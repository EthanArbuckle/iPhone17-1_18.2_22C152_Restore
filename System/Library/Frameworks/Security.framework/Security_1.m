BOOL SOSPeerInfoIsViewPermitted(uint64_t a1, const void *a2)
{
  CFSetRef V0SubviewSet;

  V0SubviewSet = (const __CFSet *)SOSViewsGetV0SubviewSet();
  return (!CFSetContainsValue(V0SubviewSet, a2) || (SOSVisibleKeychainNotAllowed() & 1) == 0)
      && SOSViewsQuery(a1, a2, 0) < 3;
}

BOOL SOSViewSetIntersectsV0(const __CFSet *a1)
{
  uint64_t V0ViewSet = SOSViewsGetV0ViewSet();
  BOOL v3 = 0;
  uint64_t v6 = 0;
  v7 = &v6;
  uint64_t v8 = 0x2020000000;
  char v9 = 1;
  if (a1 && V0ViewSet)
  {
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = __CFSetIntersectionIsEmpty_block_invoke;
    v5[3] = &unk_1E547BE98;
    v5[4] = &v6;
    v5[5] = V0ViewSet;
    CFSetApplyFunction(a1, (CFSetApplierFunction)apply_block_1_7623, v5);
    BOOL v3 = *((unsigned char *)v7 + 24) == 0;
  }
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_18B362458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CFSetIntersectionIsEmpty_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t result = CFSetContainsValue(*(CFSetRef *)(a1 + 40), a2);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (result) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = *(unsigned char *)(v4 + 24) == 0;
  }
  char v6 = !v5;
  *(unsigned char *)(v4 + 24) = v6;
  return result;
}

BOOL SOSPeerInfoV0ViewsEnabled(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  CFSetRef v1 = SOSPeerInfoCopyEnabledViews(a1);
  BOOL v2 = SOSViewSetIntersectsV0(v1);
  if (v1) {
    CFRelease(v1);
  }
  return v2;
}

uint64_t SOSPeerInfoHasUserVisibleViewsEnabled(uint64_t result)
{
  if (result)
  {
    CFSetRef v1 = SOSPeerInfoCopyEnabledViews(result);
    if (SOSViewsGetUserVisibleSet_onceToken != -1) {
      dispatch_once(&SOSViewsGetUserVisibleSet_onceToken, &__block_literal_global_7624);
    }
    uint64_t v4 = 0;
    BOOL v5 = &v4;
    uint64_t v6 = 0x2020000000;
    char v7 = 1;
    if (v1 && SOSViewsGetUserVisibleSet_subViewSet)
    {
      v3[0] = MEMORY[0x1E4F143A8];
      v3[1] = 3221225472;
      v3[2] = __CFSetIntersectionIsEmpty_block_invoke;
      v3[3] = &unk_1E547BE98;
      v3[4] = &v4;
      v3[5] = SOSViewsGetUserVisibleSet_subViewSet;
      CFSetApplyFunction(v1, (CFSetApplierFunction)apply_block_1_7623, v3);
      BOOL v2 = *((unsigned char *)v5 + 24) == 0;
      _Block_object_dispose(&v4, 8);
    }
    else
    {
      _Block_object_dispose(&v4, 8);
      BOOL v2 = 0;
      uint64_t result = 0;
      if (!v1) {
        return result;
      }
    }
    CFRelease(v1);
    return v2;
  }
  return result;
}

void sub_18B36262C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id CreateXPCObjectWithCFSetRef(const __CFSet *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    size_t v10 = der_sizeof_set(a1, (uint64_t)a2);
    if (v10)
    {
      size_t v11 = v10;
      v12 = malloc_type_malloc(v10, 0x86C9D424uLL);
      if (v12)
      {
        v13 = v12;
        der_encode_set_repair(a1, a2, 0);
        xpc_object_t v14 = xpc_data_create(v13, v11);
        free(v13);
        goto LABEL_5;
      }
    }
  }
  else
  {
    SecCFCreateErrorWithFormat(2, (const __CFString *)sSecXPCErrorDomain, 0, a2, a5, @"Unexpected Null Set to encode", a7, a8, v16);
  }
  xpc_object_t v14 = 0;
LABEL_5:

  return v14;
}

uint64_t __CFSecRecoveryKeyGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef CFSecRecoveryKeyCopyDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, @"<SecRecoveryKey: %p>", a1);
}

CFStringRef CFSecRecoveryKeyCopyFormatDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, @"<SecRecoveryKey: %p>", a1);
}

void CFSecRecoveryKeyDestroy(uint64_t a1)
{
  BOOL v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    *(void *)(a1 + 16) = 0;
    CFRelease(v2);
  }
}

__CFString *SecRKCreateRecoveryKeyString(void *a1)
{
  id v7 = 0;
  CFStringRef v2 = SecPasswordGenerate(4, (const __CFDictionary **)&v7, 0);
  if (v2)
  {
    BOOL v3 = (__CFString *)v2;
    if (ValidateRecoveryKey(v2, a1))
    {
      uint64_t v4 = v3;
      goto LABEL_10;
    }
    uint64_t v4 = v3;
    goto LABEL_9;
  }
  uint64_t v4 = (__CFString *)v7;
  if (a1)
  {
    id v5 = v7;
    uint64_t v4 = 0;
    *a1 = v5;
    goto LABEL_10;
  }
  if (v7)
  {
    id v7 = 0;
LABEL_9:
    CFRelease(v4);
    uint64_t v4 = 0;
  }
LABEL_10:

  return v4;
}

BOOL ValidateRecoveryKey(CFStringRef theString, void *a2)
{
  id v6 = 0;
  BOOL v3 = SecPasswordValidatePasswordFormat(4, theString, (__CFString **)&v6);
  if (!v3)
  {
    id v4 = v6;
    if (a2)
    {
      *a2 = v6;
    }
    else if (v6)
    {
      id v6 = 0;
      CFRelease(v4);
    }
  }
  return v3;
}

void *SecRKCreateRecoveryKey(void *a1)
{
  return SecRKCreateRecoveryKeyWithError(a1, 0);
}

void *SecRKCreateRecoveryKeyWithError(void *a1, void *a2)
{
  BOOL v3 = a1;
  if (!ValidateRecoveryKey(v3, a2)) {
    goto LABEL_9;
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __CFSecRecoveryKeyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &CFSecRecoveryKeyGetTypeID_sCFSecRecoveryKeyGetTypeIDSingleton;
  if (CFSecRecoveryKeyGetTypeID_sCFSecRecoveryKeyGetTypeIDOnce != -1) {
    dispatch_once(&CFSecRecoveryKeyGetTypeID_sCFSecRecoveryKeyGetTypeIDOnce, block);
  }
  Instance = (void *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
    }
    CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, v3, 0x8000100u, 0);
    Instance[2] = ExternalRepresentation;
    if (!ExternalRepresentation)
    {
      CFRelease(Instance);
LABEL_9:
      Instance = 0;
    }
  }

  return Instance;
}

__CFString *SecRKCopyAccountRecoveryPassword(uint64_t a1)
{
  CFSetRef v1 = SecRKCreateDerivedSecret(a1, 32);
  if (v1)
  {
    CFDataRef v2 = v1;
    CFDataGetBytePtr(v1);
    size_t v3 = (2 * (((unint64_t)(CFDataGetLength(v2) + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
    if (v3 >= 0x400) {
      __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
    }
    id v4 = (UInt8 *)malloc_type_malloc(v3, 0x2337017FuLL);
    if (v4)
    {
      id v5 = v4;
      BytePtr = (unsigned __int8 *)CFDataGetBytePtr(v2);
      CFIndex Length = CFDataGetLength(v2);
      SecBase64Encode_(BytePtr, Length, v5, v3, 0, &v10);
      if (SecCFAllocatorZeroize_sOnce != -1) {
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
      }
      uint64_t v8 = (__CFString *)CFStringCreateWithBytes((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, v5, v3, 0x8000100u, 0);
      cc_clear();
      free(v5);
    }
    else
    {
      uint64_t v8 = 0;
    }
    CFRelease(v2);
  }
  else
  {
    uint64_t v8 = 0;
  }

  return v8;
}

__CFData *SecRKCreateDerivedSecret(uint64_t a1, CFIndex a2)
{
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  CFDataSetLength(Mutable, a2);
  if (Mutable)
  {
    ccsha256_di();
    CFDataGetLength(*(CFDataRef *)(a1 + 16));
    CFDataGetBytePtr(*(CFDataRef *)(a1 + 16));
    CFDataGetLength(Mutable);
    CFDataGetMutableBytePtr(Mutable);
    if (cchkdf())
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

id SecRKCopyAccountRecoveryVerifier(void *a1, void *a2)
{
  v18[5] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v16 = 0;
  if (connectAppleIDFrameworkSymbols_onceToken != -1) {
    dispatch_once(&connectAppleIDFrameworkSymbols_onceToken, &__block_literal_global_7704);
  }
  if (connectAppleIDFrameworkSymbols_framework) {
    BOOL v4 = localProtocolSRPGROUP == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4 || localAppleIDauthSupportCreateVerifierPtr == 0)
  {
    SOSCreateErrorWithFormat(1041, 0, (CFTypeRef *)&v16, 0, @"%@", @"Recovery Key Creation Not Supported on this platform");
    id v6 = 0;
    if (a2) {
      *a2 = v16;
    }
  }
  else
  {
    id v7 = (void *)CFDataCreateWithRandomBytes(0x20uLL);
    id v8 = (id)localProtocolSRPGROUP;
    char v9 = (void *)localAppleIDauthSupportCreateVerifierPtr(localProtocolSRPGROUP, @"foo", v7, &unk_1ED86CC78, v3, &v16);
    int v10 = SecRKCreateRecoveryKeyWithError(v3, 0);
    size_t v11 = SecRKCreateDerivedSecret((uint64_t)v10, 32);
    v12 = v11;
    if (v9 && v11)
    {
      v17[0] = @"s";
      v17[1] = @"i";
      v18[0] = v7;
      v18[1] = &unk_1ED86CC78;
      v17[2] = @"p";
      v17[3] = @"v";
      v18[2] = v8;
      v18[3] = v9;
      v17[4] = @"mkid";
      v18[4] = v11;
      v13 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v18 forKeys:v17 count:5];
    }
    else
    {
      v13 = 0;
      if (a2 && v16)
      {
        id v14 = v16;
        v13 = 0;
        *a2 = v14;
      }
    }
    id v6 = v13;
  }

  return v6;
}

void *__connectAppleIDFrameworkSymbols_block_invoke()
{
  localAppleIDauthSupportCreateVerifierPtr = 0;
  localProtocolSRPGROUP = 0;
  uint64_t result = dlopen("/System/Library/PrivateFrameworks/AppleIDAuthSupport.framework/AppleIDAuthSupport", 2);
  connectAppleIDFrameworkSymbols_framework = (uint64_t)result;
  if (result)
  {
    CFSetRef v1 = (uint64_t *)dlsym(result, "kAppleIDAuthSupportProtocolSRPGROUP2048SHA256PBKDF");
    if (v1) {
      uint64_t v2 = *v1;
    }
    else {
      uint64_t v2 = 0;
    }
    localProtocolSRPGROUP = v2;
    uint64_t result = dlsym((void *)connectAppleIDFrameworkSymbols_framework, "AppleIDAuthSupportCreateVerifier");
    localAppleIDauthSupportCreateVerifierPtr = (uint64_t (*)(void, void, void, void, void, void))result;
  }
  return result;
}

__CFData *SecRKCopyBackupFullKey(uint64_t a1)
{
  return RKBackupCreateECKey(a1, 1);
}

__CFData *RKBackupCreateECKey(uint64_t a1, char a2)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = MEMORY[0x18C12DA70]();
  MEMORY[0x1F4188790](v4);
  unint64_t v6 = 0;
  do
  {
    id v7 = (void *)((char *)&v14[v6 / 8] - v5);
    void *v7 = 0xAAAAAAAAAAAAAAAALL;
    v7[1] = 0xAAAAAAAAAAAAAAAALL;
    v6 += 16;
  }
  while (v5 != v6);
  id v8 = SecRKCreateDerivedSecret(a1, 128);
  if (v8)
  {
    CFDataRef v9 = v8;
    CFDataGetLength(v8);
    CFDataGetBytePtr(v9);
    ccrng();
    if (ccec_generate_key_deterministic())
    {
      Mutable = 0;
    }
    else
    {
      CFIndex v10 = (unint64_t)(cczp_bitlen() + 7) >> 3 << a2;
      if (SecCFAllocatorZeroize_sOnce != -1) {
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
      }
      Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
      CFDataSetLength(Mutable, v10);
      if (Mutable)
      {
        CFDataGetMutableBytePtr(Mutable);
        ccec_compact_export();
      }
    }
    CFRelease(v9);
  }
  else
  {
    Mutable = 0;
  }
  v12 = Mutable;

  return v12;
}

__CFData *SecRKCopyBackupPublicKey(uint64_t a1)
{
  return RKBackupCreateECKey(a1, 0);
}

uint64_t SecRKRegisterBackupPublicKey(uint64_t a1, CFTypeRef *a2)
{
  ECKey = RKBackupCreateECKey(a1, 0);
  if (ECKey)
  {
    uint64_t v4 = ECKey;
    uint64_t v5 = SOSCCRegisterRecoveryPublicKey((uint64_t)ECKey, a2);
    CFRelease(v4);
    return v5;
  }
  else
  {
    SOSCreateErrorWithFormat(1034, 0, a2, 0, @"%@", @"Failed to create key from rk");
    return 0;
  }
}

const SecAsn1Template *NSS_TimeChooser(uint64_t a1, int a2, unsigned char *a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    int v5 = *(unsigned __int8 *)(a5 + 16);
  }
  else
  {
    if (!a4)
    {
      int v5 = 0;
      goto LABEL_9;
    }
    int v5 = *a3 & 0x1F;
    *(unsigned char *)(a5 + 16) = v5;
  }
  if (v5 == 24) {
    return kSecAsn1GeneralizedTimeTemplate;
  }
LABEL_9:
  id v7 = (uint64_t *)&off_1E547C1F8;
  uint64_t result = kSecAsn1GeneralizedTimeTemplate;
  while (1)
  {
    uint64_t v8 = *v7;
    if (!*v7) {
      break;
    }
    int v9 = *((unsigned __int8 *)v7 - 8);
    v7 += 2;
    if (v5 == v9) {
      return (const SecAsn1Template *)v8;
    }
  }
  return result;
}

void *PR_getThreadErrInfo(int a1, int *a2)
{
  if ((PR_threadKeyInitFlag & 1) == 0)
  {
    pthread_mutex_lock(&PR_threadKeyLock);
    if (!a1 && PR_threadKeyErrorFlag)
    {
      pthread_mutex_unlock(&PR_threadKeyLock);
      uint64_t v4 = 0;
      int v5 = -5991;
LABEL_15:
      *a2 = v5;
      return v4;
    }
    if ((PR_threadKeyInitFlag & 1) == 0)
    {
      int v6 = pthread_key_create((pthread_key_t *)&PR_threadKey, MEMORY[0x1E4F14838]);
      if (v6)
      {
        int v7 = v6;
        PR_threadKeyErrorFlag = 1;
        pthread_mutex_unlock(&PR_threadKeyLock);
        uint64_t v4 = 0;
        *a2 = v7;
        return v4;
      }
      PR_threadKeyErrorFlag = 0;
      PR_threadKeyInitFlag = 1;
    }
    pthread_mutex_unlock(&PR_threadKeyLock);
  }
  *a2 = 0;
  uint64_t v8 = pthread_getspecific(PR_threadKey);
  uint64_t v4 = v8;
  if (a1 && !v8)
  {
    int v9 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
    uint64_t v4 = v9;
    if (!v9)
    {
      int v5 = -6000;
      goto LABEL_15;
    }
    *int v9 = 0;
    pthread_setspecific(PR_threadKey, v9);
  }
  return v4;
}

const SecAsn1Template *NSS_ATVChooser(uint64_t a1, int a2, unsigned char *a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    int v5 = *(unsigned __int8 *)(a5 + 16);
  }
  else
  {
    if (!a4)
    {
      int v5 = 0;
      goto LABEL_9;
    }
    int v5 = *a3 & 0x1F;
    *(unsigned char *)(a5 + 16) = v5;
  }
  if (v5 == 19) {
    return kSecAsn1PrintableStringTemplate;
  }
LABEL_9:
  int v7 = (uint64_t *)&off_1E547C798;
  uint64_t result = kSecAsn1PrintableStringTemplate;
  while (1)
  {
    uint64_t v8 = *v7;
    if (!*v7) {
      break;
    }
    int v9 = *((unsigned __int8 *)v7 - 8);
    v7 += 2;
    if (v5 == v9) {
      return (const SecAsn1Template *)v8;
    }
  }
  return result;
}

void *NSS_genNameChooser(uint64_t a1, int a2, unsigned char *a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    int v5 = *(unsigned __int8 *)(a5 + 16);
    if (!*(unsigned char *)(a5 + 16)) {
      return &kSecAsn1OtherNameTemplate;
    }
  }
  else
  {
    if (!a4) {
      return &kSecAsn1OtherNameTemplate;
    }
    int v5 = *a3 & 0x1F;
    *(unsigned char *)(a5 + 16) = v5;
    if (!v5) {
      return &kSecAsn1OtherNameTemplate;
    }
  }
  int v6 = (uint64_t *)&off_1E547C808;
  uint64_t result = &kSecAsn1OtherNameTemplate;
  while (1)
  {
    uint64_t v8 = *v6;
    if (!*v6) {
      break;
    }
    int v9 = *((unsigned __int8 *)v6 - 8);
    v6 += 2;
    if (v5 == v9) {
      return (void *)v8;
    }
  }
  return result;
}

uint64_t SecAsn1TaggedTemplateChooser(uint64_t a1, int a2, unsigned char *a3, uint64_t a4, uint64_t a5, unsigned __int8 *a6)
{
  if (a2)
  {
    int v6 = *(unsigned __int8 *)(a5 + 16);
  }
  else if (a4)
  {
    int v6 = *a3 & 0x1F;
    *(unsigned char *)(a5 + 16) = v6;
  }
  else
  {
    int v6 = 0;
  }
  uint64_t result = *((void *)a6 + 1);
  if (result && v6 != *a6)
  {
    for (i = (uint64_t *)(a6 + 24); ; i += 2)
    {
      uint64_t v9 = *i;
      if (!*i) {
        break;
      }
      int v10 = *((unsigned __int8 *)i - 8);
      if (v6 == v10) {
        return v9;
      }
    }
  }
  return result;
}

const SecAsn1Template *NSS_P7_ContentInfoChooser(uint64_t a1, int a2)
{
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_Data))
  {
    int v4 = 1;
    int v5 = kSecAsn1PointerToOctetStringTemplate;
    goto LABEL_10;
  }
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_EncryptedData))
  {
    int v4 = 6;
    int v5 = (const SecAsn1Template *)&NSS_P7_PtrToEncryptedDataTemplate;
    goto LABEL_10;
  }
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_SignedData))
  {
    int v4 = 2;
LABEL_9:
    int v5 = kSecAsn1PointerToAnyTemplate;
    goto LABEL_10;
  }
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_EnvelopedData))
  {
    int v4 = 3;
    goto LABEL_9;
  }
  int v5 = kSecAsn1PointerToAnyTemplate;
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_SignedAndEnvelopedData))
  {
    int v4 = 4;
  }
  else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_DigestedData))
  {
    int v4 = 5;
  }
  else
  {
    int v5 = 0;
    int v4 = 0;
  }
LABEL_10:
  if (!a2) {
    *(_DWORD *)(a1 + 16) = v4;
  }
  return v5;
}

uint64_t PL_ArenaAllocate(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  unsigned int v3 = (v2 + a2) & ~v2;
  if (v3 < a2) {
    return 0;
  }
  int v6 = *(void **)(a1 + 32);
  unint64_t v7 = (v2 + a2) & ~v2;
  do
  {
    uint64_t result = v6[3];
    if (v7 <= v6[2] - result)
    {
      *(void *)(a1 + 32) = v6;
      v6[3] = result + v7;
      return result;
    }
    int v6 = (void *)*v6;
  }
  while (v6);
  if (*(_DWORD *)(a1 + 40) > v3) {
    unsigned int v3 = *(_DWORD *)(a1 + 40);
  }
  unint64_t v8 = v2 + 32;
  if (v8 > ~v3) {
    return 0;
  }
  unint64_t v9 = v3 + v8;
  if (v9 <= 1) {
    size_t v10 = 1;
  }
  else {
    size_t v10 = v3 + v8;
  }
  size_t v11 = malloc_type_malloc(v10, 0x7C9B19FDuLL);
  uint64_t result = ((unint64_t)v11 + *(void *)(a1 + 48) + 32) & ~*(void *)(a1 + 48);
  BOOL v12 = __CFADD__(result, v7);
  if (v11) {
    BOOL v13 = !v12;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13)
  {
    free(v11);
    return 0;
  }
  if (!v11) {
    return 0;
  }
  v11[2] = (char *)v11 + v9;
  v11[3] = result + v7;
  id v14 = *(void **)(a1 + 32);
  *size_t v11 = *v14;
  v11[1] = result;
  *id v14 = v11;
  *(void *)(a1 + 32) = v11;
  if (!*(void *)a1) {
    *(void *)a1 = v11;
  }
  return result;
}

char *PL_ArenaGrow(uint64_t a1, char *a2, unsigned int a3, unsigned int a4)
{
  if (a3 > 0x7FFFFFFE || a4 > 0x7FFFFFFE) {
    return 0;
  }
  int v6 = (void *)a1;
  uint64_t v7 = *(void *)(a1 + 48);
  unsigned int v8 = (v7 + a3) & ~v7;
  if (v8 > 0x7FFFFFFE) {
    return 0;
  }
  int v11 = v8 + a4;
  if (v8 + a4 <= 2 * v8) {
    int v11 = 2 * v8;
  }
  unsigned int v12 = (v7 + v11) & ~v7;
  if (v12 > 0x7FFFFFFE) {
    return 0;
  }
  uint64_t v15 = *(void *)(a1 + 32);
  BOOL v13 = *(char **)(v15 + 24);
  if ((unint64_t)v12 <= *(void *)(v15 + 16) - (void)v13)
  {
    *(void *)(v15 + 24) = &v13[v12];
    if (!v13) {
      return v13;
    }
  }
  else
  {
    BOOL v13 = (char *)PL_ArenaAllocate(a1, v12);
    if (!v13) {
      return v13;
    }
  }
  *(void *)(v6[4] + 24) = &v13[~*((_DWORD *)v6 + 12) & (v6[6] + a4 + a3)];
  memcpy(v13, a2, a3);
  id v16 = (void *)*v6;
  if (*v6)
  {
    while (1)
    {
      v17 = v16;
      if ((char *)v16[1] == a2 && &a2[v8] == (char *)v16[3]) {
        break;
      }
      id v16 = (void *)*v16;
      int v6 = v17;
      if (!*v17) {
        return v13;
      }
    }
    *int v6 = *v16;
    free(v16);
  }
  return v13;
}

uint64_t SEC_ASN1EncoderUpdate(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v4 = a2;
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(a1 + 16);
  if (v6 == 3)
  {
    int v6 = 2;
    *(_DWORD *)(a1 + 16) = 2;
  }
  if (a2) {
    BOOL v7 = a3 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  uint64_t v8 = v7;
  unint64_t v9 = a3 + 1;
  while (2)
  {
    if (v6 != 2) {
      goto LABEL_143;
    }
    uint64_t v10 = *(void *)(a1 + 8);
    switch(*(_DWORD *)(v10 + 40))
    {
      case 0:
        int v91 = 0;
        uint64_t v11 = *(void *)(v10 + 48);
        if (v11 == 1024) {
          goto LABEL_14;
        }
        if ((v11 & 0x100000) != 0)
        {
          v40 = *(unsigned int **)(v10 + 8);
          if (!v40[6])
          {
LABEL_57:
            *(_DWORD *)(*(void *)v10 + 16) = 1;
            goto LABEL_96;
          }
          v41 = *(_DWORD **)(v10 + 16);
          v42 = (int *)(v40 + 12);
          uint64_t v43 = 1;
          while (*v41 != *(v42 - 2))
          {
            ++v43;
            int v44 = *v42;
            v42 += 6;
            if (!v44) {
              goto LABEL_57;
            }
          }
          *(_DWORD *)(v10 + 40) = 8;
          uint64_t v55 = *(void *)v10;
          uint64_t v56 = (uint64_t)&v40[6 * v43];
          uint64_t v57 = (uint64_t)v41 - v40[1];
          goto LABEL_73;
        }
        if (*(_DWORD *)(*(void *)v10 + 20) && *(_DWORD *)(v10 + 72))
        {
          unint64_t v32 = v3;
          uint64_t v33 = v4;
          unint64_t v34 = v9;
          uint64_t v35 = v8;
          if (*(_DWORD *)(*(void *)v10 + 24)) {
            BOOL v36 = 1;
          }
          else {
            BOOL v36 = *(_DWORD *)(v10 + 68) == 0;
          }
        }
        else
        {
          unint64_t v32 = v3;
          uint64_t v33 = v4;
          unint64_t v34 = v9;
          uint64_t v35 = v8;
          BOOL v36 = 0;
        }
        char v45 = *(unsigned char *)(v10 + 45);
        char v46 = *(unsigned char *)(v10 + 44);
        unint64_t v47 = sec_asn1e_contents_length(*(_DWORD **)(v10 + 8), *(unint64_t **)(v10 + 16), *(_DWORD *)(v10 + 80), v36, &v91);
        if (v91 || (unint64_t v52 = v47) == 0 && *(_DWORD *)(v10 + 76))
        {
          *(_DWORD *)(v10 + 40) = 4;
          uint64_t v48 = *(void *)v10;
          uint64_t v8 = v35;
          unint64_t v9 = v34;
          uint64_t v4 = v33;
          unint64_t v3 = v32;
          if (*(_DWORD *)(*(void *)v10 + 20) && *(_DWORD *)(v10 + 72) && *(_DWORD *)(v48 + 24)) {
            goto LABEL_95;
          }
          goto LABEL_96;
        }
        if (v36)
        {
          unint64_t v52 = 0;
          *(_DWORD *)(v10 + 64) = 1;
          v46 |= 0x20u;
        }
        LOBYTE(v92) = v46 | v45;
        (*(void (**)(void, unint64_t *, uint64_t, void, void))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), &v92, 1, *(unsigned int *)(v10 + 56), 0);
        int v53 = *(_DWORD *)(v10 + 64);
        char v93 = -86;
        unint64_t v92 = 0xAAAAAAAAAAAAAAAALL;
        if (v53)
        {
          LOBYTE(v92) = 0x80;
          uint64_t v54 = 1;
          uint64_t v8 = v35;
          unint64_t v9 = v34;
          uint64_t v4 = v33;
          unint64_t v3 = v32;
        }
        else
        {
          uint64_t v8 = v35;
          unint64_t v9 = v34;
          if (v52 < 0x80)
          {
            LOBYTE(v92) = v52;
            uint64_t v54 = 1;
            uint64_t v4 = v33;
            unint64_t v3 = v32;
          }
          else
          {
            uint64_t v75 = 0;
            unint64_t v76 = v52;
            uint64_t v4 = v33;
            unint64_t v3 = v32;
            do
            {
              uint64_t v77 = v75++;
              BOOL v15 = v76 >= 0x100;
              v76 >>= 8;
            }
            while (v15);
            uint64_t v54 = v77 + 2;
            LOBYTE(v92) = v75 | 0x80;
            unint64_t v78 = v52;
            do
            {
              *((unsigned char *)&v92 + v75) = v78;
              v78 >>= 8;
              --v75;
            }
            while (v75);
          }
        }
        (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), &v92, v54, *(unsigned int *)(v10 + 56), 1);
        if (!v52 && !*(_DWORD *)(v10 + 64)) {
          goto LABEL_12;
        }
        if (*(_DWORD *)(v10 + 60))
        {
          *(_DWORD *)(v10 + 40) = 4;
          uint64_t v80 = *(void *)(v10 + 8);
          uint64_t v79 = *(void *)(v10 + 16);
          v81 = *(uint64_t (***)(void, uint64_t, void, void))(v80 + 8);
          if (v81 && (*(unsigned char *)(v80 + 1) & 0x40) != 0)
          {
            if (*v81)
            {
              if (v79) {
                uint64_t v82 = v79 - *(unsigned int *)(v80 + 4);
              }
              else {
                uint64_t v82 = 0;
              }
              v81 = (uint64_t (**)(void, uint64_t, void, void))(*v81)(v82, 1, 0, 0);
              uint64_t v79 = *(void *)(v10 + 16);
            }
            else
            {
              v81 = 0;
            }
          }
          uint64_t v88 = *(void *)v10;
          uint64_t v86 = v79;
LABEL_130:
          uint64_t v89 = sec_asn1e_push_state(v88, (uint64_t)v81, v86, 1);
          if (v89) {
            sec_asn1e_init_state_based_on_template(v89);
          }
          goto LABEL_96;
        }
        uint64_t v83 = *(void *)(v10 + 48);
        if ((unint64_t)(v83 - 16) < 2)
        {
          *(_DWORD *)(v10 + 40) = 3;
          uint64_t v55 = *(void *)v10;
          uint64_t v56 = *(void *)(v10 + 8) + 24;
          uint64_t v57 = *(void *)(v10 + 16);
LABEL_73:
          uint64_t v58 = sec_asn1e_push_state(v55, v56, v57, 1);
          if (v58)
          {
            uint64_t v23 = v58;
            uint64_t v59 = *(void *)v58;
            v60 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)v58 + 32);
            if (v60)
            {
              uint64_t v61 = *(unsigned int *)(v58 + 56);
              uint64_t v62 = *(void *)(v58 + 16);
              *(_DWORD *)(v59 + 48) = 1;
              v60(*(void *)(v59 + 40), 1, v62, v61);
              *(_DWORD *)(v59 + 48) = 0;
            }
LABEL_35:
            sec_asn1e_init_state_based_on_template(v23);
          }
          goto LABEL_96;
        }
        if ((unint64_t)(v83 - 8208) > 1)
        {
LABEL_14:
          *(_DWORD *)(v10 + 40) = 1;
          goto LABEL_96;
        }
        v84 = *(uint64_t ***)(v10 + 16);
        v85 = *v84;
        if (*v84)
        {
          uint64_t v86 = *v85;
          if (*v85)
          {
            *(_DWORD *)(v10 + 40) = 2;
            uint64_t v87 = *(void *)(v10 + 8);
            v81 = *(uint64_t (***)(void, uint64_t, void, void))(v87 + 8);
            if (v81 && (*(unsigned char *)(v87 + 1) & 0x40) != 0)
            {
              if (*v81)
              {
                v81 = (uint64_t (**)(void, uint64_t, void, void))(*v81)((char *)v84- *(unsigned int *)(v87 + 4), 1, 0, 0);
                uint64_t v86 = *v85;
              }
              else
              {
                v81 = 0;
              }
            }
            uint64_t v88 = *(void *)v10;
            goto LABEL_130;
          }
        }
        goto LABEL_12;
      case 1:
        if (*(_DWORD *)(a1 + 24))
        {
          if ((v8 & 1) == 0)
          {
            if (*(void *)(v10 + 48) != 1024)
            {
              LOBYTE(v92) = *(void *)(v10 + 48);
              (*(void (**)(void, unint64_t *, uint64_t, void, void))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), &v92, 1, *(unsigned int *)(v10 + 56), 0);
              if (*(void *)(v10 + 48) == 3)
              {
                char v93 = -86;
                unint64_t v92 = 0xAAAAAAAAAAAAAAAALL;
                if (v9 < 0x80)
                {
                  LOBYTE(v92) = v9;
                  uint64_t v16 = 1;
                }
                else
                {
                  uint64_t v12 = 0;
                  unint64_t v13 = v9;
                  do
                  {
                    uint64_t v14 = v12++;
                    BOOL v15 = v13 >= 0x100;
                    v13 >>= 8;
                  }
                  while (v15);
                  uint64_t v16 = v14 + 2;
                  LOBYTE(v92) = v12 | 0x80;
                  unint64_t v17 = v9;
                  do
                  {
                    *((unsigned char *)&v92 + v12) = v17;
                    v17 >>= 8;
                    --v12;
                  }
                  while (v12);
                }
                (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), &v92, v16, *(unsigned int *)(v10 + 56), 1);
                LOBYTE(v92) = 0;
                (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), &v92, 1, *(unsigned int *)(v10 + 56), 2);
              }
              else
              {
                unint64_t v92 = 0xAAAAAAAAAAAAAAAALL;
                char v93 = -86;
                if (v3 < 0x80)
                {
                  LOBYTE(v92) = v3;
                  uint64_t v66 = 1;
                }
                else
                {
                  uint64_t v63 = 0;
                  unint64_t v64 = v3;
                  do
                  {
                    uint64_t v65 = v63++;
                    BOOL v15 = v64 >= 0x100;
                    v64 >>= 8;
                  }
                  while (v15);
                  uint64_t v66 = v65 + 2;
                  LOBYTE(v92) = v63 | 0x80;
                  unint64_t v67 = v3;
                  do
                  {
                    *((unsigned char *)&v92 + v63) = v67;
                    v67 >>= 8;
                    --v63;
                  }
                  while (v63);
                }
                (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), &v92, v66, *(unsigned int *)(v10 + 56), 1);
              }
            }
            (*(void (**)(void, uint64_t, unint64_t, void, uint64_t))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), v4, v3, *(unsigned int *)(v10 + 56), 2);
          }
          uint64_t v48 = *(void *)v10;
LABEL_95:
          *(_DWORD *)(v48 + 16) = 3;
          goto LABEL_96;
        }
        uint64_t v37 = *(void *)(v10 + 48);
        if (v37 > 15)
        {
          if ((unint64_t)(v37 - 16) < 2) {
            goto LABEL_12;
          }
          if (v37 == 28)
          {
            v38 = *(uint64_t **)(v10 + 16);
            uint64_t v39 = *v38;
            if ((*v38 & 3) != 0)
            {
LABEL_83:
              *(_DWORD *)(*(void *)v10 + 16) = 1;
              goto LABEL_12;
            }
            goto LABEL_88;
          }
          if (v37 == 30)
          {
            v38 = *(uint64_t **)(v10 + 16);
            uint64_t v39 = *v38;
            if (*v38) {
              goto LABEL_83;
            }
            goto LABEL_88;
          }
LABEL_87:
          v38 = *(uint64_t **)(v10 + 16);
          uint64_t v39 = *v38;
LABEL_88:
          (*(void (**)(void, uint64_t, uint64_t, void, uint64_t))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), v38[1], v39, *(unsigned int *)(v10 + 56), 2);
          goto LABEL_12;
        }
        if (v37 != 2)
        {
          if (v37 == 3)
          {
            v49 = *(void **)(v10 + 16);
            unint64_t v50 = *v49 + 7;
            unint64_t v51 = v50 >> 3;
            LOBYTE(v92) = (v50 & 0xF8) - *v49;
            (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), &v92, 1, *(unsigned int *)(v10 + 56), 2);
            (*(void (**)(void, void, unint64_t, void, uint64_t))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), v49[1], v51, *(unsigned int *)(v10 + 56), 2);
            goto LABEL_12;
          }
          goto LABEL_87;
        }
        v68 = *(uint64_t **)(v10 + 16);
        uint64_t v69 = *v68;
        if (*v68)
        {
          v70 = (char *)v68[1];
          int v71 = *(_DWORD *)(v10 + 84);
          int v72 = *v70;
          if ((*v70 & 0x80000000) == 0)
          {
            uint64_t v73 = v69;
            v74 = v70;
            goto LABEL_134;
          }
LABEL_139:
          uint64_t v73 = v69;
          v74 = v70;
          if (v71)
          {
LABEL_134:
            while (!v72)
            {
              uint64_t v69 = v73 - 1;
              if (v73 == 1) {
                break;
              }
              v70 = v74 + 1;
              if (v74[1] < 0)
              {
                if (v71) {
                  break;
                }
              }
              int v72 = v74[1];
              --v73;
              ++v74;
              if ((v72 & 0x80) != 0) {
                goto LABEL_139;
              }
            }
            (*(void (**)(void, char *, uint64_t, void, uint64_t))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), v74, v73, *(unsigned int *)(v10 + 56), 2);
          }
          else
          {
            LOBYTE(v92) = 0;
            (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), &v92, 1, *(unsigned int *)(v10 + 56), 2);
            (*(void (**)(void, char *, uint64_t, void, uint64_t))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), v70, v69, *(unsigned int *)(v10 + 56), 2);
          }
        }
LABEL_12:
        *(_DWORD *)(v10 + 40) = 4;
LABEL_96:
        int v6 = *(_DWORD *)(a1 + 16);
        if (v6 == 1) {
          goto LABEL_143;
        }
        if (*(void *)(a1 + 8)) {
          continue;
        }
        int v6 = 0;
LABEL_142:
        *(_DWORD *)(a1 + 16) = v6;
LABEL_143:
        if (v6 == 1) {
          return 0xFFFFFFFFLL;
        }
        else {
          return 0;
        }
      case 2:
        uint64_t v18 = *(void *)(v10 + 32);
        v19 = **(uint64_t ***)(v10 + 16);
        uint64_t v20 = *(unsigned int *)(*(void *)(v18 + 8) + 4);
        do
          uint64_t v21 = *v19++;
        while (v21 != *(void *)(v18 + 16) - v20);
        uint64_t v22 = *v19;
        if (!v22)
        {
          *(_DWORD *)(v18 + 40) = 9;
          goto LABEL_12;
        }
        *(void *)(v18 + 16) = v22 + v20;
        *(_DWORD *)(v18 + 40) = 0;
        *(_DWORD *)(v18 + 64) = 0;
LABEL_39:
        *(void *)(*(void *)v10 + 8) = v18;
        goto LABEL_96;
      case 3:
        uint64_t v23 = *(void *)(v10 + 32);
        uint64_t v24 = *(void *)v10;
        v25 = *(void (**)(void, void, uint64_t, uint64_t))(*(void *)v10 + 32);
        if (v25)
        {
          uint64_t v26 = *(unsigned int *)(v23 + 56);
          uint64_t v27 = *(void *)(v23 + 16);
          *(_DWORD *)(v24 + 48) = 1;
          v25(*(void *)(v24 + 40), 0, v27, v26);
          *(_DWORD *)(v24 + 48) = 0;
        }
        uint64_t v28 = *(void *)(v23 + 8);
        int v29 = *(_DWORD *)(v28 + 24);
        *(void *)(v23 + 8) = v28 + 24;
        if (!v29)
        {
          *(_DWORD *)(v23 + 40) = 9;
          goto LABEL_12;
        }
        *(void *)(v23 + 16) = *(void *)(v10 + 16) + *(unsigned int *)(v28 + 28);
        uint64_t v30 = *(void *)v10;
        v31 = *(void (**)(void, uint64_t))(*(void *)v10 + 32);
        if (v31)
        {
          *(_DWORD *)(v30 + 48) = 1;
          v31(*(void *)(v30 + 40), 1);
          *(_DWORD *)(v30 + 48) = 0;
          uint64_t v30 = *(void *)v10;
        }
        *(void *)(v30 + 8) = v23;
        goto LABEL_35;
      case 4:
        if (*(_DWORD *)(v10 + 64))
        {
          LOWORD(v92) = 0;
          (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56))(*(void *)(*(void *)v10 + 64), &v92, 2, *(unsigned int *)(v10 + 56), 3);
        }
        uint64_t v18 = *(void *)(v10 + 24);
        goto LABEL_39;
      case 5:
      case 6:
      case 7:
      case 8:
        goto LABEL_12;
      default:
        int v6 = 1;
        goto LABEL_142;
    }
  }
}

uint64_t sec_asn1e_push_state(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t result = PORT_ArenaAlloc(*(void *)a1, 0x58uLL);
  if (result)
  {
    *(_OWORD *)(result + 16) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(void *)(result + 80) = 0;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(void *)(result + 24) = v8;
    *(void *)uint64_t result = a1;
    *(void *)(result + 8) = a2;
    *(_DWORD *)(result + 40) = 9;
    if (a3) {
      *(void *)(result + 16) = a3 + *(unsigned int *)(a2 + 4);
    }
    if (v8)
    {
      int v10 = *(_DWORD *)(v8 + 56);
      if (a4) {
        ++v10;
      }
      *(_DWORD *)(result + 56) = v10;
      *(void *)(v8 + 32) = result;
    }
    *(void *)(a1 + 8) = result;
  }
  else
  {
    *(_DWORD *)(a1 + 16) = 1;
  }
  return result;
}

uint64_t sec_asn1e_init_state_based_on_template(uint64_t a1)
{
  do
  {
    uint64_t v2 = *(unsigned int **)(a1 + 8);
    unint64_t v3 = *v2;
    unint64_t v4 = v3 & 0x200;
    uint64_t v5 = (v3 >> 8) & 1;
    if ((v3 & 0x100000) != 0)
    {
      unsigned int v14 = (v3 >> 18) & 1;
      LODWORD(v15) = (v3 >> 21) & 1;
      unint64_t v18 = 0x100000;
LABEL_39:
      LODWORD(v16) = v3;
      goto LABEL_40;
    }
    BOOL v6 = (v3 & 0xC0) != 0 && v4 == 0;
    char v7 = !v6;
    if (v3 & 0x1800) == 0 && (v7)
    {
      unsigned int v14 = (v3 >> 18) & 1;
      LODWORD(v15) = (v3 >> 21) & 1;
      unint64_t v18 = v3 & 0xFF5BBCFF;
      goto LABEL_39;
    }
    *(_DWORD *)(a1 + 64) = 0;
    uint64_t v8 = *(uint64_t **)(a1 + 16);
    if ((v3 & 0x1000) != 0)
    {
      uint64_t v9 = *v8;
      *(_DWORD *)(a1 + 40) = 7;
      if ((v3 & 0x100) != 0 && v9 == 0) {
        return a1;
      }
    }
    else
    {
      if ((v3 & 0x800) != 0)
      {
        *(_DWORD *)(a1 + 40) = 6;
      }
      else
      {
        *(unsigned char *)(a1 + 44) = v3 & 0xE0;
        *(unsigned char *)(a1 + 45) = v3 & 0x1F;
        *(_DWORD *)(a1 + 40) = 5;
        *(_DWORD *)(a1 + 76) = v5;
      }
      uint64_t v9 = (uint64_t)v8;
    }
    uint64_t v11 = (uint64_t (**)(char *, uint64_t, void, void))*((void *)v2 + 1);
    if (v11 && (v3 & 0x4000) != 0)
    {
      if (*v11)
      {
        if (v8) {
          uint64_t v12 = (char *)v8 - v2[1];
        }
        else {
          uint64_t v12 = 0;
        }
        uint64_t v11 = (uint64_t (**)(char *, uint64_t, void, void))(*v11)(v12, 1, 0, 0);
      }
      else
      {
        uint64_t v11 = 0;
      }
    }
    uint64_t v13 = sec_asn1e_push_state(*(void *)a1, (uint64_t)v11, v9, 0);
    a1 = v13;
    if (!v13) {
      return a1;
    }
  }
  while ((v3 & 0xC0) == 0);
  unsigned int v14 = (v3 >> 18) & 1;
  unint64_t v15 = (v3 & 0x200000) >> 21;
  uint64_t v16 = **(unsigned int **)(v13 + 8);
  if ((v3 & 0x200000) != 0) {
    unsigned int v17 = (v3 >> 18) & 1;
  }
  else {
    unsigned int v17 = 1;
  }
  if ((v16 & 0x40000) != 0)
  {
    unsigned int v14 = v17;
    unint64_t v18 = v16 & 0xFFFFFFFFFFFBFFFFLL;
  }
  else
  {
    unint64_t v18 = **(unsigned int **)(v13 + 8);
  }
LABEL_40:
  unint64_t v19 = v4 >> 9;
  if ((v3 & 0x400) != 0)
  {
    char v30 = 0;
    char v24 = 0;
    int v29 = 1;
  }
  else
  {
    char v20 = v16 & 0x1F;
    unsigned int v21 = (v16 >> 9) & 1;
    char v22 = v16 & 0x20 | v3 & 0xE0;
    if ((v3 & 0x4000) != 0)
    {
      LODWORD(v19) = v21;
      char v23 = v22;
    }
    else
    {
      char v23 = v3 & 0xE0;
    }
    if ((v3 & 0x4000) != 0) {
      char v24 = v20;
    }
    else {
      char v24 = v3 & 0x1F;
    }
    uint64_t v25 = 1 << (v18 & 0x1F);
    char v26 = v23 | 0x20;
    if ((v25 & 0x30000) == 0) {
      char v26 = v23;
    }
    BOOL v6 = (v25 & 0x55D81018) == 0;
    BOOL v27 = (v25 & 0x55D81018) != 0;
    if (v6) {
      char v28 = v26;
    }
    else {
      char v28 = v23;
    }
    int v29 = (v18 & 0x1F) != 0x1F && v27;
    if ((v18 & 0x1F) == 0x1F) {
      char v30 = v23;
    }
    else {
      char v30 = v28;
    }
  }
  *(unsigned char *)(a1 + 44) = v30;
  *(unsigned char *)(a1 + 45) = v24;
  *(void *)(a1 + 48) = v18;
  *(_DWORD *)(a1 + 68) = v29;
  *(_DWORD *)(a1 + 72) = v14;
  *(_DWORD *)(a1 + 76) = v5;
  *(_DWORD *)(a1 + 80) = v15;
  *(_DWORD *)(a1 + 84) = (v3 >> 23) & 1;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 60) = v19;
  *(_DWORD *)(a1 + 64) = 0;
  return a1;
}

unint64_t sec_asn1e_contents_length(_DWORD *a1, unint64_t *a2, unsigned int a3, uint64_t a4, int *a5)
{
  uint64_t v8 = a1;
  unsigned int v9 = *a1;
  if ((*a1 & 0x200000) != 0) {
    uint64_t v10 = 1;
  }
  else {
    uint64_t v10 = a3;
  }
  if ((v9 & 0x100000) != 0)
  {
    while (v8[6])
    {
      unsigned int v14 = v8 + 12;
      uint64_t v15 = 1;
      while (*(_DWORD *)a2 != *(v14 - 2))
      {
        ++v15;
        int v16 = *v14;
        v14 += 6;
        if (!v16) {
          return 0;
        }
      }
      uint64_t v17 = (uint64_t)a2 - v8[1];
      v8 += 6 * v15;
      unsigned int v9 = *v8;
      a2 = (unint64_t *)(v17 + v8[1]);
      if ((*v8 & 0x200000) != 0) {
        uint64_t v10 = 1;
      }
      else {
        uint64_t v10 = v10;
      }
      if ((v9 & 0x100000) == 0) {
        goto LABEL_5;
      }
    }
    return 0;
  }
LABEL_5:
  if ((v9 & 0x18C0) == 0)
  {
    if ((v9 & 0x20000) != 0)
    {
      unint64_t result = 0;
      int v24 = 2;
LABEL_100:
      *a5 = v24;
      return result;
    }
    uint64_t v19 = v9 & 0xFFDBBCFF;
    if ((int)(v9 & 0xFFDBBCFF) > 8207)
    {
      if ((v19 - 8208) > 1)
      {
LABEL_72:
        unint64_t v23 = *a2;
        goto LABEL_88;
      }
      uint64_t v25 = (uint64_t *)*a2;
      if (*a2)
      {
        uint64_t v26 = *((void *)v8 + 1);
        if (v26 && (v9 & 0x4000) != 0)
        {
          if (*(void *)v26) {
            uint64_t v26 = (*(uint64_t (**)(char *, uint64_t, void, void, unint64_t *))v26)((char *)a2 - v8[1], 1, 0, 0, a2);
          }
          else {
            uint64_t v26 = 0;
          }
        }
        uint64_t v39 = *v25;
        if (*v25)
        {
          unint64_t v23 = 0;
          do
          {
            unint64_t v40 = sec_asn1e_contents_length(v26, v39 + *(unsigned int *)(v26 + 4), v10, a4, a5);
            v23 += v40;
            if (!*a5)
            {
              uint64_t v41 = 1;
              if (v40 >= 0x80)
              {
                do
                {
                  ++v41;
                  BOOL v31 = v40 > 0xFF;
                  v40 >>= 8;
                }
                while (v31);
              }
              v23 += v41 + 1;
            }
            uint64_t v42 = v25[1];
            ++v25;
            uint64_t v39 = v42;
          }
          while (v42);
          goto LABEL_88;
        }
      }
    }
    else
    {
      if ((v19 - 16) >= 2)
      {
        if (v19 != 2)
        {
          if (v19 == 3)
          {
            unint64_t v20 = *a2 + 7;
            BOOL v21 = v20 >= 8;
            unint64_t v22 = v20 >> 3;
            if (v21) {
              unint64_t v23 = v22 + 1;
            }
            else {
              unint64_t v23 = 0;
            }
            goto LABEL_88;
          }
          goto LABEL_72;
        }
        unint64_t v23 = *a2;
        if (*a2)
        {
          unint64_t v34 = (unsigned char *)a2[1];
          LOBYTE(v35) = *v34;
          if (*v34)
          {
            unint64_t v36 = *a2;
LABEL_66:
            if ((*(void *)&v9 & 0x800000) == 0 && (v35 & 0x80u) != 0) {
              unint64_t v23 = v36 + 1;
            }
            else {
              unint64_t v23 = v36;
            }
          }
          else
          {
            v38 = v34 + 1;
            while (1)
            {
              unint64_t v36 = v23 - 1;
              if (v23 == 1) {
                break;
              }
              int v35 = *v38;
              if (v35 < 0) {
                break;
              }
              ++v38;
              --v23;
              if ((_BYTE)v35) {
                goto LABEL_66;
              }
            }
          }
        }
LABEL_88:
        if (a4) {
          BOOL v43 = v23 == 0;
        }
        else {
          BOOL v43 = 0;
        }
        __int16 v44 = v43;
        if (((v10 == 0) & *(_DWORD *)&v44 & (v9 >> 18)) != 0) {
          unint64_t result = 1;
        }
        else {
          unint64_t result = v23;
        }
        if ((v9 & 0x100) == 0 || result)
        {
          if (v19 != 1024) {
            goto LABEL_104;
          }
          int v24 = 1;
          goto LABEL_100;
        }
        goto LABEL_99;
      }
      BOOL v27 = v8 + 6;
      if (v8[6])
      {
        unint64_t v23 = 0;
        do
        {
          uint64_t v28 = v8[7];
          uint64_t v8 = v27;
          unint64_t v29 = sec_asn1e_contents_length(v27, (char *)a2 + v28, v10, a4, a5);
          v23 += v29;
          if (!*a5)
          {
            uint64_t v30 = 1;
            if (v29 >= 0x80)
            {
              do
              {
                ++v30;
                BOOL v31 = v29 > 0xFF;
                v29 >>= 8;
              }
              while (v31);
            }
            v23 += v30 + 1;
          }
          BOOL v27 = v8 + 6;
        }
        while (v8[6]);
        goto LABEL_88;
      }
    }
    unint64_t v23 = 0;
    goto LABEL_88;
  }
  uint64_t v11 = *((void *)v8 + 1);
  if (v11 && (v9 & 0x4000) != 0)
  {
    uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, void, void, unint64_t *))v11;
    if (*(void *)v11)
    {
      if (a2) {
        uint64_t v13 = (uint64_t)a2 - v8[1];
      }
      else {
        uint64_t v13 = 0;
      }
      uint64_t v11 = v12(v13, 1, 0, 0, a2);
      if ((v9 & 0x1000) == 0) {
        goto LABEL_53;
      }
      goto LABEL_33;
    }
    uint64_t v11 = 0;
  }
  if ((v9 & 0x1000) == 0) {
    goto LABEL_53;
  }
LABEL_33:
  a2 = (unint64_t *)*a2;
  if (!a2)
  {
    unint64_t result = 0;
    if ((v9 & 0x100) != 0) {
      int v24 = 3;
    }
    else {
      int v24 = 0;
    }
    goto LABEL_100;
  }
LABEL_53:
  unint64_t result = sec_asn1e_contents_length(v11, (char *)a2 + *(unsigned int *)(v11 + 4), v10, a4, a5);
  if ((v9 & 0x100) != 0 && !result)
  {
LABEL_99:
    int v24 = 3;
    goto LABEL_100;
  }
  if ((v9 & 0x200) != 0)
  {
    if (*a5)
    {
      if (*a5 != 1) {
        return result;
      }
LABEL_104:
      *a5 = 0;
      return result;
    }
    uint64_t v32 = 1;
    if (result >= 0x80)
    {
      unint64_t v33 = result;
      do
      {
        ++v32;
        BOOL v31 = v33 > 0xFF;
        v33 >>= 8;
      }
      while (v31);
    }
    result += v32 + 1;
  }
  return result;
}

uint64_t SEC_ASN1EncoderStart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = PORT_NewArena(2048);
  if (!v8) {
    return 0;
  }
  unsigned int v9 = v8;
  uint64_t v10 = PORT_ArenaAlloc((uint64_t)v8, 0x48uLL);
  if (!v10) {
    goto LABEL_5;
  }
  uint64_t v11 = v10;
  *(_OWORD *)(v10 + 8) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *(_OWORD *)(v10 + 24) = 0u;
  *(void *)uint64_t v10 = v9;
  *(void *)(v10 + 56) = a3;
  *(void *)(v10 + 64) = a4;
  *(_DWORD *)(v10 + 16) = 2;
  if (!sec_asn1e_push_state(v10, a2, a1, 0) || !sec_asn1e_init_state_based_on_template(*(void *)(v11 + 8)))
  {
LABEL_5:
    PORT_FreeArena(v9, 0);
    return 0;
  }
  return v11;
}

uint64_t SEC_ASN1Encode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = SEC_ASN1EncoderStart(a1, a2, a3, a4);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = (void **)v4;
  uint64_t v6 = SEC_ASN1EncoderUpdate(v4, 0, 0);
  PORT_FreeArena(*v5, 0);
  return v6;
}

void *sec_asn1e_encode_item_count(void *result, uint64_t a2, uint64_t a3)
{
  *result += a3;
  return result;
}

void *sec_asn1e_encode_item_store(void *result, const void *a2, size_t a3)
{
  if (a3)
  {
    uint64_t v4 = result;
    unint64_t result = memcpy((void *)(result[1] + *result), a2, a3);
    *v4 += a3;
  }
  return result;
}

uint64_t sec_asn1e_allocate_item(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t v4 = (uint64_t)a2;
  if (a1)
  {
    if (a2 || (uint64_t result = PORT_ArenaAlloc(a1, 0x10uLL), (v4 = result) != 0))
    {
      uint64_t v7 = PORT_ArenaAlloc(a1, a3);
      *(void *)(v4 + 8) = v7;
      if (v7) {
        return v4;
      }
      else {
        return 0;
      }
    }
  }
  else
  {
    uint64_t v8 = a2;
    if (a2 || (result = (uint64_t)PORT_Alloc(0x10uLL), (uint64_t v8 = (void *)result) != 0))
    {
      unint64_t v9 = (unint64_t)PORT_Alloc(a3);
      v8[1] = v9;
      uint64_t result = v9 ? (uint64_t)v8 : 0;
      if (!(v4 | v9))
      {
        free(v8);
        return 0;
      }
    }
  }
  return result;
}

void *SEC_ASN1EncodeItem(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v11 = 0;
  uint64_t v8 = 0;
  if (!SEC_ASN1Encode(a3, a4, (uint64_t)sec_asn1e_encode_item_count, (uint64_t)&v11))
  {
    item = (void *)sec_asn1e_allocate_item(a1, a2, v11);
    uint64_t v8 = item;
    if (item)
    {
      if (item[1])
      {
        void *item = 0;
        SEC_ASN1Encode(a3, a4, (uint64_t)sec_asn1e_encode_item_store, (uint64_t)item);
      }
      else
      {
        return 0;
      }
    }
  }
  return v8;
}

void *SEC_ASN1EncodeInteger(uint64_t a1, void *a2, unint64_t a3)
{
  char v3 = a3;
  uint64_t v4 = -1;
  unint64_t v5 = a3;
  do
  {
    uint64_t v6 = v4++;
    BOOL v7 = v5 > 0xFF;
    v5 >>= 8;
  }
  while (v7);
  uint64_t v8 = v6 + 2;
  uint64_t result = (void *)sec_asn1e_allocate_item(a1, a2, v6 + 2);
  if (result)
  {
    *uint64_t result = v8;
    do
    {
      *(unsigned char *)(result[1] + v4) = v3;
      char v3 = 0;
      --v4;
    }
    while (v4 != -1);
  }
  return result;
}

uint64_t SecAsn1DecodeTime(uint64_t a1, double *a2)
{
  CFErrorRef err = 0;
  uint64_t v4 = PORT_NewArena(1024);
  if (!v4) {
    return 4294967188;
  }
  unint64_t v5 = v4;
  memset(v10, 170, sizeof(v10));
  uint64_t Code = SEC_ASN1Decode((uint64_t)v4, (uint64_t)v10, (uint64_t)&kSecAsn1TimeTemplate, *(char **)(a1 + 8), *(void *)a1);
  if (!Code)
  {
    double v8 = SecAbsoluteTimeFromDateContentWithError(LOBYTE(v10[2]), (unsigned __int8 *)v10[1], v10[0], &err);
    if (err)
    {
      uint64_t Code = CFErrorGetCode(err);
      CFErrorRef v9 = err;
      if (err)
      {
        CFErrorRef err = 0;
        CFRelease(v9);
      }
    }
    else
    {
      uint64_t Code = 0;
      if (a2) {
        *a2 = v8;
      }
    }
  }
  PORT_FreeArena(v5, 0);
  return Code;
}

uint64_t SecAsn1EncodeTime(uint64_t a1, uint64_t a2, CFAbsoluteTime a3)
{
  CFDateFormatterRef ISO8601Formatter = CFDateFormatterCreateISO8601Formatter(0, 0);
  if (ISO8601Formatter)
  {
    BOOL v7 = ISO8601Formatter;
    CFTimeZoneRef v8 = CFTimeZoneCreateWithTimeIntervalFromGMT(0, 0.0);
    CFDateFormatterSetProperty(v7, (CFStringRef)*MEMORY[0x1E4F1D0F8], v8);
    CFDateFormatterSetFormat(v7, @"yyyyMMddHHmmss'Z'");
    CFStringRef StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(0, v7, a3);
    CFRelease(v8);
    CFRelease(v7);
  }
  else
  {
    time_t v19 = (uint64_t)(*MEMORY[0x1E4F1CF78] + a3);
    memset(&v18, 0, sizeof(v18));
    CFStringRef StringWithAbsoluteTime = 0;
    if (gmtime_r(&v19, &v18) == &v18) {
      CFStringRef StringWithAbsoluteTime = CFStringCreateWithFormat(0, 0, @"%04d%02d%02d%02d%02d%02dZ", (v18.tm_year + 1900), (v18.tm_mon + 1), v18.tm_mday, v18.tm_hour, v18.tm_min, v18.tm_sec);
    }
  }
  CFIndex Length = CFStringGetLength(StringWithAbsoluteTime);
  if (!StringWithAbsoluteTime) {
    return 4294967188;
  }
  if (a3 < -1609459200.0 || a3 > 1546300800.0)
  {
    CFStringRef v11 = (const __CFString *)CFRetain(StringWithAbsoluteTime);
    char v12 = 24;
  }
  else
  {
    v21.length = Length - 2;
    v21.location = 2;
    CFStringRef v11 = CFStringCreateWithSubstring(0, StringWithAbsoluteTime, v21);
    char v12 = 23;
  }
  *(unsigned char *)(a2 + 16) = v12;
  CFIndex v14 = CFStringGetLength(v11);
  if (v14 < 0)
  {
    uint64_t v13 = 4294967188;
  }
  else
  {
    CFIndex v15 = v14;
    *(void *)a2 = v14;
    int v16 = (UInt8 *)PORT_ArenaAlloc(a1, v14);
    *(void *)(a2 + 8) = v16;
    uint64_t v13 = 4294967188;
    if (v16)
    {
      v20.location = 0;
      v20.length = v15;
      if (v15 == CFStringGetBytes(v11, v20, 0x8000100u, 0, 0, v16, v15, 0)) {
        uint64_t v13 = 0;
      }
      else {
        uint64_t v13 = 4294967188;
      }
    }
  }
  CFRelease(StringWithAbsoluteTime);
  if (v11) {
    CFRelease(v11);
  }
  return v13;
}

void *PORT_Alloc(size_t a1)
{
  if (a1 >> 31) {
    goto LABEL_5;
  }
  if (a1 <= 1) {
    a1 = 1;
  }
  uint64_t result = malloc_type_malloc(a1, 0x7C9B19FDuLL);
  if (!result)
  {
LABEL_5:
    ++port_allocFailures;
    ThreadErrInfo = PR_getThreadErrInfo(1, &v3);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0xFFFFE01300000000;
    }
    return 0;
  }
  return result;
}

_DWORD *PORT_SetError(int a1)
{
  uint64_t result = PR_getThreadErrInfo(1, &v3);
  if (result)
  {
    *uint64_t result = 0;
    result[1] = a1;
  }
  return result;
}

void *PORT_ZAlloc(unint64_t a1)
{
  if (a1 >> 31 || (a1 <= 1 ? (v1 = 1) : (v1 = a1), (uint64_t result = malloc_type_calloc(1uLL, v1, 0xC17C3709uLL)) == 0))
  {
    ++port_allocFailures;
    ThreadErrInfo = PR_getThreadErrInfo(1, &v4);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0xFFFFE01300000000;
    }
    return 0;
  }
  return result;
}

uint64_t PORT_GetError()
{
  int v2 = -1431655766;
  ThreadErrInfo = PR_getThreadErrInfo(0, &v2);
  if (ThreadErrInfo) {
    return *((unsigned int *)ThreadErrInfo + 1);
  }
  if (v2) {
    return 4294961322;
  }
  return 0;
}

_DWORD *PORT_NewArena(int a1)
{
  uint64_t result = PORT_ZAlloc(0x40uLL);
  if (result)
  {
    result[14] = -1196647457;
    *((void *)result + 6) = 7;
    unint64_t v3 = ((unint64_t)result + 39) & 0xFFFFFFFFFFFFFFF8;
    *((void *)result + 2) = v3;
    *((void *)result + 3) = v3;
    *(void *)uint64_t result = 0;
    *((void *)result + 1) = v3;
    *((void *)result + 4) = result;
    result[10] = a1;
  }
  return result;
}

uint64_t PORT_ArenaAlloc(uint64_t a1, unint64_t a2)
{
  if (a2 <= 1) {
    unint64_t v2 = 1;
  }
  else {
    unint64_t v2 = a2;
  }
  if (!(v2 >> 31))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    unsigned int v5 = (*(void *)(a1 + 48) + v2) & ~*(void *)(a1 + 48);
    uint64_t result = *(void *)(v4 + 24);
    if (v5 >= v2)
    {
      if (v5 <= (unint64_t)(*(void *)(v4 + 16) - result))
      {
        *(void *)(v4 + 24) = v5 + result;
        if (result) {
          return result;
        }
      }
      else
      {
        uint64_t result = PL_ArenaAllocate(a1, v5);
        if (result) {
          return result;
        }
      }
    }
  }
  ++port_allocFailures;
  ThreadErrInfo = PR_getThreadErrInfo(1, &v8);
  if (ThreadErrInfo) {
    void *ThreadErrInfo = 0xFFFFE01300000000;
  }
  return 0;
}

void PORT_FreeArena(void *a1, int a2)
{
  if (a2)
  {
    unint64_t v3 = (void *)*a1;
    if (!*a1) {
      goto LABEL_7;
    }
    do
    {
      uint64_t v4 = (void *)v3[1];
      uint64_t v5 = v3[2];
      v3[3] = v4;
      bzero(v4, v5 - (void)v4);
      unint64_t v3 = (void *)*v3;
    }
    while (v3);
  }
  while (1)
  {
    uint64_t v6 = (void *)*a1;
    if (!*a1) {
      break;
    }
    *a1 = *v6;
    free(v6);
  }
LABEL_7:

  free(a1);
}

char *PORT_ArenaGrow(uint64_t a1, char *a2, unint64_t a3, unint64_t a4)
{
  if (a4 >> 31)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v18);
    if (ThreadErrInfo)
    {
      unint64_t v5 = 0xFFFFE01300000000;
LABEL_7:
      void *ThreadErrInfo = v5;
      return 0;
    }
    return 0;
  }
  BOOL v6 = a4 >= a3;
  unsigned int v7 = a4 - a3;
  if (!v6)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v19);
    if (ThreadErrInfo)
    {
      unint64_t v5 = 0xFFFFE00100000000;
      goto LABEL_7;
    }
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = &a2[a3];
  unint64_t v11 = (unint64_t)&v10[v7];
  if (v10 > a2 && v11 > (unint64_t)a2 && v11 > (unint64_t)v10)
  {
    uint64_t v15 = *(void *)(a1 + 48);
    unint64_t v16 = (v15 + v11) & ~v15;
    BOOL v17 = *(char **)(v9 + 24) != &a2[~v15 & (v15 + a3)] || v11 > v16;
    if (!v17 && *(void *)(v9 + 16) >= v16)
    {
      *(void *)(v9 + 24) = v16;
      return a2;
    }
  }

  return PL_ArenaGrow(a1, a2, a3, v7);
}

BOOL nssCompareSecAsn1Items(BOOL result, uint64_t a2)
{
  if (result)
  {
    unint64_t v2 = (size_t *)result;
    uint64_t result = 0;
    if (a2)
    {
      unint64_t v3 = (const void *)v2[1];
      if (v3) {
        return *(void *)(a2 + 8) && *v2 == *(void *)a2 && memcmp(v3, *(const void **)(a2 + 8), *v2) == 0;
      }
    }
  }
  return result;
}

const SecAsn1Template *NSS_P12_CertBagChooser(uint64_t a1, int a2)
{
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS9_X509Certificate))
  {
    int v4 = 1;
    uint64_t result = kSecAsn1OctetStringTemplate;
    if (a2) {
      return result;
    }
    goto LABEL_3;
  }
  BOOL v6 = nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS9_SdsiCertificate);
  BOOL v7 = v6;
  if (v6) {
    uint64_t result = kSecAsn1IA5StringTemplate;
  }
  else {
    uint64_t result = 0;
  }
  int v4 = 2 * v7;
  if (!a2) {
LABEL_3:
  }
    *(_DWORD *)(a1 + 16) = v4;
  return result;
}

const SecAsn1Template *NSS_P12_CrlBagChooser(uint64_t a1, int a2)
{
  BOOL v4 = nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS9_X509Crl);
  if (!a2) {
    *(_DWORD *)(a1 + 16) = v4;
  }
  if (v4) {
    return kSecAsn1OctetStringTemplate;
  }
  else {
    return 0;
  }
}

const SecAsn1Template *NSS_P12_SafeBagChooser(uint64_t a1, int a2)
{
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_keyBag))
  {
    int v4 = 1;
    unint64_t v5 = kSecAsn1PointerToAnyTemplate;
  }
  else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_shroudedKeyBag))
  {
    int v4 = 2;
    unint64_t v5 = (const SecAsn1Template *)&NSS_P12_PtrToShroudedKeyBagTemplate;
  }
  else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_certBag))
  {
    int v4 = 3;
    unint64_t v5 = (const SecAsn1Template *)&NSS_P12_PtrToCertBagTemplate;
  }
  else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_crlBag))
  {
    int v4 = 4;
    unint64_t v5 = (const SecAsn1Template *)&NSS_P12_PtrToCrlBagTemplate;
  }
  else
  {
    unint64_t v5 = kSecAsn1PointerToAnyTemplate;
    if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_secretBag))
    {
      int v4 = 5;
    }
    else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_safeContentsBag))
    {
      int v4 = 6;
    }
    else
    {
      unint64_t v5 = 0;
      int v4 = 0;
    }
  }
  if (!a2) {
    *(_DWORD *)(a1 + 16) = v4;
  }
  return v5;
}

uint64_t SEC_ASN1DecodeInteger(uint64_t *a1, uint64_t *a2)
{
  if (!a1)
  {
    unint64_t v3 = (int *)&v9;
    goto LABEL_13;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 9)
  {
    unint64_t v3 = (int *)&v10;
LABEL_13:
    ThreadErrInfo = PR_getThreadErrInfo(1, v3);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0xFFFFE00500000000;
    }
    return 0xFFFFFFFFLL;
  }
  int v4 = (unsigned __int8 *)a1[1];
  if (!v4)
  {
    unint64_t v3 = (int *)&v11;
    goto LABEL_13;
  }
  uint64_t v5 = (uint64_t)(char)*v4 >> 7;
  if (v2)
  {
    if (v2 <= 1) {
      uint64_t v2 = 1;
    }
    else {
      uint64_t v2 = v2;
    }
    do
    {
      unsigned int v6 = *v4++;
      uint64_t v5 = v6 | (unint64_t)(v5 << 8);
      --v2;
    }
    while (v2);
  }
  uint64_t result = 0;
  *a2 = v5;
  return result;
}

uint64_t SEC_ASN1DecoderUpdate(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  int v7 = *(_DWORD *)(a1 + 24);
  if (v7 != 2)
  {
    if (v7 != 3)
    {
      int v8 = 0;
      goto LABEL_438;
    }
    *(_DWORD *)(a1 + 24) = 2;
  }
  uint64_t v196 = v6;
LABEL_5:
  int v8 = *(void **)(a1 + 16);
  while (2)
  {
    uint64_t result = 0;
    switch(*((_DWORD *)v8 + 12))
    {
      case 0:
        if (!a3) {
          goto LABEL_164;
        }
        char v18 = *a2;
        if ((*a2 & 0x1F) == 0x1F)
        {
          *((_DWORD *)v8 + 12) = 1;
          v8[8] = 0;
          v8[12] = 1;
        }
        else
        {
          if (!*a2 && sec_asn1d_parent_allows_EOC(v8[4]))
          {
            *((_DWORD *)v8 + 12) = 21;
            v8[12] = 2;
            v8[8] = 0;
            *((unsigned char *)v8 + 52) = 0;
            int v15 = 1;
            int v16 = *((unsigned __int8 *)v8 + 141);
            unint64_t v13 = 0;
            int v14 = 0;
            if (*((unsigned char *)v8 + 141))
            {
              int v16 = 0;
              uint64_t v160 = 0;
              *((unsigned char *)v8 + 140) = 1;
            }
            else
            {
              uint64_t v160 = 0;
            }
            goto LABEL_417;
          }
          *((_DWORD *)v8 + 12) = 2;
          v8[8] = v18 & 0x1F;
        }
        int v14 = 0;
        int v16 = 0;
        uint64_t v160 = 0;
        *((unsigned char *)v8 + 52) = v18 & 0xE0;
        unint64_t v13 = 1;
        goto LABEL_230;
      case 1:
        if (!a3)
        {
LABEL_164:
          unint64_t v13 = 0;
          int v14 = 0;
          int v16 = 0;
          uint64_t v160 = 0;
          *(_DWORD *)(*v8 + 24) = 3;
          goto LABEL_230;
        }
        unint64_t v13 = 0;
        uint64_t v19 = v8[12];
        unint64_t v20 = a3;
LABEL_19:
        --v20;
        unint64_t v21 = v13;
        while (1)
        {
          if (!v19) {
            goto LABEL_27;
          }
          unint64_t v22 = v8[8];
          if (v22 >> 57) {
            break;
          }
          v8[8] = v22 << 7;
          unint64_t v23 = v21 + 1;
          char v24 = a2[v21];
          v8[8] = v24 & 0x7F | (v22 << 7);
          if ((v24 & 0x80) == 0)
          {
            uint64_t v19 = 0;
            v8[12] = 0;
            unint64_t v13 = v23;
            if (!v20)
            {
              unint64_t v13 = a3;
LABEL_27:
              int v14 = 0;
              int v16 = 0;
              uint64_t v160 = 0;
              *((_DWORD *)v8 + 12) = 2;
LABEL_230:
              int v15 = 1;
              goto LABEL_417;
            }
            goto LABEL_19;
          }
          --v20;
          int v15 = 1;
          unint64_t v21 = v23;
          if (v20 == -1)
          {
            int v14 = 0;
            int v16 = 0;
            uint64_t v160 = 0;
            unint64_t v13 = a3;
            goto LABEL_417;
          }
        }
        ThreadErrInfo = PR_getThreadErrInfo(1, (int *)&v197);
        if (ThreadErrInfo) {
          void *ThreadErrInfo = 0xFFFFE00900000000;
        }
        unint64_t v13 = 0;
        int v14 = 0;
        int v16 = 0;
        uint64_t v160 = 0;
        int v15 = 1;
        *(_DWORD *)(*v8 + 24) = 1;
        goto LABEL_417;
      case 2:
        uint64_t v25 = v8[7];
        if ((v25 & *((unsigned char *)v8 + 52)) == (unint64_t)*((unsigned __int8 *)v8 + 53)
          && (v8[8] & v25) == v8[9])
        {
          unint64_t v13 = 0;
          int v14 = 0;
          int v15 = 0;
          int v16 = 0;
          *((_DWORD *)v8 + 12) = 3;
          goto LABEL_416;
        }
        if (!*((unsigned char *)v8 + 141)) {
          goto LABEL_172;
        }
        unint64_t v13 = 0;
        int v14 = 0;
        int v15 = 0;
        int v16 = 0;
        *((unsigned char *)v8 + 140) = 1;
        goto LABEL_273;
      case 3:
        if (!a3) {
          goto LABEL_167;
        }
        *((_DWORD *)v8 + 12) = 5;
        uint64_t v26 = *a2;
        if (*a2 < 0)
        {
          uint64_t v141 = v26 & 0x7F;
          v8[11] = 0;
          v8[12] = v141;
          if (v141) {
            *((_DWORD *)v8 + 12) = 4;
          }
          else {
            *((unsigned char *)v8 + 139) = 1;
          }
        }
        else
        {
          v8[11] = v26;
        }
        if (*((unsigned char *)v8 + 139) || (*((unsigned char *)v8 + 81) & 0x84) == 0)
        {
          int v14 = 0;
          int v15 = 0;
        }
        else
        {
          int v14 = 0;
          int v15 = 0;
          *((unsigned char *)v8 + 52) &= ~0x20u;
        }
        unint64_t v13 = 1;
        goto LABEL_323;
      case 4:
        if (!a3)
        {
LABEL_167:
          unint64_t v13 = 0;
          int v14 = 0;
          int v15 = 0;
          *(_DWORD *)(*v8 + 24) = 3;
          goto LABEL_323;
        }
        uint64_t v27 = 0;
        unint64_t v13 = v8[12];
        uint64_t v28 = a2;
        while (1)
        {
          if (!(v13 + v27)) {
            goto LABEL_234;
          }
          unint64_t v29 = v8[11];
          if (v29 >> 55) {
            break;
          }
          v8[11] = v29 << 8;
          unsigned __int8 v30 = *v28++;
          v8[11] = v30 | (v29 << 8);
          v8[12] = v13 + v27-- - 1;
          if (!(a3 + v27))
          {
            uint64_t v31 = v13 + v27;
            unint64_t v13 = a3;
            if (v31)
            {
              int v14 = 0;
              int v15 = 0;
              int v16 = 1;
              unint64_t v13 = a3;
              goto LABEL_324;
            }
LABEL_234:
            int v14 = 0;
            int v15 = 0;
            *((_DWORD *)v8 + 12) = 5;
LABEL_323:
            int v16 = 1;
            goto LABEL_324;
          }
        }
        v157 = PR_getThreadErrInfo(1, (int *)&v197);
        if (v157) {
          void *v157 = 0xFFFFE00900000000;
        }
        unint64_t v13 = 0;
        int v14 = 0;
        int v15 = 0;
        int v16 = 1;
        *(_DWORD *)(*v8 + 24) = 1;
LABEL_324:
        uint64_t v160 = 1;
        goto LABEL_417;
      case 5:
        uint64_t v32 = v8[4];
        if (!v32) {
          goto LABEL_51;
        }
        while (1)
        {
          int v33 = *(_DWORD *)(v32 + 48);
          BOOL v34 = (v33 - 16) < 4 || v33 == 11;
          if (!v34 && v33 != 24) {
            break;
          }
          uint64_t v32 = *(void *)(v32 + 32);
          if (!v32) {
            goto LABEL_51;
          }
        }
LABEL_69:
        if (*(unsigned char *)(v32 + 139))
        {
          while (1)
          {
            uint64_t v32 = *(void *)(v32 + 32);
            if (!v32) {
              break;
            }
            int v44 = *(_DWORD *)(v32 + 48);
            if ((v44 - 16) >= 4 && v44 != 24 && v44 != 11) {
              goto LABEL_69;
            }
          }
        }
        else
        {
          unint64_t v197 = *(void *)(v32 + 96);
          unint64_t v47 = v8;
LABEL_71:
          if (!sec_asn1d_check_and_subtract_length(&v197, v47[13], *v8)
            || !sec_asn1d_check_and_subtract_length(&v197, v47[11], *v8)
            || *((unsigned char *)v47 + 139) && !sec_asn1d_check_and_subtract_length(&v197, 2uLL, *v8))
          {
            goto LABEL_414;
          }
          while (1)
          {
            unint64_t v47 = (void *)v47[4];
            if (!v47) {
              break;
            }
            int v48 = *((_DWORD *)v47 + 12);
            if ((v48 - 16) >= 4 && v48 != 24 && v48 != 11)
            {
              if (*((unsigned char *)v47 + 139)) {
                goto LABEL_71;
              }
              break;
            }
          }
        }
LABEL_51:
        if (*((unsigned char *)v8 + 136))
        {
          unint64_t v36 = (char *)sec_asn1d_zalloc(*(void *)(*v8 + 8), *(unsigned int *)(v8[1] + 16));
          if (!v36) {
            goto LABEL_174;
          }
          v8[2] = &v36[*(unsigned int *)(v8[1] + 4)];
          uint64_t v37 = v8[4];
          if (*(_DWORD *)(v37 + 48) == 18) {
            **(void **)(v37 + 16) = v36;
          }
        }
        unint64_t v38 = v8[11];
        v8[12] = v38;
        if (*((unsigned char *)v8 + 138))
        {
          *((_DWORD *)v8 + 12) = 15;
          uint64_t v40 = *v8;
          uint64_t v39 = v8[1];
          uint64_t v41 = v8[2];
          uint64_t v42 = *(uint64_t (***)(uint64_t, void, char *, unint64_t))(v39 + 8);
          if (v42 && (*(unsigned char *)(v39 + 1) & 0x40) != 0)
          {
            if (*v42)
            {
              if (v41) {
                uint64_t v43 = v41 - *(unsigned int *)(v39 + 4);
              }
              else {
                uint64_t v43 = 0;
              }
              uint64_t v42 = (uint64_t (**)(uint64_t, void, char *, unint64_t))(*v42)(v43, 0, a2, a3);
              uint64_t v41 = v8[2];
            }
            else
            {
              uint64_t v42 = 0;
            }
          }
          v171 = sec_asn1d_push_state(v40, (uint64_t)v42, v41, 1);
          if (!v171) {
            goto LABEL_414;
          }
          goto LABEL_413;
        }
        uint64_t v137 = v8[10];
        if ((v137 & 0x2000) != 0)
        {
          if (!v38)
          {
            int v15 = *((unsigned __int8 *)v8 + 139);
            if (!*((unsigned char *)v8 + 139))
            {
              unint64_t v13 = 0;
              int v14 = 0;
              int v16 = 0;
LABEL_248:
              int v17 = 14;
              goto LABEL_274;
            }
          }
          *((_DWORD *)v8 + 12) = 9;
          uint64_t v162 = v8[1];
          v163 = *(uint64_t (***)(uint64_t, void, char *, unint64_t))(v162 + 8);
          if (v163 && (*(unsigned char *)(v162 + 1) & 0x40) != 0)
          {
            if (*v163)
            {
              uint64_t v164 = v8[2];
              if (v164) {
                uint64_t v165 = v164 - *(unsigned int *)(v162 + 4);
              }
              else {
                uint64_t v165 = 0;
              }
              v163 = (uint64_t (**)(uint64_t, void, char *, unint64_t))(*v163)(v165, 0, a2, a3);
            }
            else
            {
              v163 = 0;
            }
          }
          v177 = sec_asn1d_push_state(*v8, (uint64_t)v163, 0, 1);
          unint64_t v13 = (unint64_t)v177;
          if (!v177)
          {
LABEL_415:
            int v14 = 0;
            int v15 = 0;
            int v16 = 0;
            goto LABEL_416;
          }
          uint64_t v178 = *(void *)v177;
          if (!*(_DWORD *)(*(void *)v177 + 72)) {
            v177[136] = 1;
          }
LABEL_368:
          v179 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(v178 + 32);
          if (v179)
          {
            uint64_t v180 = *(unsigned int *)(v13 + 112);
            uint64_t v181 = *(void *)(v13 + 16);
            *(_DWORD *)(v178 + 48) = 1;
            v179(*(void *)(v178 + 40), 1, v181, v180);
            *(_DWORD *)(v178 + 48) = 0;
          }
          v171 = (void *)v13;
          goto LABEL_413;
        }
        if (v137 <= 1023)
        {
          switch(v137)
          {
            case 3:
            case 4:
            case 12:
            case 19:
            case 20:
            case 22:
            case 23:
            case 26:
              goto LABEL_239;
            case 5:
              if (v38 || *((unsigned char *)v8 + 139)) {
                goto LABEL_172;
              }
              v187 = (void *)v8[2];
              if (v187)
              {
                void *v187 = 0;
                v187[1] = 0;
              }
              goto LABEL_271;
            case 16:
              *((_DWORD *)v8 + 12) = 12;
              v188 = sec_asn1d_push_state(*v8, v8[1] + 24, v8[2], 1);
              unint64_t v13 = (unint64_t)v188;
              if (!v188) {
                goto LABEL_415;
              }
              uint64_t v178 = *v188;
              goto LABEL_368;
            case 17:
              goto LABEL_172;
            case 28:
              if ((v38 & 3) == 0) {
                goto LABEL_239;
              }
              goto LABEL_172;
            case 30:
              if ((v38 & 1) == 0) {
                goto LABEL_239;
              }
              goto LABEL_172;
            default:
              goto LABEL_339;
          }
        }
        if (v137 != 1024 && v137 != 0x8000 && v137 != 66560)
        {
LABEL_339:
          if (v38)
          {
            v172 = (void *)v8[2];
            if (!v172)
            {
LABEL_426:
              unint64_t v13 = 0;
              int v14 = 0;
              int v15 = 0;
              int v16 = 0;
              int v17 = 10;
              goto LABEL_274;
            }
            void *v172 = 0;
            if (*(_DWORD *)(*v8 + 72))
            {
              v172[1] = 0;
              goto LABEL_426;
            }
            v189 = sec_asn1d_zalloc(*(void *)(*v8 + 8), v38);
            v172[1] = v189;
            if (v189) {
              goto LABEL_426;
            }
LABEL_174:
            unint64_t v13 = 0;
            int v14 = 0;
            int v15 = 0;
            int v16 = 0;
            *(_DWORD *)(*v8 + 24) = 1;
            goto LABEL_416;
          }
LABEL_172:
          v118 = PR_getThreadErrInfo(1, (int *)&v197);
          if (v118) {
LABEL_173:
          }
            void *v118 = 0xFFFFE00900000000;
          goto LABEL_174;
        }
LABEL_239:
        v138 = (void *)v8[2];
        if (!v138) {
          goto LABEL_346;
        }
        v139 = (uint64_t *)*v8;
        if (*(_DWORD *)(*v8 + 72))
        {
          uint64_t v140 = 0;
          void *v138 = 0;
          v138[1] = 0;
          goto LABEL_347;
        }
        if (*((unsigned char *)v8 + 142))
        {
          if (v138[1])
          {
LABEL_346:
            uint64_t v140 = 0;
            goto LABEL_347;
          }
        }
        else
        {
          ++v139;
          void *v138 = 0;
          v138[1] = 0;
        }
        uint64_t v140 = *v139;
        if (v38)
        {
          v176 = v8 + 15;
          uint64_t v175 = v8[15];
          if (!v175)
          {
LABEL_375:
            v183 = sec_asn1d_zalloc(v140, v38);
            v138[1] = v183;
            if (!v183) {
              goto LABEL_174;
            }
            uint64_t v184 = *v176;
            if (*v176)
            {
              uint64_t v185 = 0;
              do
              {
                memcpy((void *)(v138[1] + v185), *(const void **)v184, *(void *)(v184 + 8));
                uint64_t v186 = *(void *)(v184 + 8);
                uint64_t v184 = *(void *)(v184 + 16);
                v185 += v186;
              }
              while (v184);
            }
            else
            {
              uint64_t v185 = 0;
            }
            void *v138 = v185;
            v8[15] = 0;
            v8[16] = 0;
            unint64_t v38 = v8[11];
            goto LABEL_348;
          }
          do
          {
LABEL_374:
            uint64_t v182 = *(void *)(v175 + 8);
            uint64_t v175 = *(void *)(v175 + 16);
            v38 += v182;
          }
          while (v175);
          goto LABEL_375;
        }
LABEL_347:
        if (*((unsigned char *)v8 + 139) || (v176 = v8 + 15, (uint64_t v175 = v8[15]) == 0))
        {
LABEL_348:
          if (!v38)
          {
            int v15 = *((unsigned __int8 *)v8 + 139);
            if (!*((unsigned char *)v8 + 139))
            {
              unint64_t v13 = 0;
              int v14 = 0;
              goto LABEL_272;
            }
          }
          if ((*((unsigned char *)v8 + 52) & 0x20) == 0)
          {
            if (!*((unsigned char *)v8 + 139))
            {
              if (v8[10] == 3)
              {
                unint64_t v13 = 0;
                int v14 = 0;
                int v15 = 0;
                int v16 = 0;
                int v17 = 6;
                goto LABEL_274;
              }
              goto LABEL_426;
            }
            goto LABEL_172;
          }
          uint64_t v173 = v8[10];
          if (v173 > 1023)
          {
            if (v173 == 1024)
            {
              v174 = kSecAsn1AnyTemplate;
            }
            else if (v173 == 0x8000)
            {
              v174 = kSecAsn1SkipTemplate;
            }
            else
            {
              v174 = kSecAsn1AnyTemplate;
              if (v173 != 66560) {
LABEL_399:
              }
                v174 = 0;
            }
          }
          else
          {
            switch(v173)
            {
              case 12:
                v174 = kSecAsn1UTF8StringTemplate;
                break;
              case 13:
              case 14:
              case 15:
              case 16:
              case 17:
              case 18:
              case 21:
              case 25:
              case 27:
              case 29:
                goto LABEL_399;
              case 19:
                v174 = kSecAsn1PrintableStringTemplate;
                break;
              case 20:
                v174 = kSecAsn1T61StringTemplate;
                break;
              case 22:
                v174 = kSecAsn1IA5StringTemplate;
                break;
              case 23:
                v174 = kSecAsn1UTCTimeTemplate;
                break;
              case 24:
                v174 = kSecAsn1GeneralizedTimeTemplate;
                break;
              case 26:
                v174 = kSecAsn1VisibleStringTemplate;
                break;
              case 28:
                v174 = kSecAsn1UniversalStringTemplate;
                break;
              case 30:
                v174 = kSecAsn1BMPStringTemplate;
                break;
              default:
                if (v173 == 3)
                {
                  v174 = kSecAsn1BitStringTemplate;
                }
                else
                {
                  if (v173 != 4) {
                    goto LABEL_399;
                  }
                  v174 = kSecAsn1OctetStringTemplate;
                }
                break;
            }
          }
          *((_DWORD *)v8 + 12) = 8;
          v171 = sec_asn1d_push_state(*v8, (uint64_t)v174, (uint64_t)v138, 1);
          if (!v171) {
            goto LABEL_414;
          }
          *((unsigned char *)v171 + 142) = 1;
LABEL_413:
          sec_asn1d_init_state_based_on_template(v171, (uint64_t)a2, a3);
LABEL_414:
          unint64_t v13 = 0;
          goto LABEL_415;
        }
        if (!v138) {
          goto LABEL_172;
        }
        unint64_t v38 = 0;
        goto LABEL_374;
      case 6:
        uint64_t v51 = v8[12];
        if (!v51)
        {
          v116 = (void *)v8[2];
          if (v116)
          {
            unint64_t v13 = 0;
            int v14 = 0;
            int v15 = 0;
            int v16 = 0;
            void *v116 = 0;
            v116[1] = 0;
            uint64_t v160 = 2;
            int v117 = 20;
            goto LABEL_170;
          }
        }
        if (!a3)
        {
          unint64_t v13 = 0;
          int v14 = 0;
          int v15 = 0;
          int v16 = 0;
          *(_DWORD *)(*v8 + 24) = 3;
          goto LABEL_416;
        }
        unsigned int v52 = *a2;
        if (v52 >= 8) {
          goto LABEL_172;
        }
        int v14 = 0;
        int v15 = 0;
        int v16 = 0;
        *((_DWORD *)v8 + 29) = v52;
        *((_DWORD *)v8 + 12) = 7;
        v8[12] = v51 - 1;
        uint64_t v160 = 2;
        unint64_t v13 = 1;
        goto LABEL_417;
      case 7:
        if (v8[12]) {
          goto LABEL_90;
        }
        int v15 = *((_DWORD *)v8 + 29);
        if (v15) {
          goto LABEL_172;
        }
        unint64_t v13 = 0;
        int v14 = 0;
        int v16 = 0;
        goto LABEL_13;
      case 8:
        uint64_t v53 = v8[5];
        unint64_t v54 = *(void *)(v53 + 104);
        *(void *)(v53 + 104) = 0;
        unint64_t v55 = v8[12];
        v8[13] += v54;
        if (v55)
        {
          BOOL v56 = v55 >= v54;
          unint64_t v57 = v55 - v54;
          if (!v56) {
            goto LABEL_172;
          }
          v8[12] = v57;
          if (v57) {
            goto LABEL_95;
          }
        }
        else
        {
          v119 = *(unint64_t **)(v53 + 16);
          v120 = v8;
          while (v119 == (unint64_t *)v120[2])
          {
            if (!*((unsigned char *)v120 + 139)) {
              break;
            }
            uint64_t v121 = v120[4];
            if (!v121) {
              break;
            }
            while (1)
            {
              int v122 = *(_DWORD *)(v121 + 48);
              BOOL v123 = (v122 - 16) < 4 || v122 == 24;
              if (!v123 && v122 != 11) {
                break;
              }
              uint64_t v121 = *(void *)(v121 + 32);
              if (!v121) {
                goto LABEL_219;
              }
            }
            if (*(void *)(v121 + 80) != v120[10]) {
              break;
            }
            v120 = (void *)v121;
            if (!*(unsigned char *)(v121 + 139))
            {
              char v125 = 1;
              goto LABEL_220;
            }
          }
LABEL_219:
          char v125 = 0;
LABEL_220:
          if (v119)
          {
            v136 = (void *)v119[1];
            if (!v136) {
              char v125 = 1;
            }
            if ((v125 & 1) == 0)
            {
              sec_asn1d_add_to_subitems((uint64_t **)v8, v136, *v119, 0);
              unint64_t *v119 = 0;
              v119[1] = 0;
            }
          }
          if (!*(unsigned char *)(v53 + 137))
          {
LABEL_95:
            unint64_t v13 = 0;
            int v14 = 0;
            int v15 = 0;
            int v16 = 0;
            *(_DWORD *)(v53 + 48) = 0;
            *(unsigned char *)(v53 + 137) = 0;
            *(_WORD *)(v53 + 139) = 0;
            goto LABEL_109;
          }
        }
        unint64_t v13 = 0;
        int v14 = 0;
        int v15 = 0;
        int v16 = 0;
        *(_DWORD *)(v53 + 48) = 26;
        int v17 = 13;
        goto LABEL_274;
      case 9:
        uint64_t v53 = v8[5];
        unint64_t v58 = *(void *)(v53 + 104);
        *(void *)(v53 + 104) = 0;
        v8[13] += v58;
        if (*(unsigned char *)(v53 + 137) && !*(unsigned char *)(v53 + 139))
        {
          v142 = *(void **)(v53 + 16);
          if (v142 && !v8[15])
          {
            sec_asn1d_add_to_subitems((uint64_t **)v8, v142, 0, 0);
            *(void *)(v53 + 16) = 0;
          }
        }
        else
        {
          uint64_t v59 = *v8;
          v60 = *(void (**)(void, void, uint64_t, uint64_t))(*v8 + 32);
          if (v60)
          {
            uint64_t v61 = *(unsigned int *)(v53 + 112);
            uint64_t v62 = *(void *)(v53 + 16);
            *(_DWORD *)(v59 + 48) = 1;
            v60(*(void *)(v59 + 40), 0, v62, v61);
            *(_DWORD *)(v59 + 48) = 0;
          }
          uint64_t v63 = *(void *)(v53 + 16);
          if (v63)
          {
            sec_asn1d_add_to_subitems((uint64_t **)v8, (void *)(v63 - *(unsigned int *)(*(void *)(v53 + 8) + 4)), 0, 0);
            *(void *)(v53 + 16) = 0;
          }
          unint64_t v64 = v8[12];
          if (!v64) {
            goto LABEL_106;
          }
          BOOL v56 = v64 >= v58;
          unint64_t v65 = v64 - v58;
          if (!v56) {
            goto LABEL_172;
          }
          v8[12] = v65;
          if (v65)
          {
LABEL_106:
            uint64_t v66 = *v8;
            unint64_t v67 = *(void (**)(void, uint64_t, void, uint64_t))(*v8 + 32);
            if (v67)
            {
              uint64_t v68 = *(unsigned int *)(v53 + 112);
              *(_DWORD *)(v66 + 48) = 1;
              v67(*(void *)(v66 + 40), 1, 0, v68);
              *(_DWORD *)(v66 + 48) = 0;
            }
            *(_DWORD *)(v53 + 48) = 0;
            *(unsigned char *)(v53 + 137) = 0;
            *(_WORD *)(v53 + 139) = 0;
            sec_asn1d_init_state_based_on_template((void *)v53, (uint64_t)a2, a3);
            unint64_t v13 = 0;
            int v14 = 0;
            int v15 = 0;
            int v16 = 0;
LABEL_109:
            *(void *)(*v8 + 16) = v53;
            goto LABEL_416;
          }
        }
        unint64_t v13 = 0;
        int v14 = 0;
        int v15 = 0;
        int v16 = 0;
        *(_DWORD *)(v53 + 48) = 26;
        goto LABEL_248;
      case 0xA:
LABEL_90:
        unint64_t v13 = sec_asn1d_parse_leaf((uint64_t)v8, a2, a3);
        goto LABEL_415;
      case 0xB:
        uint64_t v69 = a2;
        uint64_t v70 = v8[5];
        uint64_t v71 = *(void *)(v70 + 104);
        *(void *)(v70 + 104) = 0;
        int v72 = (uint64_t *)v8[2];
        if (*(void *)(v70 + 40))
        {
          *(void *)(v70 + 40) = 0;
          *(void *)(v70 + 24) = 0;
        }
        *(_DWORD *)(v70 + 48) = 20;
        uint64_t v73 = *v8;
        v74 = *(void (**)(void, void))(*v8 + 32);
        if (v74)
        {
          uint64_t v75 = *((unsigned int *)v8 + 28);
          *(_DWORD *)(v73 + 48) = 1;
          ((void (*)(void, void, uint64_t *, uint64_t))v74)(*(void *)(v73 + 40), 0, v72, v75);
          *(_DWORD *)(v73 + 48) = 0;
          unint64_t v76 = (uint64_t *)v8[2];
          uint64_t v73 = *v8;
          v74 = *(void (**)(void, void))(*v8 + 32);
        }
        else
        {
          unint64_t v76 = v72;
        }
        uint64_t v126 = v8[1];
        v127 = (char *)v76 - *(unsigned int *)(v126 + 4);
        v8[1] = v126 + 24;
        v128 = &v127[*(unsigned int *)(v126 + 28)];
        *(void *)(v70 + 8) = v126 + 24;
        *(void *)(v70 + 16) = v128;
        if (v74)
        {
          *(_DWORD *)(v73 + 48) = 1;
          v74(*(void *)(v73 + 40), 1);
          *(_DWORD *)(v73 + 48) = 0;
          uint64_t v73 = *v8;
        }
        *((_DWORD *)v8 + 12) = 19;
        *(void *)(v73 + 16) = v70;
        sec_asn1d_init_state_based_on_template((void *)v70, v72[1], *v72);
        if (!SEC_ASN1DecoderUpdate(*v8, v72[1], *v72) && *(_DWORD *)(*v8 + 24) != 3)
        {
          *(void *)(v70 + 104) = 0;
          v8[13] += v71;
          *(_DWORD *)(v70 + 48) = 26;
          *((_DWORD *)v8 + 12) = 22;
        }
        int v129 = *(_DWORD *)(a1 + 24);
        if (v129 == 1) {
          return 0xFFFFFFFFLL;
        }
        if (v129 == 3) {
          goto LABEL_453;
        }
        a2 = v69;
        unint64_t v13 = 0;
        int v14 = 0;
        int v15 = 0;
        int v16 = 0;
        uint64_t v160 = 2;
        goto LABEL_418;
      case 0xC:
        uint64_t v195 = (uint64_t)a2;
        uint64_t v77 = v8[5];
        uint64_t v78 = *v8;
        uint64_t v79 = *(void (**)(void, void, uint64_t, uint64_t))(*v8 + 32);
        if (v79)
        {
          uint64_t v80 = *(unsigned int *)(v77 + 112);
          uint64_t v81 = *(void *)(v77 + 16);
          *(_DWORD *)(v78 + 48) = 1;
          v79(*(void *)(v78 + 40), 0, v81, v80);
          *(_DWORD *)(v78 + 48) = 0;
        }
        int v82 = *(unsigned __int8 *)(v77 + 140);
        unint64_t v83 = *(void *)(v77 + 104);
        *(void *)(v77 + 104) = 0;
        if (v82) {
          goto LABEL_117;
        }
        v8[13] += v83;
        if (*(void *)(v77 + 40))
        {
          *(void *)(v77 + 40) = 0;
          *(void *)(v77 + 24) = 0;
        }
        *(_DWORD *)(v77 + 48) = 20;
        unint64_t v130 = v8[12];
        if (!v130) {
          goto LABEL_117;
        }
        BOOL v56 = v130 >= v83;
        unint64_t v131 = v130 - v83;
        if (!v56)
        {
          v132 = PR_getThreadErrInfo(1, (int *)&v197);
          if (v132) {
            void *v132 = 0xFFFFE00900000000;
          }
          unint64_t v13 = 0;
          int v14 = 0;
          int v15 = 0;
          int v16 = 0;
          *(_DWORD *)(*v8 + 24) = 1;
          goto LABEL_330;
        }
        v8[12] = v131;
        if (!v131)
        {
          v166 = (int *)(*(void *)(v77 + 8) + 24);
          a2 = (char *)v195;
          while (1)
          {
            v167 = v166;
            int v16 = *v166;
            if (!*v166) {
              break;
            }
            v166 += 6;
            if ((v16 & 0x100) == 0)
            {
              *(void *)(v77 + 8) = v167;
              goto LABEL_172;
            }
          }
          unint64_t v13 = 0;
          int v14 = 0;
          int v15 = 0;
          *(void *)(v77 + 8) = v167;
          *(_DWORD *)(v77 + 48) = 26;
          uint64_t v160 = 2;
          int v117 = 22;
LABEL_170:
          *((_DWORD *)v8 + 12) = v117;
          goto LABEL_417;
        }
LABEL_117:
        uint64_t v84 = *(void *)(v77 + 8);
        int v85 = *(_DWORD *)(v84 + 24);
        *(void *)(v77 + 8) = v84 + 24;
        if (v85)
        {
          uint64_t v86 = v8[2];
          if (v86) {
            *(void *)(v77 + 16) = v86 + *(unsigned int *)(v84 + 28);
          }
          uint64_t v87 = *v8;
          uint64_t v88 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(*v8 + 32);
          if (v88)
          {
            uint64_t v89 = *(unsigned int *)(v77 + 112);
            uint64_t v90 = *(void *)(v77 + 16);
            *(_DWORD *)(v87 + 48) = 1;
            v88(*(void *)(v87 + 40), 1, v90, v89);
            *(_DWORD *)(v87 + 48) = 0;
          }
          if (v82)
          {
            char v91 = *(unsigned char *)(v77 + 52);
            uint64_t v92 = *(void *)(v77 + 64);
          }
          else
          {
            char v91 = 0;
            uint64_t v92 = 0;
          }
          *(void *)(*v8 + 16) = v77;
          inited = sec_asn1d_init_state_based_on_template((void *)v77, v195, a3);
          int v14 = 0;
          unint64_t v13 = 0;
          uint64_t v160 = 2;
          if (!v82 || !inited)
          {
            int v15 = 0;
            int v16 = 0;
            a2 = (char *)v195;
            goto LABEL_417;
          }
          *((_DWORD *)inited + 12) = 2;
          *((unsigned char *)inited + 52) = v91;
          inited[8] = v92;
          inited[13] = v83;
          a2 = (char *)v195;
          if (inited[10] == 1024 && !*(_DWORD *)(*inited + 72))
          {
            LOBYTE(v197) = v91 | v92;
            sec_asn1d_record_any_header((uint64_t **)inited, &v197, 1uLL);
          }
LABEL_327:
          unint64_t v13 = 0;
          int v14 = 0;
          int v15 = 0;
          int v16 = 0;
          goto LABEL_417;
        }
        *(_DWORD *)(v77 + 48) = 26;
        if (!v8[12])
        {
          if (!v82)
          {
            unint64_t v13 = 0;
            int v14 = 0;
            int v15 = 0;
            int v16 = 0;
            *((_DWORD *)v8 + 12) = 20;
LABEL_330:
            uint64_t v160 = 2;
            a2 = (char *)v195;
            goto LABEL_417;
          }
          if (*((unsigned char *)v8 + 139) && *(unsigned char *)(v77 + 137))
          {
            a2 = (char *)v195;
            if (v83 != 2) {
              goto LABEL_172;
            }
            unint64_t v13 = 0;
            int v14 = 0;
            int v15 = 0;
            int v16 = 0;
            v8[13] += 2;
            goto LABEL_273;
          }
        }
        v118 = PR_getThreadErrInfo(1, (int *)&v197);
        a2 = (char *)v195;
        if (v118) {
          goto LABEL_173;
        }
        goto LABEL_174;
      case 0xD:
        uint64_t v94 = v8 + 15;
        uint64_t v93 = v8[15];
        if (!v93) {
          goto LABEL_271;
        }
        v95 = a2;
        unint64_t v96 = 0;
        uint64_t v97 = v8[10];
        do
        {
          while (2)
          {
            uint64_t v98 = *(void *)(v93 + 16);
            if (v97 == 3)
            {
              uint64_t v99 = *(void *)(v93 + 8);
              if (!v98)
              {
                unint64_t v100 = v99 + v96;
                unint64_t v96 = (v99 + v96 + 7) >> 3;
                goto LABEL_264;
              }
              if ((v99 & 7) == 0)
              {
                v96 += v99;
                uint64_t v93 = v98;
                continue;
              }
              v158 = PR_getThreadErrInfo(1, (int *)&v197);
              if (v158) {
                void *v158 = 0xFFFFE00900000000;
              }
              unint64_t v13 = 0;
LABEL_284:
              int v14 = 0;
              int v15 = 0;
              int v16 = 0;
              *(_DWORD *)(*v8 + 24) = 1;
              uint64_t v160 = 2;
              a2 = v95;
              goto LABEL_417;
            }
            break;
          }
          v96 += *(void *)(v93 + 8);
          uint64_t v93 = *(void *)(v93 + 16);
        }
        while (v98);
        unint64_t v100 = v96;
        if (v97 == 1024)
        {
          if (*((unsigned char *)v8 + 139)) {
            v96 += 2;
          }
          unint64_t v100 = v96;
        }
LABEL_264:
        v153 = (unint64_t *)v8[2];
        unint64_t v13 = (unint64_t)sec_asn1d_zalloc(*(void *)(*v8 + 8), v96);
        v153[1] = v13;
        if (!v13) {
          goto LABEL_284;
        }
        unint64_t *v153 = v100;
        for (uint64_t i = *v94; i; uint64_t i = *(void *)(i + 16))
        {
          if (v97 == 3) {
            size_t v155 = (unint64_t)(*(void *)(i + 8) + 7) >> 3;
          }
          else {
            size_t v155 = *(void *)(i + 8);
          }
          memcpy((void *)v13, *(const void **)i, v155);
          v13 += v155;
        }
        *uint64_t v94 = 0;
        v8[16] = 0;
        a2 = v95;
LABEL_271:
        unint64_t v13 = 0;
        int v14 = 0;
        int v15 = 0;
LABEL_272:
        int v16 = 0;
LABEL_273:
        int v17 = 22;
LABEL_274:
        *((_DWORD *)v8 + 12) = v17;
LABEL_416:
        uint64_t v160 = 2;
LABEL_417:
        int v129 = *(_DWORD *)(a1 + 24);
LABEL_418:
        if (v129 == 1)
        {
          uint64_t v6 = v196;
          goto LABEL_442;
        }
        if (a3 < v13)
        {
          v192 = PR_getThreadErrInfo(1, (int *)&v197);
          uint64_t v6 = v196;
          if (v192) {
            void *v192 = 0xFFFFE00900000000;
          }
          *(_DWORD *)(a1 + 24) = 1;
          if (v8) {
            goto LABEL_447;
          }
          return 0xFFFFFFFFLL;
        }
        int v8 = *(void **)(a1 + 16);
        if (!v8 || *(_DWORD *)v8[1] == 0x80000)
        {
          uint64_t result = 0;
          *(_DWORD *)(a1 + 24) = 0;
          return result;
        }
        if (!v13)
        {
          if (v129 != 2) {
            return 0;
          }
          continue;
        }
        if (v8[10] == 1024 && (v15 | v16) == 1 && !*(_DWORD *)(a1 + 72)) {
          sec_asn1d_record_any_header(*(uint64_t ***)(a1 + 16), a2, v13);
        }
        v190 = *(void (**)(void, char *, unint64_t, uint64_t, uint64_t))(*v8 + 56);
        if (v190)
        {
          uint64_t v191 = *((unsigned int *)v8 + 28);
          if (v14) {
            uint64_t v191 = v191 - (*((unsigned char *)v8 + 139) == 0);
          }
          v190(*(void *)(*v8 + 64), a2, v13, v191, v160);
        }
        v8[13] += v13;
        a2 += v13;
        int v7 = *(_DWORD *)(a1 + 24);
        a3 -= v13;
        if (v7 == 2) {
          goto LABEL_5;
        }
        uint64_t v6 = v196;
LABEL_438:
        if (v7 != 1) {
          return 0;
        }
LABEL_442:
        if (v8)
        {
LABEL_447:
          v193 = *(void **)(v6 + 32);
          do
          {
            if (v193 == v8) {
              break;
            }
            if (v8[5])
            {
              v8[5] = 0;
              v8[3] = 0;
            }
            *((_DWORD *)v8 + 12) = 20;
            int v8 = (void *)v8[4];
          }
          while (v8);
        }
        return 0xFFFFFFFFLL;
      case 0xE:
        v101 = (void *)v8[2];
        if (!v101) {
          goto LABEL_271;
        }
        v103 = (void **)(v8 + 15);
        uint64_t v102 = v8[15];
        if (v102)
        {
          uint64_t v104 = 0;
          do
          {
            ++v104;
            uint64_t v102 = *(void *)(v102 + 16);
          }
          while (v102);
          unint64_t v105 = 8 * v104 + 8;
        }
        else
        {
          unint64_t v105 = 8;
        }
        v143 = sec_asn1d_zalloc(*(void *)(*v8 + 8), v105);
        if (!v143) {
          goto LABEL_174;
        }
        void *v101 = v143;
        for (j = *v103; j; j = (void *)j[2])
          *v143++ = *j;
        void *v143 = 0;
        *v103 = 0;
        v8[16] = 0;
        goto LABEL_271;
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x12:
        uint64_t v10 = v8[5];
        int v11 = *(unsigned __int8 *)(v10 + 140);
        *((unsigned char *)v8 + 140) = v11;
        if (v11)
        {
          v8[8] = *(void *)(v10 + 64);
          *((unsigned char *)v8 + 52) = *(unsigned char *)(v10 + 52);
          *((unsigned char *)v8 + 137) = *(unsigned char *)(v10 + 137);
        }
        uint64_t v12 = v8[12];
        v8[13] += *(void *)(v10 + 104);
        if (!v12) {
          goto LABEL_12;
        }
        if (v12 != *(void *)(v10 + 104)) {
          goto LABEL_172;
        }
        v8[12] = 0;
LABEL_12:
        unint64_t v13 = 0;
        int v14 = 0;
        int v15 = 0;
        int v16 = 0;
        *(void *)(v10 + 104) = 0;
LABEL_13:
        int v17 = 20;
        goto LABEL_274;
      case 0x13:
        return result;
      case 0x14:
        if (*((unsigned char *)v8 + 139))
        {
          v8[12] = 2;
          int v17 = 21;
        }
        else
        {
          int v17 = 22;
        }
        unint64_t v13 = 0;
        int v14 = 0;
        int v15 = 0;
        int v16 = 0;
        goto LABEL_274;
      case 0x15:
        if (!a3)
        {
          unint64_t v13 = 0;
          int v15 = 0;
          int v16 = 0;
          uint64_t v160 = 3;
          *(_DWORD *)(*v8 + 24) = 3;
          int v14 = 1;
          goto LABEL_417;
        }
        unint64_t v106 = v8[12];
        if (v106 >= a3) {
          unint64_t v13 = a3;
        }
        else {
          unint64_t v13 = v8[12];
        }
        if (!v13) {
          goto LABEL_150;
        }
        uint64_t v107 = 0;
        unsigned int v108 = 1;
        while (!a2[v107])
        {
          uint64_t v107 = v108;
          if (v13 <= v108++)
          {
LABEL_150:
            v8[12] = v106 - v13;
            int v14 = 1;
            if (v106 <= a3)
            {
              int v15 = 0;
              int v16 = 0;
              *((_DWORD *)v8 + 12) = 22;
              *((unsigned char *)v8 + 137) = 1;
            }
            else
            {
              int v15 = 0;
              int v16 = 0;
            }
LABEL_288:
            uint64_t v160 = 3;
            goto LABEL_417;
          }
        }
        v159 = PR_getThreadErrInfo(1, (int *)&v197);
        if (v159) {
          void *v159 = 0xFFFFE00900000000;
        }
        unint64_t v13 = 0;
        int v15 = 0;
        int v16 = 0;
        int v14 = 1;
        *(_DWORD *)(*v8 + 24) = 1;
        goto LABEL_288;
      case 0x16:
        if (v8[5])
        {
          v8[5] = 0;
          v8[3] = 0;
        }
        unint64_t v13 = 0;
        int v14 = 0;
        int v15 = 0;
        int v16 = 0;
        goto LABEL_163;
      case 0x17:
        if (*((unsigned char *)v8 + 136))
        {
          v110 = (char *)sec_asn1d_zalloc(*(void *)(*v8 + 8), *(unsigned int *)(v8[1] + 16));
          if (!v110) {
            goto LABEL_261;
          }
          uint64_t v111 = v8[1];
          uint64_t v112 = *(unsigned int *)(v111 + 4);
          v113 = &v110[v112];
          v8[2] = &v110[v112];
        }
        else
        {
          uint64_t v111 = v8[1];
          v113 = (char *)v8[2];
          uint64_t v112 = *(unsigned int *)(v111 + 4);
        }
        v133 = sec_asn1d_push_state(*v8, v111 + 24, (uint64_t)&v113[-v112], 0);
        if (v133)
        {
          *((_DWORD *)v133 + 12) = 0;
          *((unsigned char *)v133 + 137) = 0;
          *(_WORD *)((char *)v133 + 139) = 0;
          v134 = sec_asn1d_init_state_based_on_template(v133, (uint64_t)a2, a3);
          if (v134)
          {
            unint64_t v13 = 0;
            int v14 = 0;
            int v15 = 0;
            int v16 = 0;
            *((unsigned char *)v134 + 141) = 1;
            *((_DWORD *)v8 + 12) = 24;
            uint64_t v160 = 2;
            int v8 = v134;
            goto LABEL_417;
          }
        }
        int v8 = 0;
        goto LABEL_414;
      case 0x18:
        uint64_t v114 = v8[5];
        if (!*(unsigned char *)(v114 + 140))
        {
          v135 = (_DWORD *)v8[2];
          if (v135) {
            _DWORD *v135 = *(_DWORD *)(*(void *)(v114 + 8) + 16);
          }
          unint64_t v13 = 0;
          int v14 = 0;
          int v15 = 0;
          int v16 = 0;
          *(_DWORD *)(v114 + 48) = 26;
          int v17 = 25;
          goto LABEL_274;
        }
        v8[13] += *(void *)(v114 + 104);
        if (*(unsigned char *)(v114 + 137))
        {
          *(_DWORD *)(v114 + 48) = 26;
          *((_DWORD *)v8 + 12) = 25;
          *((unsigned char *)v8 + 137) = 1;
          if (sec_asn1d_parent_allows_EOC(v8[4])) {
            goto LABEL_414;
          }
        }
        else
        {
          v146 = *(unsigned int **)(v114 + 8);
          uint64_t v145 = *(void *)(v114 + 16);
          uint64_t v147 = v146[1];
          unsigned int v148 = v146[6];
          *(void *)(v114 + 8) = v146 + 6;
          if (v148)
          {
            *(void *)(v114 + 16) = v145 - v147 + v146[7];
            unint64_t v149 = v8[12];
            if (!v149
              || (v150 = *(void *)(v114 + 104), BOOL v56 = v149 >= v150, v151 = v149 - v150, v56) && (v8[12] = v151) != 0)
            {
              *(void *)(v114 + 104) = 0;
              *(_DWORD *)(v114 + 48) = 0;
              *(unsigned char *)(v114 + 137) = 0;
              *(_WORD *)(v114 + 139) = 0;
              *(void *)(*v8 + 16) = v114;
              char v168 = *(unsigned char *)(v114 + 52);
              uint64_t v169 = *(void *)(v114 + 64);
              v170 = sec_asn1d_init_state_based_on_template((void *)v114, (uint64_t)a2, a3);
              int v8 = v170;
              uint64_t v160 = 2;
              if (!v170) {
                goto LABEL_327;
              }
              unint64_t v13 = 0;
              int v14 = 0;
              int v15 = 0;
              int v16 = 0;
              *((unsigned char *)v170 + 52) = v168;
              v170[8] = v169;
              *((unsigned char *)v170 + 141) = 1;
              *((_DWORD *)v170 + 12) = 2;
              goto LABEL_417;
            }
          }
        }
        v152 = PR_getThreadErrInfo(1, (int *)&v197);
        if (v152) {
          void *v152 = 0xFFFFE00900000000;
        }
LABEL_261:
        unint64_t v13 = 0;
        int v14 = 0;
        int v15 = 0;
        int v16 = 0;
        *(_DWORD *)(*v8 + 24) = 1;
        uint64_t v160 = 2;
        int v8 = 0;
        goto LABEL_417;
      case 0x19:
        unint64_t v13 = 0;
        int v14 = 0;
        int v15 = 0;
        int v16 = 0;
        uint64_t v115 = v8[5];
        v8[13] += *(void *)(v115 + 104);
        *(void *)(v115 + 104) = 0;
        v8[5] = 0;
        v8[3] = 0;
LABEL_163:
        *((_DWORD *)v8 + 12) = 20;
        *(void *)(*v8 + 16) = v8[4];
        goto LABEL_416;
      default:
LABEL_453:
        v194 = PR_getThreadErrInfo(1, (int *)&v197);
        if (v194) {
          void *v194 = 0xFFFFE00900000000;
        }
        *(_DWORD *)(a1 + 24) = 1;
        uint64_t v6 = v196;
        goto LABEL_447;
    }
  }
}

uint64_t sec_asn1d_parent_allows_EOC(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      int v1 = *(_DWORD *)(result + 48);
      BOOL v2 = (v1 - 16) < 4 || v1 == 24;
      if (!v2 && v1 != 11) {
        break;
      }
      uint64_t result = *(void *)(result + 32);
      if (!result) {
        return result;
      }
    }
    BOOL v4 = (v1 & 0xFFFFFFFE) == 8 || *(unsigned char *)(*(void *)(result + 40) + 141) != 0;
    return *(unsigned char *)(result + 139) && v4;
  }
  return result;
}

uint64_t sec_asn1d_check_and_subtract_length(unint64_t *a1, unint64_t a2, uint64_t a3)
{
  if (a1 && a3)
  {
    if (*a1 >= a2)
    {
      *a1 -= a2;
      return 1;
    }
    else
    {
      ThreadErrInfo = PR_getThreadErrInfo(1, &v8);
      if (ThreadErrInfo) {
        void *ThreadErrInfo = 0xFFFFE00900000000;
      }
      uint64_t result = 0;
      *(_DWORD *)(a3 + 24) = 1;
    }
  }
  else
  {
    uint64_t v6 = PR_getThreadErrInfo(1, &v7);
    if (v6) {
      *uint64_t v6 = 0xFFFFE00500000000;
    }
    uint64_t result = 0;
    if (a3) {
      *(_DWORD *)(a3 + 24) = 1;
    }
  }
  return result;
}

void *sec_asn1d_zalloc(uint64_t a1, unint64_t a2)
{
  if (a1) {
    unint64_t v3 = (void *)PORT_ArenaAlloc(a1, a2);
  }
  else {
    unint64_t v3 = PORT_Alloc(a2);
  }
  BOOL v4 = v3;
  if (v3) {
    bzero(v3, a2);
  }
  return v4;
}

void *sec_asn1d_push_state(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = *(void *)(a1 + 16);
  if (a2)
  {
    if (v5) {
      *(void *)(v5 + 24) = -1;
    }
    uint64_t result = sec_asn1d_zalloc(*(void *)a1, 0x90uLL);
    if (result)
    {
      result[4] = v5;
      *uint64_t result = a1;
      result[1] = a2;
      *((_DWORD *)result + 12) = 26;
      if (a3) {
        result[2] = a3 + *(unsigned int *)(a2 + 4);
      }
      if (v5)
      {
        int v10 = *(_DWORD *)(v5 + 112);
        *((_DWORD *)result + 28) = v10;
        if (a4)
        {
          *((_DWORD *)result + 28) = v10 + 1;
          if (v10 >= 32)
          {
            ThreadErrInfo = PR_getThreadErrInfo(1, &v14);
            if (ThreadErrInfo) {
              void *ThreadErrInfo = 0xFFFFE00900000000;
            }
            *(_DWORD *)(a1 + 24) = 1;
            goto LABEL_16;
          }
        }
        *(void *)(v5 + 40) = result;
      }
      *(void *)(a1 + 16) = result;
      return result;
    }
  }
  else
  {
    uint64_t v12 = PR_getThreadErrInfo(1, &v13);
    if (v12) {
      void *v12 = 0xFFFFE08800000000;
    }
  }
  *(_DWORD *)(a1 + 24) = 1;
  if (v5)
  {
LABEL_16:
    uint64_t result = 0;
    *(void *)(v5 + 24) = 0;
    return result;
  }
  return 0;
}

void *sec_asn1d_init_state_based_on_template(void *a1, uint64_t a2, uint64_t a3)
{
  while (1)
  {
    if (!a1) {
      return a1;
    }
    uint64_t v6 = *a1;
    if (*(_DWORD *)(*a1 + 24) == 1) {
      return a1;
    }
    int v7 = (unsigned int *)a1[1];
    if (!v7) {
      return a1;
    }
    unsigned int v8 = *v7;
    if ((*v7 & 0x20000) == 0) {
      goto LABEL_19;
    }
    if (*(_DWORD *)(v6 + 72)) {
      break;
    }
    *((unsigned char *)a1 + 137) = 0;
    *(_WORD *)((char *)a1 + 139) = 0;
    *((_DWORD *)a1 + 12) = 11;
    a1 = sec_asn1d_push_state(v6, (uint64_t)kSecAsn1AnyTemplate, a1[2], 0);
    if (!a1) {
      return a1;
    }
  }
  char v9 = *(void (**)(void, void, uint64_t, uint64_t))(v6 + 32);
  if (v9)
  {
    uint64_t v10 = *((unsigned int *)a1 + 28);
    uint64_t v11 = a1[2];
    *(_DWORD *)(v6 + 48) = 1;
    v9(*(void *)(v6 + 40), 0, v11, v10);
    *(_DWORD *)(v6 + 48) = 0;
  }
  uint64_t v12 = a1[2];
  if (v12)
  {
    int v13 = (unsigned int *)a1[1];
    uint64_t v14 = v12 - v13[1];
  }
  else
  {
    uint64_t v14 = *(void *)(a1[4] + 16);
    int v13 = (unsigned int *)a1[1];
  }
  int v7 = v13 + 6;
  a1[1] = v13 + 6;
  a1[2] = v14;
  if (v14)
  {
    uint64_t v15 = v14 + v13[7];
    a1[2] = v15;
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t v16 = *a1;
  int v17 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(*a1 + 32);
  if (v17)
  {
    uint64_t v18 = *((unsigned int *)a1 + 28);
    *(_DWORD *)(v16 + 48) = 1;
    v17(*(void *)(v16 + 40), 1, v15, v18);
    *(_DWORD *)(v16 + 48) = 0;
    int v7 = (unsigned int *)a1[1];
  }
  unsigned int v8 = *v7;
LABEL_19:
  if ((v8 & 0x100000) != 0)
  {
    *((_DWORD *)a1 + 12) = 23;
    return a1;
  }
  unint64_t v19 = v8 & 0x200;
  int v20 = (v8 >> 8) & 1;
  BOOL v22 = (v8 & 0xC0) == 0 || v19 != 0;
  if ((v8 & 0x1800) == 0 && v22)
  {
    uint64_t v23 = v8 & 0xFFFBBCFF;
    if ((v8 & 0x200) != 0) {
      uint64_t v23 = 0;
    }
    goto LABEL_54;
  }
  *((_DWORD *)a1 + 12) = 0;
  *((unsigned char *)a1 + 137) = 0;
  *(_WORD *)((char *)a1 + 139) = 0;
  if ((v8 & 0x1000) != 0)
  {
    uint64_t v25 = 0;
    BOOL v24 = *(_DWORD *)(*a1 + 72) == 0;
    int v26 = 18;
  }
  else
  {
    BOOL v24 = 0;
    uint64_t v25 = a1[2];
    if ((v8 & 0x800) != 0) {
      int v26 = 17;
    }
    else {
      int v26 = 16;
    }
  }
  *((_DWORD *)a1 + 12) = v26;
  *((unsigned char *)a1 + 141) = v20;
  uint64_t v27 = a1;
  while (1)
  {
    uint64_t v28 = v27[2];
    if (v28) {
      break;
    }
    uint64_t v27 = (void *)v27[4];
    if (!v27)
    {
      unint64_t v29 = (uint64_t (**)(uint64_t, void, uint64_t, uint64_t))*((void *)v7 + 1);
      if (v29 && (v8 & 0x4000) != 0)
      {
        if (*v29)
        {
          uint64_t v30 = ((uint64_t (*)(void, void, uint64_t, uint64_t, void))*v29)(0, 0, a2, a3, 0);
LABEL_48:
          unint64_t v29 = (uint64_t (**)(uint64_t, void, uint64_t, uint64_t))v30;
          goto LABEL_50;
        }
LABEL_49:
        unint64_t v29 = 0;
        goto LABEL_50;
      }
      goto LABEL_50;
    }
  }
  unint64_t v29 = (uint64_t (**)(uint64_t, void, uint64_t, uint64_t))*((void *)v7 + 1);
  if (v29 && (v8 & 0x4000) != 0)
  {
    if (*v29)
    {
      uint64_t v30 = (*v29)(v28 - v7[1], 0, a2, a3);
      goto LABEL_48;
    }
    goto LABEL_49;
  }
LABEL_50:
  uint64_t v31 = sec_asn1d_push_state(*a1, (uint64_t)v29, v25, 0);
  a1 = v31;
  if (v31)
  {
    *((unsigned char *)v31 + 136) = v24;
    if ((v8 & 0xC0) != 0 && (v8 & 0x4000) == 0)
    {
      uint64_t v23 = *(_DWORD *)v31[1] & 0xFFFBFFFF;
LABEL_54:
      if ((v8 & 0x8400) != 0)
      {
        char v32 = 0;
        uint64_t v33 = 0;
        uint64_t v34 = 0;
        if ((v8 & 0x8000) != 0) {
          a1[2] = 0;
        }
      }
      else
      {
        char v32 = v8 & 0xE0;
        uint64_t v34 = v8 & 0x1F;
        uint64_t v35 = 1 << (v23 & 0x1F);
        char v36 = v8 & 0xC0 | 0x20;
        if ((v35 & 0x30000) == 0) {
          char v36 = v8 & 0xE0;
        }
        BOOL v37 = (v35 & 0x55D81018) == 0;
        if ((v35 & 0x55D81018) != 0) {
          char v38 = v8 & 0xE0;
        }
        else {
          char v38 = v36;
        }
        if (v37) {
          uint64_t v39 = 255;
        }
        else {
          uint64_t v39 = 223;
        }
        if ((v23 & 0x1F) == 0x1F)
        {
          uint64_t v33 = 255;
        }
        else
        {
          char v32 = v38;
          uint64_t v33 = v39;
        }
      }
      a1[7] = v33;
      *((unsigned char *)a1 + 53) = v32;
      a1[9] = v34;
      a1[10] = v23;
      *((unsigned char *)a1 + 138) = v19 >> 9;
      *((unsigned char *)a1 + 141) = v20;
      *((_DWORD *)a1 + 12) = 0;
      *((unsigned char *)a1 + 137) = 0;
      *(_WORD *)((char *)a1 + 139) = 0;
      return a1;
    }
    uint64_t inited = sec_asn1d_init_state_based_on_template(v31, a2, a3);
    a1 = (void *)inited;
    if (inited) {
      *(unsigned char *)(inited + 141) = v20;
    }
  }
  return a1;
}

unint64_t sec_asn1d_parse_leaf(uint64_t a1, char *__src, unint64_t a3)
{
  if (!a3)
  {
    unint64_t v5 = 0;
    *(_DWORD *)(*(void *)a1 + 24) = 3;
    return v5;
  }
  unint64_t v4 = *(void *)(a1 + 96);
  if (v4 >= a3) {
    unint64_t v5 = a3;
  }
  else {
    unint64_t v5 = *(void *)(a1 + 96);
  }
  uint64_t v6 = *(unint64_t **)(a1 + 16);
  if (!v6) {
    goto LABEL_30;
  }
  unint64_t v7 = v6[1];
  if (!v7) {
    goto LABEL_30;
  }
  unsigned int v8 = __src;
  uint64_t v9 = *(void *)(a1 + 80);
  unint64_t v10 = *v6;
  if (v9 == 2)
  {
    if (v10) {
      BOOL v11 = 0;
    }
    else {
      BOOL v11 = v5 >= 2;
    }
    if (!v11)
    {
      size_t v12 = v5;
      goto LABEL_25;
    }
    __src = &__src[v5 - 1];
    size_t v12 = v5;
    while (!*v8)
    {
      ++v8;
      if (--v12 <= 1)
      {
        size_t v12 = 1;
        goto LABEL_20;
      }
    }
    __src = v8;
  }
  else
  {
    size_t v12 = v5;
  }
LABEL_20:
  if (v9 != 3)
  {
LABEL_25:
    unint64_t v13 = v12;
    unint64_t v14 = *v6;
    if (0xFFFFFFFF - v10 < v12)
    {
LABEL_26:
      ThreadErrInfo = PR_getThreadErrInfo(1, &v17);
      if (ThreadErrInfo) {
        void *ThreadErrInfo = 0xFFFFE00900000000;
      }
      unint64_t v5 = 0;
      *(_DWORD *)(*(void *)a1 + 24) = 1;
      return v5;
    }
    goto LABEL_29;
  }
  if ((v10 & 7) != 0) {
    goto LABEL_26;
  }
  if (v12 >> 61) {
    goto LABEL_26;
  }
  unint64_t v13 = 8 * v12 - *(unsigned int *)(a1 + 116);
  if (0xFFFFFFFF - v10 < v13) {
    goto LABEL_26;
  }
  unint64_t v14 = v10 >> 3;
LABEL_29:
  *uint64_t v6 = v13 + v10;
  memcpy((void *)(v7 + v14), __src, v12);
  unint64_t v4 = *(void *)(a1 + 96);
LABEL_30:
  *(void *)(a1 + 96) = v4 - v5;
  if (v4 == v5) {
    *(_DWORD *)(a1 + 48) = 20;
  }
  return v5;
}

void sec_asn1d_add_to_subitems(uint64_t **a1, void *a2, unint64_t a3, int a4)
{
  unsigned int v8 = (uint64_t *)sec_asn1d_zalloc(**a1, 0x18uLL);
  if (!v8)
  {
    *((_DWORD *)*a1 + 6) = 1;
    return;
  }
  uint64_t v9 = v8;
  if (!a4)
  {
    uint64_t v12 = (uint64_t)a2;
LABEL_10:
    *uint64_t v9 = v12;
    v9[1] = a3;
    v9[2] = 0;
    if (a1[15]) {
      a1[16][2] = (uint64_t)v9;
    }
    else {
      a1[15] = v9;
    }
    a1[16] = v9;
    return;
  }
  uint64_t v10 = **a1;
  if (v10) {
    BOOL v11 = (void *)PORT_ArenaAlloc(v10, a3);
  }
  else {
    BOOL v11 = PORT_Alloc(a3);
  }
  uint64_t v12 = (uint64_t)v11;
  if (v11)
  {
    memcpy(v11, a2, a3);
    goto LABEL_10;
  }
  unint64_t v13 = *a1;
  *((_DWORD *)v13 + 6) = 1;
  if (!*v13)
  {
    free(v9);
  }
}

void sec_asn1d_record_any_header(uint64_t **a1, void *a2, unint64_t a3)
{
  unint64_t v4 = a1[2];
  if (v4 && v4[1])
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v6);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0xFFFFE00100000000;
    }
    *((_DWORD *)*a1 + 6) = 1;
  }
  else
  {
    sec_asn1d_add_to_subitems(a1, a2, a3, 1);
  }
}

uint64_t SEC_ASN1DecoderFinish(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24) != 3) {
    goto LABEL_10;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  if (!*(_DWORD *)(v2 + 48))
  {
    unint64_t v5 = *(int **)(v2 + 8);
    int v6 = *v5;
    if (*v5)
    {
      unint64_t v7 = v5 + 6;
      while ((v6 & 0x100) != 0)
      {
        int v8 = *v7;
        v7 += 6;
        LOWORD(v6) = v8;
        if (!v8) {
          goto LABEL_10;
        }
      }
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v4 = 0;
    goto LABEL_11;
  }
LABEL_3:
  ThreadErrInfo = PR_getThreadErrInfo(1, &v10);
  if (ThreadErrInfo) {
    void *ThreadErrInfo = 0xFFFFE00900000000;
  }
  uint64_t v4 = 0xFFFFFFFFLL;
LABEL_11:
  PORT_FreeArena(*(void **)a1, 0);
  return v4;
}

uint64_t SEC_ASN1DecoderStart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10 = PORT_NewArena(2048);
  if (!v10) {
    return 0;
  }
  BOOL v11 = v10;
  uint64_t v12 = PORT_ArenaAlloc((uint64_t)v10, 0x50uLL);
  if (!v12) {
    goto LABEL_7;
  }
  uint64_t v13 = v12;
  *(void *)(v12 + 72) = 0;
  *(_OWORD *)(v12 + 56) = 0u;
  *(_OWORD *)(v12 + 40) = 0u;
  *(_OWORD *)(v12 + 24) = 0u;
  *(_OWORD *)(v12 + 8) = 0u;
  *(void *)uint64_t v12 = v11;
  if (a1) {
    *(void *)(v12 + 8) = a1;
  }
  *(_DWORD *)(v12 + 24) = 3;
  if (!sec_asn1d_push_state(v12, a3, a2, 0) || !sec_asn1d_init_state_based_on_template(*(void **)(v13 + 16), a4, a5))
  {
LABEL_7:
    PORT_FreeArena(v11, 0);
    return 0;
  }
  return v13;
}

uint64_t SEC_ASN1Decode(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5)
{
  uint64_t v7 = SEC_ASN1DecoderStart(a1, a2, a3, (uint64_t)a4, a5);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = v7;
  int v9 = SEC_ASN1DecoderUpdate(v7, a4, a5);
  LODWORD(result) = SEC_ASN1DecoderFinish(v8);
  if (v9) {
    return 0xFFFFFFFFLL;
  }
  else {
    return result;
  }
}

OSStatus SecAsn1CoderCreate(SecAsn1CoderRef *coder)
{
  if (!coder) {
    return -50;
  }
  uint64_t v2 = (SecAsn1Coder *)malloc_type_malloc(8uLL, 0x2004093837F09uLL);
  unint64_t v3 = PORT_NewArena(1024);
  *(void *)uint64_t v2 = v3;
  if (v3)
  {
    OSStatus result = 0;
    *coder = v2;
  }
  else
  {
    free(v2);
    return -108;
  }
  return result;
}

OSStatus SecAsn1CoderRelease(SecAsn1CoderRef coder)
{
  if (!coder) {
    return -50;
  }
  uint64_t v2 = *(void **)coder;
  if (v2) {
    PORT_FreeArena(v2, 1);
  }
  free(coder);
  return 0;
}

OSStatus SecAsn1Decode(SecAsn1CoderRef coder, const void *src, size_t len, const SecAsn1Template *templates, void *dest)
{
  OSStatus result = -50;
  if (coder && src && templates && dest)
  {
    if (SEC_ASN1Decode(*(void *)coder, (uint64_t)dest, (uint64_t)templates, (char *)src, len)) {
      return -26275;
    }
    else {
      return 0;
    }
  }
  return result;
}

OSStatus SecAsn1DecodeData(SecAsn1CoderRef coder, const SecAsn1Item *src, const SecAsn1Template *templ, void *dest)
{
  return SecAsn1Decode(coder, src->Data, src->Length, templ, dest);
}

OSStatus SecAsn1EncodeItem(SecAsn1CoderRef coder, const void *src, const SecAsn1Template *templates, SecAsn1Item *dest)
{
  OSStatus result = -50;
  if (coder && src && templates && dest)
  {
    dest->CFIndex Length = 0;
    dest->Data = 0;
    if (SEC_ASN1EncodeItem(*(void *)coder, dest, (uint64_t)src, (uint64_t)templates)) {
      return 0;
    }
    else {
      return -50;
    }
  }
  return result;
}

void *__cdecl SecAsn1Malloc(void *coder, size_t len)
{
  if (coder) {
    return (void *)PORT_ArenaAlloc(*(void *)coder, len);
  }
  return coder;
}

OSStatus SecAsn1AllocItem(SecAsn1CoderRef coder, SecAsn1Item *item, size_t len)
{
  OSStatus result = -50;
  if (coder && item)
  {
    uint64_t v7 = (uint8_t *)PORT_ArenaAlloc(*(void *)coder, len);
    item->Data = v7;
    if (v7)
    {
      OSStatus result = 0;
      item->CFIndex Length = len;
    }
    else
    {
      return -108;
    }
  }
  return result;
}

OSStatus SecAsn1AllocCopy(SecAsn1CoderRef coder, const void *src, size_t len, SecAsn1Item *dest)
{
  if (!src) {
    return -50;
  }
  OSStatus result = -50;
  if (coder && dest)
  {
    int v9 = (uint8_t *)PORT_ArenaAlloc(*(void *)coder, len);
    dest->Data = v9;
    if (v9)
    {
      dest->CFIndex Length = len;
      memmove(v9, src, len);
      return 0;
    }
    else
    {
      return -108;
    }
  }
  return result;
}

OSStatus SecAsn1AllocCopyItem(SecAsn1CoderRef coder, const SecAsn1Item *src, SecAsn1Item *dest)
{
  return SecAsn1AllocCopy(coder, src->Data, src->Length, dest);
}

uint64_t __SSLContextGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef SSLContextCopyDescription(uint64_t a1)
{
  if (a1) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<SSLContext(%p) { ... }>", a1);
  }
  else {
    return 0;
  }
}

CFStringRef SSLContextCopyFormatDescription(CFStringRef result)
{
  if (result) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<SSLContext(%p) { ... }>", result);
  }
  return result;
}

BOOL SSLContextCompare(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

OSStatus SSLSetSessionConfig(SSLContextRef context, CFStringRef config)
{
  if (!CFEqual(config, @"ATSv1")
    && !CFEqual(config, @"ATSv1_noPFS")
    && !CFEqual(config, @"standard")
    && !CFEqual(config, @"TLSv1_fallback")
    && !CFEqual(config, @"TLSv1_RC4_fallback")
    && !CFEqual(config, @"RC4_fallback")
    && !CFEqual(config, @"3DES_fallback")
    && !CFEqual(config, @"TLSv1_3DES_fallback")
    && !CFEqual(config, @"legacy")
    && !CFEqual(config, @"legacy_DHE")
    && !CFEqual(config, @"anonymous")
    && !CFEqual(config, @"default"))
  {
    return -50;
  }

  return tls_handshake_set_config();
}

uint64_t __SSLCreateContextWithRecordFuncs_block_invoke()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFURLRef v1 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"/Library/Managed Preferences/mobile/.GlobalPreferences.plist", kCFURLPOSIXPathStyle, 0);
  if (v1)
  {
    CFURLRef v2 = v1;
    unint64_t v3 = CFReadStreamCreateWithFile(v0, v1);
    if (v3)
    {
      uint64_t v4 = v3;
      if (CFReadStreamOpen(v3)) {
        CFDictionaryRef v5 = (const __CFDictionary *)CFPropertyListCreateWithStream(v0, v4, 0, 0, 0, 0);
      }
      else {
        CFDictionaryRef v5 = 0;
      }
      CFRelease(v4);
    }
    else
    {
      CFDictionaryRef v5 = 0;
    }
    CFRelease(v2);
  }
  else
  {
    CFDictionaryRef v5 = 0;
  }
  CFBooleanRef v6 = (const __CFBoolean *)SSLPreferencesCopyValue(@"SSLDisableRecordSplitting", v5);
  if (v6)
  {
    CFBooleanRef v7 = v6;
    CFTypeID v8 = CFGetTypeID(v6);
    if (v8 == CFBooleanGetTypeID()) {
      Boolean Value = CFBooleanGetValue(v7);
    }
    else {
      Boolean Value = 0;
    }
    CFRelease(v7);
  }
  else
  {
    Boolean Value = 0;
  }
  kSSLDisableRecordSplittingDefaultBoolean Value = Value;
  kMinDhGroupSizeDefaultBoolean Value = (uint64_t)SSLPreferencesGetInteger(@"SSLMinDhGroupSize", v5);
  kMinProtocolVersionDefaultBoolean Value = (uint64_t)SSLPreferencesGetInteger(@"SSLMinProtocolVersion", v5);
  CFPropertyListRef v10 = SSLPreferencesCopyValue(@"SSLSessionConfig", v5);
  BOOL v11 = v10;
  if (v10)
  {
    CFTypeID v12 = CFGetTypeID(v10);
    if (v12 != CFStringGetTypeID())
    {
      CFRelease(v11);
      BOOL v11 = 0;
    }
  }
  kSSLSessionConfigDefaultBoolean Value = (uint64_t)v11;
  if (v5) {
    CFRelease(v5);
  }
  uint64_t result = tls_cache_create();
  g_session_cache = result;
  return result;
}

CFPropertyListRef SSLPreferencesCopyValue(const void *a1, const __CFDictionary *a2)
{
  CFPropertyListRef v4 = CFPreferencesCopyAppValue(@"SSLSessionConfig", (CFStringRef)*MEMORY[0x1E4F1D3D8]);
  CFPropertyListRef v5 = v4;
  if (a2)
  {
    if (!v4)
    {
      Boolean Value = CFDictionaryGetValue(a2, a1);
      CFPropertyListRef v5 = Value;
      if (Value) {
        CFRetain(Value);
      }
    }
  }
  return v5;
}

CFNumberRef SSLPreferencesGetInteger(const void *a1, const __CFDictionary *a2)
{
  CFNumberRef result = (const __CFNumber *)SSLPreferencesCopyValue(a1, a2);
  uint64_t valuePtr = 0;
  if (result)
  {
    CFNumberRef v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 == CFNumberGetTypeID()) {
      CFNumberGetValue(v3, kCFNumberCFIndexType, &valuePtr);
    }
    CFRelease(v3);
    return (const __CFNumber *)valuePtr;
  }
  return result;
}

uint64_t SSLSetRecordContext(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 4294967246;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 80);
  BOOL v4 = v3 > 6;
  int v5 = (1 << v3) & 0x59;
  if (v4 || v5 == 0) {
    return 4294966387;
  }
  uint64_t result = 0;
  *(void *)(a1 + 48) = a2;
  return result;
}

uint64_t _SSLNewDatagramContext(int a1, SSLContextRef *a2)
{
  if (!a2) {
    return 4294967246;
  }
  SSLContextRef v3 = SSLCreateContext((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (SSLProtocolSide)(a1 == 0), kSSLDatagramType);
  *a2 = v3;
  if (v3) {
    return 0;
  }
  else {
    return 4294967188;
  }
}

OSStatus SSLGetSessionState(SSLContextRef context, SSLSessionState *state)
{
  if (!context) {
    return -50;
  }
  unsigned int v2 = *((_DWORD *)context + 20) - 1;
  if (v2 > 5) {
    SSLSessionState v3 = kSSLIdle;
  }
  else {
    SSLSessionState v3 = dword_18B416F68[v2];
  }
  OSStatus result = 0;
  *state = v3;
  return result;
}

OSStatus SSLGetSessionOption(SSLContextRef context, SSLSessionOption option, Boolean *value)
{
  OSStatus result = -50;
  if (context && value)
  {
    switch(option)
    {
      case kSSLSessionOptionBreakOnServerAuth:
        OSStatus result = 0;
        Boolean v5 = *((unsigned char *)context + 353);
        goto LABEL_11;
      case kSSLSessionOptionBreakOnCertRequested:
        OSStatus result = 0;
        Boolean v5 = *((unsigned char *)context + 354);
        goto LABEL_11;
      case kSSLSessionOptionBreakOnClientAuth:
        OSStatus result = 0;
        Boolean v5 = *((unsigned char *)context + 355);
        goto LABEL_11;
      case kSSLSessionOptionFalseStart:
        OSStatus result = 0;
        Boolean v5 = *((unsigned char *)context + 512);
        goto LABEL_11;
      case kSSLSessionOptionSendOneByteRecord:
        OSStatus result = 0;
        Boolean v5 = *((unsigned char *)context + 315);
        goto LABEL_11;
      case kSSLSessionOptionAllowServerIdentityChange:
        tls_handshake_get_server_identity_change();
        return 0;
      case kSSLSessionOptionBreakOnClientHello:
        OSStatus result = 0;
        Boolean v5 = *((unsigned char *)context + 359);
LABEL_11:
        *value = v5;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t SSLSetNPNFunc(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    unsigned int v3 = *(_DWORD *)(result + 80);
    BOOL v4 = v3 > 6;
    int v5 = (1 << v3) & 0x59;
    if (!v4 && v5 != 0)
    {
      *(void *)(result + 520) = a2;
      *(void *)(result + 528) = a3;
      if (*(_DWORD *)(result + 108) == 1) {
        return MEMORY[0x1F417F310](*(void *)(result + 56), a2 != 0);
      }
    }
  }
  return result;
}

uint64_t SSLSetNPNData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && (unint64_t)(a3 - 256) >= 0xFFFFFFFFFFFFFF01) {
    return MEMORY[0x1F417F308](*(void *)(a1 + 56), a3, a2);
  }
  else {
    return 4294967246;
  }
}

uint64_t *SSLGetNPNData(uint64_t a1, void *a2)
{
  OSStatus result = 0;
  if (a1 && a2)
  {
    OSStatus result = (uint64_t *)tls_handshake_get_peer_npn_data();
    if (result)
    {
      uint64_t v5 = *result;
      OSStatus result = (uint64_t *)result[1];
      *a2 = v5;
    }
  }
  return result;
}

uint64_t SSLSetALPNFunc(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    unsigned int v3 = *(_DWORD *)(result + 80);
    BOOL v4 = v3 > 6;
    int v5 = (1 << v3) & 0x59;
    if (!v4 && v5 != 0)
    {
      *(void *)(result + 536) = a2;
      *(void *)(result + 544) = a3;
    }
  }
  return result;
}

uint64_t SSLSetALPNData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && (unint64_t)(a3 - 256) >= 0xFFFFFFFFFFFFFF01) {
    return tls_handshake_set_alpn_data();
  }
  else {
    return 4294967246;
  }
}

uint64_t *SSLGetALPNData(uint64_t a1, void *a2)
{
  OSStatus result = 0;
  if (a1 && a2)
  {
    OSStatus result = (uint64_t *)tls_handshake_get_peer_alpn_data();
    if (result)
    {
      uint64_t v5 = *result;
      OSStatus result = (uint64_t *)result[1];
      *a2 = v5;
    }
  }
  return result;
}

OSStatus SSLSetALPNProtocols(SSLContextRef context, CFArrayRef protocols)
{
  OSStatus v2 = -50;
  if (context && protocols && CFArrayGetCount(protocols))
  {
    CFDataRef Mutable = CFDataCreateMutable(0, 0);
    contexta[0] = MEMORY[0x1E4F143A8];
    contexta[1] = 0x40000000;
    contexta[2] = __SSLSetALPNProtocols_block_invoke;
    contexta[3] = &__block_descriptor_tmp_4_7941;
    contexta[4] = Mutable;
    v7.length = CFArrayGetCount(protocols);
    v7.location = 0;
    CFArrayApplyFunction(protocols, v7, (CFArrayApplierFunction)apply_block_1_7943, contexta);
    if (CFDataGetLength(Mutable) <= 255)
    {
      CFDataGetBytePtr(Mutable);
      CFDataGetLength(Mutable);
      OSStatus v2 = tls_handshake_set_alpn_data();
    }
    CFRelease(Mutable);
  }
  return v2;
}

void __SSLSetALPNProtocols_block_invoke(uint64_t a1, CFStringRef theString)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  UInt8 bytes = CFStringGetLength(theString);
  if (bytes <= 0x20uLL)
  {
    *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)buffer = v4;
    long long v7 = v4;
    if (CFStringGetCString(theString, buffer, 32, 0x600u))
    {
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 32), &bytes, 1);
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 32), (const UInt8 *)buffer, bytes);
    }
  }
}

uint64_t apply_block_1_7943(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

OSStatus SSLCopyALPNProtocols(SSLContextRef context, CFArrayRef *protocols)
{
  OSStatus result = -50;
  if (context && protocols)
  {
    CFDataRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    peer_alpn_data = (unint64_t *)tls_handshake_get_peer_alpn_data();
    if (peer_alpn_data)
    {
      long long v7 = peer_alpn_data;
      unint64_t v8 = 0;
      unint64_t v9 = *peer_alpn_data;
      while (v8 < v9)
      {
        unint64_t v10 = v7[1];
        CFIndex v11 = *(char *)(v10 + v8);
        unint64_t v12 = v8 + 1;
        v8 += 1 + v11;
        if (v8 <= v9)
        {
          CFStringRef v13 = CFStringCreateWithBytes(0, (const UInt8 *)(v10 + v12), v11, 0x600u, 0);
          CFArrayAppendValue(Mutable, v13);
          if (v13) {
            CFRelease(v13);
          }
          unint64_t v9 = *v7;
          if (v8 <= *v7) {
            continue;
          }
        }
        goto LABEL_10;
      }
      OSStatus result = 0;
    }
    else
    {
LABEL_10:
      if (Mutable)
      {
        CFRelease(Mutable);
        CFDataRef Mutable = 0;
      }
      OSStatus result = -50;
    }
    *protocols = Mutable;
  }
  return result;
}

OSStatus SSLSetOCSPResponse(SSLContextRef context, CFDataRef response)
{
  OSStatus result = -50;
  if (context)
  {
    if (response)
    {
      CFDataGetBytePtr(response);
      CFDataGetLength(response);
      return tls_handshake_set_ocsp_response();
    }
  }
  return result;
}

OSStatus SSLGetConnection(SSLContextRef context, SSLConnectionRef *connection)
{
  OSStatus result = -50;
  if (context)
  {
    if (connection)
    {
      OSStatus result = 0;
      *connection = (SSLConnectionRef)*((void *)context + 4);
    }
  }
  return result;
}

OSStatus SSLSetPeerDomainName(SSLContextRef context, const char *peerName, size_t peerNameLen)
{
  if (!context) {
    return -50;
  }
  unsigned int v3 = *((_DWORD *)context + 20);
  BOOL v4 = v3 > 6;
  int v5 = (1 << v3) & 0x59;
  if (v4 || v5 == 0) {
    return -909;
  }
  if (*((_DWORD *)context + 27) == 1) {
    return MEMORY[0x1F417F328](*((void *)context + 7), peerName, peerNameLen);
  }
  return 0;
}

OSStatus SSLGetPeerDomainNameLength(SSLContextRef context, size_t *peerNameLen)
{
  if (context) {
    return tls_handshake_get_peer_hostname();
  }
  else {
    return -50;
  }
}

OSStatus SSLGetPeerDomainName(SSLContextRef context, char *peerName, size_t *peerNameLen)
{
  if (!context) {
    return -50;
  }
  OSStatus result = tls_handshake_get_peer_hostname();
  if (!result)
  {
    if (*peerNameLen >= 0xAAAAAAAAAAAAAAAALL)
    {
      memcpy(peerName, (const void *)0xAAAAAAAAAAAAAAAALL, 0xAAAAAAAAAAAAAAAALL);
      OSStatus result = 0;
      *peerNameLen = 0xAAAAAAAAAAAAAAAALL;
    }
    else
    {
      return -9817;
    }
  }
  return result;
}

OSStatus SSLCopyRequestedPeerNameLength(SSLContextRef ctx, size_t *peerNameLen)
{
  if (!ctx) {
    return -50;
  }
  uint64_t sni_hostname = tls_handshake_get_sni_hostname();
  if (!sni_hostname) {
    return -50;
  }
  BOOL v4 = (size_t *)sni_hostname;
  OSStatus result = 0;
  *peerNameLen = *v4;
  return result;
}

OSStatus SSLCopyRequestedPeerName(SSLContextRef context, char *peerName, size_t *peerNameLen)
{
  if (!context) {
    return -50;
  }
  uint64_t sni_hostname = tls_handshake_get_sni_hostname();
  if (!sni_hostname) {
    return -50;
  }
  CFBooleanRef v6 = (size_t *)sni_hostname;
  if (*peerNameLen < *(void *)sni_hostname) {
    return -9817;
  }
  memcpy(peerName, *(const void **)(sni_hostname + 8), *(void *)sni_hostname);
  OSStatus result = 0;
  *peerNameLen = *v6;
  return result;
}

OSStatus SSLSetDatagramHelloCookie(SSLContextRef dtlsContext, const void *cookie, size_t cookieLen)
{
  if (!dtlsContext) {
    return -50;
  }
  OSStatus result = -50;
  if (cookieLen <= 0x20 && *((unsigned char *)dtlsContext + 104))
  {
    unsigned int v6 = *((_DWORD *)dtlsContext + 20);
    BOOL v7 = v6 > 6;
    int v8 = (1 << v6) & 0x59;
    if (v7 || v8 == 0)
    {
      return -909;
    }
    else
    {
      CFIndex v11 = (void *)*((void *)dtlsContext + 15);
      if (v11)
      {
        free(v11);
        *((void *)dtlsContext + 14) = 0;
        *((void *)dtlsContext + 15) = 0;
      }
      unint64_t v12 = malloc_type_malloc(cookieLen, 0xEFB4CC30uLL);
      CFStringRef v13 = v12;
      if (v12) {
        size_t v14 = cookieLen;
      }
      else {
        size_t v14 = 0;
      }
      if (v12) {
        OSStatus result = 0;
      }
      else {
        OSStatus result = -1;
      }
      *((void *)dtlsContext + 14) = v14;
      *((void *)dtlsContext + 15) = v13;
      if (v13)
      {
        memmove(v13, cookie, cookieLen);
        return 0;
      }
    }
  }
  return result;
}

OSStatus SSLSetMaxDatagramRecordSize(SSLContextRef dtlsContext, size_t maxSize)
{
  if (!dtlsContext) {
    return -50;
  }
  if (!*((unsigned char *)dtlsContext + 104)) {
    return -50;
  }
  tls_handshake_set_mtu();
  return 0;
}

OSStatus SSLGetMaxDatagramRecordSize(SSLContextRef dtlsContext, size_t *maxSize)
{
  if (!dtlsContext || !*((unsigned char *)dtlsContext + 104)) {
    return -50;
  }
  OSStatus result = 0;
  *maxSize = *((void *)dtlsContext + 54);
  return result;
}

OSStatus SSLGetDatagramWriteSize(SSLContextRef dtlsContext, size_t *bufSize)
{
  if (!dtlsContext) {
    return -50;
  }
  OSStatus result = -50;
  if (bufSize)
  {
    if (*((unsigned char *)dtlsContext + 104))
    {
      OSStatus result = 0;
      *bufSize = ((*((void *)dtlsContext + 54) - 13) & 0xFFFFFFFFFFFFFFF0) - 49;
    }
  }
  return result;
}

OSStatus SSLGetProtocolVersionMin(SSLContextRef context, SSLProtocol *minVersion)
{
  if (!context) {
    return -50;
  }
  SSLProtocol v2 = kSSLProtocol3;
  switch(*((_DWORD *)context + 24))
  {
    case 0x300:
      break;
    case 0x301:
      SSLProtocol v2 = kTLSProtocol1;
      break;
    case 0x302:
      SSLProtocol v2 = kTLSProtocol11;
      break;
    case 0x303:
      SSLProtocol v2 = kTLSProtocol12;
      break;
    default:
      SSLProtocol v2 = kSSLProtocolUnknown;
      break;
  }
  OSStatus result = 0;
  *minVersion = v2;
  return result;
}

OSStatus SSLSetProtocolVersionMax(SSLContextRef context, SSLProtocol maxVersion)
{
  if (!context) {
    return -50;
  }
  OSStatus result = -9830;
  unsigned int v4 = 768;
  switch(maxVersion)
  {
    case kSSLProtocol3:
      goto LABEL_7;
    case kTLSProtocol1:
      unsigned int v4 = 769;
      goto LABEL_7;
    case kTLSProtocol11:
      unsigned int v4 = 770;
      goto LABEL_7;
    case kTLSProtocol12:
      unsigned int v4 = 771;
LABEL_7:
      if (*((unsigned char *)context + 104)) {
        return result;
      }
      if (v4 < *((_DWORD *)context + 24)) {
        *((_DWORD *)context + 24) = v4;
      }
      break;
    case kDTLSProtocol1:
      if (!*((unsigned char *)context + 104)) {
        return result;
      }
      unsigned int v4 = 65279;
      if (*((_DWORD *)context + 24) <= 0xFEFEu) {
        *((_DWORD *)context + 24) = 65279;
      }
      break;
    default:
      return result;
  }
  *((_DWORD *)context + 25) = v4;
  tls_handshake_set_min_protocol_version();
  tls_handshake_set_max_protocol_version();
  return 0;
}

OSStatus SSLGetProtocolVersionMax(SSLContextRef context, SSLProtocol *maxVersion)
{
  if (!context) {
    return -50;
  }
  SSLProtocol v2 = kSSLProtocol3;
  switch(*((_DWORD *)context + 25))
  {
    case 0x300:
      break;
    case 0x301:
      SSLProtocol v2 = kTLSProtocol1;
      break;
    case 0x302:
      SSLProtocol v2 = kTLSProtocol11;
      break;
    case 0x303:
      SSLProtocol v2 = kTLSProtocol12;
      break;
    default:
      SSLProtocol v2 = kSSLProtocolUnknown;
      break;
  }
  OSStatus result = 0;
  *maxVersion = v2;
  return result;
}

uint64_t _SSLProtocolVersionToWireFormatValue(int a1)
{
  uint64_t result = 768;
  switch(a1)
  {
    case 0:
    case 1:
    case 3:
    case 5:
    case 6:
      uint64_t result = 0;
      break;
    case 2:
      return result;
    case 4:
      uint64_t result = 769;
      break;
    case 7:
      uint64_t result = 770;
      break;
    case 8:
      uint64_t result = 771;
      break;
    case 9:
      uint64_t result = 65279;
      break;
    case 10:
      uint64_t result = 772;
      break;
    case 11:
      uint64_t result = 65277;
      break;
    default:
      if (a1 == 999) {
        uint64_t result = 772;
      }
      else {
        uint64_t result = 0;
      }
      break;
  }
  return result;
}

uint64_t _SSLSetProtocolVersionEnabled(uint64_t a1, int a2, int a3)
{
  if (!a1) {
    return 4294967246;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 80);
  BOOL v4 = v3 > 6;
  int v5 = (1 << v3) & 0x59;
  BOOL v6 = v4 || v5 == 0;
  if (v6 || *(unsigned char *)(a1 + 104)) {
    return 4294966387;
  }
  int v8 = 2;
  switch(a2)
  {
    case 1:
      goto LABEL_18;
    case 2:
      int v8 = 768;
      goto LABEL_18;
    case 4:
      int v8 = 769;
      goto LABEL_18;
    case 6:
      if (!a3) {
        goto LABEL_42;
      }
      *(void *)(a1 + 96) = 0x30300000300;
      goto LABEL_43;
    case 7:
      int v8 = 770;
      goto LABEL_18;
    case 8:
      int v8 = 771;
      goto LABEL_18;
    case 9:
      int v8 = 65279;
      goto LABEL_18;
    default:
      int v8 = 0;
LABEL_18:
      unsigned int v9 = v8 - 772;
      if (!a3)
      {
        if (v9 < 0xFFFFFCFE) {
          return 4294967246;
        }
        if (v8 > 768)
        {
          if (v8 == 769)
          {
            unsigned int v11 = 770;
            goto LABEL_38;
          }
          if (v8 == 770)
          {
            unsigned int v11 = 771;
            goto LABEL_38;
          }
        }
        else
        {
          if (v8 == 2)
          {
            unsigned int v11 = 768;
            goto LABEL_38;
          }
          if (v8 == 768)
          {
            unsigned int v11 = 769;
            goto LABEL_38;
          }
        }
        unsigned int v11 = 0;
LABEL_38:
        unsigned int v12 = *(_DWORD *)(a1 + 100);
        if (*(_DWORD *)(a1 + 96) <= v11) {
          unsigned int v13 = v11;
        }
        else {
          unsigned int v13 = *(_DWORD *)(a1 + 96);
        }
        *(_DWORD *)(a1 + 96) = v13;
        if (v13 > v12) {
LABEL_42:
        }
          *(void *)(a1 + 96) = 0;
        goto LABEL_43;
      }
      if (v9 < 0xFFFFFFFC) {
        return 4294967246;
      }
      if (v8 <= *(_DWORD *)(a1 + 100))
      {
        unsigned int v10 = *(_DWORD *)(a1 + 96);
      }
      else
      {
        *(_DWORD *)(a1 + 100) = v8;
        unsigned int v10 = *(_DWORD *)(a1 + 96);
        if (!v10)
        {
          *(_DWORD *)(a1 + 96) = v8;
          unsigned int v10 = v8;
        }
      }
      if (v8 < v10) {
        *(_DWORD *)(a1 + 96) = v8;
      }
LABEL_43:
      tls_handshake_set_min_protocol_version();
      tls_handshake_set_max_protocol_version();
      return 0;
  }
}

uint64_t _SSLGetProtocolVersionEnabled(uint64_t a1, int a2, BOOL *a3)
{
  if (!a1) {
    return 4294967246;
  }
  if (*(unsigned char *)(a1 + 104)) {
    return 4294966387;
  }
  uint64_t v3 = 4294967246;
  unsigned int v4 = 2;
  switch(a2)
  {
    case 1:
      goto LABEL_12;
    case 2:
      unsigned int v4 = 768;
      goto LABEL_12;
    case 4:
      unsigned int v4 = 769;
      goto LABEL_12;
    case 6:
      if (*(_DWORD *)(a1 + 96) > 0x300u) {
        goto LABEL_13;
      }
      BOOL v5 = *(_DWORD *)(a1 + 100) > 0x302u;
      goto LABEL_15;
    case 7:
      unsigned int v4 = 770;
      goto LABEL_12;
    case 8:
      unsigned int v4 = 771;
LABEL_12:
      if (*(_DWORD *)(a1 + 96) <= v4) {
        BOOL v5 = *(_DWORD *)(a1 + 100) >= v4;
      }
      else {
LABEL_13:
      }
        BOOL v5 = 0;
LABEL_15:
      uint64_t v3 = 0;
      *a3 = v5;
      break;
    default:
      return v3;
  }
  return v3;
}

uint64_t _SSLSetProtocolVersion(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    return 4294967246;
  }
  unsigned int v2 = *(_DWORD *)(a1 + 80);
  BOOL v3 = v2 > 6;
  int v4 = (1 << v2) & 0x59;
  BOOL v5 = v3 || v4 == 0;
  if (v5 || *(unsigned char *)(a1 + 104)) {
    return 4294966387;
  }
  if (a2 > 8 || ((0x1FDu >> a2) & 1) == 0) {
    return 4294967246;
  }
  int v7 = dword_18B416FA4[a2];
  *(_DWORD *)(a1 + 96) = dword_18B416F80[a2];
  *(_DWORD *)(a1 + 100) = v7;
  tls_handshake_set_min_protocol_version();
  tls_handshake_set_max_protocol_version();
  return 0;
}

uint64_t _SSLGetProtocolVersion(uint64_t a1, int *a2)
{
  if (!a1) {
    return 4294967246;
  }
  switch(*(_DWORD *)(a1 + 100))
  {
    case 0x300:
      if (*(_DWORD *)(a1 + 96) != 768) {
        return 4294967246;
      }
      uint64_t result = 0;
      int v3 = 2;
      goto LABEL_14;
    case 0x301:
      int v4 = *(_DWORD *)(a1 + 96);
      if (v4 == 768)
      {
        uint64_t result = 0;
        int v3 = 4;
      }
      else
      {
        if (v4 != 769) {
          return 4294967246;
        }
        uint64_t result = 4294967246;
        int v3 = 5;
      }
LABEL_14:
      *a2 = v3;
      break;
    case 0x302:
      if (*(_DWORD *)(a1 + 96) != 768) {
        return 4294967246;
      }
      uint64_t result = 0;
      int v3 = 7;
      goto LABEL_14;
    case 0x303:
      if (*(_DWORD *)(a1 + 96) != 768) {
        return 4294967246;
      }
      uint64_t result = 0;
      int v3 = 6;
      goto LABEL_14;
    default:
      return 4294967246;
  }
  return result;
}

OSStatus SSLGetNegotiatedProtocolVersion(SSLContextRef context, SSLProtocol *protocol)
{
  if (!context) {
    return -50;
  }
  SSLProtocol v2 = kSSLProtocol3;
  switch(*((_DWORD *)context + 22))
  {
    case 0x300:
      break;
    case 0x301:
      SSLProtocol v2 = kTLSProtocol1;
      break;
    case 0x302:
      SSLProtocol v2 = kTLSProtocol11;
      break;
    case 0x303:
      SSLProtocol v2 = kTLSProtocol12;
      break;
    default:
      SSLProtocol v2 = kSSLProtocolUnknown;
      break;
  }
  OSStatus result = 0;
  *protocol = v2;
  return result;
}

uint64_t _SSLGetEnableCertVerify(uint64_t a1, unsigned char *a2)
{
  if (!a1) {
    return 4294967246;
  }
  uint64_t result = 0;
  *a2 = *(unsigned char *)(a1 + 187);
  return result;
}

uint64_t _SSLSetAllowsExpiredCerts()
{
  return 0;
}

uint64_t _SSLGetAllowsExpiredCerts()
{
  return 4294967292;
}

uint64_t _SSLSetAllowsExpiredRoots()
{
  return 0;
}

uint64_t _SSLGetAllowsExpiredRoots()
{
  return 4294967292;
}

uint64_t _SSLSetAllowsAnyRoot(uint64_t a1, char a2)
{
  if (!a1) {
    return 4294967246;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 312) = a2;
  return result;
}

uint64_t _SSLGetAllowsAnyRoot(uint64_t a1, unsigned char *a2)
{
  if (!a1) {
    return 4294967246;
  }
  uint64_t result = 0;
  *a2 = *(unsigned char *)(a1 + 312);
  return result;
}

uint64_t _SSLSetTrustedRoots(uint64_t a1, CFArrayRef theArray, int a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 80);
  BOOL v4 = v3 > 6;
  int v5 = (1 << v3) & 0x59;
  if (v4 || v5 == 0) {
    return 4294966387;
  }
  if (a3)
  {
    *(unsigned char *)(a1 + 184) = 1;
    unsigned int v9 = *(const void **)(a1 + 176);
    if (v9)
    {
      *(void *)(a1 + 176) = 0;
      CFRelease(v9);
    }
  }
  if (*(void *)(a1 + 176))
  {
    v12.length = CFArrayGetCount(theArray);
    v12.location = 0;
    CFArrayAppendArray(*(CFMutableArrayRef *)(a1 + 176), theArray, v12);
    return 0;
  }
  CFMutableArrayRef MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theArray);
  *(void *)(a1 + 176) = MutableCopy;
  if (MutableCopy) {
    return 0;
  }
  return 4294967188;
}

uint64_t _SSLCopyTrustedRoots(uint64_t a1, void *a2)
{
  uint64_t result = 4294967246;
  if (a1 && a2)
  {
    uint64_t v4 = *(void *)(a1 + 176);
    if (v4)
    {
      *a2 = v4;
      CFRetain(*(CFTypeRef *)(a1 + 176));
      return 0;
    }
    else
    {
      uint64_t result = 0;
      *a2 = 0;
    }
  }
  return result;
}

uint64_t SSLGetClientSideAuthenticate(uint64_t a1, _DWORD *a2)
{
  uint64_t result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      *a2 = *(_DWORD *)(a1 + 252);
    }
  }
  return result;
}

OSStatus SSLGetClientCertificateState(SSLContextRef context, SSLClientCertificateState *clientState)
{
  if (!context) {
    return -50;
  }
  SSLClientCertificateState v2 = *((_DWORD *)context + 64);
  if (*((_DWORD *)context + 27) == 1)
  {
    if (v2 == kSSLClientCertNone)
    {
LABEL_16:
      OSStatus result = 0;
      *clientState = v2;
      return result;
    }
    if (v2 == kSSLClientCertRequested)
    {
      unsigned int v3 = (char *)context + 152;
      goto LABEL_13;
    }
  }
  else
  {
    if (v2) {
      BOOL v5 = v2 == kSSLClientCertRejected;
    }
    else {
      BOOL v5 = 1;
    }
    if (v5) {
      goto LABEL_16;
    }
    if (v2 == kSSLClientCertRequested)
    {
      unsigned int v3 = (char *)context + 168;
LABEL_13:
      if (*(void *)v3) {
        SSLClientCertificateState v2 = kSSLClientCertSent;
      }
      else {
        SSLClientCertificateState v2 = kSSLClientCertRequested;
      }
      goto LABEL_16;
    }
  }
  return -9810;
}

OSStatus SSLSetEncryptionCertificate(SSLContextRef context, CFArrayRef certRefs)
{
  if (!context) {
    return -50;
  }
  unsigned int v3 = *((_DWORD *)context + 20);
  BOOL v4 = v3 > 6;
  int v5 = (1 << v3) & 0x59;
  if (v4 || v5 == 0) {
    return -909;
  }
  int v8 = (const void *)*((void *)context + 20);
  if (v8)
  {
    *((void *)context + 20) = 0;
    CFRelease(v8);
  }
  *((void *)context + 20) = certRefs;
  CFRetain(certRefs);
  return 0;
}

uint64_t SSLGetCertificate(uint64_t a1, void *a2)
{
  if (!a1) {
    return 4294967246;
  }
  uint64_t result = 0;
  *a2 = *(void *)(a1 + 152);
  return result;
}

uint64_t SSLGetEncryptionCertificate(uint64_t a1, void *a2)
{
  if (!a1) {
    return 4294967246;
  }
  uint64_t result = 0;
  *a2 = *(void *)(a1 + 160);
  return result;
}

OSStatus SSLSetPeerID(SSLContextRef context, const void *peerID, size_t peerIDLen)
{
  OSStatus result = -50;
  if (context && peerID && peerIDLen)
  {
    unsigned int v7 = *((_DWORD *)context + 20);
    BOOL v8 = v7 > 6;
    int v9 = (1 << v7) & 0x59;
    BOOL v10 = v8 || v9 == 0;
    if (!v10 || *((_DWORD *)context + 64) == 1)
    {
      unsigned int v11 = (void *)*((void *)context + 27);
      if (v11) {
        free(v11);
      }
      *((void *)context + 26) = 0;
      *((void *)context + 27) = 0;
      CFRange v12 = malloc_type_malloc(peerIDLen, 0xEFB4CC30uLL);
      if (v12) {
        size_t v13 = peerIDLen;
      }
      else {
        size_t v13 = 0;
      }
      *((void *)context + 26) = v13;
      *((void *)context + 27) = v12;
      if (v12)
      {
        tls_handshake_set_resumption();
        memmove(*((void **)context + 27), peerID, peerIDLen);
        return 0;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      return -909;
    }
  }
  return result;
}

OSStatus SSLGetPeerID(SSLContextRef context, const void **peerID, size_t *peerIDLen)
{
  size_t v3 = *((void *)context + 26);
  *peerID = (const void *)*((void *)context + 27);
  *peerIDLen = v3;
  return 0;
}

OSStatus SSLGetNegotiatedCipher(SSLContextRef context, SSLCipherSuite *cipherSuite)
{
  if (!context) {
    return -50;
  }
  unsigned int v3 = *((_DWORD *)context + 20);
  if (v3 < 7 && ((0x59u >> v3) & 1) != 0) {
    return -909;
  }
  SSLCipherSuite negotiated_cipherspec = tls_handshake_get_negotiated_cipherspec();
  OSStatus result = 0;
  *cipherSuite = negotiated_cipherspec;
  return result;
}

OSStatus SSLAddDistinguishedName(SSLContextRef context, const void *derDN, size_t derDNLen)
{
  if (!context) {
    return -50;
  }
  unsigned int v4 = *((_DWORD *)context + 20);
  BOOL v5 = v4 > 6;
  int v6 = (1 << v4) & 0x59;
  if (v5 || v6 == 0) {
    return -909;
  }
  BOOL v10 = malloc_type_malloc(0x18uLL, 0xEFB4CC30uLL);
  if (!v10) {
    return -108;
  }
  unsigned int v11 = v10;
  CFRange v12 = malloc_type_malloc(derDNLen, 0xEFB4CC30uLL);
  if (v12) {
    size_t v13 = derDNLen;
  }
  else {
    size_t v13 = 0;
  }
  v11[1] = v13;
  v11[2] = v12;
  if (v12)
  {
    memcpy(v12, derDN, derDNLen);
    *unsigned int v11 = *((void *)context + 33);
    *((void *)context + 33) = v11;
    tls_handshake_set_acceptable_dn_list();
    return 0;
  }
  else
  {
    free(v11);
    return -1;
  }
}

uint64_t _SSLSetCertificateAuthorities(uint64_t a1, CFTypeRef cf, int a3)
{
  if (!a1) {
    return 4294967246;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 80);
  BOOL v5 = v4 > 6;
  int v6 = (1 << v4) & 0x59;
  BOOL v7 = v5 || v6 == 0;
  if (v7 || *(_DWORD *)(a1 + 108)) {
    return 4294967246;
  }
  if (a3)
  {
    sslFreeDnList(a1);
    BOOL v10 = *(const void **)(a1 + 272);
    if (v10)
    {
      CFRelease(v10);
      *(void *)(a1 + 272) = 0;
    }
  }
  CFTypeID v11 = CFGetTypeID(cf);
  if (v11 != SecCertificateGetTypeID())
  {
    if (v11 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
      if (Count < 1) {
        return 0;
      }
      CFIndex v13 = Count;
      CFIndex v14 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, v14);
        CFTypeID v16 = CFGetTypeID(ValueAtIndex);
        if (v16 != SecCertificateGetTypeID()) {
          break;
        }
        uint64_t result = sslAddCA((SSLContext *)a1, ValueAtIndex);
        if (!result && v13 != ++v14) {
          continue;
        }
        return result;
      }
    }
    return 4294967246;
  }

  return sslAddCA((SSLContext *)a1, cf);
}

uint64_t sslAddCA(SSLContext *a1, const void *a2)
{
  unsigned int v4 = SecDERItemCopySequence((uint64_t)a2 + 184);
  if (!v4) {
    return 4294967246;
  }
  CFDataRef v5 = v4;
  CFDataRef Mutable = (__CFArray *)*((void *)a1 + 34);
  if (Mutable
    || (CFDataRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]), (*((void *)a1 + 34) = Mutable) != 0))
  {
    CFArrayAppendValue(Mutable, a2);
    BytePtr = CFDataGetBytePtr(v5);
    CFIndex Length = CFDataGetLength(v5);
    uint64_t v9 = SSLAddDistinguishedName(a1, BytePtr, Length);
  }
  else
  {
    uint64_t v9 = 4294967246;
  }
  CFRelease(v5);
  return v9;
}

uint64_t _SSLCopyCertificateAuthorities(uint64_t a1, void *a2)
{
  uint64_t result = 4294967246;
  if (a1 && a2)
  {
    uint64_t v4 = *(void *)(a1 + 272);
    if (v4)
    {
      *a2 = v4;
      CFRetain(*(CFTypeRef *)(a1 + 272));
      return 0;
    }
    else
    {
      uint64_t result = 0;
      *a2 = 0;
    }
  }
  return result;
}

OSStatus SSLCopyDistinguishedNames(SSLContextRef context, CFArrayRef *names)
{
  OSStatus result = -50;
  if (context && names)
  {
    if (*((_DWORD *)context + 27))
    {
      uint64_t peer_acceptable_dn_list = tls_handshake_get_peer_acceptable_dn_list();
      if (peer_acceptable_dn_list) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t peer_acceptable_dn_list = *((void *)context + 33);
      if (peer_acceptable_dn_list)
      {
LABEL_5:
        CFDataRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
        do
        {
          CFDataRef v7 = CFDataCreate(0, *(const UInt8 **)(peer_acceptable_dn_list + 16), *(void *)(peer_acceptable_dn_list + 8));
          CFArrayAppendValue(Mutable, v7);
          CFRelease(v7);
          uint64_t peer_acceptable_dn_list = *(void *)peer_acceptable_dn_list;
        }
        while (peer_acceptable_dn_list);
        goto LABEL_10;
      }
    }
    CFDataRef Mutable = 0;
LABEL_10:
    OSStatus result = 0;
    *names = Mutable;
  }
  return result;
}

uint64_t _SSLSetDiffieHellmanParams(uint64_t a1, const void *a2, size_t size)
{
  if (!a1) {
    return 4294967246;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 80);
  BOOL v5 = v4 > 6;
  int v6 = (1 << v4) & 0x59;
  if (v5 || v6 == 0) {
    return 4294966387;
  }
  BOOL v10 = (void *)(a1 + 136);
  CFTypeID v11 = *(void **)(a1 + 144);
  if (v11) {
    free(v11);
  }
  *BOOL v10 = 0;
  *(void *)(a1 + 144) = 0;
  CFRange v12 = malloc_type_malloc(size, 0xEFB4CC30uLL);
  if (v12)
  {
    CFIndex v13 = v12;
    memmove(v12, a2, size);
    *(void *)(a1 + 136) = size;
    *(void *)(a1 + 144) = v13;
    uint64_t v14 = *(void *)(a1 + 56);
    return MEMORY[0x1F417F2D0](v14, a1 + 136);
  }
  else
  {
    *(void *)(a1 + 144) = 0;
    return 0xFFFFFFFFLL;
  }
}

uint64_t _SSLGetDiffieHellmanParams(uint64_t a1, void *a2, void *a3)
{
  if (!a1) {
    return 4294967246;
  }
  uint64_t result = 0;
  uint64_t v6 = a1 + 136;
  uint64_t v5 = *(void *)(a1 + 136);
  *a2 = *(void *)(v6 + 8);
  *a3 = v5;
  return result;
}

uint64_t SSLSetDHEEnabled(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 552) = a2;
  tls_handshake_get_min_protocol_version();
  tls_handshake_get_max_protocol_version();
  tls_handshake_get_min_dh_group_size();
  tls_handshake_set_config();
  tls_handshake_set_min_protocol_version();
  tls_handshake_set_max_protocol_version();
  tls_handshake_set_min_dh_group_size();
  return 0;
}

uint64_t SSLGetDHEEnabled(uint64_t a1, unsigned char *a2)
{
  *a2 = *(unsigned char *)(a1 + 552);
  return 0;
}

uint64_t SSLSetMinimumDHGroupSize()
{
  return tls_handshake_set_min_dh_group_size();
}

uint64_t SSLGetMinimumDHGroupSize()
{
  return tls_handshake_get_min_dh_group_size();
}

uint64_t _SSLSetRsaBlinding(uint64_t a1, char a2)
{
  if (!a1) {
    return 4294967246;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 314) = a2;
  return result;
}

uint64_t _SSLGetRsaBlinding(uint64_t a1, unsigned char *a2)
{
  if (!a1) {
    return 4294967246;
  }
  uint64_t result = 0;
  *a2 = *(unsigned char *)(a1 + 314);
  return result;
}

OSStatus SSLCopyPeerTrust(SSLContextRef context, SecTrustRef *trust)
{
  OSStatus SecTrust = -50;
  if (context && trust)
  {
    uint64_t v6 = (CFTypeRef *)((char *)context + 168);
    uint64_t v5 = (__SecTrust *)*((void *)context + 21);
    if (v5)
    {
      OSStatus SecTrust = 0;
    }
    else
    {
      OSStatus SecTrust = sslCreateSecTrust((uint64_t)context, (void *)context + 21);
      uint64_t v5 = (__SecTrust *)*((void *)context + 21);
    }
    *trust = v5;
    if (*v6) {
      CFRetain(*v6);
    }
  }
  return SecTrust;
}

uint64_t SSLGetPeerSecTrust(uint64_t a1, void *a2)
{
  uint64_t result = 4294967246;
  if (a1 && a2)
  {
    uint64_t v5 = *(void *)(a1 + 168);
    if (v5)
    {
      uint64_t result = 0;
    }
    else
    {
      uint64_t result = sslCreateSecTrust(a1, (void *)(a1 + 168));
      uint64_t v5 = *(void *)(a1 + 168);
    }
    *a2 = v5;
  }
  return result;
}

uint64_t SSLInternalMasterSecret(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && a3) {
    return MEMORY[0x1F417F248](*(void *)(a1 + 56));
  }
  else {
    return 4294967246;
  }
}

uint64_t SSLInternalServerRandom(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && a3) {
    return MEMORY[0x1F417F258](*(void *)(a1 + 56));
  }
  else {
    return 4294967246;
  }
}

uint64_t SSLInternalClientRandom(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && a3) {
    return MEMORY[0x1F417F240](*(void *)(a1 + 56));
  }
  else {
    return 4294967246;
  }
}

uint64_t SSLGetCipherSizes(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t result = 4294967246;
  if (a1 && a2 && a3)
  {
    if (a4)
    {
      tls_handshake_get_negotiated_cipherspec();
      *a2 = sslCipherSuiteGetMacSize();
      *a3 = sslCipherSuiteGetSymmetricCipherKeySize();
      unsigned int SymmetricCipherBlockIvSize = sslCipherSuiteGetSymmetricCipherBlockIvSize();
      uint64_t result = 0;
      *a4 = SymmetricCipherBlockIvSize;
    }
  }
  return result;
}

uint64_t SSLGetResumableSessionInfo(uint64_t a1, unsigned char *a2, void *a3, unint64_t *a4)
{
  uint64_t result = 4294967246;
  if (a1 && a2 && a3 && a4)
  {
    if (*a4 < 0x20) {
      return 4294967246;
    }
    if (tls_handshake_get_session_match())
    {
      *a2 = 1;
      unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
      if (*a4 < 0xAAAAAAAAAAAAAAAALL) {
        return 4294967246;
      }
      memmove(a3, (const void *)0xAAAAAAAAAAAAAAAALL, 0xAAAAAAAAAAAAAAAALL);
    }
    else
    {
      unint64_t v9 = 0;
      *a2 = 0;
    }
    uint64_t result = 0;
    *a4 = v9;
  }
  return result;
}

uint64_t SSLSetAllowAnonymousCiphers()
{
  return 0;
}

uint64_t SSLGetAllowAnonymousCiphers()
{
  return 0;
}

uint64_t SSLSetSessionCacheTimeout(uint64_t a1, int a2)
{
  if (!a1) {
    return 4294967246;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 316) = a2;
  return result;
}

uint64_t SSLInternalSetMasterSecretFunction(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 4294967246;
  }
  a1[42] = a2;
  a1[43] = a3;
  return MEMORY[0x1F417F260](a1[7], tls_handshake_master_secret_function, a1);
}

uint64_t tls_handshake_master_secret_function(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(a1 + 336))(a1, *(void *)(a1 + 344), a2, a3);
}

uint64_t SSLInternalSetSessionTicket(uint64_t a1)
{
  if (!a1) {
    return 4294967246;
  }
  unsigned int v1 = *(_DWORD *)(a1 + 80);
  BOOL v2 = v1 > 6;
  int v3 = (1 << v1) & 0x59;
  if (v2 || v3 == 0) {
    return 4294966387;
  }
  else {
    return MEMORY[0x1F417F268](*(void *)(a1 + 56));
  }
}

uint64_t SSLGetNegotiatedCurve(uint64_t a1, _DWORD *a2)
{
  uint64_t result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      int negotiated_curve = tls_handshake_get_negotiated_curve();
      uint64_t result = 0;
      *a2 = negotiated_curve;
    }
  }
  return result;
}

uint64_t SSLGetNumberOfECDSACurves(uint64_t a1, _DWORD *a2)
{
  uint64_t result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      *a2 = *(_DWORD *)(a1 + 248);
    }
  }
  return result;
}

uint64_t SSLGetECDSACurves(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v3 = 4294967246;
  if (a1 && a2 && a3)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 248);
    if (*a3 >= v4)
    {
      if (v4)
      {
        unint64_t v5 = 0;
        do
        {
          *(_DWORD *)(a2 + 4 * v5) = *(unsigned __int16 *)(*(void *)(a1 + 240) + 2 * v5);
          ++v5;
          unint64_t v6 = *(unsigned int *)(a1 + 248);
        }
        while (v5 < v6);
      }
      else
      {
        LODWORD(v6) = 0;
      }
      uint64_t v3 = 0;
      *a3 = v6;
    }
    else
    {
      return 4294967246;
    }
  }
  return v3;
}

uint64_t SSLSetECDSACurves(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = 4294967246;
  if (a1 && a2 && a3)
  {
    unsigned int v7 = *(_DWORD *)(a1 + 80);
    BOOL v8 = v7 > 6;
    int v9 = (1 << v7) & 0x59;
    if (v8 || v9 == 0)
    {
      return 4294966387;
    }
    else
    {
      CFTypeID v11 = malloc_type_malloc(2 * a3, 0xEFB4CC30uLL);
      *(void *)(a1 + 240) = v11;
      if (v11)
      {
        uint64_t v12 = 0;
        do
        {
          int v13 = *(_DWORD *)(a2 + 4 * v12);
          if (v13 > 65534) {
            LOWORD(v13) = -1;
          }
          v11[v12++] = v13;
        }
        while (a3 != v12);
        *(_DWORD *)(a1 + 248) = a3;
        tls_handshake_set_curves();
        return 0;
      }
      else
      {
        *(_DWORD *)(a1 + 248) = 0;
        return 4294967188;
      }
    }
  }
  return result;
}

uint64_t SSLGetNumberOfClientAuthTypes(uint64_t a1, _DWORD *a2)
{
  if (!a1 || !*(_DWORD *)(a1 + 256)) {
    return 4294967246;
  }
  uint64_t result = 0;
  *a2 = *(_DWORD *)(a1 + 400);
  return result;
}

uint64_t SSLGetClientAuthTypes(uint64_t a1, void *__dst, _DWORD *a3)
{
  if (!a1) {
    return 4294967246;
  }
  if (!*(_DWORD *)(a1 + 256)) {
    return 4294967246;
  }
  memmove(__dst, *(const void **)(a1 + 408), 4 * *(unsigned int *)(a1 + 400));
  uint64_t result = 0;
  *a3 = *(_DWORD *)(a1 + 400);
  return result;
}

uint64_t SSLGetNegotiatedClientAuthType()
{
  return 4294967292;
}

uint64_t SSLGetNumberOfSignatureAlgorithms(uint64_t a1)
{
  if (!a1) {
    return 4294967246;
  }
  tls_handshake_get_peer_signature_algorithms();
  return 0;
}

uint64_t SSLGetSignatureAlgorithms(uint64_t a1, void *a2, _DWORD *a3)
{
  if (!a1) {
    return 4294967246;
  }
  peer_signature_algorithms = (const void *)tls_handshake_get_peer_signature_algorithms();
  memmove(a2, peer_signature_algorithms, 0x555555550uLL);
  uint64_t result = 0;
  *a3 = -1431655766;
  return result;
}

uint64_t SSLSetPSKSharedSecret(uint64_t a1, const void *a2, size_t size)
{
  if (!a1) {
    return 4294967246;
  }
  unint64_t v6 = (void *)(a1 + 480);
  unsigned int v7 = *(void **)(a1 + 488);
  if (v7)
  {
    free(v7);
    *unint64_t v6 = 0;
    v6[1] = 0;
  }
  BOOL v8 = malloc_type_malloc(size, 0xEFB4CC30uLL);
  if (v8)
  {
    int v9 = v8;
    memmove(v8, a2, size);
    *(void *)(a1 + 480) = size;
    *(void *)(a1 + 488) = v9;
    tls_handshake_set_psk_secret();
    return 0;
  }
  else
  {
    *(void *)(a1 + 488) = 0;
    return 4294967188;
  }
}

uint64_t SSLSetPSKIdentity(uint64_t a1, const void *a2, size_t size)
{
  uint64_t result = 4294967246;
  if (a1 && a2 && size)
  {
    unsigned int v7 = *(void **)(a1 + 504);
    if (v7)
    {
      free(v7);
      *(void *)(a1 + 496) = 0;
      *(void *)(a1 + 504) = 0;
    }
    BOOL v8 = malloc_type_malloc(size, 0xEFB4CC30uLL);
    if (v8)
    {
      int v9 = v8;
      memmove(v8, a2, size);
      *(void *)(a1 + 496) = size;
      *(void *)(a1 + 504) = v9;
      tls_handshake_set_psk_identity();
      return 0;
    }
    else
    {
      *(void *)(a1 + 504) = 0;
      return 4294967188;
    }
  }
  return result;
}

uint64_t SSLGetPSKIdentity(uint64_t a1, void *a2, void *a3)
{
  uint64_t result = 4294967246;
  if (a1 && a2)
  {
    if (a3)
    {
      uint64_t result = 0;
      uint64_t v6 = a1 + 496;
      uint64_t v5 = *(void *)(a1 + 496);
      *a2 = *(void *)(v6 + 8);
      *a3 = v5;
    }
  }
  return result;
}

uint64_t SSLInternal_PRF(uint64_t a1)
{
  return MEMORY[0x1F417F250](*(void *)(a1 + 56));
}

uint64_t tls_handshake_rollback_write_callback(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 32))(*(void *)(a1 + 48));
}

uint64_t tls_handshake_delete_all_sessions_callback(uint64_t a1)
{
  if (*(void *)(a1 + 64)) {
    tls_cache_empty();
  }
  return 0;
}

uint64_t tls_handshake_delete_session_data_callback(uint64_t a1)
{
  if (*(void *)(a1 + 64)) {
    return tls_cache_delete_session_data();
  }
  else {
    return 4294957492;
  }
}

uint64_t tls_handshake_load_session_data_callback(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  v12[0] = a2;
  v12[1] = a3;
  uint64_t v6 = (void *)(a1 + 224);
  unsigned int v7 = *(void **)(a1 + 232);
  if (v7) {
    free(v7);
  }
  *uint64_t v6 = 0;
  v6[1] = 0;
  if (!*(void *)(a1 + 64)) {
    return 4294957492;
  }
  size_t v10 = 0;
  CFTypeID v11 = 0;
  uint64_t session_data = _buildConfigurationSpecificSessionCacheKey(a1, (uint64_t)v12, &v10);
  if (!session_data)
  {
    uint64_t session_data = tls_cache_load_session_data();
    *a4 = *(_OWORD *)v6;
    free(v11);
  }
  return session_data;
}

uint64_t _buildConfigurationSpecificSessionCacheKey(uint64_t a1, uint64_t a2, size_t *a3)
{
  if (!*(void *)(a1 + 376))
  {
    int v9 = malloc_type_malloc(0xAuLL, 0x97F90E8AuLL);
    if (v9)
    {
      BOOL v8 = v9;
      *int v9 = *(unsigned char *)(a1 + 353);
      v9[1] = *(unsigned char *)(a1 + 354);
      v9[2] = *(unsigned char *)(a1 + 355);
      v9[3] = *(unsigned char *)(a1 + 356);
      v9[4] = *(unsigned char *)(a1 + 357);
      v9[5] = *(unsigned char *)(a1 + 358);
      v9[6] = *(unsigned char *)(a1 + 359);
      v9[7] = *(unsigned char *)(a1 + 360);
      v9[8] = *(unsigned char *)(a1 + 361);
      v9[9] = *(unsigned char *)(a1 + 362);
      size_t v6 = 10;
      *(void *)(a1 + 368) = 10;
      size_t v10 = malloc_type_malloc(0xAuLL, 0x112F0A46uLL);
      *(void *)(a1 + 376) = v10;
      __int16 v11 = v8[4];
      *(void *)size_t v10 = *(void *)v8;
      v10[4] = v11;
      goto LABEL_6;
    }
    return 4294967188;
  }
  size_t v6 = *(void *)(a1 + 368);
  unsigned int v7 = malloc_type_malloc(v6, 0xA78CAAAuLL);
  if (!v7) {
    return 4294967188;
  }
  BOOL v8 = v7;
  memcpy(v7, *(const void **)(a1 + 376), v6);
LABEL_6:
  size_t v12 = *(void *)a2 + v6;
  *a3 = v12;
  int v13 = malloc_type_malloc(v12, 0x989C50EEuLL);
  a3[1] = (size_t)v13;
  if (v13)
  {
    memcpy(v13, v8, v6);
    memcpy((void *)(a3[1] + v6), *(const void **)(a2 + 8), *(void *)a2);
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v14 = 4294967188;
  }
  free(v8);
  return v14;
}

uint64_t tls_handshake_save_session_data_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a2;
  v11[1] = a3;
  uint64_t v9 = a4;
  uint64_t v10 = a5;
  if (!*(void *)(a1 + 64)) {
    return 4294957492;
  }
  size_t v7 = 0;
  BOOL v8 = 0;
  uint64_t v5 = _buildConfigurationSpecificSessionCacheKey(a1, (uint64_t)v11, &v7);
  if (!v5)
  {
    uint64_t v5 = tls_cache_save_session_data();
    free(v8);
  }
  return v5;
}

uint64_t tls_handshake_set_retransmit_timer_callback(uint64_t a1, int a2)
{
  if (a2) {
    double v3 = CFAbsoluteTimeGetCurrent() + (double)(1 << (a2 - 1)) * *(double *)(a1 + 424);
  }
  else {
    double v3 = 0.0;
  }
  *(double *)(a1 + 416) = v3;
  return 0;
}

uint64_t SSLRollbackInternalRecordLayerWriteCipher(void *a1)
{
  return MEMORY[0x1F417F3D0](*a1);
}

void log_SecureTransport_early_fail(uint64_t a1)
{
  CFStringRef v1 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"com.apple.SecureTransport.early_fail.%ld", a1);
  if (v1)
  {
    CFStringRef v2 = v1;
    SecCoreAnalyticsSendValue((uint64_t)v1, 1);
    CFRelease(v2);
  }
}

OSStatus SSLReHandshake(SSLContextRef context)
{
  if (!context) {
    return -50;
  }
  unsigned int v1 = *((_DWORD *)context + 20) - 1;
  if (v1 < 6 && ((0x2Du >> v1) & 1) != 0) {
    return dword_18B416FC8[v1];
  }
  if (*((_DWORD *)context + 27) == 1) {
    return SSLHandshakeStart((uint64_t)context);
  }
  return MEMORY[0x1F417F280](*((void *)context + 7));
}

uint64_t SSLHandshakeStart(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long md = v2;
  long long v15 = v2;
  uint64_t v10 = 0;
  __int16 v11 = &v10;
  uint64_t v12 = 0x8000000000;
  *(_OWORD *)v13.count = v2;
  *(_OWORD *)&v13.hash[2] = v2;
  *(_OWORD *)&v13.hash[6] = v2;
  *(_OWORD *)&v13.wbuf[2] = v2;
  *(_OWORD *)&v13.wbuf[6] = v2;
  *(_OWORD *)&v13.wbuf[10] = v2;
  *(void *)&v13.wbuf[14] = 0xAAAAAAAAAAAAAAAALL;
  CC_SHA256_Init(&v13);
  CC_SHA256_Update((CC_SHA256_CTX *)(v11 + 3), (const void *)(a1 + 312), 1u);
  CC_SHA256_Update((CC_SHA256_CTX *)(v11 + 3), (const void *)(a1 + 184), 1u);
  CFArrayRef v3 = *(const __CFArray **)(a1 + 176);
  if (v3)
  {
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 0x40000000;
    context[2] = __get_extended_peer_id_block_invoke;
    context[3] = &unk_1E547E3C8;
    context[4] = &v10;
    v17.length = CFArrayGetCount(v3);
    v17.location = 0;
    CFArrayApplyFunction(v3, v17, (CFArrayApplierFunction)apply_block_1_7970, context);
  }
  CC_SHA256_Final((unsigned __int8 *)&md, (CC_SHA256_CTX *)(v11 + 3));
  BOOL v8 = (char *)malloc_type_malloc(*(void *)(a1 + 208) + 32, 0xEFB4CC30uLL);
  memcpy(v8, *(const void **)(a1 + 216), *(void *)(a1 + 208));
  unsigned int v4 = &v8[*(void *)(a1 + 208)];
  long long v5 = v15;
  *(_OWORD *)unsigned int v4 = md;
  *((_OWORD *)v4 + 1) = v5;
  _Block_object_dispose(&v10, 8);
  uint64_t v6 = tls_handshake_negotiate();
  free(v8);
  if (!v6)
  {
    *(void *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 80) = 1;
  }
  return v6;
}

uint64_t __get_extended_peer_id_block_invoke(uint64_t a1, uint64_t a2)
{
  return CC_SHA256_Update((CC_SHA256_CTX *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), *(const void **)(a2 + 16), *(_DWORD *)(a2 + 24));
}

uint64_t apply_block_1_7970(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

OSStatus SSLSetError(SSLContextRef context, OSStatus status)
{
  *((_DWORD *)context + 20) = 6;
  *((_DWORD *)context + 21) = status;
  return 0;
}

OSStatus SSLGetBufferedReadSize(SSLContextRef context, size_t *bufferSize)
{
  if (!context) {
    return -50;
  }
  size_t v2 = *((void *)context + 37);
  if (v2) {
    size_t v2 = *((void *)context + 36) - *((void *)context + 38);
  }
  OSStatus result = 0;
  *bufferSize = v2;
  return result;
}

BOOL SSLIsSessionNegotiatedWithUnsafeDH(BOOL result)
{
  if (result) {
    return tls_handshake_get_session_warning() == -49;
  }
  return result;
}

uint64_t SSLCiphersuiteGroupToCiphersuiteList(int a1, void *a2)
{
  if ((a1 - 1) >= 4) {
    unsigned __int16 v2 = 0;
  }
  else {
    unsigned __int16 v2 = a1;
  }
  if (!a2) {
    return 0;
  }
  if (v2 > 4u)
  {
    uint64_t v4 = 0;
    uint64_t result = 0;
  }
  else
  {
    uint64_t v3 = v2;
    uint64_t v4 = qword_18B415710[v2];
    uint64_t result = (uint64_t)*(&off_1E5477488 + v3);
  }
  *a2 = v4;
  return result;
}

BOOL SSLCiphersuiteGroupContainsCiphersuite(int a1, int a2)
{
  BOOL result = 0;
  if ((a1 - 1) >= 4) {
    LOWORD(a1) = 0;
  }
  if ((unsigned __int16)a1 <= 4u)
  {
    uint64_t v4 = qword_18B415710[(unsigned __int16)a1];
    long long v5 = (unsigned __int16 *)*(&off_1E5477488 + (unsigned __int16)a1);
    uint64_t v6 = v4 - 1;
    do
    {
      int v7 = *v5++;
      BOOL result = v7 == a2;
    }
    while (v7 != a2 && v6-- != 0);
  }
  return result;
}

uint64_t SSLProtocolGetVersionCodepoint(int a1)
{
  uint64_t v1 = 0;
  unsigned __int16 v2 = ssl_protocol_version_map;
  while (1)
  {
    int v3 = *v2;
    v2 += 2;
    if (v3 == a1) {
      break;
    }
    if (++v1 == 8) {
      return 0;
    }
  }
  return LOWORD(ssl_protocol_version_map[2 * v1 + 1]);
}

uint64_t SSLCiphersuiteMinimumTLSVersion(int a1)
{
  uint64_t v1 = 0;
  unsigned __int16 v2 = tls_ciphersuite_definitions;
  while (1)
  {
    int v3 = (unsigned __int16)*v2;
    v2 += 35;
    if (v3 == a1) {
      break;
    }
    if (++v1 == 37)
    {
      int v4 = 0;
      goto LABEL_6;
    }
  }
  int v4 = (unsigned __int16)tls_ciphersuite_definitions[35 * v1 + 1];
LABEL_6:
  uint64_t v5 = 0;
  uint64_t v6 = &word_18B416FE4;
  while (1)
  {
    int v7 = (unsigned __int16)*v6;
    v6 += 4;
    if (v7 == v4) {
      break;
    }
    if (++v5 == 8) {
      return 0;
    }
  }
  return ssl_protocol_version_map[2 * v5];
}

uint64_t SSLCiphersuiteMaximumTLSVersion(int a1)
{
  uint64_t v1 = 0;
  unsigned __int16 v2 = tls_ciphersuite_definitions;
  while (1)
  {
    int v3 = (unsigned __int16)*v2;
    v2 += 35;
    if (v3 == a1) {
      break;
    }
    if (++v1 == 37)
    {
      int v4 = 0;
      goto LABEL_6;
    }
  }
  int v4 = (unsigned __int16)tls_ciphersuite_definitions[35 * v1 + 2];
LABEL_6:
  uint64_t v5 = 0;
  uint64_t v6 = &word_18B416FE4;
  while (1)
  {
    int v7 = (unsigned __int16)*v6;
    v6 += 4;
    if (v7 == v4) {
      break;
    }
    if (++v5 == 8) {
      return 0;
    }
  }
  return ssl_protocol_version_map[2 * v5];
}

OSStatus SSLGetNumberSupportedCiphers(SSLContextRef context, size_t *numCiphers)
{
  OSStatus result = -50;
  if (context)
  {
    if (numCiphers)
    {
      OSStatus result = 0;
      *numCiphers = 67;
    }
  }
  return result;
}

OSStatus SSLGetSupportedCiphers(SSLContextRef context, SSLCipherSuite *ciphers, size_t *numCiphers)
{
  OSStatus result = -50;
  if (context && ciphers && numCiphers)
  {
    if (*numCiphers >= 0x43)
    {
      for (uint64_t i = 0; i != 67; ++i)
        ciphers[i] = STKnownCipherSuites[i];
      OSStatus result = 0;
      *numCiphers = 67;
    }
    else
    {
      return -9817;
    }
  }
  return result;
}

OSStatus SSLSetEnabledCiphers(SSLContextRef context, const SSLCipherSuite *ciphers, size_t numCiphers)
{
  OSStatus result = -50;
  if (context && ciphers && numCiphers)
  {
    unsigned int v7 = *((_DWORD *)context + 20);
    BOOL v8 = v7 > 6;
    int v9 = (0x10000010100uLL >> (8 * v7));
    if (!v8 && v9 == 0)
    {
      uint64_t v11 = 0;
      int v12 = 0;
      do
      {
        uint64_t v13 = 0;
        while (STKnownCipherSuites[v13] != ciphers[v11])
        {
          if (++v13 == 67) {
            goto LABEL_15;
          }
        }
        ++v12;
LABEL_15:
        ++v11;
      }
      while (v11 != numCiphers);
      if (v12)
      {
        uint64_t v14 = malloc_type_malloc(2 * v12, 0xEFB4CC30uLL);
        if (v14)
        {
          long long v15 = v14;
          uint64_t v16 = 0;
          int v17 = 0;
          do
          {
            uint64_t v18 = 0;
            int v19 = ciphers[v16];
            while ((unsigned __int16)STKnownCipherSuites[v18] != v19)
            {
              if (++v18 == 67) {
                goto LABEL_24;
              }
            }
            *((_WORD *)v14 + v17++) = v19;
LABEL_24:
            ++v16;
          }
          while (v16 != numCiphers);
          OSStatus v20 = tls_handshake_set_ciphersuites();
          free(v15);
          return v20;
        }
        else
        {
          return -108;
        }
      }
      else
      {
        return -50;
      }
    }
    else
    {
      return -909;
    }
  }
  return result;
}

OSStatus SSLGetNumberEnabledCiphers(SSLContextRef context, size_t *numCiphers)
{
  OSStatus result = -50;
  if (context && numCiphers)
  {
    OSStatus result = tls_handshake_get_ciphersuites();
    if (!result) {
      *numCiphers = 2863311530;
    }
  }
  return result;
}

OSStatus SSLGetEnabledCiphers(SSLContextRef context, SSLCipherSuite *ciphers, size_t *numCiphers)
{
  OSStatus result = -50;
  if (context)
  {
    uint64_t v5 = ciphers;
    if (ciphers)
    {
      if (numCiphers)
      {
        OSStatus result = tls_handshake_get_ciphersuites();
        if (!result)
        {
          if (*numCiphers >= 0xAAAAAAAA)
          {
            unsigned int v7 = (SSLCipherSuite *)0xAAAAAAAAAAAAAAAALL;
            uint64_t v8 = 2863311530;
            do
            {
              SSLCipherSuite v9 = *v7++;
              *v5++ = v9;
              --v8;
            }
            while (v8);
            OSStatus result = 0;
            *numCiphers = 2863311530;
          }
          else
          {
            return -9817;
          }
        }
      }
    }
  }
  return result;
}

OSStatus SSLSetSessionTicketsEnabled(SSLContextRef context, Boolean enabled)
{
  if (context) {
    return tls_handshake_set_session_ticket_enabled();
  }
  else {
    return -50;
  }
}

uint64_t SOSCCSetSOSDisabledError(CFTypeRef *a1)
{
  if (a1)
  {
    if (staticSOSDisabledError_onceToken != -1) {
      dispatch_once(&staticSOSDisabledError_onceToken, &__block_literal_global_277);
    }
    *a1 = CFRetain((CFTypeRef)staticSOSDisabledError_sosIsDisabledError);
  }
  return 1;
}

void __staticSOSDisabledError_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t SOSCCThisDeviceIsInCircle(CFTypeRef *a1)
{
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t result = SOSGetCachedCircleStatus(a1);
    if (result == -99)
    {
      return SOSCCThisDeviceIsInCircleNonCached(a1);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t SOSCCIsSOSTrustAndSyncingEnabled()
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v0 = secLogObjForScope("sos-compatibility-mode");
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_18B299000, v0, OS_LOG_TYPE_DEBUG, "enter SOSCCIsSOSTrustAndSyncingEnabled", buf, 2u);
  }

  if (!OctagonIsSOSFeatureEnabled() || !SOSCompatibilityModeEnabled()) {
    return OctagonIsSOSFeatureEnabled();
  }
  uint64_t v1 = secLogObjForScope("sos-compatibility-mode");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18B299000, v1, OS_LOG_TYPE_DEFAULT, "SOS Compatibility Mode feature flag enabled, checking platform availability and sos compat mode", buf, 2u);
  }

  CFTypeRef cf = 0;
  uint64_t v2 = SOSCCFetchCompatibilityMode(&cf);
  int v3 = secLogObjForScope("sos-compatibility-mode");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = @"disabled";
    if (v2) {
      int v4 = @"enabled";
    }
    *(_DWORD *)buf = 138412290;
    CFTypeRef v10 = v4;
    _os_log_impl(&dword_18B299000, v3, OS_LOG_TYPE_DEFAULT, "sos trust and syncing is %@", buf, 0xCu);
  }

  if (cf)
  {
    uint64_t v5 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      CFTypeRef v10 = cf;
      _os_log_impl(&dword_18B299000, v5, OS_LOG_TYPE_DEFAULT, "sos-compatibility-mode: fetching compatibility mode error: %@", buf, 0xCu);
    }

    CFTypeRef v6 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v6);
    }
  }
  return v2;
}

uint64_t SOSCCThisDeviceIsInCircleNonCached(CFTypeRef *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    unsigned int v7 = SecLogAPICreate(0, "SOSCCThisDeviceIsInCircleNonCached", 0, v2, v3, v4, v5, v6, 0);
    uint64_t v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      OSStatus v20 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    v18[2] = __SOSCCThisDeviceIsInCircleNonCached_block_invoke;
    v18[3] = &__block_descriptor_40_e5_i8__0l;
    v18[4] = a1;
    uint64_t v9 = __SOSCCThisDeviceIsInCircleNonCached_block_invoke((uint64_t)v18);
    long long v15 = SecLogAPICreate(0, "SOSCCThisDeviceIsInCircleNonCached", @"SOSCCStatus=%d", v10, v11, v12, v13, v14, v9);
    uint64_t v16 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      OSStatus v20 = v15;
      _os_log_debug_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v15) {
      CFRelease(v15);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0xFFFFFFFFLL;
  }
  return v9;
}

uint64_t __SOSCCThisDeviceIsInCircleNonCached_block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (gSecurityd)
  {
    uint64_t v2 = *(uint64_t (**)(uint64_t))(gSecurityd + 232);
    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 32);
      return v2(v3);
    }
  }
  xpc_object_t message = securityd_create_message(0x31u, *(CFTypeRef **)(a1 + 32));
  uint64_t v6 = message;
  if (message)
  {
    unsigned int v7 = (void *)securityd_message_with_reply_sync(message, *(void *)(a1 + 32));
    uint64_t v8 = v7;
    if (v7)
    {
      if (!xpc_dictionary_entry_is_type(v7))
      {
        int64_t int64 = 0xFFFFFFFFLL;
        goto LABEL_14;
      }
      int64_t int64 = xpc_dictionary_get_int64(v8, "status");
      if ((int64 & 0x80000000) != 0)
      {
LABEL_14:
        if (securityd_message_no_error((uint64_t)v8, *(CFErrorRef **)(a1 + 32)))
        {
          uint64_t v10 = (void *)MEMORY[0x18C12FA00](v8);
          SecCFCreateErrorWithFormat(0, (const __CFString *)sSecXPCErrorDomain, 0, *(CFTypeRef **)(a1 + 32), v11, @"Remote error occurred/no info: %s", v12, v13, (char)v10);
          free(v10);
        }
      }
    }
    else
    {
      int64_t int64 = 0xFFFFFFFFLL;
    }

    goto LABEL_17;
  }
  int64_t int64 = 0xFFFFFFFFLL;
LABEL_17:
  uint64_t v14 = secLogObjForScope("circleOps");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    int v16 = int64;
    _os_log_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEFAULT, "Retrieved non-cached circle value %d", buf, 8u);
  }

  return int64;
}

BOOL xpc_dictionary_entry_is_type(void *a1)
{
  uint64_t v1 = xpc_dictionary_get_value(a1, "status");
  uint64_t v2 = (void *)v1;
  if (v1) {
    BOOL v3 = MEMORY[0x18C12FBB0](v1) == MEMORY[0x1E4F145C0];
  }
  else {
    BOOL v3 = 0;
  }

  return v3;
}

uint64_t SOSCCFetchCompatibilityMode(CFTypeRef *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = secLogObjForScope("sos-compatibility-mode");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEBUG, "enter SOSCCFetchCompatibilityMode", buf, 2u);
  }

  if (gSecurityd && (BOOL v3 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 656)) != 0) {
    uint64_t v4 = v3(a1);
  }
  else {
    uint64_t v4 = simple_BOOL_error_request(0x5Bu, a1);
  }
  uint64_t v10 = v4;
  uint64_t v11 = SecLogAPICreate(0, "SOSCCFetchCompatibilityMode", @"return=%d", v5, v6, v7, v8, v9, v4);
  uint64_t v12 = secLogObjForScope("api_trace");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    long long v15 = v11;
    _os_log_debug_impl(&dword_18B299000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v11) {
    CFRelease(v11);
  }
  return v10;
}

uint64_t __SOSCCFetchCompatibilityMode_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 656)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x5Bu, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t simple_BOOL_error_request(unsigned int a1, CFTypeRef *a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 0;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = __simple_BOOL_error_request_block_invoke;
  v4[3] = &unk_1E547F420;
  v4[4] = &v5;
  securityd_send_sync_and_do(a1, a2, 0, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t SOSCCRequestToJoinCircle(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCRequestToJoinCircle", 0, v2, v3, v4, v5, v6, 0);
    char v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 240)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x32u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCRequestToJoinCircle", @"return=%d", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCRequestToJoinCircle_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 240)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x32u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCRequestToJoinCircleAfterRestore(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCRequestToJoinCircleAfterRestore", 0, v2, v3, v4, v5, v6, 0);
    char v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 248)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x33u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCRequestToJoinCircleAfterRestore", @"return=%d", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCRequestToJoinCircleAfterRestore_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 248)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x33u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCAccountHasPublicKey(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCAccountHasPublicKey", 0, v2, v3, v4, v5, v6, 0);
    char v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 600)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x55u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCAccountHasPublicKey", @"return=%d", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCAccountHasPublicKey_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 600)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x55u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCWaitForInitialSync(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCWaitForInitialSync", 0, v2, v3, v4, v5, v6, 0);
    char v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 544)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x4Fu, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCWaitForInitialSync", @"return=%d", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCWaitForInitialSync_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 544)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x4Fu, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCAccountSetToNew(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v2 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEFAULT, "SOSCCAccountSetToNew called", buf, 2u);
    }

    char v8 = SecLogAPICreate(0, "SOSCCAccountSetToNew", 0, v3, v4, v5, v6, v7, 0);
    uint64_t v9 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v8;
      _os_log_debug_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8) {
      CFRelease(v8);
    }
    if (gSecurityd && (uint64_t v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 256)) != 0) {
      uint64_t v11 = v10(a1);
    }
    else {
      uint64_t v11 = simple_BOOL_error_request(0x4Cu, a1);
    }
    uint64_t v17 = v11;
    uint64_t v18 = SecLogAPICreate(0, "SOSCCAccountSetToNew", @"return=%d", v12, v13, v14, v15, v16, v11);
    int v19 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v18;
      _os_log_debug_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v17;
}

uint64_t __SOSCCAccountSetToNew_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 256)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x4Cu, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCResetToOffering(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v2 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEFAULT, "SOSCCResetToOffering called", buf, 2u);
    }

    char v8 = SecLogAPICreate(0, "SOSCCResetToOffering", 0, v3, v4, v5, v6, v7, 0);
    uint64_t v9 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v8;
      _os_log_debug_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8) {
      CFRelease(v8);
    }
    if (gSecurityd && (uint64_t v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 264)) != 0) {
      uint64_t v11 = v10(a1);
    }
    else {
      uint64_t v11 = simple_BOOL_error_request(0x34u, a1);
    }
    uint64_t v17 = v11;
    uint64_t v18 = SecLogAPICreate(0, "SOSCCResetToOffering", @"return=%d", v12, v13, v14, v15, v16, v11);
    int v19 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v18;
      _os_log_debug_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v17;
}

uint64_t __SOSCCResetToOffering_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 264)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x34u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCResetToEmpty(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v2 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEFAULT, "SOSCCResetToEmpty called", buf, 2u);
    }

    char v8 = SecLogAPICreate(0, "SOSCCResetToEmpty", 0, v3, v4, v5, v6, v7, 0);
    uint64_t v9 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v8;
      _os_log_debug_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8) {
      CFRelease(v8);
    }
    if (gSecurityd && (uint64_t v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 272)) != 0) {
      uint64_t v11 = v10(a1);
    }
    else {
      uint64_t v11 = simple_BOOL_error_request(0x35u, a1);
    }
    uint64_t v17 = v11;
    uint64_t v18 = SecLogAPICreate(0, "SOSCCResetToEmpty", @"return=%d", v12, v13, v14, v15, v16, v11);
    int v19 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v18;
      _os_log_debug_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v17;
}

uint64_t __SOSCCResetToEmpty_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 272)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x35u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCRemovePeersFromCircle(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v9 = SecLogAPICreate(0, "SOSCCRemovePeersFromCircle", 0, v4, v5, v6, v7, v8, 0);
    uint64_t v10 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v9;
      _os_log_debug_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    v20[2] = __SOSCCRemovePeersFromCircle_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    v20[5] = a2;
    uint64_t v11 = __SOSCCRemovePeersFromCircle_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0, "SOSCCRemovePeersFromCircle", @"return=%d", v12, v13, v14, v15, v16, v11);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v11;
}

uint64_t __SOSCCRemovePeersFromCircle_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void, void))(gSecurityd + 328)) != 0) {
    return v1(*(void *)(a1 + 32), *(void *)(a1 + 40));
  }
  else {
    return info_array_to_BOOL_error_request(0x39u, *(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40));
  }
}

uint64_t info_array_to_BOOL_error_request(unsigned int a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  char v10 = 0;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __info_array_to_BOOL_error_request_block_invoke;
  v6[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  v6[4] = a2;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __info_array_to_BOOL_error_request_block_invoke_2;
  v5[3] = &unk_1E547F420;
  v5[4] = &v7;
  securityd_send_sync_and_do(a1, a3, (uint64_t)v6, (uint64_t)v5);
  uint64_t v3 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t SOSCCRemoveThisDeviceFromCircle(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCRemoveThisDeviceFromCircle", 0, v2, v3, v4, v5, v6, 0);
    uint64_t v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 320)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x38u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCRemoveThisDeviceFromCircle", @"return=%d", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCRemoveThisDeviceFromCircle_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 320)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x38u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCLoggedIntoAccount(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCLoggedIntoAccount", 0, v2, v3, v4, v5, v6, 0);
    uint64_t v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 336)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x3Au, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCLoggedIntoAccount", @"return=%d", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCLoggedIntoAccount_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 336)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x3Au, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCLoggedOutOfAccount(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCLoggedOutOfAccount", 0, v2, v3, v4, v5, v6, 0);
    uint64_t v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 344)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x3Bu, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCLoggedOutOfAccount", @"return=%d", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCLoggedOutOfAccount_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 344)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x3Bu, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCBailFromCircle_BestEffort(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v9 = SecLogAPICreate(0, "SOSCCBailFromCircle_BestEffort", 0, v4, v5, v6, v7, v8, 0);
    uint64_t v10 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v9;
      _os_log_debug_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    v20[2] = __SOSCCBailFromCircle_BestEffort_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    v20[5] = a2;
    uint64_t v11 = __SOSCCBailFromCircle_BestEffort_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0, "SOSCCBailFromCircle_BestEffort", @"return=%d", v12, v13, v14, v15, v16, v11);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v11;
}

uint64_t SOSCCCopyPeerPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCCopyPeerPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    uint64_t v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 448)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x43u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCCopyPeerPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCCopyPeerPeerInfo_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 448)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return array_of_info_error_request(0x43u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t array_of_info_error_request(unsigned int a1, CFTypeRef *a2)
{
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000;
  uint64_t v15 = 0;
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  void v11[2] = __array_of_info_error_request_block_invoke;
  v11[3] = &unk_1E547F420;
  v11[4] = &v12;
  securityd_send_sync_and_do(a1, a2, 0, (uint64_t)v11);
  uint64_t v3 = (const void *)v13[3];
  if (v3)
  {
    CFTypeID v4 = CFGetTypeID(v3);
    CFTypeID TypeID = CFArrayGetTypeID();
    uint64_t v6 = v13;
    if (v4 == TypeID) {
      goto LABEL_7;
    }
    uint64_t v7 = v13[3];
  }
  else
  {
    uint64_t v7 = 0;
  }
  SOSErrorCreate(1040, a2, 0, @"Expected array, got: %@", v7);
  uint64_t v6 = v13;
  uint64_t v8 = (const void *)v13[3];
  if (v8)
  {
    v13[3] = 0;
    CFRelease(v8);
    uint64_t v6 = v13;
  }
LABEL_7:
  uint64_t v9 = v6[3];
  _Block_object_dispose(&v12, 8);
  return v9;
}

void sub_18B36D884(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __array_of_info_error_request_block_invoke(uint64_t a1, xpc_object_t xdict, CFTypeRef *a3)
{
  uint64_t v6 = xpc_dictionary_get_value(xdict, "status");
  uint64_t v13 = v6;
  if (xdict && v6) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CreateArrayOfPeerInfoWithXPCObject(v6, a3, v7, v8, v9, v10, v11, v12);
  }
  BOOL v14 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;

  return v14;
}

uint64_t SOSCCCopyConcurringPeerPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCCopyConcurringPeerPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    uint64_t v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 456)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x44u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCCopyConcurringPeerPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCCopyConcurringPeerPeerInfo_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 456)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return array_of_info_error_request(0x44u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCCopyGenerationPeerInfo(CFTypeRef *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCCopyGenerationPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    uint64_t v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      OSStatus v20 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    v18[2] = __SOSCCCopyGenerationPeerInfo_block_invoke;
    v18[3] = &__block_descriptor_40_e17_____CFArray__8__0l;
    v18[4] = a1;
    uint64_t v9 = __SOSCCCopyGenerationPeerInfo_block_invoke((uint64_t)v18);
    uint64_t v15 = SecLogAPICreate(0, "SOSCCCopyGenerationPeerInfo", @"return=%@", v10, v11, v12, v13, v14, v9);
    uint64_t v16 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      OSStatus v20 = v15;
      _os_log_debug_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v15) {
      CFRelease(v15);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v9;
}

uint64_t __SOSCCCopyGenerationPeerInfo_block_invoke(uint64_t a1)
{
  if (!gSecurityd || (uint64_t v1 = *(uint64_t (**)(uint64_t))(gSecurityd + 392)) == 0)
  {
    uint64_t v4 = *(CFTypeRef **)(a1 + 32);
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    uint64_t v17 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __simple_array_error_request_block_invoke;
    v13[3] = &unk_1E547F420;
    v13[4] = &v14;
    int v5 = securityd_send_sync_and_do(0x45u, v4, 0, (uint64_t)v13);
    uint64_t v6 = v15;
    if (v5)
    {
      uint64_t v7 = (const void *)v15[3];
      if (!v7)
      {
        uint64_t v10 = 0;
LABEL_11:
        SOSErrorCreate(1040, v4, 0, @"Expected array, got: %@", v10);
        uint64_t v6 = v15;
        uint64_t v11 = (const void *)v15[3];
        if (v11)
        {
          v15[3] = 0;
          CFRelease(v11);
          uint64_t v6 = v15;
        }
        goto LABEL_13;
      }
      CFTypeID v8 = CFGetTypeID(v7);
      CFTypeID TypeID = CFArrayGetTypeID();
      uint64_t v6 = v15;
      if (v8 != TypeID)
      {
        uint64_t v10 = v15[3];
        goto LABEL_11;
      }
    }
LABEL_13:
    uint64_t v12 = v6[3];
    _Block_object_dispose(&v14, 8);
    return v12;
  }
  uint64_t v2 = *(void *)(a1 + 32);

  return v1(v2);
}

void sub_18B36DE70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __simple_array_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v3 = xpc_dictionary_get_value(xdict, "status");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
  BOOL v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;

  return v4;
}

uint64_t SOSCCCopyApplicantPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCCopyApplicantPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    CFTypeID v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 400)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x3Fu, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCCopyApplicantPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCCopyApplicantPeerInfo_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 400)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return array_of_info_error_request(0x3Fu, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCValidateUserPublic(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCValidateUserPublic", 0, v2, v3, v4, v5, v6, 0);
    CFTypeID v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 384)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x41u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCValidateUserPublic", 0, v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCValidateUserPublic_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 384)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x41u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCCopyValidPeerPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCCopyValidPeerPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    CFTypeID v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 408)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x40u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCCopyValidPeerPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCCopyValidPeerPeerInfo_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 408)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return array_of_info_error_request(0x40u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCCopyNotValidPeerPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCCopyNotValidPeerPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    CFTypeID v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 416)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x42u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCCopyNotValidPeerPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCCopyNotValidPeerPeerInfo_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 416)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return array_of_info_error_request(0x42u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCCopyRetirementPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCCopyRetirementPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    CFTypeID v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 424)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x48u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCCopyRetirementPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCCopyRetirementPeerInfo_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 424)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return array_of_info_error_request(0x48u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCCopyViewUnawarePeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCCopyViewUnawarePeerInfo", 0, v2, v3, v4, v5, v6, 0);
    CFTypeID v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 432)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x49u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCCopyViewUnawarePeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCCopyViewUnawarePeerInfo_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 432)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return array_of_info_error_request(0x49u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCCopyMyPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCCopyMyPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    CFTypeID v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 536)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = peer_info_error_request(0x4Bu, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCCopyMyPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCCopyMyPeerInfo_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 536)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return peer_info_error_request(0x4Bu, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t peer_info_error_request(unsigned int a1, CFTypeRef *a2)
{
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000;
  uint64_t v14 = 0;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = __peer_info_error_request_block_invoke;
  uint64_t v10[3] = &unk_1E547F420;
  v10[4] = &v11;
  securityd_send_sync_and_do(a1, a2, 0, (uint64_t)v10);
  uint64_t v3 = (const void *)v12[3];
  if (v3)
  {
    CFTypeID v4 = CFGetTypeID(v3);
    CFTypeID TypeID = CFDataGetTypeID();
    CFDataRef v6 = (const __CFData *)v12[3];
    if (v4 == TypeID)
    {
      uint64_t v7 = SOSPeerInfoCreateFromData(TypeID, a2, v6);
      goto LABEL_6;
    }
  }
  else
  {
    CFDataRef v6 = 0;
  }
  SOSErrorCreate(1040, a2, 0, @"Expected CFData, got: %@", v6);
  uint64_t v7 = 0;
LABEL_6:
  CFTypeID v8 = (const void *)v12[3];
  if (v8)
  {
    v12[3] = 0;
    CFRelease(v8);
  }
  _Block_object_dispose(&v11, 8);
  return v7;
}

void sub_18B36EF04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __peer_info_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v4 = xpc_dictionary_get_value(xdict, "status");
  uint64_t v5 = (void *)v4;
  if (xdict && v4) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
  }
  BOOL v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;

  return v6;
}

void SOSCCForEachEngineStateAsStringFromArray(const __CFArray *a1, void *a2)
{
  id v3 = a2;
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 3221225472;
    context[2] = __SOSCCForEachEngineStateAsStringFromArray_block_invoke;
    context[3] = &unk_1E547E4B0;
    id v5 = v3;
    v6.length = CFArrayGetCount(a1);
    v6.location = 0;
    CFArrayApplyFunction(a1, v6, (CFArrayApplierFunction)apply_block_1_8214, context);
  }
}

void __SOSCCForEachEngineStateAsStringFromArray_block_invoke(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID())
    {
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFDataRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      Boolean Value = CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)kSOSCCEngineStatePeerIDKey);
      if (Value && (CFTypeID v8 = Value, v9 = CFGetTypeID(Value), v9 == CFStringGetTypeID())) {
        CFStringAppendFormat(Mutable, 0, @"remote %@ ", v8);
      }
      else {
        CFStringAppendFormat(Mutable, 0, @"local ");
      }
      CFSetRef v10 = (const __CFSet *)CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)kSOSCCEngineStateSyncSetKey);
      if (v10 && (CFSetRef v11 = v10, v12 = CFGetTypeID(v10), v12 == CFSetGetTypeID()))
      {
        v31[0] = MEMORY[0x1E4F143A8];
        v31[1] = 3221225472;
        v31[2] = __SOSCCForEachEngineStateAsStringFromArray_block_invoke_2;
        v31[3] = &__block_descriptor_40_e21_v16__0____CFString__8l;
        v31[4] = Mutable;
        CFStringSetPerformWithDescription(v11, (uint64_t)v31);
      }
      else
      {
        CFStringAppendFormat(Mutable, 0, @"<Missing view set!>");
      }
      uint64_t v13 = CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)kSOSCCEngineStateManifestCountKey);
      CFStringAppendFormat(Mutable, 0, @" [%@]", v13);
      CFDataRef v14 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)kSOSCCEngineStateManifestHashKey);
      if (v14)
      {
        CFDataRef v15 = v14;
        CFTypeID v16 = CFGetTypeID(v14);
        if (v16 == CFDataGetTypeID())
        {
          v27[0] = MEMORY[0x1E4F143A8];
          v27[1] = 3221225472;
          uint64_t v28 = __SOSCCForEachEngineStateAsStringFromArray_block_invoke_3;
          unint64_t v29 = &__block_descriptor_40_e21_v16__0____CFString__8l;
          uint64_t v30 = Mutable;
          uint64_t v17 = v27;
          CFIndex Length = CFDataGetLength(v15);
          int v19 = CFStringCreateMutable(v5, 2 * Length);
          BytePtr = CFDataGetBytePtr(v15);
          CFIndex v21 = CFDataGetLength(v15);
          if (v21 >= 1)
          {
            CFIndex v22 = v21;
            do
            {
              unsigned int v23 = *BytePtr++;
              CFStringAppendFormat(v19, 0, @"%02X", v23);
              --v22;
            }
            while (v22);
          }
          v28((uint64_t)v17, (uint64_t)v19);
          CFRelease(v19);
        }
      }
      BOOL v24 = CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)kSOSCCEngineStateCoderKey);
      if (v24)
      {
        uint64_t v25 = v24;
        CFTypeID v26 = CFGetTypeID(v24);
        if (v26 == CFStringGetTypeID()) {
          CFStringAppendFormat(Mutable, 0, @" %@", v25);
        }
      }
      (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
      if (Mutable) {
        CFRelease(Mutable);
      }
    }
  }
}

uint64_t apply_block_1_8214(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void __SOSCCForEachEngineStateAsStringFromArray_block_invoke_2(uint64_t a1, const __CFString *a2)
{
}

void __SOSCCForEachEngineStateAsStringFromArray_block_invoke_3(uint64_t a1, uint64_t a2)
{
}

uint64_t SOSCCForEachEngineStateAsString(CFTypeRef *a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0 && (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    CFTypeID v9 = SecLogAPICreate(0, "SOSCCCopyEngineState", 0, v4, v5, v6, v7, v8, 0);
    CFSetRef v10 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      CFIndex v22 = v9;
      _os_log_debug_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    v20[2] = __SOSCCCopyEngineState_block_invoke;
    v20[3] = &__block_descriptor_40_e17_____CFArray__8__0l;
    v20[4] = a1;
    uint64_t v11 = __SOSCCCopyEngineState_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0, "SOSCCCopyEngineState", @"return=%@", v12, v13, v14, v15, v16, v11);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      CFIndex v22 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
    if (v11)
    {
      SOSCCForEachEngineStateAsStringFromArray((const __CFArray *)v11, v3);
      CFRelease((CFTypeRef)v11);
      uint64_t v11 = 1;
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    uint64_t v11 = 0;
  }

  return v11;
}

uint64_t __SOSCCCopyEngineState_block_invoke(uint64_t a1)
{
  if (!gSecurityd || (uint64_t v1 = *(uint64_t (**)(uint64_t))(gSecurityd + 440)) == 0)
  {
    uint64_t v4 = *(CFTypeRef **)(a1 + 32);
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    uint64_t v17 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __der_array_error_request_block_invoke;
    v13[3] = &unk_1E547F420;
    v13[4] = &v14;
    int v5 = securityd_send_sync_and_do(0x4Au, v4, 0, (uint64_t)v13);
    uint64_t v6 = v15;
    if (v5)
    {
      uint64_t v7 = (const void *)v15[3];
      if (!v7)
      {
        uint64_t v10 = 0;
LABEL_11:
        SOSErrorCreate(1040, v4, 0, @"Expected array, got: %@", v10);
        uint64_t v6 = v15;
        uint64_t v11 = (const void *)v15[3];
        if (v11)
        {
          v15[3] = 0;
          CFRelease(v11);
          uint64_t v6 = v15;
        }
        goto LABEL_13;
      }
      CFTypeID v8 = CFGetTypeID(v7);
      CFTypeID TypeID = CFArrayGetTypeID();
      uint64_t v6 = v15;
      if (v8 != TypeID)
      {
        uint64_t v10 = v15[3];
        goto LABEL_11;
      }
    }
LABEL_13:
    uint64_t v12 = v6[3];
    _Block_object_dispose(&v14, 8);
    return v12;
  }
  uint64_t v2 = *(void *)(a1 + 32);

  return v1(v2);
}

void sub_18B36F6F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __der_array_error_request_block_invoke(uint64_t a1, xpc_object_t xdict, CFTypeRef *a3)
{
  size_t length = 0;
  data = xpc_dictionary_get_data(xdict, "status", &length);
  der_decode_plist(*MEMORY[0x1E4F1CF80], *(void *)(*(void *)(a1 + 32) + 8) + 24, a3, (uint64_t)data, (uint64_t)data + length, v6, v7, v8);
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t SOSCCAcceptApplicants(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    CFTypeID v9 = SecLogAPICreate(0, "SOSCCAcceptApplicants", 0, v4, v5, v6, v7, v8, 0);
    uint64_t v10 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      CFIndex v22 = v9;
      _os_log_debug_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    v20[2] = __SOSCCAcceptApplicants_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    void v20[5] = a2;
    uint64_t v11 = __SOSCCAcceptApplicants_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0, "SOSCCAcceptApplicants", @"return=%d", v12, v13, v14, v15, v16, v11);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      CFIndex v22 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v11;
}

uint64_t __SOSCCAcceptApplicants_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void, void))(gSecurityd + 360)) != 0) {
    return v1(*(void *)(a1 + 32), *(void *)(a1 + 40));
  }
  else {
    return info_array_to_BOOL_error_request(0x3Du, *(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40));
  }
}

uint64_t SOSCCRejectApplicants(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    CFTypeID v9 = SecLogAPICreate(0, "SOSCCRejectApplicants", @"applicants=%@", v4, v5, v6, v7, v8, a1);
    uint64_t v10 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      CFIndex v22 = v9;
      _os_log_debug_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    v20[2] = __SOSCCRejectApplicants_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    void v20[5] = a2;
    uint64_t v11 = __SOSCCRejectApplicants_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0, "SOSCCRejectApplicants", @"return=%d", v12, v13, v14, v15, v16, v11);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      CFIndex v22 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v11;
}

uint64_t __SOSCCRejectApplicants_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void, void))(gSecurityd + 368)) != 0) {
    return v1(*(void *)(a1 + 32), *(void *)(a1 + 40));
  }
  else {
    return info_array_to_BOOL_error_request(0x3Eu, *(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40));
  }
}

uint64_t SOSCCCopyMyPeerWithNewDeviceRecoverySecret(const __CFData *a1, CFTypeRef *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) == 0)
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  uint64_t v4 = secLogObjForScope("devRecovery");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "Enter SOSCCCopyMyPeerWithNewDeviceRecoverySecret()", (uint8_t *)&buf, 2u);
  }

  uint64_t v5 = SOSCopyDeviceBackupPublicKey(a1, a2);
  uint64_t v6 = secLogObjForScope("devRecovery");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "SOSCopyDeviceBackupPublicKey (%@)", (uint8_t *)&buf, 0xCu);
  }

  if (v5)
  {
    if (SOSCCIsSOSTrustAndSyncingEnabled())
    {
      uint64_t v12 = SecLogAPICreate(0, "SOSSetNewPublicBackupKey", 0, v7, v8, v9, v10, v11, 0);
      uint64_t v13 = secLogObjForScope("api_trace");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v12;
        _os_log_debug_impl(&dword_18B299000, v13, OS_LOG_TYPE_DEBUG, "%@", (uint8_t *)&buf, 0xCu);
      }

      if (v12) {
        CFRelease(v12);
      }
      *(void *)&long long buf = MEMORY[0x1E4F143A8];
      *((void *)&buf + 1) = 3221225472;
      uint64_t v27 = __SOSSetNewPublicBackupKey_block_invoke;
      uint64_t v28 = &__block_descriptor_48_e27_____OpaqueSOSPeerInfo__8__0l;
      unint64_t v29 = v5;
      uint64_t v30 = a2;
      uint64_t v14 = __SOSSetNewPublicBackupKey_block_invoke((uint64_t)&buf);
      OSStatus v20 = SecLogAPICreate(0, "SOSSetNewPublicBackupKey", @"return=%@", v15, v16, v17, v18, v19, v14);
      CFIndex v21 = secLogObjForScope("api_trace");
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)BOOL v24 = 138412290;
        uint64_t v25 = v20;
        _os_log_debug_impl(&dword_18B299000, v21, OS_LOG_TYPE_DEBUG, "%@", v24, 0xCu);
      }

      if (v20) {
        CFRelease(v20);
      }
      goto LABEL_19;
    }
    SOSCCSetSOSDisabledError(a2);
  }
  uint64_t v14 = 0;
LABEL_19:
  CFIndex v22 = secLogObjForScope("devRecovery");
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v14;
    _os_log_impl(&dword_18B299000, v22, OS_LOG_TYPE_DEFAULT, "SOSSetNewPublicBackupKey (%@)", (uint8_t *)&buf, 0xCu);
  }

  if (v5) {
    CFRelease(v5);
  }
  return v14;
}

uint64_t __SOSSetNewPublicBackupKey_block_invoke(uint64_t a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(uint64_t, uint64_t))(gSecurityd + 376);
    if (v1)
    {
      uint64_t v2 = *(void *)(a1 + 40);
      uint64_t v3 = *(void *)(a1 + 32);
      return v1(v3, v2);
    }
  }
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(CFTypeRef **)(a1 + 40);
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2020000000;
  uint64_t v18 = 0;
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3221225472;
  void v14[2] = __data_to_peer_info_error_request_block_invoke;
  v14[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  v14[4] = v5;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  v13[2] = __data_to_peer_info_error_request_block_invoke_2;
  v13[3] = &unk_1E547F420;
  v13[4] = &v15;
  securityd_send_sync_and_do(0x4Du, v6, (uint64_t)v14, (uint64_t)v13);
  uint64_t v7 = (const void *)v16[3];
  if (!v7)
  {
    CFDataRef v10 = 0;
    goto LABEL_10;
  }
  CFTypeID v8 = CFGetTypeID(v7);
  CFTypeID TypeID = CFDataGetTypeID();
  CFDataRef v10 = (const __CFData *)v16[3];
  if (v8 != TypeID)
  {
LABEL_10:
    SOSErrorCreate(1040, v6, 0, @"Expected CFData, got: %@", v10);
    uint64_t v11 = 0;
    goto LABEL_11;
  }
  uint64_t v11 = SOSPeerInfoCreateFromData(TypeID, v6, v10);
LABEL_11:
  uint64_t v12 = (const void *)v16[3];
  if (v12)
  {
    v16[3] = 0;
    CFRelease(v12);
  }
  _Block_object_dispose(&v15, 8);
  return v11;
}

void sub_18B370060(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

BOOL __data_to_peer_info_error_request_block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  if (v3)
  {
    xpc_dictionary_set_value(v2, "newPublicBackupKey", v3);
  }
  return v3 != 0;
}

BOOL __data_to_peer_info_error_request_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v4 = xpc_dictionary_get_value(xdict, "status");
  uint64_t v5 = (void *)v4;
  if (xdict && v4) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
  }
  BOOL v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;

  return v6;
}

uint64_t SOSCCRegisterSingleRecoverySecret(uint64_t a1, char a2, CFTypeRef *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v11 = SecLogAPICreate(0, "SOSCCRegisterSingleRecoverySecret", 0, v6, v7, v8, v9, v10, 0);
    uint64_t v12 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v25 = v11;
      _os_log_debug_impl(&dword_18B299000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v11) {
      CFRelease(v11);
    }
    v22[0] = MEMORY[0x1E4F143A8];
    v22[1] = 3221225472;
    v22[2] = __SOSCCRegisterSingleRecoverySecret_block_invoke;
    v22[3] = &__block_descriptor_49_e5_B8__0l;
    char v23 = a2;
    v22[4] = a1;
    v22[5] = a3;
    uint64_t v13 = __SOSCCRegisterSingleRecoverySecret_block_invoke((uint64_t)v22);
    uint64_t v19 = SecLogAPICreate(0, "SOSCCRegisterSingleRecoverySecret", @"return=%d", v14, v15, v16, v17, v18, v13);
    OSStatus v20 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v25 = v19;
      _os_log_debug_impl(&dword_18B299000, v20, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v19) {
      CFRelease(v19);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0;
  }
  return v13;
}

uint64_t __SOSCCRegisterSingleRecoverySecret_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(gSecurityd + 296)) != 0)
  {
    uint64_t v2 = *(unsigned __int8 *)(a1 + 48);
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(void *)(a1 + 32);
    return v1(v4, v2, v3);
  }
  else
  {
    char v6 = *(unsigned char *)(a1 + 48);
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v7 = *(CFTypeRef **)(a1 + 40);
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = __keybag_and_BOOL_to_BOOL_error_request_block_invoke;
    v9[3] = &__block_descriptor_41_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v9[4] = v8;
    char v10 = v6;
    return securityd_send_sync_and_do(0x4Eu, v7, (uint64_t)v9, (uint64_t)&__block_literal_global_309);
  }
}

uint64_t SOSCCRegisterRecoveryPublicKey(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v9 = SecLogAPICreate(0, "SOSCCRegisterRecoveryPublicKey", 0, v4, v5, v6, v7, v8, 0);
    char v10 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      CFIndex v22 = v9;
      _os_log_debug_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    v20[2] = __SOSCCRegisterRecoveryPublicKey_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    void v20[5] = a2;
    uint64_t v11 = __SOSCCRegisterRecoveryPublicKey_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0, "SOSCCRegisterRecoveryPublicKey", @"return=%d", v12, v13, v14, v15, v16, v11);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      CFIndex v22 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v11;
}

uint64_t __SOSCCRegisterRecoveryPublicKey_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(uint64_t, uint64_t))(gSecurityd + 304)) != 0)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    uint64_t v3 = *(void *)(a1 + 32);
    return v1(v3, v2);
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v5 = *(CFTypeRef **)(a1 + 40);
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    v7[2] = __recovery_and_BOOL_to_BOOL_error_request_block_invoke;
    v7[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v7[4] = v6;
    return securityd_send_sync_and_do(0x57u, v5, (uint64_t)v7, (uint64_t)&__block_literal_global_311);
  }
}

uint64_t SOSCCCopyRecoveryPublicKey(CFTypeRef *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCCopyRecoveryPublicKey", 0, v2, v3, v4, v5, v6, 0);
    uint64_t v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      OSStatus v20 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    v18[2] = __SOSCCCopyRecoveryPublicKey_block_invoke;
    v18[3] = &__block_descriptor_40_e16_____CFData__8__0l;
    v18[4] = a1;
    uint64_t v9 = __SOSCCCopyRecoveryPublicKey_block_invoke((uint64_t)v18);
    uint64_t v15 = SecLogAPICreate(0, "SOSCCCopyRecoveryPublicKey", @"return=%@", v10, v11, v12, v13, v14, v9);
    uint64_t v16 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      OSStatus v20 = v15;
      _os_log_debug_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v15) {
      CFRelease(v15);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v9;
}

uint64_t __SOSCCCopyRecoveryPublicKey_block_invoke(uint64_t a1)
{
  if (!gSecurityd || (uint64_t v1 = *(uint64_t (**)(uint64_t))(gSecurityd + 312)) == 0)
  {
    uint64_t v4 = *(CFTypeRef **)(a1 + 32);
    uint64_t v10 = 0;
    uint64_t v11 = &v10;
    uint64_t v12 = 0x2020000000;
    uint64_t v13 = 0;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = __data_to_error_request_block_invoke;
    v9[3] = &unk_1E547F420;
    v9[4] = &v10;
    securityd_send_sync_and_do(0x58u, v4, 0, (uint64_t)v9);
    uint64_t v5 = (const void *)v11[3];
    if (v5)
    {
      CFTypeID v6 = CFGetTypeID(v5);
      CFTypeID TypeID = CFDataGetTypeID();
      uint64_t v8 = v11[3];
      if (v6 == TypeID) {
        goto LABEL_11;
      }
    }
    else
    {
      uint64_t v8 = 0;
    }
    SOSErrorCreate(1040, v4, 0, @"Expected CFData, got: %@", v8);
    uint64_t v8 = 0;
LABEL_11:
    _Block_object_dispose(&v10, 8);
    return v8;
  }
  uint64_t v2 = *(void *)(a1 + 32);

  return v1(v2);
}

void sub_18B370AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __data_to_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v4 = xpc_dictionary_get_value(xdict, "status");
  uint64_t v5 = (void *)v4;
  if (xdict && v4) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
  }
  BOOL v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;

  return v6;
}

uint64_t SOSCCRegisterUserCredentials(__CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    BOOL v6 = secLogObjForScope("circleOps");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      uint64_t v9 = a1;
      _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "SOSCCRegisterUserCredentials - calling SOSCCSetUserCredentials for %@\n", (uint8_t *)&v8, 0xCu);
    }

    return SOSCCSetUserCredentials(a1, a2, a3);
  }
  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0;
  }
}

uint64_t SOSCCSetUserCredentials(__CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    BOOL v6 = secLogObjForScope("circleOps");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v25 = a1;
      _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "SOSCCSetUserCredentials for %@\n", buf, 0xCu);
    }

    uint64_t v12 = SecLogAPICreate(0, "SOSCCSetUserCredentials", @"user_label=%@", v7, v8, v9, v10, v11, (char)a1);
    uint64_t v13 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v25 = v12;
      _os_log_debug_impl(&dword_18B299000, v13, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v12) {
      CFRelease(v12);
    }
    v23[0] = MEMORY[0x1E4F143A8];
    v23[1] = 3221225472;
    v23[2] = __SOSCCSetUserCredentials_block_invoke;
    v23[3] = &__block_descriptor_56_e5_B8__0l;
    v23[4] = a1;
    v23[5] = a2;
    v23[6] = a3;
    uint64_t v14 = __SOSCCSetUserCredentials_block_invoke(v23);
    OSStatus v20 = SecLogAPICreate(0, "SOSCCSetUserCredentials", @"return=%d", v15, v16, v17, v18, v19, v14);
    uint64_t v21 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v25 = v20;
      _os_log_debug_impl(&dword_18B299000, v21, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v20) {
      CFRelease(v20);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0;
  }
  return v14;
}

uint64_t __SOSCCSetUserCredentials_block_invoke(void *a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(gSecurityd + 200)) != 0)
  {
    uint64_t v2 = a1[5];
    uint64_t v3 = a1[6];
    uint64_t v4 = a1[4];
    return v1(v4, v2, v3);
  }
  else
  {
    BOOL v6 = (CFTypeRef *)a1[6];
    uint64_t v11 = 0;
    uint64_t v12 = &v11;
    uint64_t v13 = 0x2020000000;
    char v14 = 0;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = __label_and_password_to_BOOL_error_request_block_invoke;
    v9[3] = &__block_descriptor_48_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    long long v10 = *((_OWORD *)a1 + 2);
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    v8[2] = __label_and_password_to_BOOL_error_request_block_invoke_3;
    v8[3] = &unk_1E547F420;
    v8[4] = &v11;
    securityd_send_sync_and_do(0x2Du, v6, (uint64_t)v9, (uint64_t)v8);
    uint64_t v7 = *((unsigned __int8 *)v12 + 24);
    _Block_object_dispose(&v11, 8);
    return v7;
  }
}

uint64_t SOSCCSetUserCredentialsAndDSID(__CFString *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v8 = secLogObjForScope("circleOps");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v27 = a1;
      _os_log_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEFAULT, "SOSCCSetUserCredentialsAndDSID for %@\n", buf, 0xCu);
    }

    char v14 = SecLogAPICreate(0, "SOSCCSetUserCredentialsAndDSID", @"user_label=%@", v9, v10, v11, v12, v13, (char)a1);
    uint64_t v15 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v27 = v14;
      _os_log_debug_impl(&dword_18B299000, v15, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v14) {
      CFRelease(v14);
    }
    v25[0] = MEMORY[0x1E4F143A8];
    v25[1] = 3221225472;
    v25[2] = __SOSCCSetUserCredentialsAndDSID_block_invoke;
    v25[3] = &__block_descriptor_64_e5_B8__0l;
    v25[4] = a1;
    v25[5] = a2;
    v25[6] = a3;
    v25[7] = a4;
    uint64_t v16 = __SOSCCSetUserCredentialsAndDSID_block_invoke((uint64_t)v25);
    CFIndex v22 = SecLogAPICreate(0, "SOSCCSetUserCredentialsAndDSID", @"return=%d", v17, v18, v19, v20, v21, v16);
    uint64_t v23 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v27 = v22;
      _os_log_debug_impl(&dword_18B299000, v23, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v22) {
      CFRelease(v22);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a4);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCSetUserCredentialsAndDSID_block_invoke(uint64_t a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(gSecurityd + 208);
    if (v1)
    {
      uint64_t v2 = *(void *)(a1 + 40);
      uint64_t v3 = *(void *)(a1 + 48);
      uint64_t v4 = *(void *)(a1 + 56);
      uint64_t v5 = *(void *)(a1 + 32);
      return v1(v5, v2, v3, v4);
    }
  }
  uint64_t v7 = *(void *)(a1 + 32);
  if (!v7)
  {
    SOSErrorCreate(1045, *(CFTypeRef **)(a1 + 56), 0, @"user_label is nil");
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  if (!v8)
  {
    SOSErrorCreate(1045, *(CFTypeRef **)(a1 + 56), 0, @"user_password is nil");
    return 0;
  }
  uint64_t v9 = *(CFTypeRef **)(a1 + 56);
  if (*(void *)(a1 + 48)) {
    uint64_t v10 = *(__CFString **)(a1 + 48);
  }
  else {
    uint64_t v10 = &stru_1ED84D0B0;
  }

  return label_and_password_and_dsid_to_BOOL_error_request(0x2Eu, v7, v8, (uint64_t)v10, v9);
}

uint64_t label_and_password_and_dsid_to_BOOL_error_request(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000;
  char v12 = 0;
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  v8[2] = __label_and_password_and_dsid_to_BOOL_error_request_block_invoke;
  v8[3] = &__block_descriptor_56_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  v8[4] = a2;
  void v8[5] = a4;
  v8[6] = a3;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = __label_and_password_and_dsid_to_BOOL_error_request_block_invoke_4;
  v7[3] = &unk_1E547F420;
  v7[4] = &v9;
  securityd_send_sync_and_do(a1, a5, (uint64_t)v8, (uint64_t)v7);
  uint64_t v5 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t SOSCCTryUserCredentialsAndDSID(uint64_t a1, uint64_t a2, __CFString *a3, CFTypeRef *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) == 0)
  {
    SOSCCSetSOSDisabledError(a4);
    return 0;
  }
  uint64_t v8 = secLogObjForScope("sosops");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 138412290;
    uint64_t v12 = a1;
    _os_log_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEFAULT, "SOSCCTryUserCredentialsAndDSID!! %@\n", (uint8_t *)&v11, 0xCu);
  }

  if (!a1)
  {
    SOSErrorCreate(1045, a4, 0, @"user_label is nil");
    return 0;
  }
  if (!a2)
  {
    SOSErrorCreate(1045, a4, 0, @"user_password is nil");
    return 0;
  }
  if (a3) {
    uint64_t v9 = a3;
  }
  else {
    uint64_t v9 = &stru_1ED84D0B0;
  }
  return SOSCCTryUserCredentialsAndDSID_internal(a1, a2, (uint64_t)v9, a4);
}

uint64_t SOSCCTryUserCredentialsAndDSID_internal(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 3221225472;
    v17[2] = __SOSCCTryUserCredentialsAndDSID_internal_block_invoke;
    v17[3] = &__block_descriptor_64_e5_B8__0l;
    v17[4] = a1;
    void v17[5] = a2;
    v17[6] = a3;
    v17[7] = a4;
    uint64_t v8 = __SOSCCTryUserCredentialsAndDSID_internal_block_invoke((uint64_t)v17);
    char v14 = SecLogAPICreate(0, "SOSCCTryUserCredentialsAndDSID_internal", @"return=%d", v9, v10, v11, v12, v13, v8);
    uint64_t v15 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v19 = v14;
      _os_log_debug_impl(&dword_18B299000, v15, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v14) {
      CFRelease(v14);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a4);
    return 0;
  }
  return v8;
}

uint64_t SOSCCTryUserCredentials(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    return SOSCCTryUserCredentialsAndDSID_internal(a1, a2, 0, a3);
  }
  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0;
  }
}

uint64_t SOSCCCanAuthenticate(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCCanAuthenticate", 0, v2, v3, v4, v5, v6, 0);
    uint64_t v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 216)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x2Fu, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCCanAuthenticate", @"return=%d", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCCanAuthenticate_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 216)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x2Fu, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCPurgeUserCredentials(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCPurgeUserCredentials", 0, v2, v3, v4, v5, v6, 0);
    uint64_t v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 224)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x30u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCPurgeUserCredentials", @"return=%d", v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCPurgeUserCredentials_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 224)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x30u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCGetLastDepartureReason(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v7 = SecLogAPICreate(0, "SOSCCGetLastDepartureReason", 0, v2, v3, v4, v5, v6, 0);
    uint64_t v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 464)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = simple_int_error_request(0x46u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCGetLastDepartureReason", 0, v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCGetLastDepartureReason_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 464)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_int_error_request(0x46u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t simple_int_error_request(unsigned int a1, CFTypeRef *a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  int v8 = 0;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = __simple_int_error_request_block_invoke;
  v4[3] = &unk_1E547F420;
  v4[4] = &v5;
  securityd_send_sync_and_do(a1, a2, 0, (uint64_t)v4);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

BOOL __simple_int_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  int64_t int64 = xpc_dictionary_get_int64(xdict, "status");
  if (int64 == (int)int64) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = int64;
  }
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t SOSCCSetLastDepartureReason(int a1, CFTypeRef *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v9 = SecLogAPICreate(0, "SOSCCSetLastDepartureReason", 0, v4, v5, v6, v7, v8, 0);
    uint64_t v10 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v23 = v9;
      _os_log_debug_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    v20[2] = __SOSCCSetLastDepartureReason_block_invoke;
    v20[3] = &__block_descriptor_44_e5_B8__0l;
    int v21 = a1;
    v20[4] = a2;
    uint64_t v11 = __SOSCCSetLastDepartureReason_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0, "SOSCCSetLastDepartureReason", 0, v12, v13, v14, v15, v16, v11);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v23 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v11;
}

uint64_t __SOSCCSetLastDepartureReason_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(uint64_t, uint64_t))(gSecurityd + 472)) != 0)
  {
    uint64_t v2 = *(void *)(a1 + 32);
    uint64_t v3 = *(unsigned int *)(a1 + 40);
    return v1(v3, v2);
  }
  else
  {
    uint64_t v5 = *(CFTypeRef **)(a1 + 32);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    v6[2] = __SOSCCSetLastDepartureReason_block_invoke_2;
    v6[3] = &__block_descriptor_36_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    int v7 = *(_DWORD *)(a1 + 40);
    return securityd_send_sync_and_do(0x47u, v5, (uint64_t)v6, (uint64_t)&__block_literal_global_8291);
  }
}

uint64_t __SOSCCSetLastDepartureReason_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  return 1;
}

BOOL __SOSCCSetLastDepartureReason_block_invoke_3(int a1, xpc_object_t xdict)
{
  return xpc_dictionary_get_BOOL(xdict, "status");
}

uint64_t SOSCCProcessEnsurePeerRegistration(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v2 = secLogObjForScope("updates");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEFAULT, "enter SOSCCProcessEnsurePeerRegistration", buf, 2u);
    }

    uint64_t v8 = SecLogAPICreate(0, "SOSCCProcessEnsurePeerRegistration", 0, v3, v4, v5, v6, v7, 0);
    uint64_t v9 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v22 = v8;
      _os_log_debug_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8) {
      CFRelease(v8);
    }
    if (gSecurityd && (uint64_t v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 496)) != 0) {
      uint64_t v11 = v10(a1);
    }
    else {
      uint64_t v11 = simple_BOOL_error_request(0x22u, a1);
    }
    uint64_t v17 = v11;
    uint64_t v18 = SecLogAPICreate(0, "SOSCCProcessEnsurePeerRegistration", @"return=%d", v12, v13, v14, v15, v16, v11);
    uint64_t v19 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v22 = v18;
      _os_log_debug_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v17;
}

uint64_t __SOSCCProcessEnsurePeerRegistration_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 496)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x22u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCProcessSyncWithPeers(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v11 = SecLogAPICreate(0, "SOSCCProcessSyncWithPeers", 0, v6, v7, v8, v9, v10, 0);
    uint64_t v12 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v24 = v11;
      _os_log_debug_impl(&dword_18B299000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v11) {
      CFRelease(v11);
    }
    v22[0] = MEMORY[0x1E4F143A8];
    v22[1] = 3221225472;
    v22[2] = __SOSCCProcessSyncWithPeers_block_invoke;
    v22[3] = &__block_descriptor_56_e15_____CFSet__8__0l;
    v22[4] = a1;
    v22[5] = a2;
    void v22[6] = a3;
    uint64_t v13 = __SOSCCProcessSyncWithPeers_block_invoke(v22);
    uint64_t v19 = SecLogAPICreate(0, "SOSCCProcessSyncWithPeers", 0, v14, v15, v16, v17, v18, v13);
    uint64_t v20 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v24 = v19;
      _os_log_debug_impl(&dword_18B299000, v20, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v19) {
      CFRelease(v19);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0;
  }
  return v13;
}

uint64_t __SOSCCProcessSyncWithPeers_block_invoke(void *a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(gSecurityd + 480)) != 0)
  {
    uint64_t v2 = a1[5];
    uint64_t v3 = a1[6];
    uint64_t v4 = a1[4];
    return v1(v4, v2, v3);
  }
  else
  {
    uint64_t v6 = (CFTypeRef *)a1[6];
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    uint64_t v17 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    void v12[2] = __cfset_cfset_to_cfset_error_request_block_invoke;
    v12[3] = &__block_descriptor_48_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    long long v13 = *((_OWORD *)a1 + 2);
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    void v11[2] = __cfset_cfset_to_cfset_error_request_block_invoke_2;
    v11[3] = &unk_1E547F420;
    v11[4] = &v14;
    char v7 = securityd_send_sync_and_do(0x6Au, v6, (uint64_t)v12, (uint64_t)v11);
    uint64_t v8 = v15;
    if ((v7 & 1) == 0)
    {
      uint64_t v9 = (const void *)v15[3];
      if (v9)
      {
        v15[3] = 0;
        CFRelease(v9);
        uint64_t v8 = v15;
      }
    }
    uint64_t v10 = v8[3];
    _Block_object_dispose(&v14, 8);
    return v10;
  }
}

void sub_18B372B50(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

size_t __cfset_cfset_to_cfset_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  id v5 = a2;
  if (SecXPCDictionarySetPListWithRepair(v5, "cfset", *(const __CFString **)(a1 + 32), a3, v6, v7, v8, v9))size_t v14 = SecXPCDictionarySetPListWithRepair(v5, "cfset2", *(const __CFString **)(a1 + 40), a3, v10, v11, v12, v13); {
  else
  }
    size_t v14 = 0;

  return v14;
}

BOOL __cfset_cfset_to_cfset_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  CFTypeRef v5 = SecXPCDictionaryCopyPListAndPossiblyMutateMessage(1, a2, "status", a3);
  uint64_t v6 = v5;
  if (v5 && (CFTypeID v7 = CFGetTypeID(v5), v7 == CFSetGetTypeID()))
  {
    CFRetain(v6);
    uint64_t v8 = v6;
  }
  else
  {
    if (a3) {
      SecError(-50, a3, @"object %@ is not a set", v6);
    }
    if (!v6)
    {
      uint64_t v8 = 0;
      goto LABEL_12;
    }
    CFTypeID v9 = CFGetTypeID(v6);
    CFStringRef v10 = CFCopyTypeIDDescription(v9);
    SecError(-50, a3, @"object for key %s not set but %@", "status", v10);
    if (v10) {
      CFRelease(v10);
    }
    uint64_t v8 = 0;
  }
  CFRelease(v6);
LABEL_12:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v8;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t SOSCCProcessSyncWithAllPeers(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    CFTypeID v7 = SecLogAPICreate(0, "SOSCCProcessSyncWithAllPeers", 0, v2, v3, v4, v5, v6, 0);
    uint64_t v8 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      int v21 = v7;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    if (gSecurityd && (CFTypeID v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 488)) != 0) {
      uint64_t v10 = v9(a1);
    }
    else {
      uint64_t v10 = simple_int_error_request(0x1Cu, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0, "SOSCCProcessSyncWithAllPeers", 0, v11, v12, v13, v14, v15, v10);
    uint64_t v18 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      int v21 = v17;
      _os_log_debug_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t __SOSCCProcessSyncWithAllPeers_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 488)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_int_error_request(0x1Cu, *(CFTypeRef **)(a1 + 32));
  }
}

__CFString *SOSCCGetStatusDescription(int a1)
{
  if ((a1 + 1) > 4) {
    return @"Unknown Status";
  }
  else {
    return off_1E547E818[a1 + 1];
  }
}

__CFString *SOSCCGetViewResultDescription(unsigned int a1)
{
  if (a1 > 4) {
    return @"Unknown View Status";
  }
  else {
    return off_1E547E840[a1];
  }
}

uint64_t SOSCCView(const void *a1, int a2, CFTypeRef *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) == 0)
  {
    SOSCCSetSOSDisabledError(a3);
    return 0;
  }
  int v6 = SOSVisibleKeychainNotAllowed();
  if (a1 && a2 == 1 && v6)
  {
    CFSetRef V0SubviewSet = (const __CFSet *)SOSViewsGetV0SubviewSet();
    if (CFSetContainsValue(V0SubviewSet, a1))
    {
      uint64_t v13 = secLogObjForScope("views");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_18B299000, v13, OS_LOG_TYPE_DEFAULT, "Cannot enable visible keychain views due to profile restrictions", buf, 2u);
      }

      return 0;
    }
  }
  else if (a2 == 3 && SOSGetCachedCircleBitmask() < 0)
  {
    uint64_t v25 = SOSCachedViewBitmask();
    if (!v25) {
      return 2;
    }
    CFSetRef SetFromBitmask = SOSViewCreateSetFromBitmask(v25);
    if (!SetFromBitmask) {
      return 2;
    }
    uint64_t v22 = (__CFString *)SetFromBitmask;
    if (CFSetContainsValue(SetFromBitmask, a1)) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = 2;
    }
    goto LABEL_20;
  }
  uint64_t v15 = SecLogAPICreate(0, "SOSCCView", 0, v7, v8, v9, v10, v11, 0);
  uint64_t v16 = secLogObjForScope("api_trace");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 138412290;
    uint64_t v30 = v15;
    _os_log_debug_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v15) {
    CFRelease(v15);
  }
  v27[0] = MEMORY[0x1E4F143A8];
  v27[1] = 3221225472;
  void v27[2] = __SOSCCView_block_invoke;
  v27[3] = &__block_descriptor_52_e5_i8__0l;
  int v28 = a2;
  v27[4] = a1;
  v27[5] = a3;
  uint64_t v14 = __SOSCCView_block_invoke((uint64_t)v27);
  uint64_t v22 = SecLogAPICreate(0, "SOSCCView", @"SOSViewResultCode=%d", v17, v18, v19, v20, v21, v14);
  uint64_t v23 = secLogObjForScope("api_trace");
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 138412290;
    uint64_t v30 = v22;
    _os_log_debug_impl(&dword_18B299000, v23, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v22) {
LABEL_20:
  }
    CFRelease(v22);
  return v14;
}

uint64_t __SOSCCView_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(gSecurityd + 280)) != 0)
  {
    uint64_t v2 = *(unsigned int *)(a1 + 48);
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(void *)(a1 + 32);
    return v1(v4, v2, v3);
  }
  else
  {
    uint64_t v6 = *(int *)(a1 + 48);
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v7 = *(CFTypeRef **)(a1 + 40);
    uint64_t v13 = 0;
    uint64_t v14 = &v13;
    uint64_t v15 = 0x2020000000;
    uint64_t v16 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    void v12[2] = __name_action_to_code_request_block_invoke;
    v12[3] = &__block_descriptor_48_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    void v12[4] = v8;
    v12[5] = v6;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3221225472;
    v10[2] = __name_action_to_code_request_block_invoke_3;
    uint64_t v10[3] = &unk_1E547E7D8;
    v10[4] = &v13;
    __int16 v11 = 0;
    securityd_send_sync_and_do(0x36u, v7, (uint64_t)v12, (uint64_t)v10);
    uint64_t v9 = *((unsigned int *)v14 + 6);
    _Block_object_dispose(&v13, 8);
    return v9;
  }
}

uint64_t __name_action_to_code_request_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFStringRef v4 = *(const __CFString **)(a1 + 32);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = __name_action_to_code_request_block_invoke_2;
  v7[3] = &unk_1E547E7B0;
  id v8 = v3;
  id v5 = v3;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  v9[2] = __CFStringPerformWithCString_block_invoke;
  v9[3] = &unk_1E5484C20;
  void v9[4] = v7;
  CFStringPerformWithCStringAndLength(v4, (uint64_t)v9);
  xpc_dictionary_set_int64(v5, "viewactioncode", *(void *)(a1 + 40));

  return 1;
}

BOOL __name_action_to_code_request_block_invoke_3(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFStringRef v4 = v3;
  if (v3 && xpc_dictionary_entry_is_type(v3)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = xpc_dictionary_get_int64(v4, "status");
  }
  BOOL v5 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != *(unsigned __int16 *)(a1 + 40);

  return v5;
}

void __name_action_to_code_request_block_invoke_2(uint64_t a1, char *string)
{
}

uint64_t SOSCCViewSet(const __CFSet *a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!SOSCCIsSOSTrustAndSyncingEnabled()) {
    return 0;
  }
  int v4 = SOSVisibleKeychainNotAllowed();
  if (a1 && v4 && CFSetGetCount(a1) && SOSViewSetIntersectsV0(a1))
  {
    uint64_t v10 = secLogObjForScope("views");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEFAULT, "Cannot enable visible keychain views due to profile restrictions", buf, 2u);
    }

    return 0;
  }
  *(void *)long long buf = 0;
  uint64_t v24 = buf;
  uint64_t v25 = 0x2020000000;
  char v26 = 0;
  uint64_t v12 = SecLogAPICreate(0, "SOSCCViewSet", 0, v5, v6, v7, v8, v9, 0);
  uint64_t v13 = secLogObjForScope("api_trace");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t v27 = 138412290;
    int v28 = v12;
    _os_log_debug_impl(&dword_18B299000, v13, OS_LOG_TYPE_DEBUG, "%@", v27, 0xCu);
  }

  if (v12) {
    CFRelease(v12);
  }
  v22[0] = MEMORY[0x1E4F143A8];
  v22[1] = 3221225472;
  v22[2] = __SOSCCViewSet_block_invoke;
  v22[3] = &unk_1E547E5F8;
  void v22[6] = a2;
  void v22[7] = 0;
  v22[4] = buf;
  v22[5] = a1;
  uint64_t v11 = __SOSCCViewSet_block_invoke(v22);
  uint64_t v19 = SecLogAPICreate(0, "SOSCCViewSet", @"return=%d", v14, v15, v16, v17, v18, v11);
  uint64_t v20 = secLogObjForScope("api_trace");
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t v27 = 138412290;
    int v28 = v19;
    _os_log_debug_impl(&dword_18B299000, v20, OS_LOG_TYPE_DEBUG, "%@", v27, 0xCu);
  }

  if (v19) {
    CFRelease(v19);
  }
  _Block_object_dispose(buf, 8);
  return v11;
}

void sub_18B373730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __SOSCCViewSet_block_invoke(void *a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(uint64_t, uint64_t))(gSecurityd + 288)) != 0)
  {
    uint64_t v2 = a1[6];
    uint64_t v3 = a1[5];
    return v1(v3, v2);
  }
  else
  {
    uint64_t v5 = (CFTypeRef *)a1[7];
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    v7[2] = __SOSCCViewSet_block_invoke_2;
    v7[3] = &__block_descriptor_48_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    long long v8 = *(_OWORD *)(a1 + 5);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    v6[2] = __SOSCCViewSet_block_invoke_3;
    v6[3] = &unk_1E547F420;
    void v6[4] = a1[4];
    return securityd_send_sync_and_do(0x37u, v5, (uint64_t)v7, (uint64_t)v6);
  }
}

BOOL __SOSCCViewSet_block_invoke_2(uint64_t a1, void *a2, CFTypeRef *a3)
{
  id v5 = a2;
  uint64_t v12 = CreateXPCObjectWithCFSetRef(*(const __CFSet **)(a1 + 32), a3, v6, v7, v8, v9, v10, v11);
  uint64_t v19 = CreateXPCObjectWithCFSetRef(*(const __CFSet **)(a1 + 40), a3, v13, v14, v15, v16, v17, v18);
  if (v12) {
    xpc_dictionary_set_value(v5, "enabledViews", (xpc_object_t)v12);
  }
  if (v19) {
    xpc_dictionary_set_value(v5, "disabledViews", (xpc_object_t)v19);
  }

  return (v12 | v19) != 0;
}

uint64_t __SOSCCViewSet_block_invoke_3(uint64_t a1, xpc_object_t xdict)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = xpc_dictionary_get_BOOL(xdict, "status");
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t SOSCCIsIcloudKeychainSyncing()
{
  v1[4] = *(const void **)MEMORY[0x1E4F143B8];
  uint64_t result = SOSCCIsSOSTrustAndSyncingEnabled();
  if (result)
  {
    v1[0] = @"WiFi";
    v1[1] = @"Passwords";
    v1[2] = @"CreditCards";
    v1[3] = @"OtherSyncable";
    return sosIsViewSetSyncing(4, v1);
  }
  return result;
}

BOOL sosIsViewSetSyncing(uint64_t a1, const void **a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v2 = a2;
  CFDataRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppend(Mutable, @"|");
  uint64_t v5 = 0;
  do
  {
    CFStringAppend(Mutable, (CFStringRef)v2[v5]);
    CFStringAppend(Mutable, @"|");
    ++v5;
  }
  while (a1 != v5);
  int v6 = SOSCCThisDeviceIsInCircle(&cf);
  BOOL v7 = v6 == 0;
  if (v6)
  {
    int v8 = v6;
    uint64_t v9 = secLogObjForScope("viewCheck");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if ((v8 + 1) > 4) {
        uint64_t v10 = @"Unknown Status";
      }
      else {
        uint64_t v10 = off_1E547E868[v8 + 1];
      }
      *(_DWORD *)long long buf = 138412802;
      uint64_t v30 = Mutable;
      __int16 v31 = 2112;
      char v32 = v10;
      __int16 v33 = 2112;
      CFTypeRef v34 = cf;
      uint64_t v19 = "Checking view / circle status for %@:  SOSCCStatus: (%@)  Error: (%@)";
      uint64_t v20 = v9;
      uint32_t v21 = 32;
      goto LABEL_25;
    }
  }
  else
  {
    if (SOSGetCachedCircleBitmask() < 0)
    {
      uint64_t v24 = SOSCachedViewBitmask();
      if (v24)
      {
        CFMutableSetRef SetFromBitmask = SOSViewCreateSetFromBitmask(v24);
        if (SetFromBitmask)
        {
          CFSetRef v26 = SetFromBitmask;
          LOBYTE(v11) = 1;
          do
          {
            uint64_t v27 = *v2++;
            BOOL v11 = (CFSetContainsValue(v26, v27) != 0) & v11;
            --a1;
          }
          while (a1);
          CFTypeRef v22 = v26;
          goto LABEL_29;
        }
      }
    }
    uint64_t v12 = 0;
    char v13 = 1;
    do
    {
      while (1)
      {
        unsigned int v14 = SOSCCView(v2[v12], 3, &cf);
        if (v14 == 1) {
          break;
        }
        unsigned int v15 = v14;
        uint64_t v16 = secLogObjForScope("viewCheck");
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = @"Unknown View Status";
          if (v15 <= 4) {
            uint64_t v17 = off_1E547E890[v15];
          }
          uint64_t v18 = (__CFString *)v2[v12];
          *(_DWORD *)long long buf = 138413058;
          uint64_t v30 = v18;
          __int16 v31 = 2112;
          char v32 = @"InCircle";
          __int16 v33 = 2112;
          CFTypeRef v34 = v17;
          __int16 v35 = 2112;
          CFTypeRef v36 = cf;
          _os_log_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEFAULT, "Checking view / circle status for %@:  SOSCCStatus: (%@) SOSViewResultCode(%@) Error: (%@)", buf, 0x2Au);
        }

        char v13 = 0;
        BOOL v11 = 0;
        if (++v12 == a1) {
          goto LABEL_27;
        }
      }
      ++v12;
    }
    while (a1 != v12);
    if ((v13 & 1) == 0)
    {
      BOOL v11 = 0;
      goto LABEL_27;
    }
    uint64_t v9 = secLogObjForScope("viewCheck");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v30 = Mutable;
      uint64_t v19 = "Checking view / circle status for %@:  ENABLED";
      uint64_t v20 = v9;
      uint32_t v21 = 12;
LABEL_25:
      _os_log_impl(&dword_18B299000, v20, OS_LOG_TYPE_DEFAULT, v19, buf, v21);
    }
  }

  BOOL v11 = v7;
LABEL_27:
  CFTypeRef v22 = cf;
  if (!cf) {
    goto LABEL_30;
  }
  CFTypeRef cf = 0;
LABEL_29:
  CFRelease(v22);
LABEL_30:
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v11;
}

uint64_t SOSCCIsSafariSyncing()
{
  v1[2] = *(const void **)MEMORY[0x1E4F143B8];
  uint64_t result = SOSCCIsSOSTrustAndSyncingEnabled();
  if (result)
  {
    v1[0] = @"Passwords";
    v1[1] = @"CreditCards";
    return sosIsViewSetSyncing(2, v1);
  }
  return result;
}

uint64_t SOSCCIsAppleTVSyncing()
{
  v1[1] = *(const void **)MEMORY[0x1E4F143B8];
  uint64_t result = SOSCCIsSOSTrustAndSyncingEnabled();
  if (result)
  {
    v1[0] = @"AppleTV";
    return sosIsViewSetSyncing(1, v1);
  }
  return result;
}

uint64_t SOSCCIsHomeKitSyncing()
{
  v1[1] = *(const void **)MEMORY[0x1E4F143B8];
  uint64_t result = SOSCCIsSOSTrustAndSyncingEnabled();
  if (result)
  {
    v1[0] = @"HomeKit";
    return sosIsViewSetSyncing(1, v1);
  }
  return result;
}

uint64_t SOSCCIsWiFiSyncing()
{
  v1[1] = *(const void **)MEMORY[0x1E4F143B8];
  uint64_t result = SOSCCIsSOSTrustAndSyncingEnabled();
  if (result)
  {
    v1[0] = @"WiFi";
    return sosIsViewSetSyncing(1, v1);
  }
  return result;
}

uint64_t SOSCCIsContinuityUnlockSyncing()
{
  v1[1] = *(const void **)MEMORY[0x1E4F143B8];
  uint64_t result = SOSCCIsSOSTrustAndSyncingEnabled();
  if (result)
  {
    v1[0] = @"ContinuityUnlock";
    return sosIsViewSetSyncing(1, v1);
  }
  return result;
}

uint64_t SOSCCCopyApplication(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v2 = secLogObjForScope("hsa2PB");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEFAULT, "enter SOSCCCopyApplication applicant", buf, 2u);
    }

    int v8 = SecLogAPICreate(0, "SOSCCCopyApplication", 0, v3, v4, v5, v6, v7, 0);
    uint64_t v9 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v22 = v8;
      _os_log_debug_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8) {
      CFRelease(v8);
    }
    if (gSecurityd && (uint64_t v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 560)) != 0) {
      uint64_t v11 = v10(a1);
    }
    else {
      uint64_t v11 = peer_info_error_request(0x51u, a1);
    }
    uint64_t v17 = v11;
    uint64_t v18 = SecLogAPICreate(0, "SOSCCCopyApplication", @"return=%@", v12, v13, v14, v15, v16, v11);
    uint64_t v19 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v22 = v18;
      _os_log_debug_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v17;
}

uint64_t __SOSCCCopyApplication_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 560)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return peer_info_error_request(0x51u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCCleanupKVSKeys(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v2 = secLogObjForScope("cleanup-keys");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEFAULT, "enter SOSCCCleanupKVSKeys", buf, 2u);
    }

    int v8 = SecLogAPICreate(0, "SOSCCCleanupKVSKeys", 0, v3, v4, v5, v6, v7, 0);
    uint64_t v9 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v22 = v8;
      _os_log_debug_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8) {
      CFRelease(v8);
    }
    if (gSecurityd && (uint64_t v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 592)) != 0) {
      uint64_t v11 = v10(a1);
    }
    else {
      uint64_t v11 = simple_BOOL_error_request(0x54u, a1);
    }
    uint64_t v17 = v11;
    uint64_t v18 = SecLogAPICreate(0, "SOSCCCleanupKVSKeys", @"return=%d", v12, v13, v14, v15, v16, v11);
    uint64_t v19 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v22 = v18;
      _os_log_debug_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v17;
}

uint64_t __SOSCCCleanupKVSKeys_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 592)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x54u, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCCopyCircleJoiningBlob(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v4 = secLogObjForScope("hsa2PB");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCCopyCircleJoiningBlob approver", buf, 2u);
    }

    uint64_t v10 = SecLogAPICreate(0, "SOSCCCopyCircleJoiningBlob", 0, v5, v6, v7, v8, v9, 0);
    uint64_t v11 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v30 = v10;
      _os_log_debug_impl(&dword_18B299000, v11, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v10) {
      CFRelease(v10);
    }
    v28[0] = MEMORY[0x1E4F143A8];
    v28[1] = 3221225472;
    v28[2] = __SOSCCCopyCircleJoiningBlob_block_invoke;
    v28[3] = &__block_descriptor_48_e16_____CFData__8__0l;
    v28[4] = a1;
    v28[5] = a2;
    uint64_t v19 = __SOSCCCopyCircleJoiningBlob_block_invoke((uint64_t)v28, v12, v13, v14, v15, v16, v17, v18);
    uint64_t v25 = SecLogAPICreate(0, "SOSCCCopyCircleJoiningBlob", @"return=%@", v20, v21, v22, v23, v24, v19);
    CFSetRef v26 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v30 = v25;
      _os_log_debug_impl(&dword_18B299000, v26, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v25) {
      CFRelease(v25);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v19;
}

uint64_t __SOSCCCopyCircleJoiningBlob_block_invoke(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (gSecurityd && (uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t))(gSecurityd + 568)) != 0)
  {
    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v11 = *(void *)(a1 + 40);
    return v9(v10, v11);
  }
  else
  {
    uint64_t v13 = SOSPeerInfoCopyEncodedData(*(void *)(a1 + 32), a2, *(CFTypeRef **)(a1 + 40), a4, a5, a6, a7, a8);
    uint64_t v14 = *(CFTypeRef **)(a1 + 40);
    uint64_t v24 = 0;
    uint64_t v25 = &v24;
    uint64_t v26 = 0x2020000000;
    uint64_t v27 = 0;
    uint64_t v20 = SecLogAPICreate(0, "cfdata_error_request_returns_cfdata", 0, v15, v16, v17, v18, v19, 0);
    uint64_t v21 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v20;
      _os_log_debug_impl(&dword_18B299000, v21, OS_LOG_TYPE_DEBUG, "%@", (uint8_t *)&buf, 0xCu);
    }

    if (v20) {
      CFRelease(v20);
    }
    *(void *)&long long buf = MEMORY[0x1E4F143A8];
    *((void *)&buf + 1) = 3221225472;
    uint64_t v29 = __cfdata_error_request_returns_cfdata_block_invoke;
    uint64_t v30 = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    uint64_t v31 = v13;
    v23[0] = MEMORY[0x1E4F143A8];
    v23[1] = 3221225472;
    v23[2] = __cfdata_error_request_returns_cfdata_block_invoke_2;
    v23[3] = &unk_1E547F420;
    v23[4] = &v24;
    securityd_send_sync_and_do(0x52u, v14, (uint64_t)&buf, (uint64_t)v23);
    uint64_t v22 = v25[3];
    _Block_object_dispose(&v24, 8);
    if (v13) {
      CFRelease(v13);
    }
    return v22;
  }
}

void sub_18B37484C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __cfdata_error_request_returns_cfdata_block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  if (v3)
  {
    xpc_dictionary_set_value(v2, "data", v3);
  }
  return v3 != 0;
}

BOOL __cfdata_error_request_returns_cfdata_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  uint64_t v6 = xpc_dictionary_get_value(xdict, "status");
  uint64_t v7 = (void *)v6;
  if (xdict && v6)
  {
    uint64_t v8 = (const void *)_CFXPCCreateCFObjectFromXPCObject();
    uint64_t v9 = v8;
    if (v8)
    {
      CFTypeID v10 = CFGetTypeID(v8);
      if (v10 == CFDataGetTypeID())
      {
        CFRetain(v9);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v9;
LABEL_9:
        CFRelease(v9);
        goto LABEL_10;
      }
    }
    if (a3) {
      SecError(-50, a3, @"object %@ is not a data", v9);
    }
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    if (v9) {
      goto LABEL_9;
    }
  }
LABEL_10:
  BOOL v11 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;

  return v11;
}

uint64_t SOSCCCopyInitialSyncData(int a1, CFTypeRef *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v4 = secLogObjForScope("circleJoin");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCCopyInitialSyncData approver", buf, 2u);
    }

    CFTypeID v10 = SecLogAPICreate(0, "SOSCCCopyInitialSyncData", 0, v5, v6, v7, v8, v9, 0);
    BOOL v11 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v24 = v10;
      _os_log_debug_impl(&dword_18B299000, v11, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v10) {
      CFRelease(v10);
    }
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = __SOSCCCopyInitialSyncData_block_invoke;
    v21[3] = &__block_descriptor_44_e16_____CFData__8__0l;
    int v22 = a1;
    v21[4] = a2;
    uint64_t v12 = __SOSCCCopyInitialSyncData_block_invoke((uint64_t)v21);
    uint64_t v18 = SecLogAPICreate(0, "SOSCCCopyInitialSyncData", @"return=%@", v13, v14, v15, v16, v17, v12);
    uint64_t v19 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v24 = v18;
      _os_log_debug_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v12;
}

uint64_t __SOSCCCopyInitialSyncData_block_invoke(uint64_t a1)
{
  if (!gSecurityd || (uint64_t v1 = *(uint64_t (**)(uint64_t, uint64_t))(gSecurityd + 576)) == 0)
  {
    int v5 = *(_DWORD *)(a1 + 40);
    uint64_t v6 = *(CFTypeRef **)(a1 + 32);
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    uint64_t v17 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    void v12[2] = __flags_to_data_error_request_block_invoke;
    v12[3] = &__block_descriptor_36_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    int v13 = v5;
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    void v11[2] = __flags_to_data_error_request_block_invoke_2;
    v11[3] = &unk_1E547F420;
    v11[4] = &v14;
    securityd_send_sync_and_do(0x59u, v6, (uint64_t)v12, (uint64_t)v11);
    uint64_t v7 = (const void *)v15[3];
    if (v7)
    {
      CFTypeID v8 = CFGetTypeID(v7);
      CFTypeID TypeID = CFDataGetTypeID();
      uint64_t v10 = v15[3];
      if (v8 == TypeID) {
        goto LABEL_11;
      }
    }
    else
    {
      uint64_t v10 = 0;
    }
    SOSErrorCreate(1040, v6, 0, @"Expected CFData, got: %@", v10);
    uint64_t v10 = 0;
LABEL_11:
    _Block_object_dispose(&v14, 8);
    return v10;
  }
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);

  return v1(v3, v2);
}

void sub_18B374D74(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t __flags_to_data_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  return 1;
}

BOOL __flags_to_data_error_request_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v4 = xpc_dictionary_get_value(xdict, "status");
  int v5 = (void *)v4;
  if (xdict && v4) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
  }
  BOOL v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;

  return v6;
}

uint64_t SOSCCJoinWithCircleJoiningBlob(uint64_t a1, int a2, CFTypeRef *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    BOOL v6 = secLogObjForScope("hsa2PB");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "enter SOSCCJoinWithCircleJoiningBlob applicant", buf, 2u);
    }

    uint64_t v12 = SecLogAPICreate(0, "SOSCCJoinWithCircleJoiningBlob", 0, v7, v8, v9, v10, v11, 0);
    int v13 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      __int16 v33 = v12;
      _os_log_debug_impl(&dword_18B299000, v13, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v12) {
      CFRelease(v12);
    }
    v30[0] = MEMORY[0x1E4F143A8];
    v30[1] = 3221225472;
    v30[2] = __SOSCCJoinWithCircleJoiningBlob_block_invoke;
    v30[3] = &__block_descriptor_52_e5_B8__0l;
    int v31 = a2;
    v30[4] = a1;
    v30[5] = a3;
    uint64_t v21 = __SOSCCJoinWithCircleJoiningBlob_block_invoke((uint64_t)v30, v14, v15, v16, v17, v18, v19, v20);
    uint64_t v27 = SecLogAPICreate(0, "SOSCCJoinWithCircleJoiningBlob", @"return=%d", v22, v23, v24, v25, v26, v21);
    int v28 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      __int16 v33 = v27;
      _os_log_debug_impl(&dword_18B299000, v28, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v27) {
      CFRelease(v27);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0;
  }
  return v21;
}

uint64_t __SOSCCJoinWithCircleJoiningBlob_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t), uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (gSecurityd && (a4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(gSecurityd + 584)) != 0)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 48);
    uint64_t v9 = *(void *)(a1 + 40);
    uint64_t v10 = *(void *)(a1 + 32);
    return a4(v10, v8, v9);
  }
  else
  {
    int v12 = *(_DWORD *)(a1 + 48);
    uint64_t v14 = *(void *)(a1 + 32);
    int v13 = *(CFTypeRef **)(a1 + 40);
    uint64_t v19 = 0;
    uint64_t v20 = &v19;
    uint64_t v21 = 0x2020000000;
    char v22 = 0;
    uint64_t v15 = SecLogAPICreate(0, "cfdata_and_int_error_request_returns_BOOL", 0, (uint64_t)a4, a5, a6, a7, a8, 0);
    uint64_t v16 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v15;
      _os_log_debug_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEBUG, "%@", (uint8_t *)&buf, 0xCu);
    }

    if (v15) {
      CFRelease(v15);
    }
    *(void *)&long long buf = MEMORY[0x1E4F143A8];
    *((void *)&buf + 1) = 3221225472;
    uint64_t v24 = __cfdata_and_int_error_request_returns_BOOL_block_invoke;
    uint64_t v25 = &__block_descriptor_44_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    uint64_t v26 = v14;
    int v27 = v12;
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    v18[2] = __cfdata_and_int_error_request_returns_BOOL_block_invoke_2;
    v18[3] = &unk_1E547F420;
    v18[4] = &v19;
    securityd_send_sync_and_do(0x53u, v13, (uint64_t)&buf, (uint64_t)v18);
    uint64_t v17 = *((unsigned __int8 *)v20 + 24);
    _Block_object_dispose(&v19, 8);
    return v17;
  }
}

void sub_18B375294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SOSCCPeersHaveViewsEnabled(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v4 = secLogObjForScope("view-enabled");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCPeersHaveViewsEnabled", buf, 2u);
    }

    uint64_t v10 = SecLogAPICreate(0, "SOSCCPeersHaveViewsEnabled", 0, v5, v6, v7, v8, v9, 0);
    uint64_t v11 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v23 = v10;
      _os_log_debug_impl(&dword_18B299000, v11, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v10) {
      CFRelease(v10);
    }
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = __SOSCCPeersHaveViewsEnabled_block_invoke;
    v21[3] = &__block_descriptor_48_e19_____CFBoolean__8__0l;
    v21[4] = a1;
    void v21[5] = a2;
    uint64_t v12 = __SOSCCPeersHaveViewsEnabled_block_invoke((uint64_t)v21);
    uint64_t v18 = SecLogAPICreate(0, "SOSCCPeersHaveViewsEnabled", @"return=%@", v13, v14, v15, v16, v17, v12);
    uint64_t v19 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v23 = v18;
      _os_log_debug_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v12;
}

uint64_t __SOSCCPeersHaveViewsEnabled_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(uint64_t, uint64_t))(gSecurityd + 616)) != 0)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    uint64_t v3 = *(void *)(a1 + 32);
    return v1(v3, v2);
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v5 = *(CFTypeRef **)(a1 + 40);
    uint64_t v11 = 0;
    uint64_t v12 = &v11;
    uint64_t v13 = 0x2020000000;
    char v14 = 0;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3221225472;
    v10[2] = __cfarray_to_cfBOOLean_error_request_block_invoke;
    uint64_t v10[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v10[4] = v6;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = __cfarray_to_cfBOOLean_error_request_block_invoke_2;
    v9[3] = &unk_1E547F420;
    void v9[4] = &v11;
    uint64_t v7 = 0;
    if (securityd_send_sync_and_do(0x69u, v5, (uint64_t)v10, (uint64_t)v9))
    {
      if (*((unsigned char *)v12 + 24)) {
        uint64_t v8 = (uint64_t *)MEMORY[0x1E4F1CFD0];
      }
      else {
        uint64_t v8 = (uint64_t *)MEMORY[0x1E4F1CFC8];
      }
      uint64_t v7 = *v8;
    }
    _Block_object_dispose(&v11, 8);
    return v7;
  }
}

size_t __cfarray_to_cfBOOLean_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return SecXPCDictionarySetPListWithRepair(a2, "cfarray", *(const __CFString **)(a1 + 32), a3, a5, a6, a7, a8);
}

uint64_t __cfarray_to_cfBOOLean_error_request_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = xpc_dictionary_get_BOOL(xdict, "status");
  return 1;
}

uint64_t SOSCCMessageFromPeerIsPending(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v4 = secLogObjForScope("pending-check");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCMessageFromPeerIsPending", buf, 2u);
    }

    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    void v14[2] = __SOSCCMessageFromPeerIsPending_block_invoke;
    v14[3] = &__block_descriptor_48_e5_B8__0l;
    v14[4] = a1;
    void v14[5] = a2;
    uint64_t v5 = __SOSCCMessageFromPeerIsPending_block_invoke((uint64_t)v14);
    uint64_t v11 = SecLogAPICreate(0, "SOSCCMessageFromPeerIsPending", @"return=%d", v6, v7, v8, v9, v10, v5);
    uint64_t v12 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v16 = v11;
      _os_log_debug_impl(&dword_18B299000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v11) {
      CFRelease(v11);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v5;
}

uint64_t __SOSCCMessageFromPeerIsPending_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void, void))(gSecurityd + 632)) != 0) {
    return v1(*(void *)(a1 + 32), *(void *)(a1 + 40));
  }
  else {
    return peer_info_to_BOOL_error_request(0x6Bu, *(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40));
  }
}

uint64_t peer_info_to_BOOL_error_request(unsigned int a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  char v10 = 0;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __peer_info_to_BOOL_error_request_block_invoke;
  v6[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  void v6[4] = a2;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __peer_info_to_BOOL_error_request_block_invoke_2;
  v5[3] = &unk_1E547F420;
  v5[4] = &v7;
  securityd_send_sync_and_do(a1, a3, (uint64_t)v6, (uint64_t)v5);
  uint64_t v3 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t SOSCCSendToPeerIsPending(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __SOSCCSendToPeerIsPending_block_invoke;
    v13[3] = &__block_descriptor_48_e5_B8__0l;
    v13[4] = a1;
    void v13[5] = a2;
    uint64_t v4 = __SOSCCSendToPeerIsPending_block_invoke((uint64_t)v13);
    char v10 = SecLogAPICreate(0, "SOSCCSendToPeerIsPending", @"return=%d", v5, v6, v7, v8, v9, v4);
    uint64_t v11 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v15 = v10;
      _os_log_debug_impl(&dword_18B299000, v11, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v10) {
      CFRelease(v10);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v4;
}

uint64_t __SOSCCSendToPeerIsPending_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void, void))(gSecurityd + 640)) != 0) {
    return v1(*(void *)(a1 + 32), *(void *)(a1 + 40));
  }
  else {
    return peer_info_to_BOOL_error_request(0x6Cu, *(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40));
  }
}

uint64_t SOSCCSetCompatibilityMode(char a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = secLogObjForScope("sos-compatibility-mode");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCSetCompatibilityMode", buf, 2u);
  }

  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 3221225472;
  v21[2] = __SOSCCSetCompatibilityMode_block_invoke;
  v21[3] = &__block_descriptor_41_e5_B8__0l;
  char v22 = a1;
  v21[4] = a2;
  uint64_t v12 = __SOSCCSetCompatibilityMode_block_invoke((uint64_t)v21, v5, v6, v7, v8, v9, v10, v11);
  uint64_t v18 = SecLogAPICreate(0, "SOSCCSetCompatibilityMode", @"return=%d", v13, v14, v15, v16, v17, v12);
  uint64_t v19 = secLogObjForScope("api_trace");
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 138412290;
    uint64_t v24 = v18;
    _os_log_debug_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v18) {
    CFRelease(v18);
  }
  return v12;
}

uint64_t __SOSCCSetCompatibilityMode_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (gSecurityd && (uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t))(gSecurityd + 648)) != 0)
  {
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(unsigned __int8 *)(a1 + 40);
    return v8(v10, v9);
  }
  else
  {
    char v12 = *(unsigned char *)(a1 + 40);
    uint64_t v13 = *(CFTypeRef **)(a1 + 32);
    uint64_t v19 = 0;
    uint64_t v20 = &v19;
    uint64_t v21 = 0x2020000000;
    char v22 = 0;
    uint64_t v14 = SecLogAPICreate(0, "BOOL_and_error_request_returns_BOOL", 0, a4, a5, a6, a7, a8, 0);
    uint64_t v15 = secLogObjForScope("api_trace");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v14;
      _os_log_debug_impl(&dword_18B299000, v15, OS_LOG_TYPE_DEBUG, "%@", (uint8_t *)&buf, 0xCu);
    }

    if (v14) {
      CFRelease(v14);
    }
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 3221225472;
    v17[2] = __BOOL_and_error_request_returns_BOOL_block_invoke;
    v17[3] = &__block_descriptor_33_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    char v18 = v12;
    *(void *)&long long buf = MEMORY[0x1E4F143A8];
    *((void *)&buf + 1) = 3221225472;
    uint64_t v24 = __BOOL_and_error_request_returns_BOOL_block_invoke_2;
    uint64_t v25 = &unk_1E547F420;
    uint64_t v26 = &v19;
    securityd_send_sync_and_do(0x5Au, v13, (uint64_t)v17, (uint64_t)&buf);
    uint64_t v16 = *((unsigned __int8 *)v20 + 24);
    _Block_object_dispose(&v19, 8);
    return v16;
  }
}

void sub_18B376004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SOSCCFetchCompatibilityModeCachedValue(CFTypeRef *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = secLogObjForScope("sos-compatibility-mode-cached");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_debug_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEBUG, "enter SOSCCFetchCompatibilityModeCachedValue", buf, 2u);
  }

  if (gSecurityd && (uint64_t v3 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 664)) != 0) {
    uint64_t v4 = v3(a1);
  }
  else {
    uint64_t v4 = simple_BOOL_error_request(0x5Cu, a1);
  }
  uint64_t v10 = v4;
  uint64_t v11 = SecLogAPICreate(0, "SOSCCFetchCompatibilityModeCachedValue", @"return=%d", v5, v6, v7, v8, v9, v4);
  char v12 = secLogObjForScope("api_trace");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 138412290;
    uint64_t v15 = v11;
    _os_log_debug_impl(&dword_18B299000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v11) {
    CFRelease(v11);
  }
  return v10;
}

uint64_t __SOSCCFetchCompatibilityModeCachedValue_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 664)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x5Cu, *(CFTypeRef **)(a1 + 32));
  }
}

uint64_t SOSCCIsSOSTrustAndSyncingEnabledCachedValue()
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v0 = secLogObjForScope("sos-compatibility-mode-cached");
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_debug_impl(&dword_18B299000, v0, OS_LOG_TYPE_DEBUG, "enter SOSCCIsSOSTrustAndSyncingEnabledCachedValue", buf, 2u);
  }

  if (!OctagonIsSOSFeatureEnabled() || !SOSCompatibilityModeEnabled()) {
    return OctagonIsSOSFeatureEnabled();
  }
  uint64_t v1 = secLogObjForScope("sos-compatibility-mode-cached");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_18B299000, v1, OS_LOG_TYPE_DEFAULT, "SOS Compatibility Mode feature flag enabled, checking platform availability and sos compat mode", buf, 2u);
  }

  CFTypeRef cf = 0;
  uint64_t v2 = SOSCCFetchCompatibilityModeCachedValue(&cf);
  uint64_t v3 = secLogObjForScope("sos-compatibility-mode-cached");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = @"disabled";
    if (v2) {
      uint64_t v4 = @"enabled";
    }
    *(_DWORD *)long long buf = 138412290;
    CFTypeRef v10 = v4;
    _os_log_impl(&dword_18B299000, v3, OS_LOG_TYPE_DEFAULT, "sos trust and syncing is %@", buf, 0xCu);
  }

  if (cf)
  {
    uint64_t v5 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v10 = cf;
      _os_log_impl(&dword_18B299000, v5, OS_LOG_TYPE_DEFAULT, "sos-compatibility-mode-cached: fetching compatibility mode error: %@", buf, 0xCu);
    }

    CFTypeRef v6 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v6);
    }
  }
  return v2;
}

uint64_t SOSCCPushResetCircle(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = secLogObjForScope("push-reset-circle-to-kvs");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_debug_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEBUG, "enter SOSCCPushResetCircle", buf, 2u);
  }

  uint64_t v8 = SecLogAPICreate(0, "SOSCCPushResetCircle", 0, v3, v4, v5, v6, v7, 0);
  uint64_t v9 = secLogObjForScope("api_trace");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 138412290;
    char v22 = v8;
    _os_log_debug_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v8) {
    CFRelease(v8);
  }
  if (gSecurityd && (CFTypeRef v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 672)) != 0) {
    uint64_t v11 = v10(a1);
  }
  else {
    uint64_t v11 = simple_BOOL_error_request(0x5Du, a1);
  }
  uint64_t v17 = v11;
  char v18 = SecLogAPICreate(0, "SOSCCPushResetCircle", @"return=%d", v12, v13, v14, v15, v16, v11);
  uint64_t v19 = secLogObjForScope("api_trace");
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 138412290;
    char v22 = v18;
    _os_log_debug_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v18) {
    CFRelease(v18);
  }
  return v17;
}

uint64_t __SOSCCPushResetCircle_block_invoke(uint64_t a1)
{
  if (gSecurityd && (uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 672)) != 0) {
    return v1(*(void *)(a1 + 32));
  }
  else {
    return simple_BOOL_error_request(0x5Du, *(CFTypeRef **)(a1 + 32));
  }
}

void SOSCCAccountGetPublicKey(void *a1)
{
  id v1 = a1;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) == 0)
  {
    uint64_t v3 = sosDisabledNSError();
    (*((void (**)(id, void, void, void *))v1 + 2))(v1, 0, 0, v3);
    goto LABEL_15;
  }
  CFTypeRef cf = 0;
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    if (gSecurityd && (uint64_t v2 = *(void (**)(void))(gSecurityd + 680)) != 0)
    {
      uint64_t v3 = v2();
      if (!v3)
      {
LABEL_6:
        CFTypeRef v4 = 0;
        goto LABEL_9;
      }
    }
    else
    {
      if (SOSCCGetStatusObject_onceToken != -1) {
        dispatch_once(&SOSCCGetStatusObject_onceToken, &__block_literal_global_321);
      }
      uint64_t v6 = [(id)SOSCCGetStatusObject_control connection];
      uint64_t v3 = [v6 remoteObjectProxy];

      if (!v3) {
        goto LABEL_6;
      }
    }
    [v3 userPublicKey:v1];
LABEL_15:

    goto LABEL_16;
  }
  SOSCCSetSOSDisabledError(&cf);
  CFTypeRef v4 = cf;
LABEL_9:
  (*((void (**)(id, void, void, CFTypeRef))v1 + 2))(v1, 0, 0, v4);
  CFTypeRef v5 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v5);
  }
LABEL_16:
}

id sosDisabledNSError()
{
  if (staticSOSDisabledError_onceToken != -1) {
    dispatch_once(&staticSOSDisabledError_onceToken, &__block_literal_global_277);
  }
  CFAllocatorRef v0 = (void *)staticSOSDisabledError_sosIsDisabledError;

  return v0;
}

uint64_t __SOSCCGetStatusObject_block_invoke()
{
  SOSCCGetStatusObject_control = objc_alloc_init(SecSOSStatus);

  return MEMORY[0x1F41817F8]();
}

void SOSCCAccountGetKeyCircleGeneration(void *a1)
{
  id v1 = a1;
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = __SOSCCAccountGetKeyCircleGeneration_block_invoke;
    v3[3] = &unk_1E547E6F8;
    id v4 = v1;
    SOSCCAccountGetPublicKey(v3);
  }
  else
  {
    uint64_t v2 = sosDisabledNSError();
    (*((void (**)(id, void, void *))v1 + 2))(v1, 0, v2);
  }
}

void __SOSCCAccountGetKeyCircleGeneration_block_invoke(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v12 = a3;
  if (v12)
  {
    uint64_t v6 = (void *)MEMORY[0x1E4F1CA58];
    id v7 = a4;
    uint64_t v8 = [v6 dataWithLength:32];
    ccsha256_di();
    [v12 length];
    [v12 bytes];
    id v9 = v8;
    [v9 mutableBytes];
    ccdigest();
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v11 = *(void (**)(uint64_t, void, id))(v10 + 16);
    id v9 = a4;
    v11(v10, 0, v9);
  }
}

id SOSCCCircleHash(void *a1)
{
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    uint64_t v14 = 0;
    uint64_t v2 = SOSCCGetSynchronousStatusObject((CFTypeRef *)&v14);
    uint64_t v3 = v2;
    if (v2)
    {
      uint64_t v8 = 0;
      id v9 = &v8;
      uint64_t v10 = 0x3032000000;
      uint64_t v11 = __Block_byref_object_copy__8401;
      id v12 = __Block_byref_object_dispose__8402;
      id v13 = 0;
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 3221225472;
      v7[2] = __SOSCCCircleHash_block_invoke;
      v7[3] = &unk_1E547E720;
      void v7[4] = &v8;
      [v2 circleHash:v7];
      id v4 = (id)v9[5];
      _Block_object_dispose(&v8, 8);
    }
    else
    {
      if (a1) {
        *a1 = v14;
      }
      CFTypeRef v5 = v14;
      if (v14)
      {
        uint64_t v14 = 0;
        CFRelease(v5);
      }
      id v4 = 0;
    }
  }
  else if (a1)
  {
    sosDisabledNSError();
    id v4 = 0;
    *a1 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    id v4 = 0;
  }

  return v4;
}

void sub_18B376BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id SOSCCGetSynchronousStatusObject(CFTypeRef *a1)
{
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    if (gSecurityd && (uint64_t v2 = *(void (**)(void))(gSecurityd + 680)) != 0)
    {
      uint64_t v3 = v2();
    }
    else
    {
      if (SOSCCGetSynchronousStatusObject_onceToken != -1) {
        dispatch_once(&SOSCCGetSynchronousStatusObject_onceToken, &__block_literal_global_324);
      }
      uint64_t v8 = 0;
      id v9 = &v8;
      uint64_t v10 = 0x3032000000;
      uint64_t v11 = __Block_byref_object_copy__8401;
      id v12 = __Block_byref_object_dispose__8402;
      id v13 = 0;
      id v4 = [(id)SOSCCGetSynchronousStatusObject_control connection];
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 3221225472;
      v7[2] = __SOSCCGetSynchronousStatusObject_block_invoke_2;
      v7[3] = &unk_1E5481470;
      void v7[4] = &v8;
      uint64_t v3 = [v4 synchronousRemoteObjectProxyWithErrorHandler:v7];

      if (a1)
      {
        CFTypeRef v5 = (const void *)v9[5];
        if (v5) {
          *a1 = v5;
        }
      }
      _Block_object_dispose(&v8, 8);
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    uint64_t v3 = 0;
  }

  return v3;
}

void sub_18B376D6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__8401(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__8402(uint64_t a1)
{
}

void __SOSCCCircleHash_block_invoke(uint64_t a1, void *a2)
{
}

void __SOSCCGetSynchronousStatusObject_block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  id v4 = a2;
  CFTypeRef v5 = secLogObjForScope("ghostbust");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v4;
    _os_log_impl(&dword_18B299000, v5, OS_LOG_TYPE_DEFAULT, "An error occurred on the xpc connection to setup the background session: %@", (uint8_t *)&v6, 0xCu);
  }

  if (v4) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a2);
  }
}

uint64_t __SOSCCGetSynchronousStatusObject_block_invoke()
{
  SOSCCGetSynchronousStatusObject_control = objc_alloc_init(SecSOSStatus);

  return MEMORY[0x1F41817F8]();
}

void SOSCCGhostBust(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    CFTypeRef v10 = 0;
    id v4 = SOSCCGetSynchronousStatusObject(&v10);
    if (v4)
    {
      CFTypeRef v5 = secLogObjForScope("ghostbust");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_18B299000, v5, OS_LOG_TYPE_DEFAULT, "API Called", buf, 2u);
      }

      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 3221225472;
      v7[2] = __SOSCCGhostBust_block_invoke;
      v7[3] = &unk_1E547F640;
      id v8 = v3;
      [v4 ghostBust:a1 complete:v7];
    }
    else
    {
      (*((void (**)(id, void, CFTypeRef))v3 + 2))(v3, 0, v10);
      CFTypeRef v6 = v10;
      if (v10)
      {
        CFTypeRef v10 = 0;
        CFRelease(v6);
      }
    }
  }
  else
  {
    id v4 = sosDisabledNSError();
    (*((void (**)(id, void, void *))v3 + 2))(v3, 0, v4);
  }
}

void __SOSCCGhostBust_block_invoke(uint64_t a1, int a2, void *a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  CFTypeRef v6 = secLogObjForScope("ghostbust");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109120;
    v7[1] = a2;
    _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "API returned: %d", (uint8_t *)v7, 8u);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void SOSCCGhostBustTriggerTimed(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    CFTypeRef v10 = 0;
    id v4 = SOSCCGetSynchronousStatusObject(&v10);
    if (v4)
    {
      id v5 = secLogObjForScope("ghostbust");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_18B299000, v5, OS_LOG_TYPE_DEFAULT, "API Trigger Timed Called", buf, 2u);
      }

      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 3221225472;
      _DWORD v7[2] = __SOSCCGhostBustTriggerTimed_block_invoke;
      v7[3] = &unk_1E547F640;
      id v8 = v3;
      [v4 ghostBustTriggerTimed:a1 complete:v7];
    }
    else
    {
      (*((void (**)(id, void, CFTypeRef))v3 + 2))(v3, 0, v10);
      CFTypeRef v6 = v10;
      if (v10)
      {
        CFTypeRef v10 = 0;
        CFRelease(v6);
      }
    }
  }
  else
  {
    id v4 = sosDisabledNSError();
    (*((void (**)(id, void, void *))v3 + 2))(v3, 0, v4);
  }
}

void __SOSCCGhostBustTriggerTimed_block_invoke(uint64_t a1, int a2, void *a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  CFTypeRef v6 = secLogObjForScope("ghostbust");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109120;
    v7[1] = a2;
    _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "API Trigger Timed returned: %d", (uint8_t *)v7, 8u);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void SOSCCGhostBustInfo(void *a1)
{
  id v1 = a1;
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    CFTypeRef v8 = 0;
    uint64_t v2 = SOSCCGetSynchronousStatusObject(&v8);
    if (v2)
    {
      id v3 = secLogObjForScope("ghostbust");
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_18B299000, v3, OS_LOG_TYPE_DEFAULT, "API Info Called", buf, 2u);
      }

      v5[0] = MEMORY[0x1E4F143A8];
      v5[1] = 3221225472;
      v5[2] = __SOSCCGhostBustInfo_block_invoke;
      v5[3] = &unk_1E547E748;
      id v6 = v1;
      [v2 ghostBustInfo:v5];
    }
    else
    {
      (*((void (**)(id, void, CFTypeRef))v1 + 2))(v1, 0, v8);
      CFTypeRef v4 = v8;
      if (v8)
      {
        CFTypeRef v8 = 0;
        CFRelease(v4);
      }
    }
  }
  else
  {
    uint64_t v2 = sosDisabledNSError();
    (*((void (**)(id, void, void *))v1 + 2))(v1, 0, v2);
  }
}

void __SOSCCGhostBustInfo_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  id v7 = secLogObjForScope("ghostbust");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeRef v8 = 0;
    _os_log_impl(&dword_18B299000, v7, OS_LOG_TYPE_DEFAULT, "API Info returned", v8, 2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

CFStringRef SecCopyErrorMessageString(OSStatus status, void *reserved)
{
  uint64_t v2 = *(void *)&status;
  CFStringRef result = copyErrorMessageFromBundle(*(uint64_t *)&status, @"SecErrorMessages");
  if (!result)
  {
    CFStringRef result = copyErrorMessageFromBundle(v2, @"SecDebugErrorMessages");
    if (!result) {
      return CFStringCreateWithFormat(0, 0, @"OSStatus %d", v2);
    }
  }
  return result;
}

CFStringRef copyErrorMessageFromBundle(uint64_t a1, const __CFString *a2)
{
  uint64_t Bundle = SecFrameworkGetBundle();
  if (!Bundle) {
    return 0;
  }
  id v5 = (__CFBundle *)Bundle;
  CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%d", a1);
  if (!v6) {
    return 0;
  }
  CFStringRef v7 = v6;
  CFStringRef v8 = CFBundleCopyLocalizedString(v5, v7, v7, a2);
  if (CFEqual(v8, v7) && v8)
  {
    CFRelease(v8);
    CFStringRef v8 = 0;
  }
  CFRelease(v7);
  return v8;
}

uint64_t __SecAccessControlGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

id SecAccessControlCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();

  return SecAccessControlCopyFormatDescription(a1);
}

id SecAccessControlCopyFormatDescription(uint64_t a1)
{
  id v1 = (void *)MEMORY[0x1E4F28E78];
  id v2 = *(id *)(a1 + 16);
  id v3 = [v1 string];
  CFTypeRef v4 = [v2 objectForKeyedSubscript:@"prot"];
  dumpValue(v4, v3, &stru_1ED84D0B0);

  id v5 = [v2 objectForKeyedSubscript:@"acl"];

  dumpValue(v5, v3, @";");
  id v6 = [NSString stringWithFormat:@"<SecAccessControlRef: %@>", v3];

  return v6;
}

void dumpValue(void *a1, void *a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (v5)
  {
    CFTypeID v8 = CFGetTypeID(v5);
    if (v8 == CFBooleanGetTypeID())
    {
      if ([(__CFString *)v5 BOOLValue]) {
        id v9 = @"true";
      }
      else {
        id v9 = @"false";
      }
LABEL_6:
      CFTypeRef v10 = v6;
LABEL_7:
      [v10 appendString:v9];
      goto LABEL_11;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v11 = [(__CFString *)v5 stringValue];
      [v6 appendString:v11];
LABEL_10:

      goto LABEL_11;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      CFTypeRef v10 = v6;
      id v9 = v5;
      goto LABEL_7;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        v26[0] = MEMORY[0x1E4F143A8];
        v26[1] = 3221225472;
        v26[2] = __dumpValue_block_invoke;
        v26[3] = &unk_1E547E8C0;
        id v27 = v6;
        id v28 = v7;
        [(__CFString *)v5 enumerateKeysAndObjectsUsingBlock:v26];

        goto LABEL_11;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_11;
      }
      [v6 appendString:@"["];
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      uint64_t v15 = v5;
      uint64_t v16 = [(__CFString *)v15 countByEnumeratingWithState:&v22 objects:v29 count:16];
      if (v16)
      {
        uint64_t v17 = v16;
        uint64_t v18 = *(void *)v23;
        uint64_t v19 = &stru_1ED84D0B0;
        do
        {
          uint64_t v20 = 0;
          do
          {
            if (*(void *)v23 != v18) {
              objc_enumerationMutation(v15);
            }
            uint64_t v21 = *(void *)(*((void *)&v22 + 1) + 8 * v20);
            [v6 appendString:v19];
            dumpValue(v21, v6, v7);
            ++v20;
            uint64_t v19 = @",";
          }
          while (v17 != v20);
          uint64_t v17 = [(__CFString *)v15 countByEnumeratingWithState:&v22 objects:v29 count:16];
          uint64_t v19 = @",";
        }
        while (v17);
      }

      id v9 = @"]";
      goto LABEL_6;
    }
    uint64_t v11 = v5;
    uint64_t v12 = [(__CFString *)v11 bytes];
    if ((unint64_t)[(__CFString *)v11 length] <= 0x40)
    {
      unint64_t v13 = [(__CFString *)v11 length];
      if (!v13) {
        goto LABEL_22;
      }
    }
    else
    {
      unint64_t v13 = 64;
    }
    uint64_t v14 = 0;
    do
      objc_msgSend(v6, "appendFormat:", @"%02X", *(unsigned __int8 *)(v12 + v14++));
    while (v13 != v14);
LABEL_22:
    if (v13 < [(__CFString *)v11 length]) {
      objc_msgSend(v6, "appendFormat:", @"...(%db)", -[__CFString length](v11, "length"));
    }
    goto LABEL_10;
  }
LABEL_11:
}

uint64_t __dumpValue_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = *(void **)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  id v7 = a3;
  id v8 = a2;
  [v5 appendString:v6];
  dumpValue(v8, *(void *)(a1 + 32), &stru_1ED84D0B0);

  objc_msgSend(*(id *)(a1 + 32), "appendString:", @"(");
  dumpValue(v7, *(void *)(a1 + 32), &stru_1ED84D0B0);

  id v9 = *(void **)(a1 + 32);

  return [v9 appendString:@""]);
}

SecAccessControlRef SecAccessControlCreateWithFlags(CFAllocatorRef allocator, CFTypeRef protection, SecAccessControlCreateFlags flags, CFErrorRef *error)
{
  uint64_t v8 = SecAccessControlCreate(allocator, (__CFString **)error);
  id v9 = (__SecAccessControl *)v8;
  if (!v8) {
    return v9;
  }
  if (!SecAccessControlSetProtection(v8, protection, (__CFString **)error))
  {
LABEL_14:
    CFMutableArrayRef Mutable = v9;
    id v9 = 0;
LABEL_15:
    CFRelease(Mutable);
    return v9;
  }
  if (flags)
  {
    if ((~flags & 0xC000) == 0)
    {
      SecError(-50, (__CFString **)error, @"only one logical operation can be set");
      goto LABEL_14;
    }
    if ((flags & 8) != 0 && (flags & 0xA) != 8)
    {
      SecError(-50, (__CFString **)error, @"only one bio constraint can be set");
      goto LABEL_14;
    }
    if ((flags & 1) != 0 && (flags & 0xFFFFFFFF3FFFFFFELL) != 0)
    {
      SecError(-50, (__CFString **)error, @"kSecAccessControlUserPresence can be combined only with kSecAccessControlApplicationPassword and kSecAccessControlPrivateKeyUsage");
      goto LABEL_14;
    }
    CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
    if (flags)
    {
      MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(allocator, v12, v13, v14, v15, v16, v17, v18, @"cpo", @"DeviceOwnerAuthentication");
      if (!MutableForCFTypesWith) {
        goto LABEL_74;
      }
      uint64_t v20 = MutableForCFTypesWith;
      CFArrayAppendValue(Mutable, MutableForCFTypesWith);
      CFRelease(v20);
    }
    if ((flags & 0x10) != 0)
    {
      uint64_t v21 = CFDictionaryCreateMutableForCFTypesWith(allocator, v12, v13, v14, v15, v16, v17, v18, @"cup", *MEMORY[0x1E4F1CFD0]);
      if (!v21) {
        goto LABEL_74;
      }
      long long v22 = v21;
      CFArrayAppendValue(Mutable, v21);
      CFRelease(v22);
    }
    if ((flags & 2) != 0)
    {
      if (_getEmptyData_onceToken != -1) {
        dispatch_once(&_getEmptyData_onceToken, &__block_literal_global_8481);
      }
      BiometryAny = SecAccessConstraintCreateBiometryAny(allocator, _getEmptyData_emptyData, v13, v14, v15, v16, v17, v18);
      if (!BiometryAny) {
        goto LABEL_74;
      }
      long long v24 = BiometryAny;
      CFArrayAppendValue(Mutable, BiometryAny);
      CFRelease(v24);
    }
    if ((flags & 8) != 0)
    {
      if (_getEmptyData_onceToken != -1) {
        dispatch_once(&_getEmptyData_onceToken, &__block_literal_global_8481);
      }
      BiometryCurrentSet = SecAccessConstraintCreateBiometryCurrentSet(allocator, _getEmptyData_emptyData, (const void *)_getEmptyData_emptyData, v14, v15, v16, v17, v18);
      if (!BiometryCurrentSet) {
        goto LABEL_74;
      }
      uint64_t v26 = BiometryCurrentSet;
      CFArrayAppendValue(Mutable, BiometryCurrentSet);
      CFRelease(v26);
    }
    if ((flags & 0x20) != 0)
    {
      id v27 = CFDictionaryCreateMutableForCFTypesWith(allocator, v12, v13, v14, v15, v16, v17, v18, @"cwtch", *MEMORY[0x1E4F1CFD0]);
      if (!v27) {
        goto LABEL_74;
      }
      id v28 = v27;
      CFArrayAppendValue(Mutable, v27);
      CFRelease(v28);
    }
    if ((flags & 0x80000000) != 0)
    {
      MutableConstraints = (__CFDictionary *)SecAccessControlGetMutableConstraints((CFDictionaryRef *)v9);
      CFDictionarySetValue(MutableConstraints, @"prp", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    CFIndex Count = CFArrayGetCount(Mutable);
    if (Count >= 2)
    {
      if ((flags & 0x4000) != 0) {
        uint64_t v31 = 1;
      }
      else {
        uint64_t v31 = Count;
      }
      ValueOfKofN = SecAccessConstraintCreateValueOfKofN(allocator, v31, Mutable, (__CFString **)error);
      if (!ValueOfKofN) {
        goto LABEL_75;
      }
      if ((flags & 0x40000000) != 0)
      {
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"osgn", ValueOfKofN, (__CFString **)error)|| !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"ock", ValueOfKofN, (__CFString **)error)|| !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"okd", ValueOfKofN, (__CFString **)error)|| (__int16 v33 = (const void *)*MEMORY[0x1E4F1CFD0], !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"oa", (CFTypeRef)*MEMORY[0x1E4F1CFD0],
                 (__CFString **)error)))
        {
LABEL_75:
          CFRelease(v9);
          if (Mutable) {
            CFRelease(Mutable);
          }
          id v9 = 0;
          CFMutableArrayRef Mutable = ValueOfKofN;
          if (ValueOfKofN) {
            goto LABEL_15;
          }
          return v9;
        }
      }
      else
      {
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"od", ValueOfKofN, (__CFString **)error))goto LABEL_75; {
        __int16 v33 = (const void *)*MEMORY[0x1E4F1CFD0];
        }
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"oe", (CFTypeRef)*MEMORY[0x1E4F1CFD0], (__CFString **)error))goto LABEL_75; {
      }
        }
      if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"odel", v33, (__CFString **)error)) {
        goto LABEL_75;
      }
      CFRelease(ValueOfKofN);
LABEL_72:
      if (!Mutable) {
        return v9;
      }
      goto LABEL_15;
    }
    if (Count == 1)
    {
      if ((flags & 0x40000000) != 0)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(Mutable, 0);
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"osgn", ValueAtIndex, (__CFString **)error))goto LABEL_74; {
        char v38 = CFArrayGetValueAtIndex(Mutable, 0);
        }
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"ock", v38, (__CFString **)error)) {
          goto LABEL_74;
        }
        uint64_t v39 = CFArrayGetValueAtIndex(Mutable, 0);
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"okd", v39, (__CFString **)error)) {
          goto LABEL_74;
        }
        __int16 v35 = (const void *)*MEMORY[0x1E4F1CFD0];
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"oa", (CFTypeRef)*MEMORY[0x1E4F1CFD0], (__CFString **)error))goto LABEL_74; {
      }
        }
      else
      {
        uint64_t v34 = CFArrayGetValueAtIndex(Mutable, 0);
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"od", v34, (__CFString **)error)) {
          goto LABEL_74;
        }
        __int16 v35 = (const void *)*MEMORY[0x1E4F1CFD0];
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"oe", (CFTypeRef)*MEMORY[0x1E4F1CFD0], (__CFString **)error))goto LABEL_74; {
      }
        }
      uint64_t v40 = (CFDictionaryRef *)v9;
      uint64_t v41 = v35;
    }
    else
    {
      CFTypeRef v36 = (const void *)*MEMORY[0x1E4F1CFD0];
      if ((flags & 0x40000000) == 0)
      {
        if (SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"dacl", (CFTypeRef)*MEMORY[0x1E4F1CFD0], (__CFString **)error))
        {
          goto LABEL_72;
        }
        goto LABEL_74;
      }
      if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"osgn", (CFTypeRef)*MEMORY[0x1E4F1CFD0], (__CFString **)error)|| !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"ock", v36, (__CFString **)error)|| !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"okd", v36, (__CFString **)error)|| !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"oa", v36, (__CFString **)error))
      {
        goto LABEL_74;
      }
      uint64_t v40 = (CFDictionaryRef *)v9;
      uint64_t v41 = v36;
    }
    if (SecAccessControlAddConstraintForOperation(v40, @"odel", v41, (__CFString **)error)) {
      goto LABEL_72;
    }
LABEL_74:
    ValueOfKofN = 0;
    goto LABEL_75;
  }
  if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"dacl", (CFTypeRef)*MEMORY[0x1E4F1CFD0], (__CFString **)error))goto LABEL_14; {
  return v9;
  }
}

__CFDictionary *SecAccessConstraintCreateBiometryAny(const __CFAllocator *a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, @"pbioc", a2);
  int v17 = CFDictionaryCreateMutableForCFTypesWith(a1, v10, v11, v12, v13, v14, v15, v16, @"cbio", (uint64_t)MutableForCFTypesWith);
  if (MutableForCFTypesWith) {
    CFRelease(MutableForCFTypesWith);
  }
  return v17;
}

__CFDictionary *SecAccessConstraintCreateBiometryCurrentSet(const __CFAllocator *a1, uint64_t a2, const void *a3, int a4, int a5, int a6, int a7, int a8)
{
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, a2, (int)a3, a4, a5, a6, a7, a8, @"pbioc", a2);
  CFDictionarySetValue(MutableForCFTypesWith, @"pbioh", a3);
  int v18 = CFDictionaryCreateMutableForCFTypesWith(a1, v11, v12, v13, v14, v15, v16, v17, @"cbio", (uint64_t)MutableForCFTypesWith);
  if (MutableForCFTypesWith) {
    CFRelease(MutableForCFTypesWith);
  }
  return v18;
}

const void *SecAccessControlGetMutableConstraints(CFDictionaryRef *a1)
{
  uint64_t result = CFDictionaryGetValue(a1[2], @"acl");
  if (!result)
  {
    CFAllocatorRef v3 = CFGetAllocator(a1);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(a1[2], @"acl", Mutable);
    CFRelease(Mutable);
    CFDictionaryRef v5 = a1[2];
    return CFDictionaryGetValue(v5, @"acl");
  }
  return result;
}

__CFDictionary *SecAccessConstraintCreateValueOfKofN(const __CFAllocator *a1, uint64_t a2, const __CFArray *a3, __CFString **a4)
{
  uint64_t valuePtr = a2;
  CFNumberRef v7 = CFNumberCreate(a1, kCFNumberCFIndexType, &valuePtr);
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, v8, v9, v10, v11, v12, v13, v14, @"pkofn", (uint64_t)v7);
  CFRelease(v7);
  CFIndex Count = CFArrayGetCount(a3);
  if (Count >= 1)
  {
    CFIndex v17 = Count;
    CFIndex v18 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, v18);
      if (!ValueAtIndex) {
        break;
      }
      CFDictionaryRef v20 = ValueAtIndex;
      CFTypeID v21 = CFGetTypeID(ValueAtIndex);
      if (v21 != CFDictionaryGetTypeID()) {
        break;
      }
      uint64_t v22 = 0;
      while (1)
      {
        long long v23 = off_1E547E8E0[v22];
        Boolean Value = CFDictionaryGetValue(v20, v23);
        if (Value) {
          break;
        }
        if (++v22 == 4) {
          goto LABEL_11;
        }
      }
      CFDictionarySetValue(MutableForCFTypesWith, v23, Value);
      if (++v18 == v17) {
        return MutableForCFTypesWith;
      }
    }
LABEL_11:
    SecError(-50, a4, @"SecAccessControl: invalid constraint for k-of-n");
    if (MutableForCFTypesWith)
    {
      CFRelease(MutableForCFTypesWith);
      return 0;
    }
  }
  return MutableForCFTypesWith;
}

BOOL SecAccessControlAddConstraintForOperation(CFDictionaryRef *a1, const void *a2, CFTypeRef cf, __CFString **a4)
{
  if (cf && (CFTypeID v8 = CFGetTypeID(cf), v8 == CFDictionaryGetTypeID())
    || CFEqual(cf, (CFTypeRef)*MEMORY[0x1E4F1CFD0])
    || CFEqual(cf, (CFTypeRef)*MEMORY[0x1E4F1CFC8]))
  {
    MutableConstraints = (__CFDictionary *)SecAccessControlGetMutableConstraints(a1);
    CFDictionarySetValue(MutableConstraints, a2, cf);
    return 1;
  }
  else
  {
    return SecError(-50, a4, @"invalid constraint");
  }
}

CFMutableDataRef ___getEmptyData_block_invoke()
{
  CFMutableDataRef result = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  _getEmptyData_emptyData = (uint64_t)result;
  return result;
}

__CFDictionary *SecAccessConstraintCreatePolicy(const __CFAllocator *a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, @"cpo", a2);
}

__CFDictionary *SecAccessConstraintCreatePasscode(const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, @"cup", *MEMORY[0x1E4F1CFD0]);
}

__CFDictionary *SecAccessConstraintCreateCompanion(const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, @"cwtch", *MEMORY[0x1E4F1CFD0]);
}

void SecAccessControlSetRequirePassword(CFDictionaryRef *a1, int a2)
{
  MutableConstraints = (__CFDictionary *)SecAccessControlGetMutableConstraints(a1);
  CFTypeRef v4 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a2) {
    CFTypeRef v4 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionaryRef v5 = *v4;

  CFDictionarySetValue(MutableConstraints, @"prp", v5);
}

__CFDictionary *SecAccessConstraintCreateWatch(const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, @"cwtch", *MEMORY[0x1E4F1CFD0]);
}

__CFDictionary *SecAccessConstraintCreateKofN(const __CFAllocator *a1, uint64_t a2, const __CFArray *a3, __CFString **a4)
{
  CFMutableDataRef result = SecAccessConstraintCreateValueOfKofN(a1, a2, a3, a4);
  if (result)
  {
    int v13 = result;
    MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, v6, v7, v8, v9, v10, v11, v12, @"ckon", (uint64_t)result);
    CFRelease(v13);
    return MutableForCFTypesWith;
  }
  return result;
}

__CFData *SecAccessControlCopyConstraintData(uint64_t a1, const void *a2)
{
  CFStringRef Constraint = (const __CFString *)SecAccessControlGetConstraint(a1, a2);
  CFIndex v9 = der_sizeof_plist(Constraint, 0, v3, v4, v5, v6, v7, v8);
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, v9);
  CFDataSetLength(Mutable, v9);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (!der_encode_plist_repair(Constraint, 0, 0, MutableBytePtr, (unint64_t)&MutableBytePtr[v9], v12, v13, v14)&& Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

void SecAccessControlSetConstraints(CFMutableDictionaryRef *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v4, 0, a2);
  CFDictionarySetValue(a1[2], @"acl", MutableCopy);
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }
}

CFDictionaryRef SecAccessControlGetRequirePassword(uint64_t a1)
{
  CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"acl");
  if (result)
  {
    Boolean Value = CFDictionaryGetValue(result, @"prp");
    uint64_t v3 = (const void *)*MEMORY[0x1E4F1CFD0];
    if (Value) {
      BOOL v4 = v3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4) {
      return (const __CFDictionary *)(Value == v3);
    }
    else {
      return (const __CFDictionary *)(CFEqual(Value, v3) != 0);
    }
  }
  return result;
}

void SecAccessControlSetBound(uint64_t a1, int a2)
{
  id v2 = *(__CFDictionary **)(a1 + 16);
  uint64_t v3 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a2) {
    uint64_t v3 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(v2, @"bound", *v3);
}

uint64_t SecAccessControlIsBound(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  Boolean Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"bound");
  if (Value && *MEMORY[0x1E4F1CFD0] && CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F1CFD0])) {
    return 1;
  }
  if (SecAccessControlGetRequirePassword(a1)) {
    return 0;
  }
  BOOL v4 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"acl");
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v5 = objc_msgSend(v4, "allValues", 0);
  uint64_t v6 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v13;
    CFIndex v9 = (const void *)*MEMORY[0x1E4F1CFD0];
    while (2)
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v13 != v8) {
          objc_enumerationMutation(v5);
        }
        if (!CFEqual(*(CFTypeRef *)(*((void *)&v12 + 1) + 8 * i), v9))
        {
          uint64_t v3 = 0;
          goto LABEL_17;
        }
      }
      uint64_t v7 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
      if (v7) {
        continue;
      }
      break;
    }
  }
  uint64_t v3 = 1;
LABEL_17:

  return v3;
}

void SecItemFetchCurrentItemOutOfBand(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  uint64_t v7 = _os_activity_create(&dword_18B299000, "fetchCurrentItemOutOfBand", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  uint64_t v8 = (void *)MEMORY[0x18C12E850]();
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3221225472;
  void v14[2] = __SecItemFetchCurrentItemOutOfBand_block_invoke;
  v14[3] = &unk_1E547F618;
  id v9 = v6;
  id v15 = v9;
  int v10 = SecuritydXPCProxyObject(0, v14);
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  void v12[2] = __SecItemFetchCurrentItemOutOfBand_block_invoke_2;
  v12[3] = &unk_1E547E908;
  id v11 = v9;
  id v13 = v11;
  [v10 secItemFetchCurrentItemOutOfBand:v5 forceFetch:a2 complete:v12];

  os_activity_scope_leave(&state);
}

void sub_18B379DC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state)
{
}

uint64_t __SecItemFetchCurrentItemOutOfBand_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t __SecItemFetchCurrentItemOutOfBand_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void SecItemFetchPCSIdentityOutOfBand(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  uint64_t v7 = _os_activity_create(&dword_18B299000, "fetchPCSIdentityOutOfBand", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  uint64_t v8 = (void *)MEMORY[0x18C12E850]();
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3221225472;
  void v14[2] = __SecItemFetchPCSIdentityOutOfBand_block_invoke;
  v14[3] = &unk_1E547F618;
  id v9 = v6;
  id v15 = v9;
  int v10 = SecuritydXPCProxyObject(0, v14);
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  void v12[2] = __SecItemFetchPCSIdentityOutOfBand_block_invoke_2;
  v12[3] = &unk_1E547E908;
  id v11 = v9;
  id v13 = v11;
  [v10 secItemFetchPCSIdentityByKeyOutOfBand:v5 forceFetch:a2 complete:v12];

  os_activity_scope_leave(&state);
}

void sub_18B379F84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state)
{
}

uint64_t __SecItemFetchPCSIdentityOutOfBand_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t __SecItemFetchPCSIdentityOutOfBand_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

unint64_t SecBase64Encode(unsigned __int8 *a1, unint64_t a2, unsigned char *a3, unint64_t a4)
{
  return SecBase64Encode_(a1, a2, a3, a4, 0, &v5);
}

unint64_t SecBase64Encode_(unsigned __int8 *a1, unint64_t a2, unsigned char *a3, unint64_t a4, unsigned int a5, _DWORD *a6)
{
  uint64_t v7 = a3;
  unint64_t v8 = a2;
  unint64_t v9 = (2 * (((a2 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  *a6 = 0;
  if (a5) {
    unint64_t v9 = v9 + 2 * ((v9 + a5 - 1) / a5) - 2;
  }
  if (a3)
  {
    if (v9 <= a4)
    {
      if (a2 >= 3)
      {
        uint64_t v10 = 0;
        do
        {
          id v11 = v7;
          unint64_t v12 = *a1;
          unint64_t v13 = v12 >> 2;
          unint64_t v14 = a1[1];
          unint64_t v15 = (v14 >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v12 & 3));
          unint64_t v16 = a1[2];
          unsigned char *v7 = b64_chars[v13];
          v7[1] = b64_chars[v15];
          _DWORD v7[2] = b64_chars[(v16 >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (v14 & 0xF))];
          v7 += 4;
          v11[3] = b64_chars[v16 & 0x3F];
          v10 += 4;
          if (v10 == a5 && v7 != &a3[a4])
          {
            uint64_t v10 = 0;
            *((_WORD *)v11 + 2) = 2573;
            uint64_t v7 = v11 + 6;
          }
          a1 += 3;
          v8 -= 3;
        }
        while (v8 > 2);
      }
      if (v8)
      {
        unint64_t v17 = 0;
        __int16 v20 = -21846;
        char v21 = -86;
        do
        {
          unint64_t v18 = v17;
          *((unsigned char *)&v20 + v17) = a1[v17];
          ++v17;
        }
        while (v8 != v17);
        if (v18 < 2) {
          bzero((char *)&v20 + v8, v8 ^ 3);
        }
        SecBase64Encode_(&v20, 3, v7, 12, 0, a6);
        memset(&v7[v8 + 1], 61, v8 ^ 3);
      }
    }
    else
    {
      unint64_t v9 = 0;
      *a6 = 1;
    }
  }
  return v9;
}

unint64_t SecBase64Encode2(unsigned __int8 *a1, unint64_t a2, unsigned char *a3, unint64_t a4, char a5, unsigned int a6, char *a7)
{
  if (a7) {
    unint64_t v8 = a7;
  }
  else {
    unint64_t v8 = &v12;
  }
  int v9 = a5 & 0xF;
  unsigned int v10 = 76;
  switch(v9)
  {
    case 0:
      unsigned int v10 = a6;
      if ((a6 & 0x80000000) == 0) {
        goto LABEL_9;
      }
      goto LABEL_6;
    case 1:
      unsigned int v10 = 0;
      goto LABEL_9;
    case 2:
LABEL_6:
      unsigned int v10 = 64;
      goto LABEL_9;
    case 3:
LABEL_9:
      unint64_t result = SecBase64Encode_(a1, a2, a3, a4, v10, v8);
      break;
    default:
      unint64_t result = 0;
      *(_DWORD *)unint64_t v8 = 3;
      break;
  }
  return result;
}

unsigned char *SecBase64Decode(unsigned __int8 *a1, unint64_t a2, unsigned char *a3, unint64_t a4)
{
  return SecBase64Decode_(a1, a2, a3, a4, 0, &v6, &v5);
}

unsigned char *SecBase64Decode_(unsigned __int8 *a1, unint64_t a2, unsigned char *a3, unint64_t a4, __int16 a5, unsigned __int8 **a6, _DWORD *a7)
{
  unint64_t v7 = a2 >> 2;
  if ((a2 & 3) != 0) {
    ++v7;
  }
  unint64_t v8 = 3 * v7;
  *a6 = 0;
  *a7 = 0;
  if (a3)
  {
    if (v8 > a4)
    {
      unint64_t v8 = 0;
      *a7 = 1;
      return (unsigned char *)v8;
    }
    int v15 = -1431655766;
    int v9 = a3;
    if (!a2) {
      return (unsigned char *)(v9 - a3);
    }
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    int v9 = a3;
    while (1)
    {
      unsigned int v12 = (char)*a1;
      if (v12 == 61)
      {
        *((unsigned char *)&v15 + v11) = 0;
        ++v10;
        goto LABEL_12;
      }
      int v13 = b64_indexes[*a1];
      if (v13 != 255)
      {
        uint64_t v10 = 0;
        *((unsigned char *)&v15 + v11) = v13;
LABEL_12:
        if (++v11 == 4)
        {
          *int v9 = (4 * v15) | (BYTE1(v15) >> 4) & 3;
          if (v10 == 2) {
            return (unsigned char *)(++v9 - a3);
          }
          v9[1] = (16 * BYTE1(v15)) | (BYTE2(v15) >> 2) & 0xF;
          if (v10 == 1)
          {
            v9 += 2;
            return (unsigned char *)(v9 - a3);
          }
          v9[2] = HIBYTE(v15) + (BYTE2(v15) << 6);
          if (v10)
          {
            v9 += 3;
            return (unsigned char *)(v9 - a3);
          }
          uint64_t v11 = 0;
          v9 += 3;
        }
        goto LABEL_23;
      }
      if (v12 <= 0x20)
      {
        if (((1 << v12) & 0x100000B00) != 0)
        {
          if ((a5 & 0x200) != 0) {
            goto LABEL_30;
          }
          goto LABEL_23;
        }
        if (((1 << v12) & 0x2400) != 0) {
          goto LABEL_23;
        }
      }
      if ((a5 & 0x100) != 0)
      {
LABEL_30:
        unint64_t v8 = 0;
        *a7 = 3;
        *a6 = a1;
        return (unsigned char *)v8;
      }
LABEL_23:
      ++a1;
      if (!--a2) {
        return (unsigned char *)(v9 - a3);
      }
    }
  }
  return (unsigned char *)v8;
}

unsigned char *SecBase64Decode2(unsigned __int8 *a1, unint64_t a2, unsigned char *a3, unint64_t a4, __int16 a5, unsigned __int8 **a6, char *a7)
{
  if (!a6) {
    a6 = (unsigned __int8 **)&v9;
  }
  if (!a7) {
    a7 = &v8;
  }
  return SecBase64Decode_(a1, a2, a3, a4, a5, a6, a7);
}

__CFString *SecCFAllocatorCopyDescription()
{
  return @"Custom CFAllocator for sensitive data that zeroizes on deallocate";
}

uint64_t SecCMSCreateEnvelopedData(void *a1, CFDictionaryRef theDict, const __CFData *a3, uint64_t a4)
{
  if (theDict && (Boolean Value = CFDictionaryGetValue(theDict, (const void *)kSecCMSBulkEncryptionAlgorithm)) != 0)
  {
    char v8 = Value;
    if (CFEqual((CFTypeRef)kSecCMSEncryptionAlgorithmDESCBC, Value))
    {
      int v9 = 64;
      unsigned int v10 = 10;
    }
    else
    {
      int v26 = CFEqual((CFTypeRef)kSecCMSEncryptionAlgorithmAESCBC, v8);
      if (v26) {
        unsigned int v10 = 184;
      }
      else {
        unsigned int v10 = 7;
      }
      if (v26) {
        int v9 = 128;
      }
      else {
        int v9 = 192;
      }
    }
  }
  else
  {
    int v9 = 192;
    unsigned int v10 = 7;
  }
  uint64_t v11 = SecCmsMessageCreate();
  if (!v11) {
    return 4294967246;
  }
  unsigned int v12 = (unint64_t *)v11;
  unint64_t v13 = SecCmsEnvelopedDataCreate(v11, v10, v9);
  if (!v13) {
    goto LABEL_22;
  }
  unint64_t v14 = (unint64_t *)v13;
  if (SecCmsContentInfoSetContent(v12, 0x1Bu, v13)
    || SecCmsContentInfoSetContentData(v14, 0, 0))
  {
    goto LABEL_22;
  }
  CFTypeID v15 = CFGetTypeID(a1);
  if (v15 == CFArrayGetTypeID())
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      CFIndex v19 = Count;
      CFIndex v20 = 0;
      do
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v20);
        if (!nss_cmsrecipientinfo_create((uint64_t)v14, 0, ValueAtIndex, 0)) {
          goto LABEL_22;
        }
      }
      while (v19 != ++v20);
    }
LABEL_18:
    CFIndex Length = 0;
    BytePtr = 0;
    if (a3)
    {
      CFIndex Length = CFDataGetLength(a3);
      BytePtr = CFDataGetBytePtr(a3);
      if (Length) {
        p_CFIndex Length = &Length;
      }
      else {
        p_CFIndex Length = 0;
      }
    }
    else
    {
      p_CFIndex Length = 0;
    }
    if (SecCmsMessageEncode((uint64_t *)v12, (uint64_t)p_Length, a4, v17, v18)) {
      uint64_t v24 = 4294967246;
    }
    else {
      uint64_t v24 = 0;
    }
    goto LABEL_27;
  }
  CFTypeID v22 = CFGetTypeID(a1);
  if (v22 == SecCertificateGetTypeID() && nss_cmsrecipientinfo_create((uint64_t)v14, 0, a1, 0)) {
    goto LABEL_18;
  }
LABEL_22:
  uint64_t v24 = 4294967246;
LABEL_27:
  SecCmsMessageDestroy((uint64_t)v12);
  return v24;
}

uint64_t SecCMSDecryptEnvelopedData(const __CFData *a1, __CFData *a2, void *a3)
{
  uint64_t v6 = MS_SecCMSDecryptEnvelopedData((uint64_t)a1, a2, a3);
  if (isMessageSecurityAllowedForCurrentBundleID_onceToken != -1) {
    dispatch_once(&isMessageSecurityAllowedForCurrentBundleID_onceToken, &__block_literal_global_3525);
  }
  if (!isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound || !v6) {
    return v6;
  }
  uint64_t v24 = 0;
  v23[0] = CFDataGetLength(a1);
  v23[1] = CFDataGetBytePtr(a1);
  int v8 = SecCmsMessageDecode((uint64_t)v23, 0, 0, v7, 0, 0, 0, &v24);
  uint64_t v9 = v24;
  if (v8)
  {
    uint64_t v6 = 4294941021;
    goto LABEL_35;
  }
  if (!v24) {
    return 4294967246;
  }
  uint64_t OID = *(void *)(v24 + 32);
  if (!OID)
  {
    uint64_t OID = SECOID_FindOID(v24);
    *(void *)(v9 + 32) = OID;
    if (!OID) {
      goto LABEL_14;
    }
  }
  if (*(_DWORD *)(OID + 16) != 27 || OID == 0) {
    goto LABEL_14;
  }
  uint64_t v12 = *(void *)(v9 + 16);
  if (!v12) {
    goto LABEL_14;
  }
  unint64_t v13 = *(uint64_t **)(v12 + 144);
  while (1)
  {
    uint64_t v14 = *v13;
    if (!*v13) {
      break;
    }
    CFTypeID v15 = *(const void **)(v14 + 144);
    ++v13;
    if (v15) {
      goto LABEL_21;
    }
  }
  CFTypeID v15 = 0;
LABEL_21:
  int v16 = 0;
  uint64_t ChildContentInfo = v9;
  do
  {
    ++v16;
    uint64_t ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo);
  }
  while (ChildContentInfo);
  if (v16 != 2) {
    goto LABEL_40;
  }
  uint64_t v18 = SecCmsContentInfoGetChildContentInfo(v9);
  if (!v18)
  {
LABEL_14:
    uint64_t v6 = 4294967246;
LABEL_36:
    SecCmsMessageDestroy(v9);
    return v6;
  }
  uint64_t v19 = v18;
  uint64_t v20 = *(void *)(v18 + 32);
  if (!v20 && (uint64_t v20 = SECOID_FindOID(v19), (*(void *)(v19 + 32) = v20) == 0) || *(_DWORD *)(v20 + 16) != 25)
  {
LABEL_40:
    uint64_t v6 = 4294967246;
    goto LABEL_35;
  }
  uint64_t InnerContent = SecCmsContentInfoGetInnerContent(v9);
  if (InnerContent) {
    CFDataAppendBytes(a2, *(const UInt8 **)(InnerContent + 8), *(void *)InnerContent);
  }
  if (a3)
  {
    if (v14) {
      CFRetain(v15);
    }
    uint64_t v6 = 0;
    *a3 = v15;
  }
  else
  {
    uint64_t v6 = 0;
  }
LABEL_35:
  if (v9) {
    goto LABEL_36;
  }
  return v6;
}

uint64_t SecCMSSignDataAndAttributes(uint64_t a1, const __CFData *a2, int a3, uint64_t a4, const __CFDictionary *a5)
{
  return SecCMSSignDataOrDigestAndAttributes(a1, a2, a3, 0, 4u, a4, a5, 2, 0);
}

uint64_t SecCMSSignDataOrDigestAndAttributes(uint64_t a1, const __CFData *a2, int a3, int a4, unsigned int a5, uint64_t a6, const __CFDictionary *a7, int a8, CFArrayRef theArray)
{
  if (!a3 && (a4 & 1) != 0) {
    return 4294967246;
  }
  uint64_t v17 = SecCmsMessageCreate();
  if (!v17) {
    return 4294967246;
  }
  uint64_t v18 = (unint64_t *)v17;
  unint64_t v19 = PORT_ArenaAlloc(*(void *)(v17 + 120), 0xB8uLL);
  if (!v19) {
    goto LABEL_28;
  }
  uint64_t v20 = (unint64_t *)v19;
  *(void *)(v19 + 176) = 0;
  *(_OWORD *)(v19 + 144) = 0u;
  *(_OWORD *)(v19 + 160) = 0u;
  *(_OWORD *)(v19 + 112) = 0u;
  *(_OWORD *)(v19 + 128) = 0u;
  *(_OWORD *)(v19 + 80) = 0u;
  *(_OWORD *)(v19 + 96) = 0u;
  *(_OWORD *)(v19 + 48) = 0u;
  *(_OWORD *)(v19 + 64) = 0u;
  *(_OWORD *)(v19 + 16) = 0u;
  *(_OWORD *)(v19 + 32) = 0u;
  *(_OWORD *)unint64_t v19 = 0u;
  *(void *)(v19 + 24) = v18;
  if (SecCmsContentInfoSetContent(v18, 0x1Au, v19)) {
    goto LABEL_28;
  }
  if (SecCmsContentInfoSetContentData(v20, 0, a3)) {
    goto LABEL_28;
  }
  uint64_t v21 = SecCmsSignerInfoCreate((uint64_t)v20, a1, a5);
  if (!v21) {
    goto LABEL_28;
  }
  CFTypeID v22 = (void *)v21;
  if (theArray)
  {
    if (SecCmsSignedDataAddCertList((uint64_t)v20, theArray)) {
      goto LABEL_28;
    }
  }
  if (SecCmsSignerInfoIncludeCerts((uint64_t)v22, a8)) {
    goto LABEL_28;
  }
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  if (SecCmsSignerInfoAddSigningTime((uint64_t)v22, Current)) {
    goto LABEL_28;
  }
  if (a7) {
    CFDictionaryApplyFunction(a7, (CFDictionaryApplierFunction)sign_all_attributes, v22);
  }
  CFIndex v32 = 0;
  BytePtr = 0;
  if (!a2)
  {
    CFIndex Length = 0;
    if (a4) {
      goto LABEL_16;
    }
LABEL_19:
    if (Length) {
      BOOL v29 = a2 == 0;
    }
    else {
      BOOL v29 = 1;
    }
    if (v29) {
      id v28 = 0;
    }
    else {
      id v28 = &v32;
    }
    id v27 = (uint64_t *)v18;
    goto LABEL_26;
  }
  CFIndex Length = CFDataGetLength(a2);
  CFIndex v32 = Length;
  BytePtr = CFDataGetBytePtr(a2);
  if (!a4) {
    goto LABEL_19;
  }
LABEL_16:
  if (SecCmsSignedDataSetDigestValue(v20, a5, (uint64_t)&v32))
  {
LABEL_28:
    uint64_t v30 = 4294967246;
    goto LABEL_29;
  }
  id v27 = (uint64_t *)v18;
  id v28 = 0;
LABEL_26:
  if (SecCmsMessageEncode(v27, (uint64_t)v28, a6, v24, v25)) {
    goto LABEL_28;
  }
  uint64_t v30 = 0;
LABEL_29:
  SecCmsMessageDestroy((uint64_t)v18);
  return v30;
}

uint64_t sign_all_attributes(const __CFData *a1, const __CFData *a2, uint64_t a3)
{
  v13[0] = CFDataGetLength(a1);
  v13[1] = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a2);
  v12[0] = Length;
  v12[1] = CFDataGetBytePtr(a2);
  uint64_t v7 = *(void *)(*(void *)(*(void *)(a3 + 128) + 24) + 120);
  uint64_t result = PORT_ArenaAlloc(v7, 0x28uLL);
  if (result)
  {
    uint64_t v9 = result;
    *(void *)(result + 32) = 0;
    *(_OWORD *)uint64_t result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    if (!SECITEM_CopyItem(v7, (unint64_t *)result, (uint64_t)v13))
    {
      unsigned int v10 = SECITEM_AllocItem(v7, 0, Length);
      if (v10)
      {
        uint64_t v11 = (uint64_t)v10;
        if (!SECITEM_CopyItem(v7, v10, (uint64_t)v12)
          && !SecCmsArrayAdd(v7, (char **)(v9 + 16), v11))
        {
          *(unsigned char *)(v9 + 32) = 1;
        }
      }
    }
    return SecCmsAttributeArrayAddAttr(v7, (uint64_t **)(a3 + 64), v9);
  }
  return result;
}

uint64_t SecCMSSignDigestAndAttributes(uint64_t a1, const __CFData *a2, uint64_t a3, const __CFDictionary *a4)
{
  return SecCMSSignDataOrDigestAndAttributes(a1, a2, 1, 1, 4u, a3, a4, 2, 0);
}

uint64_t SecCMSCreateSignedData(uint64_t a1, const __CFData *a2, CFDictionaryRef theDict, const __CFDictionary *a4, uint64_t a5)
{
  CFArrayRef theArray = theDict;
  if (!theDict)
  {
    BOOL v11 = 0;
    BOOL v10 = 0;
    unsigned int v19 = 4;
    IntBoolean Value = 2;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }
  BOOL v10 = CFDictionaryGetValueIfPresent(theDict, (const void *)kSecCMSSignDigest, 0) != 0;
  BOOL v11 = CFDictionaryGetValueIfPresent(theArray, (const void *)kSecCMSSignDetached, 0) != 0;
  Boolean Value = CFDictionaryGetValue(theArray, (const void *)kSecCMSSignHashAlgorithm);
  CFStringRef v13 = (const __CFString *)CFDictionaryGetValue(theArray, (const void *)kSecCMSCertChainMode);
  if (v13 && (CFStringRef v14 = v13, v15 = CFGetTypeID(v13), v15 == CFStringGetTypeID())) {
    IntBoolean Value = CFStringGetIntValue(v14);
  }
  else {
    IntBoolean Value = 2;
  }
  CFArrayRef v17 = (const __CFArray *)CFDictionaryGetValue(theArray, (const void *)kSecCMSAdditionalCerts);
  CFArrayRef theArray = v17;
  if (v17)
  {
    CFTypeID v18 = CFGetTypeID(v17);
    if (v18 != CFArrayGetTypeID()) {
      CFArrayRef theArray = 0;
    }
  }
  if (!Value || CFEqual((CFTypeRef)kSecCMSHashingAlgorithmSHA1, Value))
  {
    unsigned int v19 = 4;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }
  if (CFEqual((CFTypeRef)kSecCMSHashingAlgorithmSHA256, Value))
  {
    unsigned int v19 = 192;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }
  if (CFEqual((CFTypeRef)kSecCMSHashingAlgorithmSHA384, Value))
  {
    unsigned int v19 = 193;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }
  if (CFEqual((CFTypeRef)kSecCMSHashingAlgorithmSHA512, Value))
  {
    unsigned int v19 = 194;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }
  return 4294967246;
}

uint64_t certArrayIsSubset(const __CFArray *a1, CFArrayRef theArray)
{
  if (a1 == theArray) {
    return 1;
  }
  uint64_t result = 0;
  if (a1 && theArray)
  {
    CFIndex v5 = 0;
    do
    {
      CFIndex Count = CFArrayGetCount(theArray);
      BOOL v7 = v5 < Count;
      uint64_t result = v5 >= Count;
      if (!v7) {
        break;
      }
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v5);
      v9.size_t length = CFArrayGetCount(a1);
      v9.location = 0;
      uint64_t result = CFArrayContainsValue(a1, v9, ValueAtIndex);
      ++v5;
    }
    while (result);
  }
  return result;
}

uint64_t SecCMSVerify(const __CFData *a1, const __CFData *a2, void *a3, SecTrustRef *a4, uint64_t *a5)
{
  return SecCMSVerifySignedData_internal(a1, a2, a3, a4, 0, a5, 0);
}

uint64_t SecCMSDecodeSignedData(const __CFData *a1, uint64_t *a2, const __CFDictionary **a3)
{
  if (isMessageSecurityAllowedForCurrentBundleID_onceToken != -1) {
    dispatch_once(&isMessageSecurityAllowedForCurrentBundleID_onceToken, &__block_literal_global_3525);
  }
  if (isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound)
  {
    return SecCMSVerifySignedData_internal(a1, 0, 0, 0, 0, a2, a3);
  }
  else
  {
    return MS_SecCMSDecodeSignedData((uint64_t)a1, a2, (uint64_t)a3);
  }
}

CFArrayRef SecCMSCertificatesOnlyMessageCopyCertificates(uint64_t a1)
{
  CFDataRef Mutable = (const __CFData *)a1;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return Mutable;
  }
  CFArrayRef v2 = (const __CFArray *)MS_SecCMSCertificatesOnlyMessageCopyCertificates(a1);
  if (isMessageSecurityAllowedForCurrentBundleID_onceToken != -1) {
    dispatch_once(&isMessageSecurityAllowedForCurrentBundleID_onceToken, &__block_literal_global_3525);
  }
  if (!isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound) {
    return v2;
  }
  uint64_t v22 = 0;
  v21[0] = CFDataGetLength(Mutable);
  v21[1] = CFDataGetBytePtr(Mutable);
  int v4 = SecCmsMessageDecode((uint64_t)v21, 0, 0, v3, 0, 0, 0, &v22);
  uint64_t v5 = v22;
  if (!v4)
  {
    if (!v22) {
      goto LABEL_21;
    }
    uint64_t OID = *(void *)(v22 + 32);
    if ((OID || (uint64_t OID = SECOID_FindOID(v22), (*(void *)(v5 + 32) = OID) != 0))
      && (*(_DWORD *)(OID + 16) == 26 ? (BOOL v7 = OID == 0) : (BOOL v7 = 1),
          !v7 && (uint64_t v8 = *(void *)(v5 + 16)) != 0 && ((v9 = *(void **)(v8 + 160)) == 0 || !*v9)))
    {
      CFTypeID v15 = *(uint64_t **)(v8 + 144);
      CFDataRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      if (v15)
      {
        uint64_t v16 = *v15;
        if (*v15)
        {
          CFArrayRef v17 = v15 + 1;
          do
          {
            CFTypeID v18 = SecCertificateCreateWithBytes(0, *(const void **)(v16 + 8), *(void *)v16);
            if (v18)
            {
              unsigned int v19 = v18;
              CFArrayAppendValue(Mutable, v18);
              CFRelease(v19);
            }
            uint64_t v20 = *v17++;
            uint64_t v16 = v20;
          }
          while (v20);
          if (!v5) {
            goto LABEL_18;
          }
        }
      }
    }
    else
    {
      CFDataRef Mutable = 0;
    }
    goto LABEL_17;
  }
  CFDataRef Mutable = 0;
  if (v22) {
LABEL_17:
  }
    SecCmsMessageDestroy(v5);
LABEL_18:
  if (!Mutable || CFArrayGetCount(Mutable) > 0) {
    goto LABEL_22;
  }
  CFRelease(Mutable);
LABEL_21:
  CFDataRef Mutable = 0;
LABEL_22:
  if (Mutable != v2)
  {
    if (v2 && Mutable && (CFIndex Count = CFArrayGetCount(Mutable), Count == CFArrayGetCount(v2)))
    {
      CFIndex v11 = 0;
      while (v11 < CFArrayGetCount(Mutable))
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v11);
        v28.size_t length = CFArrayGetCount(v2);
        v28.location = 0;
        ++v11;
        if (!CFArrayContainsValue(v2, v28, ValueAtIndex)) {
          goto LABEL_29;
        }
      }
    }
    else
    {
LABEL_29:
      CFStringRef v13 = secLogObjForScope("SecWarning");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        CFDataRef v24 = Mutable;
        __int16 v25 = 2112;
        CFArrayRef v26 = v2;
        _os_log_impl(&dword_18B299000, v13, OS_LOG_TYPE_DEFAULT, "MessageSecurity and Security frameworks have different results, returning Security result. sec: %@, ms: %@", buf, 0x16u);
      }
    }
  }
  if (v2) {
    CFRelease(v2);
  }
  return Mutable;
}

CFMutableDataRef SecCMSCreateCertificatesOnlyMessage(void *a1)
{
  values = a1;
  if (!a1) {
    return 0;
  }
  uint64_t v2 = SecCmsMessageCreate();
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  uint64_t v4 = PORT_ArenaAlloc(*(void *)(v2 + 120), 0xB8uLL);
  CFMutableDataRef Mutable = (CFMutableDataRef)v4;
  if (v4)
  {
    *(void *)(v4 + 176) = 0;
    *(_OWORD *)(v4 + 144) = 0u;
    *(_OWORD *)(v4 + 160) = 0u;
    *(_OWORD *)(v4 + 112) = 0u;
    *(_OWORD *)(v4 + 128) = 0u;
    *(_OWORD *)(v4 + 80) = 0u;
    *(_OWORD *)(v4 + 96) = 0u;
    *(_OWORD *)(v4 + 48) = 0u;
    *(_OWORD *)(v4 + 64) = 0u;
    *(_OWORD *)(v4 + 16) = 0u;
    *(_OWORD *)(v4 + 32) = 0u;
    *(_OWORD *)uint64_t v4 = 0u;
    *(void *)(v4 + 24) = v3;
    if (!SecCmsContentInfoSetContentData((unint64_t *)v4, 0, 1)
      && !SecCmsContentInfoSetContent((unint64_t *)v3, 0x1Au, (unint64_t)Mutable)
      && SEC_ASN1EncodeInteger(*(void *)(v3 + 120), (void *)Mutable + 15, 1uLL))
    {
      CFTypeID v6 = CFGetTypeID(a1);
      if (v6 == SecCertificateGetTypeID())
      {
        CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFArrayRef Copy = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
        goto LABEL_11;
      }
      CFTypeID v9 = CFGetTypeID(a1);
      if (v9 == CFArrayGetTypeID())
      {
        CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFArrayRef Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFArrayRef)a1);
LABEL_11:
        CFArrayRef v10 = Copy;
        if (Copy)
        {
          CFIndex Count = CFArrayGetCount(Copy);
          if (Count >= 1)
          {
            uint64_t v12 = Count;
            uint64_t v13 = PORT_ArenaAlloc(*(void *)(v3 + 120), 8 * Count + 8);
            *((void *)Mutable + 18) = v13;
            if (v13)
            {
              CFIndex v14 = 0;
              while (1)
              {
                CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v10, v14);
                if (!ValueAtIndex) {
                  break;
                }
                uint64_t v16 = ValueAtIndex;
                CFArrayRef v17 = (void *)PORT_ArenaAlloc(*(void *)(v3 + 120), 0x10uLL);
                if (v17)
                {
                  void *v17 = 0;
                  v17[1] = 0;
                }
                *(void *)(*((void *)Mutable + 18) + 8 * v14) = v17;
                uint64_t v18 = v16[2];
                unsigned int v19 = *(void **)(*((void *)Mutable + 18) + 8 * v14);
                void *v19 = v16[3];
                v19[1] = v18;
                if (v12 == ++v14)
                {
                  *(void *)(*((void *)Mutable + 18) + 8 * v12) = 0;
                  if (v12 >= 2) {
                    SecCmsArraySort(*((void **)Mutable + 18), SecCmsUtilDERCompare, 0, 0);
                  }
                  CFMutableDataRef Mutable = CFDataCreateMutable(v7, 0);
                  CFIndex v21 = 0;
                  uint64_t v22 = 0;
                  if (SEC_ASN1EncodeItem(*(void *)(v3 + 120), &v21, v3, (uint64_t)&SecCmsMessageTemplate))
                  {
                    CFDataAppendBytes(Mutable, v22, v21);
                    goto LABEL_23;
                  }
                  CFRelease(v10);
                  CFArrayRef v10 = Mutable;
                  if (Mutable) {
                    goto LABEL_23;
                  }
                  goto LABEL_25;
                }
              }
            }
          }
          CFMutableDataRef Mutable = 0;
LABEL_23:
          CFRelease(v10);
          goto LABEL_25;
        }
      }
    }
    CFMutableDataRef Mutable = 0;
  }
LABEL_25:
  SecCmsMessageDestroy(v3);
  return Mutable;
}

__CFData *SecCMSCreateCertificatesOnlyMessageIAP(__SecCertificate *a1)
{
  CFDataRef v1 = SecCertificateCopyData(a1);
  if (!v1) {
    return 0;
  }
  CFDataRef v2 = v1;
  BytePtr = CFDataGetBytePtr(v1);
  CFIndex Length = CFDataGetLength(v2);
  if ((unint64_t)(Length - 0xFFFF) < 0xFFFFFFFFFFFF0101)
  {
    CFAllocatorRef v7 = 0;
  }
  else
  {
    CFIndex v5 = Length;
    CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    CFAllocatorRef v7 = Mutable;
    if (Mutable)
    {
      CFDataAppendBytes(Mutable, SecCMSCreateCertificatesOnlyMessageIAP_header, 45);
      CFDataAppendBytes(v7, BytePtr, v5);
      CFDataAppendBytes(v7, SecCMSCreateCertificatesOnlyMessageIAP_trailer, 4);
      MutableBytePtr = CFDataGetMutableBytePtr(v7);
      __int16 v9 = CFDataGetLength(v7);
      MutableBytePtr[2] = (unsigned __int16)(v9 - 4) >> 8;
      MutableBytePtr[3] = v9 - 4;
      MutableBytePtr[17] = (unsigned __int16)(v9 - 19) >> 8;
      MutableBytePtr[18] = v9 - 19;
      MutableBytePtr[21] = (unsigned __int16)(v9 - 23) >> 8;
      MutableBytePtr[22] = v9 - 23;
      MutableBytePtr[43] = (unsigned __int16)(v9 - 49) >> 8;
      MutableBytePtr[44] = v9 - 49;
    }
  }
  CFRelease(v2);
  return v7;
}

void sub_18B37C418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t SecCTKIsQueryForSystemKeychain(void *a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFDataRef v1 = [a1 objectForKey:@"u_SystemKeychain"];
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && [v1 BOOLValue])
  {
    if (SecIsEduMode_once != -1) {
      dispatch_once(&SecIsEduMode_once, &__block_literal_global_16081);
    }
    uint64_t v2 = SecIsEduMode_result;
    if (_SECKEY_LOG_once != -1) {
      dispatch_once(&_SECKEY_LOG_once, &__block_literal_global_8926);
    }
    uint64_t v3 = (id)_SECKEY_LOG_log;
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
    if (v2)
    {
      if (v4)
      {
        int v7 = 138543618;
        uint64_t v8 = @"u_SystemKeychain";
        __int16 v9 = 2114;
        CFArrayRef v10 = v1;
        CFIndex v5 = "Forcing CTK systemKey due to %{public}@=%{public}@ on shared iPad";
LABEL_15:
        _os_log_debug_impl(&dword_18B299000, v3, OS_LOG_TYPE_DEBUG, v5, (uint8_t *)&v7, 0x16u);
      }
    }
    else if (v4)
    {
      int v7 = 138543618;
      uint64_t v8 = @"u_SystemKeychain";
      __int16 v9 = 2114;
      CFArrayRef v10 = v1;
      CFIndex v5 = "%{public}@=%{public}@ detected, but not on shared iPad, ignoring this flag";
      goto LABEL_15;
    }

    goto LABEL_13;
  }
  uint64_t v2 = 0;
LABEL_13:

  return v2;
}

void *__getTKClientTokenParameterForceSystemSessionSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = CryptoTokenKitLibrary();
  uint64_t result = dlsym(v2, "TKClientTokenParameterForceSystemSession");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getTKClientTokenParameterForceSystemSessionSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *SecKeyCreateCTKKey(uint64_t a1, uint64_t a2, void *a3)
{
  CFIndex v5 = SecKeyCreate(a1, (uint64_t)&kSecCTKKeyDescriptor, 0, 0, 0);
  id v10 = 0;
  CFTypeID v6 = [[SecCTKKey alloc] initWithAttributes:a2 error:&v10];
  id v7 = v10;
  uint64_t v8 = v7;
  if (v6)
  {
    v5[3] = v6;
  }
  else
  {
    CFIndex v5 = 0;
    if (a3) {
      *a3 = v7;
    }
  }

  return v5;
}

uint64_t SecCTKKeySetParameter(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v37 = +[SecCTKKey fromKeyRef:a1];
  CFTypeID v6 = [v37 sessionParameters];
  id v7 = (void *)[v6 mutableCopy];

  [v7 setObject:a3 forKeyedSubscript:a2];
  id v8 = v7;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  __int16 v9 = (void *)[v8 copy];
  uint64_t v10 = [v9 countByEnumeratingWithState:&v40 objects:v46 count:16];
  if (v10)
  {
    uint64_t v11 = v10;
    id v12 = 0;
    uint64_t v13 = *(void *)v41;
    do
    {
      for (uint64_t i = 0; i != v11; ++i)
      {
        if (*(void *)v41 != v13) {
          objc_enumerationMutation(v9);
        }
        CFTypeID v15 = *(void **)(*((void *)&v40 + 1) + 8 * i);
        uint64_t v16 = [v8 objectForKeyedSubscript:v15];
        if ([v15 isEqual:@"u_AuthCtx"])
        {
          id v17 = v16;

          [v8 removeObjectForKey:v15];
          id v12 = v17;
        }
        if ([v15 isEqual:@"u_CredRef"])
        {
          if (LocalAuthenticationLibraryCore())
          {
            uint64_t v18 = [objc_alloc((Class)getLAContextClass()) initWithExternalizedContext:v16];

            id v12 = (id)v18;
          }
          [v8 removeObjectForKey:v15];
        }
        if ([v15 isEqual:@"u_OpPrompt"])
        {
          if (LocalAuthenticationLibraryCore())
          {
            if (!v12) {
              id v12 = objc_alloc_init((Class)getLAContextClass());
            }
            [v12 setLocalizedReason:v16];
          }
          [v8 removeObjectForKey:v15];
        }
        if (LocalAuthenticationLibraryCore() && [v15 isEqual:@"u_CallerName"])
        {
          if (LocalAuthenticationLibraryCore())
          {
            if (!v12) {
              id v12 = objc_alloc_init((Class)getLAContextClass());
            }
            [v12 setOptionCallerName:v16];
          }
          [v8 removeObjectForKey:v15];
        }
        if ([v15 isEqual:@"u_AuthUI"])
        {
          if (LocalAuthenticationLibraryCore())
          {
            if (!v12) {
              id v12 = objc_alloc_init((Class)getLAContextClass());
            }
            unsigned int v19 = objc_msgSend(NSNumber, "numberWithBool:", objc_msgSend(v16, "isEqual:", @"u_AuthUIF"));
            [v12 setOptionNotInteractive:v19];
          }
          [v8 removeObjectForKey:v15];
        }
      }
      uint64_t v11 = [v9 countByEnumeratingWithState:&v40 objects:v46 count:16];
    }
    while (v11);
  }
  else
  {
    id v12 = 0;
  }

  if (CryptoTokenKitLibraryCore())
  {
    id v20 = objc_alloc((Class)getTKClientTokenSessionClass());
    CFIndex v21 = v37;
    uint64_t v22 = [v37 tokenObject];
    long long v23 = [v22 session];
    CFDataRef v24 = [v23 token];
    id v39 = 0;
    __int16 v25 = (void *)[v20 initWithToken:v24 LAContext:v12 parameters:v8 error:&v39];
    id v26 = v39;

    uint64_t v27 = [v37 tokenObject];
    CFRange v28 = [v27 objectID];
    id v38 = v26;
    BOOL v29 = [v25 objectForObjectID:v28 error:&v38];
    id v30 = v38;

    if (v29)
    {
      [v37 setSessionParameters:v8];
      [v37 setTokenObject:v29];

      uint64_t v31 = 1;
      goto LABEL_42;
    }
  }
  else
  {
    CFIndex v32 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v33 = *MEMORY[0x1E4F28760];
    uint64_t v44 = *MEMORY[0x1E4F28228];
    char v45 = @"CryptoTokenKit is not available";
    uint64_t v34 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v45 forKeys:&v44 count:1];
    id v30 = [v32 errorWithDomain:v33 code:-4 userInfo:v34];

    CFIndex v21 = v37;
  }
  if (a4)
  {
    id v30 = v30;
    uint64_t v31 = 0;
    *a4 = v30;
  }
  else
  {
    uint64_t v31 = 0;
  }
LABEL_42:

  return v31;
}

void *SecCTKKeyCreateDuplicate(const void *a1)
{
  uint64_t v2 = +[SecCTKKey fromKeyRef:a1];
  CFAllocatorRef v3 = CFGetAllocator(a1);
  BOOL v4 = SecKeyCreate((uint64_t)v3, (uint64_t)&kSecCTKKeyDescriptor, 0, 0, 0);
  v4[3] = [v2 copy];

  return v4;
}

uint64_t SecCTKKeyIsEqual(uint64_t a1, uint64_t a2)
{
  CFAllocatorRef v3 = +[SecCTKKey fromKeyRef:a1];
  BOOL v4 = +[SecCTKKey fromKeyRef:a2];
  uint64_t v5 = [v3 isEqual:v4];

  return v5;
}

uint64_t SecCTKKeyCopyOperationResult(uint64_t a1, unint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, __CFString **a8)
{
  if (a2 < 7 && ((0x59u >> a2) & 1) != 0)
  {
    uint64_t v13 = qword_18B417338[a2];
    CFIndex v14 = +[SecCTKKey fromKeyRef:a1];
    CFTypeID v15 = [v14 tokenObject];
    uint64_t v16 = [v15 session];
    [v16 setAuthenticateWhenNeeded:1];

    id v17 = [v14 tokenObject];
    id v20 = 0;
    uint64_t v9 = [v17 operation:v13 data:a6 algorithms:a4 parameters:a7 error:&v20];
    id v18 = v20;

    if (a8 && !v9) {
      *a8 = (__CFString *)v18;
    }
  }
  else
  {
    SecError(-50, a8, @"Invalid key operation %d", a2);
    return 0;
  }
  return v9;
}

uint64_t SecCTKKeyCopyPublicOctets(uint64_t a1, uint64_t *a2)
{
  CFAllocatorRef v3 = +[SecCTKKey fromKeyRef:a1];
  BOOL v4 = [v3 tokenObject];
  *a2 = [v4 publicKey];

  return 0;
}

uint64_t SecCTKGetAlgorithmID(uint64_t a1)
{
  CFDataRef v1 = +[SecCTKKey fromKeyRef:a1];
  uint64_t v2 = [v1 algorithmID];

  return v2;
}

id SecCTKKeyCopyKeyDescription(uint64_t a1)
{
  uint64_t v2 = +[SecCTKKey fromKeyRef:a1];
  CFAllocatorRef v3 = [v2 keychainAttributes];
  uint64_t v4 = [v3 objectForKeyedSubscript:@"tkid"];
  uint64_t v5 = (void *)v4;
  CFTypeID v6 = @"uninited";
  if (v4) {
    CFTypeID v6 = (__CFString *)v4;
  }
  id v7 = v6;

  id v8 = [NSString stringWithFormat:@"<SecKeyRef:('%@') %p>", v7, a1];

  id v9 = v8;
  return v9;
}

uint64_t SecCTKKeyCopyAttributeDictionary(uint64_t a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (SecCTKKeyCopyAttributeDictionary_onceToken != -1) {
    dispatch_once(&SecCTKKeyCopyAttributeDictionary_onceToken, &__block_literal_global_82);
  }
  uint64_t v2 = +[SecCTKKey fromKeyRef:a1];
  id v3 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  id v4 = (id)SecCTKKeyCopyAttributeDictionary_exportableAttributes;
  uint64_t v5 = [v4 countByEnumeratingWithState:&v25 objects:v29 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v26;
    do
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v26 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v25 + 1) + 8 * i);
        uint64_t v10 = objc_msgSend(v2, "keychainAttributes", (void)v25);
        uint64_t v11 = [v10 objectForKeyedSubscript:v9];

        if (v11) {
          [v3 setObject:v11 forKeyedSubscript:v9];
        }
      }
      uint64_t v6 = [v4 countByEnumeratingWithState:&v25 objects:v29 count:16];
    }
    while (v6);
  }

  id v12 = [v2 tokenObject];
  uint64_t v13 = [v12 publicKey];

  CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  id v15 = v13;
  uint64_t v16 = SecSHA1DigestCreate(v14, [v15 bytes], objc_msgSend(v15, "length"));
  [v3 setObject:v16 forKeyedSubscript:@"klbl"];

  [v3 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:@"perm"];
  id v17 = [v2 tokenObject];
  id v18 = [v17 session];
  unsigned int v19 = [v18 token];
  id v20 = [v19 tokenID];
  [v3 setObject:v20 forKeyedSubscript:@"tkid"];

  CFIndex v21 = [v2 tokenObject];
  uint64_t v22 = [v21 objectID];
  [v3 setObject:v22 forKeyedSubscript:@"toid"];

  uint64_t v23 = [v3 copy];
  return v23;
}

void __SecCTKKeyCopyAttributeDictionary_block_invoke()
{
  v2[23] = *MEMORY[0x1E4F143B8];
  v2[0] = @"class";
  v2[1] = @"tkid";
  v2[2] = @"kcls";
  v2[3] = @"accc";
  v2[4] = @"priv";
  v2[5] = @"modi";
  v2[6] = @"type";
  v2[7] = @"bsiz";
  v2[8] = @"esiz";
  v2[9] = @"sens";
  v2[10] = @"asen";
  v2[11] = @"extr";
  v2[12] = @"next";
  v2[13] = @"encr";
  v2[14] = @"decr";
  v2[15] = @"drve";
  v2[16] = @"sign";
  v2[17] = @"vrfy";
  v2[18] = @"snrc";
  v2[19] = @"vyrc";
  v2[20] = @"wrap";
  v2[21] = @"unwp";
  v2[22] = @"u_SystemKeychain";
  uint64_t v0 = [MEMORY[0x1E4F1C978] arrayWithObjects:v2 count:23];
  CFDataRef v1 = (void *)SecCTKKeyCopyAttributeDictionary_exportableAttributes;
  SecCTKKeyCopyAttributeDictionary_exportableAttributes = v0;
}

uint64_t SecCTKKeyBlockSize(uint64_t a1)
{
  CFDataRef v1 = +[SecCTKKey fromKeyRef:a1];
  uint64_t v2 = [v1 keychainAttributes];
  id v3 = [v2 objectForKeyedSubscript:@"bsiz"];

  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v4 = [v3 integerValue];
    uint64_t v5 = v4 + 7;
    if (v4 < -7) {
      uint64_t v5 = v4 + 14;
    }
    uint64_t v6 = v5 >> 3;
  }
  else
  {
    uint64_t v6 = 0;
  }

  return v6;
}

void SecCTKKeyDestroy(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x18C12E850]();
}

void *SecKeyCopySystemKey(uint64_t a1, __CFString **a2)
{
  switch((int)a1)
  {
    case 0:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_sikObjectIDBytes;
      goto LABEL_5;
    case 1:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_gidObjectIDBytes;
LABEL_5:
      CFAllocatorRef v6 = v3;
      CFIndex v7 = 23;
      goto LABEL_21;
    case 2:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_uikCommittedObjectIDBytes;
      goto LABEL_20;
    case 3:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_uikProposedObjectIDBytes;
      goto LABEL_20;
    case 4:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFDataRef v15 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], SecKeyCopySystemKey_casdObjectIDBytes, 29);
      goto LABEL_22;
    case 5:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_oikCommittedObjectIDBytes;
      goto LABEL_20;
    case 6:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_oikProposedObjectIDBytes;
      goto LABEL_20;
    case 7:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_dakCommittedObjectIDBytes;
      goto LABEL_20;
    case 8:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_dakProposedObjectIDBytes;
      goto LABEL_20;
    case 9:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_havenCommittedObjectIDBytes;
      goto LABEL_15;
    case 10:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_havenProposedObjectIDBytes;
LABEL_15:
      CFAllocatorRef v6 = v3;
      CFIndex v7 = 26;
      goto LABEL_21;
    case 11:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_sdakCommittedObjectIDBytes;
      goto LABEL_18;
    case 12:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_sdakProposedObjectIDBytes;
LABEL_18:
      CFAllocatorRef v6 = v3;
      CFIndex v7 = 25;
      goto LABEL_21;
    case 13:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_dcikObjectIDBytes;
LABEL_20:
      CFAllocatorRef v6 = v3;
      CFIndex v7 = 24;
LABEL_21:
      CFDataRef v15 = CFDataCreate(v6, v4, v7);
LABEL_22:
      CFDictionaryRef v16 = CFDictionaryCreateForCFTypes(v3, v8, v9, v10, v11, v12, v13, v14, @"toid", (uint64_t)v15);
      if (SecCFAllocatorZeroize_sOnce != -1) {
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
      }
      CTKKey = SecKeyCreateCTKKey(SecCFAllocatorZeroize_sAllocator, (uint64_t)v16, a2);
      if (v16) {
        CFRelease(v16);
      }
      if (v15) {
        CFRelease(v15);
      }
      break;
    default:
      SecError(-50, a2, @"unexpected system key type %d", a1);
      CTKKey = 0;
      break;
  }
  return CTKKey;
}

uint64_t SecKeyCreateAttestation(uint64_t a1, uint64_t a2, __CFString **a3)
{
  CFAllocatorRef v6 = (void *)MEMORY[0x18C12E850]();
  CFIndex v7 = _os_activity_create(&dword_18B299000, "SecKeyCreateAttestation", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateAttestation");
  int v8 = +[SecCTKKey fromKeyRef:a1];
  int v9 = +[SecCTKKey fromKeyRef:a2];
  if (*(_UNKNOWN **)(a1 + 16) == &kSecCTKKeyDescriptor)
  {
    if (*(_UNKNOWN **)(a2 + 16) == &kSecCTKKeyDescriptor)
    {
      int v12 = [v8 tokenObject];
      int v13 = [v9 tokenObject];
      int v14 = [v8 sessionParameters];
      CFDataRef v15 = [v14 objectForKeyedSubscript:@"com.apple.security.seckey.setoken.attestation-nonce"];
      id v18 = 0;
      uint64_t v10 = [v12 attestKeyObject:v13 nonce:v15 error:&v18];
      id v17 = v18;

      id v16 = v17;
      _SecKeyErrorPropagate(v10 != 0, (uint64_t)"SecKeyCreateAttestation", v16, a3);

      goto LABEL_6;
    }
    SecError(-4, a3, @"attestation not supported for key %@", a2);
  }
  else
  {
    SecError(-4, a3, @"attestation not supported by key %@", a1);
  }
  uint64_t v10 = 0;
LABEL_6:

  os_activity_scope_leave(&state);
  return v10;
}

void sub_18B37D8F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_activity_scope_state_s state)
{
}

BOOL SecKeyControlLifetime(uint64_t a1, uint64_t a2, __CFString **a3)
{
  CFAllocatorRef v6 = (void *)MEMORY[0x18C12E850]();
  CFIndex v7 = _os_activity_create(&dword_18B299000, "SecKeyControlLifetime", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyControlLifetime");
  if (*(_UNKNOWN **)(a1 + 16) == &kSecCTKKeyDescriptor)
  {
    int v9 = +[SecCTKKey fromKeyRef:a1];
    uint64_t v10 = v9;
    if (a2)
    {
      if (a2 != 1)
      {
        BOOL v8 = SecError(-50, a3, @"Unsupported lifetime operation %d requested", a2);
        id v15 = 0;
        goto LABEL_9;
      }
      int v11 = [v9 tokenObject];
      uint64_t v17 = 0;
      int v12 = (id *)&v17;
      uint64_t v13 = [v11 commitKeyWithError:&v17];
    }
    else
    {
      int v11 = [v9 tokenObject];
      uint64_t v18 = 0;
      int v12 = (id *)&v18;
      uint64_t v13 = [v11 bumpKeyWithError:&v18];
    }
    BOOL v8 = v13;
    id v14 = *v12;

    id v15 = v14;
    _SecKeyErrorPropagate(v8, (uint64_t)"SecKeyControlLifetime", v15, a3);
LABEL_9:

    goto LABEL_10;
  }
  BOOL v8 = SecError(-4, a3, @"lifetimecontrol not supported for key %@", a1);
LABEL_10:
  os_activity_scope_leave(&state);

  return v8;
}

void sub_18B37DAC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_activity_scope_state_s state)
{
}

uint64_t SecCEPEscrowMarker()
{
  return 1;
}

uint64_t SecCEPEntrustVersInfo()
{
  return 1;
}

uint64_t SecCEPNetscapeCertType()
{
  return 1;
}

uint64_t SecCEPSubjectInfoAccess()
{
  return 1;
}

uint64_t SecCEPInhibitAnyPolicy(uint64_t a1, uint64_t a2)
{
  memset(v8, 170, sizeof(v8));
  if (DERDecodeItem(a2 + 24, v8)
    || v8[0] != 2
    || DERParseInteger((char **)&v8[1], (_DWORD *)(a1 + 380)))
  {
    *(unsigned char *)(a1 + 376) = 0;
    uint64_t v5 = secLogObjForScope("SecWarning");
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v6)
    {
      *(_WORD *)CFIndex v7 = 0;
      _os_log_impl(&dword_18B299000, v5, OS_LOG_TYPE_DEFAULT, "Invalid InhibitAnyPolicy Extension", v7, 2u);
      return 0;
    }
  }
  else
  {
    uint64_t result = 1;
    *(unsigned char *)(a1 + 376) = 1;
    *(unsigned char *)(a1 + 377) = *(unsigned char *)(a2 + 16);
  }
  return result;
}

uint64_t SecCEPPolicyConstraints(uint64_t a1, uint64_t a2)
{
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v9 = v4;
  long long v10 = v4;
  if (DERParseSequence(a2 + 24, (unsigned __int16)DERNumPolicyConstraintsItemSpecs, (uint64_t)&DERPolicyConstraintsItemSpecs, (unint64_t)&v9, 0x20uLL))goto LABEL_10; {
  if (*((void *)&v9 + 1))
  }
  {
    if (DERParseInteger((char **)&v9, (_DWORD *)(a1 + 312))) {
      goto LABEL_10;
    }
    *(unsigned char *)(a1 + 310) = 1;
  }
  if (!*((void *)&v10 + 1))
  {
LABEL_8:
    uint64_t result = 1;
    *(unsigned char *)(a1 + 308) = 1;
    *(unsigned char *)(a1 + 309) = *(unsigned char *)(a2 + 16);
    return result;
  }
  if (!DERParseInteger((char **)&v10, (_DWORD *)(a1 + 320)))
  {
    *(unsigned char *)(a1 + 316) = 1;
    goto LABEL_8;
  }
LABEL_10:
  *(unsigned char *)(a1 + 308) = 0;
  BOOL v6 = secLogObjForScope("SecWarning");
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v7)
  {
    *(_WORD *)BOOL v8 = 0;
    _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "Invalid PolicyConstraints Extension", v8, 2u);
    return 0;
  }
  return result;
}

uint64_t SecCEPPolicyMappings(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2 + 24;
  memset(v18, 170, sizeof(v18));
  if (DERDecodeSeqInit(a2 + 24, &v18[2], v18) || v18[2] != 0x2000000000000010) {
    goto LABEL_10;
  }
  unint64_t v5 = 0;
  memset(v17, 170, sizeof(v17));
  while (1)
  {
    int v6 = DERDecodeSeqNext(v18, v17);
    if (v6) {
      break;
    }
    if (v17[0] != 0x2000000000000010 || v5++ >= 0x1FFF) {
      goto LABEL_10;
    }
  }
  if (!v5) {
    goto LABEL_10;
  }
  if (v6 != 1) {
    goto LABEL_10;
  }
  id v14 = malloc_type_malloc(32 * v5, 0x1010040E633A1C4uLL);
  if (!v14) {
    goto LABEL_10;
  }
  if (DERDecodeSeqInit(v4, &v18[2], v18))
  {
LABEL_23:
    free(v14);
LABEL_10:
    *(unsigned char *)(a1 + 328) = 0;
    BOOL v8 = secLogObjForScope("SecWarning");
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v9)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEFAULT, "Invalid PolicyMappings Extension", buf, 2u);
      return 0;
    }
    return result;
  }
  int v11 = v14 + 1;
  unint64_t v12 = v5;
  do
  {
    if (DERDecodeSeqNext(v18, v17)) {
      break;
    }
    if (v17[0] != 0x2000000000000010) {
      goto LABEL_23;
    }
    *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)long long buf = v13;
    long long v16 = v13;
    if (DERParseSequenceContent(&v17[1], (unsigned __int16)DERNumPolicyMappingItemSpecs, (uint64_t)&DERPolicyMappingItemSpecs, (unint64_t)buf, 0x20uLL))goto LABEL_23; {
    *(v11 - 1) = *(_OWORD *)buf;
    }
    *int v11 = v16;
    v11 += 2;
    --v12;
  }
  while (v12);
  uint64_t result = 1;
  *(unsigned char *)(a1 + 328) = 1;
  *(unsigned char *)(a1 + 329) = *(unsigned char *)(a2 + 16);
  *(void *)(a1 + 336) = v5;
  *(void *)(a1 + 344) = v14;
  return result;
}

uint64_t SecCEPNameConstraints(uint64_t a1, uint64_t a2)
{
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v8 = v3;
  long long v9 = v3;
  if (!DERParseSequence(a2 + 24, (unsigned __int16)DERNumNameConstraintsItemSpecs, (uint64_t)&DERNameConstraintsItemSpecs, (unint64_t)&v8, 0x20uLL)&& (!*((void *)&v8 + 1) || !parseGeneralSubtrees((unint64_t *)&v8, (CFTypeRef *)(a1 + 488)))&& (!*((void *)&v9 + 1) || !parseGeneralSubtrees((unint64_t *)&v9, (CFTypeRef *)(a1 + 496))))
  {
    return 1;
  }
  unint64_t v5 = secLogObjForScope("SecWarning");
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v6)
  {
    *(_WORD *)BOOL v7 = 0;
    _os_log_impl(&dword_18B299000, v5, OS_LOG_TYPE_DEFAULT, "Invalid Name Constraints extension", v7, 2u);
    return 0;
  }
  return result;
}

CFDataRef parseGeneralSubtrees(unint64_t *a1, CFTypeRef *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  v18[0] = 0xAAAAAAAAAAAAAAAALL;
  v18[1] = 0xAAAAAAAAAAAAAAAALL;
  long long v3 = DERDecodeSeqContentInit(a1, v18);
  if (v3) {
    return (CFDataRef)v3;
  }
  memset(v17, 170, sizeof(v17));
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (!Mutable) {
    return 0;
  }
  CFMutableArrayRef v6 = Mutable;
  for (int i = 0x2000; ; --i)
  {
    uint64_t v8 = DERDecodeSeqNext(v18, v17);
    if (v8 == 1) {
      goto LABEL_18;
    }
    CFDataRef v9 = (CFDataRef)v8;
    if (v8) {
      goto LABEL_23;
    }
    *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v15 = v10;
    long long v16 = v10;
    *(_OWORD *)UInt8 bytes = v10;
    if (v17[0] != 0x2000000000000010)
    {
LABEL_22:
      CFDataRef v9 = 0;
LABEL_23:
      CFRelease(v6);
      return v9;
    }
    int v11 = DERParseSequenceContent(&v17[1], (unsigned __int16)DERNumGeneralSubtreeItemSpecs, (uint64_t)&DERGeneralSubtreeItemSpecs, (unint64_t)bytes, 0x30uLL);
    if (v11)
    {
      CFDataRef v9 = (CFDataRef)v11;
      goto LABEL_23;
    }
    if (*((void *)&v15 + 1))
    {
      *(_DWORD *)long long buf = -1431655766;
      if (DERParseInteger((char **)&v15, buf) || *(_DWORD *)buf) {
        goto LABEL_22;
      }
    }
    if (*((void *)&v16 + 1) || (unint64_t)(bytes[1] - 0x7FFFFFFFFFFFFFFFLL) < 0x8000000000000002) {
      goto LABEL_22;
    }
    CFDataRef v9 = CFDataCreate(v4, bytes[0], (CFIndex)bytes[1]);
    if (!v9) {
      goto LABEL_23;
    }
    CFArrayAppendValue(v6, v9);
    CFRelease(v9);
    if (!i) {
      break;
    }
  }
  unint64_t v12 = secLogObjForScope("SecWarning");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    int v20 = 0x2000;
    _os_log_impl(&dword_18B299000, v12, OS_LOG_TYPE_DEFAULT, "Skipping subtrees after the first %d", buf, 8u);
  }
LABEL_18:
  if (*a2) {
    CFRelease(*a2);
  }
  CFDataRef v9 = 0;
  *a2 = v6;
  return v9;
}

uint64_t SecCEPIssuerAltName()
{
  return 1;
}

uint64_t SecCEPPrivateKeyUsagePeriod()
{
  return 1;
}

CFStringRef SecCertificateCopyDescription(__SecCertificate *a1)
{
  CFStringRef v2 = SecCertificateCopySubjectSummary(a1);
  CFTypeRef v3 = SecCertificateCopyIssuerSummary((uint64_t)a1);
  CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<cert(%p) s: %@ i: %@>", a1, v2, v3);
  if (v3) {
    CFRelease(v3);
  }
  if (v2) {
    CFRelease(v2);
  }
  return v4;
}

CFStringRef SecCertificateCopySubjectSummary(CFStringRef certificate)
{
  if (certificate)
  {
    CFStringRef v1 = certificate;
    uint64_t v8 = 0;
    CFTypeRef cf = 0;
    CFTypeRef v10 = 0;
    int v2 = parseX501NameContent((unint64_t *)&certificate[5].length, (uint64_t)&v8, (uint64_t (*)(uint64_t, long long *, long long *, uint64_t, uint64_t))obtainSummaryFromX501Name, 1);
    certificate = 0;
    if (!v2)
    {
      CFTypeRef v3 = v10;
      if (v10)
      {
        if (v8 == 4)
        {
          CFStringRef v4 = SecFrameworkCopyLocalizedString(@"%@ (%@)", @"Certificate");
          CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v4, cf, v10);
          CFRelease(v4);
          CFRelease(cf);
          CFTypeRef cf = v5;
          CFTypeRef v3 = v10;
        }
        CFRelease(v3);
      }
      if (v8 != 4)
      {
        CFArrayRef v6 = SecCertificateCopyRFC822Names((uint64_t)v1);
        if (v6 || (CFArrayRef v6 = SecCertificateCopyDNSNames((uint64_t)v1)) != 0)
        {
          CFTypeRef v7 = cf;
          if (cf)
          {
            CFTypeRef cf = 0;
            CFRelease(v7);
          }
          CFTypeRef cf = CFArrayGetValueAtIndex(v6, 0);
          CFRetain(cf);
          CFRelease(v6);
        }
      }
      return (CFStringRef)cf;
    }
  }
  return certificate;
}

__CFString *copyHexDescription(const __CFAllocator *a1, unsigned __int8 **a2)
{
  unint64_t v2 = (unint64_t)a2[1];
  if (v2 > 0x2AAAAAAAAAAAAAA9) {
    return 0;
  }
  CFMutableArrayRef Mutable = CFStringCreateMutable(a1, 3 * v2 - 1);
  if (v2)
  {
    for (uint64_t i = 0; i != v2; ++i)
    {
      if (i) {
        CFStringAppendFormat(Mutable, 0, @" %02X", (*a2)[i]);
      }
      else {
        CFStringAppendFormat(Mutable, 0, @"%02X", **a2);
      }
    }
  }
  return Mutable;
}

__CFString *copyIntegerContentDescription(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if ((unint64_t)(v2 - 9) >= 0xFFFFFFFFFFFFFFF8)
  {
    unint64_t v4 = 0;
    CFStringRef v5 = *(unsigned __int8 **)a2;
    do
    {
      unsigned int v6 = *v5++;
      unint64_t v4 = v6 | (v4 << 8);
      --v2;
    }
    while (v2);
    return (__CFString *)CFStringCreateWithFormat(a1, 0, @"%llu", v4);
  }
  else
  {
    return copyHexDescription(a1, (unsigned __int8 **)a2);
  }
}

CFStringRef copyBlobString(const __CFAllocator *a1, const __CFString *cf, const __CFString *a3, uint64_t a4, char a5)
{
  CFStringRef v7 = cf;
  if (a5)
  {
    CFStringRef v7 = SecFrameworkCopyLocalizedString(cf, @"Certificate");
    a3 = SecFrameworkCopyLocalizedString(a3, @"Certificate");
    CFStringRef v9 = SecFrameworkCopyLocalizedString(@"%@; %d %@; data = %@", @"Certificate");
  }
  else
  {
    if (cf) {
      CFRetain(cf);
    }
    if (a3) {
      CFRetain(a3);
    }
    CFStringRef v9 = @"%@; %d %@; data = %@";
  }
  CFTypeRef v10 = copyHexDescription(a1, (unsigned __int8 **)a4);
  CFStringRef v11 = CFStringCreateWithFormat(a1, 0, v9, v7, *(void *)(a4 + 8), a3, v10);
  CFRelease(v10);
  CFRelease(v9);
  if (a3) {
    CFRelease(a3);
  }
  if (v7) {
    CFRelease(v7);
  }
  return v11;
}

CFStringRef copyOidDescription(const __CFAllocator *a1, uint64_t a2, int a3)
{
  if (a2 && *(void *)(a2 + 8))
  {
    CFStringRef v6 = SecDERItemCopyOIDDecimalRepresentation(a1, (unsigned __int8 **)a2);
    if (!a3) {
      return v6;
    }
    unint64_t v7 = *(void *)(a2 + 8);
    if (v7 > 0x2AAAAAAAAAAAAAA5) {
      return v6;
    }
    CFMutableStringRef Mutable = CFStringCreateMutable(a1, 3 * v7 + 5);
    CFStringAppendFormat(Mutable, 0, @"06 %02lX", *(void *)(a2 + 8));
    if (*(void *)(a2 + 8))
    {
      unint64_t v9 = 0;
      do
        CFStringAppendFormat(Mutable, 0, @" %02X", *(unsigned __int8 *)(*(void *)a2 + v9++));
      while (v9 < *(void *)(a2 + 8));
    }
    CFStringRef v10 = SecFrameworkCopyLocalizedString(Mutable, @"OID");
    if (v10)
    {
      CFStringRef v11 = v10;
      if (CFEqual(Mutable, v10))
      {
        CFStringRef v12 = v11;
        CFStringRef v11 = v6;
LABEL_18:
        CFRelease(v12);
        goto LABEL_19;
      }
      CFStringRef v12 = v6;
      if (v6) {
        goto LABEL_18;
      }
    }
    else
    {
      CFStringRef v11 = v6;
    }
LABEL_19:
    CFRelease(Mutable);
    return v11;
  }
  if (!a3) {
    return @"<NULL>";
  }

  return SecFrameworkCopyLocalizedString(@"<NULL>", @"Certificate");
}

uint64_t appendRFC822NamesFromGeneralNames(__CFArray *a1, int a2, uint64_t a3)
{
  if (a2 != 1) {
    return 0;
  }
  if ((*(void *)(a3 + 8) & 0x8000000000000000) != 0) {
    return 4294941021;
  }
  CFStringRef v4 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(const UInt8 **)a3, *(void *)(a3 + 8), 0x600u, 0);
  if (!v4) {
    return 4294941021;
  }
  CFStringRef v5 = v4;
  CFArrayAppendValue(a1, v4);
  CFRelease(v5);
  return 0;
}

SecCertificateRef SecCertificateCreateWithKeychainItem(const __CFAllocator *a1, const __CFData *a2, const void *a3)
{
  SecCertificateRef v4 = SecCertificateCreateWithData(a1, a2);
  if (v4)
  {
    if (a3) {
      CFRetain(a3);
    }
    *((void *)v4 + 77) = a3;
  }
  return v4;
}

uint64_t SecCertificateSetKeychainItem(uint64_t a1, CFTypeRef cf)
{
  if (!a1) {
    return 4294967246;
  }
  if (cf) {
    CFRetain(cf);
  }
  SecCertificateRef v4 = *(const void **)(a1 + 616);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t result = 0;
  *(void *)(a1 + 616) = cf;
  return result;
}

void appendProperty(void *cf, void *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, char a6)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    if (a6)
    {
      if (a4)
      {
        CFStringRef v10 = 0;
      }
      else
      {
        CFStringRef v10 = SecFrameworkCopyLocalizedString(a3, @"Certificate");
        a4 = v10;
      }
    }
    else
    {
      CFRetain(a3);
      CFStringRef v10 = a3;
      a4 = a3;
    }
    keys = @"type";
    int v20 = @"label";
    uint64_t v21 = @"localized label";
    uint64_t v22 = @"value";
    values = a2;
    CFStringRef v16 = a3;
    CFStringRef v17 = a4;
    CFStringRef v18 = a5;
    CFAllocatorRef v13 = CFGetAllocator(cf);
    if (a5) {
      CFIndex v14 = 4;
    }
    else {
      CFIndex v14 = 3;
    }
    CFDictionaryRef v12 = CFDictionaryCreate(v13, (const void **)&keys, (const void **)&values, v14, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v10) {
      CFRelease(v10);
    }
  }
  else
  {
    keys = @"type";
    int v20 = @"value";
    values = a2;
    CFStringRef v16 = a5;
    CFAllocatorRef v11 = CFGetAllocator(cf);
    CFDictionaryRef v12 = CFDictionaryCreate(v11, (const void **)&keys, (const void **)&values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  CFArrayAppendValue((CFMutableArrayRef)cf, v12);
  CFRelease(v12);
}

double SecAbsoluteTimeFromDateContent(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  return SecAbsoluteTimeFromDateContentWithError(a1, a2, a3, 0);
}

CFDateRef SecCertificateCopyNotValidBeforeDate(CFDateRef result)
{
  if (result) {
    return CFDateCreate(0, *((CFAbsoluteTime *)result + 21));
  }
  return result;
}

CFDateRef SecCertificateCopyNotValidAfterDate(CFDateRef result)
{
  if (result) {
    return CFDateCreate(0, *((CFAbsoluteTime *)result + 22));
  }
  return result;
}

CFMutableArrayRef SecCertificateCopySummaryProperties(double *a1, double a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v4, 0, MEMORY[0x1E4F1D510]);
  CFStringRef v6 = SecCertificateCopySubjectSummary((SecCertificateRef)a1);
  if (v6)
  {
    CFStringRef v7 = v6;
    appendProperty(Mutable, @"title", 0, 0, v6, 1);
    CFRelease(v7);
  }
  double v8 = a1[22];
  if (v8 >= a2)
  {
    double v12 = a1[21];
    if (v12 <= a2) {
      CFStringRef v11 = @"Expires";
    }
    else {
      CFStringRef v11 = @"Valid from";
    }
    if (v12 <= a2)
    {
      CFStringRef v10 = @"This certificate is valid";
    }
    else
    {
      double v8 = a1[21];
      CFStringRef v10 = @"This certificate is not yet valid";
    }
    if (v12 <= a2) {
      unint64_t v9 = @"success";
    }
    else {
      unint64_t v9 = @"error";
    }
  }
  else
  {
    unint64_t v9 = @"error";
    CFStringRef v10 = @"This certificate has expired";
    CFStringRef v11 = @"Expired";
  }
  appendDateProperty(Mutable, v11, 1, v8);
  CFStringRef v13 = SecFrameworkCopyLocalizedString(v10, @"Certificate");
  appendProperty(Mutable, v9, 0, 0, v13, 1);
  CFRelease(v13);
  return Mutable;
}

void appendDateProperty(void *a1, const __CFString *a2, char a3, CFAbsoluteTime a4)
{
  CFAllocatorRef v8 = CFGetAllocator(a1);
  CFStringRef v9 = (const __CFString *)CFDateCreate(v8, a4);
  appendProperty(a1, @"date", a2, 0, v9, a3);

  CFRelease(v9);
}

CFMutableArrayRef SecCertificateCopyLegacyProperties(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
  PropertiesForX501NameContent = createPropertiesForX501NameContent(v2, (unint64_t *)(a1 + 184), 0);
  appendProperty(Mutable, @"section", @"Subject Name", 0, (const __CFString *)PropertiesForX501NameContent, 0);
  CFRelease(PropertiesForX501NameContent);
  CFStringRef v5 = createPropertiesForX501NameContent(v2, (unint64_t *)(a1 + 152), 0);
  appendProperty(Mutable, @"section", @"Issuer Name", 0, (const __CFString *)v5, 0);
  CFRelease(v5);
  CFStringRef v6 = CFStringCreateWithFormat(v2, 0, @"%d", *(unsigned __int8 *)(a1 + 96) + 1);
  appendProperty(Mutable, @"string", @"Version", 0, v6, 0);
  CFRelease(v6);
  if (*(void *)(a1 + 112)) {
    appendIntegerProperty(Mutable, @"Serial Number", a1 + 104, 0);
  }
  appendAlgorithmProperty(Mutable, @"Signature Algorithm", a1 + 120, 0);
  appendDateProperty(Mutable, @"Not Valid Before", 0, *(CFAbsoluteTime *)(a1 + 168));
  appendDateProperty(Mutable, @"Not Valid After", 0, *(CFAbsoluteTime *)(a1 + 176));
  if (*(void *)(a1 + 288)) {
    appendDataProperty(Mutable, @"Subject Unique ID", 0, a1 + 280, 0);
  }
  if (*(void *)(a1 + 272)) {
    appendDataProperty(Mutable, @"Issuer Unique ID", 0, a1 + 264, 0);
  }
  appendAlgorithmProperty(Mutable, @"Public Key Algorithm", a1 + 216, 0);
  appendDataProperty(Mutable, @"Public Key Data", 0, a1 + 248, 0);
  appendDataProperty(Mutable, @"Signature", 0, a1 + 80, 0);
  if (*(uint64_t *)(a1 + 512) >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    do
    {
      appendExtension(Mutable, *(void *)(a1 + 520) + v7, 0);
      ++v8;
      v7 += 40;
    }
    while (v8 < *(void *)(a1 + 512));
  }
  appendFingerprintsProperty(Mutable, (__CFData *)a1, 0);
  return Mutable;
}

__CFArray *createPropertiesForX501NameContent(const __CFAllocator *a1, unint64_t *a2, uint64_t a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
  if (parseX501NameContent(a2, (uint64_t)Mutable, (uint64_t (*)(uint64_t, long long *, long long *, uint64_t, uint64_t))appendRDNProperty, a3))
  {
    CFArrayRemoveAllValues(Mutable);
    appendRelabeledProperty(Mutable, @"X.501 Name", 0, (uint64_t)a2, @"Invalid %@", a3);
  }
  return Mutable;
}

void appendIntegerProperty(void *a1, const __CFString *a2, uint64_t a3, char a4)
{
  CFAllocatorRef v8 = CFGetAllocator(a1);
  CFStringRef v9 = copyIntegerContentDescription(v8, a3);
  appendProperty(a1, @"string", a2, 0, v9, a4);

  CFRelease(v9);
}

void appendAlgorithmProperty(void *a1, const __CFString *a2, uint64_t a3, int a4)
{
  CFAllocatorRef v8 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = (__CFString *)CFArrayCreateMutable(v8, 0, MEMORY[0x1E4F1D510]);
  appendOIDProperty(Mutable, @"Algorithm", 0, a3, a4);
  uint64_t v10 = *(void *)(a3 + 24);
  if (v10)
  {
    uint64_t v11 = a3 + 16;
    if (v10 == 2 && **(unsigned char **)v11 == 5 && !*(unsigned char *)(*(void *)v11 + 1))
    {
      CFStringRef v12 = SecFrameworkCopyLocalizedString(@"none", @"Certificate");
      appendProperty(Mutable, @"string", @"Parameters", 0, v12, a4);
      CFRelease(v12);
    }
    else
    {
      appendRelabeledProperty(Mutable, @"Parameters", 0, v11, @"Unparsed %@", a4);
    }
  }
  appendProperty(a1, @"section", a2, 0, Mutable, a4);

  CFRelease(Mutable);
}

void appendDataProperty(void *a1, const __CFString *a2, const __CFString *a3, uint64_t a4, char a5)
{
  if ((*(void *)(a4 + 8) & 0x8000000000000000) == 0)
  {
    CFAllocatorRef v10 = CFGetAllocator(a1);
    CFStringRef v11 = (const __CFString *)CFDataCreate(v10, *(const UInt8 **)a4, *(void *)(a4 + 8));
    appendProperty(a1, @"data", a2, a3, v11, a5);
    CFRelease(v11);
  }
}

void appendExtension(void *a1, uint64_t a2, uint64_t a3)
{
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = (__CFString *)CFArrayCreateMutable(v6, 0, MEMORY[0x1E4F1D510]);
  appendBoolProperty(Mutable, @"Critical", *(unsigned __int8 *)(a2 + 16), a3);
  uint64_t v8 = *(void *)(a2 + 8);
  if (v8 == 3 && (CFStringRef v9 = *(unsigned char **)a2, !memcmp(*(const void **)a2, &_oidSubjectKeyIdentifier, 2uLL)))
  {
    switch(v9[2])
    {
      case 0xE:
        appendSubjectKeyIdentifier(Mutable, a2 + 24, a3);
        break;
      case 0xF:
        CFStringRef v11 = appendKeyUsage_usageNames;
        CFStringRef v12 = Mutable;
        uint64_t v13 = a2 + 24;
        unsigned __int16 v14 = 9;
        goto LABEL_7;
      case 0x10:
        appendPrivateKeyUsagePeriod(Mutable, a2 + 24, a3);
        break;
      case 0x11:
      case 0x12:
        appendGeneralNames(Mutable, a2 + 24, a3);
        break;
      case 0x13:
        appendBasicConstraints(Mutable, a2 + 24, a3);
        break;
      case 0x1E:
        appendNameConstraints(Mutable, a2 + 24, a3);
        break;
      case 0x1F:
        appendCrlDistributionPoints(Mutable, a2 + 24, a3);
        break;
      case 0x20:
        appendCertificatePolicies(Mutable, a2 + 24, a3);
        break;
      case 0x23:
        appendAuthorityKeyIdentifier(Mutable, a2 + 24, a3);
        break;
      case 0x24:
        appendPolicyConstraints(Mutable, a2 + 24, a3);
        break;
      case 0x25:
        appendExtendedKeyUsage(Mutable, a2 + 24, a3);
        break;
      default:
        goto LABEL_13;
    }
  }
  else
  {
    if (v8 == 8 && (CFAllocatorRef v10 = *(unsigned __int8 **)a2, !memcmp(*(const void **)a2, &_oidAuthorityInfoAccess, 7uLL)))
    {
      int v15 = v10[7];
      if (v15 == 11 || v15 == 1)
      {
        appendInfoAccess(Mutable, a2 + 24, a3);
        goto LABEL_26;
      }
    }
    else if (DEROidCompare(a2, (uint64_t)&oidNetscapeCertType))
    {
      CFStringRef v11 = appendNetscapeCertType_certTypes;
      CFStringRef v12 = Mutable;
      uint64_t v13 = a2 + 24;
      unsigned __int16 v14 = 8;
LABEL_7:
      appendBitStringNames(v12, v13, (const __CFString **)v11, v14, a3);
      goto LABEL_26;
    }
LABEL_13:
    memset(v25, 170, sizeof(v25));
    if (DERDecodeSeqInit(a2 + 24, &v25[2], v25) || v25[2] != 0x2000000000000010) {
      goto LABEL_25;
    }
    char v16 = 0;
    memset(v24, 170, sizeof(v24));
    while (1)
    {
      int v17 = DERDecodeSeqNext(v25, (unint64_t *)v24);
      if (v17) {
        break;
      }
      if (*(void *)v24 <= 0x1CuLL && ((1 << SLOBYTE(v24[0])) & 0x1E7C1000) != 0)
      {
        CFAllocatorRef v19 = CFGetAllocator(Mutable);
        int v20 = copyDERThingContentDescription(v19, *(uint64_t *)v24, (uint64_t)&v24[2], a3);
        if (!v20) {
          goto LABEL_25;
        }
        uint64_t v21 = v20;
        appendProperty(Mutable, @"string", @"Data", 0, v20, a3);
        CFRelease(v21);
        char v16 = 1;
      }
    }
    if (v17 != 1 || (v16 & 1) == 0) {
LABEL_25:
    }
      appendRelabeledProperty(Mutable, @"Data", 0, a2 + 24, @"Unparsed %@", a3);
  }
LABEL_26:
  CFStringRef v22 = SecDERItemCopyOIDDecimalRepresentation(v6, (unsigned __int8 **)a2);
  CFStringRef v23 = copyOidDescription(v6, a2, a3);
  appendProperty(a1, @"section", v22, v23, Mutable, a3);
  if (v23) {
    CFRelease(v23);
  }
  if (v22) {
    CFRelease(v22);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void appendFingerprintsProperty(void *a1, __CFData *a2, char a3)
{
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = (__CFString *)CFArrayCreateMutable(v6, 0, MEMORY[0x1E4F1D510]);
  uint64_t v8 = SecCertificateCopySHA256Digest(a2);
  if (v8)
  {
    CFStringRef v9 = v8;
    appendProperty(Mutable, @"data", @"SHA-256", 0, (const __CFString *)v8, a3);
    CFRelease(v9);
  }
  SHA1Digest = SecCertificateGetSHA1Digest(a2);
  appendProperty(Mutable, @"data", @"SHA-1", 0, (const __CFString *)SHA1Digest, a3);
  appendProperty(a1, @"section", @"Fingerprints", 0, Mutable, a3);
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

void appendBoolProperty(void *cf, const __CFString *a2, int a3, int a4)
{
  char v4 = a4;
  if (a3) {
    CFStringRef v7 = @"Yes";
  }
  else {
    CFStringRef v7 = @"No";
  }
  if (a4) {
    CFStringRef v7 = SecFrameworkCopyLocalizedString(v7, @"Certificate");
  }
  appendProperty(cf, @"string", a2, 0, v7, v4);

  CFRelease(v7);
}

void appendSubjectKeyIdentifier(void *a1, uint64_t a2, char a3)
{
  memset(v6, 170, sizeof(v6));
  if (DERDecodeItem(a2, v6) || v6[0] != 4) {
    appendRelabeledProperty(a1, @"Subject Key Identifier", 0, a2, @"Invalid %@", a3);
  }
  else {
    appendDataProperty(a1, @"Key Identifier", 0, (uint64_t)&v6[1], a3);
  }
}

void appendBitStringNames(void *a1, uint64_t a2, const __CFString **a3, unsigned __int16 a4, int a5)
{
  memset(v10, 170, sizeof(v10));
  if (DERDecodeItem(a2, v10) || v10[0] != 3) {
    appendRelabeledProperty(a1, @"Usage", 0, a2, @"Invalid %@", a5);
  }
  else {
    appendBitStringContentNames(a1, @"Usage", (unsigned __int8 **)&v10[1], a3, a4, a5);
  }
}

void appendPrivateKeyUsagePeriod(void *a1, uint64_t a2, char a3)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v7 = v6;
  long long v8 = v6;
  if (DERParseSequence(a2, (unsigned __int16)DERNumPrivateKeyUsagePeriodItemSpecs, (uint64_t)&DERPrivateKeyUsagePeriodItemSpecs, (unint64_t)&v7, 0x20uLL))
  {
    appendRelabeledProperty(a1, @"Private Key Usage Period", 0, a2, @"Invalid %@", a3);
  }
  else
  {
    if (*((void *)&v7 + 1)) {
      appendDateContentProperty(a1, @"Not Valid Before", (uint64_t)&v7, a3);
    }
    if (*((void *)&v8 + 1)) {
      appendDateContentProperty(a1, @"Not Valid After", (uint64_t)&v8, a3);
    }
  }
}

void appendGeneralNames(void *a1, uint64_t a2, uint64_t a3)
{
  memset(v6, 170, sizeof(v6));
  if (DERDecodeItem(a2, v6) || v6[0] != 0x2000000000000010) {
    appendRelabeledProperty(a1, @"General Names", 0, a2, @"Invalid %@", a3);
  }
  else {
    appendGeneralNamesContent(a1, &v6[1], a3);
  }
}

void appendBasicConstraints(void *a1, uint64_t a2, int a3)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v7 = v6;
  long long v8 = v6;
  if (DERParseSequence(a2, (unsigned __int16)DERNumBasicConstraintsItemSpecs, (uint64_t)&DERBasicConstraintsItemSpecs, (unint64_t)&v7, 0x20uLL))
  {
    appendRelabeledProperty(a1, @"Basic Constraints", 0, a2, @"Invalid %@", a3);
  }
  else
  {
    char v9 = -86;
    if (DERParseBooleanWithDefault((unsigned __int8 **)&v7, 0, (BOOL *)&v9)) {
      appendRelabeledProperty(a1, @"Certificate Authority", 0, (uint64_t)&v7, @"Invalid %@", a3);
    }
    else {
      appendBoolProperty(a1, @"Certificate Authority", v9, a3);
    }
    if (*((void *)&v8 + 1)) {
      appendIntegerProperty(a1, @"Path Length Constraint", (uint64_t)&v8, a3);
    }
  }
}

void appendNameConstraints(void *a1, uint64_t a2, uint64_t a3)
{
  CFAllocatorRef allocator = CFGetAllocator(a1);
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v30 = v6;
  *(_OWORD *)uint64_t v31 = v6;
  uint64_t v22 = a2;
  if (DERParseSequence(a2, (unsigned __int16)DERNumNameConstraintsItemSpecs, (uint64_t)&DERNameConstraintsItemSpecs, (unint64_t)&v30, 0x20uLL))goto LABEL_29; {
  if (*((void *)&v30 + 1))
  }
  {
    unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
    if (DERDecodeSeqContentInit((unint64_t *)&v30, &v28)) {
      goto LABEL_29;
    }
    memset(v27, 170, sizeof(v27));
    while (1)
    {
      int v7 = DERDecodeSeqNext(&v28, v27);
      if (v7) {
        break;
      }
      *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v25 = v8;
      long long v26 = v8;
      long long v24 = v8;
      if (v27[0] != 0x2000000000000010
        || DERParseSequenceContent(&v27[1], (unsigned __int16)DERNumGeneralSubtreeItemSpecs, (uint64_t)&DERGeneralSubtreeItemSpecs, (unint64_t)&v24, 0x30uLL))
      {
        goto LABEL_29;
      }
      if (*((void *)&v25 + 1)) {
        appendIntegerProperty(a1, @"Permitted Subtree Minimum", (uint64_t)&v25, a3);
      }
      if (*((void *)&v26 + 1)) {
        appendIntegerProperty(a1, @"Permitted Subtree Maximum", (uint64_t)&v26, a3);
      }
      if (*((void *)&v24 + 1))
      {
        CFMutableArrayRef Mutable = (__CFString *)CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
        appendProperty(a1, @"section", @"Permitted Subtree General Name", 0, Mutable, a3);
        appendGeneralNameProperty(Mutable, (uint64_t)&v24, a3);
        CFRelease(Mutable);
      }
    }
    if (v7 != 1) {
      goto LABEL_29;
    }
  }
  if (v31[1])
  {
    unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
    if (DERDecodeSeqContentInit(v31, &v28)) {
      goto LABEL_29;
    }
    CFAllocatorRef v10 = &v25;
    CFStringRef v11 = &v26;
    CFStringRef v12 = &DERGeneralSubtreeItemSpecs;
    memset(v27, 170, sizeof(v27));
    CFStringRef v13 = @"Excluded Subtree Maximum";
    while (1)
    {
      int v14 = DERDecodeSeqNext(&v28, v27);
      if (v14) {
        break;
      }
      *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v25 = v15;
      long long v26 = v15;
      long long v24 = v15;
      if (v27[0] != 0x2000000000000010
        || DERParseSequenceContent(&v27[1], (unsigned __int16)DERNumGeneralSubtreeItemSpecs, (uint64_t)v12, (unint64_t)&v24, 0x30uLL))
      {
        goto LABEL_29;
      }
      if (*((void *)&v25 + 1)) {
        appendIntegerProperty(a1, @"Excluded Subtree Minimum", (uint64_t)v10, a3);
      }
      if (*((void *)&v26 + 1)) {
        appendIntegerProperty(a1, v13, (uint64_t)v11, a3);
      }
      if (*((void *)&v24 + 1))
      {
        char v16 = v11;
        int v17 = v10;
        CFStringRef v18 = v12;
        CFStringRef v19 = v13;
        int v20 = (__CFString *)CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
        appendProperty(a1, @"section", @"Excluded Subtree General Name", 0, v20, a3);
        appendGeneralNameProperty(v20, (uint64_t)&v24, a3);
        uint64_t v21 = v20;
        CFStringRef v13 = v19;
        CFStringRef v12 = v18;
        CFAllocatorRef v10 = v17;
        CFStringRef v11 = v16;
        CFRelease(v21);
      }
    }
    if (v14 != 1) {
LABEL_29:
    }
      appendRelabeledProperty(a1, @"Name Constraints", 0, v22, @"Invalid %@", a3);
  }
}

void appendCrlDistributionPoints(void *a1, uint64_t a2, uint64_t a3)
{
  CFAllocatorRef v6 = CFGetAllocator(a1);
  memset(v16, 170, sizeof(v16));
  if (DERDecodeSeqInit(a2, &v16[2], v16) || v16[2] != 0x2000000000000010) {
    goto LABEL_20;
  }
  memset(v15, 170, sizeof(v15));
  while (1)
  {
    int v7 = DERDecodeSeqNext(v16, v15);
    if (v7) {
      break;
    }
    if (v15[0] != 0x2000000000000010) {
      goto LABEL_20;
    }
    *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v13 = v8;
    long long v14 = v8;
    long long v12 = v8;
    if (DERParseSequenceContent(&v15[1], (unsigned __int16)DERNumDistributionPointItemSpecs, (uint64_t)&DERDistributionPointItemSpecs, (unint64_t)&v12, 0x30uLL))goto LABEL_20; {
    if (*((void *)&v12 + 1))
    }
    {
      memset(v11, 170, sizeof(v11));
      if (DERDecodeItem((uint64_t)&v12, v11)) {
        goto LABEL_20;
      }
      if (v11[0] == 0xA000000000000001)
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(v6, 0, MEMORY[0x1E4F1D510]);
        if (parseRDNContent((unint64_t *)&v13, (uint64_t)Mutable, (uint64_t (*)(uint64_t, long long *, long long *, uint64_t, uint64_t))appendRDNProperty, a3))
        {
          CFArrayRemoveAllValues(Mutable);
          appendRelabeledProperty(Mutable, @"RDN", 0, (uint64_t)&v13, @"Invalid %@", a3);
        }
        appendProperty(a1, @"section", @"Name Relative To CRL Issuer", 0, (const __CFString *)Mutable, a3);
        CFRelease(Mutable);
      }
      else
      {
        if (v11[0] != 0xA000000000000000) {
          goto LABEL_20;
        }
        appendGeneralNamesContent(a1, &v11[1], a3);
      }
    }
    if (*((void *)&v13 + 1)) {
      appendBitStringContentNames(a1, @"Reasons", (unsigned __int8 **)&v13, (const __CFString **)appendCrlDistributionPoints_reasonNames, 9u, a3);
    }
    if (*((void *)&v14 + 1))
    {
      CFAllocatorRef v10 = (__CFString *)CFArrayCreateMutable(v6, 0, MEMORY[0x1E4F1D510]);
      appendProperty(a1, @"section", @"CRL Issuer", 0, v10, a3);
      CFRelease(v10);
      appendGeneralNames(v10, (uint64_t)&v14, a3);
    }
  }
  if (v7 != 1) {
LABEL_20:
  }
    appendRelabeledProperty(a1, @"CRL Distribution Points", 0, a2, @"Invalid %@", a3);
}

void appendCertificatePolicies(void *a1, uint64_t a2, int a3)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  memset(v49, 170, sizeof(v49));
  if (DERDecodeSeqInit(a2, &v49[2], v49) || v49[2] != 0x2000000000000010)
  {
LABEL_63:
    appendRelabeledProperty(a1, @"Certificate Policies", 0, a2, @"Invalid %@", a3);
    return;
  }
  CFStringRef v5 = &v48[1];
  memset(v48, 170, sizeof(v48));
  uint64_t v6 = 1;
  uint64_t v7 = (unsigned __int16)DERNumPolicyInformationItemSpecs;
LABEL_4:
  int v8 = DERDecodeSeqNext(v49, v48);
  if (!v8)
  {
    if (v48[0] != 0x2000000000000010) {
      goto LABEL_63;
    }
    *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v46 = v9;
    long long v47 = v9;
    if (DERParseSequenceContent(v5, v7, (uint64_t)&DERPolicyInformationItemSpecs, (unint64_t)&v46, 0x20uLL))goto LABEL_63; {
    CFStringRef v10 = CFStringCreateWithFormat(v4, 0, @"Policy Identifier #%d", v6);
    }
    if (!v10) {
      goto LABEL_63;
    }
    CFStringRef v11 = v10;
    CFStringRef v12 = @"Policy Identifier #%d";
    if (a3)
    {
      CFStringRef v12 = SecFrameworkCopyLocalizedString(@"Policy Identifier #%d", @"Certificate");
      if (!v12) {
        goto LABEL_62;
      }
    }
    uint64_t v13 = v7;
    long long v14 = v5;
    CFAllocatorRef v15 = v4;
    CFStringRef v16 = CFStringCreateWithFormat(v4, 0, v12, v6);
    if (!v16)
    {
LABEL_60:
      if (v12) {
        CFRelease(v12);
      }
LABEL_62:
      CFRelease(v11);
      goto LABEL_63;
    }
    CFStringRef v17 = v16;
    uint64_t v6 = (v6 + 1);
    CFRelease(v12);
    appendOIDProperty(a1, v11, v17, (uint64_t)&v46, a3);
    CFRelease(v11);
    CFRelease(v17);
    if (!*((void *)&v47 + 1))
    {
      CFAllocatorRef v4 = v15;
      goto LABEL_57;
    }
    v45[0] = 0xAAAAAAAAAAAAAAAALL;
    v45[1] = 0xAAAAAAAAAAAAAAAALL;
    if (DERDecodeSeqContentInit((unint64_t *)&v47, v45)) {
      goto LABEL_63;
    }
    CFAllocatorRef v4 = v15;
    uint64_t v18 = 1;
    memset(v44, 170, sizeof(v44));
    CFStringRef v12 = @"Policy Qualifier #%d";
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            int v19 = DERDecodeSeqNext(v45, v44);
            if (v19)
            {
              if (v19 != 1) {
                goto LABEL_63;
              }
LABEL_57:
              CFStringRef v5 = v14;
              uint64_t v7 = v13;
              goto LABEL_4;
            }
            *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
            long long v42 = v20;
            long long v43 = v20;
            if (DERParseSequenceContent(&v44[1], (unsigned __int16)DERNumPolicyQualifierInfoItemSpecs, (uint64_t)&DERPolicyQualifierInfoItemSpecs, (unint64_t)&v42, 0x20uLL))goto LABEL_63; {
            memset(v41, 170, sizeof(v41));
            }
            if (DERDecodeItem((uint64_t)&v43, v41)) {
              goto LABEL_63;
            }
            CFStringRef v21 = CFStringCreateWithFormat(v4, 0, @"Policy Qualifier #%d", v18);
            if (!v21) {
              goto LABEL_63;
            }
            CFStringRef v11 = v21;
            if (a3)
            {
              CFStringRef v12 = SecFrameworkCopyLocalizedString(@"Policy Qualifier #%d", @"Certificate");
              if (!v12) {
                goto LABEL_62;
              }
            }
            CFStringRef v22 = CFStringCreateWithFormat(v4, 0, v12, v18);
            if (!v22) {
              goto LABEL_60;
            }
            CFStringRef v23 = v22;
            uint64_t v18 = (v18 + 1);
            CFRelease(v12);
            appendOIDProperty(a1, v11, v23, (uint64_t)&v42, a3);
            CFRelease(v11);
            CFRelease(v23);
            if (!DEROidCompare((uint64_t)&oidQtCps, (uint64_t)&v42)) {
              break;
            }
            CFStringRef v12 = @"Policy Qualifier #%d";
            if (v41[0] != 22) {
              goto LABEL_63;
            }
            CFAllocatorRef v4 = v15;
            appendURLContentProperty(a1, @"CPS URI", (uint64_t)&v41[1], a3);
          }
          CFAllocatorRef v4 = v15;
          CFStringRef v12 = @"Policy Qualifier #%d";
          if (DEROidCompare((uint64_t)&oidQtUNotice, (uint64_t)&v42)) {
            break;
          }
          appendRelabeledProperty(a1, @"Qualifier", 0, (uint64_t)&v43, @"Unparsed %@", a3);
        }
        if (v41[0] != 0x2000000000000010) {
          goto LABEL_63;
        }
        *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v39 = v24;
        long long v40 = v24;
        if (DERParseSequenceContent(&v41[1], (unsigned __int16)DERNumUserNoticeItemSpecs, (uint64_t)&DERUserNoticeItemSpecs, (unint64_t)&v39, 0x20uLL))goto LABEL_63; {
        if (*((void *)&v39 + 1))
        }
          break;
        if (*((void *)&v40 + 1)) {
          goto LABEL_52;
        }
      }
      uint64_t v34 = a2;
      *(void *)&long long v25 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v37 = v25;
      long long v38 = v25;
      if (DERParseSequenceContent((unint64_t *)&v39, (unsigned __int16)DERNumNoticeReferenceItemSpecs, (uint64_t)&DERNoticeReferenceItemSpecs, (unint64_t)&v37, 0x20uLL))goto LABEL_63; {
      appendDERThingProperty(a1, @"Organization", 0, (unsigned __int8 **)&v37, a3);
      }
      CFAllocatorRef v26 = CFGetAllocator(a1);
      v51[0] = 0xAAAAAAAAAAAAAAAALL;
      v51[1] = 0xAAAAAAAAAAAAAAAALL;
      if (!DERDecodeSeqContentInit((unint64_t *)&v38, v51))
      {
        CFStringRef v27 = @"%@, %@";
        memset(v50, 170, sizeof(v50));
        if (!a3 || (CFStringRef v27 = SecFrameworkCopyLocalizedString(@"%@, %@", @"Certificate")) != 0)
        {
          for (CFStringRef i = 0; ; CFStringRef i = MutableCopy)
          {
            int v29 = DERDecodeSeqNext(v51, v50);
            if (v29) {
              break;
            }
            if (v50[0] != 2 || (long long v30 = copyIntegerContentDescription(v26, (uint64_t)&v50[1])) == 0)
            {
              CFRelease(v27);
              goto LABEL_48;
            }
            uint64_t v31 = v30;
            if (i)
            {
              CFStringRef MutableCopy = CFStringCreateWithFormat(v26, 0, v27, i, v30);
              CFRelease(i);
              if (!MutableCopy) {
                goto LABEL_53;
              }
            }
            else
            {
              CFStringRef MutableCopy = CFStringCreateMutableCopy(v26, 0, v30);
              if (!MutableCopy)
              {
LABEL_53:
                CFRelease(v27);
                CFStringRef i = v31;
                CFStringRef v12 = @"Policy Qualifier #%d";
                goto LABEL_49;
              }
            }
            CFRelease(v31);
          }
          int v33 = v29;
          CFRelease(v27);
          if (v33 == 1 && i)
          {
            appendProperty(a1, @"string", @"Notice Numbers", 0, i, a3);
            CFRelease(i);
            CFAllocatorRef v4 = v15;
            CFStringRef v12 = @"Policy Qualifier #%d";
            goto LABEL_51;
          }
LABEL_48:
          CFStringRef v12 = @"Policy Qualifier #%d";
          if (!i) {
            goto LABEL_50;
          }
LABEL_49:
          CFRelease(i);
        }
      }
LABEL_50:
      appendRelabeledProperty(a1, @"Notice Numbers", 0, (uint64_t)&v38, @"Invalid %@", a3);
      CFAllocatorRef v4 = v15;
LABEL_51:
      a2 = v34;
      if (*((void *)&v40 + 1)) {
LABEL_52:
      }
        appendDERThingProperty(a1, @"Explicit Text", 0, (unsigned __int8 **)&v40, a3);
    }
  }
  if (v8 != 1) {
    goto LABEL_63;
  }
}

void appendAuthorityKeyIdentifier(void *a1, uint64_t a2, uint64_t a3)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v8 = v6;
  long long v9 = v6;
  long long v7 = v6;
  if (DERParseSequence(a2, (unsigned __int16)DERNumAuthorityKeyIdentifierItemSpecs, (uint64_t)&DERAuthorityKeyIdentifierItemSpecs, (unint64_t)&v7, 0x30uLL))goto LABEL_9; {
  if (*((void *)&v7 + 1))
  }
    appendDataProperty(a1, @"Key Identifier", 0, (uint64_t)&v7, a3);
  if (*((void *)&v8 + 1) | *((void *)&v9 + 1))
  {
    if (*((void *)&v8 + 1) && *((void *)&v9 + 1))
    {
      appendGeneralNamesContent(a1, (unint64_t *)&v8, a3);
      appendIntegerProperty(a1, @"Authority Certificate Serial Number", (uint64_t)&v9, a3);
      return;
    }
LABEL_9:
    appendRelabeledProperty(a1, @"Authority Key Identifier", 0, a2, @"Invalid %@", a3);
  }
}

void appendPolicyConstraints(void *a1, uint64_t a2, char a3)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v7 = v6;
  long long v8 = v6;
  if (DERParseSequence(a2, (unsigned __int16)DERNumPolicyConstraintsItemSpecs, (uint64_t)&DERPolicyConstraintsItemSpecs, (unint64_t)&v7, 0x20uLL))
  {
    appendRelabeledProperty(a1, @"Policy Constraints", 0, a2, @"Invalid %@", a3);
  }
  else
  {
    if (*((void *)&v7 + 1)) {
      appendIntegerProperty(a1, @"Require Explicit Policy", (uint64_t)&v7, a3);
    }
    if (*((void *)&v8 + 1)) {
      appendIntegerProperty(a1, @"Inhibit Policy Mapping", (uint64_t)&v8, a3);
    }
  }
}

void appendExtendedKeyUsage(void *a1, uint64_t a2, int a3)
{
  memset(v8, 170, sizeof(v8));
  if (DERDecodeSeqInit(a2, &v8[2], v8) || v8[2] != 0x2000000000000010) {
    goto LABEL_8;
  }
  memset(v7, 170, sizeof(v7));
  while (1)
  {
    int v6 = DERDecodeSeqNext(v8, v7);
    if (v6) {
      break;
    }
    if (v7[0] != 6) {
      goto LABEL_8;
    }
    appendOIDProperty(a1, @"Purpose", 0, (uint64_t)&v7[1], a3);
  }
  if (v6 != 1) {
LABEL_8:
  }
    appendRelabeledProperty(a1, @"Extended Key Usage", 0, a2, @"Invalid %@", a3);
}

void appendInfoAccess(void *a1, uint64_t a2, uint64_t a3)
{
  memset(v11, 170, sizeof(v11));
  if (DERDecodeSeqInit(a2, &v11[2], v11) || v11[2] != 0x2000000000000010) {
    goto LABEL_9;
  }
  memset(v10, 170, sizeof(v10));
  while (1)
  {
    int v6 = DERDecodeSeqNext(v11, v10);
    if (v6) {
      break;
    }
    if (v10[0] != 0x2000000000000010) {
      goto LABEL_9;
    }
    *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v8 = v7;
    long long v9 = v7;
    if (DERParseSequenceContent(&v10[1], (unsigned __int16)DERNumAccessDescriptionItemSpecs, (uint64_t)&DERAccessDescriptionItemSpecs, (unint64_t)&v8, 0x20uLL))goto LABEL_9; {
    appendOIDProperty(a1, @"Access Method", 0, (uint64_t)&v8, a3);
    }
    appendGeneralNameProperty(a1, (uint64_t)&v9, a3);
  }
  if (v6 != 1) {
LABEL_9:
  }
    appendRelabeledProperty(a1, @"Authority Information Access", 0, a2, @"Invalid %@", a3);
}

void appendRelabeledProperty(void *a1, const __CFString *a2, const __CFString *a3, uint64_t a4, const __CFString *a5, char a6)
{
  CFAllocatorRef v12 = CFGetAllocator(a1);
  CFStringRef v13 = CFStringCreateWithFormat(v12, 0, a5, a2);
  if (a6)
  {
    if (a3)
    {
      a2 = 0;
    }
    else
    {
      a2 = SecFrameworkCopyLocalizedString(a2, @"Certificate");
      a3 = a2;
    }
    a5 = SecFrameworkCopyLocalizedString(a5, @"Certificate");
  }
  else
  {
    if (a2) {
      CFRetain(a2);
    }
    if (a5) {
      CFRetain(a5);
    }
    a3 = a2;
  }
  CFAllocatorRef v14 = CFGetAllocator(a1);
  CFStringRef v15 = CFStringCreateWithFormat(v14, 0, a5, a3);
  if (a2) {
    CFRelease(a2);
  }
  if (a5) {
    CFRelease(a5);
  }
  appendDataProperty(a1, v13, v15, a4, a6);
  if (v13) {
    CFRelease(v13);
  }
  if (v15)
  {
    CFRelease(v15);
  }
}

void appendOIDProperty(void *a1, const __CFString *a2, const __CFString *a3, uint64_t a4, int a5)
{
  CFAllocatorRef v10 = CFGetAllocator(a1);
  CFStringRef v11 = copyOidDescription(v10, a4, a5);
  appendProperty(a1, @"string", a2, a3, v11, a5);

  CFRelease(v11);
}

void appendGeneralNameProperty(void *a1, uint64_t a2, uint64_t a3)
{
  memset(v6, 170, sizeof(v6));
  if (DERDecodeItem(a2, (unint64_t *)v6)
    || (appendGeneralNameContentProperty(a1, *(uint64_t *)v6, (unint64_t *)&v6[2], a3) & 1) == 0)
  {
    appendRelabeledProperty(a1, @"General Name", 0, a2, @"Invalid %@", a3);
  }
}

uint64_t appendGeneralNameContentProperty(void *cf, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  long long v7 = (unsigned __int8 **)a3;
  uint64_t result = 0;
  if (!v5 & v4)
  {
    switch(a2)
    {
      case 0xA000000000000000:
        *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)long long v25 = v10;
        *(_OWORD *)&v25[16] = v10;
        if (DERParseSequenceContent(a3, (unsigned __int16)DERNumOtherNameItemSpecs, (uint64_t)&DEROtherNameItemSpecs, (unint64_t)v25, 0x20uLL))
        {
          CFStringRef v22 = @"Other Name";
          goto LABEL_32;
        }
        CFAllocatorRef v11 = CFGetAllocator(cf);
        CFStringRef v12 = SecDERItemCopyOIDDecimalRepresentation(v11, (unsigned __int8 **)v25);
        CFMutableArrayRef Mutable = (__CFString *)copyOidDescription(v11, (uint64_t)v25, a4);
        CFAllocatorRef v14 = copyDERThingDescription(v11, (unsigned __int8 **)&v25[16], 0, a4);
        if (v14)
        {
          CFStringRef v15 = v14;
          appendProperty(cf, @"string", v12, Mutable, v14, a4);
          CFRelease(v15);
          if (!v12) {
            goto LABEL_8;
          }
        }
        else
        {
          appendRelabeledProperty(cf, v12, Mutable, (uint64_t)&v25[16], @"Unparsed %@", a4);
          if (!v12)
          {
LABEL_8:
            if (Mutable) {
LABEL_25:
            }
              CFRelease(Mutable);
            return 1;
          }
        }
        CFRelease(v12);
        goto LABEL_8;
      case 0xA000000000000003:
        CFStringRef v22 = @"X.400 Address";
        goto LABEL_34;
      case 0xA000000000000004:
        CFAllocatorRef v23 = CFGetAllocator(cf);
        CFMutableArrayRef Mutable = (__CFString *)CFArrayCreateMutable(v23, 0, MEMORY[0x1E4F1D510]);
        memset(v25, 170, 24);
        if (DERDecodeItem((uint64_t)v7, (unint64_t *)v25)
          || *(void *)v25 != 0x2000000000000010
          || parseX501NameContent((unint64_t *)&v25[8], (uint64_t)Mutable, (uint64_t (*)(uint64_t, long long *, long long *, uint64_t, uint64_t))appendRDNProperty, a4))
        {
          CFArrayRemoveAllValues((CFMutableArrayRef)Mutable);
          appendRelabeledProperty(Mutable, @"X.501 Name", 0, (uint64_t)v7, @"Invalid %@", a4);
        }
        long long v20 = @"section";
        CFStringRef v21 = @"Directory Name";
LABEL_24:
        appendProperty(cf, v20, v21, 0, Mutable, a4);
        goto LABEL_25;
      case 0xA000000000000005:
        CFStringRef v22 = @"EDI Party Name";
        goto LABEL_34;
      case 0xA000000000000006:
        memset(v25, 170, 24);
        if (!DERDecodeItem((uint64_t)a3, (unint64_t *)v25) && *(void *)v25 == 22)
        {
          a3 = (unint64_t *)&v25[8];
          CFStringRef v17 = cf;
LABEL_30:
          appendURLContentProperty(v17, @"URI", (uint64_t)a3, a4);
          return 1;
        }
        CFStringRef v22 = @"URI";
LABEL_32:
        CFStringRef v24 = @"Invalid %@";
        goto LABEL_35;
      default:
        return result;
    }
  }
  switch(a2)
  {
    case 0x8000000000000001:
      CFStringRef v16 = @"Email Address";
      goto LABEL_13;
    case 0x8000000000000002:
      CFStringRef v16 = @"DNS Name";
LABEL_13:
      appendStringContentProperty(cf, v16, (uint64_t)a3, a4);
      return 1;
    case 0x8000000000000003:
    case 0x8000000000000004:
    case 0x8000000000000005:
      return result;
    case 0x8000000000000006:
      CFStringRef v17 = cf;
      goto LABEL_30;
    case 0x8000000000000007:
      CFAllocatorRef v18 = CFGetAllocator(cf);
      CFStringRef v19 = copyIPAddressContentDescription(v18, v7);
      if (v19)
      {
        CFMutableArrayRef Mutable = (__CFString *)v19;
        long long v20 = @"string";
        CFStringRef v21 = @"IP Address";
        goto LABEL_24;
      }
      CFStringRef v22 = @"IP Address";
      break;
    case 0x8000000000000008:
      appendOIDProperty(cf, @"Registered ID", 0, (uint64_t)a3, a4);
      return 1;
    default:
      JUMPOUT(0);
  }
LABEL_34:
  CFStringRef v24 = @"Unparsed %@";
LABEL_35:
  appendRelabeledProperty(cf, v22, 0, (uint64_t)v7, v24, a4);
  return 1;
}

void appendStringContentProperty(void *cf, const __CFString *a2, uint64_t a3, char a4)
{
  if ((*(void *)(a3 + 8) & 0x8000000000000000) != 0
    || (CFAllocatorRef v8 = CFGetAllocator(cf),
        (CFStringRef v9 = CFStringCreateWithBytes(v8, *(const UInt8 **)a3, *(void *)(a3 + 8), 0x600u, 0)) == 0))
  {
    appendRelabeledProperty(cf, a2, 0, a3, @"Invalid %@", a4);
  }
  else
  {
    CFStringRef v10 = v9;
    appendProperty(cf, @"string", a2, 0, v9, a4);
    CFRelease(v10);
  }
}

void appendURLContentProperty(void *cf, const __CFString *a2, uint64_t a3, char a4)
{
  if ((*(void *)(a3 + 8) & 0x8000000000000000) != 0
    || (CFAllocatorRef v8 = CFGetAllocator(cf),
        (CFStringRef v9 = (const __CFString *)CFURLCreateWithBytes(v8, *(const UInt8 **)a3, *(void *)(a3 + 8), 0x600u, 0)) == 0))
  {
    appendRelabeledProperty(cf, a2, 0, a3, @"Invalid %@", a4);
  }
  else
  {
    CFStringRef v10 = v9;
    appendProperty(cf, @"url", a2, 0, v9, a4);
    CFRelease(v10);
  }
}

CFStringRef copyIPAddressContentDescription(const __CFAllocator *a1, unsigned __int8 **a2)
{
  CFAllocatorRef v2 = a2[1];
  if (v2 == (unsigned __int8 *)16) {
    return CFStringCreateWithFormat(a1, 0, @"%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X", **a2, (*a2)[1], (*a2)[2], (*a2)[3], (*a2)[4], (*a2)[5], (*a2)[6], (*a2)[7], (*a2)[8], (*a2)[9], (*a2)[10], (*a2)[11], (*a2)[12], (*a2)[13], (*a2)[14], (*a2)[15]);
  }
  if (v2 == (unsigned __int8 *)4) {
    return CFStringCreateWithFormat(a1, 0, @"%u.%u.%u.%u", **a2, (*a2)[1], (*a2)[2], (*a2)[3]);
  }
  return 0;
}

uint64_t appendRDNProperty(const __CFArray *cf, unsigned __int8 **a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  CFArrayRef Value = cf;
  if (a4 >= 1)
  {
    CFIndex v10 = CFArrayGetCount(cf) - 1;
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v10);
    CFDictionaryRef v12 = ValueAtIndex;
    if (a4 == 1)
    {
      CFAllocatorRef v13 = CFGetAllocator(Value);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(v13, 0, MEMORY[0x1E4F1D510]);
      CFArrayAppendValue(Mutable, v12);
      CFArrayRemoveValueAtIndex(Value, v10);
      appendProperty(Value, @"section", 0, 0, (const __CFString *)Mutable, a5);
      if (Mutable)
      {
        CFRelease(Mutable);
        CFArrayRef Value = Mutable;
      }
      else
      {
        CFArrayRef Value = 0;
      }
    }
    else
    {
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex, @"value");
    }
  }
  CFAllocatorRef v15 = CFGetAllocator(Value);
  CFStringRef v16 = SecDERItemCopyOIDDecimalRepresentation(v15, a2);
  CFAllocatorRef v17 = CFGetAllocator(Value);
  CFStringRef v18 = copyOidDescription(v17, (uint64_t)a2, a5);
  appendDERThingProperty(Value, v16, v18, a3, a5);
  if (v16) {
    CFRelease(v16);
  }
  if (v18) {
    CFRelease(v18);
  }
  return 0;
}

void appendDERThingProperty(void *a1, const __CFString *a2, const __CFString *a3, unsigned __int8 **a4, int a5)
{
  CFAllocatorRef v10 = CFGetAllocator(a1);
  CFAllocatorRef v11 = copyDERThingDescription(v10, a4, 0, a5);
  if (v11)
  {
    CFDictionaryRef v12 = v11;
    appendProperty(a1, @"string", a2, a3, v11, a5);
    CFRelease(v12);
  }
}

void appendGeneralNamesContent(void *a1, unint64_t *a2, uint64_t a3)
{
  v8[0] = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  if (DERDecodeSeqContentInit(a2, v8)) {
    goto LABEL_5;
  }
  memset(v7, 170, sizeof(v7));
  while (1)
  {
    int v6 = DERDecodeSeqNext(v8, (unint64_t *)v7);
    if (v6) {
      break;
    }
    if ((appendGeneralNameContentProperty(a1, *(uint64_t *)v7, (unint64_t *)&v7[2], a3) & 1) == 0) {
      goto LABEL_5;
    }
  }
  if (v6 != 1) {
LABEL_5:
  }
    appendRelabeledProperty(a1, @"General Names", 0, (uint64_t)a2, @"Invalid %@", a3);
}

void appendBitStringContentNames(void *a1, const __CFString *a2, unsigned __int8 **a3, const __CFString **a4, unsigned __int16 a5, int a6)
{
  unint64_t v9 = (unint64_t)a3[1];
  if ((v9 & 0xFFFFFFFFFFFFFFFELL) == 2
    && (uint64_t v10 = (uint64_t)*a3, v11 = **a3, v11 <= 7)
    && (unint64_t v12 = v9 - 1, LOWORD(v13) = 8 * v12 - v11, (unsigned __int16)v13 <= a5))
  {
    int v14 = *(unsigned __int8 *)(v10 + 1);
    if (v12 < 2)
    {
      int v15 = 128;
    }
    else
    {
      int v14 = *(unsigned __int8 *)(v10 + 2) | (v14 << 8);
      int v15 = 0x8000;
    }
    if (a6)
    {
      CFStringRef v16 = SecFrameworkCopyLocalizedString(@"%@, %@", @"Certificate");
      if ((_WORD)v13)
      {
LABEL_9:
        CFStringRef v17 = 0;
        uint64_t v13 = (unsigned __int16)v13;
        while (1)
        {
          CFStringRef v18 = *a4;
          if (a6)
          {
            CFStringRef v18 = SecFrameworkCopyLocalizedString(*a4, @"Certificate");
          }
          else if (v18)
          {
            CFRetain(*a4);
          }
          if ((v14 & v15) == 0) {
            goto LABEL_17;
          }
          if (v17) {
            break;
          }
          int v15 = (unsigned __int16)v15 >> 1;
          if (!v18)
          {
            CFStringRef v17 = 0;
            goto LABEL_22;
          }
          CFRetain(v18);
          CFStringRef v17 = v18;
LABEL_21:
          CFRelease(v18);
LABEL_22:
          ++a4;
          if (!--v13) {
            goto LABEL_27;
          }
        }
        CFAllocatorRef v19 = CFGetAllocator(a1);
        CFStringRef v20 = CFStringCreateWithFormat(v19, 0, v16, v17, v18);
        CFRelease(v17);
        CFStringRef v17 = v20;
LABEL_17:
        int v15 = (unsigned __int16)v15 >> 1;
        if (!v18) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }
    }
    else
    {
      CFStringRef v16 = @"%@, %@";
      if (8 * (_WORD)v12 != (_WORD)v11) {
        goto LABEL_9;
      }
    }
    CFStringRef v17 = 0;
LABEL_27:
    CFRelease(v16);
    if (v17) {
      CFStringRef v21 = v17;
    }
    else {
      CFStringRef v21 = &stru_1ED84D0B0;
    }
    appendProperty(a1, @"string", a2, 0, v21, a6);
    if (v17)
    {
      CFRelease(v17);
    }
  }
  else
  {
    appendRelabeledProperty(a1, a2, 0, (uint64_t)a3, @"Invalid %@", a6);
  }
}

void appendDateContentProperty(void *a1, const __CFString *a2, uint64_t a3, char a4)
{
  CFAbsoluteTime at = NAN;
  if (derDateContentGetAbsoluteTime(24, *(unsigned __int8 **)a3, *(void *)(a3 + 8), &at))
  {
    CFAllocatorRef v8 = CFGetAllocator(a1);
    CFStringRef v9 = (const __CFString *)CFDateCreate(v8, at);
    appendProperty(a1, @"date", a2, 0, v9, a4);
    CFRelease(v9);
  }
  else
  {
    appendRelabeledProperty(a1, a2, 0, a3, @"Invalid %@", a4);
  }
}

uint64_t SecCertificateCopyProperties(unsigned __int8 *a1)
{
  return CopyProperties(a1, 1);
}

uint64_t CopyProperties(unsigned __int8 *cf, int a2)
{
  CFMutableArrayRef v3 = (CFMutableArrayRef)*((void *)cf + 70);
  if (!v3)
  {
    CFAllocatorRef v5 = CFGetAllocator(cf);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v5, 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      CFMutableArrayRef v3 = Mutable;
      PropertiesForX501NameContent = createPropertiesForX501NameContent(v5, (unint64_t *)cf + 23, a2 != 0);
      if (PropertiesForX501NameContent)
      {
        CFAllocatorRef v8 = PropertiesForX501NameContent;
        appendProperty(v3, @"section", @"Subject Name", 0, (const __CFString *)PropertiesForX501NameContent, a2 != 0);
        CFRelease(v8);
      }
      CFStringRef v9 = createPropertiesForX501NameContent(v5, (unint64_t *)cf + 19, a2 != 0);
      if (v9)
      {
        uint64_t v10 = v9;
        appendProperty(v3, @"section", @"Issuer Name", 0, (const __CFString *)v9, a2 != 0);
        CFRelease(v10);
      }
      CFStringRef v11 = SecFrameworkCopyLocalizedString(@"%d", @"Certificate");
      if (v11)
      {
        CFStringRef v12 = v11;
        CFStringRef v13 = CFStringCreateWithFormat(v5, 0, v11, cf[96] + 1);
        CFRelease(v12);
        if (v13)
        {
          appendProperty(v3, @"string", @"Version", 0, v13, a2 != 0);
          CFRelease(v13);
        }
      }
      CFAllocatorRef v14 = CFGetAllocator(v3);
      CFMutableArrayRef v15 = CFArrayCreateMutable(v14, 0, MEMORY[0x1E4F1D510]);
      CFStringRef v16 = (const __CFString *)v15;
      if (*((void *)cf + 14))
      {
        appendIntegerProperty(v15, @"Serial Number", (uint64_t)(cf + 104), a2 != 0);
        appendProperty(v3, @"section", @"Serial Number", 0, v16, a2 != 0);
      }
      if (v16) {
        CFRelease(v16);
      }
      CFAllocatorRef v17 = CFGetAllocator(v3);
      CFStringRef v18 = (__CFString *)CFArrayCreateMutable(v17, 0, MEMORY[0x1E4F1D510]);
      appendDateProperty(v18, @"Not Valid Before", a2 != 0, *((CFAbsoluteTime *)cf + 21));
      appendDateProperty(v18, @"Not Valid After", a2 != 0, *((CFAbsoluteTime *)cf + 22));
      appendProperty(v3, @"section", @"Validity Period", 0, v18, a2 != 0);
      if (v18) {
        CFRelease(v18);
      }
      if (*((void *)cf + 36)) {
        appendDataProperty(v3, @"Subject Unique ID", 0, (uint64_t)(cf + 280), a2 != 0);
      }
      if (*((void *)cf + 34)) {
        appendDataProperty(v3, @"Issuer Unique ID", 0, (uint64_t)(cf + 264), a2 != 0);
      }
      CFAllocatorRef v19 = CFGetAllocator(v3);
      CFStringRef v20 = (__CFString *)CFArrayCreateMutable(v19, 0, MEMORY[0x1E4F1D510]);
      appendAlgorithmProperty(v20, @"Public Key Algorithm", (uint64_t)(cf + 216), a2 != 0);
      CFStringRef v21 = SecCertificateCopyKey((SecCertificateRef)cf);
      if (v21)
      {
        CFStringRef v22 = v21;
        uint64_t valuePtr = 0;
        CFDictionaryRef v23 = SecKeyCopyAttributes(v21);
        if (!v23) {
          goto LABEL_25;
        }
        CFDictionaryRef v24 = v23;
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v23, @"bsiz");
        if (Value) {
          CFNumberGetValue(Value, kCFNumberLongType, &valuePtr);
        }
        CFRelease(v24);
        CFAllocatorRef v26 = valuePtr;
        if (!valuePtr)
        {
LABEL_25:
          _SecKeyCheck((uint64_t)v22, (uint64_t)"SecKeyGetBlockSize");
          CFAllocatorRef v26 = *(uint64_t (**)(__SecKey *))(*((void *)v22 + 2) + 80);
          if (v26) {
            CFAllocatorRef v26 = (uint64_t (*)(__SecKey *))(8 * v26(v22));
          }
          uint64_t valuePtr = v26;
        }
        CFStringRef v27 = CFStringCreateWithFormat(v19, 0, @"%ld", v26, valuePtr);
        if (v27)
        {
          CFStringRef v28 = v27;
          appendProperty(v20, @"string", @"Public Key Size", 0, v27, a2 != 0);
          CFRelease(v28);
        }
        CFRelease(v22);
      }
      appendDataProperty(v20, @"Public Key Data", 0, (uint64_t)(cf + 248), a2 != 0);
      appendProperty(v3, @"section", @"Public Key Info", 0, v20, a2 != 0);
      if (v20) {
        CFRelease(v20);
      }
      if (*((uint64_t *)cf + 64) >= 1)
      {
        uint64_t v29 = 0;
        uint64_t v30 = 0;
        do
        {
          appendExtension(v3, *((void *)cf + 65) + v29, a2 != 0);
          ++v30;
          v29 += 40;
        }
        while (v30 < *((void *)cf + 64));
      }
      CFAllocatorRef v31 = CFGetAllocator(v3);
      CFIndex v32 = (__CFString *)CFArrayCreateMutable(v31, 0, MEMORY[0x1E4F1D510]);
      appendAlgorithmProperty(v32, @"Signature Algorithm", (uint64_t)(cf + 120), a2 != 0);
      appendDataProperty(v32, @"Signature Data", 0, (uint64_t)(cf + 80), a2 != 0);
      appendProperty(v3, @"section", @"Signature", 0, v32, a2 != 0);
      if (v32) {
        CFRelease(v32);
      }
      appendFingerprintsProperty(v3, (__CFData *)cf, a2 != 0);
      *((void *)cf + 70) = v3;
    }
    else
    {
      CFMutableArrayRef v3 = (CFMutableArrayRef)*((void *)cf + 70);
      if (!v3) {
        return 0;
      }
    }
  }
  CFRetain(v3);
  return *((void *)cf + 70);
}

CFDataRef SecCertificateCopySerialNumber(CFDataRef certificate)
{
  if (certificate)
  {
    CFDataRef v1 = certificate;
    certificate = (CFDataRef)*((void *)certificate + 71);
    if (certificate)
    {
      CFRetain(certificate);
      return (CFDataRef)*((void *)v1 + 71);
    }
  }
  return certificate;
}

uint64_t SecCertificateGetSubjectAltName(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 456);
  if (v1) {
    return v1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t SecFrameworkIsIPAddress(const __CFString *a1)
{
  return convertIPAddress(a1, 0);
}

CFTypeRef SecFrameworkCopyIPAddressData(const __CFString *a1)
{
  CFTypeRef v2 = 0;
  if (convertIPAddress(a1, &v2)) {
    return v2;
  }
  else {
    return 0;
  }
}

void __SecCertificateCopyIPAddresses_block_invoke(uint64_t a1, CFDataRef theData)
{
  if ((CFDataGetLength(theData) & 0x8000000000000000) == 0)
  {
    v6[0] = (unsigned __int8 *)CFDataGetBytePtr(theData);
    v6[1] = (unsigned __int8 *)CFDataGetLength(theData);
    CFStringRef v4 = copyIPAddressContentDescription(0, v6);
    if (v4)
    {
      CFStringRef v5 = v4;
      CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v4);
      CFRelease(v5);
    }
  }
}

uint64_t apply_block_1_9227(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t appendIPAddressesFromGeneralNames(__CFArray *a1, int a2, uint64_t a3)
{
  if (a2 != 7) {
    return 0;
  }
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3 != 16 && v3 != 4) {
    return 4294941021;
  }
  CFDataRef v6 = CFDataCreate(0, *(const UInt8 **)a3, *(void *)(a3 + 8));
  CFArrayAppendValue(a1, v6);
  if (v6) {
    CFRelease(v6);
  }
  return 0;
}

CFMutableArrayRef SecCertificateCopyRFC822NamesFromSAN(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = *(void *)(a1 + 456);
  if (v3
    && SecCertificateParseGeneralNames(v3 + 24, (uint64_t)Mutable, (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendRFC822NamesFromGeneralNames)|| !CFArrayGetCount(Mutable))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

OSStatus SecCertificateCopyEmailAddresses(SecCertificateRef certificate, CFArrayRef *emailAddresses)
{
  OSStatus result = -50;
  if (certificate && emailAddresses)
  {
    CFArrayRef v5 = SecCertificateCopyRFC822Names((uint64_t)certificate);
    *emailAddresses = v5;
    if (v5)
    {
      return 0;
    }
    else
    {
      CFArrayRef v6 = CFArrayCreate(0, 0, 0, MEMORY[0x1E4F1D510]);
      OSStatus result = 0;
      *emailAddresses = v6;
    }
  }
  return result;
}

CFMutableArrayRef SecCertificateCopyRFC822NamesFromSubject(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)Mutable, (uint64_t (*)(uint64_t, long long *, long long *, uint64_t, uint64_t))appendRFC822NamesFromX501Name, 1)|| !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t appendURIsFromGeneralNames(__CFArray *a1, int a2, uint64_t a3)
{
  if (a2 != 6) {
    return 0;
  }
  if ((*(void *)(a3 + 8) & 0x8000000000000000) != 0) {
    return 4294941021;
  }
  CFStringRef v4 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(const UInt8 **)a3, *(void *)(a3 + 8), 0x600u, 0);
  if (!v4) {
    return 4294941021;
  }
  CFStringRef v5 = v4;
  CFArrayAppendValue(a1, v4);
  CFRelease(v5);
  return 0;
}

CFMutableArrayRef SecCertificateCopyCommonNames(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)Mutable, (uint64_t (*)(uint64_t, long long *, long long *, uint64_t, uint64_t))appendCommonNamesFromX501Name, 1)|| !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t appendCommonNamesFromX501Name(__CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result = DEROidCompare(a2, (uint64_t)&oidCommonName);
  if (result)
  {
    CFStringRef v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a3, 1, a5);
    if (v9)
    {
      uint64_t v10 = v9;
      CFArrayAppendValue(a1, v9);
      CFRelease(v10);
      return 0;
    }
    else
    {
      return 4294941021;
    }
  }
  return result;
}

OSStatus SecCertificateCopyCommonName(SecCertificateRef certificate, CFStringRef *commonName)
{
  if (!certificate) {
    return -50;
  }
  CFArrayRef v3 = SecCertificateCopyCommonNames((uint64_t)certificate);
  if (!v3) {
    return -26276;
  }
  CFArrayRef v4 = v3;
  if (commonName)
  {
    CFIndex Count = CFArrayGetCount(v3);
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, Count - 1);
    CFStringRef v7 = ValueAtIndex;
    if (ValueAtIndex) {
      CFRetain(ValueAtIndex);
    }
    *commonName = v7;
  }
  CFRelease(v4);
  return 0;
}

CFMutableArrayRef SecCertificateCopyOrganization(uint64_t a1)
{
  return SecCertificateCopyOrganizationFromX501NameContent((unint64_t *)(a1 + 184));
}

CFMutableArrayRef SecCertificateCopyOrganizationalUnit(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)Mutable, (uint64_t (*)(uint64_t, long long *, long long *, uint64_t, uint64_t))appendOrganizationalUnitFromX501Name, 1)|| !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t appendOrganizationalUnitFromX501Name(__CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result = DEROidCompare(a2, (uint64_t)&oidOrganizationalUnitName);
  if (result)
  {
    CFStringRef v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a3, 1, a5);
    if (v9)
    {
      uint64_t v10 = v9;
      CFArrayAppendValue(a1, v9);
      CFRelease(v10);
      return 0;
    }
    else
    {
      return 4294941021;
    }
  }
  return result;
}

const void *SecCertificateCopySubjectAttributeValue(uint64_t a1, uint64_t a2)
{
  CFStringRef v5 = 0;
  v4[0] = a2;
  v4[1] = &v5;
  int v2 = parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)v4, (uint64_t (*)(uint64_t, long long *, long long *, uint64_t, uint64_t))copyAttributeValueFromX501Name, 0);
  uint64_t result = v5;
  if (v2)
  {
    if (v5)
    {
      CFStringRef v5 = 0;
      CFRelease(result);
      return v5;
    }
  }
  return result;
}

uint64_t copyAttributeValueFromX501Name(uint64_t *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result = DEROidCompare(a2, *a1);
  if (result)
  {
    CFStringRef v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a3, 1, a5);
    if (v9)
    {
      uint64_t v10 = v9;
      CFStringRef v11 = (CFTypeRef *)a1[1];
      if (*v11) {
        CFRelease(*v11);
      }
      uint64_t result = 0;
      *CFStringRef v11 = v10;
    }
    else
    {
      return 4294941021;
    }
  }
  return result;
}

CFMutableArrayRef SecCertificateCopyNTPrincipalNames(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = *(void *)(a1 + 456);
  if (v3
    && SecCertificateParseGeneralNames(v3 + 24, (uint64_t)Mutable, (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendNTPrincipalNamesFromGeneralNames)|| !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t appendNTPrincipalNamesFromGeneralNames(__CFArray *a1, int a2, unint64_t *a3)
{
  if (a2) {
    return 0;
  }
  uint64_t v12 = v3;
  uint64_t v13 = v4;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v10 = v7;
  long long v11 = v7;
  if (DERParseSequenceContent(a3, (unsigned __int16)DERNumOtherNameItemSpecs, (uint64_t)&DEROtherNameItemSpecs, (unint64_t)&v10, 0x20uLL))return 4294941021; {
  if (DEROidCompare((uint64_t)&v10, (uint64_t)&oidMSNTPrincipalName))
  }
  {
    CFAllocatorRef v8 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (unsigned __int8 **)&v11, 1, 1);
    if (v8)
    {
      CFStringRef v9 = v8;
      CFArrayAppendValue(a1, v8);
      CFRelease(v9);
      return 0;
    }
    return 4294941021;
  }
  return 0;
}

CFMutableStringRef SecCertificateCopySubjectString(uint64_t a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)Mutable, (uint64_t (*)(uint64_t, long long *, long long *, uint64_t, uint64_t))appendToRFC2253String, 1)|| !CFStringGetLength(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t appendToRFC2253String(__CFString *theString, unsigned __int8 **a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a4 <= 0)
  {
    if (!CFStringGetLength(theString)) {
      goto LABEL_6;
    }
    CFStringRef v9 = @",";
  }
  else
  {
    CFStringRef v9 = @"+";
  }
  CFStringAppend(theString, v9);
LABEL_6:
  if (DEROidCompare((uint64_t)a2, (uint64_t)&oidCommonName))
  {
    CFStringRef v10 = 0;
    CFStringRef v11 = @"CN";
  }
  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidLocalityName))
  {
    CFStringRef v10 = 0;
    CFStringRef v11 = @"L";
  }
  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidStateOrProvinceName))
  {
    CFStringRef v10 = 0;
    CFStringRef v11 = @"ST";
  }
  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidOrganizationName))
  {
    CFStringRef v10 = 0;
    CFStringRef v11 = @"O";
  }
  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidOrganizationalUnitName))
  {
    CFStringRef v10 = 0;
    CFStringRef v11 = @"OU";
  }
  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidCountryName))
  {
    CFStringRef v10 = 0;
    CFStringRef v11 = @"C";
  }
  else
  {
    CFStringRef v10 = SecDERItemCopyOIDDecimalRepresentation((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2);
    CFStringRef v11 = v10;
  }
  CFStringAppend(theString, v11);
  CFStringAppend(theString, @"=");
  if (v10
    || (CFAllocatorRef v14 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (unsigned __int8 **)a3, 1, a5)) == 0)
  {
    CFStringAppend(theString, @"#");
    if (*(void *)(a3 + 8))
    {
      unint64_t v12 = 0;
      do
        CFStringAppendFormat(theString, 0, @"%02X", *(unsigned __int8 *)(*(void *)a3 + v12++));
      while (v12 < *(void *)(a3 + 8));
    }
    if (v10) {
      CFRelease(v10);
    }
  }
  else
  {
    CFStringRef v15 = v14;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    *(_OWORD *)buffer = 0u;
    long long v37 = 0u;
    CFIndex Length = CFStringGetLength(v14);
    CFStringRef v44 = v15;
    uint64_t v47 = 0;
    CFIndex v48 = Length;
    CharactersPtr = CFStringGetCharactersPtr(v15);
    CStringPtr = 0;
    char v45 = CharactersPtr;
    if (!CharactersPtr) {
      CStringPtr = CFStringGetCStringPtr(v15, 0x600u);
    }
    long long v46 = CStringPtr;
    int64_t v49 = 0;
    int64_t v50 = 0;
    if (Length >= 1)
    {
      uint64_t v19 = 0;
      int64_t v20 = 0;
      uint64_t v21 = 64;
      do
      {
        if ((unint64_t)v20 >= 4) {
          uint64_t v22 = 4;
        }
        else {
          uint64_t v22 = v20;
        }
        __int16 v35 = -21846;
        CFIndex v23 = v48;
        if (v48 <= v20)
        {
          UniChar v24 = 0;
          __int16 v35 = 0;
        }
        else
        {
          if (v45)
          {
            UniChar v24 = v45[v20 + v47];
          }
          else if (v46)
          {
            UniChar v24 = v46[v47 + v20];
          }
          else
          {
            int64_t v25 = v49;
            if (v50 <= v20 || v49 > v20)
            {
              uint64_t v27 = v22 + v19;
              uint64_t v28 = v21 - v22;
              int64_t v29 = v20 - v22;
              CFIndex v30 = v29 + 64;
              if (v29 + 64 >= v48) {
                CFIndex v30 = v48;
              }
              int64_t v49 = v29;
              int64_t v50 = v30;
              if (v48 >= v28) {
                CFIndex v23 = v28;
              }
              v51.size_t length = v23 + v27;
              v51.location = v29 + v47;
              CFStringGetCharacters(v44, v51, buffer);
              int64_t v25 = v49;
            }
            UniChar v24 = buffer[v20 - v25];
          }
          __int16 v35 = v24;
          if (v24 > 0x1Fu)
          {
            if (v24 - 32 > 0x3C) {
              goto LABEL_63;
            }
            if (((1 << (v24 - 32)) & 0x1000000058001804) != 0) {
              goto LABEL_54;
            }
            if (v24 == 32)
            {
              if (!v20 || Length - 1 == v20) {
                goto LABEL_54;
              }
LABEL_64:
              CFAllocatorRef v31 = (UniChar *)&v35;
              CFIndex v32 = theString;
              CFIndex v33 = 1;
            }
            else
            {
LABEL_63:
              if (v20 || v24 != 35) {
                goto LABEL_64;
              }
LABEL_54:
              chars[0] = 92;
              chars[1] = v24;
              CFAllocatorRef v31 = chars;
              CFIndex v32 = theString;
              CFIndex v33 = 2;
            }
            CFStringAppendCharacters(v32, v31, v33);
            goto LABEL_56;
          }
        }
        CFStringAppendFormat(theString, 0, @"\\%02X", v24);
LABEL_56:
        ++v20;
        --v19;
        ++v21;
      }
      while (Length != v20);
    }
    CFRelease(v15);
  }
  return 0;
}

__CFData *SecCertificateCopySubjectSequence(uint64_t a1)
{
  return SecDERItemCopySequence(a1 + 184);
}

uint64_t SecCertificateGetPublicKeyAlgorithm(uint64_t a1)
{
  return a1 + 216;
}

uint64_t SecCertificateIsStrongKey(uint64_t result)
{
  if (result)
  {
    unint64_t v3 = 0;
    uint64_t v1 = SecCertificateGetPublicKeyAlgorithmIdAndSize((__SecCertificate *)result, (uint64_t *)&v3) - 1;
    uint64_t result = 1;
    switch(v1)
    {
      case 0:
        BOOL v2 = v3 > 0xFF;
        goto LABEL_5;
      case 2:
        BOOL v2 = v3 > 0x1B;
LABEL_5:
        uint64_t result = v2;
        break;
      case 3:
      case 5:
        return result;
      default:
        uint64_t result = 0;
        break;
    }
  }
  return result;
}

__CFData *SecCertificateCopyIssuerSHA1Digest(uint64_t a1)
{
  uint64_t result = SecDERItemCopySequence(a1 + 152);
  if (result)
  {
    CFDataRef v2 = result;
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    BytePtr = CFDataGetBytePtr(result);
    CFIndex Length = CFDataGetLength(v2);
    CFArrayRef v6 = SecSHA1DigestCreate(v3, (uint64_t)BytePtr, Length);
    CFRelease(v2);
    return v6;
  }
  return result;
}

__CFData *SecCertificateCopyIssuerSHA256Digest(uint64_t a1)
{
  uint64_t result = SecDERItemCopySequence(a1 + 152);
  if (result)
  {
    CFDataRef v2 = result;
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    BytePtr = CFDataGetBytePtr(result);
    CFIndex Length = CFDataGetLength(v2);
    CFArrayRef v6 = SecSHA256DigestCreate(v3, (uint64_t)BytePtr, Length);
    CFRelease(v2);
    return v6;
  }
  return result;
}

__CFData *SecCertificateCopyPublicKeySHA256Digest(void *cf)
{
  if (!cf || !cf[31] || (cf[32] & 0x8000000000000000) != 0) {
    return 0;
  }
  CFAllocatorRef v2 = CFGetAllocator(cf);
  uint64_t v3 = cf[31];
  unint64_t v4 = cf[32];

  return SecSHA256DigestCreate(v2, v3, v4);
}

CFDataRef SecCertificateCopySubjectPublicKeyInfoSHA1Digest(const void *a1)
{
  CFDataRef result = SecCertificateCopySPKIEncoded((uint64_t)a1);
  if (result)
  {
    CFDataRef v3 = result;
    CFAllocatorRef v4 = CFGetAllocator(a1);
    BytePtr = CFDataGetBytePtr(v3);
    CFIndex Length = CFDataGetLength(v3);
    long long v7 = SecSHA1DigestCreate(v4, (uint64_t)BytePtr, Length);
    CFRelease(v3);
    return v7;
  }
  return result;
}

void *SecCertificateCopyKeychainItem(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFDataRef result = (void *)result[77];
    if (result)
    {
      CFRetain(result);
      return (void *)v1[77];
    }
  }
  return result;
}

uint64_t SecCertificateGetCAIssuers(uint64_t result)
{
  if (result) {
    return *(void *)(result + 480);
  }
  return result;
}

BOOL SecCertificateHasCriticalSubjectAltName(BOOL result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 456);
    return v1 && *(unsigned __int8 *)(v1 + 16) != 0;
  }
  return result;
}

BOOL SecCertificateHasSubject(BOOL result)
{
  if (result) {
    return *(void *)(result + 192) != 0;
  }
  return result;
}

uint64_t SecCertificateShow(const void *a1)
{
  uint64_t v1 = (FILE **)MEMORY[0x1E4F143C8];
  fprintf((FILE *)*MEMORY[0x1E4F143C8], "SecCertificate instance %p:\n", a1);
  CFAllocatorRef v2 = *v1;

  return fputc(10, v2);
}

CFDictionaryRef SecCertificateCopyAttributeDictionary(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (!SecCertificateIsCertificate((void *)a1)) {
    return 0;
  }
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v3 = MEMORY[0x1F4188790](v2);
  unint64_t v38 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v36 = v4;
  long long v37 = v4;
  long long v34 = v4;
  long long v35 = v4;
  long long v33 = v4;
  CFAllocatorRef v5 = (const __CFAllocator *)MEMORY[0x1F4188790](v3);
  uint64_t v32 = v6;
  long long v30 = v7;
  long long v31 = v7;
  long long v28 = v7;
  long long v29 = v7;
  long long v27 = v7;
  int v8 = *(unsigned __int8 *)(a1 + 96) + 1;
  int v41 = 3;
  int valuePtr = v8;
  CFNumberRef v40 = CFNumberCreate(v5, kCFNumberSInt32Type, &valuePtr);
  if (!v40) {
    return 0;
  }
  CFNumberRef v9 = CFNumberCreate(v2, kCFNumberSInt32Type, &v41);
  if (v9)
  {
    CFNumberRef v10 = v9;
    CFDataRef v11 = SecCertificateCopyData((SecCertificateRef)a1);
    if (v11)
    {
      CFDataRef v12 = v11;
      CFDataRef SubjectKeyID = SecCertificateGetSubjectKeyID((CFDataRef)a1);
      CFAllocatorRef v14 = SecCertificateCopyPublicKeySHA1Digest((void *)a1);
      if (v14)
      {
        CFStringRef v15 = v14;
        *(void *)&long long v33 = @"class";
        *((void *)&v33 + 1) = @"ctyp";
        *(void *)&long long v27 = @"cert";
        *((void *)&v27 + 1) = v40;
        *(void *)&long long v34 = @"cenc";
        *(void *)&long long v28 = v10;
        CFStringRef v16 = *(const void **)(a1 + 584);
        uint64_t v39 = (uint64_t)&v39;
        if (v16 && (CFTypeID v17 = CFGetTypeID(v16), v17 == CFDataGetTypeID()))
        {
          *((void *)&v34 + 1) = @"subj";
          *((void *)&v28 + 1) = *(void *)(a1 + 584);
          uint64_t v18 = 4;
        }
        else
        {
          uint64_t v18 = 3;
        }
        int64_t v20 = *(const void **)(a1 + 576);
        if (v20
          && (CFTypeID v21 = CFGetTypeID(v20), v21 == CFDataGetTypeID())
          && (*((void *)&v33 + v18) = @"issr",
              *((void *)&v27 + v18) = *(void *)(a1 + 576),
              (uint64_t v22 = *(const void **)(a1 + 568)) != 0)
          && (CFTypeID v23 = CFGetTypeID(v22), v23 == CFDataGetTypeID()))
        {
          *((void *)&v33 + v18 + 1) = @"slnr";
          *((void *)&v27 + v18 + 1) = *(void *)(a1 + 568);
          uint64_t v24 = v18 + 2;
          if (SubjectKeyID)
          {
            *((void *)&v33 + v24) = @"skid";
            *((void *)&v27 + v24) = SubjectKeyID;
            uint64_t v24 = v18 + 3;
          }
          *((void *)&v33 + v24) = @"pkhh";
          *((void *)&v27 + v24) = v15;
          uint64_t v25 = 8 * v24 + 8;
          *(void *)((char *)&v33 + v25) = @"v_Data";
          *(void *)((char *)&v27 + v25) = v12;
          CFDictionaryRef v19 = CFDictionaryCreate(v2, (const void **)&v33, (const void **)&v27, v24 + 2, 0, MEMORY[0x1E4F1D540]);
        }
        else
        {
          CFDictionaryRef v19 = 0;
        }
        CFRelease(v15);
      }
      else
      {
        CFDictionaryRef v19 = 0;
      }
      CFRelease(v12);
    }
    else
    {
      CFDictionaryRef v19 = 0;
    }
    CFRelease(v10);
  }
  else
  {
    CFDictionaryRef v19 = 0;
  }
  CFRelease(v40);
  return v19;
}

CFDataRef SecCertificateCreateFromAttributeDictionary(const __CFDictionary *a1)
{
  CFDataRef result = (const __CFData *)CFDictionaryGetValue(a1, @"v_Data");
  if (result)
  {
    return SecCertificateCreateWithData(0, result);
  }
  return result;
}

void *SecCertificateIsSelfSignedCA(uint64_t a1)
{
  CFDataRef result = (void *)_SecCertificateIsSelfSigned(a1);
  if (result)
  {
    return SecCertificateIsCA(a1);
  }
  return result;
}

uint64_t SecCertificateGetExtensionValue(uint64_t a1, const __CFString *cf)
{
  if (!a1 || !cf) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFDataGetTypeID())
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID())
    {
      CFDataRef OidDataFromString = SecCertificateCreateOidDataFromString(0, cf);
      if (OidDataFromString)
      {
        CFDataRef v8 = OidDataFromString;
        uint64_t v9 = cert_extension_value_for_marker(a1, OidDataFromString);
        CFRelease(v8);
        return v9;
      }
    }
    return 0;
  }

  return cert_extension_value_for_marker(a1, (CFDataRef)cf);
}

uint64_t cert_extension_value_for_marker(uint64_t a1, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  if (Length < 0) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 512);
  if (v6 < 1) {
    return 0;
  }
  size_t v7 = Length;
  uint64_t v8 = 0;
  uint64_t v9 = *(void *)(a1 + 520);
  for (CFStringRef i = (void *)(v9 + 8); *i != v7 || memcmp((const void *)*(i - 1), BytePtr, v7); i += 5)
  {
    if (v6 == ++v8) {
      return 0;
    }
  }
  return v9 + 40 * v8 + 24;
}

CFDataRef SecCertificateCopyExtensionValue(uint64_t a1, const __CFString *cf, unsigned char *a3)
{
  CFDataRef v3 = 0;
  if (a1)
  {
    CFStringRef OidDataFromString = cf;
    if (cf)
    {
      CFTypeID v7 = CFGetTypeID(cf);
      if (v7 == CFDataGetTypeID())
      {
        CFRetain(OidDataFromString);
      }
      else
      {
        CFTypeID v8 = CFGetTypeID(OidDataFromString);
        if (v8 != CFStringGetTypeID()) {
          return 0;
        }
        CFStringRef OidDataFromString = (const __CFString *)SecCertificateCreateOidDataFromString(0, OidDataFromString);
        if (!OidDataFromString) {
          return 0;
        }
      }
      BytePtr = CFDataGetBytePtr((CFDataRef)OidDataFromString);
      CFIndex Length = CFDataGetLength((CFDataRef)OidDataFromString);
      if (Length < 0) {
        goto LABEL_13;
      }
      uint64_t v11 = *(void *)(a1 + 512);
      if (v11 < 1) {
        goto LABEL_13;
      }
      size_t v12 = Length;
      uint64_t v13 = 0;
      uint64_t v14 = *(void *)(a1 + 520);
      CFStringRef v15 = (void *)(v14 + 8);
      while (*v15 != v12 || memcmp((const void *)*(v15 - 1), BytePtr, v12))
      {
        ++v13;
        v15 += 5;
        if (v11 == v13) {
          goto LABEL_13;
        }
      }
      if (a3) {
        *a3 = *(unsigned char *)(v14 + 40 * v13 + 16);
      }
      CFIndex v17 = *(void *)(v14 + 40 * v13 + 32);
      if (v17 < 0) {
LABEL_13:
      }
        CFDataRef v3 = 0;
      else {
        CFDataRef v3 = CFDataCreate(0, *(const UInt8 **)(v14 + 40 * v13 + 24), v17);
      }
      CFRelease(OidDataFromString);
    }
  }
  return v3;
}

CFDataRef SecCertificateCopyiAPAuthCapabilities(uint64_t a1)
{
  int v2 = SecCertificateGetiAuthVersion(a1);
  if (v2 != 5)
  {
    if (v2 == 3)
    {
      CFDataRef result = (CFDataRef)SecCertificateGetExtensionValue(a1, @"1.2.840.113635.100.6.36");
      if (!result) {
        return result;
      }
      CFTypeID v4 = (unint64_t *)result;
      if (*((void *)result + 1) == 34)
      {
        memset(v7, 170, sizeof(v7));
        if (!DERDecodeItem((uint64_t)result, v7))
        {
          if (v7[0] == 4)
          {
            if (v7[2] == 32)
            {
              unint64_t v5 = v7[1];
              return CFDataCreate(0, (const UInt8 *)v5, 32);
            }
          }
          else
          {
            unint64_t v5 = *v4;
            if (!*(unsigned char *)(*v4 + 33) && !*(unsigned char *)(v5 + 32)) {
              return CFDataCreate(0, (const UInt8 *)v5, 32);
            }
          }
        }
      }
    }
    return 0;
  }
  CFDataRef result = (CFDataRef)SecCertificateGetExtensionValue(a1, @"1.2.840.113635.100.6.71.1");
  if (!result) {
    return result;
  }
  if (*((void *)result + 1) != 32) {
    return 0;
  }
  uint64_t v6 = *(const UInt8 **)result;

  return CFDataCreate(0, v6, 32);
}

uint64_t SecCertificateGetiAuthVersion(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (SecCertificateGetExtensionValue(result, @"1.2.840.113635.100.6.36"))
    {
      return 3;
    }
    else if (SecCertificateGetExtensionValue(v1, @"1.2.840.113635.100.6.59.1"))
    {
      return 4;
    }
    else if (SecCertificateGetExtensionValue(v1, @"1.2.840.113635.100.6.71.1"))
    {
      return 5;
    }
    else
    {
      int v2 = *(unsigned __int8 **)(v1 + 104);
      if (v2 && *(void *)(v1 + 112) == 15 && v2[2] == 170 && v2[6] == 170 && v2[8] == 170 && v2[11] == 170) {
        return 2;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

CFDataRef SecCertificateCopyiAPSWAuthCapabilities(uint64_t a1, unsigned int a2)
{
  CFDataRef result = 0;
  if (a1)
  {
    if (a2 <= 2)
    {
      unint64_t v7[3] = v2;
      void v7[4] = v3;
      CFDataRef result = (CFDataRef)SecCertificateGetExtensionValue(a1, off_1E547ED38[a2]);
      if (result)
      {
        memset(v7, 170, 24);
        if (DERDecodeItem((uint64_t)result, v7)) {
          BOOL v6 = 0;
        }
        else {
          BOOL v6 = v7[0] == 4;
        }
        if (v6 && v7[2] <= 0x7FFFFFFFFFFFFFFELL) {
          return CFDataCreate(0, (const UInt8 *)v7[1], v7[2]);
        }
        else {
          return 0;
        }
      }
    }
  }
  return result;
}

CFStringRef SecCertificateCopyComponentType(CFStringRef result)
{
  if (result)
  {
    CFDataRef result = (CFStringRef)SecCertificateGetExtensionValue((uint64_t)result, @"1.2.840.113635.100.11.1");
    if (result)
    {
      CFStringRef v1 = result;
      memset(v6, 170, sizeof(v6));
      int v2 = DERDecodeItem((uint64_t)result, v6);
      if (!v2 && v6[0] == 22)
      {
        unint64_t info = v6[2];
        if (v6[2] <= 0x7FFFFFFFFFFFFFFELL)
        {
          isa = (const UInt8 *)v6[1];
          CFStringEncoding v5 = 1536;
          return CFStringCreateWithBytes(0, isa, info, v5, 0);
        }
        return 0;
      }
      if (v2 || v6[0] != 12)
      {
        if (v2 != 3) {
          return 0;
        }
        unint64_t info = v1->info;
        if (info > 0x7FFFFFFFFFFFFFFELL) {
          return 0;
        }
        isa = (const UInt8 *)v1->isa;
      }
      else
      {
        unint64_t info = v6[2];
        if (v6[2] > 0x7FFFFFFFFFFFFFFELL) {
          return 0;
        }
        isa = (const UInt8 *)v6[1];
      }
      CFStringEncoding v5 = 134217984;
      return CFStringCreateWithBytes(0, isa, info, v5, 0);
    }
  }
  return result;
}

CFDictionaryRef SecCertificateCopyComponentAttributes(const __CFDictionary *a1)
{
  CFDictionaryRef Copy = a1;
  if (a1)
  {
    uint64_t v7 = 0;
    CFTypeID v8 = &v7;
    uint64_t v9 = 0x2000000000;
    CFMutableDictionaryRef Mutable = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    ExtensionCFNumberRef Value = SecCertificateGetExtensionValue((uint64_t)Copy, @"1.2.840.113635.100.11.3");
    if (ExtensionValue
      && (v6[0] = MEMORY[0x1E4F143A8],
          v6[1] = 0x40000000,
          v6[2] = __SecCertificateCopyComponentAttributes_block_invoke,
          unint64_t v6[3] = &unk_1E547EB00,
          void v6[4] = &v7,
          !DERDecodeSequenceWithBlock(ExtensionValue, (uint64_t)v6))
      && (CFDictionaryRef v3 = (const __CFDictionary *)v8[3]) != 0
      && CFDictionaryGetCount(v3) >= 1)
    {
      CFDictionaryRef Copy = CFDictionaryCreateCopy(0, (CFDictionaryRef)v8[3]);
    }
    else
    {
      CFDictionaryRef Copy = 0;
    }
    CFTypeID v4 = (const void *)v8[3];
    if (v4)
    {
      unint64_t v8[3] = 0;
      CFRelease(v4);
    }
    _Block_object_dispose(&v7, 8);
  }
  return Copy;
}

uint64_t __SecCertificateCopyComponentAttributes_block_invoke(uint64_t a1, void *a2)
{
  cf[3] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  uint64_t v3 = (uint64_t)(a2 + 1);
  uint64_t valuePtr = *a2 & 0x1FFFFFFFFFFFFFFFLL;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  memset(v17, 170, sizeof(v17));
  uint64_t v5 = DERDecodeItem(v3, v17);
  if (v5)
  {
LABEL_14:
    uint64_t v13 = v5;
LABEL_15:
    uint64_t v14 = 0;
  }
  else
  {
    switch(v17[0])
    {
      case 1uLL:
        LOBYTE(cf[0]) = 0;
        uint64_t v5 = DERParseBoolean((unsigned __int8 **)&v17[1], (BOOL *)cf);
        if (LOBYTE(cf[0])) {
          size_t v12 = (const void **)MEMORY[0x1E4F1CFD0];
        }
        else {
          size_t v12 = (const void **)MEMORY[0x1E4F1CFC8];
        }
        if (v5) {
          goto LABEL_14;
        }
        goto LABEL_23;
      case 2uLL:
        cf[0] = 0;
        uint64_t v5 = DERParseInteger64((char **)&v17[1], (unint64_t *)cf);
        if (v5) {
          goto LABEL_14;
        }
        uint64_t v9 = CFNumberCreate(0, kCFNumberSInt64Type, cf);
        goto LABEL_28;
      case 3uLL:
        *(_OWORD *)CFTypeRef cf = 0uLL;
        uint64_t v5 = DERParseBitString((uint64_t)&v17[1], (unint64_t *)cf, 0);
        if (v5) {
          goto LABEL_14;
        }
        CFTypeRef v7 = cf[1];
        if (((unint64_t)cf[1] & 0x8000000000000000) == 0)
        {
          CFTypeID v8 = (const UInt8 *)cf[0];
          goto LABEL_21;
        }
        uint64_t v13 = 7;
        goto LABEL_15;
      case 4uLL:
      case 6uLL:
        CFTypeRef v7 = (CFTypeRef)v17[2];
        if ((v17[2] & 0x8000000000000000) != 0)
        {
          uint64_t v14 = 0;
          uint64_t v13 = 7;
          break;
        }
        CFTypeID v8 = (const UInt8 *)v17[1];
LABEL_21:
        uint64_t v9 = CFDataCreate(0, v8, (CFIndex)v7);
        goto LABEL_28;
      case 5uLL:
        size_t v12 = (const void **)MEMORY[0x1E4F1D260];
LABEL_23:
        uint64_t v14 = *v12;
        goto LABEL_29;
      case 0xCuLL:
      case 0x1BuLL:
      case 0x1CuLL:
        CFStringEncoding v6 = 134217984;
        goto LABEL_7;
      case 0x13uLL:
      case 0x16uLL:
        CFStringEncoding v6 = 1536;
LABEL_7:
        uint64_t v9 = copyContentString(0, (uint64_t)&v17[1], v6);
        goto LABEL_28;
      case 0x17uLL:
      case 0x18uLL:
        cf[0] = 0;
        double v10 = SecAbsoluteTimeFromDateContentWithError(v17[0], (unsigned __int8 *)v17[1], v17[2], (CFErrorRef *)cf);
        CFTypeRef v11 = cf[0];
        if (cf[0])
        {
          cf[0] = 0;
          CFRelease(v11);
LABEL_26:
          uint64_t v14 = 0;
          uint64_t v13 = 0;
        }
        else
        {
          uint64_t v9 = CFDateCreate(0, v10);
LABEL_28:
          uint64_t v14 = v9;
LABEL_29:
          uint64_t v13 = 0;
          if (v4 && v14)
          {
            CFDictionaryAddValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v4, v14);
            uint64_t v13 = 0;
            goto LABEL_34;
          }
        }
        break;
      default:
        CFStringRef v15 = secLogObjForScope("SecWarning");
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(cf[0]) = 134217984;
          *(unint64_t *)((char *)cf + 4) = v17[0];
          _os_log_impl(&dword_18B299000, v15, OS_LOG_TYPE_DEFAULT, "unsupported value tag (%lld) found in Component Attribute dictionary, skipping", (uint8_t *)cf, 0xCu);
        }
        goto LABEL_26;
    }
  }
  if (v4) {
LABEL_34:
  }
    CFRelease(v4);
  if (v14) {
    CFRelease(v14);
  }
  return v13;
}

CFDataRef SecCertificateCopyCompressedMFiCert(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2 < 0) {
    return 0;
  }
  size_t size = 0;
  int v3 = CTCompressComputeBufferSize(*(void *)(a1 + 16), v2, &size);
  if (v3)
  {
    int v5 = v3;
LABEL_10:
    CFTypeRef v7 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v11 = v5;
      _os_log_impl(&dword_18B299000, v7, OS_LOG_TYPE_DEFAULT, "coretrust compress failed: %04x", buf, 8u);
    }
    return 0;
  }
  CFNumberRef v4 = malloc_type_malloc(size, 0xF7C031DuLL);
  if (!v4)
  {
    CFDataRef v6 = 0;
    goto LABEL_8;
  }
  int v5 = CTCompress(*(void *)(a1 + 16), *(void *)(a1 + 24), v4, size);
  if (v5 || size > 0x7FFFFFFFFFFFFFFELL)
  {
    free(v4);
    if (v5) {
      goto LABEL_10;
    }
    return 0;
  }
  CFDataRef v6 = CFDataCreate(0, v4, size);
LABEL_8:
  free(v4);
  return v6;
}

CFDataRef SecCertificateCreateWithCompressedMFiCert(const __CFData *cf)
{
  CFDataRef v1 = cf;
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (v2 == CFDataGetTypeID() && (CFDataGetLength(v1) & 0x8000000000000000) == 0)
    {
      size_t size = 0;
      BytePtr = CFDataGetBytePtr(v1);
      CFIndex Length = CFDataGetLength(v1);
      int v5 = CTDecompressComputeBufferSize((unint64_t)BytePtr, Length, &size);
      if (v5)
      {
        int v10 = v5;
        CFDataRef v6 = 0;
      }
      else
      {
        CFDataRef v6 = malloc_type_malloc(size, 0x77BDE150uLL);
        if (!v6) {
          goto LABEL_9;
        }
        CFTypeRef v7 = CFDataGetBytePtr(v1);
        CFIndex v8 = CFDataGetLength(v1);
        int v9 = CTDecompress((unint64_t)v7, v8, (unint64_t)v6, size);
        if (!v9)
        {
          if (size <= 0x7FFFFFFFFFFFFFFELL)
          {
            CFDataRef v1 = (const __CFData *)SecCertificateCreateWithBytes(0, v6, size);
LABEL_10:
            free(v6);
            return v1;
          }
LABEL_9:
          CFDataRef v1 = 0;
          goto LABEL_10;
        }
        int v10 = v9;
      }
      free(v6);
      int v11 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        int v15 = v10;
        _os_log_impl(&dword_18B299000, v11, OS_LOG_TYPE_DEFAULT, "coretrust decompress failed: %04x", buf, 8u);
      }
    }
    return 0;
  }
  return v1;
}

void *SecCertificateCreateWithPEM(int a1, CFDataRef theData)
{
  if (!theData || CFDataGetLength(theData) < 1) {
    return 0;
  }
  BytePtr = (const char *)CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  int v5 = strnstr(BytePtr, "-----BEGIN CERTIFICATE-----", Length);
  CFDataRef v6 = strnstr(BytePtr, "-----END CERTIFICATE-----", Length);
  CFTypeRef v7 = 0;
  if (!v5 || !v6 || v5 > v6) {
    return v7;
  }
  CFIndex v8 = v5 + 27;
  if (v5 + 27 < v6)
  {
    uint64_t v9 = v6 - v5 - 27;
    while (1)
    {
      int v10 = *v8;
      if (v10 != 32 && v10 != 9) {
        break;
      }
      ++v8;
      if (!--v9)
      {
        CFIndex v8 = v6;
        break;
      }
    }
  }
  int v12 = *v8;
  if (v12 == 13)
  {
    int v15 = v8[1];
    uint64_t v14 = (unsigned __int8 *)(v8 + 1);
    if (v15 == 10) {
      uint64_t v13 = v14 + 1;
    }
    else {
      uint64_t v13 = v14;
    }
    goto LABEL_21;
  }
  if (v12 != 10) {
    return 0;
  }
  uint64_t v13 = (unsigned __int8 *)(v8 + 1);
LABEL_21:
  if (v13 > (unsigned __int8 *)v6) {
    return 0;
  }
  unint64_t v16 = v6 - (char *)v13;
  unint64_t v17 = (unint64_t)(v6 - (char *)v13) >> 2;
  if (((v6 - (char *)v13) & 3) != 0) {
    ++v17;
  }
  if (!v17) {
    return 0;
  }
  size_t v18 = 3 * v17;
  if (3 * v17 >= CFDataGetLength(theData)) {
    return 0;
  }
  CFDictionaryRef v19 = malloc_type_calloc(1uLL, v18, 0x9866277FuLL);
  if (!v19) {
    return 0;
  }
  int64_t v20 = v19;
  CFTypeID v21 = SecBase64Decode_(v13, v16, v19, v18, 0, &v24, &v23);
  if (v21) {
    CFTypeRef v7 = SecCertificateCreateWithBytes(*MEMORY[0x1E4F1CF80], v20, (int64_t)v21);
  }
  else {
    CFTypeRef v7 = 0;
  }
  free(v20);
  return v7;
}

CFStringRef SecCertificateCopyPEMRepresentation(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  CFDataRef v1 = *(unsigned __int8 **)(a1 + 16);
  unint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = (2 * (((v2 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v4 = v3 + 2 * ((unint64_t)(v3 + 63) >> 6);
  unint64_t v5 = v4 - 2;
  size_t v6 = v4 + 53;
  CFTypeRef v7 = (char *)malloc_type_malloc(v4 + 53, 0x80BA09DCuLL);
  CFIndex v8 = &v7[snprintf(v7, v6, "-----BEGIN %s-----\n", "CERTIFICATE")];
  int v12 = -1431655766;
  unint64_t v9 = SecBase64Encode_(v1, v2, v8, v5, 0x40u, &v12);
  if (v12)
  {
    CFStringRef v10 = 0;
  }
  else
  {
    snprintf(&v8[v9], &v7[v6] - &v8[v9], "\n-----END %s-----\n", "CERTIFICATE");
    CFStringRef v10 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v7, v6, 0x8000100u, 0);
  }
  free(v7);
  return v10;
}

xpc_object_t SecCertificateArrayCopyXPCArray(const __CFArray *a1, __CFString **a2)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(a1);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      CFIndex v7 = 0;
      while (1)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(a1, v7);
        if (!SecCertificateAppendToXPCArray((uint64_t)ValueAtIndex, v4, a2)) {
          break;
        }
        if (v6 == ++v7) {
          return v4;
        }
      }
      xpc_release(v4);
      return 0;
    }
  }
  else
  {
    SecError(-108, a2, @"failed to create xpc_array");
  }
  return v4;
}

CFArrayRef SecCertificateCopyEscrowRoots(uint64_t a1)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  if (a1 > 5)
  {
    unint64_t v2 = &kBaseLineEscrowEnrollmentRoots;
    CFIndex v1 = 4;
  }
  else
  {
    CFIndex v1 = qword_18B419DF0[a1];
    unint64_t v2 = off_1E547ED50[a1];
  }
  MEMORY[0x1F4188790](a1);
  xpc_object_t v4 = (CFTypeRef *)((char *)v13 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  memset(v4, 170, v3);
  uint64_t v5 = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  do
  {
    CFIndex v7 = (CFIndex *)v2[v5];
    if (v7)
    {
      if (*v7 >= 1)
      {
        CFIndex v8 = (const UInt8 *)v7[1];
        if (v8)
        {
          CFDataRef v9 = CFDataCreate(v6, v8, *v7);
          if (v9)
          {
            CFDataRef v10 = v9;
            v4[v5] = SecCertificateCreateWithData(v6, v9);
            CFRelease(v10);
          }
        }
      }
    }
    ++v5;
  }
  while (v1 != v5);
  CFArrayRef v11 = CFArrayCreate(v6, v4, v1, MEMORY[0x1E4F1D510]);
  do
  {
    if (*v4) {
      CFRelease(*v4);
    }
    ++v4;
    --v1;
  }
  while (v1);
  return v11;
}

uint64_t SecCertificateCopyTrustedCTLogs()
{
  CFTypeRef cf = 0;
  uint64_t v5 = 0;
  CFAllocatorRef v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  if (gTrustd && (uint64_t v0 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 104)) != 0)
  {
    uint64_t v1 = v0(&cf);
  }
  else
  {
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 0x40000000;
    void v4[2] = __CopyTrustedCTLogs_block_invoke_2;
    v4[3] = &unk_1E547ECA0;
    v4[4] = &v5;
    securityd_send_sync_and_do(0x19u, &cf, (uint64_t)&__block_literal_global_617, (uint64_t)v4);
    uint64_t v1 = v6[3];
  }
  _Block_object_dispose(&v5, 8);
  if (cf) {
    CFRelease(cf);
  }
  return v1;
}

BOOL __CopyTrustedCTLogs_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  if (xdict && xpc_dictionary_get_value(xdict, "status") && MEMORY[0x18C12FBB0]() == MEMORY[0x1E4F14590])
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
    return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
  }
  else
  {
    return SecError(-26276, a3, @"Unable to get CT logs");
  }
}

uint64_t __CopyTrustedCTLogs_block_invoke()
{
  return 1;
}

uint64_t SecCertificateCopyCTLogForKeyID(const __CFData *a1)
{
  CFTypeRef cf = 0;
  uint64_t v11 = 0;
  int v12 = &v11;
  uint64_t v13 = 0x2000000000;
  uint64_t v14 = 0;
  if (a1 && (CFTypeID v2 = CFGetTypeID(a1), v2 == CFDataGetTypeID()))
  {
    BytePtr = CFDataGetBytePtr(a1);
    if (BytePtr && (xpc_object_t v4 = BytePtr, CFDataGetLength(a1) == 32))
    {
      if (gTrustd)
      {
        uint64_t v5 = *(uint64_t (**)(const __CFData *, CFTypeRef *))(gTrustd + 112);
        if (v5)
        {
          uint64_t v6 = v5(a1, &cf);
          goto LABEL_11;
        }
      }
      v10[0] = MEMORY[0x1E4F143A8];
      v10[1] = 0x40000000;
      v10[2] = __CopyCTLogForKeyID_block_invoke;
      unint64_t v10[3] = &__block_descriptor_tmp_628;
      v10[4] = v4;
      v9[0] = MEMORY[0x1E4F143A8];
      v9[1] = 0x40000000;
      v9[2] = __CopyCTLogForKeyID_block_invoke_2;
      v9[3] = &unk_1E547ECE8;
      void v9[4] = &v11;
      securityd_send_sync_and_do(0x1Au, &cf, (uint64_t)v10, (uint64_t)v9);
    }
    else
    {
      SecError(-50, (__CFString **)&cf, @"keyID data was not the expected length");
    }
  }
  else
  {
    SecError(-50, (__CFString **)&cf, @"keyID was not a valid CFDataRef");
  }
  uint64_t v6 = v12[3];
LABEL_11:
  _Block_object_dispose(&v11, 8);
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t __CopyCTLogForKeyID_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  return 1;
}

BOOL __CopyCTLogForKeyID_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  if (xdict && xpc_dictionary_get_value(xdict, "status") && MEMORY[0x18C12FBB0]() == MEMORY[0x1E4F14590])
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
    return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
  }
  else
  {
    return SecError(-26276, a3, @"Unable to match CT log");
  }
}

__CFArray *SecCertificateCopyiPhoneDeviceCAChain()
{
  uint64_t v0 = SecCertificateCreateWithBytes(0, &_AppleiPhoneDeviceCA, 877);
  if (!v0) {
    return 0;
  }
  uint64_t v1 = v0;
  CFTypeID v2 = SecCertificateCreateWithBytes(0, &_AppleiPhoneCA, 1015);
  if (!v2)
  {
    uint64_t v6 = 0;
    xpc_object_t v4 = v1;
LABEL_7:
    CFRelease(v4);
    return v6;
  }
  size_t v3 = v2;
  xpc_object_t v4 = SecCertificateCreateWithBytes(0, &_AppleRootCA, 1215);
  if (v4)
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 3, MEMORY[0x1E4F1D510]);
    uint64_t v6 = Mutable;
    if (Mutable)
    {
      CFArrayAppendValue(Mutable, v1);
      CFArrayAppendValue(v6, v3);
      CFArrayAppendValue(v6, v4);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  CFRelease(v1);
  CFRelease(v3);
  if (v4) {
    goto LABEL_7;
  }
  return v6;
}

BOOL SecCertificateGetDeveloperIDDate(uint64_t a1, double *a2, __CFString **a3)
{
  if (a1 && a2)
  {
    ExtensionCFNumberRef Value = SecCertificateGetExtensionValue(a1, @"1.2.840.113635.100.6.1.33");
    if (ExtensionValue)
    {
      memset(v10, 170, sizeof(v10));
      if (DERDecodeItem(ExtensionValue, v10)) {
        return SecError(-26275, a3, @"DeveloperID Date parsing: extension value failed to decode", cf);
      }
      CFTypeRef cf = 0;
      if (v10[0] != 12) {
        return SecError(-26275, a3, @"DeveloperID Date parsing: extension value wrong tag", cf);
      }
      *a2 = SecAbsoluteTimeFromDateContentWithError(24, (unsigned __int8 *)v10[1], v10[2], (CFErrorRef *)&cf);
      if (!cf) {
        return 1;
      }
      if (a3 && !*a3)
      {
        BOOL result = 0;
        *a3 = (__CFString *)cf;
      }
      else
      {
        CFRelease(cf);
        return 0;
      }
      return result;
    }
    CFStringRef v7 = @"DeveloperID Date parsing: extension not found";
    int v8 = -67880;
  }
  else
  {
    CFStringRef v7 = @"DeveloperID Date parsing: missing required input";
    int v8 = -50;
  }

  return SecError(v8, a3, v7);
}

uint64_t SecCertificateGetUnparseableKnownExtension(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 528);
  }
  else {
    return -1;
  }
}

uint64_t SecCertificateGetDuplicateExtension(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 536);
  }
  else {
    return -1;
  }
}

__CFArray *SecCertificateCopyAppleExternalRoots()
{
  uint64_t v0 = SecCertificateCreateWithBytes(0, &_AppleExternalECRootCA, 519);
  if (!v0) {
    return 0;
  }
  uint64_t v1 = v0;
  CFTypeID v2 = SecCertificateCreateWithBytes(0, &_TestAppleExternalECRootCA, 530);
  if (v2)
  {
    size_t v3 = v2;
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    uint64_t v5 = Mutable;
    if (Mutable)
    {
      CFArrayAppendValue(Mutable, v1);
      if (os_variant_allows_internal_security_policies()) {
        CFArrayAppendValue(v5, v3);
      }
    }
    CFRelease(v1);
  }
  else
  {
    uint64_t v5 = 0;
    size_t v3 = v1;
  }
  CFRelease(v3);
  return v5;
}

__CFArray *SecCertificateCopyAppleCorporateRoots()
{
  uint64_t v0 = SecCertificateCreateWithBytes(0, &_AppleCorporateRootCA, 949);
  if (!v0) {
    return 0;
  }
  uint64_t v1 = v0;
  CFTypeID v2 = SecCertificateCreateWithBytes(0, &_AppleCorporateRootCA2, 585);
  if (!v2)
  {
    uint64_t v6 = 0;
    xpc_object_t v4 = v1;
LABEL_7:
    CFRelease(v4);
    return v6;
  }
  size_t v3 = v2;
  xpc_object_t v4 = SecCertificateCreateWithBytes(0, &_AppleCorporateRootCA3, 1417);
  if (v4)
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    uint64_t v6 = Mutable;
    if (Mutable)
    {
      CFArrayAppendValue(Mutable, v1);
      CFArrayAppendValue(v6, v3);
      CFArrayAppendValue(v6, v4);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  CFRelease(v1);
  CFRelease(v3);
  if (v4) {
    goto LABEL_7;
  }
  return v6;
}

uint64_t SecCurve25519PublicKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, const __CFData *a7, __CFString **a8)
{
  int v8 = *(void **)(a1 + 16);
  BOOL v9 = v8 == &kSecEd25519PublicKeyDescriptor || v8 == &kSecEd25519PrivateKeyDescriptor;
  if (!v9 || a2 != 1 || !CFEqual(cf1, @"algid:sign:EdDSA:message-Curve25519:SHA512"))
  {
    uint64_t v14 = MEMORY[0x1E4F1D260];
    return *(void *)v14;
  }
  if (a5)
  {
LABEL_9:
    uint64_t v14 = MEMORY[0x1E4F1CFD0];
    return *(void *)v14;
  }
  CFIndex Length = CFDataGetLength(a7);
  CFDataGetBytePtr(a7);
  CFDataGetLength(a6);
  CFDataGetBytePtr(a6);
  if (Length == 64)
  {
    ccsha512_di();
    uint64_t v17 = cced25519_verify();
    if (!v17) {
      goto LABEL_9;
    }
    SecError(-67808, a8, @"Ed25519 signature verification failed (ccerr %d)", v17);
  }
  else
  {
    SecError(-67808, a8, @"Ed25519 signature verification failed (invalid signature length)");
  }
  return 0;
}

__CFData *SecCurve25519PrivateKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  CFMutableDictionaryRef Mutable = (__CFData *)*MEMORY[0x1E4F1D260];
  if (a2 != 4)
  {
    if (a2) {
      return Mutable;
    }
    uint64_t v14 = *(void **)(a1 + 16);
    BOOL v15 = v14 == &kSecEd25519PublicKeyDescriptor || v14 == &kSecEd25519PrivateKeyDescriptor;
    if (!v15 || !CFEqual(cf1, @"algid:sign:EdDSA:message-Curve25519:SHA512")) {
      return Mutable;
    }
    if (!a5)
    {
      ccsha512_di();
      ccrng();
      if (cced25519_make_pub_with_rng())
      {
        SecError(-2070, a8, @"%@: Failed to get public key from private key", a1);
        return Mutable;
      }
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
      CFDataSetLength(Mutable, 64);
      if (!Mutable)
      {
        SecError(-108, a8, @"%@: Failed to create buffer for a signature", a1);
        return Mutable;
      }
      CFDataGetLength(a6);
      CFDataGetBytePtr(a6);
      CFDataGetMutableBytePtr(Mutable);
      ccsha512_di();
      ccrng();
      uint64_t v16 = cced25519_sign_with_rng();
      cc_clear();
      if (v16)
      {
        CFRelease(Mutable);
        SecError(-50, a8, @"%@: Ed25519 signing failed (ccerr %d)", a1, v16, 0, 0, 0, 0);
        return 0;
      }
      return Mutable;
    }
    return (__CFData *)*MEMORY[0x1E4F1CFD0];
  }
  uint64_t v17 = *(void **)(a1 + 16);
  BOOL v18 = v17 == &kSecEd25519PublicKeyDescriptor || v17 == &kSecEd25519PrivateKeyDescriptor;
  if (v18 || !CFEqual(cf1, @"algid:keyexchange:ECDH") && !CFEqual(cf1, @"algid:keyexchange:ECDHC")) {
    return Mutable;
  }
  if (a5) {
    return (__CFData *)*MEMORY[0x1E4F1CFD0];
  }
  CFDataGetBytePtr(a6);
  if (CFDataGetLength(a6) == 32)
  {
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
    }
    CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
    CFDataSetLength(Mutable, 32);
    ccrng();
    CFDataGetMutableBytePtr(Mutable);
    uint64_t v19 = cccurve25519_with_rng();
    if (v19)
    {
      uint64_t v21 = v19;
      if (Mutable) {
        CFRelease(Mutable);
      }
      SecError(-50, a8, @"%@: X25519 DH failed (ccerr %d)", a1, v21);
      return 0;
    }
    CFDataSetLength(Mutable, 32);
  }
  else
  {
    SecError(-50, a8, @"X25519priv sharedsecret: bad public key");
  }
  return Mutable;
}

CFDataRef SecCurve25519PrivateKeyCopyExternalRepresentation(void *a1)
{
  uint64_t v1 = (const UInt8 *)a1[3];
  CFAllocatorRef v2 = CFGetAllocator(a1);

  return CFDataCreate(v2, v1, 32);
}

uint64_t SecCurve25519KeyCopyUnwrapKey(int a1, int a2, int a3, int a4, int a5, __CFString **a6)
{
  return 0;
}

uint64_t SecCurve25519PrivateKeyCopyPublicOctets(void *a1, CFDataRef *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  memset(v9, 0, sizeof(v9));
  xpc_object_t v4 = (void *)a1[2];
  if (v4 != &kSecEd25519PublicKeyDescriptor && v4 != &kSecEd25519PrivateKeyDescriptor)
  {
    ccrng();
    if (!cccurve25519_make_pub_with_rng()) {
      goto LABEL_9;
    }
    return 4294941020;
  }
  ccsha512_di();
  ccrng();
  if (cced25519_make_pub_with_rng()) {
    return 4294941020;
  }
LABEL_9:
  CFAllocatorRef v8 = CFGetAllocator(a1);
  *a2 = CFDataCreate(v8, (const UInt8 *)v9, 32);
  cc_clear();
  if (*a2) {
    return 0;
  }
  else {
    return 4294941021;
  }
}

CFStringRef SecCurve25519PrivateKeyCopyKeyDescription(uint64_t a1)
{
  CFAllocatorRef v2 = *(void **)(a1 + 16);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(a1);
  uint64_t v5 = *(unsigned int **)(a1 + 16);
  uint64_t v6 = *((void *)v5 + 1);
  uint64_t v7 = *v5;
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  CFAllocatorRef v8 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 80);
  if (v8) {
    CFAllocatorRef v8 = (uint64_t (*)(uint64_t))(8 * v8(a1));
  }
  BOOL v9 = v2 == &kSecEd25519PrivateKeyDescriptor || v2 == &kSecEd25519PublicKeyDescriptor;
  uint64_t v10 = "kSecX25519";
  if (v9) {
    uint64_t v10 = "kSecEd25519";
  }
  return CFStringCreateWithFormat(v3, 0, @"<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>", v10, AlgorithmId, v6, v7, v8, a1);
}

CFDictionaryRef SecCurve25519PrivateKeyCopyAttributeDictionary(void *a1)
{
  CFAllocatorRef v2 = (const UInt8 *)a1[3];
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFDataRef v4 = CFDataCreate(v3, v2, 32);
  uint64_t v5 = (void *)a1[2];
  if (v5 == &kSecEd25519PrivateKeyDescriptor || v5 == &kSecEd25519PublicKeyDescriptor) {
    uint64_t v7 = @"105";
  }
  else {
    uint64_t v7 = @"106";
  }
  CFDictionaryRef v8 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)v7, v4);
  if (v4) {
    CFRelease(v4);
  }
  return v8;
}

uint64_t SecCurve25519PrivateKeyBlockSize()
{
  return 32;
}

uint64_t SecCurve25519PrivateKeyDestroy()
{
  return cc_clear();
}

uint64_t SecCurve25519PrivateKeyInit(uint64_t a1, _OWORD *a2, uint64_t a3, int a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  CFDataRef v4 = *(_OWORD **)(a1 + 24);
  if (a4 != 5)
  {
    if (a4 != 7) {
      return 4294899625;
    }
    if (a3 == 32)
    {
      uint64_t result = 0;
      long long v6 = a2[1];
      *CFDataRef v4 = *a2;
      v4[1] = v6;
      return result;
    }
    return 4294941021;
  }
  long long v17 = 0u;
  long long v18 = 0u;
  uint64_t v7 = *(void **)(a1 + 16);
  if (v7 != &kSecEd25519PublicKeyDescriptor && v7 != &kSecEd25519PrivateKeyDescriptor)
  {
    ccrng();
    int key_pair = cccurve25519_make_key_pair();
    if (!key_pair) {
      goto LABEL_15;
    }
    int v14 = key_pair;
    uint64_t v11 = _SECKEY_LOG_9305();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
LABEL_18:

      return 4294941021;
    }
    int v15 = 67109120;
    int v16 = v14;
    int v12 = "cccurve25519_make_key_pair() failed, error %d";
LABEL_21:
    _os_log_error_impl(&dword_18B299000, v11, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&v15, 8u);
    goto LABEL_18;
  }
  ccsha512_di();
  ccrng();
  int v9 = cced25519_make_key_pair();
  if (v9)
  {
    int v10 = v9;
    uint64_t v11 = _SECKEY_LOG_9305();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    int v15 = 67109120;
    int v16 = v10;
    int v12 = "cced25519_make_key_pair() failed, error %d";
    goto LABEL_21;
  }
LABEL_15:
  cc_clear();
  return 0;
}

id _SECKEY_LOG_9305()
{
  if (_SECKEY_LOG_once_9308 != -1) {
    dispatch_once(&_SECKEY_LOG_once_9308, &__block_literal_global_9309);
  }
  uint64_t v0 = (void *)_SECKEY_LOG_log_9310;

  return v0;
}

CFDataRef SecCurve25519PublicKeyCopyExternalRepresentation(void *a1)
{
  uint64_t v1 = (const UInt8 *)a1[3];
  CFAllocatorRef v2 = CFGetAllocator(a1);

  return CFDataCreate(v2, v1, 32);
}

uint64_t SecCurve25519KeyCopyWrapKey(int a1, int a2, int a3, int a4, int a5, __CFString **a6)
{
  return 0;
}

uint64_t SecCurve25519PublicKeyCopyPublicOctets(void *a1, CFDataRef *a2)
{
  CFAllocatorRef v3 = (const UInt8 *)a1[3];
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFDataRef v5 = CFDataCreate(v4, v3, 32);
  *a2 = v5;
  if (v5) {
    return 0;
  }
  else {
    return 4294941021;
  }
}

uint64_t SecCurve25519KeyGetAlgorithmID(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  if (v1 == &kSecEd25519PrivateKeyDescriptor || v1 == &kSecEd25519PublicKeyDescriptor) {
    return 4;
  }
  else {
    return 5;
  }
}

uint64_t SecCurve25519PublicKeyCopyKeyDescription(uint64_t a1)
{
  CFAllocatorRef v2 = *(void **)(a1 + 16);
  CFAllocatorRef v3 = NSString;
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(a1);
  CFDataRef v5 = *(unsigned int **)(a1 + 16);
  uint64_t v6 = *((void *)v5 + 1);
  uint64_t v7 = *v5;
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  CFDictionaryRef v8 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 80);
  if (v8) {
    CFDictionaryRef v8 = (uint64_t (*)(uint64_t))(8 * v8(a1));
  }
  BOOL v9 = v2 == &kSecEd25519PrivateKeyDescriptor || v2 == &kSecEd25519PublicKeyDescriptor;
  int v10 = "kSecX25519";
  if (v9) {
    int v10 = "kSecEd25519";
  }
  [v3 stringWithFormat:@"<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>", v10, AlgorithmId, v6, v7, v8, a1];
  return objc_claimAutoreleasedReturnValue();
}

__CFDictionary *SecCurve25519PublicKeyCopyAttributeDictionary(void *a1)
{
  uint64_t v1 = (void *)a1[2];
  if (v1 == &kSecEd25519PrivateKeyDescriptor || v1 == &kSecEd25519PublicKeyDescriptor) {
    CFAllocatorRef v3 = @"105";
  }
  else {
    CFAllocatorRef v3 = @"106";
  }
  CFDictionaryRef v4 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)v3, 0);
  CFStringRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v4);
  CFDictionarySetValue(MutableCopy, @"drve", (const void *)*MEMORY[0x1E4F1CFC8]);
  if (v4) {
    CFRelease(v4);
  }
  return MutableCopy;
}

uint64_t SecCurve25519PublicKeyBlockSize()
{
  return 32;
}

uint64_t SecCurve25519PublicKeyDestroy()
{
  return cc_clear();
}

uint64_t SecCurve25519PublicKeyInit(uint64_t a1, _OWORD *a2, uint64_t a3, int a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *(_OWORD **)(a1 + 24);
  if (a4 != 6)
  {
    if (a4 != 7) {
      return 4294967246;
    }
    if (a3 == 32)
    {
      uint64_t result = 0;
      long long v6 = a2[1];
      *CFDictionaryRef v4 = *a2;
      v4[1] = v6;
      return result;
    }
    return 4294941021;
  }
  if (a3 != 32) {
    return 4294941021;
  }
  uint64_t v7 = *(void **)(a1 + 16);
  if (v7 == &kSecEd25519PublicKeyDescriptor || v7 == &kSecEd25519PrivateKeyDescriptor)
  {
    ccsha512_di();
    ccrng();
    uint64_t result = cced25519_make_pub_with_rng();
    if (!result) {
      return result;
    }
    int v9 = result;
    int v10 = _SECKEY_LOG_9305();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    int v13 = 67109120;
    int v14 = v9;
    uint64_t v11 = "cced25519_make_pub_with_rng() failed, error %d";
    goto LABEL_21;
  }
  ccrng();
  uint64_t result = cccurve25519_make_pub_with_rng();
  if (result)
  {
    int v12 = result;
    int v10 = _SECKEY_LOG_9305();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
LABEL_18:

      return 4294941021;
    }
    int v13 = 67109120;
    int v14 = v12;
    uint64_t v11 = "cccurve25519_make_pub_with_rng() failed, error %d";
LABEL_21:
    _os_log_error_impl(&dword_18B299000, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v13, 8u);
    goto LABEL_18;
  }
  return result;
}

uint64_t curve25519KeyGeneratePair(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  uint64_t v8 = SecCFAllocatorZeroize_sAllocator;
  if (a4 == 4) {
    int v9 = &kSecEd25519PrivateKeyDescriptor;
  }
  else {
    int v9 = &kSecX25519PrivateKeyDescriptor;
  }
  int v10 = SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)v9, a1, 0, 5);
  if (!v10) {
    return 4294967246;
  }
  uint64_t v11 = v10;
  if (a4 == 4) {
    int v12 = &kSecEd25519PublicKeyDescriptor;
  }
  else {
    int v12 = &kSecX25519PublicKeyDescriptor;
  }
  int v13 = SecKeyCreate(v8, (uint64_t)v12, v10[3], 32, 6);
  if (!v13)
  {
    uint64_t v14 = 4294967246;
LABEL_18:
    CFRelease(v11);
    return v14;
  }
  if (a2)
  {
    *a2 = v13;
    int v13 = 0;
  }
  if (a3)
  {
    *a3 = v11;
    uint64_t v11 = 0;
  }
  if (v13) {
    CFRelease(v13);
  }
  uint64_t v14 = 0;
  uint64_t result = 0;
  if (v11) {
    goto LABEL_18;
  }
  return result;
}

CFDataRef SecGenerateCertificateRequestWithParameters(const __CFString ***a1, const __CFDictionary *a2, __SecKey *a3, __SecKey *a4)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  CFDictionaryRef v4 = a1;
  if (!*a1) {
    return 0;
  }
  char v69 = 0;
  uint64_t v8 = PORT_NewArena(1024);
  CFErrorRef error = 0;
  if (!v8)
  {
    long long v17 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v17, OS_LOG_TYPE_DEFAULT, "csr: pool allocation failure", buf, 2u);
    }
    return 0;
  }
  int v9 = v8;
  CFTypeRef cf = a3;
  long long v67 = 0u;
  long long v65 = 0u;
  memset(v66, 0, sizeof(v66));
  *(_OWORD *)unint64_t v64 = 0u;
  memset(v63, 0, sizeof(v63));
  char v60 = 0;
  *(void *)long long buf = 1;
  uint64_t v62 = &v60;
  int v10 = *v4;
  if (*v4)
  {
    unsigned int v11 = 0;
    unsigned int v12 = 0;
    int v13 = v4;
    do
    {
      if (*v10)
      {
        uint64_t v14 = (uint64_t *)(v10 + 3);
        do
        {
          ++v12;
          uint64_t v15 = *v14;
          v14 += 3;
        }
        while (v15);
      }
      ++v12;
      ++v11;
      int v16 = v13[1];
      ++v13;
      int v10 = v16;
    }
    while (v16);
  }
  else
  {
    unsigned int v12 = 0;
    unsigned int v11 = 0;
  }
  key = a4;
  if (v12 <= 1) {
    uint64_t v20 = 1;
  }
  else {
    uint64_t v20 = v12;
  }
  if (v11 <= 1) {
    unsigned int v21 = 1;
  }
  else {
    unsigned int v21 = v11;
  }
  uint64_t v22 = (char *)malloc_type_malloc(8 * (v20 + 4 * v20), 0x10100404675C823uLL);
  int v23 = malloc_type_malloc(8 * v20, 0x2004093837F09uLL);
  uint64_t v24 = (char *)malloc_type_malloc(8 * v21, 0x80040B8603338uLL);
  uint64_t v25 = malloc_type_malloc(8 * (v11 + 1), 0x2004093837F09uLL);
  if (*v4)
  {
    int v26 = 0;
    LODWORD(v27) = 0;
    unint64_t v54 = v24;
    unint64_t v55 = v25;
    while (1)
    {
      long long v28 = &v24[8 * v26];
      *(void *)long long v28 = &v23[v27];
      v25[v26] = v28;
      CFStringRef v29 = **v4;
      if (v29) {
        break;
      }
      uint64_t v33 = v27;
LABEL_30:
      ++v26;
      LODWORD(v27) = v27 + 1;
      v23[v33] = 0;
      long long v34 = v4[1];
      ++v4;
      if (!v34) {
        goto LABEL_36;
      }
    }
    CFDictionaryRef v30 = a2;
    long long v31 = *v4 + 3;
    while ((make_nss_atv((uint64_t)v9, v29, *(v31 - 1), *((unsigned __int8 *)v31 - 16), (uint64_t)&v22[40 * v27], (__CFString **)&error) & 1) != 0)
    {
      v23[v27] = &v22[40 * v27];
      uint64_t v27 = (v27 + 1);
      CFStringRef v32 = *v31;
      v31 += 3;
      CFStringRef v29 = v32;
      if (!v32)
      {
        uint64_t v33 = v27;
        uint64_t v24 = v54;
        uint64_t v25 = v55;
        a2 = v30;
        goto LABEL_30;
      }
    }
    long long v35 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v70 = 0;
      _os_log_impl(&dword_18B299000, v35, OS_LOG_TYPE_DEFAULT, "csr: failed to encode atv", v70, 2u);
    }
    long long v36 = 0;
    CFDataRef v37 = 0;
    CFDataRef v38 = 0;
    CFDataRef v18 = 0;
    uint64_t v24 = v54;
    uint64_t v39 = v55;
    goto LABEL_55;
  }
  int v26 = 0;
LABEL_36:
  v25[v26] = 0;
  uint64_t v39 = v25;
  *(void *)&v63[0] = v25;
  if (!key || (long long v36 = SecKeyCopyPublicKey(key)) == 0)
  {
    CFNumberRef v40 = secLogObjForScope("csr");
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t v70 = 0;
      _os_log_debug_impl(&dword_18B299000, v40, OS_LOG_TYPE_DEBUG, "unable to create public key from private, using input public key", v70, 2u);
    }
    long long v36 = cf;
    if (!cf)
    {
      long long v46 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v70 = 0;
        _os_log_impl(&dword_18B299000, v46, OS_LOG_TYPE_DEFAULT, "csr: failed to get public key", v70, 2u);
      }
      long long v36 = 0;
      CFDataRef v37 = 0;
      CFDataRef v38 = 0;
      CFDataRef v18 = 0;
      goto LABEL_55;
    }
    CFRetain(cf);
  }
  int v41 = v24;
  CFDataRef public_key = make_public_key(v36, (uint64_t)v63 + 8, &v69, &error);
  if (!public_key)
  {
    int64_t v49 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v70 = 0;
      _os_log_impl(&dword_18B299000, v49, OS_LOG_TYPE_DEFAULT, "csr: failed to encode public key", v70, 2u);
    }
    CFDataRef v37 = 0;
    CFDataRef v38 = 0;
    goto LABEL_76;
  }
  CFDataRef v38 = public_key;
  *((void *)&v65 + 1) = nss_attributes_from_parameters_dict((uint64_t)v9, a2);
  SecCmsArraySortByDER(*((int8x16_t **)&v65 + 1), (uint64_t)&kSecAsn1AttributeTemplate, 0);
  CFIndex v58 = 0;
  uint64_t v59 = 0;
  if (!SEC_ASN1EncodeItem((uint64_t)v9, &v58, (uint64_t)buf, (uint64_t)&kSecAsn1CertRequestInfoTemplate))
  {
    uint64_t v43 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v70 = 0;
      _os_log_impl(&dword_18B299000, v43, OS_LOG_TYPE_DEFAULT, "csr: failed to encode request info", v70, 2u);
    }
  }
  if (a2) {
    CFNumberRef Value = CFDictionaryGetValue(a2, (const void *)kSecCMSSignHashAlgorithm);
  }
  else {
    CFNumberRef Value = 0;
  }
  CFDataRef signature = make_signature(v59, v58, key, Value, v66, (__CFString **)&error);
  if (!signature)
  {
    int64_t v50 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v70 = 0;
      _os_log_impl(&dword_18B299000, v50, OS_LOG_TYPE_DEFAULT, "csr: failed to create CSR signature", v70, 2u);
    }
    CFDataRef v37 = 0;
    goto LABEL_76;
  }
  CFDataRef v37 = signature;
  *((void *)&v67 + 1) = CFDataGetBytePtr(signature);
  *(void *)&long long v67 = 8 * CFDataGetLength(v37);
  CFIndex v56 = 0;
  unint64_t v57 = 0;
  if (!SEC_ASN1EncodeItem((uint64_t)v9, &v56, (uint64_t)buf, (uint64_t)&kSecAsn1CertRequestTemplate))
  {
    CFRange v51 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v70 = 0;
      _os_log_impl(&dword_18B299000, v51, OS_LOG_TYPE_DEFAULT, "csr: failed to encode cert request", v70, 2u);
    }
LABEL_76:
    CFDataRef v18 = 0;
    uint64_t v24 = v41;
    goto LABEL_55;
  }
  uint64_t v24 = v41;
  CFDataRef v18 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v57, v56);
LABEL_55:
  if (v69) {
    free(v64[0]);
  }
  PORT_FreeArena(v9, 1);
  if (v36) {
    CFRelease(v36);
  }
  if (v38) {
    CFRelease(v38);
  }
  if (v37) {
    CFRelease(v37);
  }
  free(v22);
  free(v23);
  free(v24);
  free(v39);
  if (error)
  {
    uint64_t v47 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v70 = 138412290;
      CFErrorRef v71 = error;
      _os_log_impl(&dword_18B299000, v47, OS_LOG_TYPE_DEFAULT, "csr: cert request encoding failed: %@", v70, 0xCu);
    }
    CFErrorRef v48 = error;
    if (error)
    {
      CFErrorRef error = 0;
      CFRelease(v48);
    }
  }
  return v18;
}

uint64_t make_nss_atv(uint64_t a1, const __CFString *a2, const __CFString *cf, int a4, uint64_t a5, __CFString **a6)
{
  CFTypeID v12 = CFGetTypeID(cf);
  if (v12 == CFStringGetTypeID())
  {
    CFIndex Length = CFStringGetLength(cf);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    uint64_t v15 = (char *)PORT_ArenaAlloc(a1, MaximumSizeForEncoding);
    if (!CFStringGetCString(cf, v15, MaximumSizeForEncoding, 0x600u))
    {
      if (!CFStringGetCString(cf, v15, MaximumSizeForEncoding, 0x8000100u))
      {
        SecError(-50, a6, @"ATV value is not a Printable or UTF8 string");
        return 0;
      }
      char v16 = 12;
      if (a4 && a4 != 12)
      {
        SecError(-50, a6, @"ATV input type does not match value encoding");
        return 0;
      }
      goto LABEL_26;
    }
    if (a4 != 19)
    {
      char v16 = a4;
      if (a4)
      {
LABEL_26:
        size_t v21 = strlen(v15);
        LOBYTE(a4) = v16;
        goto LABEL_27;
      }
    }
    if (!a2) {
      goto LABEL_22;
    }
    CFTypeID v17 = CFGetTypeID(a2);
    if (v17 == CFStringGetTypeID())
    {
      if (!CFEqual(@"1.2.840.113549.1.9.1", a2) && CFStringCompare(@"EMAIL", a2, 1uLL))
      {
LABEL_22:
        int v19 = 0;
        char v18 = 19;
LABEL_23:
        if (printable_string(cf, v19)) {
          char v16 = v18;
        }
        else {
          char v16 = 12;
        }
        goto LABEL_26;
      }
    }
    else
    {
      CFTypeID v22 = CFGetTypeID(a2);
      if (v22 != CFDataGetTypeID()) {
        goto LABEL_22;
      }
      if (CFDataGetLength((CFDataRef)a2) != 9) {
        goto LABEL_22;
      }
      BytePtr = CFDataGetBytePtr((CFDataRef)a2);
      if (memcmp(BytePtr, &_oidEmailAddress, 9uLL)) {
        goto LABEL_22;
      }
    }
    char v18 = 22;
    int v19 = 1;
    goto LABEL_23;
  }
  CFTypeID v20 = CFGetTypeID(cf);
  if (v20 != CFDataGetTypeID())
  {
    SecError(-50, a6, @"ATV value of unsupported type");
    return 0;
  }
  size_t v21 = CFDataGetLength((CFDataRef)cf);
  uint64_t v15 = (char *)CFDataGetBytePtr((CFDataRef)cf);
LABEL_27:
  CFIndex v30 = 0;
  CFTypeID v24 = CFGetTypeID(a2);
  if (v24 == CFStringGetTypeID())
  {
    if (CFEqual(@"CN", a2))
    {
      uint64_t v25 = &oidCommonName;
LABEL_46:
      uint64_t data = (uint64_t)v25->data;
      CFIndex v27 = v25->length;
      goto LABEL_47;
    }
    if (CFEqual(@"C", a2))
    {
      uint64_t v25 = &oidCountryName;
      goto LABEL_46;
    }
    if (CFEqual(@"ST", a2))
    {
      uint64_t v25 = &oidStateOrProvinceName;
      goto LABEL_46;
    }
    if (CFEqual(@"L", a2))
    {
      uint64_t v25 = &oidLocalityName;
      goto LABEL_46;
    }
    if (CFEqual(@"O", a2))
    {
      uint64_t v25 = &oidOrganizationName;
      goto LABEL_46;
    }
    if (CFEqual(@"OU", a2))
    {
      uint64_t v25 = &oidOrganizationalUnitName;
      goto LABEL_46;
    }
    if (CFEqual(@"EMAIL", a2))
    {
      uint64_t v25 = &oidEmailAddress;
      goto LABEL_46;
    }
    uint64_t data = oid_der_data(a1, a2, &v30);
    if (data)
    {
      CFIndex v27 = v30;
      goto LABEL_47;
    }
    SecError(-26276, a6, @"ATV OID encode failed for %@", a2);
    return 0;
  }
  CFTypeID v26 = CFGetTypeID(a2);
  if (v26 != CFDataGetTypeID())
  {
    SecError(-50, a6, @"ATV OID of unsupported type");
    return 0;
  }
  CFIndex v27 = CFDataGetLength((CFDataRef)a2);
  uint64_t data = (uint64_t)CFDataGetBytePtr((CFDataRef)a2);
LABEL_47:
  *(void *)a5 = v27;
  *(void *)(a5 + 8) = data;
  *(void *)(a5 + 16) = v21;
  *(void *)(a5 + 24) = v15;
  *(unsigned char *)(a5 + 32) = a4;
  *(_DWORD *)(a5 + 33) = -1431655766;
  uint64_t result = 1;
  *(_DWORD *)(a5 + 36) = -1431655766;
  return result;
}

CFDataRef make_public_key(__SecKey *a1, uint64_t a2, char *a3, CFErrorRef *error)
{
  if (!a1) {
    return 0;
  }
  CFDataRef v8 = SecKeyCopyExternalRepresentation(a1, error);
  if (v8)
  {
    if (SecKeyGetAlgorithmId((uint64_t)a1) == 1)
    {
      char v9 = 0;
      *(void *)a2 = 9;
      *(void *)(a2 + 8) = &_oidRsa;
      *(_OWORD *)(a2 + 16) = asn1_null;
LABEL_14:
      *a3 = v9;
      *(void *)(a2 + 40) = CFDataGetBytePtr(v8);
      *(void *)(a2 + 32) = 8 * CFDataGetLength(v8);
      return v8;
    }
    if (SecKeyGetAlgorithmId((uint64_t)a1) == 3)
    {
      *(void *)a2 = 7;
      *(void *)(a2 + 8) = &_oidEcPubKey;
      int NamedCurve = SecECKeyGetNamedCurve(a1);
      switch(NamedCurve)
      {
        case 25:
          unsigned int v11 = &oidAnsip521r1;
          size_t v12 = 5;
          uint64_t v13 = 7;
          size_t v14 = 7;
          malloc_type_id_t v15 = 3543760140;
          goto LABEL_13;
        case 24:
          unsigned int v11 = &oidAnsip384r1;
          size_t v12 = 5;
          uint64_t v13 = 7;
          size_t v14 = 7;
          malloc_type_id_t v15 = 2957968736;
          goto LABEL_13;
        case 23:
          unsigned int v11 = &oidEcPrime256v1;
          size_t v12 = 8;
          uint64_t v13 = 10;
          size_t v14 = 10;
          malloc_type_id_t v15 = 26031547;
LABEL_13:
          char v16 = malloc_type_malloc(v14, v15);
          memcpy(v16 + 2, v11->data, v12);
          *char v16 = 6;
          v16[1] = v13 - 2;
          *(void *)(a2 + 16) = v13;
          *(void *)(a2 + 24) = v16;
          char v9 = 1;
          goto LABEL_14;
      }
      SecError(-4, (__CFString **)error, @"unsupported EC curve");
    }
    else
    {
      SecError(-4, (__CFString **)error, @"unsupported key algorithmId");
    }
    CFRelease(v8);
    return 0;
  }
  return v8;
}

void *nss_attributes_from_parameters_dict(uint64_t a1, CFDictionaryRef theDict)
{
  if (!theDict) {
    return 0;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"csrChallengePassword");
  CFStringRef v5 = Value;
  if (Value)
  {
    CFIndex Length = CFStringGetLength(Value);
    unint64_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    CFIndex v8 = MaximumSizeForEncoding;
    if (MaximumSizeForEncoding <= 1) {
      unint64_t v9 = 1;
    }
    else {
      unint64_t v9 = MaximumSizeForEncoding;
    }
    int v10 = (char *)PORT_ArenaAlloc(a1, v9);
    unsigned int v11 = v10;
    if (v10) {
      bzero(v10, v9);
    }
    if (CFStringGetCString(v5, v11, v8, 0x600u))
    {
      if (printable_string(v5, 0)) {
        size_t v12 = kSecAsn1PrintableStringTemplate;
      }
      else {
        size_t v12 = kSecAsn1UTF8StringTemplate;
      }
    }
    else
    {
      if (!CFStringGetCString(v5, v11, v8, 0x8000100u))
      {
        CFTypeID v24 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v39[0]) = 0;
          uint64_t v25 = "csr: unable to get challenge bytes";
          long long v34 = (uint8_t *)v39;
LABEL_51:
          _os_log_impl(&dword_18B299000, v24, OS_LOG_TYPE_DEFAULT, v25, v34, 2u);
          return 0;
        }
        return 0;
      }
      size_t v12 = kSecAsn1UTF8StringTemplate;
    }
    CFTypeID v17 = (void *)PORT_ArenaAlloc(a1, 0x10uLL);
    char v18 = v17;
    if (v17)
    {
      void *v17 = 0;
      v17[1] = 0;
    }
    v39[0] = strlen(v11);
    v39[1] = v11;
    if (!SEC_ASN1EncodeItem(a1, v18, (uint64_t)v39, (uint64_t)v12))
    {
      CFTypeID v24 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        return 0;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v25 = "csr: failed to encode challenge";
      goto LABEL_50;
    }
    int v19 = (void *)PORT_ArenaAlloc(a1, 0x10uLL);
    malloc_type_id_t v15 = v19;
    if (v19) {
      v19[1] = 0;
    }
    void *v19 = v18;
    unsigned int v16 = 1;
    size_t v14 = &pkcs9ChallengePassword_9417;
    uint64_t v13 = 9;
  }
  else
  {
    uint64_t v13 = 0;
    size_t v14 = 0;
    malloc_type_id_t v15 = 0;
    unsigned int v16 = 0;
  }
  v39[0] = 0;
  if ((extensions_from_parameters(a1, theDict, v39, 0) & 1) == 0)
  {
    CFTypeID v24 = secLogObjForScope("SecError");
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
      return 0;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v25 = "csr: failed to encode extensions";
LABEL_50:
    long long v34 = buf;
    goto LABEL_51;
  }
  uint64_t v20 = v39[0];
  if (!v39[0])
  {
    uint64_t v36 = 0;
    CFDataRef v37 = 0;
    int v23 = 0;
    goto LABEL_32;
  }
  size_t v21 = (void *)PORT_ArenaAlloc(a1, 0x10uLL);
  CFTypeID v22 = v21;
  if (v21)
  {
    *size_t v21 = 0;
    v21[1] = 0;
  }
  if (!SEC_ASN1EncodeItem(a1, v21, (uint64_t)v39, (uint64_t)&kSecAsn1SequenceOfCertExtensionTemplate))
  {
    CFTypeID v24 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v25 = "csr: failed to encode extension attributes";
      goto LABEL_50;
    }
    return 0;
  }
  int v23 = (void *)PORT_ArenaAlloc(a1, 0x10uLL);
  *int v23 = v22;
  v23[1] = 0;
  ++v16;
  uint64_t v36 = 9;
  CFDataRef v37 = &pkcs9ExtensionsRequested;
LABEL_32:
  if (8 * (unint64_t)(v16 + 1) <= 1) {
    unint64_t v26 = 1;
  }
  else {
    unint64_t v26 = 8 * (v16 + 1);
  }
  CFIndex v27 = (void *)PORT_ArenaAlloc(a1, v26);
  long long v28 = v27;
  if (v27) {
    bzero(v27, v26);
  }
  if (24 * (unint64_t)v16 <= 1) {
    unint64_t v29 = 1;
  }
  else {
    unint64_t v29 = 24 * v16;
  }
  CFIndex v30 = (char *)PORT_ArenaAlloc(a1, v29);
  long long v31 = v30;
  if (v30) {
    bzero(v30, v29);
  }
  if (v5)
  {
    CFStringRef v32 = (uint64_t *)&v31[24 * --v16];
    *CFStringRef v32 = v13;
    v32[1] = (uint64_t)v14;
    v32[2] = (uint64_t)v15;
    v28[v16] = v32;
  }
  if (v20)
  {
    uint64_t v33 = (uint64_t *)&v31[24 * v16 - 24];
    *uint64_t v33 = v36;
    v33[1] = (uint64_t)v37;
    v33[2] = (uint64_t)v23;
    v28[v16 - 1] = v33;
  }
  return v28;
}

CFDataRef make_signature(const UInt8 *a1, CFIndex a2, __SecKey *a3, const void *a4, DERSize *a5, __CFString **a6)
{
  uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)a3);
  if (AlgorithmId == 3)
  {
    if (!a4 || kSecCMSHashingAlgorithmSHA256 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA256))
    {
      uint64_t v20 = &oidSha256Ecdsa;
      size_t v21 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA256;
    }
    else if (kSecCMSHashingAlgorithmSHA384 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA384))
    {
      uint64_t v20 = &oidSha384Ecdsa;
      size_t v21 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA384;
    }
    else
    {
      if (!kSecCMSHashingAlgorithmSHA512 || !CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA512))
      {
        CFStringRef v15 = 0;
LABEL_18:
        a5[2] = 0;
        a5[3] = 0;
        if (v15) {
          goto LABEL_9;
        }
LABEL_19:
        SecError(-4, a6, @"unsupported key or hashing algorithm");
        return 0;
      }
      uint64_t v20 = &oidSha512Ecdsa;
      size_t v21 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA512;
    }
    CFStringRef v15 = *v21;
    int v23 = v20;
    uint64_t data = v20->data;
    *a5 = v23->length;
    a5[1] = (DERSize)data;
    goto LABEL_18;
  }
  if (AlgorithmId != 1) {
    goto LABEL_19;
  }
  if (!a4 || kSecCMSHashingAlgorithmSHA1 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA1))
  {
    uint64_t v13 = &oidSha1Rsa;
    size_t v14 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA1;
LABEL_7:
    CFStringRef v15 = *v14;
    CFTypeID v17 = v13;
    unsigned int v16 = v13->data;
    *a5 = v17->length;
    a5[1] = (DERSize)v16;
    goto LABEL_8;
  }
  if (kSecCMSHashingAlgorithmSHA256 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA256))
  {
    uint64_t v13 = &oidSha256Rsa;
    size_t v14 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA256;
    goto LABEL_7;
  }
  if (kSecCMSHashingAlgorithmSHA384 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA384))
  {
    uint64_t v13 = &oidSha384Rsa;
    size_t v14 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA384;
    goto LABEL_7;
  }
  if (kSecCMSHashingAlgorithmSHA512 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA512))
  {
    uint64_t v13 = &oidSha512Rsa;
    size_t v14 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA512;
    goto LABEL_7;
  }
  CFStringRef v15 = 0;
LABEL_8:
  *((_OWORD *)a5 + 1) = asn1_null;
  if (!v15) {
    goto LABEL_19;
  }
LABEL_9:
  CFDataRef Signature = 0;
  if (a1)
  {
    if (a2)
    {
      CFDataRef v19 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, a2, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
      CFDataRef Signature = SecKeyCreateSignature(a3, v15, v19, (CFErrorRef *)a6);
      if (v19) {
        CFRelease(v19);
      }
    }
  }
  return Signature;
}

uint64_t printable_string(const __CFString *a1, int a2)
{
  LODWORD(v2) = a2;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFCharacterSetRef v5 = CFCharacterSetCreateWithCharactersInString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 '()+,-./:=?@");
  CFCharacterSetRef InvertedSet = CFCharacterSetCreateInvertedSet(v4, v5);
  CFCharacterSetRef v7 = CFCharacterSetCreateWithCharactersInString(v4, @"@");
  v9.size_t length = CFStringGetLength(a1);
  v9.location = 0;
  if (CFStringFindCharacterFromSet(a1, InvertedSet, v9, 0, 0))
  {
    uint64_t v2 = 0;
    if (!v5) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  v10.size_t length = CFStringGetLength(a1);
  v10.location = 0;
  if (CFStringFindCharacterFromSet(a1, v7, v10, 0, 0)) {
    uint64_t v2 = v2;
  }
  else {
    uint64_t v2 = 1;
  }
  if (v5) {
LABEL_3:
  }
    CFRelease(v5);
LABEL_4:
  if (InvertedSet) {
    CFRelease(InvertedSet);
  }
  if (v7) {
    CFRelease(v7);
  }
  return v2;
}

uint64_t extensions_from_parameters(uint64_t a1, const __CFDictionary *a2, void *a3, __CFString **a4)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = PORT_ArenaAlloc(a1, 0x58uLL);
  CFRange v9 = (void *)v8;
  if (v8)
  {
    *(void *)(v8 + 80) = 0;
    *(_OWORD *)(v8 + 48) = 0u;
    *(_OWORD *)(v8 + 64) = 0u;
    *(_OWORD *)(v8 + 16) = 0u;
    *(_OWORD *)(v8 + 32) = 0u;
    *(_OWORD *)uint64_t v8 = 0u;
  }
  CFRange v10 = (_OWORD *)PORT_ArenaAlloc(a1, 0x1E0uLL);
  unsigned int v11 = v10;
  if (v10)
  {
    v10[28] = 0u;
    v10[29] = 0u;
    v10[26] = 0u;
    v10[27] = 0u;
    v10[24] = 0u;
    v10[25] = 0u;
    v10[22] = 0u;
    v10[23] = 0u;
    v10[20] = 0u;
    v10[21] = 0u;
    v10[18] = 0u;
    v10[19] = 0u;
    v10[16] = 0u;
    v10[17] = 0u;
    v10[14] = 0u;
    v10[15] = 0u;
    v10[12] = 0u;
    v10[13] = 0u;
    v10[10] = 0u;
    v10[11] = 0u;
    v10[8] = 0u;
    v10[9] = 0u;
    v10[6] = 0u;
    v10[7] = 0u;
    v10[4] = 0u;
    void v10[5] = 0u;
    v10[2] = 0u;
    unint64_t v10[3] = 0u;
    *CFRange v10 = 0u;
    v10[1] = 0u;
  }
  CFTypeRef cf = 0;
  unint64_t Value = (unint64_t)CFDictionaryGetValue(a2, @"basicConstraintsCA");
  CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue(a2, @"basicConstraints");
  if (Value | (unint64_t)v13)
  {
    if (Value == *MEMORY[0x1E4F1CFC8] && v13 != 0)
    {
      SecError(-50, (__CFString **)&cf, @"non-CA cert does not support path len");
LABEL_83:
      if (cf)
      {
        uint64_t v72 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(context) = 138412290;
          *(void *)((char *)&context + 4) = cf;
          _os_log_impl(&dword_18B299000, v72, OS_LOG_TYPE_DEFAULT, "csr: extension encoding failed: %@", (uint8_t *)&context, 0xCu);
        }
        uint64_t v73 = (__CFString *)cf;
        if (a4)
        {
          if (cf)
          {
            CFRetain(cf);
            v74 = (__CFString *)cf;
          }
          else
          {
            v74 = 0;
          }
          *a4 = v73;
          uint64_t v73 = v74;
        }
        if (v73)
        {
          CFTypeRef cf = 0;
          CFRelease(v73);
        }
      }
      return 0;
    }
    if (Value == *MEMORY[0x1E4F1CFC8]) {
      CFStringRef v15 = &asn1_false;
    }
    else {
      CFStringRef v15 = &asn1_true;
    }
    long long context = *v15;
    uint64_t v85 = 0;
    uint64_t v86 = 0;
    LOBYTE(v82) = -86;
    if (v13)
    {
      LODWORD(valuePtr) = 0;
      if (!CFNumberGetValue(v13, kCFNumberIntType, &valuePtr))
      {
        SecError(-50, (__CFString **)&cf, @"failed to get basic constraints path length value");
        goto LABEL_83;
      }
      if (valuePtr <= 0xFF)
      {
        LOBYTE(v82) = valuePtr;
        uint64_t v85 = 1;
        uint64_t v86 = (__CFString **)&v82;
      }
    }
    *unsigned int v11 = 3;
    v11[1] = &_oidBasicConstraints;
    *((_OWORD *)v11 + 1) = asn1_true;
    if (!SEC_ASN1EncodeItem(a1, v11 + 4, (uint64_t)&context, (uint64_t)&kSecAsn1BasicConstraintsTemplate))
    {
      SecError(-50, (__CFString **)&cf, @"failed to encode basic constraints extension");
      goto LABEL_83;
    }
    unsigned int v16 = 1;
  }
  else
  {
    unsigned int v16 = 0;
  }
  CFDictionaryRef v17 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"subjectAltName");
  if (v17)
  {
    CFDictionaryRef v18 = v17;
    CFTypeID v19 = CFGetTypeID(v17);
    if (v19 != CFDictionaryGetTypeID())
    {
      SecError(-50, (__CFString **)&cf, @"wrong value type for subjectAltName");
      goto LABEL_83;
    }
    long long valuePtr = 0uLL;
    long long context = (unint64_t)a1;
    uint64_t v85 = 0;
    uint64_t v86 = a4;
    CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)make_general_names, &context);
    if (8 * (unint64_t)(v85 + 1) <= 1) {
      unint64_t v20 = 1;
    }
    else {
      unint64_t v20 = 8 * (v85 + 1);
    }
    size_t v21 = (void *)PORT_ArenaAlloc(a1, v20);
    CFTypeID v22 = v21;
    if (v21) {
      bzero(v21, v20);
    }
    int v23 = &v11[6 * v16];
    if (v85)
    {
      uint64_t v24 = 0;
      uint64_t v25 = 16 * v85;
      unint64_t v26 = v22;
      do
      {
        *v26++ = *((void *)&context + 1) + v24;
        v24 += 16;
      }
      while (v25 != v24);
    }
    int v82 = v22;
    if (!SEC_ASN1EncodeItem(a1, &valuePtr, (uint64_t)&v82, (uint64_t)kSecAsn1SequenceOfAnyTemplate)) {
      SecError(-26276, a4, @"failed to encode SubjectAltName");
    }
    *((_OWORD *)v23 + 2) = valuePtr;
    *int v23 = 3;
    v23[1] = &_oidSubjectAltName;
    ++v16;
  }
  CFDictionaryRef theDict = a2;
  CFArrayRef v27 = (const __CFArray *)CFDictionaryGetValue(a2, @"certificateEKUs");
  if (v27)
  {
    CFArrayRef v28 = v27;
    CFTypeID v29 = CFGetTypeID(v27);
    if (v29 != CFArrayGetTypeID())
    {
      SecError(-50, (__CFString **)&cf, @"wrong value type for EKU");
      goto LABEL_83;
    }
    unsigned int v76 = v16;
    uint64_t v77 = a3;
    uint64_t v78 = a4;
    long long context = 0uLL;
    CFIndex Count = CFArrayGetCount(v28);
    uint64_t v31 = Count;
    if ((unint64_t)(8 * Count + 8) <= 1) {
      unint64_t v32 = 1;
    }
    else {
      unint64_t v32 = 8 * Count + 8;
    }
    uint64_t v33 = (void *)PORT_ArenaAlloc(a1, v32);
    long long v34 = v33;
    if (v33) {
      bzero(v33, v32);
    }
    if (v31 >= 1)
    {
      CFIndex v35 = 0;
      unsigned int v36 = 1;
      while (1)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v28, v35);
        if (!ValueAtIndex
          || (v38 = ValueAtIndex, CFTypeID v39 = CFGetTypeID(ValueAtIndex), v39 != CFStringGetTypeID())
          || !SecCertificateIsOidString(v38))
        {
          CFStringRef v70 = @"eku is not an OID";
          goto LABEL_80;
        }
        CFArrayRef OidDataFromString = SecCertificateCreateOidDataFromString(0, v38);
        if (!OidDataFromString) {
          break;
        }
        CFDataRef v41 = OidDataFromString;
        v34[v35] = PORT_ArenaAlloc(a1, 0x10uLL);
        *(void *)v34[v35] = CFDataGetLength(v41);
        CFIndex Length = CFDataGetLength(v41);
        *(void *)(v34[v35] + 8) = PORT_ArenaAlloc(a1, Length);
        uint64_t v43 = *(void **)(v34[v35] + 8);
        BytePtr = CFDataGetBytePtr(v41);
        CFIndex v45 = CFDataGetLength(v41);
        memcpy(v43, BytePtr, v45);
        CFRelease(v41);
        CFIndex v35 = v36;
        if (v31 <= v36++) {
          goto LABEL_49;
        }
      }
      CFStringRef v70 = @"failed to create EKU data";
LABEL_80:
      int v71 = -50;
      goto LABEL_81;
    }
LABEL_49:
    *(void *)&long long valuePtr = v34;
    if (!SEC_ASN1EncodeItem(a1, &context, (uint64_t)&valuePtr, (uint64_t)kSecAsn1SequenceOfObjectIDTemplate))
    {
      CFStringRef v70 = @"failed to encode EKUs";
      int v71 = -26276;
LABEL_81:
      a4 = v78;
      SecError(v71, v78, v70);
      SecError(-50, (__CFString **)&cf, @"failed to make EKU extension");
      goto LABEL_83;
    }
    *(_OWORD *)&v11[6 * v76 + 4] = context;
    uint64_t v47 = &v11[6 * v76];
    *uint64_t v47 = 3;
    v47[1] = &_oidExtendedKeyUsage;
    unsigned int v16 = v76 + 1;
    a3 = v77;
    a4 = v78;
  }
  CFNumberRef v48 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"keyUsage");
  long long v80 = 0uLL;
  if (v48)
  {
    CFNumberRef v49 = v48;
    CFTypeID v50 = CFGetTypeID(v48);
    if (v50 != CFNumberGetTypeID()
      || (LODWORD(valuePtr) = -1431655766, !CFNumberGetValue(v49, kCFNumberIntType, &valuePtr)))
    {
      SecError(-50, (__CFString **)&cf, @"failed to get key usage value");
      goto LABEL_83;
    }
    unsigned int v51 = valuePtr;
    if ((int)valuePtr >= 1)
    {
      LODWORD(v52) = 0;
      int v53 = 0;
      unsigned int v54 = 0x80000000;
      for (unsigned int i = 1; i != 10; ++i)
      {
        v53 |= ((int)(v51 << 31) >> 31) & v54;
        if (v51) {
          uint64_t v52 = i;
        }
        else {
          uint64_t v52 = v52;
        }
        v51 >>= 1;
        v54 >>= 1;
      }
      LODWORD(valuePtr) = v51;
      LODWORD(v82) = v53;
      *(void *)&long long context = v52;
      *((void *)&context + 1) = (char *)&v82 - (v52 >> 3) + 3;
      if (!SEC_ASN1EncodeItem(a1, &v80, (uint64_t)&context, (uint64_t)kSecAsn1BitStringTemplate))
      {
        SecError(-26276, (__CFString **)&cf, @"failed to encode keyUsage");
        goto LABEL_83;
      }
      CFIndex v56 = &v11[6 * v16];
      *CFIndex v56 = 3;
      v56[1] = &_oidKeyUsage;
      *((_OWORD *)v56 + 1) = asn1_true;
      *((_OWORD *)v56 + 2) = v80;
      ++v16;
    }
  }
  unsigned int v57 = v16;
  CFDictionaryRef v58 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"certificateExtensions");
  if (v58)
  {
    CFDictionaryRef v59 = v58;
    CFTypeID v60 = CFGetTypeID(v58);
    if (v60 != CFDictionaryGetTypeID())
    {
      uint64_t v75 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(context) = 0;
        _os_log_impl(&dword_18B299000, v75, OS_LOG_TYPE_DEFAULT, "csr: wrong value type for custom extensions", (uint8_t *)&context, 2u);
      }
      goto LABEL_83;
    }
    *(void *)&long long context = a1;
    *((void *)&context + 1) = v11;
    uint64_t v85 = v16 | 0xA00000000;
    uint64_t v86 = (__CFString **)0xAAAAAAAAAAAAAA01;
    uint64_t v87 = a4;
    CFDictionaryApplyFunction(v59, (CFDictionaryApplierFunction)add_custom_extension, &context);
    unsigned int v57 = v85;
  }
  CFDictionaryRef v61 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"certificateExtensionsEncoded");
  if (v61)
  {
    CFDictionaryRef v62 = v61;
    CFTypeID v63 = CFGetTypeID(v61);
    if (v63 != CFDictionaryGetTypeID())
    {
      SecError(-50, (__CFString **)&cf, @"wrong value type for custom extensions");
      goto LABEL_83;
    }
    *(void *)&long long context = a1;
    *((void *)&context + 1) = v11;
    uint64_t v85 = v57 | 0xA00000000;
    uint64_t v86 = (__CFString **)0xAAAAAAAAAAAAAA00;
    uint64_t v87 = a4;
    CFDictionaryApplyFunction(v62, (CFDictionaryApplierFunction)add_custom_extension, &context);
    unsigned int v57 = v85;
  }
  if (v57)
  {
    uint64_t v64 = v57;
    long long v65 = v9;
    uint64_t v66 = v11;
    do
    {
      uint64_t v67 = *v66;
      v66 += 6;
      if (v67) {
        uint64_t v68 = v11;
      }
      else {
        uint64_t v68 = 0;
      }
      *v65++ = v68;
      unsigned int v11 = v66;
      --v64;
    }
    while (v64);
  }
  *a3 = v9;
  return 1;
}

uint64_t add_custom_extension(CFStringRef theString, const __CFString *a2, uint64_t a3)
{
  CFAllocatorRef v3 = *(__CFString ***)(a3 + 32);
  if (*(_DWORD *)(a3 + 16) >= *(_DWORD *)(a3 + 20))
  {
    CFStringRef v17 = @"too many extensions";
  }
  else
  {
    unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v6 = oid_der_data(*(void *)a3, theString, &v21);
    long long v20 = 0uLL;
    CFTypeID v7 = CFGetTypeID(a2);
    if (v7 == CFStringGetTypeID())
    {
      if (*(unsigned char *)(a3 + 24))
      {
        CFIndex Length = CFStringGetLength(a2);
        unint64_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
        if (MaximumSizeForEncoding <= 1) {
          unint64_t v10 = 1;
        }
        else {
          unint64_t v10 = MaximumSizeForEncoding;
        }
        unsigned int v11 = (char *)PORT_ArenaAlloc(*(void *)a3, v10);
        size_t v12 = v11;
        if (v11) {
          bzero(v11, v10);
        }
        if (CFStringGetCString(a2, v12, MaximumSizeForEncoding, 0x8000100u))
        {
          size_t v18 = strlen(v12);
          BytePtr = (const UInt8 *)v12;
          uint64_t result = (uint64_t)SEC_ASN1EncodeItem(*(void *)a3, &v20, (uint64_t)&v18, (uint64_t)kSecAsn1UTF8StringTemplate);
          if (!result) {
            uint64_t result = SecError(-26276, v3, @"failed to encode extension string");
          }
          goto LABEL_16;
        }
        CFStringRef v17 = @"failed to get custom extension string bytes";
      }
      else
      {
        CFStringRef v17 = @"encoded extensions must be a data type";
      }
    }
    else
    {
      CFTypeID v14 = CFGetTypeID(a2);
      if (v14 == CFDataGetTypeID())
      {
        if (!*(unsigned char *)(a3 + 24))
        {
          *(void *)&long long v20 = CFDataGetLength((CFDataRef)a2);
          uint64_t result = (uint64_t)CFDataGetBytePtr((CFDataRef)a2);
          *((void *)&v20 + 1) = result;
          if (!v6) {
            return result;
          }
          goto LABEL_17;
        }
        size_t v18 = CFDataGetLength((CFDataRef)a2);
        BytePtr = CFDataGetBytePtr((CFDataRef)a2);
        uint64_t result = (uint64_t)SEC_ASN1EncodeItem(*(void *)a3, &v20, (uint64_t)&v18, (uint64_t)kSecAsn1OctetStringTemplate);
        if (!result) {
          uint64_t result = SecError(-26276, v3, @"failed to encode extension data");
        }
LABEL_16:
        if (!v6) {
          return result;
        }
LABEL_17:
        if ((void)v20)
        {
          *(_OWORD *)(*(void *)(a3 + 8) + 48 * *(unsigned int *)(a3 + 16) + 32) = v20;
          unsigned int v15 = *(_DWORD *)(a3 + 16);
          unsigned int v16 = (unint64_t *)(*(void *)(a3 + 8) + 48 * v15);
          *unsigned int v16 = v21;
          v16[1] = v6;
          *(_DWORD *)(a3 + 16) = v15 + 1;
        }
        return result;
      }
      CFStringRef v17 = @"unsupported custom extensions value type";
    }
  }

  return SecError(-50, v3, v17);
}

uint64_t oid_der_data(uint64_t a1, CFStringRef theString, void *a3)
{
  if ((unint64_t)CFStringGetLength(theString) > 0x3FFFFFFFFFFFFFFELL) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(theString);
  uint64_t v7 = ((unint64_t)(4 * Length) * (unsigned __int128)0x2492492492492493uLL) >> 64;
  uint64_t v8 = PORT_ArenaAlloc(a1, ((v7 + ((unint64_t)(4 * Length - v7) >> 1)) >> 2) + 1);
  if (v8)
  {
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString, @".");
    CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
    unsigned int v11 = (unsigned char *)v8;
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      SInt32 v13 = 0;
      CFIndex v14 = 0;
      unsigned int v11 = (unsigned char *)v8;
      while (1)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v14);
        Intunint64_t Value = CFStringGetIntValue(ValueAtIndex);
        SInt32 v17 = IntValue >= 0 ? IntValue : -IntValue;
        if (v17 == 0x7FFFFFFF) {
          break;
        }
        if (v14)
        {
          if (v14 == 1) {
            unsigned int v18 = IntValue + 40 * v13;
          }
          else {
            unsigned int v18 = IntValue;
          }
          unsigned int v11 = mod128_oid_encoding_ptr(v11, v18, 1);
        }
        else
        {
          SInt32 v13 = IntValue;
        }
        if (v12 == ++v14) {
          goto LABEL_16;
        }
      }
      if (ArrayBySeparatingStrings) {
        CFRelease(ArrayBySeparatingStrings);
      }
      return 0;
    }
LABEL_16:
    if (ArrayBySeparatingStrings) {
      CFRelease(ArrayBySeparatingStrings);
    }
    *a3 = &v11[-v8];
  }
  return v8;
}

unsigned char *mod128_oid_encoding_ptr(unsigned char *a1, unsigned int a2, int a3)
{
  char v4 = a2;
  if (a2 >= 0x81) {
    a1 = (unsigned char *)mod128_oid_encoding_ptr(a1, a2 >> 7, 0);
  }
  if (a3) {
    char v5 = 0;
  }
  else {
    char v5 = 0x80;
  }
  *a1 = v5 & 0x80 | v4 & 0x7F;
  return a1 + 1;
}

void make_general_names(const __CFString *a1, const __CFString *cf, uint64_t a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (!cf) {
    return;
  }
  uint64_t v6 = *(__CFString ***)(a3 + 24);
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 == CFArrayGetTypeID())
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
    CFStringRef v9 = 0;
    CFArrayRef v10 = (const __CFArray *)cf;
    if (!a1) {
      return;
    }
  }
  else
  {
    CFTypeID v11 = CFGetTypeID(cf);
    if (v11 != CFStringGetTypeID())
    {
      CFStringRef v21 = @"unsupported subjectAltName value type";
      goto LABEL_32;
    }
    CFArrayRef v10 = 0;
    CFIndex Count = 1;
    CFStringRef v9 = cf;
    if (!a1) {
      return;
    }
  }
  if (Count < 1) {
    return;
  }
  CFTypeID v12 = CFGetTypeID(a1);
  if (v12 != CFStringGetTypeID())
  {
    CFStringRef v21 = @"unsupported subjectAltName key type";
    goto LABEL_32;
  }
  if (*(void *)(a3 + 8))
  {
    int v13 = *(_DWORD *)(a3 + 16);
    if (v13 != *(_DWORD *)(a3 + 20)) {
      goto LABEL_24;
    }
  }
  else
  {
    int v13 = *(_DWORD *)(a3 + 20);
  }
  if (v13) {
    unsigned int v14 = 2 * v13;
  }
  else {
    unsigned int v14 = 10;
  }
  if (16 * (unint64_t)v14 <= 1) {
    unint64_t v15 = 1;
  }
  else {
    unint64_t v15 = 16 * v14;
  }
  unsigned int v16 = (void *)PORT_ArenaAlloc(*(void *)a3, v15);
  SInt32 v17 = v16;
  if (v16) {
    bzero(v16, v15);
  }
  unsigned int v18 = *(const void **)(a3 + 8);
  if (v18) {
    memcpy(v17, v18, *(unsigned int *)(a3 + 20));
  }
  *(void *)(a3 + 8) = v17;
  *(_DWORD *)(a3 + 20) = v14;
LABEL_24:
  long long v43 = xmmword_18B419EF8;
  uint64_t v44 = 255;
  if (CFStringCompare(@"dNSName", a1, 1uLL) == kCFCompareEqualTo)
  {
    char v19 = 2;
    goto LABEL_36;
  }
  char v19 = 1;
  if (CFStringCompare(@"rfc822Name", a1, 1uLL) == kCFCompareEqualTo)
  {
LABEL_36:
    LOBYTE(v44) = v19;
    if (v10)
    {
      CFIndex v22 = 0;
      while (1)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, v22);
        CFTypeID v24 = CFGetTypeID(ValueAtIndex);
        if (v24 != CFStringGetTypeID())
        {
          SecError(-50, v6, @"subjectAltName value is not a string");
          return;
        }
        CFIndex Length = CFStringGetLength(ValueAtIndex);
        unint64_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
        if (MaximumSizeForEncoding <= 1) {
          unint64_t v27 = 1;
        }
        else {
          unint64_t v27 = MaximumSizeForEncoding;
        }
        CFArrayRef v28 = (char *)PORT_ArenaAlloc(*(void *)a3, v27);
        CFTypeID v29 = v28;
        if (v28) {
          bzero(v28, v27);
        }
        if (!CFStringGetCString(ValueAtIndex, v29, MaximumSizeForEncoding, 0x600u)) {
          break;
        }
        *((void *)&v43 + 1) = v29;
        *(void *)&long long v43 = strlen(v29);
        SEC_ASN1EncodeItem(*(void *)a3, (void *)(*(void *)(a3 + 8) + 16 * *(unsigned int *)(a3 + 16)), (uint64_t)&v43, (uint64_t)&kSecAsn1GeneralNameTemplate);
        ++*(_DWORD *)(a3 + 16);
        if (Count == ++v22) {
          return;
        }
      }
      SecError(-50, v6, @"failed to get subjectAltName value bytes");
      return;
    }
    if (!v9) {
      return;
    }
    CFIndex v30 = CFStringGetLength(v9);
    unint64_t v31 = CFStringGetMaximumSizeForEncoding(v30, 0x8000100u);
    if (v31 <= 1) {
      unint64_t v32 = 1;
    }
    else {
      unint64_t v32 = v31;
    }
    uint64_t v33 = (char *)PORT_ArenaAlloc(*(void *)a3, v32);
    long long v34 = v33;
    if (v33) {
      bzero(v33, v32);
    }
    if (CFStringGetCString(v9, v34, v31, 0x600u))
    {
      *((void *)&v43 + 1) = v34;
      *(void *)&long long v43 = strlen(v34);
      SEC_ASN1EncodeItem(*(void *)a3, (void *)(*(void *)(a3 + 8) + 16 * *(unsigned int *)(a3 + 16)), (uint64_t)&v43, (uint64_t)&kSecAsn1GeneralNameTemplate);
LABEL_55:
      ++*(_DWORD *)(a3 + 16);
      return;
    }
    CFStringRef v21 = @"failed to get subjectAltName value bytes";
LABEL_32:
    SecError(-50, v6, v21);
    return;
  }
  if (CFStringCompare(@"uniformResourceIdentifier", a1, 1uLL) == kCFCompareEqualTo)
  {
    char v19 = 6;
    goto LABEL_36;
  }
  if (CFStringCompare(@"ntPrincipalName", a1, 1uLL))
  {
    long long v20 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v39) = 0;
      _os_log_impl(&dword_18B299000, v20, OS_LOG_TYPE_DEFAULT, "csr: unsupported SubjectAltName type, skipping", (uint8_t *)&v39, 2u);
    }
    return;
  }
  __int16 v46 = 770;
  uint64_t v45 = 0x143782010401062BLL;
  if (!v9)
  {
    SecError(-50, v6, @"NTPrincipalName types do not allow multiple values");
    return;
  }
  CFTypeID v35 = CFGetTypeID(v9);
  if (v35 == CFStringGetTypeID())
  {
    CFIndex v36 = CFStringGetLength(cf);
    CFIndex v37 = CFStringGetMaximumSizeForEncoding(v36, 0x8000100u);
    CFStringRef v38 = (char *)PORT_ArenaAlloc(*(void *)a3, v37);
    if (!CFStringGetCString(cf, v38, v37, 0x8000100u))
    {
      SecError(-50, v6, @"failed to get NTPrincipalName value bytes");
      return;
    }
    uint64_t v39 = 10;
    CFNumberRef v40 = &v45;
    size_t v41 = strlen(v38);
    long long v42 = v38;
    if (!SEC_ASN1EncodeItem(*(void *)a3, (void *)(*(void *)(a3 + 8) + 16 * *(unsigned int *)(a3 + 16)), (uint64_t)&v39, (uint64_t)&my_other_name_template_cons))SecError(-26276, v6, @"failed to encode NTPrincipalName", v39, v40); {
    goto LABEL_55;
    }
  }
}

CFDataRef SecGenerateCertificateRequest(const __CFArray *a1, const __CFDictionary *a2, void *a3, __SecKey *a4)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = PORT_NewArena(1024);
  char v43 = 0;
  CFErrorRef error = 0;
  if (v8)
  {
    CFStringRef v9 = v8;
    BytePtr = 0;
    long long v40 = 0u;
    memset(v39, 0, sizeof(v39));
    long long v38 = 0u;
    *(_OWORD *)CFIndex v37 = 0u;
    long long v36 = 0u;
    char v32 = 0;
    *(void *)uint64_t v33 = 1;
    long long v34 = &v32;
    subject = make_subject((uint64_t)v8, a1, (__CFString **)&error);
    if (a4)
    {
      CFArrayRef v10 = SecKeyCopyPublicKey(a4);
      if (v10)
      {
LABEL_7:
        CFDataRef public_key = make_public_key(v10, (uint64_t)&v36, &v43, &error);
        if (public_key)
        {
          CFDataRef v13 = public_key;
          *(void *)&v39[0] = nss_attributes_from_parameters_dict((uint64_t)v9, a2);
          SecCmsArraySortByDER(*(int8x16_t **)&v39[0], (uint64_t)&kSecAsn1AttributeTemplate, 0);
          CFIndex v30 = 0;
          unint64_t v31 = 0;
          if (!SEC_ASN1EncodeItem((uint64_t)v9, &v30, (uint64_t)v33, (uint64_t)&kSecAsn1CertRequestInfoTemplate))
          {
            unsigned int v14 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEFAULT, "csr: failed to encode request info", buf, 2u);
            }
          }
          if (a2) {
            unint64_t Value = CFDictionaryGetValue(a2, (const void *)kSecCMSSignHashAlgorithm);
          }
          else {
            unint64_t Value = 0;
          }
          CFDataRef signature = make_signature(v31, v30, a4, Value, (DERSize *)v39 + 1, (__CFString **)&error);
          if (signature)
          {
            CFDataRef v19 = signature;
            BytePtr = CFDataGetBytePtr(signature);
            *((void *)&v40 + 1) = 8 * CFDataGetLength(v19);
            CFIndex v28 = 0;
            CFTypeID v29 = 0;
            if (SEC_ASN1EncodeItem((uint64_t)v9, &v28, (uint64_t)v33, (uint64_t)&kSecAsn1CertRequestTemplate))
            {
              CFDataRef v17 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v29, v28);
              char v20 = 0;
LABEL_24:
              if (v43) {
                free(v37[1]);
              }
              PORT_FreeArena(v9, 1);
              if ((v20 & 1) == 0) {
                CFRelease(v10);
              }
              if (v13) {
                CFRelease(v13);
              }
              if (v19) {
                CFRelease(v19);
              }
              if (error)
              {
                CFIndex v22 = secLogObjForScope("SecError");
                if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 138412290;
                  CFErrorRef v45 = error;
                  _os_log_impl(&dword_18B299000, v22, OS_LOG_TYPE_DEFAULT, "csr: cert request encoding failed: %@", buf, 0xCu);
                }
                CFErrorRef v23 = error;
                if (error)
                {
                  CFErrorRef error = 0;
                  CFRelease(v23);
                }
              }
              return v17;
            }
            unint64_t v27 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl(&dword_18B299000, v27, OS_LOG_TYPE_DEFAULT, "csr: failed to encode cert request", buf, 2u);
            }
            char v20 = 0;
          }
          else
          {
            unint64_t v26 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl(&dword_18B299000, v26, OS_LOG_TYPE_DEFAULT, "csr: failed to create CSR signature", buf, 2u);
            }
            char v20 = 0;
            CFDataRef v19 = 0;
          }
        }
        else
        {
          uint64_t v25 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl(&dword_18B299000, v25, OS_LOG_TYPE_DEFAULT, "csr: failed to encode public key", buf, 2u);
          }
          char v20 = 0;
          CFDataRef v19 = 0;
          CFDataRef v13 = 0;
        }
        CFDataRef v17 = 0;
        goto LABEL_24;
      }
    }
    CFTypeID v11 = secLogObjForScope("csr");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl(&dword_18B299000, v11, OS_LOG_TYPE_DEBUG, "unable to create public key from private, using input public key", buf, 2u);
      if (a3) {
        goto LABEL_6;
      }
    }
    else if (a3)
    {
LABEL_6:
      CFRetain(a3);
      CFArrayRef v10 = (__SecKey *)a3;
      goto LABEL_7;
    }
    CFStringRef v21 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v21, OS_LOG_TYPE_DEFAULT, "csr: failed to get public key", buf, 2u);
    }
    CFArrayRef v10 = 0;
    CFDataRef v19 = 0;
    CFDataRef v13 = 0;
    CFDataRef v17 = 0;
    char v20 = 1;
    goto LABEL_24;
  }
  unsigned int v16 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v33 = 0;
    _os_log_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEFAULT, "csr: pool allocation failure", v33, 2u);
  }
  return 0;
}

void *make_subject(uint64_t a1, CFArrayRef theArray, __CFString **a3)
{
  if (!theArray) {
    return 0;
  }
  CFArrayRef v4 = theArray;
  CFIndex Count = CFArrayGetCount(theArray);
  uint64_t v7 = Count;
  unint64_t v8 = 8 * Count;
  if ((unint64_t)(8 * Count + 8) <= 1) {
    unint64_t v9 = 1;
  }
  else {
    unint64_t v9 = 8 * Count + 8;
  }
  CFArrayRef v10 = (void *)PORT_ArenaAlloc(a1, v9);
  CFTypeID v11 = v10;
  if (v10) {
    bzero(v10, v9);
  }
  if (v8 <= 1) {
    unint64_t v12 = 1;
  }
  else {
    unint64_t v12 = v8;
  }
  CFDataRef v13 = (char *)PORT_ArenaAlloc(a1, v12);
  unsigned int v14 = v13;
  if (v13) {
    bzero(v13, v12);
  }
  if (v7 >= 1)
  {
    CFIndex v15 = 0;
    uint64_t v33 = v11;
    CFArrayRef v34 = v4;
    unint64_t v31 = v14;
    uint64_t v32 = v7;
    while (1)
    {
      unsigned int v16 = &v14[8 * v15];
      v11[v15] = v16;
      CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v4, v15);
      CFIndex v18 = CFArrayGetCount(ValueAtIndex);
      uint64_t v19 = v18;
      if ((unint64_t)(8 * v18 + 8) <= 1) {
        unint64_t v20 = 1;
      }
      else {
        unint64_t v20 = 8 * v18 + 8;
      }
      CFStringRef v21 = (void *)PORT_ArenaAlloc(a1, v20);
      CFIndex v22 = v21;
      if (v21) {
        bzero(v21, v20);
      }
      *(void *)unsigned int v16 = v22;
      unint64_t v23 = (unint64_t)(40 * v19) <= 1 ? 1 : 40 * v19;
      CFTypeID v24 = (void *)PORT_ArenaAlloc(a1, v23);
      uint64_t v25 = (uint64_t)v24;
      if (v24) {
        bzero(v24, v23);
      }
      if (v19 >= 1) {
        break;
      }
LABEL_29:
      ++v15;
      CFTypeID v11 = v33;
      CFArrayRef v4 = v34;
      unsigned int v14 = v31;
      if (v15 == v32) {
        return v11;
      }
    }
    CFIndex v26 = 0;
    while (1)
    {
      *(void *)(*(void *)v16 + 8 * v26) = v25;
      CFArrayRef v27 = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, v26);
      if (CFArrayGetCount(v27) != 2) {
        break;
      }
      CFStringRef v28 = (const __CFString *)CFArrayGetValueAtIndex(v27, 0);
      CFStringRef v29 = (const __CFString *)CFArrayGetValueAtIndex(v27, 1);
      if ((make_nss_atv(a1, v28, v29, 0, v25, a3) & 1) == 0) {
        return 0;
      }
      ++v26;
      v25 += 40;
      if (v19 == v26) {
        goto LABEL_29;
      }
    }
    SecError(-50, a3, @"subject input incorrect: 2 values required in ATV array");
    return 0;
  }
  return v11;
}

uint64_t SecVerifyCertificateRequest(const __CFData *a1, __SecKey **a2, CFStringRef *a3, CFDataRef *a4, CFDataRef *a5)
{
  CFArrayRef v10 = PORT_NewArena(1024);
  long long v67 = 0u;
  *(_OWORD *)__n = 0u;
  *(_OWORD *)__s2 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  memset(v65, 0, sizeof(v65));
  long long v66 = 0u;
  CFIndex v11 = CFDataGetLength(a1);
  BytePtr = (char *)CFDataGetBytePtr(a1);
  if (SEC_ASN1Decode((uint64_t)v10, (uint64_t)&v67, (uint64_t)&kSecAsn1CertRequestTemplate, BytePtr, v11))
  {
    unsigned int v14 = secLogObjForScope("SecError");
    uint64_t v15 = 0;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    *(_WORD *)long long buf = 0;
    unsigned int v16 = "csr: failed to decode CSR";
    goto LABEL_9;
  }
  if (SEC_ASN1Decode((uint64_t)v10, (uint64_t)v65, (uint64_t)&kSecAsn1SignedCertRequestTemplate, BytePtr, v11))
  {
    unsigned int v14 = secLogObjForScope("SecError");
    uint64_t v15 = 0;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    *(_WORD *)long long buf = 0;
    unsigned int v16 = "csr: failed to decode CSR";
    goto LABEL_9;
  }
  size_t v13 = __n[1];
  if (__n[1] == 9 && !memcmp(&_oidRsa, __s2[0], 9uLL))
  {
    CFDictionaryRef v58 = a4;
    int v17 = 1;
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex v18 = (__SecKey *)SecKeyCreate(*MEMORY[0x1E4F1CF80], (uint64_t)&kSecRSAPublicKeyDescriptor, v71, *((void *)&v70 + 1) >> 3, 1);
    if (v18)
    {
      uint64_t v19 = v18;
      CFDataRef v20 = 0;
      CFMutableDictionaryRef Mutable = 0;
      goto LABEL_14;
    }
    unsigned int v14 = secLogObjForScope("SecError");
    uint64_t v15 = 0;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    *(_WORD *)long long buf = 0;
    unsigned int v16 = "csr: failed to create RSA public key";
LABEL_9:
    _os_log_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEFAULT, v16, buf, 2u);
    uint64_t v15 = 0;
    goto LABEL_98;
  }
  if (v13 != 7 || memcmp(&_oidEcPubKey, __s2[0], 7uLL))
  {
    unsigned int v14 = secLogObjForScope("SecError");
    uint64_t v15 = 0;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    *(_WORD *)long long buf = 0;
    unsigned int v16 = "csr: unsupported public key algorithm in CSR";
    goto LABEL_9;
  }
  CFDictionaryRef v58 = a4;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef v20 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v71, *((void *)&v70 + 1) >> 3, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue(Mutable, @"type", @"73");
  CFDictionaryAddValue(Mutable, @"kcls", @"0");
  SecKeyRef v22 = SecKeyCreateWithData(v20, Mutable, 0);
  if (!v22)
  {
    unsigned int v54 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v54, OS_LOG_TYPE_DEFAULT, "csr: failed to create EC public key", buf, 2u);
    }
    uint64_t v15 = 0;
    CFDataRef v26 = 0;
    CFDataRef v27 = 0;
    if (!Mutable) {
      goto LABEL_92;
    }
    goto LABEL_91;
  }
  uint64_t v19 = v22;
  int v17 = 0;
LABEL_14:
  long long v23 = v72;
  if (!(void)v73) {
    goto LABEL_17;
  }
  if ((void)v73 != 2)
  {
    uint64_t v25 = secLogObjForScope("SecError");
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
LABEL_30:
      uint64_t v15 = 0;
      CFDataRef v26 = 0;
      CFDataRef v27 = 0;
      goto LABEL_90;
    }
    *(_WORD *)long long buf = 0;
LABEL_29:
    _os_log_impl(&dword_18B299000, v25, OS_LOG_TYPE_DEFAULT, "csr: non-empty signature algorithm parameters", buf, 2u);
    goto LABEL_30;
  }
  if (**((_WORD **)&v73 + 1) != 5)
  {
    uint64_t v25 = secLogObjForScope("SecError");
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_30;
    }
    *(_WORD *)long long buf = 0;
    goto LABEL_29;
  }
LABEL_17:
  if (!v17)
  {
    if ((void)v72 == 8 && !memcmp(&_oidSha256Ecdsa, *((const void **)&v72 + 1), 8uLL))
    {
      CFTypeID v24 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA256;
    }
    else if ((void)v23 == 8 && !memcmp(&_oidSha384Ecdsa, *((const void **)&v23 + 1), 8uLL))
    {
      CFTypeID v24 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA384;
    }
    else
    {
      if ((void)v23 != 8 || memcmp(&_oidSha512Ecdsa, *((const void **)&v23 + 1), 8uLL)) {
        goto LABEL_44;
      }
      CFTypeID v24 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA512;
    }
LABEL_43:
    CFStringRef v28 = *v24;
    if (*v24) {
      goto LABEL_47;
    }
    goto LABEL_44;
  }
  if ((void)v72 == 9 && !memcmp(&_oidSha1Rsa, *((const void **)&v72 + 1), 9uLL))
  {
    CFTypeID v24 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA1;
    goto LABEL_43;
  }
  if ((void)v23 == 9 && !memcmp(&_oidSha256Rsa, *((const void **)&v23 + 1), 9uLL))
  {
    CFTypeID v24 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA256;
    goto LABEL_43;
  }
  if ((void)v23 == 9 && !memcmp(&_oidSha384Rsa, *((const void **)&v23 + 1), 9uLL))
  {
    CFTypeID v24 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA384;
    goto LABEL_43;
  }
  if ((void)v23 == 9 && !memcmp(&_oidSha512Rsa, *((const void **)&v23 + 1), 9uLL))
  {
    CFTypeID v24 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA512;
    goto LABEL_43;
  }
LABEL_44:
  CFStringRef v29 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_18B299000, v29, OS_LOG_TYPE_DEFAULT, "csr: unsupported signature algorithm", buf, 2u);
  }
  CFStringRef v28 = 0;
LABEL_47:
  unsigned int v57 = a5;
  CFAllocatorRef v30 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  CFDataRef v27 = CFDataCreateWithBytesNoCopy(allocator, *((const UInt8 **)&v66 + 1), (unint64_t)v66 >> 3, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  CFDataRef v31 = CFDataCreateWithBytesNoCopy(allocator, *((const UInt8 **)&v65[0] + 1), *(CFIndex *)&v65[0], v30);
  CFDataRef v26 = v31;
  uint64_t v15 = 0;
  if (!v28 || !v27 || !v31) {
    goto LABEL_90;
  }
  if (!SecKeyVerifySignature(v19, v28, v31, v27, 0))
  {
    uint64_t v52 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      int v53 = "csr: failed to verify signature in CSR";
LABEL_109:
      _os_log_impl(&dword_18B299000, v52, OS_LOG_TYPE_DEFAULT, v53, buf, 2u);
    }
LABEL_110:
    uint64_t v15 = 0;
    goto LABEL_90;
  }
  unint64_t v55 = a2;
  CFIndex v56 = a3;
  CFIndex length = 0;
  UInt8 bytes = 0;
  if (!SEC_ASN1EncodeItem((uint64_t)v10, &length, (uint64_t)__n, (uint64_t)&kSecAsn1NameTemplate))
  {
    uint64_t v52 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      int v53 = "csr: failed to decode CSR subject name";
      goto LABEL_109;
    }
    goto LABEL_110;
  }
  uint64_t v32 = v19;
  uint64_t v33 = Mutable;
  CFDataRef v34 = v20;
  uint64_t v35 = **((void **)&v71 + 1);
  if (**((void **)&v71 + 1))
  {
    unint64_t v36 = 0;
    CFIndex v37 = 0;
    long long v38 = 0;
    CFIndex v39 = 0;
    unsigned int v40 = 1;
    do
    {
      if (*(void *)v35 == 9)
      {
        size_t v41 = *(uint64_t **)(v35 + 8);
        if (*v41 == 0x9010DF78648862ALL && *((unsigned char *)v41 + 8) == 7)
        {
          uint64_t v47 = **(unint64_t ***)(v35 + 16);
          unint64_t v36 = *v47;
          CFIndex v37 = (char *)v47[1];
        }
        else
        {
          uint64_t v43 = *v41;
          int v44 = *((unsigned __int8 *)v41 + 8);
          if (v43 == 0x9010DF78648862ALL && v44 == 14)
          {
            uint64_t v46 = **(CFIndex ***)(v35 + 16);
            CFIndex v39 = *v46;
            long long v38 = (const UInt8 *)v46[1];
          }
        }
      }
      uint64_t v35 = *(void *)(*((void *)&v71 + 1) + 8 * v40++);
    }
    while (v35);
  }
  else
  {
    unint64_t v36 = 0;
    CFIndex v37 = 0;
    CFIndex v39 = 0;
    long long v38 = 0;
  }
  if (v58 && length) {
    *CFDictionaryRef v58 = CFDataCreate(allocator, bytes, length);
  }
  if (v57 && v39) {
    *unsigned int v57 = CFDataCreate(allocator, v38, v39);
  }
  CFDataRef v20 = v34;
  CFMutableDictionaryRef Mutable = v33;
  uint64_t v19 = v32;
  if (v56 && v36)
  {
    *(void *)long long buf = 0;
    CFDictionaryRef v62 = 0;
    if (!SEC_ASN1Decode((uint64_t)v10, (uint64_t)buf, (uint64_t)kSecAsn1UTF8StringTemplate, v37, v36)) {
      goto LABEL_84;
    }
    CFNumberRef v48 = secLogObjForScope("csr");
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)CFTypeID v60 = 0;
      _os_log_debug_impl(&dword_18B299000, v48, OS_LOG_TYPE_DEBUG, "challenge failed to decode with UTF8, attempting PrintableString", v60, 2u);
    }
    if (SEC_ASN1Decode((uint64_t)v10, (uint64_t)buf, (uint64_t)kSecAsn1PrintableStringTemplate, v37, v36))
    {
      CFNumberRef v49 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CFTypeID v60 = 0;
        _os_log_impl(&dword_18B299000, v49, OS_LOG_TYPE_DEFAULT, "csr: failed to decode challenge", v60, 2u);
      }
      CFStringRef v50 = 0;
    }
    else
    {
LABEL_84:
      CFStringRef v50 = CFStringCreateWithBytes(allocator, v62, *(CFIndex *)buf, 0x8000100u, 0);
    }
    *CFIndex v56 = v50;
  }
  if (v55)
  {
    *unint64_t v55 = v32;
    uint64_t v15 = 1;
    if (!Mutable) {
      goto LABEL_92;
    }
    goto LABEL_91;
  }
  uint64_t v15 = 1;
LABEL_90:
  CFRelease(v19);
  if (Mutable) {
LABEL_91:
  }
    CFRelease(Mutable);
LABEL_92:
  if (v20) {
    CFRelease(v20);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (v27) {
    CFRelease(v27);
  }
LABEL_98:
  if (v10) {
    PORT_FreeArena(v10, 1);
  }
  return v15;
}

void *SecGenerateSelfSignedCertificateWithError(const __CFArray *a1, const __CFDictionary *a2, uint64_t a3, __SecKey *a4, __CFString **a5)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = PORT_NewArena(1024);
  char v47 = 0;
  CFErrorRef error = 0;
  if (!v9)
  {
    SecError(-67672, a5, @"pool allocation failure");
    return 0;
  }
  CFArrayRef v10 = v9;
  BytePtr = 0;
  long long v44 = 0u;
  memset(v43, 0, sizeof(v43));
  long long v42 = 0u;
  long long v41 = 0u;
  long long v40 = 0u;
  *(_OWORD *)CFIndex v39 = 0u;
  long long v38 = 0u;
  long long v37 = 0u;
  long long v36 = 0u;
  memset(v35, 0, sizeof(v35));
  long long v34 = 0u;
  char v32 = 2;
  v33[0] = 1;
  v33[1] = &v32;
  if (a2
    && (CFDataRef Value = (const __CFData *)CFDictionaryGetValue(a2, @"certificateSerial")) != 0
    && (CFDataRef v12 = Value, v13 = CFGetTypeID(Value), v13 == CFDataGetTypeID())
    && (unint64_t)(CFDataGetLength(v12) - 21) >= 0xFFFFFFFFFFFFFFECLL)
  {
    CFRetain(v12);
  }
  else
  {
    bytes[0] = 1;
    CFDataRef v12 = CFDataCreate(0, bytes, 1);
    if (!v12)
    {
      SecError(-67672, (__CFString **)&error, @"failed to allocate serial number");
      goto LABEL_30;
    }
  }
  *(void *)&long long v34 = CFDataGetLength(v12);
  *((void *)&v34 + 1) = CFDataGetBytePtr(v12);
  *(void *)&v35[2] = make_subject((uint64_t)v10, a1, (__CFString **)&error);
  *((void *)&v37 + 1) = *(void *)&v35[2];
  if (a2)
  {
    CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(a2, @"certificateLifetime");
    uint64_t valuePtr = 31536000;
    if (v14) {
      CFNumberGetValue(v14, kCFNumberLongLongType, &valuePtr);
    }
  }
  else
  {
    uint64_t valuePtr = 31536000;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  if (SecAsn1EncodeTime((uint64_t)v10, (uint64_t)&v35[2] + 8, Current))
  {
    CFStringRef v23 = @"failed to encode notBefore";
    goto LABEL_29;
  }
  if (SecAsn1EncodeTime((uint64_t)v10, (uint64_t)&v36, Current + (double)valuePtr))
  {
    CFStringRef v23 = @"failed to encode notAfter";
    goto LABEL_29;
  }
  if ((extensions_from_parameters((uint64_t)v10, a2, v43, (__CFString **)&error) & 1) == 0)
  {
    CFStringRef v23 = @"failed to encode extensions";
    goto LABEL_29;
  }
  if (!a4 || (unsigned int v16 = SecKeyCopyPublicKey(a4)) == 0)
  {
    CFStringRef v23 = @"failed get public key";
LABEL_29:
    SecError(-26276, (__CFString **)&error, v23);
LABEL_30:
    SecKeyRef v22 = 0;
    CFDataRef v21 = 0;
    CFDataRef public_key = 0;
    int v17 = 0;
    goto LABEL_31;
  }
  int v17 = v16;
  CFDataRef public_key = make_public_key(v16, (uint64_t)&v38, &v47, &error);
  if (!public_key)
  {
    SecError(-26276, (__CFString **)&error, @"failed to encode public key");
    SecKeyRef v22 = 0;
    CFDataRef v21 = 0;
    goto LABEL_31;
  }
  if (a2) {
    a2 = (const __CFDictionary *)CFDictionaryGetValue(a2, (const void *)kSecCMSSignHashAlgorithm);
  }
  CFDataRef signature = make_signature(0, 0, a4, a2, (DERSize *)v35, (__CFString **)&error);
  if (signature) {
    CFRelease(signature);
  }
  CFIndex v29 = 0;
  CFAllocatorRef v30 = 0;
  if (!SEC_ASN1EncodeItem((uint64_t)v10, &v29, (uint64_t)v33, (uint64_t)&kSecAsn1TBSCertificateTemplate)) {
    SecError(-26276, (__CFString **)&error, @"failed to encode TBS");
  }
  CFDataRef v20 = make_signature(v30, v29, a4, a2, &v43[5], (__CFString **)&error);
  CFDataRef v21 = v20;
  if (!v20)
  {
    SecError(-67688, (__CFString **)&error, @"failed to make signature");
LABEL_60:
    SecKeyRef v22 = 0;
    goto LABEL_31;
  }
  BytePtr = CFDataGetBytePtr(v20);
  *((void *)&v44 + 1) = 8 * CFDataGetLength(v21);
  int64_t v27 = 0;
  CFStringRef v28 = 0;
  if (!SEC_ASN1EncodeItem((uint64_t)v10, &v27, (uint64_t)v33, (uint64_t)&kSecAsn1SignedCertTemplate))
  {
    SecError(-26276, (__CFString **)&error, @"failed to encode certificate");
    goto LABEL_60;
  }
  SecKeyRef v22 = SecCertificateCreateWithBytes(*MEMORY[0x1E4F1CF80], v28, v27);
  if (!v22) {
    SecError(-26276, (__CFString **)&error, @"failed to decode encoded certificate");
  }
LABEL_31:
  if (v47) {
    free(v39[1]);
  }
  PORT_FreeArena(v10, 1);
  if (v17) {
    CFRelease(v17);
  }
  if (public_key) {
    CFRelease(public_key);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (error)
  {
    CFTypeID v24 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)UInt8 bytes = 138412290;
      CFErrorRef v49 = error;
      _os_log_impl(&dword_18B299000, v24, OS_LOG_TYPE_DEFAULT, "csr: failed to generate self-signed certificate %@", bytes, 0xCu);
    }
    if (v22) {
      CFRelease(v22);
    }
    if (a5)
    {
      CFErrorRef v25 = error;
      if (*a5) {
        CFRelease(*a5);
      }
      SecKeyRef v22 = 0;
      *a5 = (__CFString *)v25;
      return v22;
    }
    return 0;
  }
  return v22;
}

void *SecGenerateSelfSignedCertificate(const __CFArray *a1, const __CFDictionary *a2, uint64_t a3, __SecKey *a4)
{
  return SecGenerateSelfSignedCertificateWithError(a1, a2, a3, a4, 0);
}

void *SecIdentitySignCertificate(uint64_t a1, const __CFData *a2, __SecKey *a3, const void *a4, const void *a5)
{
  return SecIdentitySignCertificateWithParameters(a1, a2, a3, a4, a5, 0);
}

void *SecIdentitySignCertificateWithParameters(uint64_t a1, const __CFData *a2, __SecKey *a3, const void *a4, const void *a5, CFDictionaryRef theDict)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  if (theDict) {
    CFDataRef Value = CFDictionaryGetValue(theDict, (const void *)kSecCMSSignHashAlgorithm);
  }
  else {
    CFDataRef Value = 0;
  }
  char v80 = 0;
  CFErrorRef error = 0;
  CFTypeID v13 = PORT_NewArena(1024);
  if (v13)
  {
    CFNumberRef v14 = v13;
    uint64_t v78 = 0;
    long long v77 = 0u;
    long long v75 = 0u;
    memset(v76, 0, sizeof(v76));
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    *(_OWORD *)long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    memset(v68, 0, sizeof(v68));
    memset(v67, 0, sizeof(v67));
    long long v66 = 0u;
    char v63 = 2;
    *(void *)long long buf = 1;
    long long v65 = &v63;
    *(void *)&long long v66 = CFDataGetLength(a2);
    *((void *)&v66 + 1) = CFDataGetBytePtr(a2);
    if (!a4) {
      goto LABEL_19;
    }
    CFTypeID v15 = CFGetTypeID(a4);
    if (v15 == CFArrayGetTypeID())
    {
      *((void *)&v70 + 1) = make_subject((uint64_t)v14, (CFArrayRef)a4, (__CFString **)&error);
      goto LABEL_13;
    }
    CFTypeID v18 = CFGetTypeID(a4);
    if (v18 == CFDataGetTypeID())
    {
      CFIndex Length = CFDataGetLength((CFDataRef)a4);
      BytePtr = (char *)CFDataGetBytePtr((CFDataRef)a4);
      if (!SEC_ASN1Decode((uint64_t)v14, (uint64_t)&v70 + 8, (uint64_t)&kSecAsn1NameTemplate, BytePtr, Length))
      {
LABEL_13:
        CFDataRef v21 = *(const void **)(a1 + 16);
        CFRetain(v21);
        SecKeyRef v22 = SecDERItemCopySequence((uint64_t)v21 + 184);
        CFIndex v23 = CFDataGetLength(v22);
        CFTypeID v24 = (char *)CFDataGetBytePtr(v22);
        if (SEC_ASN1Decode((uint64_t)v14, (uint64_t)v68, (uint64_t)&kSecAsn1NameTemplate, v24, v23))
        {
          CFIndex v56 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v81 = 0;
            _os_log_impl(&dword_18B299000, v56, OS_LOG_TYPE_DEFAULT, "csr: failed to decoder subject name from CA identity", v81, 2u);
          }
          CFStringRef v28 = 0;
          goto LABEL_24;
        }
        if (v22) {
          CFRelease(v22);
        }
        if (theDict)
        {
          CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"certificateLifetime");
          uint64_t valuePtr = 31536000;
          if (v25) {
            CFNumberGetValue(v25, kCFNumberLongLongType, &valuePtr);
          }
        }
        else
        {
          uint64_t valuePtr = 31536000;
        }
        double Current = CFAbsoluteTimeGetCurrent();
        if (SecAsn1EncodeTime((uint64_t)v14, (uint64_t)v68 + 8, Current))
        {
          uint64_t v43 = secLogObjForScope("SecError");
          if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_53;
          }
          *(_WORD *)uint64_t v81 = 0;
          long long v44 = "csr: failed to encode notBefore";
          goto LABEL_52;
        }
        if (SecAsn1EncodeTime((uint64_t)v14, (uint64_t)&v69, Current + (double)valuePtr))
        {
          uint64_t v43 = secLogObjForScope("SecError");
          if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_53;
          }
          *(_WORD *)uint64_t v81 = 0;
          long long v44 = "csr: failed to encode notBefore";
          goto LABEL_52;
        }
        if (theDict)
        {
          CFTypeID v32 = CFGetTypeID(theDict);
          if (v32 == CFDictionaryGetTypeID() && parameters_contains_extensions(theDict))
          {
            uint64_t v33 = secLogObjForScope("csr");
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)uint64_t v81 = 0;
              _os_log_debug_impl(&dword_18B299000, v33, OS_LOG_TYPE_DEBUG, "overriding request extensions with parameters extensions", v81, 2u);
            }
            uint64_t v34 = (uint64_t)v14;
            CFDictionaryRef v35 = theDict;
LABEL_46:
            if ((extensions_from_parameters(v34, v35, v76, (__CFString **)&error) & 1) == 0)
            {
LABEL_50:
              uint64_t v43 = secLogObjForScope("SecError");
              if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
              {
LABEL_53:
                CFStringRef v28 = 0;
                goto LABEL_23;
              }
              *(_WORD *)uint64_t v81 = 0;
              long long v44 = "csr: failed to encode extensions";
LABEL_52:
              _os_log_impl(&dword_18B299000, v43, OS_LOG_TYPE_DEFAULT, v44, v81, 2u);
              goto LABEL_53;
            }
LABEL_56:
            CFDataRef public_key = make_public_key(a3, (uint64_t)&v71, &v80, &error);
            if (!public_key)
            {
              uint64_t v43 = secLogObjForScope("SecError");
              if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_53;
              }
              *(_WORD *)uint64_t v81 = 0;
              long long v44 = "csr: failed to encode public key";
              goto LABEL_52;
            }
            CFDataRef v30 = public_key;
            CFStringRef v28 = *(void **)(a1 + 24);
            CFRetain(v28);
            CFDataRef signature = make_signature(0, 0, (__SecKey *)v28, Value, (DERSize *)v67, (__CFString **)&error);
            if (signature) {
              CFRelease(signature);
            }
            CFIndex v60 = 0;
            CFDictionaryRef v61 = 0;
            if (!SEC_ASN1EncodeItem((uint64_t)v14, &v60, (uint64_t)buf, (uint64_t)&kSecAsn1TBSCertificateTemplate))
            {
              CFNumberRef v48 = secLogObjForScope("SecError");
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)uint64_t v81 = 0;
                _os_log_impl(&dword_18B299000, v48, OS_LOG_TYPE_DEFAULT, "csr: failed to encode TBS", v81, 2u);
              }
            }
            CFDataRef v49 = make_signature(v61, v60, (__SecKey *)v28, Value, (DERSize *)&v76[2] + 1, (__CFString **)&error);
            if (!v49)
            {
              unsigned int v57 = secLogObjForScope("SecError");
              if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)uint64_t v81 = 0;
                _os_log_impl(&dword_18B299000, v57, OS_LOG_TYPE_DEFAULT, "csr: failed to make signature", v81, 2u);
              }
              SecKeyRef v22 = 0;
              CFDataRef v29 = 0;
              goto LABEL_25;
            }
            CFDataRef v29 = v49;
            uint64_t v78 = CFDataGetBytePtr(v49);
            *((void *)&v77 + 1) = 8 * CFDataGetLength(v29);
            int64_t v58 = 0;
            CFDictionaryRef v59 = 0;
            if (SEC_ASN1EncodeItem((uint64_t)v14, &v58, (uint64_t)buf, (uint64_t)&kSecAsn1SignedCertTemplate))
            {
              uint64_t v50 = SecCertificateCreateWithBytes(*MEMORY[0x1E4F1CF80], v59, v58);
              if (v50)
              {
                int v17 = v50;
                SecKeyRef v22 = 0;
                goto LABEL_66;
              }
              unsigned int v54 = secLogObjForScope("SecError");
              if (!os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_87;
              }
              *(_WORD *)uint64_t v81 = 0;
              unint64_t v55 = "csr: failed to decode encoded certificate";
            }
            else
            {
              unsigned int v54 = secLogObjForScope("SecError");
              if (!os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_87;
              }
              *(_WORD *)uint64_t v81 = 0;
              unint64_t v55 = "csr: failed to encode certificate";
            }
            _os_log_impl(&dword_18B299000, v54, OS_LOG_TYPE_DEFAULT, v55, v81, 2u);
LABEL_87:
            SecKeyRef v22 = 0;
            goto LABEL_25;
          }
          if (!a5)
          {
            CFTypeID v36 = CFGetTypeID(theDict);
            if (v36 == CFDictionaryGetTypeID() && !parameters_contains_extensions(theDict))
            {
LABEL_54:
              CFErrorRef v45 = secLogObjForScope("csr");
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)uint64_t v81 = 0;
                _os_log_debug_impl(&dword_18B299000, v45, OS_LOG_TYPE_DEBUG, "no extensions set", v81, 2u);
              }
              goto LABEL_56;
            }
LABEL_48:
            long long v42 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v81 = 0;
              _os_log_impl(&dword_18B299000, v42, OS_LOG_TYPE_DEFAULT, "csr: extensions or parameters wrong input type", v81, 2u);
            }
            goto LABEL_50;
          }
        }
        else if (!a5)
        {
          goto LABEL_54;
        }
        CFTypeID v37 = CFGetTypeID(a5);
        if (v37 == CFDataGetTypeID())
        {
          CFIndex v38 = CFDataGetLength((CFDataRef)a5);
          CFIndex v39 = (char *)CFDataGetBytePtr((CFDataRef)a5);
          if (!SEC_ASN1Decode((uint64_t)v14, (uint64_t)v76, (uint64_t)&kSecAsn1SequenceOfCertExtensionTemplate, v39, v38))goto LABEL_56; {
          long long v40 = secLogObjForScope("SecError");
          }
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v81 = 0;
            _os_log_impl(&dword_18B299000, v40, OS_LOG_TYPE_DEFAULT, "failed to decode requested CSR extensions", v81, 2u);
          }
        }
        else
        {
          CFTypeID v41 = CFGetTypeID(a5);
          if (v41 == CFDictionaryGetTypeID())
          {
            uint64_t v34 = (uint64_t)v14;
            CFDictionaryRef v35 = (const __CFDictionary *)a5;
            goto LABEL_46;
          }
        }
        goto LABEL_48;
      }
      CFDataRef v26 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v81 = 0;
        int64_t v27 = "csr: failed to decode input subject";
        goto LABEL_21;
      }
    }
    else
    {
LABEL_19:
      CFDataRef v26 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v81 = 0;
        int64_t v27 = "csr: unsupported subject CFType";
LABEL_21:
        _os_log_impl(&dword_18B299000, v26, OS_LOG_TYPE_DEFAULT, v27, v81, 2u);
      }
    }
    CFStringRef v28 = 0;
    CFDataRef v21 = 0;
LABEL_23:
    SecKeyRef v22 = 0;
LABEL_24:
    CFDataRef v29 = 0;
    CFDataRef v30 = 0;
LABEL_25:
    int v17 = 0;
LABEL_66:
    if (v80) {
      free(v72[1]);
    }
    if (v21) {
      CFRelease(v21);
    }
    if (v22) {
      CFRelease(v22);
    }
    if (v28) {
      CFRelease(v28);
    }
    PORT_FreeArena(v14, 1);
    if (v30) {
      CFRelease(v30);
    }
    if (v29) {
      CFRelease(v29);
    }
    if (error)
    {
      unsigned int v51 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v81 = 138412290;
        CFErrorRef v82 = error;
        _os_log_impl(&dword_18B299000, v51, OS_LOG_TYPE_DEFAULT, "csr: cert issuance failed: %@", v81, 0xCu);
      }
      CFErrorRef v52 = error;
      if (error)
      {
        CFErrorRef error = 0;
        CFRelease(v52);
      }
    }
    return v17;
  }
  unsigned int v16 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEFAULT, "csr: pool allocation failure", buf, 2u);
  }
  return 0;
}

BOOL parameters_contains_extensions(const __CFDictionary *a1)
{
  return CFDictionaryContainsKey(a1, @"subjectAltName")
      || CFDictionaryContainsKey(a1, @"keyUsage")
      || CFDictionaryContainsKey(a1, @"basicConstraintsCA")
      || CFDictionaryContainsKey(a1, @"basicConstraints")
      || CFDictionaryContainsKey(a1, @"certificateEKUs")
      || CFDictionaryContainsKey(a1, @"certificateExtensions")
      || CFDictionaryContainsKey(a1, @"certificateExtensionsEncoded") != 0;
}

void *SecIdentitySignCertificateWithAlgorithm(uint64_t a1, const __CFData *a2, __SecKey *a3, const void *a4, const void *a5, const void *a6)
{
  if (a6)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionaryAddValue(Mutable, (const void *)kSecCMSSignHashAlgorithm, a6);
    CFTypeID v13 = SecIdentitySignCertificateWithParameters(a1, a2, a3, a4, a5, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
    return v13;
  }
  else
  {
    return SecIdentitySignCertificateWithParameters(a1, a2, a3, a4, a5, 0);
  }
}

__CFData *SecGenerateCertificateRequestSubject(uint64_t a1, const __CFArray *a2)
{
  CFArrayRef v4 = PORT_NewArena(1024);
  if (v4)
  {
    char v5 = v4;
    uint64_t v6 = SecDERItemCopySequence(a1 + 184);
    *(void *)long long buf = 0;
    SecKeyRef v22 = 0;
    CFIndex Length = CFDataGetLength(v6);
    BytePtr = CFDataGetBytePtr(v6);
    subject = make_subject((uint64_t)v5, a2, 0);
    if (SEC_ASN1EncodeItem((uint64_t)v5, buf, (uint64_t)&subject, (uint64_t)&kSecAsn1NameTemplate))
    {
      uint64_t v18 = DERLengthOfLength(*(void *)buf + Length);
      CFIndex v9 = Length + *(void *)buf + v18 + 1;
      CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      CFDataSetLength(Mutable, v9);
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      UInt8 *MutableBytePtr = 48;
      CFDataRef v12 = MutableBytePtr + 1;
      if (DEREncodeLength(*(void *)buf + Length, (unint64_t)(MutableBytePtr + 1), (unint64_t *)&v18))
      {
        int v17 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v19 = 0;
          _os_log_impl(&dword_18B299000, v17, OS_LOG_TYPE_DEFAULT, "csr: failed to encode outer subject sequence", v19, 2u);
        }
      }
      else
      {
        CFTypeID v13 = &v12[v18];
        memcpy(v13, BytePtr, Length);
        memcpy(&v13[Length], v22, *(size_t *)buf);
      }
    }
    else
    {
      unsigned int v16 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v19 = 0;
        _os_log_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEFAULT, "csr: failed to encode subject", v19, 2u);
      }
      CFMutableDictionaryRef Mutable = 0;
    }
    if (v6) {
      CFRelease(v6);
    }
    PORT_FreeArena(v5, 1);
  }
  else
  {
    CFNumberRef v14 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEFAULT, "csr: pool allocation failure", buf, 2u);
    }
    return 0;
  }
  return Mutable;
}

uint64_t SecDHGetMaxKeyLength()
{
  return 8 * MEMORY[0x18C12D950]();
}

uint64_t SecDHCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  unint64_t v8 = (a3 + 7) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v9 = ccdh_gp_size();
  CFArrayRef v10 = malloc_type_malloc(v9 + 2 * v8 + 23, 0x21E4C0F7uLL);
  cc_clear();
  uint64_t result = ccdh_init_gp_from_bytes();
  if (result)
  {
    SecDHDestroy(v10);
    CFArrayRef v10 = 0;
    uint64_t result = 4294941020;
  }
  *a7 = v10;
  return result;
}

void SecDHDestroy(void *a1)
{
  MEMORY[0x18C12D950]();
  ccdh_gp_size();
  cc_clear();

  free(a1);
}

uint64_t SecDHCreateFromParameters(uint64_t a1, uint64_t a2, void *a3)
{
  v13[0] = a1;
  v13[1] = a2;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[0] = v4;
  v12[1] = v4;
  v11[0] = v4;
  v11[1] = v4;
  int v10 = 0;
  uint64_t result = DERParseSequence((uint64_t)v13, 4u, (uint64_t)&DER_DHParamsItemSpecs, (unint64_t)v11, 0x40uLL);
  if (!result)
  {
    if (!*((void *)&v12[0] + 1) || (uint64_t result = DERParseInteger((char **)v12, &v10), !result))
    {
      unint64_t v6 = (*((void *)&v11[0] + 1) + 7) & 0xFFFFFFFFFFFFFFF8;
      size_t v7 = ccdh_gp_size() + 2 * v6 + 23;
      unint64_t v8 = malloc_type_malloc(v7, 0xFBD54782uLL);
      if (v8)
      {
        uint64_t v9 = v8;
        bzero(v8, v7);
        uint64_t result = ccdh_init_gp_from_bytes();
        if (result)
        {
          SecDHDestroy(v9);
          uint64_t v9 = 0;
          uint64_t result = 4294941021;
        }
        *a3 = v9;
      }
      else
      {
        return 4294967188;
      }
    }
  }
  return result;
}

uint64_t SecDHCreateFromAlgorithmId(uint64_t a1, uint64_t a2)
{
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v5[0] = v2;
  v5[1] = v2;
  v4[0] = a1;
  v4[1] = a2;
  DERParseSequence((uint64_t)v4, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)v5, 0x20uLL);
  return 4294941020;
}

uint64_t SecDHGenerateKeypair(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  MEMORY[0x18C12D950]();
  ccdh_gp_size();
  uint64_t result = ccdh_generate_key();
  if (!result)
  {
    MEMORY[0x18C12D950](a1);
    unint64_t v6 = ccn_write_uint_size();
    if (*a3 >= v6)
    {
      unint64_t v7 = v6;
      MEMORY[0x18C12D950](a1);
      ccn_write_uint();
      uint64_t result = 0;
      *a3 = v7;
    }
    else
    {
      return 4294941995;
    }
  }
  return result;
}

uint64_t dhRngCallback()
{
  return CCRandomCopyBytes();
}

uint64_t SecDHComputeKey(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, size_t *a5)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x18C12D950]();
  ccdh_gp_size();
  uint64_t v7 = ccdh_ccn_size();
  MEMORY[0x1F4188790](v7);
  if (v9 >= 0x10)
  {
    int v10 = (size_t *)((char *)v17 - v8);
    do
    {
      *int v10 = 0xAAAAAAAAAAAAAAAALL;
      v10[1] = 0xAAAAAAAAAAAAAAAALL;
      v10 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  if (ccdh_import_pub()) {
    return 4294941021;
  }
  v17[0] = ccdh_ccn_size();
  CFDataRef v12 = malloc_type_calloc(1uLL, v17[0], 0x44DBF668uLL);
  if (!v12) {
    return 4294967188;
  }
  CFTypeID v13 = v12;
  if (ccdh_compute_shared_secret())
  {
    uint64_t v11 = 4294941021;
  }
  else
  {
    size_t v14 = v17[0];
    size_t v15 = *a5;
    if (v17[0] < *a5)
    {
      *a5 = v17[0];
      size_t v15 = v14;
    }
    memcpy(a4, v13, v15);
    uint64_t v11 = 0;
  }
  free(v13);
  return v11;
}

__CFData *SecECPublicKeyCopyExternalRepresentation()
{
  return SecECPublicKeyExport(0);
}

__CFData *SecECKeyCopyWrapKey(__SecKey *a1, int a2, const __CFData *a3, const __CFDictionary *a4, uint64_t a5, __CFString **a6)
{
  char valuePtr = 0;
  int v27 = 0;
  if (a2 != 1)
  {
    SecError(-4, a6, @"unsupported key wrapping algorithm");
    return 0;
  }
  int NamedCurve = SecECKeyGetNamedCurve(a1);
  uint64_t v10 = MEMORY[0x1E4F14690];
  if (NamedCurve != 25) {
    uint64_t v10 = 0;
  }
  if (NamedCurve == 23) {
    uint64_t v11 = MEMORY[0x1E4F14688];
  }
  else {
    uint64_t v11 = v10;
  }
  if (!v11)
  {
    SecError(-4, a6, @"unsupported curve");
    return 0;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a4, @"kSecKeyWrapPGPSymAlg");
  if (!Value
    || (v13 = Value, CFTypeID v14 = CFGetTypeID(Value), v14 != CFNumberGetTypeID())
    || !CFNumberGetValue(v13, kCFNumberSInt8Type, &valuePtr))
  {
    SecError(-4, a6, @"unknown symalg given");
    return 0;
  }
  CFDataRef v15 = (const __CFData *)CFDictionaryGetValue(a4, @"kSecKeyWrapPGPFingerprint");
  if (!v15 || (CFDataRef v16 = v15, v17 = CFGetTypeID(v15), v17 != CFDataGetTypeID()) || CFDataGetLength(v16) <= 19)
  {
    SecError(-4, a6, @"invalid fingerprint");
    return 0;
  }
  CFDataRef v20 = CFDictionaryGetValue(a4, @"kSecKeyWrapPGPWrapAlg");
  if (!v20)
  {
    SecError(-4, a6, @"no wrap alg");
    return 0;
  }
  CFDataRef v21 = v20;
  if (!CFEqual(v20, @"kSecKeyWrapPGPECWrapDigestSHA256KekAES128")
    && !CFEqual(v21, @"kSecKeyWrapPGPECWrapDigestSHA512KekAES256"))
  {
    SecError(-4, a6, @"unknown wrap alg");
    return 0;
  }
  CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(a4, @"kSecKeyWrapPGPECFlags");
  if (isNumber(v22))
  {
    if (!CFNumberGetValue(v22, kCFNumberSInt32Type, &v27))
    {
      SecError(-4, a6, @"invalid flags: %@", v22);
      return 0;
    }
  }
  else if (v22)
  {
    SecError(-4, a6, @"unknown flags");
    return 0;
  }
  CFDataGetLength(a3);
  uint64_t v23 = ccec_rfc6637_wrap_key_size();
  if (!v23)
  {
    SecError(-4, a6, @"can't wrap that key, can't build size");
    return 0;
  }
  CFIndex v24 = v23;
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  CFDataSetLength(Mutable, v24);
  if (Mutable)
  {
    CFDataGetMutableBytePtr(Mutable);
    CFDataGetLength(a3);
    CFDataGetBytePtr(a3);
    BytePtr = CFDataGetBytePtr(v16);
    uint64_t v26 = ccrng();
    if (ccec_rfc6637_wrap_key())
    {
      SecError(-4, a6, @"Failed to wrap key", BytePtr, v26);
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

const void *isNumber(const void *result)
{
  if (result)
  {
    CFTypeID v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFNumberGetTypeID());
  }
  return result;
}

uint64_t SecECPublicKeyCopyKeyDescription(__SecKey *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  unsigned int v2 = SecECKeyGetNamedCurve(a1) - 23;
  if (v2 > 2) {
    CFAllocatorRef v3 = "kSecECCurveNone";
  }
  else {
    CFAllocatorRef v3 = off_1E547F2F8[v2];
  }
  CFDataRef v21 = v3;
  uint64_t v22 = (uint64_t)a1;
  unint64_t v24 = cczp_bitlen() + 7;
  id v23 = [MEMORY[0x1E4F1CA58] dataWithLength:v24 >> 3];
  uint64_t v4 = 0;
  if (v24 >> 3 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v24 >> 3;
  }
  char v6 = 1;
  do
  {
    char v7 = v6;
    id v8 = v23;
    [v8 mutableBytes];
    ccn_write_uint();
    unint64_t v9 = [MEMORY[0x1E4F28E78] stringWithCapacity:2 * (v24 >> 3)];
    uint64_t v10 = (void *)*(&v25 + v4);
    *(&v25 + v4) = (uint64_t)v9;

    if (v24 >= 8)
    {
      uint64_t v11 = 0;
      do
        objc_msgSend(v9, "appendFormat:", @"%02X", *(unsigned __int8 *)(objc_msgSend(v8, "bytes") + v11++));
      while (v5 != v11);
    }
    char v6 = 0;
    uint64_t v4 = 1;
  }
  while ((v7 & 1) != 0);
  CFDataRef v12 = NSString;
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(v22);
  CFTypeID v14 = *(unsigned int **)(v22 + 16);
  uint64_t v15 = *((void *)v14 + 1);
  uint64_t v16 = *v14;
  _SecKeyCheck(v22, (uint64_t)"SecKeyGetBlockSize");
  CFTypeID v17 = *(uint64_t (**)(uint64_t))(*(void *)(v22 + 16) + 80);
  if (v17) {
    CFTypeID v17 = (uint64_t (*)(uint64_t))(8 * v17(v22));
  }
  uint64_t v18 = [v12 stringWithFormat:@"<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, y: %@, x: %@, addr: %p>", v21, AlgorithmId, v15, v16, v17, v26, v25, v22];

  for (uint64_t i = 8; i != -8; i -= 8)
  return v18;
}

uint64_t getCPForPublicSize()
{
  ccec_x963_import_pub_size();
  if (!ccec_keysize_is_supported()) {
    return 0;
  }

  return ccec_get_cp();
}

__CFData *SecECPrivateKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef Mutable = (__CFData *)*MEMORY[0x1E4F1D260];
  if (a2 != 4)
  {
    if (a2 || !CFEqual(cf1, @"algid:sign:ECDSA:digest-X962")) {
      return Mutable;
    }
    if (!a5)
    {
      unint64_t v29 = (((unint64_t)(cczp_bitlen() + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL) + 9;
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
      CFDataSetLength(Mutable, v29);
      CFDataGetLength(a6);
      CFDataGetBytePtr(a6);
      CFDataGetMutableBytePtr(Mutable);
      ccrng();
      uint64_t v14 = ccec_sign();
      if (v14)
      {
        uint64_t v28 = v14;
        if (Mutable) {
          CFRelease(Mutable);
        }
        SecError(-50, a8, @"%@: X962 signing failed (ccerr %d)", a1, v28, v29, v30);
        return 0;
      }
      else
      {
        CFDataSetLength(Mutable, v29);
      }
      return Mutable;
    }
    return (__CFData *)*MEMORY[0x1E4F1CFD0];
  }
  if (!CFEqual(cf1, @"algid:keyexchange:ECDH") && !CFEqual(cf1, @"algid:keyexchange:ECDHC")) {
    return Mutable;
  }
  if (a5) {
    return (__CFData *)*MEMORY[0x1E4F1CFD0];
  }
  CFDataGetLength(a6);
  uint64_t CPForPublicSize = getCPForPublicSize();
  if (CPForPublicSize)
  {
    uint64_t v16 = (void *)CPForPublicSize;
    MEMORY[0x1F4188790](CPForPublicSize);
    uint64_t v18 = (char *)&v29 - v17;
    if (v19 >= 0x10)
    {
      CFDataRef v20 = (unint64_t *)((char *)&v29 - v17);
      do
      {
        *CFDataRef v20 = 0xAAAAAAAAAAAAAAAALL;
        v20[1] = 0xAAAAAAAAAAAAAAAALL;
        v20 += 2;
        v17 -= 16;
      }
      while (v17);
    }
    CFIndex Length = CFDataGetLength(a6);
    BytePtr = CFDataGetBytePtr(a6);
    uint64_t v23 = MEMORY[0x18C12DB10](v16, Length, BytePtr, v18);
    if (v23)
    {
      SecError(-50, a8, @"ECpriv sharedsecret: bad public key (err %d)", v23);
    }
    else
    {
      CFIndex v24 = 8 * *v16;
      unint64_t v29 = v24;
      if (SecCFAllocatorZeroize_sOnce != -1) {
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
      }
      CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
      CFDataSetLength(Mutable, v24);
      CFDataGetMutableBytePtr(Mutable);
      ccrng();
      uint64_t v25 = ccecdh_compute_shared_secret();
      if (v25)
      {
        uint64_t v27 = v25;
        if (Mutable) {
          CFRelease(Mutable);
        }
        SecError(-26275, a8, @"ECpriv failed to compute shared secret (err %d)", v27);
        return 0;
      }
      else
      {
        CFDataSetLength(Mutable, v29);
      }
    }
  }
  else
  {
    SecError(-50, a8, @"ECpriv sharedsecret: bad public key");
  }
  return Mutable;
}

__CFData *SecECPrivateKeyCopyExternalRepresentation()
{
  uint64_t v0 = cczp_bitlen();
  uint64_t v1 = cczp_bitlen();
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  CFDataSetLength(Mutable, (((unint64_t)(v1 + 7) >> 2) | 1) + ((unint64_t)(v0 + 7) >> 3));
  CFDataGetMutableBytePtr(Mutable);
  ccec_export_pub();
  CFDataGetMutableBytePtr(Mutable);
  cczp_bitlen();
  ccn_write_uint_padded();
  return Mutable;
}

__CFData *SecECKeyCopyUnwrapKey(__SecKey *a1, uint64_t a2, const __CFData *a3, const __CFDictionary *a4, __CFDictionary **a5, __CFString **a6)
{
  char v31 = 0;
  int valuePtr = 0;
  int NamedCurve = SecECKeyGetNamedCurve(a1);
  uint64_t v11 = MEMORY[0x1E4F14690];
  if (NamedCurve != 25) {
    uint64_t v11 = 0;
  }
  if (NamedCurve == 23) {
    uint64_t v12 = MEMORY[0x1E4F14688];
  }
  else {
    uint64_t v12 = v11;
  }
  if (!v12)
  {
    SecError(-4, a6, @"unsupported curve");
    return 0;
  }
  CFNumberRef Value = CFDictionaryGetValue(a4, @"kSecKeyWrapPGPWrapAlg");
  if (!Value)
  {
    SecError(-4, a6, @"no wrap alg");
    return 0;
  }
  uint64_t v14 = Value;
  if (!CFEqual(Value, @"kSecKeyWrapPGPECWrapDigestSHA256KekAES128")
    && !CFEqual(v14, @"kSecKeyWrapPGPECWrapDigestSHA512KekAES256"))
  {
    SecError(-4, a6, @"unknown wrap alg");
    return 0;
  }
  CFDataRef v15 = (const __CFData *)CFDictionaryGetValue(a4, @"kSecKeyWrapPGPFingerprint");
  if (!v15 || (CFDataRef v16 = v15, v17 = CFGetTypeID(v15), v17 != CFDataGetTypeID()) || CFDataGetLength(v16) <= 19)
  {
    SecError(-4, a6, @"invalid fingerprint");
    return 0;
  }
  CFNumberRef v20 = (const __CFNumber *)CFDictionaryGetValue(a4, @"kSecKeyWrapPGPECFlags");
  if (v20)
  {
    CFNumberRef v21 = v20;
    CFTypeID v22 = CFGetTypeID(v20);
    if (v22 != CFNumberGetTypeID())
    {
      SecError(-4, a6, @"unknown flags");
      return 0;
    }
    if (!CFNumberGetValue(v21, kCFNumberSInt32Type, &valuePtr))
    {
      SecError(-4, a6, @"invalid flags: %@", v21);
      return 0;
    }
  }
  unint64_t Length = CFDataGetLength(a3);
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  CFDataSetLength(Mutable, Length);
  if (Mutable)
  {
    CFDataGetMutableBytePtr(Mutable);
    CFDataGetBytePtr(v16);
    CFIndex v28 = CFDataGetLength(a3);
    BytePtr = CFDataGetBytePtr(a3);
    if (ccec_rfc6637_unwrap_key())
    {
      CFRelease(Mutable);
      SecError(-4, a6, @"failed to wrap key", v28, BytePtr);
      return 0;
    }
    if (Length > CFDataGetLength(Mutable)) {
      __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
    }
    CFDataSetLength(Mutable, Length);
    if (a5)
    {
      CFMutableDictionaryRef v24 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v24)
      {
        uint64_t v25 = v24;
        CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt8Type, &v31);
        if (v26)
        {
          CFNumberRef v27 = v26;
          CFDictionarySetValue(v25, @"kSecKeyWrapPGPSymAlg", v26);
          CFRelease(v27);
        }
        *a5 = v25;
      }
    }
  }
  return Mutable;
}

uint64_t SecECPrivateKeyCopyPublicOctets(const void *a1, __CFData **a2)
{
  CFAllocatorRef v3 = CFGetAllocator(a1);
  uint64_t v4 = SecECPublicKeyExport(v3);
  *a2 = v4;
  if (v4) {
    return 0;
  }
  else {
    return 4294941021;
  }
}

CFStringRef SecECPrivateKeyCopyKeyDescription(__SecKey *a1)
{
  unsigned int v2 = SecECKeyGetNamedCurve(a1) - 23;
  if (v2 > 2) {
    CFAllocatorRef v3 = "kSecECCurveNone";
  }
  else {
    CFAllocatorRef v3 = off_1E547F2F8[v2];
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)a1);
  char v6 = (unsigned int *)*((void *)a1 + 2);
  uint64_t v7 = *((void *)v6 + 1);
  uint64_t v8 = *v6;
  _SecKeyCheck((uint64_t)a1, (uint64_t)"SecKeyGetBlockSize");
  unint64_t v9 = *(uint64_t (**)(__SecKey *))(*((void *)a1 + 2) + 80);
  if (v9) {
    unint64_t v9 = (uint64_t (*)(__SecKey *))(8 * v9(a1));
  }
  return CFStringCreateWithFormat(v4, 0, @"<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>", v3, AlgorithmId, v7, v8, v9, a1);
}

CFDictionaryRef SecECPrivateKeyCopyAttributeDictionary(const void *a1)
{
  unsigned int v2 = SecECPrivateKeyCopyExternalRepresentation();
  CFDictionaryRef v3 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, @"73", v2);
  if (v2) {
    CFRelease(v2);
  }
  return v3;
}

unint64_t SecECPrivateKeyBlockSize()
{
  return (unint64_t)(cczp_bitlen() + 7) >> 3;
}

uint64_t SecECPrivateKeyDestroy(uint64_t result)
{
  if (**(void **)(result + 24)) {
    return cc_clear();
  }
  return result;
}

uint64_t SecECPrivateKeyInit(uint64_t a1, CFDictionaryRef theDict, unint64_t a3, int a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  char v6 = *(uint64_t **)(a1 + 24);
  if (a4 == 7)
  {
    ccec_x963_import_priv_size();
    if (!ccec_keysize_is_supported()) {
      return 4294967246;
    }
    uint64_t cp = ccec_get_cp();
    if (!cp) {
      return 4294967246;
    }
    uint64_t v13 = cp;
    *char v6 = cp;
    unint64_t v14 = (unint64_t)(cczp_bitlen() + 7) >> 2;
    if (a3 <= (v14 | 1)) {
      return 4294967246;
    }
    uint64_t v15 = 4294941021;
    if (!MEMORY[0x18C12DB10](v13, v14 | 1, theDict, v6))
    {
      if (ccn_read_uint()) {
        return 4294941021;
      }
      else {
        return 0;
      }
    }
  }
  else
  {
    if (a4 != 5)
    {
      if (a4 == 1)
      {
        *(void *)int valuePtr = 0xAAAAAAAAAAAAAAAALL;
        if (!ccec_der_import_priv_keytype())
        {
          uint64_t v7 = ccec_cp_for_oid_0(*(uint64_t *)valuePtr);
          if (!v7)
          {
            ccec_cp_192();
            MEMORY[0x18C12DA60]();
            MEMORY[0x18C12DA70]();
            MEMORY[0x18C12DA80]();
            ccec_cp_521();
            uint64_t v7 = ccec_curve_for_length_lookup();
            if (!v7) {
              return 4294941021;
            }
          }
          *char v6 = v7;
          int key_fips = ccec_der_import_priv();
          goto LABEL_23;
        }
      }
      return 4294967246;
    }
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"bsiz");
    if (Value)
    {
      CFNumberRef v10 = Value;
      CFTypeID v11 = CFGetTypeID(Value);
      if (v11 == CFNumberGetTypeID())
      {
        *(void *)int valuePtr = 0xAAAAAAAAAAAAAAAALL;
        CFNumberGetValue(v10, kCFNumberCFIndexType, valuePtr);
      }
      else
      {
        CFTypeID v16 = CFGetTypeID(v10);
        if (v16 == CFStringGetTypeID()) {
          CFStringGetIntValue((CFStringRef)v10);
        }
      }
    }
    if (ccec_get_cp())
    {
      ccrng();
      int key_fips = ccec_generate_key_fips();
LABEL_23:
      if (key_fips) {
        return 4294967246;
      }
      else {
        return 0;
      }
    }
    uint64_t v18 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int valuePtr = 138412290;
      *(void *)&valuePtr[4] = theDict;
      _os_log_impl(&dword_18B299000, v18, OS_LOG_TYPE_DEFAULT, "Invalid or missing key size in: %@", valuePtr, 0xCu);
    }

    return 4294941985;
  }
  return v15;
}

void *SecKeyCreateECPublicKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SecKeyCreate(a1, (uint64_t)&kSecECPublicKeyDescriptor, a2, a3, a4);
}

void *SecKeyCreateECPrivateKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SecKeyCreate(a1, (uint64_t)&kSecECPrivateKeyDescriptor, a2, a3, a4);
}

uint64_t SecECKeyGeneratePair(uint64_t a1, void *a2, void *a3)
{
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  uint64_t v6 = SecCFAllocatorZeroize_sAllocator;
  uint64_t v7 = SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)&kSecECPrivateKeyDescriptor, a1, 0, 5);
  if (!v7) {
    return 4294967246;
  }
  uint64_t v8 = v7;
  unint64_t v9 = SecKeyCreate(v6, (uint64_t)&kSecECPublicKeyDescriptor, v7[3], 0, 6);
  if (!v9)
  {
    uint64_t v10 = 4294967246;
LABEL_12:
    CFRelease(v8);
    return v10;
  }
  if (a2)
  {
    *a2 = v9;
    unint64_t v9 = 0;
  }
  if (a3)
  {
    *a3 = v8;
    uint64_t v8 = 0;
  }
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = 0;
  uint64_t result = 0;
  if (v8) {
    goto LABEL_12;
  }
  return result;
}

uint64_t SecECKeyCopyPublicBits(uint64_t a1)
{
  uint64_t v2 = 0;
  SecKeyCopyPublicBytes(a1, (uint64_t)&v2);
  return v2;
}

BOOL SecECDoWithFullKey(uint64_t a1, __CFString **a2, uint64_t a3)
{
  if (*(_UNKNOWN **)(a1 + 16) == &kSecECPrivateKeyDescriptor)
  {
    (*(void (**)(uint64_t, void))(a3 + 16))(a3, *(void *)(a1 + 24));
    return 1;
  }
  else
  {
    return SecError(-50, a2, @"Not an EC Full Key object, sorry can't do.");
  }
}

BOOL SecECDoWithPubKey(uint64_t a1, __CFString **a2, uint64_t a3)
{
  if (*(_UNKNOWN **)(a1 + 16) == &kSecECPublicKeyDescriptor)
  {
    (*(void (**)(uint64_t, void))(a3 + 16))(a3, *(void *)(a1 + 24));
    return 1;
  }
  else
  {
    return SecError(-50, a2, @"Not an EC Public Key object, sorry can't do.");
  }
}

uint64_t SecCurve448PublicKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, const __CFData *a7, __CFString **a8)
{
  uint64_t v8 = *(void **)(a1 + 16);
  BOOL v9 = v8 == &kSecEd448PublicKeyDescriptor || v8 == &kSecEd448PrivateKeyDescriptor;
  if (!v9 || a2 != 1 || !CFEqual(cf1, @"algid:sign:EdDSA:message-Curve448:SHAKE256"))
  {
    uint64_t v14 = MEMORY[0x1E4F1D260];
    return *(void *)v14;
  }
  if (a5)
  {
LABEL_9:
    uint64_t v14 = MEMORY[0x1E4F1CFD0];
    return *(void *)v14;
  }
  CFIndex Length = CFDataGetLength(a7);
  CFDataGetBytePtr(a7);
  CFDataGetLength(a6);
  CFDataGetBytePtr(a6);
  if (Length == 114)
  {
    uint64_t v17 = cced448_verify();
    if (!v17) {
      goto LABEL_9;
    }
    SecError(-67808, a8, @"Ed448 signature verification failed (ccerr %d)", v17);
  }
  else
  {
    SecError(-67808, a8, @"Ed448 signature verification failed (invalid signature length)");
  }
  return 0;
}

__CFData *SecCurve448PrivateKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  CFMutableDictionaryRef Mutable = (__CFData *)*MEMORY[0x1E4F1D260];
  if (a2 != 4)
  {
    if (a2) {
      return Mutable;
    }
    uint64_t v14 = *(void **)(a1 + 16);
    BOOL v15 = v14 == &kSecEd448PublicKeyDescriptor || v14 == &kSecEd448PrivateKeyDescriptor;
    if (!v15 || !CFEqual(cf1, @"algid:sign:EdDSA:message-Curve448:SHAKE256")) {
      return Mutable;
    }
    if (!a5)
    {
      ccrng();
      if (cced448_make_pub())
      {
        SecError(-2070, a8, @"%@: Failed to get public key from private key", a1);
        return Mutable;
      }
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
      CFDataSetLength(Mutable, 114);
      if (!Mutable)
      {
        SecError(-108, a8, @"%@: Failed to create buffer for a signature", a1);
        return Mutable;
      }
      CFDataGetLength(a6);
      CFDataGetBytePtr(a6);
      CFDataGetMutableBytePtr(Mutable);
      ccrng();
      uint64_t v16 = cced448_sign();
      cc_clear();
      if (v16)
      {
        CFRelease(Mutable);
        SecError(-50, a8, @"%@: Ed448 signing failed (ccerr %d)", a1, v16, 0, 0, 0, 0, 0, 0, 0, 0);
        return 0;
      }
      return Mutable;
    }
    return (__CFData *)*MEMORY[0x1E4F1CFD0];
  }
  uint64_t v17 = *(void **)(a1 + 16);
  BOOL v18 = v17 == &kSecEd448PublicKeyDescriptor || v17 == &kSecEd448PrivateKeyDescriptor;
  if (v18 || !CFEqual(cf1, @"algid:keyexchange:ECDH") && !CFEqual(cf1, @"algid:keyexchange:ECDHC")) {
    return Mutable;
  }
  if (a5) {
    return (__CFData *)*MEMORY[0x1E4F1CFD0];
  }
  CFDataGetBytePtr(a6);
  if (CFDataGetLength(a6) == 56)
  {
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
    }
    CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
    CFDataSetLength(Mutable, 56);
    CFDataSetLength(Mutable, 56);
    ccrng();
    CFDataGetMutableBytePtr(Mutable);
    uint64_t v19 = cccurve448();
    if (v19)
    {
      uint64_t v21 = v19;
      if (Mutable) {
        CFRelease(Mutable);
      }
      SecError(-50, a8, @"%@: X448 DH failed (ccerr %d)", a1, v21);
      return 0;
    }
  }
  else
  {
    SecError(-50, a8, @"X448priv sharedsecret: bad public key");
  }
  return Mutable;
}

CFDataRef SecCurve448PrivateKeyCopyExternalRepresentation(void *a1)
{
  uint64_t v2 = (const UInt8 *)a1[3];
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFAllocatorRef v4 = (void *)a1[2];
  if (v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor) {
    CFIndex v6 = 57;
  }
  else {
    CFIndex v6 = 56;
  }

  return CFDataCreate(v3, v2, v6);
}

uint64_t SecCurve448KeyCopyUnwrapKey(int a1, int a2, int a3, int a4, int a5, __CFString **a6)
{
  return 0;
}

uint64_t SecCurve448PrivateKeyCopyPublicOctets(void *a1, CFDataRef *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = (void *)a1[2];
  if (v4 == &kSecEd448PublicKeyDescriptor || v4 == &kSecEd448PrivateKeyDescriptor)
  {
    long long v11 = 0u;
    memset(v12, 0, sizeof(v12));
    long long v10 = 0u;
    ccrng();
    if (cced448_make_pub()) {
      return 4294941020;
    }
    CFAllocatorRef v6 = CFGetAllocator(a1);
    *a2 = CFDataCreate(v6, (const UInt8 *)&v10, 57);
  }
  else
  {
    long long v11 = 0u;
    memset(v12, 0, 24);
    long long v10 = 0u;
    ccrng();
    if (cccurve448_make_pub()) {
      return 4294941020;
    }
    CFAllocatorRef v9 = CFGetAllocator(a1);
    *a2 = CFDataCreate(v9, (const UInt8 *)&v10, 56);
  }
  cc_clear();
  if (*a2) {
    return 0;
  }
  else {
    return 4294941021;
  }
}

CFStringRef SecCurve448PrivateKeyCopyKeyDescription(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(a1);
  uint64_t v5 = *(unsigned int **)(a1 + 16);
  uint64_t v6 = *((void *)v5 + 1);
  uint64_t v7 = *v5;
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  uint64_t v8 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 80);
  if (v8) {
    uint64_t v8 = (uint64_t (*)(uint64_t))(8 * v8(a1));
  }
  BOOL v9 = v2 == &kSecEd448PrivateKeyDescriptor || v2 == &kSecEd448PublicKeyDescriptor;
  long long v10 = "kSecX448";
  if (v9) {
    long long v10 = "kSecEd448";
  }
  return CFStringCreateWithFormat(v3, 0, @"<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>", v10, AlgorithmId, v6, v7, v8, a1);
}

CFDictionaryRef SecCurve448PrivateKeyCopyAttributeDictionary(void *a1)
{
  uint64_t v2 = (const UInt8 *)a1[3];
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFAllocatorRef v4 = (void *)a1[2];
  if (v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor) {
    CFIndex v6 = 57;
  }
  else {
    CFIndex v6 = 56;
  }
  CFDataRef v7 = CFDataCreate(v3, v2, v6);
  uint64_t v8 = (void *)a1[2];
  if (v8 == &kSecEd448PrivateKeyDescriptor || v8 == &kSecEd448PublicKeyDescriptor) {
    long long v10 = @"107";
  }
  else {
    long long v10 = @"108";
  }
  CFDictionaryRef v11 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)v10, v7);
  if (v7) {
    CFRelease(v7);
  }
  return v11;
}

uint64_t SecCurve448PrivateKeyBlockSize(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  if (v1 == &kSecEd448PrivateKeyDescriptor || v1 == &kSecEd448PublicKeyDescriptor) {
    return 57;
  }
  else {
    return 56;
  }
}

uint64_t SecCurve448PrivateKeyDestroy()
{
  return cc_clear();
}

uint64_t SecCurve448PrivateKeyInit(uint64_t a1, const void *a2, size_t a3, int a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a4 == 5)
  {
    CFDataRef v7 = *(void **)(a1 + 16);
    if (v7 == &kSecEd448PublicKeyDescriptor || v7 == &kSecEd448PrivateKeyDescriptor)
    {
      long long v19 = 0u;
      memset(v20, 0, sizeof(v20));
      long long v18 = 0u;
      ccrng();
      int key_pair = cced448_make_key_pair();
      if (!key_pair)
      {
LABEL_19:
        cc_clear();
        return 0;
      }
      int v14 = key_pair;
      uint64_t v12 = _SECKEY_LOG_9728();
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
LABEL_25:

        return 4294941021;
      }
      *(_DWORD *)long long buf = 67109120;
      int v17 = v14;
      uint64_t v13 = "cced448_make_key_pair() failed, error %d";
    }
    else
    {
      long long v19 = 0u;
      memset(v20, 0, 24);
      long long v18 = 0u;
      ccrng();
      int v11 = cccurve448_make_key_pair();
      if (!v11) {
        goto LABEL_19;
      }
      int v15 = v11;
      uint64_t v12 = _SECKEY_LOG_9728();
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 67109120;
      int v17 = v15;
      uint64_t v13 = "ccec448_make_key_pair() failed, error %d";
    }
    _os_log_error_impl(&dword_18B299000, v12, OS_LOG_TYPE_ERROR, v13, buf, 8u);
    goto LABEL_25;
  }
  if (a4 != 7) {
    return 4294899625;
  }
  CFAllocatorRef v4 = *(void **)(a1 + 16);
  BOOL v5 = v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor;
  uint64_t v6 = 56;
  if (v5) {
    uint64_t v6 = 57;
  }
  if (v6 != a3) {
    return 4294941021;
  }
  memcpy(*(void **)(a1 + 24), a2, a3);
  return 0;
}

id _SECKEY_LOG_9728()
{
  if (_SECKEY_LOG_once_9731 != -1) {
    dispatch_once(&_SECKEY_LOG_once_9731, &__block_literal_global_9732);
  }
  uint64_t v0 = (void *)_SECKEY_LOG_log_9733;

  return v0;
}

CFDataRef SecCurve448PublicKeyCopyExternalRepresentation(void *a1)
{
  uint64_t v2 = (const UInt8 *)a1[3];
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFAllocatorRef v4 = (void *)a1[2];
  if (v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor) {
    CFIndex v6 = 57;
  }
  else {
    CFIndex v6 = 56;
  }

  return CFDataCreate(v3, v2, v6);
}

uint64_t SecCurve448KeyCopyWrapKey(int a1, int a2, int a3, int a4, int a5, __CFString **a6)
{
  return 0;
}

uint64_t SecCurve448PublicKeyCopyPublicOctets(void *a1, CFDataRef *a2)
{
  CFAllocatorRef v4 = (const UInt8 *)a1[3];
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFIndex v6 = (void *)a1[2];
  if (v6 == &kSecEd448PrivateKeyDescriptor || v6 == &kSecEd448PublicKeyDescriptor) {
    CFIndex v8 = 57;
  }
  else {
    CFIndex v8 = 56;
  }
  CFDataRef v9 = CFDataCreate(v5, v4, v8);
  *a2 = v9;
  if (v9) {
    return 0;
  }
  else {
    return 4294941021;
  }
}

uint64_t SecCurve448KeyGetAlgorithmID(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  if (v1 == &kSecEd448PrivateKeyDescriptor || v1 == &kSecEd448PublicKeyDescriptor) {
    return 6;
  }
  else {
    return 7;
  }
}

uint64_t SecCurve448PublicKeyCopyKeyDescription(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  CFAllocatorRef v3 = NSString;
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(a1);
  CFAllocatorRef v5 = *(unsigned int **)(a1 + 16);
  uint64_t v6 = *((void *)v5 + 1);
  uint64_t v7 = *v5;
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  CFIndex v8 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 80);
  if (v8) {
    CFIndex v8 = (uint64_t (*)(uint64_t))(8 * v8(a1));
  }
  BOOL v9 = v2 == &kSecEd448PrivateKeyDescriptor || v2 == &kSecEd448PublicKeyDescriptor;
  long long v10 = "kSecX448";
  if (v9) {
    long long v10 = "kSecEd448";
  }
  [v3 stringWithFormat:@"<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>", v10, AlgorithmId, v6, v7, v8, a1];
  return objc_claimAutoreleasedReturnValue();
}

__CFDictionary *SecCurve448PublicKeyCopyAttributeDictionary(void *a1)
{
  uint64_t v1 = (void *)a1[2];
  if (v1 == &kSecEd448PrivateKeyDescriptor || v1 == &kSecEd448PublicKeyDescriptor) {
    CFAllocatorRef v3 = @"107";
  }
  else {
    CFAllocatorRef v3 = @"108";
  }
  CFDictionaryRef v4 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)v3, 0);
  CFStringRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v4);
  CFDictionarySetValue(MutableCopy, @"drve", (const void *)*MEMORY[0x1E4F1CFC8]);
  if (v4) {
    CFRelease(v4);
  }
  return MutableCopy;
}

uint64_t SecCurve448PublicKeyBlockSize(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  if (v1 == &kSecEd448PrivateKeyDescriptor || v1 == &kSecEd448PublicKeyDescriptor) {
    return 57;
  }
  else {
    return 56;
  }
}

uint64_t SecCurve448PublicKeyDestroy()
{
  return cc_clear();
}

uint64_t SecCurve448PublicKeyInit(uint64_t a1, void *__src, size_t a3, int a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a4 != 6)
  {
    if (a4 != 7) {
      return 4294967246;
    }
    CFDictionaryRef v4 = *(void **)(a1 + 16);
    BOOL v5 = v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor;
    uint64_t v6 = 56;
    if (v5) {
      uint64_t v6 = 57;
    }
    if (v6 == a3)
    {
      memcpy(*(void **)(a1 + 24), __src, a3);
      return 0;
    }
    return 4294941021;
  }
  CFIndex v8 = *(void **)(a1 + 16);
  BOOL v9 = v8 == &kSecEd448PublicKeyDescriptor || v8 == &kSecEd448PrivateKeyDescriptor;
  int v10 = v9;
  uint64_t v11 = 56;
  if (v9) {
    uint64_t v11 = 57;
  }
  if (v11 != a3) {
    return 4294941021;
  }
  ccrng();
  if (v10)
  {
    uint64_t result = cced448_make_pub();
    if (result)
    {
      int v12 = result;
      uint64_t v13 = _SECKEY_LOG_9728();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        int v16 = 67109120;
        int v17 = v12;
        int v14 = "cced448_make_pub() failed, error %d";
LABEL_30:
        _os_log_error_impl(&dword_18B299000, v13, OS_LOG_TYPE_ERROR, v14, (uint8_t *)&v16, 8u);
        goto LABEL_27;
      }
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t result = cccurve448_make_pub();
    if (result)
    {
      int v15 = result;
      uint64_t v13 = _SECKEY_LOG_9728();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        int v16 = 67109120;
        int v17 = v15;
        int v14 = "cccurve448_make_pub() failed, error %d";
        goto LABEL_30;
      }
LABEL_27:

      return 4294941021;
    }
  }
  return result;
}

uint64_t curve448KeyGeneratePair(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  uint64_t v8 = SecCFAllocatorZeroize_sAllocator;
  if (a4 == 6) {
    BOOL v9 = &kSecEd448PrivateKeyDescriptor;
  }
  else {
    BOOL v9 = &kSecX448PrivateKeyDescriptor;
  }
  int v10 = SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)v9, a1, 0, 5);
  if (!v10) {
    return 4294967246;
  }
  uint64_t v11 = v10;
  if (a4 == 6) {
    int v12 = &kSecEd448PublicKeyDescriptor;
  }
  else {
    int v12 = &kSecX448PublicKeyDescriptor;
  }
  if (a4 == 6) {
    uint64_t v13 = 57;
  }
  else {
    uint64_t v13 = 56;
  }
  int v14 = SecKeyCreate(v8, (uint64_t)v12, v10[3], v13, 6);
  if (!v14)
  {
    uint64_t v15 = 4294967246;
LABEL_21:
    CFRelease(v11);
    return v15;
  }
  if (a2)
  {
    *a2 = v14;
    int v14 = 0;
  }
  if (a3)
  {
    *a3 = v11;
    uint64_t v11 = 0;
  }
  if (v14) {
    CFRelease(v14);
  }
  uint64_t v15 = 0;
  uint64_t result = 0;
  if (v11) {
    goto LABEL_21;
  }
  return result;
}

id SecEMCSCreateDerivedEMCSKey(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
  CFDictionaryRef v4 = a1;
  CFNumberRef Value = CFDictionaryGetValue(v4, @"salt");
  uint64_t v6 = CFDictionaryGetValue(v4, @"iter");
  uint64_t v7 = CFDictionaryGetValue(v4, @"wkey");

  if (!Value)
  {
LABEL_10:
    BOOL v9 = 0;
    goto LABEL_11;
  }
  CFTypeID v8 = CFGetTypeID(Value);
  BOOL v9 = 0;
  if (v8 == CFDataGetTypeID())
  {
    if (v6)
    {
      CFTypeID v10 = CFGetTypeID(v6);
      BOOL v9 = 0;
      if (v10 == CFNumberGetTypeID())
      {
        if (v7)
        {
          CFTypeID v11 = CFGetTypeID(v7);
          if (v11 == CFDataGetTypeID())
          {
            if (CFNumberGetValue((CFNumberRef)v6, kCFNumberLongType, &valuePtr))
            {
              DerivedKey = CreateDerivedKey((const __CFData *)Value, valuePtr, v3);
              if (DerivedKey)
              {
                uint64_t v13 = DerivedKey;
                BOOL v9 = CopyUnwrappedKey(DerivedKey, (const __CFData *)v7);
                CFRelease(v13);
                goto LABEL_11;
              }
            }
          }
          goto LABEL_10;
        }
      }
    }
  }
LABEL_11:

  return v9;
}

__CFData *CreateDerivedKey(const __CFData *a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (a2 < 1000 || CFDataGetLength(a1) < 16) {
    goto LABEL_8;
  }
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 16);
  uint64_t v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, 16);
    ccsha256_di();
    id v8 = v5;
    strlen((const char *)[v8 UTF8String]);
    [v8 UTF8String];
    CFDataGetLength(a1);
    CFDataGetBytePtr(a1);
    CFDataGetMutableBytePtr(v7);
    if (ccpbkdf2_hmac())
    {
      CFRelease(v7);
LABEL_8:
      uint64_t v7 = 0;
    }
  }

  return v7;
}

__CFData *CopyUnwrappedKey(const __CFData *a1, const __CFData *a2)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  ccaes_ecb_decrypt_mode();
  uint64_t v4 = ccecb_context_size();
  MEMORY[0x1F4188790](v4);
  if (v6 >= 0x10)
  {
    uint64_t v7 = (void *)((char *)v14 - v5);
    do
    {
      void *v7 = 0xAAAAAAAAAAAAAAAALL;
      v7[1] = 0xAAAAAAAAAAAAAAAALL;
      v7 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  if (CFDataGetLength(a2) < 8 || CFDataGetLength(a1) != 16) {
    goto LABEL_11;
  }
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccecb_init();
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFAllocatorRef v8 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFDataGetLength(a2);
  CFIndex v9 = ccwrap_unwrapped_size();
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v8, 0);
  CFDataSetLength(Mutable, v9);
  if (!Mutable) {
    goto LABEL_11;
  }
  v14[0] = 0;
  CFDataGetLength(a2);
  CFDataGetBytePtr(a2);
  CFTypeID v11 = Mutable;
  [(__CFData *)v11 mutableBytes];
  if (ccwrap_auth_decrypt())
  {

LABEL_11:
    CFTypeID v11 = 0;
    goto LABEL_14;
  }
  uint64_t v12 = v14[0];
  if (v12 != [(__CFData *)v11 length]) {
    __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
  }
LABEL_14:
  ccecb_context_size();
  cc_clear();

  return v11;
}

__CFData *SecEMCSCreateNewiDMSKey(void *a1, void *a2, void *a3, void *a4)
{
  keys[3] = *(void **)MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  uint64_t v21 = 1000;
  if (a4) {
    *a4 = 0;
  }
  if (v8)
  {
    CFTypeID v10 = CFGetTypeID(v8);
    if (v10 != CFDataGetTypeID() || CFDataGetLength((CFDataRef)v8) != 16)
    {
      int v14 = 0;
      goto LABEL_13;
    }
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, 16);
  if (!Mutable)
  {
    uint64_t v12 = 0;
    goto LABEL_12;
  }
  CFDataGetLength(Mutable);
  CFDataGetMutableBytePtr(Mutable);
  if (!CCRandomCopyBytes())
  {
    CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v21);
    if (v16)
    {
      CFNumberRef v17 = v16;
      if (SecCFAllocatorZeroize_sOnce != -1) {
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
      }
      if (v8)
      {
        CFStringRef MutableCopy = CFDataCreateMutableCopy((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0, (CFDataRef)v8);
      }
      else
      {
        CFStringRef MutableCopy = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
        CFDataSetLength(MutableCopy, 16);
        if (!MutableCopy
          || (CFDataGetLength(MutableCopy), CFDataGetMutableBytePtr(MutableCopy), CCRandomCopyBytes()))
        {
          uint64_t v13 = 0;
          goto LABEL_29;
        }
      }
      DerivedKey = CreateDerivedKey(Mutable, 1000, v9);
      uint64_t v12 = DerivedKey;
      if (!DerivedKey)
      {
        uint64_t v13 = 0;
        goto LABEL_31;
      }
      uint64_t v13 = CopyWrappedKey(DerivedKey, MutableCopy);
      CFRelease(v12);
      if (v13)
      {
        keys[0] = @"salt";
        keys[1] = @"iter";
        keys[2] = @"wkey";
        values[0] = Mutable;
        values[1] = v17;
        values[2] = v13;
        CFDictionaryRef v20 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        uint64_t v12 = v20;
        if (a4 && v20)
        {
          CFRetain(MutableCopy);
          *a4 = (id)objc_claimAutoreleasedReturnValue();
        }
LABEL_31:
        CFRelease(Mutable);
        CFRelease(v17);
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
        if (!v13) {
          goto LABEL_12;
        }
        goto LABEL_9;
      }
LABEL_29:
      uint64_t v12 = 0;
      goto LABEL_31;
    }
  }
  uint64_t v12 = 0;
  uint64_t v13 = Mutable;
LABEL_9:
  CFRelease(v13);
LABEL_12:
  int v14 = v12;
LABEL_13:

  return v14;
}

__CFData *CopyWrappedKey(const __CFData *a1, const __CFData *a2)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  ccaes_ecb_encrypt_mode();
  uint64_t v4 = ccecb_context_size();
  MEMORY[0x1F4188790](v4);
  if (v6 >= 0x10)
  {
    id v7 = (void *)((char *)v12 - v5);
    do
    {
      void *v7 = 0xAAAAAAAAAAAAAAAALL;
      v7[1] = 0xAAAAAAAAAAAAAAAALL;
      v7 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  if (CFDataGetLength(a1) != 16) {
    goto LABEL_8;
  }
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccecb_init();
  CFDataGetLength(a2);
  CFIndex v8 = ccwrap_wrapped_size();
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v8);
  v12[0] = 0;
  CFDataGetLength(a2);
  CFDataGetBytePtr(a2);
  CFDataGetMutableBytePtr(Mutable);
  if (ccwrap_auth_encrypt())
  {
    if (Mutable)
    {
      CFRelease(Mutable);
LABEL_8:
      CFMutableDictionaryRef Mutable = 0;
    }
  }
  else
  {
    uint64_t v10 = v12[0];
    if (v10 != CFDataGetLength(Mutable)) {
      __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
    }
  }
  ccecb_context_size();
  cc_clear();
  return Mutable;
}

uint64_t SecKyberPublicKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, __CFString **a8)
{
  void v23[2] = *MEMORY[0x1E4F143B8];
  if (a2 != 5 || !CFEqual(cf1, @"algid:kem:kyber"))
  {
    uint64_t v11 = MEMORY[0x1E4F1D260];
    return *(void *)v11;
  }
  if (a5)
  {
    uint64_t v11 = MEMORY[0x1E4F1CFD0];
    return *(void *)v11;
  }
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFAllocatorRef v14 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex v15 = cckem_shared_key_nbytes_ctx();
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v14, 0);
  CFDataSetLength(Mutable, v15);
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFAllocatorRef v17 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex v18 = cckem_encapsulated_key_nbytes_ctx();
  long long v19 = CFDataCreateMutable(v17, 0);
  CFDataSetLength(v19, v18);
  [(__CFData *)v19 length];
  CFDictionaryRef v20 = v19;
  [(__CFData *)v20 mutableBytes];
  [(__CFData *)Mutable length];
  uint64_t v21 = Mutable;
  [(__CFData *)v21 mutableBytes];
  ccrng();
  uint64_t v22 = cckem_encapsulate();
  if (v22) {
    SecError(-26275, a8, @"Key encapsulation failed, err=%d for key %@", v22, a1);
  }
  v23[0] = v20;
  v23[1] = v21;
  uint64_t v12 = [MEMORY[0x1E4F1C978] arrayWithObjects:v23 count:2];

  return v12;
}

__CFData *SecKyberPublicKeyCopyExternalRepresentation(uint64_t a1, __CFString **a2)
{
  return SecKyberPublicKeyCopyData(*(void *)(a1 + 24), a2);
}

__CFData *SecKyberPublicKeyCopyData(uint64_t a1, __CFString **a2)
{
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFAllocatorRef v3 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex v4 = cckem_pubkey_nbytes_ctx();
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v3, 0);
  CFDataSetLength(Mutable, v4);
  uint64_t v9 = [(__CFData *)Mutable length];
  unint64_t v6 = Mutable;
  [(__CFData *)v6 mutableBytes];
  if (cckem_export_pubkey())
  {
    SecError(-26275, a2, @"Failed to export Kyber pubkey");
    id v7 = 0;
  }
  else
  {
    [(__CFData *)v6 setLength:v9];
    id v7 = v6;
  }

  return v7;
}

uint64_t SecKyberPublicKeyCopyPublicOctets(uint64_t a1, __CFData **a2)
{
  CFAllocatorRef v3 = SecKyberPublicKeyCopyData(*(void *)(a1 + 24), 0);
  *a2 = v3;
  if (v3) {
    return 0;
  }
  else {
    return 4294941021;
  }
}

uint64_t SecKyberKeyGetAlgorithmID()
{
  return 8;
}

uint64_t SecKyberPublicKeyCopyKeyDescription(uint64_t a1)
{
  uint64_t v2 = cckem_pubkey_nbytes_ctx();
  CFAllocatorRef v3 = [MEMORY[0x1E4F28E78] stringWithCapacity:2 * v2];
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFAllocatorRef v4 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex v5 = cckem_pubkey_nbytes_ctx();
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v4, 0);
  CFDataSetLength(Mutable, v5);
  uint64_t v15 = [(__CFData *)Mutable length];
  id v7 = Mutable;
  [(__CFData *)v7 mutableBytes];
  if (!cckem_export_pubkey())
  {
    [(__CFData *)v7 setLength:v15];
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        objc_msgSend(v3, "appendFormat:", @"%02X", *(unsigned __int8 *)(-[__CFData bytes](v7, "bytes") + i));
    }
  }
  uint64_t v9 = cckem_pubkey_nbytes_ctx();
  cckem_kyber768();
  if (v9 == cckem_pubkey_nbytes_info())
  {
    uint64_t v10 = @"Kyber-768-pubKey";
  }
  else
  {
    uint64_t v11 = cckem_pubkey_nbytes_ctx();
    cckem_kyber1024();
    uint64_t v12 = cckem_pubkey_nbytes_info();
    uint64_t v10 = @"Kyber";
    if (v11 == v12) {
      uint64_t v10 = @"Kyber-1024-pubKey";
    }
  }
  uint64_t v13 = [NSString stringWithFormat:@"<SecKeyRef %@ algorithm id: %lu, key type: %s, version: %d, bytes: %@, addr: %p>", v10, 8, *(void *)(*(void *)(a1 + 16) + 8), **(unsigned int **)(a1 + 16), v3, a1];

  return v13;
}

uint64_t SecKyberPublicKeyCopyAttributeDictionary(uint64_t a1)
{
  v32[23] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v2 = cckem_pubkey_nbytes_ctx();
  cckem_kyber768();
  if (v2 == cckem_pubkey_nbytes_info())
  {
    CFAllocatorRef v3 = @"768";
LABEL_5:
    CFIndex v5 = v3;
    goto LABEL_9;
  }
  uint64_t v4 = cckem_pubkey_nbytes_ctx();
  cckem_kyber1024();
  if (v4 == cckem_pubkey_nbytes_info())
  {
    CFAllocatorRef v3 = @"1024";
    goto LABEL_5;
  }
  unint64_t v6 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "unknown Kyber type detected", buf, 2u);
  }

  CFAllocatorRef v3 = (__CFString *)&unk_1ED86CC90;
LABEL_9:
  CFDictionaryRef v20 = v3;
  id v7 = SecKyberPublicKeyCopyData(v1, 0);
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v25 = v7;
  unint64_t v29 = SecSHA1DigestCreate(v8, [(__CFData *)v25 bytes], [(__CFData *)v25 length]);
  v31[0] = @"class";
  v31[1] = @"type";
  v32[0] = @"keys";
  v32[1] = @"109";
  v31[2] = @"bsiz";
  v31[3] = @"esiz";
  v32[2] = v3;
  v32[3] = v3;
  unint64_t v31[4] = @"kcls";
  void v31[5] = @"klbl";
  v32[4] = @"0";
  v32[5] = v29;
  v31[6] = @"perm";
  CFIndex v28 = [NSNumber numberWithBool:1];
  v32[6] = v28;
  v31[7] = @"priv";
  CFNumberRef v27 = [NSNumber numberWithBool:1];
  v32[7] = v27;
  v31[8] = @"modi";
  CFNumberRef v26 = [NSNumber numberWithBool:1];
  v32[8] = v26;
  v31[9] = @"sens";
  CFMutableDictionaryRef v24 = [NSNumber numberWithBool:0];
  v32[9] = v24;
  v31[10] = @"asen";
  uint64_t v23 = [NSNumber numberWithBool:0];
  v32[10] = v23;
  v31[11] = @"extr";
  uint64_t v22 = [NSNumber numberWithBool:1];
  v32[11] = v22;
  v31[12] = @"next";
  uint64_t v21 = [NSNumber numberWithBool:0];
  v32[12] = v21;
  v31[13] = @"encr";
  uint64_t v9 = [NSNumber numberWithBool:0];
  v32[13] = v9;
  v31[14] = @"decr";
  uint64_t v10 = [NSNumber numberWithBool:0];
  v32[14] = v10;
  v31[15] = @"drve";
  uint64_t v11 = [NSNumber numberWithBool:0];
  v32[15] = v11;
  v31[16] = @"sign";
  uint64_t v12 = [NSNumber numberWithBool:0];
  v32[16] = v12;
  v31[17] = @"vrfy";
  uint64_t v13 = [NSNumber numberWithBool:0];
  v32[17] = v13;
  v31[18] = @"snrc";
  CFAllocatorRef v14 = [NSNumber numberWithBool:0];
  v32[18] = v14;
  v31[19] = @"vyrc";
  uint64_t v15 = [NSNumber numberWithBool:0];
  v32[19] = v15;
  v31[20] = @"wrap";
  CFNumberRef v16 = [NSNumber numberWithBool:0];
  v32[20] = v16;
  v31[21] = @"unwp";
  CFAllocatorRef v17 = [NSNumber numberWithBool:0];
  v31[22] = @"v_Data";
  v32[21] = v17;
  v32[22] = v25;
  uint64_t v19 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v32 forKeys:v31 count:23];

  return v19;
}

uint64_t SecKyberPublicKeyBlockSize()
{
  return cckem_pubkey_nbytes_ctx();
}

void SecKyberPublicKeyDestroy(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1)
  {
    cckem_sizeof_pub_ctx();
    free(v1);
  }
}

uint64_t SecKyberPublicKeyInit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    uint64_t result = 0;
    *(void *)(a1 + 24) = a2;
    return result;
  }
  cckem_kyber768();
  if (cckem_pubkey_nbytes_info() == a3)
  {
    cckem_kyber768();
    goto LABEL_7;
  }
  cckem_kyber1024();
  if (cckem_pubkey_nbytes_info() == a3)
  {
    cckem_kyber1024();
LABEL_7:
    size_t v6 = cckem_sizeof_pub_ctx();
    *(void *)(a1 + 24) = malloc_type_calloc(1uLL, v6, 0x87E28B40uLL);
    uint64_t result = cckem_import_pubkey();
    if (!result) {
      return result;
    }
    int v7 = result;
    CFAllocatorRef v8 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 67109376;
      int v13 = a3;
      __int16 v14 = 1024;
      int v15 = v7;
      uint64_t v9 = "Kyber pubkey size=%dbytes import failed: %d";
      uint64_t v10 = v8;
      uint32_t v11 = 14;
LABEL_12:
      _os_log_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v12, v11);
      goto LABEL_13;
    }
    goto LABEL_13;
  }
  CFAllocatorRef v8 = secLogObjForScope("SecWarning");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 67109120;
    int v13 = a3;
    uint64_t v9 = "Kyber pubkey size=%dbytes is invalid";
    uint64_t v10 = v8;
    uint32_t v11 = 8;
    goto LABEL_12;
  }
LABEL_13:

  return 4294967246;
}

__CFData *SecKyberPrivateKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, __CFString **a8)
{
  if (a2 != 6 || !CFEqual(cf1, @"algid:kem:kyber"))
  {
    uint64_t v12 = MEMORY[0x1E4F1D260];
    return *(__CFData **)v12;
  }
  if (a5)
  {
    uint64_t v12 = MEMORY[0x1E4F1CFD0];
    return *(__CFData **)v12;
  }
  id v15 = a6;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    && (uint64_t v16 = [v15 length], v16 == cckem_encapsulated_key_nbytes_info()))
  {
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
    }
    CFAllocatorRef v17 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
    CFIndex v18 = cckem_shared_key_nbytes_info();
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(v17, 0);
    CFDataSetLength(Mutable, v18);
    [v15 length];
    [v15 bytes];
    [(__CFData *)Mutable length];
    int v13 = Mutable;
    [(__CFData *)v13 mutableBytes];
    uint64_t v20 = cckem_decapsulate();
    if (v20) {
      SecError(-26275, a8, @"Key decapsulation failed, err=%d for key %@", v20, a1);
    }
  }
  else
  {
    uint64_t v21 = cckem_encapsulated_key_nbytes_info();
    SecError(-50, a8, @"Kyber decapsulation failed: expecting input data of size %dbytes", v21);
    int v13 = 0;
  }

  return v13;
}

__CFData *SecKyberPrivateKeyCopyExternalRepresentation(uint64_t a1, __CFString **a2)
{
  cckem_public_ctx();
  uint64_t v4 = cckem_pubkey_nbytes_ctx();
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFAllocatorRef v5 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex v6 = cckem_privkey_nbytes_ctx() + v4;
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v5, 0);
  CFDataSetLength(Mutable, v6);
  uint64_t v13 = [(__CFData *)Mutable length];
  cckem_public_ctx();
  CFAllocatorRef v8 = Mutable;
  [(__CFData *)v8 mutableBytes];
  if (cckem_export_pubkey())
  {
    SecError(-26275, a2, @"Failed to export public part of %@", a1);
  }
  else
  {
    uint64_t v12 = [(__CFData *)v8 length] - v13;
    uint64_t v9 = v8;
    [(__CFData *)v9 mutableBytes];
    if (!cckem_export_privkey())
    {
      [(__CFData *)v9 setLength:v12 + v13];
      uint64_t v10 = v9;
      goto LABEL_8;
    }
    SecError(-26275, a2, @"Failed to export %@", a1);
  }
  uint64_t v10 = 0;
LABEL_8:

  return v10;
}

uint64_t SecKyberPrivateKeyCopyPublicOctets(uint64_t a1, __CFData **a2)
{
  uint64_t v3 = cckem_public_ctx();
  uint64_t v4 = SecKyberPublicKeyCopyData(v3, 0);
  *a2 = v4;
  if (v4) {
    return 0;
  }
  else {
    return 4294941021;
  }
}

uint64_t SecKyberPrivateKeyCopyKeyDescription(uint64_t a1)
{
  uint64_t v2 = cckem_privkey_nbytes_ctx();
  cckem_kyber768();
  if (v2 == cckem_privkey_nbytes_info())
  {
    uint64_t v3 = @"Kyber-768-privKey";
  }
  else
  {
    uint64_t v4 = cckem_privkey_nbytes_ctx();
    cckem_kyber1024();
    uint64_t v5 = cckem_privkey_nbytes_info();
    uint64_t v3 = @"Kyber";
    if (v4 == v5) {
      uint64_t v3 = @"Kyber-1024-privKey";
    }
  }
  [NSString stringWithFormat:@"<SecKeyRef %@ algorithm id: %lu, key type: %s, version: %d, addr: %p>", v3, 8, *(void *)(*(void *)(a1 + 16) + 8), **(unsigned int **)(a1 + 16), a1];
  return objc_claimAutoreleasedReturnValue();
}

uint64_t SecKyberPrivateKeyCopyAttributeDictionary(uint64_t a1)
{
  v38[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = cckem_privkey_nbytes_ctx();
  cckem_kyber768();
  if (v2 == cckem_privkey_nbytes_info())
  {
    uint64_t v3 = @"768";
LABEL_5:
    uint64_t v5 = v3;
    goto LABEL_9;
  }
  uint64_t v4 = cckem_privkey_nbytes_ctx();
  cckem_kyber1024();
  if (v4 == cckem_privkey_nbytes_info())
  {
    uint64_t v3 = @"1024";
    goto LABEL_5;
  }
  CFIndex v6 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "unknown Kyber type detected", buf, 2u);
  }

  uint64_t v3 = (__CFString *)&unk_1ED86CC90;
LABEL_9:
  uint64_t v7 = cckem_public_ctx();
  CFAllocatorRef v8 = SecKyberPublicKeyCopyData(v7, 0);
  if (v8)
  {
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v10 = v8;
    uint32_t v11 = SecSHA1DigestCreate(v9, [(__CFData *)v10 bytes], [(__CFData *)v10 length]);
  }
  else
  {
    uint32_t v11 = 0;
  }
  v37[0] = @"class";
  v37[1] = @"type";
  v38[0] = @"keys";
  v38[1] = @"109";
  v37[2] = @"bsiz";
  v37[3] = @"esiz";
  v38[3] = v3;
  v38[4] = @"1";
  v37[4] = @"kcls";
  v37[5] = @"klbl";
  uint64_t v12 = (uint64_t)v11;
  v38[2] = v3;
  uint64_t v34 = v11;
  CFDictionaryRef v35 = v3;
  if (!v11)
  {
    uint64_t v12 = [MEMORY[0x1E4F1C9B8] data];
  }
  v38[5] = v12;
  v37[6] = @"perm";
  uint64_t v33 = objc_msgSend(NSNumber, "numberWithBool:", 1, v12);
  v38[6] = v33;
  v37[7] = @"priv";
  CFTypeID v32 = [NSNumber numberWithBool:1];
  v38[7] = v32;
  v37[8] = @"modi";
  char v31 = [NSNumber numberWithBool:1];
  v38[8] = v31;
  v37[9] = @"sens";
  uint64_t v30 = [NSNumber numberWithBool:0];
  v38[9] = v30;
  v37[10] = @"asen";
  unint64_t v29 = [NSNumber numberWithBool:0];
  v38[10] = v29;
  v37[11] = @"extr";
  CFIndex v28 = [NSNumber numberWithBool:1];
  v38[11] = v28;
  v37[12] = @"next";
  CFNumberRef v27 = [NSNumber numberWithBool:0];
  v38[12] = v27;
  v37[13] = @"encr";
  CFNumberRef v26 = [NSNumber numberWithBool:0];
  v38[13] = v26;
  v37[14] = @"decr";
  uint64_t v25 = [NSNumber numberWithBool:0];
  v38[14] = v25;
  v37[15] = @"drve";
  uint64_t v13 = [NSNumber numberWithBool:0];
  v38[15] = v13;
  v37[16] = @"sign";
  __int16 v14 = [NSNumber numberWithBool:0];
  v38[16] = v14;
  v37[17] = @"vrfy";
  id v15 = [NSNumber numberWithBool:0];
  v38[17] = v15;
  v37[18] = @"snrc";
  uint64_t v16 = [NSNumber numberWithBool:0];
  v38[18] = v16;
  v37[19] = @"vyrc";
  CFAllocatorRef v17 = [NSNumber numberWithBool:0];
  v38[19] = v17;
  v37[20] = @"wrap";
  CFIndex v18 = [NSNumber numberWithBool:0];
  v38[20] = v18;
  v37[21] = @"unwp";
  uint64_t v19 = [NSNumber numberWithBool:0];
  v38[21] = v19;
  v37[22] = @"v_Data";
  uint64_t v20 = SecKyberPrivateKeyCopyExternalRepresentation(a1, 0);
  uint64_t v21 = v20;
  if (!v20)
  {
    uint64_t v21 = [MEMORY[0x1E4F1CA58] data];
  }
  v38[22] = v21;
  uint64_t v22 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v38 forKeys:v37 count:23];
  if (!v20) {

  }
  if (!v34) {
  return v22;
  }
}

uint64_t SecKyberPrivateKeyBlockSize()
{
  return cckem_privkey_nbytes_ctx();
}

void SecKyberPrivateKeyDestroy(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1)
  {
    cckem_sizeof_full_ctx();
    free(v1);
  }
}

uint64_t SecKyberPrivateKeyInit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    uint64_t result = 0;
    *(void *)(a1 + 24) = a2;
    return result;
  }
  cckem_kyber768();
  uint64_t v5 = cckem_pubkey_nbytes_info();
  cckem_kyber768();
  if (cckem_privkey_nbytes_info() + v5 == a3)
  {
    cckem_kyber768();
  }
  else
  {
    cckem_kyber1024();
    uint64_t v7 = cckem_pubkey_nbytes_info();
    cckem_kyber1024();
    if (cckem_privkey_nbytes_info() + v7 != a3)
    {
      uint32_t v11 = secLogObjForScope("SecWarning");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = 67109120;
        int v17 = a3;
        uint64_t v12 = "Kyber pubkey size=%dbytes is invalid";
        __int16 v14 = v11;
        uint32_t v15 = 8;
        goto LABEL_16;
      }
      goto LABEL_17;
    }
    cckem_kyber1024();
  }
  size_t v8 = cckem_sizeof_full_ctx();
  *(void *)(a1 + 24) = malloc_type_calloc(1uLL, v8, 0xC4AA431AuLL);
  cckem_pubkey_nbytes_info();
  int v9 = cckem_import_privkey();
  if (v9)
  {
    int v10 = v9;
    uint32_t v11 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 67109376;
      int v17 = a3;
      __int16 v18 = 1024;
      int v19 = v10;
      uint64_t v12 = "Kyber privkey size=%dbytes import or priv part failed: %d";
LABEL_13:
      __int16 v14 = v11;
      uint32_t v15 = 14;
LABEL_16:
      _os_log_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v16, v15);
    }
  }
  else
  {
    cckem_public_ctx();
    uint64_t result = cckem_import_pubkey();
    if (!result) {
      return result;
    }
    int v13 = result;
    uint32_t v11 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 67109376;
      int v17 = a3;
      __int16 v18 = 1024;
      int v19 = v13;
      uint64_t v12 = "Kyber privkey size=%dbytes import of pub part failed: %d";
      goto LABEL_13;
    }
  }
LABEL_17:

  return 4294967246;
}

uint64_t SecKyberKeyGeneratePair(void *a1, void *a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  cckem_kyber768();
  CFIndex v6 = [a1 objectForKeyedSubscript:@"bsiz"];
  uint64_t v7 = v6;
  if (!v6)
  {
LABEL_6:
    size_t v10 = cckem_sizeof_full_ctx();
    uint32_t v11 = malloc_type_calloc(1uLL, v10, 0xBEFB4CFFuLL);
    cckem_full_ctx_init();
    ccrng();
    int key = cckem_generate_key();
    if (key)
    {
      int v13 = key;
      free(v11);
      __int16 v14 = secLogObjForScope("SecWarning");
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = 67109120;
        LODWORD(v26) = v13;
        _os_log_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEFAULT, "Failed to generate Kyber key: err %d", (uint8_t *)&v25, 8u);
      }

      uint64_t v15 = 4294941021;
    }
    else
    {
      if (SecCFAllocatorZeroize_sOnce != -1) {
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
      }
      int v16 = SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)&kSecKyberPrivateKeyDescriptor, (uint64_t)v11, 0, 0);
      if (v16)
      {
        size_t v17 = cckem_sizeof_pub_ctx();
        __int16 v18 = malloc_type_calloc(1uLL, v17, 0x31EB0D42uLL);
        int v19 = (const void *)cckem_public_ctx();
        size_t v20 = cckem_sizeof_pub_ctx();
        memcpy(v18, v19, v20);
        if (SecCFAllocatorZeroize_sOnce != -1) {
          dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
        }
        uint64_t v21 = SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)&kSecKyberPublicKeyDescriptor, (uint64_t)v18, 0, 0);
        uint64_t v22 = v21;
        if (v21)
        {
          if (a2) {
            *a2 = v21;
          }
          uint64_t v15 = 0;
          if (a3) {
            *a3 = v16;
          }
        }
        else
        {
          uint64_t v15 = 4294967246;
        }
      }
      else
      {
        uint64_t v15 = 4294967246;
      }
    }
    goto LABEL_27;
  }
  uint64_t v8 = [v6 integerValue];
  if (v8 == [@"768" integerValue])
  {
    cckem_kyber768();
    goto LABEL_6;
  }
  uint64_t v9 = [v7 integerValue];
  if (v9 == [@"1024" integerValue])
  {
    cckem_kyber1024();
    goto LABEL_6;
  }
  uint64_t v23 = secLogObjForScope("SecWarning");
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    int v25 = 138412290;
    CFNumberRef v26 = v7;
    _os_log_impl(&dword_18B299000, v23, OS_LOG_TYPE_DEFAULT, "Invalid kyber type %@ requested for Kyber key generation", (uint8_t *)&v25, 0xCu);
  }

  uint64_t v15 = 4294967246;
LABEL_27:

  return v15;
}

uint64_t __SecIdentityGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef SecIdentityCopyDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<SecIdentityRef: %p>", a1);
}

CFStringRef SecIdentityCopyFormatDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<SecIdentityRef: %p>", a1);
}

CFHashCode SecIdentityHash(uint64_t a1)
{
  CFHashCode v2 = CFHash(*(CFTypeRef *)(a1 + 16));
  return CFHash(*(CFTypeRef *)(a1 + 24)) + v2;
}

uint64_t SecIdentityCompare(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  if (!a2) {
    return 0;
  }
  uint64_t result = CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
  if (result) {
    return CFEqual(*(CFTypeRef *)(a1 + 24), *(CFTypeRef *)(a2 + 24)) != 0;
  }
  return result;
}

OSStatus SecPKCS12Import(CFDataRef pkcs12_data, CFDictionaryRef options, CFArrayRef *items)
{
  SecAsn1CoderRef coder = 0;
  CFTypeRef cf = 0;
  CFDictionaryRef theDict = 0;
  SecAsn1CoderCreate(&coder);
  if (options)
  {
    CFNumberRef Value = CFDictionaryGetValue(options, @"passphrase");
    CFTypeRef cf = Value;
    if (Value) {
      CFRetain(Value);
    }
  }
  if (!cf) {
    CFTypeRef cf = CFStringCreateWithCString(0, (const char *)&unk_18B41CA07, 0x8000100u);
  }
  CFDictionaryRef theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v50 = 0;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v47 = 0u;
  CFIndex Length = CFDataGetLength(pkcs12_data);
  BytePtr = (char *)CFDataGetBytePtr(pkcs12_data);
  int v9 = -50;
  if (coder && BytePtr)
  {
    if (SEC_ASN1Decode(*(void *)coder, (uint64_t)&v47, (uint64_t)&NSS_P12_DecodedPFXTemplate, BytePtr, Length))int v9 = -26275; {
    else
    }
      int v9 = 0;
  }
  int v10 = 1;
  if (v9) {
    goto LABEL_25;
  }
  if (v49 != 1) {
    goto LABEL_25;
  }
  uint32_t v11 = v50;
  if (!v50) {
    goto LABEL_25;
  }
  *(void *)&long long context = v50[1];
  *((void *)&context + 1) = *v50;
  if (DEROidCompare((uint64_t)&oidSha1, (uint64_t)&context))
  {
    CCHmacAlgorithm v12 = 0;
    unsigned int v13 = 20;
LABEL_18:
    CC_LONG v14 = 64;
    goto LABEL_19;
  }
  if (DEROidCompare((uint64_t)&oidSha256, (uint64_t)&context))
  {
    CCHmacAlgorithm v12 = 2;
    unsigned int v13 = 32;
    goto LABEL_18;
  }
  if (DEROidCompare((uint64_t)&oidSha384, (uint64_t)&context))
  {
    CCHmacAlgorithm v12 = 3;
    unsigned int v13 = 48;
  }
  else
  {
    if (!DEROidCompare((uint64_t)&oidSha512, (uint64_t)&context))
    {
      if (!DEROidCompare((uint64_t)&oidSha224, (uint64_t)&context)) {
        goto LABEL_23;
      }
      CCHmacAlgorithm v12 = 5;
      unsigned int v13 = 28;
      goto LABEL_18;
    }
    CCHmacAlgorithm v12 = 4;
    unsigned int v13 = 64;
  }
  CC_LONG v14 = 128;
LABEL_19:
  if (!*((void *)&context + 1))
  {
LABEL_23:
    size_t v17 = 0;
LABEL_24:
    free(v17);
    int v10 = 2;
LABEL_25:
    LODWORD(v51) = v10;
    goto LABEL_59;
  }
  unint64_t v15 = v11[8];
  if (!v15) {
    goto LABEL_31;
  }
  int v16 = (unsigned __int8 *)v11[9];
  if (!v16) {
    goto LABEL_31;
  }
  if (v15 > 4) {
    goto LABEL_23;
  }
  unsigned int v18 = 0;
  do
  {
    int v19 = *v16++;
    unsigned int v18 = v19 | (v18 << 8);
    --v15;
  }
  while (v15);
  if (!v18) {
LABEL_31:
  }
    unsigned int v18 = 1;
  size_t v20 = v13;
  size_t v17 = malloc_type_malloc(v13, 0xAF7DDE70uLL);
  if (p12_pbe_gen((const __CFString *)cf, (const void *)v11[7], v11[6], v18, 3, v17, v20, v14, v20)) {
    goto LABEL_24;
  }
  uint64_t v21 = (void *)0xAAAAAAAAAAAAAAAALL;
  unsigned int v51 = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
  if (coder)
  {
    uint64_t v21 = (void *)PORT_ArenaAlloc(*(void *)coder, v20);
    unint64_t v52 = (unint64_t)v21;
    if (v21) {
      unsigned int v51 = (void *)v20;
    }
  }
  CCHmac(v12, v17, v20, *(const void **)(*((void *)&v49 + 1) + 8), **((void **)&v49 + 1), v21);
  if (!nssCompareSecAsn1Items((BOOL)&v51, (uint64_t)(v11 + 4))) {
    goto LABEL_24;
  }
  free(v17);
  unsigned int v51 = 0;
  if (!coder
    || (uint64_t v22 = *(char **)(*((void *)&v49 + 1) + 8)) == 0
    || SEC_ASN1Decode(*(void *)coder, (uint64_t)&v51, (uint64_t)&NSS_P12_AuthenticatedSafeTemplate, v22, **((void **)&v49 + 1)))
  {
LABEL_80:
    int v10 = 1;
    goto LABEL_25;
  }
  if (v51)
  {
    if (*v51)
    {
      uint64_t v23 = 0;
      while (v51[++v23])
        ;
      if (v23)
      {
        unint64_t v25 = 0;
        uint64_t v26 = 8 * v23;
        while (1)
        {
          uint64_t v27 = v51[v25 / 8];
          int v28 = *(_DWORD *)(v27 + 16);
          if (v28 == 6) {
            break;
          }
          if (v28 == 1)
          {
            unint64_t v29 = *(unint64_t **)(v27 + 24);
            unint64_t v30 = *v29;
            char v31 = (char *)v29[1];
            goto LABEL_51;
          }
LABEL_52:
          v25 += 8;
          if (v26 == v25) {
            goto LABEL_53;
          }
        }
        long long context = 0uLL;
        p12Decrypt((uint64_t)&coder, (void *)(*(void *)(v27 + 24) + 32), *(void *)(v27 + 24) + 64, &context);
        if (v32) {
          goto LABEL_80;
        }
        char v31 = (char *)*((void *)&context + 1);
        unint64_t v30 = context;
LABEL_51:
        if (safeContentsParse((uint64_t **)&coder, v30, v31)) {
          goto LABEL_80;
        }
        goto LABEL_52;
      }
    }
  }
LABEL_53:
  LODWORD(v51) = 0;
  uint64_t v33 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFMutableArrayRef v35 = CFArrayCreateMutable(0, 0, v33);
  *(void *)&long long context = Mutable;
  *((void *)&context + 1) = &v51;
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)collect_certs, &context);
  if (!v51)
  {
    CFArrayRef v36 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    *(void *)&long long v47 = v36;
    *((void *)&v47 + 1) = v35;
    *(void *)&long long v48 = Mutable;
    *((void *)&v48 + 1) = &v51;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)build_trust_chains, &v47);
    *items = v36;
  }
  if (v35) {
    CFRelease(v35);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
LABEL_59:
  if (theDict) {
    CFRelease(theDict);
  }
  if (cf) {
    CFRelease(cf);
  }
  SecAsn1CoderRelease(coder);
  if (v51)
  {
    if (v51 == 2)
    {
      return -25293;
    }
    else if (v51 == 1)
    {
      return -26275;
    }
    else
    {
      return -26276;
    }
  }
  else if (options)
  {
    CFIndex v38 = CFDictionaryGetValue(options, @"nleg");
    OSStatus v37 = 0;
    if (v38 && v38 != (const void *)*MEMORY[0x1E4F1CFC8])
    {
      *(void *)&long long context = 0;
      *((void *)&context + 1) = &context;
      uint64_t v45 = 0x2000000000;
      int v46 = 0;
      CFArrayRef v39 = *items;
      *(void *)&long long v47 = MEMORY[0x1E4F143A8];
      *((void *)&v47 + 1) = 0x40000000;
      *(void *)&long long v48 = __SecPKCS12ImportToModernKeychain_block_invoke;
      *((void *)&v48 + 1) = &unk_1E547F360;
      *(void *)&long long v49 = &context;
      *((void *)&v49 + 1) = options;
      v53.CFIndex length = CFArrayGetCount(v39);
      v53.location = 0;
      CFArrayApplyFunction(v39, v53, (CFArrayApplierFunction)apply_block_1_9857, &v47);
      OSStatus v37 = *(_DWORD *)(*((void *)&context + 1) + 24);
      _Block_object_dispose(&context, 8);
    }
  }
  else
  {
    return 0;
  }
  return v37;
}

uint64_t __SecPKCS12ImportToModernKeychain_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 40);
  CFTypeID v5 = CFGetTypeID(cf);
  uint64_t result = CFDictionaryGetTypeID();
  if (v5 == result)
  {
    if (!CFDictionaryContainsKey((CFDictionaryRef)cf, @"identity"))
    {
      int v11 = 0;
LABEL_17:
      uint64_t result = CFDictionaryContainsKey((CFDictionaryRef)cf, @"chain");
      if (!result)
      {
LABEL_35:
        if (!v11) {
          return result;
        }
        goto LABEL_36;
      }
      uint64_t result = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)cf, @"chain");
      if (result)
      {
        CFArrayRef v15 = (const __CFArray *)result;
        CFTypeID v16 = CFGetTypeID((CFTypeRef)result);
        uint64_t result = CFArrayGetTypeID();
        if (v16 == result)
        {
          unsigned int v17 = 0;
          unsigned int v18 = (const void *)*MEMORY[0x1E4F1CFD0];
          while (1)
          {
            uint64_t result = CFArrayGetCount(v15);
            if (result <= v17) {
              goto LABEL_35;
            }
            unsigned int v19 = v17;
            CFArrayRef ValueAtIndex = CFArrayGetValueAtIndex(v15, v17);
            uint64_t v21 = secItemOptionsFromPKCS12Options(v4);
            CFDictionaryAddValue(v21, @"nleg", v18);
            CFDictionaryAddValue(v21, @"class", @"cert");
            CFDictionaryAddValue(v21, @"v_Ref", ValueAtIndex);
            OSStatus v22 = SecItemAdd(v21, 0);
            if (v22 == -25299) {
              break;
            }
            int v11 = v22;
            if (!v22)
            {
              uint64_t v23 = secLogObjForScope("p12Decode");
              if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_31;
              }
              *(_WORD *)long long buf = 0;
              CFMutableDictionaryRef v24 = v23;
              unint64_t v25 = "cert added to keychain";
LABEL_28:
              _os_log_impl(&dword_18B299000, v24, OS_LOG_TYPE_DEFAULT, v25, buf, 2u);
              int v11 = 0;
              goto LABEL_31;
            }
            uint64_t v27 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109120;
              int v29 = v11;
              _os_log_impl(&dword_18B299000, v27, OS_LOG_TYPE_DEFAULT, "p12Decode: Error %d adding identity to keychain", buf, 8u);
            }
LABEL_31:
            if (v21) {
              CFRelease(v21);
            }
            unsigned int v17 = v19 + 1;
          }
          uint64_t v26 = secLogObjForScope("p12Decode");
          int v11 = 0;
          if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_31;
          }
          *(_WORD *)long long buf = 0;
          CFMutableDictionaryRef v24 = v26;
          unint64_t v25 = "skipping dup cert";
          goto LABEL_28;
        }
      }
LABEL_34:
      int v11 = -26276;
LABEL_36:
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v11;
      return result;
    }
    uint64_t result = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)cf, @"identity");
    if (!result) {
      goto LABEL_34;
    }
    uint64_t v7 = (const void *)result;
    CFTypeID v8 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = SecIdentityGetTypeID();
    if (v8 != result) {
      goto LABEL_34;
    }
    int v9 = secItemOptionsFromPKCS12Options(v4);
    CFDictionaryAddValue(v9, @"nleg", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionaryAddValue(v9, @"class", @"idnt");
    CFDictionaryAddValue(v9, @"v_Ref", v7);
    OSStatus v10 = SecItemAdd(v9, 0);
    if (v10 == -25299)
    {
      CCHmacAlgorithm v12 = secLogObjForScope("p12Decode");
      int v11 = 0;
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
      *(_WORD *)long long buf = 0;
      unsigned int v13 = "skipping dup cert";
    }
    else
    {
      int v11 = v10;
      if (v10)
      {
        CC_LONG v14 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109120;
          int v29 = v11;
          _os_log_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEFAULT, "p12Decode: Error %d adding identity to keychain", buf, 8u);
        }
        goto LABEL_15;
      }
      CCHmacAlgorithm v12 = secLogObjForScope("p12Decode");
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
LABEL_15:
        if (v9) {
          CFRelease(v9);
        }
        goto LABEL_17;
      }
      *(_WORD *)long long buf = 0;
      unsigned int v13 = "cert added to keychain";
    }
    _os_log_impl(&dword_18B299000, v12, OS_LOG_TYPE_DEFAULT, v13, buf, 2u);
    int v11 = 0;
    goto LABEL_15;
  }
  return result;
}

uint64_t apply_block_1_9857(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

__CFDictionary *secItemOptionsFromPKCS12Options(CFDictionaryRef theDict)
{
  CFStringRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  CFDictionaryRemoveValue(MutableCopy, @"passphrase");
  CFDictionaryRemoveValue(MutableCopy, @"memory");
  return MutableCopy;
}

void build_trust_chains(uint64_t a1, const __CFDictionary *a2, uint64_t a3)
{
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  SecTrustRef trust = 0;
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(a2, @"key");
  if (!Value) {
    goto LABEL_34;
  }
  CFDataRef v8 = (const __CFData *)CFDictionaryGetValue(a2, @"cert");
  if (!v8)
  {
    CFArrayRef v15 = 0;
    CFArrayRef v17 = 0;
    SecPolicyRef BasicX509 = 0;
    unsigned int v13 = 0;
    CFDataRef Value = 0;
    goto LABEL_17;
  }
  CFDataRef v9 = (const __CFData *)CFDictionaryGetValue(a2, @"algid");
  v19[0] = CFDataGetBytePtr(v9);
  v19[1] = CFDataGetLength(v9);
  if (DEROidCompare((uint64_t)&oidEcPubKey, (uint64_t)v19))
  {
    BytePtr = CFDataGetBytePtr(Value);
    CFIndex Length = CFDataGetLength(Value);
    CCHmacAlgorithm v12 = &kSecECPrivateKeyDescriptor;
  }
  else
  {
    if (!DEROidCompare((uint64_t)&oidRsa, (uint64_t)v19))
    {
      CFArrayRef v15 = 0;
      CFArrayRef v17 = 0;
      SecPolicyRef BasicX509 = 0;
      unsigned int v13 = 0;
      CFDataRef v8 = 0;
      CFDataRef Value = 0;
LABEL_16:
      **(_DWORD **)(a3 + 24) = 1;
      goto LABEL_17;
    }
    BytePtr = CFDataGetBytePtr(Value);
    CFIndex Length = CFDataGetLength(Value);
    CCHmacAlgorithm v12 = &kSecRSAPrivateKeyDescriptor;
  }
  CFDataRef Value = (const __CFData *)SecKeyCreate((uint64_t)v5, (uint64_t)v12, (uint64_t)BytePtr, Length, 1);
  if (!Value)
  {
LABEL_34:
    CFArrayRef v15 = 0;
    CFArrayRef v17 = 0;
    SecPolicyRef BasicX509 = 0;
    unsigned int v13 = 0;
    CFDataRef v8 = 0;
    goto LABEL_17;
  }
  CFDataRef v8 = SecCertificateCreateWithData(v5, v8);
  if (!v8)
  {
    CFArrayRef v15 = 0;
    CFArrayRef v17 = 0;
    SecPolicyRef BasicX509 = 0;
    unsigned int v13 = 0;
    goto LABEL_16;
  }
  unsigned int v13 = (const void *)SecIdentityCreate((int)v5, v8, Value);
  if (!v13)
  {
    CFArrayRef v15 = 0;
    CFArrayRef v17 = 0;
    SecPolicyRef BasicX509 = 0;
    goto LABEL_16;
  }
  CFDictionarySetValue(Mutable, @"identity", v13);
  CC_LONG v14 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFArrayRef v15 = v14;
  if (v14)
  {
    CFArrayAppendValue(v14, v8);
    v21.CFIndex length = CFArrayGetCount(*(CFArrayRef *)(a3 + 16));
    v21.location = 0;
    CFArrayAppendArray(v15, *(CFArrayRef *)(a3 + 16), v21);
    SecPolicyRef BasicX509 = SecPolicyCreateBasicX509();
    if (BasicX509 && (int v18 = -1431655766, SecTrustCreateWithCertificates(v15, BasicX509, &trust), trust))
    {
      SecTrustEvaluateInternal(trust, &v18);
      CFDictionarySetValue(Mutable, @"trust", trust);
      CFArrayRef v17 = SecTrustCopyCertificateChain(trust);
      if (v17)
      {
        CFDictionarySetValue(Mutable, @"chain", v17);
        CFArrayAppendValue(*(CFMutableArrayRef *)a3, Mutable);
      }
    }
    else
    {
      CFArrayRef v17 = 0;
    }
  }
  else
  {
    CFArrayRef v17 = 0;
    SecPolicyRef BasicX509 = 0;
  }
LABEL_17:
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (Value) {
    CFRelease(Value);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (BasicX509) {
    CFRelease(BasicX509);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (trust) {
    CFRelease(trust);
  }
}

void collect_certs(int a1, CFDictionaryRef theDict, uint64_t a3)
{
  if (!CFDictionaryContainsKey(theDict, @"key"))
  {
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(theDict, @"cert");
    if (Value)
    {
      SecCertificateRef v6 = SecCertificateCreateWithData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Value);
      if (v6)
      {
        SecCertificateRef v7 = v6;
        CFArrayAppendValue(*(CFMutableArrayRef *)a3, v6);
        CFRelease(v7);
      }
      else
      {
        **(_DWORD **)(a3 + 8) = 1;
      }
    }
  }
}

uint64_t osstatus_for_kern_return(uint64_t a1)
{
  char v1 = a1 + 63;
  if ((unint64_t)(a1 + 536870207) > 0x21) {
    goto LABEL_8;
  }
  if (((1 << v1) & 0x20000000DLL) != 0) {
    return 4294941988;
  }
  if (((1 << v1) & 0x6000) != 0) {
    return 4294942003;
  }
  if (a1 == -536870206) {
    return 4294967246;
  }
LABEL_8:
  if (a1) {
    unsigned int v3 = -25291;
  }
  else {
    unsigned int v3 = 0;
  }
  if (a1 == -536870212) {
    return 4294941021;
  }
  else {
    return v3;
  }
}

const void *SecCopyLastError(int a1)
{
  if (getLastErrorKey_onceToken != -1) {
    dispatch_once(&getLastErrorKey_onceToken, &__block_literal_global_98);
  }
  if (getLastErrorKey_haveKey != 1) {
    return 0;
  }
  CFHashCode v2 = pthread_getspecific(getLastErrorKey_key);
  unsigned int v3 = v2;
  if (v2)
  {
    if (!a1 || SecErrorGetOSStatus((uint64_t)v2) == a1)
    {
      CFRetain(v3);
      return v3;
    }
    return 0;
  }
  return v3;
}

void lastErrorReleaseError(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

CFDataRef _SecItemCreatePersistentRef(const __CFString *a1, unint64_t a2, CFDictionaryRef theDict)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (theDict && (TokenPersistentRefData = CreateTokenPersistentRefData(a1, theDict)) != 0)
  {
    CFDataRef v6 = TokenPersistentRefData;
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex Length = CFDataGetLength(TokenPersistentRefData);
    CFMutableArrayRef Mutable = CFDataCreateMutable(v7, Length + 4);
    CFDataAppendBytes(Mutable, (const UInt8 *)"tkpr", 4);
    BytePtr = CFDataGetBytePtr(v6);
    CFIndex v11 = CFDataGetLength(v6);
    CFDataAppendBytes(Mutable, BytePtr, v11);
    CFRelease(v6);
  }
  else
  {
    if ((a2 & 0x8000000000000000) != 0) {
      return 0;
    }
    memset(buffer, 170, 12);
    if (!CFStringGetCString(a1, buffer, 5, 0x8000100u))
    {
      return 0;
    }
    else
    {
      *(void *)&buffer[4] = bswap64(a2);
      return CFDataCreate(0, (const UInt8 *)buffer, 12);
    }
  }
  return Mutable;
}

CFDictionaryRef SecTokenItemValueCopy(const void *a1, CFTypeRef *a2)
{
  CFDictionaryRef theDict = 0;
  if (!a1) {
    goto LABEL_13;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFDataGetTypeID()) {
    goto LABEL_13;
  }
  BytePtr = CFDataGetBytePtr((CFDataRef)a1);
  CFIndex Length = CFDataGetLength((CFDataRef)a1);
  CFAllocatorRef v7 = &BytePtr[Length];
  uint64_t v11 = der_decode_plist(0, (uint64_t)&theDict, a2, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length], v8, v9, v10);
  if (!v11)
  {
LABEL_14:
    CFDictionaryRef v12 = 0;
    goto LABEL_15;
  }
  if ((const UInt8 *)v11 != v7)
  {
    SecError(-26275, (__CFString **)a2, @"trailing garbage at end of token data field");
    goto LABEL_14;
  }
  CFDictionaryRef v12 = theDict;
  CFDataRef Value = CFDictionaryGetValue(theDict, @"oid");
  if (!Value || (CFTypeID v14 = CFGetTypeID(Value), v14 != CFDataGetTypeID()))
  {
    SecError(-26276, (__CFString **)a2, @"token based item data does not have OID");
    goto LABEL_14;
  }
  if ((v15 = CFDictionaryGetValue(v12, @"ac")) != 0 && (CFTypeID v16 = CFGetTypeID(v15), v16 != CFDataGetTypeID())
    || (CFArrayRef v17 = CFDictionaryGetValue(v12, @"data")) != 0 && (v18 = CFGetTypeID(v17), v18 != CFDataGetTypeID()))
  {
LABEL_13:
    SecError(-50, (__CFString **)a2, @"Unexpected type");
    goto LABEL_14;
  }
  if (!v12) {
    return v12;
  }
  CFRetain(v12);
LABEL_15:
  if (theDict) {
    CFRelease(theDict);
  }
  return v12;
}

BOOL _SecItemParsePersistentRef(const void *a1, void *a2, void *a3, const void **a4, CFDictionaryRef *a5)
{
  CFTypeID v10 = CFGetTypeID(a1);
  if (v10 != CFDataGetTypeID()) {
    return 0;
  }
  if (CFDataGetLength((CFDataRef)a1) < 5 || *(_DWORD *)CFDataGetBytePtr((CFDataRef)a1) != 1919970164)
  {
    if (CFDataGetLength((CFDataRef)a1) == 12)
    {
      BytePtr = CFDataGetBytePtr((CFDataRef)a1);
      unint64_t v12 = *(void *)(BytePtr + 4);
      CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFIndex Length = CFStringGetLength(@"genp");
      CFStringRef v15 = CFStringCreateWithBytes(v13, BytePtr, Length, 0x8000100u, 1u);
      if (v15)
      {
        CFArrayRef v16 = (const __CFArray *)v15;
        BOOL valid = isValidClass(v15, a2);
        BOOL v18 = valid;
        if (a3 && valid) {
          *a3 = bswap64(v12);
        }
        goto LABEL_31;
      }
    }
    else if (SecKeychainIsStaticPersistentRefsEnabled() && CFDataGetLength((CFDataRef)a1) == 20)
    {
      unsigned int v19 = CFDataGetBytePtr((CFDataRef)a1);
      CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFIndex v21 = CFStringGetLength(@"genp");
      CFStringRef v22 = CFStringCreateWithBytes(v20, v19, v21, 0x8000100u, 1u);
      if (v22)
      {
        CFStringRef v23 = v22;
        BOOL v24 = isValidClass(v22, a2);
        BOOL v18 = v24;
        if (a4 && v24)
        {
          CFIndex v25 = CFStringGetLength(v23);
          CFIndex v26 = CFDataGetLength((CFDataRef)a1);
          CFIndex v27 = CFStringGetLength(v23);
          CFDataRef v28 = CFDataCreateWithBytesNoCopy(v20, &v19[v25], v26 - v27, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
          int v29 = *a4;
          if (*a4 != v28)
          {
            if (!v28 || (CFRetain(v28), (int v29 = *a4) != 0)) {
              CFRelease(v29);
            }
            *a4 = v28;
          }
          if (v28) {
            CFRelease(v28);
          }
        }
        uint64_t v30 = v23;
        goto LABEL_32;
      }
    }
    return 0;
  }
  CFTypeRef cf = 0;
  char v31 = CFDataGetBytePtr((CFDataRef)a1);
  uint64_t v32 = (uint64_t)&v31[CFDataGetLength((CFDataRef)a1)];
  uint64_t v36 = der_decode_plist(0, (uint64_t)&cf, 0, (uint64_t)(v31 + 4), v32, v33, v34, v35);
  BOOL v18 = 0;
  CFArrayRef v16 = (const __CFArray *)cf;
  if (v36 && v36 == v32)
  {
    CFTypeID v37 = CFGetTypeID(cf);
    if (v37 != CFArrayGetTypeID() || CFArrayGetCount(v16) != 3)
    {
      BOOL v18 = 0;
      if (!v16) {
        return v18;
      }
      goto LABEL_31;
    }
    CFArrayRef ValueAtIndex = CFArrayGetValueAtIndex(v16, 0);
    BOOL v39 = isValidClass(ValueAtIndex, a2);
    BOOL v18 = v39;
    if (a5 && v39)
    {
      CFAllocatorRef v40 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      BOOL v18 = 1;
      CFTypeID v41 = CFArrayGetValueAtIndex(v16, 1);
      CFArrayGetValueAtIndex(v16, 2);
      *a5 = CFDictionaryCreateForCFTypes(v40, v42, v43, v44, v45, v46, v47, v48, @"tkid", (uint64_t)v41);
    }
  }
  if (v16)
  {
LABEL_31:
    uint64_t v30 = v16;
LABEL_32:
    CFRelease(v30);
  }
  return v18;
}

BOOL isValidClass(CFTypeRef cf2, void *a2)
{
  unint64_t v4 = 0;
  v8[6] = *MEMORY[0x1E4F143B8];
  v8[0] = @"genp";
  v8[1] = @"inet";
  unint64_t v8[2] = @"apls";
  unint64_t v8[3] = @"cert";
  v8[4] = @"keys";
  void v8[5] = @"idnt";
  BOOL v5 = 1;
  while (1)
  {
    if (cf2)
    {
      uint64_t v6 = v8[v4];
      if (v6)
      {
        if (CFEqual((CFTypeRef)v8[v4], cf2)) {
          break;
        }
      }
    }
    BOOL v5 = v4++ < 5;
    if (v4 == 6) {
      return 0;
    }
  }
  if (a2) {
    *a2 = v6;
  }
  return v5;
}

uint64_t apply_block_2_9961(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t __Block_byref_object_copy__9966(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__9967(uint64_t a1)
{
}

void SecItemAuthMaxAttemptsReached(const __CFArray *a1, __CFString **a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    for (CFIndex i = 0; i != v6; ++i)
    {
      CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(a1, i);
      CFDataRef v9 = (const __CFData *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
      CFIndex Length = CFDataGetLength(v9);
      uint64_t v11 = CFStringCreateMutable(v3, 2 * Length);
      BytePtr = CFDataGetBytePtr(v9);
      CFIndex v13 = CFDataGetLength(v9);
      if (v13 >= 1)
      {
        CFIndex v14 = v13;
        do
        {
          unsigned int v15 = *BytePtr++;
          CFStringAppendFormat(v11, 0, @"%02X", v15);
          --v14;
        }
        while (v14);
      }
      CFArrayRef v16 = CFArrayGetValueAtIndex(ValueAtIndex, 1);
      CFStringRef v17 = CFStringCreateWithFormat(v3, 0, @"operation: %@ acl:%@\n", v16, v11);
      CFStringAppend(Mutable, v17);
      CFRelease(v11);
      CFRelease(v17);
    }
  }
  BOOL v18 = (__CFString *)CFStringCreateWithFormat(v3, 0, @"Reached maximum count of authentication attempts\n %@", Mutable);
  SecError(-25293, a2, @"%@", v18);
  __security_simulatecrash(v18, 0x53C00006u);
  CFRelease(v18);

  CFRelease(Mutable);
}

id SecTokenSessionCreate(__CFString *theString, CFDictionaryRef *a2, __CFString **a3)
{
  unint64_t v4 = a2;
  v33[1] = *MEMORY[0x1E4F143B8];
  if (*a2 && CFDictionaryGetValue(*a2, @"u_CredRef") || CFStringHasPrefix(theString, @"com.apple.setoken")) {
    goto LABEL_9;
  }
  if (SecTokenSessionCreate_onceToken != -1) {
    goto LABEL_40;
  }
  while (1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&SecTokenSessionCreate_lock);
    CFDataRef Value = (void *)CFDictionaryGetValue((CFDictionaryRef)SecTokenSessionCreate_sharedLAContexts, theString);
    if (Value) {
      goto LABEL_6;
    }
    if (!LocalAuthenticationLibraryCore())
    {
      SecError(-26276, a3, @"LocalAuthentication is not available");
      goto LABEL_38;
    }
    id v22 = objc_alloc_init((Class)getLAContextClass());
    if (!v22)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&SecTokenSessionCreate_lock);
      SecError(-26276, a3, @"Failed to create authentication context");
      goto LABEL_38;
    }
    CFStringRef v23 = v22;
    CFDictionarySetValue((CFMutableDictionaryRef)SecTokenSessionCreate_sharedLAContexts, theString, v22);
    CFRelease(v23);
    CFDataRef Value = (void *)CFDictionaryGetValue((CFDictionaryRef)SecTokenSessionCreate_sharedLAContexts, theString);
    if (Value)
    {
LABEL_6:
      CFAllocatorRef v7 = [Value externalizedContext];
      if (v7)
      {
        uint64_t v8 = SecCFDictionaryCOWGetMutable(v4);
        CFDictionarySetValue(v8, @"u_AuthCtx", Value);
        CFDataRef v9 = SecCFDictionaryCOWGetMutable(v4);
        CFDictionarySetValue(v9, @"u_CredRef", v7);
        CFRelease(v7);
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&SecTokenSessionCreate_lock);
LABEL_9:
    CFTypeID v10 = [(__CFDictionary *)*v4 objectForKey:@"u_AuthCtx"];
    if (!v10)
    {
      uint64_t v11 = [(__CFDictionary *)*v4 objectForKey:@"u_CredRef"];
      if (v11)
      {
        if (!LocalAuthenticationLibraryCore())
        {
          SecError(-26276, a3, @"LocalAuthentication is not available");

LABEL_38:
          unsigned int v19 = 0;
          goto LABEL_28;
        }
        CFTypeID v10 = (void *)[objc_alloc((Class)getLAContextClass()) initWithExternalizedContext:v11];
      }
      else
      {
        CFTypeID v10 = 0;
      }
    }
    if (!CryptoTokenKitLibraryCore())
    {
      CFStringRef v17 = (void *)MEMORY[0x1E4F28C58];
      uint64_t v30 = *MEMORY[0x1E4F28228];
      char v31 = @"CryptoTokenKit is not available";
      CFArrayRef v16 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v31 forKeys:&v30 count:1];
      id v18 = [v17 errorWithDomain:*MEMORY[0x1E4F28760] code:-4 userInfo:v16];
      unsigned int v19 = 0;
      goto LABEL_24;
    }
    if (!SecCTKIsQueryForSystemKeychain(*v4)) {
      break;
    }
    uint64_t v26 = 0;
    CFIndex v27 = &v26;
    uint64_t v28 = 0x2020000000;
    unint64_t v4 = (const __CFDictionary **)&SecTrustCopyErrorStrings_policyChecks;
    unint64_t v12 = (id *)getTKClientTokenParameterForceSystemSessionSymbolLoc_ptr_9997;
    uint64_t v29 = getTKClientTokenParameterForceSystemSessionSymbolLoc_ptr_9997;
    if (!getTKClientTokenParameterForceSystemSessionSymbolLoc_ptr_9997)
    {
      v24[1] = (id)MEMORY[0x1E4F143A8];
      v24[2] = (id)3221225472;
      v24[3] = __getTKClientTokenParameterForceSystemSessionSymbolLoc_block_invoke_9998;
      uint8_t v24[4] = &unk_1E5484FA0;
      CFIndex v25 = &v26;
      CFIndex v13 = CryptoTokenKitLibrary();
      unint64_t v27[3] = (uint64_t)dlsym(v13, "TKClientTokenParameterForceSystemSession");
      getTKClientTokenParameterForceSystemSessionSymbolLoc_ptr_9997 = *(void *)(v25[1] + 24);
      unint64_t v12 = (id *)v27[3];
    }
    _Block_object_dispose(&v26, 8);
    if (v12)
    {
      id v32 = *v12;
      v33[0] = MEMORY[0x1E4F1CC38];
      CFIndex v14 = (void *)MEMORY[0x1E4F1C9E8];
      id v15 = v32;
      CFArrayRef v16 = [v14 dictionaryWithObjects:v33 forKeys:&v32 count:1];

      goto LABEL_23;
    }
    a3 = [MEMORY[0x1E4F28B00] currentHandler];
    theString = [NSString stringWithUTF8String:"NSString *getTKClientTokenParameterForceSystemSession(void)"];
    objc_msgSend(a3, "handleFailureInFunction:file:lineNumber:description:", theString, @"SecSoftLink.h", 41, @"%s", dlerror());

    __break(1u);
LABEL_40:
    dispatch_once(&SecTokenSessionCreate_onceToken, &__block_literal_global_169);
  }
  CFArrayRef v16 = (void *)MEMORY[0x1E4F1CC08];
LABEL_23:
  CFAllocatorRef v20 = (void *)[objc_alloc((Class)getTKClientTokenClass()) initWithTokenID:theString];
  v24[0] = 0;
  unsigned int v19 = (void *)[objc_alloc((Class)getTKClientTokenSessionClass()) initWithToken:v20 LAContext:v10 parameters:v16 error:v24];
  id v18 = v24[0];

LABEL_24:
  if (a3 && !v19) {
    *a3 = (__CFString *)v18;
  }

LABEL_28:

  return v19;
}

void sub_18B390F48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *__getTKClientTokenParameterForceSystemSessionSymbolLoc_block_invoke_9998(uint64_t a1)
{
  CFHashCode v2 = CryptoTokenKitLibrary();
  uint64_t result = dlsym(v2, "TKClientTokenParameterForceSystemSession");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getTKClientTokenParameterForceSystemSessionSymbolLoc_ptr_9997 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                            + 24);
  return result;
}

CFMutableDictionaryRef __SecTokenSessionCreate_block_invoke()
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  SecTokenSessionCreate_sharedLAContexts = (uint64_t)result;
  return result;
}

CFDictionaryRef SecItemCopyAttributeDictionary(void *a1, int a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == SecKeyGetTypeID())
  {
    CFDictionaryRef v5 = SecKeyCopyAttributes((SecKeyRef)a1);
    CFDictionaryRef v6 = v5;
    if (v5 && a2)
    {
      CFStringRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v5);
      uint64_t v8 = MutableCopy;
      if (MutableCopy)
      {
        CFDictionaryRemoveValue(MutableCopy, @"sign");
        CFDictionaryRemoveValue(v8, @"vrfy");
        CFDictionaryRemoveValue(v8, @"encr");
        CFDictionaryRemoveValue(v8, @"decr");
        CFDictionaryRemoveValue(v8, @"drve");
        CFDictionaryRemoveValue(v8, @"wrap");
        CFDictionaryRemoveValue(v8, @"unwp");
        CFDictionaryRemoveValue(v8, @"snrc");
        CFDictionaryRemoveValue(v8, @"vyrc");
        CFDictionaryRemoveValue(v8, @"perm");
      }
LABEL_23:
      CFRelease(v6);
      return v8;
    }
    return v5;
  }
  if (v4 != SecCertificateGetTypeID())
  {
    if (v4 != SecIdentityGetTypeID()) {
      return 0;
    }
    __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
    CFTypeID v10 = (void *)a1[2];
    CFRetain(v10);
    CFDictionaryRef v6 = (const __CFDictionary *)a1[3];
    CFRetain(v6);
    CFDataRef v11 = SecCertificateCopyData((SecCertificateRef)v10);
    CFDictionaryRef v12 = SecKeyCopyAttributes(v6);
    CFDictionaryRef v13 = v12;
    if (v12 && v11)
    {
      CFIndex v14 = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v12);
      CFDictionarySetValue(v14, @"certdata", v11);
    }
    else
    {
      CFIndex v14 = 0;
      uint64_t v8 = 0;
      if (!v12) {
        goto LABEL_18;
      }
    }
    CFRelease(v13);
    uint64_t v8 = v14;
LABEL_18:
    if (v11) {
      CFRelease(v11);
    }
    if (v10) {
      CFRelease(v10);
    }
    if (!v6) {
      return v8;
    }
    goto LABEL_23;
  }

  return SecCertificateCopyAttributeDictionary((uint64_t)a1);
}

uint64_t SecItemAttributesSpecifySystemKeychain(void *a1)
{
  id v1 = a1;
  CFHashCode v2 = [v1 objectForKeyedSubscript:@"u_SystemKeychainAlways"];
  char v3 = [v2 BOOLValue];

  if (SecIsEduMode_once != -1) {
    dispatch_once(&SecIsEduMode_once, &__block_literal_global_16081);
  }
  if (v3 & 1 | ((SecIsEduMode_result & 1) == 0))
  {
    char v4 = SecIsEduMode_result | v3;
  }
  else
  {
    CFDictionaryRef v5 = [v1 objectForKeyedSubscript:@"u_SystemKeychain"];
    char v4 = [v5 BOOLValue];
  }
  return v4 & 1;
}

void __SecItemAttributesPrepare_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryRef v5 = SecCFDictionaryCOWGetMutable(*(const __CFDictionary ***)(a1 + 32));

  CFDictionaryAddValue(v5, a2, a3);
}

uint64_t SecItemShareWithGroup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v6 = (void *)MEMORY[0x18C12E850]();
  uint64_t v14 = 0;
  id v15 = &v14;
  uint64_t v16 = 0x2020000000;
  uint64_t v17 = 0;
  uint64_t v12 = a1;
  CFTypeRef cf = 0;
  CFAllocatorRef v7 = _os_activity_create(&dword_18B299000, "SecItemShareWithGroup", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = __SecItemShareWithGroup_block_invoke;
  unint64_t v10[3] = &unk_1E547F448;
  v10[4] = &v14;
  void v10[5] = a2;
  SecItemAuthDoQuery(&v12, 0, SecItemShareWithGroup, a3, v10);
  if (cf) {
    CFRelease(cf);
  }
  uint64_t v8 = v15[3];
  os_activity_scope_leave(&state);

  _Block_object_dispose(&v14, 8);
  return v8;
}

void sub_18B39145C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state, uint64_t a16, uint64_t a17, char a18)
{
}

uint64_t __SecItemShareWithGroup_block_invoke(uint64_t a1, void *a2, const __CFDictionary *a3, uint64_t a4, const __CFDictionary *a5, CFTypeRef *a6)
{
  id v10 = a2;
  if ((isModifyingAPIRateWithinLimits() & 1) == 0) {
    __security_simulatecrash(@"BUG IN CLIENT OF SECITEM: too many writes. See https://at.apple.com/secitemratelimit", 0x53C0000Fu);
  }
  if (!v10)
  {
    if (gSecurityd
      && (uint64_t v12 = *(uint64_t (**)(const __CFDictionary *, uint64_t, uint64_t, CFTypeRef *))(gSecurityd + 96)) != 0)
    {
      uint64_t v13 = *(void *)(a1 + 40);
      uint64_t v14 = SecSecurityClientGet();
      id v15 = (const void *)v12(a3, v13, v14, a6);
      if (!v15)
      {
LABEL_8:
        uint64_t v11 = 0;
        goto LABEL_11;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(a1 + 40);
      SecSecurityClientGet();
      uint64_t v20 = 0;
      CFIndex v21 = &v20;
      uint64_t v22 = 0x2020000000;
      uint64_t v23 = 0;
      v19[0] = MEMORY[0x1E4F143A8];
      v19[1] = 3221225472;
      void v19[2] = __share_with_group_request_block_invoke;
      v19[3] = &__block_descriptor_48_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
      v19[4] = a3;
      v19[5] = v16;
      v18[0] = MEMORY[0x1E4F143A8];
      v18[1] = 3221225472;
      unint64_t v18[2] = __share_with_group_request_block_invoke_2;
      unint64_t v18[3] = &unk_1E547F420;
      v18[4] = &v20;
      securityd_send_sync_and_do(0x83u, a6, (uint64_t)v19, (uint64_t)v18);
      id v15 = (const void *)v21[3];
      _Block_object_dispose(&v20, 8);
      if (!v15) {
        goto LABEL_8;
      }
    }
    uint64_t v11 = SecItemResultProcess(a3, a5, 0, v15, (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), (__CFString **)a6);
    CFRelease(v15);
    goto LABEL_11;
  }
  uint64_t v11 = SecError(-50, (__CFString **)a6, @"Can't share token-protected items");
LABEL_11:

  return v11;
}

BOOL __share_with_group_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  id v5 = a2;
  if (SecXPCDictionarySetPListWithRepair(v5, "query", *(const __CFString **)(a1 + 32), a3, v6, v7, v8, v9))BOOL v10 = SecXPCDictionarySetString((uint64_t)v5, (uint64_t)"sharingGroup", *(const __CFString **)(a1 + 40), a3); {
  else
  }
    BOOL v10 = 0;

  return v10;
}

BOOL __share_with_group_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return SecXPCDictionaryCopyPListOptional(a2, (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), a3);
}

void __SecTokenItemCreateFromAttributes_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t __SecItemDelete_block_invoke_3(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, CFTypeRef *a4)
{
  CFDataRef Value = CFDictionaryGetValue(theDict, @"oid");
  uint64_t v8 = *(void **)(a1 + 32);
  id v20 = 0;
  char v9 = [v8 deleteObject:Value error:&v20];
  id v10 = v20;
  if (v9) {
    goto LABEL_6;
  }
  if (CryptoTokenKitLibraryCore() && getTKErrorDomainSymbolLoc())
  {
    uint64_t v11 = [v10 domain];
    uint64_t v12 = getTKErrorDomain();
    if ([v11 isEqual:v12])
    {
      uint64_t v13 = [v10 code];

      if (v13 == -6)
      {
LABEL_6:
        if (gSecurityd && (uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *))(gSecurityd + 24)) != 0)
        {
          uint64_t v15 = SecSecurityClientGet();
          uint64_t v16 = v14(a3, v15, a4);
        }
        else
        {
          SecSecurityClientGet();
          v21[0] = MEMORY[0x1E4F143A8];
          v21[1] = 3221225472;
          void v21[2] = __dict_to_error_request_block_invoke;
          v21[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
          v21[4] = a3;
          uint64_t v16 = securityd_send_sync_and_do(3u, a4, (uint64_t)v21, 0);
        }
        uint64_t v17 = v16;
        goto LABEL_18;
      }
    }
    else
    {
    }
  }
  id v18 = v10;
  if (v18)
  {
    if (a4 && !*a4) {
      *a4 = v18;
    }
    else {
      CFRelease(v18);
    }
  }
  SecTokenProcessError(@"odel", *(void **)(a1 + 32), (uint64_t)Value, (CFErrorRef *)a4);
  uint64_t v17 = 0;
LABEL_18:

  return v17;
}

uint64_t SecTokenItemForEachMatching(const __CFDictionary *a1, CFTypeRef *a2, void *a3)
{
  uint64_t v34 = a3;
  CFTypeRef cf = 0;
  CFDictionaryRef theDict = a1;
  CFStringRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a1);
  if (!CFDictionaryGetValue(MutableCopy, @"m_Limit")) {
    CFDictionarySetValue(MutableCopy, @"m_Limit", @"m_LimitAll");
  }
  uint64_t v6 = (const void *)*MEMORY[0x1E4F1CFD0];
  CFDictionarySetValue(MutableCopy, @"r_Data", (const void *)*MEMORY[0x1E4F1CFD0]);
  CFDictionarySetValue(MutableCopy, @"r_PersistentRef", v6);
  if (gSecurityd
    && (uint64_t v7 = *(uint64_t (**)(__CFDictionary *, uint64_t, CFTypeRef *, CFTypeRef *))(gSecurityd + 8)) != 0)
  {
    uint64_t v8 = SecSecurityClientGet();
    if ((v7(MutableCopy, v8, &cf, a2) & 1) == 0) {
      goto LABEL_6;
    }
  }
  else
  {
    SecSecurityClientGet();
    if (!cftype_to_BOOL_cftype_error_request(1u, (uint64_t)MutableCopy, (uint64_t)&cf, a2))
    {
LABEL_6:
      CFMutableArrayRef Mutable = 0;
      CFDictionaryRef v10 = 0;
      uint64_t v11 = 0;
      if (!MutableCopy) {
        goto LABEL_28;
      }
LABEL_27:
      CFRelease(MutableCopy);
      goto LABEL_28;
    }
  }
  CFTypeID v12 = CFGetTypeID(cf);
  CFTypeID TypeID = CFArrayGetTypeID();
  CFIndex v21 = cf;
  if (v12 != TypeID)
  {
    CFIndex v21 = CFArrayCreateForCFTypes(0, v14, v15, v16, v17, v18, v19, v20, (uint64_t)cf);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = v21;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)v21);
  if (Count < 1)
  {
    CFMutableArrayRef Mutable = 0;
    CFDictionaryRef v10 = 0;
    uint64_t v11 = 1;
    if (MutableCopy) {
      goto LABEL_27;
    }
  }
  else
  {
    CFIndex v23 = Count;
    id v32 = MutableCopy;
    CFIndex v24 = 0;
    CFDictionaryRef v25 = 0;
    uint64_t v26 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)cf, v24);
      CFDataRef Value = CFDictionaryGetValue(ValueAtIndex, @"v_Data");
      if (!Value)
      {
        SecError(-26276, (__CFString **)a2, @"value not present for token item");
        uint64_t v11 = 0;
        CFMutableArrayRef Mutable = v26;
        CFDictionaryRef v10 = v25;
        goto LABEL_26;
      }
      CFDictionaryRef v10 = SecTokenItemValueCopy(Value, a2);
      if (v25) {
        CFRelease(v25);
      }
      if (!v10)
      {
        uint64_t v11 = 0;
        CFMutableArrayRef Mutable = v26;
        goto LABEL_26;
      }
      CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v26) {
        CFRelease(v26);
      }
      uint64_t v29 = CFDictionaryGetValue(ValueAtIndex, @"v_PersistentRef");
      CFDictionarySetValue(Mutable, @"v_PersistentRef", v29);
      uint64_t v30 = CFDictionaryGetValue(theDict, @"u_SystemKeychain");
      if (v30) {
        CFDictionarySetValue(Mutable, @"u_SystemKeychain", v30);
      }
      if ((v34[2](v34, v10, Mutable, a2) & 1) == 0) {
        break;
      }
      ++v24;
      CFDictionaryRef v25 = v10;
      uint64_t v26 = Mutable;
      if (v23 == v24)
      {
        uint64_t v11 = 1;
        goto LABEL_26;
      }
    }
    uint64_t v11 = 0;
LABEL_26:
    CFStringRef MutableCopy = v32;
    if (v32) {
      goto LABEL_27;
    }
  }
LABEL_28:
  if (cf) {
    CFRelease(cf);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }

  return v11;
}

void SecTokenProcessError(uint64_t a1, void *a2, uint64_t a3, CFErrorRef *a4)
{
  valuePtr[1] = *(const void **)MEMORY[0x1E4F143B8];
  id v6 = a2;
  if (CryptoTokenKitLibraryCore() && getTKErrorDomainSymbolLoc())
  {
    CFErrorDomain Domain = CFErrorGetDomain(*a4);
    getTKErrorDomain();
    if (Domain && v8)
    {
      if (!CFEqual(Domain, v8)) {
        goto LABEL_16;
      }
    }
    else if (Domain != v8)
    {
      goto LABEL_16;
    }
    if (CFErrorGetCode(*a4) == -9)
    {
      id v30 = 0;
      char v9 = [v6 objectForObjectID:a3 error:&v30];
      id v10 = v30;
      uint64_t v11 = v10;
      if (!v9) {
        *a4 = (CFErrorRef)v10;
      }
      CFTypeID v12 = [v9 accessControl];

      if (v12)
      {
        uint64_t v13 = [v9 accessControl];
        CFArrayRef v21 = CFArrayCreateForCFTypes(0, v14, v15, v16, v17, v18, v19, v20, (uint64_t)v13);
        userInfoValues = CFArrayCreateForCFTypes(0, v22, v23, v24, v25, v26, v27, v28, (uint64_t)v21);
        valuePtr[0] = (const void *)-25330;
        valuePtr[0] = CFNumberCreate(0, kCFNumberCFIndexType, valuePtr);
        CFErrorRef v29 = CFErrorCreateWithUserInfoKeysAndValues(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], -25330, valuePtr, (const void *const *)&userInfoValues, 1);
        if (*a4) {
          CFRelease(*a4);
        }
        *a4 = v29;
        CFRelease(valuePtr[0]);
        CFRelease(userInfoValues);
        CFRelease(v21);
      }
    }
  }
LABEL_16:
}

OSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate)
{
  char v4 = (void *)MEMORY[0x18C12E850]();
  id v5 = _os_activity_create(&dword_18B299000, "SecItemUpdate_ios", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &state);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  _DWORD v7[2] = __SecItemUpdate_block_invoke;
  unint64_t v7[3] = &__block_descriptor_48_e20_B16__0_____CFError_8l;
  void v7[4] = query;
  unint64_t v7[5] = attributesToUpdate;
  LODWORD(attributesToUpdate) = SecOSStatusWith((uint64_t)v7);
  os_activity_scope_leave(&state);

  return (int)attributesToUpdate;
}

void sub_18B391E70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

uint64_t __SecItemUpdate_block_invoke(uint64_t a1, uint64_t a2)
{
  return SecItemUpdateWithError(*(const __CFDictionary **)(a1 + 32), *(void *)(a1 + 40), a2);
}

uint64_t SecItemUpdateWithError(const __CFDictionary *a1, uint64_t a2, uint64_t a3)
{
  id v6 = (void *)MEMORY[0x18C12E850]();
  CFDictionaryRef v21 = a1;
  CFTypeRef cf = 0;
  uint64_t v19 = a2;
  CFTypeRef v20 = 0;
  CFDataRef Value = CFDictionaryGetValue(a1, @"v_Ref");
  if (Value)
  {
    CFErrorDomain v8 = Value;
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == SecIdentityGetTypeID())
    {
      id v10 = (const void *)v8[2];
      CFRetain(v10);
      uint64_t v11 = (const void *)v8[3];
      CFRetain(v11);
      CFStringRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a1);
      if (!MutableCopy)
      {
        uint64_t v14 = 0;
        if (!v10) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
      uint64_t v13 = MutableCopy;
      CFDictionarySetValue(MutableCopy, @"v_Ref", v10);
      if (SecItemUpdateWithError(v13, a2, a3))
      {
        CFDictionarySetValue(v13, @"v_Ref", v11);
        uint64_t v14 = SecItemUpdateWithError(v13, a2, a3);
        goto LABEL_11;
      }
      goto LABEL_24;
    }
LABEL_15:
    uint64_t v14 = SecItemAuthDoQuery(&v21, &v19, SecItemUpdate, a3, &__block_literal_global_10066);
    CFTypeRef v17 = cf;
    if (!cf) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  uint64_t v15 = CFDictionaryGetValue(a1, @"class");
  if (!v15 || !CFEqual(@"idnt", v15)) {
    goto LABEL_15;
  }
  uint64_t v16 = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a1);
  if (v16)
  {
    uint64_t v13 = v16;
    CFDictionarySetValue(v16, @"class", @"cert");
    if (SecItemUpdateWithError(v13, a2, a3))
    {
      CFDictionarySetValue(v13, @"class", @"keys");
      id v10 = 0;
      uint64_t v14 = (SecItemUpdateWithError(v13, a2, a3) & 1) != 0;
      uint64_t v11 = 0;
      goto LABEL_11;
    }
    id v10 = 0;
    uint64_t v11 = 0;
LABEL_24:
    uint64_t v14 = 0;
LABEL_11:
    CFRelease(v13);
    if (!v10)
    {
LABEL_13:
      if (!v11) {
        goto LABEL_17;
      }
      CFTypeRef v17 = v11;
LABEL_16:
      CFRelease(v17);
      goto LABEL_17;
    }
LABEL_12:
    CFRelease(v10);
    goto LABEL_13;
  }
  uint64_t v14 = 0;
LABEL_17:
  if (v20) {
    CFRelease(v20);
  }
  return v14;
}

uint64_t __SecItemUpdateWithError_block_invoke(uint64_t a1, void *a2, const __CFDictionary *a3, const __CFDictionary *a4, uint64_t a5, CFTypeRef *a6)
{
  id v9 = a2;
  if ((isModifyingAPIRateWithinLimits() & 1) == 0) {
    __security_simulatecrash(@"BUG IN CLIENT OF SECITEM: too many writes. See https://at.apple.com/secitemratelimit", 0x53C0000Fu);
  }
  if (v9)
  {
    id v10 = v9;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    void v13[2] = __SecTokenItemUpdate_block_invoke;
    v13[3] = &unk_1E547F7E8;
    id v14 = v10;
    CFDictionaryRef v15 = a4;
    uint64_t v11 = SecTokenItemForEachMatching(a3, a6, v13);
  }
  else
  {
    uint64_t v11 = SecItemRawUpdate((const __CFString *)a3, a4, a6);
  }

  return v11;
}

uint64_t SecItemRawUpdate(const __CFString *a1, const __CFDictionary *a2, CFTypeRef *a3)
{
  if (gSecurityd)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], 0);
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 3221225472;
    context[2] = __SecItemRawUpdate_block_invoke;
    context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
    void context[4] = Mutable;
    CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)apply_block_2_9961, context);
    uint64_t v7 = *(uint64_t (**)(const __CFString *, CFMutableDictionaryRef, uint64_t, CFTypeRef *))(gSecurityd + 16);
    uint64_t v8 = SecSecurityClientGet();
    uint64_t v9 = v7(a1, Mutable, v8, a3);
    CFRelease(Mutable);
  }
  else
  {
    xpc_object_t message = securityd_create_message(2u, a3);
    CFDictionaryRef v15 = message;
    if (message
      && SecXPCDictionarySetPListWithRepair(message, "query", a1, (__CFString **)a3, v11, v12, v13, v14)
      && SecXPCDictionarySetPListWithRepair(v15, "attributesToUpdate", (const __CFString *)a2, (__CFString **)a3, v16, v17, v18, v19))
    {
      logUnreasonableDataLength(a2);
      uint64_t v20 = securityd_message_with_reply_sync(v15, (uint64_t)a3);
      CFDictionaryRef v21 = (void *)v20;
      if (v20) {
        uint64_t v9 = securityd_message_no_error(v20, (CFErrorRef *)a3);
      }
      else {
        uint64_t v9 = 0;
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
  }
  return v9;
}

uint64_t __SecTokenItemUpdate_block_invoke(uint64_t a1, const __CFDictionary *a2, const __CFString *a3, CFErrorRef *a4)
{
  CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, *(CFDictionaryRef *)(a1 + 40));
  uint64_t v9 = *(void **)(a1 + 32);
  CFDataRef Value = CFDictionaryGetValue(a2, @"oid");
  uint64_t v11 = SecTokenCopyUpdatedObjectID(v9, (uint64_t)Value, MutableCopy, a4);
  if (!v11)
  {
    uint64_t v13 = 0;
    if (!MutableCopy) {
      return v13;
    }
    goto LABEL_3;
  }
  uint64_t v12 = v11;
  uint64_t v13 = SecItemRawUpdate(a3, MutableCopy, (CFTypeRef *)a4);
  CFRelease(v12);
  if (MutableCopy) {
LABEL_3:
  }
    CFRelease(MutableCopy);
  return v13;
}

void *SecTokenCopyUpdatedObjectID(void *a1, uint64_t a2, const __CFDictionary *a3, CFErrorRef *a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a3);
  if (a2)
  {
    uint64_t v38 = 0;
    uint64_t v9 = (id *)&v38;
    uint64_t v10 = [v7 objectForObjectID:a2 error:&v38];
  }
  else
  {
    uint64_t v39 = 0;
    uint64_t v9 = (id *)&v39;
    uint64_t v10 = [v7 createObjectWithAttributes:a3 error:&v39];
  }
  uint64_t v11 = (void *)v10;
  id v12 = *v9;
  uint64_t v13 = v12;
  if (a4 && !v11)
  {
    *a4 = (CFErrorRef)v12;
LABEL_7:
    if (a2) {
      uint64_t v14 = a2;
    }
    else {
      uint64_t v14 = (uint64_t)a3;
    }
    SecTokenProcessError(@"oe", v7, v14, a4);
    CFDictionaryRef v15 = 0;
    goto LABEL_28;
  }
  if (!v11) {
    goto LABEL_7;
  }
  id v32 = v12;
  CFDictionaryRemoveAllValues(a3);
  uint64_t v16 = [v11 keychainAttributes];
  [(__CFDictionary *)a3 addEntriesFromDictionary:v16];

  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  CFDictionaryRef v33 = Copy;
  CFDictionaryRef v17 = Copy;
  uint64_t v18 = [(__CFDictionary *)v17 countByEnumeratingWithState:&v34 objects:v40 count:16];
  if (v18)
  {
    uint64_t v19 = v18;
    uint64_t v20 = *(void *)v35;
    do
    {
      for (uint64_t i = 0; i != v19; ++i)
      {
        if (*(void *)v35 != v20) {
          objc_enumerationMutation(v17);
        }
        uint64_t v22 = *(void **)(*((void *)&v34 + 1) + 8 * i);
        if ((objc_msgSend(v22, "isEqualToString:", @"v_Data", v32) & 1) == 0) {
          CFDictionaryAddValue(a3, v22, (const void *)[(__CFDictionary *)v17 objectForKey:v22]);
        }
      }
      uint64_t v19 = [(__CFDictionary *)v17 countByEnumeratingWithState:&v34 objects:v40 count:16];
    }
    while (v19);
  }

  uint64_t v23 = [v11 accessControl];
  uint64_t v24 = [v11 objectID];
  CFDataRef Value = CFDictionaryGetValue(a3, @"v_Data");
  id v30 = SecTokenItemValueCreate((uint64_t)v24, (int)v23, Value, (CFTypeRef *)a4, v26, v27, v28, v29);

  if (v30)
  {
    CFDictionarySetValue(a3, @"v_Data", v30);
    CFDictionaryRemoveValue(a3, @"accc");
    CFDictionaryRef v15 = [v11 objectID];

    if (v15) {
      CFRetain(v15);
    }
  }
  else
  {
    CFDictionaryRef v15 = 0;
  }
  uint64_t v13 = v32;
  CFDictionaryRef Copy = v33;
  if (v23) {
    CFRelease(v23);
  }
  if (v30) {
    CFRelease(v30);
  }
LABEL_28:
  if (Copy) {
    CFRelease(Copy);
  }

  return v15;
}

__CFData *SecTokenItemValueCreate(uint64_t a1, int a2, const void *a3, CFTypeRef *a4, int a5, int a6, int a7, int a8)
{
  MutableForCFTypesWith_10068 = CFDictionaryCreateMutableForCFTypesWith_10068(a1, a2, (int)a3, (int)a4, a5, a6, a7, a8, @"oid", a1);
  CFStringRef v16 = (const __CFString *)MutableForCFTypesWith_10068;
  if (a3) {
    CFDictionarySetValue(MutableForCFTypesWith_10068, @"data", a3);
  }
  DERData = CFPropertyListCreateDERData((uint64_t)MutableForCFTypesWith_10068, v16, a4, v11, v12, v13, v14, v15);
  CFRelease(v16);
  return DERData;
}

__CFDictionary *CFDictionaryCreateMutableForCFTypesWith_10068(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *key, uint64_t a10)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v14 = (const void **)&a10;
  uint64_t v11 = key;
  if (key)
  {
    do
    {
      CFDictionarySetValue(Mutable, v11, *v14);
      uint64_t v12 = v14 + 1;
      v14 += 2;
      uint64_t v11 = *v12;
    }
    while (*v12);
  }
  return Mutable;
}

void __SecItemRawUpdate_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
}

void __SecTokenItemAdd_block_invoke(uint64_t a1, CFTypeRef cf1, const void *a3)
{
  if (!CFEqual(cf1, @"v_Data") && !CFEqual(cf1, @"toid") && !CFEqual(cf1, @"accc"))
  {
    id v6 = *(__CFDictionary **)(a1 + 32);
    CFDictionaryAddValue(v6, cf1, a3);
  }
}

uint64_t SecDeleteItemsOnSignOut(CFTypeRef *a1)
{
  CFHashCode v2 = (void *)MEMORY[0x18C12E850]();
  char v3 = _os_activity_create(&dword_18B299000, "SecDeleteItemsOnSignOut", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v3, &state);
  if (gSecurityd)
  {
    char v4 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gSecurityd + 104);
    uint64_t v5 = SecSecurityClientGet();
    uint64_t v6 = v4(v5, a1);
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2020000000;
    char v12 = 0;
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    unint64_t v8[2] = __SecDeleteItemsOnSignOut_block_invoke;
    unint64_t v8[3] = &unk_1E547F420;
    v8[4] = &v9;
    securityd_send_sync_and_do(0x84u, a1, 0, (uint64_t)v8);
    uint64_t v6 = *((unsigned char *)v10 + 24) != 0;
    _Block_object_dispose(&v9, 8);
  }
  os_activity_scope_leave(&state);

  return v6;
}

void sub_18B3929E4(_Unwind_Exception *a1)
{
  os_activity_scope_leave((os_activity_scope_state_t)(v1 - 48));
  _Unwind_Resume(a1);
}

uint64_t __SecDeleteItemsOnSignOut_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = xpc_dictionary_get_BOOL(xdict, "status");
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t _SecKeychainForceUpgradeIfNeeded()
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  int v8 = -26276;
  uint64_t v0 = (void *)MEMORY[0x18C12E850]();
  uint64_t v1 = SecuritydXPCProxyObject(1, &__block_literal_global_45_10077);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___SecKeychainForceUpgradeIfNeeded_block_invoke_46;
  v4[3] = &unk_1E547F568;
  v4[4] = &v5;
  [v1 secKeychainForceUpgradeIfNeeded:v4];

  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_18B392B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SecItemDeleteAll()
{
  uint64_t v0 = (void *)MEMORY[0x18C12E850]();
  uint64_t v1 = SecOSStatusWith((uint64_t)&__block_literal_global_50_10084);
  return v1;
}

uint64_t __SecItemDeleteAll_block_invoke(uint64_t a1, __CFString **a2)
{
  if (gSecurityd)
  {
    if ((*(uint64_t (**)(__CFString **))(gSecurityd + 32))(a2))
    {
      return 1;
    }
    else
    {
      return SecError(-26276, a2, @"sec_item_delete_all is NULL");
    }
  }
  else
  {
    return securityd_send_sync_and_do(7u, (CFTypeRef *)a2, 0, 0);
  }
}

uint64_t SecItemDeleteAllWithAccessGroups()
{
  return 1;
}

uint64_t SecItemUpdateTokenItemsForAccessGroups(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (void *)MEMORY[0x18C12E850]();
  uint64_t v7 = _os_activity_create(&dword_18B299000, "SecItemUpdateTokenItemsForAccessGroups", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = __SecItemUpdateTokenItemsForAccessGroups_block_invoke;
  unint64_t v10[3] = &__block_descriptor_56_e20_B16__0_____CFError_8l;
  v10[4] = a3;
  void v10[5] = a1;
  void v10[6] = a2;
  uint64_t v8 = SecOSStatusWith((uint64_t)v10);
  os_activity_scope_leave(&state);

  return v8;
}

void sub_18B392E84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state)
{
}

uint64_t __SecItemUpdateTokenItemsForAccessGroups_block_invoke(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v2 = a1;
  if (*(void *)(a1 + 32))
  {
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    CFIndex v4 = 0;
    uint64_t v5 = @"accc";
    uint64_t v6 = @"toid";
    uint64_t v7 = @"v_Data";
    while (v4 < CFArrayGetCount(*(CFArrayRef *)(v2 + 32)))
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 32), v4);
      CFDataRef Value = CFDictionaryGetValue(ValueAtIndex, v5);
      uint64_t v10 = CFDictionaryGetValue(ValueAtIndex, v6);
      uint64_t v11 = CFDictionaryGetValue(ValueAtIndex, v7);
      if (v10) {
        BOOL v12 = Value == 0;
      }
      else {
        BOOL v12 = 1;
      }
      if (v12) {
        goto LABEL_14;
      }
      uint64_t v13 = v11;
      CFIndex v40 = v4;
      uint64_t v14 = v2;
      uint64_t v15 = Mutable;
      CFStringRef v16 = v7;
      CFDictionaryRef v17 = v6;
      uint64_t v18 = v5;
      CFTypeID TypeID = CFDataGetTypeID();
      BOOL v12 = TypeID == CFGetTypeID(Value);
      uint64_t v5 = v18;
      uint64_t v6 = v17;
      uint64_t v7 = v16;
      CFMutableDictionaryRef Mutable = v15;
      uint64_t v2 = v14;
      CFIndex v4 = v40;
      if (v12)
      {
        uint64_t v24 = SecTokenItemValueCreate((uint64_t)v10, (int)Value, v13, a2, v20, v21, v22, v23);
        if (!v24)
        {
          uint64_t v36 = 0;
          if (Mutable) {
            goto LABEL_34;
          }
          return v36;
        }
        uint64_t v25 = v24;
        CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(allocator, 0, ValueAtIndex);
        CFDictionarySetValue(MutableCopy, v7, v25);
        CFDictionarySetValue(MutableCopy, @"tkid", *(const void **)(v2 + 40));
        CFDictionaryRemoveValue(MutableCopy, v5);
        CFDictionaryRemoveValue(MutableCopy, v6);
        CFArrayAppendValue(Mutable, MutableCopy);
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
        CFRelease(v25);
      }
      else
      {
LABEL_14:
        CFArrayAppendValue(Mutable, ValueAtIndex);
      }
      ++v4;
    }
  }
  else
  {
    CFMutableDictionaryRef Mutable = 0;
  }
  if (gSecurityd
    && (int v27 = *(uint64_t (**)(uint64_t, uint64_t, __CFArray *, uint64_t, CFTypeRef *))(gSecurityd + 80)) != 0)
  {
    uint64_t v28 = *(void *)(v2 + 40);
    if (*(void *)(v2 + 48)) {
      uint64_t v29 = *(void *)(v2 + 48);
    }
    else {
      uint64_t v29 = MEMORY[0x1E4F1CBF0];
    }
    if (Mutable) {
      id v30 = Mutable;
    }
    else {
      id v30 = (__CFArray *)MEMORY[0x1E4F1CBF0];
    }
    uint64_t v31 = SecSecurityClientGet();
    uint64_t v32 = v27(v28, v29, v30, v31, a2);
  }
  else
  {
    uint64_t v33 = *(void *)(v2 + 40);
    if (*(void *)(v2 + 48)) {
      uint64_t v34 = *(void *)(v2 + 48);
    }
    else {
      uint64_t v34 = MEMORY[0x1E4F1CBF0];
    }
    if (Mutable) {
      long long v35 = Mutable;
    }
    else {
      long long v35 = (__CFArray *)MEMORY[0x1E4F1CBF0];
    }
    SecSecurityClientGet();
    v41[0] = MEMORY[0x1E4F143A8];
    v41[1] = 3221225472;
    v41[2] = __cfstring_array_array_to_error_request_block_invoke;
    unint64_t v41[3] = &__block_descriptor_56_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v41[4] = v33;
    v41[5] = v34;
    v41[6] = v35;
    uint64_t v32 = securityd_send_sync_and_do(0x62u, a2, (uint64_t)v41, 0);
  }
  uint64_t v36 = v32;
  if (Mutable) {
LABEL_34:
  }
    CFRelease(Mutable);
  return v36;
}

BOOL __cfstring_array_array_to_error_request_block_invoke(void *a1, void *a2, __CFString **a3)
{
  id v5 = a2;
  uint64_t v10 = v5;
  CFStringRef v11 = (const __CFString *)a1[4];
  BOOL v14 = 0;
  if (!v11 || SecXPCDictionarySetString((uint64_t)v5, (uint64_t)"cfstring", v11, a3))
  {
    CFStringRef v12 = (const __CFString *)a1[5];
    if (!v12 || SecXPCDictionarySetPListWithRepair(v10, "cfarray", v12, a3, v6, v7, v8, v9))
    {
      CFStringRef v13 = (const __CFString *)a1[6];
      if (!v13 || SecXPCDictionarySetPListWithRepair(v10, "query", v13, a3, v6, v7, v8, v9)) {
        BOOL v14 = 1;
      }
    }
  }

  return v14;
}

uint64_t _SecKeychainSyncUpdateMessage(uint64_t a1, uint64_t a2)
{
  CFIndex v4 = (void *)MEMORY[0x18C12E850]();
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2020000000;
  unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 3221225472;
  activity_block[2] = ___SecKeychainSyncUpdateMessage_block_invoke;
  activity_block[3] = &unk_1E547F5D0;
  activity_block[4] = &v8;
  activity_void block[5] = a1;
  activity_block[6] = a2;
  _os_activity_initiate(&dword_18B299000, "_SecKeychainSyncUpdateMessage", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v5 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t _SecKeychainRollKeys(uint64_t a1, CFTypeRef *a2)
{
  CFIndex v4 = (void *)MEMORY[0x18C12E850]();
  if (gSecurityd && (uint64_t v5 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gSecurityd + 72)) != 0)
  {
    uint64_t v6 = v5(a1, a2);
  }
  else
  {
    uint64_t v11 = 0;
    CFStringRef v12 = &v11;
    uint64_t v13 = 0x2020000000;
    char v14 = 0;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    _OWORD v9[2] = ___SecKeychainRollKeys_block_invoke;
    v9[3] = &__block_descriptor_33_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    char v10 = a1;
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    unint64_t v8[2] = ___SecKeychainRollKeys_block_invoke_2;
    unint64_t v8[3] = &unk_1E547F420;
    v8[4] = &v11;
    securityd_send_sync_and_do(0x1Du, a2, (uint64_t)v9, (uint64_t)v8);
    uint64_t v6 = *((unsigned char *)v12 + 24) != 0;
    _Block_object_dispose(&v11, 8);
  }
  return v6;
}

BOOL __data_array_to_array_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return SecXPCDictionaryCopyArrayOptional(a2, "status", (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), a3);
}

uint64_t SecItemCertificateExists(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v8 = (void *)MEMORY[0x18C12E850]();
  uint64_t v9 = _os_activity_create(&dword_18B299000, "SecItemCertificateExists", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v13.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &v13);
  if (gSecurityd && (char v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFTypeRef *))(gSecurityd + 48)) != 0)
  {
    uint64_t v11 = v10(a1, a2, a3, a4);
  }
  else
  {
    uint64_t v16 = 0;
    CFDictionaryRef v17 = &v16;
    uint64_t v18 = 0x2020000000;
    char v19 = 0;
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    v15[2] = __data_data_array_to_BOOL_error_request_block_invoke;
    unint64_t v15[3] = &__block_descriptor_56_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v15[4] = a1;
    v15[5] = a2;
    v15[6] = a3;
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    void v14[2] = __data_data_array_to_BOOL_error_request_block_invoke_2;
    v14[3] = &unk_1E547F420;
    void v14[4] = &v16;
    securityd_send_sync_and_do(0x6Eu, a4, (uint64_t)v15, (uint64_t)v14);
    uint64_t v11 = *((unsigned char *)v17 + 24) != 0;
    _Block_object_dispose(&v16, 8);
  }
  os_activity_scope_leave(&v13);

  return v11;
}

void sub_18B393730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

uint64_t _SecItemAddAndNotifyOnSync(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v16 = 0;
  CFDictionaryRef v17 = &v16;
  uint64_t v18 = 0x3010000000;
  char v19 = &unk_18B4547AE;
  uint64_t v20 = a1;
  uint64_t v21 = 0;
  uint64_t v6 = _os_activity_create(&dword_18B299000, "_SecItemAddAndNotifyOnSync", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v6, &state);
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  _OWORD v11[2] = ___SecItemAddAndNotifyOnSync_block_invoke;
  unint64_t v11[3] = &unk_1E547F6B8;
  os_activity_scope_state_s v13 = &v16;
  id v7 = v5;
  id v12 = v7;
  uint64_t v14 = a2;
  uint64_t v8 = SecOSStatusWith((uint64_t)v11);
  uint64_t v9 = (const void *)v17[5];
  if (v9)
  {
    void v17[5] = 0;
    CFRelease(v9);
  }

  os_activity_scope_leave(&state);
  _Block_object_dispose(&v16, 8);

  return v8;
}

void sub_18B393948(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_18B393CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v27 - 128), 8);
  _Unwind_Resume(a1);
}

void SecItemSetCurrentItemAcrossAllDevices(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  id v12 = a8;
  os_activity_scope_state_s v13 = _os_activity_create(&dword_18B299000, "SecItemSetCurrentItemAcrossAllDevices", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v13, &state);
  uint64_t v14 = (void *)MEMORY[0x18C12E850]();
  v23[0] = MEMORY[0x1E4F143A8];
  v23[1] = 3221225472;
  void v23[2] = __SecItemSetCurrentItemAcrossAllDevices_block_invoke;
  void v23[3] = &unk_1E547F618;
  id v15 = v12;
  id v24 = v15;
  uint64_t v16 = SecuritydXPCProxyObject(0, v23);
  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 3221225472;
  void v21[2] = __SecItemSetCurrentItemAcrossAllDevices_block_invoke_2;
  v21[3] = &unk_1E547F618;
  id v17 = v15;
  id v22 = v17;
  [v16 secItemSetCurrentItemAcrossAllDevices:a4 newCurrentItemHash:a5 accessGroup:a1 identifier:a2 viewHint:a3 oldCurrentItemReference:a6 oldCurrentItemHash:a7 complete:v21];

  os_activity_scope_leave(&state);
}

void sub_18B393F7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,os_activity_scope_state_s state)
{
}

uint64_t __SecItemSetCurrentItemAcrossAllDevices_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t __SecItemSetCurrentItemAcrossAllDevices_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void SecItemUnsetCurrentItemsAcrossAllDevices(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  uint64_t v8 = _os_activity_create(&dword_18B299000, "SecItemUnsetCurrentItemsAcrossAllDevices", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v8, &state);
  uint64_t v9 = (void *)MEMORY[0x18C12E850]();
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3221225472;
  v15[2] = __SecItemUnsetCurrentItemsAcrossAllDevices_block_invoke;
  unint64_t v15[3] = &unk_1E547F618;
  id v10 = v7;
  id v16 = v10;
  uint64_t v11 = SecuritydXPCProxyObject(0, v15);
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  void v13[2] = __SecItemUnsetCurrentItemsAcrossAllDevices_block_invoke_2;
  v13[3] = &unk_1E547F618;
  id v12 = v10;
  id v14 = v12;
  [v11 secItemUnsetCurrentItemsAcrossAllDevices:a1 identifiers:a2 viewHint:a3 complete:v13];

  os_activity_scope_leave(&state);
}

void sub_18B394130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state)
{
}

uint64_t __SecItemUnsetCurrentItemsAcrossAllDevices_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t __SecItemUnsetCurrentItemsAcrossAllDevices_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void SecItemFetchCurrentItemAcrossAllDevices(void *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a5;
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  _OWORD v11[2] = __SecItemFetchCurrentItemAcrossAllDevices_block_invoke;
  unint64_t v11[3] = &unk_1E547F6E0;
  id v12 = v9;
  id v10 = v9;
  SecItemFetchCurrentItemDataAcrossAllDevices(a1, a2, a3, a4, v11);
}

void __SecItemFetchCurrentItemAcrossAllDevices_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a3;
  id v6 = [a2 persistentRef];
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v6, v5);
}

void SecItemFetchCurrentItemDataAcrossAllDevices(void *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a1;
  id v10 = a2;
  id v11 = a3;
  id v12 = a5;
  os_activity_scope_state_s v13 = _os_activity_create(&dword_18B299000, "SecItemFetchCurrentItemDataAcrossAllDevices", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v13, &state);
  id v14 = (void *)MEMORY[0x18C12E850]();
  v20[0] = MEMORY[0x1E4F143A8];
  v20[1] = 3221225472;
  v20[2] = __SecItemFetchCurrentItemDataAcrossAllDevices_block_invoke;
  v20[3] = &unk_1E547F618;
  id v15 = v12;
  id v21 = v15;
  id v16 = SecuritydXPCProxyObject(0, v20);
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 3221225472;
  unint64_t v18[2] = __SecItemFetchCurrentItemDataAcrossAllDevices_block_invoke_2;
  unint64_t v18[3] = &unk_1E547F708;
  id v17 = v15;
  id v19 = v17;
  [v16 secItemFetchCurrentItemAcrossAllDevices:v9 identifier:v10 viewHint:v11 fetchCloudValue:a4 complete:v18];

  os_activity_scope_leave(&state);
}

void sub_18B394450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state)
{
}

uint64_t __SecItemFetchCurrentItemDataAcrossAllDevices_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void __SecItemFetchCurrentItemDataAcrossAllDevices_block_invoke_2(uint64_t a1, SecItemCurrentItemData *a2, void *a3, void *a4)
{
  id v9 = a4;
  if (a2)
  {
    id v7 = a3;
    uint64_t v8 = a2;
    a2 = [[SecItemCurrentItemData alloc] initWithPersistentRef:v8];

    [(SecItemCurrentItemData *)a2 setCurrentItemPointerModificationTime:v7];
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void _SecItemFetchDigests(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  uint64_t v8 = _os_activity_create(&dword_18B299000, "_SecItemFetchDigests", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v8, &state);
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  _OWORD v11[2] = ___SecItemFetchDigests_block_invoke;
  unint64_t v11[3] = &unk_1E547F618;
  id v9 = v7;
  id v12 = v9;
  id v10 = SecuritydXPCProxyObject(0, v11);
  [v10 secItemDigest:v5 accessGroup:v6 complete:v9];

  os_activity_scope_leave(&state);
}

void sub_18B39465C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void _SecKeychainDeleteMultiUser(void *a1, void *a2)
{
  v32[1] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = _os_activity_create(&dword_18B299000, "_SecKeychainDeleteMultiUser", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &state);
  id v6 = (void *)[objc_alloc(MEMORY[0x1E4F29128]) initWithUUIDString:v3];
  id v7 = v6;
  if (v6)
  {
    v31[0] = 0xAAAAAAAAAAAAAAAALL;
    v31[1] = 0xAAAAAAAAAAAAAAAALL;
    [v6 getUUIDBytes:v31];
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    uint64_t v25 = ___SecKeychainDeleteMultiUser_block_invoke;
    int v26 = &unk_1E547F618;
    id v8 = v4;
    id v27 = v8;
    id v9 = v24;
    if (gSecurityd && *(void *)(gSecurityd + 696)) {
      id v10 = objc_alloc_init(FakeSecuritydXPCClient);
    }
    else {
      id v10 = [[SecuritydXPCClient alloc] initTargetingSession:0];
    }
    id v11 = v10;
    if (v10)
    {

      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      v22[2] = ___SecKeychainDeleteMultiUser_block_invoke_2;
      v22[3] = &unk_1E547F618;
      id v12 = v8;
      id v23 = v12;
      os_activity_scope_state_s v13 = [(FakeSecuritydXPCClient *)v11 protocolWithSync:0 errorHandler:v22];
      if (v13)
      {
        cf[0] = 0;
        cf[1] = cf;
        cf[2] = (CFTypeRef)0x3032000000;
        cf[3] = __Block_byref_object_copy__9966;
        CFTypeRef cf[4] = __Block_byref_object_dispose__9967;
        id v30 = v11;
        id v14 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v31 length:16];
        v19[0] = MEMORY[0x1E4F143A8];
        v19[1] = 3221225472;
        void v19[2] = ___SecKeychainDeleteMultiUser_block_invoke_88;
        v19[3] = &unk_1E547F730;
        id v20 = v12;
        id v21 = cf;
        [v13 secKeychainDeleteMultiuser:v14 complete:v19];

        _Block_object_dispose(cf, 8);
      }
    }
    else
    {
      id v16 = (void *)MEMORY[0x1E4F28C58];
      v32[0] = *MEMORY[0x1E4F28568];
      cf[0] = @"Could not create SecuritydXPCClientObject";
      id v17 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:cf forKeys:v32 count:1];
      uint64_t v18 = [v16 errorWithDomain:@"securityd" code:-1 userInfo:v17];
      ((void (*)(void *, void *))v25)(v9, v18);
    }
  }
  else
  {
    cf[0] = 0;
    SecError(-50, (__CFString **)cf, @"_SecKeychainDeleteMultiUser: invalid UUID %@", v3);
    (*((void (**)(id, void, CFTypeRef))v4 + 2))(v4, 0, cf[0]);
    CFTypeRef v15 = cf[0];
    if (cf[0])
    {
      cf[0] = 0;
      CFRelease(v15);
    }
  }

  os_activity_scope_leave(&state);
}

void sub_18B394A40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,os_activity_scope_state_s state,char a28)
{
}

uint64_t SecItemDeleteKeychainItemsForAppClip(uint64_t a1)
{
  uint64_t v7 = 0;
  id v8 = &v7;
  uint64_t v9 = 0x2020000000;
  int v10 = -26276;
  uint64_t v2 = (void *)MEMORY[0x18C12E850]();
  id v3 = SecuritydXPCProxyObject(1, &__block_literal_global_90);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __SecItemDeleteKeychainItemsForAppClip_block_invoke_91;
  unint64_t v6[3] = &unk_1E547F568;
  void v6[4] = &v7;
  [v3 secItemDeleteForAppClipApplicationIdentifier:a1 completion:v6];

  uint64_t v4 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_18B394BE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __SecItemDeleteKeychainItemsForAppClip_block_invoke_91(uint64_t a1, int a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = secLogObjForScope("xpc");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = a2;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "app clip deletion result: %i", (uint8_t *)v5, 8u);
  }

  if (!a2 || a2 == -34018) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  }
}

void __SecItemDeleteKeychainItemsForAppClip_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  id v2 = a2;
  id v3 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = v2;
    _os_log_impl(&dword_18B299000, v3, OS_LOG_TYPE_DEFAULT, "xpc: failure to obtain XPC proxy object for app clip deletion, %@", (uint8_t *)&v4, 0xCu);
  }
}

uint64_t SecItemPersistKeychainWritesAtHighPerformanceCost(void *a1)
{
  id v2 = _os_activity_create(&dword_18B299000, "SecItemPersistKeychainWritesAtHighPerformanceCost", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v2, &state);
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2020000000;
  int v20 = -26276;
  uint64_t v13 = 0;
  id v14 = &v13;
  uint64_t v15 = 0x2020000000;
  uint64_t v16 = 0;
  id v3 = (void *)MEMORY[0x18C12E850]();
  int v4 = secLogObjForScope("xpc");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "This process is requesting a expensive full keychain database checkpoint", buf, 2u);
  }

  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  _OWORD v11[2] = __SecItemPersistKeychainWritesAtHighPerformanceCost_block_invoke;
  unint64_t v11[3] = &unk_1E5481470;
  void v11[4] = &v13;
  id v5 = SecuritydXPCProxyObject(1, v11);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = __SecItemPersistKeychainWritesAtHighPerformanceCost_block_invoke_92;
  unint64_t v10[3] = &unk_1E547F758;
  v10[4] = &v13;
  void v10[5] = &v17;
  [v5 secItemPersistKeychainWritesAtHighPerformanceCost:v10];

  uint64_t v6 = v14;
  uint64_t v7 = (const void *)v14[3];
  if (v7)
  {
    if (!a1 || (CFRetain((CFTypeRef)v14[3]), *a1 = v7, uint64_t v6 = v14, (v7 = (const void *)v14[3]) != 0))
    {
      unint64_t v6[3] = 0;
      CFRelease(v7);
    }
  }
  uint64_t v8 = *((unsigned int *)v18 + 6);
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  os_activity_scope_leave(&state);

  return v8;
}

void sub_18B394F9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 112), 8);
  os_activity_scope_leave((os_activity_scope_state_t)(v15 - 80));
  _Unwind_Resume(a1);
}

void __SecItemPersistKeychainWritesAtHighPerformanceCost_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  int v4 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v3;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "xpc: failure to obtain XPC proxy object for Item Persistence, %@", (uint8_t *)&v6, 0xCu);
  }

  id v5 = v3;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
}

void __SecItemPersistKeychainWritesAtHighPerformanceCost_block_invoke_92(uint64_t a1, int a2, void *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  if (a2)
  {
    int v6 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v8[0] = 67109378;
      v8[1] = a2;
      __int16 v9 = 2112;
      id v10 = v5;
      _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "xpc: Failed to persist keychain writes: %d %@", (uint8_t *)v8, 0x12u);
    }

    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
  }
  else
  {
    id v7 = secLogObjForScope("xpc");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8[0]) = 0;
      _os_log_impl(&dword_18B299000, v7, OS_LOG_TYPE_DEFAULT, "Successfully persisted keychain data to disk", (uint8_t *)v8, 2u);
    }
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
}

uint64_t SecItemPromoteAppClipItemsToParentApp(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0;
  id v10 = &v9;
  uint64_t v11 = 0x2020000000;
  int v12 = -26276;
  int v4 = (void *)MEMORY[0x18C12E850]();
  id v5 = SecuritydXPCProxyObject(1, &__block_literal_global_95);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  _DWORD v8[2] = __SecItemPromoteAppClipItemsToParentApp_block_invoke_96;
  unint64_t v8[3] = &unk_1E547F568;
  v8[4] = &v9;
  [v5 secItemPromoteItemsForAppClip:a1 toParentApp:a2 completion:v8];

  uint64_t v6 = *((unsigned int *)v10 + 6);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_18B3952D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __SecItemPromoteAppClipItemsToParentApp_block_invoke_96(uint64_t a1, int a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  int v4 = secLogObjForScope("xpc");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = a2;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "app clip promotion result: %i", (uint8_t *)v5, 8u);
  }

  if (a2 == -34018 || !a2 || a2 == -25308) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  }
}

void __SecItemPromoteAppClipItemsToParentApp_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  id v2 = a2;
  id v3 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = v2;
    _os_log_impl(&dword_18B299000, v3, OS_LOG_TYPE_DEFAULT, "xpc: failure to obtain XPC proxy object for app clip promotion, %@", (uint8_t *)&v4, 0xCu);
  }
}

void *__loadUIKit_block_invoke()
{
  uint64_t v0 = [MEMORY[0x1E4F28F80] processInfo];
  int v1 = [v0 isMacCatalystApp];

  if (v1) {
    id v2 = "/System/Library/iOSSupport/System/Library/Frameworks/UIKit.framework/UIKit";
  }
  else {
    id v2 = "/System/Library/Frameworks/UIKit.framework/UIKit";
  }
  CFMutableDictionaryRef result = dlopen(v2, 1);
  if (result)
  {
    CFMutableDictionaryRef result = NSClassFromString(&cfstr_Uiapplication.isa);
    kUIApplicationClass = (uint64_t)result;
  }
  return result;
}

void *__loadAuthenticationServices_block_invoke()
{
  uint64_t v0 = [MEMORY[0x1E4F28F80] processInfo];
  int v1 = [v0 isMacCatalystApp];

  if (v1) {
    id v2 = "/System/iOSSupport/System/Library/Frameworks/AuthenticationServices.framework/AuthenticationServices";
  }
  else {
    id v2 = "/System/Library/Frameworks/AuthenticationServices.framework/AuthenticationServices";
  }
  CFMutableDictionaryRef result = dlopen(v2, 1);
  if (result)
  {
    kASAuthorizationControllerClass = (uint64_t)NSClassFromString(&cfstr_Asauthorizatio.isa);
    kASAuthorizationPasswordProviderClass = (uint64_t)NSClassFromString(&cfstr_Asauthorizatio_0.isa);
    CFMutableDictionaryRef result = NSClassFromString(&cfstr_Aspasswordcred.isa);
    kASPasswordCredentialClass = (uint64_t)result;
  }
  return result;
}

uint64_t _SecKeychainCopyOTABackup()
{
  uint64_t v3 = 0;
  int v4 = &v3;
  uint64_t v5 = 0x2000000000;
  unint64_t v6 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 0x40000000;
  activity_block[2] = ___SecKeychainCopyOTABackup_block_invoke;
  activity_block[3] = &unk_1E547F830;
  activity_block[4] = &v3;
  _os_activity_initiate(&dword_18B299000, "_SecKeychainCopyOTABackup", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t client_data_data_BOOL_to_data_error_request(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  v6[2] = __client_data_data_BOOL_to_data_error_request_block_invoke;
  unint64_t v6[3] = &__block_descriptor_tmp_33_10241;
  void v6[4] = a1;
  void v6[5] = a2;
  char v7 = a3;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  _DWORD v5[2] = __client_data_data_BOOL_to_data_error_request_block_invoke_2;
  v5[3] = &unk_1E547FC40;
  void v5[4] = &v8;
  securityd_send_sync_and_do(9u, 0, (uint64_t)v6, (uint64_t)v5);
  uint64_t v3 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t _SecKeychainCopyBackup(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  unint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 0x40000000;
  activity_block[2] = ___SecKeychainCopyBackup_block_invoke;
  activity_block[3] = &unk_1E547F858;
  activity_block[4] = &v5;
  activity_void block[5] = a1;
  activity_block[6] = a2;
  _os_activity_initiate(&dword_18B299000, "_SecKeychainCopyBackup", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t _SecKeychainCopyEMCSBackup(uint64_t a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000;
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = ___SecKeychainCopyEMCSBackup_block_invoke;
  v3[3] = &unk_1E547F880;
  void v3[4] = &v4;
  v3[5] = a1;
  _os_activity_initiate(&dword_18B299000, "_SecKeychainCopyEMCSBackup", OS_ACTIVITY_FLAG_DEFAULT, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t _SecKeychainWriteBackupToFileDescriptor(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  char v11 = 0;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 0x40000000;
  activity_block[2] = ___SecKeychainWriteBackupToFileDescriptor_block_invoke;
  activity_block[3] = &unk_1E547F8F0;
  activity_block[6] = a1;
  void activity_block[7] = a2;
  int v7 = a3;
  activity_block[4] = &v8;
  activity_void block[5] = a4;
  _os_activity_initiate(&dword_18B299000, "_SecKeychainWriteBackupToFile", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v4 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v4;
}

uint64_t _SecKeychainRestoreBackupFromFileDescriptor(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  char v11 = -86;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 0x40000000;
  activity_block[2] = ___SecKeychainRestoreBackupFromFileDescriptor_block_invoke;
  activity_block[3] = &unk_1E547F960;
  int v7 = a1;
  activity_block[6] = a2;
  void activity_block[7] = a3;
  activity_block[4] = &v8;
  activity_void block[5] = a4;
  _os_activity_initiate(&dword_18B299000, "_SecKeychainRestoreBackup", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v4 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v4;
}

uint64_t _SecKeychainCopyKeybagUUIDFromFileDescriptor(int a1, uint64_t a2)
{
  uint64_t v6 = 0;
  int v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 0x40000000;
  activity_block[2] = ___SecKeychainCopyKeybagUUIDFromFileDescriptor_block_invoke;
  activity_block[3] = &unk_1E547F9D0;
  int v5 = a1;
  activity_block[4] = &v6;
  activity_void block[5] = a2;
  _os_activity_initiate(&dword_18B299000, "_SecKeychainCopyKeybagUUID", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v2 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v2;
}

uint64_t _SecKeychainRestoreBackup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  int v7 = &v6;
  uint64_t v8 = 0x2000000000;
  int v9 = -1431655766;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  _DWORD v5[2] = ___SecKeychainRestoreBackup_block_invoke;
  v5[3] = &unk_1E547FA18;
  void v5[4] = &v6;
  void v5[5] = a1;
  void v5[6] = a2;
  v5[7] = a3;
  _os_activity_initiate(&dword_18B299000, "_SecKeychainRestoreBackup", OS_ACTIVITY_FLAG_DEFAULT, v5);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

BOOL __data_client_data_data_to_error_request_block_invoke(CFDataRef *a1, void *a2, __CFString **a3)
{
  BOOL result = SecXPCDictionarySetData(a2, "backup", a1[4], a3);
  if (result)
  {
    BOOL result = SecXPCDictionarySetData(a2, "keybag", a1[5], a3);
    if (result)
    {
      CFDataRef v7 = a1[6];
      if (v7)
      {
        return SecXPCDictionarySetData(a2, "password", v7, a3);
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

CFMutableDataRef SecItemBackupCreateManifest(const __CFDictionary *a1)
{
  if (a1)
  {
    CFIndex Count = CFDictionaryGetCount(a1);
    CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 20 * Count);
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 0x40000000;
    context[2] = __SecItemBackupCreateManifest_block_invoke;
    context[3] = &__block_descriptor_tmp_19_10261;
    void context[4] = Mutable;
    CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)apply_block_2_10263, context);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    CFIndex Length = CFDataGetLength(Mutable);
    qsort(MutableBytePtr, Length / 20, 0x14uLL, (int (__cdecl *)(const void *, const void *))compareDigests);
    return Mutable;
  }
  else
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    return CFDataCreateMutable(v7, 0);
  }
}

void __SecItemBackupCreateManifest_block_invoke(uint64_t a1, int a2, CFTypeRef cf)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFDictionaryGetTypeID())
    {
      CFDataRef Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, @"hash");
      CFDataRef v7 = Value;
      if (Value && (CFTypeID v8 = CFGetTypeID(Value), v8 == CFDataGetTypeID()) && CFDataGetLength(v7) == 20)
      {
        int v9 = *(__CFData **)(a1 + 32);
        BytePtr = CFDataGetBytePtr(v7);
        CFIndex Length = CFDataGetLength(v7);
        CFDataAppendBytes(v9, BytePtr, Length);
      }
      else
      {
        CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFIndex v13 = CFDataGetLength(v7);
        CFMutableDictionaryRef Mutable = CFStringCreateMutable(v12, 2 * v13);
        uint64_t v15 = CFDataGetBytePtr(v7);
        CFIndex v16 = CFDataGetLength(v7);
        if (v16 >= 1)
        {
          CFIndex v17 = v16;
          do
          {
            unsigned int v18 = *v15++;
            CFStringAppendFormat(Mutable, 0, @"%02X", v18);
            --v17;
          }
          while (v17);
        }
        uint64_t v19 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          id v21 = Mutable;
          _os_log_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEFAULT, "bad hash %@ in backup", buf, 0xCu);
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
      }
    }
  }
}

uint64_t compareDigests(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = bswap64(*(void *)a1);
  unint64_t v3 = bswap64(*(void *)a2);
  if (v2 == v3)
  {
    unint64_t v2 = bswap64(*(void *)(a1 + 8));
    unint64_t v3 = bswap64(*(void *)(a2 + 8));
    if (v2 == v3)
    {
      unint64_t v2 = bswap32(*(_DWORD *)(a1 + 16));
      unint64_t v3 = bswap32(*(_DWORD *)(a2 + 16));
      if (v2 == v3) {
        return 0;
      }
    }
  }
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  return 1;
}

uint64_t apply_block_2_10263(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t _SecKeychainBackupSyncable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  _DWORD v5[2] = ___SecKeychainBackupSyncable_block_invoke;
  v5[3] = &__block_descriptor_tmp_20_10273;
  void v5[4] = a4;
  void v5[5] = a3;
  void v5[6] = a1;
  v5[7] = a2;
  return SecOSStatusWith((uint64_t)v5);
}

uint64_t __data_data_dict_to_dict_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef v11 = *(const __CFString **)(a1 + 32);
  if (!v11 || (uint64_t result = SecXPCDictionarySetPListWithRepair(a2, "backup", v11, a3, a5, a6, a7, a8), result))
  {
    uint64_t result = SecXPCDictionarySetData(a2, "keybag", *(CFDataRef *)(a1 + 40), a3);
    if (result)
    {
      CFDataRef v13 = *(const __CFData **)(a1 + 48);
      if (v13)
      {
        return SecXPCDictionarySetData(a2, "password", v13, a3);
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

BOOL __data_data_dict_to_dict_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  uint64_t v4 = SecXPCDictionaryCopyDictionaryAndPossiblyMutateMessage(1, a2, "status", a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
  return v4 != 0;
}

uint64_t _SecKeychainRestoreSyncable(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  CFDataRef v7 = &v6;
  uint64_t v8 = 0x2000000000;
  int v9 = -1431655766;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  _DWORD v5[2] = ___SecKeychainRestoreSyncable_block_invoke;
  v5[3] = &unk_1E547FAA0;
  void v5[4] = &v6;
  void v5[5] = a3;
  void v5[6] = a1;
  v5[7] = a2;
  _os_activity_initiate(&dword_18B299000, "_SecKeychainRestoreSyncable", OS_ACTIVITY_FLAG_DEFAULT, v5);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t __dict_data_data_to_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = SecXPCDictionarySetPListWithRepair(a2, "backup", *(const __CFString **)(a1 + 32), a3, a5, a6, a7, a8);
  if (result)
  {
    uint64_t result = SecXPCDictionarySetData(a2, "keybag", *(CFDataRef *)(a1 + 40), a3);
    if (result)
    {
      CFDataRef v12 = *(const __CFData **)(a1 + 48);
      if (v12)
      {
        return SecXPCDictionarySetData(a2, "password", v12, a3);
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

BOOL SecItemBackupWithRegisteredBackups(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = 0;
  CFStringRef v11 = &v10;
  uint64_t v12 = 0x2000000000;
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  _OWORD v9[2] = __SecItemBackupCopyNames_block_invoke;
  v9[3] = &unk_1E547FCF0;
  void v9[4] = &v10;
  void v9[5] = a1;
  _os_activity_initiate(&dword_18B299000, "SecItemBackupCopyNames", OS_ACTIVITY_FLAG_DEFAULT, v9);
  CFArrayRef v3 = (const __CFArray *)v11[3];
  _Block_object_dispose(&v10, 8);
  if (v3)
  {
    CFIndex Count = CFArrayGetCount(v3);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      for (CFIndex i = 0; i != v5; ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v3, i);
        (*(void (**)(uint64_t, const void *))(a2 + 16))(a2, ValueAtIndex);
      }
    }
    CFRelease(v3);
  }
  return v3 != 0;
}

void __SecItemBackupCopyNames_block_invoke(uint64_t a1)
{
  if (gSecurityd && (unint64_t v2 = *(uint64_t (**)(void))(gSecurityd + 136)) != 0)
  {
    uint64_t v3 = v2(*(void *)(a1 + 40));
  }
  else
  {
    uint64_t v4 = *(CFTypeRef **)(a1 + 40);
    uint64_t v6 = 0;
    CFDataRef v7 = &v6;
    uint64_t v8 = 0x2000000000;
    uint64_t v9 = 0;
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    _DWORD v5[2] = __to_array_error_request_block_invoke_2;
    v5[3] = &unk_1E547FD38;
    void v5[4] = &v6;
    securityd_send_sync_and_do(0xDu, v4, (uint64_t)&__block_literal_global_10283, (uint64_t)v5);
    uint64_t v3 = v7[3];
    _Block_object_dispose(&v6, 8);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v3;
}

BOOL __to_array_error_request_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  uint64_t v4 = SecXPCDictionaryCopyArray(xdict, "status", a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
  return v4 != 0;
}

uint64_t __to_array_error_request_block_invoke()
{
  return 1;
}

BOOL SecItemBackupWithRegisteredViewBackup(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecItemBackupViewAndCopyBackupPeerID_block_invoke;
  activity_block[3] = &unk_1E547FD60;
  activity_block[4] = &v5;
  activity_void block[5] = a1;
  void activity_block[6] = a2;
  _os_activity_initiate(&dword_18B299000, "SecItemBackupViewAndCopyBackupPeerID", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  unint64_t v2 = (const void *)v6[3];
  _Block_object_dispose(&v5, 8);
  if (v2) {
    CFRelease(v2);
  }
  return v2 != 0;
}

void __SecItemBackupViewAndCopyBackupPeerID_block_invoke(void *a1)
{
  if (gSecurityd && (unint64_t v2 = *(uint64_t (**)(void, void))(gSecurityd + 144)) != 0)
  {
    uint64_t v3 = v2(a1[5], a1[6]);
  }
  else
  {
    uint64_t v5 = a1[5];
    uint64_t v4 = (CFTypeRef *)a1[6];
    uint64_t v8 = 0;
    uint64_t v9 = &v8;
    uint64_t v10 = 0x2000000000;
    uint64_t v11 = 0;
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    _DWORD v7[2] = __string_to_string_error_request_block_invoke;
    unint64_t v7[3] = &__block_descriptor_tmp_46_10288;
    void v7[4] = v5;
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __string_to_string_error_request_block_invoke_2;
    unint64_t v6[3] = &unk_1E547FDA8;
    void v6[4] = &v8;
    securityd_send_sync_and_do(0xEu, v4, (uint64_t)v7, (uint64_t)v6);
    uint64_t v3 = v9[3];
    _Block_object_dispose(&v8, 8);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = v3;
}

BOOL __string_to_string_error_request_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  return SecXPCDictionarySetString(a2, (uint64_t)"cfstring", *(const __CFString **)(a1 + 32), a3);
}

BOOL __string_to_string_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  CFStringRef v4 = SecXPCDictionaryCopyString(a2, a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
  return v4 != 0;
}

uint64_t SecItemBackupWithChanges(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t v58 = 0;
  CFDictionaryRef v59 = &v58;
  uint64_t v60 = 0x2000000000;
  char v61 = 1;
  uint64_t v54 = 0;
  unint64_t v55 = &v54;
  uint64_t v56 = 0x2000000000;
  __darwin_ino64_t v57 = 0;
  v48[0] = MEMORY[0x1E4F143A8];
  v48[1] = 0x40000000;
  long long v49 = __SecItemBackupWithChanges_block_invoke;
  uint64_t v50 = &unk_1E547FAC8;
  unint64_t v52 = &v58;
  CFRange v53 = &v54;
  uint64_t v51 = a3;
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x2000000000;
  *(_DWORD *)&buf[24] = -1;
  *(void *)&activity_block.st_dev = MEMORY[0x1E4F143A8];
  activity_block.st_ino = 0x40000000;
  *(void *)&activity_block.st_uid = __SecItemBackupHandoffFD_block_invoke;
  *(void *)&activity_block.st_rdev = &unk_1E547FDD0;
  activity_block.st_atimespec.tv_sec = (__darwin_time_t)buf;
  activity_block.st_atimespec.tv_nsec = a1;
  activity_block.st_mtimespec.tv_sec = (__darwin_time_t)&v57;
  _os_activity_initiate(&dword_18B299000, "SecItemBackupHandoffFD", OS_ACTIVITY_FLAG_DEFAULT, &activity_block);
  int v6 = *(_DWORD *)(*(void *)&buf[8] + 24);
  _Block_object_dispose(buf, 8);
  if (v6 < 0)
  {
    id v14 = secLogObjForScope("backup");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      activity_block.st_dev = 67109378;
      *(_DWORD *)&activity_block.st_mode = v6;
      LOWORD(activity_block.st_ino) = 2112;
      *(__darwin_ino64_t *)((char *)&activity_block.st_ino + 2) = v57;
      _os_log_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEFAULT, "SecItemBackupHandoffFD returned %d: %@", (uint8_t *)&activity_block, 0x12u);
    }
    goto LABEL_7;
  }
  uint64_t v7 = lseek(v6, 0, 0);
  if (v7)
  {
    CFStringRef v13 = @"lseek";
    goto LABEL_4;
  }
  CFIndex v16 = fdopen(v6, "r");
  if (!v16)
  {
    uint64_t v31 = secLogObjForScope("backup");
    BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
    if (v32)
    {
      int v38 = *__error();
      activity_block.st_dev = 138412546;
      *(void *)&activity_block.st_mode = a1;
      WORD2(activity_block.st_ino) = 1024;
      *(_DWORD *)((char *)&activity_block.st_ino + 6) = v38;
      _os_log_impl(&dword_18B299000, v31, OS_LOG_TYPE_DEFAULT, "Receiving file for %@ failed, %d", (uint8_t *)&activity_block, 0x12u);
    }
    SecCheckErrno(v32, (CFTypeRef *)&v57, @"fdopen", v33, v34, v35, v36, v37, v47);
    if (!close(v6)) {
      goto LABEL_7;
    }
    uint64_t v39 = secLogObjForScope("backup");
    uint64_t v7 = os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
    if (v7)
    {
      int v40 = *__error();
      activity_block.st_dev = 138412546;
      *(void *)&activity_block.st_mode = a1;
      WORD2(activity_block.st_ino) = 1024;
      *(_DWORD *)((char *)&activity_block.st_ino + 6) = v40;
      _os_log_impl(&dword_18B299000, v39, OS_LOG_TYPE_DEFAULT, "Encountered error closing file %@: %d", (uint8_t *)&activity_block, 0x12u);
    }
    CFStringRef v13 = @"close";
    goto LABEL_4;
  }
  CFIndex v17 = v16;
  v18.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v18.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&activity_block.st_blksize_t size = v18;
  *(timespec *)activity_block.st_qspare = v18;
  activity_block.st_birthtimespec = v18;
  *(timespec *)&activity_block.st_size_t size = v18;
  activity_block.st_mtimespec = v18;
  activity_block.st_ctimespec = v18;
  *(timespec *)&activity_block.st_uid = v18;
  activity_block.st_atimespec = v18;
  *(timespec *)&activity_block.st_dev = v18;
  int v19 = fstat(v6, &activity_block);
  int v20 = secLogObjForScope("backup");
  BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
  if (v19)
  {
    if (v21)
    {
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v6;
      _os_log_impl(&dword_18B299000, v20, OS_LOG_TYPE_DEFAULT, "Unable to get file metadata for %@, fd %d", buf, 0x12u);
    }
    SecCheckErrno(v21, (CFTypeRef *)&v57, @"fstat", v22, v23, v24, v25, v26, v47);
    if (!fclose(v17)) {
      goto LABEL_7;
    }
    id v27 = secLogObjForScope("backup");
    uint64_t v7 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
    if (v7)
    {
      int v28 = *__error();
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v28;
      _os_log_impl(&dword_18B299000, v27, OS_LOG_TYPE_DEFAULT, "Encountered error closing file %@: %d", buf, 0x12u);
    }
    CFStringRef v13 = @"fclose";
LABEL_4:
    SecCheckErrno(v7, (CFTypeRef *)&v57, v13, v8, v9, v10, v11, v12, v47);
LABEL_7:
    *((unsigned char *)v59 + 24) = 0;
LABEL_8:
    (*(void (**)(uint64_t, uint64_t, void, void))(a3 + 16))(a3, 3, 0, 0);
    uint64_t v15 = (const void *)v55[3];
    if (v15)
    {
      if (a2 && !*a2) {
        *a2 = v15;
      }
      else {
        CFRelease(v15);
      }
    }
    goto LABEL_21;
  }
  if (v21)
  {
    *(_DWORD *)long long buf = 138412802;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v6;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = activity_block.st_size;
    _os_log_impl(&dword_18B299000, v20, OS_LOG_TYPE_DEFAULT, "Receiving file for %@ with fd %d of size %llu", buf, 0x1Cu);
  }
  v49((uint64_t)v48, v17);
  uint64_t v41 = fclose(v17);
  if (v41) {
    SecCheckErrno(v41, (CFTypeRef *)&v57, @"fclose", v42, v43, v44, v45, v46, v47);
  }
  if (!*((unsigned char *)v59 + 24)) {
    goto LABEL_8;
  }
LABEL_21:
  uint64_t v29 = *((unsigned __int8 *)v59 + 24);
  _Block_object_dispose(&v54, 8);
  _Block_object_dispose(&v58, 8);
  return v29;
}

void __SecItemBackupWithChanges_block_invoke(uint64_t a1, FILE *a2)
{
  uint64_t v37 = (__CFString **)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  uint64_t v3 = (unsigned __int8 *)malloc_type_malloc(0x10uLL, 0xB6ACB77DuLL);
  size_t v4 = 0;
  char v5 = 1;
  unint64_t v6 = 16;
  while (1)
  {
    size_t v7 = fread(&v3[v4], 1uLL, 16 - v4, a2);
    if (!v7) {
      break;
    }
    size_t v8 = v7 + v4;
    uint64_t v9 = &v3[v7 + v4];
    uint64_t v10 = (unsigned __int8 *)ccder_decode_tag();
    if (v10) {
      BOOL v11 = v10 >= v9;
    }
    else {
      BOOL v11 = 1;
    }
    if (v11)
    {
LABEL_29:
      BOOL v34 = SecError(-26275, v37, @"failed to decode backup event header");
      goto LABEL_30;
    }
    uint64_t v12 = v10 + 1;
    unint64_t v13 = *v10;
    if ((char)*v10 < 0)
    {
      if (v13 == 131)
      {
        if (v9 - v12 < 3) {
          goto LABEL_29;
        }
        uint64_t v12 = v10 + 4;
        unint64_t v13 = ((unint64_t)v10[1] << 16) | ((unint64_t)v10[2] << 8) | v10[3];
      }
      else if (v13 == 130)
      {
        if (v9 - v12 < 2) {
          goto LABEL_29;
        }
        uint64_t v12 = v10 + 3;
        unint64_t v13 = __rev16(*(unsigned __int16 *)(v10 + 1));
      }
      else
      {
        if (v13 != 129 || v9 - v12 < 1) {
          goto LABEL_29;
        }
        uint64_t v12 = v10 + 2;
        unint64_t v13 = v10[1];
      }
    }
    int64_t v14 = v12 - v3;
    unint64_t v15 = v14 + v13;
    size_t v16 = v14 + v13 - v8;
    if (v14 + v13 > v8)
    {
      if (v6 >= v15)
      {
        CFIndex v17 = (char *)v3;
      }
      else
      {
        CFIndex v17 = (char *)malloc_type_realloc(v3, v14 + v13, 0x35468961uLL);
        unint64_t v6 = v15;
        if (!v17)
        {
          BOOL v34 = SecError(-108, v37, @"realloc buf failed");
LABEL_30:
          char v5 = v34;
          goto LABEL_37;
        }
      }
      size_t v18 = fread(&v17[v8], 1uLL, v16, a2);
      if (v18 < v16)
      {
        size_t v27 = v18;
        uint64_t v28 = feof(a2);
        if (v28)
        {
          char v5 = SecError(-26275, v37, @"unexpected end of event file %zu of %zu bytes read", v27, v16);
        }
        else
        {
          SecCheckErrno(v28, (CFTypeRef *)v37, @"failed to read event body", v29, v30, v31, v32, v33, v35);
          char v5 = 0;
        }
        uint64_t v3 = (unsigned __int8 *)v17;
        goto LABEL_37;
      }
      uint64_t v3 = (unsigned __int8 *)v17;
    }
    int v19 = (char *)&v3[v15];
    ccder_decode_tag();
    BOOL v20 = SecError(-26275, v37, @"unsupported event tag: %lu", 0xAAAAAAAAAAAAAAAALL);
    if (v15 >= v8)
    {
      size_t v4 = 0;
    }
    else
    {
      size_t v4 = v8 - v15;
      memmove(v3, v19, v4);
    }
    v5 &= v20;
  }
  uint64_t v21 = feof(a2);
  if (!v21)
  {
    SecCheckErrno(v21, (CFTypeRef *)v37, @"read backup event header", v22, v23, v24, v25, v26, v35);
    char v5 = 0;
  }
LABEL_37:
  free(v3);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v5 & (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8)
                                                                              + 24) != 0);
}

void __SecItemBackupHandoffFD_block_invoke(void *a1)
{
  if (gSecurityd && (unint64_t v2 = *(uint64_t (**)(void, void))(gSecurityd + 152)) != 0)
  {
    int v3 = v2(a1[5], a1[6]);
  }
  else
  {
    uint64_t v5 = a1[5];
    size_t v4 = (CFTypeRef *)a1[6];
    uint64_t v8 = 0;
    uint64_t v9 = &v8;
    uint64_t v10 = 0x2000000000;
    int v11 = -1;
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    _DWORD v7[2] = __string_to_fd_error_request_block_invoke;
    unint64_t v7[3] = &__block_descriptor_tmp_66_10316;
    void v7[4] = v5;
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __string_to_fd_error_request_block_invoke_2;
    unint64_t v6[3] = &unk_1E547FE18;
    void v6[4] = &v8;
    securityd_send_sync_and_do(0xFu, v4, (uint64_t)v7, (uint64_t)v6);
    int v3 = *((_DWORD *)v9 + 6);
    _Block_object_dispose(&v8, 8);
  }
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = v3;
}

BOOL __string_to_fd_error_request_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  return SecXPCDictionarySetString(a2, (uint64_t)"backup", *(const __CFString **)(a1 + 32), a3);
}

uint64_t __string_to_fd_error_request_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  int v5 = xpc_dictionary_dup_fd(xdict, "status");
  if (v5 < 0) {
    SecError(-50, a3, @"missing fd for key %s", "status");
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
  return 1;
}

uint64_t SecItemBackupSetConfirmedManifest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  char v10 = -86;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecItemBackupSetConfirmedManifest_block_invoke;
  activity_block[3] = &unk_1E547FAF0;
  activity_block[4] = &v7;
  activity_void block[5] = a1;
  void activity_block[6] = a2;
  void activity_block[7] = a3;
  void activity_block[8] = a4;
  _os_activity_initiate(&dword_18B299000, "SecItemBackupSetConfirmedManifest", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t __SecItemBackupSetConfirmedManifest_block_invoke(void *a1)
{
  if (gSecurityd && (unint64_t v2 = *(uint64_t (**)(void, void, void, void))(gSecurityd + 160)) != 0)
  {
    uint64_t result = v2(a1[5], a1[6], a1[7], a1[8]);
  }
  else
  {
    uint64_t v5 = a1[7];
    uint64_t v4 = (CFTypeRef *)a1[8];
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __string_data_data_to_BOOL_error_request_block_invoke;
    unint64_t v6[3] = &__block_descriptor_tmp_104_10357;
    long long v7 = *(_OWORD *)(a1 + 5);
    uint64_t v8 = v5;
    uint64_t result = securityd_send_sync_and_do(0x10u, v4, (uint64_t)v6, (uint64_t)&__block_literal_global_107);
  }
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

void SecItemBackupRestore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = 0;
  char v10 = &v9;
  uint64_t v11 = 0x2000000000;
  uint64_t v12 = 0;
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  _DWORD v8[2] = __SecItemBackupRestore_block_invoke;
  unint64_t v8[3] = &unk_1E547FB18;
  v8[6] = a2;
  void v8[7] = a3;
  v8[8] = a4;
  v8[9] = a5;
  v8[4] = &v9;
  void v8[5] = a1;
  _os_activity_initiate(&dword_18B299000, "SecItemBackupRestore", OS_ACTIVITY_FLAG_DEFAULT, v8);
  (*(void (**)(uint64_t, uint64_t))(a6 + 16))(a6, v10[3]);
  long long v7 = (const void *)v10[3];
  if (v7) {
    CFRelease(v7);
  }
  _Block_object_dispose(&v9, 8);
}

uint64_t __SecItemBackupRestore_block_invoke(void *a1)
{
  if (gSecurityd
    && (uint64_t v1 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(gSecurityd + 168)) != 0)
  {
    uint64_t v2 = a1[6];
    uint64_t v3 = a1[7];
    uint64_t v4 = a1[8];
    uint64_t v5 = a1[9];
    uint64_t v6 = *(void *)(a1[4] + 8) + 24;
    uint64_t v7 = a1[5];
    return v1(v7, v2, v3, v4, v5, v6);
  }
  else
  {
    uint64_t v9 = a1[9];
    char v10 = (CFTypeRef *)(*(void *)(a1[4] + 8) + 24);
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 0x40000000;
    void v12[2] = __string_string_data_data_data_to_BOOL_error_request_block_invoke;
    v12[3] = &__block_descriptor_tmp_108_10360;
    long long v11 = *(_OWORD *)(a1 + 7);
    long long v13 = *(_OWORD *)(a1 + 5);
    long long v14 = v11;
    uint64_t v15 = v9;
    return securityd_send_sync_and_do(0x11u, v10, (uint64_t)v12, (uint64_t)&__block_literal_global_111);
  }
}

uint64_t SecBackupKeybagAdd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  char v10 = 0;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecBackupKeybagAdd_block_invoke;
  activity_block[3] = &unk_1E547FB88;
  activity_block[4] = &v7;
  activity_void block[5] = a4;
  void activity_block[6] = a1;
  void activity_block[7] = a2;
  void activity_block[8] = a3;
  _os_activity_initiate(&dword_18B299000, "_SecServerBackupKeybagAdd", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t __SecBackupKeybagAdd_block_invoke(uint64_t a1)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  _DWORD v5[2] = __SecBackupKeybagAdd_block_invoke_2;
  v5[3] = &__block_descriptor_tmp_27_10364;
  uint64_t v1 = *(CFTypeRef **)(a1 + 40);
  void v5[4] = *(void *)(a1 + 48);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = __SecBackupKeybagAdd_block_invoke_3;
  v3[3] = &unk_1E547FB60;
  void v3[4] = *(void *)(a1 + 32);
  long long v4 = *(_OWORD *)(a1 + 56);
  return securityd_send_sync_and_do(0x6Fu, v1, (uint64_t)v5, (uint64_t)v3);
}

BOOL __SecBackupKeybagAdd_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  CFDataRef v4 = *(const __CFData **)(a1 + 32);
  return !v4 || SecXPCDictionarySetData(a2, "password", v4, a3);
}

uint64_t __SecBackupKeybagAdd_block_invoke_3(void *a1, xpc_object_t xdict, __CFString **a3)
{
  uint64_t v6 = (CFDataRef *)a1[5];
  size_t length = 0;
  if (xpc_dictionary_get_data(xdict, "backupKeybagID", &length))
  {
    CFDataRef v7 = SecXPCDictionaryCopyData(xdict, "backupKeybagID", a3);
    *uint64_t v6 = v7;
    if (!v7) {
      goto LABEL_12;
    }
  }
  else
  {
    *uint64_t v6 = 0;
  }
  uint64_t v8 = (CFURLRef *)a1[6];
  size_t length = 0;
  if (!xpc_dictionary_get_data(xdict, "backupKeybagPath", &length))
  {
    *uint64_t v8 = 0;
LABEL_11:
    LOBYTE(v7) = xpc_dictionary_get_BOOL(xdict, "status");
    goto LABEL_12;
  }
  CFDataRef v9 = SecXPCDictionaryCopyData(xdict, "backupKeybagPath", a3);
  if (v9)
  {
    CFDataRef v10 = v9;
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    BytePtr = CFDataGetBytePtr(v9);
    CFIndex v13 = CFDataGetLength(v10);
    *uint64_t v8 = CFURLCreateWithBytes(v11, BytePtr, v13, 0x8000100u, 0);
    CFRelease(v10);
  }
  if (*v8) {
    goto LABEL_11;
  }
  LOBYTE(v7) = 0;
LABEL_12:
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = (_BYTE)v7;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t SecBackupKeybagDelete(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  char v8 = 0;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecBackupKeybagDelete_block_invoke;
  activity_block[3] = &unk_1E547FBF8;
  activity_void block[5] = a2;
  void activity_block[6] = a1;
  activity_block[4] = &v5;
  _os_activity_initiate(&dword_18B299000, "_SecBackupKeybagDelete", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecBackupKeybagDelete_block_invoke(void *a1)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  void v4[2] = __SecBackupKeybagDelete_block_invoke_2;
  v4[3] = &__block_descriptor_tmp_30_10368;
  uint64_t v1 = (CFTypeRef *)a1[5];
  v4[4] = a1[6];
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = __SecBackupKeybagDelete_block_invoke_3;
  v3[3] = &unk_1E547FBD0;
  void v3[4] = a1[4];
  return securityd_send_sync_and_do(0x70u, v1, (uint64_t)v4, (uint64_t)v3);
}

size_t __SecBackupKeybagDelete_block_invoke_2(uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return SecXPCDictionarySetPListWithRepair(a2, "query", *(const __CFString **)(a1 + 32), a3, a5, a6, a7, a8);
}

uint64_t __SecBackupKeybagDelete_block_invoke_3(uint64_t a1, xpc_object_t xdict)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = xpc_dictionary_get_BOOL(xdict, "status");
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

__CFData *SecKeyCopyPublicKeyHash(const void *a1)
{
  CFDataRef theData = 0;
  int v2 = SecKeyCopyPublicBytes((uint64_t)a1, (uint64_t)&theData);
  uint64_t v3 = 0;
  CFDataRef v4 = theData;
  if (!v2 && theData)
  {
    CFAllocatorRef v5 = CFGetAllocator(a1);
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
    uint64_t v3 = SecSHA1DigestCreate(v5, (uint64_t)BytePtr, Length);
    CFDataRef v4 = theData;
  }
  if (v4)
  {
    CFDataRef theData = 0;
    CFRelease(v4);
  }
  return v3;
}

id _SECKEY_LOG_10970()
{
  if (_SECKEY_LOG_once_10975 != -1) {
    dispatch_once(&_SECKEY_LOG_once_10975, &__block_literal_global_10976);
  }
  uint64_t v0 = (void *)_SECKEY_LOG_log_10977;

  return v0;
}

CFDictionaryRef SecKeyGeneratePublicAttributeDictionary(const void *a1, uint64_t a2)
{
  return SecKeyCopyAttributeDictionaryWithLocalKey(a1, a2, 0);
}

CFStringRef SecKeyCopyDescription(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 96);
  if (!v1) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<SecKeyRef: %p>", a1);
  }

  return (CFStringRef)v1();
}

uint64_t SecKeyEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  if (!a2) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3 != *(void *)(a2 + 16)) {
    return 0;
  }
  if (*(_DWORD *)v3 >= 4u && (CFAllocatorRef v5 = *(uint64_t (**)(void))(v3 + 160)) != 0)
  {
    return v5();
  }
  else
  {
    size_t v6 = *(unsigned int *)(v3 + 16);
    if (v6)
    {
      return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), v6) == 0;
    }
    else
    {
      CFDictionaryRef v7 = SecKeyCopyAttributes((SecKeyRef)a1);
      CFDictionaryRef v8 = SecKeyCopyAttributes((SecKeyRef)a2);
      CFDictionaryRef v9 = v8;
      if (!v7 || !v8)
      {
        if (v7) {
          CFRelease(v7);
        }
        if (v9) {
          CFRelease(v9);
        }
        return 0;
      }
      uint64_t v10 = CFEqual(v7, v8);
      CFRelease(v7);
      CFRelease(v9);
      return v10;
    }
  }
}

OSStatus SecKeyGeneratePair(CFDictionaryRef parameters, SecKeyRef *publicKey, SecKeyRef *privateKey)
{
  CFErrorRef error = 0;
  SecKeyRef v5 = SecKeyCreateRandomKey(parameters, &error);
  size_t v6 = v5;
  if (v5)
  {
    if (privateKey) {
      *privateKey = v5;
    }
    OSStatus Code = 0;
    if (publicKey) {
      *publicKey = SecKeyCopyPublicKey(v6);
    }
  }
  else
  {
    OSStatus Code = CFErrorGetCode(error);
    if (error) {
      CFRelease(error);
    }
  }

  return Code;
}

SecKeyRef SecKeyCreateRandomKey(CFDictionaryRef parameters, CFErrorRef *error)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  long long context = (void *)MEMORY[0x18C12E850]();
  CFDataRef v4 = _os_activity_create(&dword_18B299000, "SecKeyCreateRandomKey", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &state);
  SecKeyRef key = 0;
  int v40 = 0;
  CFTypeRef cf = 0;
  SecKeyRef v5 = merge_params(parameters, @"public");
  CFDictionaryRef v6 = merge_params(parameters, @"private");
  CFDataRef Value = CFDictionaryGetValue(parameters, @"type");
  if (CFDictionaryGetValue(parameters, @"tkid"))
  {
    CFDictionaryRef v8 = (void *)[(__CFDictionary *)parameters mutableCopy];
    uint64_t v9 = [v8 objectForKeyedSubscript:@"private"];
    uint64_t v10 = (void *)v9;
    CFAllocatorRef v11 = (void *)MEMORY[0x1E4F1CC08];
    if (v9) {
      CFAllocatorRef v11 = (void *)v9;
    }
    id v12 = v11;

    [v8 removeObjectForKey:@"private"];
    [v8 removeObjectForKey:@"public"];
    CFIndex v13 = (void *)[v12 mutableCopy];
    [v13 addEntriesFromDictionary:v8];
    long long v14 = [SecCTKKey alloc];
    *(void *)long long buf = 0;
    uint64_t v15 = [(SecCTKKey *)v14 initWithAttributes:v13 error:buf];
    id v16 = *(id *)buf;
    CFIndex v17 = v16;
    if (v15)
    {
      size_t v18 = (__SecKey *)SecKeyCreate(*MEMORY[0x1E4F1CF80], (uint64_t)&kSecCTKKeyDescriptor, 0, 0, 0);
      *((void *)v18 + 3) = v15;
    }
    else
    {
      size_t v18 = 0;
      int v40 = (__CFString *)v16;
    }

    SecKeyRef key = v18;
    int OSStatus = SecErrorGetOSStatus((uint64_t)v40);
    SecError(OSStatus, &v40, @"Failed to generate keypair", contexta);
    goto LABEL_15;
  }
  if (!Value) {
    goto LABEL_48;
  }
  if (CFEqual(Value, @"73"))
  {
    int v19 = SecECKeyGeneratePair((uint64_t)parameters, &cf, &key);
    goto LABEL_9;
  }
  if (!CFEqual(Value, @"42"))
  {
    if (CFEqual(Value, @"105"))
    {
      uint64_t v31 = 4;
LABEL_40:
      int v19 = curve25519KeyGeneratePair((uint64_t)parameters, &cf, &key, v31);
      goto LABEL_9;
    }
    if (CFEqual(Value, @"106"))
    {
      uint64_t v31 = 5;
      goto LABEL_40;
    }
    if (CFEqual(Value, @"107"))
    {
      uint64_t v33 = 6;
LABEL_45:
      int v19 = curve448KeyGeneratePair((uint64_t)parameters, &cf, &key, v33);
      goto LABEL_9;
    }
    if (CFEqual(Value, @"108"))
    {
      uint64_t v33 = 7;
      goto LABEL_45;
    }
    if (CFEqual(Value, @"109"))
    {
      int v19 = SecKyberKeyGeneratePair(parameters, &cf, &key);
LABEL_9:
      int v20 = v19;
      if (!v19) {
        goto LABEL_16;
      }
      goto LABEL_10;
    }
LABEL_48:
    SecError(-50, (__CFString **)error, @"incorrect or missing kSecAttrKeyType in key generation request", context);
LABEL_15:
    int v20 = 0;
    goto LABEL_16;
  }
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  uint64_t v27 = SecCFAllocatorZeroize_sAllocator;
  uint64_t v28 = (__SecKey *)SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)&kSecRSAPrivateKeyDescriptor, (uint64_t)parameters, 0, 5);
  if (v28)
  {
    uint64_t v29 = v28;
    uint64_t v30 = SecKeyCreate(v27, (uint64_t)&kSecRSAPublicKeyDescriptor, *((void *)v28 + 3), 0, 6);
    if (v30)
    {
      int v20 = 0;
      CFTypeRef cf = v30;
      SecKeyRef key = v29;
      goto LABEL_17;
    }
    CFRelease(v29);
  }
  int v20 = -50;
LABEL_10:
  uint64_t v21 = _SECKEY_LOG_10970();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    uint64_t v32 = CFDictionaryGetValue(parameters, @"bsiz");
    *(_DWORD *)long long buf = 138543874;
    *(void *)&uint8_t buf[4] = Value;
    __int16 v43 = 2114;
    uint64_t v44 = v32;
    __int16 v45 = 1024;
    int v46 = v20;
    _os_log_error_impl(&dword_18B299000, v21, OS_LOG_TYPE_ERROR, "Failed to generate software key %{public}@:%{public}@, error: %d", buf, 0x1Cu);
  }

LABEL_16:
  if (!key) {
    goto LABEL_23;
  }
LABEL_17:
  if (getBoolForKey(v5, 0))
  {
    CFDictionaryRemoveValue(v5, @"tkid");
    uint64_t v23 = (void *)cf;
    if (!cf)
    {
      uint64_t v23 = SecKeyCopyPublicKey(key);
      CFTypeRef cf = v23;
    }
    if (!add_key(v23, v5, &v40))
    {
      SecKeyRef v34 = key;
      if (!key) {
        goto LABEL_23;
      }
      goto LABEL_50;
    }
  }
  BOOL v24 = CFDictionaryContainsKey(v6, @"tkid") != 0;
  if (getBoolForKey(v6, v24) && !add_key(key, v6, &v40))
  {
    SecKeyRef v34 = key;
    if (key)
    {
LABEL_50:
      SecKeyRef key = 0;
      CFRelease(v34);
    }
  }
LABEL_23:
  SecError(v20, &v40, @"failed to generate key", context);
  _SecKeyErrorPropagate(key != 0, (uint64_t)"SecKeyCreateRandomKey", v40, error);
  if (v5) {
    CFRelease(v5);
  }
  if (v6) {
    CFRelease(v6);
  }
  if (cf) {
    CFRelease(cf);
  }
  uint64_t v25 = key;
  os_activity_scope_leave(&state);

  return v25;
}

void sub_18B399580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_activity_scope_state_s state)
{
}

SecKeyRef SecKeyCopyPublicKey(SecKeyRef key)
{
  int v2 = (void *)MEMORY[0x18C12E850]();
  uint64_t v3 = _os_activity_create(&dword_18B299000, "SecKeyCopyPublicKey", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v3, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyCopyPublicKey");
  uint64_t v4 = *((void *)key + 2);
  if (*(_DWORD *)v4 < 4u
    || (SecKeyRef v5 = *(uint64_t (**)(SecKeyRef))(v4 + 144)) == 0
    || (CFDictionaryRef v6 = (__SecKey *)v5(key)) == 0)
  {
    CFTypeRef cf = 0;
    int v7 = SecKeyCopyPublicBytes((uint64_t)key, (uint64_t)&cf);
    CFDictionaryRef v6 = 0;
    CFTypeRef v8 = cf;
    if (!v7 && cf)
    {
      if (SecCFAllocatorZeroize_sOnce != -1) {
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
      }
      uint64_t v9 = SecCFAllocatorZeroize_sAllocator;
      uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)key);
      CFDictionaryRef v6 = (__SecKey *)SecKeyCreateFromPublicData(v9, AlgorithmId, (CFDataRef)cf);
      CFTypeRef v8 = cf;
    }
    if (v8) {
      CFRelease(v8);
    }
  }
  os_activity_scope_leave(&state);

  return v6;
}

void sub_18B3996FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
}

void *SecKeyCreateFromPublicData(uint64_t a1, uint64_t a2, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);

  return SecKeyCreateFromPublicBytes(a1, a2, (uint64_t)BytePtr, Length);
}

void *SecKeyCreateFromPublicBytes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  switch(a2)
  {
    case 1:
      uint64_t v4 = &kSecRSAPublicKeyDescriptor;
      goto LABEL_11;
    case 3:
      uint64_t v4 = &kSecECPublicKeyDescriptor;
      goto LABEL_11;
    case 4:
      uint64_t v4 = &kSecEd25519PublicKeyDescriptor;
      goto LABEL_11;
    case 5:
      uint64_t v4 = &kSecX25519PublicKeyDescriptor;
      goto LABEL_11;
    case 6:
      uint64_t v4 = &kSecEd448PublicKeyDescriptor;
      goto LABEL_11;
    case 7:
      uint64_t v4 = &kSecX448PublicKeyDescriptor;
LABEL_11:
      uint64_t v6 = 7;
      goto LABEL_9;
    case 8:
      uint64_t v4 = &kSecKyberPublicKeyDescriptor;
      uint64_t v6 = 0;
LABEL_9:
      uint64_t result = SecKeyCreate(a1, (uint64_t)v4, a3, a4, v6);
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

CFMutableDictionaryRef merge_params(const __CFDictionary *a1, const void *a2)
{
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
    CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)merge_params_applier, MutableCopy);
  }
  else
  {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a1);
  }
  CFDictionaryRemoveValue(MutableCopy, @"public");
  CFDictionaryRemoveValue(MutableCopy, @"private");
  CFDictionaryRemoveValue(MutableCopy, @"type");
  CFDictionaryRemoveValue(MutableCopy, @"bsiz");
  return MutableCopy;
}

BOOL getBoolForKey(const __CFDictionary *a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a1, @"perm");
  if (Value)
  {
    CFBooleanRef v4 = Value;
    CFTypeID v5 = CFGetTypeID(Value);
    if (v5 == CFBooleanGetTypeID())
    {
      return CFBooleanGetValue(v4) != 0;
    }
    else
    {
      uint64_t v6 = _SECKEY_LOG_10970();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        int v8 = 138543618;
        CFBooleanRef v9 = v4;
        __int16 v10 = 2114;
        CFAllocatorRef v11 = @"perm";
        _os_log_error_impl(&dword_18B299000, v6, OS_LOG_TYPE_ERROR, "Value %{public}@ for key %{public}@ is not BOOL", (uint8_t *)&v8, 0x16u);
      }
    }
  }
  return a2;
}

BOOL add_key(void *value, CFMutableDictionaryRef theDict, __CFString **a3)
{
  CFDictionarySetValue(theDict, @"v_Ref", value);
  CFDictionaryRef v6 = SecKeyCopyAttributes((SecKeyRef)value);
  if (v6)
  {
    CFDictionaryRef v7 = v6;
    if (CFDictionaryContainsKey(v6, @"accc")) {
      CFDictionaryRemoveValue(theDict, @"accc");
    }
    CFRelease(v7);
  }
  CFDictionaryRemoveValue(theDict, @"applepay");
  CFDictionaryRemoveValue(theDict, @"osbound");
  CFDictionaryRemoveValue(theDict, @"sealedhashesbound");
  OSStatus v8 = SecItemAdd(theDict, 0);
  return SecError(v8, a3, @"failed to add key to keychain: %@", value);
}

void merge_params_applier(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

CFDictionaryRef CreatePrivateKeyMatchingQuery(const void *a1)
{
  uint64_t v1 = SecKeyCopyPublicKeyHash(a1);
  CFDictionaryRef v9 = CFDictionaryCreateForCFTypes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2, v3, v4, v5, v6, v7, v8, @"class", @"keys");
  if (v1) {
    CFRelease(v1);
  }
  return v9;
}

CFTypeRef SecKeyCreatePersistentRefToMatchingPrivateKey(const void *a1, __CFString **a2)
{
  CFTypeRef result = 0;
  CFDictionaryRef PrivateKeyMatchingQuery = CreatePrivateKeyMatchingQuery(a1);
  OSStatus v5 = SecItemCopyMatching(PrivateKeyMatchingQuery, &result);
  SecError(v5, a2, @"Error finding persistent ref to key from public: %@", a1);
  if (PrivateKeyMatchingQuery) {
    CFRelease(PrivateKeyMatchingQuery);
  }
  return result;
}

CFTypeRef SecKeyCopyMatchingPrivateKey(const void *a1, __CFString **a2)
{
  CFTypeRef result = 0;
  if (!a1)
  {
    SecError(-50, a2, @"Null Public Key");
    return 0;
  }
  CFDictionaryRef PrivateKeyMatchingQuery = CreatePrivateKeyMatchingQuery(a1);
  OSStatus v5 = SecItemCopyMatching(PrivateKeyMatchingQuery, &result);
  if (!SecError(v5, a2, @"Error finding private key from public: %@", a1)
    || (CFTypeID v6 = CFGetTypeID(result), v6 != SecKeyGetTypeID()))
  {
    CFTypeRef v7 = 0;
    if (!PrivateKeyMatchingQuery) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  CFTypeRef v7 = result;
  CFTypeRef result = 0;
  if (PrivateKeyMatchingQuery) {
LABEL_7:
  }
    CFRelease(PrivateKeyMatchingQuery);
LABEL_8:
  CFTypeRef v8 = result;
  if (result)
  {
    CFTypeRef result = 0;
    CFRelease(v8);
  }
  return v7;
}

uint64_t SecKeyGetMatchingPrivateKeyStatus(const void *a1, __CFString **a2)
{
  CFTypeRef result = 0;
  if (a1)
  {
    CFDictionaryRef PrivateKeyMatchingQuery = CreatePrivateKeyMatchingQuery(a1);
    uint64_t v3 = SecItemCopyMatching(PrivateKeyMatchingQuery, &result);
    if (!v3)
    {
      CFTypeID v4 = CFGetTypeID(result);
      if (v4 == SecKeyGetTypeID()) {
        uint64_t v3 = 0;
      }
      else {
        uint64_t v3 = 4294965226;
      }
    }
    if (PrivateKeyMatchingQuery) {
      CFRelease(PrivateKeyMatchingQuery);
    }
    CFTypeRef v5 = result;
    if (result)
    {
      CFTypeRef result = 0;
      CFRelease(v5);
    }
  }
  else
  {
    uint64_t v3 = 4294967246;
    SecError(-50, a2, 0, @"Null Public Key");
  }
  return v3;
}

void *SecKeyCreatePublicFromDER(uint64_t a1, SecAsn1Oid *oid1, uint64_t *a3, uint64_t *a4)
{
  if (SecAsn1OidCompare(oid1, &CSSMOID_RSA))
  {
    uint64_t v9 = *a4;
    uint64_t v8 = a4[1];
    return SecKeyCreate(a1, (uint64_t)&kSecRSAPublicKeyDescriptor, v8, v9, 1);
  }
  else if (SecAsn1OidCompare(oid1, &CSSMOID_ecPublicKey))
  {
    size_t Length = oid1->Length;
    v15[0] = oid1->Data;
    v15[1] = Length;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v12 = *a4;
    uint64_t v18 = a4[1];
    uint64_t v19 = v12;
    if (a3)
    {
      uint64_t v13 = *a3;
      uint64_t v16 = a3[1];
      uint64_t v17 = v13;
    }
    return SecKeyCreate(a1, (uint64_t)&kSecECPublicKeyDescriptor, (uint64_t)v15, 48, 4);
  }
  else
  {
    long long v14 = _SECKEY_LOG_10970();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(v15[0]) = 0;
      _os_log_debug_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEBUG, "Unsupported algorithm oid", (uint8_t *)v15, 2u);
    }

    return 0;
  }
}

OSStatus SecKeyRawSign(SecKeyRef key, SecPadding padding, const uint8_t *dataToSign, size_t dataToSignLen, uint8_t *sig, size_t *sigLen)
{
  SignatureAlgorithmForPadding = SecKeyGetSignatureAlgorithmForPadding((uint64_t)key, padding, dataToSignLen);
  if (!SignatureAlgorithmForPadding) {
    return -50;
  }
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  void v13[2] = __SecKeyRawSign_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  void v13[4] = key;
  void v13[5] = SignatureAlgorithmForPadding;
  return SecKeyPerformLegacyOperation(dataToSign, dataToSignLen, 0, 0, sig, (CFIndex *)sigLen, v13);
}

__CFString *SecKeyGetSignatureAlgorithmForPadding(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(a1);
  if (AlgorithmId == 3)
  {
    if (a2 == 0x4000) {
      return @"algid:sign:ECDSA:digest-RFC4754";
    }
    if (a2 != 1) {
      return @"algid:sign:ECDSA:digest-X962";
    }
    if (*(void *)ccsha1_di() == a3) {
      return @"algid:sign:ECDSA:digest-X962:SHA1";
    }
    if (*(void *)ccsha224_di() == a3) {
      return @"algid:sign:ECDSA:digest-X962:SHA224";
    }
    if (*(void *)ccsha256_di() == a3) {
      return @"algid:sign:ECDSA:digest-X962:SHA256";
    }
    if (*(void *)ccsha384_di() == a3) {
      return @"algid:sign:ECDSA:digest-X962:SHA384";
    }
    if (*(void *)ccsha512_di() == a3) {
      return @"algid:sign:ECDSA:digest-X962:SHA512";
    }
    else {
      return @"algid:sign:ECDSA:digest-X962";
    }
  }
  else if (AlgorithmId == 1)
  {
    switch(a2)
    {
      case 32770:
        CFTypeRef result = @"algid:sign:RSA:digest-PKCS1v15:SHA1";
        break;
      case 32771:
        CFTypeRef result = @"algid:sign:RSA:digest-PKCS1v15:SHA224";
        break;
      case 32772:
        CFTypeRef result = @"algid:sign:RSA:digest-PKCS1v15:SHA256";
        break;
      case 32773:
        CFTypeRef result = @"algid:sign:RSA:digest-PKCS1v15:SHA384";
        break;
      case 32774:
        CFTypeRef result = @"algid:sign:RSA:digest-PKCS1v15:SHA512";
        break;
      default:
        CFTypeRef v7 = @"algid:sign:RSA:raw";
        if (a2) {
          CFTypeRef v7 = 0;
        }
        if (a2 == 1) {
          CFTypeRef result = @"algid:sign:RSA:digest-PKCS1v15";
        }
        else {
          CFTypeRef result = v7;
        }
        break;
    }
  }
  else
  {
    return 0;
  }
  return result;
}

CFDataRef __SecKeyRawSign_block_invoke(uint64_t a1, CFDataRef dataToSign, int a3, int a4, CFErrorRef *error)
{
  return SecKeyCreateSignature(*(SecKeyRef *)(a1 + 32), *(SecKeyAlgorithm *)(a1 + 40), dataToSign, error);
}

OSStatus SecKeyRawVerify(SecKeyRef key, SecPadding padding, const uint8_t *signedData, size_t signedDataLen, const uint8_t *sig, size_t sigLen)
{
  SignatureAlgorithmForPadding = SecKeyGetSignatureAlgorithmForPadding((uint64_t)key, padding, signedDataLen);
  if (!SignatureAlgorithmForPadding) {
    return -50;
  }
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  void v13[2] = __SecKeyRawVerify_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  void v13[4] = key;
  void v13[5] = SignatureAlgorithmForPadding;
  return SecKeyPerformLegacyOperation(signedData, signedDataLen, sig, sigLen, 0, 0, v13);
}

uint64_t __SecKeyRawVerify_block_invoke(uint64_t a1, CFDataRef signedData, CFDataRef signature, uint64_t a4, CFErrorRef *a5)
{
  if (SecKeyVerifySignature(*(SecKeyRef *)(a1 + 32), *(SecKeyAlgorithm *)(a1 + 40), signedData, signature, a5)) {
    return *MEMORY[0x1E4F1CFD0];
  }
  else {
    return 0;
  }
}

OSStatus SecKeyEncrypt(SecKeyRef key, SecPadding padding, const uint8_t *plainText, size_t plainTextLen, uint8_t *cipherText, size_t *cipherTextLen)
{
  uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)key);
  OSStatus result = -50;
  if (AlgorithmId == 1 && padding <= 2)
  {
    long long v14 = off_1E5485B58[padding];
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    void v15[2] = __SecKeyEncrypt_block_invoke;
    unint64_t v15[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
    void v15[4] = key;
    v15[5] = v14;
    return SecKeyPerformLegacyOperation(plainText, plainTextLen, 0, 0, cipherText, (CFIndex *)cipherTextLen, v15);
  }
  return result;
}

OSStatus SecKeyDecrypt(SecKeyRef key, SecPadding padding, const uint8_t *cipherText, size_t cipherTextLen, uint8_t *plainText, size_t *plainTextLen)
{
  uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)key);
  OSStatus result = -50;
  if (AlgorithmId == 1 && padding <= 2)
  {
    long long v14 = off_1E5485B70[padding];
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    void v15[2] = __SecKeyDecrypt_block_invoke;
    unint64_t v15[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
    void v15[4] = key;
    v15[5] = v14;
    return SecKeyPerformLegacyOperation(cipherText, cipherTextLen, 0, 0, plainText, (CFIndex *)plainTextLen, v15);
  }
  return result;
}

__CFData *SecKeyCreateDecryptedDataWithParameters(uint64_t a1, const void *a2, const __CFData *a3, const __CFData *a4, void *a5)
{
  __int16 v10 = (void *)MEMORY[0x18C12E850]();
  CFAllocatorRef v11 = _os_activity_create(&dword_18B299000, "SecKeyCreateDecryptedDataWithParameters", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v11, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateDecryptedDataWithParameters");
  if (!a3) {
    [MEMORY[0x1E4F1CA00] raise:*MEMORY[0x1E4F1C3C8] format:@"SecKeyCreateDecryptedData() called with NULL ciphertext"];
  }
  uint64_t v19 = 0;
  v16[0] = a1;
  v16[1] = 3;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue(Mutable, a2);
  CFTypeRef cf = Mutable;
  uint64_t v18 = 0;
  uint64_t v13 = SecKeyRunAlgorithmAndCopyResult(v16, a3, a4, &v19);
  CFTypeRef v14 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v14);
  }
  _SecKeyErrorPropagate(v13 != 0, (uint64_t)"SecKeyCreateDecryptedDataWithParameters", v19, a5);
  os_activity_scope_leave(&state);

  return v13;
}

void sub_18B39A5F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

CFDataRef SecKeyCreateDecryptedData(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef ciphertext, CFErrorRef *error)
{
  return SecKeyCreateDecryptedDataWithParameters((uint64_t)key, algorithm, ciphertext, 0, error);
}

uint64_t SecKeyDigestAndSign(uint64_t a1, const SecAsn1Oid *a2, const UInt8 *a3, CFIndex a4, UInt8 *a5, CFIndex *a6)
{
  AlgorithmForSecAsn1AlgId = SecKeyGetAlgorithmForSecAsn1AlgId(a1, a2, 1u);
  if (!AlgorithmForSecAsn1AlgId) {
    return 4294967292;
  }
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  void v13[2] = __SecKeyDigestAndSign_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  void v13[4] = a1;
  void v13[5] = AlgorithmForSecAsn1AlgId;
  return SecKeyPerformLegacyOperation(a3, a4, 0, 0, a5, a6, v13);
}

CFDataRef __SecKeyDigestAndSign_block_invoke(uint64_t a1, CFDataRef dataToSign, int a3, int a4, CFErrorRef *error)
{
  return SecKeyCreateSignature(*(SecKeyRef *)(a1 + 32), *(SecKeyAlgorithm *)(a1 + 40), dataToSign, error);
}

uint64_t SecKeyVerifyDigest(uint64_t a1, const SecAsn1Oid *a2, const UInt8 *a3, CFIndex a4, const UInt8 *a5, CFIndex a6)
{
  AlgorithmForSecAsn1AlgId = SecKeyGetAlgorithmForSecAsn1AlgId(a1, a2, 0);
  if (!AlgorithmForSecAsn1AlgId) {
    return 4294967292;
  }
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  void v13[2] = __SecKeyVerifyDigest_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  void v13[4] = a1;
  void v13[5] = AlgorithmForSecAsn1AlgId;
  return SecKeyPerformLegacyOperation(a3, a4, a5, a6, 0, 0, v13);
}

uint64_t __SecKeyVerifyDigest_block_invoke(uint64_t a1, CFDataRef signedData, CFDataRef signature, uint64_t a4, CFErrorRef *a5)
{
  if (SecKeyVerifySignature(*(SecKeyRef *)(a1 + 32), *(SecKeyAlgorithm *)(a1 + 40), signedData, signature, a5)) {
    return *MEMORY[0x1E4F1CFD0];
  }
  else {
    return 0;
  }
}

uint64_t SecKeySignDigest(uint64_t a1, const SecAsn1Oid *a2, const UInt8 *a3, CFIndex a4, UInt8 *a5, CFIndex *a6)
{
  AlgorithmForSecAsn1AlgId = SecKeyGetAlgorithmForSecAsn1AlgId(a1, a2, 0);
  if (!AlgorithmForSecAsn1AlgId) {
    return 4294967292;
  }
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  void v13[2] = __SecKeySignDigest_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  void v13[4] = a1;
  void v13[5] = AlgorithmForSecAsn1AlgId;
  return SecKeyPerformLegacyOperation(a3, a4, 0, 0, a5, a6, v13);
}

CFDataRef __SecKeySignDigest_block_invoke(uint64_t a1, CFDataRef dataToSign, int a3, int a4, CFErrorRef *error)
{
  return SecKeyCreateSignature(*(SecKeyRef *)(a1 + 32), *(SecKeyAlgorithm *)(a1 + 40), dataToSign, error);
}

uint64_t SecKeyFindWithPersistentRef(uint64_t a1, CFTypeRef *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  CFDictionaryRef v9 = CFDictionaryCreateForCFTypes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (int)a2, a3, a4, a5, a6, a7, a8, @"r_Ref", *MEMORY[0x1E4F1CFD0]);
  CFTypeRef result = 0;
  uint64_t v10 = SecItemCopyMatching(v9, &result);
  if (!v10)
  {
    CFTypeID v11 = CFGetTypeID(result);
    if (v11 == SecKeyGetTypeID())
    {
      uint64_t v10 = 0;
      *a2 = result;
      CFTypeRef result = 0;
      goto LABEL_7;
    }
    uint64_t v10 = 4294941996;
  }
  if (result) {
    CFRelease(result);
  }
LABEL_7:
  if (v9) {
    CFRelease(v9);
  }
  return v10;
}

uint64_t SecKeyCopyPersistentRef(uint64_t a1, CFTypeRef *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v19 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEFAULT, "SecKeyCopyPersistentRef: Need a key reference for this to work", buf, 2u);
    }
    goto LABEL_22;
  }
  if (!a2)
  {
    uint64_t v19 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEFAULT, "SecKeyCopyPersistentRef: Need a persistentRef pointer for this to work", buf, 2u);
    }
LABEL_22:

    return 4294967246;
  }
  CFDictionaryRef v10 = CFDictionaryCreateForCFTypes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (int)a2, a3, a4, a5, a6, a7, a8, @"r_PersistentRef", *MEMORY[0x1E4F1CFD0]);
  CFTypeRef result = 0;
  uint64_t v11 = SecItemCopyMatching(v10, &result);
  if (v11)
  {
    uint64_t v12 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v11;
      *(_WORD *)&uint8_t buf[8] = 2112;
      *(void *)&buf[10] = a1;
      _os_log_impl(&dword_18B299000, v12, OS_LOG_TYPE_DEFAULT, "SecKeyCopyPersistentRef: received status %i for key %@", buf, 0x12u);
    }

    uint64_t v13 = (__CFString *)CFStringCreateWithFormat(0, 0, @"Expected to find persistentref for key %@", a1);
    CFTypeRef v14 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v11;
      _os_log_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEFAULT, "stackshot report, reason: %@, code=%08x", buf, 0x12u);
    }

    if ((__simulate_crash_counter == -1 || !CrashReporterSupportLibraryCore()) && CrashReporterSupportLibraryCore())
    {
      uint64_t v15 = v13;
      uint64_t v27 = 0;
      uint64_t v28 = &v27;
      uint64_t v29 = 0x2020000000;
      uint64_t v16 = (void (*)(__CFString *, void))getWriteStackshotReportSymbolLoc_ptr;
      uint64_t v30 = getWriteStackshotReportSymbolLoc_ptr;
      if (!getWriteStackshotReportSymbolLoc_ptr)
      {
        *(void *)long long buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 3221225472;
        *(void *)&uint8_t buf[16] = __getWriteStackshotReportSymbolLoc_block_invoke;
        uint64_t v32 = &unk_1E5484FA0;
        uint64_t v33 = &v27;
        uint64_t v17 = CrashReporterSupportLibrary();
        uint64_t v18 = dlsym(v17, "WriteStackshotReport");
        *(void *)(v33[1] + 24) = v18;
        getWriteStackshotReportSymbolLoc_ptr = *(_UNKNOWN **)(v33[1] + 24);
        uint64_t v16 = (void (*)(__CFString *, void))v28[3];
      }
      _Block_object_dispose(&v27, 8);
      if (!v16)
      {
        BOOL v24 = [MEMORY[0x1E4F28B00] currentHandler];
        uint64_t v25 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL soft_WriteStackshotReport(NSString *__strong, mach_exception_data_type_t)");
        objc_msgSend(v24, "handleFailureInFunction:file:lineNumber:description:", v25, @"simulate_crash.m", 25, @"%s", dlerror());

        __break(1u);
      }
      v16(v15, v11);
    }
    if (v13) {
      CFRelease(v13);
    }
LABEL_28:
    if (result) {
      CFRelease(result);
    }
    goto LABEL_30;
  }
  CFTypeID v20 = CFGetTypeID(result);
  if (v20 != CFDataGetTypeID())
  {
    uint64_t v21 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeID v22 = CFGetTypeID(result);
      *(_DWORD *)long long buf = 134218242;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = a1;
      _os_log_impl(&dword_18B299000, v21, OS_LOG_TYPE_DEFAULT, "SecKeyCopyPersistentRef: SecItemCopyMatching returned success, but we got type %lu instead of CFData for key %@.", buf, 0x16u);
    }

    uint64_t v11 = 4294941996;
    goto LABEL_28;
  }
  uint64_t v11 = 0;
  *a2 = result;
  CFTypeRef result = 0;
LABEL_30:
  if (v10) {
    CFRelease(v10);
  }
  return v11;
}

void sub_18B39AE60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _SecKeyCopyWrapKey(uint64_t a1, int a2, int a3, int a4, void *a5, __CFString **a6)
{
  if (a6) {
    *a6 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(_DWORD *)v6 >= 3u && (CFTypeRef v7 = *(uint64_t (**)(void))(v6 + 120)) != 0)
  {
    return v7();
  }
  else
  {
    SecError(-4, a6, @"No key wrap supported for key %@", a1);
    return 0;
  }
}

uint64_t _SecKeyCopyUnwrapKey(uint64_t a1, int a2, int a3, int a4, void *a5, __CFString **a6)
{
  if (a6) {
    *a6 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(_DWORD *)v6 >= 3u && (CFTypeRef v7 = *(uint64_t (**)(void))(v6 + 128)) != 0)
  {
    return v7();
  }
  else
  {
    SecError(-4, a6, @"No key unwrap for key %@", a1);
    return 0;
  }
}

CFDataRef SecKeyCopyExternalRepresentation(SecKeyRef key, CFErrorRef *error)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  CFTypeID v4 = (void *)MEMORY[0x18C12E850]();
  CFTypeRef v5 = _os_activity_create(&dword_18B299000, "SecKeyCopyExternalRepresentation", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyCopyExternalRepresentation");
  uint64_t v6 = *(uint64_t (**)(SecKeyRef, unsigned char *))(*((void *)key + 2) + 136);
  if (v6)
  {
    *(void *)long long buf = 0;
    CFDataRef v7 = (const __CFData *)v6(key, buf);
    _SecKeyErrorPropagate(v7 != 0, (uint64_t)"SecKeyCopyExternalRepresentation", *(const void **)buf, error);
  }
  else
  {
    if (error) {
      *CFErrorRef error = 0;
    }
    SecError(-4, (__CFString **)error, @"export not implemented for key %@", key);
    uint64_t v8 = _SECKEY_LOG_10970();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "SecKeyCopyExternalRepresentation";
      __int16 v12 = 2114;
      SecKeyRef v13 = key;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "%{public}s failed, export not implemented for key %{public}@", buf, 0x16u);
    }

    CFDataRef v7 = 0;
  }
  os_activity_scope_leave(&state);

  return v7;
}

void sub_18B39B10C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
}

CFTypeRef SecKeyCreateDuplicate(void *a1)
{
  int v2 = (void *)MEMORY[0x18C12E850]();
  uint64_t v3 = _os_activity_create(&dword_18B299000, "SecKeyCreateDuplicate", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  v9.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v9.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v3, &v9);
  _SecKeyCheck((uint64_t)a1, (uint64_t)"SecKeyCreateDuplicate");
  uint64_t v4 = a1[2];
  if (*(_DWORD *)v4 >= 4u && (CFTypeRef v5 = *(uint64_t (**)(void *))(v4 + 168)) != 0) {
    CFTypeRef v6 = (CFTypeRef)v5(a1);
  }
  else {
    CFTypeRef v6 = CFRetain(a1);
  }
  CFTypeRef v7 = v6;
  os_activity_scope_leave(&v9);

  return v7;
}

void sub_18B39B1F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

BOOL SecKeySetParameter(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (void *)MEMORY[0x18C12E850]();
  os_activity_scope_state_s v9 = _os_activity_create(&dword_18B299000, "SecKeySetParameter", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeySetParameter");
  uint64_t v10 = *(void *)(a1 + 16);
  if (*(_DWORD *)v10 >= 4u
    && (uint64_t v11 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, const void **))(v10 + 176)) != 0)
  {
    uint64_t v14 = 0;
    BOOL v12 = v11(a1, a2, a3, &v14) != 0;
    _SecKeyErrorPropagate(v12, (uint64_t)"SecKeySetParameter", v14, a4);
  }
  else
  {
    if (a4) {
      *a4 = 0;
    }
    BOOL v12 = SecError(-4, a4, @"setParameter not implemented for %@", a1);
  }
  os_activity_scope_leave(&state);

  return v12;
}

void sub_18B39B324(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
}

CFDataRef SecKeyCopyKeyExchangeResult(SecKeyRef privateKey, SecKeyAlgorithm algorithm, SecKeyRef publicKey, CFDictionaryRef parameters, CFErrorRef *error)
{
  uint64_t v10 = (void *)MEMORY[0x18C12E850]();
  uint64_t v11 = _os_activity_create(&dword_18B299000, "SecKeyCopyKeyExchangeResult", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v11, &state);
  _SecKeyCheck((uint64_t)privateKey, (uint64_t)"SecKeyCopyKeyExchangeResult");
  if (!publicKey) {
    [MEMORY[0x1E4F1CA00] raise:*MEMORY[0x1E4F1C3C8] format:@"SecKeyCopyKeyExchangeResult() called with NULL publicKey"];
  }
  uint64_t v19 = 0;
  v16[0] = (uint64_t)privateKey;
  v16[1] = 4;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue(Mutable, algorithm);
  CFTypeRef cf = Mutable;
  uint64_t v18 = 0;
  CFDataRef v13 = SecKeyCopyExternalRepresentation(publicKey, error);
  if (!v13)
  {
    uint64_t v14 = 0;
    if (!Mutable) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  uint64_t v14 = SecKeyRunAlgorithmAndCopyResult(v16, v13, parameters, &v19);
  _SecKeyErrorPropagate(v14 != 0, (uint64_t)"SecKeyCopyKeyExchangeResult", v19, error);
  CFRelease(v13);
  CFMutableDictionaryRef Mutable = (__CFArray *)cf;
  if (cf)
  {
LABEL_5:
    CFTypeRef cf = 0;
    CFRelease(Mutable);
  }
LABEL_6:
  os_activity_scope_leave(&state);

  return v14;
}

void sub_18B39B4BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

uint64_t SecKeyCreateEncapsulatedKey(uint64_t a1, const void *a2, uint64_t *a3, void *a4)
{
  uint64_t v8 = (void *)MEMORY[0x18C12E850]();
  os_activity_scope_state_s v9 = _os_activity_create(&dword_18B299000, "SecKeyCreateEncapsulatedKey", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateEncapsulatedKey");
  if (!a3) {
    [MEMORY[0x1E4F1CA00] raise:*MEMORY[0x1E4F1C3C8] format:@"SecKeyCreateEncapsulatedKey() requires encapsulatedKey output parameter"];
  }
  uint64_t v18 = 0;
  v15[0] = a1;
  v15[1] = 5;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue(Mutable, a2);
  CFTypeRef cf = Mutable;
  uint64_t v17 = 0;
  uint64_t v11 = SecKeyRunAlgorithmAndCopyResult(v15, 0, 0, &v18);
  CFTypeRef v12 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v12);
  }
  _SecKeyErrorPropagate(v11 != 0, (uint64_t)"SecKeyCreateEncapsulatedKey", v18, a4);
  if (v11)
  {
    *a3 = [(__CFData *)v11 objectAtIndexedSubscript:0];
    uint64_t v13 = [(__CFData *)v11 objectAtIndexedSubscript:1];
  }
  else
  {
    uint64_t v13 = 0;
  }

  os_activity_scope_leave(&state);
  return v13;
}

void sub_18B39B658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

__CFData *SecKeyCreateDecapsulatedKey(uint64_t a1, const void *a2, const __CFData *a3, void *a4)
{
  uint64_t v8 = (void *)MEMORY[0x18C12E850]();
  os_activity_scope_state_s v9 = _os_activity_create(&dword_18B299000, "SecKeyCreateDecapsulatedKey", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateDecapsulatedKey");
  if (!a3) {
    [MEMORY[0x1E4F1CA00] raise:*MEMORY[0x1E4F1C3C8] format:@"SecKeyCreateDecapsulatedKey() requires encapsulatedKey input parameter"];
  }
  uint64_t v17 = 0;
  v14[0] = a1;
  v14[1] = 6;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue(Mutable, a2);
  CFTypeRef cf = Mutable;
  uint64_t v16 = 0;
  uint64_t v11 = SecKeyRunAlgorithmAndCopyResult(v14, a3, 0, &v17);
  CFTypeRef v12 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v12);
  }
  _SecKeyErrorPropagate(v11 != 0, (uint64_t)"SecKeyCreateDecapsulatedKey", v17, a4);
  os_activity_scope_leave(&state);

  return v11;
}

void sub_18B39B7BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA512(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:keyexchange:ECDHC");
  uint64_t v8 = ccsha512_di();

  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyECDHCopyX963Result(uint64_t *a1, uint64_t a2, const __CFData *a3, const __CFDictionary *a4, __CFString **a5)
{
  uint64_t v8 = SecKeyRunAlgorithmAndCopyResult(a1, a3, 0, a5);
  if (!v8) {
    return 0;
  }
  CFDataRef v9 = v8;
  if (!a1[3])
  {
    CFIndex valuePtr = 0;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a4, @"requestedSize");
    if (Value
      && (CFNumberRef v12 = Value, v13 = CFGetTypeID(Value), v13 == CFNumberGetTypeID())
      && CFNumberGetValue(v12, kCFNumberCFIndexType, &valuePtr))
    {
      CFDataRef v14 = (const __CFData *)CFDictionaryGetValue(a4, @"sharedInfo");
      if (!v14)
      {
LABEL_10:
        if (SecCFAllocatorZeroize_sOnce != -1) {
          dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
        }
        CFIndex v17 = valuePtr;
        CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
        CFDataSetLength(Mutable, v17);
        CFDataGetLength(v9);
        CFDataGetBytePtr(v9);
        CFDataGetMutableBytePtr(Mutable);
        uint64_t v18 = ccansikdf_x963();
        if (!v18) {
          goto LABEL_13;
        }
        uint64_t v20 = v18;
        if (Mutable) {
          CFRelease(Mutable);
        }
        SecError(-50, a5, @"ECDHKeyExchange wrong input (%d)", v20);
        goto LABEL_21;
      }
      CFDataRef v15 = v14;
      CFTypeID v16 = CFGetTypeID(v14);
      if (v16 == CFDataGetTypeID())
      {
        CFDataGetBytePtr(v15);
        CFDataGetLength(v15);
        goto LABEL_10;
      }
      SecError(-50, a5, @"ECDHKeyExchange wrong sharedInfo type (must be CFData/NSData)");
    }
    else
    {
      SecError(-50, a5, @"kSecKeyKeyExchangeParameterRequestedSize is missing");
    }
LABEL_21:
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_13;
  }
  CFRetain(v8);
  CFMutableDictionaryRef Mutable = v9;
LABEL_13:
  CFRelease(v9);
  return Mutable;
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA384(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:keyexchange:ECDHC");
  uint64_t v8 = ccsha384_di();

  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA256(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:keyexchange:ECDHC");
  uint64_t v8 = ccsha256_di();

  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA224(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:keyexchange:ECDHC");
  uint64_t v8 = ccsha224_di();

  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA1(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:keyexchange:ECDHC");
  uint64_t v8 = ccsha1_di();

  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA512(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:keyexchange:ECDH");
  uint64_t v8 = ccsha512_di();

  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA384(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:keyexchange:ECDH");
  uint64_t v8 = ccsha384_di();

  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA256(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:keyexchange:ECDH");
  uint64_t v8 = ccsha256_di();

  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA224(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:keyexchange:ECDH");
  uint64_t v8 = ccsha224_di();

  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA1(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:keyexchange:ECDH");
  uint64_t v8 = ccsha1_di();

  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIES_Standard_SHA256_2PubKeys(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDH", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeSHA2562PubKeysCopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESCBCCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyECIESCopyDecryptedData(void *a1, uint64_t a2, uint64_t (*a3)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **), uint64_t (*a4)(const void *, CFDataRef, uint64_t, __CFString **), uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  CFDictionaryRef v14 = SecKeyCopyAttributes((SecKeyRef)*a1);
  if (!v14)
  {
    SecError(-50, a8, @"Unable to export key parameters");
    return 0;
  }
  CFDictionaryRef v15 = v14;
  CFNumberRef Value = CFDictionaryGetValue(v14, @"type");
  if (!CFEqual(Value, @"73")
    && (CFIndex v17 = CFDictionaryGetValue(v15, @"type"), !CFEqual(v17, @"106"))
    && (uint64_t v18 = CFDictionaryGetValue(v15, @"type"), !CFEqual(v18, @"108"))
    || (uint64_t v19 = CFDictionaryGetValue(v15, @"kcls"), !CFEqual(v19, @"1")))
  {
    CFTypeRef v34 = (CFTypeRef)*MEMORY[0x1E4F1D260];
LABEL_37:
    CFDictionaryRef v38 = v15;
    goto LABEL_31;
  }
  CFDataRef theData = a6;
  uint64_t v41 = a4;
  if (a1[3])
  {
    CFIndex v20 = 0;
    uint64_t v21 = 0;
    CFTypeRef cf = 0;
    CFDataRef v22 = 0;
    CFDataRef v23 = 0;
    goto LABEL_17;
  }
  BOOL v24 = CFDictionaryGetValue(v15, @"type");
  int v25 = CFEqual(v24, @"73");
  CFStringRef v26 = (const __CFString *)CFDictionaryGetValue(v15, @"bsiz");
  uint64_t CFIndexFromRef = SecKeyGetCFIndexFromRef(v26);
  uint64_t v28 = CFIndexFromRef + 7;
  if (CFIndexFromRef < -7) {
    uint64_t v28 = CFIndexFromRef + 14;
  }
  uint64_t v29 = v28 >> 3;
  if (v25) {
    CFIndex v20 = (2 * v29) | 1;
  }
  else {
    CFIndex v20 = v29;
  }
  if (CFDataGetLength(a6) < v20)
  {
    SecError(-50, a8, @"%@: too small input packet for ECIES decrypt", *a1, a6);
    CFTypeRef v34 = 0;
    goto LABEL_37;
  }
  BytePtr = CFDataGetBytePtr(a6);
  CFDataRef v23 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], BytePtr, v20, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  uint64_t v31 = SecKeyCopyPublicKey((SecKeyRef)*a1);
  if (!v31)
  {
    SecError(-50, a8, @"%@: Unable to get public key", *a1);
    CFDataRef v35 = 0;
    CFTypeRef cf = 0;
    CFDataRef v22 = 0;
LABEL_40:
    uint64_t v33 = 0;
    goto LABEL_41;
  }
  CFTypeRef cf = v31;
  CFDataRef v22 = SecKeyCopyExternalRepresentation(v31, (CFErrorRef *)a8);
  if (!v22)
  {
    CFDataRef v35 = 0;
    goto LABEL_40;
  }
  uint64_t v21 = &BytePtr[v20];
LABEL_17:
  uint64_t v32 = (const void *)a3(a1, a2, 0, v23, v22, a5, a7, a8);
  uint64_t v33 = v32;
  if (!v32)
  {
    CFDataRef v35 = 0;
LABEL_41:
    CFTypeRef v34 = 0;
    goto LABEL_21;
  }
  if (a1[3])
  {
    CFTypeRef v34 = CFRetain(v32);
    CFDataRef v35 = 0;
  }
  else
  {
    CFAllocatorRef v36 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex Length = CFDataGetLength(theData);
    CFDataRef v35 = CFDataCreateWithBytesNoCopy(v36, v21, Length - v20, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    CFTypeRef v34 = (CFTypeRef)v41(v33, v35, a7, a8);
  }
LABEL_21:
  CFRelease(v15);
  if (v23) {
    CFRelease(v23);
  }
  if (v33) {
    CFRelease(v33);
  }
  if (v22) {
    CFRelease(v22);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v35)
  {
    CFDictionaryRef v38 = v35;
LABEL_31:
    CFRelease(v38);
  }
  return v34;
}

uint64_t SecKeyGetCFIndexFromRef(const __CFString *a1)
{
  uint64_t valuePtr = 0;
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFNumberGetTypeID())
  {
    if (CFNumberGetValue((CFNumberRef)a1, kCFNumberCFIndexType, &valuePtr)) {
      return valuePtr;
    }
    else {
      return 0;
    }
  }
  else
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFStringGetTypeID()) {
      return CFStringGetIntValue(a1);
    }
    else {
      return 0;
    }
  }
}

__CFData *SecKeyECIESDecryptAESCBCCopyResult(const __CFData *a1, CFDataRef theData)
{
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFAllocatorRef v4 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex Length = CFDataGetLength(theData);
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v4, 0);
  CFDataSetLength(Mutable, Length);
  ccaes_cbc_decrypt_mode();
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  CFDataGetLength(a1);
  CFDataGetBytePtr(theData);
  CFDataGetMutableBytePtr(Mutable);
  cccbc_one_shot();
  return Mutable;
}

__CFData *SecKeyECIESKeyExchangeSHA2562PubKeysCopyResult(uint64_t a1, const void *a2, uint64_t a3, const __CFData *a4, const __CFData *a5, uint64_t a6, uint64_t a7, __CFString **a8)
{
  v22[1] = *MEMORY[0x1E4F143B8];
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  *(void *)(a1 + 8) = 4;
  CFNumberRef v12 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, a4, 0, a8);
  if (v12 && !*(void *)(a1 + 24))
  {
    uint64_t v13 = ccsha256_di();
    MEMORY[0x1F4188790](v13);
    CFTypeID v16 = (char *)v22 - v15;
    if (v17 >= 8) {
      memset((char *)v22 - v15, 170, v14);
    }
    ccdigest_init();
    CFDataGetLength(v12);
    CFDataGetBytePtr(v12);
    ccdigest_update();
    CFDataGetLength(a4);
    CFDataGetBytePtr(a4);
    ccdigest_update();
    CFDataGetLength(a5);
    CFDataGetBytePtr(a5);
    ccdigest_update();
    CFIndex v18 = *(void *)v13;
    CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    CFDataSetLength(Mutable, v18);
    CFRelease(v12);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    (*(void (**)(uint64_t, char *, UInt8 *))(v13 + 56))(v13, v16, MutableBytePtr);
    return Mutable;
  }
  return v12;
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorVariableIVX963SHA512(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA512", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyECIESDecryptAESGCMCopyResult(const __CFData *a1, CFDataRef theData, const __CFDictionary *a3, __CFString **a4)
{
  if (CFDataGetLength(theData) <= 15)
  {
    SecError(-50, a4, @"ECIES: Input data too short");
    return 0;
  }
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFAllocatorRef v8 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex v9 = CFDataGetLength(theData) - 16;
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v8, 0);
  CFDataSetLength(Mutable, v9);
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  uint64_t v11 = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  CFDataSetLength(v11, 16);
  CFIndex v12 = CFDataGetLength(theData) - 16;
  MutableBytePtr = CFDataGetMutableBytePtr(v11);
  v20.location = v12;
  v20.size_t length = 16;
  CFDataGetBytes(theData, v20, MutableBytePtr);
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  if (a3) {
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(a3, @"aad");
  }
  else {
    CFDataRef Value = 0;
  }
  ccaes_gcm_decrypt_mode();
  CFDataGetBytePtr(a1);
  if (Value)
  {
    CFDataGetLength(Value);
    CFDataGetBytePtr(Value);
  }
  CFDataGetLength(Mutable);
  CFDataGetBytePtr(theData);
  uint64_t v15 = CFDataGetMutableBytePtr(Mutable);
  uint64_t v19 = CFDataGetMutableBytePtr(v11);
  uint64_t v16 = ccgcm_one_shot();
  if (!v16)
  {
    CFTypeRef v17 = CFRetain(Mutable);
    if (!Mutable) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  SecError(-50, a4, @"ECIES: Failed to aes-gcm decrypt data (err %d)", v16, v15, 16, v19);
  CFTypeRef v17 = 0;
  if (Mutable) {
LABEL_13:
  }
    CFRelease(Mutable);
LABEL_14:
  if (v11) {
    CFRelease(v11);
  }
  return v17;
}

id SecKeyECIESKeyExchangeKDFX963CopyResult(uint64_t a1, const void *a2, int a3, void *a4, const __CFData *a5, int a6, void *a7, __CFString **a8)
{
  v34[2] = *MEMORY[0x1E4F143B8];
  id v15 = a7;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  *(void *)(a1 + 8) = 4;
  if (*(void *)(a1 + 24))
  {
    CFDataRef v16 = 0;
    CFTypeRef v17 = 0;
  }
  else
  {
    *(void *)uint64_t v31 = a8;
    uint64_t v32 = v15;
    CFIndex v18 = [v15 objectForKeyedSubscript:@"symKeySize"];
    if (v18)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        SecError(-50, a8, @"Bad requested kSecKeyEncryptionParameterSymmetricKeySizeInBits: %@", v18);

        id v29 = 0;
        id v15 = v32;
        goto LABEL_22;
      }
      uint64_t v19 = [v18 integerValue] / 8;
    }
    else
    {
      CFIndex Length = CFDataGetLength(a5);
      uint64_t v19 = 16;
      if (Length > 66) {
        uint64_t v19 = 32;
      }
    }
    if (a6) {
      uint64_t v21 = v19 + 16;
    }
    else {
      uint64_t v21 = v19;
    }
    CFTypeRef v17 = (void *)[a4 mutableCopy];
    CFDataRef v22 = [v32 objectForKeyedSubscript:@"sharedInfo"];
    if (v22) {
      [v17 appendData:v22];
    }
    v33[0] = @"sharedInfo";
    v33[1] = @"requestedSize";
    v34[0] = v17;
    CFDataRef v23 = [NSNumber numberWithInteger:v21];
    v34[1] = v23;
    CFDataRef v16 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v34 forKeys:v33 count:2];

    a8 = *(__CFString ***)v31;
    id v15 = v32;
  }
  if (a3) {
    CFDataRef v24 = a5;
  }
  else {
    CFDataRef v24 = (const __CFData *)a4;
  }
  int v25 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, v24, v16, a8);
  CFStringRef v26 = v25;
  if (!*(void *)(a1 + 24) && (a6 & 1) == 0 && v25)
  {
    uint64_t v27 = (void *)[(__CFData *)v25 mutableCopy];
    [v27 appendBytes:&kSecKeyIESIV length:16];
    uint64_t v28 = [MEMORY[0x1E4F1C9B8] dataWithData:v27];

    CFStringRef v26 = (void *)v28;
  }
  id v29 = v26;

LABEL_22:
  return v29;
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorVariableIVX963SHA384(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA384", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorVariableIVX963SHA256(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA256", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorVariableIVX963SHA224(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA224", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardVariableIVX963SHA512(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA512", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardVariableIVX963SHA384(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA384", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardVariableIVX963SHA256(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA256", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardVariableIVX963SHA224(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA224", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA512(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA512", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA384(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA384", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA256(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA256", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA224(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA224", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA1(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA1", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA512(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA512", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA384(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA384", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA256(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA256", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA224(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA224", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA1(void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA1", (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA512AESGCM(uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA512", a2, a4);
}

void *SecKeyRSAAESGCMCopyDecryptedData(uint64_t *a1, const void *a2, const __CFData *a3, __CFString **a4)
{
  CFDictionaryRef v8 = SecKeyCopyAttributes((SecKeyRef)*a1);
  if (!v8)
  {
    SecError(-50, a4, @"Unable to export key parameters");
    return 0;
  }
  CFDictionaryRef v9 = v8;
  CFDataRef Value = CFDictionaryGetValue(v8, @"type");
  if (!CFEqual(Value, @"42") || (uint64_t v11 = CFDictionaryGetValue(v9, @"kcls"), !CFEqual(v11, @"1")))
  {
    uint64_t v31 = (void *)*MEMORY[0x1E4F1D260];
LABEL_34:
    CFDictionaryRef v32 = v9;
    goto LABEL_28;
  }
  CFArrayAppendValue((CFMutableArrayRef)a1[2], a2);
  if (a1[3])
  {
    uint64_t v31 = SecKeyRunAlgorithmAndCopyResult(a1, 0, 0, a4);
    goto LABEL_34;
  }
  CFIndex v12 = SecKeyCopyPublicKey((SecKeyRef)*a1);
  if (!v12)
  {
    SecError(-50, a4, @"%@: unable to get public key", *a1);
    uint64_t v31 = 0;
    goto LABEL_34;
  }
  uint64_t v13 = v12;
  CFDataRef v35 = SecKeyCopyExternalRepresentation(v12, (CFErrorRef *)a4);
  if (!v35)
  {
    CFRelease(v9);
    CFRelease(v13);
    return 0;
  }
  SecKeyRef v14 = (SecKeyRef)*a1;
  _SecKeyCheck(*a1, (uint64_t)"SecKeyGetBlockSize");
  id v15 = *(uint64_t (**)(SecKeyRef))(*((void *)v14 + 2) + 80);
  if (v15) {
    CFIndex v16 = v15(v14);
  }
  else {
    CFIndex v16 = 0;
  }
  if (CFDataGetLength(a3) < v16 + 16)
  {
    SecError(-50, a4, @"RSA-WRAP too short input data");
LABEL_38:
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v31 = 0;
LABEL_25:
    CFRelease(v9);
    goto LABEL_26;
  }
  CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  BytePtr = CFDataGetBytePtr(a3);
  CFDataRef v19 = CFDataCreateWithBytesNoCopy(v17, BytePtr, v16, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  CFRange v20 = SecKeyRunAlgorithmAndCopyResult(a1, v19, 0, a4);
  if (v19) {
    CFRelease(v19);
  }
  if (!v20) {
    goto LABEL_38;
  }
  CFStringRef v21 = (const __CFString *)CFDictionaryGetValue(v9, @"bsiz");
  if (SecKeyGetCFIndexFromRef(v21) <= 4095) {
    uint64_t v22 = 16;
  }
  else {
    uint64_t v22 = 32;
  }
  if (CFDataGetLength(v20) == v22)
  {
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
    }
    CFAllocatorRef v23 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
    CFIndex v24 = CFDataGetLength(a3) - v16 - 16;
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(v23, 0);
    CFDataSetLength(Mutable, v24);
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
    }
    CFStringRef v26 = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
    CFDataSetLength(v26, 16);
    CFIndex v27 = CFDataGetLength(a3) - 16;
    MutableBytePtr = CFDataGetMutableBytePtr(v26);
    v36.location = v27;
    v36.size_t length = 16;
    CFDataGetBytes(a3, v36, MutableBytePtr);
    CFDataGetBytePtr(a3);
    ccaes_gcm_decrypt_mode();
    CFDataGetLength(v20);
    CFDataGetBytePtr(v20);
    CFDataGetLength(v35);
    CFDataGetBytePtr(v35);
    CFDataGetLength(Mutable);
    id v29 = CFDataGetMutableBytePtr(Mutable);
    CFTypeRef v34 = CFDataGetMutableBytePtr(v26);
    uint64_t v30 = ccgcm_one_shot();
    if (v30)
    {
      SecError(-50, a4, @"RSA-WRAP: Failed to aes-gcm decrypt data (err %d)", v30, v29, 16, v34);
      uint64_t v31 = 0;
    }
    else
    {
      uint64_t v31 = (void *)CFRetain(Mutable);
    }
  }
  else
  {
    SecError(-50, a4, @"RSA-WRAP bad ciphertext, unexpected session key size");
    CFStringRef v26 = 0;
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v31 = 0;
  }
  CFRelease(v9);
  CFRelease(v20);
  CFDictionaryRef v9 = v26;
  if (v26) {
    goto LABEL_25;
  }
LABEL_26:
  CFRelease(v35);
  CFRelease(v13);
  if (Mutable)
  {
    CFDictionaryRef v32 = Mutable;
LABEL_28:
    CFRelease(v32);
  }
  return v31;
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA384AESGCM(uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA384", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA256AESGCM(uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA256", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA224AESGCM(uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA224", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA1AESGCM(uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA1", a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA512(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  CFTypeRef v7 = (void *)ccsha512_di();

  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyRSACopyDecryptedWithPadding(uint64_t a1, void *a2, const __CFData *a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:encrypt:RSA:raw-cc");
  if (a2) {
    unint64_t v8 = 2 * *a2 + 2;
  }
  else {
    unint64_t v8 = 11;
  }
  uint64_t v9 = *(void *)a1;
  _SecKeyCheck(*(void *)a1, (uint64_t)"SecKeyGetBlockSize");
  uint64_t v10 = *(uint64_t (**)(uint64_t))(*(void *)(v9 + 16) + 80);
  if (v10) {
    unint64_t v11 = v10(v9);
  }
  else {
    unint64_t v11 = 0;
  }
  if (v11 < v8) {
    return (__CFData *)*MEMORY[0x1E4F1D260];
  }
  if (*(void *)(a1 + 24) != 1)
  {
    uint64_t v18 = 0;
    CFDataRef v19 = &v18;
    uint64_t v20 = 0x2020000000;
    uint64_t v21 = 0;
    uint64_t v14 = *(void *)a1;
    _SecKeyCheck(*(void *)a1, (uint64_t)"SecKeyGetBlockSize");
    id v15 = *(uint64_t (**)(uint64_t))(*(void *)(v14 + 16) + 80);
    if (v15) {
      unint64_t v16 = v15(v14);
    }
    else {
      unint64_t v16 = 0;
    }
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 3221225472;
    size_t v17[2] = __SecKeyRSACopyDecryptedWithPadding_block_invoke;
    unint64_t v17[3] = &unk_1E5481168;
    void v17[4] = &v18;
    void v17[5] = a1;
    v17[6] = a4;
    v17[7] = a2;
    PerformWithBigEndianToCCUnit(a3, v16, v17);
    uint64_t v12 = v19[3];
    _Block_object_dispose(&v18, 8);
    return (__CFData *)v12;
  }

  return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0, 0, a4);
}

void sub_18B39EAE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __SecKeyRSACopyDecryptedWithPadding_block_invoke(uint64_t a1, const __CFData *a2)
{
  uint64_t v3 = SecKeyRunAlgorithmAndCopyResult(*(uint64_t **)(a1 + 40), a2, 0, *(__CFString ***)(a1 + 48));
  if (v3)
  {
    CFDataRef v4 = v3;
    uint64_t v5 = **(void **)(a1 + 40);
    _SecKeyCheck(v5, (uint64_t)"SecKeyGetBlockSize");
    CFTypeRef v6 = *(uint64_t (**)(uint64_t))(*(void *)(v5 + 16) + 80);
    if (v6) {
      CFIndex v7 = v6(v5);
    }
    else {
      CFIndex v7 = 0;
    }
    CFIndex length = v7;
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
    CFDataSetLength(Mutable, v7);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = Mutable;
    if (*(void *)(a1 + 56))
    {
      CFDataGetMutableBytePtr(*(CFMutableDataRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      CFDataGetBytePtr(v4);
      uint64_t v9 = ccrsa_oaep_decode();
    }
    else if (*(_UNKNOWN **)(**(void **)(a1 + 40) + 16) == &kSecRSAPrivateKeyDescriptor)
    {
      CFDataGetMutableBytePtr(*(CFMutableDataRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      CFDataGetBytePtr(v4);
      uint64_t v9 = ccrsa_eme_pkcs1v15_decode_safe();
    }
    else
    {
      CFDataGetMutableBytePtr(*(CFMutableDataRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      CFDataGetBytePtr(v4);
      uint64_t v9 = ccrsa_eme_pkcs1v15_decode();
    }
    uint64_t v10 = v9;
    uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v12 = *(void **)(v11 + 24);
    if (v10)
    {
      if (v12)
      {
        *(void *)(v11 + 24) = 0;
        CFRelease(v12);
      }
      SecError(-50, *(__CFString ***)(a1 + 48), @"RSAdecrypt wrong input (err %d)", v10, length);
    }
    else
    {
      CFDataSetLength((CFMutableDataRef)v12, length);
    }
    CFRelease(v4);
  }
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA384(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  CFIndex v7 = (void *)ccsha384_di();

  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA256(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  CFIndex v7 = (void *)ccsha256_di();

  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA224(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  CFIndex v7 = (void *)ccsha224_di();

  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA1(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  CFIndex v7 = (void *)ccsha1_di();

  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionPKCS1(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSACopyDecryptedWithPadding(a1, 0, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_EncryptDecrypt_RSAEncryptionRawCCUnit(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:encrypt:RSA:raw");

  return SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian(uint64_t *a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  if (a1[3] == 1)
  {
    return SecKeyRunAlgorithmAndCopyResult(a1, 0, 0, a4);
  }
  else
  {
    uint64_t v16 = 0;
    CFAllocatorRef v17 = &v16;
    uint64_t v18 = 0x2020000000;
    uint64_t v19 = 0;
    uint64_t v9 = *a1;
    _SecKeyCheck(*a1, (uint64_t)"SecKeyGetBlockSize");
    uint64_t v10 = *(uint64_t (**)(uint64_t))(*(void *)(v9 + 16) + 80);
    if (v10) {
      size_t v11 = v10(v9);
    }
    else {
      size_t v11 = 0;
    }
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    uint64_t v15[2] = __SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian_block_invoke;
    unint64_t v15[3] = &unk_1E5481168;
    void v15[4] = &v16;
    v15[5] = a1;
    void v15[6] = a3;
    void v15[7] = a4;
    uint64_t v12 = v15;
    uint64_t v13 = v12;
    if (a2)
    {
      v20[0] = MEMORY[0x1E4F143A8];
      v20[1] = 3221225472;
      v20[2] = __PerformWithCCUnitToBigEndian_block_invoke;
      v20[3] = &unk_1E54811B8;
      uint64_t v22 = a2;
      size_t v23 = v11;
      uint64_t v21 = v12;
      PerformWithCFDataBuffer(v11, v20);
    }
    else
    {
      __SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian_block_invoke((uint64_t)v12, 0);
    }

    uint64_t v14 = v17[3];
    _Block_object_dispose(&v16, 8);
    return (__CFData *)v14;
  }
}

void sub_18B39F044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian_block_invoke(uint64_t a1, const __CFData *a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = SecKeyRunAlgorithmAndCopyResult(*(uint64_t **)(a1 + 40), a2, *(const __CFData **)(a1 + 48), *(__CFString ***)(a1 + 56));
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  CFDataRef v4 = *(const __CFData **)(v3 + 24);
  if (v4)
  {
    uint64_t v5 = **(void **)(a1 + 40);
    _SecKeyCheck(v5, (uint64_t)"SecKeyGetBlockSize");
    CFTypeRef v6 = *(uint64_t (**)(uint64_t))(*(void *)(v5 + 16) + 80);
    if (v6) {
      unint64_t v7 = v6(v5);
    }
    else {
      unint64_t v7 = 0;
    }
    unint64_t Length = CFDataGetLength(v4);
    if (Length > v7) {
      unint64_t v7 = Length;
    }
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
    }
    CFIndex v9 = (v7 + 7) & 0xFFFFFFFFFFFFFFF8;
    CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
    CFDataSetLength(Mutable, v9);
    CFDataGetMutableBytePtr(Mutable);
    CFDataGetBytePtr(v4);
    ccn_read_uint();
    size_t v11 = *(const void **)(v3 + 24);
    if (v11) {
      CFRelease(v11);
    }
    *(void *)(v3 + 24) = Mutable;
  }
}

uint64_t __PerformWithCCUnitToBigEndian_block_invoke(uint64_t a1)
{
  CFDataGetLength(*(CFDataRef *)(a1 + 40));
  CFDataGetBytePtr(*(CFDataRef *)(a1 + 40));
  ccn_write_uint_padded();
  CFTypeID v2 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v2();
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorVariableIVX963SHA512(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA512", 1, a2, a3, a4);
}

CFTypeRef SecKeyECIESCopyEncryptedData(uint64_t a1, const void *a2, int a3, const __CFData *a4, void *a5, __CFString **a6)
{
  SecKeyRef v11 = *(SecKeyRef *)a1;
  CFDictionaryRef v12 = SecKeyCopyAttributes(*(SecKeyRef *)a1);
  if (!v12)
  {
    SecError(-50, a6, @"Unable to export key parameters");
    CFTypeRef v37 = 0;
    goto LABEL_35;
  }
  CFDictionaryRef v13 = v12;
  CFDataRef theData = a4;
  CFDataRef Value = CFDictionaryGetValue(v12, @"type");
  if (!CFEqual(Value, @"73")
    && (id v15 = CFDictionaryGetValue(v13, @"type"), !CFEqual(v15, @"106"))
    && (uint64_t v16 = CFDictionaryGetValue(v13, @"type"), !CFEqual(v16, @"108"))
    || (CFAllocatorRef v17 = CFDictionaryGetValue(v13, @"kcls"), !CFEqual(v17, @"0")))
  {
    uint64_t v30 = 0;
    CFDictionaryRef v32 = 0;
    CFDataRef v33 = 0;
    CFDataRef v34 = 0;
    CFDataRef v36 = 0;
    CFDataRef MutableCopy = 0;
    CFTypeRef v37 = (CFTypeRef)*MEMORY[0x1E4F1D260];
    goto LABEL_22;
  }
  CFDataRef v50 = SecKeyCopyExternalRepresentation(*(SecKeyRef *)a1, (CFErrorRef *)a6);
  if (!v50)
  {
    uint64_t v30 = 0;
    CFDictionaryRef v32 = 0;
    CFDataRef v33 = 0;
    CFDataRef v34 = 0;
    CFDataRef v36 = 0;
    CFTypeRef v37 = 0;
    CFDataRef MutableCopy = 0;
    goto LABEL_22;
  }
  int v48 = v11;
  CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v19 = CFDictionaryGetValue(v13, @"type");
  CFDictionaryGetValue(v13, @"bsiz");
  CFDictionaryRef v27 = CFDictionaryCreateForCFTypes(v18, v20, v21, v22, v23, v24, v25, v26, @"type", (uint64_t)v19);
  CFDictionaryRef v28 = v13;
  CFDictionaryRef v13 = v27;
  CFRelease(v28);
  RandomKey = SecKeyCreateRandomKey(v13, (CFErrorRef *)a6);
  uint64_t v30 = RandomKey;
  if (!RandomKey)
  {
    CFDataRef MutableCopy = 0;
    CFTypeRef v37 = 0;
    CFDataRef v36 = 0;
    CFDataRef v34 = 0;
    CFDictionaryRef v32 = 0;
    SecKeyRef v11 = v48;
    CFDataRef v33 = v50;
    if (!v13) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  uint64_t v31 = SecKeyCopyPublicKey(RandomKey);
  CFDictionaryRef v32 = v31;
  CFDataRef v33 = v50;
  if (!v31)
  {
    SecError(-50, a6, @"Unable to get public key from generated ECkey");
    CFDataRef MutableCopy = 0;
    CFTypeRef v37 = 0;
    CFDataRef v36 = 0;
    CFDataRef v34 = 0;
    goto LABEL_13;
  }
  CFDataRef v34 = SecKeyCopyExternalRepresentation(v31, (CFErrorRef *)a6);
  if (!v34)
  {
    CFDataRef MutableCopy = 0;
    CFTypeRef v37 = 0;
    CFDataRef v36 = 0;
    goto LABEL_13;
  }
  *(void *)a1 = v30;
  CFDataRef v35 = (const __CFData *)SecKeyECIESKeyExchangeKDFX963CopyResult(a1, a2, 1, v34, v50, a3, a5, a6);
  CFDataRef v36 = v35;
  if (!v35)
  {
    CFDataRef MutableCopy = 0;
    CFTypeRef v37 = 0;
LABEL_13:
    SecKeyRef v11 = v48;
    if (!v13) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  if (*(void *)(a1 + 24))
  {
    CFTypeRef v37 = CFRetain(v35);
    CFDataRef MutableCopy = 0;
    goto LABEL_13;
  }
  CFDictionaryRef v45 = v13;
  CFDataRef v39 = (const __CFData *)a5;
  CFDataRef MutableCopy = CFDataCreateMutableCopy(v18, 0, v34);
  CFIndex Length = CFDataGetLength(MutableCopy);
  CFIndex v41 = CFDataGetLength(theData);
  CFDataSetLength(MutableCopy, Length + v41 + 16);
  int v46 = &CFDataGetMutableBytePtr(MutableCopy)[Length];
  CFIndex v42 = CFDataGetLength(theData);
  CFDataGetLength(v36);
  CFDataGetBytePtr(v36);
  if (a5) {
    CFDataRef v39 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a5, @"aad");
  }
  ccaes_gcm_encrypt_mode();
  CFDataGetBytePtr(v36);
  if (v39)
  {
    CFDataGetLength(v39);
    CFDataGetBytePtr(v39);
  }
  CFDataGetLength(theData);
  CFDataGetBytePtr(theData);
  uint64_t v43 = ccgcm_one_shot();
  if (v43)
  {
    SecError(-50, a6, @"ECIES: Failed to aes-gcm encrypt data (err %d)", v43, v46, 16, &v46[v42], 0);
    CFTypeRef v37 = 0;
  }
  else
  {
    CFTypeRef v37 = CFRetain(MutableCopy);
  }
  SecKeyRef v11 = v48;
  CFDataRef v33 = v50;
  CFDictionaryRef v13 = v45;
  if (!v45) {
    goto LABEL_23;
  }
LABEL_22:
  CFRelease(v13);
LABEL_23:
  if (v30) {
    CFRelease(v30);
  }
  if (v32) {
    CFRelease(v32);
  }
  if (v33) {
    CFRelease(v33);
  }
  if (v34) {
    CFRelease(v34);
  }
  if (v36) {
    CFRelease(v36);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
LABEL_35:
  *(void *)a1 = v11;
  return v37;
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorVariableIVX963SHA384(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA384", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorVariableIVX963SHA256(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA256", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorVariableIVX963SHA224(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA224", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardVariableIVX963SHA512(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA512", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardVariableIVX963SHA384(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA384", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardVariableIVX963SHA256(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA256", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardVariableIVX963SHA224(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA224", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA512(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA512", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA384(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA384", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA256(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA256", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA224(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA224", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA1(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA1", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA512(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA512", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA384(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA384", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA256(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA256", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA224(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA224", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA1(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA1", 0, a2, a3, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA512AESGCM(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA512", a2, a4);
}

void *SecKeyRSAAESGCMCopyEncryptedData(uint64_t a1, const void *a2, const __CFData *a3, __CFString **a4)
{
  CFDictionaryRef v8 = SecKeyCopyAttributes(*(SecKeyRef *)a1);
  if (!v8)
  {
    SecError(-50, a4, @"Unable to export key parameters");
    return 0;
  }
  CFDictionaryRef v9 = v8;
  CFDataRef Value = CFDictionaryGetValue(v8, @"type");
  if (!CFEqual(Value, @"42") || (SecKeyRef v11 = CFDictionaryGetValue(v9, @"kcls"), !CFEqual(v11, @"0")))
  {
    CFDictionaryRef v27 = (void *)*MEMORY[0x1E4F1D260];
LABEL_25:
    CFDictionaryRef v28 = v9;
    goto LABEL_19;
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  if (*(void *)(a1 + 24))
  {
    CFDictionaryRef v27 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0, 0, a4);
    goto LABEL_25;
  }
  CFDataRef v12 = SecKeyCopyExternalRepresentation(*(SecKeyRef *)a1, (CFErrorRef *)a4);
  if (!v12)
  {
    CFDictionaryRef v27 = 0;
    goto LABEL_25;
  }
  CFDataRef v13 = v12;
  CFStringRef v14 = (const __CFString *)CFDictionaryGetValue(v9, @"bsiz");
  if (SecKeyGetCFIndexFromRef(v14) <= 4095) {
    size_t v15 = 16;
  }
  else {
    size_t v15 = 32;
  }
  CFDataRef v16 = (const __CFData *)CFDataCreateWithRandomBytes(v15);
  if (v16)
  {
    CFAllocatorRef v17 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, v16, 0, a4);
    CFDataRef v18 = v17;
    if (v17)
    {
      CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFIndex Length = CFDataGetLength(v17);
      CFIndex v21 = Length + CFDataGetLength(a3) + 16;
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(v19, 0);
      CFDataSetLength(Mutable, v21);
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      v30.CFIndex length = CFDataGetLength(v18);
      v30.location = 0;
      CFDataGetBytes(v18, v30, MutableBytePtr);
      int v24 = &MutableBytePtr[CFDataGetLength(v18)];
      CFIndex v25 = (CFIndex)&v24[CFDataGetLength(a3)];
      ccaes_gcm_encrypt_mode();
      CFDataGetLength(v16);
      CFDataGetBytePtr(v16);
      CFDataGetLength(v13);
      CFDataGetBytePtr(v13);
      CFDataGetLength(a3);
      CFDataGetBytePtr(a3);
      uint64_t v26 = ccgcm_one_shot();
      if (v26)
      {
        SecError(-50, a4, @"RSAWRAP: Failed to aes-gcm encrypt data (err %d)", v26, v24, 16, v25);
        CFDictionaryRef v27 = 0;
      }
      else
      {
        CFDictionaryRef v27 = (void *)CFRetain(Mutable);
      }
    }
    else
    {
      CFDictionaryRef v27 = 0;
      CFMutableDictionaryRef Mutable = 0;
    }
  }
  else
  {
    SecError(-50, a4, @"Failed to generate session key");
    CFDictionaryRef v27 = 0;
    CFMutableDictionaryRef Mutable = 0;
    CFDataRef v18 = 0;
  }
  CFRelease(v9);
  CFRelease(v13);
  if (v18) {
    CFRelease(v18);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (Mutable)
  {
    CFDictionaryRef v28 = Mutable;
LABEL_19:
    CFRelease(v28);
  }
  return v27;
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA384AESGCM(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA384", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA256AESGCM(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA256", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA224AESGCM(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA224", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA1AESGCM(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA1", a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha512_di();

  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA384(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha384_di();

  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA256(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha256_di();

  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha224_di();

  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha1_di();

  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureRFC4754(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:ECDSA:digest-RFC4754");

  return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA512(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(a1, @"algid:sign:ECDSA:digest-X962:SHA512", a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(uint64_t a1, const void *a2, const __CFData *a3, const __CFData *a4, __CFString **a5)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  if (*(void *)(a1 + 24) != 1)
  {
    uint64_t v10 = *(void *)a1;
    uint64_t v11 = _SecKeyCheck(*(void *)a1, (uint64_t)"SecKeyGetBlockSize");
    CFDataRef v12 = *(uint64_t (**)(uint64_t))(*(void *)(v10 + 16) + 80);
    CFDataRef v21 = a3;
    if (v12)
    {
      uint64_t v13 = v12(v10);
      unint64_t v14 = (8 * ((unint64_t)(v13 + 7) >> 3) + 15) & 0xFFFFFFFFFFFFFFF0;
      uint64_t v11 = MEMORY[0x1F4188790](v13);
      if (v15 > 7)
      {
        CFDataRef v16 = memset((char *)&v20 - v14, 170, ((v13 - 1) & 0xFFFFFFFFFFFFFFF8) + 8);
        MEMORY[0x1F4188790](v16);
        memset((char *)&v20 - v14, 170, ((v13 - 1) & 0xFFFFFFFFFFFFFFF8) + 8);
LABEL_10:
        CFDataGetBytePtr(a4);
        if (CFDataGetLength(a4) != 2 * v13 || ccn_read_uint() || ccn_read_uint())
        {
          SecError(-67808, a5, @"Wrong ECDSA RFC4754 signature");
        }
        else
        {
          ccder_sizeof_integer();
          ccder_sizeof_integer();
          CFIndex v18 = ccder_sizeof();
          CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
          CFDataSetLength(Mutable, v18);
          CFDataGetMutableBytePtr(Mutable);
          ccder_encode_integer();
          ccder_encode_integer();
          if (ccder_encode_constructed_tl())
          {
            if (Mutable)
            {
              CFAllocatorRef v17 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, v21, Mutable, a5);
              CFRelease(Mutable);
              return v17;
            }
          }
          else
          {
            SecError(-26276, a5, @"Failed to encode X962 signature");
            if (Mutable) {
              CFRelease(Mutable);
            }
          }
        }
        return 0;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    MEMORY[0x1F4188790](v11);
    goto LABEL_10;
  }

  return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0, 0, a5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA384(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(a1, @"algid:sign:ECDSA:digest-X962:SHA384", a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA256(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(a1, @"algid:sign:ECDSA:digest-X962:SHA256", a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA224(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(a1, @"algid:sign:ECDSA:digest-X962:SHA224", a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA1(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(a1, @"algid:sign:ECDSA:digest-X962:SHA1", a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(a1, @"algid:sign:ECDSA:digest-X962", a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:ECDSA:digest-RFC4754:SHA512");
  CFDictionaryRef v8 = (size_t *)ccsha512_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA384(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:ECDSA:digest-RFC4754:SHA384");
  CFDictionaryRef v8 = (size_t *)ccsha384_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA256(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:ECDSA:digest-RFC4754:SHA256");
  CFDictionaryRef v8 = (size_t *)ccsha256_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:ECDSA:digest-RFC4754:SHA224");
  CFDictionaryRef v8 = (size_t *)ccsha224_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:ECDSA:digest-RFC4754:SHA1");
  CFDictionaryRef v8 = (size_t *)ccsha1_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureDigestX962SHA512(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  CFDictionaryRef v8 = (void *)ccsha512_di();

  return SecKeyCopyECDSASignatureForDigest(a1, a2, a3, @"algid:sign:ECDSA:digest-X962:SHA512", v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureDigestX962SHA224(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  CFDictionaryRef v8 = (void *)ccsha224_di();

  return SecKeyCopyECDSASignatureForDigest(a1, a2, a3, @"algid:sign:ECDSA:digest-X962:SHA224", v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureDigestX962SHA1(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  CFDictionaryRef v8 = (void *)ccsha1_di();

  return SecKeyCopyECDSASignatureForDigest(a1, a2, a3, @"algid:sign:ECDSA:digest-X962:SHA1", v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageX962SHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:ECDSA:digest-X962:SHA512");
  CFDictionaryRef v8 = (size_t *)ccsha512_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageX962SHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:ECDSA:digest-X962:SHA224");
  CFDictionaryRef v8 = (size_t *)ccsha224_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageX962SHA1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:ECDSA:digest-X962:SHA1");
  CFDictionaryRef v8 = (size_t *)ccsha1_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:RSA:digest-PSS:SHA512:SHA512:64");
  CFDictionaryRef v8 = (size_t *)ccsha512_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA384(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:RSA:digest-PSS:SHA384:SHA384:48");
  CFDictionaryRef v8 = (size_t *)ccsha384_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA256(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:RSA:digest-PSS:SHA256:SHA256:32");
  CFDictionaryRef v8 = (size_t *)ccsha256_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:RSA:digest-PSS:SHA224:SHA224:24");
  CFDictionaryRef v8 = (size_t *)ccsha224_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:RSA:digest-PSS:SHA1:SHA1:20");
  CFDictionaryRef v8 = (size_t *)ccsha1_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15MD5(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:RSA:digest-PKCS1v15:MD5");
  CFDictionaryRef v8 = (size_t *)ccmd5_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15SHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:RSA:digest-PKCS1v15:SHA512");
  CFDictionaryRef v8 = (size_t *)ccsha512_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15SHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:RSA:digest-PKCS1v15:SHA224");
  CFDictionaryRef v8 = (size_t *)ccsha224_di();

  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA512(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA512_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  void v5[4] = a1;
  void v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA384(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA384_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  void v5[4] = a1;
  void v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA256(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA256_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  void v5[4] = a1;
  void v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA224(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA224_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  void v5[4] = a1;
  void v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA1(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA1_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  void v5[4] = a1;
  void v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15MD5(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15MD5_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  void v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15Raw(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15Raw_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  void v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA512(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA512_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  void v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA224(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA224_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  void v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureRaw(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureRaw_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  void v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA512(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(a1, @"algid:sign:ECDSA:digest-X962:SHA512", a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(uint64_t a1, const void *a2, const __CFData *a3, const __CFData *a4, __CFString **a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  if (*(void *)(a1 + 24) != 1)
  {
    uint64_t v10 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, a3, a4, a5);
    CFDataRef v11 = v10;
    if (!v10 || CFEqual(v10, (CFTypeRef)*MEMORY[0x1E4F1D260])) {
      return v11;
    }
    uint64_t v12 = *(void *)a1;
    uint64_t v13 = _SecKeyCheck(v12, (uint64_t)"SecKeyGetBlockSize");
    unint64_t v14 = *(uint64_t (**)(uint64_t))(*(void *)(v12 + 16) + 80);
    if (v14)
    {
      uint64_t v15 = v14(v12);
      unint64_t v16 = (8 * ((unint64_t)(v15 + 7) >> 3) + 15) & 0xFFFFFFFFFFFFFFF0;
      uint64_t v13 = MEMORY[0x1F4188790](v15);
      if (v17 > 7)
      {
        CFIndex v18 = memset(&v22[-v16], 170, ((v15 - 1) & 0xFFFFFFFFFFFFFFF8) + 8);
        MEMORY[0x1F4188790](v18);
        memset(&v22[-v16], 170, ((v15 - 1) & 0xFFFFFFFFFFFFFFF8) + 8);
LABEL_12:
        BytePtr = CFDataGetBytePtr(v11);
        uint64_t v20 = &BytePtr[CFDataGetLength(v11)];
        if ((const UInt8 *)ccder_decode_seqii() == v20)
        {
          CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
          CFDataSetLength(Mutable, 2 * v15);
          CFDataGetMutableBytePtr(Mutable);
          ccn_write_uint_padded();
          ccn_write_uint_padded();
        }
        else
        {
          SecError(-50, a5, @"Wrong ECDSA X962 signature");
          CFMutableDictionaryRef Mutable = 0;
        }
        CFRelease(v11);
        return Mutable;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    MEMORY[0x1F4188790](v13);
    goto LABEL_12;
  }

  return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0, 0, a5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA384(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(a1, @"algid:sign:ECDSA:digest-X962:SHA384", a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA256(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(a1, @"algid:sign:ECDSA:digest-X962:SHA256", a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA224(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(a1, @"algid:sign:ECDSA:digest-X962:SHA224", a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA1(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(a1, @"algid:sign:ECDSA:digest-X962:SHA1", a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(a1, @"algid:sign:ECDSA:digest-X962", a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureRawCCUnit(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:RSA:raw");

  return SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureRaw(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:RSA:raw-cc");

  return SecKeyAlgorithmAdaptorCopyBigEndianToCCUnit((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha512_di();

  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA384(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha384_di();

  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA256(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha256_di();

  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha224_di();

  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha1_di();

  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15MD5(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccmd5_di();

  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15Raw(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, 0);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha512_di();

  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA384(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha384_di();

  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha224_di();

  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  unint64_t v7 = (void *)ccsha1_di();

  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

uint64_t SecOTRFullDHKeyGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecOTRFullDHKeyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_11856;
  block[4] = &SecOTRFullDHKeyGetTypeID_sSecOTRFullDHKeyGetTypeIDSingleton;
  if (SecOTRFullDHKeyGetTypeID_sSecOTRFullDHKeyGetTypeIDOnce != -1) {
    dispatch_once(&SecOTRFullDHKeyGetTypeID_sSecOTRFullDHKeyGetTypeIDOnce, block);
  }
  return SecOTRFullDHKeyGetTypeID_sSecOTRFullDHKeyGetTypeIDSingleton;
}

uint64_t __SecOTRFullDHKeyGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t SecOTRFullDHKeyCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();

  return SecOTRFullDHKeyCopyFormatDescription(a1);
}

uint64_t SecOTRFullDHKeyCopyFormatDescription(uint64_t a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000;
  uint64_t v7 = 0;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = __SecOTRFullDHKeyCopyFormatDescription_block_invoke;
  v3[3] = &unk_1E54812C0;
  void v3[4] = &v4;
  void v3[5] = a1;
  withXandY(a1 + 16, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void __SecOTRFullDHKeyCopyFormatDescription_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  void v4[2] = __SecOTRFullDHKeyCopyFormatDescription_block_invoke_2;
  v4[3] = &unk_1E5481298;
  v4[4] = *(void *)(a1 + 32);
  void v4[5] = v3;
  v4[6] = a2;
  v4[7] = a3;
  BufferPerformWithHexString((UInt8 *)(v3 + 160), 20, (uint64_t)v4);
}

void withXandY(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (const void *)CCNCopyAsHex();
  uint64_t v4 = (const void *)CCNCopyAsHex();
  (*(void (**)(uint64_t, const void *, const void *))(a2 + 16))(a2, v3, v4);
  if (v3) {
    CFRelease(v3);
  }
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t CCNCopyAsHex()
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = ccn_write_uint_size();
  uint64_t v1 = MEMORY[0x1F4188790](v0);
  uint64_t v3 = (UInt8 *)v6 - v2;
  if (v1) {
    memset((char *)v6 - v2, 170, v0);
  }
  ccn_write_uint();
  uint64_t v7 = 0;
  CFDictionaryRef v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v10 = 0;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  v6[2] = __CCNCopyAsHex_block_invoke;
  unint64_t v6[3] = &unk_1E54812E8;
  void v6[4] = &v7;
  BufferPerformWithHexString(v3, v0, (uint64_t)v6);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

CFTypeRef __CCNCopyAsHex_block_invoke(CFTypeRef result, CFTypeRef cf)
{
  uint64_t v3 = (uint64_t)result;
  if (cf) {
    uint64_t result = CFRetain(cf);
  }
  *(void *)(*(void *)(*(void *)(v3 + 32) + 8) + 24) = cf;
  return result;
}

void BufferPerformWithHexString(UInt8 *bytes, CFIndex length, uint64_t a3)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef v5 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, length, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (v5)
  {
    CFDataRef v6 = v5;
    CFIndex v7 = CFDataGetLength(v5);
    CFMutableDictionaryRef Mutable = CFStringCreateMutable(v4, 2 * v7);
    BytePtr = CFDataGetBytePtr(v6);
    CFIndex v10 = CFDataGetLength(v6);
    if (v10 >= 1)
    {
      CFIndex v11 = v10;
      do
      {
        unsigned int v12 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0, @"%02X", v12);
        --v11;
      }
      while (v11);
    }
    (*(void (**)(uint64_t, __CFString *))(a3 + 16))(a3, Mutable);
    CFRelease(Mutable);
  }
  else
  {
    CFDataRef v6 = (const __CFData *)@"(null)";
    (*(void (**)(uint64_t, __CFString *))(a3 + 16))(a3, @"(null)");
  }

  CFRelease(v6);
}

CFStringRef __SecOTRFullDHKeyCopyFormatDescription_block_invoke_2(void *a1, uint64_t a2)
{
  CFStringRef result = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<SecOTRFullDHKeyRef@%p: x: %@ y: %@ [%@]>", a1[5], a1[6], a1[7], a2);
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

BOOL SecOTRFullDHKeyCompare(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 160) == *(void *)(a2 + 160)
      && *(void *)(a1 + 168) == *(void *)(a2 + 168)
      && *(_DWORD *)(a1 + 176) == (unint64_t)*(unsigned int *)(a2 + 176);
}

double SecOTRFullDHKeyDestroy(_OWORD *a1)
{
  double result = 0.0;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t SecOTRFullDHKCreate()
{
  SecOTRFullDHKeyGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  SecFDHKNewKey();
  return Instance;
}

uint64_t SecFDHKNewKey()
{
  ccrng();
  MEMORY[0x18C12DA70]();
  ccec_compact_generate_key();

  return GenerateHashForKey();
}

uint64_t GenerateHashForKey()
{
  uint64_t v0 = cczp_bitlen();
  uint64_t v1 = malloc_type_malloc(((unint64_t)(v0 + 7) >> 2) | 1, 0x128A99DBuLL);
  if (!v1) {
    return 4294899624;
  }
  uint64_t v2 = v1;
  ccec_export_pub();
  ccsha1_di();
  ccdigest();
  free(v2);
  return 0;
}

void *SecOTRFullDHKCreateFromBytes(uint64_t a1, unsigned int **a2, unint64_t *a3)
{
  SecOTRFullDHKeyGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  Instance[2] = MEMORY[0x18C12DA70]();
  if (!a2) {
    goto LABEL_10;
  }
  if (!a3) {
    goto LABEL_10;
  }
  unint64_t v6 = *a3 - 4;
  if (*a3 < 4) {
    goto LABEL_10;
  }
  unint64_t v7 = bswap32(*(*a2)++);
  *a3 = v6;
  if (v6 < v7) {
    goto LABEL_10;
  }
  if (MEMORY[0x18C12DB10]()) {
    goto LABEL_10;
  }
  unint64_t v8 = *a3 - v7;
  *a3 = v8;
  uint64_t v9 = (unsigned int *)((char *)*a2 + v7);
  *a2 = v9;
  if (v8 < 5
    || (unint64_t v10 = bswap32(*v9), *a2 = v9 + 1, v11 = v8 - 4, *a3 = v11, v11 < v10)
    || (ccn_read_uint(), *a2 = (unsigned int *)((char *)*a2 + v10), *a3 -= v10, GenerateHashForKey()))
  {
LABEL_10:
    CFRelease(Instance);
    return 0;
  }
  return Instance;
}

uint64_t SecFDHKAppendSerialization(uint64_t a1, __CFData *a2)
{
  AppendECPublicKeyAsDATA(a2);
  uint64_t v3 = ccn_write_uint_size();
  *(_DWORD *)UInt8 bytes = bswap32(v3);
  CFDataAppendBytes(a2, bytes, 4);
  CFDataGetLength(a2);
  CFDataIncreaseLength(a2, v3);
  CFDataGetMutableBytePtr(a2);
  return ccn_write_uint();
}

uint64_t AppendECPublicKeyAsDATA(__CFData *a1)
{
  uint64_t v2 = cczp_bitlen();
  CFIndex v3 = ((unint64_t)(v2 + 7) >> 2) | 1;
  bytes[0] = (unint64_t)(v2 + 7) >> 26;
  bytes[1] = (unint64_t)(v2 + 7) >> 18;
  bytes[2] = (unint64_t)(v2 + 7) >> 10;
  bytes[3] = ((unint64_t)(v2 + 7) >> 2) | 1;
  CFDataAppendBytes(a1, bytes, 4);
  CFDataGetLength(a1);
  CFDataIncreaseLength(a1, v3);
  CFDataGetMutableBytePtr(a1);
  return ccec_export_pub();
}

uint64_t SecFDHKAppendPublicSerialization(uint64_t a1, __CFData *a2)
{
  uint64_t result = cczp_bitlen();
  if (result == 256)
  {
    return AppendECPublicKeyAsDATA(a2);
  }
  return result;
}

uint64_t SecFDHKAppendCompactPublicSerialization(uint64_t a1, const __CFData *a2)
{
  uint64_t result = cczp_bitlen();
  if (result == 256)
  {
    CFIndex v4 = (unint64_t)(cczp_bitlen() + 7) >> 3;
    CFDataGetLength(a2);
    CFDataIncreaseLength(a2, v4);
    CFDataGetMutableBytePtr(a2);
    return ccec_compact_export();
  }
  return result;
}

uint64_t SecFDHKGetHash(uint64_t a1)
{
  return a1 + 160;
}

uint64_t SecOTRPublicDHKeyGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecOTRPublicDHKeyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_3_11873;
  block[4] = &SecOTRPublicDHKeyGetTypeID_sSecOTRPublicDHKeyGetTypeIDSingleton;
  if (SecOTRPublicDHKeyGetTypeID_sSecOTRPublicDHKeyGetTypeIDOnce != -1) {
    dispatch_once(&SecOTRPublicDHKeyGetTypeID_sSecOTRPublicDHKeyGetTypeIDOnce, block);
  }
  return SecOTRPublicDHKeyGetTypeID_sSecOTRPublicDHKeyGetTypeIDSingleton;
}

uint64_t __SecOTRPublicDHKeyGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t SecOTRPublicDHKeyCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();

  return SecOTRPublicDHKeyCopyFormatDescription(a1);
}

uint64_t SecOTRPublicDHKeyCopyFormatDescription(uint64_t a1)
{
  uint64_t v4 = 0;
  CFDataRef v5 = &v4;
  uint64_t v6 = 0x2000000000;
  uint64_t v7 = 0;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = __SecOTRPublicDHKeyCopyFormatDescription_block_invoke;
  v3[3] = &unk_1E5481338;
  void v3[4] = &v4;
  void v3[5] = a1;
  withXandY(a1 + 16, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void __SecOTRPublicDHKeyCopyFormatDescription_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  void v4[2] = __SecOTRPublicDHKeyCopyFormatDescription_block_invoke_2;
  v4[3] = &unk_1E5481310;
  v4[4] = *(void *)(a1 + 32);
  void v4[5] = v3;
  v4[6] = a2;
  v4[7] = a3;
  BufferPerformWithHexString((UInt8 *)(v3 + 128), 20, (uint64_t)v4);
}

CFStringRef __SecOTRPublicDHKeyCopyFormatDescription_block_invoke_2(void *a1, uint64_t a2)
{
  CFStringRef result = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<SecOTRPublicDHKeyRef@%p: x: %@ y: %@ [%@]>", a1[5], a1[6], a1[7], a2);
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

BOOL SecOTRPublicDHKeyCompare(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 128) == *(void *)(a2 + 128)
      && *(void *)(a1 + 136) == *(void *)(a2 + 136)
      && *(_DWORD *)(a1 + 144) == (unint64_t)*(unsigned int *)(a2 + 144);
}

uint64_t SecOTRPublicDHKCreateFromFullKey(uint64_t a1, uint64_t a2)
{
  SecOTRPublicDHKeyGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v4 = *(void **)(a2 + 16);
  a2 += 16;
  memcpy((void *)(Instance + 16), (const void *)a2, 24 * *v4 + 16);
  int v5 = *(_DWORD *)(a2 + 160);
  *(_OWORD *)(Instance + 128) = *(_OWORD *)(a2 + 144);
  *(_DWORD *)(Instance + 144) = v5;
  return Instance;
}

char *SecOTRPublicDHKCreateFromSerialization(uint64_t a1, unsigned int **a2, unint64_t *a3)
{
  uint64_t v3 = 0;
  if (a2 && a3)
  {
    unint64_t v4 = *a3 - 4;
    if (*a3 >= 4 && (v5 = bswap32(**a2), ++*a2, *a3 = v4, v9 = v5, BOOL v6 = v4 >= v5, v7 = v4 - v5, v6))
    {
      *a3 = v7;
      return SecOTRPublicDHKCreateFromBytes(a1, a2, &v9);
    }
    else
    {
      return 0;
    }
  }
  return (char *)v3;
}

char *SecOTRPublicDHKCreateFromBytes(uint64_t a1, void *a2, void *a3)
{
  SecOTRPublicDHKeyGetTypeID();
  uint64_t Instance = (char *)_CFRuntimeCreateInstance();
  uint64_t v6 = MEMORY[0x18C12DA70]();
  if (MEMORY[0x18C12DB10](v6, *a3, *a2, Instance + 16)
    || (*a2 += *a3, *a3 = 0, GenerateHashForKey()))
  {
    if (Instance)
    {
      CFRelease(Instance);
      return 0;
    }
  }
  return Instance;
}

const void *SecOTRPublicDHKCreateFromCompactSerialization(uint64_t a1, void *a2, unint64_t *a3)
{
  SecOTRPublicDHKeyGetTypeID();
  uint64_t Instance = (const void *)_CFRuntimeCreateInstance();
  MEMORY[0x18C12DA70]();
  unint64_t v6 = (unint64_t)(cczp_bitlen() + 7) >> 3;
  if (v6 > *a3 || ccec_compact_import_pub() || (*a3 -= v6, *a2 += v6, GenerateHashForKey()))
  {
    if (Instance)
    {
      CFRelease(Instance);
      return 0;
    }
  }
  return Instance;
}

uint64_t SecPDHKAppendSerialization(uint64_t a1, __CFData *a2)
{
  return AppendECPublicKeyAsDATA(a2);
}

uint64_t SecPDHKAppendCompactSerialization(uint64_t a1, __CFData *a2)
{
  return AppendECPublicKeyAsDATA(a2);
}

uint64_t SecPDHKGetHash(uint64_t a1)
{
  return a1 + 128;
}

uint64_t SecPDHKeyGenerateS()
{
  return ccec_compute_key();
}

BOOL SecDHKIsGreater()
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  size_t v0 = ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
  unint64_t v1 = ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
  if (v0 == v1)
  {
    if (v0 < 0x42)
    {
      char v13 = -86;
      *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v11 = v5;
      long long v12 = v5;
      *(_OWORD *)long long buf = v5;
      long long v10 = v5;
      char v8 = -86;
      _DWORD v7[2] = v5;
      unint64_t v7[3] = v5;
      v7[0] = v5;
      v7[1] = v5;
      ccec_export_pub();
      ccec_export_pub();
      int v4 = memcmp(buf, v7, v0);
    }
    else
    {
      uint64_t v2 = secLogObjForScope("SecError");
      BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
      int v4 = 0;
      if (v3)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEFAULT, "The size of an SecOTRDHKey is larger than 65 bytes.                      This is not supported in SecOTR and will result in malformed ciphertexts.", buf, 2u);
        int v4 = 0;
      }
    }
  }
  else if (v1 < v0)
  {
    int v4 = -1;
  }
  else
  {
    int v4 = 1;
  }
  return v4 > 0;
}

void SecOTRDHKGenerateOTRKeys(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v26 = v11;
  long long v27 = v11;
  long long v24 = v11;
  long long v25 = v11;
  long long v22 = v11;
  long long v23 = v11;
  long long v20 = v11;
  long long v21 = v11;
  long long v18 = v11;
  long long v19 = v11;
  long long v16 = v11;
  long long v17 = v11;
  ccn_zero();
  *(void *)UInt8 bytes = 192;
  ccec_compute_key();
  if (SecDHKIsGreater()) {
    UInt8 v12 = 1;
  }
  else {
    UInt8 v12 = 2;
  }
  bytes[0] = v12;
  CFDataAppendBytes(Mutable, bytes, 1);
  uint64_t v13 = ccn_write_uint_size();
  *(_DWORD *)UInt8 bytes = bswap32(v13);
  CFDataAppendBytes(Mutable, bytes, 4);
  CFDataGetLength(Mutable);
  CFDataIncreaseLength(Mutable, v13);
  CFDataGetMutableBytePtr(Mutable);
  ccn_write_uint();
  ccn_zero();
  DeriveKeys((uint64_t)Mutable, a5, a6);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  *MutableBytePtr ^= 3u;
  DeriveKeys((uint64_t)Mutable, a3, a4);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

uint64_t DeriveKeys(uint64_t result, unint64_t a2, uint64_t a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (a2 | a3)
  {
    CFDataRef v5 = (const __CFData *)result;
    memset(v6, 170, sizeof(v6));
    ccsha1_di();
    CFDataGetLength(v5);
    CFDataGetBytePtr(v5);
    CFStringRef result = ccdigest();
    if (a2) {
      *(_OWORD *)a2 = *(_OWORD *)v6;
    }
    if (a3)
    {
      ccsha1_di();
      return ccdigest();
    }
  }
  return result;
}

double __EnsureOTRAlgIDInited_block_invoke()
{
  double result = *(double *)&CSSMOID_ECDSA_WithSHA1.Length;
  EnsureOTRAlgIDInited_kOTRECSignatureAlgID = (__int128)CSSMOID_ECDSA_WithSHA1;
  kOTRSignatureAlgIDPtr = (uint64_t)&EnsureOTRAlgIDInited_kOTRECSignatureAlgID;
  return result;
}

uint64_t SecOTRFullIdentityGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecOTRFullIdentityGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_2_11886;
  block[4] = &SecOTRFullIdentityGetTypeID_sSecOTRFullIdentityGetTypeIDSingleton;
  if (SecOTRFullIdentityGetTypeID_sSecOTRFullIdentityGetTypeIDOnce != -1) {
    dispatch_once(&SecOTRFullIdentityGetTypeID_sSecOTRFullIdentityGetTypeIDOnce, block);
  }
  return SecOTRFullIdentityGetTypeID_sSecOTRFullIdentityGetTypeIDSingleton;
}

uint64_t __SecOTRFullIdentityGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef SecOTRFullIdentityCopyDescription(unsigned __int8 *a1)
{
  SecGetDebugDescriptionFormatOptions();

  return SecOTRFullIdentityCopyFormatDescription(a1);
}

CFStringRef SecOTRFullIdentityCopyFormatDescription(unsigned __int8 *a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<SecOTRPublicIdentity: %p %02x%02x%02x%02x%02x%02x%02x%02x>", a1, a1[41], a1[42], a1[43], a1[44], a1[45], a1[46], a1[47], a1[48]);
}

void SecOTRFullIdentityDestroy(void *a1)
{
  uint64_t v2 = (const void *)a1[3];
  if (v2)
  {
    a1[3] = 0;
    CFRelease(v2);
  }
  BOOL v3 = (const void *)a1[2];
  if (v3)
  {
    a1[2] = 0;
    CFRelease(v3);
  }
  int v4 = (const void *)a1[4];
  if (v4)
  {
    a1[4] = 0;
    CFRelease(v4);
  }
}

uint64_t SecOTRFullIdentityCreate(const __CFAllocator *a1, __CFString **a2)
{
  keys[5] = *(void **)MEMORY[0x1E4F143B8];
  SecKeyRef privateKey = 0;
  SecKeyRef publicKey = 0;
  int valuePtr = 256;
  CFNumberRef v4 = CFNumberCreate(a1, kCFNumberIntType, &valuePtr);
  keys[0] = @"type";
  keys[1] = @"bsiz";
  keys[2] = @"perm";
  keys[3] = @"pdmn";
  keys[4] = @"labl";
  values[0] = @"73";
  values[1] = v4;
  values[2] = *(void **)MEMORY[0x1E4F1CFD0];
  values[3] = @"dku";
  values[4] = @"OTR Signing Key";
  CFDictionaryRef v5 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, 5, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v4) {
    CFRelease(v4);
  }
  if (SecKeyGeneratePair(v5, &publicKey, &privateKey))
  {
    unint64_t v9 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v10 = 0;
      _os_log_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEFAULT, "keygen failed", v10, 2u);
    }
  }
  else
  {
    SecOTRFIPurgeFromKeychainByValue(publicKey);
    if (v5) {
      CFRelease(v5);
    }
  }
  SecKeyRef v6 = privateKey;
  uint64_t v7 = SecOTRFullIdentityCreateFromSecKeyRefSOS((uint64_t)a1, privateKey, a2);
  if (v6) {
    CFRelease(v6);
  }
  return v7;
}

uint64_t SecOTRFIPurgeFromKeychainByValue(void *a1)
{
  keys[3] = *(void **)MEMORY[0x1E4F143B8];
  keys[0] = @"class";
  keys[1] = @"labl";
  keys[2] = @"v_Ref";
  values[0] = @"keys";
  values[1] = @"OTR Signing Key";
  values[2] = a1;
  CFDictionaryRef v1 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, 0, 0);
  uint64_t v2 = SecItemDelete(v1);
  if (v1) {
    CFRelease(v1);
  }
  return v2;
}

uint64_t SecOTRFullIdentityCreateFromSecKeyRefSOS(uint64_t a1, void *a2, __CFString **a3)
{
  uint64_t v5 = SecOTRFullIdentityCreateFromSecKeyRef(a1, a2, a3);
  CFTypeRef v15 = 0;
  uint64_t v12 = SecKeyCopyPersistentRef((uint64_t)a2, &v15, v6, v7, v8, v9, v10, v11);
  if (v12) {
    SecError(v12, a3, @"failed to find persistent ref for key: %d", v12);
  }
  CFTypeRef v13 = v15;
  *(void *)(v5 + 32) = v15;
  if (v13)
  {
    *(unsigned char *)(v5 + 40) = 0;
  }
  else
  {
    CFRelease((CFTypeRef)v5);
    return 0;
  }
  return v5;
}

uint64_t SecOTRFullIdentityCreateFromSecKeyRef(uint64_t a1, void *a2, __CFString **a3)
{
  SecOTRFullIdentityGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  int v6 = *(const void **)(Instance + 24);
  if (v6 != a2)
  {
    if (!a2 || (CFRetain(a2), (int v6 = *(const void **)(Instance + 24)) != 0)) {
      CFRelease(v6);
    }
    *(void *)(Instance + 24) = a2;
  }
  SecKeyRef v7 = SecKeyCopyPublicKey((SecKeyRef)a2);
  *(void *)(Instance + 16) = v7;
  if (!v7)
  {
    SecError(-2070, a3, @"Failed to extract public key from private key");
    goto LABEL_10;
  }
  *(void *)(Instance + 32) = 0;
  *(unsigned char *)(Instance + 40) = 1;
  if (!SecOTRFICachePublicHash(Instance, (CFErrorRef *)a3))
  {
LABEL_10:
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

BOOL SecOTRFICachePublicHash(uint64_t a1, CFErrorRef *a2)
{
  BOOL v3 = SecOTRPublicIdentityCopyFromPrivate(0, a1, a2);
  CFNumberRef v4 = v3;
  if (v3)
  {
    long long v5 = *(_OWORD *)((char *)v3 + 25);
    *(_DWORD *)(a1 + 57) = *(_DWORD *)((char *)v3 + 41);
    *(_OWORD *)(a1 + 41) = v5;
    CFRelease(v3);
  }
  return v4 != 0;
}

uint64_t SecOTRFullIdentityCreateFromBytes(const __CFAllocator *a1, const UInt8 **a2, unint64_t *a3, __CFString **a4)
{
  SecOTRFullIdentityGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (EnsureOTRAlgIDInited_kSignatureAlgID_ONCE != -1) {
    dispatch_once(&EnsureOTRAlgIDInited_kSignatureAlgID_ONCE, &__block_literal_global_11882);
  }
  unint64_t v9 = *a3;
  if (!*a3) {
    goto LABEL_28;
  }
  int v10 = *a2;
  int v11 = **a2;
  switch(v11)
  {
    case 3:
      *a2 = v10 + 1;
      *a3 = v9 - 1;
      BOOL v16 = v9 >= 3;
      unint64_t v17 = v9 - 3;
      if (v16)
      {
        CFIndex v18 = __rev16(*(unsigned __int16 *)(v10 + 1));
        *a3 = v17;
        *a2 = v10 + 3;
        LODWORD(valuePtr) = 256;
        CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
        CFDataRef v20 = CFDataCreate(a1, *a2, v18);
        CFDictionaryRef v28 = CFDictionaryCreateForCFTypes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v21, v22, v23, v24, v25, v26, v27, @"type", @"73");
        CFErrorRef error = (CFErrorRef)0xAAAAAAAAAAAAAAAALL;
        id v29 = SecKeyCreateWithData(v20, v28, &error);
        if (v28) {
          CFRelease(v28);
        }
        if (v20) {
          CFRelease(v20);
        }
        if (v19) {
          CFRelease(v19);
        }
        if (v29)
        {
          *(unsigned char *)(Instance + 40) = 1;
          *(void *)(Instance + 24) = v29;
          *(void *)(Instance + 32) = 0;
          *(void *)(Instance + 16) = SecKeyCopyPublicKey(v29);
          goto LABEL_23;
        }
        CFRelease(error);
      }
      SecError(-67673, a4, @"failed to decode v3 otr session: %d", 4294899623);
      goto LABEL_28;
    case 2:
      *a2 = v10 + 1;
      *a3 = v9 - 1;
      CFDataRef valuePtr = 0;
      CFErrorRef error = 0;
      uint64_t v30 = SecOTRFICreatePrivateKeyReadPersistentRef(a2, a3, (CFTypeRef *)&error, &valuePtr);
      if (v30)
      {
        uint64_t v38 = v30;
      }
      else
      {
        ECPublicKeyFrom = CreateECPublicKeyFrom(a2, a3);
        *(void *)(Instance + 16) = ECPublicKeyFrom;
        if (ECPublicKeyFrom)
        {
          CFDataRef v32 = valuePtr;
          *(void *)(Instance + 24) = error;
          *(void *)(Instance + 32) = v32;
          *(unsigned char *)(Instance + 40) = 0;
LABEL_23:
          if (!SecOTRFICachePublicHash(Instance, (CFErrorRef *)a4)) {
            goto LABEL_29;
          }
          return Instance;
        }
        uint64_t v38 = 4294965226;
      }
      if (error) {
        CFRelease(error);
      }
      if (valuePtr) {
        CFRelease(valuePtr);
      }
      CFDataRef v39 = *(const void **)(Instance + 32);
      if (v39)
      {
        *(void *)(Instance + 32) = 0;
        CFRelease(v39);
      }
      int v40 = *(const void **)(Instance + 16);
      if (v40)
      {
        *(void *)(Instance + 16) = 0;
        CFRelease(v40);
      }
      CFIndex v41 = *(const void **)(Instance + 24);
      if (v41)
      {
        *(void *)(Instance + 24) = 0;
        CFRelease(v41);
      }
      SecError(v38, a4, @"failed to decode v2 otr session: %d", v38);
      goto LABEL_29;
    case 1:
      *a2 = v10 + 1;
      *a3 = v9 - 1;
      CFDataRef valuePtr = 0;
      CFErrorRef error = 0;
      uint64_t v12 = SecOTRFICreatePrivateKeyReadPersistentRef(a2, a3, (CFTypeRef *)&error, &valuePtr);
      if (v12)
      {
        uint64_t v34 = v12;
        CFErrorRef v13 = error;
      }
      else
      {
        CFErrorRef v13 = error;
        SecKeyRef v14 = SecKeyCopyPublicKey(error);
        *(void *)(Instance + 16) = v14;
        if (v14)
        {
          CFDataRef v15 = valuePtr;
          *(void *)(Instance + 24) = v13;
          *(void *)(Instance + 32) = v15;
          goto LABEL_23;
        }
        uint64_t v34 = 4294965226;
      }
      if (v13) {
        CFRelease(v13);
      }
      if (valuePtr) {
        CFRelease(valuePtr);
      }
      CFDataRef v35 = *(const void **)(Instance + 16);
      if (v35)
      {
        *(void *)(Instance + 16) = 0;
        CFRelease(v35);
      }
      CFDataRef v36 = *(const void **)(Instance + 24);
      if (v36)
      {
        *(void *)(Instance + 24) = 0;
        CFRelease(v36);
      }
      CFTypeRef v37 = *(const void **)(Instance + 32);
      if (v37)
      {
        *(void *)(Instance + 32) = 0;
        CFRelease(v37);
      }
      SecError(v34, a4, @"failed to decode v1 otr session: %d", v34);
      goto LABEL_29;
  }
  SecError(-50, a4, @"unknown otr session version %hhu", **a2);
LABEL_28:
  if (Instance)
  {
LABEL_29:
    SecOTRFIPurgeFromKeychain(Instance, 0);
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

uint64_t SecOTRFICreatePrivateKeyReadPersistentRef(const UInt8 **a1, unint64_t *a2, CFTypeRef *a3, CFDataRef *a4)
{
  if (!a4) {
    return 4294967246;
  }
  uint64_t v5 = 4294967246;
  if (a1)
  {
    if (a2)
    {
      unint64_t v7 = *a2 - 2;
      if (*a2 >= 2)
      {
        int v8 = *a1 + 2;
        unint64_t v9 = __rev16(*(unsigned __int16 *)*a1);
        *a2 = v7;
        *a1 = v8;
        if (v7 >= v9)
        {
          CFDataRef v12 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v8, v9);
          if (v12)
          {
            CFDataRef v19 = v12;
            uint64_t v5 = SecKeyFindWithPersistentRef((uint64_t)v12, a3, v13, v14, v15, v16, v17, v18);
            if (v5)
            {
              CFRelease(v19);
            }
            else
            {
              *a1 += v9;
              *a2 -= v9;
              *a4 = v19;
            }
          }
        }
      }
    }
  }
  return v5;
}

BOOL SecOTRFIPurgeFromKeychain(uint64_t a1, CFErrorRef *a2)
{
  int v3 = SecOTRFIPurgeFromKeychainByValue(*(void **)(a1 + 24));
  int v4 = v3;
  if (v3) {
    SecOTRCreateError(1, v3, @"OSStatus returned in error code", 0, a2);
  }
  return v4 == 0;
}

uint64_t SecOTRFullIdentityCreateFromData(const __CFAllocator *a1, CFDataRef theData, __CFString **a3)
{
  if (!theData) {
    return 0;
  }
  CFIndex Length = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  return SecOTRFullIdentityCreateFromBytes(a1, &BytePtr, (unint64_t *)&Length, a3);
}

BOOL SecOTRFIPurgeAllFromKeychain(CFErrorRef *a1)
{
  keys[3] = *(void **)MEMORY[0x1E4F143B8];
  keys[0] = @"class";
  keys[1] = @"kcls";
  keys[2] = @"labl";
  values[0] = @"keys";
  values[1] = @"1";
  values[2] = @"OTR Signing Key";
  CFDictionaryRef v2 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, 0, 0);
  char v3 = 0;
  int v4 = 500;
  do
  {
    OSStatus v5 = SecItemDelete(v2);
    v3 |= v5 == 0;
    BOOL v6 = v4-- != 0;
  }
  while (!v5 && v4 != 0 && v6);
  if (v2) {
    CFRelease(v2);
  }
  if (v3) {
    int v7 = 0;
  }
  else {
    int v7 = -25300;
  }
  if (v5 == -25300) {
    int v8 = v7;
  }
  else {
    int v8 = v5;
  }
  if (v8) {
    SecOTRCreateError(1, v8, @"OSStatus returned in error code", 0, a1);
  }
  return v8 == 0;
}

BOOL SecOTRFIAppendSerialization(uint64_t a1, CFDataRef theData, CFErrorRef *a3)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    UInt8 v13 = 2;
    CFIndex Length = CFDataGetLength(theData);
    CFDataAppendBytes(theData, &v13, 1);
    appendSizeAndData(*(const __CFData **)(a1 + 32), theData);
    if (!appendPublicOctetsAndSize(*(void *)(a1 + 16), theData)) {
      goto LABEL_5;
    }
LABEL_7:
    CFDataSetLength(theData, Length);
    int v9 = -50;
    SecOTRCreateError(1, -50, @"OSStatus returned in error code", 0, a3);
    return v9 == 0;
  }
  UInt8 bytes = 3;
  CFIndex Length = CFDataGetLength(theData);
  CFDataAppendBytes(theData, &bytes, 1);
  CFErrorRef v11 = 0;
  CFDataRef v7 = SecKeyCopyExternalRepresentation(*(SecKeyRef *)(a1 + 24), &v11);
  if (!v7) {
    goto LABEL_7;
  }
  CFDataRef v8 = v7;
  appendSizeAndData(v7, theData);
  CFRelease(v8);
LABEL_5:
  int v9 = 0;
  return v9 == 0;
}

uint64_t AES_CTR_HighHalf_Transform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  v7[0] = HIBYTE(a3);
  v7[1] = BYTE6(a3);
  _DWORD v7[2] = BYTE5(a3);
  unint64_t v7[3] = BYTE4(a3);
  _OWORD v7[4] = BYTE3(a3);
  void v7[5] = BYTE2(a3);
  void v7[6] = BYTE1(a3);
  v7[7] = a3;
  uint64_t v8 = 0;
  return AES_CTR_Transform(a1, a2, (uint64_t)v7, a4, a5, a6);
}

uint64_t AES_CTR_Transform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = ccaes_ctr_crypt_mode();
  MEMORY[0x1F4188790](v12);
  int v14 = (char *)v18 - v13;
  if (v15 >= 0x10)
  {
    int v16 = (void *)((char *)v18 - v13);
    do
    {
      *int v16 = 0xAAAAAAAAAAAAAAAALL;
      v16[1] = 0xAAAAAAAAAAAAAAAALL;
      v16 += 2;
      v13 -= 16;
    }
    while (v13);
  }
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t))(v12 + 24))(v12, v14, a1, a2, a3);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 40))(v14, a4, a5, a6);
}

uint64_t AES_CTR_IV0_Transform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return AES_CTR_Transform(a1, a2, (uint64_t)&kIVZero, a3, a4, a5);
}

void DeriveOTR256BitsFromS(UInt8 a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
}

void HashMPIWithPrefix(UInt8 a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4)
{
  UInt8 bytes = a1;
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFDataAppendBytes(Mutable, &bytes, 1);
  uint64_t v6 = ccn_write_uint_size();
  *(_DWORD *)int v10 = bswap32(v6);
  CFDataAppendBytes(Mutable, v10, 4);
  CFDataGetLength(Mutable);
  CFDataIncreaseLength(Mutable, v6);
  CFDataGetMutableBytePtr(Mutable);
  ccn_write_uint();
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  CFIndex Length = CFDataGetLength(Mutable);
  CC_SHA256(MutableBytePtr, Length, a4);
  bzero(MutableBytePtr, Length);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void DeriveOTR128BitPairFromS(UInt8 a1, uint64_t a2, uint64_t a3, unint64_t a4, void *a5, unint64_t a6, void *a7)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[0] = v11;
  v14[1] = v11;
  HashMPIWithPrefix(a1, a2, a3, (unsigned __int8 *)v14);
  if (a5)
  {
    if (a4 >= 0x10) {
      size_t v12 = 16;
    }
    else {
      size_t v12 = a4;
    }
    memcpy(a5, v14, v12);
  }
  if (a7)
  {
    if (a6 >= 0x10) {
      size_t v13 = 16;
    }
    else {
      size_t v13 = a6;
    }
    memcpy(a7, v14, v13);
  }
}

void *DeriveOTR64BitsFromS(UInt8 a1, uint64_t a2, uint64_t a3, unint64_t a4, void *a5)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[0] = v7;
  v10[1] = v7;
  HashMPIWithPrefix(a1, a2, a3, (unsigned __int8 *)v10);
  if (a4 >= 0x10) {
    size_t v8 = 16;
  }
  else {
    size_t v8 = a4;
  }
  return memcpy(a5, v10, v8);
}

void SecOTRAppendDHMessage(uint64_t a1, __CFData *a2)
{
  if (a1)
  {
    CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (Mutable)
    {
      OSStatus v5 = Mutable;
      *(_WORD *)UInt8 bytes = 512;
      CFDataAppendBytes(a2, bytes, 2);
      UInt8 v12 = 2;
      CFDataAppendBytes(a2, &v12, 1);
      SecFDHKAppendPublicSerialization(*(void *)(a1 + 80), v5);
      CFIndex Length = CFDataGetLength(v5);
      if (Length)
      {
        CFIndex v7 = Length;
        BytePtr = CFDataGetBytePtr(v5);
        *(_DWORD *)size_t v13 = bswap32(v7);
        CFDataAppendBytes(a2, v13, 4);
        CFIndex v9 = CFDataGetLength(a2);
        CFDataIncreaseLength(a2, v7);
        MutableBytePtr = CFDataGetMutableBytePtr(a2);
        AES_CTR_Transform(16, a1 + 40, (uint64_t)&kIVZero, v7, (uint64_t)BytePtr, (uint64_t)&MutableBytePtr[v9]);
        *(_DWORD *)int v14 = 0x20000000;
        CFDataAppendBytes(a2, v14, 4);
        CFDataGetLength(a2);
        CFDataIncreaseLength(a2, 32);
        CFDataGetMutableBytePtr(a2);
        ccsha256_di();
        ccdigest();
      }
      CFRelease(v5);
    }
  }
}

uint64_t SecOTRAppendDHKeyMessage(uint64_t a1, CFMutableDataRef theData)
{
  *(_WORD *)UInt8 bytes = 512;
  CFDataAppendBytes(theData, bytes, 2);
  UInt8 v6 = 10;
  CFDataAppendBytes(theData, &v6, 1);
  return SecFDHKAppendPublicSerialization(*(void *)(a1 + 80), theData);
}

void SecOTRAppendRevealSignatureMessage(uint64_t a1, CFMutableDataRef theData)
{
  *(_WORD *)UInt8 bytes = 512;
  CFDataAppendBytes(theData, bytes, 2);
  UInt8 v6 = 17;
  CFDataAppendBytes(theData, &v6, 1);
  *(_DWORD *)CFIndex v7 = 0x10000000;
  CFDataAppendBytes(theData, v7, 4);
  CFIndex Length = CFDataGetLength(theData);
  CFDataIncreaseLength(theData, 16);
  *(_OWORD *)&CFDataGetMutableBytePtr(theData)[Length] = *(_OWORD *)(a1 + 40);
  AppendMACedEncryptedSignature(a1, 0, theData);
}

void AppendMACedEncryptedSignature(uint64_t a1, int a2, const __CFData *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v34[10] = v5;
  v34[11] = v5;
  v34[8] = v5;
  v34[9] = v5;
  v34[6] = v5;
  v34[7] = v5;
  v34[4] = v5;
  v34[5] = v5;
  v34[2] = v5;
  void v34[3] = v5;
  v34[0] = v5;
  v34[1] = v5;
  ccn_zero();
  *(void *)UInt8 bytes = 192;
  ccec_compute_key();
  CFDataGetLength(a3);
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  size_t v8 = CFDataCreateMutable(v6, 0);
  CFDataRef v9 = CFDataCreateMutable(v6, 0);
  SecFDHKAppendPublicSerialization(*(void *)(a1 + 80), v8);
  AppendECPublicKeyAsDATA(v8);
  CFIndex Length = CFDataGetLength(v8);
  uint64_t v11 = SecOTRPublicIdentityCopyFromPrivate((uint64_t)v6, *(void *)(a1 + 24), 0);
  *(_WORD *)UInt8 bytes = 240;
  CFDataAppendBytes(v8, bytes, 2);
  CFDataRef v12 = CFDataCreateMutable(v6, 0);
  SecOTRPIAppendSerialization((uint64_t)v11, v12, 0);
  CFIndex v13 = CFDataGetLength(v12);
  BytePtr = CFDataGetBytePtr(v12);
  *(_DWORD *)UInt8 bytes = bswap32(v13);
  CFDataAppendBytes(v8, bytes, 4);
  CFDataAppendBytes(v8, BytePtr, v13);
  if (v12) {
    CFRelease(v12);
  }
  if (v11) {
    CFRelease(v11);
  }
  *(_DWORD *)UInt8 bytes = bswap32(*(_DWORD *)(a1 + 72));
  CFDataAppendBytes(v8, bytes, 4);
  CFDataGetLength(v8);
  CFDataGetBytePtr(v8);
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)UInt8 bytes = v15;
  long long v37 = v15;
  if (a2) {
    UInt8 v16 = 4;
  }
  else {
    UInt8 v16 = 2;
  }
  HashMPIWithPrefix(v16, 24, (uint64_t)v34, bytes);
  CFDataGetLength(v9);
  CFDataIncreaseLength(v9, 32);
  CFDataGetMutableBytePtr(v9);
  ccsha256_di();
  cchmac();
  v39.location = 0;
  v39.CFIndex length = Length;
  CFDataDeleteBytes(v8, v39);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t Size = SecKeyGetSize(*(void *)(v17 + 16), 1);
  CFIndex v19 = CFDataGetLength(v9);
  CFDataRef v20 = CFDataGetBytePtr(v9);
  CFIndex v21 = CFDataGetLength(Mutable);
  if ((Size & 0x8000000000000000) == 0)
  {
    CFDataIncreaseLength(Mutable, Size + 1);
    int v22 = &CFDataGetMutableBytePtr(Mutable)[v21];
    *(void *)UInt8 bytes = Size;
    if (!SecKeyDigestAndSign(*(void *)(v17 + 24), (const SecAsn1Oid *)kOTRSignatureAlgIDPtr, v20, v19, v22 + 1, (CFIndex *)bytes))
    {
      uint64_t v23 = *(void *)bytes;
      if (*(void *)bytes <= 0xFFuLL)
      {
        *int v22 = bytes[0];
        v21 += v23 + 1;
      }
    }
  }
  CFDataSetLength(Mutable, v21);
  if (v9) {
    CFRelease(v9);
  }
  CFIndex v24 = CFDataGetLength(Mutable);
  int v25 = CFDataGetBytePtr(Mutable);
  *(_DWORD *)UInt8 bytes = bswap32(v24);
  CFDataAppendBytes(v8, bytes, 4);
  CFDataAppendBytes(v8, v25, v24);
  if (Mutable) {
    CFRelease(Mutable);
  }
  CFIndex v26 = CFDataGetLength(v8);
  CFDataGetLength(a3);
  *(_DWORD *)UInt8 bytes = bswap32(v26);
  CFDataAppendBytes(a3, bytes, 4);
  CFIndex v27 = CFDataGetLength(a3);
  CFDataIncreaseLength(a3, v26);
  CFDictionaryRef v28 = &CFDataGetMutableBytePtr(a3)[v27];
  *(void *)&long long v35 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v35 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v29 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)UInt8 bytes = v29;
  long long v37 = v29;
  HashMPIWithPrefix(1u, 24, (uint64_t)v34, bytes);
  long long v35 = *(_OWORD *)bytes;
  uint64_t v30 = CFDataGetBytePtr(v8);
  AES_CTR_Transform(16, (uint64_t)&v35, (uint64_t)&kIVZero, v26, (uint64_t)v30, (uint64_t)v28);
  long long v35 = 0uLL;
  if (v8) {
    CFRelease(v8);
  }
  CFDataGetMutableBytePtr(a3);
  CFDataGetLength(a3);
  *(void *)&long long v31 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)UInt8 bytes = v31;
  long long v37 = v31;
  if (a2) {
    UInt8 v32 = 5;
  }
  else {
    UInt8 v32 = 3;
  }
  HashMPIWithPrefix(v32, 24, (uint64_t)v34, bytes);
  CFDataGetLength(a3);
  CFDataIncreaseLength(a3, 32);
  CFDataGetMutableBytePtr(a3);
  ccsha256_di();
  cchmac();
  v40.location = CFDataGetLength(a3) - 12;
  v40.CFIndex length = 12;
  CFDataDeleteBytes(a3, v40);
}

void SecOTRAppendSignatureMessage(uint64_t a1, CFMutableDataRef theData)
{
  *(_WORD *)UInt8 bytes = 512;
  CFDataAppendBytes(theData, bytes, 2);
  UInt8 v5 = 18;
  CFDataAppendBytes(theData, &v5, 1);
  AppendMACedEncryptedSignature(a1, 1, theData);
}

uint64_t SecOTRPublicIdentityGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecOTRPublicIdentityGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_11921;
  block[4] = &SecOTRPublicIdentityGetTypeID_sSecOTRPublicIdentityGetTypeIDSingleton;
  if (SecOTRPublicIdentityGetTypeID_sSecOTRPublicIdentityGetTypeIDOnce != -1) {
    dispatch_once(&SecOTRPublicIdentityGetTypeID_sSecOTRPublicIdentityGetTypeIDOnce, block);
  }
  return SecOTRPublicIdentityGetTypeID_sSecOTRPublicIdentityGetTypeIDSingleton;
}

uint64_t __SecOTRPublicIdentityGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef SecOTRPublicIdentityCopyDescription(unsigned __int8 *a1)
{
  SecGetDebugDescriptionFormatOptions();

  return SecOTRPublicIdentityCopyFormatDescription(a1);
}

CFStringRef SecOTRPublicIdentityCopyFormatDescription(unsigned __int8 *a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<SecOTRPublicIdentity: %p %02x%02x%02x%02x%02x%02x%02x%02x>", a1, a1[25], a1[26], a1[27], a1[28], a1[29], a1[30], a1[31], a1[32]);
}

void SecOTRPublicIdentityDestroy(uint64_t a1)
{
  CFDictionaryRef v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    *(void *)(a1 + 16) = 0;
    CFRelease(v2);
  }
}

uint64_t SecOTRAdvertiseHashes(uint64_t result)
{
  sAdvertiseHashes = result;
  return result;
}

void *SecOTRPublicIdentityCopyFromPrivate(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  SecOTRPublicIdentityGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (EnsureOTRAlgIDInited_kSignatureAlgID_ONCE != -1) {
    dispatch_once(&EnsureOTRAlgIDInited_kSignatureAlgID_ONCE, &__block_literal_global_11882);
  }
  CFAllocatorRef v6 = *(const void **)(a2 + 16);
  Instance[2] = v6;
  CFRetain(v6);
  if ((SecOTRPICacheHash((uint64_t)Instance, a3) & 1) == 0)
  {
    CFRelease(Instance);
    return 0;
  }
  return Instance;
}

uint64_t SecOTRPICacheHash(uint64_t a1, CFErrorRef *a2)
{
  CFDataRef Mutable = CFDataCreateMutable(0, 0);
  uint64_t v5 = SecOTRPIAppendSerialization(a1, Mutable, a2);
  if (v5)
  {
    CFDataGetBytePtr(Mutable);
    CFDataGetLength(Mutable);
    CCDigest();
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v5;
}

uint64_t SecOTRPIAppendSerialization(uint64_t a1, CFDataRef theData, CFErrorRef *a3)
{
  CFIndex Length = CFDataGetLength(theData);
  CFDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (appendPublicOctetsAndSize(*(void *)(a1 + 16), Mutable)) {
    goto LABEL_10;
  }
  CFDataGetLength(Mutable);
  ccder_sizeof();
  if (sAdvertiseHashes) {
    ccder_sizeof();
  }
  CFIndex v8 = ccder_sizeof();
  CFDataIncreaseLength(theData, v8);
  CFDataRef v9 = &CFDataGetMutableBytePtr(theData)[Length];
  CFDataGetLength(Mutable);
  CFDataGetBytePtr(Mutable);
  if (sAdvertiseHashes) {
    ccder_encode_implicit_raw_octet_string();
  }
  ccder_encode_implicit_raw_octet_string();
  if ((UInt8 *)ccder_encode_constructed_tl() != v9)
  {
LABEL_10:
    if (Mutable) {
      CFRelease(Mutable);
    }
    CFDataSetLength(theData, Length);
    SecOTRCreateError(0, -10, @"Unable to create public key bytes", 0, a3);
    return 0;
  }
  else
  {
    if (Mutable) {
      CFRelease(Mutable);
    }
    return 1;
  }
}

CFTypeRef *SecOTRPublicIdentityCreateFromSecKeyRef(uint64_t a1, const void *a2, CFErrorRef *a3)
{
  SecOTRPublicIdentityGetTypeID();
  uint64_t Instance = (CFTypeRef *)_CFRuntimeCreateInstance();
  Instance[2] = a2;
  CFRetain(a2);
  if ((SecOTRPICacheHash((uint64_t)Instance, a3) & 1) == 0)
  {
    CFRelease(Instance[2]);
    CFRelease(Instance);
    return 0;
  }
  return Instance;
}

uint64_t SecOTRPublicIdentityCreateFromBytes(uint64_t a1, uint64_t *a2, void *a3, CFErrorRef *a4)
{
  CFTypeRef cf = 0;
  SecOTRPublicIdentityGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (EnsureOTRAlgIDInited_kSignatureAlgID_ONCE != -1) {
    dispatch_once(&EnsureOTRAlgIDInited_kSignatureAlgID_ONCE, &__block_literal_global_11882);
  }
  uint64_t v15 = *a2 + *a3;
  if (!ccder_decode_sequence_tl())
  {
    SecOTRCreateError(0, -9, @"Error creating public identity from bytes", 0, a4);
    if (!Instance) {
      return Instance;
    }
    goto LABEL_24;
  }
  uint64_t v8 = *a2;
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  int v18 = (const UInt8 *)ccder_decode_tl();
  CFDataRef v9 = CreateECPublicKeyFrom(&v18, &v17);
  if (v9) {
    BOOL v10 = v17 == 0;
  }
  else {
    BOOL v10 = 0;
  }
  int v11 = v10;
  if (v9 && (v11 & 1) == 0)
  {
    CFRelease(v9);
    CFTypeRef v14 = 0;
    *(void *)(Instance + 16) = 0;
LABEL_23:
    SecOTRCreateError(0, -9, @"Error creating public identity from bytes", v14, a4);
LABEL_24:
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  if (v11) {
    CFDataRef v12 = v9;
  }
  else {
    CFDataRef v12 = 0;
  }
  *(void *)(Instance + 16) = v12;
  if (!v12)
  {
    CFTypeRef v14 = 0;
    goto LABEL_23;
  }
  *(unsigned char *)(Instance + 24) = ccder_decode_tl() != 0;
  if ((SecOTRPICacheHash(Instance, (CFErrorRef *)&cf) & 1) == 0)
  {
    CFTypeRef v14 = cf;
    goto LABEL_23;
  }
  *a2 += v15 - v8;
  *a3 -= v15 - v8;
  return Instance;
}

uint64_t SecOTRPublicIdentityCreateFromData(uint64_t a1, CFDataRef theData, CFErrorRef *a3)
{
  if (!theData) {
    return 0;
  }
  CFIndex Length = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  return SecOTRPublicIdentityCreateFromBytes(a1, (uint64_t *)&BytePtr, &Length, a3);
}

void __SecOTRPIEqualToBytes_block_invoke(uint64_t a1, uint64_t a2)
{
  CFDataRef v2 = *(const __CFData **)(a1 + 32);
  uint64_t v10 = MEMORY[0x1E4F143A8];
  uint64_t v11 = 0x40000000;
  CFDataRef v12 = __SecOTRPIEqualToBytes_block_invoke_2;
  CFIndex v13 = &__block_descriptor_tmp_5_11945;
  uint64_t v14 = a2;
  if (v2)
  {
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex Length = CFDataGetLength(v2);
    CFDataRef Mutable = CFStringCreateMutable(v3, 2 * Length);
    BytePtr = CFDataGetBytePtr(v2);
    CFIndex v7 = CFDataGetLength(v2);
    if (v7 >= 1)
    {
      CFIndex v8 = v7;
      do
      {
        unsigned int v9 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0, @"%02X", v9, v10, v11);
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    CFDataRef Mutable = @"(null)";
  }
  v12((uint64_t)&v10, (uint64_t)Mutable);
  CFRelease(Mutable);
}

void __SecOTRPIEqualToBytes_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  int v4 = secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "ID Comparison failed: d: %@ id: %@", (uint8_t *)&v6, 0x16u);
  }
}

uint64_t SecOTRPIRecreateSignature(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  unint64_t v15[3] = *MEMORY[0x1E4F143B8];
  __int16 v8 = (uint64_t *)MEMORY[0x18C12DA70]();
  uint64_t v9 = *v8;
  size_t v10 = 8 * *v8;
  MEMORY[0x1F4188790](v8);
  unint64_t v11 = (v10 + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v9)
  {
    CFDataRef v12 = memset((char *)v15 - v11, 170, v10);
    MEMORY[0x1F4188790](v12);
    memset((char *)v15 - v11, 170, v10);
  }
  v15[1] = a1 + a2;
  ccder_decode_sequence_tl();
  mp_decode_forced_uint();
  mp_decode_forced_uint();
  uint64_t v13 = *a3 + *a4;
  ccder_encode_integer();
  ccder_encode_integer();
  uint64_t result = ccder_encode_constructed_tl();
  *a3 = result;
  *a4 = (v13 - result) & ~((v13 - result) >> 63);
  return result;
}

uint64_t mp_decode_forced_uint()
{
  uint64_t result = ccder_decode_tl();
  if (result)
  {
    uint64_t v1 = result;
    if ((ccn_read_uint() & 0x80000000) != 0) {
      return 0;
    }
    else {
      return v1 - 0x5555555555555556;
    }
  }
  return result;
}

void sub_18B3A5CE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_18B3A5DC8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18B3A633C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__12051(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__12052(uint64_t a1)
{
}

id SecRemoteKeyCopyOperationResult(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = (void *)[MEMORY[0x1E4F1CBF0] mutableCopy];
  uint64_t v16 = v15;
  if (a6)
  {
    [v15 addObject:a6];
    if (a7) {
      [v16 addObject:a7];
    }
  }
  uint64_t v21 = 0;
  int v22 = &v21;
  uint64_t v23 = 0x3032000000;
  CFIndex v24 = __Block_byref_object_copy__12051;
  int v25 = __Block_byref_object_dispose__12052;
  id v26 = 0;
  uint64_t v17 = +[SecKeyProxy targetForKey:a1 error:a8];
  v20[0] = MEMORY[0x1E4F143A8];
  v20[1] = 3221225472;
  v20[2] = __SecRemoteKeyCopyOperationResult_block_invoke;
  v20[3] = &unk_1E54815B0;
  void v20[4] = &v21;
  void v20[5] = a8;
  [v17 performOperation:a2 mode:a5 algorithm:a3 parameters:v16 reply:v20];

  id v18 = (id)v22[5];
  _Block_object_dispose(&v21, 8);

  return v18;
}

void sub_18B3A65E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __SecRemoteKeyCopyOperationResult_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v9 = a2;
  id v5 = a3;
  if ([v9 count])
  {
    uint64_t v6 = [v9 objectAtIndexedSubscript:0];
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    __int16 v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else if (*(void *)(a1 + 40))
  {
    **(void **)(a1 + 40) = v5;
  }
}

id SecRemoteKeyCopyPublicKey(uint64_t a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x3032000000;
  __int16 v8 = __Block_byref_object_copy__12051;
  id v9 = __Block_byref_object_dispose__12052;
  id v10 = 0;
  uint64_t v1 = +[SecKeyProxy targetForKey:a1 error:0];
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = __SecRemoteKeyCopyPublicKey_block_invoke;
  v4[3] = &unk_1E5481588;
  v4[4] = &v5;
  [v1 getPublicKey:v4];

  id v2 = (id)v6[5];
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_18B3A678C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __SecRemoteKeyCopyPublicKey_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    *(void *)(*(void *)(*(void *)(result + 32) + 8) + 40) = +[SecKeyProxy createKeyFromEndpoint:a2 error:0];
    return MEMORY[0x1F41817F8]();
  }
  return result;
}

id SecRemoteKeyCopyExternalRepresentation(uint64_t a1, void *a2)
{
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x3032000000;
  id v18 = __Block_byref_object_copy__12051;
  CFIndex v19 = __Block_byref_object_dispose__12052;
  id v20 = 0;
  uint64_t v9 = 0;
  id v10 = &v9;
  uint64_t v11 = 0x3032000000;
  uint64_t v12 = __Block_byref_object_copy__12051;
  uint64_t v13 = __Block_byref_object_dispose__12052;
  id v14 = 0;
  CFAllocatorRef v3 = +[SecKeyProxy targetForKey:a1 error:a2];
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  _DWORD v8[2] = __SecRemoteKeyCopyExternalRepresentation_block_invoke;
  unint64_t v8[3] = &unk_1E5481560;
  v8[4] = &v15;
  void v8[5] = &v9;
  [v3 getExternalRepresentationWithReply:v8];

  int v4 = v16;
  uint64_t v5 = (void *)v16[5];
  if (a2 && !v5)
  {
    *a2 = (id)v10[5];
    uint64_t v5 = (void *)v4[5];
  }
  id v6 = v5;
  _Block_object_dispose(&v9, 8);

  _Block_object_dispose(&v15, 8);
  return v6;
}

void sub_18B3A6968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 80), 8);
  _Unwind_Resume(a1);
}

void __SecRemoteKeyCopyExternalRepresentation_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  __int16 v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v5;
  id v11 = v5;

  uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
  id v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v6;
}

uint64_t SecRemoteKeyGetAlgorithmID(uint64_t a1)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  uint64_t v1 = +[SecKeyProxy targetForKey:a1 error:0];
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = __SecRemoteKeyGetAlgorithmID_block_invoke;
  v4[3] = &unk_1E5481538;
  v4[4] = &v5;
  [v1 getAlgorithmIDWithReply:v4];

  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_18B3A6AD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __SecRemoteKeyGetAlgorithmID_block_invoke(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  return result;
}

id SecRemoteKeyCopyDescription(uint64_t a1)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x3032000000;
  uint64_t v8 = __Block_byref_object_copy__12051;
  uint64_t v9 = __Block_byref_object_dispose__12052;
  id v10 = 0;
  uint64_t v1 = +[SecKeyProxy targetForKey:a1 error:0];
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = __SecRemoteKeyCopyDescription_block_invoke;
  v4[3] = &unk_1E5481510;
  v4[4] = &v5;
  [v1 getDescriptionWithReply:v4];

  id v2 = (id)v6[5];
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_18B3A6BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __SecRemoteKeyCopyDescription_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = [NSString stringWithFormat:@"<SecKeyRef remoteKey: %@>", a2];

  return MEMORY[0x1F41817F8]();
}

uint64_t SecRemoteKeyCopyAttributeDictionary(uint64_t a1)
{
  uint64_t v9 = 0;
  id v10 = &v9;
  uint64_t v11 = 0x3032000000;
  uint64_t v12 = __Block_byref_object_copy__12051;
  uint64_t v13 = __Block_byref_object_dispose__12052;
  id v14 = 0;
  uint64_t v1 = +[SecKeyProxy targetForKey:a1 error:0];
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  _DWORD v8[2] = __SecRemoteKeyCopyAttributeDictionary_block_invoke;
  unint64_t v8[3] = &unk_1E54814E8;
  v8[4] = &v9;
  [v1 getAttributesWithReply:v8];

  CFDataRef v2 = [(id)v10[5] objectForKeyedSubscript:@"accc"];
  if (v2)
  {
    uint64_t v7 = 0;
    CFAllocatorRef v3 = SecAccessControlCreateFromData((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v2, &v7);
    int v4 = (void *)v10[5];
    if (v3) {
      [v4 setObject:v3 forKeyedSubscript:@"accc"];
    }
    else {
      [v4 removeObjectForKey:@"accc"];
    }
  }
  uint64_t v5 = [(id)v10[5] copy];

  _Block_object_dispose(&v9, 8);
  return v5;
}

void sub_18B3A6DE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __SecRemoteKeyCopyAttributeDictionary_block_invoke(uint64_t a1, void *a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = [a2 mutableCopy];

  return MEMORY[0x1F41817F8]();
}

uint64_t SecRemoteKeyBlockSize(uint64_t a1)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  uint64_t v1 = +[SecKeyProxy targetForKey:a1 error:0];
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = __SecRemoteKeyBlockSize_block_invoke;
  v4[3] = &unk_1E54814C0;
  v4[4] = &v5;
  [v1 getBlockSizeWithReply:v4];

  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_18B3A6F14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __SecRemoteKeyBlockSize_block_invoke(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  return result;
}

void SecRemoteKeyDestroy(uint64_t a1)
{
  id v1 = *(id *)(a1 + 24);
  [v1 invalidate];
}

uint64_t SecRemoteKeyInit(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = a2;
  return 0;
}

uint64_t SecOTRSessionGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecOTRSessionGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_12119;
  block[4] = &SecOTRSessionGetTypeID_sSecOTRSessionGetTypeIDSingleton;
  if (SecOTRSessionGetTypeID_sSecOTRSessionGetTypeIDOnce != -1) {
    dispatch_once(&SecOTRSessionGetTypeID_sSecOTRSessionGetTypeIDOnce, block);
  }
  return SecOTRSessionGetTypeID_sSecOTRSessionGetTypeIDSingleton;
}

uint64_t __SecOTRSessionGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef SecOTRSessionCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();

  return SecOTRSessionCopyFormatDescription(a1);
}

CFStringRef SecOTRSessionCopyFormatDescription(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (v3 > 4) {
    int v4 = "InvalidState";
  }
  else {
    int v4 = off_1E54818E0[v3];
  }
  double v5 = *(double *)(a1 + 672);
  id v6 = "e";
  if (v5 != 0.0 && v5 > Current) {
    id v6 = "E";
  }
  uint64_t v8 = "S";
  if (!*(unsigned char *)(a1 + 664)) {
    uint64_t v8 = "s";
  }
  uint64_t v9 = "R";
  id v10 = "M";
  if (!*(unsigned char *)(a1 + 681)) {
    uint64_t v9 = "r";
  }
  if (!*(unsigned char *)(a1 + 680)) {
    id v10 = "m";
  }
  uint64_t v11 = "t";
  if (*(void *)(a1 + 112)) {
    uint64_t v11 = "T";
  }
  if (*(void *)(a1 + 104)) {
    uint64_t v12 = "P";
  }
  else {
    uint64_t v12 = "p";
  }
  if (*(void *)(a1 + 64)) {
    uint64_t v13 = "K";
  }
  else {
    uint64_t v13 = "k";
  }
  if (*(void *)(a1 + 56)) {
    id v14 = "D";
  }
  else {
    id v14 = "d";
  }
  if (*(void *)(a1 + 32)) {
    uint64_t v15 = "P";
  }
  else {
    uint64_t v15 = "p";
  }
  if (*(void *)(a1 + 24)) {
    uint64_t v16 = "F";
  }
  else {
    uint64_t v16 = "f";
  }
  if (*(unsigned char *)(a1 + 650)) {
    uint64_t v17 = "I";
  }
  else {
    uint64_t v17 = "i";
  }
  if (*(unsigned char *)(a1 + 649)) {
    id v18 = "C";
  }
  else {
    id v18 = "c";
  }
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s %s %s %s%s%s%s %d:%d %s%s %llu %s%s%s%s>", Current, v4, v18, v17, v16, v15, v14, v13, *(unsigned int *)(a1 + 72), *(unsigned int *)(a1 + 96), v12, v11, *(void *)(a1 + 656), v10, v9, v8,
           v6);
}

void SecOTRSessionDestroy(void *a1)
{
  uint64_t v2 = (const void *)a1[7];
  if (v2)
  {
    a1[7] = 0;
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[8];
  if (v3)
  {
    a1[8] = 0;
    CFRelease(v3);
  }
  int v4 = (const void *)a1[3];
  if (v4)
  {
    a1[3] = 0;
    CFRelease(v4);
  }
  double v5 = (const void *)a1[10];
  if (v5)
  {
    a1[10] = 0;
    CFRelease(v5);
  }
  id v6 = (const void *)a1[11];
  if (v6)
  {
    a1[11] = 0;
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)a1[4];
  if (v7)
  {
    a1[4] = 0;
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)a1[14];
  if (v8)
  {
    a1[14] = 0;
    CFRelease(v8);
  }
  uint64_t v9 = (const void *)a1[13];
  if (v9)
  {
    a1[13] = 0;
    CFRelease(v9);
  }
  id v10 = (const void *)a1[15];
  if (v10)
  {
    a1[15] = 0;
    CFRelease(v10);
  }
  uint64_t v11 = a1[16];

  dispatch_release(v11);
}

const char *SecOTRPacketTypeString(const __CFData *a1)
{
  if (!a1) {
    return "NoMessage";
  }
  int v1 = SecOTRSGetMessageType(a1);
  if (v1 > 0x1F)
  {
    if (v1 <= 47)
    {
      if (v1 == 32) {
        return "kEvenCompactDatamessage (0x20)";
      }
      if (v1 == 33) {
        return "kOddCompactDataMessage (0x21)";
      }
    }
    else
    {
      switch(v1)
      {
        case 48:
          return "kEvenCompactDatamessage (0x30)";
        case 49:
          return "kOddCompactDataMessage (0x31)";
        case 255:
          return "InvalidMessage (0xFF)";
      }
    }
  }
  else if (v1 <= 9)
  {
    if (v1 == 2) {
      return "DHMessage (0x02)";
    }
    if (v1 == 3) {
      return "DataMessage (0x03)";
    }
  }
  else
  {
    switch(v1)
    {
      case 10:
        return "DHKeyMessage (0x0A)";
      case 17:
        return "RevealSignatureMessage (0x11)";
      case 18:
        return "SignatureMessage (0x12)";
    }
  }
  return "UnknownMessage";
}

uint64_t SecOTRSGetMessageType(const __CFData *a1)
{
  CFDataRef v1 = (const __CFData *)SecOTRCopyIncomingBytes(a1);
  BytePtr = CFDataGetBytePtr(v1);
  if ((unint64_t)CFDataGetLength(v1) > 2 && __rev16(*(unsigned __int16 *)BytePtr) == 2)
  {
    uint64_t v3 = BytePtr[2];
  }
  else
  {
    uint64_t v3 = *CFDataGetBytePtr(v1);
    if (v3 > 0x31 || ((1 << v3) & 0x3000300000000) == 0) {
      uint64_t v3 = 255;
    }
  }
  if (v1) {
    CFRelease(v1);
  }
  return v3;
}

uint64_t SecOTRSGetKeyID(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t SecOTRSGetTheirKeyID(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

void SecOTRSessionReset(dispatch_queue_t *context)
{
}

double SecOTRSessionResetInternal(uint64_t a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  uint64_t v2 = *(const void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 56) = 0;
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 64);
  if (v3)
  {
    *(void *)(a1 + 64) = 0;
    CFRelease(v3);
  }
  *(_DWORD *)(a1 + 72) = 0;
  int v4 = *(const void **)(a1 + 80);
  if (v4)
  {
    *(void *)(a1 + 80) = 0;
    CFRelease(v4);
  }
  double v5 = *(const void **)(a1 + 88);
  if (v5)
  {
    *(void *)(a1 + 88) = 0;
    CFRelease(v5);
  }
  *(_DWORD *)(a1 + 96) = 0;
  id v6 = *(const void **)(a1 + 112);
  if (v6)
  {
    *(void *)(a1 + 112) = 0;
    CFRelease(v6);
  }
  uint64_t v7 = *(const void **)(a1 + 104);
  if (v7)
  {
    *(void *)(a1 + 104) = 0;
    CFRelease(v7);
  }
  uint64_t v8 = *(const void **)(a1 + 120);
  if (v8)
  {
    *(void *)(a1 + 120) = 0;
    CFRelease(v8);
  }
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  double result = 0.0;
  *(_OWORD *)(a1 + 136) = 0u;
  uint64_t v11 = (_OWORD *)(a1 + 136);
  *((void *)v11 - 2) = Mutable;
  v11[1] = 0u;
  _OWORD v11[2] = 0u;
  unint64_t v11[3] = 0u;
  void v11[4] = 0u;
  void v11[5] = 0u;
  v11[6] = 0u;
  v11[7] = 0u;
  v11[8] = 0u;
  v11[9] = 0u;
  v11[10] = 0u;
  v11[11] = 0u;
  v11[12] = 0u;
  v11[13] = 0u;
  v11[14] = 0u;
  v11[15] = 0u;
  v11[16] = 0u;
  v11[17] = 0u;
  v11[18] = 0u;
  v11[19] = 0u;
  v11[20] = 0u;
  v11[21] = 0u;
  v11[22] = 0u;
  v11[23] = 0u;
  v11[24] = 0u;
  v11[25] = 0u;
  v11[26] = 0u;
  v11[27] = 0u;
  v11[28] = 0u;
  v11[29] = 0u;
  v11[30] = 0u;
  v11[31] = 0u;
  return result;
}

uint64_t SecOTRSessionCreateFromID(uint64_t a1, const void *a2, const void *a3)
{
  SecOTRSessionGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (SecOTRGetDefaultsWriteSeconds_sdOnceToken != -1) {
    dispatch_once(&SecOTRGetDefaultsWriteSeconds_sdOnceToken, &__block_literal_global_12165);
  }
  *(void *)(Instance + 128) = dispatch_queue_create("OTRSession", 0);
  if (a2) {
    CFRetain(a2);
  }
  *(void *)(Instance + 24) = a2;
  if (a3) {
    CFRetain(a3);
  }
  *(void *)(Instance + 32) = a3;
  *(_WORD *)(Instance + 648) = 0;
  *(unsigned char *)(Instance + 650) = 0;
  *(void *)(Instance + 672) = 0;
  *(unsigned char *)(Instance + 664) = 0;
  *(void *)(Instance + 656) = 0;
  *(void *)(Instance + 56) = 0;
  *(void *)(Instance + 64) = 0;
  *(void *)(Instance + 80) = 0;
  *(void *)(Instance + 88) = 0;
  *(void *)(Instance + 112) = 0;
  *(void *)(Instance + 120) = 0;
  *(void *)(Instance + 104) = 0;
  *(_WORD *)(Instance + 680) = 1;
  SecOTRSessionResetInternal(Instance);
  id v6 = SecOTRPublicIdentityCopyFromPrivate(*MEMORY[0x1E4F1CF80], *(void *)(Instance + 24), 0);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  _DWORD v8[2] = __SecOTRSessionCreateFromID_block_invoke;
  unint64_t v8[3] = &__block_descriptor_tmp_18_12167;
  v8[4] = Instance;
  SecOTRPIPerformWithSerializationString((uint64_t)v6, (uint64_t)v8);
  if (v6) {
    CFRelease(v6);
  }
  return Instance;
}

void __SecOTRSessionCreateFromID_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 32);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  void v4[2] = __SecOTRSessionCreateFromID_block_invoke_2;
  v4[3] = &__block_descriptor_tmp_17_12175;
  v4[4] = v2;
  void v4[5] = a2;
  SecOTRPIPerformWithSerializationString(v3, (uint64_t)v4);
}

void SecOTRPIPerformWithSerializationString(uint64_t a1, uint64_t a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  SecOTRPIAppendSerialization(a1, Mutable, 0);
  if (Mutable)
  {
    CFIndex Length = CFDataGetLength(Mutable);
    uint64_t v7 = CFStringCreateMutable(v4, 2 * Length);
    BytePtr = CFDataGetBytePtr(Mutable);
    CFIndex v9 = CFDataGetLength(Mutable);
    if (v9 >= 1)
    {
      CFIndex v10 = v9;
      do
      {
        unsigned int v11 = *BytePtr++;
        CFStringAppendFormat(v7, 0, @"%02X", v11);
        --v10;
      }
      while (v10);
    }
    (*(void (**)(uint64_t, __CFString *))(a2 + 16))(a2, v7);
    CFRelease(v7);
  }
  else
  {
    CFDataRef Mutable = (const __CFData *)@"(null)";
    (*(void (**)(uint64_t, __CFString *))(a2 + 16))(a2, @"(null)");
  }

  CFRelease(Mutable);
}

void __SecOTRSessionCreateFromID_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138412802;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    uint64_t v10 = v6;
    __int16 v11 = 2112;
    uint64_t v12 = a2;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "%@ Creating with M: %@, T: %@", (uint8_t *)&v7, 0x20u);
  }
}

CFIndex __SecOTRGetDefaultsWriteSeconds_block_invoke()
{
  keyExistsAndHasValidFormCFAbsoluteTime at = 0;
  CFIndex result = CFPreferencesGetAppIntegerValue(@"OTR", @"com.apple.security", &keyExistsAndHasValidFormat);
  uint64_t v1 = 900;
  if (keyExistsAndHasValidFormat) {
    uint64_t v1 = result;
  }
  SecOTRGetDefaultsWriteSeconds_seconds = v1;
  return result;
}

uint64_t SecOTRSessionCreateFromIDAndFlags(uint64_t a1, const void *a2, const void *a3, char a4)
{
  if (SecOTRGetDefaultsWriteSeconds_sdOnceToken != -1) {
    dispatch_once(&SecOTRGetDefaultsWriteSeconds_sdOnceToken, &__block_literal_global_12165);
  }
  uint64_t v8 = SecOTRGetDefaultsWriteSeconds_seconds;
  uint64_t result = SecOTRSessionCreateFromID(a1, a2, a3);
  if (a4)
  {
    *(unsigned char *)(result + 648) = 1;
    if ((a4 & 2) == 0)
    {
LABEL_5:
      if ((a4 & 4) == 0) {
        goto LABEL_6;
      }
      goto LABEL_11;
    }
  }
  else if ((a4 & 2) == 0)
  {
    goto LABEL_5;
  }
  *(unsigned char *)(result + 649) = 1;
  if ((a4 & 4) == 0)
  {
LABEL_6:
    if ((a4 & 8) == 0) {
      return result;
    }
    goto LABEL_7;
  }
LABEL_11:
  *(unsigned char *)(result + 650) = 1;
  if ((a4 & 8) == 0) {
    return result;
  }
LABEL_7:
  *(void *)(result + 656) = v8;
  return result;
}

uint64_t SecOTRSessionCreateFromData(uint64_t a1, const __CFData *a2)
{
  if (!a2) {
    return 0;
  }
  SecOTRSessionGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  BytePtr = (UInt8 *)CFDataGetBytePtr(a2);
  UInt8 bytes = BytePtr;
  unint64_t Length = CFDataGetLength(a2);
  unint64_t v68 = Length;
  if (SecOTRGetDefaultsWriteSeconds_sdOnceToken != -1) {
    dispatch_once(&SecOTRGetDefaultsWriteSeconds_sdOnceToken, &__block_literal_global_12165);
  }
  dispatch_queue_t v6 = dispatch_queue_create("OTRSession", 0);
  *(void *)(Instance + 104) = 0;
  *(void *)(Instance + 128) = v6;
  *(void *)(Instance + 80) = 0;
  *(void *)(Instance + 56) = 0;
  *(_WORD *)(Instance + 648) = 0;
  *(void *)(Instance + 672) = 0;
  *(unsigned char *)(Instance + 664) = 0;
  *(void *)(Instance + 656) = 0;
  *(void *)(Instance + 24) = 0;
  *(void *)(Instance + 32) = 0;
  *(void *)(Instance + 64) = 0;
  *(void *)(Instance + 88) = 0;
  *(void *)(Instance + 112) = 0;
  *(_WORD *)(Instance + 680) = 1;
  *(_OWORD *)(Instance + 232) = 0u;
  *(_OWORD *)(Instance + 248) = 0u;
  *(_OWORD *)(Instance + 200) = 0u;
  *(_OWORD *)(Instance + 216) = 0u;
  *(_OWORD *)(Instance + 168) = 0u;
  *(_OWORD *)(Instance + 184) = 0u;
  *(_OWORD *)(Instance + 152) = 0u;
  *(_OWORD *)(Instance + 136) = 0u;
  *(_OWORD *)(Instance + 616) = 0u;
  *(_OWORD *)(Instance + 632) = 0u;
  *(_OWORD *)(Instance + 584) = 0u;
  *(_OWORD *)(Instance + 600) = 0u;
  *(_OWORD *)(Instance + 552) = 0u;
  *(_OWORD *)(Instance + 568) = 0u;
  *(_OWORD *)(Instance + 520) = 0u;
  *(_OWORD *)(Instance + 536) = 0u;
  *(_OWORD *)(Instance + 488) = 0u;
  *(_OWORD *)(Instance + 504) = 0u;
  *(_OWORD *)(Instance + 456) = 0u;
  *(_OWORD *)(Instance + 472) = 0u;
  *(_OWORD *)(Instance + 424) = 0u;
  *(_OWORD *)(Instance + 440) = 0u;
  *(_OWORD *)(Instance + 392) = 0u;
  *(_OWORD *)(Instance + 408) = 0u;
  *(_OWORD *)(Instance + 360) = 0u;
  *(_OWORD *)(Instance + 376) = 0u;
  *(_OWORD *)(Instance + 328) = 0u;
  *(_OWORD *)(Instance + 344) = 0u;
  *(_OWORD *)(Instance + 296) = 0u;
  *(_OWORD *)(Instance + 312) = 0u;
  *(_OWORD *)(Instance + 264) = 0u;
  *(_OWORD *)(Instance + 280) = 0u;
  if (!Length) {
    goto LABEL_76;
  }
  unsigned int v7 = *BytePtr;
  UInt8 bytes = BytePtr + 1;
  unint64_t v68 = Length - 1;
  if (v7 > 6) {
    goto LABEL_76;
  }
  if (Length < 5) {
    goto LABEL_76;
  }
  *(_DWORD *)(Instance + 16) = bswap32(*(_DWORD *)(BytePtr + 1));
  unint64_t v68 = Length - 5;
  UInt8 bytes = BytePtr + 5;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v9 = SecOTRFullIdentityCreateFromBytes((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (const UInt8 **)&bytes, &v68, 0);
  *(void *)(Instance + 24) = v9;
  if (!v9) {
    goto LABEL_76;
  }
  uint64_t v10 = SecOTRPublicIdentityCreateFromBytes((uint64_t)v8, (uint64_t *)&bytes, &v68, 0);
  *(void *)(Instance + 32) = v10;
  if (!v10) {
    goto LABEL_76;
  }
  unint64_t v11 = v68;
  unint64_t v12 = v68 - 17;
  if (v68 < 0x11) {
    goto LABEL_76;
  }
  uint64_t v13 = bytes;
  *(_OWORD *)(Instance + 40) = *(_OWORD *)bytes;
  int v14 = v13[16];
  uint64_t v15 = v13 + 17;
  unint64_t v68 = v12;
  UInt8 bytes = v13 + 17;
  if (v14)
  {
    if (v12 < 4
      || (unint64_t v16 = bswap32(*(_DWORD *)(v13 + 17)),
          uint64_t v15 = v13 + 21,
          unint64_t v12 = v11 - 21,
          unint64_t v68 = v11 - 21,
          UInt8 bytes = v13 + 21,
          v11 - 21 < v16))
    {
      CFDataRef Mutable = 0;
    }
    else
    {
      CFDataRef Mutable = CFDataCreateMutable(v8, 0);
      CFDataAppendBytes(Mutable, bytes, v16);
      uint64_t v15 = &bytes[v16];
      unint64_t v12 = v68 - v16;
      v68 -= v16;
      bytes += v16;
    }
    *(void *)(Instance + 56) = Mutable;
  }
  if (v7 < 2) {
    goto LABEL_25;
  }
  if (v12)
  {
    id v18 = v15 + 1;
    int v19 = *v15;
    unint64_t v20 = v12 - 1;
    unint64_t v68 = v12 - 1;
    UInt8 bytes = v15 + 1;
    if (v19)
    {
      BOOL v21 = v12 >= 5;
      unint64_t v22 = v12 - 5;
      if (v21)
      {
        unint64_t v23 = bswap32(*(_DWORD *)(v15 + 1));
        id v18 = v15 + 5;
        unint64_t v68 = v22;
        UInt8 bytes = v15 + 5;
        if (v22 < v23)
        {
          long long v66 = 0;
          unint64_t v20 = v22;
        }
        else
        {
          long long v66 = CFDataCreateMutable(v8, 0);
          CFDataAppendBytes(v66, bytes, v23);
          id v18 = &bytes[v23];
          unint64_t v20 = v68 - v23;
          v68 -= v23;
          bytes += v23;
        }
      }
      else
      {
        long long v66 = 0;
      }
      *(void *)(Instance + 64) = v66;
    }
    uint64_t v15 = v18;
  }
  else
  {
    unint64_t v20 = 0;
  }
  unint64_t v12 = v20;
  if (v7 <= 2)
  {
LABEL_25:
    if (!v12) {
      goto LABEL_76;
    }
    int v24 = *v15++;
    unint64_t v20 = v12 - 1;
    unint64_t v68 = v12 - 1;
    UInt8 bytes = v15;
    if (v24 && !*(_DWORD *)(Instance + 16)) {
      *(_DWORD *)(Instance + 16) = 4;
    }
  }
  unint64_t v25 = v20 - 4;
  if (v20 < 4) {
    goto LABEL_76;
  }
  unsigned int v26 = bswap32(*(_DWORD *)v15);
  *(_DWORD *)(Instance + 72) = v26;
  unint64_t v68 = v25;
  UInt8 bytes = v15 + 4;
  if (v26)
  {
    CFIndex v27 = SecOTRFullDHKCreateFromBytes((uint64_t)v8, (unsigned int **)&bytes, &v68);
    *(void *)(Instance + 80) = v27;
    if (!v27) {
      goto LABEL_76;
    }
    CFDictionaryRef v28 = SecOTRFullDHKCreateFromBytes((uint64_t)v8, (unsigned int **)&bytes, &v68);
    *(void *)(Instance + 88) = v28;
    if (!v28) {
      goto LABEL_76;
    }
    unint64_t v25 = v68;
  }
  if (!v25 || (long long v29 = bytes, v30 = *bytes, ++bytes, v68 = v25 - 1, v31 = v25 - 5, v25 < 5))
  {
LABEL_76:
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  unsigned int v32 = bswap32(*(_DWORD *)(v29 + 1));
  *(_DWORD *)(Instance + 96) = v32;
  unint64_t v68 = v31;
  UInt8 bytes = v29 + 5;
  if (v7 > 4)
  {
    if (!v30) {
      goto LABEL_44;
    }
    if (v30 == 1) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  if (!v32) {
    goto LABEL_44;
  }
  if (v32 != 1)
  {
LABEL_42:
    CFDataRef v33 = SecOTRPublicDHKCreateFromSerialization((uint64_t)v8, (unsigned int **)&bytes, &v68);
    *(void *)(Instance + 104) = v33;
    if (!v33) {
      goto LABEL_76;
    }
  }
LABEL_43:
  uint64_t v34 = SecOTRPublicDHKCreateFromSerialization((uint64_t)v8, (unsigned int **)&bytes, &v68);
  *(void *)(Instance + 112) = v34;
  if (!v34) {
    goto LABEL_76;
  }
LABEL_44:
  long long v67 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 80), *(void *)(Instance + 112), 0, 0, 0, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  unint64_t v35 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  CFDataRef v36 = bytes + 8;
  *long long v67 = bswap64(*(void *)bytes);
  unint64_t v68 = v35;
  UInt8 bytes = v36;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 80), *(void *)(Instance + 112), 1, 0, 0, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  unint64_t v37 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  uint64_t v38 = bytes + 8;
  *long long v67 = bswap64(*(void *)bytes);
  unint64_t v68 = v37;
  UInt8 bytes = v38;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 80), *(void *)(Instance + 104), 0, 0, 0, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  unint64_t v39 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  CFRange v40 = bytes + 8;
  *long long v67 = bswap64(*(void *)bytes);
  unint64_t v68 = v39;
  UInt8 bytes = v40;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 80), *(void *)(Instance + 104), 1, 0, 0, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  unint64_t v41 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  CFIndex v42 = bytes + 8;
  *long long v67 = bswap64(*(void *)bytes);
  unint64_t v68 = v41;
  UInt8 bytes = v42;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 88), *(void *)(Instance + 112), 0, 0, 0, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  unint64_t v43 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  uint64_t v44 = bytes + 8;
  *long long v67 = bswap64(*(void *)bytes);
  unint64_t v68 = v43;
  UInt8 bytes = v44;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 88), *(void *)(Instance + 112), 1, 0, 0, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  unint64_t v45 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  int v46 = bytes + 8;
  *long long v67 = bswap64(*(void *)bytes);
  unint64_t v68 = v45;
  UInt8 bytes = v46;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 88), *(void *)(Instance + 104), 0, 0, 0, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  unint64_t v47 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  int v48 = bytes + 8;
  *long long v67 = bswap64(*(void *)bytes);
  unint64_t v68 = v47;
  UInt8 bytes = v48;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 88), *(void *)(Instance + 104), 1, 0, 0, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  unint64_t v49 = v68;
  unint64_t v50 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  uint64_t v51 = bytes;
  unint64_t v52 = bytes + 8;
  *long long v67 = bswap64(*(void *)bytes);
  unint64_t v68 = v50;
  UInt8 bytes = v52;
  if (v50 < 4 || (unint64_t v53 = bswap32(*((_DWORD *)v51 + 2)), v68 = v49 - 12, bytes = v51 + 12, v49 - 12 < v53))
  {
    *(void *)(Instance + 120) = 0;
    goto LABEL_76;
  }
  uint64_t v54 = CFDataCreateMutable(v8, 0);
  CFDataAppendBytes(v54, bytes, v53);
  unint64_t v55 = v68;
  uint64_t v56 = &bytes[v53];
  uint64_t v57 = v68 - v53;
  v68 -= v53;
  bytes += v53;
  *(void *)(Instance + 120) = v54;
  if (!v54 || v55 == v53) {
    goto LABEL_76;
  }
  int v58 = *v56;
  UInt8 bytes = v56 + 1;
  unint64_t v68 = v57 - 1;
  *(unsigned char *)(Instance + 648) = v58 != 0;
  if (v7 < 4) {
    return Instance;
  }
  if (v57 == 1) {
    goto LABEL_76;
  }
  int v59 = v56[1];
  UInt8 bytes = v56 + 2;
  unint64_t v68 = v57 - 2;
  *(unsigned char *)(Instance + 649) = v59 != 0;
  if (v7 < 5) {
    return Instance;
  }
  if (v57 == 2) {
    goto LABEL_76;
  }
  int v60 = v56[2];
  UInt8 bytes = v56 + 3;
  unint64_t v68 = v57 - 3;
  *(unsigned char *)(Instance + 650) = v60 != 0;
  if (v7 >= 6)
  {
    if ((unint64_t)(v57 - 3) >= 8)
    {
      *(void *)(Instance + 656) = bswap64(*(void *)(v56 + 3));
      unint64_t v68 = v57 - 11;
      UInt8 bytes = v56 + 11;
      if (v57 != 11)
      {
        int v61 = v56[11];
        UInt8 bytes = v56 + 12;
        unint64_t v68 = v57 - 12;
        *(unsigned char *)(Instance + 664) = v61 != 0;
        if ((unint64_t)(v57 - 12) >= 8)
        {
          unint64_t v62 = *(void *)(v56 + 12);
          UInt8 bytes = v56 + 20;
          unint64_t v68 = v57 - 20;
          if (v57 != 20)
          {
            int v63 = v56[20];
            uint64_t v64 = v56 + 21;
            *(unsigned char *)(Instance + 680) = v63 != 0;
            unint64_t v68 = v57 - 21;
            UInt8 bytes = v64;
            if (v57 != 21)
            {
              *(unsigned char *)(Instance + 681) = *v64 != 0;
              *(double *)(Instance + 672) = (double)bswap64(v62);
              return Instance;
            }
          }
        }
      }
    }
    goto LABEL_76;
  }
  return Instance;
}

void SecOTRSFindKeysForMessage(uint64_t a1, uint64_t a2, uint64_t a3, int a4, void *a5, void *a6, uint64_t **a7)
{
  if (a2 && a3)
  {
    unint64_t v31 = a7;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    unint64_t v11 = (_DWORD *)(a2 + 160);
    unint64_t v12 = (_DWORD *)(a3 + 128);
    uint64_t v13 = a1 + 136;
    uint64_t v14 = a1 + 156;
    while (1)
    {
      uint64_t v15 = a1 + (v9 << 7);
      uint64_t v16 = v15 + 136;
      if (!timingsafe_bcmp((const void *)(v15 + 136), v11, 0x14uLL)
        && !timingsafe_bcmp((const void *)(v15 + 156), v12, 0x14uLL))
      {
        break;
      }
      if (!v10)
      {
        unint64_t v17 = 0;
        do
        {
          int v18 = *(unsigned __int8 *)(v13 + v17);
          if (v17 > 0x12) {
            break;
          }
          ++v17;
        }
        while (!v18);
        if (v18)
        {
          uint64_t v10 = 0;
        }
        else
        {
          unint64_t v19 = 0;
          do
          {
            char v20 = *(unsigned char *)(v14 + v19);
            if (v19 > 0x12) {
              break;
            }
            ++v19;
          }
          while (!v20);
          if (v20) {
            uint64_t v10 = 0;
          }
          else {
            uint64_t v10 = v15 + 136;
          }
        }
      }
      ++v9;
      v13 += 128;
      v14 += 128;
      if (v9 == 4)
      {
        if (v10) {
          uint64_t v16 = v10;
        }
        else {
          uint64_t v16 = a1 + 136;
        }
        long long v21 = *(_OWORD *)v11;
        *(_DWORD *)(v16 + 16) = v11[4];
        *(_OWORD *)uint64_t v16 = v21;
        long long v22 = *(_OWORD *)v12;
        *(_DWORD *)(v16 + 36) = v12[4];
        *(_OWORD *)(v16 + 20) = v22;
        *(void *)(v16 + 112) = 0;
        *(void *)(v16 + 120) = 0;
        SecOTRDHKGenerateOTRKeys(a2, a3, v16 + 60, v16 + 40, v16 + 96, v16 + 76);
        break;
      }
    }
    a7 = v31;
    if (a5)
    {
      uint64_t v23 = 96;
      if (a4) {
        uint64_t v23 = 60;
      }
      *a5 = v16 + v23;
    }
    if (a6)
    {
      uint64_t v24 = 76;
      if (a4) {
        uint64_t v24 = 40;
      }
      *a6 = v16 + v24;
    }
    if (v31)
    {
      uint64_t v25 = 120;
      if (a4) {
        uint64_t v25 = 112;
      }
      unsigned int v26 = (uint64_t *)(v16 + v25);
      goto LABEL_41;
    }
  }
  else
  {
    if (a5) {
      *a5 = 0;
    }
    if (a6) {
      *a6 = 0;
    }
    if (a7)
    {
      unsigned int v26 = &constant_zero;
LABEL_41:
      *a7 = v26;
    }
  }
}

uint64_t SecOTRSAppendSerialization(uint64_t a1, CFDataRef theData)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  uint64_t v2 = 4294967246;
  int v12 = -50;
  if (a1 && theData)
  {
    CFIndex Length = CFDataGetLength(theData);
    dispatch_queue_t v6 = *(NSObject **)(a1 + 128);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __SecOTRSAppendSerialization_block_invoke;
    block[3] = &unk_1E5481638;
    void block[5] = theData;
    block[6] = a1;
    block[4] = &v9;
    dispatch_sync(v6, block);
    if (*((_DWORD *)v10 + 6))
    {
      CFDataSetLength(theData, Length);
      uint64_t v2 = *((unsigned int *)v10 + 6);
    }
    else
    {
      uint64_t v2 = 0;
    }
  }
  _Block_object_dispose(&v9, 8);
  return v2;
}

void __SecOTRSAppendSerialization_block_invoke(uint64_t a1)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  UInt8 bytes = 6;
  CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 40), &bytes, 1);
  uint64_t v2 = *(__CFData **)(a1 + 40);
  *(_DWORD *)uint64_t v54 = bswap32(*(_DWORD *)(*(void *)(a1 + 48) + 16));
  CFDataAppendBytes(v2, v54, 4);
  if (SecOTRFIAppendSerialization(*(void *)(*(void *)(a1 + 48) + 24), *(CFDataRef *)(a1 + 40), 0)) {
    int v3 = 0;
  }
  else {
    int v3 = -50;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v3;
  if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    int v4 = SecOTRPIAppendSerialization(*(void *)(*(void *)(a1 + 48) + 32), *(CFDataRef *)(a1 + 40), 0)? 0: -50;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
    if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 40), (const UInt8 *)(*(void *)(a1 + 48) + 40), 16);
      uint64_t v5 = *(__CFData **)(a1 + 40);
      if (*(void *)(*(void *)(a1 + 48) + 56))
      {
        v54[0] = 1;
        CFDataAppendBytes(v5, v54, 1);
        dispatch_queue_t v6 = *(__CFData **)(a1 + 40);
        CFDataRef v7 = *(const __CFData **)(*(void *)(a1 + 48) + 56);
        CFIndex Length = CFDataGetLength(v7);
        BytePtr = CFDataGetBytePtr(v7);
        *(_DWORD *)uint64_t v54 = bswap32(Length);
        CFDataAppendBytes(v6, v54, 4);
        uint64_t v5 = v6;
        uint64_t v10 = (UInt8 *)BytePtr;
        CFIndex v11 = Length;
      }
      else
      {
        v54[0] = 0;
        uint64_t v10 = v54;
        CFIndex v11 = 1;
      }
      CFDataAppendBytes(v5, v10, v11);
      int v12 = *(__CFData **)(a1 + 40);
      if (*(void *)(*(void *)(a1 + 48) + 64))
      {
        v54[0] = 1;
        CFDataAppendBytes(v12, v54, 1);
        uint64_t v13 = *(__CFData **)(a1 + 40);
        CFDataRef v14 = *(const __CFData **)(*(void *)(a1 + 48) + 64);
        CFIndex v15 = CFDataGetLength(v14);
        uint64_t v16 = CFDataGetBytePtr(v14);
        *(_DWORD *)uint64_t v54 = bswap32(v15);
        CFDataAppendBytes(v13, v54, 4);
        int v12 = v13;
        unint64_t v17 = (UInt8 *)v16;
        CFIndex v18 = v15;
      }
      else
      {
        v54[0] = 0;
        unint64_t v17 = v54;
        CFIndex v18 = 1;
      }
      CFDataAppendBytes(v12, v17, v18);
      unint64_t v19 = *(__CFData **)(a1 + 40);
      *(_DWORD *)uint64_t v54 = bswap32(*(_DWORD *)(*(void *)(a1 + 48) + 72));
      CFDataAppendBytes(v19, v54, 4);
      uint64_t v20 = *(void *)(a1 + 48);
      if (*(_DWORD *)(v20 + 72))
      {
        SecFDHKAppendSerialization(*(void *)(v20 + 80), *(__CFData **)(a1 + 40));
        SecFDHKAppendSerialization(*(void *)(*(void *)(a1 + 48) + 88), *(__CFData **)(a1 + 40));
        uint64_t v20 = *(void *)(a1 + 48);
      }
      uint64_t v22 = *(void *)(v20 + 104);
      uint64_t v21 = *(void *)(v20 + 112);
      BOOL v23 = v22 == 0;
      BOOL v24 = v22 != 0;
      if (v23) {
        char v25 = 1;
      }
      else {
        char v25 = 2;
      }
      if (v21) {
        UInt8 v26 = v25;
      }
      else {
        UInt8 v26 = v24;
      }
      CFIndex v27 = *(__CFData **)(a1 + 40);
      v54[0] = v26;
      CFDataAppendBytes(v27, v54, 1);
      CFDictionaryRef v28 = *(__CFData **)(a1 + 40);
      *(_DWORD *)uint64_t v54 = bswap32(*(_DWORD *)(*(void *)(a1 + 48) + 96));
      CFDataAppendBytes(v28, v54, 4);
      long long v29 = *(uint64_t **)(a1 + 48);
      if (v29[13])
      {
        AppendECPublicKeyAsDATA(*(__CFData **)(a1 + 40));
        long long v29 = *(uint64_t **)(a1 + 48);
      }
      if (v29[14])
      {
        AppendECPublicKeyAsDATA(*(__CFData **)(a1 + 40));
        long long v29 = *(uint64_t **)(a1 + 48);
        uint64_t v30 = v29[14];
      }
      else
      {
        uint64_t v30 = 0;
      }
      unint64_t v52 = (unint64_t *)0xAAAAAAAAAAAAAAAALL;
      SecOTRSFindKeysForMessage((uint64_t)v29, v29[10], v30, 0, 0, 0, (uint64_t **)&v52);
      unint64_t v31 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v31, v54, 8);
      SecOTRSFindKeysForMessage(*(void *)(a1 + 48), *(void *)(*(void *)(a1 + 48) + 80), *(void *)(*(void *)(a1 + 48) + 112), 1, 0, 0, (uint64_t **)&v52);
      unsigned int v32 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v32, v54, 8);
      SecOTRSFindKeysForMessage(*(void *)(a1 + 48), *(void *)(*(void *)(a1 + 48) + 80), *(void *)(*(void *)(a1 + 48) + 104), 0, 0, 0, (uint64_t **)&v52);
      CFDataRef v33 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v33, v54, 8);
      SecOTRSFindKeysForMessage(*(void *)(a1 + 48), *(void *)(*(void *)(a1 + 48) + 80), *(void *)(*(void *)(a1 + 48) + 104), 1, 0, 0, (uint64_t **)&v52);
      uint64_t v34 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v34, v54, 8);
      SecOTRSFindKeysForMessage(*(void *)(a1 + 48), *(void *)(*(void *)(a1 + 48) + 88), *(void *)(*(void *)(a1 + 48) + 112), 0, 0, 0, (uint64_t **)&v52);
      unint64_t v35 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v35, v54, 8);
      SecOTRSFindKeysForMessage(*(void *)(a1 + 48), *(void *)(*(void *)(a1 + 48) + 88), *(void *)(*(void *)(a1 + 48) + 112), 1, 0, 0, (uint64_t **)&v52);
      CFDataRef v36 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v36, v54, 8);
      SecOTRSFindKeysForMessage(*(void *)(a1 + 48), *(void *)(*(void *)(a1 + 48) + 88), *(void *)(*(void *)(a1 + 48) + 104), 0, 0, 0, (uint64_t **)&v52);
      unint64_t v37 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v37, v54, 8);
      SecOTRSFindKeysForMessage(*(void *)(a1 + 48), *(void *)(*(void *)(a1 + 48) + 88), *(void *)(*(void *)(a1 + 48) + 104), 1, 0, 0, (uint64_t **)&v52);
      uint64_t v38 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v38, v54, 8);
      unint64_t v39 = *(__CFData **)(a1 + 40);
      CFDataRef v40 = *(const __CFData **)(*(void *)(a1 + 48) + 120);
      CFIndex v41 = CFDataGetLength(v40);
      CFIndex v42 = CFDataGetBytePtr(v40);
      *(_DWORD *)uint64_t v54 = bswap32(v41);
      CFDataAppendBytes(v39, v54, 4);
      CFDataAppendBytes(v39, v42, v41);
      unint64_t v43 = *(__CFData **)(a1 + 40);
      v54[0] = *(unsigned char *)(*(void *)(a1 + 48) + 648);
      CFDataAppendBytes(v43, v54, 1);
      uint64_t v44 = *(__CFData **)(a1 + 40);
      v54[0] = *(unsigned char *)(*(void *)(a1 + 48) + 649);
      CFDataAppendBytes(v44, v54, 1);
      unint64_t v45 = *(__CFData **)(a1 + 40);
      v54[0] = *(unsigned char *)(*(void *)(a1 + 48) + 650);
      CFDataAppendBytes(v45, v54, 1);
      int v46 = *(__CFData **)(a1 + 40);
      unint64_t v47 = *(void *)(*(void *)(a1 + 48) + 656);
      if (!v47) {
        unint64_t v47 = constant_zero;
      }
      *(void *)uint64_t v54 = bswap64(v47);
      CFDataAppendBytes(v46, v54, 8);
      int v48 = *(__CFData **)(a1 + 40);
      v54[0] = *(unsigned char *)(*(void *)(a1 + 48) + 664);
      CFDataAppendBytes(v48, v54, 1);
      unint64_t v49 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64((unint64_t)*(double *)(*(void *)(a1 + 48) + 672));
      CFDataAppendBytes(v49, v54, 8);
      unint64_t v50 = *(__CFData **)(a1 + 40);
      v54[0] = *(unsigned char *)(*(void *)(a1 + 48) + 680);
      CFDataAppendBytes(v50, v54, 1);
      uint64_t v51 = *(__CFData **)(a1 + 40);
      v54[0] = *(unsigned char *)(*(void *)(a1 + 48) + 681);
      CFDataAppendBytes(v51, v54, 1);
    }
  }
}

uint64_t SecOTRSIsForKeys(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  CFAllocatorRef v8 = &v7;
  uint64_t v9 = 0x2000000000;
  char v10 = 0;
  int v3 = *(NSObject **)(a1 + 128);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  v6[2] = __SecOTRSIsForKeys_block_invoke;
  unint64_t v6[3] = &unk_1E5481660;
  void v6[4] = &v7;
  void v6[5] = a1;
  void v6[6] = a2;
  v6[7] = a3;
  dispatch_sync(v3, v6);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

const void *__SecOTRSIsForKeys_block_invoke(void *a1)
{
  uint64_t v3 = a1[5];
  uint64_t v2 = (const void *)a1[6];
  uint64_t result = *(const void **)(*(void *)(v3 + 24) + 16);
  if (v2) {
    BOOL v5 = result == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    if (result == v2) {
      goto LABEL_10;
    }
LABEL_16:
    BOOL v8 = 0;
    goto LABEL_17;
  }
  uint64_t result = (const void *)CFEqual(result, v2);
  if (!result) {
    goto LABEL_16;
  }
  uint64_t v3 = a1[5];
LABEL_10:
  dispatch_queue_t v6 = (const void *)a1[7];
  uint64_t result = *(const void **)(*(void *)(v3 + 32) + 16);
  if (v6) {
    BOOL v7 = result == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    BOOL v8 = result == v6;
  }
  else
  {
    uint64_t result = (const void *)CFEqual(result, v6);
    BOOL v8 = result != 0;
  }
LABEL_17:
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = v8;
  return result;
}

uint64_t SecOTRSGetIsReadyForMessages(uint64_t a1)
{
  uint64_t v5 = 0;
  dispatch_queue_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  char v8 = -86;
  uint64_t v1 = *(NSObject **)(a1 + 128);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  void v4[2] = __SecOTRSGetIsReadyForMessages_block_invoke;
  v4[3] = &unk_1E5481688;
  v4[4] = &v5;
  void v4[5] = a1;
  dispatch_sync(v1, v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecOTRSGetIsReadyForMessages_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_DWORD *)(*(void *)(result + 40) + 16) == 4;
  return result;
}

uint64_t SecOTRSGetIsIdle(uint64_t a1)
{
  uint64_t v5 = 0;
  dispatch_queue_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  char v8 = -86;
  uint64_t v1 = *(NSObject **)(a1 + 128);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  void v4[2] = __SecOTRSGetIsIdle_block_invoke;
  v4[3] = &unk_1E54816B0;
  v4[4] = &v5;
  void v4[5] = a1;
  dispatch_sync(v1, v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecOTRSGetIsIdle_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_DWORD *)(*(void *)(result + 40) + 16) == 0;
  return result;
}

void SecOTRSPrecalculateKeys(dispatch_queue_t *context)
{
}

void SecOTRSPrecalculateKeysInternal(uint64_t *a1)
{
  SecOTRSPrecalculateForPair((uint64_t)a1, a1[10], a1[14]);
  SecOTRSPrecalculateForPair((uint64_t)a1, a1[11], a1[14]);
  SecOTRSPrecalculateForPair((uint64_t)a1, a1[10], a1[13]);
  uint64_t v2 = a1[11];
  uint64_t v3 = a1[13];

  SecOTRSPrecalculateForPair((uint64_t)a1, v2, v3);
}

void SecOTRSPrecalculateForPair(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 && a3)
  {
    SecOTRSFindKeysForMessage(a1, a2, a3, 1, 0, 0, 0);
    SecOTRSFindKeysForMessage(a1, a2, a3, 0, 0, 0, 0);
  }
}

uint64_t SecOTRSGetMessageKind(uint64_t a1, const __CFData *a2)
{
  unsigned __int8 v2 = SecOTRSGetMessageType(a2);
  if (v2 > 0x31u) {
    return 2;
  }
  if (((1 << v2) & 0x3000300000008) != 0) {
    return 1;
  }
  if (((1 << v2) & 0x60404) != 0) {
    return 0;
  }
  else {
    return 2;
  }
}

uint64_t SecOTRSSignAndProtectMessage(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  char v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v3 = 4294967246;
  int v10 = -50;
  if (a1 && a2 && a3 && *(_DWORD *)(a1 + 16) == 4)
  {
    uint64_t v4 = *(NSObject **)(a1 + 128);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __SecOTRSSignAndProtectMessage_block_invoke;
    unint64_t v6[3] = &unk_1E54816D8;
    void v6[4] = &v7;
    void v6[5] = a1;
    void v6[6] = a3;
    v6[7] = a2;
    dispatch_sync(v4, v6);
    uint64_t v3 = *((unsigned int *)v8 + 6);
  }
  _Block_object_dispose(&v7, 8);
  return v3;
}

void __SecOTRSSignAndProtectMessage_block_invoke(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 80))
  {
    uint64_t v3 = *(void *)(v2 + 112);
    if (v3)
    {
      memset(v21, 170, sizeof(v21));
      int v4 = *(_DWORD *)(v2 + 96);
      SecOTRSRollIfTime(v2);
      uint64_t v5 = *(void *)(a1 + 40);
      if (*(unsigned char *)(v5 + 664) && *(void *)(v5 + 104))
      {
        int v4 = *(_DWORD *)(v5 + 96) - 1;
        uint64_t v3 = *(void *)(v5 + 104);
      }
      SecOTRSFindKeysForMessage(v5, *(void *)(v5 + 80), v3, 1, &v21[2], &v21[1], v21);
      if (*(unsigned char *)(*(void *)(a1 + 40) + 648) || (CFDataRef Mutable = *(const __CFData **)(a1 + 48)) == 0) {
        CFDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      }
      else {
        CFRetain(*(CFTypeRef *)(a1 + 48));
      }
      uint64_t v7 = *(void *)(a1 + 40);
      CFDataRef v8 = *(const __CFData **)(a1 + 56);
      uint64_t v9 = v21[2];
      int v10 = v21[0];
      if (*(unsigned char *)(v7 + 649))
      {
        SecOTRSSignAndProtectCompact_locked(*(void *)(a1 + 40), *(const __CFData **)(a1 + 56), Mutable, (uint64_t)v21[2], (uint64_t)v21[1], v21[0], v4, v3);
      }
      else
      {
        CFDataGetLength(Mutable);
        *(_WORD *)UInt8 bytes = 512;
        CFDataAppendBytes(Mutable, bytes, 2);
        bytes[0] = 3;
        CFDataAppendBytes(Mutable, bytes, 1);
        bytes[0] = 0;
        CFDataAppendBytes(Mutable, bytes, 1);
        *(_DWORD *)UInt8 bytes = bswap32(*(_DWORD *)(v7 + 72));
        CFDataAppendBytes(Mutable, bytes, 4);
        *(_DWORD *)UInt8 bytes = bswap32(v4);
        CFDataAppendBytes(Mutable, bytes, 4);
        SecFDHKAppendPublicSerialization(*(void *)(v7 + 88), Mutable);
        unint64_t v11 = *v10 + 1;
        *int v10 = v11;
        *(void *)UInt8 bytes = bswap64(v11);
        CFDataAppendBytes(Mutable, bytes, 8);
        CFIndex Length = CFDataGetLength(v8);
        *(_DWORD *)UInt8 bytes = bswap32(Length);
        CFDataAppendBytes(Mutable, bytes, 4);
        CFIndex v13 = CFDataGetLength(Mutable);
        CFDataIncreaseLength(Mutable, Length);
        CFDataRef v14 = &CFDataGetMutableBytePtr(Mutable)[v13];
        uint64_t v15 = *v10;
        BytePtr = CFDataGetBytePtr(v8);
        AES_CTR_HighHalf_Transform(16, (uint64_t)v9, v15, Length, (uint64_t)BytePtr, (uint64_t)v14);
        CFDataGetLength(Mutable);
        CFDataGetLength(Mutable);
        CFDataIncreaseLength(Mutable, 20);
        CFDataGetMutableBytePtr(Mutable);
        ccsha1_di();
        CFDataGetBytePtr(Mutable);
        cchmac();
        CFDataRef v17 = *(const __CFData **)(v7 + 120);
        CFIndex v18 = CFDataGetBytePtr(v17);
        CFIndex v19 = CFDataGetLength(v17);
        CFDataAppendBytes(Mutable, v18, v19);
      }
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
      if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
      {
        uint64_t v20 = *(void *)(a1 + 40);
        if (*(unsigned char *)(v20 + 648))
        {
          SecOTRPrepareOutgoingBytes(Mutable, *(__CFData **)(a1 + 48));
          uint64_t v20 = *(void *)(a1 + 40);
        }
        CFDataSetLength(*(CFMutableDataRef *)(v20 + 120), 0);
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    }
  }
}

void SecOTRSRollIfTime(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  double v3 = *(double *)(a1 + 672);
  if (v3 < Current || v3 > Current + (double)*(unint64_t *)(a1 + 656))
  {
    *(unsigned char *)(a1 + 664) = 0;
    if (*(unsigned char *)(a1 + 681))
    {
      SecOTRGenerateNewProposedKey(a1);
      char v4 = 0;
      *(unsigned char *)(a1 + 681) = 0;
    }
    else
    {
      char v4 = 1;
    }
    *(unsigned char *)(a1 + 680) = v4;
    *(void *)(a1 + 672) = 0;
  }
}

void SecOTRSSignAndProtectCompact_locked(uint64_t a1, const __CFData *a2, CFDataRef theData, uint64_t a4, uint64_t a5, uint64_t *a6, char a7, uint64_t a8)
{
  uint64_t v34 = a5;
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  CFDataGetLength(theData);
  int v15 = *(unsigned __int8 *)(a1 + 650);
  if (*(unsigned char *)(a1 + 650)) {
    char v16 = 48;
  }
  else {
    char v16 = 32;
  }
  bytes[0] = v16 & 0xFE | a7 & 1;
  CFDataAppendBytes(theData, bytes, 1);
  SecFDHKAppendCompactPublicSerialization(*(void *)(a1 + 88), theData);
  unint64_t v17 = *a6 + 1;
  *a6 = v17;
  CFIndex v18 = (const UInt8 *)&v36;
  memset(bytes, 170, sizeof(bytes));
  char v36 = v17 & 0x7F;
  if (v17 >= 0x80)
  {
    do
    {
      unint64_t v19 = v17 >> 14;
      v17 >>= 7;
      *--CFIndex v18 = v17 | 0x80;
    }
    while (v19);
  }
  CFDataAppendBytes(theData, v18, bytes - v18 + 10);
  CFIndex Length = CFDataGetLength(a2);
  CFIndex v21 = CFDataGetLength(theData);
  CFDataIncreaseLength(theData, Length);
  uint64_t v22 = &CFDataGetMutableBytePtr(theData)[v21];
  uint64_t v23 = *a6;
  BytePtr = CFDataGetBytePtr(a2);
  AES_CTR_HighHalf_Transform(16, a4, v23, Length, (uint64_t)BytePtr, (uint64_t)v22);
  if (v15)
  {
    CFIndex v25 = CFDataGetLength(theData);
    CFDataIncreaseLength(theData, 20);
    UInt8 v26 = &CFDataGetMutableBytePtr(theData)[v25];
    uint64_t v27 = *(void *)(a1 + 80);
    int v28 = *(_DWORD *)(v27 + 176);
    *(_OWORD *)UInt8 v26 = *(_OWORD *)(v27 + 160);
    *((_DWORD *)v26 + 4) = v28;
    CFIndex v29 = CFDataGetLength(theData);
    CFDataIncreaseLength(theData, 20);
    uint64_t v30 = &CFDataGetMutableBytePtr(theData)[v29];
    int v31 = *(_DWORD *)(a8 + 144);
    *(_OWORD *)uint64_t v30 = *(_OWORD *)(a8 + 128);
    *((_DWORD *)v30 + 4) = v31;
  }
  CFIndex v32 = CFDataGetLength(theData);
  MEMORY[0x1F4188790](v32);
  memset(v33, 170, 20);
  ccsha1_di();
  CFDataGetBytePtr(theData);
  cchmac();
  CFDataAppendBytes(theData, v33, 16);
}

uint64_t SecOTRGenerateNewProposedKey(uint64_t a1)
{
  uint64_t v2 = 0;
  double v3 = (const void *)(*(void *)(a1 + 80) + 160);
  do
  {
    if (!timingsafe_bcmp((const void *)(a1 + v2 + 136), v3, 0x14uLL))
    {
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 120), (const UInt8 *)(a1 + v2 + 212), 20);
      *(_OWORD *)(a1 + v2 + 232) = 0u;
      *(_OWORD *)(a1 + v2 + 248) = 0u;
      *(_OWORD *)(a1 + v2 + 200) = 0u;
      *(_OWORD *)(a1 + v2 + 216) = 0u;
      *(_OWORD *)(a1 + v2 + 168) = 0u;
      *(_OWORD *)(a1 + v2 + 184) = 0u;
      *(_OWORD *)(a1 + v2 + 136) = 0u;
      *(_OWORD *)(a1 + v2 + 152) = 0u;
    }
    v2 += 128;
  }
  while (v2 != 512);
  *(int8x16_t *)(a1 + 80) = vextq_s8(*(int8x16_t *)(a1 + 80), *(int8x16_t *)(a1 + 80), 8uLL);
  uint64_t result = SecFDHKNewKey();
  ++*(_DWORD *)(a1 + 72);
  return result;
}

void SecOTRSKickTimeToRoll(uint64_t a1)
{
  *(CFAbsoluteTime *)(a1 + 672) = CFAbsoluteTimeGetCurrent();
}

uint64_t SecOTRSetupInitialRemoteKey(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  char v4 = *(const void **)(a1 + 104);
  if (v4)
  {
    *(void *)(a1 + 104) = 0;
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 112);
  if (v5) {
    CFRelease(v5);
  }
  *(void *)(a1 + 112) = a2;
  *(_DWORD *)(a1 + 96) = 1;
  return 0;
}

uint64_t SOSOTRSRoll(uint64_t result)
{
  uint64_t v1 = result;
  *(unsigned char *)(result + 664) = 0;
  if (*(unsigned char *)(result + 681))
  {
    uint64_t result = SecOTRGenerateNewProposedKey(result);
    char v2 = 0;
    *(unsigned char *)(v1 + 681) = 0;
  }
  else
  {
    char v2 = 1;
  }
  *(unsigned char *)(v1 + 680) = v2;
  return result;
}

uint64_t SecOTRSVerifyAndExposeMessage(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = 0;
  unint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  uint64_t v3 = 4294967246;
  int v13 = -50;
  if (a1 && a2 && a3)
  {
    if (*(_DWORD *)(a1 + 16) == 4)
    {
      dispatch_queue_t v6 = *(NSObject **)(a1 + 128);
      v9[0] = MEMORY[0x1E4F143A8];
      v9[1] = 0x40000000;
      _OWORD v9[2] = __SecOTRSVerifyAndExposeMessage_block_invoke;
      v9[3] = &unk_1E5481700;
      void v9[4] = &v10;
      void v9[5] = a2;
      void v9[6] = a1;
      v9[7] = a3;
      dispatch_sync(v6, v9);
      uint64_t v3 = *((unsigned int *)v11 + 6);
    }
    else
    {
      uint64_t v7 = secLogObjForScope("OTR");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134218498;
        uint64_t v15 = a1;
        __int16 v16 = 2112;
        uint64_t v17 = a2;
        __int16 v18 = 2112;
        uint64_t v19 = a1;
        _os_log_impl(&dword_18B299000, v7, OS_LOG_TYPE_DEFAULT, "session[%p]Cannot process message:%@, session is not done negotiating, session state: %@", buf, 0x20u);
      }
      uint64_t v3 = 4294941965;
      *((_DWORD *)v11 + 6) = -25331;
    }
  }
  _Block_object_dispose(&v10, 8);
  return v3;
}

void __SecOTRSVerifyAndExposeMessage_block_invoke(uint64_t a1)
{
  uint64_t v1 = (void *)a1;
  v91[3] = *MEMORY[0x1E4F143B8];
  CFDataRef v2 = (const __CFData *)SecOTRCopyIncomingBytes(*(const __CFData **)(a1 + 40));
  unsigned __int8 v3 = SecOTRSGetMessageType(v2);
  int v4 = -25256;
  if (v3 > 0x31u) {
    goto LABEL_85;
  }
  CFDataRef v80 = v2;
  if (((1 << v3) & 0x3000300000000) == 0)
  {
    if (v3 != 3) {
      goto LABEL_85;
    }
    uint64_t v30 = v1[6];
    CFDataRef v29 = (const __CFData *)v1[7];
    BytePtr = CFDataGetBytePtr(v2);
    unint64_t Length = CFDataGetLength(v2);
    if (Length < 2) {
      goto LABEL_103;
    }
    if (__rev16(*(unsigned __int16 *)BytePtr) != 2)
    {
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      int v4 = -26275;
      goto LABEL_95;
    }
    unint64_t v33 = Length;
    if (Length == 2) {
      goto LABEL_103;
    }
    uint64_t v34 = 0;
    int v4 = -26275;
    if (Length == 3)
    {
      uint64_t v35 = 0;
      goto LABEL_95;
    }
    uint64_t v35 = 0;
    if (BytePtr[2] != 3) {
      goto LABEL_95;
    }
    if (BytePtr[3])
    {
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      goto LABEL_95;
    }
    CFDataRef theDataa = v29;
    unint64_t v36 = Length & 0xFFFFFFFFFFFFFFFCLL;
    if ((Length & 0xFFFFFFFFFFFFFFFCLL) == 4) {
      goto LABEL_103;
    }
    unsigned int v37 = bswap32(*((_DWORD *)BytePtr + 1));
    unsigned int v38 = *(_DWORD *)(v30 + 96);
    if (v37 != v38 && (v37 != v38 - 1 || !*(void *)(v30 + 104)))
    {
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      if (v37 + 1 >= v38) {
        int v4 = -25329;
      }
      else {
        int v4 = -25328;
      }
      goto LABEL_95;
    }
    if (v36 == 8)
    {
LABEL_103:
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      int v4 = -50;
      goto LABEL_95;
    }
    unsigned int v39 = bswap32(*((_DWORD *)BytePtr + 2));
    unsigned int v40 = *(_DWORD *)(v30 + 72);
    if (v39 != v40 && (v39 != v40 + 1 || !*(void *)(v30 + 88)))
    {
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      if (v39 >= v40) {
        int v4 = -25329;
      }
      else {
        int v4 = -25328;
      }
      goto LABEL_94;
    }
    v91[0] = 0xAAAAAAAAAAAAAAAALL;
    CFErrorRef v82 = (unint64_t *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v83 = 0xAAAAAAAAAAAAAAAALL;
    BOOL v10 = v39 == v40;
    uint64_t v41 = 88;
    if (v10) {
      uint64_t v41 = 80;
    }
    uint64_t v34 = *(void *)(v30 + v41);
    BOOL v10 = v37 == v38;
    uint64_t v42 = 104;
    if (v10) {
      uint64_t v42 = 112;
    }
    uint64_t v35 = *(void *)(v30 + v42);
    SecOTRSFindKeysForMessage(v30, v34, v35, 0, v91, &v83, (uint64_t **)&v82);
    if (v36 != 12)
    {
      unint64_t v43 = (uint64_t *)bswap32(*((_DWORD *)BytePtr + 3));
      unint64_t v44 = v33 - 16 - (void)v43;
      if (v33 - 16 < (unint64_t)v43)
      {
LABEL_94:
        CFDataRef v2 = v80;
        goto LABEL_95;
      }
      v81[1] = (uint64_t *)(BytePtr + 16);
      v81[2] = v43;
      if (v44 >= 8)
      {
        unint64_t v45 = (char *)v43 + (void)(BytePtr + 16);
        unint64_t v46 = bswap64(*(void *)v45);
        if (v46 <= *v82)
        {
          int v4 = -25328;
          goto LABEL_94;
        }
        if ((v44 & 0xFFFFFFFFFFFFFFFCLL) != 8)
        {
          unint64_t v47 = bswap32(*((_DWORD *)v45 + 2));
          unint64_t v48 = v44 - 12;
          BOOL v49 = v48 >= v47;
          unint64_t v50 = v48 - v47;
          if (!v49) {
            goto LABEL_94;
          }
          uint64_t v79 = v1;
          memset(__b1, 170, 20);
          if (v50 >= 0x14)
          {
            uint64_t v51 = (uint64_t)(v45 + 12);
            unint64_t v52 = &v45[v47 + 12];
            ccsha1_di();
            cchmac();
            if (!timingsafe_bcmp(__b1, v52, 0x14uLL))
            {
              CFIndex v53 = CFDataGetLength(theDataa);
              CFDataIncreaseLength(theDataa, v47);
              MutableBytePtr = CFDataGetMutableBytePtr(theDataa);
              AES_CTR_HighHalf_Transform(16, v91[0], v46, v47, v51, (uint64_t)&MutableBytePtr[v53]);
              *CFErrorRef v82 = v46;
              uint64_t v55 = SecOTRPublicDHKCreateFromBytes(*MEMORY[0x1E4F1CF80], &v81[1], &v81[2]);
              uint64_t v1 = v79;
              if (v55 && v37 == *(_DWORD *)(v30 + 96)) {
                SecOTRAcceptNewRemoteKey(v30, v55);
              }
              if (v39 == *(_DWORD *)(v30 + 72) + 1) {
                SecOTRSHandleProposalAcknowledge(v30);
              }
              SecOTRSRollIfTime(v30);
              SecOTRSPrecalculateForPair(v30, *(void *)(v30 + 80), *(void *)(v30 + 112));
              CFDataRef v2 = v80;
              if (v55) {
                CFRelease(v55);
              }
              int v4 = 0;
              goto LABEL_85;
            }
            int v4 = -25293;
          }
          uint64_t v1 = v79;
          CFDataRef v2 = v80;
LABEL_95:
          *(void *)__b1 = MEMORY[0x1E4F143A8];
          *(void *)&__b1[8] = 0x40000000;
          *(void *)&__b1[16] = __SecOTRVerifyAndExposeRaw_locked_block_invoke;
          uint64_t v85 = &__block_descriptor_tmp_72_12193;
          uint64_t v86 = v30;
          uint64_t v87 = v35;
          uint64_t v88 = v34;
          if (v2)
          {
            CFAllocatorRef v66 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            CFIndex v67 = CFDataGetLength(v2);
            CFDataRef Mutable = CFStringCreateMutable(v66, 2 * v67);
            long long v69 = CFDataGetBytePtr(v2);
            CFIndex v70 = CFDataGetLength(v2);
            if (v70 >= 1)
            {
              CFIndex v71 = v70;
              do
              {
                unsigned int v72 = *v69++;
                CFStringAppendFormat(Mutable, 0, @"%02X", v72);
                --v71;
              }
              while (v71);
            }
          }
          else
          {
            CFDataRef Mutable = @"(null)";
          }
          (*(void (**)(unsigned char *, __CFString *))&__b1[16])(__b1, Mutable);
          long long v65 = Mutable;
          goto LABEL_84;
        }
      }
    }
    int v4 = -50;
    goto LABEL_94;
  }
  uint64_t v5 = v1[6];
  CFDataRef v6 = (const __CFData *)v1[7];
  uint64_t v7 = CFDataGetBytePtr(v2);
  unint64_t v83 = (unint64_t)v7;
  CFDataRef v8 = (uint64_t *)CFDataGetLength(v2);
  CFErrorRef v82 = (unint64_t *)v8;
  if (!v8)
  {
    LOBYTE(v9) = 0;
    uint64_t v15 = 0;
    uint64_t v13 = 0;
    uint64_t v18 = 0;
    int v4 = -50;
LABEL_69:
    *(void *)__b1 = MEMORY[0x1E4F143A8];
    *(void *)&__b1[8] = 0x40000000;
    *(void *)&__b1[16] = __SecOTRVerifyAndExposeRawCompact_locked_block_invoke;
    uint64_t v85 = &__block_descriptor_tmp_75_12194;
    uint64_t v86 = v5;
    uint64_t v87 = v18;
    uint64_t v88 = v13;
    uint64_t v89 = v15;
    char v90 = v9;
    CFDataRef v2 = v80;
    if (v80)
    {
      CFAllocatorRef v56 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFIndex v57 = CFDataGetLength(v80);
      int v58 = CFStringCreateMutable(v56, 2 * v57);
      int v59 = CFDataGetBytePtr(v80);
      CFIndex v60 = CFDataGetLength(v80);
      if (v60 >= 1)
      {
        CFIndex v61 = v60;
        do
        {
          unsigned int v62 = *v59++;
          CFStringAppendFormat(v58, 0, @"%02X", v62);
          --v61;
        }
        while (v61);
        CFDataRef v2 = v80;
      }
    }
    else
    {
      int v58 = @"(null)";
    }
    (*(void (**)(unsigned char *, __CFString *))&__b1[16])(__b1, v58);
    CFRelease(v58);
    if (v15) {
      goto LABEL_83;
    }
    goto LABEL_85;
  }
  unsigned int v9 = *v7;
  unint64_t v83 = (unint64_t)(v7 + 1);
  CFErrorRef v82 = (unint64_t *)((char *)v8 - 1);
  BOOL v10 = v9 > 0x31 || ((1 << v9) & 0x3000300000000) == 0;
  if (v10)
  {
    uint64_t v15 = 0;
    uint64_t v13 = 0;
LABEL_68:
    uint64_t v18 = 0;
    int v4 = -26275;
    goto LABEL_69;
  }
  char v11 = ((v9 & 0xFFFFFFEF) != 32) ^ *(unsigned char *)(v5 + 72);
  uint64_t v12 = 80;
  if (v11) {
    uint64_t v12 = 88;
  }
  uint64_t v13 = *(void *)(v5 + v12);
  if (!v13)
  {
    uint64_t v15 = 0;
    goto LABEL_68;
  }
  CFDataRef v14 = (__CFString *)SecOTRPublicDHKCreateFromCompactSerialization(*MEMORY[0x1E4F1CF80], &v83, (unint64_t *)&v82);
  uint64_t v15 = v14;
  if (!v14) {
    goto LABEL_68;
  }
  __int16 v16 = *(const void **)(v5 + 112);
  if (!v16) {
    goto LABEL_68;
  }
  char theData = v11;
  uint64_t v78 = v1;
  int v75 = CFEqual(v14, v16);
  uint64_t v17 = 104;
  if (!v75) {
    uint64_t v17 = 112;
  }
  uint64_t v18 = *(void *)(v5 + v17);
  if (!v18)
  {
LABEL_65:
    int v4 = -26275;
LABEL_66:
    uint64_t v1 = v78;
    goto LABEL_69;
  }
  int v19 = v9 & 0xFE;
  memset(v81, 170, sizeof(v81));
  SecOTRSFindKeysForMessage(v5, v13, v18, 0, &v81[2], &v81[1], v81);
  unint64_t v20 = 0;
  CFIndex v21 = (uint64_t *)v82;
  uint64_t v22 = (char *)v83;
  uint64_t v23 = (char *)v82 + v83;
  do
  {
    if (!v21)
    {
      CFErrorRef v82 = 0;
      unint64_t v83 = (unint64_t)v23;
      goto LABEL_65;
    }
    char v24 = *v22++;
    unint64_t v25 = v24 & 0x7F | (v20 << 7);
    CFIndex v21 = (uint64_t *)((char *)v21 - 1);
    unint64_t v20 = v25;
  }
  while (v24 < 0);
  CFDataRef v74 = v6;
  CFErrorRef v82 = (unint64_t *)v21;
  unint64_t v83 = (unint64_t)v22;
  if (v25 <= *v81[0])
  {
    int v4 = -25328;
    goto LABEL_66;
  }
  uint64_t v26 = 16;
  if (v19 == 48) {
    uint64_t v26 = 56;
  }
  uint64_t v27 = 0x1FFFFFFFFFFFFFFELL;
  if (v19 == 48) {
    uint64_t v27 = 0x1FFFFFFFFFFFFFF9;
  }
  extraunint64_t Length = (CFIndex)&v21[v27];
  int v28 = (char *)&v21[v27] + (void)v22;
  CFErrorRef v82 = (unint64_t *)v26;
  unint64_t v83 = (unint64_t)v28;
  if (v19 == 48)
  {
    v28 += 40;
    CFErrorRef v82 = (unint64_t *)(v26 - 40);
    unint64_t v83 = (unint64_t)v28;
    memset(v91, 170, 20);
    if (v26 != 56) {
      goto LABEL_65;
    }
  }
  else
  {
    memset(v91, 170, 20);
  }
  ccsha1_di();
  cchmac();
  if (timingsafe_bcmp(v91, v28, 0x10uLL))
  {
    int v4 = -25293;
    goto LABEL_66;
  }
  CFIndex v63 = CFDataGetLength(v74);
  CFDataIncreaseLength(v74, extraLength);
  uint64_t v64 = CFDataGetMutableBytePtr(v74);
  AES_CTR_HighHalf_Transform(16, (uint64_t)v81[2], v25, extraLength, (uint64_t)v22, (uint64_t)&v64[v63]);
  *v81[0] = v25;
  if (!v75) {
    SecOTRAcceptNewRemoteKey(v5, v15);
  }
  uint64_t v1 = v78;
  CFDataRef v2 = v80;
  if (theData) {
    SecOTRSHandleProposalAcknowledge(v5);
  }
  SecOTRSRollIfTime(v5);
  SecOTRSPrecalculateForPair(v5, *(void *)(v5 + 80), *(void *)(v5 + 112));
  int v4 = 0;
  if (v15)
  {
LABEL_83:
    long long v65 = v15;
LABEL_84:
    CFRelease(v65);
  }
LABEL_85:
  *(_DWORD *)(*(void *)(v1[4] + 8) + 24) = v4;
  if (v2) {
    CFRelease(v2);
  }
}

void SecOTRAcceptNewRemoteKey(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(void *)(a1 + 104);
  if (v4)
  {
    uint64_t v5 = 0;
    CFDataRef v6 = (const void *)(v4 + 128);
    do
    {
      uint64_t v7 = a1 + v5;
      if (!timingsafe_bcmp((const void *)(a1 + v5 + 156), v6, 0x14uLL))
      {
        CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 120), (const UInt8 *)(v7 + 212), 20);
        *(_OWORD *)(v7 + 248) = 0u;
        *(_OWORD *)(v7 + 232) = 0u;
        *(_OWORD *)(v7 + 216) = 0u;
        *(_OWORD *)(v7 + 200) = 0u;
        *(_OWORD *)(v7 + 184) = 0u;
        *(_OWORD *)(v7 + 168) = 0u;
        *(_OWORD *)(v7 + 152) = 0u;
        *(_OWORD *)(v7 + 136) = 0u;
      }
      v5 += 128;
    }
    while (v5 != 512);
    CFDataRef v8 = *(const void **)(a1 + 104);
    if (v8)
    {
      *(void *)(a1 + 104) = 0;
      CFRelease(v8);
    }
  }
  *(void *)(a1 + 104) = *(void *)(a1 + 112);
  CFRetain(cf);
  *(void *)(a1 + 112) = cf;
  *(unsigned char *)(a1 + 664) = 1;
  ++*(_DWORD *)(a1 + 96);
  double v9 = CFAbsoluteTimeGetCurrent() + (double)*(unint64_t *)(a1 + 656);
  double v10 = *(double *)(a1 + 672);
  if (v10 == 0.0 || v10 > v9) {
    *(double *)(a1 + 672) = v9;
  }
}

void SecOTRSHandleProposalAcknowledge(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 680))
  {
    SecOTRGenerateNewProposedKey(a1);
    *(unsigned char *)(a1 + 680) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 681) = 1;
    double v2 = CFAbsoluteTimeGetCurrent() + (double)*(unint64_t *)(a1 + 656);
    double v3 = *(double *)(a1 + 672);
    if (v3 == 0.0 || v3 > v2) {
      *(double *)(a1 + 672) = v2;
    }
  }
}

uint64_t SecOTRSessionCreateRemote(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  CFDataRef v6 = &v5;
  uint64_t v7 = 0x2000000000;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecOTRSessionCreateRemote_block_invoke;
  activity_block[3] = &unk_1E5481728;
  activity_block[4] = &v5;
  activity_void block[5] = a1;
  void activity_block[6] = a2;
  _os_activity_initiate(&dword_18B299000, "SecOTRSessionCreateRemote", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void __SecOTRSessionCreateRemote_block_invoke(void *a1)
{
  if (SecOTRGetDefaultsWriteSeconds_sdOnceToken != -1) {
    dispatch_once(&SecOTRGetDefaultsWriteSeconds_sdOnceToken, &__block_literal_global_12165);
  }
  if (gSecurityd && (uint64_t v2 = *(uint64_t (**)(void, void))(gSecurityd + 176)) != 0)
  {
    uint64_t v3 = v2(a1[5], a1[6]);
  }
  else
  {
    uint64_t v5 = a1[5];
    uint64_t v4 = (CFTypeRef *)a1[6];
    uint64_t v8 = 0;
    double v9 = &v8;
    uint64_t v10 = 0x2000000000;
    uint64_t v11 = 0;
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    _DWORD v7[2] = __data_to_data_error_request_block_invoke;
    unint64_t v7[3] = &__block_descriptor_tmp_77_12205;
    UInt8 v7[4] = v5;
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __data_to_data_error_request_block_invoke_2;
    unint64_t v6[3] = &unk_1E5481878;
    void v6[4] = &v8;
    securityd_send_sync_and_do(0x15u, v4, (uint64_t)v7, (uint64_t)v6);
    uint64_t v3 = v9[3];
    _Block_object_dispose(&v8, 8);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = v3;
}

BOOL __data_to_data_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  CFDataRef v4 = *(const __CFData **)(a1 + 32);
  return !v4 || SecXPCDictionarySetData(a2, "publicPeerId", v4, a3);
}

BOOL __data_to_data_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  CFDataRef v4 = SecXPCDictionaryCopyData(a2, "status", a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
  return v4 != 0;
}

uint64_t SecOTRSessionProcessPacketRemote(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  char v12 = -86;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecOTRSessionProcessPacketRemote_block_invoke;
  activity_block[3] = &unk_1E5481750;
  activity_block[4] = &v9;
  activity_void block[5] = a1;
  void activity_block[6] = a2;
  void activity_block[7] = a3;
  void activity_block[8] = a4;
  void activity_block[9] = a5;
  activity_block[10] = a6;
  _os_activity_initiate(&dword_18B299000, "SecOTRSessionProcessPacketRemote", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void __SecOTRSessionProcessPacketRemote_block_invoke(void *a1)
{
  if (gSecurityd
    && (uint64_t v2 = *(uint64_t (**)(void, void, void, void, void, void))(gSecurityd + 184)) != 0)
  {
    char v3 = v2(a1[5], a1[6], a1[7], a1[8], a1[9], a1[10]);
  }
  else
  {
    uint64_t v5 = (void *)a1[7];
    CFDataRef v4 = (void *)a1[8];
    uint64_t v7 = (unsigned char *)a1[9];
    uint64_t v6 = (CFTypeRef *)a1[10];
    uint64_t v19 = 0;
    unint64_t v20 = &v19;
    uint64_t v21 = 0x2000000000;
    uint64_t v22 = 0;
    uint64_t v15 = 0;
    __int16 v16 = &v15;
    uint64_t v17 = 0x2000000000;
    uint64_t v18 = 0;
    uint64_t v11 = 0;
    char v12 = &v11;
    uint64_t v13 = 0x2000000000;
    char v14 = 0;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    _OWORD v9[2] = __data_data_to_data_data_BOOL_error_request_block_invoke;
    v9[3] = &__block_descriptor_tmp_79_12210;
    long long v10 = *(_OWORD *)(a1 + 5);
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    _DWORD v8[2] = __data_data_to_data_data_BOOL_error_request_block_invoke_2;
    unint64_t v8[3] = &unk_1E54818C0;
    v8[4] = &v19;
    void v8[5] = &v15;
    void v8[6] = &v11;
    char v3 = securityd_send_sync_and_do(0x16u, v6, (uint64_t)v9, (uint64_t)v8);
    *uint64_t v5 = v20[3];
    *CFDataRef v4 = v16[3];
    unsigned char *v7 = *((unsigned char *)v12 + 24);
    _Block_object_dispose(&v11, 8);
    _Block_object_dispose(&v15, 8);
    _Block_object_dispose(&v19, 8);
  }
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = v3;
}

uint64_t SecOTRSessionIsSessionInAwaitingState(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 16);
  if (v1 < 5) {
    return (0xFu >> v1) & 1;
  }
  char v3 = secLogObjForScope("otrtimer");
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v4)
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl(&dword_18B299000, v3, OS_LOG_TYPE_DEFAULT, "unknown otr auth state", v5, 2u);
    return 0;
  }
  return result;
}

uint64_t SecOTRSAppendStartPacket(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  int v9 = 0;
  uint64_t v2 = *(NSObject **)(a1 + 128);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecOTRSAppendStartPacket_block_invoke;
  block[3] = &unk_1E5481930;
  block[4] = &v6;
  void block[5] = a1;
  block[6] = a2;
  dispatch_sync(v2, block);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void __SecOTRSAppendStartPacket_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  *(_DWORD *)(v2 + 16) = 1;
  SecOTRInitMyDHKeys(v2);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = CCRandomCopyBytes();
  if (!*(_DWORD *)(*(void *)(a1[4] + 8) + 24)) {
    SecOTRAppendDHMessage(a1[5], Mutable);
  }
  uint64_t v15 = MEMORY[0x1E4F143A8];
  uint64_t v16 = 0x40000000;
  uint64_t v17 = __SecOTRSAppendStartPacket_block_invoke_2;
  uint64_t v18 = &__block_descriptor_tmp_12216;
  uint64_t v19 = a1[5];
  if (Mutable)
  {
    CFIndex Length = CFDataGetLength(Mutable);
    uint64_t v6 = CFStringCreateMutable(v3, 2 * Length);
    BytePtr = CFDataGetBytePtr(Mutable);
    CFIndex v8 = CFDataGetLength(Mutable);
    if (v8 >= 1)
    {
      CFIndex v9 = v8;
      do
      {
        unsigned int v10 = *BytePtr++;
        CFStringAppendFormat(v6, 0, @"%02X", v10, v15, v16);
        --v9;
      }
      while (v9);
    }
  }
  else
  {
    uint64_t v6 = @"(null)";
  }
  v17((uint64_t)&v15, (uint64_t)v6);
  CFRelease(v6);
  uint64_t v11 = a1[5];
  char v12 = (__CFData *)a1[6];
  if (*(unsigned char *)(v11 + 648))
  {
    SecOTRPrepareOutgoingBytes(Mutable, v12);
    if (!Mutable) {
      return;
    }
  }
  else
  {
    uint64_t v13 = CFDataGetBytePtr(Mutable);
    CFIndex v14 = CFDataGetLength(Mutable);
    CFDataAppendBytes(v12, v13, v14);
    if (!Mutable) {
      return;
    }
  }
  CFRelease(Mutable);
}

void SecOTRInitMyDHKeys(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(const void **)(a1 + 80);
  if (v2)
  {
    *(void *)(a1 + 80) = 0;
    CFRelease(v2);
  }
  *(void *)(a1 + 80) = SecOTRFullDHKCreate();
  CFAllocatorRef v3 = *(const void **)(a1 + 88);
  if (v3)
  {
    *(void *)(a1 + 88) = 0;
    CFRelease(v3);
  }
  uint64_t v4 = SecOTRFullDHKCreate();
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 88) = v4;
  *(_DWORD *)(a1 + 72) = 1;
  *(_WORD *)(a1 + 680) = 1;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  uint64_t v5 = secLogObjForScope("otr");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 80);
    int v7 = 138412546;
    uint64_t v8 = a1;
    __int16 v9 = 2112;
    uint64_t v10 = v6;
    _os_log_impl(&dword_18B299000, v5, OS_LOG_TYPE_DEFAULT, "%@ Reinitializing DH Keys, first: %@", (uint8_t *)&v7, 0x16u);
  }
}

void __SecOTRSAppendStartPacket_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "%@ Start packet: %@", (uint8_t *)&v6, 0x16u);
  }
}

uint64_t SecOTRSAppendRestartPacket(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  int v9 = 0;
  uint64_t v2 = *(NSObject **)(a1 + 128);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecOTRSAppendRestartPacket_block_invoke;
  block[3] = &unk_1E5481978;
  block[4] = &v6;
  void block[5] = a1;
  block[6] = a2;
  dispatch_sync(v2, block);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void __SecOTRSAppendRestartPacket_block_invoke(void *a1)
{
  if (*(void *)(a1[5] + 80))
  {
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    uint64_t v4 = a1[5];
    *(_DWORD *)(v4 + 16) = 1;
    uint64_t v5 = *(const void **)(v4 + 56);
    if (v5)
    {
      *(void *)(v4 + 56) = 0;
      CFRelease(v5);
      uint64_t v4 = a1[5];
    }
    uint64_t v6 = *(const void **)(v4 + 64);
    if (v6)
    {
      *(void *)(v4 + 64) = 0;
      CFRelease(v6);
      uint64_t v4 = a1[5];
    }
    SecOTRAppendDHMessage(v4, Mutable);
    uint64_t v18 = MEMORY[0x1E4F143A8];
    uint64_t v19 = 0x40000000;
    unint64_t v20 = __SecOTRSAppendRestartPacket_block_invoke_6;
    uint64_t v21 = &__block_descriptor_tmp_7_12230;
    uint64_t v22 = a1[5];
    if (Mutable)
    {
      CFIndex Length = CFDataGetLength(Mutable);
      uint64_t v8 = CFStringCreateMutable(v2, 2 * Length);
      BytePtr = CFDataGetBytePtr(Mutable);
      CFIndex v10 = CFDataGetLength(Mutable);
      if (v10 >= 1)
      {
        CFIndex v11 = v10;
        do
        {
          unsigned int v12 = *BytePtr++;
          CFStringAppendFormat(v8, 0, @"%02X", v12, v18, v19);
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      uint64_t v8 = @"(null)";
    }
    v20((uint64_t)&v18, (uint64_t)v8);
    CFRelease(v8);
    uint64_t v14 = a1[5];
    uint64_t v15 = (__CFData *)a1[6];
    if (*(unsigned char *)(v14 + 648))
    {
      SecOTRPrepareOutgoingBytes(Mutable, v15);
      if (!Mutable) {
        return;
      }
    }
    else
    {
      uint64_t v16 = CFDataGetBytePtr(Mutable);
      CFIndex v17 = CFDataGetLength(Mutable);
      CFDataAppendBytes(v15, v16, v17);
      if (!Mutable) {
        return;
      }
    }
    CFRelease(Mutable);
  }
  else
  {
    uint64_t v13 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_18B299000, v13, OS_LOG_TYPE_DEFAULT, "_myKey is NULL, avoiding crash", buf, 2u);
    }
    *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = -26275;
  }
}

void __SecOTRSAppendRestartPacket_block_invoke_6(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "%@ Restart packet: %@", (uint8_t *)&v6, 0x16u);
  }
}

uint64_t SecOTRSProcessPacket(uint64_t a1, CFDataRef theData, uint64_t a3)
{
  uint64_t v10 = 0;
  CFIndex v11 = &v10;
  uint64_t v12 = 0x2000000000;
  int v13 = -50;
  if (CFDataGetLength(theData) >= 1)
  {
    int v6 = *(NSObject **)(a1 + 128);
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    _OWORD v9[2] = __SecOTRSProcessPacket_block_invoke;
    v9[3] = &unk_1E54819F0;
    void v9[6] = a1;
    v9[7] = a3;
    void v9[4] = &v10;
    void v9[5] = theData;
    dispatch_sync(v6, v9);
  }
  uint64_t v7 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  return v7;
}

void __SecOTRSProcessPacket_block_invoke_2(uint64_t a1)
{
  uint64_t v108 = *MEMORY[0x1E4F143B8];
  CFDataRef v2 = (const __CFData *)SecOTRCopyIncomingBytes(*(const __CFData **)(a1 + 40));
  BytePtr = CFDataGetBytePtr(v2);
  unint64_t Length = CFDataGetLength(v2);
  if (Length >= 2 && ((v5 = __rev16(*(unsigned __int16 *)BytePtr), Length != 2) ? (BOOL v6 = v5 == 2) : (BOOL v6 = 0), v6)) {
    int v7 = BytePtr[2];
  }
  else {
    int v7 = 255;
  }
  __int16 v8 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (*(unsigned char *)(*(void *)(a1 + 48) + 648))
  {
    CFDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  }
  else
  {
    CFDataRef Mutable = *(__CFData **)(a1 + 56);
    if (Mutable) {
      CFRetain(*(CFTypeRef *)(a1 + 56));
    }
  }
  int v10 = -26275;
  if (v7 > 16)
  {
    if (v7 != 17)
    {
      if (v7 != 18) {
        goto LABEL_122;
      }
      uint64_t v18 = *(void *)(a1 + 48);
      if (*(_DWORD *)(v18 + 16) != 3) {
        goto LABEL_105;
      }
      uint64_t v19 = CFDataGetBytePtr(v2);
      unint64_t v20 = CFDataGetLength(v2);
      if (v20 >= 2)
      {
        if (__rev16(*(unsigned __int16 *)v19) != 2) {
          goto LABEL_109;
        }
        if (v20 != 2)
        {
          int v21 = v19[2];
          v95 = (unsigned int *)(v20 - 3);
          *(void *)long long buf = v19 + 3;
          if (v21 == 18)
          {
            int v22 = SecVerifySignatureAndMac(v18, 1, (uint64_t)buf, (uint64_t)&v95);
            if (v22)
            {
              int v10 = v22;
            }
            else
            {
              uint64_t v23 = *(const void **)(v18 + 64);
              if (v23)
              {
                *(void *)(v18 + 64) = 0;
                CFRelease(v23);
              }
              int v10 = 0;
              *(_DWORD *)(v18 + 16) = 4;
            }
            goto LABEL_122;
          }
LABEL_109:
          int v10 = -26275;
          goto LABEL_122;
        }
      }
      int v10 = -50;
      goto LABEL_122;
    }
    uint64_t v34 = *(void *)(a1 + 48);
    if (*(_DWORD *)(v34 + 16) != 2)
    {
LABEL_105:
      int v10 = 0;
      goto LABEL_122;
    }
    uint64_t v35 = CFDataGetBytePtr(v2);
    uint64_t v93 = v35;
    unint64_t v36 = CFDataGetLength(v2);
    unint64_t v92 = v36;
    CFDataRef v37 = *(const __CFData **)(v34 + 56);
    if (!v37) {
      goto LABEL_114;
    }
    if (v36 < 2) {
      goto LABEL_114;
    }
    unsigned int v38 = *(unsigned __int16 *)v35;
    uint64_t v93 = v35 + 2;
    unint64_t v92 = v36 - 2;
    if (v36 == 2) {
      goto LABEL_114;
    }
    if (__rev16(v38) != 2) {
      goto LABEL_114;
    }
    int v39 = v35[2];
    unint64_t v92 = v36 - 3;
    uint64_t v93 = v35 + 3;
    if (v36 - 3 < 4) {
      goto LABEL_114;
    }
    if (v39 != 17) {
      goto LABEL_114;
    }
    unsigned int v40 = bswap32(*(_DWORD *)(v35 + 3));
    unint64_t v92 = v36 - 7;
    uint64_t v93 = v35 + 7;
    if (v40 != 16) {
      goto LABEL_114;
    }
    *(_OWORD *)(v34 + 40) = *(_OWORD *)(v35 + 7);
    unint64_t v92 = v36 - 23;
    uint64_t v93 = v35 + 23;
    *(void *)&long long v41 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)long long buf = v41;
    *(_OWORD *)&uint8_t buf[16] = v41;
    long long v97 = v41;
    long long v98 = v41;
    long long v99 = v41;
    long long v100 = v41;
    long long v101 = v41;
    long long v102 = v41;
    long long v103 = v41;
    long long v104 = v41;
    long long v105 = v41;
    long long v106 = v41;
    int v107 = -1431655766;
    v95 = (unsigned int *)buf;
    uint64_t v42 = CFDataGetBytePtr(v37);
    unint64_t v43 = CFDataGetLength(*(CFDataRef *)(v34 + 56));
    if (v43 >= 2)
    {
      if (__rev16(*(unsigned __int16 *)v42) != 2) {
        goto LABEL_111;
      }
      if (v43 != 2)
      {
        if (v42[2] != 2) {
          goto LABEL_111;
        }
        if (v43 - 3 >= 4)
        {
          uint64_t v44 = bswap32(*(_DWORD *)(v42 + 3));
          uint64_t v94 = v44;
          if (v44 < 0xC5)
          {
            AES_CTR_Transform(16, v34 + 40, (uint64_t)&kIVZero, v44, (uint64_t)(v42 + 7), (uint64_t)buf);
            int v45 = SecOTRSetupTheirKeyFrom(v34, &v95, (unint64_t *)&v94);
            if (!v45)
            {
              int v45 = SecVerifySignatureAndMac(v34, 0, (uint64_t)&v93, (uint64_t)&v92);
              if (!v45)
              {
                SecOTRAppendSignatureMessage(v34, Mutable);
                *(_DWORD *)(v34 + 16) = 4;
                *(void *)long long buf = MEMORY[0x1E4F143A8];
                *(void *)&uint8_t buf[8] = 0x40000000;
                *(void *)&uint8_t buf[16] = __SecOTRSProcessRevealSignatureMessage_block_invoke;
                *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_45_12248;
                *(void *)&long long v97 = v34;
                if (Mutable)
                {
                  CFAllocatorRef v46 = *v8;
                  CFIndex v47 = CFDataGetLength(Mutable);
                  unint64_t v48 = CFStringCreateMutable(v46, 2 * v47);
                  BOOL v49 = CFDataGetBytePtr(Mutable);
                  CFIndex v50 = CFDataGetLength(Mutable);
                  if (v50 >= 1)
                  {
                    CFIndex v51 = v50;
                    do
                    {
                      unsigned int v52 = *v49++;
                      CFStringAppendFormat(v48, 0, @"%02X", v52);
                      --v51;
                    }
                    while (v51);
                  }
                }
                else
                {
                  unint64_t v48 = @"(null)";
                }
                (*(void (**)(unsigned char *, __CFString *))&buf[16])(buf, v48);
                int v10 = 0;
LABEL_121:
                CFRelease(v48);
                goto LABEL_122;
              }
            }
            int v10 = v45;
LABEL_114:
            *(void *)long long buf = MEMORY[0x1E4F143A8];
            *(void *)&uint8_t buf[8] = 0x40000000;
            *(void *)&uint8_t buf[16] = __SecOTRSProcessRevealSignatureMessage_block_invoke_46;
            *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_47_12249;
            *(void *)&long long v97 = v34;
            DWORD2(v97) = v10;
            if (v2)
            {
              CFAllocatorRef v70 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
              CFIndex v71 = CFDataGetLength(v2);
              unint64_t v48 = CFStringCreateMutable(v70, 2 * v71);
              unsigned int v72 = CFDataGetBytePtr(v2);
              CFIndex v73 = CFDataGetLength(v2);
              if (v73 >= 1)
              {
                CFIndex v74 = v73;
                do
                {
                  unsigned int v75 = *v72++;
                  CFStringAppendFormat(v48, 0, @"%02X", v75);
                  --v74;
                }
                while (v74);
              }
            }
            else
            {
              unint64_t v48 = @"(null)";
            }
            (*(void (**)(unsigned char *, __CFString *))&buf[16])(buf, v48);
            __int16 v8 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
            goto LABEL_121;
          }
LABEL_111:
          int v10 = -26275;
          goto LABEL_114;
        }
      }
    }
    int v10 = -50;
    goto LABEL_114;
  }
  if (v7 == 2)
  {
    uint64_t v24 = *(void *)(a1 + 48);
    unint64_t v25 = &stru_1ED84D0B0;
    switch(*(_DWORD *)(v24 + 16))
    {
      case 0:
      case 3:
      case 4:
        goto LABEL_35;
      case 1:
        CFAllocatorRef v27 = *v8;
        CFIndex v53 = CFDataCreateMutable(*v8, 0);
        SecOTRAppendDHMessage(v24, v53);
        GXHash = (unint64_t *)FindGXHash(v53);
        uint64_t v55 = (unint64_t *)FindGXHash(v2);
        if (GXHash) {
          BOOL v56 = v55 == 0;
        }
        else {
          BOOL v56 = 1;
        }
        if (v56)
        {
          BOOL v62 = 0;
          if (v53) {
LABEL_90:
          }
            CFRelease(v53);
        }
        else
        {
          unint64_t v57 = bswap64(*GXHash);
          unint64_t v58 = bswap64(*v55);
          if (v57 == v58
            && (unint64_t v57 = bswap64(GXHash[1]), v58 = bswap64(v55[1]), v57 == v58)
            && (unint64_t v57 = bswap64(GXHash[2]), v58 = bswap64(v55[2]), v57 == v58)
            && (unint64_t v57 = bswap64(GXHash[3]), v58 = bswap64(v55[3]), v57 == v58))
          {
            int v59 = 0;
          }
          else if (v57 < v58)
          {
            int v59 = -1;
          }
          else
          {
            int v59 = 1;
          }
          BOOL v62 = v59 > 0;
          *(void *)long long buf = MEMORY[0x1E4F143A8];
          *(void *)&uint8_t buf[8] = 0x40000000;
          *(void *)&uint8_t buf[16] = __SecOTRMyGXHashIsBigger_block_invoke;
          *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_31_12236;
          *(void *)&long long v97 = v55;
          BufferPerformWithHexString_12237((UInt8 *)GXHash, (uint64_t)buf);
          if (v53) {
            goto LABEL_90;
          }
        }
        if (v62)
        {
          CFIndex v63 = *(const void **)(v24 + 56);
          if (v63)
          {
            *(void *)(v24 + 56) = 0;
            CFRelease(v63);
          }
          SecOTRAppendDHMessage(v24, Mutable);
          unint64_t v25 = @"Our GX is bigger, resending DH";
        }
        else
        {
          unint64_t v25 = @"Our GX is smaller, sending DHKey";
LABEL_35:
          SecOTRInitMyDHKeys(v24);
LABEL_36:
          SecOTRAppendDHKeyMessage(v24, Mutable);
          uint64_t v26 = *(const void **)(v24 + 56);
          if (v26)
          {
            *(void *)(v24 + 56) = 0;
            CFRelease(v26);
          }
          CFAllocatorRef v27 = *v8;
          *(void *)(v24 + 56) = CFDataCreateCopy(*v8, v2);
          *(_DWORD *)(v24 + 16) = 2;
        }
        *(void *)long long buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = __SecOTRSProcessDHMessage_block_invoke;
        *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_29_12240;
        *(void *)&long long v97 = v24;
        *((void *)&v97 + 1) = v25;
        if (Mutable)
        {
          CFIndex v28 = CFDataGetLength(Mutable);
          CFDataRef v29 = CFStringCreateMutable(v27, 2 * v28);
          uint64_t v30 = CFDataGetBytePtr(Mutable);
          CFIndex v31 = CFDataGetLength(Mutable);
          if (v31 >= 1)
          {
            CFIndex v32 = v31;
            do
            {
              unsigned int v33 = *v30++;
              CFStringAppendFormat(v29, 0, @"%02X", v33);
              --v32;
            }
            while (v32);
          }
        }
        else
        {
LABEL_103:
          CFDataRef v29 = @"(null)";
        }
LABEL_104:
        (*(void (**)(unsigned char *, __CFString *))&buf[16])(buf, v29);
        CFRelease(v29);
        goto LABEL_105;
      case 2:
        goto LABEL_36;
      default:
        CFIndex v60 = secLogObjForScope("otr");
        int v10 = -25308;
        if (!os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_122;
        }
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v24;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = -25308;
        goto LABEL_85;
    }
  }
  if (v7 != 10) {
    goto LABEL_122;
  }
  uint64_t v11 = *(void *)(a1 + 48);
  uint64_t v12 = CFDataGetBytePtr(v2);
  unint64_t v13 = CFDataGetLength(v2);
  if (v13 > 2
    && __rev16(*(unsigned __int16 *)v12) == 2
    && (int v14 = v12[2], v95 = (unsigned int *)(v13 - 3), *(void *)buf = v12 + 3, v14 == 10))
  {
    int v15 = SecOTRSetupTheirKeyFrom(v11, (unsigned int **)buf, (unint64_t *)&v95);
    if (!v15)
    {
      uint64_t v16 = @"Ignoring DHKey message";
      switch(*(_DWORD *)(v11 + 16))
      {
        case 0:
        case 2:
        case 4:
          goto LABEL_98;
        case 1:
          CFIndex v17 = *(const void **)(v11 + 64);
          if (v17)
          {
            *(void *)(v11 + 64) = 0;
            CFRelease(v17);
          }
          SecOTRAppendRevealSignatureMessage(v11, Mutable);
          *(_DWORD *)(v11 + 16) = 3;
          *(void *)(v11 + 64) = CFDataCreateCopy(*v8, v2);
          uint64_t v16 = @"Sending reveal signature";
          goto LABEL_98;
        case 3:
          CFDataRef v61 = *(const __CFData **)(v11 + 64);
          if (v2 && v61)
          {
            if (CFEqual(v2, v61))
            {
LABEL_81:
              SecOTRAppendRevealSignatureMessage(v11, Mutable);
              uint64_t v16 = @"Resending reveal signature";
              goto LABEL_98;
            }
          }
          else if (v61 == v2)
          {
            goto LABEL_81;
          }
          uint64_t v16 = @"Ignoring new DHKey message";
LABEL_98:
          *(void *)long long buf = MEMORY[0x1E4F143A8];
          *(void *)&uint8_t buf[8] = 0x40000000;
          *(void *)&uint8_t buf[16] = __SecOTRSProcessDHKeyMessage_block_invoke;
          *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_44_12246;
          *(void *)&long long v97 = v11;
          *((void *)&v97 + 1) = v16;
          if (!Mutable) {
            goto LABEL_103;
          }
          CFAllocatorRef v64 = *v8;
          CFIndex v65 = CFDataGetLength(Mutable);
          CFDataRef v29 = CFStringCreateMutable(v64, 2 * v65);
          CFAllocatorRef v66 = CFDataGetBytePtr(Mutable);
          CFIndex v67 = CFDataGetLength(Mutable);
          if (v67 >= 1)
          {
            CFIndex v68 = v67;
            do
            {
              unsigned int v69 = *v66++;
              CFStringAppendFormat(v29, 0, @"%02X", v69);
              --v68;
            }
            while (v68);
          }
          break;
        default:
          int v10 = -25308;
          goto LABEL_83;
      }
      goto LABEL_104;
    }
    int v10 = v15;
  }
  else
  {
    int v10 = -50;
  }
LABEL_83:
  CFIndex v60 = secLogObjForScope("otr");
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v11;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v10;
LABEL_85:
    _os_log_impl(&dword_18B299000, v60, OS_LOG_TYPE_DEFAULT, "%@ Process DH failed %d", buf, 0x12u);
  }
LABEL_122:
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v10;
  uint64_t v76 = *(void *)(a1 + 32);
  uint64_t v77 = *(void *)(a1 + 48);
  if (*(_DWORD *)(*(void *)(v76 + 8) + 24))
  {
    uint64_t v85 = MEMORY[0x1E4F143A8];
    uint64_t v86 = 0x40000000;
    uint64_t v87 = __SecOTRSProcessPacket_block_invoke_3;
    uint64_t v88 = &unk_1E54819A0;
    uint64_t v89 = v76;
    uint64_t v90 = v77;
    int v91 = v7;
    if (v2)
    {
      CFAllocatorRef v78 = *v8;
      CFIndex v79 = CFDataGetLength(v2);
      CFDataRef v80 = CFStringCreateMutable(v78, 2 * v79);
      uint64_t v81 = CFDataGetBytePtr(v2);
      CFIndex v82 = CFDataGetLength(v2);
      if (v82 >= 1)
      {
        CFIndex v83 = v82;
        do
        {
          unsigned int v84 = *v81++;
          CFStringAppendFormat(v80, 0, @"%02X", v84, v85, v86);
          --v83;
        }
        while (v83);
      }
    }
    else
    {
      CFDataRef v80 = @"(null)";
    }
    v87((uint64_t)&v85, (uint64_t)v80);
    CFRelease(v80);
    uint64_t v77 = *(void *)(a1 + 48);
  }
  if (*(unsigned char *)(v77 + 648)) {
    SecOTRPrepareOutgoingBytes(Mutable, *(__CFData **)(a1 + 56));
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v2) {
    CFRelease(v2);
  }
}

const UInt8 *FindGXHash(const __CFData *a1)
{
  BytePtr = CFDataGetBytePtr(a1);
  unint64_t Length = CFDataGetLength(a1);
  if (Length < 2) {
    return 0;
  }
  unint64_t v4 = Length;
  uint64_t result = 0;
  if (v4 != 2 && __rev16(*(unsigned __int16 *)BytePtr) == 2)
  {
    uint64_t result = 0;
    if (v4 - 3 >= 4 && BytePtr[2] == 2)
    {
      unint64_t v6 = bswap32(*(_DWORD *)(BytePtr + 3));
      unint64_t v7 = v4 - 7;
      BOOL v8 = v7 >= v6;
      unint64_t v9 = v7 - v6;
      if (!v8) {
        return 0;
      }
      BOOL v8 = v9 >= 4;
      unint64_t v10 = v9 - 4;
      if (!v8) {
        return 0;
      }
      uint64_t v11 = &BytePtr[v6];
      unint64_t v12 = bswap32(*(_DWORD *)(v11 + 7));
      unint64_t v13 = v11 + 11;
      if (v10 >= v12 && v12 == 32) {
        return v13;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

void __SecOTRMyGXHashIsBigger_block_invoke(uint64_t a1)
{
}

void BufferPerformWithHexString_12237(UInt8 *bytes, uint64_t a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef v4 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 32, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (v4)
  {
    CFDataRef v5 = v4;
    CFIndex Length = CFDataGetLength(v4);
    CFDataRef Mutable = CFStringCreateMutable(v3, 2 * Length);
    BytePtr = CFDataGetBytePtr(v5);
    CFIndex v9 = CFDataGetLength(v5);
    if (v9 >= 1)
    {
      CFIndex v10 = v9;
      do
      {
        unsigned int v11 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0, @"%02X", v11);
        --v10;
      }
      while (v10);
    }
    (*(void (**)(uint64_t, __CFString *))(a2 + 16))(a2, Mutable);
    CFRelease(Mutable);
  }
  else
  {
    CFDataRef v5 = (const __CFData *)@"(null)";
    (*(void (**)(uint64_t, __CFString *))(a2 + 16))(a2, @"(null)");
  }

  CFRelease(v5);
}

void __SecOTRSProcessDHMessage_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDataRef v4 = secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138412802;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    uint64_t v10 = v6;
    __int16 v11 = 2112;
    uint64_t v12 = a2;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "%@ %@: %@", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t SecOTRSetupTheirKeyFrom(uint64_t a1, unsigned int **a2, unint64_t *a3)
{
  CFDataRef v4 = SecOTRPublicDHKCreateFromSerialization(*MEMORY[0x1E4F1CF80], a2, a3);
  if (!v4) {
    return 4294941021;
  }
  SecOTRSetupInitialRemoteKey(a1, (uint64_t)v4);
  return 0;
}

void __SecOTRSProcessDHKeyMessage_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDataRef v4 = secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138412802;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    uint64_t v10 = v6;
    __int16 v11 = 2112;
    uint64_t v12 = a2;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "%@ %@: %@", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t SecVerifySignatureAndMac(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  int v12 = -26275;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  _DWORD v7[2] = __SecVerifySignatureAndMac_block_invoke;
  unint64_t v7[3] = &unk_1E5481B50;
  char v8 = a2;
  UInt8 v7[4] = &v9;
  void v7[5] = a1;
  void v7[6] = a3;
  v7[7] = a4;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 0x40000000;
  void v13[2] = __PerformWithBufferAndClear_block_invoke;
  v13[3] = &unk_1E5484FC8;
  UInt8 v13[4] = v7;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[0] = v4;
  v14[1] = v4;
  __PerformWithBufferAndClear_block_invoke((uint64_t)v13, 0x20uLL, v14);
  uint64_t v5 = *((unsigned int *)v10 + 6);
  _Block_object_dispose(&v9, 8);
  return v5;
}

void __SecOTRSProcessRevealSignatureMessage_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  long long v4 = secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "%@ Sending Signature message: %@", (uint8_t *)&v6, 0x16u);
  }
}

void __SecOTRSProcessRevealSignatureMessage_block_invoke_46(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  long long v4 = secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = *(_DWORD *)(a1 + 40);
    int v7 = 138412802;
    uint64_t v8 = v5;
    __int16 v9 = 1024;
    int v10 = v6;
    __int16 v11 = 2112;
    uint64_t v12 = a2;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "%@ Failed to process reveal sig message (%d): %@", (uint8_t *)&v7, 0x1Cu);
  }
}

void __SecOTRSProcessPacket_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  long long v4 = secLogObjForScope("session");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 40);
    int v6 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    int v7 = *(_DWORD *)(a1 + 48);
    int v8 = *(_DWORD *)(v5 + 16);
    int v9 = *(_DWORD *)(v5 + 72);
    uint64_t v10 = *(void *)(v5 + 80);
    uint64_t v11 = *(void *)(v5 + 88);
    int v12 = *(_DWORD *)(v5 + 96);
    uint64_t v14 = *(void *)(v5 + 104);
    uint64_t v13 = *(void *)(v5 + 112);
    int v15 = 138414850;
    uint64_t v16 = v5;
    __int16 v17 = 1024;
    int v18 = v6;
    __int16 v19 = 1024;
    int v20 = v7;
    __int16 v21 = 1024;
    int v22 = v8;
    __int16 v23 = 1024;
    int v24 = v9;
    __int16 v25 = 2048;
    uint64_t v26 = v10;
    __int16 v27 = 2048;
    uint64_t v28 = v11;
    __int16 v29 = 1024;
    int v30 = v12;
    __int16 v31 = 2048;
    uint64_t v32 = v13;
    __int16 v33 = 2048;
    uint64_t v34 = v14;
    __int16 v35 = 2112;
    uint64_t v36 = a2;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "%@ Error %d processing packet type %d, session state %d, keyid %d, myKey %p, myNextKey %p, theirKeyId %d, theirKey %p, theirPreviousKey %p, bytes %@", (uint8_t *)&v15, 0x5Cu);
  }
}

void __SecVerifySignatureAndMac_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void v13[2] = *MEMORY[0x1E4F143B8];
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  void v4[2] = __SecVerifySignatureAndMac_block_invoke_3;
  v4[3] = &unk_1E5481B00;
  char v11 = *(unsigned char *)(a1 + 80);
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = v3;
  uint64_t v8 = a2;
  uint64_t v9 = a3;
  long long v5 = *(_OWORD *)(a1 + 32);
  long long v10 = *(_OWORD *)(a1 + 64);
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 0x40000000;
  void v12[2] = __PerformWithBufferAndClear_block_invoke;
  v12[3] = &unk_1E5484FC8;
  void v12[4] = v4;
  v13[0] = 0xAAAAAAAAAAAAAAAALL;
  v13[1] = 0xAAAAAAAAAAAAAAAALL;
  __PerformWithBufferAndClear_block_invoke((uint64_t)v12, 0x10uLL, v13);
}

void __SecVerifySignatureAndMac_block_invoke_3(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v37 = v6;
  long long v38 = v6;
  long long v35 = v6;
  long long v36 = v6;
  long long v33 = v6;
  long long v34 = v6;
  long long v31 = v6;
  long long v32 = v6;
  long long v29 = v6;
  long long v30 = v6;
  long long v27 = v6;
  long long v28 = v6;
  ccn_zero();
  *(void *)&long long __src = 192;
  ccec_compute_key();
  if (*(unsigned char *)(a1 + 96)) {
    UInt8 v7 = 4;
  }
  else {
    UInt8 v7 = 2;
  }
  HashMPIWithPrefix(v7, 24, (uint64_t)&v27, *(unsigned __int8 **)(a1 + 56));
  if (*(unsigned char *)(a1 + 96)) {
    UInt8 v8 = 5;
  }
  else {
    UInt8 v8 = 3;
  }
  HashMPIWithPrefix(v8, 24, (uint64_t)&v27, *(unsigned __int8 **)(a1 + 72));
  int v9 = *(unsigned __int8 *)(a1 + 96);
  if (*(unsigned char *)(a1 + 96)) {
    long long v10 = a3;
  }
  else {
    long long v10 = 0;
  }
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long __src = v11;
  long long v40 = v11;
  HashMPIWithPrefix(1u, 24, (uint64_t)&v27, (unsigned __int8 *)&__src);
  if (!v9 && a3)
  {
    if (a2 >= 0x10) {
      size_t v12 = 16;
    }
    else {
      size_t v12 = a2;
    }
    memcpy(a3, &__src, v12);
  }
  if (v10)
  {
    if (a2 >= 0x10) {
      size_t v13 = 16;
    }
    else {
      size_t v13 = a2;
    }
    memcpy(v10, &__src, v13);
  }
  uint64_t v14 = *(unsigned int ***)(a1 + 80);
  int v15 = *(uint64_t **)(a1 + 88);
  uint64_t v16 = *v14;
  if (v15 && (uint64_t v17 = *v15 - 4, (unint64_t)*v15 >= 4))
  {
    int v18 = 0;
    unsigned int v19 = bswap32(*v16);
    *uint64_t v14 = v16 + 1;
    *int v15 = v17;
  }
  else
  {
    unsigned int v19 = 0;
    int v18 = -50;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v18;
  uint64_t v20 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(_DWORD *)(v20 + 24))
  {
    if (v19 > 4 && **(void **)(a1 + 88) >= (unint64_t)v19)
    {
      *(void *)&long long v21 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long __src = v21;
      long long v40 = v21;
      ccsha256_di();
      cchmac();
      if (**(void **)(a1 + 88) >= (unint64_t)(v19 + 20) && !cc_cmp_safe())
      {
        v25[0] = MEMORY[0x1E4F143A8];
        v25[1] = 0x40000000;
        v25[2] = __SecVerifySignatureAndMac_block_invoke_4;
        unint64_t v25[3] = &unk_1E5481AD8;
        uint64_t v22 = *(void *)(a1 + 48);
        uint64_t v24 = *(void *)(a1 + 32);
        uint64_t v23 = *(void *)(a1 + 40);
        v25[6] = *(void *)(a1 + 56);
        v25[7] = v23;
        void v25[8] = a2;
        v25[9] = a3;
        unsigned int v26 = v19;
        v25[10] = *(void *)(a1 + 80);
        v25[4] = v24;
        v25[5] = v22;
        *(void *)&long long v27 = MEMORY[0x1E4F143A8];
        *((void *)&v27 + 1) = 0x40000000;
        *(void *)&long long v28 = __PerformWithBufferAndClear_block_invoke;
        *((void *)&v28 + 1) = &unk_1E5484FC8;
        *(void *)&long long v29 = v25;
        PerformWithBuffer(v19, (uint64_t)&v27);
        return;
      }
      uint64_t v20 = *(void *)(*(void *)(a1 + 32) + 8);
    }
    *(_DWORD *)(v20 + 24) = -26275;
  }
}

void __SecVerifySignatureAndMac_block_invoke_4(uint64_t a1, uint64_t a2, const UInt8 *a3)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  ccsha256_di();
  ccsha256_di();
  uint64_t v5 = ccsha256_di();
  MEMORY[0x1F4188790](v5);
  if (v8 >= 8) {
    memset((char *)v47 - v7, 170, v6);
  }
  ccsha256_di();
  cchmac_init();
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  AppendECPublicKeyAsDATA(Mutable);
  SecFDHKAppendPublicSerialization(*(void *)(*(void *)(a1 + 56) + 80), Mutable);
  ccsha256_di();
  CFDataGetLength(Mutable);
  CFDataGetBytePtr(Mutable);
  cchmac_update();
  if (Mutable) {
    CFRelease(Mutable);
  }
  AES_CTR_Transform(*(void *)(a1 + 64), *(void *)(a1 + 72), (uint64_t)&kIVZero, *(unsigned int *)(a1 + 88), **(void **)(a1 + 80), (uint64_t)a3);
  unint64_t v11 = *(unsigned int *)(a1 + 88);
  if (v11 < 2)
  {
    int v12 = -50;
    unsigned int v14 = 43690;
    size_t v13 = a3;
  }
  else
  {
    int v12 = 0;
    size_t v13 = a3 + 2;
    unsigned int v14 = __rev16(*(unsigned __int16 *)a3);
    v11 -= 2;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v12;
  uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(_DWORD *)(v15 + 24)) {
    return;
  }
  if (v14 != 61440)
  {
    int v44 = -4;
LABEL_49:
    *(_DWORD *)(v15 + 24) = v44;
    return;
  }
  if (v11 < 4)
  {
    int v16 = -50;
    unsigned int v18 = -1431655766;
  }
  else
  {
    int v16 = 0;
    unsigned int v17 = *(_DWORD *)v13;
    v13 += 4;
    unsigned int v18 = bswap32(v17);
    v11 -= 4;
  }
  *(_DWORD *)(v15 + 24) = v16;
  uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(_DWORD *)(v15 + 24)) {
    return;
  }
  if (v11 < v18)
  {
    int v44 = -26275;
    goto LABEL_49;
  }
  CFIndex v19 = v18;
  ccsha256_di();
  cchmac_update();
  *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v51[0] = v20;
  v51[1] = v20;
  ccsha256_di();
  cchmac_final();
  uint64_t v21 = *(void *)(*(void *)(a1 + 56) + 32);
  CFDataRef v22 = CFDataCreateWithBytesNoCopy(v9, v13, v19, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  CFDataRef v23 = CFDataCreateMutable(v9, 0);
  SecOTRPIAppendSerialization(v21, v23, 0);
  if (v22 && v23)
  {
    if (CFEqual(v22, v23))
    {
      char v24 = 1;
LABEL_27:
      CFRelease(v22);
      goto LABEL_28;
    }
    goto LABEL_18;
  }
  if (v22 != v23)
  {
LABEL_18:
    v48[0] = MEMORY[0x1E4F143A8];
    v48[1] = 0x40000000;
    v49[0] = __SecOTRPIEqualToBytes_block_invoke;
    v49[1] = &__block_descriptor_tmp_6_11937;
    v49[2] = v23;
    if (v22)
    {
      CFIndex Length = CFDataGetLength(v22);
      unsigned int v26 = CFStringCreateMutable(v9, 2 * Length);
      BytePtr = CFDataGetBytePtr(v22);
      CFIndex v28 = CFDataGetLength(v22);
      if (v28 >= 1)
      {
        CFIndex v29 = v28;
        v47[1] = v49;
        do
        {
          unsigned int v30 = *BytePtr++;
          CFStringAppendFormat(v26, 0, @"%02X", v30);
          --v29;
        }
        while (v29);
      }
    }
    else
    {
      unsigned int v26 = @"(null)";
    }
    ((void (*)(uint64_t *, __CFString *))v49[0])(v48, v26);
    CFRelease(v26);
    char v24 = 0;
    if (v22) {
      goto LABEL_27;
    }
    goto LABEL_28;
  }
  char v24 = 1;
  if (v22) {
    goto LABEL_27;
  }
LABEL_28:
  if (v23) {
    CFRelease(v23);
  }
  if ((v24 & 1) == 0)
  {
    uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8);
    int v44 = -25293;
    goto LABEL_49;
  }
  long long v31 = (unsigned int *)&v13[v19];
  unint64_t v32 = v11 - v19;
  uint64_t v33 = *(void *)(a1 + 56);
  if (v11 - v19 < 4)
  {
    int v34 = -50;
  }
  else
  {
    int v34 = 0;
    unsigned int v35 = *v31++;
    *(_DWORD *)(v33 + 96) = bswap32(v35);
    unint64_t v32 = v11 - v19 - 4;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v34;
  uint64_t v36 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(_DWORD *)(v36 + 24))
  {
    if (v32 < 4)
    {
      int v37 = -50;
      unint64_t v39 = 2863311530;
    }
    else
    {
      int v37 = 0;
      unsigned int v38 = *v31++;
      unint64_t v39 = bswap32(v38);
      v32 -= 4;
    }
    *(_DWORD *)(v36 + 24) = v37;
    uint64_t v40 = *(void *)(*(void *)(a1 + 32) + 8);
    if (!*(_DWORD *)(v40 + 24))
    {
      if (v32 < v39)
      {
        *(_DWORD *)(v40 + 24) = -26275;
        return;
      }
      uint64_t v41 = *(void *)(v33 + 32);
      if (v39)
      {
        CFIndex v42 = *(unsigned __int8 *)v31;
        if (v39 - 1 == v42)
        {
          long long v31 = (unsigned int *)((char *)v31 + 1);
          if (!SecKeyDigestAndVerify(*(void *)(v41 + 16), (const SecAsn1Oid *)kOTRSignatureAlgIDPtr, (const UInt8 *)v51, 32, (const UInt8 *)v31, v42))goto LABEL_41; {
        }
          }
        else
        {
          CFIndex v42 = v39;
        }
      }
      else
      {
        CFIndex v42 = 0;
      }
      int v45 = (const UInt8 *)malloc_type_malloc(v42 + 3, 0x74E7695uLL);
      CFAllocatorRef v46 = (UInt8 *)v45;
      if (!v45
        || (v48[0] = 8, CFIndex v50 = v45, SecOTRPIRecreateSignature((uint64_t)v31, v42, (uint64_t *)&v50, v48), !v50)
        || SecKeyDigestAndVerify(*(void *)(v41 + 16), (const SecAsn1Oid *)kOTRSignatureAlgIDPtr, (const UInt8 *)v51, 32, v50, v48[0]))
      {
        free(v46);
        int v43 = -26275;
        goto LABEL_42;
      }
      free(v46);
LABEL_41:
      int v43 = 0;
LABEL_42:
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v43;
    }
  }
}

void SecOTRCreateError(int a1, CFIndex code, void *a3, CFTypeRef cf, CFErrorRef *a5)
{
  userInfoKeys[2] = *(void **)MEMORY[0x1E4F143B8];
  if (a5 && !*a5)
  {
    size_t v6 = (void *)*MEMORY[0x1E4F1D190];
    userInfoKeys[0] = *(void **)MEMORY[0x1E4F1D140];
    userInfoKeys[1] = v6;
    userInfoValues[0] = a3;
    userInfoValues[1] = (void *)cf;
    if (a1) {
      CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1D158];
    }
    else {
      CFStringRef v7 = @"com.apple.security.otr.error";
    }
    if (cf) {
      CFIndex v8 = 2;
    }
    else {
      CFIndex v8 = 1;
    }
    *a5 = CFErrorCreateWithUserInfoKeysAndValues((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7, code, (const void *const *)userInfoKeys, (const void *const *)userInfoValues, v8);
  }
  else if (cf)
  {
    CFRelease(cf);
  }
}

uint64_t appendSizeAndData(const __CFData *a1, __CFData *a2)
{
  CFIndex Length = CFDataGetLength(a1);
  if (Length >= 0xFFFF) {
    return 4294942005;
  }
  *(_WORD *)UInt8 bytes = bswap32(Length) >> 16;
  CFDataAppendBytes(a2, bytes, 2);
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex v6 = CFDataGetLength(a1);
  CFDataAppendBytes(a2, BytePtr, v6);
  return 0;
}

uint64_t appendPublicOctetsAndSize(uint64_t a1, __CFData *a2)
{
  CFTypeRef cf = 0;
  if (SecKeyCopyPublicBytes(a1, (uint64_t)&cf))
  {
    uint64_t appended = 4294941021;
  }
  else
  {
    if (!cf) {
      return 4294941021;
    }
    uint64_t appended = appendSizeAndData((const __CFData *)cf, a2);
  }
  CFTypeRef v4 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v4);
  }
  return appended;
}

void *CreateECPublicKeyFrom(const UInt8 **a1, unint64_t *a2)
{
  uint64_t v3 = 0;
  LODWORD(v4) = 0;
  if (a1 && a2)
  {
    unint64_t v5 = *a2 - 2;
    if (*a2 < 2)
    {
      LODWORD(v4) = 0;
LABEL_9:
      uint64_t v3 = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *a1 + 2;
    unint64_t v4 = __rev16(*(unsigned __int16 *)*a1);
    *a2 = v5;
    *a1 = v3;
    BOOL v6 = v5 >= v4;
    unint64_t v7 = v5 - v4;
    if (!v6) {
      goto LABEL_9;
    }
    *a2 = v7;
    *a1 = &v3[v4];
  }
LABEL_7:
  uint64_t v8 = *MEMORY[0x1E4F1CF80];
  CFDataRef v9 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v3, v4);
  long long v10 = SecKeyCreateFromPublicData(v8, 3, v9);
  CFRelease(v9);
  return v10;
}

uint64_t SecOTRCopyIncomingBytes(const __CFData *a1)
{
  uint64_t v16 = 0;
  unsigned int v17 = &v16;
  uint64_t v18 = 0x2000000000;
  uint64_t v19 = 0;
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"?OTR:", 0x8000100u, 0x3Fu);
  v20.CFIndex length = CFDataGetLength(a1);
  v20.location = 0;
  CFRange v4 = CFDataFind(a1, ExternalRepresentation, v20, 0);
  if (v4.location == -1)
  {
    unint64_t v11 = v17;
    CFDataRef v12 = (const __CFData *)v17[3];
    if (v12 != a1)
    {
      if (!a1 || (CFRetain(a1), (CFDataRef v12 = (const __CFData *)v11[3]) != 0)) {
        CFRelease(v12);
      }
      unint64_t v11[3] = (uint64_t)a1;
    }
  }
  else
  {
    CFDataRef v5 = CFStringCreateExternalRepresentation(v2, @".", 0x8000100u, 0x3Fu);
    v21.CFIndex length = CFDataGetLength(a1);
    v21.location = 0;
    CFIndex v6 = CFDataFind(a1, v5, v21, 0).location - v4.length;
    BytePtr = CFDataGetBytePtr(a1);
    CFDataRef v8 = CFDataCreateWithBytesNoCopy(v2, &BytePtr[v4.length], v6, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    CFDataGetBytePtr(v8);
    unint64_t Length = CFDataGetLength(v8);
    unint64_t v10 = Length >> 2;
    if ((Length & 3) != 0) {
      ++v10;
    }
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 0x40000000;
    uint64_t v15[2] = __SecOTRCopyIncomingBytes_block_invoke;
    unint64_t v15[3] = &unk_1E5481B78;
    void v15[4] = &v16;
    v15[5] = v8;
    PerformWithBuffer(3 * v10, (uint64_t)v15);
    CFRelease(v8);
    CFRelease(v5);
  }
  CFRelease(ExternalRepresentation);
  uint64_t v13 = v17[3];
  _Block_object_dispose(&v16, 8);
  return v13;
}

char *__SecOTRCopyIncomingBytes_block_invoke(uint64_t a1, unint64_t a2, UInt8 *a3)
{
  BytePtr = (unsigned __int8 *)CFDataGetBytePtr(*(CFDataRef *)(a1 + 40));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 40));
  uint64_t result = SecBase64Decode_(BytePtr, Length, a3, a2, 0, &v10, &v9);
  if ((unint64_t)(result - 1) < a2)
  {
    uint64_t result = (char *)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a3, (CFIndex)result);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  }
  return result;
}

void SecOTRPrepareOutgoingBytes(const __CFData *a1, __CFData *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"?OTR:", 0x8000100u, 0x3Fu);
  CFDataRef v6 = CFStringCreateExternalRepresentation(v4, @".", 0x8000100u, 0x3Fu);
  CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  size_t v8 = (2 * (((unint64_t)(Length + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  MEMORY[0x1F4188790](Length);
  unint64_t v10 = &v24[-v9];
  if (v8)
  {
    memset(&v24[-v9], 170, v8);
    BytePtr = CFDataGetBytePtr(a1);
    CFIndex v12 = CFDataGetLength(a1);
    uint64_t v13 = (unsigned __int8 *)BytePtr;
    unsigned int v14 = (UInt8 *)v10;
    unint64_t v15 = v8;
  }
  else
  {
    uint64_t v16 = CFDataGetBytePtr(a1);
    CFIndex v12 = CFDataGetLength(a1);
    uint64_t v13 = (unsigned __int8 *)v16;
    unsigned int v14 = (UInt8 *)v10;
    unint64_t v15 = 0;
  }
  SecBase64Encode_(v13, v12, v14, v15, 0, &v25);
  CFDataRef v17 = CFDataCreateWithBytesNoCopy(v4, v10, v8, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  uint64_t v18 = CFDataGetBytePtr(ExternalRepresentation);
  CFIndex v19 = CFDataGetLength(ExternalRepresentation);
  CFDataAppendBytes(a2, v18, v19);
  CFRange v20 = CFDataGetBytePtr(v17);
  CFIndex v21 = CFDataGetLength(v17);
  CFDataAppendBytes(a2, v20, v21);
  CFDataRef v22 = CFDataGetBytePtr(v6);
  CFIndex v23 = CFDataGetLength(v6);
  CFDataAppendBytes(a2, v22, v23);
  CFRelease(ExternalRepresentation);
  CFRelease(v6);
  CFRelease(v17);
}

void hmac_sha1_PRF(void *key, size_t keyLength, const void *a3, size_t a4, void *a5)
{
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v9.ctx[88] = v8;
  *(_OWORD *)&v9.ctx[92] = v8;
  *(_OWORD *)&v9.ctx[80] = v8;
  *(_OWORD *)&v9.ctx[84] = v8;
  *(_OWORD *)&v9.ctx[72] = v8;
  *(_OWORD *)&v9.ctx[76] = v8;
  *(_OWORD *)&v9.ctx[64] = v8;
  *(_OWORD *)&v9.ctx[68] = v8;
  *(_OWORD *)&v9.ctx[56] = v8;
  *(_OWORD *)&v9.ctx[60] = v8;
  *(_OWORD *)&v9.ctx[48] = v8;
  *(_OWORD *)&v9.ctx[52] = v8;
  *(_OWORD *)&v9.ctx[40] = v8;
  *(_OWORD *)&v9.ctx[44] = v8;
  *(_OWORD *)&v9.ctx[32] = v8;
  *(_OWORD *)&v9.ctx[36] = v8;
  *(_OWORD *)&v9.ctx[24] = v8;
  *(_OWORD *)&v9.ctx[28] = v8;
  *(_OWORD *)&v9.ctx[16] = v8;
  *(_OWORD *)&v9.ctx[20] = v8;
  *(_OWORD *)&v9.ctx[8] = v8;
  *(_OWORD *)&v9.ctx[12] = v8;
  *(_OWORD *)v9.ctx = v8;
  *(_OWORD *)&v9.ctx[4] = v8;
  CCHmacInit(&v9, 0, key, keyLength);
  CCHmacUpdate(&v9, a3, a4);
  CCHmacFinal(&v9, a5);
}

void hmac_sha256_PRF(void *key, size_t keyLength, const void *a3, size_t a4, void *a5)
{
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v9.ctx[88] = v8;
  *(_OWORD *)&v9.ctx[92] = v8;
  *(_OWORD *)&v9.ctx[80] = v8;
  *(_OWORD *)&v9.ctx[84] = v8;
  *(_OWORD *)&v9.ctx[72] = v8;
  *(_OWORD *)&v9.ctx[76] = v8;
  *(_OWORD *)&v9.ctx[64] = v8;
  *(_OWORD *)&v9.ctx[68] = v8;
  *(_OWORD *)&v9.ctx[56] = v8;
  *(_OWORD *)&v9.ctx[60] = v8;
  *(_OWORD *)&v9.ctx[48] = v8;
  *(_OWORD *)&v9.ctx[52] = v8;
  *(_OWORD *)&v9.ctx[40] = v8;
  *(_OWORD *)&v9.ctx[44] = v8;
  *(_OWORD *)&v9.ctx[32] = v8;
  *(_OWORD *)&v9.ctx[36] = v8;
  *(_OWORD *)&v9.ctx[24] = v8;
  *(_OWORD *)&v9.ctx[28] = v8;
  *(_OWORD *)&v9.ctx[16] = v8;
  *(_OWORD *)&v9.ctx[20] = v8;
  *(_OWORD *)&v9.ctx[8] = v8;
  *(_OWORD *)&v9.ctx[12] = v8;
  *(_OWORD *)v9.ctx = v8;
  *(_OWORD *)&v9.ctx[4] = v8;
  CCHmacInit(&v9, 2u, key, keyLength);
  CCHmacUpdate(&v9, a3, a4);
  CCHmacFinal(&v9, a5);
}

uint64_t pbkdf2_hmac_sha1(uint64_t a1, uint64_t a2, void *a3, size_t a4, unsigned int a5, char *a6, unint64_t a7)
{
  size_t v14 = a4 + 60;
  unint64_t v15 = (char *)malloc_type_malloc(a4 + 60, 0x5B5C87F3uLL);
  if (!v15) {
    return 4294899624;
  }
  uint64_t v16 = v15;
  pbkdf2((void (*)(uint64_t, uint64_t, char *, size_t, char *))hmac_sha1_PRF, 0x14uLL, a1, a2, a3, a4, a5, a6, a7, v15);
  bzero(v16, v14);
  return 0;
}

uint64_t pbkdf2_hmac_sha256(uint64_t a1, uint64_t a2, void *a3, size_t a4, unsigned int a5, char *a6, unint64_t a7)
{
  size_t v14 = a4 + 96;
  unint64_t v15 = (char *)malloc_type_malloc(a4 + 96, 0xBFDA9C05uLL);
  if (!v15) {
    return 4294899624;
  }
  uint64_t v16 = v15;
  pbkdf2((void (*)(uint64_t, uint64_t, char *, size_t, char *))hmac_sha256_PRF, 0x20uLL, a1, a2, a3, a4, a5, a6, a7, v15);
  bzero(v16, v14);
  return 0;
}

uint64_t SecKeyFromPassphraseDataHMACSHA1(const __CFData *a1, const __CFData *a2, unsigned int a3, __CFData *a4)
{
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  unint64_t v10 = (UInt8 *)CFDataGetBytePtr(a2);
  CFIndex v11 = CFDataGetLength(a2);
  MutableBytePtr = (char *)CFDataGetMutableBytePtr(a4);
  CFIndex v13 = CFDataGetLength(a4);

  return pbkdf2_hmac_sha1((uint64_t)BytePtr, Length, v10, v11, a3, MutableBytePtr, v13);
}

uint64_t SecKeyFromPassphraseDataHMACSHA256(const __CFData *a1, const __CFData *a2, unsigned int a3, __CFData *a4)
{
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  unint64_t v10 = (UInt8 *)CFDataGetBytePtr(a2);
  CFIndex v11 = CFDataGetLength(a2);
  MutableBytePtr = (char *)CFDataGetMutableBytePtr(a4);
  CFIndex v13 = CFDataGetLength(a4);

  return pbkdf2_hmac_sha256((uint64_t)BytePtr, Length, v10, v11, a3, MutableBytePtr, v13);
}

uint64_t CryptoTokenKitLibraryCore()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 0;
  uint64_t v3 = &v2;
  uint64_t v4 = 0x2020000000;
  uint64_t v0 = CryptoTokenKitLibraryCore_frameworkLibrary;
  uint64_t v5 = CryptoTokenKitLibraryCore_frameworkLibrary;
  if (!CryptoTokenKitLibraryCore_frameworkLibrary)
  {
    long long v6 = xmmword_1E5481B98;
    long long v7 = *(_OWORD *)&off_1E5481BA8;
    v3[3] = _sl_dlopen();
    CryptoTokenKitLibraryCore_frameworkLibrary = v3[3];
    uint64_t v0 = v3[3];
  }
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_18B3AE8E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CryptoTokenKitLibraryCore_block_invoke(uint64_t a1)
{
  uint64_t result = _sl_dlopen();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  CryptoTokenKitLibraryCore_frameworkLibrary = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *CryptoTokenKitLibrary()
{
  uint64_t v0 = CryptoTokenKitLibraryCore();
  if (v0) {
    return (void *)v0;
  }
  unsigned int v1 = [MEMORY[0x1E4F28B00] currentHandler];
  uint64_t v3 = [NSString stringWithUTF8String:"void *CryptoTokenKitLibrary(void)"];
  objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v3, @"SecSoftLink.m", 26, @"%s", 0);

  __break(1u);
  free(v4);
  return v1;
}

id getTKClientTokenClass()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)getTKClientTokenClass_softClass;
  uint64_t v7 = getTKClientTokenClass_softClass;
  if (!getTKClientTokenClass_softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = __getTKClientTokenClass_block_invoke;
    v3[3] = &unk_1E5484FA0;
    void v3[4] = &v4;
    __getTKClientTokenClass_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_18B3AEB0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __getTKClientTokenClass_block_invoke(uint64_t a1)
{
  CryptoTokenKitLibrary();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("TKClientToken");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getTKClientTokenClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v2 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"Class getTKClientTokenClass(void)_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"SecSoftLink.m", 27, @"Unable to find class %s", "TKClientToken");

    __break(1u);
  }
}

id getTKClientTokenSessionClass()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)getTKClientTokenSessionClass_softClass;
  uint64_t v7 = getTKClientTokenSessionClass_softClass;
  if (!getTKClientTokenSessionClass_softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = __getTKClientTokenSessionClass_block_invoke;
    v3[3] = &unk_1E5484FA0;
    void v3[4] = &v4;
    __getTKClientTokenSessionClass_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_18B3AECBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __getTKClientTokenSessionClass_block_invoke(uint64_t a1)
{
  CryptoTokenKitLibrary();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("TKClientTokenSession");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getTKClientTokenSessionClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v2 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"Class getTKClientTokenSessionClass(void)_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"SecSoftLink.m", 28, @"Unable to find class %s", "TKClientTokenSession");

    __break(1u);
  }
}

uint64_t getTKErrorDomainSymbolLoc()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getTKErrorDomainSymbolLoc_ptr;
  uint64_t v6 = getTKErrorDomainSymbolLoc_ptr;
  if (!getTKErrorDomainSymbolLoc_ptr)
  {
    id v1 = CryptoTokenKitLibrary();
    v4[3] = (uint64_t)dlsym(v1, "TKErrorDomain");
    getTKErrorDomainSymbolLoc_ptr = v4[3];
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_18B3AEE78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *__getTKErrorDomainSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = CryptoTokenKitLibrary();
  uint64_t result = dlsym(v2, "TKErrorDomain");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getTKErrorDomainSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void getTKErrorDomain()
{
  TKErrorDomainSymbolLoc = (void **)getTKErrorDomainSymbolLoc();
  if (TKErrorDomainSymbolLoc)
  {
    id v1 = *TKErrorDomainSymbolLoc;
    id v2 = v1;
  }
  else
  {
    uint64_t v3 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v4 = [NSString stringWithUTF8String:"typeof (((typeof (TKErrorDomain) (*)(void))0)()) getTKErrorDomain(void)"];
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, @"SecSoftLink.m", 29, @"%s", dlerror());

    __break(1u);
  }
}

uint64_t LocalAuthenticationLibraryCore()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 0;
  uint64_t v3 = &v2;
  uint64_t v4 = 0x2020000000;
  uint64_t v0 = LocalAuthenticationLibraryCore_frameworkLibrary;
  uint64_t v5 = LocalAuthenticationLibraryCore_frameworkLibrary;
  if (!LocalAuthenticationLibraryCore_frameworkLibrary)
  {
    long long v6 = xmmword_1E5481BE0;
    long long v7 = *(_OWORD *)&off_1E5481BF0;
    v3[3] = _sl_dlopen();
    LocalAuthenticationLibraryCore_frameworkLibrary = v3[3];
    uint64_t v0 = v3[3];
  }
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_18B3AF098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __LocalAuthenticationLibraryCore_block_invoke(uint64_t a1)
{
  uint64_t result = _sl_dlopen();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  LocalAuthenticationLibraryCore_frameworkLibrary = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *LocalAuthenticationLibrary()
{
  uint64_t v0 = LocalAuthenticationLibraryCore();
  if (v0) {
    return (void *)v0;
  }
  id v1 = [MEMORY[0x1E4F28B00] currentHandler];
  uint64_t v3 = [NSString stringWithUTF8String:"void *LocalAuthenticationLibrary(void)"];
  objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v3, @"SecSoftLink.m", 30, @"%s", 0);

  __break(1u);
  free(v4);
  return v1;
}

id getLAContextClass()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)getLAContextClass_softClass;
  uint64_t v7 = getLAContextClass_softClass;
  if (!getLAContextClass_softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = __getLAContextClass_block_invoke;
    v3[3] = &unk_1E5484FA0;
    void v3[4] = &v4;
    __getLAContextClass_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_18B3AF2C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __getLAContextClass_block_invoke(uint64_t a1)
{
  LocalAuthenticationLibrary();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("LAContext");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getLAContextClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v2 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"Class getLAContextClass(void)_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"SecSoftLink.m", 31, @"Unable to find class %s", "LAContext");

    __break(1u);
  }
}

uint64_t getLAErrorDomainSymbolLoc()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getLAErrorDomainSymbolLoc_ptr;
  uint64_t v6 = getLAErrorDomainSymbolLoc_ptr;
  if (!getLAErrorDomainSymbolLoc_ptr)
  {
    id v1 = LocalAuthenticationLibrary();
    v4[3] = (uint64_t)dlsym(v1, "LAErrorDomain");
    getLAErrorDomainSymbolLoc_ptr = v4[3];
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_18B3AF47C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *__getLAErrorDomainSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = LocalAuthenticationLibrary();
  uint64_t result = dlsym(v2, "LAErrorDomain");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getLAErrorDomainSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void getLAErrorDomain()
{
  LAErrorDomainSymbolLoc = (void **)getLAErrorDomainSymbolLoc();
  if (LAErrorDomainSymbolLoc)
  {
    id v1 = *LAErrorDomainSymbolLoc;
    id v2 = v1;
  }
  else
  {
    uint64_t v3 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v4 = [NSString stringWithUTF8String:"typeof (((typeof (LAErrorDomain) (*)(void))0)()) getLAErrorDomain(void)"];
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, @"SecSoftLink.m", 32, @"%s", dlerror());

    __break(1u);
  }
}

CFStringRef SecPasswordCreateWithRandomDigits(int a1, const __CFDictionary **a2)
{
  int v8 = a1;
  int valuePtr = a1;
  uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
  lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
  decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  punctuationCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberIntType, &v8);
  CFDataRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue(Mutable, (const void *)kSecPasswordMinLengthKey, v3);
  CFDictionaryAddValue(Mutable, (const void *)kSecPasswordMaxLengthKey, v4);
  CFDictionaryAddValue(Mutable, (const void *)kSecPasswordAllowedCharactersKey, @"0123456789");
  CFStringRef v6 = SecPasswordGenerate(3, a2, Mutable);
  if (v3) {
    CFRelease(v3);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v6;
}

CFStringRef SecPasswordGenerate(int a1, const __CFDictionary **a2, CFDictionaryRef theDict)
{
  CFTypeRef v168 = 0;
  uint64_t v169 = 0;
  CFNumberRef v166 = 0;
  CFNumberRef number = 0;
  CFIndex range = 0;
  unint64_t v165 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v163 = 0xAAAAAAAAAAAAAAAALL;
  value[0] = 0;
  CFNumberRef v3 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (!theDict) {
    goto LABEL_121;
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDefaultForType, (const void **)value))
  {
    if (value[0])
    {
      CFTypeID v6 = CFGetTypeID(value[0]);
      if (v6 == CFStringGetTypeID() && CFEqual((CFStringRef)value[0], @"true"))
      {
LABEL_111:
        if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDefaultForType, &v168)
          || !v168
          || (CFTypeID v48 = CFGetTypeID(v168), v48 != CFStringGetTypeID())
          || CFStringCompare((CFStringRef)v168, @"true", 0))
        {
          CFAllocatorRef alloc = *v3;
          CFDataRef Mutable = CFArrayCreateMutable(*v3, 0, MEMORY[0x1E4F1D510]);
          v173[3] = (void *)0xAAAAAAAAAAAAAAAALL;
          memset(v173, 0, 24);
          memset(v172, 0, sizeof(v172));
          v171[2] = 0;
          v171[3] = 0;
          CFNumberRef v50 = (const __CFNumber *)CFDictionaryGetValue(theDict, (const void *)kSecPasswordMinLengthKey);
          CFNumberRef v51 = (const __CFNumber *)CFDictionaryGetValue(theDict, (const void *)kSecPasswordMaxLengthKey);
          CFNumberGetValue(v50, kCFNumberSInt64Type, &v173[3]);
          uint64_t v52 = (uint64_t)v173[3];
          CFNumberGetValue(v51, kCFNumberSInt64Type, &v173[3]);
          CFIndex v53 = (CFIndex)v173[3];
          int v54 = a1;
          if (a1 != 3)
          {
            BOOL v68 = v173[3] != (void *)20;
            if (v52) {
              BOOL v69 = v173[3] == (void *)v52;
            }
            else {
              BOOL v69 = 0;
            }
            if (!v69) {
              BOOL v68 = 0;
            }
            if ((uint64_t)v173[3] < 20) {
              BOOL v68 = 1;
            }
            uint64_t v70 = 20;
            if (v52 > 20) {
              uint64_t v70 = v52;
            }
            int v71 = v173[3] != 0 && v68;
            BOOL v69 = v71 == 0;
            int v72 = v71 | (v52 > 20);
            if (v69) {
              CFIndex v53 = v70;
            }
            if (v72) {
              uint64_t v55 = @"false";
            }
            else {
              uint64_t v55 = @"true";
            }
            CFStringRef v73 = (const __CFString *)CFDictionaryGetValue(theDict, (const void *)kSecPasswordAllowedCharactersKey);
            CFStringRef v74 = v73;
            if (v73) {
              CFRetain(v73);
            }
            CFArrayRef v75 = (const __CFArray *)CFDictionaryGetValue(theDict, (const void *)kSecPasswordRequiredCharactersKey);
            if (v75)
            {
              CFArrayRef v76 = v75;
              for (CFIndex i = 0; i < CFArrayGetCount(v76); ++i)
              {
                CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v76, i);
                if (ValueAtIndex)
                {
                  CFIndex v79 = ValueAtIndex;
                  v175.CFIndex length = CFStringGetLength(v74);
                  v175.location = 0;
                  if (CFStringFindCharacterFromSet(v74, (CFCharacterSetRef)v79, v175, 0, 0)) {
                    CFArrayAppendValue(Mutable, v79);
                  }
                }
              }
LABEL_186:
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDisallowedCharacters, (const void **)&v173[2]))v173[2] = 0; {
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordCantEndWithChars, (const void **)&v173[1]))v173[1] = 0;
              }
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordCantStartWithChars, (const void **)v173))v173[0] = 0; {
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordGroupSize, (const void **)&v172[3]))
              }
                v172[3] = 0;
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordNumberOfGroups, (const void **)&v172[2]))v172[2] = 0; {
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordSeparator, (const void **)&v172[1]))
              }
                v172[1] = 0;
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordContainsNoMoreThanNSpecificCharacters, (const void **)v172))v172[0] = 0; {
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordContainsAtLeastNSpecificCharacters, (const void **)&v171[3]))v171[3] = 0;
              }
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordContainsNoMoreThanNConsecutiveIdenticalCharacters, (const void **)&v171[2]))v171[2] = 0; {
              CFAllocatorRef v56 = alloc;
              }
              if (v74)
              {
                v176.CFIndex length = CFStringGetLength(v74);
                v176.location = 0;
                if (!CFStringFindWithOptions(v74, @"-", v176, 1uLL, 0))
                {
LABEL_209:
                  CFIndex Length = CFStringGetLength(v74);
                  CFDataRef MutableCopy = CFStringCreateMutableCopy(alloc, Length, v74);
                  v184.CFIndex length = CFStringGetLength(v74);
                  v184.location = 0;
                  CFStringFindAndReplace(MutableCopy, @"-", &stru_1ED84D0B0, v184, 1uLL);
                  CFRelease(v74);
                  uint64_t v55 = @"false";
                  CFStringRef v74 = MutableCopy;
LABEL_210:
                  if (CFArrayGetCount(Mutable) > v53 && Mutable)
                  {
                    CFRelease(Mutable);
                    CFDataRef Mutable = 0;
                  }
                  value[0] = (void *)v53;
                  CFNumberRef v96 = CFNumberCreate(alloc, kCFNumberCFIndexType, value);
                  uint64_t v85 = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                  CFDictionaryAddValue(v85, @"UseDefaultPasswordFormat", v55);
                  CFDictionarySetValue(v85, @"NumberOfRequiredRandomCharacters", v96);
                  CFDictionaryAddValue(v85, @"AllowedCharacters", v74);
                  if (Mutable) {
                    CFDictionaryAddValue(v85, @"RequiredCharacterSets", Mutable);
                  }
                  if (v173[2]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordDisallowedCharacters, v173[2]);
                  }
                  if (v173[1]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordCantEndWithChars, v173[1]);
                  }
                  if (v173[0]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordCantStartWithChars, v173[0]);
                  }
                  if (v172[3]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordGroupSize, v172[3]);
                  }
                  if (v172[2]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordNumberOfGroups, v172[2]);
                  }
                  if (v172[1]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordSeparator, v172[1]);
                  }
                  if (v172[0]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordContainsNoMoreThanNSpecificCharacters, v172[0]);
                  }
                  if (v171[3]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordContainsAtLeastNSpecificCharacters, v171[3]);
                  }
                  if (v171[2]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordContainsNoMoreThanNConsecutiveIdenticalCharacters, v171[2]);
                  }
                  CFRelease(v55);
                  if (v96) {
                    CFRelease(v96);
                  }
                  if (v74) {
                    CFRelease(v74);
                  }
                  if (Mutable) {
                    CFRelease(Mutable);
                  }
                  goto LABEL_239;
                }
              }
              else
              {
                CFStringRef v74 = @"abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ123456789";
                CFRetain(@"abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ123456789");
              }
              if (v55 != @"false") {
                goto LABEL_210;
              }
              goto LABEL_209;
            }
            uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
            lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(Mutable, (const void *)uppercaseLetterCharacterSet);
            int v54 = a1;
            CFArrayAppendValue(Mutable, (const void *)lowercaseLetterCharacterSet);
LABEL_185:
            CFArrayAppendValue(Mutable, (const void *)decimalDigitCharacterSet);
            goto LABEL_186;
          }
          if (!v173[3] || !v52)
          {
            if (!v173[3] && v52)
            {
              uint64_t v55 = @"false";
              CFIndex v53 = v52;
LABEL_184:
              CFStringRef v74 = @"0123456789";
              goto LABEL_185;
            }
            if (v173[3]) {
              BOOL v93 = v52 == 0;
            }
            else {
              BOOL v93 = 0;
            }
            if (!v93) {
              CFIndex v53 = 4;
            }
          }
          uint64_t v55 = @"false";
          goto LABEL_184;
        }
LABEL_121:
        CFAllocatorRef v56 = *v3;
        unint64_t v57 = CFArrayCreateMutable(*v3, 0, MEMORY[0x1E4F1D510]);
        v173[2] = (void *)0xAAAAAAAAAAAAAAAALL;
        v173[3] = (void *)0xAAAAAAAAAAAAAAAALL;
        switch(a1)
        {
          case 1:
            value[0] = (void *)24;
            CFNumberRef v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            v173[3] = (void *)4;
            v173[2] = (void *)6;
            CFNumberRef v59 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[3]);
            CFNumberRef v60 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[2]);
            uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(v57, (const void *)uppercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            goto LABEL_165;
          case 2:
            v173[3] = (void *)4;
            v173[2] = (void *)3;
            CFNumberRef v59 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[3]);
            CFNumberRef v60 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[2]);
            lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            value[0] = (void *)12;
            CFNumberRef v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            CFArrayAppendValue(v57, (const void *)lowercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            goto LABEL_165;
          case 3:
            value[0] = (void *)4;
            CFNumberRef v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            v173[2] = (void *)1;
            v173[3] = (void *)4;
            CFNumberRef v59 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[3]);
            CFNumberRef v60 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[2]);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            goto LABEL_165;
          case 4:
            v173[3] = (void *)4;
            v173[2] = (void *)7;
            value[0] = (void *)26;
            CFNumberRef v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            value[0] = (void *)2;
            CFNumberRef v84 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            CFNumberRef v59 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[3]);
            CFNumberRef v60 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[2]);
            uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(v57, (const void *)uppercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            CFDictionaryRef v83 = CFDictionaryCreateForCFTypes(v56, v86, v87, v88, v89, v90, v91, v92, @"UseDefaultPasswordFormat", @"true");
            if (!v58) {
              goto LABEL_167;
            }
            goto LABEL_166;
          default:
            v173[3] = (void *)4;
            v173[2] = (void *)6;
            CFNumberRef v59 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[3]);
            CFNumberRef v60 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[2]);
            uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
            lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(v57, (const void *)uppercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)lowercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            value[0] = (void *)20;
            CFNumberRef v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
LABEL_165:
            CFDictionaryRef v83 = CFDictionaryCreateForCFTypes(v56, v61, v62, v63, v64, v65, v66, v67, @"UseDefaultPasswordFormat", @"true");
            CFNumberRef v84 = 0;
            if (v58) {
LABEL_166:
            }
              CFRelease(v58);
LABEL_167:
            int v54 = a1;
            if (v57) {
              CFRelease(v57);
            }
            if (v59) {
              CFRelease(v59);
            }
            if (v60) {
              CFRelease(v60);
            }
            if (v84) {
              CFRelease(v84);
            }
            uint64_t v85 = v83;
            break;
        }
LABEL_239:
        if (!v85) {
          return 0;
        }
        CFDictionaryRef theDicta = v85;
        CFNumberRef v97 = (const __CFNumber *)CFDictionaryGetValue(v85, @"NumberOfRequiredRandomCharacters");
        if (v97 && (CFNumberRef v98 = v97, v99 = CFGetTypeID(v97), v99 == CFNumberGetTypeID()))
        {
          if (CFNumberGetValue(v98, kCFNumberSInt64Type, &v165)) {
            uint64_t v100 = v165;
          }
          else {
            uint64_t v100 = 0;
          }
        }
        else
        {
          uint64_t v100 = 0;
        }
        CFNumberRef v101 = (const __CFNumber *)CFDictionaryGetValue(v85, @"NumberOfChecksumCharacters");
        if (v101 && (CFNumberRef v102 = v101, v103 = CFGetTypeID(v101), v103 == CFNumberGetTypeID()))
        {
          int v104 = CFNumberGetValue(v102, kCFNumberSInt64Type, &v165);
          unint64_t v105 = v165;
          if (!v104) {
            unint64_t v105 = 0;
          }
          uint64_t v158 = v105;
        }
        else
        {
          uint64_t v158 = 0;
        }
        CFDictionaryRef v81 = v85;
        if (CFDictionaryGetValueIfPresent(v85, (const void *)kSecPasswordGroupSize, (const void **)&number)) {
          CFNumberGetValue(number, kCFNumberSInt64Type, &range);
        }
        else {
          CFNumberRef number = 0;
        }
        if (CFDictionaryGetValueIfPresent(v85, (const void *)kSecPasswordNumberOfGroups, (const void **)&v166))
        {
          CFNumberGetValue(v166, kCFNumberSInt64Type, &v163);
          if (!v100) {
            goto LABEL_358;
          }
        }
        else
        {
          CFNumberRef v166 = 0;
          if (!v100) {
            goto LABEL_358;
          }
        }
        CFAllocatorRef alloca = v56;
LABEL_260:
        CFStringRef v106 = (const __CFString *)CFDictionaryGetValue(v81, @"AllowedCharacters");
        int v107 = (unsigned __int8 *)malloc_type_malloc(v100, 0xE2F0E646uLL);
        uint64_t v108 = malloc_type_malloc(v100, 0xCB6CC926uLL);
        v109 = v108;
        if (!v107 || !v108)
        {
          free(v107);
          free(v109);
          CFDictionaryRef v81 = theDicta;
          goto LABEL_358;
        }
        unsigned __int8 v110 = CFStringGetLength(v106);
        getUniformRandomNumbers((uint64_t)v107, v100, v110);
        value[0] = 0;
        if (!CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordDisallowedCharacters, (const void **)value))value[0] = 0; {
        if (v100 < 1)
        }
        {
LABEL_276:
          CFStringRef v117 = CFStringCreateWithBytes(alloca, (const UInt8 *)v109, v100, 0x8000100u, 0);
          free(v109);
          free(v107);
          if (!v166 || !number)
          {
            CFStringRef Copy = CFStringCreateCopy(alloca, v117);
            goto LABEL_299;
          }
          CFMutableStringRef v118 = CFStringCreateMutable(alloca, 0);
          if (!CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordSeparator, (const void **)&v169)
            || !v169)
          {
            uint64_t v169 = @"-";
          }
          CFIndex v119 = 0;
          v120.CFIndex length = range;
          while (1)
          {
            if (v120.length + v119 >= v100)
            {
              if (v120.length + v119 != v100)
              {
                v178.CFIndex length = v100 - v119;
                v178.location = v119;
                CFStringRef v124 = CFStringCreateWithSubstring(alloca, v117, v178);
                CFStringAppend(v118, v124);
                if (v124) {
                  CFRelease(v124);
                }
LABEL_294:
                if (v158)
                {
                  Checksum = CreateChecksum(v54, v117, v158, v106);
                  CFStringAppend(v118, Checksum);
                  if (Checksum) {
                    CFRelease(Checksum);
                  }
                }
                CFStringRef Copy = CFStringCreateCopy(alloca, v118);
                if (v118) {
                  CFRelease(v118);
                }
LABEL_299:
                if (v117) {
                  CFRelease(v117);
                }
                value[0] = 0;
                v172[3] = (void *)0xAAAAAAAAAAAAAAAALL;
                memset(v173, 0, sizeof(v173));
                CFArrayRef v126 = (const __CFArray *)CFDictionaryGetValue(theDicta, @"RequiredCharacterSets");
                if (!CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordCantEndWithChars, (const void **)&v173[3]))v173[3] = 0; {
                if (!CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordCantStartWithChars, (const void **)&v173[2]))v173[2] = 0;
                }
                if (!CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordContainsAtLeastNSpecificCharacters, (const void **)&v173[1]))v173[1] = 0; {
                if (!CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordContainsNoMoreThanNSpecificCharacters, (const void **)v173))v173[0] = 0;
                }
                if (CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordContainsNoMoreThanNConsecutiveIdenticalCharacters, (const void **)value))
                {
                  CFNumberGetValue((CFNumberRef)value[0], kCFNumberSInt64Type, &v172[3]);
                  v127 = v172[3];
                }
                else
                {
                  v127 = 0;
                  value[0] = 0;
                }
                CFStringRef v128 = (const __CFString *)v173[3];
                if (v173[3])
                {
                  CFCharacterSetRef v129 = CFCharacterSetCreateWithCharactersInString(alloca, (CFStringRef)v173[3]);
                  CFIndex v130 = CFStringGetLength(Copy);
                  CFIndex v131 = v130 - CFStringGetLength(v128);
                  v179.CFIndex length = CFStringGetLength(v128);
                  v179.location = v131;
                  CFComparisonResult v132 = CFStringCompareWithOptions(Copy, v128, v179, 0);
                  if (v129) {
                    CFRelease(v129);
                  }
                  if (v132 == kCFCompareEqualTo) {
                    goto LABEL_351;
                  }
                }
                CFStringRef v133 = (const __CFString *)v173[2];
                if (v173[2])
                {
                  CFCharacterSetRef v134 = CFCharacterSetCreateWithCharactersInString(alloca, (CFStringRef)v173[2]);
                  v180.CFIndex length = CFStringGetLength(v133);
                  v180.location = 0;
                  CFComparisonResult v135 = CFStringCompareWithOptions(Copy, v133, v180, 0);
                  if (v134) {
                    CFRelease(v134);
                  }
                  if (v135 == kCFCompareEqualTo) {
                    goto LABEL_351;
                  }
                }
                if (v173[1])
                {
                  CFNumberRef v136 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v173[1], (const void *)kSecPasswordCharacterCount);
                  CFStringRef v137 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v173[1], (const void *)kSecPasswordCharacters);
                  CFNumberGetValue(v136, kCFNumberSInt64Type, &v172[3]);
                  v138 = v172[3];
                  CFCharacterSetRef v139 = CFCharacterSetCreateWithCharactersInString(alloca, v137);
                  CFIndex v140 = 0;
                  uint64_t v141 = 0;
                  while (v140 < CFStringGetLength(Copy))
                  {
                    v181.location = v140;
                    v181.CFIndex length = 1;
                    if (CFStringFindCharacterFromSet(Copy, v139, v181, 0, 0)) {
                      ++v141;
                    }
                    ++v140;
                  }
                  if (v139) {
                    CFRelease(v139);
                  }
                  if (v141 < (uint64_t)v138) {
                    goto LABEL_351;
                  }
                }
                if (!v173[0]) {
                  goto LABEL_338;
                }
                CFNumberRef v142 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v173[0], (const void *)kSecPasswordCharacterCount);
                CFStringRef v143 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v173[0], (const void *)kSecPasswordCharacters);
                CFNumberGetValue(v142, kCFNumberSInt64Type, &v172[3]);
                v144 = v172[3];
                CFCharacterSetRef v145 = CFCharacterSetCreateWithCharactersInString(alloca, v143);
                CFIndex v146 = 0;
                uint64_t v147 = 0;
                while (v146 < CFStringGetLength(Copy))
                {
                  v182.location = v146;
                  v182.CFIndex length = 1;
                  if (CFStringFindCharacterFromSet(Copy, v145, v182, 0, 0)) {
                    ++v147;
                  }
                  ++v146;
                }
                if (v145) {
                  CFRelease(v145);
                }
                if (v147 > (uint64_t)v144)
                {
LABEL_351:
                  int v54 = a1;
                }
                else
                {
LABEL_338:
                  if (value[0])
                  {
                    LODWORD(v148) = 0;
                    for (CFIndex j = 0; j < CFStringGetLength(Copy); ++j)
                    {
                      char CharacterAtIndex = CFStringGetCharacterAtIndex(Copy, j);
                      uint64_t v151 = 0;
                      uint64_t v152 = (int)v148;
                      while (1)
                      {
                        uint64_t v148 = v152 + v151;
                        if (j + v151 >= CFStringGetLength(Copy)) {
                          break;
                        }
                        char v153 = CFStringGetCharacterAtIndex(Copy, j + v151);
                        if (v148 > (uint64_t)v127) {
                          goto LABEL_351;
                        }
                        if (v153 != CharacterAtIndex)
                        {
                          LODWORD(v148) = 0;
                          break;
                        }
                        ++v151;
                      }
                    }
                  }
                  CFIndex v154 = 0;
                  while (v154 < CFArrayGetCount(v126))
                  {
                    CFCharacterSetRef v155 = (const __CFCharacterSet *)CFArrayGetValueAtIndex(v126, v154);
                    v183.CFIndex length = CFStringGetLength(Copy);
                    v183.location = 0;
                    ++v154;
                    if (!CFStringFindCharacterFromSet(Copy, v155, v183, 0, 0)) {
                      goto LABEL_351;
                    }
                  }
                  int v54 = a1;
                  if (!SecPasswordIsPasswordWeak2(a1 == 3, Copy))
                  {
                    CFRelease(theDicta);
                    return Copy;
                  }
                }
                CFDictionaryRef v81 = theDicta;
                if (Copy) {
                  CFRelease(Copy);
                }
                goto LABEL_260;
              }
              v120.location = v119;
              CFStringRef v121 = CFStringCreateWithSubstring(alloca, v117, v120);
              BOOL v123 = v118;
              CFStringRef v122 = v121;
            }
            else
            {
              v120.location = v119;
              CFStringRef v121 = CFStringCreateWithSubstring(alloca, v117, v120);
              CFStringAppend(v118, v121);
              CFStringRef v122 = (const __CFString *)v169;
              BOOL v123 = v118;
            }
            CFStringAppend(v123, v122);
            if (v121) {
              CFRelease(v121);
            }
            v120.CFIndex length = range;
            v119 += range;
            if (v119 == v100) {
              goto LABEL_294;
            }
          }
        }
        uint64_t v111 = 0;
        while (1)
        {
          LOWORD(v173[3]) = -21846;
          UniChar v112 = CFStringGetCharacterAtIndex(v106, v107[v111]);
          LOWORD(v173[3]) = v112;
          if (!value[0]) {
            goto LABEL_274;
          }
          CFStringRef v113 = CFStringCreateWithCharacters(alloca, (const UniChar *)&v173[3], 1);
          CFCharacterSetRef v114 = CFCharacterSetCreateWithCharactersInString(alloca, (CFStringRef)value[0]);
          v177.CFIndex length = CFStringGetLength(v113);
          v177.location = 0;
          int CharacterFromSet = CFStringFindCharacterFromSet(v113, v114, v177, 0, 0);
          if (v114) {
            CFRelease(v114);
          }
          if (v113) {
            CFRelease(v113);
          }
          if (!CharacterFromSet) {
            break;
          }
          unsigned __int8 v116 = CFStringGetLength(v106);
          getUniformRandomNumbers((uint64_t)v107, v100, v116);
          --v111;
LABEL_275:
          if (++v111 >= v100) {
            goto LABEL_276;
          }
        }
        LOBYTE(v112) = v173[3];
LABEL_274:
        *((unsigned char *)v109 + v111) = v112;
        goto LABEL_275;
      }
    }
  }
  if (a1 == 3)
  {
    v173[2] = 0;
    v173[3] = 0;
    v173[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDefaultForType, (const void **)value))
    {
      if (value[0])
      {
        CFTypeID v7 = CFGetTypeID(value[0]);
        if (v7 == CFStringGetTypeID()
          && CFEqual((CFStringRef)value[0], @"true"))
        {
          goto LABEL_111;
        }
      }
    }
    if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordMaxLengthKey, (const void **)&v173[2])) {
      goto LABEL_388;
    }
    if (!v173[2]) {
      goto LABEL_375;
    }
    CFTypeID v8 = CFGetTypeID(v173[2]);
    if (v8 == CFNullGetTypeID())
    {
      CFStringRef v80 = @"To generate a password, need a max length";
      goto LABEL_158;
    }
    if (v173[2] && (CFTypeID v9 = CFGetTypeID(v173[2]), v9 == CFNumberGetTypeID()))
    {
LABEL_388:
      if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordMinLengthKey, (const void **)&v173[3]))
      {
        if (!v173[3]) {
          goto LABEL_385;
        }
        CFTypeID v10 = CFGetTypeID(v173[3]);
        if (v10 == CFNullGetTypeID())
        {
          CFStringRef v80 = @"To generate a password, need a min length";
          goto LABEL_158;
        }
        if (!v173[3] || (CFTypeID v11 = CFGetTypeID(v173[3]), v11 != CFNumberGetTypeID()))
        {
LABEL_385:
          CFStringRef v80 = @"The password's min length must be a CFNumberRef";
          goto LABEL_158;
        }
      }
      if (v173[2])
      {
        CFNumberGetValue((CFNumberRef)v173[2], kCFNumberSInt64Type, &v173[1]);
        uint64_t v12 = (uint64_t)v173[1];
      }
      else
      {
        uint64_t v12 = 0;
      }
      if (v173[3])
      {
        CFNumberGetValue((CFNumberRef)v173[3], kCFNumberSInt64Type, &v173[1]);
        CFStringRef v80 = @"The password's length parameters make no sense(is max < min ?)";
        if (v173[1])
        {
          if (v12)
          {
            if ((uint64_t)v173[1] <= v12)
            {
              CFDictionaryRef v81 = 0;
              if ((uint64_t)v173[1] > 3 || v12 > 3)
              {
LABEL_159:
                if (v81) {
                  goto LABEL_160;
                }
                goto LABEL_111;
              }
            }
          }
        }
      }
      else
      {
        CFStringRef v80 = @"The password's length parameters make no sense(is max < min ?)";
      }
    }
    else
    {
LABEL_375:
      CFStringRef v80 = @"The password's max length must be a CFNumberRef";
    }
LABEL_158:
    CFDictionaryRef v81 = CFErrorCreate(*v3, v80, -909, 0);
    goto LABEL_159;
  }
  memset(v173, 170, sizeof(v173));
  memset(v172, 170, sizeof(v172));
  memset(v171, 170, sizeof(v171));
  memset(v170, 170, sizeof(v170));
  if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordAllowedCharactersKey, (const void **)&v173[3])) {
    goto LABEL_364;
  }
  if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordMaxLengthKey, (const void **)&v173[2])) {
    goto LABEL_373;
  }
  if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordMinLengthKey, (const void **)&v173[1]))
  {
LABEL_374:
    CFStringRef v157 = @"To generate a password, need a min length";
    goto LABEL_381;
  }
  if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordRequiredCharactersKey, (const void **)v173))
  {
LABEL_365:
    CFStringRef v157 = @"Need an array of character sets, password must have at least 1 character from each set";
    goto LABEL_381;
  }
  if (v173[3])
  {
    CFTypeID v13 = CFGetTypeID(v173[3]);
    if (v13 == CFNullGetTypeID())
    {
LABEL_364:
      CFStringRef v157 = @"Need a string of characters; password must only contain characters in this string";
      goto LABEL_381;
    }
  }
  if (v173[2])
  {
    CFTypeID v14 = CFGetTypeID(v173[2]);
    if (v14 == CFNullGetTypeID())
    {
LABEL_373:
      CFStringRef v157 = @"To generate a password, need a max length";
      goto LABEL_381;
    }
  }
  if (v173[1])
  {
    CFTypeID v15 = CFGetTypeID(v173[1]);
    if (v15 == CFNullGetTypeID()) {
      goto LABEL_374;
    }
  }
  if (v173[0])
  {
    CFTypeID v16 = CFGetTypeID(v173[0]);
    if (v16 == CFNullGetTypeID()) {
      goto LABEL_365;
    }
  }
  if (!v173[3] || (CFTypeID v17 = CFGetTypeID(v173[3]), v17 != CFStringGetTypeID()))
  {
    CFStringRef v157 = @"The password's allowed characters must be a CFStringRef";
    goto LABEL_381;
  }
  if (!v173[2] || (CFTypeID v18 = CFGetTypeID(v173[2]), v18 != CFNumberGetTypeID()))
  {
    CFStringRef v157 = @"The password's max length must be a CFNumberRef";
    goto LABEL_381;
  }
  if (!v173[1] || (CFTypeID v19 = CFGetTypeID(v173[1]), v19 != CFNumberGetTypeID()))
  {
    CFStringRef v157 = @"The password's min length must be a CFNumberRef";
    goto LABEL_381;
  }
  if (!v173[0] || (CFTypeID v20 = CFGetTypeID(v173[0]), v20 != CFArrayGetTypeID()))
  {
    CFStringRef v157 = @"The password's required characters must be an array of CFCharacterSetRefs";
    goto LABEL_381;
  }
  CFNumberGetValue((CFNumberRef)v173[1], kCFNumberSInt64Type, v170);
  uint64_t v21 = v170[0];
  CFNumberGetValue((CFNumberRef)v173[2], kCFNumberSInt64Type, v170);
  if (v21 > v170[0])
  {
    CFStringRef v157 = @"The password's length parameters make no sense(is max < min ?)";
    goto LABEL_381;
  }
  if (!CFStringGetLength((CFStringRef)v173[3])) {
    goto LABEL_364;
  }
  if (!CFArrayGetCount((CFArrayRef)v173[0])) {
    goto LABEL_365;
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDisallowedCharacters, (const void **)&v172[3]))
  {
    if (!v172[3]
      || (CFTypeID v22 = CFGetTypeID(v172[3]), v22 == CFNullGetTypeID())
      || !v172[3]
      || (CFTypeID v23 = CFGetTypeID(v172[3]), v23 != CFStringGetTypeID()))
    {
      CFStringRef v157 = @"Disallowed Characters dictionary parameter is either null or not a string";
      goto LABEL_381;
    }
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordCantEndWithChars, (const void **)&v172[2]))
  {
    if (!v172[2]
      || (CFTypeID v24 = CFGetTypeID(v172[2]), v24 == CFNullGetTypeID())
      || !v172[2]
      || (CFTypeID v25 = CFGetTypeID(v172[2]), v25 != CFStringGetTypeID()))
    {
      CFStringRef v157 = @"The dictionary parameter 'EndWith' is either null or not a string";
      goto LABEL_381;
    }
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordCantStartWithChars, (const void **)&v172[1]))
  {
    if (!v172[1]
      || (CFTypeID v26 = CFGetTypeID(v172[1]), v26 == CFNullGetTypeID())
      || !v172[1]
      || (CFTypeID v27 = CFGetTypeID(v172[1]), v27 != CFStringGetTypeID()))
    {
      CFStringRef v157 = @"The dictionary parameter 'StartWith' is either null or not a string";
      goto LABEL_381;
    }
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordGroupSize, (const void **)v172))
  {
    if (!v172[0]
      || (CFTypeID v28 = CFGetTypeID(v172[0]), v28 == CFNullGetTypeID())
      || !v172[0]
      || (CFTypeID v29 = CFGetTypeID(v172[0]), v29 != CFNumberGetTypeID()))
    {
      CFStringRef v157 = @"The dictionary parameter 'groupsize' is either null or not a number";
      goto LABEL_381;
    }
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordNumberOfGroups, (const void **)&v171[3]))
  {
    if (!v171[3]
      || (CFTypeID v30 = CFGetTypeID(v171[3]), v30 == CFNullGetTypeID())
      || !v171[3]
      || (CFTypeID v31 = CFGetTypeID(v171[3]), v31 != CFNumberGetTypeID()))
    {
      CFStringRef v157 = @"The dictionary parameter 'number of groupds' is either null or not a number";
      goto LABEL_381;
    }
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordSeparator, (const void **)&v171[2]))
  {
    if (!v171[2]
      || (CFTypeID v32 = CFGetTypeID(v171[2]), v32 == CFNullGetTypeID())
      || !v171[2]
      || (CFTypeID v33 = CFGetTypeID(v171[2]), v33 != CFStringGetTypeID()))
    {
      CFStringRef v157 = @"The dictionary parameter 'password separator character' is either null or not a string";
      goto LABEL_381;
    }
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordContainsNoMoreThanNSpecificCharacters, (const void **)&v171[1]))
  {
    if (!v171[1]) {
      goto LABEL_362;
    }
    CFTypeID v34 = CFGetTypeID(v171[1]);
    if (v34 == CFNullGetTypeID()) {
      goto LABEL_362;
    }
    if (!v171[1]) {
      goto LABEL_362;
    }
    CFTypeID v35 = CFGetTypeID(v171[1]);
    if (v35 != CFDictionaryGetTypeID()
      || !CFDictionaryGetValueIfPresent((CFDictionaryRef)v171[1], (const void *)kSecPasswordCharacterCount, (const void **)&v170[3]))
    {
      goto LABEL_362;
    }
    if (!v170[3]) {
      goto LABEL_360;
    }
    CFTypeID v36 = CFGetTypeID((CFTypeRef)v170[3]);
    if (v36 == CFNullGetTypeID()) {
      goto LABEL_360;
    }
    if (!v170[3]) {
      goto LABEL_360;
    }
    CFTypeID v37 = CFGetTypeID((CFTypeRef)v170[3]);
    if (v37 != CFNumberGetTypeID()) {
      goto LABEL_360;
    }
    if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)v171[1], (const void *)kSecPasswordCharacters, (const void **)&v170[1]))
    {
LABEL_362:
      CFStringRef v157 = @"The dictionary parameter 'At Most N Characters' is either null or not a string";
      goto LABEL_381;
    }
    if (!v170[1]) {
      goto LABEL_361;
    }
    CFTypeID v38 = CFGetTypeID((CFTypeRef)v170[1]);
    if (v38 == CFNullGetTypeID()) {
      goto LABEL_361;
    }
    if (!v170[1]) {
      goto LABEL_361;
    }
    CFTypeID v39 = CFGetTypeID((CFTypeRef)v170[1]);
    if (v39 != CFStringGetTypeID()) {
      goto LABEL_361;
    }
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordContainsAtLeastNSpecificCharacters, (const void **)v171))
  {
    if (!v171[0]) {
      goto LABEL_363;
    }
    CFTypeID v40 = CFGetTypeID(v171[0]);
    if (v40 == CFNullGetTypeID()) {
      goto LABEL_363;
    }
    if (!v171[0]) {
      goto LABEL_363;
    }
    CFTypeID v41 = CFGetTypeID(v171[0]);
    if (v41 != CFDictionaryGetTypeID()
      || !CFDictionaryGetValueIfPresent((CFDictionaryRef)v171[0], (const void *)kSecPasswordCharacterCount, (const void **)&v170[3]))
    {
      goto LABEL_363;
    }
    if (v170[3])
    {
      CFTypeID v42 = CFGetTypeID((CFTypeRef)v170[3]);
      if (v42 != CFNullGetTypeID())
      {
        if (v170[3])
        {
          CFTypeID v43 = CFGetTypeID((CFTypeRef)v170[3]);
          if (v43 == CFNumberGetTypeID())
          {
            if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v171[0], (const void *)kSecPasswordCharacters, (const void **)&v170[1]))
            {
              if (v170[1])
              {
                CFTypeID v44 = CFGetTypeID((CFTypeRef)v170[1]);
                if (v44 != CFNullGetTypeID())
                {
                  if (v170[1])
                  {
                    CFTypeID v45 = CFGetTypeID((CFTypeRef)v170[1]);
                    if (v45 == CFStringGetTypeID()) {
                      goto LABEL_106;
                    }
                  }
                }
              }
LABEL_361:
              CFStringRef v157 = @"The dictionary parameter 'Characters' is either null or not a string";
              goto LABEL_381;
            }
LABEL_363:
            CFStringRef v157 = @"The dictionary parameter 'At Least N Characters' is either null or not a string";
            goto LABEL_381;
          }
        }
      }
    }
LABEL_360:
    CFStringRef v157 = @"The dictionary parameter 'characters' is either null or not a number";
    goto LABEL_381;
  }
LABEL_106:
  if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordContainsNoMoreThanNConsecutiveIdenticalCharacters, (const void **)&v170[2]))goto LABEL_111; {
  if (v170[2])
  }
  {
    CFTypeID v46 = CFGetTypeID((CFTypeRef)v170[2]);
    if (v46 != CFNullGetTypeID())
    {
      if (v170[2])
      {
        CFTypeID v47 = CFGetTypeID((CFTypeRef)v170[2]);
        if (v47 == CFNumberGetTypeID()) {
          goto LABEL_111;
        }
      }
    }
  }
  CFStringRef v157 = @"The dictionary parameter 'Identical Consecutive Characters' is either null or not a number";
LABEL_381:
  CFDictionaryRef v81 = CFErrorCreate(*v3, v157, -909, 0);
  if (!v81) {
    goto LABEL_111;
  }
LABEL_160:
  CFRetain(v81);
  CFRelease(v81);
  if (!a2)
  {
LABEL_358:
    CFRelease(v81);
    return 0;
  }
  CFStringRef Copy = 0;
  *a2 = v81;
  return Copy;
}

uint64_t getUniformRandomNumbers(uint64_t a1, unint64_t a2, unsigned int a3)
{
  unint64_t v6 = 0;
  unsigned int v7 = (0xFF % a3) ^ 0xFF;
  do
  {
    do
      uint64_t result = CCRandomCopyBytes();
    while (result == -1);
    unint64_t v9 = a2 - v6;
    if (a2 > v6)
    {
      CFTypeID v10 = (unsigned __int8 *)(a1 + v6);
      do
      {
        unsigned int v12 = *v10++;
        unsigned int v11 = v12;
        if (v12 < v7) {
          *(unsigned char *)(a1 + v6++) = v11 % a3;
        }
        --v9;
      }
      while (v9);
    }
  }
  while (a2 > v6);
  return result;
}

__CFString *CreateChecksum(int a1, CFStringRef theString, uint64_t a3, const __CFString *a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1 != 4) {
    return 0;
  }
  uint64_t v4 = a3;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[0] = v5;
  v16[1] = v5;
  if (a3 > 32) {
    return 0;
  }
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, theString, 0x8000100u, 0);
  if (!ExternalRepresentation) {
    return 0;
  }
  CFDataRef v9 = ExternalRepresentation;
  ccsha256_di();
  CFDataGetLength(v9);
  CFDataGetBytePtr(v9);
  ccdigest();
  CFRelease(v9);
  CFIndex Length = CFStringGetLength(a4);
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFDataRef Mutable = CFStringCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  if (v4 >= 1)
  {
    unsigned int v12 = (unsigned __int8 *)v16;
    do
    {
      unsigned int v13 = *v12++;
      UniChar chars = -21846;
      UniChar chars = CFStringGetCharacterAtIndex(a4, v13 % Length);
      CFStringAppendCharacters(Mutable, &chars, 1);
      --v4;
    }
    while (v4);
  }
  return Mutable;
}

BOOL SecPasswordIsPasswordWeak2(int a1, const __CFString *a2)
{
  uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
  lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
  decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  punctuationCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
  if (CFStringGetLength(a2) < 4) {
    return 1;
  }
  CFIndex v4 = 0;
  do
  {
    if (v4 >= CFStringGetLength(a2))
    {
      if (a1)
      {
        if (CFStringGetLength(a2) == 4)
        {
          if (a2)
          {
            CFRetain(a2);
            CFIndex Length = CFStringGetLength(a2);
            CFIndex v11 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
            unsigned int v12 = (char *)malloc_type_malloc(v11, 0x5ECC0363uLL);
            if (!CFStringGetCString(a2, v12, v11, 0x8000100u)) {
              char *v12 = 0;
            }
            CFRelease(a2);
          }
          else
          {
            unsigned int v12 = strdup((const char *)&unk_18B41CA07);
          }
          if (!in_word_set((unsigned __int8 *)v12))
          {
            int v43 = *v12;
            int v44 = v12[1];
            if (((v43 == v44) == v12[2]) != v12[3])
            {
              int v45 = v12[2];
              int v46 = v12[3];
              if ((v43 != v44 || v45 != v46) && (v43 != v45 || v44 != v46))
              {
                uint64_t v47 = 0;
                while (strcmp(blacklist[v47], v12))
                {
                  if (++v47 == 7) {
                    goto LABEL_100;
                  }
                }
              }
            }
          }
          goto LABEL_98;
        }
        if (CFStringGetLength(a2) != 6) {
          return 0;
        }
        if (a2)
        {
          CFRetain(a2);
          CFIndex v19 = CFStringGetLength(a2);
          CFIndex v20 = CFStringGetMaximumSizeForEncoding(v19, 0x8000100u) + 1;
          unsigned int v12 = (char *)malloc_type_malloc(v20, 0x5ECC0363uLL);
          if (!CFStringGetCString(a2, v12, v20, 0x8000100u)) {
            char *v12 = 0;
          }
          CFRelease(a2);
        }
        else
        {
          unsigned int v12 = strdup((const char *)&unk_18B41CA07);
        }
        CFIndex v48 = 0;
        do
        {
          if (CFStringGetLength(a2) <= v48) {
            break;
          }
          if (v48 == CFStringGetLength(a2) - 1) {
            goto LABEL_98;
          }
          CFAllocatorRef v56 = (unsigned __int8 *)&v12[v48];
          int v57 = v12[v48++];
        }
        while (v57 == v56[1]);
        if (isTopTenSixDigitPasscode(a2, v49, v50, v51, v52, v53, v54, v55)
          || SecPasswordIsPalindrome(a2)
          || SecPasswordHasRepeatingGroups(a2))
        {
LABEL_98:
          free(v12);
          return 1;
        }
      }
      else
      {
        if (a2)
        {
          CFRetain(a2);
          CFIndex v13 = CFStringGetLength(a2);
          CFIndex v14 = CFStringGetMaximumSizeForEncoding(v13, 0x8000100u) + 1;
          unsigned int v12 = (char *)malloc_type_malloc(v14, 0x5ECC0363uLL);
          if (!CFStringGetCString(a2, v12, v14, 0x8000100u)) {
            char *v12 = 0;
          }
          CFRelease(a2);
        }
        else
        {
          unsigned int v12 = strdup((const char *)&unk_18B41CA07);
        }
        int valuePtr = 1;
        CFIndex v21 = CFStringGetLength(a2);
        CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFDataRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
        if (v21 > 0)
        {
          if (v21 != 1)
          {
            for (CFIndex i = 1; i != v21; ++i)
            {
              int CharacterAtIndex = CFStringGetCharacterAtIndex(a2, i - 1);
              int v26 = CFStringGetCharacterAtIndex(a2, i);
              int v27 = valuePtr;
              if (CharacterAtIndex == v26)
              {
                int v27 = valuePtr + 1;
              }
              else if (valuePtr != 1)
              {
                CFNumberRef v28 = CFNumberCreate(v22, kCFNumberIntType, &valuePtr);
                CFArrayAppendValue(Mutable, v28);
                if (v28) {
                  CFRelease(v28);
                }
                int v27 = 1;
              }
              int valuePtr = v27;
            }
          }
          CFNumberRef v29 = CFNumberCreate(v22, kCFNumberIntType, &valuePtr);
          CFArrayAppendValue(Mutable, v29);
          if (v29) {
            CFRelease(v29);
          }
        }
        CFIndex v30 = 0;
        CFNumberRef v31 = 0;
        while (CFArrayGetCount(Mutable) > v30)
        {
          if (v30)
          {
            CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(Mutable, v30);
            if (CFNumberCompare(ValueAtIndex, v31, 0) == kCFCompareGreaterThan) {
              CFNumberRef v31 = ValueAtIndex;
            }
          }
          else
          {
            CFNumberRef v31 = (const __CFNumber *)CFArrayGetValueAtIndex(Mutable, 0);
          }
          ++v30;
        }
        int v58 = 0;
        if (v31) {
          CFNumberGetValue(v31, kCFNumberIntType, &v58);
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
        uint64_t v33 = v58;
        CFIndex v34 = CFStringGetLength(a2);
        if (v34 >= 0) {
          uint64_t v35 = v34;
        }
        else {
          uint64_t v35 = v34 + 1;
        }
        if (v33 >= v35 >> 1
          || SecPasswordIsPalindrome(a2)
          || isTopTenSixDigitPasscode(a2, v36, v37, v38, v39, v40, v41, v42)
          || SecPasswordHasRepeatingGroups(a2) && CFStringGetLength(a2) >= 6)
        {
          goto LABEL_98;
        }
      }
      if (!SecPasswordIsPasscodeIncrementingOrDecrementingDigits(a2)
        && !SecPasswordIsPasswordRepeatingTwoNumbers(a2))
      {
LABEL_100:
        if (v12) {
          free(v12);
        }
        return 0;
      }
      goto LABEL_98;
    }
    v60.location = v4;
    v60.CFIndex length = 1;
    ++v4;
  }
  while (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)decimalDigitCharacterSet, v60, 0, 0));
  if (a1) {
    return 0;
  }
  int v5 = 0;
  int v6 = 0;
  int v7 = 0;
  CFIndex v8 = 0;
  int v9 = 0;
  while (v8 < CFStringGetLength(a2))
  {
    v61.location = v8;
    v61.CFIndex length = 1;
    if (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)uppercaseLetterCharacterSet, v61, 4uLL, 0))
    {
      ++v9;
    }
    else
    {
      v62.location = v8;
      v62.CFIndex length = 1;
      if (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)lowercaseLetterCharacterSet, v62, 4uLL, 0))
      {
        ++v5;
      }
      else
      {
        v63.location = v8;
        v63.CFIndex length = 1;
        if (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)decimalDigitCharacterSet, v63, 4uLL, 0))
        {
          ++v6;
        }
        else
        {
          v64.location = v8;
          v64.CFIndex length = 1;
          if (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)punctuationCharacterSet, v64, 4uLL, 0)) {
            ++v7;
          }
        }
      }
    }
    ++v8;
  }
  if (v9 <= 0) {
    int v15 = 0;
  }
  else {
    int v15 = 26;
  }
  if (v5 > 0) {
    v15 += 26;
  }
  if (v6 > 0) {
    v15 += 10;
  }
  if (v7 <= 0) {
    int v16 = v15;
  }
  else {
    int v16 = v15 + 33;
  }
  double v17 = (double)CFStringGetLength(a2);
  return log2((double)v16) * v17 < 35.0;
}

const char *in_word_set(unsigned __int8 *a1)
{
  int v1 = pinhash_asso_values[a1[3] + 9];
  int v2 = pinhash_asso_values[a1[2]];
  uint64_t v3 = *a1;
  unsigned int v5 = a1[1];
  CFIndex v4 = (const char *)(a1 + 1);
  unsigned int v6 = v1 + v2 + pinhash_asso_values[v5] + pinhash_asso_values[v3 + 3] + 4;
  if (v6 > 0x113) {
    return 0;
  }
  int v7 = (const char *)*(&in_word_set_wordlist + v6);
  if (v3 != *(unsigned __int8 *)v7 || strcmp(v4, v7 + 1)) {
    return 0;
  }
  return v7;
}

BOOL isTopTenSixDigitPasscode(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  MutableForCFTypesWith = CFArrayCreateMutableForCFTypesWith((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2, a3, a4, a5, a6, a7, a8, @"030379", @"101471");
  for (CFIndex i = 0; ; ++i)
  {
    CFIndex Count = CFArrayGetCount(MutableForCFTypesWith);
    if (i >= Count) {
      break;
    }
    CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(MutableForCFTypesWith, i);
    if (a1 && ValueAtIndex)
    {
      if (CFEqual(a1, ValueAtIndex)) {
        break;
      }
    }
    else if (ValueAtIndex == a1)
    {
      break;
    }
  }
  if (MutableForCFTypesWith) {
    CFRelease(MutableForCFTypesWith);
  }
  return i < Count;
}

uint64_t SecPasswordIsPalindrome(const __CFString *cf)
{
  if (cf)
  {
    CFRetain(cf);
    CFIndex Length = CFStringGetLength(cf);
    CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    CFIndex v4 = (char *)malloc_type_malloc(v3, 0x5ECC0363uLL);
    if (!CFStringGetCString(cf, v4, v3, 0x8000100u)) {
      *CFIndex v4 = 0;
    }
    CFRelease(cf);
  }
  else
  {
    CFIndex v4 = strdup((const char *)&unk_18B41CA07);
  }
  CFIndex v5 = CFStringGetLength(cf);
  CFIndex v6 = 0;
  if (v5 >= 0) {
    CFIndex v7 = v5 & 1;
  }
  else {
    CFIndex v7 = -(v5 & 1);
  }
  CFIndex v8 = v5 - 1;
  while (CFStringGetLength(cf) > v6)
  {
    if (v7 == 1 && v8 == v6) {
      goto LABEL_18;
    }
    int v9 = v4[v6];
    int v10 = v4[v8];
    if (!v7 && v8 - 1 == v6)
    {
      if (v9 == v10)
      {
LABEL_18:
        free(v4);
        return 1;
      }
      break;
    }
    ++v6;
    --v8;
    if (v9 != v10) {
      break;
    }
  }
  free(v4);
  return 0;
}

uint64_t SecPasswordHasRepeatingGroups(const __CFString *cf)
{
  if (cf)
  {
    CFRetain(cf);
    CFIndex Length = CFStringGetLength(cf);
    CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    CFIndex v4 = (char *)malloc_type_malloc(v3, 0x5ECC0363uLL);
    if (!CFStringGetCString(cf, v4, v3, 0x8000100u)) {
      *CFIndex v4 = 0;
    }
    CFRelease(cf);
  }
  else
  {
    CFIndex v4 = strdup((const char *)&unk_18B41CA07);
  }
  for (CFIndex i = 0; CFStringGetLength(cf) > i; ++i)
  {
    CFIndex v6 = CFStringGetLength(cf);
    int v7 = v4[i];
    if (v6 == i + 4)
    {
      if (v7 == v4[(i + 3)])
      {
        free(v4);
        return 1;
      }
      break;
    }
    if (v7 != v4[i + 3]) {
      break;
    }
  }
  free(v4);
  return 0;
}

uint64_t SecPasswordIsPasscodeIncrementingOrDecrementingDigits(const __CFString *cf)
{
  if (cf)
  {
    CFRetain(cf);
    CFIndex Length = CFStringGetLength(cf);
    CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    CFIndex v4 = (char *)malloc_type_malloc(v3, 0x5ECC0363uLL);
    if (!CFStringGetCString(cf, v4, v3, 0x8000100u)) {
      *CFIndex v4 = 0;
    }
    CFRelease(cf);
  }
  else
  {
    CFIndex v4 = strdup((const char *)&unk_18B41CA07);
  }
  CFIndex v5 = 0;
  do
  {
    if (CFStringGetLength(cf) <= v5) {
      break;
    }
    if (v5 == CFStringGetLength(cf) - 1)
    {
LABEL_18:
      uint64_t v9 = 1;
      goto LABEL_20;
    }
    CFIndex v6 = &v4[v5];
    int v7 = v4[v5++] + 1;
  }
  while (v7 == v6[1]);
  for (CFIndex i = 0; CFStringGetLength(cf) > i; ++i)
  {
    if (i == CFStringGetLength(cf) - 1) {
      goto LABEL_18;
    }
    if (v4[i + 1] + 1 != v4[i])
    {
      uint64_t v9 = 0;
      if (i || *v4 != 48 || v4[i + 1] != 57) {
        goto LABEL_20;
      }
    }
  }
  uint64_t v9 = 0;
LABEL_20:
  free(v4);
  return v9;
}

uint64_t SecPasswordIsPasswordRepeatingTwoNumbers(const __CFString *cf)
{
  if (cf)
  {
    CFRetain(cf);
    CFIndex Length = CFStringGetLength(cf);
    CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    CFIndex v4 = (char *)malloc_type_malloc(v3, 0x5ECC0363uLL);
    if (!CFStringGetCString(cf, v4, v3, 0x8000100u)) {
      *CFIndex v4 = 0;
    }
    CFRelease(cf);
  }
  else
  {
    CFIndex v4 = strdup((const char *)&unk_18B41CA07);
  }
  CFIndex v5 = 0;
  while (1)
  {
    if (CFStringGetLength(cf) <= v5)
    {
LABEL_10:
      uint64_t v8 = 0;
      goto LABEL_12;
    }
    if (CFStringGetLength(cf) == v5 + 3) {
      break;
    }
    int v6 = v4[v5];
    int v7 = v4[v5++ + 2];
    if (v6 != v7) {
      goto LABEL_10;
    }
  }
  uint64_t v8 = 1;
LABEL_12:
  free(v4);
  return v8;
}

__CFArray *CFArrayCreateMutableForCFTypesWith(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10)
{
  int v16 = &a10;
  CFIndex v10 = 0;
  CFIndex v11 = a9;
  if (a9)
  {
    do
    {
      unsigned int v12 = v16++;
      ++v10;
    }
    while (*v12);
  }
  CFDataRef Mutable = CFArrayCreateMutable(a1, v10, MEMORY[0x1E4F1D510]);
  double v17 = (const void **)&a10;
  if (a9)
  {
    do
    {
      CFArrayAppendValue(Mutable, v11);
      CFIndex v14 = v17++;
      CFIndex v11 = *v14;
    }
    while (*v14);
  }
  return Mutable;
}

BOOL SecPasswordIsPasswordWeak(const __CFString *a1)
{
  uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
  lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
  decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  punctuationCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
  if (CFStringGetLength(a1) < 4) {
    return 1;
  }
  for (CFIndex i = 0; i < CFStringGetLength(a1); ++i)
  {
    v33.location = i;
    v33.CFIndex length = 1;
    if (!CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)decimalDigitCharacterSet, v33, 0, 0))
    {
      int v3 = 0;
      int v4 = 0;
      int v5 = 0;
      int v6 = 0;
      for (CFIndex j = 0; j < CFStringGetLength(a1); ++j)
      {
        v34.location = j;
        v34.CFIndex length = 1;
        if (CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)uppercaseLetterCharacterSet, v34, 4uLL, 0))
        {
          ++v3;
        }
        else
        {
          v35.location = j;
          v35.CFIndex length = 1;
          if (CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)lowercaseLetterCharacterSet, v35, 4uLL, 0))
          {
            ++v4;
          }
          else
          {
            v36.location = j;
            v36.CFIndex length = 1;
            if (CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)decimalDigitCharacterSet, v36, 4uLL, 0))
            {
              ++v5;
            }
            else
            {
              v37.location = j;
              v37.CFIndex length = 1;
              if (CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)punctuationCharacterSet, v37, 4uLL, 0)) {
                ++v6;
              }
            }
          }
        }
      }
      if (v3 <= 0) {
        int v11 = 0;
      }
      else {
        int v11 = 26;
      }
      if (v4 > 0) {
        v11 += 26;
      }
      if (v5 > 0) {
        v11 += 10;
      }
      if (v6 <= 0) {
        int v12 = v11;
      }
      else {
        int v12 = v11 + 33;
      }
      double Length = (double)CFStringGetLength(a1);
      return log2((double)v12) * Length < 35.0;
    }
  }
  if (CFStringGetLength(a1) == 4)
  {
    if (a1)
    {
      CFRetain(a1);
      CFIndex v8 = CFStringGetLength(a1);
      CFIndex v9 = CFStringGetMaximumSizeForEncoding(v8, 0x8000100u) + 1;
      CFIndex v10 = (char *)malloc_type_malloc(v9, 0x5ECC0363uLL);
      if (!CFStringGetCString(a1, v10, v9, 0x8000100u)) {
        *CFIndex v10 = 0;
      }
      CFRelease(a1);
    }
    else
    {
      CFIndex v10 = strdup((const char *)&unk_18B41CA07);
    }
    if (!in_word_set((unsigned __int8 *)v10))
    {
      int v17 = *v10;
      int v18 = v10[1];
      if (((v17 == v18) == v10[2]) != v10[3])
      {
        int v19 = v10[2];
        int v20 = v10[3];
        if ((v17 != v18 || v19 != v20) && (v17 != v19 || v18 != v20))
        {
          CFIndex v28 = 0;
          do
          {
            if (CFStringGetLength(a1) <= v28) {
              break;
            }
            if (v28 == CFStringGetLength(a1) - 1) {
              goto LABEL_43;
            }
            CFNumberRef v29 = (unsigned __int8 *)&v10[v28];
            int v30 = v10[v28++] + 1;
          }
          while (v30 == (char)v29[1]);
          for (CFIndex k = 0; CFStringGetLength(a1) > k; ++k)
          {
            if (k == CFStringGetLength(a1) - 1) {
              goto LABEL_43;
            }
            if (v10[k + 1] + 1 != v10[k] && (k || v10[k] != 48 || v10[k + 1] != 57)) {
              break;
            }
          }
          uint64_t v32 = 0;
          while (strcmp(blacklist[v32], v10))
          {
            if (++v32 == 7) {
              goto LABEL_77;
            }
          }
        }
      }
    }
LABEL_43:
    free(v10);
    return 1;
  }
  if (a1)
  {
    CFRetain(a1);
    CFIndex v15 = CFStringGetLength(a1);
    CFIndex v16 = CFStringGetMaximumSizeForEncoding(v15, 0x8000100u) + 1;
    CFIndex v10 = (char *)malloc_type_malloc(v16, 0x5ECC0363uLL);
    if (!CFStringGetCString(a1, v10, v16, 0x8000100u)) {
      *CFIndex v10 = 0;
    }
    CFRelease(a1);
  }
  else
  {
    CFIndex v10 = strdup((const char *)&unk_18B41CA07);
  }
  CFIndex v21 = 0;
  do
  {
    if (CFStringGetLength(a1) <= v21) {
      break;
    }
    if (CFStringGetLength(a1) <= v21 + 1) {
      goto LABEL_43;
    }
    int v22 = v10[v21];
    int v23 = v10[++v21];
  }
  while (v22 == v23);
  CFIndex v24 = 0;
  do
  {
    if (CFStringGetLength(a1) <= v24) {
      break;
    }
    if (v24 == CFStringGetLength(a1) - 1) {
      goto LABEL_43;
    }
    CFTypeID v25 = (unsigned __int8 *)&v10[v24];
    int v26 = v10[v24++] + 1;
  }
  while (v26 == (char)v25[1]);
  for (CFIndex m = 0; CFStringGetLength(a1) > m; ++m)
  {
    if (m == CFStringGetLength(a1) - 1) {
      goto LABEL_43;
    }
    if (v10[m + 1] + 1 != v10[m] && (m || v10[m] != 48 || v10[m + 1] != 57)) {
      goto LABEL_78;
    }
  }
LABEL_77:
  if (!v10) {
    return 0;
  }
LABEL_78:
  free(v10);
  return 0;
}

CFDictionaryRef SecPasswordCopyDefaultPasswordLength(int a1, __CFString **a2)
{
  switch(a1)
  {
    case 0:
      uint64_t valuePtr = 4;
      uint64_t v2 = 5;
      goto LABEL_8;
    case 1:
      uint64_t valuePtr = 4;
      uint64_t v2 = 6;
      goto LABEL_8;
    case 2:
      uint64_t valuePtr = 4;
      uint64_t v2 = 3;
      goto LABEL_8;
    case 3:
      uint64_t valuePtr = 4;
      uint64_t v2 = 1;
      goto LABEL_8;
    case 4:
      uint64_t valuePtr = 4;
      uint64_t v2 = 7;
LABEL_8:
      uint64_t v9 = v2;
      CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCFIndexType, &valuePtr);
      CFNumberRef v6 = CFNumberCreate(v4, kCFNumberCFIndexType, &v9);
      CFDataRef Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFDictionaryAddValue(Mutable, (const void *)kSecPasswordGroupSize, v5);
      CFDictionaryAddValue(Mutable, (const void *)kSecPasswordNumberOfGroups, v6);
      CFDictionaryRef Copy = CFDictionaryCreateCopy(v4, Mutable);
      if (v5) {
        CFRelease(v5);
      }
      if (v6) {
        CFRelease(v6);
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      break;
    default:
      SecError(-909, a2, @"Password type does not exist.");
      CFDictionaryRef Copy = 0;
      break;
  }
  return Copy;
}

BOOL SecPasswordValidatePasswordFormat(int a1, CFStringRef theString, __CFString **a3)
{
  switch(a1)
  {
    case 4:
      int v6 = 0;
      uint64_t v7 = 7;
      CFIndex range = 2;
      CFNumberRef v5 = @"ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
      break;
    case 3:
      CFNumberRef v5 = 0;
      CFIndex range = 0;
      int v6 = 1;
      uint64_t v7 = 1;
      break;
    case 1:
      CFNumberRef v5 = 0;
      CFIndex range = 0;
      int v6 = 1;
      uint64_t v7 = 6;
      break;
    default:
      SecError(-909, a3, @"Password type does not exist.");
      return 0;
  }
  if (CFStringGetLength(theString) != 5 * v7 - 1) {
    return 0;
  }
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  if (!Mutable) {
    return 0;
  }
  uint64_t v9 = Mutable;
  CFStringRef v25 = v5;
  CFIndex v10 = 0;
  uint64_t v11 = 4 * v7;
  uint64_t v12 = 5 * v7;
  do
  {
    if (v10)
    {
      CFIndex v13 = v10;
      if (CFStringGetCharacterAtIndex(theString, v10 - 1) != 45) {
        goto LABEL_33;
      }
    }
    else
    {
      CFIndex v13 = 0;
    }
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
    }
    v27.location = v13;
    v27.CFIndex length = 4;
    CFStringRef v14 = CFStringCreateWithSubstring((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, theString, v27);
    CFStringAppend(v9, v14);
    if (v14) {
      CFRelease(v14);
    }
    v10 += 5;
  }
  while (v12 != v10);
  if (v6)
  {
    CFRelease(v9);
    return 1;
  }
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  v28.CFIndex length = range;
  CFIndex v16 = v11 - range;
  v28.location = v16;
  CFStringRef v17 = CFStringCreateWithSubstring((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, v9, v28);
  if (!v17)
  {
LABEL_33:
    int v23 = v9;
LABEL_34:
    CFRelease(v23);
    return 0;
  }
  CFStringRef v18 = v17;
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_8668);
  }
  v29.location = 0;
  v29.CFIndex length = v16;
  CFStringRef v19 = CFStringCreateWithSubstring((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, v9, v29);
  if (!v19)
  {
    CFRelease(v9);
    int v23 = (__CFString *)v18;
    goto LABEL_34;
  }
  CFStringRef v20 = v19;
  ChecksuCFIndex m = CreateChecksum(a1, v19, range, v25);
  if (Checksum)
  {
    int v22 = Checksum;
    BOOL v15 = CFEqual(Checksum, v18) != 0;
    CFRelease(v9);
    uint64_t v9 = v22;
  }
  else
  {
    BOOL v15 = 0;
  }
  CFRelease(v9);
  CFRelease(v18);
  CFRelease(v20);
  return v15;
}

__CFString *SecPolicyCopyDescription(void *a1)
{
  SecGetDebugDescriptionFormatOptions();

  return SecPolicyCopyFormatDescription(a1);
}

__CFString *SecPolicyCopyFormatDescription(void *a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFTypeID v3 = CFGetTypeID(a1);
  CFStringRef v4 = CFCopyTypeIDDescription(v3);
  CFStringRef v5 = v4;
  int v6 = (__CFString *)a1[3];
  if (!v6) {
    int v6 = &stru_1ED84D0B0;
  }
  CFStringAppendFormat(Mutable, 0, @"<%@: oid: %@ name: %@ options %@", v4, a1[2], v6, a1[4]);
  CFRelease(v5);
  CFStringAppend(Mutable, @" >");
  return Mutable;
}

CFHashCode SecPolicyHash(CFTypeRef *a1)
{
  CFTypeRef v2 = a1[3];
  CFHashCode v3 = CFHash(a1[2]);
  if (v2)
  {
    CFHashCode v4 = CFHash(a1[3]) + v3;
    CFHashCode v3 = CFHash(a1[4]);
  }
  else
  {
    CFHashCode v4 = CFHash(a1[4]);
  }
  return v4 + v3;
}

uint64_t SecPolicyCompare(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 24) && *(void *)(a2 + 24))
  {
    uint64_t result = CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
    if (!result) {
      return result;
    }
    CFStringRef v5 = *(const void **)(a1 + 24);
    int v6 = *(const void **)(a2 + 24);
  }
  else
  {
    CFStringRef v5 = *(const void **)(a1 + 16);
    int v6 = *(const void **)(a2 + 16);
  }
  uint64_t result = CFEqual(v5, v6);
  if (result) {
    return CFEqual(*(CFTypeRef *)(a1 + 32), *(CFTypeRef *)(a2 + 32)) != 0;
  }
  return result;
}

SecPolicyRef SecPolicyCreateWithProperties(CFTypeRef policyIdentifier, CFDictionaryRef properties)
{
  EAP = (__SecPolicy *)policyIdentifier;
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  values = 0;
  if (!policyIdentifier) {
    return EAP;
  }
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID != CFGetTypeID(EAP)) {
    return 0;
  }
  if (!properties)
  {
    CFIndex v10 = 0;
    CFStringRef v9 = 0;
    CFTypeRef cf = 0;
    CFIndex v8 = 0;
    BOOL v7 = 0;
    int v6 = 0;
    CFStringRef v5 = 0;
LABEL_12:
    char v12 = 1;
    goto LABEL_13;
  }
  CFStringRef v5 = (__CFString *)CFDictionaryGetValue(properties, @"SecPolicyName");
  values = v5;
  int v6 = CFDictionaryGetValue(properties, @"SecPolicyTeamIdentifier");
  *(void *)value = 0xAAAAAAAAAAAAAAAALL;
  BOOL v7 = 0;
  if (CFDictionaryGetValueIfPresent(properties, @"SecPolicyClient", (const void **)value) && *(void *)value) {
    BOOL v7 = CFEqual((CFTypeRef)*MEMORY[0x1E4F1CFD0], *(CFTypeRef *)value) != 0;
  }
  CFIndex v8 = CFDictionaryGetValue(properties, @"SecPolicyContext");
  CFTypeRef cf = (__CFString *)CFDictionaryGetValue(properties, @"SecPolicyPolicyName");
  CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(properties, @"SecPolicyIntermediateMarkerOid");
  CFIndex v10 = (__CFString *)CFDictionaryGetValue(properties, @"SecPolicyLeafMarkerOid");
  properties = (CFDictionaryRef)CFDictionaryGetValue(properties, @"SecPolicyRootDigest");
  if (!v5) {
    goto LABEL_12;
  }
  CFTypeID v11 = CFGetTypeID(v5);
  if (v11 != CFStringGetTypeID() && !CFEqual(EAP, @"1.2.840.113635.100.1.9"))
  {
    BOOL v15 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)value = 138412546;
      *(void *)&value[4] = EAP;
      __int16 v44 = 2112;
      int v45 = @"SecPolicyName";
      CFIndex v16 = "policy \"%@\" requires a string value for the %@ key";
      CFStringRef v17 = v15;
      uint32_t v18 = 22;
LABEL_27:
      _os_log_impl(&dword_18B299000, v17, OS_LOG_TYPE_DEFAULT, v16, value, v18);
      return 0;
    }
    return 0;
  }
  char v12 = 0;
LABEL_13:
  if (!CFEqual(EAP, @"1.2.840.113635.100.1.3"))
  {
    if (CFEqual(EAP, @"1.2.840.113635.100.1.8"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateSMIME(31, v5);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.9"))
    {
      if (v12)
      {
LABEL_24:
        SMIME = SecPolicyCreateEAP(!v7, 0);
        goto LABEL_17;
      }
      CFTypeID v19 = CFGetTypeID(v5);
      if (v19 == CFStringGetTypeID())
      {
        CFArrayRef Copy = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
      }
      else
      {
        CFTypeID v21 = CFGetTypeID(v5);
        if (v21 != CFArrayGetTypeID()) {
          goto LABEL_24;
        }
        CFArrayRef Copy = CFArrayCreateCopy(0, (CFArrayRef)v5);
      }
      CFArrayRef v22 = Copy;
      EAP = SecPolicyCreateEAP(!v7, Copy);
      if (v22) {
        CFRelease(v22);
      }
      goto LABEL_18;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.11"))
    {
      SMIME = SecPolicyCreateIPSec(!v7, v5);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.19"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateMacAppStoreReceipt();
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.21"))
    {
      SMIME = SecPolicyCreateRevocation(3uLL);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.22"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreatePassbookCardSigner(v5, v6);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.42"))
    {
      if (v12)
      {
        int v23 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
          return 0;
        }
        *(_DWORD *)value = 138412290;
        *(void *)&value[4] = EAP;
        CFIndex v16 = "policy \"%@\" requires kSecPolicyName input";
        goto LABEL_90;
      }
      CFIndex v24 = @"1.2.840.113635.100.1.42";
      CFStringRef v25 = @"AST2";
      int v26 = &oidAppleCertExtAST2DiagnosticsServerAuthProd;
      CFRange v27 = &oidAppleCertExtAST2DiagnosticsServerAuthProdQA;
      goto LABEL_67;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.43"))
    {
      if (v12)
      {
        int v23 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
          return 0;
        }
        *(_DWORD *)value = 138412290;
        *(void *)&value[4] = EAP;
        CFIndex v16 = "policy \"%@\" requires kSecPolicyName input";
        goto LABEL_90;
      }
      CFIndex v24 = @"1.2.840.113635.100.1.43";
      CFStringRef v25 = @"Escrow";
      int v26 = &oidAppleCertExtEscrowProxyServerAuthProd;
      CFRange v27 = &oidAppleCertExtEscrowProxyServerAuthProdQA;
LABEL_67:
      CFRange v28 = v5;
LABEL_68:
      SMIME = (__SecPolicy *)SecPolicyCreateAppleServerAuthCommon(v28, v24, v25, (uint64_t)v26, (uint64_t)v27);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.44"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.44";
        CFStringRef v25 = @"FMiP";
        int v26 = &oidAppleCertExtFMiPServerAuthProd;
        CFRange v27 = &oidAppleCertExtFMiPServerAuthProdQA;
        goto LABEL_67;
      }
      int v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy \"%@\" requires kSecPolicyName input";
LABEL_90:
      CFStringRef v17 = v23;
      uint32_t v18 = 12;
      goto LABEL_27;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.45"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.45";
        CFStringRef v25 = @"MMCS";
        int v26 = &oidAppleCertExtAppleServerAuthenticationMMCSProd;
        CFRange v27 = &oidAppleCertExtAppleServerAuthenticationMMCSProdQA;
        goto LABEL_67;
      }
      int v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy \"%@\" requires kSecPolicyName input";
      goto LABEL_90;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.46"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.46";
        CFStringRef v25 = @"GS";
        int v26 = &oidAppleCertExtAppleServerAuthenticationGS;
        CFRange v28 = v5;
        CFRange v27 = 0;
        goto LABEL_68;
      }
      int v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy \"%@\" requires kSecPolicyName input";
      goto LABEL_90;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.47"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.47";
        CFStringRef v25 = @"PPQ";
        int v26 = &oidAppleCertExtAppleServerAuthenticationPPQProd;
        CFRange v27 = &oidAppleCertExtAppleServerAuthenticationPPQProdQA;
        goto LABEL_67;
      }
      int v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy \"%@\" requires kSecPolicyName input";
      goto LABEL_90;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.62"))
    {
      if (!cf)
      {
        int v23 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
          return 0;
        }
        *(_DWORD *)value = 138412290;
        *(void *)&value[4] = EAP;
        CFIndex v16 = "policy \"%@\" requires kSecPolicyPolicyName input";
        goto LABEL_90;
      }
      CFRange v29 = cf;
      CFStringRef v30 = v9;
      CFStringRef v31 = v10;
LABEL_77:
      SMIME = (__SecPolicy *)SecPolicyCreateApplePinned(v29, v30, v31);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.63"))
    {
      if (cf)
      {
        SMIME = (__SecPolicy *)SecPolicyCreateAppleSSLPinned(cf, v5, v9, v10);
        goto LABEL_17;
      }
      int v23 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)value = 138412290;
        *(void *)&value[4] = EAP;
        CFIndex v16 = "policy \"%@\" requires kSecPolicyPolicyName input";
        goto LABEL_90;
      }
      return 0;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.68"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.68";
        CFStringRef v25 = @"IDS";
        int v26 = &oidAppleCertExtAppleServerAuthenticationIDSProd;
        CFRange v27 = &oidAppleCertExtAppleServerAuthenticationIDSProdQA;
        goto LABEL_67;
      }
      int v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy \"%@\" requires kSecPolicyName input";
      goto LABEL_90;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.69"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.69";
        CFStringRef v25 = @"APN";
        int v26 = &oidAppleCertExtAppleServerAuthenticationAPNProd;
        CFRange v27 = &oidAppleCertExtAppleServerAuthenticationAPNProdQA;
        goto LABEL_67;
      }
      int v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy \"%@\" requires kSecPolicyName input";
      goto LABEL_90;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.72"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleUniqueDeviceCertificate(properties);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.77"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.77";
        CFStringRef v25 = @"iCloudSetup";
        int v26 = &oidAppleCertExtAppleServerAuthenticationiCloudSetupProd;
        CFRange v27 = &oidAppleCertExtAppleServerAuthenticationiCloudSetupProdQA;
        goto LABEL_67;
      }
      int v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy \"%@\" requires kSecPolicyName input";
      goto LABEL_90;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.84"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleBasicAttestationSystem(properties);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.85"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleBasicAttestationUser(properties);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.92"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleComponentCertificate(properties);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.102"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAggregateMetricTransparency(!v7);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.106"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAggregateMetricEncryption(!v7);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.107"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateApplePayModelSigning(1);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.108"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateMDLTerminalAuth(1, 1);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.112"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreatePPMAggregatorConfigSigning(!v7);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.117"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateiAPAuthV4(1);
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.118"))
    {
      if (v12)
      {
        int v23 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
          return 0;
        }
        *(_DWORD *)value = 138412290;
        *(void *)&value[4] = EAP;
        CFIndex v16 = "policy \"%@\" requires kSecPolicyName input";
        goto LABEL_90;
      }
      uint64_t v32 = @"1.2.840.113635.100.1.118";
      CFRange v33 = @"ParakeetService";
      CFRange v34 = v5;
      CFRange v35 = v8;
      goto LABEL_129;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.2"))
    {
      SMIME = SecPolicyCreateBasicX509();
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.10"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleSWUpdateSigning();
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.16"))
    {
      SMIME = SecPolicyCreateCodeSigning();
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.17"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateApplePackageSigning();
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.18"))
    {
LABEL_137:
      SMIME = (__SecPolicy *)SecPolicyCreateAppleIDAuthorityPolicy();
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.20"))
    {
      SMIME = SecPolicyCreateAppleTimeStamping();
      goto LABEL_17;
    }
    if (CFEqual(EAP, @"1.2.840.113635.100.1.23"))
    {
      int v36 = 0;
    }
    else
    {
      if (CFEqual(EAP, @"1.2.840.113635.100.1.24"))
      {
        SMIME = (__SecPolicy *)SecPolicyCreateEscrowServiceSigner();
        goto LABEL_17;
      }
      if (CFEqual(EAP, @"1.2.840.113635.100.1.25") || CFEqual(EAP, @"1.2.840.113635.100.1.26"))
      {
        SMIME = (__SecPolicy *)SecPolicyCreateConfigurationProfileSigner();
        goto LABEL_17;
      }
      if (!CFEqual(EAP, @"1.2.840.113635.100.1.27"))
      {
        if (CFEqual(EAP, @"1.2.840.113635.100.1.30"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleIDValidationRecordSigningPolicy();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.30"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleIDValidationShortcutSigningPolicy();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.31"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleSMPEncryption();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.32"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateTestAppleSMPEncryption();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.33"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleSSLService(v5);
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.34"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreatePCSEscrowServiceSigner();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.35"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateApplePPQSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.36"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateTestApplePPQSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.39"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateApplePayIssuerEncryption();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.40"))
        {
          SMIME = SecPolicyCreateOSXProvisioningProfileSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.41"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleATVVPNProfileSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.48"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleHomeKitServerAuth(v5);
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.49"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneActivation();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.50"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneDeviceCertificate();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.51"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateFactoryDeviceCertificate();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.52"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiAP();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.53"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiTunesStoreURLBag();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.54"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneApplicationSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.55"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneProfileApplicationSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.56"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneProvisioningProfileSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.57"))
        {
          SMIME = SecPolicyCreateLockdownPairing();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.58"))
        {
          SMIME = SecPolicyCreateURLBag();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.59"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateOTATasking();
          goto LABEL_17;
        }
        if (CFEqual(EAP, @"1.2.840.113635.100.1.60"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateMobileAsset();
          goto LABEL_17;
        }
        if (!CFEqual(EAP, @"1.2.840.113635.100.1.61"))
        {
          if (CFEqual(EAP, @"1.2.840.113635.100.1.64"))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateAppleSoftwareSigning();
            goto LABEL_17;
          }
          if (CFEqual(EAP, @"1.2.840.113635.100.1.65"))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateAppleExternalDeveloperOptionalExpiry(1);
            goto LABEL_17;
          }
          if (CFEqual(EAP, @"1.2.840.113635.100.1.66"))
          {
            SMIME = SecPolicyCreateOCSPSigner();
            goto LABEL_17;
          }
          if (CFEqual(EAP, @"1.2.840.113635.100.1.67"))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateAppleIDSService(v5);
            goto LABEL_17;
          }
          if (CFEqual(EAP, @"1.2.840.113635.100.1.70"))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateApplePushServiceLegacy(v5);
            goto LABEL_17;
          }
          if (CFEqual(EAP, @"1.2.840.113635.100.1.71"))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateAppleTVOSApplicationSigning();
            goto LABEL_17;
          }
          if (CFEqual(EAP, @"1.2.840.113635.100.1.73"))
          {
            CFRange v37 = @"1.2.840.113635.100.1.73";
            uint64_t v38 = @"Escrow";
            uint64_t v39 = @"1.2.840.113635.100.6.27.7.2";
            uint64_t v40 = @"1.2.840.113635.100.6.27.7.1";
          }
          else if (CFEqual(EAP, @"1.2.840.113635.100.1.74"))
          {
            CFRange v37 = @"1.2.840.113635.100.1.74";
            uint64_t v38 = @"MMCS";
            uint64_t v39 = @"1.2.840.113635.100.6.27.11.2";
            uint64_t v40 = @"1.2.840.113635.100.6.27.11.1";
          }
          else
          {
            if (CFEqual(EAP, @"1.2.840.113635.100.1.75"))
            {
              SMIME = (__SecPolicy *)SecPolicyCreateAppleSecureIOStaticAsset();
              goto LABEL_17;
            }
            if (CFEqual(EAP, @"1.2.840.113635.100.1.76"))
            {
              SMIME = (__SecPolicy *)SecPolicyCreateAppleWarsaw();
              goto LABEL_17;
            }
            if (!CFEqual(EAP, @"1.2.840.113635.100.1.78"))
            {
              if (CFEqual(EAP, @"1.2.840.113635.100.1.80"))
              {
                SMIME = SecPolicyCreateAppleAppTransportSecurity();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.81"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMacOSProfileApplicationSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.82"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMobileSoftwareUpdate();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.83"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMobileAssetDevelopment();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.86"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateiPhoneVPNApplicationSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.87"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateiAPSWAuthWithExpiration(0);
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.88"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateDemoDigitalCatalogSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.89"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleAssetReceipt();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.90"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleDeveloperIDPlusTicket();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.91"))
              {
                SMIME = SecPolicyCreateAppleFDRProvisioning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.93"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleKeyTransparency(v5);
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.95"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAlisha();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.96"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMeasuredBootPolicySigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.97"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateApplePayQRCodeEncryption();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.98"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateApplePayQRCodeSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.99"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleAccessoryUpdateSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.100"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateEscrowServiceIdKeySigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.101"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreatePCSEscrowServiceIdKeySigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.103"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateDeveloperIDInstaller();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.104"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMacAppStoreInstaller();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.105"))
              {
                CFRange v29 = @"MacDistributionInstaller";
                CFStringRef v30 = @"1.2.840.113635.100.6.2.1";
                CFStringRef v31 = @"1.2.840.113635.100.6.1.8";
                goto LABEL_77;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.109"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleCHIPUpdateSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.110"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateOrderBundleSigner(v5);
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.111"))
              {
                SMIME = SecPolicyCreateQiSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.113"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleXROSApplicationSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, @"1.2.840.113635.100.1.114"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateEDPSigning();
                goto LABEL_17;
              }
              if (!CFEqual(EAP, @"1.2.840.113635.100.1.116"))
              {
                if (CFEqual(EAP, @"1.2.840.113635.100.1.119"))
                {
                  SMIME = SecPolicyCreateDCAttestation();
                  goto LABEL_17;
                }
                int v23 = secLogObjForScope("SecError");
                if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)value = 138412290;
                  *(void *)&value[4] = EAP;
                  CFIndex v16 = "ERROR: policy \"%@\" is unsupported";
                  goto LABEL_90;
                }
                return 0;
              }
              uint64_t v32 = @"1.2.840.113635.100.1.116";
              CFRange v33 = @"ParakeetSigning";
              CFRange v34 = 0;
              CFRange v35 = 0;
LABEL_129:
              SMIME = (__SecPolicy *)SecPolicyCreateParakeetCommon(v34, v35, v32, v33);
              goto LABEL_17;
            }
            CFRange v37 = @"1.2.840.113635.100.1.78";
            uint64_t v38 = @"iCloudSetup";
            uint64_t v39 = @"1.2.840.113635.100.6.27.15.2";
            uint64_t v40 = @"1.2.840.113635.100.6.27.15.1";
          }
          SMIME = (__SecPolicy *)SecPolicyCreateAppleGeoTrustServerAuthCommon(v5, v37, v38, v39, v40);
          goto LABEL_17;
        }
        goto LABEL_137;
      }
      int v36 = 1;
    }
    SMIME = (__SecPolicy *)CreateMobileStoreSigner(v36);
    goto LABEL_17;
  }
  SMIME = (__SecPolicy *)SecPolicyCreateSSL_internal(!v7, v5, 0, 0);
LABEL_17:
  EAP = SMIME;
LABEL_18:
  if (EAP && cf) {
    SecPolicySetName((uint64_t)EAP, cf);
  }
  return EAP;
}

void *SecPolicyCreateSMIME(char a1, const void *a2)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v5 = Mutable;
  if ((a1 & 0x40) != 0)
  {
    SecPolicyAddBasicCertOptions(Mutable);
    if ((a1 & 1) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  SecPolicyAddBasicX509Options(Mutable);
  if (a1)
  {
LABEL_6:
    add_ku(v5, 0);
    add_ku(v5, 1);
  }
LABEL_7:
  if ((a1 & 2) != 0)
  {
    add_ku(v5, 4);
    if ((a1 & 4) == 0) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  if ((a1 & 4) != 0) {
LABEL_9:
  }
    add_ku(v5, 8);
LABEL_10:
  if ((a1 & 0x38) != 0) {
    add_ku(v5, 16);
  }
  if (a2) {
    CFDictionaryAddValue(v5, @"Email", a2);
  }
  add_eku(v5, 0);
  add_eku(v5, (const UInt8 *)&oidExtendedKeyUsageEmailProtection);
  CFDictionaryAddValue(v5, @"EmailProtectionEKU", (const void *)*MEMORY[0x1E4F1CFD0]);
  int v6 = CFArrayCreateMutable(0, 2, MEMORY[0x1E4F1D510]);
  CFDateRef v7 = CFDateCreate(0, 670464000.0);
  uint64_t valuePtr = 0x4198690600000000;
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
  CFArrayAppendValue(v6, v7);
  CFArrayAppendValue(v6, v8);
  if (v7) {
    CFRelease(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  CFStringRef v9 = CFArrayCreateMutable(0, 1, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue(v9, v6);
  if (v6) {
    CFRelease(v6);
  }
  CFDictionaryAddValue(v5, @"SystemTrustValidityPeriod", v9);
  if (v9) {
    CFRelease(v9);
  }
  if (SecPolicyAddStrongKeySizeOptions(v5) && SecPolicyRemoveWeakHashOptions(v5)) {
    CFIndex v10 = SecPolicyCreate(@"1.2.840.113635.100.1.8", @"SMIME", v5);
  }
  else {
    CFIndex v10 = 0;
  }
  CFRelease(v5);
  return v10;
}

__CFDictionary *SecPolicyCreateEAP(int a1, const void *a2)
{
  uint64_t result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (result)
  {
    CFDictionaryRef v5 = result;
    SecPolicyAddBasicX509Options(result);
    int v6 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFDictionaryAddValue(v5, @"NoNetworkAccess", (const void *)*MEMORY[0x1E4F1CFD0]);
    if (a2) {
      CFDictionaryAddValue(v5, @"EAPTrustedServerNames", a2);
    }
    if (a1)
    {
      CFDictionaryAddValue(v5, @"SystemTrustedWeakHash", v6);
      CFDictionaryAddValue(v5, @"SystemTrustedWeakKey", v6);
    }
    BOOL v7 = a1 != 0;
    if (a1) {
      CFNumberRef v8 = @"eapServer";
    }
    else {
      CFNumberRef v8 = @"eapClient";
    }
    set_ssl_ekus(v5, v7);
    CFStringRef v9 = SecPolicyCreate(@"1.2.840.113635.100.1.9", v8, v5);
    CFRelease(v5);
    return (__CFDictionary *)v9;
  }
  return result;
}

__CFDictionary *SecPolicyCreateIPSec(int a1, const void *a2)
{
  uint64_t result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (result)
  {
    CFDictionaryRef v5 = result;
    SecPolicyAddBasicX509Options(result);
    if (a2) {
      CFDictionaryAddValue(v5, @"SSLHostname", a2);
    }
    if (a1) {
      int v6 = @"ipsecServer";
    }
    else {
      int v6 = @"ipsecClient";
    }
    BOOL v7 = SecPolicyCreate(@"1.2.840.113635.100.1.11", v6, v5);
    CFRelease(v5);
    return (__CFDictionary *)v7;
  }
  return result;
}

void *SecPolicyCreateMacAppStoreReceipt()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    add_element(v1, @"CertificatePolicy", @"1.2.840.113635.100.5.6.1");
    add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.1");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.11.1");
    CFDictionaryAddValue(v1, @"Revocation", @"AnyRevocationMethod");
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.19", @"MacAppStoreReceipt", v1);
  }
  else
  {
    CFTypeRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

SecPolicyRef SecPolicyCreateRevocation(CFOptionFlags revocationFlags)
{
  CFOptionFlags v1 = revocationFlags;
  if (!revocationFlags) {
    return (SecPolicyRef)v1;
  }
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFHashCode v3 = Mutable;
  CFHashCode v4 = (const void **)MEMORY[0x1E4F1CFD0];
  if ((v1 & 0x40) != 0)
  {
    CFDictionaryAddValue(Mutable, @"RevocationIfTrusted", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionaryAddValue(v3, @"Revocation", @"AnyRevocationMethod");
  }
  if ((v1 & 0x20) != 0)
  {
    CFDictionaryAddValue(v3, @"RevocationOnline", *v4);
    CFDictionaryAddValue(v3, @"Revocation", @"AnyRevocationMethod");
  }
  if ((v1 & 3) == 3)
  {
    CFDictionaryRef v5 = @"AnyRevocationMethod";
  }
  else
  {
    if (v1) {
      CFDictionaryRef v5 = @"OCSP";
    }
    else {
      CFDictionaryRef v5 = @"CRL";
    }
    if ((v1 & 3) == 0) {
      goto LABEL_14;
    }
  }
  CFDictionaryAddValue(v3, @"Revocation", v5);
LABEL_14:
  int v6 = *v4;
  if ((v1 & 8) != 0) {
    CFDictionaryAddValue(v3, @"RevocationResponseRequired", v6);
  }
  if ((v1 & 0x10) != 0) {
    BOOL v7 = v6;
  }
  else {
    BOOL v7 = (const void *)*MEMORY[0x1E4F1CFC8];
  }
  CFDictionaryAddValue(v3, @"NoNetworkAccess", v7);
  if (v1 > 0x7F) {
    CFOptionFlags v1 = 0;
  }
  else {
    CFOptionFlags v1 = (CFOptionFlags)SecPolicyCreate(@"1.2.840.113635.100.1.21", @"revocation", v3);
  }
  CFRelease(v3);
  return (SecPolicyRef)v1;
}

void *SecPolicyCreateAppleSSLPinned(const void *a1, const __CFString *a2, const __CFString *a3, __CFString *a4)
{
  SSL_internal = 0;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1 && a2 && a4)
  {
    if (requireUATPinning((uint64_t)a1))
    {
      CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        CFDictionaryRef v10 = Mutable;
        SecPolicyAddBasicX509Options(Mutable);
        if (!SecPolicyAddAppleAnchorOptions(v10) || !SecPolicyAddChainLengthOptions(v10, 3)) {
          goto LABEL_23;
        }
        if (a3)
        {
          if ((isAppleOid(a3) & 1) == 0)
          {
            CFTypeID v11 = secLogObjForScope("SecWarning");
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              int v16 = 138412290;
              CFStringRef v17 = a3;
              _os_log_impl(&dword_18B299000, v11, OS_LOG_TYPE_DEFAULT, "creating an Apple pinning policy with a non-Apple OID: %@", (uint8_t *)&v16, 0xCu);
            }
          }
          CFDictionaryRef v12 = v10;
          CFIndex v13 = (__CFString *)a3;
        }
        else
        {
          CFIndex v13 = @"1.2.840.113635.100.6.2.12";
          CFDictionaryRef v12 = v10;
        }
        add_element(v12, @"IntermediateMarkerOid", v13);
        if ((isAppleOid(a4) & 1) == 0)
        {
          CFStringRef v14 = secLogObjForScope("SecWarning");
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            int v16 = 138412290;
            CFStringRef v17 = a4;
            _os_log_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEFAULT, "creating an Apple pinning policy with a non-Apple OID: %@", (uint8_t *)&v16, 0xCu);
          }
        }
        add_element(v10, @"LeafMarkerOid", a4);
        add_leaf_marker_value_string(v10, @"1.2.840.113635.100.6.48.1", a4);
        add_element(v10, @"ExtendedKeyUsage", @"1.3.6.1.5.5.7.3.1");
        add_element(v10, @"SSLHostname", a2);
        if (SecPolicyAddStrongKeySizeOptions(v10) && SecPolicyRemoveWeakHashOptions(v10))
        {
          add_element(v10, @"Revocation", @"AnyRevocationMethod");
          SSL_internal = SecPolicyCreate(@"1.2.840.113635.100.1.63", a1, v10);
        }
        else
        {
LABEL_23:
          SSL_internal = 0;
        }
        CFRelease(v10);
      }
      else
      {
        return 0;
      }
    }
    else
    {
      SSL_internal = SecPolicyCreateSSL_internal(1, a2, 0, 0);
      SecPolicySetOid((uint64_t)SSL_internal, @"1.2.840.113635.100.1.63");
      SecPolicySetName((uint64_t)SSL_internal, a1);
    }
  }
  return SSL_internal;
}

void *SecPolicyCreateAppleUniqueDeviceCertificate(const void *a1)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v4 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAnchorSHA256Options(v4, SEPRootCA_SHA256)) {
    goto LABEL_16;
  }
  if (a1 && os_variant_allows_internal_security_policies() && CFDataGetLength((CFDataRef)a1) == 32) {
    add_element(v4, @"AnchorSHA256", a1);
  }
  if (!SecPolicyAddChainLengthOptions(v4, 3)) {
    goto LABEL_16;
  }
  values = @"ucrt";
  keys[0] = @"1.2.840.113635.100.6.44";
  CFDictionaryRef v5 = CFDictionaryCreate(v2, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  add_element(v4, @"IntermediateMarkerOid", v5);
  if (v5) {
    CFRelease(v5);
  }
  add_element(v4, @"LeafMarkerOidWithoutValueCheck", @"1.2.840.113635.100.10.1");
  keys[0] = (void *)256;
  CFTypeRef cf = CFNumberCreate(0, kCFNumberCFIndexType, keys);
  if (cf
    && (CFDictionaryRef v6 = CFDictionaryCreate(0, (const void **)&kSecAttrKeyTypeEC, &cf, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])) != 0)
  {
    CFDictionaryRef v7 = v6;
    add_element(v4, @"KeySize", v6);
    CFNumberRef v8 = SecPolicyCreate(@"1.2.840.113635.100.1.72", @"UCRT", v4);
    CFRelease(v4);
    CFDictionaryRef v4 = v7;
  }
  else
  {
LABEL_16:
    CFNumberRef v8 = 0;
  }
  CFRelease(v4);
  if (cf) {
    CFRelease(cf);
  }
  return v8;
}

void *SecPolicyCreateAppleBasicAttestationSystem(const void *a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFHashCode v3 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v3, @"ValidLeaf", (const void *)*MEMORY[0x1E4F1CFD0]);
  SecPolicyAddAnchorSHA256Options(v3, BASystemRootCA_SHA256);
  if (a1 && os_variant_allows_internal_security_policies() && CFDataGetLength((CFDataRef)a1) == 32) {
    add_element(v3, @"AnchorSHA256", a1);
  }
  if (SecPolicyAddChainLengthOptions(v3, 3)) {
    CFDictionaryRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.84", @"BAA-SCRT", v3);
  }
  else {
    CFDictionaryRef v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateAppleBasicAttestationUser(const void *a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFHashCode v3 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v3, @"ValidLeaf", (const void *)*MEMORY[0x1E4F1CFD0]);
  SecPolicyAddAnchorSHA256Options(v3, BAUserRootCA_SHA256);
  if (a1 && os_variant_allows_internal_security_policies() && CFDataGetLength((CFDataRef)a1) == 32) {
    add_element(v3, @"AnchorSHA256", a1);
  }
  if (SecPolicyAddChainLengthOptions(v3, 3)) {
    CFDictionaryRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.85", @"BAA-UCRT", v3);
  }
  else {
    CFDictionaryRef v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateAppleComponentCertificate(const void *a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v3 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  SecPolicyAddAnchorSHA256Options(v3, ComponentRootCA_SHA256);
  if (a1 && os_variant_allows_internal_security_policies() && CFDataGetLength((CFDataRef)a1) == 32) {
    add_element(v3, @"AnchorSHA256", a1);
  }
  if (SecPolicyAddChainLengthOptions(v3, 3))
  {
    add_element(v3, @"LeafMarkerOidWithoutValueCheck", @"1.2.840.113635.100.11.1");
    add_element(v3, @"IntermediateMarkerOidWithoutValueCheck", @"1.2.840.113635.100.11.1");
    CFDictionaryRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.92", @"Component", v3);
  }
  else
  {
    CFDictionaryRef v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateAggregateMetricTransparency(int a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3)
    && ((add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.26"), !a1)
      ? (CFDictionaryRef v4 = @"1.2.840.113635.100.12.18")
      : (CFDictionaryRef v4 = @"1.2.840.113635.100.12.17"),
        add_element(v3, @"LeafMarkerOidWithoutValueCheck", v4),
        add_element(v3, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v3)))
  {
    if (!os_variant_allows_internal_security_policies()
      || !CFPreferencesGetAppBooleanValue(@"disableAggregateMetricsCTCheck", @"com.apple.security", 0))
    {
      add_element(v3, @"CTRequired", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    CFDictionaryRef v5 = SecPolicyCreate(@"1.2.840.113635.100.1.102", @"AggregateMetricTransparency", v3);
  }
  else
  {
    CFDictionaryRef v5 = 0;
  }
  CFRelease(v3);
  return v5;
}

void *SecPolicyCreateAggregateMetricEncryption(int a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3)
    && ((add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.26"), !a1)
      ? (CFDictionaryRef v4 = @"1.2.840.113635.100.15.3")
      : (CFDictionaryRef v4 = @"1.2.840.113635.100.15.2"),
        add_element(v3, @"LeafMarkerOid", v4),
        add_element(v3, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v3)))
  {
    if (!os_variant_allows_internal_security_policies()
      || !CFPreferencesGetAppBooleanValue(@"disableAggregateMetricsCTCheck", @"com.apple.security", 0))
    {
      add_element(v3, @"NonTlsCTRequired", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    CFDictionaryRef v5 = SecPolicyCreate(@"1.2.840.113635.100.1.106", @"AggregateMetricEncryption", v3);
  }
  else
  {
    CFDictionaryRef v5 = 0;
  }
  CFRelease(v3);
  return v5;
}

void *SecPolicyCreateApplePayModelSigning(int a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v3 = Mutable;
  if (a1) {
    SecPolicyAddBasicX509Options(Mutable);
  }
  else {
    SecPolicyAddBasicCertOptions(Mutable);
  }
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3)
    && (add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.17"),
        add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.12.20"),
        add_element(v3, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v3)))
  {
    CFDictionaryRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.107", @"ApplePayModelSigning", v3);
  }
  else
  {
    CFDictionaryRef v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateMDLTerminalAuth(int a1, int a2)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v5 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  add_ku(v5, 1);
  if (a1) {
    add_element(v5, @"ExtendedKeyUsage", @"1.0.18013.5.1.6");
  }
  if (a2) {
    add_element(v5, @"BasicConstraintsCA", (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  if (SecPolicyAddStrongKeySizeOptions(v5)
    && SecPolicyRemoveWeakHashOptions(v5)
    && (CFDataRef Value = (__CFArray *)CFDictionaryGetValue(v5, @"SignatureHashAlgorithms")) != 0)
  {
    CFArrayAppendValue(Value, @"SignatureDigestSHA224");
    CFDictionaryRef v7 = SecPolicyCreate(@"1.2.840.113635.100.1.108", @"MDLTerminalAuth", v5);
  }
  else
  {
    CFDictionaryRef v7 = 0;
  }
  CFRelease(v5);
  return v7;
}

void *SecPolicyCreatePPMAggregatorConfigSigning(int a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3)
    && ((add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.26"), !a1)
      ? (CFDictionaryRef v4 = @"1.2.840.113635.100.14.3")
      : (CFDictionaryRef v4 = @"1.2.840.113635.100.12.44"),
        add_element(v3, @"LeafMarkerOid", v4),
        add_element(v3, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v3)))
  {
    if (!os_variant_allows_internal_security_policies()
      || !CFPreferencesGetAppBooleanValue(@"disableAggregateMetricsCTCheck", @"com.apple.security", 0))
    {
      add_element(v3, @"NonTlsCTRequired", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    CFDictionaryRef v5 = SecPolicyCreate(@"1.2.840.113635.100.1.112", @"PPMAggregatorConfigSigning", v3);
  }
  else
  {
    CFDictionaryRef v5 = 0;
  }
  CFRelease(v3);
  return v5;
}

void *SecPolicyCreateiAPAuthV4(int a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v3 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  switch(a1)
  {
    case 1:
      CFDictionaryRef v4 = @"Apple Accessories Certification Authority - ";
      break;
    case 3:
      CFDictionaryAddValue(v3, @"IssuerCommonNamePrefix", @"Apple Accessories Provisioning Authority - ");
      goto LABEL_9;
    case 2:
      CFDictionaryRef v4 = @"Apple Accessory Host Attestation Authority - ";
      break;
    default:
      CFDictionaryRef v5 = 0;
      goto LABEL_11;
  }
  CFDictionaryAddValue(v3, @"IssuerCommonNamePrefix", v4);
  add_element(v3, @"LeafMarkerOidWithoutValueCheck", @"1.2.840.113635.100.6.71.1");
LABEL_9:
  CFDictionaryRef v5 = SecPolicyCreate(@"1.2.840.113635.100.1.117", @"iAPAuthV4", v3);
LABEL_11:
  CFRelease(v3);
  return v5;
}

void *SecPolicyCreateParakeetCommon(const void *a1, const void *a2, const void *a3, const void *a4)
{
  values = 0;
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v9 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v9, 3))
  {
    uint64_t valuePtr = 256;
    values = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
    if (values)
    {
      CFDictionaryRef v10 = CFDictionaryCreate(0, (const void **)&kSecAttrKeyTypeEC, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v10)
      {
        CFDictionaryRef v11 = v10;
        add_element(v9, @"KeySize", v10);
        if (!SecPolicyRemoveWeakHashOptions(v9)
          || (CFDataRef Value = (__CFArray *)CFDictionaryGetValue(v9, @"SignatureHashAlgorithms")) == 0)
        {
          int v26 = 0;
          goto LABEL_30;
        }
        CFRange v29 = a3;
        CFArrayAppendValue(Value, @"SignatureDigestSHA224");
        add_ku(v9, 16);
        CFIndex v13 = (const void *)*MEMORY[0x1E4F1CFD0];
        CFDictionarySetValue(v9, @"NotCA", (const void *)*MEMORY[0x1E4F1CFD0]);
        CFStringRef v14 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
        BOOL v15 = CFArrayCreateMutable(0, 1, MEMORY[0x1E4F1D510]);
        int v16 = CFArrayCreateMutable(0, 2, v14);
        uint64_t valuePtr = 0x4158674400000000;
        CFDateRef v17 = CFDateCreate(0, 0.0);
        CFNumberRef v18 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
        CFArrayAppendValue(v16, v17);
        CFArrayAppendValue(v16, v18);
        if (v17) {
          CFRelease(v17);
        }
        if (v18) {
          CFRelease(v18);
        }
        CFArrayAppendValue(v15, v16);
        if (v16) {
          CFRelease(v16);
        }
        CFDictionaryAddValue(v9, @"SystemTrustValidityPeriod", v15);
        CFDictionaryAddValue(v9, @"OtherTrustValidityPeriod", v15);
        if (v15) {
          CFRelease(v15);
        }
        CFDictionaryAddValue(v9, @"NoNetworkAccess", v13);
        if (a1) {
          CFDictionaryAddValue(v9, @"SSLHostname", a1);
        }
        if (a2)
        {
          CFTypeID v19 = CFGetTypeID(a2);
          if (v19 == CFDictionaryGetTypeID())
          {
            double Current = CFAbsoluteTimeGetCurrent();
            CFTypeID v21 = CFDictionaryGetValue((CFDictionaryRef)a2, @"verify");
            if (v21)
            {
              CFArrayRef v22 = v21;
              CFTypeID v23 = CFGetTypeID(v21);
              if (v23 == CFDateGetTypeID()) {
                double Current = MEMORY[0x18C12C760](v22);
              }
            }
            CFIndex v24 = CFDictionaryGetValue((CFDictionaryRef)a2, @"fresh");
            if (v13 && v24)
            {
              if (!CFEqual(v24, v13)) {
                goto LABEL_29;
              }
LABEL_27:
              CFDateRef v25 = CFDateCreate(0, Current + -172800.0);
              CFDictionaryAddValue(v9, @"NotValidBefore", v25);
              if (v25) {
                CFRelease(v25);
              }
              goto LABEL_29;
            }
            if (v24 == v13) {
              goto LABEL_27;
            }
          }
        }
LABEL_29:
        int v26 = SecPolicyCreate(v29, a4, v9);
LABEL_30:
        CFRelease(v9);
        goto LABEL_31;
      }
    }
  }
  int v26 = 0;
  CFDictionaryRef v11 = v9;
LABEL_31:
  CFRelease(v11);
  CFRange v27 = values;
  if (values)
  {
    values = 0;
    CFRelease(v27);
  }
  return v26;
}

void *SecPolicyCreateAppleSWUpdateSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3) && SecPolicyAddAppleAnchorOptions(v1))
  {
    add_eku(v1, oidAppleExtendedKeyUsageCodeSigning);
    add_oid(v1, @"IntermediateEKU", _oidAppleExtendedKeyUsageCodeSigning, 9);
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.10", @"AppleSWUpdateSigning", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateCodeSigning()
{
  uint64_t result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (result)
  {
    CFDictionaryRef v1 = result;
    SecPolicyAddBasicX509Options(result);
    add_ku(v1, 1);
    add_ku(v1, 2);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
    add_eku(v1, (const UInt8 *)&oidAnyExtendedKeyUsage);
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.16", @"CodeSigning", v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }
  return result;
}

void *SecPolicyCreateApplePackageSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3) && SecPolicyAddAppleAnchorOptions(v1))
  {
    add_ku(v1, 1);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.17", @"PackageSigning", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleIDAuthorityPolicy()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1))
  {
    add_leaf_marker_value(v1, (uint64_t)&oidAppleExtendedKeyUsageAppleID, 0);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleID, 10);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleID2, 10);
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.61", @"AppleIDAuthority", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateAppleTimeStamping()
{
  uint64_t result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (result)
  {
    CFDictionaryRef v1 = result;
    SecPolicyAddBasicX509Options(result);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageTimeStamping);
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.20", @"AppleTimeStamping", v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }
  return result;
}

void *CreateMobileStoreSigner(int a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v4 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (a1) {
    CFDictionaryRef v5 = @"AppleTestMobileStore";
  }
  else {
    CFDictionaryRef v5 = @"AppleMobileStore";
  }
  if (SecPolicyAddAppleAnchorOptions(v4) && SecPolicyAddChainLengthOptions(v4, 3))
  {
    CFDictionaryAddValue(v4, @"IssuerCommonName", @"Apple System Integration 2 Certification Authority");
    add_ku(v4, 1);
    CFDictionaryRef v6 = (const UInt8 **)&oidApplePolicyMobileStore;
    CFDictionaryRef v7 = (CFIndex *)&unk_1E5475350;
    if (a1) {
      CFDictionaryRef v7 = (CFIndex *)&unk_1E5475360;
    }
    if ((*v7 & 0x8000000000000000) == 0)
    {
      if (a1) {
        CFDictionaryRef v6 = (const UInt8 **)&oidApplePolicyMobileStoreProdQA;
      }
      CFDataRef v8 = CFDataCreate(v2, *v6, *v7);
      if (v8)
      {
        CFDataRef v9 = v8;
        add_element(v4, @"CertificatePolicy", v8);
        CFRelease(v9);
      }
    }
    if (a1) {
      CFDictionaryRef v10 = @"1.2.840.113635.100.1.27";
    }
    else {
      CFDictionaryRef v10 = @"1.2.840.113635.100.1.23";
    }
    CFDictionaryRef v11 = SecPolicyCreate(v10, v5, v4);
  }
  else
  {
    CFDictionaryRef v11 = 0;
  }
  CFRelease(v4);
  return v11;
}

void *SecPolicyCreateEscrowServiceSigner()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  add_ku(v1, 4);
  add_element(v1, @"LeafMarkerOidWithoutValueCheck", @"1.2.840.113635.100.6.23.1");
  if (SecPolicyAddChainLengthOptions(v1, 2)) {
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.24", @"AppleEscrowService", v1);
  }
  else {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateConfigurationProfileSigner()
{
  uint64_t v0 = (const void *)MGCopyAnswer();
  CFDictionaryRef v1 = v0;
  if (v0) {
    CFRelease(v0);
  }

  return SecPolicyCreatePrivacyConfigurationProfileSigner(1, v1 != 0);
}

void *SecPolicyCreateAppleIDValidationRecordSigningPolicy()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1))
  {
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtensionAppleIDRecordValidationSigning, 0);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleID, 10);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleSystemIntg2, 10);
    CFDictionaryAddValue(v1, @"Revocation", @"OCSP");
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.30", @"AppleIDValidationRecordSigningPolicy", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleIDValidationShortcutSigningPolicy()
{
  AppleIDValidationRecordSigningPolicy = SecPolicyCreateAppleIDValidationRecordSigningPolicy();
  CFDictionaryRef v1 = AppleIDValidationRecordSigningPolicy;
  if (AppleIDValidationRecordSigningPolicy)
  {
    CFAllocatorRef v2 = (__CFDictionary *)AppleIDValidationRecordSigningPolicy[4];
    if (v2) {
      CFDictionaryRemoveValue(v2, @"TemporalValidity");
    }
  }
  return v1;
}

void *SecPolicyCreateAppleSMPEncryption()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtAppleSMPEncryption, 0);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleSystemIntgG3, 10);
    add_ku(v1, 4);
    CFDictionaryAddValue(v1, @"Revocation", @"OCSP");
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.31", @"AppleSMPEncryption", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateTestAppleSMPEncryption()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  SecPolicyAddAnchorSHA256Options(v1, kTestAppleRootCA_ECC_SHA256);
  if (SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, @"IssuerCommonName", @"Test Apple System Integration CA - ECC");
    add_ku(v1, 4);
    CFDictionaryAddValue(v1, @"Revocation", @"OCSP");
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.32", @"AppleTestSMPEncryption", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

const void *SecPolicyCreateAppleSSLService(const __CFString *a1)
{
  SSL_internal = SecPolicyCreateSSL_internal(1, a1, 0, 0);
  CFAllocatorRef v2 = SSL_internal;
  if (SSL_internal)
  {
    CFDictionaryRef v3 = (const __CFDictionary *)SSL_internal[4];
    if (v3)
    {
      if (SecPolicyAddAppleAnchorOptions((const __CFDictionary *)SSL_internal[4]))
      {
        add_leaf_marker_value(v3, (uint64_t)&oidAppleCertExtAppleServerAuthentication, 0);
        add_oid(v3, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleServerAuthentication, 10);
        if (SecPolicyRemoveWeakHashOptions(v3))
        {
          CFDictionaryAddValue(v3, @"Revocation", @"AnyRevocationMethod");
          SecPolicySetOid((uint64_t)v2, @"1.2.840.113635.100.1.33");
          SecPolicySetName((uint64_t)v2, @"AppleSSLService");
          return v2;
        }
      }
      CFRelease(v3);
    }
    CFRelease(v2);
    return 0;
  }
  return v2;
}

void *SecPolicyCreatePCSEscrowServiceSigner()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  add_ku(v1, 4);
  add_element(v1, @"LeafMarkerOidWithoutValueCheck", @"1.2.840.113635.100.6.23.1");
  if (SecPolicyAddChainLengthOptions(v1, 2)) {
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.34", @"ApplePCSEscrowService", v1);
  }
  else {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateApplePPQSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  SecPolicyAddAppleAnchorOptions(v1);
  if (SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple System Integration 2 Certification Authority");
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtApplePPQSigningProd, 0);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleSystemIntg2, 10);
    add_ku(v1, 1);
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.35", @"ApplePPQSigning", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateTestApplePPQSigning()
{
  if (os_variant_allows_internal_security_policies())
  {
    CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!Mutable) {
      return 0;
    }
    CFDictionaryRef v1 = Mutable;
    SecPolicyAddBasicCertOptions(Mutable);
    SecPolicyAddAppleAnchorOptions(v1);
    if (SecPolicyAddChainLengthOptions(v1, 3))
    {
      CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple System Integration 2 Certification Authority");
      add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtApplePPQSigningProdQA, 0);
      add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleSystemIntg2, 10);
      add_ku(v1, 1);
      CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.36", @"AppleTestPPQSigning", v1);
    }
    else
    {
      CFAllocatorRef v2 = 0;
    }
    CFRelease(v1);
    return v2;
  }
  else
  {
    return SecPolicyCreateApplePPQSigning();
  }
}

void *SecPolicyCreateApplePayIssuerEncryption()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple Worldwide Developer Relations CA - G2");
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtCryptoServicesExtEncryption, 0);
    add_ku(v1, 4);
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.39", @"ApplePayIssuerEncryption", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateOSXProvisioningProfileSigning()
{
  uint64_t result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (result)
  {
    CFDictionaryRef v1 = result;
    SecPolicyAddBasicX509Options(result);
    SecPolicyAddAppleAnchorOptions(v1);
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtOSXProvisioningProfileSigning, 0);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleWWDR, 10);
    add_ku(v1, 1);
    CFDictionaryAddValue(v1, @"Revocation", @"OCSP");
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.40", @"AppleOSXProvisioningProfileSigning", v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }
  return result;
}

void *SecPolicyCreateAppleATVVPNProfileSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFMutableDictionaryRef v2 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v2)
  {
    CFDictionaryRef v3 = v2;
    if (os_variant_allows_internal_security_policies()) {
      CFDictionarySetValue(v3, @"AnchorAppleTestRoots", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    add_element(v1, @"AnchorApple", v3);
    if (SecPolicyAddChainLengthOptions(v1, 3))
    {
      add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtATVVPNProfileSigning, 0);
      add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleSystemIntg2, 10);
      CFDictionaryAddValue(v1, @"Revocation", @"OCSP");
      CFDictionaryRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.41", @"AppleATVVPNProfileSigning", v1);
    }
    else
    {
      CFDictionaryRef v4 = 0;
    }
    CFRelease(v1);
  }
  else
  {
    CFDictionaryRef v4 = 0;
    CFDictionaryRef v3 = v1;
  }
  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateAppleHomeKitServerAuth(const void *a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  CFDictionaryAddValue(v3, @"SSLHostname", a1);
  add_eku(v3, (const UInt8 *)&oidExtendedKeyUsageServerAuth);
  if (requireUATPinning(@"HomeKit"))
  {
    if (!SecPolicyAddChainLengthOptions(v3, 3))
    {
LABEL_10:
      CFDictionaryRef v4 = 0;
      goto LABEL_8;
    }
    SecPolicyAddAppleAnchorOptions(v3);
    add_leaf_marker_value(v3, (uint64_t)&oidAppleCertExtHomeKitServerAuth, 0);
    add_oid(v3, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleHomeKitServerCA, 10);
  }
  if (!SecPolicyRemoveWeakHashOptions(v3) || !SecPolicyAddStrongKeySizeOptions(v3)) {
    goto LABEL_10;
  }
  CFDictionaryAddValue(v3, @"Revocation", @"AnyRevocationMethod");
  CFDictionaryRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.48", @"HomeKit", v3);
LABEL_8:
  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateiPhoneActivation()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Certification Authority");
  CFDictionaryAddValue(v1, @"SubjectCommonName", @"Apple iPhone Activation");
  if (SecPolicyAddChainLengthOptions(v1, 3) && SecPolicyAddAppleAnchorOptions(v1))
  {
    CFDictionaryAddValue(v1, @"RevocationDbIgnored", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFMutableDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.49", @"iPhoneActivation", v1);
  }
  else
  {
    CFMutableDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiPhoneDeviceCertificate()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Device CA");
  if (SecPolicyAddChainLengthOptions(v1, 4) && SecPolicyAddAppleAnchorOptions(v1))
  {
    CFDictionaryAddValue(v1, @"RevocationDbIgnored", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFMutableDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.50", @"iPhoneDeviceCertificate", v1);
  }
  else
  {
    CFMutableDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateFactoryDeviceCertificate()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAnchorSHA256Options(v1, kFactoryDeviceCASHA256)) {
    CFMutableDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.51", @"FactoryDeviceCertificate", v1);
  }
  else {
    CFMutableDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiAP()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, @"SubjectCommonNamePrefix", @"IPA_");
  CFDateRef v2 = CFDateCreate(0, 170726400.0);
  CFDictionaryAddValue(v1, @"NotValidBefore", v2);
  CFDictionaryAddValue(v1, @"RevocationDbIgnored", (const void *)*MEMORY[0x1E4F1CFD0]);
  CFDictionaryRef v3 = SecPolicyCreate(@"1.2.840.113635.100.1.52", @"iAP", v1);
  if (v2) {
    CFRelease(v2);
  }
  CFRelease(v1);
  return v3;
}

void *SecPolicyCreateiTunesStoreURLBag()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, @"SubjectOrganization", @"Apple Inc.");
  CFDictionaryAddValue(v1, @"SubjectCommonName", @"iTunes Store URL Bag");
  if (SecPolicyAddChainLengthOptions(v1, 2) && SecPolicyAddAnchorSHA256Options(v1, kITMS_CA_SHA256)) {
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.53", @"iTunesStoreURLBag", v1);
  }
  else {
    CFDateRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiPhoneApplicationSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAppleAnchorOptions(v1)) {
    goto LABEL_10;
  }
  if (os_variant_allows_internal_security_policies())
  {
    CFDictionaryAddValue(v1, @"SubjectCommonNameTEST", @"Apple iPhone OS Application Signing");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.3.1");
  }
  else
  {
    CFDictionaryAddValue(v1, @"SubjectCommonName", @"Apple iPhone OS Application Signing");
  }
  add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.3");
  add_eku(v1, 0);
  add_eku(v1, (const UInt8 *)&oidAnyExtendedKeyUsage);
  add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
  CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Certification Authority");
  if (SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, @"NoNetworkAccess", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.54", @"iPhoneApplicationSigning", v1);
  }
  else
  {
LABEL_10:
    CFDateRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiPhoneProfileApplicationSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    add_element(v1, @"ExtendedKeyUsage", @"1.3.6.1.5.5.7.3.3");
    add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.1");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.2");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.4");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.25.1");
    if (os_variant_allows_internal_security_policies()) {
      add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.25.2");
    }
    CFDictionaryAddValue(v1, @"Revocation", @"AnyRevocationMethod");
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.55", @"iPhoneProfileApplicationSigning", v1);
  }
  else
  {
    CFDateRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiPhoneProvisioningProfileSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Certification Authority");
  if (os_variant_allows_internal_security_policies()) {
    CFDateRef v2 = @"SubjectCommonNameTEST";
  }
  else {
    CFDateRef v2 = @"SubjectCommonName";
  }
  CFDictionaryAddValue(v1, v2, @"Apple iPhone OS Provisioning Profile Signing");
  if (SecPolicyAddChainLengthOptions(v1, 3) && SecPolicyAddAppleAnchorOptions(v1))
  {
    CFDictionaryAddValue(v1, @"NoNetworkAccess", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionaryRef v3 = SecPolicyCreate(@"1.2.840.113635.100.1.56", @"iPhoneProvisioningProfileSigning", v1);
  }
  else
  {
    CFDictionaryRef v3 = 0;
  }
  CFRelease(v1);
  return v3;
}

__CFDictionary *SecPolicyCreateURLBag()
{
  uint64_t result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (result)
  {
    CFDictionaryRef v1 = result;
    SecPolicyAddBasicCertOptions(result);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.58", @"URLBag", v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }
  return result;
}

void *SecPolicyCreateOTATasking()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Certification Authority");
    CFDictionaryAddValue(v1, @"SubjectCommonName", @"OTA Task Signing");
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.59", @"OTATasking", v1);
  }
  else
  {
    CFDateRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateMobileAsset()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Certification Authority");
    CFDictionaryAddValue(v1, @"SubjectCommonName", @"Asset Manifest Signing");
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.60", @"MobileAsset", v1);
  }
  else
  {
    CFDateRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleSoftwareSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, @"IssuerCommonName", @"Apple Code Signing Certification Authority"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.22"),
        add_element(v1, @"ExtendedKeyUsage", @"1.3.6.1.5.5.7.3.3"),
        add_element(v1, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.64", @"SoftwareSigning", v1);
  }
  else
  {
    CFDateRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleExternalDeveloperOptionalExpiry(int a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v3 = Mutable;
  if (a1) {
    SecPolicyAddBasicX509Options(Mutable);
  }
  else {
    SecPolicyAddBasicCertOptions(Mutable);
  }
  if (!SecPolicyAddAppleAnchorOptions(v3)) {
    goto LABEL_11;
  }
  if (!SecPolicyAddChainLengthOptions(v3, 3)) {
    goto LABEL_11;
  }
  add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.1");
  add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.6");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.2");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.4");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.5");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.7");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.8");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.12");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.13");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.14");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.35");
  add_element(v3, @"ExtendedKeyUsage", @"1.3.6.1.5.5.7.3.3");
  add_element(v3, @"ExtendedKeyUsage", @"1.2.840.113635.100.4.8");
  add_element(v3, @"ExtendedKeyUsage", @"1.2.840.113635.100.4.9");
  add_element(v3, @"ExtendedKeyUsage", @"1.2.840.113635.100.4.13");
  add_element(v3, @"Revocation", @"AnyRevocationMethod");
  if (SecPolicyAddStrongKeySizeOptions(v3)) {
    CFDictionaryRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.65", @"Developer", v3);
  }
  else {
LABEL_11:
  }
    CFDictionaryRef v4 = 0;
  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateApplePushServiceLegacy(const void *a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef v3 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], entrustSPKIL1C, 32, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (!v3) {
    return 0;
  }
  CFDataRef v4 = v3;
  CFMutableStringRef Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFDictionaryRef v6 = Mutable;
    SecPolicyAddBasicX509Options(Mutable);
    CFDictionaryAddValue(v6, @"SSLHostname", a1);
    CFDictionaryRef v7 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFDictionaryAddValue(v6, @"BlackListedLeaf", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionaryAddValue(v6, @"GrayListedLeaf", v7);
    CFDictionaryAddValue(v6, @"IntermediateSPKISHA256", v4);
    add_eku(v6, (const UInt8 *)&oidExtendedKeyUsageServerAuth);
    if (SecPolicyRemoveWeakHashOptions(v6) && SecPolicyAddStrongKeySizeOptions(v6))
    {
      CFDictionaryAddValue(v6, @"Revocation", @"AnyRevocationMethod");
      CFDataRef v8 = SecPolicyCreate(@"1.2.840.113635.100.1.70", @"AppleLegacyPushService", v6);
    }
    else
    {
      CFDataRef v8 = 0;
    }
    CFRelease(v4);
  }
  else
  {
    CFDataRef v8 = 0;
    CFDictionaryRef v6 = v4;
  }
  CFRelease(v6);
  return v8;
}

void *SecPolicyCreateAppleTVOSApplicationSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3) && SecPolicyAddAppleAnchorOptions(v1))
  {
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleWWDR, 10);
    add_ku(v1, 1);
    add_leaf_marker_value(v1, (uint64_t)&oidAppleTVOSApplicationSigningProd, 0);
    add_leaf_marker_value(v1, (uint64_t)&oidAppleTVOSApplicationSigningProdQA, 0);
    CFDictionaryAddValue(v1, @"NoNetworkAccess", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.71", @"AppleTVApplicationSigning", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleGeoTrustServerAuthCommon(const void *a1, const void *a2, const void *a3, void *a4, void *a5)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v11 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (!a1) {
    goto LABEL_13;
  }
  CFDictionaryAddValue(v11, @"SSLHostname", a1);
  add_eku(v11, (const UInt8 *)&oidExtendedKeyUsageServerAuth);
  if (requireUATPinning((uint64_t)a3))
  {
    SecPolicyAddAnchorSHA256Options(v11, GeoTrust_Global_CA_sha256);
    add_element(v11, @"IntermediateCountry", @"US");
    add_element(v11, @"IntermediateOrganization", @"Apple Inc.");
    if (!SecPolicyAddChainLengthOptions(v11, 3))
    {
LABEL_13:
      CFDictionaryRef v12 = 0;
      goto LABEL_11;
    }
    if (a5)
    {
      add_leaf_prod_qa_element(v11, a4, a5);
      add_leaf_prod_qa_markers_value_string(v11, a4, a5);
    }
    else
    {
      add_element(v11, @"LeafMarkerOid", a4);
      add_leaf_marker_value_string(v11, @"1.2.840.113635.100.6.48.1", a4);
    }
  }
  if (!SecPolicyRemoveWeakHashOptions(v11) || !SecPolicyAddStrongKeySizeOptions(v11)) {
    goto LABEL_13;
  }
  CFDictionaryRef v12 = SecPolicyCreate(a2, a3, v11);
LABEL_11:
  CFRelease(v11);
  return v12;
}

void *SecPolicyCreateAppleSecureIOStaticAsset()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.10"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.50"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.75", @"SecureIOStaticAsset", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleWarsaw()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.14"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.29"),
        add_element(v1, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.76", @"Warsaw", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

__CFArray *SecPolicyCreateAppleAppTransportSecurity()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  if (SecPolicyAddStrongKeySizeOptions(Mutable))
  {
    CFAllocatorRef v2 = CFArrayCreateMutable(0, 5, MEMORY[0x1E4F1D510]);
    CFDataRef v3 = v2;
    if (v2)
    {
      CFArrayAppendValue(v2, @"SignatureDigestMD2");
      CFArrayAppendValue(v3, @"SignatureDigestMD4");
      CFArrayAppendValue(v3, @"SignatureDigestMD5");
      CFArrayAppendValue(v3, @"SignatureDigestSHA1");
      CFArrayAppendValue(v3, @"SignatureDigestSHA224");
      add_element(v1, @"SignatureHashAlgorithms", v3);
      CFDataRef v3 = (__CFArray *)SecPolicyCreate(@"1.2.840.113635.100.1.80", @"ATS", v1);
    }
  }
  else
  {
    CFDataRef v3 = 0;
  }
  CFRelease(v1);
  return v3;
}

void *SecPolicyCreateMacOSProfileApplicationSigning()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    add_element(v1, @"ExtendedKeyUsage", @"1.3.6.1.5.5.7.3.3");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.12");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.7");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.13");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.22");
    CFDictionaryAddValue(v1, @"Revocation", @"AnyRevocationMethod");
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.81", @"macOSProfileApplicationSigning", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateMobileSoftwareUpdate()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAppleAnchorOptions(v1) || !SecPolicyAddChainLengthOptions(v1, 3)) {
    goto LABEL_10;
  }
  add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.18");
  add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.57.2");
  if (os_variant_allows_internal_security_policies()) {
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.57.1");
  }
  if (SecPolicyAddStrongKeySizeOptions(v1)) {
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.82", @"MobileSoftwareUpdate", v1);
  }
  else {
LABEL_10:
  }
    CFAllocatorRef v2 = 0;
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateMobileAssetDevelopment()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.18");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.55.1");
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.83", @"MobileAsset", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiPhoneVPNApplicationSigning()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAppleAnchorOptions(v1)) {
    goto LABEL_10;
  }
  if (os_variant_allows_internal_security_policies())
  {
    CFDictionaryAddValue(v1, @"SubjectCommonNameTEST", @"Apple iPhone OS Application Signing");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.6.1");
  }
  else
  {
    CFDictionaryAddValue(v1, @"SubjectCommonName", @"Apple iPhone OS Application Signing");
  }
  add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.6");
  add_eku(v1, 0);
  add_eku(v1, (const UInt8 *)&oidAnyExtendedKeyUsage);
  add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
  CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Certification Authority");
  if (SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, @"NoNetworkAccess", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.86", @"iPhoneVPNApplicationSigning", v1);
  }
  else
  {
LABEL_10:
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiAPSWAuthWithExpiration(int a1)
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v3 = Mutable;
  if (a1) {
    SecPolicyAddBasicX509Options(Mutable);
  }
  else {
    SecPolicyAddBasicCertOptions(Mutable);
  }
  if (SecPolicyAddChainLengthOptions(v3, 2))
  {
    add_element(v3, @"LeafMarkerOidWithoutValueCheck", @"1.2.840.113635.100.6.59.1");
    CFDictionaryAddValue(v3, @"RevocationDbIgnored", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDataRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.87", @"iAPSWAuth", v3);
  }
  else
  {
    CFDataRef v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateDemoDigitalCatalogSigning()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3))
  {
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.60");
    add_element(v1, @"IssuerCommonName", @"DemoUnit CA");
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.88", @"DemoCatalog", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleAssetReceipt()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.10"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.61"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.89", @"AssetReceipt", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleDeveloperIDPlusTicket()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.17"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.30"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.90", @"DeveloperIDPlusTicket", v1);
  }
  else
  {
    CFAllocatorRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateAppleFDRProvisioning()
{
  uint64_t result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (result)
  {
    CFDictionaryRef v1 = result;
    SecPolicyAddBasicCertOptions(result);
    CFAllocatorRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.91", @"FDRProvisioning", v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }
  return result;
}

void *SecPolicyCreateAppleKeyTransparency(void *a1)
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v3 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3)
    && (add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.3"),
        add_leaf_marker_value_string(v3, @"1.2.840.113635.100.12.4", a1),
        SecPolicyAddStrongKeySizeOptions(v3))
    && SecPolicyRemoveWeakHashOptions(v3))
  {
    CFDataRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.93", @"KT", v3);
  }
  else
  {
    CFDataRef v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateAlisha()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  uint64_t valuePtr = 256;
  uint64_t valuePtr = (uint64_t)CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
  if (valuePtr
    && (CFDictionaryRef v2 = CFDictionaryCreate(0, (const void **)&kSecAttrKeyTypeEC, (const void **)&valuePtr, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])) != 0)
  {
    CFDictionaryRef v3 = v2;
    add_element(v1, @"KeySize", v2);
    if (SecPolicyRemoveWeakHashOptions(v1)) {
      CFDataRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.95", @"Alisha", v1);
    }
    else {
      CFDataRef v4 = 0;
    }
    CFRelease(v1);
  }
  else
  {
    CFDataRef v4 = 0;
    CFDictionaryRef v3 = v1;
  }
  CFRelease(v3);
  CFDictionaryRef v5 = (const void *)valuePtr;
  if (valuePtr)
  {
    uint64_t valuePtr = 0;
    CFRelease(v5);
  }
  return v4;
}

void *SecPolicyCreateMeasuredBootPolicySigning()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.24.17"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.26.6.1"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.96", @"MeasuredBootPolicySigning", v1);
  }
  else
  {
    CFDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateApplePayQRCodeEncryption()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.22"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.13.3"),
        SecPolicyAddStrongKeySizeOptions(v1))
    && SecPolicyAddAnchorSHA256Options(v1, AppleExternalECRoot_SHA256)
    && (!os_variant_allows_internal_security_policies()
     || SecPolicyAddAnchorSHA256Options(v1, TestAppleExternalECRoot_SHA256)))
  {
    add_element(v1, @"Revocation", @"AnyRevocationMethod");
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.97", @"ApplePayQRCodeEncryption", v1);
  }
  else
  {
    CFDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateApplePayQRCodeSigning()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.22"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.12.12"),
        SecPolicyAddStrongKeySizeOptions(v1))
    && SecPolicyAddAnchorSHA256Options(v1, AppleExternalECRoot_SHA256)
    && (!os_variant_allows_internal_security_policies()
     || SecPolicyAddAnchorSHA256Options(v1, TestAppleExternalECRoot_SHA256)))
  {
    add_element(v1, @"Revocation", @"AnyRevocationMethod");
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.98", @"ApplePayQRCodeSigning", v1);
  }
  else
  {
    CFDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleAccessoryUpdateSigning()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddChainLengthOptions(v1, 3) || !SecPolicyAddAppleAnchorOptions(v1)) {
    goto LABEL_10;
  }
  add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.17");
  add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.12.9");
  if (CFPreferencesGetAppBooleanValue(@"AllowAccessoryUpdateSigningBeta", @"com.apple.security", 0)) {
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.12.10");
  }
  if (SecPolicyAddStrongKeySizeOptions(v1))
  {
    add_element(v1, @"Revocation", @"AnyRevocationMethod");
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.99", @"AccessoryUpdateSigning", v1);
  }
  else
  {
LABEL_10:
    CFDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateEscrowServiceIdKeySigning()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  add_ku(v1, 1);
  CFDictionaryAddValue(v1, @"SubjectCommonName", @"Escrow Service ID Key");
  if (SecPolicyAddChainLengthOptions(v1, 2)) {
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.100", @"AppleEscrowServiceIdKeySigning", v1);
  }
  else {
    CFDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreatePCSEscrowServiceIdKeySigning()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  add_ku(v1, 1);
  CFDictionaryAddValue(v1, @"SubjectCommonName", @"Effaceable Service ID Key");
  if (SecPolicyAddChainLengthOptions(v1, 2)) {
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.101", @"ApplePCSEscrowServiceIdKeySigning", v1);
  }
  else {
    CFDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateDeveloperIDInstaller()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.6"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.14"),
        add_element(v1, @"ExtendedKeyUsage", @"1.2.840.113635.100.4.13"),
        add_element(v1, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.103", @"DeveloperIDInstaller", v1);
  }
  else
  {
    CFDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateMacAppStoreInstaller()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.1"),
        add_leaf_prod_qa_element(v1, @"1.2.840.113635.100.6.1.10", @"1.2.840.113635.100.6.1.10.1"),
        add_element(v1, @"ExtendedKeyUsage", @"1.2.840.113635.100.4.10"),
        add_element(v1, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.104", @"MacAppStoreInstaller", v1);
  }
  else
  {
    CFDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleCHIPUpdateSigning()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddChainLengthOptions(v1, 3) || !SecPolicyAddAppleAnchorOptions(v1)) {
    goto LABEL_10;
  }
  add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.17");
  add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.12.25");
  if (CFPreferencesGetAppBooleanValue(@"AllowCHIPUpdateSigningBeta", @"com.apple.security", 0)) {
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.12.26");
  }
  if (SecPolicyAddStrongKeySizeOptions(v1))
  {
    add_element(v1, @"Revocation", @"AnyRevocationMethod");
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.109", @"CHIPUpdateSigning", v1);
  }
  else
  {
LABEL_10:
    CFDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateOrderBundleSigner(void *a1)
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3) && SecPolicyAddChainLengthOptions(v3, 3))
  {
    add_leaf_marker_value_string(v3, @"1.2.840.113635.100.14.2", a1);
    add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.1");
    add_element(v3, @"ExtendedKeyUsage", @"1.2.840.113635.100.4.19");
    add_element(v3, @"Revocation", @"AnyRevocationMethod");
    CFDataRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.110", @"OrderBundleSigner", v3);
  }
  else
  {
    CFDataRef v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

__CFDictionary *SecPolicyCreateQiSigning()
{
  uint64_t result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (result)
  {
    CFDictionaryRef v1 = result;
    SecPolicyAddBasicCertOptions(result);
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.111", @"QiSigning", v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }
  return result;
}

void *SecPolicyCreateAppleXROSApplicationSigning()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3) && SecPolicyAddAppleAnchorOptions(v1))
  {
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleWWDR, 10);
    add_ku(v1, 1);
    add_eku(v1, (const UInt8 *)&oidAnyExtendedKeyUsage);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.36");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.36.1");
    CFDictionaryAddValue(v1, @"NoNetworkAccess", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.113", @"AppleXROSApplicationSigning", v1);
  }
  else
  {
    CFDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateEDPSigning()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAppleAnchorOptions(v1) || !SecPolicyAddChainLengthOptions(v1, 3)) {
    goto LABEL_10;
  }
  add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.17");
  if (os_variant_allows_internal_security_policies()) {
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.12.48");
  }
  add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.12.47");
  if (SecPolicyAddStrongKeySizeOptions(v1))
  {
    CFDictionaryAddValue(v1, @"NoNetworkAccess", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.114", @"EDPSigning", v1);
  }
  else
  {
LABEL_10:
    CFDictionaryRef v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateDCAttestation()
{
  uint64_t result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (result)
  {
    CFDictionaryRef v1 = result;
    SecPolicyAddBasicCertOptions(result);
    CFDictionaryRef v2 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFDictionaryAddValue(v1, @"ValidLeaf", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionaryAddValue(v1, @"NoNetworkAccess", v2);
    CFDictionaryRef v3 = SecPolicyCreate(@"1.2.840.113635.100.1.119", @"DCAttestation", v1);
    CFRelease(v1);
    return (__CFDictionary *)v3;
  }
  return result;
}

void add_leaf_marker_value_string(const __CFDictionary *a1, void *a2, void *a3)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  if (a3)
  {
    values = a3;
    keys[0] = a2;
    CFDictionaryRef v4 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    add_element(a1, @"LeafMarkerOid", v4);
    if (v4) {
      CFRelease(v4);
    }
  }
  else
  {
    add_element(a1, @"LeafMarkerOid", a2);
  }
}

BOOL SecPolicyAddAnchorSHA256Options(const __CFDictionary *a1, const UInt8 *a2)
{
  CFDataRef v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 32);
  if (v3)
  {
    add_element(a1, @"AnchorSHA256", v3);
    CFRelease(v3);
  }
  return v3 != 0;
}

void SecPolicySetOid(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    if (cf)
    {
      CFDictionaryRef v4 = *(const void **)(a1 + 16);
      CFRetain(cf);
      *(void *)(a1 + 16) = cf;
      if (v4)
      {
        CFRelease(v4);
      }
    }
  }
}

void *SecPolicyCreatePrivacyConfigurationProfileSigner(int a1, int a2)
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v5 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v5))
  {
    BOOL v6 = SecPolicyAddChainLengthOptions(v5, 3);
    CFDictionaryRef v7 = 0;
    if ((a1 | a2) == 1 && v6)
    {
      if (a1) {
        add_eku(v5, oidAppleExtendedKeyUsageProfileSigning);
      }
      if (a2) {
        add_eku(v5, oidAppleExtendedKeyUsageQAProfileSigning);
      }
      add_element(v5, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.3");
      CFDictionaryRef v7 = SecPolicyCreate(@"1.2.840.113635.100.1.25", @"AppleProfileSigner", v5);
    }
  }
  else
  {
    CFDictionaryRef v7 = 0;
  }
  CFRelease(v5);
  return v7;
}

CFMutableArrayRef parseNSPinnedDomains(const __CFDictionary *a1, const __CFString *a2, uint64_t a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v11 = 0;
  CFDictionaryRef v12 = &v11;
  uint64_t v13 = 0x2000000000;
  char v14 = 0;
  CFIndex Length = CFStringGetLength(a2);
  CFIndex v8 = Length - 1;
  if (Length >= 1 && CFStringGetCharacterAtIndex(a2, v8) == 46)
  {
    v15.location = 0;
    v15.CFIndex length = v8;
    a2 = CFStringCreateWithSubstring(0, a2, v15);
    if (!a2) {
      goto LABEL_9;
    }
  }
  else if (a2)
  {
    CFRetain(a2);
  }
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 0x40000000;
  _OWORD v10[2] = __parseNSPinnedDomains_block_invoke;
  unint64_t v10[3] = &unk_1E54829F0;
  UInt8 v10[4] = &v11;
  void v10[5] = a2;
  void v10[6] = a3;
  void v10[7] = Mutable;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)apply_block_2_13374, v10);
  if (a2) {
    CFRelease(a2);
  }
LABEL_9:
  if (!*((unsigned char *)v12 + 24) && Mutable)
  {
    CFRelease(Mutable);
    CFMutableArrayRef Mutable = 0;
  }
  _Block_object_dispose(&v11, 8);
  return Mutable;
}

void __parseNSPinnedDomains_block_invoke(uint64_t a1, const __CFString *cf, const void *a3)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    CFTypeID TypeID = CFStringGetTypeID();
    if (a3)
    {
      if (v6 == TypeID)
      {
        CFTypeID v8 = CFGetTypeID(a3);
        if (v8 == CFDictionaryGetTypeID())
        {
          if (CFStringCompare(cf, *(CFStringRef *)(a1 + 40), 1uLL))
          {
            if (CFDictionaryGetValue((CFDictionaryRef)a3, @"NSIncludesSubdomains") != (const void *)*MEMORY[0x1E4F1CFD0]) {
              return;
            }
            CFStringRef v9 = *(const __CFString **)(a1 + 40);
            if (!v9) {
              return;
            }
            CFIndex Length = CFStringGetLength(*(CFStringRef *)(a1 + 40));
            if (!Length) {
              return;
            }
            CFIndex v11 = Length;
            CFIndex location = CFStringFind(v9, @".", 0).location;
            if (location == -1) {
              return;
            }
            if (location >= v11 - 1) {
              return;
            }
            v20.CFIndex location = location + 1;
            v20.CFIndex length = v11 + ~location;
            CFStringRef v13 = CFStringCreateWithSubstring(0, v9, v20);
            if (!v13) {
              return;
            }
            CFStringRef v14 = v13;
            if (CFStringCompare(cf, v13, 1uLL))
            {
LABEL_19:
              CFRelease(v14);
              return;
            }
          }
          else
          {
            CFStringRef v14 = 0;
          }
          CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a3, *(const void **)(a1 + 48));
          if (Value)
          {
            CFArrayRef v16 = Value;
            *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
            CFTypeID v17 = CFGetTypeID(Value);
            if (v17 == CFArrayGetTypeID())
            {
              context[0] = MEMORY[0x1E4F143A8];
              context[1] = 0x40000000;
              context[2] = __parseNSPinnedDomains_block_invoke_2;
              context[3] = &__block_descriptor_tmp_736;
              void context[4] = *(void *)(a1 + 56);
              v19.CFIndex length = CFArrayGetCount(v16);
              v19.CFIndex location = 0;
              CFArrayApplyFunction(v16, v19, (CFArrayApplierFunction)apply_block_1_13376, context);
            }
          }
          if (v14) {
            goto LABEL_19;
          }
        }
      }
    }
  }
}

uint64_t apply_block_2_13374(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void __parseNSPinnedDomains_block_invoke_2(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID())
    {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"SPKI-SHA256-BASE64");
      if (Value)
      {
        CFStringRef v6 = Value;
        CFTypeID v7 = CFGetTypeID(Value);
        if (v7 == CFStringGetTypeID())
        {
          CFDataFromBase64CFString = (const void *)CreateCFDataFromBase64CFString(v6);
          if (CFDataFromBase64CFString)
          {
            CFStringRef v9 = CFDataFromBase64CFString;
            CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), CFDataFromBase64CFString);
            CFRelease(v9);
          }
        }
      }
    }
  }
}

uint64_t apply_block_1_13376(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t CreateCFDataFromBase64CFString(const __CFString *a1)
{
  uint64_t v4 = 0;
  CFDictionaryRef v5 = &v4;
  uint64_t v6 = 0x2000000000;
  uint64_t v7 = 0;
  if (a1)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 0x40000000;
    v3[2] = __CreateCFDataFromBase64CFString_block_invoke;
    v3[3] = &unk_1E54829A8;
    void v3[4] = &v4;
    CFStringPerformWithCStringAndLength(a1, (uint64_t)v3);
    uint64_t v1 = v5[3];
  }
  else
  {
    uint64_t v1 = 0;
  }
  _Block_object_dispose(&v4, 8);
  return v1;
}

void __CreateCFDataFromBase64CFString_block_invoke(uint64_t a1, unsigned __int8 *a2, unint64_t a3)
{
  CFDataRef v3 = 0;
  if (a2 && a3)
  {
    unint64_t v5 = a3 >> 2;
    if ((a3 & 3) != 0) {
      ++v5;
    }
    if (v5)
    {
      unint64_t v8 = 3 * v5;
      CFDataRef v3 = (UInt8 *)malloc_type_malloc(3 * v5, 0x110C4DAuLL);
      if (v3)
      {
        CFStringRef v9 = SecBase64Decode_(a2, a3, v3, v8, 0, &v11, &v10);
        if ((unint64_t)(v9 - 0x7FFFFFFFFFFFFFFFLL) >= 0x8000000000000002) {
          *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v3, (CFIndex)v9);
        }
      }
    }
    else
    {
      CFDataRef v3 = 0;
    }
  }

  free(v3);
}

void *SecPolicyCreateAppleAST2Service(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, @"1.2.840.113635.100.1.42", @"AST2", (uint64_t)&oidAppleCertExtAST2DiagnosticsServerAuthProd, (uint64_t)&oidAppleCertExtAST2DiagnosticsServerAuthProdQA);
}

void *SecPolicyCreateAppleEscrowProxyService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, @"1.2.840.113635.100.1.43", @"Escrow", (uint64_t)&oidAppleCertExtEscrowProxyServerAuthProd, (uint64_t)&oidAppleCertExtEscrowProxyServerAuthProdQA);
}

void *SecPolicyCreateAppleFMiPService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, @"1.2.840.113635.100.1.44", @"FMiP", (uint64_t)&oidAppleCertExtFMiPServerAuthProd, (uint64_t)&oidAppleCertExtFMiPServerAuthProdQA);
}

void *SecPolicyCreateAppleMMCSService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, @"1.2.840.113635.100.1.45", @"MMCS", (uint64_t)&oidAppleCertExtAppleServerAuthenticationMMCSProd, (uint64_t)&oidAppleCertExtAppleServerAuthenticationMMCSProdQA);
}

void *SecPolicyCreateAppleGSService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, @"1.2.840.113635.100.1.46", @"GS", (uint64_t)&oidAppleCertExtAppleServerAuthenticationGS, 0);
}

void *SecPolicyCreateApplePPQService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, @"1.2.840.113635.100.1.47", @"PPQ", (uint64_t)&oidAppleCertExtAppleServerAuthenticationPPQProd, (uint64_t)&oidAppleCertExtAppleServerAuthenticationPPQProdQA);
}

void *SecPolicyCreateAppleIDSServiceContext(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, @"1.2.840.113635.100.1.68", @"IDS", (uint64_t)&oidAppleCertExtAppleServerAuthenticationIDSProd, (uint64_t)&oidAppleCertExtAppleServerAuthenticationIDSProdQA);
}

void *SecPolicyCreateApplePushService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, @"1.2.840.113635.100.1.69", @"APN", (uint64_t)&oidAppleCertExtAppleServerAuthenticationAPNProd, (uint64_t)&oidAppleCertExtAppleServerAuthenticationAPNProdQA);
}

void *SecPolicyCreateAppleiCloudSetupService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, @"1.2.840.113635.100.1.77", @"iCloudSetup", (uint64_t)&oidAppleCertExtAppleServerAuthenticationiCloudSetupProd, (uint64_t)&oidAppleCertExtAppleServerAuthenticationiCloudSetupProdQA);
}

void *SecPolicyCreateParakeetService(const void *a1, const void *a2)
{
  return SecPolicyCreateParakeetCommon(a1, a2, @"1.2.840.113635.100.1.118", @"ParakeetService");
}

void *SecPolicyCreateMobileStoreSigner()
{
  return CreateMobileStoreSigner(0);
}

void *SecPolicyCreateTestMobileStoreSigner()
{
  return CreateMobileStoreSigner(1);
}

void *SecPolicyCreateAppleExternalDeveloper()
{
  return SecPolicyCreateAppleExternalDeveloperOptionalExpiry(1);
}

void *SecPolicyCreateAppleCompatibilityEscrowProxyService(const void *a1)
{
  return SecPolicyCreateAppleGeoTrustServerAuthCommon(a1, @"1.2.840.113635.100.1.73", @"Escrow", @"1.2.840.113635.100.6.27.7.2", @"1.2.840.113635.100.6.27.7.1");
}

void *SecPolicyCreateAppleCompatibilityMMCSService(const void *a1)
{
  return SecPolicyCreateAppleGeoTrustServerAuthCommon(a1, @"1.2.840.113635.100.1.74", @"MMCS", @"1.2.840.113635.100.6.27.11.2", @"1.2.840.113635.100.6.27.11.1");
}

void *SecPolicyCreateAppleCompatibilityiCloudSetupService(const void *a1)
{
  return SecPolicyCreateAppleGeoTrustServerAuthCommon(a1, @"1.2.840.113635.100.1.78", @"iCloudSetup", @"1.2.840.113635.100.6.27.15.2", @"1.2.840.113635.100.6.27.15.1");
}

void *SecPolicyCreateiAPSWAuth()
{
  return SecPolicyCreateiAPSWAuthWithExpiration(0);
}

void *SecPolicyCreateMacDistributionInstaller()
{
  return SecPolicyCreateApplePinned(@"MacDistributionInstaller", @"1.2.840.113635.100.6.2.1", @"1.2.840.113635.100.6.1.8");
}

void *SecPolicyCreateParakeetSigning()
{
  return SecPolicyCreateParakeetCommon(0, 0, @"1.2.840.113635.100.1.116", @"ParakeetSigning");
}

CFDictionaryRef SecPolicyCopyProperties(SecPolicyRef policyRef)
{
  if (!policyRef) {
    return 0;
  }
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFTypeRef v3 = CFRetain(*((CFTypeRef *)policyRef + 2));
    CFDictionaryRef v4 = (const __CFDictionary *)*((void *)policyRef + 4);
    if (v4)
    {
      unint64_t v5 = @"SSLHostname";
      if (CFDictionaryContainsKey(v4, @"SSLHostname")
        || (unint64_t v5 = @"EAPTrustedServerNames",
            CFDictionaryContainsKey(*((CFDictionaryRef *)policyRef + 4), @"EAPTrustedServerNames")))
      {
        CFDictionarySetValue(Mutable, @"SecPolicyOid", v3);
      }
      else
      {
        unint64_t v5 = @"Email";
        int v13 = CFDictionaryContainsKey(*((CFDictionaryRef *)policyRef + 4), @"Email");
        CFDictionarySetValue(Mutable, @"SecPolicyOid", v3);
        if (!v13) {
          goto LABEL_13;
        }
      }
      CFDictionaryRef v6 = (const __CFDictionary *)*((void *)policyRef + 4);
      if (!v6) {
        goto LABEL_13;
      }
      CFStringRef Value = CFDictionaryGetValue(v6, v5);
      if (!Value) {
        goto LABEL_13;
      }
      unint64_t v8 = Value;
      CFStringRef v9 = @"SecPolicyName";
      int v10 = Mutable;
    }
    else
    {
      CFStringRef v9 = @"SecPolicyOid";
      int v10 = Mutable;
      unint64_t v8 = v3;
    }
    CFDictionarySetValue(v10, v9, v8);
LABEL_13:
    CFIndex v11 = (const void *)*((void *)policyRef + 3);
    if (v11)
    {
      CFRetain(v11);
      if (CFEqual(v11, @"sslClient") || CFEqual(v11, @"ipsecClient") || CFEqual(v11, @"eapClient")) {
        CFDictionarySetValue(Mutable, @"SecPolicyClient", (const void *)*MEMORY[0x1E4F1CFD0]);
      }
      CFRelease(v11);
    }
    CFRelease(v3);
  }
  return Mutable;
}

uint64_t SecPolicyGetOidString(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void deserializePolicy(const void *a1, __CFArray *a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFDictionaryGetTypeID())
    {
      CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)a1, @"SecPolicyOid");
      if (Value)
      {
        CFDictionaryRef v6 = Value;
        CFTypeID v7 = CFGetTypeID(Value);
        if (v7 == CFStringGetTypeID())
        {
          unint64_t v8 = CFDictionaryGetValue((CFDictionaryRef)a1, @"policyOptions");
          if (v8)
          {
            CFStringRef v9 = v8;
            CFTypeID v10 = CFGetTypeID(v8);
            if (v10 == CFDictionaryGetTypeID())
            {
              CFIndex v11 = CFDictionaryGetValue((CFDictionaryRef)a1, @"SecPolicyPolicyName");
              CFDictionaryRef v12 = SecPolicyCreate(v6, v11, v9);
              if (v12)
              {
                int v13 = v12;
                CFArrayAppendValue(a2, v12);
                CFRelease(v13);
              }
            }
          }
        }
      }
    }
  }
}

void SecPolicySetSHA256Pins(uint64_t a1, const void *a2, const void *a3)
{
  if (a1)
  {
    CFDictionaryRef v6 = *(__CFDictionary **)(a1 + 32);
    if (!v6)
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (!Mutable) {
        return;
      }
      CFDictionaryRef v6 = Mutable;
      *(void *)(a1 + 32) = Mutable;
    }
    CFDictionaryRemoveValue(v6, @"LeafSPKISHA256");
    if (a2) {
      add_element(v6, @"LeafSPKISHA256", a2);
    }
    CFDictionaryRemoveValue(v6, @"CAspkiSHA256");
    if (a3)
    {
      add_element(v6, @"CAspkiSHA256", a3);
    }
  }
}

void *SecPolicyCreateSSLWithATSPinning(int a1, const __CFString *a2, const __CFDictionary *a3)
{
  return SecPolicyCreateSSL_internal(a1, a2, 0, a3);
}

void *SecPolicyCreateVerifiedMark(const void *a1, const __CFData *a2)
{
  if (!a2) {
    return 0;
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0;
  }
  CFDictionaryRef v6 = Mutable;
  CFMutableDictionaryRef v7 = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v7)
  {
    CFRange v15 = 0;
    CFStringRef v14 = v6;
LABEL_14:
    CFRelease(v14);
    return v15;
  }
  unint64_t v8 = v7;
  SecPolicyAddBasicX509Options(v6);
  if (a1) {
    CFDictionaryAddValue(v6, @"SSLHostname", a1);
  }
  if (SecPolicyRemoveWeakHashOptions(v6) && SecPolicyAddStrongKeySizeOptions(v6))
  {
    add_element(v6, @"CertificatePolicy", @"1.3.6.1.4.1.53087.1.1");
    CFDictionaryAddValue(v6, @"SinglePurposeChainEKU", @"1.3.6.1.5.5.7.3.31");
    BytePtr = CFDataGetBytePtr(a2);
    CFIndex Length = CFDataGetLength(a2);
    CFIndex v11 = SecSHA1DigestCreate(v4, (uint64_t)BytePtr, Length);
    if (v11)
    {
      CFDictionaryRef v12 = CFDataGetBytePtr(a2);
      CFIndex v13 = CFDataGetLength(a2);
      CFStringRef v14 = SecSHA256DigestCreate(v4, (uint64_t)v12, v13);
      if (v14)
      {
        CFDictionaryAddValue(v8, @"sha1", v11);
        CFDictionaryAddValue(v8, @"sha256", v14);
        add_element(v6, @"MarkRepresentation", v8);
        CFRange v15 = SecPolicyCreate(@"1.2.840.113635.100.1.115", a1, v6);
      }
      else
      {
        CFRange v15 = 0;
      }
    }
    else
    {
      CFRange v15 = 0;
      CFStringRef v14 = 0;
    }
  }
  else
  {
    CFRange v15 = 0;
    CFStringRef v14 = 0;
    CFIndex v11 = 0;
  }
  CFRelease(v6);
  CFRelease(v8);
  if (v11) {
    CFRelease(v11);
  }
  if (v14) {
    goto LABEL_14;
  }
  return v15;
}

BOOL SecPolicyCheckCertCriticalExtensions(uint64_t a1)
{
  return !a1 || *(unsigned char *)(a1 + 296) == 0;
}

uint64_t SecDNSIsTLD(CFStringRef theString)
{
  if (SecDNSIsTLD_onceToken != -1) {
    dispatch_once(&SecDNSIsTLD_onceToken, &__block_literal_global_13384);
  }
  if (!SecDNSIsTLD_CFNIsDomainTopLevelFunctionPtr) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(theString);
  if (Length < 3) {
    return 1;
  }
  v6.CFIndex length = Length - 2;
  v6.CFIndex location = 2;
  uint64_t result = (uint64_t)CFStringCreateWithSubstring(0, theString, v6);
  if (result)
  {
    CFAllocatorRef v4 = (const void *)result;
    uint64_t v5 = SecDNSIsTLD_CFNIsDomainTopLevelFunctionPtr();
    CFRelease(v4);
    return v5;
  }
  return result;
}

void *__SecDNSIsTLD_block_invoke()
{
  uint64_t result = dlopen("/System/Library/Frameworks/CFNetwork.framework/CFNetwork", 1);
  if (result)
  {
    uint64_t result = dlsym(result, "_CFHostIsDomainTopLevelForCertificatePolicy");
    SecDNSIsTLD_CFNIsDomainTopLevelFunctionPtr = result;
  }
  return result;
}

BOOL SecPolicyCheckCertEmailSAN(uint64_t a1, const __CFString *cf, int a3)
{
  if (cf
    && (CFTypeID v6 = CFGetTypeID(cf), v6 == CFStringGetTypeID())
    && (!a3 ? (CFArrayRef v7 = SecCertificateCopyRFC822Names(a1)) : (CFArrayRef v7 = SecCertificateCopyRFC822NamesFromSAN(a1)),
        (CFArrayRef v8 = v7) != 0))
  {
    CFIndex Count = CFArrayGetCount(v7);
    if (Count < 1)
    {
      BOOL v12 = 0;
    }
    else
    {
      CFIndex v10 = Count;
      CFIndex v11 = 0;
      BOOL v12 = 1;
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v8, v11);
        if (CFStringCompare(cf, ValueAtIndex, 1uLL) == kCFCompareEqualTo) {
          break;
        }
        BOOL v12 = ++v11 < v10;
      }
      while (v10 != v11);
    }
    CFRelease(v8);
  }
  else
  {
    return 0;
  }
  return v12;
}

BOOL SecPolicyCheckCertEmail(uint64_t a1, const __CFString *a2)
{
  return SecPolicyCheckCertEmailSAN(a1, a2, 0);
}

BOOL SecPolicyCheckCertTemporalValidity(uint64_t a1, uint64_t a2)
{
  MEMORY[0x18C12C760](a2);
  return a1 && *(double *)(a1 + 168) <= v3 && *(double *)(a1 + 176) >= v3;
}

BOOL SecPolicyCheckCertValidLeaf(uint64_t a1, uint64_t a2)
{
  MEMORY[0x18C12C760](a2);
  return a1 && *(double *)(a1 + 168) <= v3 && *(double *)(a1 + 176) >= v3;
}

CFStringRef SecPolicyCheckCertSubjectCommonNamePrefix(uint64_t a1, const __CFString *cf)
{
  CFStringRef v2 = cf;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID() && (CFArrayRef v5 = SecCertificateCopyCommonNames(a1)) != 0)
    {
      CFArrayRef v6 = v5;
      CFStringRef v2 = (const __CFString *)(CFArrayGetCount(v5) == 1
                             && (CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, 0),
                                 CFStringHasPrefix(ValueAtIndex, v2)));
      CFRelease(v6);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

CFTypeRef SecPolicyCheckCertSubjectCommonName(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2 = cf;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID() && (CFArrayRef v5 = SecCertificateCopyCommonNames(a1)) != 0)
    {
      CFArrayRef v6 = v5;
      CFTypeRef v2 = (CFTypeRef)(CFArrayGetCount(v5) == 1
                    && (CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v6, 0), CFEqual(v2, ValueAtIndex)));
      CFRelease(v6);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t SecPolicyCheckCertSubjectCommonNameTEST(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2 = (uint64_t)cf;
  if (!cf) {
    return v2;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID()) {
    return 0;
  }
  CFArrayRef v5 = SecCertificateCopyCommonNames(a1);
  CFArrayRef v6 = v5;
  if (v5 && CFArrayGetCount(v5) == 1)
  {
    uint64_t v2 = 1;
LABEL_14:
    CFRelease(v6);
    return v2;
  }
  CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v6, 0);
  CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"TEST %@ TEST", v2);
  if (!CFEqual((CFTypeRef)v2, ValueAtIndex))
  {
    if (!v8)
    {
      uint64_t v2 = 0;
      if (!v6) {
        return v2;
      }
      goto LABEL_14;
    }
    uint64_t v2 = CFEqual(v8, ValueAtIndex) != 0;
    goto LABEL_12;
  }
  uint64_t v2 = 1;
  if (v8) {
LABEL_12:
  }
    CFRelease(v8);
  if (v6) {
    goto LABEL_14;
  }
  return v2;
}

BOOL SecPolicyCheckCertNotValidBefore(uint64_t a1, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  return v4 == CFDateGetTypeID() && *(double *)(a1 + 168) > MEMORY[0x18C12C760](cf);
}

CFTypeRef SecPolicyCheckCertSubjectOrganizationalUnit(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2 = cf;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID() && (CFArrayRef v5 = SecCertificateCopyOrganizationalUnit(a1)) != 0)
    {
      CFArrayRef v6 = v5;
      CFTypeRef v2 = (CFTypeRef)(CFArrayGetCount(v5) == 1
                    && (CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v6, 0), CFEqual(v2, ValueAtIndex)));
      CFRelease(v6);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t SecPolicyCheckCertEAPTrustedServerNames(uint64_t a1, CFTypeRef cf)
{
  if (!cf) {
    return 1;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFArrayGetTypeID()) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
  CFArrayRef v6 = SecCertificateCopyDNSNames(a1);
  if (!v6) {
    return 0;
  }
  CFArrayRef v7 = v6;
  CFIndex v8 = CFArrayGetCount(v6);
  if (v8 >= 1)
  {
    CFIndex v9 = v8;
    CFIndex v10 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, v10);
      if (Count >= 1) {
        break;
      }
LABEL_12:
      if (++v10 == v9) {
        goto LABEL_13;
      }
    }
    CFStringRef v12 = ValueAtIndex;
    CFIndex v13 = 0;
    while (1)
    {
      CFStringRef v14 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, v13);
      if (!v14) {
        break;
      }
      CFStringRef v15 = v14;
      CFTypeID v16 = CFGetTypeID(v14);
      if (v16 != CFStringGetTypeID()) {
        break;
      }
      if (SecDNSMatch(v12, v15))
      {
        uint64_t v17 = 1;
        goto LABEL_17;
      }
      if (Count == ++v13) {
        goto LABEL_12;
      }
    }
  }
LABEL_13:
  uint64_t v17 = 0;
LABEL_17:
  CFRelease(v7);
  return v17;
}

uint64_t SecPolicyCheckCertLeafMarkerOidWithoutValueCheck(uint64_t a1, const __CFString *a2)
{
  CFTypeID v4 = CFGetTypeID(a2);
  if (v4 != CFArrayGetTypeID())
  {
    CFTypeID v11 = CFGetTypeID(a2);
    if (v11 == CFDataGetTypeID()) {
      return SecCertificateGetExtensionValue(a1, a2) != 0;
    }
    CFTypeID v12 = CFGetTypeID(a2);
    if (v12 == CFStringGetTypeID()) {
      return SecCertificateGetExtensionValue(a1, a2) != 0;
    }
    return 0;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)a2);
  CFIndex v6 = Count - 1;
  if (Count < 1) {
    return 0;
  }
  CFIndex v7 = 0;
  do
  {
    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v7);
    uint64_t result = SecPolicyCheckCertLeafMarkerOidWithoutValueCheck(a1, ValueAtIndex);
    if (result) {
      break;
    }
  }
  while (v6 != v7++);
  return result;
}

uint64_t SecPolicyCheckCertLeafMarkersProdAndQA(uint64_t a1, CFDictionaryRef theDict)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"ProdMarker");
  if (Value && (SecCertificateHasMarkerExtension(a1, Value) & 1) != 0) {
    return 1;
  }
  uint64_t result = os_variant_allows_internal_security_policies();
  if (!result) {
    return result;
  }
  CFStringRef v6 = (const __CFString *)CFDictionaryGetValue(theDict, @"QAMarker");
  return v6 && (SecCertificateHasMarkerExtension(a1, v6) & 1) != 0;
}

BOOL SecPolicyCheckCertCertificatePolicy(uint64_t a1, const __CFString *cf)
{
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFDataGetTypeID())
  {
    return checkPolicyOidData(a1, cf);
  }
  else
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID() && (CFArrayRef OidDataFromString = SecCertificateCreateOidDataFromString(0, cf)) != 0)
    {
      CFArrayRef v8 = OidDataFromString;
      BOOL v9 = checkPolicyOidData(a1, OidDataFromString);
      CFRelease(v8);
      return v9;
    }
    else
    {
      return 0;
    }
  }
}

BOOL checkPolicyOidData(uint64_t a1, const void *a2)
{
  CFMutableSetRef Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
  if (!Mutable) {
    return 0;
  }
  CFArrayRef v5 = Mutable;
  if (*(unsigned char *)(a1 + 352)) {
    uint64_t v6 = a1 + 352;
  }
  else {
    uint64_t v6 = 0;
  }
  if (*(unsigned char *)(a1 + 352))
  {
    uint64_t v7 = *(void *)(v6 + 8);
    if (v7)
    {
      uint64_t v8 = 0;
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      do
      {
        uint64_t v10 = *(void *)(v6 + 16) + v8;
        CFIndex v11 = *(void *)(v10 + 8);
        if ((v11 & 0x8000000000000000) == 0)
        {
          CFDataRef v12 = CFDataCreate(v9, *(const UInt8 **)v10, v11);
          CFSetAddValue(v5, v12);
          if (v12) {
            CFRelease(v12);
          }
        }
        v8 += 32;
        --v7;
      }
      while (v7);
    }
  }
  BOOL v13 = CFSetContainsValue(v5, a2) != 0;
  CFRelease(v5);
  return v13;
}

BOOL SecPolicyCheckCertWeakKeySize(__SecCertificate *a1)
{
  return !a1 || (SecCertificateIsWeakKey(a1) & 1) == 0;
}

uint64_t SecPolicyCheckCertNotCA(uint64_t a1)
{
  return SecCertificateIsCA(a1) ^ 1;
}

void SecLeafPVCValidateKey(void *key, uint64_t a2, CFAbsoluteTime *a3)
{
  if (*((unsigned char *)a3 + 56) || *((void *)a3 + 3))
  {
    CFStringRef Value = (uint64_t (*)(void, CFDateRef))CFDictionaryGetValue(*((CFDictionaryRef *)a3 + 5), key);
    if (Value)
    {
      uint64_t v6 = Value;
      if (CFEqual(key, @"TemporalValidity") || CFEqual(key, @"ValidLeaf"))
      {
        CFDateRef v7 = CFDateCreate(0, a3[2]);
        if ((v6(*(void *)a3, v7) & 1) == 0) {
          SecLeafPVCSetResult((uint64_t)a3, key, (const void *)*MEMORY[0x1E4F1CFC8]);
        }
        if (v7)
        {
          CFRelease(v7);
        }
      }
      else
      {
        CFStringRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*((CFArrayRef *)a3 + 1), *((void *)a3 + 6));
        if (ValueAtIndex)
        {
          CFDateRef v9 = (const __CFDate *)CFDictionaryGetValue(ValueAtIndex[4], key);
          if ((v6(*(void *)a3, v9) & 1) == 0)
          {
            uint64_t v10 = (const void *)*MEMORY[0x1E4F1CFC8];
            SecLeafPVCSetResult((uint64_t)a3, key, v10);
          }
        }
        else
        {
          *((unsigned char *)a3 + 56) = 0;
        }
      }
    }
  }
}

void SecLeafPVCSetResult(uint64_t a1, const void *a2, const void *a3)
{
  CFStringRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 48));
  if (!ValueAtIndex || CFDictionaryContainsKey(ValueAtIndex[4], a2))
  {
    *(unsigned char *)(a1 + 56) = 0;
    CFArrayRef v7 = *(const __CFArray **)(a1 + 24);
    if (v7)
    {
      uint64_t v8 = (__CFDictionary *)CFArrayGetValueAtIndex(v7, 0);
      CFDictionarySetValue(v8, a2, a3);
    }
  }
}

__CFData *SecRSAPublicKeyCopyExternalRepresentation(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return SecRSAPublicKeyCreatePKCS1(v1);
}

CFStringRef SecRSAPublicKeyCopyDescription(void *a1)
{
  CFTypeRef v2 = SecKeyCopyModulus(a1);
  double v3 = (void *)a1[3];
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex Length = CFDataGetLength(v2);
  CFMutableSetRef Mutable = CFStringCreateMutable(v4, 2 * Length);
  BytePtr = CFDataGetBytePtr(v2);
  CFIndex v8 = CFDataGetLength(v2);
  if (v8 >= 1)
  {
    CFIndex v9 = v8;
    do
    {
      unsigned int v10 = *BytePtr++;
      CFStringAppendFormat(Mutable, 0, @"%02X", v10);
      --v9;
    }
    while (v9);
  }
  if (Mutable)
  {
    uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)a1);
    CFDataRef v12 = (unsigned int *)a1[2];
    uint64_t v13 = *((void *)v12 + 1);
    uint64_t v14 = *v12;
    uint64_t v15 = cczp_bitlen();
    _SecKeyCheck((uint64_t)a1, (uint64_t)"SecKeyGetBlockSize");
    CFTypeID v16 = *(uint64_t (**)(void *))(a1[2] + 80);
    if (v16) {
      uint64_t v17 = v16(a1);
    }
    else {
      uint64_t v17 = 0;
    }
    CFStringRef v18 = CFStringCreateWithFormat(v4, 0, @"<SecKeyRef algorithm id: %lu, key type: %s, version: %d, %d bits (block size: %zu), exponent: {hex: %llx, decimal: %lld}, modulus: %@, addr: %p>", AlgorithmId, v13, v14, v15, v17, v3[2 * *v3 + 4], v3[2 * *v3 + 4], Mutable, a1);
    if (v2) {
      goto LABEL_9;
    }
  }
  else
  {
    CFStringRef v18 = 0;
    if (v2) {
LABEL_9:
    }
      CFRelease(v2);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v18) {
    return v18;
  }
  uint64_t v20 = SecKeyGetAlgorithmId((uint64_t)a1);
  CFTypeID v21 = (unsigned int *)a1[2];
  uint64_t v22 = *((void *)v21 + 1);
  uint64_t v23 = *v21;
  _SecKeyCheck((uint64_t)a1, (uint64_t)"SecKeyGetBlockSize");
  CFIndex v24 = *(uint64_t (**)(void *))(a1[2] + 80);
  if (v24) {
    CFIndex v24 = (uint64_t (*)(void *))(8 * v24(a1));
  }
  return CFStringCreateWithFormat(v4, 0, @"<SecKeyRef algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>", v20, v22, v23, v24, a1);
}

__CFDictionary *SecRSAPublicKeyCopyAttributeDictionary(const void *a1)
{
  CFDictionaryRef v1 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, @"42", 0);
  CFDataRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v1);
  CFDictionarySetValue(MutableCopy, @"decr", (const void *)*MEMORY[0x1E4F1CFD0]);
  CFDictionarySetValue(MutableCopy, @"drve", (const void *)*MEMORY[0x1E4F1CFC8]);
  uint64_t valuePtr = cczp_bitlen();
  CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCFIndexType, &valuePtr);
  CFDictionarySetValue(MutableCopy, @"bsiz", v3);
  CFDictionarySetValue(MutableCopy, @"esiz", v3);
  if (v3) {
    CFRelease(v3);
  }
  if (v1) {
    CFRelease(v1);
  }
  return MutableCopy;
}

uint64_t ccrsa_pub_init(unint64_t *a1, uint64_t a2, unsigned char *a3)
{
  for (uint64_t i = a2; i; --i)
  {
    if (*a3) {
      break;
    }
    ++a3;
  }
  unint64_t v5 = (unint64_t)(i + 7) >> 3;
  if (v5 > *a1) {
    return 0xFFFFFFFFLL;
  }
  *a1 = v5;
  return MEMORY[0x1F40CB0E0]();
}

CFStringRef SecRSAPrivateKeyCopyDescription(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(a1);
  CFAllocatorRef v4 = *(unsigned int **)(a1 + 16);
  uint64_t v5 = *((void *)v4 + 1);
  uint64_t v6 = *v4;
  uint64_t v7 = cczp_bitlen();
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  CFIndex v8 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 80);
  if (v8) {
    uint64_t v9 = v8(a1);
  }
  else {
    uint64_t v9 = 0;
  }
  return CFStringCreateWithFormat(v2, 0, @"<SecKeyRef algorithm id: %lu, key type: %s, version: %d, %d bits (block size: %zu), addr: %p>", AlgorithmId, v5, v6, v7, v9, a1);
}

void *SecKeyCreateRSAPublicKey_ios(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SecKeyCreate(a1, (uint64_t)&kSecRSAPublicKeyDescriptor, a2, a3, a4);
}

uint64_t SecSCEPCreateTemporaryIdentity(uint64_t a1, __SecKey *a2)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  int valuePtr = 5;
  CFTypeRef cf = 0;
  CFTypeRef v17 = 0;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  if (!v4)
  {
    CFStringRef v9 = 0;
    uint64_t v14 = 0;
    goto LABEL_13;
  }
  CFNumberRef v5 = v4;
  values = v4;
  keys[0] = @"keyUsage";
  CFDictionaryRef v6 = CFDictionaryCreate(v3, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v6)
  {
    CFStringRef v9 = 0;
    uint64_t v14 = 0;
    CFArrayRef v12 = v5;
LABEL_12:
    CFRelease(v12);
    goto LABEL_13;
  }
  CFDictionaryRef v7 = v6;
  memset(cStr, 0, 37);
  memset(out, 170, sizeof(out));
  uuid_generate_random(out);
  uuid_unparse(out, cStr);
  CFStringRef v8 = CFStringCreateWithCString(v3, cStr, 0x600u);
  CFStringRef v9 = v8;
  if (!v8
    || (v19[0] = @"CN", v19[1] = (void *)v8, (CFTypeRef v17 = CFArrayCreate(v3, (const void **)v19, 2, 0)) == 0)
    || (CFTypeRef cf = CFArrayCreate(v3, &v17, 1, 0)) == 0)
  {
    CFArrayRef v12 = 0;
    goto LABEL_21;
  }
  CFArrayRef v10 = CFArrayCreate(v3, &cf, 1, 0);
  CFArrayRef v12 = v10;
  if (!v10)
  {
LABEL_21:
    uint64_t v14 = 0;
    SelfSignedCertificateWithError = 0;
    goto LABEL_9;
  }
  SelfSignedCertificateWithError = SecGenerateSelfSignedCertificateWithError(v10, v7, v11, a2, 0);
  if (SelfSignedCertificateWithError) {
    uint64_t v14 = SecIdentityCreate((int)v3, SelfSignedCertificateWithError, a2);
  }
  else {
    uint64_t v14 = 0;
  }
LABEL_9:
  CFRelease(v5);
  CFRelease(v7);
  if (SelfSignedCertificateWithError) {
    CFRelease(SelfSignedCertificateWithError);
  }
  if (v12) {
    goto LABEL_12;
  }
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v9) {
    CFRelease(v9);
  }
  return v14;
}

CFDictionaryRef SecSCEPGenerateCertificateRequest(const __CFArray *a1, const __CFDictionary *a2, CFMutableDataRef Mutable, __SecKey *a4, void *a5, const void *a6)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  values = 0;
  CFArrayRef v11 = filterRecipients(a6);
  CFTypeID v12 = CFGetTypeID(v11);
  CFStringRef ValueAtIndex = v11;
  if (v12 != SecCertificateGetTypeID())
  {
    CFTypeID v14 = CFGetTypeID(v11);
    if (v14 != CFArrayGetTypeID())
    {
LABEL_38:
      SecKeyRef v16 = 0;
      CFDictionaryRef v44 = 0;
      CFDataRef CertificateRequest = 0;
      SecKeyRef v15 = 0;
LABEL_39:
      CFMutableSetRef Mutable = 0;
      goto LABEL_54;
    }
    CFStringRef ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v11, 0);
  }
  if (!ValueAtIndex) {
    goto LABEL_38;
  }
  SecKeyRef v15 = SecCertificateCopyKey(ValueAtIndex);
  if (SecKeyGetAlgorithmId((uint64_t)v15) != 1)
  {
    SecKeyRef v16 = 0;
    CFDictionaryRef v44 = 0;
    CFDataRef CertificateRequest = 0;
    goto LABEL_39;
  }
  SecKeyRef v16 = SecKeyCopyPublicKey(a4);
  if (!v16)
  {
    if (!Mutable)
    {
      SecKeyRef v16 = 0;
      CFDictionaryRef v44 = 0;
LABEL_53:
      CFDataRef CertificateRequest = 0;
      goto LABEL_54;
    }
    CFRetain(Mutable);
    SecKeyRef v16 = Mutable;
  }
  uint64_t v46 = a4;
  CFDataRef CertificateRequest = SecGenerateCertificateRequest(a1, a2, v16, a4);
  if (!CertificateRequest)
  {
    CFDictionaryRef v44 = 0;
    goto LABEL_39;
  }
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableSetRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (Mutable && !SecCMSCreateEnvelopedData(ValueAtIndex, a2, CertificateRequest, (uint64_t)Mutable))
  {
    CFRelease(CertificateRequest);
    CFStringRef v18 = CFDictionaryCreateMutable(allocator, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    memset(bytes, 170, 20);
    CFDictionaryRef v19 = SecKeyCopyAttributes(v16);
    uint64_t v50 = v15;
    CFDictionaryRef theDict = a2;
    if (v19)
    {
      CFDictionaryRef v20 = v19;
      CFStringRef Value = CFDictionaryGetValue(v19, @"kcls");
      if (Value
        && CFEqual(Value, @"0")
        && (CFDataRef v22 = (const __CFData *)CFDictionaryGetValue(v20, @"v_Data")) != 0
        && (CFDataRef v23 = v22, !((unint64_t)CFDataGetLength(v22) >> 32)))
      {
        CFDataGetBytePtr(v23);
        CFDataGetLength(v23);
        CCDigest();
        CFDataRef v24 = CFDataCreate(allocator, bytes, 20);
      }
      else
      {
        CFDataRef v24 = 0;
      }
      CFRelease(v20);
    }
    else
    {
      CFDataRef v24 = 0;
    }
    CFIndex Length = CFDataGetLength(v24);
    BytePtr = CFDataGetBytePtr(v24);
    CFRange v27 = (UInt8 *)malloc_type_calloc(1uLL, (2 * Length) | 1, 0x71F4B16FuLL);
    CFRange v28 = v27;
    uint64_t v49 = v16;
    if (Length && BytePtr && v27)
    {
      CFIndex v48 = a5;
      CFRange v29 = v18;
      CFStringRef v30 = Mutable;
      CFArrayRef v31 = v11;
      CFIndex v32 = 2 * Length;
      if (Length >= 1)
      {
        CFRange v33 = (char *)v27;
        do
        {
          int v34 = *BytePtr++;
          snprintf(v33, 3uLL, "%02X", v34);
          v33 += 2;
          --Length;
        }
        while (Length);
      }
      CFDataRef v35 = CFDataCreateWithBytesNoCopy(allocator, v28, v32, (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
      CFArrayRef v11 = v31;
      CFMutableSetRef Mutable = v30;
      CFStringRef v18 = v29;
      a5 = v48;
      if (v24) {
LABEL_26:
      }
        CFRelease(v24);
    }
    else
    {
      if (v27) {
        free(v27);
      }
      CFDataRef v35 = 0;
      if (v24) {
        goto LABEL_26;
      }
    }
    *(_WORD *)&UInt8 bytes[8] = 1801;
    CFDataRef v36 = CFDataCreate(allocator, bytes, 10);
    CFIndex v37 = CFDataGetLength(v35);
    uint64_t v38 = CFDataGetBytePtr(v35);
    uint64_t v39 = printable_string_data(v37, v38);
    if (v35) {
      CFRelease(v35);
    }
    CFDictionarySetValue(v18, v36, v39);
    if (v36) {
      CFRelease(v36);
    }
    if (v39) {
      CFRelease(v39);
    }
    *(_WORD *)&UInt8 bytes[8] = 521;
    CFDataRef v40 = CFDataCreate(allocator, bytes, 10);
    SecKeyRef v16 = v49;
    if (!v40)
    {
      CFDictionaryRef v44 = 0;
      SecKeyRef v15 = v50;
      goto LABEL_48;
    }
    uint64_t v41 = printable_string_data(2uLL, &PKCSReq);
    SecKeyRef v15 = v50;
    if (!v41)
    {
      CFDictionaryRef v44 = 0;
      goto LABEL_48;
    }
    uint64_t v42 = v41;
    CFDictionarySetValue(v18, v40, v41);
    CFRelease(v40);
    CFRelease(v42);
    uint64_t sender_nonce = generate_sender_nonce(v18);
    if (!sender_nonce)
    {
      if (a5)
      {
        values = a5;
        CFRetain(a5);
        goto LABEL_46;
      }
      values = (void *)SecSCEPCreateTemporaryIdentity(sender_nonce, v46);
      if (values)
      {
        CFDictionaryRef v44 = CFDictionaryCreate(0, (const void **)&kSecValueRef, (const void **)&values, 1, 0, 0);
        if (SecItemAdd(v44, 0))
        {
LABEL_69:
          if (!v44) {
            goto LABEL_47;
          }
          CFRelease(v44);
          goto LABEL_45;
        }
        if (v44) {
          CFRelease(v44);
        }
        if (values)
        {
LABEL_46:
          CFDictionaryRef v44 = CFDataCreateMutable(allocator, 0);
          if (!SecCMSCreateSignedData((uint64_t)values, Mutable, theDict, v18, (uint64_t)v44)) {
            goto LABEL_47;
          }
          goto LABEL_69;
        }
      }
    }
LABEL_45:
    CFDictionaryRef v44 = 0;
LABEL_47:
    CFDataRef v40 = 0;
LABEL_48:
    if (v18) {
      CFRelease(v18);
    }
    if (v40) {
      CFRelease(v40);
    }
    goto LABEL_53;
  }
  CFDictionaryRef v44 = 0;
LABEL_54:
  if (values) {
    CFRelease(values);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (CertificateRequest) {
    CFRelease(CertificateRequest);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (v11) {
    CFRelease(v11);
  }
  return v44;
}

CFArrayRef filterRecipients(const void *a1)
{
  CFDictionaryRef v1 = a1;
  if (a1)
  {
    CFTypeID TypeID = SecCertificateGetTypeID();
    if (TypeID != CFGetTypeID(v1))
    {
      CFTypeID v3 = CFGetTypeID(v1);
      if (v3 != CFArrayGetTypeID()) {
        return 0;
      }
      CFArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
      context[0] = MEMORY[0x1E4F143A8];
      context[1] = 0x40000000;
      context[2] = __filterRecipients_block_invoke;
      context[3] = &__block_descriptor_tmp_13447;
      void context[4] = Mutable;
      v7.CFIndex length = CFArrayGetCount((CFArrayRef)v1);
      v7.CFIndex location = 0;
      CFArrayApplyFunction((CFArrayRef)v1, v7, (CFArrayApplierFunction)apply_block_1_13449, context);
      if (CFArrayGetCount(Mutable)) {
        return Mutable;
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
    }
    CFRetain(v1);
  }
  return (const __CFArray *)v1;
}

__CFData *printable_string_data(unint64_t a1, const void *a2)
{
  uint64_t v9 = DERLengthOfLength(a1);
  CFIndex v4 = a1 + v9 + 1;
  CFArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4);
  CFDataSetLength(Mutable, v4);
  BytePtr = (UInt8 *)CFDataGetBytePtr(Mutable);
  UInt8 *BytePtr = 19;
  CFRange v7 = BytePtr + 1;
  DEREncodeLength(a1, (unint64_t)(BytePtr + 1), (unint64_t *)&v9);
  memcpy(&v7[v9], a2, a1);
  return Mutable;
}

uint64_t generate_sender_nonce(__CFDictionary *a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  WORD4(v9) = 1289;
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)&v9, 10);
  long long v9 = xmmword_18B41A3C7;
  __int16 v10 = 0;
  uint64_t v4 = CCRandomCopyBytes();
  CFDataRef v5 = CFDataCreate(v2, (const UInt8 *)&v9, 18);
  CFDataRef v6 = v5;
  if (v3) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    CFDictionarySetValue(a1, v3, v5);
    goto LABEL_10;
  }
  if (v3)
  {
LABEL_10:
    CFRelease(v3);
    if (!v6) {
      return v4;
    }
    goto LABEL_8;
  }
  if (v5) {
LABEL_8:
  }
    CFRelease(v6);
  return v4;
}

void __filterRecipients_block_invoke(uint64_t a1, _DWORD *a2)
{
  CFTypeID TypeID = SecCertificateGetTypeID();
  if (TypeID == CFGetTypeID(a2) && (!a2 || (int v5 = a2[96]) == 0 || (v5 & 4) != 0))
  {
    CFDataRef v6 = *(__CFArray **)(a1 + 32);
    CFArrayAppendValue(v6, a2);
  }
}

uint64_t apply_block_1_13449(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFMutableDataRef SecSCEPCertifyRequest(const __CFData *a1, uint64_t a2, const __CFData *a3, char a4)
{
  return SecSCEPCertifyRequestWithAlgorithms(a1, a2, a3, a4, 0, 0);
}

CFMutableDataRef SecSCEPCertifyRequestWithAlgorithms(const __CFData *a1, uint64_t a2, const __CFData *a3, char a4, const void *a5, void *a6)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  CFTypeRef v47 = 0;
  values = a6;
  CFTypeRef v45 = 0;
  CFTypeRef v46 = 0;
  CFTypeRef v43 = 0;
  CFTypeRef v44 = 0;
  CFTypeRef v41 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v40 = 0;
  __int16 v10 = *(void **)(a2 + 16);
  CFRetain(v10);
  CFTypeRef v34 = v10;
  uint64_t v11 = SecCertificateCopyKey((SecCertificateRef)v10);
  SecPolicyRef BasicX509 = SecPolicyCreateBasicX509();
  CFIndex v37 = v11;
  if (SecCMSVerifySignedData_internal(a1, 0, BasicX509, (SecTrustRef *)&v47, 0, (uint64_t *)&v46, (const __CFDictionary **)&v45)|| (int v39 = -1431655766, SecTrustEvaluateInternal((__SecTrust *)v47, &v39)))
  {
    CFMutableDataRef v20 = 0;
    CFDataRef v25 = 0;
    CFDataRef v24 = 0;
    CFArrayRef Mutable = 0;
    CFArrayRef v31 = 0;
    CFDataRef v36 = 0;
    CFDataRef v16 = 0;
    uint64_t v13 = 0;
LABEL_89:
    CFDataRef v22 = 0;
    CFTypeRef v17 = 0;
    goto LABEL_44;
  }
  CFTypeID v12 = copySignerCert((__SecTrust *)v47);
  uint64_t v13 = v12;
  if (!v12
    || (int IsSignedBy = SecCertificateIsSignedBy(v12, v11),
        !scep_attr_has_val((const __CFDictionary *)v45, "19")))
  {
    CFMutableDataRef v20 = 0;
    CFDataRef v25 = 0;
    CFDataRef v24 = 0;
    CFArrayRef Mutable = 0;
    CFArrayRef v31 = 0;
    CFDataRef v36 = 0;
    CFDataRef v16 = 0;
    goto LABEL_89;
  }
  __int16 v52 = 1801;
  CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef v16 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 10);
  if (!v16) {
    goto LABEL_90;
  }
  CFTypeRef v17 = (void *)dictionary_array_value_1((const __CFDictionary *)v45, v16);
  if (!v17)
  {
    CFMutableDataRef v20 = 0;
    CFDataRef v25 = 0;
    CFDataRef v24 = 0;
    CFArrayRef Mutable = 0;
    CFArrayRef v31 = 0;
    CFDataRef v36 = 0;
    CFDataRef v22 = 0;
    goto LABEL_44;
  }
  __int16 v52 = 1289;
  CFDataRef v18 = CFDataCreate(v15, bytes, 10);
  if (!v18)
  {
LABEL_90:
    CFMutableDataRef v20 = 0;
    CFDataRef v25 = 0;
    CFDataRef v24 = 0;
    CFArrayRef Mutable = 0;
    CFArrayRef v31 = 0;
    CFDataRef v36 = 0;
LABEL_96:
    CFDataRef v22 = 0;
LABEL_104:
    CFTypeRef v17 = 0;
    goto LABEL_44;
  }
  CFDataRef v36 = v18;
  if (!dictionary_array_value_1((const __CFDictionary *)v45, v18)) {
    goto LABEL_86;
  }
  CFArrayRef Mutable = CFDataCreateMutable(v15, 0);
  CFMutableDataRef v20 = 0;
  if (SecCMSDecryptEnvelopedData((const __CFData *)v46, Mutable, &v40) || !v40)
  {
    CFDataRef v25 = 0;
    CFDataRef v24 = 0;
    CFArrayRef v31 = 0;
    CFDataRef v22 = 0;
    CFTypeRef v17 = 0;
    goto LABEL_44;
  }
  if (!SecVerifyCertificateRequest(Mutable, (__SecKey **)&v41, (CFStringRef *)&cf, (CFDataRef *)&v44, (CFDataRef *)&v43))
  {
    CFMutableDataRef v20 = 0;
    CFDataRef v25 = 0;
    CFDataRef v24 = 0;
    goto LABEL_95;
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (IsSignedBy)
  {
    if (!cf || (CFTypeID TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(cf)) || !CFEqual(@"magic", cf))
    {
LABEL_86:
      CFMutableDataRef v20 = 0;
      CFDataRef v25 = 0;
      CFDataRef v24 = 0;
      CFArrayRef Mutable = 0;
LABEL_95:
      CFArrayRef v31 = 0;
      goto LABEL_96;
    }
  }
  CFDataRef v22 = CFDataCreateMutable(v15, 0);
  if (!v22) {
    goto LABEL_92;
  }
  if (a4)
  {
    CFDataRef v23 = &PKIStatusPENDING;
    goto LABEL_32;
  }
  if (SecKeyGetAlgorithmId((uint64_t)v41) != 1)
  {
LABEL_92:
    CFMutableDataRef v20 = 0;
    CFDataRef v25 = 0;
LABEL_102:
    CFDataRef v24 = 0;
    goto LABEL_103;
  }
  CFDataRef v24 = SecIdentitySignCertificateWithAlgorithm(a2, a3, (__SecKey *)v41, v44, v43, a5);
  CFDataRef v25 = SecCMSCreateCertificatesOnlyMessage(v24);
  if (!v25)
  {
    CFMutableDataRef v20 = 0;
LABEL_103:
    CFArrayRef Mutable = 0;
    CFArrayRef v31 = 0;
    goto LABEL_104;
  }
  if (v24) {
    CFRelease(v24);
  }
  if (values) {
    CFDictionaryRef v26 = CFDictionaryCreate(0, (const void **)&kSecCMSBulkEncryptionAlgorithm, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  else {
    CFDictionaryRef v26 = 0;
  }
  if (SecCMSCreateEnvelopedData(v13, v26, v25, (uint64_t)v22))
  {
    CFMutableDataRef v20 = 0;
    goto LABEL_102;
  }
  CFRelease(v25);
  if (v26) {
    CFRelease(v26);
  }
  CFDataRef v23 = &PKIStatusSUCCESS;
LABEL_32:
  __int16 v52 = 777;
  CFDataRef v27 = CFDataCreate(v15, bytes, 10);
  CFRange v28 = printable_string_data(1uLL, v23);
  __int16 v52 = 521;
  CFDataRef v29 = CFDataCreate(v15, bytes, 10);
  CFStringRef v30 = printable_string_data(1uLL, &CertRep);
  keys[0] = v16;
  keys[1] = v27;
  keys[2] = v29;
  v49[0] = v17;
  v49[1] = v28;
  v49[2] = v30;
  CFTypeRef v17 = CFDictionaryCreate(v15, (const void **)keys, (const void **)v49, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v27) {
    CFRelease(v27);
  }
  if (v28) {
    CFRelease(v28);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (v30) {
    CFRelease(v30);
  }
  CFMutableDataRef v20 = CFDataCreateMutable(v15, 0);
  CFArrayRef v31 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue(v31, (const void *)kSecCMSCertChainMode, (const void *)kSecCMSCertChainModeNone);
  if (a5) {
    CFDictionaryAddValue(v31, (const void *)kSecCMSSignHashAlgorithm, a5);
  }
  if (!SecCMSCreateSignedData(a2, v22, v31, (const __CFDictionary *)v17, (uint64_t)v20))
  {
    CFDataRef v25 = 0;
    CFDataRef v24 = 0;
    CFArrayRef Mutable = 0;
LABEL_44:
    SecPolicyRef v32 = BasicX509;
    goto LABEL_45;
  }
  SecPolicyRef v32 = BasicX509;
  if (v20)
  {
    CFRelease(v20);
    CFMutableDataRef v20 = 0;
  }
  CFDataRef v25 = 0;
  CFDataRef v24 = 0;
  CFArrayRef Mutable = 0;
LABEL_45:
  if (v34) {
    CFRelease(v34);
  }
  if (v37) {
    CFRelease(v37);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (v22) {
    CFRelease(v22);
  }
  if (v47) {
    CFRelease(v47);
  }
  if (v32) {
    CFRelease(v32);
  }
  if (v46) {
    CFRelease(v46);
  }
  if (v45) {
    CFRelease(v45);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v36) {
    CFRelease(v36);
  }
  if (v44) {
    CFRelease(v44);
  }
  if (v43) {
    CFRelease(v43);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v41) {
    CFRelease(v41);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v40) {
    CFRelease(v40);
  }
  if (v31) {
    CFRelease(v31);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v20;
}

const void *copySignerCert(__SecTrust *a1)
{
  CFArrayRef v1 = SecTrustCopyCertificateChain(a1);
  if (!v1) {
    return 0;
  }
  CFArrayRef v2 = v1;
  CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v1, 0);
  uint64_t v4 = ValueAtIndex;
  if (ValueAtIndex) {
    CFRetain(ValueAtIndex);
  }
  CFRelease(v2);
  return v4;
}

unint64_t scep_attr_has_val(const __CFDictionary *a1, char *__s)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  size_t v4 = strlen(__s);
  CFTypeRef cf = printable_string_data(v4, __s);
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef v6 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &cf, 1, MEMORY[0x1E4F1D510]);
  CFRelease(cf);
  __int16 v12 = 521;
  CFDataRef v7 = CFDataCreate(v5, bytes, 10);
  unint64_t Value = (unint64_t)CFDictionaryGetValue(a1, v7);
  CFRelease(v7);
  if (Value) {
    unint64_t Value = CFEqual(v6, (CFTypeRef)Value) != 0;
  }
  CFRelease(v6);
  return Value;
}

const void *dictionary_array_value_1(const __CFDictionary *a1, const void *a2)
{
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a1, a2);
  if (!Value) {
    return 0;
  }
  CFArrayRef v3 = Value;
  if (CFArrayGetCount(Value) != 1) {
    return 0;
  }

  return CFArrayGetValueAtIndex(v3, 0);
}

BOOL SecSCEPVerifyGetCertInitial(const __CFData *a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  CFTypeRef v14 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v12 = 0;
  CFTypeRef v13 = 0;
  CFArrayRef v3 = *(void **)(a2 + 16);
  CFRetain(v3);
  SecKeyRef v4 = SecCertificateCopyKey((SecCertificateRef)v3);
  SecPolicyRef BasicX509 = SecPolicyCreateBasicX509();
  if (SecCMSVerifySignedData_internal(a1, 0, BasicX509, (SecTrustRef *)&cf, 0, (uint64_t *)&v14, (const __CFDictionary **)&v13)|| !scep_attr_has_val((const __CFDictionary *)v13, "20"))
  {
    BOOL v10 = 0;
    CFDataRef Mutable = 0;
    CFDataRef v8 = 0;
    CFDataRef v7 = 0;
  }
  else
  {
    __int16 v17 = 1801;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDataRef v7 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 10);
    if (v7 && dictionary_array_value_1((const __CFDictionary *)v13, v7))
    {
      __int16 v17 = 1289;
      CFDataRef v8 = CFDataCreate(v6, bytes, 10);
      if (v8 && dictionary_array_value_1((const __CFDictionary *)v13, v8))
      {
        CFDataRef Mutable = CFDataCreateMutable(v6, 0);
        BOOL v10 = 0;
        if (!SecCMSDecryptEnvelopedData((const __CFData *)v14, Mutable, &v12) && v12) {
          BOOL v10 = CFDataGetLength(Mutable) > 0;
        }
      }
      else
      {
        BOOL v10 = 0;
        CFDataRef Mutable = 0;
      }
    }
    else
    {
      BOOL v10 = 0;
      CFDataRef Mutable = 0;
      CFDataRef v8 = 0;
    }
  }
  if (v3) {
    CFRelease(v3);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (BasicX509) {
    CFRelease(BasicX509);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v10;
}

CFArrayRef SecSCEPVerifyReply(int a1, const __CFData *a2, CFTypeRef cf, CFErrorRef *a4)
{
  CFStringRef ValueAtIndex = (void *)cf;
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  CFTypeRef v29 = 0;
  CFTypeRef cfa = 0;
  CFTypeRef v27 = 0;
  CFDictionaryRef theDict = 0;
  values = 0;
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 == SecCertificateGetTypeID())
  {
    values = ValueAtIndex;
    if (!ValueAtIndex) {
      goto LABEL_61;
    }
    goto LABEL_10;
  }
  CFTypeID v8 = CFGetTypeID(ValueAtIndex);
  if (v8 != CFArrayGetTypeID()) {
    goto LABEL_15;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)ValueAtIndex);
  if (Count >= 2)
  {
    CFArrayRef v10 = (const __CFArray *)ValueAtIndex;
    CFIndex v11 = 1;
    goto LABEL_9;
  }
  if (Count != 1)
  {
LABEL_15:
    CFArrayRef v15 = 0;
    CFArrayRef v16 = 0;
    CFArrayRef v17 = 0;
    CFDataRef Mutable = 0;
    CFDictionaryRef v19 = 0;
    CFStringRef ValueAtIndex = 0;
    goto LABEL_42;
  }
  CFArrayRef v10 = (const __CFArray *)ValueAtIndex;
  CFIndex v11 = 0;
LABEL_9:
  CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v10, v11);
  values = ValueAtIndex;
  if (!ValueAtIndex)
  {
LABEL_61:
    CFArrayRef v15 = 0;
    CFArrayRef v16 = 0;
    CFArrayRef v17 = 0;
    CFDataRef Mutable = 0;
    CFDictionaryRef v19 = 0;
    goto LABEL_42;
  }
LABEL_10:
  CFStringRef ValueAtIndex = SecPolicyCreateBasicX509();
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef v13 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
  if (SecCMSVerifySignedData(a2, 0, ValueAtIndex, (SecTrustRef *)&cfa, v13, (uint64_t *)&v29, &theDict)) {
    goto LABEL_61;
  }
  if (v13) {
    CFRelease(v13);
  }
  CFDictionaryRef v14 = theDict ? (const __CFDictionary *)CFDictionaryGetValue(theDict, (const void *)kSecCMSSignedAttributes) : 0;
  int v25 = -1431655766;
  if (SecTrustEvaluateInternal((__SecTrust *)cfa, &v25)) {
    goto LABEL_61;
  }
  CFDictionaryRef v19 = copySignerCert((__SecTrust *)cfa);
  if (!v19)
  {
    CFArrayRef v15 = 0;
    CFArrayRef v16 = 0;
    goto LABEL_26;
  }
  CFArrayRef v15 = 0;
  if (!CFEqual(values, v19) || !v14)
  {
    CFArrayRef v16 = 0;
    CFArrayRef v17 = 0;
    CFDataRef Mutable = 0;
    goto LABEL_42;
  }
  CFArrayRef v16 = copy_signed_attr_printable_string_value(v14, 2u);
  CFArrayRef v15 = copy_signed_attr_printable_string_value(v14, 3u);
  if ((unint64_t)v16 | (unint64_t)v15)
  {
    if (!v16 || !CFEqual(v16, @"3") || !v15 || CFEqual(v15, @"2")) {
      goto LABEL_26;
    }
    if (CFEqual(v15, @"3"))
    {
      __int16 v32 = 1801;
      CFDataRef v20 = CFDataCreate(v12, bytes, 10);
      *(void *)UInt8 bytes = v20;
      if (v20)
      {
        CFDataRef v24 = dictionary_array_value_1(v14, v20);
        if (v24)
        {
          CFDictionaryRef v21 = CFDictionaryCreate(v12, (const void **)bytes, &v24, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          if (a4) {
            *a4 = CFErrorCreate(v12, @"PENDING", 3, v21);
          }
          if (v21) {
            CFRelease(v21);
          }
        }
        if (*(void *)bytes) {
          CFRelease(*(CFTypeRef *)bytes);
        }
      }
      goto LABEL_26;
    }
    if (!CFEqual(v15, @"0"))
    {
LABEL_26:
      CFArrayRef v17 = 0;
      CFDataRef Mutable = 0;
      goto LABEL_42;
    }
  }
  CFDataRef Mutable = CFDataCreateMutable(v12, 0);
  CFArrayRef v17 = 0;
  if (!SecCMSDecryptEnvelopedData((const __CFData *)v29, Mutable, &v27))
  {
    if (v27)
    {
      CFArrayRef v17 = SecCMSCertificatesOnlyMessageCopyCertificates((uint64_t)Mutable);
      if (v17)
      {
        CFDictionaryRef v22 = CFDictionaryCreate(0, (const void **)&kSecValueRef, &v27, 1, 0, 0);
        SecItemDelete(v22);
        if (v22) {
          CFRelease(v22);
        }
      }
    }
  }
LABEL_42:
  if (cfa) {
    CFRelease(cfa);
  }
  if (ValueAtIndex) {
    CFRelease(ValueAtIndex);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v27) {
    CFRelease(v27);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (theDict) {
    CFRelease(theDict);
  }
  if (v19) {
    CFRelease(v19);
  }
  return v17;
}

CFArrayRef copy_signed_attr_printable_string_value(const __CFDictionary *a1, UInt8 a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  UInt8 bytes[9] = a2;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef v4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 10);
  if (!v4) {
    return 0;
  }
  CFDataRef v5 = v4;
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a1, v4);
  CFArrayRef v7 = Value;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == CFArrayGetTypeID()
      && CFArrayGetCount(v7) == 1
      && (CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v7, 0),
          BytePtr = CFDataGetBytePtr(ValueAtIndex),
          unint64_t Length = CFDataGetLength(ValueAtIndex),
          Length >= 2)
      && *BytePtr == 19)
    {
      CFArrayRef v7 = 0;
      if (((char)BytePtr[1] & 0x80000000) == 0 && Length - 2 == BytePtr[1]) {
        CFArrayRef v7 = (const __CFArray *)CFStringCreateWithBytes(v3, BytePtr + 2, BytePtr[1], 0x600u, 0);
      }
    }
    else
    {
      CFArrayRef v7 = 0;
    }
  }
  CFRelease(v5);
  return v7;
}

uint64_t SecSCEPValidateCACertMessage(CFArrayRef theArray, CFDataRef theData, __CFData **a3, void *a4, void *a5)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  if (!theData)
  {
    CFDataRef ValueAtIndex = 0;
    goto LABEL_54;
  }
  CFIndex v7 = 0;
  CFArrayRef theArraya = (CFArrayRef)CFDataGetLength(theData);
  *((void *)&v9 + 1) = theArraya;
  *(void *)&long long v9 = (char *)theArraya - 16;
  uint64_t v8 = v9 >> 2;
  while (2)
  {
    if (v7 >= CFArrayGetCount(theArray))
    {
      uint64_t v35 = 4294899453;
LABEL_49:
      CFDataRef v36 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long md = 138412290;
        *(void *)&md[4] = theData;
        _os_log_impl(&dword_18B299000, v36, OS_LOG_TYPE_DEFAULT, "SCEP failed to find certificate matching CA fingerprint: %@", md, 0xCu);
      }
      return v35;
    }
    CFDataRef ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(theArray, v7);
    switch(v8)
    {
      case 0:
        CFIndex v11 = secLogObjForScope("scep");
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long md = 0;
          _os_log_debug_impl(&dword_18B299000, v11, OS_LOG_TYPE_DEBUG, "MD5 fingerprint digest", md, 2u);
        }
        memset(md, 170, 16);
        CFAllocatorRef v12 = (const void *)*((void *)ValueAtIndex + 2);
        uint64_t v13 = *((void *)ValueAtIndex + 3);
        if ((unint64_t)(v13 - 0xFFFFFFFFLL) < 0xFFFFFFFF00000002 || v12 == 0) {
          goto LABEL_46;
        }
        CC_MD5(v12, v13, md);
        CFIndex v15 = 16;
        goto LABEL_40;
      case 1:
        CFArrayRef v16 = secLogObjForScope("scep");
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long md = 0;
          _os_log_debug_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEBUG, "SHA1 fingerprint digest", md, 2u);
        }
        SHA1Digest = SecCertificateGetSHA1Digest(ValueAtIndex);
        if (!SHA1Digest) {
          goto LABEL_45;
        }
        uint64_t v18 = SHA1Digest;
        CFRetain(SHA1Digest);
        goto LABEL_43;
      case 3:
        CFDictionaryRef v19 = secLogObjForScope("scep");
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long md = 0;
          _os_log_debug_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEBUG, "SHA224 fingerprint digest", md, 2u);
        }
        memset(md, 170, 28);
        CFDataRef v20 = (const void *)*((void *)ValueAtIndex + 2);
        uint64_t v21 = *((void *)ValueAtIndex + 3);
        if ((unint64_t)(v21 - 0xFFFFFFFFLL) < 0xFFFFFFFF00000002 || v20 == 0) {
          goto LABEL_46;
        }
        CC_SHA224(v20, v21, md);
        CFIndex v15 = 28;
        goto LABEL_40;
      case 4:
        CFDataRef v23 = secLogObjForScope("scep");
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long md = 0;
          _os_log_debug_impl(&dword_18B299000, v23, OS_LOG_TYPE_DEBUG, "SHA256 fingerprint digest", md, 2u);
        }
        CFDataRef v24 = SecCertificateCopySHA256Digest(ValueAtIndex);
        goto LABEL_41;
      case 8:
        int v25 = secLogObjForScope("scep");
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long md = 0;
          _os_log_debug_impl(&dword_18B299000, v25, OS_LOG_TYPE_DEBUG, "SHA384 fingerprint digest", md, 2u);
        }
        CFDictionaryRef v26 = (const void *)*((void *)ValueAtIndex + 2);
        uint64_t v27 = *((void *)ValueAtIndex + 3);
        if ((unint64_t)(v27 - 0xFFFFFFFFLL) < 0xFFFFFFFF00000002 || v26 == 0) {
          goto LABEL_46;
        }
        *(void *)&long long v29 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&md[16] = v29;
        long long v81 = v29;
        *(_OWORD *)long long md = v29;
        CC_SHA384(v26, v27, md);
        CFIndex v15 = 48;
        goto LABEL_40;
      case 12:
        CFStringRef v30 = secLogObjForScope("scep");
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long md = 0;
          _os_log_debug_impl(&dword_18B299000, v30, OS_LOG_TYPE_DEBUG, "SHA512 fingerprint digest", md, 2u);
        }
        CFArrayRef v31 = (const void *)*((void *)ValueAtIndex + 2);
        uint64_t v32 = *((void *)ValueAtIndex + 3);
        if ((unint64_t)(v32 - 0xFFFFFFFFLL) < 0xFFFFFFFF00000002 || v31 == 0)
        {
LABEL_46:
          uint64_t v18 = 0;
        }
        else
        {
          *(void *)&long long v34 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
          long long v81 = v34;
          long long v82 = v34;
          *(_OWORD *)long long md = v34;
          *(_OWORD *)&md[16] = v34;
          CC_SHA512(v31, v32, md);
          CFIndex v15 = 64;
LABEL_40:
          CFDataRef v24 = CFDataCreate(0, md, v15);
LABEL_41:
          uint64_t v18 = v24;
        }
        if (!v18) {
          goto LABEL_45;
        }
LABEL_43:
        if (!CFEqual(v18, theData))
        {
          CFRelease(v18);
LABEL_45:
          ++v7;
          continue;
        }
        if (ValueAtIndex) {
          CFRetain(ValueAtIndex);
        }
        CFRelease(v18);
LABEL_54:
        CFIndex Count = CFArrayGetCount(theArray);
        uint64_t v38 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
        CFMutableArrayRef Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E4F1D510]);
        CFIndex v40 = CFArrayGetCount(theArray);
        CFMutableArrayRef v41 = CFArrayCreateMutable(0, v40, v38);
        CFIndex v42 = CFArrayGetCount(theArray);
        CFMutableArrayRef v43 = CFArrayCreateMutable(0, v42, v38);
        CFArrayRef v44 = v43;
        if (Mutable) {
          BOOL v45 = v41 == 0;
        }
        else {
          BOOL v45 = 1;
        }
        if (v45 || v43 == 0)
        {
          uint64_t v35 = 4294899624;
          goto LABEL_63;
        }
        CFIndex v49 = 0;
        while (2)
        {
          if (v49 < CFArrayGetCount(theArray))
          {
            uint64_t v50 = CFArrayGetValueAtIndex(theArray, v49);
            if (v50)
            {
              uint64_t v51 = v50;
              int v52 = *((_DWORD *)v50 + 96) & 5;
              if (v52 == 1)
              {
                uint64_t v53 = v41;
              }
              else
              {
                uint64_t v53 = Mutable;
                if (v52 != 5)
                {
                  uint64_t v53 = v44;
                  if (v52 != 4) {
                    goto LABEL_81;
                  }
                }
              }
              CFArrayAppendValue(v53, v51);
            }
LABEL_81:
            ++v49;
            continue;
          }
          break;
        }
        if (!CFArrayGetCount(Mutable))
        {
          uint64_t v35 = 4294899565;
          if (!CFArrayGetCount(v41) || !CFArrayGetCount(v44))
          {
LABEL_63:
            CFTypeRef v47 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long md = 0;
              _os_log_impl(&dword_18B299000, v47, OS_LOG_TYPE_DEFAULT, "SCEP failed to find candidate RA certificates", md, 2u);
            }
            if (ValueAtIndex) {
              CFRelease(ValueAtIndex);
            }
            if (Mutable) {
              CFRelease(Mutable);
            }
            if (v41) {
              CFRelease(v41);
            }
            if (v44)
            {
              CFArrayRef v48 = v44;
              goto LABEL_150;
            }
            return v35;
          }
        }
        ra_chain = scep_find_ra_chain(v41, theArray, ValueAtIndex);
        uint64_t v55 = scep_find_ra_chain(v44, theArray, ValueAtIndex);
        CFAllocatorRef v56 = 0;
        uint64_t v35 = 4294941020;
        CFArrayRef theArrayb = v55;
        if (!ra_chain)
        {
          int v58 = 0;
          goto LABEL_105;
        }
        CFArrayRef v57 = v55;
        int v58 = 0;
        if (!v55) {
          goto LABEL_105;
        }
        CFNumberRef v59 = CFArrayGetValueAtIndex(ra_chain, 0);
        int v58 = v59;
        if (v59) {
          CFRetain(v59);
        }
        CFRange v60 = CFArrayGetValueAtIndex(v57, 0);
        CFAllocatorRef v56 = v60;
        if (v60) {
          CFRetain(v60);
        }
        if (ValueAtIndex)
        {
          CFRange v61 = ValueAtIndex;
          goto LABEL_127;
        }
        CFIndex v63 = CFArrayGetCount(ra_chain);
        CFRange v61 = (void *)CFArrayGetValueAtIndex(ra_chain, v63 - 1);
        CFIndex v64 = CFArrayGetCount(theArrayb);
        int v65 = (void *)CFArrayGetValueAtIndex(theArrayb, v64 - 1);
        if (!v61 || !v65)
        {
          if (v61 != v65) {
            goto LABEL_102;
          }
          if (!v61)
          {
            if (!a3) {
              goto LABEL_130;
            }
            goto LABEL_129;
          }
LABEL_126:
          CFRetain(v61);
LABEL_127:
          if (!a3) {
            goto LABEL_130;
          }
          CFRetain(v61);
LABEL_129:
          *a3 = (__CFData *)v61;
LABEL_130:
          if (a4)
          {
            if (v58) {
              CFRetain(v58);
            }
            *a4 = v58;
          }
          if (a5)
          {
            if (v56) {
              CFRetain(v56);
            }
            uint64_t v35 = 0;
            CFStringRef v73 = 0;
            *a5 = v56;
          }
          else
          {
            uint64_t v35 = 0;
            CFStringRef v73 = 0;
          }
LABEL_139:
          CFRelease(ra_chain);
          CFDataRef ValueAtIndex = (__CFData *)v61;
          goto LABEL_140;
        }
        if (CFEqual(v61, v65)) {
          goto LABEL_126;
        }
LABEL_102:
        int v66 = secLogObjForScope("scep");
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long md = 0;
          _os_log_impl(&dword_18B299000, v66, OS_LOG_TYPE_DEFAULT, "signing/encryption CAs do not match", md, 2u);
        }
        uint64_t v35 = 4294899453;
LABEL_105:
        int v67 = secLogObjForScope("scep");
        if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long md = 0;
          _os_log_debug_impl(&dword_18B299000, v67, OS_LOG_TYPE_DEBUG, "SCEP did not find different RA certificates for signing/encryption; looking for one cert",
            md,
            2u);
        }
        BOOL v68 = scep_find_ra_chain(Mutable, theArray, ValueAtIndex);
        if (v68)
        {
          CFArrayRef v69 = v68;
          if (!ValueAtIndex)
          {
            CFIndex v70 = CFArrayGetCount(v68);
            int v71 = (__CFData *)CFArrayGetValueAtIndex(v69, v70 - 1);
            CFDataRef ValueAtIndex = v71;
            if (v71) {
              CFRetain(v71);
            }
          }
          int v72 = CFArrayGetValueAtIndex(v69, 0);
          CFStringRef v73 = v72;
          if (v72) {
            CFRetain(v72);
          }
          CFRelease(v69);
          if (a3)
          {
            if (ValueAtIndex) {
              CFRetain(ValueAtIndex);
            }
            *a3 = ValueAtIndex;
          }
          if (a4)
          {
            if (v73) {
              CFRetain(v73);
            }
            uint64_t v35 = 0;
            *a4 = v73;
          }
          else
          {
            uint64_t v35 = 0;
          }
        }
        else
        {
          CFStringRef v73 = 0;
        }
        CFRange v61 = ValueAtIndex;
        if (ra_chain) {
          goto LABEL_139;
        }
LABEL_140:
        if (theArrayb) {
          CFRelease(theArrayb);
        }
        CFRelease(Mutable);
        CFRelease(v41);
        CFRelease(v44);
        if (ValueAtIndex) {
          CFRelease(ValueAtIndex);
        }
        if (v73) {
          CFRelease(v73);
        }
        if (v58) {
          CFRelease(v58);
        }
        if (v56)
        {
          CFArrayRef v48 = (const __CFArray *)v56;
LABEL_150:
          CFRelease(v48);
        }
        return v35;
      default:
        CFRange v62 = secLogObjForScope("SecError");
        uint64_t v35 = 4294899481;
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long md = 134217984;
          *(void *)&md[4] = theArraya;
          _os_log_impl(&dword_18B299000, v62, OS_LOG_TYPE_DEFAULT, "SCEP failed to find algorithm to match CA fingerprint length: %ld", md, 0xCu);
        }
        goto LABEL_49;
    }
  }
}

__CFArray *scep_find_ra_chain(CFArrayRef theArray, const __CFArray *a2, void *a3)
{
  CFIndex v5 = 0;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v6 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  values = a3;
  while (v5 < CFArrayGetCount(theArray))
  {
    CFIndex Count = CFArrayGetCount(a2);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, Count + 1, v6);
    CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v5);
    CFArrayAppendValue(Mutable, ValueAtIndex);
    v26.CFIndex length = CFArrayGetCount(a2);
    v26.CFIndex location = 0;
    CFArrayAppendArray(Mutable, a2, v26);
    SecTrustRef trust = 0;
    if (SecTrustCreateWithCertificates(Mutable, 0, &trust))
    {
      CFArrayRef v10 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFDictionaryRef v22 = ValueAtIndex;
        _os_log_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEFAULT, "SCEP failed to create trust for %@", buf, 0xCu);
      }
      if (Mutable) {
        goto LABEL_19;
      }
    }
    else
    {
      if (Mutable) {
        CFRelease(Mutable);
      }
      if (values)
      {
        CFArrayRef v11 = CFArrayCreate(0, (const void **)&values, 1, v6);
        SecTrustSetAnchorCertificates(trust, v11);
        if (v11) {
          CFRelease(v11);
        }
      }
      CFArrayRef v12 = SecTrustCopyCertificateChain(trust);
      if (v12)
      {
        CFMutableArrayRef Mutable = v12;
        uint64_t v13 = values;
        if (!values) {
          return Mutable;
        }
        CFIndex v14 = CFArrayGetCount(v12);
        CFIndex v15 = CFArrayGetValueAtIndex(Mutable, v14 - 1);
        if (v15)
        {
          if (CFEqual(v13, v15)) {
            return Mutable;
          }
        }
        CFArrayRef v16 = secLogObjForScope("scep");
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412546;
          CFDictionaryRef v22 = ValueAtIndex;
          __int16 v23 = 2112;
          CFDataRef v24 = values;
          _os_log_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEFAULT, "failed to create chain from %@ to ca cert %@", buf, 0x16u);
        }
LABEL_19:
        CFRelease(Mutable);
        goto LABEL_20;
      }
      CFArrayRef v17 = secLogObjForScope("scep");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFDictionaryRef v22 = ValueAtIndex;
        _os_log_impl(&dword_18B299000, v17, OS_LOG_TYPE_DEFAULT, "failed to create chain %@", buf, 0xCu);
      }
    }
LABEL_20:
    ++v5;
  }
  return 0;
}

CFMutableDataRef SecSCEPGetCertInitial(uint64_t a1, const __CFArray *a2, const __CFDictionary *a3, const __CFDictionary *a4, uint64_t a5, const void *a6)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a4) {
    return 0;
  }
  CertificateRequestSubject = SecGenerateCertificateRequestSubject(a1, a2);
  if (!CertificateRequestSubject) {
    return 0;
  }
  CFArrayRef v11 = CertificateRequestSubject;
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (!Mutable)
  {
    CFRelease(v11);
    return 0;
  }
  CFDataRef v14 = Mutable;
  CFArrayRef v15 = filterRecipients(a6);
  if (SecCMSCreateEnvelopedData(v15, a3, v11, (uint64_t)v14))
  {
    CFMutableDataRef v20 = 0;
    CFDataRef v17 = 0;
  }
  else
  {
    CFDataRef MutableCopy = CFDictionaryCreateMutableCopy(v12, 3, a4);
    __int16 v23 = 521;
    CFDataRef v17 = CFDataCreate(v12, bytes, 10);
    if (v17 && (uint64_t v18 = printable_string_data(2uLL, "20")) != 0)
    {
      CFDictionaryRef v19 = v18;
      CFDictionarySetValue(MutableCopy, v17, v18);
      CFRelease(v17);
      CFRelease(v19);
      generate_sender_nonce(MutableCopy);
      CFMutableDataRef v20 = CFDataCreateMutable(v12, 0);
      if (SecCMSCreateSignedData(a5, v14, a3, MutableCopy, (uint64_t)v20) && v20)
      {
        CFRelease(v20);
        CFMutableDataRef v20 = 0;
      }
      CFDataRef v17 = 0;
      if (!MutableCopy) {
        goto LABEL_10;
      }
    }
    else
    {
      CFMutableDataRef v20 = 0;
      if (!MutableCopy) {
        goto LABEL_10;
      }
    }
    CFRelease(MutableCopy);
  }
LABEL_10:
  CFRelease(v11);
  CFRelease(v14);
  if (v17) {
    CFRelease(v17);
  }
  if (v15) {
    CFRelease(v15);
  }
  return v20;
}

uint64_t SecCopyEncryptedToServerKey(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v6 = 0;
  CFIndex v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  _DWORD v5[2] = __SecCopyEncryptedToServerKey_block_invoke;
  v5[3] = &unk_1E5482B00;
  void v5[5] = a2;
  void v5[6] = a3;
  void v5[4] = &v6;
  if (*(_UNKNOWN **)(a1 + 16) == &kSecECPublicKeyDescriptor) {
    __SecCopyEncryptedToServerKey_block_invoke((uint64_t)v5);
  }
  else {
    SecError(-50, a3, @"Not an EC Public Key object, sorry can't do.");
  }
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void __SecCopyEncryptedToServerKey_block_invoke(uint64_t a1)
{
  unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v22[0] = v2;
  v22[1] = v2;
  uint64_t v3 = ccaes_gcm_encrypt_mode();
  InitServerECIES((uint64_t)v22, v3);
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 40));
  CFIndex v21 = ccecies_encrypt_gcm_ciphertext_size();
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFDataSetLength(Mutable, v21);
  if (!Mutable)
  {
    SecError(-108, *(__CFString ***)(a1 + 48), @"failed to create data");
    return;
  }
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  CFDataGetBytePtr(*(CFDataRef *)(a1 + 40));
  uint64_t v8 = ccecies_encrypt_gcm();
  size_t v9 = ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
  CFArrayRef v10 = *(__CFString ***)(a1 + 48);
  if (Length + v9 + 16 == v21)
  {
    ccder_sizeof();
    ccder_sizeof();
    ccder_sizeof();
    CFIndex v11 = ccder_sizeof();
    CFAllocatorRef v12 = CFDataCreateMutable(v5, 0);
    CFDataSetLength(v12, v11);
    if (v12)
    {
      uint64_t v19 = v8;
      CFTypeRef cf = Mutable;
      CFDataGetMutableBytePtr(v12);
      CFDataGetLength(v12);
      uint64_t v13 = (_OWORD *)ccder_encode_body_nocopy();
      ccder_encode_tl();
      CFDataRef v14 = (void *)ccder_encode_body_nocopy();
      ccder_encode_tl();
      CFArrayRef v15 = (void *)ccder_encode_body_nocopy();
      ccder_encode_tl();
      if (ccder_encode_constructed_tl())
      {
        CFRetain(v12);
        CFRelease(v12);
        memcpy(v15, MutableBytePtr, v9);
        memcpy(v14, &MutableBytePtr[v9], Length);
        _OWORD *v13 = *(_OWORD *)&MutableBytePtr[v9 + Length];
        if (v19)
        {
          SecError(-909, *(__CFString ***)(a1 + 48), @"ccecies_encrypt_gcm failed %d", v19);
        }
        else
        {
          uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 8);
          if (*(__CFData **)(v16 + 24) != v12)
          {
            CFRetain(v12);
            CFDataRef v17 = *(const void **)(v16 + 24);
            if (v17) {
              CFRelease(v17);
            }
            *(void *)(v16 + 24) = v12;
          }
        }
        CFRelease(cf);
        uint64_t v18 = v12;
        goto LABEL_11;
      }
      SecError(-50, v10, @"Encoding failed");
      CFRelease(v12);
    }
    else
    {
      SecError(-108, v10, @"failed to create data", &v21, MutableBytePtr);
    }
  }
  else
  {
    SecError(-26276, v10, @"Allocation mismatch", &v21, MutableBytePtr);
  }
  uint64_t v18 = Mutable;
LABEL_11:
  CFRelease(v18);
}

uint64_t InitServerECIES(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = ccsha256_di();
  uint64_t v5 = ccrng();

  return MEMORY[0x1F40CAC10](a1, v4, v5, a2, 16, 16, 19);
}

uint64_t SecCopyDecryptedForServer(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v6 = 0;
  CFIndex v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  _DWORD v5[2] = __SecCopyDecryptedForServer_block_invoke;
  v5[3] = &unk_1E5482B28;
  void v5[5] = a2;
  void v5[6] = a3;
  void v5[4] = &v6;
  if (*(_UNKNOWN **)(a1 + 16) == &kSecECPrivateKeyDescriptor) {
    __SecCopyDecryptedForServer_block_invoke((uint64_t)v5);
  }
  else {
    SecError(-50, a3, @"Not an EC Full Key object, sorry can't do.");
  }
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void __SecCopyDecryptedForServer_block_invoke(uint64_t a1)
{
  unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v24[0] = v2;
  v24[1] = v2;
  uint64_t v3 = ccaes_gcm_decrypt_mode();
  InitServerECIES((uint64_t)v24, v3);
  memset(v23, 170, sizeof(v23));
  CFDataRef v5 = *(const __CFData **)(a1 + 40);
  uint64_t v4 = *(__CFString ***)(a1 + 48);
  BytePtr = CFDataGetBytePtr(v5);
  CFIndex v7 = &BytePtr[CFDataGetLength(v5)];
  unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
  ccder_decode_sequence_tl();
  uint64_t v8 = (const void *)ccder_decode_tl();
  uint64_t v9 = (const void *)ccder_decode_tl();
  uint64_t v10 = ccder_decode_tl();
  size_t v11 = v10 + v23[0];
  if (!v10) {
    size_t v11 = 0;
  }
  if ((const UInt8 *)v11 != v7)
  {
    SecError(-50, v4, @"Blob failed to decode");
    return;
  }
  if (v8)
  {
    CFAllocatorRef v12 = (const void *)v10;
    if (v9 && v10 != 0)
    {
      CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      CFDataSetLength(Mutable, v23[1] + v23[2] + v23[0]);
      if (!Mutable)
      {
        SecError(-108, *(__CFString ***)(a1 + 48), @"failed to create data");
        return;
      }
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      memcpy(MutableBytePtr, v8, v23[2]);
      memcpy(&MutableBytePtr[v23[2]], v9, v23[1]);
      memcpy(&MutableBytePtr[v23[2] + v23[1]], v12, v23[0]);
      CFIndex v17 = ccecies_decrypt_gcm_plaintext_size();
      unint64_t v26 = v17;
      uint64_t v18 = CFDataCreateMutable(v14, 0);
      CFDataSetLength(v18, v17);
      CFDictionaryRef v22 = CFDataGetMutableBytePtr(v18);
      uint64_t v19 = ccecies_decrypt_gcm();
      if (v19)
      {
        SecError(-909, *(__CFString ***)(a1 + 48), @"ccecies_decrypt_gcm failed %d", v19, v22);
        if (!v18) {
          goto LABEL_18;
        }
      }
      else
      {
        uint64_t v20 = *(void *)(*(void *)(a1 + 32) + 8);
        CFIndex v21 = *(__CFData **)(v20 + 24);
        if (v21 != v18)
        {
          if (!v18 || (CFRetain(v18), (CFIndex v21 = *(__CFData **)(v20 + 24)) != 0)) {
            CFRelease(v21);
          }
          *(void *)(v20 + 24) = v18;
        }
        if (!v18) {
          goto LABEL_18;
        }
      }
      CFRelease(v18);
LABEL_18:
      CFRelease(Mutable);
    }
  }
}

uint64_t SecCopyEncryptedToServer(__SecTrust *a1, uint64_t a2, __CFString **a3)
{
  SecKeyRef v5 = SecTrustCopyKey(a1);
  if (v5)
  {
    SecKeyRef v6 = v5;
    uint64_t v7 = SecCopyEncryptedToServerKey((uint64_t)v5, a2, a3);
    CFRelease(v6);
    return v7;
  }
  else
  {
    SecError(-25308, a3, @"Failed to get key out of trust ref, was it evaluated?");
    return 0;
  }
}

uint64_t __SecAddSharedWebCredentialSync_block_invoke(uint64_t a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  SecSecurityClientGet();
  uint64_t v5 = cftype_to_BOOL_cftype_error_request(0x1Eu, v4, (uint64_t)&cf, a2);
  SecKeyRef v6 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v6) {
    CFRelease(v6);
  }
  if ((v5 & 1) == 0 && !*a2) {
    SecError(-26276, (__CFString **)a2, @"Internal error (XPC failure)");
  }
  uint64_t v7 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (v7)
  {
    if (a2) {
      CFTypeRef v8 = *a2;
    }
    else {
      CFTypeRef v8 = 0;
    }
    void *v7 = v8;
    uint64_t v10 = **(const void ***)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    if (v10) {
      CFRetain(v10);
    }
  }
  else
  {
    CFTypeRef v9 = *a2;
    if (*a2)
    {
      *a2 = 0;
      CFRelease(v9);
    }
  }
  CFTypeRef v11 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v11);
  }
  return v5;
}

void SecAddSharedWebCredential(CFStringRef fqdn, CFStringRef account, CFStringRef password, void *completionHandler)
{
  uint64_t v27 = 0;
  CFRange v28 = (__CFString **)&v27;
  uint64_t v29 = 0x2000000000;
  uint64_t v30 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = &v23;
  uint64_t v25 = 0x2000000000;
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0, 0);
  if (!fqdn) {
    goto LABEL_12;
  }
  CFTypeID v8 = CFGetTypeID(fqdn);
  if (v8 != CFStringGetTypeID()) {
    goto LABEL_12;
  }
  CFIndex Length = CFStringGetLength(fqdn);
  uint64_t v10 = @"fqdn or account was not of type CFString, or not provided";
  if (!account || !Length) {
    goto LABEL_13;
  }
  CFTypeID v11 = CFGetTypeID(account);
  if (v11 != CFStringGetTypeID() || !CFStringGetLength(account))
  {
LABEL_12:
    uint64_t v10 = @"fqdn or account was not of type CFString, or not provided";
LABEL_13:
    SecError(-50, v28 + 3, @"%@", v10);
    CFAllocatorRef v14 = v24[3];
    v22[0] = MEMORY[0x1E4F143A8];
    v22[1] = 0x40000000;
    _OWORD v22[2] = __SecAddSharedWebCredential_block_invoke;
    v22[3] = &unk_1E5482B90;
    void v22[4] = completionHandler;
    v22[5] = &v27;
    dispatch_async(v14, v22);
    goto LABEL_14;
  }
  if (password)
  {
    CFTypeID v12 = CFGetTypeID(password);
    if (v12 != CFStringGetTypeID())
    {
      uint64_t v10 = @"non-nil password was not of type CFString";
      goto LABEL_13;
    }
  }
  v20[0] = 0;
  v20[1] = v20;
  v20[2] = 0x2000000000;
  CFStringRef v21 = (CFStringRef)0xAAAAAAAAAAAAAAAALL;
  CFRetain(fqdn);
  CFStringRef v21 = fqdn;
  v18[0] = 0;
  v18[1] = v18;
  void v18[2] = 0x2000000000;
  CFStringRef v19 = (CFStringRef)0xAAAAAAAAAAAAAAAALL;
  CFRetain(account);
  CFStringRef v19 = account;
  v16[0] = 0;
  v16[1] = v16;
  _OWORD v16[2] = 0x2000000000;
  CFStringRef v17 = (CFStringRef)0xAAAAAAAAAAAAAAAALL;
  if (password) {
    CFRetain(password);
  }
  CFStringRef v17 = password;
  uint64_t v13 = v24[3];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecAddSharedWebCredential_block_invoke_2;
  block[3] = &unk_1E5482BE0;
  block[6] = v18;
  void block[7] = v16;
  block[8] = &v27;
  block[9] = &v23;
  block[4] = completionHandler;
  void block[5] = v20;
  dispatch_async(v13, block);
  _Block_object_dispose(v16, 8);
  _Block_object_dispose(v18, 8);
  _Block_object_dispose(v20, 8);
LABEL_14:
  _Block_object_dispose(&v23, 8);
  _Block_object_dispose(&v27, 8);
}

void __SecAddSharedWebCredential_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    (*(void (**)(uint64_t, void))(v2 + 16))(v2, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  }
  uint64_t v3 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (v3)
  {
    CFRelease(v3);
  }
}

void __SecAddSharedWebCredential_block_invoke_2(void *a1)
{
  uint64_t v2 = *(const void **)(*(void *)(a1[5] + 8) + 24);
  uint64_t v3 = *(const void **)(*(void *)(a1[6] + 8) + 24);
  uint64_t v4 = *(const void **)(*(void *)(a1[7] + 8) + 24);
  uint64_t v5 = *(void *)(a1[8] + 8) + 24;
  v21[0] = 0;
  v21[1] = v21;
  void v21[2] = 0x2000000000;
  v21[3] = v5;
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2000000000;
  CFMutableDictionaryRef Mutable = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v2) {
    CFDictionaryAddValue((CFMutableDictionaryRef)v18[3], @"srvr", v2);
  }
  if (v3) {
    CFDictionaryAddValue((CFMutableDictionaryRef)v18[3], @"acct", v3);
  }
  if (v4) {
    CFDictionaryAddValue((CFMutableDictionaryRef)v18[3], @"spwd", v4);
  }
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 0x40000000;
  _OWORD v16[2] = __SecAddSharedWebCredentialSync_block_invoke;
  void v16[3] = &unk_1E5482B68;
  v16[4] = &v17;
  v16[5] = v21;
  int v6 = SecOSStatusWith((uint64_t)v16);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(v21, 8);
  uint64_t v7 = *(const void **)(*(void *)(a1[5] + 8) + 24);
  if (v7) {
    CFRelease(v7);
  }
  CFTypeID v8 = *(const void **)(*(void *)(a1[6] + 8) + 24);
  if (v8) {
    CFRelease(v8);
  }
  CFTypeRef v9 = *(const void **)(*(void *)(a1[7] + 8) + 24);
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = a1[8];
  if (v6)
  {
    uint64_t v11 = *(void *)(v10 + 8);
    uint64_t v13 = *(void *)(v11 + 24);
    CFTypeID v12 = (__CFString **)(v11 + 24);
    if (!v13)
    {
      SecError(v6, v12, @"Error adding shared password");
      uint64_t v10 = a1[8];
    }
  }
  CFAllocatorRef v14 = *(NSObject **)(*(void *)(a1[9] + 8) + 24);
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 0x40000000;
  uint64_t v15[2] = __SecAddSharedWebCredential_block_invoke_3;
  unint64_t v15[3] = &unk_1E5482BB8;
  void v15[4] = a1[4];
  v15[5] = v10;
  dispatch_async(v14, v15);
}

void __SecAddSharedWebCredential_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    (*(void (**)(uint64_t, void))(v2 + 16))(v2, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  }
  uint64_t v3 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (v3)
  {
    CFRelease(v3);
  }
}

void SecRequestSharedWebCredential(CFStringRef fqdn, CFStringRef account, void *completionHandler)
{
  uint64_t v42 = 0;
  CFMutableArrayRef v43 = (__CFString **)&v42;
  uint64_t v44 = 0x2000000000;
  uint64_t v45 = 0;
  uint64_t v38 = 0;
  int v39 = &v38;
  uint64_t v40 = 0x2000000000;
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0, 0);
  v37[0] = 0;
  v37[1] = v37;
  v37[2] = 0x2000000000;
  v37[3] = 0;
  uint64_t v33 = 0;
  long long v34 = &v33;
  uint64_t v35 = 0x2000000000;
  CFStringRef v36 = (CFStringRef)0xAAAAAAAAAAAAAAAALL;
  if (fqdn) {
    CFRetain(fqdn);
  }
  CFStringRef v36 = fqdn;
  uint64_t v29 = 0;
  uint64_t v30 = &v29;
  uint64_t v31 = 0x2000000000;
  CFStringRef v32 = (CFStringRef)0xAAAAAAAAAAAAAAAALL;
  if (account) {
    CFRetain(account);
  }
  CFStringRef v32 = account;
  if (fqdn)
  {
    CFTypeID v6 = CFGetTypeID(fqdn);
    if (v6 != CFStringGetTypeID() || !CFStringGetLength(fqdn))
    {
LABEL_31:
      uint64_t v24 = @"fqdn was empty or not a CFString";
      goto LABEL_33;
    }
  }
  else
  {
    uint64_t v7 = SecTaskCreateFromSelf(0);
    if (v7)
    {
      CFTypeID v8 = v7;
      CFArrayRef v9 = (const __CFArray *)SecTaskCopyValueForEntitlement(v7, @"com.apple.developer.associated-domains", 0);
      if (v9)
      {
        CFArrayRef v10 = v9;
        CFIndex Count = CFArrayGetCount(v9);
        CFIndex v12 = Count - 1;
        if (Count >= 1)
        {
          CFIndex v13 = 0;
          do
          {
            CFDataRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v10, v13);
            if ([ValueAtIndex hasPrefix:@"webcredentials:"])
            {
              CFArrayRef v15 = [ValueAtIndex substringFromIndex:objc_msgSend(@"webcredentials:", "length")];
              if ([v15 length]) {
                id v16 = v15;
              }
              else {
                id v16 = 0;
              }
            }
            else
            {
              id v16 = 0;
            }
            void v34[3] = (uint64_t)v16;
            if (v16) {
              break;
            }
          }
          while (v12 != v13++);
        }
        CFRelease(v10);
      }
      CFRelease(v8);
    }
  }
  uint64_t v18 = (const void *)v34[3];
  if (!v18)
  {
    uint64_t v24 = @"fqdn was NULL, and no associated domains found";
    goto LABEL_33;
  }
  CFTypeID v19 = CFGetTypeID(v18);
  if (v19 != CFStringGetTypeID() || !CFStringGetLength((CFStringRef)v34[3])) {
    goto LABEL_31;
  }
  uint64_t v20 = (const void *)v30[3];
  if (!v20 || (CFTypeID v21 = CFGetTypeID(v20), v21 == CFStringGetTypeID()) && CFStringGetLength((CFStringRef)v30[3]))
  {
    CFDictionaryRef v22 = v39[3];
    v27[0] = MEMORY[0x1E4F143A8];
    v27[1] = 0x40000000;
    void v27[2] = __SecRequestSharedWebCredential_block_invoke_2;
    unint64_t v27[3] = &unk_1E5482C58;
    void v27[6] = &v29;
    v27[7] = v37;
    v27[8] = &v42;
    v27[9] = &v38;
    uint8_t v27[4] = completionHandler;
    v27[5] = &v33;
    uint64_t v23 = v27;
    goto LABEL_38;
  }
  uint64_t v24 = @"account was empty or not a CFString";
LABEL_33:
  uint64_t v25 = (const void *)v34[3];
  if (v25) {
    CFRelease(v25);
  }
  unint64_t v26 = (const void *)v30[3];
  if (v26) {
    CFRelease(v26);
  }
  SecError(-50, v43 + 3, @"%@", v24);
  CFDictionaryRef v22 = v39[3];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecRequestSharedWebCredential_block_invoke;
  block[3] = &unk_1E5482C08;
  block[4] = completionHandler;
  void block[5] = v37;
  block[6] = &v42;
  uint64_t v23 = block;
LABEL_38:
  dispatch_async(v22, v23);
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v33, 8);
  _Block_object_dispose(v37, 8);
  _Block_object_dispose(&v38, 8);
  _Block_object_dispose(&v42, 8);
}

void __SecRequestSharedWebCredential_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2) {
    (*(void (**)(uint64_t, void, void))(v2 + 16))(v2, *(void *)(*(void *)(a1[5] + 8) + 24), *(void *)(*(void *)(a1[6] + 8) + 24));
  }
  uint64_t v3 = *(const void **)(*(void *)(a1[6] + 8) + 24);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(*(void *)(a1[5] + 8) + 24);
  if (v4)
  {
    CFRelease(v4);
  }
}

void __SecRequestSharedWebCredential_block_invoke_2(void *a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(*(void *)(a1[5] + 8) + 24);
  uint64_t v3 = *(void *)(a1[7] + 8);
  uint64_t v4 = *(void *)(a1[8] + 8);
  uint64_t v5 = objc_alloc_init(SharedCredentialController);
  CFTypeID v6 = [(SharedCredentialController *)v5 passwordCredential];
  int v7 = [(SharedCredentialController *)v5 result];
  if (v7)
  {
    int v8 = v7;
    CFArrayRef v9 = secLogObjForScope("swcagent");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v8;
      _os_log_debug_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEBUG, "SecCopySharedWebCredentialSync received result %d", buf, 8u);
    }

    *(void *)(v4 + 24) = [(SharedCredentialController *)v5 error];
    CFArrayRef v10 = (void *)MEMORY[0x1E4F1CBF0];
  }
  else if (v6)
  {
    *(void *)long long buf = v2;
    v26[0] = @"srvr";
    v26[1] = @"acct";
    uint64_t v11 = [v6 user];
    CFRange v28 = v11;
    v26[2] = @"spwd";
    CFIndex v12 = [v6 password];
    uint64_t v29 = v12;
    CFIndex v13 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:buf forKeys:v26 count:3];

    uint64_t v25 = v13;
    CFArrayRef v10 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v25 count:1];

    int v8 = 0;
  }
  else
  {
    CFAllocatorRef v14 = secLogObjForScope("swcagent");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEBUG, "SecCopySharedWebCredentialSync found no credential", buf, 2u);
    }

    CFArrayRef v10 = (void *)MEMORY[0x1E4F1CBF0];
    int v8 = -25300;
  }
  id v15 = v10;
  *(void *)(v3 + 24) = v15;

  id v16 = *(const void **)(*(void *)(a1[5] + 8) + 24);
  if (v16) {
    CFRelease(v16);
  }
  uint64_t v17 = *(const void **)(*(void *)(a1[6] + 8) + 24);
  if (v17) {
    CFRelease(v17);
  }
  uint64_t v18 = a1[8];
  if (v8)
  {
    uint64_t v19 = *(void *)(v18 + 8);
    uint64_t v21 = *(void *)(v19 + 24);
    uint64_t v20 = (__CFString **)(v19 + 24);
    if (!v21)
    {
      SecError(v8, v20, @"Error copying shared password");
      uint64_t v18 = a1[8];
    }
  }
  CFDictionaryRef v22 = *(NSObject **)(*(void *)(a1[9] + 8) + 24);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecRequestSharedWebCredential_block_invoke_3;
  block[3] = &unk_1E5482C30;
  uint64_t v23 = a1[7];
  block[4] = a1[4];
  void block[5] = v23;
  block[6] = v18;
  dispatch_async(v22, block);
}

void __SecRequestSharedWebCredential_block_invoke_3(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2) {
    (*(void (**)(uint64_t, void, void))(v2 + 16))(v2, *(void *)(*(void *)(a1[5] + 8) + 24), *(void *)(*(void *)(a1[6] + 8) + 24));
  }
  uint64_t v3 = *(const void **)(*(void *)(a1[6] + 8) + 24);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(*(void *)(a1[5] + 8) + 24);
  if (v4)
  {
    CFRelease(v4);
  }
}

CFStringRef SecCreateSharedWebCredentialPassword(void)
{
  CFDictionaryRef v15 = 0;
  CFCharacterSetRef v0 = CFCharacterSetCreateWithCharactersInString(0, @"abcdefghkmnopqrstuvwxyz");
  CFCharacterSetRef v1 = CFCharacterSetCreateWithCharactersInString(0, @"ABCDEFGHJKLMNPQRSTUVWXYZ");
  CFCharacterSetRef v2 = CFCharacterSetCreateWithCharactersInString(0, @"3456789");
  int v13 = 4;
  int valuePtr = 3;
  int v12 = 12;
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberIntType, &v13);
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &v12);
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue(Mutable, v0);
  CFArrayAppendValue(Mutable, v1);
  CFArrayAppendValue(Mutable, v2);
  int v7 = CFDictionaryCreateMutable(0, 0, 0, 0);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordAllowedCharactersKey, @"abcdefghkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789");
  CFDictionaryAddValue(v7, (const void *)kSecPasswordRequiredCharactersKey, Mutable);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordGroupSize, v3);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordNumberOfGroups, v4);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordSeparator, @"-");
  CFDictionaryAddValue(v7, (const void *)kSecPasswordMaxLengthKey, v5);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordMinLengthKey, v5);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordDefaultForType, @"false");
  CFRelease(v0);
  CFRelease(v1);
  CFRelease(v2);
  CFRelease(v3);
  CFRelease(v4);
  CFRelease(v5);
  CFStringRef v8 = SecPasswordGenerate(0, &v15, v7);
  CFRelease(Mutable);
  CFRelease(v7);
  if (v15 || !v8)
  {
    if (v8) {
      CFRelease(v8);
    }
    CFArrayRef v9 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v11 = 0;
      _os_log_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEFAULT, "SecPasswordGenerate failed to generate a password for SecCreateSharedWebCredentialPassword.", v11, 2u);
    }
    return 0;
  }
  return v8;
}

__CFData *SecRecreateSignatureWithDERAlgorithmId(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  CFMutableDictionaryRef Mutable = 0;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    if (SecKeyGetAlgorithmId(a1) == 3)
    {
      uint64_t v7 = *(void *)MEMORY[0x18C12DA70]();
      size_t v8 = 8 * v7;
      ((void (*)(void))MEMORY[0x1F4188790])();
      unint64_t v9 = (8 * v7 + 15) & 0xFFFFFFFFFFFFFFF0;
      if (v7)
      {
        CFArrayRef v10 = memset((char *)&v17 - v9, 170, v8);
        MEMORY[0x1F4188790](v10);
        memset((char *)&v17 - v9, 170, v8);
      }
      uint64_t v18 = a3 + a4;
      ccder_decode_sequence_tl();
      mp_decode_forced_uint();
      uint64_t v11 = mp_decode_forced_uint();
      if (v11) {
        BOOL v12 = v18 == v11;
      }
      else {
        BOOL v12 = 0;
      }
      if (!v12) {
        return 0;
      }
      ccder_sizeof_integer();
      ccder_sizeof_integer();
      unint64_t v13 = ccder_sizeof();
      if (v13 < a4 || v13 > a4 + 5) {
        return 0;
      }
      CFIndex v16 = v13;
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, v13);
      CFDataSetLength(Mutable, v16);
      CFDataGetMutableBytePtr(Mutable);
      ccder_encode_integer();
      ccder_encode_integer();
      if (!ccder_encode_constructed_tl() && Mutable)
      {
        CFRelease(Mutable);
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return Mutable;
}

CFStringRef SecTrustCopyDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<SecTrustRef: %p>", a1);
}

CFStringRef SecTrustCopyFormatDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<SecTrustRef: %p>", a1);
}

uint64_t SecTrustCopyInputCertificates(uint64_t a1, void *a2)
{
  uint64_t v2 = 4294967246;
  if (a1 && a2)
  {
    uint64_t v8 = 0;
    unint64_t v9 = &v8;
    uint64_t v10 = 0x2000000000;
    uint64_t v11 = 0;
    CFNumberRef v4 = *(NSObject **)(a1 + 136);
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    _DWORD v7[2] = __SecTrustCopyInputCertificates_block_invoke;
    unint64_t v7[3] = &unk_1E5482DC0;
    UInt8 v7[4] = &v8;
    void v7[5] = a1;
    dispatch_sync(v4, v7);
    uint64_t v5 = v9[3];
    if (v5)
    {
      uint64_t v2 = 0;
      *a2 = v5;
    }
    else
    {
      uint64_t v2 = 4294967188;
    }
    _Block_object_dispose(&v8, 8);
  }
  return v2;
}

CFArrayRef __SecTrustCopyInputCertificates_block_invoke(uint64_t a1)
{
  CFArrayRef result = CFArrayCreateCopy(0, *(CFArrayRef *)(*(void *)(a1 + 40) + 16));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t SecTrustAddToInputCertificates(uint64_t a1, const void *a2)
{
  uint64_t v2 = 4294967246;
  if (a1 && a2)
  {
    uint64_t v18 = 0;
    uint64_t v19 = &v18;
    uint64_t v20 = 0x2000000000;
    uint64_t v21 = 0;
    uint64_t v5 = *(NSObject **)(a1 + 136);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __SecTrustAddToInputCertificates_block_invoke;
    block[3] = &unk_1E5482DE8;
    block[4] = &v18;
    void block[5] = a1;
    dispatch_sync(v5, block);
    CFTypeID v6 = CFGetTypeID(a2);
    if (v6 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)v19[3]);
      context[0] = MEMORY[0x1E4F143A8];
      context[1] = 0x40000000;
      context[2] = __SecTrustAddToInputCertificates_block_invoke_2;
      context[3] = &unk_1E5482E10;
      void context[4] = &v18;
      v27.CFIndex length = CFArrayGetCount((CFArrayRef)a2);
      v27.CFIndex location = 0;
      CFArrayApplyFunction((CFArrayRef)a2, v27, (CFArrayApplierFunction)apply_block_1_13885, context);
      CFIndex v8 = CFArrayGetCount((CFArrayRef)v19[3]);
      if (v8 != CFArrayGetCount((CFArrayRef)a2) + Count)
      {
LABEL_11:
        unint64_t v13 = (const void *)v19[3];
        if (v13)
        {
          v19[3] = 0;
          CFRelease(v13);
        }
        uint64_t v2 = 4294967246;
        goto LABEL_14;
      }
    }
    else
    {
      CFTypeID v9 = CFGetTypeID(a2);
      if (v9 != SecCertificateGetTypeID())
      {
        BOOL v12 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_18B299000, v12, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: certificates contains unsupported value type", buf, 2u);
        }
        goto LABEL_11;
      }
      CFArrayAppendValue((CFMutableArrayRef)v19[3], a2);
    }
    uint64_t v10 = *(NSObject **)(a1 + 136);
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 0x40000000;
    uint64_t v15[2] = __SecTrustAddToInputCertificates_block_invoke_66;
    unint64_t v15[3] = &unk_1E5482E38;
    void v15[4] = &v18;
    v15[5] = a1;
    dispatch_sync(v10, v15);
    uint64_t v11 = *(NSObject **)(a1 + 136);
    *(void *)long long buf = MEMORY[0x1E4F143A8];
    uint64_t v23 = 0x40000000;
    uint64_t v24 = __SecTrustSetNeedsEvaluation_block_invoke;
    uint64_t v25 = &__block_descriptor_tmp_68_13884;
    uint64_t v26 = a1;
    dispatch_sync(v11, buf);
    uint64_t v2 = 0;
LABEL_14:
    _Block_object_dispose(&v18, 8);
  }
  return v2;
}

CFMutableArrayRef __SecTrustAddToInputCertificates_block_invoke(uint64_t a1)
{
  CFMutableArrayRef result = CFArrayCreateMutableCopy(0, 0, *(CFArrayRef *)(*(void *)(a1 + 40) + 16));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void __SecTrustAddToInputCertificates_block_invoke_2(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == SecCertificateGetTypeID())
  {
    uint64_t v5 = *(__CFArray **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    CFArrayAppendValue(v5, cf);
  }
  else
  {
    CFTypeID v6 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: certificates array contains non-certificate value", v7, 2u);
    }
  }
}

void __SecTrustAddToInputCertificates_block_invoke_66(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  CFNumberRef v3 = *(const void **)(v2 + 16);
  if (v3)
  {
    *(void *)(v2 + 16) = 0;
    CFRelease(v3);
    uint64_t v2 = *(void *)(a1 + 40);
  }
  *(void *)(v2 + 16) = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t apply_block_1_13885(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void SecTrustSetNeedsEvaluation(uint64_t a1)
{
  if (a1)
  {
    CFCharacterSetRef v1 = *(NSObject **)(a1 + 136);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
    block[3] = &__block_descriptor_tmp_68_13884;
    block[4] = a1;
    dispatch_sync(v1, block);
  }
}

OSStatus SecTrustSetAnchorCertificatesOnly(SecTrustRef trust, Boolean anchorCertificatesOnly)
{
  if (!trust) {
    return -50;
  }
  CFTypeID v4 = *((void *)trust + 17);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_68_13884;
  block[4] = trust;
  dispatch_sync(v4, block);
  uint64_t v5 = *((void *)trust + 17);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  _DWORD v7[2] = __SecTrustSetAnchorCertificatesOnly_block_invoke;
  unint64_t v7[3] = &__block_descriptor_tmp_69_13890;
  UInt8 v7[4] = trust;
  Boolean v8 = anchorCertificatesOnly;
  dispatch_sync(v5, v7);
  return 0;
}

uint64_t __SecTrustSetAnchorCertificatesOnly_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 116) = *(unsigned char *)(result + 40) != 0;
  return result;
}

OSStatus SecTrustCopyCustomAnchorCertificates(SecTrustRef trust, CFArrayRef *anchors)
{
  OSStatus v2 = -50;
  if (trust && anchors)
  {
    uint64_t v7 = 0;
    Boolean v8 = &v7;
    uint64_t v9 = 0x2000000000;
    uint64_t v10 = 0;
    CFTypeID v4 = *((void *)trust + 17);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __SecTrustCopyCustomAnchorCertificates_block_invoke;
    unint64_t v6[3] = &unk_1E5482EC8;
    void v6[4] = &v7;
    void v6[5] = trust;
    dispatch_sync(v4, v6);
    *anchors = (CFArrayRef)v8[3];
    _Block_object_dispose(&v7, 8);
    return 0;
  }
  return v2;
}

CFArrayRef __SecTrustCopyCustomAnchorCertificates_block_invoke(CFArrayRef result)
{
  CFArrayRef v1 = *(const __CFArray **)(*((void *)result + 5) + 24);
  if (v1)
  {
    CFArrayRef v2 = result;
    CFMutableArrayRef result = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1);
    *(void *)(*(void *)(*((void *)v2 + 4) + 8) + 24) = result;
  }
  return result;
}

uint64_t SecTrustFlushResponseCache(CFTypeRef *a1)
{
  return SecTrustResetSettings(10, a1);
}

uint64_t SecTrustResetSettings(uint64_t a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  CFTypeID v4 = _os_activity_create(&dword_18B299000, "SecTrustResetSettings", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &state);
  if (gTrustd && (uint64_t v5 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gTrustd + 240)) != 0)
  {
    uint64_t v6 = v5(a1, &cf);
  }
  else
  {
    uint64_t v13 = 0;
    CFAllocatorRef v14 = &v13;
    uint64_t v15 = 0x2000000000;
    char v16 = 0;
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 0x40000000;
    _OWORD v11[2] = __int_to_BOOL_error_request_block_invoke;
    unint64_t v11[3] = &__block_descriptor_tmp_611;
    int v12 = a1;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 0x40000000;
    _OWORD v10[2] = __int_to_BOOL_error_request_block_invoke_2;
    unint64_t v10[3] = &unk_1E54842D0;
    UInt8 v10[4] = &v13;
    securityd_send_sync_and_do(0x82u, &cf, (uint64_t)v11, (uint64_t)v10);
    uint64_t v6 = *((unsigned char *)v14 + 24) != 0;
    _Block_object_dispose(&v13, 8);
  }
  os_release(v4);
  if (a2)
  {
    *a2 = cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  os_activity_scope_leave(&state);
  return v6;
}

OSStatus SecTrustSetSignedCertificateTimestamps(SecTrustRef trust, CFArrayRef sctArray)
{
  if (!trust) {
    return -50;
  }
  CFTypeID v4 = *((void *)trust + 17);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_68_13884;
  block[4] = trust;
  dispatch_sync(v4, block);
  uint64_t v5 = *((void *)trust + 17);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  _DWORD v7[2] = __SecTrustSetSignedCertificateTimestamps_block_invoke;
  unint64_t v7[3] = &__block_descriptor_tmp_73_13900;
  UInt8 v7[4] = trust;
  void v7[5] = sctArray;
  dispatch_sync(v5, v7);
  return 0;
}

void __SecTrustSetSignedCertificateTimestamps_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFArrayRef v1 = *(const void **)(a1 + 40);
  CFNumberRef v3 = *(const void **)(v2 + 48);
  if (v3 != v1)
  {
    if (!v1 || (CFRetain(v1), (CFNumberRef v3 = *(const void **)(v2 + 48)) != 0)) {
      CFRelease(v3);
    }
    *(void *)(v2 + 48) = v1;
  }
}

uint64_t SecTrustSetTrustedLogs(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 4294967246;
  }
  CFTypeID v4 = *(NSObject **)(a1 + 136);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_68_13884;
  block[4] = a1;
  dispatch_sync(v4, block);
  uint64_t v5 = *(NSObject **)(a1 + 136);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  _DWORD v7[2] = __SecTrustSetTrustedLogs_block_invoke;
  unint64_t v7[3] = &__block_descriptor_tmp_74_13901;
  UInt8 v7[4] = a1;
  void v7[5] = a2;
  dispatch_sync(v5, v7);
  return 0;
}

void __SecTrustSetTrustedLogs_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFArrayRef v1 = *(const void **)(a1 + 40);
  CFNumberRef v3 = *(const void **)(v2 + 56);
  if (v3 != v1)
  {
    if (!v1 || (CFRetain(v1), (CFNumberRef v3 = *(const void **)(v2 + 56)) != 0)) {
      CFRelease(v3);
    }
    *(void *)(v2 + 56) = v1;
  }
}

OSStatus SecTrustSetPolicies(SecTrustRef trust, CFTypeRef policies)
{
  values = (void *)policies;
  OSStatus v2 = -50;
  if (trust && policies)
  {
    uint64_t v5 = *((void *)trust + 17);
    blocCFIndex k = MEMORY[0x1E4F143A8];
    p_blocCFIndex k = 0x40000000;
    uint64_t v26 = (uint64_t)__SecTrustSetNeedsEvaluation_block_invoke;
    CFRange v27 = &__block_descriptor_tmp_68_13884;
    SecTrustRef v28 = trust;
    dispatch_sync(v5, &block);
    blocCFIndex k = 0;
    p_blocCFIndex k = (uint64_t)&block;
    uint64_t v26 = 0x2000000000;
    CFRange v27 = 0;
    CFTypeID v6 = CFGetTypeID(policies);
    if (v6 == CFArrayGetTypeID())
    {
      uint64_t Count = CFArrayGetCount((CFArrayRef)policies);
      if (Count < 1)
      {
LABEL_21:
        OSStatus v2 = -50;
        goto LABEL_22;
      }
      uint64_t v8 = Count;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E4F1D510]);
      *(void *)(p_block + 24) = Mutable;
      if (!Mutable)
      {
        OSStatus v2 = -108;
        goto LABEL_22;
      }
      for (CFIndex i = 0; i != v8; ++i)
      {
        CFDataRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)policies, i);
        if (ValueAtIndex && (int v12 = ValueAtIndex, v13 = CFGetTypeID(ValueAtIndex), v13 == SecPolicyGetTypeID()))
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(p_block + 24), v12);
        }
        else
        {
          CFAllocatorRef v14 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: newPolicies array contains non-policy value", buf, 2u);
          }
        }
      }
      if (v8 != CFArrayGetCount(*(CFArrayRef *)(p_block + 24)))
      {
        uint64_t v15 = *(const void **)(p_block + 24);
        if (v15) {
          CFRelease(v15);
        }
        goto LABEL_21;
      }
    }
    else
    {
      CFTypeID v16 = CFGetTypeID(policies);
      if (v16 != SecPolicyGetTypeID())
      {
        uint64_t v19 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: newPolicies contains unsupported value type", buf, 2u);
        }
        goto LABEL_21;
      }
      CFArrayRef v17 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
      *(void *)(p_block + 24) = v17;
    }
    uint64_t v18 = *((void *)trust + 17);
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 0x40000000;
    void v21[2] = __SecTrustSetPolicies_block_invoke;
    v21[3] = &unk_1E5482F78;
    void v21[4] = &block;
    void v21[5] = trust;
    dispatch_sync(v18, v21);
    OSStatus v2 = 0;
LABEL_22:
    _Block_object_dispose(&block, 8);
  }
  return v2;
}

void __SecTrustSetPolicies_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  CFNumberRef v3 = *(const void **)(v2 + 32);
  if (v3)
  {
    CFRelease(v3);
    uint64_t v2 = *(void *)(a1 + 40);
  }
  *(void *)(v2 + 32) = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t SecTrustSetKeychainsAllowed(uint64_t a1, char a2)
{
  if (!a1) {
    return 4294967246;
  }
  CFTypeID v4 = *(NSObject **)(a1 + 136);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_68_13884;
  block[4] = a1;
  dispatch_sync(v4, block);
  uint64_t v5 = *(NSObject **)(a1 + 136);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  _DWORD v7[2] = __SecTrustSetKeychainsAllowed_block_invoke;
  unint64_t v7[3] = &__block_descriptor_tmp_80_13912;
  UInt8 v7[4] = a1;
  char v8 = a2;
  dispatch_sync(v5, v7);
  return 0;
}

uint64_t __SecTrustSetKeychainsAllowed_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 117) = *(unsigned char *)(result + 40) != 0;
  return result;
}

uint64_t SecTrustGetKeychainsAllowed(uint64_t a1, unsigned char *a2)
{
  uint64_t result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      *a2 = *(unsigned char *)(a1 + 117);
    }
  }
  return result;
}

OSStatus SecTrustSetNetworkFetchAllowed(SecTrustRef trust, Boolean allowFetch)
{
  if (!trust) {
    return -50;
  }
  int v2 = allowFetch;
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000;
  int v17 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  char v13 = 1;
  CFTypeID v4 = *((void *)trust + 17);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecTrustSetNetworkFetchAllowed_block_invoke;
  block[3] = &unk_1E5483030;
  void block[5] = &v14;
  void block[6] = trust;
  Boolean v9 = allowFetch;
  block[4] = &v10;
  dispatch_sync(v4, block);
  if (v2 && !*((unsigned char *)v11 + 24))
  {
    uint64_t v5 = *((void *)trust + 17);
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 0x40000000;
    void v18[2] = __SecTrustSetNeedsEvaluation_block_invoke;
    void v18[3] = &__block_descriptor_tmp_68_13884;
    void v18[4] = trust;
    dispatch_sync(v5, v18);
  }
  OSStatus v6 = *((_DWORD *)v15 + 6);
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
  return v6;
}

uint64_t __SecTrustSetNetworkFetchAllowed_block_invoke(uint64_t a1)
{
  int v2 = SecTrustCopyOptionsFromPolicies(*(const __CFArray **)(*(void *)(a1 + 48) + 32));
  if (v2)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    CFRelease(v2);
  }
  uint64_t v3 = *(void *)(a1 + 48);
  CFArrayRef v4 = *(const __CFArray **)(v3 + 32);
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t result = SecTrustRemoveOptionInPolicies(*(const void **)(v3 + 32), @"NoNetworkAccess");
  }
  else if (v4 && (CFTypeID v6 = CFGetTypeID(*(CFTypeRef *)(v3 + 32)), v6 == CFArrayGetTypeID()))
  {
    CFIndex v7 = 0;
    char v8 = (const void *)*MEMORY[0x1E4F1CFD0];
    while (1)
    {
      if (CFArrayGetCount(v4) <= v7)
      {
        uint64_t result = 0;
        goto LABEL_15;
      }
      CFDataRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v4, v7);
      if (!ValueAtIndex) {
        goto LABEL_16;
      }
      uint64_t v10 = ValueAtIndex;
      CFDataRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, ValueAtIndex[4]);
      if (!MutableCopy) {
        break;
      }
      uint64_t v12 = MutableCopy;
      CFDictionarySetValue(MutableCopy, @"NoNetworkAccess", v8);
      CFDictionaryRef v13 = v10[4];
      if (v13)
      {
        UInt8 v10[4] = 0;
        CFRelease(v13);
      }
      UInt8 v10[4] = v12;
      ++v7;
    }
    uint64_t result = 4294967188;
  }
  else
  {
LABEL_16:
    uint64_t result = 4294941020;
  }
LABEL_15:
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

__CFArray *SecTrustCopyOptionsFromPolicies(const __CFArray *a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  for (CFIndex i = 0; CFArrayGetCount(a1) > i; ++i)
  {
    CFDataRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(a1, i);
    CFArrayRef Value = CFDictionaryGetValue(ValueAtIndex[4], @"NoNetworkAccess");
    if (Value) {
      CFArrayAppendValue(Mutable, Value);
    }
  }
  if (!CFArrayGetCount(Mutable) && Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t SecTrustRemoveOptionInPolicies(const void *a1, const void *a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 != CFArrayGetTypeID()) {
      return 4294941020;
    }
    for (CFIndex i = 0; ; ++i)
    {
      if (CFArrayGetCount((CFArrayRef)a1) <= i) {
        return 0;
      }
      CFDataRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex((CFArrayRef)a1, i);
      if (!ValueAtIndex) {
        return 4294941020;
      }
      CFIndex v7 = ValueAtIndex;
      if (CFDictionaryGetValue(ValueAtIndex[4], a2))
      {
        CFDataRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v7[4]);
        if (!MutableCopy) {
          return 4294967188;
        }
        Boolean v9 = MutableCopy;
        CFDictionaryRemoveValue(MutableCopy, a2);
        CFDictionaryRef v10 = v7[4];
        if (v10)
        {
          UInt8 v7[4] = 0;
          CFRelease(v10);
        }
        UInt8 v7[4] = v9;
      }
    }
  }
  return 4294941020;
}

OSStatus SecTrustGetNetworkFetchAllowed(SecTrustRef trust, Boolean *allowFetch)
{
  OSStatus v2 = -50;
  if (trust && allowFetch)
  {
    uint64_t v11 = 0;
    uint64_t v12 = &v11;
    uint64_t v13 = 0x2000000000;
    uint64_t v14 = 0;
    CFTypeID v4 = *((void *)trust + 17);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __SecTrustGetNetworkFetchAllowed_block_invoke;
    block[3] = &unk_1E5483058;
    block[4] = &v11;
    void block[5] = trust;
    dispatch_sync(v4, block);
    uint64_t v5 = v12;
    CFArrayRef v6 = (const __CFArray *)v12[3];
    if (v6)
    {
      context[0] = MEMORY[0x1E4F143A8];
      context[1] = 0x40000000;
      context[2] = __SecTrustGetNetworkFetchAllowed_block_invoke_2;
      context[3] = &__block_descriptor_tmp_85;
      void context[4] = allowFetch;
      v15.CFIndex length = CFArrayGetCount(v6);
      v15.CFIndex location = 0;
      CFArrayApplyFunction(v6, v15, (CFArrayApplierFunction)apply_block_1_13885, context);
      uint64_t v5 = v12;
    }
    else
    {
      *allowFetch = 1;
    }
    CFIndex v7 = (const void *)v5[3];
    if (v7)
    {
      v5[3] = 0;
      CFRelease(v7);
    }
    _Block_object_dispose(&v11, 8);
    return 0;
  }
  return v2;
}

uint64_t __SecTrustGetNetworkFetchAllowed_block_invoke_2(uint64_t result, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(cf);
    uint64_t result = CFBooleanGetTypeID();
    if (v4 == result)
    {
      uint64_t result = CFBooleanGetValue((CFBooleanRef)cf);
      **(unsigned char **)(v3 + 32) = result == 0;
    }
  }
  return result;
}

uint64_t SecTrustSetPinningException(uint64_t a1)
{
  if (!a1) {
    return 4294967246;
  }
  uint64_t v5 = 0;
  CFArrayRef v6 = &v5;
  uint64_t v7 = 0x2000000000;
  int v8 = 0;
  CFArrayRef v1 = *(NSObject **)(a1 + 136);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  void v4[2] = __SecTrustSetPinningException_block_invoke;
  v4[3] = &unk_1E54830A8;
  void v4[4] = &v5;
  void v4[5] = a1;
  dispatch_sync(v1, v4);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecTrustSetPinningException_block_invoke(uint64_t a1)
{
  uint64_t result = SecTrustRemoveOptionInPolicies(*(const void **)(*(void *)(a1 + 40) + 32), @"PinningRequired");
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

__SecTrust *SecTrustGetDetails(__SecTrust *result)
{
  if (result)
  {
    CFArrayRef v1 = result;
    SecTrustEvaluateIfNecessary(result);
    return (__SecTrust *)*((void *)v1 + 11);
  }
  return result;
}

void __SecTrustAddPolicyAnchors_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(const void **)(v2 + 24);
  if (v3)
  {
    CFRelease(v3);
    uint64_t v2 = *(void *)(a1 + 40);
  }
  *(void *)(v2 + 24) = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

os_log_t __SecTrustEvaluateThreadRuntimeCheck_block_invoke_3()
{
  os_log_t result = os_log_create("com.apple.runtime-issues", "Security");
  checkmap_block_invoke_2_runtimeLog = (uint64_t)result;
  return result;
}

OSStatus SecTrustGetTrustResult(SecTrustRef trust, SecTrustResultType *result)
{
  OSStatus v3 = -50;
  if (trust)
  {
    if (result)
    {
      SecTrustEvaluateIfNecessary(trust);
      uint64_t v5 = *((void *)trust + 17);
      v6[0] = MEMORY[0x1E4F143A8];
      v6[1] = 0x40000000;
      v6[2] = __SecTrustGetTrustResult_block_invoke;
      unint64_t v6[3] = &__block_descriptor_tmp_88_13972;
      void v6[4] = result;
      void v6[5] = trust;
      dispatch_sync(v5, v6);
      return 0;
    }
  }
  return v3;
}

uint64_t __SecTrustGetTrustResult_block_invoke(uint64_t result)
{
  **(_DWORD **)(result + 32) = *(_DWORD *)(*(void *)(result + 40) + 112);
  return result;
}

__SecTrust *SecTrustCopyFilteredDetails(__SecTrust *a1)
{
  CFArrayRef v1 = a1;
  if (a1)
  {
    SecTrustEvaluateIfNecessary(a1);
    uint64_t v5 = 0;
    CFArrayRef v6 = &v5;
    uint64_t v7 = 0x2000000000;
    uint64_t v8 = 0;
    uint64_t v2 = *((void *)v1 + 17);
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 0x40000000;
    void v4[2] = __SecTrustCopyFilteredDetails_block_invoke;
    v4[3] = &unk_1E5483118;
    void v4[4] = &v5;
    void v4[5] = v1;
    dispatch_sync(v2, v4);
    CFArrayRef v1 = (__SecTrust *)v6[3];
    _Block_object_dispose(&v5, 8);
  }
  return v1;
}

void *__SecTrustCopyFilteredDetails_block_invoke(void *result)
{
  CFArrayRef v1 = result;
  uint64_t v2 = result[5];
  uint64_t v3 = *(void *)(v2 + 88);
  if (v3) {
    os_log_t result = CFRetain(*(CFTypeRef *)(v2 + 88));
  }
  *(void *)(*(void *)(v1[4] + 8) + 24) = v3;
  return result;
}

uint64_t SecTrustIsExpiredOnly(__SecTrust *a1)
{
  CFArrayRef v1 = SecTrustCopyFilteredDetails(a1);
  if (v1)
  {
    CFArrayRef v2 = v1;
    CFIndex Count = CFArrayGetCount(v1);
    if (Count >= 1)
    {
      CFIndex v4 = Count;
      CFIndex v5 = 0;
      unsigned __int8 v6 = 0;
      uint64_t v7 = (const void *)*MEMORY[0x1E4F1CFC8];
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, v5);
        if (ValueAtIndex)
        {
          CFDictionaryRef v9 = ValueAtIndex;
          CFIndex v10 = CFDictionaryGetCount(ValueAtIndex);
          if (v10 > 1) {
            break;
          }
          if (v10)
          {
            CFArrayRef Value = CFDictionaryGetValue(v9, @"TemporalValidity");
            if (!Value) {
              break;
            }
            uint64_t v12 = Value;
            CFTypeID v13 = CFGetTypeID(Value);
            if (v13 != CFBooleanGetTypeID() || !CFEqual(v12, v7)) {
              break;
            }
            unsigned __int8 v6 = 1;
          }
        }
        if (v4 == ++v5) {
          goto LABEL_14;
        }
      }
    }
    unsigned __int8 v6 = 0;
LABEL_14:
    CFRelease(v2);
  }
  else
  {
    return 0;
  }
  return v6;
}

__CFString *SecTrustCopyFailureDescription(__SecTrust *a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  CFMutableArrayRef Mutable = CFStringCreateMutable(0, 0);
  SecTrustEvaluateIfNecessary(a1);
  uint64_t v26 = 0;
  CFRange v27 = &v26;
  uint64_t v28 = 0x2000000000;
  uint64_t v29 = 0;
  uint64_t v3 = *((void *)a1 + 17);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecTrustCopyFailureDescription_block_invoke;
  block[3] = &unk_1E54836D0;
  block[4] = &v26;
  void block[5] = a1;
  dispatch_sync(v3, block);
  CFArrayRef v4 = (const __CFArray *)v27[3];
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(v4);
    CFIndex v22 = Count - 1;
    CFIndex v23 = Count;
    if (Count >= 1)
    {
      CFIndex v6 = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v27[3], v6);
        CFIndex v8 = CFDictionaryGetCount(ValueAtIndex);
        if (v8 >= 1) {
          break;
        }
LABEL_18:
        if (++v6 == v23) {
          goto LABEL_19;
        }
      }
      size_t v9 = v8;
      if (v6)
      {
        if (v6 != v22)
        {
          CFStringAppendFormat(Mutable, 0, @" [ca%ld", v6);
LABEL_12:
          uint64_t v24 = &v22;
          MEMORY[0x1F4188790](v12);
          uint64_t v14 = (const void **)((char *)&v22 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
          memset(v14, 170, v13);
          CFDictionaryGetKeysAndValues(ValueAtIndex, v14, 0);
          qsort(v14, v9, 8uLL, (int (__cdecl *)(const void *, const void *))compare_strings);
          do
          {
            uint64_t v16 = *v14++;
            CFRange v15 = v16;
            CFArrayRef Value = (__CFString *)CFDictionaryGetValue(ValueAtIndex, v16);
            CFTypeID v18 = CFGetTypeID(Value);
            if (v18 == CFBooleanGetTypeID()) {
              uint64_t v19 = &stru_1ED84D0B0;
            }
            else {
              uint64_t v19 = Value;
            }
            CFStringAppendFormat(Mutable, 0, @" %@%@", v15, v19);
            --v9;
          }
          while (v9);
          CFStringAppend(Mutable, @"]");
          goto LABEL_18;
        }
        CFIndex v10 = Mutable;
        CFStringRef v11 = @" [root";
      }
      else
      {
        CFIndex v10 = Mutable;
        CFStringRef v11 = @" [leaf";
      }
      CFStringAppend(v10, v11);
      goto LABEL_12;
    }
  }
LABEL_19:
  uint64_t v20 = (const void *)v27[3];
  if (v20) {
    CFRelease(v20);
  }
  _Block_object_dispose(&v26, 8);
  return Mutable;
}

void *__SecTrustCopyFailureDescription_block_invoke(void *result)
{
  CFArrayRef v1 = result;
  uint64_t v2 = result[5];
  uint64_t v3 = *(void *)(v2 + 88);
  if (v3) {
    os_log_t result = CFRetain(*(CFTypeRef *)(v2 + 88));
  }
  *(void *)(*(void *)(v1[4] + 8) + 24) = v3;
  return result;
}

CFComparisonResult compare_strings(CFStringRef *a1, CFStringRef *a2)
{
  return CFStringCompare(*a1, *a2, 0x200uLL);
}

CFErrorRef SecTrustCopyError(uint64_t a1)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v45 = 0;
    CFTypeRef v46 = &v45;
    uint64_t v47 = 0x2000000000;
    int v48 = 0;
    uint64_t v2 = *(NSObject **)(a1 + 136);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __SecTrustCopyError_block_invoke;
    block[3] = &unk_1E5483B58;
    block[4] = &v45;
    void block[5] = a1;
    dispatch_sync(v2, block);
    CFErrorRef v3 = 0;
    int v4 = *((_DWORD *)v46 + 6);
    if (v4 == 1 || v4 == 4)
    {
LABEL_71:
      _Block_object_dispose(&v45, 8);
      return v3;
    }
    values = 0;
    uint64_t v73 = 0;
    CFStringRef v74 = &v73;
    uint64_t v75 = 0x2000000000;
    uint64_t v76 = 0;
    uint64_t v69 = 0;
    CFIndex v70 = &v69;
    uint64_t v71 = 0x2000000000;
    uint64_t v72 = 0;
    CFIndex v6 = *(NSObject **)(a1 + 136);
    CFNumberRef v97 = (void *)MEMORY[0x1E4F143A8];
    uint64_t v98 = 0x40000000;
    CFTypeID v99 = __SecTrustCopyErrorStrings_block_invoke;
    uint64_t v100 = &unk_1E5483B80;
    CFNumberRef v102 = &v69;
    uint64_t v103 = a1;
    CFNumberRef v101 = &v73;
    dispatch_sync(v6, &v97);
    if (v74[3])
    {
      if (SecTrustCopyErrorStrings_onceToken != -1) {
        dispatch_once(&SecTrustCopyErrorStrings_onceToken, &__block_literal_global_387);
      }
      uint64_t v65 = 0;
      int v66 = &v65;
      uint64_t v67 = 0x2000000000;
      CFMutableStringRef Mutable = (CFMutableStringRef)0xAAAAAAAAAAAAAAAALL;
      CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
      uint64_t v61 = 0;
      CFRange v62 = &v61;
      uint64_t v63 = 0x2000000000;
      int v64 = 11;
      uint64_t v57 = 0;
      int v58 = &v57;
      uint64_t v59 = 0x2000000000;
      int v60 = -67671;
      uint64_t v53 = 0;
      uint64_t v54 = &v53;
      uint64_t v55 = 0x2000000000;
      uint64_t v56 = -1;
      uint64_t v49 = 0;
      uint64_t v50 = &v49;
      uint64_t v51 = 0x2000000000;
      unint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
      CFIndex Count = CFArrayGetCount((CFArrayRef)v74[3]);
      unint64_t v50[3] = 0;
      if (Count >= 1)
      {
        CFIndex v8 = Count;
        for (CFIndex i = 0; i < v8; v50[3] = i)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v74[3], i);
          if (CFDictionaryGetCount(ValueAtIndex))
          {
            CFStringRef v11 = (__SecCertificate *)CFArrayGetValueAtIndex((CFArrayRef)v70[3], v50[3]);
            CFStringRef v12 = SecCertificateCopySubjectSummary(v11);
            CFStringRef v13 = SecFrameworkCopyLocalizedString(@"Certificate %ld %@ has errors: ", @"Trust");
            CFStringAppendFormat((CFMutableStringRef)v66[3], 0, v13, v50[3], v12);
            if (v12) {
              CFRelease(v12);
            }
            if (v13) {
              CFRelease(v13);
            }
            uint64_t v77 = 0;
            uint64_t v78 = (uint64_t)&v77;
            uint64_t v79 = 0x2000000000;
            LOBYTE(v80) = 1;
            long long context = (const void *)MEMORY[0x1E4F143A8];
            uint64_t v88 = 0x40000000;
            int v89 = __SecTrustCopyErrorStrings_block_invoke_3;
            int v90 = &unk_1E5483E10;
            int v91 = &v61;
            int v92 = &v53;
            BOOL v93 = &v49;
            uint64_t v94 = &v57;
            v95 = &v77;
            CFNumberRef v96 = &v65;
            CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)apply_block_2_14037, &context);
            CFStringAppend((CFMutableStringRef)v66[3], @";");
            _Block_object_dispose(&v77, 8);
          }
          CFIndex i = v50[3] + 1;
        }
      }
      uint64_t v14 = (const void *)v74[3];
      if (v14)
      {
        v74[3] = 0;
        CFRelease(v14);
      }
      CFIndex v15 = v54[3];
      if (v15 == -1)
      {
        CFIndex v15 = 0;
        v54[3] = 0;
      }
      uint64_t v16 = (__SecCertificate *)CFArrayGetValueAtIndex((CFArrayRef)v70[3], v15);
      CFStringRef v17 = SecCertificateCopySubjectSummary(v16);
      switch(*((_DWORD *)v62 + 6))
      {
        case 0:
          CFStringRef v18 = @"%@ certificate is blocked";
          goto LABEL_48;
        case 1:
          CFStringRef v18 = @"%@ certificate is revoked";
          goto LABEL_48;
        case 2:
          CFStringRef v18 = @"%@ certificate is using a broken key size";
          goto LABEL_48;
        case 3:
          CFStringRef v18 = @"%@ certificate is using a broken signature algorithm";
          goto LABEL_48;
        case 4:
          CFStringRef v18 = @"User or administrator set %@ certificate as distrusted";
          goto LABEL_48;
        case 5:
          CFStringRef v18 = @"%@ certificate is not standards compliant";
          goto LABEL_48;
        case 6:
          CFStringRef v23 = SecFrameworkCopyLocalizedString(@"%@ certificates do not meet pinning requirements", @"Trust");
          uint64_t v24 = CFStringCreateMutable(0, 0);
          uint64_t v83 = 0;
          CFNumberRef v84 = &v83;
          uint64_t v85 = 0x2000000000;
          uint64_t v86 = 0;
          uint64_t v25 = *(NSObject **)(a1 + 136);
          uint64_t v77 = MEMORY[0x1E4F143A8];
          uint64_t v78 = 0x40000000;
          uint64_t v79 = (uint64_t)__SecTrustCopyChainSummary_block_invoke;
          CFStringRef v80 = &unk_1E5483E38;
          long long v81 = &v83;
          uint64_t v82 = a1;
          dispatch_sync(v25, &v77);
          CFIndex v26 = CFArrayGetCount((CFArrayRef)v84[3]);
          if (v26 >= 1)
          {
            CFIndex v27 = v26;
            for (CFIndex j = 0; j != v27; ++j)
            {
              if (j) {
                CFStringAppend(v24, @",");
              }
              uint64_t v29 = (__SecCertificate *)CFArrayGetValueAtIndex((CFArrayRef)v84[3], j);
              CFStringRef v30 = SecCertificateCopySubjectSummary(v29);
              CFStringAppendFormat(v24, 0, @"\"%@\"", v30);
              if (v30) {
                CFRelease(v30);
              }
            }
          }
          _Block_object_dispose(&v83, 8);
          if (v17) {
            CFRelease(v17);
          }
          CFStringRef v17 = v24;
          goto LABEL_49;
        case 7:
          CFStringRef v18 = @"%@ certificate is not trusted";
          goto LABEL_48;
        case 8:
          CFStringRef v18 = @"%@ certificate is not permitted for this usage";
          goto LABEL_48;
        case 9:
          CFStringRef v18 = @"%@ certificate name does not match input";
          goto LABEL_48;
        case 0xA:
          CFStringRef v18 = @"%@ certificate is expired";
          goto LABEL_48;
        default:
          CFStringRef v18 = @"Unknown trust error for %@ certificate";
LABEL_48:
          CFStringRef v23 = SecFrameworkCopyLocalizedString(v18, @"Trust");
LABEL_49:
          if (v23 && v17)
          {
            CFStringRef v31 = CFStringCreateWithFormat(0, 0, v23, v17);
          }
          else
          {
            CFStringRef v31 = 0;
            uint64_t v21 = 0;
            if (!v23) {
              goto LABEL_54;
            }
          }
          CFRelease(v23);
          uint64_t v21 = (__CFString *)v31;
LABEL_54:
          if (v17) {
            CFRelease(v17);
          }
          CFStringRef v32 = (const void *)v70[3];
          if (v32)
          {
            v70[3] = 0;
            CFRelease(v32);
          }
          uint64_t v20 = (void *)v66[3];
          values = v20;
          OSStatus v22 = *((_DWORD *)v58 + 6);
          _Block_object_dispose(&v49, 8);
          _Block_object_dispose(&v53, 8);
          _Block_object_dispose(&v57, 8);
          _Block_object_dispose(&v61, 8);
          _Block_object_dispose(&v65, 8);
          break;
      }
    }
    else
    {
      uint64_t v19 = (const void *)v70[3];
      if (v19)
      {
        v70[3] = 0;
        CFRelease(v19);
      }
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      OSStatus v22 = -26276;
    }
    _Block_object_dispose(&v69, 8);
    _Block_object_dispose(&v73, 8);
    if (v21)
    {
      if (v20)
      {
LABEL_61:
        long long v34 = (const void **)MEMORY[0x1E4F1D170];
        CFDictionaryRef v35 = CFDictionaryCreate(0, MEMORY[0x1E4F1D170], (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFStringRef v36 = (const __CFString *)*MEMORY[0x1E4F1D158];
        CFIndex v37 = v22;
        CFErrorRef v38 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v22, v35);
        if (v35) {
          CFRelease(v35);
        }
        int v39 = values;
        if (values)
        {
          values = 0;
          CFRelease(v39);
        }
        uint64_t v40 = *MEMORY[0x1E4F1D190];
        long long context = *v34;
        uint64_t v88 = v40;
        CFNumberRef v97 = v21;
        uint64_t v98 = (uint64_t)v38;
        CFDictionaryRef v41 = CFDictionaryCreate(0, &context, (const void **)&v97, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFErrorRef v3 = CFErrorCreate(0, v36, v37, v41);
        if (v41) {
          CFRelease(v41);
        }
        if (v21) {
          CFRelease(v21);
        }
        if (v38) {
          CFRelease(v38);
        }
        goto LABEL_71;
      }
    }
    else
    {
      uint64_t v21 = (__CFString *)SecCopyErrorMessageString(v22, v33);
      if (v20) {
        goto LABEL_61;
      }
    }
    values = (void *)SecCopyErrorMessageString(v22, v33);
    goto LABEL_61;
  }
  return 0;
}

uint64_t __SecTrustCopyError_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_DWORD *)(*(void *)(result + 40) + 112);
  return result;
}

void *__SecTrustCopyErrorStrings_block_invoke(void *result)
{
  CFArrayRef v1 = result;
  uint64_t v2 = result[6];
  uint64_t v3 = *(void *)(v2 + 88);
  if (v3) {
    os_log_t result = CFRetain(*(CFTypeRef *)(v2 + 88));
  }
  *(void *)(*(void *)(v1[4] + 8) + 24) = v3;
  uint64_t v4 = v1[6];
  uint64_t v5 = *(void *)(v4 + 72);
  if (v5) {
    os_log_t result = CFRetain(*(CFTypeRef *)(v4 + 72));
  }
  *(void *)(*(void *)(v1[5] + 8) + 24) = v5;
  return result;
}

void __SecTrustCopyErrorStrings_block_invoke_3(void *a1, const void *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFArrayRef v4 = (const __CFArray *)SecTrustCopyErrorStrings_policyChecks;
  v14.CFIndex length = CFArrayGetCount((CFArrayRef)SecTrustCopyErrorStrings_policyChecks);
  v14.CFIndex location = 0;
  FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(v4, v14, a2);
  if (FirstIndexOfValue < 0x4C)
  {
    unint64_t v7 = FirstIndexOfValue;
    uint64_t v8 = *(void *)(a1[4] + 8);
    unsigned int v9 = *((_DWORD *)&checkmap + 4 * FirstIndexOfValue);
    if (*(_DWORD *)(v8 + 24) > v9)
    {
      *(_DWORD *)(v8 + 24) = v9;
      *(void *)(*(void *)(a1[5] + 8) + 24) = *(void *)(*(void *)(a1[6] + 8) + 24);
      *(_DWORD *)(*(void *)(a1[7] + 8) + 24) = *((_DWORD *)&checkmap + 4 * FirstIndexOfValue + 1);
    }
    if (!*(unsigned char *)(*(void *)(a1[8] + 8) + 24)) {
      CFStringAppend(*(CFMutableStringRef *)(*(void *)(a1[9] + 8) + 24), @", ");
    }
    CFStringRef v10 = SecFrameworkCopyLocalizedString(*((const __CFString **)&checkmap + 2 * v7 + 1), @"Trust");
    CFStringAppend(*(CFMutableStringRef *)(*(void *)(a1[9] + 8) + 24), v10);
    if (v10) {
      CFRelease(v10);
    }
    *(unsigned char *)(*(void *)(a1[8] + 8) + 24) = 0;
  }
  else
  {
    CFIndex v6 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      CFStringRef v12 = a2;
      _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "unknown failure key in details dictionary: %@", (uint8_t *)&v11, 0xCu);
    }
  }
}

uint64_t __SecTrustCopyChainSummary_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(*(void *)(result + 40) + 72);
  return result;
}

uint64_t apply_block_2_14037(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void __SecTrustCopyErrorStrings_block_invoke_2()
{
  CFMutableStringRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue(Mutable, @"SSLHostname");
  CFArrayAppendValue(Mutable, @"Email");
  CFArrayAppendValue(Mutable, @"TemporalValidity");
  CFArrayAppendValue(Mutable, @"ValidLeaf");
  CFArrayAppendValue(Mutable, @"WeakKeySize");
  CFArrayAppendValue(Mutable, @"WeakSignature");
  CFArrayAppendValue(Mutable, @"KeyUsage");
  CFArrayAppendValue(Mutable, @"ExtendedKeyUsage");
  CFArrayAppendValue(Mutable, @"SubjectCommonName");
  CFArrayAppendValue(Mutable, @"SubjectCommonNamePrefix");
  CFArrayAppendValue(Mutable, @"SubjectCommonNameTEST");
  CFArrayAppendValue(Mutable, @"SubjectOrganization");
  CFArrayAppendValue(Mutable, @"SubjectOrganizationalUnit");
  CFArrayAppendValue(Mutable, @"NotValidBefore");
  CFArrayAppendValue(Mutable, @"EAPTrustedServerNames");
  CFArrayAppendValue(Mutable, @"LeafMarkerOid");
  CFArrayAppendValue(Mutable, @"LeafMarkerOidWithoutValueCheck");
  CFArrayAppendValue(Mutable, @"LeafMarkersProdAndQA");
  CFArrayAppendValue(Mutable, @"BlackListedLeaf");
  CFArrayAppendValue(Mutable, @"GrayListedLeaf");
  CFArrayAppendValue(Mutable, @"LeafSPKISHA256");
  CFArrayAppendValue(Mutable, @"NotCA");
  CFArrayAppendValue(Mutable, @"MarkRepresentation");
  CFArrayAppendValue(Mutable, @"IssuerCommonName");
  CFArrayAppendValue(Mutable, @"IssuerCommonNamePrefix");
  CFArrayAppendValue(Mutable, @"BasicConstraints");
  CFArrayAppendValue(Mutable, @"BasicConstraintsCA");
  CFArrayAppendValue(Mutable, @"BasicConstraintsPathLen");
  CFArrayAppendValue(Mutable, @"IntermediateSPKISHA256");
  CFArrayAppendValue(Mutable, @"IntermediateEKU");
  CFArrayAppendValue(Mutable, @"IntermediateMarkerOid");
  CFArrayAppendValue(Mutable, @"IntermediateMarkerOidWithoutValueCheck");
  CFArrayAppendValue(Mutable, @"IntermediateOrganization");
  CFArrayAppendValue(Mutable, @"IntermediateCountry");
  CFArrayAppendValue(Mutable, @"AnchorSHA256");
  CFArrayAppendValue(Mutable, @"AnchorTrusted");
  CFArrayAppendValue(Mutable, @"MissingIntermediate");
  CFArrayAppendValue(Mutable, @"AnchorApple");
  CFArrayAppendValue(Mutable, @"CAspkiSHA256");
  CFArrayAppendValue(Mutable, @"NonEmptySubject");
  CFArrayAppendValue(Mutable, @"IdLinkage");
  CFArrayAppendValue(Mutable, @"KeySize");
  CFArrayAppendValue(Mutable, @"SignatureHashAlgorithms");
  CFArrayAppendValue(Mutable, @"CertificatePolicy");
  CFArrayAppendValue(Mutable, @"ValidRoot");
  CFArrayAppendValue(Mutable, @"CriticalExtensions");
  CFArrayAppendValue(Mutable, @"ChainLength");
  CFArrayAppendValue(Mutable, @"BasicCertificateProcessing");
  CFArrayAppendValue(Mutable, @"NameConstraints");
  CFArrayAppendValue(Mutable, @"PolicyConstraints");
  CFArrayAppendValue(Mutable, @"GrayListedKey");
  CFArrayAppendValue(Mutable, @"BlackListedKey");
  CFArrayAppendValue(Mutable, @"UsageConstraints");
  CFArrayAppendValue(Mutable, @"SystemTrustedWeakHash");
  CFArrayAppendValue(Mutable, @"SystemTrustedWeakKey");
  CFArrayAppendValue(Mutable, @"PinningRequired");
  CFArrayAppendValue(Mutable, @"Revocation");
  CFArrayAppendValue(Mutable, @"RevocationResponseRequired");
  CFArrayAppendValue(Mutable, @"CTRequired");
  CFArrayAppendValue(Mutable, @"SystemTrustedCTRequired");
  CFArrayAppendValue(Mutable, @"IssuerPolicyConstraints");
  CFArrayAppendValue(Mutable, @"IssuerNameConstraints");
  CFArrayAppendValue(Mutable, @"ValidityPeriodMaximums");
  CFArrayAppendValue(Mutable, @"SystemTrustValidityPeriod");
  CFArrayAppendValue(Mutable, @"OtherTrustValidityPeriod");
  CFArrayAppendValue(Mutable, @"ServerAuthEKU");
  CFArrayAppendValue(Mutable, @"EmailProtectionEKU");
  CFArrayAppendValue(Mutable, @"SinglePurposeChainEKU");
  CFArrayAppendValue(Mutable, @"UnparseableExtension");
  CFArrayAppendValue(Mutable, @"NonTlsCTRequired");
  CFArrayAppendValue(Mutable, @"DuplicateExtension");
  CFArrayAppendValue(Mutable, @"NoNetworkAccess");
  CFArrayAppendValue(Mutable, @"ExtendedValidation");
  CFArrayAppendValue(Mutable, @"RevocationOnline");
  CFArrayAppendValue(Mutable, @"RevocationIfTrusted");
  CFArrayAppendValue(Mutable, @"RevocationDbIgnored");
  SecTrustCopyErrorStrings_policyChecks = (uint64_t)Mutable;
}

OSStatus SecTrustEvaluateAsync(SecTrustRef trust, dispatch_queue_t queue, SecTrustCallback result)
{
  if (trust) {
    CFRetain(trust);
  }
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  _DWORD v7[2] = __SecTrustEvaluateAsync_block_invoke;
  unint64_t v7[3] = &unk_1E5483608;
  UInt8 v7[4] = result;
  void v7[5] = trust;
  dispatch_async(queue, v7);
  return 0;
}

void __SecTrustEvaluateAsync_block_invoke(uint64_t a1)
{
  int v3 = -1431655766;
  if (SecTrustEvaluateInternal(*(__SecTrust **)(a1 + 40), &v3)) {
    int v3 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v2 = *(const void **)(a1 + 40);
  if (v2) {
    CFRelease(v2);
  }
}

void __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_524(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = secLogObjForScope("trust");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    int v5 = 134217984;
    uint64_t v6 = v4;
    _os_log_debug_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEBUG, "(Trust %p) Calling completion block", (uint8_t *)&v5, 0xCu);
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  int v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
}

void __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_526(uint64_t a1)
{
  uint64_t v17 = 0;
  uint64_t v2 = *(uint64_t (**)(uint64_t, uint64_t, BOOL, BOOL, uint64_t, uint64_t, uint64_t, uint64_t, double, uint64_t, void, void, void, void, uint64_t, uint64_t, uint64_t *))(gTrustd + 40);
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = *(void *)(v3 + 16);
  uint64_t v5 = *(void *)(v3 + 24);
  int v6 = *(unsigned __int8 *)(v3 + 116);
  int v7 = *(unsigned __int8 *)(v3 + 117);
  uint64_t v8 = *(void *)(v3 + 32);
  uint64_t v9 = *(void *)(v3 + 40);
  uint64_t v10 = *(void *)(v3 + 48);
  uint64_t v11 = *(void *)(v3 + 56);
  double v12 = *(double *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (SecTrustGetCurrentAccessGroups_onceToken != -1) {
    dispatch_once(&SecTrustGetCurrentAccessGroups_onceToken, &__block_literal_global_472);
  }
  int v13 = v2(v4, v5, v6 != 0, v7 != 0, v8, v9, v10, v11, v12, SecTrustGetCurrentAccessGroups_accessGroups, *(void *)(*(void *)(a1 + 56) + 104), *(void *)(*(void *)(a1 + 56) + 144), *(void *)(*(void *)(a1 + 56) + 152), *(void *)(a1 + 64), *(void *)(a1 + 64) + 8, *(void *)(a1 + 64) + 16, &v17);
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 0x40000000;
  _OWORD v14[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_2;
  v14[3] = &unk_1E5484068;
  uint64_t v16 = *(void *)(a1 + 64);
  long long v15 = *(_OWORD *)(a1 + 48);
  UInt8 v14[4] = *(void *)(a1 + 32);
  __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_2(v14, v13, v17);
}

void __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_2(void *a1, int a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v6 = secLogObjForScope("trust");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = a1[6];
    *(_DWORD *)long long buf = 134218240;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "(Trust %p) trustd returned %d", buf, 0x12u);
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x2000000000;
  int v19 = -67671;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_527;
  block[3] = &unk_1E5484040;
  int v15 = a2;
  long long v13 = *((_OWORD *)a1 + 3);
  uint64_t v8 = *(NSObject **)(v13 + 136);
  uint64_t v14 = a3;
  block[4] = buf;
  dispatch_sync(v8, block);
  uint64_t v9 = secLogObjForScope("trust");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v11 = a1[6];
    *(_DWORD *)uint64_t v16 = 134217984;
    uint64_t v17 = v11;
    _os_log_debug_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEBUG, "(Trust %p) Calling completion block after async xpc", v16, 0xCu);
  }
  os_activity_scope_leave((os_activity_scope_state_t)(*(void *)(a1[5] + 8) + 24));
  (*(void (**)(void))(a1[4] + 16))();
  uint64_t v10 = (const void *)a1[6];
  if (v10) {
    CFRelease(v10);
  }
  _Block_object_dispose(buf, 8);
}

void __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_527(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  *(_DWORD *)(v2 + 112) = *(_DWORD *)(a1 + 64);
  uint64_t v3 = **(void **)(a1 + 48);
  uint64_t v4 = *(const void **)(v2 + 88);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(v2 + 88) = v3;
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v7 = *(const void **)(v5 + 96);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(v5 + 96) = v6;
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 16);
  uint64_t v10 = *(const void **)(v8 + 72);
  if (v10) {
    CFRelease(v10);
  }
  *(void *)(v8 + 72) = v9;
  free(*(void **)(a1 + 48));
  uint64_t v11 = *(void *)(a1 + 40);
  if (!*(_DWORD *)(v11 + 112)
    && (OSStatus = SecErrorGetOSStatus(*(void *)(a1 + 56)), uint64_t v11 = *(void *)(a1 + 40), OSStatus == -25291)
    && (Count = CFArrayGetCount(*(CFArrayRef *)(v11 + 16)), uint64_t v11 = *(void *)(a1 + 40), Count))
  {
    *(void *)values = CFArrayGetValueAtIndex(*(CFArrayRef *)(v11 + 16), 0);
    CFArrayRef v14 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x1E4F1D510]);
    uint64_t v15 = *(void *)(a1 + 40);
    uint64_t v16 = *(const void **)(v15 + 72);
    if (v16)
    {
      *(void *)(v15 + 72) = 0;
      CFRelease(v16);
      uint64_t v15 = *(void *)(a1 + 40);
    }
    *(void *)(v15 + 72) = v14;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  else
  {
    v19[0] = MEMORY[0x1E4F143A8];
    v19[1] = 0x40000000;
    void v19[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_2_528;
    v19[3] = &__block_descriptor_tmp_529;
    void v19[4] = *(void *)(a1 + 56);
    v19[5] = v11;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = SecOSStatusWith((uint64_t)v19);
    uint64_t v17 = secLogObjForScope("trust");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v18 = *(void *)(a1 + 40);
      *(_DWORD *)values = 134217984;
      *(void *)&values[4] = v18;
      _os_log_debug_impl(&dword_18B299000, v17, OS_LOG_TYPE_DEBUG, "(Trust %p) Kick off pending evals", values, 0xCu);
    }
    dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 40) + 168));
    *(unsigned char *)(*(void *)(a1 + 40) + 160) = 0;
  }
}

BOOL __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_2_528(uint64_t a1, void *a2)
{
  if (a2) {
    *a2 = *(void *)(a1 + 32);
  }
  return *(_DWORD *)(*(void *)(a1 + 40) + 112) != 0;
}

OSStatus SecTrustEvaluateAsyncWithError(SecTrustRef trust, dispatch_queue_t queue, SecTrustWithErrorCallback result)
{
  OSStatus v4 = -50;
  if (trust && queue)
  {
    if (result)
    {
      dispatch_assert_queue_V2(queue);
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 0x40000000;
      _DWORD v7[2] = __SecTrustEvaluateAsyncWithError_block_invoke;
      unint64_t v7[3] = &unk_1E54836A8;
      UInt8 v7[4] = result;
      void v7[5] = trust;
      SecTrustEvaluateIfNecessaryFastAsync((dispatch_queue_t *)trust, queue, (uint64_t)v7);
      return 0;
    }
  }
  return v4;
}

void __SecTrustEvaluateAsyncWithError_block_invoke(uint64_t a1, int a2)
{
  if (a2)
  {
    Error = SecCopyLastError(a2);
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    if (Error)
    {
      CFRelease(Error);
    }
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v9 = &v8;
    uint64_t v10 = 0x2000000000;
    int v11 = 0;
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(NSObject **)(v4 + 136);
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    _DWORD v7[2] = __SecTrustEvaluateAsyncWithError_block_invoke_2;
    unint64_t v7[3] = &unk_1E5483680;
    UInt8 v7[4] = &v8;
    void v7[5] = v4;
    dispatch_sync(v5, v7);
    SecTrustLogFailureDescription(*(__SecTrust **)(a1 + 40), *((_DWORD *)v9 + 6));
    CFErrorRef v6 = SecTrustCopyError(*(void *)(a1 + 40));
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    if (v6) {
      CFRelease(v6);
    }
    _Block_object_dispose(&v8, 8);
  }
}

uint64_t __SecTrustEvaluateAsyncWithError_block_invoke_2(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_DWORD *)(*(void *)(result + 40) + 112);
  return result;
}

CFIndex SecTrustGetCertificateCount(SecTrustRef trust)
{
  SecTrustRef v1 = trust;
  if (trust)
  {
    SecTrustEvaluateIfNecessary(trust);
    uint64_t v5 = 0;
    CFErrorRef v6 = &v5;
    uint64_t v7 = 0x2000000000;
    uint64_t v8 = 1;
    uint64_t v2 = *((void *)v1 + 17);
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 0x40000000;
    void v4[2] = __SecTrustGetCertificateCount_block_invoke;
    v4[3] = &unk_1E5483748;
    void v4[4] = &v5;
    void v4[5] = v1;
    dispatch_sync(v2, v4);
    SecTrustRef v1 = (SecTrustRef)v6[3];
    _Block_object_dispose(&v5, 8);
  }
  return (CFIndex)v1;
}

SecCertificateRef SecTrustGetCertificateAtIndex(SecTrustRef trust, CFIndex ix)
{
  SecTrustRef v2 = trust;
  if (trust)
  {
    uint64_t v9 = 0;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2000000000;
    uint64_t v12 = 0;
    if (ix)
    {
      SecTrustEvaluateIfNecessary(trust);
      uint64_t v4 = *((void *)v2 + 17);
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 0x40000000;
      _DWORD v7[2] = __SecTrustGetCertificateAtIndex_block_invoke_2;
      unint64_t v7[3] = &unk_1E5483798;
      UInt8 v7[4] = &v9;
      void v7[5] = v2;
      void v7[6] = ix;
      uint64_t v5 = v7;
    }
    else
    {
      uint64_t v4 = *((void *)trust + 17);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __SecTrustGetCertificateAtIndex_block_invoke;
      block[3] = &unk_1E5483770;
      block[4] = &v9;
      void block[5] = v2;
      uint64_t v5 = block;
    }
    dispatch_sync(v4, v5);
    SecTrustRef v2 = (SecTrustRef)v10[3];
    _Block_object_dispose(&v9, 8);
  }
  return v2;
}

const void *__SecTrustGetCertificateAtIndex_block_invoke(uint64_t a1)
{
  os_log_t result = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 40) + 16), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

__SecTrust *SecTrustCopyInfo(__SecTrust *a1)
{
  SecTrustRef v1 = a1;
  if (a1)
  {
    SecTrustEvaluateIfNecessary(a1);
    uint64_t v5 = 0;
    CFErrorRef v6 = &v5;
    uint64_t v7 = 0x2000000000;
    uint64_t v8 = 0;
    SecTrustRef v2 = *((void *)v1 + 17);
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 0x40000000;
    void v4[2] = __SecTrustCopyInfo_block_invoke;
    v4[3] = &unk_1E54837E8;
    void v4[4] = &v5;
    void v4[5] = v1;
    dispatch_sync(v2, v4);
    SecTrustRef v1 = (__SecTrust *)v6[3];
    _Block_object_dispose(&v5, 8);
  }
  return v1;
}

void *__SecTrustCopyInfo_block_invoke(void *result)
{
  SecTrustRef v1 = result;
  uint64_t v2 = result[5];
  uint64_t v3 = *(void *)(v2 + 96);
  if (v3) {
    os_log_t result = CFRetain(*(CFTypeRef *)(v2 + 96));
  }
  *(void *)(*(void *)(v1[4] + 8) + 24) = v3;
  return result;
}

uint64_t SecTrustGetTrustExceptionsArray(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v5 = 0;
  CFErrorRef v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  SecTrustRef v1 = *(NSObject **)(a1 + 136);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  void v4[2] = __SecTrustGetTrustExceptionsArray_block_invoke;
  v4[3] = &unk_1E5483810;
  void v4[4] = &v5;
  void v4[5] = a1;
  dispatch_sync(v1, v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecTrustGetTrustExceptionsArray_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(*(void *)(result + 40) + 104);
  return result;
}

CFDataRef SecTrustCopyExceptions(SecTrustRef trust)
{
  SecTrustRef Data = trust;
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (trust)
  {
    uint64_t v42 = 0;
    CFMutableArrayRef v43 = &v42;
    uint64_t v44 = 0x2000000000;
    uint64_t v45 = 0;
    uint64_t v2 = *((void *)trust + 17);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __SecTrustCopyExceptions_block_invoke;
    block[3] = &unk_1E5483838;
    block[4] = &v42;
    void block[5] = Data;
    dispatch_sync(v2, block);
    if (v43[3])
    {
      uint64_t v3 = *((void *)Data + 17);
      *(void *)long long buf = MEMORY[0x1E4F143A8];
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = __SecTrustSetNeedsEvaluation_block_invoke;
      uint64_t v47 = &__block_descriptor_tmp_68_13884;
      SecTrustRef v48 = Data;
      dispatch_sync(v3, buf);
    }
    uint64_t v37 = 0;
    CFErrorRef v38 = &v37;
    uint64_t v39 = 0x2000000000;
    uint64_t v40 = 0;
    uint64_t v33 = 0;
    long long v34 = &v33;
    uint64_t v35 = 0x2000000000;
    uint64_t v36 = 0;
    SecTrustEvaluateIfNecessary(Data);
    uint64_t v4 = *((void *)Data + 17);
    v32[0] = MEMORY[0x1E4F143A8];
    v32[1] = 0x40000000;
    void v32[2] = __SecTrustCopyExceptions_block_invoke_2;
    v32[3] = &unk_1E5483860;
    v32[5] = &v33;
    v32[6] = Data;
    v32[4] = &v37;
    dispatch_sync(v4, v32);
    CFArrayRef v5 = (const __CFArray *)v38[3];
    if (v5) {
      uint64_t Count = CFArrayGetCount(v5);
    }
    else {
      uint64_t Count = 0;
    }
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
    CFTypeRef cf = 0;
    ExceptionResetuint64_t Count = SecTrustGetExceptionResetCount(&cf);
    uint64_t valuePtr = ExceptionResetCount;
    uint64_t v10 = secLogObjForScope("trust");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v28 = "Error";
      if (!cf) {
        uint64_t v28 = "OK";
      }
      *(_DWORD *)long long buf = 134218242;
      *(void *)&uint8_t buf[4] = ExceptionResetCount;
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v28;
      _os_log_debug_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEBUG, "The current exceptions epoch is %llu. (%{public}s)", buf, 0x16u);
    }
    CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
    if (Count >= 1)
    {
      CFIndex v12 = 0;
      long long v13 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
      CFArrayRef v14 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      do
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v38[3], v12);
        CFIndex v16 = CFDictionaryGetCount(ValueAtIndex);
        if (v12 && v16 < 1)
        {
          CFDataRef MutableCopy = CFDictionaryCreate(v7, 0, 0, 0, v13, v14);
        }
        else
        {
          CFDataRef MutableCopy = CFDictionaryCreateMutableCopy(v7, 0, ValueAtIndex);
          uint64_t v18 = (__CFData *)CFArrayGetValueAtIndex((CFArrayRef)v34[3], v12);
          SHA1Digest = SecCertificateGetSHA1Digest(v18);
          if (SHA1Digest)
          {
            CFDictionaryAddValue(MutableCopy, @"SHA1Digest", SHA1Digest);
          }
          else
          {
            uint64_t v20 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 134217984;
              *(void *)&uint8_t buf[4] = v12;
              _os_log_impl(&dword_18B299000, v20, OS_LOG_TYPE_DEFAULT, "Unable to get digest of certificate at index %lld", buf, 0xCu);
            }
          }
          if (valuePtr && !cf && v11) {
            CFDictionaryAddValue(MutableCopy, @"ExceptionResetCount", v11);
          }
        }
        CFArrayAppendValue(Mutable, MutableCopy);
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
        ++v12;
      }
      while (Count != v12);
    }
    if (v43[3])
    {
      uint64_t v21 = *((void *)Data + 17);
      v29[0] = MEMORY[0x1E4F143A8];
      v29[1] = 0x40000000;
      v29[2] = __SecTrustCopyExceptions_block_invoke_301;
      v29[3] = &unk_1E5483888;
      v29[4] = &v42;
      v29[5] = Data;
      dispatch_sync(v21, v29);
      OSStatus v22 = *((void *)Data + 17);
      *(void *)long long buf = MEMORY[0x1E4F143A8];
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = __SecTrustSetNeedsEvaluation_block_invoke;
      uint64_t v47 = &__block_descriptor_tmp_68_13884;
      SecTrustRef v48 = Data;
      dispatch_sync(v22, buf);
    }
    if (Count >= 2)
    {
      unint64_t v23 = Count + 1;
      do
      {
        CFDictionaryRef v24 = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v23 - 2);
        if (CFDictionaryGetCount(v24)) {
          break;
        }
        CFArrayRemoveValueAtIndex(Mutable, v23 - 2);
        --v23;
      }
      while (v23 > 2);
    }
    SecTrustRef Data = CFPropertyListCreateData(v7, Mutable, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    CFRelease(Mutable);
    uint64_t v25 = (const void *)v38[3];
    if (v25) {
      CFRelease(v25);
    }
    CFIndex v26 = (const void *)v34[3];
    if (v26) {
      CFRelease(v26);
    }
    if (v11) {
      CFRelease(v11);
    }
    if (cf) {
      CFRelease(cf);
    }
    _Block_object_dispose(&v33, 8);
    _Block_object_dispose(&v37, 8);
    _Block_object_dispose(&v42, 8);
  }
  return Data;
}

uint64_t __SecTrustCopyExceptions_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(result + 40) + 104);
  if (v1)
  {
    *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v1;
    *(void *)(*(void *)(result + 40) + 104) = 0;
  }
  return result;
}

void *__SecTrustCopyExceptions_block_invoke_2(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[6];
  uint64_t v3 = *(void *)(v2 + 88);
  if (v3) {
    os_log_t result = CFRetain(*(CFTypeRef *)(v2 + 88));
  }
  *(void *)(*(void *)(v1[4] + 8) + 24) = v3;
  uint64_t v4 = v1[6];
  uint64_t v5 = *(void *)(v4 + 72);
  if (v5) {
    os_log_t result = CFRetain(*(CFTypeRef *)(v4 + 72));
  }
  *(void *)(*(void *)(v1[5] + 8) + 24) = v5;
  return result;
}

uint64_t SecTrustGetExceptionResetCount(CFTypeRef *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = _os_activity_create(&dword_18B299000, "SecTrustExceptionGetResetCount", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  v8.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v8.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v2, &v8);
  if (gTrustd && (uint64_t v3 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 176)) != 0)
  {
    uint64_t v4 = v3(a1);
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2000000000;
    uint64_t v12 = 0;
    *(void *)&long long buf = MEMORY[0x1E4F143A8];
    *((void *)&buf + 1) = 0x40000000;
    CFArrayRef v14 = __to_uint_error_request_block_invoke;
    uint64_t v15 = &unk_1E5484260;
    CFIndex v16 = &v9;
    uint64_t v17 = a1;
    securityd_send_sync_and_do(0x78u, a1, 0, (uint64_t)&buf);
    uint64_t v4 = v10[3];
    _Block_object_dispose(&v9, 8);
  }
  os_release(v2);
  if (a1)
  {
    if (*a1)
    {
      uint64_t v5 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_18B299000, v5, OS_LOG_TYPE_DEFAULT, "Failed to get the exceptions epoch.", (uint8_t *)&buf, 2u);
      }
    }
  }
  CFErrorRef v6 = secLogObjForScope("trust");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v4;
    _os_log_debug_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEBUG, "The exceptions epoch is %lld.", (uint8_t *)&buf, 0xCu);
  }
  os_activity_scope_leave(&v8);
  return v4;
}

uint64_t __SecTrustCopyExceptions_block_invoke_301(uint64_t result)
{
  *(void *)(*(void *)(result + 40) + 104) = *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24);
  return result;
}

BOOL __to_uint_error_request_block_invoke(uint64_t a1, xpc_object_t xdict, void *a3)
{
  uint64_t int64 = xpc_dictionary_get_uint64(xdict, "status");
  if ((uint64 & 0x8000000000000000) != 0)
  {
    CFErrorRef v6 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "Invalid exceptions epoch.", v9, 2u);
    }
    if (*(void *)(a1 + 40)) {
      **(void **)(a1 + 40) = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D160], 34, 0);
    }
  }
  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = uint64;
  }
  if (a3)
  {
    CFAllocatorRef v7 = *(void **)(a1 + 40);
    if (v7)
    {
      if (*a3) {
        void *v7 = *a3;
      }
    }
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

BOOL SecTrustSetExceptions(SecTrustRef trust, CFDataRef exceptions)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (trust)
  {
    SecTrustRef v2 = trust;
    if (exceptions)
    {
      CFPropertyListRef v3 = CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], exceptions, 0, 0, 0);
      uint64_t v4 = v3;
      if (!v3 || (CFTypeID v5 = CFGetTypeID(v3), v5 == CFArrayGetTypeID()))
      {
LABEL_7:
        CFErrorRef v6 = *((void *)v2 + 17);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        block[2] = __SecTrustSetExceptions_block_invoke;
        block[3] = &__block_descriptor_tmp_303;
        block[4] = v2;
        void block[5] = v4;
        dispatch_sync(v6, block);
        CFAllocatorRef v7 = *((void *)v2 + 17);
        *(void *)long long buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = __SecTrustSetNeedsEvaluation_block_invoke;
        unint64_t v52 = &__block_descriptor_tmp_68_13884;
        uint64_t v53 = (CFTypeRef *)v2;
        dispatch_sync(v7, buf);
        CFTypeRef cf = 0;
        p_CFTypeRef cf = &cf;
        uint64_t v49 = 0x2000000000;
        uint64_t v50 = 0;
        unint64_t valuePtr = 0;
        p_unint64_t valuePtr = &valuePtr;
        uint64_t v45 = 0x2000000000;
        uint64_t v46 = 0;
        os_activity_scope_state_s v8 = *((void *)v2 + 17);
        *(void *)long long buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = __SecTrustGetExceptionForCertificateAtIndex_block_invoke;
        unint64_t v52 = &unk_1E54841C0;
        uint64_t v54 = &valuePtr;
        SecTrustRef v55 = v2;
        uint64_t v53 = &cf;
        dispatch_sync(v8, buf);
        CFArrayRef v9 = (const __CFArray *)p_cf[3];
        if (!v9 || CFArrayGetCount(v9) < 1) {
          goto LABEL_18;
        }
        CFArrayRef v10 = (const __CFArray *)p_valuePtr[3];
        if (!v10)
        {
          CFArrayRef v18 = SecTrustCopyCertificateChain(v2);
          p_valuePtr[3] = (unint64_t)v18;
          if (!v18 || CFArrayGetCount(v18) < 1) {
            goto LABEL_18;
          }
          CFArrayRef v10 = (const __CFArray *)p_valuePtr[3];
        }
        CFDictionaryRef ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(v10, 0);
        if (ValueAtIndex)
        {
          uint64_t v12 = ValueAtIndex;
          long long v13 = CFArrayGetValueAtIndex((CFArrayRef)p_cf[3], 0);
          CFTypeID v14 = CFGetTypeID(v13);
          uint64_t v15 = 0;
          if (v14 != CFDictionaryGetTypeID()
            || (SHA1Digest = SecCertificateGetSHA1Digest(v12),
                (uint64_t v17 = CFDictionaryGetValue((CFDictionaryRef)v13, @"SHA1Digest")) != 0)
            && (uint64_t v15 = v13, CFEqual(SHA1Digest, v17)))
          {
LABEL_19:
            CFTypeRef v19 = p_cf[3];
            if (v19) {
              CFRelease(v19);
            }
            uint64_t v20 = (const void *)p_valuePtr[3];
            if (v20) {
              CFRelease(v20);
            }
            _Block_object_dispose(&valuePtr, 8);
            _Block_object_dispose(&cf, 8);
            if (v15)
            {
              if (v4)
              {
                CFTypeID v21 = CFGetTypeID(v4);
                if (v21 != CFArrayGetTypeID() || CFArrayGetCount((CFArrayRef)v4) < 1) {
                  goto LABEL_36;
                }
                CFDictionaryRef v22 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v4, 0);
                if (v22 && (CFDictionaryRef v23 = v22, v24 = CFGetTypeID(v22), v24 == CFDictionaryGetTypeID()))
                {
                  CFTypeRef cf = 0;
                  ExceptionResetuint64_t Count = SecTrustGetExceptionResetCount(&cf);
                  CFIndex v26 = secLogObjForScope("trust");
                  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
                  {
                    CFErrorRef v38 = "Error";
                    if (!cf) {
                      CFErrorRef v38 = "OK";
                    }
                    *(_DWORD *)long long buf = 134218242;
                    *(void *)&uint8_t buf[4] = ExceptionResetCount;
                    *(_WORD *)&unsigned char buf[12] = 2082;
                    *(void *)&buf[14] = v38;
                    _os_log_debug_impl(&dword_18B299000, v26, OS_LOG_TYPE_DEBUG, "The current exceptions epoch is %llu. (%{public}s)", buf, 0x16u);
                  }
                  if (cf)
                  {
                    CFIndex v27 = secLogObjForScope("SecError");
                    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_impl(&dword_18B299000, v27, OS_LOG_TYPE_DEFAULT, "Failed to get the current exceptions epoch.", buf, 2u);
                    }
                    CFTypeRef v28 = cf;
                    if (cf)
                    {
                      CFTypeRef cf = 0;
                      CFRelease(v28);
                    }
                    goto LABEL_36;
                  }
                  if (!ExceptionResetCount) {
                    goto LABEL_50;
                  }
                  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v23, @"ExceptionResetCount");
                  if (Value && (CFNumberRef v35 = Value, v36 = CFGetTypeID(Value), v36 == CFNumberGetTypeID()))
                  {
                    unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
                    if (CFNumberGetValue(v35, kCFNumberSInt64Type, &valuePtr))
                    {
                      if (valuePtr == ExceptionResetCount)
                      {
                        uint64_t v37 = secLogObjForScope("trust");
                        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
                        {
                          *(_DWORD *)long long buf = 134217984;
                          *(void *)&uint8_t buf[4] = ExceptionResetCount;
                          _os_log_debug_impl(&dword_18B299000, v37, OS_LOG_TYPE_DEBUG, "Exceptions are valid for the current exceptions epoch. (%llu)", buf, 0xCu);
                        }
LABEL_50:
                        CFRelease(v4);
                        LOBYTE(trust) = 1;
                        return (char)trust;
                      }
                      uint64_t v39 = secLogObjForScope("SecError");
                      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)long long buf = 134218240;
                        *(void *)&uint8_t buf[4] = valuePtr;
                        *(_WORD *)&unsigned char buf[12] = 2048;
                        *(void *)&buf[14] = ExceptionResetCount;
                        CFStringRef v31 = "The current exception's epoch (%llu) is not the current epoch. (%llu)";
                        CFStringRef v32 = v39;
                        uint32_t v33 = 22;
                        goto LABEL_42;
                      }
LABEL_36:
                      CFRelease(v4);
                      goto LABEL_37;
                    }
                    CFStringRef v30 = secLogObjForScope("SecError");
                    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_36;
                    }
                    *(_WORD *)long long buf = 0;
                    CFStringRef v31 = "Failed to parse the current exceptions epoch as a uint64.";
                  }
                  else
                  {
                    CFStringRef v30 = secLogObjForScope("SecError");
                    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_36;
                    }
                    *(_WORD *)long long buf = 0;
                    CFStringRef v31 = "Failed to get the exception's epoch.";
                  }
                }
                else
                {
                  CFStringRef v30 = secLogObjForScope("SecError");
                  if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_36;
                  }
                  *(_WORD *)long long buf = 0;
                  CFStringRef v31 = "Failed to get exception for epoch check.";
                }
                CFStringRef v32 = v30;
                uint32_t v33 = 2;
LABEL_42:
                _os_log_impl(&dword_18B299000, v32, OS_LOG_TYPE_DEFAULT, v31, buf, v33);
                goto LABEL_36;
              }
            }
            else if (v4)
            {
              goto LABEL_36;
            }
LABEL_37:
            uint64_t v29 = *((void *)v2 + 17);
            v41[0] = MEMORY[0x1E4F143A8];
            v41[1] = 0x40000000;
            v41[2] = __SecTrustSetExceptions_block_invoke_2;
            unint64_t v41[3] = &__block_descriptor_tmp_304;
            v41[4] = v2;
            dispatch_sync(v29, v41);
            LOBYTE(trust) = 0;
            return (char)trust;
          }
        }
LABEL_18:
        uint64_t v15 = 0;
        goto LABEL_19;
      }
      CFRelease(v4);
    }
    uint64_t v4 = 0;
    goto LABEL_7;
  }
  return (char)trust;
}

CFTypeRef __SecTrustSetExceptions_block_invoke(uint64_t a1)
{
  SecTrustRef v2 = *(const void **)(*(void *)(a1 + 32) + 104);
  if (v2) {
    CFRelease(v2);
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 40);
  if (result)
  {
    CFTypeRef result = CFRetain(result);
    uint64_t v4 = *(void *)(a1 + 40);
  }
  else
  {
    uint64_t v4 = 0;
  }
  *(void *)(*(void *)(a1 + 32) + 104) = v4;
  return result;
}

void *__SecTrustGetExceptionForCertificateAtIndex_block_invoke(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[6];
  uint64_t v3 = *(void *)(v2 + 104);
  if (v3) {
    CFTypeRef result = CFRetain(*(CFTypeRef *)(v2 + 104));
  }
  *(void *)(*(void *)(v1[4] + 8) + 24) = v3;
  uint64_t v4 = v1[6];
  uint64_t v5 = *(void *)(v4 + 72);
  if (v5) {
    CFTypeRef result = CFRetain(*(CFTypeRef *)(v4 + 72));
  }
  *(void *)(*(void *)(v1[5] + 8) + 24) = v5;
  return result;
}

void __SecTrustSetExceptions_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(const void **)(v1 + 104);
  if (v2)
  {
    *(void *)(v1 + 104) = 0;
    CFRelease(v2);
  }
}

CFArrayRef SecTrustCopySummaryPropertiesAtIndex(__SecTrust *a1, CFIndex a2)
{
  CFArrayRef result = SecTrustCopyCertificateChain(a1);
  if (result)
  {
    CFArrayRef v5 = result;
    CFDictionaryRef ValueAtIndex = (double *)CFArrayGetValueAtIndex(result, a2);
    double VerifyTime = SecTrustGetVerifyTime(a1);
    CFMutableArrayRef v8 = SecCertificateCopySummaryProperties(ValueAtIndex, VerifyTime);
    CFRelease(v5);
    return v8;
  }
  return result;
}

CFArrayRef SecTrustCopyDetailedPropertiesAtIndex(__SecTrust *a1, CFIndex a2)
{
  CFArrayRef result = SecTrustCopyCertificateChain(a1);
  if (result)
  {
    CFArrayRef v4 = result;
    CFDictionaryRef ValueAtIndex = (unsigned __int8 *)CFArrayGetValueAtIndex(result, a2);
    uint64_t v6 = CopyProperties(ValueAtIndex, 1);
    CFRelease(v4);
    return (const __CFArray *)v6;
  }
  return result;
}

CFArrayRef SecTrustCopyProperties(SecTrustRef trust)
{
  SecTrustRef v1 = trust;
  if (trust)
  {
    SecTrustEvaluateIfNecessary(trust);
    uint64_t v15 = 0;
    CFIndex v16 = &v15;
    uint64_t v17 = 0x2000000000;
    uint64_t v18 = 0;
    uint64_t v2 = *((void *)v1 + 17);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __SecTrustCopyProperties_block_invoke;
    block[3] = &unk_1E54838F0;
    block[4] = &v15;
    void block[5] = v1;
    dispatch_sync(v2, block);
    CFArrayRef v3 = (const __CFArray *)v16[3];
    if (!v3)
    {
      SecTrustRef v1 = 0;
LABEL_34:
      _Block_object_dispose(&v15, 8);
      return v1;
    }
    __int16 context = 0;
    CFIndex Count = CFArrayGetCount(v3);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      for (CFIndex i = 0; i != v5; ++i)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v16[3], i);
        CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)applyDetailProperty, &context);
      }
    }
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    SecTrustRef v1 = Mutable;
    __int16 v9 = context;
    if (context)
    {
      CFStringRef v10 = @"Invalid certificate chain linkage.";
    }
    else
    {
      if ((context & 2) == 0)
      {
        if ((context & 4) != 0)
        {
          appendError(Mutable, @"Root certificate is not trusted.");
          __int16 v9 = context;
          if ((context & 8) == 0)
          {
LABEL_10:
            if ((v9 & 0x10) == 0) {
              goto LABEL_11;
            }
            goto LABEL_22;
          }
        }
        else if ((context & 8) == 0)
        {
          goto LABEL_10;
        }
        appendError(v1, @"Unable to build chain to root certificate.");
        __int16 v9 = context;
        if ((context & 0x10) == 0)
        {
LABEL_11:
          if ((v9 & 0x20) == 0) {
            goto LABEL_12;
          }
          goto LABEL_23;
        }
LABEL_22:
        appendError(v1, @"Hostname mismatch.");
        __int16 v9 = context;
        if ((context & 0x20) == 0)
        {
LABEL_12:
          if ((v9 & 0x40) == 0) {
            goto LABEL_13;
          }
          goto LABEL_24;
        }
LABEL_23:
        appendError(v1, @"Policy requirements not met.");
        __int16 v9 = context;
        if ((context & 0x40) == 0)
        {
LABEL_13:
          if ((v9 & 0x80) == 0) {
            goto LABEL_14;
          }
          goto LABEL_25;
        }
LABEL_24:
        appendError(v1, @"One or more certificates have expired or are not valid yet.");
        __int16 v9 = context;
        if ((context & 0x80) == 0)
        {
LABEL_14:
          if ((v9 & 0x100) == 0) {
            goto LABEL_15;
          }
          goto LABEL_26;
        }
LABEL_25:
        appendError(v1, @"One or more certificates is using a weak key size.");
        __int16 v9 = context;
        if ((context & 0x100) == 0)
        {
LABEL_15:
          if ((v9 & 0x200) == 0)
          {
LABEL_29:
            if (!CFArrayGetCount(v1) && v1)
            {
              CFRelease(v1);
              SecTrustRef v1 = 0;
            }
            uint64_t v11 = (const void *)v16[3];
            if (v11)
            {
              void v16[3] = 0;
              CFRelease(v11);
            }
            goto LABEL_34;
          }
          goto LABEL_27;
        }
LABEL_26:
        appendError(v1, @"One or more certificates is using a weak signature algorithm.");
        if ((context & 0x200) == 0) {
          goto LABEL_29;
        }
LABEL_27:
        CFStringRef v10 = @"One or more certificates have been revoked.";
        goto LABEL_28;
      }
      CFStringRef v10 = @"One or more unsupported critical extensions found.";
    }
LABEL_28:
    appendError(v1, v10);
    goto LABEL_29;
  }
  return v1;
}

void *__SecTrustCopyProperties_block_invoke(void *result)
{
  SecTrustRef v1 = result;
  uint64_t v2 = result[5];
  uint64_t v3 = *(void *)(v2 + 88);
  if (v3) {
    CFArrayRef result = CFRetain(*(CFTypeRef *)(v2 + 88));
  }
  *(void *)(*(void *)(v1[4] + 8) + 24) = v3;
  return result;
}

void appendError(void *a1, const __CFString *a2)
{
  if (a2)
  {
    CFStringRef v3 = SecFrameworkCopyLocalizedString(a2, @"SecCertificate");
    appendProperty(a1, @"error", 0, 0, v3, 1);
    if (v3)
    {
      CFRelease(v3);
    }
  }
}

CFNumberRef applyDetailProperty(void *key, uint64_t a2, _WORD *a3)
{
  if (applyDetailProperty_onceToken != -1) {
    dispatch_once(&applyDetailProperty_onceToken, &__block_literal_global_552);
  }
  CFNumberRef result = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)applyDetailProperty_policyChecks, key);
  __int16 valuePtr = 0;
  if (result)
  {
    CFNumberRef result = (const __CFNumber *)CFNumberGetValue(result, kCFNumberSInt16Type, &valuePtr);
    if (a3)
    {
      if (result) {
        *a3 |= valuePtr;
      }
    }
  }
  return result;
}

void __applyDetailProperty_block_invoke()
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  __int16 valuePtr = 16;
  CFNumberRef v1 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SSLHostname", v1);
  if (v1) {
    CFRelease(v1);
  }
  __int16 valuePtr = 16;
  CFNumberRef v2 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"Email", v2);
  if (v2) {
    CFRelease(v2);
  }
  __int16 valuePtr = 64;
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"TemporalValidity", v3);
  if (v3) {
    CFRelease(v3);
  }
  __int16 valuePtr = 64;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ValidLeaf", v4);
  if (v4) {
    CFRelease(v4);
  }
  __int16 valuePtr = 128;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"WeakKeySize", v5);
  if (v5) {
    CFRelease(v5);
  }
  __int16 valuePtr = 256;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"WeakSignature", v6);
  if (v6) {
    CFRelease(v6);
  }
  __int16 valuePtr = 32;
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"KeyUsage", v7);
  if (v7) {
    CFRelease(v7);
  }
  __int16 valuePtr = 32;
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ExtendedKeyUsage", v8);
  if (v8) {
    CFRelease(v8);
  }
  __int16 valuePtr = 32;
  CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SubjectCommonName", v9);
  if (v9) {
    CFRelease(v9);
  }
  __int16 valuePtr = 32;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SubjectCommonNamePrefix", v10);
  if (v10) {
    CFRelease(v10);
  }
  __int16 valuePtr = 32;
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SubjectCommonNameTEST", v11);
  if (v11) {
    CFRelease(v11);
  }
  __int16 valuePtr = 32;
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SubjectOrganization", v12);
  if (v12) {
    CFRelease(v12);
  }
  __int16 valuePtr = 32;
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SubjectOrganizationalUnit", v13);
  if (v13) {
    CFRelease(v13);
  }
  __int16 valuePtr = 32;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"NotValidBefore", v14);
  if (v14) {
    CFRelease(v14);
  }
  __int16 valuePtr = 16;
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"EAPTrustedServerNames", v15);
  if (v15) {
    CFRelease(v15);
  }
  __int16 valuePtr = 32;
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"LeafMarkerOid", v16);
  if (v16) {
    CFRelease(v16);
  }
  __int16 valuePtr = 32;
  CFNumberRef v17 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"LeafMarkerOidWithoutValueCheck", v17);
  if (v17) {
    CFRelease(v17);
  }
  __int16 valuePtr = 32;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"LeafMarkersProdAndQA", v18);
  if (v18) {
    CFRelease(v18);
  }
  __int16 valuePtr = 512;
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"BlackListedLeaf", v19);
  if (v19) {
    CFRelease(v19);
  }
  __int16 valuePtr = 512;
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"GrayListedLeaf", v20);
  if (v20) {
    CFRelease(v20);
  }
  __int16 valuePtr = 32;
  CFNumberRef v21 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"LeafSPKISHA256", v21);
  if (v21) {
    CFRelease(v21);
  }
  __int16 valuePtr = 32;
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"NotCA", v22);
  if (v22) {
    CFRelease(v22);
  }
  __int16 valuePtr = 32;
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"MarkRepresentation", v23);
  if (v23) {
    CFRelease(v23);
  }
  __int16 valuePtr = 32;
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IssuerCommonName", v24);
  if (v24) {
    CFRelease(v24);
  }
  __int16 valuePtr = 32;
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IssuerCommonNamePrefix", v25);
  if (v25) {
    CFRelease(v25);
  }
  __int16 valuePtr = 64;
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"BasicConstraints", v26);
  if (v26) {
    CFRelease(v26);
  }
  __int16 valuePtr = 64;
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"BasicConstraintsCA", v27);
  if (v27) {
    CFRelease(v27);
  }
  __int16 valuePtr = 64;
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"BasicConstraintsPathLen", v28);
  if (v28) {
    CFRelease(v28);
  }
  __int16 valuePtr = 32;
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IntermediateSPKISHA256", v29);
  if (v29) {
    CFRelease(v29);
  }
  __int16 valuePtr = 32;
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IntermediateEKU", v30);
  if (v30) {
    CFRelease(v30);
  }
  __int16 valuePtr = 32;
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IntermediateMarkerOid", v31);
  if (v31) {
    CFRelease(v31);
  }
  __int16 valuePtr = 32;
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IntermediateMarkerOidWithoutValueCheck", v32);
  if (v32) {
    CFRelease(v32);
  }
  __int16 valuePtr = 32;
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IntermediateOrganization", v33);
  if (v33) {
    CFRelease(v33);
  }
  __int16 valuePtr = 32;
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IntermediateCountry", v34);
  if (v34) {
    CFRelease(v34);
  }
  __int16 valuePtr = 4;
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"AnchorSHA256", v35);
  if (v35) {
    CFRelease(v35);
  }
  __int16 valuePtr = 4;
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"AnchorTrusted", v36);
  if (v36) {
    CFRelease(v36);
  }
  __int16 valuePtr = 8;
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"MissingIntermediate", v37);
  if (v37) {
    CFRelease(v37);
  }
  __int16 valuePtr = 4;
  CFNumberRef v38 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"AnchorApple", v38);
  if (v38) {
    CFRelease(v38);
  }
  __int16 valuePtr = 32;
  CFNumberRef v39 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"CAspkiSHA256", v39);
  if (v39) {
    CFRelease(v39);
  }
  __int16 valuePtr = 64;
  CFNumberRef v40 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"NonEmptySubject", v40);
  if (v40) {
    CFRelease(v40);
  }
  __int16 valuePtr = 1;
  CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IdLinkage", v41);
  if (v41) {
    CFRelease(v41);
  }
  __int16 valuePtr = 128;
  CFNumberRef v42 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"KeySize", v42);
  if (v42) {
    CFRelease(v42);
  }
  __int16 valuePtr = 256;
  CFNumberRef v43 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SignatureHashAlgorithms", v43);
  if (v43) {
    CFRelease(v43);
  }
  __int16 valuePtr = 32;
  CFNumberRef v44 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"CertificatePolicy", v44);
  if (v44) {
    CFRelease(v44);
  }
  __int16 valuePtr = 64;
  CFNumberRef v45 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ValidRoot", v45);
  if (v45) {
    CFRelease(v45);
  }
  __int16 valuePtr = 2;
  CFNumberRef v46 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"CriticalExtensions", v46);
  if (v46) {
    CFRelease(v46);
  }
  __int16 valuePtr = 32;
  CFNumberRef v47 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ChainLength", v47);
  if (v47) {
    CFRelease(v47);
  }
  __int16 valuePtr = 64;
  CFNumberRef v48 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"BasicCertificateProcessing", v48);
  if (v48) {
    CFRelease(v48);
  }
  __int16 valuePtr = 64;
  CFNumberRef v49 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"NameConstraints", v49);
  if (v49) {
    CFRelease(v49);
  }
  __int16 valuePtr = 64;
  CFNumberRef v50 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"PolicyConstraints", v50);
  if (v50) {
    CFRelease(v50);
  }
  __int16 valuePtr = 512;
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"GrayListedKey", v51);
  if (v51) {
    CFRelease(v51);
  }
  __int16 valuePtr = 512;
  CFNumberRef v52 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"BlackListedKey", v52);
  if (v52) {
    CFRelease(v52);
  }
  __int16 valuePtr = 4;
  CFNumberRef v53 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"UsageConstraints", v53);
  if (v53) {
    CFRelease(v53);
  }
  __int16 valuePtr = 256;
  CFNumberRef v54 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SystemTrustedWeakHash", v54);
  if (v54) {
    CFRelease(v54);
  }
  __int16 valuePtr = 128;
  CFNumberRef v55 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SystemTrustedWeakKey", v55);
  if (v55) {
    CFRelease(v55);
  }
  __int16 valuePtr = 32;
  CFNumberRef v56 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"PinningRequired", v56);
  if (v56) {
    CFRelease(v56);
  }
  __int16 valuePtr = 512;
  CFNumberRef v57 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"Revocation", v57);
  if (v57) {
    CFRelease(v57);
  }
  __int16 valuePtr = 32;
  CFNumberRef v58 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"RevocationResponseRequired", v58);
  if (v58) {
    CFRelease(v58);
  }
  __int16 valuePtr = 32;
  CFNumberRef v59 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"CTRequired", v59);
  if (v59) {
    CFRelease(v59);
  }
  __int16 valuePtr = 32;
  CFNumberRef v60 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SystemTrustedCTRequired", v60);
  if (v60) {
    CFRelease(v60);
  }
  __int16 valuePtr = 512;
  CFNumberRef v61 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IssuerPolicyConstraints", v61);
  if (v61) {
    CFRelease(v61);
  }
  __int16 valuePtr = 512;
  CFNumberRef v62 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IssuerNameConstraints", v62);
  if (v62) {
    CFRelease(v62);
  }
  __int16 valuePtr = 32;
  CFNumberRef v63 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ValidityPeriodMaximums", v63);
  if (v63) {
    CFRelease(v63);
  }
  __int16 valuePtr = 32;
  CFNumberRef v64 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SystemTrustValidityPeriod", v64);
  if (v64) {
    CFRelease(v64);
  }
  __int16 valuePtr = 32;
  CFNumberRef v65 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"OtherTrustValidityPeriod", v65);
  if (v65) {
    CFRelease(v65);
  }
  __int16 valuePtr = 32;
  CFNumberRef v66 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ServerAuthEKU", v66);
  if (v66) {
    CFRelease(v66);
  }
  __int16 valuePtr = 32;
  CFNumberRef v67 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"EmailProtectionEKU", v67);
  if (v67) {
    CFRelease(v67);
  }
  __int16 valuePtr = 32;
  CFNumberRef v68 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SinglePurposeChainEKU", v68);
  if (v68) {
    CFRelease(v68);
  }
  __int16 valuePtr = 64;
  CFNumberRef v69 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"UnparseableExtension", v69);
  if (v69) {
    CFRelease(v69);
  }
  __int16 valuePtr = 32;
  CFNumberRef v70 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"NonTlsCTRequired", v70);
  if (v70) {
    CFRelease(v70);
  }
  __int16 valuePtr = 64;
  CFNumberRef v71 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"DuplicateExtension", v71);
  if (v71) {
    CFRelease(v71);
  }
  __int16 valuePtr = 32;
  CFNumberRef v72 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"NoNetworkAccess", v72);
  if (v72) {
    CFRelease(v72);
  }
  __int16 valuePtr = 32;
  CFNumberRef v73 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ExtendedValidation", v73);
  if (v73) {
    CFRelease(v73);
  }
  __int16 valuePtr = 32;
  CFNumberRef v74 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"RevocationOnline", v74);
  if (v74) {
    CFRelease(v74);
  }
  __int16 valuePtr = 32;
  CFNumberRef v75 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"RevocationIfTrusted", v75);
  if (v75) {
    CFRelease(v75);
  }
  __int16 valuePtr = 32;
  CFNumberRef v76 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"RevocationDbIgnored", v76);
  if (v76) {
    CFRelease(v76);
  }
  applyDetailProperty_policyChecks = (uint64_t)Mutable;
}

CFDictionaryRef SecTrustCopyResult(SecTrustRef trust)
{
  SecTrustRef v1 = trust;
  if (trust)
  {
    uint64_t v9 = 0;
    CFNumberRef v10 = &v9;
    uint64_t v11 = 0x2000000000;
    CFMutableDictionaryRef Mutable = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    SecTrustEvaluateIfNecessary(v1);
    v7[0] = 0;
    v7[1] = v7;
    _DWORD v7[2] = 0x2000000000;
    unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v14 = 0;
    CFNumberRef v15 = &v14;
    uint64_t v16 = 0x2000000000;
    uint64_t v17 = 0;
    CFNumberRef v2 = *((void *)v1 + 17);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___SecTrustCopyDetails_block_invoke;
    block[3] = &unk_1E5484210;
    block[4] = &v14;
    void block[5] = v1;
    dispatch_sync(v2, block);
    unint64_t v3 = v15[3];
    _Block_object_dispose(&v14, 8);
    unint64_t v8 = v3;
    CFNumberRef v4 = *((void *)v1 + 17);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __SecTrustCopyResult_block_invoke;
    unint64_t v6[3] = &unk_1E5483918;
    void v6[4] = v7;
    void v6[5] = &v9;
    void v6[6] = v1;
    dispatch_sync(v4, v6);
    SecTrustRef v1 = (SecTrustRef)v10[3];
    _Block_object_dispose(v7, 8);
    _Block_object_dispose(&v9, 8);
  }
  return v1;
}

void __SecTrustCopyResult_block_invoke(void *a1)
{
  CFNumberRef v2 = *(const void **)(*(void *)(a1[4] + 8) + 24);
  if (v2)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8) + 24), @"TrustResultDetails", v2);
    CFRelease(*(CFTypeRef *)(*(void *)(a1[4] + 8) + 24));
  }
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(a1[6] + 112));
  if (v3)
  {
    CFNumberRef v4 = v3;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8) + 24), @"TrustResultValue", v3);
    CFRelease(v4);
  }
  uint64_t v5 = a1[6];
  CFDictionaryRef v6 = *(const __CFDictionary **)(v5 + 96);
  if (*(_DWORD *)(v5 + 112)) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    unint64_t v8 = *(const void **)(v5 + 64);
    if (v8) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8) + 24), @"TrustEvaluationDate", v8);
    }
    value = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(v6, @"CertificateTransparency", (const void **)&value)) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8) + 24), @"TrustCertificateTransparency", value);
    }
    CFNumberRef v13 = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(v6, @"ExtendedValidation", (const void **)&v13)) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8) + 24), @"TrustExtendedValidation", v13);
    }
    CFNumberRef v12 = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(v6, @"CompanyName", (const void **)&v12)) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8) + 24), @"Organization", v12);
    }
    uint64_t v11 = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(v6, @"TrustRevocationChecked", (const void **)&v11)) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8) + 24), @"TrustRevocationChecked", v11);
    }
    CFNumberRef v10 = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(v6, @"TrustRevocationReason", (const void **)&v10)) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8) + 24), @"TrustRevocationReason", v10);
    }
    uint64_t v9 = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(v6, @"TrustExpirationDate", (const void **)&v9)) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8) + 24), @"TrustExpirationDate", v9);
    }
  }
}

uint64_t SecTrustCopyTrustStoreContentDigest(CFTypeRef *a1)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  if (gTrustd && (CFNumberRef v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 56)) != 0)
  {
    uint64_t v3 = v2(a1);
  }
  else
  {
    CFNumberRef v4 = _os_activity_create(&dword_18B299000, "SecTrustCopyTrustStoreContentDigest", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v4, &state);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __SecTrustCopyTrustStoreContentDigest_block_invoke_2;
    unint64_t v6[3] = &unk_1E5483960;
    void v6[4] = &v8;
    securityd_send_sync_and_do(0x86u, a1, (uint64_t)&__block_literal_global_14108, (uint64_t)v6);
    os_release(v4);
    uint64_t v3 = v9[3];
    os_activity_scope_leave(&state);
  }
  _Block_object_dispose(&v8, 8);
  return v3;
}

BOOL __SecTrustCopyTrustStoreContentDigest_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  if (xdict && xpc_dictionary_get_value(xdict, "status") && MEMORY[0x18C12FBB0]() == MEMORY[0x1E4F145F0])
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
    return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
  }
  else
  {
    return SecError(-26276, a3, @"Unable to get trust store content digest");
  }
}

uint64_t __SecTrustCopyTrustStoreContentDigest_block_invoke()
{
  return 1;
}

uint64_t SecTrustCopyTrustStoreAssetVersion(CFTypeRef *a1)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  if (gTrustd && (CFNumberRef v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 48)) != 0)
  {
    uint64_t v3 = v2(a1);
  }
  else
  {
    CFNumberRef v4 = _os_activity_create(&dword_18B299000, "SecTrustCopyTrustStoreAssetVersion", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v4, &state);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __SecTrustCopyTrustStoreAssetVersion_block_invoke_2;
    unint64_t v6[3] = &unk_1E54839A8;
    void v6[4] = &v8;
    securityd_send_sync_and_do(0x87u, a1, (uint64_t)&__block_literal_global_345, (uint64_t)v6);
    os_release(v4);
    uint64_t v3 = v9[3];
    os_activity_scope_leave(&state);
  }
  _Block_object_dispose(&v8, 8);
  return v3;
}

BOOL __SecTrustCopyTrustStoreAssetVersion_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  if (xdict && xpc_dictionary_get_value(xdict, "status") && MEMORY[0x18C12FBB0]() == MEMORY[0x1E4F145F0])
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
    return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
  }
  else
  {
    return SecError(-26276, a3, @"Unable to get trust store asset version");
  }
}

uint64_t __SecTrustCopyTrustStoreAssetVersion_block_invoke()
{
  return 1;
}

uint64_t SecTrustGetTrustStoreVersionNumber(CFTypeRef *a1)
{
  if (gTrustd && (CFNumberRef v2 = *(uint64_t (**)(void))(gTrustd + 64)) != 0)
  {
    return v2();
  }
  else
  {
    CFNumberRef v4 = _os_activity_create(&dword_18B299000, "SecTrustGetTrustStoreVersionNumber", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v4, &v6);
    uint64_t v5 = do_ota_pki_op(0x13u, a1);
    os_release(v4);
    os_activity_scope_leave(&v6);
    return v5;
  }
}

uint64_t do_ota_pki_op(unsigned int a1, CFTypeRef *a2)
{
  xpc_object_t message = securityd_create_message(a1, a2);
  if (message)
  {
    CFNumberRef v4 = message;
    uint64_t v5 = (void *)securityd_message_with_reply_sync(message, (uint64_t)a2);
    if (!v5)
    {
      uint64_t int64 = 0;
      os_activity_scope_state_s v6 = v4;
LABEL_15:
      xpc_release(v6);
      return uint64;
    }
    os_activity_scope_state_s v6 = v5;
    if (xpc_dictionary_get_value(v5, "status") && MEMORY[0x18C12FBB0]() == MEMORY[0x1E4F145F8])
    {
      uint64_t int64 = xpc_dictionary_get_uint64(v6, "status");
      if (!a2)
      {
LABEL_14:
        xpc_release(v4);
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t int64 = 0;
      if (!a2) {
        goto LABEL_14;
      }
    }
    if (xpc_dictionary_get_value(v6, "error"))
    {
      if (MEMORY[0x18C12FBB0]() == MEMORY[0x1E4F14590])
      {
        xpc_object_t value = xpc_dictionary_get_value(v6, "error");
        if (value) {
          *a2 = SecCreateCFErrorWithXPCObject(value);
        }
      }
    }
    goto LABEL_14;
  }
  return 0;
}

uint64_t SecTrustGetAssetVersionNumber(CFTypeRef *a1)
{
  if (gTrustd && (CFNumberRef v2 = *(uint64_t (**)(void))(gTrustd + 72)) != 0)
  {
    return v2();
  }
  else
  {
    CFNumberRef v4 = _os_activity_create(&dword_18B299000, "SecTrustGetAssetVersionNumber", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v4, &v6);
    uint64_t v5 = do_ota_pki_op(0x14u, a1);
    os_release(v4);
    os_activity_scope_leave(&v6);
    return v5;
  }
}

uint64_t SecTrustOTAPKIGetUpdatedAsset(CFTypeRef *a1)
{
  if (gTrustd && (CFNumberRef v2 = *(uint64_t (**)(void))(gTrustd + 80)) != 0)
  {
    return v2();
  }
  else
  {
    CFNumberRef v4 = _os_activity_create(&dword_18B299000, "SecTrustOTAPKIGetUpdatedAsset", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v4, &v6);
    uint64_t v5 = do_ota_pki_op(0x17u, a1);
    os_release(v4);
    os_activity_scope_leave(&v6);
    return v5;
  }
}

uint64_t SecTrustOTASecExperimentGetUpdatedAsset(CFTypeRef *a1)
{
  if (gTrustd && (CFNumberRef v2 = *(uint64_t (**)(void))(gTrustd + 88)) != 0)
  {
    return v2();
  }
  else
  {
    CFNumberRef v4 = _os_activity_create(&dword_18B299000, "SecTrustOTASecExperimentGetUpdatedAsset", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v4, &v6);
    uint64_t v5 = do_ota_pki_op(0x77u, a1);
    os_release(v4);
    os_activity_scope_leave(&v6);
    return v5;
  }
}

uint64_t SecTrustOTASecExperimentCopyAsset(CFTypeRef *a1)
{
  uint64_t v5 = 0;
  os_activity_scope_state_s v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  if (gTrustd && (SecTrustRef v1 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 96)) != 0)
  {
    uint64_t v2 = v1(a1);
  }
  else
  {
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 0x40000000;
    void v4[2] = __SecTrustOTASecExperimentCopyAsset_block_invoke_2;
    v4[3] = &unk_1E54839F0;
    void v4[4] = &v5;
    securityd_send_sync_and_do(0x76u, a1, (uint64_t)&__block_literal_global_352, (uint64_t)v4);
    uint64_t v2 = v6[3];
  }
  _Block_object_dispose(&v5, 8);
  return v2;
}

BOOL __SecTrustOTASecExperimentCopyAsset_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  if (xdict && xpc_dictionary_get_value(xdict, "status") && MEMORY[0x18C12FBB0]() == MEMORY[0x1E4F14590])
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
    return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
  }
  else
  {
    return SecError(-26276, a3, @"Unable to get SecExperiment Assets");
  }
}

uint64_t __SecTrustOTASecExperimentCopyAsset_block_invoke()
{
  return 1;
}

uint64_t SecTrustTriggerValidUpdate(CFTypeRef *a1)
{
  if (gTrustd && (uint64_t v2 = *(uint64_t (**)(void))(gTrustd + 200)) != 0)
  {
    return v2();
  }
  else
  {
    CFNumberRef v4 = _os_activity_create(&dword_18B299000, "SecTrustTriggerValidUpdate", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v4, &v6);
    uint64_t v5 = do_ota_pki_op(0x7Cu, a1);
    os_release(v4);
    os_activity_scope_leave(&v6);
    return v5 != 0;
  }
}

uint64_t SecTrustReportTLSAnalytics(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  BOOL v3 = 0;
  if (!a1 || !a2) {
    return v3;
  }
  if (!gTrustd || (uint64_t v7 = *(uint64_t (**)(void))(gTrustd + 144)) == 0)
  {
    uint64_t v9 = _os_activity_create(&dword_18B299000, "SecTrustReportTLSAnalytics", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v9, &state);
    uint64_t v12 = 0;
    CFNumberRef v13 = &v12;
    uint64_t v14 = 0x2000000000;
    char v15 = 0;
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 0x40000000;
    _OWORD v11[2] = __SecTrustReportTLSAnalytics_block_invoke;
    unint64_t v11[3] = &__block_descriptor_tmp_359;
    void v11[4] = a1;
    void v11[5] = a2;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 0x40000000;
    _OWORD v10[2] = __SecTrustReportTLSAnalytics_block_invoke_2;
    unint64_t v10[3] = &unk_1E5483A38;
    UInt8 v10[4] = &v12;
    securityd_send_sync_and_do(0x73u, a3, (uint64_t)v11, (uint64_t)v10);
    os_release(v9);
    BOOL v3 = *((unsigned char *)v13 + 24) != 0;
    _Block_object_dispose(&v12, 8);
    os_activity_scope_leave(&state);
    return v3;
  }

  return v7();
}

BOOL __SecTrustReportTLSAnalytics_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  BOOL v5 = SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"eventName", *(const __CFString **)(a1 + 32), a3);
  if (v5) {
    xpc_dictionary_set_value(a2, "eventAttributes", *(xpc_object_t *)(a1 + 40));
  }
  return v5;
}

uint64_t __SecTrustReportTLSAnalytics_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = xpc_dictionary_get_BOOL(xdict, "status");
  return 1;
}

uint64_t SecTrustEvaluateLeafOnly(__SecTrust *a1, int *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 4294967246;
  }
  uint64_t result = SecTrustValidateInput(a1);
  if (!result)
  {
    long long context = xmmword_18B41A3E8;
    long long v52 = unk_18B41A3F8;
    memset(v53, 170, sizeof(v53));
    uint64_t v47 = 0;
    CFNumberRef v48 = &v47;
    uint64_t v49 = 0x2000000000;
    uint64_t v50 = 0;
    uint64_t v43 = 0;
    CFNumberRef v44 = &v43;
    uint64_t v45 = 0x2000000000;
    uint64_t v46 = 0;
    BOOL v5 = *((void *)a1 + 17);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __SecTrustEvaluateLeafOnly_block_invoke;
    block[3] = &unk_1E5483AA8;
    void block[5] = &v43;
    void block[6] = a1;
    block[4] = &v47;
    dispatch_sync(v5, block);
    os_activity_scope_state_s v6 = (const void *)v48[3];
    uint64_t v7 = (const void *)v44[3];
    CFAbsoluteTime VerifyTime = SecTrustGetVerifyTime(a1);
    if (v6) {
      CFRetain(v6);
    }
    *(void *)&long long context = v6;
    if (v7) {
      CFRetain(v7);
    }
    *((void *)&context + 1) = v7;
    *(CFAbsoluteTime *)&long long v52 = VerifyTime;
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v10 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], 0);
    CFDictionaryAddValue(Mutable, @"SSLHostname", SecPolicyCheckCertSSLHostname);
    CFDictionaryAddValue(Mutable, @"Email", SecPolicyCheckCertEmail);
    CFDictionaryAddValue(Mutable, @"TemporalValidity", SecPolicyCheckCertTemporalValidity);
    CFDictionaryAddValue(Mutable, @"ValidLeaf", SecPolicyCheckCertValidLeaf);
    CFDictionaryAddValue(Mutable, @"WeakKeySize", SecPolicyCheckCertWeakKeySize);
    CFDictionaryAddValue(Mutable, @"WeakSignature", SecPolicyCheckCertWeakSignature);
    CFDictionaryAddValue(Mutable, @"KeyUsage", SecPolicyCheckCertKeyUsage);
    CFDictionaryAddValue(Mutable, @"ExtendedKeyUsage", SecPolicyCheckCertExtendedKeyUsage);
    CFDictionaryAddValue(Mutable, @"SubjectCommonName", SecPolicyCheckCertSubjectCommonName);
    CFDictionaryAddValue(Mutable, @"SubjectCommonNamePrefix", SecPolicyCheckCertSubjectCommonNamePrefix);
    CFDictionaryAddValue(Mutable, @"SubjectCommonNameTEST", SecPolicyCheckCertSubjectCommonNameTEST);
    CFDictionaryAddValue(Mutable, @"SubjectOrganization", SecPolicyCheckCertSubjectOrganization);
    CFDictionaryAddValue(Mutable, @"SubjectOrganizationalUnit", SecPolicyCheckCertSubjectOrganizationalUnit);
    CFDictionaryAddValue(Mutable, @"NotValidBefore", SecPolicyCheckCertNotValidBefore);
    CFDictionaryAddValue(Mutable, @"EAPTrustedServerNames", SecPolicyCheckCertEAPTrustedServerNames);
    CFDictionaryAddValue(Mutable, @"LeafMarkerOid", SecPolicyCheckCertLeafMarkerOid);
    CFDictionaryAddValue(Mutable, @"LeafMarkerOidWithoutValueCheck", SecPolicyCheckCertLeafMarkerOidWithoutValueCheck);
    CFDictionaryAddValue(Mutable, @"LeafMarkersProdAndQA", SecPolicyCheckCertLeafMarkersProdAndQA);
    CFDictionaryAddValue(Mutable, @"NotCA", SecPolicyCheckCertNotCA);
    CFDictionaryAddValue(Mutable, @"NonEmptySubject", SecPolicyCheckCertNonEmptySubject);
    CFDictionaryAddValue(Mutable, @"KeySize", SecPolicyCheckCertKeySize);
    CFDictionaryAddValue(Mutable, @"SignatureHashAlgorithms", SecPolicyCheckCertSignatureHashAlgorithms);
    CFDictionaryAddValue(Mutable, @"CertificatePolicy", SecPolicyCheckCertCertificatePolicy);
    CFDictionaryAddValue(Mutable, @"CriticalExtensions", SecPolicyCheckCertCriticalExtensions);
    CFDictionaryAddValue(Mutable, @"UnparseableExtension", SecPolicyCheckCertUnparseableExtension);
    CFDictionaryAddValue(Mutable, @"DuplicateExtension", SecPolicyCheckCertDuplicateExtension);
    *((void *)&v53[0] + 1) = Mutable;
    *(void *)&v53[1] = 0;
    *(void *)values = CFDictionaryCreateMutable(v9, 0, v10, MEMORY[0x1E4F1D540]);
    BOOL v12 = 1;
    *((void *)&v52 + 1) = CFArrayCreate(v9, (const void **)values, 1, MEMORY[0x1E4F1D510]);
    CFRelease(*(CFTypeRef *)values);
    BYTE8(v53[1]) = 1;
    CFIndex Count = CFArrayGetCount((CFArrayRef)v7);
    if (Count < 1)
    {
      int v18 = 4;
    }
    else
    {
      CFIndex v14 = Count;
      for (CFIndex i = 0; i != v14; ++i)
      {
        CFDictionaryRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex((CFArrayRef)v7, i);
        *(void *)&v53[1] = i;
        CFDictionaryApplyFunction(ValueAtIndex[4], (CFDictionaryApplierFunction)SecLeafPVCValidateKey, &context);
        if (BYTE8(v53[1])) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = *((void *)&v52 + 1) == 0;
        }
        if (v17)
        {
          BOOL v12 = 0;
          int v18 = 5;
          goto LABEL_20;
        }
      }
      BOOL v12 = BYTE8(v53[1]) != 0;
      if (BYTE8(v53[1])) {
        int v18 = 4;
      }
      else {
        int v18 = 5;
      }
    }
LABEL_20:
    double v19 = SecTrustGetVerifyTime(a1);
    double v20 = *(double *)(v48[3] + 176);
    double Current = CFAbsoluteTimeGetCurrent();
    if (v20 >= v19 + 4500.0 || v20 <= Current) {
      double v20 = v19 + 4500.0;
    }
    CFDateRef v23 = CFDateCreate(0, v19);
    CFDateRef v24 = CFDateCreate(0, v20);
    CFNumberRef v25 = *((void *)a1 + 17);
    v34[0] = MEMORY[0x1E4F143A8];
    v34[1] = 0x40000000;
    long long v35 = context;
    long long v36 = v52;
    long long v37 = v53[0];
    long long v38 = v53[1];
    v34[2] = __SecTrustEvaluateLeafOnly_block_invoke_2;
    void v34[3] = &__block_descriptor_tmp_364;
    v34[4] = a1;
    int v41 = v18;
    CFDateRef v39 = v23;
    CFDateRef v40 = v24;
    dispatch_sync(v25, v34);
    CFNumberRef v26 = (const void *)*((void *)&context + 1);
    if (*((void *)&context + 1))
    {
      *((void *)&context + 1) = 0;
      CFRelease(v26);
    }
    CFNumberRef v27 = (const void *)*((void *)&v52 + 1);
    if (*((void *)&v52 + 1))
    {
      *((void *)&v52 + 1) = 0;
      CFRelease(v27);
    }
    CFNumberRef v28 = (const void *)*((void *)&v53[0] + 1);
    if (*((void *)&v53[0] + 1))
    {
      *((void *)&v53[0] + 1) = 0;
      CFRelease(v28);
    }
    CFNumberRef v29 = (const void *)context;
    if ((void)context)
    {
      *(void *)&long long context = 0;
      CFRelease(v29);
    }
    if (!v12)
    {
      CFNumberRef v30 = SecTrustCopyFailureDescription(a1);
      CFNumberRef v31 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)values = 138412290;
        *(void *)&values[4] = v30;
        _os_log_impl(&dword_18B299000, v31, OS_LOG_TYPE_DEFAULT, "%@", values, 0xCu);
      }
      CFRelease(v30);
    }
    if (a2) {
      *a2 = v18;
    }
    CFNumberRef v32 = (const void *)v48[3];
    if (v32) {
      CFRelease(v32);
    }
    CFNumberRef v33 = (const void *)v44[3];
    if (v33) {
      CFRelease(v33);
    }
    if (v23) {
      CFRelease(v23);
    }
    if (v24) {
      CFRelease(v24);
    }
    _Block_object_dispose(&v43, 8);
    _Block_object_dispose(&v47, 8);
    return 0;
  }
  return result;
}

const void *__SecTrustEvaluateLeafOnly_block_invoke(void *a1)
{
  uint64_t result = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1[6] + 16), 0);
  BOOL v3 = result;
  if (result) {
    uint64_t result = CFRetain(result);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = v3;
  uint64_t v4 = a1[6];
  uint64_t v5 = *(void *)(v4 + 32);
  if (v5) {
    uint64_t result = CFRetain(*(CFTypeRef *)(v4 + 32));
  }
  *(void *)(*(void *)(a1[5] + 8) + 24) = v5;
  return result;
}

void __SecTrustEvaluateLeafOnly_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(_DWORD *)(v2 + 112) = *(_DWORD *)(a1 + 120);
  BOOL v3 = *(const void **)(v2 + 88);
  if (v3)
  {
    *(void *)(v2 + 88) = 0;
    CFRelease(v3);
  }
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
    CFRetain(*(CFTypeRef *)(a1 + 64));
  }
  *(void *)(*(void *)(a1 + 32) + 88) = v4;
  CFMutableArrayRef MutableCopy = CFArrayCreateMutableCopy(0, 1, *(CFArrayRef *)(*(void *)(a1 + 32) + 16));
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(const void **)(v6 + 72);
  if (v7)
  {
    *(void *)(v6 + 72) = 0;
    CFRelease(v7);
    uint64_t v6 = *(void *)(a1 + 32);
  }
  *(void *)(v6 + 72) = MutableCopy;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFAllocatorRef v9 = Mutable;
  uint64_t v10 = *(const void **)(a1 + 104);
  if (v10) {
    CFDictionarySetValue(Mutable, @"TrustResultNotBefore", v10);
  }
  uint64_t v11 = *(const void **)(a1 + 112);
  if (v11) {
    CFDictionarySetValue(v9, @"TrustResultNotAfter", v11);
  }
  uint64_t v12 = *(void *)(a1 + 32);
  CFNumberRef v13 = *(const void **)(v12 + 96);
  if (v13)
  {
    *(void *)(v12 + 96) = 0;
    CFRelease(v13);
    uint64_t v12 = *(void *)(a1 + 32);
  }
  *(void *)(v12 + 96) = v9;
}

SecTrustRef SecTrustDeserialize(const __CFData *a1, __CFString **a2, uint64_t a3)
{
  if (!a1)
  {
    SecError(-50, a2, @"null serialized trust input");
    return 0;
  }
  CFTypeRef v4 = CFPropertyListCreateWithDERData(0, a1, a3, 0, (CFTypeRef *)a2);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  SecTrustRef trust = 0;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v5)) {
    goto LABEL_57;
  }
  CFNumberRef Value = CFDictionaryGetValue((CFDictionaryRef)v5, @"certificates");
  if (!Value) {
    goto LABEL_57;
  }
  CFMutableArrayRef v8 = SecCertificateArrayDeserialize(Value);
  if (!v8) {
    goto LABEL_57;
  }
  CFMutableArrayRef v9 = v8;
  CFArrayRef v10 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v5, @"policies");
  if (!v10
    || (CFArrayRef v11 = v10, v12 = CFGetTypeID(v10), v12 != CFArrayGetTypeID())
    || (CFIndex Count = CFArrayGetCount(v11),
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]),
        v57.CFIndex location = 0,
        v57.CFIndex length = Count,
        CFArrayApplyFunction(v11, v57, (CFArrayApplierFunction)deserializePolicy, Mutable),
        !Mutable))
  {
    CFRelease(v9);
LABEL_57:
    SecTrustRef v53 = 0;
    int v49 = -50;
    goto LABEL_58;
  }
  OSStatus v15 = SecTrustCreateWithCertificates(v9, Mutable, &trust);
  if (v15)
  {
    int v49 = v15;
    SecTrustRef v53 = 0;
    goto LABEL_53;
  }
  uint64_t v16 = CFDictionaryGetValue((CFDictionaryRef)v5, @"anchors");
  if (v16)
  {
    BOOL v17 = v16;
    CFTypeID v18 = CFGetTypeID(v16);
    if (v18 == CFArrayGetTypeID())
    {
      CFMutableArrayRef v19 = SecCertificateArrayDeserialize(v17);
      *((void *)trust + 3) = v19;
    }
  }
  double v20 = CFDictionaryGetValue((CFDictionaryRef)v5, @"responses");
  if (v20)
  {
    CFNumberRef v21 = v20;
    CFTypeID v22 = CFGetTypeID(v20);
    if (v22 == CFArrayGetTypeID())
    {
      CFRetain(v21);
      *((void *)trust + 5) = v21;
    }
  }
  CFDateRef v23 = CFDictionaryGetValue((CFDictionaryRef)v5, @"scts");
  if (v23)
  {
    CFDateRef v24 = v23;
    CFTypeID v25 = CFGetTypeID(v23);
    if (v25 == CFArrayGetTypeID())
    {
      CFRetain(v24);
      *((void *)trust + 6) = v24;
    }
  }
  CFNumberRef v26 = CFDictionaryGetValue((CFDictionaryRef)v5, @"trustedLogs");
  if (v26)
  {
    CFNumberRef v27 = v26;
    CFTypeID v28 = CFGetTypeID(v26);
    if (v28 == CFArrayGetTypeID())
    {
      CFRetain(v27);
      *((void *)trust + 7) = v27;
    }
  }
  CFNumberRef v29 = CFDictionaryGetValue((CFDictionaryRef)v5, @"verifyDate");
  if (v29)
  {
    CFNumberRef v30 = v29;
    CFTypeID v31 = CFGetTypeID(v29);
    if (v31 == CFDateGetTypeID())
    {
      CFRetain(v30);
      *((void *)trust + 8) = v30;
    }
  }
  CFNumberRef v32 = CFDictionaryGetValue((CFDictionaryRef)v5, @"chain");
  if (v32)
  {
    CFNumberRef v33 = v32;
    CFTypeID v34 = CFGetTypeID(v32);
    if (v34 == CFArrayGetTypeID())
    {
      CFMutableArrayRef v35 = SecCertificateArrayDeserialize(v33);
      *((void *)trust + 9) = v35;
    }
  }
  long long v36 = CFDictionaryGetValue((CFDictionaryRef)v5, @"details");
  if (v36)
  {
    long long v37 = v36;
    CFTypeID v38 = CFGetTypeID(v36);
    if (v38 == CFArrayGetTypeID())
    {
      CFRetain(v37);
      *((void *)trust + 11) = v37;
    }
  }
  CFDateRef v39 = CFDictionaryGetValue((CFDictionaryRef)v5, @"info");
  if (v39)
  {
    CFDateRef v40 = v39;
    CFTypeID v41 = CFGetTypeID(v39);
    if (v41 == CFDictionaryGetTypeID())
    {
      CFRetain(v40);
      *((void *)trust + 12) = v40;
    }
  }
  CFNumberRef v42 = CFDictionaryGetValue((CFDictionaryRef)v5, @"exceptions");
  if (v42)
  {
    uint64_t v43 = v42;
    CFTypeID v44 = CFGetTypeID(v42);
    if (v44 == CFArrayGetTypeID())
    {
      CFRetain(v43);
      *((void *)trust + 13) = v43;
    }
  }
  int valuePtr = -1;
  CFNumberRef v45 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v5, @"result");
  CFNumberRef v46 = v45;
  if (v45)
  {
    CFTypeID v47 = CFGetTypeID(v45);
    if (v47 == CFNumberGetTypeID())
    {
      int v48 = CFNumberGetValue(v46, kCFNumberSInt32Type, &valuePtr);
      LODWORD(v46) = 0;
      int v49 = -50;
      if (v48 && (valuePtr & 0x80000000) == 0)
      {
        int v49 = 0;
        *((_DWORD *)trust + 28) = valuePtr;
        LODWORD(v46) = 1;
      }
      goto LABEL_44;
    }
    LODWORD(v46) = 0;
  }
  int v49 = -50;
LABEL_44:
  if (CFDictionaryGetValue((CFDictionaryRef)v5, @"anchorsOnly") == (const void *)*MEMORY[0x1E4F1CFD0]) {
    *((unsigned char *)trust + 116) = 1;
  }
  uint64_t v50 = CFDictionaryGetValue((CFDictionaryRef)v5, @"keychainsAllowed");
  SecTrustRef v51 = trust;
  if (v50 == (const void *)*MEMORY[0x1E4F1CFC8]) {
    *((unsigned char *)trust + 117) = 0;
  }
  BOOL v52 = v46 == 0;
  if (v46) {
    SecTrustRef v53 = v51;
  }
  else {
    SecTrustRef v53 = 0;
  }
  if (!v52) {
    int v49 = 0;
  }
LABEL_53:
  CFRelease(Mutable);
  CFRelease(v9);
  if (v49) {
LABEL_58:
  }
    SecError(v49, a2, @"unable to create trust ref");
  CFRelease(v5);
  return v53;
}

CFMutableArrayRef SecCertificateArrayDeserialize(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFArrayGetTypeID()) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
  v6.CFIndex location = 0;
  v6.CFIndex length = Count;
  CFArrayApplyFunction((CFArrayRef)a1, v6, (CFArrayApplierFunction)deserializeCert, Mutable);
  return Mutable;
}

void deserializeCert(const void *a1, __CFArray *a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFDataGetTypeID())
    {
      SecCertificateRef v5 = SecCertificateCreateWithData(0, (CFDataRef)a1);
      if (v5)
      {
        SecCertificateRef v6 = v5;
        CFArrayAppendValue(a2, v5);
        CFRelease(v6);
      }
    }
  }
}

uint64_t SecTrustIncrementExceptionResetCount(CFTypeRef *a1)
{
  CFTypeID v2 = _os_activity_create(&dword_18B299000, "SecTrustIncrementExceptionResetCount", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  v9.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v9.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v2, &v9);
  if (gTrustd && (BOOL v3 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 168)) != 0)
  {
    char v4 = v3(a1);
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v16 = &v15;
    uint64_t v17 = 0x2000000000;
    char v18 = 0;
    *(void *)long long buf = MEMORY[0x1E4F143A8];
    uint64_t v11 = 0x40000000;
    CFTypeID v12 = __to_BOOL_error_request_block_invoke;
    CFNumberRef v13 = &unk_1E5484288;
    CFIndex v14 = &v15;
    securityd_send_sync_and_do(0x79u, a1, 0, (uint64_t)buf);
    char v4 = *((unsigned char *)v16 + 24) != 0;
    _Block_object_dispose(&v15, 8);
  }
  os_release(v2);
  if (a1)
  {
    if (*a1) {
      char v5 = 0;
    }
    else {
      char v5 = v4;
    }
    if (v5) {
      goto LABEL_10;
    }
  }
  else if (v4)
  {
LABEL_10:
    uint64_t v6 = 0;
    goto LABEL_15;
  }
  uint64_t v7 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_18B299000, v7, OS_LOG_TYPE_DEFAULT, "Failed to increment the exceptions epoch.", buf, 2u);
  }
  uint64_t v6 = 4294941020;
LABEL_15:
  os_activity_scope_leave(&v9);
  return v6;
}

uint64_t SecTrustSetClientAuditToken(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 4294967246;
  }
  char v4 = *(NSObject **)(a1 + 136);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_68_13884;
  block[4] = a1;
  dispatch_sync(v4, block);
  char v5 = *(NSObject **)(a1 + 136);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  _DWORD v7[2] = __SecTrustSetClientAuditToken_block_invoke;
  void v7[3] = &__block_descriptor_tmp_377;
  UInt8 v7[4] = a1;
  void v7[5] = a2;
  dispatch_sync(v5, v7);
  return 0;
}

void __SecTrustSetClientAuditToken_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  SecTrustRef v1 = *(const void **)(a1 + 40);
  BOOL v3 = *(const void **)(v2 + 144);
  if (v3 != v1)
  {
    if (!v1 || (CFRetain(v1), (BOOL v3 = *(const void **)(v2 + 144)) != 0)) {
      CFRelease(v3);
    }
    *(void *)(v2 + 144) = v1;
  }
}

uint64_t SecTrustGetAppleAnchors()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecGetAppleTrustAnchors_block_invoke;
  block[3] = &__block_descriptor_tmp_1_15837;
  char v2 = 0;
  if (SecGetAppleTrustAnchors_onceToken != -1) {
    dispatch_once(&SecGetAppleTrustAnchors_onceToken, block);
  }
  return SecGetAppleTrustAnchors_anchors;
}

__CFString *SecTrustStoreDomainName(CFTypeRef cf)
{
  CFTypeRef v1 = cf;
  if (cf)
  {
    if (gTrustd)
    {
      char v2 = @"user";
      if ((CFTypeRef)(*(uint64_t (**)(__CFString *, void))gTrustd)(@"user", 0) == cf) {
        return v2;
      }
      char v2 = @"admin";
      if ((CFTypeRef)(*(uint64_t (**)(__CFString *, void))gTrustd)(@"admin", 0) == v1) {
        return v2;
      }
      char v2 = @"system";
      if ((CFTypeRef)(*(uint64_t (**)(__CFString *, void))gTrustd)(@"system", 0) == v1) {
        return v2;
      }
    }
    else
    {
      CFTypeID v3 = CFGetTypeID(cf);
      if (v3 == CFStringGetTypeID()) {
        return (__CFString *)v1;
      }
    }
    return 0;
  }
  return (__CFString *)v1;
}

__CFString *SecTrustSettingsDomainName(unsigned int a1)
{
  if (a1 > 2) {
    return 0;
  }
  else {
    return off_1E5484748[a1];
  }
}

uint64_t SecTrustSettingsDomainForName(CFTypeRef cf2)
{
  if (!cf2) {
    return 0xFFFFFFFFLL;
  }
  if (CFEqual(@"user", cf2)) {
    return 0;
  }
  if (CFEqual(@"admin", cf2)) {
    return 1;
  }
  if (CFEqual(@"system", cf2)) {
    return 2;
  }
  return 0xFFFFFFFFLL;
}

BOOL SecXPCDictionarySetCertificate(void *a1, uint64_t a2, __CFString **a3)
{
  if (a2 && (int64_t v3 = *(void *)(a2 + 24), v3 >= 1))
  {
    xpc_dictionary_set_data(a1, "cert", *(const void **)(a2 + 16), v3);
    return 1;
  }
  else
  {
    return SecError(-50, a3, @"NULL certificate");
  }
}

uint64_t SecTrustStoreSetTrustSettings(uint64_t a1, void *a2, const __CFArray *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v22 = 0;
  CFDateRef v23 = &v22;
  uint64_t v24 = 0x2000000000;
  int v25 = -1431655766;
  uint64_t v18 = 0;
  CFMutableArrayRef v19 = (__CFArray **)&v18;
  uint64_t v20 = 0x2000000000;
  uint64_t v21 = 0;
  if (SecCertificateIsCertificate(a2))
  {
    BOOL IsSelfSigned = _SecCertificateIsSelfSigned((uint64_t)a2);
    *((_DWORD *)v23 + 6) = 0;
    int v7 = validateTrustSettings(IsSelfSigned, a3, v19 + 3);
    *((_DWORD *)v23 + 6) = v7;
    if (!v7)
    {
      v17[0] = MEMORY[0x1E4F143A8];
      v17[1] = 0x40000000;
      size_t v17[2] = __SecTrustStoreSetTrustSettings_block_invoke;
      unint64_t v17[3] = &unk_1E5484348;
      v17[6] = a1;
      v17[7] = a2;
      void v17[4] = &v22;
      void v17[5] = &v18;
      _os_activity_initiate(&dword_18B299000, "SecTrustStoreSetTrustSettings", OS_ACTIVITY_FLAG_DEFAULT, v17);
      if (!*((_DWORD *)v23 + 6))
      {
        CFMutableArrayRef v8 = secLogObjForScope("truststore");
        if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_10;
        }
        *(_DWORD *)long long buf = 141558274;
        uint64_t v27 = 1752392040;
        __int16 v28 = 2112;
        CFNumberRef v29 = a2;
        os_activity_scope_state_s v9 = "Set TrustSettings for %{mask.hash}@";
        CFArrayRef v10 = v8;
        uint32_t v11 = 22;
        goto LABEL_9;
      }
    }
  }
  else
  {
    *((_DWORD *)v23 + 6) = -26275;
  }
  CFTypeID v12 = secLogObjForScope("SecError");
  if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_10;
  }
  int v13 = *((_DWORD *)v23 + 6);
  *(_DWORD *)long long buf = 141558530;
  uint64_t v27 = 1752392040;
  __int16 v28 = 2112;
  CFNumberRef v29 = a2;
  __int16 v30 = 1024;
  int v31 = v13;
  os_activity_scope_state_s v9 = "Failed set trust settings for %{mask.hash}@, %d";
  CFArrayRef v10 = v12;
  uint32_t v11 = 28;
LABEL_9:
  _os_log_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
LABEL_10:
  CFIndex v14 = v19[3];
  if (v14)
  {
    v19[3] = 0;
    CFRelease(v14);
  }
  uint64_t v15 = *((unsigned int *)v23 + 6);
  _Block_object_dispose(&v18, 8);
  _Block_object_dispose(&v22, 8);
  return v15;
}

uint64_t validateTrustSettings(uint64_t a1, const __CFArray *a2, __CFArray **a3)
{
  if (a1 && !a2) {
    return 0;
  }
  if (!a1 && !a2) {
    return 4294967246;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(a2))
  {
    CFTypeID v14 = CFArrayGetTypeID();
    if (v14 == CFGetTypeID(a2))
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
      if (!Mutable) {
        return 4294967188;
      }
      CFMutableArrayRef MutableCopy = Mutable;
      CFIndex Count = CFArrayGetCount(a2);
      if (Count < 1)
      {
        uint64_t v6 = 4294967246;
      }
      else
      {
        CFIndex v17 = Count;
        CFIndex v18 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a2, v18);
          xpc_object_t value = 0;
          uint64_t v20 = validateTrustSettings(a1, ValueAtIndex, &value);
          if (v20) {
            break;
          }
          CFArrayAppendValue(MutableCopy, value);
          uint64_t v21 = value;
          if (value)
          {
            xpc_object_t value = 0;
            CFRelease(v21);
          }
          if (v17 == ++v18) {
            goto LABEL_31;
          }
        }
        uint64_t v6 = v20;
      }
      goto LABEL_38;
    }
    return 4294967246;
  }
  CFMutableArrayRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a2);
  os_activity_scope_state_s v9 = CFDictionaryGetValue(MutableCopy, @"kSecTrustSettingsResult");
  int valuePtr = 0;
  if (v9)
  {
    CFArrayRef v10 = v9;
    CFTypeID v11 = CFGetTypeID(v9);
    CFTypeID v12 = CFNumberGetTypeID();
    if (!a1 && v11 != v12) {
      goto LABEL_16;
    }
    CFTypeID v13 = CFGetTypeID(v10);
    if (v13 == CFNumberGetTypeID()
      && CFNumberGetValue((CFNumberRef)v10, kCFNumberSInt32Type, &valuePtr)
      && (a1 && valuePtr == 2 || !a1 && valuePtr == 1))
    {
      goto LABEL_16;
    }
  }
  else if (!a1)
  {
LABEL_16:
    uint64_t v6 = 4294967246;
    goto LABEL_32;
  }
  uint64_t v22 = CFDictionaryGetValue(MutableCopy, @"kSecTrustSettingsPolicy");
  if (v22)
  {
    CFDateRef v23 = (const void *)*((void *)v22 + 3);
    CFDictionarySetValue(MutableCopy, @"kSecTrustSettingsPolicy", *((const void **)v22 + 2));
    if (v23) {
      CFDictionaryAddValue(MutableCopy, @"kSecTrustSettingsPolicyName", v23);
    }
  }
LABEL_31:
  uint64_t v6 = 0;
LABEL_32:
  if (a3 && !v6)
  {
    if (MutableCopy) {
      CFRetain(MutableCopy);
    }
    uint64_t v6 = 0;
    *a3 = MutableCopy;
  }
  if (MutableCopy) {
LABEL_38:
  }
    CFRelease(MutableCopy);
  return v6;
}

uint64_t __SecTrustStoreSetTrustSettings_block_invoke(uint64_t a1)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = __SecTrustStoreSetTrustSettings_block_invoke_2;
  v3[3] = &unk_1E5484320;
  uint64_t v5 = *(void *)(a1 + 56);
  long long v4 = *(_OWORD *)(a1 + 40);
  uint64_t result = SecOSStatusWith((uint64_t)v3);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t __SecTrustStoreSetTrustSettings_block_invoke_2(void *a1, CFTypeRef *a2)
{
  if (gTrustd && (int64_t v3 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFTypeRef *))(gTrustd + 16)) != 0)
  {
    uint64_t v4 = a1[6];
    uint64_t v5 = *(void *)(*(void *)(a1[4] + 8) + 24);
    uint64_t v6 = a1[5];
    return v3(v6, v4, v5, a2);
  }
  else
  {
    uint64_t v8 = *(void *)(*(void *)(a1[4] + 8) + 24);
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    _OWORD v9[2] = __string_cert_cftype_to_error_block_invoke;
    v9[3] = &__block_descriptor_tmp_68_14212;
    long long v10 = *(_OWORD *)(a1 + 5);
    uint64_t v11 = v8;
    return securityd_send_sync_and_do(5u, a2, (uint64_t)v9, 0);
  }
}

size_t __string_cert_cftype_to_error_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  size_t result = SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"domain", *(const __CFString **)(a1 + 32), a3);
  if (result)
  {
    size_t result = SecXPCDictionarySetCertificate(a2, *(void *)(a1 + 40), a3);
    if (result)
    {
      CFStringRef v11 = *(const __CFString **)(a1 + 48);
      if (v11)
      {
        return SecXPCDictionarySetPListWithRepair(a2, "settings", v11, a3, v7, v8, v9, v10);
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t SecTrustStoreRemoveCertificate(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = _os_activity_create(&dword_18B299000, "SecTrustStoreRemoveCertificate", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &state);
  if (!a1)
  {
    uint64_t v5 = 4294967246;
LABEL_3:
    uint64_t v6 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 141558530;
      uint64_t v12 = 1752392040;
      __int16 v13 = 2112;
      uint64_t v14 = a2;
      __int16 v15 = 1024;
      int v16 = v5;
      _os_log_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEFAULT, "Failed to remove trust settings for %{mask.hash}@, %d", buf, 0x1Cu);
    }
    goto LABEL_7;
  }
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  _OWORD v9[2] = __SecTrustStoreRemoveCertificate_block_invoke;
  v9[3] = &__block_descriptor_tmp_8_14223;
  void v9[4] = a1;
  void v9[5] = a2;
  uint64_t v5 = SecOSStatusWith((uint64_t)v9);
  if (v5) {
    goto LABEL_3;
  }
  uint64_t v7 = secLogObjForScope("truststore");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 141558274;
    uint64_t v12 = 1752392040;
    __int16 v13 = 2112;
    uint64_t v14 = a2;
    _os_log_impl(&dword_18B299000, v7, OS_LOG_TYPE_DEFAULT, "Removed TrustSettings for %{mask.hash}@", buf, 0x16u);
    uint64_t v5 = 0;
  }
LABEL_7:
  os_release(v4);
  os_activity_scope_leave(&state);
  return v5;
}

uint64_t __SecTrustStoreRemoveCertificate_block_invoke(uint64_t a1, CFTypeRef *a2)
{
  if (gTrustd && (int64_t v3 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *))(gTrustd + 24)) != 0)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 32);
    return v3(v5, v4, a2);
  }
  else
  {
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    _DWORD v7[2] = __string_cert_to_BOOL_error_block_invoke;
    void v7[3] = &__block_descriptor_tmp_69_14226;
    long long v8 = *(_OWORD *)(a1 + 32);
    return securityd_send_sync_and_do(6u, a2, (uint64_t)v7, 0);
  }
}

uint64_t SecTrustStoreGetSettingsVersionNumber(_DWORD *a1)
{
  if (!a1) {
    return 4294967246;
  }
  CFErrorRef err = 0;
  *a1 = SecTrustGetTrustStoreVersionNumber((CFTypeRef *)&err);
  if (!err) {
    return 0;
  }
  CFIndex Code = CFErrorGetCode(err);
  if (err) {
    CFRelease(err);
  }
  return Code;
}

uint64_t SecTrustStoreGetSettingsAssetVersionNumber(_DWORD *a1)
{
  if (!a1) {
    return 4294967246;
  }
  CFErrorRef err = 0;
  *a1 = SecTrustGetAssetVersionNumber((CFTypeRef *)&err);
  if (!err) {
    return 0;
  }
  CFIndex Code = CFErrorGetCode(err);
  if (err) {
    CFRelease(err);
  }
  return Code;
}

uint64_t SecTrustStoreCopyAll(uint64_t a1, void *a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  uint64_t v12 = 0;
  uint64_t v4 = _os_activity_create(&dword_18B299000, "SecTrustStoreCopyAll", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &state);
  if (a1)
  {
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    _DWORD v7[2] = __SecTrustStoreCopyAll_block_invoke;
    void v7[3] = &unk_1E5484390;
    void v7[4] = &v9;
    void v7[5] = a1;
    uint64_t v5 = SecOSStatusWith((uint64_t)v7);
    *a2 = v10[3];
  }
  else
  {
    uint64_t v5 = 4294967246;
  }
  os_release(v4);
  os_activity_scope_leave(&state);
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t __SecTrustStoreCopyAll_block_invoke(uint64_t a1, CFTypeRef *a2)
{
  if (gTrustd && (int64_t v3 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *))(gTrustd + 120)) != 0)
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8) + 24;
    uint64_t v5 = *(void *)(a1 + 40);
    return v3(v5, v4, a2);
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8) + 24;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 0x40000000;
    _OWORD v10[2] = __string_to_array_error_block_invoke;
    unint64_t v10[3] = &__block_descriptor_tmp_70_14229;
    UInt8 v10[4] = v7;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    _OWORD v9[2] = __string_to_array_error_block_invoke_2;
    v9[3] = &__block_descriptor_tmp_71_14230;
    void v9[4] = v8;
    return securityd_send_sync_and_do(0x64u, a2, (uint64_t)v10, (uint64_t)v9);
  }
}

BOOL __string_to_array_error_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  return SecXPCDictionarySetString(a2, (uint64_t)"domain", *(const __CFString **)(a1 + 32), a3);
}

BOOL __string_to_array_error_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  BOOL result = 1;
  if (*(void *)(a1 + 32))
  {
    **(void **)(a1 + 32) = SecXPCDictionaryCopyArray(xdict, "status", a3);
    if (!**(void **)(a1 + 32)) {
      return 0;
    }
  }
  return result;
}

uint64_t SecTrustStoreCopyUsageConstraints(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2000000000;
  uint64_t v23 = 0;
  uint64_t v6 = _os_activity_create(&dword_18B299000, "SecTrustStoreCopyUsageConstraints", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v6, &state);
  uint64_t v7 = 4294967246;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        v18[0] = MEMORY[0x1E4F143A8];
        v18[1] = 0x40000000;
        void v18[2] = __SecTrustStoreCopyUsageConstraints_block_invoke;
        void v18[3] = &unk_1E54843B8;
        void v18[5] = a1;
        void v18[6] = a2;
        void v18[4] = &v20;
        uint64_t v7 = SecOSStatusWith((uint64_t)v18);
        uint64_t v8 = v21;
        *a3 = v21[3];
        if (!v7)
        {
          CFArrayRef v10 = (const __CFArray *)v8[3];
          if (!v10)
          {
            __int16 v15 = secLogObjForScope("truststore");
            uint64_t v7 = 0;
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_18;
            }
            *(_DWORD *)long long buf = 141558274;
            uint64_t v25 = 1752392040;
            __int16 v26 = 2112;
            uint64_t v27 = a2;
            uint64_t v14 = "Found no trust settings for %{mask.hash}@";
            int v16 = v15;
            goto LABEL_16;
          }
          CFIndex Count = CFArrayGetCount(v10);
          uint64_t v12 = secLogObjForScope("truststore");
          BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
          if (Count)
          {
            if (v13)
            {
              *(_DWORD *)long long buf = 141558274;
              uint64_t v25 = 1752392040;
              __int16 v26 = 2112;
              uint64_t v27 = a2;
              uint64_t v14 = "Found usage constraints for %{mask.hash}@";
LABEL_15:
              int v16 = v12;
LABEL_16:
              _os_log_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEFAULT, v14, buf, 0x16u);
            }
          }
          else if (v13)
          {
            *(_DWORD *)long long buf = 141558274;
            uint64_t v25 = 1752392040;
            __int16 v26 = 2112;
            uint64_t v27 = a2;
            uint64_t v14 = "Found no usage constraints for %{mask.hash}@";
            goto LABEL_15;
          }
          uint64_t v7 = 0;
          goto LABEL_18;
        }
      }
    }
  }
  uint64_t v9 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 141558530;
    uint64_t v25 = 1752392040;
    __int16 v26 = 2112;
    uint64_t v27 = a2;
    __int16 v28 = 1024;
    int v29 = v7;
    _os_log_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEFAULT, "Failed to get usage contraints for %{mask.hash}@, %d", buf, 0x1Cu);
  }
LABEL_18:
  os_release(v6);
  os_activity_scope_leave(&state);
  _Block_object_dispose(&v20, 8);
  return v7;
}

uint64_t __SecTrustStoreCopyUsageConstraints_block_invoke(void *a1, CFTypeRef *a2)
{
  if (gTrustd && (int64_t v3 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFTypeRef *))(gTrustd + 128)) != 0)
  {
    uint64_t v4 = a1[6];
    uint64_t v5 = *(void *)(a1[4] + 8) + 24;
    uint64_t v6 = a1[5];
    return v3(v6, v4, v5, a2);
  }
  else
  {
    uint64_t v8 = *(void *)(a1[4] + 8) + 24;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 0x40000000;
    _OWORD v10[2] = __string_cert_to_array_error_block_invoke;
    unint64_t v10[3] = &__block_descriptor_tmp_72_14237;
    long long v11 = *(_OWORD *)(a1 + 5);
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    _OWORD v9[2] = __string_cert_to_array_error_block_invoke_2;
    v9[3] = &__block_descriptor_tmp_73_14238;
    void v9[4] = v8;
    return securityd_send_sync_and_do(0x65u, a2, (uint64_t)v10, (uint64_t)v9);
  }
}

BOOL __string_cert_to_array_error_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  BOOL result = SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"domain", *(const __CFString **)(a1 + 32), a3);
  if (result)
  {
    uint64_t v7 = *(void *)(a1 + 40);
    return SecXPCDictionarySetCertificate(a2, v7, a3);
  }
  return result;
}

BOOL __string_cert_to_array_error_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return SecXPCDictionaryCopyArrayOptional(a2, "status", *(void **)(a1 + 32), a3);
}

uint64_t SecTrustStoreRemoveAll(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  char v2 = _os_activity_create(&dword_18B299000, "SecTrustStoreRemoveAll", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v2, &state);
  if (!a1)
  {
    uint64_t v3 = 4294967246;
LABEL_3:
    uint64_t v4 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v10 = v3;
      _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "Failed to remove all trust settings, %d", buf, 8u);
    }
    goto LABEL_7;
  }
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  _DWORD v7[2] = __SecTrustStoreRemoveAll_block_invoke;
  void v7[3] = &__block_descriptor_tmp_11_14240;
  void v7[4] = a1;
  uint64_t v3 = SecOSStatusWith((uint64_t)v7);
  if (v3) {
    goto LABEL_3;
  }
  uint64_t v5 = secLogObjForScope("truststore");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_18B299000, v5, OS_LOG_TYPE_DEFAULT, "Removed all trust settings", buf, 2u);
    uint64_t v3 = 0;
  }
LABEL_7:
  os_release(v2);
  os_activity_scope_leave(&state);
  return v3;
}

uint64_t __SecTrustStoreRemoveAll_block_invoke(uint64_t a1, CFTypeRef *a2)
{
  if (gTrustd && (char v2 = *(uint64_t (**)(uint64_t))(gTrustd + 32)) != 0)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    return v2(v3);
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 32);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __string_to_error_block_invoke;
    unint64_t v6[3] = &__block_descriptor_tmp_74_14243;
    void v6[4] = v5;
    return securityd_send_sync_and_do(0x81u, a2, (uint64_t)v6, (uint64_t)&__block_literal_global_14244);
  }
}

BOOL __string_to_error_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  return SecXPCDictionarySetString(a2, (uint64_t)"domain", *(const __CFString **)(a1 + 32), a3);
}

uint64_t __string_to_error_block_invoke_2()
{
  return 1;
}

uint64_t SecTrustStoreSetCTExceptions(__CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v5 = a1;
  if (a1 && gTrustd)
  {
    uint64_t v6 = *(uint64_t (**)(__CFString *))(gTrustd + 152);
    if (v6) {
      goto LABEL_8;
    }
LABEL_11:
    uint64_t v8 = _os_activity_create(&dword_18B299000, "SecTrustStoreSetCTExceptions", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v8, &state);
    uint64_t v12 = 0;
    BOOL v13 = &v12;
    uint64_t v14 = 0x2000000000;
    char v15 = 0;
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 0x40000000;
    _OWORD v11[2] = __SecTrustStoreSetCTExceptions_block_invoke;
    unint64_t v11[3] = &__block_descriptor_tmp_28_14249;
    void v11[4] = a2;
    void v11[5] = v5;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 0x40000000;
    _OWORD v10[2] = __SecTrustStoreSetCTExceptions_block_invoke_2;
    unint64_t v10[3] = &unk_1E5484450;
    void v10[4] = &v12;
    securityd_send_sync_and_do(0x74u, a3, (uint64_t)v11, (uint64_t)v10);
    os_release(v8);
    uint64_t v9 = *((unsigned __int8 *)v13 + 24);
    _Block_object_dispose(&v12, 8);
    os_activity_scope_leave(&state);
    return v9;
  }
  if (!gTrustd) {
    goto LABEL_11;
  }
  uint64_t v6 = *(uint64_t (**)(__CFString *))(gTrustd + 152);
  if (!v6) {
    goto LABEL_11;
  }
  a1 = @"com.apple.trusttests";
LABEL_8:

  return v6(a1);
}

uint64_t __SecTrustStoreSetCTExceptions_block_invoke(uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef v11 = *(const __CFString **)(a1 + 32);
  if (v11) {
    SecXPCDictionarySetPListWithRepair(a2, "exceptions", v11, a3, a5, a6, a7, a8);
  }
  CFStringRef v12 = *(const __CFString **)(a1 + 40);
  if (v12) {
    SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"appID", v12, a3);
  }
  return 1;
}

uint64_t __SecTrustStoreSetCTExceptions_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = xpc_dictionary_get_BOOL(xdict, "status");
  return 1;
}

uint64_t SecTrustStoreCopyCTExceptions(uint64_t a1, CFTypeRef *a2)
{
  if (gTrustd && (uint64_t v4 = *(uint64_t (**)(void))(gTrustd + 160)) != 0)
  {
    return v4();
  }
  else
  {
    uint64_t v6 = _os_activity_create(&dword_18B299000, "SecTrustStoreCopyCTExceptions", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v6, &state);
    uint64_t v10 = 0;
    CFStringRef v11 = &v10;
    uint64_t v12 = 0x2000000000;
    uint64_t v13 = 0;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    _OWORD v9[2] = __SecTrustStoreCopyCTExceptions_block_invoke;
    v9[3] = &__block_descriptor_tmp_30_14256;
    void v9[4] = a1;
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    _DWORD v8[2] = __SecTrustStoreCopyCTExceptions_block_invoke_2;
    unint64_t v8[3] = &unk_1E5484498;
    v8[4] = &v10;
    securityd_send_sync_and_do(0x75u, a2, (uint64_t)v9, (uint64_t)v8);
    os_release(v6);
    uint64_t v7 = v11[3];
    _Block_object_dispose(&v10, 8);
    os_activity_scope_leave(&state);
    return v7;
  }
}

uint64_t __SecTrustStoreCopyCTExceptions_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  CFStringRef v4 = *(const __CFString **)(a1 + 32);
  if (v4) {
    SecXPCDictionarySetString(a2, (uint64_t)"appID", v4, a3);
  }
  return 1;
}

uint64_t __SecTrustStoreCopyCTExceptions_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return 1;
}

uint64_t SecTrustStoreSetCARevocationAdditions(__CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v5 = a1;
  if (a1 && gTrustd)
  {
    uint64_t v6 = *(uint64_t (**)(__CFString *))(gTrustd + 184);
    if (v6) {
      goto LABEL_8;
    }
LABEL_11:
    uint64_t v8 = _os_activity_create(&dword_18B299000, "SecTrustStoreSetCARevocationAdditions", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v8, &state);
    uint64_t v12 = 0;
    uint64_t v13 = &v12;
    uint64_t v14 = 0x2000000000;
    char v15 = 0;
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 0x40000000;
    _OWORD v11[2] = __SecTrustStoreSetCARevocationAdditions_block_invoke;
    unint64_t v11[3] = &__block_descriptor_tmp_36_14259;
    void v11[4] = a2;
    void v11[5] = v5;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 0x40000000;
    _OWORD v10[2] = __SecTrustStoreSetCARevocationAdditions_block_invoke_2;
    unint64_t v10[3] = &unk_1E54844F8;
    void v10[4] = &v12;
    securityd_send_sync_and_do(0x7Au, a3, (uint64_t)v11, (uint64_t)v10);
    os_release(v8);
    uint64_t v9 = *((unsigned __int8 *)v13 + 24);
    _Block_object_dispose(&v12, 8);
    os_activity_scope_leave(&state);
    return v9;
  }
  if (!gTrustd) {
    goto LABEL_11;
  }
  uint64_t v6 = *(uint64_t (**)(__CFString *))(gTrustd + 184);
  if (!v6) {
    goto LABEL_11;
  }
  a1 = @"com.apple.trusttests";
LABEL_8:

  return v6(a1);
}

uint64_t __SecTrustStoreSetCARevocationAdditions_block_invoke(uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef v11 = *(const __CFString **)(a1 + 32);
  if (v11) {
    SecXPCDictionarySetPListWithRepair(a2, "revocationCheck", v11, a3, a5, a6, a7, a8);
  }
  CFStringRef v12 = *(const __CFString **)(a1 + 40);
  if (v12) {
    SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"appID", v12, a3);
  }
  return 1;
}

uint64_t __SecTrustStoreSetCARevocationAdditions_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = xpc_dictionary_get_BOOL(xdict, "status");
  return 1;
}

uint64_t SecTrustStoreCopyCARevocationAdditions(uint64_t a1, CFTypeRef *a2)
{
  if (gTrustd && (CFStringRef v4 = *(uint64_t (**)(void))(gTrustd + 192)) != 0)
  {
    return v4();
  }
  else
  {
    uint64_t v6 = _os_activity_create(&dword_18B299000, "SecTrustStoreCopyCARevocationAdditions", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v6, &state);
    uint64_t v10 = 0;
    CFStringRef v11 = &v10;
    uint64_t v12 = 0x2000000000;
    uint64_t v13 = 0;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    _OWORD v9[2] = __SecTrustStoreCopyCARevocationAdditions_block_invoke;
    v9[3] = &__block_descriptor_tmp_38_14263;
    void v9[4] = a1;
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    _DWORD v8[2] = __SecTrustStoreCopyCARevocationAdditions_block_invoke_2;
    unint64_t v8[3] = &unk_1E5484540;
    v8[4] = &v10;
    securityd_send_sync_and_do(0x7Bu, a2, (uint64_t)v9, (uint64_t)v8);
    os_release(v6);
    uint64_t v7 = v11[3];
    _Block_object_dispose(&v10, 8);
    os_activity_scope_leave(&state);
    return v7;
  }
}

uint64_t __SecTrustStoreCopyCARevocationAdditions_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  CFStringRef v4 = *(const __CFString **)(a1 + 32);
  if (v4) {
    SecXPCDictionarySetString(a2, (uint64_t)"appID", v4, a3);
  }
  return 1;
}

uint64_t __SecTrustStoreCopyCARevocationAdditions_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return 1;
}

uint64_t SecTrustStoreSetTransparentConnectionPins(__CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v5 = a1;
  if (a1 && gTrustd)
  {
    uint64_t v6 = *(uint64_t (**)(__CFString *))(gTrustd + 208);
    if (v6) {
      goto LABEL_8;
    }
LABEL_11:
    uint64_t v8 = _os_activity_create(&dword_18B299000, "SecTrustStoreSetTransparentConnectionPins", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v8, &state);
    uint64_t v12 = 0;
    uint64_t v13 = &v12;
    uint64_t v14 = 0x2000000000;
    char v15 = 0;
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 0x40000000;
    _OWORD v11[2] = __SecTrustStoreSetTransparentConnectionPins_block_invoke;
    unint64_t v11[3] = &__block_descriptor_tmp_41_14266;
    void v11[4] = a2;
    void v11[5] = v5;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 0x40000000;
    _OWORD v10[2] = __SecTrustStoreSetTransparentConnectionPins_block_invoke_2;
    unint64_t v10[3] = &unk_1E5484588;
    void v10[4] = &v12;
    securityd_send_sync_and_do(0x7Du, a3, (uint64_t)v11, (uint64_t)v10);
    os_release(v8);
    uint64_t v9 = *((unsigned __int8 *)v13 + 24);
    _Block_object_dispose(&v12, 8);
    os_activity_scope_leave(&state);
    return v9;
  }
  if (!gTrustd) {
    goto LABEL_11;
  }
  uint64_t v6 = *(uint64_t (**)(__CFString *))(gTrustd + 208);
  if (!v6) {
    goto LABEL_11;
  }
  a1 = @"com.apple.trusttests";
LABEL_8:

  return v6(a1);
}

uint64_t __SecTrustStoreSetTransparentConnectionPins_block_invoke(uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef v11 = *(const __CFString **)(a1 + 32);
  if (v11) {
    SecXPCDictionarySetPListWithRepair(a2, "anchors", v11, a3, a5, a6, a7, a8);
  }
  CFStringRef v12 = *(const __CFString **)(a1 + 40);
  if (v12) {
    SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"appID", v12, a3);
  }
  return 1;
}

uint64_t __SecTrustStoreSetTransparentConnectionPins_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = xpc_dictionary_get_BOOL(xdict, "status");
  return 1;
}

uint64_t SecTrustStoreCopyTransparentConnectionPins(uint64_t a1, CFTypeRef *a2)
{
  if (gTrustd && (CFStringRef v4 = *(uint64_t (**)(void))(gTrustd + 216)) != 0)
  {
    return v4();
  }
  else
  {
    uint64_t v6 = _os_activity_create(&dword_18B299000, "SecTrustStoreCopyTransparentConnectionPins", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v6, &state);
    uint64_t v10 = 0;
    CFStringRef v11 = &v10;
    uint64_t v12 = 0x2000000000;
    uint64_t v13 = 0;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    _OWORD v9[2] = __SecTrustStoreCopyTransparentConnectionPins_block_invoke;
    v9[3] = &__block_descriptor_tmp_43_14270;
    void v9[4] = a1;
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    _DWORD v8[2] = __SecTrustStoreCopyTransparentConnectionPins_block_invoke_2;
    unint64_t v8[3] = &unk_1E54845D0;
    v8[4] = &v10;
    securityd_send_sync_and_do(0x7Eu, a2, (uint64_t)v9, (uint64_t)v8);
    os_release(v6);
    uint64_t v7 = v11[3];
    _Block_object_dispose(&v10, 8);
    os_activity_scope_leave(&state);
    return v7;
  }
}

uint64_t __SecTrustStoreCopyTransparentConnectionPins_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  CFStringRef v4 = *(const __CFString **)(a1 + 32);
  if (v4) {
    SecXPCDictionarySetString(a2, (uint64_t)"appID", v4, a3);
  }
  return 1;
}

uint64_t __SecTrustStoreCopyTransparentConnectionPins_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return 1;
}

CFDataRef SecXPCDictionaryCopyData(void *a1, const char *a2, __CFString **a3)
{
  size_t length = 0;
  uint64_t data = (const UInt8 *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    if ((length & 0x8000000000000000) != 0)
    {
      SecError(-50, a3, @"too large data for key %s", a2);
    }
    else
    {
      CFDataRef result = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], data, length);
      if (result) {
        return result;
      }
      SecError(-50, a3, @"failed to create data for key %s", a2);
    }
  }
  else
  {
    SecError(-50, a3, @"no data for key %s", a2);
  }
  return 0;
}

CFStringRef SecXPCDictionaryCopyString(void *a1, __CFString **a2)
{
  string = xpc_dictionary_get_string(a1, "status");
  if (string)
  {
    CFStringRef v4 = string;
    CFStringRef result = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], string, 0x8000100u);
    if (result) {
      return result;
    }
    SecError(-108, a2, @"object for key %s failed to convert %s to CFString", "status", v4);
  }
  else
  {
    SecError(-50, a2, @"object for key %s not string", "status");
  }
  return 0;
}

uint64_t safeContentsParse(uint64_t **a1, unint64_t a2, char *a3)
{
  uint64_t v22 = 0;
  if (*a1) {
    BOOL v3 = a3 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3 || SEC_ASN1Decode(**a1, (uint64_t)&v22, (uint64_t)&NSS_P12_SafeContentsTemplate, a3, a2)) {
    return 0xFFFFFFFFLL;
  }
  if (!v22) {
    return 0;
  }
  if (!*v22) {
    return 0;
  }
  uint64_t v5 = 0;
  while (v22[++v5])
    ;
  if (!v5) {
    return 0;
  }
  unint64_t v7 = 0;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  uint64_t v10 = 8 * v5;
  while (2)
  {
    uint64_t v11 = v22[v7 / 8];
    uint64_t v12 = *(void *)(v11 + 24);
    if (!v12) {
      return 0xFFFFFFFFLL;
    }
    switch(*(_DWORD *)(v11 + 16))
    {
      case 1:
      case 4:
      case 5:
      case 6:
        goto LABEL_14;
      case 2:
        long long v29 = 0uLL;
        p12Decrypt((uint64_t)a1, (void *)v12, v12 + 32, &v29);
        if (v13) {
          return 0xFFFFFFFFLL;
        }
        uint64_t v28 = 0;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        if (!*a1) {
          return 0xFFFFFFFFLL;
        }
        if (!*((void *)&v29 + 1)) {
          return 0xFFFFFFFFLL;
        }
        if (SEC_ASN1Decode(**a1, (uint64_t)&v24, (uint64_t)&kSecAsn1PrivateKeyInfoTemplate, *((char **)&v29 + 1), v29))return 0xFFFFFFFFLL; {
        v23[0] = *((void *)&v25 + 1);
        }
        v23[1] = v25;
        BOOL v14 = DEROidCompare((uint64_t)&oidEcPubKey, (uint64_t)v23);
        char v15 = &oidEcPubKey;
        if (!v14)
        {
          BOOL v16 = DEROidCompare((uint64_t)&oidRsa, (uint64_t)v23);
          char v15 = &oidRsa;
          if (!v16) {
            return 0xFFFFFFFFLL;
          }
        }
        CFDataRef v17 = CFDataCreateWithBytesNoCopy(v8, v15->data, v15->length, v9);
        if (emit_item((uint64_t)a1, *(void **)(v11 + 32), @"algid", v17))
        {
          if (!v17) {
            return 0xFFFFFFFFLL;
          }
          int v18 = -1;
LABEL_29:
          CFRelease(v17);
          goto LABEL_30;
        }
        if (v17) {
          CFRelease(v17);
        }
        CFDataRef v17 = CFDataCreate(v8, *((const UInt8 **)&v27 + 1), v27);
        if (emit_item((uint64_t)a1, *(void **)(v11 + 32), @"key", v17)) {
          int v18 = -1;
        }
        else {
          int v18 = 0;
        }
        if (v17) {
          goto LABEL_29;
        }
LABEL_30:
        if (v18) {
          return 0xFFFFFFFFLL;
        }
        goto LABEL_14;
      case 3:
        int v19 = *(_DWORD *)(v12 + 16);
        if (v19 == 2) {
          goto LABEL_14;
        }
        if (v19 != 1) {
          return 0xFFFFFFFFLL;
        }
        CFDataRef v20 = CFDataCreate(v8, *(const UInt8 **)(v12 + 32), *(void *)(v12 + 24));
        if (!emit_item((uint64_t)a1, *(void **)(v11 + 32), @"cert", v20))
        {
          CFRelease(v20);
LABEL_14:
          v7 += 8;
          if (v10 == v7) {
            return 0;
          }
          continue;
        }
        if (v20) {
          CFRelease(v20);
        }
        return 0xFFFFFFFFLL;
      default:
        return 0xFFFFFFFFLL;
    }
  }
}

double p12Decrypt(uint64_t a1, void *a2, uint64_t a3, _OWORD *a4)
{
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  unint64_t v8 = a2[2];
  if (v8)
  {
    long long v62 = 0uLL;
    long long v63 = 0uLL;
    long long v60 = 0uLL;
    long long v61 = 0uLL;
    long long v58 = 0uLL;
    long long v59 = 0uLL;
    long long v56 = 0uLL;
    long long v57 = 0uLL;
    long long v54 = 0uLL;
    long long v55 = 0uLL;
    CFAllocatorRef v9 = *(uint64_t **)a1;
    uint64_t v10 = (char *)a2[3];
    if (*(void *)a1 && v10)
    {
      if (!SEC_ASN1Decode(*v9, (uint64_t)&v54, (uint64_t)&NSS_P12_PBE_ParamsTemplate, v10, v8)) {
        goto LABEL_10;
      }
      CFAllocatorRef v9 = *(uint64_t **)a1;
      uint64_t v10 = (char *)a2[3];
    }
    long long v62 = 0u;
    long long v63 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    if (v9
      && v10
      && !SEC_ASN1Decode(*v9, (uint64_t)&v54, (uint64_t)&NSS_P12_PBE2_ParamsTemplate, v10, a2[2]))
    {
      long long v54 = v57;
      long long v55 = v58;
    }
  }
LABEL_10:
  uint64_t v11 = *a2 - 1;
  uint64_t v64 = a2[1];
  uint64_t v65 = v11;
  if (DEROidCompare((uint64_t)&OID_PKCS12_pbep, (uint64_t)&v64))
  {
    uint64_t v13 = *(unsigned __int8 *)(*a2 + a2[1] - 1);
    if (v13 > 7 || v13 == 4) {
      return result;
    }
    char v15 = (char *)&pkcsOidInfos + 16 * v13;
    CCAlgorithm v16 = *((_DWORD *)v15 - 4);
    unsigned int v17 = *((_DWORD *)v15 - 3);
    unsigned int v19 = *((_DWORD *)v15 - 2);
    CCOptions v18 = *((_DWORD *)v15 - 1);
    unsigned int v20 = 20;
  }
  else
  {
    if (!DEROidCompare((uint64_t)&OID_PKCS5_pbep2, (uint64_t)&v64)) {
      return result;
    }
    CCAlgorithm v16 = 0;
    unsigned int v20 = 32;
    CCOptions v18 = 1;
    unsigned int v19 = 16;
    unsigned int v17 = 256;
  }
  uint64_t v21 = v55;
  if ((void)v55 && (uint64_t v22 = (unsigned __int8 *)*((void *)&v55 + 1)) != 0)
  {
    if ((unint64_t)v55 > 4) {
      return result;
    }
    unsigned int v23 = 0;
    do
    {
      int v24 = *v22++;
      unsigned int v23 = v24 | (v23 << 8);
      --v21;
    }
    while (v21);
  }
  else
  {
    unsigned int v23 = 0;
  }
  CFTypeID v34 = a4;
  if (v17 && *(void *)a1)
  {
    unint64_t v25 = (v17 + 7) >> 3;
    long long v26 = (void *)PORT_ArenaAlloc(**(void **)a1, v25);
    if (!v26) {
      unint64_t v25 = 0;
    }
    if (!v16)
    {
LABEL_30:
      uint64_t v50 = 0;
      SecTrustRef v51 = &v50;
      uint64_t v52 = 0x2000000000;
      int v53 = 0;
      CFStringRef v27 = *(const __CFString **)(a1 + 8);
      v36[0] = MEMORY[0x1E4F143A8];
      v36[1] = 0x40000000;
      long long v43 = v60;
      long long v44 = v61;
      long long v45 = v62;
      long long v46 = v63;
      long long v39 = v56;
      long long v40 = v57;
      long long v41 = v58;
      long long v42 = v59;
      long long v37 = v54;
      unint64_t v25 = v17 >> 3;
      v36[2] = __p12Decrypt_block_invoke;
      v36[3] = &unk_1E54848D8;
      v36[4] = &v50;
      long long v38 = v55;
      unsigned int v49 = v23;
      unint64_t v47 = v25;
      int v48 = v26;
      uint64_t v64 = MEMORY[0x1E4F143A8];
      uint64_t v65 = 0x40000000;
      CFNumberRef v66 = __CFStringPerformWithCString_block_invoke;
      CFNumberRef v67 = &unk_1E5484C20;
      CFNumberRef v68 = v36;
      CFStringPerformWithCStringAndLength(v27, (uint64_t)&v64);
      int v28 = *((_DWORD *)v51 + 6);
      _Block_object_dispose(&v50, 8);
      if (v28) {
        return result;
      }
      goto LABEL_34;
    }
  }
  else
  {
    unint64_t v25 = 0;
    long long v26 = 0;
    if (!v16) {
      goto LABEL_30;
    }
  }
  if (p12_pbe_gen(*(const __CFString **)(a1 + 8), *((const void **)&v54 + 1), v54, v23, 1, v26, v25, 0x40u, v20))return result; {
LABEL_34:
  }
  long long v29 = (void *)*((void *)&v63 + 1);
  if (*((void *)&v63 + 1) && (void)v63)
  {
LABEL_44:
    long long v35 = 0uLL;
    int v31 = *(uint64_t **)a1;
    if (*(void *)a1)
    {
      size_t dataOutAvailable = *(void *)a3;
      dataOut = (void *)PORT_ArenaAlloc(*v31, *(void *)a3);
      *((void *)&v35 + 1) = dataOut;
      if (dataOut) {
        *(void *)&long long v35 = dataOutAvailable;
      }
      else {
        size_t dataOutAvailable = 0;
      }
    }
    else
    {
      size_t dataOutAvailable = 0;
      dataOut = 0;
    }
    if (!CCCrypt(1u, v16, v18, v26, v25, v29, *(const void **)(a3 + 8), *(void *)a3, dataOut, dataOutAvailable, (size_t *)&v35))
    {
      double result = *(double *)&v35;
      *CFTypeID v34 = v35;
    }
    return result;
  }
  if (!v19)
  {
    long long v29 = 0;
    goto LABEL_44;
  }
  if (*(void *)a1)
  {
    long long v29 = (void *)PORT_ArenaAlloc(**(void **)a1, v19);
    if (v29) {
      size_t v30 = v19;
    }
    else {
      size_t v30 = 0;
    }
  }
  else
  {
    size_t v30 = 0;
    long long v29 = 0;
  }
  if (!p12_pbe_gen(*(const __CFString **)(a1 + 8), *((const void **)&v54 + 1), v54, v23, 2, v29, v30, 0x40u, v20))goto LABEL_44; {
  return result;
  }
}

uint64_t __p12Decrypt_block_invoke(uint64_t a1, char *__s)
{
  size_t v4 = strlen(__s);
  uint64_t result = CCKeyDerivationPBKDF(2u, __s, v4, *(const uint8_t **)(a1 + 48), *(void *)(a1 + 40), 3u, *(_DWORD *)(a1 + 216), *(uint8_t **)(a1 + 208), *(void *)(a1 + 200));
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t emit_item(uint64_t a1, void *a2, void *a3, const void *a4)
{
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable) {
    return 0xFFFFFFFFLL;
  }
  CFDictionaryRef v10 = Mutable;
  SecKeyRef key = a3;
  if (a2)
  {
    if (*a2)
    {
      uint64_t v11 = 0;
      while (a2[++v11])
        ;
      if (v11)
      {
        uint64_t v13 = 0;
        uint64_t v14 = v11;
        do
        {
          char v15 = (unint64_t *)a2[v13];
          CCAlgorithm v16 = (void *)v15[2];
          if (v16 && *v16)
          {
            uint64_t v17 = 0;
            CCOptions v18 = v16 + 1;
            while (v18[v17++])
              ;
          }
          else
          {
            LODWORD(v17) = 0;
          }
          unint64_t v39 = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v39 = v15[1];
          unint64_t v40 = *v15;
          if (DEROidCompare((uint64_t)&v39, (uint64_t)&oidFriendlyName))
          {
            if (v17 != 1) {
              goto LABEL_41;
            }
            CFIndex v37 = 0xAAAAAAAAAAAAAAAALL;
            long long v38 = (const UInt8 *)0xAAAAAAAAAAAAAAAALL;
            if (!*(void *)a1) {
              goto LABEL_41;
            }
            unsigned int v20 = *(unint64_t **)v15[2];
            uint64_t v21 = (char *)v20[1];
            if (!v21
              || SEC_ASN1Decode(**(void **)a1, (uint64_t)&v37, (uint64_t)kSecAsn1BMPStringTemplate, v21, *v20))
            {
              goto LABEL_41;
            }
            CFStringRef v22 = CFStringCreateWithBytes(v8, v38, v37, 0x100u, 1u);
            if (v22)
            {
              unsigned int v23 = v22;
              int v24 = v10;
              unint64_t v25 = @"label";
LABEL_28:
              CFDictionarySetValue(v24, v25, v23);
              CFRelease(v23);
            }
          }
          else if (DEROidCompare((uint64_t)&v39, (uint64_t)&oidLocalKeyId))
          {
            if (v17 != 1
              || (CFIndex v37 = 0xAAAAAAAAAAAAAAAALL, v38 = (const UInt8 *)0xAAAAAAAAAAAAAAAALL, !*(void *)a1)
              || (long long v26 = *(unint64_t **)v15[2], (v27 = (char *)v26[1]) == 0)
              || SEC_ASN1Decode(**(void **)a1, (uint64_t)&v37, (uint64_t)kSecAsn1OctetStringTemplate, v27, *v26))
            {
LABEL_41:
              uint64_t v34 = 0xFFFFFFFFLL;
              goto LABEL_39;
            }
            CFDataRef v28 = CFDataCreate(v8, v38, v37);
            if (v28)
            {
              unsigned int v23 = v28;
              int v24 = v10;
              unint64_t v25 = @"keyid";
              goto LABEL_28;
            }
          }
          ++v13;
        }
        while (v13 != v14);
      }
    }
  }
  CFNumberRef Value = CFDictionaryGetValue(v10, @"keyid");
  if (!Value) {
    CFNumberRef Value = CFDictionaryGetValue(v10, @"label");
  }
  if (Value) {
    size_t v30 = Value;
  }
  else {
    size_t v30 = a4;
  }
  int v31 = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v30);
  uint64_t v32 = key;
  if (v31)
  {
    CFDictionaryRef v33 = (const __CFDictionary *)a4;
  }
  else
  {
    CFDictionarySetValue(v10, key, a4);
    int v31 = *(__CFDictionary **)(a1 + 16);
    uint64_t v32 = v30;
    CFDictionaryRef v33 = v10;
  }
  CFDictionarySetValue(v31, v32, v33);
  uint64_t v34 = 0;
LABEL_39:
  CFRelease(v10);
  return v34;
}

void sub_18B3CEE78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t __Block_byref_object_copy__15168(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__15169(uint64_t a1)
{
}

void _getAppAttestInternalSymbol(void *a1, char *__symbol)
{
  if (_initAppAttestInternal_onceToken == -1)
  {
    if (!a1) {
      return;
    }
  }
  else
  {
    dispatch_once(&_initAppAttestInternal_onceToken, &__block_literal_global_584);
    if (!a1) {
      return;
    }
  }
  if (!*a1)
  {
    size_t v4 = dlsym((void *)appAttestInternal, __symbol);
    *a1 = v4;
    if (!v4)
    {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "symbol %s is missing", __symbol);
      abort();
    }
  }
}

void *___initAppAttestInternal_block_invoke()
{
  uint64_t result = dlopen("/System/Library/PrivateFrameworks/AppAttestInternal.framework/AppAttestInternal", 5);
  appAttestInternal = (uint64_t)result;
  return result;
}

void sub_18B3CF260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18B3CF438(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18B3CF6A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18B3D03D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void SecRequestClientIdentity(const void *a1, const void *a2, void *a3, void *a4)
{
  v28[1] = *MEMORY[0x1E4F143B8];
  unint64_t v7 = a3;
  id v8 = a4;
  CFAllocatorRef v9 = (void (**)(void, void, void))v8;
  CFDictionaryRef v10 = "subject";
  if (a1) {
    CFDictionaryRef v10 = 0;
  }
  if (!a2) {
    CFDictionaryRef v10 = "parameters";
  }
  if (!v7) {
    CFDictionaryRef v10 = "queue";
  }
  if (!v8) {
    CFDictionaryRef v10 = "result block";
  }
  if (v10)
  {
    uint64_t v11 = objc_msgSend(NSString, "stringWithFormat:", @"SecRequestClientIdentity was called with NULL %s", v10);
    uint64_t v12 = (void *)v11;
    if (v9)
    {
      uint64_t v13 = (void *)MEMORY[0x1E4F28C58];
      uint64_t v14 = *MEMORY[0x1E4F28760];
      uint64_t v27 = *MEMORY[0x1E4F28568];
      v28[0] = v11;
      char v15 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v28 forKeys:&v27 count:1];
      CCAlgorithm v16 = [v13 errorWithDomain:v14 code:-50 userInfo:v15];

      ((void (**)(void, void, NSObject *))v9)[2](v9, 0, v16);
    }
    else
    {
      CCAlgorithm v16 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v12;
        _os_log_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&buf, 0xCu);
      }
    }
  }
  else
  {
    if (a1) {
      CFRetain(a1);
    }
    if (a2) {
      CFRetain(a2);
    }
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &buf;
    uint64_t v23 = 0x3032000000;
    int v24 = __Block_byref_object_copy__15168;
    unint64_t v25 = __Block_byref_object_dispose__15169;
    id v26 = (id)0xAAAAAAAAAAAAAAAALL;
    id v26 = (id)os_transaction_create();
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __SecRequestClientIdentity_block_invoke;
    block[3] = &unk_1E5484B48;
    unsigned int v20 = a1;
    uint64_t v21 = a2;
    CCOptions v18 = v9;
    p_long long buf = &buf;
    dispatch_async(v7, block);

    _Block_object_dispose(&buf, 8);
  }
}

void __SecRequestClientIdentity_block_invoke(void *a1)
{
  char v2 = (void *)MEMORY[0x18C12E850]();
  BOOL v3 = [[AcmeCertRequest alloc] initWithSubject:a1[6] parameters:a1[7]];
  uint64_t v4 = [(AcmeCertRequest *)v3 sanitizeParameters];
  if (v4)
  {
    id v5 = (id)v4;
  }
  else
  {
    id v10 = 0;
    [(AcmeCertRequest *)v3 identityWithError:&v10];
    id v5 = v10;
  }
  (*(void (**)(void))(a1[4] + 16))();
  uint64_t v6 = (const void *)a1[7];
  if (v6) {
    CFRelease(v6);
  }
  unint64_t v7 = (const void *)a1[6];
  if (v7) {
    CFRelease(v7);
  }

  uint64_t v8 = *(void *)(a1[5] + 8);
  CFAllocatorRef v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = 0;
}

uint64_t SecAreQARootCertificatesEnabled()
{
  if (SecAreQARootCertificatesEnabled_onceToken != -1) {
    dispatch_once(&SecAreQARootCertificatesEnabled_onceToken, &__block_literal_global_15275);
  }
  return SecAreQARootCertificatesEnabled_sQACertsEnabled;
}

void __SecAreQARootCertificatesEnabled_block_invoke()
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  int v4 = 0;
  size_t v3 = 4;
  int v0 = sysctlbyname("security.mac.amfi.qa_root_certs_allowed", &v4, &v3, 0, 0);
  if (v0)
  {
    int v1 = v0;
    char v2 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v6 = v1;
      _os_log_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEFAULT, "Unable to check QA certificate status: %d", buf, 8u);
    }
  }
  else
  {
    SecAreQARootCertificatesEnabled_sQACertsEnabled = v4 == 1;
  }
}

uint64_t p12_pbe_gen(const __CFString *a1, const void *a2, size_t a3, unsigned int a4, uint64_t a5, void *a6, size_t a7, CC_LONG a8, unsigned int a9)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  size_t v16 = a8;
  MEMORY[0x1F4188790](a1);
  memset((char *)&v56 - ((v16 + 15) & 0x1FFFFFFF0), v17, v16);
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x10000100u, 0);
  if (!ExternalRepresentation) {
    return 0xFFFFFFFFLL;
  }
  CFDataRef v19 = ExternalRepresentation;
  CFNumberRef v67 = (char *)&v56 - ((v16 + 15) & 0x1FFFFFFF0);
  __int16 bytes = 0;
  CFMutableArrayRef MutableCopy = CFDataCreateMutableCopy(0, 0, ExternalRepresentation);
  CFRelease(v19);
  if (!MutableCopy) {
    return 0xFFFFFFFFLL;
  }
  CFDataAppendBytes(MutableCopy, (const UInt8 *)&bytes, 2);
  int64_t v70 = 0;
  CFIndex Length = CFDataGetLength(MutableCopy);
  BytePtr = CFDataGetBytePtr(MutableCopy);
  uint64_t v23 = concatenate_to_blocksize(BytePtr, Length, v16, &v70);
  CFRelease(MutableCopy);
  if (!v23) {
    return 0xFFFFFFFFLL;
  }
  size_t v69 = 0;
  if (!a3) {
    goto LABEL_36;
  }
  int v24 = concatenate_to_blocksize(a2, a3, v16, (int64_t *)&v69);
  if (!v24) {
    goto LABEL_36;
  }
  unint64_t v25 = v24;
  unsigned int v66 = a4;
  size_t v26 = v69;
  int64_t v27 = v70;
  unint64_t v28 = v70 + v69;
  long long v29 = (char *)malloc_type_malloc(v70 + v69, 0x20A1AE30uLL);
  if (!v29)
  {
    free(v25);
LABEL_36:
    long long v54 = v23;
LABEL_37:
    free(v54);
    return 0xFFFFFFFFLL;
  }
  size_t v65 = a9;
  size_t v64 = v27;
  size_t v30 = v29;
  memcpy(v29, v25, v26);
  CFNumberRef v68 = v30;
  int v31 = &v30[v26];
  size_t v32 = v65;
  memcpy(v31, v23, v64);
  free(v25);
  free(v23);
  int64_t v33 = (a7 + v32 - 1) / v32 * v32;
  long long v60 = (char *)malloc_type_malloc(v33, 0x1402BCAuLL);
  if (!v60)
  {
    long long v54 = v68;
    goto LABEL_37;
  }
  long long v57 = a6;
  size_t v58 = a7;
  long long v59 = &v56;
  if (v33 < 1)
  {
LABEL_33:
    uint64_t v52 = v60;
    memmove(v57, v60, v58);
    free(v52);
    free(v68);
    return 0;
  }
  else
  {
    uint64_t v34 = (unsigned __int8 *)v60;
    long long v63 = (unsigned __int8 *)&v60[v33];
    size_t v64 = (v16 + 7) >> 3;
    unsigned int v61 = v66 - 1;
    HIDWORD(v36) = v32;
    LODWORD(v36) = v32 - 20;
    unsigned int v35 = v36 >> 2;
    uint64_t v62 = v35;
    while (1)
    {
      CFIndex v37 = v67;
      switch(v35)
      {
        case 0u:
          *(void *)&long long v38 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v38 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.hash[6] = v38;
          *(_OWORD *)c.wlong long buf = v38;
          *(_OWORD *)&c.hash[4] = v38;
          *(_OWORD *)&c.hash[2] = v38;
          *(_OWORD *)c.hash = v38;
          *(_OWORD *)c.count = v38;
          CC_SHA1_Init((CC_SHA1_CTX *)&c);
          CC_SHA1_Update((CC_SHA1_CTX *)&c, v37, a8);
          CC_SHA1_Update((CC_SHA1_CTX *)&c, v68, v28);
          CC_SHA1_Final(v34, (CC_SHA1_CTX *)&c);
          break;
        case 2u:
          c.wuint8_t buf[2] = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v39 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.hash[6] = v39;
          *(_OWORD *)c.wlong long buf = v39;
          *(_OWORD *)&c.hash[4] = v39;
          *(_OWORD *)&c.hash[2] = v39;
          *(_OWORD *)c.hash = v39;
          *(_OWORD *)c.count = v39;
          CC_SHA224_Init((CC_SHA256_CTX *)&c);
          CC_SHA224_Update((CC_SHA256_CTX *)&c, v37, a8);
          CC_SHA224_Update((CC_SHA256_CTX *)&c, v68, v28);
          CC_SHA224_Final(v34, (CC_SHA256_CTX *)&c);
          break;
        case 3u:
          c.wuint8_t buf[2] = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v40 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v40 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.hash[6] = v40;
          *(_OWORD *)c.wlong long buf = v40;
          *(_OWORD *)&c.hash[4] = v40;
          *(_OWORD *)&c.hash[2] = v40;
          *(_OWORD *)c.hash = v40;
          *(_OWORD *)c.count = v40;
          CC_SHA256_Init((CC_SHA256_CTX *)&c);
          CC_SHA256_Update((CC_SHA256_CTX *)&c, v37, a8);
          CC_SHA256_Update((CC_SHA256_CTX *)&c, v68, v28);
          CC_SHA256_Final(v34, (CC_SHA256_CTX *)&c);
          break;
        case 7u:
          *(void *)&long long v41 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.wunsigned char buf[12] = v41;
          *(_OWORD *)&c.wbuf[14] = v41;
          *(_OWORD *)&c.wuint8_t buf[8] = v41;
          *(_OWORD *)&c.wbuf[10] = v41;
          *(_OWORD *)&c.wuint8_t buf[4] = v41;
          *(_OWORD *)&c.wbuf[6] = v41;
          *(_OWORD *)c.wlong long buf = v41;
          *(_OWORD *)&c.wuint8_t buf[2] = v41;
          *(_OWORD *)&c.hash[6] = v41;
          *(_OWORD *)&c.hash[4] = v41;
          *(_OWORD *)&c.hash[2] = v41;
          *(_OWORD *)c.hash = v41;
          *(_OWORD *)c.count = v41;
          CC_SHA384_Init(&c);
          CC_SHA384_Update(&c, v37, a8);
          CC_SHA384_Update(&c, v68, v28);
          CC_SHA384_Final(v34, &c);
          break;
        case 0xBu:
          *(void *)&long long v42 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v42 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.wunsigned char buf[12] = v42;
          *(_OWORD *)&c.wbuf[14] = v42;
          *(_OWORD *)&c.wuint8_t buf[8] = v42;
          *(_OWORD *)&c.wbuf[10] = v42;
          *(_OWORD *)&c.wuint8_t buf[4] = v42;
          *(_OWORD *)&c.wbuf[6] = v42;
          *(_OWORD *)c.wlong long buf = v42;
          *(_OWORD *)&c.wuint8_t buf[2] = v42;
          *(_OWORD *)&c.hash[6] = v42;
          *(_OWORD *)&c.hash[4] = v42;
          *(_OWORD *)&c.hash[2] = v42;
          *(_OWORD *)c.hash = v42;
          *(_OWORD *)c.count = v42;
          CC_SHA512_Init(&c);
          CC_SHA512_Update(&c, v37, a8);
          CC_SHA512_Update(&c, v68, v28);
          CC_SHA512_Final(v34, &c);
          break;
        default:
          break;
      }
      if (v66 >= 2)
      {
        unsigned int v43 = v61;
        do
        {
          CCDigest();
          --v43;
        }
        while (v43);
      }
      c.count[0] = 0;
      long long v44 = concatenate_to_blocksize(v34, v32, v16, (int64_t *)&c);
      if (!v44) {
        goto LABEL_41;
      }
      long long v45 = v44;
      if ((c.count[0] + 8) >> 3 <= v64) {
        CC_LONG64 v46 = v64;
      }
      else {
        CC_LONG64 v46 = (c.count[0] + 8) >> 3;
      }
      unint64_t v47 = malloc_type_malloc(8 * v46, 0x100004000313F17uLL);
      if (!v47)
      {
        free(v45);
LABEL_41:
        free(v68);
        long long v55 = v60;
        goto LABEL_43;
      }
      int v48 = v47;
      ccn_read_uint();
      ccn_add1();
      free(v45);
      unsigned int v49 = malloc_type_malloc(8 * v46, 0x100004000313F17uLL);
      if (!v49) {
        break;
      }
      uint64_t v50 = v49;
      if (v28)
      {
        for (unsigned int i = 0; i < v28; i += a8)
        {
          ccn_read_uint();
          ccn_add();
          while (ccn_bitlen() > (unint64_t)(8 * a8))
            ccn_set_bit();
          ccn_write_uint_padded();
        }
      }
      size_t v32 = v65;
      v34 += v65;
      free(v48);
      free(v50);
      unsigned int v35 = v62;
      if (v34 >= v63) {
        goto LABEL_33;
      }
    }
    free(v68);
    free(v60);
    long long v55 = v48;
LABEL_43:
    free(v55);
    return 0xFFFFFFFFLL;
  }
}

char *concatenate_to_blocksize(const void *a1, size_t a2, unint64_t a3, int64_t *a4)
{
  int64_t v7 = (a2 + a3 - 1) / a3 * a3;
  uint64_t v8 = (char *)malloc_type_malloc(v7, 0x2D286B2EuLL);
  CFAllocatorRef v9 = v8;
  if (v8)
  {
    if (v7 >= 1)
    {
      id v10 = &v8[v7];
      uint64_t v11 = v8;
      do
      {
        if (v10 - v11 >= a2) {
          size_t v12 = a2;
        }
        else {
          size_t v12 = v10 - v11;
        }
        memcpy(v11, a1, v12);
        v11 += a2;
      }
      while (v11 < v10);
    }
    *a4 = v7;
  }
  return v9;
}

void (*pbkdf2(void (*result)(uint64_t, uint64_t, char *, size_t, char *), size_t a2, uint64_t a3, uint64_t a4, void *__src, size_t __n, unint64_t a7, char *a8, unint64_t a9, char *a10))(uint64_t, uint64_t, char *, size_t, char *)
{
  unint64_t v16 = a9 / a2;
  unint64_t v20 = a9 / a2 * a2;
  if ((a9 / a2))
  {
    uint64_t v21 = &a10[a2];
    unsigned int v17 = 1;
    do
    {
      CCOptions v18 = result;
      unint64_t v19 = a7;
      F(result, a2, a3, a4, __src, __n, a7, v17, a8, v21);
      uint64_t result = v18;
      a7 = v19;
      a8 += a2;
      ++v17;
    }
    while (v17 <= v16);
  }
  else
  {
    unsigned int v17 = 1;
  }
  if (a9 != v20)
  {
    F(result, a2, a3, a4, __src, __n, a7, v17, a10, &a10[a2]);
    return (void (*)(uint64_t, uint64_t, char *, size_t, char *))memcpy(a8, a10, a9 - v20);
  }
  return result;
}

void *F(void (*a1)(uint64_t, uint64_t, char *, size_t, char *), size_t a2, uint64_t a3, uint64_t a4, void *__src, size_t __n, unint64_t a7, unsigned int a8, void *a9, char *a10)
{
  unsigned int v17 = a10;
  CCOptions v18 = &a10[a2];
  memcpy(&a10[a2], __src, __n);
  *(_DWORD *)&v18[__n] = bswap32(a8);
  a1(a3, a4, v18, __n + 4, a10);
  uint64_t result = memcpy(a9, a10, a2);
  if (a7 >= 2)
  {
    unint64_t v20 = 2;
    do
    {
      uint64_t v21 = v18;
      uint64_t result = (void *)((uint64_t (*)(uint64_t, uint64_t, char *, size_t, char *))a1)(a3, a4, v17, a2, v18);
      if (a2)
      {
        uint64_t v22 = 0;
        do
        {
          *((unsigned char *)a9 + v22) ^= v18[v22];
          ++v22;
        }
        while (a2 > v22);
      }
      ++v20;
      CCOptions v18 = v17;
      unsigned int v17 = v21;
    }
    while (v20 <= a7);
  }
  return result;
}

__CFString *SecLogAPICreate(uint64_t a1, const char *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppend(Mutable, @"SecAPITrace ");
  CFStringAppendCString(Mutable, a2, 0x600u);
  CFStringAppendCString(Mutable, "ENTER", 0x600u);
  if (a3)
  {
    CFStringRef v13 = CFStringCreateWithFormatAndArguments(v11, 0, a3, &a9);
    CFStringAppend(Mutable, v13);
    if (v13) {
      CFRelease(v13);
    }
  }
  *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v19 = v14;
  long long v20 = v14;
  long long v17 = v14;
  long long v18 = v14;
  *(_OWORD *)__str = v14;
  snprintf(__str, 0x50uLL, "C%p F%p", vars0[1], *vars0);
  CFStringAppend(Mutable, @"CALLER ");
  CFStringAppendCString(Mutable, __str, 0x600u);
  return Mutable;
}

uint64_t SecGetDebugDescriptionFormatOptions()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __SecGetDebugDescriptionFormatOptions_block_invoke;
  block[3] = &__block_descriptor_tmp_15414;
  void block[4] = &SecGetDebugDescriptionFormatOptions_sSecGetDebugDescriptionFormatOptionsSingleton;
  if (SecGetDebugDescriptionFormatOptions_sSecGetDebugDescriptionFormatOptionsOnce != -1) {
    dispatch_once(&SecGetDebugDescriptionFormatOptions_sSecGetDebugDescriptionFormatOptionsOnce, block);
  }
  return SecGetDebugDescriptionFormatOptions_sSecGetDebugDescriptionFormatOptionsSingleton;
}

CFDictionaryRef __SecGetDebugDescriptionFormatOptions_block_invoke(uint64_t a1)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  values = (void *)*MEMORY[0x1E4F1CFD0];
  keys[0] = @"debug";
  CFDictionaryRef result = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  **(void **)(a1 + 32) = result;
  return result;
}

void __CFStringArrayPerformWithDelimiterWithDescription_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = @", ";
}

uint64_t apply_block_1_15422(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void CFStringSetPerformWithDescription(const __CFSet *a1, uint64_t a2)
{
  if (a1
    && (CFIndex Count = CFSetGetCount(a1),
        CFArrayRef Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E4F1D510]),
        CFSetApplyFunction(a1, (CFSetApplierFunction)appendDescriptionToArray, Mutable),
        v15.size_t length = CFArrayGetCount(Mutable),
        v15.CFIndex location = 0,
        CFArraySortValues(Mutable, v15, MEMORY[0x1E4F1C2A8], 0),
        Mutable))
  {
    uint64_t v10 = 0;
    CFAllocatorRef v11 = &v10;
    uint64_t v12 = 0x2000000000;
    CFMutableStringRef MutableCopy = (CFMutableStringRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"{(");
    v9[0] = 0;
    v9[1] = v9;
    _OWORD v9[2] = 0x2000000000;
    v9[3] = &stru_1ED84D0B0;
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    _DWORD v8[2] = __CFStringArrayPerformWithDelimiterWithDescription_block_invoke;
    unint64_t v8[3] = &unk_1E5484D00;
    v8[4] = &v10;
    void v8[5] = v9;
    v16.size_t length = CFArrayGetCount(Mutable);
    v16.CFIndex location = 0;
    CFArrayApplyFunction(Mutable, v16, (CFArrayApplierFunction)apply_block_1_15422, v8);
    CFStringAppend((CFMutableStringRef)v11[3], @"}"));
    (*(void (**)(uint64_t, uint64_t))(a2 + 16))(a2, v11[3]);
    int v6 = (const void *)v11[3];
    if (v6)
    {
      unint64_t v11[3] = 0;
      CFRelease(v6);
    }
    _Block_object_dispose(v9, 8);
    _Block_object_dispose(&v10, 8);
    CFRelease(Mutable);
  }
  else
  {
    int64_t v7 = *(void (**)(uint64_t, __CFString *))(a2 + 16);
    v7(a2, @"null");
  }
}

void appendDescriptionToArray(__CFString *a1, __CFArray *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFStringGetTypeID())
  {
    id v5 = a2;
    int v6 = a1;
LABEL_8:
    CFArrayAppendValue(v5, v6);
    return;
  }
  CFStringRef v7 = CFCopyDescription(a1);
  if (!v7)
  {
    int v6 = @"null";
    id v5 = a2;
    goto LABEL_8;
  }
  CFStringRef v8 = v7;
  CFArrayAppendValue(a2, v7);

  CFRelease(v8);
}

uint64_t apply_block_2_15471(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void __CFDictionaryCopySuperCompactDescription_block_invoke(uint64_t a1, const __CFString *a2, const __CFString *cf)
{
  if (!cf) {
    goto LABEL_12;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFDataGetTypeID())
  {
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"0x");
    BytePtr = CFDataGetBytePtr((CFDataRef)cf);
    CFIndex Length = CFDataGetLength((CFDataRef)cf);
    if (Length >= 1)
    {
      CFIndex v10 = Length;
      do
      {
        unsigned int v11 = *BytePtr++;
        CFStringAppendFormat(MutableCopy, 0, @"%02X", v11);
        --v10;
      }
      while (v10);
    }
    v21.CFIndex location = 0;
    v21.size_t length = 5;
    CFStringDelete(MutableCopy, v21);
    goto LABEL_16;
  }
  CFTypeID v12 = CFGetTypeID(cf);
  if (v12 != CFStringGetTypeID())
  {
    CFTypeID v16 = CFGetTypeID(cf);
    if (v16 == CFNumberGetTypeID())
    {
      CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFStringRef Copy = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@", cf);
      goto LABEL_14;
    }
LABEL_12:
    CFMutableStringRef MutableCopy = 0;
    goto LABEL_16;
  }
  CFIndex v13 = CFStringGetLength(cf);
  CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v13 > 5)
  {
    v22.CFIndex location = 0;
    v22.size_t length = 6;
    CFStringRef Copy = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cf, v22);
  }
  else
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cf);
  }
LABEL_14:
  CFStringRef v17 = Copy;
  CFIndex v18 = CFStringGetLength(Copy);
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v14, v18, v17);
  if (v17) {
    CFRelease(v17);
  }
LABEL_16:
  unsigned int CharacterAtIndex = CFStringGetCharacterAtIndex(a2, 0);
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), 0, @"%c:%@ ", CharacterAtIndex, MutableCopy);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = @", ";
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }
}

uint64_t CFDataCreateWithRandomBytes(size_t a1)
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2000000000;
  uint64_t v7 = 0;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = __CFDataCreateWithRandomBytes_block_invoke;
  v3[3] = &unk_1E5484C70;
  void v3[4] = &v4;
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  _DWORD v8[2] = __PerformWithBufferAndClear_block_invoke;
  unint64_t v8[3] = &unk_1E5484FC8;
  v8[4] = v3;
  PerformWithBuffer(a1, (uint64_t)v8);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

CFDataRef __CFDataCreateWithRandomBytes_block_invoke(uint64_t a1, size_t a2, void *bytes)
{
  CCRandomGenerateBytes(bytes, a2);
  CFDataRef result = CFDataCreate(0, (const UInt8 *)bytes, a2);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void __GetShortDateFormatter_block_invoke(uint64_t a1)
{
  CFLocaleRef v2 = CFLocaleCopyCurrent();
  **(void **)(a1 + 32) = CFDateFormatterCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
  CFDateFormatterSetFormat(**(CFDateFormatterRef **)(a1 + 32), @"yyyy-MM-dd HH:mm");
  if (v2)
  {
    CFRelease(v2);
  }
}

dispatch_queue_t __GetShortDateFormatterQueue_block_invoke(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("Date Formatting", 0);
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef __withStringOfAbsoluteTime_block_invoke(uint64_t a1, __CFDateFormatter *a2)
{
  CFStringRef result = CFDateFormatterCreateStringWithAbsoluteTime((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, *(CFAbsoluteTime *)(a1 + 40));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t __withShortDateFormatter_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __GetShortDateFormatter_block_invoke;
  block[3] = &__block_descriptor_tmp_53_15496;
  void block[4] = &GetShortDateFormatter_sGetShortDateFormatterSingleton;
  if (GetShortDateFormatter_sGetShortDateFormatterOnce != -1) {
    dispatch_once(&GetShortDateFormatter_sGetShortDateFormatterOnce, block);
  }
  uint64_t v2 = GetShortDateFormatter_sGetShortDateFormatterSingleton;
  size_t v3 = *(uint64_t (**)(uint64_t, uint64_t))(v1 + 16);

  return v3(v1, v2);
}

void der_encode_date(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  double v11 = MEMORY[0x18C12C760]();
  der_encode_generalizedtime_body_repair(0, 0, a2, a3, v11);
  if (!ccder_encode_constructed_tl())
  {
    CFStringRef v15 = (const __CFString *)sSecDERErrorDomain;
    SecCFCreateErrorWithFormat(-7, v15, 0, 0, v12, @"ccder failed to encode", v13, v14, a9);
  }
}

void __getAnchors_block_invoke()
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  addAnchor(Mutable, AppleRootCAHash, 1);
  addAnchor(Mutable, AppleRootG2Hash, 1);
  addAnchor(Mutable, AppleRootG3Hash, 1);
  addAnchor(Mutable, TestAppleRootCAHash, 0);
  addAnchor(Mutable, TestAppleRootG2Hash, 0);
  addAnchor(Mutable, TestAppleRootG3Hash, 0);
  getAnchors_anchors = (uint64_t)Mutable;
}

void addAnchor(const __CFDictionary *a1, const UInt8 *a2, int a3)
{
  CFDataRef v5 = CFDataCreateWithBytesNoCopy(0, a2, 32, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (CFDictionaryGetValue(a1, v5)) {
    abort();
  }
  uint64_t v6 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a3) {
    uint64_t v6 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(a1, v5, *v6);
  if (v5)
  {
    CFRelease(v5);
  }
}

uint64_t SecIsAppleTrustAnchor(void *a1, char a2)
{
  size_t v3 = SecCertificateCopySHA256Digest(a1);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  if (getAnchors_onceToken != -1) {
    dispatch_once(&getAnchors_onceToken, &__block_literal_global_4_15828);
  }
  if (!getAnchors_anchors)
  {
LABEL_13:
    uint64_t v6 = 0;
    goto LABEL_11;
  }
  CFNumberRef Value = CFDictionaryGetValue((CFDictionaryRef)getAnchors_anchors, v4);
  uint64_t v6 = (uint64_t)Value;
  if (Value)
  {
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFBooleanGetTypeID())
    {
      int v8 = CFBooleanGetValue((CFBooleanRef)v6);
      uint64_t v6 = v8 != 0;
      if (a2)
      {
        int v9 = v8;
        unsigned int v10 = os_variant_allows_internal_security_policies() | ((a2 & 2) >> 1);
        if (v9) {
          uint64_t v6 = 1;
        }
        else {
          uint64_t v6 = v10;
        }
      }
      goto LABEL_11;
    }
    goto LABEL_13;
  }
LABEL_11:
  CFRelease(v4);
  return v6;
}

void __SecGetAppleTrustAnchors_block_invoke(uint64_t a1)
{
  CFArrayRef Mutable = CFArrayCreateMutable(0, 3, MEMORY[0x1E4F1D510]);
  addCertificate(Mutable, &AppleRootCA, 1215);
  addCertificate(Mutable, &AppleRootG2, 1430);
  addCertificate(Mutable, &AppleRootG3, 583);
  if ((os_variant_allows_internal_security_policies() & 1) != 0 || *(unsigned char *)(a1 + 32))
  {
    addCertificate(Mutable, &TestAppleRootCA, 1232);
    addCertificate(Mutable, &TestAppleRootG2, 630);
    addCertificate(Mutable, &TestAppleRootG3, 592);
  }
  SecGetAppleTrustAnchors_anchors = (uint64_t)Mutable;
}

void addCertificate(const __CFArray *a1, const void *a2, int64_t a3)
{
  uint64_t v4 = SecCertificateCreateWithBytes(0, a2, a3);
  v6.size_t length = CFArrayGetCount(a1);
  v6.CFIndex location = 0;
  if (CFArrayContainsValue(a1, v6, v4)) {
    abort();
  }
  CFArrayAppendValue(a1, v4);
  if (v4)
  {
    CFRelease(v4);
  }
}

BOOL SecKernError(int a1, CFTypeRef *a2, CFStringRef format, ...)
{
  va_start(va, format);
  if (a1 && a2)
  {
    CFDataRef v5 = (__CFString *)*a2;
    *a2 = 0;
    SecCFCreateErrorWithFormatAndArguments(a1, (const __CFString *)*MEMORY[0x1E4F1D150], v5, a2, 0, format, va);
  }
  return a1 == 0;
}

void SecCFCreateErrorWithFormatAndArguments(CFIndex a1, const __CFString *a2, __CFString *cf, CFTypeRef *a4, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  if (!a4) {
    return;
  }
  if (*a4)
  {
    if (cf && *a4 != cf)
    {
      CFRelease(cf);
    }
    return;
  }
  CFStringRef v11 = CFStringCreateWithFormatAndArguments(0, formatOptions, format, arguments);
  uint64_t v30 = 0;
  uint64_t v12 = (const void **)MEMORY[0x1E4F1D140];
  if (!cf) {
    goto LABEL_30;
  }
  CFDictionaryRef v13 = CFErrorCopyUserInfo((CFErrorRef)cf);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v13, *v12);
  if (Value)
  {
    BOOL v15 = CFEqual(v11, Value);
    if (!v13) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  BOOL v15 = 0;
  if (v13) {
LABEL_11:
  }
    CFRelease(v13);
LABEL_12:
  CFIndex Code = CFErrorGetCode((CFErrorRef)cf);
  CFStringRef Domain = CFErrorGetDomain((CFErrorRef)cf);
  CFComparisonResult v18 = CFStringCompare(a2, Domain, 0);
  BOOL v20 = Code == a1 && v18 == kCFCompareEqualTo && v15;
  CFRange v21 = cf;
  if (v20) {
    goto LABEL_19;
  }
  CFDictionaryRef v23 = CFErrorCopyUserInfo((CFErrorRef)cf);
  if (v23)
  {
    CFDictionaryRef v24 = v23;
    if (CFDictionaryContainsKey(v23, @"numberOfErrorsDeep") == 1)
    {
      CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(v24, @"numberOfErrorsDeep");
      if (v25)
      {
        uint64_t valuePtr = 0;
        CFNumberGetValue(v25, kCFNumberLongType, &valuePtr);
        if (valuePtr > 199)
        {
          CFRelease(v24);
          CFRange v21 = cf;
LABEL_19:
          CFRetain(v21);
          *a4 = cf;
          CFRelease(cf);
          if (!v11) {
            return;
          }
          CFStringRef v22 = v11;
          goto LABEL_44;
        }
        uint64_t v30 = valuePtr + 1;
      }
    }
    CFRelease(v24);
  }
LABEL_30:
  CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v27 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, &v30);
  CFArrayRef Mutable = CFDictionaryCreateMutable(v26, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  long long v29 = Mutable;
  if (cf) {
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F1D190], cf);
  }
  if (v27) {
    CFDictionaryAddValue(v29, @"numberOfErrorsDeep", v27);
  }
  if (v11) {
    CFDictionaryAddValue(v29, *v12, v11);
  }
  *a4 = CFErrorCreate(v26, a2, a1, v29);
  if (v27) {
    CFRelease(v27);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (cf)
  {
    CFStringRef v22 = cf;
LABEL_44:
    CFRelease(v22);
  }
}

void SecCheckErrno(uint64_t a1, CFTypeRef *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a2)
  {
    CFIndex v11 = *__error();
    uint64_t v12 = (__CFString *)*a2;
    *a2 = 0;
    CFStringRef v13 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a3, &a9);
    CFStringRef v14 = (const __CFString *)*MEMORY[0x1E4F1D160];
    strerror(v11);
    SecCFCreateErrorWithFormat(v11, v14, v12, a2, v15, @"%@: [%d] %s", v16, v17, (char)v13);
    if (v13) {
      CFRelease(v13);
    }
  }
}

void SecCFCreateErrorWithFormat(CFIndex a1, const __CFString *a2, __CFString *a3, CFTypeRef *a4, uint64_t a5, const __CFString *a6, uint64_t a7, uint64_t a8, char a9)
{
}

BOOL SecError(int a1, __CFString **a2, CFStringRef format, ...)
{
  va_start(va, format);
  if (a1)
  {
    CFTypeRef cf = 0;
    CFStringRef v5 = (const __CFString *)*MEMORY[0x1E4F1D158];
    if (a2)
    {
      SecCFCreateErrorWithFormatAndArguments(a1, v5, *a2, &cf, 0, format, va);
      *a2 = (__CFString *)cf;
    }
    else
    {
      SecCFCreateErrorWithFormatAndArguments(a1, v5, 0, &cf, 0, format, va);
      CFTypeRef v6 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v6);
      }
    }
  }
  return a1 == 0;
}

uint64_t SecRequirementError(uint64_t a1, CFTypeRef *a2, CFStringRef format, ...)
{
  va_start(va, format);
  if (a2 && (a1 & 1) == 0)
  {
    CFStringRef v5 = (__CFString *)*a2;
    *a2 = 0;
    SecCFCreateErrorWithFormatAndArguments(-50, (const __CFString *)*MEMORY[0x1E4F1D158], v5, a2, 0, format, va);
  }
  return a1;
}

BOOL SecAllocationError(uint64_t a1, CFTypeRef *a2, CFStringRef format, ...)
{
  va_start(va, format);
  if (!a1 && a2)
  {
    CFStringRef v5 = (__CFString *)*a2;
    *a2 = 0;
    SecCFCreateErrorWithFormatAndArguments(-108, (const __CFString *)*MEMORY[0x1E4F1D158], v5, a2, 0, format, va);
  }
  return a1 != 0;
}

uint64_t der_encode_plist(const __CFString *a1, CFTypeRef *a2, UInt8 *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return der_encode_plist_repair(a1, a2, 0, a3, a4, a6, a7, a8);
}

CFTypeRef CFPropertyListCreateWithDERData(uint64_t a1, CFDataRef theData, uint64_t a3, void *a4, CFTypeRef *a5)
{
  CFTypeRef cf = 0;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  CFIndex v11 = &BytePtr[Length];
  uint64_t v15 = der_decode_plist(a1, (uint64_t)&cf, a5, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length], v12, v13, v14);
  if (!v15 || (const UInt8 *)v15 == v11)
  {
    if (a4) {
      *a4 = 400;
    }
  }
  else
  {
    SecCFCreateErrorWithFormat(-1, (const __CFString *)sSecDERErrorDomain, 0, a5, v16, @"trailing garbage after plist item", v17, v18, v21);
    CFTypeRef v19 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v19);
    }
  }
  return cf;
}

uint64_t der_encode_null(CFTypeRef *a1)
{
  uint64_t v5 = ccder_encode_tl();
  if (!v5) {
    SecCFCreateErrorWithFormat(-7, (const __CFString *)sSecDERErrorDomain, 0, a1, v2, @"ccder failed to encode", v3, v4, v7);
  }
  return v5;
}

uint64_t der_sizeof_set(const __CFSet *a1, uint64_t a2)
{
  long long v3 = xmmword_18B414B80;
  LOBYTE(v3) = 1;
  uint64_t v4 = a2;
  CFSetApplyFunction(a1, (CFSetApplierFunction)add_value_size, &v3);
  if ((_BYTE)v3) {
    return ccder_sizeof();
  }
  else {
    return 0;
  }
}

uint64_t add_value_size(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    CFStringRef result = der_sizeof_plist(result, *(void *)(a2 + 16));
    if (result) {
      *(void *)(a2 + 8) += result;
    }
    else {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

uint64_t der_encode_set_repair(const __CFSet *a1, CFTypeRef *a2, char a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  v14[0] = 0xAAAAAAAAAAAAAA01;
  v14[1] = a2;
  BYTE1(v14[0]) = a3;
  _OWORD v14[2] = Mutable;
  v14[3] = 0;
  CFSetApplyFunction(a1, (CFSetApplierFunction)add_sequence_to_array_16026, v14);
  if (!LOBYTE(v14[0]))
  {
    if (Mutable) {
      CFRelease(Mutable);
    }
    return 0;
  }
  v15.size_t length = CFArrayGetCount(Mutable);
  v15.CFIndex location = 0;
  CFArraySortValues(Mutable, v15, (CFComparatorFunction)cfdata_compare_der_contents_16025, 0);
  CFIndex Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    unint64_t v8 = Count + 1;
    do
    {
      CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Mutable, v8 - 2);
      CFDataGetLength(ValueAtIndex);
      CFDataGetBytePtr(ValueAtIndex);
      ccder_encode_body();
      --v8;
    }
    while (v8 > 1);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  uint64_t result = ccder_encode_constructed_tl();
  if (!result)
  {
    SecCFCreateErrorWithFormat(-7, (const __CFString *)sSecDERErrorDomain, 0, a2, v11, @"ccder failed to encode", v12, v13, v14[0]);
    return 0;
  }
  return result;
}

uint64_t cfdata_compare_der_contents_16025(const __CFData *a1, const __CFData *a2)
{
  CFIndex Length = CFDataGetLength(a1);
  CFIndex v5 = CFDataGetLength(a2);
  unint64_t v6 = v5;
  if (Length < 0 || v5 < 0)
  {
    if (Length >= v5) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = -1;
    }
    if (Length <= v5) {
      return v12;
    }
    else {
      return 1;
    }
  }
  else
  {
    if (Length >= v5) {
      size_t v7 = v5;
    }
    else {
      size_t v7 = Length;
    }
    BytePtr = CFDataGetBytePtr(a1);
    int v9 = CFDataGetBytePtr(a2);
    int v10 = memcmp(BytePtr, v9, v7);
    if (v10 <= 0 && (v10 || Length <= v6))
    {
      LODWORD(v13) = v10 == 0;
      if (Length >= v6) {
        LODWORD(v13) = 0;
      }
      if (v10 < 0) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = v13;
      }
      return v13 << 63 >> 63;
    }
    else
    {
      return 1;
    }
  }
}

void add_sequence_to_array_16026(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)a2)
  {
    CFIndex v10 = der_sizeof_plist(a1, *(CFTypeRef **)(a2 + 8), a3, a4, a5, a6, a7, a8);
    if (!v10)
    {
      *(unsigned char *)a2 = 0;
      return;
    }
    CFIndex v11 = v10;
    CFMutableArrayRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a2 + 24), v10);
    CFDataSetLength(Mutable, v11);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    uint64_t v14 = der_encode_plist_repair(a1, *(void *)(a2 + 8), *(unsigned __int8 *)(a2 + 1), MutableBytePtr, &MutableBytePtr[v11]);
    if (v14)
    {
      v16.size_t length = v14 - (void)MutableBytePtr;
      v16.CFIndex location = 0;
      CFDataDeleteBytes(Mutable, v16);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 16), Mutable);
      if (!Mutable) {
        return;
      }
    }
    else
    {
      *(unsigned char *)a2 = 0;
      if (!Mutable) {
        return;
      }
    }
    CFRelease(Mutable);
  }
}

uint64_t GetKeybagAssertionQueue()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __GetKeybagAssertionQueue_block_invoke;
  block[3] = &__block_descriptor_tmp_16030;
  void block[4] = &GetKeybagAssertionQueue_sGetKeybagAssertionQueueSingleton;
  if (GetKeybagAssertionQueue_sGetKeybagAssertionQueueOnce != -1) {
    dispatch_once(&GetKeybagAssertionQueue_sGetKeybagAssertionQueueOnce, block);
  }
  return GetKeybagAssertionQueue_sGetKeybagAssertionQueueSingleton;
}

dispatch_queue_t __GetKeybagAssertionQueue_block_invoke(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("AKS Lock Assertion Queue", 0);
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t __SecAKSKeybagHoldLockAssertion_block_invoke(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (!count)
  {
    uint64_t v2 = secLogObjForScope("lockassertions");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(v1 + 40);
      int v4 = 134217984;
      uint64_t v5 = v3;
      _os_log_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEFAULT, "Requesting lock assertion for %lld seconds", (uint8_t *)&v4, 0xCu);
    }
    dispatch_queue_t result = aks_assert_hold(*(_DWORD *)(v1 + 48), 0, *(void *)(v1 + 40));
    *(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 8) + 24) = result;
  }
  if (!*(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 8) + 24)) {
    ++count;
  }
  return result;
}

uint64_t __SecAKSKeybagDropLockAssertion_block_invoke(uint64_t result)
{
  int v1 = count;
  if (count)
  {
    --count;
    if (v1 == 1)
    {
      uint64_t v2 = result;
      uint64_t v3 = secLogObjForScope("lockassertions");
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v4 = 0;
        _os_log_impl(&dword_18B299000, v3, OS_LOG_TYPE_DEFAULT, "Dropping lock assertion", v4, 2u);
      }
      dispatch_queue_t result = aks_assert_drop(*(_DWORD *)(v2 + 40), 0);
      *(_DWORD *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = result;
    }
  }
  return result;
}

void __SecIsEduMode_block_invoke()
{
  uint64_t v18 = 0;
  CFTypeRef v19 = &v18;
  uint64_t v20 = 0x2000000000;
  int v0 = getMKBUserTypeDeviceModeSymbolLoc_ptr;
  char v21 = getMKBUserTypeDeviceModeSymbolLoc_ptr;
  if (!getMKBUserTypeDeviceModeSymbolLoc_ptr)
  {
    *(void *)long long buf = MEMORY[0x1E4F143A8];
    uint64_t v14 = 0x40000000;
    CFRange v15 = __getMKBUserTypeDeviceModeSymbolLoc_block_invoke;
    CFRange v16 = &unk_1E5484EB8;
    uint64_t v17 = &v18;
    int v1 = (void *)MobileKeyBagLibrary();
    v19[3] = (uint64_t)dlsym(v1, "MKBUserTypeDeviceMode");
    getMKBUserTypeDeviceModeSymbolLoc_ptr = *(_UNKNOWN **)(v17[1] + 24);
    int v0 = (void *)v19[3];
  }
  _Block_object_dispose(&v18, 8);
  if (!v0)
  {
LABEL_18:
    dlerror();
    uint64_t v11 = abort_report_np();
    __getMKBUserTypeDeviceModeSymbolLoc_block_invoke(v11);
    return;
  }
  uint64_t v2 = ((uint64_t (*)(void, void))v0)(0, 0);
  if (v2)
  {
    uint64_t v3 = (const void *)v2;
    xpc_object_t value = 0;
    uint64_t v18 = 0;
    CFTypeRef v19 = &v18;
    uint64_t v20 = 0x2000000000;
    int v4 = (const void **)getkMKBDeviceModeKeySymbolLoc_ptr;
    char v21 = (void *)getkMKBDeviceModeKeySymbolLoc_ptr;
    if (!getkMKBDeviceModeKeySymbolLoc_ptr)
    {
      *(void *)long long buf = MEMORY[0x1E4F143A8];
      uint64_t v14 = 0x40000000;
      CFRange v15 = __getkMKBDeviceModeKeySymbolLoc_block_invoke;
      CFRange v16 = &unk_1E5484F18;
      uint64_t v17 = &v18;
      uint64_t v5 = (void *)MobileKeyBagLibrary();
      v19[3] = (uint64_t)dlsym(v5, "kMKBDeviceModeKey");
      getkMKBDeviceModeKeySymbolLoc_ptr = *(void *)(v17[1] + 24);
      int v4 = (const void **)v19[3];
    }
    _Block_object_dispose(&v18, 8);
    if (v4)
    {
      if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)v3, *v4, (const void **)&value))
      {
LABEL_14:
        CFRelease(v3);
        return;
      }
      uint64_t v6 = value;
      uint64_t v18 = 0;
      CFTypeRef v19 = &v18;
      uint64_t v20 = 0x2000000000;
      size_t v7 = (CFTypeRef *)getkMKBDeviceModeSharedIPadSymbolLoc_ptr;
      char v21 = (void *)getkMKBDeviceModeSharedIPadSymbolLoc_ptr;
      if (!getkMKBDeviceModeSharedIPadSymbolLoc_ptr)
      {
        *(void *)long long buf = MEMORY[0x1E4F143A8];
        uint64_t v14 = 0x40000000;
        CFRange v15 = __getkMKBDeviceModeSharedIPadSymbolLoc_block_invoke;
        CFRange v16 = &unk_1E5484F40;
        uint64_t v17 = &v18;
        unint64_t v8 = (void *)MobileKeyBagLibrary();
        int v9 = dlsym(v8, "kMKBDeviceModeSharedIPad");
        *(void *)(v17[1] + 24) = v9;
        getkMKBDeviceModeSharedIPadSymbolLoc_ptr = *(void *)(v17[1] + 24);
        size_t v7 = (CFTypeRef *)v19[3];
      }
      _Block_object_dispose(&v18, 8);
      if (v7)
      {
        if (CFEqual(v6, *v7)) {
          SecIsEduMode_dispatch_queue_t result = 1;
        }
        goto LABEL_14;
      }
    }
    goto LABEL_18;
  }
  CFIndex v10 = secLogObjForScope("edumode");
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEFAULT, "Cannot determine because deviceMode is NULL", buf, 2u);
  }
}

void *__getMKBUserTypeDeviceModeSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)MobileKeyBagLibrary();
  dispatch_queue_t result = dlsym(v2, "MKBUserTypeDeviceMode");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getMKBUserTypeDeviceModeSymbolLoc_ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t MobileKeyBagLibrary()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!MobileKeyBagLibraryCore_frameworkLibrary)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    v3[2] = 0x40000000;
    v3[3] = __MobileKeyBagLibraryCore_block_invoke;
    void v3[4] = &__block_descriptor_tmp_43_16093;
    void v3[5] = v3;
    long long v4 = xmmword_1E5484ED8;
    uint64_t v5 = 0;
    MobileKeyBagLibraryCore_frameworkLibrary = _sl_dlopen();
    int v1 = (void *)v3[0];
    uint64_t v0 = MobileKeyBagLibraryCore_frameworkLibrary;
    if (MobileKeyBagLibraryCore_frameworkLibrary)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      int v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return MobileKeyBagLibraryCore_frameworkLibrary;
}

void *__getkMKBDeviceModeKeySymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)MobileKeyBagLibrary();
  dispatch_queue_t result = dlsym(v2, "kMKBDeviceModeKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkMKBDeviceModeKeySymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getkMKBDeviceModeSharedIPadSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)MobileKeyBagLibrary();
  dispatch_queue_t result = dlsym(v2, "kMKBDeviceModeSharedIPad");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkMKBDeviceModeSharedIPadSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __MobileKeyBagLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  MobileKeyBagLibraryCore_frameworkLibrary = result;
  return result;
}

CFURLRef SecCopyURLForFileInBaseDirectory(const __CFString *a1, uint64_t a2)
{
  CFURLRef v4 = SecCopyBaseFilesURL(1);
  if (a2)
  {
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef Copy = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@/%@", a1, a2);
  }
  else
  {
    if (!a1) {
      goto LABEL_10;
    }
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1);
  }
  CFStringRef v7 = Copy;
  if (v4 && Copy)
  {
    CFURLRef v8 = CFURLCreateCopyAppendingPathComponent(v5, v4, Copy, a2 == 0);
    CFRelease(v7);
LABEL_11:
    CFRelease(v4);
    return v8;
  }
  if (Copy) {
    CFRelease(Copy);
  }
LABEL_10:
  CFURLRef v8 = 0;
  if (v4) {
    goto LABEL_11;
  }
  return v8;
}

void WithPathInDirectory(const __CFURL *a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    memset(__b, 170, sizeof(__b));
    CFURLGetFileSystemRepresentation(a1, 0, __b, 1024);
    (*(void (**)(uint64_t, UInt8 *))(a2 + 16))(a2, __b);
    CFRelease(a1);
  }
}

void WithPathInKeychainDirectory(uint64_t a1, uint64_t a2)
{
  syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0);
  CFURLRef v4 = SecCopyURLForFileInBaseDirectory(@"Library/Keychains", a1);

  WithPathInDirectory(v4, a2);
}

void __security_simulatecrash(void *a1, unsigned int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  CFURLRef v4 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "Simulating crash, reason: %@, code=%08x", buf, 0x12u);
  }

  int v5 = __simulate_crash_counter;
  if (__simulate_crash_counter != -1) {
    goto LABEL_4;
  }
  if (!CrashReporterSupportLibraryCore())
  {
    int v5 = __simulate_crash_counter;
LABEL_4:
    __simulate_crash_counter = v5 + 1;
    return;
  }
  uint64_t v6 = getpid();
  id v7 = a1;
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000;
  CFURLRef v8 = (void (*)(uint64_t, void, id))getSimulateCrashSymbolLoc_ptr;
  CFRange v16 = getSimulateCrashSymbolLoc_ptr;
  if (!getSimulateCrashSymbolLoc_ptr)
  {
    *(void *)long long buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = __getSimulateCrashSymbolLoc_block_invoke;
    uint64_t v18 = &unk_1E5484FA0;
    CFTypeRef v19 = &v13;
    int v9 = CrashReporterSupportLibrary();
    CFIndex v10 = dlsym(v9, "SimulateCrash");
    *(void *)(v19[1] + 24) = v10;
    getSimulateCrashSymbolLoc_ptr = *(_UNKNOWN **)(v19[1] + 24);
    CFURLRef v8 = (void (*)(uint64_t, void, id))v14[3];
  }
  _Block_object_dispose(&v13, 8);
  if (!v8)
  {
    uint64_t v11 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v12 = objc_msgSend(NSString, "stringWithUTF8String:", "BOOL soft_SimulateCrash(pid_t, mach_exception_data_type_t, NSString *__strong)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, @"simulate_crash.m", 22, @"%s", dlerror());

    __break(1u);
  }
  v8(v6, a2, v7);
}

void sub_18B3D3F80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t CrashReporterSupportLibraryCore()
{
  if (!CrashReporterSupportLibraryCore_frameworkLibrary) {
    CrashReporterSupportLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  return CrashReporterSupportLibraryCore_frameworkLibrary;
}

void *__getSimulateCrashSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = CrashReporterSupportLibrary();
  uint64_t result = dlsym(v2, "SimulateCrash");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getSimulateCrashSymbolLoc_ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *CrashReporterSupportLibrary()
{
  uint64_t v0 = CrashReporterSupportLibraryCore();
  if (v0) {
    return (void *)v0;
  }
  int v1 = [MEMORY[0x1E4F28B00] currentHandler];
  uint64_t v3 = [NSString stringWithUTF8String:"void *CrashReporterSupportLibrary(void)"];
  objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v3, @"simulate_crash.m", 18, @"%s", 0);

  __break(1u);
  free(v4);
  return v1;
}

uint64_t __CrashReporterSupportLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CrashReporterSupportLibraryCore_frameworkLibrary = result;
  return result;
}

void *__getWriteStackshotReportSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = CrashReporterSupportLibrary();
  uint64_t result = dlsym(v2, "WriteStackshotReport");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getWriteStackshotReportSymbolLoc_ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

xpc_object_t SecCreateXPCObjectWithCFError(__CFError *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  CFStringRef Domain = CFErrorGetDomain(a1);
  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 0x40000000;
  void v21[2] = __SecXPCDictionarySetCFString_block_invoke;
  v21[3] = &__block_descriptor_tmp_16175;
  void v21[4] = v2;
  void v21[5] = "domain";
  v22[0] = MEMORY[0x1E4F143A8];
  v22[1] = 0x40000000;
  _OWORD v22[2] = __CFStringPerformWithCString_block_invoke;
  v22[3] = &unk_1E5484C20;
  void v22[4] = v21;
  CFStringPerformWithCStringAndLength(Domain, (uint64_t)v22);
  int64_t Code = CFErrorGetCode(a1);
  xpc_dictionary_set_int64(v2, "code", Code);
  CFStringRef v5 = (const __CFString *)CFErrorCopyUserInfo(a1);
  size_t v12 = der_sizeof_plist(v5, 0, v6, v7, v8, v9, v10, v11);
  if (v12)
  {
    size_t v13 = v12;
    uint64_t v14 = (UInt8 *)malloc_type_malloc(v12, 0x4ABABCFuLL);
    unint64_t v15 = (unint64_t)&v14[v13];
    CFTypeRef v19 = (const void *)der_encode_plist_repair(v5, 0, 0, v14, v15, v16, v17, v18);
    if (v19) {
      xpc_dictionary_set_data(v2, "userinfo", v19, v15 - (void)v19);
    }
    free(v14);
  }
  CFRelease(v5);
  return v2;
}

void __SecXPCDictionarySetCFString_block_invoke(uint64_t a1, char *string)
{
}

uint64_t SecGetCurrentServerLoggingInfo(uint64_t a1)
{
  uint64_t v4 = 0;
  CFStringRef v5 = &v4;
  uint64_t v6 = 0x2000000000;
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = __SecGetCurrentServerLoggingInfo_block_invoke;
  v3[3] = &unk_1E5485010;
  void v3[4] = &v4;
  void v3[5] = a1;
  _os_activity_initiate(&dword_18B299000, "SecGetCurrentServerLoggingInfo", OS_ACTIVITY_FLAG_DEFAULT, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void __SecGetCurrentServerLoggingInfo_block_invoke(uint64_t a1)
{
  if (gSecurityd && (xpc_object_t v2 = *(uint64_t (**)(void))(gSecurityd + 512)) != 0)
  {
    uint64_t v3 = v2(*(void *)(a1 + 40));
  }
  else
  {
    uint64_t v4 = *(CFTypeRef **)(a1 + 40);
    uint64_t v6 = 0;
    unint64_t v7 = &v6;
    uint64_t v8 = 0x2000000000;
    uint64_t v9 = 0;
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    _DWORD v5[2] = __void_to_dict_error_request_block_invoke;
    v5[3] = &unk_1E5485088;
    void v5[4] = &v6;
    securityd_send_sync_and_do(0x1Fu, v4, 0, (uint64_t)v5);
    uint64_t v3 = v7[3];
    _Block_object_dispose(&v6, 8);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v3;
}

BOOL __void_to_dict_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  CFTypeRef v4 = SecXPCDictionaryCopyPListAndPossiblyMutateMessage(1, a2, "status", a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
  return v4 != 0;
}

uint64_t SecSetLoggingInfoForXPCScope(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  char v8 = -86;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecSetLoggingInfoForXPCScope_block_invoke;
  activity_block[3] = &unk_1E5485038;
  activity_void block[4] = &v5;
  activity_void block[5] = a1;
  void activity_block[6] = a2;
  _os_activity_initiate(&dword_18B299000, "SecSetLoggingInfoForXPCScope", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecSetLoggingInfoForXPCScope_block_invoke(void *a1)
{
  if (gSecurityd && (uint64_t v2 = *(uint64_t (**)(void, void))(gSecurityd + 520)) != 0)
  {
    uint64_t result = v2(a1[5], a1[6]);
  }
  else
  {
    uint64_t v5 = a1[5];
    CFTypeRef v4 = (CFTypeRef *)a1[6];
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __dict_to_error_request_block_invoke_16186;
    unint64_t v6[3] = &__block_descriptor_tmp_5_16187;
    void v6[4] = v5;
    uint64_t result = securityd_send_sync_and_do(0x20u, v4, (uint64_t)v6, 0);
  }
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

size_t __dict_to_error_request_block_invoke_16186(uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return SecXPCDictionarySetPListWithRepair(a2, "query", *(const __CFString **)(a1 + 32), a3, a5, a6, a7, a8);
}

uint64_t SecSetLoggingInfoForCircleScope(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  char v8 = -86;
  activity_block[0] = MEMORY[0x1E4F143A8];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecSetLoggingInfoForCircleScope_block_invoke;
  activity_block[3] = &unk_1E5485060;
  activity_void block[4] = &v5;
  activity_void block[5] = a1;
  void activity_block[6] = a2;
  _os_activity_initiate(&dword_18B299000, "SecSetLoggingInfoForCircleScope", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecSetLoggingInfoForCircleScope_block_invoke(void *a1)
{
  if (gSecurityd && (uint64_t v2 = *(uint64_t (**)(void, void))(gSecurityd + 528)) != 0)
  {
    uint64_t result = v2(a1[5], a1[6]);
  }
  else
  {
    uint64_t v5 = a1[5];
    CFTypeRef v4 = (CFTypeRef *)a1[6];
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = __dict_to_error_request_block_invoke_16186;
    unint64_t v6[3] = &__block_descriptor_tmp_5_16187;
    void v6[4] = v5;
    uint64_t result = securityd_send_sync_and_do(0x21u, v4, (uint64_t)v6, 0);
  }
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

uint64_t Security::CFMunge::next(Security::CFMunge *this)
{
  uint64_t v1 = *(unsigned __int8 **)this;
  LOBYTE(v2) = **(unsigned char **)this;
  if ((_BYTE)v2)
  {
    uint64_t v4 = MEMORY[0x1E4F14390];
    do
    {
      if ((v2 & 0x80) != 0)
      {
        int v5 = __maskrune((char)v2, 0x4000uLL);
        uint64_t v1 = *(unsigned __int8 **)this;
        if (!v5)
        {
LABEL_7:
          int v2 = *v1;
          if (v2 != 44) {
            return (char)v2;
          }
        }
      }
      else if ((*(_DWORD *)(v4 + 4 * (char)v2 + 60) & 0x4000) == 0)
      {
        goto LABEL_7;
      }
      *(void *)this = v1 + 1;
      int v2 = *++v1;
    }
    while (v2);
  }
  return (char)v2;
}

CFDataRef Security::CFMake::make(Security::CFMake *this)
{
  while (Security::CFMunge::next(this) == 64)
  {
    uint64_t v2 = (*(void *)this)++;
    int v3 = *(char *)(v2 + 1);
    if (v3 == 69)
    {
      *(void *)this = v2 + 2;
      uint64_t v6 = (_DWORD **)*((void *)this + 1);
      uint64_t v7 = *v6;
      *v6 += 2;
      *((_DWORD *)this + 6) = *v7;
    }
    else if (v3 == 65)
    {
      *(void *)this = v2 + 2;
      uint64_t v4 = (void **)*((void *)this + 1);
      int v5 = (*v4)++;
      *((void *)this + 2) = *v5;
    }
  }
  int v8 = Security::CFMunge::next(this);
  CFMutableStringRef MutableCopy = 0;
  if (v8 > 90)
  {
    if (v8 <= 122)
    {
      if (v8 != 91)
      {
        if (v8 == 93) {
          return MutableCopy;
        }
        goto LABEL_45;
      }
      ++*(void *)this;
      if (Security::CFMunge::next(this) == 33) {
        ++*(void *)this;
      }
      unint64_t v15 = (Security *)Security::CFMunge::next(this);
      if (v15 == 43)
      {
        ++*(void *)this;
        if (Security::CFMunge::next(this) != 37) {
          return 0;
        }
        ++*(void *)this;
        if (Security::CFMunge::next(this) != 79) {
          return 0;
        }
        uint64_t v17 = (CFArrayRef **)*((void *)this + 1);
        ++*(void *)this;
        uint64_t v18 = (*v17)++;
        CFMutableStringRef MutableCopy = CFArrayCreateMutableCopy(*((CFAllocatorRef *)this + 2), 0, *v18);
        if (Security::CFMunge::next(this) != 125) {
          goto LABEL_52;
        }
      }
      else
      {
        CFMutableStringRef MutableCopy = Security::makeCFMutableArray(v15, v16);
LABEL_52:
        while (Security::CFMunge::next(this) != 93)
        {
          int64_t v33 = (const void *)Security::CFMake::make(this);
          if (!v33) {
            goto LABEL_62;
          }
          uint64_t v34 = v33;
          CFArrayAppendValue(MutableCopy, v33);
          CFRelease(v34);
        }
      }
LABEL_37:
      ++*(void *)this;
      return MutableCopy;
    }
    if (v8 == 125) {
      return MutableCopy;
    }
    if (v8 != 123) {
      goto LABEL_45;
    }
    ++*(void *)this;
    if (Security::CFMunge::next(this) == 33) {
      ++*(void *)this;
    }
    if (Security::CFMunge::next(this) == 43)
    {
      ++*(void *)this;
      if (Security::CFMunge::next(this) != 37) {
        return 0;
      }
      ++*(void *)this;
      if (Security::CFMunge::next(this) != 79) {
        return 0;
      }
      size_t v13 = (CFDictionaryRef **)*((void *)this + 1);
      ++*(void *)this;
      uint64_t v14 = (*v13)++;
      CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(*((CFAllocatorRef *)this + 2), 0, *v14);
      if (Security::CFMunge::next(this) == 125) {
        goto LABEL_37;
      }
    }
    else
    {
      CFMutableStringRef MutableCopy = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 2), 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    if (!MutableCopy || Security::CFMake::add(this, MutableCopy)) {
      return MutableCopy;
    }
LABEL_62:
    CFRelease(MutableCopy);
    return 0;
  }
  if (v8 <= 36)
  {
    if (!v8) {
      return MutableCopy;
    }
    if (v8 == 35)
    {
      CFMutableStringRef MutableCopy = 0;
      uint64_t v10 = *(char **)this;
      *(void *)this += 2;
      int v11 = v10[1];
      if (v11 <= 83)
      {
        if (v11 != 70)
        {
          if (v11 == 78)
          {
            uint64_t v12 = MEMORY[0x1E4F1D260];
            return *(CFDataRef *)v12;
          }
          return MutableCopy;
        }
      }
      else
      {
        if (v11 == 84)
        {
LABEL_14:
          uint64_t v12 = MEMORY[0x1E4F1CFD0];
          return *(CFDataRef *)v12;
        }
        if (v11 != 102)
        {
          if (v11 == 116) {
            goto LABEL_14;
          }
          return MutableCopy;
        }
      }
      uint64_t v12 = MEMORY[0x1E4F1CFC8];
      return *(CFDataRef *)v12;
    }
LABEL_45:
    unsigned int v29 = **(char **)this;
    if ((v29 & 0x80000000) != 0)
    {
      int v37 = __maskrune(**(char **)this, 0x100uLL);
    }
    else
    {
      if (v29 == 45 || (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v29 + 60) & 0x400) != 0)
      {
        double valuePtr = strtod(*(const char **)this, (char **)this);
        CFAllocatorRef v31 = (const __CFAllocator *)*((void *)this + 2);
        CFNumberType v32 = kCFNumberDoubleType;
        return CFNumberCreate(v31, v32, &valuePtr);
      }
      int v37 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v29 + 60) & 0x100;
    }
    if (v37) {
      goto LABEL_70;
    }
    return 0;
  }
  if (v8 != 37)
  {
    if (v8 == 39)
    {
LABEL_70:
      return (CFDataRef)Security::CFMake::makestring(this);
    }
    goto LABEL_45;
  }
  CFMutableStringRef MutableCopy = 0;
  uint64_t v19 = *(void *)this;
  *(void *)this += 2;
  int v20 = *(char *)(v19 + 1);
  if (v20 > 99)
  {
    if (v20 == 100)
    {
      unsigned int v43 = (_DWORD **)*((void *)this + 1);
      long long v44 = *v43;
      *v43 += 2;
      LODWORD(valuePtr) = *v44;
      CFAllocatorRef v31 = 0;
      CFNumberType v32 = kCFNumberIntType;
      return CFNumberCreate(v31, v32, &valuePtr);
    }
    if (v20 != 115)
    {
      if (v20 != 117) {
        return MutableCopy;
      }
      unsigned int v35 = (unsigned int **)*((void *)this + 1);
      unint64_t v36 = *v35;
      *v35 += 2;
      *(void *)&double valuePtr = *v36;
      CFAllocatorRef v31 = 0;
      CFNumberType v32 = kCFNumberLongLongType;
      return CFNumberCreate(v31, v32, &valuePtr);
    }
    CC_LONG64 v46 = (const char ***)*((void *)this + 1);
    CFAllocatorRef v45 = (const __CFAllocator *)*((void *)this + 2);
    unint64_t v47 = (*v46)++;
    int v48 = *v47;
    return (CFDataRef)CFStringCreateWithCString(v45, v48, 0x8000100u);
  }
  else
  {
    switch(v20)
    {
      case 'B':
        long long v38 = (_DWORD **)*((void *)this + 1);
        long long v39 = *v38;
        *v38 += 2;
        uint64_t v12 = MEMORY[0x1E4F1CFD0];
        if (!*v39) {
          uint64_t v12 = MEMORY[0x1E4F1CFC8];
        }
        return *(CFDataRef *)v12;
      case 'O':
        long long v40 = (const void ***)*((void *)this + 1);
        long long v41 = (*v40)++;
        long long v42 = *v41;
        return (CFDataRef)CFRetain(v42);
      case 'b':
        char v21 = (const UInt8 ***)*((void *)this + 1);
        CFStringRef v22 = (*v21)++;
        CFDictionaryRef v23 = *v22;
        CFDictionaryRef v24 = (CFIndex **)*((void *)this + 1);
        CFNumberRef v25 = (*v24)++;
        CFIndex v26 = *v25;
        CFAllocatorRef v27 = (const __CFAllocator *)*((void *)this + 2);
        return CFDataCreate(v27, v23, v26);
      default:
        return MutableCopy;
    }
  }
}

char *Security::CFMake::makestring(Security::CFMake *this)
{
  uint64_t v2 = *(char **)this;
  if (**(unsigned char **)this == 39)
  {
    *(void *)this = ++v2;
    uint64_t result = strchr(v2, 39);
    if (!result) {
      return result;
    }
    uint64_t v4 = result + 1;
  }
  else
  {
    uint64_t v5 = MEMORY[0x1E4F14390];
    uint64_t v4 = *(char **)this;
    do
    {
      while (1)
      {
        unsigned int v7 = *++v4;
        unsigned int v6 = v7;
        if ((v7 & 0x80000000) != 0) {
          break;
        }
        if ((*(_DWORD *)(v5 + 4 * v6 + 60) & 0x500) == 0) {
          goto LABEL_9;
        }
      }
    }
    while (__maskrune(v6, 0x500uLL));
LABEL_9:
    uint64_t result = v4;
  }
  *(void *)this = v4;
  CFIndex v8 = result - v2;
  CFAllocatorRef v9 = (const __CFAllocator *)*((void *)this + 2);

  return (char *)CFStringCreateWithBytes(v9, (const UInt8 *)v2, v8, 0x8000100u, 0);
}

__CFDictionary *Security::CFMake::add(Security::CFMake *this, __CFDictionary *a2)
{
  while (Security::CFMunge::next(this) != 125)
  {
    uint64_t v4 = Security::CFMake::make(this);
    if (!v4) {
      return 0;
    }
    uint64_t v5 = (const void *)v4;
    if (Security::CFMunge::next(this) != 61
      || (++*(void *)this, (unsigned int v6 = (const void *)Security::CFMake::make(this)) == 0))
    {
      CFRelease(v5);
      return 0;
    }
    unsigned int v7 = v6;
    CFDictionaryAddValue(a2, v5, v6);
    CFRelease(v5);
    CFRelease(v7);
  }
  ++*(void *)this;
  return a2;
}

uint64_t Security::CFScan::scan(Security::CFScan *this, const __CFString *a2)
{
  while (Security::CFMunge::next(this) == 64)
  {
    uint64_t v4 = (*(void *)this)++;
    int v5 = *(char *)(v4 + 1);
    if (v5 == 69)
    {
      *(void *)this = v4 + 2;
      CFIndex v8 = (_DWORD **)*((void *)this + 1);
      CFAllocatorRef v9 = *v8;
      *v8 += 2;
      *((_DWORD *)this + 6) = *v9;
    }
    else if (v5 == 65)
    {
      *(void *)this = v4 + 2;
      unsigned int v6 = (void **)*((void *)this + 1);
      unsigned int v7 = (*v6)++;
      *((void *)this + 2) = *v7;
    }
  }
  int v10 = Security::CFMunge::next(this);
  if (v10 <= 90)
  {
    if (!v10) {
      return 1;
    }
    if (v10 != 37)
    {
      if (v10 != 61) {
        return 0;
      }
      ++*(void *)this;
      CFDataRef v11 = Security::CFMake::make(this);
      BOOL v12 = CFEqual(a2, v11) != 0;
      CFRelease(v11);
      return v12;
    }
    BOOL v12 = 0;
    uint64_t v19 = (*(void *)this)++;
    int v20 = *(char *)(v19 + 1);
    if (v20 <= 82)
    {
      if (v20 <= 67)
      {
        if (v20 != 65)
        {
          if (v20 != 66) {
            return v12;
          }
          CFTypeID TypeID = CFBooleanGetTypeID();
          int v27 = Security::CFScan::typescan(this, a2, TypeID);
          BOOL v12 = v27 == 1;
          if (v27) {
            return v12;
          }
          if (**(unsigned char **)this == 102)
          {
            unint64_t v28 = (int **)*((void *)this + 1);
            unsigned int v29 = *v28;
            *v28 += 2;
            int v30 = *v29;
            CFAllocatorRef v31 = (_DWORD ***)*((void *)this + 1);
            CFNumberType v32 = (*v31)++;
            if ((const __CFString *)*MEMORY[0x1E4F1CFD0] != a2 || *((unsigned char *)this + 28)) {
              return 1;
            }
            int64_t v33 = *v32;
            int v34 = *v33 | v30;
          }
          else
          {
            if (*((unsigned char *)this + 28)) {
              return 1;
            }
            int v34 = *MEMORY[0x1E4F1CFD0] == (void)a2;
            unsigned int v43 = (int ***)*((void *)this + 1);
            long long v44 = (*v43)++;
            int64_t v33 = *v44;
          }
          *int64_t v33 = v34;
          return 1;
        }
        CFTypeID v35 = CFArrayGetTypeID();
      }
      else
      {
        switch(v20)
        {
          case 'D':
            CFTypeID v35 = CFDictionaryGetTypeID();
            break;
          case 'N':
            CFTypeID v35 = CFNumberGetTypeID();
            break;
          case 'O':
            if (!*((unsigned char *)this + 28))
            {
              char v21 = (void ***)*((void *)this + 1);
              CFStringRef v22 = (const __CFString ***)(*v21)++;
              **CFStringRef v22 = a2;
            }
            return 1;
          default:
            return v12;
        }
      }
      return Security::CFScan::typescan(this, a2, v35) == 1;
    }
    if (v20 <= 99)
    {
      if (v20 != 83)
      {
        if (v20 != 88) {
          return v12;
        }
        CFTypeID v35 = CFDataGetTypeID();
        return Security::CFScan::typescan(this, a2, v35) == 1;
      }
    }
    else
    {
      if (v20 == 100)
      {
        *(void *)this = v19 + 2;
        if (!a2) {
          return 1;
        }
        CFTypeID v40 = CFGetTypeID(a2);
        if (v40 != CFNumberGetTypeID()) {
          return 0;
        }
        int v24 = Security::cfNumber<int>((const __CFNumber *)a2);
        goto LABEL_63;
      }
      if (v20 != 115)
      {
        if (v20 != 117) {
          return v12;
        }
        *(void *)this = v19 + 2;
        if (!a2) {
          return 1;
        }
        CFTypeID v23 = CFGetTypeID(a2);
        if (v23 != CFNumberGetTypeID()) {
          return 0;
        }
        int v24 = Security::cfNumber<unsigned int>((const __CFNumber *)a2);
LABEL_63:
        if (!*((unsigned char *)this + 28))
        {
          long long v41 = (_DWORD ***)*((void *)this + 1);
          long long v42 = (*v41)++;
          *const void *v42 = v24;
        }
        return 1;
      }
    }
    CFTypeID v36 = CFStringGetTypeID();
    int v37 = Security::CFScan::typescan(this, a2, v36);
    BOOL v12 = v37 == 1;
    if (v37) {
      return v12;
    }
    Security::cfString(&__str, a2);
    if (!*((unsigned char *)this + 28))
    {
      long long v38 = (std::string ***)*((void *)this + 1);
      long long v39 = (*v38)++;
      std::string::operator=(*v39, &__str);
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    return 1;
  }
  if (v10 <= 122)
  {
    if (v10 != 91) {
      return 0;
    }
    if (!a2)
    {
      uint64_t v17 = this;
      CFArrayRef v18 = 0;
      goto LABEL_40;
    }
    CFTypeID v16 = CFGetTypeID(a2);
    if (v16 == CFArrayGetTypeID())
    {
      uint64_t v17 = this;
      CFArrayRef v18 = (const __CFArray *)a2;
LABEL_40:
      return Security::CFScan::scanarray(v17, v18);
    }
    return 0;
  }
  if (v10 != 123) {
    return 0;
  }
  if (a2)
  {
    CFTypeID v13 = CFGetTypeID(a2);
    if (v13 != CFDictionaryGetTypeID()) {
      return 0;
    }
    uint64_t v14 = this;
    CFDictionaryRef v15 = (const __CFDictionary *)a2;
  }
  else
  {
    uint64_t v14 = this;
    CFDictionaryRef v15 = 0;
  }

  return (uint64_t)Security::CFScan::scandictionary(v14, v15);
}

void sub_18B3D54AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFDataRef Security::CFScan::scandictionary(Security::CFScan *this, const __CFDictionary *a2)
{
  ++*(void *)this;
  while (1)
  {
    BOOL v4 = Security::CFMunge::next(this) == 125;
    CFDataRef result = (CFDataRef)v4;
    if (v4) {
      break;
    }
    int v6 = Security::CFMunge::next(this);
    if (v6 == 63) {
      ++*(void *)this;
    }
    CFDataRef result = Security::CFMake::make(this);
    if (!result) {
      break;
    }
    CFDataRef v7 = result;
    char v8 = *((unsigned char *)this + 28);
    if (a2) {
      CFStringRef Value = CFDictionaryGetValue(a2, result);
    }
    else {
      CFStringRef Value = 0;
    }
    if (v6 != 63 && !Value
      || (*((unsigned char *)this + 28) |= Value == 0, Security::CFMunge::next(this) != 61)
      || (++*(void *)this, (Security::CFScan::scan(this, Value) & 1) == 0))
    {
      CFRelease(v7);
      return 0;
    }
    *((unsigned char *)this + 28) = v8;
    CFRelease(v7);
  }
  return result;
}

uint64_t Security::CFScan::scanarray(Security::CFScan *this, CFArrayRef theArray)
{
  ++*(void *)this;
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
    char v10 = 0;
  }
  else
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0;
    BOOL v7 = 1;
    while (1)
    {
      if (Security::CFMunge::next(this) == 93)
      {
        char v9 = 1;
        goto LABEL_10;
      }
      CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v6);
      if ((Security::CFScan::scan(this, ValueAtIndex) & 1) == 0) {
        break;
      }
      BOOL v7 = v5 > ++v6;
      if (v5 == v6) {
        goto LABEL_10;
      }
    }
    char v9 = 0;
LABEL_10:
    char v10 = v7 & v9;
  }
  return v10 & 1;
}

uint64_t Security::CFScan::typescan(Security::CFScan *this, CFTypeRef cf, uint64_t a3)
{
  if (cf && CFGetTypeID(cf) != a3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = (*(void *)this)++;
  int v6 = *(char *)(v5 + 1);
  if (v6 == 110)
  {
    *(void *)this = v5 + 2;
    return 1;
  }
  if (v6 == 79)
  {
    *(void *)this = v5 + 2;
    if (!*((unsigned char *)this + 28))
    {
      BOOL v7 = (void ***)*((void *)this + 1);
      char v8 = (*v7)++;
      **char v8 = cf;
    }
    return 1;
  }
  return 0;
}

uint64_t Security::cfNumber<unsigned int>(const __CFNumber *a1)
{
  unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
  CFStringRef Value = (Security::CFError *)CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr);
  if (!Value) {
    Security::CFError::throwMe(Value);
  }
  return valuePtr;
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

uint64_t Security::cfNumber<int>(const __CFNumber *a1)
{
  unsigned int valuePtr = -1431655766;
  CFStringRef Value = (Security::CFError *)CFNumberGetValue(a1, kCFNumberIntType, &valuePtr);
  if (!Value) {
    Security::CFError::throwMe(Value);
  }
  return valuePtr;
}

__CFDictionary *Security::cfadd(Security *this, __CFDictionary *a2, const char *a3, ...)
{
  va_start(va, a3);
  va_copy(v7, va);
  v5[0] = a2;
  v5[1] = &v7;
  _DWORD v5[2] = 0;
  int v6 = 0;
  CFDataRef result = (__CFDictionary *)Security::CFMunge::next((Security::CFMunge *)v5);
  if (result == 123)
  {
    ++v5[0];
    return Security::CFMake::add((Security::CFMake *)v5, this);
  }
  return result;
}

uint64_t Security::cfscan(const __CFString *this, const void *a2, const char *a3, ...)
{
  va_start(va, a3);
  va_copy(v4, va);
  v5[0] = a2;
  v5[1] = &v4;
  _DWORD v5[2] = 0;
  int v6 = 0;
  char v7 = 0;
  return Security::CFScan::scan((Security::CFScan *)v5, this);
}

uint64_t Security::SecCFObject::copyDebugDesc(Security::SecCFObject *this)
{
  return 0;
}

uint64_t Security::SecCFObject::copyFormattingDesc(Security::SecCFObject *this, const __CFDictionary *a2)
{
  return 0;
}

BOOL Security::SecCFObject::equal(Security::SecCFObject *this, Security::SecCFObject *a2)
{
  return this == a2;
}

void Security::SecPointerBase::assign(Security::SecPointerBase *this, atomic_uchar *a2)
{
  if (a2 && (atomic_exchange(a2 - 8, 1u) & 1) != 0)
  {
    va_list v4 = (const void *)(*(uint64_t (**)(atomic_uchar *))(*(void *)a2 + 16))(a2);
    CFRetain(v4);
  }
  if (*(void *)this)
  {
    uint64_t v5 = (const void *)(*(uint64_t (**)(void))(**(void **)this + 16))(*(void *)this);
    CFRelease(v5);
  }
  *(void *)this = a2;
}

void DYLDCache::~DYLDCache(DYLDCache *this)
{
  DYLDCache::~DYLDCache(this);

  JUMPOUT(0x18C12D390);
}

{
  *(void *)this = &unk_1ED849758;
  munmap(*((void **)this + 2), *((void *)this + 3));
  Security::UnixPlusPlus::FileDesc::closeAndLog((DYLDCache *)((char *)this + 8));
}

const char *DYLDCache::matchArchitecture(char *__s1)
{
  uint64_t v2 = "\a";
  while (1)
  {
    int v3 = strcmp(__s1, v2 + 8);
    if (!v3) {
      break;
    }
    int v4 = *((_DWORD *)v2 + 9);
    v2 += 36;
    if (!v4)
    {
      uint64_t v2 = (const char *)&unk_18B41BFA8;
      break;
    }
  }
  if (*(void *)__s1 == 0x2031765F646C7964) {
    uint64_t v5 = &DYLDCache::defaultArchitecture;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v3) {
    return (const char *)v5;
  }
  else {
    return v2;
  }
}

void Security::Syslog::warning(Security::Syslog *this, const char *a2, ...)
{
  va_start(va, a2);
  vsyslog(4, (const char *)this, va);
}

void Security::Syslog::notice(Security::Syslog *this, const char *a2, ...)
{
  va_start(va, a2);
  vsyslog(5, (const char *)this, va);
}

Security::UnixError *Security::Mutex::lock(pthread_mutex_t *this)
{
  CFDataRef result = (Security::UnixError *)pthread_mutex_lock(this);
  if (result) {
    Security::UnixError::throwMe(result);
  }
  return result;
}

uint64_t Security::cfarrayApplyBlock_func(Security *this, uint64_t (**a2)(void, void), const void *a3)
{
  return ((uint64_t (**)(void, Security *))a2)[2](a2, this);
}

void Security::cfString(std::string *this, CFStringRef theString)
{
  if (!theString)
  {
    uint64_t v5 = (char *)&unk_18B41CA07;
    goto LABEL_5;
  }
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  if (CStringPtr)
  {
    uint64_t v5 = (char *)CStringPtr;
LABEL_5:
    std::string::basic_string[abi:ne180100]<0>(this, v5);
    return;
  }
  this->__r_.__value_.__r.__words[0] = 0;
  this->__r_.__value_.__l.__size_ = 0;
  this->__r_.__value_.__r.__words[2] = 0;
  CFIndex Length = CFStringGetLength(theString);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  if (MaximumSizeForEncoding <= -2) {
    std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
  }
  size_t v8 = MaximumSizeForEncoding + 1;
  char v9 = operator new(MaximumSizeForEncoding + 1);
  bzero(v9, v8);
  if (CFStringGetCString(theString, (char *)v9, v8, 0x8000100u)) {
    std::string::__assign_external(this, (const std::string::value_type *)v9);
  }

  operator delete(v9);
}

void sub_18B3D5BDC(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(a1);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  std::string::size_type v4 = strlen(__s);

  return std::string::__assign_external(this, __s, v4);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    unint64_t v10 = this->__r_.__value_.__r.__words[2];
    unint64_t v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      std::string::size_type size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    unint64_t v6 = HIBYTE(v10);
    char v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    char v7 = this;
    if (__n > 0x16)
    {
      std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      unint64_t v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0, size, __n, __s);
      return this;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((unsigned char *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0) {
    this->__r_.__value_.__l.__size_ = __n;
  }
  else {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  }
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

void Security::cfString(std::string *this, __CFString *cf)
{
  if (!cf) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA13);
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFStringGetTypeID())
  {
    Security::cfString(this, cf);
  }
  else if (v4 == CFURLGetTypeID())
  {
    Security::cfString((Security *)this, (const __CFURL *)cf);
  }
  else if (v4 == CFBundleGetTypeID())
  {
    CFURLRef v5 = CFBundleCopyBundleURL((CFBundleRef)cf);
    Security::cfStringRelease((Security *)this, v5);
  }
  else
  {
    CFStringRef v6 = CFCopyDescription(cf);
    Security::cfString(this, v6);
    Security::CFRef<__CFString const*>::~CFRef((const void **)&v6);
  }
}

void sub_18B3D5E34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Security::CFRef<__CFString const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

CFArrayRef Security::makeCFArray(Security *this, const void *a2, ...)
{
  va_start(va, a2);
  va_copy((va_list)&v3[1], va);
  v3[0] = a2;
  return CFArrayCreate(0, v3, 1, MEMORY[0x1E4F1D510]);
}

uint64_t Security::mmapPreferredSize(Security *this, uint64_t a2, unint64_t a3, void *a4)
{
  return (uint64_t)this + 8;
}

uint64_t Security::mmapDeallocatorAllocate(Security *this, uint64_t a2, unint64_t a3, void *a4)
{
  return 0;
}

void Security::Dispatch::Group::~Group(Security::Dispatch::Group *this)
{
  Security::Dispatch::Group::~Group(this);

  JUMPOUT(0x18C12D390);
}

{
  *(void *)this = &unk_1ED84AB50;
  dispatch_group_wait(*((dispatch_group_t *)this + 11), 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(*((dispatch_object_t *)this + 11));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)this + 10);
  Security::Mutex::~Mutex((pthread_mutex_t *)((char *)this + 8));
}

void Security::Dispatch::Semaphore::~Semaphore(dispatch_object_t *this)
{
  *this = (dispatch_object_t)&unk_1ED84AB90;
  dispatch_release(this[1]);

  JUMPOUT(0x18C12D390);
}

{
  *this = (dispatch_object_t)&unk_1ED84AB90;
  dispatch_release(this[1]);
}

void Security::Dispatch::SemaphoreWait::~SemaphoreWait(Security::Dispatch::SemaphoreWait *this)
{
  *(void *)this = &unk_1ED84AB30;
  if (*((unsigned char *)this + 16)) {
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*((void *)this + 1) + 8));
  }

  JUMPOUT(0x18C12D390);
}

{
  *(void *)this = &unk_1ED84AB30;
  if (*((unsigned char *)this + 16)) {
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*((void *)this + 1) + 8));
  }
}

uint64_t ___ZN8Security8Dispatch23ExceptionAwareEnqueuing21enqueueWithDispatcherEU13block_pointerFvU13block_pointerFvvEES3__block_invoke(uint64_t result)
{
  if (!*(unsigned char *)(*(void *)(result + 40) + 64)) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void sub_18B3D6138(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10, uint64_t a11, uint64_t a12)
{
  __cxa_begin_catch(a1);
  a11 = v12;
  a12 = 0xAAAAAAAAAAAAAA01;
  Security::Mutex::lock((pthread_mutex_t *)v12);
  *(unsigned char *)(v12 + 64) = 1;
  std::current_exception();
  std::exception_ptr::operator=((std::exception_ptr *)(v12 + 72), &a10);
  std::exception_ptr::~exception_ptr(&a10);
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&a11);
  __cxa_end_catch();
  JUMPOUT(0x18B3D6128);
}

void sub_18B3D6184(_Unwind_Exception *a1)
{
}

void ___ZN8Security8Dispatch5Group7enqueueEP16dispatch_queue_sU13block_pointerFvvE_block_invoke(uint64_t a1, dispatch_block_t block)
{
}

void Security::Dispatch::Group::wait(Security::Dispatch::Group *this)
{
  dispatch_group_wait(*((dispatch_group_t *)this + 11), 0xFFFFFFFFFFFFFFFFLL);
  if (*((unsigned char *)this + 72))
  {
    *((unsigned char *)this + 72) = 0;
    std::exception_ptr::exception_ptr(&v3, (const std::exception_ptr *)this + 10);
    v2.__ptr_ = &v3;
    std::rethrow_exception(v2);
    __break(1u);
  }
}

void sub_18B3D6200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
}

_DWORD *Security::BlobWrapper::alloc(Security::BlobWrapper *this, unint64_t a2)
{
  if (a2 > 0xFFFFFFFFFFFFFFF7) {
    return 0;
  }
  unsigned int v4 = a2 + 8;
  CFURLRef v5 = malloc_type_malloc(a2 + 8, 0x154CD2DFuLL);
  std::exception_ptr v2 = v5;
  if (v5)
  {
    *CFURLRef v5 = 17555194;
    v5[1] = bswap32(v4);
    memcpy(v5 + 2, this, v4 - 8);
  }
  return v2;
}

uint64_t Security::UnixError::unixError(Security::UnixError *this)
{
  return *((unsigned int *)this + 36);
}

uint64_t Security::UnixError::osStatus(Security::UnixError *this)
{
  return (*((_DWORD *)this + 36) + 100000);
}

uint64_t Security::UnixError::what(Security::UnixError *this)
{
  return (uint64_t)this + 8;
}

void Security::UnixError::~UnixError(std::exception *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x18C12D390);
}

uint64_t Security::MacOSError::unixError(Security::MacOSError *this)
{
  unsigned int v1 = *((_DWORD *)this + 36) - 100000;
  if (v1 >= 0x100) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v1;
  }
}

uint64_t Security::MacOSError::osStatus(Security::MacOSError *this)
{
  return *((unsigned int *)this + 36);
}

uint64_t Security::MacOSError::what(Security::MacOSError *this)
{
  return (uint64_t)this + 8;
}

void Security::MacOSError::~MacOSError(std::exception *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x18C12D390);
}

uint64_t Security::CFError::unixError(Security::CFError *this)
{
  return 14;
}

uint64_t Security::CFError::osStatus(Security::CFError *this)
{
  return 4294962336;
}

const char *Security::CFError::what(Security::CFError *this)
{
  return "CoreFoundation error";
}

void Security::CFError::~CFError(std::exception *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x18C12D390);
}

uint64_t Security::ModuleNexusError::unixError(Security::ModuleNexusError *this)
{
  return 22;
}

uint64_t Security::ModuleNexusError::osStatus(Security::ModuleNexusError *this)
{
  return 4294967246;
}

void Security::ModuleNexusError::~ModuleNexusError(std::exception *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x18C12D390);
}

void Security::CommonError::LogBacktrace(Security::CommonError *this)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = secLogObjForScope("security_exception");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v35 = v2;
    long long v36 = v2;
    long long v33 = v2;
    long long v34 = v2;
    long long v31 = v2;
    long long v32 = v2;
    long long v29 = v2;
    long long v30 = v2;
    long long v27 = v2;
    long long v28 = v2;
    long long v25 = v2;
    long long v26 = v2;
    long long v23 = v2;
    long long v24 = v2;
    *(_OWORD *)char v21 = v2;
    long long v22 = v2;
    int v3 = backtrace(v21, 32);
    unsigned int v4 = backtrace_symbols(v21, v3);
    CFURLRef v5 = v4;
    memset(&v18, 0, sizeof(v18));
    if (v3 < 1)
    {
      free(v4);
    }
    else
    {
      for (uint64_t i = 0; i != v3; ++i)
      {
        if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
        {
          v18.__r_.__value_.__l.__size_ = 0;
          char v7 = (std::string *)v18.__r_.__value_.__r.__words[0];
        }
        else
        {
          *((unsigned char *)&v18.__r_.__value_.__s + 23) = 0;
          char v7 = &v18;
        }
        v7->__r_.__value_.__s.__data_[0] = 0;
        __stringp = v5[i];
        while (1)
        {
          size_t v8 = strsep(&__stringp, " ");
          unint64_t v9 = v8;
          if (!v8) {
            break;
          }
          if (*v8)
          {
            int status = 0;
            unint64_t v10 = __cxa_demangle(v8, 0, 0, &status);
            CFDataRef v11 = v10;
            if (status)
            {
              std::string::size_type v12 = strlen(v9);
              std::string::append(&v18, v9, v12);
            }
            else
            {
              std::string::size_type v13 = strlen(v10);
              std::string::append(&v18, v11, v13);
            }
            std::string::append(&v18, " ", 1uLL);
            if (v11) {
              free(v11);
            }
          }
          else
          {
            std::string::append(&v18, " ", 1uLL);
          }
        }
        uint64_t v14 = secLogObjForScope("security_exception");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            CFDictionaryRef v15 = &v18;
          }
          else {
            CFDictionaryRef v15 = (std::string *)v18.__r_.__value_.__r.__words[0];
          }
          int status = 136315138;
          int v20 = v15;
          _os_log_debug_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEBUG, "%s", (uint8_t *)&status, 0xCu);
        }
      }
      int v16 = SHIBYTE(v18.__r_.__value_.__r.__words[2]);
      free(v5);
      if (v16 < 0) {
        operator delete(v18.__r_.__value_.__l.__data_);
      }
    }
  }
}

void sub_18B3D6660(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
}

Security::UnixError *Security::UnixError::UnixError(Security::UnixError *this, int a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)((char *)this + 72) = xmmword_18B41C0F6;
  *(_OWORD *)((char *)this + 88) = unk_18B41C106;
  *(_OWORD *)((char *)this + 104) = xmmword_18B41C116;
  *(_OWORD *)((char *)this + 120) = unk_18B41C126;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)"CommonError";
  *(_OWORD *)((char *)this + 24) = unk_18B41C0C6;
  *(_OWORD *)((char *)this + 40) = xmmword_18B41C0D6;
  *(_OWORD *)((char *)this + 56) = unk_18B41C0E6;
  *((void *)this + 17) = 128;
  *(void *)this = &unk_1ED84ABB0;
  *((_DWORD *)this + 36) = a2;
  snprintf((char *)this + 8, *((void *)this + 17), "UNIX error exception: %d", *((_DWORD *)this + 36));
  int v3 = secLogObjForScope("security_exception");
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    uint64_t v5 = (*(uint64_t (**)(Security::UnixError *))(*(void *)this + 16))(this);
    *(_DWORD *)long long buf = 136315138;
    uint64_t v8 = v5;
    _os_log_impl(&dword_18B299000, v3, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
  }
  Security::CommonError::LogBacktrace((Security::CommonError *)v4);
  return this;
}

void sub_18B3D67DC(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void Security::UnixError::throwMe(Security::UnixError *this)
{
  int v1 = (int)this;
  exception = (Security::UnixError *)__cxa_allocate_exception(0x98uLL);
  Security::UnixError::UnixError(exception, v1);
}

void sub_18B3D6838(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

Security::MacOSError *Security::MacOSError::MacOSError(Security::MacOSError *this, int a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)((char *)this + 72) = xmmword_18B41C0F6;
  *(_OWORD *)((char *)this + 88) = unk_18B41C106;
  *(_OWORD *)((char *)this + 104) = xmmword_18B41C116;
  *(_OWORD *)((char *)this + 120) = unk_18B41C126;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)"CommonError";
  *(_OWORD *)((char *)this + 24) = unk_18B41C0C6;
  *(_OWORD *)((char *)this + 40) = xmmword_18B41C0D6;
  *(_OWORD *)((char *)this + 56) = unk_18B41C0E6;
  *((void *)this + 17) = 128;
  *(void *)this = &unk_1ED849AA0;
  *((_DWORD *)this + 36) = a2;
  snprintf((char *)this + 8, *((void *)this + 17), "MacOS error: %d", *((_DWORD *)this + 36));
  if (a2 != -67050)
  {
    BOOL v4 = secLogObjForScope("security_exception");
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      uint64_t v6 = (*(uint64_t (**)(Security::MacOSError *))(*(void *)this + 16))(this);
      *(_DWORD *)long long buf = 136315138;
      uint64_t v9 = v6;
      _os_log_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
    }
    Security::CommonError::LogBacktrace((Security::CommonError *)v5);
  }
  return this;
}

void sub_18B3D69B4(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void Security::MacOSError::throwMe(Security::MacOSError *this, uint64_t a2, const char *a3, ...)
{
  int v3 = (int)this;
  exception = (Security::MacOSError *)__cxa_allocate_exception(0x98uLL);
  Security::MacOSError::MacOSError(exception, v3);
}

void sub_18B3D6A14(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

Security::CFError *Security::CFError::CFError(Security::CFError *this)
{
  *(_OWORD *)((char *)this + 72) = xmmword_18B41C0F6;
  *(_OWORD *)((char *)this + 88) = unk_18B41C106;
  *(_OWORD *)((char *)this + 104) = xmmword_18B41C116;
  *(_OWORD *)((char *)this + 120) = unk_18B41C126;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)"CommonError";
  *(_OWORD *)((char *)this + 24) = unk_18B41C0C6;
  *(_OWORD *)((char *)this + 40) = xmmword_18B41C0D6;
  *(_OWORD *)((char *)this + 56) = unk_18B41C0E6;
  *((void *)this + 17) = 128;
  *(void *)this = &unk_1ED84AAF8;
  long long v2 = secLogObjForScope("security_exception");
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    *(_WORD *)BOOL v5 = 0;
    _os_log_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEFAULT, "CFError", v5, 2u);
  }
  Security::CommonError::LogBacktrace((Security::CommonError *)v3);
  return this;
}

void sub_18B3D6AFC(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void Security::CFError::throwMe(Security::CFError *this)
{
  exception = (Security::CFError *)__cxa_allocate_exception(0x90uLL);
  Security::CFError::CFError(exception);
}

void sub_18B3D6B50(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void Security::ModuleNexusError::throwMe(Security::ModuleNexusError *this)
{
  exception = (char *)__cxa_allocate_exception(0x90uLL);
  *(_OWORD *)(exception + 72) = xmmword_18B41C0F6;
  *(_OWORD *)(exception + 88) = unk_18B41C106;
  *(_OWORD *)(exception + 104) = xmmword_18B41C116;
  *(_OWORD *)(exception + 120) = unk_18B41C126;
  *(_OWORD *)(exception + 8) = *(_OWORD *)"CommonError";
  *(_OWORD *)(exception + 24) = unk_18B41C0C6;
  *(_OWORD *)(exception + 40) = xmmword_18B41C0D6;
  *(_OWORD *)(exception + 56) = unk_18B41C0E6;
  *((void *)exception + 17) = 128;
  *(void *)exception = &unk_1ED84AA60;
}

void Security::UnixPlusPlus::FileDesc::close(Security::UnixPlusPlus::FileDesc *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  int v2 = *(_DWORD *)this;
  if ((v2 & 0x80000000) == 0)
  {
    if (close(v2) == -1)
    {
      BOOL v5 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v5);
    }
    BOOL v3 = secLogObjForScope("unixio");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      int v4 = *(_DWORD *)this;
      v6[0] = 67109120;
      v6[1] = v4;
      _os_log_debug_impl(&dword_18B299000, v3, OS_LOG_TYPE_DEBUG, "close(%d)", (uint8_t *)v6, 8u);
    }
    *(_DWORD *)this = -1;
  }
}

void *std::string::basic_string[abi:ne180100](void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    uint64_t v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

ssize_t Security::UnixPlusPlus::FileDesc::writeAll(ssize_t this, char *__buf, size_t __nbyte)
{
  if (__nbyte)
  {
    size_t v3 = __nbyte;
    BOOL v5 = (int *)this;
    do
    {
      this = write(*v5, __buf, v3);
      if (this == -1)
      {
        if (*__error() != 35)
        {
          uint64_t v6 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v6);
        }
        this = 0;
      }
      __buf += this;
      v3 -= this;
    }
    while (v3);
  }
  return this;
}

off_t Security::UnixPlusPlus::FileDesc::seek(Security::UnixPlusPlus::FileDesc *this, off_t a2)
{
  off_t result = lseek((int)this, a2, 0);
  if (result == -1)
  {
    size_t v3 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v3);
  }
  return result;
}

float Security::UnixPlusPlus::FileDesc::fcntl(Security::UnixPlusPlus::FileDesc *this, int a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v4 = fcntl(*(_DWORD *)this, 48, a3, 1);
  BOOL v5 = secLogObjForScope("unixio");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    int v7 = *(_DWORD *)this;
    *(_DWORD *)long long buf = 67109888;
    int v10 = v7;
    __int16 v11 = 1024;
    int v12 = 48;
    __int16 v13 = 2048;
    uint64_t v14 = 1;
    __int16 v15 = 1024;
    int v16 = v4;
    _os_log_debug_impl(&dword_18B299000, v5, OS_LOG_TYPE_DEBUG, "%d fcntl(%d,%p) = %d", buf, 0x1Eu);
  }
  if (v4 == -1)
  {
    size_t v8 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v8);
  }
  return result;
}

int *Security::UnixPlusPlus::FileDesc::removeAttr(Security::UnixPlusPlus::FileDesc *this, const char *a2)
{
  float result = (int *)fremovexattr((int)this, a2, 0);
  if (result)
  {
    float result = __error();
    if (*result != 93)
    {
      size_t v3 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v3);
    }
  }
  return result;
}

ssize_t Security::UnixPlusPlus::FileDesc::listAttr(Security::UnixPlusPlus::FileDesc *this, char *a2, size_t a3)
{
  ssize_t result = flistxattr((int)this, a2, a3, 0);
  if (result == -1)
  {
    int v4 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v4);
  }
  return result;
}

const void **Security::UnixPlusPlus::FileDesc::mediumType(std::string *this, Security::UnixPlusPlus::FileDesc *a2)
{
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v19.st_blkstd::string::size_type size = v3;
  *(timespec *)v19.st_qspare = v3;
  v19.st_birthtimespeCC_SHA512_CTX c = v3;
  *(timespec *)&v19.st_std::string::size_type size = v3;
  v19.st_mtimespeCC_SHA512_CTX c = v3;
  v19.st_ctimespeCC_SHA512_CTX c = v3;
  *(timespec *)&v19.st_uid = v3;
  v19.st_atimespeCC_SHA512_CTX c = v3;
  *(timespec *)&v19.st_dev = v3;
  Security::UnixPlusPlus::FileDesc::fstat(a2, &v19);
  CFDictionaryRef matching = (CFDictionaryRef)0xAAAAAAAAAAAAAAAALL;
  Security::CFTemp<__CFDictionary const*>::CFTemp((CFTypeRef *)&matching, (uint64_t)"{%s=%d,%s=%d}", v4, v5, v6, v7, v8, v9, (uint64_t)"BSD Major");
  mach_port_t v10 = *MEMORY[0x1E4F2EEF0];
  CFDictionaryRef v11 = matching;
  CFDictionaryRef matching = 0;
  io_service_t MatchingService = IOServiceGetMatchingService(v10, v11);
  io_object_t v13 = MatchingService;
  if (!MatchingService)
  {
    Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&matching);
    unint64_t v17 = 0;
LABEL_6:
    this->__r_.__value_.__r.__words[0] = 0;
    this->__r_.__value_.__l.__size_ = 0;
    this->__r_.__value_.__r.__words[2] = 0;
    return Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v17);
  }
  CFDictionaryRef v14 = (const __CFDictionary *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"Device Characteristics", 0, 3u);
  IOObjectRelease(v13);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&matching);
  unint64_t v17 = (unint64_t)v14;
  if (!v14) {
    goto LABEL_6;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v14, @"Medium Type");
  if (!Value) {
    goto LABEL_6;
  }
  Security::cfString(this, Value);
  return Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v17);
}

void sub_18B3D70B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

CFTypeRef *Security::CFTemp<__CFDictionary const*>::CFTemp(CFTypeRef *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *a1 = 0;
  int v12 = &a9;
  v13[0] = a2;
  v13[1] = &v12;
  void v13[2] = 0;
  int v14 = 0;
  CFDataRef v10 = Security::CFMake::make((Security::CFMake *)v13);
  if (*a1) {
    CFRelease(*a1);
  }
  *a1 = v10;
  return a1;
}

void sub_18B3D713C(_Unwind_Exception *a1)
{
  Security::CFRef<__CFDictionary const*>::~CFRef(v1);
  _Unwind_Resume(a1);
}

BOOL Security::Allocator::operator==(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

void *DefaultAllocator::realloc(DefaultAllocator *this, void *ptr, size_t size)
{
  ssize_t result = malloc_type_realloc(ptr, size, 0x70F28E8uLL);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    uint64_t v5 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v5, MEMORY[0x1E4FBA360], MEMORY[0x1E4FBA2C0]);
  }
  return result;
}

void DefaultAllocator::free(DefaultAllocator *this, void *a2)
{
}

void *DefaultAllocator::malloc(DefaultAllocator *this, size_t size)
{
  ssize_t result = malloc_type_malloc(size, 0x3885DBC7uLL);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    uint64_t v4 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v4, MEMORY[0x1E4FBA360], MEMORY[0x1E4FBA2C0]);
  }
  return result;
}

void DefaultAllocator::~DefaultAllocator(DefaultAllocator *this)
{
}

void *SensitiveAllocator::realloc(SensitiveAllocator *this, char *ptr, size_t a3)
{
  size_t v5 = malloc_size(ptr);
  if (v5 > a3) {
    size_t v5 = memset_s(&ptr[a3], v5 - a3, 0, v5 - a3);
  }

  return DefaultAllocator::realloc((DefaultAllocator *)v5, ptr, a3);
}

void SensitiveAllocator::free(SensitiveAllocator *this, void *ptr)
{
  size_t v3 = malloc_size(ptr);
  memset_s(ptr, v3, 0, v3);

  free(ptr);
}

void SensitiveAllocator::~SensitiveAllocator(SensitiveAllocator *this)
{
}

uint64_t Security::Allocator::standard(Security::Allocator *this)
{
  if (!defaultAllocators) {
    defaultAllocators = Security::ModuleNexusCommon::create((Security::ModuleNexusCommon *)&defaultAllocators, (void *(*)(void))Security::ModuleNexus<DefaultAllocators>::make);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1E9132F18);
  return defaultAllocators;
}

void sub_18B3D7350(void *a1)
{
}

void sub_18B3D7368(_Unwind_Exception *a1)
{
}

void Security::ModuleNexus<DefaultAllocators>::make()
{
}

uint64_t Security::CFClass::copyDebugDescType(Security::CFClass *this, const void *a2)
{
  if (this) {
    int v2 = (char *)this + 24;
  }
  else {
    int v2 = 0;
  }
  return (*(uint64_t (**)(char *, const void *))(*(void *)v2 + 48))(v2, a2);
}

void sub_18B3D7428(void *a1)
{
}

uint64_t Security::CFClass::copyFormattingDescType(Security::CFClass *this, const void *a2, const __CFDictionary *a3)
{
  if (this) {
    size_t v3 = (char *)this + 24;
  }
  else {
    size_t v3 = 0;
  }
  return (*(uint64_t (**)(char *, const void *, const __CFDictionary *))(*(void *)v3 + 40))(v3, a2, a3);
}

void sub_18B3D7484(void *a1)
{
}

uint64_t Security::CFClass::hashType(Security::CFClass *this, const void *a2)
{
  if (this) {
    int v2 = (char *)this + 24;
  }
  else {
    int v2 = 0;
  }
  return (*(uint64_t (**)(char *, const void *))(*(void *)v2 + 32))(v2, a2);
}

void sub_18B3D74E0(void *a1)
{
}

uint64_t Security::CFClass::equalType(Security::CFClass *this, char *a2, const void *a3)
{
  if (this) {
    size_t v3 = (char *)this + 24;
  }
  else {
    size_t v3 = 0;
  }
  if (a2) {
    uint64_t v4 = a2 + 24;
  }
  else {
    uint64_t v4 = 0;
  }
  return (*(uint64_t (**)(char *, char *, const void *))(*(void *)v3 + 24))(v3, v4, a3);
}

void sub_18B3D7544(void *a1)
{
}

uint64_t Security::Architecture::local(Security::Architecture *this)
{
  image_header = _dyld_get_image_header(0);
  int v12 = &unk_1ED849AD8;
  Security::MachOBase::initHeader((uint64_t)&v12, image_header);
  uint64_t v2 = 32;
  if (!v16) {
    uint64_t v2 = 28;
  }
  size_t v3 = (char *)image_header + v2;
  int v14 = (char *)image_header + v2;
  LODWORD(v4) = v13[5];
  unsigned int v5 = bswap32(v4);
  if (v17) {
    uint64_t v4 = v5;
  }
  else {
    uint64_t v4 = v4;
  }
  __int16 v15 = &v3[v4];
  if (v3 + 8 > &v3[v4]) {
    Security::UnixError::throwMe((Security::UnixError *)8);
  }
  unsigned int v7 = v13[1];
  LODWORD(v6) = v13[2];
  unsigned int v8 = bswap32(v7);
  if (v17) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = v7;
  }
  unsigned int v10 = bswap32(v6);
  if (v17) {
    uint64_t v6 = v10;
  }
  else {
    uint64_t v6 = v6;
  }
  return v9 | (v6 << 32);
}

void Security::MachOImage::~MachOImage(Security::MachOImage *this)
{
}

unint64_t Security::MachOBase::version(Security::MachOBase *this, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  Command = (const load_command *)*((void *)this + 2);
  if (Command)
  {
    do
    {
      clong long md = Command->cmd;
      int v10 = *((unsigned __int8 *)this + 33);
      unsigned int v11 = bswap32(Command->cmd);
      if (*((unsigned char *)this + 33)) {
        clong long md = v11;
      }
      if (cmd == 50)
      {
        cmdstd::string::size_type size = Command->cmdsize;
        unsigned int v18 = bswap32(cmdsize);
        if (*((unsigned char *)this + 33)) {
          cmdstd::string::size_type size = v18;
        }
        if (cmdsize <= 0x17) {
          goto LABEL_56;
        }
        if (a2)
        {
          unsigned int v19 = Command[1].cmd;
          unsigned int v20 = bswap32(v19);
          if (*((unsigned char *)this + 33)) {
            unsigned int v19 = v20;
          }
          *a2 = v19;
        }
        if (a3)
        {
          unsigned int v21 = Command[1].cmdsize;
          unsigned int v22 = bswap32(v21);
          if (v10) {
            unsigned int v21 = v22;
          }
          *a3 = v21;
        }
        if (a4)
        {
          unsigned int v23 = Command[2].cmd;
          goto LABEL_51;
        }
        return 1;
      }
      Command = (const load_command *)Security::MachOBase::nextCommand(this, Command);
    }
    while (Command);
    int v12 = (const load_command *)*((void *)this + 2);
    if (v12)
    {
      while (1)
      {
        int v13 = v12->cmd;
        int v10 = *((unsigned __int8 *)this + 33);
        unsigned int v14 = bswap32(v12->cmd);
        if (*((unsigned char *)this + 33)) {
          int v13 = v14;
        }
        if (v13 <= 0x30 && ((1 << v13) & 0x1803000000000) != 0) {
          break;
        }
        unint64_t result = Security::MachOBase::nextCommand(this, v12);
        int v12 = (const load_command *)result;
        if (!result) {
          return result;
        }
      }
      unsigned int v24 = v12->cmdsize;
      unsigned int v25 = bswap32(v24);
      if (*((unsigned char *)this + 33)) {
        unsigned int v24 = v25;
      }
      if (v24 > 0xF)
      {
        if (v13 > 46)
        {
          if (v13 == 47)
          {
            unsigned int v26 = 3;
          }
          else
          {
            if (v13 != 48) {
              goto LABEL_42;
            }
            unsigned int v26 = 4;
          }
        }
        else if (v13 == 36)
        {
          unsigned int v26 = 1;
        }
        else
        {
          if (v13 == 37)
          {
            unsigned int v26 = 2;
            goto LABEL_43;
          }
LABEL_42:
          unsigned int v26 = 0;
        }
LABEL_43:
        if (a2) {
          *a2 = v26;
        }
        if (a3)
        {
          unsigned int v27 = v12[1].cmd;
          unsigned int v28 = bswap32(v27);
          if (v10) {
            unsigned int v27 = v28;
          }
          *a3 = v27;
        }
        if (a4)
        {
          unsigned int v23 = v12[1].cmdsize;
LABEL_51:
          unsigned int v29 = bswap32(v23);
          if (v10) {
            unsigned int v30 = v29;
          }
          else {
            unsigned int v30 = v23;
          }
          *a4 = v30;
        }
        return 1;
      }
LABEL_56:
      Security::UnixError::throwMe((Security::UnixError *)8);
    }
  }
  return 0;
}

uint64_t Security::MachO::signingExtent(Security::MachO *this)
{
  CodeCFDataRef Signature = Security::MachOBase::findCodeSignature(this);
  if (!CodeSignature) {
    return *((void *)this + 7);
  }
  clong long md = CodeSignature[1].cmd;
  unsigned int v4 = bswap32(cmd);
  uint64_t result = *((unsigned char *)this + 33) ? v4 : cmd;
  if (!result) {
    return *((void *)this + 7);
  }
  return result;
}

uint64_t *std::list<fat_arch *>::__sort<BOOL({block_pointer})(fat_arch const*,fat_arch const*)>(uint64_t **a1, uint64_t **a2, unint64_t a3, uint64_t a4)
{
  unsigned int v4 = a1;
  if (a3 >= 2)
  {
    if (a3 == 2)
    {
      unsigned int v7 = *a2;
      if ((*(unsigned int (**)(void))(*(void *)a4 + 16))())
      {
        uint64_t v8 = *v7;
        *(void *)(v8 + 8) = v7[1];
        *(void *)v7[1] = v8;
        uint64_t v9 = *v4;
        v9[1] = (uint64_t)v7;
        uint64_t *v7 = (uint64_t)v9;
        *unsigned int v4 = v7;
        v7[1] = (uint64_t)v4;
        return v7;
      }
    }
    else
    {
      unint64_t v11 = a3 >> 1;
      unint64_t v12 = (a3 >> 1) + 1;
      int v13 = a1;
      do
      {
        int v13 = (uint64_t **)v13[1];
        --v12;
      }
      while (v12 > 1);
      unsigned int v14 = (uint64_t **)std::list<fat_arch *>::__sort<BOOL({block_pointer})(fat_arch const*,fat_arch const*)>(a1, v13, a3 >> 1, a4);
      unsigned int v4 = (uint64_t **)std::list<fat_arch *>::__sort<BOOL({block_pointer})(fat_arch const*,fat_arch const*)>(v13, a2, a3 - v11, a4);
      if ((*(unsigned int (**)(void))(*(void *)a4 + 16))())
      {
        for (uint64_t i = v4[1]; i != (uint64_t *)a2; uint64_t i = (uint64_t *)i[1])
        {
          if (!(*(unsigned int (**)(void))(*(void *)a4 + 16))()) {
            goto LABEL_14;
          }
        }
        uint64_t i = (uint64_t *)a2;
LABEL_14:
        uint64_t v17 = *i;
        unsigned int v18 = *v4;
        v18[1] = *(void *)(*i + 8);
        **(void **)(v17 + 8) = v18;
        unsigned int v19 = *v14;
        char v16 = v14[1];
        v19[1] = (uint64_t)v4;
        *unsigned int v4 = v19;
        *unsigned int v14 = (uint64_t *)v17;
        *(void *)(v17 + 8) = v14;
      }
      else
      {
        char v16 = v14[1];
        uint64_t i = (uint64_t *)v4;
        unsigned int v4 = v14;
      }
      if (v16 != i && i != (uint64_t *)a2)
      {
        unsigned int v20 = i;
        do
        {
          if ((*(unsigned int (**)(void))(*(void *)a4 + 16))())
          {
            for (CFIndex j = (uint64_t *)i[1]; j != (uint64_t *)a2; CFIndex j = (uint64_t *)j[1])
            {
              if (!(*(unsigned int (**)(void))(*(void *)a4 + 16))()) {
                goto LABEL_25;
              }
            }
            CFIndex j = (uint64_t *)a2;
LABEL_25:
            uint64_t v23 = *j;
            uint64_t v24 = *i;
            *(void *)(v24 + 8) = *(void *)(*j + 8);
            **(void **)(v23 + 8) = v24;
            if (v20 == i) {
              unsigned int v20 = j;
            }
            uint64_t v25 = *v16;
            unsigned int v22 = (uint64_t *)v16[1];
            *(void *)(v25 + 8) = i;
            uint64_t *i = v25;
            *char v16 = v23;
            *(void *)(v23 + 8) = v16;
            uint64_t i = j;
          }
          else
          {
            unsigned int v22 = (uint64_t *)v16[1];
          }
          BOOL v26 = v22 == v20 || i == (uint64_t *)a2;
          char v16 = v22;
        }
        while (!v26);
      }
    }
  }
  return (uint64_t *)v4;
}

void *std::__list_imp<fat_arch *>::clear(void *result)
{
  if (result[2])
  {
    int v1 = result;
    uint64_t result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        unsigned int v4 = (void *)result[1];
        operator delete(result);
        uint64_t result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

BOOL ___ZN8Security9UniversalC2ENS_12UnixPlusPlus8FileDescEmm_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_DWORD *)(a2 + 8) < *(_DWORD *)(a3 + 8);
}

unint64_t Security::Universal::bestNativeArch(Security::Universal *this)
{
  if (*((void *)this + 1))
  {
    uint64_t v2 = Security::Architecture::local(this);
    uint64_t v3 = NXFindBestFatArch(v2, HIDWORD(v2) & 0xFFFFFF, *((fat_arch **)this + 1), *((_DWORD *)this + 4));
    if (v3)
    {
      unsigned int cputype = v3->cputype;
      uint64_t cpusubtype = v3->cpusubtype;
    }
    else
    {
      uint64_t v6 = (unsigned int *)*((void *)this + 1);
      unsigned int cputype = *v6;
      uint64_t cpusubtype = v6[1];
    }
  }
  else
  {
    unsigned int cputype = *((_DWORD *)this + 5);
    uint64_t cpusubtype = *((unsigned int *)this + 6);
  }
  return cputype | (unint64_t)(cpusubtype << 32);
}

void Security::Universal::findImage(Security::Universal **this, const Security::Architecture *a2, int a3)
{
}

void sub_18B3D7C54(_Unwind_Exception *a1)
{
  MEMORY[0x18C12D390](v1, 0x10E1C40592D68B5);
  _Unwind_Resume(a1);
}

Security::Universal *Security::Universal::findArch(Security::Universal *this, const Security::Architecture *a2, int a3, int a4)
{
  if (!a2) {
LABEL_19:
  }
    Security::UnixError::throwMe((Security::UnixError *)8);
  unsigned int v4 = (Security::Universal *)((char *)this + 20 * a2);
  unsigned int v5 = this;
  while (*(_DWORD *)v5 != a3 || *((_DWORD *)v5 + 1) != a4)
  {
    unsigned int v5 = (Security::Universal *)((char *)v5 + 20);
    if (v5 >= v4)
    {
      unsigned int v5 = this;
      while (*(_DWORD *)v5 != a3 || ((*((_DWORD *)v5 + 1) ^ a4) & 0xFFFFFF) != 0)
      {
        unsigned int v5 = (Security::Universal *)((char *)v5 + 20);
        if (v5 >= v4)
        {
          unsigned int v5 = this;
          while (*(_DWORD *)v5 != a3 || (*((_DWORD *)v5 + 1) & 0xFFFFFF) != 0)
          {
            unsigned int v5 = (Security::Universal *)((char *)v5 + 20);
            if (v5 >= v4)
            {
              while (*(_DWORD *)this != a3)
              {
                this = (Security::Universal *)((char *)this + 20);
                if (this >= v4) {
                  goto LABEL_19;
                }
              }
              return this;
            }
          }
          return v5;
        }
      }
      return v5;
    }
  }
  return v5;
}

uint64_t Security::Universal::archOffset(Security::Universal *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (*((void *)this + 1))
  {
    unint64_t v3 = Security::Universal::bestNativeArch(this);
    v1 += *((unsigned int *)Security::Universal::findArch(*((Security::Universal **)this + 1), (const Security::Architecture *)*((unsigned int *)this + 4), v3, SHIDWORD(v3))+ 2);
  }
  return v1;
}

void Security::Universal::architecture(Security::Universal **this, const Security::Architecture *a2, int a3)
{
  if (this[1])
  {
    Security::Universal::findImage(this, a2, a3);
  }
  if (*((_DWORD *)this + 5) == a2 && (a3 == -1 || ((*((_DWORD *)this + 6) ^ a3) & 0xFFFFFF) == 0)) {
    operator new();
  }
  Security::UnixError::throwMe((Security::UnixError *)8);
}

void sub_18B3D7E7C(_Unwind_Exception *a1)
{
  MEMORY[0x18C12D390](v1, 0x10E1C40592D68B5);
  _Unwind_Resume(a1);
}

uint64_t Security::Universal::archOffset(Security::Universal *this, const Security::Architecture *a2, int a3)
{
  if (*((void *)this + 1))
  {
    uint64_t v3 = *((void *)this + 4);
    return v3
         + *((unsigned int *)Security::Universal::findArch(*((Security::Universal **)this + 1), (const Security::Architecture *)*((unsigned int *)this + 4), (int)a2, a3)+ 2);
  }
  else
  {
    if (*((_DWORD *)this + 5) != a2 || a3 != -1 && ((*((_DWORD *)this + 6) ^ a3) & 0xFFFFFF) != 0) {
      Security::UnixError::throwMe((Security::UnixError *)8);
    }
    return 0;
  }
}

void *Security::Bundle::lookupSymbol(Security::Bundle *this, const char *a2)
{
  CFStringRef functionName = CFStringCreateWithCString(0, a2, 0);
  if (!functionName) {
    Security::UnixError::throwMe((Security::UnixError *)0x55);
  }
  uint64_t v3 = (__CFBundle *)Security::Bundle::cfBundle(this);
  FunctionPointerForName = CFBundleGetFunctionPointerForName(v3, functionName);
  if (!FunctionPointerForName) {
    Security::UnixError::throwMe((Security::UnixError *)0x55);
  }
  Security::CFRef<__CFString const*>::~CFRef((const void **)&functionName);
  return FunctionPointerForName;
}

void sub_18B3D7F90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Security::CFRef<__CFString const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t Security::Bundle::cfBundle(Security::Bundle *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t result = *((void *)this + 8);
  if (!result)
  {
    uint64_t v3 = secLogObjForScope("bundle");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v7 = (void *)((char *)this + 16);
      if (*((char *)this + 39) < 0) {
        unsigned int v7 = (void *)*v7;
      }
      *(_DWORD *)uint64_t v8 = 136315138;
      *(void *)&v8[4] = v7;
      _os_log_debug_impl(&dword_18B299000, v3, OS_LOG_TYPE_DEBUG, "instantiating CFBundle for %s", v8, 0xCu);
    }
    if (*((char *)this + 39) < 0)
    {
      unsigned int v4 = (const UInt8 *)*((void *)this + 2);
      CFIndex v5 = *((void *)this + 3);
    }
    else
    {
      unsigned int v4 = (const UInt8 *)this + 16;
      CFIndex v5 = *((unsigned __int8 *)this + 39);
    }
    uint64_t v6 = CFURLCreateFromFileSystemRepresentation(0, v4, v5, 1u);
    *(void *)uint64_t v8 = v6;
    if (!v6 || (uint64_t v6 = CFBundleCreate(0, v6), (*((void *)this + 8) = v6) == 0)) {
      Security::CFError::throwMe(v6);
    }
    Security::CFRef<__CFURL const*>::~CFRef((const void **)v8);
    return *((void *)this + 8);
  }
  return result;
}

void sub_18B3D80BC(_Unwind_Exception *exception_object)
{
}

SecStaticCodeRef Security::OSXCode::codeRef(Security::OSXCode *this)
{
  staticint64_t Code = (SecStaticCodeRef)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(void **__return_ptr))(*(void *)this + 16))(__p);
  if (v6 >= 0) {
    uint64_t v2 = __p;
  }
  else {
    uint64_t v2 = (void **)__p[0];
  }
  CFURLRef CFURL = Security::makeCFURL((Security *)v2, 0, 0, v1);
  uint64_t v3 = (Security::MacOSError *)SecStaticCodeCreateWithPath(CFURL, 0, &staticCode);
  if (v3) {
    Security::MacOSError::throwMe(v3);
  }
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&CFURL);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return staticCode;
}

void sub_18B3D8184(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Security::Bundle::executablePath(Security::Bundle *this@<X0>, std::string *a2@<X8>)
{
  unsigned int v4 = (char *)this + 40;
  if (*((char *)this + 63) < 0)
  {
    std::string::size_type v5 = *((void *)this + 6);
    if (v5)
    {
      char v6 = *(const std::string::value_type **)v4;
      std::string::__init_copy_ctor_external(a2, v6, v5);
      return;
    }
  }
  else if (*((unsigned char *)this + 63))
  {
LABEL_11:
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)v4;
    a2->__r_.__value_.__r.__words[2] = *((void *)v4 + 2);
    return;
  }
  unsigned int v7 = (__CFBundle *)Security::Bundle::cfBundle(this);
  CFURLRef v8 = CFBundleCopyExecutableURL(v7);
  Security::cfStringRelease((Security *)__p, v8);
  if (*((char *)this + 63) < 0) {
    operator delete(*(void **)v4);
  }
  *((void *)v4 + 2) = v10;
  *(_OWORD *)unsigned int v4 = *(_OWORD *)__p;
  HIBYTE(v10) = 0;
  LOBYTE(__p[0]) = 0;
  if ((*((char *)this + 63) & 0x80000000) == 0) {
    goto LABEL_11;
  }
  std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 5), *((void *)this + 6));
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_18B3D82A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Security::Bundle::canonicalPath(Security::Bundle *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 39) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 2), *((void *)this + 3));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *((_OWORD *)this + 1);
    a2->__r_.__value_.__r.__words[2] = *((void *)this + 4);
  }
}

void Security::Bundle::~Bundle(Security::Bundle *this)
{
  Security::Bundle::~Bundle(this);

  JUMPOUT(0x18C12D390);
}

{
  const void *v2;

  *(void *)this = &unk_1ED84AAB8;
  uint64_t v2 = (const void *)*((void *)this + 8);
  if (v2) {
    CFRelease(v2);
  }
  if (*((char *)this + 63) < 0) {
    operator delete(*((void **)this + 5));
  }
  if (*((char *)this + 39) < 0) {
    operator delete(*((void **)this + 2));
  }
}

void Security::LoadableBundle::unload(Security::LoadableBundle *this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = secLogObjForScope("bundle");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)this + 39) < 0) {
      std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)this + 2), *((void *)this + 3));
    }
    else {
      std::string __p = *(std::string *)((char *)this + 16);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 134218242;
    unsigned int v7 = this;
    __int16 v8 = 2080;
    uint64_t v9 = p_p;
    _os_log_debug_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEBUG, "%p (%s) unloaded", buf, 0x16u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v3 = (__CFBundle *)Security::Bundle::cfBundle(this);
  CFBundleUnloadExecutable(v3);
}

void Security::LoadableBundle::load(Security::LoadableBundle *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (__CFBundle *)Security::Bundle::cfBundle(this);
  Executable = (Security::CFError *)CFBundleLoadExecutable(v2);
  if (!Executable) {
    Security::CFError::throwMe(Executable);
  }
  unsigned int v4 = secLogObjForScope("bundle");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)this + 39) < 0) {
      std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)this + 2), *((void *)this + 3));
    }
    else {
      std::string __p = *(std::string *)((char *)this + 16);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 134218242;
    __int16 v8 = this;
    __int16 v9 = 2080;
    uint64_t v10 = p_p;
    _os_log_debug_impl(&dword_18B299000, v4, OS_LOG_TYPE_DEBUG, "%p (%s) loaded", buf, 0x16u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

BOOL Security::LoadableBundle::isLoaded(Security::LoadableBundle *this)
{
  CFURLRef v1 = (__CFBundle *)Security::Bundle::cfBundle(this);
  return CFBundleIsExecutableLoaded(v1) != 0;
}

void Security::LoadableBundle::~LoadableBundle(Security::LoadableBundle *this)
{
  Security::Bundle::~Bundle(this);

  JUMPOUT(0x18C12D390);
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E5473C28, MEMORY[0x1E4FBA1D0]);
}

void sub_18B3D8684(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
  return result;
}

uint64_t Security::ModuleNexusCommon::create(Security::ModuleNexusCommon *this, void *(*a2)(void))
{
  uint64_t v4 = *((void *)this + 1);
  uint64_t v3 = (dispatch_once_t *)((char *)this + 8);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  _DWORD v6[2] = ___ZN8Security17ModuleNexusCommon6createEPFPvvE_block_invoke;
  unint64_t v6[3] = &__block_descriptor_tmp_16377;
  void v6[4] = this;
  void v6[5] = a2;
  if (v4 != -1) {
    dispatch_once(v3, v6);
  }
  uint64_t result = *(void *)this;
  if (!*(void *)this) {
    Security::ModuleNexusError::throwMe(0);
  }
  return result;
}

uint64_t ___ZN8Security17ModuleNexusCommon6createEPFPvvE_block_invoke(uint64_t a1)
{
  CFURLRef v1 = *(uint64_t **)(a1 + 32);
  uint64_t result = (*(uint64_t (**)(void))(a1 + 40))();
  *CFURLRef v1 = result;
  return result;
}

void sub_18B3D8788(void *a1)
{
  __cxa_begin_catch(a1);
  *CFURLRef v1 = 0;
  __cxa_end_catch();
}

uint64_t Security::CodeSigning::DiskRep::appleInternalForcePlatform(Security::CodeSigning::DiskRep *this)
{
  return 0;
}

uint64_t Security::CodeSigning::FilterRep::allowedResourceOmissions(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 240))();
}

uint64_t Security::CodeSigning::FilterRep::strictValidateStructure(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 232))();
}

uint64_t Security::CodeSigning::FilterRep::strictValidate(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 224))();
}

uint64_t Security::CodeSigning::FilterRep::pageSize(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 216))();
}

uint64_t Security::CodeSigning::FilterRep::defaultRequirements(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 208))();
}

uint64_t Security::CodeSigning::FilterRep::defaultResourceRules(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 200))();
}

uint64_t Security::CodeSigning::FilterRep::recommendedIdentifier(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 184))();
}

uint64_t Security::CodeSigning::FilterRep::flush(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 152))();
}

uint64_t Security::CodeSigning::FilterRep::fd(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 144))();
}

uint64_t Security::CodeSigning::FilterRep::modifiedFiles(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 136))();
}

uint64_t Security::CodeSigning::FilterRep::format(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 128))();
}

uint64_t Security::CodeSigning::DiskRep::platformType()
{
  return 0;
}

uint64_t Security::CodeSigning::FilterRep::execSegLimit(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 112))();
}

uint64_t Security::CodeSigning::FilterRep::execSegBase(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 104))();
}

uint64_t Security::CodeSigning::FilterRep::signingLimit(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 96))();
}

uint64_t Security::CodeSigning::FilterRep::signingBase(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 88))();
}

uint64_t Security::CodeSigning::FilterRep::mainExecutableImage(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 80))();
}

uint64_t Security::CodeSigning::FilterRep::adjustResources(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 64))();
}

uint64_t Security::CodeSigning::FilterRep::resourcesRootPath(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 56))();
}

uint64_t Security::CodeSigning::FilterRep::copyCanonicalPath(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 48))();
}

uint64_t Security::CodeSigning::FilterRep::mainExecutablePath(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 40))();
}

uint64_t Security::CodeSigning::FilterRep::identification(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 32))();
}

CFDataRef Security::CodeSigning::DetachedRep::component(Security::CodeSigning::EmbeddedSignatureBlob **this, Security::CodeSigning::EmbeddedSignatureBlob *a2, const Security::BlobCore *a3)
{
  CFDataRef result = Security::CodeSigning::EmbeddedSignatureBlob::component(this[14], a2, a3);
  if (!result)
  {
    unsigned int v7 = this[15];
    if (!v7 || (CFDataRef result = Security::CodeSigning::EmbeddedSignatureBlob::component(v7, a2, v6)) == 0)
    {
      __int16 v8 = *(uint64_t (**)(void))(*(void *)(*((uint64_t (**)(Security::CodeSigning::EmbeddedSignatureBlob **))*this
                                             + 2))(this)
                               + 24);
      return (CFDataRef)v8();
    }
  }
  return result;
}

uint64_t Security::CodeSigning::FilterRep::base(Security::CodeSigning::FilterRep *this)
{
  return *((void *)this + 2);
}

void Security::CodeSigning::DetachedRep::~DetachedRep(Security::CodeSigning::DetachedRep *this)
{
  *(void *)this = &unk_1ED849C10;
  if (*((char *)this + 151) < 0) {
    operator delete(*((void **)this + 16));
  }
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 12);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 11);
  *(void *)this = &unk_1ED84A8B8;
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((uint64_t)this + 16);
  Security::CodeSigning::DiskRep::~DiskRep(this);

  JUMPOUT(0x18C12D390);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1ED849C10;
  if (*((char *)this + 151) < 0) {
    operator delete(*((void **)this + 16));
  }
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 12);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 11);
  *(void *)this = &unk_1ED84A8B8;
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((uint64_t)this + 16);

  Security::CodeSigning::DiskRep::~DiskRep(this);
}

_DWORD *Security::Blob<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u>::specific(_DWORD *result)
{
  if (result)
  {
    if (*result == -1072898310
      && (v1 = bswap32(result[2]), v2 = 8 * v1 + 12, unint64_t v3 = bswap32(result[1]), v2 <= v3))
    {
      unint64_t v5 = (unint64_t)&result[2 * v1 + 3];
      while (1)
      {
        v5 -= 8;
        if (v5 < (unint64_t)(result + 3)) {
          break;
        }
        unsigned int v6 = *(_DWORD *)(v5 + 4);
        if (v6)
        {
          unint64_t v7 = bswap32(v6);
          BOOL v8 = v2 > v7 || v7 + 8 > v3;
          if (v8 || bswap32(*(_DWORD *)((char *)result + v7 + 4)) + v7 > v3) {
            return 0;
          }
        }
      }
    }
    else
    {
      uint64_t v4 = __error();
      CFDataRef result = 0;
      *uint64_t v4 = 22;
    }
  }
  return result;
}

uint64_t Security::SuperBlobCore<Security::SuperBlob<4208856257u,unsigned int>,4208856257u,unsigned int>::find(uint64_t a1, int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = 0;
  LODWORD(v4) = bswap32(v2);
  uint64_t v4 = v4 <= 1 ? 1 : v4;
  unint64_t v5 = (unsigned int *)(a1 + 12);
  while (1)
  {
    unsigned int v6 = *v5;
    v5 += 2;
    if (bswap32(v6) == a2) {
      break;
    }
    if (v4 == ++v3) {
      return 0;
    }
  }
  unsigned int v7 = *(_DWORD *)(a1 + 8 * v3 + 16);
  if (v7) {
    return bswap32(v7) + a1;
  }
  else {
    return 0;
  }
}

void Security::CodeSigning::DYLDCacheRep::writer(Security::CodeSigning::DYLDCacheRep *this)
{
}

void sub_18B3D8E84(_Unwind_Exception *a1)
{
  MEMORY[0x18C12D390](v1, 0x10A1C4069E8879DLL);
  _Unwind_Resume(a1);
}

Security::CodeSigning::SingleDiskRep::Writer *Security::CodeSigning::SingleDiskRep::Writer::Writer(Security::CodeSigning::SingleDiskRep::Writer *this, atomic_uint *a2, int a3)
{
  *((_DWORD *)this + 2) = 0;
  *(void *)((char *)this + 12) = -1;
  *((_DWORD *)this + 5) = a3;
  *(void *)this = &unk_1ED84A378;
  Security::Mutex::Mutex((pthread_mutex_t *)((char *)this + 32));
  if (a2) {
    atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
  }
  *((void *)this + 3) = a2;
  *((_DWORD *)this + 24) = -1;
  *((unsigned char *)this + 100) = 0;
  return this;
}

ssize_t Security::CodeSigning::DYLDCacheRep::Writer::flush(Security::CodeSigning::DYLDCacheRep::Writer *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *((void *)this + 17);
  if (v9) {
    MEMORY[0x18C12D390](v9, 0x1000C403E1C8BA9);
  }
  *((void *)this + 17) = Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::make((uint64_t)this + 104, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  Security::UnixPlusPlus::FileDesc::seek((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v10, *(void *)(*((void *)this + 16) + 104));
  uint64_t v11 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  uint64_t v12 = *((void *)this + 17);
  size_t v13 = bswap32(*(_DWORD *)(v12 + 4));

  return Security::UnixPlusPlus::FileDesc::writeAll((ssize_t)v11, (char *)v12, v13);
}

_DWORD *Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::make(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  int v9 = *(_DWORD *)(a1 + 16);
  long long v33 = 0uLL;
  *(void *)&long long v34 = 0;
  unsigned int v10 = Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::size((void *)a1, (uint64_t **)&v33, 0, a4, a5, a6, a7, a8, v30);
  uint64_t v11 = malloc_type_malloc(v10, 0x79CB62BEuLL);
  if (!v11) {
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  uint64_t v12 = v11;
  unsigned int v13 = *(_DWORD *)(a1 + 16);
  *uint64_t v11 = -1072898310;
  v11[1] = bswap32(v10);
  _OWORD v11[2] = bswap32(v13);
  unsigned int v14 = *(void **)a1;
  if (*(void *)a1 != a1 + 8)
  {
    int v15 = 0;
    unsigned int v16 = 8 * v9 + 12;
    do
    {
      uint64_t v17 = &v12[2 * v15];
      unint64_t v17[3] = bswap32(*((_DWORD *)v14 + 8));
      void v17[4] = bswap32(v16);
      memcpy((char *)v12 + v16, (const void *)v14[5], bswap32(*(_DWORD *)(v14[5] + 4)));
      unsigned int v18 = (void *)v14[1];
      unsigned int v19 = v14;
      if (v18)
      {
        do
        {
          unsigned int v20 = v18;
          unsigned int v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          unsigned int v20 = (void *)v19[2];
          BOOL v21 = *v20 == (void)v19;
          unsigned int v19 = v20;
        }
        while (!v21);
      }
      v16 += bswap32(*(_DWORD *)(v14[5] + 4));
      ++v15;
      unsigned int v14 = v20;
    }
    while (v20 != (void *)(a1 + 8));
  }
  unint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v22 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40[7] = v22;
  v40[8] = v22;
  v40[5] = v22;
  v40[6] = v22;
  v40[3] = v22;
  v40[4] = v22;
  v40[1] = v22;
  v40[2] = v22;
  v40[0] = v22;
  long long v38 = v22;
  long long v39 = v22;
  long long v36 = v22;
  *(_OWORD *)std::string __p = v22;
  long long v34 = v22;
  long long v35 = v22;
  long long v33 = v22;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v33);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v33, (uint64_t)"Maker ", 6);
  uint64_t v23 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)" assembles ", 11);
  uint64_t v24 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)" blob(s) into ", 14);
  uint64_t v25 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)" (size=", 7);
  BOOL v26 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)")", 1);
  unsigned int v27 = secLogObjForScope("superblob");
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)&v33 + 8);
    unsigned int v29 = v32 >= 0 ? __dst : (void **)__dst[0];
    *(_DWORD *)long long buf = 136315138;
    unsigned int v43 = v29;
    _os_log_debug_impl(&dword_18B299000, v27, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
    if (v32 < 0) {
      operator delete(__dst[0]);
    }
  }
  *(void *)&long long v33 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v33 + *(void *)(v33 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  *((void *)&v33 + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v38) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x18C12D300](v40);
  return v12;
}

void sub_18B3D9320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::size(void *a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = (void *)*a1;
  if ((void *)*a1 == a1 + 1)
  {
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    do
    {
      uint64_t v11 = (void *)v9[1];
      uint64_t v12 = v9;
      if (v11)
      {
        do
        {
          unsigned int v13 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          uint64_t v12 = v13;
        }
        while (!v14);
      }
      v10 += bswap32(*(_DWORD *)(v9[5] + 4));
      int v9 = v13;
    }
    while (v13 != a1 + 1);
  }
  int v15 = a2[1];
  if (*a2 != v15)
  {
    unsigned int v16 = *a2;
    do
    {
      uint64_t v17 = *v16++;
      v10 += v17;
    }
    while (v16 != v15);
  }
  uint64_t v18 = a1[2] + v15 - *a2;
  if (a3)
  {
    BOOL v21 = &a9;
    do
    {
      ++v18;
      v10 += a3;
      unsigned int v19 = (uint64_t *)v21;
      v21 += 8;
      a3 = *v19;
    }
    while (*v19);
  }
  return v10 + 8 * v18 + 12;
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 112) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  unint64_t v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x1E4FBA498] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 112) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_18B3D9580(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x18C12D300](v1);
  _Unwind_Resume(a1);
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  v23[0] = 0xAAAAAAAAAAAAAAAALL;
  v23[1] = 0xAAAAAAAAAAAAAAAALL;
  MEMORY[0x18C12D230](v23, a1);
  if (LOBYTE(v23[0]))
  {
    uint64_t v6 = (char *)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *((void *)v6 + 5);
    int v8 = *((_DWORD *)v6 + 2);
    int v9 = *((_DWORD *)v6 + 36);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v10 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(__b);
      *((_DWORD *)v6 + 36) = v9;
    }
    uint64_t v11 = a2 + a3;
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v12 = a2 + a3;
    }
    else {
      uint64_t v12 = a2;
    }
    if (!v7) {
      goto LABEL_29;
    }
    uint64_t v13 = *((void *)v6 + 3);
    BOOL v14 = v13 <= a3;
    uint64_t v15 = v13 - a3;
    size_t v16 = v14 ? 0 : v15;
    if (v12 - a2 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, a2, v12 - a2) != v12 - a2)
    {
      goto LABEL_29;
    }
    if ((uint64_t)v16 >= 1)
    {
      memset(__b, 170, sizeof(__b));
      if (v16 >= 0x7FFFFFFFFFFFFFF8) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v16 >= 0x17)
      {
        uint64_t v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v16 | 7) != 0x17) {
          uint64_t v18 = v16 | 7;
        }
        uint64_t v19 = v18 + 1;
        uint64_t v17 = (std::locale::__imp *)operator new(v18 + 1);
        __b[1].__locale_ = (std::locale::__imp *)v16;
        __b[2].__locale_ = (std::locale::__imp *)(v19 | 0x8000000000000000);
        __b[0].__locale_ = v17;
      }
      else
      {
        HIBYTE(__b[2].__locale_) = v16;
        uint64_t v17 = (std::locale::__imp *)__b;
      }
      memset(v17, v9, v16);
      *((unsigned char *)v17 + v16) = 0;
      unsigned int v20 = SHIBYTE(__b[2].__locale_) >= 0 ? __b : (std::locale *)__b[0].__locale_;
      uint64_t v21 = (*(uint64_t (**)(uint64_t, std::locale *, size_t))(*(void *)v7 + 96))(v7, v20, v16);
      if (SHIBYTE(__b[2].__locale_) < 0) {
        operator delete(__b[0].__locale_);
      }
      if (v21 != v16) {
        goto LABEL_29;
      }
    }
    if (v11 - v12 < 1
      || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, v12, v11 - v12) == v11 - v12)
    {
      *((void *)v6 + 3) = 0;
    }
    else
    {
LABEL_29:
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x18C12D240](v23);
  return a1;
}

void sub_18B3D9858(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  MEMORY[0x18C12D240](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v17 + *(void *)(*v17 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x18B3D982CLL);
}

void sub_18B3D98C4(_Unwind_Exception *a1)
{
}

void *std::stringbuf::str[abi:ne180100]<std::allocator<char>>(void *__dst, uint64_t a2)
{
  uint64_t v2 = __dst;
  int v3 = *(_DWORD *)(a2 + 96);
  if ((v3 & 0x10) != 0)
  {
    unint64_t v5 = *(void *)(a2 + 88);
    unint64_t v6 = *(void *)(a2 + 48);
    if (v5 < v6)
    {
      *(void *)(a2 + 88) = v6;
      unint64_t v5 = v6;
    }
    uint64_t v7 = (const void **)(a2 + 40);
  }
  else
  {
    if ((v3 & 8) == 0)
    {
      size_t v4 = 0;
      *((unsigned char *)__dst + 23) = 0;
      goto LABEL_16;
    }
    uint64_t v7 = (const void **)(a2 + 16);
    unint64_t v5 = *(void *)(a2 + 32);
  }
  int v8 = *v7;
  size_t v4 = v5 - (void)*v7;
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v4 >= 0x17)
  {
    uint64_t v9 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v9 = v4 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v11 = operator new(v9 + 1);
    v2[1] = v4;
    v2[2] = v10 | 0x8000000000000000;
    *uint64_t v2 = v11;
    uint64_t v2 = v11;
  }
  else
  {
    *((unsigned char *)__dst + 23) = v4;
    if (!v4) {
      goto LABEL_16;
    }
  }
  __dst = memmove(v2, v8, v4);
LABEL_16:
  *((unsigned char *)v2 + v4) = 0;
  return __dst;
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)a1 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x18C12D300](a1 + 112);
  return a1;
}

void Security::CodeSigning::DYLDCacheRep::Writer::addDiscretionary(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 128);
  unsigned int v5 = *(_DWORD *)(*(void *)(v4 + 80) + 20);
  unsigned int v6 = bswap32(v5);
  if (*(unsigned char *)(v4 + 96)) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v5;
  }
  size_t v8 = 24 * (v7 + 1);
  *(void *)(a2 + 160) = v8;
  uint64_t v9 = malloc_type_realloc(*(void **)(a2 + 152), v8, 0x372C092CuLL);
  *(void *)(a2 + 152) = v9;
  if (!v9) {
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  bzero(v9, *(void *)(a2 + 160));
  if (v7)
  {
    uint64_t v10 = *(void *)(a1 + 128);
    unint64_t v11 = *(void *)(v10 + 72);
    int v12 = *(unsigned __int8 *)(v10 + 96);
    unsigned int v13 = bswap32(*(_DWORD *)(*(void *)(v10 + 80) + 16));
    if (!*(unsigned char *)(v10 + 96)) {
      unsigned int v13 = *(_DWORD *)(*(void *)(v10 + 80) + 16);
    }
    int32x2_t v14 = vdup_n_s32(*(unsigned char *)(v10 + 96) == 0);
    uint64_t v15 = (void *)(*(void *)(a2 + 152) + 8);
    v16.i64[0] = v14.u32[0];
    v16.i64[1] = v14.u32[1];
    int8x16_t v17 = (int8x16_t)vcltzq_s64(vshlq_n_s64(v16, 0x3FuLL));
    do
    {
      if ((unint64_t)v13 + 32 > v11) {
        Security::UnixError::throwMe((Security::UnixError *)8);
      }
      uint64_t v18 = *(void *)(v10 + 64) + v13;
      unint64_t v19 = *(void *)v18;
      unint64_t v20 = bswap64(*(void *)v18);
      if (v12) {
        unint64_t v19 = v20;
      }
      *uint64_t v15 = bswap64(v19);
      int64x2_t v21 = (int64x2_t)vbslq_s8(v17, *(int8x16_t *)(v18 + 8), vrev64q_s8(*(int8x16_t *)(v18 + 8)));
      *(v15 - 1) = vrev32_s8((int8x8_t)vshrn_n_s64(v21, 0xCuLL));
      int v22 = *(_DWORD *)(v18 + 24);
      if (v12) {
        LOBYTE(v22) = HIBYTE(v22);
      }
      if ((v22 & 4) != 0)
      {
        *(int8x16_t *)(a2 + 168) = vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL);
        *(void *)(a2 + 184) = 0;
      }
      v15 += 3;
      v13 += 32;
      --v7;
    }
    while (v7);
  }
}

void Security::CodeSigning::DYLDCacheRep::Writer::component(uint64_t **this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
}

void Security::CodeSigning::DYLDCacheRep::Writer::~Writer(Security::CodeSigning::DYLDCacheRep::Writer *this)
{
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 104);
  *(void *)this = &unk_1ED84A378;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::DYLDCacheRep::Writer *)((char *)this + 96));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer((void *)this + 3);

  JUMPOUT(0x18C12D390);
}

{
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 104);
  *(void *)this = &unk_1ED84A378;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::DYLDCacheRep::Writer *)((char *)this + 96));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer((void *)this + 3);
}

uint64_t Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1 != a1 + 8)
  {
    do
    {
      free((void *)v3[5]);
      uint64_t v4 = (void *)v3[1];
      if (v4)
      {
        do
        {
          unsigned int v5 = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          unsigned int v5 = (void *)v3[2];
          BOOL v6 = *v5 == (void)v3;
          uint64_t v3 = v5;
        }
        while (!v6);
      }
      uint64_t v3 = v5;
    }
    while (v5 != v2);
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(void **)(a1 + 8));
  return a1;
}

void *Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer(void *a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 1);
  v5[0] = a1 + 1;
  v5[1] = 0xAAAAAAAAAAAAAA01;
  uint64_t v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if (v3) {
    Security::UnixError::throwMe(v3);
  }
  if (*a1 && atomic_fetch_add_explicit((atomic_uint *volatile)(*a1 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    if (*a1) {
      (*(void (**)(void))(*(void *)*a1 + 8))(*a1);
    }
    *a1 = 0;
  }
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v5);
  Security::Mutex::~Mutex(v2);
  return a1;
}

uint64_t Security::CodeSigning::DYLDCacheRep::pageSize()
{
  return 4096;
}

void *Security::CodeSigning::DYLDCacheRep::format@<X0>(Security::CodeSigning::DYLDCacheRep *this@<X0>, void *a2@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = NXGetArchInfoFromCpuType(**((_DWORD **)this + 11), *(_DWORD *)(*((void *)this + 11) + 4) & 0xFFFFFF);
  if (v4 && (name = v4->name) != 0)
  {
    int v16 = -1431655766;
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v14 = v6;
    long long v15 = v6;
    long long v12 = v6;
    long long v13 = v6;
    *(_OWORD *)std::string __str = v6;
    long long v11 = v6;
    unint64_t v7 = *(void *)(*((void *)this + 10) + 32);
    unint64_t v8 = bswap64(v7);
    if (*((unsigned char *)this + 96)) {
      unint64_t v7 = v8;
    }
    snprintf(__str, 0x64uLL, "OS X Shared Library Cache (%s @ 0x%llx)", name, v7);
    return std::string::basic_string[abi:ne180100]<0>(a2, __str);
  }
  else
  {
    return std::string::basic_string[abi:ne180100]<0>(a2, "OS X Shared Library Cache (unknown type)");
  }
}

uint64_t Security::CodeSigning::DYLDCacheRep::signingLimit(Security::CodeSigning::DYLDCacheRep *this)
{
  return *((void *)this + 13);
}

Security::CodeSigning::EmbeddedSignatureBlob *Security::CodeSigning::DYLDCacheRep::component(Security::CodeSigning::DYLDCacheRep *this, Security::CodeSigning::EmbeddedSignatureBlob *a2, const Security::BlobCore *a3)
{
  CFDataRef result = (Security::CodeSigning::EmbeddedSignatureBlob *)*((void *)this + 15);
  if (result) {
    return Security::CodeSigning::EmbeddedSignatureBlob::component(result, a2, a3);
  }
  return result;
}

void Security::CodeSigning::DYLDCacheRep::~DYLDCacheRep(void **this)
{
  *this = &unk_1ED849F38;
  DYLDCache::~DYLDCache((DYLDCache *)(this + 6));
  *this = &unk_1ED84A3C0;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 5));
  if (*((char *)this + 39) < 0) {
    operator delete(this[2]);
  }
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)this);

  JUMPOUT(0x18C12D390);
}

{
  uint64_t vars8;

  *this = &unk_1ED849F38;
  DYLDCache::~DYLDCache((DYLDCache *)(this + 6));
  *this = &unk_1ED84A3C0;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 5));
  if (*((char *)this + 39) < 0) {
    operator delete(this[2]);
  }

  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)this);
}

uint64_t Security::CodeSigning::DirScanner::DirScanner(uint64_t a1, const std::string *a2)
{
  *(unsigned char *)(a1 + 1080) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  std::string::operator=((std::string *)a1, a2);
  if (*(void *)(a1 + 24)) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEF7A9);
  }
  *__error() = 0;
  uint64_t v3 = (const char *)a1;
  if (*(char *)(a1 + 23) < 0) {
    uint64_t v3 = *(const char **)a1;
  }
  uint64_t v4 = opendir(v3);
  *(void *)(a1 + 24) = v4;
  if (v4)
  {
    char v5 = 1;
  }
  else
  {
    if (*__error() != 2)
    {
      unint64_t v7 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v7);
    }
    char v5 = 0;
  }
  *(unsigned char *)(a1 + 1080) = v5;
  return a1;
}

void sub_18B3DA104(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::DirScanner::~DirScanner(Security::CodeSigning::DirScanner *this)
{
  uint64_t v2 = (DIR *)*((void *)this + 3);
  if (v2) {
    closedir(v2);
  }
  if (*((char *)this + 23) < 0) {
    operator delete(*(void **)this);
  }
}

dirent *Security::CodeSigning::DirScanner::getNext(DIR **this)
{
  long long v6 = (dirent *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v2 = (dirent *)(this + 4);
  do
  {
    uint64_t v3 = (Security::UnixError *)readdir_r(this[3], v2, &v6);
    if (v3) {
      Security::UnixError::throwMe(v3);
    }
    uint64_t v4 = v6;
  }
  while (v6 && (!strcmp(v6->d_name, ".") || !strcmp(v4->d_name, "..")));
  return v4;
}

BOOL Security::CodeSigning::DirScanner::isRegularFile(Security::CodeSigning::DirScanner *this, dirent *a2)
{
  if (a2->d_type) {
    return a2->d_type == 8;
  }
  v5.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v5.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v18.st_blkstd::string::size_type size = v5;
  *(timespec *)v18.st_qspare = v5;
  v18.st_birthtimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v18.st_std::string::size_type size = v5;
  v18.st_mtimespeCC_SHA512_CTX c = v5;
  v18.st_ctimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v18.st_uid = v5;
  v18.st_atimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v18.st_dev = v5;
  if (*((char *)this + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)this + 23);
  }
  else {
    size_t v6 = *((void *)this + 1);
  }
  memset(&v15, 170, sizeof(v15));
  unint64_t v7 = &v15;
  std::string::basic_string[abi:ne180100]((uint64_t)&v15, v6 + 1);
  if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    unint64_t v7 = (std::string *)v15.__r_.__value_.__r.__words[0];
  }
  if (v6)
  {
    if (*((char *)this + 23) >= 0) {
      unint64_t v8 = this;
    }
    else {
      unint64_t v8 = *(Security::CodeSigning::DirScanner **)this;
    }
    memmove(v7, v8, v6);
  }
  *(_WORD *)((char *)&v7->__r_.__value_.__l.__data_ + v6) = 47;
  d_name = a2->d_name;
  std::string::size_type v10 = strlen(d_name);
  long long v11 = std::string::append(&v15, d_name, v10);
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  int64_t v17 = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (v17 >= 0) {
    long long v13 = __p;
  }
  else {
    long long v13 = (void **)__p[0];
  }
  long long v14 = (Security::MacOSError *)stat((const char *)v13, &v18);
  if (v14) {
    Security::MacOSError::throwMe(v14);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  return (v18.st_mode & 0xF000) == 0x8000;
}

void sub_18B3DA364(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::DirValidator::~DirValidator(uint64_t **this)
{
  uint64_t v3 = *this;
  uint64_t v2 = this[1];
  if (*this != v2)
  {
    do
    {
      uint64_t v4 = *v3;
      if (*v3)
      {
        timespec v5 = *(const void **)(v4 + 64);
        if (v5) {
          _Block_release(v5);
        }
        Security::CodeSigning::ResourceBuilder::Rule::~Rule((void **)v4);
        MEMORY[0x18C12D390]();
        uint64_t v2 = this[1];
      }
      ++v3;
    }
    while (v3 != v2);
    uint64_t v3 = *this;
  }
  if (v3)
  {
    this[1] = v3;
    operator delete(v3);
  }
}

void Security::CodeSigning::DirValidator::validate(uint64_t a1, uint64_t a2, unsigned int a3)
{
  __b[129] = *(char **)MEMORY[0x1E4F143B8];
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  long long v55 = &v56;
  if (*(char *)(a2 + 23) >= 0) {
    timespec v5 = (char *)a2;
  }
  else {
    timespec v5 = *(char **)a2;
  }
  __b[0] = v5;
  __b[1] = 0;
  size_t v6 = fts_open(__b, 21, 0);
  if (!v6)
  {
    unsigned int v49 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v49);
  }
  while (1)
  {
    unint64_t v7 = fts_read(v6);
    unint64_t v8 = v7;
    if (!v7) {
      break;
    }
    uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
    if ((v9 & 0x80u) != 0) {
      uint64_t v9 = *(void *)(a2 + 8);
    }
    std::string::size_type v10 = &v7->fts_path[v9 + 1];
    int v11 = v7->fts_statp->st_mode & 0x49;
    fts_unint64_t info = v7->fts_info;
    if (fts_info > 7)
    {
      if (fts_info == 12)
      {
        unsigned int v29 = secLogObjForScope("dirval");
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          fts_path = v8->fts_path;
          LODWORD(__b[0]) = 136315138;
          *(char **)((char *)__b + 4) = fts_path;
          _os_log_debug_impl(&dword_18B299000, v29, OS_LOG_TYPE_DEBUG, "symlink %s", (uint8_t *)__b, 0xCu);
        }
        memset(__b, 170, 0x400uLL);
        ssize_t v30 = readlink(v8->fts_accpath, (char *)__b, 0x3FFuLL);
        if (v30 < 0)
        {
          uint64_t v44 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v44);
        }
        *((unsigned char *)__b + v30) = 0;
        stat v18 = Security::CodeSigning::DirValidator::match((const regex_t ***)a1, v10, 4, v11 != 0, (char *)__b);
      }
      else
      {
        if (fts_info != 8)
        {
LABEL_64:
          CFAllocatorRef v45 = secLogObjForScope("dirval");
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
          {
            int v46 = v8->fts_info;
            int fts_errno = v8->fts_errno;
            int v48 = v8->fts_path;
            LODWORD(__b[0]) = 67109634;
            HIDWORD(__b[0]) = v46;
            LOWORD(__b[1]) = 1024;
            *(_DWORD *)((char *)&__b[1] + 2) = fts_errno;
            HIWORD(__b[1]) = 2080;
            __b[2] = v48;
            _os_log_debug_impl(&dword_18B299000, v45, OS_LOG_TYPE_DEBUG, "type %d (errno %d): %s", (uint8_t *)__b, 0x18u);
          }
          Security::MacOSError::throwMe((Security::MacOSError *)a3);
        }
        int64_t v17 = secLogObjForScope("dirval");
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          long long v36 = v8->fts_path;
          LODWORD(__b[0]) = 136315138;
          *(char **)((char *)__b + 4) = v36;
          _os_log_debug_impl(&dword_18B299000, v17, OS_LOG_TYPE_DEBUG, "file %s", (uint8_t *)__b, 0xCu);
        }
        stat v18 = Security::CodeSigning::DirValidator::match((const regex_t ***)a1, v10, 1, v11 != 0, 0);
      }
      int v22 = v18;
      if (v18) {
        goto LABEL_24;
      }
LABEL_41:
      if (v8->fts_info != 8
        || (*(char *)(a2 + 23) >= 0 ? (long long v31 = (Security::CodeSigning *)a2) : (long long v31 = *(Security::CodeSigning **)a2),
            !Security::CodeSigning::pathFileSystemUsesXattrFiles(v31, v19)))
      {
LABEL_62:
        Security::MacOSError::throwMe((Security::MacOSError *)a3);
      }
      std::string::basic_string[abi:ne180100]<0>(__p, v8->fts_path);
      int IsValidXattrFile = Security::CodeSigning::pathIsValidXattrFile((char *)__p, "csutilities");
      char v33 = IsValidXattrFile;
      if (v54 < 0)
      {
        operator delete(__p[0]);
        if ((v33 & 1) == 0) {
          goto LABEL_62;
        }
      }
      else if (!IsValidXattrFile)
      {
        goto LABEL_62;
      }
      long long v34 = secLogObjForScope("dirval");
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        long long v35 = v8->fts_path;
        LODWORD(__b[0]) = 136315138;
        *(char **)((char *)__b + 4) = v35;
        std::string v15 = v34;
        int v16 = "skipping file due to xattr: %s";
LABEL_52:
        _os_log_debug_impl(&dword_18B299000, v15, OS_LOG_TYPE_DEBUG, v16, (uint8_t *)__b, 0xCu);
      }
    }
    else if (fts_info == 1)
    {
      unint64_t v20 = secLogObjForScope("dirval");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v37 = v8->fts_path;
        LODWORD(__b[0]) = 136315138;
        *(char **)((char *)__b + 4) = v37;
        _os_log_debug_impl(&dword_18B299000, v20, OS_LOG_TYPE_DEBUG, "entering %s", (uint8_t *)__b, 0xCu);
      }
      if (v8->fts_level)
      {
        int64x2_t v21 = Security::CodeSigning::DirValidator::match((const regex_t ***)a1, v10, 2, v11 != 0, 0);
        int v22 = v21;
        if (v21)
        {
          int v23 = *(&v21[1].re_magic + 1);
          if ((v23 & 0x20) != 0) {
            goto LABEL_25;
          }
        }
        fts_set(v6, v8, 4);
        if (!v22) {
          goto LABEL_41;
        }
LABEL_24:
        int v23 = *(&v22[1].re_magic + 1);
LABEL_25:
        if ((v23 & 0x10) != 0)
        {
          uint64_t v24 = v56;
          uint64_t v25 = &v56;
          BOOL v26 = &v56;
          if (v56)
          {
            while (1)
            {
              while (1)
              {
                BOOL v26 = (uint64_t **)v24;
                unint64_t v27 = v24[4];
                if ((unint64_t)v22 >= v27) {
                  break;
                }
                uint64_t v24 = *v26;
                uint64_t v25 = v26;
                if (!*v26) {
                  goto LABEL_33;
                }
              }
              if (v27 >= (unint64_t)v22) {
                break;
              }
              uint64_t v24 = v26[1];
              if (!v24)
              {
                uint64_t v25 = v26 + 1;
                goto LABEL_33;
              }
            }
          }
          else
          {
LABEL_33:
            unsigned int v28 = (uint64_t *)operator new(0x28uLL);
            v28[4] = (uint64_t)v22;
            *unsigned int v28 = 0;
            v28[1] = 0;
            void v28[2] = (uint64_t)v26;
            *uint64_t v25 = v28;
            if (*v55)
            {
              long long v55 = (uint64_t **)*v55;
              unsigned int v28 = *v25;
            }
            std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v56, v28);
            ++v57;
          }
        }
      }
    }
    else
    {
      if (fts_info != 6) {
        goto LABEL_64;
      }
      long long v13 = secLogObjForScope("dirval");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        long long v14 = v8->fts_path;
        LODWORD(__b[0]) = 136315138;
        *(char **)((char *)__b + 4) = v14;
        std::string v15 = v13;
        int v16 = "leaving %s";
        goto LABEL_52;
      }
    }
  }
  if (v57 != *(_DWORD *)(a1 + 24))
  {
    __b[32] = (char *)0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v39 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&__b[28] = v39;
    *(_OWORD *)&__b[30] = v39;
    *(_OWORD *)&__b[24] = v39;
    *(_OWORD *)&__b[26] = v39;
    *(_OWORD *)&__b[20] = v39;
    *(_OWORD *)&__b[22] = v39;
    *(_OWORD *)&__b[16] = v39;
    *(_OWORD *)&__b[18] = v39;
    *(_OWORD *)&__b[12] = v39;
    *(_OWORD *)&__b[14] = v39;
    *(_OWORD *)&__b[8] = v39;
    *(_OWORD *)&__b[10] = v39;
    *(_OWORD *)&__b[6] = v39;
    *(_OWORD *)&__b[2] = v39;
    *(_OWORD *)&__b[4] = v39;
    *(_OWORD *)__b = v39;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)__b);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(__b, (uint64_t)"matched ", 8);
    CFTypeID v40 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)" of ", 4);
    unint64_t v41 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)" required rules", 15);
    long long v42 = secLogObjForScope("dirval");
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    {
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)&__b[1]);
      unsigned int v43 = v52 >= 0 ? __dst : (void **)__dst[0];
      *(_DWORD *)long long buf = 136315138;
      long long v59 = v43;
      _os_log_debug_impl(&dword_18B299000, v42, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
      if (v52 < 0) {
        operator delete(__dst[0]);
      }
    }
    Security::MacOSError::throwMe((Security::MacOSError *)a3);
  }
  fts_close(v6);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v56);
}

void sub_18B3DAA70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45)
{
  a28 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a28 + *(void *)(a28 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a29 = MEMORY[0x1E4FBA470] + 16;
  if (a42 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x18C12D300](&a45);
  fts_close(v45);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a24);
  _Unwind_Resume(a1);
}

const regex_t *Security::CodeSigning::DirValidator::match(const regex_t ***this, char *a2, int a3, char a4, char *a5)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  timespec v5 = *this;
  if (*this != this[1])
  {
    while (1)
    {
      int v11 = *v5;
      int v12 = *(&(*v5)[1].re_magic + 1);
      if ((v12 & a3) != 0 && ((v12 & 8) == 0 || (a4 & 1) == 0))
      {
        if (Security::CodeSigning::ResourceBuilder::Rule::match(*v5, a2)) {
          break;
        }
      }
LABEL_29:
      if (++v5 == this[1]) {
        return 0;
      }
    }
    if (!a5) {
      return v11;
    }
    uint64_t v14 = *(void *)&v11[2].re_magic;
    if (!v14)
    {
      Security::Syslog::notice((Security::Syslog *)"code signing internal problem: !mTargetBlock", v13);
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
    }
    memset(v27, 170, sizeof(v27));
    std::string::basic_string[abi:ne180100]<0>(&v28, a2);
    std::string::basic_string[abi:ne180100]<0>(__p, a5);
    (*(void (**)(void **__return_ptr, uint64_t, regex_t *, void **))(v14 + 16))(v27, v14, &v28, __p);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v28.re_endp) < 0) {
      operator delete(*(void **)&v28.re_magic);
    }
    std::string v15 = (void *)HIBYTE(v27[2]);
    if (SHIBYTE(v27[2]) < 0) {
      std::string v15 = v27[1];
    }
    if (v15)
    {
      int v16 = secLogObjForScope("dirval");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        if (SHIBYTE(v27[2]) >= 0) {
          int v23 = v27;
        }
        else {
          int v23 = (void **)v27[0];
        }
        v28.re_magiCC_SHA512_CTX c = 136315650;
        *(void *)(&v28.re_magic + 1) = a2;
        WORD2(v28.re_nsub) = 2080;
        *(size_t *)((char *)&v28.re_nsub + 6) = (size_t)a5;
        HIWORD(v28.re_endp) = 2080;
        v28.re_g = (re_guts *)v23;
        _os_log_debug_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEBUG, "%s: match target %s against %s", (uint8_t *)&v28, 0x20u);
      }
      *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v28.re_magiCC_SHA512_CTX c = v17;
      *(_OWORD *)&v28.re_endp = v17;
      if (SHIBYTE(v27[2]) >= 0) {
        stat v18 = v27;
      }
      else {
        stat v18 = (void **)v27[0];
      }
      if (regcomp(&v28, (const char *)v18, 5))
      {
        Security::Syslog::notice((Security::Syslog *)"code signing internal problem: failed to compile internal RE", v19);
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
      }
      uint64_t v20 = regexec(&v28, a5, 0, 0, 0);
      MEMORY[0x18C12EEA0](&v28);
      if (v20)
      {
        if (v20 != 1)
        {
          Security::Syslog::notice((Security::Syslog *)"code signing internal error: regexec failed error=%d", v21, v20);
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
        }
        char v22 = 0;
      }
      else
      {
        char v22 = 1;
      }
      if ((HIBYTE(v27[2]) & 0x80) == 0)
      {
LABEL_28:
        if (v22) {
          return v11;
        }
        goto LABEL_29;
      }
    }
    else
    {
      char v22 = 1;
      if ((HIBYTE(v27[2]) & 0x80) == 0) {
        goto LABEL_28;
      }
    }
    operator delete(v27[0]);
    goto LABEL_28;
  }
  return 0;
}

void sub_18B3DAE7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Security::CodeSigning::DirValidator::Rule::Rule(uint64_t a1, long long *a2, int a3, const void *a4)
{
  *(void *)&Security::CodeSigning::ResourceBuilder::Rule::Rule((regex_t *)a1, a2, 0, a3)[2].re_magiCC_SHA512_CTX c = 0;
  if (a4) {
    *(void *)(a1 + 64) = _Block_copy(a4);
  }
  return a1;
}

void sub_18B3DAF20(_Unwind_Exception *a1)
{
  Security::CodeSigning::ResourceBuilder::Rule::~Rule(v1);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::registerStapledTicketWithSystem(Security::CodeSigning *this, const __CFData *a2)
{
  if (this)
  {
    uint64_t v2 = secLogObjForScope("notarization");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_debug_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEBUG, "Registering stapled ticket with system", v3, 2u);
    }
  }
}

const void **Security::CFRef<__CFError *>::~CFRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t SecCodeSignerGetTypeID()
{
  return *(void *)(Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()() + 408);
}

void sub_18B3DAFF8(void *a1)
{
}

void Security::ModuleNexus<Security::CodeSigning::CFObjects>::make()
{
}

void sub_18B3DB2F4(_Unwind_Exception *a1)
{
  MEMORY[0x18C12D390](v1, 0x10D0C40CB15CC2FLL);
  _Unwind_Resume(a1);
}

uint64_t SecCodeSignerCreate(const __CFDictionary *a1, int a2, void *a3)
{
  if ((a2 & 0xFEFFF000) != 0) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  int v11 = (Security::SecCFObject *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  uint64_t v8 = Security::SecCFObject::allocate((Security::SecCFObject *)0x140, *(void *)(v6 + 408), v7);
  *(void *)(v8 + 8) = 1;
  *(void *)uint64_t v8 = &unk_1ED84A228;
  *(_DWORD *)(v8 + 16) = a2;
  *(void *)(v8 + 168) = 0;
  *(void *)(v8 + 160) = 0;
  *(_OWORD *)(v8 + 24) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(void *)(v8 + 152) = v8 + 160;
  *(void *)(v8 + 288) = 0;
  *(_DWORD *)(v8 + 296) = 0;
  *(_OWORD *)(v8 + 176) = 0u;
  *(_OWORD *)(v8 + 192) = 0u;
  *(_OWORD *)(v8 + 208) = 0u;
  *(_OWORD *)(v8 + 224) = 0u;
  *(void *)(v8 + 240) = 0;
  *(void *)(v8 + 256) = 0;
  *(void *)(v8 + 264) = 0;
  *(void *)(v8 + 272) = 0;
  *(void *)(v8 + 304) = 0;
  *(void *)(v8 + 312) = 0;
  Security::SecPointerBase::SecPointerBase(&v11, v8);
  Security::CodeSigning::SecCodeSigner::parameters(v11, a1);
  uint64_t v9 = Security::SecCFObject::handle((atomic_uchar *)v11, 1);
  if (!a3) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  }
  *a3 = v9;
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v11);
  return 0;
}

void sub_18B3DB448(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  switch(a2)
  {
    case 6:
      int v11 = __cxa_begin_catch(a1);
      if (v11[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v11 + 24))(v11);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      int v11 = __cxa_begin_catch(a1);
      unsigned int v13 = v11[36];
      if (v13 > 0x1A) {
        goto LABEL_6;
      }
      int v14 = 1 << v13;
      if ((v14 & 0x800108) == 0 && (v14 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      int v12 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v12 + 24))(v12);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v15);
      }
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18B3DB410);
}

void sub_18B3DB5DC(_Unwind_Exception *a1)
{
}

uint64_t SecCodeSignerAddSignature(uint64_t a1, Security::CodeSigning::SecStaticCode *a2, int a3)
{
  return SecCodeSignerAddSignatureWithErrors(a1, a2, a3);
}

uint64_t SecCodeSignerAddSignatureWithErrors(uint64_t a1, Security::CodeSigning::SecStaticCode *a2, int a3)
{
  if ((a3 & 0xEFFFFFFF) != 0)
  {
    uint64_t v3 = 4294900226;
    goto LABEL_6;
  }
  uint64_t v3 = 4294900225;
  if (!a1
  {
LABEL_6:
    Security::MacOSError::throwMe((Security::MacOSError *)v3);
  }
  uint64_t v8 = v6;
  uint64_t v9 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::required(a2, v7);
  Security::CodeSigning::SecCodeSigner::sign(v8, v9, a3);
  return 0;
}

void *Security::CodeSigning::SecStaticCode::required(Security::CodeSigning::SecStaticCode *this, const __SecCode *a2)
{
  if (!this
  {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  }
  return result;
}

CFDateRef Security::CodeSigning::copyCutOffDate(const __CFString *this, const __CFString *a2, CFAbsoluteTime a3)
{
  CFDateRef v4 = CFDateCreate(0, a3);
  CFDateRef v5 = (const __CFDate *)CFPreferencesCopyValue(this, @"com.apple.security.syspolicy", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  if (!v5)
  {
    CFRetain(v4);
    CFDateRef v8 = v4;
    if (!v4) {
      return v8;
    }
    goto LABEL_7;
  }
  CFDateRef v6 = v5;
  CFTypeID v7 = CFGetTypeID(v5);
  CFDateRef v8 = v4;
  if (v7 == CFDateGetTypeID())
  {
    if (CFDateCompare(v4, v6, 0) <= kCFCompareEqualTo) {
      CFDateRef v8 = v4;
    }
    else {
      CFDateRef v8 = v6;
    }
  }
  CFRetain(v8);
  CFRelease(v6);
  if (v4) {
LABEL_7:
  }
    CFRelease(v4);
  return v8;
}

const void **Security::CFRef<__CFDate const*>::~CFRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void Security::CodeSigning::SecCode::checkValidity(Security::CodeSigning::SecCode *this, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!*((void *)this + 2)) {
    return;
  }
  Security::CodeSigning::SecCode::checkValidity(*((Security::CodeSigning::SecCode **)this + 2), a2);
  if (!*((unsigned char *)this + 24))
  {
    (*(void (**)(Security::CodeSigning::SecCode *))(*(void *)this + 80))(this);
    *((unsigned char *)this + 24) = 1;
  }
  uint64_t v4 = *((void *)this + 4);
  *(_DWORD *)(v4 + 208) = a2;
  uint64_t v5 = *((void *)this + 2);
  if (!*(unsigned char *)(v5 + 24))
  {
    (*(void (**)(void))(*(void *)v5 + 80))(*((void *)this + 2));
    *(unsigned char *)(v5 + 24) = 1;
  }
  CFDateRef v6 = *(Security::CodeSigning::SecStaticCode **)(v5 + 32);
  Security::CodeSigning::SecStaticCode::validateNonResourceComponents((UInt8 *)v4);
  if ((a2 & 0x10) != 0)
  {
    uint64_t v9 = *(void *)(v4 + 32);
    std::string::size_type v10 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v4, 1);
    *(void *)&__p[8] = 0;
    *(void *)&__p[16] = 0;
    *(void *)std::string __p = &__p[8];
    (*(void (**)(uint64_t, const UInt8 *, unsigned char *, uint64_t))(*(void *)v9 + 224))(v9, v10, __p, a2);
  }
  else
  {
    if ((a2 & 0x2000) == 0) {
      goto LABEL_12;
    }
    uint64_t v7 = *(void *)(v4 + 32);
    CFDateRef v8 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v4, 1);
    *(void *)&__p[8] = 0;
    *(void *)&__p[16] = 0;
    *(void *)std::string __p = &__p[8];
    (*(void (**)(uint64_t, const UInt8 *, unsigned char *, uint64_t))(*(void *)v7 + 232))(v7, v8, __p, a2);
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(void **)&__p[8]);
LABEL_12:
  int v11 = (*(uint64_t (**)(void, Security::CodeSigning::SecCode *))(**((void **)this + 2) + 104))(*((void *)this + 2), this);
  if ((v11 & 1) == 0)
  {
    char v12 = os_variant_allows_internal_security_policies();
    char v13 = (v11 & 0x4000000) != 0 ? v12 : 1;
    if ((v11 & 0x10000000) == 0 || (v13 & 1) == 0) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA09);
    }
  }
  if (!*((unsigned char *)this + 24))
  {
    (*(void (**)(Security::CodeSigning::SecCode *))(*(void *)this + 80))(this);
    *((unsigned char *)this + 24) = 1;
  }
  int v14 = (const void *)*((void *)this + 5);
  if (v14)
  {
    std::string v15 = (const void *)Security::CodeSigning::SecStaticCode::cdHash((Security::CodeSigning::SecStaticCode *)v4);
    if (!CFEqual(v14, v15))
    {
      uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(v4 + 32) + 48))(*(void *)(v4 + 32));
      long long v17 = secLogObjForScope("SecCode");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        if (!*((unsigned char *)this + 24))
        {
          (*(void (**)(Security::CodeSigning::SecCode *))(*(void *)this + 80))(this);
          *((unsigned char *)this + 24) = 1;
        }
        uint64_t v18 = *((void *)this + 5);
        uint64_t v19 = Security::CodeSigning::SecStaticCode::cdHash((Security::CodeSigning::SecStaticCode *)v4);
        *(_DWORD *)std::string __p = 138412802;
        *(void *)&__p[4] = v16;
        *(_WORD *)&__p[12] = 2112;
        *(void *)&__p[14] = v18;
        *(_WORD *)&__p[22] = 2112;
        uint64_t v21 = v19;
        _os_log_impl(&dword_18B299000, v17, OS_LOG_TYPE_DEFAULT, "cdhash mismatch: %@, %@, %@", __p, 0x20u);
      }
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA26);
    }
  }
  if (*(void *)(*((void *)this + 2) + 16))
  {
    Security::CodeSigning::SecStaticCode::validateRequirements((Security::CodeSigning::SecStaticCode *)v4, 1, v6, 4294900249);
    Security::CodeSigning::SecStaticCode::validateRequirements(v6, 2, (Security::CodeSigning::SecStaticCode *)v4, 0);
  }
  Security::CodeSigning::SecCode::checkValidity::_DTFrameCODESIGN_EVAL_DYNAMIC::~_DTFrameCODESIGN_EVAL_DYNAMIC();
}

void sub_18B3DBF54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void Security::CodeSigning::SecCode::autoLocateGuest(Security::CodeSigning::SecCode *this, const __CFDictionary *a2)
{
}

const void **non-virtual thunk to'Security::CodeSigning::BundleDiskRep::createRawComponents@<X0>(Security::CodeSigning::BundleDiskRep *this@<X0>, uint64_t a2@<X8>)
{
  return Security::CodeSigning::BundleDiskRep::createRawComponents((Security::CodeSigning::BundleDiskRep *)((char *)this - 16), a2);
}

const void **Security::CodeSigning::BundleDiskRep::createRawComponents@<X0>(Security::CodeSigning::BundleDiskRep *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = a2 + 8;
  int v12 = 0;
  do
  {
    CFDataRef v11 = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
    uint64_t v5 = Security::CodeSigning::CodeDirectory::canonicalSlotName(v4);
    if (v5)
    {
      CFDataRef v11 = Security::CodeSigning::BundleDiskRep::metaData(this, v5);
      if (v11)
      {
        CFDateRef v6 = std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t **)a2, (int)v4, &v12);
        Security::CFRef<__CFData const*>::operator=((CFTypeRef *)v6 + 5, (CFTypeRef *)&v11);
      }
    }
    else
    {
      CFDataRef v11 = 0;
    }
    Security::CFRef<__CFData const*>::~CFRef((const void **)&v11);
    uint64_t v4 = (Security::CodeSigning::CodeDirectory *)(v4 + 1);
    int v12 = (int)v4;
  }
  while (v4 != 11);
  uint64_t v7 = 4096;
  int v12 = 4096;
  do
  {
    CFDataRef v11 = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
    CFDateRef v8 = Security::CodeSigning::CodeDirectory::canonicalSlotName((Security::CodeSigning::CodeDirectory *)v7);
    if (v8)
    {
      CFDataRef v11 = Security::CodeSigning::BundleDiskRep::metaData(this, v8);
      if (v11)
      {
        uint64_t v9 = std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t **)a2, v7, &v12);
        Security::CFRef<__CFData const*>::operator=((CFTypeRef *)v9 + 5, (CFTypeRef *)&v11);
      }
    }
    else
    {
      CFDataRef v11 = 0;
    }
    CFDataRef result = Security::CFRef<__CFData const*>::~CFRef((const void **)&v11);
    uint64_t v7 = (v7 + 1);
    int v12 = v7;
  }
  while (v7 != 4101);
  return result;
}

void sub_18B3DC140(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  CFDateRef v6 = a1 + 1;
  uint64_t v5 = a1[1];
  uint64_t v7 = a1 + 1;
  CFDateRef v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        CFDateRef v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a2) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    void v12[2] = 0xAAAAAAAAAAAAAA01;
    std::string::size_type v10 = operator new(0x30uLL);
    v12[1] = v6;
    void v10[8] = *a3;
    *((void *)v10 + 5) = 0;
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(a1, (uint64_t)v8, v7, (uint64_t *)v10);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)v12);
    return (uint64_t **)v10;
  }
  return v8;
}

void Security::CodeSigning::BundleDiskRep::writer(Security::CodeSigning::BundleDiskRep *this)
{
}

void sub_18B3DC388(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&a9);
  std::__tree<std::string>::destroy(*v11);
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer(v10);
  Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer((void *)(v9 + 24));
  MEMORY[0x18C12D390](v9, 0x10A1C4026A71BB4);
  _Unwind_Resume(a1);
}

void std::__tree<std::string>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::string>::destroy(*(void *)a1);
    std::__tree<std::string>::destroy(*((void *)a1 + 1));
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

uint64_t Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 8);
  v5[0] = a1 + 8;
  v5[1] = 0xAAAAAAAAAAAAAA01;
  uint64_t v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (v3) {
    Security::UnixError::throwMe(v3);
  }
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::release_internal(a1);
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v5);
  Security::Mutex::~Mutex(v2);
  return a1;
}

void sub_18B3DC4A8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(void *a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 1);
  v5[0] = a1 + 1;
  v5[1] = 0xAAAAAAAAAAAAAA01;
  uint64_t v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if (v3) {
    Security::UnixError::throwMe(v3);
  }
  if (*a1 && atomic_fetch_add_explicit((atomic_uint *volatile)(*a1 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    if (*a1) {
      (*(void (**)(void))(*(void *)*a1 + 8))(*a1);
    }
    *a1 = 0;
  }
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v5);
  Security::Mutex::~Mutex(v2);
  return a1;
}

uint64_t Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::release_internal(uint64_t result)
{
  if (*(void *)result
    && atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)result + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v1 = (void *)result;
    CFDataRef result = *(void *)result;
    if (result) {
      CFDataRef result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
    *uint64_t v1 = 0;
  }
  return result;
}

void Security::CodeSigning::BundleDiskRep::Writer::flush(Security::CodeSigning::BundleDiskRep::Writer *this)
{
  __b[136] = *(DIR **)MEMORY[0x1E4F143B8];
  (*(void (**)(void))(**((void **)this + 12) + 48))(*((void *)this + 12));
  memset(__b, 170, 0x440uLL);
  uint64_t v2 = *((void *)this + 3);
  if (*(char *)(v2 + 55) < 0) {
    std::string::__init_copy_ctor_external(&v12, *(const std::string::value_type **)(v2 + 32), *(void *)(v2 + 40));
  }
  else {
    std::string v12 = *(std::string *)(v2 + 32);
  }
  Security::CodeSigning::DirScanner::DirScanner((uint64_t)__b, &v12);
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
  if (LOBYTE(__b[135]))
  {
    uint64_t v3 = (char *)this + 176;
    uint64_t v4 = (char *)this + 184;
    while (1)
    {
      Next = Security::CodeSigning::DirScanner::getNext(__b);
      if (!Next) {
        break;
      }
      if (!Security::CodeSigning::DirScanner::isRegularFile((Security::CodeSigning::DirScanner *)__b, Next)) {
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA3ALL);
      }
      d_name = Next->d_name;
      std::string::basic_string[abi:ne180100]<0>(__p, d_name);
      uint64_t v7 = (char *)std::__tree<std::string>::find<std::string>((uint64_t)v3, __p);
      if (v11 < 0) {
        operator delete(__p[0]);
      }
      if (v4 == v7)
      {
        int v8 = dirfd(__b[3]);
        if (unlinkat(v8, d_name, 0) == -1)
        {
          uint64_t v9 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v9);
        }
      }
    }
  }
  Security::CodeSigning::DirScanner::~DirScanner((Security::CodeSigning::DirScanner *)__b);
}

void sub_18B3DC770(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
}

void *std::__tree<std::string>::find<std::string>(uint64_t a1, void *a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = (void *)(a1 + 8);
  do
  {
    char v6 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v3 + 4, a2);
    if (v6 >= 0) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = v3 + 1;
    }
    if (v6 >= 0) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v2
    || (std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, v5 + 4) & 0x80) != 0)
  {
    return v2;
  }
  return v5;
}

uint64_t std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, void *a2)
{
  size_t v2 = a1[1];
  if (*((char *)a1 + 23) >= 0)
  {
    size_t v3 = *((unsigned __int8 *)a1 + 23);
  }
  else
  {
    a1 = (void *)*a1;
    size_t v3 = v2;
  }
  size_t v4 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (void *)*a2;
    size_t v5 = v4;
  }
  if (v5 >= v3) {
    size_t v6 = v3;
  }
  else {
    size_t v6 = v5;
  }
  int v7 = memcmp(a1, a2, v6);
  if (v7)
  {
    if ((v7 & 0x80000000) == 0) {
      return 1;
    }
  }
  else
  {
    if (v3 == v5) {
      return 0;
    }
    if (v3 >= v5) {
      return 1;
    }
  }
  return 255;
}

void Security::CodeSigning::BundleDiskRep::Writer::remove(Security::CodeSigning::BundleDiskRep::Writer *this)
{
  (*(void (**)(void))(**((void **)this + 12) + 40))(*((void *)this + 12));
  size_t v2 = 0;
  do
  {
    Security::CodeSigning::BundleDiskRep::Writer::remove((const char **)this, v2);
    size_t v2 = (Security::CodeSigning::CodeDirectory *)(v2 + 1);
  }
  while (v2 != 12);

  Security::CodeSigning::BundleDiskRep::Writer::remove((const char **)this, (Security::CodeSigning::CodeDirectory *)0x10000);
}

void Security::CodeSigning::BundleDiskRep::Writer::remove(const char **this, Security::CodeSigning::CodeDirectory *a2)
{
  size_t v3 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
  if (v3)
  {
    Security::CodeSigning::BundleDiskRep::metaPath(&v10, this[3], v3);
    int v4 = SHIBYTE(v10.__r_.__value_.__r.__words[2]);
    size_t v5 = (void *)v10.__r_.__value_.__r.__words[0];
    if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v6 = &v10;
    }
    else {
      size_t v6 = (std::string *)v10.__r_.__value_.__r.__words[0];
    }
    int v7 = unlink((const char *)v6);
    int v8 = v7;
    if (v4 < 0)
    {
      operator delete(v5);
      if (!v8) {
        return;
      }
    }
    else if (!v7)
    {
      return;
    }
    if (*__error() != 2)
    {
      uint64_t v9 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v9);
    }
  }
}

void Security::CodeSigning::BundleDiskRep::Writer::component(Security::CodeSigning::BundleDiskRep::Writer *this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
  if (a2 == 3)
  {
    size_t v5 = "CodeResources";
LABEL_8:
    uint64_t v8 = *((void *)this + 3);
    memset(&__str, 170, sizeof(__str));
    Security::CodeSigning::BundleDiskRep::metaPath(&__str, (const char *)v8, 0);
    if (!*(unsigned char *)(v8 + 56))
    {
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_str = &__str;
      }
      else {
        p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      if (mkdir((const char *)p_str, 0x1EDu))
      {
        if (*__error() != 17)
        {
          std::string v10 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v10);
        }
      }
      else
      {
        CFURLRef v11 = (const __CFURL *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 48))(v8);
        Security::cfStringRelease((Security *)__p, v11);
        if (v19 >= 0) {
          std::string v12 = __p;
        }
        else {
          std::string v12 = (void **)__p[0];
        }
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          char v13 = &__str;
        }
        else {
          char v13 = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        copyfile((const char *)v12, (const char *)v13, 0, 3u);
        if (v19 < 0) {
          operator delete(__p[0]);
        }
        std::string::operator=((std::string *)(v8 + 32), &__str);
        *(unsigned char *)(v8 + 56) = 1;
      }
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    memset(&__str, 170, sizeof(__str));
    Security::CodeSigning::BundleDiskRep::metaPath(&__str, *((const char **)this + 3), v5);
    unint64_t v17 = 0xAAAAAAAAFFFFFFFFLL;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v14 = &__str;
    }
    else {
      int v14 = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v17, (const char *)v14, 1537, 420);
    BytePtr = (char *)CFDataGetBytePtr(a3);
    CFIndex Length = CFDataGetLength(a3);
    Security::UnixPlusPlus::FileDesc::writeAll((ssize_t)&v17, BytePtr, Length);
    Security::UnixPlusPlus::FileDesc::close((Security::UnixPlusPlus::FileDesc *)&v17);
    std::string::basic_string[abi:ne180100]<0>(__p, v5);
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>((uint64_t **)this + 22, __p, (uint64_t)__p);
    if (v19 < 0) {
      operator delete(__p[0]);
    }
    Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v17);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    return;
  }
  size_t v6 = (unsigned char *)*((void *)this + 12);
  if (v6[20])
  {
    size_t v5 = (char *)Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
    if (!v5) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
    }
    goto LABEL_8;
  }
  int v7 = *(void (**)(void))(*(void *)v6 + 16);

  v7();
}

void sub_18B3DCC4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>(uint64_t **a1, void *a2, uint64_t a3)
{
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  CFDataRef result = std::__tree<std::string>::__find_equal<std::string>((uint64_t)a1, &v9, a2);
  if (!*result)
  {
    size_t v6 = (uint64_t **)result;
    int v7 = operator new(0x38uLL);
    _DWORD v7[2] = *(_OWORD *)a3;
    *((void *)v7 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    uint64_t v8 = v9;
    return std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(a1, v8, v6, (uint64_t *)v7);
  }
  return result;
}

void *std::__tree<std::string>::__find_equal<std::string>(uint64_t a1, void *a2, void *a3)
{
  size_t v5 = (void *)(a1 + 8);
  int v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        int v7 = v4;
        uint64_t v8 = v4 + 4;
        if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a3, v4 + 4) & 0x80) == 0) {
          break;
        }
        int v4 = (void *)*v7;
        size_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v8, a3) & 0x80) == 0) {
        break;
      }
      size_t v5 = v7 + 1;
      int v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    int v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

void Security::CodeSigning::BundleDiskRep::Writer::~Writer(char **this)
{
  *this = (char *)&unk_1ED84A070;
  std::__tree<std::string>::destroy(this[23]);
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer((uint64_t)(this + 12));
  Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(this + 3);

  JUMPOUT(0x18C12D390);
}

{
  *this = (char *)&unk_1ED84A070;
  std::__tree<std::string>::destroy(this[23]);
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer((uint64_t)(this + 12));
  Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(this + 3);
}

uint64_t Security::CodeSigning::BundleDiskRep::appleInternalForcePlatform(Security::CodeSigning::BundleDiskRep *this)
{
  return *((unsigned __int8 *)this + 232);
}

CFDataRef Security::CodeSigning::BundleDiskRep::allowedResourceOmissions(CFBundleRef *this)
{
  std::string::basic_string[abi:ne180100]<0>(&v20, "^");
  Security::CodeSigning::BundleDiskRep::resourcesRelativePath((Security::CodeSigning::BundleDiskRep *)__p, this);
  if ((v19 & 0x80u) == 0) {
    size_t v2 = __p;
  }
  else {
    size_t v2 = (void **)__p[0];
  }
  if ((v19 & 0x80u) == 0) {
    std::string::size_type v3 = v19;
  }
  else {
    std::string::size_type v3 = (std::string::size_type)__p[1];
  }
  int v4 = std::string::append(&v20, (const std::string::value_type *)v2, v3);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  size_t v6 = std::string::append(&v21, ".*\\.lproj/locversion.plist$", 0x1BuLL);
  long long v14 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  int64_t v23 = v6->__r_.__value_.__r.__words[2];
  long long v22 = v14;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  std::string v15 = &v22;
  if (v23 < 0) {
    std::string v15 = (long long *)v22;
  }
  CFDataRef v16 = Security::cfmake<__CFArray const*>((uint64_t)v6, v7, v8, v9, v10, v11, v12, v13, (uint64_t)v15);
  if (SHIBYTE(v23) < 0) {
    operator delete((void *)v22);
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
  if ((char)v19 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  return v16;
}

void sub_18B3DCFE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (*(char *)(v28 - 25) < 0) {
    operator delete(*(void **)(v28 - 48));
  }
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::BundleDiskRep::resourcesRelativePath(Security::CodeSigning::BundleDiskRep *this, CFBundleRef *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  p_str = &__str;
  memset(&__str, 170, sizeof(__str));
  (*((void (**)(std::string *__return_ptr, CFBundleRef *))*a2 + 7))(&__str, a2);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int64_t size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  }
  else {
    int64_t size = __str.__r_.__value_.__l.__size_;
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if (size >= 3)
  {
    size_t v6 = (char *)p_str + size;
    int64_t v7 = size;
    uint64_t v8 = p_str;
    do
    {
      uint64_t v9 = (char *)memchr(v8, 47, v7 - 2);
      if (!v9) {
        break;
      }
      if (*(_WORD *)v9 == 11823 && v9[2] == 47)
      {
        if (v9 != v6)
        {
          std::string::size_type v11 = v9 - (char *)p_str;
          if (v9 - (char *)p_str != -1)
          {
LABEL_17:
            uint64_t v12 = std::string::replace(&__str, v11, 2uLL, (const std::string::value_type *)&unk_18B41CA07, 0);
            std::string::operator=(&__str, v12);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              int64_t size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            }
            else {
              int64_t size = __str.__r_.__value_.__l.__size_;
            }
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v13 = &__str;
            }
            else {
              uint64_t v13 = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            if (size >= 3)
            {
              long long v14 = (char *)v13 + size;
              int64_t v15 = size;
              CFDataRef v16 = v13;
              while (1)
              {
                unint64_t v17 = (char *)memchr(v16, 47, v15 - 2);
                if (!v17) {
                  break;
                }
                if (*(_WORD *)v17 == 11823 && v17[2] == 47)
                {
                  if (v17 != v14)
                  {
                    std::string::size_type v11 = v17 - (char *)v13;
                    if (v17 - (char *)v13 != -1) {
                      goto LABEL_17;
                    }
                  }
                  goto LABEL_34;
                }
                CFDataRef v16 = (std::string *)(v17 + 1);
                int64_t v15 = v14 - (char *)v16;
                if (v14 - (char *)v16 < 3) {
                  goto LABEL_34;
                }
              }
            }
          }
        }
        break;
      }
      uint64_t v8 = (std::string *)(v9 + 1);
      int64_t v7 = v6 - (char *)v8;
    }
    while (v6 - (char *)v8 >= 3);
  }
LABEL_34:
  std::string::basic_string(&v35, &__str, size - 2, 2uLL, (std::allocator<char> *)v38);
  std::string::size_type v19 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
  if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v19 = v35.__r_.__value_.__l.__size_;
  }
  if (v19 != 2)
  {
    BOOL v21 = 0;
    if ((SHIBYTE(v35.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_40;
    }
LABEL_43:
    operator delete(v35.__r_.__value_.__l.__data_);
    if (!v21) {
      goto LABEL_49;
    }
    goto LABEL_44;
  }
  std::string v20 = (std::string *)v35.__r_.__value_.__r.__words[0];
  if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string v20 = &v35;
  }
  BOOL v21 = LOWORD(v20->__r_.__value_.__l.__data_) == 11823;
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_43;
  }
LABEL_40:
  if (!v21) {
    goto LABEL_49;
  }
LABEL_44:
  std::string::size_type v22 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v22 = __str.__r_.__value_.__l.__size_;
  }
  std::string::basic_string(&v35, &__str, 0, v22 - 2, (std::allocator<char> *)v38);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  std::string __str = v35;
LABEL_49:
  *((void *)this + 1) = 0xAAAAAAAAAAAAAAAALL;
  int64_t v23 = (void *)((char *)this + 8);
  *((void *)this + 2) = 0xAAAAAAAAAAAAAAAALL;
  *(void *)this = 0xAAAAAAAAAAAAAAAALL;
  CFURLRef v24 = CFBundleCopyResourcesDirectoryURL(a2[3]);
  Security::cfStringRelease(this, v24);
  uint64_t v25 = *((unsigned __int8 *)this + 23);
  if ((v25 & 0x80u) == 0) {
    uint64_t v26 = *((unsigned __int8 *)this + 23);
  }
  else {
    uint64_t v26 = *((void *)this + 1);
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v27 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v27 = __str.__r_.__value_.__l.__size_;
  }
  if (v26 == v27)
  {
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v28 = &__str;
    }
    else {
      uint64_t v28 = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    if ((v25 & 0x80) == 0)
    {
      if (*((unsigned char *)this + 23))
      {
        uint64_t v29 = this;
        while (*(unsigned __int8 *)v29 == v28->__r_.__value_.__s.__data_[0])
        {
          uint64_t v29 = (Security::CodeSigning::BundleDiskRep *)((char *)v29 + 1);
          uint64_t v28 = (std::string *)((char *)v28 + 1);
          if (!--v25) {
            goto LABEL_64;
          }
        }
        goto LABEL_66;
      }
LABEL_64:
      *((unsigned char *)this + 23) = 0;
LABEL_74:
      *(unsigned char *)this = 0;
      goto LABEL_75;
    }
    ssize_t v30 = *(Security::CodeSigning::BundleDiskRep **)this;
    if (!memcmp(*(const void **)this, v28, *((void *)this + 1)))
    {
      *int64_t v23 = 0;
      this = v30;
      goto LABEL_74;
    }
  }
LABEL_66:
  if (std::string::compare((const std::string *)this, 0, v27, &__str, 0, v27)) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
  }
  std::string::size_type v31 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v31 = __str.__r_.__value_.__l.__size_;
  }
  std::string::basic_string(&v35, (const std::string *)this, v31 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v37);
  char v32 = std::string::append(&v35, "/", 1uLL);
  std::string::size_type v33 = v32->__r_.__value_.__r.__words[0];
  *(void *)long long v38 = v32->__r_.__value_.__l.__size_;
  *(void *)&v38[7] = *(std::string::size_type *)((char *)&v32->__r_.__value_.__r.__words[1] + 7);
  char v34 = HIBYTE(v32->__r_.__value_.__r.__words[2]);
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  if (*((char *)this + 23) < 0) {
    operator delete(*(void **)this);
  }
  *(void *)this = v33;
  *int64_t v23 = *(void *)v38;
  *(void *)((char *)this + 15) = *(void *)&v38[7];
  *((unsigned char *)this + 23) = v34;
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
LABEL_75:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_18B3DD47C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFDataRef Security::cfmake<__CFArray const*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = &a9;
  v11[0] = "['^(.*/)?\\.DS_Store$''^Info\\.plist$''^PkgInfo$'%s]";
  v11[1] = &v10;
  _OWORD v11[2] = 0;
  int v12 = 0;
  return Security::CFMake::make((Security::CFMake *)v11);
}

void Security::CodeSigning::BundleDiskRep::strictValidateStructure(uint64_t a1, Security::CodeSigning::CodeDirectory *this, void *a3, int a4)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  if ((a4 & 0x4000000) == 0)
  {
    if (Security::CodeSigning::CodeDirectory::slotIsPresent(this, -3)) {
      std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)(a1 + 184), 3u, 3);
    }
    v70[0] = 0;
    v70[1] = 0;
    size_t v69 = v70;
    uint64_t v8 = *(void **)(a1 + 184);
    if (v8 != (void *)(a1 + 192))
    {
      do
      {
        uint64_t v9 = (Security::CodeSigning::CodeDirectory *)*((unsigned int *)v8 + 7);
        if (v9 != 1)
        {
          uint64_t v10 = (char *)Security::CodeSigning::CodeDirectory::canonicalSlotName(v9);
          if (v10)
          {
            std::string::basic_string[abi:ne180100]<0>(__p, v10);
            std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>((uint64_t **)&v69, __p, (uint64_t)__p);
            if (SHIBYTE(__p[2]) < 0) {
              operator delete(__p[0]);
            }
          }
        }
        std::string::size_type v11 = (void *)v8[1];
        if (v11)
        {
          do
          {
            int v12 = v11;
            std::string::size_type v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            int v12 = (void *)v8[2];
            BOOL v13 = *v12 == (void)v8;
            uint64_t v8 = v12;
          }
          while (!v13);
        }
        uint64_t v8 = v12;
      }
      while (v12 != (void *)(a1 + 192));
    }
    long long v14 = (Security::CodeSigning **)(a1 + 32);
    int64_t v15 = (Security::CodeSigning *)(a1 + 32);
    if (*(char *)(a1 + 55) < 0) {
      int64_t v15 = *v14;
    }
    BOOL v16 = Security::CodeSigning::pathFileSystemUsesXattrFiles(v15, v7);
    memset(__p, 170, sizeof(__p));
    if (*(char *)(a1 + 55) < 0)
    {
      std::string::__init_copy_ctor_external(&v68, *(const std::string::value_type **)(a1 + 32), *(void *)(a1 + 40));
    }
    else
    {
      *(_OWORD *)&v68.__r_.__value_.__l.__data_ = *(_OWORD *)v14;
      v68.__r_.__value_.__r.__words[2] = *(void *)(a1 + 48);
    }
    Security::CodeSigning::DirScanner::DirScanner((uint64_t)__p, &v68);
    if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v68.__r_.__value_.__l.__data_);
    }
    if (LOBYTE(__p[135]))
    {
      while (1)
      {
        while (1)
        {
          do
          {
            Next = Security::CodeSigning::DirScanner::getNext((DIR **)__p);
            if (!Next) {
              goto LABEL_57;
            }
            if (!Security::CodeSigning::DirScanner::isRegularFile((Security::CodeSigning::DirScanner *)__p, Next)) {
              Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA3ALL);
            }
            d_name = Next->d_name;
            std::string::basic_string[abi:ne180100]<0>(&v72, Next->d_name);
            std::string::size_type v19 = (char **)std::__tree<std::string>::find<std::string>((uint64_t)&v69, &v72);
            if (SHIBYTE(v72.st_gid) < 0) {
              operator delete(*(void **)&v72.st_dev);
            }
          }
          while (v70 != v19);
          if (!strcmp(d_name, "CodeSignature")) {
            break;
          }
          if (!v16) {
            goto LABEL_56;
          }
          if (*(char *)(a1 + 55) >= 0) {
            size_t v20 = *(unsigned __int8 *)(a1 + 55);
          }
          else {
            size_t v20 = *(void *)(a1 + 40);
          }
          memset(&v72, 170, 24);
          std::string::basic_string[abi:ne180100]((uint64_t)&v72, v20 + 1);
          if ((v72.st_gid & 0x80000000) == 0) {
            BOOL v21 = &v72;
          }
          else {
            BOOL v21 = *(stat **)&v72.st_dev;
          }
          if (v20)
          {
            if (*(char *)(a1 + 55) >= 0) {
              std::string::size_type v22 = (const void *)(a1 + 32);
            }
            else {
              std::string::size_type v22 = *(const void **)(a1 + 32);
            }
            memmove(v21, v22, v20);
          }
          *(_WORD *)((char *)&v21->st_dev + v20) = 47;
          std::string::size_type v23 = strlen(d_name);
          CFURLRef v24 = std::string::append((std::string *)&v72, d_name, v23);
          long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
          std::string::size_type v66 = v24->__r_.__value_.__r.__words[2];
          *(_OWORD *)size_t v65 = v25;
          v24->__r_.__value_.__l.__size_ = 0;
          v24->__r_.__value_.__r.__words[2] = 0;
          v24->__r_.__value_.__r.__words[0] = 0;
          int IsValidXattrFile = Security::CodeSigning::pathIsValidXattrFile((char *)v65, "bundlediskrep");
          if (SHIBYTE(v66) < 0) {
            operator delete(v65[0]);
          }
          if (SHIBYTE(v72.st_gid) < 0)
          {
            operator delete(*(void **)&v72.st_dev);
            if (!IsValidXattrFile) {
              goto LABEL_56;
            }
          }
          else if (!IsValidXattrFile)
          {
            goto LABEL_56;
          }
          ssize_t v30 = secLogObjForScope("bundlediskrep");
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            v72.st_dev = 136315138;
            *(void *)&v72.st_mode = d_name;
            _os_log_debug_impl(&dword_18B299000, v30, OS_LOG_TYPE_DEBUG, "meta directory validation on xattr file skipped: %s", (uint8_t *)&v72, 0xCu);
          }
        }
        CFNumberRef v67 = (Security::UnixPlusPlus::FileDesc *)0xAAAAAAAAFFFFFFFFLL;
        Security::CodeSigning::BundleDiskRep::metaPath((std::string *)&v72, (const char *)a1, "CodeSignature");
        if ((v72.st_gid & 0x80000000) == 0) {
          std::string::size_type v27 = &v72;
        }
        else {
          std::string::size_type v27 = *(stat **)&v72.st_dev;
        }
        Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v67, (const char *)v27, 0, 438);
        if (SHIBYTE(v72.st_gid) < 0) {
          operator delete(*(void **)&v72.st_dev);
        }
        v28.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
        v28.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
        *(timespec *)&v72.st_blkint64_t size = v28;
        *(timespec *)v72.st_qspare = v28;
        v72.st_birthtimespeCC_SHA512_CTX c = v28;
        *(timespec *)&v72.st_int64_t size = v28;
        v72.st_mtimespeCC_SHA512_CTX c = v28;
        v72.st_ctimespeCC_SHA512_CTX c = v28;
        *(timespec *)&v72.st_uid = v28;
        v72.st_atimespeCC_SHA512_CTX c = v28;
        *(timespec *)&v72.st_dev = v28;
        Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)v67, &v72);
        st_int64_t size = v72.st_size;
        Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v67);
        if (st_size) {
LABEL_56:
        }
          std::__tree<int>::__emplace_unique_key_args<int,int const&>((uint64_t *)(a1 + 208), -67014, -67014);
      }
    }
LABEL_57:
    Security::CodeSigning::DirScanner::~DirScanner((Security::CodeSigning::DirScanner *)__p);
    std::__tree<std::string>::destroy(v70[0]);
  }
  memset(__p, 170, 24);
  CFURLRef v31 = (const __CFURL *)(*(uint64_t (**)(uint64_t, Security::CodeSigning::CodeDirectory *))(*(void *)a1 + 48))(a1, this);
  Security::cfStringRelease((Security *)__p, v31);
  v65[0] = (Security::UnixPlusPlus::FileDesc *)0xAAAAAAAAFFFFFFFFLL;
  if (SHIBYTE(__p[2]) >= 0) {
    char v32 = __p;
  }
  else {
    char v32 = (void **)__p[0];
  }
  Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)v65, (const char *)v32, 0, 438);
  if ((a4 & 0x1000000) != 0)
  {
    std::string::size_type v33 = (Security::UnixPlusPlus::FileDesc *)LODWORD(v65[0]);
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute((Security::UnixPlusPlus::FileDesc *)LODWORD(v65[0]), "com.apple.ResourceFork"))
    {
      Security::UnixPlusPlus::FileDesc::removeAttr(v33, "com.apple.ResourceFork");
    }
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute(v33, "com.apple.FinderInfo")) {
      Security::UnixPlusPlus::FileDesc::removeAttr(v33, "com.apple.FinderInfo");
    }
  }
  if ((a4 & 0x200) != 0)
  {
    char v34 = (Security::UnixPlusPlus::FileDesc *)LODWORD(v65[0]);
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute((Security::UnixPlusPlus::FileDesc *)LODWORD(v65[0]), "com.apple.ResourceFork"))
    {
      long long v59 = __p;
      if (SHIBYTE(__p[2]) < 0) {
        long long v59 = (void **)__p[0];
      }
      CFStringRef v60 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Disallowed xattr %s found on %s", "com.apple.ResourceFork", v59);
      Security::CodeSigning::CSError::throwMe((Security::CodeSigning::CSError *)0xFFFEFA49, @"SecCSResourceHasSidebandData", v60, v61);
    }
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute(v34, "com.apple.FinderInfo"))
    {
      uint64_t v62 = __p;
      if (SHIBYTE(__p[2]) < 0) {
        uint64_t v62 = (void **)__p[0];
      }
      CFStringRef v63 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Disallowed xattr %s found on %s", "com.apple.FinderInfo", v62);
      Security::CodeSigning::CSError::throwMe((Security::CodeSigning::CSError *)0xFFFEFA49, @"SecCSResourceHasSidebandData", v63, v64);
    }
  }
  memset(&v72, 0, 24);
  std::string v35 = *(void **)(a1 + 208);
  long long v36 = (void *)(a1 + 216);
  uint64_t v39 = (int *)*a3;
  char v37 = (int *)(a3 + 1);
  long long v38 = v39;
  CFTypeID v40 = (uint64_t *)&v72;
  v68.__r_.__value_.__r.__words[0] = (std::string::size_type)&v72;
  if (v35 != (void *)(a1 + 216))
  {
    if (v38 == v37)
    {
LABEL_96:
      size_t v69 = (char **)v40;
      if (v35 != v36)
      {
        do
        {
          std::back_insert_iterator<std::vector<int>>::operator=[abi:ne180100]((uint64_t *)&v69, *((_DWORD *)v35 + 7));
          SecTrustRef v51 = (void *)v35[1];
          if (v51)
          {
            do
            {
              char v52 = v51;
              SecTrustRef v51 = (void *)*v51;
            }
            while (v51);
          }
          else
          {
            do
            {
              char v52 = (void *)v35[2];
              BOOL v13 = *v52 == (void)v35;
              std::string v35 = v52;
            }
            while (!v13);
          }
          std::string v35 = v52;
        }
        while (v52 != v36);
      }
    }
    else
    {
      while (1)
      {
        int v41 = *((_DWORD *)v35 + 7);
        int v42 = v38[7];
        if (v41 >= v42)
        {
          if (v42 >= v41)
          {
            unint64_t v47 = (void *)v35[1];
            if (v47)
            {
              do
              {
                int v48 = v47;
                unint64_t v47 = (void *)*v47;
              }
              while (v47);
            }
            else
            {
              do
              {
                int v48 = (void *)v35[2];
                BOOL v13 = *v48 == (void)v35;
                std::string v35 = v48;
              }
              while (!v13);
            }
            unsigned int v49 = (int *)*((void *)v38 + 1);
            if (v49)
            {
              do
              {
                long long v38 = v49;
                unsigned int v49 = *(int **)v49;
              }
              while (v49);
            }
            else
            {
              do
              {
                uint64_t v50 = v38;
                long long v38 = (int *)*((void *)v38 + 2);
              }
              while (*(int **)v38 != v50);
            }
            std::string v35 = v48;
          }
          else
          {
            CFAllocatorRef v45 = (int *)*((void *)v38 + 1);
            if (v45)
            {
              do
              {
                long long v38 = v45;
                CFAllocatorRef v45 = *(int **)v45;
              }
              while (v45);
            }
            else
            {
              do
              {
                int v46 = v38;
                long long v38 = (int *)*((void *)v38 + 2);
              }
              while (*(int **)v38 != v46);
            }
          }
        }
        else
        {
          std::back_insert_iterator<std::vector<int>>::operator=[abi:ne180100]((uint64_t *)&v68, v41);
          unsigned int v43 = (void *)v35[1];
          if (v43)
          {
            do
            {
              std::string v35 = v43;
              unsigned int v43 = (void *)*v43;
            }
            while (v43);
          }
          else
          {
            do
            {
              uint64_t v44 = v35;
              std::string v35 = (void *)v35[2];
            }
            while ((void *)*v35 != v44);
          }
        }
        if (v35 == v36) {
          break;
        }
        if (v38 == v37)
        {
          CFTypeID v40 = (uint64_t *)v68.__r_.__value_.__r.__words[0];
          goto LABEL_96;
        }
      }
    }
  }
  if (*(void *)&v72.st_dev != v72.st_ino)
  {
    uint64_t v53 = **(unsigned int **)&v72.st_dev;
    goto LABEL_123;
  }
  if ((a4 & 0x100) != 0 && !*(unsigned char *)(a1 + 73))
  {
    uint64_t v53 = 4294900294;
    uint64_t v54 = *(void *)v37;
    if (!*(void *)v37) {
      goto LABEL_123;
    }
    long long v55 = v37;
    do
    {
      int v56 = *(_DWORD *)(v54 + 28);
      BOOL v57 = v56 < 256;
      if (v56 >= 256) {
        size_t v58 = (uint64_t *)v54;
      }
      else {
        size_t v58 = (uint64_t *)(v54 + 8);
      }
      if (!v57) {
        long long v55 = (int *)v54;
      }
      uint64_t v54 = *v58;
    }
    while (*v58);
    if (v55 == v37 || v55[7] >= 257) {
LABEL_123:
    }
      Security::MacOSError::throwMe((Security::MacOSError *)v53);
  }
  if (*(void *)&v72.st_dev)
  {
    v72.st_ino = *(void *)&v72.st_dev;
    operator delete(*(void **)&v72.st_dev);
  }
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)v65);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
}

void sub_18B3DDCE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,char *a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
}

uint64_t *std::back_insert_iterator<std::vector<int>>::operator=[abi:ne180100](uint64_t *a1, int a2)
{
  uint64_t v4 = *a1;
  size_t v6 = *(_DWORD **)(*a1 + 8);
  unint64_t v5 = *(void *)(*a1 + 16);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = *(_DWORD **)v4;
    uint64_t v9 = ((uint64_t)v6 - *(void *)v4) >> 2;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62) {
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      BOOL v13 = (char *)operator new(4 * v12);
    }
    else
    {
      BOOL v13 = 0;
    }
    long long v14 = &v13[4 * v9];
    *(_DWORD *)long long v14 = a2;
    int64_t v7 = v14 + 4;
    while (v6 != v8)
    {
      int v15 = *--v6;
      *((_DWORD *)v14 - 1) = v15;
      v14 -= 4;
    }
    *(void *)uint64_t v4 = v14;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = &v13[4 * v12];
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *size_t v6 = a2;
    int64_t v7 = v6 + 1;
  }
  *(void *)(v4 + 8) = v7;
  return a1;
}

uint64_t *std::__tree<int>::__emplace_unique_key_args<int,int const&>(uint64_t *result, int a2, int a3)
{
  uint64_t v4 = (uint64_t **)result;
  size_t v6 = (uint64_t **)(result + 1);
  unint64_t v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int64_t v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        unint64_t v5 = *v7;
        size_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      unint64_t v5 = v7[1];
      if (!v5)
      {
        size_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int64_t v7 = (uint64_t **)(result + 1);
LABEL_9:
    uint64_t v9 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v9 + 7) = a3;
    return std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(v4, (uint64_t)v7, v6, v9);
  }
  return result;
}

uint64_t Security::CodeSigning::BundleDiskRep::strictValidate(void **a1)
{
  ((void (*)(void **))(*a1)[29])(a1);
  size_t v2 = *(uint64_t (**)(void))(*a1[13] + 224);

  return v2();
}

uint64_t Security::CodeSigning::BundleDiskRep::pageSize(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 216))();
}

uint64_t Security::CodeSigning::BundleDiskRep::defaultRequirements(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 208))();
}

CFDataRef Security::CodeSigning::BundleDiskRep::defaultResourceRules(uint64_t a1, uint64_t a2)
{
  memset(v143, 170, sizeof(v143));
  Security::CodeSigning::BundleDiskRep::resourcesRelativePath((Security::CodeSigning::BundleDiskRep *)v143, (CFBundleRef *)a1);
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v4 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v138, "^");
    if (SHIBYTE(v143[2]) >= 0) {
      unint64_t v5 = (const std::string::value_type *)v143;
    }
    else {
      unint64_t v5 = (const std::string::value_type *)v143[0];
    }
    if (SHIBYTE(v143[2]) >= 0) {
      std::string::size_type v6 = HIBYTE(v143[2]);
    }
    else {
      std::string::size_type v6 = (std::string::size_type)v143[1];
    }
    int64_t v7 = std::string::append(v4, v5, v6);
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    uint64_t v9 = std::string::append(&v140, ".*\\.lproj/", 0xAuLL);
    long long v17 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t v142 = v9->__r_.__value_.__r.__words[2];
    long long v141 = v17;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    uint64_t v18 = &v141;
    if (v142 < 0) {
      uint64_t v18 = (long long *)v141;
    }
    CFDataRef v19 = Security::cfmake<__CFDictionary const*>((uint64_t)"{rules={'^.*' = #T%s = {optional=#T, weight=1000}'^.*/.*\\.pkg/' = {omit=#T, weight=10000}}}", v10, v11, v12, v13, v14, v15, v16, (uint64_t)v18);
    if (SHIBYTE(v142) < 0) {
      operator delete((void *)v141);
    }
    if (SHIBYTE(v140.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v140.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v139) < 0)
    {
      size_t v20 = (void *)v138;
LABEL_138:
      operator delete(v20);
      goto LABEL_142;
    }
    goto LABEL_142;
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2) & 0x10) != 0)
  {
    uint64_t v83 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v140, "^");
    if (SHIBYTE(v143[2]) >= 0) {
      CFNumberRef v84 = (const std::string::value_type *)v143;
    }
    else {
      CFNumberRef v84 = (const std::string::value_type *)v143[0];
    }
    if (SHIBYTE(v143[2]) >= 0) {
      std::string::size_type v85 = HIBYTE(v143[2]);
    }
    else {
      std::string::size_type v85 = (std::string::size_type)v143[1];
    }
    uint64_t v86 = std::string::append(v83, v84, v85);
    long long v87 = *(_OWORD *)&v86->__r_.__value_.__l.__data_;
    int64_t v142 = v86->__r_.__value_.__r.__words[2];
    long long v141 = v87;
    v86->__r_.__value_.__l.__size_ = 0;
    v86->__r_.__value_.__r.__words[2] = 0;
    v86->__r_.__value_.__r.__words[0] = 0;
    if (v142 >= 0) {
      uint64_t v88 = &v141;
    }
    else {
      uint64_t v88 = (long long *)v141;
    }
    int v89 = (std::string *)std::string::basic_string[abi:ne180100]<0>(v135, "^");
    if (SHIBYTE(v143[2]) >= 0) {
      int v90 = (const std::string::value_type *)v143;
    }
    else {
      int v90 = (const std::string::value_type *)v143[0];
    }
    if (SHIBYTE(v143[2]) >= 0) {
      std::string::size_type v91 = HIBYTE(v143[2]);
    }
    else {
      std::string::size_type v91 = (std::string::size_type)v143[1];
    }
    int v92 = std::string::append(v89, v90, v91);
    long long v93 = *(_OWORD *)&v92->__r_.__value_.__l.__data_;
    v137.__r_.__value_.__r.__words[2] = v92->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v93;
    v92->__r_.__value_.__l.__size_ = 0;
    v92->__r_.__value_.__r.__words[2] = 0;
    v92->__r_.__value_.__r.__words[0] = 0;
    uint64_t v94 = std::string::append(&v137, ".*\\.lproj/", 0xAuLL);
    long long v95 = *(_OWORD *)&v94->__r_.__value_.__l.__data_;
    std::string::size_type v139 = v94->__r_.__value_.__r.__words[2];
    long long v138 = v95;
    v94->__r_.__value_.__l.__size_ = 0;
    v94->__r_.__value_.__r.__words[2] = 0;
    v94->__r_.__value_.__r.__words[0] = 0;
    std::string::basic_string[abi:ne180100]<0>(&v131, "^");
    if (SHIBYTE(v143[2]) >= 0) {
      CFNumberRef v96 = (const std::string::value_type *)v143;
    }
    else {
      CFNumberRef v96 = (const std::string::value_type *)v143[0];
    }
    if (SHIBYTE(v143[2]) >= 0) {
      std::string::size_type v97 = HIBYTE(v143[2]);
    }
    else {
      std::string::size_type v97 = (std::string::size_type)v143[1];
    }
    uint64_t v98 = std::string::append(&v131, v96, v97);
    long long v99 = *(_OWORD *)&v98->__r_.__value_.__l.__data_;
    v132.__r_.__value_.__r.__words[2] = v98->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v132.__r_.__value_.__l.__data_ = v99;
    v98->__r_.__value_.__l.__size_ = 0;
    v98->__r_.__value_.__r.__words[2] = 0;
    v98->__r_.__value_.__r.__words[0] = 0;
    uint64_t v100 = std::string::append(&v132, ".*\\.lproj/locversion.plist$", 0x1BuLL);
    long long v101 = *(_OWORD *)&v100->__r_.__value_.__l.__data_;
    std::string::size_type v134 = v100->__r_.__value_.__r.__words[2];
    long long v133 = v101;
    v100->__r_.__value_.__l.__size_ = 0;
    v100->__r_.__value_.__r.__words[2] = 0;
    v100->__r_.__value_.__r.__words[0] = 0;
    CFDataRef v19 = Security::cfmake<__CFDictionary const*>((uint64_t)"{rules={'^version.plist$' = #T%s = #T%s = {optional=#T, weight=1000}%s = {omit=#T, weight=1100}}}", v102, v103, v104, v105, v106, v107, v108, (uint64_t)v88);
    goto LABEL_122;
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2) & 8) != 0)
  {
    v109 = "{rules={'^.*' = #T'^Info\\.plist$' = {omit=#T,weight=10}}}";
LABEL_141:
    CFDataRef v19 = Security::cfmake<__CFDictionary const*>((uint64_t)v109, v21, v22, v23, v24, v25, v26, v27, v111);
    goto LABEL_142;
  }
  timespec v28 = (void *)HIBYTE(v143[2]);
  if (SHIBYTE(v143[2]) < 0) {
    timespec v28 = v143[1];
  }
  if (!v28)
  {
    v109 = "{rules={'^version.plist$' = #T'^.*' = #T'^.*\\.lproj/' = {optional=#T, weight=1000}'^Base\\.lproj/' = {weight"
           "=1010}'^.*\\.lproj/locversion.plist$' = {omit=#T, weight=1100}},rules2={'^.*' = #T'.*\\.dSYM($|/)' = {weight="
           "11}'^(.*/)?\\.DS_Store$' = {omit=#T,weight=2000}'^Info\\.plist$' = {omit=#T, weight=20}'^version\\.plist$' = "
           "{weight=20}'^embedded\\.provisionprofile$' = {weight=20}'^PkgInfo$' = {omit=#T, weight=20}'^.*\\.lproj/' = {o"
           "ptional=#T, weight=1000}'^Base\\.lproj/' = {weight=1010}'^.*\\.lproj/locversion.plist$' = {omit=#T, weight=1100}}}";
    goto LABEL_141;
  }
  uint64_t v29 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v140, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    ssize_t v30 = (const std::string::value_type *)v143;
  }
  else {
    ssize_t v30 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v31 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v31 = (std::string::size_type)v143[1];
  }
  char v32 = std::string::append(v29, v30, v31);
  long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  int64_t v142 = v32->__r_.__value_.__r.__words[2];
  long long v141 = v33;
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  if (v142 >= 0) {
    char v34 = &v141;
  }
  else {
    char v34 = (long long *)v141;
  }
  std::string v35 = (std::string *)std::string::basic_string[abi:ne180100]<0>(v135, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    long long v36 = (const std::string::value_type *)v143;
  }
  else {
    long long v36 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v37 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v37 = (std::string::size_type)v143[1];
  }
  long long v38 = std::string::append(v35, v36, v37);
  long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
  v137.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v39;
  v38->__r_.__value_.__l.__size_ = 0;
  v38->__r_.__value_.__r.__words[2] = 0;
  v38->__r_.__value_.__r.__words[0] = 0;
  CFTypeID v40 = std::string::append(&v137, ".*\\.lproj/", 0xAuLL);
  long long v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
  std::string::size_type v139 = v40->__r_.__value_.__r.__words[2];
  long long v138 = v41;
  v40->__r_.__value_.__l.__size_ = 0;
  v40->__r_.__value_.__r.__words[2] = 0;
  v40->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(&v131, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    int v42 = (const std::string::value_type *)v143;
  }
  else {
    int v42 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v43 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v43 = (std::string::size_type)v143[1];
  }
  uint64_t v44 = std::string::append(&v131, v42, v43);
  long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
  v132.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v132.__r_.__value_.__l.__data_ = v45;
  v44->__r_.__value_.__l.__size_ = 0;
  v44->__r_.__value_.__r.__words[2] = 0;
  v44->__r_.__value_.__r.__words[0] = 0;
  int v46 = std::string::append(&v132, "Base\\.lproj/", 0xCuLL);
  long long v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
  std::string::size_type v134 = v46->__r_.__value_.__r.__words[2];
  long long v133 = v47;
  v46->__r_.__value_.__l.__size_ = 0;
  v46->__r_.__value_.__r.__words[2] = 0;
  v46->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(&v127, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    int v48 = (const std::string::value_type *)v143;
  }
  else {
    int v48 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v49 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v49 = (std::string::size_type)v143[1];
  }
  uint64_t v50 = std::string::append(&v127, v48, v49);
  long long v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
  v128.__r_.__value_.__r.__words[2] = v50->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v128.__r_.__value_.__l.__data_ = v51;
  v50->__r_.__value_.__l.__size_ = 0;
  v50->__r_.__value_.__r.__words[2] = 0;
  v50->__r_.__value_.__r.__words[0] = 0;
  char v52 = std::string::append(&v128, ".*\\.lproj/locversion.plist$", 0x1BuLL);
  long long v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
  std::string::size_type v130 = v52->__r_.__value_.__r.__words[2];
  long long v129 = v53;
  v52->__r_.__value_.__l.__size_ = 0;
  v52->__r_.__value_.__r.__words[2] = 0;
  v52->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(&v124, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    uint64_t v54 = (const std::string::value_type *)v143;
  }
  else {
    uint64_t v54 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v55 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v55 = (std::string::size_type)v143[1];
  }
  int v56 = std::string::append(&v124, v54, v55);
  long long v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
  std::string::size_type v126 = v56->__r_.__value_.__r.__words[2];
  long long v125 = v57;
  v56->__r_.__value_.__l.__size_ = 0;
  v56->__r_.__value_.__r.__words[2] = 0;
  v56->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(&v120, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    size_t v58 = (const std::string::value_type *)v143;
  }
  else {
    size_t v58 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v59 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v59 = (std::string::size_type)v143[1];
  }
  CFStringRef v60 = std::string::append(&v120, v58, v59);
  long long v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
  v121.__r_.__value_.__r.__words[2] = v60->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v121.__r_.__value_.__l.__data_ = v61;
  v60->__r_.__value_.__l.__size_ = 0;
  v60->__r_.__value_.__r.__words[2] = 0;
  v60->__r_.__value_.__r.__words[0] = 0;
  uint64_t v62 = std::string::append(&v121, ".*\\.lproj/", 0xAuLL);
  long long v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
  std::string::size_type v123 = v62->__r_.__value_.__r.__words[2];
  long long v122 = v63;
  v62->__r_.__value_.__l.__size_ = 0;
  v62->__r_.__value_.__r.__words[2] = 0;
  v62->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(&v116, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    size_t v64 = (const std::string::value_type *)v143;
  }
  else {
    size_t v64 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v65 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v65 = (std::string::size_type)v143[1];
  }
  std::string::size_type v66 = std::string::append(&v116, v64, v65);
  long long v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
  v117.__r_.__value_.__r.__words[2] = v66->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v117.__r_.__value_.__l.__data_ = v67;
  v66->__r_.__value_.__l.__size_ = 0;
  v66->__r_.__value_.__r.__words[2] = 0;
  v66->__r_.__value_.__r.__words[0] = 0;
  std::string v68 = std::string::append(&v117, "Base\\.lproj/", 0xCuLL);
  long long v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
  std::string::size_type v119 = v68->__r_.__value_.__r.__words[2];
  long long v118 = v69;
  v68->__r_.__value_.__l.__size_ = 0;
  v68->__r_.__value_.__r.__words[2] = 0;
  v68->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(&v112, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    int64_t v70 = (const std::string::value_type *)v143;
  }
  else {
    int64_t v70 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v71 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v71 = (std::string::size_type)v143[1];
  }
  stat v72 = std::string::append(&v112, v70, v71);
  long long v73 = *(_OWORD *)&v72->__r_.__value_.__l.__data_;
  v113.__r_.__value_.__r.__words[2] = v72->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v113.__r_.__value_.__l.__data_ = v73;
  v72->__r_.__value_.__l.__size_ = 0;
  v72->__r_.__value_.__r.__words[2] = 0;
  v72->__r_.__value_.__r.__words[0] = 0;
  CFNumberRef v74 = std::string::append(&v113, ".*\\.lproj/locversion.plist$", 0x1BuLL);
  long long v75 = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
  std::string::size_type v115 = v74->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v75;
  v74->__r_.__value_.__l.__size_ = 0;
  v74->__r_.__value_.__r.__words[2] = 0;
  v74->__r_.__value_.__r.__words[0] = 0;
  CFDataRef v19 = Security::cfmake<__CFDictionary const*>((uint64_t)"{rules={'^version.plist$' = #T%s = #T%s = {optional=#T, weight=1000}%s = {weight=1010}%s = {omit=#T, weight=1100}},rules2={'^.*' = #T'^[^/]+$' = {nested=#T, weight=10}'^(Frameworks|SharedFrameworks|PlugIns|Plug-ins|XPCServices|Helpers|MacOS|Library/(Automator|Spotlight|LoginItems))/' = {nested=#T, weight=10}'.*\\.dSYM($|/)' = {weight=11}'^(.*/)?\\.DS_Store$' = {omit=#T,weight=2000}'^Info\\.plist$' = {omit=#T, weight=20}'^version\\.plist$' = {weight=20}'^embedded\\.provisionprofile$' = {weight=20}'^PkgInfo$' = {omit=#T, weight=20}%s = {weight=20}%s = {optional=#T, weight=1000}%s = {weight=1010}%s = {omit=#T, weight=1100}}}", v76, v77, v78, v79, v80, v81, v82, (uint64_t)v34);
  if (SHIBYTE(v115) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v113.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v113.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v112.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v119) < 0) {
    operator delete((void *)v118);
  }
  if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v117.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v116.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v123) < 0) {
    operator delete((void *)v122);
  }
  if (SHIBYTE(v121.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v121.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v120.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v126) < 0) {
    operator delete((void *)v125);
  }
  if (SHIBYTE(v124.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v124.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v130) < 0) {
    operator delete((void *)v129);
  }
  if (SHIBYTE(v128.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v128.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v127.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v127.__r_.__value_.__l.__data_);
  }
LABEL_122:
  if (SHIBYTE(v134) < 0) {
    operator delete((void *)v133);
  }
  if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v132.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v131.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v131.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v139) < 0) {
    operator delete((void *)v138);
  }
  if (SHIBYTE(v137.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v137.__r_.__value_.__l.__data_);
  }
  if (v136 < 0) {
    operator delete(v135[0]);
  }
  if (SHIBYTE(v142) < 0) {
    operator delete((void *)v141);
  }
  if (SHIBYTE(v140.__r_.__value_.__r.__words[2]) < 0)
  {
    size_t v20 = (void *)v140.__r_.__value_.__r.__words[0];
    goto LABEL_138;
  }
LABEL_142:
  if (SHIBYTE(v143[2]) < 0) {
    operator delete(v143[0]);
  }
  return v19;
}

void sub_18B3DE96C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,void *a62,uint64_t a63)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a55 < 0) {
    operator delete(a50);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (a72 < 0) {
    operator delete(a69);
  }
  if (a67 < 0) {
    operator delete(a62);
  }
  if (a61 < 0) {
    operator delete(a56);
  }
  if (a76 < 0) {
    operator delete(a75);
  }
  if (a74 < 0) {
    operator delete(a73);
  }
  if (a82 < 0) {
    operator delete(a81);
  }
  if (a80 < 0) {
    operator delete(a79);
  }
  if (a78 < 0) {
    operator delete(a77);
  }
  if (*(char *)(v86 - 233) < 0) {
    operator delete(*(void **)(v86 - 256));
  }
  if (a86 < 0) {
    operator delete(a85);
  }
  if (a84 < 0) {
    operator delete(a83);
  }
  if (*(char *)(v86 - 153) < 0) {
    operator delete(*(void **)(v86 - 176));
  }
  if (*(char *)(v86 - 185) < 0) {
    operator delete(*(void **)(v86 - 208));
  }
  if (*(char *)(v86 - 209) < 0) {
    operator delete(*(void **)(v86 - 232));
  }
  if (*(char *)(v86 - 89) < 0) {
    operator delete(*(void **)(v86 - 112));
  }
  if (*(char *)(v86 - 121) < 0) {
    operator delete(*(void **)(v86 - 144));
  }
  if (*(char *)(v86 - 65) < 0) {
    operator delete(*(void **)(v86 - 88));
  }
  _Unwind_Resume(a1);
}

CFDataRef Security::cfmake<__CFDictionary const*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = &a9;
  v11[0] = a1;
  v11[1] = &v10;
  _OWORD v11[2] = 0;
  int v12 = 0;
  return Security::CFMake::make((Security::CFMake *)v11);
}

void Security::CodeSigning::BundleDiskRep::explicitIdentifier(CFBundleRef *this@<X0>, std::string *a2@<X8>)
{
  CFStringRef Identifier = CFBundleGetIdentifier(this[3]);
  if (Identifier
    || (CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(this[3])) != 0
    && (CFStringRef Identifier = (const __CFString *)CFDictionaryGetValue(InfoDictionary, (const void *)*MEMORY[0x1E4F1D008])) != 0)
  {
    Security::cfString(a2, Identifier);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(a2, (char *)&unk_18B41CA07);
  }
}

void Security::CodeSigning::BundleDiskRep::recommendedIdentifier(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  memset(v8, 170, sizeof(v8));
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 192))(v8);
  uint64_t v4 = (void *)HIBYTE(v8[2]);
  if (SHIBYTE(v8[2]) < 0) {
    uint64_t v4 = v8[1];
  }
  if (v4)
  {
    *(_OWORD *)a2 = *(_OWORD *)v8;
    *(void **)(a2 + 16) = v8[2];
  }
  else
  {
    CFURLRef v5 = (const __CFURL *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
    Security::cfStringRelease((Security *)__p, v5);
    Security::CodeSigning::DiskRep::canonicalIdentifier((std::string *)a2, (uint64_t)__p);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v8[2]) < 0) {
      operator delete(v8[0]);
    }
  }
}

void sub_18B3DEDBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

CFTypeRef Security::CodeSigning::BundleDiskRep::copyStapledTicket(Security::CodeSigning::BundleDiskRep *this)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  memset(v25, 170, sizeof(v25));
  CFURLRef v1 = (const __CFURL *)(*(uint64_t (**)(Security::CodeSigning::BundleDiskRep *))(*(void *)this + 48))(this);
  Security::cfStringRelease((Security *)v25, v1);
  v2.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v29.st_blkint64_t size = v2;
  *(timespec *)v29.st_qspare = v2;
  v29.st_birthtimespeCC_SHA512_CTX c = v2;
  *(timespec *)&v29.st_int64_t size = v2;
  v29.st_mtimespeCC_SHA512_CTX c = v2;
  v29.st_ctimespeCC_SHA512_CTX c = v2;
  *(timespec *)&v29.st_uid = v2;
  v29.st_atimespeCC_SHA512_CTX c = v2;
  *(timespec *)&v29.st_dev = v2;
  int64_t v27 = 0xAAAAAAAAAAAAAAAALL;
  CFTypeRef cf = 0;
  if (SHIBYTE(v25[2]) >= 0) {
    size_t v3 = HIBYTE(v25[2]);
  }
  else {
    size_t v3 = (size_t)v25[1];
  }
  __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  __p[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v3 + 23);
  if (v27 < 0) {
    uint64_t v4 = (void **)__p[0];
  }
  if (v3)
  {
    if (SHIBYTE(v25[2]) >= 0) {
      CFURLRef v5 = v25;
    }
    else {
      CFURLRef v5 = (void **)v25[0];
    }
    memmove(v4, v5, v3);
  }
  strcpy((char *)v4 + v3, "/Contents/CodeResources");
  std::string::size_type v6 = secLogObjForScope("notarization");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v23 = v25;
    if (SHIBYTE(v25[2]) < 0) {
      uint64_t v23 = (void **)v25[0];
    }
    *(_DWORD *)long long buf = 136315138;
    off_t v31 = (off_t)v23;
    _os_log_debug_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEBUG, "Extracting ticket from bundle: %s", buf, 0xCu);
  }
  if (v27 >= 0) {
    char v7 = __p;
  }
  else {
    char v7 = (void **)__p[0];
  }
  int v8 = open((const char *)v7, 0);
  int v9 = v8;
  if (v8 > 0)
  {
    if (fstat(v8, &v29))
    {
      uint64_t v10 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = *__error();
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v31) = v11;
        int v12 = "unable to stat stapling file: %d";
        uint64_t v13 = v10;
        uint32_t v14 = 8;
LABEL_28:
        _os_log_impl(&dword_18B299000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
      }
LABEL_29:
      close(v9);
      goto LABEL_30;
    }
    if ((__int16)v29.st_mode < 0)
    {
      st_int64_t size = v29.st_size;
      if (v29.st_size > 0x7FFFFFFF)
      {
        uint64_t v24 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_29;
        }
        *(_DWORD *)long long buf = 134217984;
        off_t v31 = v29.st_size;
        int v12 = "ticket size was too large: %lld";
        uint64_t v13 = v24;
        uint32_t v14 = 12;
        goto LABEL_28;
      }
      uint64_t v21 = (UInt8 *)malloc_type_malloc(v29.st_size, 0xA9C3E540uLL);
      if (v21)
      {
        if (read(v9, v21, st_size) == st_size)
        {
          CFDataRef v22 = CFDataCreateWithBytesNoCopy(0, v21, st_size, (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
          if (cf) {
            CFRelease(cf);
          }
          CFTypeRef cf = v22;
          if (v22) {
            goto LABEL_29;
          }
          long long v17 = secLogObjForScope("SecError");
          if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_29;
          }
          *(_WORD *)long long buf = 0;
          int v12 = "unable to create cfdata for notarization";
        }
        else
        {
          long long v17 = secLogObjForScope("SecError");
          if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_29;
          }
          *(_WORD *)long long buf = 0;
          int v12 = "unable to read entire ticket from bundle";
        }
      }
      else
      {
        long long v17 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_29;
        }
        *(_WORD *)long long buf = 0;
        int v12 = "unable to allocate data for ticket";
      }
    }
    else
    {
      long long v17 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_29;
      }
      *(_WORD *)long long buf = 0;
      int v12 = "stapling is not a regular file";
    }
    uint64_t v13 = v17;
    uint32_t v14 = 2;
    goto LABEL_28;
  }
  if (*__error() != 2)
  {
    uint64_t v15 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = *__error();
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v31) = v16;
      _os_log_impl(&dword_18B299000, v15, OS_LOG_TYPE_DEFAULT, "cannot open stapled file for reading: %d", buf, 8u);
    }
  }
  if (v9) {
    goto LABEL_29;
  }
LABEL_30:
  CFTypeRef v18 = cf;
  CFTypeRef cf = 0;
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  Security::CFRef<__CFData const*>::~CFRef(&cf);
  if (SHIBYTE(v25[2]) < 0) {
    operator delete(v25[0]);
  }
  return v18;
}

void sub_18B3DF274(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,const void *a22)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  Security::CFRef<__CFData const*>::~CFRef(&a22);
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

const void **Security::CodeSigning::BundleDiskRep::registerStapledTicket(Security::CodeSigning::BundleDiskRep *this)
{
  size_t v3 = (Security::CodeSigning *)(*(uint64_t (**)(Security::CodeSigning::BundleDiskRep *))(*(void *)this
                                                                                                  + 176))(this);
  Security::CodeSigning::registerStapledTicketWithSystem(v3, v1);
  return Security::CFRef<__CFData const*>::~CFRef((const void **)&v3);
}

uint64_t Security::CodeSigning::BundleDiskRep::copyDiskRepInformation(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 160))();
}

uint64_t Security::CodeSigning::BundleDiskRep::flush(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 152))();
}

uint64_t Security::CodeSigning::BundleDiskRep::fd(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 144))();
}

__CFArray *Security::CodeSigning::BundleDiskRep::modifiedFiles(Security::CodeSigning::BundleDiskRep *this)
{
  CFArrayRef v6 = (const __CFArray *)(*(uint64_t (**)(void))(**((void **)this + 13) + 136))(*((void *)this + 13));
  CFMutableStringRef MutableCopy = CFArrayCreateMutableCopy(0, 0, v6);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, 0);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)0x10000);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)3);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)4);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)5);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)7);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)6);
  uint64_t v2 = 4096;
  do
  {
    Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)v2);
    uint64_t v2 = (v2 + 1);
  }
  while (v2 != 4101);
  size_t v3 = MutableCopy;
  CFMutableStringRef MutableCopy = 0;
  Security::CFRef<__CFArray *>::~CFRef((const void **)&MutableCopy);
  Security::CFRef<__CFArray const*>::~CFRef((const void **)&v6);
  return v3;
}

void sub_18B3DF4A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Security::CFRef<__CFArray const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::BundleDiskRep::checkModifiedFile(Security::CodeSigning::BundleDiskRep *this, __CFArray *a2, Security::CodeSigning::CodeDirectory *a3)
{
  CFArrayRef v6 = (const void *)(*(uint64_t (**)(void, Security::CodeSigning::CodeDirectory *))(**((void **)this + 13)
                                                                                               + 24))(*((void *)this + 13), a3);
  if (v6)
  {
    CFRelease(v6);
  }
  else
  {
    char v7 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a3);
    if (v7)
    {
      memset(&__sz, 170, sizeof(__sz));
      Security::CodeSigning::BundleDiskRep::metaPath(&__sz, (const char *)this, v7);
      int v8 = SHIBYTE(__sz.__r_.__value_.__r.__words[2]);
      int v9 = (std::string::value_type *)__sz.__r_.__value_.__r.__words[0];
      if ((__sz.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_sz = &__sz;
      }
      else {
        p_sz = (std::string *)__sz.__r_.__value_.__r.__words[0];
      }
      if (!access((const char *)p_sz, 0))
      {
        if (v8 < 0) {
          std::string::__init_copy_ctor_external(&__p, v9, __sz.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = __sz;
        }
        int v12 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? (Security *)&__p
            : (Security *)__p.__r_.__value_.__r.__words[0];
        CFURLRef CFURL = Security::makeCFURL(v12, 0, 0, v11);
        CFArrayAppendValue(a2, CFURL);
        Security::CFRef<__CFURL const*>::~CFRef((const void **)&CFURL);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      if (v8 < 0) {
        operator delete(v9);
      }
    }
  }
}

void sub_18B3DF620(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  operator delete(v16);
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::BundleDiskRep::execSegLimit(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 112))();
}

uint64_t Security::CodeSigning::BundleDiskRep::execSegBase(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 104))();
}

uint64_t Security::CodeSigning::BundleDiskRep::signingLimit(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 96))();
}

uint64_t Security::CodeSigning::BundleDiskRep::signingBase(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 88))();
}

uint64_t Security::CodeSigning::BundleDiskRep::mainExecutableImage(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 80))();
}

uint64_t Security::CodeSigning::BundleDiskRep::prepareForSigning(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 72))();
}

void Security::CodeSigning::BundleDiskRep::adjustResources(Security::CodeSigning::BundleDiskRep *this, Security::CodeSigning::ResourceBuilder *a2)
{
  std::string::basic_string[abi:ne180100]<0>(&__str, "^_CodeSignature$");
  Security::CodeSigning::ResourceBuilder::addExclusion();
}

void sub_18B3DFA8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (*(char *)(v33 - 73) < 0) {
    operator delete(*(void **)(v33 - 96));
  }
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (*(char *)(v33 - 49) < 0) {
    operator delete(*(void **)(v33 - 72));
  }
  if (*(char *)(v33 - 25) < 0) {
    operator delete(*(void **)(v33 - 48));
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::ResourceBuilder::addExclusion()
{
}

void sub_18B3DFD6C(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Security::CodeSigning::ResourceBuilder::Rule *>>(unint64_t a1)
{
  if (a1 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a1);
}

const void **Security::CodeSigning::BundleDiskRep::resourcesRootPath@<X0>(CFBundleRef *this@<X0>, Security *a2@<X8>)
{
  CFURLRef v3 = CFBundleCopySupportFilesDirectoryURL(this[3]);

  return Security::cfStringRelease(a2, v3);
}

uint64_t Security::CodeSigning::BundleDiskRep::identification(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 32))();
}

void Security::CodeSigning::DirValidator::require()
{
}

void sub_18B3DFEC8(_Unwind_Exception *a1)
{
  MEMORY[0x18C12D390](v1, 0x10F2C405152D04CLL);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::DirValidator::allow()
{
}

void sub_18B3DFF6C(_Unwind_Exception *a1)
{
  MEMORY[0x18C12D390](v1, 0x10F2C405152D04CLL);
  _Unwind_Resume(a1);
}

void ___ZN8Security11CodeSigning13BundleDiskRep21validateFrameworkRootENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEE_block_invoke(uint64_t a1@<X0>, std::string::value_type *a2@<X1>, std::string *a3@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(&v22, "^(\\./)?Versions/");
  int v8 = *(const std::string::value_type **)(a1 + 32);
  uint64_t v7 = a1 + 32;
  CFArrayRef v6 = v8;
  int v9 = *(char *)(v7 + 23);
  if (v9 >= 0) {
    uint64_t v10 = (const std::string::value_type *)v7;
  }
  else {
    uint64_t v10 = v6;
  }
  if (v9 >= 0) {
    std::string::size_type v11 = *(unsigned __int8 *)(v7 + 23);
  }
  else {
    std::string::size_type v11 = *(void *)(v7 + 8);
  }
  int v12 = std::string::append(&v22, v10, v11);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  uint32_t v14 = std::string::append(&v23, "/", 1uLL);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  Security::CodeSigning::ResourceBuilder::escapeRE(&__p, a2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  CFTypeRef v18 = std::string::append(&v24, (const std::string::value_type *)p_p, size);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  size_t v20 = std::string::append(&v25, "$", 1uLL);
  *a3 = *v20;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
}

void sub_18B3E0104(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (*(char *)(v33 - 41) < 0) {
    operator delete(*(void **)(v33 - 64));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN8Security11CodeSigning12DirValidator5allowERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEjS8__block_invoke(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 32), *(void *)(a1 + 40));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 32);
    a2->__r_.__value_.__r.__words[2] = *(void *)(a1 + 48);
  }
}

void __destroy_helper_block_e8_32c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
}

void __copy_helper_block_e8_32c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (std::string *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v3 = *(_OWORD *)(a2 + 32);
    v2->__r_.__value_.__r.__words[2] = *(void *)(a2 + 48);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

void ___ZN8Security11CodeSigning12DirValidator7requireERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEjS8__block_invoke(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 32), *(void *)(a1 + 40));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 32);
    a2->__r_.__value_.__r.__words[2] = *(void *)(a1 + 48);
  }
}

void Security::CodeSigning::DirValidator::addRule(char **a1, uint64_t a2)
{
  CFURLRef v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = *a1;
    uint64_t v8 = (v5 - *a1) >> 3;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int v12 = (char *)operator new(8 * v11);
    }
    else
    {
      int v12 = 0;
    }
    long long v13 = &v12[8 * v8];
    *(void *)long long v13 = a2;
    CFArrayRef v6 = v13 + 8;
    if (v5 != v7)
    {
      do
      {
        uint64_t v14 = *((void *)v5 - 1);
        v5 -= 8;
        *((void *)v13 - 1) = v14;
        v13 -= 8;
      }
      while (v5 != v7);
      CFURLRef v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v6;
    a1[2] = &v12[8 * v11];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *(void *)CFURLRef v5 = a2;
    CFArrayRef v6 = v5 + 8;
  }
  a1[1] = v6;
}

void Security::CodeSigning::CodeDirectory::Builder::Builder(Security::CodeSigning::CodeDirectory::Builder *this, Security::CodeSigning::CodeDirectory *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)this = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = (char *)this + 24;
  *((_DWORD *)this + 10) = -1;
  *((unsigned char *)this + 44) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_DWORD *)this + 19) = a2;
  *((unsigned char *)this + 80) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((void *)this + 27) = 0;
  *((void *)this + 26) = 0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 177) = 0u;
  *((void *)this + 25) = (char *)this + 208;
  *((_DWORD *)this + 56) = 0;
  *((void *)this + 29) = 0;
  Security::CodeSigning::CodeDirectory::hashFor(a2);
}

void sub_18B3E044C(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*(const void ***)(v1 + 208));
  if (*(char *)(v1 + 135) < 0) {
    operator delete(*(void **)(v1 + 112));
  }
  if (*(char *)(v1 + 111) < 0) {
    operator delete(*v4);
  }
  Security::UnixPlusPlus::FileDesc::closeAndLog(v2);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*v3);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::CodeDirectory::Builder::~Builder(Security::CodeSigning::CodeDirectory::Builder *this)
{
  if (*((char *)this + 135) < 0) {
    operator delete(*((void **)this + 14));
  }
  if (*((char *)this + 111) < 0) {
    operator delete(*((void **)this + 11));
  }
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::CodeDirectory::Builder *)((char *)this + 40));
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((void **)this + 3));
}

void Security::CodeSigning::CodeDirectory::Builder::specialSlot(Security::CodeSigning::CodeDirectory::Builder *this, unsigned int a2, const __CFData *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v6 = v3;
  long long v7 = v3;
  long long v4 = v3;
  long long v5 = v3;
  Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)*((unsigned int *)this + 19));
}

void sub_18B3E067C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unint64_t Security::CodeSigning::CodeDirectory::Builder::size(Security::CodeSigning::CodeDirectory::Builder *this, unsigned int a2)
{
  unint64_t v4 = *((void *)this + 7);
  if (v4) {
    goto LABEL_3;
  }
  v5.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v5.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v15.st_blkstd::string::size_type size = v5;
  *(timespec *)v15.st_qspare = v5;
  v15.st_birthtimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v15.st_std::string::size_type size = v5;
  v15.st_mtimespeCC_SHA512_CTX c = v5;
  v15.st_ctimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v15.st_uid = v5;
  v15.st_atimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v15.st_dev = v5;
  Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*((unsigned int *)this + 10), &v15);
  uint64_t v6 = *((void *)this + 6);
  unint64_t v4 = v15.st_size - v6;
  BOOL v7 = v15.st_size == v6;
  *((void *)this + 7) = v15.st_size - v6;
  if (!v7) {
LABEL_3:
  }
    unint64_t v4 = (v4 - 1) / *((void *)this + 8) + 1;
  *((void *)this + 18) = v4;
  uint64_t v8 = 96;
  if (a2 < 0x20500) {
    uint64_t v8 = 88;
  }
  if (a2 < 0x20400) {
    v8 -= 24;
  }
  if (a2 >= 0x20300) {
    unint64_t v9 = v8;
  }
  else {
    unint64_t v9 = v8 - 12;
  }
  if (a2 >> 9 < 0x101) {
    v9 -= 4;
  }
  if (*((char *)this + 111) < 0) {
    uint64_t v10 = *((void *)this + 12);
  }
  else {
    uint64_t v10 = *((unsigned __int8 *)this + 111);
  }
  uint64_t v11 = v9 + *((void *)this + 20) + v10 + 1;
  if (*((char *)this + 135) < 0)
  {
    uint64_t v12 = *((void *)this + 15);
    if (!v12) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  uint64_t v12 = *((unsigned __int8 *)this + 135);
  if (*((unsigned char *)this + 135)) {
LABEL_18:
  }
    v11 += v12 + 1;
LABEL_19:
  uint64_t v13 = *((unsigned int *)this + 21);
  unint64_t result = v11 + (*((void *)this + 17) + v4) * v13;
  if (*((unsigned char *)this + 192) || *((void *)this + 27)) {
    result += v4 * v13;
  }
  if (result <= v9) {
    Security::UnixError::throwMe((Security::UnixError *)8);
  }
  return result;
}

uint64_t Security::CodeSigning::CodeDirectory::Builder::build(Security::CodeSigning::CodeDirectory::Builder *this)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  if (*((char *)this + 111) < 0) {
    uint64_t v2 = *((void *)this + 12);
  }
  else {
    uint64_t v2 = *((unsigned __int8 *)this + 111);
  }
  uint64_t v3 = *((unsigned __int8 *)this + 135);
  if (*((char *)this + 135) < 0) {
    uint64_t v4 = *((void *)this + 15);
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)this + 135);
  }
  if (*((unsigned char *)this + 192) || *((void *)this + 27))
  {
    unsigned int v5 = 132352;
  }
  else
  {
    unsigned int v5 = 132352;
    if (!*((_DWORD *)this + 56))
    {
      if (*((void *)this + 22))
      {
        unsigned int v5 = 132096;
      }
      else if (*((_DWORD *)this + 15))
      {
        unsigned int v5 = 131840;
      }
      else
      {
        if ((v3 & 0x80) != 0) {
          uint64_t v3 = *((void *)this + 15);
        }
        if (v3) {
          unsigned int v5 = 131584;
        }
        else {
          unsigned int v5 = 131328;
        }
      }
    }
  }
  if (*((_DWORD *)this + 37)) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA44);
  }
  size_t v6 = Security::CodeSigning::CodeDirectory::Builder::size(this, v5);
  unsigned int v7 = v6;
  uint64_t v8 = (int8x8_t *)malloc_type_calloc(1uLL, v6, 0x39C17D27uLL);
  *((void *)this + 29) = v8;
  if (!v8) {
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  unint64_t v9 = (int8x16_t *)v8;
  v8->i32[0] = 34397946;
  v8->i32[1] = bswap32(v7);
  v8[1].i32[0] = bswap32(v5);
  v8[1].i32[1] = bswap32(*((_DWORD *)this + 18));
  unint64_t v8[3] = vrev32_s8((int8x8_t)vmovn_s64(*(int64x2_t *)((char *)this + 136)));
  unint64_t v10 = *((void *)this + 7);
  if (HIDWORD(v10))
  {
    void v8[7] = (int8x8_t)bswap64(v10);
    unsigned int v11 = -1;
  }
  else
  {
    unsigned int v11 = bswap32(v10);
  }
  size_t v12 = v2 + 1;
  v8[4].i32[0] = v11;
  v8[4].i8[5] = *((_DWORD *)this + 19);
  v8[4].i8[6] = *((unsigned char *)this + 80);
  v8[4].i8[4] = *((_DWORD *)this + 21);
  unint64_t v13 = *((void *)this + 8);
  frexp((double)v13, &__e);
  __int8 v14 = __e - 1;
  if (!v13) {
    __int8 v14 = 0;
  }
  v9[2].i8[7] = v14;
  void v9[4] = vrev64q_s8(*(int8x16_t *)((char *)this + 168));
  v9[5].i64[0] = bswap64(*((void *)this + 23));
  v9[5].i32[2] = bswap32(*((_DWORD *)this + 56));
  uint64_t v15 = 96;
  if (v5 < 0x20500) {
    uint64_t v15 = 88;
  }
  if (v5 < 0x20400) {
    v15 -= 24;
  }
  if (v5 < 0x20300) {
    v15 -= 12;
  }
  if (v5 >= 0x20200) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = v15 - 4;
  }
  long long v17 = (const void *)*((void *)this + 19);
  if (v17)
  {
    v9[2].i32[3] = bswap32(v16);
    memcpy(&v9->i8[v16], v17, *((void *)this + 20));
    v16 += *((void *)this + 20);
  }
  CFTypeRef v18 = (void *)((char *)this + 88);
  uint64_t v19 = *((void *)this + 29);
  *(_DWORD *)(v19 + 20) = bswap32(v16);
  if (*((char *)this + 111) < 0) {
    CFTypeRef v18 = (void *)*v18;
  }
  memcpy((void *)(v19 + v16), v18, v12);
  size_t v20 = v16 + v12;
  if (*((char *)this + 135) < 0)
  {
    if (!*((void *)this + 15)) {
      goto LABEL_43;
    }
  }
  else if (!*((unsigned char *)this + 135))
  {
    goto LABEL_43;
  }
  uint64_t v21 = (void *)((char *)this + 112);
  uint64_t v22 = *((void *)this + 29);
  *(_DWORD *)(v22 + 48) = bswap32(v20);
  unsigned int v23 = bswap32(*(_DWORD *)(v22 + 8));
  if (v20) {
    BOOL v24 = v23 >= 0x20200;
  }
  else {
    BOOL v24 = 0;
  }
  std::string v25 = (void *)(v22 + v20);
  if (v24) {
    uint64_t v26 = v25;
  }
  else {
    uint64_t v26 = 0;
  }
  if (*((char *)this + 135) < 0) {
    uint64_t v21 = (void *)*v21;
  }
  memcpy(v26, v21, v4 + 1);
  v20 += v4 + 1;
LABEL_43:
  if (*((unsigned char *)this + 192) || *((void *)this + 27))
  {
    uint64_t v27 = *((void *)this + 29);
    *(_DWORD *)(v27 + 92) = bswap32(v20);
    uint64_t v28 = *((unsigned int *)this + 21);
    v20 += *((void *)this + 18) * v28;
  }
  else
  {
    uint64_t v28 = *((unsigned int *)this + 21);
    uint64_t v27 = *((void *)this + 29);
  }
  uint64_t v29 = *((void *)this + 17);
  size_t v30 = v29 * v28;
  unsigned int v31 = v29 * v28 + v20;
  *(_DWORD *)(v27 + 16) = bswap32(v31);
  bzero((void *)(v27 + v31 + -(v29 * *(unsigned __int8 *)(v27 + 36))), v30);
  if (*((void *)this + 17))
  {
    unint64_t v32 = 1;
    unint64_t v33 = 0xFFFFFFFF00000000;
    do
    {
      memcpy((void *)(bswap32(*(_DWORD *)(*((void *)this + 29) + 16))+ *((void *)this + 29)+ ((uint64_t)(v33 * *(unsigned __int8 *)(*((void *)this + 29) + 36)) >> 32)), (const void *)(*((void *)this + 1) + (*((_DWORD *)this + 21) * (v32++ - 1))), *((unsigned int *)this + 21));
      v33 -= 0x100000000;
    }
    while (v32 <= *((void *)this + 17));
  }
  Security::UnixPlusPlus::FileDesc::seek((Security::UnixPlusPlus::FileDesc *)*((unsigned int *)this + 10), *((void *)this + 6));
  if (*((void *)this + 18))
  {
    unint64_t v89 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v34 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v87 = v34;
    long long v88 = v34;
    long long v85 = v34;
    long long v86 = v34;
    Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)*((unsigned int *)this + 19));
  }
  long long v36 = (char *)this + 208;
  std::string v35 = (char *)*((void *)this + 26);
  if (!v35) {
    return *((void *)this + 29);
  }
  unsigned int v37 = *((_DWORD *)this + 19);
  long long v38 = (char *)this + 208;
  do
  {
    unsigned int v39 = *((_DWORD *)v35 + 8);
    BOOL v40 = v39 >= v37;
    if (v39 >= v37) {
      long long v41 = (char **)v35;
    }
    else {
      long long v41 = (char **)(v35 + 8);
    }
    if (v40) {
      long long v38 = v35;
    }
    std::string v35 = *v41;
  }
  while (*v41);
  if (v38 == v36 || v37 < *((_DWORD *)v38 + 8)) {
    return *((void *)this + 29);
  }
  uint64_t v42 = *((void *)this + 29);
  if (bswap32(*(_DWORD *)(v42 + 8)) <= 0x204FF)
  {
    long long v45 = 0;
  }
  else
  {
    unsigned int v43 = *(_DWORD *)(v42 + 92);
    uint64_t v44 = bswap32(v43) + v42;
    long long v45 = v43 ? (void *)v44 : 0;
  }
  BytePtr = CFDataGetBytePtr(*((CFDataRef *)v38 + 5));
  memcpy(v45, BytePtr, *((void *)this + 18) * *((unsigned int *)this + 21));
  long long v47 = (char *)*((void *)this + 26);
  if (!v47) {
    return *((void *)this + 29);
  }
  unsigned int v48 = *((_DWORD *)v38 + 8);
  std::string::size_type v49 = (char *)this + 208;
  uint64_t v50 = (char *)*((void *)this + 26);
  do
  {
    unsigned int v51 = *((_DWORD *)v50 + 8);
    BOOL v52 = v51 >= v48;
    if (v51 >= v48) {
      long long v53 = (char **)v50;
    }
    else {
      long long v53 = (char **)(v50 + 8);
    }
    if (v52) {
      std::string::size_type v49 = v50;
    }
    uint64_t v50 = *v53;
  }
  while (*v53);
  if (v49 == v36 || v48 < *((_DWORD *)v49 + 8)) {
    return *((void *)this + 29);
  }
  uint64_t v54 = (char *)*((void *)v49 + 1);
  if (v54)
  {
    do
    {
      std::string::size_type v55 = v54;
      uint64_t v54 = *(char **)v54;
    }
    while (v54);
  }
  else
  {
    int v56 = v49;
    do
    {
      std::string::size_type v55 = (char *)*((void *)v56 + 2);
      BOOL v76 = *(void *)v55 == (void)v56;
      int v56 = v55;
    }
    while (!v76);
  }
  if (*((char **)this + 25) == v49) {
    *((void *)this + 25) = v55;
  }
  --*((void *)this + 27);
  uint64_t v57 = *(void *)v49;
  size_t v58 = v49;
  if (*(void *)v49)
  {
    std::string::size_type v59 = (char *)*((void *)v49 + 1);
    if (!v59)
    {
      size_t v58 = v49;
      goto LABEL_103;
    }
    do
    {
      size_t v58 = v59;
      std::string::size_type v59 = *(char **)v59;
    }
    while (v59);
  }
  uint64_t v57 = *((void *)v58 + 1);
  if (v57)
  {
LABEL_103:
    int v60 = 0;
    *(void *)(v57 + 16) = *((void *)v58 + 2);
    goto LABEL_104;
  }
  int v60 = 1;
LABEL_104:
  long long v61 = (char **)*((void *)v58 + 2);
  uint64_t v62 = *v61;
  if (*v61 == v58)
  {
    *long long v61 = (char *)v57;
    if (v58 == v47)
    {
      uint64_t v62 = 0;
      long long v47 = (char *)v57;
    }
    else
    {
      uint64_t v62 = v61[1];
    }
  }
  else
  {
    v61[1] = (char *)v57;
  }
  int v63 = v58[24];
  if (v58 != v49)
  {
    uint64_t v64 = *((void *)v49 + 2);
    *((void *)v58 + 2) = v64;
    *(void *)(v64 + 8 * (**((void **)v49 + 2) != (void)v49)) = v58;
    uint64_t v65 = *(void *)v49;
    *(void *)size_t v58 = *(void *)v49;
    *(void *)(v65 + 16) = v58;
    uint64_t v66 = *((void *)v49 + 1);
    *((void *)v58 + 1) = v66;
    if (v66) {
      *(void *)(v66 + 16) = v58;
    }
    v58[24] = v49[24];
    if (v47 == v49) {
      long long v47 = v58;
    }
  }
  if (!v63 || !v47) {
    goto LABEL_168;
  }
  if (!v60)
  {
    *(unsigned char *)(v57 + 24) = 1;
    goto LABEL_168;
  }
  while (1)
  {
    uint64_t v67 = *((void *)v62 + 2);
    if (*(char **)v67 != v62) {
      break;
    }
    if (!v62[24])
    {
      v62[24] = 1;
      *(unsigned char *)(v67 + 24) = 0;
      uint64_t v73 = *((void *)v62 + 1);
      *(void *)uint64_t v67 = v73;
      if (v73) {
        *(void *)(v73 + 16) = v67;
      }
      *((void *)v62 + 2) = *(void *)(v67 + 16);
      *(void *)(*(void *)(v67 + 16) + 8 * (**(void **)(v67 + 16) != v67)) = v62;
      *((void *)v62 + 1) = v67;
      *(void *)(v67 + 16) = v62;
      if (v47 == (char *)v67) {
        long long v47 = v62;
      }
      uint64_t v62 = *(char **)v67;
    }
    CFNumberRef v74 = *(char **)v62;
    if (*(void *)v62 && !v74[24]) {
      goto LABEL_163;
    }
    long long v75 = (char *)*((void *)v62 + 1);
    if (v75 && !v75[24])
    {
      if (v74 && !v74[24])
      {
LABEL_163:
        long long v75 = v62;
      }
      else
      {
        v75[24] = 1;
        v62[24] = 0;
        uint64_t v81 = *(void *)v75;
        *((void *)v62 + 1) = *(void *)v75;
        if (v81) {
          *(void *)(v81 + 16) = v62;
        }
        *((void *)v75 + 2) = *((void *)v62 + 2);
        *(void *)(*((void *)v62 + 2) + 8 * (**((void **)v62 + 2) != (void)v62)) = v75;
        *(void *)long long v75 = v62;
        *((void *)v62 + 2) = v75;
        CFNumberRef v74 = v62;
      }
      uint64_t v78 = *((void *)v75 + 2);
      v75[24] = *(unsigned char *)(v78 + 24);
      *(unsigned char *)(v78 + 24) = 1;
      v74[24] = 1;
      uint64_t v79 = *(uint64_t **)v78;
      uint64_t v82 = *(void *)(*(void *)v78 + 8);
      *(void *)uint64_t v78 = v82;
      if (v82) {
        *(void *)(v82 + 16) = v78;
      }
      v79[2] = *(void *)(v78 + 16);
      *(void *)(*(void *)(v78 + 16) + 8 * (**(void **)(v78 + 16) != v78)) = v79;
      v79[1] = v78;
      goto LABEL_167;
    }
    v62[24] = 0;
    stat v72 = (char *)*((void *)v62 + 2);
    if (v72[24]) {
      BOOL v76 = v72 == v47;
    }
    else {
      BOOL v76 = 1;
    }
    if (v76) {
      goto LABEL_148;
    }
LABEL_145:
    uint64_t v62 = *(char **)(*((void *)v72 + 2) + 8 * (**((void **)v72 + 2) == (void)v72));
  }
  if (!v62[24])
  {
    v62[24] = 1;
    *(unsigned char *)(v67 + 24) = 0;
    std::string v68 = *(uint64_t **)(v67 + 8);
    uint64_t v69 = *v68;
    *(void *)(v67 + 8) = *v68;
    if (v69) {
      *(void *)(v69 + 16) = v67;
    }
    _OWORD v68[2] = *(void *)(v67 + 16);
    *(void *)(*(void *)(v67 + 16) + 8 * (**(void **)(v67 + 16) != v67)) = v68;
    uint64_t *v68 = v67;
    *(void *)(v67 + 16) = v68;
    if (v47 == *(char **)v62) {
      long long v47 = v62;
    }
    uint64_t v62 = *(char **)(*(void *)v62 + 8);
  }
  int64_t v70 = *(char **)v62;
  if (!*(void *)v62 || v70[24])
  {
    std::string::size_type v71 = (char *)*((void *)v62 + 1);
    if (v71 && !v71[24]) {
      goto LABEL_154;
    }
    v62[24] = 0;
    stat v72 = (char *)*((void *)v62 + 2);
    if (v72 == v47)
    {
      stat v72 = v47;
LABEL_148:
      v72[24] = 1;
      goto LABEL_168;
    }
    if (!v72[24]) {
      goto LABEL_148;
    }
    goto LABEL_145;
  }
  std::string::size_type v71 = (char *)*((void *)v62 + 1);
  if (v71 && !v71[24])
  {
LABEL_154:
    int64_t v70 = v62;
  }
  else
  {
    v70[24] = 1;
    v62[24] = 0;
    uint64_t v77 = *((void *)v70 + 1);
    *(void *)uint64_t v62 = v77;
    if (v77) {
      *(void *)(v77 + 16) = v62;
    }
    *((void *)v70 + 2) = *((void *)v62 + 2);
    *(void *)(*((void *)v62 + 2) + 8 * (**((void **)v62 + 2) != (void)v62)) = v70;
    *((void *)v70 + 1) = v62;
    *((void *)v62 + 2) = v70;
    std::string::size_type v71 = v62;
  }
  uint64_t v78 = *((void *)v70 + 2);
  v70[24] = *(unsigned char *)(v78 + 24);
  *(unsigned char *)(v78 + 24) = 1;
  v71[24] = 1;
  uint64_t v79 = *(uint64_t **)(v78 + 8);
  uint64_t v80 = *v79;
  *(void *)(v78 + 8) = *v79;
  if (v80) {
    *(void *)(v80 + 16) = v78;
  }
  v79[2] = *(void *)(v78 + 16);
  *(void *)(*(void *)(v78 + 16) + 8 * (**(void **)(v78 + 16) != v78)) = v79;
  *uint64_t v79 = v78;
LABEL_167:
  *(void *)(v78 + 16) = v79;
LABEL_168:
  Security::CFRef<__CFData const*>::~CFRef((const void **)v49 + 5);
  operator delete(v49);
  return *((void *)this + 29);
}

void sub_18B3E1234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  Security::RefPointer<Security::DynamicHash>::~RefPointer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN8Security11CodeSigning12hashFileDataINS_11DynamicHashEEEmNS_12UnixPlusPlus8FileDescEPT_m_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))();
}

void Security::CodeSigning::scanFileData(int *a1, size_t a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  v6.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v17.st_blkstd::string::size_type size = v6;
  *(timespec *)v17.st_qspare = v6;
  v17.st_birthtimespeCC_SHA512_CTX c = v6;
  *(timespec *)&v17.st_std::string::size_type size = v6;
  v17.st_mtimespeCC_SHA512_CTX c = v6;
  v17.st_ctimespeCC_SHA512_CTX c = v6;
  *(timespec *)&v17.st_uid = v6;
  v17.st_atimespeCC_SHA512_CTX c = v6;
  *(timespec *)&v17.st_dev = v6;
  Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*a1, &v17);
  if (v17.st_blksize <= 0x10000) {
    st_blkstd::string::size_type size = 0x10000;
  }
  else {
    st_blkstd::string::size_type size = v17.st_blksize;
  }
  uint64_t v8 = malloc_type_valloc(st_blksize, 0x261F55AFuLL);
  if (v8)
  {
    while (1)
    {
      size_t v9 = a2;
      if (a2 >= st_blksize || a2 == 0) {
        size_t v11 = st_blksize;
      }
      else {
        size_t v11 = a2;
      }
      ssize_t v12 = read(*a1, v8, v11);
      ssize_t v13 = v12;
      if (v12 == -1)
      {
        if (*__error() != 35)
        {
          uint64_t v16 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v16);
        }
      }
      else
      {
        if (v12) {
          goto LABEL_17;
        }
        *((unsigned char *)a1 + 4) = 1;
        __int8 v14 = secLogObjForScope("unixio");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          int v15 = *a1;
          *(_DWORD *)long long buf = 67109120;
          int v19 = v15;
          _os_log_debug_impl(&dword_18B299000, v14, OS_LOG_TYPE_DEBUG, "%d end of data", buf, 8u);
        }
      }
      ssize_t v13 = 0;
LABEL_17:
      if (!*((unsigned char *)a1 + 4))
      {
        (*(void (**)(uint64_t, void *, ssize_t))(a3 + 16))(a3, v8, v13);
        a2 = 0;
        if (!v9) {
          continue;
        }
        a2 = v9 - v13;
        if (v9 != v13) {
          continue;
        }
      }
      free(v8);
      return;
    }
  }
}

void sub_18B3E1488(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_18B3E14C4(_Unwind_Exception *a1)
{
}

void sub_18B3E14D0(void *a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x18B3E14D8);
  }
  __clang_call_terminate(a1);
}

void Security::CodeSigning::CodeDirectory::multipleHashFileData(uint64_t a1, size_t a2, void *a3, uint64_t a4)
{
  v24[0] = 0;
  v24[1] = 0;
  unsigned int v23 = v24;
  unsigned int v5 = (void *)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    do
    {
      timespec v6 = (Security::CodeSigning::CodeDirectory *)*((unsigned int *)v5 + 7);
      unsigned int v7 = &Security::CodeSigning::hashPriorities;
      do
      {
        int v9 = *v7++;
        int v8 = v9;
        BOOL v10 = v9 == v6 || v8 == 0;
      }
      while (!v10);
      if (v8) {
        Security::CodeSigning::CodeDirectory::hashFor(v6);
      }
      size_t v11 = (void *)v5[1];
      if (v11)
      {
        do
        {
          ssize_t v12 = v11;
          size_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          ssize_t v12 = (void *)v5[2];
          BOOL v10 = *v12 == (void)v5;
          unsigned int v5 = v12;
        }
        while (!v10);
      }
      unsigned int v5 = v12;
    }
    while (v12 != a3 + 1);
  }
  int v21 = *(_DWORD *)a1;
  char v22 = *(unsigned char *)(a1 + 4);
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 1174405120;
  void v19[2] = ___ZN8Security11CodeSigning13CodeDirectory20multipleHashFileDataENS_12UnixPlusPlus8FileDescEmNSt3__13setIjNS4_4lessIjEENS4_9allocatorIjEEEEU13block_pointerFvjPNS_11DynamicHashEE_block_invoke;
  v19[3] = &__block_descriptor_tmp_16708;
  std::map<unsigned int,Security::RefPointer<Security::DynamicHash>>::map[abi:ne180100]((uint64_t)v20, &v23);
  Security::CodeSigning::scanFileData(&v21, a2, (uint64_t)v19);
  CFMutableDictionaryRef CFMutableDictionary = Security::makeCFMutableDictionary(v13);
  __int8 v14 = v23;
  if (v23 != v24)
  {
    do
    {
      (*(void (**)(uint64_t, void, void *))(a4 + 16))(a4, *((unsigned int *)v14 + 8), v14[5]);
      int v15 = v14[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = (void **)v15;
          int v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void **)v14[2];
          BOOL v10 = *v16 == v14;
          __int8 v14 = v16;
        }
        while (!v10);
      }
      __int8 v14 = v16;
    }
    while (v16 != v24);
  }
  Security::CFRef<__CFDictionary *>::~CFRef((const void **)&CFMutableDictionary);
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(v20[1]);
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(v24[0]);
}

void sub_18B3E17A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
}

uint64_t ___ZN8Security11CodeSigning13CodeDirectory20multipleHashFileDataENS_12UnixPlusPlus8FileDescEmNSt3__13setIjNS4_4lessIjEENS4_9allocatorIjEEEEU13block_pointerFvjPNS_11DynamicHashEE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(result + 32);
  uint64_t v4 = (void *)(result + 40);
  if (v3 != (void *)(result + 40))
  {
    do
    {
      unint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v3[5] + 24))(v3[5], a2, a3);
      unsigned int v7 = (void *)v3[1];
      if (v7)
      {
        do
        {
          int v8 = v7;
          unsigned int v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (void *)v3[2];
          BOOL v9 = *v8 == (void)v3;
          uint64_t v3 = v8;
        }
        while (!v9);
      }
      uint64_t v3 = v8;
    }
    while (v8 != v4);
  }
  return result;
}

uint64_t std::map<unsigned int,Security::RefPointer<Security::DynamicHash>>::map[abi:ne180100](uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = (uint64_t **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  uint64_t v4 = a2 + 1;
  unsigned int v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      timespec v6 = *(uint64_t **)(a1 + 8);
      unsigned int v7 = v3;
      if (*(uint64_t ***)a1 == v3) {
        goto LABEL_8;
      }
      uint64_t v8 = *(void *)(a1 + 8);
      BOOL v9 = v3;
      if (v6)
      {
        do
        {
          unsigned int v7 = (uint64_t **)v8;
          uint64_t v8 = *(void *)(v8 + 8);
        }
        while (v8);
      }
      else
      {
        do
        {
          unsigned int v7 = (uint64_t **)v9[2];
          BOOL v10 = *v7 == (uint64_t *)v9;
          BOOL v9 = v7;
        }
        while (v10);
      }
      unsigned int v11 = *((_DWORD *)v5 + 8);
      if (*((_DWORD *)v7 + 8) < v11)
      {
LABEL_8:
        if (v6) {
          ssize_t v12 = v7;
        }
        else {
          ssize_t v12 = v3;
        }
        if (v6) {
          ssize_t v13 = v7 + 1;
        }
        else {
          ssize_t v13 = v3;
        }
      }
      else
      {
        ssize_t v12 = v3;
        ssize_t v13 = v3;
        if (v6)
        {
          ssize_t v13 = v3;
          while (1)
          {
            while (1)
            {
              ssize_t v12 = (uint64_t **)v6;
              unsigned int v18 = *((_DWORD *)v6 + 8);
              if (v11 >= v18) {
                break;
              }
              timespec v6 = *v12;
              ssize_t v13 = v12;
              if (!*v12) {
                goto LABEL_15;
              }
            }
            if (v18 >= v11) {
              break;
            }
            ssize_t v13 = v12 + 1;
            timespec v6 = v12[1];
            if (!v6) {
              goto LABEL_15;
            }
          }
        }
      }
      if (!*v13)
      {
LABEL_15:
        unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
        __int8 v14 = (char *)operator new(0x70uLL);
        v20[0] = v14;
        v20[1] = v3;
        LOBYTE(v21) = 0;
        *((_DWORD *)v14 + 8) = *((_DWORD *)v5 + 8);
        Security::Mutex::Mutex((pthread_mutex_t *)(v14 + 48));
        uint64_t v15 = v5[5];
        if (v15)
        {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v15 + 8), 1u, memory_order_relaxed);
          uint64_t v15 = v5[5];
        }
        *((void *)v14 + 5) = v15;
        LOBYTE(v21) = 1;
        std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v12, v13, (uint64_t *)v14);
        v20[0] = 0;
        std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>>>>::reset[abi:ne180100]((uint64_t)v20);
      }
      uint64_t v16 = (void *)v5[1];
      if (v16)
      {
        do
        {
          stat v17 = v16;
          uint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          stat v17 = (void *)v5[2];
          BOOL v10 = *v17 == (void)v5;
          unsigned int v5 = v17;
        }
        while (!v10);
      }
      unsigned int v5 = v17;
    }
    while (v17 != v4);
  }
  return a1;
}

void sub_18B3E1A68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(*v2);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(a1[1]);
    Security::RefPointer<Security::DynamicHash>::~RefPointer((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      Security::RefPointer<Security::DynamicHash>::~RefPointer((uint64_t)v1 + 40);
    }
    operator delete(v1);
  }
}

void __destroy_helper_block_e8_32c106_ZTSNSt3__13mapIjN8Security10RefPointerINS1_11DynamicHashEEENS_4lessIjEENS_9allocatorINS_4pairIKjS4_EEEEEE(uint64_t a1)
{
}

uint64_t __copy_helper_block_e8_32c106_ZTSNSt3__13mapIjN8Security10RefPointerINS1_11DynamicHashEEENS_4lessIjEENS_9allocatorINS_4pairIKjS4_EEEEEE(uint64_t a1, uint64_t a2)
{
  return std::map<unsigned int,Security::RefPointer<Security::DynamicHash>>::map[abi:ne180100](a1 + 32, (void *)(a2 + 32));
}

BOOL Security::DynamicHash::verify(Security::DynamicHash *this, const unsigned __int8 *a2)
{
  v11[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(Security::DynamicHash *))(*(void *)this + 16))(this);
  uint64_t v5 = MEMORY[0x1F4188790](v4);
  uint64_t v8 = (char *)v11 - v7;
  if (v5) {
    memset((char *)v11 - v7, 170, v6);
  }
  (*(void (**)(Security::DynamicHash *, char *))(*(void *)this + 32))(this, v8);
  size_t v9 = (*(uint64_t (**)(Security::DynamicHash *))(*(void *)this + 16))(this);
  return memcmp(v8, a2, v9) == 0;
}

SecTaskRef SecTaskCreateWithXPCMessage(SecTaskRef result)
{
  *(void *)&long long v1 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v3.val = v1;
  *(_OWORD *)&v3.val[4] = v1;
  if (result)
  {
    if (MEMORY[0x18C12FBB0]() == MEMORY[0x1E4F14590])
    {
      xpc_dictionary_get_audit_token();
      audit_token_t v2 = v3;
      return SecTaskCreateWithAuditToken(0, &v2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t SecTaskEntitlementsValidated(uint64_t a1)
{
  if (csops_task(a1) == -1) {
    return 0;
  }
  else {
    return 0;
  }
}

uint64_t SecTaskValidateForLightweightCodeRequirementData(_OWORD *a1, const __CFData *a2, CFErrorRef *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  CFTypeID TypeID = SecTaskGetTypeID();
  if (TypeID != CFGetTypeID(a1))
  {
    if (a3)
    {
      CFStringRef v13 = (const __CFString *)*MEMORY[0x1E4F1D158];
      __int8 v14 = @"Invalid task reference";
      int v15 = -67675;
LABEL_13:
      uint64_t v11 = 0;
      *a3 = createError(v13, v15, v14);
      return v11;
    }
    return 0;
  }
  if (!a2 || !CFDataGetLength(a2))
  {
    if (a3)
    {
      CFStringRef v13 = (const __CFString *)*MEMORY[0x1E4F1D158];
      __int8 v14 = @"Invalid requirement";
      int v15 = -50;
      goto LABEL_13;
    }
    return 0;
  }
  bzero(&v18, 0x404uLL);
  BytePtr = CFDataGetBytePtr(a2);
  CFIndex Length = CFDataGetLength(a2);
  long long v9 = a1[2];
  v17[0] = a1[1];
  v17[1] = v9;
  uint64_t v10 = amfi_launch_constraint_matches_process((uint64_t)v17, (uint64_t)BytePtr, Length, (uint64_t)&v18);
  uint64_t v11 = v10;
  if (a3 && (v10 & 1) == 0)
  {
    CFStringRef v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v19, 0x8000100u);
    if (v18 <= 5) {
      *a3 = createError(**((const __CFString ***)&unk_1E54851B0 + v18), dword_18B41C3C0[v18], v12);
    }
    CFRelease(v12);
  }
  return v11;
}

CFErrorRef createError(const __CFString *a1, int a2, const void *a3)
{
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F1D140], a3);

  return CFErrorCreate(v6, a1, a2, Mutable);
}

uint64_t Security::PerThreadPointer<Security::CodeSigning::PerThread>::destructor(uint64_t result)
{
  if (result) {
    JUMPOUT(0x18C12D390);
  }
  return result;
}

CFTypeID SecCodeGetTypeID(void)
{
  return *(void *)(Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()() + 96);
}

void sub_18B3E1FB0(void *a1)
{
}

OSStatus SecCodeCopySelf(SecCSFlags flags, SecCodeRef *self)
{
  if (!flags)
  {
    LODWORD(valuePtr) = getpid();
    audit_token_t v2 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    unsigned int valuePtr = Security::makeCFMutableDictionary(v2, v3, v4, @"pid", v2, v2);
    uint64_t v5 = Security::CFRef<__CFNumber const*>::~CFRef(&v7);
    Security::CodeSigning::SecCode::autoLocateGuest((Security::CodeSigning::SecCode *)v5, v6);
  }
  Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
}

uint64_t sub_18B3E2028(void *a1, int a2)
{
  Security::CFRef<__CFDictionary *>::~CFRef(&v12);
  switch(a2)
  {
    case 6:
      uint64_t v4 = __cxa_begin_catch(a1);
      if (v4[36] == 8)
      {
        uint64_t v5 = 4294900247;
        goto LABEL_8;
      }
      goto LABEL_6;
    case 5:
      goto LABEL_5;
    case 4:
      uint64_t v4 = __cxa_begin_catch(a1);
      unsigned int v9 = v4[36];
      if (v9 <= 0x1A)
      {
        uint64_t v5 = 4294900263;
        int v10 = 1 << v9;
        if ((v10 & 0x800108) != 0) {
          goto LABEL_8;
        }
        if ((v10 & 0x4014000) != 0)
        {
          uint64_t v5 = 4294900264;
          goto LABEL_8;
        }
      }
LABEL_6:
      uint64_t v7 = (*(uint64_t (**)(_DWORD *))(*(void *)v4 + 24))(v4);
      goto LABEL_7;
    case 3:
LABEL_5:
      CFDictionaryRef v6 = __cxa_begin_catch(a1);
      uint64_t v7 = (*(uint64_t (**)(void *))(*(void *)v6 + 24))(v6);
LABEL_7:
      uint64_t v5 = v7;
      goto LABEL_8;
  }
  __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v5 = 4294967188;
  }
  else
  {
    Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v11);
    uint64_t v5 = 4294900248;
  }
LABEL_8:
  __cxa_end_catch();
  return v5;
}

void sub_18B3E21D8(_Unwind_Exception *a1)
{
}

uint64_t SecCodeGetStatus(Security::CodeSigning::SecCode *a1, __SecCode *a2, int *a3)
{
  if (a2)
  {
    uint64_t v7 = 4294900226;
LABEL_8:
    Security::MacOSError::throwMe((Security::MacOSError *)v7);
  }
  uint64_t v4 = *((void *)Security::CodeSigning::SecCode::required(a1, a2) + 2);
  if (!v4)
  {
    int v5 = 1;
    if (a3) {
      goto LABEL_4;
    }
    goto LABEL_6;
  }
  int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 104))(v4);
  if (!a3)
  {
LABEL_6:
    uint64_t v7 = 4294900227;
    goto LABEL_8;
  }
LABEL_4:
  *a3 = v5;
  return 0;
}

void *Security::CodeSigning::SecCode::required(Security::CodeSigning::SecCode *this, __SecCode *a2)
{
  if (!this
  {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  }
  return result;
}

uint64_t SecCodeSetStatus(Security::CodeSigning::SecCode *a1, __SecCode *a2, uint64_t a3, int a4)
{
  if (a4)
  {
    uint64_t v9 = 4294900226;
    goto LABEL_6;
  }
  CFDictionaryRef v6 = Security::CodeSigning::SecCode::required(a1, a2);
  uint64_t v7 = v6[2];
  if (!v7)
  {
    uint64_t v9 = 4294900256;
LABEL_6:
    Security::MacOSError::throwMe((Security::MacOSError *)v9);
  }
  (*(void (**)(uint64_t, void *, __SecCode *, uint64_t))(*(void *)v7 + 112))(v7, v6, a2, a3);
  return 0;
}

OSStatus SecCodeCopyStaticCode(SecCodeRef code, SecCSFlags flags, SecStaticCodeRef *staticCode)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (flags >= 2) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  __int8 v14 = (Security::SecCFObject *)0xAAAAAAAAAAAAAAAALL;
  int v5 = Security::CodeSigning::SecCode::required(code, *(__SecCode **)&flags);
  CFDictionaryRef v6 = v5;
  if (!v5[24])
  {
    (*(void (**)(unsigned char *))(*(void *)v5 + 80))(v5);
    v6[24] = 1;
  }
  Security::SecPointerBase::SecPointerBase(&v14, *((void *)v6 + 4));
  if (flags)
  {
    uint64_t v7 = (*(uint64_t (**)(void))(**((void **)v14 + 4) + 80))(*((void *)v14 + 4));
    if (v7)
    {
      if (*(void *)(v7 + 32))
      {
        unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v17 = v8;
        long long v18 = v8;
        *(_OWORD *)int v15 = v8;
        long long v16 = v8;
        (*(void (**)(void **__return_ptr))(**((void **)v14 + 4) + 40))(__p);
        if (v13 >= 0) {
          uint64_t v9 = (char *)__p;
        }
        else {
          uint64_t v9 = (char *)__p[0];
        }
        Security::CodeSigning::DiskRep::bestGuess(v9, 0);
      }
    }
  }
  int v10 = v14;
  if (v14) {
    int v10 = (const __SecCode *)Security::SecCFObject::handle((atomic_uchar *)v14, 1);
  }
  if (!staticCode) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  }
  *staticint64_t Code = v10;
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v14);
  return 0;
}

void sub_18B3E28E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  Security::SecCFObject::operator delete(v19);
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((uint64_t)&a17);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a15);
  if (a2 == 6)
  {
    char v22 = __cxa_begin_catch(exception_object);
    if (v22[36] == 8) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  if (a2 != 5)
  {
    if (a2 == 4)
    {
      char v22 = __cxa_begin_catch(exception_object);
      unsigned int v24 = v22[36];
      if (v24 <= 0x1A)
      {
        int v25 = 1 << v24;
        if ((v25 & 0x800108) != 0 || (v25 & 0x4014000) != 0) {
          goto LABEL_17;
        }
      }
LABEL_16:
      (*(void (**)(_DWORD *))(*(void *)v22 + 24))(v22);
LABEL_17:
      __cxa_end_catch();
LABEL_19:
      JUMPOUT(0x18B3E288CLL);
    }
    if (a2 != 3)
    {
      __cxa_begin_catch(exception_object);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v26);
      }
      goto LABEL_17;
    }
  }
  unsigned int v23 = __cxa_begin_catch(exception_object);
  (*(void (**)(void *))(*(void *)v23 + 24))(v23);
  __cxa_end_catch();
  goto LABEL_19;
}

OSStatus SecCodeCopyHost(SecCodeRef guest, SecCSFlags flags, SecCodeRef *host)
{
  if (flags) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  uint64_t v7 = (Security::SecCFObject *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = Security::CodeSigning::SecCode::required(guest, *(__SecCode **)&flags);
  Security::SecPointerBase::SecPointerBase(&v7, v4[2]);
  int v5 = v7;
  if (v7) {
    int v5 = (__SecCode *)Security::SecCFObject::handle((atomic_uchar *)v7, 1);
  }
  if (!host) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  }
  *host = v5;
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v7);
  return 0;
}

void sub_18B3E2BE8(void *a1, int a2, uint64_t a3, ...)
{
  va_start(va, a3);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)va);
  switch(a2)
  {
    case 6:
      int v5 = __cxa_begin_catch(a1);
      if (v5[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v5 + 24))(v5);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      int v5 = __cxa_begin_catch(a1);
      unsigned int v7 = v5[36];
      if (v7 > 0x1A) {
        goto LABEL_6;
      }
      int v8 = 1 << v7;
      if ((v8 & 0x800108) == 0 && (v8 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      CFDictionaryRef v6 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v6 + 24))(v6);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v9);
      }
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18B3E2BB8);
}

void sub_18B3E2D80(_Unwind_Exception *a1)
{
}

OSStatus SecCodeCheckValidity(SecCodeRef code, SecCSFlags flags, SecRequirementRef requirement)
{
  return SecCodeCheckValidityWithErrors(code, flags, requirement, 0);
}

OSStatus SecCodeCheckValidityWithErrors(SecCodeRef code, SecCSFlags flags, SecRequirementRef requirement, CFErrorRef *errors)
{
  if ((flags & 0x1F7EDDEF) != 0) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  uint64_t v5 = *(void *)&flags;
  uint64_t v11 = (Security::CodeSigning::SecCode *)0xAAAAAAAAAAAAAAAALL;
  CFDictionaryRef v6 = Security::CodeSigning::SecCode::required(code, *(__SecCode **)&flags);
  Security::SecPointerBase::SecPointerBase(&v11, (uint64_t)v6);
  Security::CodeSigning::SecCode::checkValidity(v11, v5);
  int v8 = Security::CodeSigning::SecRequirement::optional((char *)requirement, v7);
  if (v8)
  {
    uint64_t v9 = v11;
    if ((v5 & 0x800000) != 0)
    {
      (*(void (**)(void, Security::CodeSigning::SecCode *, void))(**((void **)v11 + 2) + 120))(*((void *)v11 + 2), v11, *((void *)v8 + 2));
    }
    else
    {
      if (!*((unsigned char *)v11 + 24))
      {
        (*(void (**)(Security::CodeSigning::SecCode *))(*(void *)v11 + 80))(v11);
        *((unsigned char *)v9 + 24) = 1;
      }
      if (!Security::CodeSigning::SecStaticCode::satisfiesRequirement(*((void *)v9 + 4), *((Security::CodeSigning::Requirement **)v8 + 2)))Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA16); {
    }
      }
  }
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v11);
  return 0;
}

void sub_18B3E2F00(void *a1, int a2, uint64_t a3, ...)
{
  va_start(va, a3);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)va);
  switch(a2)
  {
    case 7:
      CFDictionaryRef v6 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v6, v3);
      goto LABEL_32;
    case 6:
      unsigned int v7 = __cxa_begin_catch(a1);
      if (v7[36] == 8) {
        int v8 = -67049;
      }
      else {
        int v8 = (*(uint64_t (**)(_DWORD *))(*(void *)v7 + 24))(v7);
      }
      if (v3)
      {
LABEL_30:
        CFErrorRef v11 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v8, 0);
        goto LABEL_31;
      }
LABEL_32:
      __cxa_end_catch();
      JUMPOUT(0x18B3E2ED8);
    case 5:
      uint64_t v9 = __cxa_begin_catch(a1);
      int v10 = (*(uint64_t (**)(void *))(*(void *)v9 + 24))(v9);
      if (!v3) {
        goto LABEL_32;
      }
      CFErrorRef v11 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v10, 0);
LABEL_31:
      *audit_token_t v3 = v11;
      goto LABEL_32;
  }
  if (a2 != 4)
  {
    if (a2 == 3)
    {
      int v15 = __cxa_begin_catch(a1);
      int v16 = (*(uint64_t (**)(void *))(*(void *)v15 + 24))(v15);
      if (v3) {
        *audit_token_t v3 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v16, 0);
      }
    }
    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v3) {
          *audit_token_t v3 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], -108, 0);
        }
      }
      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v17);
        if (v3) {
          *audit_token_t v3 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], -67048, 0);
        }
      }
    }
    goto LABEL_32;
  }
  CFStringRef v12 = __cxa_begin_catch(a1);
  unsigned int v13 = v12[36];
  if (v13 > 0x1A) {
    goto LABEL_28;
  }
  int v8 = -67033;
  int v14 = 1 << v13;
  if ((v14 & 0x800108) != 0) {
    goto LABEL_29;
  }
  if ((v14 & 0x4014000) != 0) {
    int v8 = -67032;
  }
  else {
LABEL_28:
  }
    int v8 = (*(uint64_t (**)(_DWORD *))(*(void *)v12 + 24))(v12);
LABEL_29:
  if (!v3) {
    goto LABEL_32;
  }
  goto LABEL_30;
}

void sub_18B3E31A0(_Unwind_Exception *a1)
{
}

char *Security::CodeSigning::SecRequirement::optional(char *this, __SecRequirement *a2)
{
  if (this)
  {
    if (!this) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
    }
  }
  return this;
}

CFTypeID SecStaticCodeGetTypeID(void)
{
  return *(void *)(Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()() + 200);
}

void sub_18B3E3280(void *a1)
{
}

OSStatus SecStaticCodeCreateWithPathAndAttributes(CFURLRef path, SecCSFlags flags, CFDictionaryRef attributes, SecStaticCodeRef *staticCode)
{
  if (flags >= 2) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  long long v28 = 0xAAAAAAAAAAAAAA00;
  unint64_t v30 = 0xAAAAAAAAAAAAAA00;
  unint64_t v25 = 0xFFFFFFFF00000000;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v29 = 0;
  v23[0] = 0;
  v23[1] = 0;
  uint64_t v24 = 0;
  if (!attributes)
  {
LABEL_24:
    uint64_t v14 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
    Security::SecCFObject::allocate((Security::SecCFObject *)0x288, *(void *)(v14 + 200), v15);
    Security::cfString((Security *)__p, path);
    if (v22 >= 0) {
      int v16 = (char *)__p;
    }
    else {
      int v16 = (char *)__p[0];
    }
    Security::CodeSigning::DiskRep::bestGuess(v16, (uint64_t)&v25);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v22 = 0;
  int v19 = -1431655766;
  int v20 = -1431655766;
  int v18 = -1431655766;
  if (Security::cfscan((const __CFString *)attributes, "{%O=%d}", (const char *)attributes, staticCode, @"UniversalFileOffset", &v18))
  {
    uint64_t v27 = v18;
LABEL_18:
    if (Security::cfscan((const __CFString *)attributes, "{%O=%s}", v6, @"bundleversion", v23))
    {
      unsigned int v13 = v23;
      if (v24 < 0) {
        unsigned int v13 = (void **)v23[0];
      }
      uint64_t v26 = v13;
    }
    if (SHIBYTE(v22) < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_24;
  }
  if (Security::cfscan((const __CFString *)attributes, "{%O=%s}", v6, @"architecture", __p))
  {
    if (v22 >= 0) {
      int v8 = __p;
    }
    else {
      int v8 = (void **)__p[0];
    }
    uint64_t v9 = NXGetArchInfoFromName((const char *)v8);
    if (v9) {
      unint64_t v10 = *(void *)&v9->cputype;
    }
    else {
      unint64_t v10 = 0;
    }
    unint64_t v25 = v10;
    goto LABEL_18;
  }
  if (Security::cfscan((const __CFString *)attributes, "{%O=%d,%O=%d}", v7, @"architecture", &v20, @"subarchitecture", &v19))
  {
    int v12 = v19;
    int v11 = v20;
  }
  else
  {
    if (!Security::cfscan((const __CFString *)attributes, "{%O=%d}", v6, @"architecture", &v20)) {
      goto LABEL_18;
    }
    int v11 = v20;
    int v12 = -1;
  }
  unint64_t v25 = __PAIR64__(v12, v11);
  goto LABEL_18;
}

void sub_18B3E34F8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  switch(a2)
  {
    case 6:
      uint64_t v29 = __cxa_begin_catch(a1);
      if (v29[36] == 8) {
        break;
      }
LABEL_10:
      (*(void (**)(_DWORD *))(*(void *)v29 + 24))(v29);
      break;
    case 5:
      goto LABEL_9;
    case 4:
      uint64_t v29 = __cxa_begin_catch(a1);
      unsigned int v31 = v29[36];
      if (v31 > 0x1A) {
        goto LABEL_10;
      }
      int v32 = 1 << v31;
      if ((v32 & 0x800108) == 0 && (v32 & 0x4014000) == 0) {
        goto LABEL_10;
      }
      break;
    case 3:
LABEL_9:
      unint64_t v30 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v30 + 24))(v30);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v33);
      }
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18B3E34B8);
}

void sub_18B3E36EC(_Unwind_Exception *a1)
{
}

OSStatus SecStaticCodeCheckValidity(SecStaticCodeRef staticCode, SecCSFlags flags, SecRequirementRef requirement)
{
  return SecStaticCodeCheckValidityWithErrors(staticCode, flags, requirement, 0);
}

OSStatus SecStaticCodeCheckValidityWithErrors(SecStaticCodeRef staticCode, SecCSFlags flags, SecRequirementRef requirement, CFErrorRef *errors)
{
  if ((flags & 0xDFE0020) != 0) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  if (errors) {
    SecCSFlags v6 = flags | 0x20;
  }
  else {
    SecCSFlags v6 = flags;
  }
  uint64_t v14 = (Security::CodeSigning::SecStaticCode *)0xAAAAAAAAAAAAAAAALL;
  unsigned int v7 = Security::CodeSigning::SecStaticCode::requiredStatic(staticCode, *(const __SecCode **)&flags);
  Security::SecPointerBase::SecPointerBase(&v14, (uint64_t)v7);
  int v8 = v6 | 0x2000000;
  *((_DWORD *)v14 + 52) = v8;
  unint64_t v10 = Security::CodeSigning::SecRequirement::optional((char *)requirement, v9);
  std::string __p = v14;
  Security::CodeSigning::SecStaticCode::staticValidate(v14, v8, (Security::CodeSigning::Requirement **)v10);
  if (*((unsigned char *)v14 + 632)) {
    OSStatus v11 = 0;
  }
  else {
    OSStatus v11 = -66996;
  }
  if (!*((unsigned char *)v14 + 632) && errors)
  {
    *errors = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], -66996, 0);
    OSStatus v11 = -66996;
  }
  SecStaticCodeCheckValidityWithErrors::_DTFrameCODESIGN_EVAL_STATIC::~_DTFrameCODESIGN_EVAL_STATIC((SecStaticCodeCheckValidityWithErrors::_DTFrameCODESIGN_EVAL_STATIC *)&__p);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v14);
  return v11;
}

void sub_18B3E38A8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a15);
  switch(a2)
  {
    case 7:
      int v18 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v18, v15);
      goto LABEL_34;
    case 6:
      int v19 = __cxa_begin_catch(a1);
      if (v19[36] == 8) {
        int v20 = -67049;
      }
      else {
        int v20 = (*(uint64_t (**)(_DWORD *))(*(void *)v19 + 24))(v19);
      }
      if (v15)
      {
LABEL_32:
        CFErrorRef v23 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v20, 0);
        goto LABEL_33;
      }
LABEL_34:
      __cxa_end_catch();
      JUMPOUT(0x18B3E387CLL);
    case 5:
      unint64_t v21 = __cxa_begin_catch(a1);
      int v22 = (*(uint64_t (**)(void *))(*(void *)v21 + 24))(v21);
      if (!v15) {
        goto LABEL_34;
      }
      CFErrorRef v23 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v22, 0);
LABEL_33:
      *int v15 = v23;
      goto LABEL_34;
  }
  if (a2 != 4)
  {
    if (a2 == 3)
    {
      uint64_t v27 = __cxa_begin_catch(a1);
      int v28 = (*(uint64_t (**)(void *))(*(void *)v27 + 24))(v27);
      if (v15) {
        *int v15 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v28, 0);
      }
    }
    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v15) {
          *int v15 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], -108, 0);
        }
      }
      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v29);
        if (v15) {
          *int v15 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], -67048, 0);
        }
      }
    }
    goto LABEL_34;
  }
  uint64_t v24 = __cxa_begin_catch(a1);
  unsigned int v25 = v24[36];
  if (v25 > 0x1A) {
    goto LABEL_30;
  }
  int v20 = -67033;
  int v26 = 1 << v25;
  if ((v26 & 0x800108) != 0) {
    goto LABEL_31;
  }
  if ((v26 & 0x4014000) != 0) {
    int v20 = -67032;
  }
  else {
LABEL_30:
  }
    int v20 = (*(uint64_t (**)(_DWORD *))(*(void *)v24 + 24))(v24);
LABEL_31:
  if (!v15) {
    goto LABEL_34;
  }
  goto LABEL_32;
}

void sub_18B3E3B7C(_Unwind_Exception *a1)
{
}

void SecStaticCodeCheckValidityWithErrors::_DTFrameCODESIGN_EVAL_STATIC::~_DTFrameCODESIGN_EVAL_STATIC(SecStaticCodeCheckValidityWithErrors::_DTFrameCODESIGN_EVAL_STATIC *this)
{
}

uint64_t SecStaticCodeValidateResourceWithErrors(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, int a3)
{
  if ((a3 & 0x1FFC9DAE) != 0) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  Security::SecPointerBase::SecPointerBase(&v10, (uint64_t)v5);
  SecCSFlags v6 = (Security::CodeSigning::SecStaticCode *)v10;
  *(_DWORD *)(v10 + 208)  = a3;
  Security::cfString((Security *)__p, a2);
  Security::CodeSigning::SecStaticCode::staticValidateResource(v6, (std::string::size_type)__p, a3, 0);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v10);
  return 0;
}

void sub_18B3E3CC0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a15);
  switch(a2)
  {
    case 7:
      int v18 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v18, v15);
      goto LABEL_34;
    case 6:
      int v19 = __cxa_begin_catch(a1);
      if (v19[36] == 8) {
        int v20 = -67049;
      }
      else {
        int v20 = (*(uint64_t (**)(_DWORD *))(*(void *)v19 + 24))(v19);
      }
      if (v15)
      {
LABEL_32:
        CFErrorRef v23 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v20, 0);
        goto LABEL_33;
      }
LABEL_34:
      __cxa_end_catch();
      JUMPOUT(0x18B3E3C98);
    case 5:
      unint64_t v21 = __cxa_begin_catch(a1);
      int v22 = (*(uint64_t (**)(void *))(*(void *)v21 + 24))(v21);
      if (!v15) {
        goto LABEL_34;
      }
      CFErrorRef v23 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v22, 0);
LABEL_33:
      *int v15 = v23;
      goto LABEL_34;
  }
  if (a2 != 4)
  {
    if (a2 == 3)
    {
      uint64_t v27 = __cxa_begin_catch(a1);
      int v28 = (*(uint64_t (**)(void *))(*(void *)v27 + 24))(v27);
      if (v15) {
        *int v15 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v28, 0);
      }
    }
    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v15) {
          *int v15 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], -108, 0);
        }
      }
      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v29);
        if (v15) {
          *int v15 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], -67048, 0);
        }
      }
    }
    goto LABEL_34;
  }
  uint64_t v24 = __cxa_begin_catch(a1);
  unsigned int v25 = v24[36];
  if (v25 > 0x1A) {
    goto LABEL_30;
  }
  int v20 = -67033;
  int v26 = 1 << v25;
  if ((v26 & 0x800108) != 0) {
    goto LABEL_31;
  }
  if ((v26 & 0x4014000) != 0) {
    int v20 = -67032;
  }
  else {
LABEL_30:
  }
    int v20 = (*(uint64_t (**)(_DWORD *))(*(void *)v24 + 24))(v24);
LABEL_31:
  if (!v15) {
    goto LABEL_34;
  }
  goto LABEL_32;
}

void sub_18B3E3F78(_Unwind_Exception *a1)
{
}

OSStatus SecCodeCopyPath(SecStaticCodeRef staticCode, SecCSFlags flags, CFURLRef *path)
{
  if (flags) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = Security::CodeSigning::SecStaticCode::requiredStatic(staticCode, *(const __SecCode **)&flags);
  Security::SecPointerBase::SecPointerBase(&v7, (uint64_t)v4);
  CFURLRef v5 = (const __CFURL *)(*(uint64_t (**)(void))(**(void **)(v7 + 32) + 48))(*(void *)(v7 + 32));
  if (!path) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  }
  *path  = v5;
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v7);
  return 0;
}

void sub_18B3E4078(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  switch(a2)
  {
    case 6:
      OSStatus v11 = __cxa_begin_catch(a1);
      if (v11[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v11 + 24))(v11);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      OSStatus v11 = __cxa_begin_catch(a1);
      unsigned int v13 = v11[36];
      if (v13 > 0x1A) {
        goto LABEL_6;
      }
      int v14 = 1 << v13;
      if ((v14 & 0x800108) == 0 && (v14 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      int v12 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v12 + 24))(v12);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v15);
      }
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18B3E4048);
}

void sub_18B3E4210(_Unwind_Exception *a1)
{
}

OSStatus SecCodeCopyDesignatedRequirement(SecStaticCodeRef code, SecCSFlags flags, SecRequirementRef *requirement)
{
  if (flags) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  uint64_t v4 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(code, *(const __SecCode **)&flags);
  CFURLRef v5 = (unsigned int *)Security::CodeSigning::SecStaticCode::designatedRequirement(v4);
  uint64_t v6 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  int v8 = (atomic_uchar *)Security::SecCFObject::allocate((Security::SecCFObject *)0x18, *(void *)(v6 + 304), v7);
  Security::CodeSigning::SecRequirement::SecRequirement(v8, v5, 0);
  char v9 = (__SecRequirement *)Security::SecCFObject::handle(v8, 1);
  if (!requirement) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  }
  unint64_t v10 = v9;
  OSStatus result = 0;
  *requirement  = v10;
  return result;
}

void sub_18B3E42E8(void *a1, int a2)
{
  Security::SecCFObject::operator delete(v2);
  switch(a2)
  {
    case 6:
      CFURLRef v5 = __cxa_begin_catch(a1);
      if (v5[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v5 + 24))(v5);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      CFURLRef v5 = __cxa_begin_catch(a1);
      unsigned int v7 = v5[36];
      if (v7 > 0x1A) {
        goto LABEL_6;
      }
      int v8 = 1 << v7;
      if ((v8 & 0x800108) == 0 && (v8 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      uint64_t v6 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v6 + 24))(v6);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v9);
      }
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18B3E42B8);
}

void sub_18B3E4480(_Unwind_Exception *a1)
{
}

uint64_t SecCodeCopyInternalRequirement(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, int a3, void *a4)
{
  if (a3) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  int v5 = (int)a2;
  uint64_t v6 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  unsigned int v7 = Security::CodeSigning::SecStaticCode::internalRequirements(v6);
  if (v7
    && (int v8 = Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::find<Security::CodeSigning::Requirement>((uint64_t)v7, v5)) != 0)
  {
    uint64_t v9 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
    OSStatus v11 = (atomic_uchar *)Security::SecCFObject::allocate((Security::SecCFObject *)0x18, *(void *)(v9 + 304), v10);
    Security::CodeSigning::SecRequirement::SecRequirement(v11, v8, 0);
    int v12 = Security::SecCFObject::handle(v11, 1);
  }
  else
  {
    int v12 = 0;
  }
  if (!a4) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  }
  uint64_t result = 0;
  *a4  = v12;
  return result;
}

void sub_18B3E4574(void *a1, int a2)
{
  Security::SecCFObject::operator delete(v2);
  switch(a2)
  {
    case 6:
      int v5 = __cxa_begin_catch(a1);
      if (v5[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v5 + 24))(v5);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      int v5 = __cxa_begin_catch(a1);
      unsigned int v7 = v5[36];
      if (v7 > 0x1A) {
        goto LABEL_6;
      }
      int v8 = 1 << v7;
      if ((v8 & 0x800108) == 0 && (v8 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      uint64_t v6 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v6 + 24))(v6);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v9);
      }
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18B3E4544);
}

void sub_18B3E470C(_Unwind_Exception *a1)
{
}

uint64_t SecCodeSetDetachedSignature(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, int a3)
{
  if (a3) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  uint64_t v6 = (Security::CodeSigning::SecStaticCode *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  Security::SecPointerBase::SecPointerBase(&v6, (uint64_t)v4);
  Security::CodeSigning::SecStaticCode::detachedSignature(v6, a2);
  Security::CodeSigning::SecStaticCode::resetValidity(v6);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v6);
  return 0;
}

void sub_18B3E47C4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  switch(a2)
  {
    case 6:
      OSStatus v11 = __cxa_begin_catch(a1);
      if (v11[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v11 + 24))(v11);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      OSStatus v11 = __cxa_begin_catch(a1);
      unsigned int v13 = v11[36];
      if (v13 > 0x1A) {
        goto LABEL_6;
      }
      int v14 = 1 << v13;
      if ((v14 & 0x800108) == 0 && (v14 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      int v12 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v12 + 24))(v12);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v15);
      }
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18B3E47A4);
}

void sub_18B3E495C(_Unwind_Exception *a1)
{
}

OSStatus SecCodeMapMemory(SecStaticCodeRef code, SecCSFlags flags)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (flags) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  unint64_t v10 = (Security::CodeSigning::SecStaticCode *)0xAAAAAAAAAAAAAAAALL;
  audit_token_t v2 = Security::CodeSigning::SecStaticCode::requiredStatic(code, *(const __SecCode **)&flags);
  Security::SecPointerBase::SecPointerBase(&v10, (uint64_t)v2);
  audit_token_t v3 = Security::CodeSigning::SecStaticCode::codeDirectory(v10, 0);
  if (!v3) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ALL);
  }
  uint64_t v4 = v10;
  if ((*(uint64_t (**)(void))(**((void **)v10 + 4) + 16))(*((void *)v10 + 4)) == *((void *)v4 + 4))
  {
    int v8 = (Security::Universal *)(*(uint64_t (**)(void))(**((void **)v10 + 4) + 80))(*((void *)v10 + 4));
    if (v8) {
      Security::Universal::architecture(v8);
    }
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2BLL);
  }
  *(void *)&v12[32]  = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)int v12 = v5;
  *(_OWORD *)&v12[16]  = v5;
  long long v11 = v5;
  *(void *)&long long v11 = (*(uint64_t (**)(void))(**((void **)v10 + 4) + 88))(*((void *)v10 + 4));
  *((void *)&v11 + 1)  = v3;
  *(void *)int v12 = bswap32(*((_DWORD *)v3 + 1));
  memset(&v12[8], 0, 32);
  uint64_t v6 = (int *)(*(uint64_t (**)(void))(**((void **)v10 + 4) + 144))(*((void *)v10 + 4));
  if (fcntl(*v6, 59, &v11) == -1)
  {
    unsigned int v7 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v7);
  }
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v10);
  return 0;
}

void sub_18B3E4CC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a10);
  if (a2 == 6)
  {
    uint64_t v13 = __cxa_begin_catch(exception_object);
    if (v13[36] == 8) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  if (a2 != 5)
  {
    if (a2 == 4)
    {
      uint64_t v13 = __cxa_begin_catch(exception_object);
      unsigned int v15 = v13[36];
      if (v15 <= 0x1A)
      {
        int v16 = 1 << v15;
        if ((v16 & 0x800108) != 0 || (v16 & 0x4014000) != 0) {
          goto LABEL_17;
        }
      }
LABEL_16:
      (*(void (**)(_DWORD *))(*(void *)v13 + 24))(v13);
LABEL_17:
      __cxa_end_catch();
LABEL_19:
      JUMPOUT(0x18B3E4C34);
    }
    if (a2 != 3)
    {
      __cxa_begin_catch(exception_object);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v17);
      }
      goto LABEL_17;
    }
  }
  int v14 = __cxa_begin_catch(exception_object);
  (*(void (**)(void *))(*(void *)v14 + 24))(v14);
  __cxa_end_catch();
  goto LABEL_19;
}

uint64_t SecStaticCodeSetCallback(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, void *a3, uint64_t a4)
{
  if (a2) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  uint64_t v6 = Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  unsigned int v7 = v6;
  if (a3) {
    *a3  = v6[72];
  }
  uint64_t result = 0;
  v7[72]  = a4;
  return result;
}

void sub_18B3E4F94(void *a1, int a2)
{
  switch(a2)
  {
    case 6:
      audit_token_t v3 = __cxa_begin_catch(a1);
      if (v3[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v3 + 24))(v3);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      audit_token_t v3 = __cxa_begin_catch(a1);
      unsigned int v5 = v3[36];
      if (v5 > 0x1A) {
        goto LABEL_6;
      }
      int v6 = 1 << v5;
      if ((v6 & 0x800108) == 0 && (v6 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      uint64_t v4 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v4 + 24))(v4);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v7);
      }
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18B3E4F78);
}

void sub_18B3E5110(_Unwind_Exception *a1)
{
}

uint64_t SecStaticCodeSetValidationConditions(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2)
{
  audit_token_t v3 = (CFTypeRef *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  if (a2)
  {
    uint64_t v4 = v3;
    unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
    Security::CFCopyRef<__CFDictionary const*>::CFCopyRef(&v9, a2);
    LODWORD(v10)  = -67024;
    unsigned int v5 = Security::CFDictionary::get<__CFArray const*>((uint64_t)&v9, "omissions");
    Security::CFRef<__CFArray const*>::operator=(v4 + 21, v5);
    CFArrayRef v6 = (const __CFArray *)Security::CFDictionary::get<__CFArray const*>((uint64_t)&v9, "errors");
    CFArrayRef v7 = v6;
    if (v6)
    {
      v11.size_t length = CFArrayGetCount(v6);
      v11.CFIndex location = 0;
      CFArrayApplyFunction(v7, v11, (CFArrayApplierFunction)Security::CodeSigning::addError, v4 + 18);
    }
    Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v9);
  }
  return 0;
}

void sub_18B3E521C(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  Security::CFRef<__CFDictionary const*>::~CFRef(&a9);
  switch(a2)
  {
    case 6:
      CFRange v11 = __cxa_begin_catch(a1);
      if (v11[36] == 8) {
        break;
      }
      goto LABEL_6;
    case 5:
      goto LABEL_5;
    case 4:
      CFRange v11 = __cxa_begin_catch(a1);
      unsigned int v13 = v11[36];
      if (v13 > 0x1A || (int v14 = 1 << v13, (v14 & 0x800108) == 0) && (v14 & 0x4014000) == 0) {
LABEL_6:
      }
        (*(void (**)(_DWORD *))(*(void *)v11 + 24))(v11);
      break;
    case 3:
LABEL_5:
      int v12 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v12 + 24))(v12);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v15);
      }
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18B3E5208);
}

void sub_18B3E53A8(_Unwind_Exception *a1)
{
}

uint64_t SecStaticCodeCancelValidation(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2)
{
  audit_token_t v2 = (dispatch_queue_t *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  audit_token_t v3 = v2;
  if ((*((unsigned char *)v2 + 211) & 0x10) == 0) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  dispatch_assert_queue_V2(v2[39]);
  uint64_t result = 0;
  *((unsigned char *)v3 + 220)  = 1;
  return result;
}

unint64_t SecCodeCopyComponent(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, const __CFData *a3)
{
  unsigned int v5 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  CFArrayRef v6 = Security::CodeSigning::SecStaticCode::codeDirectory(v5, 1);
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  CFArrayRef v7 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *, const __SecCode *, uint64_t))(*(void *)v5 + 80))(v5, a2, 4294900235);
  Security::CFCopyRef<__CFData const*>::CFCopyRef(&v15, v7);
  unint64_t v8 = v15;
  if (v15)
  {
    if (a3)
    {
      unsigned int v9 = *((_DWORD *)v6 + 4);
      uint64_t v10 = v6[36];
      if (CFDataGetLength(a3) != v10
        || (BytePtr  = CFDataGetBytePtr(a3), memcmp(&v6[bswap32(v9) + (int)v10 * (uint64_t)(int)a2], BytePtr, v6[36])))
      {
        CFIndex Length = CFDataGetLength(a3);
        Security::Syslog::notice((Security::Syslog *)"copyComponent hash mismatch slot %d length %d", v13, a2, Length);
        unint64_t v8 = 0;
        goto LABEL_8;
      }
      unint64_t v8 = v15;
    }
    unint64_t v15 = 0;
  }
LABEL_8:
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v15);
  return v8;
}

void sub_18B3E5728(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18B3E570CLL);
}

uint64_t SecCodeSpecialSlotIsPresent(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2)
{
  int v2 = (int)a2;
  audit_token_t v3 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  uint64_t v4 = (Security::CodeSigning::CodeDirectory *)Security::CodeSigning::SecStaticCode::codeDirectory(v3, 1);
  IsPresent  = Security::CodeSigning::CodeDirectory::slotIsPresent(v4, -v2);
  uint64_t v6 = MEMORY[0x1E4F1CFD0];
  if (!IsPresent) {
    uint64_t v6 = MEMORY[0x1E4F1CFC8];
  }
  return *(void *)v6;
}

void sub_18B3E57A4(void *a1)
{
}

uint64_t SecStaticCodeEnableOnlineNotarizationCheck(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2)
{
  int v2 = (int)a2;
  audit_token_t v3 = Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  uint64_t result = 0;
  v3[148]  = v3[148] & 0xFFFFFFFE | (v2 != 0);
  return result;
}

OSStatus SecCodeValidateFileResource(SecStaticCodeRef code, CFStringRef relativePath, CFDataRef fileData, SecCSFlags flags)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (fileData)
  {
    unsigned int v5 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(code, (const __SecCode *)relativePath);
    Security::cfString(&__p, relativePath);
    int v18 = (__CFDictionary *)0xAAAAAAAAAAAAAAAALL;
    int v19 = (__CFDictionary *)0xAAAAAAAAAAAAAAAALL;
    if (Security::CodeSigning::SecStaticCode::loadResources(v5, &v19, &v18, &v17))
    {
      uint64_t v6 = v18;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&v16, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      }
      else {
        std::string v16 = __p;
      }
      Security::CFTempString::CFTempString<std::string>((CFStringRef *)key, (char *)&v16);
      CFStringRef Value = CFDictionaryGetValue(v6, key[0]);
      Security::CFRef<__CFString const*>::~CFRef((const void **)key);
      if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v16.__r_.__value_.__l.__data_);
      }
      uint64_t v8 = 4294900242;
      if (Value)
      {
        *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v9 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        v15[0]  = v9;
        v15[1]  = v9;
        Security::CodeSigning::ResourceSeal::ResourceSeal((Security::CodeSigning::ResourceSeal *)v15, Value);
        uint64_t v10 = Security::CodeSigning::SecStaticCode::codeDirectory(v5, 1);
        if (Security::CodeSigning::ResourceSeal::hash((CFDictionaryRef *)v15, v10[37]))
        {
          CFRange v11 = Security::CodeSigning::SecStaticCode::codeDirectory(v5, 1);
          unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v12 + 1)  = 0xAAAAAAAAAAAAAAAALL;
          long long v22 = v12;
          long long v23 = v12;
          *(_OWORD *)SecKeyRef key = v12;
          long long v21 = v12;
          Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)v11[37]);
        }
        Security::CFRef<__CFDictionary const*>::~CFRef((const void **)v15);
      }
    }
    else
    {
      uint64_t v8 = 4294900240;
    }
    Security::MacOSError::throwMe((Security::MacOSError *)v8);
  }
  Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
}

void sub_18B3E5C00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,const void *a29)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  Security::CFRef<__CFString const*>::~CFRef(&a29);
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a2 == 6)
  {
    unsigned int v31 = __cxa_begin_catch(exception_object);
    if (v31[36] == 8) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if (a2 != 5)
  {
    if (a2 == 4)
    {
      unsigned int v31 = __cxa_begin_catch(exception_object);
      unsigned int v33 = v31[36];
      if (v33 <= 0x1A)
      {
        int v34 = 1 << v33;
        if ((v34 & 0x800108) != 0 || (v34 & 0x4014000) != 0) {
          goto LABEL_21;
        }
      }
LABEL_20:
      (*(void (**)(_DWORD *))(*(void *)v31 + 24))(v31);
LABEL_21:
      __cxa_end_catch();
LABEL_23:
      JUMPOUT(0x18B3E5B98);
    }
    if (a2 != 3)
    {
      __cxa_begin_catch(exception_object);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v35);
      }
      goto LABEL_21;
    }
  }
  int v32 = __cxa_begin_catch(exception_object);
  (*(void (**)(void *))(*(void *)v32 + 24))(v32);
  __cxa_end_catch();
  goto LABEL_23;
}

CFTypeID SecRequirementGetTypeID(void)
{
  return *(void *)(Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()() + 304);
}

void sub_18B3E5E80(void *a1)
{
}

OSStatus SecRequirementCreateWithData(CFDataRef data, SecCSFlags flags, SecRequirementRef *requirement)
{
  if (flags)
  {
    uint64_t v13 = 4294900226;
    goto LABEL_12;
  }
  uint64_t v5 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  uint64_t v7 = Security::SecCFObject::allocate((Security::SecCFObject *)0x18, *(void *)(v5 + 304), v6);
  BytePtr  = (unsigned int *)CFDataGetBytePtr(data);
  unint64_t Length = CFDataGetLength(data);
  *(void *)(v7 + 8)  = 1;
  *(void *)uint64_t v7 = &unk_1ED84A4D8;
  *(void *)(v7 + 16)  = 0;
  if (Length < 0xC) {
LABEL_10:
  }
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA14);
  if (*BytePtr != 843514 || (unsigned int v10 = bswap32(BytePtr[1]), v10 <= 0xB))
  {
    *__error()  = 22;
    goto LABEL_10;
  }
  if (Length != v10) {
    goto LABEL_10;
  }
  *(void *)(v7 + 16)  = Security::Blob<Security::CodeSigning::Requirement,4208856064u>::clone((Security::BlobCore *)BytePtr);
  CFRange v11 = (__SecRequirement *)Security::SecCFObject::handle((atomic_uchar *)v7, 1);
  if (!requirement)
  {
    uint64_t v13 = 4294900227;
LABEL_12:
    Security::MacOSError::throwMe((Security::MacOSError *)v13);
  }
  *requirement  = v11;
  return 0;
}

void sub_18B3E5FAC(void *a1, int a2)
{
  Security::SecCFObject::operator delete(v2);
  switch(a2)
  {
    case 6:
      uint64_t v5 = __cxa_begin_catch(a1);
      if (v5[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v5 + 24))(v5);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      uint64_t v5 = __cxa_begin_catch(a1);
      unsigned int v7 = v5[36];
      if (v7 > 0x1A) {
        goto LABEL_6;
      }
      int v8 = 1 << v7;
      if ((v8 & 0x800108) == 0 && (v8 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      uint64_t v6 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v6 + 24))(v6);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v9);
      }
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18B3E5F64);
}

void sub_18B3E6128(_Unwind_Exception *a1)
{
}

OSStatus SecRequirementCreateWithString(CFStringRef text, SecCSFlags flags, SecRequirementRef *requirement)
{
  return SecRequirementCreateWithStringAndErrors(text, flags, 0, requirement);
}

OSStatus SecRequirementCreateWithStringAndErrors(CFStringRef text, SecCSFlags flags, CFErrorRef *errors, SecRequirementRef *requirement)
{
  if (flags) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  uint64_t v6 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  int v8 = (atomic_uchar *)Security::SecCFObject::allocate((Security::SecCFObject *)0x18, *(void *)(v6 + 304), v7);
  Security::cfString(&__p, text);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v16, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else {
    std::string v16 = __p;
  }
  memset(&v20, 0, sizeof(v20));
  long long v9 = *(uint64_t (**)(std::string *, std::string *))(*(void *)(Security::ModuleNexus<Security::CodeSigning::PluginHost>::operator()()
                                                                          + 72)
                                                              + 24);
  int v10 = SHIBYTE(v16.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v19, v16.__r_.__value_.__l.__data_, v16.__r_.__value_.__l.__size_);
  }
  else {
    std::string v19 = v16;
  }
  CFRange v11 = (unsigned int *)v9(&v19, &v20);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (!v11)
  {
    if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v17, v20.__r_.__value_.__l.__data_, v20.__r_.__value_.__l.__size_);
    }
    else {
      std::string v17 = v20;
    }
    Security::CFTempString::CFTempString<std::string>((CFStringRef *)&v18, (char *)&v17);
    Security::CodeSigning::CSError::throwMe((Security::CodeSigning::CSError *)0xFFFEFA14, @"SecRequirementSyntax", v18, v14);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v20.__r_.__value_.__l.__data_);
    if ((v10 & 0x80000000) == 0) {
      goto LABEL_13;
    }
  }
  else if ((v10 & 0x80000000) == 0)
  {
    goto LABEL_13;
  }
  operator delete(v16.__r_.__value_.__l.__data_);
LABEL_13:
  Security::CodeSigning::SecRequirement::SecRequirement(v8, v11, 1);
  long long v12 = (__SecRequirement *)Security::SecCFObject::handle(v8, 1);
  if (!requirement) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  }
  *requirement  = v12;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_18B3E6340(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (*(char *)(v37 - 49) < 0) {
    operator delete(*(void **)(v37 - 72));
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  Security::SecCFObject::operator delete(v36);
  switch(a2)
  {
    case 7:
      BOOL v40 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v40, v35);
      goto LABEL_38;
    case 6:
      long long v41 = __cxa_begin_catch(a1);
      if (v41[36] == 8) {
        int v42 = -67049;
      }
      else {
        int v42 = (*(uint64_t (**)(_DWORD *))(*(void *)v41 + 24))(v41);
      }
      if (v35)
      {
LABEL_36:
        CFErrorRef v45 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v42, 0);
        goto LABEL_37;
      }
LABEL_38:
      __cxa_end_catch();
      JUMPOUT(0x18B3E6298);
    case 5:
      unsigned int v43 = __cxa_begin_catch(a1);
      int v44 = (*(uint64_t (**)(void *))(*(void *)v43 + 24))(v43);
      if (!v35) {
        goto LABEL_38;
      }
      CFErrorRef v45 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v44, 0);
LABEL_37:
      *std::string v35 = v45;
      goto LABEL_38;
  }
  if (a2 != 4)
  {
    if (a2 == 3)
    {
      std::string::size_type v49 = __cxa_begin_catch(a1);
      int v50 = (*(uint64_t (**)(void *))(*(void *)v49 + 24))(v49);
      if (v35) {
        *std::string v35 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v50, 0);
      }
    }
    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v35) {
          *std::string v35 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], -108, 0);
        }
      }
      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v51);
        if (v35) {
          *std::string v35 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], -67048, 0);
        }
      }
    }
    goto LABEL_38;
  }
  int v46 = __cxa_begin_catch(a1);
  unsigned int v47 = v46[36];
  if (v47 > 0x1A) {
    goto LABEL_34;
  }
  int v42 = -67033;
  int v48 = 1 << v47;
  if ((v48 & 0x800108) != 0) {
    goto LABEL_35;
  }
  if ((v48 & 0x4014000) != 0) {
    int v42 = -67032;
  }
  else {
LABEL_34:
  }
    int v42 = (*(uint64_t (**)(_DWORD *))(*(void *)v46 + 24))(v46);
LABEL_35:
  if (!v35) {
    goto LABEL_38;
  }
  goto LABEL_36;
}

void sub_18B3E667C(_Unwind_Exception *a1)
{
}

OSStatus SecRequirementCopyData(SecRequirementRef requirement, SecCSFlags flags, CFDataRef *data)
{
  uint64_t v5 = (const UInt8 **)Security::CodeSigning::SecRequirement::required(requirement, *(__SecRequirement **)&flags);
  if (flags)
  {
    uint64_t v7 = 4294900226;
    goto LABEL_6;
  }
  if (!data)
  {
    uint64_t v7 = 4294900227;
LABEL_6:
    Security::MacOSError::throwMe((Security::MacOSError *)v7);
  }
  const UInt8 *data = CFDataCreate(0, v5[2], bswap32(*((_DWORD *)v5[2] + 1)));
  return 0;
}

void *Security::CodeSigning::SecRequirement::required(Security::CodeSigning::SecRequirement *this, __SecRequirement *a2)
{
  if (!this
  {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  }
  return result;
}

OSStatus SecRequirementCopyString(SecRequirementRef requirement, SecCSFlags flags, CFStringRef *text)
{
  uint64_t v5 = Security::CodeSigning::SecRequirement::required(requirement, *(__SecRequirement **)&flags);
  if (flags)
  {
    uint64_t v11 = 4294900226;
    goto LABEL_15;
  }
  if (!text)
  {
    uint64_t v11 = 4294900227;
LABEL_15:
    Security::MacOSError::throwMe((Security::MacOSError *)v11);
  }
  Security::CodeSigning::Dumper::dump(&cStr, v5[2]);
  if (SHIBYTE(cStr.__r_.__value_.__r.__words[2]) < 0)
  {
    p_cStr  = (std::string *)cStr.__r_.__value_.__r.__words[0];
    if (!cStr.__r_.__value_.__r.__words[0])
    {
      long long v9 = 0;
      *text  = 0;
      goto LABEL_11;
    }
  }
  else
  {
    p_cStr  = &cStr;
  }
  CFStringRef v7 = CFStringCreateWithCString(0, (const char *)p_cStr, 0x8000100u);
  if (!v7)
  {
    CFStringRef v7 = CFStringCreateWithCString(0, (const char *)p_cStr, 0x600u);
    if (!v7) {
      Security::CFError::throwMe(0);
    }
  }
  int v8 = SHIBYTE(cStr.__r_.__value_.__r.__words[2]);
  *text  = v7;
  if (v8 < 0)
  {
    long long v9 = (void *)cStr.__r_.__value_.__r.__words[0];
LABEL_11:
    operator delete(v9);
  }
  return 0;
}

void sub_18B3E6A2C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  switch(a2)
  {
    case 6:
      std::string v16 = __cxa_begin_catch(a1);
      if (v16[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v16 + 24))(v16);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      std::string v16 = __cxa_begin_catch(a1);
      unsigned int v18 = v16[36];
      if (v18 > 0x1A) {
        goto LABEL_6;
      }
      int v19 = 1 << v18;
      if ((v19 & 0x800108) == 0 && (v19 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      std::string v17 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v17 + 24))(v17);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v20);
      }
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18B3E69F8);
}

void sub_18B3E6BB0(_Unwind_Exception *a1)
{
}

_DWORD *Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::make(void *a1)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1[2];
  audit_token_t v3 = (void *)*a1;
  uint64_t v4 = a1 + 1;
  if ((void *)*a1 == a1 + 1)
  {
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    do
    {
      uint64_t v6 = (void *)v3[1];
      CFStringRef v7 = v3;
      if (v6)
      {
        do
        {
          int v8 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          int v8 = (void *)v7[2];
          BOOL v9 = *v8 == (void)v7;
          CFStringRef v7 = v8;
        }
        while (!v9);
      }
      v5 += bswap32(*(_DWORD *)(v3[5] + 4));
      audit_token_t v3 = v8;
    }
    while (v8 != v4);
  }
  unsigned int v10 = v5 + 8 * v2 + 12;
  uint64_t v11 = malloc_type_malloc(v10, 0x79CB62BEuLL);
  if (!v11) {
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  long long v12 = v11;
  unsigned int v13 = *((_DWORD *)a1 + 4);
  *uint64_t v11 = 17620730;
  v11[1]  = bswap32(v10);
  void v11[2] = bswap32(v13);
  int v14 = (void *)*a1;
  if ((void *)*a1 != v4)
  {
    int v15 = 0;
    unsigned int v16 = 8 * v2 + 12;
    do
    {
      std::string v17 = &v12[2 * v15];
      unint64_t v17[3] = bswap32(*((_DWORD *)v14 + 8));
      void v17[4] = bswap32(v16);
      memcpy((char *)v12 + v16, (const void *)v14[5], bswap32(*(_DWORD *)(v14[5] + 4)));
      unsigned int v18 = (void *)v14[1];
      int v19 = v14;
      if (v18)
      {
        do
        {
          std::string v20 = v18;
          unsigned int v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          std::string v20 = (void *)v19[2];
          BOOL v9 = *v20 == (void)v19;
          int v19 = v20;
        }
        while (!v9);
      }
      v16 += bswap32(*(_DWORD *)(v14[5] + 4));
      ++v15;
      int v14 = v20;
    }
    while (v20 != v4);
  }
  unint64_t v36 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v21 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v21 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v35[7]  = v21;
  v35[8]  = v21;
  v35[5]  = v21;
  v35[6]  = v21;
  v35[3]  = v21;
  _OWORD v35[4] = v21;
  v35[1]  = v21;
  v35[2]  = v21;
  v35[0]  = v21;
  long long v33 = v21;
  long long v34 = v21;
  v31[3]  = v21;
  *(_OWORD *)std::string __p = v21;
  v31[1]  = v21;
  int v31[2] = v21;
  v31[0]  = v21;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v31);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)"Maker ", 6);
  long long v22 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)" assembles ", 11);
  long long v23 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)" blob(s) into ", 14);
  unint64_t v24 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)" (size=", 7);
  uint64_t v25 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)")", 1);
  int v26 = secLogObjForScope("superblob");
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)v31 + 8);
    int v28 = v30 >= 0 ? __dst : (void **)__dst[0];
    *(_DWORD *)long long buf = 136315138;
    long long v38 = v28;
    _os_log_debug_impl(&dword_18B299000, v26, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
    if (v30 < 0) {
      operator delete(__dst[0]);
    }
  }
  *(void *)&v31[0]  = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v31 + *(void *)(*(void *)&v31[0] - 24))  = *(void *)(MEMORY[0x1E4FBA418] + 24);
  *((void *)&v31[0] + 1)  = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v33) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x18C12D300](v35);
  return v12;
}

void sub_18B3E6FC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

_DWORD *Security::Blob<Security::CodeSigning::Requirement,4208856064u>::clone(Security::BlobCore *a1)
{
  uint64_t result = Security::BlobCore::clone(a1);
  unsigned int v2 = bswap32(result[1]);
  if (*result != 843514 || v2 <= 0xB)
  {
    uint64_t v4 = __error();
    uint64_t result = 0;
    *uint64_t v4 = 22;
  }
  return result;
}

void Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add(uint64_t **a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = std::__tree<std::__value_type<unsigned int,Security::BlobCore *>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::BlobCore *>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::BlobCore *>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,Security::BlobCore *>>(a1, a2, a2, a3);
  if (!v7)
  {
    int v8 = v6;
    BOOL v9 = secLogObjForScope("superblob");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      int v10 = 134218240;
      uint64_t v11 = a1;
      __int16 v12 = 1024;
      unsigned int v13 = a2;
      _os_log_debug_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEBUG, "Maker %p replaces type=%d", (uint8_t *)&v10, 0x12u);
    }
    free(v8[5]);
    void v8[5] = a3;
  }
}

uint64_t **std::__tree<std::__value_type<unsigned int,Security::BlobCore *>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::BlobCore *>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::BlobCore *>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,Security::BlobCore *>>(uint64_t **a1, unsigned int a2, int a3, uint64_t *a4)
{
  int v8 = a1 + 1;
  char v7 = a1[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        BOOL v9 = (uint64_t **)v7;
        unsigned int v10 = *((_DWORD *)v7 + 8);
        if (v10 <= a2) {
          break;
        }
        char v7 = *v9;
        int v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v10 >= a2) {
        break;
      }
      char v7 = v9[1];
      if (!v7)
      {
        int v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v9 = a1 + 1;
LABEL_9:
    uint64_t v11 = (uint64_t *)v9;
    BOOL v9 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v9 + 8)  = a3;
    void v9[5] = a4;
    *BOOL v9 = 0;
    v9[1]  = 0;
    _OWORD v9[2] = v11;
    *int v8 = (uint64_t *)v9;
    __int16 v12 = (uint64_t *)**a1;
    unsigned int v13 = (uint64_t *)v9;
    if (v12)
    {
      *a1  = v12;
      unsigned int v13 = *v8;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v13);
    a1[2]  = (uint64_t *)((char *)a1[2] + 1);
  }
  return v9;
}

void *Security::BlobCore::clone(Security::BlobCore *this)
{
  unsigned int v2 = malloc_type_malloc(bswap32(*((_DWORD *)this + 1)), 0x18E3CB5FuLL);
  if (!v2) {
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  size_t v3 = bswap32(*((_DWORD *)this + 1));

  return memcpy(v2, this, v3);
}

const void **Security::CFRef<__SecRequirement *>::~CFRef(const void **a1)
{
  unsigned int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t SecRequirementCreateWithLightweightCodeRequirementData(const __CFData *a1, int a2, void *a3)
{
  if (a2) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  uint64_t result = 4294900227;
  if (a1 && a3)
  {
    int v16 = 1024;
    uint64_t v6 = (unsigned int *)malloc_type_malloc(0x400uLL, 0x96562061uLL);
    int v15 = v6;
    *(void *)uint64_t v6 = 843514;
    _DWORD v6[2] = 0x2000000;
    unsigned int v17 = 12;
    BytePtr  = CFDataGetBytePtr(a1);
    CFIndex Length = CFDataGetLength(a1);
    BOOL v9 = makeLightweightCodeRequirement(a1);
    if (!v9) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFC73);
    }

    Security::CodeSigning::Requirement::Maker::putData((Security::CodeSigning::Requirement::Maker *)&v15, BytePtr, Length);
    uint64_t v10 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
    __int16 v12 = (atomic_uchar *)Security::SecCFObject::allocate((Security::SecCFObject *)0x18, *(void *)(v10 + 304), v11);
    unsigned int v13 = v15;
    v15[1]  = bswap32(v17);
    Security::CodeSigning::SecRequirement::SecRequirement(v12, v13, 1);
    uint64_t v14 = Security::SecCFObject::handle(v12, 1);
    uint64_t result = 0;
    *a3  = v14;
  }
  return result;
}

void sub_18B3E73B8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  Security::SecCFObject::operator delete(v10);
  free(0);
  switch(a2)
  {
    case 7:
      uint64_t v14 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v14, v9);
      __cxa_end_catch();
      goto LABEL_33;
    case 6:
      int v15 = __cxa_begin_catch(a1);
      if (v15[36] == 8) {
        int v16 = v11 - 16;
      }
      else {
        int v16 = (*(uint64_t (**)(_DWORD *))(*(void *)v15 + 24))(v15);
      }
      if (!v9) {
        goto LABEL_32;
      }
      goto LABEL_30;
    case 5:
      unsigned int v17 = __cxa_begin_catch(a1);
      int v18 = (*(uint64_t (**)(void *))(*(void *)v17 + 24))(v17);
      if (v9)
      {
        CFErrorRef v19 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v18, 0);
LABEL_31:
        *BOOL v9 = v19;
        goto LABEL_32;
      }
      goto LABEL_32;
  }
  if (a2 != 4)
  {
    if (a2 == 3)
    {
      long long v23 = __cxa_begin_catch(a1);
      int v24 = (*(uint64_t (**)(void *))(*(void *)v23 + 24))(v23);
      if (v9) {
        *BOOL v9 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v24, 0);
      }
    }
    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v9) {
          *BOOL v9 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], -108, 0);
        }
      }
      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v25);
        if (v9) {
          *BOOL v9 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], -67048, 0);
        }
      }
    }
    goto LABEL_32;
  }
  std::string v20 = __cxa_begin_catch(a1);
  unsigned int v21 = v20[36];
  if (v21 > 0x1A) {
    goto LABEL_28;
  }
  int v22 = 1 << v21;
  int v16 = -67033;
  if ((v22 & 0x800108) != 0) {
    goto LABEL_29;
  }
  if ((v22 & 0x4014000) != 0) {
    int v16 = v11 + 1;
  }
  else {
LABEL_28:
  }
    int v16 = (*(uint64_t (**)(_DWORD *))(*(void *)v20 + 24))(v20);
LABEL_29:
  if (v9)
  {
LABEL_30:
    CFErrorRef v19 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E4F1D158], v16, 0);
    goto LABEL_31;
  }
LABEL_32:
  __cxa_end_catch();
LABEL_33:
  JUMPOUT(0x18B3E7384);
}

void sub_18B3E767C(_Unwind_Exception *a1)
{
}

uint64_t mapFile(const char *a1, const void **a2, off_t *a3, char **a4)
{
  v7.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v7.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v13.st_blkstd::string::size_type size = v7;
  *(timespec *)v13.st_qspare  = v7;
  v13.st_birthtimespeCC_SHA512_CTX c = v7;
  *(timespec *)&v13.st_std::string::size_type size = v7;
  v13.st_mtimespeCC_SHA512_CTX c = v7;
  v13.st_ctimespeCC_SHA512_CTX c = v7;
  *(timespec *)&v13.st_uid  = v7;
  v13.st_atimespeCC_SHA512_CTX c = v7;
  *(timespec *)&v13.st_dev  = v7;
  int v8 = open(a1, 0, 0);
  if (v8 == -1)
  {
    __error();
    log_error(a4, "cannot open file %s, errno=%d\n");
  }
  else
  {
    int v9 = v8;
    if (fstat(v8, &v13))
    {
      __error();
      log_error(a4, "fstat(%s) failed, errno=%d\n");
    }
    else
    {
      uint64_t v10 = mmap(0, v13.st_size, 1, 8194, v9, 0);
      if (v10 != (void *)-1)
      {
        int v11 = v10;
        close(v9);
        *a2  = v11;
        *a3  = v13.st_size;
        return 1;
      }
      log_error(a4, "cannot mmap file %s\n");
    }
  }
  return 0;
}

uint64_t log_error(char **a1, const char *a2, ...)
{
  va_start(va, a2);
  return vasprintf(a1, a2, va);
}

BOOL vm_alloc(vm_address_t *a1, vm_size_t size, char **a3)
{
  kern_return_t v5;
  vm_address_t address;

  address  = 0;
  int v5 = vm_allocate(*MEMORY[0x1E4F14960], &address, size, 1);
  if (v5) {
    log_error(a3, "failed to allocate memory\n");
  }
  else {
    *a1  = address;
  }
  return v5 == 0;
}

uint64_t assure_signature_space(_DWORD *a1, unsigned int a2, unsigned int a3, unsigned int *a4, char **a5)
{
  int v5 = *a1;
  BOOL v6 = *a1 == -822415874 || v5 == -805638658;
  int v7 = v6;
  unsigned int v8 = a1[3];
  unsigned int v9 = bswap32(v8);
  if (v6) {
    unsigned int v8 = v9;
  }
  if (v8 > 0xB || ((1 << v8) & 0x9C4) == 0)
  {
    log_error(a5, "mach-o filetype (%d) does not support code signing\n");
    return 0;
  }
  BOOL v11 = v5 == -805638658 || v5 == -17958193;
  uint64_t v12 = 7;
  if (v11) {
    uint64_t v12 = 8;
  }
  unsigned int v13 = a1[5];
  unsigned int v14 = bswap32(a1[4]);
  if (v7) {
    unsigned int v15 = v14;
  }
  else {
    unsigned int v15 = a1[4];
  }
  LODWORD(v16)  = bswap32(v13);
  if (v7) {
    uint64_t v16 = v16;
  }
  else {
    uint64_t v16 = v13;
  }
  if (!v15) {
    goto LABEL_68;
  }
  CFNumberRef v84 = a5;
  int v17 = 0;
  int v18 = 0;
  CFErrorRef v19 = 0;
  std::string v20 = 0;
  unsigned int v21 = (char *)&a1[v12];
  uint64_t v79 = v16;
  int v22 = (_DWORD *)((char *)&a1[v12] + v16);
  long long v23 = (char *)&a1[v12];
  do
  {
    unsigned int v24 = *(_DWORD *)v23;
    unsigned int v25 = bswap32(*(_DWORD *)v23);
    if (v7) {
      unsigned int v24 = v25;
    }
    unsigned int v26 = bswap32(*((_DWORD *)v23 + 1));
    if (v7) {
      unsigned int v27 = v26;
    }
    else {
      unsigned int v27 = *((_DWORD *)v23 + 1);
    }
    switch(v24)
    {
      case 1u:
        if (!strcmp(v23 + 8, "__LINKEDIT")) {
          CFErrorRef v19 = v23;
        }
        break;
      case 0x19u:
        if (!strcmp(v23 + 8, "__LINKEDIT")) {
          int v18 = v23;
        }
        break;
      case 0x1Du:
        std::string v20 = v23;
        break;
    }
    v23 += v27;
    if (v23 > (char *)v22)
    {
      log_error(v84, "malformed mach-o file, load command #%d is outside size of load commands\n");
      return 0;
    }
    ++v17;
  }
  while (v15 != v17);
  if (!v19)
  {
    long long v34 = a4;
    a5  = v84;
    unsigned int v35 = a2;
    unint64_t v36 = a1;
    unsigned int v37 = a3;
    uint64_t v38 = v79;
    if (v18)
    {
      unint64_t v39 = *((void *)v18 + 5);
      unint64_t v40 = *((void *)v18 + 6);
      unint64_t v41 = bswap64(v39);
      if (v7) {
        unint64_t v39 = v41;
      }
      unint64_t v42 = bswap64(v40);
      if (v7) {
        unint64_t v40 = v42;
      }
      BOOL v32 = __CFADD__(v39, v40);
      unint64_t v43 = v39 + v40;
      if (!v32 && v43 <= a3) {
        goto LABEL_60;
      }
LABEL_69:
      log_error(a5, "malformed mach-o file, __LINKEDIT segment extends past end of file\n");
      return 0;
    }
LABEL_68:
    log_error(a5, "malformed mach-o file, no __LINKEDIT segment\n");
    return 0;
  }
  unsigned int v28 = *((_DWORD *)v19 + 8);
  unsigned int v29 = *((_DWORD *)v19 + 9);
  unsigned int v30 = bswap32(v28);
  if (v7) {
    unsigned int v28 = v30;
  }
  unsigned int v31 = bswap32(v29);
  if (v7) {
    unsigned int v29 = v31;
  }
  BOOL v32 = __CFADD__(v28, v29);
  unsigned int v33 = v28 + v29;
  long long v34 = a4;
  a5  = v84;
  unsigned int v35 = a2;
  unint64_t v36 = a1;
  unsigned int v37 = a3;
  uint64_t v38 = v79;
  if (v32 || v33 > a3) {
    goto LABEL_69;
  }
LABEL_60:
  if (v20)
  {
    unsigned int v44 = *((_DWORD *)v20 + 2);
    unsigned int v45 = *((_DWORD *)v20 + 3);
    unsigned int v46 = bswap32(v44);
    if (v7) {
      unsigned int v44 = v46;
    }
    unsigned int v47 = bswap32(v45);
    if (v7) {
      unsigned int v45 = v47;
    }
    BOOL v32 = __CFADD__(v44, v45);
    unsigned int v48 = v44 + v45;
    if (v32)
    {
      log_error(a5, "malformed mach-o file, LC_CODE_SIGNATURE offset + size overflows\n");
    }
    else if (v48 >= v37 - 7)
    {
      unsigned int v64 = bswap32(v35);
      if (!v7) {
        unsigned int v64 = v35;
      }
      *((_DWORD *)v20 + 3)  = v64;
      unsigned int v65 = *v34;
      BOOL v32 = __CFADD__(v44, v35);
      unsigned int v63 = v44 + v35;
      *long long v34 = v63;
      if (!v32)
      {
        if (v65 > v63)
        {
          bzero((char *)v36 + v63, v65 - v63);
          unsigned int v63 = *v34;
        }
        goto LABEL_112;
      }
      log_error(a5, "mew sigSpace causes overflow\n");
    }
    else
    {
      log_error(a5, "malformed mach-o file, LC_CODE_SIGNATURE does not point to end of file\n");
    }
    return 0;
  }
  int v50 = 0;
  BOOL v51 = 1;
  unint64_t v52 = 96;
  while (2)
  {
    unsigned int v53 = bswap32(*(_DWORD *)v21);
    if (!v7) {
      unsigned int v53 = *(_DWORD *)v21;
    }
    unsigned int v54 = bswap32(*((_DWORD *)v21 + 1));
    if (!v7) {
      unsigned int v54 = *((_DWORD *)v21 + 1);
    }
    if (v53 != 25)
    {
      if (v53 == 1 && !*((_DWORD *)v21 + 8) && *((_DWORD *)v21 + 9) && *((_DWORD *)v21 + 12)) {
        goto LABEL_129;
      }
      goto LABEL_85;
    }
    if (*((void *)v21 + 5) || !*((void *)v21 + 6) || !*((_DWORD *)v21 + 16))
    {
LABEL_85:
      v21 += v54;
      BOOL v51 = ++v50 < v15;
      if (v15 == v50) {
        goto LABEL_86;
      }
      continue;
    }
    break;
  }
  unint64_t v52 = 120;
LABEL_129:
  LODWORD(v52)  = *(_DWORD *)&v21[v52];
  unsigned int v78 = bswap32(v52);
  if (v7) {
    unint64_t v52 = v78;
  }
  else {
    unint64_t v52 = v52;
  }
  if (v51 && v38 + 16 > v52)
  {
    log_error(a5, "not enough room in load commands to add LC_CODE_SIGNATURE\n");
    return 0;
  }
LABEL_86:
  unsigned int v55 = v38 + 16;
  unsigned int v56 = bswap32(v38 + 16);
  if (v7) {
    unsigned int v55 = v56;
  }
  unsigned int v57 = bswap32(v15 + 1);
  if (!v7) {
    unsigned int v57 = v15 + 1;
  }
  v36[4]  = v57;
  void v36[5] = v55;
  if (v7) {
    int v58 = 486539264;
  }
  else {
    int v58 = 29;
  }
  if (v7) {
    int v59 = 0x10000000;
  }
  else {
    int v59 = 16;
  }
  *int v22 = v58;
  v22[1]  = v59;
  unsigned int v60 = (v37 + 15) & 0xFFFFFFF0;
  unsigned int v61 = bswap32(v60);
  if (!v7) {
    unsigned int v61 = (v37 + 15) & 0xFFFFFFF0;
  }
  unsigned int v62 = bswap32(v35);
  if (!v7) {
    unsigned int v62 = v35;
  }
  _OWORD v22[2] = v61;
  v22[3]  = v62;
  BOOL v32 = __CFADD__(v60, v35);
  unsigned int v63 = v60 + v35;
  *long long v34 = v63;
  if (v32)
  {
    log_error(a5, "sigSpace + appendOffset overflows\n");
    return 0;
  }
LABEL_112:
  if (v19)
  {
    unsigned int v66 = *((_DWORD *)v19 + 8);
    unsigned int v67 = bswap32(v66);
    if (v7) {
      unsigned int v66 = v67;
    }
    unsigned int v68 = v63 - v66;
    unsigned int v69 = (v68 + 0x3FFF) & 0xFFFFC000;
    unsigned int v70 = bswap32(v68);
    if (v7) {
      unsigned int v68 = v70;
    }
    *((_DWORD *)v19 + 9)  = v68;
    unsigned int v71 = bswap32(v69);
    if (!v7) {
      unsigned int v71 = v69;
    }
    *((_DWORD *)v19 + 7)  = v71;
  }
  else
  {
    unint64_t v72 = *((void *)v18 + 5);
    unint64_t v73 = bswap64(v72);
    if (v7) {
      unint64_t v72 = v73;
    }
    unint64_t v74 = v63 - v72;
    unint64_t v75 = (v74 + 0x3FFF) & 0xFFFFFFFFFFFFC000;
    unint64_t v76 = bswap64(v74);
    if (v7) {
      unint64_t v74 = v76;
    }
    *((void *)v18 + 6)  = v74;
    unint64_t v77 = bswap64(v75);
    if (!v7) {
      unint64_t v77 = v75;
    }
    *((void *)v18 + 4)  = v77;
  }
  return 1;
}

uint64_t writeFile(const char *a1, char *a2, unsigned int a3, char **a4)
{
  int v7 = open(a1, 1537, 511);
  if (v7 == -1)
  {
    __error();
    log_error(a4, "can't open output file for writing: %s, errno=%d\n");
  }
  else
  {
    int v8 = v7;
    uint64_t v9 = 0;
    if (a3)
    {
      unint64_t v10 = a3;
      while (1)
      {
        size_t v11 = v10 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : v10;
        ssize_t v12 = write(v8, a2, v11);
        if (v12 == -1) {
          break;
        }
        if (v12)
        {
          a2 += v12;
          v9 += v12;
          v10 -= v12;
          if (v10) {
            continue;
          }
        }
        goto LABEL_10;
      }
    }
    else
    {
LABEL_10:
      if (v9 == a3)
      {
        close(v8);
        return 1;
      }
    }
    __error();
    log_error(a4, "can't write to output file (len: %d): %s, errno=%d\n");
  }
  return 0;
}

BOOL vm_dealloc(void **a1, uint64_t a2, char **a3)
{
  int v5 = MEMORY[0x18C12F830](*MEMORY[0x1E4F14960], *a1, a2);
  if (v5) {
    log_error(a3, "failed to deallocate memory\n");
  }
  else {
    *a1  = 0;
  }
  return v5 == 0;
}

uint64_t remove_signature_space(_DWORD *a1, unsigned int a2, unsigned int *a3, char **a4)
{
  int v4 = *a1;
  BOOL v5 = *a1 == -822415874 || v4 == -805638658;
  int v6 = v5;
  unsigned int v7 = a1[3];
  unsigned int v8 = bswap32(v7);
  if (v5) {
    unsigned int v7 = v8;
  }
  if (v7 > 0xB || ((1 << v7) & 0x9C4) == 0)
  {
    log_error(a4, "mach-o filetype (%d) does not support code signing");
    return 0;
  }
  BOOL v10 = v4 == -805638658 || v4 == -17958193;
  uint64_t v11 = 7;
  if (v10) {
    uint64_t v11 = 8;
  }
  unsigned int v12 = a1[5];
  unsigned int v13 = bswap32(a1[4]);
  if (v6) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = a1[4];
  }
  LODWORD(v15)  = bswap32(v12);
  if (v6) {
    uint64_t v15 = v15;
  }
  else {
    uint64_t v15 = v12;
  }
  if (!v14) {
    goto LABEL_70;
  }
  unsigned int v64 = a4;
  int v16 = 0;
  int v17 = 0;
  int v18 = 0;
  CFErrorRef v19 = 0;
  std::string v20 = (char *)&a1[v11];
  int v60 = v15;
  unsigned int v21 = (char *)&a1[v11] + v15;
  do
  {
    unsigned int v22 = *(_DWORD *)v20;
    unsigned int v23 = bswap32(*(_DWORD *)v20);
    if (v6) {
      unsigned int v22 = v23;
    }
    unsigned int v24 = bswap32(*((_DWORD *)v20 + 1));
    if (v6) {
      unsigned int v25 = v24;
    }
    else {
      unsigned int v25 = *((_DWORD *)v20 + 1);
    }
    switch(v22)
    {
      case 1u:
        if (!strcmp(v20 + 8, "__LINKEDIT")) {
          int v18 = v20;
        }
        break;
      case 0x19u:
        if (!strcmp(v20 + 8, "__LINKEDIT")) {
          int v17 = v20;
        }
        break;
      case 0x1Du:
        CFErrorRef v19 = v20;
        break;
    }
    v20 += v25;
    if (v20 > v21)
    {
      log_error(v64, "malformed mach-o file, load command #%d is outside size of load commands\n");
      return 0;
    }
    ++v16;
  }
  while (v14 != v16);
  if (!v18)
  {
    BOOL v32 = a3;
    a4  = v64;
    unsigned int v33 = a1;
    unsigned int v34 = a2;
    int v35 = v60;
    if (v17)
    {
      unint64_t v36 = *((void *)v17 + 5);
      unint64_t v37 = *((void *)v17 + 6);
      unint64_t v38 = bswap64(v36);
      if (v6) {
        unint64_t v36 = v38;
      }
      unint64_t v39 = bswap64(v37);
      if (v6) {
        unint64_t v37 = v39;
      }
      BOOL v30 = __CFADD__(v36, v37);
      unint64_t v40 = v36 + v37;
      if (v30 || v40 > a2) {
        goto LABEL_71;
      }
      goto LABEL_60;
    }
LABEL_70:
    log_error(a4, "malformed mach-o file, no __LINKEDIT segment\n");
    return 0;
  }
  unsigned int v26 = *((_DWORD *)v18 + 8);
  unsigned int v27 = *((_DWORD *)v18 + 9);
  unsigned int v28 = bswap32(v26);
  if (v6) {
    unsigned int v26 = v28;
  }
  unsigned int v29 = bswap32(v27);
  if (v6) {
    unsigned int v27 = v29;
  }
  BOOL v30 = __CFADD__(v26, v27);
  unsigned int v31 = v26 + v27;
  BOOL v32 = a3;
  a4  = v64;
  unsigned int v33 = a1;
  unsigned int v34 = a2;
  int v35 = v60;
  if (v30 || v31 > a2)
  {
LABEL_71:
    log_error(a4, "malformed mach-o file, __LINKEDIT segment extends past end of file\n");
    return 0;
  }
LABEL_60:
  if (!v19) {
    return 1;
  }
  unsigned int v41 = *((_DWORD *)v19 + 3);
  unsigned int v42 = bswap32(*((_DWORD *)v19 + 2));
  if (v6) {
    unsigned int v43 = v42;
  }
  else {
    unsigned int v43 = *((_DWORD *)v19 + 2);
  }
  unsigned int v44 = bswap32(v41);
  if (v6) {
    size_t v45 = v44;
  }
  else {
    size_t v45 = v41;
  }
  unsigned int v46 = v43 + v45;
  if (__CFADD__(v43, v45))
  {
    log_error(a4, "malformed mach-o file, LC_CODE_SIGNATURE wraps around\n");
    return 0;
  }
  if (v46 < v34 - 7)
  {
    log_error(a4, "malformed mach-o file, LC_CODE_SIGNATURE does not point to end of file\n");
    return 0;
  }
  if (v46 > *v32)
  {
    log_error(a4, "malformed mach-o file, LC_CODE_SIGNATURE points past the end of the mach-o\n");
    return 0;
  }
  bzero((char *)v33 + v43, v45);
  *BOOL v32 = v43;
  unsigned int v48 = v14 - 1;
  unsigned int v49 = bswap32(v14 - 1);
  if (v6) {
    unsigned int v48 = v49;
  }
  *(void *)CFErrorRef v19 = 0;
  *((void *)v19 + 1)  = 0;
  unsigned int v50 = bswap32(v35 - 16);
  if (!v6) {
    unsigned int v50 = v35 - 16;
  }
  v33[4]  = v48;
  v33[5]  = v50;
  if (v19 + 16 < v21)
  {
    memmove(v19, v19 + 16, v21 - (v19 + 16));
    *((void *)v21 - 2)  = 0;
    *((void *)v21 - 1)  = 0;
  }
  uint64_t v51 = *v32;
  if (v18)
  {
    unsigned int v52 = *((_DWORD *)v18 + 8);
    unsigned int v53 = bswap32(v52);
    if (v6) {
      unsigned int v52 = v53;
    }
    unsigned int v54 = v51 - v52;
    unsigned int v55 = bswap32(v54);
    if (v6) {
      unsigned int v54 = v55;
    }
    *((_DWORD *)v18 + 9)  = v54;
  }
  else
  {
    unint64_t v56 = *((void *)v17 + 5);
    unint64_t v57 = bswap64(v56);
    if (v6) {
      unint64_t v56 = v57;
    }
    unint64_t v58 = v51 - v56;
    unint64_t v59 = bswap64(v58);
    if (v6) {
      unint64_t v58 = v59;
    }
    *((void *)v17 + 6)  = v58;
  }
  return 1;
}

void Security::CodeSigning::DiskRep::writer(Security::CodeSigning::DiskRep *this)
{
}

uint64_t Security::CodeSigning::DiskRep::allowedResourceOmissions(Security::CodeSigning::DiskRep *this)
{
  return 0;
}

void Security::CodeSigning::DiskRep::strictValidate(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4)
{
  if ((a4 & 0x100) != 0)
  {
    uint64_t v6 = *(void *)(a3 + 8);
    uint64_t v4 = a3 + 8;
    uint64_t v5 = v6;
    if (!v6) {
      goto LABEL_13;
    }
    uint64_t v7 = v4;
    do
    {
      int v8 = *(_DWORD *)(v5 + 28);
      BOOL v9 = v8 < -67002;
      if (v8 >= -67002) {
        BOOL v10 = (uint64_t *)v5;
      }
      else {
        BOOL v10 = (uint64_t *)(v5 + 8);
      }
      if (!v9) {
        uint64_t v7 = v5;
      }
      uint64_t v5 = *v10;
    }
    while (*v10);
    if (v7 == v4 || *(int *)(v7 + 28) > -67002) {
LABEL_13:
    }
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA46);
  }
}

uint64_t Security::CodeSigning::DiskRep::pageSize()
{
  return 0;
}

uint64_t Security::CodeSigning::DiskRep::defaultRequirements()
{
  return 0;
}

uint64_t Security::CodeSigning::DiskRep::defaultResourceRules()
{
  return 0;
}

void *Security::CodeSigning::DiskRep::explicitIdentifier@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18B41CA07);
}

uint64_t Security::CodeSigning::DiskRep::copyStapledTicket(Security::CodeSigning::DiskRep *this)
{
  return 0;
}

uint64_t Security::CodeSigning::DiskRep::copyDiskRepInformation(Security::CodeSigning::DiskRep *this)
{
  return 0;
}

CFArrayRef Security::CodeSigning::DiskRep::modifiedFiles(Security::CodeSigning::DiskRep *this)
{
  (*(void (**)(void **__return_ptr))(*(void *)this + 40))(__p);
  if (v9 >= 0) {
    unsigned int v2 = __p;
  }
  else {
    unsigned int v2 = (void **)__p[0];
  }
  CFURLRef CFURL = Security::makeCFURL((Security *)v2, 0, 0, v1);
  CFURLRef v5 = CFURL;
  CFURLRef v10 = CFURL;
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  CFArray  = Security::makeCFArray(CFURL, v4, v5);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&v10);
  return CFArray;
}

void sub_18B3E831C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  Security::CFRef<__CFURL const*>::~CFRef((const void **)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::DiskRep::execSegBase()
{
  return 0;
}

uint64_t Security::CodeSigning::DiskRep::signingBase(Security::CodeSigning::DiskRep *this)
{
  return 0;
}

uint64_t Security::CodeSigning::DiskRep::mainExecutableImage(Security::CodeSigning::DiskRep *this)
{
  return 0;
}

void *Security::CodeSigning::DiskRep::resourcesRootPath@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18B41CA07);
}

void Security::CodeSigning::DiskRep::Writer::remove(Security::CodeSigning::DiskRep::Writer *this)
{
}

uint64_t Security::CodeSigning::DiskRep::Writer::attributes(Security::CodeSigning::DiskRep::Writer *this)
{
  return *((unsigned int *)this + 5);
}

void Security::CodeSigning::DiskRep::canonicalIdentifier(std::string *a1, uint64_t a2)
{
  memset(&__str, 170, sizeof(__str));
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __str = *(std::string *)a2;
  }
  std::string::size_type v3 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  unsigned __int8 v4 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  std::string::size_type size = __str.__r_.__value_.__l.__size_;
  CFURLRef v5 = (std::string *)__str.__r_.__value_.__r.__words[0];
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_str  = &__str;
  }
  else {
    p_str  = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v8 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v8 = __str.__r_.__value_.__l.__size_;
  }
  if (v8)
  {
    while (v8)
    {
      int v9 = p_str->__r_.__value_.__s.__data_[--v8];
      if (v9 == 47)
      {
        if (v8 != -1)
        {
          std::string::basic_string(&v20, &__str, v8 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v22);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string __str = v20;
          std::string::size_type v3 = HIBYTE(v20.__r_.__value_.__r.__words[2]);
          std::string::size_type size = v20.__r_.__value_.__l.__size_;
          CFURLRef v5 = (std::string *)v20.__r_.__value_.__r.__words[0];
          unsigned __int8 v4 = HIBYTE(v20.__r_.__value_.__r.__words[2]);
        }
        break;
      }
    }
  }
  if ((v4 & 0x80u) != 0) {
    std::string::size_type v3 = size;
  }
  else {
    CFURLRef v5 = &__str;
  }
  if (v3)
  {
    while (v3)
    {
      int v10 = v5->__r_.__value_.__s.__data_[--v3];
      if (v10 == 46)
      {
        uint64_t v11 = (char *)v5 + v3;
        std::string::size_type v12 = v11 - (char *)v5;
        if (v11 - (char *)v5 == -1 || memchr("0123456789", v11[1], 0xBuLL)) {
          break;
        }
        std::string::basic_string(&v20, &__str, 0, v12, (std::allocator<char> *)&v22);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        std::string __str = v20;
        unsigned __int8 v4 = HIBYTE(v20.__r_.__value_.__r.__words[2]);
        if ((*((unsigned char *)&v20.__r_.__value_.__s + 23) & 0x80) == 0) {
          goto LABEL_26;
        }
        goto LABEL_31;
      }
    }
  }
  if ((v4 & 0x80) != 0)
  {
LABEL_31:
    unsigned int v14 = (std::string *)__str.__r_.__value_.__r.__words[0];
    if (!memchr("0123456789.", *__str.__r_.__value_.__l.__data_, 0xCuLL))
    {
      std::string::size_type v13 = __str.__r_.__value_.__l.__size_;
      goto LABEL_34;
    }
LABEL_32:
    *a1  = __str;
    return;
  }
LABEL_26:
  if (memchr("0123456789.", __str.__r_.__value_.__s.__data_[0], 0xCuLL)) {
    goto LABEL_32;
  }
  std::string::size_type v13 = v4;
  unsigned int v14 = &__str;
  do
LABEL_34:
    std::string::size_type v15 = v13--;
  while (memchr("0123456789.", v14->__r_.__value_.__s.__data_[v13], 0xCuLL));
  BOOL v16 = v14->__r_.__value_.__s.__data_[v15] == 46;
  if (v14->__r_.__value_.__s.__data_[v15] == 46) {
    std::string::size_type v17 = v15 + 1;
  }
  else {
    std::string::size_type v17 = v15;
  }
  if ((v4 & 0x80u) == 0) {
    std::string::size_type v18 = v4;
  }
  else {
    std::string::size_type v18 = __str.__r_.__value_.__l.__size_;
  }
  if (v17 < v18)
  {
    uint64_t v19 = (uint64_t)v14->__r_.__value_.__r.__words + v16 + 1;
    while (memchr("0123456789", *(char *)(v19 + v13), 0xBuLL))
    {
      ++v19;
      if (++v17 >= v18)
      {
        std::string::size_type v17 = v18;
        break;
      }
    }
  }
  std::string::basic_string(a1, &__str, 0, v17, (std::allocator<char> *)&v20);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_18B3E8650(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::FileDiskRep::writer(Security::CodeSigning::FileDiskRep *this)
{
}

void sub_18B3E86F8(_Unwind_Exception *a1)
{
  Security::CodeSigning::SingleDiskRep::Writer::~Writer(v1);
  MEMORY[0x18C12D390](v1, 0x10A1C40DCF3D2E7);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::SingleDiskRep::Writer::~Writer(Security::CodeSigning::SingleDiskRep::Writer *this)
{
  *(void *)this  = &unk_1ED84A378;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::SingleDiskRep::Writer *)((char *)this + 96));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer((void *)this + 3);
}

void Security::CodeSigning::FileDiskRep::Writer::flush(Security::CodeSigning::FileDiskRep::Writer *this)
{
  unsigned int v2 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  ssize_t v3 = Security::UnixPlusPlus::FileDesc::listAttr((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v2, 0, 0);
  int64_t v4 = v3;
  if (v3)
  {
    if (v3 < 0) {
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    }
    CFURLRef v5 = (char *)operator new(v3);
    bzero(v5, v4);
  }
  else
  {
    CFURLRef v5 = 0;
  }
  uint64_t v6 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  Security::UnixPlusPlus::FileDesc::listAttr((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v6, v5, v4);
  if (v4 >= 1)
  {
    uint64_t v7 = v5;
    do
    {
      memset(&v11, 170, sizeof(v11));
      std::string::basic_string[abi:ne180100]<0>(&v11, v7);
      size_t v8 = strlen(v7);
      if (!std::string::compare(&v11, 0, 0xDuLL, "com.apple.cs.")
        && (void *)((char *)this + 184) == std::__tree<std::string>::find<std::string>((uint64_t)this + 176, &v11))
      {
        int v9 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
        if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int v10 = &v11;
        }
        else {
          int v10 = (std::string *)v11.__r_.__value_.__r.__words[0];
        }
        Security::UnixPlusPlus::FileDesc::removeAttr((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v9, (const char *)v10);
      }
      if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v11.__r_.__value_.__l.__data_);
      }
      v7 += v8 + 1;
    }
    while (v7 < &v5[v4]);
  }
  if (v5) {
    operator delete(v5);
  }
}

void sub_18B3E88DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (v15) {
    operator delete(v15);
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::FileDiskRep::Writer::remove(Security::CodeSigning::FileDiskRep::Writer *this)
{
  unsigned int v2 = 0;
  do
  {
    ssize_t v3 = Security::CodeSigning::CodeDirectory::canonicalSlotName(v2);
    if (v3)
    {
      int64_t v4 = v3;
      CFURLRef v5 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
      Security::CodeSigning::FileDiskRep::attrName(&__p, v4);
      uint64_t v6 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &__p
         : (std::string *)__p.__r_.__value_.__r.__words[0];
      Security::UnixPlusPlus::FileDesc::removeAttr((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v5, (const char *)v6);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    unsigned int v2 = (Security::CodeSigning::CodeDirectory *)(v2 + 1);
  }
  while (v2 != 12);
  uint64_t v7 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  Security::CodeSigning::FileDiskRep::attrName(&__p, "CodeSignature");
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p  = &__p;
  }
  else {
    p_p  = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  Security::UnixPlusPlus::FileDesc::removeAttr((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v7, (const char *)p_p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_18B3E89F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::FileDiskRep::attrName(std::string *this, const char *a2)
{
  std::string::basic_string[abi:ne180100]<0>(&v6, "com.apple.cs.");
  std::string::size_type v4 = strlen(a2);
  CFURLRef v5 = std::string::append(&v6, a2, v4);
  *this  = *v5;
  v5->__r_.__value_.__l.__size_  = 0;
  v5->__r_.__value_.__r.__words[2]  = 0;
  v5->__r_.__value_.__r.__words[0]  = 0;
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
}

void sub_18B3E8A90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::FileDiskRep::Writer::component(Security::CodeSigning::FileDiskRep::Writer *this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
  memset(&__p, 170, sizeof(__p));
  CFURLRef v5 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
  Security::CodeSigning::FileDiskRep::attrName(&__p, v5);
  std::string v6 = (int *)Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  BytePtr  = CFDataGetBytePtr(a3);
  CFIndex Length = CFDataGetLength(a3);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p  = &__p;
  }
  else {
    p_p  = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (fsetxattr(*v6, (const char *)p_p, BytePtr, Length, 0, 0) == -1)
  {
    std::string::size_type v15 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v15);
  }
  int v10 = (uint64_t **)((char *)this + 176);
  uint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  std::string v11 = (uint64_t **)std::__tree<std::string>::__find_equal<std::string>((uint64_t)v10, &v17, &__p);
  if (!*v11)
  {
    std::string::size_type v12 = v11;
    std::string::size_type v13 = (uint64_t *)operator new(0x38uLL);
    unsigned int v14 = (std::string *)(v13 + 4);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(v14, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else
    {
      *(_OWORD *)&v14->__r_.__value_.__l.__data_  = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      void v13[6] = __p.__r_.__value_.__r.__words[2];
    }
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(v10, v17, v12, v13);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_18B3E8BE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_18B3E8C50()
{
}

void Security::CodeSigning::FileDiskRep::Writer::~Writer(char **this)
{
  *this  = (char *)&unk_1ED849D28;
  std::__tree<std::string>::destroy(this[23]);
  Security::RefPointer<Security::CodeSigning::FileDiskRep>::~RefPointer(this + 13);
  *this  = (char *)&unk_1ED84A378;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 12));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer(this + 3);

  JUMPOUT(0x18C12D390);
}

{
  *this  = (char *)&unk_1ED849D28;
  std::__tree<std::string>::destroy(this[23]);
  Security::RefPointer<Security::CodeSigning::FileDiskRep>::~RefPointer(this + 13);
  *this  = (char *)&unk_1ED84A378;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 12));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer(this + 3);
}

void *Security::RefPointer<Security::CodeSigning::FileDiskRep>::~RefPointer(void *a1)
{
  unsigned int v2 = (pthread_mutex_t *)(a1 + 1);
  v5[0]  = a1 + 1;
  v5[1]  = 0xAAAAAAAAAAAAAA01;
  ssize_t v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if (v3) {
    Security::UnixError::throwMe(v3);
  }
  if (*a1 && atomic_fetch_add_explicit((atomic_uint *volatile)(*a1 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    if (*a1) {
      (*(void (**)(void))(*(void *)*a1 + 8))(*a1);
    }
    *a1  = 0;
  }
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v5);
  Security::Mutex::~Mutex(v2);
  return a1;
}

uint64_t Security::CodeSigning::FileDiskRep::defaultRequirements(uint64_t a1, uint64_t a2, void (***a3)(void **__return_ptr, void, void **))
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v21[14]  = v4;
  v21[15]  = v4;
  v21[12]  = v4;
  v21[13]  = v4;
  v21[10]  = v4;
  v21[11]  = v4;
  v21[8]  = v4;
  v21[9]  = v4;
  void v21[6] = v4;
  v21[7]  = v4;
  void v21[4] = v4;
  void v21[5] = v4;
  void v21[2] = v4;
  v21[3]  = v4;
  v21[0]  = v4;
  v21[1]  = v4;
  CFURLRef v5 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 144))(a1);
  unint64_t v6 = Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)*v5, v21, 0x100uLL, 0);
  if (v6 >= 4 && LOBYTE(v21[0]) == 35 && BYTE1(v21[0]) == 33 && BYTE2(v21[0]) == 47)
  {
    uint64_t v7 = 255;
    if (v6 != 256) {
      uint64_t v7 = v6;
    }
    *((unsigned char *)v21 + v7)  = 0;
    *((unsigned char *)v21 + strcspn((const char *)v21 + 2, " \t\n\r\f") + 2)  = 0;
    size_t v8 = secLogObjForScope("filediskrep");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(__p[0])  = 136315138;
      *(void **)((char *)__p + 4)  = (char *)v21 + 2;
      _os_log_debug_impl(&dword_18B299000, v8, OS_LOG_TYPE_DEBUG, "looks like a script for %s", (uint8_t *)__p, 0xCu);
    }
    if (BYTE3(v21[0]))
    {
      memset(v12, 170, sizeof(v12));
      std::string::basic_string[abi:ne180100]<0>(__p, (char *)v21 + 2);
      (**a3)(v12, a3, __p);
      if (SBYTE7(v17) < 0) {
        operator delete(__p[0]);
      }
      unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v9 + 1)  = 0xAAAAAAAAAAAAAAAALL;
      long long v19 = v9;
      long long v17 = v9;
      long long v18 = v9;
      long long v15 = v9;
      *(_OWORD *)std::string __p = v9;
      if (SHIBYTE(v12[2]) >= 0) {
        int v10 = (char *)v12;
      }
      else {
        int v10 = (char *)v12[0];
      }
      long long v14 = 0xAAAAAAAAAAAAAAAALL;
      v13[0]  = 0xFFFFFFFF00000000;
      v13[1]  = 0;
      void v13[2] = 0;
      *(void *)&long long v15 = 0;
      BYTE8(v15)  = 0;
      LOBYTE(v14)  = 1;
      Security::CodeSigning::DiskRep::bestGuess(v10, (uint64_t)v13);
    }
  }
  return 0;
}

void sub_18B3E9164(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t buf,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a2)
  {
    Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a10);
    Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((uint64_t)&buf);
    if (a16 < 0) {
      operator delete(__p);
    }
    __cxa_begin_catch(exception_object);
    BOOL v30 = secLogObjForScope("filediskrep");
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf)  = 0;
      _os_log_debug_impl(&dword_18B299000, v30, OS_LOG_TYPE_DEBUG, "exception getting host requirement (ignored)", (uint8_t *)&buf, 2u);
    }
    __cxa_end_catch();
    JUMPOUT(0x18B3E90F0);
  }
  _Unwind_Resume(exception_object);
}

void *Security::CodeSigning::FileDiskRep::format@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "generic");
}

CFDataRef Security::CodeSigning::FileDiskRep::component(Security::CodeSigning::FileDiskRep *this, Security::CodeSigning::CodeDirectory *a2)
{
  ssize_t v3 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
  if (!v3) {
    return 0;
  }
  memset(&__p, 170, sizeof(__p));
  Security::CodeSigning::FileDiskRep::attrName(&__p, v3);
  long long v4 = (int *)(*(uint64_t (**)(Security::CodeSigning::FileDiskRep *))(*(void *)this + 144))(this);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p  = &__p;
  }
  else {
    p_p  = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  ssize_t v6 = fgetxattr(*v4, (const char *)p_p, 0, 0, 0, 0);
  size_t v7 = v6;
  if (v6 == -1)
  {
    if (*__error() != 93)
    {
      std::string::size_type v12 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v12);
    }
  }
  else if ((v6 & 0x8000000000000000) == 0)
  {
    value[0]  = (void *)0xAAAAAAAAAAAAAAAALL;
    value[1]  = (void *)0xAAAAAAAAAAAAAAAALL;
    Security::CFMallocData::CFMallocData((Security::CFMallocData *)value, v6);
    size_t v8 = (int *)(*(uint64_t (**)(Security::CodeSigning::FileDiskRep *))(*(void *)this + 144))(this);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v9 = &__p;
    }
    else {
      long long v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (fgetxattr(*v8, (const char *)v9, value[0], v7, 0, 0) == -1 && *__error() != 93)
    {
      std::string::size_type v13 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v13);
    }
    CFDataRef v10 = Security::CFMallocData::operator __CFData const*((uint64_t)value);
    if (value[0]) {
      free(value[0]);
    }
    goto LABEL_17;
  }
  CFDataRef v10 = 0;
LABEL_17:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v10;
}

void sub_18B3E9400(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a2 == 1)
  {
    int v18 = *((_DWORD *)__cxa_begin_catch(exception_object) + 36);
    if (v18 != 45 && v18 != 1) {
      __cxa_rethrow();
    }
    __cxa_end_catch();
    JUMPOUT(0x18B3E93B8);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_18B3E9454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

void Security::CodeSigning::FileDiskRep::~FileDiskRep(void **this)
{
  *this  = &unk_1ED84A3C0;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 5));
  if (*((char *)this + 39) < 0) {
    operator delete(this[2]);
  }
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)this);

  JUMPOUT(0x18C12D390);
}

{
  uint64_t vars8;

  *this  = &unk_1ED84A3C0;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 5));
  if (*((char *)this + 39) < 0) {
    operator delete(this[2]);
  }

  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)this);
}

Security::CodeSigning::FileDiskRep *Security::CodeSigning::FileDiskRep::FileDiskRep(Security::CodeSigning::FileDiskRep *this, char *a2)
{
  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  Security::CodeSigning::SingleDiskRep::SingleDiskRep((uint64_t)this, (long long *)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  *(void *)this  = &unk_1ED849D70;
  return this;
}

void sub_18B3E95E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  *(void *)uint64_t v15 = &unk_1ED84A3C0;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(v15 + 40));
  if (*(char *)(v15 + 39) < 0) {
    operator delete(*(void **)(v15 + 16));
  }
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)v15);
  _Unwind_Resume(a1);
}

const void **Security::CFRef<__SecCertificate *>::~CFRef(const void **a1)
{
  unsigned int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void Security::CodeSigning::BlobEditor::commit(Security::CodeSigning::BlobEditor *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  long long v9 = (uint64_t **)((char *)this + 56);
  CFDataRef v10 = (uint64_t *)Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::make((uint64_t)this + 80, a2, a3, a4, a5, a6, a7, a8);
  Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add(v9, 0, v10);
  uint64_t v11 = *((void *)this + 9);
  std::string::size_type v12 = (char *)*((void *)this + 7);
  std::string::size_type v13 = (char *)this + 64;
  if (v12 == (char *)this + 64)
  {
    int v14 = 0;
  }
  else
  {
    int v14 = 0;
    do
    {
      uint64_t v15 = (char *)*((void *)v12 + 1);
      BOOL v16 = v12;
      if (v15)
      {
        do
        {
          long long v17 = v15;
          uint64_t v15 = *(char **)v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          long long v17 = (char *)*((void *)v16 + 2);
          BOOL v18 = *(void *)v17 == (void)v16;
          BOOL v16 = v17;
        }
        while (!v18);
      }
      v14 += bswap32(*(_DWORD *)(*((void *)v12 + 5) + 4));
      std::string::size_type v12 = v17;
    }
    while (v17 != v13);
  }
  unsigned int v19 = v14 + 8 * v11 + 12;
  unint64_t v20 = (Security::BlobCore *)malloc_type_malloc(v19, 0x79CB62BEuLL);
  if (!v20) {
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  unsigned int v21 = v20;
  unsigned int v22 = *((_DWORD *)this + 18);
  *(_DWORD *)unint64_t v20 = -1056121094;
  *((_DWORD *)v20 + 1)  = bswap32(v19);
  *((_DWORD *)v20 + 2)  = bswap32(v22);
  unsigned int v23 = (char *)*((void *)this + 7);
  if (v23 != v13)
  {
    unsigned int v24 = 0;
    unsigned int v25 = 8 * v11 + 12;
    do
    {
      unsigned int v26 = (char *)v21 + 8 * v24;
      *((_DWORD *)v26 + 3)  = bswap32(*((_DWORD *)v23 + 8));
      *((_DWORD *)v26 + 4)  = bswap32(v25);
      memcpy((char *)v21 + v25, *((const void **)v23 + 5), bswap32(*(_DWORD *)(*((void *)v23 + 5) + 4)));
      unsigned int v27 = (char *)*((void *)v23 + 1);
      unsigned int v28 = v23;
      if (v27)
      {
        do
        {
          unsigned int v29 = v27;
          unsigned int v27 = *(char **)v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          unsigned int v29 = (char *)*((void *)v28 + 2);
          BOOL v18 = *(void *)v29 == (void)v28;
          unsigned int v28 = v29;
        }
        while (!v18);
      }
      v25 += bswap32(*(_DWORD *)(*((void *)v23 + 5) + 4));
      ++v24;
      unsigned int v23 = v29;
    }
    while (v29 != v13);
  }
  unint64_t v45 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v30 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v30 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v44[7]  = v30;
  v44[8]  = v30;
  v44[5]  = v30;
  v44[6]  = v30;
  unint64_t v44[3] = v30;
  v44[4]  = v30;
  v44[1]  = v30;
  v44[2]  = v30;
  v44[0]  = v30;
  long long v42 = v30;
  long long v43 = v30;
  v40[3]  = v30;
  *(_OWORD *)std::string __p = v30;
  v40[1]  = v30;
  v40[2]  = v30;
  v40[0]  = v30;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v40);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)"Maker ", 6);
  unsigned int v31 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)" assembles ", 11);
  BOOL v32 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)" blob(s) into ", 14);
  unsigned int v33 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)" (size=", 7);
  unsigned int v34 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v34, (uint64_t)")", 1);
  int v35 = secLogObjForScope("superblob");
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)v40 + 8);
    unint64_t v37 = v39 >= 0 ? __dst : (void **)__dst[0];
    *(_DWORD *)long long buf = 136315138;
    unsigned int v47 = v37;
    _os_log_debug_impl(&dword_18B299000, v35, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
    if (v39 < 0) {
      operator delete(__dst[0]);
    }
  }
  *(void *)&v40[0]  = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v40 + *(void *)(*(void *)&v40[0] - 24))  = *(void *)(MEMORY[0x1E4FBA418] + 24);
  *((void *)&v40[0] + 1)  = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v42) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x18C12D300](v44);
  Security::CodeSigning::SecCodeSigner::returnDetachedSignature(*(CFTypeRef **)(*((void *)this + 6) + 8), v21, v36);

  free(v21);
}

void sub_18B3E9A8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  a13  = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a13 + *(void *)(a13 - 24))  = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a14  = MEMORY[0x1E4FBA470] + 16;
  if (a27 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x18C12D300](&a30);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::BlobEditor::write(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

void Security::CodeSigning::BlobEditor::component(uint64_t **this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
}

void Security::CodeSigning::BlobEditor::~BlobEditor(Security::CodeSigning::BlobEditor *this)
{
  *(void *)this  = &unk_1ED849BA8;
  unsigned int v2 = (char *)this + 56;
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 80);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)v2);
  Security::CodeSigning::ArchEditor::~ArchEditor(this);

  JUMPOUT(0x18C12D390);
}

{
  char *v2;
  uint64_t vars8;

  *(void *)this  = &unk_1ED849BA8;
  unsigned int v2 = (char *)this + 56;
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 80);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)v2);

  Security::CodeSigning::ArchEditor::~ArchEditor(this);
}

void Security::CodeSigning::ArchEditor::~ArchEditor(Security::CodeSigning::ArchEditor *this)
{
  *(void *)this  = &unk_1ED849B40;
  unsigned int v2 = (char *)*((void *)this + 3);
  ssize_t v3 = (char *)this + 32;
  if (v2 != (char *)this + 32)
  {
    do
    {
      uint64_t v4 = *((void *)v2 + 5);
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      }
      char v5 = (char *)*((void *)v2 + 1);
      if (v5)
      {
        do
        {
          ssize_t v6 = v5;
          char v5 = *(char **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          ssize_t v6 = (char *)*((void *)v2 + 2);
          BOOL v7 = *(void *)v6 == (void)v2;
          unsigned int v2 = v6;
        }
        while (!v7);
      }
      unsigned int v2 = v6;
    }
    while (v6 != v3);
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((void **)this + 4));
}

uint64_t Security::CodeSigning::MachOEditor::commit(Security::CodeSigning::MachOEditor *this)
{
  unsigned int v2 = (const std::__fs::filesystem::path *)((char *)this + 120);
  int v3 = *((char *)this + 143);
  uint64_t v4 = (char *)this + 120;
  if (v3 < 0) {
    uint64_t v4 = (const char *)v2->__pn_.__r_.__value_.__r.__words[0];
  }
  v5.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v5.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v20.st_blkstd::string::size_type size = v5;
  *(timespec *)v20.st_qspare  = v5;
  v20.st_birthtimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v20.st_std::string::size_type size = v5;
  v20.st_mtimespeCC_SHA512_CTX c = v5;
  v20.st_ctimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v20.st_uid  = v5;
  v20.st_atimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v20.st_dev  = v5;
  if (stat(v4, &v20) == -1 || (ssize_t v6 = copyfile_state_alloc()) == 0)
  {
    std::string::size_type v13 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v13);
  }
  BOOL v7 = v6;
  srCC_SHA512_CTX c = *((_DWORD *)this + 50);
  if (copyfile_state_set(v6, 3u, &src) < 0)
  {
    uint64_t v15 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v15);
  }
  uid_t v18 = -1;
  if (!Security::CodeSigning::UidGuard::seteuid((Security::CodeSigning::UidGuard *)&v18, 0)) {
    Security::CodeSigning::UidGuard::seteuid((Security::CodeSigning::UidGuard *)&v18, v20.st_uid);
  }
  size_t v8 = (const char *)v2;
  if (*((char *)this + 143) < 0) {
    size_t v8 = (const char *)v2->__pn_.__r_.__value_.__r.__words[0];
  }
  if (copyfile(v8, 0, v7, 7u) < 0)
  {
    BOOL v16 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v16);
  }
  __long long buf = -86;
  Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)*((unsigned int *)this + 50), &__buf, 1uLL, 0);
  if (pwrite(*((_DWORD *)this + 50), &__buf, 1uLL, 0) == -1) {
    goto LABEL_19;
  }
  CFDataRef v10 = (const std::__fs::filesystem::path *)((char *)this + 144);
  if (*((char *)this + 167) < 0) {
    CFDataRef v10 = (const std::__fs::filesystem::path *)v10->__pn_.__r_.__value_.__r.__words[0];
  }
  if (*((char *)this + 143) < 0) {
    unsigned int v2 = (const std::__fs::filesystem::path *)v2->__pn_.__r_.__value_.__r.__words[0];
  }
  rename(v10, v2, v9);
  if (v11 == -1)
  {
LABEL_19:
    int v14 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v14);
  }
  *((unsigned char *)this + 208)  = 0;
  Security::CodeSigning::UidGuard::~UidGuard(&v18);
  (*(void (**)(void))(**((void **)this + 6) + 48))(*((void *)this + 6));
  return copyfile_state_free(v7);
}

void sub_18B3E9EF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  copyfile_state_free(v10);
  _Unwind_Resume(a1);
}

BOOL Security::CodeSigning::UidGuard::seteuid(Security::CodeSigning::UidGuard *this, uid_t a2)
{
  if (geteuid() == a2) {
    return 1;
  }
  if (*(_DWORD *)this == -1) {
    *(_DWORD *)this  = geteuid();
  }
  return seteuid(a2) == 0;
}

void Security::CodeSigning::UidGuard::~UidGuard(uid_t *this)
{
  uid_t v1 = *this;
  if (v1 != -1 && seteuid(v1) == -1)
  {
    unsigned int v2 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v2);
  }
}

void Security::CodeSigning::MachOEditor::write(Security::CodeSigning::MachOEditor *this, Security::CodeSigning::ArchEditor::Arch *a2, Security::CodeSigning::EmbeddedSignatureBlob *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  ssize_t v6 = (Security::MachOBase *)*((void *)a2 + 7);
  CodeCFDataRef Signature = Security::MachOBase::findCodeSignature(v6);
  if (!CodeSignature
    || ((cmd = CodeSignature[1].cmd, unsigned int v9 = bswap32(cmd), *((unsigned char *)v6 + 33)) ? (v10 = v9) : (v10 = cmd), !v10))
  {
    BOOL v16 = secLogObjForScope("signer");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      int v17 = 134217984;
      uid_t v18 = this;
      _os_log_debug_impl(&dword_18B299000, v16, OS_LOG_TYPE_DEBUG, "%p cannot find CODESIGNING data in Mach-O", (uint8_t *)&v17, 0xCu);
    }
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
  }
  int v11 = (Security::MachOBase *)*((void *)a2 + 7);
  std::string::size_type v12 = Security::MachOBase::findCodeSignature(v11);
  if (v12)
  {
    cmdstd::string::size_type size = v12[1].cmdsize;
    unsigned int v14 = bswap32(cmdsize);
    if (*((unsigned char *)v11 + 33)) {
      unint64_t v15 = v14;
    }
    else {
      unint64_t v15 = cmdsize;
    }
  }
  else
  {
    unint64_t v15 = 0;
  }
  NXGetArchInfoFromCpuType(*((_DWORD *)a2 + 12), *((_DWORD *)a2 + 13) & 0xFFFFFF);
  if (v15 < bswap32(*((_DWORD *)a3 + 1))) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA24);
  }
  Security::UnixPlusPlus::FileDesc::seek((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)(*((void *)a2 + 7) + 36), *(void *)(*((void *)a2 + 7) + 48) + v10);
  Security::UnixPlusPlus::FileDesc::writeAll(*((void *)a2 + 7) + 36, (char *)a3, bswap32(*((_DWORD *)a3 + 1)));

  free(a3);
}

void Security::CodeSigning::MachOEditor::reset(uint64_t a1, uint64_t a2)
{
}

void ___ZN8Security11CodeSigning11MachOEditor5resetERNS0_10ArchEditor4ArchE_block_invoke(uint64_t a1, void *a2)
{
  unsigned int v2 = (Security::UnixPlusPlus::FileDesc *)(a2 + 5);
  if (*((_DWORD *)a2 + 10) != -1)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (*(char *)(v5 + 167) < 0) {
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(v5 + 144), *(void *)(v5 + 152));
    }
    else {
      std::string __p = *(std::string *)(v5 + 144);
    }
    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 56);
    uint64_t v7 = *(void *)(v6 + 48);
    CodeCFDataRef Signature = Security::MachOBase::findCodeSignature((Security::MachOBase *)v6);
    if (CodeSignature)
    {
      clong long md = CodeSignature[1].cmd;
      unsigned int v10 = bswap32(cmd);
      if (*(unsigned char *)(v6 + 33)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = cmd;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    Security::UnixPlusPlus::FileDesc::close(v2);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p  = &__p;
    }
    else {
      p_p  = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    Security::UnixPlusPlus::FileDesc::open(v2, (const char *)p_p, 0, 438);
    a2[6]  = v7;
    a2[7]  = v11;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_18B3EA380(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Security::CodeSigning::ArchEditor::Arch::eachDigest(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(void **)(result + 64);
  int v3 = (void *)(result + 72);
  if (v2 != (void *)(result + 72))
  {
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void))(a2 + 16))(a2, v2[5]);
      uint64_t v5 = (void *)v2[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          uint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void *)v2[2];
          BOOL v7 = *v6 == (void)v2;
          unsigned int v2 = v6;
        }
        while (!v7);
      }
      unsigned int v2 = v6;
    }
    while (v6 != v3);
  }
  return result;
}

void Security::CodeSigning::MachOEditor::allocate(Security::CodeSigning::MachOEditor *this)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  uint64_t v80 = 0;
  *((unsigned char *)this + 208)  = 1;
  unsigned int v2 = (Security::CodeSigning::MachOEditor *)*((void *)this + 3);
  if (v2 != (Security::CodeSigning::MachOEditor *)((char *)this + 32))
  {
    char v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(*((void *)v2 + 5) + 120);
      BOOL v5 = v4 == 0;
      if (v4 && (v3 & 1) != 0)
      {
        unsigned int v70 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_18B299000, v70, OS_LOG_TYPE_DEFAULT, "codesign allocate error: one architecture signaled removal while another signaled signing", buf, 2u);
        }
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
      }
      uint64_t v6 = (Security::CodeSigning::MachOEditor *)*((void *)v2 + 1);
      if (v6)
      {
        do
        {
          BOOL v7 = v6;
          uint64_t v6 = *(Security::CodeSigning::MachOEditor **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          BOOL v7 = (Security::CodeSigning::MachOEditor *)*((void *)v2 + 2);
          BOOL v27 = *(void *)v7 == (void)v2;
          unsigned int v2 = v7;
        }
        while (!v27);
      }
      v3 |= v5;
      unsigned int v2 = v7;
    }
    while (v7 != (Security::CodeSigning::MachOEditor *)((char *)this + 32));
    if (v3)
    {
      size_t v8 = (char *)this + 120;
      if (*((char *)this + 143) < 0) {
        size_t v8 = *(const char **)v8;
      }
      unsigned int v9 = (char *)this + 144;
      if (*((char *)this + 167) < 0) {
        unsigned int v9 = *(const char **)v9;
      }
      *(void *)long long buf = 0;
      __dst  = 0;
      vm_size_t size = 0;
      if ((mapFile(v8, (const void **)buf, (off_t *)&size, &v80) & 1) == 0) {
        goto LABEL_117;
      }
      unsigned int v10 = *(void **)buf;
      vm_size_t v11 = size;
      if (HIDWORD(size))
      {
        log_error(&v80, "input file is too big: %lld\n", size);
        LODWORD(v11)  = 0;
        goto LABEL_116;
      }
      std::string::size_type v12 = 0;
      unsigned int v13 = 0;
      int v14 = **(_DWORD **)buf;
      if ((int)**(_DWORD **)buf > -17958195)
      {
        vm_size_t v15 = 0;
        if ((v14 + 17958194) >= 2) {
          goto LABEL_57;
        }
      }
      else
      {
        if (v14 == -1095041334)
        {
          unsigned int v47 = *(_DWORD *)(*(void *)buf + 4);
          uint64_t v48 = bswap32(v47);
          vm_size_t v15 = (size + (v48 << 14));
          if (vm_alloc((vm_address_t *)&__dst, v15, &v80))
          {
            std::string::size_type v12 = (char *)__dst;
            *(void *)__dst  = *v10;
            if (!v47)
            {
              unsigned int v13 = 0;
LABEL_57:
              int v38 = writeFile(v9, v12, v13, &v80);
              goto LABEL_66;
            }
            uint64_t v49 = 0;
            unsigned int v50 = v12 + 0x4000;
            while (1)
            {
              uint64_t v51 = &v12[v49];
              long long v52 = *(_OWORD *)((char *)v10 + v49 + 8);
              *((_DWORD *)v51 + 6)  = *(_DWORD *)((char *)v10 + v49 + 24);
              *(_OWORD *)(v51 + 8)  = v52;
              size_t v53 = bswap32(*(_DWORD *)((char *)v10 + v49 + 20));
              memcpy(v50, (char *)v10 + bswap32(*(_DWORD *)((char *)v10 + v49 + 16)), v53);
              unsigned int v81 = v53;
              if (!remove_signature_space(v50, v53, &v81, &v80)) {
                goto LABEL_101;
              }
              unint64_t v54 = v50 - v12;
              if (v50 < v12)
              {
                log_error(&v80, "new architecture offset underflows");
                goto LABEL_101;
              }
              if (HIDWORD(v54)) {
                break;
              }
              unsigned int v55 = &v12[v49];
              unsigned int v56 = v81;
              unsigned int v57 = bswap32(v81);
              *((_DWORD *)v55 + 4)  = bswap32(v54);
              *((_DWORD *)v55 + 5)  = v57;
              *((_DWORD *)v55 + 6)  = 234881024;
              v50 += (v56 + 0x3FFF) & 0xFFFFC000;
              v49 += 20;
              if (!--v48)
              {
                unsigned int v13 = v56 + v54;
                goto LABEL_57;
              }
            }
            log_error(&v80, "new architecture offset is too large");
LABEL_101:
            int v38 = 0;
LABEL_66:
            BOOL v46 = vm_dealloc(&__dst, v15, &v80);
            munmap(v10, v11);
            if (v46 & v38) {
              goto LABEL_90;
            }
LABEL_117:
            unint64_t v72 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v80;
              _os_log_impl(&dword_18B299000, v72, OS_LOG_TYPE_DEFAULT, "codesign deallocation failed: %s", buf, 0xCu);
            }
            free(v80);
            Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
          }
LABEL_116:
          munmap(v10, v11);
          goto LABEL_117;
        }
        if (v14 != -822415874)
        {
          vm_size_t v15 = 0;
          if (v14 != -805638658) {
            goto LABEL_57;
          }
        }
      }
      unsigned int v82 = size;
      if (vm_alloc((vm_address_t *)&__dst, size, &v80))
      {
        std::string::size_type v12 = (char *)__dst;
        memcpy(__dst, v10, v11);
        if (remove_signature_space(v12, v11, &v82, &v80))
        {
          unsigned int v13 = v82;
          vm_size_t v15 = v11;
          goto LABEL_57;
        }
        int v38 = 0;
        vm_size_t v15 = v11;
        goto LABEL_66;
      }
      goto LABEL_116;
    }
  }
  BOOL v16 = (char *)this + 120;
  if (*((char *)this + 143) < 0) {
    BOOL v16 = *(const char **)v16;
  }
  int v17 = (char *)this + 144;
  if (*((char *)this + 167) < 0) {
    int v17 = *(const char **)v17;
  }
  v76[0]  = MEMORY[0x1E4F143A8];
  v76[1]  = 0x40000000;
  unint64_t v77 = ___ZN8Security11CodeSigning11MachOEditor8allocateEv_block_invoke;
  unsigned int v78 = &__block_descriptor_tmp_17240;
  uint64_t v79 = this;
  uint64_t v80 = 0;
  *(void *)long long buf = 0;
  __dst  = 0;
  vm_size_t size = 0;
  if ((mapFile(v16, (const void **)buf, (off_t *)&size, &v80) & 1) == 0) {
    goto LABEL_110;
  }
  vm_size_t v18 = size;
  long long __src = *(unsigned int **)buf;
  if (HIDWORD(size))
  {
    log_error(&v80, "input file too large: %lld bytes\n", size);
    LODWORD(v18)  = 0;
  }
  else
  {
    uint64_t v19 = 0;
    unsigned int v20 = 0;
    int v21 = **(_DWORD **)buf;
    if ((int)**(_DWORD **)buf > -17958195)
    {
      uint64_t v22 = 0;
      if ((v21 + 17958194) >= 2) {
        goto LABEL_88;
      }
      goto LABEL_35;
    }
    if (v21 != -1095041334)
    {
      if (v21 != -822415874)
      {
        uint64_t v22 = 0;
        if (v21 != -805638658) {
          goto LABEL_88;
        }
      }
LABEL_35:
      unsigned int v23 = v21 & 0xFEFFFFFF;
      unsigned int v24 = *(_DWORD *)(*(void *)buf + 4);
      unsigned int v25 = *(_DWORD *)(*(void *)buf + 8);
      unsigned int v26 = bswap32(v24);
      BOOL v27 = v23 == -822415874;
      if (v23 == -822415874) {
        uint64_t v28 = v26;
      }
      else {
        uint64_t v28 = v24;
      }
      unsigned int v29 = bswap32(v25);
      if (v27) {
        uint64_t v30 = v29;
      }
      else {
        uint64_t v30 = v25;
      }
      unsigned int v31 = v77((uint64_t)v76, v28, v30);
      unsigned int v32 = v31;
      if (v31 == -1)
      {
        log_error(&v80, "requested signature size is too long for slice");
      }
      else
      {
        if ((v31 & 0xF) != 0)
        {
          log_error(&v80, "signature size not a multiple of 16\n");
          int v33 = 0;
          uint64_t v22 = 0;
          goto LABEL_89;
        }
        uint64_t v34 = v18 + v31;
        BOOL v35 = __CFADD__(v18, v31);
        uint64_t v36 = v34 + 15;
        uint64_t v37 = (v34 + 15) << 31 >> 31;
        unsigned int v82 = v36;
        if (v35 || v37 != v36 || v37 < 0)
        {
          log_error(&v80, "overflow calculating output size (%u + %d + 15)", v18, v31);
        }
        else
        {
          uint64_t v22 = v37 & 0x1FFFFFFFFLL;
          if (vm_alloc((vm_address_t *)&__dst, v37 & 0x1FFFFFFFFLL, &v80))
          {
            uint64_t v19 = __dst;
            memcpy(__dst, __src, v18);
            if (assure_signature_space(v19, v32, v18, &v82, &v80))
            {
              unsigned int v20 = v82;
              goto LABEL_88;
            }
            int v33 = 0;
            goto LABEL_89;
          }
        }
      }
      goto LABEL_109;
    }
    unsigned int v20 = *(_DWORD *)(*(void *)buf + 4);
    size_t v39 = bswap32(v20);
    unint64_t v40 = malloc_type_calloc(v39, 4uLL, 0x100004052888210uLL);
    unint64_t v74 = v17;
    if (v20)
    {
      uint64_t v41 = 0;
      LODWORD(v42)  = 0;
      long long v43 = __src + 3;
      unsigned int v44 = "requested signature size is too long for slice: %d\n";
      while (1)
      {
        if (bswap32(v43[2]) + bswap32(v43[1]) > v18)
        {
          log_error(&v80, "malformed fat file, slice %d extends past end of file\n", v41);
          goto LABEL_108;
        }
        int v45 = v77((uint64_t)v76, bswap32(*(v43 - 1)), bswap32(*v43));
        if (v45 == -1) {
          goto LABEL_107;
        }
        if ((v45 & 0xF) != 0) {
          break;
        }
        v40[v41]  = v45;
        uint64_t v42 = (v45 + v42);
        ++v41;
        v43 += 5;
        if (v39 == v41) {
          goto LABEL_78;
        }
      }
      unsigned int v44 = "signature size not a multiple of 16 in slice %d\n";
LABEL_107:
      log_error(&v80, v44, v41);
    }
    else
    {
      uint64_t v42 = 0;
LABEL_78:
      uint64_t v22 = (16399 * v39) + (unint64_t)v18 + v42;
      int v17 = v74;
      if (vm_alloc((vm_address_t *)&__dst, v22, &v80))
      {
        uint64_t v19 = __dst;
        *(void *)__dst  = *(void *)__src;
        if (!v20) {
          goto LABEL_87;
        }
        uint64_t v73 = (16399 * v39) + (unint64_t)v18 + v42;
        uint64_t v58 = 0;
        unint64_t v59 = (char *)(v19 + 4096);
        int v60 = __src + 5;
        unsigned int v61 = v19 + 6;
        while (1)
        {
          long long v62 = *(_OWORD *)(v60 - 3);
          *unsigned int v61 = v60[1];
          *((_OWORD *)v61 - 1)  = v62;
          size_t v63 = bswap32(*v60);
          memcpy(v59, (char *)__src + bswap32(*(v60 - 1)), v63);
          unsigned int v64 = v40[v58];
          unsigned int v81 = v64 + v63;
          if ((assure_signature_space(v59, v64, v63, &v81, &v80) & 1) == 0) {
            goto LABEL_98;
          }
          unint64_t v65 = v59 - (char *)v19;
          if (v59 < (char *)v19) {
            break;
          }
          if (HIDWORD(v65))
          {
            log_error(&v80, "new architecture offset is too large");
            goto LABEL_98;
          }
          unsigned int v66 = v81;
          unsigned int v67 = bswap32(v81);
          *(v61 - 2)  = bswap32(v65);
          *(v61 - 1)  = v67;
          *unsigned int v61 = 234881024;
          unsigned int v20 = v65 + v66;
          if (__CFADD__(v65, v66))
          {
            log_error(&v80, "new outputsize overflows: newOffset(%d) newSliceSize(%d)\n", v59 - v19, v66);
            goto LABEL_98;
          }
          v59 += (v66 + 0x3FFF) & 0xFFFFC000;
          ++v58;
          v60 += 5;
          v61 += 5;
          if (v39 == v58)
          {
            uint64_t v22 = v73;
            int v17 = v74;
LABEL_87:
            free(v40);
LABEL_88:
            int v33 = writeFile(v17, (char *)v19, v20, &v80);
LABEL_89:
            BOOL v68 = vm_dealloc(&__dst, v22, &v80);
            munmap(__src, v18);
            if (v68 & v33)
            {
LABEL_90:
              *(_DWORD *)long long buf = -1;
              Security::CodeSigning::UidGuard::seteuid((Security::CodeSigning::UidGuard *)buf, 0);
              if (*((char *)this + 167) >= 0) {
                unsigned int v69 = (char *)this + 144;
              }
              else {
                unsigned int v69 = (const char *)*((void *)this + 18);
              }
              Security::UnixPlusPlus::FileDesc::open((Security::CodeSigning::MachOEditor *)((char *)this + 200), v69, 2, 438);
              Security::CodeSigning::UidGuard::~UidGuard((uid_t *)buf);
              operator new();
            }
LABEL_110:
            unsigned int v71 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v80;
              _os_log_impl(&dword_18B299000, v71, OS_LOG_TYPE_DEFAULT, "codesign allocation failed: %s", buf, 0xCu);
            }
            free(v80);
            Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
          }
        }
        log_error(&v80, "new architecture offset underflows");
LABEL_98:
        free(v40);
        int v33 = 0;
        uint64_t v22 = v73;
        goto LABEL_89;
      }
    }
LABEL_108:
    free(v40);
  }
LABEL_109:
  munmap(__src, v18);
  goto LABEL_110;
}

void sub_18B3EADE0(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

unint64_t ___ZN8Security11CodeSigning11MachOEditor8allocateEv_block_invoke(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void **)(v3 + 24);
  BOOL v5 = (void *)(v3 + 32);
  uint64_t v6 = 0xFFFFFFFFLL;
  if (v4 != v5)
  {
    do
    {
      if (*((_DWORD *)v4 + 8) == a2 && (a3 == -1 || ((*((_DWORD *)v4 + 9) ^ a3) & 0xFFFFFF) == 0)) {
        uint64_t v6 = *(void *)(v4[5] + 120);
      }
      BOOL v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          size_t v8 = v7;
          BOOL v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          size_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != v5);
  }
  if (((v6 - 1) & 0xFFFFFFFFFFFFFFF0) + 16 >= 0xFFFFFFFF) {
    return 0xFFFFFFFFLL;
  }
  else {
    return ((v6 - 1) & 0xFFFFFFFFFFFFFFF0) + 16;
  }
}

uint64_t Security::CodeSigning::MachOEditor::component(Security::CodeSigning::MachOEditor *this, uint64_t a2, const __CFData *a3)
{
  return (*(uint64_t (**)(void, uint64_t, const __CFData *))(**((void **)this + 6) + 16))(*((void *)this + 6), a2, a3);
}

void Security::CodeSigning::MachOEditor::~MachOEditor(Security::CodeSigning::MachOEditor *this, std::error_code *a2)
{
  Security::CodeSigning::MachOEditor::~MachOEditor(this, a2);

  JUMPOUT(0x18C12D390);
}

{
  uint64_t v3;
  const std::__fs::filesystem::path *v4;
  uint64_t vars8;

  *(void *)this  = &unk_1ED849E88;
  uint64_t v3 = *((void *)this + 24);
  if (v3)
  {
    free(*(void **)(v3 + 8));
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(void **)(v3 + 56));
    MEMORY[0x18C12D390](v3, 0x1020C4076728D04);
  }
  if (*((unsigned char *)this + 208))
  {
    uint64_t v4 = (const std::__fs::filesystem::path *)((char *)this + 144);
    if (*((char *)this + 167) < 0) {
      uint64_t v4 = (const std::__fs::filesystem::path *)v4->__pn_.__r_.__value_.__r.__words[0];
    }
    remove(v4, a2);
  }
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::MachOEditor *)((char *)this + 200));
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((void **)this + 22));
  if (*((char *)this + 167) < 0) {
    operator delete(*((void **)this + 18));
  }
  if (*((char *)this + 143) < 0) {
    operator delete(*((void **)this + 15));
  }
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer((uint64_t)this + 48);

  Security::CodeSigning::ArchEditor::~ArchEditor(this);
}

void Security::CodeSigning::BlobWriter::component(uint64_t **this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
}

void Security::CodeSigning::DetachedBlobWriter::flush(Security::CodeSigning::DetachedBlobWriter *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9 = (UInt8 *)Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::make((uint64_t)this + 24, a2, a3, a4, a5, a6, a7, a8);
  unsigned int v10 = *(Security::CodeSigning::SecStaticCode **)(*((void *)this + 6) + 16);
  CFDataRef v12 = CFDataCreate(0, v9, bswap32(*((_DWORD *)v9 + 1)));
  Security::CodeSigning::SecStaticCode::detachedSignature(v10, v12);
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v12);
  Security::CodeSigning::SecCodeSigner::returnDetachedSignature(*(CFTypeRef **)(*((void *)this + 6) + 8), (Security::BlobCore *)v9, v11);
  free(v9);
}

void sub_18B3EB0A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::DetachedBlobWriter::~DetachedBlobWriter(Security::CodeSigning::DetachedBlobWriter *this)
{
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 24);

  JUMPOUT(0x18C12D390);
}

{
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 24);
}

uint64_t Security::CodeSigning::ArchEditor::ArchEditor(uint64_t a1, Security::Universal *this, uint64_t a3, int a4)
{
  *(_DWORD *)(a1 + 8)  = 0;
  *(void *)(a1 + 12)  = -1;
  *(_DWORD *)(a1 + 20)  = a4;
  *(void *)a1  = &unk_1ED849B40;
  *(void *)(a1 + 32)  = 0;
  *(void *)(a1 + 40)  = 0;
  *(void *)(a1 + 24)  = a1 + 32;
  v7[0]  = 0;
  v7[1]  = 0;
  uint64_t v6 = v7;
  Security::Universal::architectures((uint64_t *)this, (uint64_t *)&v6);
  if (v6 != v7) {
    operator new();
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v7[0]);
  return a1;
}

void sub_18B3EB4D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
}

void std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>>>::destroy(a1[1]);
    Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>::~RefPointer((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

uint64_t Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>::~RefPointer(uint64_t a1)
{
  unsigned int v2 = (pthread_mutex_t *)(a1 + 8);
  v6[0]  = a1 + 8;
  v6[1]  = 0xAAAAAAAAAAAAAA01;
  uint64_t v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (v3) {
    Security::UnixError::throwMe(v3);
  }
  if (*(void *)a1 && atomic_fetch_add_explicit(*(atomic_uint *volatile *)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    if (*(void *)a1)
    {
      Security::CodeSigning::CodeDirectory::Builder::~Builder(*(Security::CodeSigning::CodeDirectory::Builder **)a1);
      MEMORY[0x18C12D390](v4, 0x1032C4080168F4FLL);
    }
    *(void *)a1  = 0;
  }
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v6);
  Security::Mutex::~Mutex(v2);
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uid_t v1 = *(void **)a1;
  *(void *)a1  = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>::~RefPointer((uint64_t)v1 + 40);
    }
    operator delete(v1);
  }
}

void Security::CodeSigning::ArchEditor::Arch::~Arch(void **this)
{
  *this  = &unk_1ED849AF8;
  unsigned int v2 = (char *)(this + 11);
  free(this[14]);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)v2);
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>>>::destroy(this[9]);
  uint64_t v3 = this[7];
  this[7]  = 0;
  if (v3) {
    (*(void (**)(void *))(*(void *)v3 + 8))(v3);
  }
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)(this + 3));

  JUMPOUT(0x18C12D390);
}

{
  char *v2;
  void *v3;

  *this  = &unk_1ED849AF8;
  unsigned int v2 = (char *)(this + 11);
  free(this[14]);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)v2);
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>>>::destroy(this[9]);
  uint64_t v3 = this[7];
  this[7]  = 0;
  if (v3) {
    (*(void (**)(void *))(*(void *)v3 + 8))(v3);
  }
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)(this + 3));
}

uint64_t Security::CodeSigning::MachOEditor::MachOEditor(uint64_t a1, atomic_uint *a2, Security::Universal *a3, void *a4, long long *a5)
{
  std::set<unsigned int>::set[abi:ne180100]((uint64_t)v16, a4);
  int v10 = (*(uint64_t (**)(atomic_uint *))(*(void *)a2 + 24))(a2);
  Security::CodeSigning::ArchEditor::ArchEditor(a1, a3, (uint64_t)v16, v10);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v17);
  *(void *)a1  = &unk_1ED849E88;
  Security::Mutex::Mutex((pthread_mutex_t *)(a1 + 56));
  atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
  *(void *)(a1 + 48)  = a2;
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 120), *(const std::string::value_type **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v11 = *a5;
    *(void *)(a1 + 136)  = *((void *)a5 + 2);
    *(_OWORD *)(a1 + 120)  = v11;
  }
  *(void *)(a1 + 144)  = 0xAAAAAAAAAAAAAAAALL;
  if (*((char *)a5 + 23) >= 0) {
    size_t v12 = *((unsigned __int8 *)a5 + 23);
  }
  else {
    size_t v12 = *((void *)a5 + 1);
  }
  *(void *)(a1 + 152)  = 0xAAAAAAAAAAAAAAAALL;
  *(void *)(a1 + 160)  = 0xAAAAAAAAAAAAAAAALL;
  std::string::basic_string[abi:ne180100](a1 + 144, v12 + 7);
  if (*(char *)(a1 + 167) >= 0) {
    unsigned int v13 = (void *)(a1 + 144);
  }
  else {
    unsigned int v13 = *(void **)(a1 + 144);
  }
  if (v12)
  {
    if (*((char *)a5 + 23) >= 0) {
      int v14 = (const std::string::value_type *)a5;
    }
    else {
      int v14 = *(const std::string::value_type **)a5;
    }
    memmove(v13, v14, v12);
  }
  strcpy((char *)v13 + v12, ".cstemp");
  std::set<unsigned int>::set[abi:ne180100](a1 + 168, a4);
  *(void *)(a1 + 192)  = 0;
  *(_DWORD *)(a1 + 200)  = -1;
  *(unsigned char *)(a1 + 204)  = 0;
  *(unsigned char *)(a1 + 208)  = 0;
  return a1;
}

void sub_18B3EBA08(_Unwind_Exception *a1)
{
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer((uint64_t)v1 + 48);
  Security::CodeSigning::ArchEditor::~ArchEditor(v1);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::InternalRequirements::operator()(uint64_t a1)
{
  unsigned int v2 = secLogObjForScope("signer");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_debug_impl(&dword_18B299000, v2, OS_LOG_TYPE_DEBUG, "Platform does not support signing internal requirements", v3, 2u);
  }
  *(void *)(a1 + 24)  = 0;
}

const void **Security::CFRef<__SecPolicy *>::~CFRef(const void **a1)
{
  unsigned int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void Security::CodeSigning::CodeDirectorySet::add(Security::CodeSigning::CodeDirectorySet *this, const Security::CodeSigning::CodeDirectory *a2)
{
  unsigned int v4 = *((unsigned __int8 *)a2 + 37);
  BOOL v5 = operator new(0x30uLL);
  void v5[8] = v4;
  *((void *)v5 + 5)  = a2;
  uint64_t v6 = (uint64_t **)((char *)this + 8);
  BOOL v7 = (uint64_t *)*((void *)this + 1);
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        size_t v8 = (uint64_t **)v7;
        unsigned int v9 = *((_DWORD *)v7 + 8);
        if (v9 <= v4) {
          break;
        }
        BOOL v7 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_9;
        }
      }
      if (v9 >= v4) {
        break;
      }
      BOOL v7 = v8[1];
      if (!v7)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_9;
      }
    }
    operator delete(v5);
  }
  else
  {
    size_t v8 = (uint64_t **)((char *)this + 8);
LABEL_9:
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at((uint64_t **)this, (uint64_t)v8, v6, (uint64_t *)v5);
  }
  if (*((unsigned char *)a2 + 37) == 1) {
    *((void *)this + 3)  = a2;
  }
}

const void **Security::CodeSigning::CodeDirectorySet::populate(const void **this, Security::CodeSigning::DiskRep::Writer *a2)
{
  uint64_t v3 = this;
  unsigned int v4 = (const void **)*this;
  if (!this[3]) {
    this[3]  = v4[5];
  }
  BOOL v5 = this + 1;
  if (v4 != this + 1)
  {
    unsigned int v6 = 4096;
    do
    {
      BOOL v7 = (unsigned int *)v4[5];
      size_t v8 = (unsigned int *)v3[3];
      if (v7 == v8) {
        uint64_t v9 = 0;
      }
      else {
        uint64_t v9 = v6;
      }
      if (v7 != v8) {
        ++v6;
      }
      CFDataRef v13 = CFDataCreate(0, (const UInt8 *)v7, bswap32(v7[1]));
      (*(void (**)(Security::CodeSigning::DiskRep::Writer *, uint64_t, CFDataRef))(*(void *)a2 + 16))(a2, v9, v13);
      this  = Security::CFRef<__CFData const*>::~CFRef((const void **)&v13);
      int v10 = (const void **)v4[1];
      if (v10)
      {
        do
        {
          long long v11 = v10;
          int v10 = (const void **)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          long long v11 = (const void **)v4[2];
          BOOL v12 = *v11 == v4;
          unsigned int v4 = v11;
        }
        while (!v12);
      }
      unsigned int v4 = v11;
    }
    while (v11 != v5);
  }
  return this;
}

void sub_18B3EBCB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

__CFArray *Security::CodeSigning::CodeDirectorySet::hashList(Security::CodeSigning::CodeDirectorySet *this, uint64_t a2)
{
  CFMutableArray  = Security::makeCFMutableArray(this, a2);
  CFMutableArrayRef theArray = CFMutableArray;
  uint64_t v4 = *(void *)this;
  if (*(Security::CodeSigning::CodeDirectorySet **)this != (Security::CodeSigning::CodeDirectorySet *)((char *)this + 8))
  {
    unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
    Security::CodeSigning::CodeDirectory::cdhash(*(Security::CodeSigning::CodeDirectory **)(v4 + 40));
  }
  BOOL v5 = CFMutableArray;
  CFMutableArrayRef theArray = 0;
  Security::CFRef<__CFArray *>::~CFRef((const void **)&theArray);
  return v5;
}

void sub_18B3EBD90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

CFMutableDictionaryRef Security::CodeSigning::CodeDirectorySet::hashDict(Security::CodeSigning::CodeDirectorySet *this)
{
  CFMutableDictionaryRef CFMutableDictionary = Security::makeCFMutableDictionary(this);
  CFMutableDictionaryRef v11 = CFMutableDictionary;
  uint64_t v3 = *(void *)this;
  if (*(Security::CodeSigning::CodeDirectorySet **)this != (Security::CodeSigning::CodeDirectorySet *)((char *)this + 8))
  {
    unsigned int v4 = *(_DWORD *)(v3 + 32) - 1;
    if (v4 < 4)
    {
      int v5 = dword_18B414C00[v4];
      unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
      LODWORD(valuePtr)  = v5;
      CFNumberRef v6 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v10 = (unint64_t)v6;
      Security::CodeSigning::CodeDirectory::cdhash(*(Security::CodeSigning::CodeDirectory **)(v3 + 40));
    }
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA48);
  }
  CFMutableDictionaryRef v7 = CFMutableDictionary;
  CFMutableDictionaryRef v11 = 0;
  Security::CFRef<__CFDictionary *>::~CFRef((const void **)&v11);
  return v7;
}

void sub_18B3EBEC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  Security::CFRef<__CFDictionary *>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL Security::CodeSigning::SecCodeSigner::valid(Security::CodeSigning::SecCodeSigner *this)
{
  return (*((_WORD *)this + 8) & 0x401) != 0 || *((void *)this + 3) != 0;
}

void Security::CodeSigning::SecCodeSigner::~SecCodeSigner(Security::CodeSigning::SecCodeSigner *this)
{
  Security::CodeSigning::SecCodeSigner::~SecCodeSigner(this);

  Security::SecCFObject::operator delete(v1);
}

{
  uint64_t v2;
  void **v3;

  *(void *)this  = &unk_1ED84A228;
  unsigned int v2 = *((void *)this + 36);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 39);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)this + 34);
  Security::CFRef<__SecIdentity *>::~CFRef((const void **)this + 33);
  Security::CFRef<__CFNumber const*>::~CFRef((const void **)this + 32);
  if (*((char *)this + 247) < 0) {
    operator delete(*((void **)this + 28));
  }
  if (*((char *)this + 223) < 0) {
    operator delete(*((void **)this + 25));
  }
  if (*((char *)this + 199) < 0) {
    operator delete(*((void **)this + 22));
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((void **)this + 20));
  Security::CFRef<void const*>::~CFRef((const void **)this + 15);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)this + 14);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 13);
  uint64_t v3 = (void **)((char *)this + 80);
  std::vector<Security::CFRef<__CFData const*>>::__destroy_vector::operator()[abi:ne180100](&v3);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 8);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 7);
  Security::CFRef<__CFDate const*>::~CFRef((const void **)this + 6);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)this + 5);
  Security::CFRef<void const*>::~CFRef((const void **)this + 4);
  Security::CFRef<__SecIdentity *>::~CFRef((const void **)this + 3);
}

{
  uint64_t v2;
  void **v3;

  *(void *)this  = &unk_1ED84A228;
  unsigned int v2 = *((void *)this + 36);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 39);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)this + 34);
  Security::CFRef<__SecIdentity *>::~CFRef((const void **)this + 33);
  Security::CFRef<__CFNumber const*>::~CFRef((const void **)this + 32);
  if (*((char *)this + 247) < 0) {
    operator delete(*((void **)this + 28));
  }
  if (*((char *)this + 223) < 0) {
    operator delete(*((void **)this + 25));
  }
  if (*((char *)this + 199) < 0) {
    operator delete(*((void **)this + 22));
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((void **)this + 20));
  Security::CFRef<void const*>::~CFRef((const void **)this + 15);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)this + 14);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 13);
  uint64_t v3 = (void **)((char *)this + 80);
  std::vector<Security::CFRef<__CFData const*>>::__destroy_vector::operator()[abi:ne180100](&v3);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 8);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 7);
  Security::CFRef<__CFDate const*>::~CFRef((const void **)this + 6);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)this + 5);
  Security::CFRef<void const*>::~CFRef((const void **)this + 4);
  Security::CFRef<__SecIdentity *>::~CFRef((const void **)this + 3);
}

const void **Security::CFRef<__SecIdentity *>::~CFRef(const void **a1)
{
  unsigned int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **Security::CFRef<void const*>::~CFRef(const void **a1)
{
  unsigned int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void std::vector<Security::CFRef<__CFData const*>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uid_t v1 = *a1;
  unsigned int v2 = (const void **)**a1;
  if (v2)
  {
    unsigned int v4 = (const void **)v1[1];
    int v5 = v2;
    if (v4 != v2)
    {
      do
        unsigned int v4 = Security::CFRef<__CFData const*>::~CFRef(v4 - 1);
      while (v4 != v2);
      int v5 = **a1;
    }
    v1[1]  = v2;
    operator delete(v5);
  }
}

uint64_t Security::CodeSigning::SecCodeSigner::parameters(Security::CodeSigning::SecCodeSigner *this, const __CFDictionary *a2)
{
  uint64_t v3 = 4294900225;
  Security::CFDictionary::CFDictionary((Security::CFDictionary *)&theDict, a2, (Security::MacOSError *)0xFFFEFA0ELL);
  CFStringRef Value = CFDictionaryGetValue(theDict, @"edit-cpu-type");
  Security::CFRef<__CFNumber const*>::check<void const*>(Value, (Security::MacOSError *)v123);
  int v5 = CFDictionaryGetValue(theDict, @"edit-cpu-subtype");
  Security::CFRef<__CFNumber const*>::check<void const*>(v5, (Security::MacOSError *)v123);
  if (Value && v5)
  {
    int v6 = Security::cfNumber<unsigned int>((const __CFNumber *)Value);
    int v7 = Security::cfNumber<unsigned int>((const __CFNumber *)v5);
    *((_DWORD *)this + 76)  = v6;
    *((_DWORD *)this + 77)  = v7;
  }
  size_t v8 = CFDictionaryGetValue(theDict, @"edit-cms");
  Security::CFRef<__CFData const*>::check<void const*>(v8, (Security::MacOSError *)v123);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 39, v8);
  uint64_t v9 = CFDictionaryGetValue(theDict, @"dryrun");
  CFTypeRef v10 = Security::CFRef<__CFBoolean const*>::check<void const*>(v9, (Security::MacOSError *)v123);
  CFTypeRef v11 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
  if (v10) {
    BOOL v12 = v10 == v11;
  }
  else {
    BOOL v12 = 0;
  }
  char v13 = v12;
  *((unsigned char *)this + 250)  = v13;
  int v14 = CFDictionaryGetValue(theDict, @"sdkroot");
  Security::CFRef<__CFURL const*>::check<void const*>(v14, (Security::MacOSError *)v123);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 14, v14);
  vm_size_t v15 = CFDictionaryGetValue(theDict, @"preserve-afsc");
  CFTypeRef v16 = Security::CFRef<__CFBoolean const*>::check<void const*>(v15, (Security::MacOSError *)v123);
  if (v16) {
    BOOL v17 = v16 == v11;
  }
  else {
    BOOL v17 = 0;
  }
  char v18 = v17;
  *((unsigned char *)this + 300)  = v18;
  if ((*((unsigned char *)this + 17) & 4) != 0) {
    goto LABEL_155;
  }
  uint64_t v19 = CFDictionaryGetValue(theDict, @"signer");
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 3, v19);
  if (*((void *)this + 3))
  {
    CFTypeID v20 = CFGetTypeID(*((CFTypeRef *)this + 3));
    if (v20 != SecIdentityGetTypeID() && !CFEqual(*((CFTypeRef *)this + 3), (CFTypeRef)*MEMORY[0x1E4F1D260])) {
      goto LABEL_157;
    }
  }
  int v21 = CFDictionaryGetValue(theDict, @"flags");
  CFNumberRef v22 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(v21, (Security::MacOSError *)v123);
  if (v22)
  {
    *((unsigned char *)this + 144)  = 1;
    *((_DWORD *)this + 34)  = Security::cfNumber<unsigned int>(v22);
  }
  else
  {
    *((unsigned char *)this + 144)  = 0;
  }
  cf[0]  = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  unsigned int v23 = CFDictionaryGetValue(theDict, @"digest-algorithm");
  Security::CFCopyRef<void const*>::CFCopyRef(cf, v23);
  CFArrayRef v24 = (CFArrayRef)cf[0];
  if (cf[0])
  {
    unint64_t v125 = 0xAAAAAAAAAAAAAAAALL;
    values.__r_.__value_.__l.__data_  = (std::string::pointer)cf[0];
    CFTypeID v25 = CFGetTypeID(cf[0]);
    if (v25 == CFArrayGetTypeID())
    {
      CFRetain(v24);
      unint64_t v125 = (unint64_t)v24;
      goto LABEL_27;
    }
    CFArrayRef v24 = CFArrayCreate(0, (const void **)&values.__r_.__value_.__l.__data_, 1, MEMORY[0x1E4F1D510]);
    unint64_t v125 = (unint64_t)v24;
    if (v24)
    {
LABEL_27:
      CFArrayGetCount(v24);
      operator new[]();
    }
    Security::CFRef<__CFArray const*>::~CFRef((const void **)&v125);
  }
  Security::CFRef<void const*>::~CFRef(cf);
  unsigned int v26 = CFDictionaryGetValue(theDict, @"cmssize");
  CFNumberRef v27 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(v26, (Security::MacOSError *)v123);
  if (v27) {
    unint64_t v28 = Security::cfNumber<unsigned long>(v27);
  }
  else {
    unint64_t v28 = 18000;
  }
  *((void *)this + 16)  = v28;
  unsigned int v29 = CFDictionaryGetValue(theDict, @"preserve-metadata");
  CFNumberRef v30 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(v29, (Security::MacOSError *)v123);
  if (v30) {
    LODWORD(v30)  = Security::cfNumber<unsigned int>(v30);
  }
  *((_DWORD *)this + 35)  = v30;
  unsigned int v31 = CFDictionaryGetValue(theDict, @"signing-time");
  unsigned int v32 = v31;
  if (v31)
  {
    CFTypeID v33 = CFGetTypeID(v31);
    if (v33 != CFDateGetTypeID() && v32 != (const void *)*MEMORY[0x1E4F1D260]) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
    }
    CFRetain(v32);
    uint64_t v34 = (const void *)*((void *)this + 6);
    if (v34) {
      CFRelease(v34);
    }
    *((void *)this + 6)  = v32;
  }
  CFStringRef v35 = (const __CFString *)CFDictionaryGetValue(theDict, @"identifier");
  Security::CFRef<__CFString const*>::check<void const*>(v35, (Security::MacOSError *)v123);
  if (v35)
  {
    Security::cfString(&values, v35);
    uint64_t v36 = (void **)((char *)this + 176);
    if (*((char *)this + 199) < 0) {
      operator delete(*v36);
    }
    *(_OWORD *)uint64_t v36 = *(_OWORD *)&values.__r_.__value_.__l.__data_;
    *((void *)this + 24)  = *((void *)&values.__r_.__value_.__l + 2);
  }
  CFStringRef v37 = (const __CFString *)CFDictionaryGetValue(theDict, @"teamidentifier");
  Security::CFRef<__CFString const*>::check<void const*>(v37, (Security::MacOSError *)v123);
  if (v37)
  {
    Security::cfString(&values, v37);
    int v38 = (void **)((char *)this + 224);
    if (*((char *)this + 247) < 0) {
      operator delete(*v38);
    }
    *(_OWORD *)int v38 = *(_OWORD *)&values.__r_.__value_.__l.__data_;
    *((void *)this + 30)  = *((void *)&values.__r_.__value_.__l + 2);
  }
  size_t v39 = CFDictionaryGetValue(theDict, @"platform-identifier");
  CFNumberRef v40 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(v39, (Security::MacOSError *)v123);
  if (v40)
  {
    values.__r_.__value_.__r.__words[0]  = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v41 = (Security::CFError *)CFNumberGetValue(v40, kCFNumberLongLongType, &values);
    if (!v41) {
      Security::CFError::throwMe(v41);
    }
    if (values.__r_.__value_.__r.__words[0] >= 0x100) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA43);
    }
    *((unsigned char *)this + 248)  = values.__r_.__value_.__s.__data_[0];
  }
  CFStringRef v42 = (const __CFString *)CFDictionaryGetValue(theDict, @"identifier-prefix");
  Security::CFRef<__CFString const*>::check<void const*>(v42, (Security::MacOSError *)v123);
  if (v42)
  {
    Security::cfString(&values, v42);
    long long v43 = (void **)((char *)this + 200);
    if (*((char *)this + 223) < 0) {
      operator delete(*v43);
    }
    *(_OWORD *)long long v43 = *(_OWORD *)&values.__r_.__value_.__l.__data_;
    *((void *)this + 27)  = *((void *)&values.__r_.__value_.__l + 2);
  }
  unsigned int v44 = CFDictionaryGetValue(theDict, @"requirements");
  int v45 = v44;
  if (v44)
  {
    CFTypeID v46 = CFGetTypeID(v44);
    if (v46 != CFDataGetTypeID())
    {
      CFTypeID v47 = CFGetTypeID(v45);
      if (v47 != CFStringGetTypeID()) {
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
      }
    }
    Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 15, v45);
  }
  else
  {
    uint64_t v48 = (const void *)*((void *)this + 15);
    if (v48) {
      CFRelease(v48);
    }
    *((void *)this + 15)  = 0;
  }
  uint64_t v49 = CFDictionaryGetValue(theDict, @"no-macho");
  CFTypeRef v50 = Security::CFRef<__CFBoolean const*>::check<void const*>(v49, (Security::MacOSError *)v123);
  if (v50) {
    BOOL v51 = v50 == v11;
  }
  else {
    BOOL v51 = 0;
  }
  char v52 = v51;
  *((unsigned char *)this + 249)  = v52;
  size_t v53 = CFDictionaryGetValue(theDict, @"pagesize");
  Security::CFRef<__CFNumber const*>::check<void const*>(v53, (Security::MacOSError *)v123);
  if (v53) {
    CFRetain(v53);
  }
  unint64_t v54 = (const void *)*((void *)this + 32);
  if (v54) {
    CFRelease(v54);
  }
  *((void *)this + 32)  = v53;
  unsigned int v55 = CFDictionaryGetValue(theDict, @"detached");
  CFTypeRef v56 = *Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 4, v55);
  if (v56)
  {
    CFTypeID v57 = CFGetTypeID(v56);
    if (v57 != CFURLGetTypeID() && v57 != CFDataGetTypeID() && v57 != CFNullGetTypeID()) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
    }
  }
  uint64_t v58 = CFDictionaryGetValue(theDict, @"resource-rules");
  unint64_t v59 = v58;
  if (v58)
  {
    uint64_t v3 = v123;
    CFTypeID v60 = CFGetTypeID(v58);
    if (v60 != CFDictionaryGetTypeID()) {
LABEL_157:
    }
      Security::MacOSError::throwMe((Security::MacOSError *)v3);
  }
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 5, v59);
  unsigned int v61 = CFDictionaryGetValue(theDict, @"application-specific");
  Security::CFRef<__CFData const*>::check<void const*>(v61, (Security::MacOSError *)v123);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 7, v61);
  long long v62 = CFDictionaryGetValue(theDict, @"entitlements");
  Security::CFRef<__CFData const*>::check<void const*>(v62, (Security::MacOSError *)v123);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 8, v62);
  size_t v63 = CFDictionaryGetValue(theDict, @"force-library-entitlements");
  CFTypeRef v64 = Security::CFRef<__CFBoolean const*>::check<void const*>(v63, (Security::MacOSError *)v123);
  if (v64) {
    BOOL v65 = v64 == v11;
  }
  else {
    BOOL v65 = 0;
  }
  char v66 = v65;
  *((unsigned char *)this + 72)  = v66;
  uint64_t v67 = *((void *)this + 10);
  BOOL v68 = (const void **)*((void *)this + 11);
  uint64_t v69 = (uint64_t)v68 - v67;
  if ((unint64_t)v68 - v67 > 0x17)
  {
    if (v69 != 24)
    {
      uint64_t v83 = (const void **)(v67 + 24);
      while (v68 != v83)
        Security::CFRef<__CFData const*>::~CFRef(--v68);
      *((void *)this + 11)  = v83;
    }
  }
  else
  {
    unint64_t v70 = 3 - (v69 >> 3);
    uint64_t v71 = *((void *)this + 12);
    if (v70 <= (v71 - (uint64_t)v68) >> 3)
    {
      bzero(*((void **)this + 11), 8 * v70);
      *((void *)this + 11)  = &v68[v70];
    }
    else
    {
      uint64_t v72 = v71 - v67;
      uint64_t v73 = v72 >> 2;
      if ((unint64_t)(v72 >> 2) <= 3) {
        uint64_t v73 = 3;
      }
      if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v74 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v74 = v73;
      }
      unint64_t v75 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Security::CodeSigning::ResourceBuilder::Rule *>>(v74);
      uint64_t v77 = *((void *)this + 10);
      uint64_t v76 = *((void *)this + 11);
      unsigned int v78 = &v75[8 * (v69 >> 3)];
      uint64_t v80 = &v75[8 * v79];
      bzero(v78, 8 * v70);
      unsigned int v81 = &v78[8 * v70];
      while (v76 != v77)
      {
        uint64_t v82 = *(void *)(v76 - 8);
        v76 -= 8;
        *((void *)v78 - 1)  = v82;
        v78 -= 8;
      }
      long long v84 = *((_OWORD *)this + 5);
      *((void *)this + 10)  = v78;
      *((void *)this + 11)  = v81;
      *((void *)this + 12)  = v80;
      long long v85 = (const void **)*((void *)&v84 + 1);
      uint64_t v86 = (const void **)v84;
      while (v85 != v86)
        long long v85 = Security::CFRef<__CFData const*>::~CFRef(v85 - 1);
      if (v86) {
        operator delete(v86);
      }
    }
  }
  long long v87 = CFDictionaryGetValue(theDict, @"lwcr-self");
  Security::CFRef<__CFData const*>::check<void const*>(v87, (Security::MacOSError *)v123);
  Security::CFRef<__CFArray const*>::operator=(*((CFTypeRef **)this + 10), v87);
  long long v88 = CFDictionaryGetValue(theDict, @"lwcr-parent");
  Security::CFRef<__CFData const*>::check<void const*>(v88, (Security::MacOSError *)v123);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)(*((void *)this + 10) + 8), v88);
  unint64_t v89 = CFDictionaryGetValue(theDict, @"lwcr-responsible");
  Security::CFRef<__CFData const*>::check<void const*>(v89, (Security::MacOSError *)v123);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)(*((void *)this + 10) + 16), v89);
  uint64_t v90 = CFDictionaryGetValue(theDict, @"lwcr-library");
  Security::CFRef<__CFData const*>::check<void const*>(v90, (Security::MacOSError *)v123);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 13, v90);
  std::string::size_type v91 = CFDictionaryGetValue(theDict, @"timestamp-required");
  CFTypeRef v92 = Security::CFRef<__CFBoolean const*>::check<void const*>(v91, (Security::MacOSError *)v123);
  if (v92)
  {
    *((unsigned char *)this + 280)  = v92 == v11;
    goto LABEL_119;
  }
  *((unsigned char *)this + 280)  = 0;
  uint64_t v93 = *((void *)this + 3);
  if (v93 && v93 != *MEMORY[0x1E4F1D260])
  {
    values.__r_.__value_.__r.__words[0]  = *(void *)(v93 + 16);
    CFRetain(values.__r_.__value_.__l.__data_);
    uint64_t v94 = values.__r_.__value_.__r.__words[0];
    LOBYTE(cf[0])  = 0;
    CFStringRef v95 = (const __CFString *)CFDataCreateWithBytesNoCopy(0, Security::CodeSigning::caspianLeafMarker, 10, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    CFStringRef v96 = v95;
    if (v94 && v95)
    {
      CFDataRef v97 = SecCertificateCopyExtensionValue(v94, v95, cf);
      BOOL v98 = v97 != 0;
      if (v97)
      {
        CFRelease(v97);
        BOOL v98 = 1;
      }
    }
    else
    {
      if (!v95) {
        goto LABEL_117;
      }
      BOOL v98 = 0;
    }
    CFRelease(v96);
    if (v98)
    {
      *((unsigned char *)this + 280)  = 1;
      goto LABEL_164;
    }
LABEL_117:
    if (!*((unsigned char *)this + 280))
    {
      Security::CFRef<__SecCertificate *>::~CFRef((const void **)&values.__r_.__value_.__l.__data_);
      goto LABEL_119;
    }
LABEL_164:
    std::string v121 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(cf[0])  = 0;
      _os_log_impl(&dword_18B299000, v121, OS_LOG_TYPE_DEFAULT, "Platform does not support signing secure timestamps", (uint8_t *)cf, 2u);
    }
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFFFCLL);
  }
LABEL_119:
  long long v99 = CFDictionaryGetValue(theDict, @"timestamp-authentication");
  uint64_t v100 = v99;
  if (v99)
  {
    uint64_t v3 = v123;
    CFTypeID v101 = CFGetTypeID(v99);
    if (v101 != SecIdentityGetTypeID()) {
      goto LABEL_157;
    }
  }
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 33, v100);
  uint64_t v102 = CFDictionaryGetValue(theDict, @"timestamp-url");
  Security::CFRef<__CFURL const*>::check<void const*>(v102, (Security::MacOSError *)v123);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 34, v102);
  uint64_t v103 = CFDictionaryGetValue(theDict, @"timestamp-omit-certificates");
  CFTypeRef v104 = Security::CFRef<__CFBoolean const*>::check<void const*>(v103, (Security::MacOSError *)v123);
  if (v104) {
    BOOL v105 = v104 == v11;
  }
  else {
    BOOL v105 = 0;
  }
  char v106 = v105;
  *((unsigned char *)this + 281)  = v106;
  CFStringRef v107 = (const __CFString *)CFDictionaryGetValue(theDict, @"runtime-version");
  Security::CFRef<__CFString const*>::check<void const*>(v107, (Security::MacOSError *)v123);
  if (v107)
  {
    memset(&values, 170, sizeof(values));
    Security::cfString(&values, v107);
    std::string::size_type size = HIBYTE(values.__r_.__value_.__r.__words[2]);
    if ((values.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = values.__r_.__value_.__l.__size_;
    }
    if (!size) {
      goto LABEL_144;
    }
    v109  = 0;
    unsigned __int8 v110 = (values.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &values
         : (std::string *)values.__r_.__value_.__r.__words[0];
    uint64_t v111 = (std::string *)((char *)v110 + size);
    uint64_t v112 = 16;
    while (v110 < v111)
    {
      cf[0]  = 0;
      *__error()  = 0;
      uint64_t v113 = strtol((const char *)v110, (char **)cf, 10);
      CFCharacterSetRef v114 = cf[0];
      if (v110 != cf[0])
      {
        uint64_t v115 = v113;
        if (!*__error() && (v115 & 0x8000000000000000) == 0 && v115 <= 255)
        {
          v109 |= v115 << v112;
          if (!*v114) {
            break;
          }
          if (*v114 == 46)
          {
            if (v112)
            {
              v112 -= 8;
              unsigned __int8 v110 = (std::string *)(v114 + 1);
              if (v114 + 1 != (unsigned char *)v111) {
                continue;
              }
            }
          }
        }
      }
      goto LABEL_144;
    }
    if (!v109) {
LABEL_144:
    }
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA4FLL);
    *((_DWORD *)this + 74)  = v109;
    if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(values.__r_.__value_.__l.__data_);
    }
  }
  std::string v116 = CFDictionaryGetValue(theDict, @"omit-adhoc-flag");
  CFTypeRef v117 = Security::CFRef<__CFBoolean const*>::check<void const*>(v116, (Security::MacOSError *)v123);
  if (v117) {
    BOOL v118 = v117 == v11;
  }
  else {
    BOOL v118 = 0;
  }
  char v119 = v118;
  *((unsigned char *)this + 301)  = v119;
LABEL_155:
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&theDict);
  uint64_t result = (*(uint64_t (**)(Security::CodeSigning::SecCodeSigner *))(*(void *)this + 80))(this);
  if ((result & 1) == 0) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  }
  return result;
}

void sub_18B3ECEA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21)
{
}

Security::CFDictionary *Security::CFDictionary::CFDictionary(Security::CFDictionary *this, const __CFDictionary *a2, Security::MacOSError *a3)
{
  *((_DWORD *)Security::CFCopyRef<__CFDictionary const*>::CFCopyRef(this, a2) + 2)  = a3;
  if (!a2) {
    Security::MacOSError::throwMe(a3);
  }
  return this;
}

void sub_18B3ECFC8(_Unwind_Exception *a1)
{
  Security::CFRef<__CFDictionary const*>::~CFRef(v1);
  _Unwind_Resume(a1);
}

CFTypeRef Security::CFRef<__CFNumber const*>::check<void const*>(CFTypeRef cf, Security::MacOSError *a2)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 != CFNumberGetTypeID()) {
      Security::MacOSError::throwMe(a2);
    }
  }
  return cf;
}

CFTypeRef Security::CFRef<__CFData const*>::check<void const*>(CFTypeRef cf, Security::MacOSError *a2)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 != CFDataGetTypeID()) {
      Security::MacOSError::throwMe(a2);
    }
  }
  return cf;
}

CFTypeRef Security::CFRef<__CFBoolean const*>::check<void const*>(CFTypeRef cf, Security::MacOSError *a2)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 != CFBooleanGetTypeID()) {
      Security::MacOSError::throwMe(a2);
    }
  }
  return cf;
}

CFTypeRef Security::CFRef<__CFURL const*>::check<void const*>(CFTypeRef cf, Security::MacOSError *a2)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 != CFURLGetTypeID()) {
      Security::MacOSError::throwMe(a2);
    }
  }
  return cf;
}

void *Security::CFCopyRef<void const*>::CFCopyRef(void *a1, CFTypeRef cf)
{
  *a1  = cf;
  if (cf) {
    CFRetain(cf);
  }
  return a1;
}

void sub_18B3ED160(_Unwind_Exception *a1)
{
  Security::CFRef<void const*>::~CFRef(v1);
  _Unwind_Resume(a1);
}

unint64_t Security::cfNumber<unsigned long>(const __CFNumber *a1)
{
  unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
  CFStringRef Value = (Security::CFError *)CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr);
  if (!Value) {
    Security::CFError::throwMe(Value);
  }
  return valuePtr;
}

CFTypeRef Security::CFRef<__CFString const*>::check<void const*>(CFTypeRef cf, Security::MacOSError *a2)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 != CFStringGetTypeID()) {
      Security::MacOSError::throwMe(a2);
    }
  }
  return cf;
}

void *Security::CFCopyRef<__CFDictionary const*>::CFCopyRef(void *a1, CFTypeRef cf)
{
  *a1  = cf;
  if (cf) {
    CFRetain(cf);
  }
  return a1;
}

void sub_18B3ED238(_Unwind_Exception *a1)
{
  Security::CFRef<__CFDictionary const*>::~CFRef(v1);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::SecCodeSigner::sign(Security::CodeSigning::SecCodeSigner *this, Security::CodeSigning::SecStaticCode *a2, int a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  int v6 = Security::CodeSigning::SecStaticCode::codeDirectory(a2, 0);
  if ((a3 & 2) == 0
    || !v6
    || (int v7 = Security::CodeSigning::SecStaticCode::codeDirectory(a2, 0)) != 0 && (v7[13] & 2) != 0)
  {
    *((_DWORD *)a2 + 52)  = a3;
    memcpy(__dst, &unk_18B41C710, sizeof(__dst));
    Security::CodeSigning::SecCodeSigner::Signer::Signer((Security::CodeSigning::SecCodeSigner::Signer *)__dst, this, a2);
    int v8 = *((_DWORD *)this + 4) | a3;
    if (v8)
    {
      CFTypeRef v10 = secLogObjForScope("signer");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 134218240;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14]  = a2;
        _os_log_debug_impl(&dword_18B299000, v10, OS_LOG_TYPE_DEBUG, "%p will remove signature from %p", buf, 0x16u);
      }
      if (*(void *)(__dst[1] + 32))
      {
        uint64_t v19 = 4294900259;
      }
      else
      {
        Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((uint64_t)&__dst[3], *(void *)(__dst[2] + 32));
        if (!*(unsigned char *)(__dst[1] + 300))
        {
          if (!*(unsigned char *)(__dst[1] + 249))
          {
            vm_size_t v15 = (Security::Universal *)(*(uint64_t (**)(void))(*(void *)__dst[3] + 80))(__dst[3]);
            if (v15)
            {
              unint64_t v36 = 0xAAAAAAAAAAAAAAAALL;
              *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
              *((void *)&v16 + 1)  = 0xAAAAAAAAAAAAAAAALL;
              long long v34 = v16;
              long long v35 = v16;
              long long v32 = v16;
              long long v33 = v16;
              long long v30 = v16;
              long long v31 = v16;
              long long v28 = v16;
              long long v29 = v16;
              long long v26 = v16;
              long long v27 = v16;
              *(_OWORD *)&uint8_t buf[16] = v16;
              long long v25 = v16;
              *(_OWORD *)long long buf = v16;
              BOOL v17 = (atomic_uint *)(*(uint64_t (**)(void))(*(void *)__dst[3] + 256))();
              char v18 = (void *)(*(uint64_t (**)(void *))(__dst[0] + 24))(__dst);
              std::set<unsigned int>::set[abi:ne180100]((uint64_t)v22, v18);
              (*(void (**)(void **__return_ptr))(*(void *)__dst[3] + 40))(__p);
              Security::CodeSigning::MachOEditor::MachOEditor((uint64_t)buf, v17, v15, v22, (long long *)__p);
              if (v21 < 0) {
                operator delete(__p[0]);
              }
              std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((void *)v22[1]);
              Security::CodeSigning::MachOEditor::allocate((Security::CodeSigning::MachOEditor *)buf);
            }
          }
          *(void *)&long long v27 = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v11 + 1)  = 0xAAAAAAAAAAAAAAAALL;
          long long v25 = v11;
          long long v26 = v11;
          *(_OWORD *)long long buf = v11;
          *(_OWORD *)&uint8_t buf[16] = v11;
          BOOL v12 = (atomic_uint *)(*(uint64_t (**)(void))(*(void *)__dst[3] + 256))();
          Security::Mutex::Mutex((pthread_mutex_t *)&buf[8]);
          if (v12) {
            atomic_fetch_add_explicit(v12 + 2, 1u, memory_order_relaxed);
          }
          *(void *)long long buf = v12;
          (*(void (**)(atomic_uint *))(*(void *)v12 + 40))(v12);
          (*(void (**)(void))(**(void **)buf + 48))(*(void *)buf);
          Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer((uint64_t)buf);
          goto LABEL_19;
        }
        (*(void (**)(void))(*(void *)__dst[3] + 256))(__dst[3]);
        uint64_t v19 = 4294967292;
      }
    }
    else
    {
      if ((v8 & 0x400) != 0)
      {
        char v13 = secLogObjForScope("signer");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 134218240;
          *(void *)&uint8_t buf[4] = this;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14]  = a2;
          _os_log_debug_impl(&dword_18B299000, v13, OS_LOG_TYPE_DEBUG, "%p will edit signature of %p", buf, 0x16u);
        }
        uint64_t v14 = (*(uint64_t (**)(void))(**(void **)(__dst[2] + 32) + 16))(*(void *)(__dst[2] + 32));
        Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((uint64_t)&__dst[3], v14);
        if (*(unsigned char *)(__dst[1] + 249)) {
          Security::CodeSigning::SecCodeSigner::Signer::prepareForEdit((Security::CodeSigning::SecCodeSigner::Signer *)__dst);
        }
        (*(void (**)(void))(*(void *)__dst[3] + 80))(__dst[3]);
        Security::CodeSigning::SecCodeSigner::Signer::prepareForEdit((Security::CodeSigning::SecCodeSigner::Signer *)__dst);
      }
      if ((*(unsigned int (**)(Security::CodeSigning::SecCodeSigner *))(*(void *)this + 80))(this))
      {
        uint64_t v9 = secLogObjForScope("signer");
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 134218496;
          *(void *)&uint8_t buf[4] = this;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14]  = a2;
          *(_WORD *)&buf[22]  = 1024;
          *(_DWORD *)&unsigned char buf[24] = a3;
          _os_log_debug_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEBUG, "%p will sign %p (flags 0x%x)", buf, 0x1Cu);
        }
        Security::CodeSigning::SecCodeSigner::Signer::sign((Security::CodeSigning::SecCodeSigner::Signer *)__dst, *((_DWORD *)this + 4) & 0x1000000 | a3);
LABEL_19:
        Security::CodeSigning::SecStaticCode::resetValidity(a2);
        Security::CodeSigning::SecCodeSigner::Signer::~Signer((Security::CodeSigning::SecCodeSigner::Signer *)__dst);
        return;
      }
      uint64_t v19 = 4294900225;
    }
    Security::MacOSError::throwMe((Security::MacOSError *)v19);
  }
}

void sub_18B3EDD70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a17);
  MEMORY[0x18C12D390](v72, 0x10B3C408FE6E862);
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer((uint64_t)&a72);
  Security::CodeSigning::SecCodeSigner::Signer::~Signer((Security::CodeSigning::SecCodeSigner::Signer *)&a19);
  _Unwind_Resume(a1);
}

Security::CodeSigning::SecCodeSigner::Signer *Security::CodeSigning::SecCodeSigner::Signer::Signer(Security::CodeSigning::SecCodeSigner::Signer *this, Security::CodeSigning::SecCodeSigner *a2, Security::CodeSigning::SecStaticCode *a3)
{
  *(void *)this  = &unk_1ED84A1F0;
  *((void *)this + 1)  = a2;
  *((void *)this + 2)  = a3;
  *((void *)this + 3)  = 0;
  Security::Mutex::Mutex((pthread_mutex_t *)((char *)this + 32));
  *((void *)this + 15)  = 0;
  *((void *)this + 12)  = 0;
  *((void *)this + 16)  = 0;
  *((void *)this + 13)  = 0;
  *((void *)this + 14)  = (char *)this + 120;
  *(_OWORD *)((char *)this + 136)  = 0u;
  *(_OWORD *)((char *)this + 184)  = 0u;
  *(_OWORD *)((char *)this + 216)  = 0u;
  *((void *)this + 31)  = 0;
  *((void *)this + 32)  = 0;
  *((void *)this + 30)  = 0;
  *(_OWORD *)((char *)this + 152)  = 0u;
  *(_OWORD *)((char *)this + 168)  = 0u;
  *(_OWORD *)((char *)this + 200)  = 0u;
  *((void *)this + 29)  = (char *)this + 240;
  *((void *)this + 34)  = 0;
  *((void *)this + 35)  = 0;
  *((void *)this + 33)  = (char *)this + 272;
  *((void *)this + 37)  = 0;
  *((unsigned char *)this + 322)  = 0;
  *((void *)this + 45)  = 0;
  *((void *)this + 46)  = 0;
  *((void *)this + 43)  = 0;
  *((void *)this + 44)  = (char *)this + 360;
  *((void *)this + 41)  = 0;
  *((void *)this + 42)  = 0;
  Security::Mutex::Mutex((pthread_mutex_t *)((char *)this + 376));
  *((unsigned char *)this + 321)  = ((*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(void *)this + 16))(this) & 0x80) != 0;
  return this;
}

void sub_18B3EDF98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  char v18 = v14;
  Security::Mutex::~Mutex(v18);
  std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::destroy(*(void **)(v11 + 360));
  Security::CFRef<__CFArray const*>::~CFRef((const void **)(v16 + 216));
  std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>>>::destroy(*(void **)(v11 + 272));
  std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::destroy(*(void **)(v11 + 240));
  Security::CFRef<__CFData const*>::~CFRef(v15);
  a10  = v16 + 72;
  std::vector<Security::CFRef<__CFData const*>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  Security::CFRef<__CFData const*>::~CFRef(v13);
  if (*(char *)(v11 + 183) < 0) {
    operator delete(*(void **)(v11 + 160));
  }
  if (*(char *)(v11 + 159) < 0) {
    operator delete(*v17);
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(void **)(v11 + 120));
  Security::CFRef<__CFData const*>::~CFRef((const void **)(v11 + 104));
  Security::CFRef<__CFDictionary const*>::~CFRef(v12);
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(v10);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::SecCodeSigner::Signer::~Signer(Security::CodeSigning::SecCodeSigner::Signer *this)
{
  *(void *)this  = &unk_1ED84A1F0;
  free(*((void **)this + 37));
  Security::Mutex::~Mutex((pthread_mutex_t *)((char *)this + 376));
  std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::destroy(*((void **)this + 45));
  Security::CFRef<__CFArray const*>::~CFRef((const void **)this + 42);
  std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>>>::destroy(*((void **)this + 34));
  std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::destroy(*((void **)this + 30));
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 27);
  unsigned int v2 = (void **)((char *)this + 192);
  std::vector<Security::CFRef<__CFData const*>>::__destroy_vector::operator()[abi:ne180100](&v2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 23);
  if (*((char *)this + 183) < 0) {
    operator delete(*((void **)this + 20));
  }
  if (*((char *)this + 159) < 0) {
    operator delete(*((void **)this + 17));
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((void **)this + 15));
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 13);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)this + 12);
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((uint64_t)this + 24);
}

void std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::destroy(*a1);
    std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::destroy(a1[1]);
    std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>::reset[abi:ne180100](a1 + 5, 0);
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>>>::destroy(*a1);
    std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>>>::destroy(a1[1]);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((void *)a1[6]);
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::destroy(*a1);
    std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::destroy(a1[1]);
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy((const void **)a1[6]);
    operator delete(a1);
  }
}

uint64_t *std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*(const void ***)(v2 + 8));
    JUMPOUT(0x18C12D390);
  }
  return result;
}

void Security::CodeSigning::SecCodeSigner::returnDetachedSignature(CFTypeRef *this, Security::BlobCore *a2, Security::CodeSigning::SecCodeSigner::Signer *a3)
{
  CFTypeID v5 = CFGetTypeID(this[4]);
  if (v5 == CFURLGetTypeID())
  {
    Security::cfString((Security *)__p, (const __CFURL *)this[4]);
    unint64_t v15 = 0xAAAAAAAAFFFFFFFFLL;
    if (v14 >= 0) {
      int v6 = __p;
    }
    else {
      int v6 = (void **)__p[0];
    }
    Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v15, (const char *)v6, 1537, 438);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
    Security::UnixPlusPlus::FileDesc::writeAll((ssize_t)&v15, (char *)a2, bswap32(*((_DWORD *)a2 + 1)));
    Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v15);
  }
  else
  {
    CFTypeID v7 = CFGetTypeID(this[4]);
    CFTypeID TypeID = CFDataGetTypeID();
    uint64_t v9 = (__CFData *)this[4];
    if (v7 == TypeID)
    {
      CFIndex v10 = bswap32(*((_DWORD *)a2 + 1));
      CFDataAppendBytes(v9, (const UInt8 *)a2, v10);
    }
    else
    {
      CFTypeID v11 = CFGetTypeID(v9);
      if (v11 == CFNullGetTypeID())
      {
        BOOL v12 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p[0])  = 0;
          _os_log_impl(&dword_18B299000, v12, OS_LOG_TYPE_DEFAULT, "Platform does not support the detached signature database", (uint8_t *)__p, 2u);
        }
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFFFCLL);
      }
    }
  }
}

void sub_18B3EE3F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void *__Block_byref_object_copy__17305(void *result, void *a2)
{
  result[5]  = a2[5];
  uint64_t v2 = a2 + 6;
  uint64_t v3 = a2[6];
  result[6]  = v3;
  CFTypeID v4 = result + 6;
  uint64_t v5 = a2[7];
  result[7]  = v5;
  if (v5)
  {
    *(void *)(v3 + 16)  = v4;
    a2[5]  = v2;
    *uint64_t v2 = 0;
    a2[7]  = 0;
  }
  else
  {
    result[5]  = v4;
  }
  return result;
}

void __Block_byref_object_dispose__17306(uint64_t a1)
{
}

void *__Block_byref_object_copy__13(void *result, void *a2)
{
  result[5]  = a2[5];
  uint64_t v2 = a2 + 6;
  uint64_t v3 = a2[6];
  result[6]  = v3;
  CFTypeID v4 = result + 6;
  uint64_t v5 = a2[7];
  result[7]  = v5;
  if (v5)
  {
    *(void *)(v3 + 16)  = v4;
    a2[5]  = v2;
    *uint64_t v2 = 0;
    a2[7]  = 0;
  }
  else
  {
    result[5]  = v4;
  }
  return result;
}

void __Block_byref_object_dispose__14(uint64_t a1)
{
}

uint64_t __Block_byref_object_copy__15(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40)  = *(void *)(a2 + 40);
  return result;
}

const void **__Block_byref_object_dispose__16(uint64_t a1)
{
  return Security::CFRef<__CFData const*>::~CFRef((const void **)(a1 + 40));
}

__CFData *Security::Blob<Security::CodeSigning::EntitlementDERBlob,4208882034u>::blobify(const __CFData *a1)
{
  CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFIndex Length = CFDataGetLength(a1);
  CFDataSetLength(Mutable, Length + 8);
  if (!Mutable) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFF94);
  }
  MutableBytePtr  = CFDataGetMutableBytePtr(Mutable);
  int v5 = CFDataGetLength(a1);
  *(_DWORD *)MutableBytePtr  = 1920065274;
  *((_DWORD *)MutableBytePtr + 1)  = bswap32(v5 + 8);
  BytePtr  = CFDataGetBytePtr(a1);
  CFIndex v7 = CFDataGetLength(a1);
  memcpy(MutableBytePtr + 8, BytePtr, v7);
  return Mutable;
}

CFHashCode Security::CodeSigning::SecStaticCode::hash(Security::CodeSigning::SecStaticCode *this)
{
  uint64_t v2 = (const void *)Security::CodeSigning::SecStaticCode::cdHash(this);
  if (v2)
  {
    return CFHash(v2);
  }
  else
  {
    int v5 = (const void *)(*(uint64_t (**)(void))(**((void **)this + 4) + 48))(*((void *)this + 4));
    CFHashCode v4 = CFHash(v5);
    Security::CFRef<__CFURL const*>::~CFRef(&v5);
    return v4;
  }
}

void sub_18B3EE62C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL Security::CodeSigning::SecStaticCode::equal(Security::CodeSigning::SecStaticCode *this, Security::SecCFObject *a2)
{
  uint64_t v4 = Security::CodeSigning::SecStaticCode::cdHash(this);
  uint64_t v5 = Security::CodeSigning::SecStaticCode::cdHash(a2);
  if (v4 | v5)
  {
    BOOL v6 = 0;
    if (v4 && v5) {
      return CFEqual((CFTypeRef)v4, (CFTypeRef)v5) != 0;
    }
  }
  else
  {
    uint64_t v9 = (const void *)(*(uint64_t (**)(void))(**((void **)this + 4) + 48))(*((void *)this + 4));
    int v8 = (const void *)(*(uint64_t (**)(void))(**((void **)a2 + 4) + 48))(*((void *)a2 + 4));
    BOOL v6 = CFEqual(v9, v8) != 0;
    Security::CFRef<__CFURL const*>::~CFRef(&v8);
    Security::CFRef<__CFURL const*>::~CFRef(&v9);
  }
  return v6;
}

void sub_18B3EE734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t Security::CodeSigning::SecStaticCode::ValidationContext::osStatus(Security::CodeSigning::SecStaticCode::ValidationContext *this)
{
  return 0;
}

void Security::CodeSigning::SecStaticCode::ValidationContext::reportProblem(Security::CodeSigning::SecStaticCode::ValidationContext *this, Security::CodeSigning::CSError *a2, const __CFString *a3, const __CFString *a4)
{
}

void Security::CodeSigning::SecStaticCode::ValidationContext::~ValidationContext(Security::CodeSigning::SecStaticCode::ValidationContext *this)
{
}

void Security::CodeSigning::SecStaticCode::CollectingContext::throwMe(Security::CodeSigning::SecStaticCode::CollectingContext *this)
{
  exception  = (Security::CodeSigning::CSError *)__cxa_allocate_exception(0xA0uLL);
  int v3 = *((_DWORD *)this + 6);
  uint64_t v4 = (const void *)*((void *)this + 2);
  if (v4)
  {
    CFRetain(v4);
    CFDictionaryRef v5 = (const __CFDictionary *)*((void *)this + 2);
  }
  else
  {
    CFDictionaryRef v5 = 0;
  }
  Security::CodeSigning::CSError::CSError(exception, v3, v5);
}

void sub_18B3EE804(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

Security::MacOSError *Security::CodeSigning::CSError::CSError(Security::CodeSigning::CSError *this, int a2, const __CFDictionary *a3)
{
  uint64_t result = Security::MacOSError::MacOSError(this, a2);
  *(void *)uint64_t result = &unk_1ED84A5E8;
  *((void *)result + 19)  = a3;
  return result;
}

uint64_t Security::CodeSigning::SecStaticCode::CollectingContext::osStatus(Security::CodeSigning::SecStaticCode::CollectingContext *this)
{
  return *((unsigned int *)this + 6);
}

uint64_t Security::CodeSigning::SecStaticCode::CollectingContext::reportProblem(Security::CodeSigning::SecStaticCode::CollectingContext *this, int a2, const __CFString *a3, const void *a4)
{
  char v14 = (char *)this + 32;
  unint64_t v15 = 0xAAAAAAAAAAAAAA01;
  int v8 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  if (v8) {
    Security::UnixError::throwMe(v8);
  }
  if (*((_DWORD *)this + 6))
  {
    if (!a3) {
      return Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&v14);
    }
  }
  else
  {
    *((_DWORD *)this + 6)  = a2;
    if (!a3) {
      return Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&v14);
    }
  }
  CFDictionaryRef CFMutableDictionary = (const __CFDictionary *)*((void *)this + 2);
  if (!CFMutableDictionary)
  {
    CFDictionaryRef CFMutableDictionary = Security::makeCFMutableDictionary(v8);
    CFIndex v10 = (const void *)*((void *)this + 2);
    if (v10) {
      CFRelease(v10);
    }
    *((void *)this + 2)  = CFMutableDictionary;
  }
  CFStringRef Value = (void *)CFDictionaryGetValue(CFMutableDictionary, a3);
  if (!Value)
  {
    CFStringRef Value = Security::makeCFMutableArray(0, v11, v14, v15);
    if (!Value) {
      Security::CFError::throwMe(0);
    }
    CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 2), a3, Value);
    CFRelease(Value);
  }
  CFArrayAppendValue((CFMutableArrayRef)Value, a4);
  return Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&v14);
}

void sub_18B3EE948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void Security::CodeSigning::SecStaticCode::CollectingContext::~CollectingContext(Security::CodeSigning::SecStaticCode::CollectingContext *this)
{
  *(void *)this  = &unk_1ED84A290;
  uid_t v1 = (const void **)((char *)this + 16);
  Security::Mutex::~Mutex((pthread_mutex_t *)((char *)this + 32));
  Security::CFRef<__CFDictionary *>::~CFRef(v1);

  JUMPOUT(0x18C12D390);
}

{
  const void **v1;

  *(void *)this  = &unk_1ED84A290;
  uid_t v1 = (const void **)((char *)this + 16);
  Security::Mutex::~Mutex((pthread_mutex_t *)((char *)this + 32));
  Security::CFRef<__CFDictionary *>::~CFRef(v1);
}

uint64_t Security::CodeSigning::SecStaticCode::initializeFromParent(uint64_t this, const Security::CodeSigning::SecStaticCode *a2)
{
  *(void *)(this + 320)  = a2;
  *(void *)(this + 576)  = *((void *)a2 + 72);
  if (*((void *)a2 + 73)) {
    operator new();
  }
  return this;
}

void sub_18B3EEAF0(_Unwind_Exception *a1)
{
  MEMORY[0x18C12D390](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::SecStaticCode::prepareProgress(Security::CodeSigning::SecStaticCode *this, int a2)
{
  uint64_t v4 = *((void *)this + 39);
  block[0]  = MEMORY[0x1E4F143A8];
  block[1]  = 0x40000000;
  block[2]  = ___ZN8Security11CodeSigning13SecStaticCode15prepareProgressEj_block_invoke;
  block[3]  = &__block_descriptor_tmp_17327;
  void block[4] = this;
  dispatch_sync(v4, block);
  if ((*((unsigned char *)this + 211) & 0x10) != 0)
  {
    *((_DWORD *)this + 53)  = a2;
    *((_DWORD *)this + 54)  = 0;
  }
}

uint64_t ___ZN8Security11CodeSigning13SecStaticCode15prepareProgressEj_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 220)  = 0;
  return result;
}

void Security::CodeSigning::SecStaticCode::reportProgress(Security::CodeSigning::SecStaticCode *this)
{
  if (*((void *)this + 72) && (*((unsigned char *)this + 211) & 0x10) != 0)
  {
    uint64_t v4 = 0;
    CFDictionaryRef v5 = &v4;
    uint64_t v6 = 0x2000000000;
    char v7 = 0;
    uint64_t v1 = *((void *)this + 39);
    block[0]  = MEMORY[0x1E4F143A8];
    block[1]  = 0x40000000;
    block[2]  = ___ZN8Security11CodeSigning13SecStaticCode14reportProgressEj_block_invoke;
    block[3]  = &unk_1E54853F8;
    void block[4] = &v4;
    void block[5] = this;
    int v3 = 1;
    dispatch_sync(v1, block);
    if (*((unsigned char *)v5 + 24)) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA42);
    }
    _Block_object_dispose(&v4, 8);
  }
}

void sub_18B3EEC80(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

const void **___ZN8Security11CodeSigning13SecStaticCode14reportProgressEj_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v1 + 220)) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = 1;
  }
  *(_DWORD *)(v1 + 216) += *(_DWORD *)(a1 + 48);
  uint64_t v2 = *(void *)(v1 + 576);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1);
  Security::CFTemp<__CFDictionary const*>::CFTemp(&v11, (uint64_t)"{current=%d,total=%d}", v4, v5, v6, v7, v8, v9, *(unsigned int *)(v1 + 216));
  (*(void (**)(uint64_t, uint64_t, __CFString *, const void *))(v2 + 16))(v2, v3, @"progress", v11);
  return Security::CFRef<__CFDictionary const*>::~CFRef(&v11);
}

void sub_18B3EED60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

const void *Security::CFDictionary::get<__CFArray const*>(uint64_t a1, const char *a2)
{
  Security::CFTempString::CFTempString<char const*>((CFStringRef *)&key, a2);
  CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)a1, key);
  uint64_t v4 = Value;
  if (Value)
  {
    uint64_t v5 = (Security::MacOSError *)*(unsigned int *)(a1 + 8);
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 != CFArrayGetTypeID()) {
      Security::MacOSError::throwMe(v5);
    }
  }
  Security::CFRef<__CFString const*>::~CFRef((const void **)&key);
  return v4;
}

void sub_18B3EEDF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Security::CFRef<__CFString const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t *Security::CodeSigning::addError(Security::CodeSigning *this, uint64_t *a2, void *a3)
{
  CFTypeID v5 = CFGetTypeID(this);
  uint64_t result = (uint64_t *)CFNumberGetTypeID();
  if ((uint64_t *)v5 == result)
  {
    unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(this, kCFNumberSInt64Type, &valuePtr);
    return std::__tree<int>::__emplace_unique_key_args<int,int const&>(a2, valuePtr, valuePtr);
  }
  return result;
}

Security::CodeSigning::SecStaticCode *Security::CodeSigning::SecStaticCode::detachedSignature(Security::CodeSigning::SecStaticCode *this, const __CFData *a2)
{
  uint64_t v3 = (CFTypeRef *)((char *)this + 136);
  if (a2)
  {
    Security::CFRef<__CFArray const*>::operator=(v3, a2);
    operator new();
  }
  CFTypeRef v4 = *v3;
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 17)  = 0;
  uint64_t v5 = (*(uint64_t (**)(void))(**((void **)this + 4) + 16))(*((void *)this + 4));
  Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((uint64_t)this + 32, v5);
  return this;
}

void sub_18B3EF1D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (v15[151] < 0) {
    operator delete(*v20);
  }
  Security::CFRef<__CFData const*>::~CFRef(v19);
  Security::CFRef<__CFData const*>::~CFRef(v18);
  *(void *)unint64_t v15 = v16;
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(v17);
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)v15);
  if (a15 < 0) {
    operator delete(__p);
  }
  MEMORY[0x18C12D390](v15, 0x10F3C404880461CLL);
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::SecStaticCode::resetValidity(Security::CodeSigning::SecStaticCode *this)
{
  *((unsigned char *)this + 176)  = 0;
  *((unsigned char *)this + 192)  = 0;
  *((unsigned char *)this + 185)  = 0;
  uint64_t v2 = *((void *)this + 25);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    *((void *)this + 25)  = 0;
  }
  uint64_t v3 = (const void *)*((void *)this + 42);
  if (v3) {
    CFRelease(v3);
  }
  CFTypeRef v4 = (const void **)*((void *)this + 14);
  *((void *)this + 42)  = 0;
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(v4);
  *((void *)this + 13)  = (char *)this + 112;
  *((void *)this + 14)  = 0;
  *((void *)this + 15)  = 0;
  uint64_t v5 = (const void *)*((void *)this + 46);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = 0;
  *((void *)this + 46)  = 0;
  uint64_t v7 = (char *)this + 392;
  do
  {
    uint64_t v8 = *(const void **)&v7[v6];
    if (v8) {
      CFRelease(v8);
    }
    *(void *)&v7[v6]  = 0;
    v6 += 8;
  }
  while (v6 != 96);
  uint64_t v9 = (const void *)*((void *)this + 61);
  if (v9) {
    CFRelease(v9);
  }
  *((void *)this + 61)  = 0;
  CFIndex v10 = (const void *)*((void *)this + 62);
  if (v10) {
    CFRelease(v10);
  }
  *((void *)this + 62)  = 0;
  uint64_t v11 = (const void *)*((void *)this + 63);
  if (v11) {
    CFRelease(v11);
  }
  *((void *)this + 63)  = 0;
  *((void *)this + 64)  = 0;
  BOOL v12 = (const void *)*((void *)this + 65);
  if (v12) {
    CFRelease(v12);
  }
  *((void *)this + 65)  = 0;
  *((unsigned char *)this + 560)  = 0;
  char v13 = (const void *)*((void *)this + 77);
  if (v13) {
    CFRelease(v13);
  }
  *((void *)this + 77)  = 0;
  char v14 = (const void *)*((void *)this + 78);
  if (v14) {
    CFRelease(v14);
  }
  *((void *)this + 78)  = 0;
  *((_WORD *)this + 298)  = 0;
  *((void *)this + 75)  = 0x7FF8000000000000;
  (*(void (**)(void))(**((void **)this + 4) + 152))(*((void *)this + 4));
  unint64_t v15 = (const void *)*((void *)this + 69);
  if (v15) {
    CFRelease(v15);
  }
  *((void *)this + 69)  = 0;

  return CEReleaseManagedContext();
}

const UInt8 *Security::CodeSigning::SecStaticCode::validateNonResourceComponents(UInt8 *this)
{
  Security::CodeSigning::SecStaticCode::validateDirectory(this);
  uint64_t result = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)this, 1);
  unsigned int v3 = bswap32(*((_DWORD *)result + 6));
  if (v3 >= 0xB) {
    uint64_t v4 = 11;
  }
  else {
    uint64_t v4 = v3;
  }
  while (1)
  {
    if (v4 == 3) {
      goto LABEL_7;
    }
    if (!v4) {
      return result;
    }
    uint64_t result = (const UInt8 *)(*(uint64_t (**)(UInt8 *, uint64_t, uint64_t))(*(void *)this + 80))(this, v4, 4294900235);
LABEL_7:
    uint64_t v4 = (v4 - 1);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(unint64_t a1)
{
  if (a1 >> 62) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(4 * a1);
}

BOOL ___ZN8Security11CodeSigning13SecStaticCode18validateExecutableEv_block_invoke(uint64_t a1, unsigned int a2, Security::DynamicHash *a3)
{
  unsigned int v11 = a2;
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = std::__tree<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t **)(v5 + 104), a2, &v11);
  BytePtr  = CFDataGetBytePtr((CFDataRef)v6[5]);
  if ((*(unsigned char *)(v5 + 209) & 8) == 0)
  {
    unsigned int v8 = *((_DWORD *)BytePtr + 4);
LABEL_5:
    uint64_t v9 = &BytePtr[bswap32(v8) + *(int *)(a1 + 48) * (unint64_t)BytePtr[36]];
    goto LABEL_7;
  }
  if (bswap32(*((_DWORD *)BytePtr + 2)) >> 8 >= 0x205)
  {
    unsigned int v8 = *((_DWORD *)BytePtr + 23);
    if (v8) {
      goto LABEL_5;
    }
  }
  uint64_t v9 = 0;
LABEL_7:
  BOOL result = Security::DynamicHash::verify(a3, v9);
  if (!result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = 0;
  }
  return result;
}

uint64_t **std::__tree<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  uint64_t v7 = a1 + 1;
  unsigned int v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a2) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    void v12[2] = 0xAAAAAAAAAAAAAA01;
    CFIndex v10 = operator new(0x30uLL);
    v12[1]  = v6;
    void v10[8] = *a3;
    *((void *)v10 + 5)  = 0;
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(a1, (uint64_t)v8, v7, (uint64_t *)v10);
    v12[0]  = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)v12);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t Security::CodeSigning::SecStaticCode::resourceDictionary(Security::CodeSigning::SecStaticCode *this, int a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 63);
  if (!v2)
  {
    Dictionary  = (const __CFString *)Security::CodeSigning::SecStaticCode::getDictionary((UInt8 *)this, 3, a2);
    CFStringRef v9 = Dictionary;
    if (Dictionary && Security::cfscan(Dictionary, "{rules=%Dn,files=%Dn}", v5))
    {
      uint64_t v6 = secLogObjForScope("staticCode");
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = *((void *)this + 63);
        *(_DWORD *)long long buf = 134218240;
        unsigned int v11 = this;
        __int16 v12 = 2048;
        uint64_t v13 = v8;
        _os_log_debug_impl(&dword_18B299000, v6, OS_LOG_TYPE_DEBUG, "%p loaded ResourceDict %p", buf, 0x16u);
      }
      Security::CFRef<__CFData const*>::operator=((CFTypeRef *)this + 63, (CFTypeRef *)&v9);
      uint64_t v2 = *((void *)this + 63);
      Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v9);
    }
    else
    {
      Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v9);
      return 0;
    }
  }
  return v2;
}

void sub_18B3EF794(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

const void *Security::cfget<__CFDictionary const*>(const void *Value, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v14 = &a9;
  v15[0]  = a2;
  v15[1]  = &v14;
  _OWORD v15[2] = 0;
  int v16 = 0;
  char v17 = 0;
  while (Security::CFMunge::next((Security::CFMunge *)v15))
  {
    if (Security::CFMunge::next((Security::CFMunge *)v15) == 46) {
      ++v15[0];
    }
    if (!Value) {
      return 0;
    }
    CFTypeID v10 = CFGetTypeID(Value);
    if (v10 != CFDictionaryGetTypeID()) {
      return 0;
    }
    CFDataRef v11 = Security::CFMake::make((Security::CFMake *)v15);
    CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)Value, v11);
    CFRelease(v11);
  }
  if (!Value) {
    return 0;
  }
  CFTypeID v12 = CFGetTypeID(Value);
  if (v12 == CFDictionaryGetTypeID()) {
    return Value;
  }
  else {
    return 0;
  }
}

BOOL Security::CodeSigning::itemQualifiesForResourceExemption(char *a1, const char *a2)
{
  uint64_t v2 = a1;
  if (a1[23] < 0) {
    a1  = *(char **)a1;
  }
  if (Security::CodeSigning::isOnRootFilesystem((Security::CodeSigning *)a1, a2)) {
    return 1;
  }
  if (!os_variant_allows_internal_security_policies()) {
    return 0;
  }
  std::string::basic_string[abi:ne180100]<0>(v18, "/AppleInternal/");
  if (v2[23] < 0) {
    std::string::__init_copy_ctor_external(&__s, *(const std::string::value_type **)v2, *((void *)v2 + 1));
  }
  else {
    __s  = *(std::string *)v2;
  }
  if (Security::CodeSigning::isPathPrefix((char *)v18, &__s))
  {
    isPathPrefix  = 1;
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(v15, "/System/Volumes/Data/AppleInternal/");
    if (v2[23] < 0) {
      std::string::__init_copy_ctor_external(&v14, *(const std::string::value_type **)v2, *((void *)v2 + 1));
    }
    else {
      std::string v14 = *(std::string *)v2;
    }
    if (Security::CodeSigning::isPathPrefix((char *)v15, &v14))
    {
      isPathPrefix  = 1;
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(v12, "/System/AppleInternal/");
      if (v2[23] < 0) {
        std::string::__init_copy_ctor_external(&v11, *(const std::string::value_type **)v2, *((void *)v2 + 1));
      }
      else {
        std::string v11 = *(std::string *)v2;
      }
      if (Security::CodeSigning::isPathPrefix((char *)v12, &v11))
      {
        isPathPrefix  = 1;
      }
      else
      {
        std::string::basic_string[abi:ne180100]<0>(v9, "/usr/local/");
        if (v2[23] < 0) {
          std::string::__init_copy_ctor_external(&v8, *(const std::string::value_type **)v2, *((void *)v2 + 1));
        }
        else {
          std::string v8 = *(std::string *)v2;
        }
        if (Security::CodeSigning::isPathPrefix((char *)v9, &v8))
        {
          isPathPrefix  = 1;
        }
        else
        {
          std::string::basic_string[abi:ne180100]<0>(v6, "/usr/appleinternal/");
          if (v2[23] < 0) {
            std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v2, *((void *)v2 + 1));
          }
          else {
            std::string __p = *(std::string *)v2;
          }
          isPathPrefix  = Security::CodeSigning::isPathPrefix((char *)v6, &__p);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (v7 < 0) {
            operator delete(v6[0]);
          }
        }
        if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v8.__r_.__value_.__l.__data_);
        }
        if (v10 < 0) {
          operator delete(v9[0]);
        }
      }
      if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v11.__r_.__value_.__l.__data_);
      }
      if (v13 < 0) {
        operator delete(v12[0]);
      }
    }
    if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v14.__r_.__value_.__l.__data_);
    }
    if (v16 < 0) {
      operator delete(v15[0]);
    }
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
  if (v19 < 0) {
    operator delete(v18[0]);
  }
  return (isPathPrefix & 1) != 0;
}

void sub_18B3EFB00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  if (*(char *)(v44 - 89) < 0) {
    operator delete(*(void **)(v44 - 112));
  }
  if (*(char *)(v44 - 65) < 0) {
    operator delete(*(void **)(v44 - 88));
  }
  if (*(char *)(v44 - 41) < 0) {
    operator delete(*(void **)(v44 - 64));
  }
  if (*(char *)(v44 - 17) < 0) {
    operator delete(*(void **)(v44 - 40));
  }
  _Unwind_Resume(exception_object);
}

BOOL Security::CodeSigning::SecStaticCode::loadResources(Security::CodeSigning::SecStaticCode *this, const __CFDictionary **a2, const __CFDictionary **a3, unsigned int *a4)
{
  CFDictionaryRef v8 = (const __CFDictionary *)Security::CodeSigning::SecStaticCode::resourceDictionary(this, 1);
  uint64_t v9 = Security::CodeSigning::SecStaticCode::resourceBase(this);
  if (!v9)
  {
    if (!v8) {
      return v9 != 0;
    }
LABEL_17:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA10);
  }
  if (!v8) {
    goto LABEL_17;
  }
  CFStringRef Value = CFDictionaryGetValue(v8, @"files2");
  if (Value) {
    char v17 = "rules2";
  }
  else {
    char v17 = "rules";
  }
  if (Value) {
    char v18 = "files2";
  }
  else {
    char v18 = "files";
  }
  if (Value) {
    unsigned int v19 = 2;
  }
  else {
    unsigned int v19 = 1;
  }
  *a2  = (const __CFDictionary *)Security::cfget<__CFDictionary const*>(v8, (uint64_t)v17, v11, v12, v13, v14, v15, v16, v27);
  *a3  = (const __CFDictionary *)Security::cfget<__CFDictionary const*>(v8, (uint64_t)v18, v20, v21, v22, v23, v24, v25, v28);
  *a4  = v19;
  if (!*a2 || !*a3) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA11);
  }
  return v9 != 0;
}

uint64_t __Block_byref_object_copy__28(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40)  = *(void *)(a2 + 40);
  return result;
}

const void **__Block_byref_object_dispose__29(uint64_t a1)
{
  return Security::CFRef<__CFDictionary *>::~CFRef((const void **)(a1 + 40));
}

uint64_t Security::CodeSigning::SecStaticCode::resourceBase(Security::CodeSigning::SecStaticCode *this)
{
  if (!*((unsigned char *)this + 560))
  {
    memset(__p, 170, sizeof(__p));
    (*(void (**)(void **__return_ptr))(**((void **)this + 4) + 56))(__p);
    unsigned int v3 = (void *)HIBYTE(__p[2]);
    char v4 = HIBYTE(__p[2]);
    if (SHIBYTE(__p[2]) < 0) {
      unsigned int v3 = __p[1];
    }
    if (v3)
    {
      if (SHIBYTE(__p[2]) >= 0) {
        uint64_t v5 = __p;
      }
      else {
        uint64_t v5 = (void **)__p[0];
      }
      CFURLRef CFURL = Security::makeCFURL((Security *)v5, (const char *)1, 0, v2);
      char v7 = (const void *)*((void *)this + 71);
      if (v7) {
        CFRelease(v7);
      }
      *((void *)this + 71)  = CFURL;
      char v4 = HIBYTE(__p[2]);
    }
    *((unsigned char *)this + 560)  = 1;
    if (v4 < 0) {
      operator delete(__p[0]);
    }
  }
  return *((void *)this + 71);
}

void sub_18B3EFDD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke(uint64_t a1, uint64_t a2, char a3, char *a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  char v7 = *(Security::CodeSigning::SecStaticCode **)(a1 + 32);
  unsigned int v8 = a3 & 0x40;
  uint64_t v9 = secLogObjForScope("staticCode");
  if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    if (!v8) {
      return;
    }
LABEL_3:
    CFTypeRef cf = 0;
    int v10 = *(unsigned __int16 *)(a2 + 88);
    if (v10 != 8)
    {
      if (v10 == 12)
      {
        memset(__b, 170, 0x400uLL);
        if (realpath_DARWIN_EXTSN(*(const char **)(a2 + 48), (char *)__b))
        {
          CFTypeRef cf = Security::makeCFURL((Security *)__b, 0, 0, v11);
          uint64_t v12 = secLogObjForScope("staticCode");
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 136315138;
            long long v30 = __b;
            _os_log_debug_impl(&dword_18B299000, v12, OS_LOG_TYPE_DEBUG, "Checking symlink target: %s", buf, 0xCu);
          }
          CFURLRef CFURL = (void *)cf;
LABEL_13:
          CFTypeRef cf = 0;
          v26[0]  = MEMORY[0x1E4F143A8];
          v26[1]  = 0x40000000;
          v26[2]  = ___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke_31;
          void v26[3] = &__block_descriptor_tmp_32_17427;
          void v26[4] = v7;
          v26[5]  = CFURL;
          int v27 = *(_DWORD *)(a1 + 48);
          Security::CodeSigning::LimitedAsync::perform(*(void *)(*((void *)v7 + 73) + 8), *(void *)(a1 + 40), (uint64_t)v26);
LABEL_21:
          Security::CFRef<__CFURL const*>::~CFRef(&cf);
          return;
        }
        uint64_t v23 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_21;
        }
        int v24 = *__error();
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v30)  = v24;
        unsigned int v19 = "realpath failed checking symlink: %d";
        uint64_t v20 = buf;
        uint64_t v21 = v23;
        uint32_t v22 = 8;
      }
      else
      {
        char v17 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_21;
        }
        int v18 = *(unsigned __int16 *)(a2 + 88);
        if (a4[23] < 0) {
          a4  = *(char **)a4;
        }
        __b[0]  = 67109378;
        __b[1]  = v18;
        LOWORD(__b[2])  = 2080;
        *(void *)((char *)&__b[2] + 2)  = a4;
        unsigned int v19 = "Unexpected scan input: %d, %s";
        uint64_t v20 = (uint8_t *)__b;
        uint64_t v21 = v17;
        uint32_t v22 = 18;
      }
      _os_log_impl(&dword_18B299000, v21, OS_LOG_TYPE_DEFAULT, v19, v20, v22);
      goto LABEL_21;
    }
    uint64_t v14 = Security::CodeSigning::SecStaticCode::resourceBase(v7);
    if (a4[23] >= 0) {
      uint64_t v16 = (Security *)a4;
    }
    else {
      uint64_t v16 = *(Security **)a4;
    }
    CFURLRef CFURL = Security::makeCFURL(v16, 0, v14, v15);
    goto LABEL_13;
  }
  uint64_t v25 = a4;
  if (a4[23] < 0) {
    uint64_t v25 = *(char **)a4;
  }
  __b[0]  = 67109378;
  __b[1]  = v8 >> 6;
  LOWORD(__b[2])  = 2080;
  *(void *)((char *)&__b[2] + 2)  = v25;
  _os_log_debug_impl(&dword_18B299000, v9, OS_LOG_TYPE_DEBUG, "Visiting unhandled file: %d, %s", (uint8_t *)__b, 0x12u);
  if (v8) {
    goto LABEL_3;
  }
}

void sub_18B3F010C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

void ___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 40);
  unsigned int v8 = *(__CFDictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  if (*(char *)(a4 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v18, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
  }
  else {
    std::string v18 = *(std::string *)a4;
  }
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)&v19, (char *)&v18);
  CFDictionaryRemoveValue(v8, v19);
  Security::CFRef<__CFString const*>::~CFRef(&v19);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  BOOL v9 = *(unsigned __int16 *)(a2 + 88) == 12;
  v11[0]  = MEMORY[0x1E4F143A8];
  v11[1]  = 1174405120;
  void v11[2] = ___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke_3;
  void v11[3] = &__block_descriptor_tmp_36_17371;
  void v11[4] = v7;
  char v15 = *(unsigned char *)(a1 + 72);
  if (*(char *)(a4 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
  }
  else {
    std::string __p = *(std::string *)a4;
  }
  char v16 = *(unsigned char *)(a1 + 73);
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v13 = *(void *)(a1 + 48);
  BOOL v17 = v9;
  uint64_t v14 = *(void *)(a1 + 64);
  Security::CodeSigning::LimitedAsync::perform(*(void *)(*(void *)(v7 + 584) + 8), v10, (uint64_t)v11);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_18B3F028C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **Security::CodeSigning::SecStaticCode::checkOptionalResource(const __CFString *this, const void *a2, Security::CodeSigning::SecStaticCode **a3, void *a4)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v15 = v6;
  long long v16 = v6;
  Security::CodeSigning::ResourceSeal::ResourceSeal((Security::CodeSigning::ResourceSeal *)&v15, a2);
  if ((BYTE8(v16) & 1) == 0)
  {
    if (this && (CFTypeID v7 = CFGetTypeID(this), v7 == CFStringGetTypeID()))
    {
      uint64_t v8 = Security::CodeSigning::SecStaticCode::resourceBase(a3[1]);
      if (v8) {
        CFURLRef v9 = (CFURLRef)MEMORY[0x18C12CDE0](0, this, 0, 0, v8);
      }
      else {
        CFURLRef v9 = CFURLCreateWithFileSystemPath(0, this, kCFURLPOSIXPathStyle, 0);
      }
      CFURLRef v14 = v9;
      if (v9) {
        uint64_t v10 = 4294900242;
      }
      else {
        uint64_t v10 = 4294900238;
      }
      if (v9) {
        CFStringRef v11 = (const __CFString *)v9;
      }
      else {
        CFStringRef v11 = this;
      }
      if (v9) {
        uint64_t v12 = @"SecCSResourceMissing";
      }
      else {
        uint64_t v12 = @"SecCSResourceSeal";
      }
      (*((void (**)(Security::CodeSigning::SecStaticCode **, uint64_t, __CFString *, const __CFString *))*a3
       + 2))(a3, v10, v12, v11);
      Security::CFRef<__CFURL const*>::~CFRef((const void **)&v14);
    }
    else
    {
      (*((void (**)(Security::CodeSigning::SecStaticCode **, uint64_t, __CFString *, const __CFString *))*a3
       + 2))(a3, 4294900242, @"SecCSResourceSeal", this);
    }
  }
  return Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v15);
}

void sub_18B3F0448(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  unsigned int v3 = va_arg(va1, const void *);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)va);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)va1);
  _Unwind_Resume(a1);
}

void ___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke_3(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  CFURLRef v2 = *(Security::CodeSigning::SecStaticCode **)(a1 + 32);
  if (!*(unsigned char *)(a1 + 80)) {
    goto LABEL_17;
  }
  CFURLRef v3 = (const __CFURL *)Security::CodeSigning::SecStaticCode::resourceBase(*(Security::CodeSigning::SecStaticCode **)(a1 + 32));
  Security::cfString((Security *)&v27, v3);
  char v4 = std::string::append(&v27, "/", 1uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v28.__r_.__value_.__r.__words[2]  = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v28.__r_.__value_.__l.__data_  = v5;
  v4->__r_.__value_.__l.__size_  = 0;
  v4->__r_.__value_.__r.__words[2]  = 0;
  v4->__r_.__value_.__r.__words[0]  = 0;
  long long v6 = (void *)(a1 + 40);
  int v7 = *(char *)(a1 + 63);
  if (v7 >= 0) {
    uint64_t v8 = (const std::string::value_type *)(a1 + 40);
  }
  else {
    uint64_t v8 = *(const std::string::value_type **)(a1 + 40);
  }
  if (v7 >= 0) {
    std::string::size_type v9 = *(unsigned __int8 *)(a1 + 63);
  }
  else {
    std::string::size_type v9 = *(void *)(a1 + 48);
  }
  uint64_t v10 = std::string::append(&v28, v8, v9);
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  std::string::size_type v26 = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v11;
  v10->__r_.__value_.__l.__size_  = 0;
  v10->__r_.__value_.__r.__words[2]  = 0;
  v10->__r_.__value_.__r.__words[0]  = 0;
  int IsValidXattrFile = Security::CodeSigning::pathIsValidXattrFile((char *)__p, "staticCode");
  if (SHIBYTE(v26) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v27.__r_.__value_.__l.__data_);
    if (IsValidXattrFile) {
      goto LABEL_14;
    }
LABEL_17:
    int v14 = 1;
    goto LABEL_18;
  }
  if (!IsValidXattrFile) {
    goto LABEL_17;
  }
LABEL_14:
  uint64_t v13 = secLogObjForScope("staticCode");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    if (*(char *)(a1 + 63) < 0) {
      long long v6 = (void *)*v6;
    }
    LODWORD(v28.__r_.__value_.__l.__data_)  = 136315138;
    *(std::string::size_type *)((char *)v28.__r_.__value_.__r.__words + 4)  = (std::string::size_type)v6;
    _os_log_debug_impl(&dword_18B299000, v13, OS_LOG_TYPE_DEBUG, "resource validation on xattr file skipped: %s", (uint8_t *)&v28, 0xCu);
  }
  int v14 = 0;
LABEL_18:
  if (!*(unsigned char *)(a1 + 81))
  {
    if (!v14) {
      goto LABEL_36;
    }
    goto LABEL_30;
  }
  uint64_t v15 = Security::CodeSigning::SecStaticCode::resourceBase(v2);
  if (*(char *)(a1 + 63) >= 0) {
    BOOL v17 = (Security *)(a1 + 40);
  }
  else {
    BOOL v17 = *(Security **)(a1 + 40);
  }
  CFURLRef CFURL = Security::makeCFURL(v17, 0, v15, v16);
  memset(&v28, 170, sizeof(v28));
  Security::cfString((Security *)&v28, CFURL);
  if (Security::CodeSigning::itemQualifiesForResourceExemption((char *)&v28, v18))
  {
    unsigned int v19 = secLogObjForScope("staticCode");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      uint32_t v22 = &v28;
      if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint32_t v22 = (std::string *)v28.__r_.__value_.__r.__words[0];
      }
      LODWORD(v27.__r_.__value_.__l.__data_)  = 136315138;
      *(std::string::size_type *)((char *)v27.__r_.__value_.__r.__words + 4)  = (std::string::size_type)v22;
      _os_log_debug_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEBUG, "resource validation on root volume skipped: %s", (uint8_t *)&v27, 0xCu);
    }
    LOBYTE(v14)  = 0;
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&CFURL);
  if (v14)
  {
LABEL_30:
    uint64_t v20 = secLogObjForScope("staticCode");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v21 = (void *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0) {
        uint64_t v21 = (void *)*v21;
      }
      LODWORD(v28.__r_.__value_.__l.__data_)  = 136315138;
      *(std::string::size_type *)((char *)v28.__r_.__value_.__r.__words + 4)  = (std::string::size_type)v21;
      _os_log_debug_impl(&dword_18B299000, v20, OS_LOG_TYPE_DEBUG, "performing resource validation on item: %s", (uint8_t *)&v28, 0xCu);
    }
    if (*(char *)(a1 + 63) < 0) {
      std::string::__init_copy_ctor_external(&v23, *(const std::string::value_type **)(a1 + 40), *(void *)(a1 + 48));
    }
    else {
      std::string v23 = *(std::string *)(a1 + 40);
    }
    Security::CodeSigning::SecStaticCode::validateResource((uint64_t)v2);
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v23.__r_.__value_.__l.__data_);
    }
  }
LABEL_36:
  Security::CodeSigning::SecStaticCode::reportProgress(v2);
}

void sub_18B3F07C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
}

void __copy_helper_block_e8_40c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  CFURLRef v2 = (std::string *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v3 = *(_OWORD *)(a2 + 40);
    v2->__r_.__value_.__r.__words[2]  = *(void *)(a2 + 56);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_  = v3;
  }
}

const void **Security::CodeSigning::SecStaticCode::validateResource(uint64_t a1)
{
  uint64_t v1 = (Security::CodeSigning::SecStaticCode *)MEMORY[0x1F4188790](a1);
  unsigned int v3 = v2;
  __int16 v5 = v4;
  uint64_t v7 = v6;
  int v9 = v8;
  std::string::size_type v11 = v10;
  CFDictionaryRef v13 = v12;
  uint64_t v14 = (uint64_t)v1;
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  if (!Security::CodeSigning::SecStaticCode::resourceBase(v1)) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA10);
  }
  uint64_t v15 = Security::CodeSigning::SecStaticCode::resourceBase((Security::CodeSigning::SecStaticCode *)v14);
  if (*(char *)(v11 + 23) >= 0) {
    BOOL v17 = (std::string::value_type *)v11;
  }
  else {
    BOOL v17 = *(std::string::value_type **)v11;
  }
  CFURLRef CFURL = Security::makeCFURL((Security *)v17, 0, v15, v16);
  v113[0]  = CFURL;
  if (v3 >= 2 && (v5 & 0x210) == 0x210)
  {
    __b[0].__r_.__value_.__r.__words[0]  = 0xAAAAAAAAFFFFFFFFLL;
    Security::cfString((Security *)__p, CFURL);
    if (SHIBYTE(__p[2]) >= 0) {
      unsigned int v19 = __p;
    }
    else {
      unsigned int v19 = (void **)__p[0];
    }
    Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)__b, (const char *)v19, 0, 438);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    data_low  = (Security::UnixPlusPlus::FileDesc *)LODWORD(__b[0].__r_.__value_.__l.__data_);
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute((Security::UnixPlusPlus::FileDesc *)LODWORD(__b[0].__r_.__value_.__l.__data_), "com.apple.ResourceFork"))
    {
      Security::cfString((Security *)__p, v113[0]);
      if (SHIBYTE(__p[2]) >= 0) {
        uint64_t v21 = __p;
      }
      else {
        uint64_t v21 = (void **)__p[0];
      }
      CFStringRef v22 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Disallowed xattr %s found on %s", "com.apple.ResourceFork", v21);
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      (*(void (**)(uint64_t, uint64_t, __CFString *, CFStringRef))(*(void *)v7 + 16))(v7, 4294900297, @"SecCSResourceHasSidebandData", v22);
    }
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute(data_low, "com.apple.FinderInfo"))
    {
      Security::cfString((Security *)__p, v113[0]);
      if (SHIBYTE(__p[2]) >= 0) {
        std::string v23 = __p;
      }
      else {
        std::string v23 = (void **)__p[0];
      }
      CFStringRef v24 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Disallowed xattr %s found on %s", "com.apple.FinderInfo", v23);
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      (*(void (**)(uint64_t, uint64_t, __CFString *, CFStringRef))(*(void *)v7 + 16))(v7, 4294900297, @"SecCSResourceHasSidebandData", v24);
    }
    Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)__b);
  }
  (*(void (**)(void **__return_ptr))(**(void **)(v14 + 32) + 40))(__p);
  Security::cfString((Security *)__b, v113[0]);
  char v25 = HIBYTE(__p[2]);
  if (SHIBYTE(__p[2]) >= 0) {
    std::string::size_type v26 = (void *)HIBYTE(__p[2]);
  }
  else {
    std::string::size_type v26 = __p[1];
  }
  std::string::size_type size = HIBYTE(__b[0].__r_.__value_.__r.__words[2]);
  int v28 = SHIBYTE(__b[0].__r_.__value_.__r.__words[2]);
  if ((__b[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __b[0].__r_.__value_.__l.__size_;
  }
  if (v26 == (void *)size)
  {
    if ((__b[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v29 = __b;
    }
    else {
      uint64_t v29 = (std::string *)__b[0].__r_.__value_.__r.__words[0];
    }
    if (SHIBYTE(__p[2]) < 0)
    {
      BOOL v38 = memcmp(__p[0], v29, (size_t)__p[1]) == 0;
      if ((v28 & 0x80000000) == 0) {
        goto LABEL_45;
      }
    }
    else if (HIBYTE(__p[2]))
    {
      uint64_t v30 = HIBYTE(__p[2]) - 1;
      long long v31 = __p;
      do
      {
        int v33 = *(unsigned __int8 *)v31;
        long long v31 = (void **)((char *)v31 + 1);
        int v32 = v33;
        int v35 = v29->__r_.__value_.__s.__data_[0];
        uint64_t v29 = (std::string *)((char *)v29 + 1);
        int v34 = v35;
        BOOL v37 = v30-- != 0;
        BOOL v38 = v32 == v34;
      }
      while (v32 == v34 && v37);
      if ((SHIBYTE(__b[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_45:
        if ((v25 & 0x80) == 0) {
          goto LABEL_46;
        }
LABEL_50:
        operator delete(__p[0]);
        if (v38) {
          goto LABEL_47;
        }
        goto LABEL_51;
      }
    }
    else
    {
      BOOL v38 = 1;
      if ((SHIBYTE(__b[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_45;
      }
    }
  }
  else
  {
    BOOL v38 = 0;
    if ((SHIBYTE(__b[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_45;
    }
  }
  operator delete(__b[0].__r_.__value_.__l.__data_);
  if ((HIBYTE(__p[2]) & 0x80) != 0) {
    goto LABEL_50;
  }
LABEL_46:
  if (v38)
  {
LABEL_47:
    (*(void (**)(uint64_t, uint64_t, __CFString *, __CFURL *))(*(void *)v7 + 16))(v7, 4294900242, @"SecCSResourceRecursive", v113[0]);
    return Security::CFRef<__CFURL const*>::~CFRef((const void **)v113);
  }
LABEL_51:
  if (*(char *)(v11 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v112, *(const std::string::value_type **)v11, *(void *)(v11 + 8));
  }
  else {
    std::string v112 = *(std::string *)v11;
  }
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)__p, (char *)&v112);
  CFStringRef Value = CFDictionaryGetValue(v13, __p[0]);
  Security::CFRef<__CFString const*>::~CFRef((const void **)__p);
  if ((SHIBYTE(v112.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (Value) {
      goto LABEL_58;
    }
LABEL_73:
    if (v3 != 2)
    {
      if (v3 == 1)
      {
        memset(__p, 170, 0x400uLL);
        Security::cfString((Security *)__b, v113[0]);
        if ((__b[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          CFTypeID v47 = __b;
        }
        else {
          CFTypeID v47 = (std::string *)__b[0].__r_.__value_.__r.__words[0];
        }
        ssize_t v48 = readlink((const char *)v47, (char *)__p, 0x400uLL);
        if (SHIBYTE(__b[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__b[0].__r_.__value_.__l.__data_);
        }
        if (v48 >= 1) {
          return Security::CFRef<__CFURL const*>::~CFRef((const void **)v113);
        }
      }
LABEL_129:
      if (*(char *)(v11 + 23) < 0) {
        std::string::__init_copy_ctor_external(&v100, *(const std::string::value_type **)v11, *(void *)(v11 + 8));
      }
      else {
        std::string v100 = *(std::string *)v11;
      }
      uint64_t v64 = Security::CodeSigning::SecStaticCode::resourceBase((Security::CodeSigning::SecStaticCode *)v14);
      if ((v100.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        char v66 = &v100;
      }
      else {
        char v66 = (std::string *)v100.__r_.__value_.__r.__words[0];
      }
      __p[0]  = Security::makeCFURL((Security *)v66, 0, v64, v65);
      (*(void (**)(uint64_t, uint64_t, __CFString *, void *))(*(void *)v7 + 16))(v7, 4294900242, @"SecCSResourceAdded", __p[0]);
      Security::CFRef<__CFURL const*>::~CFRef((const void **)__p);
      if (SHIBYTE(v100.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v100.__r_.__value_.__l.__data_);
      }
      return Security::CFRef<__CFURL const*>::~CFRef((const void **)v113);
    }
    if (*(char *)(v11 + 23) < 0) {
      std::string::__init_copy_ctor_external(&v101, *(const std::string::value_type **)v11, *(void *)(v11 + 8));
    }
    else {
      std::string v101 = *(std::string *)v11;
    }
    int v61 = Security::CodeSigning::SecStaticCode::checkfix30814861(v14, (const std::string::value_type *)&v101, 1);
    char v62 = v61;
    if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v101.__r_.__value_.__l.__data_);
      if ((v62 & 1) == 0) {
        goto LABEL_129;
      }
    }
    else if (!v61)
    {
      goto LABEL_129;
    }
    size_t v63 = secLogObjForScope("validateResource");
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(v11 + 23) < 0) {
        std::string::size_type v11 = *(void *)v11;
      }
      LODWORD(__p[0])  = 136315138;
      *(void **)((char *)__p + 4)  = (void *)v11;
      _os_log_debug_impl(&dword_18B299000, v63, OS_LOG_TYPE_DEBUG, "%s check-fixed (added).", (uint8_t *)__p, 0xCu);
    }
    return Security::CFRef<__CFURL const*>::~CFRef((const void **)v113);
  }
  operator delete(v112.__r_.__value_.__l.__data_);
  if (!Value) {
    goto LABEL_73;
  }
LABEL_58:
  *(void *)&long long v40 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v40 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)text  = v40;
  *(_OWORD *)theString  = v40;
  Security::CodeSigning::ResourceSeal::ResourceSeal((Security::CodeSigning::ResourceSeal *)text, Value);
  if (((uint64_t)theString[1] & 4) != 0)
  {
    if (v9) {
      goto LABEL_83;
    }
    memset(v109, 170, sizeof(v109));
    std::string::basic_string[abi:ne180100]<0>(v109, ".framework");
    if (*(char *)(v11 + 23) < 0)
    {
      size_t v55 = *(void *)(v11 + 8);
      BOOL v50 = v109[2] < 0;
      if (v109[2] >= 0) {
        size_t v51 = HIBYTE(v109[2]);
      }
      else {
        size_t v51 = v109[1];
      }
      BOOL v96 = v55 > v51;
      size_t v52 = v55 - v51;
      if (!v96)
      {
LABEL_116:
        CFURLRef v57 = v113[0];
        requirement  = 0;
        if (!SecRequirementCreateWithStringAndErrors(text[1], 0, 0, &requirement))
        {
          v113[1]  = (__CFURL *)0xAAAAAAAAAAAAAAAALL;
          uint64_t v58 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
          Security::SecCFObject::allocate((Security::SecCFObject *)0x288, *(void *)(v58 + 200), v59);
          Security::cfString((Security *)__p, v57);
          if (SHIBYTE(__p[2]) >= 0) {
            CFTypeID v60 = (char *)__p;
          }
          else {
            CFTypeID v60 = (char *)__p[0];
          }
          Security::CodeSigning::DiskRep::bestGuess(v60, 0);
        }
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA11);
      }
      std::string::size_type v11 = *(void *)v11;
    }
    else
    {
      size_t v49 = *(unsigned __int8 *)(v11 + 23);
      BOOL v50 = v109[2] < 0;
      if (v109[2] >= 0) {
        size_t v51 = HIBYTE(v109[2]);
      }
      else {
        size_t v51 = v109[1];
      }
      BOOL v96 = v49 > v51;
      size_t v52 = v49 - v51;
      if (!v96) {
        goto LABEL_116;
      }
    }
    if (v50) {
      CFTypeRef v56 = (void *)v109[0];
    }
    else {
      CFTypeRef v56 = v109;
    }
    memcmp((const void *)(v11 + v52), v56, v51);
    goto LABEL_116;
  }
  if (!theString[0])
  {
    size_t v53 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v14, 1);
    if (!Security::CodeSigning::ResourceSeal::hash((CFDictionaryRef *)text, v53[37]) || (v9 & 1) != 0) {
      goto LABEL_83;
    }
    v117[0]  = (void *)0xAAAAAAAAFFFFFFFFLL;
    Security::cfString((Security *)__p, v113[0]);
    if (SHIBYTE(__p[2]) >= 0) {
      unint64_t v54 = __p;
    }
    else {
      unint64_t v54 = (void **)__p[0];
    }
    Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)v117, (const char *)v54, 0, 4096);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    if (LODWORD(v117[0]) == -1)
    {
      if ((uint64_t)theString[1])
      {
        Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)v117);
        goto LABEL_219;
      }
      (*(void (**)(uint64_t, uint64_t, __CFString *, __CFURL *))(*(void *)v7 + 16))(v7, 4294900242, @"SecCSResourceMissing", v113[0]);
      goto LABEL_193;
    }
    __p[0]  = 0;
    __p[1]  = __p;
    __p[2]  = (void *)0x2000000000;
    LOBYTE(__p[3])  = 1;
    int v105 = (int)v117[0];
    char v106 = BYTE4(v117[0]);
    std::set<unsigned int>::set[abi:ne180100]((uint64_t)v104, (void *)(v14 + 344));
    v103[0]  = MEMORY[0x1E4F143A8];
    v103[1]  = 0x40000000;
    v103[2]  = ___ZN8Security11CodeSigning13SecStaticCode16validateResourceEPK14__CFDictionaryNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEEbRNS1_17ValidationContextEjj_block_invoke;
    v103[3]  = &unk_1E5485538;
    v103[4]  = __p;
    v103[5]  = text;
    Security::CodeSigning::CodeDirectory::multipleHashFileData((uint64_t)&v105, 0, v104, (uint64_t)v103);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((void *)v104[1]);
    if (!*((unsigned char *)__p[1] + 24))
    {
      if (v3 == 2)
      {
        if (*(char *)(v11 + 23) < 0) {
          std::string::__init_copy_ctor_external(&v102, *(const std::string::value_type **)v11, *(void *)(v11 + 8));
        }
        else {
          std::string v102 = *(std::string *)v11;
        }
        int v85 = Security::CodeSigning::SecStaticCode::checkfix30814861(v14, (const std::string::value_type *)&v102, 0);
        char v86 = v85;
        if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v102.__r_.__value_.__l.__data_);
          if (v86)
          {
LABEL_186:
            long long v87 = secLogObjForScope("validateResource");
            if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
            {
              if (*(char *)(v11 + 23) < 0) {
                std::string::size_type v11 = *(void *)v11;
              }
              LODWORD(__b[0].__r_.__value_.__l.__data_)  = 136315138;
              *(std::string::size_type *)((char *)__b[0].__r_.__value_.__r.__words + 4)  = v11;
              _os_log_debug_impl(&dword_18B299000, v87, OS_LOG_TYPE_DEBUG, "%s check-fixed (altered).", (uint8_t *)__b, 0xCu);
            }
            goto LABEL_192;
          }
        }
        else if (v85)
        {
          goto LABEL_186;
        }
      }
      (*(void (**)(uint64_t, uint64_t, __CFString *, __CFURL *))(*(void *)v7 + 16))(v7, 4294900242, @"SecCSResourceAltered", v113[0]);
    }
LABEL_192:
    _Block_object_dispose(__p, 8);
LABEL_193:
    Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)v117);
    goto LABEL_219;
  }
  if (!v9)
  {
LABEL_83:
    (*(void (**)(uint64_t, uint64_t, __CFString *, __CFURL *))(*(void *)v7 + 16))(v7, 4294900242, @"SecCSResourceAltered", v113[0]);
    goto LABEL_219;
  }
  Security::cfString((Security *)&__str, v113[0]);
  Security::cfString(&v107, theString[0]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_str  = &__str;
  }
  else {
    p_str  = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  memset(__p, 170, 0x400uLL);
  ssize_t v42 = readlink((const char *)p_str, (char *)__p, 0x3FFuLL);
  if (v42 < 0)
  {
    long long v99 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v99);
  }
  *((unsigned char *)__p + v42)  = 0;
  memset(v117, 170, 24);
  std::string::basic_string[abi:ne180100]<0>(v117, (char *)__p);
  if (LOBYTE(__p[0]) != 47)
  {
    std::string::size_type v43 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    uint64_t v44 = &__str;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    {
      std::string::size_type v43 = __str.__r_.__value_.__l.__size_;
      uint64_t v44 = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    if (v43)
    {
      while (v43)
      {
        int v45 = v44->__r_.__value_.__s.__data_[--v43];
        if (v45 == 47)
        {
          std::string::size_type v46 = v43;
          goto LABEL_138;
        }
      }
    }
    std::string::size_type v46 = -1;
LABEL_138:
    std::string::basic_string(&v115, &__str, 0, v46, (std::allocator<char> *)&v116);
    std::string::push_back(&v115, 47);
    __b[0]  = v115;
    memset(&v115, 0, sizeof(v115));
    std::string::size_type v67 = strlen((const char *)__p);
    BOOL v68 = std::string::append(__b, (const std::string::value_type *)__p, v67);
    uint64_t v69 = (void *)v68->__r_.__value_.__r.__words[0];
    v118.__r_.__value_.__r.__words[0]  = v68->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v118.__r_.__value_.__r.__words + 7)  = *(std::string::size_type *)((char *)&v68->__r_.__value_.__r.__words[1] + 7);
    char v70 = HIBYTE(v68->__r_.__value_.__r.__words[2]);
    v68->__r_.__value_.__l.__size_  = 0;
    v68->__r_.__value_.__r.__words[2]  = 0;
    v68->__r_.__value_.__r.__words[0]  = 0;
    if (SHIBYTE(v117[2]) < 0) {
      operator delete(v117[0]);
    }
    v117[0]  = v69;
    v117[1]  = v118.__r_.__value_.__l.__data_;
    *(void **)((char *)&v117[1] + 7)  = *(void **)((char *)v118.__r_.__value_.__r.__words + 7);
    HIBYTE(v117[2])  = v70;
    if (SHIBYTE(__b[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__b[0].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v115.__r_.__value_.__l.__data_);
    }
  }
  if ((v107.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v71 = HIBYTE(v107.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v71 = v107.__r_.__value_.__l.__size_;
  }
  if (v71 != strlen((const char *)__p)
    || ((v107.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? (uint64_t v72 = &v107)
      : (uint64_t v72 = (std::string *)v107.__r_.__value_.__r.__words[0]),
        memcmp(v72, __p, v71)))
  {
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(__b, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
    }
    else {
      __b[0]  = __str;
    }
    Security::CFTempString::CFTempString<std::string>((CFStringRef *)&v115, (char *)__b);
    (*(void (**)(uint64_t, uint64_t, __CFString *, std::string::size_type))(*(void *)v7 + 16))(v7, 4294900242, @"SecCSResourceAltered", v115.__r_.__value_.__r.__words[0]);
    Security::CFRef<__CFString const*>::~CFRef((const void **)&v115.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__b[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_213;
    }
    uint64_t v73 = (void *)__b[0].__r_.__value_.__r.__words[0];
    goto LABEL_157;
  }
  if ((~*(_DWORD *)(v14 + 208) & 0x90) != 0) {
    goto LABEL_213;
  }
  memset(__b, 170, 0x400uLL);
  if (SHIBYTE(v117[2]) >= 0) {
    unint64_t v74 = v117;
  }
  else {
    unint64_t v74 = (void **)v117[0];
  }
  if (!realpath_DARWIN_EXTSN((const char *)v74, (char *)__b)) {
    goto LABEL_199;
  }
  size_t v75 = strlen((const char *)__b);
  if (LOBYTE(__p[0]) == 47)
  {
    size_t v76 = v75;
    uint64_t v77 = "/System/";
    unsigned int v78 = &off_1E5485568;
    while (1)
    {
      size_t v79 = strlen(v77);
      if (v76 > v79 && !strncmp((const char *)__b, v77, v79)) {
        goto LABEL_213;
      }
      uint64_t v80 = *v78++;
      uint64_t v77 = v80;
      if (!v80) {
        goto LABEL_199;
      }
    }
  }
  uint64_t v81 = v14;
  while (1)
  {
    memset(&v115, 170, sizeof(v115));
    uint64_t v82 = *(void *)(v81 + 328);
    if (*(char *)(v82 + 23) < 0) {
      std::string::__init_copy_ctor_external(&v115, *(const std::string::value_type **)v82, *(void *)(v82 + 8));
    }
    else {
      std::string v115 = *(std::string *)v82;
    }
    std::string::size_type v83 = HIBYTE(v115.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      break;
    }
    std::string::size_type v88 = v115.__r_.__value_.__l.__size_;
    long long v84 = (void *)v115.__r_.__value_.__r.__words[0];
    if (!strncmp((const char *)__b, v115.__r_.__value_.__l.__data_, v115.__r_.__value_.__l.__size_)) {
      goto LABEL_194;
    }
    operator delete(v84);
LABEL_181:
    uint64_t v81 = *(void *)(v81 + 320);
    if (!v81) {
      goto LABEL_199;
    }
  }
  if (strncmp((const char *)__b, (const char *)&v115, HIBYTE(v115.__r_.__value_.__r.__words[2]))) {
    goto LABEL_181;
  }
  std::string::size_type v88 = v83;
LABEL_194:
  uint64_t v89 = *(void *)(v81 + 328);
  std::string::basic_string[abi:ne180100]<0>(&v118, (char *)&__b[0].__r_.__value_.__l.__data_ + v88 + 1);
  char v90 = Security::CodeSigning::ResourceBuilder::includes(v89, &v118);
  if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v118.__r_.__value_.__l.__data_);
  }
  if ((v83 & 0x80) != 0) {
    operator delete(v115.__r_.__value_.__l.__data_);
  }
  if ((v90 & 1) == 0)
  {
LABEL_199:
    uint64_t v93 = *(void *)(v14 + 152);
    uint64_t v92 = v14 + 152;
    uint64_t v91 = v93;
    if (v93)
    {
      uint64_t v94 = v92;
      do
      {
        int v95 = *(_DWORD *)(v91 + 28);
        BOOL v96 = v95 < -67003;
        if (v95 >= -67003) {
          CFDataRef v97 = (uint64_t *)v91;
        }
        else {
          CFDataRef v97 = (uint64_t *)(v91 + 8);
        }
        if (!v96) {
          uint64_t v94 = v91;
        }
        uint64_t v91 = *v97;
      }
      while (*v97);
      if (v94 != v92 && *(int *)(v94 + 28) <= -67003) {
        goto LABEL_213;
      }
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v115, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
    }
    else {
      std::string v115 = __str;
    }
    Security::CFTempString::CFTempString<std::string>((CFStringRef *)&v116, (char *)&v115);
    (*(void (**)(uint64_t, uint64_t, __CFString *, void *))(*(void *)v7 + 16))(v7, 4294900293, @"SecCSResourceAltered", v116);
    Security::CFRef<__CFString const*>::~CFRef((const void **)&v116);
    if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_213;
    }
    uint64_t v73 = (void *)v115.__r_.__value_.__r.__words[0];
LABEL_157:
    operator delete(v73);
  }
LABEL_213:
  if (SHIBYTE(v117[2]) < 0) {
    operator delete(v117[0]);
  }
  if (SHIBYTE(v107.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v107.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
LABEL_219:
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)text);
  return Security::CFRef<__CFURL const*>::~CFRef((const void **)v113);
}

void sub_18B3F1D4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, __CFString *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,void *a50,uint64_t a51,uint64_t a52,const void *a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *a63)
{
  if (SLOBYTE(STACK[0x6E7]) < 0) {
    operator delete((void *)STACK[0x6D0]);
  }
  if (v69 < 0) {
    operator delete(a69);
  }
  if (SLOBYTE(STACK[0x2E7]) < 0) {
    operator delete((void *)STACK[0x2D0]);
  }
  if (a43 < 0) {
    operator delete(a38);
  }
  if (a49 < 0) {
    operator delete(a44);
  }
  Security::CFRef<__CFDictionary const*>::~CFRef(&a53);
  JUMPOUT(0x18B3F22A4);
}

void sub_18B3F2040()
{
  Security::SecCFObject::operator delete(v0);
  std::ostringstream::~ostringstream((uint64_t)&STACK[0x6D0]);
  Security::CodeSigning::DirScanner::~DirScanner((Security::CodeSigning::DirScanner *)&STACK[0x7E0]);
  JUMPOUT(0x18B3F20E0);
}

void sub_18B3F2054()
{
  if (SLOBYTE(STACK[0x2E7]) < 0) {
    JUMPOUT(0x18B3F2068);
  }
  std::ostringstream::~ostringstream(&STACK[0x6D0]);
  JUMPOUT(0x18B3F20D8);
}

void sub_18B3F2070(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x18B3F22A4);
}

void sub_18B3F20B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
}

void sub_18B3F20CC()
{
}

void sub_18B3F223C()
{
}

void sub_18B3F224C()
{
}

void sub_18B3F225C()
{
}

void sub_18B3F2268()
{
}

void sub_18B3F2278()
{
  if (SLOBYTE(STACK[0x7F7]) < 0) {
    JUMPOUT(0x18B3F2288);
  }
  JUMPOUT(0x18B3F22A4);
}

void sub_18B3F2290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,const void *a54)
{
}

void sub_18B3F22B4(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x18B3F22ACLL);
}

BOOL ___ZN8Security11CodeSigning13SecStaticCode16validateResourceEPK14__CFDictionaryNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEEbRNS1_17ValidationContextEjj_block_invoke(uint64_t a1, int a2, Security::DynamicHash *a3)
{
  __int16 v5 = Security::CodeSigning::ResourceSeal::hash(*(CFDictionaryRef **)(a1 + 40), a2);
  BOOL result = Security::DynamicHash::verify(a3, v5);
  if (!result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = 0;
  }
  return result;
}

uint64_t Security::CodeSigning::SecStaticCode::checkfix30814861(uint64_t a1, const std::string::value_type *a2, int a3)
{
  v30[2]  = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v27 = (const __CFDictionary *)(*(uint64_t (**)(void))(**(void **)(a1 + 32) + 160))(*(void *)(a1 + 32));
  CFDictionaryRef theDict = (CFDictionaryRef)0xAAAAAAAAAAAAAAAALL;
  v30[0]  = 0xAAAAAAAAAAAAAAAALL;
  Security::CFDictionary::CFDictionary((Security::CFDictionary *)&theDict, v27, (Security::MacOSError *)0xFFFEFA23);
  CFStringRef Value = CFDictionaryGetValue(theDict, @"VersionPlatform");
  CFNumberRef v7 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(Value, (Security::MacOSError *)0xFFFEFA23);
  unsigned int valuePtr = -1431655766;
  int v8 = CFNumberGetValue(v7, kCFNumberIntType, &valuePtr);
  unsigned int v9 = valuePtr;
  std::string::size_type v10 = CFDictionaryGetValue(theDict, @"VersionSDK");
  CFNumberRef v11 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(v10, (Security::MacOSError *)0xFFFEFA23);
  unsigned int valuePtr = -1431655766;
  if (CFNumberGetValue(v11, kCFNumberIntType, &valuePtr)) {
    BOOL v12 = valuePtr >= 0x90000;
  }
  else {
    BOOL v12 = 0;
  }
  char v13 = !v12;
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&theDict);
  uint64_t v14 = 0;
  if (!v8 || v9 != 2 || (v13 & 1) == 0) {
    goto LABEL_34;
  }
  if (Security::CodeSigning::SecStaticCode::checkfix30814861(std::string,BOOL)::once != -1) {
    dispatch_once(&Security::CodeSigning::SecStaticCode::checkfix30814861(std::string,BOOL)::once, &__block_literal_global_17386);
  }
  if (a3) {
    uint64_t v15 = (const regex_t *)&Security::CodeSigning::SecStaticCode::checkfix30814861(std::string,BOOL)::pathre_sinf;
  }
  else {
    uint64_t v15 = (const regex_t *)&Security::CodeSigning::SecStaticCode::checkfix30814861(std::string,BOOL)::pathre_supp_supf;
  }
  CFURLRef v16 = a2;
  if (a2[23] < 0) {
    CFURLRef v16 = *(const char **)a2;
  }
  int v17 = regexec(v15, v16, 0, 0, 0);
  int v18 = v17;
  if (!v17)
  {
    uint64_t v20 = *(void *)(a1 + 24);
    block[0]  = MEMORY[0x1E4F143A8];
    block[1]  = 0x40000000;
    block[2]  = ___ZN8Security11CodeSigning13SecStaticCode16checkfix30814861ENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEb_block_invoke_53;
    block[3]  = &__block_descriptor_tmp_54_17389;
    void block[4] = a1;
    if (v20 != -1) {
      dispatch_once((dispatch_once_t *)(a1 + 24), block);
    }
    uint64_t v21 = *(void *)(a1 + 16);
    if (a2[23] < 0) {
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *((void *)a2 + 1));
    }
    else {
      std::string __p = *(std::string *)a2;
    }
    Rule  = Security::CodeSigning::ResourceBuilder::findRule(v21, (uint64_t)&__p);
    uint64_t v23 = Rule;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if (!v23) {
        goto LABEL_33;
      }
    }
    else if (!Rule)
    {
      goto LABEL_33;
    }
    uint64_t v14 = (*(unsigned __int8 *)(v23 + 36) >> 1) & 1;
    goto LABEL_34;
  }
  if (v17 == 1)
  {
LABEL_33:
    uint64_t v14 = 0;
    goto LABEL_34;
  }
  unsigned int v19 = secLogObjForScope("SecError");
  uint64_t v14 = 0;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    if (a2[23] < 0) {
      a2  = *(const std::string::value_type **)a2;
    }
    LODWORD(theDict)  = 67109378;
    HIDWORD(theDict)  = v18;
    LOWORD(v30[0])  = 2080;
    *(void *)((char *)v30 + 2)  = a2;
    _os_log_impl(&dword_18B299000, v19, OS_LOG_TYPE_DEFAULT, "unexpected regexec result %d for path '%s'", (uint8_t *)&theDict, 0x12u);
    goto LABEL_33;
  }
LABEL_34:
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v27);
  return v14;
}

void ___ZN8Security11CodeSigning13SecStaticCode16checkfix30814861ENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEb_block_invoke_53(uint64_t a1)
{
  uint64_t v1 = *(Security::CodeSigning::SecStaticCode **)(a1 + 32);
  unsigned int v2 = (const void *)Security::CodeSigning::SecStaticCode::resourceDictionary(v1, 1);
  Security::cfget<__CFDictionary const*>(v2, (uint64_t)"rules", v3, v4, v5, v6, v7, v8, v10);
  memset(__p, 170, sizeof(__p));
  CFURLRef v9 = (const __CFURL *)Security::CodeSigning::SecStaticCode::resourceBase(v1);
  Security::cfString((Security *)__p, v9);
  operator new();
}

void sub_18B3F2730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  MEMORY[0x18C12D390](v15, 0x10F2C40CEC4FCADLL);
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t ___ZN8Security11CodeSigning13SecStaticCode16checkfix30814861ENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEb_block_invoke()
{
  if (regcomp(&Security::CodeSigning::SecStaticCode::checkfix30814861(std::string,BOOL)::pathre_sinf, "^(Frameworks/[^/]+\\.framework/|PlugIns/[^/]+\\.appex/|())SC_Info/[^/]+\\.sinf$", 5))
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_5;
  }
  uint64_t result = regcomp(&Security::CodeSigning::SecStaticCode::checkfix30814861(std::string,BOOL)::pathre_supp_supf, "^(Frameworks/[^/]+\\.framework/|PlugIns/[^/]+\\.appex/|())SC_Info/[^/]+\\.(supf|supp)$", 5);
  if (result)
  {
LABEL_5:
    _os_assert_log();
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

const void **Security::CodeSigning::SecStaticCode::staticValidate(Security::CodeSigning::SecStaticCode *this, int a2, Security::CodeSigning::Requirement **a3)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 52)  = a2;
  if ((a2 & 0x10000000) != 0)
  {
    uint64_t v6 = (const void *)Security::CodeSigning::SecStaticCode::resourceDictionary(this, 1);
    CFDictionaryRef v13 = (const __CFDictionary *)Security::cfget<__CFDictionary const*>(v6, (uint64_t)"files2", v7, v8, v9, v10, v11, v12, v45);
    if (v13
      || (CFDictionaryRef v13 = (const __CFDictionary *)Security::cfget<__CFDictionary const*>(v6, (uint64_t)"files", v14, v15, v16, v17, v18, v19, v46)) != 0)
    {
      LODWORD(v13)  = CFDictionaryGetCount(v13);
    }
    Security::CodeSigning::SecStaticCode::prepareProgress(this, v13 + 2);
  }
  Security::CodeSigning::SecStaticCode::staticValidateCore((UInt8 *)this, a2, a3);
  if (a2)
  {
    v47[0]  = MEMORY[0x1E4F143A8];
    v47[1]  = 0x40000000;
    void v47[2] = ___ZN8Security11CodeSigning13SecStaticCode14staticValidateEjPKNS0_14SecRequirementE_block_invoke;
    v47[3]  = &__block_descriptor_tmp_76_17403;
    int v48 = a2;
    v47[4]  = this;
    v47[5]  = a3;
    buf.__r_.__value_.__r.__words[0]  = MEMORY[0x1E4F143A8];
    buf.__r_.__value_.__l.__size_  = 0x40000000;
    buf.__r_.__value_.__r.__words[2]  = (std::string::size_type)___ZN8Security11CodeSigning13SecStaticCode24handleOtherArchitecturesEU13block_pointerFvPS1_E_block_invoke;
    size_t v53 = &unk_1E5485740;
    unint64_t v54 = v47;
    size_t v55 = this;
    Security::CodeSigning::SecStaticCode::visitOtherArchitectures((uint64_t)this);
  }
  Security::CodeSigning::SecStaticCode::reportProgress(this);
  uint64_t v20 = *((void *)this + 72);
  if (v20)
  {
    uint64_t v21 = (*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(void *)this + 16))(this);
    (*(void (**)(uint64_t, uint64_t, __CFString *, void))(v20 + 16))(v20, v21, @"prepared", 0);
  }
  if ((a2 & 4) == 0)
  {
    if (*((unsigned char *)this + 192) && ((a2 & 8) == 0 || *((unsigned char *)this + 193)))
    {
      int v33 = (Security::MacOSError *)*((unsigned int *)this + 49);
      if (v33) {
        Security::MacOSError::throwMe(v33);
      }
      if ((*(unsigned int (**)(void))(**((void **)this + 25) + 24))(*((void *)this + 25))) {
        (*(void (**)(void))(**((void **)this + 25) + 32))(*((void *)this + 25));
      }
    }
    else
    {
      memset(__p, 170, sizeof(__p));
      CFURLRef v22 = (const __CFURL *)(*(uint64_t (**)(void))(**((void **)this + 4) + 48))(*((void *)this + 4));
      Security::cfStringRelease((Security *)__p, v22);
      BOOL v24 = Security::CodeSigning::itemQualifiesForResourceExemption((char *)__p, v23);
      BOOL v26 = v24;
      unsigned int v27 = *((_DWORD *)this + 52) & 0x4000;
      if (v27) {
        BOOL v28 = 0;
      }
      else {
        BOOL v28 = v24;
      }
      if (SHIBYTE(__p[2]) >= 0) {
        uint64_t v29 = __p;
      }
      else {
        uint64_t v29 = (void **)__p[0];
      }
      BOOL v30 = Security::CodeSigning::pathFileSystemUsesXattrFiles((Security::CodeSigning *)v29, v25);
      long long v31 = secLogObjForScope("staticCode");
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v44 = __p;
        if (SHIBYTE(__p[2]) < 0) {
          uint64_t v44 = (void **)__p[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_)  = 136316162;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4)  = (std::string::size_type)v44;
        WORD2(buf.__r_.__value_.__r.__words[1])  = 1024;
        *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6)  = v26;
        WORD1(buf.__r_.__value_.__r.__words[2])  = 1024;
        HIDWORD(buf.__r_.__value_.__r.__words[2])  = v27 >> 14;
        LOWORD(v53)  = 1024;
        *(_DWORD *)((char *)&v53 + 2)  = v28;
        HIWORD(v53)  = 1024;
        LODWORD(v54)  = v30;
        _os_log_debug_impl(&dword_18B299000, v31, OS_LOG_TYPE_DEBUG, "performing resource validation for %s (%d, %d, %d, %d)", (uint8_t *)&buf, 0x24u);
      }
      if (!*((void *)this + 73))
      {
        if ((a2 & 0x1000) == 0)
        {
          int v32 = (unsigned int *)(*(uint64_t (**)(void))(**((void **)this + 4) + 144))(*((void *)this + 4));
          Security::UnixPlusPlus::FileDesc::mediumType(&buf, (Security::UnixPlusPlus::FileDesc *)*v32);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
        }
        operator new();
      }
      memset(v50, 170, sizeof(v50));
      if (Security::CodeSigning::SecStaticCode::loadResources(this, (const __CFDictionary **)&v50[3], (const __CFDictionary **)&v50[1], v50))
      {
        size_t v49 = this;
        operator new();
      }
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
    }
  }
  if ((a2 & 0x10) != 0)
  {
    uint64_t v36 = *((void *)this + 4);
    BOOL v37 = Security::CodeSigning::SecStaticCode::codeDirectory(this, 1);
    (*(void (**)(uint64_t, const UInt8 *, char *, void))(*(void *)v36 + 224))(v36, v37, (char *)this + 144, *((unsigned int *)this + 52));
    Security::CodeSigning::SecStaticCode::reportProgress(this);
  }
  else if ((a2 & 0x2000) != 0)
  {
    uint64_t v34 = *((void *)this + 4);
    int v35 = Security::CodeSigning::SecStaticCode::codeDirectory(this, 1);
    (*(void (**)(uint64_t, const UInt8 *, char *, void))(*(void *)v34 + 232))(v34, v35, (char *)this + 144, *((unsigned int *)this + 52));
  }
  buf.__r_.__value_.__r.__words[0]  = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v38 = *((void *)this + 72);
  if (v38)
  {
    uint64_t v39 = (*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(void *)this + 16))(this);
    long long v40 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t, __CFString *, void))(v38 + 16))(v38, v39, @"validated", 0);
    buf.__r_.__value_.__r.__words[0]  = (std::string::size_type)v40;
    if (v40)
    {
      CFTypeID v41 = CFGetTypeID(v40);
      if (v41 == CFNumberGetTypeID()) {
        uint64_t v42 = Security::cfNumber<int>((const __CFNumber *)buf.__r_.__value_.__l.__data_);
      }
      else {
        uint64_t v42 = 4294900276;
      }
      Security::MacOSError::throwMe((Security::MacOSError *)v42);
    }
  }
  else
  {
    buf.__r_.__value_.__r.__words[0]  = 0;
  }
  return Security::CFRef<void const*>::~CFRef((const void **)&buf.__r_.__value_.__l.__data_);
}

void sub_18B3F3478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,const void *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,int a55,__int16 a56,char a57,char a58,const void *a59,long long buf)
{
  if (a2)
  {
    Security::CFRef<__CFDictionary const*>::~CFRef(&a43);
    _Block_object_dispose(&a17, 8);
    _Block_object_dispose(&buf, 8);
    if (a32 < 0) {
      operator delete(__p);
    }
    Security::CFRef<__CFArray *>::~CFRef(&a59);
    Security::CFRef<__CFArray const*>::~CFRef((const void **)(v62 - 112));
    Security::CodeSigning::SecStaticCode::validateResources::_DTFrameCODESIGN_EVAL_STATIC_RESOURCES::~_DTFrameCODESIGN_EVAL_STATIC_RESOURCES();
    CFURLRef v65 = __cxa_begin_catch(exception_object);
    if (a2 == 2)
    {
      *(unsigned char *)(v60 + 192)  = 1;
      *(unsigned char *)(v60 + 193)  = (v61 & 8) != 0;
      *(_DWORD *)(v60 + 196)  = (*(uint64_t (**)(void *))(*(void *)v65 + 24))(v65);
      __cxa_rethrow();
    }
    char v66 = secLogObjForScope("staticCode");
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf)  = 134217984;
      *(void *)((char *)&buf + 4)  = v60;
      _os_log_debug_impl(&dword_18B299000, v66, OS_LOG_TYPE_DEBUG, "%p executable validation threw non-common exception", (uint8_t *)&buf, 0xCu);
    }
    *(unsigned char *)(v60 + 192)  = 1;
    *(unsigned char *)(v60 + 193)  = (v61 & 8) != 0;
    *(_DWORD *)(v60 + 196)  = -67048;
    Security::Syslog::notice((Security::Syslog *)"code signing internal problem: unknown exception thrown by validation", v67);
    __cxa_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_18B3F3764(_Unwind_Exception *a1)
{
  Security::CFRef<void const*>::~CFRef((const void **)(v1 - 208));
  _Unwind_Resume(a1);
}

void sub_18B3F3774(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (a52 < 0) {
    operator delete(a47);
  }
  JUMPOUT(0x18B3F37B0);
}

void sub_18B3F3780()
{
}

void sub_18B3F379C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void Security::CodeSigning::SecStaticCode::staticValidateCore(UInt8 *this, char a2, Security::CodeSigning::Requirement **a3)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  Security::CodeSigning::SecStaticCode::validateNonResourceComponents(this);
  CFDataRef v6 = (const __CFData *)(*(uint64_t (**)(UInt8 *, uint64_t, uint64_t))(*(void *)this + 80))(this, 4, 4294900235);
  CFDataRef v7 = v6;
  if (v6)
  {
    BytePtr  = CFDataGetBytePtr(v6);
    CFIndex Length = CFDataGetLength(v7);
    unint64_t v10 = Length;
    if ((unint64_t)Length >= 4)
    {
      if (Length < 0) {
        std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(Length >> 2);
      uint64_t v13 = 0;
      do
      {
        *(_DWORD *)&v11[v13]  = bswap32(*(_DWORD *)&BytePtr[v13]);
        v13 += 4;
      }
      while (4 * (v10 >> 2) != v13);
      uint64_t v12 = &v11[v13];
    }
    else
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
    }
    unint64_t v59 = v12;
    uint64_t v60 = (const Security::CodeSigning::SecRequirement *)a3;
    char v61 = a2;
    __s1  = v11;
    uint64_t v14 = (char *)operator new(4uLL);
    *(_DWORD *)uint64_t v14 = 0;
    uint64_t v15 = v14 + 4;
    uint64_t v16 = 1;
    uint64_t v17 = v14 + 4;
    do
    {
      if (v16 != 7
        || (uint64_t v18 = (Security::CodeSigning::CodeDirectory *)Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)this, 1), Security::CodeSigning::CodeDirectory::slotIsPresent(v18, -7)))
      {
        if ((*(uint64_t (**)(UInt8 *, uint64_t, uint64_t))(*(void *)this + 80))(this, v16, 4294900235))
        {
          if (v15 >= v17)
          {
            uint64_t v19 = (v15 - v14) >> 2;
            unint64_t v20 = v19 + 1;
            if ((unint64_t)(v19 + 1) >> 62) {
              std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
            }
            if ((v17 - v14) >> 1 > v20) {
              unint64_t v20 = (v17 - v14) >> 1;
            }
            if ((unint64_t)(v17 - v14) >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v21 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v21 = v20;
            }
            if (v21) {
              unint64_t v21 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v21);
            }
            else {
              uint64_t v22 = 0;
            }
            uint64_t v23 = (char *)(v21 + 4 * v19);
            *(_DWORD *)uint64_t v23 = v16;
            BOOL v24 = v23 + 4;
            while (v15 != v14)
            {
              int v25 = *((_DWORD *)v15 - 1);
              v15 -= 4;
              *((_DWORD *)v23 - 1)  = v25;
              v23 -= 4;
            }
            uint64_t v17 = (char *)(v21 + 4 * v22);
            if (v14) {
              operator delete(v14);
            }
            uint64_t v14 = v23;
            uint64_t v15 = v24;
          }
          else
          {
            *(_DWORD *)uint64_t v15 = v16;
            v15 += 4;
          }
        }
      }
      uint64_t v16 = (v16 + 1);
    }
    while (v16 != 12);
    int v26 = *((_DWORD *)this + 30) - 1;
    if (v26 < 1)
    {
      uint64_t v29 = v15;
    }
    else
    {
      for (int i = 0; i != v26; ++i)
      {
        int v28 = i + 4096;
        if (v15 >= v17)
        {
          uint64_t v30 = (v15 - v14) >> 2;
          unint64_t v31 = v30 + 1;
          if ((unint64_t)(v30 + 1) >> 62) {
            std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
          }
          if ((v17 - v14) >> 1 > v31) {
            unint64_t v31 = (v17 - v14) >> 1;
          }
          if ((unint64_t)(v17 - v14) >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v32 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v32 = v31;
          }
          if (v32) {
            unint64_t v32 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v32);
          }
          else {
            uint64_t v33 = 0;
          }
          uint64_t v34 = (char *)(v32 + 4 * v30);
          *(_DWORD *)uint64_t v34 = v28;
          uint64_t v29 = v34 + 4;
          while (v15 != v14)
          {
            int v35 = *((_DWORD *)v15 - 1);
            v15 -= 4;
            *((_DWORD *)v34 - 1)  = v35;
            v34 -= 4;
          }
          uint64_t v17 = (char *)(v32 + 4 * v33);
          if (v14) {
            operator delete(v14);
          }
          uint64_t v14 = v34;
        }
        else
        {
          *(_DWORD *)uint64_t v15 = v28;
          uint64_t v29 = v15 + 4;
        }
        uint64_t v15 = v29;
      }
    }
    if (v29 >= v17)
    {
      uint64_t v38 = (v29 - v14) >> 2;
      unint64_t v39 = v38 + 1;
      BOOL v37 = __s1;
      if ((unint64_t)(v38 + 1) >> 62) {
        std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
      }
      if ((v17 - v14) >> 1 > v39) {
        unint64_t v39 = (v17 - v14) >> 1;
      }
      if ((unint64_t)(v17 - v14) >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v40 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v40 = v39;
      }
      if (v40) {
        unint64_t v40 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v40);
      }
      a3  = (Security::CodeSigning::Requirement **)v60;
      a2  = v61;
      CFTypeID v41 = (char *)(v40 + 4 * v38);
      *(_DWORD *)CFTypeID v41 = 0x10000;
      uint64_t v36 = v41 + 4;
      while (v29 != v14)
      {
        int v42 = *((_DWORD *)v29 - 1);
        v29 -= 4;
        *((_DWORD *)v41 - 1)  = v42;
        v41 -= 4;
      }
      if (v14) {
        operator delete(v14);
      }
      uint64_t v14 = v41;
    }
    else
    {
      *(_DWORD *)uint64_t v29 = 0x10000;
      uint64_t v36 = v29 + 4;
      a3  = (Security::CodeSigning::Requirement **)v60;
      BOOL v37 = __s1;
      a2  = v61;
    }
    if (v59 - v37 != v36 - v14 || memcmp(v37, v14, v59 - v37)) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0BLL);
    }
    if (v14) {
      operator delete(v14);
    }
    if (v37) {
      operator delete(v37);
    }
  }
  if ((a2 & 2) != 0) {
    goto LABEL_106;
  }
  if (!this[185])
  {
    v73[1]  = this;
    std::string::size_type v43 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)this, 1);
    if (!v43) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ALL);
    }
    v73[0]  = 0xAAAAAAAAFFFFFFFFLL;
    (*(void (**)(void **__return_ptr))(**((void **)this + 4) + 40))(__p);
    if (SHIBYTE(v65) >= 0) {
      uint64_t v44 = __p;
    }
    else {
      uint64_t v44 = (void **)__p[0];
    }
    Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)v73, (const char *)v44, 0, 438);
    if (SHIBYTE(v65) < 0) {
      operator delete(__p[0]);
    }
    float v47 = Security::UnixPlusPlus::FileDesc::fcntl((Security::UnixPlusPlus::FileDesc *)v73, v45, v46);
    int v48 = (Security::Universal *)(*(uint64_t (**)(void, float))(**((void **)this + 4) + 80))(*((void *)this + 4), v47);
    if (v48)
    {
      off_t v49 = Security::Universal::archOffset(v48);
    }
    else
    {
      if (!(*(uint64_t (**)(void))(**((void **)this + 4) + 88))(*((void *)this + 4)))
      {
LABEL_87:
        __s1a  = v43[39];
        if (v43[39]) {
          unint64_t v50 = 1 << v43[39];
        }
        else {
          unint64_t v50 = 0;
        }
        if (bswap32(*((_DWORD *)v43 + 2)) >> 8 >= 0x203 && (unint64_t v51 = *((void *)v43 + 7)) != 0) {
          unint64_t v52 = bswap64(v51);
        }
        else {
          unint64_t v52 = bswap32(*((_DWORD *)v43 + 8));
        }
        if (*((_DWORD *)v43 + 7))
        {
          unsigned int v53 = 0;
          int v54 = v73[0];
          char v55 = BYTE4(v73[0]);
          do
          {
            if (v50 >= v52) {
              size_t v56 = v52;
            }
            else {
              size_t v56 = v50;
            }
            uint64_t v74 = 0;
            size_t v75 = &v74;
            if (__s1a) {
              size_t v57 = v56;
            }
            else {
              size_t v57 = v52;
            }
            uint64_t v76 = 0x2000000000;
            char v77 = 1;
            int v71 = v54;
            char v72 = v55;
            std::set<unsigned int>::set[abi:ne180100]((uint64_t)v70, (void *)this + 43);
            __p[0]  = (void *)MEMORY[0x1E4F143A8];
            __p[1]  = (void *)0x40000000;
            CFURLRef v65 = ___ZN8Security11CodeSigning13SecStaticCode18validateExecutableEv_block_invoke;
            char v66 = &unk_1E5485448;
            unsigned int v69 = v53;
            std::string::size_type v67 = &v74;
            BOOL v68 = this;
            Security::CodeSigning::CodeDirectory::multipleHashFileData((uint64_t)&v71, v57, v70, (uint64_t)__p);
            std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((void *)v70[1]);
            if (!*((unsigned char *)v75 + 24)) {
              Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0BLL);
            }
            v52 -= v57;
            _Block_object_dispose(&v74, 8);
            ++v53;
          }
          while (v53 < bswap32(*((_DWORD *)v43 + 7)));
        }
        this[185]  = 1;
        *((_DWORD *)this + 47)  = 0;
        Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)v73);
        Security::CodeSigning::SecStaticCode::validateExecutable(void)::_DTFrameCODESIGN_EVAL_STATIC_EXECUTABLE::~_DTFrameCODESIGN_EVAL_STATIC_EXECUTABLE();
        goto LABEL_105;
      }
      off_t v49 = (*(uint64_t (**)(void))(**((void **)this + 4) + 88))(*((void *)this + 4));
    }
    Security::UnixPlusPlus::FileDesc::seek((Security::UnixPlusPlus::FileDesc *)LODWORD(v73[0]), v49);
    goto LABEL_87;
  }
LABEL_105:
  uint64_t v58 = *((unsigned int *)this + 47);
  if (v58) {
    goto LABEL_114;
  }
LABEL_106:
  if (a3 && !Security::CodeSigning::SecStaticCode::satisfiesRequirement((uint64_t)this, a3[2]))
  {
    uint64_t v58 = 4294900246;
LABEL_114:
    Security::MacOSError::throwMe((Security::MacOSError *)v58);
  }
}

void sub_18B3F3F30(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  if (a2)
  {
    unint64_t v40 = __cxa_begin_catch(a1);
    if (a2 == 4)
    {
      *(unsigned char *)(v37 + 185)  = 1;
      *(_DWORD *)(v37 + 188)  = (*(uint64_t (**)(void *))(*(void *)v40 + 24))(v40);
      __cxa_rethrow();
    }
    CFTypeID v41 = secLogObjForScope("staticCode");
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)(v38 - 144)  = 134217984;
      *(void *)(v38 - 140)  = v37;
      _os_log_debug_impl(&dword_18B299000, v41, OS_LOG_TYPE_DEBUG, "%p executable validation threw non-common exception", (uint8_t *)(v38 - 144), 0xCu);
    }
    *(unsigned char *)(v37 + 185)  = 1;
    *(_DWORD *)(v37 + 188)  = -67048;
    Security::Syslog::notice((Security::Syslog *)"code signing internal problem: unknown exception thrown by validation", v42);
    __cxa_rethrow();
  }
  JUMPOUT(0x18B3F43C4);
}