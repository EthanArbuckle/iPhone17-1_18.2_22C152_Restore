char *CA::OGL::MetalContext::create_surface_from_iosurface(CA::OGL::MetalContext *this, int a2, int a3, int a4, IOSurfaceRef buffer)
{
  int Width;
  int Height;
  char *v12;
  unsigned int v13;
  unint64_t v14;
  CA::Render *PixelFormat;
  int v16;
  MTLPixelFormat v17;
  MTLPixelFormat v18;
  malloc_zone_t *malloc_zone;
  __int16 v20;
  __IOSurface *v21;
  float edr_factor;
  float v23;
  BOOL v24;
  int v25;
  uint64_t v26;
  const char *v27;
  NSObject *v28;
  os_log_type_t v29;
  uint32_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  int v34;
  void *v35;
  void *v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  uint8_t buf[4];
  int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  __int16 v51;
  int v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E4F143B8];
  Width = IOSurfaceGetWidth(buffer);
  Height = IOSurfaceGetHeight(buffer);
  v12 = 0;
  if (a2 == 1 && Width >= 1)
  {
    v13 = Height;
    if (Height >= 1)
    {
      v14 = *((void *)this + 337);
      if (Width > v14 || Height > v14)
      {
        if (x_log_hook_p())
        {
LABEL_43:
          x_log_();
          return 0;
        }
        v26 = x_log_category_ogl_metal;
        if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT)) {
          return 0;
        }
        *(_DWORD *)buf = 67109376;
        v46 = Width;
        v47 = 1024;
        v48 = v13;
        v27 = "Surface from iosurface %d x %d is too large\n";
        v28 = v26;
        v29 = OS_LOG_TYPE_DEFAULT;
        v30 = 14;
      }
      else
      {
        PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(buffer);
        v16 = (int)PixelFormat;
        v17 = CA::OGL::four_cc_to_mtl_format(PixelFormat, *((_DWORD *)this + 681));
        if (v17)
        {
          v18 = v17;
          if (!CA::OGL::MetalContext::is_viable_texture_from_iosurface(this, buffer, v17)) {
            return 0;
          }
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          v12 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xF0uLL, 0x743898A5uLL);
          *(_DWORD *)v12 = 1;
          *(_WORD *)(v12 + 75) |= 0x10u;
          *((_DWORD *)v12 + 8) = a3;
          *((_DWORD *)v12 + 9) = a4;
          *((_DWORD *)v12 + 10) = Width;
          *((_DWORD *)v12 + 11) = v13;
          *((_DWORD *)v12 + 6) = Width;
          *((_DWORD *)v12 + 7) = v13;
          *((void *)v12 + 6) = IOSurfaceGetProtectionOptions();
          *((_DWORD *)v12 + 46) = Width;
          *((_DWORD *)v12 + 47) = v13;
          v12[72] |= 1u;
          v20 = *((_WORD *)v12 + 116);
          *(_WORD *)(v12 + 75) |= 0x180u;
          *((_WORD *)v12 + 116) = v20 & 0xFDC0 | 0x31;
          *((void *)v12 + 8) = 0xF3F800000;
          edr_factor = CA::Render::iosurface_get_edr_factor(buffer, v21);
          v23 = 1.0;
          if (edr_factor == 0.0) {
            edr_factor = 1.0;
          }
          v24 = edr_factor > 1.0 || edr_factor < 0.0;
          if (edr_factor < 0.0 && edr_factor <= 1.0) {
            v23 = 0.0;
          }
          if (v24) {
            edr_factor = v23;
          }
          *((float *)v12 + 16) = edr_factor;
          if (v18 - 550 <= 5) {
            *((_DWORD *)v12 + 17) |= 0x100u;
          }
          if (v18 == MTLPixelFormatRGBA16Float)
          {
            v25 = 16;
          }
          else
          {
            if (v18 != MTLPixelFormatRGBA32Float)
            {
LABEL_33:
              v35 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:v18 width:Width height:v13 mipmapped:0];
              [v35 setUsage:5];
              [v35 setProtectionOptions:*((void *)v12 + 6)];
              v36 = (void *)[*((id *)this + 369) newTextureWithDescriptor:v35 iosurface:buffer plane:0];
              *((void *)v12 + 12) = v36;
              [v36 setLabel:@"com.apple.coreanimation.surface"];
              *((void *)v12 + 15) = v18;
              if (*((void *)v12 + 12))
              {
                CA::OGL::MetalContext::add_memoryless_textures((uint64_t)this, (uint64_t)v12);
                return v12;
              }
              CA::OGL::MetalContext::finalize_surface((uint64_t)this, (uint64_t)v12);
              return 0;
            }
            v25 = 32;
          }
          *((_DWORD *)v12 + 17) |= v25;
          goto LABEL_33;
        }
        if (x_log_hook_p())
        {
          if (v16 < 0) {
            __maskrune(HIBYTE(v16), 0x40000uLL);
          }
          if (BYTE2(v16) > 0x7Fu) {
            __maskrune(BYTE2(v16), 0x40000uLL);
          }
          if (BYTE1(v16) > 0x7Fu) {
            __maskrune(BYTE1(v16), 0x40000uLL);
          }
          if (v16 > 0x7Fu) {
            __maskrune(v16, 0x40000uLL);
          }
          goto LABEL_43;
        }
        v31 = x_log_category_ogl_metal;
        if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR)) {
          return 0;
        }
        v32 = HIBYTE(v16);
        v33 = MEMORY[0x1E4F14390];
        if (v16 < 0) {
          v34 = __maskrune(v32, 0x40000uLL);
        }
        else {
          v34 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v32 + 60) & 0x40000;
        }
        if (v34) {
          v37 = v16 >> 24;
        }
        else {
          v37 = 32;
        }
        if (BYTE2(v16) <= 0x7Fu) {
          v38 = *(_DWORD *)(v33 + 4 * BYTE2(v16) + 60) & 0x40000;
        }
        else {
          v38 = __maskrune(BYTE2(v16), 0x40000uLL);
        }
        if (v38) {
          v39 = SBYTE2(v16);
        }
        else {
          v39 = 32;
        }
        if (BYTE1(v16) <= 0x7Fu) {
          v40 = *(_DWORD *)(v33 + 4 * BYTE1(v16) + 60) & 0x40000;
        }
        else {
          v40 = __maskrune(BYTE1(v16), 0x40000uLL);
        }
        if (v40) {
          v41 = SBYTE1(v16);
        }
        else {
          v41 = 32;
        }
        if (v16 <= 0x7Fu) {
          v42 = *(_DWORD *)(v33 + 4 * v16 + 60) & 0x40000;
        }
        else {
          v42 = __maskrune(v16, 0x40000uLL);
        }
        *(_DWORD *)buf = 67109888;
        v43 = (char)v16;
        v46 = v37;
        v47 = 1024;
        if (!v42) {
          v43 = 32;
        }
        v48 = v39;
        v49 = 1024;
        v50 = v41;
        v51 = 1024;
        v52 = v43;
        v27 = "Unsupported IOSurface pixel format: %c%c%c%c";
        v28 = v31;
        v29 = OS_LOG_TYPE_ERROR;
        v30 = 26;
      }
      _os_log_impl(&dword_184668000, v28, v29, v27, buf, v30);
      return 0;
    }
  }
  return v12;
}

float CA::Render::iosurface_get_edr_factor(CA::Render *this, __IOSurface *a2)
{
  if (this) {
    IOSurfaceGetBulkAttachments();
  }
  return 1.0;
}

BOOL CA::OGL::MetalContext::add_submitted_callback(void *a1, void *aBlock)
{
  if (!a1[372]) {
    return 0;
  }
  v3 = _Block_copy(aBlock);
  v4 = v3;
  v5 = (void *)a1[384];
  unint64_t v6 = a1[385];
  if ((unint64_t)v5 >= v6)
  {
    v9 = (void *)a1[383];
    uint64_t v10 = v5 - v9;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 61) {
      abort();
    }
    uint64_t v12 = v6 - (void)v9;
    if (v12 >> 2 > v11) {
      unint64_t v11 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13)
    {
      if (v13 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      v14 = (char *)operator new(8 * v13);
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[8 * v10];
    *(void *)v15 = v4;
    v7 = v15 + 8;
    if (v5 != v9)
    {
      do
      {
        uint64_t v16 = *--v5;
        *((void *)v15 - 1) = v16;
        v15 -= 8;
      }
      while (v5 != v9);
      v5 = (void *)a1[383];
    }
    a1[383] = v15;
    a1[384] = v7;
    a1[385] = &v14[8 * v13];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    void *v5 = v3;
    v7 = v5 + 1;
  }
  a1[384] = v7;
  return a1[372] != 0;
}

void CA::Render::AsynchronousState::~AsynchronousState(CA::Render::AsynchronousState *this)
{
  CA::Render::AsynchronousState::~AsynchronousState(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  const CA::Render::Object *v2;
  void *v3;
  atomic_uint *v4;
  atomic_uint *v5;

  *(void *)this = &unk_1ED02E628;
  CA::Render::AsynchronousState::set_item((uint64_t)this, 0);
  v3 = (void *)*((void *)this + 5);
  if (v3)
  {
    *((void *)this + 6) = v3;
    operator delete(v3);
  }
  v4 = (atomic_uint *)*((void *)this + 4);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  v5 = (atomic_uint *)*((void *)this + 3);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 8))(v5);
  }
  --dword_1EB2ADE54;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, v2);
  }
}

atomic_uint *CA::Render::AsynchronousState::set_item(uint64_t a1, atomic_uint *a2)
{
  result = *(atomic_uint **)(a1 + 24);
  if (result)
  {
    (*(void (**)(atomic_uint *))(*(void *)result + 40))(result);
    result = *(atomic_uint **)(a1 + 24);
    *((void *)result + 2) = 0;
    if (result == a2) {
      return result;
    }
    if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 8))(result);
    }
    if (!a2) {
      goto LABEL_9;
    }
  }
  else if (!a2)
  {
    return result;
  }
  atomic_fetch_add(a2 + 2, 1u);
LABEL_9:
  *(void *)(a1 + 24) = a2;
  return result;
}

void CA::OGL::AsynchronousItem::~AsynchronousItem(CA::OGL::AsynchronousItem *this, __IOSurface *a2)
{
  CA::OGL::AsynchronousItem::~AsynchronousItem(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  CA::OGL **v3;
  CA::OGL **v4;
  CA::OGL *v5;
  __IOSurface *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t i;
  CA::Shape *v10;
  uint64_t v11;
  void v12[6];

  v12[5] = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED02B6E8;
  v3 = (CA::OGL **)((char *)this + 216);
  v4 = (CA::OGL **)((char *)this + 328);
  do
  {
    v5 = *v3;
    if (*v3)
    {
      if (CA::OGL::cache_io_surfaces)
      {
        os_unfair_lock_lock(&CA::OGL::surface_cache_lock);
        v7 = 0;
        while (CA::OGL::surface_cache[v7])
        {
          if (++v7 == 2)
          {
            CA::OGL::release_iosurface((CA::OGL *)CA::OGL::surface_cache[0], v6);
            v8 = &qword_1E8F84FA0;
            CA::OGL::surface_cache[0] = qword_1E8F84FA0;
            goto LABEL_10;
          }
        }
        v8 = &CA::OGL::surface_cache[v7];
LABEL_10:
        *v8 = (uint64_t)v5;
        os_unfair_lock_unlock(&CA::OGL::surface_cache_lock);
      }
      else
      {
        CA::OGL::release_iosurface(*v3, a2);
      }
    }
    v3 += 7;
  }
  while (v3 != v4);
  for (i = 0; i != -112; i -= 56)
  {
    dispatch_release(*(dispatch_object_t *)((char *)this + i + 296));
    dispatch_release(*(dispatch_object_t *)((char *)this + i + 304));
    uint64_t v10 = *(CA::Shape **)((char *)this + i + 280);
    if (v10) {
      CA::Shape::unref(v10);
    }
  }
  *(void *)this = &unk_1ED02E3D8;
  unint64_t v11 = *((void *)this + 23);
  if (v11)
  {
    if (CA::Render::AsynchronousItem::~AsynchronousItem()::once[0] != -1) {
      dispatch_once(CA::Render::AsynchronousItem::~AsynchronousItem()::once, &__block_literal_global_4972);
    }
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 0x40000000;
    v12[2] = ___ZN2CA6Render16AsynchronousItemD2Ev_block_invoke_2;
    v12[3] = &__block_descriptor_tmp_2_4973;
    v12[4] = v11;
    dispatch_async((dispatch_queue_t)CA::Render::AsynchronousItem::~AsynchronousItem()::queue, v12);
  }
}

uint64_t CA::OGL::AsynchronousItem::first_buffer(CA::OGL::AsynchronousItem *this, CA::OGL::Context *a2, CA::Render::Handle *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = (os_unfair_lock_s *)((char *)this + 208);
  os_unfair_lock_lock((os_unfair_lock_t)this + 52);
  *((_DWORD *)this + 59) = 3;
  v7 = (CA::OGL *)*((int *)this + 86);
  uint64_t v8 = *((int *)this + 87);
  uint64_t v9 = (*(uint64_t (**)(CA::OGL::Context *))(*(void *)a2 + 96))(a2);
  os_unfair_lock_lock((os_unfair_lock_t)this + 94);
  char v10 = *((unsigned char *)this + 528);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 94);
  os_unfair_lock_lock((os_unfair_lock_t)this + 94);
  int v11 = *((unsigned __int8 *)this + 529);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 94);
  *((void *)this + 27) = CA::OGL::create_iosurface(v7, v8, v9, v10, v11);
  *((void *)this + 32) = (*(uint64_t (**)(CA::OGL::Context *))(*(void *)a2 + 96))(a2);
  *((_DWORD *)this + 58) = *((_DWORD *)a2 + 57);
  uint64_t v12 = *((void *)a3 + 12);
  *((unsigned char *)this + 268) = (v12 & 0x1800000000) != 0;
  *((unsigned char *)this + 269) = (v12 & 0x18000000000) != 0;
  os_unfair_lock_lock((os_unfair_lock_t)this + 94);
  LOBYTE(a3) = *((unsigned char *)this + 528);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 94);
  *((unsigned char *)this + 270) = (_BYTE)a3;
  os_unfair_lock_lock((os_unfair_lock_t)this + 94);
  LOBYTE(a3) = *((unsigned char *)this + 529);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 94);
  *((unsigned char *)this + 271) = (_BYTE)a3;
  dispatch_semaphore_wait(*((dispatch_semaphore_t *)this + 30), 0xFFFFFFFFFFFFFFFFLL);
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 0x40000000;
  uint64_t v16 = ___ZN2CA3OGL16AsynchronousItem12first_bufferERNS0_7ContextEPNS_6Render6HandleE_block_invoke;
  v17 = &__block_descriptor_tmp_7;
  v18 = this;
  v19 = (char *)this + 216;
  atomic_fetch_add((atomic_uint *volatile)this + 2, 1u);
  if (((*(uint64_t (**)(CA::OGL::Context *, void *))(*(void *)a2 + 144))(a2, v15) & 1) == 0) {
    v16((uint64_t)v15);
  }
  uint64_t v13 = *((void *)this + 27);
  os_unfair_lock_unlock(v6);
  return v13;
}

__IOSurface *CA::OGL::create_iosurface(CA::OGL *this, uint64_t a2, uint64_t a3, char a4, int a5)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = 1380411457;
  os_unfair_lock_lock(&CA::OGL::surface_cache_lock);
  uint64_t v11 = 0;
  if (a5) {
    unsigned int v12 = 1999843442;
  }
  else {
    unsigned int v12 = 1647534392;
  }
  do
  {
    uint64_t v13 = (__IOSurface *)CA::OGL::surface_cache[v11];
    if (v13)
    {
      if ((CA::OGL *)IOSurfaceGetWidth(v13) == this
        && IOSurfaceGetHeight((IOSurfaceRef)CA::OGL::surface_cache[v11]) == a2
        && IOSurfaceGetProtectionOptions() == a3)
      {
        OSType PixelFormat = IOSurfaceGetPixelFormat((IOSurfaceRef)CA::OGL::surface_cache[v11]);
        int v16 = 1380411457;
        if ((a4 & 1) == 0)
        {
          if (CADeviceUseCIF10::once != -1) {
            dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_12019);
          }
          if (CADeviceUseCIF10::enable_cif10) {
            int v16 = v12;
          }
          else {
            int v16 = 1111970369;
          }
        }
        if (PixelFormat == v16)
        {
          iosurface_with_pixel_format = (__IOSurface *)CA::OGL::surface_cache[v11];
          CA::OGL::surface_cache[v11] = 0;
          os_unfair_lock_unlock(&CA::OGL::surface_cache_lock);
          return iosurface_with_pixel_format;
        }
      }
      CA::OGL::release_iosurface((CA::OGL *)CA::OGL::surface_cache[v11], v14);
      CA::OGL::surface_cache[v11] = 0;
    }
    ++v11;
  }
  while (v11 != 2);
  os_unfair_lock_unlock(&CA::OGL::surface_cache_lock);
  if ((a4 & 1) == 0)
  {
    if (CADeviceUseCIF10::once != -1) {
      dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_12019);
    }
    if (CADeviceUseCIF10::enable_cif10) {
      uint64_t v10 = v12;
    }
    else {
      uint64_t v10 = 1111970369;
    }
  }
  iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v10, this, a2, 0xAu, a3, @"CA Asynchronous Page", v17);
  if (!iosurface_with_pixel_format)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v19 = x_log_category_ogl;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        v22 = this;
        __int16 v23 = 2048;
        uint64_t v24 = a2;
        _os_log_impl(&dword_184668000, v19, OS_LOG_TYPE_ERROR, "Failed to allocate async IOSurface [%zu x %zu]\n", buf, 0x16u);
      }
    }
    return 0;
  }
  return iosurface_with_pixel_format;
}

__IOSurface *CA::Render::create_iosurface_with_pixel_format(CA::Render *this, unsigned int a2, int a3, unsigned int a4, uint64_t a5, const void *a6, const __CFString *a7)
{
  result = 0;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a2 && a3)
  {
    unsigned __int8 v14 = (2 * a4) & 0x10 | (8 * (a4 & 1));
    if ((a4 & 0x10) != 0) {
      int v15 = 2;
    }
    else {
      int v15 = (a4 >> 5) & 1;
    }
    uint64_t v16 = *MEMORY[0x1E4F14B00];
    if ((a4 & 0x1C6) != 0) {
      int v17 = 1792;
    }
    else {
      int v17 = 1024;
    }
    if (CADeviceUseCompression::once[0] == -1)
    {
      if ((a4 & 2) == 0) {
        goto LABEL_19;
      }
    }
    else
    {
      dispatch_once(CADeviceUseCompression::once, &__block_literal_global_21);
      if ((a4 & 2) == 0) {
        goto LABEL_19;
      }
    }
    if (CADeviceUseCompression::enable_compression)
    {
      if (CADeviceSupportsUniversalCompression::once != -1) {
        dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
      }
      if (CADeviceSupportsUniversalCompression::universal) {
        int v18 = 3;
      }
      else {
        int v18 = 2;
      }
      v19 = this;
      int v20 = 0;
      goto LABEL_29;
    }
LABEL_19:
    if (CADeviceSupportsLossyUniversalCompression::once != -1) {
      dispatch_once(&CADeviceSupportsLossyUniversalCompression::once, &__block_literal_global_46);
    }
    if ((a4 & 0x1C0) == 0 || !CADeviceSupportsLossyUniversalCompression::lossy) {
      goto LABEL_30;
    }
    if ((a4 & 0x40) != 0)
    {
      int v20 = 1;
    }
    else if ((a4 & 0x80) != 0)
    {
      int v20 = 2;
    }
    else
    {
      int v20 = ((int)(a4 << 23) >> 31) & 3;
    }
    v19 = this;
    int v18 = 4;
LABEL_29:
    this = (CA::Render *)CA::Render::fourcc_compressed_of_type(v19, v18, v20);
LABEL_30:
    long long v21 = xmmword_184997CD0;
    uint64_t v22 = 1;
    uint64_t v23 = v16;
    uint64_t v24 = 0;
    return CA::SurfaceUtil::CAIOSurfaceCreate(a2, a3, (uint64_t)this, v17, v15, v14, a5, &v21, a6);
  }
  return result;
}

void CA::OGL::AsynchronousItem::unschedule(CA::OGL::AsynchronousItem *this)
{
  v9[5] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 25);
  if (v2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v2 + 4));
    v3 = *(CA::OGL::AsynchronousItem **)(v2 + 8);
    if (v3)
    {
      v4 = (void *)(v2 + 8);
      if (v3 == this)
      {
LABEL_7:
        void *v4 = *((void *)this + 24);
        --*(_DWORD *)(v2 + 16);
      }
      else
      {
        while (1)
        {
          v5 = v3;
          v3 = (CA::OGL::AsynchronousItem *)*((void *)v3 + 24);
          if (!v3) {
            break;
          }
          if (v3 == this)
          {
            v4 = (void *)((char *)v5 + 192);
            goto LABEL_7;
          }
        }
      }
    }
    *((void *)this + 25) = 0;
    unsigned int add = atomic_fetch_add((atomic_uint *volatile)this + 2, 0xFFFFFFFF);
    if (this && add == 1) {
      (*(void (**)(CA::OGL::AsynchronousItem *))(*(void *)this + 8))(this);
    }
    if (!*(void *)(v2 + 8) && *(_DWORD *)v2)
    {
      v7 = *(__CFRunLoop **)(v2 + 32);
      uint64_t v8 = (const void *)*MEMORY[0x1E4F1D418];
      v9[0] = MEMORY[0x1E4F143A8];
      v9[1] = 0x40000000;
      v9[2] = ___ZN2CA3OGL22AsynchronousDispatcher15unschedule_itemEPNS0_16AsynchronousItemE_block_invoke;
      v9[3] = &__block_descriptor_tmp_2;
      v9[4] = v2;
      CFRunLoopPerformBlock(v7, v8, v9);
      CFRunLoopWakeUp(*(CFRunLoopRef *)(v2 + 32));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 4));
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 94);
  *((void *)this + 48) = 0;
  *((void *)this + 65) = CAHostTimeWithTime(0.0);

  os_unfair_lock_unlock((os_unfair_lock_t)this + 94);
}

void CA::OGL::release_iosurface(CA::OGL *this, __IOSurface *a2)
{
  v5[5] = *MEMORY[0x1E4F143B8];
  if (CA::OGL::AsynchronousDispatcher::dispatcher(void)::once != -1) {
    dispatch_once(&CA::OGL::AsynchronousDispatcher::dispatcher(void)::once, &__block_literal_global_1810);
  }
  v3 = (void *)CA::OGL::AsynchronousDispatcher::renderer((CA::OGL::AsynchronousDispatcher *)CA::OGL::AsynchronousDispatcher::dispatcher(void)::dispatcher);
  if (v3) {
    (*(void (**)(void, CA::OGL *))(*(void *)*v3 + 40))(*v3, this);
  }
  if (CA::OGL::release_iosurface(__IOSurface *)::once[0] != -1) {
    dispatch_once(CA::OGL::release_iosurface(__IOSurface *)::once, &__block_literal_global_12);
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = ___ZN2CA3OGLL17release_iosurfaceEP11__IOSurface_block_invoke_2;
  v5[3] = &__block_descriptor_tmp_14_1811;
  v5[4] = this;
  dispatch_block_t v4 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, v5);
  dispatch_async((dispatch_queue_t)CA::OGL::release_iosurface(__IOSurface *)::queue, v4);
  _Block_release(v4);
}

void CA::OGL::AsynchronousDispatcher::stop_timer(CFTypeRef *this)
{
  uint64_t v2 = (void *)CA::OGL::AsynchronousDispatcher::renderer((CA::OGL::AsynchronousDispatcher *)this);
  if (v2) {
    (*(void (**)(void, void))(*(void *)*v2 + 224))(*v2, 0);
  }
  uint64_t v3 = (uint64_t)this[5];
  if (v3)
  {
    CADisplayTimerInvalidate(v3);
    CFRelease(this[5]);
    this[5] = 0;
  }
}

uint64_t CA::OGL::AsynchronousDispatcher::renderer(CA::OGL::AsynchronousDispatcher *this)
{
  uint64_t result = *((void *)this + 7);
  if (result) {
    goto LABEL_7;
  }
  id v3 = CAMetalContextCreate();
  if (v3)
  {
    dispatch_block_t v4 = v3;
    uint64_t v5 = CA::OGL::new_metal_context(v3, 0, 0, 140307, 2, @"com.apple.coreanimation.async");
    *((void *)this + 8) = v5;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    v7 = malloc_type_zone_malloc(malloc_zone, 0x68uLL, 0x8BB15036uLL);
    uint64_t v8 = v7;
    if (v7)
    {
      uint64_t v9 = *((void *)this + 8);
      v7[1] = 0;
      v7[2] = 0;
      void *v7 = v9;
      v7[6] = malloc_type_malloc(0x40000uLL, 0xA44586FDuLL);
      v8[7] = 0;
      *((_DWORD *)v8 + 24) = 1;
      *((_WORD *)v8 + 50) = 0;
    }
    *((void *)this + 7) = v8;
    *(_WORD *)(v5 + 832) |= 1u;
    *(_DWORD *)(v5 + 440) = 2;
  }
  uint64_t result = *((void *)this + 7);
  if (result)
  {
LABEL_7:
    uint64_t v10 = *((void *)this + 8);
    int v11 = *(_DWORD *)(v10 + 224);
    *(_DWORD *)(v10 + 224) = 140307;
    *(_DWORD *)(v10 + 432) = global_feature_flags | 0x22413;
    if ((v11 & 0x2000200) != 0)
    {
      CA::OGL::Context::update_color_program_cache(v10);
      return *((void *)this + 7);
    }
  }
  return result;
}

void CA::Display::DisplayLink::~DisplayLink(CA::Display::DisplayLink *this)
{
  CA::Display::DisplayLink::~DisplayLink(this);

  JUMPOUT(0x185323DC0);
}

{
  uint64_t v2;
  CA::Display::DisplayLink *v3;
  CA::Display::DisplayLink *v4;
  uint64_t *v5;
  const void *v6;
  void *v7;

  *(void *)this = &unk_1ED0302C0;
  uint64_t v2 = *((void *)this + 19);
  if (v2)
  {
    CADisplayTimerInvalidate(v2);
    CFRelease(*((CFTypeRef *)this + 19));
  }
  id v3 = (CA::Display::DisplayLink *)CA::Display::DisplayLink::_list;
  if (CA::Display::DisplayLink::_list)
  {
    if ((CA::Display::DisplayLink *)CA::Display::DisplayLink::_list == this)
    {
      uint64_t v5 = &CA::Display::DisplayLink::_list;
LABEL_9:
      CA::OGL::AsynchronousItem *v5 = *((void *)this + 6);
    }
    else
    {
      while (1)
      {
        dispatch_block_t v4 = v3;
        id v3 = (CA::Display::DisplayLink *)*((void *)v3 + 6);
        if (!v3) {
          break;
        }
        if (v3 == this)
        {
          uint64_t v5 = (uint64_t *)((char *)v4 + 48);
          goto LABEL_9;
        }
      }
    }
  }
  _Block_release(*((const void **)this + 29));
  _Block_release(*((const void **)this + 30));
  _Block_release(*((const void **)this + 31));
  CFRelease(*((CFTypeRef *)this + 2));
  unint64_t v6 = (const void *)*((void *)this + 4);
  if (v6) {
    CFRelease(v6);
  }

  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 56));
  v7 = (void *)*((void *)this + 15);
  if (v7)
  {
    *((void *)this + 16) = v7;
    operator delete(v7);
  }
}

void sub_1846D8E8C(_Unwind_Exception *exception_object)
{
  id v3 = *(void **)(v1 + 120);
  if (v3)
  {
    *(void *)(v1 + 128) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void CA::Display::DisplayLinkItem::invalidate(CA::Display::DisplayLinkItem *this)
{
  *((_DWORD *)this + 78) = 1;
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  id v3 = (void *)*((void *)this + 34);
  *((void *)this + 34) = 0;
  while (1)
  {
    dispatch_block_t v4 = (_opaque_pthread_t *)*((void *)this + 31);
    if (!v4 || v4 == pthread_self()) {
      break;
    }
    pthread_cond_wait((pthread_cond_t *)((char *)this + 200), v2);
  }
  uint64_t v5 = *((void *)this + 33);
  if (v5) {
    unint64_t v6 = *(__CFRunLoop **)(v5 + 16);
  }
  else {
    unint64_t v6 = 0;
  }
  pthread_mutex_unlock(v2);
  if (v6)
  {
    CA::Display::DisplayLinkItem::update_link(this, v6);
  }
}

void sub_1846D8F74(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Display::anonymous namespace'::delete_mode_list(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    uint64_t v2 = (CFTypeRef *)a1;
    do
    {
      CFRelease(*v2);
      uint64_t v2 = (CFTypeRef *)v2[1];
    }
    while (v2);
    do
    {
      id v3 = (void *)v1[1];
      free(v1);
      uint64_t v1 = v3;
    }
    while (v3);
  }
}

uint64_t CADisplayTimerInvalidate(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  id v3 = *(__CFRunLoopSource **)(a1 + 136);
  if (v3)
  {
    CFRunLoopSourceInvalidate(v3);
    CFRelease(*(CFTypeRef *)(a1 + 136));
  }
  *(void *)(a1 + 136) = 0;
  dispatch_block_t v4 = *(__CFMachPort **)(a1 + 128);
  if (v4)
  {
    CFMachPortInvalidate(v4);
    CFRelease(*(CFTypeRef *)(a1 + 128));
  }
  *(void *)(a1 + 128) = 0;
  if (*(_DWORD *)(a1 + 120))
  {
    mk_timer_cancel();
    *(unsigned char *)(a1 + 200) = 1;
    uint64_t v5 = *(void (**)(uint64_t, uint64_t, void, void, void))(a1 + 192);
    if (v5) {
      v5(a1, 2, *(void *)(a1 + 224), *(void *)(a1 + 216), *(void *)(a1 + 184));
    }
    mk_timer_destroy();
  }
  *(_DWORD *)(a1 + 120) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0;

  return pthread_mutex_unlock(v2);
}

uint64_t CA::OGL::Context::purge(CA::OGL::Context *this, int a2)
{
  os_unfair_lock_lock(&CA::Render::BackdropGroup::_list_lock);
  dispatch_block_t v4 = (char *)CA::Render::BackdropGroup::_list;
  uint64_t v5 = qword_1E8F83D90;
  if (CA::Render::BackdropGroup::_list == (_UNKNOWN *)qword_1E8F83D90)
  {
    os_unfair_lock_unlock(&CA::Render::BackdropGroup::_list_lock);
  }
  else
  {
    unint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(void *)v4;
      if (*(_DWORD *)(*(void *)v4 + 8))
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v7 + 40));
        uint64_t v8 = *(void *)(v7 + 48);
        if (v8 && *(CA::OGL::Context **)(v8 + 8) == this)
        {
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          uint64_t v10 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
          *uint64_t v10 = v8;
          v10[1] = v6;
          *(void *)(v7 + 48) = 0;
          unint64_t v6 = v10;
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 40));
      }
      v4 += 8;
    }
    while (v4 != (char *)v5);
    os_unfair_lock_unlock(&CA::Render::BackdropGroup::_list_lock);
    if (v6)
    {
      int v11 = v6;
      do
      {
        if (*v11) {
          (*(void (**)(void))(*(void *)*v11 + 8))(*v11);
        }
        int v11 = (void *)v11[1];
      }
      while (v11);
      do
      {
        unsigned int v12 = (void *)v6[1];
        free(v6);
        unint64_t v6 = v12;
      }
      while (v12);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 76);
  x_hash_table_remove_if (*((void *)this + 39), (unsigned int (*)(void, void, uint64_t))CA::OGL::Context::remove_images, (uint64_t)this);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 76);
  uint64_t result = (*(uint64_t (**)(CA::OGL::Context *, uint64_t))(*(void *)this + 216))(this, 1);
  if (a2)
  {
    return CA::OGL::Context::update_color_program_cache((uint64_t)this);
  }
  return result;
}

uint64_t CA::OGL::MetalContext::purge(os_unfair_lock_s *this, int a2)
{
  if (a2)
  {
    CA::OGL::MetalContext::purge_shaders((CA::OGL::MetalContext *)this);
    os_unfair_lock_lock(this + 702);
    dispatch_block_t v4 = *(void **)&this[704]._os_unfair_lock_opaque;
    if (v4) {
      x_hash_table_remove_all(v4);
    }
    os_unfair_lock_unlock(this + 702);
  }

  return CA::OGL::Context::purge((CA::OGL::Context *)this, a2);
}

void CA::OGL::MetalContext::purge_iosurface_cache(os_unfair_lock_s *this, __IOSurface *a2)
{
  if (a2)
  {
    dispatch_block_t v4 = this + 702;
    os_unfair_lock_lock(this + 702);
    uint64_t v5 = *(void *)&this[704]._os_unfair_lock_opaque;
    if (v5) {
      x_hash_table_remove(v5, (uint64_t)a2);
    }
    os_unfair_lock_unlock(v4);
  }
}

uint64_t CA::OGL::MetalContext::calculate_average_luma(CA::OGL::MetalContext *this, uint64_t a2, uint64_t a3)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a2 + 48)) {
    __assert_rtn("calculate_average_luma", "ogl-metal.mm", 15825, "!surf->protection_options");
  }
  if (*((void *)this + 386)) {
    return 0;
  }
  int v7 = *((_DWORD *)this + 681);
  if ((v7 & 0x400000) == 0 || (v7 & 0x2000000) == 0 || BYTE7(xmmword_1EB2ACC50)) {
    goto LABEL_25;
  }
  CA::OGL::Context::push_surface((uint64_t)this, a2, 0, 64, 0);
  uint64_t v8 = *((void *)this + 34);
  if (v8 != *((void *)this + 33)) {
    goto LABEL_8;
  }
  if (v8) {
    LODWORD(v8) = (*(unsigned __int8 *)(v8 + 72) >> 1) & 0x1F;
  }
  if (*((_DWORD *)this + 65) != v8) {
LABEL_8:
  }
    CA::OGL::Context::prepare_destination_(this);
  if ((*((_WORD *)this + 416) & 0x200) != 0) {
    CA::OGL::Context::flatten_detached_layers_((uint64_t)this);
  }
  if (!CA::OGL::MetalContext::start_render_encoder(this)
    || (int v9 = [*((id *)this + 373) tileWidth],
        int v10 = [*((id *)this + 373) tileHeight],
        int v11 = (v9 + *(_DWORD *)(a2 + 184) - 1) / v9,
        int v12 = (v10 + *(_DWORD *)(a2 + 188) - 1) / v10 * v11,
        (external_buffer = CA::OGL::MetalBufferPool::create_external_buffer(*((CA::OGL::MetalBufferPool **)this + 505), v12 << 6, 8uLL, 0)) == 0))
  {
    CA::OGL::Context::pop_surface(this);
    goto LABEL_25;
  }
  uint64_t v14 = (uint64_t)external_buffer;
  int v46 = 8 * v12;
  int v15 = (void *)external_buffer[4];
  uint64_t v16 = *((unsigned int *)external_buffer + 10);
  uint64_t tile_pipeline = CA::OGL::MetalContext::get_tile_pipeline((uint64_t)this, 0xBu, *(void *)(a2 + 120));
  int v18 = v9 >= 0 ? v9 : v9 + 1;
  uint64_t v19 = (uint64_t)v18 >> 1;
  int v20 = v10 >= 0 ? v10 : v10 + 1;
  uint64_t v21 = (uint64_t)v20 >> 1;
  int v22 = *(_DWORD *)(a2 + 44);
  v68[0] = *(_DWORD *)(a2 + 40);
  v68[1] = v22;
  v68[2] = v11;
  v68[3] = 0;
  [*((id *)this + 373) setRenderPipelineState:tile_pipeline];
  [*((id *)this + 373) setTileBuffer:v15 offset:v16 atIndex:2];
  [*((id *)this + 373) setTileBytes:v68 length:8 atIndex:0];
  uint64_t v23 = (void *)*((void *)this + 373);
  uint64_t v62 = v19;
  uint64_t v63 = v21;
  uint64_t v4 = 1;
  uint64_t v64 = 1;
  [v23 dispatchThreadsPerTile:&v62];
  *((void *)this + 420) = tile_pipeline;
  float v24 = powf(*(float *)(a2 + 64), -1.0 / *((float *)this + 38));
  *(void *)&long long v54 = MEMORY[0x1E4F143A8];
  *((void *)&v54 + 1) = 3221225472;
  v55 = ___ZN2CA3OGL12MetalContext27tile_calculate_average_lumaEPNS0_7SurfaceEU13block_pointerFvfE_block_invoke;
  v56 = &unk_1E527BEB0;
  int v59 = v46;
  int v60 = v16;
  float v61 = v24;
  v57 = v15;
  uint64_t v58 = a3;
  CA::OGL::MetalBufferPool::release_external_buffer(*((void *)this + 505), v14);
  CA::OGL::Context::pop_surface(this);
  uint64_t v25 = (void *)*((void *)this + 372);
  v65.i64[0] = MEMORY[0x1E4F143A8];
  v65.i64[1] = 3221225472;
  v66.i64[0] = (uint64_t)___ZN2CA3OGL12MetalContext22add_completed_callbackEU13block_pointerFvvE_block_invoke;
  v66.i64[1] = (uint64_t)&unk_1E527BE88;
  v67 = &v54;
  [v25 addCompletedHandler:&v65];
  if (!*((void *)this + 372))
  {
LABEL_25:
    uint64_t v62 = 0;
    uint64_t v47 = *(void *)(a2 + 40);
    uint64_t v63 = v47;
    surface = CA::OGL::MetalContext::create_surface(this, MTLPixelFormatA8Unorm, (int32x2_t *)&v62, 1446991);
    if (!surface) {
      return 0;
    }
    uint64_t v27 = (uint64_t)surface;
    *(_WORD *)(surface + 75) |= 0x1000u;
    int v28 = v47;
    if ((int)v47 <= SHIDWORD(v47)) {
      int v28 = HIDWORD(v47);
    }
    v29.i64[0] = (int)v47;
    v29.i64[1] = SHIDWORD(v47);
    int8x16_t v30 = (int8x16_t)vcvtq_f64_s64(v29);
    int32x2_t v31 = vdup_n_s32(v28 > 1073741822);
    v29.i64[0] = v31.u32[0];
    v29.i64[1] = v31.u32[1];
    int32x4_t v32 = (int32x4_t)vcltzq_s64(vshlq_n_s64(v29, 0x3FuLL));
    int32x4_t v33 = (int32x4_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    int8x16_t v34 = vbslq_s8((int8x16_t)v32, (int8x16_t)v33, v30);
    v32.i32[0] = v28;
    v33.i32[0] = 1073741822;
    int8x16_t v65 = vandq_s8((int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v32, v33), 0));
    int8x16_t v66 = v34;
    uint64_t v35 = 1;
    CA::OGL::MetalContext::copy_surface((uint64_t)this, (uint64_t)surface, a2, 1, 0, (float64x2_t *)&v65, (float64x2_t *)&v65);
    v36 = *(void **)(v27 + 96);
    if (CA::OGL::MetalContext::start_blit_encoder(this, 0))
    {
      [*((id *)this + 374) generateMipmapsForTexture:v36];
      long long v54 = xmmword_184998020;
      v37 = CA::OGL::MetalContext::create_surface(this, MTLPixelFormatA8Unorm, (int32x2_t *)&v54, 1971279);
      if (!v37)
      {
LABEL_32:
        uint64_t v35 = 0;
        goto LABEL_33;
      }
      uint64_t v38 = (uint64_t)v37;
      *(_WORD *)(v37 + 75) |= 0x1000u;
      v39 = (void *)*((void *)this + 374);
      uint64_t v40 = *(void *)(v27 + 96);
      uint64_t v41 = [v36 mipmapLevelCount];
      uint64_t v35 = 1;
      int64x2_t v51 = vdupq_n_s64(1uLL);
      uint64_t v52 = 1;
      memset(v53, 0, sizeof(v53));
      uint64_t v42 = *(void *)(v38 + 96);
      memset(v50, 0, sizeof(v50));
      [v39 copyFromTexture:v40 sourceSlice:0 sourceLevel:v41 - 1 sourceOrigin:v53 sourceSize:&v51 toTexture:v42 destinationSlice:0 destinationLevel:0 destinationOrigin:v50];
      float v43 = powf(*(float *)(v38 + 64), -1.0 / *((float *)this + 38));
      v48[0] = MEMORY[0x1E4F143A8];
      v48[1] = 3221225472;
      v48[2] = ___ZN2CA3OGL12MetalContext22calculate_average_lumaEPNS0_7SurfaceEU13block_pointerFvfE_block_invoke;
      v48[3] = &unk_1E527BED8;
      v48[5] = this;
      v48[6] = v38;
      float v49 = v43;
      v48[4] = a3;
      v44 = (void *)*((void *)this + 372);
      *(void *)&long long v54 = MEMORY[0x1E4F143A8];
      *((void *)&v54 + 1) = 3221225472;
      v55 = ___ZN2CA3OGL12MetalContext22add_completed_callbackEU13block_pointerFvvE_block_invoke;
      v56 = &unk_1E527BE88;
      v57 = v48;
      [v44 addCompletedHandler:&v54];
      if (!*((void *)this + 372))
      {
        CA::OGL::Context::release_surface((uint64_t)this, v38);
        goto LABEL_32;
      }
    }
LABEL_33:
    CA::OGL::Context::release_surface((uint64_t)this, v27);
    return v35;
  }
  return v4;
}

uint64_t CA::OGL::MetalContext::tile_simd_blur_surface(CA::OGL::Context *this, uint64_t a2, int32x2_t *a3, float32x4_t *a4, int a5, int a6)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = *((void *)this + 34);
  if (v11 != *((void *)this + 33)) {
    goto LABEL_2;
  }
  if (v11) {
    LODWORD(v11) = (*(unsigned __int8 *)(v11 + 72) >> 1) & 0x1F;
  }
  if (*((_DWORD *)this + 65) != v11) {
LABEL_2:
  }
    CA::OGL::Context::prepare_destination_(this);
  if ((*((_WORD *)this + 416) & 0x200) != 0) {
    CA::OGL::Context::flatten_detached_layers_((uint64_t)this);
  }
  uint64_t result = CA::OGL::MetalContext::start_render_encoder(this);
  if (result)
  {
    uint64_t v14 = 0;
    uint64_t v15 = *((void *)this + 33);
    int v46 = a4;
    int v44 = a6;
    while (1)
    {
      uint64_t v16 = (char *)&CA::OGL::MetalContext::tile_simd_blur_surface(CA::OGL::Surface *,CA::Bounds,float const*,int,BOOL)::shaders
          + v14;
      if (*(_DWORD *)((char *)&CA::OGL::MetalContext::tile_simd_blur_surface(CA::OGL::Surface *,CA::Bounds,float const*,int,BOOL)::shaders
                     + v14) < a5)
        break;
      v14 += 12;
      if (v14 == 84)
      {
        int v17 = 2;
        int v18 = 10;
        goto LABEL_14;
      }
    }
    int v17 = *((_DWORD *)v16 + 1);
    int v18 = v16[8];
LABEL_14:
    unsigned int v42 = v18;
    int32x2_t v43 = *(int32x2_t *)(v15 + 32);
    int32x2_t v19 = vsub_s32(*a3, v43);
    int32x2_t v20 = vadd_s32(a3[1], v19);
    int v21 = ((int)(v19.i32[0] - (v16 & 0xFFFFFFE0)) >> 31) + v19.i32[0] / 32;
    int v22 = ((int)(v19.i32[1] - (v19.i32[0] & 0xFFFFFFE0)) >> 31) + v19.i32[1] / 32;
    int v23 = 32 * (((int)(v20.i32[0] - (v16 & 0xFFFFFFE0)) > 0) - v21 + v20.i32[0] / 32);
    int v24 = 32 * (((int)(v20.i32[1] - (v13 & 0xFFFFFFE0)) > 0) - v22 + v20.i32[1] / 32);
    uint64_t v45 = *((void *)this + 33);
    _S0 = powf(*(float *)(v15 + 64) / *(float *)(a2 + 64), 1.0 / *((float *)this + 38));
    if (v44) {
      int v26 = v17;
    }
    else {
      int v26 = 0;
    }
    int v27 = v26 + *(_DWORD *)(a2 + 32);
    if (v44) {
      __int16 v28 = 0;
    }
    else {
      __int16 v28 = v17;
    }
    __int16 v29 = v28 + *(_DWORD *)(a2 + 36);
    if (v44) {
      __int16 v30 = 32;
    }
    else {
      __int16 v30 = 0;
    }
    if (v44) {
      __int16 v31 = 0;
    }
    else {
      __int16 v31 = 32;
    }
    v51[1] = v43.i16[2] + 32 * v22 - v29;
    v51[0] = v43.i16[0] + 32 * v21 - v27;
    v51[3] = v31;
    v51[2] = v30;
    v51[4] = v44;
    __asm { FCVT            H0, S0 }
    v51[5] = _H0;
    if (v17 >= a5) {
      bzero(v52, 2 * (v17 - a5) + 2);
    }
    uint64_t v37 = v23;
    CA::HalfFloat::convert_float_array((uint64_t)&v52[v17 - a5 + 1], v46, (const float *)a5);
    if (v17 >= 1)
    {
      uint64_t v38 = v17;
      v39 = &v52[v17 + 1];
      do
        *v39++ = v52[(int)--v38];
      while (v38);
    }
    uint64_t tile_pipeline = CA::OGL::MetalContext::get_tile_pipeline((uint64_t)this, v42, *(void *)(v45 + 120));
    [*((id *)this + 373) setRenderPipelineState:tile_pipeline];
    [*((id *)this + 373) setTileTexture:*(void *)(a2 + 96) atIndex:0];
    [*((id *)this + 373) setTileBytes:v51 length:12 atIndex:0];
    [*((id *)this + 373) setTileBytes:v52 length:2 * ((2 * v17) | 1) atIndex:1];
    uint64_t v41 = (void *)*((void *)this + 373);
    int64x2_t v49 = vdupq_n_s64(0x20uLL);
    uint64_t v50 = 1;
    v48[0] = 32 * v21;
    v48[1] = 32 * v22;
    v48[2] = 0;
    v48[3] = v37;
    v48[4] = v24;
    v48[5] = 1;
    uint64_t result = [v41 dispatchThreadsPerTile:&v49 inRegion:v48];
    *((void *)this + 420) = tile_pipeline;
  }
  return result;
}

uint64_t CA::OGL::MetalContext::copy_image_to_texture(uint64_t a1, CA::Render::Image *this, uint64_t a3)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *((void *)this + 12);
  unint64_t v7 = *((void *)this + 20);
  if (*MEMORY[0x1E4F14B00] >= *MEMORY[0x1E4F14AE8]) {
    uint64_t v8 = *MEMORY[0x1E4F14AE8];
  }
  else {
    uint64_t v8 = *MEMORY[0x1E4F14B00];
  }
  uint64_t v9 = CA::Render::Image::data_size(this);
  if (*(_WORD *)(a3 + 123)) {
    return 0;
  }
  uint64_t v10 = v9;
  unint64_t v11 = [*(id *)(a1 + 2952) deviceLinearReadOnlyTextureAlignmentBytes];
  if (v6 % v11 || v7 % v11) {
    return 0;
  }
  uint64_t v13 = -v8 & v6;
  uint64_t v14 = v6 - v13;
  uint64_t v15 = (v10 + v8 + v14 - 1) & -v8;
  uint64_t v16 = (void *)[*(id *)(a1 + 2952) newBufferWithBytesNoCopy:v13 length:v15 options:0 deallocator:0];
  [v16 setLabel:@"com.apple.coreanimation.buffer-client-storage"];
  if (v16)
  {
    objc_msgSend(*(id *)(a3 + 88), "setCpuCacheMode:", objc_msgSend(v16, "cpuCacheMode"));
    objc_msgSend(*(id *)(a3 + 88), "setStorageMode:", objc_msgSend(v16, "storageMode"));
    *(void *)(a3 + 64) = [v16 newLinearTextureWithDescriptor:*(void *)(a3 + 88) offset:v14 bytesPerRow:v7 bytesPerImage:CA::Render::Image::data_size(this)];

    int v17 = *(void **)(a3 + 64);
    if (v17)
    {
      [v17 setLabel:@"com.apple.coreanimation.image-client-storage"];
      CA::OGL::MetalContext::update_texture_ownership(a1, *(void **)(a3 + 64));
      *(_WORD *)(a3 + 123) |= 0x200u;
      return 1;
    }
    if (x_log_hook_p()) {
      goto LABEL_15;
    }
    int v18 = x_log_category_ogl_metal;
    BOOL v23 = os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v23)
    {
      int v24 = *((_DWORD *)this + 4);
      int v25 = *((_DWORD *)this + 5);
      *(_DWORD *)buf = 134219520;
      uint64_t v27 = v13;
      __int16 v28 = 2048;
      uint64_t v29 = v14;
      __int16 v30 = 2048;
      uint64_t v31 = v15;
      __int16 v32 = 1024;
      int v33 = v24;
      __int16 v34 = 1024;
      int v35 = v25;
      __int16 v36 = 2048;
      unint64_t v37 = v7;
      __int16 v38 = 2048;
      uint64_t v39 = CA::Render::Image::data_size(this);
      int v22 = "nil linear texture from buffer: [b:%08lx o:%04lx l:%06zx], w:%u h:%u bpr:%zu bpi:%zu\n";
      goto LABEL_20;
    }
  }
  else
  {
    if (x_log_hook_p())
    {
LABEL_15:
      CA::Render::Image::data_size(this);
      x_log_();
      return 0;
    }
    int v18 = x_log_category_ogl_metal;
    BOOL v19 = os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v19)
    {
      int v20 = *((_DWORD *)this + 4);
      int v21 = *((_DWORD *)this + 5);
      *(_DWORD *)buf = 134219520;
      uint64_t v27 = v13;
      __int16 v28 = 2048;
      uint64_t v29 = v14;
      __int16 v30 = 2048;
      uint64_t v31 = v15;
      __int16 v32 = 1024;
      int v33 = v20;
      __int16 v34 = 1024;
      int v35 = v21;
      __int16 v36 = 2048;
      unint64_t v37 = v7;
      __int16 v38 = 2048;
      uint64_t v39 = CA::Render::Image::data_size(this);
      int v22 = "nil buffer from memory: [b:%08lx o:%04lx l:%06zx], w:%u h:%u bpr:%zu bpi:%zu\n";
LABEL_20:
      _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_DEFAULT, v22, buf, 0x40u);
      return 0;
    }
  }
  return result;
}

uint64_t CA::Render::Image::data_size(CA::Render::Image *this)
{
  uint64_t v1 = *((unsigned __int8 *)this + 152);
  unsigned int v2 = *((_DWORD *)this + 4);
  unsigned int v3 = *((_DWORD *)this + 5);
  unint64_t v4 = *((unsigned __int8 *)this + 153);
  if (v4 < 2)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = (v4 - 1);
    unint64_t v7 = (uint64_t *)((char *)this + 160);
    uint64_t v8 = v6;
    do
    {
      uint64_t v9 = *v7++;
      v5 += v9 * v3;
      if (v2 <= 1) {
        unsigned int v2 = 1;
      }
      else {
        v2 >>= 1;
      }
      if (v3 <= 1) {
        unsigned int v3 = 1;
      }
      else {
        v3 >>= 1;
      }
      --v8;
    }
    while (v8);
  }
  if (v1 > 0x25) {
    int v10 = 0;
  }
  else {
    int v10 = dword_184999468[v1];
  }
  return v5 + v2 * v10 + *((void *)this + v6 + 20) * (v3 - 1);
}

uint64_t CA::OGL::MetalContext::add_memoryless_textures(uint64_t result, uint64_t a2)
{
  if ((*(_WORD *)(result + 3328) & 8) == 0) {
    return result;
  }
  uint64_t v3 = result;
  unint64_t v4 = *(void **)(a2 + 96);
  uint64_t v5 = [v4 pixelFormat];
  if (v5 > 89)
  {
    uint64_t v7 = 110;
    if (v5 == 90 || v5 == 94) {
      goto LABEL_18;
    }
    if (v5 == 554)
    {
      if (CADeviceIsVirtualized::once != -1) {
        dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
      }
      uint64_t v7 = 115;
      if (!CADeviceIsVirtualized::is_virtualized) {
        uint64_t v7 = 550;
      }
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if (v5 == 10)
  {
    uint64_t v7 = 30;
    goto LABEL_18;
  }
  if (v5 == 43)
  {
    uint64_t v7 = 80;
    goto LABEL_18;
  }
  if (v5 != 63)
  {
LABEL_17:
    uint64_t v7 = v5;
    goto LABEL_18;
  }
  uint64_t v7 = 113;
LABEL_18:
  uint64_t v8 = CA::OGL::non_srgb_pixel_format(v7, v6);
  uint64_t v9 = objc_msgSend(MEMORY[0x1E4F35330], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", v8, objc_msgSend(v4, "width"), objc_msgSend(v4, "height"), 0);
  [v9 setUsage:5];
  if (!BYTE1(xmmword_1EB2ACBF0)) {
    [v9 setStorageMode:3];
  }
  uint64_t result = [v9 setProtectionOptions:*(void *)(v3 + 3088)];
  int v10 = *(unsigned __int16 *)(a2 + 232);
  if ((v10 & 0xFu) <= 2)
  {
    uint64_t v11 = (uint64_t)(v10 << 28) >> 28;
    int v12 = (void *)[*(id *)(v3 + 2952) newTextureWithDescriptor:v9];
    uint64_t v13 = a2 + 8 * v11;
    *(void *)(v13 + 96) = v12;
    uint64_t result = [v12 setLabel:@"com.apple.coreanimation.memoryless-texture"];
    if (*(void *)(v13 + 96))
    {
      *(void *)(v13 + 120) = v8;
      *(_WORD *)(a2 + 232) = *(_WORD *)(a2 + 232) & 0xFFF0 | (v11 + 1);
      *(_WORD *)(a2 + 214) |= 1 << v11;
    }
  }
  *(_WORD *)(a2 + 216) = *(_WORD *)(a2 + 214);
  return result;
}

uint64_t CA::OGL::non_srgb_pixel_format(uint64_t this, MTLPixelFormat a2)
{
  if (this <= 80)
  {
    switch(this)
    {
      case 11:
        return 10;
      case 31:
        return 30;
      case 71:
        return 70;
    }
  }
  else if (this > 552)
  {
    if (this == 553)
    {
      return 552;
    }
    else if (this == 555)
    {
      return 554;
    }
  }
  else if (this == 81)
  {
    return 80;
  }
  else if (this == 551)
  {
    return 550;
  }
  return this;
}

void CA::OGL::MetalContext::update_texture_ownership(uint64_t a1, void *a2)
{
  {
    CA::OGL::MetalContext::update_texture_ownership(objc_object  {objcproto10MTLTexture}*,CA::Render::Texture *)::set_owner_sel = (uint64_t)sel_setOwnerWithIdentity_;
  }
  if (*(_DWORD *)(a1 + 352) && (objc_opt_respondsToSelector() & 1) != 0)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 352);
    [a2 setOwnerWithIdentity:v4];
  }
}

void CA::OGL::MetalContext::collect(CA::OGL::MetalContext *this, int a2)
{
  uint64_t v4 = *((void *)this + 505);
  unint64_t v5 = atomic_load((unint64_t *)this + 504);
  CA::OGL::MetalBufferPool::pool_flush((CA::OGL::MetalBufferPool *)v4, v5, 0);
  if (a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v4 + 56));
    MTLPixelFormat v6 = *(void ***)(v4 + 248);
    uint64_t v7 = *(void ***)(v4 + 256);
    if (v7 == v6)
    {
      uint64_t v11 = (void *)(v4 + 280);
      uint64_t v7 = *(void ***)(v4 + 248);
    }
    else
    {
      unint64_t v8 = *(void *)(v4 + 272);
      uint64_t v9 = &v6[v8 >> 9];
      int v10 = (id *)((char *)*v9 + 8 * (v8 & 0x1FF));
      uint64_t v11 = (void *)(v4 + 280);
      uint64_t v12 = *(uint64_t *)((char *)v6 + (((*(void *)(v4 + 280) + v8) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((*(void *)(v4 + 280) + v8) & 0x1FF);
      if (v10 != (id *)v12)
      {
        do
        {

          if ((char *)v10 - (unsigned char *)*v9 == 4096)
          {
            uint64_t v13 = (id *)v9[1];
            ++v9;
            int v10 = v13;
          }
        }
        while (v10 != (id *)v12);
        MTLPixelFormat v6 = *(void ***)(v4 + 248);
        uint64_t v7 = *(void ***)(v4 + 256);
      }
    }
    *uint64_t v11 = 0;
    unint64_t v14 = (char *)v7 - (char *)v6;
    if (v14 >= 0x11)
    {
      do
      {
        operator delete(*v6);
        uint64_t v15 = *(void *)(v4 + 256);
        MTLPixelFormat v6 = (void **)(*(void *)(v4 + 248) + 8);
        *(void *)(v4 + 248) = v6;
        unint64_t v14 = v15 - (void)v6;
      }
      while (v14 > 0x10);
    }
    if (v14 >> 3 == 1)
    {
      uint64_t v16 = 256;
    }
    else
    {
      if (v14 >> 3 != 2) {
        goto LABEL_16;
      }
      uint64_t v16 = 512;
    }
    *(void *)(v4 + 272) = v16;
LABEL_16:
    int v17 = *(void ***)(v4 + 296);
    int v18 = *(void ***)(v4 + 304);
    if (v18 == v17)
    {
      int v22 = (void *)(v4 + 328);
      int v18 = *(void ***)(v4 + 296);
    }
    else
    {
      unint64_t v19 = *(void *)(v4 + 320);
      int v20 = &v17[v19 >> 9];
      int v21 = (id *)((char *)*v20 + 8 * (v19 & 0x1FF));
      int v22 = (void *)(v4 + 328);
      uint64_t v23 = *(uint64_t *)((char *)v17 + (((*(void *)(v4 + 328) + v19) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((*(void *)(v4 + 328) + v19) & 0x1FF);
      if (v21 != (id *)v23)
      {
        do
        {

          if ((char *)v21 - (unsigned char *)*v20 == 4096)
          {
            int v24 = (id *)v20[1];
            ++v20;
            int v21 = v24;
          }
        }
        while (v21 != (id *)v23);
        int v17 = *(void ***)(v4 + 296);
        int v18 = *(void ***)(v4 + 304);
      }
    }
    void *v22 = 0;
    unint64_t v25 = (char *)v18 - (char *)v17;
    if (v25 >= 0x11)
    {
      do
      {
        operator delete(*v17);
        uint64_t v26 = *(void *)(v4 + 304);
        int v17 = (void **)(*(void *)(v4 + 296) + 8);
        *(void *)(v4 + 296) = v17;
        unint64_t v25 = v26 - (void)v17;
      }
      while (v25 > 0x10);
    }
    if (v25 >> 3 == 1)
    {
      uint64_t v27 = 256;
    }
    else
    {
      if (v25 >> 3 != 2)
      {
LABEL_30:
        os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 56));
        goto LABEL_31;
      }
      uint64_t v27 = 512;
    }
    *(void *)(v4 + 320) = v27;
    goto LABEL_30;
  }
LABEL_31:

  CA::OGL::Context::collect(this, a2);
}

void sub_1846DA53C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::OGL::MetalContext::flush(CA::OGL::MetalContext *this, int a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (CA::OGL::MetalBufferPool *)*((void *)this + 505);
  unint64_t v5 = atomic_load((unint64_t *)this + 504);
  CA::OGL::MetalBufferPool::pool_flush(v4, v5, 1);
  uint64_t v33 = 0;
  __int16 v34 = &v33;
  uint64_t v35 = 0x2020000000;
  char v36 = 0;
  if (*((void *)this + 372))
  {
    CA::OGL::MetalContext::stop_encoders(this);
    MTLPixelFormat v6 = (void (*)(void, void))*((void *)this + 413);
    if (v6) {
      v6(*((void *)this + 414), *((void *)this + 372));
    }
    if (BYTE13(xmmword_1EB2ACC50))
    {
      int v14 = *((_DWORD *)this + 1022);
      __uint64_t handler = 0;
      uint64_t v38 = 0;
      mach_get_times();
      __uint64_t v15 = handler;
      uint64_t v16 = v38;
      int v17 = *((_DWORD *)this + 57);
      int v18 = pthread_self();
      __uint64_t handler = 0;
      pthread_threadid_np(v18, &handler);
      __uint64_t v19 = v16 - v15;
      __uint64_t v20 = handler;
      __int16 v21 = *((_WORD *)this + 1664);
      if ((v21 & 0x80) != 0)
      {
        uint64_t v22 = *((void *)this + 512);
        *((void *)this + 512) = 0;
        *((_WORD *)this + 1664) = v21 & 0xFF3F;
      }
      else
      {
        uint64_t v22 = 0;
      }
      int v24 = (void *)*((void *)this + 372);
      v30[0] = MEMORY[0x1E4F143A8];
      v30[1] = 3221225472;
      v30[2] = ___ZN2CA3OGL12MetalContext5flushEb_block_invoke;
      v30[3] = &__block_descriptor_64_e28_v16__0___MTLCommandBuffer__8l;
      int v31 = v17;
      int v32 = v14;
      v30[4] = this;
      v30[5] = v20;
      v30[6] = v19;
      [v24 addScheduledHandler:v30];
      unint64_t v25 = (void *)*((void *)this + 372);
      v27[0] = MEMORY[0x1E4F143A8];
      v27[1] = 3221225472;
      v27[2] = ___ZN2CA3OGL12MetalContext5flushEb_block_invoke_75;
      v27[3] = &__block_descriptor_72_e28_v16__0___MTLCommandBuffer__8l;
      v27[4] = this;
      v27[5] = v19;
      int v28 = v17;
      int v29 = v14;
      v27[6] = v20;
      v27[7] = v22;
      [v25 addCompletedHandler:v27];
    }
    if (BYTE5(xmmword_1EB2ACBF0))
    {
      uint64_t v23 = (void *)*((void *)this + 372);
      v26[0] = MEMORY[0x1E4F143A8];
      v26[1] = 3221225472;
      v26[2] = ___ZN2CA3OGL12MetalContext5flushEb_block_invoke_77;
      v26[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
      v26[4] = this;
      [v23 addCompletedHandler:v26];
    }
    if (a2)
    {
      if ((*((_WORD *)this + 1664) & 0x200) != 0)
      {
        BMMonitorBlockExecutionWithSignature();
      }
      else
      {
        char v7 = [*((id *)this + 372) commitAndWaitUntilSubmitted];
        *((unsigned char *)v34 + 24) = v7;
      }
    }
    if (*((unsigned char *)v34 + 24))
    {
      unint64_t v8 = (void *)*((void *)this + 383);
      uint64_t v9 = (void *)*((void *)this + 384);
      if (v8 != v9)
      {
        do
        {
          int v10 = (const void *)*v8;
          (*(void (**)(void))(*v8 + 16))(*v8);
          _Block_release(v10);
          ++v8;
        }
        while (v8 != v9);
        unint64_t v8 = (void *)*((void *)this + 383);
      }
      *((void *)this + 384) = v8;
    }
    else
    {
      CA::OGL::MetalContext::copy_submitted_callbacks((uint64_t)this, *((void **)this + 372));
    }
    if ((a2 & 1) == 0) {
      [*((id *)this + 372) commit];
    }

    *((void *)this + 371) = *((void *)this + 372);
    *((void *)this + 372) = 0;
    *((void *)this + 413) = 0;
    *((void *)this + 414) = 0;
  }
  if (a2 && !*((unsigned char *)v34 + 24)) {
    [*((id *)this + 371) waitUntilScheduled];
  }
  uint64_t v11 = mach_absolute_time();
  *((double *)this + 501) = CATimeWithHostTime(v11);
  os_unfair_lock_lock((os_unfair_lock_t)this + 670);
  if (!*((void *)this + 502))
  {
    uint64_t v12 = dispatch_source_create(MEMORY[0x1E4F14490], 1uLL, 0, *((dispatch_queue_t *)this + 500));
    *((void *)this + 502) = v12;
    if (v12)
    {
      dispatch_source_set_timer(v12, 0, 0x3B9ACA00uLL, 0x1DCD6500uLL);
      uint64_t v13 = *((void *)this + 502);
      __uint64_t handler = MEMORY[0x1E4F143A8];
      uint64_t v38 = 3221225472;
      uint64_t v39 = ___ZN2CA3OGL12MetalContext24start_idle_collect_timerEv_block_invoke;
      uint64_t v40 = &__block_descriptor_40_e5_v8__0l;
      uint64_t v41 = this;
      dispatch_source_set_event_handler(v13, &handler);
      dispatch_resume(*((dispatch_object_t *)this + 502));
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 670);
  _Block_object_dispose(&v33, 8);
}

void sub_1846DA97C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t CA::OGL::Context::prepare_destination_(CA::OGL::Context *this)
{
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 33);
  if (!byte_1EB2ACBED)
  {
    if (!v2) {
      goto LABEL_10;
    }
    goto LABEL_3;
  }
  uint64_t v9 = *((void *)this + 34);
  if ((_BYTE)xmmword_1EB2ACC50) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = v2 == 0;
  }
  if (v10 || v9 == 0)
  {
    if (!v2)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
LABEL_47:
      __uint64_t v15 = 0;
      uint64_t v21 = 0;
      char v18 = 1;
      goto LABEL_48;
    }
  }
  else if ((*(unsigned char *)(v2 + 69) & 8) != 0 || (*(unsigned char *)(v9 + 69) & 8) != 0)
  {
LABEL_3:
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      uint64_t v4 = *(_DWORD *)(v3 + 300) & 0x1FFFF;
      if (v4)
      {
        for (uint64_t i = 0; i != 17; ++i)
        {
          if ((v4 >> i)) {
            ++*((_DWORD *)this + i + 186);
          }
        }
        if (BYTE9(xmmword_1EB2ACC10))
        {
          uint64_t v79 = v4 << 32;
          uint64_t v22 = *(CA::Render::Object **)(v3 + 24);
          if (v22 && (uint64_t v23 = *((void *)v22 + 15)) != 0)
          {
            int v24 = (const char *)(v23 + 28);
            uint64_t v78 = 0;
            size_t v25 = strlen((const char *)(v23 + 28));
            if (v25 >= 0xC) {
              uint64_t v26 = 12;
            }
            else {
              uint64_t v26 = v25;
            }
            *(void *)buf = &v79;
            *(void *)&buf[8] = &v78;
            if (v26)
            {
              uint64_t v27 = 0;
              int v28 = &v24[v26];
              char v29 = 1;
              size_t v30 = 4;
              do
              {
                strncpy(*(char **)&buf[8 * v27], v24, v30);
                if ((v29 & 1) == 0) {
                  break;
                }
                char v29 = 0;
                v24 += v30;
                uint64_t v27 = 1;
                size_t v30 = 8;
              }
              while (v24 < v28);
            }
          }
          else
          {
            uint64_t v78 = 0;
          }
          if (v22) {
            CA::Render::Object::render_id(v22);
          }
          kdebug_trace();
        }
      }
    }
    goto LABEL_10;
  }
  uint64_t v13 = *(void *)(v2 + 16);
  if (!v13)
  {
    uint64_t v12 = 0;
    goto LABEL_47;
  }
  unsigned int v14 = *(_DWORD *)(v13 + 300);
  __uint64_t v15 = (CA::Render *)(v14 & 0x1FFFF);
  uint64_t v12 = (CA::Render *)((v14 >> 17) & 0x7FF);
  uint64_t v16 = *(void *)(v13 + 24);
  if (v16 && (uint64_t v17 = *(void *)(v16 + 120)) != 0)
  {
    char v18 = 0;
    int v19 = *(_DWORD *)(v17 + 24);
    uint64_t v20 = v17 + 28;
    if (v19) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = 0;
    }
  }
  else
  {
    char v18 = 0;
    uint64_t v21 = 0;
  }
LABEL_48:
  x_log_begin();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    int v31 = x_log_category_ogl;
    if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEFAULT))
    {
      int v32 = *((_DWORD *)this + 57);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v32;
      _os_log_impl(&dword_184668000, v31, OS_LOG_TYPE_DEFAULT, "[%u]", buf, 8u);
    }
  }
  if ((v18 & 1) == 0 && *(void *)(v13 + 24))
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v33 = x_log_category_ogl;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = *(void *)(v13 + 24);
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = v34;
        _os_log_impl(&dword_184668000, v33, OS_LOG_TYPE_DEFAULT, " (%p)", buf, 0xCu);
      }
    }
  }
  if (v21)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v35 = x_log_category_ogl;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = v21;
        _os_log_impl(&dword_184668000, v35, OS_LOG_TYPE_DEFAULT, " %s", buf, 0xCu);
      }
    }
  }
  if (v15) {
    CA::Render::print_offscreen_flags(v15);
  }
  if (v12) {
    CA::Render::print_group_flags(v12);
  }
  uint64_t v36 = *((void *)this + 33);
  if ((*(uint64_t (**)(CA::OGL::Context *))(*(void *)this + 800))(this))
  {
    if (x_log_hook_p())
    {
LABEL_90:
      x_log_();
      goto LABEL_121;
    }
    uint64_t v41 = x_log_category_ogl;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_121;
    }
    *(_WORD *)buf = 0;
    uint64_t v42 = " s:framebuffer\n";
    int32x2_t v43 = v41;
    uint32_t v44 = 2;
  }
  else
  {
    uint64_t v37 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t))(*(void *)this + 1024))(this, v36);
    unint64_t v38 = v37 * *(int *)(v36 + 24) * *(int *)(v36 + 28);
    uint64_t v39 = *(int *)(v36 + 44);
    uint64_t v40 = v37 * *(int *)(v36 + 40);
    if (!x_hash_table_lookup(*((void *)this + 36), v36, 0))
    {
      hash_table_modify(*((int **)this + 36), v36, v38, 0);
      *((void *)this + 37) += v38;
    }
    unint64_t v45 = v40 * v39;
    kdebug_trace();
    if (x_log_hook_p())
    {
      if (v38 >= 0x400)
      {
        double v49 = 1.0;
        do
          double v49 = v49 * 0.0009765625;
        while (v49 * (double)v38 >= 1024.0);
      }
      if (v45 >= 0x400)
      {
        double v50 = 1.0;
        do
          double v50 = v50 * 0.0009765625;
        while (v50 * (double)v45 >= 1024.0);
      }
      goto LABEL_90;
    }
    uint64_t v46 = x_log_category_ogl;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_121;
    }
    double v47 = (double)v38;
    if (v38 >= 0x400)
    {
      double v51 = 1.0;
      do
      {
        double v51 = v51 * 0.0009765625;
        double v48 = v51 * v47;
      }
      while (v51 * v47 >= 1024.0);
    }
    else
    {
      double v48 = (double)v38;
    }
    uint64_t v52 = v38 > 0x3FF;
    if ((v38 & 0xFFFFFFFFFFF00000) != 0) {
      ++v52;
    }
    if ((v38 & 0xFFFFFFFFC0000000) != 0) {
      ++v52;
    }
    if (v38 >> 40) {
      ++v52;
    }
    if (v38 >> 50) {
      ++v52;
    }
    if (v38 >> 60) {
      ++v52;
    }
    uint64_t v53 = off_1E527FCB0[v52];
    int v55 = *(_DWORD *)(v36 + 24);
    int v54 = *(_DWORD *)(v36 + 28);
    int v56 = *(_DWORD *)(v36 + 40);
    int v57 = *(_DWORD *)(v36 + 44);
    double v58 = (double)v45;
    if (v45 >= 0x400)
    {
      double v60 = 1.0;
      do
      {
        double v60 = v60 * 0.0009765625;
        double v59 = v60 * v58;
      }
      while (v60 * v58 >= 1024.0);
    }
    else
    {
      double v59 = (double)v45;
    }
    uint64_t v61 = v45 > 0x3FF;
    if ((v45 & 0xFFFFFFFFFFF00000) != 0) {
      ++v61;
    }
    if ((v45 & 0xFFFFFFFFC0000000) != 0) {
      ++v61;
    }
    if (v45 >> 40) {
      ++v61;
    }
    if (v45 >> 50) {
      ++v61;
    }
    if (v45 >> 60) {
      ++v61;
    }
    uint64_t v62 = off_1E527FCB0[v61];
    unsigned int v63 = *(unsigned __int16 *)(v36 + 75);
    __int16 v64 = *(_DWORD *)(v36 + 68);
    *(_DWORD *)buf = 67111682;
    *(_DWORD *)&uint8_t buf[4] = v55;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v54;
    *(_WORD *)&buf[14] = 2048;
    *(double *)&buf[16] = v48;
    int v65 = (v63 >> 5) & 1;
    *(void *)&buf[26] = v53;
    int8x16_t v66 = ", memoryless";
    *(_WORD *)&buf[24] = 2080;
    if ((v64 & 0x800) == 0) {
      int8x16_t v66 = "";
    }
    __int16 v81 = 1024;
    int v82 = v56;
    __int16 v83 = 1024;
    int v84 = v57;
    __int16 v85 = 2048;
    double v86 = v59;
    __int16 v87 = 2080;
    v88 = v62;
    __int16 v89 = 1024;
    int v90 = v65;
    __int16 v91 = 2080;
    v92 = v66;
    __int16 v93 = 2048;
    uint64_t v94 = v36;
    uint64_t v42 = " s:[%u x %u (%.2lf %s)] b:[%u x %u (%.2lf %s)] need-clear:%d%s, id:%p\n";
    int32x2_t v43 = v46;
    uint32_t v44 = 92;
  }
  _os_log_impl(&dword_184668000, v43, OS_LOG_TYPE_DEFAULT, v42, buf, v44);
LABEL_121:
  v77 = (void **)x_stream_pop_(0);
  v67 = x_stream_get(v77);
  int v68 = 0;
  while (2)
  {
    uint64_t v69 = 0;
    v70 = &v67[v68];
    int v71 = -1;
    while (1)
    {
      if (v70[v69] == 10)
      {
        int v71 = v69;
        goto LABEL_127;
      }
      if (!v70[v69]) {
        break;
      }
LABEL_127:
      ++v69;
      unsigned int v72 = 32512;
      if (v69 == 32512) {
        goto LABEL_128;
      }
    }
    unsigned int v72 = v69;
LABEL_128:
    if (v71 <= -1 || v70[v72] == 0) {
      int v74 = v72;
    }
    else {
      int v74 = v71 + 1;
    }
    if (v74 > 0)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v75 = x_log_category_ogl;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v76 = "";
          if (v68) {
            v76 = "continued...\n";
          }
          *(void *)&uint8_t buf[4] = v76;
          *(_WORD *)&buf[12] = 1040;
          *(_DWORD *)&buf[14] = v74;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = &v67[v68];
          _os_log_impl(&dword_184668000, v75, OS_LOG_TYPE_DEFAULT, "%s%.*s", buf, 0x1Cu);
        }
      }
      v68 += v74;
      continue;
    }
    break;
  }
  x_log_end_free_(v77);
  uint64_t v2 = *((void *)this + 33);
  if (v2) {
    goto LABEL_3;
  }
LABEL_10:
  uint64_t result = (*(uint64_t (**)(CA::OGL::Context *))(*(void *)this + 792))(this);
  if (result) {
    ++*((_DWORD *)this + 178);
  }
  uint64_t v7 = *((void *)this + 33);
  *((void *)this + 34) = v7;
  if (v7)
  {
    *((_DWORD *)this + 65) = (*(unsigned __int8 *)(v7 + 72) >> 1) & 0x1F;
    uint64_t v8 = *(void *)(v7 + 16);
    if (v8)
    {
      ++*(_WORD *)(v8 + 298);
      *(void *)(v7 + 16) = 0;
    }
  }
  else
  {
    *((_DWORD *)this + 65) = 0;
  }
  return result;
}

uint64_t CA::OGL::MetalContext::set_surface(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if ((*(unsigned char *)(a2 + 69) & 8) != 0)
    {
      if (*(void *)(a2 + 200) == *(void *)(a1 + 3992))
      {
        uint64_t v22 = *(void *)(a1 + 264);
        if ((*(unsigned char *)(v22 + 69) & 8) != 0 && (*(_WORD *)(v22 + 75) & 0x20) != 0) {
          CA::OGL::MetalContext::clear_memoryless_texture_(a1, v22);
        }
        return 0;
      }
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v23 = x_log_category_ogl_metal;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v26 = 0;
          _os_log_impl(&dword_184668000, v23, OS_LOG_TYPE_DEFAULT, "Target of memoryless surface not bound, possible misuse.", v26, 2u);
        }
      }
      return CA::OGL::MetalContext::set_surface(a1, *(void *)(v2 + 200));
    }
    if (*(void *)(a1 + 3992) == a2)
    {
      uint64_t v4 = *(void *)(a1 + 264);
      if (v4) {
        LODWORD(v4) = (*(unsigned __int8 *)(v4 + 72) >> 1) & 0x1F;
      }
      if (v4 == *(_DWORD *)(a1 + 260)) {
        return 0;
      }
    }
  }
  if ((*(_WORD *)(a1 + 3328) & 1) == 0 || *(void *)(a1 + 3320) != a2) {
    CA::OGL::MetalContext::stop_encoders((CA::OGL::MetalContext *)a1);
  }
  *(void *)(a1 + 3992) = 0;
  unsigned int v5 = *(_DWORD *)(a1 + 712);
  if (!v5 || (*(_WORD *)(a1 + 3328) & 0x100) != 0)
  {
LABEL_17:
    if (v2) {
      goto LABEL_18;
    }
LABEL_48:
    uint64_t v24 = a1 + 3960;
    do
    {
      [*(id *)(v24 + v2) setTexture:0];
      v2 += 8;
    }
    while (v2 != 24);
    return 0;
  }
  unsigned int v6 = *(_DWORD *)(a1 + 2728);
  if (!v6 || v5 % v6)
  {
    unsigned int v7 = *(_DWORD *)(a1 + 440);
    if (v7 && !(v5 % v7)) {
      CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)a1, 1);
    }
    goto LABEL_17;
  }
  CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)a1, 1);
  [*(id *)(a1 + 2968) waitUntilCompleted];

  *(void *)(a1 + 2968) = 0;
  if (!v2) {
    goto LABEL_48;
  }
LABEL_18:
  BOOL v8 = *(void *)(a1 + 2984) == 0;
  *(float *)&double v9 = CA::OGL::MetalContext::update_projection_matrix((CA::OGL::MetalContext *)a1);
  ++*(_DWORD *)(a1 + 256);
  BOOL v10 = (int *)(v2 + 184);
  uint64_t v11 = (int *)(v2 + 188);
  if ((*(unsigned char *)(v2 + 70) & 4) != 0)
  {
    BOOL v10 = (int *)(v2 + 24);
    uint64_t v11 = (int *)(v2 + 28);
  }
  int v12 = *v11;
  int v13 = *v10;
  uint64_t v14 = *(void *)(a1 + 264);
  if (v14)
  {
    int v15 = (*(unsigned __int8 *)(v14 + 72) >> 1) & 0x1F;
    int v16 = v13 >> v15;
    if (v13 >> v15 <= 1) {
      int v16 = 1;
    }
    int v17 = v12 >> v15;
    if (v12 >> v15 <= 1) {
      int v17 = 1;
    }
    if (v15)
    {
      int v13 = v16;
      int v12 = v17;
    }
  }
  objc_msgSend(*(id *)(a1 + 3952), "setRenderTargetWidth:", v13, v9);
  [*(id *)(a1 + 3952) setRenderTargetHeight:v12];
  for (uint64_t i = 0; i != 3; ++i)
  {
    int v19 = *(void **)(a1 + 8 * i + 3960);
    if (i >= *(unsigned __int16 *)(v2 + 232) << 28 >> 28)
    {
      [*(id *)(a1 + 8 * i + 3960) setTexture:0];
      [v19 setLoadAction:0];
      BOOL v21 = 0;
    }
    else
    {
      uint64_t v20 = v2 + 8 * i;
      [*(id *)(a1 + 8 * i + 3960) setTexture:*(void *)(v20 + 96)];
      BOOL v21 = [*(id *)(v20 + 96) storageMode] != 3;
    }
    [v19 setStoreAction:v21];
  }
  if (*(_WORD *)(v2 + 214) && (*(_WORD *)(a1 + 832) & 1) == 0) {
    *(void *)(a1 + 3992) = v2;
  }
  if ((*(_WORD *)(v2 + 75) & 0x20) != 0
    && !CA::OGL::MetalContext::start_render_encoder((CA::OGL::MetalContext *)a1))
  {
    return 0;
  }
  return v8;
}

void CA::OGL::MetalContext::stop_encoders(CA::OGL::MetalContext *this)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)*((void *)this + 373);
  if (!BYTE1(xmmword_1EB2ACBF0))
  {
    if (v2)
    {
      uint64_t v3 = *((void *)this + 499);
      if (v3 && *(unsigned __int16 *)(v3 + 216) != *(unsigned __int16 *)(v3 + 214)) {
        __assert_rtn("stop_encoders", "ogl-metal.mm", 14988, "!memoryless_in_use ()");
      }
      goto LABEL_5;
    }
LABEL_24:
    char v14 = 1;
    goto LABEL_25;
  }
  if (!v2) {
    goto LABEL_24;
  }
LABEL_5:
  if (*((void *)this + 388))
  {
    os_signpost_id_t v4 = *((unsigned int *)this + 57);
    if (v4)
    {
      unsigned int v5 = CA::OGL::MetalContext::_metal_trace_log;
      if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::_metal_trace_log))
      {
        uint64_t v6 = *((unsigned int *)this + 778);
        if (v6)
        {
          if (CA::OGL::layer_flags_str::once != -1) {
            dispatch_once(&CA::OGL::layer_flags_str::once, &__block_literal_global_5896);
          }
          uint64_t v7 = [NSNumber numberWithUnsignedInt:v6];
          BOOL v8 = (__CFString *)[(id)CA::OGL::layer_flags_str::str_cache objectForKeyedSubscript:v7];
          if (!v8)
          {
            BOOL v8 = (__CFString *)[@"offscreen:" mutableCopy];
            for (unint64_t i = 0; i != 32; ++i)
            {
              if ((v6 >> i))
              {
                if (i <= 0x10) {
                  BOOL v10 = CA::Render::offscreen_flag_names[i];
                }
                else {
                  BOOL v10 = 0;
                }
                [(__CFString *)v8 appendFormat:@" %s", v10];
              }
            }
            [(id)CA::OGL::layer_flags_str::str_cache setObject:v8 forKeyedSubscript:v7];
          }
        }
        else
        {
          BOOL v8 = @"assembly";
        }
        uint64_t v11 = *((void *)this + 390);
        int v12 = *((_DWORD *)this + 782);
        uint64_t v13 = *((void *)this + 388);
        *(_DWORD *)buf = 138544130;
        size_t v25 = v8;
        __int16 v26 = 2050;
        uint64_t v27 = v11;
        __int16 v28 = 1026;
        int v29 = v12;
        __int16 v30 = 2050;
        uint64_t v31 = v13;
        _os_signpost_emit_with_name_impl(&dword_184668000, v5, OS_SIGNPOST_EVENT, v4, "RenderEncoder", "ID is update pass=%{public,name=pass}@ layerid=%{public,name=layerid}#lx contextid=%{public,name=contextid}#x begin=%{public,signpost.description:begin_time}llu", buf, 0x26u);
        uint64_t v2 = (void *)*((void *)this + 373);
      }
    }
  }
  [v2 endEncoding];

  char v14 = 0;
  *((void *)this + 373) = 0;
  *((_OWORD *)this + 188) = 0u;
  *((_OWORD *)this + 189) = 0u;
  *((void *)this + 380) = 0;
  *((_WORD *)this + 1664) &= ~1u;
LABEL_25:
  int v15 = (void *)*((void *)this + 374);
  if (v15)
  {
    int v16 = (__CFString *)*((void *)this + 388);
    if (v16)
    {
      os_signpost_id_t v17 = *((unsigned int *)this + 57);
      if (v17)
      {
        char v18 = CA::OGL::MetalContext::_metal_trace_log;
        if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::_metal_trace_log))
        {
          *(_DWORD *)buf = 134349056;
          size_t v25 = v16;
          _os_signpost_emit_with_name_impl(&dword_184668000, v18, OS_SIGNPOST_EVENT, v17, "BlitEncoder", "ID is update begin=%{public,signpost.description:begin_time}llu", buf, 0xCu);
          int v15 = (void *)*((void *)this + 374);
        }
      }
    }
    [v15 endEncoding];

    *((void *)this + 374) = 0;
    id v19 = (id)*((void *)this + 375);
    if (!v19) {
      goto LABEL_38;
    }
  }
  else
  {
    id v19 = (id)*((void *)this + 375);
    if (!v19)
    {
      if (v14) {
        return;
      }
      goto LABEL_38;
    }
  }
  uint64_t v20 = (id *)((char *)this + 3000);
  BOOL v21 = (__CFString *)*((void *)this + 388);
  if (v21)
  {
    os_signpost_id_t v22 = *((unsigned int *)this + 57);
    if (v22)
    {
      uint64_t v23 = CA::OGL::MetalContext::_metal_trace_log;
      if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::_metal_trace_log))
      {
        *(_DWORD *)buf = 134349056;
        size_t v25 = v21;
        _os_signpost_emit_with_name_impl(&dword_184668000, v23, OS_SIGNPOST_EVENT, v22, "ComputeEncoder", "ID is update begin=%{public,signpost.description:begin_time}llu", buf, 0xCu);
        id v19 = *v20;
      }
    }
  }
  [v19 endEncoding];

  *uint64_t v20 = 0;
LABEL_38:
  if ((*((unsigned char *)this + 2726) & 1) != 0 && *((void *)this + 10))
  {
    if (byte_1EB2ACC2A) {
      CA::OGL::MetalContext::issue_cache_drop_hints(this);
    }
  }
}

float CA::OGL::MetalContext::update_projection_matrix(CA::OGL::MetalContext *this)
{
  uint64_t v1 = *((void *)this + 33);
  int v2 = *(_DWORD *)(v1 + 32);
  int v3 = *(_DWORD *)(v1 + 36);
  int v4 = *(_DWORD *)(v1 + 28);
  float v5 = (float)v3;
  float v6 = (float)(v4 + v3);
  if ((*(_WORD *)(v1 + 232) & 0x400) != 0) {
    float v7 = (float)(v4 + v3);
  }
  else {
    float v7 = (float)v2;
  }
  if ((*(_WORD *)(v1 + 232) & 0x400) != 0) {
    float v8 = (float)v3;
  }
  else {
    float v8 = (float)(*(_DWORD *)(v1 + 24) + v2);
  }
  if ((*(_WORD *)(v1 + 232) & 0x400) != 0)
  {
    float v5 = (float)v2;
    float v6 = (float)(*(_DWORD *)(v1 + 24) + v2);
  }
  float v9 = 1.0 / (float)(v8 - v7);
  float v10 = 1.0 / (float)(v6 - v5);
  float result = v9 + v9;
  float v12 = 0.0;
  if ((*(_WORD *)(v1 + 232) & 0x400) != 0) {
    float v13 = 0.0;
  }
  else {
    float v13 = v9 + v9;
  }
  *((float *)this + 546) = v13;
  if ((*(_WORD *)(v1 + 232) & 0x400) == 0) {
    float result = 0.0;
  }
  *((float *)this + 550) = result;
  *((_DWORD *)this + 554) = 0;
  *((float *)this + 558) = -(float)((float)(v8 + v7) * v9);
  if ((*(_WORD *)(v1 + 232) & 0x400) != 0) {
    float v14 = v10 * -2.0;
  }
  else {
    float v14 = 0.0;
  }
  *((float *)this + 547) = v14;
  if ((*(_WORD *)(v1 + 232) & 0x400) == 0) {
    float v12 = v10 * -2.0;
  }
  *((float *)this + 551) = v12;
  *((_DWORD *)this + 555) = 0;
  float v15 = v10 * (float)(v6 + v5);
  *((float *)this + 559) = v15;
  *((void *)this + 274) = 0;
  *((void *)this + 276) = 0;
  *((void *)this + 278) = 0;
  *((void *)this + 280) = 0x3F80000000000000;
  if ((*(_WORD *)(v1 + 232) & 0x200) != 0)
  {
    *((float *)this + 550) = -result;
    *((float *)this + 551) = -v12;
    float result = -v15;
    *((float *)this + 559) = -v15;
  }
  return result;
}

uint64_t CA::Render::Object::render_id(CA::Render::Object *this)
{
  if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
    dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
  }
  if (this) {
    return (uint64_t)this + CA::Render::_render_id_slide;
  }
  else {
    return 0;
  }
}

void CA::OGL::MetalBufferPool::pool_flush(CA::OGL::MetalBufferPool *this, unint64_t a2, int a3)
{
  v30[1] = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v5 = *((void *)this + 1);
    if (v5)
    {
      float v6 = (void *)((char *)this + 24);
      if (*((_DWORD *)this + 6))
      {
        CA::OGL::MetalBufferPool::retire_metal_buffer((uint64_t)this, v5);
        *((void *)this + 1) = 0;
        *float v6 = 0;
        *((void *)this + 4) = 0;
      }
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 14);
  float v7 = (void *)*((void *)this + 43);
  if (v7)
  {
    float v8 = (uint64_t *)((char *)this + 344);
    float v9 = (uint64_t *)*((void *)this + 43);
    do
    {
      float v10 = v9;
      float v9 = (uint64_t *)*v9;
    }
    while (v9);
    do
    {
      unint64_t v11 = v7[4];
      BOOL v12 = v11 > a2;
      if (v11 <= a2) {
        float v13 = v7 + 1;
      }
      else {
        float v13 = v7;
      }
      if (v12) {
        float v8 = v7;
      }
      float v7 = (void *)*v13;
    }
    while (*v13);
    float v14 = v10;
    if (v10 != v8)
    {
      float v15 = v10;
      do
      {
        int v16 = (void *)v15[5];
        v30[0] = v16;
        if ([v16 length] == 0x40000)
        {
          unint64_t v17 = *((void *)this + 35);
          if (v17 >= 0x10)
          {
            unint64_t v18 = *((void *)this + 34);
            id v19 = *(void **)(*(void *)(*((void *)this + 31) + ((v18 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v18 & 0x1FF));
            int v29 = v19;
            *((void *)this + 34) = v18 + 1;
            *((void *)this + 35) = v17 - 1;
            std::deque<objc_object  {objcproto9MTLBuffer}*>::__maybe_remove_front_spare[abi:nn180100]((uint64_t)this + 240);
            unint64_t v20 = *((void *)this + 41);
            if (v20 >= 0x40)
            {
              BOOL v21 = *(void **)(*(void *)(*((void *)this + 37) + ((*((void *)this + 40) >> 6) & 0x3FFFFFFFFFFFFF8))
                             + 8 * (*((void *)this + 40) & 0x1FFLL));
              ++*((void *)this + 40);
              *((void *)this + 41) = v20 - 1;
              std::deque<objc_object  {objcproto9MTLBuffer}*>::__maybe_remove_front_spare[abi:nn180100]((uint64_t)this + 288);
            }
            std::deque<objc_object  {objcproto9MTLBuffer}*>::push_back((void *)this + 36, &v29);
            [v19 setPurgeableState:3];
          }
          std::deque<objc_object  {objcproto9MTLBuffer}*>::push_back((void *)this + 30, v30);
        }
        else
        {
        }
        os_signpost_id_t v22 = (uint64_t *)v15[1];
        if (v22)
        {
          do
          {
            uint64_t v23 = v22;
            os_signpost_id_t v22 = (uint64_t *)*v22;
          }
          while (v22);
        }
        else
        {
          do
          {
            uint64_t v23 = (uint64_t *)v15[2];
            BOOL v24 = *v23 == (void)v15;
            float v15 = v23;
          }
          while (!v24);
        }
        float v15 = v23;
      }
      while (v23 != v8);
      float v14 = v8;
    }
    if (v10 != v14)
    {
      do
      {
        size_t v25 = (uint64_t *)v10[1];
        __int16 v26 = v10;
        if (v25)
        {
          do
          {
            uint64_t v27 = v25;
            size_t v25 = (uint64_t *)*v25;
          }
          while (v25);
        }
        else
        {
          do
          {
            uint64_t v27 = (uint64_t *)v26[2];
            BOOL v24 = *v27 == (void)v26;
            __int16 v26 = v27;
          }
          while (!v24);
        }
        if (*((uint64_t **)this + 42) == v10) {
          *((void *)this + 42) = v27;
        }
        __int16 v28 = (uint64_t *)*((void *)this + 43);
        --*((void *)this + 44);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v28, v10);
        operator delete(v10);
        float v10 = v27;
      }
      while (v27 != v14);
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)this + 14);
}

void sub_1846DBE1C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  int v3 = a2;
  if (*a2)
  {
    int v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      int v3 = a2;
      goto LABEL_7;
    }
    do
    {
      int v3 = v4;
      int v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  float v6 = (uint64_t **)v3[2];
  float v7 = *v6;
  if (*v6 == v3)
  {
    *float v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      float v7 = 0;
      float result = (uint64_t *)v2;
    }
    else
    {
      float v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    uint64_t *v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      float result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 != v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      uint64_t v18 = v7[1];
      *(void *)uint64_t v12 = v18;
      if (v18) {
        *(void *)(v18 + 16) = v12;
      }
      v7[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(void *)(v12 + 16) = v7;
      if (result == (uint64_t *)v12) {
        float result = v7;
      }
      float v7 = *(uint64_t **)v12;
    }
    id v19 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v19 + 24)) {
      goto LABEL_68;
    }
    unint64_t v20 = (uint64_t *)v7[1];
    if (v20 && !*((unsigned char *)v20 + 24))
    {
      if (v19 && !*((unsigned char *)v19 + 24))
      {
LABEL_68:
        unint64_t v20 = v7;
      }
      else
      {
        *((unsigned char *)v20 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v26 = *v20;
        v7[1] = *v20;
        if (v26) {
          *(void *)(v26 + 16) = v7;
        }
        v20[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
        *unint64_t v20 = (uint64_t)v7;
        v7[2] = (uint64_t)v20;
        id v19 = v7;
      }
      uint64_t v23 = v20[2];
      *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v19 + 24) = 1;
      BOOL v24 = *(uint64_t **)v23;
      uint64_t v27 = *(void *)(*(void *)v23 + 8);
      *(void *)uint64_t v23 = v27;
      if (v27) {
        *(void *)(v27 + 16) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }
    *((unsigned char *)v7 + 24) = 0;
    unint64_t v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
LABEL_49:
    float v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    float v13 = *(uint64_t **)(v12 + 8);
    uint64_t v14 = *v13;
    *(void *)(v12 + 8) = *v13;
    if (v14) {
      *(void *)(v14 + 16) = v12;
    }
    v13[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
    *float v13 = v12;
    *(void *)(v12 + 16) = v13;
    if (result == (uint64_t *)*v7) {
      float result = v7;
    }
    float v7 = *(uint64_t **)(*v7 + 8);
  }
  float v15 = (void *)*v7;
  if (!*v7 || *((unsigned char *)v15 + 24))
  {
    int v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_59;
    }
    *((unsigned char *)v7 + 24) = 0;
    unint64_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      unint64_t v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  int v16 = (uint64_t *)v7[1];
  if (v16 && !*((unsigned char *)v16 + 24))
  {
LABEL_59:
    float v15 = v7;
  }
  else
  {
    *((unsigned char *)v15 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v22 = v15[1];
    uint64_t *v7 = v22;
    if (v22) {
      *(void *)(v22 + 16) = v7;
    }
    void v15[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
    v15[1] = v7;
    v7[2] = (uint64_t)v15;
    int v16 = v7;
  }
  uint64_t v23 = v15[2];
  *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v16 + 24) = 1;
  BOOL v24 = *(uint64_t **)(v23 + 8);
  uint64_t v25 = *v24;
  *(void *)(v23 + 8) = *v24;
  if (v25) {
    *(void *)(v25 + 16) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  *BOOL v24 = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

void std::deque<objc_object  {objcproto9MTLBuffer}*>::push_back(void *a1, void *a2)
{
  int v4 = (char *)a1[2];
  int v5 = (char *)a1[1];
  uint64_t v6 = v4 - v5;
  if (v4 == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = ((v4 - v5) << 6) - 1;
  }
  unint64_t v8 = a1[4];
  unint64_t v9 = a1[5] + v8;
  if (v7 == v9)
  {
    if (v8 >= 0x200)
    {
      a1[4] = v8 - 512;
      uint64_t v12 = *(void *)v5;
      uint64_t v10 = v5 + 8;
      uint64_t v11 = v12;
      a1[1] = v10;
      if ((char *)a1[3] == v4)
      {
        uint64_t v13 = (uint64_t)&v10[-*a1];
        if ((unint64_t)v10 <= *a1)
        {
          if (v4 == (char *)*a1) {
            unint64_t v41 = 1;
          }
          else {
            unint64_t v41 = (uint64_t)&v4[-*a1] >> 2;
          }
          uint64_t v42 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v41);
          uint32_t v44 = &v42[8 * (v41 >> 2)];
          unint64_t v45 = (uint64_t *)a1[1];
          int v4 = v44;
          uint64_t v46 = a1[2] - (void)v45;
          if (v46)
          {
            int v4 = &v44[v46 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v47 = 8 * (v46 >> 3);
            double v48 = &v42[8 * (v41 >> 2)];
            do
            {
              uint64_t v49 = *v45++;
              *(void *)double v48 = v49;
              v48 += 8;
              v47 -= 8;
            }
            while (v47);
          }
          double v50 = (char *)*a1;
          *a1 = v42;
          a1[1] = v44;
          a1[2] = v4;
          a1[3] = &v42[8 * v43];
          if (v50)
          {
            operator delete(v50);
            int v4 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v14 = v13 >> 3;
          BOOL v15 = v13 >> 3 < -1;
          uint64_t v16 = (v13 >> 3) + 2;
          if (v15) {
            uint64_t v17 = v16;
          }
          else {
            uint64_t v17 = v14 + 1;
          }
          uint64_t v18 = -(v17 >> 1);
          uint64_t v19 = v17 >> 1;
          unint64_t v20 = &v10[-8 * v19];
          int64_t v21 = v4 - v10;
          if (v4 == v10)
          {
            uint64_t v22 = v4;
          }
          else
          {
            memmove(&v10[-8 * v19], v10, v4 - v10);
            uint64_t v22 = (char *)a1[1];
          }
          int v4 = &v20[v21];
          a1[1] = &v22[8 * v18];
          a1[2] = &v20[v21];
        }
      }
      *(void *)int v4 = v11;
LABEL_82:
      a1[2] += 8;
LABEL_83:
      int v5 = (char *)a1[1];
      unint64_t v9 = a1[5] + a1[4];
      goto LABEL_84;
    }
    uint64_t v23 = v6 >> 3;
    BOOL v24 = (char *)a1[3];
    uint64_t v25 = (char *)*a1;
    uint64_t v26 = (uint64_t)&v24[-*a1];
    if (v6 >> 3 < (unint64_t)(v26 >> 3))
    {
      uint64_t v27 = operator new(0x1000uLL);
      __int16 v28 = v27;
      if (v24 == v4)
      {
        if (v25 == v5)
        {
          if (v4 == v5) {
            unint64_t v51 = 1;
          }
          else {
            unint64_t v51 = v26 >> 2;
          }
          uint64_t v52 = 2 * v51;
          uint64_t v53 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v51);
          int v5 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
          int v55 = (uint64_t *)a1[1];
          int v56 = v5;
          uint64_t v57 = a1[2] - (void)v55;
          if (v57)
          {
            int v56 = &v5[v57 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v58 = 8 * (v57 >> 3);
            double v59 = v5;
            do
            {
              uint64_t v60 = *v55++;
              *(void *)double v59 = v60;
              v59 += 8;
              v58 -= 8;
            }
            while (v58);
          }
          uint64_t v61 = (char *)*a1;
          *a1 = v53;
          a1[1] = v5;
          a1[2] = v56;
          a1[3] = &v53[8 * v54];
          if (v61)
          {
            operator delete(v61);
            int v5 = (char *)a1[1];
          }
        }
        *((void *)v5 - 1) = v28;
        uint64_t v62 = (char *)a1[1];
        unsigned int v63 = (char *)a1[2];
        a1[1] = v62 - 8;
        uint64_t v64 = *((void *)v62 - 1);
        a1[1] = v62;
        if (v63 == (char *)a1[3])
        {
          uint64_t v65 = (uint64_t)&v62[-*a1];
          if ((unint64_t)v62 <= *a1)
          {
            if (v63 == (char *)*a1) {
              unint64_t v96 = 1;
            }
            else {
              unint64_t v96 = (uint64_t)&v63[-*a1] >> 2;
            }
            v97 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v96);
            v99 = &v97[8 * (v96 >> 2)];
            v100 = (uint64_t *)a1[1];
            unsigned int v63 = v99;
            uint64_t v101 = a1[2] - (void)v100;
            if (v101)
            {
              unsigned int v63 = &v99[v101 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v102 = 8 * (v101 >> 3);
              v103 = &v97[8 * (v96 >> 2)];
              do
              {
                uint64_t v104 = *v100++;
                *(void *)v103 = v104;
                v103 += 8;
                v102 -= 8;
              }
              while (v102);
            }
            v105 = (char *)*a1;
            *a1 = v97;
            a1[1] = v99;
            a1[2] = v63;
            a1[3] = &v97[8 * v98];
            if (v105)
            {
              operator delete(v105);
              unsigned int v63 = (char *)a1[2];
            }
          }
          else
          {
            uint64_t v66 = v65 >> 3;
            BOOL v15 = v65 >> 3 < -1;
            uint64_t v67 = (v65 >> 3) + 2;
            if (v15) {
              uint64_t v68 = v67;
            }
            else {
              uint64_t v68 = v66 + 1;
            }
            uint64_t v69 = -(v68 >> 1);
            uint64_t v70 = v68 >> 1;
            int v71 = &v62[-8 * v70];
            int64_t v72 = v63 - v62;
            if (v63 != v62)
            {
              memmove(&v62[-8 * v70], v62, v63 - v62);
              uint64_t v62 = (char *)a1[1];
            }
            unsigned int v63 = &v71[v72];
            a1[1] = &v62[8 * v69];
            a1[2] = &v71[v72];
          }
        }
        *(void *)unsigned int v63 = v64;
      }
      else
      {
        *(void *)int v4 = v27;
      }
      goto LABEL_82;
    }
    if (v24 == v25) {
      unint64_t v29 = 1;
    }
    else {
      unint64_t v29 = v26 >> 2;
    }
    __int16 v30 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v29);
    uint64_t v32 = v31;
    uint64_t v33 = &v30[8 * v23];
    *(void *)&long long v34 = v30;
    *((void *)&v34 + 1) = v33;
    long long v109 = v34;
    uint64_t v35 = operator new(0x1000uLL);
    *(void *)&long long v36 = v33;
    *((void *)&v36 + 1) = &v30[8 * v32];
    if (v23 == v32)
    {
      uint64_t v37 = 8 * v23;
      *(void *)&long long v38 = v109;
      if (v6 >= 1)
      {
        uint64_t v39 = v37 >> 3;
        if (v39 >= -1) {
          unint64_t v40 = v39 + 1;
        }
        else {
          unint64_t v40 = v39 + 2;
        }
        v33 -= 8 * (v40 >> 1);
        *(void *)&long long v36 = v33;
        *((void *)&v38 + 1) = v33;
        goto LABEL_56;
      }
      uint64_t v73 = v37 >> 2;
      if (v4 == v5) {
        unint64_t v74 = 1;
      }
      else {
        unint64_t v74 = v73;
      }
      v75 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v74);
      uint64_t v33 = &v75[8 * (v74 >> 2)];
      *(void *)&long long v38 = v75;
      *((void *)&v38 + 1) = v33;
      *(void *)&long long v36 = v33;
      *((void *)&v36 + 1) = &v75[8 * v76];
      if (!v30) {
        goto LABEL_56;
      }
      long long v106 = v36;
      long long v109 = v38;
      operator delete(v30);
      long long v36 = v106;
    }
    long long v38 = v109;
LABEL_56:
    *(void *)uint64_t v33 = v35;
    *(void *)&long long v36 = v36 + 8;
    for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
    {
      uint64_t v78 = (void *)*((void *)&v38 + 1);
      if (*((void *)&v38 + 1) == (void)v38)
      {
        v80 = (unsigned char *)v36;
        if ((unint64_t)v36 >= *((void *)&v36 + 1))
        {
          if (*((void *)&v36 + 1) == *((void *)&v38 + 1)) {
            unint64_t v85 = 1;
          }
          else {
            unint64_t v85 = (uint64_t)(*((void *)&v36 + 1) - *((void *)&v38 + 1)) >> 2;
          }
          double v86 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v85);
          uint64_t v79 = &v86[(2 * v85 + 6) & 0xFFFFFFFFFFFFFFF8];
          v88 = v79;
          uint64_t v89 = v80 - (unsigned char *)v78;
          if (v80 != (unsigned char *)v78)
          {
            v88 = &v79[v89 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v90 = 8 * (v89 >> 3);
            __int16 v91 = v79;
            v92 = v78;
            do
            {
              uint64_t v93 = *v92++;
              *(void *)__int16 v91 = v93;
              v91 += 8;
              v90 -= 8;
            }
            while (v90);
          }
          *(void *)&long long v38 = v86;
          *((void *)&v38 + 1) = v79;
          *(void *)&long long v36 = v88;
          *((void *)&v36 + 1) = &v86[8 * v87];
          if (v78)
          {
            long long v107 = v36;
            long long v111 = v38;
            operator delete(v78);
            long long v36 = v107;
            long long v38 = v111;
          }
        }
        else
        {
          uint64_t v81 = (uint64_t)(*((void *)&v36 + 1) - v36) >> 3;
          if (v81 >= -1) {
            uint64_t v82 = v81 + 1;
          }
          else {
            uint64_t v82 = v81 + 2;
          }
          uint64_t v83 = v82 >> 1;
          uint64_t v84 = v36 + 8 * (v82 >> 1);
          uint64_t v79 = (char *)(v84 - (v36 - *((void *)&v38 + 1)));
          if ((void)v36 == *((void *)&v38 + 1))
          {
            v80 = (unsigned char *)*((void *)&v38 + 1);
          }
          else
          {
            uint64_t v108 = *((void *)&v36 + 1);
            uint64_t v110 = v38;
            memmove((void *)(v84 - (v36 - *((void *)&v38 + 1))), *((const void **)&v38 + 1), v36 - *((void *)&v38 + 1));
            *((void *)&v36 + 1) = v108;
            *(void *)&long long v38 = v110;
          }
          *((void *)&v38 + 1) = v79;
          *(void *)&long long v36 = &v80[8 * v83];
        }
      }
      else
      {
        uint64_t v79 = (char *)*((void *)&v38 + 1);
      }
      uint64_t v94 = *(void *)(i - 8);
      *((void *)v79 - 1) = v94;
      *((void *)&v38 + 1) -= 8;
    }
    uint64_t v95 = (char *)*a1;
    *(_OWORD *)a1 = v38;
    *((_OWORD *)a1 + 1) = v36;
    if (v95) {
      operator delete(v95);
    }
    goto LABEL_83;
  }
LABEL_84:
  *(void *)(*(void *)&v5[(v9 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v9 & 0x1FF)) = *a2;
  ++a1[5];
}

void sub_1846DC714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11)
{
  operator delete(v11);
  if ((void)a11) {
    operator delete((void *)a11);
  }
  _Unwind_Resume(a1);
}

void CA::OGL::MetalBufferPool::retire_metal_buffer(uint64_t a1, uint64_t a2)
{
  int v4 = (os_unfair_lock_s *)(a1 + 56);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 56));
  unint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = (uint64_t *)operator new(0x30uLL);
  uint64_t v7 = v6;
  v6[4] = v5;
  v6[5] = a2;
  unint64_t v8 = *(uint64_t **)(a1 + 344);
  if (v8)
  {
    do
    {
      while (1)
      {
        unint64_t v9 = (uint64_t **)v8;
        if (v5 >= v8[4]) {
          break;
        }
        unint64_t v8 = (uint64_t *)*v8;
        uint64_t v10 = v9;
        if (!*v9) {
          goto LABEL_8;
        }
      }
      unint64_t v8 = (uint64_t *)v8[1];
    }
    while (v8);
    uint64_t v10 = v9 + 1;
  }
  else
  {
    unint64_t v9 = (uint64_t **)(a1 + 344);
    uint64_t v10 = (uint64_t **)(a1 + 344);
  }
LABEL_8:
  *uint64_t v6 = 0;
  v6[1] = 0;
  v6[2] = (uint64_t)v9;
  *uint64_t v10 = v6;
  uint64_t v11 = **(void **)(a1 + 336);
  if (v11)
  {
    *(void *)(a1 + 336) = v11;
    uint64_t v7 = *v10;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 344), v7);
  ++*(void *)(a1 + 352);

  os_unfair_lock_unlock(v4);
}

void sub_1846DC818(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::OGL::MetalContext::get_tile_pipeline(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = a3 & 0x3FF | ((a2 & 0xF) << 10);
  int8x8_t v6 = *(int8x8_t *)(a1 + 2616);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      uint64_t v8 = a3 & 0x3FF | ((a2 & 0xF) << 10);
      if (*(void *)&v6 <= v5) {
        uint64_t v8 = v5 % *(void *)&v6;
      }
    }
    else
    {
      uint64_t v8 = (v6.i32[0] - 1) & v5;
    }
    unint64_t v9 = *(uint64_t ***)(*(void *)(a1 + 2608) + 8 * v8);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v5)
        {
          if (*((_DWORD *)i + 4) == v5) {
            return i[3];
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= *(void *)&v6) {
              v11 %= *(void *)&v6;
            }
          }
          else
          {
            v11 &= *(void *)&v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  uint64_t v12 = *(&CA::OGL::MetalContext::tile_shader_type_info + 2 * a2);
  id v53 = 0;
  shader_function = CA::OGL::MetalContext::load_shader_function(a1, *(void **)(a1 + 3336), v12, 0, 0, 0, (uint64_t)&v53);
  if (!shader_function)
  {
    bzero(__str, 0x7FFuLL);
    uint64_t v47 = (const char *)[v12 UTF8String];
    if (v53) {
      double v48 = (const char *)objc_msgSend((id)objc_msgSend(v53, "localizedDescription"), "UTF8String");
    }
    else {
      double v48 = "";
    }
    snprintf(__str, 0x800uLL, "function=%s\n%s", v47, v48);
    char v59 = 0;
    if (!x_log_hook_p())
    {
      unint64_t v51 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        int v55 = "Metal failed to load compute shader";
        __int16 v56 = 2080;
        uint64_t v57 = __str;
        _os_log_impl(&dword_184668000, v51, OS_LOG_TYPE_ERROR, "%s: %s\n", buf, 0x16u);
      }
      goto LABEL_133;
    }
    goto LABEL_125;
  }
  id v14 = (id)objc_opt_new();
  [v14 setLabel:objc_msgSend(NSString, "stringWithFormat:", @"com.apple.coreanimation.%@", v12)];
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(v14, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setPixelFormat:", a3);
  if ((*(_WORD *)(a1 + 3328) & 8) != 0)
  {
    if (a3 > 89)
    {
      uint64_t v16 = 110;
      if (a3 == 90 || a3 == 94) {
        goto LABEL_35;
      }
      if (a3 == 554)
      {
        if (CADeviceIsVirtualized::once != -1) {
          dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
        }
        if (CADeviceIsVirtualized::is_virtualized) {
          uint64_t v16 = 115;
        }
        else {
          uint64_t v16 = 550;
        }
        goto LABEL_35;
      }
    }
    else
    {
      switch(a3)
      {
        case 10:
          uint64_t v16 = 30;
          goto LABEL_35;
        case 43:
          uint64_t v16 = 80;
          goto LABEL_35;
        case 63:
          uint64_t v16 = 113;
LABEL_35:
          objc_msgSend((id)objc_msgSend((id)objc_msgSend(v14, "colorAttachments"), "objectAtIndexedSubscript:", 1), "setPixelFormat:", CA::OGL::non_srgb_pixel_format(v16, v15));
          goto LABEL_36;
      }
    }
    uint64_t v16 = a3;
    goto LABEL_35;
  }
LABEL_36:
  [v14 setThreadgroupSizeMatchesTileSize:0];
  [v14 setTileFunction:shader_function];

  uint64_t v45 = [*(id *)(a1 + 2952) newRenderPipelineStateWithTileDescriptor:v14 options:0 reflection:0 error:&v53];
  if (!v45)
  {
    bzero(__str, 0x7FFuLL);
    Name = (const char *)MTLPixelFormatGetName();
    double v50 = (const char *)[v12 UTF8String];
    snprintf(__str, 0x800uLL, "tile_pipeline=%s_%s\n%s", Name, v50, (const char *)objc_msgSend((id)objc_msgSend(v53, "localizedDescription"), "UTF8String"));
    char v59 = 0;
    if (!x_log_hook_p())
    {
      uint64_t v52 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        int v55 = "Metal failed to build render pipeline";
        __int16 v56 = 2080;
        uint64_t v57 = __str;
        _os_log_impl(&dword_184668000, v52, OS_LOG_TYPE_ERROR, "%s: %s\n", buf, 0x16u);
      }
      goto LABEL_133;
    }
LABEL_125:
    x_log_();
LABEL_133:
    strlen(__str);
    uint64_t result = abort_with_payload();
    __break(1u);
    return result;
  }
  unint64_t v17 = *(void *)(a1 + 2616);
  if (v17)
  {
    uint8x8_t v18 = (uint8x8_t)vcnt_s8((int8x8_t)v17);
    v18.i16[0] = vaddlv_u8(v18);
    if (v18.u32[0] > 1uLL)
    {
      unint64_t v19 = v5;
      if (v17 <= v5) {
        unint64_t v19 = v5 % v17;
      }
    }
    else
    {
      unint64_t v19 = (v17 - 1) & v5;
    }
    unint64_t v20 = *(void ***)(*(void *)(a1 + 2608) + 8 * v19);
    if (v20)
    {
      int64_t v21 = *v20;
      if (*v20)
      {
        do
        {
          unint64_t v22 = v21[1];
          if (v22 == v5)
          {
            if (*((_DWORD *)v21 + 4) == v5) {
              goto LABEL_109;
            }
          }
          else
          {
            if (v18.u32[0] > 1uLL)
            {
              if (v22 >= v17) {
                v22 %= v17;
              }
            }
            else
            {
              v22 &= v17 - 1;
            }
            if (v22 != v19) {
              break;
            }
          }
          int64_t v21 = (void *)*v21;
        }
        while (v21);
      }
    }
  }
  else
  {
    unint64_t v19 = 0;
  }
  int64_t v21 = operator new(0x20uLL);
  *int64_t v21 = 0;
  v21[1] = v5;
  *((_DWORD *)v21 + 4) = v5;
  float v23 = (float)(unint64_t)(*(void *)(a1 + 2632) + 1);
  v21[3] = 0;
  float v24 = *(float *)(a1 + 2640);
  if ((((float)(v24 * (float)v17) >= v23) & ~(v17 == 0)) != 0)
  {
    unint64_t v5 = v19;
    goto LABEL_99;
  }
  BOOL v25 = 1;
  if (v17 >= 3) {
    BOOL v25 = (v17 & (v17 - 1)) != 0;
  }
  unint64_t v26 = v25 | (2 * v17);
  unint64_t v27 = vcvtps_u32_f32(v23 / v24);
  if (v26 <= v27) {
    int8x8_t prime = (int8x8_t)v27;
  }
  else {
    int8x8_t prime = (int8x8_t)v26;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v17 = *(void *)(a1 + 2616);
  }
  if (*(void *)&prime > v17) {
    goto LABEL_66;
  }
  if (*(void *)&prime < v17)
  {
    unint64_t v35 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 2632) / *(float *)(a1 + 2640));
    if (v17 < 3 || (uint8x8_t v36 = (uint8x8_t)vcnt_s8((int8x8_t)v17), v36.i16[0] = vaddlv_u8(v36), v36.u32[0] > 1uLL))
    {
      unint64_t v35 = std::__next_prime(v35);
    }
    else
    {
      uint64_t v37 = 1 << -(char)__clz(v35 - 1);
      if (v35 >= 2) {
        unint64_t v35 = v37;
      }
    }
    if (*(void *)&prime <= v35) {
      int8x8_t prime = (int8x8_t)v35;
    }
    if (*(void *)&prime >= v17)
    {
      unint64_t v17 = *(void *)(a1 + 2616);
    }
    else
    {
      if (prime)
      {
LABEL_66:
        if (*(void *)&prime >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v29 = operator new(8 * *(void *)&prime);
        __int16 v30 = *(void **)(a1 + 2608);
        *(void *)(a1 + 2608) = v29;
        if (v30) {
          operator delete(v30);
        }
        uint64_t v31 = 0;
        *(int8x8_t *)(a1 + 2616) = prime;
        do
          *(void *)(*(void *)(a1 + 2608) + 8 * v31++) = 0;
        while (*(void *)&prime != v31);
        uint64_t v32 = *(void **)(a1 + 2624);
        if (v32)
        {
          unint64_t v33 = v32[1];
          uint8x8_t v34 = (uint8x8_t)vcnt_s8(prime);
          v34.i16[0] = vaddlv_u8(v34);
          if (v34.u32[0] > 1uLL)
          {
            if (v33 >= *(void *)&prime) {
              v33 %= *(void *)&prime;
            }
          }
          else
          {
            v33 &= *(void *)&prime - 1;
          }
          *(void *)(*(void *)(a1 + 2608) + 8 * v33) = a1 + 2624;
          long long v38 = (void *)*v32;
          if (*v32)
          {
            do
            {
              unint64_t v39 = v38[1];
              if (v34.u32[0] > 1uLL)
              {
                if (v39 >= *(void *)&prime) {
                  v39 %= *(void *)&prime;
                }
              }
              else
              {
                v39 &= *(void *)&prime - 1;
              }
              if (v39 != v33)
              {
                uint64_t v40 = *(void *)(a1 + 2608);
                if (!*(void *)(v40 + 8 * v39))
                {
                  *(void *)(v40 + 8 * v39) = v32;
                  goto LABEL_91;
                }
                *uint64_t v32 = *v38;
                *long long v38 = **(void **)(*(void *)(a1 + 2608) + 8 * v39);
                **(void **)(*(void *)(a1 + 2608) + 8 * v39) = v38;
                long long v38 = v32;
              }
              unint64_t v39 = v33;
LABEL_91:
              uint64_t v32 = v38;
              long long v38 = (void *)*v38;
              unint64_t v33 = v39;
            }
            while (v38);
          }
        }
        unint64_t v17 = (unint64_t)prime;
        goto LABEL_95;
      }
      uint64_t v46 = *(void **)(a1 + 2608);
      *(void *)(a1 + 2608) = 0;
      if (v46) {
        operator delete(v46);
      }
      unint64_t v17 = 0;
      *(void *)(a1 + 2616) = 0;
    }
  }
LABEL_95:
  if ((v17 & (v17 - 1)) != 0)
  {
    if (v17 <= v5) {
      v5 %= v17;
    }
  }
  else
  {
    unint64_t v5 = (v17 - 1) & v5;
  }
LABEL_99:
  uint64_t v41 = *(void *)(a1 + 2608);
  uint64_t v42 = *(void **)(v41 + 8 * v5);
  if (v42)
  {
    *int64_t v21 = *v42;
LABEL_107:
    *uint64_t v42 = v21;
    goto LABEL_108;
  }
  *int64_t v21 = *(void *)(a1 + 2624);
  *(void *)(a1 + 2624) = v21;
  *(void *)(v41 + 8 * v5) = a1 + 2624;
  if (*v21)
  {
    unint64_t v43 = *(void *)(*v21 + 8);
    if ((v17 & (v17 - 1)) != 0)
    {
      if (v43 >= v17) {
        v43 %= v17;
      }
    }
    else
    {
      v43 &= v17 - 1;
    }
    uint64_t v42 = (void *)(*(void *)(a1 + 2608) + 8 * v43);
    goto LABEL_107;
  }
LABEL_108:
  ++*(void *)(a1 + 2632);
LABEL_109:
  v21[3] = v45;
  return v45;
}

void sub_1846DD0AC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::OGL::MetalContext::clear_memoryless_texture_(uint64_t a1, uint64_t a2)
{
  __dst[61] = *MEMORY[0x1E4F143B8];
  *(_WORD *)(a2 + 75) &= ~0x20u;
  uint64_t v14 = 0x3C003C003C003C00;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  v12[0] = 0;
  long long v13 = 0u;
  uint64_t v18 = 0x4013F800000;
  v12[1] = &CA::Shape::_infinite_shape;
  int v4 = *(unsigned __int8 *)(a1 + 64);
  *(unsigned char *)(a1 + 64) = 0;
  unint64_t v5 = *(const void **)(a1 + 16);
  memcpy(__dst, v5, 0x1E8uLL);
  __dst[0] = v5;
  *(void *)(a1 + 16) = __dst;
  v12[0] = CA::OGL::Context::set_gstate(a1, (uint64_t)v12);
  *(unsigned char *)(*(void *)(a1 + 16) + 481) &= ~1u;
  uint64_t v6 = *(void *)(a1 + 816);
  if (v6)
  {
    *(void *)(a1 + 816) = 0;
    ++*(_DWORD *)(a1 + 256);
  }
  *(unsigned char *)(*(void *)(a1 + 16) + 16) = 98;
  int32x2_t v7 = *(int32x2_t *)(a2 + 32);
  float32x2_t v8 = vcvt_f32_s32(v7);
  float32x2_t v9 = vcvt_f32_s32(vadd_s32(*(int32x2_t *)(a2 + 40), v7));
  v11[0] = v8;
  v11[1] = v9;
  v11[2] = 0;
  CA::OGL::MetalContext::draw_axis_aligned_rects((CA::OGL::Context *)a1, 1, (int)v11);
  if (v6)
  {
    *(void *)(a1 + 816) = v6;
    ++*(_DWORD *)(a1 + 256);
  }
  uint64_t result = CA::OGL::Context::set_gstate(a1, **(void **)(a1 + 248));
  *(void *)(a1 + 16) = __dst[0];
  if (v4) {
    *(unsigned char *)(a1 + 64) = 1;
  }
  return result;
}

void sub_1846DD248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  if (!a23) {
    _Unwind_Resume(a1);
  }
  __assert_rtn("~ContextState", "ogl-context.h", 551, "!next && \"Imbalanced ContextState push/pop\"");
}

uint64_t CA::OGL::MetalContext::draw_axis_aligned_rects(CA::OGL::Context *a1, int a2, int a3)
{
  int v3 = *(unsigned __int8 *)(*((void *)a1 + 2) + 16);
  if ((v3 - 90) >= 3 && v3 != 98) {
    __assert_rtn("draw_axis_aligned_rects", "ogl-metal.mm", 8349, "get_texture_function () == OGL_TEX_PATH_CLEAR || get_texture_function () == OGL_TEX_PATH_BLIT || get_texture_function () == OGL_TEX_PATH_BLIT_EO || get_texture_function () == OGL_TEX_ATTACHMENT_CLEAR");
  }
  return CA::OGL::MetalContext::draw(a1, 4, 4, a2, a3, 24, 8, 0, a2, 0, 0, 0);
}

uint64_t CA::HalfFloat::convert_float_array(uint64_t this, float32x4_t *a2, const float *a3)
{
  if (((a2 | this) & 0xF) != 0)
  {
    if ((unint64_t)a3 >= 4)
    {
      do
      {
        float32x4_t v15 = *a2++;
        *(float16x4_t *)this = vcvt_f16_f32(v15);
        this += 8;
        --a3;
      }
      while ((unint64_t)a3 > 3);
    }
    for (; a3; a3 = (const float *)((char *)a3 - 1))
    {
      __int32 v16 = a2->i32[0];
      a2 = (float32x4_t *)((char *)a2 + 4);
      _S0 = v16;
      __asm { FCVT            H0, S0 }
      *(_WORD *)this = _S0;
      this += 2;
    }
  }
  else
  {
    if ((unint64_t)a3 >= 0x10)
    {
      do
      {
        float32x4_t v4 = a2[2];
        float32x4_t v3 = a2[3];
        float32x4_t v6 = *a2;
        float32x4_t v5 = a2[1];
        a2 += 4;
        *(float16x8_t *)this = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v6), v5);
        *(float16x8_t *)(this + 16) = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v4), v3);
        this += 32;
        a3 -= 4;
      }
      while ((unint64_t)a3 > 0xF);
    }
    if ((unint64_t)a3 >= 4)
    {
      do
      {
        float32x4_t v7 = *a2++;
        *(float16x4_t *)this = vcvt_f16_f32(v7);
        this += 8;
        --a3;
      }
      while ((unint64_t)a3 > 3);
    }
    if (a3 != (const float *)1)
    {
      if (a3 != (const float *)2)
      {
        if (a3 != (const float *)3) {
          return this;
        }
        _S0 = a2->i32[2];
        __asm { FCVT            H0, S0 }
        *(_WORD *)(this + 4) = _S0;
      }
      _S0 = a2->i32[1];
      __asm { FCVT            H0, S0 }
      *(_WORD *)(this + 2) = _S0;
    }
    _S0 = a2->i32[0];
    __asm { FCVT            H0, S0 }
    *(_WORD *)this = _S0;
  }
  return this;
}

void *CA::OGL::MetalBufferPool::create_external_buffer(CA::OGL::MetalBufferPool *this, unsigned int a2, unint64_t a3, uint64_t a4)
{
  if (!a2) {
    return 0;
  }
  if (!a4)
  {
    unint64_t v20 = (_OWORD *)*((void *)this + 6);
    if (!v20)
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      unint64_t v20 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x20uLL, 0x743898A5uLL);
      if (v20)
      {
        *unint64_t v20 = 0u;
        v20[1] = 0u;
      }
      *((void *)this + 6) = v20;
    }
    unint64_t v22 = *((unsigned int *)this + 11);
    if (v22 <= a3) {
      unint64_t v22 = a3;
    }
    unint64_t v23 = v22 - 1 + *((unsigned int *)v20 + 4);
    unint64_t v24 = v23 / v22 * v22;
    unint64_t v25 = v23 & -(uint64_t)v22;
    if ((v22 & (v22 - 1)) != 0) {
      unsigned int v26 = v24;
    }
    else {
      unsigned int v26 = v25;
    }
    if (*(void *)v20)
    {
      if (*((_DWORD *)v20 + 5) >= v26 + a2)
      {
LABEL_29:
        *((_DWORD *)v20 + 4) = v26 + a2;
        ++*((_DWORD *)v20 + 6);
        uint64_t v32 = (malloc_zone_t *)get_malloc_zone();
        uint64_t result = malloc_type_zone_calloc(v32, 1uLL, 0x30uLL, 0x743898A5uLL);
        uint64_t v33 = *((void *)this + 6);
        void *result = *(void *)(v33 + 8) + v26;
        result[1] = a2;
        result[3] = v33;
        result[4] = **((void **)this + 6);
        *((_DWORD *)result + 10) = v26;
        return result;
      }
      if (*((_DWORD *)v20 + 6))
      {
        unint64_t v27 = (malloc_zone_t *)get_malloc_zone();
        __int16 v28 = malloc_type_zone_calloc(v27, 1uLL, 0x20uLL, 0x743898A5uLL);
        if (v28)
        {
          *__int16 v28 = 0u;
          v28[1] = 0u;
        }
        *((void *)this + 6) = v28;
      }
      else
      {
        CA::OGL::MetalBufferPool::retire_metal_buffer((uint64_t)this, *(void *)v20);
        **((void **)this + 6) = 0;
      }
    }
    uint64_t result = CA::OGL::MetalBufferPool::allocate_buffer((os_unfair_lock_s *)this, a2);
    **((void **)this + 6) = result;
    if (!result) {
      return result;
    }
    uint64_t v29 = [result contents];
    uint64_t v30 = *((void *)this + 6);
    *(void *)(v30 + 8) = v29;
    int v31 = [*(id *)v30 length];
    unsigned int v26 = 0;
    unint64_t v20 = (_OWORD *)*((void *)this + 6);
    *((_DWORD *)v20 + 5) = v31;
    goto LABEL_29;
  }
  float32x2_t v8 = *(void **)this;
  id v9 = (id)objc_opt_new();
  uint64_t v10 = v9;
  unint64_t v11 = a3 - 1 + a2;
  unint64_t v12 = v11 / a3 * a3;
  unint64_t v13 = v11 & -(uint64_t)a3;
  if ((a3 & (a3 - 1)) != 0) {
    unint64_t v14 = v12;
  }
  else {
    unint64_t v14 = v13;
  }
  [v9 setSize:v14];
  [v10 setProtectionOptions:a4];
  [v10 setHazardTrackingMode:2];
  uint64_t result = (void *)[v8 newHeapWithDescriptor:v10];
  if (result)
  {
    __int32 v16 = result;
    uint64_t v17 = [result newBufferWithLength:a2 options:32];
    if (v17)
    {
      uint64_t v18 = v17;
      unint64_t v19 = (malloc_zone_t *)get_malloc_zone();
      uint64_t result = malloc_type_zone_calloc(v19, 1uLL, 0x30uLL, 0x743898A5uLL);
      result[1] = a2;
      result[2] = a4;
      result[3] = v16;
      result[4] = v18;
    }
    else
    {

      return 0;
    }
  }
  return result;
}

void CA::OGL::MetalBufferPool::release_external_buffer(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 16))
  {
  }
  else
  {
    uint64_t v3 = *(void *)(a2 + 24);
    int v4 = *(_DWORD *)(v3 + 24) - 1;
    *(_DWORD *)(v3 + 24) = v4;
    if (!v4 && *(void *)(a1 + 48) != v3)
    {
      CA::OGL::MetalBufferPool::retire_metal_buffer(a1, *(void *)v3);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, (void *)v3);
    }
  }
  float32x4_t v6 = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(v6, (void *)a2);
}

intptr_t ___ZN2CA3OGL16AsynchronousItem20retain_latest_bufferERNS0_7ContextEb_block_invoke(intptr_t result)
{
  uint64_t v1 = *(atomic_uint **)(result + 32);
  if (!*(unsigned char *)(result + 48)) {
    uint64_t result = dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(result + 40) + 24));
  }
  unsigned int add = atomic_fetch_add(v1 + 2, 0xFFFFFFFF);
  if (v1) {
    BOOL v3 = add == 1;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3)
  {
    int v4 = *(uint64_t (**)(atomic_uint *))(*(void *)v1 + 8);
    return v4(v1);
  }
  return result;
}

void CA::OGL::MetalContext::copy_submitted_callbacks(uint64_t a1, void *a2)
{
  v8[5] = *MEMORY[0x1E4F143B8];
  BOOL v3 = *(const void ***)(a1 + 3064);
  int v4 = *(const void ***)(a1 + 3072);
  if (v3 != v4)
  {
    uint64_t v6 = MEMORY[0x1E4F143A8];
    do
    {
      float32x4_t v7 = *v3++;
      v8[0] = v6;
      v8[1] = 3221225472;
      v8[2] = ___ZN2CA3OGL12MetalContext24copy_submitted_callbacksEPU27objcproto16MTLCommandBuffer11objc_object_block_invoke;
      v8[3] = &unk_1E527BE88;
      v8[4] = v7;
      [a2 addScheduledHandler:v8];
      _Block_release(v7);
    }
    while (v3 != v4);
    BOOL v3 = *(const void ***)(a1 + 3064);
  }
  *(void *)(a1 + 3072) = v3;
}

void std::deque<objc_object  {objcproto9MTLBuffer}*>::__maybe_remove_front_spare[abi:nn180100](uint64_t a1)
{
  if (*(void *)(a1 + 32) >= 0x400uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 512;
  }
}

intptr_t ___ZN2CA3OGL16AsynchronousItem12first_bufferERNS0_7ContextEPNS_6Render6HandleE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(atomic_uint **)(a1 + 32);
  intptr_t result = dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(a1 + 40) + 24));
  unsigned int add = atomic_fetch_add(v1 + 2, 0xFFFFFFFF);
  if (v1) {
    BOOL v4 = add == 1;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    float32x4_t v5 = *(uint64_t (**)(atomic_uint *))(*(void *)v1 + 8);
    return v5(v1);
  }
  return result;
}

uint64_t CA::Render::copy_elements(uint64_t this, void *a2, const CGPathElement *a3)
{
  char v3 = CA::Render::cgpath_types[*(int *)a2];
  BOOL v4 = *(char **)(this + 24);
  *(void *)(this + 24) = v4 + 1;
  char *v4 = v3;
  uint64_t v5 = *(int *)a2;
  if (v5 != 4)
  {
    LODWORD(v6) = cgpath_counts[v5];
    float32x4_t v7 = (long long *)a2[1];
    float32x2_t v8 = *(_OWORD **)(this + 32);
    if ((int)v6 <= 1) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = v6;
    }
    do
    {
      long long v9 = *v7++;
      *v8++ = v9;
      --v6;
    }
    while (v6);
    *(void *)(this + 32) = v8;
  }
  return this;
}

uint64_t CA::Render::Server::server_thread(CA::Render::Server *this, void *a2)
{
  MEMORY[0x1F4188790](this);
  char v3 = v2;
  uint64_t v190 = *MEMORY[0x1E4F143B8];
  int v4 = pthread_setname_np("com.apple.coreanimation.render-server");
  if (v4)
  {
    mach_port_t v5 = v4;
    uint64_t v6 = x_log_category_utilities;
    if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
    {
      policy_info[0].uint64_t msgh_bits = 136315394;
      *(void *)&policy_info[0].msgh_size = "com.apple.coreanimation.render-server";
      LOWORD(policy_info[0].msgh_local_port) = 1024;
      *(mach_port_t *)((char *)&policy_info[0].msgh_local_port + 2) = v5;
      _os_log_error_impl(&dword_184668000, v6, OS_LOG_TYPE_ERROR, "pthread_setname_np(%s) returned %d\n", (uint8_t *)policy_info, 0x12u);
    }
  }
  pthread_mutex_lock(&CA::Render::Server::_mutex);
  CA::Render::Server::_thread = (uint64_t)pthread_self();
  unsigned char *v3 = 1;
  pthread_cond_broadcast(&CA::Render::Server::_cond);
  pthread_mutex_unlock(&CA::Render::Server::_mutex);
  float32x4_t v7 = getenv("CA_BENCHMARK");
  float32x2_t v8 = (ipc_space_t *)MEMORY[0x1E4F14960];
  if (v7 && atoi(v7))
  {
    policy_info[0].uint64_t msgh_bits = 0;
    thread_act_t v9 = MEMORY[0x185324740]();
    thread_policy_set(v9, 1u, (thread_policy_t)policy_info, 1u);
    mach_port_deallocate(*v8, v9);
  }
  bzero(policy_info, 0x4000uLL);
  double v11 = 0.0;
  do
  {
    while (1)
    {
      unint64_t v12 = (CA::Render::Server *)MEMORY[0x185324A30](v10);
      unint64_t v13 = v12;
      if (!CA::Render::Server::_callback_list)
      {
        double v17 = 0.0;
        if (v11 == 0.0) {
          goto LABEL_31;
        }
        goto LABEL_28;
      }
      uint64_t v14 = mach_absolute_time();
      double v15 = CATimeWithHostTime(v14);
      while (1)
      {
        os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Server::_callback_lock);
        uint64_t v16 = CA::Render::Server::_callback_list;
        if (!CA::Render::Server::_callback_list) {
          break;
        }
        double v17 = *(double *)(CA::Render::Server::_callback_list + 8);
        if (v15 < v17) {
          goto LABEL_24;
        }
        CA::Render::Server::_callback_list = *(void *)CA::Render::Server::_callback_list;
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_callback_lock);
        v18.n128_u64[0] = *(void *)(v16 + 8);
        double v19 = *(double *)(v16 + 16);
        if (v18.n128_f64[0] >= v19) {
          double v19 = *(double *)(v16 + 8);
        }
        double v20 = v15 - v19;
        if (v15 - v19 > 1.0)
        {
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            unint64_t v22 = x_log_category_render;
            if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v187) = 134217984;
              *(double *)((char *)&v187 + 4) = v20;
              _os_log_impl(&dword_184668000, v22, OS_LOG_TYPE_ERROR, "Render::Server callback delayed by %.2fs", (uint8_t *)&v187, 0xCu);
            }
          }
          v18.n128_u64[0] = *(void *)(v16 + 8);
        }
        if (v15 > v18.n128_f64[0]) {
          v18.n128_f64[0] = v15;
        }
        (*(void (**)(void, __n128))(v16 + 24))(*(void *)(v16 + 32), v18);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, (void *)v16);
      }
      double v17 = 0.0;
LABEL_24:
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_callback_lock);
      if (v11 != v17)
      {
        if (v17 > 0.0)
        {
          CA::Render::Server::timer_port(v12);
          CAHostTimeWithTime(v17);
          unint64_t v12 = (CA::Render::Server *)mk_timer_arm_leeway();
LABEL_30:
          double v11 = v17;
          goto LABEL_31;
        }
LABEL_28:
        if (v11 > 0.0)
        {
          CA::Render::Server::timer_port(v12);
          unint64_t v12 = (CA::Render::Server *)mk_timer_cancel();
        }
        goto LABEL_30;
      }
LABEL_31:
      mach_port_name_t v23 = CA::Render::Server::port_set(v12);
      uint64_t v24 = mach_msg(policy_info, 50333710, 0, 0x4000u, v23, 0, 0);
      if (!v24)
      {
        int v31 = 0;
        unint64_t v32 = policy_info[0].msgh_size + 3;
        uint64_t v33 = (v32 & 0x1FFFFFFFCLL) + 68;
        BOOL v34 = v32 >> 2 >= 0xFEF;
        uint64_t v35 = 0x4000;
        if (!v34) {
          uint64_t v35 = v33;
        }
        size_t v182 = v35;
        uint64_t v29 = policy_info;
        goto LABEL_46;
      }
      uint64_t v25 = v24;
      if (v24 == 268451844) {
        break;
      }
LABEL_38:
      if (v25 == 268451843) {
        goto LABEL_82;
      }
      if (CADeviceHasInternalBuild::once[0] != -1) {
        dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
      }
      if (CADeviceHasInternalBuild::internal)
      {
        if (v25 == 268455948) {
          CARenderServerDumpVMRegions();
        }
        x_log_crash("CoreAnimation: mach_msg returned 0x%x!\n");
LABEL_379:
        abort();
      }
LABEL_81:
      CA::Render::Server::error_jump_table[0] = (uint64_t)CA::Render::Server::ca_mach_msg_error_0;
      qword_1E8F880D0 = (uint64_t)CA::Render::Server::ca_mach_msg_error_1;
      qword_1E8F880D8 = (uint64_t)CA::Render::Server::ca_mach_msg_error_2;
      qword_1E8F880E0 = (uint64_t)CA::Render::Server::ca_mach_msg_error_3;
      qword_1E8F880E8 = (uint64_t)CA::Render::Server::ca_mach_msg_error_4;
      qword_1E8F880F0 = (uint64_t)CA::Render::Server::ca_mach_msg_error_5;
      qword_1E8F880F8 = (uint64_t)CA::Render::Server::ca_mach_msg_error_6;
      qword_1E8F88100 = (uint64_t)CA::Render::Server::ca_mach_msg_error_7;
      qword_1E8F88108 = (uint64_t)CA::Render::Server::ca_mach_msg_error_8;
      qword_1E8F88110 = (uint64_t)CA::Render::Server::ca_mach_msg_error_9;
      qword_1E8F88118 = (uint64_t)CA::Render::Server::ca_mach_msg_error_a;
      qword_1E8F88120 = (uint64_t)CA::Render::Server::ca_mach_msg_error_b;
      qword_1E8F88128 = (uint64_t)CA::Render::Server::ca_mach_msg_error_c;
      qword_1E8F88130 = (uint64_t)CA::Render::Server::ca_mach_msg_error_d;
      qword_1E8F88138 = (uint64_t)CA::Render::Server::ca_mach_msg_error_e;
      qword_1E8F88140 = (uint64_t)CA::Render::Server::ca_mach_msg_error_f;
      ((void (*)(uint64_t, uint64_t))CA::Render::Server::error_jump_table[v25 & 0xF])(v25, 4);
LABEL_82:
    }
    mach_port_t msgh_local_port = policy_info[0].msgh_local_port;
    mach_msg_size_t v27 = ((policy_info[0].msgh_size + 3) & 0xFFFFFFFC) + 68;
    __int16 v28 = (mach_msg_header_t *)malloc_type_calloc(1uLL, ((policy_info[0].msgh_size + 3) & 0x1FFFFFFFCLL) + 68, 0xEF1217AEuLL);
    if (!v28)
    {
      mach_msg(0, 2, 0, 0, msgh_local_port, 0, 0);
      if (CADeviceHasInternalBuild::once[0] != -1) {
        dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
      }
      if (CADeviceHasInternalBuild::internal)
      {
        x_log_crash("Couldn't allocate buffer of %zu bytes for message!");
        goto LABEL_379;
      }
      uint64_t v25 = 268451844;
      goto LABEL_81;
    }
    uint64_t v29 = v28;
    uint64_t v30 = mach_msg(v28, 50333698, 0, v27, msgh_local_port, 0, 0);
    if (v30)
    {
      uint64_t v25 = v30;
      free(v29);
      if (CADeviceHasInternalBuild::once[0] != -1) {
        dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
      }
      if (CADeviceHasInternalBuild::internal)
      {
        x_log_crash("CoreAnimation: mach_msg returned 0x%x for retry with size:%zu\n");
        goto LABEL_379;
      }
      goto LABEL_38;
    }
    size_t v182 = 0;
    int v31 = 1;
LABEL_46:
    state = voucher_mach_msg_adopt(v29);
    mach_port_t v36 = v29->msgh_local_port;
    uint64_t v37 = (CA::Render::Server *)CA::Render::Server::notify_port(state);
    if (v36 == v37)
    {
      long long v38 = (mach_msg_bits_t *)((char *)&v29->msgh_bits + ((v29->msgh_size + 3) & 0x1FFFFFFFCLL));
      if (!*v38 && v38[1] >= 0x34u && !v38[10])
      {
        mach_msg_id_t msgh_id = v29->msgh_id;
        if (msgh_id == 70)
        {
          if (CA::Render::Fence::fence_info_once[0] != -1) {
            dispatch_once_f(CA::Render::Fence::fence_info_once, 0, (dispatch_function_t)CA::Render::Fence::fence_info_init);
          }
          os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Fence::_lock);
          uint64_t v69 = *(void **)(CA::Render::Fence::fences_by_name + 16);
          if (v69)
          {
            char v70 = 0;
LABEL_128:
            int v71 = (void *)CA::Render::Fence::cleared_f_names;
            do
            {
              attributes = (CA::Render::Fence *)std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(v71, v69[2]);
              if (!attributes)
              {
                mach_port_name_t v73 = *(_DWORD *)(v69[3] + 16);
                uint64_t v189 = 0;
                long long v188 = 0u;
                long long v187 = 0u;
                port_info_outCnt[0] = 10;
                attributes = (CA::Render::Fence *)mach_port_get_attributes(*v8, v73, 2, (mach_port_info_t)&v187, port_info_outCnt);
                int v71 = (void *)CA::Render::Fence::cleared_f_names;
                if (attributes || DWORD2(v188) == 0)
                {
                  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(CA::Render::Fence::cleared_f_names, v69[2], v69[2]);
                  uint64_t v69 = (void *)*v69;
                  char v70 = 1;
                  if (v69) {
                    goto LABEL_128;
                  }
                  goto LABEL_150;
                }
              }
              uint64_t v69 = (void *)*v69;
            }
            while (v69);
            if ((v70 & 1) == 0) {
              goto LABEL_151;
            }
LABEL_150:
            CA::Render::Fence::resolve_fences(attributes);
          }
LABEL_151:
          v80 = *(uint64_t **)(CA::Render::Fence::batches_by_port + 16);
          if (v80)
          {
            char v81 = 0;
LABEL_153:
            char v179 = v81;
            do
            {
              mach_port_name_t v82 = *((_DWORD *)v80 + 4);
              if (!std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::cleared_b_ports, v82)&& *(double *)(v80[3] + 16) == 0.0)
              {
                uint64_t v189 = 0;
                long long v188 = 0u;
                long long v187 = 0u;
                port_info_outCnt[0] = 10;
                if (mach_port_get_attributes(*v8, v82, 2, (mach_port_info_t)&v187, port_info_outCnt)
                  || DWORD2(v188) == 0)
                {
                  uint64_t v84 = v80[3];
                  unint64_t v85 = *(uint64_t **)(*(void *)(v84 + 32) + 16);
                  if (v85)
                  {
                    double v86 = (void *)CA::Render::Fence::bcontexts_by_id;
                    do
                    {
                      uint64_t v87 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v86, *((_DWORD *)v85 + 4));
                      if (v87)
                      {
                        double v88 = CA::Render::Context::delay_of_batch(*(os_unfair_lock_s **)v87[3], *((_DWORD *)v80 + 4));
                        uint64_t v84 = v80[3];
                        double v86 = (void *)CA::Render::Fence::bcontexts_by_id;
                        if (v88 > *(double *)(v84 + 16)
                          && (*(void *)(v84 + 16) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                        {
                          *(double *)(v84 + 16) = v88;
                        }
                      }
                      unint64_t v85 = (uint64_t *)*v85;
                    }
                    while (v85);
                  }
                  double v90 = *(double *)(v84 + 16);
                  if (v90 == 0.0 || (uint64_t v91 = mach_absolute_time(), v90 <= CATimeWithHostTime(v91)))
                  {
                    std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(CA::Render::Fence::cleared_b_ports, *((_DWORD *)v80 + 4), *((_DWORD *)v80 + 4));
                    v80 = (uint64_t *)*v80;
                    char v81 = 1;
                    float32x2_t v8 = (ipc_space_t *)MEMORY[0x1E4F14960];
                    if (v80) {
                      goto LABEL_153;
                    }
                    goto LABEL_179;
                  }
                  CA::Render::Server::add_callback(3, (uint64_t)CA::Render::Fence::btimeout_callback, 0, *(double *)(v80[3] + 16));
                  float32x2_t v8 = (ipc_space_t *)MEMORY[0x1E4F14960];
                }
              }
              v80 = (uint64_t *)*v80;
            }
            while (v80);
            if ((v179 & 1) == 0) {
              goto LABEL_180;
            }
LABEL_179:
            uint64_t v92 = mach_absolute_time();
            double v93 = CATimeWithHostTime(v92);
            CA::Render::Fence::resolve_batches(v94, v93);
          }
LABEL_180:
          os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Fence::_lock);
        }
        else if (msgh_id == 72)
        {
          while (1)
          {
            uint64_t v66 = (CA::Render::Context *)CA::Render::Context::context_by_client_port((CA::Render::Context *)v29[1].msgh_remote_port);
            if (!v66) {
              break;
            }
            uint64_t v67 = (atomic_uint *)v66;
            CA::Render::Context::destroy(v66);
            if (atomic_fetch_add(v67 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v67 + 16))(v67);
            }
          }
          os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Server::_dead_name_watch_list_lock);
          CA::Render::Server::dead_name_watch_list(v75);
          uint64_t v76 = std::__hash_table<std::__hash_value_type<unsigned int,BOOL (*)>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,BOOL (*)>>>::find<unsigned int>(v29[1].msgh_remote_port);
          if (v76)
          {
            v77 = (void (*)(void))v76[3];
            std::__hash_table<std::__hash_value_type<unsigned int,BOOL (*)>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,BOOL (*)>>>::erase(v76);
            os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_dead_name_watch_list_lock);
            if (v77) {
              v77(v29[1].msgh_remote_port);
            }
          }
          else
          {
            os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_dead_name_watch_list_lock);
          }
          mach_port_deallocate(*v8, v29[1].msgh_remote_port);
        }
      }
      unint64_t v39 = v29;
LABEL_51:
      mach_msg_destroy(v39);
LABEL_52:
      int v40 = 0;
      goto LABEL_117;
    }
    mach_port_t v41 = v29->msgh_local_port;
    if (v41 == CA::Render::Server::timer_port(v37)) {
      goto LABEL_115;
    }
    mach_msg_id_t v42 = v29->msgh_id;
    if ((v42 - 40000) > 0xC7)
    {
      if ((v42 - 40200) <= 0xC7)
      {
        bzero(&v187, 0x354uLL);
        mach_port_t msgh_remote_port = v29->msgh_remote_port;
        LODWORD(v187) = v29->msgh_bits & 0x1F;
        DWORD1(v187) = 36;
        int v56 = v29->msgh_id + 100;
        *((void *)&v187 + 1) = msgh_remote_port;
        LODWORD(v188) = 0;
        DWORD1(v188) = v56;
        mach_msg_id_t v57 = v29->msgh_id;
        if ((v57 - 40291) >= 0xFFFFFFA5
          && (uint64_t v58 = CASCARenderServices_subsystem[5 * (v57 - 40200) + 5]) != 0)
        {
          ((void (*)(mach_msg_header_t *, long long *))v58)(v29, &v187);
          if (!DWORD2(v187)) {
            goto LABEL_52;
          }
          char v59 = (mach_msg_header_t *)&v187;
          if ((mach_msg((mach_msg_header_t *)&v187, 1, DWORD1(v187), 0, 0, 0, 0) - 268435459) >= 2) {
            goto LABEL_52;
          }
        }
        else
        {
          *((void *)&v188 + 1) = *MEMORY[0x1E4F14068];
          LODWORD(v189) = -303;
          char v59 = v29;
        }
        unint64_t v39 = v59;
        goto LABEL_51;
      }
LABEL_115:
      int v40 = 0;
LABEL_116:
      mach_msg_destroy(v29);
      goto LABEL_117;
    }
    if ((v42 - 40002) >= 4)
    {
      if (v42 == 40001)
      {
        int v40 = 0;
        CA::Render::Server::_kicked = 0;
      }
      else
      {
        if (v42 != 40000) {
          goto LABEL_115;
        }
        mach_port_name_t v60 = CA::Render::Server::_server_port;
        int v61 = CA::Render::Server::_server_port;
        atomic_compare_exchange_strong(&CA::Render::Server::_server_port, (unsigned int *)&v61, 0);
        if (v61 == v60)
        {
          mach_port_mod_refs(*v8, v60, 1u, -1);
          mach_port_deallocate(*v8, v60);
        }
        if (CA::Render::Server::_checked_in_ports)
        {
          os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Server::_checked_in_lock);
          uint64_t v62 = CA::Render::Server::_checked_in_ports;
          if (CA::Render::Server::_checked_in_ports)
          {
            do
            {
              mach_port_mod_refs(*v8, *(_DWORD *)v62, 1u, -1);
              uint64_t v62 = *(void *)(v62 + 8);
            }
            while (v62);
            unsigned int v63 = (void *)CA::Render::Server::_checked_in_ports;
            if (CA::Render::Server::_checked_in_ports)
            {
              do
              {
                uint64_t v64 = (void *)v63[1];
                free(v63);
                unsigned int v63 = v64;
              }
              while (v64);
            }
          }
          CA::Render::Server::_checked_in_ports = 0;
          os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_checked_in_lock);
        }
        int v40 = 1;
      }
      goto LABEL_116;
    }
    uint64_t v43 = CA::Render::Context::context_by_server_port((CA::Render::Context *)v29->msgh_local_port);
    if (!v43)
    {
      if (!x_log_hook_p())
      {
        uint64_t v68 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v187) = 0;
          _os_log_impl(&dword_184668000, v68, OS_LOG_TYPE_ERROR, "dropping CmdStreamMsg due to missing ctx", (uint8_t *)&v187, 2u);
        }
        goto LABEL_115;
      }
      x_log_();
      goto LABEL_148;
    }
    uint64_t v44 = v43;
    uint64_t v45 = (malloc_zone_t *)get_malloc_zone();
    uint64_t v46 = malloc_type_zone_malloc(v45, 0x1058uLL, 0x8BB15036uLL);
    if (!v46)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v78 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          int v79 = *(_DWORD *)(v44 + 16);
          LODWORD(v187) = 67109120;
          DWORD1(v187) = v79;
          _os_log_impl(&dword_184668000, v78, OS_LOG_TYPE_ERROR, "failed to create CmdStreamMsg for %x", (uint8_t *)&v187, 8u);
        }
      }
      if (atomic_fetch_add((atomic_uint *volatile)(v44 + 8), 0xFFFFFFFF) == 1) {
        (*(void (**)(uint64_t))(*(void *)v44 + 16))(v44);
      }
LABEL_148:
      int v40 = 0;
      goto LABEL_116;
    }
    uint64_t v47 = v46;
    v46[7] = 0;
    double v48 = v46 + 7;
    *uint64_t v47 = &unk_1ED02F6E0;
    v47[1] = v44;
    v47[4] = 0;
    v47[5] = 0;
    v47[2] = v29;
    v47[3] = 0;
    v47[8] = v47 + 11;
    *(_OWORD *)(v47 + 9) = xmmword_184998060;
    v47[6] = v48;
    uint64_t v49 = v47 + 519;
    v47[519] = 0;
    v47[521] = 0;
    v47[520] = 0;
    *((unsigned char *)v47 + 4176) = 0;
    *((unsigned char *)v47 + 4177) = v31;
    uint64_t msgh_bits = v29[1].msgh_bits;
    if (((v29->msgh_bits & 0x80000000) != 0 || !msgh_bits)
      && ((v29->msgh_bits & 0x80000000) == 0 || msgh_bits))
    {
      p_msgh_size = (char *)&v29[1].msgh_size;
      unsigned int v96 = v29->msgh_id;
      switch(v96)
      {
        case 0x9C42u:
        case 0x9C44u:
          if (v29->msgh_size > 0x1B) {
            goto LABEL_197;
          }
          if (CADeviceHasInternalBuild::once[0] != -1) {
            dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
          }
          if (!CADeviceHasInternalBuild::internal) {
            break;
          }
          x_log_crash("Message buffer underflow, diff: %lld, msgh_size: %lld, desc: %p, _msg: %p!");
          goto LABEL_379;
        case 0x9C43u:
        case 0x9C45u:
          v47[4] = p_msgh_size;
          if (!msgh_bits)
          {
            if (CADeviceHasInternalBuild::once[0] != -1) {
              dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
            }
            if (CADeviceHasInternalBuild::internal)
            {
LABEL_382:
              x_log_crash("Message is ool CommandStream, but no body, desc_count: %zu, body_ool->type:%u!");
              goto LABEL_379;
            }
            break;
          }
          if (HIBYTE(v29[1].msgh_local_port) != 1)
          {
            if (CADeviceHasInternalBuild::once[0] != -1) {
              dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
            }
            if (CADeviceHasInternalBuild::internal) {
              goto LABEL_382;
            }
            break;
          }
          uint64_t v100 = *(void *)&v29[1].msgh_size;
          uint64_t msgh_voucher_port = v29[1].msgh_voucher_port;
          p_msgh_size = (char *)&v29[1].msgh_id;
          --msgh_bits;
LABEL_198:
          if (v96 >> 1 == 20002)
          {
            if (!msgh_bits)
            {
              if (CADeviceHasInternalBuild::once[0] != -1) {
                dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
              }
              if (CADeviceHasInternalBuild::internal)
              {
LABEL_383:
                x_log_crash("Message is batched CommandStream, but no batch ports, desc_count: %zu, port->type:%u!");
                goto LABEL_379;
              }
              break;
            }
            unsigned int v102 = *((_DWORD *)p_msgh_size + 2);
            if (HIBYTE(v102))
            {
              if (HIWORD(v102) != 529)
              {
LABEL_202:
                if (CADeviceHasInternalBuild::once[0] != -1) {
                  dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
                }
                if (CADeviceHasInternalBuild::internal) {
                  goto LABEL_383;
                }
                break;
              }
            }
            else if ((v102 & 0xFF0000) != 0x110000)
            {
              goto LABEL_202;
            }
            uint64_t v172 = v100;
            uint64_t v174 = msgh_voucher_port;
            v47[5] = p_msgh_size;
            uint64_t v161 = 16;
            if (!p_msgh_size[11]) {
              uint64_t v161 = 12;
            }
            p_msgh_size += v161;
            --msgh_bits;
          }
          else
          {
            uint64_t v172 = v100;
            uint64_t v174 = msgh_voucher_port;
          }
          v47[519] = x_heap_malloc(v48, 8 * msgh_bits);
          v47[520] = msgh_bits;
          if (msgh_bits)
          {
            for (uint64_t i = 0; i != msgh_bits; ++i)
            {
              *(void *)(v47[519] + 8 * i) = x_heap_malloc_small_((uint64_t *)v47[6], 0x30uLL);
              int v163 = HIBYTE(*((_DWORD *)p_msgh_size + 2));
              if (v163)
              {
                if (v163 != 1) {
                  goto LABEL_62;
                }
                uint64_t v164 = *(void *)(*v49 + 8 * i);
                *(_DWORD *)(v164 + 8) = 1;
                *(void *)(v164 + 16) = *(void *)p_msgh_size;
                *(void *)(*(void *)(*v49 + 8 * i) + 24) = *((unsigned int *)p_msgh_size + 3);
                *(void *)(*(void *)(*v49 + 8 * i) + 32) = CA::Render::Server::release_vm;
                *(void *)(*(void *)(*v49 + 8 * i) + 40) = *((unsigned int *)p_msgh_size + 3);
                p_msgh_size += 16;
                MEMORY[0x185325430](*MEMORY[0x1E4F14960], *(void *)(*(void *)(*v49 + 8 * i) + 16), *(void *)(*(void *)(*v49 + 8 * i) + 24), 1, 1);
              }
              else
              {
                uint64_t v165 = *(void *)(*v49 + 8 * i);
                *(_DWORD *)(v165 + 8) = 2;
                *(_DWORD *)(v165 + 16) = *(_DWORD *)p_msgh_size;
                *(_DWORD *)(*(void *)(*v49 + 8 * i) + 20) = p_msgh_size[10];
                *(unsigned char *)(*(void *)(*v49 + 8 * i) + 24) = 1;
                p_msgh_size += 12;
              }
            }
          }
          v47[3] = p_msgh_size;
          uint64_t v166 = v47[2];
          int v167 = *(_DWORD *)(v166 + 20);
          uint64_t v168 = v172;
          if (v167 == 40004 || v167 == 40002)
          {
            uint64_t v174 = v166 - (void)p_msgh_size + *(unsigned int *)(v166 + 4);
            uint64_t v168 = (uint64_t)p_msgh_size;
          }
          v169 = (malloc_zone_t *)get_malloc_zone();
          v170 = malloc_type_zone_malloc(v169, 0x58uLL, 0x8BB15036uLL);
          if (v170) {
            v170 = (unsigned char *)CA::Render::Decoder::Decoder((uint64_t)v170, v47[6], v47[1], v168, v174);
          }
          if ((v170[18] & 1) == 0)
          {
            v47[521] = v170;
            float32x2_t v8 = (ipc_space_t *)MEMORY[0x1E4F14960];
            goto LABEL_63;
          }
          (*(void (**)(unsigned char *))(*(void *)v170 + 8))(v170);
          break;
        default:
LABEL_197:
          uint64_t v100 = 0;
          uint64_t msgh_voucher_port = 0;
          goto LABEL_198;
      }
    }
LABEL_62:
    CA::Render::Server::CmdStreamMsg::_send_reply((CA::Render::Server::CmdStreamMsg *)v47);
    float32x2_t v8 = (ipc_space_t *)MEMORY[0x1E4F14960];
    if (v47[521])
    {
LABEL_63:
      *(void *)port_info_outCnt = v47;
      os_unfair_lock_lock((os_unfair_lock_t)(v44 + 680));
      if ((*(unsigned char *)(v44 + 13) & 4) != 0)
      {
        (*(void (**)(void *))(*v47 + 8))(v47);
LABEL_346:
        os_unfair_lock_unlock((os_unfair_lock_t)(v44 + 680));
        int v31 = 0;
        goto LABEL_52;
      }
      uint64_t v189 = 1065353216;
      long long v188 = 0u;
      long long v187 = 0u;
      (*(void (**)(void *, long long *))(*v47 + 24))(v47, &v187);
      if (*((void *)&v188 + 1))
      {
        os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Fence::_lock);
        unsigned int v50 = *(_DWORD *)(v44 + 16);
        unsigned int v185 = v50;
        for (j = v188; j; float32x2_t v8 = (ipc_space_t *)MEMORY[0x1E4F14960])
        {
          mach_port_deallocate(*v8, *(_DWORD *)(j + 16));
          unsigned int v52 = *(_DWORD *)(j + 16);
          if (v52 - 1 <= 0xFFFFFFFD
            && !std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::cleared_b_ports, *(_DWORD *)(j + 16))&& (v53 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::batches_by_port, v52)) != 0&& (uint64_t v54 = v53[3], *(double *)(v54 + 16) == 0.0))
          {
            v178 = *(void **)(v54 + 24);
            if (!std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v178, v50))
            {
              std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)v178, v50, v50);
              if (*(unsigned char *)(v54 + 44)) {
                kdebug_trace();
              }
            }
            std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(*(void *)(v54 + 32), v50, v50);
            uint64_t j = *(void *)j;
          }
          else
          {
            uint64_t j = std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::erase(&v187, (uint64_t *)j);
          }
        }
        v97 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::bcontexts_by_id, v50);
        if (!v97)
        {
          if (!atomic_fetch_add((atomic_uint *volatile)(v44 + 8), 1u)) {
            atomic_fetch_add((atomic_uint *volatile)(v44 + 8), 0xFFFFFFFF);
          }
          v103 = (malloc_zone_t *)get_malloc_zone();
          *(void *)malloc_type_zone_malloc(v103, 0x18uLL, 0x8BB15036uLL) = v44;
          operator new();
        }
        uint64_t v104 = *(uint64_t **)(v97[3] + 8);
        unint64_t v105 = v104[1];
        unint64_t v106 = v104[2];
        if (v105 >= v106)
        {
          unint64_t v108 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v105 - *v104) >> 3);
          unint64_t v109 = v108 + 1;
          if (v108 + 1 > 0x666666666666666) {
            abort();
          }
          unint64_t v110 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v106 - *v104) >> 3);
          if (2 * v110 > v109) {
            unint64_t v109 = 2 * v110;
          }
          if (v110 >= 0x333333333333333) {
            unint64_t v111 = 0x666666666666666;
          }
          else {
            unint64_t v111 = v109;
          }
          if (v111)
          {
            if (v111 > 0x666666666666666) {
LABEL_380:
            }
              std::__throw_bad_array_new_length[abi:nn180100]();
            v112 = (char *)operator new(40 * v111);
          }
          else
          {
            v112 = 0;
          }
          v175 = &v112[40 * v111];
          uint64_t v113 = std::unordered_set<unsigned int>::unordered_set((uint64_t)&v112[40 * v108], (uint64_t)&v187);
          uint64_t v107 = v113 + 40;
          v115 = (uint64_t *)*v104;
          v114 = (uint64_t *)v104[1];
          uint64_t v180 = v113 + 40;
          if (v114 == (uint64_t *)*v104)
          {
            *uint64_t v104 = v113;
            v104[1] = v107;
            v104[2] = (uint64_t)v175;
          }
          else
          {
            do
            {
              v114 -= 5;
              uint64_t v113 = std::__hash_table<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>>>::__hash_table(v113 - 40, v114);
            }
            while (v114 != v115);
            v116 = (uint64_t *)*v104;
            v114 = (uint64_t *)v104[1];
            uint64_t v107 = v180;
            *uint64_t v104 = v113;
            v104[1] = v180;
            v104[2] = (uint64_t)v175;
            if (v114 != v116)
            {
              do
              {
                v114 -= 5;
                std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v114);
              }
              while (v114 != v116);
              v114 = v116;
              uint64_t v107 = v180;
            }
          }
          float32x2_t v8 = (ipc_space_t *)MEMORY[0x1E4F14960];
          if (v114)
          {
            operator delete(v114);
            uint64_t v107 = v180;
          }
        }
        else
        {
          uint64_t v107 = std::unordered_set<unsigned int>::unordered_set(v105, (uint64_t)&v187) + 40;
        }
        v104[1] = v107;
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Fence::_lock);
      }
      double v117 = (*(double (**)(void *))(*v47 + 16))(v47);
      double v118 = v117;
      if (v117 == 0.0)
      {
        double v121 = v117;
      }
      else
      {
        uint64_t v119 = mach_absolute_time();
        double v120 = CATimeWithHostTime(v119);
        double v121 = 0.0;
        if (v118 <= v120)
        {
LABEL_250:
          if (!*(void *)(v44 + 688) && !*((void *)&v188 + 1))
          {
            CA::Render::Context::apply_streams((CA::Render::Context *)v44, port_info_outCnt, 1);
            (*(void (**)(void *))(*v47 + 8))(v47);
LABEL_345:
            std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v187);
            goto LABEL_346;
          }
LABEL_253:
          (*(void (**)(void *))(*v47 + 32))(v47);
          v125 = (malloc_zone_t *)get_malloc_zone();
          v126 = (double *)malloc_type_zone_malloc(v125, 0x20uLL, 0x8BB15036uLL);
          double *v126 = 0.0;
          v126[2] = v121;
          *((void *)v126 + 3) = v47;
          if (*((void *)&v188 + 1))
          {
            uint64_t v127 = v188;
            if (!(void)v188) {
LABEL_340:
            }
              operator new();
            v173 = (void *)(v44 + 712);
            v176 = v126;
            while (2)
            {
              unint64_t v128 = *(unsigned int *)(v127 + 16);
              unint64_t v129 = *(void *)(v44 + 704);
              v181 = (uint64_t *)v127;
              if (v129)
              {
                uint8x8_t v130 = (uint8x8_t)vcnt_s8((int8x8_t)v129);
                v130.i16[0] = vaddlv_u8(v130);
                if (v130.u32[0] > 1uLL)
                {
                  unint64_t v131 = *(unsigned int *)(v127 + 16);
                  if (v129 <= v128) {
                    unint64_t v131 = v128 % v129;
                  }
                }
                else
                {
                  unint64_t v131 = (v129 - 1) & v128;
                }
                v132 = *(void ***)(*(void *)(v44 + 696) + 8 * v131);
                if (v132)
                {
                  v133 = *v132;
                  if (*v132)
                  {
                    do
                    {
                      unint64_t v134 = v133[1];
                      if (v134 == v128)
                      {
                        if (*((_DWORD *)v133 + 4) == v128)
                        {
                          v157 = v176;
                          v156 = v181;
                          goto LABEL_329;
                        }
                      }
                      else
                      {
                        if (v130.u32[0] > 1uLL)
                        {
                          if (v134 >= v129) {
                            v134 %= v129;
                          }
                        }
                        else
                        {
                          v134 &= v129 - 1;
                        }
                        if (v134 != v131) {
                          break;
                        }
                      }
                      v133 = (void *)*v133;
                    }
                    while (v133);
                  }
                }
              }
              else
              {
                unint64_t v131 = 0;
              }
              v133 = operator new(0x20uLL);
              void *v133 = 0;
              v133[1] = v128;
              *((_DWORD *)v133 + 4) = v128;
              v133[3] = 0;
              float v135 = (float)(unint64_t)(*(void *)(v44 + 720) + 1);
              float v136 = *(float *)(v44 + 728);
              if (!v129 || (float)(v136 * (float)v129) < v135)
              {
                BOOL v137 = (v129 & (v129 - 1)) != 0;
                if (v129 < 3) {
                  BOOL v137 = 1;
                }
                unint64_t v138 = v137 | (2 * v129);
                unint64_t v139 = vcvtps_u32_f32(v135 / v136);
                if (v138 <= v139) {
                  int8x8_t prime = (int8x8_t)v139;
                }
                else {
                  int8x8_t prime = (int8x8_t)v138;
                }
                if (*(void *)&prime == 1)
                {
                  int8x8_t prime = (int8x8_t)2;
                }
                else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
                {
                  int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
                }
                unint64_t v129 = *(void *)(v44 + 704);
                if (*(void *)&prime <= v129)
                {
                  if (*(void *)&prime < v129)
                  {
                    unint64_t v147 = vcvtps_u32_f32((float)*(unint64_t *)(v44 + 720) / *(float *)(v44 + 728));
                    if (v129 < 3
                      || (uint8x8_t v148 = (uint8x8_t)vcnt_s8((int8x8_t)v129), v148.i16[0] = vaddlv_u8(v148), v148.u32[0] > 1uLL))
                    {
                      unint64_t v147 = std::__next_prime(v147);
                    }
                    else
                    {
                      uint64_t v149 = 1 << -(char)__clz(v147 - 1);
                      if (v147 >= 2) {
                        unint64_t v147 = v149;
                      }
                    }
                    if (*(void *)&prime <= v147) {
                      int8x8_t prime = (int8x8_t)v147;
                    }
                    if (*(void *)&prime >= v129)
                    {
                      unint64_t v129 = *(void *)(v44 + 704);
                    }
                    else
                    {
                      if (prime) {
                        goto LABEL_285;
                      }
                      v158 = *(void **)(v44 + 696);
                      *(void *)(v44 + 696) = 0;
                      if (v158) {
                        operator delete(v158);
                      }
                      unint64_t v129 = 0;
                      *(void *)(v44 + 704) = 0;
                    }
                  }
                }
                else
                {
LABEL_285:
                  if (*(void *)&prime >> 61) {
                    goto LABEL_380;
                  }
                  v141 = operator new(8 * *(void *)&prime);
                  v142 = *(void **)(v44 + 696);
                  *(void *)(v44 + 696) = v141;
                  if (v142) {
                    operator delete(v142);
                  }
                  uint64_t v143 = 0;
                  *(int8x8_t *)(v44 + 704) = prime;
                  do
                    *(void *)(*(void *)(v44 + 696) + 8 * v143++) = 0;
                  while (*(void *)&prime != v143);
                  v144 = (void *)*v173;
                  if (*v173)
                  {
                    unint64_t v145 = v144[1];
                    uint8x8_t v146 = (uint8x8_t)vcnt_s8(prime);
                    v146.i16[0] = vaddlv_u8(v146);
                    if (v146.u32[0] > 1uLL)
                    {
                      if (v145 >= *(void *)&prime) {
                        v145 %= *(void *)&prime;
                      }
                    }
                    else
                    {
                      v145 &= *(void *)&prime - 1;
                    }
                    *(void *)(*(void *)(v44 + 696) + 8 * v145) = v173;
                    v150 = (void *)*v144;
                    if (*v144)
                    {
                      while (2)
                      {
                        unint64_t v151 = v150[1];
                        if (v146.u32[0] > 1uLL)
                        {
                          if (v151 >= *(void *)&prime) {
                            v151 %= *(void *)&prime;
                          }
                        }
                        else
                        {
                          v151 &= *(void *)&prime - 1;
                        }
                        if (v151 == v145)
                        {
LABEL_309:
                          unint64_t v151 = v145;
                        }
                        else
                        {
                          uint64_t v152 = *(void *)(v44 + 696);
                          if (*(void *)(v152 + 8 * v151))
                          {
                            void *v144 = *v150;
                            void *v150 = **(void **)(*(void *)(v44 + 696) + 8 * v151);
                            **(void **)(*(void *)(v44 + 696) + 8 * v151) = v150;
                            v150 = v144;
                            goto LABEL_309;
                          }
                          *(void *)(v152 + 8 * v151) = v144;
                        }
                        v144 = v150;
                        v150 = (void *)*v150;
                        unint64_t v145 = v151;
                        if (!v150) {
                          break;
                        }
                        continue;
                      }
                    }
                  }
                  unint64_t v129 = (unint64_t)prime;
                }
                if ((v129 & (v129 - 1)) != 0)
                {
                  if (v129 <= v128) {
                    unint64_t v131 = v128 % v129;
                  }
                  else {
                    unint64_t v131 = v128;
                  }
                }
                else
                {
                  unint64_t v131 = (v129 - 1) & v128;
                }
              }
              uint64_t v153 = *(void *)(v44 + 696);
              v154 = *(void **)(v153 + 8 * v131);
              v156 = v181;
              if (v154)
              {
                void *v133 = *v154;
                v157 = v176;
                goto LABEL_327;
              }
              void *v133 = *v173;
              void *v173 = v133;
              *(void *)(v153 + 8 * v131) = v173;
              v157 = v176;
              if (*v133)
              {
                unint64_t v155 = *(void *)(*v133 + 8);
                if ((v129 & (v129 - 1)) != 0)
                {
                  if (v155 >= v129) {
                    v155 %= v129;
                  }
                }
                else
                {
                  v155 &= v129 - 1;
                }
                v154 = (void *)(*(void *)(v44 + 696) + 8 * v155);
LABEL_327:
                void *v154 = v133;
              }
              ++*(void *)(v44 + 720);
LABEL_329:
              v133[3] = v157;
              uint64_t v127 = *v156;
              if (!v127) {
                goto LABEL_340;
              }
              continue;
            }
          }
          v126[1] = 0.0;
          v159 = *(double **)(v44 + 688);
          if (v159)
          {
            do
            {
              v160 = (double **)v159;
              v159 = *(double **)v159;
            }
            while (v159);
            *v160 = v126;
          }
          else
          {
            *(void *)(v44 + 688) = v126;
          }
          goto LABEL_345;
        }
        double v122 = v120 + 0.5;
        if (v118 >= v122) {
          double v121 = v122;
        }
        else {
          double v121 = v118;
        }
        uint64_t v123 = v44;
        if (!atomic_fetch_add((atomic_uint *volatile)(v44 + 8), 1u))
        {
          uint64_t v123 = 0;
          atomic_fetch_add((atomic_uint *volatile)(v44 + 8), 0xFFFFFFFF);
        }
        if (CA::Render::Server::add_callback(0, (uint64_t)CA::Render::Context::enqueue_command_stream(CA::Render::Context::CommandStream *)::$_0::__invoke, v123, v121))BOOL v124 = CA::Render::Server::_thread == 0; {
        else
        }
          BOOL v124 = 1;
        if (v124) {
          __assert_rtn("enqueue_command_stream", "render-context.cpp", 1174, "success && Server::is_running ()");
        }
      }
      if (v121 != 0.0) {
        goto LABEL_253;
      }
      goto LABEL_250;
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v98 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        int v99 = *(_DWORD *)(v44 + 16);
        LODWORD(v187) = 67109120;
        DWORD1(v187) = v99;
        _os_log_impl(&dword_184668000, v98, OS_LOG_TYPE_ERROR, "CmdStreamMsg for %x is invalid", (uint8_t *)&v187, 8u);
      }
    }
    (*(void (**)(void *))(*v47 + 8))(v47);
    int v31 = 0;
    int v40 = 0;
LABEL_117:
    voucher_mach_msg_revert(state);
    if (v182)
    {
      bzero(policy_info, v182);
      if ((v31 & 1) == 0) {
        goto LABEL_120;
      }
LABEL_119:
      free(v29);
      goto LABEL_120;
    }
    if (v31) {
      goto LABEL_119;
    }
LABEL_120:
  }
  while (!v40);
  pthread_mutex_lock(&CA::Render::Server::_mutex);
  CA::Render::Server::_thread = 0;
  pthread_cond_broadcast(&CA::Render::Server::_cond);
  return pthread_mutex_unlock(&CA::Render::Server::_mutex);
}

double CATimeWithHostTime(unint64_t a1)
{
  uint64_t v1 = &CA::callback_timer;
  double v2 = *(double *)&time_scale;
  if (*(double *)&time_scale == 0.0)
  {
    if (time_scale_once[0] != -1)
    {
      unint64_t v4 = a1;
      dispatch_once_f(time_scale_once, 0, (dispatch_function_t)initialize_time_scale);
      uint64_t v1 = &CA::callback_timer;
      a1 = v4;
    }
    double v2 = *((double *)v1 + 408);
  }
  return v2 * (double)a1;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(void *a1, unsigned int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  mach_port_t v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (intptr_t result = *v5; result; intptr_t result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint8x8_t v3 = (void *)*v2;
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t CA::Render::Server::port_set(CA::Render::Server *this)
{
  kern_return_t v4;
  kern_return_t v5;
  NSObject *v6;
  mach_port_name_t name;
  uint8_t buf[4];
  kern_return_t v9;
  uint64_t v10;

  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t result = CA::Render::Server::_server_port_set;
  name = CA::Render::Server::_server_port_set;
  if (!CA::Render::Server::_server_port_set)
  {
    unint64_t v2 = (ipc_space_t *)MEMORY[0x1E4F14960];
    mach_port_allocate(*MEMORY[0x1E4F14960], 3u, &name);
    int v3 = 0;
    atomic_compare_exchange_strong(&CA::Render::Server::_server_port_set, (unsigned int *)&v3, name);
    if (v3)
    {
      unint64_t v4 = mach_port_mod_refs(*v2, name, 3u, -1);
      if (v4)
      {
        mach_port_t v5 = v4;
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          uint64_t v6 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            thread_act_t v9 = v5;
            _os_log_impl(&dword_184668000, v6, OS_LOG_TYPE_ERROR, "CA:Render:Server:port_set (): mach_port_mod_refs () returned error 0x%x\n", buf, 8u);
          }
        }
      }
    }
    return CA::Render::Server::_server_port_set;
  }
  return result;
}

uint64_t CA::Render::Server::timer_port(CA::Render::Server *this)
{
  uint64_t result = CA::Render::Server::_timer_port[0];
  if (!CA::Render::Server::_timer_port[0])
  {
    unint64_t v2 = (CA::Render::Server *)mk_timer_create();
    if (!v2)
    {
      x_log_crash("CoreAnimation: mk_timer_create returned error!\n");
      abort();
    }
    mach_port_name_t v3 = v2;
    int v4 = 0;
    atomic_compare_exchange_strong(CA::Render::Server::_timer_port, (unsigned int *)&v4, v2);
    if (v4)
    {
      mk_timer_destroy();
    }
    else
    {
      ipc_space_t v5 = *MEMORY[0x1E4F14960];
      mach_port_name_t v6 = CA::Render::Server::port_set(v2);
      mach_port_move_member(v5, v3, v6);
    }
    return CA::Render::Server::_timer_port[0];
  }
  return result;
}

uint64_t CA::Render::Server::notify_port(CA::Render::Server *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t result = CA::Render::Server::_notify_port[0];
  mach_port_name_t name = CA::Render::Server::_notify_port[0];
  if (!CA::Render::Server::_notify_port[0])
  {
    unint64_t v2 = (ipc_space_t *)MEMORY[0x1E4F14960];
    mach_port_name_t v3 = (CA::Render::Server *)mach_port_allocate(*MEMORY[0x1E4F14960], 1u, &name);
    int v4 = 0;
    atomic_compare_exchange_strong(CA::Render::Server::_notify_port, (unsigned int *)&v4, name);
    ipc_space_t v5 = *v2;
    mach_port_name_t v6 = name;
    if (v4)
    {
      mach_port_mod_refs(v5, name, 1u, -1);
    }
    else
    {
      mach_port_name_t v7 = CA::Render::Server::port_set(v3);
      mach_port_move_member(v5, v6, v7);
    }
    return CA::Render::Server::_notify_port[0];
  }
  return result;
}

uint64_t x_heap_malloc(uint64_t *a1, unint64_t a2)
{
  unint64_t v2 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v2 < a2) {
    return 0;
  }
  if (v2 >= 0x801)
  {
    mach_port_name_t v3 = malloc_type_malloc((a2 + 7) & 0xFFFFFFFFFFFFFFF8, 0xE6CB7714uLL);
    uint64_t v5 = *a1;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    mach_port_name_t v7 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    void *v7 = v3;
    v7[1] = v5;
    *a1 = (uint64_t)v7;
    return (uint64_t)v3;
  }
  unint64_t v9 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;

  return x_heap_malloc_small_(a1, v9);
}

uint64_t CA::Render::Encoder::Encoder(uint64_t a1, uint64_t a2, int a3, int a4, double a5)
{
  uint64_t v9 = CA::Render::Coder::Coder(a1, a2);
  *(void *)uint64_t v9 = &unk_1ED02F910;
  *(_DWORD *)(v9 + 68) = a4;
  *(void *)(v9 + 72) = 0;
  *(unsigned char *)(v9 + 104) = 0;
  *(void *)(v9 + 112) = 0;
  if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
    dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
  }
  int v10 = a3 | 1;
  *(_DWORD *)(a1 + 64) = v10;
  uint64_t v11 = *(void *)(a1 + 8);
  unint64_t v12 = *(void *)(v11 + 16);
  if ((int)v12 >= 8704) {
    uint64_t v13 = (int)v12 - 0x2000;
  }
  else {
    uint64_t v13 = 512;
  }
  unint64_t v14 = (v13 + 7) & 0xFFFFFFFFFFFFFFF8;
  BOOL v15 = v12 >= v14;
  unint64_t v16 = v12 - v14;
  if (v15)
  {
    double v17 = *(_DWORD **)(v11 + 8);
    *(void *)(v11 + 8) = (char *)v17 + v14;
    *(void *)(v11 + 16) = v16;
  }
  else
  {
    double v17 = (_DWORD *)x_heap_malloc_small_(*(uint64_t **)(a1 + 8), v14);
    int v10 = *(_DWORD *)(a1 + 64);
  }
  *(void *)(a1 + 24) = v17;
  *(void *)(a1 + 32) = v17;
  *(void *)(a1 + 40) = (char *)v17 + v13;
  if (v13 <= 3)
  {
    CA::Render::Encoder::grow((CA::Render::Encoder *)a1, 4);
    double v17 = *(_DWORD **)(a1 + 32);
  }
  _DWORD *v17 = v10;
  uint64_t v18 = *(void *)(a1 + 32);
  unint64_t v19 = *(void *)(a1 + 40);
  double v20 = (_DWORD *)(v18 + 4);
  *(void *)(a1 + 32) = v18 + 4;
  if (v18 + 8 > v19)
  {
    CA::Render::Encoder::grow((CA::Render::Encoder *)a1, 4);
    double v20 = *(_DWORD **)(a1 + 32);
  }
  *double v20 = a4;
  uint64_t v21 = *(void *)(a1 + 32);
  unint64_t v22 = *(void *)(a1 + 40);
  mach_port_name_t v23 = (double *)(v21 + 4);
  *(void *)(a1 + 32) = v21 + 4;
  if (v21 + 12 > v22)
  {
    CA::Render::Encoder::grow((CA::Render::Encoder *)a1, 8);
    mach_port_name_t v23 = *(double **)(a1 + 32);
  }
  *mach_port_name_t v23 = a5;
  uint64_t v24 = *(void *)(a1 + 24);
  uint64_t v25 = *(void *)(a1 + 32) + 8;
  *(void *)(a1 + 32) = v25;
  *(void *)(a1 + 96) = v25 - v24;
  return a1;
}

uint64_t CA::Render::Decoder::Decoder(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  int v10 = (CA::Render::Decoder *)CA::Render::Coder::Coder(a1, a2);
  *(void *)int v10 = &unk_1ED02F8F0;
  *((void *)v10 + 9) = a3;
  *((void *)v10 + 3) = a4;
  *((void *)v10 + 4) = a4;
  *((void *)v10 + 5) = a4 + a5;
  *(_DWORD *)(a1 + 64) = CA::Render::Decoder::decode_int32(v10);
  int v11 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)a1);
  *(void *)(a1 + 80) = CA::Render::Decoder::decode_int64((CA::Render::Decoder *)a1);
  if (!a3)
  {
    if (x_log_hook_p()) {
      goto LABEL_10;
    }
    uint64_t v12 = x_log_category_render;
    if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 67109120;
    int v25 = v11;
    uint64_t v13 = "Decoder has no context! dcid=%x";
LABEL_17:
    double v20 = v12;
    os_log_type_t v21 = OS_LOG_TYPE_DEFAULT;
    uint32_t v22 = 8;
    goto LABEL_18;
  }
  if (*(_DWORD *)(a3 + 16) != v11)
  {
    if (x_log_hook_p())
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a3 + 52));
      os_unfair_lock_unlock((os_unfair_lock_t)(a3 + 52));
LABEL_10:
      x_log_();
LABEL_19:
      *(unsigned char *)(a1 + 18) = 1;
      return a1;
    }
    uint64_t v14 = x_log_category_render;
    if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
    int v15 = *(_DWORD *)(a3 + 16);
    unint64_t v16 = (os_unfair_lock_s *)(a3 + 52);
    os_unfair_lock_lock((os_unfair_lock_t)(a3 + 52));
    int v17 = *(_DWORD *)(a3 + 64);
    os_unfair_lock_unlock(v16);
    int v18 = *(_DWORD *)(a1 + 64);
    uint64_t v19 = *(void *)(a1 + 80);
    *(_DWORD *)buf = 67110912;
    int v25 = v15;
    __int16 v26 = 1024;
    int v27 = v17;
    __int16 v28 = 2048;
    uint64_t v29 = a2;
    __int16 v30 = 2048;
    uint64_t v31 = a4;
    __int16 v32 = 2048;
    uint64_t v33 = a5;
    __int16 v34 = 1024;
    int v35 = v18;
    __int16 v36 = 1024;
    int v37 = v11;
    __int16 v38 = 2048;
    uint64_t v39 = v19;
    uint64_t v13 = "Context ID mismatch! pcid=%x pseed=%u : heap=%p data=%p data_len=%zu flags=%u dcid=%x t=%f";
    double v20 = v14;
    os_log_type_t v21 = OS_LOG_TYPE_ERROR;
    uint32_t v22 = 66;
LABEL_18:
    _os_log_impl(&dword_184668000, v20, v21, v13, buf, v22);
    goto LABEL_19;
  }
  if ((*(unsigned char *)(a3 + 13) & 4) != 0)
  {
    if (x_log_hook_p()) {
      goto LABEL_10;
    }
    uint64_t v12 = x_log_category_render;
    if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 67109120;
    int v25 = v11;
    uint64_t v13 = "Context is destroyed! cid=%x";
    goto LABEL_17;
  }
  return a1;
}

uint64_t CA::Render::Coder::Coder(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1ED02F1D0;
  *(void *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = (a2 == 0) | (*(unsigned __int8 *)(a1 + 19) << 24);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  if (!a2) {
    *(void *)(a1 + 8) = x_heap_new(0x1000uLL);
  }
  return a1;
}

double CA::Render::Server::CmdStreamMsg::timestamp(CA::Render::Server::CmdStreamMsg *this)
{
  uint64_t v1 = *((void *)this + 521);
  if (v1) {
    return *(double *)(v1 + 80);
  }
  else {
    return 0.0;
  }
}

void CA::Render::Server::CmdStreamMsg::consume_batch_ports(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(uint64_t **)(a1 + 40);
  if (v2)
  {
    if (*((unsigned char *)v2 + 11))
    {
      uint64_t v4 = *((unsigned int *)v2 + 3);
      if (!v4) {
        return;
      }
      unint64_t v2 = (uint64_t *)*v2;
    }
    else
    {
      uint64_t v4 = 1;
    }
    uint64_t v5 = (ipc_space_t *)MEMORY[0x1E4F14960];
    do
    {
      unsigned int v6 = *(_DWORD *)v2;
      if ((*(_DWORD *)v2 + 1) >= 2) {
        std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(a2, v6, *(_DWORD *)v2);
      }
      else {
        mach_port_deallocate(*v5, v6);
      }
      *(_DWORD *)unint64_t v2 = 0;
      unint64_t v2 = (uint64_t *)((char *)v2 + 4);
      --v4;
    }
    while (v4);
  }
}

uint64_t CA::Render::Server::CmdStreamMsg::defer(uint64_t this)
{
  if (!*(void *)(this + 4168)) {
    __assert_rtn("defer", "render-server.cpp", 1554, "is_valid ()");
  }
  uint64_t v1 = this;
  uint64_t v2 = this + 4176;
  if (*(unsigned char *)(this + 4176)) {
    __assert_rtn("defer", "render-server.cpp", 1555, "!_did_run");
  }
  if (!*(unsigned char *)(this + 4177))
  {
    mach_port_name_t v3 = (char *)malloc_type_calloc(1uLL, *(unsigned int *)(*(void *)(this + 16) + 4), 0x2B6B237AuLL);
    if (!v3) {
      __assert_rtn("defer", "render-server.cpp", 1561, "msg");
    }
    uint64_t v4 = v3;
    *(unsigned char *)(v2 + 1) = 1;
    this = (uint64_t)memcpy(v3, *(const void **)(v1 + 16), *(unsigned int *)(*(void *)(v1 + 16) + 4));
    uint64_t v5 = *(void *)(v1 + 16);
    uint64_t v6 = *(void *)(v1 + 24) - v5;
    *(void *)(v1 + 24) = &v4[v6];
    uint64_t v7 = *(void *)(v1 + 32);
    if (v7)
    {
      *(void *)(v1 + 32) = &v4[v7 - v5];
    }
    else
    {
      uint64_t v8 = *(void *)(v1 + 4168);
      if (v8)
      {
        (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
        uint64_t v5 = *(void *)(v1 + 16);
      }
      uint64_t v9 = *(unsigned int *)(v5 + 4);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      int v11 = malloc_type_zone_malloc(malloc_zone, 0x58uLL, 0x8BB15036uLL);
      if (!v11)
      {
        *(void *)(v1 + 4168) = 0;
        __assert_rtn("defer", "render-server.cpp", 1580, "_decoder");
      }
      this = CA::Render::Decoder::Decoder((uint64_t)v11, *(void *)(v1 + 48), *(void *)(v1 + 8), *(void *)(v1 + 24), v9 - v6);
      *(void *)(v1 + 4168) = this;
    }
    uint64_t v12 = *(void *)(v1 + 40);
    if (v12) {
      *(void *)(v1 + 40) = &v4[v12 - *(void *)(v1 + 16)];
    }
    *(void *)(v1 + 16) = v4;
  }
  return this;
}

void CA::Render::Decoder::~Decoder(CA::Render::Decoder *this)
{
  CA::Render::Coder::~Coder(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::Render::Coder::~Coder(CA::Render::Coder *this)
{
  *(void *)this = &unk_1ED02F1D0;
  uint64_t v2 = (uint64_t *)*((void *)this + 6);
  if (v2)
  {
    mach_port_name_t v3 = (ipc_space_t *)MEMORY[0x1E4F14960];
    do
    {
      int v4 = *((_DWORD *)v2 + 2);
      if (v4 == 2)
      {
        if (*((unsigned char *)v2 + 24)) {
          mach_port_deallocate(*v3, *((_DWORD *)v2 + 4));
        }
      }
      else if (v4 == 1)
      {
        uint64_t v5 = (void (*)(uint64_t, uint64_t))v2[4];
        if (v5) {
          v5(v2[2], v2[5]);
        }
      }
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  int v6 = *((_DWORD *)this + 4);
  if ((v6 & 0x100) != 0)
  {
    munmap(*((void **)this + 3), *((void *)this + 5) - *((void *)this + 3));
    int v6 = *((_DWORD *)this + 4);
  }
  if (v6) {
    x_heap_free(*((void ****)this + 1));
  }
}

{
  malloc_zone_t *malloc_zone;
  uint64_t vars8;

  CA::Render::Coder::~Coder(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::Render::Server::add_callback(int a1, uint64_t a2, uint64_t a3, double a4)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Server::_callback_lock);
  if (!a1)
  {
    if ((*(void *)&a4 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
    {
LABEL_19:
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_callback_lock);
      CA::Render::Server::kick_server(v16);
      return 1;
    }
LABEL_12:
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    int v10 = (double *)malloc_type_zone_malloc(malloc_zone, 0x28uLL, 0x8BB15036uLL);
    *((void *)v10 + 3) = a2;
    *((void *)v10 + 4) = a3;
LABEL_13:
    v10[1] = a4;
    uint64_t v12 = mach_absolute_time();
    v10[2] = CATimeWithHostTime(v12);
    uint64_t v13 = &CA::Render::Server::_callback_list;
    do
    {
      uint64_t v14 = v13;
      uint64_t v13 = (uint64_t *)*v13;
    }
    while (v13 && *((double *)v13 + 1) <= v10[1]);
    *(void *)int v10 = v13;
    uint64_t *v14 = (uint64_t)v10;
    goto LABEL_19;
  }
  uint64_t v8 = CA::Render::Server::_callback_list;
  if (!CA::Render::Server::_callback_list)
  {
LABEL_7:
    int v10 = 0;
    goto LABEL_8;
  }
  uint64_t v9 = &CA::Render::Server::_callback_list;
  while (1)
  {
    int v10 = (double *)v8;
    if (*(void *)(v8 + 24) == a2 && *(void *)(v8 + 32) == a3) {
      break;
    }
    uint64_t v8 = *(void *)v8;
    uint64_t v9 = (uint64_t *)v10;
    if (!*(void *)v10) {
      goto LABEL_7;
    }
  }
  if (a1 != 1 && (a1 != 3 || *(double *)(v8 + 8) >= a4))
  {
    uint64_t *v9 = *(void *)v8;
LABEL_8:
    if ((*(void *)&a4 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
    {
      if (v10)
      {
        int v15 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v15, v10);
      }
      goto LABEL_19;
    }
    if (v10) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_callback_lock);
  return 0;
}

void CA::Render::Server::kick_server(CA::Render::Server *this)
{
  mach_msg_return_t v3;
  mach_msg_return_t v4;
  NSObject *v5;
  unsigned char msg[28];
  uint8_t buf[4];
  mach_msg_return_t v8;
  uint64_t v9;

  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (!CA::Render::Server::_kicked)
  {
    uint64_t v1 = (CA::Render::Server *)pthread_self();
    if (v1 != (CA::Render::Server *)CA::Render::Server::_thread)
    {
      int v2 = CA::Render::Server::server_port(v1);
      if (v2)
      {
        CA::Render::Server::_kicked = 1;
        *(void *)msg = 0x1C00000013;
        *(_DWORD *)&msg[8] = v2;
        *(_OWORD *)&msg[12] = xmmword_1849982A0;
        mach_port_name_t v3 = mach_msg((mach_msg_header_t *)msg, 17, 0x1Cu, 0, 0, 0, 0);
        if (v3)
        {
          int v4 = v3;
          CA::Render::Server::_kicked = 0;
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            uint64_t v5 = x_log_category_render;
            if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109120;
              uint64_t v8 = v4;
              _os_log_impl(&dword_184668000, v5, OS_LOG_TYPE_ERROR, "Server kick failed with error %u", buf, 8u);
            }
          }
        }
      }
    }
  }
}

void CA::Render::Context::enqueue_command_stream(CA::Render::Context::CommandStream *)::$_0::__invoke(os_unfair_lock_s *a1, double a2)
{
  int v4 = a1 + 170;
  os_unfair_lock_lock(a1 + 170);
  CA::Render::Context::drain_deferred((uint64_t)a1, a2);
  os_unfair_lock_unlock(v4);
  if (atomic_fetch_add((atomic_uint *volatile)&a1[2], 0xFFFFFFFF) == 1)
  {
    uint64_t v5 = *(void (**)(os_unfair_lock_s *))(*(void *)&a1->_os_unfair_lock_opaque + 16);
    v5(a1);
  }
}

uint64_t CA::Render::Context::drain_deferred(uint64_t this, double a2)
{
  int v2 = (CA::Render::Context *)this;
  v14[1] = *MEMORY[0x1E4F143B8];
  double v3 = *(double *)(this + 736);
  if (v3 < a2)
  {
    *(double *)(this + 736) = a2;
    double v3 = a2;
  }
  int v4 = *(double **)(this + 688);
  if (v4 && (*(unsigned char *)(this + 13) & 4) == 0)
  {
    uint64_t v5 = 0;
    do
    {
      if (v4[2] > v3) {
        break;
      }
      uint64_t v6 = *((void *)v4 + 1);
      if (v6)
      {
        if (*(void *)(v6 + 24)) {
          break;
        }
      }
      ++v5;
      int v4 = *(double **)v4;
    }
    while (v4);
    if (v5)
    {
      MEMORY[0x1F4188790](this);
      uint64_t v8 = (void *)((char *)v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0));
      bzero(v8, v7);
      for (uint64_t i = 0; i != v5; ++i)
      {
        int v10 = (void *)*((void *)v2 + 86);
        uint64_t v11 = v10[1];
        *((void *)v2 + 86) = *v10;
        v8[i] = v10[3];
        if (v11)
        {
          uint64_t v12 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v11);
          MEMORY[0x185323DC0](v12, 0x10A0C408EF24B1CLL);
        }
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, v10);
      }
      CA::Render::Context::apply_streams(v2, v8, v5);
      do
      {
        this = *v8;
        if (*v8) {
          this = (*(uint64_t (**)(uint64_t))(*(void *)this + 8))(this);
        }
        ++v8;
        --v5;
      }
      while (v5);
    }
  }
  return this;
}

void CA::Render::Context::apply_streams(CA::Render::Context *this, void *a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if ((CA::Render::Context::apply_streams(CA::Render::Context::CommandStream **,unsigned long)::initialized & 1) == 0)
  {
    uint64_t v6 = getenv("CA_BENCHMARK");
    if (v6 && atoi(v6)) {
      CA::Render::Context::apply_streams(CA::Render::Context::CommandStream **,unsigned long)::benchmark_mode = 1;
    }
    CA::Render::Context::apply_streams(CA::Render::Context::CommandStream **,unsigned long)::initialized = 1;
  }
  CA::Render::Context::will_commit(this);
  char v7 = 0;
  LOBYTE(v8) = 1;
  double v9 = NAN;
  do
  {
    char v13 = CA::Render::Context::apply_streams(CA::Render::Context::CommandStream **,unsigned long)::benchmark_mode;
    char v12 = 0;
    double v11 = NAN;
    (*(void (**)(void, char *, char *, double *))(*(void *)*a2 + 40))(*a2, &v13, &v12, &v11);
    if (v13
      || CA::Render::Context::apply_streams(CA::Render::Context::CommandStream **,unsigned long)::benchmark_mode == 1)
    {
      char v7 = 1;
    }
    uint64_t v8 = (v12 != 0) & v8;
    if (v11 < v9) {
      double v9 = v11;
    }
    ++a2;
    --a3;
  }
  while (a3);
  if ((*(void *)&v9 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = *(void *)&v9;
  }
  CA::Render::Context::did_commit((unint64_t)this, v7 & 1, v10, 1, v8, 0);
  CA::Render::Context::run_scheduled_handle_updates(this);
}

void CA::Render::Context::did_commit(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  char v12 = *(atomic_uint **)(a1 + 432);
  if (atomic_fetch_add((atomic_uint *volatile)(a1 + 440), 0xFFFFFFFF) == 1) {
    *(void *)(a1 + 432) = 0;
  }
  ++*(_DWORD *)(a1 + 40);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 72));
  if (a2) {
    CA::Render::Context::mark_changed(a1, a5, a6, a3, a4);
  }
  if (a5 && BYTE9(xmmword_1EB2ACC10)) {
    kdebug_trace();
  }
  if (*(void *)(a1 + 416) | (unint64_t)v12)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
    uint64_t v13 = *(void *)(a1 + 416);
    if (v13)
    {
      if ((*(unsigned char *)(v13 + 13) & 4) != 0)
      {
        if (a2)
        {
          uint64_t v14 = *(void *)(v13 + 32);
          if (v14)
          {
            uint64_t v15 = *(void *)(v14 + 24);
            if (v15) {
              (*(void (**)(uint64_t))(*(void *)v15 + 32))(v15);
            }
          }
        }
      }
      else
      {
        if (*(atomic_uint **)(v13 + 80) != v12)
        {
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            unint64_t v16 = x_log_category_render;
            if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v19 = 0;
              _os_log_impl(&dword_184668000, v16, OS_LOG_TYPE_DEFAULT, "CoreAnimation: context hosting changed while locked!\n", v19, 2u);
            }
          }
        }
        int v17 = *(atomic_uint **)(*(void *)(a1 + 416) + 24);
        if (v17)
        {
          int v18 = v17 + 2;
          if (atomic_fetch_add(v17 + 2, 1u))
          {
            CA::Render::Handle::set_update_flags((CA::Render::Object *)v17, 4);
            if (atomic_fetch_add(v18, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v17 + 16))(v17);
            }
          }
          else
          {
            atomic_fetch_add(v18, 0xFFFFFFFF);
          }
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
    if (v12)
    {
      CA::Render::Context::did_commit(v12, a2, a3, a4, a5, a6);
      if (atomic_fetch_add(v12 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v12 + 16))(v12);
      }
    }
  }
  if ((*(_WORD *)(a1 + 552) & 0x40) == 0)
  {
    CA::Render::post_notification(5u, a1, 0, 0);
  }
}

uint64_t CA::Render::Context::will_commit(CA::Render::Context *this)
{
  if ((*((_WORD *)this + 276) & 0x40) == 0) {
    CA::Render::post_notification(4u, (unint64_t)this, 0, 0);
  }
  if (!*((void *)this + 52)) {
    goto LABEL_10;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
  uint64_t v2 = *((void *)this + 52);
  if (!v2 || (double v3 = *(atomic_uint **)(v2 + 80)) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
LABEL_10:
    double v3 = 0;
    goto LABEL_11;
  }
  if (!atomic_fetch_add(v3 + 2, 1u)) {
    atomic_fetch_add(v3 + 2, 0xFFFFFFFF);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
  CA::Render::Context::will_commit((CA::Render::Context *)v3);
LABEL_11:
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)((char *)this + 72));
  uint64_t v5 = (atomic_uint *)*((void *)this + 54);
  if (v5 && v5 != v3) {
    __assert_rtn("will_commit", "render-context.cpp", 2307, "!_locked_host_ctx || _locked_host_ctx == host_ctx");
  }
  *((void *)this + 54) = v3;
  atomic_fetch_add((atomic_uint *volatile)this + 110, 1u);
  return result;
}

void CA::Render::post_notification(unsigned int a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (a1 > 0x49) {
    return;
  }
  unint64_t v8 = *MEMORY[0x1E4F14B00];
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::notification_lock);
  if ((CA::Render::initialize_notifications(void)::initialized & 1) == 0)
  {
    uint64_t v54 = 0;
    int v55 = (int64x2_t *)CA::Render::notifications;
    do
    {
      int v56 = (char *)&CA::Render::notifications_map_data + v54;
      *(_OWORD *)int v56 = 0uLL;
      *((_OWORD *)v56 + 1) = 0uLL;
      *((_DWORD *)v56 + 8) = 1065353216;
      *int v55 = vdupq_n_s64((unint64_t)v55);
      ++v55;
      v54 += 40;
    }
    while (v54 != 2960);
    CA::Render::initialize_notifications(void)::initialized = 1;
  }
  if (*((long long **)&CA::Render::notifications[a1] + 1) != &CA::Render::notifications[a1])
  {
    double v9 = (void *)((char *)&CA::Render::notifications_map_data + 40 * a1);
    uint64_t v10 = std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::find<CA::Render::Object *>(v9, 0);
    double v11 = (_UNKNOWN **)(v10 + 3);
    char v12 = &CA::Render::post_notification(CA::Render::NotificationName,CA::Render::Object *,void *,BOOL)::empty_dummy;
    if (!v10) {
      double v11 = &CA::Render::post_notification(CA::Render::NotificationName,CA::Render::Object *,void *,BOOL)::empty_dummy;
    }
    char v59 = v11;
    uint64_t v57 = a3;
    if (a2)
    {
      uint64_t v13 = std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::find<CA::Render::Object *>(v9, a2);
      if (v13) {
        char v12 = (_UNKNOWN **)(v13 + 3);
      }
      else {
        char v12 = &CA::Render::post_notification(CA::Render::NotificationName,CA::Render::Object *,void *,BOOL)::empty_dummy;
      }
    }
    uint64_t v14 = v59;
    uint64_t v15 = (_UNKNOWN **)v59[1];
    unint64_t v16 = (_UNKNOWN **)v12[1];
    BOOL v17 = v16 != v12;
    BOOL v18 = v15 != v59;
    if (v15 != v59 || v16 != v12)
    {
      mach_port_name_t v60 = v9;
      int v61 = 0;
      uint64_t v20 = 0;
      os_log_type_t v21 = 0;
      uint32_t v22 = 0;
      uint64_t v23 = 0;
      unint64_t v62 = v8 >> 4;
      unsigned int v63 = v12;
      int v58 = a4;
      while (v18)
      {
        uint64_t v24 = (atomic_uint *)(v15 - 2);
        if (v17 && v15[2] >= v16[2])
        {
          uint64_t v24 = (atomic_uint *)(v16 - 2);
LABEL_24:
          unint64_t v16 = (_UNKNOWN **)v16[1];
          goto LABEL_25;
        }
        uint64_t v15 = (_UNKNOWN **)v15[1];
LABEL_25:
        uint64_t v25 = *((void *)v24 + 6);
        if (v25) {
          BOOL v26 = v25 == a2;
        }
        else {
          BOOL v26 = 1;
        }
        if (v26)
        {
          if (!atomic_fetch_add(v24 + 18, 1u))
          {
            int v27 = v23;
            dispatch_semaphore_wait(*((dispatch_semaphore_t *)v24 + 8), 0xFFFFFFFFFFFFFFFFLL);
            LODWORD(v23) = v27;
            char v12 = v63;
          }
          if ((int)v23 >= (int)v62)
          {
            if (v21 >= v61)
            {
              uint64_t v28 = (v21 - v20) >> 3;
              unint64_t v29 = v28 + 1;
              if ((unint64_t)(v28 + 1) >> 61) {
                abort();
              }
              uint64_t v30 = v61 - v20;
              if ((v61 - v20) >> 2 > v29) {
                unint64_t v29 = v30 >> 2;
              }
              unint64_t v31 = (unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v29;
              if (v31)
              {
                if (v31 >> 61) {
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
                int v32 = v23;
                uint64_t v33 = (char *)operator new(8 * v31);
                char v12 = v63;
                LODWORD(v23) = v32;
              }
              else
              {
                uint64_t v33 = 0;
              }
              __int16 v34 = &v33[8 * v28];
              *(void *)__int16 v34 = v24;
              int v35 = v34 + 8;
              while (v21 != v20)
              {
                uint64_t v36 = *((void *)v21 - 1);
                v21 -= 8;
                *((void *)v34 - 1) = v36;
                v34 -= 8;
              }
              int v61 = &v33[8 * v31];
              if (v20)
              {
                int v37 = v20;
                int v38 = v23;
                operator delete(v37);
                LODWORD(v23) = v38;
                char v12 = v63;
              }
              uint64_t v20 = v34;
              os_log_type_t v21 = v35;
              a4 = v58;
              uint64_t v14 = v59;
            }
            else
            {
              *(void *)os_log_type_t v21 = v24;
              v21 += 8;
            }
          }
          else
          {
            MEMORY[0x1F4188790]();
            *(&v57 - 2) = (uint64_t)v24;
            *(&v57 - 1) = (uint64_t)v22;
            uint32_t v22 = &v57 - 2;
          }
          uint64_t v23 = (v23 + 1);
          if (*((unsigned char *)v24 + 76))
          {
            unint64_t v39 = *((void *)v24 + 6);
LABEL_56:
            *((unsigned char *)v24 + 77) = 1;
            uint64_t v41 = *(void *)v24;
            uint64_t v40 = (void *)*((void *)v24 + 1);
            *(void *)(v41 + 8) = v40;
            *uint64_t v40 = v41;
            *(void *)uint64_t v24 = v24;
            *((void *)v24 + 1) = v24;
            mach_msg_id_t v42 = (void *)*((void *)v24 + 3);
            uint64_t v43 = *((void *)v24 + 2);
            *(void *)(v43 + 8) = v42;
            *mach_msg_id_t v42 = v43;
            *((void *)v24 + 2) = v24 + 4;
            *((void *)v24 + 3) = v24 + 4;
            if (v39)
            {
              uint64_t v44 = v23;
              uint64_t v45 = std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::find<CA::Render::Object *>(v60, *((void *)v24 + 6));
              if (v45 && (void *)v45[4] == v45 + 3) {
                std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::erase(v60, v45);
              }
              char v12 = v63;
              uint64_t v23 = v44;
            }
            goto LABEL_61;
          }
        }
        if (a4)
        {
          unint64_t v39 = a2;
          if (*((void *)v24 + 6) == a2) {
            goto LABEL_56;
          }
        }
LABEL_61:
        BOOL v17 = v16 != v12;
        BOOL v18 = v15 != v14;
        if (v15 == v14 && v16 == v12)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::notification_lock);
          for (i = v57; v22; uint32_t v22 = (uint64_t *)v22[1])
          {
            uint64_t v47 = *v22;
            (*(void (**)(unint64_t, void, uint64_t))(*v22 + 40))(a2, *(void *)(*v22 + 56), i);
            int v48 = *(unsigned __int8 *)(v47 + 77);
            if (atomic_fetch_add((atomic_uint *volatile)(v47 + 72), 0xFFFFFFFF) == 1) {
              dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v47 + 64));
            }
            if (v48)
            {
              dispatch_release(*(dispatch_object_t *)(v47 + 64));
              malloc_zone = (malloc_zone_t *)get_malloc_zone();
              malloc_zone_free(malloc_zone, (void *)v47);
            }
          }
          if (v20 != v21)
          {
            unsigned int v50 = v20;
            do
            {
              uint64_t v51 = *(void *)v50;
              (*(void (**)(unint64_t, void, uint64_t))(*(void *)v50 + 40))(a2, *(void *)(*(void *)v50 + 56), i);
              int v52 = *(unsigned __int8 *)(v51 + 77);
              if (atomic_fetch_add((atomic_uint *volatile)(v51 + 72), 0xFFFFFFFF) == 1) {
                dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v51 + 64));
              }
              if (v52)
              {
                dispatch_release(*(dispatch_object_t *)(v51 + 64));
                id v53 = (malloc_zone_t *)get_malloc_zone();
                malloc_zone_free(v53, (void *)v51);
              }
              v50 += 8;
            }
            while (v50 != v21);
          }
          if (v20) {
            operator delete(v20);
          }
          return;
        }
      }
      if (!v16) {
        __assert_rtn("post_notification", "render-notification.cpp", 434, "0");
      }
      if (v17) {
        uint64_t v24 = (atomic_uint *)(v16 - 2);
      }
      else {
        uint64_t v24 = 0;
      }
      goto LABEL_24;
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::notification_lock);
}

void CA::Render::Server::CmdStreamMsg::_send_reply(CA::Render::Server::CmdStreamMsg *this)
{
  mach_msg_return_t v5;
  mach_msg_header_t send_size;
  int v7;
  uint64_t v8;

  unint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *((void *)this + 2);
  if (*(_DWORD *)(v1 + 8))
  {
    char v7 = 0;
    uint64_t v3 = *(void *)(v1 + 16);
    *(_OWORD *)&send_size.uint64_t msgh_bits = *(_OWORD *)v1;
    *(void *)&send_size.uint64_t msgh_voucher_port = v3;
    send_size.msgh_size = 28;
    send_size.mach_port_t msgh_local_port = 0;
    BOOLean_t v4 = voucher_mach_msg_set(&send_size);
    uint64_t v5 = mach_msg(&send_size, 1, send_size.msgh_size, 0, 0, 0, 0);
    if (v4) {
      voucher_mach_msg_clear(&send_size);
    }
    if ((v5 - 268435459) <= 1) {
      mach_msg_destroy(&send_size);
    }
    *(_DWORD *)(*((void *)this + 2) + 8) = 0;
  }
}

void CA::Render::Context::run_scheduled_handle_updates(CA::Render::Context *this)
{
  uint64_t v2 = (CA::Render::Handle **)*((void *)this + 49);
  uint64_t v3 = (CA::Render::Handle **)*((void *)this + 50);
  if (v2 != v3)
  {
    do
    {
      BOOLean_t v4 = *v2;
      uint64_t v5 = (CA::Render::Context *)CA::Render::Handle::retain_context(*v2);
      if (v5)
      {
        uint64_t v6 = (atomic_uint *)v5;
        CA::Render::Context::will_commit(v5);
        CA::Render::Handle::set_update_flags(v4, 4);
        CA::Render::Context::did_commit((unint64_t)v6, 1, 0, 1, 0, 0);
        if (atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
        }
      }
      if (atomic_fetch_add((atomic_uint *volatile)v4 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(CA::Render::Handle *))(*(void *)v4 + 16))(v4);
      }
      ++v2;
    }
    while (v2 != v3);
    uint64_t v2 = (CA::Render::Handle **)*((void *)this + 49);
  }
  *((void *)this + 50) = v2;
}

void CA::WindowServer::Server::get_active_display_count(CA::WindowServer::Server *this, CA::Render::Object *a2, unsigned char *a3, void *a4)
{
  if (!*((unsigned char *)a2 + 512)
    && (*(double (**)(void))(**((void **)a2 + 12) + 744))(*((void *)a2 + 12)) != 0.0)
  {
    ++*(void *)a3;
    char v6 = a3[8];
    if (v6) {
      char v6 = fabs((*(double (**)(void))(**((void **)a2 + 12) + 744))(*((void *)a2 + 12)) + -0.00416666667) < 0.005;
    }
    a3[8] = v6;
  }
}

double CA::WindowServer::IOMFBDisplay::refresh_rate(CA::WindowServer::IOMFBDisplay *this)
{
  if (*((unsigned char *)this + 636) == 1 && *((void *)this + 80) == -1)
  {
    double v4 = (double)(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 768))(this);
    return (*(double (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 760))(this) * v4;
  }
  else
  {
    uint64_t v2 = *(void (**)(void))(*(void *)this + 736);
    v2();
  }
  return result;
}

double CA::WindowServer::AppleInternalDisplay::heartbeat_rate(CA::WindowServer::AppleInternalDisplay *this)
{
  double result = *((double *)this + 3569);
  if (result == 0.0)
  {
    uint64_t v3 = getenv("CA_HEARTBEAT_RATE");
    if (v3)
    {
      double result = 1.0 / atof(v3);
    }
    else
    {
      double result = *((double *)this + 3565);
      if (result == 0.0)
      {
        unint64_t v4 = *((void *)this + 3564);
        if (v4)
        {
          double v5 = 1.16415322e-10;
          if ((*((_DWORD *)this + 156) & 0x10) == 0) {
            double v5 = 2.32830644e-10;
          }
          double result = v5 * (double)v4;
        }
        else
        {
          double result = 0.0166666667;
        }
      }
    }
    *((double *)this + 3569) = result;
  }
  uint64_t v6 = *((void *)this + 80);
  if (v6 != -1)
  {
    double result = 65536.0 / (double)(((unint64_t)v6 >> 29) & 0x1FFFFFF);
    if ((*((_DWORD *)this + 156) & 0x10) != 0 && v6 < 0) {
      return result * 0.5;
    }
  }
  return result;
}

uint64_t CA::WindowServer::AppleInternalDisplay::minimum_frame_duration(CA::WindowServer::AppleInternalDisplay *this)
{
  if ((*((_DWORD *)this + 156) & 0x10) != 0 && (*((void *)this + 80) & 0x8000000000000000) != 0)
  {
    uint64_t v3 = (_DWORD *)((char *)this + 27192);
    if (*((_DWORD *)this + 6798)) {
      unsigned int v4 = 4;
    }
    else {
      unsigned int v4 = 2;
    }
    if (initialized != -1)
    {
      uint64_t v6 = (char *)this + 27192;
      unsigned int v5 = v4;
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
      unsigned int v4 = v5;
      uint64_t v3 = v6;
    }
    if (v4 <= *(float *)&dword_1EB2ACB58)
    {
      return *(float *)&dword_1EB2ACB58;
    }
    else if (*v3)
    {
      return 4;
    }
    else
    {
      return 2;
    }
  }
  else
  {
    uint64_t v1 = *(uint64_t (**)(void))(*(void *)this + 776);
    return v1();
  }
}

void CA::WindowServer::IOMFBDisplay::hardware_refresh_rate(CA::WindowServer::IOMFBDisplay *this)
{
  if (*((unsigned char *)this + 636) == 1 && *((void *)this + 80) == -1)
  {
    (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, double))(*(void *)this + 776))(this, 0.0);
    (*(double (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 760))(this);
  }
}

CA::Render::Object *CA::Render::Handle::set_update_flags(CA::Render::Object *this, char a2)
{
  if ((a2 & 0x3F) != 0)
  {
    *((void *)this + 12) |= a2 & 0x3F | 0x100000000000;
    for (uint64_t i = (CA::Render::Context *)*((void *)this + 3); i; uint64_t i = (CA::Render::Context *)*((void *)this + 3))
    {
      this = CA::Render::Context::lookup_handle(i, *((CA::Render::Object **)this + 4), 0, 0, 0);
      if (!this) {
        break;
      }
      uint64_t v3 = *((void *)this + 12);
      if ((~v3 & 0x100000000020) == 0) {
        break;
      }
      *((void *)this + 12) = v3 | 0x100000000020;
    }
  }
  return this;
}

void CA::Render::Server::CmdStreamMsg::~CmdStreamMsg(CA::Render::Server::CmdStreamMsg *this)
{
  CA::Render::Server::CmdStreamMsg::~CmdStreamMsg(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  atomic_uint *v6;
  mach_vm_address_t v7;
  unint64_t v8;
  ipc_space_t *v9;
  unint64_t v10;

  uint64_t v2 = (char *)this + 4176;
  *(void *)this = &unk_1ED02F6E0;
  uint64_t v3 = *((void *)this + 521);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  if (*v2)
  {
    unsigned int v4 = *((void *)this + 4);
    if (v4) {
      mach_vm_deallocate(*MEMORY[0x1E4F14960], *(void *)v4, *(unsigned int *)(v4 + 12));
    }
    unsigned int v5 = *((void *)this + 5);
    if (v5)
    {
      if (*(unsigned char *)(v5 + 11))
      {
        char v7 = *(void *)v5;
        if (*(void *)v5 && *(_DWORD *)(v5 + 12))
        {
          unint64_t v8 = 0;
          double v9 = (ipc_space_t *)MEMORY[0x1E4F14960];
          do
          {
            mach_port_deallocate(*v9, *(_DWORD *)(v7 + 4 * v8++));
            uint64_t v10 = *(unsigned int *)(v5 + 12);
          }
          while (v8 < v10);
          mach_vm_deallocate(*v9, v7, 4 * v10);
        }
      }
      else
      {
        mach_port_deallocate(*MEMORY[0x1E4F14960], *(_DWORD *)v5);
      }
    }
  }
  else
  {
    mach_msg_destroy(*((mach_msg_header_t **)this + 2));
  }
  if (v2[1]) {
    free(*((void **)this + 2));
  }
  uint64_t v6 = (atomic_uint *)*((void *)this + 1);
  if (atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
  }
  x_heap_free(*((void ****)this + 6));
}

double CA::Render::Context::delay_of_batch(os_unfair_lock_s *this, unsigned int a2)
{
  unsigned int v4 = this + 170;
  os_unfair_lock_lock(this + 170);
  unsigned int v5 = *(double **)&this[172]._os_unfair_lock_opaque;
  double i = 0.0;
  if (v5)
  {
    char v7 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(&this[174]._os_unfair_lock_opaque, a2);
    if (v7)
    {
      uint64_t v8 = v7[3];
      for (i = *(double *)(v8 + 16); v5 != (double *)v8; unsigned int v5 = *(double **)v5)
      {
        if (((void)v5[2] & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000 && v5[2] > i) {
          double i = v5[2];
        }
      }
    }
  }
  os_unfair_lock_unlock(v4);
  return i;
}

void CA::Render::Context::mark_changed(unint64_t a1, int a2, char a3, uint64_t a4, uint64_t a5)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  ++*(_DWORD *)(a1 + 44);
  if ((*(_WORD *)(a1 + 552) & 0x40) == 0)
  {
    v6[0] = a2;
    if (a2) {
      *(double *)&a4 = -1.0;
    }
    BYTE1(v6[0]) = a3;
    v6[1] = a4;
    v6[2] = a5;
    CA::Render::post_notification(0, a1, (uint64_t)v6, 0);
  }
}

void _XRegisterFrameIntervalRange(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)a1 & 0x80000000) != 0 || *(_DWORD *)(a1 + 4) != 56)
  {
    int v3 = -304;
  }
  else if (*(_DWORD *)(a1 + 56) || *(_DWORD *)(a1 + 60) < 0x20u)
  {
    int v3 = -309;
  }
  else
  {
    int v6 = *(_DWORD *)(a1 + 32);
    int v5 = *(_DWORD *)(a1 + 36);
    unsigned int v8 = *(_DWORD *)(a1 + 40);
    int v7 = *(_DWORD *)(a1 + 44);
    int v9 = *(_DWORD *)(a1 + 48);
    int v10 = *(unsigned __int8 *)(a1 + 52);
    if (initialized != -1)
    {
      int v11 = *(_DWORD *)(a1 + 36);
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
      int v5 = v11;
    }
    if (byte_1EB2ACC45)
    {
      int v15 = v6;
      memset(buffer, 0, sizeof(buffer));
      int v12 = v5;
      proc_name(v5, buffer, 0x20u);
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v13 = x_log_category_frame_rate;
        if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = " compat";
          *(_DWORD *)buf = 67110402;
          *(_DWORD *)&uint8_t buf[4] = v8;
          LOWORD(v17) = 1024;
          if (!v10) {
            uint64_t v14 = "";
          }
          *(_DWORD *)((char *)&v17 + 2) = v7;
          HIWORD(v17) = 1024;
          int v18 = v9;
          *(_WORD *)uint64_t v19 = 2080;
          *(void *)&v19[2] = v14;
          __int16 v20 = 1024;
          int v21 = v12;
          __int16 v22 = 2080;
          uint64_t v23 = buffer;
          _os_log_impl(&dword_184668000, v13, OS_LOG_TYPE_DEFAULT, "CAFrameRateServer: receiving registration %u %u %u%s from %d[%s]", buf, 0x2Eu);
        }
      }
      int v5 = v12;
      int v6 = v15;
    }
    *(_DWORD *)buf = 0;
    *(_DWORD *)uint64_t v19 = v9;
    *(_DWORD *)&uint8_t buf[4] = v6;
    unint64_t v17 = __PAIR64__(v8, v5);
    int v18 = v7;
    *(_DWORD *)&v19[4] = v10 != 0;
    CA::Render::post_notification(0x37u, 0, (uint64_t)buf, 0);
    if (buf[0]) {
      int v3 = 0;
    }
    else {
      int v3 = 5;
    }
  }
  unsigned int v4 = (void *)MEMORY[0x1E4F14068];
  *(_DWORD *)(a2 + 32) = v3;
  *(void *)(a2 + 24) = *v4;
}

void CA::WindowServer::Server::get_displays(CA::WindowServer::Server *this, CA::Render::Object *a2, CFMutableArrayRef *a3, void *a4)
{
  keys[8] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)a2 + 12);
  int v6 = (void *)*((void *)a2 + 13);
  int v7 = (int *)(v5 + 25368);
  keys[0] = @"kCADisplayName";
  keys[1] = @"kCADisplayDeviceName";
  keys[2] = @"kCADisplayId";
  keys[3] = @"kCADisplayFrameCount";
  keys[4] = @"kCADisplaySkippedFrameCount";
  keys[5] = @"kCADisplayClonedFrameCount";
  keys[6] = @"kCADisplaySkippedClonedFrameCount";
  keys[7] = @"kCADisplayDirtyFrameCount";
  unsigned int v8 = *(void **)(v5 + 8);
  values[0] = v6;
  values[1] = v8;
  int valuePtr = *(_DWORD *)(v5 + 24);
  CFTypeRef cf = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  int valuePtr = *v7;
  CFTypeRef v13 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  int valuePtr = v7[1];
  CFTypeRef v14 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  int valuePtr = v7[2];
  CFTypeRef v15 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  int valuePtr = v7[3];
  CFTypeRef v16 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  int valuePtr = v7[4];
  CFTypeRef v17 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryRef v9 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 8, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFArrayAppendValue(*a3, v9);
  CFRelease(v9);
  CFRelease(cf);
  CFRelease(v13);
  CFRelease(v14);
  CFRelease(v15);
  CFRelease(v16);
  CFRelease(v17);
}

uint64_t _XSynchronize(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 && *(_DWORD *)(result + 24) == 1 && *(_DWORD *)(result + 4) == 68)
  {
    if (*(unsigned __int16 *)(result + 38) << 16 == 1179648)
    {
      if (!*(_DWORD *)(result + 68) && *(_DWORD *)(result + 72) > 0x1Fu)
      {
        double result = CASSynchronize((CA::Render::Context *)*(unsigned int *)(result + 12), *(_DWORD *)(result + 28), *(_DWORD *)(result + 48), *(_DWORD *)(result + 52), *(_DWORD *)(result + 56), *(_DWORD *)(result + 60), *(_DWORD *)(result + 64));
        *(_DWORD *)(a2 + 32) = result;
        return result;
      }
      int v3 = -309;
    }
    else
    {
      int v3 = -300;
    }
  }
  else
  {
    int v3 = -304;
  }
  *(_DWORD *)(a2 + 32) = v3;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

unint64_t CA::WindowServer::Server::context_created(unint64_t this, CA::Render::Object *a2, void *a3, void *a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)(this + 12) & 0x4200) != 0x4000) {
    return this;
  }
  unint64_t v5 = this;
  CFDictionaryRef v6 = *(const __CFDictionary **)(this + 32);
  if (v6)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(this + 32), @"displayId");
    if (Value)
    {
      this = CA_CFIntValue(Value);
      if (this)
      {
        if (*(_DWORD *)(*((void *)a2 + 12) + 24) != this) {
          return this;
        }
        goto LABEL_11;
      }
    }
    this = (unint64_t)CFDictionaryGetValue(v6, @"displayName");
    if (this)
    {
      this = CFEqual((CFTypeRef)this, *((CFTypeRef *)a2 + 13));
      if (!this) {
        return this;
      }
      goto LABEL_11;
    }
  }
  if ((*(unsigned char *)(*((void *)a2 + 12) + 745) & 0x20) == 0) {
    return this;
  }
LABEL_11:
  CFDictionaryRef v8 = *(const __CFDictionary **)(v5 + 32);
  if (v8)
  {
    CFDictionaryRef v9 = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 32), @"definesDisplayBounds");
    if (v9 && CA_CFBoolValue(v9)) {
      *(_DWORD *)(v5 + 12) |= 0x8000u;
    }
    int v10 = CFDictionaryGetValue(v8, @"displayFilter");
    if (v10)
    {
      if (CFEqual(v10, @"nearest")) {
        *(_DWORD *)(v5 + 12) |= 0x10000u;
      }
    }
  }
  *(_DWORD *)(v5 + 12) |= 0x200u;
  CA::Render::Context::set_display_id((CA::Render::Context *)v5, *(_DWORD *)(*((void *)a2 + 12) + 24));
  CA::Render::add_observer(2u, v5, (uint64_t)CA::WindowServer::Server::context_deleted, (uint64_t)a2, 1);
  CA::Render::add_observer(0, v5, (uint64_t)CA::WindowServer::Server::context_changed, (uint64_t)a2, 0);
  CA::Render::add_observer(8u, v5, (uint64_t)CA::WindowServer::Server::context_ordered, (uint64_t)a2, 0);
  CA::WindowServer::Server::invalidate_context((os_unfair_lock_s *)a2, (CA::Render::Context *)v5);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 4);
  uint64_t v11 = *((void *)a2 + 16);
  float v12 = *(float *)(v5 + 192);
  unint64_t v13 = 0;
  if (v11)
  {
    CFTypeRef v14 = (float *)(*((void *)a2 + 14) + 8);
    while (*v14 <= v12)
    {
      ++v13;
      v14 += 4;
      if (v11 == v13)
      {
        unint64_t v13 = *((void *)a2 + 16);
        break;
      }
    }
  }
  CA::WindowServer::Server::context_insert(a2, v13, (CA::Render::Context *)v5, v12);
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 4);
  uint64_t v15 = 0;
  int64x2_t v16 = vdupq_n_s64(4uLL);
  return (*(uint64_t (**)(CA::Render::Object *, uint64_t *, double))(*(void *)a2 + 184))(a2, &v15, 0.0);
}

uint64_t CA::WindowServer::IOMFBServer::post_render_statistics_power_log(CA::WindowServer::IOMFBServer *this, CA::Render::Object *a2, void *a3, void *a4)
{
  unint64_t v5 = (pthread_mutex_t *)((char *)a2 + 544);
  pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 544));
  uint64_t v6 = *((void *)a2 + 12);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 27544));
  if (*(unsigned char *)(v6 + 27548))
  {
    uint64_t v24 = (unsigned char *)(v6 + 27548);
    lock = (os_unfair_lock_s *)(v6 + 27544);
    BOOL v26 = v5;
    int v7 = (_OWORD *)(v6 + 27552);
    CFDictionaryRef v8 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    CFDictionaryRef v9 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v11 = CFDictionaryCreateMutable(0, 0, v8, v9);
    float v12 = CFDictionaryCreateMutable(0, 0, v8, v9);
    CA_CFDictionarySetInt(Mutable, @"bucket_size", 10);
    CA_CFDictionarySetInt(Mutable, @"bucket_count", 10);
    unint64_t v13 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    for (uint64_t i = 0; i != 40; i += 4)
      CA_CFArrayAppendInt(v13, *(_DWORD *)((char *)v7 + i));
    uint64_t v15 = (_OWORD *)(v6 + 27592);
    CFDictionarySetValue(Mutable, @"data", v13);
    *(void *)(v6 + 27584) = 0;
    _OWORD *v7 = 0u;
    *(_OWORD *)(v6 + 27568) = 0u;
    CA_CFDictionarySetInt(v11, @"bucket_size", 200);
    CA_CFDictionarySetInt(v11, @"bucket_count", 10);
    int64x2_t v16 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    for (uint64_t j = 0; j != 40; j += 4)
      CA_CFArrayAppendInt(v16, *(_DWORD *)((char *)v15 + j));
    CFDictionarySetValue(v11, @"data", v16);
    uint64_t v18 = 0;
    *(void *)(v6 + 27624) = 0;
    _OWORD *v15 = 0u;
    *(_OWORD *)(v6 + 27608) = 0u;
    uint64_t v19 = (_OWORD *)(v6 + 27632);
    do
    {
      int v20 = *((_DWORD *)v19 + v18);
      if (v20 >= 1)
      {
        CFStringRef v21 = CFStringCreateWithCString(0, *((const char **)&CA::WindowServer::IOMFBDisplay::offscreen_reason_string + v18), 0x8000100u);
        if (v21)
        {
          CFStringRef v22 = v21;
          CA_CFDictionarySetInt(v12, v21, v20);
          CFRelease(v22);
        }
      }
      ++v18;
    }
    while (v18 != 12);
    v19[1] = 0u;
    v19[2] = 0u;
    _OWORD *v19 = 0u;
    *uint64_t v24 = 0;
    if (v16) {
      CFRelease(v16);
    }
    unint64_t v5 = v26;
    if (v13) {
      CFRelease(v13);
    }
    os_unfair_lock_unlock(lock);
    if (CA::WindowServer::IOMFBDisplay::post_render_statistics_power_log(void)::once != -1) {
      dispatch_once(&CA::WindowServer::IOMFBDisplay::post_render_statistics_power_log(void)::once, &__block_literal_global_463);
    }
    if (CA::WindowServer::IOMFBDisplay::post_render_statistics_power_log(void)::render_pass_id) {
      pps_send_telemetry();
    }
    if (CA::WindowServer::IOMFBDisplay::post_render_statistics_power_log(void)::layer_count_id) {
      pps_send_telemetry();
    }
    if (CA::WindowServer::IOMFBDisplay::post_render_statistics_power_log(void)::offscreen_reasons_id) {
      pps_send_telemetry();
    }
    if (v12) {
      CFRelease(v12);
    }
    if (v11) {
      CFRelease(v11);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 27544));
  }

  return pthread_mutex_unlock(v5);
}

_DWORD *CA::WindowServer::Server::get_display_edr_state(CA::WindowServer::Server *this, CA::Render::Object *a2, void *a3, void *a4)
{
  uint64_t v4 = *((void *)a2 + 12);
  if (*((_DWORD *)a3 + 1) == *(_DWORD *)(v4 + 24))
  {
    *(unsigned char *)a3 = 1;
    double result = CA::WindowServer::Display::initialize_edr_state((_DWORD *)v4);
    a3[1] = *(void *)(v4 + 680);
  }
  return result;
}

void _XGetDisplayInfo(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  uint64_t v162 = *MEMORY[0x1E4F143B8];
  if ((*v1 & 0x80000000) != 0 || v1[1] != 40)
  {
    int v4 = -304;
    goto LABEL_7;
  }
  long long v92 = 0u;
  long long v93 = 0u;
  long long src = 0u;
  long long v91 = 0u;
  *(_OWORD *)unint64_t v74 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  if (v1[10] || v1[11] <= 0x1Fu)
  {
    int v4 = -309;
LABEL_7:
    *(_DWORD *)(v2 + 32) = v4;
LABEL_8:
    *(void *)(v3 + 24) = *MEMORY[0x1E4F14068];
    return;
  }
  *(_DWORD *)(v2 + 36) = 16777473;
  *(_DWORD *)(v2 + 52) = 16777473;
  *(_DWORD *)(v2 + 68) = 16777473;
  *(_DWORD *)(v2 + 84) = 16777473;
  *(void *)(v2 + 96) = 0x13000000000000;
  if (v1[9])
  {
    int v5 = 5;
LABEL_11:
    *(_DWORD *)(v3 + 32) = v5;
    goto LABEL_8;
  }
  uint64_t v6 = (_OWORD *)(v2 + 128);
  int v7 = v1[8];
  bzero(v94, 0x23A8uLL);
  __long long src = v143;
  v140 = (char *)v143;
  v141 = v143;
  uint64_t v142 = 16;
  int v95 = v7;
  CA::Render::post_notification(0x1Bu, 0, (uint64_t)v94, 0);
  int v8 = v94[0];
  if (v94[0])
  {
    long long v9 = v98;
    *uint64_t v6 = v97;
    *(_OWORD *)(v3 + 144) = v9;
    long long v10 = v100;
    *(_OWORD *)(v3 + 160) = v99;
    *(_OWORD *)(v3 + 176) = v10;
    long long src = v101;
    long long v91 = v102;
    long long v92 = v103;
    long long v93 = v104;
    long long v76 = v107;
    long long v77 = v108;
    *(_OWORD *)unint64_t v74 = v105;
    long long v75 = v106;
    long long v80 = v111;
    long long v81 = v112;
    long long v78 = v109;
    long long v79 = v110;
    long long v84 = v115;
    long long v85 = v116;
    long long v82 = v113;
    long long v83 = v114;
    long long v88 = v119;
    long long v89 = v120;
    long long v86 = v117;
    long long v87 = v118;
    *(void *)(v3 + 112) = v96;
    vm_address_t address = 0;
    uint64_t v11 = v122;
    float v12 = (void *)MEMORY[0x1E4F14B00];
    unint64_t v13 = (vm_map_t *)MEMORY[0x1E4F14960];
    if (v122)
    {
      vm_size_t v14 = (*MEMORY[0x1E4F14B00] + 8 * v122 - 1) & -*MEMORY[0x1E4F14B00];
      vm_allocate(*MEMORY[0x1E4F14960], &address, v14, 1);
      if (address)
      {
        memcpy((void *)address, &v121, 8 * v11);
        vm_address_t v15 = address;
      }
      else
      {
        vm_address_t v15 = 0;
      }
    }
    else
    {
      vm_address_t v15 = 0;
      LODWORD(v14) = 0;
    }
    *(void *)(v3 + 28) = v15;
    BOOL v28 = v15 == 0;
    if (v15) {
      int v17 = v14;
    }
    else {
      int v17 = 0;
    }
    int v29 = v122;
    if (v28) {
      int v29 = 0;
    }
    HIDWORD(v72) = v29;
    *(void *)(v3 + 44) = 0;
    *(void *)(v3 + 60) = 0;
    vm_address_t address = 0;
    size_t v30 = v140 - (unsigned char *)__src;
    if (v140 != __src
      && (vm_size_t v16 = (v30 + *v12 - 1) & -*v12, vm_allocate(*v13, &address, v16, 1), address)
      && (memcpy((void *)address, __src, v30), address))
    {
      LODWORD(v72) = -1431655765 * ((unint64_t)(v140 - (unsigned char *)__src) >> 2);
      *(void *)(v3 + 76) = address;
    }
    else
    {
      LODWORD(v72) = 0;
      LODWORD(v16) = 0;
      *(void *)(v3 + 76) = 0;
    }
    HIDWORD(v71) = v143[48];
    uint64_t v23 = v125;
    long long v60 = v126;
    long long v61 = v123;
    uint64_t v57 = v128;
    long long v58 = v127;
    int v22 = v130;
    int v24 = v131;
    long long v67 = v133;
    unint64_t v70 = __PAIR64__(v124, v134);
    int v25 = v135;
    int v26 = v136;
    unint64_t v69 = __PAIR64__(v129, v137);
    unint64_t v68 = __PAIR64__(v132, v138);
    uint64_t v27 = v145;
    uint64_t v63 = v146;
    LOBYTE(v71) = v147;
    uint64_t v64 = v148;
    long long v65 = v144;
    if (object_handle)
    {
      int v31 = CA::Render::Shmem::port(object_handle);
      int v32 = object_handle;
      *(_DWORD *)(v3 + 92) = v31;
      if (v32) {
        uint64_t v66 = *((void *)v32 + 2);
      }
      else {
        uint64_t v66 = 0;
      }
    }
    else
    {
      uint64_t v66 = 0;
      *(_DWORD *)(v3 + 92) = 0;
    }
    int v5 = 0;
    int v62 = v151;
    long long v53 = v152;
    long long v54 = v150;
    uint64_t v51 = v154;
    long long v52 = v153;
    int v18 = v155;
    char v19 = v156;
    char v59 = v157;
    long long v55 = v160;
    long long v56 = v159;
    char v20 = v158;
    char v21 = v161;
  }
  else
  {
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    unint64_t v69 = 0;
    unint64_t v70 = 0;
    unint64_t v68 = 0;
    LODWORD(v16) = 0;
    uint64_t v66 = 0;
    int v62 = 0;
    int v17 = 0;
    int v18 = 0;
    char v19 = 0;
    char v59 = 0;
    char v20 = 0;
    char v21 = 0;
    long long v67 = 0u;
    int v22 = 0;
    uint64_t v23 = 0;
    int v24 = 0;
    int v25 = 0;
    int v26 = 0;
    uint64_t v27 = 0;
    uint64_t v64 = 0;
    long long v65 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    uint64_t v57 = 0;
    long long v58 = 0u;
    int v5 = 56;
    uint64_t v63 = 0;
    long long v53 = 0u;
    long long v54 = 0u;
    uint64_t v51 = 0;
    long long v52 = 0u;
  }
  if (__src != v141) {
    free(__src);
  }
  if (!v8) {
    goto LABEL_11;
  }
  *(_DWORD *)(v3 + 40) = v17;
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(v3 + 72) = 0;
  *(_DWORD *)(v3 + 88) = v16;
  uint64_t v33 = *MEMORY[0x1E4F14068];
  *(void *)(v3 + 104) = *MEMORY[0x1E4F14068];
  size_t v34 = strlen((const char *)(v3 + 128));
  if ((v34 + 1) >> 32)
  {
    *(_DWORD *)(v3 + 32) = -304;
    *(void *)(v3 + 24) = v33;
  }
  else
  {
    char v35 = v21;
    *(_DWORD *)(v3 + 120) = 0;
    *(_DWORD *)(v3 + 124) = v34 + 1;
    uint64_t v36 = (v34 + 4) & 0xFFFFFFFC;
    int v37 = v36 + 468;
    uint64_t v38 = v3 + v36;
    uint64_t v39 = v38 - 64;
    uint64_t v40 = (char *)(v38 + 136);
    uint64_t v41 = MEMORY[0x1E4F149B0];
    if (MEMORY[0x1E4F149B0]) {
      int v42 = mig_strncpy_zerofill(v40, (const char *)&src, 64);
    }
    else {
      int v42 = mig_strncpy(v40, (const char *)&src, 64);
    }
    *(_DWORD *)(v39 + 192) = 0;
    *(_DWORD *)(v39 + 196) = v42;
    uint64_t v43 = (v42 + 3) & 0xFFFFFFFC;
    int v44 = v37 + v43;
    uint64_t v45 = v39 + v43;
    uint64_t v46 = v45 - 64;
    uint64_t v47 = (char *)(v45 + 208);
    if (v41) {
      int v48 = mig_strncpy_zerofill(v47, v74, 256);
    }
    else {
      int v48 = mig_strncpy(v47, v74, 256);
    }
    *(_DWORD *)(v46 + 268) = v48;
    *(_DWORD *)(v46 + 264) = 0;
    uint64_t v49 = (v48 + 3) & 0xFFFFFFFC;
    uint64_t v50 = v46 + v49;
    *(_DWORD *)(v50 + 272) = v17;
    *(void *)(v46 + v49 + 276) = 0;
    *(_DWORD *)(v50 + 284) = HIDWORD(v72);
    *(_DWORD *)(v50 + 288) = 0;
    *(_OWORD *)(v46 + v49 + 292) = v61;
    *(_DWORD *)(v50 + 308) = HIDWORD(v70);
    *(void *)(v50 + 312) = v23;
    *(_OWORD *)(v50 + 320) = v60;
    *(_OWORD *)(v50 + 336) = v58;
    *(void *)(v50 + 352) = v57;
    *(_DWORD *)(v50 + 360) = HIDWORD(v69);
    *(_DWORD *)(v50 + 364) = v22;
    *(_DWORD *)(v50 + 368) = v24;
    *(_DWORD *)(v50 + 372) = HIDWORD(v68);
    *(_OWORD *)(v46 + v49 + 376) = v67;
    *(_DWORD *)(v50 + 392) = v70;
    *(_DWORD *)(v50 + 396) = v25;
    *(_DWORD *)(v50 + 400) = v26;
    *(_DWORD *)(v50 + 404) = v69;
    *(_DWORD *)(v50 + 408) = v68;
    *(_DWORD *)(v50 + 412) = v16;
    *(_DWORD *)(v50 + 416) = v72;
    *(_DWORD *)(v50 + 420) = HIDWORD(v71);
    *(_OWORD *)(v46 + v49 + 424) = v65;
    *(void *)(v50 + 440) = v27;
    *(void *)(v50 + 448) = v63;
    *(unsigned char *)(v50 + 456) = v71;
    *(_DWORD *)(v50 + 460) = 0;
    *(_DWORD *)(v46 + v49 + 457) = 0;
    *(void *)(v50 + 464) = v64;
    *(void *)(v50 + 472) = v66;
    *(_OWORD *)(v50 + 480) = v54;
    *(_DWORD *)(v50 + 496) = v62;
    *(_DWORD *)(v50 + 500) = 0;
    *(_OWORD *)(v46 + v49 + 504) = v53;
    *(_OWORD *)(v46 + v49 + 520) = v52;
    *(void *)(v50 + 536) = v51;
    *(_DWORD *)(v50 + 544) = v18;
    *(unsigned char *)(v50 + 548) = v19;
    *(_WORD *)(v46 + v49 + 549) = 0;
    *(unsigned char *)(v50 + 551) = 0;
    *(unsigned char *)(v50 + 552) = v59;
    *(_WORD *)(v46 + v49 + 553) = 0;
    *(unsigned char *)(v50 + 555) = 0;
    *(unsigned char *)(v50 + 556) = v20;
    *(unsigned char *)(v50 + 559) = 0;
    *(_WORD *)(v46 + v49 + 557) = 0;
    *(_OWORD *)(v50 + 560) = v56;
    *(_OWORD *)(v50 + 576) = v55;
    *(unsigned char *)(v50 + 592) = v35;
    *(_WORD *)(v46 + v49 + 593) = 0;
    *(unsigned char *)(v50 + 595) = 0;
    *(_DWORD *)v3 |= 0x80000000;
    *(_DWORD *)(v3 + 4) = v44 + v49;
    *(_DWORD *)(v3 + 24) = 5;
  }
}

void _XGetDisplays(_DWORD *a1, uint64_t a2)
{
  propertyList[1] = *(CFPropertyListRef *)MEMORY[0x1E4F143B8];
  if ((*a1 & 0x80000000) != 0 || a1[1] != 36)
  {
    int v3 = -304;
  }
  else if (a1[9] || a1[10] <= 0x1Fu)
  {
    int v3 = -309;
  }
  else
  {
    *(_DWORD *)(a2 + 36) = 16777473;
    if (!a1[8])
    {
      CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF98];
      propertyList[0] = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF98], 0, MEMORY[0x1E4F1D510]);
      CA::Render::post_notification(0x1Au, 0, (uint64_t)propertyList, 0);
      vm_address_t address = 0;
      CFDataRef Data = CFPropertyListCreateData(v4, propertyList[0], kCFPropertyListBinaryFormat_v1_0, 0, 0);
      if (Data)
      {
        CFDataRef v6 = Data;
        size_t Length = CFDataGetLength(Data);
        vm_allocate(*MEMORY[0x1E4F14960], &address, (Length + *MEMORY[0x1E4F14B00] - 1) & -*MEMORY[0x1E4F14B00], 1);
        int v8 = (void *)address;
        if (address)
        {
          BytePtr = CFDataGetBytePtr(v6);
          memcpy(v8, BytePtr, Length);
        }
        CFRelease(v6);
      }
      else
      {
        LODWORD(Length) = 0;
      }
      CFRelease(propertyList[0]);
      vm_address_t v10 = address;
      *(void *)(a2 + 28) = address;
      int v11 = v10 ? Length : 0;
      *(_DWORD *)(a2 + 52) = v11;
      if (v10)
      {
        *(_DWORD *)(a2 + 40) = v11;
        *(void *)(a2 + 44) = *MEMORY[0x1E4F14068];
        *(_DWORD *)a2 |= 0x80000000;
        *(_DWORD *)(a2 + 4) = 56;
        *(_DWORD *)(a2 + 24) = 1;
        return;
      }
    }
    int v3 = 5;
  }
  *(_DWORD *)(a2 + 32) = v3;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
}

uint64_t _XApplyFenceTransaction(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 84)
  {
    int v3 = -304;
    goto LABEL_12;
  }
  if (*(_WORD *)(result + 38) != 529
    || *(unsigned char *)(result + 55) != 1
    || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 72)
    || *(_DWORD *)(result + 76) != *(_DWORD *)(result + 56) >> 2)
  {
    int v3 = -300;
    goto LABEL_12;
  }
  if (*(_DWORD *)(result + 84) || *(_DWORD *)(result + 88) <= 0x1Fu)
  {
    int v3 = -309;
LABEL_12:
    *(_DWORD *)(a2 + 32) = v3;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return result;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  *(_DWORD *)(a2 + 52) = 16777473;
  *(void *)(a2 + 64) = 0x10000000000000;
  *(void *)(a2 + 76) = 0x11000000000000;
  double result = CASApplyFenceTransaction(*(_DWORD *)(result + 68), *(void *)(result + 28), *(_DWORD *)(result + 40), *(void *)(result + 44), *(_DWORD *)(result + 56) >> 2, *(unsigned __int8 *)(result + 80), (vm_address_t *)(a2 + 28), (_DWORD *)(a2 + 92), (vm_address_t *)(a2 + 44), (unsigned int *)(a2 + 96), (_DWORD *)(a2 + 60), (_DWORD *)(a2 + 72), (unsigned char *)(a2 + 100), (void *)(a2 + 104));
  int v4 = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a2 + 40) = 8 * *(_DWORD *)(a2 + 92);
  *(_DWORD *)(a2 + 56) = 4 * v4;
  *(void *)(a2 + 84) = *MEMORY[0x1E4F14068];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 112;
  *(_DWORD *)(a2 + 24) = 4;
  return result;
}

void CA::WindowServer::IOMFBServer::register_frame_interval_reasons(CA::WindowServer::IOMFBServer *this, CA::Render::Object *a2, _DWORD *a3, void *a4)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)a2 + 12);
  if ((*(_DWORD *)(v4 + 624) & 0x100) != 0)
  {
    int v6 = a3[1];
    if ((!v6 || *(_DWORD *)(v4 + 24) == v6) && (*(_WORD *)(v4 + 656) & 0x1C00) == 0)
    {
      uint64_t v7 = a3[2];
      int v8 = (int *)*((void *)a3 + 2);
      unint64_t v9 = *((void *)a3 + 3);
      vm_address_t v10 = (os_unfair_lock_s *)(v4 + 27448);
      os_unfair_lock_lock((os_unfair_lock_t)(v4 + 27448));
      int v17 = *(_DWORD **)(v4 + 27456);
      int v18 = *(_DWORD **)(v4 + 27464);
      char v19 = v17;
      if (v17 != v18)
      {
        while (*v19 != v7)
        {
          v19 += 7;
          if (v19 == v18) {
            goto LABEL_10;
          }
        }
      }
      if (v19 == v18)
      {
LABEL_10:
        if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * (v18 - v17)) >= 0x40)
        {
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            int v22 = x_log_category_frame_rate;
            if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_184668000, v22, OS_LOG_TYPE_DEFAULT, "CAFrameRateServer too many reasons.", buf, 2u);
            }
          }
          goto LABEL_48;
        }
        if (!v9)
        {
LABEL_48:
          os_unfair_lock_unlock(v10);
          *(unsigned char *)a3 = 1;
          return;
        }
        if (v7)
        {
          os_unfair_lock_lock((os_unfair_lock_t)(v4 + 27396));
          [(CAProcessMonitor *)CA::WindowServer::IOMFBDisplay::process_monitor((CA::WindowServer::IOMFBDisplay *)v4) addMonitoringProcess:v7];
          os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 27396));
          int v18 = *(_DWORD **)(v4 + 27464);
        }
        unint64_t v20 = *(void *)(v4 + 27472);
        if ((unint64_t)v18 >= v20)
        {
          uint64_t v23 = *(_DWORD **)(v4 + 27456);
          unint64_t v24 = 0x6DB6DB6DB6DB6DB7 * (v18 - v23) + 1;
          if (v24 > 0x924924924924924) {
            abort();
          }
          unint64_t v25 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v20 - (void)v23) >> 2);
          if (2 * v25 > v24) {
            unint64_t v24 = 2 * v25;
          }
          if (v25 >= 0x492492492492492) {
            unint64_t v26 = 0x924924924924924;
          }
          else {
            unint64_t v26 = v24;
          }
          if (v26)
          {
            if (v26 > 0x924924924924924) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            uint64_t v27 = (char *)operator new(28 * v26);
          }
          else
          {
            uint64_t v27 = 0;
          }
          BOOL v28 = &v27[4 * (v18 - v23)];
          *(_DWORD *)BOOL v28 = v7;
          *(void *)(v28 + 4) = 0;
          char v21 = v28 + 28;
          *(void *)(v28 + 20) = 0;
          *(void *)(v28 + 12) = 0;
          if (v18 != v23)
          {
            do
            {
              long long v29 = *(_OWORD *)(v18 - 7);
              *((_OWORD *)v28 - 1) = *((_OWORD *)v18 - 1);
              *(_OWORD *)(v28 - 28) = v29;
              v28 -= 28;
              v18 -= 7;
            }
            while (v18 != v23);
            int v18 = *(_DWORD **)(v4 + 27456);
          }
          *(void *)(v4 + 27456) = v28;
          *(void *)(v4 + 27464) = v21;
          *(void *)(v4 + 27472) = &v27[28 * v26];
          if (v18) {
            operator delete(v18);
          }
        }
        else
        {
          _DWORD *v18 = v7;
          char v21 = v18 + 7;
          *(void *)(v18 + 1) = 0;
          *(void *)(v18 + 5) = 0;
          *(void *)(v18 + 3) = 0;
        }
        *(void *)(v4 + 27464) = v21;
        char v19 = v21 - 7;
      }
      if (v9 && *v8)
      {
        uint64_t v30 = 0;
        *((void *)v19 + 1) = 0;
        *((void *)v19 + 2) = 0;
        uint64_t v31 = 4;
        if (v9 < 4) {
          uint64_t v31 = v9;
        }
        do
        {
          int v33 = *v8++;
          int v32 = v33;
          if (v33)
          {
            size_t v34 = &v19[v30++];
            v34[2] = v32;
          }
          --v31;
        }
        while (v31);
      }
      else
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v4 + 27396));
        char v35 = *(char **)(v4 + 27464);
        uint64_t v36 = v35 - (char *)(v19 + 7);
        if (v35 != (char *)(v19 + 7)) {
          memmove(v19, v19 + 7, v35 - (char *)(v19 + 7));
        }
        *(void *)(v4 + 27464) = (char *)v19 + v36;
        os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 27396));
      }
      if (byte_1EB2ACC45)
      {
        *(void *)buf = 0;
        uint64_t v50 = 0;
        uint64_t v51 = 0;
        x_stream_printf((uint64_t)buf, "  Reasons: %ld", v11, v12, v13, v14, v15, v16, 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v4 + 27464) - *(void *)(v4 + 27456)) >> 2));
        uint64_t v43 = *(unsigned int **)(v4 + 27456);
        for (uint64_t i = *(unsigned int **)(v4 + 27464); v43 != i; v43 += 7)
        {
          x_stream_printf((uint64_t)buf, "    %d: ", v37, v38, v39, v40, v41, v42, *v43);
          for (uint64_t j = 2; j != 6; ++j)
            x_stream_printf((uint64_t)buf, "%u %u, ", v37, v38, v39, v40, v41, v42, HIWORD(v43[j]));
        }
        uint64_t v46 = x_stream_finish((uint64_t)buf);
        if (v46)
        {
          uint64_t v47 = v46;
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            int v48 = x_log_category_frame_rate;
            if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long v52 = 136315138;
              long long v53 = v47;
              _os_log_impl(&dword_184668000, v48, OS_LOG_TYPE_DEFAULT, "CAFrameRateServer: %s\n", v52, 0xCu);
            }
          }
          free(v47);
        }
      }
      goto LABEL_48;
    }
  }
}

uint64_t _XRegisterFrameIntervalReasons(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)a1 & 0x80000000) != 0 && *(_DWORD *)(a1 + 24) == 1 && *(_DWORD *)(a1 + 4) == 64)
  {
    if (*(unsigned char *)(a1 + 39) == 1 && (unsigned int v3 = *(_DWORD *)(a1 + 40) >> 2, v3 == *(_DWORD *)(a1 + 60)))
    {
      if (*(_DWORD *)(a1 + 64) || *(_DWORD *)(a1 + 68) < 0x20u) {
        uint64_t result = 4294966987;
      }
      else {
        uint64_t result = CASRegisterFrameIntervalReasons(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 52), *(_DWORD *)(a1 + 56), *(void *)(a1 + 28), v3);
      }
    }
    else
    {
      uint64_t result = 4294966996;
    }
  }
  else
  {
    uint64_t result = 4294966992;
  }
  *(_DWORD *)(a2 + 32) = result;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

uint64_t CASRegisterFrameIntervalReasons(uint64_t a1, int a2, unsigned int a3, mach_vm_address_t a4, unsigned int a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  v9[0] = 0;
  mach_vm_size_t v6 = 4 * a5;
  v9[1] = a2;
  uint64_t v10 = a3;
  mach_vm_address_t v11 = a4;
  uint64_t v12 = a5;
  CA::Render::post_notification(0x38u, 0, (uint64_t)v9, 0);
  if (LOBYTE(v9[0])) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 5;
  }
  mach_vm_deallocate(*MEMORY[0x1E4F14960], a4, v6);
  return v7;
}

void CA::OGL::Context::image_volatile(CA::OGL::Context *this, CA::Render::Object *a2, void *a3, void *a4)
{
  mach_vm_size_t v6 = (os_unfair_lock_s *)((char *)a2 + 304);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 76);
  uint64_t v7 = x_hash_table_remove(*((void *)a2 + 39), (uint64_t)this);
  if (v7) {
    CA::OGL::Context::prepend_deleted_image(a2, v7);
  }

  os_unfair_lock_unlock(v6);
}

void CA::WindowServer::IOMFBServer::check_display_blanked(CA::WindowServer::IOMFBServer *this, CA::Render::Object *a2, unsigned char *a3, void *a4)
{
  uint64_t v4 = *((void *)a2 + 12);
  if (!*(unsigned char *)(v4 + 28138) && (*(_WORD *)(v4 + 656) & 0x1C00) != 0x1000 && *(_DWORD *)a3 == *(_DWORD *)(v4 + 24)) {
    a3[4] = *(unsigned char *)(*(void *)(v4 + 728) + 1) != 1;
  }
}

uint64_t _XUpdateClient(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 || *(_DWORD *)(result + 4) != 60)
  {
    int v3 = -304;
  }
  else
  {
    if (!*(_DWORD *)(result + 60) && *(_DWORD *)(result + 64) > 0x1Fu)
    {
      uint64_t result = CASUpdateClient(*(_DWORD *)(result + 12), (CA::Render::Context *)*(unsigned int *)(result + 32), *(double *)(result + 36), *(double *)(result + 52), *(unsigned int *)(result + 44), *(unsigned int *)(result + 48));
      *(_DWORD *)(a2 + 32) = result;
      return result;
    }
    int v3 = -309;
  }
  *(_DWORD *)(a2 + 32) = v3;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

uint64_t CASUpdateClient(int a1, CA::Render::Context *this, double a3, double a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = (CA::Render::Context *)CA::Render::Context::context_by_id(this);
  if (v10)
  {
    mach_vm_address_t v11 = (atomic_uint *)v10;
    CA::Render::Context::will_commit(v10);
    if (a4 != 0.0) {
      CA::Render::Context::add_input_time((CA::Render::Context *)v11, a4);
    }
    CA::Render::Context::did_commit((unint64_t)v11, 1, *(uint64_t *)&a3, 0, a5, a6);
    if (atomic_fetch_add(v11 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v11 + 16))(v11);
    }
  }
  return 0;
}

uint64_t _XRegisterClient(uint64_t result, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 5 || *(_DWORD *)(result + 4) != 108)
  {
    int v3 = -304;
    goto LABEL_14;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112
    || *(unsigned __int16 *)(result + 50) << 16 != 1114112
    || *(unsigned __int16 *)(result + 62) << 16 != 1114112
    || *(unsigned __int16 *)(result + 74) << 16 != 1114112
    || *(unsigned char *)(result + 87) != 1
    || *(_DWORD *)(result + 88) != *(_DWORD *)(result + 104))
  {
    int v3 = -300;
    goto LABEL_14;
  }
  if (*(_DWORD *)(result + 108) || *(_DWORD *)(result + 112) <= 0x1Fu)
  {
    int v3 = -309;
LABEL_14:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_15;
  }
  uint64_t v4 = (_DWORD *)(a2 + 28);
  *(void *)(a2 + 32) = 0x13000000000000;
  mach_port_name_t v5 = *(_DWORD *)(result + 28);
  mach_vm_size_t v6 = (const audit_token_t *)*(unsigned int *)(result + 40);
  mach_port_name_t v7 = *(_DWORD *)(result + 52);
  mach_port_name_t v8 = *(_DWORD *)(result + 64);
  int v9 = *(_DWORD *)(result + 100);
  uint64_t v10 = *(const UInt8 **)(result + 76);
  unsigned int v11 = *(_DWORD *)(result + 88);
  long long v12 = *(_OWORD *)(result + 144);
  v13[0] = *(_OWORD *)(result + 128);
  v13[1] = v12;
  uint64_t result = CASRegisterClient(v5, v6, v7, v8, v9, v10, v11, v4, (_DWORD *)(a2 + 48), (pid_t *)(a2 + 52), (CA::Render::Server *)v13);
  if (!result)
  {
    *(void *)(a2 + 40) = *MEMORY[0x1E4F14068];
    *(_DWORD *)a2 |= 0x80000000;
    *(_DWORD *)(a2 + 4) = 56;
    *(_DWORD *)(a2 + 24) = 1;
    return result;
  }
  *(_DWORD *)(a2 + 32) = result;
LABEL_15:
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

void CA::Render::Fence::btimeout_callback(CA::Render::Fence *this, double a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (CA::Render::Fence::fence_info_once[0] != -1) {
    dispatch_once_f(CA::Render::Fence::fence_info_once, 0, (dispatch_function_t)CA::Render::Fence::fence_info_init);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Fence::_lock);
  uint64_t v4 = *(uint64_t **)(CA::Render::Fence::batches_by_port + 16);
  if (!v4)
  {
LABEL_41:
    double v6 = INFINITY;
    goto LABEL_42;
  }
  char v5 = 0;
  double v6 = INFINITY;
  do
  {
    uint64_t v7 = CA::Render::Fence::cleared_b_ports;
    unsigned int v8 = *((_DWORD *)v4 + 4);
    int v9 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::cleared_b_ports, v8);
    if (v9) {
      goto LABEL_29;
    }
    uint64_t v10 = v4[3];
    double v11 = *(double *)(v10 + 16);
    if (v11 == 0.0)
    {
      double v11 = *(double *)(v10 + 8);
      if (v11 <= a2)
      {
        kdebug_trace();
        *(unsigned char *)(v4[3] + 44) = 1;
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          uint64_t v15 = x_log_category_render;
          int v9 = (uint64_t *)os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT);
          if (v9)
          {
            int v16 = *((_DWORD *)v4 + 4);
            *(_DWORD *)buf = 67109120;
            int v27 = v16;
            _os_log_impl(&dword_184668000, v15, OS_LOG_TYPE_DEFAULT, "timed out batch %x\n", buf, 8u);
          }
        }
        uint64_t v17 = v4[3];
        int v18 = *(uint64_t **)(*(void *)(v17 + 32) + 16);
        if (v18)
        {
          char v19 = (void *)CA::Render::Fence::bcontexts_by_id;
          do
          {
            int v9 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v19, *((_DWORD *)v18 + 4));
            if (v9)
            {
              double v20 = CA::Render::Context::delay_of_batch(*(os_unfair_lock_s **)v9[3], *((_DWORD *)v4 + 4));
              uint64_t v17 = v4[3];
              char v19 = (void *)CA::Render::Fence::bcontexts_by_id;
              if (v20 > *(double *)(v17 + 16)) {
                *(double *)(v17 + 16) = a2;
              }
            }
            int v18 = (uint64_t *)*v18;
          }
          while (v18);
        }
        double v11 = *(double *)(v17 + 16);
        if (v11 == 0.0 || v11 <= a2)
        {
          uint64_t v12 = CA::Render::Fence::cleared_b_ports;
          unsigned int v13 = *((_DWORD *)v4 + 4);
          int v14 = v13;
          goto LABEL_26;
        }
      }
    }
    else if (v11 <= a2)
    {
      uint64_t v12 = v7;
      unsigned int v13 = v8;
      int v14 = v8;
LABEL_26:
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(v12, v13, v14);
      char v5 = 1;
      goto LABEL_29;
    }
    if (v11 <= v6) {
      double v6 = v11;
    }
LABEL_29:
    uint64_t v4 = (uint64_t *)*v4;
  }
  while (v4);
  if ((v5 & 1) == 0 || !CA::Render::Fence::resolve_batches((CA::Render::Fence *)v9, a2)) {
    goto LABEL_42;
  }
  int v22 = *(uint64_t **)(CA::Render::Fence::batches_by_port + 16);
  if (!v22) {
    goto LABEL_41;
  }
  uint64_t v23 = (void *)CA::Render::Fence::cleared_b_ports;
  double v6 = INFINITY;
  do
  {
    if (!std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v23, *((_DWORD *)v22 + 4)))
    {
      uint64_t v24 = v22[3];
      double v25 = *(double *)(v24 + 16);
      if (v25 == 0.0) {
        double v25 = *(double *)(v24 + 8);
      }
      if (v25 <= v6) {
        double v6 = v25;
      }
    }
    int v22 = (uint64_t *)*v22;
  }
  while (v22);
LABEL_42:
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Fence::_lock);
  if ((*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL) {
    CA::Render::Server::add_callback(3, (uint64_t)CA::Render::Fence::btimeout_callback, 0, v6);
  }
}

uint64_t CA::OGL::AsynchronousItem::invalidate(uint64_t this)
{
  *(unsigned char *)(this + 356) = 1;
  return this;
}

void CA::Render::ShadowCache::path_deleted(CA::Render::ShadowCache *this, os_unfair_lock_s *a2, void *a3, void *a4)
{
  double v6 = a2 + 6;
  os_unfair_lock_lock(a2 + 6);
  uint64_t v7 = x_hash_table_remove(*(void *)&a2->_os_unfair_lock_opaque, (uint64_t)this);
  if (v7)
  {
    unsigned int v8 = (void *)v7;
    do
    {
      int v9 = v8;
      unsigned int v8 = (void *)*v8;
    }
    while (v8);
    void *v9 = *(void *)&a2[4]._os_unfair_lock_opaque;
    *(void *)&a2[4]._os_unfair_lock_opaque = v7;
  }

  os_unfair_lock_unlock(v6);
}

unsigned char *CA::WindowServer::Server::get_surface_replaceability(CA::WindowServer::Server *this, CA::Render::Object *a2, unsigned char *a3, void *a4)
{
  uint64_t result = (unsigned char *)*((void *)a2 + 12);
  if ((result[745] & 0x20) != 0)
  {
    uint64_t result = (unsigned char *)(*(uint64_t (**)(unsigned char *, void))(*(void *)result + 1632))(result, *(unsigned int *)a3);
    a3[4] = (_BYTE)result;
  }
  return result;
}

void _XGetNeededAlignment(_DWORD *a1, uint64_t a2)
{
  if ((*a1 & 0x80000000) != 0 || a1[1] != 24)
  {
    int v2 = -304;
    goto LABEL_7;
  }
  if (a1[6] || a1[7] <= 0x1Fu)
  {
    int v2 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v2;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return;
  }
  {
    uint64_t v4 = a2;
    a2 = v4;
  }
  int v3 = qword_1EB2A87C0;
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 36) = v3;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  *(_DWORD *)(a2 + 4) = 40;
}

void _XGetMaxRenderableIOSurfaceSize(_DWORD *a1, uint64_t a2)
{
  if ((*a1 & 0x80000000) != 0 || a1[1] != 24)
  {
    int v2 = -304;
    goto LABEL_7;
  }
  if (a1[6] || a1[7] <= 0x1Fu)
  {
    int v2 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v2;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return;
  }
  {
    uint64_t v3 = a2;
    a2 = v3;
  }
  *(_DWORD *)(a2 + 32) = 0;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  *(_DWORD *)(a2 + 4) = 48;
}

uint64_t CA::WindowServer::AppleInternalDisplay::hardware_minimum_frame_duration(CA::WindowServer::AppleInternalDisplay *this)
{
  uint64_t v1 = 1;
  if ((*((_DWORD *)this + 156) & 0x10) != 0)
  {
    if (*((uint64_t *)this + 80) >= 0) {
      uint64_t v1 = 1;
    }
    else {
      uint64_t v1 = 2;
    }
  }
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (v1 <= *(float *)&dword_1EB2ACB58) {
    return *(float *)&dword_1EB2ACB58;
  }
  return v1;
}

uint64_t CA::Render::release_object(CA::Render *this, atomic_uint *a2, void *a3)
{
  if (a2)
  {
    if (atomic_fetch_add(a2 + 2, 0xFFFFFFFF) == 1) {
      return (*(uint64_t (**)(atomic_uint *))(*(void *)a2 + 16))(a2);
    }
  }
  return result;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,BOOL (*)(unsigned int)>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)(unsigned int)>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)(unsigned int)>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,BOOL (*)(unsigned int)>>>::find<unsigned int>(unsigned int a1)
{
  if (!*((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1)) {
    return 0;
  }
  uint8x8_t v1 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 8));
  v1.i16[0] = vaddlv_u8(v1);
  if (v1.u32[0] > 1uLL)
  {
    unint64_t v2 = a1;
    if (*((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) <= (unint64_t)a1) {
      unint64_t v2 = (unint64_t)a1 % *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
    }
  }
  else
  {
    unint64_t v2 = (DWORD2(CA::Render::Server::dead_name_watch_list(void)::watch_list) - 1) & a1;
  }
  uint64_t i = *(uint64_t **)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v2);
  if (i)
  {
    for (uint64_t i = (uint64_t *)*i; i; uint64_t i = (uint64_t *)*i)
    {
      unint64_t v4 = i[1];
      if (v4 == a1)
      {
        if (*((_DWORD *)i + 4) == a1) {
          return i;
        }
      }
      else
      {
        if (v1.u32[0] > 1uLL)
        {
          if (v4 >= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1)) {
            v4 %= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
          }
        }
        else
        {
          v4 &= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) - 1;
        }
        if (v4 != v2) {
          return 0;
        }
      }
    }
  }
  return i;
}

void CA::Render::Server::dead_name_watch_list(CA::Render::Server *this)
{
  {
    CA::Render::Server::dead_name_watch_list(void)::watch_list = 0u;
    *(_OWORD *)&qword_1E8F85E28 = 0u;
    dword_1E8F85E38 = 1065353216;
  }
}

void _XGetSurfaceReplaceability(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)a1 & 0x80000000) != 0 || *(_DWORD *)(a1 + 4) != 36)
  {
    int v3 = -304;
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 36) || *(_DWORD *)(a1 + 40) <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 72);
  v8[0] = *(_OWORD *)(a1 + 56);
  v8[1] = v5;
  if ((CA::Render::Server::audit_token_cache_lookup((CA::Render::Server *)v8, (const audit_token_t *)a2) & 0x80) != 0
    || (CA::Render::Server::audit_token_cache_lookup((CA::Render::Server *)v8, v6) & 0x20000) != 0)
  {
    int v3 = -81182719;
    goto LABEL_7;
  }
  if (v4)
  {
    uint64_t v7 = v4;
    CA::Render::post_notification(0x34u, 0, (uint64_t)&v7, 0);
    *(_DWORD *)(a2 + 36) = BYTE4(v7);
  }
  *(_DWORD *)(a2 + 32) = 0;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  *(_DWORD *)(a2 + 4) = 40;
}

void CA::Render::Fence::ftimeout_callback(CA::Render::Fence *this, double a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (CA::Render::Fence::fence_info_once[0] != -1) {
    dispatch_once_f(CA::Render::Fence::fence_info_once, 0, (dispatch_function_t)CA::Render::Fence::fence_info_init);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Fence::_lock);
  unsigned int v4 = *(void **)(CA::Render::Fence::fences_by_name + 16);
  if (!v4) {
    goto LABEL_25;
  }
  char v5 = 0;
  double v6 = INFINITY;
  do
  {
    while (1)
    {
      uint64_t v7 = (CA::Render::Fence *)std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>((void *)CA::Render::Fence::cleared_f_names, v4[2]);
      if (v7) {
        goto LABEL_15;
      }
      uint64_t v8 = v4[3];
      double v9 = *(double *)(v8 + 8);
      if (v9 > a2) {
        break;
      }
      kdebug_trace();
      ht_fence_timeout();
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v10 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = v4[2];
          *(_DWORD *)buf = 134217984;
          uint64_t v16 = v11;
          _os_log_impl(&dword_184668000, v10, OS_LOG_TYPE_DEFAULT, "timed out fence %llu\n", buf, 0xCu);
        }
      }
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(CA::Render::Fence::cleared_f_names, v4[2], v4[2]);
      unsigned int v4 = (void *)*v4;
      char v5 = 1;
      if (!v4) {
        goto LABEL_17;
      }
    }
    if (v9 <= v6) {
      double v6 = *(double *)(v8 + 8);
    }
LABEL_15:
    unsigned int v4 = (void *)*v4;
  }
  while (v4);
  if ((v5 & 1) == 0) {
    goto LABEL_26;
  }
LABEL_17:
  if (CA::Render::Fence::resolve_fences(v7))
  {
    uint64_t v12 = *(void **)(CA::Render::Fence::fences_by_name + 16);
    if (v12)
    {
      unsigned int v13 = (void *)CA::Render::Fence::cleared_f_names;
      double v6 = INFINITY;
      do
      {
        if (!std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(v13, v12[2]))
        {
          uint64_t v14 = v12[3];
          if (*(double *)(v14 + 8) <= v6) {
            double v6 = *(double *)(v14 + 8);
          }
        }
        uint64_t v12 = (void *)*v12;
      }
      while (v12);
      goto LABEL_26;
    }
LABEL_25:
    double v6 = INFINITY;
  }
LABEL_26:
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Fence::_lock);
  if ((*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL) {
    CA::Render::Server::add_callback(3, (uint64_t)CA::Render::Fence::ftimeout_callback, 0, v6);
  }
}

void CA::Render::sync_req_timeout(os_unfair_lock_s *this, double a2, void *a3)
{
  char v5 = this + 13;
  os_unfair_lock_lock(this + 13);
  CA::Render::Context::check_sync_reqs((CA::Render::Context *)this, a2);
  os_unfair_lock_unlock(v5);
  if (atomic_fetch_add((atomic_uint *volatile)&this[2], 0xFFFFFFFF) == 1)
  {
    double v6 = *(void (**)(os_unfair_lock_s *))(*(void *)&this->_os_unfair_lock_opaque + 16);
    v6(this);
  }
}

void sub_1846E5260(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CAObject_setValueForKeyPath_(void *a1, void *a2, uint64_t a3, void *a4, int a5)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = objc_msgSend(a1, "valueForKey:");
  if (!v10) {
    return;
  }
  uint64_t v11 = (NSArray *)v10;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          if ((a5 & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
          {
            uint64_t v11 = (NSArray *)[(NSArray *)v11 mutableCopy];
            [a1 setValue:v11 forKey:a3];

            if (!v11) {
              return;
            }
          }
        }
        goto LABEL_113;
      }
      memset(v108, 0, 40);
      *(_OWORD *)long long v106 = 0u;
      long long v107 = 0u;
      [(NSArray *)v11 transformStruct];
      float64x2_t v98 = v90;
      float64x2_t v99 = v91;
      long long v100 = v92;
      CA::Mat2Impl::mat2_get_unmatrix((uint64_t)&v98, (uint64_t)v106);
      if ([a4 isEqualToString:@"rotation"])
      {
        [a2 doubleValue];
        *(void *)&v108[0] = v28;
      }
      else if ([a4 isEqualToString:@"scale"])
      {
        [a2 doubleValue];
        v106[0] = v32;
        v106[1] = v32;
      }
      else if ([a4 isEqualToString:@"scale.x"])
      {
        [a2 doubleValue];
        v106[0] = v43;
      }
      else if ([a4 isEqualToString:@"scale.y"])
      {
        [a2 doubleValue];
        v106[1] = v57;
      }
      else if ([a4 isEqualToString:@"translation"])
      {
        [a2 sizeValue];
        *(void *)&long long v107 = v67;
        *((void *)&v107 + 1) = v68;
      }
      else if ([a4 isEqualToString:@"translation.x"])
      {
        [a2 doubleValue];
        *(void *)&long long v107 = v71;
      }
      else
      {
        if (([a4 isEqualToString:@"translation.y"] & 1) == 0) {
          goto LABEL_113;
        }
        [a2 doubleValue];
        *((void *)&v107 + 1) = v75;
      }
      float64x2_t v98 = *(float64x2_t *)((char *)v108 + 8);
      float64x2_t v99 = *(float64x2_t *)((char *)&v108[1] + 8);
      long long v100 = v107;
      if (*(double *)v108 != 0.0) {
        CA::Mat2Impl::mat2_rotate(&v98, v27, *(double *)v108);
      }
      if (*(double *)v106 != 1.0 || *(double *)&v106[1] != 1.0)
      {
        float64x2_t v98 = vmulq_n_f64(v98, *(double *)v106);
        float64x2_t v99 = vmulq_n_f64(v99, *(double *)&v106[1]);
      }
      long long v76 = (void *)[MEMORY[0x1E4F28AF0] transform];
      v89[0] = v98;
      v89[1] = v99;
      v89[2] = v100;
      [v76 setTransformStruct:v89];
      unint64_t v26 = a1;
      uint64_t v25 = (uint64_t)v76;
      goto LABEL_83;
    }
    double v20 = (const char *)[(NSArray *)v11 objCType];
    if (v20)
    {
      char v21 = v20;
      if (!strcmp(v20, "{CGPoint=dd}"))
      {
        [(NSArray *)v11 pointValue];
        double v34 = v33;
        double v36 = v35;
        if ([a4 isEqualToString:@"x"])
        {
          [a2 doubleValue];
          double v34 = v37;
        }
        else
        {
          if (![a4 isEqualToString:@"y"]) {
            goto LABEL_113;
          }
          [a2 doubleValue];
          double v36 = v44;
        }
        uint64_t v45 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithPoint:", v34, v36);
      }
      else if (!strcmp(v21, "{CGSize=dd}"))
      {
        [(NSArray *)v11 sizeValue];
        double v39 = v38;
        double v41 = v40;
        if ([a4 isEqualToString:@"width"])
        {
          [a2 doubleValue];
          double v39 = v42;
        }
        else
        {
          if (![a4 isEqualToString:@"height"]) {
            goto LABEL_113;
          }
          [a2 doubleValue];
          double v41 = v56;
        }
        uint64_t v45 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithSize:", v39, v41);
      }
      else if (!strcmp(v21, "{CGRect={CGPoint=dd}{CGSize=dd}}"))
      {
        [(NSArray *)v11 rectValue];
        double v47 = v46;
        double v49 = v48;
        double v51 = v50;
        double v53 = v52;
        if ([a4 isEqualToString:@"origin"])
        {
          [a2 pointValue];
          double v47 = v54;
          double v49 = v55;
        }
        else if ([a4 isEqualToString:@"size"])
        {
          [a2 sizeValue];
          double v51 = v65;
          double v53 = v66;
        }
        else if ([a4 isEqualToString:@"origin.x"])
        {
          [a2 doubleValue];
          double v47 = v70;
        }
        else if ([a4 isEqualToString:@"origin.y"])
        {
          [a2 doubleValue];
          double v49 = v73;
        }
        else if ([a4 isEqualToString:@"size.width"])
        {
          [a2 doubleValue];
          double v51 = v77;
        }
        else
        {
          if (![a4 isEqualToString:@"size.height"]) {
            goto LABEL_113;
          }
          [a2 doubleValue];
          double v53 = v79;
        }
        uint64_t v45 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithRect:", v47, v49, v51, v53);
      }
      else
      {
        if (strcmp(v21, "{CAPoint3D=ddd}"))
        {
          if (!strcmp(v21, "{CATransform3D=dddddddddddddddd}"))
          {
            long long v110 = 0u;
            long long v111 = 0u;
            long long v109 = 0u;
            long long v107 = 0u;
            memset(v108, 0, sizeof(v108));
            *(_OWORD *)long long v106 = 0u;
            [(NSArray *)v11 CATransform3DValue];
            float64x2_t v98 = v90;
            float64x2_t v99 = v91;
            long long v100 = v92;
            long long v101 = v93;
            long long v102 = v94;
            long long v103 = v95;
            long long v104 = v96;
            long long v105 = v97;
            CA::Mat4Impl::mat4_get_unmatrix(v98.f64, (uint64_t)v106, 0);
            if (([a4 isEqualToString:@"rotation"] & 1) != 0
              || [a4 isEqualToString:@"rotation.z"])
            {
              [a2 doubleValue];
              *((void *)&v110 + 1) = v24;
LABEL_18:
              uint64_t v25 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithBytes:objCType:", &v98, "{CATransform3D=dddddddddddddddd}", CA::Mat4Impl::mat4_set_unmatrix((CA::Mat4Impl *)&v98, (uint64_t)v106, v22, v23).f64[0]);
              unint64_t v26 = a1;
LABEL_83:
              [v26 setValue:v25 forKey:a3];
              return;
            }
            if ([a4 isEqualToString:@"rotation.x"])
            {
              [a2 doubleValue];
              *((void *)&v109 + 1) = v74;
              goto LABEL_18;
            }
            if ([a4 isEqualToString:@"rotation.y"])
            {
              [a2 doubleValue];
              *(void *)&long long v110 = v78;
              goto LABEL_18;
            }
            if ([a4 isEqualToString:@"scale"])
            {
              [a2 doubleValue];
              *(void *)&long long v107 = v80;
LABEL_98:
              v106[0] = v80;
              v106[1] = v80;
              goto LABEL_18;
            }
            if ([a4 isEqualToString:@"scale.xy"])
            {
              [a2 doubleValue];
              goto LABEL_98;
            }
            if ([a4 isEqualToString:@"scale.x"])
            {
              [a2 doubleValue];
              v106[0] = v81;
              goto LABEL_18;
            }
            if ([a4 isEqualToString:@"scale.y"])
            {
              [a2 doubleValue];
              v106[1] = v82;
              goto LABEL_18;
            }
            if ([a4 isEqualToString:@"scale.z"])
            {
              [a2 doubleValue];
              *(void *)&long long v107 = v83;
              goto LABEL_18;
            }
            if ([a4 isEqualToString:@"translation"])
            {
              [a2 sizeValue];
              *(void *)&v108[1] = v84;
              *((void *)&v108[1] + 1) = v85;
              goto LABEL_18;
            }
            if ([a4 isEqualToString:@"translation.x"])
            {
              [a2 doubleValue];
              *(void *)&v108[1] = v86;
              goto LABEL_18;
            }
            if ([a4 isEqualToString:@"translation.y"])
            {
              [a2 doubleValue];
              *((void *)&v108[1] + 1) = v87;
              goto LABEL_18;
            }
            if ([a4 isEqualToString:@"translation.z"])
            {
              [a2 doubleValue];
              *(void *)&v108[2] = v88;
              goto LABEL_18;
            }
          }
          goto LABEL_113;
        }
        [(NSArray *)v11 CAPoint3DValue];
        double v59 = v58;
        double v61 = v60;
        double v63 = v62;
        if ([a4 isEqualToString:@"x"])
        {
          [a2 doubleValue];
          double v59 = v64;
        }
        else if ([a4 isEqualToString:@"y"])
        {
          [a2 doubleValue];
          double v61 = v69;
        }
        else
        {
          if (![a4 isEqualToString:@"z"]) {
            goto LABEL_113;
          }
          [a2 doubleValue];
          double v63 = v72;
        }
        uint64_t v45 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithCAPoint3D:", v59, v61, v63);
      }
      [a1 setValue:v45 forKey:a3];
      return;
    }
LABEL_113:
    [a1 willChangeValueForKey:a3];
    uint64_t v31 = v11;
    goto LABEL_114;
  }
  v106[0] = 0;
  uint64_t v12 = [a4 rangeOfString:@"."];
  if (!v13)
  {
    if (!objectForKey(v11, (NSString *)a4, v106)) {
      return;
    }
    char v19 = (void *)[(NSArray *)v11 mutableCopy];
    [v19 replaceObjectAtIndex:v106[0] withObject:a2];
    goto LABEL_24;
  }
  uint64_t v14 = v12;
  uint64_t v15 = (NSString *)[a4 substringToIndex:v12];
  a4 = (void *)[a4 substringFromIndex:v14 + 1];
  uint64_t v16 = (NSArray *)objectForKey(v11, v15, v106);
  if (!v16) {
    return;
  }
  uint64_t v17 = v16;
  if (!a5 || (objc_opt_respondsToSelector() & 1) == 0)
  {
    [a1 willChangeValueForKey:a3];
    uint64_t v31 = v17;
LABEL_114:
    [(NSArray *)v31 setValue:a2 forKeyPath:a4];
    [a1 didChangeValueForKey:a3];
    return;
  }
  int v18 = (void *)[(NSArray *)v17 mutableCopy];
  [v18 setValue:a2 forKeyPath:a4];
  char v19 = (void *)[(NSArray *)v11 mutableCopy];
  [v19 replaceObjectAtIndex:v106[0] withObject:v18];

LABEL_24:
  long long v29 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (v29)
  {
    uint64_t v30 = (char *)v29 + 88;
    while (1)
    {
      uint64_t v30 = *(char **)v30;
      if (!v30) {
        break;
      }
      if (v30[28])
      {
        if (v30[24]) {
          goto LABEL_36;
        }
        break;
      }
    }
    CA::Transaction::set_BOOL_value(v29, 1, 0);
    [a1 setValue:v19 forKey:a3];
    CA::Transaction::set_BOOL_value(v29, 0, 0);
  }
  else
  {
LABEL_36:
    [a1 setValue:v19 forKey:a3];
  }
}

_DWORD *CA::Transaction::set_BOOL_value(CA::Transaction *this, int a2, unsigned int a3)
{
  if (a3 >= 0x20) {
    __assert_rtn("set_BOOL_value", "CATransactionInternal.mm", 1295, "key < (CHAR_BIT * sizeof (Level::_BOOL_values))");
  }
  char v3 = a3;
  if (!**((_DWORD **)this + 13)) {
    CA::Transaction::ensure_implicit(this, 1);
  }
  uint64_t result = (_DWORD *)*((void *)this + 11);
  if (!result)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t result = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x20uLL, 0x743898A5uLL);
    *((void *)this + 11) = result;
  }
  int v8 = 1 << v3;
  if (a2) {
    int v9 = result[6] | v8;
  }
  else {
    int v9 = result[6] & ~v8;
  }
  result[6] = v9;
  result[7] |= v8;
  return result;
}

NSArray *CAObject_valueForKeyPath(void *a1, void *a2)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = [a2 rangeOfString:@"."];
  if (!v5)
  {
    return (NSArray *)[a1 valueForKey:a2];
  }
  uint64_t v6 = v4;
  uint64_t v7 = [a2 substringToIndex:v4];
  int v8 = (void *)[a2 substringFromIndex:v6 + 1];
  uint64_t result = (NSArray *)[a1 valueForKey:v7];
  if (!result) {
    return result;
  }
  uint64_t v10 = result;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v11 = [v8 rangeOfString:@"."];
    if (v12)
    {
      uint64_t v13 = v11;
      uint64_t v14 = (NSString *)[v8 substringToIndex:v11];
      uint64_t v15 = [v8 substringFromIndex:v13 + 1];
      id v16 = objectForKey(v10, v14, 0);
      return (NSArray *)[v16 valueForKeyPath:v15];
    }
    else
    {
      return (NSArray *)objectForKey(v10, (NSString *)v8, 0);
    }
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      return (NSArray *)[(NSArray *)v10 valueForKeyPath:v8];
    }
    long long v55 = 0u;
    long long v56 = 0u;
    long long v54 = 0u;
    *(void *)&long long v66 = 0;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    [(NSArray *)v10 transformStruct];
    CA::Mat2Impl::mat2_get_unmatrix((uint64_t)&v54, (uint64_t)&v62);
    if ([v8 isEqualToString:@"rotation"])
    {
      char v19 = NSNumber;
      double v20 = *(double *)&v64;
      return (NSArray *)[v19 numberWithDouble:v20];
    }
    if (![v8 isEqualToString:@"scale"])
    {
      if (![v8 isEqualToString:@"scale.x"])
      {
        if (![v8 isEqualToString:@"scale.y"])
        {
          if ([v8 isEqualToString:@"translation"])
          {
            unint64_t v43 = (void *)MEMORY[0x1E4F29238];
            double v45 = *((double *)&v63 + 1);
            double v44 = *(double *)&v63;
            return (NSArray *)objc_msgSend(v43, "valueWithSize:", v44, v45);
          }
          if (![v8 isEqualToString:@"translation.x"])
          {
            if ([v8 isEqualToString:@"translation.y"])
            {
              char v19 = NSNumber;
              double v20 = *((double *)&v63 + 1);
              return (NSArray *)[v19 numberWithDouble:v20];
            }
            return (NSArray *)[(NSArray *)v10 valueForKeyPath:v8];
          }
LABEL_62:
          char v19 = NSNumber;
          double v20 = *(double *)&v63;
          return (NSArray *)[v19 numberWithDouble:v20];
        }
LABEL_44:
        char v19 = NSNumber;
        double v20 = *((double *)&v62 + 1);
        return (NSArray *)[v19 numberWithDouble:v20];
      }
LABEL_35:
      char v19 = NSNumber;
      double v20 = *(double *)&v62;
      return (NSArray *)[v19 numberWithDouble:v20];
    }
LABEL_28:
    char v19 = NSNumber;
    double v21 = *((double *)&v62 + 1) + *(double *)&v62;
    double v22 = 0.5;
LABEL_29:
    double v20 = v21 * v22;
    return (NSArray *)[v19 numberWithDouble:v20];
  }
  uint64_t v17 = (const char *)[(NSArray *)v10 objCType];
  if (!v17) {
    return (NSArray *)[(NSArray *)v10 valueForKeyPath:v8];
  }
  int v18 = v17;
  if (!strcmp(v17, "{CGPoint=dd}"))
  {
    [(NSArray *)v10 pointValue];
    double v24 = v23;
    double v26 = v25;
    if ([v8 isEqualToString:@"x"]) {
      goto LABEL_33;
    }
    int v27 = @"y";
LABEL_41:
    if (![v8 isEqualToString:v27]) {
      return (NSArray *)[(NSArray *)v10 valueForKeyPath:v8];
    }
    uint64_t v30 = NSNumber;
    double v31 = v26;
    goto LABEL_58;
  }
  if (!strcmp(v18, "{CGSize=dd}"))
  {
    [(NSArray *)v10 sizeValue];
    double v24 = v28;
    double v26 = v29;
    if ([v8 isEqualToString:@"width"]) {
      goto LABEL_33;
    }
    int v27 = @"height";
    goto LABEL_41;
  }
  if (strcmp(v18, "{CGRect={CGPoint=dd}{CGSize=dd}}"))
  {
    if (strcmp(v18, "{CAPoint3D=ddd}"))
    {
      if (strcmp(v18, "{CATransform3D=dddddddddddddddd}")) {
        return (NSArray *)[(NSArray *)v10 valueForKeyPath:v8];
      }
      long long v69 = 0u;
      long long v70 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v62 = 0u;
      [(NSArray *)v10 CATransform3DValue];
      long long v54 = v46;
      long long v55 = v47;
      long long v56 = v48;
      long long v57 = v49;
      long long v58 = v50;
      long long v59 = v51;
      long long v60 = v52;
      long long v61 = v53;
      CA::Mat4Impl::mat4_get_unmatrix((double *)&v54, (uint64_t)&v62, 0);
      if (([v8 isEqualToString:@"rotation"] & 1) != 0
        || [v8 isEqualToString:@"rotation.z"])
      {
        char v19 = NSNumber;
        double v20 = *((double *)&v69 + 1);
        return (NSArray *)[v19 numberWithDouble:v20];
      }
      if ([v8 isEqualToString:@"rotation.x"])
      {
        char v19 = NSNumber;
        double v20 = *((double *)&v68 + 1);
        return (NSArray *)[v19 numberWithDouble:v20];
      }
      if ([v8 isEqualToString:@"rotation.y"])
      {
        char v19 = NSNumber;
        double v20 = *(double *)&v69;
        return (NSArray *)[v19 numberWithDouble:v20];
      }
      if ([v8 isEqualToString:@"scale"])
      {
        char v19 = NSNumber;
        double v21 = *((double *)&v62 + 1) + *(double *)&v62 + *(double *)&v63;
        double v22 = 0.333333333;
        goto LABEL_29;
      }
      if (![v8 isEqualToString:@"scale.xy"])
      {
        if (![v8 isEqualToString:@"scale.x"])
        {
          if (![v8 isEqualToString:@"scale.y"])
          {
            if (![v8 isEqualToString:@"scale.z"])
            {
              if ([v8 isEqualToString:@"translation"])
              {
                unint64_t v43 = (void *)MEMORY[0x1E4F29238];
                double v45 = *((double *)&v65 + 1);
                double v44 = *(double *)&v65;
                return (NSArray *)objc_msgSend(v43, "valueWithSize:", v44, v45);
              }
              if ([v8 isEqualToString:@"translation.x"])
              {
                char v19 = NSNumber;
                double v20 = *(double *)&v65;
                return (NSArray *)[v19 numberWithDouble:v20];
              }
              if ([v8 isEqualToString:@"translation.y"])
              {
                char v19 = NSNumber;
                double v20 = *((double *)&v65 + 1);
                return (NSArray *)[v19 numberWithDouble:v20];
              }
              if ([v8 isEqualToString:@"translation.z"])
              {
                char v19 = NSNumber;
                double v20 = *(double *)&v66;
                return (NSArray *)[v19 numberWithDouble:v20];
              }
              return (NSArray *)[(NSArray *)v10 valueForKeyPath:v8];
            }
            goto LABEL_62;
          }
          goto LABEL_44;
        }
        goto LABEL_35;
      }
      goto LABEL_28;
    }
    [(NSArray *)v10 CAPoint3DValue];
    double v35 = v39;
    double v24 = v40;
    double v26 = v41;
    if ([v8 isEqualToString:@"x"])
    {
LABEL_46:
      uint64_t v30 = NSNumber;
      double v31 = v35;
      goto LABEL_58;
    }
    if (![v8 isEqualToString:@"y"])
    {
      int v27 = @"z";
      goto LABEL_41;
    }
LABEL_33:
    uint64_t v30 = NSNumber;
    double v31 = v24;
LABEL_58:
    return (NSArray *)[v30 numberWithDouble:v31];
  }
  [(NSArray *)v10 rectValue];
  double v33 = v32;
  double v35 = v34;
  double v24 = v36;
  double v26 = v37;
  if ([v8 isEqualToString:@"origin"])
  {
    double v38 = (void *)MEMORY[0x1E4F29238];
    return (NSArray *)objc_msgSend(v38, "valueWithPoint:", v33, v35);
  }
  else
  {
    if (![v8 isEqualToString:@"size"])
    {
      if ([v8 isEqualToString:@"origin.x"])
      {
        uint64_t v30 = NSNumber;
        double v31 = v33;
        goto LABEL_58;
      }
      if ([v8 isEqualToString:@"origin.y"]) {
        goto LABEL_46;
      }
      if (![v8 isEqualToString:@"size.width"])
      {
        int v27 = @"size.height";
        goto LABEL_41;
      }
      goto LABEL_33;
    }
    double v42 = (void *)MEMORY[0x1E4F29238];
    return (NSArray *)objc_msgSend(v42, "valueWithSize:", v24, v26);
  }
}

id CA_valueForKey(void *a1, const char *a2, uint64_t a3)
{
  id v3 = 0;
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    memset(v16, 0, sizeof(v16));
    switch((int)a3)
    {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        id v4 = [a1 a2];
        goto LABEL_5;
      case 6:
        id v4 = (id)objc_msgSend(NSNumber, "numberWithBool:", objc_msgSend(a1, a2));
        goto LABEL_5;
      case 7:
        id v4 = (id)objc_msgSend(NSNumber, "numberWithChar:", objc_msgSend(a1, a2));
        goto LABEL_5;
      case 8:
        id v4 = (id)objc_msgSend(NSNumber, "numberWithUnsignedChar:", objc_msgSend(a1, a2));
        goto LABEL_5;
      case 9:
        id v4 = (id)objc_msgSend(NSNumber, "numberWithShort:", objc_msgSend(a1, a2));
        goto LABEL_5;
      case 10:
        id v4 = (id)objc_msgSend(NSNumber, "numberWithUnsignedShort:", objc_msgSend(a1, a2));
        goto LABEL_5;
      case 11:
        id v4 = (id)objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend(a1, a2));
        goto LABEL_5;
      case 12:
        id v4 = (id)objc_msgSend(NSNumber, "numberWithUnsignedInt:", objc_msgSend(a1, a2));
        goto LABEL_5;
      case 13:
        id v4 = (id)objc_msgSend(NSNumber, "numberWithLong:", objc_msgSend(a1, a2));
        goto LABEL_5;
      case 14:
        id v4 = (id)objc_msgSend(NSNumber, "numberWithUnsignedLong:", objc_msgSend(a1, a2));
        goto LABEL_5;
      case 15:
        id v4 = (id)objc_msgSend(NSNumber, "numberWithLongLong:", objc_msgSend(a1, a2));
        goto LABEL_5;
      case 16:
        id v4 = (id)objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(a1, a2));
        goto LABEL_5;
      case 17:
        uint64_t v6 = NSNumber;
        [a1 a2];
        id v4 = (id)objc_msgSend(v6, "numberWithFloat:");
        goto LABEL_5;
      case 18:
        uint64_t v7 = NSNumber;
        [a1 a2];
        id v4 = (id)objc_msgSend(v7, "numberWithDouble:");
        goto LABEL_5;
      case 19:
        int v8 = (void *)MEMORY[0x1E4F29238];
        [a1 a2];
        id v4 = (id)objc_msgSend(v8, "valueWithPoint:");
        goto LABEL_5;
      case 20:
        int v9 = (void *)MEMORY[0x1E4F29238];
        [a1 a2];
        id v4 = (id)objc_msgSend(v9, "valueWithSize:");
        goto LABEL_5;
      case 21:
        uint64_t v10 = (void *)MEMORY[0x1E4F29238];
        [a1 a2];
        id v4 = (id)objc_msgSend(v10, "valueWithRect:");
        goto LABEL_5;
      case 22:
        uint64_t v11 = (void *)MEMORY[0x1E4F29238];
        [a1 a2];
        id v4 = (id)[v11 valueWithCATransform3D:v15];
        goto LABEL_5;
      case 23:
        [a1 a2];
        id v4 = (id)[MEMORY[0x1E4F29238] value:v16 withObjCType:"{CGAffineTransform=dddddd}"];
        goto LABEL_5;
      case 24:
        uint64_t v12 = (void *)MEMORY[0x1E4F29238];
        [a1 a2];
        id v4 = (id)objc_msgSend(v12, "valueWithCAPoint3D:");
        goto LABEL_5;
      case 25:
        uint64_t v13 = (void *)MEMORY[0x1E4F29238];
        [a1 a2];
        id v4 = (id)[v13 valueWithCACornerRadii:v14];
LABEL_5:
        id v3 = v4;
        break;
      default:
        NSLog(&cfstr_UnhandledGette.isa, a3);
        id v3 = 0;
        break;
    }
  }
  return v3;
}

double ___ZL27cons_CALayer_kCAValueDoublejb_block_invoke(uint64_t a1, uint64_t a2)
{
  v4[1] = *(id *)MEMORY[0x1E4F143B8];
  unsigned int v2 = *(_DWORD *)(a1 + 32);
  v4[0] = 0;
  CA::Layer::getter(*(CA::Transaction **)(a2 + 16), v2, (const CGAffineTransform *)0x12, v4);
  return *(double *)v4;
}

_DWORD *CA::Render::set_transform_property(CA::Render *this, CA::Render::Vector *a2, int *a3, const unsigned int *a4, unint64_t a5, uint64_t a6, const double *a7)
{
  int v9 = (int)a4;
  int v11 = (int)a2;
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = (double *)&CA::Mat4Impl::mat4_identity_double;
  if (this)
  {
    unsigned int v14 = *((_DWORD *)this + 4);
    uint64_t v15 = (double *)((char *)this + 24);
    if (v14 > 0xF) {
      uint64_t v13 = v15;
    }
  }
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  float64x2_t v41 = 0u;
  CA::Mat4Impl::mat4_get_unmatrix(v13, (uint64_t)&v41, 0);
  if (v11 != 2)
  {
    if (v11 != 1) {
      goto LABEL_77;
    }
    int v18 = *a3;
    if (a5 && v18 == 481) {
      goto LABEL_8;
    }
    if (a5 && v18 == 486)
    {
      double v22 = *(double *)a6;
      if (v9)
      {
        float64x2_t v23 = vaddq_f64(v41, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v22, 0));
        double v22 = v22 + *(double *)&v42;
      }
      else
      {
        float64x2_t v23 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v22, 0);
      }
      float64x2_t v41 = v23;
      *(double *)&long long v42 = v22;
      goto LABEL_77;
    }
    if (!a5 || v18 != 572) {
      goto LABEL_77;
    }
    if (!v9)
    {
      *(void *)&long long v44 = *(void *)a6;
      if (a5 <= 1) {
        goto LABEL_77;
      }
      *((void *)&v44 + 1) = *(void *)(a6 + 8);
      if (a5 == 2) {
        goto LABEL_77;
      }
      double v36 = *(double *)(a6 + 16);
LABEL_74:
      *(double *)&long long v45 = v36;
      goto LABEL_77;
    }
    *(double *)&long long v44 = *(double *)a6 + *(double *)&v44;
    if (a5 <= 1) {
      goto LABEL_77;
    }
    *((double *)&v44 + 1) = *(double *)(a6 + 8) + *((double *)&v44 + 1);
    if (a5 == 2) {
      goto LABEL_77;
    }
    double v26 = *(double *)&v45;
    double v27 = *(double *)(a6 + 16);
LABEL_66:
    double v36 = v27 + v26;
    goto LABEL_74;
  }
  int v20 = *a3;
  if (a5 && v20 == 486)
  {
    switch(a3[1])
    {
      case 607:
        if (v9) {
          double v21 = *(double *)a6 + v41.f64[0];
        }
        else {
          double v21 = *(double *)a6;
        }
        v41.f64[0] = v21;
        break;
      case 610:
        float64x2_t v30 = vld1q_dup_f64((const double *)a6);
        int8x16_t v31 = (int8x16_t)vdupq_n_s64(0x8000000000000000);
        if (v9) {
          unint64_t v32 = -1;
        }
        else {
          unint64_t v32 = 0;
        }
        float64x2_t v41 = vaddq_f64(v30, (float64x2_t)vbslq_s8((int8x16_t)vdupq_n_s64(v32), (int8x16_t)v41, v31));
        break;
      case 611:
        if (v9) {
          double v33 = *(double *)a6 + v41.f64[1];
        }
        else {
          double v33 = *(double *)a6;
        }
        v41.f64[1] = v33;
        break;
      case 613:
        if (v9) {
          double v34 = *(double *)a6 + *(double *)&v42;
        }
        else {
          double v34 = *(double *)a6;
        }
        *(double *)&long long v42 = v34;
        break;
      default:
        break;
    }
  }
  else if (a5 && v20 == 481)
  {
    int v24 = a3[1];
    switch(v24)
    {
      case 613:
LABEL_8:
        if (v9) {
          double v19 = *(double *)a6 + *((double *)&v48 + 1);
        }
        else {
          double v19 = *(double *)a6;
        }
        *((double *)&v48 + 1) = v19;
        break;
      case 611:
        if (v9) {
          double v35 = *(double *)a6 + *(double *)&v48;
        }
        else {
          double v35 = *(double *)a6;
        }
        *(double *)&long long v48 = v35;
        break;
      case 607:
        if (v9) {
          double v25 = *(double *)a6 + *((double *)&v47 + 1);
        }
        else {
          double v25 = *(double *)a6;
        }
        *((double *)&v47 + 1) = v25;
        break;
    }
  }
  else
  {
    if (!a5 || v20 != 572) {
      goto LABEL_77;
    }
    int v28 = a3[1];
    switch(v28)
    {
      case 613:
        if ((v9 & 1) == 0)
        {
          double v36 = *(double *)a6;
          goto LABEL_74;
        }
        double v26 = *(double *)&v45;
        double v27 = *(double *)a6;
        goto LABEL_66;
      case 611:
        if (v9) {
          double v37 = *(double *)a6 + *((double *)&v44 + 1);
        }
        else {
          double v37 = *(double *)a6;
        }
        *((double *)&v44 + 1) = v37;
        break;
      case 607:
        if (v9) {
          double v29 = *(double *)a6 + *(double *)&v44;
        }
        else {
          double v29 = *(double *)a6;
        }
        *(double *)&long long v44 = v29;
        break;
    }
  }
LABEL_77:
  memset(v40, 0, sizeof(v40));
  CA::Mat4Impl::mat4_set_unmatrix((CA::Mat4Impl *)v40, (uint64_t)&v41, v16, v17);
  return CA::Render::Vector::new_vector((CA::Render::Vector *)0x10, v40, v38);
}

double CATransform3DSetDecomposition_(double *a1, long long *a2, uint64_t a3, long long *a4, double *a5, CA::Mat4Impl *this)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v22 = 0;
  long long v21 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  memset(v17, 0, sizeof(v17));
  long long v16 = 0u;
  if (a1)
  {
    _Q0 = *(_OWORD *)a1;
    double v7 = a1[2];
  }
  else
  {
    __asm { FMOV            V0.2D, #1.0 }
    double v7 = 1.0;
  }
  long long v14 = _Q0;
  double v15 = v7;
  if (a2)
  {
    long long v20 = *a2;
    *(void *)&long long v21 = *((void *)a2 + 2);
  }
  if (a3)
  {
    *(_OWORD *)((char *)v17 + 8) = *(_OWORD *)a3;
    *((void *)&v17[1] + 1) = *(void *)(a3 + 16);
  }
  if (a4)
  {
    long long v16 = *a4;
    *(void *)&v17[0] = *((void *)a4 + 2);
  }
  if (a5)
  {
    long long v18 = *(_OWORD *)a5;
    double v12 = a5[3];
    *(double *)&long long v19 = a5[2];
  }
  else
  {
    double v12 = 1.0;
  }
  *((double *)&v19 + 1) = v12;
  *(void *)&double result = *(_OWORD *)&CA::Mat4Impl::mat4_set_unmatrix(this, (uint64_t)&v14, a3, (const double *)a4);
  return result;
}

float64x2_t CA::Mat4Impl::mat4_set_unmatrix(CA::Mat4Impl *this, uint64_t a2, uint64_t a3, const double *a4)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)this = xmmword_184997D50;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = xmmword_184997D60;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = xmmword_184997D50;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = xmmword_184997D60;
  *((void *)this + 3) = *(void *)(a2 + 72);
  *((void *)this + 7) = *(void *)(a2 + 80);
  *((void *)this + 11) = *(void *)(a2 + 88);
  *((void *)this + 15) = *(void *)(a2 + 96);
  long long v6 = *(_OWORD *)(a2 + 48);
  long long v7 = *(_OWORD *)(a2 + 64);
  long long v8 = *(_OWORD *)(a2 + 56);
  float64x2_t v9 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*((float64x2_t *)this + 7), *((float64x2_t *)this + 1), *(double *)&v6), *((float64x2_t *)this + 3), *(double *)&v8), *((float64x2_t *)this + 5), *(double *)&v7);
  *((float64x2_t *)this + 6) = vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64((float64x2_t)xmmword_184997D50, *(double *)&v6), (float64x2_t)xmmword_184997D60, *(double *)&v8), (float64x2_t)0, *(double *)&v7);
  *((float64x2_t *)this + 7) = v9;
  if (*(unsigned char *)(a2 + 136))
  {
    double v10 = *(double *)(a2 + 104);
    double v11 = *(double *)(a2 + 112);
    double v12 = v10 * v10;
    double v13 = v11 * v10;
    double v14 = *(double *)(a2 + 120);
    double v15 = *(double *)(a2 + 128);
    double v16 = v14 * v10;
    double v17 = v15 * v10;
    double v18 = v11 * v11;
    double v19 = v14 * v11;
    double v20 = v15 * v11;
    double v21 = v14 * v14;
    double v22 = v15 * v14;
    *(double *)&long long v53 = 1.0 - (v21 + v18) * 2.0;
    *((double *)&v53 + 1) = v13 - v22 + v13 - v22;
    *(double *)&long long v54 = v20 + v16 + v20 + v16;
    *((void *)&v54 + 1) = 0;
    *(double *)&long long v55 = v22 + v13 + v22 + v13;
    *((double *)&v55 + 1) = 1.0 - (v21 + v12) * 2.0;
    *(double *)&long long v56 = v19 - v17 + v19 - v17;
    *((void *)&v56 + 1) = 0;
    *(double *)&long long v57 = v16 - v20 + v16 - v20;
    *((double *)&v57 + 1) = v17 + v19 + v17 + v19;
    *(double *)long long v58 = 1.0 - (v18 + v12) * 2.0;
    memset(&v58[8], 0, 32);
    *(void *)&v58[40] = 0x3FF0000000000000;
LABEL_21:
    CA::Mat4Impl::mat4_concat((float64x2_t *)this, (double *)&v53, (const double *)this, a4);
    goto LABEL_22;
  }
  double v23 = *(double *)(a2 + 120);
  if (v23 != 0.0)
  {
    long long v54 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    *(_OWORD *)long long v58 = xmmword_184997D50;
    *(_OWORD *)&v58[16] = 0u;
    *(_OWORD *)&v58[32] = xmmword_184997D60;
    __double2 v27 = __sincos_stret(v23);
    *(double *)v26.i64 = v27.__cosval;
    *(double *)v25.i64 = v27.__sinval;
    if (fabs(v27.__sinval) >= 0.0000001)
    {
      if (fabs(v27.__cosval) < 0.0000001)
      {
        v26.i64[0] = 1.0;
        v29.f64[0] = NAN;
        v29.f64[1] = NAN;
        v25.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v29), v26, v25).u64[0];
        v26.i64[0] = 0;
      }
    }
    else
    {
      v25.i64[0] = 1.0;
      v28.f64[0] = NAN;
      v28.f64[1] = NAN;
      v26.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v28), v25, v26).u64[0];
      v25.i64[0] = 0;
    }
    *(void *)&long long v53 = v26.i64[0];
    *((void *)&v53 + 1) = v25.i64[0];
    *(double *)&long long v55 = -*(double *)v25.i64;
    *((void *)&v55 + 1) = v26.i64[0];
    CA::Mat4Impl::mat4_concat((float64x2_t *)this, (double *)&v53, (const double *)this, v24);
  }
  double v30 = *(double *)(a2 + 112);
  if (v30 != 0.0)
  {
    long long v53 = xmmword_184997D50;
    long long v54 = 0u;
    long long v55 = xmmword_184997D60;
    long long v56 = 0u;
    long long v57 = 0u;
    *(_OWORD *)long long v58 = xmmword_184997D50;
    *(_OWORD *)&v58[16] = 0u;
    *(_OWORD *)&v58[32] = xmmword_184997D60;
    __double2 v34 = __sincos_stret(v30);
    *(double *)v33.i64 = v34.__cosval;
    *(double *)v32.i64 = v34.__sinval;
    if (fabs(v34.__sinval) >= 0.0000001)
    {
      if (fabs(v34.__cosval) < 0.0000001)
      {
        v33.i64[0] = 1.0;
        v36.f64[0] = NAN;
        v36.f64[1] = NAN;
        v32.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v36), v33, v32).u64[0];
        v33.i64[0] = 0;
      }
    }
    else
    {
      v32.i64[0] = 1.0;
      v35.f64[0] = NAN;
      v35.f64[1] = NAN;
      v33.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v35), v32, v33).u64[0];
      v32.i64[0] = 0;
    }
    *(void *)&long long v53 = v33.i64[0];
    *(double *)&long long v54 = -*(double *)v32.i64;
    *(void *)&long long v57 = v32.i64[0];
    *(void *)long long v58 = v33.i64[0];
    CA::Mat4Impl::mat4_concat((float64x2_t *)this, (double *)&v53, (const double *)this, v31);
  }
  double v37 = *(double *)(a2 + 104);
  if (v37 != 0.0)
  {
    long long v53 = xmmword_184997D50;
    long long v54 = 0u;
    long long v55 = xmmword_184997D60;
    long long v56 = 0u;
    long long v57 = 0u;
    *(_OWORD *)long long v58 = xmmword_184997D50;
    *(_OWORD *)&v58[16] = 0u;
    *(_OWORD *)&v58[32] = xmmword_184997D60;
    __double2 v40 = __sincos_stret(v37);
    *(double *)v39.i64 = v40.__cosval;
    *(double *)v38.i64 = v40.__sinval;
    if (fabs(v40.__sinval) >= 0.0000001)
    {
      if (fabs(v40.__cosval) < 0.0000001)
      {
        v39.i64[0] = 1.0;
        v42.f64[0] = NAN;
        v42.f64[1] = NAN;
        v38.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v42), v39, v38).u64[0];
        v39.i64[0] = 0;
      }
    }
    else
    {
      v38.i64[0] = 1.0;
      v41.f64[0] = NAN;
      v41.f64[1] = NAN;
      v39.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v41), v38, v39).u64[0];
      v38.i64[0] = 0;
    }
    *((void *)&v55 + 1) = v39.i64[0];
    *(void *)&long long v56 = v38.i64[0];
    *((double *)&v57 + 1) = -*(double *)v38.i64;
    *(void *)long long v58 = v39.i64[0];
    goto LABEL_21;
  }
LABEL_22:
  double v43 = *(double *)(a2 + 40);
  if (v43 != 0.0)
  {
    long long v53 = xmmword_184997D50;
    long long v54 = 0u;
    long long v55 = xmmword_184997D60;
    long long v56 = 0u;
    *(void *)&long long v57 = 0;
    *(_OWORD *)long long v58 = xmmword_184997D50;
    *(_OWORD *)&v58[16] = 0u;
    *(_OWORD *)&v58[32] = xmmword_184997D60;
    *((double *)&v57 + 1) = v43;
    CA::Mat4Impl::mat4_concat((float64x2_t *)this, (double *)&v53, (const double *)this, a4);
  }
  double v44 = *(double *)(a2 + 32);
  if (v44 != 0.0)
  {
    long long v53 = xmmword_184997D50;
    long long v54 = 0u;
    long long v55 = xmmword_184997D60;
    long long v56 = 0u;
    *(_OWORD *)long long v58 = xmmword_184997D50;
    *(_OWORD *)&v58[16] = 0u;
    *(_OWORD *)&v58[32] = xmmword_184997D60;
    long long v57 = *(unint64_t *)&v44;
    CA::Mat4Impl::mat4_concat((float64x2_t *)this, (double *)&v53, (const double *)this, a4);
  }
  double v45 = *(double *)(a2 + 24);
  if (v45 != 0.0)
  {
    long long v53 = xmmword_184997D50;
    long long v54 = 0u;
    *((void *)&v55 + 1) = 0x3FF0000000000000;
    long long v56 = 0u;
    long long v57 = 0u;
    *(_OWORD *)long long v58 = xmmword_184997D50;
    *(_OWORD *)&v58[16] = 0u;
    *(_OWORD *)&v58[32] = xmmword_184997D60;
    *(double *)&long long v55 = v45;
    CA::Mat4Impl::mat4_concat((float64x2_t *)this, (double *)&v53, (const double *)this, a4);
  }
  long long v46 = *(_OWORD *)(a2 + 16);
  long long v47 = *(_OWORD *)(a2 + 8);
  float64x2_t result = vmulq_n_f64(*((float64x2_t *)this + 1), *(double *)a2);
  float64x2_t v49 = vmulq_n_f64(*((float64x2_t *)this + 2), *(double *)&v47);
  float64x2_t v50 = vmulq_n_f64(*((float64x2_t *)this + 3), *(double *)&v47);
  float64x2_t v51 = vmulq_n_f64(*((float64x2_t *)this + 4), *(double *)&v46);
  float64x2_t v52 = vmulq_n_f64(*((float64x2_t *)this + 5), *(double *)&v46);
  *(float64x2_t *)this = vmulq_n_f64(*(float64x2_t *)this, *(double *)a2);
  *((float64x2_t *)this + 1) = result;
  *((float64x2_t *)this + 2) = v49;
  *((float64x2_t *)this + 3) = v50;
  *((float64x2_t *)this + 4) = v51;
  *((float64x2_t *)this + 5) = v52;
  return result;
}

uint64_t CA::Render::get_transform_property(CA::Render *this, CA::Render::Vector *a2, int *a3, unsigned int *a4, double *a5)
{
  int v7 = (int)a2;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  float64x2_t v9 = (double *)&CA::Mat4Impl::mat4_identity_double;
  if (this)
  {
    unsigned int v10 = *((_DWORD *)this + 4);
    double v11 = (double *)((char *)this + 24);
    if (v10 > 0xF) {
      float64x2_t v9 = v11;
    }
  }
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v20 = 0u;
  CA::Mat4Impl::mat4_get_unmatrix(v9, (uint64_t)&v20, 0);
  if (v7 != 2)
  {
    if (v7 == 1)
    {
      int v12 = *a3;
      if (*a3 == 572)
      {
        *(_OWORD *)a4 = v23;
        *((void *)a4 + 2) = v24;
        return 3;
      }
      if (v12 == 486)
      {
        double v16 = *((double *)&v20 + 1) + *(double *)&v20 + *(double *)&v21;
        double v17 = 0.333333333;
LABEL_17:
        double v13 = v16 * v17;
        goto LABEL_18;
      }
      if (v12 == 481) {
        goto LABEL_9;
      }
    }
    return 0;
  }
  int v14 = *a3;
  if (*a3 == 481)
  {
    int v18 = a3[1];
    switch(v18)
    {
      case 613:
LABEL_9:
        double v13 = *((double *)&v27 + 1);
LABEL_18:
        *(double *)a4 = v13;
        return 1;
      case 611:
        double v13 = *(double *)&v27;
        goto LABEL_18;
      case 607:
        double v13 = *((double *)&v26 + 1);
        goto LABEL_18;
    }
    return 0;
  }
  if (v14 == 572)
  {
    int v19 = a3[1];
    switch(v19)
    {
      case 613:
        double v13 = *(double *)&v24;
        goto LABEL_18;
      case 611:
        double v13 = *((double *)&v23 + 1);
        goto LABEL_18;
      case 607:
        double v13 = *(double *)&v23;
        goto LABEL_18;
    }
    return 0;
  }
  if (v14 != 486) {
    return 0;
  }
  uint64_t result = 0;
  switch(a3[1])
  {
    case 607:
      double v13 = *(double *)&v20;
      goto LABEL_18;
    case 610:
      double v16 = *((double *)&v20 + 1) + *(double *)&v20;
      double v17 = 0.5;
      goto LABEL_17;
    case 611:
      double v13 = *((double *)&v20 + 1);
      goto LABEL_18;
    case 613:
      double v13 = *(double *)&v21;
      goto LABEL_18;
    default:
      return result;
  }
  return result;
}

double CATransform3DGetDecomposition_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5, double *a6)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v14 = 0u;
  memset(v15, 0, sizeof(v15));
  memset(v13, 0, sizeof(v13));
  CA::Mat4Impl::mat4_get_unmatrix(a6, (uint64_t)v13, 0);
  if (a1)
  {
    *(_OWORD *)a1 = v13[0];
    double result = *(double *)&v13[1];
    *(void *)(a1 + 16) = *(void *)&v13[1];
  }
  if (a2)
  {
    *(_OWORD *)a2 = *(_OWORD *)((char *)&v15[2] + 8);
    double result = *((double *)&v15[3] + 1);
    *(void *)(a2 + 16) = *((void *)&v15[3] + 1);
  }
  if (a3)
  {
    *(_OWORD *)a3 = v14;
    double result = *(double *)v15;
    *(void *)(a3 + 16) = *(void *)&v15[0];
  }
  if (a4)
  {
    *(_OWORD *)a4 = *(_OWORD *)((char *)&v13[1] + 8);
    double result = *((double *)&v13[2] + 1);
    *(void *)(a4 + 16) = *((void *)&v13[2] + 1);
  }
  if (a5)
  {
    double result = *((double *)v15 + 1);
    long long v12 = *(_OWORD *)((char *)&v15[1] + 8);
    *a5 = *(_OWORD *)((char *)v15 + 8);
    a5[1] = v12;
  }
  return result;
}

void CA::Mat4Impl::mat4_get_unmatrix(double *a1, uint64_t a2, const double *a3)
{
  char v3 = (char)a3;
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  if (a1[15] == 0.0)
  {
    *(void *)(a2 + 128) = 0;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
  }
  else
  {
    _Q18 = *(_OWORD *)a1;
    float64x2_t v6 = *(float64x2_t *)(a1 + 2);
    long long v7 = *((_OWORD *)a1 + 2);
    int64x2_t v8 = *(int64x2_t *)(a1 + 6);
    long long v10 = *((_OWORD *)a1 + 4);
    int64x2_t v9 = *(int64x2_t *)(a1 + 10);
    long long v11 = *((_OWORD *)a1 + 6);
    float64x2_t v12 = *(float64x2_t *)(a1 + 14);
    v74[0] = *(_OWORD *)a1;
    v74[1] = *(unint64_t *)&v6.f64[0];
    v74[2] = v7;
    v74[3] = v8.u64[0];
    v74[4] = v10;
    v74[5] = v9.u64[0];
    v74[6] = v11;
    float64_t v75 = v12.f64[0];
    uint64_t v76 = 0x3FF0000000000000;
    if (v6.f64[1] != 0.0
      || (int32x2_t v13 = vmovn_s64((int64x2_t)vmvnq_s8((int8x16_t)vceqzq_f64((float64x2_t)vzip2q_s64(v9, v8)))),
          (v13.i8[4] & 1) != 0)
      || (v13.i8[0] & 1) != 0)
    {
      long long v62 = v11;
      float64x2_t v63 = v12;
      long long v64 = v7;
      float64x2_t v65 = (float64x2_t)v8;
      long long v66 = v10;
      float64x2_t v67 = (float64x2_t)v9;
      long long __x = _Q18;
      float64x2_t v70 = v6;
      if (CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)v73, (CA::Mat4Impl *)v74, a3))
      {
        CA::Mat4Impl::mat4_transpose((CA::Mat4Impl *)v72, v73, v14);
        v6.f64[0] = v70.f64[0];
        v8.i64[0] = *(void *)&v65.f64[0];
        v9.i64[0] = *(void *)&v67.f64[0];
        v12.f64[0] = v63.f64[0];
        float64x2_t v15 = vmlaq_laneq_f64(vmlaq_laneq_f64(vmlaq_laneq_f64(vmulq_laneq_f64(v72[1], v70, 1), v72[3], v65, 1), v72[5], v67, 1), v72[7], v63, 1);
        *(float64x2_t *)(a2 + 72) = vmlaq_laneq_f64(vmlaq_laneq_f64(vmlaq_laneq_f64(vmulq_laneq_f64(v72[0], v70, 1), v72[2], v65, 1), v72[4], v67, 1), v72[6], v63, 1);
        *(float64x2_t *)(a2 + 88) = v15;
      }
      else
      {
        *(void *)(a2 + 72) = 0;
        *(void *)(a2 + 80) = 0;
        *(void *)(a2 + 88) = 0;
        *(void *)(a2 + 96) = 0x3FF0000000000000;
        v6.f64[0] = v70.f64[0];
        v9.i64[0] = *(void *)&v67.f64[0];
        v8.i64[0] = *(void *)&v65.f64[0];
        v12.f64[0] = v63.f64[0];
      }
      v6.f64[1] = 0.0;
      _Q18 = __x;
      long long v10 = v66;
      long long v7 = v64;
      long long v11 = v62;
    }
    else
    {
      *(void *)(a2 + 72) = 0;
      *(void *)(a2 + 80) = 0;
      *(void *)(a2 + 88) = 0;
      *(void *)(a2 + 96) = 0x3FF0000000000000;
    }
    *(_OWORD *)(a2 + 48) = v11;
    *(float64_t *)(a2 + 64) = v12.f64[0];
    _D8 = *((double *)&_Q18 + 1);
    __asm { FMLA            D0, D8, V18.D[1] }
    double v22 = sqrt(_D0 + vmulq_f64(v6, v6).f64[0]);
    *(double *)a2 = v22;
    if (v22 != 0.0)
    {
      *(double *)&_Q18 = 1.0 / v22 * *(double *)&_Q18;
      _D8 = 1.0 / v22 * *((double *)&_Q18 + 1);
      v6.f64[0] = 1.0 / v22 * v6.f64[0];
    }
    double v23 = v6.f64[0] * *(double *)v8.i64 + _D8 * *((double *)&v7 + 1) + *(double *)&_Q18 * *(double *)&v7;
    double v24 = *(double *)&v7 - v23 * *(double *)&_Q18;
    double v25 = *((double *)&v7 + 1) - v23 * _D8;
    double v26 = *(double *)v8.i64 - v23 * v6.f64[0];
    double v27 = sqrt(v24 * v24 + v25 * v25 + v26 * v26);
    *(double *)(a2 + 8) = v27;
    double v28 = 0.0;
    if (v27 == 0.0)
    {
      double v29 = 0.0;
    }
    else
    {
      double v24 = 1.0 / v27 * v24;
      double v25 = 1.0 / v27 * v25;
      double v26 = 1.0 / v27 * v26;
      double v29 = 1.0 / v27 * v23;
    }
    double v30 = v6.f64[0] * *(double *)v9.i64 + _D8 * *((double *)&v10 + 1) + *(double *)&_Q18 * *(double *)&v10;
    double v31 = *(double *)&v10 - v30 * *(double *)&_Q18;
    double v32 = *((double *)&v10 + 1) - v30 * _D8;
    double v33 = *(double *)v9.i64 - v30 * v6.f64[0];
    double v34 = v26 * v33 + v25 * v32 + v24 * v31;
    double v35 = v31 - v34 * v24;
    double v36 = v32 - v34 * v25;
    double v37 = v33 - v34 * v26;
    double v38 = sqrt(v35 * v35 + v36 * v36 + v37 * v37);
    *(double *)(a2 + 16) = v38;
    *(double *)(a2 + 24) = v29;
    if (v38 == 0.0)
    {
      double v39 = 0.0;
    }
    else
    {
      double v35 = 1.0 / v38 * v35;
      double v36 = 1.0 / v38 * v36;
      double v37 = 1.0 / v38 * v37;
      double v28 = 1.0 / v38 * v30;
      double v39 = 1.0 / v38 * v34;
    }
    *(double *)(a2 + 32) = v28;
    *(double *)(a2 + 40) = v39;
    if (-(v36 * v26 - v37 * v25) * *(double *)&_Q18
       + -(v37 * v24 - v35 * v26) * _D8
       + -(v35 * v25 - v36 * v24) * v6.f64[0] < 0.0)
    {
      *(double *)a2 = -v22;
      *(double *)(a2 + 8) = -v27;
      *(double *)&_Q18 = -*(double *)&_Q18;
      *(double *)(a2 + 16) = -v38;
      _D8 = -_D8;
      v6.f64[0] = -v6.f64[0];
      double v24 = -v24;
      double v25 = -v25;
      double v26 = -v26;
      double v35 = -v35;
      double v36 = -v36;
      double v37 = -v37;
    }
    if (v3)
    {
      double v40 = v37 + 1.0 + *(double *)&_Q18 + v25;
      if (v40 <= 0.0001)
      {
        if (*(double *)&_Q18 <= v25 || *(double *)&_Q18 <= v37)
        {
          double v50 = sqrt(v37 + 1.0 - (*(double *)&_Q18 + v25));
          double v51 = 1.0 / (v50 + v50);
          double v52 = (v6.f64[0] + v35) * v51;
          double v53 = v26 + v36;
          double v54 = v53 * v51;
          double v55 = v50 * 0.5;
          double v56 = (v24 - _D8) * v51;
          double v57 = sqrt(v25 + 1.0 - (v37 + *(double *)&_Q18));
          double v58 = 1.0 / (v57 + v57);
          double v59 = v57 * 0.5;
          double v60 = v53 * v58;
          double v61 = (v6.f64[0] - v35) * v58;
          if (v25 > v37) {
            double v43 = (_D8 + v24) * v58;
          }
          else {
            double v43 = v52;
          }
          if (v25 > v37) {
            double v44 = v59;
          }
          else {
            double v44 = v54;
          }
          if (v25 > v37) {
            double v45 = v60;
          }
          else {
            double v45 = v55;
          }
          if (v25 > v37) {
            double v42 = v61;
          }
          else {
            double v42 = v56;
          }
        }
        else
        {
          double v47 = sqrt(1.0 - (v37 + v25) + *(double *)&_Q18);
          double v48 = v47 + v47;
          double v43 = v47 * 0.5;
          double v49 = 1.0 / v48;
          double v44 = (_D8 + v24) * v49;
          double v45 = (v6.f64[0] + v35) * v49;
          double v42 = (v36 - v26) * v49;
        }
      }
      else
      {
        double v41 = 0.5 / sqrt(v40);
        double v42 = 0.25 / v41;
        double v43 = v41 * (v36 - v26);
        double v44 = v41 * (v6.f64[0] - v35);
        double v45 = v41 * (v24 - _D8);
      }
      *(double *)(a2 + 104) = v43;
      *(double *)(a2 + 112) = v44;
      *(double *)(a2 + 120) = v45;
      *(double *)(a2 + 128) = v42;
    }
    else
    {
      long double __xa = *(double *)&_Q18;
      double v71 = v6.f64[0];
      double v46 = asin(-v6.f64[0]);
      *(double *)(a2 + 112) = v46;
      if (fabs(v71) >= 1.0)
      {
        *(long double *)(a2 + 104) = atan2(v24, v25);
      }
      else
      {
        if (v37 >= 0.0 || v26 != 0.0 || _D8 != 0.0 || __xa >= 0.0)
        {
          *(long double *)(a2 + 104) = atan2(v26, v37);
          *(long double *)(a2 + 120) = atan2(_D8, __xa);
          goto LABEL_49;
        }
        *(double *)(a2 + 112) = dbl_184998050[v71 <= 0.0] - v46;
        *(void *)(a2 + 104) = 0;
      }
      *(void *)(a2 + 120) = 0;
    }
  }
LABEL_49:
  *(unsigned char *)(a2 + 136) = v3;
}

double CA::Mat4Impl::mat4_transpose(CA::Mat4Impl *this, double *a2, const double *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (this == (CA::Mat4Impl *)a2)
  {
    long long v3 = *(_OWORD *)this;
    long long v7 = *((_OWORD *)this + 1);
    long long v4 = *((_OWORD *)this + 2);
    long long v8 = *((_OWORD *)this + 3);
    v12[0] = *(_OWORD *)this;
    v12[1] = v7;
    void v12[2] = v4;
    v12[3] = v8;
    long long v5 = *((_OWORD *)this + 4);
    long long v9 = *((_OWORD *)this + 5);
    long long v6 = *((_OWORD *)this + 6);
    long long v10 = *((_OWORD *)this + 7);
    v12[4] = v5;
    v12[5] = v9;
    a2 = (double *)v12;
    v12[6] = v6;
    v12[7] = v10;
  }
  else
  {
    *(double *)&long long v3 = *a2;
    *(double *)&long long v4 = a2[4];
    *(double *)&long long v5 = a2[8];
    *(double *)&long long v6 = a2[12];
    *(double *)&long long v7 = a2[2];
    *(double *)&long long v8 = a2[6];
    *(double *)&long long v9 = a2[10];
    *(double *)&long long v10 = a2[14];
  }
  *(void *)this = v3;
  *((void *)this + 1) = v4;
  *((void *)this + 2) = v5;
  *((void *)this + 3) = v6;
  *((double *)this + 4) = a2[1];
  *((double *)this + 5) = a2[5];
  *((double *)this + 6) = a2[9];
  *((double *)this + 7) = a2[13];
  *((void *)this + 8) = v7;
  *((void *)this + 9) = v8;
  *((void *)this + 10) = v9;
  *((void *)this + 11) = v10;
  *((double *)this + 12) = a2[3];
  *((double *)this + 13) = a2[7];
  *((double *)this + 14) = a2[11];
  double result = a2[15];
  *((double *)this + 15) = result;
  return result;
}

uint64_t mapAnimationTime(CAAnimation *a1, double *a2, int *a3)
{
  long long v6 = (CA::Render::Timing *)CAMediaTimingCopyRenderTiming((unint64_t)a1);
  uint64_t v7 = (uint64_t)v6;
  if (v6)
  {
    if (!CA::Render::Timing::map_parent_to_active(v6, a2, 0))
    {
      uint64_t v10 = 0;
LABEL_17:
      if (atomic_fetch_add((atomic_uint *volatile)(v7 + 8), 0xFFFFFFFF) == 1) {
        (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
      }
      return v10;
    }
    if (a3)
    {
      double v8 = *(double *)(v7 + 32);
      if (*(unsigned char *)(v7 + 13)) {
        double v8 = v8 + v8;
      }
      if ((*(void *)&v8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        int v9 = 0;
      }
      else {
        int v9 = vcvtmd_s64_f64(*a2 / v8);
      }
      *a3 = v9;
    }
    CA::Render::Timing::map_active_to_local(v7, a2, 0);
    *a2 = *a2 / *(double *)(v7 + 32);
  }
  else if (a3)
  {
    *a3 = 0;
  }
  long long v11 = [(CAAnimation *)a1 timingFunction];
  if (v11)
  {
    double v12 = *a2;
    *(float *)&double v12 = *a2;
    [(CAMediaTimingFunction *)v11 _solveForInput:v12];
    *a2 = v13;
  }
  uint64_t v10 = 1;
  if (v7) {
    goto LABEL_17;
  }
  return v10;
}

void sub_1846E830C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

id ___ZL36cons_CALayer_kCAValueRetainedPointerjb_block_invoke(uint64_t a1, uint64_t a2)
{
  v4[1] = *(id *)MEMORY[0x1E4F143B8];
  unsigned int v2 = *(_DWORD *)(a1 + 32);
  v4[0] = 0;
  CA::Layer::getter(*(CA::Transaction **)(a2 + 16), v2, (const CGAffineTransform *)2, v4);
  return v4[0];
}

uint64_t CA::OGL::emit_shadow_rect(void *a1, float64x2_t *a2, float32x2_t *a3, float16x4_t *a4, int a5, int a6, int a7, uint64_t a8, double a9)
{
  v65[1] = *MEMORY[0x1E4F143B8];
  _Q0 = vaddq_f64(*a2, vcvtq_f64_f32(*a3));
  *a2 = _Q0;
  float16x4_t v17 = *a4;
  if (a5 >= 255) {
    int v18 = 255;
  }
  else {
    int v18 = a5;
  }
  int v19 = v18 & ~(v18 >> 31);
  if (*(void *)&v17 == 0x3C003C003C003C00)
  {
    *(float *)_Q0.f64 = (float)v19 * 0.0039216;
    __asm { FCVT            H0, S0 }
    *(int16x4_t *)&_Q0.f64[0] = vdup_lane_s16(*(int16x4_t *)&_Q0.f64[0], 0);
  }
  else
  {
    *(float16x4_t *)&_Q0.f64[0] = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v17), (float)v19 * 0.0039216));
  }
  double v24 = COERCE_DOUBLE(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(*(float16x4_t *)(a1[31] + 32)), vcvtq_f32_f16(*(float16x4_t *)&_Q0.f64[0]))));
  if (*(void *)(a1[31] + 32) != 0x3C003C003C003C00) {
    _Q0.f64[0] = v24;
  }
  *(float64_t *)(a1[2] + 8) = _Q0.f64[0];
  if (a6) {
    char v25 = 12;
  }
  else {
    char v25 = 3;
  }
  *(unsigned char *)(a1[2] + 16) = v25;
  uint64_t v64 = 0;
  v65[0] = 0;
  (*(void (**)(void *, void, void *))(*a1 + 496))(a1, 0, v65);
  double v26 = a2->f64[1];
  double v27 = a2->f64[0] - a9 * 2.8;
  double v28 = v27 + a9 * 5.6;
  v63[0] = v27;
  v63[1] = v28;
  double v29 = a2[1].f64[0];
  double v30 = a2[1].f64[1];
  double v31 = v29 + v27;
  double v32 = v29 + v28;
  v63[2] = v29 + v27;
  v63[3] = v29 + v28;
  double v33 = v26 - a9 * 2.8;
  double v34 = v33 + a9 * 5.6;
  v62[0] = v33;
  v62[1] = v34;
  double v35 = v30 + v33;
  double v36 = v30 + v34;
  v62[2] = v30 + v33;
  v62[3] = v30 + v34;
  v60[0] = HIDWORD(v65[0]);
  v60[1] = v65[0];
  uint64_t v61 = v65[0];
  v58[0] = HIDWORD(v65[0]);
  v58[1] = v65[0];
  uint64_t v59 = v65[0];
  v50[0] = a2;
  v50[1] = a8;
  int v51 = 63;
  uint64_t v52 = 0;
  uint64_t v54 = 0;
  uint64_t v53 = 0;
  int v55 = 0;
  if (a7)
  {
    *(unsigned char *)(a1[2] + 16) = 14;
    (*(void (**)(void *, uint64_t, void, void, uint64_t *))(*a1 + 448))(a1, 1, 0, 0, &v64);
    float v37 = 1.0 / a2[1].f64[0];
    float v38 = 1.0 / a2[1].f64[1];
    double v39 = a2->f64[1] - a3->f32[1];
    double v40 = trunc(a2->f64[0] - a3->f32[0]);
    double v41 = (float)(*((float *)&v64 + 1) - *(float *)&v64);
    double v42 = v41 * v37;
    float v43 = *(float *)&v64 + v42 * (v27 - v40);
    float v44 = *(float *)&v64 + v42 * (v28 - v40);
    *(float *)double v57 = v43;
    *(float *)&v57[1] = v44;
    float v45 = *(float *)&v64 + v42 * (v31 - v40);
    *(float *)&double v42 = *(float *)&v64 + v42 * (v32 - v40);
    *(float *)&v57[2] = v45;
    v57[3] = LODWORD(v42);
    double v46 = trunc(v39);
    double v47 = v41 * v38;
    *(float *)&double v40 = *(float *)&v64 + v47 * (v33 - v46);
    *(float *)&double v39 = *(float *)&v64 + v47 * (v34 - v46);
    v56[0] = LODWORD(v40);
    v56[1] = LODWORD(v39);
    *(float *)&double v40 = *(float *)&v64 + v47 * (v35 - v46);
    *(float *)&double v47 = *(float *)&v64 + v47 * (v36 - v46);
    v56[2] = LODWORD(v40);
    v56[3] = LODWORD(v47);
    CA::OGL::emit_nine_part_rect((uint64_t)a1, (uint64_t)v50, (uint64_t)v63, (uint64_t)v62, (uint64_t)v60, (uint64_t)v58, (uint64_t)v57, (uint64_t)v56, 0);
    (*(void (**)(void *, void, uint64_t))(*a1 + 520))(a1, 0, 1);
  }
  else
  {
    if (a6) {
      unsigned int v48 = 278528;
    }
    else {
      unsigned int v48 = 0;
    }
    CA::OGL::emit_nine_part_rect((uint64_t)a1, (uint64_t)v50, (uint64_t)v63, (uint64_t)v62, (uint64_t)v60, (uint64_t)v58, 0, 0, v48);
  }
  uint64_t result = (*(uint64_t (**)(void *, void, void))(*a1 + 520))(a1, 0, 0);
  *(unsigned char *)(a1[2] + 16) = 0;
  return result;
}

void CA::OGL::stroke_round_rect(void *a1, float64x2_t **a2, double *a3, double *a4, float64_t a5, double a6)
{
  int v8 = (int)a3;
  v136[287] = *MEMORY[0x1E4F143B8];
  double v118 = 0.0;
  double v119 = 0.0;
  memset(v126, 0, sizeof(v126));
  long long v124 = 0u;
  long long v125 = 0u;
  memset(v123, 0, sizeof(v123));
  memset(v122, 0, sizeof(v122));
  uint64_t v121 = 0;
  float v13 = a2[1];
  if ((LOBYTE(v13[9].f64[0]) & 0x10) != 0)
  {
    CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v13, &v119, &v118, a4);
    double v14 = v118;
    double v15 = v119;
  }
  else
  {
    double v14 = v13[8].f64[0];
    double v118 = v14;
    double v119 = v14;
    double v15 = v14;
  }
  if (a4) {
    double v16 = a5 * 1.528665;
  }
  else {
    double v16 = a5;
  }
  if (v15 > v14) {
    double v14 = v15;
  }
  LODWORD(v6) = vcvtpd_s64_f64(v14 * v16);
  if ((int)v6 >= 2) {
    double v17 = v16;
  }
  else {
    double v17 = a6 * 1.1;
  }
  if (a6 > 0.001)
  {
    int v18 = *a2;
    double v19 = (*a2)[1].f64[0];
    if (a6 + a6 >= v19 || (double v20 = v18[1].f64[1], a6 + a6 >= v20))
    {
      if ((int)v6 > 1) {
        CA::OGL::fill_round_rect((uint64_t)a1, a2, (double *)0xF, 0, a5, a5);
      }
      else {
        CA::OGL::fill_rect((uint64_t)a1, (uint64_t)a2, a3, a4);
      }
    }
    else
    {
      if (v19 >= v20) {
        double v19 = v18[1].f64[1];
      }
      if (v19 > 0.0)
      {
        long long v129 = 0u;
        long long v130 = 0u;
        long long v127 = 0u;
        long long v128 = 0u;
        long long v131 = 0u;
        long long v132 = 0u;
        long long v133 = 0u;
        long long v134 = 0u;
        BOOL v21 = !CA::Transform::is_isotropic((CA::Transform *)v13, 0.0, (uint64_t)a2, (uint64_t)a3, a4);
        if ((int)v6 > 1)
        {
          if (a4)
          {
            int8x16_t v28 = (int8x16_t)vaddq_f64(vdivq_f64(vmulq_f64(v18[1], (float64x2_t)vdupq_n_s64(0xBFF721E8A7A4B61BLL)), (float64x2_t)vdupq_lane_s64(COERCE__INT64(a5 * 1.528665), 0)), (float64x2_t)vdupq_n_s64(0x400721E8A7A4B61BuLL));
            __asm { FMOV            V1.2D, #1.0 }
            int8x16_t v34 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v28, (float64x2_t)_Q1), _Q1, v28);
            *(float32x2_t *)&v135.f64[0] = vcvt_f32_f64((float64x2_t)vbicq_s8(v34, (int8x16_t)vcltzq_f64((float64x2_t)v34)));
            (*(void (**)(void *, void, uint64_t, BOOL, void, uint64_t *, double *, float64x2_t *))(*a1 + 464))(a1, 0, v6, v21, 0, &v121, a4, &v135);
          }
          else
          {
            (*(void (**)(void *, void, uint64_t, BOOL, uint64_t, uint64_t *))(*a1 + 456))(a1, 0, v6, v21, 1, &v121);
          }
          unsigned int v25 = ~(v8 << 22) & 0x3C00000;
          double v27 = v16 - a6;
          double v26 = 0.01;
          if (v16 - a6 <= 0.01)
          {
            uint64_t v96 = a1[2];
            unint64_t v97 = *(void *)(v96 + 16) & 0xFFFFFF00FF00FF00;
            if (*(void *)(v96 + 8) == 0x3C003C003C003C00) {
              int v98 = 1;
            }
            else {
              int v98 = 3;
            }
            *(_DWORD *)(v96 + 16) = v98 | v97;
            *(_DWORD *)(v96 + 20) = HIDWORD(v97);
            float64x2_t v99 = *a2;
            *(float64_t *)&long long v131 = (*a2)->f64[0];
            *((double *)&v131 + 1) = *(double *)&v131 + v16;
            double v100 = v99->f64[1];
            if (v27 >= -0.01)
            {
              float64_t v106 = v99[1].f64[0] + *(double *)&v131;
              *(double *)&long long v132 = v106 - v16;
              *((float64_t *)&v132 + 1) = v106;
              *(double *)&long long v127 = v100;
              *((double *)&v127 + 1) = v100 + v16;
              float64_t v107 = v99[1].f64[1] + v100;
              *(double *)&long long v128 = v107 - v16;
              *((float64_t *)&v128 + 1) = v107;
              LODWORD(v126[0]) = v121;
              *((float *)v126 + 1) = *(float *)&v121 + (float)((float)(*((float *)&v121 + 1) - *(float *)&v121) * 0.5);
              *((float *)v126 + 2) = *((float *)v126 + 1);
              HIDWORD(v126[0]) = HIDWORD(v121);
              *(void *)&v123[0] = v121;
              *((void *)&v123[0] + 1) = v121;
              CA::OGL::emit_eight_part_rect((uint64_t)a1, (uint64_t)a2, (uint64_t)&v131, (uint64_t)&v127, (uint64_t)v126, (uint64_t)v126, (uint64_t)v123, (uint64_t)v123, v25);
            }
            else
            {
              float64_t v101 = v99[1].f64[0] + *(double *)&v131;
              *(double *)&long long v133 = v101 - v16;
              *((float64_t *)&v133 + 1) = v101;
              *(double *)&long long v132 = *(double *)&v131 + a6;
              *((double *)&v132 + 1) = v101 - a6;
              *(double *)&long long v127 = v100;
              *((double *)&v127 + 1) = v100 + v16;
              float64_t v102 = v99[1].f64[1] + v100;
              double v103 = v100 + a6;
              float64_t v104 = v102 - v16;
              *(double *)&long long v129 = v102 - v16;
              *((float64_t *)&v129 + 1) = v102;
              *(double *)&long long v128 = v103;
              *((double *)&v128 + 1) = v102 - a6;
              *(float *)&float64_t v104 = *(float *)&v121 + (float)((float)(*((float *)&v121 + 1) - *(float *)&v121) * 0.5);
              LODWORD(v126[0]) = v121;
              *(int32x4_t *)((char *)v126 + 4) = vdupq_lane_s32(*(int32x2_t *)&v104, 0);
              DWORD1(v126[1]) = HIDWORD(v121);
              LODWORD(v123[0]) = v121;
              *((float *)v123 + 1) = *(float *)&v104;
              *((void *)&v123[0] + 1) = __PAIR64__(v121, HIDWORD(v121));
              *(float *)&v123[1] = *(float *)&v104;
              DWORD1(v123[1]) = HIDWORD(v121);
              CA::OGL::emit_twenty_four_part_rect((uint64_t)a1, (uint64_t)a2, (uint64_t)&v131, (uint64_t)&v127, (uint64_t)v126, (uint64_t)v126, (uint64_t)v123, (uint64_t)v123, v25);
            }
            goto LABEL_106;
          }
        }
        else
        {
          (*(void (**)(void *, void, BOOL, uint64_t, uint64_t *))(*a1 + 448))(a1, 0, v21, 1, &v121);
          unsigned int v25 = ~(v8 << 22) & 0x3C00000;
          double v26 = 0.1;
          double v27 = a6 * 0.1;
        }
        BOOL v35 = !CA::Transform::is_isotropic((CA::Transform *)a2[1], v26, v22, v23, v24);
        *(unsigned char *)(a1[2] + 16) = 6;
        if (!a4)
        {
          uint64_t v84 = *a1;
          if (v8 == 15 && (int)v6 > 1)
          {
            (*(void (**)(void *, uint64_t, uint64_t, BOOL, uint64_t, uint64_t *))(v84 + 456))(a1, 1, v6, v35, 1, &v121);
            uint64_t v85 = *a2;
            double v86 = (*a2)->f64[1];
            *(float64_t *)&long long v131 = (*a2)->f64[0];
            *((double *)&v131 + 1) = *(double *)&v131 + a6;
            double v87 = v85[1].f64[1];
            float64_t v88 = v85[1].f64[0] + *(double *)&v131;
            *(double *)&long long v133 = v88 - a6;
            *((float64_t *)&v133 + 1) = v88;
            *(double *)&long long v132 = *(double *)&v131 + v17;
            *((double *)&v132 + 1) = v88 - v17;
            *(double *)&long long v127 = v86;
            *((double *)&v127 + 1) = v86 + a6;
            double v89 = v86 + v17;
            double v90 = v87 + v86;
            *(double *)&long long v129 = v90 - a6;
            *((double *)&v129 + 1) = v90;
            *(double *)&long long v128 = v89;
            *((double *)&v128 + 1) = v90 - v17;
            float v91 = (float)(*((float *)&v121 + 1) - *(float *)&v121) * 0.5;
            *(float *)&double v87 = v91 + *(float *)&v121;
            *(float *)&unsigned int v92 = *(float *)&v121 + a6 / v17 * v91;
            *(float *)&unsigned int v93 = *((float *)&v121 + 1) + a6 / v17 * (float)(*(float *)&v87 - *((float *)&v121 + 1));
            *(void *)&long long v124 = __PAIR64__(v92, v121);
            *(void *)&v126[0] = __PAIR64__(v92, v121);
            DWORD2(v124) = LODWORD(v87);
            HIDWORD(v124) = LODWORD(v87);
            DWORD2(v126[0]) = LODWORD(v87);
            HIDWORD(v126[0]) = LODWORD(v87);
            *(void *)&long long v125 = __PAIR64__(HIDWORD(v121), v93);
            *(void *)&v126[1] = __PAIR64__(HIDWORD(v121), v93);
            float v94 = 0.5 - v17 * 0.5 / v27;
            *(float *)uint64_t v122 = *(float *)&v121 + (float)((float)(*((float *)&v121 + 1) - *(float *)&v121) * v94);
            *(void *)((char *)v122 + 4) = __PAIR64__(LODWORD(v87), v121);
            *(float *)long long v123 = *(float *)v122;
            *(void *)((char *)v123 + 4) = __PAIR64__(LODWORD(v87), v121);
            HIDWORD(v122[0]) = LODWORD(v87);
            HIDWORD(v123[0]) = LODWORD(v87);
            LODWORD(v122[1]) = HIDWORD(v121);
            *((float *)&v122[1] + 1) = *((float *)&v121 + 1)
                                     + (float)((float)(*(float *)&v121 - *((float *)&v121 + 1)) * v94);
            LODWORD(v123[1]) = HIDWORD(v121);
            *((float *)&v123[1] + 1) = *((float *)&v122[1] + 1);
            CA::OGL::emit_twenty_part_rect((uint64_t)a1, (uint64_t)a2, (uint64_t)&v131, (uint64_t)&v127, (uint64_t)v126, (uint64_t)&v124, (uint64_t)v123, (uint64_t)v122, v25 | 0x4000);
          }
          else
          {
            if ((int)v6 > 1) {
              (*(void (**)(void *, uint64_t, uint64_t, BOOL, uint64_t, uint64_t *))(v84 + 456))(a1, 1, v6, v35, 1, &v121);
            }
            else {
              (*(void (**)(void *, uint64_t, BOOL, uint64_t, uint64_t *))(v84 + 448))(a1, 1, v35, 1, &v121);
            }
            long long v108 = *a2;
            double v109 = (*a2)->f64[1];
            *(float64_t *)&long long v131 = (*a2)->f64[0];
            *((double *)&v131 + 1) = *(double *)&v131 + v17;
            double v110 = v108[1].f64[1];
            float64_t v111 = v108[1].f64[0] + *(double *)&v131;
            *(double *)&long long v132 = v111 - v17;
            *((float64_t *)&v132 + 1) = v111;
            *(double *)&long long v127 = v109;
            *((double *)&v127 + 1) = v109 + v17;
            *(double *)&long long v128 = v110 + v109 - v17;
            *((double *)&v128 + 1) = v110 + v109;
            LODWORD(v126[0]) = v121;
            *((float *)v126 + 1) = *(float *)&v121 + (float)((float)(*((float *)&v121 + 1) - *(float *)&v121) * 0.5);
            *((float *)v126 + 2) = *((float *)v126 + 1);
            HIDWORD(v126[0]) = HIDWORD(v121);
            LODWORD(v124) = v121;
            *((float *)&v124 + 1) = *((float *)v126 + 1);
            *((float *)&v124 + 2) = *((float *)v126 + 1);
            HIDWORD(v124) = HIDWORD(v121);
            float v112 = 0.5 - v17 * 0.5 / v27;
            *(float *)long long v123 = *(float *)&v121 + (float)((float)(*((float *)&v121 + 1) - *(float *)&v121) * v112);
            *((float *)v123 + 1) = *((float *)v126 + 1);
            *((float *)v123 + 2) = *((float *)v126 + 1);
            *((float *)v123 + 3) = *((float *)&v121 + 1)
                                 + (float)((float)(*(float *)&v121 - *((float *)&v121 + 1)) * v112);
            *(float *)uint64_t v122 = *(float *)v123;
            *((float *)v122 + 1) = *((float *)v126 + 1);
            *((float *)v122 + 2) = *((float *)v126 + 1);
            *((float *)v122 + 3) = *((float *)v123 + 3);
            CA::OGL::emit_nine_part_rect((uint64_t)a1, (uint64_t)a2, (uint64_t)&v131, (uint64_t)&v127, (uint64_t)v126, (uint64_t)&v124, (uint64_t)v123, (uint64_t)v122, v25 | 0x4000);
          }
          goto LABEL_105;
        }
        if (a5 - a6 >= 0.0) {
          double v36 = (a5 - a6) * 1.528665;
        }
        else {
          double v36 = 0.0;
        }
        double v117 = v36;
        int8x16_t v37 = (int8x16_t)vaddq_f64(vdivq_f64(vmulq_f64(vsubq_f64((float64x2_t)vdupq_lane_s64(COERCE__INT64(a6 + a6), 0), (*a2)[1]), (float64x2_t)vdupq_n_s64(0x3FF721E8A7A4B61BuLL)), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v36, 0)), (float64x2_t)vdupq_n_s64(0x400721E8A7A4B61BuLL));
        __asm { FMOV            V1.2D, #1.0 }
        int8x16_t v39 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v37, (float64x2_t)_Q1), _Q1, v37);
        float32x2_t v120 = vcvt_f32_f64((float64x2_t)vbicq_s8(v39, (int8x16_t)vcltzq_f64((float64x2_t)v39)));
        uint64_t v40 = 1;
        (*(void (**)(void *, uint64_t, uint64_t, BOOL, void, uint64_t *, double *, float32x2_t *))(*a1 + 464))(a1, 1, v6, v35, 0, &v121, a4, &v120);
        double v41 = *a2;
        double v42 = (*a2)->f64[1];
        *(float64_t *)&long long v131 = (*a2)->f64[0];
        *((double *)&v131 + 1) = *(double *)&v131 + a6;
        v45.i32[1] = HIDWORD(v117);
        *(double *)&long long v132 = *(double *)&v131 + a6 + v117;
        *((double *)&v132 + 1) = *(double *)&v131 + v17;
        double v43 = v41[1].f64[1];
        float64_t v44 = v41[1].f64[0] + *(double *)&v131;
        *(double *)&long long v134 = v44 - a6;
        *((float64_t *)&v134 + 1) = v44;
        *(double *)&long long v133 = v44 - v17;
        *((double *)&v133 + 1) = v44 - a6 - v117;
        *(double *)&long long v127 = v42;
        *((double *)&v127 + 1) = v42 + a6;
        *(double *)&long long v128 = v42 + a6 + v117;
        *((double *)&v128 + 1) = v42 + v17;
        *(double *)&long long v130 = v43 + v42 - a6;
        *((double *)&v130 + 1) = v43 + v42;
        *(double *)&long long v129 = v43 + v42 - v17;
        *((double *)&v129 + 1) = *(double *)&v130 - v117;
        *(float *)&double v43 = (float)(*((float *)&v121 + 1) - *(float *)&v121) * 0.5;
        *(float *)v45.i32 = *(float *)&v43 + *(float *)&v121;
        double v46 = *(float *)&v43;
        *(float *)&unsigned int v47 = *(float *)&v121 + a6 / v17 * v46;
        double v48 = (v117 + a6) / v17;
        *(float *)&double v46 = *(float *)&v121 + v48 * v46;
        double v49 = (float)(*(float *)v45.i32 - *((float *)&v121 + 1));
        *(float *)&double v48 = *((float *)&v121 + 1) + v48 * v49;
        *(float *)&unsigned int v50 = *((float *)&v121 + 1) + a6 / v17 * v49;
        *(void *)&v126[0] = __PAIR64__(v47, v121);
        *((void *)&v126[0] + 1) = __PAIR64__(v45.u32[0], LODWORD(v46));
        *(void *)&v126[1] = __PAIR64__(LODWORD(v48), v45.u32[0]);
        *((void *)&v126[1] + 1) = __PAIR64__(HIDWORD(v121), v50);
        *(void *)&long long v124 = __PAIR64__(v47, v121);
        *((void *)&v124 + 1) = __PAIR64__(v45.u32[0], LODWORD(v46));
        *(void *)&long long v125 = __PAIR64__(LODWORD(v48), v45.u32[0]);
        *((void *)&v125 + 1) = __PAIR64__(HIDWORD(v121), v50);
        if (v117 == 0.0) {
          double v51 = v27;
        }
        else {
          double v51 = v117;
        }
        float v52 = a6 * -0.5 / v51;
        *(float *)long long v123 = *(float *)&v121 + (float)((float)(*((float *)&v121 + 1) - *(float *)&v121) * v52);
        DWORD1(v123[0]) = v121;
        *(int32x4_t *)((char *)v123 + 8) = vdupq_lane_s32(v45, 0);
        DWORD2(v123[1]) = HIDWORD(v121);
        *((float *)&v123[1] + 3) = *((float *)&v121 + 1)
                                 + (float)((float)(*(float *)&v121 - *((float *)&v121 + 1)) * v52);
        *(float *)uint64_t v122 = *(float *)v123;
        DWORD1(v122[0]) = v121;
        *(_OWORD *)((char *)v122 + 8) = *(_OWORD *)((char *)v123 + 8);
        DWORD2(v122[1]) = HIDWORD(v121);
        *((float *)&v122[1] + 3) = *((float *)&v123[1] + 3);
        uint64_t v53 = 6;
        do
        {
          double v54 = *((double *)&v131 + v40);
          double v55 = *((double *)&v131 + v53);
          if (v54 > v55)
          {
            float v56 = (v55 + v54) * 0.5;
            double v57 = v56;
            float v58 = (v57 - *(double *)&v131) / (v54 - *(double *)&v131);
            *((double *)&v131 + v53) = v57;
            *((double *)&v131 + v40) = v57;
            *((float *)v126 + v40) = *(float *)v126 + (float)((float)(*((float *)v126 + v40) - *(float *)v126) * v58);
            *((float *)v126 + v53) = *((float *)&v126[1] + 3)
                                   + (float)((float)(*((float *)v126 + v53) - *((float *)&v126[1] + 3)) * v58);
            *((float *)v123 + v40) = *(float *)v123 + (float)((float)(*((float *)v123 + v40) - *(float *)v123) * v58);
            *((float *)v123 + v53) = *((float *)&v123[1] + 3)
                                   + (float)((float)(*((float *)v123 + v53) - *((float *)&v123[1] + 3)) * v58);
          }
          ++v40;
          --v53;
        }
        while (v40 != 4);
        uint64_t v59 = 1;
        uint64_t v60 = 6;
        do
        {
          double v61 = *((double *)&v127 + v59);
          double v62 = *((double *)&v127 + v60);
          if (v61 > v62)
          {
            float v63 = (v62 + v61) * 0.5;
            double v64 = v63;
            float v65 = (v64 - *(double *)&v127) / (v61 - *(double *)&v127);
            *((double *)&v127 + v60) = v64;
            *((double *)&v127 + v59) = v64;
            *((float *)&v124 + v59) = *(float *)&v124
                                    + (float)((float)(*((float *)&v124 + v59) - *(float *)&v124) * v65);
            *((float *)&v124 + v60) = *((float *)&v125 + 3)
                                    + (float)((float)(*((float *)&v124 + v60) - *((float *)&v125 + 3)) * v65);
            *((float *)v122 + v59) = *(float *)v122 + (float)((float)(*((float *)v122 + v59) - *(float *)v122) * v65);
            *((float *)v122 + v60) = *((float *)&v122[1] + 3)
                                   + (float)((float)(*((float *)v122 + v60) - *((float *)&v122[1] + 3)) * v65);
          }
          ++v59;
          --v60;
        }
        while (v59 != 4);
        bzero(&v135, 0x900uLL);
        int v66 = v25 & 0x3C00000;
        if ((v25 & 0x3C00000) != 0) {
          unint64_t v67 = 72;
        }
        else {
          unint64_t v67 = 64;
        }
        if (v67 > *((unsigned int *)a1 + 34)) {
          goto LABEL_105;
        }
        uint64_t v68 = 0;
        uint64_t v69 = a1[15];
        float64x2_t v70 = (_DWORD *)(v69 + 28);
        double v71 = v136;
        __n128 v72 = (__n128)xmmword_184997D60;
        do
        {
          uint64_t v73 = 0;
          uint64_t v74 = *((void *)&v127 + v68);
          int v75 = *((_DWORD *)&v124 + v68);
          uint64_t v76 = v71;
          int v77 = *((_DWORD *)v122 + v68);
          uint64_t v78 = v70;
          do
          {
            *((void *)v76 - 2) = *((void *)&v131 + v73);
            *((void *)v76 - 1) = v74;
            _OWORD *v76 = xmmword_184997D60;
            v76 += 2;
            *(v78 - 3) = *((_DWORD *)v126 + v73);
            *(v78 - 2) = v75;
            *(v78 - 1) = *((_DWORD *)v123 + v73);
            *uint64_t v78 = v77;
            ++v73;
            v78 += 12;
          }
          while (v73 != 8);
          ++v68;
          v70 += 96;
          v71 += 32;
        }
        while (v68 != 8);
        if (v66)
        {
          CA::OGL::adjust_skipped_corner_vertices((uint64_t)&v135, v69, 0, 3uLL, 64, 4, v25 | 0x4000);
          v72.n128_f32[0] = CA::OGL::adjust_skipped_corner_vertices((uint64_t)&v135, v69, 1, 1uLL, 68, 4, v25 | 0x4000);
        }
        uint64_t v79 = 0;
        uint64_t v80 = *(void *)(a1[2] + 8);
        do
        {
          *(void *)(v69 + v79 + 32) = v80;
          v79 += 48;
        }
        while (48 * v67 != v79);
        unint64_t v81 = a2[3];
        if (v81) {
          ((void (*)(float64x2_t **, float64x2_t *, uint64_t, unint64_t, __n128))v81)(a2, &v135, v69, v67, v72);
        }
        CA::OGL::transform_vertices(&v135, (float32x4_t *)v69, (const double *)v67, a2[1]);
        unint64_t v82 = a2[4];
        if (v82) {
          ((void (*)(float64x2_t **, uint64_t, unint64_t))v82)(a2, v69, v67);
        }
        if (((_BYTE)a2[2] & 9) == 0)
        {
LABEL_101:
          if (v66)
          {
            long long v113 = (const unsigned __int16 *)&CA::OGL::emit_forty_nine_part_rect(CA::OGL::Context &,CA::OGL::RectState const&,double const*,double const*,float const*,float const*,float const*,float const*,unsigned int,float)::corner_skipped_indices;
            uint64_t v114 = (uint64_t)a1;
            unint64_t v115 = 144;
            unsigned int v116 = 72;
          }
          else
          {
            long long v113 = (const unsigned __int16 *)&CA::OGL::emit_forty_nine_part_rect(CA::OGL::Context &,CA::OGL::RectState const&,double const*,double const*,float const*,float const*,float const*,float const*,unsigned int,float)::indices;
            uint64_t v114 = (uint64_t)a1;
            unint64_t v115 = 112;
            unsigned int v116 = 64;
          }
          CA::OGL::emit_quad_indices(v114, a2[5], v113, v115, v116);
LABEL_105:
          (*(void (**)(void *, void, uint64_t))(*a1 + 520))(a1, 0, 1);
LABEL_106:
          *(unsigned char *)(a1[2] + 16) = 0;
          (*(void (**)(void *, void, void))(*a1 + 520))(a1, 0, 0);
          return;
        }
        int v83 = *((_DWORD *)a2 + 5);
        if ((v83 & 0xF) == 0) {
          goto LABEL_100;
        }
        if (v66)
        {
          if ((v83 & 4) != 0)
          {
            CA::OGL::aa_adjust_vertices(v69 + 3072, v69 + 384, 0, 1);
            CA::OGL::aa_adjust_vertices(v69 + 48, v69 + 3264, 0, 1);
            CA::OGL::aa_adjust_vertices(v69 + 96, v69 + 480, 48, 4);
            CA::OGL::aa_adjust_vertices(v69 + 336, v69 + 720, 0, 1);
            CA::OGL::aa_adjust_vertices(v69 + 3072, v69 + 48, 0, 1);
            if ((v25 & 0x400000) != 0) {
              *(_OWORD *)(v69 + 3088) = *(_OWORD *)(v69 + 64);
            }
          }
          if (*((unsigned char *)a2 + 20))
          {
            CA::OGL::aa_adjust_vertices(v69, v69 + 384, 0, 1);
            CA::OGL::aa_adjust_vertices(v69, v69 + 48, 384, 6);
            CA::OGL::aa_adjust_vertices(v69 + 2304, v69 + 3408, 0, 1);
            CA::OGL::aa_adjust_vertices(v69 + 3216, v69 + 2736, 0, 1);
            CA::OGL::aa_adjust_vertices(v69 + 3216, v69 + 2304, 0, 1);
            if ((v25 & 0x400000) != 0) {
              *(_OWORD *)(v69 + 16) = *(_OWORD *)(v69 + 400);
            }
            if ((v25 & 0x1000000) != 0) {
              *(_OWORD *)(v69 + 3232) = *(_OWORD *)(v69 + 2320);
            }
          }
          if ((*((unsigned char *)a2 + 20) & 8) != 0)
          {
            CA::OGL::aa_adjust_vertices(v69 + 2688, v69 + 2736, 0, 1);
            CA::OGL::aa_adjust_vertices(v69 + 2688, v69 + 2304, 48, 6);
            CA::OGL::aa_adjust_vertices(v69 + 2976, v69 + 3360, 0, 1);
            CA::OGL::aa_adjust_vertices(v69 + 3168, v69 + 2640, 0, 1);
            CA::OGL::aa_adjust_vertices(v69 + 3168, v69 + 2976, 0, 1);
            if ((v25 & 0x1000000) != 0) {
              *(_OWORD *)(v69 + 2704) = *(_OWORD *)(v69 + 2752);
            }
            if ((v25 & 0x2000000) != 0) {
              *(_OWORD *)(v69 + 3184) = *(_OWORD *)(v69 + 2992);
            }
          }
          if ((*((unsigned char *)a2 + 20) & 2) != 0)
          {
            CA::OGL::aa_adjust_vertices(v69 + 3024, v69 + 2640, 0, 1);
            CA::OGL::aa_adjust_vertices(v69 + 1104, v69 + 1056, 384, 6);
            CA::OGL::aa_adjust_vertices(v69 + 720, v69 + 3312, 0, 1);
            CA::OGL::aa_adjust_vertices(v69 + 3120, v69 + 288, 0, 1);
            CA::OGL::aa_adjust_vertices(v69 + 3120, v69 + 720, 0, 1);
            if ((v25 & 0x2000000) != 0) {
              *(_OWORD *)(v69 + 3040) = *(_OWORD *)(v69 + 2656);
            }
            if ((v25 & 0x800000) != 0) {
              *(_OWORD *)(v69 + 3136) = *(_OWORD *)(v69 + 736);
            }
          }
          if ((*((unsigned char *)a2 + 20) & 4) != 0)
          {
            CA::OGL::aa_adjust_vertices(v69 + 288, v69 + 672, 0, 1);
            CA::OGL::aa_adjust_vertices(v69 + 336, v69 + 288, 0, 1);
            if ((v25 & 0x800000) != 0) {
              *(_OWORD *)(v69 + 352) = *(_OWORD *)(v69 + 304);
            }
          }
          goto LABEL_100;
        }
        if ((v83 & 4) != 0)
        {
          CA::OGL::aa_adjust_vertices(v69, v69 + 384, 48, 8);
          int v83 = *((_DWORD *)a2 + 5);
          if ((v83 & 8) == 0)
          {
LABEL_97:
            if ((v83 & 1) == 0) {
              goto LABEL_98;
            }
            goto LABEL_110;
          }
        }
        else if ((v83 & 8) == 0)
        {
          goto LABEL_97;
        }
        CA::OGL::aa_adjust_vertices(v69 + 2688, v69 + 2304, 48, 8);
        int v83 = *((_DWORD *)a2 + 5);
        if ((v83 & 1) == 0)
        {
LABEL_98:
          if ((v83 & 2) != 0) {
LABEL_99:
          }
            CA::OGL::aa_adjust_vertices(v69 + 336, v69 + 288, 384, 8);
LABEL_100:
          CA::OGL::aa_adjust_vertices(v69 + 480, v69 + 96, 48, 4);
          CA::OGL::aa_adjust_vertices(v69 + 2400, v69 + 2784, 48, 4);
          CA::OGL::aa_adjust_vertices(v69 + 816, v69 + 768, 384, 4);
          CA::OGL::aa_adjust_vertices(v69 + 1056, v69 + 1104, 384, 4);
          goto LABEL_101;
        }
LABEL_110:
        CA::OGL::aa_adjust_vertices(v69, v69 + 48, 384, 8);
        if ((*((_DWORD *)a2 + 5) & 2) == 0) {
          goto LABEL_100;
        }
        goto LABEL_99;
      }
    }
  }
}

uint64_t CA::OGL::emit_nine_part_rect(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  v81[78] = *MEMORY[0x1E4F143B8];
  BOOL v9 = (a9 & 0x3C00000) != 0;
  BOOL v10 = (a9 & 0x8000000) == 0;
  BOOL v11 = v9 && v10;
  if (v9 && v10) {
    unint64_t v12 = 20;
  }
  else {
    unint64_t v12 = 16;
  }
  if (a7) {
    unint64_t v13 = 4;
  }
  else {
    unint64_t v13 = 2;
  }
  if (v12 > *(unsigned int *)(result + 136)) {
    return result;
  }
  double v15 = (CA::OGL::Context *)result;
  uint64_t v16 = 0;
  uint64_t v17 = *(void *)(result + 120);
  int v18 = (_DWORD *)(v17 + 28);
  double v19 = v81;
  __n128 v20 = (__n128)xmmword_184997D60;
  do
  {
    uint64_t v21 = 0;
    uint64_t v22 = *(void *)(a4 + 8 * v16);
    uint64_t v23 = v19;
    double v24 = v18;
    do
    {
      *((void *)v23 - 2) = *(void *)(a3 + 8 * v21);
      *((void *)v23 - 1) = v22;
      *uint64_t v23 = xmmword_184997D60;
      if (a5)
      {
        *(v24 - 3) = *(_DWORD *)(a5 + 4 * v21);
        *(v24 - 2) = *(_DWORD *)(a6 + 4 * v16);
      }
      if (a7)
      {
        *(v24 - 1) = *(_DWORD *)(a7 + 4 * v21);
        *double v24 = *(_DWORD *)(a8 + 4 * v16);
      }
      ++v21;
      v24 += 12;
      v23 += 2;
    }
    while (v21 != 4);
    ++v16;
    v18 += 48;
    v19 += 16;
  }
  while (v16 != 4);
  if (v11) {
    v20.n128_f32[0] = CA::OGL::adjust_skipped_corner_vertices_simple(&v80, v17, 4, v13, a9);
  }
  uint64_t v25 = 0;
  uint64_t v26 = *(void *)(*((void *)v15 + 2) + 8);
  do
  {
    *(void *)(v17 + v25 + 32) = v26;
    v25 += 48;
  }
  while (48 * v12 != v25);
  double v27 = *(void (**)(uint64_t, float64x2_t *, uint64_t, unint64_t, __n128))(a2 + 24);
  if (v27) {
    v27(a2, &v80, v17, v12, v20);
  }
  CA::OGL::transform_vertices(&v80, (float32x4_t *)v17, (const double *)v12, *(float64x2_t **)(a2 + 8));
  int8x16_t v28 = *(void (**)(uint64_t, uint64_t, unint64_t))(a2 + 32);
  if (v28) {
    v28(a2, v17, v12);
  }
  if ((*(unsigned char *)(a2 + 16) & 9) == 0) {
    goto LABEL_78;
  }
  int v29 = *(_DWORD *)(a2 + 20);
  if ((v29 & 0xF) == 0) {
    goto LABEL_78;
  }
  if (v11)
  {
    if ((v29 & 4) != 0)
    {
      CA::OGL::aa_adjust_vertices(v17 + 768, v17 + 192, 0, 1);
      CA::OGL::aa_adjust_vertices(v17 + 48, v17 + 240, 0, 1);
      CA::OGL::aa_adjust_vertices(v17 + 144, v17 + 336, 0, 1);
      CA::OGL::aa_adjust_vertices(v17 + 768, v17 + 48, 0, 1);
      if ((a9 & 0x400000) != 0)
      {
        unint64_t v30 = (a9 >> 25) & 2;
        BOOL v31 = v13 >= v30;
        unint64_t v32 = v13 - v30;
        if (v32 != 0 && v31)
        {
          unint64_t v33 = v17 + 8 * (((unint64_t)a9 >> 26) & 1);
          do
          {
            *(_DWORD *)(v33 + 784) = *(_DWORD *)(v33 + 64);
            v33 += 4;
            --v32;
          }
          while (v32);
        }
      }
    }
    if (*(unsigned char *)(a2 + 20))
    {
      CA::OGL::aa_adjust_vertices(v17, v17 + 192, 0, 1);
      CA::OGL::aa_adjust_vertices(v17, v17 + 48, 192, 3);
      CA::OGL::aa_adjust_vertices(v17 + 912, v17 + 624, 0, 1);
      CA::OGL::aa_adjust_vertices(v17 + 912, v17 + 384, 0, 1);
      if ((a9 & 0x400000) != 0)
      {
        unint64_t v34 = (a9 >> 25) & 2;
        BOOL v31 = v13 >= v34;
        unint64_t v35 = v13 - v34;
        if (v35 != 0 && v31)
        {
          double v36 = (_DWORD *)(v17 + 8 * (((unint64_t)a9 >> 26) & 1) + 208);
          do
          {
            *(v36 - 48) = *v36;
            ++v36;
            --v35;
          }
          while (v35);
        }
      }
      if ((a9 & 0x1000000) != 0)
      {
        unint64_t v37 = (a9 >> 25) & 2;
        BOOL v31 = v13 >= v37;
        unint64_t v38 = v13 - v37;
        if (v38 != 0 && v31)
        {
          unint64_t v39 = v17 + 8 * (((unint64_t)a9 >> 26) & 1);
          do
          {
            *(_DWORD *)(v39 + 928) = *(_DWORD *)(v39 + 400);
            v39 += 4;
            --v38;
          }
          while (v38);
        }
      }
    }
    if ((*(unsigned char *)(a2 + 20) & 8) != 0)
    {
      CA::OGL::aa_adjust_vertices(v17 + 576, v17 + 624, 0, 1);
      CA::OGL::aa_adjust_vertices(v17 + 576, v17 + 384, 48, 3);
      CA::OGL::aa_adjust_vertices(v17 + 864, v17 + 528, 0, 1);
      CA::OGL::aa_adjust_vertices(v17 + 864, v17 + 672, 0, 1);
      if ((a9 & 0x1000000) != 0)
      {
        unint64_t v40 = (a9 >> 25) & 2;
        BOOL v31 = v13 >= v40;
        unint64_t v41 = v13 - v40;
        if (v41 != 0 && v31)
        {
          double v42 = (_DWORD *)(v17 + 8 * (((unint64_t)a9 >> 26) & 1) + 592);
          do
          {
            *double v42 = v42[12];
            ++v42;
            --v41;
          }
          while (v41);
        }
      }
      if ((a9 & 0x2000000) != 0)
      {
        unint64_t v43 = (a9 >> 25) & 2;
        BOOL v31 = v13 >= v43;
        unint64_t v44 = v13 - v43;
        if (v44 != 0 && v31)
        {
          int32x2_t v45 = (_DWORD *)(v17 + 8 * (((unint64_t)a9 >> 26) & 1) + 880);
          do
          {
            *int32x2_t v45 = *(v45 - 48);
            ++v45;
            --v44;
          }
          while (v44);
        }
      }
    }
    if ((*(unsigned char *)(a2 + 20) & 2) != 0)
    {
      CA::OGL::aa_adjust_vertices(v17 + 720, v17 + 528, 0, 1);
      CA::OGL::aa_adjust_vertices(v17 + 336, v17 + 288, 192, 3);
      CA::OGL::aa_adjust_vertices(v17 + 816, v17 + 96, 0, 1);
      CA::OGL::aa_adjust_vertices(v17 + 816, v17 + 336, 0, 1);
      if ((a9 & 0x2000000) != 0)
      {
        unint64_t v46 = (a9 >> 25) & 2;
        BOOL v31 = v13 >= v46;
        unint64_t v47 = v13 - v46;
        if (v47 != 0 && v31)
        {
          double v48 = (_DWORD *)(v17 + 8 * (((unint64_t)a9 >> 26) & 1) + 736);
          do
          {
            *double v48 = *(v48 - 48);
            ++v48;
            --v47;
          }
          while (v47);
        }
      }
      if ((a9 & 0x800000) != 0)
      {
        unint64_t v49 = (a9 >> 25) & 2;
        BOOL v31 = v13 >= v49;
        unint64_t v50 = v13 - v49;
        if (v50 != 0 && v31)
        {
          unint64_t v51 = v17 + 8 * (((unint64_t)a9 >> 26) & 1);
          do
          {
            *(_DWORD *)(v51 + 832) = *(_DWORD *)(v51 + 352);
            v51 += 4;
            --v50;
          }
          while (v50);
        }
      }
    }
    if ((*(unsigned char *)(a2 + 20) & 4) != 0)
    {
      CA::OGL::aa_adjust_vertices(v17 + 96, v17 + 288, 0, 1);
      CA::OGL::aa_adjust_vertices(v17 + 144, v17 + 96, 0, 1);
      if ((a9 & 0x800000) != 0)
      {
        unint64_t v52 = (a9 >> 25) & 2;
        BOOL v31 = v13 >= v52;
        unint64_t v53 = v13 - v52;
        if (v53 != 0 && v31)
        {
          double v54 = (_DWORD *)(v17 + 8 * (((unint64_t)a9 >> 26) & 1) + 160);
          do
          {
            *double v54 = *(v54 - 12);
            ++v54;
            --v53;
          }
          while (v53);
        }
      }
    }
    goto LABEL_78;
  }
  if ((v29 & 4) != 0)
  {
    CA::OGL::aa_adjust_vertices(v17, v17 + 192, 48, 4);
    int v29 = *(_DWORD *)(a2 + 20);
    if ((v29 & 8) == 0)
    {
LABEL_75:
      if ((v29 & 1) == 0) {
        goto LABEL_76;
      }
LABEL_100:
      CA::OGL::aa_adjust_vertices(v17, v17 + 48, 192, 4);
      if ((*(_DWORD *)(a2 + 20) & 2) == 0) {
        goto LABEL_78;
      }
      goto LABEL_77;
    }
  }
  else if ((v29 & 8) == 0)
  {
    goto LABEL_75;
  }
  CA::OGL::aa_adjust_vertices(v17 + 576, v17 + 384, 48, 4);
  int v29 = *(_DWORD *)(a2 + 20);
  if (v29) {
    goto LABEL_100;
  }
LABEL_76:
  if ((v29 & 2) != 0) {
LABEL_77:
  }
    CA::OGL::aa_adjust_vertices(v17 + 144, v17 + 96, 192, 4);
LABEL_78:
  uint64_t v55 = CA::OGL::Context::need_transparent_source(v15);
  unsigned int v56 = a9 & 0x40000;
  if ((a9 & 0x8000000) != 0) {
    unint64_t v57 = 20;
  }
  else {
    unint64_t v57 = 4;
  }
  float v58 = (const unsigned __int16 *)&CA::OGL::emit_nine_part_rect(CA::OGL::Context &,CA::OGL::RectState const&,double const*,double const*,float const*,float const*,float const*,float const*,unsigned int,float)::indices;
  if ((a9 & 0x8000000) != 0 && (a9 & 0x3C00000) != 0)
  {
    LODWORD(v55) = MEMORY[0x1F4188790](v55);
    uint64_t v60 = 0;
    uint64_t v61 = 0;
    memset(v74, 0, sizeof(v74));
    long long v75 = xmmword_1849A7184;
    long long v76 = unk_1849A7194;
    uint64_t v77 = 0x9000A00060005;
    uint64_t v62 = 12;
    do
    {
      uint64_t v63 = *(void *)(v59 + 8 * v60);
      if ((dword_184998820[v60] & a9) != 0)
      {
        *(void *)&v74[v62] = v63;
        v62 -= 4;
        v57 += 4;
      }
      else
      {
        *(void *)&v74[v61] = v63;
        v61 += 4;
      }
      ++v60;
    }
    while (v60 != 4);
    float v58 = v74;
  }
  int v64 = v55 | (v56 >> 18);
  if (v11)
  {
    float v58 = (const unsigned __int16 *)&CA::OGL::emit_nine_part_rect(CA::OGL::Context &,CA::OGL::RectState const&,double const*,double const*,float const*,float const*,float const*,float const*,unsigned int,float)::corner_skipped_indices;
    uint64_t v65 = (uint64_t)v15;
    uint64_t v66 = a2;
    unint64_t v67 = 52;
    unsigned int v68 = 20;
  }
  else
  {
    uint64_t v65 = (uint64_t)v15;
    uint64_t v66 = a2;
    unint64_t v67 = 36;
    unsigned int v68 = 16;
  }
  uint64_t result = CA::OGL::emit_mesh_with_center(v65, v66, v58, v67, v57, v68, a9);
  if (v64)
  {
    float64x2_t v69 = vcvtq_f64_f32(*(float32x2_t *)(v17 + 8));
    v79[0] = vcvtq_f64_f32(*(float32x2_t *)v17);
    v79[1] = v69;
    float64x2_t v70 = vcvtq_f64_f32(*(float32x2_t *)(v17 + 152));
    v79[2] = vcvtq_f64_f32(*(float32x2_t *)(v17 + 144));
    v79[3] = v70;
    float64x2_t v71 = vcvtq_f64_f32(*(float32x2_t *)(v17 + 728));
    v79[4] = vcvtq_f64_f32(*(float32x2_t *)(v17 + 720));
    v79[5] = v71;
    float64x2_t v72 = vcvtq_f64_f32(*(float32x2_t *)(v17 + 584));
    v79[6] = vcvtq_f64_f32(*(float32x2_t *)(v17 + 576));
    v79[7] = v72;
    if ((a9 & 0x40000) != 0) {
      uint64_t v73 = *(void *)(*((void *)v15 + 2) + 8);
    }
    else {
      uint64_t v73 = 0;
    }
    uint64_t v78 = v73;
    return CA::OGL::emit_quad_surround((uint64_t)v15, (const double *)v79, &v78);
  }
  return result;
}

uint64_t CA::OGL::aa_adjust_vertices(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v4 = 0;
    do
    {
      float32x4_t v5 = *(float32x4_t *)(result + v4);
      float32x4_t v6 = *(float32x4_t *)(a2 + v4);
      float32x4_t v7 = vsubq_f32(v5, v6);
      float32x4_t v8 = vmulq_f32(v7, v7);
      float v9 = vaddv_f32((float32x2_t)*(_OWORD *)&vpaddq_f32(v8, v8));
      if (v9 != 0.0)
      {
        float v10 = 1.0;
        if (v9 != 1.0) {
          float v10 = 1.0 / sqrtf(v9);
        }
        v6.i32[0] = HIDWORD(*(_OWORD *)(a2 + v4));
        if (v5.f32[3] > v6.f32[3]) {
          v6.i32[0] = HIDWORD(*(_OWORD *)(result + v4));
        }
        float v11 = v10 * v6.f32[0];
        unint64_t v12 = (float32x4_t *)(result + v4);
        float32x4_t v13 = vmlaq_n_f32(v5, v7, v11);
        float32x4_t v14 = vmlaq_n_f32(*(float32x4_t *)(result + v4 + 16), vsubq_f32(*(float32x4_t *)(result + v4 + 16), *(float32x4_t *)(a2 + v4 + 16)), v11);
        *unint64_t v12 = v13;
        v12[1] = v14;
      }
      v4 += a3;
      --a4;
    }
    while (a4);
  }
  return result;
}

uint64_t CA::OGL::emit_quad_indices(uint64_t a1, float64x2_t *a2, const unsigned __int16 *a3, unint64_t a4, unsigned int a5)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int32x4_t v20 = 0uLL;
  if (a2)
  {
    float64x2_t v9 = a2[1];
    int64x2_t v10 = vceqzq_f64(v9);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10).u64[0] & 0x8000000000000000) == 0)
    {
      int8x16_t v11 = vorrq_s8((int8x16_t)vcltzq_f64(v9), (int8x16_t)vcgezq_f64(v9));
      if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v11), 1), v11).u64[0] & 0x8000000000000000) == 0)
      {
        int32x4_t v12 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(*a2, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        int32x4_t v20 = vuzp1q_s32(v12, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(*a2, v9), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v12));
      }
    }
    float32x4_t v13 = &v20;
  }
  else
  {
    float32x4_t v13 = 0;
  }
  long long v21 = 0u;
  if (*(_DWORD *)(a1 + 92)) {
    int v14 = 6;
  }
  else {
    int v14 = 4;
  }
  long long v24 = 0uLL;
  uint64_t v15 = *(void *)(*(void *)(a1 + 248) + 8);
  v22[0] = a1;
  v22[1] = v15;
  long long v23 = 0uLL;
  v22[2] = 0;
  WORD4(v23) = 256;
  *(void *)&long long v24 = v13;
  CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v22);
  uint64_t v16 = a5;
  while (1)
  {
    uint64_t result = CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v22, (int32x2_t *)&v21);
    if (!result) {
      break;
    }
    *(void *)(a1 + 128) = v16;
    if (a4)
    {
      unint64_t v18 = 0;
      double v19 = a3;
      do
      {
        if ((v14 + *(_DWORD *)(a1 + 104)) > *(_DWORD *)(a1 + 112))
        {
          *(_WORD *)(a1 + 832) |= 0x20u;
          CA::OGL::Context::array_flush(a1);
          *(void *)(a1 + 96) = a1 + 834;
          *(_OWORD *)(a1 + 104) = xmmword_184997E70;
          *(void *)(a1 + 128) = v16;
        }
        CA::OGL::Context::array_indices_vec(a1, v19);
        v18 += 4;
        v19 += 4;
      }
      while (v18 < a4);
    }
  }
  return result;
}

uint64_t CA::OGL::Context::array_indices_vec(uint64_t this, const unsigned __int16 *a2)
{
  uint64_t v2 = *(void *)(this + 104);
  long long v3 = (_WORD *)(*(void *)(this + 96) + 2 * v2);
  int v4 = *(_DWORD *)(this + 92);
  if (v4 == 1)
  {
    _WORD *v3 = *a2;
    v3[1] = a2[1];
    v3[2] = a2[2];
    v3[3] = a2[2];
    v3[4] = a2[3];
    uint64_t v5 = 6;
    uint64_t v6 = 5;
  }
  else
  {
    if (v4) {
      return this;
    }
    _WORD *v3 = *a2;
    v3[1] = a2[1];
    v3[2] = a2[2];
    a2 += 3;
    uint64_t v5 = 4;
    uint64_t v6 = 3;
  }
  v3[v6] = *a2;
  *(void *)(this + 104) = v2 + v5;
  return this;
}

float64x2_t *CA::OGL::transform_vertices(float64x2_t *result, float32x4_t *a2, const double *a3, float64x2_t *this)
{
  int v4 = a3;
  uint64_t v6 = result;
  if ((LOBYTE(this[9].f64[0]) & 0x1F) != 0)
  {
    for (uint64_t result = (float64x2_t *)CA::Transform::apply_to_point4((uint64_t)this, result, result, a3);
          v4;
          int v4 = (const double *)((char *)v4 - 1))
    {
      float64x2_t v8 = *v6;
      float64x2_t v7 = v6[1];
      v6 += 2;
      *a2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v8), v7);
      a2 += 3;
    }
  }
  else if (a3)
  {
    float64x2_t v9 = this[6];
    int64x2_t v10 = result + 1;
    do
    {
      *a2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(v10[-1], v9)), *v10);
      a2 += 3;
      v10 += 2;
      int v4 = (const double *)((char *)v4 - 1);
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::emit_mesh_with_center(uint64_t a1, uint64_t a2, const unsigned __int16 *a3, unint64_t a4, unint64_t a5, unsigned int a6, int a7)
{
  unint64_t v8 = a4;
  if ((a7 & 0x4000) != 0)
  {
    unint64_t v8 = a4 - a5;
  }
  else if ((a7 & 0x30000) != 0 || (*(unsigned char *)(a2 + 17) & 0x80) != 0)
  {
    unint64_t v8 = a4 - a5;
    if (a5)
    {
      uint64_t v12 = *(void *)(a1 + 16);
      uint64_t v13 = *(void *)(v12 + 16);
      if ((a7 & 0x10000) != 0)
      {
        unint64_t v14 = v13 & 0xFFFFFF00FF00FF00;
        if (*(void *)(v12 + 8) == 0x3C003C003C003C00) {
          int v15 = 1;
        }
        else {
          int v15 = 3;
        }
        *(_DWORD *)(v12 + 16) = v15 | v14;
        *(_DWORD *)(v12 + 20) = HIDWORD(v14);
      }
      char v16 = *(unsigned char *)(v12 + 481);
      if ((a7 & 0x20000) != 0) {
        *(unsigned char *)(*(void *)(a1 + 16) + 16) = 0;
      }
      if (v16)
      {
        if ((*(unsigned char *)(a2 + 17) & 0x80) != 0) {
          *(unsigned char *)(*(void *)(a1 + 16) + 481) &= ~1u;
        }
        CA::OGL::emit_quad_indices(a1, *(float64x2_t **)(a2 + 40), &a3[v8], a5, a6);
        if ((*(unsigned char *)(a2 + 17) & 0x80) != 0) {
          *(unsigned char *)(*(void *)(a1 + 16) + 481) |= 1u;
        }
      }
      else
      {
        CA::OGL::emit_quad_indices(a1, *(float64x2_t **)(a2 + 40), &a3[v8], a5, a6);
      }
      *(void *)(*(void *)(a1 + 16) + 16) = v13;
    }
  }
  uint64_t v17 = *(float64x2_t **)(a2 + 40);

  return CA::OGL::emit_quad_indices(a1, v17, a3, v8, a6);
}

float32x2_t CA::OGL::anonymous namespace'::BackdropRectState::map(uint64_t a1, uint64_t a2, float32x2_t *a3, uint64_t a4)
{
  if (a4)
  {
    int v4 = *(float32x2_t **)(a1 + 48);
    uint64_t v5 = a3 + 2;
    do
    {
      uint64_t v6 = (const float *)v5;
      float32x2_t result = vld1_dup_f32(v6++);
      float32x2_t v8 = vmla_f32(*v4, result, vsub_f32(v4[1], *v4));
      float32x2_t *v5 = vmla_n_f32(v8, vmla_f32(vsub_f32(v4[3], v8), result, vsub_f32(v4[2], v4[3])), *v6);
      v5 += 6;
      --a4;
    }
    while (a4);
  }
  return result;
}

void CA::OGL::anonymous namespace'::BackdropRectState::post_map(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    long long v3 = (float *)(a2 + 8);
    do
    {
      float v4 = v3[1];
      if (v4 != 1.0)
      {
        float v5 = 1.0 / v4;
        *((float32x2_t *)v3 - 1) = vmul_n_f32(*(float32x2_t *)(v3 - 2), v5);
        float *v3 = *v3 * v5;
        v3[1] = 1.0;
      }
      v3 += 12;
      --a3;
    }
    while (a3);
  }
}

void CA::OGL::Shape::fill_path<CA::OGL::RenderPathIterator>(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  float32x2_t v8 = v3;
  int v9 = v2;
  uint64_t v11 = v10;
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  v42[0] = 0;
  v42[1] = &v44;
  long long v43 = xmmword_184998000;
  unint64_t v41 = (void ***)v42;
  uint64_t v36 = 0;
  *(void *)&v30.f64[0] = v42;
  v30.f64[1] = 0.0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0x3FC0000000000000;
  float64x2_t v34 = 0u;
  memset(v35, 0, sizeof(v35));
  int64x2_t v37 = vdupq_n_s64(0x7FF0000000000000uLL);
  int64x2_t v38 = vdupq_n_s64(0xFFF0000000000000);
  int32x2_t v12 = vadd_s32(v3[1], *v3);
  v13.i64[0] = v12.i32[0];
  v13.i64[1] = v12.i32[1];
  float64x2_t v14 = vcvtq_f64_s64(v13);
  v13.i64[0] = v3->i32[0];
  v13.i64[1] = (int)HIDWORD(*(unint64_t *)v3);
  float64x2_t v39 = vcvtq_f64_s64(v13);
  float64x2_t v40 = v14;
  int v15 = *(double **)(*v1 + 32);
  char v16 = *(unsigned char **)(*v1 + 40);
  uint64_t v17 = *(unsigned int *)(*v1 + 20);
  unint64_t v18 = &v16[v17];
  if (v1[1])
  {
    if (v17)
    {
      double v19 = v1;
      long long v20 = xmmword_184997D60;
      while (1)
      {
        long long v49 = 0u;
        long long v50 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        float64x2_t v45 = 0u;
        long long v46 = 0u;
        int v21 = *v16;
        if ((v21 - 1) < 2) {
          break;
        }
        if (v21 == 3)
        {
          uint64_t v22 = 1;
LABEL_10:
          long long v47 = *((_OWORD *)v15 + 1);
          long long v48 = v20;
LABEL_11:
          float64x2_t v45 = *(float64x2_t *)v15;
          long long v46 = v20;
          uint64_t v23 = v22 + 1;
          CA::Transform::apply_to_point4(v19[1], &v45, &v45, (const double *)(v22 + 1));
          long long v20 = xmmword_184997D60;
          v15 += 2 * v23;
          int v21 = *v16;
          goto LABEL_12;
        }
        if (v21 == 4)
        {
          long long v49 = *((_OWORD *)v15 + 2);
          *((void *)&v50 + 1) = 0x3FF0000000000000;
          uint64_t v22 = 2;
          goto LABEL_10;
        }
LABEL_12:
        switch(v21)
        {
          case 0:
            CA::ScanConverter::Path::closepath(v30.f64);
            goto LABEL_18;
          case 1:
            float64x2_t v24 = v45;
            uint64_t v25 = *((void *)&v46 + 1);
            CA::ScanConverter::Path::closepath(v30.f64);
            float64x2_t v34 = v24;
            *(void *)&v35[0] = v25;
            *(float64x2_t *)((char *)v35 + 8) = v24;
            *((void *)&v35[1] + 1) = v25;
            goto LABEL_18;
          case 2:
            CA::ScanConverter::Path::lineto((uint64_t)&v30, v45.f64[0], v45.f64[1], *((double *)&v46 + 1));
            goto LABEL_18;
          case 3:
            CA::ScanConverter::Path::quadto((CA::ScanConverter::Path *)&v30, v45.f64[0], v45.f64[1], *((double *)&v46 + 1), *(double *)&v47, *((double *)&v47 + 1), *((double *)&v48 + 1), (uint64_t)v1, v2, (uint64_t)v3, v4, v5, v6, v7);
            goto LABEL_18;
          case 4:
            CA::ScanConverter::Path::cubeto((CA::ScanConverter::Path *)&v30, v45.f64[0], v45.f64[1], *((double *)&v46 + 1), *(double *)&v47, *((double *)&v47 + 1), *((double *)&v48 + 1), *(double *)&v49, *((double *)&v49 + 1), (uint64_t)v1, v2, (uint64_t)v3, v4, v5, v6, v7, *((double *)&v50 + 1));
LABEL_18:
            long long v20 = xmmword_184997D60;
            break;
          default:
            break;
        }
        if (++v16 >= v18) {
          goto LABEL_29;
        }
      }
      uint64_t v22 = 0;
      goto LABEL_11;
    }
  }
  else if (v17)
  {
    do
    {
      switch(*v16)
      {
        case 0:
          CA::ScanConverter::Path::closepath(v30.f64);
          break;
        case 1:
          float64_t v28 = *v15;
          float64_t v29 = v15[1];
          v15 += 2;
          CA::ScanConverter::Path::closepath(v30.f64);
          v34.f64[0] = v28;
          v34.f64[1] = v29;
          *((float64_t *)v35 + 1) = v28;
          *(float64_t *)&v35[1] = v29;
          *(void *)&v35[0] = 0x3FF0000000000000;
          *((void *)&v35[1] + 1) = 0x3FF0000000000000;
          break;
        case 2:
          double v26 = *v15;
          double v27 = v15[1];
          v15 += 2;
          CA::ScanConverter::Path::lineto(v30.f64, v26, v27);
          break;
        case 3:
          CA::ScanConverter::Path::quadto((CA::ScanConverter::Path *)&v30, *v15, v15[1], v15[2], v15[3], (uint64_t)v1, v2, (uint64_t)v3, v4, v5, v6, v7);
          v15 += 4;
          break;
        case 4:
          CA::ScanConverter::Path::cubeto((CA::ScanConverter::Path *)&v30, *v15, v15[1], v15[2], v15[3], v15[4], v15[5], (uint64_t)v1, v2, (uint64_t)v3, v4, v5, v6, v7);
          v15 += 6;
          break;
        default:
          break;
      }
      ++v16;
    }
    while (v16 < v18);
  }
LABEL_29:
  CA::ScanConverter::Path::closepath(v30.f64);
  if (*(void *)&v30.f64[0]) {
    CA::OGL::Shape::fill_sc_path(v11, &v30, v9, 0, 1u, *v8, v8[1]);
  }
  x_heap_free(v41);
}

uint64_t CA::Transform::apply_to_point4(uint64_t this, float64x2_t *a2, float64x2_t *a3, const double *a4)
{
  if ((*(unsigned char *)(this + 144) & 0x10) != 0)
  {
    for (; a4; a4 = (const double *)((char *)a4 - 1))
    {
      float64x2_t v7 = *a3;
      float64x2_t v8 = a3[1];
      a3 += 2;
      float64x2_t v9 = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)(this + 16), v7.f64[0]), *(float64x2_t *)(this + 48), v7, 1), *(float64x2_t *)(this + 80), v8.f64[0]), *(float64x2_t *)(this + 112), v8, 1);
      *a2 = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)this, v7.f64[0]), *(float64x2_t *)(this + 32), v7, 1), *(float64x2_t *)(this + 64), v8.f64[0]), *(float64x2_t *)(this + 96), v8, 1);
      a2[1] = v9;
      a2 += 2;
    }
  }
  else
  {
    float64x2_t v4 = *(float64x2_t *)(this + 96);
    v5.f64[0] = *(float64_t *)this;
    v6.f64[1] = *(float64_t *)(this + 40);
    if (a2 == a3)
    {
      if (a4)
      {
        v5.f64[1] = *(float64_t *)(this + 8);
        v6.f64[0] = *(float64_t *)(this + 32);
        do
        {
          *a2 = vmlaq_laneq_f64(vmlaq_n_f64(v4, v5, a2->f64[0]), v6, *a2, 1);
          a2 += 2;
          a4 = (const double *)((char *)a4 - 1);
        }
        while (a4);
      }
    }
    else if (a4)
    {
      v5.f64[1] = *(float64_t *)(this + 8);
      v6.f64[0] = *(float64_t *)(this + 32);
      do
      {
        *a2 = vmlaq_laneq_f64(vmlaq_n_f64(v4, v5, a3->f64[0]), v6, *a3, 1);
        a2[1] = a3[1];
        a3 += 2;
        a2 += 2;
        a4 = (const double *)((char *)a4 - 1);
      }
      while (a4);
    }
  }
  return this;
}

uint64_t CA::ScanConverter::Path::add_monotonic_cube(uint64_t this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, int a10)
{
  uint64_t v15 = this;
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  if (a10 >= 2)
  {
    double v18 = a9 * a9;
    double v19 = 4.0;
    double v75 = a8 * 4.0;
    double v69 = a9 * 8.0;
    double v70 = a9 * 4.0;
    double v67 = a9 * a9 * a9;
    double v68 = a9 + a9;
    unsigned int v20 = a10 + 1;
    double v21 = 12.0;
    double v22 = 6.0;
    double v23 = 2.0;
    double v24 = a8 + a8;
    double v79 = a8 + a8;
    while (1)
    {
      if (vabdd_f64(a9, a3) < 0.0001)
      {
        double v16 = a2;
        double v17 = a3;
        return CA::ScanConverter::Path::add_line(v15, v16, v17, a8, a9);
      }
      if (a3 >= a9) {
        double v25 = a9;
      }
      else {
        double v25 = a3;
      }
      if (a3 <= a9) {
        double v26 = a9;
      }
      else {
        double v26 = a3;
      }
      if (v25 > *(double *)(v15 + 184) || v26 < *(double *)(v15 + 168)) {
        return this;
      }
      double v27 = *(double *)(v15 + 32);
      double v28 = a4 + a4;
      double v29 = a6 + a6;
      BOOL v30 = (a2 - (a4 + a4) + a6) * (a2 - (a4 + a4) + a6) + (a3 - (a5 + a5) + a7) * (a3 - (a5 + a5) + a7) > v27 * v27
         || (a4 - (a6 + a6) + a8) * (a4 - (a6 + a6) + a8) + (a5 - (a7 + a7) + a9) * (a5 - (a7 + a7) + a9) > v27 * v27;
      if (!v30)
      {
        return CA::ScanConverter::Path::add_line(v15, a2, a3, a8, a9);
      }
      double v74 = v25;
      double v31 = 1.0 / (a3 - a9);
      double v78 = a4 + a2;
      double v32 = v31
          * v31
          * (0.9
           * v31)
          * (a7 * (a4 + a2 - v24) + (v29 + a4 + a2 * -3.0) * a9 + (a8 * 3.0 - v28 - a6) * a3 + (a2 + a2 - (a6 + a8))
                                                                                             * a5);
      double v33 = (a2 - a8 + v32 * (v18 - a3 * a3)) * v31;
      double v77 = a2 * v19;
      double v34 = a2 * v19 + a4 * v19 + a6;
      double v35 = a8 + a2 * 8.0 + a4 * v21 + a6 * v22;
      double v36 = v35 * 0.037037037;
      double v76 = a3 * v19;
      double v37 = (a9 + a3 * 8.0 + a5 * v21 + a7 * v22) * 0.037037037;
      double v72 = v33;
      double v73 = v32;
      double v38 = v32 * 0.333333333;
      double v39 = v33 * 0.5;
      if (fabs(-(v33 * 0.5 * (v37 * v37 - a3 * a3)+ v32 * 0.333333333 * (v37 * v37 * v37 - a3 * a3 * a3)+ (a2 - (v33 + v32 * a3) * a3) * (v37 - a3)+ ((v35 * 0.037037037 - (a2 + a2 + v34 * -0.111111111)) * (a5 + a3 + a3)+ (a3 * v19 + a5 * v19 + a7) * 0.333333333 * (v35 * 0.0740740741 - (a2 + (a4 + a2 + a2) * 0.333333333))+ (v35 * 0.037037037 + a2 * 10.0 + (a4 + a2 + a2) * v23 + v34 * 0.333333333) * a3+ (-(a4 + a2 + a2 + a2 + v34 * 0.666666667) - v35 * 0.37037037) * v37)* 0.05)/ sqrt((v36 - a2) * (v36 - a2) + (v37 - a3) * (v37 - a3))) <= v27)
      {
        double v40 = a2 - (v33 + v32 * a3) * a3;
        double v41 = a4 + v75 + a6 * 4.0;
        double v42 = a2 + a8 * 8.0 + a4 * 6.0 + a6 * v21;
        double v43 = v42 * 0.037037037;
        double v44 = v79 - v42 * 0.037037037 + v41 * -0.111111111;
        double v45 = v42 * 0.0740740741;
        double v46 = v42 * 0.37037037;
        double v47 = (a3 + v69 + a5 * 6.0 + a7 * v21) * 0.037037037;
        double v71 = v44 * (a7 + v68)
            + (a6 + v24 + a8 + v41 * 0.666666667 + v46) * v47
            + (a5 + v70 + a7 * 4.0) * -0.333333333 * (v45 - (a8 - (a6 + v24) * -0.333333333));
        double v48 = a2 + a2 + v75 + a4 * 9.0 + a6 * v21;
        double v49 = v77 + v79 + a4 * v21 + a6 * 9.0;
        double v50 = v47 * v47 * v47;
        BOOL v30 = fabs(-(v39 * (v47 * v47 - v37 * v37)+ v38 * (v50 - v37 * v37 * v37)+ v40 * (v47 - v37)+ ((-(v46 + v48 * 0.222222222 + v49 * 0.111111111) - v36) * v47+ (v35 * 0.37037037 + v49 * 0.222222222 + v48 * 0.111111111 + v43) * v37+ ((v43 + v48 * 0.037037037 - v35 * 0.0740740741) * (v76 + v68 + a5 * v21 + a7 * 9.0)+ (v45 - (v36 + v49 * 0.037037037)) * (a3 + a3 + v70 + a5 * 9.0 + a7 * v21))* 0.111111111)* 0.05)/ sqrt((v43 - v36) * (v43 - v36) + (v47 - v37) * (v47 - v37))) <= v27;
        double v51 = fabs(-(v39 * (a9 * a9 - v47 * v47)+ v38 * (v67 - v50)+ v40 * (a9 - v47)+ (v71 + (-(a8 * 10.0 + (a6 + v24) * 2.0 - v41 * -0.333333333) - v43) * a9) * 0.05)/ sqrt((a8 - v43) * (a8 - v43) + (a9 - v47) * (a9 - v47)));
        if (v30 && v51 <= v27) {
          break;
        }
      }
      double v53 = (v28 + a2 + a6) * 0.25;
      double v16 = (a2 + a8 + (a6 + a4) * 3.0) * 0.125;
      a4 = (v29 + a4 + a8) * 0.25;
      a6 = (a6 + a8) * 0.5;
      double v54 = (a5 + a3) * 0.5;
      double v55 = (a5 + a5 + a3 + a7) * 0.25;
      double v17 = (a3 + a9 + (a7 + a5) * 3.0) * 0.125;
      a5 = (a5 + a9 + a7 + a7) * 0.25;
      a7 = (a7 + a9) * 0.5;
      this = CA::ScanConverter::Path::add_monotonic_cube((CA::ScanConverter::Path *)v15, a2, a3, v78 * 0.5, v54, v53, v55, v16, v17, v20 - 2);
      double v21 = 12.0;
      double v18 = a9 * a9;
      double v24 = a8 + a8;
      --v20;
      a3 = v17;
      a2 = v16;
      double v19 = 4.0;
      double v22 = 6.0;
      double v23 = 2.0;
      if (v20 < 3) {
        goto LABEL_3;
      }
    }
    double v57 = v40;
    double v58 = a8;
    if (a2 >= a8) {
      double v59 = a8;
    }
    else {
      double v59 = a2;
    }
    if (a2 > a8) {
      double v58 = a2;
    }
    if (v73 == 0.0)
    {
      double v63 = v74;
      double v60 = v72;
    }
    else
    {
      double v60 = v72;
      double v61 = v72 * -0.5 / v73;
      BOOL v62 = v61 > a3 && v61 < a9;
      double v63 = v74;
      if (v62 || (v61 > a9 ? (BOOL v64 = v61 < a3) : (BOOL v64 = 0), v64))
      {
        double v65 = v57 + v39 * v61;
        if (v59 >= v65) {
          double v59 = v65;
        }
        if (v58 <= v65) {
          double v58 = v65;
        }
      }
    }
    if (a3 <= a9) {
      double v66 = 1.0;
    }
    else {
      double v66 = -1.0;
    }
    return CA::ScanConverter::Path::add_curve(v15, v59, v63, v58, v26, v73, v60, v57, v66);
  }
  else
  {
    double v16 = a2;
    double v17 = a3;
LABEL_3:
    if (!*(unsigned char *)(v15 + 90))
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unsigned int v56 = x_log_category_utilities;
        if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134219776;
          double v82 = v16;
          __int16 v83 = 2048;
          double v84 = v17;
          __int16 v85 = 2048;
          double v86 = a4;
          __int16 v87 = 2048;
          double v88 = a5;
          __int16 v89 = 2048;
          double v90 = a6;
          __int16 v91 = 2048;
          double v92 = a7;
          __int16 v93 = 2048;
          double v94 = a8;
          __int16 v95 = 2048;
          double v96 = a9;
          _os_log_impl(&dword_184668000, v56, OS_LOG_TYPE_ERROR, "CoreAnimation: failed to add monotonic cube ((%g, %g) (%g, %g) (%g, %g) (%g, %g))\n", buf, 0x52u);
        }
      }
      *(unsigned char *)(v15 + 90) = 1;
    }
    return CA::ScanConverter::Path::add_line(v15, v16, v17, a8, a9);
  }
}

uint64_t CA::ScanConverter::Path::add_cube(uint64_t this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  uint64_t v11 = this;
  if (vabdd_f64(a5, a7) + vabdd_f64(a4, a6) >= 0.0001) {
    goto LABEL_5;
  }
  double v12 = vabdd_f64(a3, a5) + vabdd_f64(a2, a4);
  double v13 = vabdd_f64(a7, a9) + vabdd_f64(a6, a8);
  if (v13 + v12 < 0.0002) {
    return this;
  }
  if (v12 < 0.0001 || v13 < 0.0001)
  {
    return CA::ScanConverter::Path::add_line(this, a2, a3, a8, a9);
  }
  else
  {
LABEL_5:
    double v14 = a5 - a7;
    double v15 = (a5 - a7) * a5 + (a7 - a3) * a7 + (a3 - a5) * a9;
    if (v15 >= 0.0)
    {
      double v16 = a9 - a3 + v14 * 3.0;
      double v17 = a3 + a5 * -2.0 + a7;
      if (v16 == 0.0)
      {
        if (v17 == 0.0)
        {
          double v18 = 0.0;
          double v19 = 0.0;
        }
        else
        {
          double v18 = 2.0;
          double v19 = (a3 - a5) * 0.5 / v17;
        }
      }
      else if (v17 != 0.0 || (double v18 = 0.0, v19 = 0.0, v15 != 0.0))
      {
        double v20 = sqrt(v15);
        if (v17 < 0.0) {
          double v20 = -v20;
        }
        double v21 = v20 + v17;
        double v22 = -v21 / v16;
        double v18 = (a3 - a5) / v21;
        if (v22 >= v18) {
          double v19 = (a3 - a5) / v21;
        }
        else {
          double v19 = v22;
        }
        if (v22 > v18) {
          double v18 = v22;
        }
      }
      double v23 = 2.0;
      if (v19 < 1.0e-10)
      {
        double v24 = v18;
      }
      else
      {
        double v23 = v18;
        double v24 = v19;
      }
      if (v24 >= 1.0e-10 && v24 <= 1.0)
      {
        if (1.0 - v23 >= 1.0e-10)
        {
          double v32 = 1.0 - v24;
          double v33 = (v23 - v24) / (1.0 - v24);
          double v34 = a9 - a7;
          double v35 = a2 + a4 * -2.0 + a6;
          double v36 = a2 + ((a4 - a2) * 3.0 + (v35 * 3.0 + v24 * (a8 - (a2 + (a4 - a6) * -3.0))) * v24) * v24;
          double v37 = a3 + ((a5 - a3) * 3.0 + (v17 * 3.0 + v24 * (a9 - (a3 + v14 * -3.0))) * v24) * v24;
          double v38 = a8 - a6 + a8 - a6;
          double v58 = -((v38 + v32 * (-(a4 + a6 * -2.0) - a8)) * v32);
          double v39 = -((v34 + v34 + v32 * (-(a5 + a7 * -2.0) - a9)) * v32);
          double v56 = a9 - (v34 + v34 + v32 * (-(a5 + a7 * -2.0) - a9)) * v32;
          double v57 = a8 - (v38 + v32 * (-(a4 + a6 * -2.0) - a8)) * v32;
          double v40 = (1.0 - v24) * (a8 - a6);
          double v41 = (1.0 - v24) * (a9 - a7);
          CA::ScanConverter::Path::add_monotonic_cube(this, a2, a3, a2 + v24 * (a4 - a2), a3 + v24 * (a5 - a3), a2 + (a4 - a2 + a4 - a2 + v24 * v35) * v24, a3 + (a5 - a3 + a5 - a3 + v24 * v17) * v24, v36, v37, 128);
          double v42 = v36 + (v57 - v36) * v33;
          double v43 = v37 + (v56 - v37) * v33;
          double v44 = v36 + v57 * -2.0 + a8 - v40;
          double v45 = v36 + (v57 - v36 + v57 - v36 + v44 * v33) * v33;
          double v46 = v37 + v56 * -2.0 + a9 - v41;
          double v47 = v37 + (v56 - v37 + v56 - v37 + v46 * v33) * v33;
          double v48 = v36 + ((v57 - v36) * 3.0 + ((a8 - v36 + (v58 + v40) * 3.0) * v33 + v44 * 3.0) * v33) * v33;
          double v49 = v37 + ((v56 - v37) * 3.0 + ((a9 - v37 + (v39 + v41) * 3.0) * v33 + v46 * 3.0) * v33) * v33;
          double v50 = 1.0 - v33;
          double v59 = a8 - (v40 + v40 + (-(a8 + (a8 - v40) * -2.0) - v57) * (1.0 - v33)) * (1.0 - v33);
          double v51 = a9 - (v41 + v41 + (-(a9 + (a9 - v41) * -2.0) - v56) * (1.0 - v33)) * (1.0 - v33);
          double v52 = a8 - v50 * v40;
          double v53 = a9 - v50 * v41;
          double v54 = v36;
          double v55 = v48;
          CA::ScanConverter::Path::add_monotonic_cube(v11, v54, v37, v42, v43, v45, v47, v48, v49, 128);
          a2 = v55;
          this = v11;
          a3 = v49;
          a4 = v59;
          a5 = v51;
          a6 = v52;
          a7 = v53;
        }
        else
        {
          double v25 = a2 + a4 * -2.0 + a6;
          double v26 = a2 + ((a4 - a2) * 3.0 + (v25 * 3.0 + v24 * (a8 - (a2 + (a4 - a6) * -3.0))) * v24) * v24;
          double v27 = a3 + ((a5 - a3) * 3.0 + (v17 * 3.0 + v24 * (a9 - (a3 + v14 * -3.0))) * v24) * v24;
          double v28 = a8 - (a8 - a6 + a8 - a6 + (1.0 - v24) * (-(a4 + a6 * -2.0) - a8)) * (1.0 - v24);
          double v29 = a9 - (a9 - a7 + a9 - a7 + (1.0 - v24) * (-(a5 + a7 * -2.0) - a9)) * (1.0 - v24);
          double v30 = a8 - (1.0 - v24) * (a8 - a6);
          double v31 = a9 - (1.0 - v24) * (a9 - a7);
          CA::ScanConverter::Path::add_monotonic_cube(this, a2, a3, a2 + v24 * (a4 - a2), a3 + v24 * (a5 - a3), a2 + (a4 - a2 + a4 - a2 + v24 * v25) * v24, a3 + (a5 - a3 + a5 - a3 + v24 * v17) * v24, v26, v27, 128);
          a2 = v26;
          this = v11;
          a3 = v27;
          a4 = v28;
          a5 = v29;
          a6 = v30;
          a7 = v31;
        }
      }
    }
    return CA::ScanConverter::Path::add_monotonic_cube(this, a2, a3, a4, a5, a6, a7, a8, a9, 128);
  }
}

uint64_t CA::ScanConverter::Path::lineto(uint64_t this, double a2, double a3, double a4)
{
  uint64_t v7 = this;
  double v8 = *(double *)(this + 64);
  if (v8 != a2 || *(double *)(this + 72) != a3 || *(double *)(this + 80) != a4)
  {
    double v9 = *(double *)(this + 80);
    double v10 = v9 + -0.0001;
    if (a4 + -0.0001 < 0.0 || v10 < 0.0)
    {
      if (a4 + -0.0001 < 0.0 && v10 < 0.0) {
        goto LABEL_14;
      }
      double v15 = v10 / (v9 - a4);
      double v16 = v8 + v15 * (a2 - v8);
      double v17 = *(double *)(this + 72);
      double v18 = v17 + (a3 - v17) * v15;
      double v19 = v9 + v15 * (a4 - v9);
      double v20 = v18 / v19;
      if (v10 >= 0.0)
      {
        double v22 = v16 / v19;
        this = CA::ScanConverter::Path::add_line(this, v8 / v9, v17 / v9, v16 / v19, v18 / v19);
        *(double *)(v7 + 96) = v22;
        *(double *)(v7 + 104) = v20;
        *(unsigned char *)(v7 + 88) = 1;
        goto LABEL_14;
      }
      if (*(unsigned char *)(this + 88))
      {
        double v21 = v16 / v19;
        CA::ScanConverter::Path::add_line(this, *(double *)(this + 96), *(double *)(this + 104), v16 / v19, v18 / v19);
        *(unsigned char *)(v7 + 88) = 0;
      }
      else
      {
        *(unsigned char *)(this + 89) = 1;
        double v21 = v16 / v19;
        *(double *)(this + 112) = v16 / v19;
        *(double *)(this + 120) = v20;
      }
      double v13 = a2 / a4;
      double v14 = a3 / a4;
      this = v7;
      double v11 = v21;
      double v12 = v20;
    }
    else
    {
      double v11 = v8 / v9;
      double v12 = *(double *)(this + 72) / v9;
      double v13 = a2 / a4;
      double v14 = a3 / a4;
    }
    this = CA::ScanConverter::Path::add_line(this, v11, v12, v13, v14);
LABEL_14:
    *(double *)(v7 + 64) = a2;
    *(double *)(v7 + 72) = a3;
    *(double *)(v7 + 80) = a4;
  }
  return this;
}

uint64_t CA::ScanConverter::Path::add_curve(uint64_t this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  float v9 = a3;
  float v10 = a5;
  if (v10 <= v9) {
    return this;
  }
  uint64_t v13 = this;
  if (*(double *)(this + 184) < a3 || *(double *)(this + 168) > a5) {
    return this;
  }
  this = *(void *)(this + 16);
  if (this)
  {
    uint64_t v18 = *(void *)(this + 16);
    if (v18)
    {
      uint64_t v19 = *(void *)(this + 8);
      uint64_t v20 = v18 - 1;
LABEL_15:
      double v22 = (float *)(this + 24 * v19 + 24);
      *(void *)(this + 8) = v19 + 1;
      *(void *)(this + 16) = v20;
      ++*(void *)(v13 + 24);
      goto LABEL_16;
    }
  }
  this = *(void *)v13;
  if (*(void *)v13)
  {
    double v29 = a8;
    double v30 = a9;
    this = x_heap_malloc_small_((uint64_t *)this, 0x400uLL);
    if (this)
    {
      *(void *)this = 0;
      *(void *)(this + 8) = 0;
      *(void *)(this + 16) = 41;
      double v21 = *(void **)(v13 + 16);
      uint64_t v19 = 0;
      if (v21) {
        *double v21 = this;
      }
      else {
        *(void *)(v13 + 8) = this;
      }
      *(void *)(v13 + 16) = this;
      uint64_t v20 = 40;
      a8 = v29;
      a9 = v30;
      goto LABEL_15;
    }
    *(void *)uint64_t v13 = 0;
    double v22 = (float *)&CA::ScanConverter::CurveAccumulator::append(void)::fail;
    a8 = v29;
    a9 = v30;
  }
  else
  {
    double v22 = (float *)&CA::ScanConverter::CurveAccumulator::append(void)::fail;
  }
LABEL_16:
  float v23 = a2;
  float v24 = a4;
  float *v22 = v9;
  v22[1] = v10;
  float v25 = 0.0;
  BOOL v26 = v23 == v24;
  float v27 = 0.0;
  if (!v26)
  {
    float v25 = a6;
    float v27 = a7 + a6 * a3 * 2.0;
    float v23 = a8 + (a6 * a3 + a7) * a3;
  }
  v22[2] = v25;
  void v22[3] = v27;
  float v28 = a9;
  v22[4] = v23;
  v22[5] = v28;
  if (*(double *)(v13 + 128) > a2) {
    *(double *)(v13 + 128) = a2;
  }
  if (*(double *)(v13 + 136) > a3) {
    *(double *)(v13 + 136) = a3;
  }
  if (*(double *)(v13 + 144) < a4) {
    *(double *)(v13 + 144) = a4;
  }
  if (*(double *)(v13 + 152) < a5) {
    *(double *)(v13 + 152) = a5;
  }
  return this;
}

uint64_t CA::ScanConverter::Path::add_line(uint64_t this, double a2, double a3, double a4, double a5)
{
  if (a2 != a4 || a3 != a5)
  {
    double v6 = a2;
    if (vabdd_f64(a5, a3) >= 0.000001) {
      double v7 = a5;
    }
    else {
      double v7 = a3;
    }
    if (a2 >= a4) {
      a2 = a4;
    }
    if (v6 <= a4) {
      double v8 = a4;
    }
    else {
      double v8 = v6;
    }
    if (v7 <= a3) {
      double v9 = v7;
    }
    else {
      double v9 = a3;
    }
    if (v7 >= a3) {
      double v10 = v7;
    }
    else {
      double v10 = a3;
    }
    if (v7 == a3) {
      double v11 = 0.0;
    }
    else {
      double v11 = (a4 - v6) / (v7 - a3);
    }
    double v12 = a4 - v11 * v7;
    if (v7 >= a3) {
      double v13 = 1.0;
    }
    else {
      double v13 = -1.0;
    }
    return CA::ScanConverter::Path::add_curve(this, a2, v9, v8, v10, 0.0, v11, v12, v13);
  }
  return this;
}

uint64_t CA::ScanConverter::Path::cubeto(CA::ScanConverter::Path *this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, double a17)
{
  double v25 = *((double *)this + 8);
  double v26 = *((double *)this + 9);
  double v27 = *((double *)this + 10);
  *((double *)this + 8) = a8;
  *((double *)this + 9) = a9;
  *((double *)this + 10) = a17;
  if (a17 == 1.0 && a7 == 1.0 && a4 == 1.0 && v27 == 1.0)
  {
    return CA::ScanConverter::Path::add_cube((uint64_t)this, v25, v26, a2, a3, a5, a6, a8, a9);
  }
  else
  {
    double v32 = (a4 - a7) * a4 + (a7 - v27) * a7 + (v27 - a4) * a17;
    if (v32 < 0.0) {
      goto LABEL_16;
    }
    double v33 = a17 - v27 + (a4 - a7) * 3.0;
    double v34 = a4 + a4;
    double v35 = a7 - (a4 + a4) + v27;
    if (v33 == 0.0)
    {
      if (v35 == 0.0)
      {
        double v36 = 0.0;
        double v37 = 0.0;
      }
      else
      {
        double v36 = 2.0;
        double v37 = (v27 - a4) * 0.5 / v35;
      }
    }
    else if (v35 != 0.0 || (v36 = 0.0, double v37 = 0.0, v32 != 0.0))
    {
      double v38 = sqrt(v32);
      if (v35 < 0.0) {
        double v38 = -v38;
      }
      double v39 = v38 + v35;
      double v40 = -v39 / v33;
      double v41 = (v26 - a3) / v39;
      if (v40 >= v41) {
        double v37 = v41;
      }
      else {
        double v37 = v40;
      }
      if (v40 <= v41) {
        double v36 = v41;
      }
      else {
        double v36 = v40;
      }
    }
    double v42 = 2.0;
    if (v37 < 1.0e-10) {
      double v37 = v36;
    }
    else {
      double v42 = v36;
    }
    if (v37 < 1.0e-10 || v37 > 1.0)
    {
LABEL_16:
      v116.f64[1] = a9;
      v116.f64[0] = a8;
      return CA::ScanConverter::Path::add_cube_clip((uint64_t)this, v25, v26, v27, a2, a3, a4, a5, a6, a10, a11, a12, a13, a14, a15, a16, a7, v116, a17);
    }
    else if (1.0 - v42 >= 1.0e-10)
    {
      double v67 = 1.0 - v37;
      double v68 = (v42 - v37) / (1.0 - v37);
      double v69 = a9 - a6;
      double v70 = v25 + a2 * -2.0 + a5;
      double v71 = v26 + a3 * -2.0 + a6;
      double v72 = (a3 - v26) * 3.0 + (v71 * 3.0 + v37 * (a9 + (a6 - a3) * -3.0 - v26)) * v37;
      float64_t v73 = v25 + v37 * (a2 - v25);
      float64_t v74 = v26 + v37 * (a3 - v26);
      double v75 = v27 - v34 + a7;
      double v76 = a4 - v27 + a4 - v27 + v37 * v75;
      double v77 = v75 * 3.0 + v37 * (a17 + (a7 - a4) * -3.0 - v27);
      double v78 = v27 + v37 * (a4 - v27);
      float64_t v79 = v25 + (a2 - v25 + a2 - v25 + v37 * v70) * v37;
      float64_t v80 = v26 + (a3 - v26 + a3 - v26 + v37 * v71) * v37;
      double v81 = v27 + v76 * v37;
      double v82 = v25 + ((a2 - v25) * 3.0 + (v70 * 3.0 + v37 * (a8 + (a5 - a2) * -3.0 - v25)) * v37) * v37;
      float64_t v83 = v26 + v72 * v37;
      double v84 = v27 + ((a4 - v27) * 3.0 + v77 * v37) * v37;
      double v85 = a8 - a5 + a8 - a5;
      double v136 = -((v85 + v67 * (-(a2 + a5 * -2.0) - a8)) * v67);
      double v130 = -((v69 + v69 + v67 * (-(a3 + a6 * -2.0) - a9)) * v67);
      double v133 = a8 - (v85 + v67 * (-(a2 + a5 * -2.0) - a8)) * v67;
      double v86 = a17 - a7 + a17 - a7;
      double v126 = -((v86 + v67 * (-(a4 + a7 * -2.0) - a17)) * v67);
      double v128 = a9 - (v69 + v69 + v67 * (-(a3 + a6 * -2.0) - a9)) * v67;
      double v125 = a17 - (v86 + v67 * (-(a4 + a7 * -2.0) - a17)) * v67;
      double v124 = v67 * (a8 - a5);
      double v123 = v67 * (a9 - a6);
      double v122 = v67 * (a17 - a7);
      v119.f64[1] = v83;
      v119.f64[0] = v82;
      CA::ScanConverter::Path::add_cube_clip((uint64_t)this, v25, v26, v27, v73, v74, v78, v79, v80, a10, a11, a12, a13, a14, a15, a16, v81, v119, v84);
      double v87 = v82 + v133 * -2.0 + a8 - v124;
      float64_t v88 = v83 + v128 * -2.0 + a9 - v123;
      double v89 = (v133 - v82) * 3.0 + ((a8 - v82 + (v136 + v124) * 3.0) * v68 + v87 * 3.0) * v68;
      double v90 = v84 + v125 * -2.0 + a17 - v122;
      double v91 = v125 - v84 + v125 - v84 + v90 * v68;
      double v92 = (v125 - v84) * 3.0 + ((a17 - v84 + (v126 + v122) * 3.0) * v68 + v90 * 3.0) * v68;
      float64_t v93 = v82 + (v133 - v82) * v68;
      float64_t v94 = v83 + (v128 - v83) * v68;
      double v95 = v84 + (v125 - v84) * v68;
      float64_t v96 = v82 + (v133 - v82 + v133 - v82 + v87 * v68) * v68;
      float64_t v97 = v83 + (v128 - v83 + v128 - v83 + v88 * v68) * v68;
      double v98 = v84 + v91 * v68;
      double v99 = v82 + v89 * v68;
      float64_t v100 = v83 + ((v128 - v83) * 3.0 + ((a9 - v83 + (v130 + v123) * 3.0) * v68 + v88 * 3.0) * v68) * v68;
      double v127 = v84 + v92 * v68;
      float64_t v131 = a8 - (v124 + v124 + (-(a8 + (a8 - v124) * -2.0) - v133) * (1.0 - v68)) * (1.0 - v68);
      float64_t v134 = a9 - (v123 + v123 + (-(a9 + (a9 - v123) * -2.0) - v128) * (1.0 - v68)) * (1.0 - v68);
      double v141 = a17 - (v122 + v122 + (-(a17 + (a17 - v122) * -2.0) - v125) * (1.0 - v68)) * (1.0 - v68);
      float64_t v139 = a8 - (1.0 - v68) * v124;
      float64_t v137 = a9 - (1.0 - v68) * v123;
      double v129 = a17 - (1.0 - v68) * v122;
      v120.f64[1] = v100;
      float64_t v101 = v100;
      v120.f64[0] = v99;
      CA::ScanConverter::Path::add_cube_clip((uint64_t)this, v82, v83, v84, v93, v94, v95, v96, v97, v102, v103, v104, v105, v106, v107, v108, v98, v120, v127);
      v121.f64[1] = a9;
      v121.f64[0] = a8;
      return CA::ScanConverter::Path::add_cube_clip((uint64_t)this, v99, v101, v127, v131, v134, v141, v139, v137, v109, v110, v111, v112, v113, v114, v115, v129, v121, a17);
    }
    else
    {
      double v43 = a2 - v25;
      double v44 = a3 - v26;
      double v45 = v25 + a2 * -2.0 + a5;
      double v46 = v43 + v43 + v37 * v45;
      double v47 = (a2 - v25) * 3.0 + (v45 * 3.0 + v37 * (a8 + (a5 - a2) * -3.0 - v25)) * v37;
      double v48 = v26 + a3 * -2.0 + a6;
      double v49 = (a3 - v26) * 3.0 + (v48 * 3.0 + v37 * (a9 + (a6 - a3) * -3.0 - v26)) * v37;
      double v50 = v27 - v34 + a7;
      double v51 = -(a2 + a5 * -2.0);
      double v52 = -(a3 + a6 * -2.0);
      double v53 = a8 - a5;
      double v54 = a9 - a6;
      double v55 = v25 + v47 * v37;
      float64_t v56 = v26 + v49 * v37;
      double v57 = v27 + ((a4 - v27) * 3.0 + (v50 * 3.0 + v37 * (a17 + (a7 - a4) * -3.0 - v27)) * v37) * v37;
      float64_t v58 = a8 - (v53 + v53 + (1.0 - v37) * (v51 - a8)) * (1.0 - v37);
      float64_t v132 = a9 - (v54 + v54 + (1.0 - v37) * (v52 - a9)) * (1.0 - v37);
      double v135 = a17 - (a17 - a7 + a17 - a7 + (1.0 - v37) * (-(a4 + a7 * -2.0) - a17)) * (1.0 - v37);
      float64_t v138 = a8 - (1.0 - v37) * v53;
      float64_t v140 = a9 - (1.0 - v37) * v54;
      double v59 = a17 - (1.0 - v37) * (a17 - a7);
      v117.f64[1] = v56;
      v117.f64[0] = v55;
      CA::ScanConverter::Path::add_cube_clip((uint64_t)this, v25, v26, v27, v25 + v37 * v43, v26 + v37 * v44, v27 + v37 * (a4 - v27), v25 + v46 * v37, v26 + (v44 + v44 + v37 * v48) * v37, a10, a11, a12, a13, a14, a15, a16, v27 + (a4 - v27 + a4 - v27 + v37 * v50) * v37, v117, v57);
      v118.f64[1] = a9;
      v118.f64[0] = a8;
      return CA::ScanConverter::Path::add_cube_clip((uint64_t)this, v55, v56, v57, v58, v132, v135, v138, v140, v60, v61, v62, v63, v64, v65, v66, v59, v118, a17);
    }
  }
}

double *CA::ScanConverter::Path::closepath(double *this)
{
  uint8x8_t v1 = this;
  double v2 = this[5];
  if (this[8] != v2)
  {
    double v3 = this[6];
LABEL_5:
    double v4 = this[7];
    if (v4 == 1.0) {
      this = CA::ScanConverter::Path::lineto(this, v2, v3);
    }
    else {
      this = (double *)CA::ScanConverter::Path::lineto((uint64_t)this, v2, v3, v4);
    }
    goto LABEL_8;
  }
  double v3 = this[6];
  if (this[9] != v3 || this[10] != this[7]) {
    goto LABEL_5;
  }
LABEL_8:
  if (*((unsigned char *)v1 + 89) && *((unsigned char *)v1 + 88)) {
    this = (double *)CA::ScanConverter::Path::add_line((uint64_t)v1, v1[12], v1[13], v1[14], v1[15]);
  }
  *((_WORD *)v1 + 44) = 0;
  return this;
}

uint64_t CA::ScanConverter::Path::quadto(CA::ScanConverter::Path *this, double a2, double a3, double a4, double a5, double a6, double a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  return CA::ScanConverter::Path::cubeto(this, (*((double *)this + 8) + a2 + a2) * 0.333333333, (*((double *)this + 9) + a3 + a3) * 0.333333333, (*((double *)this + 10) + a4 + a4) * 0.333333333, (a2 + a2 + a5) * 0.333333333, (a3 + a3 + a6) * 0.333333333, (a4 + a4 + a7) * 0.333333333, a5, a6, a8, a9, a10, a11, a12, a13, a14, a7);
}

double *CA::ScanConverter::Path::lineto(double *this, double a2, double a3)
{
  if (this[10] != 1.0) {
    return (double *)CA::ScanConverter::Path::lineto((uint64_t)this, a2, a3, 1.0);
  }
  double v5 = this[8];
  double v6 = this[9];
  if (v5 != a2 || v6 != a3)
  {
    this[8] = a2;
    this[9] = a3;
    return (double *)CA::ScanConverter::Path::add_line((uint64_t)this, v5, v6, a2, a3);
  }
  return this;
}

void CA::OGL::Shape::fill_sc_path(uint64_t a1, float64x2_t *a2, int a3, char a4, unsigned __int8 a5, int32x2_t a6, int32x2_t a7)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  float64x2_t v9 = a2[8];
  float64x2_t v8 = a2[9];
  float64x2_t v10 = vsubq_f64(v8, v9);
  int64x2_t v11 = vceqzq_f64(v10);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v11, 1), (int8x16_t)v11).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v12 = vorrq_s8((int8x16_t)vcltzq_f64(v10), (int8x16_t)vcgezq_f64(v10)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v12), 1), v12).u64[0] & 0x8000000000000000) != 0))
  {
    int32x4_t v27 = 0uLL;
    v14.i64[0] = 0;
    int32x2_t v15 = 0;
  }
  else
  {
    int32x4_t v13 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v9, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    int32x4_t v14 = vuzp1q_s32(v13, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(v8, (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v13));
    int32x4_t v27 = v14;
    int32x2_t v15 = (int32x2_t)v14.u64[1];
  }
  double v29 = a2;
  float v28 = &unk_1ED02BA60;
  int v30 = a3;
  int v31 = a5;
  uint32x2_t v16 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v15);
  unsigned __int32 v17 = vpmax_u32(v16, v16).u32[0];
  if (a4)
  {
    if ((v17 & 0x80000000) != 0
      || (uint32x2_t v18 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, a7), (vpmax_u32(v18, v18).u32[0] & 0x80000000) != 0)
      || (uint32x2_t v19 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)v14.i8, v15), vadd_s32(a6, a7)), vmax_s32(*(int32x2_t *)v14.i8, a6))), (vpmax_u32(v19, v19).u32[0] & 0x80000000) != 0))
    {
      v26[0] = 0;
      v26[1] = 0;
      uint64_t v20 = (const CA::Bounds *)v26;
    }
    else
    {
      CA::OGL::Shape::render_path(a1);
      uint64_t v20 = (const CA::Bounds *)&v27;
    }
    CA::OGL::emit_bounds_surround(a1, v20);
  }
  else if ((v17 & 0x80000000) == 0)
  {
    uint32x2_t v21 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, a7);
    if ((vpmax_u32(v21, v21).u32[0] & 0x80000000) == 0)
    {
      int32x2_t v22 = vadd_s32(a6, a7);
      *(int32x2_t *)v23.i8 = vmax_s32(*(int32x2_t *)v14.i8, a6);
      int32x2_t v24 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)v14.i8, v15), v22), *(int32x2_t *)v23.i8);
      uint32x2_t v25 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v24);
      if ((vpmax_u32(v25, v25).u32[0] & 0x80000000) == 0)
      {
        v23.u64[1] = (unint64_t)v24;
        int32x4_t v27 = v23;
        CA::OGL::Shape::render_path(a1);
      }
    }
  }
}

uint64_t CA::ScanConverter::Path::add_cube_clip(uint64_t this, double a2, float64_t a3, double a4, float64_t a5, float64_t a6, double a7, float64_t a8, float64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, double a17, float64x2_t a18, double a19)
{
  uint64_t v19 = this;
  double v20 = a4 + -0.0001;
  double v21 = a19 + -0.0001;
  if (a4 + -0.0001 < 0.0 || v21 < 0.0)
  {
    if (v20 < 0.0 && v21 < 0.0) {
      return this;
    }
    int v32 = 0;
    double v33 = a7 - a4;
    double v34 = (a7 - a4) * 3.0;
    double v35 = (a17 - a7) * 3.0;
    double v36 = v35 - v34;
    double v37 = a19 - (v35 + a4);
    double v38 = v37 * 3.0;
    double v39 = a4 + -0.0001;
    double v40 = v34;
    double v41 = v36;
    while (2)
    {
      _D19 = 0.5;
      int v43 = 8;
      do
      {
        double v44 = v39 + (v40 + (v41 + _D19 * v37) * _D19) * _D19;
        if (fabs(v44) < 0.000001) {
          break;
        }
        double v45 = v40 + (v41 + v41 + _D19 * v38) * _D19;
        if (fabs(v45) < 0.000001)
        {
          double v48 = 0.0;
          double v49 = 1.0;
          _D19 = 0.5;
          do
          {
            double v50 = v20 + (v34 + (v36 + _D19 * v37) * _D19) * _D19;
            if (fabs(v50) < 0.000001) {
              break;
            }
            if (v50 <= 0.0) {
              double v49 = _D19;
            }
            else {
              double v48 = _D19;
            }
            _D19 = v48 + (v49 - v48) * 0.5;
          }
          while (v48 < v49);
          goto LABEL_26;
        }
        _D19 = _D19 - v44 / v45;
        --v43;
      }
      while (v43);
      if (_D19 >= 0.0 && _D19 <= 1.0)
      {
        if (!v32) {
          goto LABEL_26;
        }
      }
      else
      {
        double v47 = v41 + _D19 * v37;
        double v39 = v40 + v47 * _D19 - (v39 + (v40 + v47 * _D19) * _D19);
        ++v32;
        double v40 = v47;
        double v41 = v37;
        if (v32 != 4) {
          continue;
        }
      }
      break;
    }
    char v78 = 1;
    do
    {
      double v79 = v20 + (v34 + (v36 + _D19 * v37) * _D19) * _D19;
      if (fabs(v79) < 0.000001) {
        break;
      }
      double v80 = v34 + (v36 + v36 + _D19 * v38) * _D19;
      if (fabs(v80) < 0.000001) {
        break;
      }
      char v81 = v78;
      char v78 = 0;
      _D19 = _D19 - v79 / v80;
    }
    while ((v81 & 1) != 0);
LABEL_26:
    v51.f64[0] = a5;
    v51.f64[1] = a6;
    v52.f64[0] = a2;
    v52.f64[1] = a3;
    _Q22 = vsubq_f64(v51, v52);
    v54.f64[0] = a8;
    v54.f64[1] = a9;
    float64x2_t v55 = vsubq_f64(v51, v54);
    __asm { FMOV            V28.2D, #-2.0 }
    double v61 = a4 + a7 * -2.0 + a17;
    float64x2_t v62 = vaddq_f64(vmlaq_f64(v52, _Q28, v51), v54);
    __asm
    {
      FMOV            V26.2D, #3.0
      FMOV            V29.2D, #-3.0
    }
    float64x2_t v65 = vmlaq_n_f64(v52, vmlaq_n_f64(vmulq_f64(_Q22, _Q26), vmlaq_n_f64(vmulq_f64(v62, _Q26), vsubq_f64(a18, vmlaq_f64(v52, _Q29, v55)), _D19), _D19), _D19);
    double v66 = a4 + (v34 + (v61 * 3.0 + _D19 * v37) * _D19) * _D19;
    if (v20 >= 0.0)
    {
      __asm { FMOV            V4.2D, #2.0 }
      _Q4.f64[0] = _D19;
      double v76 = a4 + (v33 + v33 + _D19 * v61) * _D19;
      __asm { FMLA            D7, D19, V22.D[1] }
      uint64_t v83 = *(void *)&v66;
      float64x2_t v85 = v65;
      this = CA::ScanConverter::Path::add_cube(this, 1.0 / a4 * a2, 1.0 / a4 * a3, 1.0 / (a4 + _D19 * v33) * vmlad_n_f64(a2, _D19, _Q22.f64[0]), 1.0 / (a4 + _D19 * v33) * _D7, 1.0 / v76 * (a2 + vmlad_n_f64(_Q22.f64[0] + _Q22.f64[0], _D19, v62.f64[0]) * _D19), 1.0/ v76* (a3 + vaddvq_f64(vmulq_f64(_Q4, (float64x2_t)vzip2q_s64((int64x2_t)v62, (int64x2_t)_Q22))) * _D19), 1.0 / v66 * v65.f64[0], vmuld_lane_f64(1.0 / v66, v65, 1));
      *(float64x2_t *)(v19 + 96) = vdivq_f64(v85, (float64x2_t)vdupq_lane_s64(v83, 0));
      *(unsigned char *)(v19 + 88) = 1;
      return this;
    }
    double v67 = a18.f64[0]
        - (a18.f64[0] - a8 + a18.f64[0] - a8 + (1.0 - _D19) * (-(a5 + a8 * -2.0) - a18.f64[0])) * (1.0 - _D19);
    double v68 = a18.f64[1]
        - (a18.f64[1] - a9 + a18.f64[1] - a9 + (1.0 - _D19) * (-(a6 + a9 * -2.0) - a18.f64[1])) * (1.0 - _D19);
    double v69 = a19 - (a19 - a17 + a19 - a17 + (1.0 - _D19) * (-(a7 + a17 * -2.0) - a19)) * (1.0 - _D19);
    double v70 = a18.f64[0] - (1.0 - _D19) * (a18.f64[0] - a8);
    double v71 = a18.f64[1] - (1.0 - _D19) * (a18.f64[1] - a9);
    double v72 = a19 - (1.0 - _D19) * (a19 - a17);
    double v73 = v65.f64[1];
    double v74 = v65.f64[1] / v66;
    if (*(unsigned char *)(this + 88))
    {
      double v82 = v66;
      float64_t v84 = v65.f64[0];
      CA::ScanConverter::Path::add_line(this, *(double *)(this + 96), *(double *)(this + 104), v65.f64[0] / v66, v74);
      double v66 = v82;
      v65.f64[0] = v84;
      *(unsigned char *)(v19 + 88) = 0;
    }
    else
    {
      *(unsigned char *)(this + 89) = 1;
      *(double *)(this + 112) = v65.f64[0] / v66;
      *(double *)(this + 120) = v74;
    }
    double v24 = 1.0 / v66 * v65.f64[0];
    double v25 = 1.0 / v66 * v73;
    double v26 = 1.0 / v69 * v67;
    double v27 = 1.0 / v69 * v68;
    double v28 = 1.0 / v72 * v70;
    double v29 = 1.0 / v72 * v71;
    double v30 = 1.0 / a19 * a18.f64[0];
    double v31 = 1.0 / a19 * a18.f64[1];
  }
  else
  {
    double v22 = 1.0 / a4;
    double v23 = 1.0 / a7;
    double v24 = v22 * a2;
    double v25 = v22 * a3;
    double v26 = v23 * a5;
    double v27 = v23 * a6;
    double v28 = 1.0 / a17 * a8;
    double v29 = 1.0 / a17 * a9;
    double v30 = 1.0 / a19 * a18.f64[0];
    double v31 = 1.0 / a19 * a18.f64[1];
  }

  return CA::ScanConverter::Path::add_cube(v19, v24, v25, v26, v27, v28, v29, v30, v31);
}

double CA::OGL::MetalContext::bind_gaussian(CA::OGL::MetalContext *this, unsigned int a2, float *a3)
{
  uint64_t v6 = *((void *)this + 2);
  unsigned int v10 = CA::OGL::state_image_texture_unit(v6, a2);
  uint64_t texture = *((void *)this + 356);
  if (!texture)
  {
    uint64_t texture = CA::OGL::MetalContext::create_texture((id *)this, 1, 6uLL, (MTLPixelFormat)&CA::OGL::gaussian_data, (uint64_t)"gaussian_texture", v7, v8, v9);
    *((void *)this + 356) = texture;
    if (!texture) {
      return result;
    }
    uint64_t v6 = *((void *)this + 2);
  }
  *(_WORD *)(v6 + 2 * v10 + 144) = *(_DWORD *)(texture + 52);
  *(void *)(v6 + 8 * v10 + 176) = texture;
  *(unsigned char *)(v6 + a2 + 17) = *(unsigned char *)(texture + 55) & 0x3F;
  *(_OWORD *)(*((void *)this + 2) + 16 * a2 + 96) = xmmword_184997ED0;
  double result = 0.0078125;
  *(void *)a3 = 0x3F80000000000000;
  return result;
}

float CA::OGL::adjust_skipped_corner_vertices_simple(_OWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v5 = a3 * a3;
  uint64_t v6 = &a1[2 * a3 * a3];
  long long v7 = a1[1];
  *uint64_t v6 = *a1;
  v6[1] = v7;
  uint64_t v8 = a3 - 1;
  float64x2_t v9 = &a1[2 * a3 - 2];
  long long v10 = v9[1];
  v6[2] = *v9;
  v6[3] = v10;
  int64x2_t v11 = (_OWORD *)((char *)a1 + ((32 * a3 * a3) | 0x40));
  long long v12 = *(v6 - 1);
  *int64x2_t v11 = *(v6 - 2);
  v11[1] = v12;
  int32x4_t v13 = &a1[2 * (a3 - 1) * a3];
  long long v14 = v13[1];
  v6[6] = *v13;
  v6[7] = v14;
  uint64_t v15 = 48 * a3 * a3 + 64;
  uint64_t v16 = a2;
  unint64_t v17 = a4;
  do
  {
    uint64_t v18 = v16 + v15;
    *(_DWORD *)(v18 - 48) = *(_DWORD *)(v16 + 16);
    *(_DWORD *)uint64_t v18 = *(_DWORD *)(v16 + 48 * a3 - 32);
    *(_DWORD *)(v18 + 48) = *(_DWORD *)(v16 + v15 - 96);
    float result = *(float *)(v16 + 48 * a3 * (a3 - 1) + 16);
    *(float *)(v18 + 96) = result;
    v16 += 4;
    --v17;
  }
  while (v17);
  unint64_t v20 = (a5 >> 25) & 2;
  if ((a5 & 0x400000) != 0)
  {
    unint64_t v21 = a4 - v20;
    if (a4 > v20)
    {
      uint64_t v22 = a2 + 8 * ((a5 >> 26) & 1);
      do
      {
        *(_DWORD *)(v22 + 16) = *(_DWORD *)(v22 + 48 * a3 + 16);
        float result = *(float *)(v22 + 64);
        *(float *)(v22 + 48 * a3 * a3 + 16) = result;
        v22 += 4;
        --v21;
      }
      while (v21);
    }
  }
  if ((a5 & 0x800000) != 0)
  {
    unint64_t v23 = a4 - v20;
    if (a4 > v20)
    {
      uint64_t v24 = 8 * ((a5 >> 26) & 1);
      double v25 = (float *)(((48 * a3 * a3) & 0xFFFFFFFFFFFFFFF7 | (8 * ((a5 >> 26) & 1))) + a2 + 64);
      double v26 = (float *)((v24 | (96 * a3)) + a2 - 32);
      double v27 = (_DWORD *)((v24 & 0xF | (48 * a3)) + a2 - 80);
      do
      {
        v27[12] = *v27;
        float v28 = *v26++;
        float result = v28;
        *v25++ = v28;
        ++v27;
        --v23;
      }
      while (v23);
    }
  }
  if ((a5 & 0x2000000) != 0)
  {
    unint64_t v29 = a4 - v20;
    if (a4 > v20)
    {
      uint64_t v30 = 8 * ((a5 >> 26) & 1);
      double v31 = (int *)((v30 | (48 * a3 * v8)) + a2 - 32);
      uint64_t v32 = (v30 | (48 * v5)) + a2 - 80;
      do
      {
        int v33 = *v31++;
        *(_DWORD *)(v32 + 48) = v33;
        float result = *(float *)v32;
        *(_DWORD *)(v32 + 192) = *(_DWORD *)v32;
        v32 += 4;
        --v29;
      }
      while (v29);
    }
  }
  if ((a5 & 0x1000000) != 0)
  {
    BOOL v34 = a4 >= v20;
    unint64_t v35 = a4 - v20;
    if (v35 != 0 && v34)
    {
      uint64_t v36 = 8 * ((a5 >> 26) & 1);
      double v37 = (float *)((v36 | (48 * v5)) + a2 + 160);
      double v38 = (float *)((v36 | (48 * a3 * (a3 - 2))) + a2 + 16);
      double v39 = (_DWORD *)((v36 | (48 * a3 * v8)) + a2 + 64);
      do
      {
        *(v39 - 12) = *v39;
        float v40 = *v38++;
        float result = v40;
        *v37++ = v40;
        ++v39;
        --v35;
      }
      while (v35);
    }
  }
  return result;
}

_DWORD *CA::Bounds::subtract_exterior(_DWORD *this, const CA::Shape *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v2 = this[2];
  if (v2 >= this[3]) {
    int v2 = this[3];
  }
  if (v2 >= 1)
  {
    double v4 = this;
    if (a2)
    {
      if (a2 == (const CA::Shape *)1) {
        return this;
      }
    }
    else if (*((_DWORD *)a2 + 1) == 6)
    {
      return this;
    }
    memset(v10, 0, 48);
    CA::Shape::operator=((uint64_t)v10, this);
    bzero(&v8, 0x7F0uLL);
    long long v7 = xmmword_184998410;
    int v8 = 2;
    v6[0] = (int *)&v7;
    v6[1] = (int *)v9;
    v6[2] = (int *)v9;
    v6[3] = (int *)&v7 + 3;
    *(void *)&v9[2028] = v4;
    return (_DWORD *)CA::shape_subtract(v6, (uint64_t)v10, (uint64_t)a2, v5);
  }
  return this;
}

void CA::OGL::capture_backdrop(CA::OGL *a1, void *a2)
{
  double v3 = a1;
  uint64_t v508 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(*(void *)a1 + 248);
  if (BYTE5(xmmword_1EB2ACBF0))
  {
    uint64_t PerfHud = CA::OGL::GetPerfHud(a1);
    if (PerfHud) {
      ++*(void *)(PerfHud + 456);
    }
  }
  uint64_t v6 = *(uint64_t **)(a2[3] + 128);
  if (v6 && (uint64_t v7 = *v6) != 0)
  {
    if (*(unsigned char *)(v7 + 12) == 3) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(void *)(a2[2] + 256);
  if (v9)
  {
    long long v10 = (os_unfair_lock_s *)(v9 + 36);
    os_unfair_lock_lock((os_unfair_lock_t)(v9 + 36));
    uint64_t v11 = *(void *)(v9 + 40);
    if (!v11)
    {
LABEL_440:
      os_unfair_lock_unlock(v10);
      return;
    }
    uint64_t v451 = v5;
    long long v12 = (os_unfair_lock_s *)(v11 + 40);
    os_unfair_lock_lock((os_unfair_lock_t)(v11 + 40));
    int v13 = *(_DWORD *)(v8 + 12);
    if ((v13 & 0x1000) != 0)
    {
      uint64_t v15 = *(void *)(v11 + 64);
      uint64_t v14 = *(void *)(v11 + 72);
      if ((v13 & 0x400) == 0 && v14 - v15 == 168) {
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(v11 + 64);
      uint64_t v14 = *(void *)(v11 + 72);
    }
    uint64_t v450 = v8;
    if (v15 == v14) {
      goto LABEL_439;
    }
    int v16 = *(_DWORD *)(*((void *)v3 + 1) + 248);
    while (*(void *)v15 != *(void *)(v9 + 24) || v16 && *(_DWORD *)(v15 + 164) != v16)
    {
      v15 += 168;
      if (v15 == v14) {
        goto LABEL_439;
      }
    }
    if (*(unsigned char *)(v15 + 160) && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v4 + 184))(v4, 27))
    {
      uint64_t v18 = *(CA::Shape **)(v11 + 520);
      if (v18)
      {
        CA::Shape::unref(v18);
        *(void *)(v11 + 520) = 0;
      }
      *(_DWORD *)(v11 + 12) |= 0x800u;
      goto LABEL_439;
    }
    *(_DWORD *)(v11 + 12) &= ~0x800u;
    uint64_t v19 = *(void *)(v11 + 48);
    if (v19)
    {
      uint64_t v20 = *(void *)(v19 + 8);
      unint64_t v21 = v20 == v4 ? *(char **)(v11 + 48) : 0;
      if (v20 == v4) {
        goto LABEL_40;
      }
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    unint64_t v21 = (char *)malloc_type_zone_malloc(malloc_zone, 0xE0uLL, 0x8BB15036uLL);
    if (v21)
    {
      uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 96))(v4);
      *((void *)v21 + 1) = v4;
      *((void *)v21 + 2) = v23;
      *(void *)unint64_t v21 = &unk_1ED02B630;
      *(_OWORD *)(v21 + 24) = 0u;
      *(_OWORD *)(v21 + 40) = 0u;
      *((void *)v21 + 7) = 0;
      v21[216] &= 0xF8u;
      uint64_t v24 = *(char **)(v11 + 48);
      if (v24 != v21)
      {
        if (!v24) {
          goto LABEL_39;
        }
        goto LABEL_38;
      }
    }
    else
    {
      uint64_t v24 = *(char **)(v11 + 48);
      if (v24)
      {
LABEL_38:
        (*(void (**)(char *))(*(void *)v24 + 8))(v24);
LABEL_39:
        *(void *)(v11 + 48) = v21;
      }
    }
LABEL_40:
    *((void *)v21 + 2) = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 96))(v4);
    uint64_t v25 = *((void *)v3 + 1);
    int v26 = *(_DWORD *)(v25 + 248);
    v432 = (CA::OGL::Context *)v21;
    if (*((_DWORD *)v21 + 13) == v26)
    {
      int v27 = *(_DWORD *)(v25 + 264);
      if (*((_DWORD *)v21 + 14) == v27) {
        goto LABEL_439;
      }
    }
    else
    {
      int v27 = *(_DWORD *)(v25 + 264);
    }
    if (*(_DWORD *)(v11 + 436) == v26 && *(_DWORD *)(v11 + 440) == v27) {
      goto LABEL_439;
    }
    if (*(_DWORD *)(v11 + 432) != v26) {
      goto LABEL_439;
    }
    uint64_t v29 = *(void *)(v11 + 64);
    uint64_t v28 = *(void *)(v11 + 72);
    if (v28 == v29) {
      goto LABEL_439;
    }
    unint64_t v30 = (v28 - v29) / 168;
    unint64_t v31 = v30 - 1;
    uint64_t v32 = 168 * v30 - 168;
    unint64_t v33 = -1;
    do
    {
      if (*(void *)(v29 + v32) == *(void *)(v9 + 24)) {
        unint64_t v33 = v31;
      }
      --v31;
      v32 -= 168;
    }
    while (v31 != -1);
    if (v33 >= v30) {
      goto LABEL_439;
    }
    v421 = (os_unfair_lock_s *)(v9 + 36);
    unint64_t v34 = 0;
    *(_DWORD *)(v11 + 436) = v26;
    *(_DWORD *)(v11 + 440) = v27;
    unint64_t v35 = (float64x2_t *)(v29 + 168 * v33);
    *(float64x2_t *)(v11 + 448) = v35[1];
    int32x4_t v36 = (int32x4_t)v35[2];
    *(int32x4_t *)(v11 + 464) = v36;
    uint64_t v37 = 112;
    v36.i32[0] = 2139095040;
    float64x2_t v427 = v35[3];
    int32x4_t v429 = v36;
    float64x2_t v433 = v35[4];
    int32x4_t v435 = v36;
    int8x16_t v439 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    int8x16_t v443 = (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    v438 = v3;
    while (1)
    {
      uint64_t v38 = v29 + v37;
      float v39 = *(double *)(v29 + v37 - 96);
      float v40 = *(double *)(v29 + v37 - 88);
      float v41 = *(double *)(v29 + v37 - 80);
      float v42 = *(double *)(v29 + v37 - 72);
      *(float *)uint64_t v38 = v39;
      *(float *)(v38 + 4) = v40;
      float v43 = v41 + v39;
      *(float *)(v38 + 8) = v43;
      *(float *)(v38 + 12) = v40;
      float v44 = v42 + v40;
      *(float *)(v38 + 16) = v43;
      *(float *)(v38 + 20) = v44;
      *(float *)(v38 + 24) = v39;
      *(float *)(v38 + 28) = v44;
      if (v33 != v34) {
        break;
      }
LABEL_83:
      ++v34;
      v37 += 168;
      if (v34 >= 0xCF3CF3CF3CF3CF3DLL * ((v28 - v29) >> 3))
      {
        uint64_t v79 = *(void *)(v11 + 560);
        long long v10 = v421;
        if (v79)
        {
          uint64_t v80 = *(unsigned int *)(v79 + 16);
          if (v80)
          {
            uint64_t v81 = 0;
            uint64_t v82 = v79 + 24;
            while (1)
            {
              uint64_t v83 = *(void *)(v82 + 8 * v81);
              if (*(_DWORD *)(v83 + 24) == 247) {
                break;
              }
              if (v80 == ++v81) {
                goto LABEL_105;
              }
            }
            float64_t v84 = *(_DWORD **)(v83 + 40);
            memset(buf, 0, 32);
            CA::Render::KeyValueArray::get_rect_key((float64x2_t *)buf, (uint64_t)v84, (const Rect *)0x11D, (float64x2_t)0, (float64x2_t)0);
            double v85 = *(double *)&buf[16];
            if (*(double *)&buf[16] >= *(double *)&buf[24]) {
              double v85 = *(double *)&buf[24];
            }
            if (v85 > 0.0)
            {
              v444 = CA::Render::Array::new_array((CA::Render::Array *)v84[4], v84 + 6, (CA::Render::Object *const *)1, v84[3] >> 8);
              int8x16_t v498 = (int8x16_t)v427;
              float64x2_t v499 = vaddq_f64(v433, v427);
              double v87 = CA::Render::Vector::new_vector((CA::Render::Vector *)4, &v498, v86);
              CA::Render::KeyValueArray::set_key((CA::Render::KeyValueArray *)v444, 285, v87);
              if (atomic_fetch_add(v87 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v87 + 16))(v87);
              }
              float64_t v88 = CA::Render::Array::new_array((CA::Render::Array *)*(unsigned int *)(*(void *)(v11 + 560) + 16), (const void *)(*(void *)(v11 + 560) + 24), (CA::Render::Object *const *)1, *(_DWORD *)(*(void *)(v11 + 560) + 12) >> 8);
              double v89 = *(atomic_uint **)(v11 + 560);
              *(void *)(v11 + 560) = v88;
              if (v89 && atomic_fetch_add(v89 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v89 + 16))(v89);
              }
              *(void *)(*(void *)(v11 + 560) + 8 * v81 + 24) = CA::Render::Filter::copy_with_inputs((CA::Render::Filter *)v83, v444);
              if (atomic_fetch_add(v444 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v444 + 16))(v444);
              }
              if (atomic_fetch_add((atomic_uint *volatile)(v83 + 8), 0xFFFFFFFF) == 1) {
                (*(void (**)(uint64_t))(*(void *)v83 + 16))(v83);
              }
            }
          }
        }
LABEL_105:
        long long v12 = (os_unfair_lock_s *)(v11 + 40);
        if ((*((unsigned char *)v432 + 216) & 4) != 0) {
          goto LABEL_439;
        }
        double v90 = (CA::OGL::Context *)((char *)v432 + 64);
        CA::Transform::operator=((uint64_t)v432 + 64, *(void *)(v451 + 24));
        uint64_t v91 = a2[2];
        double v92 = *(CA::Mat4Impl **)(v91 + 56);
        if (v92)
        {
          uint64_t v507 = 0;
          long long v506 = 0u;
          long long v505 = 0u;
          long long v504 = 0u;
          long long v503 = 0u;
          long long v502 = 0u;
          long long v501 = 0u;
          long long v500 = 0u;
          float64x2_t v499 = 0u;
          int8x16_t v498 = 0u;
          CA::Transform::set((uint64_t)&v498, v92, 1);
          if ((v507 & 0x10) != 0)
          {
            v499.f64[0] = 0.0;
            *(void *)&long long v501 = 0;
            *(void *)&long long v503 = 0x3FF0000000000000;
            *(void *)&long long v505 = 0;
          }
          CA::Transform::concat_left(v90, (float64x2_t *)&v498, v93, v94);
        }
        else
        {
          CA::Transform::translate(v90, *(double *)(v91 + 64), *(double *)(v91 + 72), 0.0);
        }
        if (*(unsigned char *)(v15 + 161)) {
          goto LABEL_439;
        }
        uint64_t v497 = 0;
        long long v496 = 0u;
        long long v495 = 0u;
        long long v494 = 0u;
        long long v493 = 0u;
        long long v506 = 0u;
        long long v505 = 0u;
        long long v504 = 0u;
        long long v503 = 0u;
        long long v502 = 0u;
        long long v501 = 0u;
        long long v500 = 0u;
        float64x2_t v499 = 0u;
        int8x16_t v498 = 0u;
        char v468 = 0;
        if (v95)
        {
          int v428 = v95;
          uint64_t v97 = *((void *)v3 + 1);
          double v98 = v432;
          *((_DWORD *)v432 + 13) = *(_DWORD *)(v97 + 248);
          *((_DWORD *)v432 + 14) = *(_DWORD *)(v97 + 264);
          float v99 = fmax(fmin(*(float *)(v11 + 60), 1.0), 0.01);
          *((float *)v432 + 6) = v99;
          unsigned int v100 = *(_DWORD *)(v4 + 456);
          if (v100) {
            *((float *)v432 + 6) = 1.0 / (float)v100;
          }
          float64x2_t v101 = *(float64x2_t *)(v11 + 464);
          float64x2_t v466 = *(float64x2_t *)(v11 + 448);
          float64x2_t v467 = v101;
          CA::Rect::apply_transform((int8x16_t *)&v466, v90, v96);
          if ((*(_WORD *)(v451 + 68) & 0x100) != 0)
          {
            v105.i64[0] = *(void *)(v97 + 192);
            unint64_t v111 = *(void *)(v97 + 200);
            int v110 = v111;
            if ((int)v111 <= SHIDWORD(v111)) {
              int v110 = HIDWORD(v111);
            }
          }
          else
          {
            int8x16_t v105 = v498;
            int v106 = v498.i32[2];
            if (v498.i32[2] <= v498.i32[3]) {
              int v107 = v498.i32[3];
            }
            else {
              int v107 = v498.i32[2];
            }
            if (v498.i32[2] >= v498.i32[3]) {
              int v106 = v498.i32[3];
            }
            if (v107 <= 1073741822 && v106 >= 1)
            {
              *(int32x2_t *)v102.i8 = vadd_s32(*(int32x2_t *)v498.i8, (int32x2_t)0x100000001);
              v103.i64[0] = v102.i64[0];
              v103.u64[1] = (unint64_t)vadd_s32((int32x2_t)*(_OWORD *)&vextq_s8(v498, v498, 8uLL), (int32x2_t)0x100000001);
              if (v103.i32[3] < 1 || v103.i32[2] < 1) {
                unsigned int v109 = -1;
              }
              else {
                unsigned int v109 = 0;
              }
              int8x16_t v105 = vbslq_s8((int8x16_t)vdupq_n_s32(v109), v102, (int8x16_t)v103);
            }
            int v110 = v105.i32[2];
            if (v105.i32[2] <= v105.i32[3]) {
              int v110 = v105.i32[3];
            }
            unint64_t v111 = vextq_s8(v105, v105, 8uLL).u64[0];
          }
          v103.i32[0] = v110;
          v104.i32[0] = 1073741822;
          *(int32x4_t *)v445 = v104;
          v113.i64[0] = v105.i32[0];
          v113.i64[1] = v105.i32[1];
          int8x16_t v440 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
          float64x2_t v114 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v103, v104), 0), v440, (int8x16_t)vcvtq_f64_s64(v113));
          v113.i64[0] = (int)v111;
          v113.i64[1] = SHIDWORD(v111);
          int32x2_t v115 = vdup_n_s32(v110 > 1073741822);
          int8x16_t v116 = (int8x16_t)vcvtq_f64_s64(v113);
          v113.i64[0] = v115.u32[0];
          v113.i64[1] = v115.u32[1];
          v465[0] = v466;
          v465[1] = v467;
          CA::BoundsImpl::intersect((uint64_t)&v466, v114, (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v113, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v116));
          CA::OGL::Context::raster_round_rect((CA::OGL::Context *)buf, (const Rect *)v4, v466.f64);
          if (*(int *)&buf[8] <= *(int *)&buf[12]) {
            int v119 = *(_DWORD *)&buf[12];
          }
          else {
            int v119 = *(_DWORD *)&buf[8];
          }
          v118.i32[0] = v119;
          v120.i64[0] = *(int *)buf;
          v120.i64[1] = *(int *)&buf[4];
          int8x16_t v121 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v118, *(int32x4_t *)v445), 0), v440, (int8x16_t)vcvtq_f64_s64(v120));
          double v122 = 1.79769313e308;
          if (v119 <= 1073741822) {
            double v123 = (double)*(int *)&buf[8];
          }
          else {
            double v123 = 1.79769313e308;
          }
          if (v119 <= 1073741822) {
            double v122 = (double)*(int *)&buf[12];
          }
          float64x2_t v426 = (float64x2_t)v121;
          float64x2_t v466 = (float64x2_t)v121;
          v467.f64[0] = v123;
          v467.f64[1] = v122;
          float64x2_t v124 = v467;
          float v125 = *((float *)v432 + 6);
          double v126 = v125;
          if (v125 != 1.0 && v467.f64[0] < 1.79769313e308)
          {
            v466.f64[0] = v126 * *(double *)v121.i64;
            v467.f64[0] = v467.f64[0] * v126;
          }
          float64x2_t v420 = v124;
          float64_t v127 = v124.f64[1];
          double v423 = *(double *)&v121.i64[1];
          if (v125 != 1.0 && v124.f64[1] < 1.79769313e308)
          {
            v466.f64[1] = *(double *)&v121.i64[1] * v126;
            v467.f64[1] = v124.f64[1] * v126;
          }
          int8x16_t v464 = 0uLL;
          CA::Bounds::set_exterior((int32x4_t *)&v464, v117, v466, v467);
          memset(v463, 0, sizeof(v463));
          uint64_t v462 = 0;
          char v461 = 0;
          uint64_t v129 = a2[4];
          uint64_t v130 = v129 & 0x2000013C0;
          v132 = (v129 & 0x20) == 0 || (uint64_t v131 = *(void *)(a2[3] + 128)) == 0 || *(void *)(v131 + 80) == 0;
          int v136 = CA::Render::BackdropGroup::has_consistent_background_color(*(CA::Render::BackdropGroup **)(v11 + 64), *(void *)(v11 + 72)) & v132;
          int v430 = v136;
          if (v130) {
            int v136 = 0;
          }
          int v139 = v136 | v133;
          int v140 = v139 & v128;
          *((unsigned char *)v432 + 216) = *((unsigned char *)v432 + 216) & 0xFE | v139 & v128;
          if (!v461) {
            int v139 = 0;
          }
          int v418 = v140;
          int v414 = v139 & v140;
          if ((v139 & v140) == 1)
          {
            int v141 = v464.i32[3];
            if (v464.i32[2] <= v464.i32[3]) {
              int v142 = v464.i32[3];
            }
            else {
              int v142 = v464.i32[2];
            }
            if (v464.i32[2] < v464.i32[3]) {
              int v141 = v464.i32[2];
            }
            if (v142 <= 1073741822 && v141 >= 1)
            {
              v137.i64[1] = v464.i64[1];
              int8x16_t v464 = (int8x16_t)vaddq_s32((int32x4_t)v464, (int32x4_t)xmmword_184997F10);
              int32x2_t v143 = vcgt_s32((int32x2_t)0x100000001, vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8(v464, v464, 8uLL)));
              if ((v143.i32[1] | v143.i32[0])) {
                v464.i64[1] = 0;
              }
            }
          }
          int v144 = *(_DWORD *)(v450 + 12);
          uint64_t v145 = v464.i64[1];
          int32x4_t v460 = (int32x4_t)v464;
          int v146 = *(_DWORD *)(v450 + 12);
          double v413 = v127;
          *(int8x16_t *)v446 = v464;
          if ((v146 & 0x10000) != 0)
          {
            CA::OGL::Context::raster_round_rect((CA::OGL::Context *)buf, (const Rect *)v4, (double *)v465);
            v357.i32[1] = *(_DWORD *)&buf[12];
            int v358 = *(_DWORD *)&buf[12];
            v359.i64[0] = *(int *)buf;
            v359.i64[1] = *(int *)&buf[4];
            int64x2_t v360 = v359;
            v359.i64[0] = *(int *)&buf[8];
            v359.i64[1] = *(int *)&buf[12];
            int64x2_t v361 = v359;
            if (*(int *)&buf[8] > *(int *)&buf[12]) {
              int v358 = *(_DWORD *)&buf[8];
            }
            v357.i32[0] = v358;
            v356.i32[0] = 1073741822;
            int8x16_t v362 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v357, v356), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v360));
            int8x16_t v363 = (int8x16_t)vcvtq_f64_s64(v361);
            int32x2_t v364 = vdup_n_s32(v358 > 1073741822);
            v365.i64[0] = v364.u32[0];
            v365.i64[1] = v364.u32[1];
            int8x16_t v366 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v365, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v363);
            float v367 = *((float *)v432 + 6);
            double v368 = v367;
            BOOL v369 = *(double *)v366.i64 >= 1.79769313e308 || v367 == 1.0;
            v370.i64[1] = v362.i64[1];
            v371.i64[1] = v366.i64[1];
            if (v369) {
              unint64_t v372 = 0;
            }
            else {
              unint64_t v372 = -1;
            }
            int8x16_t v373 = (int8x16_t)vdupq_n_s64(v372);
            *(double *)v370.i64 = v368 * *(double *)v362.i64;
            float64x2_t v374 = (float64x2_t)vbslq_s8(v373, v370, v362);
            *(double *)v371.i64 = v368 * *(double *)v366.i64;
            float64x2_t v375 = (float64x2_t)vbslq_s8(v373, v371, v366);
            if (v367 != 1.0 && v375.f64[1] < 1.79769313e308)
            {
              v374.f64[1] = vmuld_lane_f64(v368, v374, 1);
              v375.f64[1] = v375.f64[1] * v368;
            }
            CA::Bounds::set_exterior(&v460, v355, v374, v375);
            if (v414)
            {
              int v376 = v460.i32[3];
              if (v460.i32[2] <= v460.i32[3]) {
                int v377 = v460.i32[3];
              }
              else {
                int v377 = v460.i32[2];
              }
              if (v460.i32[2] < v460.i32[3]) {
                int v376 = v460.i32[2];
              }
              if (v377 <= 1073741822 && v376 >= 1)
              {
                v137.i64[1] = v460.i64[1];
                int32x4_t v460 = vaddq_s32(v460, (int32x4_t)xmmword_184997F10);
                int32x2_t v378 = vcgt_s32((int32x2_t)0x100000001, vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v460, (int8x16_t)v460, 8uLL)));
                if ((v378.i32[1] | v378.i32[0])) {
                  v460.i64[1] = 0;
                }
              }
            }
            long long v10 = v421;
            double v98 = v432;
            uint64_t v145 = (uint64_t)v446[1];
            double v3 = v438;
            if ((*(_DWORD *)(v450 + 12) & 0x20000) != 0) {
              goto LABEL_464;
            }
          }
          else
          {
            if ((v146 & 0x20000) == 0) {
              goto LABEL_173;
            }
LABEL_464:
            uint64_t v379 = *((void *)v3 + 1);
            uint64_t v380 = *(void *)(v379 + 192);
            v137.i64[0] = *(void *)(v379 + 200);
            int v381 = v137.i32[1];
            v382.i64[0] = (int)v380;
            v382.i64[1] = SHIDWORD(v380);
            int64x2_t v383 = v382;
            v382.i64[0] = v137.i32[0];
            v382.i64[1] = v137.i32[1];
            int64x2_t v384 = v382;
            if (v137.i32[0] > v137.i32[1]) {
              int v381 = v137.i32[0];
            }
            v137.i32[0] = v381;
            v138.i32[0] = 1073741822;
            int8x16_t v385 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v137, v138), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v383));
            int8x16_t v386 = (int8x16_t)vcvtq_f64_s64(v384);
            int32x2_t v387 = vdup_n_s32(v381 > 1073741822);
            v388.i64[0] = v387.u32[0];
            v388.i64[1] = v387.u32[1];
            int8x16_t v389 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v388, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v386);
            float v390 = *((float *)v98 + 6);
            double v391 = v390;
            BOOL v392 = *(double *)v389.i64 >= 1.79769313e308 || v390 == 1.0;
            v393.i64[1] = v385.i64[1];
            v394.i64[1] = v389.i64[1];
            if (v392) {
              unint64_t v395 = 0;
            }
            else {
              unint64_t v395 = -1;
            }
            int8x16_t v396 = (int8x16_t)vdupq_n_s64(v395);
            *(double *)v393.i64 = v391 * *(double *)v385.i64;
            float64x2_t v397 = (float64x2_t)vbslq_s8(v396, v393, v385);
            *(double *)v394.i64 = v391 * *(double *)v389.i64;
            float64x2_t v398 = (float64x2_t)vbslq_s8(v396, v394, v389);
            if (v390 != 1.0 && v398.f64[1] < 1.79769313e308)
            {
              v397.f64[1] = vmuld_lane_f64(v391, v397, 1);
              v398.f64[1] = v398.f64[1] * v391;
            }
            CA::Bounds::set_exterior(&v460, v134, v397, v398);
            long long v10 = v421;
            double v98 = v432;
            uint64_t v145 = (uint64_t)v446[1];
            double v3 = v438;
            if (v414)
            {
              int v399 = v460.i32[3];
              if (v460.i32[2] <= v460.i32[3]) {
                int v400 = v460.i32[3];
              }
              else {
                int v400 = v460.i32[2];
              }
              if (v460.i32[2] < v460.i32[3]) {
                int v399 = v460.i32[2];
              }
              if (v400 <= 1073741822 && v399 >= 1)
              {
                int32x4_t v460 = vaddq_s32(v460, (int32x4_t)xmmword_184997F10);
                int32x2_t v401 = vcgt_s32((int32x2_t)0x100000001, vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v460, (int8x16_t)v460, 8uLL)));
                if ((v401.i32[1] | v401.i32[0])) {
                  v460.i64[1] = 0;
                }
              }
            }
          }
LABEL_173:
          int v147 = v145;
          int v148 = HIDWORD(v145);
          uint64_t v149 = *((void *)v98 + 4);
          if (v149 && *(void *)(v149 + 40) != v145) {
          if (v147 >= v148)
          }
            int v150 = v148;
          else {
            int v150 = v147;
          }
          if (v150 < 1) {
            goto LABEL_438;
          }
          int v151 = v144 & 0x2000;
          int v152 = BYTE7(xmmword_1EB2ACC10);
          int v153 = *(_DWORD *)(*((void *)v3 + 1) + 268) & 0x38000;
          uint64_t v154 = *((void *)v98 + 4);
          if (v154)
          {
            if ((v153 != 0) != (*(unsigned char *)(v11 + 569) != 0)
              || (uint64_t v155 = *(void *)(v154 + 48), v155 != (*(uint64_t (**)(uint64_t))(*(void *)v4 + 96))(v4)))
            {
            }
          }
          if (v153) {
            int v156 = 1055;
          }
          else {
            int v156 = 1039;
          }
          int v412 = v151;
          uint64_t v157 = v156 | (8 * v151);
          uint64_t v158 = *(void *)(v11 + 560);
          if (v158)
          {
            uint64_t v159 = *(unsigned int *)(v158 + 16);
            if (v159)
            {
              uint64_t v160 = v158 + 24;
              uint64_t v161 = 8 * v159;
              while (*(_DWORD *)(*(void *)v160 + 24) != 50)
              {
                v160 += 8;
                v161 -= 8;
                if (!v161) {
                  goto LABEL_194;
                }
              }
              uint64_t v157 = v157 | 0x40040;
            }
          }
LABEL_194:
          uint64_t v162 = *((void *)v98 + 4);
          if (v162)
          {
            if (*((_DWORD *)v98 + 12) == v157)
            {
              *((_DWORD *)v98 + 12) = v157;
LABEL_199:
              if (*(_DWORD *)(v162 + 32) != LODWORD(v446[0])
                || (BOOL v163 = v152 != 0, *(_DWORD *)(v162 + 36) != HIDWORD(v446[0])))
              {
                *(CA::Render::KeyValueArray **)(v162 + 32) = v446[0];
                goto LABEL_204;
              }
              goto LABEL_205;
            }
            uint64_t v162 = *((void *)v98 + 4);
            *((_DWORD *)v98 + 12) = v157;
            if (v162) {
              goto LABEL_199;
            }
          }
          else
          {
            *((_DWORD *)v98 + 12) = v157;
          }
          uint64_t v164 = (*(uint64_t (**)(uint64_t, uint64_t, int32x4_t *, uint64_t))(*(void *)v4 + 656))(v4, 1, &v460, v157);
          *((void *)v98 + 4) = v164;
          if (!v164) {
            goto LABEL_438;
          }
          *(unsigned char *)(v11 + 569) = v153 != 0;
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v4 + 704))(v4, v164, 16, 16);
          *(_OWORD *)(*((void *)v98 + 4) + 32) = *(_OWORD *)v446;
LABEL_204:
          BOOL v163 = 1;
LABEL_205:
          float16x4_t v165 = vcvt_f16_f32(*(float32x4_t *)(a2[3] + 16));
          __int16 v166 = v165.i16[0];
          __int16 v167 = v165.i16[1];
          __int16 v168 = v165.i16[2];
          LODWORD(v169) = v165.u16[3];
          if (v430)
          {
            float16x4_t v170 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(*(float16x4_t *)(v451 + 32)), vcvtq_f32_f16(v165)));
            if (*(void *)(v451 + 32) == 0x3C003C003C003C00) {
              uint64_t v169 = v169;
            }
            else {
              uint64_t v169 = v170.u16[3];
            }
            if (*(void *)(v451 + 32) != 0x3C003C003C003C00)
            {
              __int16 v168 = v170.i16[2];
              __int16 v167 = v170.i16[1];
              __int16 v166 = v170.i16[0];
            }
            unsigned __int16 v410 = v166;
            unsigned __int16 v411 = v167;
            unsigned __int16 v409 = v168;
            uint64_t v408 = v169;
            if (v163)
            {
              char v171 = *((unsigned char *)v98 + 216) | 2;
              goto LABEL_221;
            }
            long long v492 = 0u;
            long long v490 = 0u;
            long long v491 = 0u;
            if ((*(_WORD *)(v451 + 68) & 0x100) == 0)
            {
LABEL_218:
              char v172 = 0;
              if (*(void *)(v11 + 520)) {
                goto LABEL_219;
              }
              uint64_t v173 = 0;
              long long v10 = v421;
              double v98 = v432;
LABEL_233:
              uint64_t v174 = 0;
              int v418 = 0;
              *((unsigned char *)v98 + 216) &= ~1u;
              char v177 = 1;
              goto LABEL_234;
            }
LABEL_227:
            char v172 = 0;
            v175 = (uint64_t *)(v11 + 520);
LABEL_228:
            uint64_t v173 = *v175;
            v176 = *(CA::Shape **)(v11 + 480);
            if (!v176) {
              goto LABEL_233;
            }
            *(void *)&uint8_t buf[8] = 0;
            *(void *)buf = 0;
            CA::Bounds::set_exterior((int32x4_t *)buf, v134, v426, v420);
            uint64_t v174 = (CA::Shape *)CA::Shape::intersect(v176, (const CA::Bounds *)buf);
LABEL_230:
            if (!v174) {
              goto LABEL_233;
            }
            char v177 = 0;
LABEL_234:
            if (v173)
            {
              if (v173)
              {
                if (v173 == 1) {
                  goto LABEL_434;
                }
              }
              else if (*(_DWORD *)(v173 + 4) == 6)
              {
                goto LABEL_434;
              }
              v417 = (CA::OGL::Context *)v173;
              char v407 = v177;
              v415 = v174;
              uint64_t v459 = 0;
              uint64_t v458 = 0;
              int32x4_t v178 = (int32x4_t)0x3C003C003C003C00uLL;
              uint64_t v485 = 0x3C003C003C003C00;
              uint64_t v487 = 0;
              uint64_t v486 = 0;
              uint64_t v488 = 0;
              v178.i32[1] = 0;
              v483[0] = 0;
              long long v484 = 0u;
              uint64_t v489 = 0x4013F800000;
              v483[1] = &CA::Shape::_infinite_shape;
              long long v457 = 0uLL;
              if (*(unsigned char *)(v451 + 69))
              {
                uint64_t v459 = 1;
                uint64_t v458 = 1;
                int32x4_t v456 = 0uLL;
                v482[2] = 0;
                v178.i32[0] = 1073741822;
                int32x4_t v436 = v178;
                v482[0] = v173;
                v482[1] = 0;
                int8x16_t v434 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
                while (CA::ShapeIterator::iterate(v482, (int *)&v457))
                {
                  if (SDWORD2(v457) <= SHIDWORD(v457)) {
                    int v180 = HIDWORD(v457);
                  }
                  else {
                    int v180 = DWORD2(v457);
                  }
                  v179.i32[0] = v180;
                  v181.i64[0] = (int)v457;
                  v181.i64[1] = SDWORD1(v457);
                  int8x16_t v182 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v179, v436), 0), v434, (int8x16_t)vcvtq_f64_s64(v181));
                  double v183 = (double)SDWORD2(v457);
                  double v184 = (double)SHIDWORD(v457);
                  if (v180 > 1073741822)
                  {
                    double v183 = 1.79769313e308;
                    double v184 = 1.79769313e308;
                  }
                  *(int8x16_t *)buf = v182;
                  *(double *)&buf[16] = v183;
                  *(double *)&buf[24] = v184;
                  double v185 = (float)-*(float *)&v462;
                  double v186 = (float)-*((float *)&v462 + 1);
                  CA::BoundsImpl::inset((double *)buf, v185, v186);
                  float64x2_t v441 = *(float64x2_t *)&buf[16];
                  *(_OWORD *)v447 = *(_OWORD *)buf;
                  float64x2_t v480 = *(float64x2_t *)buf;
                  float64x2_t v481 = *(float64x2_t *)&buf[16];
                  CA::BoundsImpl::intersect((uint64_t)&v480, v426, v420);
                  float v187 = *((float *)v98 + 6);
                  if (v187 != 1.0)
                  {
                    double v188 = v187;
                    if (v481.f64[0] < 1.79769313e308)
                    {
                      v480.f64[0] = v480.f64[0] * v188;
                      v481.f64[0] = v481.f64[0] * v188;
                    }
                    if (v481.f64[1] < 1.79769313e308)
                    {
                      v480.f64[1] = v480.f64[1] * v188;
                      v481.f64[1] = v481.f64[1] * v188;
                    }
                  }
                  float64x2_t v454 = *(float64x2_t *)v447;
                  float64x2_t v455 = v441;
                  CA::BoundsImpl::inset(v454.f64, v185, v186);
                  CA::BoundsImpl::intersect((uint64_t)&v454, v426, v420);
                  float v190 = *((float *)v98 + 6);
                  if (v190 != 1.0)
                  {
                    double v191 = v190;
                    if (v455.f64[0] < 1.79769313e308)
                    {
                      v454.f64[0] = v454.f64[0] * v191;
                      v455.f64[0] = v455.f64[0] * v191;
                    }
                    if (v455.f64[1] < 1.79769313e308)
                    {
                      v454.f64[1] = v454.f64[1] * v191;
                      v455.f64[1] = v455.f64[1] * v191;
                    }
                  }
                  CA::Bounds::set_exterior(&v456, v189, v480, v481);
                  CA::shape_union((CA::Shape **)&v459, (CA::Shape **)&v456, v192);
                  CA::Bounds::set_exterior(&v456, v193, v454, v455);
                  CA::shape_union((CA::Shape **)&v458, (CA::Shape **)&v456, v194);
                }
                v179.i32[0] = *((_DWORD *)v98 + 6);
                v195 = (CA::Shape *)CA::Shape::scale_and_dilate(v415, *(float32x2_t *)v179.i8, *(float32_t *)v179.i32, 1u, 1u);
                CA::shape_intersect((CA *)&v459, (uint64_t)v195, v196);
                CA::shape_intersect((CA *)&v458, (uint64_t)v195, v197);
                CA::Shape::unref(v195);
              }
              v483[0] = CA::OGL::Context::set_gstate(v4, (uint64_t)v483);
              CA::OGL::Context::push_surface(v4, *((void *)v98 + 4), (*(_WORD *)(*((void *)v98 + 4) + 75) & 0x80) == 0, 8, 0);
              unsigned int v416 = *((float *)v98 + 6) != 1.0;
              uint64_t v199 = *(void *)(v4 + 16);
              int v404 = *(unsigned __int8 *)(v4 + 64);
              char v405 = *(unsigned char *)(v199 + 481);
              char v406 = *(unsigned char *)(v199 + 480);
              LOBYTE(v454.f64[0]) = 0;
              *(unsigned char *)(v199 + 481) = v405 & 0xFE;
              uint64_t v200 = *(void *)(v4 + 192);
              if (!v200 || (*(_DWORD *)(*((void *)v438 + 1) + 1084) & 4) != 0 || v468)
              {
                *(unsigned char *)(v4 + 64) = 0;
              }
              else
              {
                *(void *)&buf[64] = 0;
                memset(&buf[32], 0, 32);
                *(_OWORD *)&buf[16] = 0u;
                *(void *)buf = v4;
                *(void *)&uint8_t buf[8] = v173;
                *(_DWORD *)&buf[16] = *((_DWORD *)v98 + 6);
                *(float64x2_t *)&buf[24] = v426;
                *(float64x2_t *)&buf[40] = v420;
                *(void *)&buf[64] = &v454;
                int v201 = LOBYTE(v454.f64[0]);
                *(unsigned char *)(v4 + 64) = 0;
                BOOL v336 = v201 == 0;
                int v202 = v418;
                if (v336) {
                  int v202 = 0;
                }
                if (v202 == 1 && !v461) {
                  *((unsigned char *)v98 + 216) &= ~1u;
                }
              }
              if (v172)
              {
                char v203 = *((unsigned char *)v98 + 216);
                if (!(((unint64_t)v409 << 32) | (v408 << 48) | ((unint64_t)v411 << 16) | v410))
                {
                  if (v430) {
                    char v204 = 2;
                  }
                  else {
                    char v204 = 0;
                  }
                  char v203 = v203 & 0xFD | v204;
                  *((unsigned char *)v98 + 216) = v203;
                }
              }
              else
              {
                char v203 = *((unsigned char *)v98 + 216);
              }
              if ((v203 & 2) == 0)
              {
                unsigned __int16 v410 = 0;
                unsigned __int16 v411 = 0;
                unsigned __int16 v409 = 0;
                uint64_t v408 = 0;
              }
              if (v412)
              {
                *(unsigned char *)(*(void *)(v4 + 16) + 481) |= 2u;
                *(_DWORD *)(*(void *)(v4 + 16) + 352) = 1065353216;
              }
              v205 = v432;
              uint64_t v206 = v173;
              if (v428 >= 1)
              {
                uint64_t v431 = v4 + 834;
                *(void *)&double v425 = *(_OWORD *)&vaddq_f64(v420, v426);
                double v424 = v413 + v426.f64[1];
                float v207 = 1.0;
                uint64_t v208 = (v428 - 1);
                do
                {
                  if (LOBYTE(v454.f64[0])) {
                    BOOL v209 = 1;
                  }
                  else {
                    BOOL v209 = v208 < (v428 - 1);
                  }
                  if (v209)
                  {
                    *(unsigned char *)(*(void *)(v4 + 16) + 481) |= 1u;
                    *(unsigned char *)(*(void *)(v4 + 16) + 480) = 3;
                  }
                  uint64_t v210 = *((void *)&v493 + v208);
                  if (v210)
                  {
                    CA::OGL::Context::bind_surface(v4, *((void *)&v493 + v208), 0, v416, v416, -16.0);
                  }
                  else
                  {
                    uint64_t v211 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 1072))(v4);
                    if (v211) {
                      (*(void (**)(uint64_t, void, void, void))(*(void *)v211 + 1168))(v211, 0, v416, v416);
                    }
                  }
                  float v212 = *((float *)v205 + 6);
                  if (v212 >= 0.5)
                  {
                    *(unsigned char *)(*(void *)(v4 + 16) + 16) = 1;
                  }
                  else if (v212 >= 0.25)
                  {
                    float v217 = sqrtf(fminf((float)(v212 * -4.0) + 2.0, v207));
                    uint64_t v218 = *(void *)(v4 + 16);
                    float v219 = *(float *)(v218 + 96);
                    float v220 = *(float *)(v218 + 100);
                    *(float *)buf = -(float)(v217 * v219);
                    *(float *)&uint8_t buf[4] = v220 * v217;
                    *(float *)&uint8_t buf[8] = v219 * v217;
                    *(float *)&buf[12] = v220 * v217;
                    *(float *)&buf[16] = *(float *)buf;
                    *(float *)&buf[20] = -(float)(v217 * v220);
                    *(float *)&buf[24] = v219 * v217;
                    *(float *)&buf[28] = *(float *)&buf[20];
                    *(unsigned char *)(v218 + 16) = 26;
                    (*(void (**)(uint64_t, void, uint64_t, uint64_t, unsigned char *))(*(void *)v4 + 1000))(v4, 0, 2, 4, buf);
                    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v4 + 1000))(v4, 1, 4, 1, &CA::OGL::capture_backdrop(CA::OGL::Renderer &,CA::OGL::Layer const*)::weight);
                  }
                  else
                  {
                    *(unsigned char *)(*(void *)(v4 + 16) + 16) = 28;
                    float v213 = (float)(sqrtf(fminf((float)(*((float *)v205 + 6) * -8.0) + 2.0, v207)) * 0.5) + 0.5;
                    uint64_t v214 = *(void *)(v4 + 16);
                    float v215 = v213 * *(float *)(v214 + 96);
                    float v216 = v213 * *(float *)(v214 + 100);
                    *(float *)buf = v215;
                    *(float *)&uint8_t buf[4] = v216;
                    *(float *)&uint8_t buf[8] = v215;
                    *(float *)&buf[12] = v216 * 3.0;
                    *(float *)&buf[16] = v215 * 3.0;
                    *(float *)&buf[20] = v216;
                    *(float *)&buf[24] = v215 * 3.0;
                    *(float *)&buf[28] = v216 * 3.0;
                    (*(void (**)(uint64_t, void, uint64_t, uint64_t, unsigned char *))(*(void *)v4 + 1000))(v4, 0, 2, 4, buf);
                  }
                  v221 = (int32x2_t *)(&v498 + v208);
                  int v222 = v418;
                  if (v461) {
                    int v222 = 0;
                  }
                  if (v222 == 1)
                  {
                    float v223 = *((float *)v205 + 6);
                    uint64_t v453 = 0;
                  }
                  uint64_t v419 = v208;
                  uint64_t v437 = v210;
                  if (byte_1EB2ACBEA)
                  {
                    uint64_t v276 = *(void *)(v11 + 480);
                    float64x2_t v480 = 0uLL;
                    CA::Shape::get_bounds(v276, (int *)&v480);
                    if (x_log_hook_p())
                    {
                      x_log_();
                    }
                    else
                    {
                      v277 = x_log_category_ogl;
                      if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v278 = *(void *)(v450 + 16);
                        int v279 = *((_DWORD *)v432 + 13);
                        uint64_t v280 = *(void *)(v11 + 32);
                        v281 = (const char *)(v280 + 28);
                        BOOL v336 = v280 == 0;
                        v282 = "";
                        if (!v336) {
                          v282 = v281;
                        }
                        unint64_t v283 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(void *)(v11 + 72) - *(void *)(v11 + 64)) >> 3);
                        v284 = (_DWORD *)*((void *)v432 + 4);
                        int v286 = v284[8];
                        int v285 = v284[9];
                        int v287 = v284[10];
                        LODWORD(v284) = v284[11];
                        double v288 = *((float *)v432 + 6);
                        *(_DWORD *)buf = 134221314;
                        *(void *)&uint8_t buf[4] = v278;
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v279;
                        *(_WORD *)&buf[18] = 2048;
                        *(void *)&buf[20] = v11;
                        *(_WORD *)&buf[28] = 2080;
                        *(void *)&buf[30] = v282;
                        *(_WORD *)&buf[38] = 2048;
                        *(void *)&buf[40] = v283;
                        *(_WORD *)&buf[48] = 1024;
                        *(_DWORD *)&buf[50] = LODWORD(v480.f64[0]);
                        *(_WORD *)&buf[54] = 1024;
                        *(_DWORD *)&buf[56] = HIDWORD(v480.f64[0]);
                        *(_WORD *)&buf[60] = 1024;
                        *(_DWORD *)&buf[62] = LODWORD(v480.f64[1]);
                        *(_WORD *)&buf[66] = 1024;
                        *(_DWORD *)&buf[68] = HIDWORD(v480.f64[1]);
                        __int16 v470 = 1024;
                        int v471 = v286;
                        __int16 v472 = 1024;
                        int v473 = v285;
                        __int16 v474 = 1024;
                        int v475 = v287;
                        __int16 v476 = 1024;
                        int v477 = (int)v284;
                        __int16 v478 = 2048;
                        double v479 = v288;
                        _os_log_impl(&dword_184668000, v277, OS_LOG_TYPE_DEFAULT, "backdrop 0x%lx; update %d; group %p \"%s\" size %zu; [%d %d; %d x %d]:\n"
                          "  copying to surface [%d %d; %d x %d] scale %g:\n",
                          buf,
                          0x6Au);
                      }
                    }
                    v205 = v432;
                    uint64_t v206 = (uint64_t)v417;
                    float v207 = 1.0;
                  }
                  *(void *)(v4 + 128) = 0;
                  *(void *)(v4 + 96) = v431;
                  *(_OWORD *)(v4 + 104) = xmmword_184997E70;
                  float64x2_t v480 = (float64x2_t)(unint64_t)v206;
                  v481.f64[0] = 0.0;
                  while (CA::ShapeIterator::iterate((uint64_t *)&v480, (int *)&v457))
                  {
                    if (v210)
                    {
                      uint32x2_t v224 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v457 + 8));
                      if ((vpmax_u32(v224, v224).u32[0] & 0x80000000) == 0)
                      {
                        int32x2_t v225 = v221[1];
                        uint32x2_t v226 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v225);
                        if ((vpmax_u32(v226, v226).u32[0] & 0x80000000) == 0)
                        {
                          *(int32x2_t *)&long long v227 = vmax_s32(*(int32x2_t *)&v457, *v221);
                          int32x2_t v228 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)&v457, *(int32x2_t *)((char *)&v457 + 8)), vadd_s32(*v221, v225)), *(int32x2_t *)&v227);
                          uint32x2_t v229 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v228);
                          if ((vpmax_u32(v229, v229).u32[0] & 0x80000000) == 0)
                          {
                            *((int32x2_t *)&v227 + 1) = v228;
                            long long v457 = v227;
                            goto LABEL_308;
                          }
                        }
                        *((void *)&v457 + 1) = 0;
                      }
                    }
                    else
                    {
LABEL_308:
                      uint64_t v230 = 4;
                      if (*(_DWORD *)(v4 + 92)) {
                        uint64_t v230 = 6;
                      }
                      if ((unint64_t)(*(void *)(v4 + 128) + 4) > *(void *)(v4 + 136)
                        || (unint64_t v231 = *(void *)(v4 + 112)) != 0 && *(void *)(v4 + 104) + v230 > v231)
                      {
                        *(_WORD *)(v4 + 832) |= 0x20u;
                        CA::OGL::Context::array_flush(v4);
                        *(void *)(v4 + 128) = 0;
                        *(void *)(v4 + 96) = v431;
                        *(_OWORD *)(v4 + 104) = xmmword_184997E70;
                      }
                      int v232 = DWORD1(v457);
                      float v233 = *((float *)v205 + 6);
                      float v234 = v233 * (float)(int)v457;
                      float v235 = v233 * (float)SDWORD1(v457);
                      int v236 = HIDWORD(v457);
                      float v237 = v233 * (float)(DWORD2(v457) + v457);
                      int v238 = v457 - v221->i32[0];
                      int v239 = HIDWORD(v457) + DWORD1(v457);
                      float v240 = v233 * (float)(HIDWORD(v457) + DWORD1(v457));
                      float v241 = v207 / v233;
                      float v242 = floorf(v234);
                      float v243 = floorf(v235);
                      float v244 = ceilf(v237);
                      float v245 = ceilf(v240);
                      float v246 = (float)v238 + (float)((float)(v242 - v234) * v241);
                      int v247 = DWORD1(v457) - v221->i32[1];
                      float v248 = (float)v247 + (float)((float)(v243 - v235) * v241);
                      float v249 = (float)(v238 + DWORD2(v457)) + (float)((float)(v244 - v237) * v241);
                      float v250 = (float)(v247 + HIDWORD(v457)) + (float)((float)(v245 - v240) * v241);
                      float v448 = v242;
                      CA::OGL::Context::array_rect((void *)v4, v242, v243, v244, v245);
                      uint64_t v251 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                      *(float *)(v251 - 176) = v246;
                      *(float *)(v251 - 172) = v248;
                      *(float *)(v251 - 128) = v249;
                      *(float *)(v251 - 124) = v248;
                      *(float *)(v251 - 80) = v249;
                      *(float *)(v251 - 76) = v250;
                      float v442 = v246;
                      *(float *)(v251 - 32) = v246;
                      *(float *)(v251 - 28) = v250;
                      if (byte_1EB2ACBEA)
                      {
                        if (x_log_hook_p())
                        {
                          x_log_();
                          v205 = v432;
                          float v207 = 1.0;
                        }
                        else
                        {
                          v273 = x_log_category_ogl;
                          v205 = v432;
                          float v207 = 1.0;
                          if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEFAULT))
                          {
                            uint64_t v274 = *(void *)(v450 + 16);
                            *(_DWORD *)buf = 134219008;
                            *(void *)&uint8_t buf[4] = v274;
                            *(_WORD *)&buf[12] = 1024;
                            *(_DWORD *)&buf[14] = v457;
                            *(_WORD *)&buf[18] = 1024;
                            *(_DWORD *)&buf[20] = v232;
                            *(_WORD *)&buf[24] = 1024;
                            *(_DWORD *)&buf[26] = DWORD2(v457);
                            *(_WORD *)&buf[30] = 1024;
                            *(_DWORD *)&buf[32] = v236;
                            _os_log_impl(&dword_184668000, v273, OS_LOG_TYPE_DEFAULT, "backdrop 0x%lx rect [%d %d; %d x %d]\n",
                              buf,
                              0x24u);
                          }
                        }
                      }
                      uint64_t v210 = v437;
                      if (*((float *)v205 + 6) != v207)
                      {
                        uint64_t v252 = 32;
                        if (*(_DWORD *)(v4 + 92)) {
                          uint64_t v252 = 48;
                        }
                        if ((unint64_t)(*(void *)(v4 + 128) + 32) > *(void *)(v4 + 136)
                          || (unint64_t v253 = *(void *)(v4 + 112)) != 0 && *(void *)(v4 + 104) + v252 > v253)
                        {
                          *(_WORD *)(v4 + 832) |= 0x20u;
                          CA::OGL::Context::array_flush(v4);
                          *(void *)(v4 + 128) = 0;
                          *(void *)(v4 + 96) = v431;
                          *(_OWORD *)(v4 + 104) = xmmword_184997E70;
                        }
                        int v254 = v457;
                        double v422 = (double)(int)v457;
                        if (v426.f64[0] == (double)(int)v457)
                        {
                          CA::OGL::Context::array_rect((void *)v4, v448 + -1.0, v243, v448, v245);
                          float v255 = v246 + 0.5;
                          uint64_t v256 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                          *(float *)(v256 - 176) = v246 + 0.5;
                          *(float *)(v256 - 172) = v248;
                          *(float *)(v256 - 128) = v246 + 0.5;
                          *(float *)(v256 - 124) = v248;
                          *(float *)(v256 - 80) = v246 + 0.5;
                          *(float *)(v256 - 76) = v250;
                          *(float *)(v256 - 32) = v246 + 0.5;
                          *(float *)(v256 - 28) = v250;
                          double v257 = (double)v232;
                          double v258 = v426.f64[1];
                          if (v426.f64[1] != (double)v232) {
                            goto LABEL_328;
                          }
                          CA::OGL::Context::array_rect((void *)v4, v448 + -1.0, v243 + -1.0, v448, v243);
                          uint64_t v259 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                          *(float *)(v259 - 176) = v255;
                          *(float *)(v259 - 172) = v248 + 0.5;
                          *(float *)(v259 - 128) = v255;
                          *(float *)(v259 - 124) = v248 + 0.5;
                          *(float *)(v259 - 80) = v255;
                          *(float *)(v259 - 76) = v248 + 0.5;
                          *(float *)(v259 - 32) = v255;
                          *(float *)(v259 - 28) = v248 + 0.5;
                        }
                        else
                        {
                          double v257 = (double)v232;
                        }
                        double v258 = v426.f64[1];
LABEL_328:
                        int v260 = DWORD2(v457);
                        if (v258 == v257)
                        {
                          CA::OGL::Context::array_rect((void *)v4, v448, v243 + -1.0, v244, v243);
                          float v261 = v248 + 0.5;
                          uint64_t v262 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                          *(float *)(v262 - 176) = v442;
                          *(float *)(v262 - 172) = v248 + 0.5;
                          *(float *)(v262 - 128) = v249;
                          *(float *)(v262 - 124) = v248 + 0.5;
                          *(float *)(v262 - 80) = v249;
                          *(float *)(v262 - 76) = v248 + 0.5;
                          *(float *)(v262 - 32) = v442;
                          *(float *)(v262 - 28) = v248 + 0.5;
                          double v263 = (double)(v260 + v254);
                          if (v425 == v263)
                          {
                            CA::OGL::Context::array_rect((void *)v4, v244, v243 + -1.0, v244 + 1.0, v243);
                            uint64_t v264 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                            *(float *)(v264 - 176) = v249 + -0.5;
                            *(float *)(v264 - 172) = v261;
                            *(float *)(v264 - 128) = v249 + -0.5;
                            *(float *)(v264 - 124) = v261;
                            *(float *)(v264 - 80) = v249 + -0.5;
                            *(float *)(v264 - 76) = v261;
                            *(float *)(v264 - 32) = v249 + -0.5;
                            *(float *)(v264 - 28) = v261;
                          }
                        }
                        else
                        {
                          double v263 = (double)(DWORD2(v457) + v254);
                        }
                        uint64_t v210 = v437;
                        if (v425 == v263)
                        {
                          CA::OGL::Context::array_rect((void *)v4, v244, v243, v244 + 1.0, v245);
                          float v265 = v249 + -0.5;
                          uint64_t v266 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                          *(float *)(v266 - 176) = v249 + -0.5;
                          *(float *)(v266 - 172) = v248;
                          *(float *)(v266 - 128) = v249 + -0.5;
                          *(float *)(v266 - 124) = v248;
                          *(float *)(v266 - 80) = v249 + -0.5;
                          *(float *)(v266 - 76) = v250;
                          *(float *)(v266 - 32) = v249 + -0.5;
                          *(float *)(v266 - 28) = v250;
                          double v267 = (double)v239;
                          if (v424 == (double)v239)
                          {
                            CA::OGL::Context::array_rect((void *)v4, v244, v245, v244 + 1.0, v245 + 1.0);
                            float v268 = -0.5;
                            uint64_t v269 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                            *(float *)(v269 - 176) = v265;
                            *(float *)(v269 - 172) = v250 + -0.5;
                            *(float *)(v269 - 128) = v265;
                            *(float *)(v269 - 124) = v250 + -0.5;
                            *(float *)(v269 - 80) = v265;
                            *(float *)(v269 - 76) = v250 + -0.5;
                            *(float *)(v269 - 32) = v265;
                            *(float *)(v269 - 28) = v250 + -0.5;
                          }
                          else
                          {
                            float v268 = -0.5;
                          }
                        }
                        else
                        {
                          float v268 = -0.5;
                          double v267 = (double)v239;
                        }
                        float v207 = 1.0;
                        if (v424 == v267)
                        {
                          CA::OGL::Context::array_rect((void *)v4, v448, v245, v244, v245 + 1.0);
                          float v270 = v250 + v268;
                          uint64_t v271 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                          *(float *)(v271 - 176) = v442;
                          *(float *)(v271 - 172) = v250 + v268;
                          *(float *)(v271 - 128) = v249;
                          *(float *)(v271 - 124) = v250 + v268;
                          *(float *)(v271 - 80) = v249;
                          *(float *)(v271 - 76) = v250 + v268;
                          *(float *)(v271 - 32) = v442;
                          *(float *)(v271 - 28) = v250 + v268;
                          if (v426.f64[0] == v422)
                          {
                            CA::OGL::Context::array_rect((void *)v4, v448 + -1.0, v245, v448, v245 + 1.0);
                            uint64_t v272 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                            *(float *)(v272 - 176) = v442 + 0.5;
                            *(float *)(v272 - 172) = v270;
                            *(float *)(v272 - 128) = v442 + 0.5;
                            *(float *)(v272 - 124) = v270;
                            *(float *)(v272 - 80) = v442 + 0.5;
                            *(float *)(v272 - 76) = v270;
                            *(float *)(v272 - 32) = v442 + 0.5;
                            *(float *)(v272 - 28) = v270;
                          }
                        }
                      }
                    }
                  }
                  CA::OGL::Context::array_flush(v4);
                  if (v210)
                  {
                    CA::OGL::Context::unbind_surface((void *)v4, v210, 0);
                  }
                  else
                  {
                    uint64_t v275 = *(void *)(v4 + 16);
                    *(_WORD *)(v275 + 144) = 0;
                    *(void *)(v275 + 176) = 0;
                  }
                  uint64_t v208 = v419 - 1;
                  uint64_t v206 = (uint64_t)v417;
                }
                while (v419 > 0);
              }
              unint64_t v289 = ((unint64_t)v409 << 32) | (v408 << 48) | ((unint64_t)v411 << 16) | v410;
              uint64_t v290 = *(void *)(v4 + 16);
              if (v289)
              {
                *(unsigned char *)(v290 + 16) = 0;
                *(unsigned char *)(*(void *)(v4 + 16) + 481) |= 1u;
                *(unsigned char *)(*(void *)(v4 + 16) + 480) = 3;
                int v291 = v418;
                if (v461) {
                  int v291 = 0;
                }
                if (v291 == 1)
                {
                  float v292 = *((float *)v432 + 6);
                  *(void *)&uint8_t buf[8] = 0;
                  *(void *)buf = 0;
                  LOWORD(v452) = v410;
                  WORD1(v452) = v411;
                  WORD2(v452) = v409;
                  HIWORD(v452) = v408;
                }
                *(void *)(v4 + 128) = 0;
                *(void *)(v4 + 96) = v4 + 834;
                *(_OWORD *)(v4 + 104) = xmmword_184997E70;
                *(void *)&buf[16] = 0;
                *(void *)buf = v206;
                *(void *)&uint8_t buf[8] = 0;
                *(void *)&double v449 = *(_OWORD *)&vaddq_f64(v420, v426);
                double v293 = v413 + v426.f64[1];
                float v294 = 1.0;
                while (CA::ShapeIterator::iterate((uint64_t *)buf, (int *)&v457))
                {
                  int v295 = DWORD1(v457);
                  int v296 = DWORD2(v457);
                  float v297 = *((float *)v432 + 6);
                  float v298 = floorf(v297 * (float)(int)v457);
                  float v299 = floorf(v297 * (float)SDWORD1(v457));
                  float v300 = ceilf(v297 * (float)(DWORD2(v457) + v457));
                  int v301 = HIDWORD(v457) + DWORD1(v457);
                  float v302 = ceilf(v297 * (float)(HIDWORD(v457) + DWORD1(v457)));
                  CA::OGL::Context::array_check((CA::OGL::Context *)v4, 1);
                  CA::OGL::Context::array_rect((void *)v4, v298, v299, v300, v302);
                  uint64_t v303 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                  *(void *)(v303 - 160) = v289;
                  *(void *)(v303 - 112) = v289;
                  *(void *)(v303 - 64) = v289;
                  *(void *)(v303 - 16) = v289;
                  if (*((float *)v432 + 6) != v294)
                  {
                    double v304 = v293;
                    int v305 = v457;
                    double v306 = (double)(int)v457;
                    double v307 = (double)v295;
                    double v308 = (double)v301;
                    CA::OGL::Context::array_check((CA::OGL::Context *)v4, 4);
                    if (v426.f64[0] == v306)
                    {
                      float v309 = 1.0;
                      if (v426.f64[1] == v307) {
                        float v310 = 1.0;
                      }
                      else {
                        float v310 = 0.0;
                      }
                      float v311 = v299 - v310;
                      if (v304 != v308) {
                        float v309 = 0.0;
                      }
                      CA::OGL::Context::array_rect((void *)v4, v298 + -1.0, v311, v298, v302 + v309);
                      uint64_t v312 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                      *(void *)(v312 - 160) = v289;
                      *(void *)(v312 - 112) = v289;
                      *(void *)(v312 - 64) = v289;
                      *(void *)(v312 - 16) = v289;
                    }
                    if (v423 == v307)
                    {
                      CA::OGL::Context::array_rect((void *)v4, v298, v299 + -1.0, v300, v299);
                      uint64_t v313 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                      *(void *)(v313 - 160) = v289;
                      *(void *)(v313 - 112) = v289;
                      *(void *)(v313 - 64) = v289;
                      *(void *)(v313 - 16) = v289;
                    }
                    double v293 = v304;
                    float v294 = 1.0;
                    if (v449 == (double)(v296 + v305))
                    {
                      if (v426.f64[1] == v307) {
                        float v314 = 1.0;
                      }
                      else {
                        float v314 = 0.0;
                      }
                      float v315 = v299 - v314;
                      if (v293 == v308) {
                        float v316 = 1.0;
                      }
                      else {
                        float v316 = 0.0;
                      }
                      CA::OGL::Context::array_rect((void *)v4, v300, v315, v300 + 1.0, v302 + v316);
                      uint64_t v317 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                      *(void *)(v317 - 160) = v289;
                      *(void *)(v317 - 112) = v289;
                      *(void *)(v317 - 64) = v289;
                      *(void *)(v317 - 16) = v289;
                    }
                    if (v293 == v308)
                    {
                      CA::OGL::Context::array_rect((void *)v4, v298, v302, v300, v302 + 1.0);
                      uint64_t v318 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                      *(void *)(v318 - 160) = v289;
                      *(void *)(v318 - 112) = v289;
                      *(void *)(v318 - 64) = v289;
                      *(void *)(v318 - 16) = v289;
                    }
                  }
                }
                CA::OGL::Context::array_flush(v4);
                uint64_t v290 = *(void *)(v4 + 16);
              }
              *(unsigned char *)(v290 + 481) &= ~1u;
              if (v412) {
                *(unsigned char *)(*(void *)(v4 + 16) + 481) &= ~2u;
              }
              int v319 = v418;
              if (!v461) {
                int v319 = 0;
              }
              if (v319 == 1) {
              if ((*(_WORD *)(v451 + 68) & 0x100) != 0 && *(void *)(v11 + 528))
              }
              {
                *(void *)(v4 + 128) = 0;
                *(void *)(v4 + 96) = v4 + 834;
                *(_OWORD *)(v4 + 104) = xmmword_184997E70;
                *(unsigned char *)(*(void *)(v4 + 16) + 16) = 0;
                uint64_t v320 = *(void *)(v11 + 528);
                *(void *)&buf[16] = 0;
                *(void *)buf = v320;
                *(void *)&uint8_t buf[8] = 0;
                while (CA::ShapeIterator::iterate((uint64_t *)buf, (int *)&v457))
                {
                  CA::OGL::Context::array_check((CA::OGL::Context *)v4, 1);
                  CA::OGL::Context::array_rect((void *)v4, *((float *)v432 + 6) * (float)(int)v457, *((float *)v432 + 6) * (float)SDWORD1(v457), *((float *)v432 + 6) * (float)(DWORD2(v457) + v457), *((float *)v432 + 6) * (float)(HIDWORD(v457) + DWORD1(v457)));
                  uint64_t v321 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                  *(void *)(v321 - 160) = 0;
                  *(void *)(v321 - 112) = 0;
                  *(void *)(v321 - 64) = 0;
                  *(void *)(v321 - 16) = 0;
                }
                CA::OGL::Context::array_flush(v4);
              }
              if (v414)
              {
                int v322 = v464.i32[0];
                int v323 = v464.i32[1];
                __int32 v324 = v464.i32[2];
                __int32 v325 = v464.i32[3];
                *(unsigned char *)(*(void *)(v4 + 16) + 16) = 0;
                *(void *)(v4 + 128) = 0;
                *(void *)(v4 + 96) = v4 + 834;
                *(_OWORD *)(v4 + 104) = xmmword_184997E70;
                CA::OGL::Context::array_check((CA::OGL::Context *)v4, 4);
                float v326 = (float)(v325 + v323);
                CA::OGL::Context::array_rect((void *)v4, (float)v322, (float)v323, (float)v322 + 1.0, v326);
                uint64_t v327 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                *(void *)(v327 - 160) = 0;
                *(void *)(v327 - 112) = 0;
                *(void *)(v327 - 64) = 0;
                *(void *)(v327 - 16) = 0;
                float v328 = (float)(v324 + v322);
                CA::OGL::Context::array_rect((void *)v4, v328 + -1.0, (float)v323, v328, v326);
                uint64_t v329 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                *(void *)(v329 - 160) = 0;
                *(void *)(v329 - 112) = 0;
                *(void *)(v329 - 64) = 0;
                *(void *)(v329 - 16) = 0;
                CA::OGL::Context::array_rect((void *)v4, (float)v322, (float)v323, v328, (float)v323 + 1.0);
                uint64_t v330 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                *(void *)(v330 - 160) = 0;
                *(void *)(v330 - 112) = 0;
                *(void *)(v330 - 64) = 0;
                *(void *)(v330 - 16) = 0;
                CA::OGL::Context::array_rect((void *)v4, (float)v322, v326 + -1.0, v328, v326);
                uint64_t v331 = *(void *)(v4 + 120) + 48 * *(void *)(v4 + 128);
                *(void *)(v331 - 160) = 0;
                *(void *)(v331 - 112) = 0;
                *(void *)(v331 - 64) = 0;
                *(void *)(v331 - 16) = 0;
                CA::OGL::Context::array_flush(v4);
              }
              if (byte_1EB2ACBEA)
              {
                if (x_log_hook_p())
                {
                  x_log_();
                }
                else
                {
                  v402 = x_log_category_ogl;
                  if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v403 = *(void *)(v450 + 16);
                    *(_DWORD *)buf = 134217984;
                    *(void *)&uint8_t buf[4] = v403;
                    _os_log_impl(&dword_184668000, v402, OS_LOG_TYPE_DEFAULT, "backdrop 0x%lx complete\n", buf, 0xCu);
                  }
                }
              }
              if (v404) {
                *(unsigned char *)(v4 + 64) = 1;
              }
              uint64_t v332 = *(void *)(v4 + 16);
              *(unsigned char *)(v332 + 480) = v406;
              *(unsigned char *)(v332 + 481) = *(unsigned char *)(v332 + 481) & 0xFE | v405 & 1;
              *(unsigned char *)(*(void *)(v4 + 16) + 16) = 0;
              CA::OGL::Context::pop_surface((CA::OGL::Context *)v4);
              CA::OGL::Context::set_gstate(v4, **(void **)(v4 + 248));
              __int16 v334 = 0;
              uint64_t v335 = (uint64_t)v432;
              BOOL v336 = *((float *)v432 + 6) == 1.0 && v468 == 0;
              if (v336) {
                __int16 v334 = ~(*(_WORD *)(v4 + 832) << 10) & 0x800;
              }
              *(_WORD *)(*((void *)v432 + 4) + 75) = *(_WORD *)(*((void *)v432 + 4) + 75) & 0xF7FF | v334;
              v480.f64[0] = 0.0;
              v333.i32[0] = *((_DWORD *)v432 + 6);
              *(void *)&v480.f64[0] = CA::Shape::scale_and_dilate(v417, v333, v333.f32[0], 0, 0);
              int v338 = v418;
              if (!v461) {
                int v338 = 0;
              }
              if (v338 == 1)
              {
                v339 = (CA::Shape *)CA::Shape::dilate((uint64_t)v417, (int)*(float *)&v462, (int)*((float *)&v462 + 1));
                v342 = (CA::Shape *)CA::Shape::subtract(v339, v415, v340, v341);
                v343.i32[0] = *((_DWORD *)v432 + 6);
                v344 = (CA::Shape **)CA::Shape::scale_and_dilate(v342, v343, v343.f32[0], 0, 0);
                CA::shape_subtract((CA::Shape **)&v480, v344, v345, v346);
                if (v344) {
                  CA::Shape::unref((CA::Shape *)v344);
                }
                if (v342) {
                  CA::Shape::unref(v342);
                }
                uint64_t v335 = (uint64_t)v432;
                if (v339) {
                  CA::Shape::unref(v339);
                }
              }
              if (v414)
              {
                *(int8x16_t *)buf = v464;
                __int32 v347 = v464.i32[2];
                if (v464.i32[2] <= v464.i32[3]) {
                  int v348 = v464.i32[3];
                }
                else {
                  int v348 = v464.i32[2];
                }
                if (v464.i32[2] >= v464.i32[3]) {
                  __int32 v347 = v464.i32[3];
                }
                if (v348 <= 1073741822 && v347 >= 1)
                {
                  *(int32x4_t *)buf = vaddq_s32((int32x4_t)v464, (int32x4_t)xmmword_1849985D0);
                  int32x2_t v350 = vcgt_s32((int32x2_t)0x100000001, vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)buf, *(int8x16_t *)buf, 8uLL)));
                  if ((v350.i32[1] | v350.i32[0])) {
                    *(void *)&uint8_t buf[8] = 0;
                  }
                }
                CA::shape_intersect((CA::Shape **)&v480, (CA::Shape **)buf, v337);
                uint64_t v335 = (uint64_t)v432;
              }
              v351 = (CA::Shape *)v459;
              v352 = (CA::Shape *)v458;
              float64_t v353 = v480.f64[0];
              CA::Shape::unref(*(CA::Shape **)&v353);
              if (v351) {
                CA::Shape::unref(v351);
              }
              if (v352) {
                CA::Shape::unref(v352);
              }
              ++*((_DWORD *)v432 + 15);
              long long v10 = v421;
              uint64_t v174 = v415;
              char v177 = v407;
            }
LABEL_434:
            if ((v177 & 1) == 0) {
              CA::Shape::unref(v174);
            }
            v354 = *(CA::Shape **)(v11 + 520);
            if (v354)
            {
              CA::Shape::unref(v354);
              *(void *)(v11 + 520) = 0;
            }
LABEL_438:
            long long v12 = (os_unfair_lock_s *)(v11 + 40);
LABEL_439:
            os_unfair_lock_unlock(v12);
            goto LABEL_440;
          }
          unsigned __int16 v410 = v165.i16[0];
          unsigned __int16 v411 = v165.u16[1];
          unsigned __int16 v409 = v165.u16[2];
          uint64_t v408 = v165.u16[3];
          if ((*((unsigned char *)v98 + 216) & 2) != 0)
          {
            char v171 = *((unsigned char *)v98 + 216) & 0xFD;
LABEL_221:
            *((unsigned char *)v98 + 216) = v171;
            long long v492 = 0u;
            long long v490 = 0u;
            long long v491 = 0u;
            if ((*(unsigned char *)(v451 + 69) & 1) == 0)
            {
              char v172 = 1;
LABEL_223:
              *(void *)&uint8_t buf[8] = 0;
              *(void *)buf = 0;
              CA::Bounds::set_exterior((int32x4_t *)buf, v134, v426, v420);
              uint64_t v173 = (uint64_t)&v490;
              CA::Shape::operator=((uint64_t)&v490, buf);
              uint64_t v174 = (CA::Shape *)CA::Shape::new_shape((unsigned int *)buf);
              goto LABEL_230;
            }
          }
          else
          {
            long long v492 = 0u;
            long long v490 = 0u;
            long long v491 = 0u;
            if ((*(_WORD *)(v451 + 68) & 0x100) == 0)
            {
              if (!v163) {
                goto LABEL_218;
              }
              char v172 = 1;
LABEL_219:
              long long v10 = v421;
              double v98 = v432;
              goto LABEL_223;
            }
            long long v10 = v421;
            double v98 = v432;
            if (!v163) {
              goto LABEL_227;
            }
          }
          v175 = (uint64_t *)(v11 + 480);
          char v172 = 1;
          goto LABEL_228;
        }
        if (*((void *)v432 + 4))
        {
          *((_DWORD *)v432 + 13) = 0;
          ++*((_DWORD *)v432 + 15);
          *((void *)v432 + 3) = 0;
        }
LABEL_21:
        unint64_t v17 = *(CA::Shape **)(v11 + 520);
        if (v17)
        {
          CA::Shape::unref(v17);
          *(void *)(v11 + 520) = 0;
        }
        goto LABEL_439;
      }
    }
    long long v501 = 0u;
    long long v500 = 0u;
    float64x2_t v499 = 0u;
    int8x16_t v498 = 0u;
    double v45 = (double *)&v498;
    double v46 = (double *)&v500;
    float32x4x2_t v509 = vld2q_f32((const float *)v38);
    v512.val[0] = vcvtq_f64_f32(*(float32x2_t *)v509.val[0].f32);
    v512.val[1] = vcvtq_f64_f32(*(float32x2_t *)v509.val[1].f32);
    vst2q_f64(v45, v512);
    v512.val[0] = vcvt_hight_f64_f32(v509.val[0]);
    v512.val[1] = vcvt_hight_f64_f32(v509.val[1]);
    vst2q_f64(v46, v512);
    *(void *)buf = &unk_1ED030230;
    *(void *)&uint8_t buf[8] = 4;
    *(void *)&buf[16] = &v498;
    if (0xCF3CF3CF3CF3CF3DLL * ((v28 - v29) >> 3) <= v33) {
      goto LABEL_224;
    }
    CA::Render::LayerNode::MapGeometry::map((uint64_t)buf, *(CA::Render::LayerNode **)(v38 - 104), *(CA::Render::LayerNode **)(v29 + 168 * v33 + 8));
    double v47 = (const double *)&v498;
    float64x2x2_t v510 = vld2q_f64(v47);
    v47 += 4;
    float64x2x2_t v513 = vld2q_f64(v47);
    int32x4_t v48 = (int32x4_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v510.val[0]), v513.val[0]);
    v510.val[0] = (float64x2_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v510.val[1]), v513.val[1]);
    v510.val[1] = (float64x2_t)vzip1q_s32(v48, (int32x4_t)v510.val[0]);
    v510.val[0] = (float64x2_t)vzip2q_s32(v48, (int32x4_t)v510.val[0]);
    *(float64x2_t *)uint64_t v38 = v510.val[1];
    *(float64x2_t *)(v38 + 16) = v510.val[0];
    *(int8x8_t *)&v513.val[1].f64[0] = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v510.val[1].f64[1], *(float32x2_t *)&v510.val[1].f64[0]), *(int8x8_t *)&v510.val[1].f64[0], *(int8x8_t *)&v510.val[1].f64[1]);
    *(int8x8_t *)&v510.val[1].f64[0] = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v510.val[1].f64[0], *(float32x2_t *)&v510.val[1].f64[1]), *(int8x8_t *)&v510.val[1].f64[0], *(int8x8_t *)&v510.val[1].f64[1]);
    *(int8x8_t *)v48.i8 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v510.val[0].f64[1], *(float32x2_t *)&v510.val[0].f64[0]), *(int8x8_t *)&v510.val[0].f64[0], *(int8x8_t *)&v510.val[0].f64[1]);
    *(int8x8_t *)&v510.val[0].f64[0] = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v510.val[0].f64[0], *(float32x2_t *)&v510.val[0].f64[1]), *(int8x8_t *)&v510.val[0].f64[0], *(int8x8_t *)&v510.val[0].f64[1]);
    *(int8x8_t *)&v513.val[0].f64[0] = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)v48.i8, *(float32x2_t *)&v513.val[1].f64[0]), *(int8x8_t *)&v513.val[1].f64[0], *(int8x8_t *)v48.i8);
    *(float32x2_t *)&v510.val[0].f64[0] = vsub_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v510.val[1].f64[0], *(float32x2_t *)&v510.val[0].f64[0]), *(int8x8_t *)&v510.val[1].f64[0], *(int8x8_t *)&v510.val[0].f64[0]), *(float32x2_t *)&v513.val[0].f64[0]);
    LODWORD(v510.val[1].f64[0]) = COERCE_UNSIGNED_INT(vaddv_f32(*(float32x2_t *)&v510.val[0].f64[0])) & 0x7FFFFFFF;
    v510.val[1] = (float64x2_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v435, (int32x4_t)v510.val[1]), 0);
    float64x2_t v49 = (float64x2_t)vbslq_s8((int8x16_t)v510.val[1], (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)&v510.val[0].f64[0]), v443);
    float64x2_t v50 = (float64x2_t)vbslq_s8((int8x16_t)v510.val[1], (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)&v513.val[0].f64[0]), v439);
    float64x2_t v51 = *(float64x2_t *)(v11 + 464);
    int64x2_t v52 = vclezq_f64(v51);
    int64x2_t v53 = vclezq_f64(v49);
    int32x2_t v54 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v53, v52), (int8x16_t)vzip2q_s64(v53, v52))));
    __int8 v55 = v54.i8[0];
    if (v54.i8[4])
    {
      float64x2_t v56 = v50;
      float64x2_t v57 = v49;
      if (v55)
      {
LABEL_62:
        float64x2_t v60 = *(float64x2_t *)(v29 + v37 - 48);
        double v61 = *(double *)(v29 + v37 - 40);
        if (v60.f64[0] >= v61) {
          double v62 = *(double *)(v29 + v37 - 40);
        }
        else {
          double v62 = *(double *)(v29 + v37 - 48);
        }
        if (v62 <= 0.0)
        {
          double v3 = v438;
LABEL_82:
          uint64_t v29 = *(void *)(v11 + 64);
          uint64_t v28 = *(void *)(v11 + 72);
          goto LABEL_83;
        }
        v63.f64[0] = *(float64_t *)(v29 + v37 - 64);
        uint64_t v64 = v29 + v37;
        if (v63.f64[0] == *(double *)(v38 - 96))
        {
          double v65 = *(double *)(v64 - 56);
          if (v65 == *(double *)(v38 - 88) && v60.f64[0] == *(double *)(v38 - 80) && v61 == *(double *)(v38 - 72))
          {
            int64x2_t v66 = vclezq_f64(v433);
            int32x2_t v67 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v53, v66), (int8x16_t)vzip2q_s64(v53, v66))));
            if (v67.i8[4])
            {
              double v3 = v438;
              if (v67.i8[0]) {
                goto LABEL_82;
              }
              goto LABEL_81;
            }
            double v3 = v438;
            if (v67.i8[0]) {
              goto LABEL_82;
            }
            goto LABEL_80;
          }
        }
        else
        {
          double v65 = *(double *)(v64 - 56);
        }
        v63.f64[1] = v65;
        float32x2_t v68 = vcvt_f32_f64(v63);
        *(float32x2_t *)v69.i8 = vadd_f32(vcvt_f32_f64(v60), v68);
        *(float32x2_t *)v70.i8 = v68;
        v70.i64[1] = __PAIR64__(v68.u32[1], v69.u32[0]);
        v69.i64[1] = v69.i64[0];
        float32x4_t v71 = (float32x4_t)vuzp1q_s32(v70, (int32x4_t)vcvt_hight_f32_f64(*(int32x2_t *)v69.i8, v63));
        float32x4_t v72 = (float32x4_t)vuzp2q_s32(v70, v69);
        v514.val[0] = vcvtq_f64_f32(*(float32x2_t *)v71.f32);
        v514.val[1] = vcvtq_f64_f32(*(float32x2_t *)v72.f32);
        double v73 = (double *)&v498;
        vst2q_f64(v73, v514);
        v73 += 4;
        v514.val[0] = vcvt_hight_f64_f32(v71);
        v514.val[1] = vcvt_hight_f64_f32(v72);
        vst2q_f64(v73, v514);
        *(void *)&long long v493 = &unk_1ED030230;
        *((void *)&v493 + 1) = 4;
        *(void *)&long long v494 = &v498;
        uint64_t v74 = *(void *)(v11 + 64);
        if (0xCF3CF3CF3CF3CF3DLL * ((*(void *)(v11 + 72) - v74) >> 3) <= v33) {
LABEL_224:
        }
          __assert_rtn("operator[]", "x-small-vector.h", 91, "pos < size () && \"Out of bounds access\"");
        CA::Render::LayerNode::MapGeometry::map((uint64_t)&v493, *(CA::Render::LayerNode **)(v38 - 104), *(CA::Render::LayerNode **)(v74 + 168 * v33 + 8));
        double v75 = (const double *)&v498;
        float64x2x2_t v511 = vld2q_f64(v75);
        v75 += 4;
        float64x2x2_t v515 = vld2q_f64(v75);
        int32x4_t v76 = (int32x4_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v511.val[0]), v515.val[0]);
        v511.val[0] = (float64x2_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v511.val[1]), v515.val[1]);
        v511.val[1] = (float64x2_t)vzip2q_s32(v76, (int32x4_t)v511.val[0]);
        v511.val[0] = (float64x2_t)vzip1q_s32(v76, (int32x4_t)v511.val[0]);
        *(void *)&v515.val[0].f64[0] = vextq_s8((int8x16_t)v511.val[0], (int8x16_t)v511.val[0], 8uLL).u64[0];
        *(int8x8_t *)&v515.val[1].f64[0] = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v515.val[0].f64[0], *(float32x2_t *)&v511.val[0].f64[0]), *(int8x8_t *)&v511.val[0].f64[0], *(int8x8_t *)&v515.val[0].f64[0]);
        *(int8x8_t *)&v511.val[0].f64[0] = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v511.val[0].f64[0], *(float32x2_t *)&v515.val[0].f64[0]), *(int8x8_t *)&v511.val[0].f64[0], *(int8x8_t *)&v515.val[0].f64[0]);
        *(void *)&v515.val[0].f64[0] = vextq_s8((int8x16_t)v511.val[1], (int8x16_t)v511.val[1], 8uLL).u64[0];
        *(int8x8_t *)v76.i8 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v515.val[0].f64[0], *(float32x2_t *)&v511.val[1].f64[0]), *(int8x8_t *)&v511.val[1].f64[0], *(int8x8_t *)&v515.val[0].f64[0]);
        *(int8x8_t *)&v511.val[1].f64[0] = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v511.val[1].f64[0], *(float32x2_t *)&v515.val[0].f64[0]), *(int8x8_t *)&v511.val[1].f64[0], *(int8x8_t *)&v515.val[0].f64[0]);
        *(int8x8_t *)&v515.val[0].f64[0] = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)v76.i8, *(float32x2_t *)&v515.val[1].f64[0]), *(int8x8_t *)&v515.val[1].f64[0], *(int8x8_t *)v76.i8);
        *(float32x2_t *)&v511.val[0].f64[0] = vsub_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v511.val[0].f64[0], *(float32x2_t *)&v511.val[1].f64[0]), *(int8x8_t *)&v511.val[0].f64[0], *(int8x8_t *)&v511.val[1].f64[0]), *(float32x2_t *)&v515.val[0].f64[0]);
        LODWORD(v511.val[1].f64[0]) = COERCE_UNSIGNED_INT(vaddv_f32(*(float32x2_t *)&v511.val[0].f64[0])) & 0x7FFFFFFF;
        v511.val[1] = (float64x2_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v429, (int32x4_t)v511.val[1]), 0);
        float64x2_t v49 = (float64x2_t)vbslq_s8((int8x16_t)v511.val[1], (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)&v511.val[0].f64[0]), v443);
        float64x2_t v50 = (float64x2_t)vbslq_s8((int8x16_t)v511.val[1], (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)&v515.val[0].f64[0]), v439);
        v515.val[0] = (float64x2_t)vclezq_f64(v433);
        v515.val[1] = (float64x2_t)vclezq_f64(v49);
        int32x2_t v77 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64((int64x2_t)v515.val[1], (int64x2_t)v515.val[0]), (int8x16_t)vzip2q_s64((int64x2_t)v515.val[1], (int64x2_t)v515.val[0]))));
        double v3 = v438;
        if (v77.i8[4])
        {
          if (v77.i8[0]) {
            goto LABEL_82;
          }
          goto LABEL_81;
        }
        if (v77.i8[0]) {
          goto LABEL_82;
        }
LABEL_80:
        float64x2_t v78 = vaddq_f64(v50, v49);
        float64x2_t v50 = vminnmq_f64(v427, v50);
        float64x2_t v49 = vsubq_f64(vmaxnmq_f64(vaddq_f64(v427, v433), v78), v50);
LABEL_81:
        float64x2_t v427 = v50;
        float64x2_t v433 = v49;
        goto LABEL_82;
      }
    }
    else
    {
      if (v54.i8[0]) {
        goto LABEL_62;
      }
      float64x2_t v58 = *(float64x2_t *)(v11 + 448);
      float64x2_t v59 = vaddq_f64(v58, v51);
      float64x2_t v56 = vminnmq_f64(v58, v50);
      float64x2_t v57 = vsubq_f64(vmaxnmq_f64(v59, vaddq_f64(v50, v49)), v56);
    }
    *(float64x2_t *)(v11 + 448) = v56;
    *(float64x2_t *)(v11 + 464) = v57;
    goto LABEL_62;
  }
}

uint64_t CA::OGL::MetalContext::protection_options(CA::OGL::MetalContext *this)
{
  return *((void *)this + 386);
}

uint64_t CA::BoundsImpl::intersect(uint64_t a1, float64x2_t a2, float64x2_t a3)
{
  double v3 = (void *)(a1 + 16);
  float64x2_t v4 = *(float64x2_t *)(a1 + 16);
  int64x2_t v5 = vclezq_f64(v4);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) != 0) {
    return 0;
  }
  int64x2_t v6 = vclezq_f64(a3);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), (int8x16_t)v6).u64[0] & 0x8000000000000000) != 0
    || (float64x2_t v7 = vaddq_f64(a2, a3),
        float64x2_t v8 = vmaxnmq_f64(*(float64x2_t *)a1, a2),
        float64x2_t v9 = vsubq_f64(vminnmq_f64(vaddq_f64(*(float64x2_t *)a1, v4), v7), v8),
        int64x2_t v10 = vclezq_f64(v9),
        (vorrq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10).u64[0] & 0x8000000000000000) != 0))
  {
    uint64_t result = 0;
    void *v3 = 0;
    v3[1] = 0;
  }
  else
  {
    *(float64x2_t *)a1 = v8;
    *(float64x2_t *)(a1 + 16) = v9;
    return 1;
  }
  return result;
}

float CA::OGL::Context::raster_round_rect(CA::OGL::Context *this, const Rect *a2, double *a3)
{
  double v4 = a3[2];
  double v5 = a3[3];
  if (v4 > v5) {
    double v5 = a3[2];
  }
  if (v5 < 1073741820.0)
  {
    double v9 = *a3;
    float v10 = *a3;
    float v11 = *(float *)&a2[101].bottom;
    unsigned int v12 = vcvtms_s32_f32(v11 + v10);
    *(_DWORD *)this = v12;
    float v13 = v9 + v4;
    *((_DWORD *)this + 2) = vcvtms_s32_f32(v11 + v13) - v12;
    int v14 = (*(uint64_t (**)(const Rect *))(*(void *)a2 + 1104))(a2);
    double v15 = a3[1];
    float v16 = v15;
    float v17 = *(float *)&a2[101].bottom;
    if (v14) {
      float v17 = 1.0 - v17;
    }
    float v18 = a3[3] + v15;
    unsigned int v19 = vcvtms_s32_f32(v17 + v18);
    float result = v17 + v16;
    unsigned int v20 = vcvtms_s32_f32(v17 + v16);
    *((_DWORD *)this + 1) = v20;
    *((_DWORD *)this + 3) = v19 - v20;
  }
  else
  {
    float result = -3.6893e19;
    *(_OWORD *)this = xmmword_184998040;
  }
  return result;
}

uint64_t CA::OGL::MetalContext::destination_rotated_or_flipped(CA::OGL::MetalContext *this)
{
  uint64_t v1 = *((void *)this + 33);
  if (!v1) {
    return 0;
  }
  unsigned int v2 = *(unsigned __int16 *)(v1 + 232);
  if ((v2 & 0x400) != 0) {
    return 1;
  }
  else {
    return (v2 >> 9) & 1;
  }
}

void CA::shape_subtract(CA::Shape **this, CA::Shape **a2, const CA::Shape *a3, const int *a4)
{
  double v5 = *this;
  if (*this)
  {
    if (v5 == (CA::Shape *)1) {
      return;
    }
  }
  else if (*((_DWORD *)v5 + 1) == 6)
  {
    return;
  }
  if (a2)
  {
    if (a2 == (CA::Shape **)1) {
      return;
    }
    goto LABEL_9;
  }
  if (*((_DWORD *)a2 + 1) != 6)
  {
LABEL_9:
    unint64_t v6 = CA::Shape::subtract(*this, (const CA::Shape *)a2, (uint64_t)a3, a4);
    CA::Shape::unref(v5);
    *this = (CA::Shape *)v6;
  }
}

unint64_t CA::Shape::subtract(CA::Shape *this, const CA::Shape *a2, uint64_t a3, const int *a4)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if ((this & 1) == 0)
  {
    if (*((_DWORD *)this + 1) == 6) {
      goto LABEL_7;
    }
LABEL_5:
    if (a2)
    {
      if (a2 == (const CA::Shape *)1) {
        goto LABEL_7;
      }
    }
    else if (*((_DWORD *)a2 + 1) == 6)
    {
      goto LABEL_7;
    }
    long long v6 = xmmword_184998410;
    int v7 = 2;
    v5[0] = (int *)&v6;
    v5[1] = (int *)v8;
    v5[2] = (int *)v8;
    v5[3] = (int *)&v6 + 3;
    *(void *)&v8[2028] = 0;
    return CA::shape_subtract(v5, (uint64_t)this, (uint64_t)a2, a4);
  }
  if (this != (CA::Shape *)1) {
    goto LABEL_5;
  }
LABEL_7:

  return CA::Shape::ref((unint64_t)this);
}

int32x4_t *CA::Bounds::set_exterior(int32x4_t *this, const Rect *a2, float64x2_t a3, float64x2_t a4)
{
  int64x2_t v4 = vceqzq_f64(a4);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v4, 1), (int8x16_t)v4).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v5 = vorrq_s8((int8x16_t)vcltzq_f64(a4), (int8x16_t)vcgezq_f64(a4)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v5), 1), v5).u64[0] & 0x8000000000000000) != 0))
  {
    this->i64[0] = 0;
    this->i64[1] = 0;
  }
  else
  {
    float64x2_t v6 = vmaxnmq_f64(a3, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000));
    float64x2_t v7 = vminnmq_f64(vaddq_f64(a3, a4), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
    int32x4_t v8 = (int32x4_t)vcvtmq_s64_f64(v6);
    *this = vuzp1q_s32(v8, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v7), (int64x2_t)v8));
  }
  return this;
}

uint64_t CA::shape_subtract(int **this, uint64_t a2, uint64_t a3, const int *a4)
{
  int64x2_t v4 = (long long *)a2;
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  long long v39 = 0u;
  long long v40 = 0u;
  long long v38 = 0u;
  if (a2)
  {
    long long v38 = xmmword_184998420;
    LODWORD(v39) = 2;
    DWORD1(v39) = (int)((unint64_t)a2 >> 16) >> 16;
    DWORD2(v39) = 4;
    HIDWORD(v39) = a2 >> 48;
    LODWORD(v40) = HIDWORD(v39) + (a2 >> 17);
    DWORD1(v40) = ((a2 >> 2) & 0x7FFF) + DWORD1(v39);
    *((void *)&v40 + 1) = 0x7FFFFFFF00000002;
    int64x2_t v4 = &v38;
  }
  long long v36 = 0uLL;
  long long v37 = 0uLL;
  long long v35 = 0uLL;
  if (a3)
  {
    long long v35 = xmmword_184998420;
    LODWORD(v36) = 2;
    DWORD1(v36) = (int)((unint64_t)a3 >> 16) >> 16;
    DWORD2(v36) = 4;
    HIDWORD(v36) = a3 >> 48;
    LODWORD(v37) = HIDWORD(v36) + (a3 >> 17);
    DWORD1(v37) = ((a3 >> 2) & 0x7FFF) + DWORD1(v36);
    *((void *)&v37 + 1) = 0x7FFFFFFF00000002;
    a3 = (uint64_t)&v35;
  }
  int v8 = *((_DWORD *)v4 + 3);
  float64x2_t v6 = (char *)v4 + 12;
  int v7 = v8;
  if (v8 != 0x7FFFFFFF)
  {
    float v11 = (const int *)(a3 + 12);
    unsigned int v12 = (const int *)(a3 + 12);
    uint64_t v9 = (const int *)v6;
    while (1)
    {
      int v13 = *v12;
      if (*v12 == 0x7FFFFFFF) {
        return CA::ShapeHandle::finish((CA::ShapeHandle *)this, v9);
      }
      if (v7 - v13 >= 1) {
        break;
      }
      uint64_t v14 = v9[1];
      if (((v7 - v13) & 0x80000000) == 0)
      {
        float64x2_t v6 = (char *)v9;
        v9 += v14;
        goto LABEL_14;
      }
      LODWORD(v15) = v11[1];
      float64x2_t v6 = (char *)v9;
      v9 += v14;
      float v16 = v12;
LABEL_15:
      int v17 = v14 - 2;
      unsigned int v18 = v14 - 2 + v15;
      unsigned int v19 = this[1];
      if ((*this)[2] < &v19[v18] - *this)
      {
        if (!CA::ShapeHandle::grow((CA::ShapeHandle *)this, v18)) {
          return CA::ShapeHandle::finish((CA::ShapeHandle *)this, v9);
        }
        unsigned int v19 = this[1];
      }
      int *v19 = v7;
      unsigned int v20 = v19 + 2;
      this[1] = v19 + 2;
      v19[1] = 0;
      unint64_t v21 = (int *)(v6 + 8);
      if (v17)
      {
        int v22 = v15 - 2;
        if (v15 != 2)
        {
          int v23 = 0;
          uint64_t v24 = (int *)(v11 + 2);
          while (1)
          {
            int v25 = *v21;
            int v26 = *v24;
            if (*v21 > *v24) {
              break;
            }
            ++v21;
            --v17;
            int v27 = v23 ^ 1;
            if (((v25 - *v24) & 0x80000000) == 0) {
              goto LABEL_24;
            }
            int v26 = v25;
LABEL_25:
            if (v23 == 1 || v27 == 1)
            {
              *v20++ = v26;
              this[1] = v20;
            }
            if (v17)
            {
              int v23 = v27;
              if (v22) {
                continue;
              }
            }
            goto LABEL_32;
          }
          int v27 = v23;
LABEL_24:
          ++v24;
          --v22;
          v27 ^= 2u;
          goto LABEL_25;
        }
      }
LABEL_32:
      if (v17)
      {
        do
        {
          int v28 = *v21++;
          *v20++ = v28;
          --v17;
        }
        while (v17);
        this[1] = v20;
      }
      uint64_t v29 = this[2];
      unint64_t v30 = this[3];
      unint64_t v31 = (unint64_t)((char *)v20 - (char *)v29) >> 2;
      v29[1] = v31;
      if (v30 && v30[1] == v31)
      {
        uint64_t v32 = 2;
        while (v31 != v32)
        {
          int v33 = v29[v32];
          int v34 = v30[v32++];
          if (v33 != v34) {
            goto LABEL_40;
          }
        }
        this[1] = v29;
      }
      else
      {
LABEL_40:
        this[2] = v20;
        this[3] = v29;
      }
      int v7 = *v9;
      unsigned int v12 = v16;
      if (*v9 == 0x7FFFFFFF) {
        return CA::ShapeHandle::finish((CA::ShapeHandle *)this, v9);
      }
    }
    LODWORD(v14) = *((_DWORD *)v6 + 1);
LABEL_14:
    uint64_t v15 = v12[1];
    float v16 = &v12[v15];
    float v11 = v12;
    int v7 = *v12;
    goto LABEL_15;
  }
  uint64_t v9 = (const int *)v6;
  return CA::ShapeHandle::finish((CA::ShapeHandle *)this, v9);
}

void CA::shape_intersect(CA *this, uint64_t a2, const CA::Shape *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)this;
  if (*(void *)this)
  {
    if (v4 == 1) {
      return;
    }
  }
  else
  {
    int v5 = *(_DWORD *)(v4 + 4);
    if (v5 == 6) {
      return;
    }
    if (v5 != 12) {
      goto LABEL_8;
    }
  }
  if (a2)
  {
    if (a2 == 1) {
      goto LABEL_8;
    }
  }
  else if (*(_DWORD *)(a2 + 4) != 12)
  {
LABEL_8:
    uint64_t v6 = CA::Shape::intersect(*(void *)this, a2);
    CA::Shape::unref((CA::Shape *)v4);
    *(void *)this = v6;
    return;
  }
  if (v4)
  {
    uint64_t v9 = v4 >> 48;
    uint64_t v7 = v4 << 16 >> 48;
    int v10 = ((v4 >> 2) & 0x7FFF) + v7;
    int v8 = (v4 >> 48) + (v4 >> 17);
    if (a2) {
      goto LABEL_12;
    }
  }
  else
  {
    LODWORD(v7) = *(_DWORD *)(v4 + 20);
    LODWORD(v9) = *(_DWORD *)(v4 + 28);
    int v8 = *(_DWORD *)(v4 + 32);
    int v10 = *(_DWORD *)(v4 + 36);
    if (a2)
    {
LABEL_12:
      uint64_t v11 = a2 >> 48;
      uint64_t v12 = a2 << 16 >> 48;
      int v13 = ((a2 >> 2) & 0x7FFF) + v12;
      int v14 = (a2 >> 48) + (a2 >> 17);
      goto LABEL_15;
    }
  }
  LODWORD(v12) = *(_DWORD *)(a2 + 20);
  LODWORD(v11) = *(_DWORD *)(a2 + 28);
  int v14 = *(_DWORD *)(a2 + 32);
  int v13 = *(_DWORD *)(a2 + 36);
LABEL_15:
  if ((int)v9 >= (int)v11)
  {
    if ((int)v7 < (int)v12 || v8 > v14)
    {
      LODWORD(v11) = v9;
    }
    else
    {
      LODWORD(v11) = v9;
      if (v10 <= v13) {
        return;
      }
    }
  }
  if ((int)v7 <= (int)v12) {
    signed int v15 = v12;
  }
  else {
    signed int v15 = v7;
  }
  if (v8 >= v14) {
    int v16 = v14;
  }
  else {
    int v16 = v8;
  }
  if (v10 >= v13) {
    int v10 = v13;
  }
  unsigned int v17 = v16 - v11;
  if (v16 <= (int)v11 || (unsigned int v18 = v10 - v15, v10 <= v15))
  {
    CA::Shape::unref(*(CA::Shape **)this);
    *(void *)this = 1;
  }
  else if ((v4 & 1) != 0 || *(_DWORD *)v4 != 1)
  {
    CA::Shape::unref(*(CA::Shape **)this);
    v19[0] = v11;
    v19[1] = v15;
    v19[2] = v17;
    v19[3] = v18;
    *(void *)this = CA::Shape::new_shape(v19);
  }
  else
  {
    *(_DWORD *)(v4 + 20) = v15;
    *(_DWORD *)(v4 + 28) = v11;
    *(_DWORD *)(v4 + 32) = v16;
    *(_DWORD *)(v4 + 36) = v10;
  }
}

float64x2_t CA::Render::KeyValueArray::get_rect_key(float64x2_t *this, uint64_t a2, const Rect *a3, float64x2_t a4, float64x2_t a5)
{
  unsigned int named_object = CA::Render::KeyValueArray::find_named_object_(a2, (int)a3);
  if ((named_object & 0x80000000) == 0
    && (uint64_t v8 = *(void *)(*(void *)(a2 + 8 * named_object + 24) + 24)) != 0
    && *(unsigned char *)(v8 + 12) == 56
    && *(_DWORD *)(v8 + 16) >= 4u)
  {
    float64x2_t result = *(float64x2_t *)(v8 + 24);
    float64x2_t v10 = vsubq_f64(*(float64x2_t *)(v8 + 40), result);
    *this = result;
    this[1] = v10;
  }
  else
  {
    float64x2_t result = a5;
    *this = a4;
    this[1] = a5;
  }
  return result;
}

uint64_t CA::Render::BackdropGroup::has_consistent_background_color(CA::Render::BackdropGroup *this, uint64_t a2)
{
  unint64_t v2 = 0xCF3CF3CF3CF3CF3DLL * ((a2 - (uint64_t)this) >> 3);
  if (v2 < 2) {
    return 1;
  }
  uint64_t v4 = (float *)((char *)this + 324);
  unint64_t v5 = v2 - 1;
  while (*(v4 - 3) == *((float *)this + 36)
       && *(v4 - 2) == *((float *)this + 37)
       && *(v4 - 1) == *((float *)this + 38)
       && *v4 == *((float *)this + 39))
  {
    v4 += 42;
    if (!--v5) {
      return 1;
    }
  }
  return 0;
}

uint64_t CA::OGL::anonymous namespace'::filters_are_valid(uint64_t result)
{
  if (result)
  {
    unint64_t v1 = *(unsigned int *)(result + 16);
    if (v1)
    {
      if (*(unsigned char *)(*(void *)(result + 24) + 13))
      {
        return 1;
      }
      else
      {
        unint64_t v2 = 0;
        while (v1 - 1 != v2)
        {
          uint64_t v3 = *(void *)(result + 32 + 8 * v2++);
          if (*(unsigned char *)(v3 + 13)) {
            return v2 < v1;
          }
        }
        unint64_t v2 = *(unsigned int *)(result + 16);
        return v2 < v1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CA::OGL::anonymous namespace'::collect_surfaces(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unsigned char *a5)
{
  if (!a1) {
    return 0;
  }
  uint64_t v9 = a1;
  uint64_t v10 = 0;
  while (1)
  {
    BOOL v12 = (int)v10 >= 1
       && (uint64_t v11 = *(void *)(a2 + 8 * (v10 - 1))) != 0
       && (*(_WORD *)(v11 + 75) & 0x800) != 0
       && CA::BoundsImpl::contains((_DWORD *)(v11 + 32), (_DWORD *)(v9 + 32));
    __int16 v13 = *(_WORD *)(v9 + 75);
    if ((v13 & 0x80) != 0 && !(((v13 & 0x60) != 0) & (a4 ^ 1) | v12))
    {
      a4 = 0;
      *(void *)(a2 + 8 * (int)v10) = v9;
      *(_OWORD *)(a3 + 16 * (int)v10) = *(_OWORD *)(v9 + 32);
      uint64_t v10 = (v10 + 1);
      __int16 v13 = *(_WORD *)(v9 + 75);
    }
    if ((v13 & 0x400) != 0) {
      break;
    }
    uint64_t v9 = *(void *)(v9 + 8);
    if (!v9 || (int)v10 > 7) {
      return v10;
    }
  }
  *a5 = 1;
  return v10;
}

uint64_t CA::WindowServer::anonymous namespace'::OGLDisplay::foreach_detached_layer_geometry(CA::WindowServer::_anonymous_namespace_::OGLDisplay *this, void (*a2)(Handle *, uint64_t, CA::Render::Texture *, Rect, Rect, unsigned int, void *), void *a3)
{
  return (*(uint64_t (**)(void, void (*)(Handle *, uint64_t, CA::Render::Texture *, Rect, Rect, unsigned int, void *), void *))(**((void **)this + 1) + 608))(*((void *)this + 1), a2, a3);
}

void CA::WindowServer::IOMFBDisplay::foreach_detached_layer_geometry(CA::WindowServer::IOMFBDisplay *this, void (__high *a2)(CA::Render::Handle *, uint64_t, CA::Render::Texture *, CA::Rect, CA::Rect, unsigned int, void *), void *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (uint64_t *)*((void *)this + 3255);
  if (v3 && (*((unsigned char *)v3 + 292) & 1) == 0)
  {
    uint64_t v5 = *v3;
    if (*v3)
    {
      uint64_t v8 = *((int *)v3 + 72);
      uint64_t v9 = v3[1];
      long long v10 = *((_OWORD *)v3 + 5);
      v13[0] = *((_OWORD *)v3 + 4);
      v13[1] = v10;
      long long v11 = *((_OWORD *)v3 + 7);
      v12[0] = *((_OWORD *)v3 + 6);
      v12[1] = v11;
      ((void (*)(uint64_t, uint64_t, uint64_t, _OWORD *, _OWORD *, void, void *))a2)(v5, v8, v9, v13, v12, *((unsigned int *)v3 + 8), a3);
    }
    else
    {
      CA::WindowServer::IOMFBDisplay::delete_detached_layer(this);
    }
  }
}

uint64_t CA::OGL::GaussianBlurFilter::get_edge_info(uint64_t a1, const CA::Render::Filter *a2, const CA::Render::Layer *a3, uint64_t a4, Rect *a5, float *a6, BOOL *a7)
{
  v22[1] = *(double *)MEMORY[0x1E4F143B8];
  uint64_t v12 = *(void *)(*(void *)(a4 + 248) + 24);
  double v21 = 0.0;
  v22[0] = 0.0;
  if ((*(unsigned char *)(v12 + 144) & 0x10) != 0)
  {
    CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v12, v22, &v21, (double *)a4);
    double v13 = v21;
    double v14 = v22[0];
  }
  else
  {
    double v13 = *(double *)(v12 + 128);
    double v21 = v13;
    v22[0] = v13;
    double v14 = v13;
  }
  float v15 = v14;
  float v16 = v13;
  unsigned int v17 = (CA::Render::KeyValueArray *)*((void *)a2 + 5);
  float v18 = CA::Render::KeyValueArray::get_float_key(v17, 310, 0.0) * 2.79999995;
  *a6 = v18 * v15;
  a6[1] = v18 * v16;
  int_key = (CA::OGL::GaussianBlurFilter *)CA::Render::KeyValueArray::get_int_key(v17, 305, 0);
  *a7 = int_key != 0;
  return CA::OGL::GaussianBlurFilter::get_bounds(int_key, a2, a3, a5);
}

double CA::OGL::Context::array_check(CA::OGL::Context *this, int a2)
{
  if (*((_DWORD *)this + 23)) {
    unsigned int v3 = 6 * a2;
  }
  else {
    unsigned int v3 = 4 * a2;
  }
  if (*((void *)this + 16) + (unint64_t)(4 * a2) > *((void *)this + 17)
    || (unint64_t v4 = *((void *)this + 14)) != 0 && *((void *)this + 13) + (unint64_t)v3 > v4)
  {
    *((_WORD *)this + 416) |= 0x20u;
    CA::OGL::Context::array_flush((uint64_t)this);
    *((void *)this + 16) = 0;
    *((void *)this + 12) = (char *)this + 834;
    double result = 0.0;
    *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
  }
  return result;
}

BOOL x_log_hook_p()
{
  if (x_log_once != -1) {
    dispatch_once_f(&x_log_once, 0, (dispatch_function_t)x_log_init);
  }
  return x_log_stream_slot && pthread_getspecific(x_log_stream_slot)
      || __PAIR128__((unint64_t)x_log_function, x_log_file_handle) != 0;
}

void CA::OGL::anonymous namespace'::release_buffer_surfaces(CA::OGL::_anonymous_namespace_ *this, CA::OGL::Context *a2, CA::OGL::BackdropBuffer *a3)
{
  CA::OGL::Context::release_surface((uint64_t)this, *((void *)a2 + 4));
  *((void *)a2 + 4) = 0;
  *((unsigned char *)a2 + 216) &= ~2u;
  uint64_t v5 = *((void *)a2 + 5);
  if (v5)
  {
    CA::OGL::Context::release_surface((uint64_t)this, v5);
    *((void *)a2 + 5) = 0;
  }
}

void CA::OGL::PingPongState::~PingPongState(CA::OGL::PingPongState *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    CA::OGL::Context::release_surface(*(void *)this, v2);
  }
  uint64_t v3 = *((void *)this + 11);
  if (v3) {
    CA::OGL::Context::release_surface(*(void *)this, v3);
  }
  unint64_t v4 = (CA::Shape *)*((void *)this + 5);
  if (v4) {
    CA::Shape::unref(v4);
  }
}

void CA::OGL::Context::release_surface(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)a2)-- == 1)
  {
    uint64_t v5 = *(void *)(a2 + 56);
    if (v5)
    {
      os_signpost_id_t v6 = *(unsigned int *)(a1 + 228);
      if (v6)
      {
        uint64_t v7 = CA::OGL::Context::_trace_log;
        if (os_signpost_enabled((os_log_t)CA::OGL::Context::_trace_log))
        {
          int v8 = *(_DWORD *)(a2 + 40);
          int v9 = *(_DWORD *)(a2 + 44);
          int v10 = *(_DWORD *)(a2 + 68);
          int v11 = (*(unsigned __int16 *)(a2 + 75) >> 13) & 1;
          v13[0] = 67241216;
          v13[1] = v8;
          __int16 v14 = 1026;
          int v15 = v9;
          __int16 v16 = 1026;
          int v17 = v10;
          __int16 v18 = 1026;
          int v19 = v11;
          __int16 v20 = 2050;
          uint64_t v21 = v5;
          _os_signpost_emit_with_name_impl(&dword_184668000, v7, OS_SIGNPOST_EVENT, v6, "Surface", "ID is update width=%{public,name=width}d height=%{public,name=height}d features=%{public,name=features}#x recycled=%{public,name=recycled,BOOL}d begin=%{public,signpost.description:begin_time}llu", (uint8_t *)v13, 0x24u);
        }
      }
    }
    if (*(void *)(a1 + 272) == a2) {
      (*(void (**)(uint64_t))(*(void *)a1 + 392))(a1);
    }
    if ((*(_WORD *)(a2 + 75) & 0x100) != 0)
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 736))(a1, a2);
    }
    else
    {
      if ((*(_WORD *)(a2 + 75) & 0x1000) != 0) {
        int v12 = 40;
      }
      else {
        int v12 = 4;
      }
      *(_DWORD *)a2 = v12;
      *(void *)(a2 + 8) = *(void *)(a1 + 80);
      *(void *)(a1 + 80) = a2;
    }
  }
}

void CA::OGL::anonymous namespace'::capture_detached(uint64_t a1, uint64_t a2, uint32x2_t *a3, double *a4, float64x2_t *a5, char a6, uint64_t a7)
{
  uint64_t v146 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    int v11 = a3;
    uint64_t v12 = *(void *)a7;
    if (a3[1].i8[4] == 51)
    {
      float64x2_t v13 = a5[1];
      int64x2_t v14 = vceqzq_f64(v13);
      int8x16_t v136 = 0u;
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v14, 1), (int8x16_t)v14).u64[0] & 0x8000000000000000) == 0)
      {
        int8x16_t v15 = vorrq_s8((int8x16_t)vcltzq_f64(v13), (int8x16_t)vcgezq_f64(v13));
        if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v15), 1), v15).u64[0] & 0x8000000000000000) == 0)
        {
          int32x4_t v16 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(*a5, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
          int8x16_t v136 = (int8x16_t)vuzp1q_s32(v16, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(*a5, v13), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v16));
        }
      }
      long long v140 = 0uLL;
      unint64_t v17 = *(void *)(a7 + 8);
      uint64_t v145 = 0;
      float32x4_t v144 = (float32x4_t)v17;
      if ((*(unsigned int (**)(uint32x2_t *))(*(void *)a3 + 280))(a3))
      {
        int32x2_t v18 = (int32x2_t)vextq_s8(v136, v136, 8uLL).u64[0];
        uint32x2_t v19 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v18);
        int32x2_t v20 = vadd_s32(*(int32x2_t *)v136.i8, v18);
        unsigned __int32 v138 = vpmax_u32(v19, v19).u32[0];
        while (1)
        {
          do
          {
            if (!CA::ShapeIterator::iterate((uint64_t *)&v144, (int *)&v140)) {
              goto LABEL_36;
            }
            uint32x2_t v21 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v140 + 8));
          }
          while ((vpmax_u32(v21, v21).u32[0] & 0x80000000) != 0);
          if ((v138 & 0x80000000) == 0)
          {
            *(int32x2_t *)&long long v22 = vmax_s32(*(int32x2_t *)&v140, *(int32x2_t *)v136.i8);
            int32x2_t v23 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)&v140, *(int32x2_t *)((char *)&v140 + 8)), v20), *(int32x2_t *)&v22);
            uint32x2_t v24 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v23);
            if ((vpmax_u32(v24, v24).u32[0] & 0x80000000) == 0) {
              break;
            }
          }
          *((void *)&v140 + 1) = 0;
        }
        *((int32x2_t *)&v22 + 1) = v23;
        long long v140 = v22;
        int v25 = (uint32x2_t *)v11[20];
        if (v25) {
          goto LABEL_37;
        }
        if (BYTE12(xmmword_1EB2ACC30))
        {
          if (x_log_hook_p())
          {
            uint64_t v125 = v11[13].u32[0];
            x_log_();
          }
          else
          {
            double v123 = x_log_category_ogl;
            if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEBUG))
            {
              __int32 v124 = v11[13].i32[0];
              *(_DWORD *)int32x2_t v143 = 67109120;
              *(_DWORD *)&v143[4] = v124;
              _os_log_impl(&dword_184668000, v123, OS_LOG_TYPE_DEBUG, "Cannot Display TM (capture_detached), OnDemand MSR/GPU TM on surface (0x%x)", v143, 8u);
            }
          }
        }
        memset(v143, 0, sizeof(v143));
        int v26 = (atomic_uint *)v11[21];
        if (v26)
        {
          atomic_fetch_add(v26 + 4, 1u);
          long long v27 = *(_OWORD *)v11[32].i8;
          *(_OWORD *)&v143[72] = *(_OWORD *)v11[30].i8;
          long long v28 = *(_OWORD *)v11[26].i8;
          *(_OWORD *)&v143[56] = *(_OWORD *)v11[28].i8;
          *(_OWORD *)&v143[40] = v28;
          long long v29 = *(_OWORD *)v11[22].i8;
          *(_OWORD *)&v143[24] = *(_OWORD *)v11[24].i8;
          long long v30 = *(_OWORD *)v11[34].i8;
          *(_OWORD *)&v143[120] = *(_OWORD *)v11[36].i8;
          *(_OWORD *)&v143[104] = v30;
          *(_OWORD *)&v143[88] = v27;
          *(void *)int32x2_t v143 = v26;
          v143[136] = v11[38].u8[0];
          *(_OWORD *)&v143[8] = v29;
          uint64_t v31 = *(void *)(v12 + 216);
          uint64_t v32 = (*(uint64_t (**)(atomic_uint *, uint64_t))(*(void *)v26 + 56))(v26, v31);
          uint64_t v33 = v143[136];
          uint64_t v34 = (*(uint64_t (**)(uint32x2_t *))(*(void *)v11 + 256))(v11);
          LOWORD(v125) = 1;
          long long v35 = (CA::Render::Surface *)(*(uint64_t (**)(atomic_uint *, uint32x2_t *, uint64_t, uint8_t *, uint64_t, void, uint64_t, uint64_t, float, uint64_t))(*(void *)v26 + 24))(v26, v11, v31, &v143[8], v32, 0, v33, v34, 1.0, v125);
          if (v35)
          {
            long long v36 = (atomic_uint *)v35;
            CA::Render::Surface::set_tonemapped_surface((CA::Render::Surface *)v11, v35);
            if (atomic_fetch_add(v36 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v36 + 16))(v36);
            }
LABEL_28:
            uint64_t v47 = *(void *)v143;
            if (*(void *)v143 && atomic_fetch_add((atomic_uint *volatile)(*(void *)v143 + 16), 0xFFFFFFFF) == 1) {
              (*(void (**)(uint64_t))(*(void *)v47 + 8))(v47);
            }
            int v25 = (uint32x2_t *)v11[20];
            if (!v25)
            {
              if (x_log_hook_p())
              {
                x_log_();
              }
              else
              {
                int32x4_t v48 = x_log_category_ogl;
                if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR))
                {
                  __int32 v49 = v11[13].i32[0];
                  *(_DWORD *)int32x2_t v143 = 67109120;
                  *(_DWORD *)&v143[4] = v49;
                  _os_log_impl(&dword_184668000, v48, OS_LOG_TYPE_ERROR, "No valid tonemapped surface available for 0x%x", v143, 8u);
                }
              }
              goto LABEL_36;
            }
            goto LABEL_37;
          }
          if (x_log_hook_p())
          {
LABEL_20:
            x_log_();
            goto LABEL_28;
          }
          uint64_t v45 = x_log_category_ogl;
          if (!os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR)) {
            goto LABEL_28;
          }
          __int32 v46 = v11[13].i32[0];
          *(_DWORD *)buf = 67109120;
          int v142 = v46;
          float v42 = "Failed to tonemap surface 0x%x";
          float v43 = v45;
          uint32_t v44 = 8;
        }
        else
        {
          long long v37 = *(_OWORD *)v11[30].i8;
          *(_OWORD *)&v143[88] = *(_OWORD *)v11[32].i8;
          long long v38 = *(_OWORD *)v11[36].i8;
          *(_OWORD *)&v143[104] = *(_OWORD *)v11[34].i8;
          *(_OWORD *)&v143[120] = v38;
          long long v39 = *(_OWORD *)v11[22].i8;
          *(_OWORD *)&v143[24] = *(_OWORD *)v11[24].i8;
          long long v40 = *(_OWORD *)v11[28].i8;
          *(_OWORD *)&v143[40] = *(_OWORD *)v11[26].i8;
          *(_OWORD *)&v143[56] = v40;
          *(_OWORD *)&v143[72] = v37;
          v143[136] = v11[38].u8[0];
          *(_OWORD *)&v143[8] = v39;
          if (x_log_hook_p()) {
            goto LABEL_20;
          }
          uint64_t v41 = x_log_category_ogl;
          if (!os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR)) {
            goto LABEL_28;
          }
          *(_WORD *)buf = 0;
          float v42 = "Could not tonemap surface because of invalid configuration";
          float v43 = v41;
          uint32_t v44 = 2;
        }
        _os_log_impl(&dword_184668000, v43, OS_LOG_TYPE_ERROR, v42, buf, v44);
        goto LABEL_28;
      }
LABEL_36:
      int v25 = v11;
LABEL_37:
      int v11 = v25;
    }
    float32x4_t v144 = 0uLL;
    float64x2_t v50 = CA::OGL::Context::bind_image(v12, 0, v11, (double *)0x3F, 1u, 1, 0, 0, 0.0, &v144, 0);
    if (v50)
    {
      double v135 = v50;
      if (*(unsigned char *)(a7 + 56))
      {
        char v134 = a6;
        *(unsigned char *)(*(void *)(v12 + 16) + 16) = 0;
        *(void *)(v12 + 128) = 0;
        *(void *)(v12 + 96) = v12 + 834;
        *(_OWORD *)(v12 + 104) = xmmword_184997E70;
        long long v140 = 0uLL;
        uint64_t v51 = *(void *)(a7 + 8);
        *(void *)&v143[8] = 0;
        *(void *)&v143[16] = 0;
        *(void *)int32x2_t v143 = v51;
        while (CA::ShapeIterator::iterate((uint64_t *)v143, (int *)&v140))
        {
          int v53 = v140;
          int v52 = DWORD1(v140);
          int v54 = DWORD2(v140);
          int v55 = HIDWORD(v140);
          if (*(_DWORD *)(v12 + 92)) {
            uint64_t v56 = 6;
          }
          else {
            uint64_t v56 = 4;
          }
          if ((unint64_t)(*(void *)(v12 + 128) + 4) > *(void *)(v12 + 136)
            || (unint64_t v57 = *(void *)(v12 + 112)) != 0 && *(void *)(v12 + 104) + v56 > v57)
          {
            *(_WORD *)(v12 + 832) |= 0x20u;
            CA::OGL::Context::array_flush(v12);
            *(void *)(v12 + 128) = 0;
            *(void *)(v12 + 96) = v12 + 834;
            *(_OWORD *)(v12 + 104) = xmmword_184997E70;
          }
          CA::OGL::Context::array_rect((void *)v12, *(float *)(a7 + 16) * (float)v53, *(float *)(a7 + 16) * (float)v52, *(float *)(a7 + 16) * (float)(v54 + v53), *(float *)(a7 + 16) * (float)(v55 + v52));
          uint64_t v58 = *(void *)(v12 + 120) + 48 * *(void *)(v12 + 128);
          *(void *)(v58 - 160) = 0;
          *(void *)(v58 - 112) = 0;
          *(void *)(v58 - 64) = 0;
          *(void *)(v58 - 16) = 0;
        }
        CA::OGL::Context::array_flush(v12);
        a6 = v134;
      }
      *(unsigned char *)(*(void *)(v12 + 16) + 16) = 1;
      *(void *)(v12 + 128) = 0;
      *(void *)(v12 + 96) = v12 + 834;
      *(_OWORD *)(v12 + 104) = xmmword_184997E70;
      float64x2_t v59 = a5[1];
      int64x2_t v60 = vceqzq_f64(v59);
      int8x16_t v137 = 0u;
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v60, 1), (int8x16_t)v60).u64[0] & 0x8000000000000000) == 0)
      {
        int8x16_t v61 = vorrq_s8((int8x16_t)vcltzq_f64(v59), (int8x16_t)vcgezq_f64(v59));
        if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v61), 1), v61).u64[0] & 0x8000000000000000) == 0)
        {
          int32x4_t v62 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(*a5, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
          int8x16_t v137 = (int8x16_t)vuzp1q_s32(v62, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(*a5, v59), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v62));
        }
      }
      uint64_t v63 = 0;
      long long v140 = 0uLL;
      uint64_t v64 = *(void *)(a7 + 8);
      *(void *)&v143[8] = 0;
      *(void *)&v143[16] = 0;
      *(void *)int32x2_t v143 = v64;
      int32x2_t v65 = (int32x2_t)vextq_s8(v137, v137, 8uLL).u64[0];
      uint32x2_t v66 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v65);
      int32x2_t v67 = vadd_s32(*(int32x2_t *)v137.i8, v65);
      unsigned __int32 v139 = vpmax_u32(v66, v66).u32[0];
      float v68 = 1.0;
      while (CA::ShapeIterator::iterate((uint64_t *)v143, (int *)&v140))
      {
        uint32x2_t v69 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v140 + 8));
        if ((vpmax_u32(v69, v69).u32[0] & 0x80000000) == 0)
        {
          if ((v139 & 0x80000000) != 0
            || (int32x2_t v70 = vmax_s32(*(int32x2_t *)&v140, *(int32x2_t *)v137.i8),
                int32x2_t v71 = vmin_s32(vadd_s32(*(int32x2_t *)&v140, *(int32x2_t *)((char *)&v140 + 8)), v67),
                int32x2_t v72 = vsub_s32(v71, v70),
                uint32x2_t v73 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v72),
                (vpmax_u32(v73, v73).u32[0] & 0x80000000) != 0))
          {
            *((void *)&v140 + 1) = 0;
          }
          else
          {
            *(int32x2_t *)&long long v74 = v70;
            *((int32x2_t *)&v74 + 1) = v72;
            float v75 = (float)v70.i32[0];
            long long v140 = v74;
            float v76 = (float)v70.i32[1];
            float v77 = (float)v71.i32[0];
            float v78 = (float)v71.i32[1];
            float v79 = *(float *)(a7 + 16);
            if (v79 != v68)
            {
              float v80 = v68 / v79;
              float v81 = floorf(v79 * v75) * (float)(v68 / v79);
              float v82 = floorf(v79 * v76) * (float)(v68 / v79);
              float v83 = ceilf(v79 * v77) * (float)(v68 / v79);
              float v84 = ceilf(v79 * v78) * (float)(v68 / v79);
              double v85 = *(double *)(a7 + 24);
              double v86 = *(double *)(a7 + 32);
              if (v85 == v81) {
                float v87 = v68 / v79;
              }
              else {
                float v87 = 0.0;
              }
              float v75 = v81 - v87;
              if (v86 == v82) {
                float v88 = v68 / v79;
              }
              else {
                float v88 = 0.0;
              }
              float v76 = v82 - v88;
              if (*(double *)(a7 + 40) + v85 == v83) {
                float v89 = v68 / v79;
              }
              else {
                float v89 = -0.0;
              }
              float v77 = v89 + v83;
              if (*(double *)(a7 + 48) + v86 != v84) {
                float v80 = -0.0;
              }
              float v78 = v80 + v84;
            }
            double v90 = a5->f64[1];
            double v91 = a5[1].f64[0];
            double v92 = a5[1].f64[1];
            double v93 = (v75 - a5->f64[0]) / v91;
            *(float *)&double v93 = v93;
            float v94 = (v76 - v90) / v92;
            float v95 = (v77 - a5->f64[0]) / v91;
            double v96 = (v78 - v90) / v92;
            *(float *)&double v96 = v96;
            float v97 = v68 - v94;
            if (a6) {
              *(float *)&double v96 = v68 - *(float *)&v96;
            }
            else {
              float v97 = v94;
            }
            if ((a6 & 2) != 0)
            {
              *(float *)&double v93 = v68 - *(float *)&v93;
              float v95 = v68 - v95;
            }
            float v98 = v68 - *(float *)&v93;
            if ((a6 & 4) != 0) {
              float v99 = v97;
            }
            else {
              float v99 = *(float *)&v93;
            }
            if ((a6 & 4) != 0) {
              float v100 = v68 - v95;
            }
            else {
              float v100 = v97;
            }
            if ((a6 & 4) != 0) {
              float v101 = *(float *)&v96;
            }
            else {
              float v101 = v95;
            }
            if ((a6 & 4) == 0) {
              float v98 = *(float *)&v96;
            }
            double v102 = *a4;
            double v103 = a4[1];
            LODWORD(v93) = v11[2].i32[0];
            LODWORD(v96) = v11[2].i32[1];
            double v104 = a4[2];
            double v105 = a4[3];
            if (*(_DWORD *)(v12 + 92)) {
              uint64_t v106 = 6;
            }
            else {
              uint64_t v106 = 4;
            }
            if ((unint64_t)(v63 + 4) > *(void *)(v12 + 136)
              || (unint64_t v107 = *(void *)(v12 + 112)) != 0 && *(void *)(v12 + 104) + v106 > v107)
            {
              *(_WORD *)(v12 + 832) |= 0x20u;
              float v130 = v75;
              float v128 = v77;
              float v108 = v78;
              float v132 = v100;
              float v133 = v98;
              float v109 = v101;
              double v131 = v103;
              double v129 = v105;
              double v126 = v93;
              double v127 = v96;
              CA::OGL::Context::array_flush(v12);
              double v105 = v129;
              double v103 = v131;
              float v100 = v132;
              float v98 = v133;
              float v101 = v109;
              float v78 = v108;
              float v77 = v128;
              float v75 = v130;
              *(void *)(v12 + 128) = 0;
              *(void *)(v12 + 96) = v12 + 834;
              *(_OWORD *)(v12 + 104) = xmmword_184997E70;
              double v93 = v126;
              double v96 = v127;
              float v79 = *(float *)(a7 + 16);
            }
            double v110 = (double)*(unint64_t *)&v93;
            float v111 = v102 / v110;
            double v112 = (double)*(unint64_t *)&v96;
            float v113 = v103 / v112;
            *(float *)&double v110 = (v104 + v102) / v110;
            *(float *)&double v112 = (v105 + v103) / v112;
            *(float *)&double v110 = *(float *)&v110 - v111;
            float v114 = v111 + (float)(*(float *)&v110 * v99);
            *(float *)&double v112 = *(float *)&v112 - v113;
            float v115 = v113 + (float)(*(float *)&v112 * v100);
            float v116 = v111 + (float)(*(float *)&v110 * v101);
            float v117 = v113 + (float)(*(float *)&v112 * v98);
            CA::OGL::Context::array_rect((void *)v12, v79 * v75, v79 * v76, v79 * v77, v79 * v78);
            if ((a6 & 4) != 0) {
              float v118 = v117;
            }
            else {
              float v118 = v115;
            }
            if ((a6 & 4) != 0) {
              float v119 = v114;
            }
            else {
              float v119 = v116;
            }
            if ((a6 & 4) != 0) {
              float v120 = v115;
            }
            else {
              float v120 = v117;
            }
            if ((a6 & 4) != 0) {
              float v121 = v116;
            }
            else {
              float v121 = v114;
            }
            uint64_t v63 = *(void *)(v12 + 128);
            uint64_t v122 = *(void *)(v12 + 120) + 48 * v63;
            *(float *)(v122 - 176) = v114;
            *(float *)(v122 - 172) = v118;
            *(float *)(v122 - 128) = v119;
            *(float *)(v122 - 124) = v115;
            *(float *)(v122 - 80) = v116;
            *(float *)(v122 - 76) = v120;
            *(float *)(v122 - 32) = v121;
            *(float *)(v122 - 28) = v117;
            **(unsigned char **)(a7 + 64) = 1;
            float v68 = 1.0;
          }
        }
      }
      CA::OGL::Context::array_flush(v12);
      (*(void (**)(uint64_t, _OWORD *, void))(*(void *)v12 + 520))(v12, v135, 0);
    }
  }
}

uint64_t CA::OGL::VariableBlurFilter::get_edge_info(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, float *a6)
{
  v16[1] = *(double *)MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(*(void *)(a4 + 248) + 24);
  double v15 = 0.0;
  v16[0] = 0.0;
  if ((*(unsigned char *)(v8 + 144) & 0x10) != 0)
  {
    CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v8, v16, &v15, (double *)a4);
    double v9 = v15;
    double v10 = v16[0];
  }
  else
  {
    double v9 = *(double *)(v8 + 128);
    double v15 = v9;
    v16[0] = v9;
    double v10 = v9;
  }
  float v11 = v10;
  float v12 = v9;
  float v13 = CA::Render::KeyValueArray::get_float_key(*(CA::Render::KeyValueArray **)(a2 + 40), 310, 0.0) * 5.5999999;
  *a6 = v13 * v11;
  a6[1] = v13 * v12;
  return 0;
}

void CA::OGL::MetalContext::detach_surface(CA::OGL::MetalContext *this)
{
  if (!*(void *)(*((void *)this + 34) + 200)) {
    CA::OGL::MetalContext::stop_encoders(this);
  }
  *((void *)this + 34) = 0;
  *((void *)this + 499) = 0;
}

uint64_t CABackingStoreCreate()
{
  if (memory_once != -1) {
    dispatch_once_f(&memory_once, 0, (dispatch_function_t)register_memory_handler);
  }
  if (CABackingStoreGetTypeID::once[0] != -1) {
    dispatch_once(CABackingStoreGetTypeID::once, &__block_literal_global_907);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v1 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 464) = 0u;
    *(_OWORD *)(Instance + 480) = 0u;
    *(_OWORD *)(Instance + 432) = 0u;
    *(_OWORD *)(Instance + 448) = 0u;
    *(_OWORD *)(Instance + 400) = 0u;
    *(_OWORD *)(Instance + 416) = 0u;
    *(_OWORD *)(Instance + 368) = 0u;
    *(_OWORD *)(Instance + 384) = 0u;
    *(_OWORD *)(Instance + 336) = 0u;
    *(_OWORD *)(Instance + 352) = 0u;
    *(_OWORD *)(Instance + 304) = 0u;
    *(_OWORD *)(Instance + 320) = 0u;
    *(_OWORD *)(Instance + 272) = 0u;
    *(_OWORD *)(Instance + 288) = 0u;
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 224) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    pthread_mutex_init((pthread_mutex_t *)(Instance + 16), 0);
    pthread_cond_init((pthread_cond_t *)(v1 + 80), 0);
    uint64_t v2 = (CGColorSpace *)CAGetColorSpace(0x1Du);
    *(void *)(v1 + 160) = CGColorSpaceRetain(v2);
    pthread_mutex_lock(&buffer_list_mutex);
    uint64_t v3 = buffer_list;
    if (buffer_list) {
      *(void *)(buffer_list + 176) = v1;
    }
    uint64_t v4 = 0;
    *(void *)(v1 + 168) = v3;
    buffer_list = v1;
    uint64_t v5 = *(void *)(v1 + 400);
    do
    {
      *(void *)(v1 + v4 + 184) = v5;
      uint64_t v6 = v1 + v4 + 184;
      v4 += 72;
      uint64_t v5 = v6;
    }
    while (v4 != 216);
    *(void *)(v1 + 400) = v1 + 328;
    pthread_mutex_unlock(&buffer_list_mutex);
  }
  return v1;
}

void CACGContextEvaluator::CACGContextEvaluator(CACGContextEvaluator *this, uint64_t a2, uint64_t a3, CGColorSpace *a4)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((void *)this + 2) = a4;
  *((void *)this + 3) = CAColorSpaceCreateExtended(a4);
  *((void *)this + 4) = CGDisplayListCreateWithRect();
  *((void *)this + 5) = CGDisplayListContextCreate();
  uint64_t Delegate = CGContextGetDelegate();
  *((_DWORD *)this + 21) = 0;
  *((void *)this + 6) = Delegate;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((_WORD *)this + 40) = 0;
  CGContextDelegateCreate();
  CGContextDelegateSetCallbacks();
  *((void *)this + 7) = CGContextCreateWithDelegate();
  CGContextDelegateRelease();
}

CGColorSpaceRef CAColorSpaceCreateExtended(CGColorSpace *a1)
{
  if ((CGColorSpace *)CAGetColorSpace(0x1Du) == a1 || (CGColorSpace *)CAGetColorSpace(0x1Cu) == a1)
  {
    uint64_t v5 = (CGColorSpace *)CAGetColorSpace(0x1Cu);
    return CGColorSpaceRetain(v5);
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CAColorSpaceCreateExtended::lock);
    Extended = (CGColorSpace *)CAColorSpaceCreateExtended::extended;
    if ((CGColorSpace *)CAColorSpaceCreateExtended::base != a1)
    {
      CGColorSpaceRelease((CGColorSpaceRef)CAColorSpaceCreateExtended::extended);
      CAColorSpaceCreateExtended::base = (uint64_t)a1;
      Extended = CGColorSpaceCreateExtended(a1);
      CAColorSpaceCreateExtended::extended = (uint64_t)Extended;
      if (!Extended)
      {
        Extended = CGColorSpaceRetain(a1);
        CAColorSpaceCreateExtended::extended = (uint64_t)Extended;
      }
    }
    CGColorSpaceRef v3 = CGColorSpaceRetain(Extended);
    os_unfair_lock_unlock((os_unfair_lock_t)&CAColorSpaceCreateExtended::lock);
    return v3;
  }
}

atomic_uint *CA::Render::prepare_image(CA::Render *this, CGImage *a2, CGColorSpace *a3, double a4)
{
  double result = (atomic_uint *)CA::Render::copy_image(this, a2, a3, 0.0, 1.0);
  if (result && atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1)
  {
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)result + 16);
    return (atomic_uint *)v5();
  }
  return result;
}

void CA::Render::convert_cgcolor_to_float(CGColor *cf, CGColor *a2, CGColorSpace *a3, float *a4, CA::Render::Pattern **a5)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (CADeviceUseCIF10::once != -1) {
    dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_12019);
  }
  if (CADeviceUseCIF10::enable_cif10)
  {
    double v9 = (const void *)CAGetColorSpace(0x1Du);
    if (CFEqual(a2, v9)) {
      a2 = (CGColor *)CAGetColorSpace(0x1Cu);
    }
  }
  if (CA::Render::initialize_types(void)::once[0] == -1)
  {
    if (!cf) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(CA::Render::initialize_types(void)::once, &__block_literal_global_5);
    if (!cf) {
      goto LABEL_27;
    }
  }
  if (CFGetTypeID(cf) == CA::Render::color_type && CGColorGetAlpha(cf) > 0.0)
  {
    Pattern = CGColorGetPattern(cf);
    if (Pattern)
    {
      if (a4) {
        *(void *)a4 = CA::Render::Pattern::new_pattern(Pattern, a2, 0, 0, 0.0);
      }
      if (CGPatternIsColored())
      {
        CGFloat Alpha = CGColorGetAlpha(cf);
        if (Alpha > 1.0) {
          CGFloat Alpha = 1.0;
        }
        if (Alpha < 0.0) {
          CGFloat Alpha = 0.0;
        }
        *(float *)&CGFloat Alpha = Alpha;
        _Q0 = vdupq_lane_s32(*(int32x2_t *)&Alpha, 0);
        goto LABEL_25;
      }
      PatternBaseColor = (CGColor *)CGColorGetPatternBaseColor();
      if (!PatternBaseColor)
      {
        __asm { FMOV            V0.4S, #1.0 }
LABEL_25:
        *(int32x4_t *)a3 = _Q0;
        return;
      }
      float64x2_t v20 = 0u;
      float64x2_t v21 = 0u;
      CA_CGColorGetRGBComponents(PatternBaseColor, a2, v20.f64);
      float32x2_t v13 = vcvt_f32_f64(v20);
      float32x2_t v14 = vcvt_f32_f64(v21);
      *(float32x4_t *)a3 = vcvt_hight_f32_f64((int32x2_t)v13, v21);
    }
    else
    {
      float64x2_t v20 = 0u;
      float64x2_t v21 = 0u;
      CA_CGColorGetRGBComponents(cf, a2, v20.f64);
      float32x2_t v13 = vcvt_f32_f64(v20);
      float32x2_t v14 = vcvt_f32_f64(v21);
      *(float32x4_t *)a3 = vcvt_hight_f32_f64((int32x2_t)v13, v21);
      if (a4) {
        *(void *)a4 = 0;
      }
    }
    *(float32x2_t *)a3 = vmul_lane_f32(v13, v14, 1);
    *((_DWORD *)a3 + 2) = vmul_lane_f32(v14, v14, 1).u32[0];
    return;
  }
LABEL_27:
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
  if (a4) {
    *(void *)a4 = 0;
  }
}

void *CA::Render::copy_image(CA::Render *this, CGImage *a2, CGColorSpace *a3, double a4, double a5)
{
  int v7 = (int)a3;
  uint64_t v198 = *MEMORY[0x1E4F143B8];
  double v10 = (CGImage *)(a3 | 8);
  ColorSpace = CGImageGetColorSpace(this);
  if (ColorSpace)
  {
    BaseColorSpace = ColorSpace;
    if (!CGColorSpaceUsesITUR_2100TF(ColorSpace)) {
      CGImageGetHeadroom();
    }
    while (1)
    {
      CGColorSpaceModel Model = CGColorSpaceGetModel(BaseColorSpace);
      if (Model != kCGColorSpaceModelIndexed) {
        break;
      }
      BaseColorSpace = CGColorSpaceGetBaseColorSpace(BaseColorSpace);
      if (!BaseColorSpace) {
        goto LABEL_10;
      }
    }
    if (Model <= kCGColorSpaceModelRGB && CGColorSpaceSupportsOutput(BaseColorSpace)) {
      a2 = BaseColorSpace;
    }
  }
LABEL_10:
  if ((v7 & 0x100) != 0)
  {
    float v190 = 0;
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    if (CGImageIsSubimage()
      && (Property = (const void *)CGImageGetProperty()) != 0
      && CA_CFBoolValue(Property))
    {
      uint64_t v16 = CA::Render::copy_image(v190, a2, (CGColorSpace *)(v7 | 0x208u), v15, a4, a5);
      if (v16)
      {
        unint64_t v17 = (atomic_uint *)v16;
        if ((*(unsigned char *)(v16 + 13) & 0x64) != 0) {
          __assert_rtn("copy_image", "render-image-cache.cpp", 1761, "!main_texture->has_display_transform ()");
        }
        unsigned int Width = CGImageGetWidth(this);
        unsigned int Height = CGImageGetHeight(this);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        float64x2_t v21 = (char *)malloc_type_zone_malloc(malloc_zone, 0x28uLL, 0x8BB15036uLL);
        image_by_rendering = v21;
        if (v21)
        {
          LODWORD(v23) = (int)*(double *)buf;
          DWORD1(v23) = (int)*(double *)&buf[8];
          *((void *)&v23 + 1) = __PAIR64__(Height, Width);
          *((_DWORD *)v21 + 2) = 1;
          *((_DWORD *)v21 + 3) = 50;
          ++dword_1EB2ADE90;
          *(void *)float64x2_t v21 = &unk_1ED02CDE0;
          uint32x2_t v24 = v17;
          if (!atomic_fetch_add(v17 + 2, 1u))
          {
            uint32x2_t v24 = 0;
            atomic_fetch_add(v17 + 2, 0xFFFFFFFF);
          }
          *((void *)v21 + 2) = v24;
          *(_OWORD *)(v21 + 24) = v23;
        }
        if (atomic_fetch_add(v17 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v17 + 16))(v17);
        }
        return image_by_rendering;
      }
    }
    else
    {
      double v10 = (CGImage *)(v10 & 0xFFFFFEFF);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::image_cache_lock);
  uint64_t v25 = CA::Render::image_cache;
  if (!CA::Render::image_cache)
  {
    CA::Render::image_cache = (uint64_t)x_hash_table_new_(0, 0, 0, 0, 0, 0);
    CA::Render::image_cache_list = (uint64_t)&CA::Render::image_cache_list;
    qword_1EB2AC540 = (uint64_t)&CA::Render::image_cache_list;
    CGImageNotificationCenter();
    CGNotificationCenterAddCallback();
    uint64_t v25 = CA::Render::image_cache;
  }
  uint64_t v26 = x_hash_table_lookup(v25, (uint64_t)this, 0);
  uint64_t v28 = v26;
  if (v26)
  {
    image_by_rendering = *(void **)(v26 + 24);
    if (image_by_rendering)
    {
      LODWORD(v27) = *((_DWORD *)image_by_rendering + 4);
      char v29 = 0;
      double v30 = (double)v27 / (double)CGImageGetWidth(this);
      goto LABEL_30;
    }
  }
  else
  {
    image_by_rendering = 0;
  }
  char v29 = 1;
  double v30 = 1.0;
LABEL_30:
  if (CGImageIsSubimage()) {
    double v31 = 1.0;
  }
  else {
    double v31 = v30;
  }
  if ((v29 & 1) == 0 && v31 >= a5)
  {
    int v32 = *(_DWORD *)(v28 + 40);
    if ((v10 & 1) == 0 || (v32)
      && (((unsigned __int16)v32 ^ (unsigned __int16)v10) & 0x442) == 0)
    {
      if (CARequiresColorMatching(*((CGColorSpace **)image_by_rendering + 6), a2, 1))
      {
        if (((unsigned __int16)v10 & 0x1000) == 0 && (*(_DWORD *)(v28 + 40) & 8) != 0) {
          goto LABEL_78;
        }
      }
      else if (((unsigned __int16)v10 & 0x1000) == 0)
      {
        goto LABEL_78;
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::image_cache_lock);
  uint64_t v33 = mach_absolute_time();
  double v34 = CATimeWithHostTime(v33);
  int v35 = BYTE9(ca_debug_options);
  if (a5 < 1.0)
  {
    if (BYTE9(ca_debug_options))
    {
      size_t v36 = CGImageGetWidth(this);
      size_t v37 = CGImageGetHeight(this);
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        long long v40 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218496;
          *(void *)&uint8_t buf[4] = this;
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v36;
          *(_WORD *)&buf[22] = 2048;
          *(void *)&buf[24] = v37;
          _os_log_impl(&dword_184668000, v40, OS_LOG_TYPE_DEFAULT, "CoreAnimation: copied CGImageRef %p - image size (%lu x %lu) exceeds max texture size\n", buf, 0x20u);
        }
      }
    }
    uint64_t v41 = this;
    float v42 = a2;
    __int16 v43 = (__int16)v10;
    double v44 = a5;
    goto LABEL_72;
  }
  if ((v10 & 0x40) != 0 && CGImageGetMask())
  {
    if (v35)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int32x4_t v48 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          *(void *)&uint8_t buf[4] = this;
          _os_log_impl(&dword_184668000, v48, OS_LOG_TYPE_DEFAULT, "CoreAnimation: copied CGImageRef %p - mask size\n", buf, 0xCu);
        }
      }
    }
    uint64_t v41 = this;
    float v42 = a2;
    __int16 v43 = (__int16)v10;
    double v44 = a5;
    goto LABEL_72;
  }
  if (((unsigned __int16)v10 & 0x400) != 0)
  {
    Bitmapuint64_t Info = CGImageGetBitmapInfo(this);
    int v110 = BitmapInfo & 0x1F;
    int v111 = (BitmapInfo & 0x7000) == 0x2000 ? 1 : 2;
    if ((double v112 = CGImageGetColorSpace(this)) != 0 && CGColorSpaceGetModel(v112) == kCGColorSpaceModelMonochrome
      || v110 == v111)
    {
      float v42 = (CGColorSpace *)CAGetColorSpace(0x1Cu);
      uint64_t v41 = this;
      __int16 v43 = (__int16)v10;
      double v44 = a5;
LABEL_72:
      goto LABEL_73;
    }
  }
  if (CA::Render::create_image(CGImage *,CGColorSpace *,unsigned int,double)::initialized)
  {
    if (!CA::Render::create_image(CGImage *,CGColorSpace *,unsigned int,double)::use_cgtexturedata) {
      goto LABEL_117;
    }
  }
  else
  {
    long long v38 = getenv("CA_USE_CGTEXTUREDATA");
    if (v38) {
      BOOL v39 = atoi(v38) != 0;
    }
    else {
      BOOL v39 = 1;
    }
    CA::Render::create_image(CGImage *,CGColorSpace *,unsigned int,double)::use_cgtexturedata = v39;
    CA::Render::create_image(CGImage *,CGColorSpace *,unsigned int,double)::initialized = 1;
    if (!v39)
    {
LABEL_117:
      int32x2_t v72 = (__IOSurface *)CGImageGetProperty();
      if (v72 && (v73 = v72, CFTypeID v74 = CFGetTypeID(v72), v74 == IOSurfaceGetTypeID()))
      {
        if (image_by_rendering) {
          goto LABEL_73;
        }
      }
      else
      {
        LOBYTE(image_by_rendering) = 1;
      }
      if (CGImageGetProperty() == *MEMORY[0x1E4F1CFD0])
      {
        if (CGImageGetImageProvider())
        {
          uint64_t Info = CGImageProviderGetInfo();
          if (Info)
          {
            float v88 = (objc_object *)Info;
            float v89 = (malloc_zone_t *)get_malloc_zone();
            double v90 = (CA::Render::MetalTexture *)malloc_type_zone_calloc(v89, 1uLL, 0x70uLL, 0x743898A5uLL);
            image_by_rendering = v90;
            if (v90) {
              CA::Render::MetalTexture::MetalTexture(v90, v88);
            }
            goto LABEL_73;
          }
        }
      }
      char v189 = (char)image_by_rendering;
      if ((v10 & 2) != 0)
      {
        double v86 = CGImageGetColorSpace(this);
        if (v86)
        {
LABEL_179:
          CGColorSpaceModel v114 = CGColorSpaceGetModel(v86);
          if (v114)
          {
            if (v114 != kCGColorSpaceModelRGB)
            {
              if (v35)
              {
                if (x_log_hook_p())
                {
LABEL_205:
                  x_log_();
                  goto LABEL_225;
                }
                int8x16_t v137 = x_log_category_render;
                if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_225;
                }
                *(_DWORD *)buf = 134217984;
                *(void *)&uint8_t buf[4] = this;
                unsigned __int32 v138 = "CoreAnimation: copied CGImageRef %p - non-RGB color model\n";
LABEL_224:
                _os_log_impl(&dword_184668000, v137, OS_LOG_TYPE_DEFAULT, v138, buf, 0xCu);
              }
LABEL_225:
              float v132 = this;
              float v133 = a2;
              __int16 v134 = (__int16)v10;
              double v135 = a5;
LABEL_258:
              goto LABEL_259;
            }
            int v115 = BYTE9(ca_debug_options);
            if ((v10 & 2) == 0)
            {
              size_t BitsPerPixel = CGImageGetBitsPerPixel(this);
              size_t BitsPerComponent = CGImageGetBitsPerComponent(this);
              CGBitmapInfo v118 = CGImageGetBitmapInfo(this);
              CGBitmapInfo v119 = v118;
              if ((v10 & 0x20) != 0 && BitsPerComponent == 16)
              {
                if (BitsPerPixel == 64 && (v118 & 0x1F) == 1 && (v118 & 0x7000) == 0x1000)
                {
                  float v120 = this;
                  float v121 = 0;
                  uint64_t v122 = 13;
LABEL_202:
LABEL_259:
                  image_by_rendering = image_from_image_data;
                  goto LABEL_260;
                }
                if (v115)
                {
                  if (x_log_hook_p())
                  {
LABEL_248:
                    x_log_();
                    goto LABEL_268;
                  }
                  int32x2_t v143 = x_log_category_render;
                  if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_268;
                  }
                  *(_DWORD *)buf = 134218752;
                  *(void *)&uint8_t buf[4] = this;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = BitsPerPixel;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = 16;
                  *(_WORD *)&buf[24] = 1024;
                  *(_DWORD *)&buf[26] = v119;
                  float32x4_t v144 = "CoreAnimation: ignored CGImageRef %p - bad RGB 16-is-half format (%d bpp, %d bpc, %d info)\n";
LABEL_267:
                  _os_log_impl(&dword_184668000, v143, OS_LOG_TYPE_DEFAULT, v144, buf, 0x1Eu);
                  goto LABEL_268;
                }
                goto LABEL_268;
              }
              if (CGImageGetDecode(this) || CGImageGetMask() || CGImageGetMatte() || CGImageGetMaskingColors())
              {
                if (v115)
                {
                  if (x_log_hook_p()) {
                    goto LABEL_232;
                  }
                  int8x16_t v136 = x_log_category_render;
                  if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_254;
                  }
                  *(_DWORD *)buf = 134217984;
                  *(void *)&uint8_t buf[4] = this;
LABEL_253:
                  _os_log_impl(&dword_184668000, v136, OS_LOG_TYPE_DEFAULT, "CoreAnimation: copied CGImageRef %p - decode or mask\n", buf, 0xCu);
                  goto LABEL_254;
                }
                goto LABEL_254;
              }
              if (BitsPerPixel != 16)
              {
                if (BitsPerPixel != 32)
                {
                  if (BitsPerPixel == 64 && BitsPerComponent == 16)
                  {
                    if ((v119 & 0x701F) == 0x1005)
                    {
                      BOOL v152 = (v119 & 0x100) == 0;
                      unsigned int v153 = 17;
                      unsigned int v154 = 22;
LABEL_348:
                      if (v152) {
                        uint64_t v122 = v154;
                      }
                      else {
                        uint64_t v122 = v153;
                      }
                      goto LABEL_351;
                    }
                    if ((v119 & 0x701F) == 0x1001)
                    {
                      BOOL v152 = (v119 & 0x100) == 0;
                      unsigned int v153 = 13;
                      unsigned int v154 = 21;
                      goto LABEL_348;
                    }
                  }
LABEL_362:
                  if (v115)
                  {
                    if (x_log_hook_p()) {
                      goto LABEL_364;
                    }
                    __int16 v168 = x_log_category_render;
                    if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_368;
                    }
                    *(_DWORD *)buf = 134218752;
                    *(void *)&uint8_t buf[4] = this;
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = BitsPerPixel;
                    *(_WORD *)&buf[18] = 1024;
                    *(_DWORD *)&buf[20] = BitsPerComponent;
                    *(_WORD *)&buf[24] = 1024;
                    *(_DWORD *)&buf[26] = v119;
                    uint64_t v169 = "CoreAnimation: copied CGImageRef %p - bad RGB image format (%d bpp, %d bpc, %d info)\n";
LABEL_367:
                    _os_log_impl(&dword_184668000, v168, OS_LOG_TYPE_DEFAULT, v169, buf, 0x1Eu);
                    goto LABEL_368;
                  }
                  goto LABEL_368;
                }
                int v166 = v119 & 0x1F;
                int v167 = v119 & 0x7000;
                if (BitsPerComponent == 10 && v166 == 6 && v167 == 0x2000 && (v119 & 0xF0000) == 0x30000)
                {
                  uint64_t v122 = 31;
                }
                else
                {
                  if (BitsPerComponent != 8) {
                    goto LABEL_362;
                  }
                  switch(v166)
                  {
                    case 2:
                      char v170 = 0;
                      int v171 = 0;
                      char v172 = 0;
                      uint64_t v122 = 0;
                      break;
                    case 6:
                      int v171 = 0;
                      char v172 = 0;
                      uint64_t v122 = 2;
                      char v170 = 1;
                      break;
                    case 5:
                      char v170 = 0;
                      int v171 = 0;
                      uint64_t v122 = 12;
                      char v172 = 1;
                      break;
                    case 1:
                      char v170 = 0;
                      char v172 = 0;
                      uint64_t v122 = 11;
                      int v171 = 1;
                      break;
                    default:
                      goto LABEL_362;
                  }
                  if (v167 == 0x2000)
                  {
                    BOOL v96 = v166 == 2;
                    char v173 = v170 ^ 1;
                    if (v96) {
                      char v173 = 0;
                    }
                    if (v173)
                    {
                      if (v171) {
                        uint64_t v122 = 15;
                      }
                      else {
                        uint64_t v122 = 16;
                      }
                      if ((v171 | v172)) {
                        goto LABEL_351;
                      }
                      goto LABEL_362;
                    }
                    uint64_t v122 = (v122 + 1);
                  }
                }
LABEL_351:
                float v120 = this;
                float v121 = a2;
                goto LABEL_202;
              }
              if (BitsPerComponent != 5 || (v119 & 0x1F) != 6) {
                goto LABEL_362;
              }
              BOOL v150 = (v119 & 0x7000) == 4096;
              unsigned int v151 = 4;
LABEL_316:
              if (v150) {
                uint64_t v122 = v151 + 1;
              }
              else {
                uint64_t v122 = v151;
              }
              goto LABEL_351;
            }
            if (!BYTE9(ca_debug_options))
            {
LABEL_245:
              float v132 = this;
              float v133 = 0;
              __int16 v134 = (__int16)v10;
              double v135 = a5;
              goto LABEL_258;
            }
            if (x_log_hook_p())
            {
LABEL_211:
              x_log_();
              goto LABEL_245;
            }
            uint64_t v139 = x_log_category_render;
            if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_245;
            }
            *(_DWORD *)buf = 134217984;
            *(void *)&uint8_t buf[4] = this;
            long long v140 = "CoreAnimation: copied CGImageRef %p - RGB mask (bug!)\n";
            int v141 = v139;
            uint32_t v142 = 12;
LABEL_244:
            _os_log_impl(&dword_184668000, v141, OS_LOG_TYPE_DEFAULT, v140, buf, v142);
            goto LABEL_245;
          }
          int v125 = BYTE9(ca_debug_options);
          size_t v126 = CGImageGetBitsPerPixel(this);
          size_t v127 = CGImageGetBitsPerComponent(this);
          CGBitmapInfo v128 = CGImageGetBitmapInfo(this);
          CGBitmapInfo v129 = v128;
          if ((v10 & 0x20) == 0 || v127 != 16)
          {
            if (CGImageGetDecode(this) || CGImageGetMask() || CGImageGetMatte() || CGImageGetMaskingColors())
            {
              if (v125)
              {
                if (x_log_hook_p())
                {
LABEL_232:
                  x_log_();
                  goto LABEL_254;
                }
                int8x16_t v136 = x_log_category_render;
                if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 134217984;
                  *(void *)&uint8_t buf[4] = this;
                  goto LABEL_253;
                }
              }
LABEL_254:
              float v132 = this;
              float v133 = a2;
              __int16 v134 = (__int16)v10;
              double v135 = a5;
              goto LABEL_258;
            }
            if (v126 == 32)
            {
              if ((v10 & 2) == 0 && v127 == 16 && (v129 & 0x1F) == 1 && (v129 & 0x7000) == 0x1000)
              {
                if ((v129 & 0x100) != 0) {
                  uint64_t v122 = 28;
                }
                else {
                  uint64_t v122 = 27;
                }
                goto LABEL_351;
              }
            }
            else if (v126 == 16)
            {
              if (v127 == 8)
              {
                int v155 = v129 & 0x1F;
                int v156 = v129 & 0x7000;
                if ((v10 & 2) == 0 && v155 == 1 && v156 != 4096)
                {
                  uint64_t v122 = 18;
                  goto LABEL_351;
                }
                if ((v10 & 2) == 0 && v155 == 5 && v156 != 4096)
                {
                  uint64_t v122 = 19;
                  goto LABEL_351;
                }
              }
            }
            else if (v126 == 8 && v127 == 8 && (v129 & 0x1F) == 0)
            {
              BOOL v150 = (v10 & 2) == 0;
              unsigned int v151 = 9;
              goto LABEL_316;
            }
            if (v125)
            {
              if (x_log_hook_p())
              {
LABEL_364:
                x_log_();
                goto LABEL_368;
              }
              __int16 v168 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 134218752;
                *(void *)&uint8_t buf[4] = this;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v126;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v127;
                *(_WORD *)&buf[24] = 1024;
                *(_DWORD *)&buf[26] = v129;
                uint64_t v169 = "CoreAnimation: copied CGImageRef %p - bad grayscale image format (%d bpp, %d bpc, %d info)\n";
                goto LABEL_367;
              }
            }
LABEL_368:
            float v132 = this;
            float v133 = a2;
            __int16 v134 = (__int16)v10;
            double v135 = a5;
            goto LABEL_258;
          }
          if (v126 != 16 || (v128 & 0x7000) != 0x1000)
          {
            if (v125)
            {
              if (x_log_hook_p()) {
                goto LABEL_248;
              }
              int32x2_t v143 = x_log_category_render;
              if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_268;
              }
              *(_DWORD *)buf = 134218752;
              *(void *)&uint8_t buf[4] = this;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v126;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = 16;
              *(_WORD *)&buf[24] = 1024;
              *(_DWORD *)&buf[26] = v129;
              float32x4_t v144 = "CoreAnimation: ignored CGImageRef %p - bad grayscale 16-is-half format (%d bpp, %d bpc, %d info)\n";
              goto LABEL_267;
            }
LABEL_268:
            image_by_rendering = 0;
            goto LABEL_73;
          }
          if ((v10 & 2) != 0) {
            uint64_t v122 = 23;
          }
          else {
            uint64_t v122 = 25;
          }
          goto LABEL_201;
        }
LABEL_188:
        int v123 = BYTE9(ca_debug_options);
        Decode = CGImageGetDecode(this);
        if (!Decode || *Decode != 1.0 || Decode[1] != 0.0)
        {
          if (v123)
          {
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              double v131 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 134217984;
                *(void *)&uint8_t buf[4] = this;
                _os_log_impl(&dword_184668000, v131, OS_LOG_TYPE_DEFAULT, "CoreAnimation: copied CGImageRef %p - bad decode array\n", buf, 0xCu);
              }
            }
          }
          float v132 = this;
          float v133 = 0;
          __int16 v134 = (__int16)v10;
          double v135 = a5;
          goto LABEL_258;
        }
        if (CGImageGetMask() || CGImageGetMatte() || CGImageGetMaskingColors())
        {
          if (v123)
          {
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              uint64_t v145 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 134217984;
                *(void *)&uint8_t buf[4] = this;
                _os_log_impl(&dword_184668000, v145, OS_LOG_TYPE_DEFAULT, "CoreAnimation: copied CGImageRef %p - bad mask\n", buf, 0xCu);
              }
            }
          }
          float v132 = this;
          float v133 = 0;
          __int16 v134 = (__int16)v10;
          double v135 = a5;
          goto LABEL_258;
        }
        size_t v147 = CGImageGetBitsPerPixel(this);
        size_t v148 = CGImageGetBitsPerComponent(this);
        int v149 = v148;
        if (v147 != 8 || v148 != 8)
        {
          if (!v123) {
            goto LABEL_245;
          }
          if (x_log_hook_p()) {
            goto LABEL_211;
          }
          uint64_t v165 = x_log_category_render;
          if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_245;
          }
          *(_DWORD *)buf = 134218496;
          *(void *)&uint8_t buf[4] = this;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v147;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v149;
          long long v140 = "CoreAnimation: copied CGImageRef %p - bad mask image format (%d bpp, %d bpc)\n";
          int v141 = v165;
          uint32_t v142 = 24;
          goto LABEL_244;
        }
        if (CGImageIsMask(this) | ((v10 & 2) >> 1)) {
          uint64_t v122 = 9;
        }
        else {
          uint64_t v122 = 8;
        }
LABEL_201:
        float v120 = this;
        float v121 = 0;
        goto LABEL_202;
      }
      uint64_t ImageProvider = CGImageGetImageProvider();
      if (!ImageProvider) {
        goto LABEL_174;
      }
      uint64_t v78 = ImageProvider;
      float v79 = (CA::Render *)CGImageGetWidth(this);
      unsigned int v80 = CGImageGetHeight(this);
      if (CA::Render::iosurface_size_supported(v79, v80))
      {
        float v81 = (__IOSurface *)CGImageProviderCopyIOSurface();
        if (v81)
        {
          float v82 = v81;
          OSType PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(v81);
          if (!CA::Render::fourcc_has_alpha(PixelFormat)) {
            goto LABEL_137;
          }
          int v197 = 0;
          long long v195 = 0u;
          long long v196 = 0u;
          long long v193 = 0u;
          long long v194 = 0u;
          long long v192 = 0u;
          memset(buf, 0, sizeof(buf));
          float v190 = (CA::Render *)116;
          if (IOSurfaceGetBulkAttachments()) {
            goto LABEL_137;
          }
          if (BYTE4(v196) == 1)
          {
            CFRelease(v82);
          }
          else
          {
LABEL_137:
            CFRelease(v82);
            if (image_by_rendering) {
              goto LABEL_260;
            }
          }
        }
      }
      double v91 = CGImageGetColorSpace(this);
      if (!v91) {
        goto LABEL_174;
      }
      double v92 = v91;
      if (CGColorSpaceGetModel(v91) != kCGColorSpaceModelRGB)
      {
        if (CGColorSpaceGetModel(v92)) {
          goto LABEL_174;
        }
      }
      if (CGImageGetDecode(this) || CGImageGetMask() || CGImageGetMatte() || CGImageGetMaskingColors()) {
        goto LABEL_174;
      }
      CGColorSpaceModel v93 = CGColorSpaceGetModel(v92);
      unsigned int ComponentType = CGImageProviderGetComponentType();
      BOOL v95 = ComponentType > 1;
      CGColorSpaceModel v180 = v93;
      BOOL v96 = v93 == kCGColorSpaceModelMonochrome;
      unsigned int v97 = ComponentType;
      int v98 = v96;
      int v184 = v98;
      if (v96) {
        BOOL v95 = 1;
      }
      BOOL cf = v95;
      Alphauint64_t Info = CGImageProviderGetAlphaInfo();
      unsigned int v182 = v97;
      int v100 = v97;
      unsigned int v101 = AlphaInfo;
      BOOL v103 = v102 == -1 || v102 == 14;
      BOOL v104 = !v103;
      if (cf && v102 != -1 && v102 != 14 && v101 <= 4 && ((1 << v101) & 0x19) != 0
        || v182 - 3 < 2
            double v105 = (double)CGImageGetWidth(this),
            double v106 = (double)CGImageGetHeight(this),
            uint64_t v107 = CGImageProviderCopyImageBlockSetWithOptions(),
            CFRelease(cfb),
            !v107))
      {
LABEL_174:
        float v113 = CGImageGetColorSpace(this);
        if (v113)
        {
          double v86 = v113;
          if (CARequiresColorMatching(v113, a2, 1))
          {
            if (v35)
            {
              if (x_log_hook_p()) {
                goto LABEL_205;
              }
              int8x16_t v137 = x_log_category_render;
              if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_225;
              }
              *(_DWORD *)buf = 134217984;
              *(void *)&uint8_t buf[4] = this;
              unsigned __int32 v138 = "CoreAnimation: copied CGImageRef %p - needs color matching\n";
              goto LABEL_224;
            }
            goto LABEL_225;
          }
          goto LABEL_179;
        }
        goto LABEL_188;
      }
      cfa = (void (*)(const void *, void *))v107;
      CGImageBlockSetGetRect();
      v200.origin.x = 0.0;
      v200.origin.y = 0.0;
      v200.size.width = v105;
      v200.size.height = v106;
      BOOL v108 = CGRectEqualToRect(v199, v200);
      if ((v10 & 0x10) != 0 || v108)
      {
        if (CGImageBlockSetGetCount() != 1)
        {
          {
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              uint64_t v174 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_184668000, v174, OS_LOG_TYPE_DEFAULT, "CoreAnimation: warning, CGImageProvider returned multiple blocks\n", buf, 2u);
              }
            }
          }
          goto LABEL_164;
        }
        if (CGImageBlockSetGetImageBlock())
        {
          CGImageBlockGetRect();
          double v158 = v157;
          double v160 = v159;
          if (v161 != -1)
          {
            uint64_t v162 = (CA::Render *)v161;
            unsigned int v181 = v158;
            unsigned int v183 = v160;
            unint64_t Data = CGImageBlockGetData();
            unint64_t BytesPerRow = CGImageBlockGetBytesPerRow();
            float v190 = (CA::Render *)BytesPerRow;
            if (v10)
            {
              if (!BYTE9(ca_debug_options)) {
                goto LABEL_381;
              }
              if (x_log_hook_p()) {
                goto LABEL_391;
              }
              log = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 134217984;
                *(void *)&uint8_t buf[4] = this;
                _os_log_impl(&dword_184668000, log, OS_LOG_TYPE_DEFAULT, "CoreAnimation: copied CGImageRef %p - mipmap generation\n", buf, 0xCu);
              }
              goto LABEL_381;
            }
            if (qword_1EB2A87C0)
            {
              if ((qword_1EB2A87C0 & (qword_1EB2A87C0 - 1)) != 0
                 ? Data % qword_1EB2A87C0
                 : (qword_1EB2A87C0 - 1) & Data)
              {
                if (!BYTE9(ca_debug_options)) {
                  goto LABEL_381;
                }
                if (x_log_hook_p())
                {
LABEL_391:
                  x_log_();
                  goto LABEL_381;
                }
                loga = x_log_category_render;
                if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 134217984;
                  *(void *)&uint8_t buf[4] = this;
                  _os_log_impl(&dword_184668000, loga, OS_LOG_TYPE_DEFAULT, "CoreAnimation: copied CGImageRef %p - bad image alignment\n", buf, 0xCu);
                }
LABEL_381:
                CGImageBlockSetRelease();
                if (!image_by_rendering) {
                  goto LABEL_174;
                }
LABEL_260:
                char v146 = v189;
                if (!image_by_rendering) {
                  char v146 = 1;
                }
                if ((v146 & 1) == 0)
                {
                  int v47 = *((_DWORD *)image_by_rendering + 3) | 0x800000;
LABEL_264:
                  *((_DWORD *)image_by_rendering + 3) = v47;
                }
                goto LABEL_73;
              }
            }
            if (qword_1EB2A87C8)
            {
              if ((qword_1EB2A87C8 & (qword_1EB2A87C8 - 1)) != 0
                 ? BytesPerRow % qword_1EB2A87C8
                 : (qword_1EB2A87C8 - 1) & BytesPerRow)
              {
                if (!BYTE9(ca_debug_options)) {
                  goto LABEL_381;
                }
                if (x_log_hook_p()) {
                  goto LABEL_391;
                }
                logb = x_log_category_render;
                if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 134217984;
                  *(void *)&uint8_t buf[4] = this;
                  _os_log_impl(&dword_184668000, logb, OS_LOG_TYPE_DEFAULT, "CoreAnimation: copied CGImageRef %p - bad row alignment\n", buf, 0xCu);
                }
                goto LABEL_381;
              }
            }
            if (image_by_rendering) {
              goto LABEL_260;
            }
          }
        }
      }
LABEL_164:
      CGImageBlockSetRelease();
      goto LABEL_174;
    }
  }
  if (!CGImageGetImageProvider()) {
    goto LABEL_117;
  }
  uint64_t v45 = CGImageProviderCopyImageTextureData();
  if (!v45) {
    goto LABEL_117;
  }
  image_by_rendering = CA::Render::CompressedImage::new_image_with_texture_data(v45);
  CGImageTextureDataRelease();
  if (!image_by_rendering) {
    goto LABEL_117;
  }
  int v46 = CGImageProviderGetAlphaInfo();
  switch(v46)
  {
    case 0:
    case 5:
      *((_DWORD *)image_by_rendering + 42) = 0;
      int v47 = *((_DWORD *)image_by_rendering + 3) | 0x1000;
      goto LABEL_264;
    case 1:
      int v70 = 1;
      break;
    case 3:
      int v70 = 2;
      break;
    default:
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int32x2_t v71 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v46;
          _os_log_impl(&dword_184668000, v71, OS_LOG_TYPE_DEBUG, "Unsupported CGImageAlpha '%d' for compressed texture", buf, 8u);
        }
      }
      if (atomic_fetch_add((atomic_uint *volatile)image_by_rendering + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(void *))(*(void *)image_by_rendering + 16))(image_by_rendering);
      }
      goto LABEL_117;
  }
  *((_DWORD *)image_by_rendering + 42) = v70;
LABEL_73:
  uint64_t v49 = mach_absolute_time();
  double v50 = CATimeWithHostTime(v49) - v34;
  if (a4 <= 0.0) {
    double v50 = -0.0;
  }
  if (!image_by_rendering)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::image_cache_lock);
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::image_cache_lock);
    return image_by_rendering;
  }
  a4 = v50 + a4;
  *(_DWORD *)buf = 0;
  CGImageGetHeadroom();
  *((_DWORD *)image_by_rendering + 14) = *(_DWORD *)buf;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::image_cache_lock);
  if (!(*(unsigned int (**)(void *))(*(void *)image_by_rendering + 224))(image_by_rendering)
    || ((unsigned __int16)v10 & 0x1000) != 0)
  {
LABEL_78:
    uint64_t v51 = 0;
    if ((v10 & 4) == 0) {
      goto LABEL_79;
    }
LABEL_90:
    if (v28)
    {
      double v60 = *(double *)(v28 + 32);
      if (v60 >= 0.0 && a4 > v60)
      {
        if (v60 > 0.0)
        {
          uint64_t v62 = *(void *)v28;
          int8x16_t v61 = *(void **)(v28 + 8);
          *(void *)(v62 + 8) = v61;
          *int8x16_t v61 = v62;
          *(void *)uint64_t v28 = v28;
          *(void *)(v28 + 8) = v28;
        }
        *(double *)(v28 + 32) = a4;
        uint64_t v63 = &CA::Render::image_cache_list;
        while (1)
        {
          uint64_t v63 = (uint64_t *)*v63;
          if (v63 == &CA::Render::image_cache_list) {
            break;
          }
          if (*((double *)v63 + 4) <= a4)
          {
            uint64_t v64 = (void *)v63[1];
            uint64_t v65 = *(void *)v28;
            v63[1] = v28;
            *(void *)uint64_t v28 = v63;
            *uint64_t v64 = v65;
            *(void *)(v65 + 8) = v64;
            goto LABEL_100;
          }
        }
        uint32x2_t v66 = (void *)qword_1EB2AC540;
        uint64_t v67 = *(void *)v28;
        qword_1EB2AC540 = v28;
        *(void *)uint64_t v28 = &CA::Render::image_cache_list;
        *uint32x2_t v66 = v67;
        *(void *)(v67 + 8) = v66;
      }
    }
    goto LABEL_100;
  }
  uint64_t v54 = x_hash_table_lookup(CA::Render::image_cache, (uint64_t)this, 0);
  if (v54)
  {
    uint64_t v28 = v54;
    uint64_t v51 = *(atomic_uint **)(v54 + 24);
  }
  else
  {
    int v55 = (malloc_zone_t *)get_malloc_zone();
    uint64_t v56 = malloc_type_zone_malloc(v55, 0x30uLL, 0x8BB15036uLL);
    uint64_t v28 = (uint64_t)v56;
    if (v56)
    {
      v56[3] = 0;
      _DWORD v56[4] = 0;
      v56[1] = v56;
      v56[2] = this;
      void *v56 = v56;
      unint64_t v57 = (int *)CA::Render::image_cache;
      uint64_t v58 = this;
      uint64_t v59 = v28;
    }
    else
    {
      unint64_t v57 = (int *)CA::Render::image_cache;
      uint64_t v58 = this;
      uint64_t v59 = 0;
    }
    hash_table_modify(v57, (uint64_t)v58, v59, 0);
    uint64_t v51 = 0;
  }
  *(void *)(v28 + 24) = image_by_rendering;
  *(_DWORD *)(v28 + 40) = v10;
  if ((v10 & 4) != 0) {
    goto LABEL_90;
  }
LABEL_79:
  if (v28 && *(double *)(v28 + 32) >= 0.0)
  {
    uint64_t v53 = *(void *)v28;
    int v52 = *(void **)(v28 + 8);
    *(void *)(v53 + 8) = v52;
    *int v52 = v53;
    *(void *)uint64_t v28 = v28;
    *(void *)(v28 + 8) = v28;
    *(void *)(v28 + 32) = 0xBFF0000000000000;
  }
LABEL_100:
  int v68 = (*(uint64_t (**)(void *))(*(void *)image_by_rendering + 224))(image_by_rendering);
  if (((unsigned __int16)v10 & 0x1000) == 0
    && v68
    && !atomic_fetch_add((atomic_uint *volatile)image_by_rendering + 2, 1u))
  {
    atomic_fetch_add((atomic_uint *volatile)image_by_rendering + 2, 0xFFFFFFFF);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::image_cache_lock);
  if (v51 && atomic_fetch_add(v51 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v51 + 16))(v51);
  }
  return image_by_rendering;
}

_DWORD *CA::ColorProgram::Cache::lookup(CGColorSpace **this, CGColorSpace *a2, int a3, uint64_t a4)
{
  int v8 = *((unsigned __int8 *)this + 64);
  if (!*((_WORD *)this + 32) || *((_DWORD *)this + 17) != 2)
  {
    if (!CARequiresColorMatching(a2, *this, 0)) {
      return 0;
    }
    int v8 = *((unsigned __int8 *)this + 64);
  }
  if (*((unsigned char *)this + 60)) {
    int v9 = a3 | 2;
  }
  else {
    int v9 = a3;
  }
  int v10 = v9 | 0x80;
  if (*((unsigned char *)this + 66)) {
    int v10 = v9;
  }
  if (*((unsigned char *)this + 61)) {
    int v9 = v10;
  }
  if (*((unsigned char *)this + 62)) {
    v9 |= 8u;
  }
  if (v8) {
    int v11 = v9 | 0x10;
  }
  else {
    int v11 = v9;
  }
  if (*((unsigned char *)this + 65)) {
    v11 |= 0x20u;
  }
  if (*((unsigned char *)this + 66)) {
    v11 |= 0x40u;
  }
  if (!byte_1EB2ACC8B) {
    v11 |= 0x100u;
  }
  if (!byte_1EB2ACC8C) {
    v11 |= 0x200u;
  }
  if (*((unsigned char *)this + 67)) {
    unsigned int v12 = v11 | 0x400;
  }
  else {
    unsigned int v12 = v11;
  }
  if (!(*((unsigned __int8 *)this + 63) | BYTE6(xmmword_1EB2ACC30)) && (!a4 || !*(unsigned char *)(a4 + 52))
    || BYTE5(xmmword_1EB2ACC30))
  {
    v12 |= 4u;
  }
  double result = CA::ColorProgram::Cache::lookup_((CA::ColorProgram::Cache *)this, a2, v12, (CGColorRenderingIntent)a4);
  if (result)
  {
    if (!result[9]) {
      return 0;
    }
  }
  return result;
}

uint64_t CARequiresColorMatching(CGColorSpace *a1, CGColorSpace *a2, int a3)
{
  uint64_t result = 0;
  if (a2 && a1 && a1 != a2)
  {
    if ((CGColorSpaceIsUncalibrated() & 1) != 0
      || ((CGColorSpace *)CAGetColorSpace(3u) == a1 || CGColorSpaceEqualToColorSpaceIgnoringRange())
      && ((CGColorSpace *)CAGetColorSpace(0x1Du) == a2
       || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
       || CGColorSpaceGetModel(a2) == kCGColorSpaceModelRGB
       && CGColorSpaceGetRenderingIntent() != 1
       && (colorspace_has_srgb_gamma(a2) & 1) != 0))
    {
      return 0;
    }
    if (CARequiresColorMatching::once[0] != -1) {
      dispatch_once(CARequiresColorMatching::once, &__block_literal_global_23195);
    }
    if (CARequiresColorMatching::compat_mode
      && (CGColorSpaceGetType() < 2 || CGColorSpaceGetType() < 2)
      || a3 && CGColorSpaceGetModel(a1) < kCGColorSpaceModelCMYK)
    {
      return 0;
    }
    else
    {
      return CGColorSpaceEqualToColorSpaceIgnoringRange() ^ 1;
    }
  }
  return result;
}

uint64_t CACGColorSpaceIsRec709(uint64_t a1)
{
  if (CAGetColorSpace(0x14u) == a1
    || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
    || CAGetColorSpace(0x15u) == a1
    || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
    || CAGetColorSpace(0x11u) == a1)
  {
    return 1;
  }

  return CGColorSpaceEqualToColorSpaceIgnoringRange();
}

uint64_t CAGetColorSpace(unsigned int a1)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (a1 > 0x1F) {
    return 0;
  }
  uint64_t result = colorspaces[a1];
  if (!result)
  {
    uint64_t v3 = a1;
    switch(a1)
    {
      case 0u:
        return colorspaces[v3];
      case 1u:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DCA0];
        goto LABEL_38;
      case 2u:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DCA8];
        goto LABEL_38;
      case 3u:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DC00];
        goto LABEL_38;
      case 4u:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DBF0];
        goto LABEL_38;
      case 5u:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DB90];
        goto LABEL_38;
      case 6u:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DB98];
        goto LABEL_38;
      case 7u:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DBA0];
        goto LABEL_38;
      case 8u:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DB88];
        goto LABEL_38;
      case 9u:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DC28];
        goto LABEL_38;
      case 0xAu:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DC80];
        goto LABEL_38;
      case 0xBu:
        uint64_t v5 = 9;
        goto LABEL_34;
      case 0xCu:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DC48];
        goto LABEL_38;
      case 0xDu:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DC50];
        goto LABEL_38;
      case 0xEu:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DC40];
        goto LABEL_38;
      case 0xFu:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DC70];
        goto LABEL_38;
      case 0x10u:
        uint64_t v5 = 5;
        goto LABEL_34;
      case 0x11u:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DC58];
        goto LABEL_38;
      case 0x12u:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DC68];
        goto LABEL_38;
      case 0x13u:
        *(_OWORD *)whitePoint = xmmword_1849A8758;
        uint64_t v33 = 0x3FEA6594AF4F0D84;
        CGFloat blackPoint = 0.0;
        uint64_t v30 = 0;
        uint64_t v31 = 0;
        *(_OWORD *)gamma = xmmword_1849A8770;
        uint64_t v28 = 0x4003333333333333;
        uint64_t v6 = &xmmword_1849A86C8;
        goto LABEL_31;
      case 0x14u:
        uint64_t v7 = *MEMORY[0x1E4F24BC8];
        *(void *)&long long v22 = *MEMORY[0x1E4F24A90];
        *((void *)&v22 + 1) = v7;
        *(void *)&long long v23 = *MEMORY[0x1E4F24C18];
        CGFloat v8 = *MEMORY[0x1E4F24BE0];
        whitePoint[0] = *(CGFloat *)MEMORY[0x1E4F24AB0];
        whitePoint[1] = v8;
        int v9 = (uint64_t *)MEMORY[0x1E4F24C48];
        goto LABEL_43;
      case 0x15u:
        uint64_t v10 = *MEMORY[0x1E4F24BC8];
        *(void *)&long long v22 = *MEMORY[0x1E4F24A90];
        *((void *)&v22 + 1) = v10;
        *(void *)&long long v23 = *MEMORY[0x1E4F24C18];
        int v11 = (CGFloat *)MEMORY[0x1E4F24AB0];
        goto LABEL_28;
      case 0x16u:
        uint64_t v12 = *MEMORY[0x1E4F24BC8];
        *(void *)&long long v22 = *MEMORY[0x1E4F24A90];
        *((void *)&v22 + 1) = v12;
        *(void *)&long long v23 = *MEMORY[0x1E4F24C18];
        int v11 = (CGFloat *)MEMORY[0x1E4F24AC8];
        goto LABEL_28;
      case 0x17u:
        uint64_t v13 = *MEMORY[0x1E4F24BC8];
        *(void *)&long long v22 = *MEMORY[0x1E4F24A90];
        *((void *)&v22 + 1) = v13;
        *(void *)&long long v23 = *MEMORY[0x1E4F24C18];
        int v11 = (CGFloat *)MEMORY[0x1E4F24AA0];
LABEL_28:
        CGFloat v14 = *MEMORY[0x1E4F24BE0];
        whitePoint[0] = *v11;
        whitePoint[1] = v14;
        int v9 = (uint64_t *)MEMORY[0x1E4F24C40];
        goto LABEL_43;
      case 0x18u:
        *(_OWORD *)whitePoint = xmmword_1849A8758;
        uint64_t v33 = 0x3FEA6594AF4F0D84;
        CGFloat blackPoint = 0.0;
        uint64_t v30 = 0;
        uint64_t v31 = 0;
        *(_OWORD *)gamma = xmmword_1849A8770;
        uint64_t v28 = 0x4003333333333333;
        uint64_t v6 = &xmmword_1849A8710;
        goto LABEL_31;
      case 0x19u:
        *(_OWORD *)whitePoint = xmmword_1849A8758;
        uint64_t v33 = 0x3FEA6594AF4F0D84;
        CGFloat blackPoint = 0.0;
        uint64_t v30 = 0;
        uint64_t v31 = 0;
        *(_OWORD *)gamma = xmmword_1849A8770;
        uint64_t v28 = 0x4003333333333333;
        uint64_t v6 = &xmmword_1849A8788;
LABEL_31:
        long long v15 = v6[3];
        long long v24 = v6[2];
        long long v25 = v15;
        uint64_t v26 = *((void *)v6 + 8);
        long long v16 = v6[1];
        long long v22 = *v6;
        long long v23 = v16;
        CGColorSpaceRef Linearized = CGColorSpaceCreateCalibratedRGB(whitePoint, &blackPoint, gamma, (const CGFloat *)&v22);
        goto LABEL_39;
      case 0x1Au:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DBE0];
        goto LABEL_38;
      case 0x1Bu:
        uint64_t v5 = 29;
LABEL_34:
        int32x2_t v18 = (CGColorSpace *)CAGetColorSpace(v5);
        CGColorSpaceRef Linearized = CGColorSpaceCreateLinearized(v18);
        goto LABEL_39;
      case 0x1Cu:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DBE8];
        goto LABEL_38;
      case 0x1Du:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DC98];
        goto LABEL_38;
      case 0x1Eu:
        uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1DC20];
LABEL_38:
        CGColorSpaceRef Linearized = CGColorSpaceCreateWithName(*v4);
LABEL_39:
        colorspaces[v3] = Linearized;
        break;
      case 0x1Fu:
        uint64_t v19 = *MEMORY[0x1E4F24BC8];
        *(void *)&long long v22 = *MEMORY[0x1E4F24A90];
        *((void *)&v22 + 1) = v19;
        *(void *)&long long v23 = *MEMORY[0x1E4F24C18];
        CGFloat v20 = *MEMORY[0x1E4F24C10];
        whitePoint[0] = *(CGFloat *)MEMORY[0x1E4F24AA8];
        whitePoint[1] = v20;
        int v9 = (uint64_t *)MEMORY[0x1E4F24C30];
LABEL_43:
        uint64_t v33 = *v9;
        CFDictionaryRef v21 = CFDictionaryCreate(0, (const void **)&v22, (const void **)whitePoint, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        colorspaces[v3] = CVImageBufferCreateColorSpaceFromAttachments(v21);
        if (v21) {
          CFRelease(v21);
        }
        break;
      default:
        __assert_rtn("CAGetColorSpace", "CACGUtil.cpp", 1402, "false");
    }
    return colorspaces[v3];
  }
  return result;
}

_DWORD *CA::ColorProgram::Cache::lookup_(CA::ColorProgram::Cache *this, CGColorSpace *a2, unsigned int a3, CGColorRenderingIntent a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](this);
  uint64_t v6 = v5;
  CGFloat v8 = v7;
  uint64_t v9 = v4;
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  space = *(CGColorSpace **)(v4 + 8);
  if (CGColorSpaceGetModel(v7) == kCGColorSpaceModelCMYK) {
    CGFloat v8 = (CGColorSpace *)CAGetReconciledColorSpace((uint64_t)v8);
  }
  CFDictionaryRef theDict = 0;
  BOOL IsHLGBased = CGColorSpaceIsHLGBased(v8);
  v88[4] = IsHLGBased;
  BOOL IsPQBased = CGColorSpaceIsPQBased(v8);
  v88[5] = IsPQBased;
  BOOL v12 = CGColorSpaceUsesExtendedRange(v8);
  BOOL v13 = v12;
  v88[6] = v12;
  v88[0] = (v6 & 0x30) != 0;
  int v85 = v6 & 0x30;
  v88[1] = v85 == 16;
  int v14 = (v6 & 0x200) != 0 && (IsHLGBased || IsPQBased || v12);
  v88[2] = v14;
  if ((v6 & 0x100) != 0) {
    int v15 = CGColorSpaceContainsFlexGTCInfo();
  }
  else {
    int v15 = 0;
  }
  v88[3] = v15;
  int v16 = !IsPQBased;
  int v81 = v15;
  BOOL v82 = (IsHLGBased || (v16 & 1) == 0) && *(_DWORD *)(v9 + 68) == 2;
  if ((v14 ^ 1))
  {
    CGColorSpaceRef cf = 0;
  }
  else
  {
    CGColorSpaceRef cf = CGColorSpaceCreateExtended(space);
    space = cf;
  }
  size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(v8);
  if (NumberOfComponents == 4)
  {
    if (*(_DWORD *)(v9 + 40) == 5) {
      goto LABEL_26;
    }
    int v18 = 5;
    goto LABEL_25;
  }
  if (NumberOfComponents == 3)
  {
    if (*(_DWORD *)(v9 + 40) == 32) {
      goto LABEL_26;
    }
    int v18 = 32;
    goto LABEL_25;
  }
  if (NumberOfComponents == 1 && *(_DWORD *)(v9 + 40) != 256)
  {
    int v18 = 256;
LABEL_25:
    *(_DWORD *)(v9 + 40) = v18;
  }
LABEL_26:
  if (v14)
  {
    float v19 = 203.0;
  }
  else
  {
    if (IsHLGBased) {
      float v19 = 100.0;
    }
    else {
      float v19 = 203.0;
    }
    if ((v6 & 0x40) != 0 && IsHLGBased && *(float *)(v9 + 56) > 0.0) {
      float v19 = *(float *)(v9 + 56);
    }
  }
  float v20 = v19;
  if ((v6 & 0x20) == 0)
  {
    if ((v16 & !IsHLGBased & !v13 | v14 ^ 1))
    {
      BOOL v21 = !IsPQBased;
      if ((v6 & 0x40) != 0) {
        BOOL v21 = 0;
      }
      if (v21)
      {
        float v20 = v19;
        if (IsHLGBased)
        {
          float v22 = *(float *)(v9 + 48);
          if (v22 >= 4.92610837) {
            float v22 = 4.9261;
          }
          *(float *)(v9 + 48) = v22;
          float v20 = (float)(v22 + -1.0) * 229.23463 + 100.0;
        }
      }
      else
      {
        float v20 = *(float *)(v9 + 48) * v19;
      }
      int v23 = v20 <= 999.9 || !IsPQBased;
      if (((v23 | v81) & 1) == 0)
      {
        float v20 = 999.9;
        *(float *)(v9 + 48) = 999.9 / v19;
      }
    }
    else
    {
      float v20 = *(float *)(v9 + 48) * v19;
    }
  }
  if (*(float *)(v9 + 52) == 0.0) {
    float v24 = 4.9261;
  }
  else {
    float v24 = *(float *)(v9 + 52);
  }
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  long long v25 = space;
  int v26 = v6 & 0x30;
  if (*(float *)&dword_1EB2ACB98 != 0.0)
  {
    float v27 = 203.0;
    if (v19 != 0.0) {
      float v27 = v19;
    }
    float v24 = *(float *)&dword_1EB2ACB98 / v27;
  }
  int v80 = BYTE7(xmmword_1EB2ACC30);
  if (!BYTE7(xmmword_1EB2ACC30))
  {
    if (v85 != 16) {
      goto LABEL_65;
    }
    if (CA::ColorProgram::Cache::force_single_cache(void)::once[0] != -1) {
      dispatch_once(CA::ColorProgram::Cache::force_single_cache(void)::once, &__block_literal_global_11751);
    }
    if (!CA::ColorProgram::Cache::force_single_cache(void)::force_single_cache) {
      uint64_t v28 = (float **)(v9 + 32);
    }
    else {
LABEL_65:
    }
      uint64_t v28 = (float **)(v9 + 24);
    if (CA::ColorProgram::Cache::find_program(v9, v28, v8, space, v6, v88, v20, v24))
    {
      char v29 = *v28;
      uint64_t v30 = &CA::callback_timer;
      goto LABEL_155;
    }
  }
  BOOL v31 = v85 == 0;
  int v83 = v6 & 0x400 | v82;
  if (v83) {
    unsigned int v32 = (v6 >> 3) & 1 | 2;
  }
  else {
    unsigned int v32 = (v6 >> 3) & 1;
  }
  if (CA::ColorProgram::Cache::lookup_(CGColorSpace *,unsigned int,CGColorRenderingIntent)::options_once != -1) {
    dispatch_once(&CA::ColorProgram::Cache::lookup_(CGColorSpace *,unsigned int,CGColorRenderingIntent)::options_once, &__block_literal_global_61_11757);
  }
  if ((v6 & 0x30) != 0) {
    int v33 = 4;
  }
  else {
    int v33 = v32;
  }
  X::CFRef<__CFDictionary const*>::operator=((const void **)&theDict, (CFTypeRef)CA::ColorProgram::Cache::lookup_(CGColorSpace *,unsigned int,CGColorRenderingIntent)::converter_options[v33]);
  LODWORD(v34) = 1.0;
  float v35 = 1.0;
  if ((v6 & 0x20) == 0) {
    float v35 = *(float *)(v9 + 48);
  }
  if (v35 > 0.0) {
    float v36 = 1.0;
  }
  else {
    float v36 = v24;
  }
  if (v35 >= 1.0) {
    float v37 = v35;
  }
  else {
    float v37 = v36;
  }
  if ((v6 & 0x30) != 0 || IsHLGBased)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
    if ((v6 & 0x30) != 0)
    {
      *(float *)&long long valuePtr = v20;
      CFNumberRef v39 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
      CFDictionarySetValue(MutableCopy, @"kCGTargetDisplayWhite", v39);
      if (v14)
      {
        *(float *)&long long valuePtr = v37;
        CFNumberRef v40 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
        *(float *)&long long valuePtr = v24 * 203.0;
        CFNumberRef v41 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
        uint64_t v42 = *MEMORY[0x1E4F1DE80];
        *(void *)&long long valuePtr = *MEMORY[0x1E4F1DE78];
        *((void *)&valuePtr + 1) = v42;
        values[0] = v40;
        values[1] = v41;
        CFDictionaryRef v43 = CFDictionaryCreate(0, (const void **)&valuePtr, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (v41) {
          CFRelease(v41);
        }
        BOOL v44 = v85 == 0;
        if (v40) {
          CFRelease(v40);
        }
        CFDictionarySetValue(MutableCopy, (const void *)*MEMORY[0x1E4F1DB50], v43);
        long long v25 = space;
        if (v43) {
          CFRelease(v43);
        }
      }
      else
      {
        BOOL v44 = v85 == 0;
        CFDictionarySetValue(MutableCopy, @"kCGApplyToneMappingForBT2100", (const void *)*MEMORY[0x1E4F1CFD0]);
      }
      if (v81)
      {
        CFDictionaryRemoveAllValues(MutableCopy);
        Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        *(float *)&long long valuePtr = v37;
        CFNumberRef v46 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
        CFDictionarySetValue(Mutable, @"kCGFlexGTCTargetHeadroom", v46);
        CFDictionarySetValue(MutableCopy, @"kCGApplyFlexLumaScaling", Mutable);
        if (v46) {
          CFRelease(v46);
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
      }
      BOOL v31 = v44;
      if (v39) {
        CFRelease(v39);
      }
    }
    X::CFRef<__CFDictionary const*>::operator=((const void **)&theDict, MutableCopy);
    int v26 = v6 & 0x30;
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
  }
  int v47 = CGColorConversionInfoCreateFromList(theDict, v8, kCGColorConversionTransformFromSpace, kCGRenderingIntentDefault, v34, v25, 1, 0, 0);
  int32x4_t v48 = v47;
  uint64_t v30 = &CA::callback_timer;
  if (!BYTE8(xmmword_1EB2ACC30))
  {
    if (v47) {
      goto LABEL_105;
    }
LABEL_140:
    char v29 = CA::ColorProgram::Program::null_program(v47);
    if (!v29) {
      goto LABEL_156;
    }
    goto LABEL_141;
  }
  BOOL v60 = v31;
  CFStringRef v61 = CFCopyDescription(theDict);
  bzero(&valuePtr, 0x1000uLL);
  if (v61)
  {
    if (x_log_hook_p())
    {
      CA_CFStringGetCString(v61, (char *)&valuePtr, 4096);
      x_log_();
    }
    else
    {
      uint64_t v62 = x_log_category_color;
      if (os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_DEFAULT))
      {
        CString = CA_CFStringGetCString(v61, (char *)&valuePtr, 4096);
        LODWORD(values[0]) = 134218242;
        *(void **)((char *)values + 4) = v48;
        WORD2(values[1]) = 2080;
        *(void **)((char *)&values[1] + 6) = (void *)CString;
        _os_log_impl(&dword_184668000, v62, OS_LOG_TYPE_DEFAULT, "CCColorConversionInfo %p Options: %s\n", (uint8_t *)values, 0x16u);
      }
    }
    CFRelease(v61);
    int v26 = v6 & 0x30;
  }
  BOOL v31 = v60;
  if (!v48) {
    goto LABEL_140;
  }
LABEL_105:
  CGColorSpaceModel Model = CGColorSpaceGetModel(v25);
  int v50 = *(_DWORD *)(v9 + 72);
  BOOL v51 = *(_DWORD *)(v9 + 76) == 24;
  if (v50 == 14) {
    unsigned int v52 = 6;
  }
  else {
    unsigned int v52 = 5;
  }
  if (v50 == 14) {
    unsigned int v53 = 2;
  }
  else {
    unsigned int v53 = 1;
  }
  if (Model) {
    uint64_t v54 = v52;
  }
  else {
    uint64_t v54 = v53;
  }
  char v87 = 0;
  if (v83) {
    BOOL v55 = 0;
  }
  else {
    BOOL v55 = v31;
  }
  if (*(unsigned char *)(v9 + 60)) {
    int v56 = 2;
  }
  else {
    int v56 = v55;
  }
  char v29 = CA::ColorProgram::Program::color_program((uint64_t)v48, *(unsigned int *)(v9 + 40), v56, v51, v54, v6, &v87, v37, v20);
  if (v87)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      unint64_t v57 = x_log_category_color;
      if (os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_ERROR))
      {
        LOWORD(valuePtr) = 0;
        _os_log_impl(&dword_184668000, v57, OS_LOG_TYPE_ERROR, "Failed to iterate CGColorConverter ", (uint8_t *)&valuePtr, 2u);
      }
    }
    long long v119 = 0u;
    long long v120 = 0u;
    long long v117 = 0u;
    long long v118 = 0u;
    long long v115 = 0u;
    long long v116 = 0u;
    long long valuePtr = 0u;
    long long v114 = 0u;
    long long v111 = 0u;
    long long v112 = 0u;
    long long v109 = 0u;
    long long v110 = 0u;
    long long v107 = 0u;
    long long v108 = 0u;
    memset(values, 0, sizeof(values));
    CA_CGColorSpaceGetCString(v8, (char *)&valuePtr);
    CA_CGColorSpaceGetCString(v25, (char *)values);
    if (x_log_hook_p())
    {
      CGColorSpaceUsesExtendedRange(v25);
      x_log_();
    }
    else
    {
      uint64_t v58 = x_log_category_color;
      if (os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_ERROR))
      {
        BOOL v59 = CGColorSpaceUsesExtendedRange(v25);
        *(_DWORD *)buf = 136315650;
        p_long long valuePtr = &valuePtr;
        __int16 v92 = 2080;
        CGColorSpaceModel v93 = values;
        __int16 v94 = 1024;
        BOOL v95 = v59;
        _os_log_impl(&dword_184668000, v58, OS_LOG_TYPE_ERROR, "'%s' --> '%s' (extended: %d)\n", buf, 0x1Cu);
      }
    }
    int v26 = v6 & 0x30;
  }
  CFRelease(v48);
  if (!v29) {
    goto LABEL_156;
  }
LABEL_141:
  int v64 = *(_DWORD *)(v9 + 44) + 1;
  *(_DWORD *)(v9 + 44) = v64;
  v29[2] = v64;
  *((void *)v29 + 2) = CGColorSpaceRetain(v8);
  *((void *)v29 + 3) = CGColorSpaceRetain(v25);
  v29[22] = v6;
  v29[8] = 0;
  v29[23] = *(_DWORD *)(v9 + 40);
  *((float *)v29 + 25) = v24;
  *((float *)v29 + 26) = v20;
  if (v26 != 16) {
    goto LABEL_145;
  }
  if (CA::ColorProgram::Cache::force_single_cache(void)::once[0] != -1) {
    dispatch_once(CA::ColorProgram::Cache::force_single_cache(void)::once, &__block_literal_global_11751);
  }
  if (!CA::ColorProgram::Cache::force_single_cache(void)::force_single_cache)
  {
    *(void *)char v29 = *(void *)(v9 + 32);
    if (!v80)
    {
      *(void *)(v9 + 32) = v29;
      if (BYTE8(xmmword_1EB2ACC30))
      {
        if (x_log_hook_p())
        {
          x_log_();
          long long v25 = space;
          int v26 = v6 & 0x30;
          goto LABEL_151;
        }
        uint64_t v78 = x_log_category_color;
        long long v25 = space;
        int v26 = v6 & 0x30;
        if (!os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_151;
        }
        LOWORD(valuePtr) = 0;
        float v79 = "Added program to dynamic cache";
        goto LABEL_173;
      }
    }
  }
  else
  {
LABEL_145:
    *(void *)char v29 = *(void *)(v9 + 24);
    if (!v80)
    {
      *(void *)(v9 + 24) = v29;
      if (BYTE8(xmmword_1EB2ACC30))
      {
        if (x_log_hook_p())
        {
          x_log_();
          goto LABEL_151;
        }
        uint64_t v78 = x_log_category_color;
        if (!os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_151;
        }
        LOWORD(valuePtr) = 0;
        float v79 = "Added program to static cache";
LABEL_173:
        _os_log_impl(&dword_184668000, v78, OS_LOG_TYPE_DEFAULT, v79, (uint8_t *)&valuePtr, 2u);
      }
    }
  }
LABEL_151:
  int v65 = v29[9];
  if (v29[23] == 5 || (v6 & 1) != 0 && v65) {
    v29[9] = v65 | 0x80000000;
  }
LABEL_155:
  if (!*((unsigned char *)v30 + 3128)) {
    goto LABEL_156;
  }
  long long v119 = 0u;
  long long v120 = 0u;
  long long v117 = 0u;
  long long v118 = 0u;
  long long v115 = 0u;
  long long v116 = 0u;
  long long valuePtr = 0u;
  long long v114 = 0u;
  long long v111 = 0u;
  long long v112 = 0u;
  long long v109 = 0u;
  long long v110 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  memset(values, 0, sizeof(values));
  CA_CGColorSpaceGetCString(v8, (char *)&valuePtr);
  CA_CGColorSpaceGetCString(v25, (char *)values);
  BOOL v67 = CGColorSpaceUsesITUR_2100TF(v8);
  BOOL v68 = x_log_hook_p();
  if (v67)
  {
    if (v68)
    {
      CGColorSpaceUsesExtendedRange(v25);
LABEL_165:
      x_log_();
      goto LABEL_156;
    }
    uint64_t v69 = x_log_category_color;
    if (os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v70 = CGColorSpaceUsesExtendedRange(v25);
      unsigned int v71 = v29[22];
      double v72 = *((float *)v29 + 24);
      double v73 = *((float *)v29 + 26);
      *(_DWORD *)buf = 136316930;
      p_long long valuePtr = &valuePtr;
      __int16 v92 = 2080;
      CGColorSpaceModel v93 = values;
      __int16 v94 = 1024;
      BOOL v95 = v70;
      __int16 v96 = 1024;
      BOOL v97 = v26 != 0;
      __int16 v98 = 1024;
      int v99 = (v71 >> 5) & 1;
      __int16 v100 = 2048;
      double v101 = v72;
      __int16 v102 = 2048;
      double v103 = v73;
      __int16 v104 = 1024;
      int v105 = (v71 >> 6) & 1;
      CFTypeID v74 = "'%s' --> '%s' (extended: %d), BT2100 Tonemapping: %d, to SDR: %d, headroom: %g, target nits: %g, reference preset: %d\n";
      unsigned int v75 = v69;
      uint32_t v76 = 66;
LABEL_170:
      _os_log_impl(&dword_184668000, v75, OS_LOG_TYPE_DEFAULT, v74, buf, v76);
    }
  }
  else
  {
    if (v68) {
      goto LABEL_165;
    }
    uint64_t v77 = x_log_category_color;
    if (os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      p_long long valuePtr = &valuePtr;
      __int16 v92 = 2080;
      CGColorSpaceModel v93 = values;
      CFTypeID v74 = "'%s' --> '%s'\n";
      unsigned int v75 = v77;
      uint32_t v76 = 22;
      goto LABEL_170;
    }
  }
LABEL_156:
  if (cf) {
    CFRelease(cf);
  }
  if (theDict) {
    CFRelease(theDict);
  }
  return v29;
}

uint64_t CA::ColorProgram::Cache::find_program(uint64_t a1, float **a2, CGColorSpace *a3, CGColorSpace *a4, int a5, unsigned __int8 *a6, float a7, float a8)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  if (a6[3]) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = (a6[5] | a6[4]) == 0;
  }
  int v15 = !v14;
  int v16 = *a2;
  int v17 = 0;
  if (*a2)
  {
    int v18 = a2;
    BOOL v59 = a4;
    do
    {
      float v19 = (float **)v16;
      if (a6[1])
      {
        float v20 = *(float *)(a1 + 48);
        float v21 = v16[24];
        if (v20 == v21)
        {
          BOOL v22 = 0;
        }
        else
        {
          if (v20 == 1.0 || v21 == 1.0)
          {
            int v24 = 1;
            goto LABEL_29;
          }
          BOOL v22 = vabds_f32(v20, v21) > (float)(fminf(v20, v21) * 0.01);
        }
        if (((v22 | v15 ^ 1) & 1) == 0)
        {
LABEL_21:
          float v25 = v16[26];
          BOOL v22 = v25 != a7;
          if (v25 <= 0.0) {
            BOOL v22 = 0;
          }
        }
      }
      else
      {
        if (v15) {
          goto LABEL_21;
        }
        BOOL v22 = 0;
      }
      if (*a6) {
        int v24 = 1;
      }
      else {
        int v24 = v22;
      }
      if (!v22 && *a6) {
        int v24 = v16[25] != a8;
      }
LABEL_29:
      if (!*((_DWORD *)v16 + 9))
      {
        if (*(unsigned char *)(a1 + 64)) {
          BOOL v26 = 1;
        }
        else {
          BOOL v26 = *(unsigned char *)(a1 + 65) != 0;
        }
        if (*(_DWORD *)(a1 + 68) != 2) {
          BOOL v26 = 0;
        }
        v24 &= v26;
      }
      if (!*((_DWORD *)v16 + 8) && *((_DWORD *)v16 + 22) == a5 && *((_DWORD *)v16 + 23) == *(_DWORD *)(a1 + 40))
      {
        if (*((CGColorSpace **)v16 + 2) == a3 || (int v27 = CGColorSpaceEqualToColorSpaceIgnoringRange(), a4 = v59, v27))
        {
          if (v19[3] == (float *)a4)
          {
            int v28 = 1;
          }
          else
          {
            int v28 = CGColorSpaceEqualToColorSpaceIgnoringRange();
            a4 = v59;
          }
          if (((v28 ^ 1 | v24) & 1) == 0)
          {
            CGColorSpace *v18 = *v19;
            int v33 = a2;
            int *v19 = *a2;
            if (BYTE8(xmmword_1EB2ACC30))
            {
              long long v79 = 0u;
              long long v80 = 0u;
              long long v77 = 0u;
              long long v78 = 0u;
              long long v75 = 0u;
              long long v76 = 0u;
              long long v73 = 0u;
              long long v74 = 0u;
              long long v71 = 0u;
              long long v72 = 0u;
              long long v69 = 0u;
              memset(v70, 0, sizeof(v70));
              memset(buf, 0, sizeof(buf));
              BOOL v44 = a3;
              uint64_t v45 = a4;
              CA_CGColorSpaceGetCString(v44, (char *)&v73);
              CA_CGColorSpaceGetCString(v45, (char *)buf);
              if (x_log_hook_p())
              {
                x_log_();
              }
              else
              {
                CFNumberRef v46 = x_log_category_color;
                if (os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_DEFAULT))
                {
                  int v47 = *(_DWORD *)(a1 + 40);
                  int v48 = *a6;
                  if ((float **)(a1 + 24) == a2) {
                    uint64_t v49 = "static";
                  }
                  else {
                    uint64_t v49 = "dynamic";
                  }
                  int v50 = a6[1];
                  double v51 = *(float *)(a1 + 48);
                  int v52 = *((_DWORD *)v19 + 8);
                  int v53 = *((_DWORD *)v19 + 22);
                  int v54 = *((_DWORD *)v19 + 23);
                  double v55 = *((float *)v19 + 24);
                  double v56 = *((float *)v19 + 25);
                  double v57 = *((float *)v19 + 26);
                  *(_DWORD *)BOOL v60 = 134222850;
                  *(void *)&v60[4] = v19;
                  *(_WORD *)&v60[12] = 2080;
                  *(void *)&v60[14] = v49;
                  *(_WORD *)&v60[22] = 1024;
                  *(_DWORD *)&v60[24] = v17;
                  *(_WORD *)&v60[28] = 2080;
                  *(void *)&v60[30] = &v73;
                  *(_WORD *)&v60[38] = 2080;
                  *(void *)&v60[40] = buf;
                  *(_WORD *)&v60[48] = 1024;
                  *(_DWORD *)&v60[50] = 0;
                  *(_WORD *)&v60[54] = 1024;
                  *(_DWORD *)&v60[56] = a5;
                  *(_WORD *)&v60[60] = 1024;
                  *(_DWORD *)&v60[62] = v47;
                  *(_WORD *)&v60[66] = 2048;
                  *(double *)&v60[68] = v51;
                  *(_WORD *)&v60[76] = 2048;
                  *(double *)&v60[78] = a8;
                  *(_WORD *)&v60[86] = 2048;
                  *(double *)&v60[88] = a7;
                  *(_WORD *)&v60[96] = 1024;
                  *(_DWORD *)&v60[98] = v48;
                  *(_WORD *)&v60[102] = 1024;
                  *(_DWORD *)&v60[104] = v50;
                  *(_WORD *)&v60[108] = 1024;
                  *(_DWORD *)&v60[110] = v15;
                  *(_WORD *)&v60[114] = 1024;
                  *(_DWORD *)&v60[116] = v52;
                  *(_WORD *)&v60[120] = 1024;
                  *(_DWORD *)&v60[122] = v53;
                  *(_WORD *)&v60[126] = 1024;
                  int v61 = v54;
                  __int16 v62 = 2048;
                  double v63 = v55;
                  __int16 v64 = 2048;
                  double v65 = v56;
                  __int16 v66 = 2048;
                  double v67 = v57;
                  _os_log_impl(&dword_184668000, v46, OS_LOG_TYPE_DEFAULT, "Found matching color program %p in %s cache at %d for color matching from '%s' to '%s'. Search parameters: ri=%d flags=0x%x cube_size=%u tonemap_headroom=%f content_headroom=%f target_nits=%f tm=%d dynamic_tm=%d need_target_nits=%d. Color program: ri=%d flags=0x%x cube_size=%u tonemap_headroom=%f content_headroom=%f target_nits=%f.", v60, 0xA2u);
                }
              }
              CA::ColorProgram::Program::show((CA::ColorProgram::Program *)v19);
              int v33 = a2;
            }
            *int v33 = (float *)v19;
            return 1;
          }
        }
      }
      int v16 = *v19;
      if (v17 == 1000)
      {
        if (!v16)
        {
          int v17 = 1001;
          break;
        }
        int v29 = 0;
        int *v19 = 0;
        do
        {
          uint64_t v30 = *(float **)v16;
          CA::ColorProgram::Program::~Program((CA::ColorProgram::Program *)v16);
          free(v31);
          ++v29;
          int v16 = v30;
        }
        while (v30);
        if (BYTE8(xmmword_1EB2ACC30))
        {
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            CFDictionaryRef v43 = x_log_category_color;
            if (os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)BOOL v60 = 67109120;
              *(_DWORD *)&v60[4] = v29;
              _os_log_impl(&dword_184668000, v43, OS_LOG_TYPE_DEFAULT, "Purged %d entries from color program cache", v60, 8u);
            }
          }
          int v17 = 1001;
          a4 = v59;
          break;
        }
        return 0;
      }
      ++v17;
      int v18 = v19;
    }
    while (v16);
  }
  if (BYTE8(xmmword_1EB2ACC30))
  {
    memset(v60, 0, sizeof(v60));
    long long v79 = 0u;
    long long v80 = 0u;
    long long v77 = 0u;
    long long v78 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    long long v73 = 0u;
    long long v74 = 0u;
    double v34 = a4;
    CA_CGColorSpaceGetCString(a3, (char *)v60);
    CA_CGColorSpaceGetCString(v34, (char *)&v73);
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      float v35 = x_log_category_color;
      if (os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_DEFAULT))
      {
        int v36 = *(_DWORD *)(a1 + 40);
        float v37 = *(float *)(a1 + 48);
        int v38 = a6[1];
        if ((float **)(a1 + 24) == a2) {
          CFNumberRef v39 = "static";
        }
        else {
          CFNumberRef v39 = "dynamic";
        }
        *(_DWORD *)buf = 136317954;
        *(void *)&uint8_t buf[4] = v39;
        CFNumberRef v40 = "n";
        *(_WORD *)&buf[12] = 1024;
        if (v38) {
          CFNumberRef v41 = "y";
        }
        else {
          CFNumberRef v41 = "n";
        }
        *(_DWORD *)&buf[14] = v17;
        double v42 = v37;
        *(_WORD *)&buf[18] = 1024;
        if (v15) {
          CFNumberRef v40 = "y";
        }
        *(_DWORD *)&buf[20] = 0;
        *(_WORD *)&buf[24] = 1024;
        *(_DWORD *)&buf[26] = a5;
        *(_WORD *)&buf[30] = 1024;
        LODWORD(v69) = v36;
        WORD2(v69) = 2080;
        *(void *)((char *)&v69 + 6) = v60;
        HIWORD(v69) = 2080;
        *(void *)&v70[0] = &v73;
        WORD4(v70[0]) = 2080;
        *(void *)((char *)v70 + 10) = v41;
        WORD1(v70[1]) = 2048;
        *(double *)((char *)&v70[1] + 4) = v42;
        WORD6(v70[1]) = 2048;
        *(double *)((char *)&v70[1] + 14) = a8;
        WORD3(v70[2]) = 2080;
        *((void *)&v70[2] + 1) = v40;
        LOWORD(v71) = 2048;
        *(double *)((char *)&v71 + 2) = a7;
        _os_log_impl(&dword_184668000, v35, OS_LOG_TYPE_DEFAULT, "No matching program in %s cache after %d; ri %d; f 0x%x; cu %d; src %s; dst %s; dt %s; targ_hr %f; source_hr %f; nn %s; tn %f",
          buf,
          0x6Au);
      }
    }
  }
  return 0;
}

uint64_t CA::Render::Texture::should_cache(CA::Render::Texture *this)
{
  return 1;
}

void CA_CGColorGetRGBComponents(CGColor *a1, CGColorSpace *a2, CGFloat *a3)
{
  Components = CGColorGetComponents(a1);
  ColorSpace = CGColorGetColorSpace(a1);
  if (CARequiresColorMatching(ColorSpace, a2, 0)) {
    goto LABEL_13;
  }
  CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
  if (Model == kCGColorSpaceModelRGB)
  {
    *a3 = *Components;
    a3[1] = Components[1];
    a3[2] = Components[2];
    double Alpha = Components[3];
    goto LABEL_10;
  }
  if (Model)
  {
LABEL_13:
    if (CARetainColorTransform(a2))
    {
      CGColorTransformConvertColorComponents();
      CGColorTransformRelease();
    }
    else
    {
      *a3 = *Components;
      a3[1] = Components[1];
      a3[2] = Components[2];
    }
    double Alpha = CGColorGetAlpha(a1);
  }
  else
  {
    *a3 = *Components;
    a3[1] = *Components;
    a3[2] = *Components;
    double Alpha = Components[1];
  }
LABEL_10:
  a3[3] = Alpha;
}

void CA_CGColorSpaceGetCString(CGColorSpace *a1, char *a2)
{
  if (a2) {
    *a2 = 0;
  }
  CFStringRef v4 = (const __CFString *)CGColorSpaceCopyICCProfileDescription();
  if (v4 || (CFStringRef v4 = CGColorSpaceCopyName(a1)) != 0)
  {
    CFStringGetCString(v4, a2, 128, 0x8000100u);
    CFRelease(v4);
  }
}

CA::Render::Texture *CA::Render::anonymous namespace'::create_image_from_image_data(CGImageRef image, CGImage *a2, CGColorSpace *a3, __int16 a4, double a5)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  int v10 = BYTE9(ca_debug_options);
  if ((a4 & 0x20) == 0 && a3 <= 0x23 && ((0x1FFFFFF2FuLL >> (char)a3) & 1) == 0)
  {
    if (BYTE9(ca_debug_options))
    {
      if (x_log_hook_p()) {
        goto LABEL_11;
      }
      uint64_t v19 = x_log_category_render;
      if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT)) {
      *(_DWORD *)buf = 134218240;
      }
      CGImageRef v39 = image;
      __int16 v40 = 1024;
      int v41 = (int)a3;
      float v20 = "CoreAnimation: copied CGImageRef %p - non-native format (%d)\n";
      float v21 = v19;
      uint32_t v22 = 18;
      goto LABEL_21;
    }
  }
  if (a3 != 14 && a3 != -1)
  {
    DataProvider = (void (*)(const void *, void *))CGImageGetDataProvider(image);
    unint64_t v12 = CGDataProviderRetainBytePtr();
    size_t Width = CGImageGetWidth(image);
    size_t Height = CGImageGetHeight(image);
    size_t BytesPerRow = CGImageGetBytesPerRow(image);
    size_t v37 = BytesPerRow;
    CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
    int v17 = ColorSpace;
    if (!v12)
    {
      if (v10)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          int v28 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            CGImageRef v39 = image;
            _os_log_impl(&dword_184668000, v28, OS_LOG_TYPE_DEFAULT, "CoreAnimation: copied CGImageRef %p - no data pointer\n", buf, 0xCu);
          }
        }
      }
    }
    int v36 = ColorSpace;
    SizeOfunint64_t Data = CGDataProviderGetSizeOfData();
    if (SizeOfData == -1)
    {
      if (x_log_hook_p())
      {
LABEL_29:
        x_log_();
LABEL_43:
        image_by_copying = 0;
        goto LABEL_72;
      }
      int v29 = x_log_category_render;
      if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR)) {
        goto LABEL_43;
      }
      *(_WORD *)buf = 0;
      uint64_t v30 = "CoreAnimation: data provider size invalid";
LABEL_42:
      _os_log_impl(&dword_184668000, v29, OS_LOG_TYPE_ERROR, v30, buf, 2u);
      goto LABEL_43;
    }
    if (SizeOfData < (CGImageGetBitsPerPixel(image) >> 3) * Width + BytesPerRow * (Height - 1))
    {
      if (x_log_hook_p()) {
        goto LABEL_29;
      }
      int v29 = x_log_category_render;
      if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR)) {
        goto LABEL_43;
      }
      *(_WORD *)buf = 0;
      uint64_t v30 = "CoreAnimation: data provider size is too small";
      goto LABEL_42;
    }
    if (qword_1EB2A87C0
      && ((qword_1EB2A87C0 & (qword_1EB2A87C0 - 1)) != 0
        ? (unint64_t v27 = v12 % qword_1EB2A87C0)
        : (unint64_t v27 = (qword_1EB2A87C0 - 1) & v12),
          v27))
    {
      if (!v10) {
        goto LABEL_71;
      }
      if (!x_log_hook_p())
      {
        unsigned int v32 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          CGImageRef v39 = image;
          _os_log_impl(&dword_184668000, v32, OS_LOG_TYPE_DEFAULT, "CoreAnimation: copied CGImageRef %p - bad image alignment\n", buf, 0xCu);
        }
        goto LABEL_71;
      }
    }
    else if (qword_1EB2A87C8 {
           && ((qword_1EB2A87C8 & (qword_1EB2A87C8 - 1)) != 0
    }
             ? (unint64_t v31 = BytesPerRow % qword_1EB2A87C8)
             : (unint64_t v31 = BytesPerRow & (qword_1EB2A87C8 - 1)),
               v31))
    {
      if (!v10) {
        goto LABEL_71;
      }
      if (!x_log_hook_p())
      {
        int v33 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          CGImageRef v39 = image;
          _os_log_impl(&dword_184668000, v33, OS_LOG_TYPE_DEFAULT, "CoreAnimation: copied CGImageRef %p - bad row alignment\n", buf, 0xCu);
        }
        goto LABEL_71;
      }
    }
    else
    {
      if ((a4 & 1) == 0)
      {
        if (image_by_copying)
        {
          CGDataProviderRetain((CGDataProviderRef)DataProvider);
          return (CA::Render::Texture *)image_by_copying;
        }
LABEL_72:
        CGDataProviderReleaseBytePtr();
        return (CA::Render::Texture *)image_by_copying;
      }
      if (!v10)
      {
LABEL_71:
        goto LABEL_72;
      }
      if (!x_log_hook_p())
      {
        double v34 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          CGImageRef v39 = image;
          _os_log_impl(&dword_184668000, v34, OS_LOG_TYPE_DEFAULT, "CoreAnimation: copied CGImageRef %p - mipmap generation\n", buf, 0xCu);
        }
        goto LABEL_71;
      }
    }
    x_log_();
    goto LABEL_71;
  }
  if (BYTE9(ca_debug_options))
  {
    if (x_log_hook_p())
    {
LABEL_11:
      x_log_();
    }
    uint64_t v23 = x_log_category_render;
    if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT)) {
    *(_DWORD *)buf = 134217984;
    }
    CGImageRef v39 = image;
    float v20 = "CoreAnimation: copied CGImageRef %p - format not supported by hardware\n";
    float v21 = v23;
    uint32_t v22 = 12;
LABEL_21:
    _os_log_impl(&dword_184668000, v21, OS_LOG_TYPE_DEFAULT, v20, buf, v22);
  }
}

uint64_t CA::Render::CompressedImage::should_cache(CA::Render::CompressedImage *this)
{
  return (*((unsigned __int8 *)this + 176) >> 1) & 1;
}

uint64_t CA::Render::anonymous namespace'::image_format_from_component_type(int a1, int a2, int a3)
{
  uint64_t result = 0xFFFFFFFFLL;
  int v5 = a1 - 1;
  unsigned int v6 = a2 - 1;
  switch(v5)
  {
    case 0:
      if (v6 < 4) {
        unsigned int v7 = 1;
      }
      else {
        unsigned int v7 = 3;
      }
      if (a2 == 5) {
        int v8 = 19;
      }
      else {
        int v8 = 10;
      }
      if (v6 >= 4) {
        unsigned int v9 = v8;
      }
      else {
        unsigned int v9 = 18;
      }
      if (a3) {
        uint64_t result = v9;
      }
      else {
        uint64_t result = v7;
      }
      break;
    case 1:
      BOOL v10 = v6 >= 4;
      if (v6 < 4) {
        unsigned int v11 = 21;
      }
      else {
        unsigned int v11 = 22;
      }
      if (v10) {
        unsigned int v12 = -1;
      }
      else {
        unsigned int v12 = 27;
      }
      goto LABEL_26;
    case 4:
      BOOL v13 = v6 >= 4;
      if (v6 >= 4) {
        unsigned int v11 = 17;
      }
      else {
        unsigned int v11 = 13;
      }
      if (v13) {
        unsigned int v12 = 25;
      }
      else {
        unsigned int v12 = 28;
      }
LABEL_26:
      if (a3) {
        uint64_t result = v12;
      }
      else {
        uint64_t result = v11;
      }
      break;
    case 5:
      if (a2 == 6) {
        int v14 = a3;
      }
      else {
        int v14 = 1;
      }
      if (v14) {
        uint64_t result = 0xFFFFFFFFLL;
      }
      else {
        uint64_t result = 31;
      }
      break;
    default:
      return result;
  }
  return result;
}

CFTypeRef CA::Render::anonymous namespace'::retain_provider_options(CA::Render::_anonymous_namespace_ *this)
{
  int v1 = (int)this;
  {
  }
  else
  {
  }
  if (!v1) {

  }
  return CFRetain(provider_options);
}

uint64_t CA::Render::anonymous namespace'::image_format_from_blockset(uint64_t a1, uint64_t a2, int a3)
{
  int ComponentType = CGImageBlockSetGetComponentType();
  Alphauint64_t Info = CGImageProviderGetAlphaInfo();
}

CFDictionaryRef CA::Render::anonymous namespace'::create_provider_options(CA::Render::_anonymous_namespace_ *this)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = 0;
  *(_OWORD *)keys = 0u;
  long long v18 = 0u;
  uint64_t v16 = 0;
  *(_OWORD *)values = 0u;
  long long v15 = 0u;
  if (this)
  {
    unsigned int v1 = 0;
  }
  else
  {
    keys[0] = *(void **)MEMORY[0x1E4F1DD38];
    values[0] = *(void **)MEMORY[0x1E4F1DD30];
    unsigned int v1 = 1;
  }
  uint64_t v2 = (void **)MEMORY[0x1E4F1CFD0];
  *(void *)((unint64_t)keys | (8 * v1)) = *MEMORY[0x1E4F1DD48];
  uint64_t v3 = *v2;
  unsigned int v4 = v1 + 1;
  *(void *)((unint64_t)values & 0xFFFFFFFFFFFFFFF7 | (8 * (v1 & 1))) = *v2;
  keys[v4] = (void *)*MEMORY[0x1E4F1DD40];
  int v5 = v1 | 2;
  values[v4] = v3;
  int v6 = qword_1EB2A87C0;
  if (qword_1EB2A87C0)
  {
    unsigned int v7 = 1 << v5;
    keys[v5] = (void *)*MEMORY[0x1E4F1DD18];
    int valuePtr = v6;
    unsigned int v8 = v1 + 3;
    values[v5] = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  }
  else
  {
    unsigned int v7 = 0;
    unsigned int v8 = v1 | 2;
  }
  int v9 = qword_1EB2A87C8;
  if (qword_1EB2A87C8)
  {
    v7 |= 1 << v8;
    keys[v8] = (void *)*MEMORY[0x1E4F1DD20];
    int valuePtr = v9;
    values[v8++] = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  }
  CFDictionaryRef v10 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v8, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v11 = 0;
  do
  {
    if ((v7 >> v11)) {
      CFRelease(values[v11]);
    }
    ++v11;
  }
  while (v8 != v11);
  return v10;
}

_DWORD *CA::Render::Pattern::new_pattern(CA::Render::Pattern *this, CGPattern *a2, CGColorSpace *a3, CGAffineTransform *a4, double a5)
{
  if (CGPatternGetType()) {
    return 0;
  }
  CGPatternGetBounds();
  double width = v78.size.width;
  double height = v78.size.height;
  if (CGRectIsEmpty(v78)) {
    return 0;
  }
  double v74 = 1.0;
  __asm { FMOV            V0.2D, #1.0 }
  float64x2_t v77 = _Q0;
  if (a3)
  {
    uint64_t Image = CGPatternGetImage();
    double v18 = 1.0;
    if (!Image)
    {
      CGPatternGetMatrix();
      double v19 = *((double *)a3 + 1);
      double v20 = *((double *)a3 + 2);
      double v21 = *((double *)a3 + 3);
      double v22 = 0.0 * v19 + 0.0 * v21;
      double v23 = (*(double *)a3 * 0.0 + v20 * 0.0) * (*(double *)a3 * 0.0 + v20 * 0.0)
          + (v19 * 0.0 + v21 * 0.0) * (v19 * 0.0 + v21 * 0.0);
      double v24 = v22 * v22 + (0.0 * *(double *)a3 + 0.0 * v20) * (0.0 * *(double *)a3 + 0.0 * v20);
      double v25 = sqrt(v23);
      if (v23 == 1.0) {
        double v18 = v23;
      }
      else {
        double v18 = v25;
      }
      double v26 = sqrt(v24);
      if (v24 == 1.0) {
        double v27 = v24;
      }
      else {
        double v27 = v26;
      }
      for (; v18 > 1.0 && v18 * width > 2048.0; double v18 = v18 * 0.5)
        ;
      for (; v27 > 1.0 && v27 * height > 2048.0; double v27 = v27 * 0.5)
        ;
      v32.f64[0] = v18;
      double v74 = v27;
      v32.f64[1] = v27;
      float64x2_t v77 = v32;
    }
  }
  else
  {
    double v18 = 1.0;
  }
  double v75 = v18;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::pattern_lock);
  uint64_t v33 = CA::Render::pattern_cache;
  if (!CA::Render::pattern_cache)
  {
    CA::Render::pattern_cache = (uint64_t)x_hash_table_new_(0, 0, 0, 0, 0, 0);
    CA::Render::pattern_cache_list = (uint64_t)&CA::Render::pattern_cache_list;
    qword_1EB2A8A98 = (uint64_t)&CA::Render::pattern_cache_list;
    CGPatternNotificationCenter();
    CGNotificationCenterAddCallback();
    uint64_t v33 = CA::Render::pattern_cache;
  }
  uint64_t v34 = x_hash_table_lookup(v33, (uint64_t)this, 0);
  if (v34
    && (v35 = v34, (unsigned int v12 = *(_DWORD **)(v34 + 24)) != 0)
    && *((double *)v12 + 14) == v75
    && *((double *)v12 + 15) == v74
    && ((uint64_t v73 = *((void *)v12 + 16)) == 0
     || !CARequiresColorMatching(*(CGColorSpace **)(v73 + 48), a2, (a4 >> 3) & 1)))
  {
    double v56 = 0;
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::pattern_lock);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    size_t v37 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x88uLL, 0x743898A5uLL);
    unsigned int v12 = v37;
    if (v37)
    {
      v37[2] = 1;
      v37[3] = 37;
      ++dword_1EB2ADE5C;
      *(void *)size_t v37 = &unk_1ED02F960;
      CGPatternGetMatrix();
      CGPatternGetBounds();
      *((void *)v12 + 8) = v38;
      *((void *)v12 + 9) = v39;
      *((void *)v12 + 10) = v40;
      *((void *)v12 + 11) = v41;
      CGPatternGetStep();
      __asm { FMOV            V2.2D, #1.0 }
      float64x2_t v76 = _Q2;
      *((float64x2_t *)v12 + 7) = _Q2;
      *((void *)v12 + 12) = v43;
      *((void *)v12 + 13) = v44;
      *((void *)v12 + 16) = 0;
      if ((CGPatternIsColored() & 1) == 0)
      {
        a2 = 0;
        v12[3] |= 0x200u;
      }
      uint64_t v45 = (CA::Render *)CGPatternGetImage();
      if (v45)
      {
        pattern_image = CA::Render::copy_image(v45, a2, (CGColorSpace *)a4, a5, 1.0);
      }
      else
      {
        if (v77.f64[0] != 1.0 || v77.f64[1] != 1.0)
        {
          float64x2_t v49 = vdivq_f64(v76, v77);
          float64x2_t v50 = vmulq_f64(*((float64x2_t *)v12 + 1), v49);
          float64x2_t v51 = vmulq_f64(*((float64x2_t *)v12 + 2), v49);
          *((float64x2_t *)v12 + 1) = v50;
          *((float64x2_t *)v12 + 2) = v51;
          float64x2_t v52 = vmulq_f64(*((float64x2_t *)v12 + 5), v77);
          *((float64x2_t *)v12 + 4) = vmulq_f64(*((float64x2_t *)v12 + 4), v77);
          *((float64x2_t *)v12 + 5) = v52;
          *((float64x2_t *)v12 + 6) = vmulq_f64(*((float64x2_t *)v12 + 6), v77);
          *((float64x2_t *)v12 + 7) = v77;
        }
        pattern_image = CA::Render::create_pattern_image((uint64_t)this, a2, (CGFloat *)v12 + 14, (double *)v12 + 8);
      }
      int v53 = (atomic_uint *)*((void *)v12 + 16);
      *((void *)v12 + 16) = pattern_image;
      if (v53)
      {
        if (atomic_fetch_add(v53 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v53 + 16))(v53);
        }
        pattern_image = (_DWORD *)*((void *)v12 + 16);
      }
      if (pattern_image)
      {
        LODWORD(v47) = pattern_image[4];
        double v54 = (double)v47;
        if (*((double *)v12 + 12) == v54)
        {
          LODWORD(v54) = pattern_image[5];
          if (*((double *)v12 + 13) == (double)*(unint64_t *)&v54
            && *((double *)v12 + 3) == 0.0
            && *((double *)v12 + 4) == 0.0)
          {
            v12[3] |= 0x100u;
          }
        }
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::pattern_lock);
    uint64_t v55 = x_hash_table_lookup(CA::Render::pattern_cache, (uint64_t)this, 0);
    if (v55)
    {
      uint64_t v35 = v55;
      double v56 = *(atomic_uint **)(v55 + 24);
    }
    else
    {
      double v57 = (malloc_zone_t *)get_malloc_zone();
      uint64_t v58 = malloc_type_zone_malloc(v57, 0x28uLL, 0x8BB15036uLL);
      uint64_t v35 = (uint64_t)v58;
      if (v58)
      {
        v58[3] = 0;
        v58[4] = 0;
        v58[1] = v58;
        _DWORD v58[2] = this;
        *uint64_t v58 = v58;
        BOOL v59 = (int *)CA::Render::pattern_cache;
        BOOL v60 = this;
        uint64_t v61 = v35;
      }
      else
      {
        BOOL v59 = (int *)CA::Render::pattern_cache;
        BOOL v60 = this;
        uint64_t v61 = 0;
      }
      hash_table_modify(v59, (uint64_t)v60, v61, 0);
      double v56 = 0;
    }
    *(void *)(v35 + 24) = v12;
  }
  double v62 = *(double *)(v35 + 32);
  if ((a4 & 4) != 0)
  {
    if (v62 >= 0.0 && v62 < a5)
    {
      if (v62 > 0.0)
      {
        uint64_t v67 = *(void *)v35;
        __int16 v66 = *(void **)(v35 + 8);
        *(void *)(v67 + 8) = v66;
        *__int16 v66 = v67;
        *(void *)uint64_t v35 = v35;
        *(void *)(v35 + 8) = v35;
      }
      *(double *)(v35 + 32) = a5;
      BOOL v68 = &CA::Render::pattern_cache_list;
      while (1)
      {
        BOOL v68 = (uint64_t *)*v68;
        if (v68 == &CA::Render::pattern_cache_list) {
          break;
        }
        if (*((double *)v68 + 4) <= a5)
        {
          long long v69 = (void *)v68[1];
          uint64_t v70 = *(void *)v35;
          v68[1] = v35;
          *(void *)uint64_t v35 = v68;
          *long long v69 = v70;
          *(void *)(v70 + 8) = v69;
          goto LABEL_82;
        }
      }
      long long v71 = (void *)qword_1EB2A8A98;
      uint64_t v72 = *(void *)v35;
      qword_1EB2A8A98 = v35;
      *(void *)uint64_t v35 = &CA::Render::pattern_cache_list;
      *long long v71 = v72;
      *(void *)(v72 + 8) = v71;
    }
  }
  else if (v62 >= 0.0)
  {
    uint64_t v64 = *(void *)v35;
    double v63 = *(void **)(v35 + 8);
    *(void *)(v64 + 8) = v63;
    *double v63 = v64;
    *(void *)uint64_t v35 = v35;
    *(void *)(v35 + 8) = v35;
    *(void *)(v35 + 32) = 0xBFF0000000000000;
  }
LABEL_82:
  if (!atomic_fetch_add(v12 + 2, 1u)) {
    atomic_fetch_add(v12 + 2, 0xFFFFFFFF);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::pattern_lock);
  if (v56 && atomic_fetch_add(v56 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v56 + 16))(v56);
  }
  return v12;
}

CA::Render::Texture *CA::Render::anonymous namespace'::create_image_by_rendering(CGImage *a1, CGColorSpace *Extended, __int16 a3, double a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if ((a3 & 0x200) == 0)
  {
    char v5 = a3;
    unsigned int v7 = a1;
    size_t Width = (CA::Render::_anonymous_namespace_ *)CGImageGetWidth(a1);
    unsigned int Height = CGImageGetHeight(v7);
    long long v55 = 0u;
    long long v56 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v48 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    *(_OWORD *)uint64_t v41 = 0u;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    kdebug_trace();
    BOOL IsMask = CGImageIsMask(v7);
    char v12 = IsMask;
    int v13 = 0;
    uint64_t v14 = 9;
    if (Extended && !IsMask)
    {
      BOOL v15 = (CGImageHasAlpha() & 1) != 0 || CGImageGetMask() || CGImageGetMaskingColors() != 0;
      size_t BitsPerComponent = CGImageGetBitsPerComponent(v7);
      if (CGColorSpaceGetModel(Extended))
      {
        if (CGColorSpaceGetModel(Extended) == kCGColorSpaceModelCMYK)
        {
          if (v15)
          {
            Extended = (CGColorSpace *)CAGetColorSpace(0x1Du);
            int v13 = 0;
            uint64_t v14 = 1;
          }
          else
          {
            int v13 = 0;
            uint64_t v14 = 29;
          }
        }
        else if (BitsPerComponent < 9)
        {
          int v13 = 0;
          if (v15) {
            uint64_t v14 = 1;
          }
          else {
            uint64_t v14 = 3;
          }
        }
        else if ((CGImageGetBitmapInfo(v7) & 0x100) != 0)
        {
          Extended = CAColorSpaceCreateExtended(Extended);
          if (v15) {
            uint64_t v14 = 13;
          }
          else {
            uint64_t v14 = 17;
          }
          int v13 = 1;
        }
        else
        {
          int v13 = 0;
          if (v15) {
            uint64_t v14 = 21;
          }
          else {
            uint64_t v14 = 22;
          }
        }
      }
      else
      {
        int v18 = BitsPerComponent > 8 || v15;
        if (v18 == 1)
        {
          if (BitsPerComponent < 9)
          {
            Extended = (CGColorSpace *)CAGetColorSpace(3u);
            int v13 = 0;
            uint64_t v14 = 18;
          }
          else
          {
            Extended = (CGColorSpace *)CAGetColorSpace(0x1Du);
            int v13 = 0;
            uint64_t v14 = 21;
          }
        }
        else
        {
          int v13 = 0;
          uint64_t v14 = 10;
        }
      }
    }
    int v38 = v13;
    if ((v5 & 0x40) != 0)
    {
      Mask = (CGImage *)CGImageGetMask();
      if (Mask)
      {
        double v20 = Mask;
        size_t Width = (CA::Render::_anonymous_namespace_ *)CGImageGetWidth(Mask);
        unsigned int Height = CGImageGetHeight(v20);
      }
    }
    LODWORD(Width) = vcvtpd_u64_f64((double)Width * a4);
    unsigned int v21 = vcvtpd_u64_f64((double)Height * a4);
    if (v22
      && (unsigned int v23 = v22, (v24 = (unsigned __int16 *)CA::Render::aligned_malloc(v40, (unint64_t *)&v39, 0)) != 0))
    {
      double v25 = v24;
      double v26 = CAGetCachedCGBitmapContext_(v24, Width, v21, v14, v41[0], Extended);
      if (v26)
      {
        int v28 = (CGContext *)*((void *)v26 + 2);
        if (v28)
        {
          CGContextSetCompositeOperation();
          image = CGImageCreateCopy(v7);
          if (image)
          {
            CGImageSetCachingFlags();
            unsigned int v7 = image;
          }
          if (v14 == 9) {
            char v29 = v12;
          }
          else {
            char v29 = 1;
          }
          if ((v29 & 1) == 0)
          {
            CGContextSetRGBFillColor(v28, 1.0, 1.0, 1.0, 1.0);
            v59.origin.x = 0.0;
            v59.origin.y = 0.0;
            v59.size.double width = (double)Width;
            v59.size.double height = (double)v21;
            CGContextClipToMask(v28, v59, v7);
            v60.origin.x = 0.0;
            v60.origin.y = 0.0;
            v60.size.double width = (double)Width;
            v60.size.double height = (double)v21;
            CGContextFillRect(v28, v60);
LABEL_60:
            CGImageRelease(image);
            CAReleaseCachedCGContext(v28);
            if (v23 >= 2) {
            float64x2_t v32 = (void (*)(const void *, void *))v39;
            }
            MEMORY[0x185325430](*MEMORY[0x1E4F14960], v25, v39, 1, 1);
            if ((v5 & 2) != 0) {
              unsigned int v33 = 9;
            }
            else {
              unsigned int v33 = 10;
            }
            if (v14 == 10) {
              unint64_t v34 = v33;
            }
            else {
              unint64_t v34 = v14;
            }
            int v17 = CA::Render::Image::new_image((CA::Render::Image *)v34, Width, v21, v23, Extended, (CGColorSpace *)v25, v41, (const unint64_t *)CA::Render::aligned_free, v32, image);
            if (v38) {
              CGColorSpaceRelease(Extended);
            }
            if (v17) {
              *((_DWORD *)v17 + 3) |= 0x800000u;
            }
            else {
              CA::Render::aligned_free((CA::Render *)v25, (size_t)v32, v35);
            }
            goto LABEL_73;
          }
          if (a4 == 1.0 && CGImageGetBitsPerPixel(v7) != 1)
          {
            int v30 = 0;
            if ((v5 & 0x80) == 0) {
              goto LABEL_52;
            }
          }
          else
          {
            CGContextGetInterpolationQualityRange();
            CGContextSetInterpolationQualityRange();
            int v30 = 1;
            if ((v5 & 0x80) == 0)
            {
LABEL_52:
              v58.origin.x = 0.0;
              v58.origin.y = 0.0;
              v58.size.double width = (double)Width;
              v58.size.double height = (double)v21;
              CGContextDrawImage(v28, v58, v7);
              goto LABEL_58;
            }
          }
          CGContextDrawImageWithOptions();
LABEL_58:
          if (v30) {
            CGContextSetInterpolationQualityRange();
          }
          goto LABEL_60;
        }
      }
      CA::Render::aligned_free((CA::Render *)v25, (size_t)v39, v27);
      int v17 = 0;
    }
    else
    {
      int v17 = 0;
    }
LABEL_73:
    kdebug_trace();
    return v17;
  }
  return 0;
}

void CA::OGL::render(CA::OGL *this, CA::OGL::Renderer *a2, CA::Render::Update *a3)
{
  int v6 = (void *)MEMORY[0x185324A30](this, a2, a3);
  uint64_t v7 = *(void *)this;
  int v8 = *(_DWORD *)(*(void *)this + 208);
  int v9 = *(_DWORD *)(*(void *)this + 212);
  if (v8 <= v9) {
    int v10 = *(_DWORD *)(*(void *)this + 212);
  }
  else {
    int v10 = *(_DWORD *)(*(void *)this + 208);
  }
  if (v10 < 0x3FFFFFFF)
  {
    CA::OGL::Renderer::render(this, a2, 0, v5);
    ++*((_DWORD *)a2 + 66);
    CA::Render::Update::mark_composited(a2);
  }
  else
  {
    uint64_t v11 = *(void *)(v7 + 200);
    *(_OWORD *)(v7 + 200) = *((_OWORD *)a2 + 12);
    CA::OGL::Renderer::render(this, a2, 0, v5);
    ++*((_DWORD *)a2 + 66);
    CA::Render::Update::mark_composited(a2);
    *(void *)(v7 + 200) = v11;
    *(_DWORD *)(v7 + 208) = v8;
    *(_DWORD *)(v7 + 212) = v9;
  }
}

void CA::Render::Update::mark_composited(CA::Render::Update *this)
{
  unsigned int v1 = (void *)*((void *)this + 103);
  if (v1)
  {
    uint64_t v2 = (void *)*((void *)this + 103);
    atomic_compare_exchange_strong((atomic_ullong *volatile)this + 103, (unint64_t *)&v2, 0);
    if (v2 == v1)
    {
      uint64_t v3 = (void *)*v1;
      if ((void *)*v1 != v1 + 1)
      {
        do
        {
          uint64_t v4 = v3[4];
          if (*(unsigned char *)(v4 + 12) != 25) {
            __assert_rtn("mark_composited", "render-updater.cpp", 10700, "obj->type () == Render::kTypeImageQueue");
          }
          CA::Render::ImageQueue::did_composite((CA::Render::ImageQueue *)v3[4]);
          if (atomic_fetch_add((atomic_uint *volatile)(v4 + 8), 0xFFFFFFFF) == 1) {
            (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
          }
          char v5 = (void *)v3[1];
          if (v5)
          {
            do
            {
              int v6 = v5;
              char v5 = (void *)*v5;
            }
            while (v5);
          }
          else
          {
            do
            {
              int v6 = (void *)v3[2];
              BOOL v7 = *v6 == (void)v3;
              uint64_t v3 = v6;
            }
            while (!v7);
          }
          uint64_t v3 = v6;
        }
        while (v6 != v1 + 1);
      }
      std::__tree<std::tuple<unsigned short,unsigned short>>::destroy((void *)v1[1]);
      JUMPOUT(0x185323DC0);
    }
  }
}

void CA::Render::ImageQueue::did_composite(CA::Render::ImageQueue *this)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(*((void *)this + 2) + 24);
  if (v1)
  {
    uint64_t v2 = *((unsigned int *)this + 45);
    if (v2)
    {
      mach_port_t v3 = *((_DWORD *)this + 49);
      uint64_t v4 = (unsigned char *)(v1 + 586);
      int v5 = *(_DWORD *)(v1 + 52);
      unsigned int v6 = *(_DWORD *)(v1 + 40);
      do
      {
        if (*(_DWORD *)(v4 - 54))
        {
          unsigned int v7 = *(_DWORD *)(v4 - 22);
          BOOL v8 = *v4 || v3 == 0;
          BOOL v9 = v8 || v7 > v6;
          if (!v9 && v5 != 0)
          {
            int v11 = *(_DWORD *)(v4 - 30);
            mach_error_t v12 = _CACImageQueueDidComposite(v3, 0, v5, *(_DWORD *)(v4 - 22), v11);
            if (v12)
            {
              mach_error_t v13 = v12;
              if (v12 == 268435460)
              {
                if (v3 == -1 || mach_port_mod_refs(*MEMORY[0x1E4F14960], v3, 0, 1))
                {
                  if (x_log_hook_p())
                  {
                    x_log_();
                  }
                  else
                  {
                    uint64_t v16 = x_log_category_utilities;
                    if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136315138;
                      double v25 = "IQDidComposite";
                      _os_log_impl(&dword_184668000, v16, OS_LOG_TYPE_ERROR, "%s failed to retain right", buf, 0xCu);
                    }
                  }
                }
                else
                {
                  if (CA::MachPortUtil::reply_queue(void)::once != -1) {
                    dispatch_once(&CA::MachPortUtil::reply_queue(void)::once, &__block_literal_global_9866);
                  }
                  block[0] = MEMORY[0x1E4F143A8];
                  block[1] = 0x40000000;
                  block[2] = ___ZN2CA12MachPortUtil17call_with_timeoutIPFijjjjjEJjjjEEEijjbPKcT_DpT0__block_invoke;
                  block[3] = &__block_descriptor_tmp_116;
                  mach_port_t v18 = v3;
                  int v19 = 2;
                  int v20 = v5;
                  unsigned int v21 = v7;
                  int v22 = v11;
                  char v23 = 0;
                  block[4] = _CACImageQueueDidComposite;
                  block[5] = "IQDidComposite";
                  dispatch_async((dispatch_queue_t)CA::MachPortUtil::reply_queue(void)::queue, block);
                }
              }
              else
              {
                if (x_log_hook_p())
                {
                  mach_error_string(v13);
                  x_log_();
                }
                else
                {
                  uint64_t v14 = x_log_category_utilities;
                  if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
                  {
                    BOOL v15 = mach_error_string(v13);
                    *(_DWORD *)buf = 136315650;
                    double v25 = "IQDidComposite";
                    __int16 v26 = 1024;
                    mach_error_t v27 = v13;
                    __int16 v28 = 2080;
                    char v29 = v15;
                    _os_log_impl(&dword_184668000, v14, OS_LOG_TYPE_ERROR, "%s client message err=0x%x : %s", buf, 0x1Cu);
                  }
                }
                if (v13 != 268435460) {
                  goto LABEL_16;
                }
              }
            }
            unsigned char *v4 = 1;
          }
        }
LABEL_16:
        v4 += 160;
        --v2;
      }
      while (v2);
    }
  }
}

void CA::WindowServer::IOMFBDisplay::FrameInfo::~FrameInfo(CA::WindowServer::IOMFBDisplay::FrameInfo *this)
{
  uint64_t v2 = (char *)*((void *)this + 9);
  mach_port_t v3 = (char *)this + 80;
  if (v2 != (char *)this + 80)
  {
    do
    {
      uint64_t v4 = (atomic_uint *)*((void *)v2 + 4);
      if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
      }
      int v5 = (char *)*((void *)v2 + 1);
      if (v5)
      {
        do
        {
          unsigned int v6 = v5;
          int v5 = *(char **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          unsigned int v6 = (char *)*((void *)v2 + 2);
          BOOL v7 = *(void *)v6 == (void)v2;
          uint64_t v2 = v6;
        }
        while (!v7);
      }
      uint64_t v2 = v6;
    }
    while (v6 != v3);
  }
  BOOL v8 = (const void **)*((void *)this + 15);
  BOOL v9 = (const void **)*((void *)this + 16);
  if (v8 != v9)
  {
    do
    {
      int v10 = *v8++;
      _Block_release(v10);
    }
    while (v8 != v9);
    BOOL v8 = (const void **)*((void *)this + 15);
  }
  if (v8 != *((const void ***)this + 17)) {
    free(v8);
  }
  std::__tree<CA::Render::Update::ContextInfo>::destroy(*((void **)this + 13));
  std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(*((void **)this + 10));
}

void CA::Render::Update::~Update(CA::Render::Update *this, CA::Render::LayerNode *a2)
{
  mach_port_t v3 = (char *)this + 216;
  uint64_t v4 = (atomic_uint *)*((void *)this + 28);
  if (v4 != (atomic_uint *)v3)
  {
    do
    {
      uint64_t v5 = *(void *)v4;
      unsigned int v6 = (char *)*((void *)v4 + 1);
      *(void *)(v5 + 8) = v6;
      *(void *)unsigned int v6 = v5;
      *(void *)uint64_t v4 = v4;
      *((void *)v4 + 1) = v4;
      if (atomic_fetch_add(v4 + 4, 0xFFFFFFFF) == 1) {
        CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v4, a2);
      }
      uint64_t v4 = (atomic_uint *)v6;
    }
    while (v6 != v3);
  }
  CA::Shape::unref(*((CA::Shape **)this + 2));
  BOOL v7 = (CA::Shape *)*((void *)this + 3);
  if (v7) {
    CA::Shape::unref(v7);
  }
  CA::Shape::unref(*((CA::Shape **)this + 4));
  CA::Shape::unref(*((CA::Shape **)this + 5));
  CA::Shape::unref(*((CA::Shape **)this + 6));
  CA::Shape::unref(*((CA::Shape **)this + 7));
  CA::Shape::unref(*((CA::Shape **)this + 8));
  BOOL v9 = (CA::Shape *)*((void *)this + 1);
  if (v9) {
    CA::Shape::unref(v9);
  }
  int v10 = (CA::Render::LayerNode **)*((void *)this + 74);
  if (v10)
  {
    do
    {
      int v11 = *v10;
      if (atomic_fetch_add((atomic_uint *volatile)*v10 + 4, 0xFFFFFFFF) == 1) {
        CA::Render::LayerNode::delete_node(v11, v8);
      }
      int v10 = (CA::Render::LayerNode **)v10[1];
    }
    while (v10);
    mach_error_t v12 = (void *)*((void *)this + 74);
    if (v12)
    {
      do
      {
        mach_error_t v13 = (void *)v12[1];
        free(v12);
        mach_error_t v12 = v13;
      }
      while (v13);
    }
  }
  uint64_t v14 = (void *)*((void *)this + 75);
  if (v14)
  {
    do
    {
      (*(void (**)(void))(*(void *)*v14 + 24))();
      uint64_t v15 = *v14;
      unsigned int add = atomic_fetch_add((atomic_uint *volatile)(*v14 + 8), 0xFFFFFFFF);
      if (v15) {
        BOOL v17 = add == 1;
      }
      else {
        BOOL v17 = 0;
      }
      if (v17) {
        (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
      }
      uint64_t v14 = (void *)v14[1];
    }
    while (v14);
    mach_port_t v18 = (void *)*((void *)this + 75);
    if (v18)
    {
      do
      {
        int v19 = (void *)v18[1];
        free(v18);
        mach_port_t v18 = v19;
      }
      while (v19);
    }
  }
  CA::Render::Update::release_objects(this);
  for (uint64_t i = (uint64_t *)*((void *)this + 42); i; uint64_t i = (uint64_t *)*i)
  {
    if ((*((_DWORD *)this + 271) & 0x44) == 0)
    {
      int v22 = (os_unfair_lock_s *)i[1];
      uint32_t v23 = *((_DWORD *)i + 4);
      os_unfair_lock_lock(v22 + 13);
      if (v22[17]._os_unfair_lock_opaque < v23)
      {
        v22[17]._os_unfair_lock_opaque = v23;
        CA::Render::Context::check_sync_reqs((CA::Render::Context *)v22, 0.0);
      }
      os_unfair_lock_unlock(v22 + 13);
    }
    double v24 = (atomic_uint *)i[1];
    if (atomic_fetch_add(v24 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v24 + 16))(v24);
    }
  }
  CA::Render::Update::pop_dependence_group(this, v20);
  for (uint64_t j = (uint64_t **)*((void *)this + 63); j; uint64_t j = (uint64_t **)*j)
  {
    int v26 = *((_DWORD *)this + 62);
    uint64_t v27 = j[1][32];
    os_unfair_lock_lock((os_unfair_lock_t)(v27 + 36));
    uint64_t v28 = *(void *)(v27 + 40);
    os_unfair_lock_lock((os_unfair_lock_t)(v28 + 40));
    if (*(_DWORD *)(v28 + 56) == v26)
    {
      int v29 = *(_DWORD *)(v28 + 432);
      if (v29 == v26 || v29 == 0)
      {
        uint64_t v31 = *(void *)(v28 + 64);
        uint64_t v32 = *(void *)(v28 + 72);
        while (v31 != v32)
        {
          *(void *)(v31 + 8) = 0;
          *(unsigned char *)(v31 + 161) = 0;
          v31 += 168;
        }
        *(_DWORD *)(v28 + 432) = 0;
      }
      uint64_t v33 = *(void *)(v28 + 48);
      if (v33)
      {
        double v34 = *(double *)(v28 + 504);
        if (v34 >= *(double *)(v28 + 512)) {
          double v34 = *(double *)(v28 + 512);
        }
        if (v34 <= 0.0)
        {
          (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
          *(void *)(v28 + 48) = 0;
        }
      }
      *(_DWORD *)(v28 + 56) = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v28 + 40));
    os_unfair_lock_unlock((os_unfair_lock_t)(v27 + 36));
    int v36 = (atomic_uint *)j[1];
    if (atomic_fetch_add(v36 + 4, 0xFFFFFFFF) == 1) {
      CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v36, v35);
    }
    CA::Shape::unref((CA::Shape *)j[5]);
    size_t v37 = j[11];
    if (v37)
    {
      do
      {
        int v38 = (uint64_t *)v37[1];
        (*(void (**)(uint64_t *))*v37)(v37);
        size_t v37 = v38;
      }
      while (v38);
    }
  }
  for (k = (void *)*((void *)this + 68); k; k = (void *)*k)
  {
    uint64_t v40 = (CA::Shape *)k[2];
    if (v40) {
      CA::Shape::unref(v40);
    }
  }
  uint64_t v41 = (uint64_t *)*((void *)this + 69);
  for (m = (uint64_t *)*((void *)this + 70); v41 != m; ++v41)
  {
    uint64_t v43 = *v41;
    if (atomic_fetch_add((atomic_uint *volatile)(*v41 + 8), 0xFFFFFFFF) == 1) {
      (*(void (**)(uint64_t))(*(void *)v43 + 16))(v43);
    }
  }
  if ((*((_DWORD *)this + 271) & 0x10000) == 0) {
    CA::Render::BackdropState::collect((CA::Render::BackdropState *)*((unsigned int *)this + 62));
  }
  long long v44 = (void *)*((void *)this + 67);
  if (v44)
  {
    unint64_t v45 = *((unsigned int *)this + 128);
    if (v45)
    {
      for (unint64_t n = 0; n < v45; ++n)
      {
        long long v47 = *(CA::Shape **)(*((void *)this + 67) + 8 * n);
        if (v47)
        {
          CA::Shape::unref(v47);
          unint64_t v45 = *((unsigned int *)this + 128);
        }
      }
      long long v44 = (void *)*((void *)this + 67);
    }
    free(v44);
  }
  long long v48 = (CA::Shape *)*((void *)this + 65);
  if (v48) {
    CA::Shape::unref(v48);
  }
  long long v49 = (CA::Shape *)*((void *)this + 66);
  if (v49) {
    CA::Shape::unref(v49);
  }
  for (iuint64_t i = (void *)*((void *)this + 131); ii; iuint64_t i = (void *)*ii)
  {
    long long v51 = (atomic_uint *)ii[1];
    if (atomic_fetch_add(v51 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v51 + 16))(v51);
    }
  }
  uint64_t v52 = *((void *)this + 103);
  if (v52)
  {
    long long v53 = *(void **)v52;
    if (*(void *)v52 == v52 + 8) {
      goto LABEL_93;
    }
    do
    {
      uint64_t v54 = v53[4];
      if (*(unsigned char *)(v54 + 12) != 25) {
        __assert_rtn("~Update", "render-updater.cpp", 10399, "obj->type () == Render::kTypeImageQueue");
      }
      if (atomic_fetch_add((atomic_uint *volatile)(v54 + 8), 0xFFFFFFFF) == 1) {
        (*(void (**)(uint64_t))(*(void *)v54 + 16))(v54);
      }
      long long v55 = (void *)v53[1];
      if (v55)
      {
        do
        {
          long long v56 = v55;
          long long v55 = (void *)*v55;
        }
        while (v55);
      }
      else
      {
        do
        {
          long long v56 = (void *)v53[2];
          BOOL v17 = *v56 == (void)v53;
          long long v53 = v56;
        }
        while (!v17);
      }
      long long v53 = v56;
    }
    while (v56 != (void *)(v52 + 8));
    uint64_t v52 = *((void *)this + 103);
    if (v52)
    {
LABEL_93:
      std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(*(void **)(v52 + 8));
      MEMORY[0x185323DC0](v52, 0x1020C4062D53EE8);
    }
  }
  if (*((void *)this + 109))
  {
    uint64_t v57 = (CA::Render::Update *)*((void *)this + 107);
    if (v57 != (CA::Render::Update *)((char *)this + 864))
    {
      do
      {
        uint64_t v58 = *((void *)v57 + 4);
        if (*(unsigned char *)(v58 + 12) != 25) {
          __assert_rtn("~Update", "render-updater.cpp", 10421, "obj->type () == Render::kTypeImageQueue");
        }
        CA::Render::ImageQueue::did_display(*((CA::Render::ImageQueue **)v57 + 4), *((_DWORD *)this + 62), 0.0, 0.0, 0.0);
        if (atomic_fetch_add((atomic_uint *volatile)(v58 + 8), 0xFFFFFFFF) == 1) {
          (*(void (**)(uint64_t))(*(void *)v58 + 16))(v58);
        }
        CGRect v59 = (CA::Render::Update *)*((void *)v57 + 1);
        if (v59)
        {
          do
          {
            CGRect v60 = v59;
            CGRect v59 = *(CA::Render::Update **)v59;
          }
          while (v59);
        }
        else
        {
          do
          {
            CGRect v60 = (CA::Render::Update *)*((void *)v57 + 2);
            BOOL v17 = *(void *)v60 == (void)v57;
            uint64_t v57 = v60;
          }
          while (!v17);
        }
        uint64_t v57 = v60;
      }
      while (v60 != (CA::Render::Update *)((char *)this + 864));
    }
  }
  std::__tree<CA::Render::Update::ContextInfo>::destroy(*((void **)this + 105));
  *((void *)this + 104) = (char *)this + 840;
  *((void *)this + 106) = 0;
  *((void *)this + 105) = 0;
  for (juint64_t j = (void *)*((void *)this + 127); jj; juint64_t j = (void *)*jj)
  {
    double v62 = (const void *)jj[1];
    if (v62) {
      CFRelease(v62);
    }
  }
  *((void *)this + 116) = *((void *)this + 115);

  x_heap_free(*(void ****)this);
  double v63 = (void *)*((void *)this + 128);
  if (v63)
  {
    *((void *)this + 129) = v63;
    operator delete(v63);
  }
  uint64_t v64 = (void *)*((void *)this + 115);
  if (v64 != *((void **)this + 117)) {
    free(v64);
  }
  double v65 = (const void *)*((void *)this + 114);
  if (v65) {
    CFRelease(v65);
  }
  __int16 v66 = (const void *)*((void *)this + 113);
  if (v66) {
    CFRelease(v66);
  }
  uint64_t v67 = (const void *)*((void *)this + 112);
  if (v67) {
    CFRelease(v67);
  }
  std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(*((void **)this + 108));
  std::__tree<CA::Render::Update::ContextInfo>::destroy(*((void **)this + 105));
  uint64_t v68 = *((void *)this + 100);
  if (v68)
  {
    uint64_t v69 = *((void *)this + 101);
    uint64_t v70 = (void *)*((void *)this + 100);
    if (v69 != v68)
    {
      do
        uint64_t v69 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v69 - 40);
      while (v69 != v68);
      uint64_t v70 = (void *)*((void *)this + 100);
    }
    *((void *)this + 101) = v68;
    operator delete(v70);
  }
  long long v71 = (void *)*((void *)this + 69);
  if (v71 != *((void **)this + 71)) {
    free(v71);
  }
}

void std::__tree<CA::Render::Update::ContextInfo>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<CA::Render::Update::ContextInfo>::destroy(*a1);
    std::__tree<CA::Render::Update::ContextInfo>::destroy(a1[1]);
    uint64_t v2 = (atomic_uint *)a1[4];
    if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
    }
    operator delete(a1);
  }
}

uint64_t CA::Render::Context::increment_commit_seed(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 13;
  os_unfair_lock_lock(this + 13);
  ++this[16]._os_unfair_lock_opaque;
  CA::Render::Context::check_sync_reqs((CA::Render::Context *)this, 0.0);
  uint64_t os_unfair_lock_opaque = this[16]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v2);
  return os_unfair_lock_opaque;
}

void CA::Render::Context::check_sync_reqs(CA::Render::Context *this, double a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  mach_port_t v3 = (double *)((char *)this + 56);
  uint64_t v2 = (double *)*((void *)this + 7);
  if (v2)
  {
    do
    {
      unsigned int v6 = *((_DWORD *)v2 + 9);
      unsigned int v7 = *((_DWORD *)this + 16);
      BOOL v8 = v7 >= v6;
      if (*((unsigned char *)v2 + 40)) {
        BOOL v9 = v7 >= v6;
      }
      else {
        BOOL v9 = 0;
      }
      if (v9) {
        BOOL v8 = *((_DWORD *)this + 17) >= v6 || *((_DWORD *)this + 88) == 0;
      }
      if (v2[2] <= a2)
      {
        if (CA::Render::sync_hang_report_level(void)::onceToken[0] != -1) {
          dispatch_once(CA::Render::sync_hang_report_level(void)::onceToken, &__block_literal_global_4151);
        }
        if (CA::Render::sync_hang_report_level(void)::level == 2)
        {
          if (x_log_hook_p()) {
            goto LABEL_18;
          }
          uint64_t v19 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_FAULT))
          {
            int v20 = *((_DWORD *)this + 4);
            int v21 = *((_DWORD *)this + 16);
            int v22 = *((_DWORD *)this + 17);
            if (*((unsigned char *)v2 + 40)) {
              int v23 = 114;
            }
            else {
              int v23 = 99;
            }
            int v25 = *((_DWORD *)v2 + 8);
            int v24 = *((_DWORD *)v2 + 9);
            *(_DWORD *)buf = 67110400;
            int v36 = v20;
            __int16 v37 = 1024;
            int v38 = v21;
            __int16 v39 = 1024;
            int v40 = v22;
            __int16 v41 = 1024;
            int v42 = v23;
            __int16 v43 = 1024;
            int v44 = v24;
            __int16 v45 = 1024;
            int v46 = v25;
            BOOL v17 = v19;
            os_log_type_t v18 = OS_LOG_TYPE_FAULT;
            goto LABEL_29;
          }
        }
        else
        {
          if (CA::Render::sync_hang_report_level(void)::level == 3)
          {
            uint64_t v34 = 114;
            if (!*((unsigned char *)v2 + 40)) {
              uint64_t v34 = 99;
            }
            x_log_crash("long synchronize for %x: now (%u,%u): req %c%u(%u)", *((_DWORD *)this + 4), *((_DWORD *)this + 16), *((_DWORD *)this + 17), v34, *((_DWORD *)v2 + 9), *((_DWORD *)v2 + 8));
            abort();
          }
          if (x_log_hook_p())
          {
LABEL_18:
            x_log_();
            goto LABEL_30;
          }
          uint64_t v10 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
          {
            int v11 = *((_DWORD *)this + 4);
            int v12 = *((_DWORD *)this + 16);
            int v13 = *((_DWORD *)this + 17);
            if (*((unsigned char *)v2 + 40)) {
              int v14 = 114;
            }
            else {
              int v14 = 99;
            }
            int v16 = *((_DWORD *)v2 + 8);
            int v15 = *((_DWORD *)v2 + 9);
            *(_DWORD *)buf = 67110400;
            int v36 = v11;
            __int16 v37 = 1024;
            int v38 = v12;
            __int16 v39 = 1024;
            int v40 = v13;
            __int16 v41 = 1024;
            int v42 = v14;
            __int16 v43 = 1024;
            int v44 = v15;
            __int16 v45 = 1024;
            int v46 = v16;
            BOOL v17 = v10;
            os_log_type_t v18 = OS_LOG_TYPE_ERROR;
LABEL_29:
            _os_log_impl(&dword_184668000, v17, v18, "long synchronize for %x: now (%u,%u): req %c%u(%u)", buf, 0x26u);
          }
        }
      }
LABEL_30:
      if (v2[3] <= a2)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          int v26 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
          {
            int v27 = *((_DWORD *)this + 4);
            int v28 = *((_DWORD *)this + 16);
            int v29 = *((_DWORD *)this + 17);
            if (*((unsigned char *)v2 + 40)) {
              int v30 = 114;
            }
            else {
              int v30 = 99;
            }
            int v32 = *((_DWORD *)v2 + 8);
            int v31 = *((_DWORD *)v2 + 9);
            *(_DWORD *)buf = 67110400;
            int v36 = v27;
            __int16 v37 = 1024;
            int v38 = v28;
            __int16 v39 = 1024;
            int v40 = v29;
            __int16 v41 = 1024;
            int v42 = v30;
            __int16 v43 = 1024;
            int v44 = v31;
            __int16 v45 = 1024;
            int v46 = v32;
            _os_log_impl(&dword_184668000, v26, OS_LOG_TYPE_ERROR, "synchronize timed out for %x with (%u,%u): req %c%u(%u)", buf, 0x26u);
          }
        }
LABEL_40:
        CA::Render::send_synchronize_reply((CA::Render *)*((unsigned int *)this + 4), *((_DWORD *)v2 + 2), *((_DWORD *)v2 + 8), *((_DWORD *)this + 16), *((_DWORD *)this + 17));
        double *v3 = *v2;
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, v2);
        goto LABEL_41;
      }
      if (v8) {
        goto LABEL_40;
      }
      mach_port_t v3 = v2;
LABEL_41:
      uint64_t v2 = *(double **)v3;
    }
    while (*(void *)v3);
  }
}

void std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(*a1);
    std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(a1[1]);
    operator delete(a1);
  }
}

void CA::Render::Updater::FilterOp::~FilterOp(CA::Render::Updater::FilterOp *this)
{
  *(void *)this = &unk_1ED02FE40;
  if (*((unsigned char *)this + 16))
  {
    uint64_t v2 = (atomic_uint *)*((void *)this + 4);
    if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
    }
    mach_port_t v3 = (atomic_uint *)*((void *)this + 5);
    if (v3)
    {
      if (atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
      }
    }
  }
}

{
  uint64_t vars8;

  CA::Render::Updater::FilterOp::~FilterOp(this);

  JUMPOUT(0x185323DC0);
}

void CA::Render::BackdropState::collect(CA::Render::BackdropState *this)
{
  int v1 = (int)this;
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::BackdropState::_list_lock);
  uint64_t v2 = (char *)CA::Render::BackdropState::_list;
  uint64_t v3 = qword_1E8F83DD0;
  if (CA::Render::BackdropState::_list == (_UNKNOWN *)qword_1E8F83DD0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::BackdropState::_list_lock);
  }
  else
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)v2;
      if (*(_DWORD *)(*(void *)v2 + 8))
      {
        unsigned int v6 = (os_unfair_lock_s *)(v5 + 36);
        os_unfair_lock_lock((os_unfair_lock_t)(v5 + 36));
        if (!*(unsigned char *)(v5 + 97))
        {
          uint64_t v10 = *(void *)(v5 + 40);
          if (v10)
          {
            if (!*(_DWORD *)(v10 + 56)) {
              *(_DWORD *)(v10 + 552) = v1;
            }
          }
        }
        uint64_t v9 = *(void *)(v5 + 88);
        BOOL v8 = (uint64_t *)(v5 + 88);
        uint64_t v7 = v9;
        if (v9)
        {
          do
          {
            if (*(_DWORD *)(v7 + 24) == v1)
            {
              BOOL v8 = (uint64_t *)v7;
            }
            else
            {
              *BOOL v8 = *(void *)v7;
              *(void *)uint64_t v7 = v4;
              uint64_t v4 = (void *)v7;
            }
            uint64_t v7 = *v8;
          }
          while (*v8);
        }
        os_unfair_lock_unlock(v6);
      }
      v2 += 8;
    }
    while (v2 != (char *)v3);
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::BackdropState::_list_lock);
    if (v4)
    {
      do
      {
        int v11 = (void *)*v4;
        int v12 = (atomic_uint *)v4[4];
        if (atomic_fetch_add(v12 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v12 + 16))(v12);
        }
        free(v4);
        uint64_t v4 = v11;
      }
      while (v11);
    }
  }
  os_unfair_lock_lock(&CA::Render::BackdropGroup::_list_lock);
  int v13 = (char *)CA::Render::BackdropGroup::_list;
  uint64_t v14 = qword_1E8F83D90;
  if (CA::Render::BackdropGroup::_list == (_UNKNOWN *)qword_1E8F83D90)
  {
    os_unfair_lock_unlock(&CA::Render::BackdropGroup::_list_lock);
  }
  else
  {
    int v15 = 0;
    int v16 = &CA::callback_timer;
    do
    {
      uint64_t v17 = *(void *)v13;
      if (*(_DWORD *)(*(void *)v13 + 8) && *(_DWORD *)(v17 + 552) != v1 && !*(_DWORD *)(v17 + 56))
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v17 + 40));
        if (*(void *)(v17 + 48) && *(_DWORD *)(v17 + 552) != v1 && !*(_DWORD *)(v17 + 56))
        {
          if (*((unsigned char *)v16 + 3050))
          {
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              int v22 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v23 = *(void *)(v17 + 48);
                *(_DWORD *)buf = 134218240;
                uint64_t v27 = v17;
                __int16 v28 = 2048;
                uint64_t v29 = v23;
                _os_log_impl(&dword_184668000, v22, OS_LOG_TYPE_DEFAULT, "collected backdrop group %p buffer %p\n", buf, 0x16u);
              }
            }
          }
          os_log_type_t v18 = v16;
          uint64_t v19 = *(void *)(v17 + 48);
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          int v21 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
          *int v21 = v19;
          v21[1] = v15;
          int v16 = v18;
          *(void *)(v17 + 48) = 0;
          X::small_vector_base<CA::Render::BackdropGroup::Item>::resize((char **)(v17 + 64), 0);
          int v15 = v21;
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 40));
      }
      v13 += 8;
    }
    while (v13 != (char *)v14);
    os_unfair_lock_unlock(&CA::Render::BackdropGroup::_list_lock);
    if (v15)
    {
      int v24 = v15;
      do
      {
        if (*v24) {
          (*(void (**)(void))(*(void *)*v24 + 8))(*v24);
        }
        int v24 = (void *)v24[1];
      }
      while (v24);
      do
      {
        int v25 = (void *)v15[1];
        free(v15);
        int v15 = v25;
      }
      while (v25);
    }
  }
}

uint64_t backing_callback(CGContext *a1, CA::Layer *this)
{
  uint64_t v4 = (CA::Transaction *)CA::Layer::prepare_context_for_drawing(this, a1, 1);
  uint64_t v5 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (!v5) {
    uint64_t v5 = (CA::Transaction *)CA::Transaction::create(v4);
  }
  id v6 = CA::Layer::layer_being_drawn(this, v5, 0x800000);

  return [v6 drawInContext:a1];
}

void CA::Layer::layout_and_display_if_needed(CA::Layer *this, CA::Transaction *a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](this);
  uint64_t v4 = v3;
  uint64_t v5 = (id *)v2;
  int v6 = 0;
  v25[508] = *MEMORY[0x1E4F143B8];
  while (1)
  {
    CA::Layer::layout_if_needed((CA::Layer *)v5, (CA::Transaction *)v4);
    uint64_t v7 = v4[24];
    if ((v7 & 0x80000000) != 0 || (BOOL v8 = (char *)v5 + 4 * v7, (v9 = *((_DWORD *)v8 + 68)) == 0))
    {
      uint64_t v10 = CA::Layer::thread_flags_((CA::Layer *)v5, (CA::Transaction *)v4);
      int v9 = *v10;
    }
    else
    {
      uint64_t v10 = v8 + 272;
    }
    if ((v9 & 0x300) == 0) {
      break;
    }
    kdebug_trace();
    uint64_t v11 = 0;
    char v12 = 0;
    while ((*((unsigned char *)v10 + 1) & 3) != 0)
    {
      *(void *)&buf[0] = 0;
      *((void *)&buf[0] + 1) = v25;
      buf[1] = xmmword_1849983E0;
      unsigned int v13 = v4[25];
      v4[25] = v13 + 1;
      if (!v13) {
        os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
      }
      uint64_t v19 = 0;
      uint64_t v23 = 0;
      long long v18 = 0u;
      int v20 = v4;
      int v21 = buf;
      uint64_t v22 = 0x20000000100;
      CA::Layer::collect_layers_((CA::Layer *)v5, (uint64_t *)&v18);
      uint64_t v14 = v19;
      int v15 = (void *)v18;
      CA::Transaction::unlock((CA::Transaction *)v4);
      if (v14)
      {
        for (v11 += v14; v15; int v15 = (void *)v15[1])
        {
          kdebug_trace();
          [*(id *)(*v15 + 16) display];
          kdebug_trace();
        }
        char v12 = 1;
      }
      x_heap_free((void ***)buf);
    }
    kdebug_trace();
    if ((v12 & 1) == 0) {
      break;
    }
    if (++v6 == 102)
    {
      if (x_log_hook_p())
      {
        objc_msgSend((id)objc_msgSend(v5[2], "debugDescription"), "UTF8String");
        x_log_();
      }
      else
      {
        int v16 = x_log_category_api;
        if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
        {
          uint64_t v17 = objc_msgSend((id)objc_msgSend(v5[2], "debugDescription"), "UTF8String");
          LODWORD(buf[0]) = 136315138;
          *(void *)((char *)buf + 4) = v17;
          _os_log_impl(&dword_184668000, v16, OS_LOG_TYPE_ERROR, "Layer (%s) took over 100 attempts to layout and display – this typically implies a client error. Breaking the loop!", (uint8_t *)buf, 0xCu);
        }
      }
      return;
    }
  }
}

void sub_1846F89F0(_Unwind_Exception *a1)
{
}

CA::Layer *CA::Layer::layout_if_needed(CA::Layer *this, CA::Transaction *a2)
{
  uint64_t result = (CA::Layer *)MEMORY[0x1F4188790](this);
  uint64_t v4 = v3;
  uint64_t v5 = result;
  v34[508] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = v3[24];
  if ((v6 & 0x80000000) != 0 || (v7 = (char *)result + 4 * v6, (int v8 = *((_DWORD *)v7 + 68)) == 0))
  {
    uint64_t result = (CA::Layer *)CA::Layer::thread_flags_(result, (CA::Transaction *)v3);
    int v9 = result;
    int v8 = *(_DWORD *)result;
  }
  else
  {
    int v9 = (CA::Layer *)(v7 + 272);
  }
  if ((v8 & 0x60) != 0)
  {
    kdebug_trace();
    unsigned int v10 = v4[25];
    v4[25] = v10 + 1;
    if (!v10) {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    }
    if ((*(unsigned char *)v9 & 0x60) != 0)
    {
      int v11 = 0;
      do
      {
        v32[0] = 0;
        v32[1] = (void **)v34;
        long long v33 = xmmword_1849983E0;
        int v12 = dyld_program_sdk_at_least();
        unsigned __int8 v13 = v12;
        long long v29 = 0u;
        long long v30 = 0u;
        if (v12) {
          unsigned int v14 = 0;
        }
        else {
          unsigned int v14 = 128;
        }
        long long v28 = 0uLL;
        *((void *)&v29 + 1) = v4;
        *(void *)&long long v30 = v32;
        *((void *)&v30 + 1) = 0x4000000020;
        uint64_t v31 = v14;
        CA::Layer::collect_layers_(v5, (uint64_t *)&v28);
        uint64_t v15 = *((void *)&v28 + 1);
        int v16 = (void *)v28;
        *(void *)&long long v30 = v13 ^ 1u;
        uint64_t v17 = *((void *)v4 + 9);
        *(void *)&long long v28 = v4;
        *((void *)&v28 + 1) = v17;
        long long v29 = (unint64_t)v16;
        *((void *)v4 + 9) = &v28;
        CA::Transaction::unlock((CA::Transaction *)v4);
        for (; v16; ++v11)
        {
          *((void *)&v29 + 1) = *v16;
          long long v18 = (CA::Layer *)*((void *)&v29 + 1);
          kdebug_trace();
          id v19 = CA::Layer::layer_being_drawn(v18, (CA::Transaction *)v4, 0x1000000);
          int v20 = v19;
          if (BYTE3(xmmword_1EB2ACC30) | BYTE4(xmmword_1EB2ACC30))
          {
            double Current = CFAbsoluteTimeGetCurrent();
            [v20 layoutSublayers];
            [v20 _validateLayoutHashHasChangedWithLayoutTime:CFAbsoluteTimeGetCurrent() - Current];
          }
          else
          {
            [v19 layoutSublayers];
          }
          kdebug_trace();
          int v16 = (void *)v16[1];
        }
        while (v15)
        {
          uint64_t v22 = *(CA::Layer **)v15;
          uint64_t v23 = v4[24];
          if ((v23 & 0x80000000) != 0 || (int v24 = (char *)v22 + 4 * v23, (v25 = *((_DWORD *)v24 + 68)) == 0))
          {
            int v26 = CA::Layer::thread_flags_(v22, (CA::Transaction *)v4);
            int v25 = *v26;
          }
          else
          {
            int v26 = (int *)(v24 + 272);
          }
          *int v26 = v25 & 0xFFFFFF7F;
          uint64_t v15 = *(void *)(v15 + 8);
        }
        x_heap_free(v32);
        unsigned int v27 = v4[25];
        v4[25] = v27 + 1;
        if (!v27) {
          os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
        }
        *(void *)(v28 + 72) = *((void *)&v28 + 1);
      }
      while ((*(unsigned char *)v9 & 0x60) != 0);
    }
    CA::Transaction::unlock((CA::Transaction *)v4);
    return (CA::Layer *)kdebug_trace();
  }
  return result;
}

void sub_1846F8D68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  kdebug_trace();
  int v14 = *((_DWORD *)v12 + 25);
  *((_DWORD *)v12 + 25) = v14 + 1;
  if (!v14) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  *(void *)(a11 + 72) = a12;
  CA::Transaction::unlock(v12);
  kdebug_trace();
  _Unwind_Resume(a1);
}

id CA::Layer::layer_being_drawn(CA::Layer *this, CA::Transaction *a2, int a3)
{
  id v3 = (id)*((void *)this + 2);
  if ((*((_DWORD *)this + 1) & a3) != 0 && (*((_DWORD *)this + 1) & 0x60000) != 0x40000 && *((void *)this + 35))
  {
    int v6 = *((_DWORD *)a2 + 25);
    *((_DWORD *)a2 + 25) = v6 + 1;
    if (!v6) {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    }
    uint64_t v7 = (double *)*((void *)a2 + 13);
    double v8 = v7[29];
    double v9 = v8;
    if (v8 == 0.0)
    {
      CA::Transaction::Shared::time((CA::Transaction::Shared *)v7);
      double v9 = v10 + 0.025;
    }
    id v3 = CA::Layer::layer_at_time(this, a2, v9, v8 == 0.0, 1);
    CA::Transaction::unlock(a2);
  }
  return v3;
}

void sub_1846F8EBC(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Layer::prepare_commit(CA::Layer *this, CA::Transaction *a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](this);
  uint64_t v4 = v3;
  uint64_t v5 = (CA::Layer *)v2;
  v22[508] = *MEMORY[0x1E4F143B8];
  v20[0] = 0;
  v20[1] = (void **)v22;
  long long v21 = xmmword_1849983E0;
  int v6 = *((_DWORD *)v3 + 25);
  *((_DWORD *)v3 + 25) = v6 + 1;
  if (!v6) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  uint64_t v15 = 0;
  uint64_t v19 = 0;
  long long v14 = 0u;
  int v16 = v4;
  uint64_t v17 = v20;
  uint64_t v18 = 0x400000002;
  CA::Layer::collect_layers_(v5, (uint64_t *)&v14);
  uint64_t v7 = v15;
  double v8 = (void *)v14;
  CA::Transaction::unlock(v4);
  if (v7)
  {
    kdebug_trace();
    for (; v8; double v8 = (void *)v8[1])
    {
      uint64_t v10 = *v8;
      int v11 = *(CA::Layer **)(*v8 + 16);
      if (v11) {
        CA::Layer::prepare_contents(v11, (CALayer *)v4, v9);
      }
      int v12 = *(uint64_t ***)(v10 + 280);
      if (v12)
      {
        int v13 = *((_DWORD *)v4 + 25);
        *((_DWORD *)v4 + 25) = v13 + 1;
        if (v13
          || (os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock),
              (int v12 = *(uint64_t ***)(v10 + 280)) != 0))
        {
          do
          {
            if (((_WORD)v12[7] & 0x66) == 0) {
              objc_msgSend(v12[1], "CA_prepareRenderValue");
            }
            int v12 = (uint64_t **)*v12;
          }
          while (v12);
        }
        CA::Transaction::unlock(v4);
      }
    }
    kdebug_trace();
  }
  x_heap_free(v20);
}

void sub_1846F91F0(_Unwind_Exception *exception_object)
{
}

CA::Layer *CA::Layer::collect_layers_(CA::Layer *result, uint64_t *a2)
{
  id v3 = result;
  uint64_t v4 = (unsigned int *)a2[3];
  uint64_t v5 = v4[24];
  if ((v5 & 0x80000000) != 0 || (int v6 = (char *)result + 4 * v5, (v7 = *((_DWORD *)v6 + 68)) == 0))
  {
    uint64_t result = (CA::Layer *)CA::Layer::thread_flags_(result, (CA::Transaction *)v4);
    double v8 = result;
    int v7 = *(_DWORD *)result;
  }
  else
  {
    double v8 = (CA::Layer *)(v6 + 272);
  }
  _ZF = ((*((_DWORD *)a2 + 11) | *((_DWORD *)a2 + 10)) & v7) == 0;
  atomic_fetch_and((atomic_uint *volatile)v3 + 1, ~((*((_DWORD *)a2 + 11) | *((_DWORD *)a2 + 10)) & v7));
  if (!_ZF)
  {
    int v10 = *((_DWORD *)a2 + 12);
    if (v10)
    {
      *(_DWORD *)v8 |= v10;
      uint64_t result = (CA::Layer *)a2[4];
      unint64_t v11 = *((void *)result + 2);
      unint64_t v12 = v11 - 16;
      if (v11 >= 0x10)
      {
        int v13 = (void *)*((void *)result + 1);
        *((void *)result + 1) = v13 + 2;
        *((void *)result + 2) = v12;
      }
      else
      {
        uint64_t result = (CA::Layer *)x_heap_malloc_small_((uint64_t *)result, 0x10uLL);
        int v13 = result;
      }
      uint64_t v14 = a2[1];
      *int v13 = v3;
      v13[1] = v14;
      a2[1] = (uint64_t)v13;
    }
    int v15 = *((_DWORD *)a2 + 11);
    if ((v15 & v7) == 0) {
      goto LABEL_21;
    }
    *(_DWORD *)v8 &= ~v15;
    int v16 = (void *)*((void *)v3 + 3);
    if (!v16)
    {
LABEL_19:
      uint64_t v25 = *((void *)v3 + 4);
      if (v25)
      {
        _X0 = *(void *)(v25 + 16);
        __asm { PRFM            #0, [X0,#0x110] }
        uint64_t result = (CA::Layer *)CA::Layer::collect_layers_();
      }
LABEL_21:
      int v28 = *((_DWORD *)a2 + 10);
      if ((v28 & v7) != 0)
      {
        *(_DWORD *)v8 &= ~v28;
        uint64_t result = (CA::Layer *)a2[4];
        unint64_t v29 = *((void *)result + 2);
        unint64_t v30 = v29 - 16;
        if (v29 >= 0x10)
        {
          uint64_t v31 = (void *)*((void *)result + 1);
          *((void *)result + 1) = v31 + 2;
          *((void *)result + 2) = v30;
        }
        else
        {
          uint64_t result = (CA::Layer *)x_heap_malloc_small_((uint64_t *)result, 0x10uLL);
          uint64_t v31 = result;
        }
        uint64_t v32 = *a2;
        *uint64_t v31 = v3;
        v31[1] = v32;
        *a2 = (uint64_t)v31;
        ++a2[2];
      }
      return result;
    }
    uint64_t v17 = v16 + 1;
    uint64_t v18 = v16[2];
    if (v18 == 1)
    {
      if (!v16[3])
      {
        do
        {
LABEL_18:
          uint64_t v19 = *v17++;
          _X0 = *(void *)(v19 + 16);
          __asm { PRFM            #0, [X0,#0x110] }
          uint64_t result = (CA::Layer *)CA::Layer::collect_layers_();
          --v18;
        }
        while (v18);
        goto LABEL_19;
      }
    }
    else if (!v18)
    {
      goto LABEL_19;
    }
    uint64_t v17 = (uint64_t *)*v17;
    goto LABEL_18;
  }
  return result;
}

void x_heap_free(void ***a1)
{
  if (a1)
  {
    int v1 = *a1;
    if (*a1)
    {
      uint64_t v2 = *a1;
      do
      {
        free(*v2);
        uint64_t v2 = (void **)v2[1];
      }
      while (v2);
      do
      {
        id v3 = (void **)v1[1];
        free(v1);
        int v1 = v3;
      }
      while (v3);
    }
  }
}

uint64_t CA::Layer::prepare_contents(CA::Layer *this, CALayer *a2, CA::Transaction *a3)
{
  kdebug_trace();
  int isa_high = HIDWORD(a2[3].super.isa);
  HIDWORD(a2[3].super.isa) = isa_high + 1;
  if (!isa_high) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  int v6 = (void *)[(CA::Layer *)this contents];
  int v7 = v6;
  if (v6)
  {
    CFRetain(v6);
    CA::Transaction::unlock((CA::Transaction *)a2);
    CFTypeID v8 = CFGetTypeID(v7);
    if (v8 == CGImageGetTypeID())
    {
      double v9 = (CGColorSpace *)[(CA::Layer *)this _renderImageCopyFlags];
      uint64_t v11 = *(void *)&a2[1]._attr.refcount;
      if (v11) {
        unint64_t v12 = *(CGImage **)(v11 + 112);
      }
      else {
        unint64_t v12 = (CGImage *)CAGetColorSpace(0x1Du);
      }
      CA::Render::prepare_image((CA::Render *)v7, v12, v9, v10);
    }
    else
    {
      objc_msgSend(v7, "CA_prepareRenderValue");
    }
    CFRelease(v7);
  }
  else
  {
    CA::Transaction::unlock((CA::Transaction *)a2);
  }

  return kdebug_trace();
}

void sub_1846F96D0(_Unwind_Exception *a1)
{
}

void sub_1846FA2D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  CACGContextEvaluator::~CACGContextEvaluator((CGColorSpaceRef *)va);
  _Unwind_Resume(a1);
}

void sub_1846FA4EC(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::Layer::prepare_context_for_drawing(CA::Layer *this, CGContext *a2, int a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  int v6 = (void *)*((void *)this + 2);
  memset(&v17, 0, sizeof(v17));
  CGContextGetBaseCTM();
  if (*((unsigned char *)this + 56))
  {
    [v6 contentsScale];
    CGFloat v8 = v7;
    CGContextScaleCTM(a2, v7, v7);
    CGAffineTransform v15 = v17;
    CGAffineTransformScale(&v16, &v15, v8, v8);
    CGAffineTransform v17 = v16;
  }
  if (a3)
  {
    if ((*((_DWORD *)this + 1) & 0x400000) == 0)
    {
      CGFloat v9 = *((double *)this + 15);
      transform.b = 0.0;
      transform.c = 0.0;
      transform.a = 1.0;
      *(_OWORD *)&transform.d = xmmword_184997E00;
      transform.ty = v9;
      CGContextConcatCTM(a2, &transform);
      if (dyld_program_sdk_at_least())
      {
        t1.b = 0.0;
        t1.c = 0.0;
        t1.a = 1.0;
        *(_OWORD *)&t1.d = xmmword_184997E00;
        t1.ty = v9;
        CGAffineTransform t2 = v17;
        CGAffineTransformConcat(&v16, &t1, &t2);
        CGAffineTransform v17 = v16;
      }
    }
  }
  if ((*((unsigned char *)this + 55) & 4) != 0)
  {
    CGContextTranslateCTM(a2, -*((double *)this + 12), -*((double *)this + 13));
    if (dyld_program_sdk_at_least())
    {
      CGAffineTransform v11 = v17;
      CGAffineTransformTranslate(&v16, &v11, -*((double *)this + 12), -*((double *)this + 13));
      CGAffineTransform v17 = v16;
    }
  }
  CGContextSetBaseCTM();
  return [v6 _prepareContext:a2];
}

uint64_t CABackingStoreSetDefaultAccelFlags(uint64_t a1)
{
  if (accel_once[0] != -1) {
    dispatch_once_f(accel_once, 0, (dispatch_function_t)accel_init);
  }
  if (accel_defined == 1)
  {
    if (accel_enabled) {
      return a1 | 0x100;
    }
    else {
      return a1 & 0xFFFFFEFF;
    }
  }
  return a1;
}

uint64_t x_blame_allocations(uint64_t a1, uint64_t a2)
{
  v9[3] = *MEMORY[0x1E4F143B8];
  if (*MEMORY[0x1E4F1CBC0])
  {
    double v4 = MEMORY[0x1F4188790](a1);
    v9[0] = backing_blame_callback;
    v9[1] = v5;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    uint64_t v7 = *(void *)(StatusReg + 592);
    *(void *)(StatusReg + 592) = v9;
    uint64_t result = (*(uint64_t (**)(uint64_t, double))(v8 + 16))(v8, v4);
    *(void *)(StatusReg + 592) = v7;
  }
  else
  {
    uint64_t v2 = *(uint64_t (**)(uint64_t))(a2 + 16);
    return v2(a2);
  }
  return result;
}

uint64_t CABackingStoreSetColorSpace(uint64_t a1, CGColorSpace *a2)
{
  double v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v5 = *(CGColorSpace **)(a1 + 160);
  if (v5 == a2) {
    goto LABEL_4;
  }
  if (!v5)
  {
LABEL_6:
    CGColorSpaceRelease(v5);
    *(void *)(a1 + 160) = CGColorSpaceRetain(a2);
    *(_WORD *)(a1 + 492) |= 0x400u;
    uint64_t v6 = 1;
    goto LABEL_7;
  }
  if ((CGColorSpaceEqualToColorSpace() & 1) == 0)
  {
    uint64_t v5 = *(CGColorSpace **)(a1 + 160);
    goto LABEL_6;
  }
LABEL_4:
  uint64_t v6 = 0;
LABEL_7:
  pthread_mutex_unlock(v4);
  return v6;
}

void X::small_vector_base<CA::Render::BackdropGroup::Item>::resize(char **a1, unint64_t a2)
{
  uint64_t v5 = *a1;
  double v4 = a1[1];
  unint64_t v6 = 0xCF3CF3CF3CF3CF3DLL * ((v4 - *a1) >> 3);
  if (v6 <= a2)
  {
    if (v6 >= a2) {
      return;
    }
    unint64_t v8 = (unint64_t)a1[3];
    if (v8 >= a2)
    {
      CGAffineTransform v15 = *a1;
    }
    else
    {
      CGFloat v9 = a1[2];
      unint64_t v10 = (v8 + 1) | ((v8 + 1) >> 1) | (((v8 + 1) | ((v8 + 1) >> 1)) >> 2);
      unint64_t v11 = v10 | (v10 >> 4) | ((v10 | (v10 >> 4)) >> 8);
      unint64_t v12 = v11 | (v11 >> 16) | ((v11 | (v11 >> 16)) >> 32);
      if (v12 + 1 > a2) {
        unint64_t v13 = v12 + 1;
      }
      else {
        unint64_t v13 = a2;
      }
      uint64_t v14 = (char *)malloc_type_malloc(168 * v13, 0x102004011100410uLL);
      CGAffineTransform v15 = v14;
      CGAffineTransform v16 = *a1;
      CGAffineTransform v17 = a1[1];
      if (*a1 != v17)
      {
        uint64_t v18 = v14;
        do
        {
          _OWORD *v18 = *(_OWORD *)v16;
          v18[1] = *((_OWORD *)v16 + 1);
          v18[2] = *((_OWORD *)v16 + 2);
          v18[3] = *((_OWORD *)v16 + 3);
          v18[4] = *((_OWORD *)v16 + 4);
          v18[5] = *((_OWORD *)v16 + 5);
          v18[6] = *((_OWORD *)v16 + 6);
          long long v19 = *((_OWORD *)v16 + 7);
          long long v20 = *((_OWORD *)v16 + 8);
          long long v21 = *((_OWORD *)v16 + 9);
          *((void *)v18 + 20) = *((void *)v16 + 20);
          v18[8] = v20;
          v18[9] = v21;
          v18[7] = v19;
          v16 += 168;
          uint64_t v18 = (_OWORD *)((char *)v18 + 168);
        }
        while (v16 != v17);
      }
      if (v5 != v9) {
        free(*a1);
      }
      *a1 = v15;
      double v4 = &v15[168 * v6];
      a1[3] = (char *)v13;
    }
    for (uint64_t i = &v15[168 * a2]; v4 != i; v4 += 168)
    {
      *(void *)double v4 = 0;
      *((_WORD *)v4 + 80) = 0;
      *((_DWORD *)v4 + 41) = 0;
      *((_OWORD *)v4 + 7) = 0uLL;
      *((_OWORD *)v4 + 8) = 0uLL;
      *((_OWORD *)v4 + 1) = 0uLL;
      *((_OWORD *)v4 + 2) = 0uLL;
    }
  }
  else
  {
    uint64_t i = &v5[168 * a2];
  }
  a1[1] = i;
}

void CA::OGL::AsynchronousItem::unlatch(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 52;
  os_unfair_lock_lock(this + 52);
  uint64_t v3 = *(void *)&this[82]._os_unfair_lock_opaque;
  *(void *)&this[82]._uint64_t os_unfair_lock_opaque = 0;
  os_unfair_lock_unlock(v2);
  if (v3)
  {
    double v4 = *(NSObject **)(v3 + 32);
    dispatch_semaphore_signal(v4);
  }
}

uint64_t _CACImageQueueDidComposite(mach_port_t a1, mach_msg_timeout_t timeout, int a3, int a4, int a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *MEMORY[0x1E4F14068];
  int v10 = a3;
  int v11 = a4;
  int v12 = a5;
  *(void *)&msg.uint64_t msgh_bits = 19;
  msg.uint64_t msgh_voucher_port = 0;
  msg.mach_msg_id_t msgh_id = 40404;
  msg.mach_port_t msgh_remote_port = a1;
  msg.mach_port_t msgh_local_port = 0;
  if (MEMORY[0x1E4F14B18]) {
    voucher_mach_msg_set(&msg);
  }
  uint64_t v6 = mach_msg(&msg, 17, 0x2Cu, 0, 0, timeout, 0);
  if ((v6 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
    mach_msg_destroy(&msg);
  }
  return v6;
}

uint64_t default_contents_image_format(id *a1)
{
  uint64_t v2 = (unsigned __int8 *)CA::Layer::retain_context((CA::Layer *)a1);
  if (v2)
  {
    int v3 = v2[240];
    CA::Context::unref((CA::Context *)v2, 0);
    int v4 = [a1[2] isOpaque];
    switch(v3)
    {
      case 0:
        goto LABEL_8;
      case 1:
        if (v4) {
          unsigned int v5 = 17;
        }
        else {
          unsigned int v5 = 13;
        }
        LOBYTE(v3) = 1;
        break;
      case 2:
        if (v4) {
          unsigned int v5 = 33;
        }
        else {
          unsigned int v5 = 35;
        }
        LOBYTE(v3) = 2;
        break;
      case 3:
        unsigned int v5 = 9;
        break;
      case 4:
        if (v4) {
          unsigned int v5 = 10;
        }
        else {
          unsigned int v5 = 18;
        }
        LOBYTE(v3) = 4;
        break;
      case 5:
        unsigned int v5 = 36;
        break;
      default:
        unsigned int v5 = 1;
        break;
    }
  }
  else
  {
    int v4 = [a1[2] isOpaque];
LABEL_8:
    LOBYTE(v3) = 0;
    if (v4) {
      unsigned int v5 = 3;
    }
    else {
      unsigned int v5 = 1;
    }
  }
  LODWORD(result) = [a1[2] _overrideImageFormat];
  if ((*((unsigned char *)a1 + 58) & 0x40) == 0) {
    *((_DWORD *)a1 + 11) = *((_DWORD *)a1 + 11) & 0xFFFFFFF8 | v3 & 7;
  }
  if (result == -1) {
    return v5;
  }
  else {
    return result;
  }
}

void sub_1846FB090(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::CG::AccelRenderer::acquire(CA::CG::AccelRenderer *this, CA::CG::AccelDrawable *a2, CA::CG::AccelRenderer **a3, uint64_t a4, uint64_t a5, __CFString *a6, const __CFString *a7)
{
  int v72 = a4;
  char v73 = a5;
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  int v10 = (void *)MEMORY[0x185324A30](this, a2, a3, a4, a5, a6, a7);
  if ((CAMetalContextIsWhippetEnabled::initialized & 1) == 0)
  {
    CAMetalContextIsWhippetEnabled::whippet_enabled = 1;
    Boolean keyExistsAndHasValidFormat = 0;
    CFStringRef v11 = (const __CFString *)*MEMORY[0x1E4F1D3D8];
    uint64_t AppBooleanValue = CFPreferencesGetAppBooleanValue(@"CAEnableMetalWhippet", (CFStringRef)*MEMORY[0x1E4F1D3D8], &keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat) {
      CAMetalContextIsWhippetEnabled::whippet_enabled = AppBooleanValue != 0;
    }
    uint64_t v13 = (void *)MEMORY[0x185324A30](AppBooleanValue);
    uint64_t v14 = v13;
    if (CAMetalContextAllowDynamicBackend(void)::initialized == 1)
    {
      BOOL v15 = CAMetalContextAllowDynamicBackend(void)::allow_dynamic_backend == 0;
      if (!v15) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
    BOOL v20 = CFPreferencesGetAppBooleanValue(@"CADynamicBackendSwitching", v11, 0) != 0;
    CAMetalContextAllowDynamicBackend(void)::allow_dynamic_backend = v20;
    CAMetalContextAllowDynamicBackend(void)::initialized = 1;
    if (!v20) {
LABEL_6:
    }
      CAMetalContextIsWhippetEnabled::initialized = 1;
  }
LABEL_7:
  int v16 = CAMetalContextIsWhippetEnabled::whippet_enabled;
  uint64_t v17 = *(void *)a2;
  if (!*(void *)a2) {
    goto LABEL_17;
  }
  if (os_unfair_lock_trylock((os_unfair_lock_t)(v17 + 4224)))
  {
    if (*(CA::CG::AccelDrawable **)(v17 + 4240) != a2
      || *(CA::CG::AccelRenderer **)(v17 + 4264) != this
      || a3 && *(CA::CG::AccelRenderer ***)(v17 + 144) != a3)
    {
      goto LABEL_15;
    }
    int v18 = *(_DWORD *)(v17 + 4232);
    if (v16)
    {
      if (v18)
      {
LABEL_15:
        os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 4224));
        goto LABEL_16;
      }
    }
    else if (!v18)
    {
      goto LABEL_15;
    }
    *(unsigned char *)(v17 + 4228) = 1;
LABEL_105:
    *(_DWORD *)(*(void *)(v17 + 8) + 352) = v72;
    return v17;
  }
LABEL_16:
  *(void *)a2 = 0;
LABEL_17:
  long long v19 = (os_unfair_lock_s *)&CA::CG::AccelRenderer::_list_lock;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::CG::AccelRenderer::_list_lock);
  uint64_t v17 = CA::CG::AccelRenderer::_list;
  if (CA::CG::AccelRenderer::_list)
  {
    while (1)
    {
      if (!*(unsigned char *)(v17 + 4228))
      {
        long long v19 = (os_unfair_lock_s *)(v17 + 4224);
        os_unfair_lock_lock((os_unfair_lock_t)(v17 + 4224));
        if (*(CA::CG::AccelRenderer **)(v17 + 4264) == this)
        {
          long long v21 = *(void **)(v17 + 4240);
          if (v21)
          {
            *long long v21 = 0;
            *(void *)(v17 + 4240) = 0;
          }
          if (a3 && *(CA::CG::AccelRenderer ***)(v17 + 144) != a3) {
            goto LABEL_31;
          }
          int v22 = *(_DWORD *)(v17 + 4232);
          if (v16)
          {
            if (v22)
            {
LABEL_31:
              os_unfair_lock_unlock((os_unfair_lock_t)&CA::CG::AccelRenderer::_list_lock);
              CA::CG::AccelRenderer::detach_surface((CFTypeRef *)v17, 0);
              break;
            }
          }
          else if (!v22)
          {
            goto LABEL_31;
          }
          *(void *)(v17 + 4240) = a2;
          *(void *)a2 = v17;
          *(unsigned char *)(v17 + 4228) = 1;
          *(_DWORD *)(*(void *)(v17 + 8) + 352) = v72;
          os_unfair_lock_unlock((os_unfair_lock_t)&CA::CG::AccelRenderer::_list_lock);
          return v17;
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 4224));
      }
      uint64_t v17 = *(void *)(v17 + 4272);
      if (!v17)
      {
        long long v19 = (os_unfair_lock_s *)&CA::CG::AccelRenderer::_list_lock;
        break;
      }
    }
  }
  os_unfair_lock_unlock(v19);
  if (v73) {
    return 0;
  }
  uint64_t v23 = a2;
  int v24 = *((_DWORD *)this + 16) | 1;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::CG::AccelRenderer::_list_lock);
  uint64_t v17 = CA::CG::AccelRenderer::_list;
  if (!CA::CG::AccelRenderer::_list)
  {
LABEL_45:
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::CG::AccelRenderer::_list_lock);
    if (v16)
    {
      id v26 = CAMetalContextCreate();
      if (v26)
      {
        unsigned int v27 = v26;
        uint64_t v28 = CA::OGL::new_metal_context(v26, 0, 13, v24, 0, a6);
        if (v28)
        {
          int v29 = *((_DWORD *)this + 15);
          if (v29) {
            *(_DWORD *)(v28 + 440) = v29;
          }
          operator new();
        }
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          uint64_t v31 = x_log_category_cg;
          if (os_log_type_enabled((os_log_t)x_log_category_cg, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_184668000, v31, OS_LOG_TYPE_ERROR, "CoreAnimation: failed to create Metal context!\n", buf, 2u);
          }
        }
      }
    }
    if (((*(uint64_t (**)(CA::CG::AccelRenderer *))(*(void *)this + 40))(this) & 1) == 0)
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      long long v33 = (CA::OGL::Context *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x5010uLL, 0x743898A5uLL);
      uint64_t v34 = v33;
      if (v33)
      {
        bzero(v33, 0x5010uLL);
        CA::OGL::Context::Context(v34);
        *(void *)uint64_t v34 = &unk_1ED02C7F0;
      }
      operator new();
    }
    return 0;
  }
  while (*(unsigned char *)(v17 + 4228))
  {
LABEL_44:
    uint64_t v17 = *(void *)(v17 + 4272);
    if (!v17) {
      goto LABEL_45;
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v17 + 4224));
  if (a3 && *(CA::CG::AccelRenderer ***)(v17 + 144) != a3) {
    goto LABEL_43;
  }
  int v25 = *(_DWORD *)(v17 + 4232);
  if (v16 && !v25)
  {
    if (*(_DWORD *)(*(void *)(v17 + 8) + 432) == v24) {
      goto LABEL_53;
    }
    goto LABEL_43;
  }
  if (v25 != 1 || ((*(uint64_t (**)(CA::CG::AccelRenderer *))(*(void *)this + 40))(this) & 1) != 0)
  {
LABEL_43:
    os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 4224));
    goto LABEL_44;
  }
LABEL_53:
  unint64_t v30 = *(void **)(v17 + 4240);
  if (v30) {
    *unint64_t v30 = 0;
  }
  *(void *)(v17 + 4240) = v23;
  *(void *)uint64_t v23 = v17;
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::CG::AccelRenderer::_list_lock);
  if (*(CA::CG::AccelRenderer **)(v17 + 4264) == this) {
    goto LABEL_104;
  }
  uint64_t v35 = *(void *)(v17 + 8);
  if ((*(_WORD *)(v35 + 832) & 0x80) != 0)
  {
    uint64_t v36 = mach_absolute_time();
    double v37 = CATimeWithHostTime(v36);
    CARecordFrame(*(_DWORD *)(v35 + 708), *(_DWORD *)(v35 + 712), *(_DWORD *)(v35 + 716), 1, v37, 0.0, (double)*(unint64_t *)(v35 + 728));
    uint64_t v38 = *(void *)(v17 + 8);
    *(_DWORD *)(v38 + 708) = 0;
    x_hash_table_remove_all(*(void **)(v38 + 288));
    *(void *)(v38 + 296) = 0;
    *(_DWORD *)(v38 + 712) = *(void *)(v38 + 264) == *(void *)(v38 + 272);
    *(_OWORD *)(v38 + 716) = 0u;
    *(_DWORD *)(v38 + 732) = 0;
    *(_WORD *)(v38 + 832) &= 0xFC7Fu;
    *(_OWORD *)(v38 + 744) = 0u;
    *(_OWORD *)(v38 + 760) = 0u;
    *(_OWORD *)(v38 + 776) = 0u;
    *(_OWORD *)(v38 + 792) = 0u;
    *(_DWORD *)(v38 + 808) = 0;
  }
  int v39 = *(_DWORD *)(v17 + 4232);
  if (v39 == 1)
  {
    uint64_t v41 = (*(uint64_t (**)(CA::CG::AccelRenderer *))(*(void *)this + 24))(this);
    if (*(void *)(v17 + 4256) != v41)
    {
      int v42 = (void *)v41;
      CA::CG::AccelRenderer::unlock_surface((CA::CG::AccelRenderer *)v17);
      if (v42)
      {
        *(void *)(v17 + 4256) = v42;
        CFRetain(v42);
        IOSurfaceLock((IOSurfaceRef)v42, 0, 0);
        BaseAddress = IOSurfaceGetBaseAddress((IOSurfaceRef)v42);
        size_t BytesPerRow = IOSurfaceGetBytesPerRow((IOSurfaceRef)v42);
        size_t v45 = 0;
        int v46 = 0;
        uint64_t v47 = 0;
        uint64_t v48 = 0;
        unsigned int v49 = 0;
        unsigned int v50 = 0;
        size_t v51 = 0;
        uint64_t v52 = 0;
        unsigned int v53 = 0;
        int v54 = 8;
        size_t v55 = BytesPerRow;
        long long v56 = BaseAddress;
        switch(*((_DWORD *)this + 4))
        {
          case 1:
            int v54 = 32;
            size_t v45 = BytesPerRow;
            int v46 = BaseAddress;
            goto LABEL_84;
          case 3:
            size_t v45 = 0;
            int v46 = 0;
            int v54 = 32;
            goto LABEL_84;
          case 5:
            size_t v45 = 0;
            int v46 = 0;
            int v54 = 15;
            goto LABEL_84;
          case 9:
            break;
          case 0xA:
LABEL_84:
            if (BaseAddress)
            {
              uint64_t v47 = *((unsigned int *)this + 9);
              uint64_t v48 = *((unsigned int *)this + 10);
              size_t v55 = v45;
              size_t v51 = BytesPerRow;
              long long v56 = v46;
              uint64_t v52 = BaseAddress;
              unsigned int v53 = v54;
              unsigned int v49 = *((_DWORD *)this + 13);
              unsigned int v50 = *((_DWORD *)this + 14);
            }
            else
            {
              uint64_t v47 = 0;
              uint64_t v48 = 0;
              unsigned int v49 = 0;
              unsigned int v50 = 0;
              uint64_t v52 = 0;
              size_t v55 = v45;
              size_t v51 = BytesPerRow;
              long long v56 = v46;
              unsigned int v53 = v54;
            }
            break;
          default:
            goto LABEL_81;
        }
      }
      else
      {
LABEL_81:
        uint64_t v47 = 0;
        uint64_t v48 = 0;
        unsigned int v49 = 0;
        unsigned int v50 = 0;
        size_t v55 = 0;
        size_t v51 = 0;
        long long v56 = 0;
        uint64_t v52 = 0;
        unsigned int v53 = 0;
      }
      (*(void (**)(void, void *, size_t, void, void *, size_t, uint64_t, uint64_t, unint64_t))(**(void **)(v17 + 8) + 1064))(*(void *)(v17 + 8), v52, v51, v53, v56, v55, v47, v48, __PAIR64__(v50, v49));
    }
LABEL_88:
    long long v57 = *(_OWORD *)((char *)this + 36);
    *((void *)&v57 + 1) = *(void *)((char *)this + 52);
    long long v74 = v57;
    CA::CG::Renderer::end_rendering((CA::CG::Renderer *)v17);
    *(_OWORD *)(v17 + 16) = v74;
    uint64_t v58 = *(void *)(v17 + 8);
    if (v58)
    {
      *(_OWORD *)(v58 + 200) = v74;
      CGRect v59 = (CGColorSpace *)*((void *)this + 3);
      if (*(CGColorSpace **)(v58 + 144) != v59)
      {
        CA::OGL::Context::set_colorspace((CA::OGL::Context *)v58, *((CGColorSpace **)this + 3));
        BOOL v60 = CGColorSpaceUsesExtendedRange(v59);
        *((unsigned char *)CA::OGL::Context::color_program_cache(*(CA::OGL::Context **)(v17 + 8)) + 65) = !v60;
        CA::OGL::Mosaic::purge((CA::OGL::Mosaic *)(v17 + 1584));
        CA::OGL::Mosaic::purge((CA::OGL::Mosaic *)(v17 + 1776));
        CA::OGL::Mosaic::purge((CA::OGL::Mosaic *)(v17 + 1968));
        CA::OGL::Mosaic::purge((CA::OGL::Mosaic *)(v17 + 2160));
        CA::OGL::Mosaic::purge((CA::OGL::Mosaic *)(v17 + 2352));
      }
    }
    if (*(double *)(v17 + 80) != 1.0)
    {
      __asm { FMOV            V0.2D, #1.0 }
      *(_OWORD *)(v17 + 80) = _Q0;
      *(void *)(v17 + 96) = 0;
      *(void *)(v17 + 104) = 0;
      *(void *)(v17 + 120) = 0;
      *(void *)(v17 + 128) = 0;
      *(void *)(v17 + 112) = 0x3FF0000000000000;
    }
    *(unsigned char *)(v17 + 4176) = *(unsigned char *)(v17 + 4176) & 0xF9 | (4 * *((unsigned char *)this + 69));
    *(void *)(v17 + 4264) = this;
    if (((*((unsigned int *)this + 4) < 0x24uLL) & (0xC99B4EB03uLL >> *((_DWORD *)this + 4))) != 0) {
      __int16 v66 = 4;
    }
    else {
      __int16 v66 = 0;
    }
    *(_WORD *)(*(void *)(v17 + 8) + 832) = *(_WORD *)(*(void *)(v17 + 8) + 832) & 0xFFFB | v66;
    int v67 = *((_DWORD *)this + 4);
    switch(v67)
    {
      case 18:
        uint64_t v68 = *(void *)(v17 + 8);
        __int16 v69 = *(_WORD *)(v68 + 832) & 0x8FFF | 0x2000;
        break;
      case 10:
        uint64_t v68 = *(void *)(v17 + 8);
        __int16 v69 = *(_WORD *)(v68 + 832) & 0x8FFF | 0x3000;
        break;
      case 9:
        uint64_t v68 = *(void *)(v17 + 8);
        __int16 v69 = *(_WORD *)(v68 + 832) & 0x8FFF | 0x1000;
        break;
      default:
        uint64_t v68 = *(void *)(v17 + 8);
        __int16 v69 = *(_WORD *)(v68 + 832) & 0x8FFF;
        break;
    }
    *(_WORD *)(v68 + 832) = v69;
LABEL_104:
    *(unsigned char *)(v17 + 4228) = 1;
    goto LABEL_105;
  }
  if (v39) {
    goto LABEL_88;
  }
  CA::CG::Renderer::end_rendering((CA::CG::Renderer *)v17);
  BOOL v40 = (*(unsigned int (**)(void, uint64_t))(**(void **)(v17 + 8) + 184))(*(void *)(v17 + 8), 32) != 0;
  if ((*(unsigned int (**)(CA::CG::AccelRenderer *, void, BOOL))(*(void *)this + 48))(this, *(void *)(v17 + 8), v40))
  {
    (*(void (**)(void, void, void))(**(void **)(v17 + 8) + 80))(*(void *)(v17 + 8), 0, (*((_DWORD *)this + 12) - *((_DWORD *)this + 14)));
    if (!*(void *)(v17 + 4248)) {
      *(void *)(v17 + 4248) = (*(int (**)(void, uint64_t))(**(void **)(v17 + 8) + 184))(*(void *)(v17 + 8), 7);
    }
    goto LABEL_88;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 4224));
  return 0;
}

void sub_1846FBA94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CA::OGL::prepare_color_program_cache(CA::OGL::Context **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v8 = (*(unsigned char *)(*(void *)(a2 + 24) + 43) & 8) == 0 && (*(unsigned char *)(*(void *)(a2 + 16) + 25) & 4) == 0;
  int v9 = BYTE3(xmmword_1EB2ACC10);
  int v10 = CGColorSpaceUsesITUR_2100TF(*(CGColorSpaceRef *)(a3 + 48));
  if ((*(void *)(*(void *)(a2 + 24) + 40) & 0x30) == 0x20 && byte_1EB2ACC8C == 0) {
    v10 |= CGColorSpaceUsesExtendedRange(*(CGColorSpaceRef *)(a3 + 48));
  }
  int v12 = *(unsigned __int8 *)(a4 + 12);
  BOOL v13 = v12 == 25 && (*(unsigned char *)(*(void *)(a2 + 24) + 40) & 0x30) == 0;
  if (BYTE3(xmmword_1EB2ACC10)
    || ((v10 ^ 1) & 1) != 0
    || v13
    || (BOOL v14 = v9 == 0, (*(void *)(*(void *)(a2 + 24) + 40) & 0x30) == 0x10))
  {
    BOOL v8 = 0;
    BOOL v14 = 0;
  }
  BOOL v15 = v12 != 25 && CGColorSpaceUsesITUR_2100TF(*(CGColorSpaceRef *)(a3 + 48));
  int v16 = *a1;
  float v17 = *(float *)(a3 + 56);
  if ((CGColorSpaceContainsFlexGTCInfo() & 1) == 0)
  {
    if (initialized != -1) {
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    }
    if (*(float *)&dword_1EB2ACB98 != 0.0) {
      float v17 = fmax(*(float *)&dword_1EB2ACB98 * 0.00492610837, 1.0);
    }
  }
  if (v17 == 0.0) {
    float v18 = 4.9261;
  }
  else {
    float v18 = v17;
  }
  uint64_t v19 = *(void *)(a2 + 24);
  uint64_t v20 = *(void *)(v19 + 128);
  if (v20)
  {
    if (*(float *)(v20 + 260) == 0.0) {
      float v21 = v18;
    }
    else {
      float v21 = *(float *)(v20 + 260);
    }
    float v22 = *(float *)(v20 + 256);
  }
  else
  {
    float v22 = 1.0;
    float v21 = v18;
  }
  uint64_t v23 = *(void *)(v19 + 40);
  int v24 = CA::OGL::Context::color_program_cache(v16);
  if (v24)
  {
    int v25 = v24;
    *((_DWORD *)v24 + 17) = (v23 >> 4) & 3;
    *((unsigned char *)v24 + 64) = v14;
    *((unsigned char *)v24 + 65) = v8;
    *((unsigned char *)v24 + 67) = v15;
    *((float *)v24 + 13) = v18;
    uint64_t v26 = *((void *)v16 + 27);
    if (v26)
    {
      float v27 = *(float *)(v26 + 372);
      if (v21 != 0.0)
      {
        if (v27 > v21) {
          float v27 = v21;
        }
        if (v27 <= 1.0) {
          float v27 = 1.0;
        }
      }
      if (v22 < 1.0)
      {
        if (initialized != -1)
        {
          float v29 = v27;
          dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
          float v27 = v29;
        }
        if (*(float *)&dword_1EB2ACB90 == 1)
        {
          float v27 = (float)((float)(v27 + -1.0) * v22) + 1.0;
        }
        else
        {
          float v28 = log2f(v27);
          float v27 = exp2f(v28 * v22);
        }
      }
      *((float *)v25 + 12) = v27;
      *((unsigned char *)v25 + 66) = *(unsigned char *)(v26 + 406);
      *((float *)v25 + 14) = *(float *)(v26 + 364) / *(float *)(v26 + 372);
    }
  }
}

CA::ColorProgram::Cache *CA::OGL::Context::color_program_cache(CA::OGL::Context *this)
{
  uint64_t result = (CA::ColorProgram::Cache *)*((void *)this + 20);
  if (!result)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t result = (CA::ColorProgram::Cache *)malloc_type_zone_malloc(malloc_zone, 0x50uLL, 0x8BB15036uLL);
    if (result)
    {
      *((void *)this + 20) = CA::ColorProgram::Cache::Cache(result, *((CGColorSpaceRef *)this + 18));
      CA::OGL::Context::update_color_program_cache((uint64_t)this);
      return (CA::ColorProgram::Cache *)*((void *)this + 20);
    }
    else
    {
      *((void *)this + 20) = 0;
    }
  }
  return result;
}

void CAMarkStatistic(uint64_t a1, double a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  double v4 = *(double *)(a1 + 56);
  if (v4 <= 0.0)
  {
    *(double *)(a1 + 56) = a2;
  }
  else if (v4 + 1.0 < a2)
  {
    if (BYTE10(ca_debug_options))
    {
      memset(v29, 0, sizeof(v29));
      unsigned int v5 = CARecordCurrentDisplayGet();
      if (v5) {
        x_stream_printf((uint64_t)v29, "display %u: ", v6, v7, v8, v9, v10, v11, (uint64_t)v5);
      }
      x_stream_printf((uint64_t)v29, "%d transactions", v6, v7, v8, v9, v10, v11, (*(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 80)));
      uint64_t v18 = (*(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 84));
      if (v18) {
        x_stream_printf((uint64_t)v29, "; %d %s (%.3gs duration, %.3gfps frame rate, %.3g %s, %.2gs gap)",
      }
          v12,
          v13,
          v14,
          v15,
          v16,
          v17,
          v18);
      uint64_t v19 = (*(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 92));
      if (v19) {
        x_stream_printf((uint64_t)v29, "; %d cache miss%s", v12, v13, v14, v15, v16, v17, v19);
      }
      double v20 = *(double *)(a1 + 40);
      if (v20 != 0.0) {
        x_stream_printf((uint64_t)v29, "; %.3g MP area", v12, v13, v14, v15, v16, v17, COERCE__INT64(v20 * 0.000001));
      }
      if (*(_DWORD *)(a1 + 28)) {
        x_stream_printf((uint64_t)v29, "; %d draw calls", v12, v13, v14, v15, v16, v17, *(unsigned int *)(a1 + 28));
      }
      double v21 = *(double *)(a1 + 48);
      if (v21 != 0.0) {
        x_stream_printf((uint64_t)v29, "; %.3g MB uploaded", v12, v13, v14, v15, v16, v17, COERCE__INT64(v21 * 0.000001));
      }
      if (x_log_hook_p())
      {
        x_stream_get(v29);
        x_log_();
      }
      else
      {
        float v22 = x_log_category_CADebug;
        if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          float v28 = x_stream_get(v29);
          _os_log_impl(&dword_184668000, v22, OS_LOG_TYPE_DEFAULT, "%s\n", buf, 0xCu);
        }
      }
      if (*(void *)v29) {
        free(*(void **)v29);
      }
    }
    if (BYTE8(ca_debug_options))
    {
      if (x_log_hook_p())
      {
        CAGetStatsStruct(0);
        CAGetStatsStruct(0);
        x_log_();
      }
      else
      {
        uint64_t v23 = x_log_category_CADebug;
        if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_DEFAULT))
        {
          double v24 = (double)*(unint64_t *)CAGetStatsStruct(0) * 0.000001;
          double v25 = (double)*((unint64_t *)CAGetStatsStruct(0) + 1) * 0.000001;
          *(_DWORD *)float v29 = 134218240;
          *(double *)&v29[4] = v24;
          *(_WORD *)&v29[12] = 2048;
          *(double *)&v29[14] = v25;
          _os_log_impl(&dword_184668000, v23, OS_LOG_TYPE_DEFAULT, "CoreAnimation buffers: currently %.3gMB; maximum %.3gMB\n",
            v29,
            0x16u);
        }
      }
    }
    *(void *)(a1 + 80) = *(void *)(a1 + 16);
    int v26 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 92) = v26;
    *(double *)(a1 + 56) = a2;
    *(void *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
  }
}

uint64_t CAImageQueueCommit::CAImageQueueCommit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = a1 + 56;
  *(_OWORD *)(a1 + 40) = xmmword_184998060;
  *(void *)(a1 + 16) = a1 + 24;
  double v4 = (CA::Render::Encoder *)(a1 + 4120);
  CA::Render::Encoder::Encoder(a1 + 4120, a1 + 24, 4, *(_DWORD *)(a2 + 216), 0.0);
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  if (v5)
  {
    uint64_t v6 = (atomic_uint *)v5;
    int v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    CA::Render::Encoder::set_object_cache(v4, v6, v7 ^ 1);
    CA::Render::Encoder::ObjectCache::unref((CA::Render::Encoder::ObjectCache *)v6);
  }
  return a1;
}

void CA::Render::Encoder::set_object_cache(CA::Render::Encoder *this, atomic_uint *a2, int a3)
{
  uint64_t v6 = (CA::Render::Encoder::ObjectCache *)*((void *)this + 9);
  if (v6 != (CA::Render::Encoder::ObjectCache *)a2)
  {
    if (v6) {
      CA::Render::Encoder::ObjectCache::unref(v6);
    }
    if (a2) {
      atomic_fetch_add(a2, 1u);
    }
    *((void *)this + 9) = a2;
  }
  if (a2 && a3)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Encoder::ObjectCache::_lock);
    uint64_t v8 = *((void *)a2 + 2);
    if (v8)
    {
      uint64_t v9 = 0;
      uint64_t v10 = 1 << *(_DWORD *)v8;
      do
      {
        for (uint64_t i = *(uint64_t ***)(*(void *)(v8 + 16) + 8 * v9); i; uint64_t i = (uint64_t **)*i)
          CA::Render::encode_invalidation((CA::Render *)i[2], (const CA::Render::Object *)i[3], this, v7);
        ++v9;
      }
      while (v9 != v10);
      x_hash_table_remove_all(*((void **)a2 + 2));
    }
    uint64_t v12 = *((void *)a2 + 4);
    if (v12)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 1 << *(_DWORD *)v12;
      do
      {
        for (uint64_t j = *(uint64_t ***)(*(void *)(v12 + 16) + 8 * v13); j; uint64_t j = (uint64_t **)*j)
          CA::Render::encode_volatile((CA::Render *)j[2], (const CA::Render::Object *)j[3], this, v7);
        ++v13;
      }
      while (v13 != v14);
      x_hash_table_remove_all(*((void **)a2 + 4));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Encoder::ObjectCache::_lock);
  }
}

CA::Render::Encoder *CA::Render::encode_delete_object(CA::Render::Encoder *this, CA::Render::Encoder *a2, int a3)
{
  uint64_t v5 = this;
  uint64_t v6 = (unsigned char *)*((void *)this + 4);
  if ((unint64_t)(v6 + 1) > *((void *)this + 5))
  {
    this = (CA::Render::Encoder *)CA::Render::Encoder::grow(this, 1);
    uint64_t v6 = (unsigned char *)*((void *)v5 + 4);
  }
  *((void *)v5 + 4) = v6 + 1;
  *uint64_t v6 = 1;
  int v7 = (void *)*((void *)v5 + 4);
  if ((unint64_t)(v7 + 1) > *((void *)v5 + 5))
  {
    this = (CA::Render::Encoder *)CA::Render::Encoder::grow(v5, 8);
    int v7 = (void *)*((void *)v5 + 4);
  }
  void *v7 = a2;
  uint64_t v8 = *((void *)v5 + 4);
  unint64_t v9 = *((void *)v5 + 5);
  uint64_t v10 = (_DWORD *)(v8 + 8);
  *((void *)v5 + 4) = v8 + 8;
  if (v8 + 12 > v9)
  {
    this = (CA::Render::Encoder *)CA::Render::Encoder::grow(v5, 4);
    uint64_t v10 = (_DWORD *)*((void *)v5 + 4);
  }
  *uint64_t v10 = a3;
  *((void *)v5 + 4) += 4;
  return this;
}

void *x_hash_table_remove_all(void *result)
{
  if (result[3])
  {
    int v1 = result;
    uint64_t v2 = 0;
    uint64_t v3 = 1 << *(_DWORD *)result;
    while (1)
    {
      uint64_t v4 = v1[2];
      uint64_t v5 = *(void **)(v4 + 8 * v2);
      if (v5) {
        break;
      }
      if (!v1[9]) {
        goto LABEL_14;
      }
LABEL_17:
      *(void *)(v4 + 8 * v2++) = 0;
      if (v2 == v3)
      {
        v1[3] = 0;
        return result;
      }
    }
    do
    {
      uint64_t v6 = (void *)*v5;
      uint64_t v7 = v5[3];
      uint64_t v8 = (uint64_t (*)(void))v1[6];
      if (v8) {
        uint64_t result = (void *)v8(v5[2]);
      }
      unint64_t v9 = (uint64_t (*)(uint64_t))v1[7];
      if (v9) {
        uint64_t result = (void *)v9(v7);
      }
      uint64_t v10 = v1[9];
      if (v10)
      {
        void *v5 = *(void *)(v10 + 8);
        *(void *)(v10 + 8) = v5;
      }
      uint64_t v5 = v6;
    }
    while (v6);
    uint64_t v4 = v1[2];
    if (v10) {
      goto LABEL_17;
    }
LABEL_14:
    uint64_t result = *(void **)(v4 + 8 * v2);
    if (result)
    {
      do
      {
        uint64_t v11 = (void *)*result;
        free(result);
        uint64_t result = v11;
      }
      while (v11);
      uint64_t v4 = v1[2];
    }
    goto LABEL_17;
  }
  return result;
}

CA::Render::Encoder *CA::Render::encode_invalidation(CA::Render *this, const CA::Render::Object *a2, CA::Render *a3, void *a4)
{
  int v5 = (int)a2;
  if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
    dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
  }
  if (this) {
    uint64_t v7 = (CA::Render *)((char *)this + CA::Render::_render_id_slide);
  }
  else {
    uint64_t v7 = 0;
  }

  return CA::Render::encode_delete_object(a3, v7, v5);
}

atomic_uint *CA::Context::Generic::retain_encoder_cache(CA::Context::Generic *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = (os_unfair_lock_s *)(v1 + 164);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 164));
  if ((*(unsigned char *)(v1 + 241) & 8) != 0)
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = *(atomic_uint **)(v1 + 168);
    if (v3) {
      atomic_fetch_add(v3, 1u);
    }
  }
  os_unfair_lock_unlock(v2);
  return v3;
}

BOOL CA::Context::Generic::is_deferring(CA::Context::Generic *this)
{
  uint64_t v1 = *((void *)this + 1);
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_deferred_lock);
  BOOL v2 = CA::Context::_deferred_by_lid
    && std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Context::_deferred_by_lid, *(_DWORD *)(v1 + 8));
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_deferred_lock);
  return v2;
}

void CAImageQueueCommit::~CAImageQueueCommit(CAImageQueueCommit *this)
{
  BOOL v2 = (CAImageQueueCommit *)((char *)this + 4120);
  int v3 = (*(uint64_t (**)(void))(**((void **)this + 1) + 32))(*((void *)this + 1));
  CA::Render::Encoder::send_message(v2, v3, 0, 0, 0);
  (***((void (****)(void))this + 1))();
  CA::Render::Encoder::~Encoder(v2);
  x_heap_free(*((void ****)this + 2));
}

uint64_t CA::Context::send_deferrals(int a1, int a2, uint64_t a3, unsigned int a4, double a5)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  unsigned int v78 = a4;
  pthread_mutex_lock(&CA::Context::_deferred_sending_mutex);
  long long v76 = 0uLL;
  uint64_t v77 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_deferred_lock);
  if (!CA::Context::_deferred_by_lid || (uint64_t v8 = *(void **)(CA::Context::_deferred_by_lid + 16)) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_deferred_lock);
    return pthread_mutex_unlock(&CA::Context::_deferred_sending_mutex);
  }
  unsigned int v71 = a4;
  unint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  if (a1) {
    BOOL v12 = a2 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  int v13 = !v12;
  int v75 = v13;
  do
  {
    uint64_t v14 = v8[3];
    uint64_t v15 = *(void *)(v14 + 8);
    int v16 = v75;
    if (!v15) {
      int v16 = 0;
    }
    if (v16 != 1 || *(_DWORD *)(v15 + 12) == a1 && *(_DWORD *)(v15 + 4) == a2)
    {
      uint64_t v17 = 0;
      int v18 = 0;
      uint64_t v19 = (uint64_t *)v8[3];
      while (1)
      {
        uint64_t v20 = v19[2];
        if (!v20) {
          goto LABEL_26;
        }
        uint64_t v21 = *(void *)(v20 + 16);
        if (v21)
        {
          do
          {
            while (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(*(void *)a3, *(void *)(a3 + 8), *(void *)(v21 + 16)))
            {
              uint64_t v21 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase((void *)v19[2], (uint64_t *)v21);
              if (!v21) {
                goto LABEL_22;
              }
            }
            uint64_t v21 = *(void *)v21;
          }
          while (v21);
LABEL_22:
          uint64_t v20 = v19[2];
        }
        if (!*(void *)(v20 + 24)) {
          break;
        }
        int v18 = 1;
LABEL_28:
        uint64_t v19 = (uint64_t *)*v19;
        if (!v19)
        {
          if (v17)
          {
            if (v11 >= v10)
            {
              uint64_t v23 = (v11 - v9) >> 4;
              unint64_t v24 = v23 + 1;
              if ((unint64_t)(v23 + 1) >> 60) {
                abort();
              }
              if ((v10 - v9) >> 3 > v24) {
                unint64_t v24 = (v10 - v9) >> 3;
              }
              if ((unint64_t)(v10 - v9) >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v25 = v24;
              }
              if (v25)
              {
                if (v25 >> 60) {
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
                int v26 = (char *)operator new(16 * v25);
              }
              else
              {
                int v26 = 0;
              }
              float v27 = &v26[16 * v23];
              *(void *)float v27 = v14;
              *((void *)v27 + 1) = v17;
              if (v11 == v9)
              {
                float v29 = &v26[16 * v23];
              }
              else
              {
                float v28 = &v26[16 * v23];
                do
                {
                  float v29 = v28 - 16;
                  *((_OWORD *)v28 - 1) = *((_OWORD *)v11 - 1);
                  v11 -= 16;
                  v28 -= 16;
                }
                while (v11 != v9);
              }
              uint64_t v10 = &v26[16 * v25];
              uint64_t v11 = v27 + 16;
              *(void *)&long long v76 = v29;
              uint64_t v77 = v10;
              if (v9) {
                operator delete(v9);
              }
              unint64_t v9 = v29;
            }
            else
            {
              *(void *)uint64_t v11 = v14;
              *((void *)v11 + 1) = v17;
              v11 += 16;
            }
            *((void *)&v76 + 1) = v11;
          }
          goto LABEL_51;
        }
      }
      uint64_t v22 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v20);
      MEMORY[0x185323DC0](v22, 0x10A0C408EF24B1CLL);
      v19[2] = 0;
LABEL_26:
      v18 |= *((unsigned char *)v19 + 44) == 0;
      if ((v18 & 1) == 0) {
        uint64_t v17 = v19;
      }
      goto LABEL_28;
    }
LABEL_51:
    uint64_t v8 = (void *)*v8;
  }
  while (v8);
  uint64_t v30 = (void *)v76;
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_deferred_lock);
  if ((char *)v76 != v11)
  {
    do
    {
      uint64_t v31 = (uint64_t *)*v30;
      uint64_t v32 = (uint64_t *)v30[1];
      long long v74 = v30;
      uint64_t v33 = *(void *)(*v30 + 8);
      for (i = (uint64_t *)*v30; ; uint64_t v33 = i[1])
      {
        uint64_t v35 = (pthread_mutex_t *)(v33 + 16);
        pthread_mutex_lock((pthread_mutex_t *)(v33 + 16));
        if (CA::Render::DeferredEncoder::retime((int8x8_t *)i[3], a5)) {
          CA::Layer::run_deferred_animation_callbacks(i[3], a5, v36);
        }
        BOOL v39 = (i == v31 || i == v32) && v71 - 1 < 0xFFFFFFFE;
        mach_error_t v40 = CA::Render::Encoder::send_message((CA::Render::Encoder *)i[3], *(_DWORD *)(v33 + 160), 0, &v78, v39);
        if (v40)
        {
          mach_error_t v41 = v40;
          if (v40 == 268435459)
          {
            *(unsigned char *)(v33 + 241) |= 2u;
          }
          else if (v40 == -81182719)
          {
            x_log_crash("Unentitled call to server!");
            abort();
          }
          if (x_log_hook_p())
          {
            mach_error_string(v41);
            x_log_();
          }
          else
          {
            int v42 = x_log_category_api;
            if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
            {
              int v43 = *(_DWORD *)(v33 + 4);
              int v44 = mach_error_string(v41);
              *(_DWORD *)buf = 67109634;
              int v80 = v43;
              __int16 v81 = 1024;
              mach_error_t v82 = v41;
              __int16 v83 = 2080;
              unsigned int v84 = v44;
              _os_log_impl(&dword_184668000, v42, OS_LOG_TYPE_ERROR, "Failed to send deferred commits (client=0x%x) [0x%x %s]", buf, 0x18u);
            }
          }
        }
        if (*((_DWORD *)i + 10)) {
          kdebug_trace();
        }
        pthread_mutex_unlock(v35);
        uint64_t v45 = i[3];
        if (v45) {
          (*(void (**)(uint64_t))(*(void *)v45 + 8))(v45);
        }
        int v46 = (void *)i[4];
        if (v46)
        {
          do
          {
            uint64_t v47 = (const void *)*v46;
            (*(void (**)(void))(*v46 + 16))(*v46);
            _Block_release(v47);
            int v46 = (void *)v46[1];
          }
          while (v46);
          uint64_t v48 = (void *)i[4];
          if (v48)
          {
            do
            {
              unsigned int v49 = (void *)v48[1];
              free(v48);
              uint64_t v48 = v49;
            }
            while (v49);
          }
        }
        if (i == v32) {
          break;
        }
        uint64_t i = (uint64_t *)*i;
      }
      uint64_t v30 = v74 + 2;
    }
    while (v74 + 2 != (void *)v11);
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_deferred_lock);
    uint64_t v50 = *((void *)&v76 + 1);
    uint64_t v11 = (char *)v76;
    if ((void)v76 != *((void *)&v76 + 1))
    {
      uint64_t v51 = v76;
      do
      {
        uint64_t v52 = *(uint64_t **)(v51 + 8);
        unsigned int v53 = *(_DWORD *)(v52[1] + 8);
        *(_DWORD *)buf = v53;
        size_t v55 = (void *)CA::Context::_deferred_by_lid;
        if (*v52)
        {
          uint64_t v54 = *v52;
          std::__hash_table<std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)CA::Context::_deferred_by_lid, v53, buf)[3] = v54;
        }
        else
        {
          long long v56 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Context::_deferred_by_lid, v53);
          int8x8_t v57 = (int8x8_t)v55[1];
          unint64_t v58 = v56[1];
          uint8x8_t v59 = (uint8x8_t)vcnt_s8(v57);
          v59.i16[0] = vaddlv_u8(v59);
          if (v59.u32[0] > 1uLL)
          {
            if (v58 >= *(void *)&v57) {
              v58 %= *(void *)&v57;
            }
          }
          else
          {
            v58 &= *(void *)&v57 - 1;
          }
          BOOL v60 = *(uint64_t **)(*v55 + 8 * v58);
          do
          {
            uint64_t v61 = v60;
            BOOL v60 = (uint64_t *)*v60;
          }
          while (v60 != v56);
          if (v61 == v55 + 2) {
            goto LABEL_106;
          }
          unint64_t v62 = v61[1];
          if (v59.u32[0] > 1uLL)
          {
            if (v62 >= *(void *)&v57) {
              v62 %= *(void *)&v57;
            }
          }
          else
          {
            v62 &= *(void *)&v57 - 1;
          }
          if (v62 != v58)
          {
LABEL_106:
            if (!*v56) {
              goto LABEL_107;
            }
            unint64_t v63 = *(void *)(*v56 + 8);
            if (v59.u32[0] > 1uLL)
            {
              if (v63 >= *(void *)&v57) {
                v63 %= *(void *)&v57;
              }
            }
            else
            {
              v63 &= *(void *)&v57 - 1;
            }
            if (v63 != v58) {
LABEL_107:
            }
              *(void *)(*v55 + 8 * v58) = 0;
          }
          uint64_t v64 = *v56;
          if (*v56)
          {
            unint64_t v65 = *(void *)(v64 + 8);
            if (v59.u32[0] > 1uLL)
            {
              if (v65 >= *(void *)&v57) {
                v65 %= *(void *)&v57;
              }
            }
            else
            {
              v65 &= *(void *)&v57 - 1;
            }
            if (v65 != v58)
            {
              *(void *)(*v55 + 8 * v65) = v61;
              uint64_t v64 = *v56;
            }
          }
          *uint64_t v61 = v64;
          uint64_t *v56 = 0;
          --v55[3];
          operator delete(v56);
          __int16 v66 = (void **)CA::Context::_deferred_by_lid;
          if (!*(void *)(CA::Context::_deferred_by_lid + 24))
          {
            int v67 = *(void **)(CA::Context::_deferred_by_lid + 16);
            if (v67)
            {
              do
              {
                uint64_t v68 = (void *)*v67;
                operator delete(v67);
                int v67 = v68;
              }
              while (v68);
            }
            __int16 v69 = *v66;
            *__int16 v66 = 0;
            if (v69) {
              operator delete(v69);
            }
            MEMORY[0x185323DC0](v66, 0x10A0C408EF24B1CLL);
            CA::Context::_deferred_by_lid = 0;
          }
        }
        v51 += 16;
      }
      while (v51 != v50);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_deferred_lock);
    if (!pthread_main_np()) {
      operator new();
    }
    CA::Context::delete_sent_deferrals((uint64_t *)&v76);
  }
  if (v11)
  {
    *((void *)&v76 + 1) = v11;
    operator delete(v11);
  }
  return pthread_mutex_unlock(&CA::Context::_deferred_sending_mutex);
}

void sub_1846FCE98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  pthread_mutex_unlock(&CA::Context::_deferred_sending_mutex);
  _Unwind_Resume(a1);
}

uint64_t CA::Render::Encoder::send_message(CA::Render::Encoder *this, int a2, mach_port_t a3, unsigned int *a4, uint64_t a5)
{
  mach_port_t v47 = a3;
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  uint64_t v8 = this;
  unint64_t v9 = (unsigned char *)*((void *)this + 4);
  if ((unint64_t)(v9 + 1) > *((void *)this + 5))
  {
    this = (CA::Render::Encoder *)CA::Render::Encoder::grow(this, 1);
    unint64_t v9 = (unsigned char *)*((void *)v8 + 4);
  }
  *((void *)v8 + 4) = v9 + 1;
  unsigned char *v9 = 0;
  uint64_t v10 = *((void *)v8 + 7);
  uint64_t v11 = a5 == 1;
  if (v10)
  {
    MEMORY[0x1F4188790](this);
    BOOL v12 = (char *)&v42 - ((8 * v10 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v12, 8 * v10);
    int v13 = (uint64_t *)*((void *)v8 + 6);
    if (v13)
    {
      uint64_t v14 = 0;
      uint64_t v15 = 8 * v10 - 8;
      do
      {
        *(void *)&v12[v15] = v13;
        int v16 = *((_DWORD *)v13 + 2);
        if (v16 == 1) {
          uint64_t v17 = v14 + 1;
        }
        else {
          uint64_t v17 = v14;
        }
        if (v16 == 2) {
          ++v11;
        }
        else {
          uint64_t v14 = v17;
        }
        int v13 = (uint64_t *)*v13;
        v15 -= 8;
      }
      while (v13);
    }
    else
    {
      uint64_t v14 = 0;
    }
  }
  else
  {
    uint64_t v14 = 0;
    BOOL v12 = 0;
  }
  uint64_t v19 = *((void *)v8 + 3);
  uint64_t v18 = *((void *)v8 + 4);
  size_t v20 = v18 - v19;
  if (v18 == v19) {
    return 0;
  }
  uint64_t v46 = a5;
  uint64_t v42 = 12 * v11;
  int v43 = a4;
  unint64_t v21 = ((12 * v11 + 28 + 16 * v14 + v20) + 3) & 0x1FFFFFFFCLL;
  unint64_t v22 = *MEMORY[0x1E4F14B00];
  if (v21 < *MEMORY[0x1E4F14B00]) {
    uint64_t v23 = v14;
  }
  else {
    uint64_t v23 = v14 + 1;
  }
  MEMORY[0x1F4188790](this);
  unint64_t v25 = (char *)&v42 - v24;
  size_t v45 = v26;
  bzero((char *)&v42 - v24, v26);
  mach_port_t reply_port = v47;
  if (v47) {
    BOOL v28 = 1;
  }
  else {
    BOOL v28 = *((unsigned char *)v8 + 104) == 0;
  }
  int v29 = !v28;
  int v44 = v29;
  if (!v28) {
    mach_port_t reply_port = mig_get_reply_port();
  }
  if (v46) {
    int v30 = 40004;
  }
  else {
    int v30 = 40002;
  }
  if (v46) {
    int v31 = 40005;
  }
  else {
    int v31 = 40003;
  }
  if (v21 < v22) {
    int v31 = v30;
  }
  if (reply_port) {
    int v32 = 5395;
  }
  else {
    int v32 = 19;
  }
  int v33 = v45;
  *(_DWORD *)unint64_t v25 = v32;
  *((_DWORD *)v25 + 1) = v33;
  *((_DWORD *)v25 + 2) = a2;
  *((_DWORD *)v25 + 3) = reply_port;
  *((_DWORD *)v25 + 4) = 0;
  *((_DWORD *)v25 + 5) = v31;
  if (v11 + v23)
  {
    *(_DWORD *)unint64_t v25 = v32 | 0x80000000;
    *((_DWORD *)v25 + 6) = v11 + v23;
  }
  if (v21 >= v22)
  {
    mach_port_name_t v34 = reply_port;
    *(void *)(v25 + 28) = *((void *)v8 + 3);
    *((_DWORD *)v25 + 9) = *((_DWORD *)v8 + 4) & 0x100 | (v25[38] << 16) | 0x1000000;
    *((_DWORD *)v25 + 10) = v20;
    uint64_t v35 = v25 + 44;
  }
  else
  {
    mach_port_name_t v34 = reply_port;
    uint64_t v35 = v25 + 28;
    memcpy(&v25[16 * v23 + 28 + v42], *((const void **)v8 + 3), v20);
  }
  if (v46 == 1)
  {
    *(_DWORD *)uint64_t v35 = *v43;
    *((_WORD *)v35 + 5) = 19;
    v35 += 12;
  }
  for (; v10; --v10)
  {
    uint64_t v37 = *(void *)v12;
    int v38 = *(_DWORD *)(*(void *)v12 + 8);
    if (v38 == 2)
    {
      *(_DWORD *)uint64_t v35 = *(_DWORD *)(v37 + 16);
      *((_WORD *)v35 + 5) = *(unsigned __int8 *)(v37 + 20);
      uint64_t v40 = *(void *)v12;
      if (*(_DWORD *)(*(void *)v12 + 20) == 18 && *(unsigned char *)(v40 + 24)) {
        *(unsigned char *)(v40 + 24) = 0;
      }
      v35 += 12;
    }
    else if (v38 == 1)
    {
      *(void *)uint64_t v35 = *(void *)(v37 + 16);
      uint64_t v39 = *(void *)(*(void *)v12 + 24);
      *((_DWORD *)v35 + 2) = (v35[10] << 16) | 0x1000100;
      *((_DWORD *)v35 + 3) = v39;
      v35 += 16;
    }
    v12 += 8;
  }
  if (BYTE9(xmmword_1EB2ACC10))
  {
    kdebug_trace();
    uint64_t v36 = CA::Render::Message::send_message((mach_msg_header_t *)v25);
    kdebug_trace();
  }
  else
  {
    uint64_t v36 = CA::Render::Message::send_message((mach_msg_header_t *)v25);
  }
  if (v44)
  {
    if (!v36)
    {
      memset(msg, 0, 92);
      uint64_t v36 = mach_msg(msg, 2, 0, 0x5Cu, v34, 0, 0);
    }
    if ((v36 - 268435458) <= 0xE && ((1 << (v36 - 2)) & 0x4003) != 0) {
      mig_put_reply_port(v34);
    }
    else {
      mig_dealloc_reply_port(v34);
    }
  }
  return v36;
}

uint64_t CA::Render::Message::send_message(mach_msg_header_t *this)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  BOOLean_t v2 = voucher_mach_msg_set(this);
  uint64_t v3 = mach_msg(this, 1, this->msgh_size, 0, 0, 0, 0);
  if (v2) {
    voucher_mach_msg_clear(this);
  }
  if (v3)
  {
    if (v3 == 268435459) {
      goto LABEL_16;
    }
    if (CA::Render::should_abort_on_send_failures(void)::once[0] != -1) {
      dispatch_once(CA::Render::should_abort_on_send_failures(void)::once, &__block_literal_global_52_13583);
    }
    if ((CA::Render::should_abort_on_send_failures(void)::ignore_mach_send_errors & 1) == 0)
    {
      if (CADeviceHasInternalBuild::once[0] != -1) {
        dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
      }
      if (CADeviceHasInternalBuild::internal)
      {
        x_log_crash("CoreAnimation: Message::send_message() returned 0x%x - size %zu, # descriptors %zu", v3, this->msgh_size, this[1].msgh_bits);
        abort();
      }
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v4 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        int v7 = v3;
        _os_log_impl(&dword_184668000, v4, OS_LOG_TYPE_ERROR, "CoreAnimation: Message::send_message() returned 0x%x\n", buf, 8u);
      }
    }
    if ((v3 - 268435459) <= 1) {
LABEL_16:
    }
      mach_msg_destroy(this);
  }
  return v3;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(float *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *((void *)a1 + 1);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  uint64_t v10 = operator new(0x20uLL);
  *uint64_t v10 = 0;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  v10[3] = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (v6 && (float)(v13 * (float)v6) >= v12)
  {
    unint64_t v5 = v8;
    goto LABEL_64;
  }
  BOOL v14 = 1;
  if (v6 >= 3) {
    BOOL v14 = (v6 & (v6 - 1)) != 0;
  }
  unint64_t v15 = v14 | (2 * v6);
  unint64_t v16 = vcvtps_u32_f32(v12 / v13);
  if (v15 <= v16) {
    int8x8_t prime = (int8x8_t)v16;
  }
  else {
    int8x8_t prime = (int8x8_t)v15;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v6 = *((void *)a1 + 1);
  }
  if (*(void *)&prime <= v6)
  {
    if (*(void *)&prime >= v6) {
      goto LABEL_60;
    }
    unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v6 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
    {
      unint64_t v24 = std::__next_prime(v24);
    }
    else
    {
      uint64_t v26 = 1 << -(char)__clz(v24 - 1);
      if (v24 >= 2) {
        unint64_t v24 = v26;
      }
    }
    if (*(void *)&prime <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    if (*(void *)&prime >= v6)
    {
      unint64_t v6 = *((void *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      int v33 = *(void **)a1;
      *(void *)a1 = 0;
      if (v33) {
        operator delete(v33);
      }
      unint64_t v6 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v18 = operator new(8 * *(void *)&prime);
  uint64_t v19 = *(void **)a1;
  *(void *)a1 = v18;
  if (v19) {
    operator delete(v19);
  }
  uint64_t v20 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v20++) = 0;
  while (*(void *)&prime != v20);
  unint64_t v21 = (void *)*((void *)a1 + 2);
  if (v21)
  {
    unint64_t v22 = v21[1];
    uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
    v23.i16[0] = vaddlv_u8(v23);
    if (v23.u32[0] > 1uLL)
    {
      if (v22 >= *(void *)&prime) {
        v22 %= *(void *)&prime;
      }
    }
    else
    {
      v22 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
    float v27 = (void *)*v21;
    if (*v21)
    {
      do
      {
        unint64_t v28 = v27[1];
        if (v23.u32[0] > 1uLL)
        {
          if (v28 >= *(void *)&prime) {
            v28 %= *(void *)&prime;
          }
        }
        else
        {
          v28 &= *(void *)&prime - 1;
        }
        if (v28 != v22)
        {
          if (!*(void *)(*(void *)a1 + 8 * v28))
          {
            *(void *)(*(void *)a1 + 8 * v28) = v21;
            goto LABEL_56;
          }
          *unint64_t v21 = *v27;
          *float v27 = **(void **)(*(void *)a1 + 8 * v28);
          **(void **)(*(void *)a1 + 8 * v28) = v27;
          float v27 = v21;
        }
        unint64_t v28 = v22;
LABEL_56:
        unint64_t v21 = v27;
        float v27 = (void *)*v27;
        unint64_t v22 = v28;
      }
      while (v27);
    }
  }
  unint64_t v6 = (unint64_t)prime;
LABEL_60:
  if ((v6 & (v6 - 1)) != 0)
  {
    if (v6 <= v5) {
      v5 %= v6;
    }
  }
  else
  {
    unint64_t v5 = (v6 - 1) & v5;
  }
LABEL_64:
  int v29 = *(void **)a1;
  int v30 = *(void **)(*(void *)a1 + 8 * v5);
  if (v30)
  {
    *uint64_t v10 = *v30;
LABEL_72:
    *int v30 = v10;
    goto LABEL_73;
  }
  *uint64_t v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v5] = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v31 >= v6) {
        v31 %= v6;
      }
    }
    else
    {
      v31 &= v6 - 1;
    }
    int v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1846FD8D0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }
  else
  {
    unint64_t v4 = (a2 - 1) & a3;
  }
  unint64_t v5 = *(void **)(a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  uint64_t result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == a3)
      {
        if (result[2] == a3) {
          return result;
        }
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= a2) {
            v7 %= a2;
          }
        }
        else
        {
          v7 &= a2 - 1;
        }
        if (v7 != v4) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

BOOL CA::Render::DeferredEncoder::retime(int8x8_t *this, double a2)
{
  int8x8_t v4 = this[15];
  int8x8_t v3 = this[16];
  if (*(void *)&v4 == *(void *)&v3)
  {
    int8x8_t v3 = this[15];
  }
  else
  {
    int64x2_t v6 = vdupq_n_s64(0x7FF8000000000000uLL);
    int64x2_t v20 = v6;
    do
    {
      int8x8_t v7 = this[19];
      if (v7)
      {
        unint64_t v8 = **(void **)&v4;
        uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
        v9.i16[0] = vaddlv_u8(v9);
        if (v9.u32[0] > 1uLL)
        {
          unint64_t v10 = **(void **)&v4;
          if (v8 >= *(void *)&v7) {
            unint64_t v10 = v8 % *(void *)&v7;
          }
        }
        else
        {
          unint64_t v10 = (*(void *)&v7 - 1) & v8;
        }
        unint64_t v11 = *(void **)(*(void *)&this[18] + 8 * v10);
        if (v11)
        {
          float v12 = (void *)*v11;
          if (*v11)
          {
            do
            {
              unint64_t v13 = v12[1];
              if (v13 == v8)
              {
                if (v12[2] == v8)
                {
                  double v14 = CA::Render::TimingList::map_time(*(CA::Render::TimingList **)(*(void *)&v4 + 16), *(double *)(*(void *)&v4 + 24) + a2);
                  int64x2_t v6 = v20;
                  *(double *)(*(void *)&v4 + 32) = v14;
                  *(double *)(*(void *)&this[3] + v12[3]) = v14;
                  int8x8_t v3 = this[16];
                  goto LABEL_20;
                }
              }
              else
              {
                if (v9.u32[0] > 1uLL)
                {
                  if (v13 >= *(void *)&v7) {
                    v13 %= *(void *)&v7;
                  }
                }
                else
                {
                  v13 &= *(void *)&v7 - 1;
                }
                if (v13 != v10) {
                  break;
                }
              }
              float v12 = (void *)*v12;
            }
            while (v12);
          }
        }
      }
      *(int64x2_t *)(*(void *)&v4 + 24) = v6;
LABEL_20:
      *(void *)&v4 += 40;
    }
    while (*(void *)&v4 != *(void *)&v3);
  }
  if (this[21])
  {
    unint64_t v15 = (void *)this[20];
    if (v15)
    {
      do
      {
        unint64_t v16 = (void *)*v15;
        operator delete(v15);
        unint64_t v15 = v16;
      }
      while (v16);
    }
    this[20] = 0;
    int8x8_t v17 = this[19];
    if (v17)
    {
      uint64_t v18 = 0;
      do
        *(void *)(*(void *)&this[18] + 8 * v18++) = 0;
      while (*(void *)&v17 != v18);
    }
    this[21] = 0;
    int8x8_t v3 = this[16];
  }
  return *(void *)&this[15] != *(void *)&v3;
}

void CA::Render::DeferredEncoder::~DeferredEncoder(CA::Render::DeferredEncoder *this)
{
  CA::Render::DeferredEncoder::~DeferredEncoder(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  uint64_t v2;
  uint64_t i;
  atomic_uint *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t vars8;

  *(void *)this = &unk_1ED02E140;
  BOOLean_t v2 = *((void *)this + 15);
  for (uint64_t i = *((void *)this + 16); v2 != i; v2 += 40)
  {
    int8x8_t v4 = *(atomic_uint **)(v2 + 16);
    if (atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
    }
  }
  unint64_t v5 = (void *)*((void *)this + 20);
  if (v5)
  {
    do
    {
      int64x2_t v6 = (void *)*v5;
      operator delete(v5);
      unint64_t v5 = v6;
    }
    while (v6);
  }
  int8x8_t v7 = (void *)*((void *)this + 18);
  *((void *)this + 18) = 0;
  if (v7) {
    operator delete(v7);
  }
  unint64_t v8 = (void *)*((void *)this + 15);
  if (v8)
  {
    *((void *)this + 16) = v8;
    operator delete(v8);
  }

  CA::Render::Encoder::~Encoder(this);
}

void CA::Render::Encoder::~Encoder(CA::Render::Encoder *this)
{
  *(void *)this = &unk_1ED02F910;
  for (uint64_t i = (void *)*((void *)this + 14); i; uint64_t i = (void *)i[1])
  {
    uint64_t v3 = *i;
    if (atomic_fetch_add((atomic_uint *volatile)(*i + 8), 0xFFFFFFFF) == 1) {
      (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  int8x8_t v4 = (CA::Render::Encoder::ObjectCache *)*((void *)this + 9);
  if (v4) {
    CA::Render::Encoder::ObjectCache::unref(v4);
  }

  CA::Render::Coder::~Coder(this);
}

{
  malloc_zone_t *malloc_zone;
  uint64_t vars8;

  CA::Render::Encoder::~Encoder(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::Render::Encoder::ObjectCache::unref(CA::Render::Encoder::ObjectCache *this)
{
  if (atomic_fetch_add((atomic_uint *volatile)this, 0xFFFFFFFF) == 1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Encoder::ObjectCache::_lock);
    CA::Render::Encoder::ObjectCache::_cache_list = (uint64_t)x_list_remove((void *)CA::Render::Encoder::ObjectCache::_cache_list, (uint64_t)this);
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Encoder::ObjectCache::_lock);
    x_hash_table_free(*((void **)this + 1));
    BOOLean_t v2 = (void *)*((void *)this + 2);
    if (v2) {
      x_hash_table_free(v2);
    }
    uint64_t v3 = (void *)*((void *)this + 3);
    if (v3) {
      x_hash_table_free(v3);
    }
    int8x8_t v4 = (void *)*((void *)this + 4);
    if (v4) {
      x_hash_table_free(v4);
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, this);
  }
}

void CA::Render::CompressedImage::finalize(atomic_uint *this)
{
  CA::Render::post_notification(3u, (unint64_t)this, 0, 1);
  unsigned int add = atomic_fetch_add(this + 41, 0xFFFFFFFF);
  if (this && add == 1)
  {
    uint64_t v3 = *(void (**)(atomic_uint *))(*(void *)this + 8);
    v3(this);
  }
}

void CA::Render::CompressedImage::~CompressedImage(CA::Render::CompressedImage *this)
{
  CA::Render::CompressedImage::~CompressedImage(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  mach_port_name_t v2;
  void (*v3)(void, void);
  void *v4;
  malloc_zone_t *malloc_zone;
  void *v6;
  malloc_zone_t *v7;
  void *v8;
  malloc_zone_t *v9;
  uint64_t vars8;

  *(void *)this = &unk_1ED02E030;
  BOOLean_t v2 = *((_DWORD *)this + 43);
  if (v2) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v2);
  }
  uint64_t v3 = (void (*)(void, void))*((void *)this + 14);
  if (v3) {
    v3(*((void *)this + 12), *((void *)this + 15));
  }
  int8x8_t v4 = (void *)*((void *)this + 16);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, v4);
  int64x2_t v6 = (void *)*((void *)this + 17);
  int8x8_t v7 = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(v7, v6);
  unint64_t v8 = (void *)*((void *)this + 18);
  uint8x8_t v9 = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(v9, v8);
  --dword_1EB2ADDEC;

  CA::Render::Texture::~Texture((CGColorSpaceRef *)this);
}

void sub_1846FDF30(_Unwind_Exception *a1)
{
  --dword_1EB2ADDEC;
  CA::Render::Texture::~Texture(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::Render::release_cgtexturedata(CA::Render *this, const void *a2, void *a3)
{
  return CGImageTextureDataRelease();
}

int *CAImageQueuePing_(uint64_t a1, int a2, int a3, double a4, double a5)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t result = (int *)*(unsigned int *)(a1 + 208);
  if (result)
  {
    uint64_t result = CA::Context::retain_context_with_id((CA::Context *)result);
    unint64_t v11 = result ? result + 54 : 0;
    if (result)
    {
      float v12 = (CA::Render::Context *)(*(uint64_t (**)(int *))(*(void *)v11 + 8))(v11);
      if (v12)
      {
        unint64_t v13 = (atomic_uint *)v12;
        CA::Render::Context::will_commit(v12);
        CA::Render::Context::did_commit((unint64_t)v13, 1, 0, 1, 0, 0);
        if (atomic_fetch_add(v13 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v13 + 16))(v13);
        }
      }
      else
      {
        mach_port_t v14 = (*(uint64_t (**)(int *))(*(void *)v11 + 32))(v11);
        if (v14)
        {
          mach_port_t v15 = v14;
          int v16 = (*(uint64_t (**)(int *))(*(void *)v11 + 24))(v11);
          uint64_t v17 = *(void *)(a1 + 48);
          if (!v17 || (int v18 = *(_DWORD *)(*(void *)(v17 + 24) + 72)) == 0) {
            int v18 = v16;
          }
          uint64_t v21 = *MEMORY[0x1E4F14068];
          int v22 = v18;
          double v23 = a4;
          int v24 = a2;
          int v25 = a3;
          double v26 = a5;
          *(void *)&msg.uint64_t msgh_bits = 19;
          msg.uint64_t msgh_voucher_port = 0;
          msg.mach_msg_id_t msgh_id = 40204;
          msg.mach_port_t msgh_remote_port = v15;
          msg.mach_port_t msgh_local_port = 0;
          if (MEMORY[0x1E4F14B18]) {
            voucher_mach_msg_set(&msg);
          }
          if (mach_msg(&msg, 1, 0x3Cu, 0, 0, 0, 0) == -81182719)
          {
            x_log_crash("Unentitled call to server!");
            abort();
          }
        }
      }
      uint64_t v19 = **(uint64_t (***)(int *))v11;
      return (int *)v19(v11);
    }
  }
  return result;
}

uint64_t CA::Context::retain_render_ctx(CA::Context *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
  uint64_t v2 = *((void *)this + 13);
  if (v2)
  {
    uint64_t v3 = (atomic_uint *)(v2 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
    {
      uint64_t v2 = 0;
      atomic_fetch_add(v3, 0xFFFFFFFF);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
  return v2;
}

uint64_t CA::Context::Generic::server_port(CA::Context::Generic *this)
{
  return *(unsigned int *)(*((void *)this + 1) + 160);
}

uint64_t CA::Context::Generic::client_id(CA::Context::Generic *this)
{
  return *(unsigned int *)(*((void *)this + 1) + 4);
}

uint64_t CA::Context::Generic::retain_render_context(CA::Context **this)
{
  return CA::Context::retain_render_ctx(this[1]);
}

uint64_t CA::Render::CompressedImage::data_size(CA::Render::CompressedImage *this)
{
  return *((void *)this + 13);
}

void CA::Render::encode_volatile(CA::Render *this, const CA::Render::Object *a2, CA::Render::Encoder *a3, void *a4)
{
  int v5 = (int)a2;
  if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
    dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
  }
  if (this) {
    int8x8_t v7 = (char *)this + CA::Render::_render_id_slide;
  }
  else {
    int8x8_t v7 = 0;
  }
  unint64_t v8 = (unsigned char *)*((void *)a3 + 4);
  if ((unint64_t)(v8 + 1) > *((void *)a3 + 5))
  {
    CA::Render::Encoder::grow(a3, 1);
    unint64_t v8 = (unsigned char *)*((void *)a3 + 4);
  }
  *((void *)a3 + 4) = v8 + 1;
  *unint64_t v8 = 17;
  uint8x8_t v9 = (void *)*((void *)a3 + 4);
  if ((unint64_t)(v9 + 1) > *((void *)a3 + 5))
  {
    CA::Render::Encoder::grow(a3, 8);
    uint8x8_t v9 = (void *)*((void *)a3 + 4);
  }
  void *v9 = v7;
  uint64_t v10 = *((void *)a3 + 4);
  unint64_t v11 = *((void *)a3 + 5);
  float v12 = (_DWORD *)(v10 + 8);
  *((void *)a3 + 4) = v10 + 8;
  if (v10 + 12 > v11)
  {
    CA::Render::Encoder::grow(a3, 4);
    float v12 = (_DWORD *)*((void *)a3 + 4);
  }
  *float v12 = v5;
  *((void *)a3 + 4) += 4;
}

double CA::Render::TimingList::map_time(CA::Render::TimingList *this, double result)
{
  v11[1] = *(double *)MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)this + 2);
  uint64_t v2 = *((void *)this + 3);
  v11[0] = result;
  uint64_t v4 = v2 - v3;
  if (v4)
  {
    unint64_t v6 = 0;
    unint64_t v7 = v4 >> 3;
    if (v7 <= 1) {
      unint64_t v7 = 1;
    }
    unint64_t v8 = v7 - 1;
    do
    {
      uint64_t v9 = *((void *)this + 2);
      if (v6 >= (*((void *)this + 3) - v9) >> 3) {
        __assert_rtn("operator[]", "x-small-vector.h", 98, "pos < (size ()) && \"Out of bounds access\"");
      }
      if (CA::Render::Timing::map_time(*(CA::Render::Timing **)(v9 + 8 * v6), v11, 0)) {
        BOOL v10 = v8 == v6;
      }
      else {
        BOOL v10 = 1;
      }
      ++v6;
    }
    while (!v10);
    return v11[0];
  }
  return result;
}

void CA::Render::TimingList::~TimingList(CA::Render::TimingList *this, const CA::Render::Object *a2)
{
  CA::Render::TimingList::~TimingList(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  char *v3;
  char *v4;
  uint64_t v5;

  *(void *)this = &unk_1ED02CE58;
  uint64_t v3 = (char *)*((void *)this + 2);
  uint64_t v4 = (char *)*((void *)this + 3);
  if (v3 != v4)
  {
    do
    {
      int v5 = *(void *)v3;
      if (atomic_fetch_add((atomic_uint *volatile)(*(void *)v3 + 8), 0xFFFFFFFF) == 1) {
        (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
      }
      v3 += 8;
    }
    while (v3 != v4);
    uint64_t v3 = (char *)*((void *)this + 2);
  }
  if (v3 != *((char **)this + 4)) {
    free(v3);
  }
  --dword_1EB2ADE9C;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

uint64_t CA::Layer::run_deferred_animation_callbacks(uint64_t this, double a2, const CA::Render::DeferredEncoder *a3)
{
  if (!byte_1EB2ACC81)
  {
    if (*(void *)(this + 120) != *(void *)(this + 128)) {
      operator new();
    }
    __assert_rtn("run_deferred_animation_callbacks", "CALayer.mm", 8331, "!timing_infos.empty ()");
  }
  return this;
}

void sub_1846FEB54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,void *a21)
{
  if (a19 != a21) {
    free(a19);
  }
  if (v21) {
    MEMORY[0x185323DC0](v21, 0x20C40960023A9);
  }
  _Unwind_Resume(exception_object);
}

void CA::OGL::MetalContext::set_destination_offset(CA::OGL::MetalContext *this, int a2, int a3)
{
  *((_DWORD *)this + 710) = a2;
  *((_DWORD *)this + 711) = a3;
  uint64_t v3 = *((void *)this + 353);
  if (v3)
  {
    *(_DWORD *)(v3 + 32) = -a2;
    *(_DWORD *)(v3 + 36) = -a3;
    CA::OGL::MetalContext::update_projection_matrix(this);
    ++*((_DWORD *)this + 64);
  }
}

uint64_t CA::CG::IOSurfaceDrawable::set_as_destination(CA::CG::IOSurfaceDrawable *this, CA::OGL::Context *a2, uint64_t a3)
{
  return (*(uint64_t (**)(CA::OGL::Context *, void, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, *((void *)this + 12), 1, a3);
}

uint64_t CA::OGL::Context::update_color_program_cache(uint64_t this)
{
  if (*(void *)(this + 160))
  {
    uint64_t v1 = this;
    *(unsigned char *)(*(void *)(this + 160) + 60) = (*(_DWORD *)(this + 432) & 0x200 | (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)this + 184))(this, 21)) != 0;
    this = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v1 + 184))(v1, 40);
    BOOL v3 = (*(_DWORD *)(v1 + 432) & 0x2000000) == 0 && this != 0;
    *(unsigned char *)(*(void *)(v1 + 160) + 61) = v3;
  }
  return this;
}

id CAMetalContextCreate()
{
  v0 = (void *)MEMORY[0x185324A30]();
  if (CAMetalContextCreate::once[0] != -1) {
    dispatch_once(CAMetalContextCreate::once, &__block_literal_global_22238);
  }
  id v1 = MTLCreateSystemDefaultDevice();
  return v1;
}

void sub_1846FED2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CA::GenericRectTree<CA::Rect>::insert_node(uint64_t result, uint64_t *a2, double a3, __n128 a4, __n128 a5, __n128 a6)
{
  if (a6.n128_f64[0] <= a4.n128_f64[0] || a5.n128_f64[0] <= a3 || *(unsigned char *)(result + 16) != 0) {
    return result;
  }
  uint64_t v8 = result;
  if (*(unsigned char *)(result + 17))
  {
LABEL_10:
    *(unsigned char *)(v8 + 16) = 1;
    uint64_t v9 = *(void **)(v8 + 8);
    if (v9)
    {
      uint64_t result = CA::GenericRectTree<CA::Rect>::Pool::delete_node(*(void *)v8, v9);
      *(void *)(v8 + 8) = 0;
    }
    return result;
  }
  double v10 = a6.n128_f64[0];
  double v11 = a5.n128_f64[0];
  double v12 = a4.n128_f64[0];
  double v13 = a3;
  mach_port_t v15 = (double *)*a2;
  if (*a2)
  {
    double v16 = v15[1];
    if (v16 > a4.n128_f64[0])
    {
      if (v16 <= a6.n128_f64[0]) {
        a6.n128_f64[0] = v15[1];
      }
      uint64_t result = CA::GenericRectTree<CA::Rect>::insert_node(result, v15 + 6, v13, a4, a5, a6);
      double v12 = v15[1];
    }
    double v17 = v15[3];
    if (v17 < v10)
    {
      if (v12 <= v17) {
        double v18 = v15[3];
      }
      else {
        double v18 = v12;
      }
      a4.n128_f64[0] = v18;
      a5.n128_f64[0] = v11;
      a6.n128_f64[0] = v10;
      uint64_t result = CA::GenericRectTree<CA::Rect>::insert_node(v8, v15 + 7, v13, a4, a5, a6);
      double v10 = v18;
    }
    if (*v15 > v13)
    {
      if (*v15 <= v11) {
        a5.n128_f64[0] = *v15;
      }
      else {
        a5.n128_f64[0] = v11;
      }
      a4.n128_f64[0] = v12;
      a6.n128_f64[0] = v10;
      uint64_t result = CA::GenericRectTree<CA::Rect>::insert_node(v8, v15 + 4, v13, a4, a5, a6);
      double v13 = *v15;
    }
    double v19 = v15[2];
    if (v19 < v11)
    {
      if (v13 <= v19) {
        double v20 = v15[2];
      }
      else {
        double v20 = v13;
      }
      a4.n128_f64[0] = v12;
      a5.n128_f64[0] = v11;
      a6.n128_f64[0] = v10;
      uint64_t result = CA::GenericRectTree<CA::Rect>::insert_node(v8, v15 + 5, v20, a4, a5, a6);
      double v11 = v20;
    }
    if (v11 > v13 && v10 > v12) {
      goto LABEL_10;
    }
  }
  else
  {
    unsigned int v21 = *(_DWORD *)(result + 20);
    *(_DWORD *)(result + 20) = v21 + 1;
    if (v21 > 0x3F) {
      goto LABEL_10;
    }
    int v22 = *(uint64_t **)result;
    uint64_t result = **(void **)result;
    if (result)
    {
      uint64_t *v22 = *(void *)(result + 32);
      *(void *)(result + 32) = 0;
    }
    else
    {
      double v23 = (uint64_t *)v22[1];
      unint64_t v24 = v23[2];
      BOOL v25 = v24 >= 0x40;
      unint64_t v26 = v24 - 64;
      if (v25)
      {
        uint64_t result = v23[1];
        v23[1] = result + 64;
        v23[2] = v26;
      }
      else
      {
        uint64_t result = x_heap_malloc_small_(v23, 0x40uLL);
      }
      *(_OWORD *)(result + 32) = 0u;
      *(_OWORD *)(result + 48) = 0u;
    }
    *(double *)uint64_t result = v13;
    *(double *)(result + 8) = v12;
    *(double *)(result + 16) = v11;
    *(double *)(result + 24) = v10;
    *a2 = result;
  }
  return result;
}

uint64_t CA::GenericRectTree<CA::Rect>::Pool::delete_node(uint64_t result, void *a2)
{
  BOOL v3 = (void *)result;
  if (a2[4])
  {
    uint64_t result = CA::GenericRectTree<CA::Rect>::Pool::delete_node(result);
    a2[4] = 0;
  }
  if (a2[5])
  {
    uint64_t result = CA::GenericRectTree<CA::Rect>::Pool::delete_node(v3);
    a2[5] = 0;
  }
  if (a2[6])
  {
    uint64_t result = CA::GenericRectTree<CA::Rect>::Pool::delete_node(v3);
    a2[6] = 0;
  }
  if (a2[7])
  {
    uint64_t result = CA::GenericRectTree<CA::Rect>::Pool::delete_node(v3);
    a2[7] = 0;
  }
  a2[4] = *v3;
  void *v3 = a2;
  return result;
}

uint64_t ___ZN2CA19IOMobileFramebuffer10swap_beginEPj_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t result = IOMobileFramebufferSwapBegin();
  if (!result) {
    *(unsigned char *)(v2 + 16) = 0;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t CA::Render::count_elements(uint64_t this, void *a2, const CGPathElement *a3)
{
  uint64_t v3 = *(int *)a2;
  unint64_t v4 = cgpath_counts[v3];
  unint64_t v5 = *(void *)(this + 8) + v4;
  ++*(void *)this;
  *(void *)(this + 8) = v5;
  if (v3) {
    ++*(void *)(this + 16);
  }
  if (*(unsigned char *)(this + 40)) {
    BOOL v6 = v3 == 4;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    unint64_t v7 = (void *)(a2[1] + 8);
    do
    {
      if ((*(v7 - 1) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*v7 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
      {
        *(unsigned char *)(this + 40) = 0;
      }
      v7 += 2;
      --v4;
    }
    while (v4);
  }
  return this;
}

CAAnimation *CALayerCreateImplicitAnimation(CAMediaTimingFunction *a1, void *a2, unsigned int a3)
{
  unint64_t v5 = (CAAnimation *)a1;
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!CALayerCreateImplicitAnimation::timingFunction)
  {
    a1 = +[CAMediaTimingFunction functionWithName:@"default"];
    CALayerCreateImplicitAnimation::timingFunctiounint64_t n = (uint64_t)a1;
  }
  char v15 = 0;
  BOOL v6 = CA::Transaction::ensure_compat((CA::Transaction *)a1);
  if (CA::Transaction::get_value(*((void *)v6 + 11), 29, (const CGAffineTransform *)7, (CA::Mat4Impl *)&v15))BOOL v7 = v15 == 0; {
  else
  }
    BOOL v7 = 1;
  if (v7) {
    unint64_t v5 = (CAAnimation *)[(CAAnimation *)v5 presentationLayer];
  }
  if (v5)
  {
    if (a3)
    {
      uint64_t v8 = (objc_class *)objc_opt_class();
      uint64_t v9 = (uint64_t *)classDescription(v8);
      double v10 = propertyInfoForAtom(v9, a3, 0);
      if (v10)
      {
        double v11 = (const char *)*((void *)v10 + 2);
        if (!v11 || !*((_WORD *)v10 + 2)) {
          return 0;
        }
        id v12 = CA_valueForKey(v5, v11, *((unsigned __int16 *)v10 + 2));
      }
      else
      {
        id v12 = [(CAAnimation *)v5 valueForUndefinedKey:CAAtomGetString(a3)];
      }
    }
    else
    {
      id v12 = CAObject_valueForKeyPath(v5, a2);
    }
    double v13 = v12;
    if (v12)
    {
      unint64_t v5 = +[CAAnimation animation];
      [(CAAnimation *)v5 setFromValue:v13];
      [(CAAnimation *)v5 setKeyPath:a2];
      [(CAAnimation *)v5 setTimingFunction:CALayerCreateImplicitAnimation::timingFunction];
      [(CAAnimation *)v5 setFillMode:@"backwards"];
      if (dyld_program_sdk_at_least()) {
        v5->_flags |= 1u;
      }
      return v5;
    }
    return 0;
  }
  return v5;
}

void sub_1846FF484()
{
}

void *CAObject_initWithCoder(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)[a1 init];
  uint64_t v3 = v2;
  if (v2)
  {
    objc_msgSend(v2, "CA_initialize_for_decoding");
    unint64_t v4 = objc_msgSend(a2, "decodeObjectOfClasses:forKey:", objc_msgSend(MEMORY[0x1E4F28B90], "CA_supportedClasses"), @"__CACodingContents");
    if (v4)
    {
      unint64_t v5 = v4;
      uint64_t v19 = [v4 count];
      if (v19)
      {
        for (uint64_t i = 0; i != v19; ++i)
        {
          BOOL v7 = (__CFString *)objc_msgSend(v5, "objectAtIndex:", i, v17, v18);
          uint64_t v8 = objc_msgSend(a2, "CA_decodeObjectForKey:", v7);
          if ([(__CFString *)v7 isEqualToString:@"sublayers"])
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              long long v28 = 0u;
              long long v29 = 0u;
              long long v26 = 0u;
              long long v27 = 0u;
              uint64_t v9 = [v8 countByEnumeratingWithState:&v26 objects:v25 count:16];
              if (v9)
              {
                uint64_t v10 = *(void *)v27;
                do
                {
                  uint64_t v11 = 0;
                  do
                  {
                    if (*(void *)v27 != v10) {
                      objc_enumerationMutation(v8);
                    }
                    uint64_t v12 = *(void *)(*((void *)&v26 + 1) + 8 * v11);
                    objc_opt_class();
                    if ((objc_opt_isKindOfClass() & 1) == 0) {
                      [MEMORY[0x1E4F1CA00] raise:@"CALayerInvalid", @"sublayers array %@ contains non-layer %@", v8, v12 format];
                    }
                    ++v11;
                  }
                  while (v9 != v11);
                  uint64_t v9 = [v8 countByEnumeratingWithState:&v26 objects:v25 count:16];
                }
                while (v9);
              }
            }
          }
          if (objc_msgSend(v3, "CA_validateValue:forKey:", v8, v7))
          {
            CAObject_setValueForKey(v3, 0, v8, v7);
          }
          else if (x_log_hook_p())
          {
            uint64_t v17 = objc_msgSend((id)objc_msgSend(v8, "debugDescription"), "UTF8String");
            uint64_t v18 = objc_msgSend((id)-[__CFString debugDescription](v7, "debugDescription"), "UTF8String");
            x_log_();
          }
          else
          {
            double v13 = x_log_category_api;
            if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
            {
              uint64_t v14 = objc_msgSend((id)objc_msgSend(v8, "debugDescription"), "UTF8String");
              uint64_t v15 = objc_msgSend((id)-[__CFString debugDescription](v7, "debugDescription"), "UTF8String");
              *(_DWORD *)buf = 136315394;
              uint64_t v22 = v14;
              __int16 v23 = 2080;
              uint64_t v24 = v15;
              _os_log_impl(&dword_184668000, v13, OS_LOG_TYPE_ERROR, "Rejecting value:\n %s\nFor key: %s", buf, 0x16u);
            }
          }
        }
      }
    }
  }
  return v3;
}

void sub_1846FFAE8(_Unwind_Exception *a1)
{
}

void CA::Layer::set_bit_int(CA::Layer *this, unsigned int a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  v22[1] = *(objc_object **)MEMORY[0x1E4F143B8];
  uint64_t v12 = CA::Transaction::ensure_compat(this);
  int v13 = *((_DWORD *)v12 + 25);
  *((_DWORD *)v12 + 25) = v13 + 1;
  if (!v13) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  uint64_t v14 = (char *)this + 40;
  int v15 = a6 & a5;
  uint64_t v16 = a3 >> 5;
  if (((*((_DWORD *)this + v16 + 11) >> a3) & a5) != (a6 & a5))
  {
    v22[0] = 0;
    String = (objc_object *)CAAtomGetString(a2);
    CA::Layer::begin_change(this, v12, String, (objc_object *)v22, v18);
    uint64_t v14 = CA::Layer::writable_state(this, v12);
    *(_DWORD *)&v14[4 * v16 + 4] = *(_DWORD *)&v14[4 * v16 + 4] & ~(a5 << (a3 & 0x1F)) | (v15 << (a3 & 0x1F));
    CA::Layer::end_change((id *)this, v12, a2, String, v22[0]);
  }
  uint64_t v19 = a4 >> 5;
  int v20 = 1 << a4;
  if ((*(_DWORD *)&v14[4 * v19 + 4] & v20) == 0)
  {
    unsigned int v21 = CA::Layer::writable_state(this, v12);
    *(_DWORD *)&v21[4 * v19 + 4] |= v20;
  }

  CA::Transaction::unlock(v12);
}

void sub_1846FFD28(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA_setValueForKey(void *a1, const char *a2, uint64_t a3, void *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    unint64_t v4 = a2;
    if (a2)
    {
      unint64_t v5 = a1;
      switch((int)a3)
      {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          BOOL v6 = a4;
          goto LABEL_21;
        case 6:
          uint64_t v7 = [a4 BOOLValue];
          goto LABEL_13;
        case 7:
          uint64_t v7 = [a4 charValue];
          goto LABEL_13;
        case 8:
          uint64_t v7 = [a4 unsignedCharValue];
          goto LABEL_13;
        case 9:
          uint64_t v7 = [a4 shortValue];
          goto LABEL_13;
        case 10:
          uint64_t v7 = [a4 unsignedShortValue];
          goto LABEL_13;
        case 11:
          uint64_t v7 = [a4 intValue];
          goto LABEL_13;
        case 12:
          uint64_t v7 = [a4 unsignedIntValue];
LABEL_13:
          BOOL v6 = (void *)v7;
          a1 = v5;
          a2 = v4;
          goto LABEL_15;
        case 13:
          uint64_t v8 = [a4 longValue];
          goto LABEL_20;
        case 14:
          uint64_t v8 = [a4 unsignedLongValue];
          goto LABEL_20;
        case 15:
          uint64_t v8 = [a4 longLongValue];
          goto LABEL_20;
        case 16:
          uint64_t v8 = [a4 unsignedLongLongValue];
LABEL_20:
          BOOL v6 = (void *)v8;
          a1 = v5;
          a2 = v4;
LABEL_21:
          goto LABEL_15;
        case 17:
          [a4 floatValue];
          a1 = v5;
          a2 = v4;
          goto LABEL_15;
        case 18:
          [a4 doubleValue];
          a1 = v5;
          a2 = v4;
          goto LABEL_15;
        case 19:
          [a4 pointValue];
          goto LABEL_32;
        case 20:
          [a4 sizeValue];
LABEL_32:
          a1 = v5;
          a2 = v4;
          goto LABEL_15;
        case 21:
          [a4 rectValue];
          a1 = v5;
          a2 = v4;
          goto LABEL_15;
        case 22:
          if (a4) {
            [a4 CATransform3DValue];
          }
          else {
            memset(v11, 0, sizeof(v11));
          }
          uint64_t v9 = v11;
          goto LABEL_53;
        case 23:
          if (a4) {
            objc_msgSend(a4, "CA_CGAffineTransformValue");
          }
          else {
            memset(v12, 0, sizeof(v12));
          }
          uint64_t v9 = v12;
          goto LABEL_53;
        case 24:
          [a4 CAPoint3DValue];
          a1 = v5;
          a2 = v4;
LABEL_15:
          objc_msgSend(a1, a2, v6);
          break;
        case 25:
          if (a4) {
            [a4 CACornerRadiiValue];
          }
          else {
            memset(v10, 0, sizeof(v10));
          }
          uint64_t v9 = v10;
LABEL_53:
          objc_msgSend(v5, v4, v9);
          break;
        default:
          NSLog(&cfstr_UnhandledSette.isa, a3);
          break;
      }
    }
  }
}

void CAObject_setValueForKey(void *a1, objc_class *a2, void *a3, const __CFString *a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (objc_class *)objc_opt_class();
  uint64_t v9 = (uint64_t *)classDescription(v8);
  uint64_t v10 = propertyInfoForKey(v9, a4, 0);
  if (v10
    && (uint64_t v11 = (const char *)*((void *)v10 + 1)) != 0
    && (uint64_t v12 = *((unsigned __int16 *)v10 + 2), *((_WORD *)v10 + 2)))
  {
    CA_setValueForKey(a1, v11, v12, a3);
  }
  else if (a2)
  {
    v13.receiver = a1;
    v13.super_class = a2;
    objc_msgSendSuper(&v13, sel_setValue_forKey_, a3, a4);
  }
}

id CAObject_valueForKey(void *a1, objc_class *a2, const __CFString *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  BOOL v6 = (objc_class *)objc_opt_class();
  uint64_t v7 = (uint64_t *)classDescription(v6);
  uint64_t v8 = propertyInfoForKey(v7, a3, 0);
  if (v8
    && (uint64_t v9 = (const char *)*((void *)v8 + 2)) != 0
    && (uint64_t v10 = *((unsigned __int16 *)v8 + 2), *((_WORD *)v8 + 2)))
  {
    return CA_valueForKey(a1, v9, v10);
  }
  else
  {
    v12.receiver = a1;
    v12.super_class = a2;
    return objc_msgSendSuper(&v12, sel_valueForKey_, a3);
  }
}

unsigned int *propertyInfoForAtom(uint64_t *a1, unsigned int a2, void *a3)
{
  if (!a1) {
    return 0;
  }
  while (1)
  {
    int v3 = *((_DWORD *)a1 + 6);
    if (v3) {
      break;
    }
LABEL_13:
    a1 = (uint64_t *)*a1;
    if (!a1) {
      return 0;
    }
  }
  unint64_t v4 = (unsigned int *)a1[2];
  unint64_t v5 = (unint64_t)&v4[10 * v3 - 10];
  unint64_t v6 = v5 - (void)v4;
  if ((uint64_t)(v5 - (void)v4) < 41) {
    goto LABEL_12;
  }
  while (1)
  {
    uint64_t v7 = &v4[10 * (v6 / 0x50)];
    if (*v7 == a2) {
      break;
    }
    if (*v7 > a2) {
      unint64_t v5 = (unint64_t)v7;
    }
    else {
      unint64_t v4 = v7;
    }
    unint64_t v6 = v5 - (void)v4;
    if ((uint64_t)(v5 - (void)v4) <= 40)
    {
LABEL_12:
      while ((unint64_t)v4 <= v5)
      {
        if (*v4 == a2) {
          goto LABEL_16;
        }
        v4 += 10;
      }
      goto LABEL_13;
    }
  }
  unint64_t v4 = v7;
LABEL_16:
  if (a3) {
    *a3 = a1;
  }
  return v4;
}

unsigned int *propertyInfoForKey(uint64_t *a1, const __CFString *a2, void *a3)
{
  unsigned int v5 = CAInternAtom(a2, 1);
  if (!v5) {
    return 0;
  }

  return propertyInfoForAtom(a1, v5, a3);
}

id objectForKey(NSArray *a1, NSString *a2, unint64_t *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = [(NSArray *)a1 count];
  int v7 = [(NSString *)a2 length];
  if ((v7 & 0xFFFFFFF8) == 0) {
    goto LABEL_12;
  }
  uint64_t v8 = (v7 - 1);
  if ([(NSString *)a2 characterAtIndex:v8] != 41 {
    || ![(NSString *)a2 hasPrefix:@"@index(")]
  }
  {
    goto LABEL_12;
  }
  unsigned int v14 = 0;
  uint64_t v9 = (void *)[objc_alloc(MEMORY[0x1E4F28FE8]) initWithString:a2];
  [v9 setScanLocation:7];
  if (![v9 scanInt:&v14] || objc_msgSend(v9, "scanLocation") != v8) {
    unsigned int v14 = -1;
  }

  if ((v14 & 0x80000000) != 0)
  {
LABEL_12:
    if (v6)
    {
      unint64_t v11 = 0;
      while (1)
      {
        id v10 = [(NSArray *)a1 objectAtIndex:v11];
        if ((objc_opt_respondsToSelector() & 1) == 0) {
          break;
        }
        objc_super v12 = (void *)[v10 name];
        if (v12 && [v12 isEqualToString:a2])
        {
          if (a3) {
            *a3 = v11;
          }
          return v10;
        }
        if (v6 == ++v11) {
          return 0;
        }
      }
    }
    return 0;
  }
  if (v6 <= v14) {
    return 0;
  }
  if (a3) {
    *a3 = v14;
  }
  return -[NSArray objectAtIndex:](a1, "objectAtIndex:");
}

void sub_184700BE0(_Unwind_Exception *a1)
{
}

uint64_t ensure_displays(void)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  pthread_mutex_lock(&_displays_mutex);
  if ((displays_up_to_date & 1) == 0)
  {
    query_displays();
    displays_up_to_date = 1;
  }
  if ([(id)_displays count] && (initialized & 1) == 0)
  {
    out_tokeunint64_t n = 0;
    uint32_t v0 = notify_register_dispatch("com.apple.CoreAnimation.CAWindowServer.DisplayChanged", &out_token, MEMORY[0x1E4F14428], &__block_literal_global_921);
    if (v0)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        id v1 = x_log_category_windowserver;
        if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          uint32_t v8 = v0;
          _os_log_impl(&dword_184668000, v1, OS_LOG_TYPE_ERROR, "Failed to register for CADisplay change notifications: 0x%x", buf, 8u);
        }
      }
    }
    int v5 = 0;
    if (CA::Display::display_queue(void)::once != -1) {
      dispatch_once(&CA::Display::display_queue(void)::once, &__block_literal_global_939);
    }
    uint32_t v2 = notify_register_dispatch("com.apple.CoreAnimation.CAWindowServer.DisplayPower", &v5, (dispatch_queue_t)CA::Display::display_queue(void)::queue, &__block_literal_global_926);
    if (v2)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int v3 = x_log_category_windowserver;
        if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          uint32_t v8 = v2;
          _os_log_impl(&dword_184668000, v3, OS_LOG_TYPE_ERROR, "Failed to register for CADisplay power notifications: 0x%x", buf, 8u);
        }
      }
    }
    CA::Render::add_observer(0x32u, 0, (uint64_t)will_suspend_callback, 0, 0);
    initialized = 1;
  }
  return pthread_mutex_unlock(&_displays_mutex);
}

void sub_184700E44(_Unwind_Exception *a1)
{
}

void CAAnimation_setter(uint64_t a1, const void *a2, int a3, unsigned __int8 *a4)
{
  uint32_t v8 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (!v8) {
    uint32_t v8 = (CA::Transaction *)CA::Transaction::create((CA::Transaction *)a1);
  }
  if (*(unsigned char *)(a1 + 16)) {
    [MEMORY[0x1E4F1CA00] raise:@"CAAnimationImmutable", @"attempting to modify read-only animation %@", a1 format];
  }
  String = CAAtomGetString(a2);
  [(id)a1 willChangeValueForKey:String];
  int v10 = *((_DWORD *)v8 + 25);
  *((_DWORD *)v8 + 25) = v10 + 1;
  if (!v10) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  unint64_t v11 = *(CA::AttrList **)(a1 + 8);
  if (!v11)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    unint64_t v11 = (CA::AttrList *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x10uLL, 0x743898A5uLL);
  }
  *(void *)(a1 + 8) = CA::AttrList::set(v11, a2, a3, a4);
  CA::Transaction::unlock(v8);
  [(id)a1 didChangeValueForKey:String];
  if ((int)a2 > 468)
  {
    if ((a2 - 469) >= 2 && a2 != 558 && a2 != 526) {
      return;
    }
  }
  else if ((int)a2 > 190)
  {
    if (a2 != 191 && a2 != 223) {
      return;
    }
  }
  else if (a2 != 49 && a2 != 57)
  {
    return;
  }

  CAMediaTimingInvalidate(a1);
}

uint64_t CAMediaTimingCopyRenderTiming(unint64_t a1)
{
  v34[1] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    unint64_t v2 = a1 ^ 0x8000000000000000;
    os_unfair_lock_lock((os_unfair_lock_t)&timing_lock);
    if (timing_cache)
    {
      v34[0] = 0;
      uint64_t v3 = x_hash_table_lookup(timing_cache, v2, v34);
      if (v34[0])
      {
        uint64_t v4 = v3;
LABEL_52:
        if (v4)
        {
          int v32 = (atomic_uint *)(v4 + 8);
          if (!atomic_fetch_add((atomic_uint *volatile)(v4 + 8), 1u))
          {
            uint64_t v4 = 0;
            atomic_fetch_add(v32, 0xFFFFFFFF);
          }
        }
LABEL_55:
        os_unfair_lock_unlock((os_unfair_lock_t)&timing_lock);
        return v4;
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&timing_lock);
    [(id)a1 beginTime];
    double v6 = v5;
    [(id)a1 timeOffset];
    double v8 = v7;
    [(id)a1 duration];
    double v10 = v9;
    [(id)a1 speed];
    float v12 = v11;
    if (v6 >= 0.000001 || v6 <= 0.0) {
      double v14 = v6;
    }
    else {
      double v14 = 0.0;
    }
    [(id)a1 repeatCount];
    float v16 = v15;
    [(id)a1 repeatDuration];
    double v18 = v17;
    int v19 = [(id)a1 autoreverses];
    int v20 = v19;
    if (v18 <= 0.0 || v16 <= 0.0)
    {
      double v23 = v18;
    }
    else
    {
      double v21 = v10 + v10;
      if (!v19) {
        double v21 = v10;
      }
      double v22 = v21 * v16;
      double v23 = 0.0;
      if (v18 < v22) {
        goto LABEL_21;
      }
    }
    double v18 = v23;
    if (v16 > 0.0)
    {
      double v24 = v16;
      goto LABEL_23;
    }
LABEL_21:
    double v24 = 0.0;
    if (v18 > 0.0)
    {
      int v20 = v19 | 8;
      double v24 = v18;
    }
LABEL_23:
    BOOL v25 = (__CFString *)[(id)a1 fillMode];
    long long v26 = v25;
    if (!v25)
    {
LABEL_35:
      if (!v20 && (v14 == 0.0 ? (BOOL v27 = v10 == INFINITY) : (BOOL v27 = 0), v27 && v8 == 0.0 && v12 == 1.0 && v24 == 0.0))
      {
        uint64_t v4 = 0;
      }
      else
      {
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        long long v29 = (double *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x40uLL, 0x743898A5uLL);
        uint64_t v4 = (uint64_t)v29;
        if (v29)
        {
          *((_DWORD *)v29 + 2) = 1;
          ++dword_1EB2ADE98;
          *(void *)long long v29 = &unk_1ED02F798;
          int v30 = 52;
        }
        else
        {
          int v30 = MEMORY[0xC];
        }
        *((_DWORD *)v29 + 3) = v30 | (v20 << 8);
        v29[5] = v14;
        v29[6] = v8;
        *((float *)v29 + 4) = v12;
        v29[3] = v24;
        v29[4] = v10;
      }
      os_unfair_lock_lock((os_unfair_lock_t)&timing_lock);
      unint64_t v31 = (int *)timing_cache;
      if (!timing_cache)
      {
        unint64_t v31 = (int *)x_hash_table_new_(0, 0, 0, (uint64_t)release_timing, 0, 0);
        timing_cache = (uint64_t)v31;
      }
      if (!hash_table_modify(v31, v2, v4, 0)) {
        goto LABEL_55;
      }
      goto LABEL_52;
    }
    if (v25 == @"forwards")
    {
LABEL_29:
      v20 |= 2u;
      goto LABEL_35;
    }
    if (v25 != @"backwards")
    {
      if (v25 != @"both")
      {
        if (([(__CFString *)v25 isEqualToString:@"forwards"] & 1) != 0
          || [(__CFString *)v26 isEqualToString:@"frozen"])
        {
          goto LABEL_29;
        }
        if ([(__CFString *)v26 isEqualToString:@"backwards"]) {
          goto LABEL_31;
        }
        if (([(__CFString *)v26 isEqualToString:@"both"] & 1) == 0
          && ![(__CFString *)v26 isEqualToString:@"extended"])
        {
          goto LABEL_35;
        }
      }
      v20 |= 6u;
      goto LABEL_35;
    }
LABEL_31:
    v20 |= 4u;
    goto LABEL_35;
  }
  return 0;
}

uint64_t hash_table_modify(int *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = (*((uint64_t (**)(uint64_t))a1 + 4))(a2);
  double v9 = *(void **)(*((void *)a1 + 2) + 8 * (*((void *)a1 + 1) & v8));
  if (!v9)
  {
LABEL_5:
    int v10 = *a1;
    if (*a1 > 0x1E || *((void *)a1 + 3) + 1 <= (unint64_t)(4 << *a1)) {
      goto LABEL_37;
    }
    float v12 = (void *)*((void *)a1 + 2);
    *a1 = v10 + 1;
    uint64_t v13 = (uint64_t *)*((void *)a1 + 8);
    if (v13)
    {
      if ((2 << v10) < 0x101)
      {
        double v24 = (void *)x_heap_malloc_small_(*((uint64_t **)a1 + 8), 8 * (2 << v10));
        if (!v24)
        {
          int v23 = *a1;
LABEL_36:
          *a1 = v23 - 1;
LABEL_37:
          int v32 = (uint64_t *)*((void *)a1 + 9);
          if (v32)
          {
            int v33 = (uint64_t *)v32[1];
            if (v33)
            {
              v32[1] = *v33;
            }
            else
            {
              uint64_t v35 = v32[2];
              uint64_t v36 = *((int *)v32 + 6);
              size_t v37 = v35 * v36 + 8;
              int v38 = (uint64_t *)v32[4];
              if (v38)
              {
                uint64_t v39 = x_heap_malloc(v38, v35 * v36 + 8);
              }
              else
              {
                malloc_zone = (malloc_zone_t *)get_malloc_zone();
                uint64_t v39 = (uint64_t)malloc_type_zone_malloc(malloc_zone, v37, 0x81ECB6CuLL);
              }
              mach_error_t v41 = (void *)v39;
              if (v39)
              {
                int v33 = (uint64_t *)(v39 + 8);
                int v42 = *((_DWORD *)v32 + 6);
                int v43 = v41 + 1;
                if (v42 >= 2)
                {
                  uint64_t v44 = v32[2];
                  int v45 = v42 - 1;
                  uint64_t v46 = v41 + 1;
                  do
                  {
                    int v43 = (void *)((char *)v46 + v44);
                    *uint64_t v46 = (char *)v46 + v44;
                    uint64_t v46 = (void *)((char *)v46 + v44);
                    --v45;
                  }
                  while (v45);
                }
                uint64_t v47 = *v32;
                *int v43 = v32[1];
                v32[1] = v41[1];
                *mach_error_t v41 = v47;
                *int v32 = (uint64_t)v41;
              }
              else
              {
                int v33 = 0;
              }
            }
          }
          else
          {
            mach_port_name_t v34 = (malloc_zone_t *)get_malloc_zone();
            int v33 = (uint64_t *)malloc_type_zone_malloc(v34, 0x20uLL, 0x8BB15036uLL);
          }
          v33[2] = a2;
          v33[3] = a3;
          uint64_t v48 = *((void *)a1 + 2);
          uint64_t v49 = *((void *)a1 + 1) & v8;
          *int v33 = *(void *)(v48 + 8 * v49);
          v33[1] = v8;
          *(void *)(v48 + 8 * v49) = v33;
          ++*((void *)a1 + 3);
          return 1;
        }
        double v14 = v24;
        bzero(v24, 8 * (2 << v10));
        int v23 = *a1;
LABEL_24:
        uint64_t v25 = 0;
        uint64_t v26 = ~(-1 << v23);
        *((void *)a1 + 1) = v26;
        do
        {
          BOOL v27 = (void *)v12[v25];
          if (v27)
          {
            do
            {
              long long v28 = (void *)*v27;
              uint64_t v29 = v27[1] & v26;
              *BOOL v27 = v14[v29];
              v14[v29] = v27;
              BOOL v27 = v28;
            }
            while (v28);
          }
          ++v25;
        }
        while (v25 != 1 << v10);
        *((void *)a1 + 2) = v14;
        if (!*((void *)a1 + 8))
        {
          int v30 = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(v30, v12);
        }
        goto LABEL_37;
      }
      double v14 = malloc_type_calloc(1uLL, 8 * (2 << v10), 0x9DF21B1EuLL);
      uint64_t v15 = *v13;
      float v16 = (malloc_zone_t *)get_malloc_zone();
      double v17 = malloc_type_zone_malloc(v16, 0x10uLL, 0x8BB15036uLL);
      void *v17 = v14;
      v17[1] = v15;
      *uint64_t v13 = (uint64_t)v17;
    }
    else
    {
      double v22 = (malloc_zone_t *)get_malloc_zone();
      double v14 = malloc_type_zone_calloc(v22, 1uLL, 8 * (2 << v10), 0x743898A5uLL);
    }
    int v23 = *a1;
    if (!v14) {
      goto LABEL_36;
    }
    goto LABEL_24;
  }
  while (v9[1] != v8 || (*((unsigned int (**)(void, uint64_t))a1 + 5))(v9[2], a2))
  {
    double v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v18 = v9[3];
  int v19 = (void (*)(uint64_t))*((void *)a1 + 6);
  if (a4)
  {
    if (v19) {
      v19(v9[2]);
    }
    int v20 = (void (*)(uint64_t))*((void *)a1 + 7);
    if (v20) {
      v20(v18);
    }
    uint64_t result = 0;
    _DWORD v9[2] = a2;
    v9[3] = a3;
  }
  else
  {
    if (v19) {
      v19(a2);
    }
    unint64_t v31 = (void (*)(uint64_t))*((void *)a1 + 7);
    if (v31) {
      v31(v18);
    }
    uint64_t result = 0;
    v9[3] = a3;
  }
  return result;
}

void CAAnimation_getter(CA::Transaction *a1, int a2, const CGAffineTransform *a3, CA::Mat4Impl *this)
{
  uint64_t v8 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (!v8) {
    uint64_t v8 = (CA::Transaction *)CA::Transaction::create(a1);
  }
  int v9 = *((_DWORD *)v8 + 25);
  *((_DWORD *)v8 + 25) = v9 + 1;
  if (!v9) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  uint64_t v10 = *((void *)a1 + 1);
  if (v10)
  {
    char v11 = CA::AttrList::get(v10, a2, a3, this);
    CA::Transaction::unlock(v8);
    if (v11) {
      return;
    }
  }
  else
  {
    CA::Transaction::unlock(v8);
  }
  Class = object_getClass(a1);

  CAObject_defaultValueForAtom(Class, a2, a3, (uint64_t)this);
}

CALayer *CA::Layer::presentation_layer(CA::Layer *this, CA::Transaction::Shared **a2)
{
  v22[1] = *MEMORY[0x1E4F143B8];
  do
  {
    uint64_t v3 = this;
    this = CA::Layer::model_layer(this, (CA::Transaction *)a2);
  }
  while (this != v3 && this);
  if ((*((_DWORD *)v3 + 1) & 0x4000) == 0) {
    return 0;
  }
  double v5 = a2[13];
  int v6 = *((_DWORD *)a2 + 25);
  *((_DWORD *)a2 + 25) = v6 + 1;
  if (!v6) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  uint64_t v7 = *((void *)v5 + 27);
  if (!v7 || (uint64_t v4 = (CALayer *)x_hash_table_lookup(v7, (uint64_t)v3, 0)) == 0)
  {
    uint64_t v8 = (CALayer *)*((void *)v3 + 2);
    uint64_t v4 = (CALayer *)objc_alloc((Class)objc_opt_class());
    if (v4)
    {
      int v9 = *((_DWORD *)v3 + 1);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      char v11 = (atomic_uint *)malloc_type_zone_malloc(malloc_zone, 0x128uLL, 0x8BB15036uLL);
      float v12 = v11;
      if (v11)
      {
        if ((v9 & 0x100000) != 0) {
          uint64_t v13 = (CA::Layer *)((char *)v3 + 152);
        }
        else {
          uint64_t v13 = (CA::Layer *)((char *)v3 + 40);
        }
        *(void *)char v11 = 0;
        *((void *)v11 + 1) = 0;
        *((void *)v11 + 3) = 0;
        *((void *)v11 + 4) = 0;
        *((void *)v11 + 2) = v4;
        CA::Layer::State::State((CA::Layer::State *)(v11 + 10), v13, (CA::Transaction *)a2);
        *((void *)v12 + 19) = 0;
        *((void *)v12 + 20) = 0;
        v12[44] = 0;
        *((void *)v12 + 21) = 0;
        *(_OWORD *)(v12 + 46) = 0u;
        *(_OWORD *)(v12 + 50) = 0u;
        *(_OWORD *)(v12 + 54) = 0u;
        *(_OWORD *)(v12 + 58) = 0u;
        *((unsigned char *)v12 + 248) = 0;
        *((void *)v12 + 32) = 0;
        *((void *)v12 + 33) = 0;
        *((void *)v12 + 35) = 0;
        *((void *)v12 + 36) = 0;
        *float v12 = 1;
        v12[1] = v9 & 0xFFEDFFFF | 0x20000;
        *((void *)v12 + 34) = 0;
        v4->_attr.layer = v12;
      }
      CA::Layer::set_model_layer((CA::Layer *)v12, (CA::Transaction *)a2, v3);
      uint64_t v4 = [(CALayer *)v4 initWithLayer:v8];
      if (v4)
      {
        CA::Layer::apply_modifiers_to_layer(*((CA::Layer **)v3 + 36), v4);
        double v14 = (uint64_t **)*((void *)v3 + 35);
        if (v14)
        {
          CA::Transaction::Shared::time(a2[13]);
          v22[0] = v15;
          if (CA::Layer::convert_time((CA::Layer *)a2, (CA::Transaction *)v22, 0, v8, v16))
          {
            double v17 = *(double *)v22;
            do
            {
              if (((_WORD)v14[7] & 0x802) == 2) {
                [v14[1] applyForTime:v4 presentationObject:v8 modelObject:v17];
              }
              double v14 = (uint64_t **)*v14;
            }
            while (v14);
          }
          atomic_fetch_or(v12 + 1, 0x8000u);
        }
        if (!*(_DWORD *)a2[13]) {
          CA::Transaction::ensure_implicit((CA::Transaction *)a2, 1);
        }
        uint64_t v18 = (int *)*((void *)v5 + 27);
        if (!v18)
        {
          int v20 = (uint64_t *)*((void *)v5 + 16);
          uint64_t v19 = *((void *)v5 + 17);
          if (!v19)
          {
            uint64_t v19 = x_pool_new_(*((uint64_t **)v5 + 16));
            *((void *)v5 + 17) = v19;
          }
          uint64_t v18 = (int *)x_hash_table_new_(0, 0, 0, 0, v20, v19);
          *((void *)v5 + 27) = v18;
        }
        hash_table_modify(v18, (uint64_t)v3, (uint64_t)v4, 0);
      }
    }
  }
  CA::Transaction::unlock((CA::Transaction *)a2);
  return v4;
}

void sub_184702CF4(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Layer::set_mask(CA::Layer ***this, CALayer *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  double v5 = (unsigned int *)CA::Transaction::ensure_compat((CA::Transaction *)this);
  if ((*((_DWORD *)this + 1) & 0x60000) != 0) {
    [MEMORY[0x1E4F1CA00] raise:@"CALayerInvalidTree", @"expecting model layer not copy: %@", this[2] format];
  }
  if (this[4] != (CA::Layer **)a2)
  {
    unsigned int v6 = v5[25];
    v5[25] = v6 + 1;
    if (v6)
    {
      if (!a2) {
        goto LABEL_15;
      }
    }
    else
    {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
      if (!a2)
      {
LABEL_15:
        v19.isa = 0;
        CA::Layer::begin_change((CA::Layer *)this, (CA::Transaction *)v5, @"mask", &v19, v4);
        int v14 = CA::Layer::ancestor_context_id((CA::Layer *)this, (CA::Transaction *)v5);
        uint64_t v15 = this[4];
        if (v15) {
          CA::Layer::update_removed_sublayer(v15[2], (CA::Transaction *)v5, v14);
        }
        if (a2)
        {
          CA::Layer::update_added_sublayer((CA::Layer *)a2->_attr.layer, (CA::Transaction *)v5, (CA::Layer *)this, v14);
          layer = (CA::Layer *)a2->_attr.layer;
          uint64_t v17 = v5[24];
          if ((v17 & 0x80000000) != 0 || (int v18 = *((_DWORD *)layer + v17 + 68)) == 0) {
            int v18 = *CA::Layer::thread_flags_(layer, (CA::Transaction *)v5);
          }
          CA::Layer::update_for_changed_sublayers((atomic_uint *)this, (CA::Transaction *)v5, v18);
        }
        this[4] = &a2->super.isa;
        CA::Layer::end_change((id *)this, (CA::Transaction *)v5, 376, (objc_object *)@"mask", (objc_object *)v19.isa);
        CA::Transaction::unlock((CA::Transaction *)v5);
        if (v15)
        {
          CA::Transaction::release_object((CA::Transaction *)v5, v15);
        }
        return;
      }
    }
    uint64_t v7 = (CA::Layer *)CA::Layer::retain_parent((CA::Layer *)a2->_attr.layer, (CA::Transaction *)v5);
    if (v7)
    {
      uint64_t v10 = (atomic_uint *)v7;
      CA::Layer::remove_sublayer(v7, (CA::Transaction *)v5, a2, v8, v9);
      while (1)
      {
        atomic_uint v11 = *v10;
        if (!*v10) {
          break;
        }
        atomic_uint v12 = *v10;
        atomic_compare_exchange_strong(v10, (unsigned int *)&v12, v11 - 1);
        if (v12 == v11)
        {
          if (v11 == 1)
          {
            CA::Layer::destroy((CA::Layer *)v10);
            CA::Layer::~Layer((CA::AttrList **)v10);
            malloc_zone = (malloc_zone_t *)get_malloc_zone();
            malloc_zone_free(malloc_zone, v10);
          }
          goto LABEL_15;
        }
      }
    }
    else
    {
      CFRetain(a2);
      CA::Layer::remove_from_context((CA::Layer *)a2->_attr.layer);
    }
    goto LABEL_15;
  }
}

void sub_184703030(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t x_string_hash(unsigned char *a1)
{
  char v1 = *a1;
  if (!*a1) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v4 = a1 + 1;
  do
  {
    uint64_t result = 33 * result + v1;
    int v5 = *v4++;
    char v1 = v5;
  }
  while (v5);
  return result;
}

BOOL x_pointer_compare(uint64_t a1, uint64_t a2)
{
  return a1 != a2;
}

uint64_t CA::Layer::apply_modifiers_to_layer(CA::Layer *this, CALayer *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t result = [(CA::Layer *)this countByEnumeratingWithState:&v12 objects:v11 count:16];
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)v13;
    do
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v13 != v6) {
          objc_enumerationMutation(this);
        }
        uint64_t v8 = *(void **)(*((void *)&v12 + 1) + 8 * v7);
        uint64_t v9 = [v8 value];
        uint64_t v10 = [v8 keyPath];
        if ([v8 additive]) {
          uint64_t v9 = objc_msgSend(-[CALayer valueForKeyPath:](a2, "valueForKeyPath:", v10), "CA_addValue:multipliedBy:", v9, 1);
        }
        [(CALayer *)a2 setValue:v9 forKeyPath:v10];
        ++v7;
      }
      while (v5 != v7);
      uint64_t result = [(CA::Layer *)this countByEnumeratingWithState:&v12 objects:v11 count:16];
      uint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

uint64_t CA::Layer::set_model_layer(CA::Layer *this, CA::Transaction *a2, CA::Layer *a3)
{
  uint64_t v6 = *((unsigned int *)a2 + 24);
  if ((v6 & 0x80000000) != 0 || !*((_DWORD *)a3 + v6 + 68)) {
    CA::Layer::thread_flags_(a3, a2);
  }
  uint64_t v7 = *((void *)a2 + 13);
  uint64_t v8 = *(int **)(v7 + 224);
  if (!v8)
  {
    uint64_t v10 = *(uint64_t **)(v7 + 128);
    uint64_t v9 = *(void *)(v7 + 136);
    if (!v9)
    {
      uint64_t v9 = x_pool_new_(*(uint64_t **)(v7 + 128));
      *(void *)(v7 + 136) = v9;
    }
    uint64_t v8 = (int *)x_hash_table_new_(0, 0, 0, 0, v10, v9);
    *(void *)(v7 + 224) = v8;
  }

  return hash_table_modify(v8, (uint64_t)this, (uint64_t)a3, 0);
}

void CA::Transaction::Shared::time(CA::Transaction::Shared *this)
{
  if (*((double *)this + 18) == 0.0)
  {
    uint64_t v2 = mach_absolute_time();
    *((double *)this + 18) = CATimeWithHostTime(v2);
  }
}

uint64_t CAObject_validateArrayOfClass(void *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  uint64_t v2 = [a1 countByEnumeratingWithState:&v8 objects:v7 count:16];
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = *(void *)v9;
LABEL_4:
    uint64_t v5 = 0;
    while (1)
    {
      if (*(void *)v9 != v4) {
        objc_enumerationMutation(a1);
      }
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        return 0;
      }
      if (v3 == ++v5)
      {
        uint64_t v3 = [a1 countByEnumeratingWithState:&v8 objects:v7 count:16];
        uint64_t result = 1;
        if (v3) {
          goto LABEL_4;
        }
        return result;
      }
    }
  }
  return 1;
}

uint64_t x_pool_new_(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = x_heap_malloc_small_(a1, 0x28uLL);
    *(_OWORD *)uint64_t v2 = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(void *)(v2 + 32) = a1;
  }
  else
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v2 = (uint64_t)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x28uLL, 0xB6D46EB3uLL);
  }
  if (!pool_construct(x_pool_struct *,unsigned long)::choices)
  {
    pool_construct(x_pool_struct *,unsigned long)::choices = malloc_good_size(0x3F0uLL) - 8;
    pool_construct(x_pool_struct *,unsigned long)::choices = malloc_good_size(0x7F0uLL) - 8;
    malloc_good_size(0xBF0uLL);
    malloc_good_size(0xFF0uLL);
  }
  *(void *)(v2 + 16) = 32;
  *(_DWORD *)(v2 + 24) = (unint64_t)pool_construct(x_pool_struct *,unsigned long)::choices >> 5;
  return v2;
}

BOOL CA::ColorMatrix::is_alpha_identity(CA::ColorMatrix *this)
{
  return *((float *)this + 3) == 0.0
      && *((float *)this + 8) == 0.0
      && *((float *)this + 13) == 0.0
      && *((float *)this + 15) == 0.0
      && *((float *)this + 16) == 0.0
      && *((float *)this + 17) == 0.0
      && *((float *)this + 18) == 1.0
      && *((float *)this + 19) == 0.0;
}

atomic_uint *CA::Render::Layer::set_sublayers(uint64_t a1, atomic_uint *a2)
{
  uint64_t v2 = a2;
  int v4 = *(_DWORD *)(a1 + 12);
  uint64_t result = *(atomic_uint **)(a1 + 104);
  if ((v4 & 0x2000) == 0)
  {
    if (result == a2) {
      return result;
    }
    if (result && atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      uint64_t result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
    }
    if (!v2) {
      goto LABEL_15;
    }
    goto LABEL_13;
  }
  if (result)
  {
    if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      uint64_t result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
    }
    int v4 = *(_DWORD *)(a1 + 12);
  }
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 12) = v4 & 0xFFFFDFFF;
  if (v2)
  {
LABEL_13:
    uint64_t v6 = v2 + 2;
    if (!atomic_fetch_add(v2 + 2, 1u))
    {
      uint64_t v2 = 0;
      atomic_fetch_add(v6, 0xFFFFFFFF);
    }
LABEL_15:
    *(void *)(a1 + 104) = v2;
  }
  return result;
}

uint64_t CA::OGL::VariableBlurFilter::filter_flags(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (CA::OGL::BlurFilter::needs_dither(*(CA::Render::KeyValueArray **)(a2 + 40), a3)) {
    int v4 = 14;
  }
  else {
    int v4 = 6;
  }
  int int_key = CA::Render::KeyValueArray::get_int_key(*(CA::Render::KeyValueArray **)(a2 + 40), 305, 0);
  unsigned int v6 = v4 | (int_key == 0);
  if (int_key) {
    return v6 | 0x10;
  }
  else {
    return v6;
  }
}

uint64_t CA::OGL::GaussianBlurFilter::filter_flags(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v14[1] = *(double *)MEMORY[0x1E4F143B8];
  if (CA::OGL::BlurFilter::needs_dither(*(CA::Render::KeyValueArray **)(a2 + 40), a3)) {
    unsigned int v5 = 14;
  }
  else {
    unsigned int v5 = 6;
  }
  unsigned int v6 = *(CA::Render::KeyValueArray **)(a2 + 40);
  if (!CA::Render::KeyValueArray::get_int_key(v6, 305, 0)) {
    return v5 | (CA::Render::KeyValueArray::get_int_key(v6, 300, 0) == 0);
  }
  double v13 = 0.0;
  v14[0] = 0.0;
  if ((*(unsigned char *)(a3 + 288) & 0x10) != 0)
  {
    CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)(a3 + 144), v14, &v13, v7);
    double v8 = v13;
    double v9 = v14[0];
  }
  else
  {
    double v8 = *(double *)(a3 + 272);
    double v13 = v8;
    v14[0] = v8;
    double v9 = v8;
  }
  if (v9 >= v8) {
    double v11 = v8;
  }
  else {
    double v11 = v9;
  }
  float v12 = v11 * CA::Render::KeyValueArray::get_float_key(v6, 310, 0.0);
  if (v12 <= 0.35) {
    return v5;
  }
  else {
    return v5 | 0x10;
  }
}

uint64_t CA::OGL::BlurFilter::needs_dither(CA::Render::KeyValueArray *a1, uint64_t a2)
{
  uint64_t result = CA::Render::KeyValueArray::get_int_key(a1, 292, 0);
  if (result)
  {
    double float_key = CA::Render::KeyValueArray::get_float_key(a1, 310, 0.0);
    if ((*(unsigned char *)(a2 + 288) & 0x10) != 0) {
      double scale = CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)(a2 + 144), 0, 0, v5);
    }
    else {
      double scale = *(double *)(a2 + 272);
    }
    return scale * float_key > 4.0;
  }
  return result;
}

uint64_t ___ZL26enable_frame_rate_featuresv_block_invoke()
{
  uint64_t result = CADeviceSupportsOddQuantaFrameRates();
  if (result)
  {
    uint64_t result = os_variant_has_factory_content();
    char v1 = result ^ 1;
  }
  else
  {
    char v1 = 0;
  }
  enable_frame_rate_features(void)::enabled = v1;
  return result;
}

void ___Z16CAPrefers60HzAPTv_block_invoke()
{
  if (enable_frame_rate_features(void)::once != -1) {
    dispatch_once(&enable_frame_rate_features(void)::once, &__block_literal_global_9);
  }
  if (enable_frame_rate_features(void)::enabled) {
    BOOL v0 = CADevicePrefers60HzAPT();
  }
  else {
    BOOL v0 = 0;
  }
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  char v1 = *(float *)&dword_1EB2ACB64 == 1 || v0;
  if (*(float *)&dword_1EB2ACB64 == 2) {
    char v2 = 0;
  }
  else {
    char v2 = v1;
  }
  CAPrefers60HzAPT(void)::enabled = v2;
}

CA::Display::DisplayLink *CA::Display::DisplayLinkItem::set_reasons(CA::Display::DisplayLinkItem *this, const unsigned int *a2, unsigned int a3)
{
  __s2[2] = *MEMORY[0x1E4F143B8];
  if (a3 >= 4) {
    uint64_t v4 = 4;
  }
  else {
    uint64_t v4 = a3;
  }
  size_t v5 = (4 * v4);
  __s2[0] = 0;
  __s2[1] = 0;
  if (v4)
  {
    unsigned int v6 = 0;
    do
    {
      int v8 = *a2++;
      int v7 = v8;
      if (v8) {
        *((_DWORD *)__s2 + v6++) = v7;
      }
      --v4;
    }
    while (v4);
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  if (!memcmp((char *)this + 88, __s2, v5) || (memcpy((char *)this + 88, __s2, v5), (*((unsigned char *)this + 316) & 1) != 0))
  {
    return (CA::Display::DisplayLink *)pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 136));
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 2);
    CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, (const unsigned int *)this + 22, 4u);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 136));
    int v9 = *((_DWORD *)this + 19);
    int v10 = *((_DWORD *)this + 20);
    int v11 = *((_DWORD *)this + 21);
    return CA::Display::DisplayLinkItem::set_preferred_fps_range((CA::Display::DisplayLink **)this, *(CAFrameRateRange *)&v9, 1, 1);
  }
}

void sub_184704894(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Display::DisplayTimingsControl::register_frame_interval_reasons(CA::Display::DisplayTimingsControl *this, uint64_t a2, const unsigned int *a3, unsigned int a4)
{
  mach_msg_return_t v41;
  long long v42;
  mach_msg_header_t buf;
  int v44;
  long long *v45;
  int v46;
  int v47;
  uint64_t v48;
  int v49;
  pid_t v50;
  int v51;
  uint64_t v52;

  uint64_t v52 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 233) & 2) != 0)
  {
    int v8 = (os_unfair_lock_s *)((char *)this + 136);
    os_unfair_lock_lock((os_unfair_lock_t)this + 34);
    int v9 = (char *)*((void *)this + 20);
    int v10 = (char *)*((void *)this + 21);
    int v11 = v9;
    if (v9 != v10)
    {
      int v11 = (char *)*((void *)this + 20);
      while (*(void *)v11 != a2)
      {
        v11 += 24;
        if (v11 == v10) {
          goto LABEL_17;
        }
      }
    }
    if (v11 != v10)
    {
      if (!a4) {
        goto LABEL_40;
      }
      goto LABEL_9;
    }
LABEL_17:
    unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v9) >> 3);
    if (v18 < 8)
    {
      if (a4 && *a3)
      {
        unint64_t v19 = *((void *)this + 22);
        if ((unint64_t)v10 >= v19)
        {
          unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - (void)v9) >> 3);
          if (2 * v22 <= v18 + 1) {
            uint64_t v23 = v18 + 1;
          }
          else {
            uint64_t v23 = 2 * v22;
          }
          if (v22 >= 0x555555555555555) {
            unint64_t v24 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v24 = v23;
          }
          if (v24 > 0xAAAAAAAAAAAAAAALL) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v25 = (char *)operator new(24 * v24);
          uint64_t v26 = &v25[8 * ((v10 - v9) >> 3)];
          *((void *)v26 + 1) = 0;
          *((void *)v26 + 2) = 0;
          BOOL v27 = &v25[24 * v24];
          *(void *)uint64_t v26 = a2;
          uint64_t v20 = v26 + 24;
          if (v9 == v10)
          {
            uint64_t v29 = &v25[8 * ((v10 - v9) >> 3)];
          }
          else
          {
            do
            {
              long long v28 = *(_OWORD *)(v10 - 24);
              uint64_t v29 = v26 - 24;
              *((void *)v26 - 1) = *((void *)v10 - 1);
              *(_OWORD *)(v26 - 24) = v28;
              v10 -= 24;
              v26 -= 24;
            }
            while (v10 != v9);
          }
          *((void *)this + 20) = v29;
          *((void *)this + 21) = v20;
          *((void *)this + 22) = v27;
          if (v9) {
            operator delete(v9);
          }
        }
        else
        {
          *((void *)v10 + 1) = 0;
          *((void *)v10 + 2) = 0;
          uint64_t v20 = v10 + 24;
          *(void *)int v10 = a2;
        }
        *((void *)this + 21) = v20;
        int v11 = v20 - 24;
        int v10 = v20;
LABEL_9:
        if (*a3)
        {
          uint64_t v12 = 0;
          *((void *)v11 + 1) = 0;
          *((void *)v11 + 2) = 0;
          if (a4 >= 4) {
            uint64_t v13 = 4;
          }
          else {
            uint64_t v13 = a4;
          }
          do
          {
            int v15 = *a3++;
            int v14 = v15;
            if (v15)
            {
              uint64_t v16 = &v11[4 * v12++];
              *((_DWORD *)v16 + 2) = v14;
            }
            --v13;
          }
          while (v13);
          uint64_t v17 = (char *)*((void *)this + 21);
LABEL_43:
          int v42 = 0uLL;
          int v30 = (char *)*((void *)this + 20);
          if (v30 == v17)
          {
            int v31 = 0;
          }
          else
          {
            int v31 = 0;
            do
            {
              uint64_t v32 = 0;
              int v33 = v31;
              do
              {
                int v34 = *(_DWORD *)&v30[4 * v32 + 8];
                if (v34) {
                  BOOL v35 = v31 + v32 == 4;
                }
                else {
                  BOOL v35 = 1;
                }
                if (v35) {
                  break;
                }
                *((_DWORD *)&v42 + (v31 + v32++)) = v34;
              }
              while (v32 != 4);
              v31 += v32;
              if (v33 + v32 == 4) {
                break;
              }
              v30 += 24;
            }
            while (v30 != v17);
          }
          if (*(void *)((char *)this + 140) != (void)v42
            || *(void *)((char *)this + 148) != *((void *)&v42 + 1))
          {
            *(_OWORD *)((char *)this + 140) = v42;
            mach_port_t ServerPort = CARenderServerGetServerPort(0);
            int v38 = *((_DWORD *)this + 2);
            pid_t v39 = getpid();
            uint64_t v44 = 1;
            int v45 = &v42;
            uint64_t v46 = 16777472;
            uint64_t v47 = 4 * v31;
            uint64_t v48 = *MEMORY[0x1E4F14068];
            uint64_t v49 = v38;
            uint64_t v50 = v39;
            uint64_t v51 = v31;
            mach_port_t reply_port = mig_get_reply_port();
            *(void *)&buf.uint64_t msgh_bits = 2147489043;
            buf.mach_port_t msgh_remote_port = ServerPort;
            buf.mach_port_t msgh_local_port = reply_port;
            *(void *)&buf.uint64_t msgh_voucher_port = 0x9D5800000000;
            if (MEMORY[0x1E4F14B18])
            {
              voucher_mach_msg_set(&buf);
              mach_port_t reply_port = buf.msgh_local_port;
            }
            mach_error_t v41 = mach_msg(&buf, 3, 0x40u, 0x2Cu, reply_port, 0, 0);
            if ((v41 - 268435458) <= 0xE && ((1 << (v41 - 2)) & 0x4003) != 0)
            {
              mig_put_reply_port(buf.msgh_local_port);
            }
            else if (v41)
            {
              mig_dealloc_reply_port(buf.msgh_local_port);
            }
            else if (buf.msgh_id != 40380 {
                   || (buf.msgh_bits & 0x80000000) != 0
            }
                   || buf.msgh_size != 36
                   || buf.msgh_remote_port
                   || HIDWORD(v45))
            {
              mach_msg_destroy(&buf);
            }
          }
          goto LABEL_72;
        }
LABEL_40:
        if (v10 != v11 + 24) {
          memmove(v11, v11 + 24, v10 - (v11 + 24));
        }
        uint64_t v17 = v10 - 24;
        *((void *)this + 21) = v10 - 24;
        goto LABEL_43;
      }
    }
    else if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      double v21 = x_log_category_windowserver;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.msgh_bits) = 0;
        _os_log_impl(&dword_184668000, v21, OS_LOG_TYPE_DEFAULT, "CADisplayTimingsControl too many reasons.", (uint8_t *)&buf, 2u);
      }
    }
LABEL_72:
    os_unfair_lock_unlock(v8);
  }
}

void sub_184704DA8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Display::DisplayTimingsControl::unregister_frame_interval_range(os_unfair_lock_s *this, CAFrameIntervalRange a2)
{
  if ((this[58]._os_unfair_lock_opaque & 0x200) != 0)
  {
    unsigned int var2 = a2.var2;
    uint64_t v3 = *(void *)&a2.var0;
    size_t v5 = this + 23;
    os_unfair_lock_lock(this + 23);
    v14.unsigned int var2 = var2;
    *(void *)&v14.var0 = v3;
    CA::Display::DisplayTimingsControl::_unregister_frame_interval_range((CA::Display::DisplayTimingsControl *)this, v14);
    CA::Display::DisplayTimingsControl::update_frame_interval_request((CA::Display::DisplayTimingsControl *)this, v6, v7, v8, v9, v10, v11, v12);
    os_unfair_lock_unlock(v5);
  }
}

void sub_184704E40(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Display::DisplayTimingsControl::_unregister_frame_interval_range(CA::Display::DisplayTimingsControl *this, CAFrameIntervalRange a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a2.var0)
  {
    uint64_t v4 = (_DWORD *)*((void *)this + 14);
    uint64_t v3 = (char *)*((void *)this + 15);
    if (v4 != (_DWORD *)v3)
    {
      unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v3 - (char *)v4) >> 2);
      do
      {
        unint64_t v6 = v5 >> 1;
        uint64_t v7 = &v4[3 * (v5 >> 1)];
        if (*v7 < a2.var0
          || *v7 == a2.var0 && ((unsigned int v8 = v4[3 * v6 + 1], v8 < a2.var1) || v8 == a2.var1 && v4[3 * v6 + 2] < a2.var2))
        {
          unint64_t v6 = v5 + ~v6;
          uint64_t v4 = v7 + 3;
        }
        unint64_t v5 = v6;
      }
      while (v6);
      if (v4 != (_DWORD *)v3 && *v4 == a2.var0 && *(void *)(v4 + 1) == *(void *)&a2.var1)
      {
        int64_t v9 = v3 - (char *)(v4 + 3);
        if (v3 != (char *)(v4 + 3)) {
          memmove(v4, v4 + 3, v3 - (char *)(v4 + 3));
        }
        *((void *)this + 15) = (char *)v4 + v9;
      }
    }
  }
  else if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    uint64_t v10 = x_log_category_windowserver;
    if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
    {
      __int16 v11 = 0;
      _os_log_impl(&dword_184668000, v10, OS_LOG_TYPE_ERROR, "CAFrameIntervalRange.minimum = 0 should not be unregistered.", (uint8_t *)&v11, 2u);
    }
  }
}

void CA::Display::DisplayTimingsControl::register_frame_interval_range(os_unfair_lock_s *this, CAFrameIntervalRange a2)
{
  if ((this[58]._os_unfair_lock_opaque & 0x200) != 0)
  {
    unsigned int var2 = a2.var2;
    uint64_t v3 = *(void *)&a2.var0;
    unint64_t v5 = this + 23;
    os_unfair_lock_lock(this + 23);
    v14.unsigned int var2 = var2;
    *(void *)&v14.var0 = v3;
    CA::Display::DisplayTimingsControl::_register_frame_interval_range((CA::Display::DisplayTimingsControl *)this, v14);
    CA::Display::DisplayTimingsControl::update_frame_interval_request((CA::Display::DisplayTimingsControl *)this, v6, v7, v8, v9, v10, v11, v12);
    os_unfair_lock_unlock(v5);
  }
}

void sub_18470508C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Display::DisplayTimingsControl::update_frame_interval_request(CA::Display::DisplayTimingsControl *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_msg_return_t v28;
  NSObject *v29;
  NSObject *v30;
  long long msg;
  long long msg_16;
  int v33;
  pid_t v34;
  int v35;
  int v36;
  int v37;
  char v38;
  __int16 v39;
  char v40;
  uint64_t v41;

  mach_error_t v41 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = CA::FrameRateArbitrator::arbitrate((uint64_t)this + 112, (uint64_t)"CAFrameRateClient: ", a3, a4, a5, a6, a7, a8);
  int v11 = v10;
  unint64_t v12 = HIDWORD(v9);
  if (CADeviceSupportsOddQuantaFrameRates())
  {
    BOOL v13 = CADevicePrefers60HzAPT();
    int v14 = v9 ? 2 : v11;
    unsigned int v15 = v9 ? 2 : HIDWORD(v9);
    int v16 = v9 ? 2 : 0;
    if (v13)
    {
      unint64_t v12 = HIDWORD(v9);
    }
    else
    {
      int v11 = v14;
      unint64_t v12 = v15;
    }
    if (!v13) {
      LODWORD(v9) = v16;
    }
  }
  if (*((_DWORD *)this + 24) != v9 || *((_DWORD *)this + 25) != v12 || *((_DWORD *)this + 26) != v11)
  {
    if (byte_1EB2ACC45)
    {
      if (x_log_hook_p())
      {
        getpid();
        x_log_();
      }
      else
      {
        int v30 = x_log_category_frame_rate;
        if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)&mach_msg_header_t msg = __PAIR64__(getpid(), 67109888);
          WORD4(msg) = 1024;
          *(_DWORD *)((char *)&msg + 10) = v9;
          HIWORD(msg) = 1024;
          LODWORD(msg_16) = v12;
          WORD2(msg_16) = 1024;
          *(_DWORD *)((char *)&msg_16 + 6) = v11;
          _os_log_impl(&dword_184668000, v30, OS_LOG_TYPE_DEFAULT, "CAFrameRateClient: pid %i register to server %u %u %u", (uint8_t *)&msg, 0x1Au);
        }
      }
    }
    *((void *)this + 12) = v9 | (v12 << 32);
    *((_DWORD *)this + 26) = v11;
    char v17 = CA::Display::DisplayTimingsControl::compat_quanta_mode(this);
    if (CADeviceIsAppleBundle::once != -1) {
      dispatch_once(&CADeviceIsAppleBundle::once, &__block_literal_global_345);
    }
    if (!CADeviceIsAppleBundle::apple_bundle)
    {
      unint64_t v18 = (int *)*((void *)this + 14);
      unint64_t v19 = (int *)*((void *)this + 15);
      if (v18 != v19)
      {
        while (1)
        {
          int v20 = *v18;
          BOOL v21 = *v18 == 8 || v20 == 4;
          if (v21 && v20 == v18[1])
          {
            int v22 = v18[2];
            if (v20 == v22 || v22 == 0) {
              break;
            }
          }
          v18 += 3;
          if (v18 == v19)
          {
            unint64_t v18 = (int *)*((void *)this + 15);
            break;
          }
        }
      }
      if (v18 != v19) {
        char v17 = 1;
      }
    }
    unsigned int ServerPort = CARenderServerGetServerPort(0);
    int v25 = *((_DWORD *)this + 2);
    pid_t v26 = getpid();
    *((void *)&msg_16 + 1) = *MEMORY[0x1E4F14068];
    int v33 = v25;
    int v34 = v26;
    BOOL v35 = v9;
    uint64_t v36 = v12;
    size_t v37 = v11;
    int v38 = v17;
    pid_t v39 = 0;
    uint64_t v40 = 0;
    mach_port_t reply_port = mig_get_reply_port();
    *(void *)&mach_msg_header_t msg = 5395;
    *((void *)&msg + 1) = __PAIR64__(reply_port, ServerPort);
    *(void *)&msg_16 = 0x9D5700000000;
    if (MEMORY[0x1E4F14B18])
    {
      voucher_mach_msg_set((mach_msg_header_t *)&msg);
      mach_port_t reply_port = HIDWORD(msg);
    }
    long long v28 = mach_msg((mach_msg_header_t *)&msg, 3, 0x38u, 0x2Cu, reply_port, 0, 0);
    if ((v28 - 268435458) <= 0xE && ((1 << (v28 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(HIDWORD(msg));
      goto LABEL_50;
    }
    if (v28)
    {
      mig_dealloc_reply_port(HIDWORD(msg));
LABEL_50:
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v29 = x_log_category_frame_rate;
        if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_ERROR))
        {
          LOWORD(msg) = 0;
          _os_log_impl(&dword_184668000, v29, OS_LOG_TYPE_ERROR, "CAFrameRateClient: registration failed", (uint8_t *)&msg, 2u);
        }
      }
      return;
    }
    if (DWORD1(msg_16) != 40379 || (msg & 0x80000000) != 0 || *(void *)((char *)&msg + 4) != 36 || v33)
    {
      mach_msg_destroy((mach_msg_header_t *)&msg);
      goto LABEL_50;
    }
  }
}

BOOL CADevicePrefers60HzAPT()
{
  BOOL result = CADeviceSupportsOddQuantaFrameRates();
  if (result)
  {
    if (CADeviceIsPhone::once[0] != -1) {
      dispatch_once(CADeviceIsPhone::once, &__block_literal_global_193);
    }
    if (CADeviceIsPhone::phone)
    {
      if (CADeviceSupportsAPT::once[0] != -1) {
        dispatch_once(CADeviceSupportsAPT::once, &__block_literal_global_52);
      }
      char v1 = &CADeviceSupportsAPT::supports_apt;
    }
    else
    {
      if (CADevicePrefers60HzAPT::once[0] != -1) {
        dispatch_once(CADevicePrefers60HzAPT::once, &__block_literal_global_274);
      }
      char v1 = &CADevicePrefers60HzAPT::enabled;
    }
    return *v1 != 0;
  }
  return result;
}

BOOL CADeviceSupportsOddQuantaFrameRates()
{
  if (CADeviceSupportsOddQuantaFrameRates::once != -1) {
    dispatch_once(&CADeviceSupportsOddQuantaFrameRates::once, &__block_literal_global_265);
  }
  if (CADeviceSupportsOddQuantaFrameRates::enabled) {
    return 1;
  }
  if (CADeviceSupportsAPT::once[0] != -1) {
    dispatch_once(CADeviceSupportsAPT::once, &__block_literal_global_52);
  }
  if (!CADeviceSupportsAPT::supports_apt) {
    return 0;
  }
  if (CADeviceIsPhone::once[0] != -1) {
    dispatch_once(CADeviceIsPhone::once, &__block_literal_global_193);
  }
  return CADeviceIsPhone::phone != 0;
}

uint64_t CARenderServerGetServerPort(char *service_name)
{
  kern_return_t v8;
  uint64_t v9;
  mach_port_t v10;
  const char *v11;
  NSObject *v12;
  uint32_t v13;
  uint64_t v14;
  const char *v15;
  mach_error_t v17;
  char *v18;
  mach_port_t sp;
  const char *v20;
  __int16 v21;
  kern_return_t v22;
  __int16 v23;
  const char *v24;
  uint64_t v25;

  int v25 = *MEMORY[0x1E4F143B8];
  if (force_local_server(void)::once[0] != -1) {
    dispatch_once(force_local_server(void)::once, &__block_literal_global_7691);
  }
  if (!force_local_server(void)::_force_local_server)
  {
    if (service_name)
    {
      mach_port_t v2 = *MEMORY[0x1E4F14638];
      if ((*MEMORY[0x1E4F14638] - 1) > 0xFFFFFFFD) {
        return 0;
      }
      sp = 0;
      if (bootstrap_look_up(v2, service_name, &sp)) {
        return 0;
      }
      else {
        return sp;
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)&_CARenderServerGetCachedDefaultServerPort(void)::default_server_port_lock);
    uint64_t v4 = (unsigned int *)&unk_1EB2AD000;
    if (_CARenderServerGetCachedDefaultServerPort(void)::default_server_port)
    {
      sp = 0;
      unint64_t v5 = (ipc_space_t *)MEMORY[0x1E4F14960];
      mach_error_t v6 = mach_port_type(*MEMORY[0x1E4F14960], _CARenderServerGetCachedDefaultServerPort(void)::default_server_port, &sp);
      if (v6)
      {
        char v17 = v6;
        unint64_t v18 = mach_error_string(v6);
        x_log_crash("Failed to get server port type (%x) - %s", v17, v18);
        abort();
      }
      if ((sp & 0x100000) != 0)
      {
        mach_port_deallocate(*v5, _CARenderServerGetCachedDefaultServerPort(void)::default_server_port);
        _CARenderServerGetCachedDefaultServerPort(void)::default_server_port = 0;
        _CARenderServerGetCachedDefaultServerPort(void)::default_server_port_initialized = 0;
      }
    }
    if (_CARenderServerGetCachedDefaultServerPort(void)::default_server_port_initialized) {
      goto LABEL_14;
    }
    uint64_t v7 = (mach_port_t *)MEMORY[0x1E4F14638];
    if ((*MEMORY[0x1E4F14638] - 1) >= 0xFFFFFFFE)
    {
      if (x_log_hook_p()) {
        goto LABEL_24;
      }
      unint64_t v9 = x_log_category_render;
      if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR)) {
        goto LABEL_30;
      }
      int v10 = *v7;
      sp = 67109120;
      LODWORD(v20) = v10;
      int v11 = "Invalid bootstrap port (%d)";
      unint64_t v12 = v9;
      BOOL v13 = 8;
    }
    else
    {
      if (CADeviceIsSystemSessionClient::once != -1) {
        dispatch_once(&CADeviceIsSystemSessionClient::once, &__block_literal_global_368);
      }
      if (CADeviceIsSystemSessionClient::enabled && xpc_user_sessions_enabled())
      {
        xpc_user_sessions_get_foreground_uid();
        uint64_t v8 = bootstrap_look_up_per_user();
        uint64_t v4 = (_DWORD *)&unk_1EB2AD000;
        if (!v8) {
          goto LABEL_37;
        }
      }
      else
      {
        uint64_t v8 = bootstrap_look_up(*v7, "com.apple.CARenderServer", (mach_port_t *)&_CARenderServerGetCachedDefaultServerPort(void)::default_server_port);
        if (!v8)
        {
LABEL_37:
          _CARenderServerGetCachedDefaultServerPort(void)::default_server_port_initialized = 1;
LABEL_14:
          mach_port_mod_refs(*MEMORY[0x1E4F14960], v4[959], 0, 1);
          uint64_t v3 = v4[959];
LABEL_31:
          os_unfair_lock_unlock((os_unfair_lock_t)&_CARenderServerGetCachedDefaultServerPort(void)::default_server_port_lock);
          return v3;
        }
      }
      if (x_log_hook_p())
      {
        bootstrap_strerror(v8);
LABEL_24:
        x_log_();
LABEL_30:
        uint64_t v3 = 0;
        goto LABEL_31;
      }
      int v14 = x_log_category_render;
      if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR)) {
        goto LABEL_30;
      }
      unsigned int v15 = bootstrap_strerror(v8);
      sp = 136315650;
      int v20 = "com.apple.CARenderServer";
      BOOL v21 = 1024;
      int v22 = v8;
      uint64_t v23 = 2080;
      unint64_t v24 = v15;
      int v11 = "Service \"%s\" failed bootstrap look up (%x) - %s";
      unint64_t v12 = v14;
      BOOL v13 = 28;
    }
    _os_log_impl(&dword_184668000, v12, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&sp, v13);
    goto LABEL_30;
  }
  uint64_t v3 = CA::Render::Server::server_port((CA::Render::Server *)service_name);
  if (v3) {
    mach_port_mod_refs(*MEMORY[0x1E4F14960], v3, 0, 1);
  }
  return v3;
}

void CA::Display::DisplayTimingsControl::_register_frame_interval_range(CA::Display::DisplayTimingsControl *this, CAFrameIntervalRange a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  CAFrameIntervalRange v16 = a2;
  if (!a2.var0)
  {
    if (x_log_hook_p())
    {
LABEL_6:
      x_log_();
      return;
    }
    uint64_t v11 = x_log_category_windowserver;
    if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)buf = 0;
    unint64_t v12 = "CAFrameIntervalRange.minimum = 0 should not be registered.";
    BOOL v13 = v11;
    os_log_type_t v14 = OS_LOG_TYPE_ERROR;
LABEL_24:
    _os_log_impl(&dword_184668000, v13, v14, v12, buf, 2u);
    return;
  }
  uint64_t v4 = (char *)*((void *)this + 14);
  uint64_t v3 = (char *)*((void *)this + 15);
  mach_port_t v2 = (char *)this + 112;
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v3 - v4) >> 2);
  if (v5 >= 0x20)
  {
    if (x_log_hook_p()) {
      goto LABEL_6;
    }
    uint64_t v15 = x_log_category_windowserver;
    if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
    unint64_t v12 = "CADisplayTimingsControl too many requests.";
    BOOL v13 = v15;
    os_log_type_t v14 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_24;
  }
  if (v3 == v4) {
    goto LABEL_19;
  }
  do
  {
    unint64_t v6 = v5 >> 1;
    uint64_t v7 = (unsigned int *)&v4[12 * (v5 >> 1)];
    if (*v7 > a2.var0) {
      goto LABEL_17;
    }
    if (*v7 != a2.var0) {
      goto LABEL_16;
    }
    unsigned int v8 = *(_DWORD *)&v4[12 * v6 + 4];
    if (v8 > a2.var1) {
      goto LABEL_17;
    }
    if (v8 == a2.var1)
    {
      unint64_t v9 = v5 + ~v6;
      int v10 = (char *)(v7 + 3);
      if (*(_DWORD *)&v4[12 * v6 + 8] <= a2.var2)
      {
        uint64_t v4 = v10;
        unint64_t v6 = v9;
      }
    }
    else
    {
LABEL_16:
      uint64_t v4 = (char *)(v7 + 3);
      unint64_t v6 = v5 + ~v6;
    }
LABEL_17:
    unint64_t v5 = v6;
  }
  while (v6);
  uint64_t v3 = v4;
LABEL_19:
  std::vector<CAFrameIntervalRange>::insert((uint64_t)v2, v3, (unint64_t)&v16);
}

uint64_t CA::Render::Server::server_port(CA::Render::Server *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t result = CA::Render::Server::_server_port;
  mach_port_name_t name = CA::Render::Server::_server_port;
  if (!CA::Render::Server::_server_port)
  {
    mach_port_t v2 = (ipc_space_t *)MEMORY[0x1E4F14960];
    mach_port_allocate(*MEMORY[0x1E4F14960], 1u, &name);
    CA::Render::Server::port_set_qlimit(name);
    inserted = (CA::Render::Server *)mach_port_insert_right(*v2, name, name, 0x14u);
    int v4 = 0;
    atomic_compare_exchange_strong(&CA::Render::Server::_server_port, (unsigned int *)&v4, name);
    ipc_space_t v5 = *v2;
    mach_port_name_t v6 = name;
    if (v4)
    {
      mach_port_mod_refs(*v2, name, 1u, -1);
      mach_port_deallocate(*v2, name);
    }
    else
    {
      mach_port_name_t v7 = CA::Render::Server::port_set(inserted);
      mach_port_move_member(v5, v6, v7);
    }
    return CA::Render::Server::_server_port;
  }
  return result;
}

void CA::Render::BasicAnimation0::next_time(uint64_t *a1, void *a2, int a3, uint64_t a4, int a5, double *a6, CA::Render::Layer *a7, float64x2_t *a8, int8x16_t a9, double a10, int8x16_t a11, _DWORD *a12)
{
  int v15 = a4;
  float v16 = *(float *)&a10;
  double v17 = *(double *)a9.i64;
  double v19 = *a6;
  CA::Render::Animation::next_time((uint64_t)a1, a2, a3, a9, a10, a11, a4, a5, a6);
  CA::Render::PropertyAnimation::significant_change_next_time((CA::Render::Animation *)a1, 0, 0, v15, a6, a7, a8, a12, v17, v16, v19, a1[14], a1[15], a1[16]);
}

void CA::Render::Animation::next_time(uint64_t a1, void *a2, int a3, int8x16_t a4, double a5, int8x16_t a6, uint64_t a7, int a8, double *a9)
{
  if (*(float *)&a5 == 0.0) {
    return;
  }
  uint64_t v46 = v21;
  uint64_t v47 = v20;
  uint64_t v48 = v19;
  uint64_t v49 = v18;
  uint64_t v50 = v17;
  uint64_t v51 = v14;
  uint64_t v52 = v13;
  uint64_t v53 = v12;
  uint64_t v54 = v11;
  uint64_t v55 = v10;
  uint64_t v56 = v9;
  float v27 = *(float *)&a5;
  double v28 = *(double *)a4.i64;
  uint64_t v30 = *(void *)(a1 + 40);
  if (v30)
  {
    if (*(float *)(v30 + 16) == 0.0) {
      return;
    }
    double v31 = *(double *)(v30 + 40);
    *(double *)a4.i64 = CA::Render::Timing::end_time((CA::Render::Timing *)v30);
  }
  else
  {
    double v31 = 0.0;
    a4.i64[0] = 0x7FF0000000000000;
  }
  if (v27 >= 0.0) {
    double v32 = v31;
  }
  else {
    double v32 = *(double *)a4.i64;
  }
  BOOL v33 = v32 > v28;
  if (v27 <= 0.0) {
    BOOL v33 = v32 < v28;
  }
  if (v33)
  {
    BOOL v34 = v32 < *a9;
    if (v27 <= 0.0) {
      BOOL v34 = v32 > *a9;
    }
    if (!v34) {
      return;
    }
LABEL_75:
    *a9 = v32;
    return;
  }
  if (v27 < 0.0) {
    *(double *)a4.i64 = v31;
  }
  BOOL v35 = *(double *)a4.i64 > v28;
  if (v27 <= 0.0) {
    BOOL v35 = *(double *)a4.i64 < v28;
  }
  if (v35)
  {
    float v37 = *(float *)(a1 + 28);
    float v36 = *(float *)(a1 + 32);
    if (!a2) {
      goto LABEL_57;
    }
    a4.i32[0] = *(_DWORD *)(a1 + 24);
    uint64_t v38 = *(void *)(a1 + 40);
    if (v38)
    {
      if (*(float *)(v38 + 16) == 0.0) {
        goto LABEL_57;
      }
    }
    if (*(float *)a4.i32 == 0.0 && v37 == 0.0 && v36 == 0.0)
    {
      if (CAPrefers60HzAPT(void)::once[0] != -1) {
        dispatch_once(CAPrefers60HzAPT(void)::once, &__block_literal_global_3);
      }
      a4.i32[1] = 0;
      if (CAPrefers60HzAPT(void)::enabled) {
        float v36 = 0.0;
      }
      else {
        float v36 = 120.0;
      }
      if (CAPrefers60HzAPT(void)::enabled) {
        float v37 = 80.0;
      }
      else {
        float v37 = 120.0;
      }
      if (CAPrefers60HzAPT(void)::enabled) {
        *(float *)a4.i32 = 60.0;
      }
      else {
        *(float *)a4.i32 = 120.0;
      }
    }
    uint64_t v39 = *(unsigned int *)(a1 + 88);
    if (a8 && !v39)
    {
      if ((*(unsigned char *)(a1 + 14) & 0x80) != 0)
      {
        if (*(float *)a4.i32 > 60.0) {
          *(float *)a4.i32 = 60.0;
        }
        LODWORD(a5) = 1117782016;
        if (v37 <= 80.0) {
          *(float *)&a5 = v37;
        }
        a6.i32[0] = 1114636288;
        if (v36 <= 60.0) {
          *(float *)a6.i32 = v36;
        }
        uint64_t v39 = 0;
        if (v36 == 0.0) {
          *(float *)a6.i32 = v36;
        }
        goto LABEL_51;
      }
      uint64_t v39 = 0;
    }
    *(float *)&a5 = v37;
    *(float *)a6.i32 = v36;
LABEL_51:
    if (!a3 || a3 == 2 && (*(unsigned char *)(a1 + 14) & 0x10) != 0) {
      objc_msgSend(a2, "addFrameRateRange:", *(double *)a4.i64, a5, *(double *)a6.i64, v22, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v15, v16);
    }
    if ((v39 + 0x10000) >= 0x20000) {
      objc_msgSend(a2, "addReason:", v39, *(double *)a4.i64, a5, *(double *)a6.i64);
    }
LABEL_57:
    float v40 = 48.0;
    if (v37 >= 48.0) {
      float v40 = v37;
    }
    if (v37 == 0.0 || v36 != 0.0) {
      float v40 = v36;
    }
    if (v40 != 0.0)
    {
      *(double *)a4.i64 = 1.0 / v40;
      if (*(double *)a4.i64 != 0.0)
      {
        uint64_t v42 = *(void *)(a1 + 40);
        if (v42) {
          *(double *)a4.i64 = *(double *)a4.i64 * *(float *)(v42 + 16);
        }
        if (*(double *)a4.i64 != 0.0)
        {
          if ((*(unsigned char *)(a1 + 13) & 0x80) != 0)
          {
            double v28 = v32 + ceil((v28 - v32) / *(double *)a4.i64) * *(double *)a4.i64;
          }
          else
          {
            double v43 = *(double *)a4.i64 + v28;
            *(double *)a4.i64 = -*(double *)a4.i64;
            a6.i64[0] = 0x3F61111111111111;
            v44.f64[0] = NAN;
            v44.f64[1] = NAN;
            double v28 = v43 + *(double *)vbslq_s8((int8x16_t)vnegq_f64(v44), a6, a4).i64;
          }
        }
      }
    }
    BOOL v45 = v28 < *a9;
    if (v27 <= 0.0) {
      BOOL v45 = v28 > *a9;
    }
    double v32 = v28;
    if (v45) {
      goto LABEL_75;
    }
  }
}

void CA::Render::PropertyAnimation::significant_change_next_time(CA::Render::Animation *a1, uint64_t a2, uint64_t a3, int a4, double *a5, CA::Render::Layer *a6, float64x2_t *a7, _DWORD *a8, double a9, float a10, double a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v128 = *MEMORY[0x1E4F143B8];
  if (!a7 || *((float *)a1 + 6) != 0.0 && (*((unsigned char *)a6 + 41) & 0x10) == 0) {
    return;
  }
  unint64_t v22 = *((void *)a1 + 12);
  if (!v22)
  {
    uint64_t v23 = a8;
    uint64_t v24 = a3;
LABEL_9:
    int v25 = a5;
    LODWORD(v26) = 0;
    goto LABEL_11;
  }
  uint64_t v23 = a8;
  uint64_t v24 = a3;
  if ((v22 & 1) == 0)
  {
    if (*(_DWORD *)v22)
    {
      int v25 = a5;
      LODWORD(v26) = *(_DWORD *)(v22 + 4);
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  int v25 = a5;
  unint64_t v26 = v22 >> 1;
LABEL_11:
  int v98 = v26;
  uint64_t v27 = CAAtomIndexInArray(10, (uint64_t)CA::Render::PropertyAnimation::significant_change_next_time(double,float,double({block_pointer})(double),double({block_pointer})(double),unsigned int,double &,double,CA::Render::Layer const*,CA::Vec2<double> const*,unsigned int &,CA::Render::Object *,CA::Render::Object *,CA::Render::Object *)const::atoms, v26);
  if (v27 == -1) {
    return;
  }
  double v28 = v25;
  uint64_t v29 = v24;
  uint64_t v30 = v23;
  int v127 = 0;
  uint64_t v126 = 0;
  if (v22)
  {
    if (v22)
    {
      LODWORD(v126) = v22 >> 1;
      uint64_t v31 = 1;
    }
    else
    {
      uint64_t v31 = *(unsigned int *)v22;
      if (v31 > 3) {
        return;
      }
      uint64_t v32 = *(unsigned int *)v22;
      if (v32)
      {
        BOOL v33 = (int *)(v22 + 4);
        BOOL v34 = &v126;
        do
        {
          int v35 = *v33++;
          *(_DWORD *)BOOL v34 = v35;
          BOOL v34 = (uint64_t *)((char *)v34 + 4);
          --v32;
        }
        while (v32);
      }
    }
  }
  else
  {
    uint64_t v31 = 0;
  }
  int v36 = *v23;
  int v37 = 1 << v27;
  if ((v36 & (1 << v27)) == 0)
  {
    __int16 v96 = v28;
    unint64_t v97 = v31;
    double v101 = a9;
    BOOL v100 = 0;
    if (CA::Render::Animation::map_time(a1, &v101, 0, &v100, 0))
    {
      uint64_t v39 = a13;
      if (a2)
      {
        double v40 = (*(double (**)(uint64_t, double))(a2 + 16))(a2, v101);
        uint64_t v39 = a13;
        double v101 = v40;
      }
      v41.n128_u64[1] = 0;
      long long v124 = 0u;
      long long v125 = 0u;
      long long v122 = 0u;
      long long v123 = 0u;
      float64x2_t v120 = 0u;
      long long v121 = 0u;
      long long v118 = 0u;
      long long v119 = 0u;
      long long v116 = 0u;
      long long v117 = 0u;
      float64x2_t __dst = 0u;
      float64x2_t v115 = 0u;
      long long v112 = 0u;
      long long v113 = 0u;
      long long v110 = 0u;
      long long v111 = 0u;
      long long v109 = 0u;
      long long v107 = 0u;
      float64x2_t v108 = 0u;
      long long v105 = 0u;
      long long v106 = 0u;
      float64x2_t v103 = 0u;
      long long v104 = 0u;
      float64x2_t v102 = 0u;
      if (a12 && v39)
      {
        unint64_t v42 = v97;
        if (*(unsigned char *)(a12 + 12) == 56
          && ((unsigned int v43 = *(_DWORD *)(a12 + 16), v43 >= 0x18) ? (v44 = 24) : (v44 = v43), v44))
        {
          uint64_t v45 = v39;
          memcpy(&__dst, (const void *)(a12 + 24), 8 * v44);
          uint64_t v39 = v45;
          unint64_t v42 = v97;
        }
        else
        {
          unint64_t v44 = 0;
        }
        if (*(unsigned char *)(v39 + 12) == 56)
        {
          unsigned int v47 = *(_DWORD *)(v39 + 16);
          unint64_t keypath_value = v47 >= 0x18 ? 24 : v47;
          if (keypath_value)
          {
            uint64_t v49 = (const void *)(v39 + 24);
            goto LABEL_48;
          }
        }
        unint64_t keypath_value = 0;
      }
      else
      {
        unint64_t v42 = v97;
        if (a12 && a14)
        {
          if (*(unsigned char *)(a12 + 12) == 56
            && ((unsigned int v46 = *(_DWORD *)(a12 + 16), v46 >= 0x18) ? (v44 = 24) : (v44 = v46), v44))
          {
            memcpy(&__dst, (const void *)(a12 + 24), 8 * v44);
            unint64_t v42 = v97;
          }
          else
          {
            unint64_t v44 = 0;
          }
          if (*(unsigned char *)(a14 + 12) == 56
            && ((unsigned int v52 = *(_DWORD *)(a14 + 16), v52 >= 0x18) ? (keypath_value = 24) : (keypath_value = v52),
                keypath_value))
          {
            memcpy(&v102, (const void *)(a14 + 24), 8 * keypath_value);
            unint64_t v42 = v97;
          }
          else
          {
            unint64_t keypath_value = 0;
          }
          if (v44 >= keypath_value) {
            unint64_t v53 = keypath_value;
          }
          else {
            unint64_t v53 = v44;
          }
          if (v53)
          {
            uint64_t v54 = &v102;
            p_dst = &__dst;
            do
            {
              double v56 = p_dst->f64[0];
              p_dst = (float64x2_t *)((char *)p_dst + 8);
              v54->f64[0] = v54->f64[0] + v56;
              uint64_t v54 = (float64x2_t *)((char *)v54 + 8);
              --v53;
            }
            while (v53);
          }
        }
        else if (v39 && a14)
        {
          if (*(unsigned char *)(a14 + 12) == 56
            && ((v50 = *(_DWORD *)(a14 + 16), v50 >= 0x18) ? (unint64_t v44 = 24) : (unint64_t v44 = v50), v44))
          {
            uint64_t v51 = v39;
            memcpy(&__dst, (const void *)(a14 + 24), 8 * v44);
            uint64_t v39 = v51;
            unint64_t v42 = v97;
          }
          else
          {
            unint64_t v44 = 0;
          }
          if (*(unsigned char *)(v39 + 12) == 56
            && ((unsigned int v59 = *(_DWORD *)(v39 + 16), v59 >= 0x18) ? (keypath_value = 24) : (keypath_value = v59),
                keypath_value))
          {
            memcpy(&v102, (const void *)(v39 + 24), 8 * keypath_value);
            unint64_t v42 = v97;
          }
          else
          {
            unint64_t keypath_value = 0;
          }
          if (v44 >= keypath_value) {
            unint64_t v60 = keypath_value;
          }
          else {
            unint64_t v60 = v44;
          }
          if (v60)
          {
            uint64_t v61 = &__dst;
            unint64_t v62 = &v102;
            do
            {
              double v63 = v62->f64[0];
              unint64_t v62 = (float64x2_t *)((char *)v62 + 8);
              v61->f64[0] = v63 - v61->f64[0];
              uint64_t v61 = (float64x2_t *)((char *)v61 + 8);
              --v60;
            }
            while (v60);
          }
        }
        else if (a12)
        {
          if (*(unsigned char *)(a12 + 12) == 56
            && ((LODWORD(v57) = *(_DWORD *)(a12 + 16), v57 >= 0x18)
              ? (uint64_t v57 = 24)
              : (uint64_t v57 = v57),
                v57))
          {
            unint64_t v58 = v57;
            memcpy(&__dst, (const void *)(a12 + 24), 8 * v57);
          }
          else
          {
            unint64_t v58 = 0;
          }
          unint64_t keypath_value = CA::Render::Layer::get_keypath_value(a6, (unint64_t *)a1 + 12, 0x18uLL, &v102, 0);
          unint64_t v42 = v97;
          unint64_t v44 = v58;
        }
        else
        {
          if (v39)
          {
            uint64_t v84 = v39;
            unint64_t v44 = CA::Render::Layer::get_keypath_value(a6, (unint64_t *)a1 + 12, 0x18uLL, &__dst, 0);
            if (*(unsigned char *)(v84 + 12) != 56
              || ((unsigned int v85 = *(_DWORD *)(v84 + 16), v85 >= 0x18) ? (keypath_value = 24) : (keypath_value = v85),
                  !keypath_value))
            {
              unint64_t keypath_value = 0;
              goto LABEL_49;
            }
            uint64_t v49 = (const void *)(v84 + 24);
LABEL_48:
            memcpy(&v102, v49, 8 * keypath_value);
LABEL_49:
            unint64_t v42 = v97;
            goto LABEL_98;
          }
          if (!a14) {
            return;
          }
          uint64_t v90 = CA::Render::Layer::get_keypath_value(a6, (unint64_t *)a1 + 12, 0x18uLL, &__dst, 0);
          unint64_t v42 = v97;
          unint64_t v44 = v90;
          unint64_t keypath_value = 0;
          if (*(unsigned char *)(a14 + 12) == 56)
          {
            unsigned int v91 = *(_DWORD *)(a14 + 16);
            if (v91 >= 0x18) {
              unint64_t keypath_value = 24;
            }
            else {
              unint64_t keypath_value = v91;
            }
            if (keypath_value)
            {
              memcpy(&v102, (const void *)(a14 + 24), 8 * keypath_value);
              unint64_t v42 = v97;
            }
            else
            {
              unint64_t keypath_value = 0;
            }
          }
          if (v44 >= keypath_value) {
            unint64_t v92 = keypath_value;
          }
          else {
            unint64_t v92 = v44;
          }
          if (v92)
          {
            CGColorSpaceModel v93 = &v102;
            __int16 v94 = &__dst;
            do
            {
              double v95 = v94->f64[0];
              __int16 v94 = (float64x2_t *)((char *)v94 + 8);
              v93->f64[0] = v93->f64[0] + v95;
              CGColorSpaceModel v93 = (float64x2_t *)((char *)v93 + 8);
              --v92;
            }
            while (v92);
          }
        }
      }
LABEL_98:
      double v64 = 0.0;
      double v65 = 0.00833333333;
      double position_range = INFINITY;
      if (v98 > 408)
      {
        if (v98 <= 500)
        {
          if (v98 == 409) {
            goto LABEL_121;
          }
          if (v98 != 438) {
            goto LABEL_131;
          }
          uint64_t v69 = v42 - 1;
          int v70 = HIDWORD(v126);
          goto LABEL_161;
        }
        if (v98 == 501 || v98 == 503) {
          goto LABEL_121;
        }
        if (v98 != 568) {
          goto LABEL_131;
        }
        double position_range = INFINITY;
        if (v42 == 1)
        {
          if (v44 == 16 && keypath_value == 16)
          {
            if (!CA::Mat4Impl::mat4_is_translation((CA::Mat4Impl *)&__dst, v38)
              || !CA::Mat4Impl::mat4_is_translation((CA::Mat4Impl *)&v102, v67)
              || *(double *)&v121 != *(double *)&v109)
            {
              goto LABEL_128;
            }
            float64x2_t v68 = vmulq_f64(*a7, vsubq_f64(v108, v120));
            __n128 v41 = (__n128)vmulq_f64(v68, v68);
            double position_range = sqrt(vaddvq_f64((float64x2_t)v41));
LABEL_162:
            double v64 = 0.5;
          }
        }
        else if (v42 && HIDWORD(v126) == 572)
        {
          uint64_t v69 = v42 - 2;
LABEL_160:
          int v70 = v127;
LABEL_161:
          double position_range = CA::Render::get_position_range(v70, v69, v44, keypath_value, a7->f64[0], a7->f64[1], __dst.f64[0], __dst.f64[1], v102.f64[0], v102.f64[1]);
          goto LABEL_162;
        }
      }
      else
      {
        if (v98 > 73)
        {
          if (v98 != 74)
          {
            if (v98 == 119)
            {
              double position_range = 1.0;
              double v64 = 0.00392156863;
LABEL_130:
              double v65 = dbl_1849985F0[(a4 - 1) < 0x4F];
              goto LABEL_131;
            }
            if (v98 != 133) {
              goto LABEL_131;
            }
LABEL_121:
            double position_range = vabdd_f64(__dst.f64[0], v102.f64[0]);
            double v64 = 0.00392156863;
            if (v44 >= 2)
            {
              unint64_t v71 = v44 - 1;
              int v72 = &v102.f64[1];
              char v73 = &__dst.f64[1];
              do
              {
                double v74 = *v73++;
                double v75 = v74;
                double v76 = *v72++;
                double position_range = fmax(position_range, vabdd_f64(v75, v76));
                --v71;
              }
              while (v71);
            }
            goto LABEL_130;
          }
          uint64_t v69 = v42 - 2;
          if (v42 < 2)
          {
            double position_range = INFINITY;
            if (v42 == 1 && v44 >= 4 && keypath_value >= 4)
            {
              float64x2_t v86 = vmulq_f64(*a7, vsubq_f64(v102, __dst));
              int64x2_t v87 = (int64x2_t)vmulq_f64(v86, v86);
              float64x2_t v88 = vmulq_f64(vsubq_f64(v103, v115), *a7);
              int64x2_t v89 = (int64x2_t)vmulq_f64(v88, v88);
              __n128 v41 = (__n128)vsqrtq_f64(vaddq_f64((float64x2_t)vzip2q_s64(v87, v89), (float64x2_t)vzip1q_s64(v87, v89)));
              double position_range = v41.n128_f64[1];
              double v64 = 0.5;
              if (v41.n128_f64[0] > v41.n128_f64[1]) {
                double position_range = v41.n128_f64[0];
              }
            }
            goto LABEL_131;
          }
          if (HIDWORD(v126) != 513 && HIDWORD(v126) != 416)
          {
LABEL_128:
            double position_range = INFINITY;
            goto LABEL_131;
          }
          goto LABEL_160;
        }
        if (v98 == 54 || v98 == 66) {
          goto LABEL_121;
        }
      }
LABEL_131:
      if ((*(void *)&position_range & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        double v77 = fabsf(a10);
        v41.n128_f64[0] = v64 / position_range;
        if (v100) {
          v41.n128_f64[0] = -(v64 / position_range);
        }
        uint64_t v78 = *((void *)a1 + 5);
        if (v78 && *(float *)(v78 + 16) < 0.0) {
          v41.n128_f64[0] = -v41.n128_f64[0];
        }
        double v79 = (v65 + -0.00208333333) * v77;
        double v80 = v101;
        double v81 = (*(double (**)(CA::Render::Animation *, __n128, double))(*(void *)a1 + 176))(a1, v41, v101)
            + v80;
        if (v81 > 1.0) {
          double v81 = 1.0;
        }
        if (v81 < 0.0) {
          double v81 = 0.0;
        }
        double v99 = v81;
        if (v29) {
          double v99 = (*(double (**)(uint64_t))(v29 + 16))(v29);
        }
        CA::Render::Animation::inverse_map_time((uint64_t)a1, &v99, a9);
        double v82 = fmax(v99 + -0.00208333333, v79 + a9);
        BOOL v83 = v82 < a11;
        if (a10 <= 0.0) {
          BOOL v83 = v82 > a11;
        }
        if (v83) {
          *__int16 v96 = v82;
        }
        if (position_range != 0.0) {
          *v30 |= v37;
        }
      }
    }
  }
}

void sub_184706A04(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::FrameRateRangeGroup::add(CA::FrameRateRangeGroup *this, CAFrameRateRange a2)
{
  float preferred = a2.preferred;
  float maximum = a2.maximum;
  float minimum = a2.minimum;
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = CA::FrameRateRangeGroup::fps_range_to_frame_interval_range(this, a2);
  unsigned int v8 = v7;
  unint64_t v49 = v6;
  unsigned int v50 = v7;
  unint64_t v9 = ((uint64_t)(int)maximum << 16) | ((unint64_t)(int)minimum << 32) | (int)preferred;
  unint64_t v10 = *((void *)this + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v12 = ((uint64_t)(int)maximum << 16) | ((unint64_t)(int)minimum << 32) | (int)preferred;
      if (v9 >= v10) {
        unint64_t v12 = v9 % v10;
      }
    }
    else
    {
      unint64_t v12 = v9 & (v10 - 1);
    }
    uint64_t v13 = *(void ***)(*((void *)this + 7) + 8 * v12);
    if (v13)
    {
      uint64_t v14 = (char *)*v13;
      if (*v13)
      {
        do
        {
          unint64_t v15 = *((void *)v14 + 1);
          if (v15 == v9)
          {
            if (*((float *)v14 + 4) == minimum && *((float *)v14 + 5) == maximum && *((float *)v14 + 6) == preferred) {
              goto LABEL_76;
            }
          }
          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v15 >= v10) {
                v15 %= v10;
              }
            }
            else
            {
              v15 &= v10 - 1;
            }
            if (v15 != v12) {
              break;
            }
          }
          uint64_t v14 = *(char **)v14;
        }
        while (v14);
      }
    }
  }
  else
  {
    unint64_t v12 = 0;
  }
  uint64_t v14 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v14 = 0;
  *((void *)v14 + 1) = v9;
  *((float *)v14 + 4) = minimum;
  *((float *)v14 + 5) = maximum;
  *((float *)v14 + 6) = preferred;
  *((void *)v14 + 5) = 0;
  *((void *)v14 + 6) = 0;
  *((void *)v14 + 4) = 0;
  float v16 = (float)(unint64_t)(*((void *)this + 10) + 1);
  float v17 = *((float *)this + 22);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      int8x8_t prime = (int8x8_t)v20;
    }
    else {
      int8x8_t prime = (int8x8_t)v19;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v10 = *((void *)this + 8);
    }
    if (*(void *)&prime > v10) {
      goto LABEL_32;
    }
    if (*(void *)&prime < v10)
    {
      unint64_t v28 = vcvtps_u32_f32((float)*((unint64_t *)this + 10) / *((float *)this + 22));
      if (v10 < 3 || (uint8x8_t v29 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v29.i16[0] = vaddlv_u8(v29), v29.u32[0] > 1uLL))
      {
        unint64_t v28 = std::__next_prime(v28);
      }
      else
      {
        uint64_t v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2) {
          unint64_t v28 = v30;
        }
      }
      if (*(void *)&prime <= v28) {
        int8x8_t prime = (int8x8_t)v28;
      }
      if (*(void *)&prime >= v10)
      {
        unint64_t v10 = *((void *)this + 8);
      }
      else
      {
        if (prime)
        {
LABEL_32:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v22 = operator new(8 * *(void *)&prime);
          uint64_t v23 = (void *)*((void *)this + 7);
          *((void *)this + 7) = v22;
          if (v23) {
            operator delete(v23);
          }
          uint64_t v24 = 0;
          *((int8x8_t *)this + 8) = prime;
          do
            *(void *)(*((void *)this + 7) + 8 * v24++) = 0;
          while (*(void *)&prime != v24);
          int v25 = (void *)*((void *)this + 9);
          if (v25)
          {
            unint64_t v26 = v25[1];
            uint8x8_t v27 = (uint8x8_t)vcnt_s8(prime);
            v27.i16[0] = vaddlv_u8(v27);
            if (v27.u32[0] > 1uLL)
            {
              if (v26 >= *(void *)&prime) {
                v26 %= *(void *)&prime;
              }
            }
            else
            {
              v26 &= *(void *)&prime - 1;
            }
            *(void *)(*((void *)this + 7) + 8 * v26) = (char *)this + 72;
            uint64_t v31 = (void *)*v25;
            if (*v25)
            {
              do
              {
                unint64_t v32 = v31[1];
                if (v27.u32[0] > 1uLL)
                {
                  if (v32 >= *(void *)&prime) {
                    v32 %= *(void *)&prime;
                  }
                }
                else
                {
                  v32 &= *(void *)&prime - 1;
                }
                if (v32 != v26)
                {
                  uint64_t v33 = *((void *)this + 7);
                  if (!*(void *)(v33 + 8 * v32))
                  {
                    *(void *)(v33 + 8 * v32) = v25;
                    goto LABEL_57;
                  }
                  *int v25 = *v31;
                  *uint64_t v31 = **(void **)(*((void *)this + 7) + 8 * v32);
                  **(void **)(*((void *)this + 7) + 8 * v32) = v31;
                  uint64_t v31 = v25;
                }
                unint64_t v32 = v26;
LABEL_57:
                int v25 = v31;
                uint64_t v31 = (void *)*v31;
                unint64_t v26 = v32;
              }
              while (v31);
            }
          }
          unint64_t v10 = (unint64_t)prime;
          goto LABEL_61;
        }
        uint64_t v48 = (void *)*((void *)this + 7);
        *((void *)this + 7) = 0;
        if (v48) {
          operator delete(v48);
        }
        unint64_t v10 = 0;
        *((void *)this + 8) = 0;
      }
    }
LABEL_61:
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v12 = v9 % v10;
      }
      else {
        unint64_t v12 = ((uint64_t)(int)maximum << 16) | ((unint64_t)(int)minimum << 32) | (int)preferred;
      }
    }
    else
    {
      unint64_t v12 = (v10 - 1) & v9;
    }
  }
  uint64_t v34 = *((void *)this + 7);
  int v35 = *(void **)(v34 + 8 * v12);
  if (v35)
  {
    *(void *)uint64_t v14 = *v35;
  }
  else
  {
    *(void *)uint64_t v14 = *((void *)this + 9);
    *((void *)this + 9) = v14;
    *(void *)(v34 + 8 * v12) = (char *)this + 72;
    if (!*(void *)v14) {
      goto LABEL_75;
    }
    unint64_t v36 = *(void *)(*(void *)v14 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v36 >= v10) {
        v36 %= v10;
      }
    }
    else
    {
      v36 &= v10 - 1;
    }
    int v35 = (void *)(*((void *)this + 7) + 8 * v36);
  }
  *int v35 = v14;
LABEL_75:
  ++*((void *)this + 10);
LABEL_76:
  int v37 = v14 + 32;
  uint64_t v38 = *((void *)v14 + 6);
  if (v38)
  {
    if (*v37 != v6 || *(void *)(v14 + 36) != __PAIR64__(v8, HIDWORD(v6))) {
      __assert_rtn("add", "CAFrameRateRangeGroup.mm", 152, "info.count == 0 || info.range == range");
    }
    goto LABEL_92;
  }
  double v40 = (char *)*((void *)this + 12);
  uint64_t v39 = (char *)*((void *)this + 13);
  __n128 v41 = (char *)this + 96;
  if (v39 == v40) {
    goto LABEL_91;
  }
  unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * ((v39 - v40) >> 2);
  do
  {
    unint64_t v43 = v42 >> 1;
    unint64_t v44 = &v40[12 * (v42 >> 1)];
    if (*(_DWORD *)v44 > v6) {
      goto LABEL_89;
    }
    if (*(_DWORD *)v44 != v6) {
      goto LABEL_88;
    }
    unsigned int v45 = *(_DWORD *)&v40[12 * v43 + 4];
    if (v45 > HIDWORD(v6)) {
      goto LABEL_89;
    }
    if (v45 == HIDWORD(v6))
    {
      unint64_t v46 = v42 + ~v43;
      unsigned int v47 = v44 + 12;
      if (*(_DWORD *)&v40[12 * v43 + 8] <= v8)
      {
        double v40 = v47;
        unint64_t v43 = v46;
      }
    }
    else
    {
LABEL_88:
      double v40 = v44 + 12;
      unint64_t v43 = v42 + ~v43;
    }
LABEL_89:
    unint64_t v42 = v43;
  }
  while (v43);
  uint64_t v39 = v40;
LABEL_91:
  std::vector<CAFrameIntervalRange>::insert((uint64_t)v41, v39, (unint64_t)&v49);
  uint64_t v38 = *((void *)v14 + 6);
LABEL_92:
  *(void *)int v37 = v49;
  *((_DWORD *)v14 + 10) = v50;
  *((void *)v14 + 6) = v38 + 1;
}

void sub_184706F9C(_Unwind_Exception *exception_object)
{
}

unint64_t CA::FrameRateRangeGroup::fps_range_to_frame_interval_range(CA::FrameRateRangeGroup *this, CAFrameRateRange a2)
{
  if (*((void *)this + 1)) {
    return CA::Display::DisplayTimingsControl::fps_range_to_frame_interval_range(*((CA::Display::DisplayTimingsControl **)this + 1), a2, 0);
  }
  else {
    return CAFrameRateRangeToFrameIntervalRange(a2, *((double *)this + 15), *((unsigned __int8 *)this + 128), *((unsigned char *)this + 129) & 1, (*((unsigned __int8 *)this + 129) >> 1) & 1, (*((unsigned __int8 *)this + 129) >> 2) & 1);
  }
}

unint64_t CAFrameRateRangeToFrameIntervalRange(CAFrameRateRange a1, double a2, uint64_t a3, int a4, int a5, int a6)
{
  float preferred = a1.preferred;
  float maximum = a1.maximum;
  float minimum = a1.minimum;
  if (a1.minimum == 0.0 && a1.maximum == 0.0 && a1.preferred == 0.0 && a3 != 1)
  {
    if (CAPrefers60HzAPT(void)::once[0] != -1) {
      dispatch_once(CAPrefers60HzAPT(void)::once, &__block_literal_global_3);
    }
    if (CAPrefers60HzAPT(void)::enabled)
    {
      float minimum = 60.0;
      if (a5) {
        float maximum = 60.0;
      }
      else {
        float maximum = 80.0;
      }
      if (a5) {
        float preferred = 60.0;
      }
      else {
        float preferred = 0.0;
      }
    }
    else
    {
      float minimum = 120.0;
      float maximum = 120.0;
      float preferred = 120.0;
    }
  }
  uint64_t v15 = CAFrameRateToFrameInterval((int)maximum, a2, a3, a4, a5, a6);
  unsigned int v16 = v15;
  BOOL v18 = preferred == 0.0 && maximum == 0.0 && minimum == 0.0;
  if (v18 || preferred != 0.0)
  {
    uint64_t v19 = v15;
    if (maximum != preferred) {
      uint64_t v19 = CAFrameRateToFrameInterval((int)preferred, a2, a3, a4, a5, a6);
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  uint64_t v20 = v19;
  if (preferred != minimum) {
    uint64_t v20 = CAFrameRateToFrameInterval((int)minimum, a2, a3, a4, a5, a6);
  }
  return v16 | (unint64_t)(v20 << 32);
}

uint64_t CAFrameRateToFrameInterval(int a1, double a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6 = a3;
  if (a2 == 0.0) {
    a2 = 0.0166666667;
  }
  int v7 = a5 | a6;
  if (a1)
  {
    double v8 = (double)a3;
    if (!v7) {
      double v8 = 1.0;
    }
    float v9 = 1.0 / (v8 * ((double)a1 * a2)) + -0.00100000005;
    int v10 = llroundf(v9);
    if (v10 <= 1) {
      int v10 = 1;
    }
  }
  else if (a4)
  {
    if (dyld_program_sdk_at_least()) {
      int v10 = 1;
    }
    else {
      int v10 = 2 * v6;
    }
  }
  else
  {
    int v10 = 1;
  }
  if (v7) {
    int v11 = v6;
  }
  else {
    int v11 = 1;
  }
  int v12 = v10 * v11;
  if (v12 <= (int)v6) {
    int v12 = v6;
  }
  if (!v12) {
    __assert_rtn("CAFrameIntervalValidInterval", "CATimingReference.cpp", 111, "frame_interval != 0");
  }
  uint64_t v13 = 0;
  while (frame_interval_table[v13] <= v12)
  {
    if (++v13 == 21) {
      return v6;
    }
  }
  return frame_interval_table[v13 - 1];
}

void CA::FrameRateRangeGroup::arbitrate_ranges(CA::FrameRateRangeGroup *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&v9.var0 = CA::FrameRateArbitrator::arbitrate((uint64_t)this + 96, (uint64_t)"", a3, a4, a5, a6, a7, a8);
  *(CAFrameIntervalRange *)((char *)this + 32) = v9;
  uint64_t v10 = *((void *)this + 1);
  if (v10)
  {
    char v11 = *(unsigned char *)(v10 + 233);
    int v12 = (double *)(v10 + 64);
    uint64_t v13 = (double *)(v10 + 48);
    if ((v11 & 8) != 0) {
      uint64_t v13 = v12;
    }
  }
  else
  {
    uint64_t v13 = (double *)((char *)this + 120);
  }
  float v16 = CAFrameIntervalRangeToFrameRateRange(v9, *v13);
  float v17 = v14;
  float v18 = v15;
  BOOL v19 = v16 == *((float *)this + 11) && v14 == *((float *)this + 12);
  if (!v19 || v15 != *((float *)this + 13))
  {
    [*((id *)this + 2) willChangeValueForKey:@"arbitratedRange"];
    *((float *)this + 11) = v16;
    *((float *)this + 12) = v17;
    *((float *)this + 13) = v18;
    uint64_t v20 = (void *)*((void *)this + 2);
    [v20 didChangeValueForKey:@"arbitratedRange"];
  }
}

unint64_t CA::FrameRateArbitrator::arbitrate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v102 = *MEMORY[0x1E4F143B8];
  double v8 = *(_DWORD **)a1;
  uint64_t v9 = *(void *)(a1 + 8);
  if (*(void *)a1 == v9)
  {
    LODWORD(v11) = 0;
    goto LABEL_5;
  }
  uint64_t v10 = v9 - (void)v8;
  if (v10 == 12)
  {
    LODWORD(v11) = *v8;
    uint64_t v12 = v8[1];
    return v11 | (unint64_t)(v12 << 32);
  }
  uint64_t v13 = (unsigned __int128)(v10 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
  uint64_t v87 = 0;
  uint64_t v88 = 0;
  uint64_t v89 = 0;
  if (initialized != -1)
  {
    uint64_t v60 = a1;
    uint64_t v61 = a2;
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    a1 = v60;
    a2 = v61;
  }
  unint64_t v15 = (v13 >> 1) + ((unint64_t)v13 >> 63);
  float v16 = &CA::callback_timer;
  if (byte_1EB2ACC45)
  {
    uint64_t v87 = 0;
    uint64_t v88 = 0;
    uint64_t v89 = 0;
  }
  uint64_t v17 = 0;
  uint64_t v11 = 0;
  if (v15 <= 1) {
    uint64_t v18 = 1;
  }
  else {
    uint64_t v18 = (v13 >> 1) + ((unint64_t)v13 >> 63);
  }
  uint64_t v12 = 0xFFFFFFFFLL;
  uint64_t v19 = -1;
  uint64_t v20 = 3;
  uint64_t v21 = &initialized;
  uint64_t v22 = v18;
  uint64_t v23 = "  candidate: %u %u %u\n";
  do
  {
    uint64_t v24 = *(_DWORD **)a1;
    int v25 = (int *)(*(void *)a1 + v17 * 4);
    int v26 = *v25;
    unsigned int v27 = v25[1];
    if (*v25 < 4 && v27 > 3) {
      int v28 = 2;
    }
    else {
      int v28 = *v25;
    }
    if (v28 == 4 && v27 > 5) {
      unsigned int v30 = 3;
    }
    else {
      unsigned int v30 = v28;
    }
    if (v25[2] == 2 && v27 > 3) {
      unsigned int v31 = 3;
    }
    else {
      unsigned int v31 = v25[1];
    }
    if (v19 != -1)
    {
      uint64_t v75 = a1;
      uint64_t v81 = a2;
      unint64_t v73 = v15;
      uint64_t v74 = v11;
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
      uint64_t v23 = "  candidate: %u %u %u\n";
      uint64_t v21 = &initialized;
      uint64_t v20 = 3;
      uint64_t v11 = v74;
      a1 = v75;
      float v16 = &CA::callback_timer;
      unint64_t v15 = v73;
      a2 = v81;
    }
    if (*((unsigned char *)v16 + 3141))
    {
      uint64_t v76 = a1;
      uint64_t v82 = a2;
      uint64_t v72 = v24[v17];
      uint64_t v34 = v11;
      unint64_t v35 = v15;
      x_stream_printf((uint64_t)&v87, v23, 3, (uint64_t)&initialized, (uint64_t)v23, a6, a7, a8, v72);
      uint64_t v23 = "  candidate: %u %u %u\n";
      uint64_t v21 = &initialized;
      uint64_t v20 = 3;
      a1 = v76;
      a2 = v82;
      float v16 = &CA::callback_timer;
      unint64_t v15 = v35;
      uint64_t v11 = v34;
    }
    if (v11 <= v30) {
      uint64_t v32 = v30;
    }
    else {
      uint64_t v32 = v11;
    }
    if (v12 >= v31) {
      uint64_t v33 = v31;
    }
    else {
      uint64_t v33 = v12;
    }
    if (v32 > v33) {
      break;
    }
    if (v14[186] != -1)
    {
      uint64_t v77 = a1;
      uint64_t v83 = a2;
      unint64_t v36 = v15;
      int v37 = v14;
      uint64_t v38 = v23;
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
      uint64_t v23 = v38;
      uint64_t v21 = &initialized;
      uint64_t v20 = 3;
      a1 = v77;
      a2 = v83;
      float v16 = &CA::callback_timer;
      float v14 = v37;
      unint64_t v15 = v36;
    }
    if (*((unsigned char *)v16 + 3141))
    {
      uint64_t v78 = a1;
      uint64_t v84 = a2;
      unint64_t v39 = v15;
      double v40 = v14;
      __n128 v41 = v16;
      x_stream_printf((uint64_t)&v87, "    update result: %u %u\n", 3, (uint64_t)&initialized, (uint64_t)v23, a6, a7, a8, v32);
      uint64_t v23 = "  candidate: %u %u %u\n";
      uint64_t v21 = &initialized;
      uint64_t v20 = 3;
      a1 = v78;
      a2 = v84;
      float v16 = v41;
      float v14 = v40;
      unint64_t v15 = v39;
      uint64_t v19 = v40[186];
    }
    else
    {
      uint64_t v19 = -1;
    }
    v17 += 3;
    uint64_t v11 = v32;
    uint64_t v12 = v33;
    --v22;
  }
  while (v22);
  BOOL v43 = v26 == 4 && v27 == 5;
  if (v12 == -1 && !v11)
  {
LABEL_5:
    uint64_t v12 = 0;
    return v11 | (unint64_t)(v12 << 32);
  }
  int v44 = 0;
  uint64_t v45 = 8;
  do
  {
    uint64_t v46 = *(unsigned int *)(*(void *)a1 + v45);
    if (v46 >= v11
      && v46 <= v12
      && v44 - 1 >= v46)
    {
      if (v14[186] != -1)
      {
        uint64_t v79 = a1;
        uint64_t v85 = a2;
        uint64_t v49 = v11;
        unint64_t v50 = v15;
        uint64_t v51 = v14;
        unsigned int v52 = v16;
        dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
        a1 = v79;
        a2 = v85;
        float v16 = v52;
        float v14 = v51;
        unint64_t v15 = v50;
        uint64_t v11 = v49;
      }
      if (*((unsigned char *)v16 + 3141))
      {
        uint64_t v80 = a1;
        uint64_t v86 = a2;
        uint64_t v53 = v11;
        unint64_t v54 = v15;
        uint64_t v55 = v14;
        double v56 = v16;
        x_stream_printf((uint64_t)&v87, "  explicit preference for %u\n", v20, (uint64_t)v21, (uint64_t)v23, a6, a7, a8, v46);
        a1 = v80;
        a2 = v86;
        float v16 = v56;
        float v14 = v55;
        unint64_t v15 = v54;
        uint64_t v11 = v53;
      }
      int v44 = v46;
    }
    v45 += 12;
    --v18;
  }
  while (v18);
  if (v43)
  {
    BOOL v57 = v11 == 3 && v44 == 0;
    BOOL v58 = v57;
    if (v44 == 3 || v58)
    {
      LODWORD(v11) = 2;
      uint64_t v12 = 2;
      int v44 = 2;
    }
  }
  if (v14[186] != -1)
  {
    uint64_t v62 = a2;
    int v63 = v11;
    unint64_t v64 = v15;
    double v65 = v16;
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    float v16 = v65;
    unint64_t v15 = v64;
    LODWORD(v11) = v63;
    a2 = v62;
  }
  if (*((unsigned char *)v16 + 3141))
  {
    unint64_t v66 = v15;
    int v67 = v11;
    uint64_t v68 = a2;
    uint64_t v69 = x_stream_finish((uint64_t)&v87);
    if (v69)
    {
      int v70 = v69;
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unint64_t v71 = x_log_category_frame_rate;
        if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316418;
          uint64_t v91 = v68;
          __int16 v92 = 2048;
          unint64_t v93 = v66;
          __int16 v94 = 1024;
          int v95 = v67;
          __int16 v96 = 1024;
          int v97 = v12;
          __int16 v98 = 1024;
          int v99 = v44;
          __int16 v100 = 2080;
          double v101 = v70;
          _os_log_impl(&dword_184668000, v71, OS_LOG_TYPE_DEFAULT, "%sarbitration among %ld clients yields min:%u max:%u preferred:%u\n%s", buf, 0x32u);
        }
      }
      free(v70);
    }
    LODWORD(v11) = v67;
  }
  return v11 | (unint64_t)(v12 << 32);
}

float CAFrameIntervalRangeToFrameRateRange(CAFrameIntervalRange a1, double a2)
{
  unsigned int var2 = a1.var2;
  unsigned int var0 = a1.var0;
  float v5 = (float)CAFrameIntervalToFrameRate(a1.var1, a2);
  CAFrameIntervalToFrameRate(var0, a2);
  CAFrameIntervalToFrameRate(var2, a2);
  return v5;
}

int CAFrameIntervalToFrameRate(int result, double a2)
{
  if (result < 0) {
    __assert_rtn("CAFrameIntervalToFrameRate", "CATimingReference.cpp", 443, "frame_interval >= 0");
  }
  if (result)
  {
    float v2 = 1.0 / ((double)result * a2);
    return llroundf(v2);
  }
  return result;
}

void std::vector<CAFrameIntervalRange>::insert(uint64_t a1, char *__src, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v6 = *(char **)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v12 = *(char **)a1;
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v6[-*(void *)a1] >> 2) + 1;
    if (v13 > 0x1555555555555555) {
      abort();
    }
    uint64_t v14 = __src - v12;
    int64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((__src - v12) >> 2);
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (void)v12) >> 2);
    if (2 * v16 > v13) {
      unint64_t v13 = 2 * v16;
    }
    if (v16 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v17 = 0x1555555555555555;
    }
    else {
      unint64_t v17 = v13;
    }
    if (v17)
    {
      uint64_t v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CAFrameIntervalRange>>(v17);
    }
    else
    {
      uint64_t v19 = 0;
      uint64_t v18 = 0;
    }
    uint64_t v22 = &v19[12 * v15];
    uint64_t v23 = &v19[12 * v18];
    if (v15 == v18)
    {
      if (v14 < 1)
      {
        if (v12 == __src) {
          unint64_t v25 = 1;
        }
        else {
          unint64_t v25 = 2 * v15;
        }
        int v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CAFrameIntervalRange>>(v25);
        uint64_t v22 = &v26[12 * (v25 >> 2)];
        uint64_t v23 = &v26[12 * v27];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        uint64_t v24 = v15 + 2;
        if (v15 >= -1) {
          uint64_t v24 = v15 + 1;
        }
        v22 -= 12 * (v24 >> 1);
      }
    }
    uint64_t v28 = *(void *)v3;
    *((_DWORD *)v22 + 2) = *(_DWORD *)(v3 + 8);
    *(void *)uint64_t v22 = v28;
    uint8x8_t v29 = *(char **)a1;
    unsigned int v30 = v22;
    if (*(char **)a1 != __src)
    {
      unsigned int v31 = __src;
      unsigned int v30 = v22;
      do
      {
        uint64_t v32 = *(void *)(v31 - 12);
        v31 -= 12;
        int v33 = *((_DWORD *)v31 + 2);
        *(void *)(v30 - 12) = v32;
        v30 -= 12;
        *((_DWORD *)v30 + 2) = v33;
      }
      while (v31 != v29);
    }
    uint64_t v34 = *(unsigned char **)(a1 + 8);
    uint64_t v35 = v34 - __src;
    if (v34 != __src) {
      memmove(v22 + 12, __src, v34 - __src);
    }
    unint64_t v36 = *(char **)a1;
    *(void *)a1 = v30;
    *(void *)(a1 + 8) = &v22[v35 + 12];
    *(void *)(a1 + 16) = v23;
    if (v36)
    {
      operator delete(v36);
    }
  }
  else if (__src == v6)
  {
    uint64_t v21 = *(void *)a3;
    *((_DWORD *)__src + 2) = *(_DWORD *)(a3 + 8);
    *(void *)__long long src = v21;
    *(void *)(a1 + 8) = __src + 12;
  }
  else
  {
    double v8 = __src + 12;
    uint64_t v9 = v6 - 12;
    uint64_t v10 = *(void *)(a1 + 8);
    while (v9 < v6)
    {
      uint64_t v11 = *(void *)v9;
      *(_DWORD *)(v10 + 8) = *((_DWORD *)v9 + 2);
      *(void *)uint64_t v10 = v11;
      v10 += 12;
      v9 += 12;
    }
    *(void *)(a1 + 8) = v10;
    if (v6 != v8) {
      memmove(__src + 12, __src, v6 - v8);
    }
    if ((unint64_t)__src <= v3) {
      v3 += 12 * (*(void *)(a1 + 8) > v3);
    }
    uint64_t v20 = *(void *)v3;
    *((_DWORD *)__src + 2) = *(_DWORD *)(v3 + 8);
    *(void *)__long long src = v20;
  }
}

void sub_184707CA0(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CA::Render::Timing::inverse_map_time(uint64_t this, double *a2, double a3)
{
  double v3 = *(double *)(this + 32);
  if ((*(void *)&v3 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    float v4 = *(float *)(this + 16);
  }
  else
  {
    float v4 = *(float *)(this + 16);
    double v5 = floor((*(double *)(this + 48) + (a3 - *(double *)(this + 40)) * v4) / v3);
    double v6 = *a2;
    if (*(unsigned char *)(this + 13) & 1) != 0 && ((int)v5) {
      double v6 = v3 - v6;
    }
    double v7 = v6 + v5 * v3;
    if ((*(void *)&v7 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL) {
      *a2 = v7;
    }
  }
  if (v4 == 0.0
    || (v4 != 1.0 ? (float v8 = 1.0 / v4) : (float v8 = v4),
        a3 = *(double *)(this + 40) + (*a2 - *(double *)(this + 48)) * v8,
        (*(void *)&a3 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL))
  {
    *a2 = a3;
  }
  return this;
}

uint64_t CA::Render::Animation::inverse_map_time(uint64_t this, double *a2, double a3)
{
  uint64_t v3 = *(void *)(this + 40);
  if (v3)
  {
    double v6 = *(double *)(v3 + 32);
    uint64_t v7 = *(void *)(this + 48);
    if (v7)
    {
      double v8 = *a2;
      if (*(_DWORD *)(v7 + 16) == 4) {
        double v8 = CA::Render::TimingFunction::evaluate_inverse((CA::Render::TimingFunction *)(v7 + 24), a2, v8, 0.001 / v6);
      }
    }
    else
    {
      double v8 = *a2;
    }
    *a2 = v8 * v6;
    return CA::Render::Timing::inverse_map_time(v3, a2, a3);
  }
  return this;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CAFrameIntervalRange>>(unint64_t a1)
{
  if (a1 >= 0x1555555555555556) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(12 * a1);
}

double CA::Render::TimingFunction::evaluate_inverse(CA::Render::TimingFunction *this, const double *a2, double a3, double a4)
{
  double v4 = *((double *)this + 1);
  double v5 = v4 * 3.0;
  double v6 = (*((double *)this + 3) - v4) * 3.0;
  double v7 = v6 - v4 * 3.0;
  double v8 = 1.0 - v6;
  int v9 = 8;
  double v10 = a3;
  while (1)
  {
    double v11 = -(a3 - (v5 + (v7 + v10 * v8) * v10) * v10);
    if (fabs(v11) < a4) {
      break;
    }
    double v12 = v5 + (v7 + v7 + v8 * 3.0 * v10) * v10;
    if (fabs(v12) >= 0.000001)
    {
      double v10 = v10 - v11 / v12;
      if (--v9) {
        continue;
      }
    }
    double v10 = 0.0;
    if (a3 >= 0.0)
    {
      double v10 = 1.0;
      if (a3 <= 1.0)
      {
        double v13 = 0.0;
        double v14 = 1.0;
        int v15 = -1025;
        double v10 = a3;
        do
        {
          if (__CFADD__(v15++, 1)) {
            break;
          }
          double v17 = -(a3 - (v5 + (v7 + v10 * v8) * v10) * v10);
          if (fabs(v17) < a4) {
            break;
          }
          if (v17 >= 0.0) {
            double v14 = v10;
          }
          else {
            double v13 = v10;
          }
          double v10 = v13 + (v14 - v13) * 0.5;
        }
        while (v13 < v14);
      }
    }
    return (*(double *)this * 3.0
          + ((*((double *)this + 2) - *(double *)this) * 3.0
           - *(double *)this * 3.0
           + v10 * (1.0 - (*((double *)this + 2) - *(double *)this) * 3.0))
          * v10)
         * v10;
  }
  return (*(double *)this * 3.0
        + ((*((double *)this + 2) - *(double *)this) * 3.0
         - *(double *)this * 3.0
         + v10 * (1.0 - (*((double *)this + 2) - *(double *)this) * 3.0))
        * v10)
       * v10;
}

double CA::Render::SpringAnimation::inverse_delta_time_function(CA::Render::SpringAnimation *this, double a2, double a3)
{
  uint64_t v5 = *((void *)this + 5);
  if (v5) {
    double v6 = *(double *)(v5 + 32);
  }
  else {
    double v6 = INFINITY;
  }
  double v7 = 0.0;
  if (*((double *)this + 25) >= 1.0)
  {
    double v8 = v6 * a3;
    double v9 = *((double *)this + 24);
    long double v10 = exp(-(v6 * a3 * v9));
    double v11 = *((double *)this + 28);
    double v12 = (*((double *)this + 27) * v9 + v11 * (v9 * v8 + -1.0)) * v10;
    double v13 = v10 * v9;
    if (v12 >= 0.0) {
      double v14 = v13;
    }
    else {
      double v14 = *((double *)this + 28);
    }
    if (v11 <= v9) {
      double v14 = v13;
    }
    if (v12 > 0.0) {
      double v13 = -v11;
    }
    if (v11 >= 0.0) {
      double v13 = v14;
    }
    double v7 = fmax(a2 / fmax(fabs(v12), v13), 0.0);
  }
  return v7 / v6;
}

double CA::Render::get_position_range(int a1, uint64_t a2, unint64_t a3, unint64_t a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  if (a2 != 1 || !a3 || !a4)
  {
    if (a2) {
      return INFINITY;
    }
    if (a3 < 2) {
      return INFINITY;
    }
    double v10 = a9;
    if (a4 < 2) {
      return INFINITY;
    }
    return sqrt((v10 - a7) * a5 * ((v10 - a7) * a5) + (a10 - a8) * a6 * ((a10 - a8) * a6));
  }
  a10 = 0.0;
  if (a1 > 606)
  {
    if (a1 == 607)
    {
      double v10 = a9;
      a8 = 0.0;
      return sqrt((v10 - a7) * a5 * ((v10 - a7) * a5) + (a10 - a8) * a6 * ((a10 - a8) * a6));
    }
    if (a1 != 611) {
      return INFINITY;
    }
    goto LABEL_14;
  }
  if (a1 == 256)
  {
LABEL_14:
    double v10 = 0.0;
    a10 = a9;
    a8 = a7;
    a7 = 0.0;
    return sqrt((v10 - a7) * a5 * ((v10 - a7) * a5) + (a10 - a8) * a6 * ((a10 - a8) * a6));
  }
  double v10 = a9;
  a8 = 0.0;
  if (a1 != 604) {
    return INFINITY;
  }
  return sqrt((v10 - a7) * a5 * ((v10 - a7) * a5) + (a10 - a8) * a6 * ((a10 - a8) * a6));
}

atomic_uint *CA::Render::ShapeLayer::invalidate_stroke_path(CA::Render::ShapeLayer *this)
{
  float v2 = (atomic_uint *)*((void *)this + 17);
  if (v2)
  {
    if (atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
    }
    *((void *)this + 17) = 0;
  }
  *((void *)this + 18) = 0x3FF0000000000000;
  uint64_t result = (atomic_uint *)*((void *)this + 16);
  if (result)
  {
    if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      uint64_t result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
    }
    *((void *)this + 16) = 0;
  }
  return result;
}

void sub_184708C60(_Unwind_Exception *exception_object)
{
  if (atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CA::Render::Layer::set_subclass(uint64_t this, CA::Render::LayerSubclass *a2)
{
  float v2 = a2;
  if (a2 || *(void *)(this + 128))
  {
    uint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    this = *v3;
    if ((CA::Render::LayerSubclass *)*v3 != v2)
    {
      if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)((char *)v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v2 + 2, 1u))
        {
          float v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      uint64_t *v3 = (uint64_t)v2;
    }
  }
  return this;
}

void sub_1847091DC(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1847099C4(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

CALayer *CA::Layer::mask(CA::Layer *this)
{
  int v2 = *((_DWORD *)this + 1) & 0x60000;
  if (!v2) {
    return (CALayer *)*((void *)this + 4);
  }
  uint64_t v3 = CA::Transaction::ensure_compat(this);
  uint64_t result = (CALayer *)CA::Layer::model_layer(this, v3);
  if (result)
  {
    uint64_t result = (CALayer *)result[1].super.isa;
    if (v2 == 0x20000 && result != 0)
    {
      layer = (CA::Layer *)result->_attr.layer;
      return CA::Layer::presentation_layer(layer, (CA::Transaction::Shared **)v3);
    }
  }
  return result;
}

void sub_184709D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9)
{
}

void sub_18470A234(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_18470A65C(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_18470B264(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Layer::get_frame_transform(CA::Layer *this, CGAffineTransform *a2, char a3)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  double v6 = (CA::Layer **)*((void *)this + 2);
  double v8 = CA::Transaction::ensure_compat(this);
  int v9 = *((_DWORD *)v8 + 25);
  *((_DWORD *)v8 + 25) = v9 + 1;
  if (!v9) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  if ((*((unsigned char *)this + 56) & 8) != 0)
  {
    [v6 anchorPoint];
    _Q0.f64[1] = v15;
  }
  else
  {
    __asm { FMOV            V0.2D, #0.5 }
  }
  float64x2_t v16 = vmulq_f64(*((float64x2_t *)this + 7), _Q0);
  if ((*((unsigned char *)this + 55) & 0x10) != 0)
  {
    float64x2_t v37 = v16;
    if (v6)
    {
      [v6 transform];
    }
    else
    {
      float64x2_t v49 = 0u;
      long long v50 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v46 = 0u;
      memset(&v45, 0, sizeof(v45));
    }
    long long v53 = v47;
    long long v54 = v48;
    float64x2_t v55 = v49;
    long long v56 = v50;
    CGAffineTransform v51 = v45;
    long long v52 = v46;
    if (CA::Mat4Impl::mat4_is_affine((CA::Mat4Impl *)&v51, v7))
    {
      float64x2_t v18 = *(float64x2_t *)&v51.a;
      float64x2_t v19 = *(float64x2_t *)&v51.tx;
      *(_OWORD *)&a2->a = *(_OWORD *)&v51.a;
      *(float64x2_t *)&a2->c = v19;
      float64x2_t v20 = v55;
      *(float64x2_t *)&a2->tx = v55;
    }
    else
    {
      long long v22 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
      long long v21 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
      *(_OWORD *)&a2->a = *MEMORY[0x1E4F1DAB8];
      *(_OWORD *)&a2->c = v22;
      *(_OWORD *)&a2->tx = v21;
      float64x2_t v18 = *(float64x2_t *)&a2->a;
      float64x2_t v19 = *(float64x2_t *)&a2->c;
      float64x2_t v20 = *(float64x2_t *)&a2->tx;
    }
    float64x2_t v17 = vaddq_f64(vsubq_f64(*((float64x2_t *)this + 5), vmlaq_n_f64(vmulq_laneq_f64(v19, v37, 1), v18, v37.f64[0])), v20);
  }
  else
  {
    a2->a = 1.0;
    a2->b = 0.0;
    a2->c = 0.0;
    a2->d = 1.0;
    float64x2_t v17 = vsubq_f64(*((float64x2_t *)this + 5), v16);
  }
  *(float64x2_t *)&a2->tx = v17;
  if ((a3 & 1) == 0)
  {
    if (v6)
    {
      uint64_t v23 = CA::Layer::superlayer(v6[2], v8);
      if (v23)
      {
        if (dyld_program_sdk_at_least())
        {
          layer = v23->_attr.layer;
          if ((*((unsigned char *)layer + 55) & 0x20) != 0)
          {
            if ((*((unsigned char *)layer + 56) & 8) != 0)
            {
              [(CALayer *)v23 anchorPoint];
              _Q0.f64[1] = v26;
            }
            else
            {
              __asm { FMOV            V0.2D, #0.5 }
            }
            float64x2_t v38 = vmlaq_f64(*((float64x2_t *)layer + 6), _Q0, *((float64x2_t *)layer + 7));
            *(float64x2_t *)&a2->tx = vsubq_f64(*(float64x2_t *)&a2->tx, v38);
            [(CALayer *)v23 sublayerTransform];
            long long v53 = v47;
            long long v54 = v48;
            float64x2_t v55 = v49;
            long long v56 = v50;
            CGAffineTransform v51 = v45;
            long long v52 = v46;
            if (CA::Mat4Impl::mat4_is_affine((CA::Mat4Impl *)&v51, v27))
            {
              long long v28 = *(_OWORD *)&a2->c;
              *(_OWORD *)&t1.a = *(_OWORD *)&a2->a;
              *(_OWORD *)&t1.c = v28;
              *(_OWORD *)&t1.tx = *(_OWORD *)&a2->tx;
              *(_OWORD *)&t2.a = *(_OWORD *)&v51.a;
              *(_OWORD *)&t2.c = *(_OWORD *)&v51.tx;
              *(float64x2_t *)&t2.tx = v55;
              CGAffineTransformConcat(&v45, &t1, &t2);
              long long v29 = *(_OWORD *)&v45.c;
              *(_OWORD *)&a2->a = *(_OWORD *)&v45.a;
              *(_OWORD *)&a2->c = v29;
              *(_OWORD *)&a2->tx = *(_OWORD *)&v45.tx;
            }
            *(float64x2_t *)&a2->tx = vaddq_f64(*(float64x2_t *)&a2->tx, v39);
          }
        }
      }
    }
  }
  int v30 = *((_DWORD *)this + 12);
  if ((v30 & 0x800) != 0)
  {
    CGFloat v31 = *((double *)this + 15);
    v42.b = 0.0;
    v42.c = 0.0;
    v42.a = 1.0;
    *(_OWORD *)&v42.d = xmmword_184997E00;
    v42.ty = v31;
    long long v32 = *(_OWORD *)&a2->c;
    *(_OWORD *)&v41.a = *(_OWORD *)&a2->a;
    *(_OWORD *)&v41.c = v32;
    *(_OWORD *)&v41.tx = *(_OWORD *)&a2->tx;
    CGAffineTransformConcat(&v45, &v42, &v41);
    long long v33 = *(_OWORD *)&v45.c;
    *(_OWORD *)&a2->a = *(_OWORD *)&v45.a;
    *(_OWORD *)&a2->c = v33;
    *(_OWORD *)&a2->tx = *(_OWORD *)&v45.tx;
    int v30 = *((_DWORD *)this + 12);
  }
  if ((v30 & 0x10000000) != 0)
  {
    float64x2_t v36 = *(float64x2_t *)&a2->a;
    *(float64x2_t *)&a2->tx = vmlaq_n_f64(*(float64x2_t *)&a2->tx, *(float64x2_t *)&a2->a, *((double *)this + 14));
    *(float64x2_t *)&a2->a = vnegq_f64(v36);
  }
  if ((*((unsigned char *)this + 55) & 4) != 0)
  {
    long long v34 = *(_OWORD *)&a2->c;
    *(_OWORD *)&v40.a = *(_OWORD *)&a2->a;
    *(_OWORD *)&v40.c = v34;
    *(_OWORD *)&v40.tx = *(_OWORD *)&a2->tx;
    CGAffineTransformTranslate(&v45, &v40, -*((double *)this + 12), -*((double *)this + 13));
    long long v35 = *(_OWORD *)&v45.c;
    *(_OWORD *)&a2->a = *(_OWORD *)&v45.a;
    *(_OWORD *)&a2->c = v35;
    *(_OWORD *)&a2->tx = *(_OWORD *)&v45.tx;
  }
  CA::Transaction::unlock(v8);
}

void sub_18470B6C4(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA_CGAffineTransformIsValid()
{
  if (!CGFloatIsValid()
    || !CGFloatIsValid()
    || !CGFloatIsValid()
    || !CGFloatIsValid()
    || !CGFloatIsValid())
  {
    return 0;
  }

  return CGFloatIsValid();
}

double CALayer_getter_kCAValueRect(CA::Transaction *a1, unsigned int a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  memset(v3, 0, sizeof(v3));
  CA::Layer::getter(a1, a2, (const CGAffineTransform *)0x15, (id *)v3);
  return *(double *)v3;
}

int8x16_t *CA::Render::Path::new_path(CGPathRef path, const CGPath *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!path) {
    return 0;
  }
  if (CA::Render::Path::_path_table)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Path::_path_lock);
    uint64_t v3 = x_hash_table_lookup(CA::Render::Path::_path_table, (uint64_t)path, 0);
    if (v3)
    {
      uint64_t v4 = (int8x16_t *)v3;
      if (atomic_fetch_add((atomic_uint *volatile)(v3 + 8), 1u))
      {
LABEL_12:
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Path::_path_lock);
        return v4;
      }
      atomic_fetch_add((atomic_uint *volatile)(v3 + 8), 0xFFFFFFFF);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Path::_path_lock);
  }
  uint64_t v19 = 1;
  int8x16_t v18 = 0uLL;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  CGPathApply(path, &v15, (CGPathApplierFunction)CA::Render::count_elements);
  if (!(_BYTE)v19)
  {
    if ((CA::Render::Path::new_path(CGPath const*,BOOL)::_before & 1) == 0)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        double v14 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184668000, v14, OS_LOG_TYPE_DEFAULT, "CoreAnimation: ignoring invalid path\n", buf, 2u);
        }
      }
      uint64_t v4 = 0;
      CA::Render::Path::new_path(CGPath const*,BOOL)::_before = 1;
      return v4;
    }
    return 0;
  }
  size_t v5 = v15 + 16 * v16 + 113;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  double v7 = (int8x16_t *)malloc_type_zone_malloc(malloc_zone, v5, 0x8BB15036uLL);
  uint64_t v4 = v7;
  if (v7)
  {
    unsigned __int32 v9 = v16;
    __int32 v8 = v17;
    __int32 v10 = v15;
    v7->i32[2] = 1;
    v7->i32[3] = 36;
    ++dword_1EB2ADE58;
    v7->i64[0] = (uint64_t)&unk_1ED02F0E0;
    v7[1].i32[0] = v8;
    v7[1].i32[1] = v10;
    v7[1].i32[2] = v9;
    v7[2].i64[0] = (uint64_t)v7[7].i64;
    v7[2].i64[1] = (uint64_t)v7[v9 + 7].i64;
    v7[3].i64[1] = 0;
    v7[4].i64[0] = 0;
    v7[3].i64[0] = (uint64_t)path;
    v7[3].i64[1] = (uint64_t)CGPathRetain(path);
    int8x16_t v18 = vextq_s8(v4[2], v4[2], 8uLL);
    CGPathApply(path, &v15, (CGPathApplierFunction)CA::Render::copy_elements);
    double v11 = (unsigned char *)v18.i64[0]++;
    *double v11 = 5;
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Path::_path_lock);
    double v12 = (int *)CA::Render::Path::_path_table;
    if (!CA::Render::Path::_path_table)
    {
      double v12 = (int *)x_hash_table_new_(0, 0, 0, 0, 0, 0);
      CA::Render::Path::_path_table = (uint64_t)v12;
    }
    hash_table_modify(v12, v4[3].i64[0], (uint64_t)v4, 0);
    goto LABEL_12;
  }
  return v4;
}

void CA_CGContextAddRoundRect(CGContext *a1, int a2, CGFloat a3, CGFloat a4, double a5, double a6, CGFloat a7)
{
  if (!CGRectIsNull(*(CGRect *)&a3) && (*(void *)&a7 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    if (a7 <= 0.0)
    {
      CGFloat v20 = a3;
      CGFloat v21 = a4;
      double v22 = a5;
      double v23 = a6;
      CGContextAddRect(a1, *(CGRect *)&v20);
    }
    else
    {
      if (a2)
      {
        CGFloat v14 = a3 + a5;
        CGFloat v15 = a4 + a6;
        CGFloat v48 = a7 * 1.528665;
        CGContextMoveToPoint(a1, a3, a7 * 1.528665 + a4);
        CGFloat v44 = a7 * 1.08849;
        CGFloat v37 = a7 * 1.08849 + a4;
        CGFloat v16 = a7 * 0.868407;
        CGFloat v36 = a7 * 0.868407 + a4;
        CGFloat v47 = a7 * 0.0749114;
        CGFloat v43 = a7 * 0.0749114 + a3;
        CGFloat y = a7 * 0.631494 + a4;
        CGContextAddCurveToPoint(a1, a3, v37, a3, v36, v43, y);
        CGFloat v29 = a7 * 0.16906;
        CGFloat v42 = a7 * 0.16906 + a3;
        CGFloat v30 = a7 * 0.372824;
        CGFloat cp2y = a7 * 0.372824 + a4;
        CGFloat cp1y = a7 * 0.16906 + a4;
        CGFloat v40 = a7 * 0.631494 + a3;
        CGFloat v41 = a7 * 0.372824 + a3;
        CGFloat v17 = a7 * 0.0749114 + a4;
        CGContextAddCurveToPoint(a1, v42, cp2y, v41, cp1y, v40, v17);
        CGFloat v27 = a7 * 0.868407;
        CGFloat v39 = a7 * 0.868407 + a3;
        CGFloat v38 = a7 * 1.08849 + a3;
        CGFloat v46 = a7 * 1.52866;
        CGContextAddCurveToPoint(a1, v39, a4, v38, a4, a7 * 1.52866 + a3, a4);
        CGContextAddLineToPoint(a1, v14 - a7 * 1.528665, a4);
        CGFloat v33 = v14 - a7 * 0.868407;
        CGFloat v34 = v14 - a7 * 1.08849;
        CGFloat v18 = a7 * 0.631494;
        CGFloat x = v14 - v18;
        CGContextAddCurveToPoint(a1, v14 - v44, a4, v14 - v16, a4, v14 - v18, v17);
        CGContextAddCurveToPoint(a1, v14 - v30, cp1y, v14 - v29, cp2y, v14 - v47, y);
        CGContextAddCurveToPoint(a1, v14, v36, v14, v37, v14, v46 + a4);
        CGContextAddLineToPoint(a1, v14, v15 - v48);
        CGFloat v45 = v15 - v44;
        CGFloat v19 = v15 - v18;
        CGContextAddCurveToPoint(a1, v14, v45, v14, v15 - v27, v14 - v47, v19);
        CGContextAddCurveToPoint(a1, v14 - v29, v15 - v30, v14 - v30, v15 - v29, x, v15 - v47);
        CGContextAddCurveToPoint(a1, v33, v15, v34, v15, v14 - v46, v15);
        CGContextAddLineToPoint(a1, v48 + a3, v15);
        CGContextAddCurveToPoint(a1, v38, v15, v39, v15, v40, v15 - v47);
        CGContextAddCurveToPoint(a1, v41, v15 - v29, v42, v15 - v30, v43, v19);
        CGContextAddCurveToPoint(a1, a3, v15 - v27, a3, v45, a3, v15 - v46);
      }
      else
      {
        CGFloat v24 = a3 + a7;
        CGContextMoveToPoint(a1, a3 + a7, a4);
        CGFloat v25 = a3 + a5 - a7;
        CGContextAddArc(a1, v25, a4 + a7, a7, 4.71238898, 0.0, 0);
        CGFloat v26 = a4 + a6 - a7;
        CGContextAddArc(a1, v25, v26, a7, 0.0, 1.57079633, 0);
        CGContextAddArc(a1, v24, v26, a7, 1.57079633, 3.14159265, 0);
        CGContextAddArc(a1, v24, a4 + a7, a7, 3.14159265, 4.71238898, 0);
      }
      CGContextClosePath(a1);
    }
  }
}

uint64_t CABackingStoreRetainFrontTexture(uint64_t a1, CGColorSpace *a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  CABackingStoreGetFrontTexture((CABackingStore *)a1, a2, v5);
  uint64_t v7 = v6;
  if (v6 && !atomic_fetch_add((atomic_uint *volatile)(v6 + 8), 1u))
  {
    uint64_t v7 = 0;
    atomic_fetch_add((atomic_uint *volatile)(v6 + 8), 0xFFFFFFFF);
  }
  pthread_mutex_unlock(v4);
  return v7;
}

float CABackingStoreGetFrontTexture(CABackingStore *a1, CGColorSpace *a2, float result)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  __int16 v3 = *((_WORD *)a1 + 246);
  if ((v3 & 0x100) == 0)
  {
    uint64_t v5 = *((void *)a1 + 53);
    if (v5)
    {
LABEL_62:
      uint64_t v43 = *((void *)a1 + 50);
      if (v43)
      {
        uint64_t result = *(float *)(v43 + 60);
        *(float *)(v5 + 56) = result;
      }
      return result;
    }
    uint64_t v7 = *((void *)a1 + 50);
    __int32 v8 = *(CA::Render::Shmem **)(v7 + 16);
    if (v8)
    {
      __int32 v10 = CA::Render::Shmem::copy_image(v8, *(CGColorSpace **)(v7 + 8));
    }
    else
    {
      uint64_t v11 = *(void *)(v7 + 24);
      if (!v11) {
        goto LABEL_61;
      }
      if ((v3 & 0x800) != 0)
      {
        uint64_t v12 = *(void *)(v11 + 72);
        if (v12)
        {
          CA::CG::Queue::flush(v12, 3, 1);
          __int16 v3 = *((_WORD *)a1 + 246);
        }
        *((_WORD *)a1 + 246) = v3 & 0xF7FF;
      }
      os_unfair_lock_lock((os_unfair_lock_t)(v11 + 12));
      if (*(unsigned char *)(v11 + 68))
      {
        __int32 v10 = 0;
      }
      else
      {
        CA::CG::IOSurfaceDrawable::ensure_shared_surface(v11);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        CGFloat v14 = (CA::Render::Surface *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x158uLL, 0x743898A5uLL);
        __int32 v10 = v14;
        if (v14) {
          CA::Render::Surface::Surface(v14, *(CA::Render::Surface **)(v11 + 104), 0x8000);
        }
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v11 + 12));
    }
    *((void *)a1 + 53) = v10;
    if (!v10) {
      return result;
    }
    *((_DWORD *)v10 + 3) |= 0x100000u;
    uint64_t v15 = *((void *)a1 + 53);
    uint64_t v16 = *(unsigned int *)(v15 + 16);
    uint64_t v17 = *((void *)a1 + 16);
    if (v17 != v16 || *((void *)a1 + 17) != *(_DWORD *)(v15 + 20))
    {
      if (*(unsigned char *)(v7 + 64))
      {
        uint64_t v18 = *((void *)a1 + 17);
        int v19 = *((_DWORD *)a1 + 38) - v18;
        int v20 = *(_DWORD *)(v15 + 20);
      }
      else
      {
        int v20 = *(_DWORD *)(v15 + 20);
        int v19 = v20 - *((_DWORD *)a1 + 38);
        uint64_t v18 = *((void *)a1 + 17);
      }
      *(_WORD *)(v15 + 24) = 0;
      *(_WORD *)(v15 + 26) = v19;
      *(_WORD *)(v15 + 28) = v16 - v17;
      *(_WORD *)(v15 + 30) = v20 - v19 - v18;
      *(_DWORD *)(v15 + 12) |= 0x4000u;
    }
    CGFloat v21 = *(CGColor **)(v7 + 32);
    if (v21)
    {
      long long v58 = 0uLL;
      CA::Render::convert_cgcolor_to_float(v21, a2, (CGColorSpace *)&v58, 0, v9);
      uint64_t result = *(float *)&v58;
      *(_OWORD *)(*((void *)a1 + 53) + 60) = v58;
    }
    if (!*((void *)a1 + 58))
    {
LABEL_61:
      uint64_t v5 = *((void *)a1 + 53);
      if (!v5) {
        return result;
      }
      goto LABEL_62;
    }
    unint64_t v22 = CA::Shape::new_shape();
    if (!CA::Shape::is_valid((CA::Shape *)v22))
    {
      uint64_t v57 = CA::Shape::dump((CA::Shape *)v22);
      x_log_crash("Shape: %s", v57);
      abort();
    }
    uint64_t v23 = *((void *)a1 + 53);
    unsigned int v24 = *(__int16 *)(v23 + 24);
    int v25 = *(__int16 *)(v23 + 26);
    int v26 = v25 | v24;
    if (v22)
    {
      if (!v26 || v22 == 1) {
        goto LABEL_60;
      }
      if (!(v25 | v24)) {
        goto LABEL_57;
      }
    }
    else
    {
      if (!v26) {
        goto LABEL_60;
      }
      int v27 = *(_DWORD *)(v22 + 4);
      if (v27 == 6) {
        goto LABEL_60;
      }
      if (v27 == 12)
      {
        unsigned int v28 = *(_DWORD *)(v22 + 32) - *(_DWORD *)(v22 + 28);
        unsigned int v29 = *(_DWORD *)(v22 + 36) - *(_DWORD *)(v22 + 20);
        if (v28 >= 0x3FFFFFFF && v29 > 0x3FFFFFFE) {
          goto LABEL_60;
        }
        if (v29 <= 0x3FFFFFFE) {
          int v30 = v25;
        }
        else {
          int v30 = 0;
        }
        if (v28 > 0x3FFFFFFE) {
          unsigned int v24 = 0;
        }
        else {
          int v25 = v30;
        }
      }
      if (*(_DWORD *)v22 == 1)
      {
        CGFloat v31 = (int32x2_t *)(v22 + 20);
        __int32 v32 = *(_DWORD *)(v22 + 20);
        if (v32 != 0x7FFFFFFF)
        {
          int32x2_t v33 = vdup_n_s32(v24);
          do
          {
            v31->i32[0] = v32 + v25;
            __int32 v34 = v31->i32[1];
            if ((v34 - 2) >= 2)
            {
              int v35 = (v34 - 2) >> 1;
              CGFloat v36 = v31 + 1;
              do
              {
                int32x2_t *v36 = vadd_s32(*v36, v33);
                ++v36;
                --v35;
              }
              while (v35);
              __int32 v34 = v31->i32[1];
            }
            CGFloat v31 = (int32x2_t *)((char *)v31 + 4 * v34);
            __int32 v32 = v31->i32[0];
          }
          while (v31->i32[0] != 0x7FFFFFFF);
        }
        goto LABEL_60;
      }
      if (!(v25 | v24)) {
        goto LABEL_57;
      }
      if ((v22 & 1) == 0)
      {
        uint64_t v38 = *(unsigned int *)(v22 + 4);
        if (v38 == 12)
        {
          unsigned int v39 = *(_DWORD *)(v22 + 32) - *(_DWORD *)(v22 + 28);
          unsigned int v40 = *(_DWORD *)(v22 + 36) - *(_DWORD *)(v22 + 20);
          if (v39 >= 0x3FFFFFFF && v40 >= 0x3FFFFFFF)
          {
LABEL_57:
            unint64_t v37 = CA::Shape::ref(v22);
            goto LABEL_58;
          }
          if (v40 <= 0x3FFFFFFE) {
            int v44 = v25;
          }
          else {
            int v44 = 0;
          }
          if (v39 <= 0x3FFFFFFE) {
            int v25 = v44;
          }
          else {
            unsigned int v24 = 0;
          }
        }
        else if ((v38 & 0x80000000) != 0)
        {
          CGFloat v41 = 0;
          goto LABEL_59;
        }
        CGFloat v45 = (malloc_zone_t *)get_malloc_zone();
        CGFloat v46 = malloc_type_zone_malloc(v45, 4 * v38, 0x8BB15036uLL);
        CGFloat v41 = v46;
        if (v46)
        {
          if (v38)
          {
            int v47 = v38;
            CGFloat v48 = (int *)v22;
            float64x2_t v49 = v46;
            do
            {
              int v50 = *v48++;
              *v49++ = v50;
              --v47;
            }
            while (v47);
          }
          *CGFloat v46 = 1;
          v46[2] = v38;
          CGAffineTransform v51 = (int32x2_t *)(v46 + 5);
          __int32 v52 = v46[5];
          if (v52 != 0x7FFFFFFF)
          {
            int32x2_t v53 = vdup_n_s32(v24);
            do
            {
              v51->i32[0] = v52 + v25;
              __int32 v54 = v51->i32[1];
              if ((v54 - 2) >= 2)
              {
                int v55 = (v54 - 2) >> 1;
                long long v56 = v51 + 1;
                do
                {
                  int32x2_t *v56 = vadd_s32(*v56, v53);
                  ++v56;
                  --v55;
                }
                while (v55);
                __int32 v54 = v51->i32[1];
              }
              CGAffineTransform v51 = (int32x2_t *)((char *)v51 + 4 * v54);
              __int32 v52 = v51->i32[0];
            }
            while (v51->i32[0] != 0x7FFFFFFF);
          }
        }
        goto LABEL_59;
      }
    }
    long long v58 = 0uLL;
    CA::Shape::get_bounds(v22, (int *)&v58);
    LODWORD(v58) = v58 + v24;
    DWORD1(v58) += v25;
    unint64_t v37 = CA::Shape::new_shape((unsigned int *)&v58);
LABEL_58:
    CGFloat v41 = (_DWORD *)v37;
LABEL_59:
    CA::Shape::unref((CA::Shape *)v22);
    unint64_t v22 = (unint64_t)v41;
LABEL_60:
    long long v58 = 0uLL;
    CA::Shape::get_bounds(v22, (int *)&v58);
    CGFloat v42 = (CA::Shape *)CA::Shape::new_shape((unsigned int *)&v58);
    CA::Render::Texture::set_dirty_shape(*((CA::Render::Texture **)a1 + 53), v42);
    CA::Shape::unref(v42);
    CA::Shape::unref((CA::Shape *)v22);
    CGSReleaseRegion();
    *((void *)a1 + 58) = 0;
    goto LABEL_61;
  }
  return result;
}

atomic_uint *copy_attr(atomic_uint *result, CFTypeRef *a2, int a3, uint64_t *a4)
{
  if ((a3 - 1) > 3) {
    return result;
  }
  atomic_uint v6 = (int)result;
  int v7 = *((_DWORD *)a4 + 4);
  __int32 v8 = (void *)*a2;
  if (!a2 || v7 != 588)
  {
LABEL_10:
    if (a2)
    {
      if (v7 == 372)
      {
        if (v8)
        {
          CFTypeID v14 = CFGetTypeID(v8);
          CFTypeID TypeID = CGImageGetTypeID();
          __int32 v8 = (void *)*a2;
          if (v14 == TypeID)
          {
            uint64_t v16 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
            if (v16 && (uint64_t v17 = *(void *)(v16 + 40)) != 0) {
              double v13 = *(CGImage **)(v17 + 112);
            }
            else {
              double v13 = (CGImage *)CAGetColorSpace(0x1Du);
            }
            double v18 = 1.0;
            int v19 = (CA::Render *)v8;
            uint64_t v20 = 6144;
            goto LABEL_22;
          }
        }
      }
    }
LABEL_17:
    uint64_t result = (atomic_uint *)objc_msgSend(v8, "CA_copyRenderValue");
    goto LABEL_23;
  }
  if (!v8) {
    goto LABEL_17;
  }
  CFTypeID v9 = CFGetTypeID(*a2);
  if (v9 != CGImageGetTypeID())
  {
    int v7 = *((_DWORD *)a4 + 4);
    __int32 v8 = (void *)*a2;
    goto LABEL_10;
  }
  __int32 v10 = (CA::Render *)*a2;
  uint64_t v11 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (v11 && (uint64_t v12 = *(void *)(v11 + 40)) != 0) {
    double v13 = *(CGImage **)(v12 + 112);
  }
  else {
    double v13 = (CGImage *)CAGetColorSpace(0x1Du);
  }
  double v18 = 1.0;
  int v19 = v10;
  uint64_t v20 = 1024;
LABEL_22:
  uint64_t result = (atomic_uint *)CA::Render::copy_image(v19, v13, (CGColorSpace *)v20, 0.0, v18);
LABEL_23:
  CGFloat v21 = result;
  if (result)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t result = (atomic_uint *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x20uLL, 0x743898A5uLL);
    if (result)
    {
      result[2] = 1;
      result[3] = 28;
      ++dword_1EB2ADE38;
      *(void *)uint64_t result = &unk_1ED02FFB8;
      result[4] = v6;
      uint64_t v23 = v21;
      if (!atomic_fetch_add(v21 + 2, 1u))
      {
        uint64_t v23 = 0;
        atomic_fetch_add(v21 + 2, 0xFFFFFFFF);
      }
      *((void *)result + 3) = v23;
    }
    uint64_t v25 = *a4;
    uint64_t v24 = a4[1];
    ++*a4;
    *(void *)(v24 + 8 * v25) = result;
    if (atomic_fetch_add(v21 + 2, 0xFFFFFFFF) == 1)
    {
      int v26 = *(uint64_t (**)(atomic_uint *))(*(void *)v21 + 16);
      return (atomic_uint *)v26(v21);
    }
  }
  return result;
}

atomic_uint *CA::Render::copy_render_array(const __CFArray *a1, int a2)
{
  uint64_t result = CA::Render::copy_render_object(a1, a2);
  if (result && *((unsigned char *)result + 12) != 1)
  {
    if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)result + 16))(result);
    }
    return 0;
  }
  return result;
}

_DWORD *CA::Render::copy_render_object(const __CFArray *a1, int a2)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(a1);
  if (!Count) {
    return 0;
  }
  CFIndex v5 = Count;
  size_t v6 = 8 * Count;
  if ((unint64_t)(8 * Count) > 0x1000)
  {
    int v7 = (char *)malloc_type_malloc(8 * Count, 0x8D3DBFD1uLL);
  }
  else
  {
    MEMORY[0x1F4188790](Count);
    int v7 = (char *)v20 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v7, v6);
  }
  v21.locatiounint64_t n = 0;
  v21.length = v5;
  CFArrayGetValues(a1, v21, (const void **)v7);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    int v9 = 0;
    __int32 v10 = v7;
    CFIndex v11 = v5;
    do
    {
      v10 += 8;
      objc_opt_class();
      v9 += objc_opt_isKindOfClass() & 1;
      --v11;
    }
    while (v11);
    __int32 v8 = CA::Render::Vector::new_vector((CA::Render::Vector *)(4 * v9), 0, v12);
    double v13 = v8 + 6;
    CFTypeID v14 = (void **)v7;
    do
    {
      uint64_t v15 = *v14;
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        [v15 _getPoints:v13];
      }
      v13 += 8;
      ++v14;
      --v5;
    }
    while (v5);
  }
  else
  {
    uint64_t v16 = 0;
    for (uint64_t i = 0; i != v5; ++i)
    {
      uint64_t v18 = objc_msgSend(*(id *)&v7[8 * i], "CA_copyRenderValue");
      if (v18)
      {
        if (a2 && *(unsigned __int8 *)(v18 + 12) != a2)
        {
          if (atomic_fetch_add((atomic_uint *volatile)(v18 + 8), 0xFFFFFFFF) == 1) {
            (*(void (**)(uint64_t))(*(void *)v18 + 16))(v18);
          }
        }
        else
        {
          *(void *)&v7[8 * (void)v16] = v18;
          uint64_t v16 = (CA::Render::Array *)((char *)v16 + 1);
        }
      }
    }
    __int32 v8 = CA::Render::Array::new_array(v16, v7, 0, 0);
  }
  if (v6 > 0x1000) {
    free(v7);
  }
  return v8;
}

uint64_t CA::Context::Generic::local_id(CA::Context::Generic *this)
{
  return *(unsigned int *)(*((void *)this + 1) + 8);
}

atomic_uint *CA::Render::String::new_string(const __CFString *this, const __CFString *a2)
{
  usedBufLen[1] = *MEMORY[0x1E4F143B8];
  if (!this) {
    return 0;
  }
  usedBufLen[0] = 0;
  v8.length = CFStringGetLength(this);
  v8.locatiounint64_t n = 0;
  CFStringGetBytes(this, v8, 0x8000100u, 0, 0, 0, 0, usedBufLen);
  uint64_t v4 = 0;
  if ((unint64_t)(usedBufLen[0] - 0x100000000) >= 0xFFFFFFFF00000001)
  {
    CFIndex v5 = CA::Render::String::new_string((CA::Render::String *)usedBufLen[0], 0, v3);
    uint64_t v4 = v5;
    if (v5)
    {
      if (!CFStringGetCString(this, (char *)v5 + 28, usedBufLen[0] + 1, 0x8000100u))
      {
        if (atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
        }
        return 0;
      }
    }
  }
  return v4;
}

_DWORD *CA::Render::String::decode(CA::Render::String *this, CA::Render::Decoder *a2)
{
  size_t v3 = CA::Render::Decoder::decode_int32(this);
  CFIndex v5 = CA::Render::String::new_string((CA::Render::String *)v3, 0, v4);
  size_t v6 = v5;
  if (v5) {
    CA::Render::Decoder::decode_bytes(this, v5 + 7, v3);
  }
  return v6;
}

_DWORD *CA::Render::String::new_string(CA::Render::String *this, const void *a2, const char *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if ((unint64_t)this <= 0x10000)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    size_t v6 = malloc_type_zone_malloc(malloc_zone, (size_t)this + 32, 0x8BB15036uLL);
    int v7 = v6;
    if (v6)
    {
      v6[2] = 1;
      v6[3] = 49;
      ++dword_1EB2ADE8C;
      *(void *)size_t v6 = &unk_1ED02F728;
      *((void *)v6 + 2) = 0;
      v6[6] = this;
      if (a2) {
        memcpy(v6 + 7, a2, (size_t)this);
      }
      *((unsigned char *)this + (void)v7 + 28) = 0;
    }
  }
  else
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      CFRange v8 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134217984;
        CFIndex v11 = this;
        _os_log_impl(&dword_184668000, v8, OS_LOG_TYPE_ERROR, "suspiciously long string: %zu", buf, 0xCu);
      }
    }
    return 0;
  }
  return v7;
}

uint64_t CA::AttrList::for_each(uint64_t result, uint64_t (*a2)(void, void *, uint64_t, uint64_t), uint64_t a3)
{
  if (result)
  {
    uint64_t v5 = result;
    do
    {
      unsigned int v6 = *(_DWORD *)(v5 + 8);
      uint64_t v7 = HIBYTE(v6) & 0x7F;
      CFRange v8 = (void *)(v5 + 16);
      switch((int)v7)
      {
        case 6:
        case 7:
        case 9:
        case 11:
        case 13:
          uint64_t v7 = 13;
          break;
        case 8:
        case 10:
        case 12:
        case 14:
          uint64_t v7 = 14;
          break;
        case 17:
        case 18:
          uint64_t v7 = 18;
          break;
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
          CFRange v8 = (void *)*v8;
          break;
        default:
          break;
      }
      uint64_t result = a2(v6 & 0xFFFFFF, v8, v7, a3);
      uint64_t v5 = *(void *)v5;
    }
    while (v5);
  }
  return result;
}

uint64_t animation_property_flags(__CFString *a1, CALayer *a2)
{
  uint64_t AtomInKeyPath = CAInternFirstAtomInKeyPath(a1);
  if (!AtomInKeyPath) {
    return 0;
  }
  int v5 = AtomInKeyPath;
  if ([(CALayer *)a2 _renderLayerDefinesProperty:AtomInKeyPath]) {
    unsigned int v6 = 1;
  }
  else {
    unsigned int v6 = 2;
  }
  Class = object_getClass(a2);
  if (CAObject_needsLayoutForKey(Class, v5)) {
    v6 |= 4u;
  }
  if (CAObject_needsDisplayForKey(Class, v5)) {
    uint64_t v8 = v6 | 8;
  }
  else {
    uint64_t v8 = v6;
  }
  if (v5 == 547)
  {
    [(__CFString *)a1 rangeOfString:@"."];
    if (v9) {
      return v8;
    }
    else {
      return v8 | 0x10;
    }
  }
  return v8;
}

uint64_t CAInternFirstAtomInKeyPath(const __CFString *a1)
{
  if (!a1) {
    return 0;
  }
  CFRange v2 = CFStringFind(a1, @".", 0);
  if (v2.length >= 1)
  {
    v8.length = v2.location;
    v8.locatiounint64_t n = 0;
    CFStringRef v3 = CFStringCreateWithSubstring(0, a1, v8);
    if (v3)
    {
      CFStringRef v4 = v3;
      uint64_t v5 = CAInternAtom(v3, 0);
      CFRelease(v4);
      return v5;
    }
    return 0;
  }

  return CAInternAtom(a1, 0);
}

uint64_t CAObject_needsDisplayForKey(objc_class *a1, int a2)
{
  uint64_t result = classDescription(a1);
  if (result) {
    return *(_WORD *)(result + 30)
  }
        && CAAtomIndexInArray(*(unsigned __int16 *)(result + 30), *(void *)(result + 40), a2) != -1;
  return result;
}

uint64_t CAObject_needsLayoutForKey(objc_class *a1, int a2)
{
  uint64_t result = classDescription(a1);
  if (result) {
    return *(_WORD *)(result + 28)
  }
        && CAAtomIndexInArray(*(unsigned __int16 *)(result + 28), *(void *)(result + 32), a2) != -1;
  return result;
}

void sub_18470EB78(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void CA::Layer::add_animation(atomic_uint *this, CAAnimation *a2, __CFString *a3)
{
  unsigned int v6 = *(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (!v6) {
    unsigned int v6 = CA::Transaction::create((CA::Transaction *)this);
  }
  a2->_flags |= 1u;
  int v7 = v6[25];
  v6[25] = v7 + 1;
  if (!v7) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  CGFloat v31 = (uint64_t *)*((void *)this + 35);
  CFRange v8 = v31;
  uint64_t v9 = [(__CFString *)a3 hash];
  char v10 = 0;
  if (v31)
  {
    CFIndex v11 = (uint64_t *)&v31;
    do
    {
      if (v8[3] == v9 && [(id)v8[2] isEqualToString:a3])
      {
        if ((v8[7] & 0x3002) == 0 && !v8[6])
        {
          *CFIndex v11 = *v8;
          schedule_stop_callback((uint64_t)v8, (uint64_t *)&animation_state);
          free_non_deferred_animation(v8, 0);
          char v10 = 1;
          goto LABEL_14;
        }
        *((_WORD *)v8 + 28) |= 0x20u;
        char v10 = 1;
      }
      CFIndex v11 = v8;
      CFRange v8 = (uint64_t *)*v8;
    }
    while (v8);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  CFRange v8 = (uint64_t *)malloc_type_zone_malloc(malloc_zone, 0x40uLL, 0x8BB15036uLL);
LABEL_14:
  v8[1] = (uint64_t)CFRetain(a2);
  if (a3) {
    CFTypeRef v13 = CFRetain(a3);
  }
  else {
    CFTypeRef v13 = 0;
  }
  _OWORD v8[2] = (uint64_t)v13;
  v8[3] = v9;
  v8[4] = 0;
  *((_DWORD *)v8 + 10) = atomic_fetch_add(CA::Layer::add_animation(CAAnimation *,__CFString const*)::counter, 1u) + 1;
  __int16 v14 = [(CAAnimation *)a2 isRemovedOnCompletion];
  if (v10) {
    __int16 v15 = 64;
  }
  else {
    __int16 v15 = 0;
  }
  *((_WORD *)v8 + 28) = v15 | v14 | v8[7] & 0xFF80;
  *((_DWORD *)v8 + 15) = -892679478;
  unsigned int v16 = [(id)v8[1] _propertyFlagsForLayer:*((void *)this + 2)];
  int v17 = ((_WORD)v16 << 7) & 0xC00 | ((v16 & 1) << 8) & 0xFD7F | v8[7] & 0xF07F | (((v16 >> 2) & 1) << 9) | (((v16 >> 1) & 1) << 7);
  *((_WORD *)v8 + 28) = ((_WORD)v16 << 7) & 0xC00 | ((v16 & 1) << 8) & 0xFD7F | v8[7] & 0xF07F | (((v16 >> 2) & 1) << 9) | (((v16 >> 1) & 1) << 7);
  if (((v16 << 6) & 0x80) != 0 && (((_WORD)v16 << 7) & 0x200) != 0)
  {
    atomic_fetch_or(this + 1, 0x1000000u);
    int v17 = *((unsigned __int16 *)v8 + 28);
  }
  if ((~v17 & 0x480) == 0) {
    atomic_fetch_or(this + 1, 0x800000u);
  }
  uint64_t v18 = [(CAAnimation *)a2 delegate];
  if (v18) {
    __int16 v19 = v8[7] & 0xCFFF | (lookup_delegate_methods((CA::Transaction *)v6, v18) >> 6 << 12);
  }
  else {
    __int16 v19 = v8[7] & 0xCFFF;
  }
  *((_WORD *)v8 + 28) = v19;
  uint64_t v20 = v6 + 22;
  CFRange v21 = v6 + 22;
  while (1)
  {
    CFRange v21 = *(atomic_uint **)v21;
    if (!v21) {
      break;
    }
    if (*((void *)v21 + 1))
    {
      while (1)
      {
        uint64_t v20 = (void *)*v20;
        if (!v20) {
          break;
        }
        CFRange v21 = (atomic_uint *)v20[1];
        if (v21) {
          goto LABEL_35;
        }
      }
      CFRange v21 = 0;
LABEL_35:
      atomic_fetch_add(v21, 1u);
      break;
    }
  }
  void v8[6] = (uint64_t)v21;
  uint64_t v22 = (uint64_t)v31;
  if (!v31)
  {
    CGFloat v31 = v8;
    *CFRange v8 = 0;
    goto LABEL_62;
  }
  uint64_t v23 = CAMediaTimingCopyRenderTiming((unint64_t)a2);
  uint64_t v24 = (uint64_t *)&v31;
  while (1)
  {
    uint64_t v25 = (uint64_t *)v22;
    uint64_t v26 = CAMediaTimingCopyRenderTiming(*(void *)(v22 + 8));
    double v27 = 0.0;
    double v28 = 0.0;
    if (v23) {
      double v28 = *(double *)(v23 + 40);
    }
    if (v26) {
      double v27 = *(double *)(v26 + 40);
    }
    if (v28 >= v27)
    {
      if (v28 <= v27)
      {
        if (*((_DWORD *)v8 + 10) >= *(_DWORD *)(v22 + 40)) {
          int v29 = 0;
        }
        else {
          int v29 = 5;
        }
        if (!v26) {
          goto LABEL_54;
        }
      }
      else
      {
        int v29 = 7;
        if (!v26) {
          goto LABEL_54;
        }
      }
    }
    else
    {
      int v29 = 5;
      if (!v26) {
        goto LABEL_54;
      }
    }
    if (atomic_fetch_add((atomic_uint *volatile)(v26 + 8), 0xFFFFFFFF) == 1) {
      (*(void (**)(uint64_t))(*(void *)v26 + 16))(v26);
    }
LABEL_54:
    if (v29 == 5) {
      break;
    }
    uint64_t v22 = *v25;
    uint64_t v24 = v25;
    if (!*v25)
    {
      uint64_t v30 = 0;
      goto LABEL_59;
    }
  }
  uint64_t v30 = *v24;
  uint64_t v25 = v24;
LABEL_59:
  *CFRange v8 = v30;
  *uint64_t v25 = (uint64_t)v8;
  if (v23 && atomic_fetch_add((atomic_uint *volatile)(v23 + 8), 0xFFFFFFFF) == 1) {
    (*(void (**)(uint64_t))(*(void *)v23 + 16))(v23);
  }
LABEL_62:
  CA::Layer::set_animations(this, (uint64_t)v31);
  CA::Layer::mark_animations((CA::Layer *)this, (CA::Transaction *)v6, 1);

  CA::Transaction::unlock((CA::Transaction *)v6);
}

void sub_18470F1A8(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Layer::mark_animations(CA::Layer *this, CA::Transaction *a2, int a3)
{
  BOOL v4 = a3 == 0;
  if (a3) {
    int v5 = 2099210;
  }
  else {
    int v5 = 2099208;
  }
  if (v4) {
    int v6 = 2064;
  }
  else {
    int v6 = 2068;
  }
  CA::Layer::mark(this, a2, v5, v6);
  if (!**((_DWORD **)a2 + 13))
  {
    CA::Transaction::ensure_implicit(a2, 1);
  }
}

void CA::Layer::set_delegate(CA::Layer *this, objc_object *a2, int a3)
{
  v11[1] = *(objc_object **)MEMORY[0x1E4F143B8];
  int v6 = CA::Transaction::ensure_compat(this);
  int v7 = *((_DWORD *)v6 + 25);
  *((_DWORD *)v6 + 25) = v7 + 1;
  if (!v7) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  if (X::Weak<objc_object *>::operator==((uint64_t)this + 128, a2))
  {
    uint64_t v9 = (char *)this + 40;
  }
  else
  {
    v11[0] = 0;
    CA::Layer::begin_change(this, v6, @"delegate", (objc_object *)v11, v8);
    uint64_t v9 = CA::Layer::writable_state(this, v6);
    CA::Layer::State::set_delegate((CA::Layer::State *)v9, v6, a2, a3);
    CA::Layer::end_change((id *)this, v6, 165, (objc_object *)@"delegate", v11[0]);
  }
  if ((v9[18] & 0x10) == 0)
  {
    char v10 = CA::Layer::writable_state(this, v6);
    *((_DWORD *)v10 + 4) |= 0x100000u;
  }

  CA::Transaction::unlock(v6);
}

void sub_18470F450(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::Layer::State::set_delegate(CA::Layer::State *this, CA::Transaction *a2, objc_object *a3, int a4)
{
  CFRange v8 = (id *)((char *)this + 88);
  uint64_t result = X::Weak<objc_object *>::operator==((uint64_t)this + 88, a3);
  if ((result & 1) == 0)
  {
    uint64_t result = (uint64_t)X::WeakDetails::Ptr::set(v8, a3, a4);
    if (a3)
    {
      uint64_t result = lookup_delegate_methods(a2, a3);
      if ((result & 0x20) != 0) {
        int v10 = *((_DWORD *)this + 4) & 0xFFFE0FFF | ((result & 0x1F) << 12) | 0x20000;
      }
      else {
        int v10 = *((_DWORD *)this + 4) & 0xFFFC0FFF | ((result & 0x1F) << 12) & 0xFFFDFFFF;
      }
    }
    else
    {
      int v10 = *((_DWORD *)this + 4) & 0xFFFC0FFF;
    }
    *((_DWORD *)this + 4) = v10;
  }
  return result;
}

BOOL X::Weak<objc_object *>::operator==(uint64_t a1, id a2)
{
  if (*(unsigned char *)(a1 + 8)) {
    id WeakRetained = objc_loadWeakRetained((id *)a1);
  }
  else {
    id WeakRetained = *(id *)a1;
  }
  BOOL v4 = WeakRetained == a2;

  return v4;
}

CA::Layer::State *CA::Layer::State::State(CA::Layer::State *this, const CA::Layer::State *a2, CA::Transaction *a3)
{
  *(_DWORD *)this = *(_DWORD *)a2;
  *((void *)this + 4) = 0;
  long long v6 = *(_OWORD *)((char *)a2 + 40);
  *((void *)this + 11) = 0;
  int v7 = (id *)((char *)this + 88);
  *(_OWORD *)((char *)this + 40) = v6;
  *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 56);
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)((char *)a2 + 72);
  CFRange v8 = (id *)((char *)a2 + 88);
  *((unsigned char *)v7 + 8) = 0;
  if (*((unsigned char *)a2 + 96))
  {
    id WeakRetained = objc_loadWeakRetained(v8);
    if (WeakRetained)
    {
      int v10 = WeakRetained;
      X::WeakDetails::Ptr::set(v7, WeakRetained, 1);
    }
  }
  else
  {
    X::WeakDetails::Ptr::set(v7, *v8, 0);
  }
  CFTypeRef v11 = (CFTypeRef)*((void *)a2 + 13);
  if (v11) {
    CFTypeRef v11 = CFRetain(v11);
  }
  *((void *)this + 13) = v11;
  uint64_t v12 = (CA::AttrList *)*((void *)a2 + 4);
  if (v12)
  {
    int v13 = *((_DWORD *)a3 + 25);
    *((_DWORD *)a3 + 25) = v13 + 1;
    if (v13
      || (os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock),
          (uint64_t v12 = (CA::AttrList *)*((void *)a2 + 4)) != 0))
    {
      uint64_t v14 = *((void *)v12 + 1) & 7;
      if (v14 == 7) {
        uint64_t v12 = (CA::AttrList *)CA::AttrList::copy_(v12);
      }
      else {
        *((void *)v12 + 1) = *((void *)v12 + 1) & 0xFFFFFFFFFFFFFFF8 | (v14 + 1);
      }
    }
    *((void *)this + 4) = v12;
    CA::Transaction::unlock(a3);
  }
  for (uint64_t i = 4; i != 28; i += 4)
    *(_DWORD *)((char *)this + i) = *(_DWORD *)((char *)a2 + i);
  return this;
}

void sub_18470F7C8(_Unwind_Exception *exception_object)
{
  if (*v2)
  {
    if (*(unsigned char *)(v1 + 96)) {
      objc_storeWeakOrNil(v2, 0);
    }
    else {
      *CFRange v2 = 0;
    }
  }
  _Unwind_Resume(exception_object);
}

id *X::WeakDetails::Ptr::set(id *location, id obj, int a3)
{
  CFStringRef v3 = location;
  if (obj)
  {
    if (*((unsigned char *)location + 8))
    {
      if (!a3) {
        goto LABEL_13;
      }
    }
    else
    {
      *locatiounint64_t n = 0;
      if (!a3)
      {
LABEL_13:
        if (*v3)
        {
          if (*((unsigned char *)v3 + 8)) {
            locatiounint64_t n = (id *)objc_storeWeakOrNil(v3, 0);
          }
        }
        *((unsigned char *)v3 + 8) = 0;
        id *v3 = obj;
        return location;
      }
    }
    locatiounint64_t n = (id *)objc_storeWeakOrNil(location, obj);
    if (location)
    {
      *((unsigned char *)v3 + 8) = 1;
      return location;
    }
    goto LABEL_13;
  }
  if (*location)
  {
    if (*((unsigned char *)location + 8))
    {
      return (id *)objc_storeWeakOrNil(location, 0);
    }
    else
    {
      *locatiounint64_t n = 0;
    }
  }
  return location;
}

char *CA::Layer::class_state(CA::Layer *this, objc_class *a2)
{
  v38[1] = *MEMORY[0x1E4F143B8];
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  while (1)
  {
    uint64_t v3 = classDescription(this);
    if (v3)
    {
      BOOL v4 = *(char **)(v3 + 128);
      if (v4) {
        return v4;
      }
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    long long v6 = (char *)malloc_type_zone_malloc(malloc_zone, 0x70uLL, 0x8BB15036uLL);
    BOOL v4 = v6;
    if (v6)
    {
      unsigned int v7 = 0;
      int v8 = 0;
      int v9 = 0;
      *((void *)v6 + 13) = 0;
      *((void *)v6 + 1) = 0;
      *((void *)v6 + 2) = 0;
      *(void *)long long v6 = 0;
      *((_DWORD *)v6 + 6) = 0;
      *((_OWORD *)v6 + 2) = 0u;
      *((_OWORD *)v6 + 3) = 0u;
      *((_OWORD *)v6 + 4) = 0u;
      *((_OWORD *)v6 + 5) = 0u;
      v6[96] = 0;
    }
    else
    {
      int v9 = MEMORY[0x10];
      int v8 = MEMORY[4];
      unsigned int v7 = MEMORY[8];
    }
    *((_DWORD *)v6 + 4) = v9 | 0x80;
    *((_DWORD *)v6 + 1) = v8 & 0x3C000000 | 0x7FC8;
    if (LINKED_DEFAULT_CONTINUOUS_CORNERS)
    {
      unsigned int v7 = v7 & 0xFFFFFFF9 | 2;
      *((_DWORD *)v6 + 2) = v7;
    }
    uint64_t v10 = 0;
    *((_DWORD *)v6 + 2) = v7 & 0xFFFFFFE7;
    CFTypeRef v11 = &BOOL_bits;
    do
    {
      if (((0x37EF7BDFE757uLL >> v10) & 1) == 0)
      {
        uint64_t v12 = &v6[4 * (*v11 >> 5)];
        *((_DWORD *)v12 + 1) |= 1 << *v11;
      }
      ++v10;
      v11 += 8;
    }
    while (v10 != 46);
    uint64_t v13 = classDescription(this);
    if (v13 && *(unsigned char *)(v13 + 138)) {
      *((_DWORD *)v4 + 4) |= 0x400u;
    }
    uint64_t v14 = (CA::Transaction *)classDescription(this);
    if (v14 && *((unsigned char *)v14 + 137)) {
      *((_DWORD *)v4 + 4) |= 0x800u;
    }
    __int16 v15 = *(CA::Transaction **)(StatusReg + 576);
    if (!v15) {
      __int16 v15 = (CA::Transaction *)CA::Transaction::create(v14);
    }
    *(_DWORD *)v4 |= CA::Layer::State::fetch_defaults((uint64_t)v4, v15, (void (*)(uint64_t, uint64_t, uint64_t, CFTypeRef *))fetchDefault, (uint64_t)this);
    unsigned int v16 = (CA::Layer *)objc_opt_class();
    if (v16 == this)
    {
      int v17 = 0;
    }
    else
    {
      int v17 = 0;
      for (uint64_t i = 0; i != 14; ++i)
      {
        __int16 v19 = (char *)&CA::Layer::changed_flags_for_class(objc_class *)::changed_flags + 16 * i;
        uint64_t v20 = (const char *)*((void *)v19 + 1);
        if (*v20)
        {
          while (1)
          {
            SEL v21 = sel_registerName(v20);
            if (v21)
            {
              uint64_t v22 = [(CA::Layer *)v16 instanceMethodForSelector:v21];
              if ([(CA::Layer *)this instanceMethodForSelector:v21] != v22) {
                break;
              }
            }
            uint64_t v23 = &v20[strlen(v20)];
            int v24 = *((unsigned __int8 *)v23 + 1);
            uint64_t v20 = v23 + 1;
            if (!v24) {
              goto LABEL_29;
            }
          }
          v17 |= *(_DWORD *)v19;
        }
LABEL_29:
        ;
      }
    }
    int v25 = [(CA::Layer *)this _hasRenderLayerSubclass];
    int v26 = v17 | 0x10000;
    if (!v25) {
      int v26 = v17;
    }
    int v27 = *(_DWORD *)v4 | v26;
    *(_DWORD *)BOOL v4 = v27;
    if ((v27 & 0x8000) == 0)
    {
      v38[0] = 0;
      CAObject_defaultValueForAtom(this, 54, (const CGAffineTransform *)1, (uint64_t)v38);
      if (!v38[0])
      {
        CAObject_defaultValueForAtom(this, 66, (const CGAffineTransform *)1, (uint64_t)v38);
        if (!v38[0])
        {
          if ((*(_DWORD *)v4 & 0x2000) != 0) {
            goto LABEL_41;
          }
          goto LABEL_39;
        }
      }
      int v27 = *(_DWORD *)v4 | 0x8000;
      *(_DWORD *)BOOL v4 = v27;
    }
    if ((v27 & 0x2000) != 0) {
      goto LABEL_41;
    }
LABEL_39:
    v38[0] = 0;
    CAObject_defaultValueForAtom(this, 501, (const CGAffineTransform *)1, (uint64_t)v38);
    if (v38[0]) {
      *(_DWORD *)v4 |= 0x2000u;
    }
LABEL_41:
    double v28 = (atomic_ullong *)classDescription(this);
    if (v28)
    {
      while (1)
      {
        atomic_ullong v29 = v28[16];
        if (v29) {
          break;
        }
        atomic_compare_exchange_strong(v28 + 16, (unint64_t *)&v29, (unint64_t)v4);
        if (!v29) {
          return v4;
        }
      }
    }
    uint64_t v30 = *(CA::Transaction **)(StatusReg + 576);
    if (!v30) {
      uint64_t v30 = (CA::Transaction *)CA::Transaction::create((CA::Transaction *)v28);
    }
    CGFloat v31 = (const void *)*((void *)v4 + 13);
    if (v31) {
      CA::Transaction::release_object(v30, v31);
    }
    __int32 v32 = (CA::AttrList *)*((void *)v4 + 4);
    if (v32)
    {
      int v33 = *((_DWORD *)v30 + 25);
      *((_DWORD *)v30 + 25) = v33 + 1;
      if (v33
        || (os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock),
            (__int32 v32 = (CA::AttrList *)*((void *)v4 + 4)) != 0))
      {
        CA::AttrList::free(v32, v31);
      }
      CA::Transaction::unlock(v30);
    }
    __int32 v34 = (id *)(v4 + 88);
    if (*((void *)v4 + 11))
    {
      if (v4[96]) {
        objc_storeWeakOrNil(v34, 0);
      }
      else {
        *__int32 v34 = 0;
      }
    }
    int v35 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v35, v4);
  }
}

void sub_18470FCB0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (id *)(v1 + 88);
  if (*(void *)(v1 + 88))
  {
    if (*(unsigned char *)(v1 + 96)) {
      objc_storeWeakOrNil(v3, 0);
    }
    else {
      id *v3 = 0;
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t lookup_delegate_methods(CA::Transaction *a1, objc_object *a2)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  BOOL v4 = (objc_object *)objc_opt_class();
  int v5 = *((_DWORD *)a1 + 25);
  *((_DWORD *)a1 + 25) = v5 + 1;
  if (!v5) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  uint64_t v6 = lookup_delegate_methods(CA::Transaction *,objc_object *)::table;
  if (!lookup_delegate_methods(CA::Transaction *,objc_object *)::table)
  {
    lookup_delegate_methods(CA::Transaction *,objc_object *)::table = (uint64_t)x_hash_table_new_(0, 0, 0, 0, 0, 0);
    unsigned int v7 = "actionForLayer:forKey:";
    int v8 = &lookup_delegate_methods(CA::Transaction *,objc_object *)::selectors;
    do
    {
      *v8++ = (uint64_t)sel_registerName(v7);
      int v9 = &v7[strlen(v7)];
      int v10 = *((unsigned __int8 *)v9 + 1);
      unsigned int v7 = v9 + 1;
    }
    while (v10);
    uint64_t v6 = lookup_delegate_methods(CA::Transaction *,objc_object *)::table;
  }
  v17[0] = 0;
  uint64_t v11 = x_hash_table_lookup(v6, (uint64_t)v4, v17);
  if (!v17[0] || (uint64_t v12 = v11, (v11 & 0x100) != (v4 == a2) << 8))
  {
    uint64_t v13 = 0;
    int v14 = 1;
    LODWORD(v12) = (v4 == a2) << 8;
    do
    {
      if (objc_opt_respondsToSelector()) {
        int v15 = v14;
      }
      else {
        int v15 = 0;
      }
      uint64_t v12 = v15 | v12;
      v14 *= 2;
      v13 += 8;
    }
    while (v13 != 64);
    hash_table_modify((int *)lookup_delegate_methods(CA::Transaction *,objc_object *)::table, (uint64_t)v4, v12, 0);
  }
  CA::Transaction::unlock(a1);
  return v12;
}

void sub_18470FE6C(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

BOOL key_path_affects_container(unint64_t a1)
{
  if (!a1) {
    return 0;
  }
  if (a1)
  {
    unint64_t v1 = a1 >> 1;
  }
  else
  {
    if (!*(_DWORD *)a1) {
      return 0;
    }
    LODWORD(v1) = *(_DWORD *)(a1 + 4);
  }
  uint64_t v2 = 1;
  if ((int)v1 > 567)
  {
    if (v1 == 615) {
      return v2;
    }
    if (v1 == 568)
    {
      if ((a1 & 1) == 0)
      {
        unsigned int v3 = *(_DWORD *)a1;
        if (*(_DWORD *)a1 >= 2u)
        {
          int v4 = *(_DWORD *)(a1 + 8);
          switch(v4)
          {
            case 481:
              if (v3 >= 3) {
                return *(_DWORD *)(a1 + 12) != 613;
              }
              break;
            case 486:
              return 0;
            case 572:
              if (v3 >= 3) {
                return *(_DWORD *)(a1 + 12) == 613;
              }
              return 0;
          }
        }
      }
      return 1;
    }
    return 0;
  }
  if (v1 != 28 && v1 != 113) {
    return 0;
  }
  return v2;
}

void sub_184710378(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_18471052C(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1847106BC(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1847107CC(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

CA::Layer *CA::Layer::model_layer(CA::Layer *this, CA::Transaction *a2)
{
  if (!*((void *)this + 2)) {
    return 0;
  }
  uint64_t v2 = this;
  if ((*((_DWORD *)this + 1) & 0x60000) != 0)
  {
    int v4 = *((_DWORD *)a2 + 25);
    *((_DWORD *)a2 + 25) = v4 + 1;
    if (!v4) {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    }
    uint64_t v5 = *(void *)(*((void *)a2 + 13) + 224);
    if (v5) {
      uint64_t v2 = (CA::Layer *)x_hash_table_lookup(v5, (uint64_t)v2, 0);
    }
    CA::Transaction::unlock(a2);
  }
  return v2;
}

atomic_uint *CA::Render::ShapeLayer::set_dash_pattern(CA::Render::ShapeLayer *this, CA::Render::Vector *a2)
{
  uint64_t result = (atomic_uint *)*((void *)this + 14);
  if (result != (atomic_uint *)a2)
  {
    int v4 = a2;
    if (result && atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      uint64_t result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
    }
    if (v4)
    {
      uint64_t v5 = (atomic_uint *)((char *)v4 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)v4 + 2, 1u))
      {
        int v4 = 0;
        atomic_fetch_add(v5, 0xFFFFFFFF);
      }
    }
    *((void *)this + 14) = v4;
  }
  return result;
}

_DWORD *CA::Render::copy_render_array(CA::Render *this, const __CFArray *a2, CGColorSpace *a3)
{
  int v24 = a2;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFArrayGetCount(this);
  if (!Count)
  {
    return CA::Render::Vector::new_vector(0, 0, v5);
  }
  CFIndex v6 = Count;
  if (CA::Render::initialize_types(void)::once[0] != -1) {
    dispatch_once(CA::Render::initialize_types(void)::once, &__block_literal_global_5);
  }
  ValueAtIndeCGFloat x = (void *)CFArrayGetValueAtIndex(this, 0);
  CFTypeID v8 = CFGetTypeID(ValueAtIndex);
  CFTypeID v9 = v8;
  uint64_t v10 = CA::Render::number_type;
  if (v8 == CA::Render::number_type)
  {
    int v24 = 0;
    uint64_t v11 = 1;
  }
  else
  {
    if (v8 != CA::Render::color_type)
    {
      return CA::Render::copy_render_object(this, 0);
    }
    uint64_t v11 = 4;
  }
  unint64_t v23 = 8 * v6 * v11;
  if (v23 > 0x1000)
  {
    int v14 = malloc_type_malloc(8 * v6 * v11, 0x341C2289uLL);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    int v14 = (_OWORD *)((char *)&v21 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
    bzero(v14, v13);
  }
  unsigned int v16 = 0;
  CFIndex v17 = 0;
  uint64_t v22 = v14;
  while (1)
  {
    if (v17) {
      ValueAtIndeCGFloat x = (void *)CFArrayGetValueAtIndex(this, v17);
    }
    if (v9 == v10)
    {
      if (ValueAtIndex)
      {
        *(void *)&long long valuePtr = 0;
        CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberDoubleType, &valuePtr);
        uint64_t v18 = valuePtr;
      }
      else
      {
        uint64_t v18 = 0;
      }
      *(void *)int v14 = v18;
      goto LABEL_24;
    }
    if (CGColorGetPattern((CGColorRef)ValueAtIndex)) {
      break;
    }
    long long valuePtr = 0u;
    long long v26 = 0u;
    CA_CGColorGetRGBComponents((CGColor *)ValueAtIndex, v24, (CGFloat *)&valuePtr);
    _OWORD *v14 = valuePtr;
    v14[1] = v26;
LABEL_24:
    ++v17;
    unsigned int v16 = (CA::Render::Vector *)((char *)v16 + v11);
    int v14 = (_OWORD *)((char *)v14 + 8 * v11);
    if (v6 == v17)
    {
      __int16 v19 = v22;
      uint64_t v20 = CA::Render::Vector::new_vector(v16, v22, v15);
      if (v23 > 0x1000) {
        free(v19);
      }
      return v20;
    }
  }
  if (v23 > 0x1000) {
    free(v22);
  }
  return 0;
}

uint64_t CA::CG::IOSurfaceContext::create_delegate(uint64_t a1)
{
  CAIsAppSuspended();
  if (CA::Render::memory_once[0] != -1) {
    dispatch_once_f(CA::Render::memory_once, 0, (dispatch_function_t)CA::Render::init_memory_warnings_);
  }
  uint64_t v2 = *(CGColorSpace **)(a1 + 40);
  if (v2) {
    size_t NumberOfComponents = (CA::Render *)CGColorSpaceGetNumberOfComponents(v2);
  }
  else {
    size_t NumberOfComponents = 0;
  }
  unsigned int v4 = CA::Render::coregraphics_image_format(NumberOfComponents, *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 48))- 1;
  if (v4 > 0x14) {
    int v5 = -1;
  }
  else {
    int v5 = dword_1849A7E54[v4];
  }
  CFIndex v6 = *(__IOSurface **)(a1 + 16);
  if (v6)
  {
    OSType PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(v6);
    if (PixelFormat == 1999843442 || PixelFormat == 1647534392) {
      int v5 = CA::Render::fourcc_to_format(PixelFormat);
    }
  }
  if (v5 != -1) {
    operator new();
  }
  CGPostError();
  return 0;
}

uint64_t CAIsAppSuspended()
{
  if (CAIsAppSuspended::once != -1) {
    dispatch_once_f(&CAIsAppSuspended::once, 0, (dispatch_function_t)init_suspended);
  }
  unsigned __int8 v0 = atomic_load(is_suspended);
  return v0 & 1;
}

uint64_t CA::Render::coregraphics_image_format(CA::Render *this, int a2, int a3, int a4)
{
  if (!this && a2 == 8 && a3 == 8)
  {
    if (a4 == 7) {
      return 9;
    }
    return 0xFFFFFFFFLL;
  }
  if (this == 1 && a2 == 8 && a3 == 8)
  {
    if (!a4) {
      return 10;
    }
    return 0xFFFFFFFFLL;
  }
  if (this == 1 && a2 == 16 && a3 == 8)
  {
    if (a4 == 1) {
      return 18;
    }
    return 0xFFFFFFFFLL;
  }
  if (this == 3 && a2 == 32 && a3 == 8)
  {
    uint64_t result = 0;
    switch(a4)
    {
      case 1:
        return 11;
      case 2:
        return result;
      case 3:
      case 4:
        return 0xFFFFFFFFLL;
      case 5:
        return 12;
      case 6:
        return 2;
      default:
        JUMPOUT(0);
    }
  }
  if (this == 3 && a2 == 64 && a3 == 16)
  {
    if (a4 > 4352)
    {
      if (a4 == 4353) {
        return 13;
      }
      if (a4 == 4357) {
        return 17;
      }
    }
    else
    {
      if (a4 == 4097) {
        return 21;
      }
      if (a4 == 4101) {
        return 22;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (this == 3 && a2 == 128 && a3 == 32)
  {
    if (a4 == 8449) {
      return 14;
    }
    return 0xFFFFFFFFLL;
  }
  if (this != 3 || a2 != 16 || a3 != 5)
  {
    if (this == 4 && a2 == 32 && a3 == 8) {
      return 29;
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 4;
  if (a4 != 6 && a4 != 12294)
  {
    if (a4 == 4102) {
      return 5;
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t CA::CG::Queue::cancel_and_grow(CA::CG::Queue *this, CA::CG::DrawOp *a2, CA::CG::DrawOp *a3, uint64_t a4)
{
  unsigned int v4 = (void *)*((void *)this + 4);
  if (!v4[4]) {
    return 0;
  }
  if ((uint64_t)v4 > (uint64_t)a3 || *((void *)this + 5) != (void)a3) {
    return 0;
  }
  if ((uint64_t)v4 + v4[2] < (uint64_t)a3) {
    return 0;
  }
  unint64_t v8 = (a4 + 15) & 0xFFFFFFFFFFFFFFF0;
  if (*((void *)a2 - 2) + v4[3] < v8 || *((void *)a3 - 1) != *((void *)a2 - 1)) {
    return 0;
  }
  CA::CG::Queue::cancel(this, a2);
  *((void *)a3 - 2) += v8;
  uint64_t v10 = *((void *)this + 4);
  if (v10)
  {
    unint64_t v11 = *(void *)(v10 + 32) + v8;
    *(void *)(v10 + 24) -= v8;
    *(void *)(v10 + 32) = v11;
  }
  return 1;
}

void CA::CG::Queue::cancel(CA::CG::Queue *this, CA::CG::DrawOp *a2)
{
  (**(void (***)(CA::CG::DrawOp *))a2)(a2);
  unsigned int v4 = (void *)*((void *)this + 4);
  int v5 = (atomic_uint *)*((void *)a2 - 1);
  if (v5)
  {
    CA::CG::TransparencyLayer::unref(v5);
    *((void *)a2 - 1) = 0;
  }
  uint64_t v6 = v4[4];
  if (v6)
  {
    v4[4] = v6 - *((void *)a2 - 2);
    v4[3] += *((void *)a2 - 2);
  }
  else
  {
    CA::CG::Queue::deallocate_slab(v4);
    *((void *)this + 4) = 0;
  }
}

void CA::CG::Queue::render_callback(CA::CG::Queue *this, void *a2)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = (void *)MEMORY[0x185324A30](this, a2);
  unsigned int v4 = *(CA::CG::Queue **)this;
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)this + 32))(*(void *)this);
  if (!v5)
  {
    CA::CG::Queue::mark_serial(v4);
    goto LABEL_89;
  }
  *((void *)this + 1) = v5;
  uint64_t v6 = (void *)MEMORY[0x185324A30]();
  unint64_t v8 = *(CA::CG::Queue **)this;
  int v9 = BYTE9(xmmword_1EB2ACC10);
  if (BYTE9(xmmword_1EB2ACC10)) {
    kdebug_trace();
  }
  uint64_t v10 = *((void *)this + 1);
  if (!v10)
  {
    uint64_t v14 = 0;
    goto LABEL_76;
  }
  uint64_t v11 = *(void *)(v10 + 8);
  if (!v11)
  {
    char v15 = 0;
    goto LABEL_74;
  }
  if ((*(unsigned char *)(v10 + 4176) & 1) == 0)
  {
    if (!(*(unsigned int (**)(uint64_t))(*(void *)v11 + 208))(v11))
    {
      char v15 = 0;
      goto LABEL_72;
    }
    uint64_t v12 = (*(uint64_t (**)(void, void))(**(void **)(v10 + 8) + 184))(*(void *)(v10 + 8), 0);
    if (v12)
    {
      uint64_t v13 = v12;
      if (x_log_hook_p())
      {
        (*(void (**)(void, uint64_t))(**(void **)(v10 + 8) + 192))(*(void *)(v10 + 8), v13);
        x_log_();
      }
      else
      {
        unsigned int v16 = x_log_category_cg;
        if (os_log_type_enabled((os_log_t)x_log_category_cg, OS_LOG_TYPE_ERROR))
        {
          uint64_t v17 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v10 + 8) + 192))(*(void *)(v10 + 8), v13);
          *(_DWORD *)buf = 136315138;
          *(void *)&uint8_t buf[4] = v17;
          _os_log_impl(&dword_184668000, v16, OS_LOG_TYPE_ERROR, "CoreAnimation: rendering error %s\n", buf, 0xCu);
        }
      }
    }
    *(unsigned char *)(v10 + 4176) |= 1u;
    memset(buf, 0, sizeof(buf));
    mach_get_times();
    uint64_t v18 = *(void *)&buf[8];
    uint64_t v19 = *(void *)(v10 + 8);
    *(double *)(v19 + 240) = CATimeWithHostTime(*(unint64_t *)buf);
    CA::CG::Renderer::update_finished_seed(v10);
    if (BYTE13(xmmword_1EB2ACC50))
    {
      if (CA::CG::cg_perf_log(void)::once_token[0] != -1) {
        dispatch_once(CA::CG::cg_perf_log(void)::once_token, &__block_literal_global_11);
      }
      __int32 v52 = CA::CG::cg_perf_log(void)::log;
      os_signpost_id_t v53 = os_signpost_id_generate((os_log_t)CA::CG::cg_perf_log(void)::log);
      *(void *)(v10 + 4168) = v53;
      if (v53 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        os_signpost_id_t v54 = v53;
        if (os_signpost_enabled(v52))
        {
          int v55 = *(_DWORD *)(*(void *)(v10 + 8) + 8);
          int v60 = *(_DWORD *)(v10 + 152);
          long long v56 = _MXSignpostMetricsSnapshot();
          *(_DWORD *)buf = 67240706;
          *(_DWORD *)&uint8_t buf[4] = v55;
          *(_WORD *)&uint8_t buf[8] = 1026;
          *(_DWORD *)&buf[10] = v60;
          *(_WORD *)&buf[14] = 2114;
          int v63 = v56;
          _os_signpost_emit_with_name_impl(&dword_184668000, v52, OS_SIGNPOST_INTERVAL_BEGIN, v54, "Rendering", "context=%{public,name=context}u update=0x%{public,name=update}x\n%{public, signpost:metrics}@", buf, 0x18u);
        }
      }
    }
    (*(void (**)(void, uint64_t))(**(void **)(v10 + 8) + 160))(*(void *)(v10 + 8), v18);
    uint64_t v20 = *(void *)(v10 + 8);
    *(void *)(v20 + 228) = *(void *)(v10 + 152);
    if (*(double *)(v10 + 296) == 0.0) {
      *(double *)(v10 + 296) = *(double *)(v20 + 240) + 0.25;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 1008))(v20, v10 + 1296);
  }
  int v61 = v9;
  unint64_t v21 = *((void *)this + 2) - 48;
  if (v21 <= *((void *)this + 3))
  {
    char v15 = 1;
    int v9 = v61;
    goto LABEL_72;
  }
  uint64_t v59 = v6;
  uint64_t v22 = 0;
  unint64_t v23 = (char *)this + 48;
  char v24 = 1;
  float64x2_t v57 = (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL);
  float64x2_t v58 = (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000);
  do
  {
    int v25 = (atomic_uint *)*((void *)v23 + 1);
    if (v22 == v25)
    {
      if (v22) {
        CA::CG::TransparencyLayer::unref(v22);
      }
      long long v26 = (CA::CG::DrawOp *)(v23 + 16);
      if ((v24 & 1) == 0)
      {
        char v24 = 0;
        goto LABEL_62;
      }
      int v25 = v22;
      goto LABEL_54;
    }
    if (v22 == 0 || (v24 & 1) == 0)
    {
      if (!v22) {
        goto LABEL_32;
      }
    }
    else
    {
      CA::CG::Renderer::pop_transparency_layer((CA::CG::Renderer *)v10, (CA::CG::TransparencyLayer *)v22);
      int v25 = (atomic_uint *)*((void *)v23 + 1);
    }
    CA::CG::TransparencyLayer::unref(v22);
LABEL_32:
    if (!v25) {
      goto LABEL_53;
    }
    uint64_t v27 = *(unsigned __int16 **)(v10 + 8);
    if (v27 && (v25[49] & 8) == 0)
    {
      uint64_t v28 = *((void *)v25 + 5);
      if (v28) {
        goto LABEL_45;
      }
      double v29 = *(double *)(v10 + 80);
      *((double *)v25 + 6) = v29;
      int8x16_t v30 = *(int8x16_t *)(v25 + 2);
      int8x16_t v31 = *(int8x16_t *)(v25 + 6);
      if (v29 != 1.0)
      {
        v7.f64[0] = 1.79769313e308;
        int8x16_t v32 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(v7, (float64x2_t)v31).i64[0], 0);
        v33.i64[1] = *((void *)v25 + 2);
        *(double *)v33.i64 = v29 * *(double *)v30.i64;
        int8x16_t v30 = vbslq_s8(v32, v33, v30);
        v33.i64[1] = *((void *)v25 + 4);
        *(double *)v33.i64 = v29 * *(double *)v31.i64;
        int8x16_t v31 = vbslq_s8(v32, v33, v31);
        if (*(double *)&v31.i64[1] < 1.79769313e308)
        {
          v30.i64[1] = vmuld_lane_f64(v29, (float64x2_t)v30, 1);
          *(double *)&v31.i64[1] = *(double *)&v31.i64[1] * v29;
        }
      }
      int64x2_t v34 = vceqzq_f64((float64x2_t)v31);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v34, 1), (int8x16_t)v34).u64[0] & 0x8000000000000000) != 0
        || (int8x16_t v35 = vorrq_s8((int8x16_t)vcltzq_f64((float64x2_t)v31), (int8x16_t)vcgezq_f64((float64x2_t)v31)),
            (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v35), 1), v35).u64[0] & 0x8000000000000000) != 0))
      {
        memset(buf, 0, sizeof(buf));
      }
      else
      {
        float64x2_t v36 = vmaxnmq_f64((float64x2_t)v30, v58);
        float64x2_t v37 = vminnmq_f64(vaddq_f64((float64x2_t)v30, (float64x2_t)v31), v57);
        int32x4_t v38 = (int32x4_t)vcvtmq_s64_f64(v36);
        *(int32x4_t *)buf = vuzp1q_s32(v38, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v37), (int64x2_t)v38));
      }
      CA::Shape::operator=((uint64_t)(v25 + 14), buf);
      uint64_t v28 = (*(uint64_t (**)(unsigned __int16 *, uint64_t, uint8_t *, uint64_t))(*(void *)v27 + 656))(v27, 1, buf, 8207);
      *((void *)v25 + 5) = v28;
      if (v28)
      {
LABEL_45:
        int v39 = (v27[416] >> 12) & 7;
        *((unsigned char *)v25 + 176) = (v27[416] >> 12) & 7;
        unsigned int v40 = v27[416];
        if (v39 == 3)
        {
          unsigned int v41 = v40 & 0xFFFF8FFF | 0x2000;
          v27[416] = v41;
          unsigned int v42 = v41 >> 12;
          uint64_t v28 = *((void *)v25 + 5);
        }
        else
        {
          unsigned int v42 = v40 >> 12;
        }
        if ((v42 & 4) != 0) {
          char v43 = 0;
        }
        else {
          char v43 = 0x1E1F1400u >> (8 * (v42 & 7));
        }
        *(unsigned char *)(v28 + 73) = *(unsigned char *)(v28 + 73) & 0xC0 | v43;
        char v44 = *((unsigned char *)v25 + 196);
        *((unsigned char *)v25 + 196) = (4 * *((unsigned char *)v27 + 832)) & 0x10 | v44 & 0xEF;
        CA::OGL::Context::push_surface((uint64_t)v27, *((void *)v25 + 5), (v44 & 4) != 0, 512, 0);
        v27[416] |= 4u;
        *((unsigned char *)v25 + 196) &= ~4u;
        *((void *)v25 + 13) = CA::OGL::Context::set_gstate((uint64_t)v27, (uint64_t)(v25 + 26));
        *((unsigned char *)v25 + 196) |= 8u;
        *(void *)(v10 + 1368) = v25;
LABEL_53:
        long long v26 = (CA::CG::DrawOp *)(v23 + 16);
LABEL_54:
        int v45 = *((_DWORD *)v23 + 29) & 0x18;
        if (v45 == 8)
        {
          CA::CG::DrawOp::render(v26, (float64x2_t *)v10);
          CGFloat v46 = (CA::CG::DrawOp *)*((void *)v23 + 15);
LABEL_59:
          CA::CG::DrawOp::render(v46, (float64x2_t *)v10);
        }
        else if (!v45 || (CA::CG::DrawOp::render(*((CA::CG::DrawOp **)v23 + 15), (float64x2_t *)v10), v45 == 16))
        {
          CGFloat v46 = v26;
          goto LABEL_59;
        }
        char v24 = 1;
        goto LABEL_61;
      }
    }
    char v24 = 0;
    long long v26 = (CA::CG::DrawOp *)(v23 + 16);
LABEL_61:
    uint64_t v22 = v25;
LABEL_62:
    (*(void (**)(CA::CG::DrawOp *, uint64_t))(*((void *)v23 + 2) + 16))(v26, v10);
    (**((void (***)(CA::CG::DrawOp *))v23 + 2))(v26);
    v21 -= *(void *)v23;
    v23 += *(void *)v23;
  }
  while (v21 > *((void *)this + 3));
  if (v22) {
    char v47 = v24;
  }
  else {
    char v47 = 0;
  }
  if (v47)
  {
    CA::CG::Renderer::pop_transparency_layer((CA::CG::Renderer *)v10, (CA::CG::TransparencyLayer *)v22);
    uint64_t v6 = v59;
    int v9 = v61;
    goto LABEL_70;
  }
  uint64_t v6 = v59;
  int v9 = v61;
  if (v22) {
LABEL_70:
  }
    CA::CG::TransparencyLayer::unref(v22);
  char v15 = 1;
LABEL_72:
  uint64_t v14 = *(void *)(v10 + 8);
  if (v14)
  {
    if (*(double *)(v10 + 296) == 0.0)
    {
LABEL_74:
      uint64_t v14 = 0;
    }
    else
    {
      uint64_t v51 = mach_absolute_time();
      *(double *)(v14 + 240) = CATimeWithHostTime(v51);
      if (*(double *)(v10 + 296) >= *(double *)(*(void *)(v10 + 8) + 240)) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = 3;
      }
    }
  }
  (*(void (**)(CA::CG::Queue *, uint64_t))(*(void *)v8 + 40))(v8, v10);
  if ((v15 & 1) == 0)
  {
LABEL_76:
    unint64_t v48 = *((void *)this + 2) - 48;
    if (v48 > *((void *)this + 3))
    {
      float64x2_t v49 = (char *)this + 48;
      do
      {
        int v50 = (atomic_uint *)*((void *)v49 + 1);
        if (v50) {
          CA::CG::TransparencyLayer::unref(v50);
        }
        (**((void (***)(uint64_t))v49 + 2))((uint64_t)(v49 + 16));
        v48 -= *(void *)v49;
        v49 += *(void *)v49;
      }
      while (v48 > *((void *)this + 3));
    }
  }
  CA::CG::Queue::deallocate_slab(this);
  ++*((_DWORD *)v8 + 42);
  if (dispatch_semaphore_signal((dispatch_semaphore_t)CA::CG::Queue::_queue_sema) && *((int *)v8 + 42) > 7)
  {
    uint64_t v14 = 1;
    goto LABEL_85;
  }
  if (v14) {
LABEL_85:
  }
    (*(void (**)(CA::CG::Queue *, uint64_t, void))(*(void *)v8 + 48))(v8, v14, 0);
  CA::CG::Queue::mark_serial(v8);
  if (v9) {
    kdebug_trace();
  }
LABEL_89:
}

BOOL CA::OGL::MetalContext::update(CA::OGL::MetalContext *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 24);
  if (v2 && (uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2)) != 0)
  {
    uint64_t v4 = *(int *)(v3 + 180) * (uint64_t)*(int *)(v3 + 176);
    if (CADeviceUseCIF10::once != -1) {
      dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_12019);
    }
    uint64_t v5 = 20;
    if (!CADeviceUseCIF10::enable_cif10) {
      uint64_t v5 = 10;
    }
    unint64_t v6 = v5 * v4;
    if (v6 <= 0x200000) {
      unint64_t v6 = 0x200000;
    }
  }
  else
  {
    unint64_t v6 = 0x8000000;
  }
  *((void *)this + 49) = v6;
  uint64_t v7 = *((void *)this + 33);
  if (!v7)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      unint64_t v8 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v10 = 0;
        _os_log_impl(&dword_184668000, v8, OS_LOG_TYPE_ERROR, "Can't run metal against null surface\n", v10, 2u);
      }
    }
  }
  return v7 != 0;
}

uint64_t CA::OGL::MetalContext::begin_rendering(uint64_t a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  __int16 v4 = *(_WORD *)(a1 + 3328);
  *(_WORD *)(a1 + 3328) = v4 & 0xFF7F;
  if (BYTE13(xmmword_1EB2ACC50))
  {
    if ((v4 & 0x40) == 0)
    {
      *(void *)(a1 + 4096) = mach_continuous_time();
      os_signpost_id_t v22 = os_signpost_id_generate((os_log_t)CA::OGL::MetalContext::_perf_log);
      *(void *)(a1 + 4104) = v22;
      if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        os_signpost_id_t v23 = v22;
        char v24 = CA::OGL::MetalContext::_perf_log;
        if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::_perf_log))
        {
          int v25 = *(_DWORD *)(a1 + 8);
          int v26 = *(_DWORD *)(a1 + 228);
          *(_DWORD *)buf = 67240706;
          *(_DWORD *)int8x16_t v31 = v25;
          *(_WORD *)&v31[4] = 1026;
          *(_DWORD *)&v31[6] = v26;
          *(_WORD *)&v31[10] = 2114;
          *(void *)&v31[12] = _MXSignpostMetricsSnapshot();
          _os_signpost_emit_with_name_impl(&dword_184668000, v24, OS_SIGNPOST_INTERVAL_BEGIN, v23, "Rendering", "context=%{public,name=context}u update=0x%{public,name=update}x\n%{public, signpost:metrics}@", buf, 0x18u);
        }
      }
    }
  }
  if (*(void *)(a1 + 3056))
  {
    if ((*(_WORD *)(a1 + 3328) & 4) == 0)
    {
      uint64_t v5 = *(void *)(a1 + 192);
      if (v5)
      {
        uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
        if (v6)
        {
          if ((*(_WORD *)(v6 + 656) & 0x1C00) == 0) {
            [*(id *)(a1 + 3048) setDefaultCaptureScope:*(void *)(a1 + 3056)];
          }
        }
      }
      *(_WORD *)(a1 + 3328) |= 4u;
    }
    if (initialized != -1) {
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    }
    if (!*(float *)&dword_1EB2ACB44 || ([*(id *)(a1 + 3048) isCapturing] & 1) != 0) {
      goto LABEL_33;
    }
    if ([*(id *)(a1 + 3048) supportsDestination:2])
    {
      id v7 = (id)objc_opt_new();
      [v7 setDateFormat:@"yyyyMMdd-HHmmssSSS"];
      unint64_t v8 = -[NSString stringByAppendingPathComponent:](NSTemporaryDirectory(), "stringByAppendingPathComponent:", [NSString stringWithFormat:@"CoreAnimation-%@.gputrace", objc_msgSend(v7, "stringFromDate:", objc_msgSend(MEMORY[0x1E4F1C9C8], "date"))]);
      id v9 = (id)objc_opt_new();
      [v9 setCaptureObject:*(void *)(a1 + 2960)];
      [v9 setDestination:2];
      objc_msgSend(v9, "setOutputURL:", objc_msgSend(MEMORY[0x1E4F1CB10], "fileURLWithPath:", v8));
      id v29 = 0;
      LODWORD(v9) = [*(id *)(a1 + 3048) startCaptureWithDescriptor:v9 error:&v29];
      BOOL v10 = x_log_hook_p();
      if (v9)
      {
        if (v10)
        {
          if (initialized != -1) {
            dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
          }
          uint64_t v27 = *(float *)&dword_1EB2ACB44;
          uint64_t v28 = [(NSString *)v8 UTF8String];
          goto LABEL_23;
        }
        uint64_t v16 = x_log_category_ogl_metal;
        if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_33;
        }
        if (initialized != -1) {
          dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
        }
        unsigned int v17 = *(float *)&dword_1EB2ACB44;
        uint64_t v18 = [(NSString *)v8 UTF8String];
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)int8x16_t v31 = v17;
        *(_WORD *)&v31[4] = 2080;
        *(void *)&v31[6] = v18;
        uint64_t v12 = "Capturing %d GPU frames to %s\n";
        uint64_t v13 = v16;
        os_log_type_t v14 = OS_LOG_TYPE_DEFAULT;
        uint32_t v15 = 18;
LABEL_32:
        _os_log_impl(&dword_184668000, v13, v14, v12, buf, v15);
        goto LABEL_33;
      }
      if (!v10)
      {
        uint64_t v19 = x_log_category_ogl_metal;
        if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_33;
        }
        uint64_t v20 = objc_msgSend((id)objc_msgSend(v29, "localizedDescription"), "UTF8String");
        *(_DWORD *)buf = 136315138;
        *(void *)int8x16_t v31 = v20;
        uint64_t v12 = "Unable to capture to GPU trace file: %s\n";
        uint64_t v13 = v19;
        os_log_type_t v14 = OS_LOG_TYPE_ERROR;
        uint32_t v15 = 12;
        goto LABEL_32;
      }
      uint64_t v27 = objc_msgSend((id)objc_msgSend(v29, "localizedDescription"), "UTF8String");
    }
    else if (!x_log_hook_p())
    {
      uint64_t v11 = x_log_category_ogl_metal;
      if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_33;
      }
      *(_WORD *)buf = 0;
      uint64_t v12 = "Capture to a GPU trace file is not supported. Try setting env var: METAL_CAPTURE_ENABLED=1\n";
      uint64_t v13 = v11;
      os_log_type_t v14 = OS_LOG_TYPE_ERROR;
      uint32_t v15 = 2;
      goto LABEL_32;
    }
LABEL_23:
    x_log_();
LABEL_33:
    objc_msgSend(*(id *)(a1 + 3056), "beginScope", v27, v28);
  }
  return CA::OGL::Context::begin_rendering(a1, a2);
}

void CA::OGL::Context::prepare_context(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = a2 + 488;
  *(void *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 432) = global_feature_flags | *(_DWORD *)(a1 + 224);
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  for (uint64_t i = 0; i != 66; ++i)
    *(_DWORD *)(a1 + 444 + 4 * i) = CAGetDebugValueFloat(i);
  *(void *)(a1 + 248) = 0;
}

uint64_t CA::OGL::Context::begin_rendering(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = 0; i != 66; ++i)
    *(_DWORD *)(a1 + 4 * i + 444) = CAGetDebugValueFloat(i);
  *(void *)(a1 + 816) = 0;
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(v5 + 480) = 0;
  *(_OWORD *)(v5 + 448) = 0u;
  *(_OWORD *)(v5 + 464) = 0u;
  *(_OWORD *)(v5 + 416) = 0u;
  *(_OWORD *)(v5 + 432) = 0u;
  *(_OWORD *)(v5 + 384) = 0u;
  *(_OWORD *)(v5 + 400) = 0u;
  *(_OWORD *)(v5 + 352) = 0u;
  *(_OWORD *)(v5 + 368) = 0u;
  *(_OWORD *)(v5 + 320) = 0u;
  *(_OWORD *)(v5 + 336) = 0u;
  *(_OWORD *)(v5 + 288) = 0u;
  *(_OWORD *)(v5 + 304) = 0u;
  *(_OWORD *)(v5 + 256) = 0u;
  *(_OWORD *)(v5 + 272) = 0u;
  *(_OWORD *)(v5 + 224) = 0u;
  *(_OWORD *)(v5 + 240) = 0u;
  *(_OWORD *)(v5 + 192) = 0u;
  *(_OWORD *)(v5 + 208) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + 176) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  uint64_t v6 = *(void *)(a1 + 16);
  *(void *)(v6 + 480) = 0;
  *(_OWORD *)(v6 + 448) = 0u;
  *(_OWORD *)(v6 + 464) = 0u;
  *(_OWORD *)(v6 + 416) = 0u;
  *(_OWORD *)(v6 + 432) = 0u;
  *(_OWORD *)(v6 + 384) = 0u;
  *(_OWORD *)(v6 + 400) = 0u;
  *(_OWORD *)(v6 + 352) = 0u;
  *(_OWORD *)(v6 + 368) = 0u;
  *(_OWORD *)(v6 + 320) = 0u;
  *(_OWORD *)(v6 + 336) = 0u;
  *(_OWORD *)(v6 + 288) = 0u;
  *(_OWORD *)(v6 + 304) = 0u;
  *(_OWORD *)(v6 + 256) = 0u;
  *(_OWORD *)(v6 + 272) = 0u;
  *(_OWORD *)(v6 + 224) = 0u;
  *(_OWORD *)(v6 + 240) = 0u;
  *(_OWORD *)(v6 + 192) = 0u;
  *(_OWORD *)(v6 + 208) = 0u;
  *(_OWORD *)(v6 + 160) = 0u;
  *(_OWORD *)(v6 + 176) = 0u;
  *(_OWORD *)(v6 + 128) = 0u;
  *(_OWORD *)(v6 + 144) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  *(_OWORD *)(v6 + 112) = 0u;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)(v6 + 48) = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(unsigned char *)(a1 + 65) &= ~1u;
  *(unsigned char *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 88) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 184))(a1, 3);
  (*(void (**)(uint64_t))(*(void *)a1 + 232))(a1);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 184))(a1, 8);
  uint64_t v8 = 0;
  *(_DWORD *)(a1 + 92) = result == 0;
  uint64_t v9 = *(void *)(a1 + 16);
  do
  {
    *(_OWORD *)(v9 + 96 + v8) = xmmword_184997ED0;
    v8 += 16;
  }
  while (v8 != 48);
  *(unsigned char *)(v9 + 481) &= ~1u;
  uint64_t v10 = *(void *)(a1 + 16);
  *(unsigned char *)(v10 + 480) = *(unsigned char *)(a2 + 68);
  *(void *)(v10 + 288) = *(void *)(a2 + 40);
  *(void *)(*(void *)(a1 + 16) + 296) = *(void *)(a2 + 48);
  *(void *)(*(void *)(a1 + 16) + 280) = *(void *)(a2 + 56);
  uint64_t v11 = *(void *)(a2 + 8);
  if (v11) {
    BOOL v12 = v11 != 1;
  }
  else {
    BOOL v12 = *(_DWORD *)(v11 + 4) == 12;
  }
  if (v12) {
    __int16 v13 = 24;
  }
  else {
    __int16 v13 = 0;
  }
  *(_WORD *)(a1 + 832) = v13 | *(_WORD *)(a1 + 832) & 0xFFE7;
  *(void *)(a1 + 248) = a2;
  return result;
}

float CAGetDebugValueFloat(unsigned int a1)
{
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  float result = 0.0;
  if (a1 <= 0x41) {
    return *(float *)&debug_values[a1];
  }
  return result;
}

double CA::OGL::MetalContext::init_state(CA::OGL::MetalContext *this)
{
  if (!*((void *)this + 33)) {
    __assert_rtn("init_state", "ogl-metal.mm", 4615, "current_surface () && \"no such thing as current fbo\"");
  }
  uint64_t v1 = 0;
  *(unsigned char *)(*((void *)this + 3) + 16) = 0;
  *(unsigned char *)(*((void *)this + 3) + 17) = 0;
  *(unsigned char *)(*((void *)this + 3) + 18) = 0;
  *(unsigned char *)(*((void *)this + 3) + 19) = 0;
  *(unsigned char *)(*((void *)this + 3) + 20) = 0;
  uint64_t v2 = *((void *)this + 3);
  *(unsigned char *)(v2 + 480) = 1;
  uint64_t v3 = v2 + 96;
  do
  {
    *(_OWORD *)(v3 + v1) = xmmword_184997ED0;
    v1 += 16;
  }
  while (v1 != 48);
  *((unsigned char *)this + 65) &= ~1u;
  double result = NAN;
  *((void *)this + 7) = -1;
  return result;
}

uint64_t CA::OGL::MetalContext::set_render_begin_time(uint64_t this, uint64_t a2)
{
  *(void *)(this + 4096) = a2;
  *(_WORD *)(this + 3328) |= 0x40u;
  return this;
}

CA::Shape **CA::WindowServer::AccelServer::render_update(CA::WindowServer::Display **this, CA::Render::Update *a2, unsigned int *a3)
{
  uint64_t v6 = (CA::Shape **)(*((uint64_t (**)(CA::WindowServer::Display **))*this + 49))(this);
  if (v6)
  {
    uint64_t v8 = (CA::OGL::Renderer *)v6;
    if (CA::WindowServer::Display::render_display(this[12], v6, a2)) {
      *a3 |= 3u;
    }
    if (BYTE4(xmmword_1EB2ACBF0)) {
      (*(void (**)(void, const char *))(**(void **)v8 + 424))(*(void *)v8, "com.apple.GL.event.frameboundary.end");
    }
    double v9 = *((double *)a2 + 9);
    return (CA::Shape **)CA::OGL::Renderer::collect(v8, a2, v9);
  }
  else
  {
    return CA::WindowServer::Server::render_update(this, a2, v7);
  }
}

uint64_t CA::WindowServer::AccelServer::renderer(CA::WindowServer::AccelServer *this)
{
  uint64_t result = *((void *)this + 129);
  if (result) {
    goto LABEL_12;
  }
  uint64_t v3 = *((void *)this + 12);
  id v4 = *(id *)(v3 + 296);
  if (!v4)
  {
    id v4 = CAMetalContextCreate();
    *(void *)(v3 + 296) = v4;
    if (!v4)
    {
      uint64_t result = *((void *)this + 129);
      if (!result) {
        return result;
      }
      goto LABEL_12;
    }
  }
  *((void *)this + 128) = CA::OGL::new_metal_context(v4, 0, 0, 0, 4, @"com.apple.coreanimation.AccelServer");
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v6 = malloc_type_zone_malloc(malloc_zone, 0x68uLL, 0x8BB15036uLL);
  id v7 = v6;
  if (v6)
  {
    uint64_t v8 = *((void *)this + 128);
    v6[1] = 0;
    v6[2] = 0;
    *uint64_t v6 = v8;
    v6[6] = malloc_type_malloc(0x40000uLL, 0xA44586FDuLL);
    v7[7] = 0;
    *((_DWORD *)v7 + 24) = 1;
    *((_WORD *)v7 + 50) = 0;
  }
  *((void *)this + 129) = v7;
  if (CADeviceUseFramebufferCompression::once != -1) {
    dispatch_once(&CADeviceUseFramebufferCompression::once, &__block_literal_global_30);
  }
  BOOL v9 = CADeviceUseFramebufferCompression::enable_compression
    && (unint64_t)(*(unsigned char *)(*((void *)this + 12) + 28155) == 0);
  (*(void (**)(void, BOOL))(**((void **)this + 128) + 176))(*((void *)this + 128), v9);
  uint64_t result = *((void *)this + 129);
  *(void *)(*((void *)this + 12) + 312) = result;
  if (result)
  {
LABEL_12:
    if ((*(_DWORD *)(*((void *)this + 12) + 745) & 0x4000) != 0) {
      int v10 = 33685520;
    }
    else {
      int v10 = 131088;
    }
    int v11 = v10 | *((_DWORD *)this + 46);
    uint64_t v12 = *((void *)this + 128);
    int v13 = *(_DWORD *)(v12 + 224);
    *(_DWORD *)(v12 + 224) = v11;
    *(_DWORD *)(v12 + 432) = global_feature_flags | v11;
    if (((v13 ^ v11) & 0x2000200) != 0)
    {
      CA::OGL::Context::update_color_program_cache(v12);
      return *((void *)this + 129);
    }
  }
  return result;
}

uint64_t CA::WindowServer::Display::render_display(CA::WindowServer::Display *this, CA::Shape **a2, CA::Render::Update *a3)
{
  uint64_t v6 = (void *)MEMORY[0x185324A30]();
  id v7 = *a2;
  *((void *)v7 + 24) = CA::WindowServer::Display::ogl_display(this);
  *(_OWORD *)((char *)v7 + 200) = *(_OWORD *)((char *)this + 200);
  if ((*(unsigned int (**)(CA::WindowServer::Display *))(*(void *)this + 1840))(this))
  {
    uint64_t v8 = (CGColorSpace *)(*(uint64_t (**)(CA::WindowServer::Display *))(*(void *)this + 1800))(this);
    if (v8) {
      CA::OGL::Context::set_colorspace(v7, v8);
    }
  }
  uint64_t v9 = (*(uint64_t (**)(CA::Shape *))(*(void *)v7 + 1080))(v7);
  uint64_t v10 = (*(uint64_t (**)(CA::WindowServer::Display *, uint64_t, uint64_t, void, void))(*(void *)this
                                                                                                 + 488))(this, 1, v9, *((void *)a3 + 36), 0);
  uint64_t v11 = v10;
  if (!v10) {
    goto LABEL_22;
  }
  int v12 = *(_DWORD *)(v10 + 64);
  if (v12 != 643969848 && v12 != 1647534392)
  {
    if (((*(unsigned int *)(v10 + 224) | ((unint64_t)*(unsigned __int8 *)(v10 + 228) << 32)) & 0x200000000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  int v14 = *((_DWORD *)a3 + 67);
  if ((v14 & 0x2000) != 0 || (v14 & 2) != 0 || BYTE8(xmmword_1EB2ACC10))
  {
    uint64_t v15 = v10 + 224;
    unint64_t v17 = *(unsigned int *)(v10 + 224) | ((unint64_t)*(unsigned __int8 *)(v10 + 228) << 32);
    if ((*(_DWORD *)(v10 + 224) & 0x40000000) != 0) {
      goto LABEL_20;
    }
    uint64_t v18 = v17 | 0x80000000;
    goto LABEL_18;
  }
  uint64_t v15 = v10 + 224;
  uint64_t v16 = *(unsigned __int8 *)(v10 + 228);
  unint64_t v17 = *(unsigned int *)(v10 + 224) | (unint64_t)(v16 << 32);
  if (((v17 >> 30) & 1) == ((v16 >> 1) & 1)) {
    goto LABEL_20;
  }
  uint64_t v18 = v17 | 0x80000000;
  if ((v17 & 0x200000000) != 0)
  {
LABEL_18:
    unint64_t v17 = v18 | 0x240000000;
    goto LABEL_19;
  }
  unint64_t v17 = v17 & 0xFFFFFFFF3FFFFFFFLL | 0x80000000;
LABEL_19:
  *(_DWORD *)uint64_t v15 = v17;
  *(unsigned char *)(v15 + 4) = BYTE4(v17);
LABEL_20:
  if ((v17 & 0x200000000) != 0) {
LABEL_21:
  }
    CA::Render::Update::set_shape(a3, *((const CA::Shape **)this + 27));
LABEL_22:
  CA::OGL::Renderer::prepare_clip_shape((CA::OGL::Renderer *)a2, *((const CA::Render::Update **)a3 + 2));
  CA::Render::Update::render_edr_factor(a3, v19);
  float v21 = v20;
  if (v11)
  {
    unsigned int v22 = CA::Render::fourcc_to_format((CA::Render *)*(unsigned int *)(v11 + 64));
    if (((v22 < 0x1D) & (0x17826000u >> v22)) != 0) {
      float v21 = 1.0;
    }
  }
  (*(void (**)(CA::Shape *, float))(*(void *)v7 + 1048))(v7, v21);
  if (v11 && (*(unsigned int (**)(CA::Shape *, uint64_t))(*(void *)v7 + 920))(v7, v11))
  {
    if ((*(unsigned int (**)(CA::WindowServer::Display *))(*(void *)this + 1536))(this))
    {
      CA::Render::Update::render_edr_factor(a3, v23);
      float v25 = 1.0 / v24;
    }
    else
    {
      float v25 = *((float *)a3 + 93);
      float v21 = 1.0 / v25;
    }
    *(float *)(v11 + 68) = v25;
    (*(void (**)(uint64_t, float))(*(void *)v11 + 200))(v11, v21);
    CA::OGL::Renderer::render((CA::OGL::Renderer *)a2, a3, *(void *)(v11 + 16), v26);
    unsigned int v28 = *(_DWORD *)(v11 + 224);
    uint64_t v27 = v11 + 224;
    uint64_t v29 = *(unsigned __int8 *)(v27 + 4);
    *(_DWORD *)uint64_t v27 = v28;
    *(unsigned char *)(v27 + 4) = ((v28 | (unint64_t)(v29 << 32)) & 0xFFFFFFFDFFFFFFFFLL) >> 32;
    (*(void (**)(CA::Shape *, void))(*(void *)v7 + 920))(v7, 0);
  }
  int8x16_t v30 = a2[2];
  if (v30)
  {
    CA::Shape::unref(v30);
    a2[2] = 0;
  }
  (*(void (**)(CA::Shape *, float))(*(void *)v7 + 1048))(v7, 1.0);
  *((void *)v7 + 24) = 0;
  unsigned int v31 = *((unsigned __int16 *)v7 + 416);
  if ((v31 & 0x80) != 0) {
    (*(void (**)(CA::WindowServer::Display *))(*(void *)this + 504))(this);
  }
  return (v31 >> 7) & 1;
}

void CA::Render::Update::render_edr_factor(CA::Render::Update *this, const CA::Render::LayerNode *a2)
{
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
}

uint64_t CA::OGL::MetalContext::set_hdr_scale(uint64_t this, float a2)
{
  *(float *)(this + 2936) = a2;
  return this;
}

uint64_t CA::OGL::MetalContext::make_buffer_current(CA::OGL::MetalContext *this, CA::WindowServer::Surface *a2)
{
  if (a2)
  {
    uint64_t result = CA::OGL::MetalContext::get_surface(this, a2, 1);
    if (!result) {
      return result;
    }
    uint64_t v5 = result;
    *((void *)this + 386) = (*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)a2 + 216))(a2);
    CA::OGL::Context::push_surface((uint64_t)this, v5, (*(_WORD *)(v5 + 75) & 0x80) == 0, 0, 0);
    *((void *)this + 353) = v5;
    *((void *)this + 354) = *(void *)(v5 + 120);
  }
  else
  {
    *((void *)this + 386) = 0;
    CA::OGL::Context::pop_surface(this);
    uint64_t v6 = *((void *)this + 34);
    if (v6 != *((void *)this + 33)) {
      goto LABEL_5;
    }
    if (v6) {
      LODWORD(v6) = (*(unsigned __int8 *)(v6 + 72) >> 1) & 0x1F;
    }
    if (*((_DWORD *)this + 65) != v6) {
LABEL_5:
    }
      CA::OGL::Context::prepare_destination_(this);
    *(_OWORD *)((char *)this + 2824) = 0u;
  }
  return 1;
}

uint64_t CA::WindowServer::IOSurface::set_edr_factor(uint64_t this, float a2)
{
  if (*(float *)(this + 252) != a2)
  {
    *(float *)(this + 252) = a2;
    this = *(void *)(this + 240);
    if (this) {
      return IOSurfaceSetBulkAttachments2();
    }
  }
  return this;
}

uint64_t CA::Render::fourcc_to_format(CA::Render *this)
{
  int v1 = CA::Render::fourcc_compressed_of_type(this, 0, 0);
  if (v1 > 1279342647)
  {
    if (v1 > 1647534391)
    {
      if (v1 > 1999843441)
      {
        switch(v1)
        {
          case 1999843442:
            return 33;
          case 1999908961:
            return 34;
          case 2037741171:
            return 7;
        }
      }
      else
      {
        switch(v1)
        {
          case 1647534392:
            return 35;
          case 1815162994:
            return 31;
          case 1815491698:
            return 21;
        }
      }
      return 0xFFFFFFFFLL;
    }
    if (v1 > 1380401728)
    {
      switch(v1)
      {
        case 1380401729:
          return 11;
        case 1380410945:
          return 14;
        case 1380411457:
          return 13;
      }
      return 0xFFFFFFFFLL;
    }
    if (v1 != 1279342648)
    {
      if (v1 == 1378955371) {
        return 32;
      }
      return 0xFFFFFFFFLL;
    }
    return 18;
  }
  if (v1 > 892679472)
  {
    if (v1 <= 1278226487)
    {
      switch(v1)
      {
        case 892679473:
          return 20;
        case 1093677112:
          return 9;
        case 1111970369:
          return 1;
      }
      return 0xFFFFFFFFLL;
    }
    if (v1 == 1278226488) {
      return 10;
    }
    if (v1 == 1278555445) {
      return 5;
    }
    if (v1 != 1279340600) {
      return 0xFFFFFFFFLL;
    }
    return 18;
  }
  if (v1 > 843264103)
  {
    switch(v1)
    {
      case 843264104:
        return 28;
      case 843264310:
        return 27;
      case 846624121:
        return 6;
    }
    return 0xFFFFFFFFLL;
  }
  if (v1 == 16) {
    return 4;
  }
  uint64_t v2 = 0;
  if (v1 != 32) {
    return 0xFFFFFFFFLL;
  }
  return v2;
}

void CA::OGL::Renderer::prepare_clip_shape(CA::OGL::Renderer *this, const CA::Render::Update *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  id v4 = (CA::Shape *)*((void *)this + 2);
  if (v4) {
    CA::Shape::unref(v4);
  }
  *((void *)this + 2) = 0;
  if ((a2 & 1) == 0)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    int v5 = *((_DWORD *)a2 + 1);
    if (v5 != 6 && v5 != 12)
    {
      CA::Shape::get_bounds((uint64_t)a2, (int *)&v9);
      if ((*(unsigned char *)(*(void *)this + 432) & 0x10) != 0
        || (uint64_t v7 = SHIDWORD(v10) * (uint64_t)(int)v10, v7 < 2 * CA::Shape::area(a2)))
      {
        uint64_t v8 = (CA::Shape *)*((void *)this + 2);
        if (v8) {
          CA::Shape::unref(v8);
        }
        *((void *)this + 2) = CA::Shape::new_shape((unsigned int *)&v9);
      }
    }
  }
}

uint64_t CA::OGL::MetalContext::get_surface(CA::OGL::MetalContext *this, CA::WindowServer::Surface *a2, int a3)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  uint64_t v6 = (*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)a2 + 160))(a2);
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *((unsigned int *)a2 + 14);
  if (!v7
    || (unint64_t v8 = *((unsigned int *)a2 + 15), !v8)
    || (unint64_t v9 = *((void *)this + 337), v9 < v7)
    || v9 < v8)
  {
    if (x_log_hook_p())
    {
LABEL_12:
      x_log_();
      return 0;
    }
    uint64_t v15 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT)) {
      return 0;
    }
    int v16 = *((_DWORD *)a2 + 14);
    int v17 = *((_DWORD *)a2 + 15);
    *(_DWORD *)buf = 67109376;
    int v72 = v16;
    __int16 v73 = 1024;
    int v74 = v17;
    uint64_t v18 = "Ignoring [%d x %d] invalid surface dimensions";
    uint64_t v19 = v15;
    os_log_type_t v20 = OS_LOG_TYPE_DEFAULT;
    uint32_t v21 = 14;
LABEL_15:
    _os_log_impl(&dword_184668000, v19, v20, v18, buf, v21);
    return 0;
  }
  uint64_t v10 = (__IOSurface *)v6;
  unint64_t v11 = *((unsigned int *)a2 + 16);
  MTLPixelFormat v12 = CA::OGL::four_cc_to_mtl_format((CA::Render *)v11, *((_DWORD *)this + 681));
  if (v12 == MTLPixelFormatInvalid)
  {
    if (x_log_hook_p())
    {
      if ((v11 & 0x80000000) != 0) {
        __maskrune(v11 >> 24, 0x40000uLL);
      }
      if (BYTE2(v11) > 0x7Fu) {
        __maskrune(BYTE2(v11), 0x40000uLL);
      }
      if (BYTE1(v11) > 0x7Fu) {
        __maskrune(BYTE1(v11), 0x40000uLL);
      }
      if (v11 > 0x7Fu) {
        __maskrune(v11, 0x40000uLL);
      }
      goto LABEL_12;
    }
    uint64_t v24 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    unint64_t v25 = v11 >> 24;
    if ((v11 & 0x80000000) != 0) {
      int v26 = __maskrune(v25, 0x40000uLL);
    }
    else {
      int v26 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v25 + 60) & 0x40000;
    }
    if (v26) {
      int v50 = (int)v11 >> 24;
    }
    else {
      int v50 = 32;
    }
    if (BYTE2(v11) <= 0x7Fu) {
      int v51 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * BYTE2(v11) + 60) & 0x40000;
    }
    else {
      int v51 = __maskrune(BYTE2(v11), 0x40000uLL);
    }
    if (v51) {
      int v52 = SBYTE2(v11);
    }
    else {
      int v52 = 32;
    }
    if (BYTE1(v11) <= 0x7Fu) {
      int v53 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * BYTE1(v11) + 60) & 0x40000;
    }
    else {
      int v53 = __maskrune(BYTE1(v11), 0x40000uLL);
    }
    if (v53) {
      int v54 = SBYTE1(v11);
    }
    else {
      int v54 = 32;
    }
    if (v11 <= 0x7Fu) {
      int v55 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v11 + 60) & 0x40000;
    }
    else {
      int v55 = __maskrune(v11, 0x40000uLL);
    }
    *(_DWORD *)buf = 67109888;
    int v56 = (char)v11;
    int v72 = v50;
    __int16 v73 = 1024;
    if (!v55) {
      int v56 = 32;
    }
    int v74 = v52;
    __int16 v75 = 1024;
    int v76 = v54;
    __int16 v77 = 1024;
    int v78 = v56;
    uint64_t v18 = "Unsupported IOSurface pixel format: %c%c%c%c";
    uint64_t v19 = v24;
    os_log_type_t v20 = OS_LOG_TYPE_ERROR;
    uint32_t v21 = 26;
    goto LABEL_15;
  }
  uint64_t v13 = v12;
  if (!CA::OGL::MetalContext::is_viable_texture_from_iosurface(this, v10, v12)) {
    return 0;
  }
  if (*((void (**)(CA::OGL::MetalContext *, CA::WindowServer::Surface *, void *))a2 + 10) != CA::OGL::MetalContext::release_display_surfaces
    || (uint64_t v27 = *((void *)a2 + 9)) == 0)
  {
    operator new();
  }
  int v28 = *((_DWORD *)a2 + 16);
  BOOL v29 = v28 == 643969848 || v28 == 1647534392;
  if (v29 && a3)
  {
    unsigned int v30 = ((*((_DWORD *)a2 + 56) & 0x40000000) == 0) & (*((unsigned __int8 *)this + 2725) >> 1);
    if (v30) {
      uint64_t v13 = 554;
    }
    uint64_t v22 = *(void *)(v27 + 8 * v30 + 8);
    if ((*((_DWORD *)a2 + 56) & 0x80000000) != 0)
    {
      uint64_t v31 = *(void *)(v27
                      + 8 * ((((*((_DWORD *)a2 + 56) & 0x40000000) == 0) & (*((unsigned char *)this + 2725) >> 1)) == 0)
                      + 8);
      int v32 = *(_WORD *)(v22 + 75) & 0xFF7F | (((*(unsigned __int16 *)(v31 + 75) >> 7) & 1) << 7);
      *(_WORD *)(v22 + 75) = *(_WORD *)(v22 + 75) & 0xFF7F | (((*(_WORD *)(v31 + 75) >> 7) & 1) << 7);
      *(_DWORD *)(v22 + 4) = *(_DWORD *)(v31 + 4);
      unint64_t v33 = *((unsigned int *)a2 + 56) | ((unint64_t)*((unsigned __int8 *)a2 + 228) << 32);
      if ((v33 & 0x200000000) != 0)
      {
        *(_WORD *)(v22 + 75) = v32 | 0x20;
        unint64_t v33 = *((unsigned int *)a2 + 56) | ((unint64_t)*((unsigned __int8 *)a2 + 228) << 32);
      }
      *((_DWORD *)a2 + 56) = v33 & 0x7FFFFFFF;
      *((unsigned char *)a2 + 228) = (v33 & 0xFFFFFFFF7FFFFFFFLL) >> 32;
    }
  }
  else
  {
    uint64_t v22 = *(void *)(v27 + 8);
  }
  if (a3)
  {
    if (CADeviceUseFramebufferCompression::once != -1) {
      dispatch_once(&CADeviceUseFramebufferCompression::once, &__block_literal_global_30);
    }
    uint64_t v34 = *((void *)this + 24);
    if (v34)
    {
      int v35 = CADeviceUseFramebufferCompression::enable_compression;
      uint64_t v36 = (*(uint64_t (**)(uint64_t))(*(void *)v34 + 16))(v34);
      BOOL v37 = 0;
      if (v36 && !v35) {
        BOOL v37 = (*(_WORD *)(v36 + 656) & 0xFD) == 1;
      }
    }
    else
    {
      BOOL v37 = 0;
    }
    if (((*(unsigned __int16 *)(v22 + 232) >> 10) & 1) != v37) {
      CA::OGL::MetalContext::finalize_surface_textures((uint64_t)this, v22);
    }
    BOOL v38 = v37;
  }
  else
  {
    BOOL v38 = 0;
  }
  *(void *)&long long v39 = *((void *)a2 + 7);
  __int16 v40 = *(_WORD *)(v22 + 232);
  if (v38) {
    __int16 v41 = 1024;
  }
  else {
    __int16 v41 = 0;
  }
  *((void *)&v39 + 1) = *((void *)this + 25);
  *(_OWORD *)(v22 + 24) = v39;
  *(void *)(v22 + 40) = *((void *)this + 26);
  *(_WORD *)(v22 + 232) = v40 & 0xFBFF | v41;
  if (v38) {
    int v42 = DWORD1(v39);
  }
  else {
    int v42 = v39;
  }
  if (v38) {
    int v43 = v39;
  }
  else {
    int v43 = DWORD1(v39);
  }
  *(_DWORD *)(v22 + 184) = v42;
  *(_DWORD *)(v22 + 188) = v43;
  *(_DWORD *)(v22 + 64) = *((_DWORD *)this + 734);
  *(_WORD *)(v22 + 75) |= 0x100u;
  if (!*(void *)(v22 + 96))
  {
    char v44 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:v13 width:v42 height:v43 mipmapped:0];
    int v45 = v44;
    if (a3)
    {
      [v44 setFramebufferOnly:1];
      if (v38) {
        uint64_t v46 = 3;
      }
      else {
        uint64_t v46 = 0;
      }
      [v45 setRotation:v46];
      uint64_t v47 = 5;
    }
    else
    {
      uint64_t v47 = 17;
    }
    [v45 setUsage:v47];
    unint64_t v48 = (void *)[*((id *)this + 369) newTextureWithDescriptor:v45 iosurface:v10 plane:0];
    *(void *)(v22 + 96) = v48;
    [v48 setLabel:@"com.apple.coreanimation.framebuffer-surface"];
    *(void *)(v22 + 120) = v13;
    *(_WORD *)(v22 + 232) = *(_WORD *)(v22 + 232) & 0xFFF0 | 1;
    if (*(void *)(v22 + 96))
    {
      CA::OGL::MetalContext::add_memoryless_textures((uint64_t)this, v22);
      goto LABEL_76;
    }
    if (x_log_hook_p())
    {
      if ((v11 & 0x80000000) != 0) {
        __maskrune(v11 >> 24, 0x40000uLL);
      }
      if (BYTE2(v11) > 0x7Fu) {
        __maskrune(BYTE2(v11), 0x40000uLL);
      }
      if (BYTE1(v11) > 0x7Fu) {
        __maskrune(BYTE1(v11), 0x40000uLL);
      }
      if (v11 > 0x7Fu) {
        __maskrune(v11, 0x40000uLL);
      }
      MTLPixelFormatGetName();
      goto LABEL_12;
    }
    uint64_t v57 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    uint64_t v58 = 28;
    if ((*(_WORD *)(v22 + 232) & 0x400) != 0) {
      uint64_t v59 = 28;
    }
    else {
      uint64_t v59 = 24;
    }
    int v60 = *(_DWORD *)(v22 + v59);
    if ((*(_WORD *)(v22 + 232) & 0x400) != 0) {
      uint64_t v58 = 24;
    }
    int v61 = *(_DWORD *)(v22 + v58);
    uint64_t v62 = MEMORY[0x1E4F14390];
    if ((v11 & 0x80000000) != 0) {
      int v63 = __maskrune(BYTE3(v11), 0x40000uLL);
    }
    else {
      int v63 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * BYTE3(v11) + 60) & 0x40000;
    }
    if (v63) {
      int v64 = (int)v11 >> 24;
    }
    else {
      int v64 = 32;
    }
    if (BYTE2(v11) <= 0x7Fu) {
      int v65 = *(_DWORD *)(v62 + 4 * BYTE2(v11) + 60) & 0x40000;
    }
    else {
      int v65 = __maskrune(BYTE2(v11), 0x40000uLL);
    }
    if (v65) {
      int v66 = SBYTE2(v11);
    }
    else {
      int v66 = 32;
    }
    if (BYTE1(v11) <= 0x7Fu) {
      int v67 = *(_DWORD *)(v62 + 4 * BYTE1(v11) + 60) & 0x40000;
    }
    else {
      int v67 = __maskrune(BYTE1(v11), 0x40000uLL);
    }
    if (v67) {
      int v68 = SBYTE1(v11);
    }
    else {
      int v68 = 32;
    }
    if (v11 <= 0x7Fu) {
      int v69 = *(_DWORD *)(v62 + 4 * v11 + 60) & 0x40000;
    }
    else {
      int v69 = __maskrune(v11, 0x40000uLL);
    }
    if (v69) {
      int v70 = (char)v11;
    }
    else {
      int v70 = 32;
    }
    *(_DWORD *)buf = 67110658;
    int v72 = v60;
    __int16 v73 = 1024;
    int v74 = v61;
    __int16 v75 = 1024;
    int v76 = v64;
    __int16 v77 = 1024;
    int v78 = v66;
    __int16 v79 = 1024;
    int v80 = v68;
    __int16 v81 = 1024;
    int v82 = v70;
    __int16 v83 = 2080;
    uint64_t Name = MTLPixelFormatGetName();
    uint64_t v18 = "Failed to allocate [%d x %d] %c%c%c%c framebuffer %s";
    uint64_t v19 = v57;
    os_log_type_t v20 = OS_LOG_TYPE_ERROR;
    uint32_t v21 = 48;
    goto LABEL_15;
  }
LABEL_76:
  if ((unint64_t)(v13 - 550) <= 5) {
    *(_DWORD *)(v22 + 68) |= 0x100u;
  }
  if (v13 == 115)
  {
    int v49 = 16;
  }
  else
  {
    if (v13 != 125) {
      goto LABEL_83;
    }
    int v49 = 32;
  }
  *(_DWORD *)(v22 + 68) |= v49;
LABEL_83:
  if (!CA::OGL::metal_pixel_format_has_alpha_plane((CA::OGL *)v13, v14)) {
    *(_DWORD *)(v22 + 68) &= ~8u;
  }
  return v22;
}

uint64_t CA::WindowServer::anonymous namespace'::OGLDisplay::native_display(CA::WindowServer::_anonymous_namespace_::OGLDisplay *this)
{
  return *((void *)this + 1);
}

uint64_t CA::OGL::four_cc_to_mtl_format(CA::Render *a1, __int16 a2)
{
  int v3 = CA::Render::fourcc_compressed_of_type(a1, 0, 0);
  uint64_t result = 0;
  if (v3 > 1882468913)
  {
    if (v3 <= 1953903153)
    {
      if (v3 > 1886676531)
      {
        if (v3 <= 1952854575)
        {
          if (v3 <= 1886680625)
          {
            if (v3 != 1886676532)
            {
              if (v3 != 1886680624) {
                return result;
              }
              goto LABEL_139;
            }
LABEL_108:
            BOOL v16 = (a2 & 0x40) == 0;
            uint64_t v17 = 582;
            goto LABEL_148;
          }
          if (v3 != 1886680626)
          {
            if (v3 != 1886680628) {
              return result;
            }
            goto LABEL_108;
          }
LABEL_116:
          BOOL v16 = (a2 & 0x40) == 0;
          uint64_t v17 = 581;
          goto LABEL_148;
        }
        if (v3 <= 1952855091)
        {
          if (v3 != 1952854576)
          {
            if (v3 != 1952854578) {
              return result;
            }
            goto LABEL_144;
          }
LABEL_129:
          BOOL v16 = (a2 & 0x20) == 0;
          uint64_t v17 = 570;
          goto LABEL_148;
        }
        if (v3 != 1952855092)
        {
          if (v3 != 1953903152) {
            return result;
          }
          goto LABEL_129;
        }
LABEL_141:
        BOOL v16 = (a2 & 0x20) == 0;
        uint64_t v17 = 572;
        goto LABEL_148;
      }
      if (v3 <= 1885745713)
      {
        if (v3 != 1882468914)
        {
          if (v3 != 1882469428)
          {
            int v24 = 1885745712;
            goto LABEL_132;
          }
LABEL_137:
          BOOL v16 = (a2 & 0x10) == 0;
          uint64_t v17 = 510;
          goto LABEL_148;
        }
      }
      else
      {
        if (v3 > 1886676527)
        {
          if (v3 == 1886676528)
          {
LABEL_139:
            BOOL v16 = (a2 & 0x40) == 0;
            uint64_t v17 = 580;
            goto LABEL_148;
          }
          if (v3 != 1886676530) {
            return result;
          }
          goto LABEL_116;
        }
        if (v3 != 1885745714)
        {
          if (v3 != 1885746228) {
            return result;
          }
          goto LABEL_137;
        }
      }
      BOOL v16 = (a2 & 0x10) == 0;
      uint64_t v17 = 509;
      goto LABEL_148;
    }
    if (v3 <= 2016687215)
    {
      if (v3 <= 1999908960)
      {
        if (v3 == 1953903154)
        {
LABEL_144:
          BOOL v16 = (a2 & 0x20) == 0;
          uint64_t v17 = 571;
          goto LABEL_148;
        }
        if (v3 != 1953903668)
        {
          uint64_t v27 = 554;
          if ((a2 & 0x200) == 0) {
            uint64_t v27 = 0;
          }
          if (v3 == 1999843442) {
            return v27;
          }
          else {
            return 0;
          }
        }
        goto LABEL_141;
      }
      if (v3 <= 2016686641)
      {
        if (v3 == 1999908961)
        {
          BOOL v16 = (a2 & 0x200) == 0;
          uint64_t v17 = 552;
          goto LABEL_148;
        }
        int v15 = 2016686640;
LABEL_50:
        if (v3 != v15) {
          return result;
        }
        BOOL v16 = (a2 & 0x10) == 0;
        uint64_t v17 = 505;
        goto LABEL_148;
      }
      if (v3 != 2016686642)
      {
        int v28 = 2016687156;
        goto LABEL_125;
      }
    }
    else
    {
      if (v3 > 2019964015)
      {
        if (v3 > 2037741157)
        {
          if (v3 != 2037741158 && v3 != 2037741171) {
            return result;
          }
          BOOL v16 = (a2 & 4) == 0;
          uint64_t v17 = 501;
          goto LABEL_148;
        }
        if (v3 != 2019964016)
        {
          BOOL v5 = v3 == 2033463606;
          uint64_t v6 = 110;
          goto LABEL_119;
        }
        goto LABEL_142;
      }
      if (v3 <= 2019963441)
      {
        if (v3 != 2016687216)
        {
          int v15 = 2019963440;
          goto LABEL_50;
        }
LABEL_142:
        BOOL v16 = (a2 & 0x10) == 0;
        uint64_t v17 = 504;
        goto LABEL_148;
      }
      if (v3 != 2019963442)
      {
        int v28 = 2019963956;
LABEL_125:
        if (v3 != v28) {
          return result;
        }
        BOOL v16 = (a2 & 0x10) == 0;
        uint64_t v17 = 507;
        goto LABEL_148;
      }
    }
    BOOL v16 = (a2 & 0x10) == 0;
    uint64_t v17 = 506;
    goto LABEL_148;
  }
  if (v3 > 1278226535)
  {
    if (v3 > 1380401728)
    {
      if (v3 <= 1647534391)
      {
        int v7 = 1380411456;
        uint64_t v8 = 542;
        if ((a2 & 4) == 0) {
          uint64_t v8 = 0;
        }
        if (v3 == 1599226420) {
          uint64_t v9 = v8;
        }
        else {
          uint64_t v9 = 0;
        }
        if (v3 == 1380411457) {
          uint64_t v10 = 115;
        }
        else {
          uint64_t v10 = v9;
        }
        int v11 = 1380401729;
        uint64_t v12 = 70;
        BOOL v13 = v3 == 1380410945;
        uint64_t v14 = 125;
        goto LABEL_58;
      }
      if (v3 <= 1815491697)
      {
        int v20 = 1647534392;
        uint64_t v21 = 550;
        if ((a2 & 0x100) == 0) {
          uint64_t v21 = 0;
        }
        BOOL v22 = v3 == 1815162994;
        uint64_t v23 = 94;
        goto LABEL_79;
      }
      if (v3 == 1815491698) {
        return 110;
      }
      int v24 = 1882468912;
LABEL_132:
      if (v3 != v24) {
        return result;
      }
      BOOL v16 = (a2 & 0x10) == 0;
      uint64_t v17 = 508;
      goto LABEL_148;
    }
    if (v3 <= 1278555700)
    {
      int v20 = 1278226536;
      uint64_t v21 = 25;
      uint64_t v25 = 43;
      if ((a2 & 0x400) == 0) {
        uint64_t v25 = 0;
      }
      if (v3 == 1278555445) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = 0;
      }
      if (v3 == 1278226742) {
        uint64_t v23 = 20;
      }
      else {
        uint64_t v23 = v26;
      }
      goto LABEL_93;
    }
    if (v3 <= 1279342647)
    {
      if (v3 == 1278555701) {
        return 40;
      }
      if (v3 != 1279340600) {
        return result;
      }
      return 30;
    }
    if (v3 == 1279342648) {
      return 30;
    }
    BOOL v5 = v3 == 1378955371;
    uint64_t v6 = 90;
LABEL_119:
    if (v5) {
      return v6;
    }
    else {
      return 0;
    }
  }
  if (v3 <= 875704949)
  {
    if (v3 > 846624120)
    {
      if (v3 > 875704437)
      {
        if (v3 != 875704438)
        {
          if (v3 != 875704934) {
            return result;
          }
LABEL_113:
          BOOL v16 = (a2 & 0x10) == 0;
          uint64_t v17 = 502;
          goto LABEL_148;
        }
        goto LABEL_138;
      }
      if (v3 != 846624121)
      {
        if (v3 != 875704422) {
          return result;
        }
LABEL_138:
        BOOL v16 = (a2 & 4) == 0;
        uint64_t v17 = 500;
        goto LABEL_148;
      }
      BOOL v16 = (a2 & 8) == 0;
      uint64_t v17 = 562;
LABEL_148:
      if (v16) {
        return 0;
      }
      else {
        return v17;
      }
    }
    if (v3 != 843264056)
    {
      int v20 = 843264104;
      uint64_t v21 = 65;
      BOOL v22 = v3 == 843264310;
      uint64_t v23 = 60;
LABEL_79:
      if (!v22) {
        uint64_t v23 = 0;
      }
LABEL_93:
      if (v3 == v20) {
        return v21;
      }
      else {
        return v23;
      }
    }
    return 30;
  }
  if (v3 > 1093677111)
  {
    int v7 = 1278226487;
    uint64_t v18 = 55;
    if (v3 != 1278226534) {
      uint64_t v18 = 0;
    }
    if (v3 == 1278226488) {
      uint64_t v10 = 10;
    }
    else {
      uint64_t v10 = v18;
    }
    int v11 = 1093677112;
    uint64_t v12 = 1;
    BOOL v13 = v3 == 1111970369;
    uint64_t v14 = 80;
LABEL_58:
    if (!v13) {
      uint64_t v14 = 0;
    }
    if (v3 == v11) {
      uint64_t v19 = v12;
    }
    else {
      uint64_t v19 = v14;
    }
    if (v3 <= v7) {
      return v19;
    }
    else {
      return v10;
    }
  }
  if (v3 <= 875836517)
  {
    if (v3 != 875704950)
    {
      BOOL v5 = v3 == 875836468;
      uint64_t v6 = 42;
      goto LABEL_119;
    }
    goto LABEL_113;
  }
  if (v3 == 875836518 || v3 == 875836534)
  {
    BOOL v16 = (a2 & 0x10) == 0;
    uint64_t v17 = 503;
    goto LABEL_148;
  }
  return result;
}

BOOL CA::OGL::MetalContext::is_viable_texture_from_iosurface(CA::OGL::MetalContext *this, IOSurfaceRef buffer, MTLPixelFormat a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (IOSurfaceGetPlaneCount(buffer)) {
    return 1;
  }
  size_t BytesPerRow = IOSurfaceGetBytesPerRow(buffer);
  uint64_t v6 = qword_1EB2A87C8;
  if (((qword_1EB2A87C8 - 1) & BytesPerRow) == 0)
  {
    size_t BytesPerElement = IOSurfaceGetBytesPerElement(buffer);
    uint64_t v20 = 0;
    long long v18 = 0u;
    long long v19 = 0u;
    memset(v17, 0, sizeof(v17));
    MTLGetTextureLevelInfoForDeviceWithOptions();
    IOSurfaceGetWidth(buffer);
    if (IOSurfaceAllowsPixelSizeCasting(buffer) || *((void *)&v18 + 1) == BytesPerElement) {
      return 1;
    }
    if (x_log_hook_p()) {
      goto LABEL_9;
    }
    uint64_t v8 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)buf = 67109632;
    IOSurfaceID ID = IOSurfaceGetID(buffer);
    __int16 v13 = 2048;
    uint64_t v14 = *((void *)&v18 + 1);
    __int16 v15 = 2048;
    size_t v16 = BytesPerElement;
    uint64_t v9 = "Failed to allocate MTLTexture from IOSurface 0x%x. Texture block bytes (%ld) not equal to surface block bytes (%ld).";
    uint64_t v10 = buf;
LABEL_12:
    _os_log_impl(&dword_184668000, v8, OS_LOG_TYPE_ERROR, v9, v10, 0x1Cu);
    return 0;
  }
  if (!x_log_hook_p())
  {
    uint64_t v8 = x_log_category_ogl_metal;
    BOOL result = os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LODWORD(v17[0]) = 67109632;
    DWORD1(v17[0]) = IOSurfaceGetID(buffer);
    WORD4(v17[0]) = 2048;
    *(void *)((char *)v17 + 10) = BytesPerRow;
    WORD1(v17[1]) = 2048;
    *(void *)((char *)&v17[1] + 4) = v6;
    uint64_t v9 = "Failed to allocate MTLTexture from IOSurface 0x%x. Row bytes (%ld) not %ld aligned.";
    uint64_t v10 = (uint8_t *)v17;
    goto LABEL_12;
  }
LABEL_9:
  IOSurfaceGetID(buffer);
  x_log_();
  return 0;
}

BOOL CA::OGL::metal_pixel_format_has_alpha_plane(CA::OGL *this, MTLPixelFormat a2)
{
  BOOL result = 1;
  if ((unint64_t)this - 70 > 0x37 || ((1 << (this - 70)) & 0xE03D0000000C1FLL) == 0)
  {
    id v4 = (char *)this - 550;
    BOOL v5 = this == (CA::OGL *)1;
    return (unint64_t)v4 < 4 || v5;
  }
  return result;
}

void *CA::WindowServer::Display::ogl_display(CA::WindowServer::Display *this)
{
  BOOL result = (void *)*((void *)this + 38);
  if (!result)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    BOOL result = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    if (result)
    {
      void *result = &unk_1ED023C80;
      result[1] = this;
    }
    *((void *)this + 38) = result;
  }
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::update_surface(CA::WindowServer::IOMFBDisplay *this, int a2, int a3, uint64_t a4)
{
  int v8 = CA::WindowServer::IOMFBDisplay::use_assembly_surface(this);

  return CA::WindowServer::IOMFBDisplay::current_page_surface(this, v8, a2, a3, 0, a4);
}

uint64_t CA::WindowServer::IOMFBDisplay::dirty_update_surface(CA::WindowServer::IOMFBDisplay *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 25720);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
  uint64_t v3 = *((void *)this + 6 * *((unsigned int *)this + 6426) + 3224);
  if (v3)
  {
    *(unsigned char *)(v3 + 132) = *(unsigned char *)(v3 + 132) & 0xFA | 1;
    if (CA::WindowServer::IOMFBDisplay::use_assembly_surface(this)) {
      *(unsigned char *)(v3 + 132) |= 2u;
    }
  }

  return pthread_mutex_unlock(v2);
}

void CA::CG::DrawOp::~DrawOp(CA::CG::DrawOp *this)
{
  *(void *)this = &unk_1ED029D88;
  uint64_t v2 = *((void *)this + 13);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (CFTypeRef *)*((void *)this + 10);
  if (v3)
  {
    CFRelease(*v3);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v3);
  }
  BOOL v5 = (void (***)(char *))*((void *)this + 9);
  if (v5 && atomic_fetch_add((atomic_uint *volatile)v5, 0xFFFFFFFF) == 1) {
    CA::CG::ClipStack::destroy_clip_stack(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 8);
  if (v6)
  {
    CGSoftMaskRelease();
    CGRenderingStateRelease();
    CGGStateRelease();
    int v7 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v7, v6);
  }
}

uint64_t CA::CG::DrawOp::invalidate(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 104);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

uint64_t CA::CG::Queue::mark_serial(CA::CG::Queue *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 56);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 56));
  ++*((_DWORD *)this + 13);
  pthread_cond_broadcast((pthread_cond_t *)((char *)this + 120));

  return pthread_mutex_unlock(v2);
}

uint64_t CA::CG::Renderer::update_finished_seed(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 8);
  if (v1 && *(_DWORD *)(this + 156) < (*(_DWORD *)(this + 152) - 1))
  {
    double v2 = *(double *)(v1 + 240) + -0.25;
    int v3 = *(_DWORD *)(this + 288);
    int v4 = 8;
    do
    {
      int v5 = v3 + v4;
      if (v3 + v4 - 8 >= 0) {
        int v5 = v3 + v4 - 8;
      }
      --v4;
    }
    while (v4 && *(double *)(this + 16 * v5 + 160) > v2);
    *(_DWORD *)(this + 156) = *(_DWORD *)(this + 16 * v5 + 168);
  }
  return this;
}

void CA::CG::Queue::deallocate_slab(void *a1)
{
  if (a1[4])
  {
    a1[1] = a1[2];
    os_unfair_lock_lock((os_unfair_lock_t)&CA::CG::Queue::_free_lock);
    *a1 = CA::CG::Queue::_free_slabs;
    CA::CG::Queue::_free_slabs = (uint64_t)a1;
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::CG::Queue::_free_lock);
  }
  else
  {
    free(a1);
  }
}

CGColorSpace *CA::CG::AccelContextDelegate<CA::CG::MetalDrawable>::set_drawable(CGColorSpace *this, uint64_t a2)
{
  double v2 = (atomic_uint *)*((void *)this + 42);
  if (v2 != (atomic_uint *)a2)
  {
    uint64_t v4 = (uint64_t)this;
    if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1)
    {
      (**(void (***)(atomic_uint *))v2)(v2);
      this = (CGColorSpace *)(*(uint64_t (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
    }
    if (a2)
    {
      while (1)
      {
        int v5 = *(_DWORD *)(a2 + 8);
        if (!v5) {
          break;
        }
        int v6 = *(_DWORD *)(a2 + 8);
        atomic_compare_exchange_strong((atomic_uint *volatile)(a2 + 8), (unsigned int *)&v6, v5 + 1);
        if (v6 == v5)
        {
          uint64_t v7 = a2;
          goto LABEL_12;
        }
      }
      uint64_t v7 = 0;
LABEL_12:
      *(void *)(v4 + 336) = v7;
      *(void *)&long long v8 = *(void *)(a2 + 36);
      *((void *)&v8 + 1) = *(void *)(a2 + 52);
      *(_OWORD *)(v4 + 16) = v8;
      uint64_t v9 = *(CGColorSpace **)(a2 + 24);
      return CA::CG::ContextDelegate::set_colorspace((CA::CG::ContextDelegate *)v4, v9);
    }
    else
    {
      *(void *)(v4 + 336) = 0;
    }
  }
  return this;
}

CA::CG::IOSurfaceDrawable *CA::CG::IOSurfaceDrawable::IOSurfaceDrawable(CA::CG::IOSurfaceDrawable *this, IOSurfaceRef buffer, int a3, int a4, CGColorSpace *a5, unsigned int a6, unsigned int a7, int a8, unsigned int a9)
{
  int Width = IOSurfaceGetWidth(buffer);
  unsigned int Height = IOSurfaceGetHeight(buffer);
  *(void *)this = &unk_1ED028088;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = a3;
  *((void *)this + 3) = CGColorSpaceRetain(a5);
  *((_DWORD *)this + 8) = a4;
  *(void *)((char *)this + 36) = __PAIR64__(a7, a6);
  *((_DWORD *)this + 11) = Width;
  *((_DWORD *)this + 12) = Height;
  if (a8) {
    int v18 = a8;
  }
  else {
    int v18 = Width;
  }
  if (a9) {
    unsigned int v19 = a9;
  }
  else {
    unsigned int v19 = Height;
  }
  *((_DWORD *)this + 13) = v18;
  *((_DWORD *)this + 14) = v19;
  *(void *)((char *)this + 60) = 0;
  *(_DWORD *)((char *)this + 67) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 9) = 0;
  *((_DWORD *)this + 2) = 1;
  *(void *)this = &unk_1ED029078;
  *((void *)this + 12) = CFRetain(buffer);
  *((void *)this + 13) = 0;
  return this;
}

void *CA::CG::IOSurfaceDrawable::create_queue(CA::CG::IOSurfaceDrawable *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t result = malloc_type_zone_malloc(malloc_zone, 0xD8uLL, 0x8BB15036uLL);
  if (result)
  {
    uint64_t result = (void *)CA::CG::AccelQueue::AccelQueue((uint64_t)result, (uint64_t)this);
    void *result = &unk_1ED028728;
  }
  return result;
}

CA::CG::ContextDelegate *CA::CG::ContextDelegate::ContextDelegate(CA::CG::ContextDelegate *this)
{
  *(void *)this = &unk_1ED028810;
  *((void *)this + 1) = CGContextDelegateCreate();
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *(void *)&long long v2 = -1;
  *((void *)&v2 + 1) = -1;
  *(_OWORD *)((char *)this + 56) = v2;
  *(_OWORD *)((char *)this + 72) = v2;
  *(_OWORD *)((char *)this + 88) = v2;
  *(_OWORD *)((char *)this + 104) = v2;
  *(_OWORD *)((char *)this + 120) = v2;
  *(_OWORD *)((char *)this + 136) = v2;
  *(_OWORD *)((char *)this + 152) = v2;
  *(_OWORD *)((char *)this + 168) = v2;
  *(_OWORD *)((char *)this + 184) = v2;
  *(_OWORD *)((char *)this + 200) = v2;
  *(_OWORD *)((char *)this + 216) = v2;
  *(_OWORD *)((char *)this + 232) = v2;
  *(_OWORD *)((char *)this + 248) = v2;
  *(_OWORD *)((char *)this + 40) = v2;
  *(_OWORD *)((char *)this + 264) = v2;
  *(_OWORD *)((char *)this + 280) = v2;
  *((void *)this + 37) = 0;
  *((_DWORD *)this + 76) = -1;
  *((void *)this + 40) = 0;
  *((void *)this + 41) = 0;
  *((void *)this + 39) = 0;
  CGContextDelegateSetCallbacks();
  return this;
}

CGColorSpace *CA::CG::ContextDelegate::set_colorspace(CA::CG::ContextDelegate *this, CGColorSpace *a2)
{
  uint64_t result = (CGColorSpace *)*((void *)this + 4);
  if (result != a2)
  {
    CGColorSpaceRelease(result);
    CGColorSpaceRef v5 = CGColorSpaceRetain(a2);
    *(void *)&long long v6 = -1;
    *((void *)&v6 + 1) = -1;
    *(_OWORD *)((char *)this + 40) = v6;
    uint64_t v7 = (char *)this + 40;
    *((void *)v7 - 1) = v5;
    *((_OWORD *)v7 + 1) = v6;
    *((_OWORD *)v7 + 2) = v6;
    *((_OWORD *)v7 + 3) = v6;
    *((_OWORD *)v7 + 4) = v6;
    *((_OWORD *)v7 + 5) = v6;
    *((_OWORD *)v7 + 6) = v6;
    *((_OWORD *)v7 + 7) = v6;
    *((_OWORD *)v7 + 8) = v6;
    *((_OWORD *)v7 + 9) = v6;
    *((_OWORD *)v7 + 10) = v6;
    *((_OWORD *)v7 + 11) = v6;
    *((_OWORD *)v7 + 12) = v6;
    *((_OWORD *)v7 + 13) = v6;
    *((_OWORD *)v7 + 14) = v6;
    *((_OWORD *)v7 + 15) = v6;
    uint64_t result = (CGColorSpace *)*((void *)v7 + 32);
    if (result)
    {
      return (CGColorSpace *)CA::ColorProgram::Cache::set_colorspace((CGColorSpace **)result, a2);
    }
  }
  return result;
}

uint64_t CA::CG::AccelQueue::AccelQueue(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 168) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1ED029CF0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  atomic_fetch_add(CA::CG::Queue::_queue_count, 1u);
  if ((CA::CG::Queue::should_disable_async(void)::initialized & 1) == 0)
  {
    uint64_t v4 = getenv("CA_DISABLE_ASYNC");
    if (v4 && atoi(v4)) {
      CA::CG::Queue::_disable_async = 1;
    }
    CA::CG::Queue::should_disable_async(void)::initialized = 1;
  }
  if (CA::CG::Queue::Queue(void)::onceToken != -1) {
    dispatch_once(&CA::CG::Queue::Queue(void)::onceToken, &__block_literal_global_196);
  }
  pthread_mutex_init((pthread_mutex_t *)(a1 + 56), 0);
  pthread_cond_init((pthread_cond_t *)(a1 + 120), 0);
  *(void *)a1 = &unk_1ED027458;
  *(void *)(a1 + 176) = a2;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  if ((CA::CG::AccelQueue::AccelQueue(CA::CG::AccelDrawable &)::initialized & 1) == 0)
  {
    CGColorSpaceRef v5 = getenv("CA_NO_ACCEL");
    if (v5) {
      CA::CG::AccelQueue::AccelQueue(CA::CG::AccelDrawable &)::no_accel = atoi(v5) != 0;
    }
    CA::CG::AccelQueue::AccelQueue(CA::CG::AccelDrawable &)::initialized = 1;
  }
  int v6 = CA::CG::AccelQueue::AccelQueue(CA::CG::AccelDrawable &)::no_accel;
  *(unsigned char *)(a1 + 209) = CA::CG::AccelQueue::AccelQueue(CA::CG::AccelDrawable &)::no_accel ^ 1;
  if (!v6)
  {
    unsigned int v7 = *(_DWORD *)(a2 + 16);
    if (v7 > 0x23 || ((1 << v7) & 0xA0026660ALL) == 0) {
      *(unsigned char *)(a1 + 209) = 0;
    }
  }
  return a1;
}

void CA::CG::AccelQueue::set_label(CA::CG::AccelQueue *this, CFTypeRef cf)
{
  uint64_t v4 = (const void *)*((void *)this + 24);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 24) = cf;
  if (cf)
  {
    CFRetain(cf);
  }
}

void CA::CG::AccelQueue::release_renderer(CA::CG::AccelQueue *this, CA::CG::Renderer *a2)
{
  *((unsigned char *)a2 + 4228) = 0;
  *(_DWORD *)(*((void *)a2 + 1) + 352) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 1056);
  *((unsigned char *)this + 208) = 1;
}

uint64_t CA::CG::AccelQueue::acquire_renderer(CA::CG::AccelQueue *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const __CFString *a7)
{
  if (*((unsigned char *)this + 209)) {
    unsigned int v7 = (CA::CG::AccelRenderer **)*((void *)this + 25);
  }
  else {
    unsigned int v7 = 0;
  }
  return CA::CG::AccelRenderer::acquire(*((CA::CG::AccelRenderer **)this + 22), (CA::CG::AccelQueue *)((char *)this + 184), v7, *((unsigned int *)this + 6), 0, *((__CFString **)this + 24), a7);
}

uint64_t CA::WindowServer::IOMFBDisplay::finish_update(CA::WindowServer::IOMFBDisplay *this, CA::Render::Update *a2, unsigned int a3)
{
  uint64_t v484 = *MEMORY[0x1E4F143B8];
  int v6 = (void *)MEMORY[0x185324A30]();
  int v7 = byte_1EB2ACC43;
  unsigned int v8 = *((_DWORD *)a2 + 67);
  uint64_t v9 = *((void *)this + 3255);
  if (v9 && (*(unsigned char *)(v9 + 292) & 1) != 0) {
    CA::WindowServer::IOMFBDisplay::delete_detached_layer(this);
  }
  if (!(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 216))(this)
    || !*((void *)this + 80)
    || *((unsigned char *)this + 28162))
  {
    goto LABEL_16;
  }
  v447 = (char *)this + 26904;
  if ((a3 & 8) != 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
    uint64_t v10 = (_DWORD *)((char *)this + 48 * *((unsigned int *)this + 6426) + 25808);
    if (*v10)
    {
      IOMobileFramebufferSwapCancel();
      *uint64_t v10 = 0;
    }
    int v11 = (void (***)(void))*((void *)this + 3312);
    if (v11) {
      (**v11)(v11);
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 25720));
LABEL_16:
    uint64_t v12 = 0;
    goto LABEL_17;
  }
  BOOL v433 = *((unsigned char *)this + 28193)
      && (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 920))(this) == 0.0
      && *((double *)this + 3404) != 0.0;
  if (*((unsigned char *)this + 28161)) {
    *((unsigned char *)this + 28162) = 1;
  }
  if ((*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1544))(this)) {
    BOOL is_hdr = CA::WindowServer::Display::Mode::is_hdr((CA::WindowServer::IOMFBDisplay *)((char *)this + 640));
  }
  else {
    BOOL is_hdr = 0;
  }
  if ((*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 80))(this)) {
    BOOL v421 = *((unsigned char *)std::__hash_table<std::__hash_value_type<CA::WindowServer::Display::Mode,CA::WindowServer::IOMFBDisplay::ModeInfo>,std::__unordered_map_hasher<CA::WindowServer::Display::Mode,std::__hash_value_type<CA::WindowServer::Display::Mode,CA::WindowServer::IOMFBDisplay::ModeInfo>,CA::WindowServer::IOMFBDisplay::ModeHash,std::equal_to<CA::WindowServer::Display::Mode>,true>,std::__unordered_map_equal<CA::WindowServer::Display::Mode,std::__hash_value_type<CA::WindowServer::Display::Mode,CA::WindowServer::IOMFBDisplay::ModeInfo>,std::equal_to<CA::WindowServer::Display::Mode>,CA::WindowServer::IOMFBDisplay::ModeHash,true>,std::allocator<std::__hash_value_type<CA::WindowServer::Display::Mode,CA::WindowServer::IOMFBDisplay::ModeInfo>>>::__emplace_unique_key_args<CA::WindowServer::Display::Mode,std::piecewise_construct_t const&,std::tuple<CA::WindowServer::Display::Mode const&>,std::tuple<>>((float *)this + 6610, *((void *)this + 80), (uint64_t *)this + 80)+ 40) != 0;
  }
  else {
    BOOL v421 = 0;
  }
  unsigned int v416 = v8;
  unsigned int v445 = a3;
  uint64_t v437 = a2;
  long long v419 = *(_OWORD *)((char *)this + 152);
  uint64_t v431 = (pthread_mutex_t *)((char *)this + 25720);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
  if (*((_DWORD *)this + 6428))
  {
    unint64_t v14 = 0;
    int v15 = 0;
    int v16 = 0;
    uint64_t v17 = (char *)this + 25824;
    do
    {
      char v18 = *v17;
      if (!*((_DWORD *)v17 - 10)
        || !*((_DWORD *)v17 - 4)
        || !CA::IOMobileFramebuffer::swap_wait((CA::WindowServer::IOMFBDisplay *)((char *)this + 25568)))
      {
        ++v16;
      }
      v15 |= (v18 & 0x20) >> 5;
      ++v14;
      v17 += 48;
    }
    while (v14 < *((unsigned int *)this + 6428));
  }
  else
  {
    int v16 = 0;
    LOBYTE(v15) = 0;
  }
  v446 = (char *)this + 25704;
  uint64_t v19 = *((void *)this + 3255);
  if (v19) {
    BOOL v457 = (*(unsigned char *)(v19 + 292) & 1) == 0;
  }
  else {
    BOOL v457 = 0;
  }
  int v20 = byte_1EB2ACC85;
  double v21 = (*(double (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 760))(this);
  double v22 = *((double *)v437 + 9);
  if ((*((_DWORD *)this + 156) & 0x100) == 0) {
    goto LABEL_48;
  }
  if (CAPrefers60HzAPT(void)::once[0] != -1) {
    dispatch_once(CAPrefers60HzAPT(void)::once, &__block_literal_global_3);
  }
  if (CAPrefers60HzAPT(void)::enabled)
  {
    if (v457
      && (*(unsigned char *)(v19 + 292) & 4) != 0
      && (*(unsigned char *)(v19 + 37) & 8) != 0
      && (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 136))(this) == 2)
    {
      BOOL v23 = 0;
      goto LABEL_51;
    }
    BOOL v23 = *((_DWORD *)this + 6798) == 0;
  }
  else
  {
LABEL_48:
    BOOL v23 = 0;
  }
  if (!v457)
  {
LABEL_52:
    int v24 = 0;
    goto LABEL_54;
  }
LABEL_51:
  if ((*((_DWORD *)this + 156) & 0x10) == 0) {
    goto LABEL_52;
  }
  int v24 = (*(unsigned __int8 *)(v19 + 45) >> 5) & 1;
LABEL_54:
  uint64_t v448 = v19;
  int v417 = v24;
  if (*((double *)this + 3267) >= *((double *)v437 + 9))
  {
    int v32 = 1;
  }
  else
  {
    if (CADeviceNeedsTripleBufferedTTL::once[0] != -1)
    {
      int v377 = v24;
      dispatch_once(CADeviceNeedsTripleBufferedTTL::once, &__block_literal_global_360);
      int v24 = v377;
    }
    int v26 = CADeviceNeedsTripleBufferedTTL::wants_triple_buffered_ttl;
    if (initialized != -1)
    {
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
      int v24 = v417;
    }
    unsigned int v27 = *(float *)&dword_1EB2ACB84;
    if (v26) {
      _ZF = 1;
    }
    else {
      _ZF = v27 == 1;
    }
    BOOL v29 = !_ZF || v27 == 2;
    int v30 = !v29;
    BOOL v31 = v457;
    if (v29) {
      BOOL v31 = 0;
    }
    if (v31)
    {
      uint64_t v19 = v448;
      if ((*(unsigned char *)(v448 + 292) & 4) != 0) {
        int v32 = (*(unsigned __int8 *)(v448 + 37) >> 3) & 1;
      }
      else {
        int v32 = 0;
      }
    }
    else
    {
      int v32 = v30 ^ 1;
      uint64_t v19 = v448;
    }
  }
  BOOL v415 = v23;
  if (v16 == 1 || v20)
  {
    int v34 = !v457;
    if ((*((_DWORD *)v437 + 271) & 0x400) == 0) {
      int v34 = 1;
    }
    int v33 = v34 | v23 | v24;
  }
  else
  {
    int v33 = v23 | v24;
  }
  if (((v33 | v32) & 1) == 0) {
    int v33 = *((unsigned char *)this + 28185) != 0;
  }
  double v35 = v21 * 0.125;
  BOOL v454 = (v445 & 4 | v7) != 0;
  uint64_t v36 = (char *)this + 26904;
  if (*((unsigned char *)this + 28186)) {
    int v37 = 0;
  }
  else {
    int v37 = v33;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 6512);
  CA::WindowServer::IOMFBDisplay::initialize_timings(this);
  uint64_t v38 = *((void *)this + 3258);
  if (v38) {
    atomic_store(v37, (unsigned __int8 *)(v38 + 2));
  }
  double v39 = v22 - v35;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 6512);
  if (v37)
  {
    double v40 = (*(double (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 760))(this);
    double v39 = v39
        + v40
        * (double)(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 768))(this);
  }
  *((unsigned char *)this + 28188) = v37;
  if (v457)
  {
    if (*(void *)v19)
    {
      uint64_t v41 = CA::Render::Handle::lock_context(*(CA::Render::Handle **)v19);
      if (v41)
      {
        uint64_t v43 = v41;
        char v44 = *(atomic_uint **)(v41 + 384);
        if (v44)
        {
          if (atomic_fetch_add(v44 + 4, 0xFFFFFFFF) == 1) {
            CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v44, v42);
          }
          *(void *)(v43 + 384) = 0;
        }
        CA::Render::Handle::unlock_context((atomic_uint *)v43, v42);
      }
    }
  }
  double v45 = *((double *)v437 + 15) + 0.0001;
  if (v39 < v45) {
    double v39 = *((double *)v437 + 15) + 0.0001;
  }
  char v441 = v37;
  if (*((unsigned __int8 *)this + 28185) != v37)
  {
    uint64_t v376 = *((void *)this + 3192);
    if (v376)
    {
      if (v39 + -0.001 >= v45) {
        double v45 = v39 + -0.001;
      }
      *(void *)(v376 + 16) = CAHostTimeWithTime(v45);
    }
  }
  unsigned int v46 = *(_DWORD *)v446;
  int v418 = (_DWORD *)((char *)this + 48 * *(unsigned int *)v446 + 25784);
  int8x16_t v443 = (unsigned int *)((char *)this + 48 * *(unsigned int *)v446 + 25808);
  if (!*v443) {
    CA::IOMobileFramebuffer::swap_begin((CA::WindowServer::IOMFBDisplay *)((char *)this + 25568), v443);
  }
  int8x16_t v434 = (char *)this + 48 * v46 + 25824;
  *v434 &= ~0x20u;
  if (*((unsigned char *)this + 28192)) {
    double v47 = CACurrentMediaTimeDelta();
  }
  else {
    double v47 = 0.0;
  }
  *((double *)v437 + 98) = v47 + v39;
  *(_DWORD *)__int16 v470 = 1;
  *(void *)buf = CAHostTimeWithTime(v47 + v39);
  IOMobileFramebufferSwapSetTimestamps();
  unint64_t v48 = CAHostTimeWithTime(*((double *)this + 3315) + v47);
  *(_DWORD *)__int16 v470 = 2;
  *(void *)buf = v48;
  IOMobileFramebufferSwapSetTimestamps();
  double v49 = *((double *)v437 + 95);
  if (v49 != 0.0)
  {
    *(_DWORD *)__int16 v470 = 3;
    *(void *)buf = CAHostTimeWithTime(v49 + v47);
    IOMobileFramebufferSwapSetTimestamps();
  }
  int v50 = (char *)this + 25393;
  if (*((unsigned char *)this + 28149) || *((unsigned char *)this + 28136) != ((*((_DWORD *)this + 156) >> 2) & 1)) {
    IOMobileFramebufferSwapSetBackgroundColor();
  }
  *((unsigned char *)this + 28136) = (*((_DWORD *)this + 156) & 4) != 0;
  if (*((unsigned char *)this + 28201))
  {
    IOMobileFramebufferSwapSetColorRemapMode();
    *((unsigned char *)this + 28201) = 0;
  }
  if (*v50)
  {
    if (CADeviceNeedsIRDCFlush::once != -1) {
      dispatch_once(&CADeviceNeedsIRDCFlush::once, &__block_literal_global_390);
    }
    if (CADeviceNeedsIRDCFlush::b)
    {
      IOMobileFramebufferSwapSetParams();
      if (BYTE9(xmmword_1EB2ACC10)) {
        kdebug_trace();
      }
    }
    *int v50 = 0;
  }
  CA::WindowServer::IOMFBDisplay::update_blend_display_color_spaces(this);
  CA::WindowServer::IOMFBDisplay::update_system_gamma(this);
  CA::WindowServer::IOMFBDisplay::update_blackpoint_adaptation(this);
  CA::WindowServer::IOMFBDisplay::update_gamma_adjustment(this);
  v51.n128_f64[0] = CA::WindowServer::IOMFBDisplay::update_user_adjustment(this);
  if (((*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, __n128))(*(void *)this + 1544))(this, v51) & 1) == 0
    && *((unsigned char *)this + 28152)
    && CA::WindowServer::IOMFBDisplay::set_framebuffer_ax_matrix(this))
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      int v52 = x_log_category_windowserver;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_184668000, v52, OS_LOG_TYPE_ERROR, "IOMFB was not able to set accessibility matrix.\n", buf, 2u);
      }
    }
  }
  v444 = (CA::IOMobileFramebuffer **)((char *)this + 25568);
  v432 = (char *)this + 25393;
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (*(float *)&dword_1EB2ACAC8)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::flattened_lock);
    if (CA::Render::flattened_cache)
    {
      unsigned int v53 = v46;
      if (initialized != -1) {
        dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
      }
      uint64_t v54 = 0;
      *(_DWORD *)__int16 v470 = *(float *)&dword_1EB2ACAC8;
      uint64_t v55 = CA::Render::flattened_cache;
      *(void *)buf = &unk_1ED030EA8;
      *(void *)&uint8_t buf[8] = v470;
      v477.i64[1] = (uint64_t)buf;
      uint64_t v56 = 1 << *(_DWORD *)CA::Render::flattened_cache;
      do
      {
        for (uint64_t i = *(void **)(*(void *)(v55 + 16) + 8 * v54); i; uint64_t i = (void *)*i)
          X::HashTable<unsigned int,CA::Render::FlattenedCacheEntry *>::foreach(std::function<void ()(unsigned int,CA::Render::FlattenedCacheEntry *)>)::{lambda(void *,void *,void *)#1}::__invoke(i[2], i[3], (uint64_t)buf);
        ++v54;
      }
      while (v54 != v56);
      uint64_t v36 = (char *)this + 26904;
      unsigned int v46 = v53;
      if ((uint8_t *)v477.i64[1] == buf)
      {
        (*(void (**)(uint8_t *))(*(void *)buf + 32))(buf);
      }
      else
      {
        if (v477.i64[1]) {
          (*(void (**)(void))(*(void *)v477.i64[1] + 40))();
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
    if (*(float *)&dword_1EB2ACAC8 > 0.0) {
      *(float *)&dword_1EB2ACAC8 = *(float *)&dword_1EB2ACAC8 + -1.0;
    }
  }
  unsigned int v438 = v46;
  if (v25[186] != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  uint64_t v58 = (uint64_t)v437;
  BOOL v59 = is_hdr;
  if (*(float *)&dword_1EB2ACACC && *(float *)&dword_1EB2ACACC > 0.0) {
    *(float *)&dword_1EB2ACACC = *(float *)&dword_1EB2ACACC + -1.0;
  }
  char v60 = v454 | v15;
  if (v457)
  {
    if (!is_hdr && (v36[1233] || (v36[1245] != 0) | v60 & 1))
    {
      int v63 = (const CA::Rect *)*(unsigned int *)(v448 + 40);
      int v64 = (__IOSurface *)(*(uint64_t (**)(void))(**(void **)(v448 + 24) + 160))(*(void *)(v448 + 24));
      float64x2_t v65 = *(float64x2_t *)(v448 + 208);
      *(_OWORD *)buf = *(_OWORD *)(v448 + 192);
      int8x16_t v477 = (int8x16_t)v65;
      float64x2_t v66 = *(float64x2_t *)(v448 + 240);
      *(_OWORD *)__int16 v470 = *(_OWORD *)(v448 + 224);
      float64x2_t v471 = v66;
      if (initialized != -1) {
        dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
      }
      if (*(float *)&dword_1EB2ACAB4)
      {
        int v67 = CAIOSurfaceWriteToFileWithSuffix(v64, "detached-src");
        if (v67)
        {
          if (*(float *)&dword_1EB2ACAB4 > 0.0) {
            *(float *)&dword_1EB2ACAB4 = *(float *)&dword_1EB2ACAB4 + -1.0;
          }
          free(v67);
        }
      }
      CA::WindowServer::IOMFBDisplay::swap_set_layer(this, (CA::Render::Update *)*((unsigned __int8 *)this + 26425), *(CA::Render::Update **)(v448 + 24), (const Rect *)buf, (const Rect *)v470, v63, *v443, *((_DWORD *)v437 + 62), *(unsigned int *)v399, v399[4]);
      int v68 = *((_DWORD *)this + *((unsigned __int8 *)this + 26425) + 6802);
      IOSurfaceID ID = IOSurfaceGetID(v64);
      uint64_t v70 = *((unsigned __int8 *)this + 26425);
      if (v68 == ID)
      {
        uint64_t v61 = 0;
      }
      else
      {
        uint64_t v61 = CA::WindowServer::layer_value[v70 + 3];
        IOSurfaceID v71 = IOSurfaceGetID(v64);
        LODWORD(v70) = *((unsigned __int8 *)this + 26425);
        *((_DWORD *)this + *((unsigned __int8 *)this + 26425) + 6802) = v71;
      }
      memset(v475, 0, sizeof(v475));
      *(_OWORD *)int v473 = 0u;
      long long v474 = 0u;
      CA::WindowServer::IOMFBDisplay::swap_set_layer(this, (CA::Render::Update *)(2 * (v70 == 0)), 0, (const Rect *)v475, (const Rect *)v473, 0, *v443, *((_DWORD *)v437 + 62), *(unsigned int *)v401, v401[4]);
    }
    else
    {
      uint64_t v61 = 0;
    }
    uint64_t v72 = *(void *)(v448 + 24);
    *(_DWORD *)(v72 + 224) = *(_DWORD *)(v72 + 224) & 0xFFFF0000 | (unsigned __int16)(*(_DWORD *)(v72 + 224) + 1);
    *((void *)this + 6 * v438 + 3225) = v72;
    if ((*(unsigned char *)(v448 + 292) & 4) != 0) {
      *v434 |= 2u;
    }
    goto LABEL_170;
  }
  if (!v36[1233] && !((v36[1245] != 0) | v60 & 1))
  {
    uint64_t v61 = 0;
LABEL_170:
    uint64_t v62 = v443;
    goto LABEL_171;
  }
  *(_OWORD *)buf = 0u;
  int8x16_t v477 = 0u;
  *(_OWORD *)__int16 v470 = 0u;
  float64x2_t v471 = 0u;
  uint64_t v62 = v443;
  CA::WindowServer::IOMFBDisplay::swap_set_layer(this, (CA::Render::Update *)1, 0, (const Rect *)buf, (const Rect *)v470, 0, *v443, *((_DWORD *)v437 + 62), *(unsigned int *)v399, v399[4]);
  *(_OWORD *)buf = 0u;
  int8x16_t v477 = 0u;
  *(_OWORD *)__int16 v470 = 0u;
  float64x2_t v471 = 0u;
  CA::WindowServer::IOMFBDisplay::swap_set_layer(this, (CA::Render::Update *)2, 0, (const Rect *)buf, (const Rect *)v470, 0, *v443, *((_DWORD *)v437 + 62), v400, v403);
  uint64_t v61 = 0;
LABEL_171:
  uint64_t v73 = *((void *)this + 6 * v438 + 3224);
  *(_DWORD *)(v73 + 12) = *v62;
  if ((options_are_visual & 1) != 0 || !*(void *)(v73 + 32) || (*(unsigned char *)(v73 + 132) & 4) != 0)
  {
    __int16 v75 = (char *)this + 25704;
    goto LABEL_178;
  }
  unsigned int v74 = *((_DWORD *)v437 + 67);
  if ((v457 & (v74 >> 3)) == 1)
  {
    __int16 v75 = (char *)this + 25704;
    if ((*(unsigned char *)(v448 + 37) & 1) == 0) {
      goto LABEL_178;
    }
  }
  else
  {
    __int16 v75 = (char *)this + 25704;
    if ((v74 & 8) != 0) {
      goto LABEL_178;
    }
  }
  *(unsigned char *)(v73 + 132) |= 4u;
LABEL_178:
  int v76 = *(CA::Shape **)(v73 + 16);
  if (!v76)
  {
LABEL_184:
    *(void *)(v73 + 16) = 1;
    goto LABEL_185;
  }
  if (v76)
  {
    if (v76 == (CA::Shape *)1) {
      goto LABEL_185;
    }
    goto LABEL_183;
  }
  if (*((_DWORD *)v76 + 1) != 6)
  {
LABEL_183:
    CA::Shape::unref(v76);
    goto LABEL_184;
  }
LABEL_185:
  if ((*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1504))(this)) {
    CA::shape_union((CA::Shape **)(v73 + 16), *((CA::Shape ***)v437 + 3), v77);
  }
  char v80 = *(unsigned char *)(v73 + 132);
  *(unsigned char *)(v73 + 132) = v80 & 0xF7;
  if (!v448
    || (*(unsigned char *)(v448 + 292) & 1) != 0
    || (*((_DWORD *)v437 + 271) & 0x800000) == 0
    || (*((unsigned char *)v437 + 268) & 4) != 0)
  {
    uint64_t v81 = 0;
  }
  else
  {
    uint64_t v81 = *((void *)v437 + 4);
  }
  if (options_are_visual == 1) {
    uint64_t v81 = 0;
  }
  uint64_t v442 = v73;
  if (!is_hdr)
  {
    if ((*(void *)(v73 + 32) || *(void *)(v73 + 40)) && (v80 & 4) == 0)
    {
      if (!v81) {
        goto LABEL_196;
      }
      if (v81)
      {
        if (v81 != 1) {
          goto LABEL_196;
        }
      }
      else if (*(_DWORD *)(v81 + 4) != 6)
      {
        goto LABEL_196;
      }
    }
    double v101 = (CA::Render::Update *)*((unsigned __int8 *)this + 26424);
    *(_OWORD *)buf = 0u;
    int8x16_t v477 = 0u;
    *(_OWORD *)__int16 v470 = 0u;
    float64x2_t v471 = 0u;
    CA::WindowServer::IOMFBDisplay::swap_set_layer(this, v101, 0, (const Rect *)buf, (const Rect *)v470, 0, *v443, *((_DWORD *)v437 + 62), *(unsigned int *)v399, v399[4]);
    int v425 = 0;
LABEL_311:
    unsigned int v162 = v438;
    goto LABEL_312;
  }
LABEL_196:
  int v412 = (char *)this + 745;
  uint64_t v458 = v81;
  if ((v80 & 2) == 0 || (*v434 & 0x10) != 0)
  {
    int v425 = 0;
    goto LABEL_212;
  }
  *(unsigned char *)(v73 + 132) = v80 & 0xF5;
  uint64_t v82 = CA::WindowServer::IOMFBDisplay::current_page_surface(this, 1, 0, 0, 0, *((void *)v437 + 36));
  if (!v82)
  {
LABEL_203:
    int v87 = -536870212;
LABEL_204:
    uint64_t v88 = v36;
    uint64_t v89 = *((unsigned __int8 *)this + 26424);
    int v90 = v88[1250];
    if (*((void *)this + 3255) || v89 == 2)
    {
      BOOL v93 = v90 != 0;
      uint64_t v91 = v443;
      unsigned int v92 = v438;
    }
    else
    {
      uint64_t v91 = v443;
      unsigned int v92 = v438;
      if (!v90) {
        goto LABEL_263;
      }
      if ((*((_DWORD *)this + 14) & 0x10) != 0) {
        uint64_t v89 = *((unsigned __int8 *)this + 26424);
      }
      else {
        uint64_t v89 = 2;
      }
      BOOL v93 = 1;
    }
    if (v87 == -536870191 && v93)
    {
      if (v82)
      {
        long long v117 = (CA::Render::Update *)v82;
        if ((*(uint64_t (**)(void))(*(void *)v82 + 160))())
        {
          *(_OWORD *)buf = 0u;
          int8x16_t v477 = 0u;
          *(_OWORD *)__int16 v470 = 0u;
          float64x2_t v471 = 0u;
          CA::WindowServer::IOMFBDisplay::swap_set_layer(this, (CA::Render::Update *)v89, v117, (const Rect *)buf, (const Rect *)v470, 0, *v91, *((_DWORD *)v437 + 62), *(unsigned int *)v399, v399[4]);
        }
      }
      long long v118 = *(CA::WindowServer::Surface **)(v73 + 32);
      if (v118)
      {
        CA::WindowServer::Surface::unref(v118);
        *(void *)(v73 + 32) = 0;
      }
      long long v119 = (char *)this + 48 * v92;
      float64x2_t v120 = (CA::WindowServer::Surface *)*((void *)v119 + 3225);
      if (v120)
      {
        long long v121 = v119 + 25800;
        CA::WindowServer::Surface::unref(v120);
        *long long v121 = 0;
      }
      goto LABEL_264;
    }
LABEL_263:
    *(_OWORD *)buf = 0u;
    int8x16_t v477 = 0u;
    *(_OWORD *)__int16 v470 = 0u;
    float64x2_t v471 = 0u;
    CA::WindowServer::IOMFBDisplay::swap_set_layer(this, (CA::Render::Update *)v89, 0, (const Rect *)buf, (const Rect *)v470, 0, *v91, *((_DWORD *)v437 + 62), *(unsigned int *)v399, v399[4]);
LABEL_264:
    IOMobileFramebufferSwapCancel();
    *uint64_t v91 = 0;
    uint64_t v123 = *((void *)this + 3312);
    if (v123)
    {
      if (v87 == -536870184
        && (v445 & 1) != 0
        && *((unsigned char *)this + 28154)
        && (*(unsigned int (**)(void))(*(void *)v123 + 8))(*((void *)this + 3312)))
      {
        uint64_t v124 = (*(uint64_t (**)(uint64_t))(*(void *)v123 + 16))(v123);
        int v125 = *((_DWORD *)v437 + 62);
        *(void *)buf = v124;
        *(_DWORD *)&uint8_t buf[8] = v125;
        __n128 v122 = X::small_vector_base<std::pair<unsigned long,unsigned int>>::push_back((uint64_t)this + 28024, (__n128 *)buf);
      }
      (**(void (***)(uint64_t, __n128))v123)(v123, v122);
    }
    uint64_t v12 = v87 != -536870184;
    goto LABEL_558;
  }
  __int16 v83 = (CA::WindowServer::Surface *)v82;
  if (!v36[1250]) {
    goto LABEL_607;
  }
  int v84 = byte_1EB2ACC8D;
  uint64_t v85 = (*(uint64_t (**)(uint64_t))(*(void *)v82 + 216))(v82);
  uint64_t v86 = v85;
  if (v84)
  {
    uint64_t v378 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1400))(this);
    if ((v378 | v86) != v378) {
      goto LABEL_202;
    }
  }
  else if (v85)
  {
LABEL_202:
    uint64_t v82 = 0;
    goto LABEL_203;
  }
  if (!v36[1250])
  {
LABEL_607:
    uint64_t v82 = CA::WindowServer::IOMFBDisplay::current_page_surface(this, 0, 1, 0, is_hdr, *((void *)v437 + 36));
    int v425 = 0;
    if (v82) {
      int v87 = 0;
    }
    else {
      int v87 = -536870212;
    }
    goto LABEL_610;
  }
  v485.double width = (double)(int)((*((_DWORD *)this + 40) + 1) & 0xFFFFFFFE);
  v485.double height = (double)(int)((*((_DWORD *)this + 41) + 1) & 0xFFFFFFFE);
  *(void *)buf = 0;
  int wireless_surface_options = CA::IOMobileFramebuffer::get_wireless_surface_options(*v444, *((double *)v437 + 9), v485, (__IOSurface **)buf);
  if (wireless_surface_options)
  {
    int v87 = wireless_surface_options;
    int v425 = 0;
    uint64_t v82 = 0;
    goto LABEL_610;
  }
  uint64_t v82 = (uint64_t)CA::WindowServer::IOSurface::wrap_buffer(this, *(IOSurfaceRef *)buf, 0, 0);
  *(void *)(v73 + 32) = v82;
  if (!v82)
  {
    int v425 = 0;
    int v87 = -536870211;
    goto LABEL_610;
  }
  unint64_t v396 = *((void *)v437 + 38);
  unint64_t v397 = *((void *)this + 3423);
  if (v396 == -1 || v396 <= v397)
  {
    if (!v397)
    {
      int v87 = 0;
      int v425 = 1;
      goto LABEL_610;
    }
  }
  else
  {
    *((void *)this + 3423) = v396;
  }
  uint64_t v398 = v82;
  if ((*(uint64_t (**)(void))(*(void *)v82 + 160))())
  {
    (*(void (**)(void))(**(void **)(v73 + 32) + 160))(*(void *)(v73 + 32));
    IOSurfaceSetIndexedTimestamp();
  }
  int v87 = 0;
  int v425 = 1;
  uint64_t v82 = v398;
LABEL_610:
  if (v87) {
    char v380 = 1;
  }
  else {
    char v380 = is_hdr;
  }
  if ((v380 & 1) == 0)
  {
    int v381 = (CA::WindowServer::Surface *)v82;
    int64x2_t v382 = (void (***)(void))*((void *)this + 3312);
    if (v382) {
      (**v382)(v382);
    }
    if ((*v412 & 0x10) != 0) {
      uint64_t v383 = 1536;
    }
    else {
      uint64_t v383 = 1024;
    }
    if (v36[1250])
    {
      BOOL v384 = CA::WindowServer::Display::Mode::is_hdr((CA::WindowServer::IOMFBDisplay *)((char *)this + 640));
      if (!CA::WindowServer::Display::has_hdr_clone(this))
      {
        if (v384)
        {
          BOOL v384 = 1;
LABEL_633:
          long long v482 = 0u;
          long long v483 = 0u;
          long long v480 = 0u;
          long long v481 = 0u;
          long long v478 = 0u;
          long long v479 = 0u;
          *(_OWORD *)buf = 0u;
          int8x16_t v477 = 0u;
          CA::WindowServer::Display::display_attributes((CA::WindowServer::Display *)buf, (uint64_t *)this);
          if ((*((_DWORD *)v437 + 67) & 0x38000) != 0
            || v384 && (*(unsigned int (**)(CA::WindowServer::Surface *))(*(void *)v83 + 128))(v83))
          {
            uint64_t v393 = (*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)v381 + 216))(v381);
            char v394 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, CA::WindowServer::Surface *, CA::WindowServer::Surface *, uint8_t *, CA::Render::Update *, uint64_t, uint64_t, uint64_t))(*(void *)this + 640))(this, v381, v83, buf, v437, v383, v393, 1);
          }
          else
          {
            char v394 = CA::WindowServer::IOMFBDisplay::copy_surface(this, v381, v83, v383, 0, 0, 0, 0, v392);
          }
          char v395 = *v434 & 0xFE | v394;
          *int8x16_t v434 = v395;
          __int16 v75 = (char *)this + 25704;
          uint64_t v73 = v442;
          goto LABEL_645;
        }
LABEL_629:
        int32x4_t v386 = 0uLL;
        *(_OWORD *)buf = 0u;
        int8x16_t v477 = 0u;
        uint64_t v73 = v442;
        if (v421)
        {
          int v387 = DWORD2(v419);
          if (SDWORD2(v419) <= SHIDWORD(v419)) {
            int v387 = HIDWORD(v419);
          }
          v386.i32[0] = 1073741822;
          v385.i32[0] = v387;
          v388.i64[0] = (int)v419;
          v388.i64[1] = SDWORD1(v419);
          int32x4_t v386 = (int32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v385, v386), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v388));
          v388.i64[0] = SDWORD2(v419);
          v388.i64[1] = SHIDWORD(v419);
          int32x2_t v389 = vdup_n_s32(v387 > 1073741822);
          int8x16_t v390 = (int8x16_t)vcvtq_f64_s64(v388);
          v388.i64[0] = v389.u32[0];
          v388.i64[1] = v389.u32[1];
          *(int32x4_t *)buf = v386;
          int8x16_t v477 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v388, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v390);
          uint64_t v383 = v383 | 0x10000;
          double v391 = buf;
        }
        else
        {
          double v391 = 0;
        }
        char v395 = *v434 & 0xFE | CA::WindowServer::IOMFBDisplay::copy_surface(this, v381, v83, v383, 0, (CA::Rect *)v391, 0, 0, *(float *)v386.i32);
        *int8x16_t v434 = v395;
        __int16 v75 = (char *)this + 25704;
LABEL_645:
        BOOL v59 = is_hdr;
        if ((v395 & 1) == 0)
        {
          uint64_t v82 = (uint64_t)v381;
          int v87 = -536870191;
          goto LABEL_204;
        }
        goto LABEL_212;
      }
    }
    else
    {
      if (!CA::WindowServer::Display::has_hdr_clone(this)) {
        goto LABEL_629;
      }
      BOOL v384 = 0;
    }
    if ((*((_DWORD *)v437 + 103) - 2) < 4 || v384) {
      goto LABEL_633;
    }
    goto LABEL_629;
  }
  __int16 v75 = (char *)this + 25704;
  if (v87) {
    goto LABEL_204;
  }
LABEL_212:
  if (v445 & 1) != 0 && (*(unsigned char *)(v73 + 132)) {
    *v434 |= 1u;
  }
  __int16 v94 = *(CA::Render::Update **)(v73 + 32);
  if (v59)
  {
    uint64_t v95 = *((void *)v437 + 2);
    memset(buf, 0, sizeof(buf));
    CA::Shape::get_bounds(v95, (int *)buf);
    int v96 = *(_DWORD *)&buf[8];
    if (*(int *)&buf[8] >= *(int *)&buf[12]) {
      int v96 = *(_DWORD *)&buf[12];
    }
    if (v96 > 0 || v36[1233])
    {
      int v97 = *(CA::WindowServer::Surface **)(v73 + 40);
      if (v448) {
        uint64_t v98 = *(void *)(v448 + 24);
      }
      else {
        uint64_t v98 = 0;
      }
      uint64_t v410 = v98;
      if (((v98 != 0) & (*(unsigned __int8 *)(v73 + 132) >> 2)) != 0) {
        int v99 = 0;
      }
      else {
        int v99 = *(CA::WindowServer::Surface **)(v73 + 40);
      }
      if (v458)
      {
        if (v458)
        {
          if (v458 == 1) {
            goto LABEL_236;
          }
        }
        else if (*(_DWORD *)(v458 + 4) == 6)
        {
LABEL_236:
          __int16 v94 = (CA::Render::Update *)CA::WindowServer::IOMFBDisplay::current_page_surface(this, 0, 1, 0, 1, *((void *)v437 + 36));
          goto LABEL_245;
        }
      }
      float64x2_t v426 = v97;
      uint64_t v102 = CA::WindowServer::IOMFBDisplay::current_page_surface(this, 0, 1, 0, 1, *((void *)v437 + 36));
      __int16 v94 = (CA::Render::Update *)v102;
      if (v99)
      {
        uint64_t v104 = *(unsigned int *)(v102 + 56);
        uint64_t v103 = *(unsigned int *)(v102 + 60);
        if (__PAIR64__(v103, v104) == *((void *)v99 + 7))
        {
          int v105 = 0;
          __int16 v75 = (char *)this + 25704;
          uint64_t v73 = v442;
          long long v106 = v426;
          goto LABEL_278;
        }
        if ((*(_DWORD *)v412 & 0x10) != 0) {
          uint64_t v107 = 4608;
        }
        else {
          uint64_t v107 = 4096;
        }
        unsigned int v407 = *((_DWORD *)v99 + 16);
        unsigned int v406 = (*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)v99 + 24))(v99);
        unsigned int v405 = (*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)v99 + 56))(v99);
        uint64_t v108 = (*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)v99 + 216))(v99);
        surface = (CA::WindowServer::Surface *)CA::WindowServer::Display::allocate_surface((uint64_t)this, v104, v103, (CA::Render *)v407, v406, v405, 0, v108, @"CA Backward DM", 0);
        int32x4_t v111 = 0uLL;
        *(_OWORD *)buf = 0u;
        int8x16_t v477 = 0u;
        if (v421)
        {
          int v112 = DWORD2(v419);
          if (SDWORD2(v419) <= SHIDWORD(v419)) {
            int v112 = HIDWORD(v419);
          }
          v111.i32[0] = 1073741822;
          v110.i32[0] = v112;
          v113.i64[0] = (int)v419;
          v113.i64[1] = SDWORD1(v419);
          int32x4_t v111 = (int32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v110, v111), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v113));
          v113.i64[0] = SDWORD2(v419);
          v113.i64[1] = SHIDWORD(v419);
          int32x2_t v114 = vdup_n_s32(v112 > 1073741822);
          int8x16_t v115 = (int8x16_t)vcvtq_f64_s64(v113);
          v113.i64[0] = v114.u32[0];
          v113.i64[1] = v114.u32[1];
          *(int32x4_t *)buf = v111;
          int8x16_t v477 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v113, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v115);
          uint64_t v107 = v107 | 0x10000;
          long long v116 = buf;
        }
        else
        {
          long long v116 = 0;
        }
        uint64_t v126 = (float (***)(void))*((void *)this + 3312);
        if (v126) {
          *(float *)v111.i32 = (**v126)(v126);
        }
        int v105 = CA::WindowServer::IOMFBDisplay::copy_surface(this, surface, v99, v107, 0, (CA::Rect *)v116, 0, 0, *(float *)v111.i32);
        if ((v105 & 1) == 0)
        {
          int v409 = v105;
          __int16 v75 = (char *)this + 25704;
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            float64x2_t v375 = x_log_category_windowserver;
            if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int16 v470 = 0;
              _os_log_impl(&dword_184668000, v375, OS_LOG_TYPE_DEFAULT, "Failed to copy surface prior to backwardDM\n", v470, 2u);
            }
          }
          if (surface) {
            CA::WindowServer::Surface::unref(surface);
          }
          uint64_t v73 = v442;
          long long v106 = v426;
          int v105 = v409;
LABEL_278:
          int v127 = (void *)*((void *)this + 39);
          if (!v127)
          {
LABEL_299:
            if (v106) {
              int v151 = v105;
            }
            else {
              int v151 = 0;
            }
            if (v151 == 1) {
              CA::WindowServer::Surface::unref(v106);
            }
            goto LABEL_304;
          }
          int v408 = v105;
          uint64_t v467 = 0;
          HIWORD(v467) = COERCE_UNSIGNED_INT(1.0);
          if (v448)
          {
            long long v128 = *(_OWORD *)(v448 + 192);
            float64x2_t v129 = *(float64x2_t *)(v448 + 208);
            float64x2_t v130 = *(float64x2_t *)(v448 + 224);
            float64x2_t v131 = *(float64x2_t *)(v448 + 240);
          }
          else
          {
            long long v128 = 0uLL;
            float64x2_t v129 = 0uLL;
            float64x2_t v130 = 0uLL;
            float64x2_t v131 = 0uLL;
          }
          *(_OWORD *)__int16 v470 = v128;
          float64x2_t v471 = v129;
          v475[0] = v130;
          v475[1] = v131;
          if (v106)
          {
            unsigned int v133 = *((_DWORD *)v106 + 14);
            unsigned int v132 = *((_DWORD *)v106 + 15);
            memset(v473, 0, sizeof(v473));
            *(double *)&long long v474 = (double)v133;
            *((double *)&v474 + 1) = (double)v132;
            unsigned int v135 = *((_DWORD *)v94 + 14);
            unsigned int v134 = *((_DWORD *)v94 + 15);
            long long v468 = 0uLL;
            *(double *)&long long v469 = (double)v135;
            *((double *)&v469 + 1) = (double)v134;
            if (v458)
            {
              if ((v458 & 1) == 0)
              {
                if (*(_DWORD *)(v458 + 4) == 6) {
                  goto LABEL_296;
                }
LABEL_291:
                if (v133 == v135 && v132 == v134)
                {
                  memset(buf, 0, sizeof(buf));
                  int8x16_t v136 = v106;
                  CA::Shape::get_bounds(v458, (int *)buf);
                  v138.i32[1] = *(_DWORD *)&buf[12];
                  v139.i64[0] = *(int *)buf;
                  v139.i64[1] = *(int *)&buf[4];
                  int8x16_t v140 = (int8x16_t)vcvtq_f64_s64(v139);
                  int v141 = *(_DWORD *)&buf[12];
                  v139.i64[0] = *(int *)&buf[8];
                  v139.i64[1] = *(int *)&buf[12];
                  int64x2_t v142 = v139;
                  if (*(int *)&buf[8] > *(int *)&buf[12]) {
                    int v141 = *(_DWORD *)&buf[8];
                  }
                  v138.i32[0] = v141;
                  v137.i32[0] = 1073741822;
                  float64x2_t v427 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v138, v137), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v140);
                  int32x2_t v143 = vdup_n_s32(v141 > 1073741822);
                  v144.i64[0] = v143.u32[0];
                  v144.i64[1] = v143.u32[1];
                  float64x2_t v449 = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v144, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), (int8x16_t)vcvtq_f64_s64(v142));
                  CA::BoundsImpl::intersect((uint64_t)v473, v427, v449);
                  CA::BoundsImpl::intersect((uint64_t)&v468, v427, v449);
                  long long v106 = v136;
                }
                goto LABEL_296;
              }
              if (v458 != 1) {
                goto LABEL_291;
              }
            }
          }
          else
          {
            *(_OWORD *)int v473 = 0u;
            long long v474 = 0u;
            long long v468 = 0u;
            long long v469 = 0u;
          }
LABEL_296:
          uint64_t v428 = v61;
          long long v478 = 0u;
          long long v479 = 0u;
          *(_OWORD *)buf = 0u;
          int8x16_t v477 = 0u;
          if (!v36[68])
          {
            float64x2_t v145 = *((float64x2_t *)v36 + 1);
            long long v146 = *((_OWORD *)v36 + 2);
            long long v147 = *((_OWORD *)v36 + 3);
            *(_OWORD *)buf = *(_OWORD *)v36;
            int8x16_t v477 = (int8x16_t)v145;
            long long v478 = v146;
            long long v479 = v147;
            size_t v148 = v106;
            CA::Mat4Impl::mat4_scale((CA::Mat4Impl *)buf, v100, *((float *)v36 + 16), *((float *)v36 + 16), *((float *)v36 + 16));
            long long v106 = v148;
            v36[68] = 1;
          }
          int v149 = v106;
          (*(void (**)(void, CA::Render::Update *, uint64_t, uint8_t *, float64x2_t *, CA::WindowServer::Surface *, uint8_t *, long long *))(*(void *)*v127 + 976))(*v127, v94, v410, v470, v475, v106, v473, &v468);
          unint64_t v150 = (*((unsigned int *)v94 + 56) | ((unint64_t)*((unsigned __int8 *)v94 + 228) << 32)) & 0xFFFFFFFDFFFFFFFFLL;
          *((_DWORD *)v94 + 56) = *((_DWORD *)v94 + 56);
          *((unsigned char *)v94 + 228) = BYTE4(v150);
          v445 |= 3u;
          *((unsigned char *)this + 26424) = 0;
          long long v465 = 0u;
          long long v466 = 0u;
          long long v463 = 0u;
          long long v464 = 0u;
          CA::WindowServer::IOMFBDisplay::swap_set_layer(this, (CA::Render::Update *)1, 0, (const Rect *)&v465, (const Rect *)&v463, 0, *v443, *((_DWORD *)v437 + 62), &v467, (unint64_t)&v467 >> 32);
          long long v465 = 0u;
          long long v466 = 0u;
          long long v463 = 0u;
          long long v464 = 0u;
          CA::WindowServer::IOMFBDisplay::swap_set_layer(this, (CA::Render::Update *)2, 0, (const Rect *)&v465, (const Rect *)&v463, 0, *v443, *((_DWORD *)v437 + 62), v402, v404);
          long long v106 = v149;
          uint64_t v61 = v428;
          int v105 = v408;
          goto LABEL_299;
        }
        long long v106 = surface;
        __int16 v75 = (char *)this + 25704;
LABEL_277:
        uint64_t v73 = v442;
        goto LABEL_278;
      }
LABEL_245:
      long long v106 = 0;
      int v105 = 0;
      goto LABEL_277;
    }
  }
LABEL_304:
  if (!v94) {
    goto LABEL_311;
  }
  memset(v470, 0, sizeof(v470));
  uint64_t v152 = *((void *)v94 + 7);
  v153.i64[0] = v152;
  v153.i64[1] = HIDWORD(v152);
  float64x2_t v154 = vcvtq_f64_u64(v153);
  int v155 = DWORD2(v419);
  float64x2_t v471 = v154;
  if (SDWORD2(v419) <= SHIDWORD(v419)) {
    int v155 = HIDWORD(v419);
  }
  v78.i32[0] = 1073741822;
  v79.i32[0] = v155;
  v156.i64[0] = (int)v419;
  v156.i64[1] = SDWORD1(v419);
  int8x16_t v157 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v79, v78), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v156));
  v156.i64[0] = SDWORD2(v419);
  v156.i64[1] = SHIDWORD(v419);
  int8x16_t v158 = (int8x16_t)vcvtq_f64_s64(v156);
  int32x2_t v159 = vdup_n_s32(v155 > 1073741822);
  v156.i64[0] = v159.u32[0];
  v156.i64[1] = v159.u32[1];
  v475[0] = (float64x2_t)v157;
  v475[1] = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v156, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v158);
  if (v421)
  {
    v475[0] = 0uLL;
    v475[1] = v154;
  }
  double v160 = (const CA::Rect *)(32 * v36[1258]);
  if ((*((_DWORD *)v94 + 56) & 0x40000000) != 0) {
    uint64_t v161 = (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1552))(this) ^ 1;
  }
  else {
    uint64_t v161 = 1;
  }
  unsigned int v162 = v438;
  (*(void (**)(CA::Render::Update *, uint64_t))(*(void *)v94 + 120))(v94, v161);
  if ((*((_DWORD *)v437 + 271) & 0x2000000) == 0) {
    goto LABEL_424;
  }
  uint64_t v176 = *((void *)v437 + 7);
  if (!v176) {
    goto LABEL_424;
  }
  if ((v176 & 1) == 0)
  {
    if (*(_DWORD *)(v176 + 4) == 6) {
      goto LABEL_424;
    }
LABEL_412:
    double v245 = v471.f64[0] / v475[1].f64[0];
    memset(buf, 0, sizeof(buf));
    double v246 = v471.f64[1] / v475[1].f64[1];
    CA::Shape::get_bounds(v176, (int *)buf);
    v248.i32[1] = *(_DWORD *)&buf[12];
    int v249 = *(_DWORD *)&buf[12];
    v250.i64[0] = *(int *)buf;
    v250.i64[1] = *(int *)&buf[4];
    int64x2_t v251 = v250;
    v250.i64[0] = *(int *)&buf[8];
    v250.i64[1] = *(int *)&buf[12];
    int64x2_t v252 = v250;
    if (*(int *)&buf[8] > *(int *)&buf[12]) {
      int v249 = *(_DWORD *)&buf[8];
    }
    v248.i32[0] = v249;
    v247.i32[0] = 1073741822;
    int8x16_t v253 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v248, v247), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v251));
    int8x16_t v254 = (int8x16_t)vcvtq_f64_s64(v252);
    int32x2_t v255 = vdup_n_s32(v249 > 1073741822);
    v256.i64[0] = v255.u32[0];
    v256.i64[1] = v255.u32[1];
    int8x16_t v257 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v256, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v254);
    v475[0] = (float64x2_t)v253;
    v475[1] = (float64x2_t)v257;
    BOOL v258 = *(double *)v257.i64 >= 1.79769313e308 || v245 == 1.0;
    v259.i64[1] = v253.i64[1];
    v260.i64[1] = v257.i64[1];
    if (v258) {
      unint64_t v261 = 0;
    }
    else {
      unint64_t v261 = -1;
    }
    int8x16_t v262 = (int8x16_t)vdupq_n_s64(v261);
    *(double *)v260.i64 = v245 * *(double *)v257.i64;
    int8x16_t v263 = vbslq_s8(v262, v260, v257);
    *(double *)v259.i64 = v245 * *(double *)v253.i64;
    float64x2_t v264 = (float64x2_t)vbslq_s8(v262, v259, v253);
    if (v246 != 1.0 && *(double *)&v263.i64[1] < 1.79769313e308)
    {
      v264.f64[1] = vmuld_lane_f64(v246, v264, 1);
      *(double *)&v263.i64[1] = *(double *)&v263.i64[1] * v246;
    }
    *(float64x2_t *)__int16 v470 = v264;
    float64x2_t v471 = (float64x2_t)v263;
    goto LABEL_424;
  }
  if (v176 != 1) {
    goto LABEL_412;
  }
LABEL_424:
  CA::WindowServer::IOMFBDisplay::swap_set_layer(this, (CA::Render::Update *)*((unsigned __int8 *)this + 26424), v94, (const Rect *)v470, (const Rect *)v475, v160, *v443, *((_DWORD *)v437 + 62), *(unsigned int *)v399, v399[4]);
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  uint64_t v73 = v442;
  uint64_t v430 = v61;
  if (*(float *)&dword_1EB2ACAB8)
  {
    float v265 = (__IOSurface *)(*(uint64_t (**)(CA::Render::Update *))(*(void *)v94 + 160))(v94);
    CA::WindowServer::IOMFBDisplay::dump_framebuffer(this, v265);
  }
  int v266 = *((_DWORD *)this + *((unsigned __int8 *)this + 26424) + 6802);
  double v267 = (__IOSurface *)(*(uint64_t (**)(CA::Render::Update *))(*(void *)v94 + 160))(v94);
  if (v266 != IOSurfaceGetID(v267))
  {
    uint64_t v430 = CA::WindowServer::layer_value[*((unsigned __int8 *)this + 26424)] | v61;
    float v268 = (__IOSurface *)(*(uint64_t (**)(CA::Render::Update *))(*(void *)v94 + 160))(v94);
    *((_DWORD *)this + *((unsigned __int8 *)this + 26424) + 6802) = IOSurfaceGetID(v268);
  }
  BOOL v269 = is_hdr;
  float v270 = (CA::Shape *)v458;
  if ((*v412 & 4) != 0)
  {
    uint64_t v275 = *((void *)this + 19);
    uint64_t v274 = *((void *)this + 20);
    v276.i64[0] = (int)v274;
    v276.i64[1] = SHIDWORD(v274);
    float64x2_t v277 = vcvtq_f64_s64(v276);
    uint64_t v279 = *((void *)this + 25);
    uint64_t v278 = *((void *)this + 26);
    v276.i64[0] = (int)v278;
    v276.i64[1] = SHIDWORD(v278);
    float64x2_t v272 = vdivq_f64(v277, vcvtq_f64_s64(v276));
    v276.i64[0] = (int)v275;
    v276.i64[1] = SHIDWORD(v275);
    float64x2_t v280 = vcvtq_f64_s64(v276);
    v276.i64[0] = (int)v279;
    v276.i64[1] = SHIDWORD(v279);
    float64x2_t v271 = vmlsq_f64(v280, vcvtq_f64_s64(v276), v272);
    double v273 = v272.f64[1];
  }
  else
  {
    float64x2_t v271 = 0uLL;
    v272.f64[0] = 1.0;
    double v273 = 1.0;
  }
  uint64_t v61 = v430;
  uint64_t v281 = *((void *)v437 + 3);
  if (v281)
  {
    double v422 = v272.f64[0];
    float64x2_t v451 = v271;
    memset(v473, 0, sizeof(v473));
    CA::Shape::get_bounds(v281, (int *)v473);
    if (*(int *)&v473[8] <= *(int *)&v473[12]) {
      int v284 = *(_DWORD *)&v473[12];
    }
    else {
      int v284 = *(_DWORD *)&v473[8];
    }
    v282.i32[0] = 1073741822;
    v283.i32[0] = v284;
    v285.i64[0] = *(int *)v473;
    v285.i64[1] = *(int *)&v473[4];
    int8x16_t v286 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v283, v282), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v285));
    double v287 = (double)*(int *)&v473[12];
    if (v284 <= 1073741822) {
      double v288 = (double)*(int *)&v473[8];
    }
    else {
      double v288 = 1.79769313e308;
    }
    if (v284 > 1073741822) {
      double v287 = 1.79769313e308;
    }
    *(int8x16_t *)buf = v286;
    *(double *)v477.i64 = v288;
    *(double *)&v477.i64[1] = v287;
    if (!v36[1275])
    {
      if (v422 != 1.0 && v288 < 1.79769313e308)
      {
        *(double *)buf = *(double *)v286.i64 * v422;
        *(double *)v477.i64 = v288 * v422;
      }
      if (v273 != 1.0 && v287 < 1.79769313e308)
      {
        *(double *)&uint8_t buf[8] = *(double *)&v286.i64[1] * v273;
        *(double *)&v477.i64[1] = v287 * v273;
      }
      float64x2_t v289 = vaddq_f64(*(float64x2_t *)buf, v451);
      *(float64x2_t *)buf = v289;
      double v290 = *(double *)&v477.i64[1];
      if (*(double *)v477.i64 <= *(double *)&v477.i64[1]) {
        double v291 = *(double *)&v477.i64[1];
      }
      else {
        double v291 = *(double *)v477.i64;
      }
      if (v291 < 1.79769313e308)
      {
        if (*(double *)v477.i64 < *(double *)&v477.i64[1]) {
          double v290 = *(double *)v477.i64;
        }
        if (v290 > 0.0)
        {
          *(float64x2_t *)buf = vrndmq_f64(v289);
          int8x16_t v477 = (int8x16_t)vsubq_f64(vrndpq_f64(vaddq_f64(v289, (float64x2_t)v477)), *(float64x2_t *)buf);
        }
      }
      CA::BoundsImpl::intersect((uint64_t)buf, v475[0], v475[1]);
      double v287 = *(double *)&v477.i64[1];
      double v288 = *(double *)v477.i64;
    }
    if (v288 >= v287) {
      double v292 = v287;
    }
    else {
      double v292 = v288;
    }
    if (v292 > 0.0)
    {
      int v293 = IOMobileFramebufferSwapDirtyRegion();
      if (v293)
      {
        int v294 = v293;
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          v344 = x_log_category_windowserver;
          if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int v473 = 67109120;
            *(_DWORD *)&v473[4] = v294;
            _os_log_impl(&dword_184668000, v344, OS_LOG_TYPE_ERROR, "CADisplayIOMFB: swap_dirty_region returned error %x\n", v473, 8u);
          }
        }
      }
    }
    uint64_t v73 = v442;
    BOOL v269 = is_hdr;
    float v270 = (CA::Shape *)v458;
  }
  if (v270)
  {
    BOOL v345 = (v270 & 1) != 0 ? v270 == (CA::Shape *)1 : *((_DWORD *)v270 + 1) == 6;
    BOOL v346 = v345;
    if (!v346 && !v269)
    {
      long long v478 = 0u;
      long long v479 = 0u;
      *(_OWORD *)buf = 0u;
      int8x16_t v477 = 0u;
      if (CA::Shape::rect_count(v270) >= 32) {
        unint64_t v347 = 1;
      }
      else {
        unint64_t v347 = 4;
      }
      unint64_t v348 = CA::Shape::coalesce(v270, (int8x16_t *)buf, v347);
      if (v348)
      {
        unint64_t v349 = v348;
        int64x2_t v350 = vclezq_f64(v471);
        int32x4_t v351 = (int32x4_t)vdupq_laneq_s64(v350, 1);
        int64x2_t v352 = (int64x2_t)vorrq_s8((int8x16_t)v351, (int8x16_t)v350);
        uint64_t v353 = v352.i64[0];
        float64x2_t v354 = vaddq_f64(*(float64x2_t *)v470, v471);
        float64x2_t v420 = v354;
        float64x2_t v424 = *(float64x2_t *)v470;
        v355 = &buf[8];
        LODWORD(v354.f64[0]) = 1073741822;
        *(float64x2_t *)uint64_t v462 = v354;
        int8x16_t v453 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
        int64x2_t v356 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
        *(int64x2_t *)int32x4_t v436 = v356;
        v356.i64[0] = -1;
        int64x2_t v414 = v356;
        do
        {
          v352.i64[0] = 0;
          uint64_t v357 = *((void *)v355 - 1);
          v351.i64[0] = *(void *)v355;
          v358.i64[0] = (int)v357;
          v358.i64[1] = SHIDWORD(v357);
          int8x16_t v359 = (int8x16_t)vcvtq_f64_s64(v358);
          __int32 v360 = HIDWORD(*(void *)v355);
          v358.i64[0] = (int)*(void *)v355;
          v358.i64[1] = v360;
          int64x2_t v361 = v358;
          if (v358.i32[0] > v360) {
            __int32 v360 = *(void *)v355;
          }
          v351.i32[0] = v360;
          float64x2_t v362 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v351, *(int32x4_t *)v462), 0), v453, v359);
          int32x2_t v363 = vdup_n_s32(v360 > 1073741822);
          v364.i64[0] = v363.u32[0];
          v364.i64[1] = v363.u32[1];
          int8x16_t v365 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v364, 0x3FuLL)), *(int8x16_t *)v436, (int8x16_t)vcvtq_f64_s64(v361));
          int64x2_t v366 = vclezq_f64((float64x2_t)v365);
          int64x2_t v367 = (int64x2_t)vorrq_s8((int8x16_t)vdupq_laneq_s64(v366, 1), (int8x16_t)v366);
          uint64_t v368 = v367.i64[0];
          int64x2_t v352 = vdupq_lane_s64(vcgtq_s64(v352, v367).i64[0], 0);
          int32x4_t v351 = (int32x4_t)vandq_s8(v365, (int8x16_t)v352);
          if ((v368 & 0x8000000000000000) == 0 && (v353 & 0x8000000000000000) == 0)
          {
            int64x2_t v352 = (int64x2_t)vmaxnmq_f64(v362, v424);
            int8x16_t v369 = (int8x16_t)vsubq_f64(vminnmq_f64(vaddq_f64(v362, (float64x2_t)v365), v420), (float64x2_t)v352);
            int64x2_t v370 = vclezq_f64((float64x2_t)v369);
            int32x4_t v351 = (int32x4_t)vandq_s8(v369, (int8x16_t)vdupq_lane_s64(vcgtq_s64((int64x2_t)vorrq_s8((int8x16_t)vdupq_laneq_s64(v370, 1), (int8x16_t)v370), v414).i64[0], 0));
          }
          if (*(double *)v351.i64 >= *(double *)&v351.i64[1]) {
            double v371 = *(double *)&v351.i64[1];
          }
          else {
            double v371 = *(double *)v351.i64;
          }
          if (v371 > 0.0)
          {
            if (BYTE9(xmmword_1EB2ACC10)) {
              kdebug_trace();
            }
            int active = IOMobileFramebufferSwapActiveRegion();
            if (active)
            {
              int v373 = active;
              if (x_log_hook_p())
              {
                x_log_();
              }
              else
              {
                float64x2_t v374 = x_log_category_windowserver;
                if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)int v473 = 67109120;
                  *(_DWORD *)&v473[4] = v373;
                  _os_log_impl(&dword_184668000, v374, OS_LOG_TYPE_ERROR, "CADisplayIOMFB: swap_active_region returned error %x\n", v473, 8u);
                }
              }
            }
          }
          v355 += 16;
          --v349;
          __int16 v75 = (char *)this + 25704;
          uint64_t v73 = v442;
        }
        while (v349);
      }
      uint64_t v58 = (uint64_t)v437;
      unsigned int v162 = v438;
      uint64_t v36 = (char *)this + 26904;
      uint64_t v61 = v430;
    }
  }
LABEL_312:
  if (v445)
  {
    uint64_t v163 = *((void *)this + 3312);
    if (v163)
    {
      if ((*(unsigned int (**)(void))(*(void *)v163 + 8))(*((void *)this + 3312)))
      {
        *((void *)this + 6 * v162 + 3227) = (*(uint64_t (**)(uint64_t))(*(void *)v163 + 16))(v163);
        v445 |= 2u;
      }
    }
  }
  if ((v445 & 2) != 0)
  {
    uint64_t v164 = (void (***)(void))*((void *)this + 3312);
    if (v164) {
      (**v164)(v164);
    }
  }
  if (v36[1271])
  {
    *(void *)&uint8_t buf[8] = 0;
    int v165 = 1 << *((unsigned char *)this + 26424);
    *(_DWORD *)buf = 1;
    *(_DWORD *)&uint8_t buf[4] = v165;
LABEL_323:
    IOMobileFramebufferSwapWorkaroundSettings();
    goto LABEL_324;
  }
  if (v36[1272])
  {
    *(void *)&uint8_t buf[4] = 0;
    *(_DWORD *)&buf[12] = 0;
    *(_DWORD *)buf = 2;
    goto LABEL_323;
  }
LABEL_324:
  uint64_t v166 = mach_absolute_time();
  double v167 = CATimeWithHostTime(v166);
  *(double *)(v58 + 128) = v167;
  *(void *)(v58 + 880) = v61;
  __int16 v168 = (void *)*((void *)this + 3192);
  if (v168)
  {
    v168[3] = CAHostTimeWithTime(v167);
    *v168 |= v61;
    (*(void (**)(CA::WindowServer::IOMFBDisplay *, uint64_t))(*(void *)this + 392))(this, 1);
  }
  unint64_t v169 = CAHostTimeWithTime(*(double *)(v58 + 120));
  *(_DWORD *)__int16 v470 = 4;
  *(void *)buf = v169;
  IOMobileFramebufferSwapSetTimestamps();
  unint64_t v170 = CAHostTimeWithTime(*(double *)(v58 + 128));
  *(_DWORD *)__int16 v470 = 5;
  *(void *)buf = v170;
  IOMobileFramebufferSwapSetTimestamps();
  if (!v433) {
    CA::WindowServer::IOMFBDisplay::swap_brightness(this);
  }
  CA::WindowServer::IOMFBDisplay::swap_display_edr_factor((uint64_t)this);
  CA::WindowServer::IOMFBDisplay::swap_display_headroom_used(this, (const CA::Render::Update *)v58);
  char v171 = v441;
  if (CADeviceSupportsReferenceMode::once[0] != -1) {
    dispatch_once(CADeviceSupportsReferenceMode::once, &__block_literal_global_225);
  }
  if (CADeviceSupportsReferenceMode::supports_ref)
  {
    uint64_t v172 = mach_absolute_time();
    double v173 = CATimeWithHostTime(v172);
    if (v173 - *((double *)this + 3194) > 180.0)
    {
      char v174 = *((unsigned char *)this + 26368);
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&uint8_t buf[8] = 0x40000000;
      v477.i64[0] = (uint64_t)___ZN2CA12WindowServer12IOMFBDisplay32send_refmode_residency_telemetryEv_block_invoke;
      v477.i64[1] = (uint64_t)&__block_descriptor_tmp_102_21718;
      LOBYTE(v478) = v174;
      analytics_send_event_lazy();
      *((double *)this + 3194) = v173;
    }
  }
  CA::WindowServer::IOMFBDisplay::swap_hdr_metadata(this, (const CA::Render::Update *)v58);
  if (CADeviceSupportsHWGainMap::once[0] != -1) {
    dispatch_once(CADeviceSupportsHWGainMap::once, &__block_literal_global_80);
  }
  if (!CADeviceSupportsHWGainMap::supports_gain_map) {
    goto LABEL_513;
  }
  v175 = *(float64x2_t **)(v58 + 1048);
  if (!v175
    || BYTE10(xmmword_1EB2ACC50)
    || (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 80))(this))
  {
    uint64_t v73 = v442;
    if (*((_DWORD *)v36 + 20))
    {
      *((_DWORD *)v36 + 20) = 0;
      IOMobileFramebufferSwapSetGainMap();
    }
    goto LABEL_513;
  }
  uint64_t v178 = *((void *)this + 19);
  uint64_t v177 = *((void *)this + 20);
  v179.i64[0] = (int)v177;
  v179.i64[1] = SHIDWORD(v177);
  float64x2_t v180 = vcvtq_f64_s64(v179);
  uint64_t v182 = *((void *)this + 25);
  uint64_t v181 = *((void *)this + 26);
  unsigned __int16 v411 = this;
  v179.i64[0] = (int)v181;
  v179.i64[1] = SHIDWORD(v181);
  float64x2_t v183 = vdivq_f64(v180, vcvtq_f64_s64(v179));
  v179.i64[0] = (int)v178;
  v179.i64[1] = SHIDWORD(v178);
  float64x2_t v184 = vcvtq_f64_s64(v179);
  v179.i64[0] = (int)v182;
  v179.i64[1] = SHIDWORD(v182);
  float64x2_t v450 = vmlsq_f64(v184, vcvtq_f64_s64(v179), v183);
  float64x2_t v455 = v183;
  bzero(buf, 0x500uLL);
  uint64_t v187 = 0;
  unsigned int v188 = 0;
  int v189 = BYTE11(xmmword_1EB2ACC50);
  *(_OWORD *)int32x4_t v429 = 0u;
  __asm { FMOV            V0.2D, #0.5 }
  float64x2_t v439 = _Q0;
  float32x2_t v193 = (float32x2_t)vdup_n_s32(0x40390F46u);
  __asm { FMOV            V15.2S, #1.0 }
  float64x2_t v195 = 0uLL;
  while (1)
  {
    float64_t v196 = v175->f64[1];
    float64x2_t v197 = *(float64x2_t *)(*(void *)&v196 + 80);
    *(_OWORD *)__int16 v470 = *(_OWORD *)(*(void *)&v196 + 64);
    float64x2_t v471 = v197;
    uint64_t v198 = *(void *)(*(void *)&v196 + 128);
    float v199 = 0.0;
    if (v198) {
      float v199 = *(float *)(v198 + 228);
    }
    char v200 = *(unsigned char *)(*(void *)&v196 + 40);
    *(float64x2_t *)uint64_t v459 = v195;
    if ((LOBYTE(v175[10].f64[0]) & 0x10) != 0) {
      double scale = CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)&v175[1], 0, 0, v186);
    }
    else {
      double scale = v175[9].f64[0];
    }
    CA::Mat4Impl::mat4_apply_to_rect(v175 + 1, (int8x16_t *)v470, v185);
    if (v455.f64[0] != 1.0 && v471.f64[0] < 1.79769313e308)
    {
      *(double *)__int16 v470 = *(double *)v470 * v455.f64[0];
      v471.f64[0] = v471.f64[0] * v455.f64[0];
    }
    double v202 = v471.f64[1];
    _NF = v455.f64[1] != 1.0 && v471.f64[1] < 1.79769313e308;
    float64x2_t v195 = *(float64x2_t *)v459;
    if (_NF)
    {
      double v202 = v471.f64[1] * v455.f64[1];
      *(double *)&v470[8] = *(double *)&v470[8] * v455.f64[1];
      v471.f64[1] = v471.f64[1] * v455.f64[1];
    }
    double v204 = v455.f64[0] * v199 * scale;
    float64x2_t v205 = vaddq_f64(v450, *(float64x2_t *)v470);
    *(float64x2_t *)__int16 v470 = v205;
    if (v204 != 0.0) {
      double v204 = v204 + 1.0;
    }
    double v206 = v471.f64[0];
    if (v471.f64[0] <= v202) {
      double v207 = v202;
    }
    else {
      double v207 = v471.f64[0];
    }
    if (v207 < 1.79769313e308)
    {
      double v208 = v471.f64[0] >= v202 ? v202 : v471.f64[0];
      if (v208 > 0.0)
      {
        __asm { FMOV            V4.2D, #-1.0 }
        *(float64x2_t *)__int16 v470 = vaddq_f64(v205, _Q4);
        double v210 = v202 + 2.0;
        v471.f64[0] = v471.f64[0] + 2.0;
        v471.f64[1] = v210;
        if (v206 + 2.0 <= 0.0 || v210 <= 0.0) {
          float64x2_t v471 = 0uLL;
        }
      }
    }
    float64x2_t v211 = v471;
    if (v189)
    {
      double v228 = v471.f64[1];
      if (v471.f64[0] <= v471.f64[1]) {
        double v229 = v471.f64[1];
      }
      else {
        double v229 = v471.f64[0];
      }
      if (v229 < 1.79769313e308)
      {
        if (v471.f64[0] < v471.f64[1]) {
          double v228 = v471.f64[0];
        }
        if (v228 > 0.0)
        {
          float64x2_t v230 = vrndaq_f64(*(float64x2_t *)v470);
          float64x2_t v211 = vsubq_f64(vrndaq_f64(vaddq_f64(*(float64x2_t *)v470, v471)), v230);
          *(float64x2_t *)__int16 v470 = v230;
          float64x2_t v471 = v211;
        }
      }
      uint64_t v58 = (uint64_t)v437;
      float64x2_t v195 = *(float64x2_t *)v459;
    }
    int64x2_t v212 = vclezq_f64(v195);
    int64x2_t v213 = vclezq_f64(v211);
    int32x2_t v214 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v213, v212), (int8x16_t)vzip2q_s64(v213, v212))));
    if ((v214.i8[4] & 1) == 0)
    {
      if (v214.i8[0]) {
        goto LABEL_382;
      }
      float64x2_t v216 = vminnmq_f64(*(float64x2_t *)v429, *(float64x2_t *)v470);
      float64x2_t v215 = vsubq_f64(vmaxnmq_f64(vaddq_f64(*(float64x2_t *)v429, v195), vaddq_f64(*(float64x2_t *)v470, v211)), v216);
LABEL_381:
      *(float64x2_t *)int32x4_t v429 = v216;
      float64x2_t v195 = v215;
      goto LABEL_382;
    }
    float64x2_t v215 = v211;
    float64x2_t v216 = *(float64x2_t *)v470;
    if ((v214.i8[0] & 1) == 0) {
      goto LABEL_381;
    }
LABEL_382:
    int v217 = v200 & 3;
    float v218 = 0.0;
    if (!LOBYTE(v175[10].f64[1])) {
      float v218 = 1.0;
    }
    v475[0] = (float64x2_t)xmmword_184998770;
    LODWORD(v475[1].f64[0]) = 1065353216;
    if (v217 == 3)
    {
      v475[0].f64[0] = 15.8284855;
      *(float64_t *)((char *)&v475[0].f64[1] + 4) = 0.000761708822;
      long long v220 = xmmword_184998790;
      char v219 = 1;
      char v171 = v441;
    }
    else
    {
      _ZF = v217 == 2;
      char v171 = v441;
      char v219 = 0;
      if (_ZF)
      {
        v475[0] = (float64x2_t)xmmword_1849987A0;
        LODWORD(v475[1].f64[0]) = 1061197339;
        long long v220 = xmmword_1849987B0;
      }
      else
      {
        long long v220 = xmmword_184998780;
      }
    }
    float64x2_t v221 = vmulq_f64(v211, v439);
    float32x2_t v222 = vcvt_f32_f64(vaddq_f64(v221, *(float64x2_t *)v470));
    float v223 = v204;
    double v224 = v204 * 1.52866495;
    *(float *)&double v224 = v224;
    *(float32x2_t *)&v221.f64[0] = vcvt_f32_f64(v221);
    float32x2_t v225 = vsub_f32(v193, vdiv_f32(vmul_f32(*(float32x2_t *)&v221.f64[0], v193), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v224, 0)));
    float32x2_t v226 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v225, _D15), (int8x8_t)_D15, (int8x8_t)v225);
    long long v227 = &buf[v187];
    *(float32x2_t *)long long v227 = v222;
    *((void *)v227 + 1) = *(void *)&v221.f64[0];
    *((float *)v227 + 4) = v223;
    *((_DWORD *)v227 + 5) = LODWORD(v224);
    *((float *)v227 + 6) = 1.0 / *(float *)&v224;
    *(int8x8_t *)(v227 + 28) = vbic_s8((int8x8_t)v226, (int8x8_t)vcltz_f32(v226));
    *((float *)v227 + 9) = v218;
    *(_OWORD *)(v227 + 40) = v220;
    *(float64x2_t *)(v227 + 56) = v475[0];
    *((_DWORD *)v227 + 18) = LODWORD(v475[1].f64[0]);
    v227[76] = v219;
    if (v187 == 1200) {
      break;
    }
    v175 = *(float64x2_t **)&v175->f64[0];
    v187 += 80;
    ++v188;
    if (!v175)
    {
      *(float64x2_t *)int32x4_t v460 = v195;
      goto LABEL_402;
    }
  }
  *(float64x2_t *)int32x4_t v460 = v195;
  unsigned int v188 = 16;
LABEL_402:
  uint64_t v36 = (char *)this + 26904;
  unint64_t v231 = (void *)*((void *)this + 3372);
  if (v188 != *((_DWORD *)this + 6746) || memcmp(buf, *((const void **)this + 3372), 80 * v188))
  {
    memcpy(v231, buf, 80 * v188);
    *((_DWORD *)this + 6746) = v188;
    int64x2_t v232 = vceqzq_f64(*(float64x2_t *)v460);
    int8x16_t v233 = 0uLL;
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v232, 1), (int8x16_t)v232).u64[0] & 0x8000000000000000) == 0)
    {
      int8x16_t v234 = vorrq_s8((int8x16_t)vcltzq_f64(*(float64x2_t *)v460), (int8x16_t)vcgezq_f64(*(float64x2_t *)v460));
      if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v234), 1), v234).u64[0] & 0x8000000000000000) == 0)
      {
        int32x4_t v235 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(*(float64x2_t *)v429, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        int8x16_t v233 = (int8x16_t)vuzp1q_s32(v235, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(*(float64x2_t *)v429, *(float64x2_t *)v460), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v235));
      }
    }
    int32x2_t v236 = (int32x2_t)vextq_s8(v233, v233, 8uLL).u64[0];
    uint32x2_t v237 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v236);
    if ((vpmax_u32(v237, v237).u32[0] & 0x80000000) == 0)
    {
      int32x2_t v238 = *(int32x2_t *)((char *)this + 160);
      uint32x2_t v239 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v238);
      if ((vpmax_u32(v239, v239).u32[0] & 0x80000000) != 0
        || (int32x2_t v240 = *(int32x2_t *)((char *)this + 152),
            int32x2_t v241 = vadd_s32(*(int32x2_t *)v233.i8, v236),
            *(int32x2_t *)v242.i8 = vmax_s32(*(int32x2_t *)v233.i8, v240),
            int32x2_t v243 = vsub_s32(vmin_s32(v241, vadd_s32(v240, v238)), *(int32x2_t *)v242.i8),
            uint32x2_t v244 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v243),
            (vpmax_u32(v244, v244).u32[0] & 0x80000000) != 0))
      {
        v233.i64[1] = 0;
      }
      else
      {
        v242.u64[1] = (unint64_t)v243;
        int8x16_t v233 = v242;
      }
    }
    int v295 = v233.i32[2];
    int v296 = v233.i32[3];
    int v440 = v233.i32[2];
    if (v233.i32[2] >= v233.i32[3]) {
      int v295 = v233.i32[3];
    }
    if (v295 <= 0)
    {
      IOMobileFramebufferSwapSetGainMap();
    }
    else
    {
      uint64_t v461 = v233.i64[0];
      double v413 = v6;
      unsigned int v297 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1056))(this) - 1;
      float v452 = 0.5;
      float v423 = 0.5;
      if (v297 <= 7)
      {
        float v452 = flt_1849A8490[v297];
        float v423 = flt_1849A84B0[v297];
      }
      v475[0].f64[0] = 0.0;
      int v298 = HIDWORD(v461);
      IOMFBGainEncoderCreate();
      if (v296 >= 1)
      {
        int v299 = v440 + v461;
        do
        {
          IOMFBGainEncoderStartRow();
          if (v440 < 1)
          {
            float v310 = -1.0;
            float v308 = -1.0;
          }
          else
          {
            int v302 = 0;
            float v303 = -1.0;
            int v304 = v461;
            float v305 = -1.0;
            do
            {
              float v456 = v303;
              LODWORD(v306) = v299 - v304;
              if (v188)
              {
                uint64_t v307 = 0;
                float v308 = 1.0;
                float v309 = (float32x2_t *)buf;
                float v310 = 1.0;
                while (1)
                {
                  unint64_t v311 = CA::GainMapGenerator::Element::gain(v309, (float)v304 + 0.5, (float)v298 + 0.5, v300, v301);
                  unint64_t v312 = HIDWORD(v311);
                  float v313 = *(float *)&v311;
                  if (*(float *)&v311 == -1.0)
                  {
                    float v310 = *((float *)&v478 + 20 * v307 + 1);
                    float v308 = v310;
                    unint64_t v306 = HIDWORD(v311);
                    goto LABEL_493;
                  }
                  unint64_t v314 = CA::GainMapGenerator::Element::gain(v309, v452 + (float)v304, v423 + (float)v298, v300, v301);
                  unint64_t v315 = HIDWORD(v314);
                  if (*(float *)&v314 == -1.0) {
                    break;
                  }
                  if (v310 > *(float *)&v314) {
                    float v310 = *(float *)&v314;
                  }
                  if (v308 > v313) {
                    float v308 = v313;
                  }
                  if ((int)v306 < SHIDWORD(v314)) {
                    LODWORD(v315) = v306;
                  }
                  if ((int)v315 >= (int)v312) {
                    LODWORD(v306) = v312;
                  }
                  else {
                    LODWORD(v306) = v315;
                  }
                  ++v307;
                  v309 += 10;
                  if (v188 == v307) {
                    goto LABEL_493;
                  }
                }
                float v310 = *((float *)&v478 + 20 * v307 + 1);
                float v308 = v310;
                unint64_t v306 = HIDWORD(v314);
              }
              else
              {
                float v310 = 1.0;
                float v308 = 1.0;
              }
LABEL_493:
              if (v308 == v456 && v310 == v305)
              {
                float v310 = v305;
                float v308 = v456;
              }
              else if (v302)
              {
                *(float *)__int16 v470 = v305;
                *(float *)&v470[4] = v456;
                *(float *)&v470[8] = v305;
                IOMFBGainEncoderEmitRun();
                int v302 = 0;
              }
              if ((int)v306 <= 1) {
                int v317 = 1;
              }
              else {
                int v317 = v306;
              }
              v304 += v317;
              v302 += v317;
              float v303 = v308;
              float v305 = v310;
            }
            while (v304 < v299);
          }
          *(float *)__int16 v470 = v310;
          *(float *)&v470[4] = v308;
          *(float *)&v470[8] = v310;
          IOMFBGainEncoderEmitRun();
          ++v298;
        }
        while (v298 < v296 + HIDWORD(v461));
      }
      uint64_t v318 = IOMFBGainEncoderFinishEncoding();
      IOMobileFramebufferSwapSetGainMap();
      if (v318) {
        IOMFBGainMapRelease();
      }
      MEMORY[0x185322F10](*(void *)&v475[0].f64[0]);
      this = v411;
      int v6 = v413;
      uint64_t v58 = (uint64_t)v437;
      uint64_t v36 = v447;
    }
    char v171 = v441;
  }
  __int16 v75 = v446;
  uint64_t v73 = v442;
LABEL_513:
  IOMobileFramebufferSwapDebugInfo();
  __int16 v319 = v432[191];
  int v320 = IOMobileFramebufferSwapEnd();
  if (v36[1258]) {
    CA::IOMobileFramebuffer::swap_wait((CA::IOMobileFramebuffer *)v444);
  }
  if (v433)
  {
    CA::IOMobileFramebuffer::swap_wait((CA::IOMobileFramebuffer *)v444);
    *(_DWORD *)buf = 0;
    CA::IOMobileFramebuffer::swap_begin((CA::IOMobileFramebuffer *)v444, (unsigned int *)buf);
    CA::WindowServer::IOMFBDisplay::swap_brightness(this);
    IOMobileFramebufferSwapEnd();
    CA::IOMobileFramebuffer::swap_wait((CA::IOMobileFramebuffer *)v444);
  }
  if (v425)
  {
    uint64_t v321 = *(CA::WindowServer::Surface **)(v73 + 32);
    if (v321)
    {
      CA::WindowServer::Surface::unref(v321);
      *(void *)(v73 + 32) = 0;
    }
  }
  if (v320)
  {
    if (x_log_hook_p())
    {
      x_log_();
      int v322 = v443;
    }
    else
    {
      v339 = x_log_category_windowserver;
      int v322 = v443;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
      {
        int v340 = *((_DWORD *)this + 6);
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v340;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v320;
        _os_log_impl(&dword_184668000, v339, OS_LOG_TYPE_ERROR, "display %u swap_end returned error %x\n", buf, 0xEu);
      }
    }
    if (BYTE9(xmmword_1EB2ACC10)) {
      kdebug_trace();
    }
    *int v322 = 0;
    uint64_t v12 = 1;
  }
  else
  {
    if (!v36[1248])
    {
      CA::WindowServer::IOMFBDisplay::fetch_default_framebuffer(this);
      CA::IOMobileFramebuffer::swap_wait((CA::IOMobileFramebuffer *)v444);
    }
    int v323 = x_mem_alloc0(0xC8uLL);
    __int32 v324 = v323;
    if (v323)
    {
      v323[13] = 0;
      v323[10] = 0;
      v323[9] = v323 + 10;
      v323[11] = 0;
      v323[12] = v323 + 13;
      v323[14] = 0;
      v323[15] = v323 + 19;
      v323[16] = v323 + 19;
      v323[17] = v323 + 19;
      v323[18] = 4;
    }
    *(void *)&v475[0].f64[0] = v323;
    if (v36[1263])
    {
      *((_DWORD *)v323 + 1) = *(_DWORD *)(v58 + 248);
      v323[1] = *(void *)(v58 + 72);
      *(_DWORD *)int v323 = *v443;
      uint64_t v325 = *(void *)(v73 + 32);
      if (v325)
      {
        float v326 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(void *)v325 + 160))(v325);
        if (v326) {
          *((_DWORD *)v324 + 48) = IOSurfaceGetID(v326);
        }
      }
      *((unsigned char *)v324 + 196) = *((_DWORD *)v75 + 2) - (v171 ^ 1);
      uint64_t v327 = (_WORD *)(v58 + 1084);
      int v328 = *(_WORD *)((unsigned char *)v324 + 197) & 0xFFDF | (32 * ((*(unsigned __int16 *)(v58 + 1084) >> 5) & 1));
      *(_WORD *)((char *)v324 + 197) = v328;
      v324[2] = *(void *)(v58 + 760);
      v324[3] = *(void *)(v58 + 112);
      *((double *)v324 + 23) = v35;
      unsigned int v329 = v328 & 0xFFFFFDFF | (((v416 >> 21) & 1) << 9);
      *(_WORD *)((char *)v324 + 197) = v329;
      uint64_t v330 = *((void *)this + 91);
      if (*(unsigned char *)(v330 + 3) == 1 && *(unsigned char *)(v330 + 2) == 1) {
        __int16 v332 = 16;
      }
      else {
        __int16 v332 = 0;
      }
      float32x2_t v333 = (double *)v58;
      __int16 v334 = v329 & 0xFFEF | v332;
      *(_WORD *)((char *)v324 + 197) = v334;
      unint64_t v335 = CAHostTimeWithTime(v333[96]);
      memset(buf, 0, sizeof(buf));
      mach_get_times();
      v324[4] = *(void *)&buf[8] - *(void *)buf + v335;
      __int16 v336 = v334 & 0xFFF0 | *(_WORD *)(v432 + 139) & 0xF;
      *(_WORD *)((char *)v324 + 197) = v336;
      unint64_t v337 = CAHostTimeWithTime(v333[15]);
      memset(buf, 0, sizeof(buf));
      mach_get_times();
      v324[5] = *(void *)&buf[8] - *(void *)buf + v337;
      if (((void)v333[97] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        unint64_t v338 = -1;
      }
      else {
        unint64_t v338 = CAHostTimeWithTime(v333[97]);
      }
      uint64_t v36 = v447;
      v324[7] = v338;
      if (v415 | v417) {
        __int16 v341 = 128;
      }
      else {
        __int16 v341 = 0;
      }
      __int16 v342 = v336 & 0xFF3F | v341 | ((v447[1261] & 3) << 6);
      *(_WORD *)((char *)v324 + 197) = v342;
      uint64_t v58 = (uint64_t)v437;
      v324[8] = *((void *)v437 + 99);
      __int16 v343 = v342 & 0xF7FF | (v319 << 11);
      *(_WORD *)((char *)v324 + 197) = v343;
      *(_WORD *)((char *)v324 + 197) = (4 * *v327) & 0x1000 | v343 & 0xEFFF;
      std::__tree<CA::Render::Object *>::swap((uint64_t *)v437 + 107, (uint64_t)(v324 + 9));
      CA::Render::Update::swap_displayable_contexts(v437, (uint64_t)(v324 + 12));
    }
    v36[1261] = 0;
    uint64_t v12 = CA::WindowServer::IOMFBDisplay::finish_update_((uint64_t)this, v418, v58, v445);
    if (v36[1263])
    {
      v324[6] = mach_continuous_time();
      os_unfair_lock_lock((os_unfair_lock_t)this + 6485);
      *(void *)__int16 v470 = v472;
      *(void *)&v470[8] = v472;
      *(void *)&v471.f64[0] = v472;
      *(void *)&v471.f64[1] = 4;
      std::exchange[abi:nn180100]<X::small_vector<void({block_pointer})(__CFDictionary const*),4ul>,X::small_vector<void({block_pointer})(__CFDictionary const*),4ul>>((uint64_t)buf, (uint64_t)this + 25968, (uint64_t)v470);
      if (v324 + 15 != (void *)buf) {
        X::small_vector_base<void({block_pointer})(__CFDictionary const*)>::move((uint64_t)(v324 + 15), (uint64_t)buf, v324 + 19);
      }
      if (*(void *)buf != v477.i64[0]) {
        free(*(void **)buf);
      }
      if (*(void *)v470 != *(void *)&v471.f64[0]) {
        free(*(void **)v470);
      }
      std::vector<std::unique_ptr<CA::WindowServer::IOMFBDisplay::FrameInfo>>::push_back[abi:nn180100]((void *)this + 3243, (uint64_t *)v475);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 6485);
    }
    std::unique_ptr<CA::WindowServer::IOMFBDisplay::FrameInfo>::reset[abi:nn180100]((CA::WindowServer::IOMFBDisplay::FrameInfo **)v475, 0);
  }
LABEL_558:
  pthread_mutex_unlock(v431);
LABEL_17:
  return v12;
}

void CA::Render::Update::add_included_context(CA::Render::Update *this, os_unfair_lock_s *a2, char a3)
{
  double begin_time = CA::Render::Context::get_begin_time(a2, *((double *)this + 15));
  uint64_t v7 = mach_absolute_time();
  double v8 = CATimeWithHostTime(v7);
  if (v8 >= begin_time) {
    double v8 = begin_time;
  }
  double v9 = *((double *)this + 96);
  if (v9 >= v8) {
    double v9 = v8;
  }
  *((double *)this + 96) = v9;
  uint32_t os_unfair_lock_opaque = a2[72]._os_unfair_lock_opaque;
  float v11 = *((float *)this + 269);
  if (v11 <= *(float *)&a2[77]._os_unfair_lock_opaque) {
    float v11 = *(float *)&a2[77]._os_unfair_lock_opaque;
  }
  *((float *)this + 269) = v11;
  unint64_t v12 = CAHostTimeWithTime(v8);
  mach_get_times();
  uint32_t v13 = a2[73]._os_unfair_lock_opaque;
  if (v13) {
    *((_DWORD *)this + 67) |= 0x1000000u;
  }
  unint64_t v14 = v12;
  BOOL v15 = v13 != 0;
  int v16 = (void *)((char *)this + 840);
  uint64_t v17 = operator new(0x38uLL);
  char v18 = v17;
  _OWORD v17[4] = 0;
  uint64_t v19 = v17 + 4;
  int v20 = a2;
  if (!atomic_fetch_add((atomic_uint *volatile)&a2[2], 1u))
  {
    int v20 = 0;
    atomic_fetch_add((atomic_uint *volatile)&a2[2], 0xFFFFFFFF);
  }
  _OWORD v17[4] = v20;
  *((unsigned char *)v17 + 40) = v15;
  *((_DWORD *)v17 + 11) = os_unfair_lock_opaque;
  v17[6] = v14;
  double v21 = (void *)*v16;
  if (*v16)
  {
    while (1)
    {
      while (1)
      {
        double v22 = v21;
        BOOL v23 = v21 + 4;
        if (!CA::Render::Update::ContextInfo::operator<(v19, v21 + 4)) {
          break;
        }
        double v21 = (void *)*v22;
        int v16 = v22;
        if (!*v22) {
          goto LABEL_19;
        }
      }
      if (!CA::Render::Update::ContextInfo::operator<(v23, v19)) {
        break;
      }
      int v16 = v22 + 1;
      double v21 = (void *)v22[1];
      if (!v21) {
        goto LABEL_19;
      }
    }
    if (*v16)
    {
      if (v20 && atomic_fetch_add((atomic_uint *volatile)&v20[2], 0xFFFFFFFF) == 1) {
        (*(void (**)(os_unfair_lock_s *))(*(void *)&v20->_os_unfair_lock_opaque + 16))(v20);
      }
      operator delete(v18);
      goto LABEL_22;
    }
  }
  else
  {
    double v22 = (void *)((char *)this + 840);
  }
LABEL_19:
  void *v18 = 0;
  v18[1] = 0;
  v18[2] = v22;
  *int v16 = v18;
  uint64_t v24 = **((void **)this + 104);
  if (v24)
  {
    *((void *)this + 104) = v24;
    char v18 = (void *)*v16;
  }
  uint64_t v25 = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 105), v18);
  ++*((void *)this + 106);
LABEL_22:
  double v26 = *(double *)&a2[134]._os_unfair_lock_opaque;
  *(void *)&a2[134]._uint32_t os_unfair_lock_opaque = 0;
  if (v26 != 0.0) {
    CA::Render::CA_IS_FULFILLING_SERVER_GLITCH_REQUEST((CA::Render *)v25, v26);
  }
  unsigned int v27 = (os_unfair_lock_s **)((char *)this + 336);
  while (1)
  {
    unsigned int v27 = (os_unfair_lock_s **)*v27;
    if (!v27) {
      break;
    }
    if (v27[1] == a2) {
      return;
    }
  }
  uint64_t v28 = x_heap_malloc_small_(*(uint64_t **)this, 0x18uLL);
  *(void *)(v28 + 8) = a2;
  if (!atomic_fetch_add((atomic_uint *volatile)&a2[2], 1u)) {
    atomic_fetch_add((atomic_uint *volatile)&a2[2], 0xFFFFFFFF);
  }
  os_unfair_lock_lock(a2 + 13);
  uint32_t v29 = a2[16]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(a2 + 13);
  *(_DWORD *)(v28 + 16) = v29;
  *(void *)uint64_t v28 = *((void *)this + 42);
  *(unsigned char *)(v28 + 20) = a3;
  *((void *)this + 42) = v28;
  unint64_t v30 = *(void *)&a2[118]._os_unfair_lock_opaque;
  if (*((void *)this + 38) > v30)
  {
    *((void *)this + 38) = v30;
    *(void *)&a2[118]._uint32_t os_unfair_lock_opaque = -1;
  }
}

BOOL CA::Render::Update::ContextInfo::operator<(uint64_t *a1, void *a2)
{
  unsigned int v2 = *((unsigned __int8 *)a1 + 8);
  unsigned int v3 = *((unsigned __int8 *)a2 + 8);
  BOOL v4 = v2 >= v3;
  if (v2 != v3) {
    return !v4;
  }
  unsigned int v7 = *((_DWORD *)a1 + 3);
  unsigned int v8 = *((_DWORD *)a2 + 3);
  BOOL v4 = v7 >= v8;
  if (v7 != v8) {
    return !v4;
  }
  uint64_t v9 = *a1;
  unsigned int v10 = atomic_load((unsigned int *)(*a1 + 228));
  if (!v10)
  {
    if (*(_DWORD *)(v9 + 252)) {
      pid_t v11 = 0;
    }
    else {
      pid_t v11 = getpid();
    }
    unsigned int v12 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(v9 + 228), &v12, v11);
    if (v12) {
      unsigned int v10 = v12;
    }
    else {
      unsigned int v10 = v11;
    }
  }
  uint64_t v13 = *a2;
  unsigned int v14 = atomic_load((unsigned int *)(*a2 + 228));
  if (!v14)
  {
    unsigned int v15 = *(_DWORD *)(v13 + 252) ? 0 : getpid();
    unsigned int v14 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(v13 + 228), &v14, v15);
    if (!v14) {
      unsigned int v14 = v15;
    }
  }
  int v16 = (_DWORD *)*a1;
  if (v10 == v14)
  {
    unsigned int v17 = v16[4];
    unsigned int v18 = *(_DWORD *)(*a2 + 16);
    BOOL v4 = v17 >= v18;
    if (v17 == v18) {
      BOOL v4 = (unint64_t)a1[2] >= a2[2];
    }
    return !v4;
  }
  signed int v20 = atomic_load(v16 + 57);
  if (!v20)
  {
    if (v16[63]) {
      pid_t v21 = 0;
    }
    else {
      pid_t v21 = getpid();
    }
    signed int v22 = 0;
    atomic_compare_exchange_strong(v16 + 57, (unsigned int *)&v22, v21);
    if (v22) {
      signed int v20 = v22;
    }
    else {
      signed int v20 = v21;
    }
  }
  uint64_t v23 = *a2;
  signed int v24 = atomic_load((unsigned int *)(v23 + 228));
  if (!v24)
  {
    unsigned int v25 = *(_DWORD *)(v23 + 252) ? 0 : getpid();
    signed int v24 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(v23 + 228), (unsigned int *)&v24, v25);
    if (!v24) {
      signed int v24 = v25;
    }
  }
  return v20 < v24;
}

unint64_t CAHostTimeWithTime(double a1)
{
  if (*(double *)&time_scale == 0.0 && time_scale_once[0] != -1)
  {
    double v2 = a1;
    dispatch_once_f(time_scale_once, 0, (dispatch_function_t)initialize_time_scale);
    a1 = v2;
  }
  return (unint64_t)(*(double *)&recip_time_scale * a1 + 0.5);
}

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      double v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      unsigned int v3 = (uint64_t *)v2[2];
      BOOL v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (int v8 = *(unsigned __int8 *)(v7 + 24), v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            uint64_t v9 = (uint64_t **)a2[2];
          }
          else
          {
            uint64_t v9 = (uint64_t **)v2[1];
            unsigned int v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              unsigned int v3 = (uint64_t *)v2[2];
            }
            _DWORD v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            CGColorSpace *v9 = v2;
            v2[2] = (uint64_t)v9;
            unsigned int v3 = v9[2];
            double v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          uint64_t *v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (int v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *double v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            unsigned int v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          unsigned int v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        double v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        *double v2 = (uint64_t)v3;
LABEL_27:
        _OWORD v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      unsigned char *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

double CA::Render::Context::get_begin_time(os_unfair_lock_s *this, double a2)
{
  BOOL v4 = this + 120;
  os_unfair_lock_lock(this + 120);
  CGColorSpaceRef v5 = *(double **)&this[122]._os_unfair_lock_opaque;
  int v6 = *(double **)&this[124]._os_unfair_lock_opaque;
  if (v5 == v6)
  {
    double v7 = 1.79769313e308;
  }
  else
  {
    double v7 = 1.79769313e308;
    do
    {
      double v8 = v5[1];
      double v9 = COERCE_DOUBLE(atomic_load(&CA::Render::Context::_begin_time_threshold));
      if (v8 > v9)
      {
        if (v5[1] > a2) {
          break;
        }
        if (*v5 < v7) {
          double v7 = *v5;
        }
      }
      v5 += 2;
    }
    while (v5 != v6);
  }
  os_unfair_lock_unlock(v4);
  return v7;
}

unint64_t CA::GainMapGenerator::Element::gain(float32x2_t *this, float32_t a2, float a3, double a4, double a5)
{
  float32x2_t v5 = (float32x2_t)__PAIR64__(LODWORD(a3), LODWORD(a2));
  float32x2_t v6 = *this;
  float32x2_t v7 = this[1];
  float32x2_t v8 = vabd_f32(v5, *this);
  float32x2_t v9 = vsub_f32(v8, v7);
  float v10 = 1.0;
  if (v9.f32[1] >= 0.0) {
    goto LABEL_9;
  }
  if (v9.f32[0] >= 0.0)
  {
    LODWORD(v14) = (int)v9.f32[0];
    if (v6.f32[0] <= a2) {
      uint64_t v14 = 0x7FFFFFFFLL;
    }
    else {
      uint64_t v14 = v14;
    }
    return LODWORD(v10) | (unint64_t)(v14 << 32);
  }
  LODWORD(a5) = this[2].i32[0];
  float32x2_t v11 = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0), v9);
  float32x2_t v12 = vmaxnm_f32(v11, 0);
  if (v11.f32[0] < v11.f32[1]) {
    v11.f32[0] = v11.f32[1];
  }
  if (v11.f32[0] > 0.0) {
    v11.f32[0] = 0.0;
  }
  float v13 = (float)(sqrtf(vaddv_f32(vmul_f32(v12, v12))) - *(float *)&a5) + v11.f32[0];
  if (v13 > 0.0)
  {
    if (v6.f32[0] < a2)
    {
LABEL_9:
      uint64_t v14 = 0x7FFFFFFFLL;
      return LODWORD(v10) | (unint64_t)(v14 << 32);
    }
    v23.i32[1] = v12.i32[1];
    v23.i32[0] = this[2].i32[0];
    float32x2_t v24 = vmul_f32(v23, v23);
    float v25 = v12.f32[0] - sqrtf(vsub_f32(v24, (float32x2_t)vdup_lane_s32((int32x2_t)v24, 1)).f32[0]);
LABEL_26:
    uint64_t v14 = (int)v25;
    return LODWORD(v10) | (unint64_t)(v14 << 32);
  }
  LODWORD(a5) = this[2].i32[1];
  float32x2_t v15 = vmla_n_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0), v9, this[5].f32[0]);
  if (v15.f32[0] <= 0.0)
  {
    float v26 = v9.f32[1] + 1.0;
    if ((float)(v9.f32[1] + 1.0) < 0.0) {
      float v26 = 0.0;
    }
    if (v9.f32[1] >= -6.1147) {
      float v10 = v26;
    }
    else {
      float v10 = -1.0;
    }
    float v25 = vadd_f32(v6, v7).f32[0] - (float)(*(float *)&a5 + a2);
    goto LABEL_26;
  }
  float32x2_t v16 = vmaxnm_f32(v15, 0);
  float v17 = sqrtf(vaddv_f32(vmul_f32(v16, v16)));
  if (v17 <= (float)(*(float *)&a5 + -6.1147))
  {
    float v27 = v8.f32[0] + v8.f32[0];
    float v28 = v17 - *(float *)&a5;
LABEL_34:
    if (v6.f32[0] <= a2) {
      float v35 = v28;
    }
    else {
      float v35 = v27;
    }
    uint64_t v14 = (int)v35;
    float v10 = -1.0;
    return LODWORD(v10) | (unint64_t)(v14 << 32);
  }
  if (this[9].i8[4])
  {
    float v18 = fminf(v16.f32[0], v16.f32[1]);
    float v19 = fmaxf(v16.f32[0], v16.f32[1]);
    float v20 = v18 / v19;
    BOOL v21 = v19 == 0.0;
    float v22 = 0.0;
    if (!v21) {
      float v22 = v20;
    }
  }
  else
  {
    float v29 = this[3].f32[0] * fabsf(vsub_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 1), v16).f32[0]);
    float v30 = 1.0 - v29;
    BOOL v31 = v29 < 1.0;
    float v22 = 0.0;
    if (v31) {
      float v22 = v30;
    }
  }
  float v32 = (float)(v17
              - (float)((float)((float)((float)(this[8].f32[0]
                                              + (float)((float)(this[7].f32[1]
                                                              + (float)((float)(this[7].f32[0]
                                                                              + (float)((float)(this[6].f32[1]
                                                                                              + (float)((float)(this[6].f32[0] + (float)(this[5].f32[1] * v22)) * v22))
                                                                                      * v22))
                                                                      * v22))
                                                      * v22))
                                      * (float)(this[8].f32[1] * v22))
                              + 1.0)
                      * *(float *)&a5))
      * this[9].f32[0];
  uint64_t v33 = 8;
  if (vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v12, 1), v12).u8[0]) {
    uint64_t v33 = 7;
  }
  float v34 = v32 + (float)((float)(v13 - v32) * this->f32[v33]);
  if (v34 < -6.1147)
  {
    float v27 = v8.f32[0] + v8.f32[0];
    float v28 = v34 - *(float *)&a5;
    goto LABEL_34;
  }
  if (v34 <= 0.0)
  {
    if ((float)(v34 + 1.0) >= 0.0) {
      float v10 = v34 + 1.0;
    }
    else {
      float v10 = 0.0;
    }
    uint64_t v14 = 1;
  }
  else
  {
    LODWORD(v14) = (int)v34;
    if (v6.f32[0] <= a2) {
      uint64_t v14 = 0x7FFFFFFFLL;
    }
    else {
      uint64_t v14 = v14;
    }
    float v10 = 1.0;
  }
  return LODWORD(v10) | (unint64_t)(v14 << 32);
}

void X::small_vector_base<void({block_pointer})(__CFDictionary const*)>::move(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1 != a2)
  {
    float32x2_t v6 = *(void **)a1;
    if (v6 != *(void **)(a1 + 16)) {
      free(v6);
    }
    *(void *)(a1 + 16) = a3;
    if (*(void *)a2 == *(void *)(a2 + 16))
    {
      *(void *)a1 = a3;
      float32x2_t v8 = *(uint64_t **)a2;
      *(void *)(a1 + 8) = (char *)a3 + *(void *)(a2 + 8) - *(void *)a2;
      float32x2_t v9 = *(uint64_t **)(a2 + 8);
      while (v8 != v9)
      {
        uint64_t v10 = *v8++;
        *a3++ = v10;
      }
    }
    else
    {
      uint64_t v7 = *(void *)(a2 + 8);
      *(void *)a1 = *(void *)a2;
      *(void *)(a1 + 8) = v7;
      *(_OWORD *)a2 = 0u;
      *(_OWORD *)(a2 + 16) = 0u;
    }
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
  }
}

uint64_t CA::WindowServer::IOMFBDisplay::swap_display_edr_factor(uint64_t this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = this + 26176;
  float v2 = *(float *)(this + 26176);
  if (*(float *)(this + 26180) != v2)
  {
    uint64_t v3 = this;
    *(float *)(this + 26180) = v2;
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      BOOL v4 = x_log_category_windowserver;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEBUG))
      {
        int v5 = *(_DWORD *)(v3 + 24);
        double v6 = *(float *)v1;
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v5;
        __int16 v8 = 2048;
        double v9 = v6;
        _os_log_impl(&dword_184668000, v4, OS_LOG_TYPE_DEBUG, "Display %u setting display edr to %g", buf, 0x12u);
      }
    }
    if (*(unsigned char *)(v1 + 2033) && (*(unsigned char *)(v3 + 746) & 2) != 0)
    {
      return IOMobileFramebufferSwapSetDisplayEdr();
    }
    else
    {
      *(void *)buf = vcvts_n_u32_f32(*(float *)v1, 0x10uLL);
      return IOMobileFramebufferSetParameter();
    }
  }
  return this;
}

uint64_t CA::IOMobileFramebuffer::swap_begin(CA::IOMobileFramebuffer *this, unsigned int *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 8))
  {
    uint64_t v5 = 0;
    double v6 = &v5;
    uint64_t v7 = 0x2000000000;
    int v8 = 0;
    BMMonitorBlockExecutionWithSignature();
    uint64_t v3 = *((unsigned int *)v6 + 6);
    _Block_object_dispose(&v5, 8);
  }
  else
  {
    uint64_t v3 = IOMobileFramebufferSwapBegin();
    if (!v3) {
      *((unsigned char *)this + 16) = 0;
    }
  }
  return v3;
}

uint64_t CA::WindowServer::IOMFBDisplay::finish_update_(uint64_t a1, _DWORD *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1 + 25368;
  unsigned int v13 = a4;
  int v7 = *(_DWORD *)(a1 + 25712);
  if (v7 == 1) {
    a2[6] = 0;
  }
  *a2 = *(_DWORD *)(a3 + 248);
  if (*(unsigned char *)(a1 + 28164) && !*(_DWORD *)(a1 + 25936)) {
    *(_DWORD *)(a1 + 25936) = a2[6];
  }
  int v8 = *(_DWORD *)(a1 + 25704);
  *(_DWORD *)(a1 + 25708) = v8;
  if (v8 + 1 == v7) {
    int v9 = 0;
  }
  else {
    int v9 = v8 + 1;
  }
  *(_DWORD *)(a1 + 25704) = v9;
  (*(void (**)(uint64_t, void))(*(void *)a1 + 2216))(a1, (*(_DWORD *)(a3 + 268) >> 5) & 1);
  uint64_t updated = CA::WindowServer::Display::update_clones((CA::WindowServer::Display *)a1, (CA::Render::Update *)a3, &v13);
  *(unsigned char *)(v6 + 2769) = 0;
  *(unsigned char *)(v6 + 2781) = 0;
  ++*(_DWORD *)v6;
  if (!*(unsigned char *)(v6 + 2831)) {
    ++*(_DWORD *)(v6 + 16);
  }
  *(unsigned char *)(v6 + 2831) = 0;
  float32x2_t v11 = *(CA::WindowServer::Surface **)(a1 + 26552);
  if (v11
    && ((*(_DWORD *)(a1 + 624) & 4) == 0
     || ((*(unsigned int *)(a3 + 1084) | ((unint64_t)*(unsigned __int16 *)(a3 + 1088) << 32)) & 0x10000000000) == 0))
  {
    CA::WindowServer::Surface::unref(v11);
    *(void *)(a1 + 26552) = 0;
  }
  CA::WindowServer::IOMFBDisplay::collect_buffers((CA::WindowServer::IOMFBDisplay *)a1, *(void *)(a3 + 288));
  CA::WindowServer::Display::purge_surfaces((os_unfair_lock_s *)a1, 0);
  return updated;
}

uint64_t CA::WindowServer::IOSurface::set_premultiplied(uint64_t this, int a2)
{
  if (*(unsigned __int8 *)(this + 289) != a2)
  {
    char v2 = a2;
    uint64_t v3 = this;
    this = IOSurfaceSetBulkAttachments2();
    *(unsigned char *)(v3 + 289) = v2;
  }
  return this;
}

uint64_t CA::WindowServer::IOMFBDisplay::update_blackpoint_adaptation(CA::WindowServer::IOMFBDisplay *this)
{
  uint64_t result = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1840))(this);
  if (result)
  {
    if (*((unsigned char *)this + 28205) && HIBYTE(xmmword_1EB2ACC30) == 0)
    {
      BOOL v4 = (unsigned int *)((char *)this + 48 * *((unsigned int *)this + 6426) + 25808);
      if (!*v4) {
        CA::IOMobileFramebuffer::swap_begin((CA::WindowServer::IOMFBDisplay *)((char *)this + 25568), v4);
      }
      uint64_t v5 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1872))(this);
      uint64_t result = CA::WindowServer::IOMFBDisplay::set_icc_curve_with_cg_trc((uint64_t)this, v5, 0x11u, 7);
      *((unsigned char *)this + 28205) = 0;
    }
  }
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::set_framebuffer_ax_matrix(CA::WindowServer::IOMFBDisplay *this)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (float *)((char *)this + 26904);
  if (*((unsigned char *)this + 28154) || *((unsigned char *)this + 26972)) {
    return 0;
  }
  memset(v42, 0, 60);
  BOOL v4 = (char *)this + 26904;
  for (uint64_t i = 12; i != 48; i += 12)
  {
    uint64_t v6 = (char *)v42 + i;
    *(void *)uint64_t v6 = *(void *)v4;
    *((_DWORD *)v6 + 2) = *((_DWORD *)v4 + 2);
    v4 += 16;
  }
  uint64_t result = IOMobileFramebufferSwapSetColorMatrix();
  if (!result)
  {
    *(void *)buf = vcvts_n_u32_f32(v1[16], 0x10uLL);
    uint64_t result = IOMobileFramebufferSetParameter();
    if (!BYTE8(xmmword_1EB2ACBF0))
    {
LABEL_9:
      *((unsigned char *)v1 + 68) = 1;
      return result;
    }
    uint64_t v7 = result;
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      int v8 = x_log_category_windowserver;
      BOOL v9 = os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT);
      uint64_t result = v7;
      if (!v9) {
        goto LABEL_9;
      }
      int v10 = *((_DWORD *)this + 6);
      double v11 = *v1;
      double v12 = v1[1];
      double v13 = v1[2];
      double v14 = v1[4];
      double v15 = v1[5];
      double v16 = v1[6];
      double v17 = v1[8];
      double v18 = v1[9];
      double v19 = v1[10];
      double v20 = v1[16];
      *(_DWORD *)buf = 67111680;
      *(_DWORD *)&uint8_t buf[4] = v10;
      __int16 v22 = 2048;
      double v23 = v11;
      __int16 v24 = 2048;
      double v25 = v12;
      __int16 v26 = 2048;
      double v27 = v13;
      __int16 v28 = 2048;
      double v29 = v14;
      __int16 v30 = 2048;
      double v31 = v15;
      __int16 v32 = 2048;
      double v33 = v16;
      __int16 v34 = 2048;
      double v35 = v17;
      __int16 v36 = 2048;
      double v37 = v18;
      __int16 v38 = 2048;
      double v39 = v19;
      __int16 v40 = 2048;
      double v41 = v20;
      _os_log_impl(&dword_184668000, v8, OS_LOG_TYPE_DEFAULT, "Display %u accessibility matrix [%g, %g, %g; %g, %g, %g; %g, %g, %g], scale %g\n",
        buf,
        0x6Cu);
    }
    uint64_t result = v7;
    goto LABEL_9;
  }
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::update_gamma_adjustment(CA::WindowServer::IOMFBDisplay *this)
{
  uint64_t result = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1840))(this);
  if (result)
  {
    if (*((unsigned char *)this + 28206) && HIBYTE(xmmword_1EB2ACC30) == 0)
    {
      BOOL v4 = (unsigned int *)((char *)this + 48 * *((unsigned int *)this + 6426) + 25808);
      if (!*v4) {
        CA::IOMobileFramebuffer::swap_begin((CA::WindowServer::IOMFBDisplay *)((char *)this + 25568), v4);
      }
      uint64_t v5 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1888))(this);
      CA::WindowServer::IOMFBDisplay::set_icc_curve_with_cg_trc((uint64_t)this, v5, 0x10u, 1);
      CA::WindowServer::IOMFBDisplay::set_icc_curve_with_cg_trc((uint64_t)this, v5 + 36, 0x10u, 2);
      uint64_t result = CA::WindowServer::IOMFBDisplay::set_icc_curve_with_cg_trc((uint64_t)this, v5 + 72, 0x10u, 4);
      *((unsigned char *)this + 28206) = 0;
    }
  }
  return result;
}

double CA::WindowServer::IOMFBDisplay::update_user_adjustment(CA::WindowServer::IOMFBDisplay *this)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (float *)((char *)this + 26896);
  if (!*((unsigned char *)this + 26900))
  {
    memset(v12, 0, 60);
    long long v3 = *(_OWORD *)((char *)this + 26876);
    *(_OWORD *)((char *)v12 + 12) = *(_OWORD *)((char *)this + 26860);
    *(_OWORD *)((char *)&v12[1] + 12) = v3;
    HIDWORD(v12[2]) = *((_DWORD *)this + 6723);
    CA::IOMobileFramebuffer::swap_set_icc_matrix((uint64_t)this + 25568, 7u, *((_DWORD *)this + 6), 0, (float *)v12);
    IOMobileFrameBufferSwapSetUserLuminanceAdjustment();
    *((unsigned char *)v1 + 4) = 1;
    if (BYTE8(xmmword_1EB2ACC30))
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v5 = x_log_category_color;
        if (os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_INFO))
        {
          int v6 = *((_DWORD *)this + 6);
          double v7 = *v1;
          *(_DWORD *)buf = 67109376;
          int v9 = v6;
          __int16 v10 = 2048;
          double v11 = v7;
          _os_log_impl(&dword_184668000, v5, OS_LOG_TYPE_INFO, "Display %u setting IOMFB display luminance adjustment to %f", buf, 0x12u);
        }
      }
    }
  }
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::update_system_gamma(CA::WindowServer::IOMFBDisplay *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (*(float *)&dword_1EB2ACB54 != 0.0)
  {
    memset(v5, 0, sizeof(v5));
    *(void *)((char *)v5 + 4) = dword_1EB2ACB54 | 0x3F80000000000000;
    int v6 = 0;
    (*(void (**)(CA::WindowServer::IOMFBDisplay *, _OWORD *))(*(void *)this + 1864))(this, v5);
  }
  uint64_t result = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1840))(this);
  if (result && *((unsigned char *)this + 28204) && !HIBYTE(xmmword_1EB2ACC30))
  {
    long long v3 = (unsigned int *)((char *)this + 48 * *((unsigned int *)this + 6426) + 25808);
    if (!*v3) {
      CA::IOMobileFramebuffer::swap_begin((CA::WindowServer::IOMFBDisplay *)((char *)this + 25568), v3);
    }
    uint64_t v4 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1856))(this);
    uint64_t result = CA::WindowServer::IOMFBDisplay::set_icc_curve_with_cg_trc((uint64_t)this, v4, 0xEu, 7);
    *((unsigned char *)this + 28204) = 0;
  }
  return result;
}

double CACurrentMediaTimeDelta()
{
  return CATimeWithHostTime(0);
}

void CA::WindowServer::IOMFBDisplay::collect_buffers(CA::WindowServer::IOMFBDisplay *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 3254);
  if (v2)
  {
    uint64_t v4 = (uint64_t *)((char *)this + 26032);
    do
    {
      if (*(_DWORD *)(v2 + 8)
        || (uint64_t v5 = *(_DWORD **)(v2 + 32)) == 0
        || (v5[56] & 0x4000000) != 0
        || (*(uint64_t (**)(_DWORD *))(*(void *)v5 + 216))(v5) == a2
        && (*(_DWORD *)(*(void *)(v2 + 32) + 224) & 0x10000000) == 0)
      {
        uint64_t v4 = (uint64_t *)v2;
      }
      else
      {
        uint64_t *v4 = *(void *)v2;
        CA::WindowServer::IOMFBDisplay::release_buffer((void *)v2);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, (void *)v2);
      }
      uint64_t v2 = *v4;
    }
    while (*v4);
  }
}

void CA::WindowServer::IOMFBDisplay::swap_hdr_metadata(CA::WindowServer::IOMFBDisplay *this, const CA::Render::Update *a2)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (char *)this + 26256;
  if (!*((unsigned char *)this + 28154))
  {
    unint64_t v5 = *((void *)this + 3388);
    int v6 = CA::WindowServer::Display::Mode::hdr_type(v5);
    if (((*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1544))(this) & 1) == 0)
    {
      uint64_t v7 = (_DWORD *)((char *)this + 25656);
      if ((v5 & 0xF00000000000000) == 0xD00000000000000)
      {
        if (!*((void *)this + 3206)) {
          *((void *)this + 3206) = malloc_type_calloc(0x20CuLL, 1uLL, 0xA3EE5BA1uLL);
        }
        CFTypeRef cf = 0;
        uint64_t v8 = *((void *)this + 3255);
        if (v8 && (uint64_t v9 = *(void *)(v8 + 16)) != 0 && (*(uint64_t (**)(uint64_t))(*(void *)v9 + 160))(v9))
        {
          __int16 v10 = (__IOSurface *)(*(uint64_t (**)(void))(**(void **)(*((void *)this + 3255) + 16) + 160))(*(void *)(*((void *)this + 3255) + 16));
          CFTypeRef v11 = IOSurfaceCopyValue(v10, @"DolbyVisionHDMIData");
          CFTypeRef cf = v11;
        }
        else
        {
          if (!(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 80))(this)) {
            goto LABEL_31;
          }
          double v19 = (const void *)*((void *)a2 + 113);
          if (!v19) {
            goto LABEL_31;
          }
          X::CFRef<__CFData const*>::operator=(&cf, v19);
          CFTypeRef v11 = cf;
        }
        if (v11)
        {
          CFTypeID v20 = CFGetTypeID(v11);
          if (v20 == CFDataGetTypeID() && CFDataGetLength((CFDataRef)cf) >= 524)
          {
            v79.locatiounint64_t n = 0;
            v79.length = 524;
            CFDataGetBytes((CFDataRef)cf, v79, *((UInt8 **)this + 3206));
            _DWORD *v7 = 0;
            goto LABEL_37;
          }
        }
LABEL_31:
        if (*v7 == 5)
        {
LABEL_43:
          if (cf) {
            CFRelease(cf);
          }
          return;
        }
        uint64_t v21 = *((void *)this + 3206);
        if (hdrprocessing_init_once != -1) {
          dispatch_once_f(&hdrprocessing_init_once, 0, (dispatch_function_t)load_hdrprocessing_symbols);
        }
        if (hdr_handle) {
          objc_msgSend((id)hdr_processor_class, "dolbyIOMFBMetadata:withMinBrightness:maxBrightness:", v21);
        }
        _DWORD *v7 = 5;
LABEL_37:
        int v22 = IOMobileFramebufferSwapSetParams();
        if (v22)
        {
          int v23 = v22;
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            __int16 v24 = x_log_category_windowserver;
            if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
            {
              int v25 = *((_DWORD *)this + 6);
              *(_DWORD *)buf = 67109376;
              int v49 = v25;
              __int16 v50 = 1024;
              int v51 = v23;
              _os_log_impl(&dword_184668000, v24, OS_LOG_TYPE_ERROR, "display %u set hdr metadata returned error %x\n", buf, 0xEu);
            }
          }
        }
        goto LABEL_43;
      }
      if (v6 != 3)
      {
        _DWORD *v7 = 0;
        return;
      }
      if (v2[1916] && !BYTE5(xmmword_1EB2ACC10))
      {
        if (!*((void *)this + 3208)) {
          *((void *)this + 3208) = malloc_type_calloc(0x49uLL, 1uLL, 0xC173EC8BuLL);
        }
        uint64_t v12 = *((void *)this + 3255);
        if (v12)
        {
          uint64_t v13 = *(void *)(v12 + 16);
          if (v13)
          {
            if ((*(uint64_t (**)(uint64_t))(*(void *)v13 + 160))(v13))
            {
              double v14 = (__IOSurface *)(*(uint64_t (**)(void))(**(void **)(*((void *)this + 3255) + 16)
                                                                     + 160))(*(void *)(*((void *)this + 3255)
                                                                                         + 16));
              CFDataRef v15 = (const __CFData *)IOSurfaceCopyValue(v14, @"HDR10PlusData");
              if (v15)
              {
                CFDataRef v16 = v15;
                CFTypeID v17 = CFGetTypeID(v15);
                if (v17 == CFDataGetTypeID())
                {
                  if (BYTE6(xmmword_1EB2ACC10))
                  {
                    BytePtr = CFDataGetBytePtr(v16);
                    int Length = CFDataGetLength(v16);
                    double v29 = x_log_category_windowserver;
                    if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 67109634;
                      int v49 = Length;
                      __int16 v50 = 1040;
                      int v51 = Length;
                      __int16 v52 = 2096;
                      *(void *)unsigned int v53 = BytePtr;
                      _os_log_impl(&dword_184668000, v29, OS_LOG_TYPE_DEFAULT, "HDR10PlusMetadataSEI: Size:%d bytes, %.*P", buf, 0x18u);
                    }
                  }
                  if (CA::CAHDRProcessor::iomfb_hdr10plus_convert_sei_to_metadata(v16, *((const __CFData **)this + 3208), v18))
                  {
                    if (BYTE6(xmmword_1EB2ACC10))
                    {
                      if (x_log_hook_p())
                      {
                        x_log_();
                      }
                      else
                      {
                        __int16 v30 = x_log_category_windowserver;
                        if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v31 = *((void *)this + 3208);
                          int v32 = *(_DWORD *)(v31 + 1);
                          int v33 = *(_DWORD *)(v31 + 5);
                          int v34 = *(_DWORD *)(v31 + 9);
                          int v35 = *(_DWORD *)(v31 + 13);
                          int v36 = *(_DWORD *)(v31 + 17);
                          int v37 = *(_DWORD *)(v31 + 21);
                          int v38 = *(_DWORD *)(v31 + 25);
                          int v39 = *(_DWORD *)(v31 + 29);
                          int v40 = *(_DWORD *)(v31 + 33);
                          int v41 = *(_DWORD *)(v31 + 37);
                          int v42 = *(_DWORD *)(v31 + 41);
                          int v43 = *(unsigned __int16 *)(v31 + 45);
                          int v44 = *(unsigned __int16 *)(v31 + 47);
                          int v45 = *(unsigned __int8 *)(v31 + 67);
                          int v46 = *(unsigned __int8 *)(v31 + 69);
                          LODWORD(v31) = *(unsigned __int8 *)(v31 + 70);
                          *(_DWORD *)buf = 67112960;
                          int v49 = v32;
                          __int16 v50 = 1024;
                          int v51 = v33;
                          __int16 v52 = 1024;
                          *(_DWORD *)unsigned int v53 = v34;
                          *(_WORD *)&v53[4] = 1024;
                          *(_DWORD *)&v53[6] = v35;
                          __int16 v54 = 1024;
                          int v55 = v36;
                          __int16 v56 = 1024;
                          int v57 = v37;
                          __int16 v58 = 1024;
                          int v59 = v38;
                          __int16 v60 = 1024;
                          int v61 = v39;
                          __int16 v62 = 1024;
                          int v63 = v40;
                          __int16 v64 = 1024;
                          int v65 = v41;
                          __int16 v66 = 1024;
                          int v67 = v42;
                          __int16 v68 = 1024;
                          int v69 = v43;
                          __int16 v70 = 1024;
                          int v71 = v44;
                          __int16 v72 = 1024;
                          int v73 = v45;
                          __int16 v74 = 1024;
                          int v75 = v46;
                          __int16 v76 = 1024;
                          int v77 = v31;
                          _os_log_impl(&dword_184668000, v30, OS_LOG_TYPE_DEFAULT, "Converted HDR10PlusMetadataParams:TargetedSystemDisplayMaxLum[%u], AverageMaxRGB[%u], distValues[%u, %u, %u, %u, %u, %u, %u, %u, %u], KneePointX[%u], KneePointY[%u], ToneMappingFlag[%u], GraphicsOverlayFlag[%u], vsifTimingMode[%u]\n", buf, 0x62u);
                        }
                      }
                    }
                    _DWORD *v7 = 0;
                    CFRelease(v16);
                    goto LABEL_50;
                  }
                }
                CFRelease(v16);
              }
            }
          }
        }
        if (*v7 == 3) {
          return;
        }
        if (BYTE6(xmmword_1EB2ACC10))
        {
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            __int16 v26 = x_log_category_windowserver;
            if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_184668000, v26, OS_LOG_TYPE_DEFAULT, "HDR10PlusMetadata: Swapping in NULL metadata", buf, 2u);
            }
          }
        }
        **((unsigned char **)this + 3208) = 0;
        _DWORD *v7 = 3;
LABEL_50:
        IOMobileFramebufferSwapSetParams();
      }
    }
  }
}

void std::exchange[abi:nn180100]<X::small_vector<void({block_pointer})(__CFDictionary const*),4ul>,X::small_vector<void({block_pointer})(__CFDictionary const*),4ul>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  X::small_vector_base<void({block_pointer})(__CFDictionary const*)>::small_vector_base((uint64_t **)a1, a2, (uint64_t *)(a1 + 32));
  if (a2 != a3)
  {
    X::small_vector_base<void({block_pointer})(__CFDictionary const*)>::move(a2, a3, (void *)(a2 + 32));
  }
}

void *std::vector<std::unique_ptr<CA::WindowServer::IOMFBDisplay::FrameInfo>>::push_back[abi:nn180100](void *result, uint64_t *a2)
{
  long long v3 = result;
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = result + 2;
  unint64_t v5 = result[2];
  int v6 = (void *)result[1];
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v9 = ((uint64_t)v6 - *result) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      abort();
    }
    uint64_t v10 = v5 - *result;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    int v25 = v4;
    if (v12) {
      unint64_t v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v12);
    }
    else {
      uint64_t v13 = 0;
    }
    double v14 = (void *)(v12 + 8 * v9);
    unint64_t v15 = v12 + 8 * v13;
    unint64_t v24 = v15;
    uint64_t v16 = *a2;
    *a2 = 0;
    void *v14 = v16;
    uint64_t v8 = v14 + 1;
    v23.i64[1] = (uint64_t)(v14 + 1);
    double v18 = (void *)*v3;
    CFTypeID v17 = (void *)v3[1];
    if (v17 == (void *)*v3)
    {
      int64x2_t v20 = vdupq_n_s64((unint64_t)v17);
    }
    else
    {
      do
      {
        uint64_t v19 = *--v17;
        void *v17 = 0;
        *--double v14 = v19;
      }
      while (v17 != v18);
      int64x2_t v20 = *(int64x2_t *)v3;
      uint64_t v8 = (void *)v23.i64[1];
      unint64_t v15 = v24;
    }
    void *v3 = v14;
    v3[1] = v8;
    int64x2_t v23 = v20;
    unint64_t v21 = v3[2];
    _OWORD v3[2] = v15;
    unint64_t v24 = v21;
    uint64_t v22 = v20.i64[0];
    uint64_t result = (void *)std::__split_buffer<std::unique_ptr<CA::WindowServer::IOMFBDisplay::FrameInfo>>::~__split_buffer((uint64_t)&v22);
  }
  else
  {
    uint64_t v7 = *a2;
    *a2 = 0;
    *int v6 = v7;
    uint64_t v8 = v6 + 1;
  }
  v3[1] = v8;
  return result;
}

uint64_t *std::__tree<CA::Render::Object *>::swap(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  CGColorSpace *result = *(void *)a2;
  *(void *)a2 = v2;
  uint64_t v5 = result[1];
  uint64_t v4 = result[2];
  long long v3 = result + 1;
  *(_OWORD *)(result + 1) = *(_OWORD *)(a2 + 8);
  *(void *)(a2 + 8) = v5;
  *(void *)(a2 + 16) = v4;
  if (result[2]) {
    uint64_t result = (uint64_t *)(*v3 + 16);
  }
  CGColorSpace *result = (uint64_t)v3;
  int v6 = (void *)(*(void *)(a2 + 8) + 16);
  if (!v4) {
    int v6 = (void *)a2;
  }
  *int v6 = a2 + 8;
  return result;
}

void *CA::Render::Update::swap_displayable_contexts(void *result, uint64_t a2)
{
  uint64_t v2 = result + 104;
  uint64_t v3 = result[104];
  result[104] = *(void *)a2;
  *(void *)a2 = v3;
  uint64_t v4 = result + 105;
  uint64_t v5 = result[105];
  uint64_t v6 = result[106];
  *(_OWORD *)(result + 105) = *(_OWORD *)(a2 + 8);
  *(void *)(a2 + 8) = v5;
  *(void *)(a2 + 16) = v6;
  if (result[106]) {
    uint64_t v2 = (void *)(*v4 + 16);
  }
  *uint64_t v2 = v4;
  uint64_t v7 = (void *)(*(void *)(a2 + 8) + 16);
  if (!v6) {
    uint64_t v7 = (void *)a2;
  }
  void *v7 = a2 + 8;
  return result;
}

BOOL CA::WindowServer::Display::purge_surfaces(os_unfair_lock_s *this, char a2)
{
  uint64_t v4 = this + 56;
  os_unfair_lock_lock(this + 56);
  uint64_t v6 = *(void **)&this[64]._os_unfair_lock_opaque;
  uint64_t v5 = *(void **)&this[66]._os_unfair_lock_opaque;
  if (v6 == v5)
  {
    BOOL v14 = 0;
    goto LABEL_31;
  }
  uint64_t v7 = *(void **)&this[66]._os_unfair_lock_opaque;
  while (1)
  {
    uint64_t v8 = *v6;
    if ((*(_DWORD *)(*v6 + 224) & 0x4000000) == 0)
    {
      uint64_t v9 = *(void *)(v8 + 16);
      if (v9)
      {
        unint64_t v10 = [*(id *)(v9 + 8) signaledValue] + 1;
        uint64_t v8 = *v6;
        if (*(void *)(v9 + 32) - 1 >= v10)
        {
          if (!CA::WindowServer::SharedEvent::is_complete_with_timeout(*(CA::WindowServer::SharedEvent **)(v8 + 16))) {
            goto LABEL_10;
          }
          uint64_t v8 = *v6;
        }
      }
      if (a2) {
        goto LABEL_14;
      }
      int v12 = *(_DWORD *)(v8 + 224);
      uint64_t v11 = v8 + 224;
      unint64_t v13 = v12 & 0xFF00FFFF | ((unint64_t)*(unsigned __int8 *)(v11 + 4) << 32);
      *(unsigned char *)(v11 + 4) = BYTE4(v13);
      *(_DWORD *)uint64_t v11 = v13 | ((BYTE2(v12) - 1) << 16);
      if (BYTE2(v12) == 1) {
        break;
      }
    }
LABEL_10:
    if (++v6 == v5) {
      goto LABEL_29;
    }
  }
  uint64_t v8 = *v6;
LABEL_14:
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  if (v6 != v5)
  {
    unint64_t v15 = v6 + 1;
    uint64_t v7 = v6;
    while (v15 != v5)
    {
      uint64_t v16 = *v15;
      if ((*(_DWORD *)(*v15 + 224) & 0x4000000) != 0) {
        goto LABEL_25;
      }
      uint64_t v17 = *(void *)(v16 + 16);
      if (v17)
      {
        unint64_t v18 = [*(id *)(v17 + 8) signaledValue] + 1;
        uint64_t v16 = *v15;
        if (*(void *)(v17 + 32) - 1 >= v18)
        {
          BOOL is_complete_with_timeout = CA::WindowServer::SharedEvent::is_complete_with_timeout(*(CA::WindowServer::SharedEvent **)(v16 + 16));
          uint64_t v16 = *v15;
          if (!is_complete_with_timeout) {
            goto LABEL_25;
          }
        }
      }
      if ((a2 & 1) != 0
        || (int v21 = *(_DWORD *)(v16 + 224),
            uint64_t v20 = v16 + 224,
            unint64_t v22 = v21 & 0xFF00FFFF | ((unint64_t)*(unsigned __int8 *)(v20 + 4) << 32),
            *(_DWORD *)uint64_t v20 = v21 & 0xFF00FFFF | ((BYTE2(v21) - 1) << 16),
            *(unsigned char *)(v20 + 4) = BYTE4(v22),
            uint64_t v16 = *v15,
            BYTE2(v21) == 1))
      {
        if (v16) {
          (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
        }
      }
      else
      {
LABEL_25:
        *v7++ = v16;
      }
      ++v15;
    }
  }
LABEL_29:
  int64x2_t v23 = *(void **)&this[66]._os_unfair_lock_opaque;
  BOOL v14 = v7 != v23;
  if (v7 != v23)
  {
    *(void *)&this[66]._uint32_t os_unfair_lock_opaque = v7;
    BOOL v14 = 1;
  }
LABEL_31:
  os_unfair_lock_unlock(v4);
  return v14;
}

uint64_t CA::WindowServer::IOMFBDisplay::set_dpb_enabled(uint64_t this, int a2)
{
  if (*(unsigned __int8 *)(this + 28150) != a2)
  {
    uint64_t v2 = (CA::WindowServer::IOMFBDisplay *)this;
    *(unsigned char *)(this + 28150) = a2;
    uint64_t v3 = (pthread_mutex_t *)(this + 560);
    pthread_mutex_lock((pthread_mutex_t *)(this + 560));
    CA::WindowServer::IOMFBDisplay::update_framebuffer_locked(v2, 8);
    return pthread_mutex_unlock(v3);
  }
  return this;
}

uint64_t **X::small_vector_base<void({block_pointer})(__CFDictionary const*)>::small_vector_base(uint64_t **result, uint64_t a2, uint64_t *a3)
{
  CGColorSpace *result = a3;
  result[1] = a3;
  result[2] = a3;
  uint64_t v3 = *(void *)(a2 + 16);
  result[3] = *(uint64_t **)(a2 + 24);
  uint64_t v4 = *(uint64_t **)a2;
  if (*(void *)a2 == v3)
  {
    result[1] = (uint64_t *)((char *)a3 + *(void *)(a2 + 8) - (void)v4);
    uint64_t v6 = *(uint64_t **)(a2 + 8);
    while (v4 != v6)
    {
      uint64_t v7 = *v4++;
      *a3++ = v7;
    }
  }
  else
  {
    uint64_t v5 = *(uint64_t **)(a2 + 8);
    CGColorSpace *result = v4;
    result[1] = v5;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
  }
  return result;
}

void CA::WindowServer::IOMFBDisplay::swap_display_headroom_used(CA::WindowServer::IOMFBDisplay *this, const CA::Render::Update *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if ((*((_WORD *)this + 328) & 0x1C00) == 0)
  {
    int v4 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1840))(this);
    if (a2)
    {
      if (v4)
      {
        int v5 = *((_DWORD *)a2 + 67);
        if ((v5 & 0x200000) == 0)
        {
          uint64_t v6 = (float *)((char *)this + 26184);
          float v7 = 1.0;
          if ((v5 & 0x8000) != 0) {
            float v7 = CA::WindowServer::Display::edr_headroom(this);
          }
          if (*v6 != v7)
          {
            double v8 = v7;
            *uint64_t v6 = v7;
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              uint64_t v9 = x_log_category_brightness;
              if (os_log_type_enabled((os_log_t)x_log_category_brightness, OS_LOG_TYPE_DEFAULT))
              {
                int v10 = *((_DWORD *)this + 6);
                *(_DWORD *)buf = 67109376;
                int v12 = v10;
                __int16 v13 = 2048;
                double v14 = v8;
                _os_log_impl(&dword_184668000, v9, OS_LOG_TYPE_DEFAULT, "Display %u setting display headroom hint to %g", buf, 0x12u);
              }
            }
            if (*((unsigned char *)this + 28209))
            {
              if ((*((unsigned char *)this + 746) & 2) != 0) {
                IOMobileFramebufferSwapSetDisplayEdrHeadroom();
              }
            }
          }
        }
      }
    }
  }
}

void CA::WindowServer::IOMFBDisplay::update_blend_display_color_spaces(CA::WindowServer::IOMFBDisplay *this)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1840))(this)) {
    BOOL v2 = HIBYTE(xmmword_1EB2ACC30) == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2)
  {
    if (initialized != -1) {
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    }
    if (*(float *)&dword_1EB2ACB4C)
    {
      uint64_t v3 = CAGetColorSpace(*(float *)&dword_1EB2ACB4C);
      (*(void (**)(CA::WindowServer::IOMFBDisplay *, uint64_t))(*(void *)this + 1816))(this, v3);
      if (initialized != -1) {
        dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
      }
    }
    if (*(float *)&dword_1EB2ACB50)
    {
      uint64_t v4 = CAGetColorSpace(*(float *)&dword_1EB2ACB50);
      (*(void (**)(CA::WindowServer::IOMFBDisplay *, uint64_t))(*(void *)this + 1832))(this, v4);
    }
    if (*((unsigned char *)this + 28202) || *((unsigned char *)this + 28203))
    {
      int v5 = CA::WindowServer::IOMFBDisplay::color_program_cache(this);
      v5[63] = 1;
      *((_DWORD *)this + 6834) = -1;
      uint64_t v6 = (unsigned int *)((char *)this + 48 * *((unsigned int *)this + 6426) + 25808);
      if (!*v6) {
        CA::IOMobileFramebuffer::swap_begin((CA::WindowServer::IOMFBDisplay *)((char *)this + 25568), v6);
      }
      float v7 = (CGColorSpace *)CAGetColorSpace(0x1Eu);
      double v8 = &CA::callback_timer;
      if (*((unsigned char *)this + 28202))
      {
        uint64_t v9 = (CGColorSpace *)(*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1808))(this);
        if (BYTE8(xmmword_1EB2ACC30))
        {
          uint64_t v14 = CGColorSpaceCopyICCProfileDescription();
          if (v14)
          {
            CFStringRef v15 = (const __CFString *)v14;
            long long v33 = 0u;
            long long v34 = 0u;
            long long v31 = 0u;
            long long v32 = 0u;
            long long v29 = 0u;
            long long v30 = 0u;
            long long v27 = 0u;
            long long v28 = 0u;
            if (x_log_hook_p())
            {
              CA_CFStringGetCString(v15, (char *)&v27, 128);
              x_log_();
            }
            else
            {
              unint64_t v18 = x_log_category_color;
              if (os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_INFO))
              {
                int v19 = *((_DWORD *)this + 6);
                *(_DWORD *)buf = 67109378;
                int v24 = v19;
                __int16 v25 = 2080;
                CString = CA_CFStringGetCString(v15, (char *)&v27, 128);
                _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_INFO, "Display %u setting IOMFB blending colorspace to '%s'", buf, 0x12u);
              }
            }
            CFRelease(v15);
            double v8 = &CA::callback_timer;
          }
        }
        CA::ColorProgram::Cache::set_colorspace((CGColorSpace **)v5, v9);
        int v10 = CA::ColorProgram::Cache::lookup((CGColorSpace **)v5, v7, 0, 0);
        if (v10) {
          CA::WindowServer::IOMFBDisplay::set_icc_matrix_and_trc((uint64_t)this, (uint64_t)v10, 1u, 1u, -1);
        }
        CA::ColorProgram::Cache::set_colorspace((CGColorSpace **)v5, v7);
        uint64_t v11 = CA::ColorProgram::Cache::lookup((CGColorSpace **)v5, v9, 0, 0);
        if (v11) {
          CA::WindowServer::IOMFBDisplay::set_icc_matrix_and_trc((uint64_t)this, (uint64_t)v11, 4u, 0xCu, -1);
        }
        *((unsigned char *)this + 28202) = 0;
      }
      if (*((unsigned char *)this + 28203))
      {
        (*(void (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1824))(this);
        if (*((unsigned char *)v8 + 3128))
        {
          uint64_t v16 = CGColorSpaceCopyICCProfileDescription();
          if (v16)
          {
            CFStringRef v17 = (const __CFString *)v16;
            long long v33 = 0u;
            long long v34 = 0u;
            long long v31 = 0u;
            long long v32 = 0u;
            long long v29 = 0u;
            long long v30 = 0u;
            long long v27 = 0u;
            long long v28 = 0u;
            if (x_log_hook_p())
            {
              CA_CFStringGetCString(v17, (char *)&v27, 128);
              x_log_();
            }
            else
            {
              uint64_t v20 = x_log_category_color;
              if (os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_INFO))
              {
                int v21 = *((_DWORD *)this + 6);
                unint64_t v22 = CA_CFStringGetCString(v17, (char *)&v27, 128);
                *(_DWORD *)buf = 67109378;
                int v24 = v21;
                __int16 v25 = 2080;
                CString = v22;
                _os_log_impl(&dword_184668000, v20, OS_LOG_TYPE_INFO, "Display %u setting IOMFB display colorspace to '%s'", buf, 0x12u);
              }
            }
            CFRelease(v17);
          }
        }
        int v12 = (CGColorSpace *)(*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1824))(this);
        CA::ColorProgram::Cache::set_colorspace((CGColorSpace **)v5, v12);
        __int16 v13 = CA::ColorProgram::Cache::lookup((CGColorSpace **)v5, v7, 0, 0);
        if (v13) {
          CA::WindowServer::IOMFBDisplay::set_icc_matrix_and_trc((uint64_t)this, (uint64_t)v13, 5u, 0xFu, -1);
        }
        *((unsigned char *)this + 28203) = 0;
      }
    }
  }
}

uint64_t CA::OGL::MetalContext::supports_fences(CA::OGL::MetalContext *this)
{
  return 1;
}

unint64_t CA::OGL::MetalContext::set_fence(CA::OGL::MetalContext *this)
{
  unint64_t v2 = *((void *)this + 348) + 1;
  *((void *)this + 348) = v2;
  unint64_t v3 = atomic_load((unint64_t *)this + 503);
  unint64_t v4 = *((void *)this + 344);
  if (v4)
  {
    uint8x8_t v5 = (uint8x8_t)vcnt_s8((int8x8_t)v4);
    v5.i16[0] = vaddlv_u8(v5);
    if (v5.u32[0] > 1uLL)
    {
      unint64_t v6 = v2;
      if (v2 >= v4) {
        unint64_t v6 = v2 % v4;
      }
    }
    else
    {
      unint64_t v6 = (v4 - 1) & v2;
    }
    float v7 = *(void ***)(*((void *)this + 343) + 8 * v6);
    if (v7)
    {
      for (uint64_t i = *v7; i; uint64_t i = (void *)*i)
      {
        unint64_t v9 = i[1];
        if (v9 == v2)
        {
          if (i[2] == v2) {
            goto LABEL_74;
          }
        }
        else
        {
          if (v5.u32[0] > 1uLL)
          {
            if (v9 >= v4) {
              v9 %= v4;
            }
          }
          else
          {
            v9 &= v4 - 1;
          }
          if (v9 != v6) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v6 = 0;
  }
  uint64_t i = operator new(0x20uLL);
  *uint64_t i = 0;
  i[1] = v2;
  i[2] = v2;
  i[3] = 0;
  float v10 = (float)(unint64_t)(*((void *)this + 346) + 1);
  float v11 = *((float *)this + 694);
  if (!v4 || (float)(v11 * (float)v4) < v10)
  {
    BOOL v12 = 1;
    if (v4 >= 3) {
      BOOL v12 = (v4 & (v4 - 1)) != 0;
    }
    unint64_t v13 = v12 | (2 * v4);
    unint64_t v14 = vcvtps_u32_f32(v10 / v11);
    if (v13 <= v14) {
      int8x8_t prime = (int8x8_t)v14;
    }
    else {
      int8x8_t prime = (int8x8_t)v13;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v4 = *((void *)this + 344);
    }
    if (*(void *)&prime > v4) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v4)
    {
      unint64_t v22 = vcvtps_u32_f32((float)*((unint64_t *)this + 346) / *((float *)this + 694));
      if (v4 < 3 || (uint8x8_t v23 = (uint8x8_t)vcnt_s8((int8x8_t)v4), v23.i16[0] = vaddlv_u8(v23), v23.u32[0] > 1uLL))
      {
        unint64_t v22 = std::__next_prime(v22);
      }
      else
      {
        uint64_t v24 = 1 << -(char)__clz(v22 - 1);
        if (v22 >= 2) {
          unint64_t v22 = v24;
        }
      }
      if (*(void *)&prime <= v22) {
        int8x8_t prime = (int8x8_t)v22;
      }
      if (*(void *)&prime >= v4)
      {
        unint64_t v4 = *((void *)this + 344);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v16 = operator new(8 * *(void *)&prime);
          CFStringRef v17 = (void *)*((void *)this + 343);
          *((void *)this + 343) = v16;
          if (v17) {
            operator delete(v17);
          }
          uint64_t v18 = 0;
          *((int8x8_t *)this + 344) = prime;
          do
            *(void *)(*((void *)this + 343) + 8 * v18++) = 0;
          while (*(void *)&prime != v18);
          int v19 = (void *)*((void *)this + 345);
          if (v19)
          {
            unint64_t v20 = v19[1];
            uint8x8_t v21 = (uint8x8_t)vcnt_s8(prime);
            v21.i16[0] = vaddlv_u8(v21);
            if (v21.u32[0] > 1uLL)
            {
              if (v20 >= *(void *)&prime) {
                v20 %= *(void *)&prime;
              }
            }
            else
            {
              v20 &= *(void *)&prime - 1;
            }
            *(void *)(*((void *)this + 343) + 8 * v20) = (char *)this + 2760;
            __int16 v25 = (void *)*v19;
            if (*v19)
            {
              do
              {
                unint64_t v26 = v25[1];
                if (v21.u32[0] > 1uLL)
                {
                  if (v26 >= *(void *)&prime) {
                    v26 %= *(void *)&prime;
                  }
                }
                else
                {
                  v26 &= *(void *)&prime - 1;
                }
                if (v26 != v20)
                {
                  uint64_t v27 = *((void *)this + 343);
                  if (!*(void *)(v27 + 8 * v26))
                  {
                    *(void *)(v27 + 8 * v26) = v19;
                    goto LABEL_55;
                  }
                  void *v19 = *v25;
                  *__int16 v25 = **(void **)(*((void *)this + 343) + 8 * v26);
                  **(void **)(*((void *)this + 343) + 8 * v26) = v25;
                  __int16 v25 = v19;
                }
                unint64_t v26 = v20;
LABEL_55:
                int v19 = v25;
                __int16 v25 = (void *)*v25;
                unint64_t v20 = v26;
              }
              while (v25);
            }
          }
          unint64_t v4 = (unint64_t)prime;
          goto LABEL_59;
        }
        long long v32 = (void *)*((void *)this + 343);
        *((void *)this + 343) = 0;
        if (v32) {
          operator delete(v32);
        }
        unint64_t v4 = 0;
        *((void *)this + 344) = 0;
      }
    }
LABEL_59:
    if ((v4 & (v4 - 1)) != 0)
    {
      if (v2 >= v4) {
        unint64_t v6 = v2 % v4;
      }
      else {
        unint64_t v6 = v2;
      }
    }
    else
    {
      unint64_t v6 = (v4 - 1) & v2;
    }
  }
  uint64_t v28 = *((void *)this + 343);
  long long v29 = *(void **)(v28 + 8 * v6);
  if (v29)
  {
    *uint64_t i = *v29;
LABEL_72:
    *long long v29 = i;
    goto LABEL_73;
  }
  *uint64_t i = *((void *)this + 345);
  *((void *)this + 345) = i;
  *(void *)(v28 + 8 * v6) = (char *)this + 2760;
  if (*i)
  {
    unint64_t v30 = *(void *)(*i + 8);
    if ((v4 & (v4 - 1)) != 0)
    {
      if (v30 >= v4) {
        v30 %= v4;
      }
    }
    else
    {
      v30 &= v4 - 1;
    }
    long long v29 = (void *)(*((void *)this + 343) + 8 * v30);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)this + 346);
LABEL_74:
  i[3] = v3;
  return v2;
}

void sub_18471BBF0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unint64_t CA::Shape::coalesce(CA::Shape *this, int8x16_t *a2, unint64_t a3)
{
  v58[3] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = a3 - 1;
  if (a3 == 1)
  {
LABEL_57:
    CA::Shape::get_bounds((uint64_t)this, a2->i32);
    return 1;
  }
  unint64_t v56 = 0;
  int8x16_t v57 = 0uLL;
  v58[0] = (uint64_t)this;
  v58[1] = 0;
  _DWORD v58[2] = 0;
  if (a3 + 1 > 2) {
    uint64_t v6 = a3 + 1;
  }
  else {
    uint64_t v6 = 2;
  }
  __int16 v54 = a2 + 2;
  unint64_t v55 = a3 - 2;
  __int16 v52 = this;
  uint64_t v53 = -1;
  while ((CA::ShapeIterator::iterate(v58, v57.i32) & 1) != 0)
  {
    if (v56 < a3)
    {
      a2[v56++] = v57;
      ++v53;
      continue;
    }
    unint64_t v9 = 0;
    int8x16_t v10 = 0uLL;
    char v11 = 1;
    v7.f64[0] = INFINITY;
    do
    {
      if (a3)
      {
        BOOL v12 = &a2[1].i8[12];
        unint64_t v13 = 1;
        while (2)
        {
          unint64_t v14 = (int32x2_t *)(v12 - 12);
          if (v13 >= a3) {
            unint64_t v14 = (int32x2_t *)&v57;
          }
          unsigned int v15 = *((_DWORD *)v12 - 6);
          if (v11)
          {
            uint64_t v16 = v12 - 8;
            if (v13 >= a3) {
              uint64_t v16 = &v57.i8[4];
            }
            int v17 = *(_DWORD *)v16;
            if (v15 != v17)
            {
              uint64_t v18 = v13 >= a3 ? (char *)((unint64_t)&v57 | 0xC) : v12;
              if (*((_DWORD *)v12 - 4) + v15 != *(_DWORD *)v18 + v17) {
                goto LABEL_38;
              }
            }
          }
          __int32 v19 = *((_DWORD *)v12 - 7);
          int32x2_t v20 = *(int32x2_t *)(v12 - 20);
          v21.i32[0] = v19;
          v21.i32[1] = *((_DWORD *)v12 - 6);
          v21.u64[1] = (unint64_t)v20;
          unint64_t v22 = (int32x2_t *)(v12 - 4);
          if (v13 >= a3) {
            unint64_t v22 = (int32x2_t *)&v57.u64[1];
          }
          int32x2_t v23 = *v22;
          uint32x2_t v24 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v20);
          unsigned __int32 v25 = vpmax_u32(v24, v24).u32[0];
          uint32x2_t v26 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *v22);
          unsigned __int32 v27 = vpmax_u32(v26, v26).u32[0];
          if ((v25 & 0x80000000) != 0)
          {
            if ((v27 & 0x80000000) == 0)
            {
              *(int32x2_t *)v29.i8 = *v14;
              v29.i32[3] = vextq_s8(*(int8x16_t *)&v21, *(int8x16_t *)&v21, 8uLL).i32[1];
              v29.i32[2] = (__int32)*v22;
              int32x2_t v28 = *v22;
LABEL_28:
              int32x4_t v21 = v29;
              v21.i32[3] = v28.i32[1];
            }
          }
          else if ((v27 & 0x80000000) == 0)
          {
            *(int32x2_t *)v29.i8 = vmin_s32((int32x2_t)__PAIR64__(v15, v19), *v14);
            int32x2_t v28 = vsub_s32(vmax_s32(vadd_s32((int32x2_t)__PAIR64__(v15, v19), v20), vadd_s32(*v14, v23)), *(int32x2_t *)v29.i8);
            v29.i32[3] = vextq_s8(*(int8x16_t *)&v21, *(int8x16_t *)&v21, 8uLL).i32[1];
            v29.i32[2] = v28.i32[0];
            goto LABEL_28;
          }
          __int32 v30 = vmulq_laneq_s32(v21, v21, 3).i32[2];
          if (v13 >= a3) {
            long long v31 = (__int32 *)((unint64_t)&v57 | 0xC);
          }
          else {
            long long v31 = (__int32 *)v12;
          }
          int32x2_t v32 = vdup_lane_s32(v20, 0);
          v32.i32[0] = *v31;
          v23.i32[1] = HIDWORD(*(void *)(v12 - 20));
          int32x2_t v33 = vmul_s32(v32, v23);
          v33.i32[0] = vadd_s32(v33, vdup_lane_s32(v33, 1)).u32[0];
          v8.f64[0] = (double)((v30 - v33.i32[0]) & ~((v30 - v33.i32[0]) >> 31));
          if ((v25 & 0x80000000) == 0)
          {
            uint32x2_t v34 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *v22);
            if ((vpmax_u32(v34, v34).u32[0] & 0x80000000) == 0)
            {
              uint32x2_t v35 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)(v12 - 28), v20), vadd_s32(*v14, *v22)), vmax_s32(*(int32x2_t *)(v12 - 28), *v14)));
              if (vpmax_u32(v35, v35).i32[0] >= 0) {
                v8.f64[0] = 0.0;
              }
            }
          }
          int8x16_t v10 = vbslq_s8((int8x16_t)vdupq_lane_s64(vcgtq_f64(v7, v8).i64[0], 0), (int8x16_t)v21, v10);
          if (v8.f64[0] < v7.f64[0])
          {
            unint64_t v9 = v13 - 1;
            v7.f64[0] = v8.f64[0];
          }
LABEL_38:
          ++v13;
          v12 += 16;
          if (v6 == v13) {
            break;
          }
          continue;
        }
      }
      char v36 = (v7.f64[0] >= INFINITY) & v11;
      char v11 = 0;
    }
    while ((v36 & 1) != 0);
    a2[v9] = v10;
    if (v9 != v4)
    {
      if (v9 + 2 < a3)
      {
        unint64_t v37 = v55 - v9;
        i8 = v54[v9].i8;
        do
        {
          *((_OWORD *)i8 - 1) = *(_OWORD *)i8;
          i8 += 16;
          --v37;
        }
        while (v37);
      }
      a2[v4] = v57;
    }
  }
  unint64_t result = v56;
  if (v56)
  {
    uint64_t v40 = 0;
    int v41 = (int32x2_t *)&a2[1].u64[1];
    for (uint64_t i = v53; ; --i)
    {
      uint64_t v43 = v40 + 1;
      if (v40 + 1 < v56) {
        break;
      }
LABEL_54:
      v41 += 2;
      uint64_t v40 = v43;
      if (v43 == v56) {
        return result;
      }
    }
    int v44 = (int32x2_t *)&a2[v40];
    int32x2_t v45 = v44[1];
    uint32x2_t v46 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v45);
    unsigned __int32 v47 = vpmax_u32(v46, v46).u32[0];
    uint64_t v48 = i;
    int v49 = v41;
    while (1)
    {
      if ((v47 & 0x80000000) == 0)
      {
        uint32x2_t v50 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *v49);
        if ((vpmax_u32(v50, v50).u32[0] & 0x80000000) == 0)
        {
          uint32x2_t v51 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(vadd_s32(*v44, v45), vadd_s32(v49[-1], *v49)), vmax_s32(*v44, v49[-1])));
          if ((vpmax_u32(v51, v51).u32[0] & 0x80000000) == 0) {
            break;
          }
        }
      }
      v49 += 2;
      if (!--v48) {
        goto LABEL_54;
      }
    }
    this = v52;
    goto LABEL_57;
  }
  return result;
}

BOOL CA::Shape::rect_count(CA::Shape *this)
{
  if (this) {
    return this != (CA::Shape *)1;
  }
  int v1 = *((_DWORD *)this + 1);
  if (v1 == 6) {
    return 0;
  }
  if (v1 == 12) {
    return 1;
  }
  int v4 = *((_DWORD *)this + 3);
  unint64_t v3 = (_DWORD *)((char *)this + 12);
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  LODWORD(v2) = 0;
  do
  {
    uint64_t v5 = (int)v3[1];
    uint64_t v2 = (v2 + (((int)v5 - 2) >> 1));
    v3 += v5;
  }
  while (*v3 != 0x7FFFFFFF);
  return v2;
}

uint64_t CA::WindowServer::AppleDisplay::subpixel_layout(CA::WindowServer::AppleDisplay *this)
{
  return *((unsigned int *)this + 7134);
}

uint64_t CA::Render::Layer::set_mesh_transform(uint64_t this, os_unfair_lock_s *a2)
{
  uint64_t v2 = (CA::Render::Layer *)this;
  if (a2 && (unint64_t v3 = a2, this = CA::Render::MeshTransform::validate(a2), (this & 1) != 0))
  {
    char v4 = 0;
  }
  else
  {
    if (!*((void *)v2 + 16)) {
      return this;
    }
    unint64_t v3 = 0;
    char v4 = 1;
  }
  uint64_t v5 = CA::Render::Layer::ensure_ext(v2);
  this = v5[14];
  if ((os_unfair_lock_s *)this != v3)
  {
    if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
      this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
    }
    if (v4)
    {
      unint64_t v3 = 0;
    }
    else
    {
      uint64_t v6 = (atomic_uint *)&v3[2];
      if (!atomic_fetch_add((atomic_uint *volatile)&v3[2], 1u))
      {
        unint64_t v3 = 0;
        atomic_fetch_add(v6, 0xFFFFFFFF);
      }
    }
    v5[14] = v3;
  }
  return this;
}

uint64_t CA::Render::MeshTransform::validate(os_unfair_lock_s *this)
{
  uint32_t os_unfair_lock_opaque = this[3]._os_unfair_lock_opaque;
  if ((os_unfair_lock_opaque & 0x2000) != 0) {
    return (os_unfair_lock_opaque >> 12) & 1;
  }
  unint64_t v3 = this + 4;
  os_unfair_lock_lock(this + 4);
  uint64_t v4 = CA::Render::MeshTransform::validate_locked((CA::Render::MeshTransform *)this);
  os_unfair_lock_unlock(v3);
  return v4;
}

uint64_t CA::Render::HitTestTree::hit_test(uint64_t a1, int *a2, const char *a3, unsigned char *a4, CGFloat a5, CGFloat a6)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (byte_1EB2ACC2F)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      unint64_t v14 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218240;
        CGFloat v18 = a5;
        __int16 v19 = 2048;
        CGFloat v20 = a6;
        _os_log_impl(&dword_184668000, v14, OS_LOG_TYPE_DEFAULT, "HitTest: start at: (%g, %g)", buf, 0x16u);
      }
    }
  }
  uint64_t v12 = CA::Render::HitTestTree::hit_test_node(a1, *(void *)(a1 + 16), a2, a3, a4, a5, a6);
  if (byte_1EB2ACC2F)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      unsigned int v15 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        double v16 = *(double *)(v12 + 16);
        *(_DWORD *)buf = 134217984;
        CGFloat v18 = v16;
        _os_log_impl(&dword_184668000, v15, OS_LOG_TYPE_DEFAULT, "HitTest: end - layer %p", buf, 0xCu);
      }
    }
  }
  return v12;
}

uint64_t CA::Render::HitTestTree::hit_test_node(uint64_t a1, uint64_t a2, int *a3, const char *a4, unsigned char *a5, CGFloat a6, CGFloat a7)
{
  uint64_t v12 = a2;
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  v68.double x = a6;
  v68.double y = a7;
  uint64_t v14 = *(void *)(a2 + 16);
  CA::Render::print_hit_test((CA::Render *)v14, (const CA::Render::Layer *)"entering", 0, a4);
  unint64_t v17 = *(void *)(v12 + 8);
  if ((v17 & 0x10000000000) != 0)
  {
    unsigned __int32 v25 = "culled/disallows hit testing";
    goto LABEL_110;
  }
  int v18 = *(_DWORD *)(v12 + 24);
  if (v18) {
    BOOL v19 = a4 == 0;
  }
  else {
    BOOL v19 = 1;
  }
  if (!v19)
  {
    CGFloat v20 = a4;
    uint64_t v21 = a3;
    while (1)
    {
      int v22 = *v21++;
      if (v18 == v22) {
        break;
      }
      if (!--v20) {
        goto LABEL_9;
      }
    }
    unsigned __int32 v25 = "rejected context ID";
    goto LABEL_110;
  }
LABEL_9:
  CGSize v23 = *(CGSize *)(v12 + 64);
  v67.origiunint64_t n = (CGPoint)*MEMORY[0x1E4F1DAD8];
  v67.size = v23;
  if ((v17 & 0x8000000000000) != 0)
  {
    CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)&buf, (CA::Mat4Impl *)(v12 + 80), v15);
    CA::Mat4Impl::mat4_unapply_inverse_to_point2((float64x2_t *)&buf, &v68.x, v26);
    unsigned int v24 = 16;
  }
  else if ((v17 & 0x10000000000000) != 0)
  {
    CGFloat v27 = a7 - *(double *)(v12 + 88);
    v68.double x = a6 - *(double *)(v12 + 80);
    v68.double y = v27;
    unsigned int v24 = 2;
  }
  else
  {
    unsigned int v24 = 0;
  }
  double v28 = 0.0;
  if ((v17 & 0x20000000000000) != 0)
  {
    uint64_t v30 = v12 + 8 * v24;
    v24 |= 1u;
    double v29 = *(double *)(v30 + 80);
    if ((v17 & 0x40000000000000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  double v29 = 0.0;
  if ((v17 & 0x40000000000000) != 0)
  {
LABEL_20:
    uint64_t v31 = v12 + 8 * v24++;
    double v28 = *(double *)(v31 + 80);
  }
LABEL_21:
  double v32 = 0.0;
  if ((v17 & 0x80000000000000) != 0)
  {
    uint64_t v33 = v12 + 8 * v24++;
    double v32 = *(double *)(v33 + 80);
    if ((v17 & 0x100000000000000) == 0)
    {
LABEL_23:
      if ((v17 & 0x20000000000) == 0) {
        goto LABEL_28;
      }
      goto LABEL_27;
    }
  }
  else if ((v17 & 0x100000000000000) == 0)
  {
    goto LABEL_23;
  }
  v67.origiunint64_t n = *(CGPoint *)(v12 + 8 * v24 + 80);
  if ((v17 & 0x20000000000) == 0) {
    goto LABEL_28;
  }
LABEL_27:
  if ((CA_CGRoundRectContainsPoint(&v67.origin.x, v32, v68.x, v68.y) & 1) == 0)
  {
    unsigned __int32 v25 = "masksToBounds = YES and not in bounds";
    goto LABEL_110;
  }
LABEL_28:
  uint64_t v34 = v12 + BYTE4(v17);
  if ((v17 & 0x800000000000) != 0)
  {
    uint32x2_t v35 = (CA::Render *)CA::Render::HitTestTree::hit_test_node(a1, v12 + BYTE4(v17), a3, a4, a5, v68.x, v68.y);
    if (v14)
    {
      if ((v35 == 0) != *(unsigned __int8 *)(v14 + 40) >> 7)
      {
        if (byte_1EB2ACC2F)
        {
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            __int16 v62 = x_log_category_render;
            if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
            {
              CGFloat v63 = *(double *)(v14 + 120);
              if (v63 != 0.0)
              {
                int v64 = *(_DWORD *)(*(void *)&v63 + 24);
                *(void *)&v63 += 28;
                if (!v64) {
                  CGFloat v63 = 0.0;
                }
              }
              LODWORD(buf.origin.x) = 136316162;
              *(void *)((char *)&buf.origin.x + 4) = "rejecting";
              WORD2(buf.origin.y) = 2048;
              *(void *)((char *)&buf.origin.y + 6) = v14;
              HIWORD(buf.size.width) = 2080;
              buf.size.double height = v63;
              __int16 v70 = 2080;
              int v71 = " - ";
              __int16 v72 = 2080;
              int v73 = "mask not hit";
              _os_log_impl(&dword_184668000, v62, OS_LOG_TYPE_DEFAULT, "HitTest: %s layer %p \"%s\"%s%s", (uint8_t *)&buf, 0x34u);
            }
          }
        }
        return 0;
      }
    }
    else if (!v35)
    {
      unsigned __int32 v25 = "mask not hit";
LABEL_111:
      CA::Render::print_hit_test(v35, (const CA::Render::Layer *)"rejecting", v25, v16);
      return 0;
    }
    v34 += *(unsigned int *)(v34 + 4);
    unint64_t v17 = *(void *)(v12 + 8);
  }
  if ((v17 & 0xFFFFFF) == 0)
  {
LABEL_41:
    if ((v17 & 0x80000000000) != 0)
    {
      double v39 = v67.size.height + v67.origin.y;
      if (v67.size.width + v67.origin.x > v67.origin.x && v39 > v67.origin.y)
      {
        BOOL v41 = v68.x >= v67.origin.x && v68.x < v67.size.width + v67.origin.x;
        BOOL v42 = !v41 || v68.y < v67.origin.y;
        if (!v42 && v68.y < v39)
        {
          int v44 = "hitTestsAsOpaque = YES and in bounds";
          goto LABEL_108;
        }
      }
    }
    if ((v17 & 0x200000000000) == 0)
    {
      if ((v17 & 0x1000000000000) != 0 && CA_CGRoundRectContainsPoint(&v67.origin.x, v32, v68.x, v68.y))
      {
        int v44 = "within background color";
LABEL_108:
        CA::Render::print_hit_test((CA::Render *)v14, (const CA::Render::Layer *)"accepting", v44, v16);
        return v12;
      }
      if (v29 != 0.0)
      {
        CGRect buf = CGRectInset(v67, -v28, -v28);
        CGRect v66 = CGRectInset(buf, v29, v29);
        if (v32 + v28 >= 0.0) {
          double v46 = v32 + v28;
        }
        else {
          double v46 = 0.0;
        }
        double y = v68.y;
        double x = v68.x;
        if (CA_CGRoundRectContainsPoint(&buf.origin.x, v46, v68.x, v68.y))
        {
          double v48 = v46 - v29;
          if (v46 - v29 < 0.0) {
            double v48 = 0.0;
          }
          if (!CA_CGRoundRectContainsPoint(&v66.origin.x, v48, x, y))
          {
            int v44 = "within border";
            goto LABEL_108;
          }
        }
        unint64_t v17 = *(void *)(v12 + 8);
      }
      if ((v17 & 0x2000000000000) != 0)
      {
        if ((v17 & 0x4000000000000) == 0)
        {
          if (!CA::Render::hit_test_contents(v14, *(void *)(v14 + 96), (v17 >> 44) & 1, v68.x, v68.y)) {
            goto LABEL_92;
          }
LABEL_90:
          int v44 = "within contents";
          goto LABEL_108;
        }
        double v49 = v67.size.height + v67.origin.y;
        BOOL v50 = v67.size.width + v67.origin.x <= v67.origin.x || v49 <= v67.origin.y;
        if (!v50 && v68.x >= v67.origin.x)
        {
          BOOL v51 = v68.x >= v67.size.width + v67.origin.x || v68.y < v67.origin.y;
          if (!v51 && v68.y < v49) {
            goto LABEL_90;
          }
        }
      }
      if (!v14)
      {
LABEL_109:
        unsigned __int32 v25 = "no hits";
        goto LABEL_110;
      }
LABEL_92:
      uint64_t v53 = *(CA::Render::LayerHost ***)(v14 + 128);
      if (v53)
      {
        __int16 v54 = *v53;
        if (*v53)
        {
          if (*((unsigned char *)v54 + 12) == 30)
          {
            uint64_t v55 = CA::Render::LayerHost::retain_async_hit_test_tree(v54);
            if (v55)
            {
              unint64_t v56 = (CA::Render::HitTestTree *)v55;
              int8x16_t v57 = *(uint64_t **)(v55 + 40);
              if (v57)
              {
                uint64_t v58 = a1 + 24;
                do
                {
                  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(v58, *((_DWORD *)v57 + 4), *((_DWORD *)v57 + 4));
                  int8x16_t v57 = (uint64_t *)*v57;
                }
                while (v57);
              }
              int v59 = (unsigned int *)CA::Render::HitTestTree::hit_test(v56, a3, a4, a5, v68.x, v68.y);
              if (v59)
              {
                *a5 = 1;
                do
                {
                  LODWORD(v60) = v59[6];
                  if (v60) {
                    break;
                  }
                  uint64_t v60 = *v59;
                  int v59 = (unsigned int *)((char *)v59 - v60);
                }
                while (v60);
                *(_DWORD *)(v12 + 24) = v60;
                CA::Render::HitTestTree::unref(v56);
                return v12;
              }
              CA::Render::HitTestTree::unref(v56);
            }
          }
          buf.origiunint64_t n = v68;
          if ((*(unsigned int (**)(CA::Render::LayerHost *, uint64_t, CGRect *))(*(void *)v54 + 224))(v54, v14, &buf))
          {
            int v44 = "subclass";
            goto LABEL_108;
          }
        }
      }
      goto LABEL_109;
    }
    unsigned __int32 v25 = "culled above";
LABEL_110:
    uint32x2_t v35 = (CA::Render *)v14;
    goto LABEL_111;
  }
  unsigned int v36 = 0;
  CGPoint v37 = v68;
  while (1)
  {
    uint64_t v38 = CA::Render::HitTestTree::hit_test_node(a1, v34, a3, a4, a5, v37.x, v37.y);
    if (v38) {
      break;
    }
    v34 += *(unsigned int *)(v34 + 4);
    ++v36;
    unint64_t v17 = *(void *)(v12 + 8);
    if (v36 >= (*(_DWORD *)(v12 + 8) & 0xFFFFFFu)) {
      goto LABEL_41;
    }
  }
  uint64_t v45 = v38;
  CA::Render::print_hit_test((CA::Render *)v14, (const CA::Render::Layer *)"accepting", "hit sublayer", v16);
  return v45;
}

void CA::Render::print_hit_test(CA::Render *this, const CA::Render::Layer *a2, const char *a3, const char *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (byte_1EB2ACC2F)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      float64x2_t v7 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        float64x2_t v8 = "";
        if (this)
        {
          unint64_t v9 = (const char *)*((void *)this + 15);
          if (v9)
          {
            int v10 = *((_DWORD *)v9 + 6);
            v9 += 28;
            if (!v10) {
              unint64_t v9 = 0;
            }
          }
        }
        else
        {
          unint64_t v9 = "";
        }
        char v11 = " - ";
        *(_DWORD *)CGRect buf = 136316162;
        if (!a3) {
          char v11 = "";
        }
        unint64_t v13 = a2;
        if (a3) {
          float64x2_t v8 = a3;
        }
        __int16 v14 = 2048;
        unsigned int v15 = this;
        __int16 v16 = 2080;
        unint64_t v17 = v9;
        __int16 v18 = 2080;
        BOOL v19 = v11;
        __int16 v20 = 2080;
        uint64_t v21 = v8;
        _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_DEFAULT, "HitTest: %s layer %p \"%s\"%s%s", buf, 0x34u);
      }
    }
  }
}

uint64_t CA_CGRoundRectContainsPoint(double *a1, double a2, double a3, double a4)
{
  double v4 = *a1;
  double v5 = a1[1];
  double v6 = a1[2] + *a1;
  double v7 = a1[3] + v5;
  BOOL v8 = v6 <= *a1 || v7 <= v5;
  if (v8) {
    return 0;
  }
  BOOL v9 = v4 <= a3 && v6 > a3;
  BOOL v10 = v9 && v5 <= a4;
  if (!v10 || v7 <= a4) {
    return 0;
  }
  if (a2 <= 0.0) {
    return 1;
  }
  double v13 = a2 * a2;
  double v14 = v4 + a2 - a3;
  double v15 = v5 + a2 - a4;
  if (v14 > 0.0 && v15 > 0.0 && v14 * v14 + v15 * v15 > v13) {
    return 0;
  }
  if (((double v16 = a2 - v6 + a3, v16 <= 0.0) || v15 <= 0.0 || v16 * v16 + v15 * v15 <= v13)
    && ((double v17 = a2 - v7 + a4, v16 <= 0.0) || v17 <= 0.0 || v16 * v16 + v17 * v17 <= v13)
    && (v14 <= 0.0 || ((BOOL v8 = v17 <= 0.0, v18 = v14 * v14 + v17 * v17, !v8) ? (v19 = v18 <= v13) : (v19 = 1), v19)))
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t CA::Render::hit_test_contents(uint64_t a1, uint64_t a2, int a3, double a4, double a5)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 80))(a2);
  if (v10) {
    goto LABEL_2;
  }
  if (*(unsigned char *)(a2 + 12) != 26) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a2 + 32) + 80))(*(void *)(a2 + 32));
  uint64_t v10 = result;
  if (result)
  {
LABEL_2:
    *(void *)int v44 = 0;
    if ((*(unsigned char *)(v10 + 13) & 0x64) != 0)
    {
      CA::Render::Texture::displayed_size_(v10, &v44[1], v44);
    }
    else
    {
      unsigned int v14 = *(_DWORD *)(v10 + 16);
      v44[0] = *(_DWORD *)(v10 + 20);
      v44[1] = v14;
    }
    double v15 = (unsigned int *)(a2 + 32);
    double v16 = v44;
    if (*(unsigned char *)(a2 + 12) == 50) {
      double v16 = (unsigned int *)(a2 + 36);
    }
    else {
      double v15 = &v44[1];
    }
    LODWORD(v11) = *v15;
    LODWORD(v12) = *v16;
    double v17 = (double)v11;
    double v18 = (double)v12;
    double v40 = 0.0;
    double v41 = 0.0;
    double v42 = v17;
    double v43 = (double)v12;
    uint64_t v19 = *(void *)(a1 + 128);
    if (v19)
    {
      LODWORD(v12) = *(_DWORD *)(v19 + 284);
    }
    else
    {
      LOBYTE(v12) = *(unsigned char *)(a1 + 34);
      *(float *)&unint64_t v12 = (float)v12;
    }
    if (*(float *)&v12 != 1.0)
    {
      if (*(float *)&v12 != 0.0)
      {
        double v23 = *(float *)&v12;
        double v17 = v17 / v23;
        double v18 = v18 / v23;
        double v42 = v17;
        double v43 = v18;
        if (!v19) {
          goto LABEL_20;
        }
        goto LABEL_18;
      }
      double v42 = 0.0;
      double v43 = 0.0;
      double v18 = 0.0;
      double v17 = 0.0;
    }
    if (!v19) {
      goto LABEL_20;
    }
LABEL_18:
    __int16 v20 = *(double **)(v19 + 40);
    if (v20)
    {
      double v17 = (v20[5] - v20[3]) * v17;
      double v18 = (v20[6] - v20[4]) * v18;
      double v42 = v17;
      double v43 = v18;
    }
LABEL_20:
    v39.f64[0] = v17;
    v39.f64[1] = v18;
    if ((*(_DWORD *)(a1 + 36) & 0xF000) == 0x9000
      && *(double *)(a1 + 64) == 0.0
      && *(double *)(a1 + 72) == 0.0
      && (!v19 || !*(void *)(v19 + 32))
      && *(double *)(a1 + 80) == v17
      && *(double *)(a1 + 88) == v18)
    {
      double v21 = 0.0;
    }
    else
    {
      CA::Render::Layer::apply_contents_transform(a1, (uint64_t)&v40, &v39, 0);
      double v21 = v40;
    }
    if (v21 <= a4 && v42 + v21 > a4 && v41 <= a5 && v43 + v41 > a5)
    {
      uint64_t v22 = *(void *)(a1 + 40);
      if ((v22 & 0x100000000) == 0) {
        return 1;
      }
      if ((v22 & 0x20000) != 0) {
        return 1;
      }
      if ((*(_DWORD *)(v10 + 12) & 0x1000) != 0) {
        return 1;
      }
      v45[0] = xmmword_184997D50;
      v45[1] = 0u;
      v45[2] = xmmword_184997D60;
      memset(&v45[3], 0, 32);
      v45[5] = xmmword_184997D50;
      v45[6] = 0u;
      v45[7] = xmmword_184997D60;
      __asm { FMOV            V0.2D, #1.0 }
      v45[8] = _Q0;
      char v46 = 0;
      if (!CA::Render::Layer::append_texture_transform((CA::Render::Layer *)a1, (CA::Transform *)v45, (CA::Render::Texture *)v10, (CA::Render::Object *)a2))return 1; {
      double v37 = a4;
      }
      double v38 = a5;
      if ((v46 & 0x10) != 0)
      {
        CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)v36, (CA::Mat4Impl *)v45, v29);
        CA::Mat4Impl::mat4_unapply_inverse_to_point2(v36, &v37, v30);
      }
      else
      {
        CA::Transform::unapply_simple<double>((uint64_t)v45, &v37, &v38);
      }
      unsigned int v31 = *(_DWORD *)(v10 + 20);
      if (a3) {
        double v38 = -1.0 - v38 + (double)v31;
      }
      double v32 = v37;
      if (*(unsigned char *)(a2 + 12) == 50)
      {
        int v34 = *(_DWORD *)(a2 + 24);
        int v33 = *(_DWORD *)(a2 + 28);
        int v35 = *(_DWORD *)(a2 + 32);
        unsigned int v31 = *(_DWORD *)(a2 + 36);
        double v32 = v37 + (double)v34;
        double v38 = v38 + (double)v33;
      }
      else
      {
        int v34 = 0;
        int v33 = 0;
        int v35 = *(_DWORD *)(v10 + 16);
      }
      if (v32 >= (double)v34
        && v32 < (double)(v35 + v34)
        && v38 >= (double)v33
        && v38 < (double)(int)(v31 + v33)
        && (*(float (**)(uint64_t, void, void))(*(void *)v10 + 248))(v10, (int)v32, (int)v38) > 0.0)
      {
        return 1;
      }
    }
    return 0;
  }
  return result;
}

uint64_t CA::Render::BackdropLayer::hit_test(unsigned char *a1, uint64_t a2, double *a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if ((a1[13] & 0x10) == 0)
  {
    long long v6 = 0u;
    *(_OWORD *)double v7 = 0u;
    uint64_t result = (*(uint64_t (**)(unsigned char *, uint64_t, long long *, void))(*(void *)a1 + 184))(a1, a2, &v6, 0);
    if (!result) {
      return result;
    }
    if (*(double *)&v6 <= *a3 && v7[0] + *(double *)&v6 > *a3)
    {
      double v5 = a3[1];
      if (*((double *)&v6 + 1) <= v5) {
        return v7[1] + *((double *)&v6 + 1) > v5;
      }
    }
  }
  return 0;
}

void CA::OGL::fill_surface_mesh(uint64_t a1, os_unfair_lock_s *this, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, int a7, double a8, float a9)
{
  v135[7] = *MEMORY[0x1E4F143B8];
  if ((this[25]._os_unfair_lock_opaque & 0x80000000) != 0) {
    int os_unfair_lock_opaque = 3;
  }
  else {
    int os_unfair_lock_opaque = this[25]._os_unfair_lock_opaque;
  }
  double v17 = CA::Render::MeshTransform::retain_subdivided_mesh(this, os_unfair_lock_opaque);
  if (v17)
  {
    double v18 = v17;
    if (*(double *)&v17[42]._os_unfair_lock_opaque == *(double *)&v17[48]._os_unfair_lock_opaque)
    {
      uint64_t v19 = *(void *)(a1 + 248);
      os_unfair_lock_lock(v17 + 4);
      BOOL v20 = 1;
      CA::Render::MeshTransform::update_locked((CA::Render::MeshTransform *)v18, 1);
      os_unfair_lock_unlock(v18 + 4);
      uint64_t v125 = v19;
      uint64_t v21 = *(void *)(v19 + 32);
      if (v21 == 0x3C003C003C003C00) {
        char v22 = 1;
      }
      else {
        char v22 = 3;
      }
      *(unsigned char *)(*(void *)(a1 + 16) + 16) = v22;
      CA::OGL::Context::bind_surface(a1, a4, 0, a5, a6, a9);
      if ((*(_WORD *)(a4 + 75) & 0x800) != 0) {
        BOOL v20 = LOBYTE(v18[27]._os_unfair_lock_opaque) == 0;
      }
      uint64_t v23 = *(void *)(a1 + 16);
      unsigned int v24 = *(unsigned __int8 *)(v23 + 480);
      if (v24 >= 2 && (v24 != 3 || v20)) {
        *(unsigned char *)(v23 + 481) |= 1u;
      }
      float v132 = 0.0;
      uint64_t v131 = 0;
      float v130 = 0.0;
      float32x2_t v129 = 0;
      CA::Render::MeshTransform::vertex_transform(v18[24]._os_unfair_lock_opaque, (float64x2_t *)a3, (uint64_t)&v131, &v129);
      uint64_t v134 = 0;
      uint64_t v26 = *(void *)(v19 + 24);
      float64x2_t v27 = *(float64x2_t *)(v26 + 16);
      float64x2_t v28 = *(float64x2_t *)(v26 + 32);
      float64x2_t v29 = *(float64x2_t *)(v26 + 48);
      v133[0] = *(float64x2_t *)v26;
      v133[1] = v27;
      v133[2] = v28;
      v133[3] = v29;
      float64x2_t v30 = *(float64x2_t *)(v26 + 80);
      float64x2_t v31 = *(float64x2_t *)(v26 + 96);
      float64x2_t v32 = *(float64x2_t *)(v26 + 112);
      v133[4] = *(float64x2_t *)(v26 + 64);
      v133[5] = v30;
      v133[6] = v31;
      v133[7] = v32;
      v133[8] = *(float64x2_t *)(v26 + 128);
      LOBYTE(v134) = *(unsigned char *)(v26 + 144) & 0x1F;
      float64x2_t v33 = CA::Transform::translate((CA::Transform *)v133, v129.f32[0], v129.f32[1], v130);
      v33.f64[0] = *(float *)&v131;
      CA::Transform::scale(v133, v33, *((float *)&v131 + 1), v132);
      *(void *)(a1 + 816) = v133;
      ++*(_DWORD *)(a1 + 256);
      int v35 = *(float32x4_t **)(a1 + 16);
      v36.i64[0] = v131;
      int32x2_t v37 = *(int32x2_t *)(a4 + 32);
      *(float32x2_t *)v38.i8 = vsub_f32(v129, vcvt_f32_s32(v37));
      v38.i32[2] = LODWORD(a8);
      float32x4_t v39 = v35[6];
      v38.i32[3] = LODWORD(a8);
      v36.i64[1] = v35[6].i64[0];
      float32x4_t v40 = vmulq_f32(v36, (float32x4_t)vextq_s8(v38, v38, 8uLL));
      v38.i64[0] = vmulq_f32(v40, v39).u64[0];
      v38.i64[1] = vaddq_f32(v40, v39).i64[1];
      v35[6] = (float32x4_t)v38;
      if (a7)
      {
        double v41 = *(const CA::Transform **)(v19 + 24);
        long long v42 = *(_OWORD *)(a3 + 16);
        *(_OWORD *)unsigned int v135 = *(_OWORD *)a3;
        *(_OWORD *)&v135[2] = v42;
        CA::Rect::apply_transform((int8x16_t *)v135, v41, v34);
        if (*(float *)&a8 != 1.0)
        {
          double v43 = *(float *)&a8;
          if (*(double *)&v135[2] < 1.79769313e308)
          {
            *(double *)unsigned int v135 = *(double *)v135 * v43;
            *(double *)&v135[2] = *(double *)&v135[2] * v43;
          }
          if (*(double *)&v135[3] < 1.79769313e308)
          {
            *(double *)&v135[1] = *(double *)&v135[1] * v43;
            *(double *)&v135[3] = *(double *)&v135[3] * v43;
          }
        }
        v44.i64[0] = v37.i32[0];
        v44.i64[1] = v37.i32[1];
        float64x2_t v45 = vsubq_f64(*(float64x2_t *)v135, vcvtq_f64_s64(v44));
        uint64_t v46 = *(void *)(a4 + 24);
        v44.i64[0] = (int)v46;
        v44.i64[1] = SHIDWORD(v46);
        float64x2_t v47 = vcvtq_f64_s64(v44);
        v35[6] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(*(float64x2_t *)&v135[2], v47)), vdivq_f64(v45, v47));
      }
      if (LOBYTE(v18[27]._os_unfair_lock_opaque))
      {
        uint64_t v48 = *(void *)(a4 + 40);
        v49.i64[0] = (int)v48;
        v49.i64[1] = SHIDWORD(v48);
        __asm { FMOV            V1.2D, #-0.5 }
        float64x2_t v54 = vaddq_f64(vcvtq_f64_s64(v49), _Q1);
        _Q1.f64[0] = *(float64_t *)(a4 + 24);
        v49.i64[0] = SLODWORD(_Q1.f64[0]);
        v49.i64[1] = SHIDWORD(_Q1.f64[0]);
        float64x2_t v55 = vcvtq_f64_s64(v49);
        __asm { FMOV            V2.2D, #0.5 }
        v35[1].i8[3] = 5;
        *(float32x4_t *)(*(void *)(a1 + 16) + 368) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(_Q2, v55)), vdivq_f64(v54, v55));
      }
      uint64_t v124 = a4;
      uint64_t v57 = *(void *)(*(void *)(a1 + 248) + 8);
      v135[0] = a1;
      v135[1] = v57;
      memset(&v135[2], 0, 40);
      LOWORD(v135[4]) = 256;
      CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v135);
      v128[0] = 0;
      v128[1] = 0;
LABEL_27:
      while (CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v135, v128))
      {
        uint64_t v58 = *(void *)&v18[12]._os_unfair_lock_opaque;
        if (*(void *)&v18[14]._os_unfair_lock_opaque != v58)
        {
          uint64_t v59 = 0;
          unint64_t v60 = 0;
          while (1)
          {
            int v61 = (unsigned int *)(v58 + v59);
            uint64_t v62 = *(void *)&v18[6]._os_unfair_lock_opaque;
            uint64_t v64 = *v61;
            uint64_t v63 = v61[1];
            int v65 = (float *)(v62 + 32 * v64);
            CGRect v66 = (float *)(v62 + 32 * v63);
            uint64_t v67 = v61[2];
            uint64_t v68 = v61[3];
            int v69 = (float *)(v62 + 32 * v67);
            __int16 v70 = (float *)(v62 + 32 * v68);
            float v72 = *v65;
            float v71 = v65[1];
            float v74 = *v66;
            float v73 = v66[1];
            float v75 = *v69;
            float v76 = v69[1];
            float v77 = *v70;
            float v78 = v70[1];
            uint64_t v79 = 6;
            if (!*(_DWORD *)(a1 + 92)) {
              uint64_t v79 = 4;
            }
            uint64_t v80 = *(void *)(a1 + 128);
            if ((unint64_t)(v80 + 4) > *(void *)(a1 + 136)
              || (unint64_t v81 = *(void *)(a1 + 112)) != 0 && *(void *)(a1 + 104) + v79 > v81)
            {
              *(_WORD *)(a1 + 832) |= 0x20u;
              CA::OGL::Context::array_flush(a1);
              uint64_t v80 = 0;
              *(void *)(a1 + 96) = a1 + 834;
              *(_OWORD *)(a1 + 104) = xmmword_184997E70;
            }
            uint64_t v82 = v62 + 32 * v64;
            uint64_t v84 = *(void *)(v82 + 16);
            __int16 v83 = (_OWORD *)(v82 + 16);
            *(void *)&long long v85 = v84;
            uint64_t v86 = (float32x2_t *)(v62 + 32 * v63);
            float32x2_t v88 = v86[2];
            int v87 = v86 + 2;
            float32x2_t v89 = v88;
            int v90 = (float32x2_t *)(v62 + 32 * v67);
            float32x2_t v92 = v90[2];
            uint64_t v91 = v90 + 2;
            float32x2_t v93 = v92;
            __int16 v94 = (float32x2_t *)(v62 + 32 * v68);
            float32x2_t v96 = v94[2];
            uint64_t v95 = v94 + 2;
            float32x2_t v97 = v96;
            float32x2_t v98 = vsub_f32(vadd_f32(*(float32x2_t *)&v85, v93), vadd_f32(v89, v96));
            if (fabsf(v98.f32[0]) >= 0.000001 || fabsf(v98.f32[1]) >= 0.000001)
            {
              float32x2_t v103 = (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(v97, v93));
              float32x2_t v104 = vsub_f32(v89, v93);
              float32x2_t v105 = vmul_f32(v103, v104);
              float32x2_t v106 = vmul_f32(v98, v103);
              v105.f32[0] = 1.0 / vsub_f32(v105, (float32x2_t)vdup_lane_s32((int32x2_t)v105, 1)).f32[0];
              float32x2_t v107 = vmul_f32(v104, (float32x2_t)vrev64_s32((int32x2_t)v98));
              v107.f32[0] = v105.f32[0] * vsub_f32(v107, (float32x2_t)vdup_lane_s32((int32x2_t)v107, 1)).f32[0];
              v104.f32[0] = vmlas_n_f32(1.0, v105.f32[0], vsub_f32(v106, (float32x2_t)vdup_lane_s32((int32x2_t)v106, 1)).f32[0]);
              DWORD2(v85) = *(_DWORD *)(v62 + 32 * v64 + 24);
              HIDWORD(v85) = 1.0;
              *(float32x2_t *)&long long v108 = vmul_n_f32(v89, v104.f32[0]);
              *((float *)&v108 + 2) = *(float *)(v62 + 32 * v63 + 24) * v104.f32[0];
              HIDWORD(v108) = v104.i32[0];
              *(float32x2_t *)&long long v109 = vmul_n_f32(v93, v104.f32[0] + v107.f32[0]);
              *((float *)&v109 + 2) = *(float *)(v62 + 32 * v67 + 24) * (float)(v104.f32[0] + v107.f32[0]);
              *((float *)&v109 + 3) = v104.f32[0] + v107.f32[0];
              v107.f32[0] = v107.f32[0] + 1.0;
              *(float32x2_t *)&long long v110 = vmul_n_f32(v97, v107.f32[0]);
              *((float *)&v110 + 2) = *(float *)(v62 + 32 * v68 + 24) * v107.f32[0];
              HIDWORD(v110) = v107.i32[0];
              int32x4_t v111 = (_OWORD *)(*(void *)(a1 + 120) + 48 * v80);
              *(void *)(a1 + 128) = v80 + 4;
              *int32x4_t v111 = v85;
              v111[3] = v108;
              v111[6] = v109;
              v111[9] = v110;
            }
            else
            {
              int v99 = (_OWORD *)(*(void *)(a1 + 120) + 48 * v80);
              *(void *)(a1 + 128) = v80 + 4;
              long long v100 = *(_OWORD *)v87->f32;
              long long v101 = *(_OWORD *)v91->f32;
              long long v102 = *(_OWORD *)v95->f32;
              _OWORD *v99 = *v83;
              v99[3] = v100;
              v99[6] = v101;
              v99[9] = v102;
            }
            if (*(void *)(a1 + 96)) {
              CA::OGL::Context::array_indices(a1, v80);
            }
            if (!a7) {
              goto LABEL_48;
            }
            int v112 = *(double **)(v125 + 24);
            double v113 = v112[1];
            double v114 = v112[4];
            if (fabs(v113) >= 0.000001 || fabs(v114) >= 0.000001)
            {
              BOOL v116 = v113 < 0.0;
              float v119 = 1.0 - v71;
              float v120 = 1.0 - v73;
              float v121 = 1.0 - v76;
              float v122 = 1.0 - v78;
              float v71 = v72;
              float v73 = v74;
              float v76 = v75;
              float v78 = v77;
              float v77 = v122;
              float v75 = v121;
              float v74 = v120;
              float v72 = v119;
              if (v114 > 0.0)
              {
LABEL_53:
                float v72 = 1.0 - v72;
                float v74 = 1.0 - v74;
                float v75 = 1.0 - v75;
                float v77 = 1.0 - v77;
                if (!v116) {
                  goto LABEL_48;
                }
LABEL_47:
                float v71 = 1.0 - v71;
                float v73 = 1.0 - v73;
                float v76 = 1.0 - v76;
                float v78 = 1.0 - v78;
                goto LABEL_48;
              }
            }
            else
            {
              double v115 = *v112;
              BOOL v116 = v112[5] < 0.0;
              if (v115 < 0.0) {
                goto LABEL_53;
              }
            }
            if (v116) {
              goto LABEL_47;
            }
LABEL_48:
            uint64_t v117 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
            *(float *)(v117 - 176) = v72;
            *(float *)(v117 - 172) = v71;
            *(float *)(v117 - 128) = v74;
            *(float *)(v117 - 124) = v73;
            *(float *)(v117 - 80) = v75;
            *(float *)(v117 - 76) = v76;
            *(float *)(v117 - 32) = v77;
            *(float *)(v117 - 28) = v78;
            if (v21 != 0x3C003C003C003C00)
            {
              uint64_t v118 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
              *(void *)(v118 - 160) = v21;
              *(void *)(v118 - 112) = v21;
              *(void *)(v118 - 64) = v21;
              *(void *)(v118 - 16) = v21;
            }
            ++v60;
            uint64_t v58 = *(void *)&v18[12]._os_unfair_lock_opaque;
            v59 += 16;
            if (v60 >= (*(void *)&v18[14]._os_unfair_lock_opaque - v58) >> 4) {
              goto LABEL_27;
            }
          }
        }
      }
      *(unsigned char *)(*(void *)(a1 + 16) + 481) &= ~1u;
      CA::OGL::Context::unbind_surface((void *)a1, v124, 0);
      *(unsigned char *)(*(void *)(a1 + 16) + 16) = 0;
      *(unsigned char *)(*(void *)(a1 + 16) + 19) = 0;
      *(void *)(a1 + 816) = 0;
      ++*(_DWORD *)(a1 + 256);
    }
    else
    {
      CA::OGL::fill_surface_mesh_3d(a1, (uint64_t)v17, a3, (void *)a4, a5, a6, a7, a8, a9);
    }
    if (atomic_fetch_add((atomic_uint *volatile)&v18[2], 0xFFFFFFFF) == 1)
    {
      uint64_t v123 = *(void (**)(os_unfair_lock_s *))(*(void *)&v18->_os_unfair_lock_opaque + 16);
      v123(v18);
    }
  }
}

BOOL CA::Render::Layer::append_texture_transform(CA::Render::Layer *this, CA::Transform *a2, CA::Render::Texture *a3, CA::Render::Object *a4)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 41) & 0x80) != 0) {
    return 0;
  }
  double v7 = (unsigned int *)((char *)a3 + 16);
  double v8 = (double)*((unsigned int *)a3 + 4);
  uint64_t v10 = (unsigned int *)((char *)a3 + 20);
  unsigned int v9 = *((_DWORD *)a3 + 5);
  double v11 = (double)v9;
  v43.f64[0] = v8;
  v43.f64[1] = (double)v9;
  uint64_t v45 = 0;
  v44[0] = (float64x2_t)xmmword_184997D50;
  v44[1] = 0u;
  double v12 = 0.0;
  unsigned int v44[2] = (float64x2_t)xmmword_184997D60;
  memset(&v44[3], 0, 32);
  v44[5] = (float64x2_t)xmmword_184997D50;
  v44[6] = 0u;
  v44[7] = (float64x2_t)xmmword_184997D60;
  __asm { FMOV            V0.2D, #1.0 }
  float64x2_t v40 = _Q0;
  v44[8] = _Q0;
  if (*((unsigned char *)a4 + 12) != 50)
  {
    int v18 = *((_DWORD *)a3 + 3);
    if ((v18 & 0x6400) == 0) {
      goto LABEL_15;
    }
    if ((v18 & 0x100) != 0)
    {
      float64x2_t v24 = CA::Transform::translate((CA::Transform *)v44, 0.0, (double)-v9, 0.0);
      v24.f64[0] = 1.0;
      _Q0.f64[0] = CA::Transform::scale(v44, v24, -1.0, 1.0);
      int v18 = *((_DWORD *)a3 + 3);
      if ((v18 & 0x200) == 0)
      {
LABEL_7:
        if ((v18 & 0x400) == 0) {
          goto LABEL_8;
        }
        goto LABEL_26;
      }
    }
    else if ((v18 & 0x200) == 0)
    {
      goto LABEL_7;
    }
    float64x2_t v25 = CA::Transform::translate((CA::Transform *)v44, (double)-*((_DWORD *)a3 + 4), 0.0, 0.0);
    v25.f64[0] = -1.0;
    _Q0.f64[0] = CA::Transform::scale(v44, v25, 1.0, 1.0);
    int v18 = *((_DWORD *)a3 + 3);
    if ((v18 & 0x400) == 0)
    {
LABEL_8:
      if ((v18 & 0x4000) == 0) {
        goto LABEL_9;
      }
      goto LABEL_27;
    }
LABEL_26:
    CA::Transform::translate((CA::Transform *)v44, 0.0, (double)-*((_DWORD *)a3 + 5), 0.0);
    _Q0.f64[0] = CA::Transform::rotate90((CA::Transform *)v44, v26, v27, v28);
    int v18 = *((_DWORD *)a3 + 3);
    if ((v18 & 0x4000) == 0)
    {
LABEL_9:
      if ((v18 & 0x2000) == 0)
      {
LABEL_11:
        LODWORD(v41.f64[0]) = 0;
        unsigned int v42 = 0;
        if ((v18 & 0x6400) != 0)
        {
          double v7 = (unsigned int *)&v41;
          uint64_t v10 = &v42;
          CA::Render::Texture::displayed_size_((uint64_t)a3, (unsigned int *)&v41, &v42);
        }
        LODWORD(_Q0.f64[0]) = *v7;
        double v8 = (double)*(unint64_t *)&_Q0.f64[0];
        LODWORD(_Q0.f64[0]) = *v10;
        double v11 = (double)*(unint64_t *)&_Q0.f64[0];
        goto LABEL_14;
      }
LABEL_10:
      _Q0.f64[0] = *((float *)a3 + 8);
      _Q0.f64[0] = CA::Transform::scale(v44, _Q0, 1.0, 1.0);
      int v18 = *((_DWORD *)a3 + 3);
      goto LABEL_11;
    }
LABEL_27:
    _Q0 = CA::Transform::translate((CA::Transform *)v44, (double)-*((__int16 *)a3 + 12), (double)-*((__int16 *)a3 + 13), 0.0);
    if ((v18 & 0x2000) == 0) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  LODWORD(_Q0.f64[0]) = *((_DWORD *)a4 + 8);
  double v8 = (double)*(unint64_t *)&_Q0.f64[0];
  double v11 = (double)*((unsigned int *)a4 + 9);
LABEL_14:
  v43.f64[0] = v8;
  v43.f64[1] = v11;
LABEL_15:
  uint64_t v19 = *((void *)this + 16);
  if (!v19)
  {
    unsigned int v23 = *((unsigned __int8 *)this + 34);
    if (!*((unsigned char *)this + 34))
    {
      uint64_t v22 = 0;
      double v21 = 0.0;
LABEL_30:
      _Q0.f64[0] = v21;
      CA::Transform::scale_2d_right((CA::Transform *)v44, (__n128)_Q0, (uint64_t)a2, (uint64_t)a3, (const double *)a4);
      double v8 = v8 * v21;
      double v11 = v11 * v21;
      v43.f64[0] = v8;
      v43.f64[1] = v11;
      if (!v22) {
        goto LABEL_37;
      }
      goto LABEL_31;
    }
    if (v23 == 1) {
      goto LABEL_37;
    }
    float v20 = (float)v23;
LABEL_22:
    uint64_t v22 = *((void *)this + 16);
    double v21 = 1.0 / v20;
    goto LABEL_30;
  }
  float v20 = *(float *)(v19 + 284);
  if (v20 != 1.0)
  {
    if (v20 == 0.0)
    {
      double v21 = 0.0;
      uint64_t v22 = *((void *)this + 16);
      goto LABEL_30;
    }
    goto LABEL_22;
  }
  uint64_t v22 = *((void *)this + 16);
LABEL_31:
  float64x2_t v29 = *(double **)(v22 + 40);
  if (v29)
  {
    double v30 = v29[3];
    if (v30 < 0.0) {
      return 0;
    }
    double v31 = v29[4];
    if (v31 < 0.0) {
      return 0;
    }
    double v32 = v29[5];
    if (v32 > 1.0) {
      return 0;
    }
    double v33 = v29[6];
    if (v33 > 1.0) {
      return 0;
    }
    _Q0.f64[0] = -(v30 * v8);
    CA::Transform::translate_right(v44, _Q0, -(v31 * v11), v12);
    double v8 = (v32 - v30) * v8;
    double v11 = (v33 - v31) * v11;
    v43.f64[0] = v8;
    v43.f64[1] = v11;
  }
LABEL_37:
  float64x2_t v41 = v40;
  if ((*((_DWORD *)this + 9) & 0xF000) != 0x9000
    || *((double *)this + 8) != 0.0
    || *((double *)this + 9) != 0.0
    || v19 && *(void *)(v19 + 32)
    || *((double *)this + 10) != v8
    || *((double *)this + 11) != v11)
  {
    CA::Render::Layer::append_contents_transform((uint64_t)this, a2, &v43, &v41);
    double v35 = v41.f64[0];
    double v34 = v41.f64[1];
    CA::Transform::concat_left(a2, v44, v36, v37);
    if (v35 == 1.0 && v34 == 1.0) {
      return 1;
    }
    uint64_t v38 = *((void *)this + 16);
    return !v38 || !*(void *)(v38 + 48);
  }
  CA::Transform::concat_left(a2, v44, (uint64_t)a3, (const double *)a4);
  return 1;
}

float64_t CA::Transform::scale(float64x2_t *this, float64x2_t a2, double a3, double a4)
{
  if (a2.f64[0] == a3 && a4 == 1.0)
  {
LABEL_12:
    *(void *)&v12.f64[0] = *(_OWORD *)&CA::Transform::scale_2d((CA::Transform *)this, a2);
    return v12.f64[0];
  }
  char v5 = LOBYTE(this[9].f64[0]);
  if ((v5 & 0x10) == 0)
  {
    if (-a3 != a2.f64[0] || a4 != 1.0)
    {
      __asm { FMOV            V3.2D, #1.0 }
      this[8] = _Q3;
      LOBYTE(this[9].f64[0]) = v5 & 0xE0 | 0x10;
      goto LABEL_11;
    }
    if (a2.f64[0] >= 0.0)
    {
      if (a3 >= 0.0) {
        goto LABEL_18;
      }
      LOBYTE(this[9].f64[0]) = v5 ^ 1;
      this[2].f64[0] = -this[2].f64[0];
      double v17 = &this[2].f64[1];
    }
    else
    {
      LOBYTE(this[9].f64[0]) = v5 ^ 2;
      this->f64[0] = -this->f64[0];
      double v17 = &this->f64[1];
    }
    double *v17 = -*v17;
LABEL_18:
    if (a2.f64[0] < 0.0) {
      a2.f64[0] = -a2.f64[0];
    }
    goto LABEL_12;
  }
LABEL_11:
  float64x2_t v11 = vmulq_n_f64(*this, a2.f64[0]);
  float64x2_t v12 = vmulq_n_f64(this[1], a2.f64[0]);
  float64x2_t v13 = vmulq_n_f64(this[2], a3);
  float64x2_t v14 = vmulq_n_f64(this[3], a3);
  float64x2_t v15 = vmulq_n_f64(this[4], a4);
  float64x2_t v16 = vmulq_n_f64(this[5], a4);
  *this = v11;
  this[1] = v12;
  this[2] = v13;
  this[3] = v14;
  this[4] = v15;
  this[5] = v16;
  return v12.f64[0];
}

double CA::Transform::scale_2d_right(CA::Transform *this, __n128 a2, uint64_t a3, uint64_t a4, const double *a5)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a2.n128_f64[0] != 1.0)
  {
    char v5 = *((unsigned char *)this + 144);
    if ((v5 & 0x10) != 0)
    {
      uint64_t v19 = 8;
      v9[1] = 0u;
      uint64_t v10 = 0;
      long long v12 = 0u;
      long long v13 = 0u;
      long long v15 = 0u;
      long long v16 = xmmword_184997D60;
      v9[0] = (float64x2_t)a2.n128_u64[0];
      unint64_t v11 = a2.n128_u64[0];
      long long v14 = 0x3FF0000000000000uLL;
      unint64_t v17 = a2.n128_u64[0];
      double v18 = 1.0 / a2.n128_f64[0];
      a2.n128_f64[0] = CA::Transform::concat(this, v9, a4, a5);
    }
    else
    {
      double v6 = *((double *)this + 16) * a2.n128_f64[0];
      double v7 = *((double *)this + 17) / a2.n128_f64[0];
      *((double *)this + 16) = v6;
      *((double *)this + 17) = v7;
      *((unsigned char *)this + 144) = v5 & 0xF7 | (8 * (v6 != 1.0));
      *(float64x2_t *)this = vmulq_n_f64(*(float64x2_t *)this, a2.n128_f64[0]);
      *((float64x2_t *)this + 2) = vmulq_n_f64(*((float64x2_t *)this + 2), a2.n128_f64[0]);
      a2 = (__n128)vmulq_n_f64(*((float64x2_t *)this + 6), a2.n128_f64[0]);
      *((__n128 *)this + 6) = a2;
    }
  }
  return a2.n128_f64[0];
}

uint64_t CA::Render::Texture::displayed_size_(uint64_t this, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *(_DWORD *)(this + 20);
  int v4 = *(_DWORD *)(this + 12);
  if ((v4 & 0x400) != 0) {
    unsigned int v5 = *(_DWORD *)(this + 20);
  }
  else {
    unsigned int v5 = *(_DWORD *)(this + 16);
  }
  if ((v4 & 0x400) != 0) {
    unsigned int v3 = *(_DWORD *)(this + 16);
  }
  if ((v4 & 0x4000) != 0)
  {
    v5 -= *(__int16 *)(this + 24) + *(__int16 *)(this + 28);
    v3 -= *(__int16 *)(this + 26) + *(__int16 *)(this + 30);
  }
  if ((v4 & 0x2000) != 0) {
    unsigned int v5 = (float)((float)(*(float *)(this + 32) * (float)v5) + 0.5);
  }
  *a2 = v5;
  *a3 = v3;
  return this;
}

void CA::Render::MeshTransform::update_locked(CA::Render::MeshTransform *this, int a2)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 9);
  uint64_t v3 = *((void *)this + 10);
  unint64_t v4 = (v3 - v2) >> 4;
  uint64_t v5 = *((void *)this + 6);
  uint64_t v6 = *((void *)this + 7);
  if (v4 == (v6 - v5) >> 2)
  {
    double v7 = this;
    unsigned int v8 = *((_DWORD *)this + 3);
    int v9 = a2 & ~(v8 >> 8);
    if (v9)
    {
      uint64_t v10 = *((void *)this + 3);
      uint64_t v11 = *((void *)this + 4) - v10;
      if (v11)
      {
        unint64_t v12 = v11 >> 5;
        if (v12 <= 1) {
          unint64_t v12 = 1;
        }
        float32x2_t v13 = (float32x2_t)vdup_n_s32(0x7F800000u);
        int8x16_t v14 = (int8x16_t)vdupq_n_s64(0xFFF0000000000000);
        int8x16_t v15 = (int8x16_t)xmmword_1849983F0;
        int8x16_t v16 = (int8x16_t)vdupq_n_s64(0x7FF0000000000000uLL);
        unint64_t v17 = (float *)(v10 + 24);
        float32x2_t v18 = (float32x2_t)0x7F0000007FLL;
        do
        {
          float32x2_t v19 = *(float32x2_t *)(v17 - 6);
          float32x2_t v13 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v19, v13), (int8x8_t)v13, (int8x8_t)v19);
          float32x2_t v18 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v18, v19), (int8x8_t)v18, (int8x8_t)v19);
          int8x16_t v20 = (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)(v17 - 2));
          float v21 = *v17;
          v17 += 8;
          int8x16_t v22 = vextq_s8(v20, v20, 8uLL);
          *(void *)&v23.f64[1] = v22.i64[1];
          *(void *)&v24.f64[1] = v15.i64[1];
          *(void *)&v23.f64[0] = v15.i64[0];
          v24.f64[0] = v21;
          int8x16_t v16 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v20, (float64x2_t)v16), v16, v20);
          v25.i64[1] = v22.i64[1];
          *(double *)v25.i64 = v21;
          int8x16_t v15 = vbslq_s8((int8x16_t)vcgtq_f64(v24, v23), v15, v25);
          *(double *)&v22.i64[1] = v21;
          int8x16_t v14 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v14, (float64x2_t)v22), v14, v22);
          --v12;
        }
        while (v12);
        *(int8x16_t *)((char *)this + 152) = v16;
        *(int8x16_t *)((char *)this + 168) = v15;
        *(int8x16_t *)((char *)this + 184) = v14;
        *(float64x2_t *)((char *)this + 120) = vcvtq_f64_f32(v13);
        *(float64x2_t *)((char *)this + 136) = vcvtq_f64_f32(vsub_f32(v18, v13));
      }
      else
      {
        *(_OWORD *)((char *)this + 136) = 0u;
        *(_OWORD *)((char *)this + 120) = 0u;
        *(_OWORD *)((char *)this + 152) = CA::Volume::null;
        *(_OWORD *)((char *)this + 168) = unk_1849A7DA0;
        *(_OWORD *)((char *)this + 184) = xmmword_1849A7DB0;
      }
      v8 |= 0x100u;
      *((_DWORD *)this + 3) = v8;
    }
    if ((v9 & 8) != 0)
    {
      *((_DWORD *)this + 29) = 2139095040;
      if (v3 != v2)
      {
        if (v4 <= 1) {
          unint64_t v4 = 1;
        }
        uint64_t v26 = (float *)(v2 + 4);
        float v27 = INFINITY;
        do
        {
          float v28 = *v26;
          if (*v26 < v27)
          {
            *((float *)this + 29) = v28;
            float v27 = v28;
          }
          v26 += 4;
          --v4;
        }
        while (v4);
      }
    }
    if ((v9 & 2) != 0)
    {
      float32x2_t v97 = 0;
      uint64_t v98 = 0;
      float32x2_t v96 = &v97;
      *((_DWORD *)this + 28) = 0;
      if (v6 != v5)
      {
        char v92 = v9;
        uint64_t v29 = 0;
        while (1)
        {
          uint64_t v30 = 0;
          uint64_t v95 = 4 * v29;
          uint64_t v31 = 3;
          uint64_t v93 = v29;
          uint64_t v32 = v5 + 16 * v29;
          do
          {
            unsigned int v33 = *(_DWORD *)(v32 + 4 * v31);
            uint64_t v31 = v30;
            unsigned int v34 = *(_DWORD *)(v32 + 4 * v30);
            if (v33 >= v34) {
              uint64_t v35 = v34;
            }
            else {
              uint64_t v35 = v33;
            }
            if (v33 <= v34) {
              uint64_t v36 = v34;
            }
            else {
              uint64_t v36 = v33;
            }
            int32x2_t v37 = v97;
            uint64_t v38 = &v97;
            float32x4_t v39 = v97;
            if (!v97)
            {
              int v62 = v95 + v31;
              uint64_t v63 = &v97;
              float v74 = &v97;
              goto LABEL_80;
            }
            do
            {
              int v40 = *((_DWORD *)v39 + 7);
              BOOL v41 = v40 == v35;
              if (v40 >= (int)v35) {
                char v42 = 1;
              }
              else {
                char v42 = -1;
              }
              if (v41)
              {
                int v43 = *((_DWORD *)v39 + 8);
                BOOL v44 = v43 == v36;
                char v42 = v43 >= (int)v36 ? 1 : -1;
                if (v44) {
                  char v42 = 0;
                }
              }
              BOOL v45 = (v42 & 0x80) == 0;
              if (v42 < 0) {
                uint64_t v46 = v39 + 1;
              }
              else {
                uint64_t v46 = v39;
              }
              if (v45) {
                uint64_t v38 = (uint64_t **)v39;
              }
              float32x4_t v39 = (uint64_t *)*v46;
            }
            while (*v46);
            if (&v97 != v38)
            {
              int v47 = *((_DWORD *)v38 + 7);
              BOOL v48 = v35 == v47;
              if ((int)v35 >= v47) {
                char v49 = 1;
              }
              else {
                char v49 = -1;
              }
              if (v48)
              {
                int v50 = *((_DWORD *)v38 + 8);
                BOOL v51 = v36 == v50;
                char v49 = (int)v36 >= v50 ? 1 : -1;
                if (v51) {
                  char v49 = 0;
                }
              }
              if ((v49 & 0x80) == 0)
              {
                uint64_t v52 = *((int *)v38 + 9);
                uint64_t v53 = *((void *)v7 + 9);
                uint64_t v54 = v53 + ((v95 + v31) << 32 >> 28);
                float v56 = *(float *)(v54 + 4);
                float64x2_t v55 = (float *)(v54 + 4);
                float v57 = v56;
                *((_DWORD *)v55 + 1) = v52;
                uint64_t v58 = v53 + 16 * v52;
                float v60 = *(float *)(v58 + 4);
                uint64_t v59 = v58 + 4;
                float v61 = v60;
                *(_DWORD *)(v59 + 4) = v95 + v31;
                if (v57 <= v60) {
                  *float64x2_t v55 = v61;
                }
                else {
                  *(float *)uint64_t v59 = v57;
                }
                float v71 = v38[1];
                float v72 = v38;
                if (v71)
                {
                  do
                  {
                    float v73 = (uint64_t **)v71;
                    float v71 = (uint64_t *)*v71;
                  }
                  while (v71);
                }
                else
                {
                  do
                  {
                    float v73 = (uint64_t **)v72[2];
                    BOOL v41 = *v73 == (uint64_t *)v72;
                    float v72 = v73;
                  }
                  while (!v41);
                }
                if (v96 == v38) {
                  float32x2_t v96 = v73;
                }
                --v98;
                std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v37, (uint64_t *)v38);
                operator delete(v38);
                goto LABEL_84;
              }
            }
            int v62 = v95 + v31;
            do
            {
              while (1)
              {
                uint64_t v63 = (uint64_t **)v37;
                int v64 = *((_DWORD *)v37 + 7);
                if (v35 != v64) {
                  break;
                }
                int v65 = *((_DWORD *)v37 + 8);
                if ((int)v36 < v65) {
                  goto LABEL_71;
                }
                BOOL v66 = v65 == v36;
                if (v65 >= (int)v36) {
                  char v67 = 1;
                }
                else {
                  char v67 = -1;
                }
                if (v66) {
                  char v67 = 0;
                }
                if ((v67 & 0x80) == 0) {
                  goto LABEL_83;
                }
LABEL_77:
                float v74 = (uint64_t **)(v37 + 1);
                int32x2_t v37 = (uint64_t *)v37[1];
                if (!v37) {
                  goto LABEL_80;
                }
              }
              if ((int)v35 >= v64)
              {
                if (v64 >= (int)v35) {
                  char v68 = 1;
                }
                else {
                  char v68 = -1;
                }
                if ((v68 & 0x80) == 0) {
                  goto LABEL_83;
                }
                goto LABEL_77;
              }
LABEL_71:
              int32x2_t v37 = (uint64_t *)*v37;
            }
            while (*v63);
            float v74 = v63;
LABEL_80:
            int v69 = (uint64_t *)v63;
            uint64_t v63 = (uint64_t **)operator new(0x28uLL);
            *(uint64_t **)((char *)v63 + 28) = (uint64_t *)(v35 | (v36 << 32));
            *((_DWORD *)v63 + 9) = 0;
            *uint64_t v63 = 0;
            v63[1] = 0;
            v63[2] = v69;
            *float v74 = (uint64_t *)v63;
            __int16 v70 = (uint64_t *)v63;
            if (*v96)
            {
              float32x2_t v96 = (uint64_t **)*v96;
              __int16 v70 = *v74;
            }
            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v97, v70);
            ++v98;
            double v7 = this;
LABEL_83:
            *((_DWORD *)v63 + 9) = v62;
            *(_DWORD *)(*((void *)v7 + 9) + 16 * v62 + 8) = -1;
            ++*((_DWORD *)v7 + 28);
LABEL_84:
            uint64_t v30 = v31 + 1;
          }
          while (v31 != 3);
          uint64_t v29 = v93 + 1;
          uint64_t v5 = *((void *)v7 + 6);
          if (v93 + 1 >= (unint64_t)((*((void *)v7 + 7) - v5) >> 4))
          {
            unsigned int v8 = *((_DWORD *)v7 + 3);
            float v75 = v97;
            LOBYTE(v9) = v92;
            goto LABEL_98;
          }
        }
      }
      float v75 = 0;
LABEL_98:
      *((_DWORD *)v7 + 3) = v8 | 0x200;
      std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(v75);
    }
    if ((v9 & 4) != 0)
    {
      uint64_t v76 = *((void *)v7 + 6);
      uint64_t v77 = *((void *)v7 + 7);
      uint64_t v78 = v77 - v76;
      if (v77 != v76)
      {
        uint64_t v79 = 0;
        unint64_t v80 = v78 >> 4;
        uint64_t v81 = *((void *)v7 + 3);
        if (v80 <= 1) {
          unint64_t v80 = 1;
        }
        uint64_t v82 = *((void *)v7 + 9) + 12;
        uint64_t v83 = *((void *)v7 + 6);
        do
        {
          uint64_t v84 = 0;
          long long v85 = (float *)v82;
          uint64_t v86 = 3;
          do
          {
            uint64_t v87 = v81 + 32 * *(unsigned int *)(v83 + 4 * v84);
            uint64_t v88 = v81 + 32 * *(unsigned int *)(v76 + 16 * v79 + 4 * v86);
            float v89 = *(float *)(v87 + 16) - *(float *)(v88 + 16);
            float32x2_t v90 = vsub_f32(*(float32x2_t *)(v87 + 20), *(float32x2_t *)(v88 + 20));
            float32x2_t v91 = vmul_f32(v90, v90);
            *long long v85 = sqrtf((float)(v91.f32[0] + (float)(v89 * v89)) + v91.f32[1]);
            v85 += 4;
            uint64_t v86 = v84++;
          }
          while (v84 != 4);
          ++v79;
          v82 += 64;
          v83 += 16;
        }
        while (v79 != v80);
      }
      *((_DWORD *)v7 + 3) |= 0x400u;
    }
  }
}

os_unfair_lock_s *CA::Render::MeshTransform::retain_subdivided_mesh(os_unfair_lock_s *this, int a2)
{
  uint64_t v180 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = this + 4;
  os_unfair_lock_lock(this + 4);
  if (!CA::Render::MeshTransform::validate_locked((CA::Render::MeshTransform *)this))
  {
    uint64_t v5 = 0;
LABEL_115:
    os_unfair_lock_unlock(v4);
    return v5;
  }
  if (this[26]._os_unfair_lock_opaque == a2) {
    goto LABEL_112;
  }
  uint64_t v5 = *(os_unfair_lock_s **)&this[50]._os_unfair_lock_opaque;
  if (v5 && v5[26]._os_unfair_lock_opaque == a2)
  {
LABEL_113:
    double v167 = (atomic_uint *)&v5[2];
    if (!atomic_fetch_add((atomic_uint *volatile)&v5[2], 1u))
    {
      uint64_t v5 = 0;
      atomic_fetch_add(v167, 0xFFFFFFFF);
    }
    goto LABEL_115;
  }
  CA::Render::MeshTransform::update_locked((CA::Render::MeshTransform *)this, 8);
  if (*(float *)&this[29]._os_unfair_lock_opaque >= (float)a2)
  {
LABEL_112:
    uint64_t v5 = this;
    goto LABEL_113;
  }
  os_unfair_lock_unlock(v4);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  double v7 = (CA::Render::MeshTransform *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xD0uLL, 0x743898A5uLL);
  uint64_t v5 = (os_unfair_lock_s *)v7;
  if (v7)
  {
    lock = v4;
    unsigned int v8 = (os_unfair_lock_s *)CA::Render::MeshTransform::MeshTransform(v7, (const CA::Render::MeshTransform *)this);
    unint64_t v169 = this;
    uint32_t os_unfair_lock_opaque = this[26]._os_unfair_lock_opaque;
    if (CA::Render::MeshTransform::validate(v8))
    {
      os_unfair_lock_lock(v5 + 4);
      CA::Render::MeshTransform::update_locked((CA::Render::MeshTransform *)v5, 3);
      os_unfair_lock_unlock(v5 + 4);
      int v171 = a2 - os_unfair_lock_opaque;
      if ((signed int)v5[26]._os_unfair_lock_opaque < (signed int)(a2 - os_unfair_lock_opaque))
      {
        uint64_t v10 = v5 + 6;
        __asm
        {
          FMOV            V12.2S, #0.75
          FMOV            V15.2S, #0.25
        }
        while (1)
        {
          uint64_t v172 = *(void *)&v5[8]._os_unfair_lock_opaque;
          uint64_t v175 = *(void *)&v5[6]._os_unfair_lock_opaque;
          uint64_t v17 = v172 - v175;
          uint64_t v19 = *(void *)&v5[12]._os_unfair_lock_opaque;
          uint64_t v18 = *(void *)&v5[14]._os_unfair_lock_opaque;
          std::vector<CA::Render::MeshVertex>::resize((char **)&v5[6], v5[28]._os_unfair_lock_opaque + ((v172 - v175) >> 5) + ((v18 - v19) >> 4));
          long long v20 = xmmword_184997DF0;
          unint64_t v21 = (v172 - v175) >> 5;
          uint64_t v22 = v21;
          uint64_t v173 = v18;
          uint64_t v174 = v19;
          int64_t v23 = v18 - v19;
          unint64_t v24 = v23 >> 4;
          if (v23)
          {
            uint64_t v25 = 0;
            uint64_t v26 = *(void *)&v5[12]._os_unfair_lock_opaque;
            uint64_t v27 = *(void *)&v5[6]._os_unfair_lock_opaque;
            if (v24 <= 1) {
              uint64_t v28 = 1;
            }
            else {
              uint64_t v28 = v23 >> 4;
            }
            uint64_t v22 = v17 >> 5;
            do
            {
              uint64_t v29 = 0;
              uint64_t v30 = (float32x2_t *)(v27 + 32 * v22);
              float32x2_t v31 = 0;
              *uint64_t v30 = 0;
              uint64_t v32 = (float *)&v30[3];
              *(_OWORD *)v30[2].f32 = xmmword_184997DF0;
              unsigned int v33 = v30 + 2;
              float v34 = 0.0;
              float32x2_t v35 = 0;
              do
              {
                uint64_t v36 = (float32x2_t *)(v27 + 32 * *(unsigned int *)(v26 + v29));
                float32x2_t v31 = vadd_f32(v31, *v36);
                *uint64_t v30 = v31;
                float32x2_t v35 = vadd_f32(v35, v36[2]);
                *unsigned int v33 = v35;
                float v34 = v34 + v36[3].f32[0];
                *uint64_t v32 = v34;
                v29 += 4;
              }
              while (v29 != 16);
              ++v22;
              *uint64_t v30 = vmul_f32(v31, _D15);
              *unsigned int v33 = vmul_f32(v35, _D15);
              *uint64_t v32 = v34 * 0.25;
              ++v25;
              v26 += 16;
            }
            while (v25 != v28);
          }
          uint64_t v37 = v172;
          if (v172 == v175)
          {
            uint64_t v38 = 0;
            float v40 = 0.75;
          }
          else
          {
            if (v17 < 0) {
              abort();
            }
            uint64_t v38 = (int *)operator new(44 * v21);
            uint64_t v39 = 0;
            do
            {
              *(void *)&v38[v39 + 8] = 0;
              v39 += 11;
            }
            while (11 * v21 != v39);
            float v40 = 0.75;
            long long v20 = xmmword_184997DF0;
            uint64_t v37 = v172;
          }
          if (v173 != v174)
          {
            uint64_t v41 = 0;
            uint64_t v42 = *(void *)&v5[12]._os_unfair_lock_opaque;
            uint64_t v43 = *(void *)&v5[18]._os_unfair_lock_opaque;
            if (v24 <= 1) {
              uint64_t v44 = 1;
            }
            else {
              uint64_t v44 = v23 >> 4;
            }
            uint64_t v45 = *(void *)&v5[18]._os_unfair_lock_opaque;
            uint64_t v46 = *(void *)&v5[12]._os_unfair_lock_opaque;
            do
            {
              uint64_t v47 = 0;
              uint64_t v48 = v45;
              uint64_t v49 = 3;
              uint64_t v50 = v42 + 16 * v41;
              do
              {
                uint64_t v51 = v47;
                unint64_t v52 = *(int *)(v48 + 8);
                uint64_t v53 = *(unsigned int *)(v48 + 8);
                if ((v52 & 0x80000000) != 0)
                {
                  BOOL v54 = 1;
                }
                else
                {
                  BOOL v54 = *(float *)(v48 + 4) > 0.5;
                  if ((int)v52 < *(_DWORD *)(v43 + 16 * v53 + 8)) {
                    goto LABEL_40;
                  }
                }
                float64x2_t v55 = &v38[11 * *(unsigned int *)(v50 + 4 * v49)];
                ++v55[8];
                float v56 = &v38[11 * *(unsigned int *)(v46 + 4 * v51)];
                ++v56[8];
                if (v54)
                {
                  float v57 = &v38[11 * *(unsigned int *)(v50 + 4 * v49)];
                  ++v57[9];
                  uint64_t v58 = &v38[11 * *(unsigned int *)(v46 + 4 * v51)];
                  ++v58[9];
                  *(_DWORD *)uint64_t v48 = v22;
                  if ((v53 & 0x80000000) == 0) {
                    *(_DWORD *)(v43 + 16 * v53) = v22;
                  }
                  uint64_t v59 = *(void *)&v10->_os_unfair_lock_opaque;
                  uint64_t v60 = *(void *)&v10->_os_unfair_lock_opaque + 32 * v22;
                  *(void *)uint64_t v60 = 0;
                  *(_OWORD *)(v60 + 16) = v20;
                  float v61 = (float *)(v60 + 16);
                  int v62 = (float32x2_t *)(v59 + 32 * *(unsigned int *)(v50 + 4 * v49));
                  float v63 = 0.5;
                  float v64 = v62[3].f32[0] * 0.5;
                  *(float *)(v60 + 24) = v64;
                  int v65 = (float *)(v60 + 24);
                  float32x2_t v66 = vmul_f32(*v62, (float32x2_t)0x3F0000003F000000);
                  *(float32x2_t *)uint64_t v60 = v66;
                  float32x2_t v67 = vmul_f32(v62[2], (float32x2_t)0x3F0000003F000000);
                  *(float32x2_t *)(v60 + 16) = v67;
                  char v68 = (float32x2_t *)(v59 + 32 * *(unsigned int *)(v46 + 4 * v51));
                }
                else
                {
                  int v69 = (_DWORD *)(v43 + 16 * v52);
                  *int v69 = v22;
                  *(_DWORD *)uint64_t v48 = v22;
                  uint64_t v70 = ((unint64_t)(int)v69[2] >> 2) + v21;
                  unint64_t v71 = v52 >> 2;
                  uint64_t v59 = *(void *)&v10->_os_unfair_lock_opaque;
                  uint64_t v60 = *(void *)&v10->_os_unfair_lock_opaque + 32 * v22;
                  *(void *)uint64_t v60 = 0;
                  *(_OWORD *)(v60 + 16) = v20;
                  float v61 = (float *)(v60 + 16);
                  float v72 = (float32x2_t *)(v59 + 32 * *(unsigned int *)(v50 + 4 * v49));
                  float v63 = 0.25;
                  float v73 = v72[3].f32[0] * 0.25;
                  *(float *)(v60 + 24) = v73;
                  int v65 = (float *)(v60 + 24);
                  float v74 = (float32x2_t *)(v59 + 32 * *(unsigned int *)(v46 + 4 * v51));
                  float v75 = v73 + (float)(v74[3].f32[0] * 0.25);
                  *(float *)(v60 + 24) = v75;
                  uint64_t v76 = (float32x2_t *)(v59 + 32 * v70);
                  float v77 = v76[3].f32[0];
                  float32x2_t v78 = vmul_f32(*v72, _D15);
                  *(float32x2_t *)uint64_t v60 = v78;
                  float32x2_t v79 = vmla_f32(v78, _D15, *v74);
                  *(float32x2_t *)uint64_t v60 = v79;
                  float32x2_t v66 = vmla_f32(v79, _D15, *v76);
                  *(float32x2_t *)uint64_t v60 = v66;
                  float32x2_t v80 = vmul_f32(v72[2], _D15);
                  *(float32x2_t *)(v60 + 16) = v80;
                  float32x2_t v81 = vmla_f32(v80, _D15, v74[2]);
                  *(float32x2_t *)(v60 + 16) = v81;
                  float32x2_t v67 = vmla_f32(v81, _D15, v76[2]);
                  *(float32x2_t *)(v60 + 16) = v67;
                  float v64 = v75 + (float)(v77 * 0.25);
                  *(float *)(v60 + 24) = v64;
                  char v68 = (float32x2_t *)(v59 + 32 * (v71 + v21));
                }
                float v82 = v68[2].f32[0];
                float v83 = v68[2].f32[1];
                float v84 = v68[3].f32[0];
                *(float32x2_t *)uint64_t v60 = vmla_n_f32(v66, *v68, v63);
                *float v61 = v67.f32[0] + (float)(v82 * v63);
                *(float *)(v59 + 32 * v22 + 20) = v67.f32[1] + (float)(v83 * v63);
                *int v65 = v64 + (float)(v84 * v63);
                ++v22;
LABEL_40:
                uint64_t v47 = v51 + 1;
                v48 += 16;
                uint64_t v49 = v51;
              }
              while (v51 != 3);
              ++v41;
              v46 += 16;
              v45 += 64;
            }
            while (v41 != v44);
          }
          if (v37 != v175)
          {
            if (v21 <= 1) {
              uint64_t v85 = 1;
            }
            else {
              uint64_t v85 = (v172 - v175) >> 5;
            }
            uint64_t v86 = (float32x2_t *)(v38 + 6);
            uint64_t v87 = 28;
            while (1)
            {
              int v88 = v86[1].i32[0];
              if (v88 <= 2) {
                break;
              }
              int v90 = v86[1].i32[1];
              uint64_t v89 = *(void *)&v10->_os_unfair_lock_opaque;
              if (v90 >= 2)
              {
                if (v90 != 2) {
                  goto LABEL_53;
                }
                uint64_t v98 = (__int32 *)(v89 + v87);
                float32x2_t v99 = *(float32x2_t *)(v98 - 7);
                v86[-3] = v99;
                float32x2_t v100 = v99;
                float32x2_t v101 = *(float32x2_t *)(v98 - 3);
                v86->i32[0] = *(v98 - 1);
                v86[-1] = v101;
                __int32 v102 = *v98;
                v86[-3] = vmul_f32(v100, _D12);
                v86[-1] = vmul_f32(v86[-1], _D12);
                v86->f32[0] = v86->f32[0] * v40;
                v86->i32[1] = v102;
                float v97 = 0.125;
              }
              else
              {
                float v91 = (float)v88;
                char v92 = (__int32 *)(v89 + v87);
                float32x2_t v93 = *(float32x2_t *)(v92 - 7);
                v86[-3] = v93;
                float32x2_t v94 = *(float32x2_t *)(v92 - 3);
                v86->i32[0] = *(v92 - 1);
                v86[-1] = v94;
                __int32 v95 = *v92;
                float v96 = (float)(v91 + -2.0) / v91;
                v86[-3].f32[0] = v96 * v93.f32[0];
                v86[-3].f32[1] = v96 * v93.f32[1];
                v86[-1] = vmul_n_f32(v86[-1], v96);
                v86->f32[0] = v86->f32[0] * v96;
                v86->i32[1] = v95;
                float v97 = 1.0 / (float)(v91 * v91);
              }
LABEL_54:
              v86[2].f32[0] = v97;
              v87 += 32;
              uint64_t v86 = (float32x2_t *)((char *)v86 + 44);
              if (!--v85) {
                goto LABEL_55;
              }
            }
            v86[1].i32[1] = 3;
            uint64_t v89 = *(void *)&v10->_os_unfair_lock_opaque;
LABEL_53:
            float32x2_t v103 = (__int32 *)(v89 + v87);
            v86[-3] = *(float32x2_t *)(v103 - 7);
            float32x2_t v104 = *(float32x2_t *)(v103 - 3);
            v86->i32[0] = *(v103 - 1);
            v86[-1] = v104;
            v86->i32[1] = *v103;
            float v97 = 0.0;
            goto LABEL_54;
          }
LABEL_55:
          if (v173 != v174)
          {
            uint64_t v105 = 0;
            uint64_t v106 = *(void *)&v5[12]._os_unfair_lock_opaque;
            if (v24 <= 1) {
              uint64_t v107 = 1;
            }
            else {
              uint64_t v107 = v23 >> 4;
            }
            do
            {
              uint64_t v108 = 0;
              uint64_t v109 = 3;
              do
              {
                int v110 = *(_DWORD *)(v106 + 16 * v105 + 4 * v109);
                uint64_t v109 = v108;
                if (v38[11 * v110 + 9] <= 1)
                {
                  int32x4_t v111 = (float32x2_t *)&v38[11 * v110];
                  float v112 = v111[5].f32[0];
                  double v113 = (float32x2_t *)(*(void *)&v10->_os_unfair_lock_opaque + 32 * (v105 + v21));
                  float v114 = v113[3].f32[0];
                  float32x2_t v115 = v113[2];
                  *int32x4_t v111 = vmla_n_f32(*v111, *v113, v112);
                  v111[2] = vmla_n_f32(v111[2], v115, v112);
                  v111[3].f32[0] = v111[3].f32[0] + (float)(v114 * v112);
                }
                uint64_t v108 = v109 + 1;
              }
              while (v109 != 3);
              ++v105;
            }
            while (v105 != v107);
            uint64_t v116 = 0;
            uint64_t v117 = *(void *)&v5[18]._os_unfair_lock_opaque;
            do
            {
              uint64_t v118 = 0;
              uint64_t v119 = 3;
              uint64_t v120 = v106 + 16 * v116;
              do
              {
                uint64_t v121 = v118;
                uint64_t v122 = v117 + 16 * (4 * v116 + v118);
                uint64_t v123 = (_DWORD *)(v122 + 8);
                if ((*(_DWORD *)(v122 + 8) & 0x80000000) != 0
                  || *(_DWORD *)(v122 + 8) >= *(_DWORD *)(v117 + 16 * *(unsigned int *)(v122 + 8) + 8))
                {
                  uint64_t v124 = *(unsigned int *)(v120 + 4 * v119);
                  uint64_t v125 = *(unsigned int *)(v120 + 4 * v121);
                  uint64_t v126 = (float *)(v122 + 4);
                  uint64_t v127 = v124;
                  do
                  {
                    uint64_t v128 = v127;
                    uint64_t v127 = v125;
                    float32x2_t v129 = (float32x2_t *)&v38[11 * v128];
                    int v130 = v129[4].i32[1];
                    if (v130 < 2 || v130 == 2 && (*v126 <= 0.5 ? (BOOL v135 = *v123 <= 0) : (BOOL v135 = 1), v135))
                    {
                      float v131 = *(float *)&v38[11 * v128 + 10];
                      float v132 = (float32x2_t *)(*(void *)&v10->_os_unfair_lock_opaque + 32 * v127);
                      float v133 = v132[3].f32[0];
                      float32x2_t v134 = v132[2];
                      *float32x2_t v129 = vmla_n_f32(*v129, *v132, v131);
                      v129[2] = vmla_n_f32(v129[2], v134, v131);
                      v129[3].f32[0] = v129[3].f32[0] + (float)(v133 * v131);
                    }
                    uint64_t v125 = v124;
                  }
                  while (v128 == v124);
                }
                uint64_t v118 = v121 + 1;
                uint64_t v119 = v121;
              }
              while (v121 != 3);
              ++v116;
            }
            while (v116 != v107);
          }
          if (v37 != v175) {
            break;
          }
          if (v38) {
            goto LABEL_87;
          }
LABEL_88:
          long long v178 = 0uLL;
          uint64_t v179 = 0;
          long long v176 = 0uLL;
          uint64_t v177 = 0;
          std::vector<CA::Render::MeshFace>::resize((char **)&v178, v23 >> 2);
          std::vector<CA::Render::MeshFace>::resize((char **)&v176, v23);
          v5[28]._uint32_t os_unfair_lock_opaque = 12 * ((unint64_t)v23 >> 4);
          if (v173 != v174)
          {
            uint64_t v141 = 0;
            uint64_t v142 = 0;
            uint64_t v143 = *(void *)&v5[18]._os_unfair_lock_opaque;
            uint64_t v144 = *(void *)&v5[12]._os_unfair_lock_opaque;
            if (v24 <= 1) {
              uint64_t v145 = 1;
            }
            else {
              uint64_t v145 = v23 >> 4;
            }
            uint64_t v146 = v178 + 12;
            long long v147 = (float *)(v176 + 36);
            uint64_t v148 = *(void *)&v5[18]._os_unfair_lock_opaque;
            do
            {
              uint64_t v149 = 0;
              uint64_t v150 = 0;
              int v151 = 16 * v142;
              uint64_t v152 = v147;
              char v153 = 1;
              do
              {
                unint64_t v154 = v153 & 3 | (unint64_t)(4 * v142);
                uint64_t v155 = v143 + 16 * v154;
                int64x2_t v156 = (_DWORD *)(v146 + v150);
                *(v156 - 3) = *(_DWORD *)(v144 + v149);
                *(v156 - 2) = *(_DWORD *)v155;
                *(v156 - 1) = v142 + v21;
                _DWORD *v156 = *(_DWORD *)(v148 + v150);
                unint64_t v157 = v141 + v149;
                *(v152 - 8) = *(float *)(v148 + 4 * v149 + 4) + -1.0;
                *(v152 - 4) = *(float *)(v155 + 4) + -1.0;
                v152[4] = 0.0;
                *uint64_t v152 = 0.0;
                int v158 = *(_DWORD *)(v148 + v150 + 8);
                if (v158 < 0)
                {
                  *(v152 - 7) = NAN;
                }
                else
                {
                  signed int v159 = ((4 * v158) & 0xFFFFFFF0) + CA::Render::MeshTransform::subdivide(int)::edge_map[4 * (v158 & 3)];
                  *((_DWORD *)v152 - 7) = v159;
                  if (v157 < v159) {
                    --v5[28]._os_unfair_lock_opaque;
                  }
                }
                int v160 = *(_DWORD *)(v143 + 16 * v154 + 8);
                if (v160 < 0)
                {
                  *(v152 - 3) = NAN;
                }
                else
                {
                  signed int v161 = ((4 * v160) & 0xFFFFFFF0)
                       + CA::Render::MeshTransform::subdivide(int)::edge_map[((4 * v160) & 0xC) + 1];
                  *((_DWORD *)v152 - 3) = v161;
                  if (v157 < v161) {
                    --v5[28]._os_unfair_lock_opaque;
                  }
                }
                *((_DWORD *)v152 + 1) = v151 + CA::Render::MeshTransform::subdivide(int)::edge_map[v149 + 2];
                *((_DWORD *)v152 + 5) = v151 + CA::Render::MeshTransform::subdivide(int)::edge_map[v149 + 3];
                v150 += 16;
                v149 += 4;
                ++v153;
                v152 += 16;
              }
              while (v149 != 16);
              ++v142;
              v146 += 64;
              v144 += 16;
              v148 += 64;
              v141 += 16;
              v147 += 64;
            }
            while (v142 != v145);
          }
          unsigned int v162 = *(void **)&v5[12]._os_unfair_lock_opaque;
          *(_OWORD *)&v5[12]._uint32_t os_unfair_lock_opaque = v178;
          *(void *)&v5[16]._uint32_t os_unfair_lock_opaque = v179;
          uint64_t v163 = *(void **)&v5[18]._os_unfair_lock_opaque;
          *(_OWORD *)&v5[18]._uint32_t os_unfair_lock_opaque = v176;
          *(void *)&v5[22]._uint32_t os_unfair_lock_opaque = v177;
          if (v163) {
            operator delete(v163);
          }
          if (v162) {
            operator delete(v162);
          }
          int v164 = v5[26]._os_unfair_lock_opaque + 1;
          v5[26]._uint32_t os_unfair_lock_opaque = v164;
          v5[3]._os_unfair_lock_opaque &= ~0x400u;
          if (v164 >= v171) {
            goto LABEL_109;
          }
        }
        uint64_t v136 = 0;
        if (v21 <= 1) {
          uint64_t v137 = 1;
        }
        else {
          uint64_t v137 = (v172 - v175) >> 5;
        }
        int32x4_t v138 = (char *)(v38 + 4);
        do
        {
          uint64_t v139 = *(void *)&v10->_os_unfair_lock_opaque + v136;
          *(void *)uint64_t v139 = *((void *)v138 - 2);
          uint64_t v140 = *(void *)v138;
          *(_DWORD *)(v139 + 24) = *((_DWORD *)v138 + 2);
          *(void *)(v139 + 16) = v140;
          *(_DWORD *)(v139 + 28) = *((_DWORD *)v138 + 3);
          v136 += 32;
          v138 += 44;
          --v137;
        }
        while (v137);
LABEL_87:
        operator delete(v38);
        goto LABEL_88;
      }
    }
LABEL_109:
    unint64_t v4 = lock;
    os_unfair_lock_lock(lock);
    int v165 = *(atomic_uint **)&v169[50]._os_unfair_lock_opaque;
    *(void *)&v169[50]._uint32_t os_unfair_lock_opaque = v5;
    uint64_t v166 = (atomic_uint *)&v5[2];
    if (!atomic_fetch_add((atomic_uint *volatile)&v5[2], 1u))
    {
      uint64_t v5 = 0;
      atomic_fetch_add(v166, 0xFFFFFFFF);
    }
  }
  else
  {
    os_unfair_lock_lock(v4);
    int v165 = *(atomic_uint **)&this[50]._os_unfair_lock_opaque;
    *(void *)&this[50]._uint32_t os_unfair_lock_opaque = 0;
  }
  os_unfair_lock_unlock(v4);
  if (v165 && atomic_fetch_add(v165 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v165 + 16))(v165);
  }
  return v5;
}

uint64_t CA::Render::MeshTransform::validate_locked(CA::Render::MeshTransform *this)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *((_DWORD *)this + 3);
  if ((v1 & 0x2000) != 0) {
    return (v1 >> 12) & 1;
  }
  *((_DWORD *)this + 3) = v1 & 0xFFFFCFFF | 0x2000;
  uint64_t v3 = *((void *)this + 6);
  uint64_t v4 = *((void *)this + 7);
  uint64_t v5 = v4 - v3;
  if ((uint64_t)(*((void *)this + 10) - *((void *)this + 9)) >> 4 == (v4 - v3) >> 2)
  {
    if (v4 == v3)
    {
LABEL_10:
      CA::Render::MeshTransform::update_locked(this, 2);
      uint64_t v9 = *((void *)this + 7) - *((void *)this + 6);
      if (v9)
      {
        uint64_t v10 = 0;
        unint64_t v11 = v9 >> 4;
        uint64_t v12 = *((void *)this + 9);
        unint64_t v13 = (unint64_t)(*((void *)this + 10) - v12) >> 4;
        if (v11 <= 1) {
          unint64_t v11 = 1;
        }
        uint64_t v14 = v12 + 8;
LABEL_14:
        uint64_t v15 = 0;
        while (*(_DWORD *)(v14 + v15) < (int)v13)
        {
          v15 += 16;
          if (v15 == 64)
          {
            ++v10;
            v14 += 64;
            if (v10 != v11) {
              goto LABEL_14;
            }
            goto LABEL_18;
          }
        }
        if (x_log_hook_p()) {
          goto LABEL_29;
        }
        uint64_t v17 = x_log_category_render;
        BOOL v22 = os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT);
        uint64_t result = 0;
        if (v22)
        {
          __int16 v23 = 0;
          uint64_t v19 = "CoreAnimation: invalid mesh transform - paired edge\n";
          long long v20 = (uint8_t *)&v23;
          goto LABEL_32;
        }
      }
      else
      {
LABEL_18:
        *((_DWORD *)this + 3) |= 0x1000u;
        return 1;
      }
    }
    else
    {
      uint64_t v6 = 0;
      uint64_t v7 = v5 >> 4;
      if ((unint64_t)(v5 >> 4) <= 1) {
        uint64_t v7 = 1;
      }
LABEL_6:
      uint64_t v8 = 0;
      while ((uint64_t)(*((void *)this + 4) - *((void *)this + 3)) >> 5 > (unint64_t)*(unsigned int *)(v3 + v8))
      {
        v8 += 4;
        if (v8 == 16)
        {
          ++v6;
          v3 += 16;
          if (v6 != v7) {
            goto LABEL_6;
          }
          goto LABEL_10;
        }
      }
      if (x_log_hook_p()) {
        goto LABEL_29;
      }
      uint64_t v17 = x_log_category_render;
      BOOL v21 = os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (v21)
      {
        __int16 v24 = 0;
        uint64_t v19 = "CoreAnimation: invalid mesh transform - vertex index\n";
        long long v20 = (uint8_t *)&v24;
        goto LABEL_32;
      }
    }
  }
  else
  {
    if (x_log_hook_p())
    {
LABEL_29:
      x_log_();
    }
    else
    {
      uint64_t v17 = x_log_category_render;
      BOOL v18 = os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (!v18) {
        return result;
      }
      __int16 v25 = 0;
      uint64_t v19 = "CoreAnimation: invalid mesh transform - too few edges\n";
      long long v20 = (uint8_t *)&v25;
LABEL_32:
      _os_log_impl(&dword_184668000, v17, OS_LOG_TYPE_DEFAULT, v19, v20, 2u);
    }
    return 0;
  }
  return result;
}

float CA::Render::MeshTransform::vertex_transform(int a1, float64x2_t *a2, uint64_t a3, float32x2_t *a4)
{
  if (a1)
  {
    _D0 = a2[1].f64[0];
    double v5 = a2[1].f64[1];
    float v6 = _D0;
    float v7 = v5;
    *(float *)a3 = v6;
    *(float *)(a3 + 4) = v7;
    *a4 = vcvt_f32_f64(*a2);
    a4[1].i32[0] = 0;
    switch(a1)
    {
      case 2:
        goto LABEL_11;
      case 3:
        _D0 = v5 * 0.5;
        goto LABEL_14;
      case 4:
        if (_D0 >= v5) {
          _D0 = v5;
        }
        goto LABEL_11;
      case 5:
        if (_D0 <= v5) {
          _D0 = v5;
        }
LABEL_11:
        double v12 = 0.5;
        goto LABEL_13;
      case 6:
        _D0 = v5 + _D0;
        double v12 = 0.25;
LABEL_13:
        _D0 = _D0 * v12;
LABEL_14:
        *(float *)&_D0 = _D0;
        *(_DWORD *)(a3 + 8) = LODWORD(_D0);
        break;
      default:
        *(_DWORD *)(a3 + 8) = 1056964608;
        break;
    }
  }
  else
  {
    __asm { FMOV            V0.2S, #1.0 }
    *(double *)a3 = _D0;
    *(_DWORD *)(a3 + 8) = 1065353216;
    *a4 = 0;
    a4[1].i32[0] = 0;
  }
  return *(float *)&_D0;
}

uint64_t CA::Render::LayerSubclass::hit_test()
{
  return 0;
}

uint64_t CA::Render::GradientLayer::hit_test(CA::Render::GradientLayer *a1, uint64_t a2, double *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t result = CA::Render::GradientLayer::is_valid(a1);
  if (result)
  {
    long long v6 = *(_OWORD *)(a2 + 80);
    v9[0] = *(_OWORD *)(a2 + 64);
    v9[1] = v6;
    uint64_t v7 = *(void *)(a2 + 128);
    float v8 = 0.0;
    if (v7) {
      float v8 = *(float *)(v7 + 228);
    }
    return CA_CGRoundRectContainsPoint((double *)v9, v8, *a3, a3[1]);
  }
  return result;
}

BOOL CA::OGL::prepare_layer_image(CA::OGL::Renderer &,CA::OGL::Layer *,CA::OGL::Gstate const&)::visitor::visit_subclass(uint64_t a1, CA::Render::GradientLayer *this)
{
  BOOL result = CA::Render::GradientLayer::is_valid(this);
  if (result) {
    *(void *)(*(void *)(a1 + 16) + 32) |= 0x4000uLL;
  }
  return result;
}

BOOL CA::Render::GradientLayer::has_background(CA::Render::GradientLayer *this, const CA::Render::Layer *a2, BOOL *a3)
{
  BOOL result = CA::Render::GradientLayer::is_valid(this);
  if (result)
  {
    if ((*((_DWORD *)this + 3) & 0x800) != 0) {
      int v6 = *((_DWORD *)this + 3) & 0x1000;
    }
    else {
      int v6 = *((_DWORD *)this + 7) & 0x800;
    }
    *a3 = v6 != 0;
  }
  return result;
}

BOOL CA::Render::GradientLayer::is_valid(CA::Render::GradientLayer *this)
{
  int v1 = *((_DWORD *)this + 26);
  if (v1 != 51 && v1 != 453 && v1 != 117) {
    return 0;
  }
  if ((*((unsigned char *)this + 13) & 8) != 0 && *((void *)this + 14)) {
    return 1;
  }
  return *((void *)this + 6) != 0;
}

CA::Render::Context *CA::Render::Context::set_frame_stall_skip_request(CA::Render::Context *this, BOOL a2)
{
  BOOL result = (CA::Render::Context *)CA::Render::Context::retain_host_context(this);
  if (result)
  {
    double v5 = (atomic_uint *)result;
    BOOL result = (CA::Render::Context *)CA::Render::Context::set_frame_stall_skip_request(result, a2);
    if (atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1)
    {
      int v6 = *(uint64_t (**)(atomic_uint *))(*(void *)v5 + 16);
      return (CA::Render::Context *)v6(v5);
    }
  }
  else
  {
    if (a2) {
      __int16 v7 = 128;
    }
    else {
      __int16 v7 = 0;
    }
    *((_WORD *)this + 276) = *((_WORD *)this + 276) & 0xFF7F | v7;
  }
  return result;
}

CA::Render::Context *CA::Render::Context::add_update_deadline(CA::Render::Context *this, double a2)
{
  BOOL result = (CA::Render::Context *)CA::Render::Context::retain_host_context(this);
  if (result)
  {
    double v5 = (atomic_uint *)result;
    BOOL result = (CA::Render::Context *)CA::Render::Context::add_update_deadline(result, a2);
    if (atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1)
    {
      int v6 = *(uint64_t (**)(atomic_uint *))(*(void *)v5 + 16);
      return (CA::Render::Context *)v6(v5);
    }
  }
  else
  {
    double v7 = *((double *)this + 64);
    if (v7 > a2) {
      double v7 = a2;
    }
    *((double *)this + 64) = v7;
  }
  return result;
}

CA::Render::Context *CA::Render::Context::add_input_time(CA::Render::Context *this, double a2)
{
  BOOL result = (CA::Render::Context *)CA::Render::Context::retain_host_context(this);
  if (result)
  {
    double v5 = (atomic_uint *)result;
    BOOL result = (CA::Render::Context *)CA::Render::Context::add_input_time(result, a2);
    if (atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1)
    {
      int v6 = *(uint64_t (**)(atomic_uint *))(*(void *)v5 + 16);
      return (CA::Render::Context *)v6(v5);
    }
  }
  else
  {
    double v7 = *((double *)this + 57);
    if (v7 > a2) {
      double v7 = a2;
    }
    *((double *)this + 57) = v7;
  }
  return result;
}

uint64_t CA::Render::Context::retain_host_context(CA::Render::Context *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
  uint64_t v2 = *((void *)this + 52);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 80);
    if (v3)
    {
      uint64_t v4 = (atomic_uint *)(v3 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v3 + 8), 1u))
      {
        uint64_t v3 = 0;
        atomic_fetch_add(v4, 0xFFFFFFFF);
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
  return v3;
}

void sub_18471FB10(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::OGL::compute_contents_dod(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (int32x2_t *)result;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    BOOL result = (*(uint64_t (**)(uint64_t))(*(void *)a4 + 80))(a4);
    if (result)
    {
      uint64_t v14 = 0;
      memset(v13, 0, sizeof(v13));
      BOOL result = CA::OGL::ContentsGeometry::ContentsGeometry((uint64_t)v13, a2, a3, result, a4, 0);
      int64x2_t v8 = vceqzq_f64(*(float64x2_t *)((char *)&v13[3] + 8));
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0] & 0x8000000000000000) == 0)
      {
        int8x16_t v9 = vorrq_s8((int8x16_t)vcltzq_f64(*(float64x2_t *)((char *)&v13[3] + 8)), (int8x16_t)vcgezq_f64(*(float64x2_t *)((char *)&v13[3] + 8)));
        if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v9), 1), v9).u64[0] & 0x8000000000000000) == 0)
        {
          int32x4_t v10 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(*(float64x2_t *)((char *)&v13[2] + 8), (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
          *(int32x4_t *)v4->i8 = vuzp1q_s32(v10, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(*(float64x2_t *)((char *)&v13[2] + 8), *(float64x2_t *)((char *)&v13[3] + 8)), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v10));
          return result;
        }
      }
    }
    else if (*(unsigned char *)(a4 + 12) == 26)
    {
      v13[0] = 0uLL;
      int32x2_t v11 = 0;
      int32x2_t v12 = 0;
      CA::OGL::compute_contents_dod(v13, a2, a3, *(void *)(a4 + 24));
      CA::OGL::compute_contents_dod(&v11, a2, a3, *(void *)(a4 + 32));
      *(_OWORD *)v4->i8 = v13[0];
      return CA::BoundsImpl::Union(v4, v11, v12);
    }
  }
  int32x2_t *v4 = 0;
  v4[1] = 0;
  return result;
}

uint64_t CA::Render::Object::texture_cast(CA::Render::Object *this)
{
  return 0;
}

uint64_t CA::OGL::color_matrix_function(CA::OGL *this, CA::OGL::Context *a2, const CA::ColorMatrix *a3, int a4, int a5)
{
  int v7 = (int)a3;
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  uint64_t result = CA::ColorMatrix::is_diagonal(a2);
  if (!result) {
    goto LABEL_21;
  }
  float v11 = *(float *)a2;
  BOOL v12 = *(float *)a2 >= 0.0 && v11 <= 1.0;
  if (!v12
    || ((float v13 = *((float *)a2 + 6), v13 >= 0.0) ? (v14 = v13 <= 1.0) : (v14 = 0),
        !v14
     || ((v15 = *((float *)a2 + 12), v15 >= 0.0) ? (BOOL v16 = v15 <= 1.0) : (BOOL v16 = 0),
         !v16 || ((_S3 = *((float *)a2 + 18), _S3 >= 0.0) ? (BOOL v18 = _S3 <= 1.0) : (BOOL v18 = 0), !v18))))
  {
LABEL_21:
    long long v61 = 0u;
    long long v62 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v58 = 0u;
    if (CA::ColorMatrix::is_alpha_identity(a2) || a4 && CA::ColorMatrix::is_opaque_identity(a2))
    {
      if (*((float *)a2 + 4) == 0.0
        && *((float *)a2 + 9) == 0.0
        && *((float *)a2 + 14) == 0.0
        && *((float *)a2 + 19) == 0.0)
      {
        char v19 = v7 ? 22 : 18;
        *(unsigned char *)(*((void *)this + 2) + 16) = v19;
        if ((*(unsigned int (**)(CA::OGL *))(*(void *)this + 984))(this))
        {
          int v20 = *((_DWORD *)a2 + 1);
          int v21 = *((_DWORD *)a2 + 5);
          unsigned int v22 = *((_DWORD *)a2 + 6);
          LODWORD(v58) = *(_DWORD *)a2;
          DWORD1(v58) = v21;
          unsigned int v23 = *((_DWORD *)a2 + 11);
          DWORD2(v58) = *((_DWORD *)a2 + 10);
          HIDWORD(v58) = v20;
          *(void *)&long long v59 = __PAIR64__(v23, v22);
          int v24 = *((_DWORD *)a2 + 7);
          DWORD2(v59) = *((_DWORD *)a2 + 2);
          HIDWORD(v59) = v24;
          uint64_t v25 = 3;
          uint64_t v26 = 3;
          LODWORD(v60) = *((_DWORD *)a2 + 12);
          return (*(uint64_t (**)(CA::OGL *, void, uint64_t, uint64_t, long long *))(*(void *)this + 1000))(this, 0, v25, v26, &v58);
        }
      }
      if (v7) {
        char v27 = 23;
      }
      else {
        char v27 = 19;
      }
      *(unsigned char *)(*((void *)this + 2) + 16) = v27;
      if ((*(unsigned int (**)(CA::OGL *))(*(void *)this + 984))(this))
      {
        int v28 = *((_DWORD *)a2 + 1);
        unsigned int v30 = *((_DWORD *)a2 + 4);
        int v29 = *((_DWORD *)a2 + 5);
        LODWORD(v58) = *(_DWORD *)a2;
        DWORD1(v58) = v29;
        unsigned int v31 = *((_DWORD *)a2 + 9);
        DWORD2(v58) = *((_DWORD *)a2 + 10);
        HIDWORD(v58) = v28;
        int v32 = *((_DWORD *)a2 + 7);
        int v33 = *((_DWORD *)a2 + 11);
        unsigned int v34 = *((_DWORD *)a2 + 12);
        LODWORD(v59) = *((_DWORD *)a2 + 6);
        DWORD1(v59) = v33;
        DWORD2(v59) = *((_DWORD *)a2 + 2);
        HIDWORD(v59) = v32;
        *(void *)&long long v60 = __PAIR64__(v30, v34);
        uint64_t v26 = 4;
        uint64_t v25 = 3;
        *((void *)&v60 + 1) = __PAIR64__(*((_DWORD *)a2 + 14), v31);
        return (*(uint64_t (**)(CA::OGL *, void, uint64_t, uint64_t, long long *))(*(void *)this + 1000))(this, 0, v25, v26, &v58);
      }
    }
    if (a5) {
      char v35 = 20;
    }
    else {
      char v35 = 21;
    }
    if (v7) {
      char v35 = 24;
    }
    *(unsigned char *)(*((void *)this + 2) + 16) = v35;
    unsigned int v36 = *((_DWORD *)a2 + 1);
    unsigned int v38 = *((_DWORD *)a2 + 4);
    int v37 = *((_DWORD *)a2 + 5);
    LODWORD(v58) = *(_DWORD *)a2;
    DWORD1(v58) = v37;
    unsigned int v39 = *((_DWORD *)a2 + 11);
    unsigned int v41 = *((_DWORD *)a2 + 14);
    int v40 = *((_DWORD *)a2 + 15);
    DWORD2(v58) = *((_DWORD *)a2 + 10);
    HIDWORD(v58) = v40;
    int v42 = *((_DWORD *)a2 + 7);
    *(void *)&long long v59 = __PAIR64__(*((_DWORD *)a2 + 6), v36);
    int v43 = *((_DWORD *)a2 + 17);
    *((void *)&v59 + 1) = __PAIR64__(*((_DWORD *)a2 + 16), v39);
    unsigned int v44 = *((_DWORD *)a2 + 3);
    LODWORD(v60) = *((_DWORD *)a2 + 2);
    DWORD1(v60) = v42;
    unsigned int v45 = *((_DWORD *)a2 + 13);
    DWORD2(v60) = *((_DWORD *)a2 + 12);
    HIDWORD(v60) = v43;
    unsigned int v46 = *((_DWORD *)a2 + 9);
    *(void *)&long long v61 = __PAIR64__(*((_DWORD *)a2 + 8), v44);
    unsigned int v47 = *((_DWORD *)a2 + 19);
    *((void *)&v61 + 1) = __PAIR64__(*((_DWORD *)a2 + 18), v45);
    *(void *)&long long v62 = __PAIR64__(v46, v38);
    uint64_t v26 = 5;
    uint64_t v25 = 4;
    *((void *)&v62 + 1) = __PAIR64__(v47, v41);
    return (*(uint64_t (**)(CA::OGL *, void, uint64_t, uint64_t, long long *))(*(void *)this + 1000))(this, 0, v25, v26, &v58);
  }
  _S0 = _S3 * v11;
  _S1 = v13 * _S3;
  _S2 = v15 * _S3;
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S1
    FCVT            H2, S2
    FCVT            H3, S3
  }
  float v56 = (_WORD *)*((void *)this + 2);
  _DWORD v56[4] = LOWORD(_S0);
  v56[5] = LOWORD(_S1);
  v56[6] = LOWORD(_S2);
  v56[7] = _H3;
  if (v7) {
    char v57 = 4;
  }
  else {
    char v57 = 3;
  }
  *(unsigned char *)(*((void *)this + 2) + 16) = v57;
  return result;
}

void CA::OGL::GaussianBlurFilter::render(float a1, float a2, uint64_t a3, CA::Render::KeyValueArray **a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if ((CA::OGL::GaussianBlurFilter::render(CA::Render::Filter const*,CA::OGL::Layer const*,CA::OGL::Context &,float,CA::OGL::Surface *,float,BOOL,CA::ColorMatrix const*,CA::Shape const*,float *)const::initialized & 1) == 0)
  {
    CA::OGL::GaussianBlurFilter::render(CA::Render::Filter const*,CA::OGL::Layer const*,CA::OGL::Context &,float,CA::OGL::Surface *,float,BOOL,CA::ColorMatrix const*,CA::Shape const*,float *)const::all_linear = CFPreferencesGetAppBooleanValue(@"CALinearBlurs", (CFStringRef)*MEMORY[0x1E4F1D3D8], 0) != 0;
    CA::OGL::GaussianBlurFilter::render(CA::Render::Filter const*,CA::OGL::Layer const*,CA::OGL::Context &,float,CA::OGL::Surface *,float,BOOL,CA::ColorMatrix const*,CA::Shape const*,float *)const::initialized = 1;
  }
  if (a7)
  {
    long long v55 = 0u;
    long long v56 = 0u;
    long long v54 = 0u;
    DWORD1(v56) = 15;
    uint64_t v20 = *(void *)(*(void *)(a6 + 248) + 24);
    double v51 = 0.0;
    double v52 = 0.0;
    if ((*(unsigned char *)(v20 + 144) & 0x10) != 0)
    {
      CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v20, &v52, &v51, (double *)a6);
      double v21 = v51;
      double v22 = v52;
    }
    else
    {
      double v21 = *(double *)(v20 + 128);
      double v51 = v21;
      double v52 = v21;
      double v22 = v21;
    }
    float v23 = v22;
    float v24 = v21;
    float float_key = CA::Render::KeyValueArray::get_float_key(a4[5], 310, 0.0);
    float v26 = float_key * a2;
    v53[0] = v26 * v23;
    v53[1] = v26 * v24;
    *(_OWORD *)&v49[0].top = 0u;
    long long v50 = 0u;
    if (CA::OGL::GaussianBlurFilter::get_bounds(v27, (const CA::Render::Filter *)a4, *(const CA::Render::Layer **)(a5 + 24), v49))
    {
      CA::Rect::apply_transform((int8x16_t *)v49, (const CA::Transform *)v20, v28);
      *(void *)&long long v55 = v49;
    }
    int v29 = a4[5];
    if (v29 && (uint64_t v30 = *((unsigned int *)v29 + 4), v30))
    {
      uint64_t v31 = 0;
      while (1)
      {
        uint64_t v32 = *((void *)v29 + v31 + 3);
        if (*(_DWORD *)(v32 + 16) == 309) {
          break;
        }
        if (v30 == ++v31) {
          goto LABEL_40;
        }
      }
      if ((v31 & 0x80000000) != 0 || (uint64_t v41 = *(void *)(v32 + 24)) == 0 || *(unsigned char *)(v41 + 12) != 49)
      {
LABEL_40:
        char v33 = 0;
        goto LABEL_41;
      }
      int v42 = (const char *)(v41 + 28);
      if (!strcmp((const char *)(v41 + 28), "low"))
      {
        char v33 = 2;
      }
      else
      {
        if (strcmp(v42, "high")) {
          goto LABEL_40;
        }
        char v33 = 4;
      }
      BYTE8(v56) = v33;
LABEL_41:
      uint64_t v43 = 0;
      while (1)
      {
        uint64_t v44 = *((void *)v29 + v43 + 3);
        if (*(_DWORD *)(v44 + 16) == 302) {
          break;
        }
        if (v30 == ++v43) {
          goto LABEL_16;
        }
      }
      if ((v43 & 0x80000000) == 0)
      {
        uint64_t v45 = *(void *)(v44 + 24);
        if (v45)
        {
          if (*(unsigned char *)(v45 + 12) == 49)
          {
            unsigned int v46 = (const char *)(v45 + 28);
            if (!strcmp((const char *)(v45 + 28), "medium"))
            {
              int v47 = 31;
              int v34 = 31;
              goto LABEL_55;
            }
            if (!strcmp(v46, "high"))
            {
              int v34 = 63;
              int v47 = 47;
LABEL_55:
              DWORD1(v56) = v47;
LABEL_17:
              if ((*(unsigned char *)(*(void *)(a5 + 16) + 25) & 4) != 0 || (*(unsigned char *)(a5 + 36) & 0x10) != 0) {
                DWORD1(v56) = v34;
              }
              char v35 = v33 | a8;
              *((void *)&v55 + 1) = a10;
              *((void *)&v54 + 1) = a9;
              if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a6 + 184))(a6, 24)
                && (CA::OGL::GaussianBlurFilter::render(CA::Render::Filter const*,CA::OGL::Layer const*,CA::OGL::Context &,float,CA::OGL::Surface *,float,BOOL,CA::ColorMatrix const*,CA::Shape const*,float *)const::all_linear
                 || CA::Render::KeyValueArray::get_int_key(a4[5], 303, 0)))
              {
                char v36 = 8 * ((*(unsigned char *)(a7 + 68) & 0x30) == 0);
              }
              else
              {
                char v36 = 0;
              }
              int v37 = a4[5];
              BYTE8(v56) = v35 | v36 | (16 * (CA::Render::KeyValueArray::get_int_key(v37, 292, 0) != 0));
              if (CA::Render::KeyValueArray::get_int_key(v37, 300, 0)
                || CA::Render::KeyValueArray::get_rect_key((uint64_t)v37, &v48))
              {
                LODWORD(v56) = 1;
              }
              if (CA::Render::KeyValueArray::get_int_key(v37, 305, 0)) {
                LODWORD(v56) = 2;
              }
              uint64_t v38 = *(void *)(a6 + 16);
              unint64_t v39 = *(void *)(v38 + 16) & 0xFFFFFF00FF00FF00;
              if (*(void *)(v38 + 8) == 0x3C003C003C003C00) {
                int v40 = 1;
              }
              else {
                int v40 = 3;
              }
              *(_DWORD *)(v38 + 16) = v40 | v39;
              *(_DWORD *)(v38 + 20) = HIDWORD(v39);
              (*(void (**)(uint64_t, uint64_t, float *, uint64_t, float, float))(*(void *)a6 + 848))(a6, a7, v53, a11, a1, a2);
              *(unsigned char *)(*(void *)(a6 + 16) + 16) = 0;
              return;
            }
          }
        }
      }
    }
    else
    {
      char v33 = 0;
    }
LABEL_16:
    int v34 = 31;
    goto LABEL_17;
  }
}

void CA::OGL::Context::blur_surface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float a5, float a6, double a7, double a8, float64x2_t a9)
{
  uint64_t v378 = *MEMORY[0x1E4F143B8];
  if (BYTE5(xmmword_1EB2ACBF0))
  {
    uint64_t PerfHud = CA::OGL::GetPerfHud((CA::OGL *)a1);
    if (PerfHud) {
      ++*(void *)(PerfHud + 464);
    }
  }
  if (*(_DWORD *)(a2 + 24)
    && *(_DWORD *)(a2 + 28)
    && (*(_DWORD *)a3 & 0x7FFFFFFFu) <= 0x7F7FFFFF
    && (*(_DWORD *)(a3 + 4) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
  {
    uint64_t v338 = a2;
    if ((*(unsigned char *)(a3 + 48) & 8) != 0) {
      uint64_t v338 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 680))(a1, a2, 1);
    }
    uint64_t v333 = a2;
    int32x4_t v345 = 0uLL;
    float v15 = *(int8x16_t **)(a3 + 24);
    unint64_t v16 = *(void *)(a3 + 32);
    uint64_t v339 = a4;
    if (!v15)
    {
      int v31 = 0;
      int v29 = 0;
      __int32 v32 = 0;
      uint64_t v39 = 0;
      unsigned int v40 = *(unsigned __int8 *)(a3 + 48);
      goto LABEL_37;
    }
    int8x16_t v17 = *v15;
    int8x16_t v18 = v15[1];
    if (a6 != 1.0)
    {
      double v19 = a6;
      a9.f64[0] = 1.79769313e308;
      int8x16_t v20 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a9, (float64x2_t)v18).i64[0], 0);
      v21.i64[1] = v15->i64[1];
      *(double *)v21.i64 = a6 * *(double *)v17.i64;
      int8x16_t v17 = vbslq_s8(v20, v21, v17);
      v21.i64[1] = v15[1].i64[1];
      *(double *)v21.i64 = a6 * *(double *)v18.i64;
      int8x16_t v18 = vbslq_s8(v20, v21, v18);
      if (*(double *)&v18.i64[1] < 1.79769313e308)
      {
        v17.i64[1] = vmuld_lane_f64(v19, (float64x2_t)v17, 1);
        *(double *)&v18.i64[1] = *(double *)&v18.i64[1] * v19;
      }
    }
    int8x16_t v22 = (int8x16_t)vceqzq_f64((float64x2_t)v18);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v22, 1), v22).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v23 = vorrq_s8((int8x16_t)vcltzq_f64((float64x2_t)v18), (int8x16_t)vcgezq_f64((float64x2_t)v18)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v23), 1), v23).u64[0] & 0x8000000000000000) != 0))
    {
      int v31 = 0;
      int v29 = 0;
      __int32 v32 = 0;
      __int32 v33 = 0;
      v28.i64[0] = 0;
      int32x2_t v30 = 0;
    }
    else
    {
      float64x2_t v24 = vmaxnmq_f64((float64x2_t)v17, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000));
      float64x2_t v25 = vminnmq_f64(vaddq_f64((float64x2_t)v17, (float64x2_t)v18), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
      int32x4_t v26 = (int32x4_t)vcvtmq_s64_f64(v24);
      int32x4_t v27 = (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v25), (int64x2_t)v26);
      int32x4_t v28 = vuzp1q_s32(v26, v27);
      int32x4_t v345 = v28;
      int v29 = v28.i32[2];
      int32x2_t v30 = (int32x2_t)v28.u64[1];
      int v31 = v27.i32[2];
      __int32 v32 = v26.i32[2];
      __int32 v33 = v26.i32[0];
    }
    if (v16)
    {
      int32x2_t v335 = *(int32x2_t *)v28.i8;
      int32x4_t __dst = 0uLL;
      int32x2_t v342 = v30;
      CA::Shape::get_bounds(v16, __dst.i32);
      int32x2_t v34 = (int32x2_t)__dst.u64[1];
      uint32x2_t v35 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v342);
      uint32x2_t v36 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)__dst.u64[1]);
      unsigned __int32 v37 = vpmax_u32(v36, v36).u32[0];
      if ((vpmax_u32(v35, v35).u32[0] & 0x80000000) != 0)
      {
        if ((v37 & 0x80000000) != 0) {
          goto LABEL_24;
        }
        int32x2_t v38 = *(int32x2_t *)__dst.i8;
      }
      else
      {
        if ((v37 & 0x80000000) != 0) {
          goto LABEL_24;
        }
        int32x2_t v38 = vmin_s32(v335, *(int32x2_t *)__dst.i8);
        int32x2_t v34 = vsub_s32(vmax_s32(vadd_s32(v335, v342), vadd_s32(*(int32x2_t *)__dst.i8, (int32x2_t)__dst.u64[1])), v38);
      }
      __int32 v32 = v38.i32[1];
      __int32 v33 = v38.i32[0];
      *(int32x2_t *)v345.i8 = v38;
      v345.u64[1] = (unint64_t)v34;
      int v29 = v34.i32[0];
      int v31 = v34.i32[1];
    }
LABEL_24:
    unsigned int v40 = *(unsigned __int8 *)(a3 + 48);
    if ((v40 & 1) == 0)
    {
      int v41 = v29 <= v31 ? v31 : v29;
      int v42 = v29 >= v31 ? v31 : v29;
      if (v41 <= 1073741822 && v42 >= 1)
      {
        ++v32;
        v345.i32[0] = v33 + 1;
        v345.i32[1] = v32;
        v29 -= 2;
        v31 -= 2;
        v345.i64[1] = __PAIR64__(v31, v29);
        if (v29 < 1 || v31 <= 0)
        {
          int v31 = 0;
          int v29 = 0;
          v345.i64[1] = 0;
        }
      }
    }
    a4 = v339;
    uint64_t v39 = *(void *)(a3 + 24);
LABEL_37:
    long long v371 = 0u;
    long long v370 = 0u;
    long long v369 = 0u;
    long long v368 = 0u;
    long long v367 = 0u;
    int v43 = ((v40 & 4) << 15) ^ 0x20000 | *(_DWORD *)(a3 + 44);
    int64x2_t v364 = (CA::OGL::Context *)a1;
    uint64_t v365 = v338;
    long long v366 = *(_OWORD *)(v338 + 32);
    LOWORD(v367) = -1;
    BYTE2(v367) = 1;
    DWORD1(v367) = v43;
    __asm { FMOV            V0.2S, #1.0 }
    long long v370 = _D0;
    *(void *)&long long v371 = 0;
    if (v16)
    {
      *((void *)&v367 + 1) = CA::Shape::ref(v16);
      unsigned int v40 = *(unsigned __int8 *)(a3 + 48);
    }
    DWORD2(v371) = *(_DWORD *)(a3 + 40);
    unsigned int v48 = v40 >> 2;
    BYTE12(v371) = v48 & 4 | (v39 != 0) | v48 & 2;
    if ((v48 & 2) != 0) {
      DWORD1(v367) = v43 | 0x80;
    }
    int32x4_t __dst = 0uLL;
    CA::Shape::get_bounds(*(void *)(*(void *)(a1 + 248) + 8), __dst.i32);
    double v51 = *(int32x2_t **)(a1 + 264);
    if (v51) {
      double v52 = v51 + 4;
    }
    else {
      double v52 = (int32x2_t *)(a1 + 200);
    }
    int32x2_t v53 = (int32x2_t)__dst.u64[1];
    v50.i32[1] = 1;
    uint32x2_t v54 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)__dst.u64[1]);
    *(uint32x2_t *)v49.i8 = vpmax_u32(v54, v54);
    if ((v49.i32[0] & 0x80000000) == 0)
    {
      *(int32x2_t *)v49.i8 = v52[1];
      uint32x2_t v55 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v49.i8);
      *(uint32x2_t *)v50.i8 = vpmax_u32(v55, v55);
      if (v50.i32[0] < 0
        || (int32x2_t v56 = vadd_s32(*v52, *(int32x2_t *)v49.i8),
            *(int32x2_t *)v49.i8 = vmax_s32(*(int32x2_t *)__dst.i8, *v52),
            int32x2_t v53 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)__dst.i8, (int32x2_t)__dst.u64[1]), v56), *(int32x2_t *)v49.i8), v57 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v53), *(uint32x2_t *)v50.i8 = vpmax_u32(v57, v57), v50.i32[0] < 0))
      {
        int32x2_t v53 = 0;
      }
      else
      {
        v49.u64[1] = (unint64_t)v53;
        int32x4_t __dst = v49;
      }
    }
    int v58 = v53.i32[0];
    if (v53.i32[0] <= v53.i32[1]) {
      int v58 = v53.i32[1];
    }
    v49.i32[0] = v58;
    v50.i32[0] = 1073741822;
    v59.i64[0] = __dst.i32[0];
    v59.i64[1] = __dst.i32[1];
    float64x2_t v60 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v49, v50), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v59));
    v59.i64[0] = v53.i32[0];
    v59.i64[1] = v53.i32[1];
    int8x16_t v61 = (int8x16_t)vcvtq_f64_s64(v59);
    int32x2_t v62 = vdup_n_s32(v58 > 1073741822);
    v59.i64[0] = v62.u32[0];
    v59.i64[1] = v62.u32[1];
    int8x16_t v63 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v59, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v61);
    int8x16_t v64 = (int8x16_t)vsubq_f64(v60, vcvtq_f64_f32(*(float32x2_t *)(a3 + 8)));
    float v65 = a6 / a5;
    double v66 = (float)(a6 / a5);
    _ZF = *(double *)v63.i64 >= 1.79769313e308 || v65 == 1.0;
    v68.i64[1] = v64.i64[1];
    v69.i64[1] = v63.i64[1];
    if (_ZF) {
      unint64_t v70 = 0;
    }
    else {
      unint64_t v70 = -1;
    }
    int8x16_t v71 = (int8x16_t)vdupq_n_s64(v70);
    *(double *)v69.i64 = v66 * *(double *)v63.i64;
    float64x2_t v72 = (float64x2_t)vbslq_s8(v71, v69, v63);
    *(double *)v68.i64 = v66 * *(double *)v64.i64;
    float64x2_t v73 = (float64x2_t)vbslq_s8(v71, v68, v64);
    if (v65 != 1.0 && v72.f64[1] < 1.79769313e308)
    {
      v73.f64[1] = vmuld_lane_f64(v66, v73, 1);
      v72.f64[1] = v72.f64[1] * v66;
    }
    int8x16_t v74 = (int8x16_t)vceqzq_f64(v72);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v74, 1), v74).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v75 = vorrq_s8((int8x16_t)vcltzq_f64(v72), (int8x16_t)vcgezq_f64(v72)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v75), 1), v75).u64[0] & 0x8000000000000000) != 0))
    {
      int v79 = 0;
      int v78 = 0;
      int32x4_t __dst = 0uLL;
      int32x2_t v80 = 0;
      int32x2_t v81 = 0;
    }
    else
    {
      int32x4_t v76 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v73, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      int32x4_t v77 = (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v73, v72), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v76);
      int32x4_t __dst = vuzp1q_s32(v76, v77);
      int v78 = __dst.i32[2];
      int v79 = v77.i32[2];
      int32x2_t v80 = (int32x2_t)__dst.u64[1];
      int32x2_t v81 = vmovn_s64((int64x2_t)v76);
      v81.i32[0] = v76.i32[0];
    }
    if (v78 <= v79) {
      int v82 = v79;
    }
    else {
      int v82 = v78;
    }
    if (v78 >= v79) {
      int v83 = v79;
    }
    else {
      int v83 = v78;
    }
    if (v82 <= 1073741822 && v83 >= 1)
    {
      int32x2_t v84 = vcvt_s32_f32(vneg_f32(vrndp_f32(vcvt_f32_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)a3), (float64x2_t)vdupq_n_s64(0x4006666666666666uLL))))));
      int v85 = v78 - 2 * v84.i32[0];
      *(int32x2_t *)__dst.i8 = vadd_s32(v81, v84);
      __dst.i32[2] = v85;
      __dst.i32[3] = v79 - 2 * v84.i32[1];
      BOOL v86 = __dst.i32[3] < 1 || v85 < 1;
      if (v86) {
        unsigned int v87 = -1;
      }
      else {
        unsigned int v87 = 0;
      }
      int32x2_t v80 = (int32x2_t)vbic_s8((int8x8_t)__dst.u64[1], (int8x8_t)vdup_n_s32(v87));
    }
    if (BYTE12(v371))
    {
      uint64_t v88 = (uint64_t)&v345.i64[1];
      if (!v39) {
        uint64_t v88 = 8;
      }
      uint32x2_t v89 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v80);
      if ((vpmax_u32(v89, v89).u32[0] & 0x80000000) == 0)
      {
        uint32x2_t v90 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v88);
        if ((vpmax_u32(v90, v90).u32[0] & 0x80000000) != 0
          || (int32x2_t v91 = vadd_s32(*(int32x2_t *)__dst.i8, v80),
              *(int32x2_t *)v92.i8 = vmax_s32(*(int32x2_t *)__dst.i8, *(int32x2_t *)v345.i8),
              int32x2_t v93 = vsub_s32(vmin_s32(v91, vadd_s32(*(int32x2_t *)v345.i8, *(int32x2_t *)v88)), *(int32x2_t *)v92.i8),
              uint32x2_t v94 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v93),
              (vpmax_u32(v94, v94).u32[0] & 0x80000000) != 0))
        {
          int32x2_t v80 = 0;
        }
        else
        {
          v92.u64[1] = (unint64_t)v93;
          int32x4_t __dst = v92;
          int32x2_t v80 = v93;
        }
      }
    }
    int32x2_t v95 = *(int32x2_t *)((char *)&v366 + 8);
    uint32x2_t v96 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v366 + 8));
    if ((vpmax_u32(v96, v96).u32[0] & 0x80000000) == 0)
    {
      uint32x2_t v97 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v80);
      if ((vpmax_u32(v97, v97).u32[0] & 0x80000000) != 0
        || (int32x2_t v98 = vadd_s32(*(int32x2_t *)__dst.i8, v80),
            *(int32x2_t *)&long long v99 = vmax_s32(*(int32x2_t *)&v366, *(int32x2_t *)__dst.i8),
            int32x2_t v95 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)&v366, *(int32x2_t *)((char *)&v366 + 8)), v98), *(int32x2_t *)&v99), v100 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v95), (vpmax_u32(v100, v100).u32[0] & 0x80000000) != 0))
      {
        int32x2_t v95 = 0;
        *((void *)&v366 + 1) = 0;
      }
      else
      {
        *((int32x2_t *)&v99 + 1) = v95;
        long long v366 = v99;
      }
    }
    int v101 = v95.i32[0];
    if (v95.i32[0] >= v95.i32[1]) {
      int v102 = v95.i32[1];
    }
    else {
      int v102 = v95.i32[0];
    }
    if (!a4 && v102 < 1) {
      goto LABEL_419;
    }
    DWORD1(v367) |= *(_DWORD *)(v338 + 68) & 0x30;
    int32x2_t v347 = (int32x2_t)v366;
    int8x8_t v348 = (int8x8_t)v95;
    if (v95.i32[0] <= v95.i32[1]) {
      int v101 = v95.i32[1];
    }
    if (v101 <= 1073741822 && v102 >= 1)
    {
      int32x2_t v103 = vadd_s32(*(int32x2_t *)&v366, (int32x2_t)-1);
      int8x8_t v104 = (int8x8_t)vadd_s32(v95, (int32x2_t)0x200000002);
      if (v104.i32[1] < 1 || v104.i32[0] < 1) {
        unsigned int v106 = -1;
      }
      else {
        unsigned int v106 = 0;
      }
      int32x2_t v347 = v103;
      int8x8_t v348 = vbic_s8(v104, (int8x8_t)vdup_n_s32(v106));
    }
    memset(&__dst, 0, 488);
    uint64_t v107 = *(const void **)(a1 + 16);
    memcpy(&__dst, v107, 0x1E8uLL);
    __dst.i64[0] = (uint64_t)v107;
    *(void *)(a1 + 16) = &__dst;
    long long v360 = 0u;
    long long v361 = 0u;
    long long v362 = 0u;
    long long v359 = 0u;
    uint64_t v108 = *(void *)(a1 + 248);
    *((void *)&v360 + 1) = 0x3C003C003C003C00;
    long long v361 = 0uLL;
    *(void *)&long long v362 = 0;
    WORD6(v362) = 1;
    uint64_t v358 = 0;
    if (v108)
    {
      float v109 = *(float *)(v108 + 64);
      WORD6(v362) = *(_WORD *)(v108 + 68) & 0x100 | 1;
      __int16 v110 = WORD6(v362) | *(_WORD *)(v108 + 68) & 0x400;
    }
    else
    {
      __int16 v110 = 1025;
      float v109 = 1.0;
    }
    *((float *)&v362 + 2) = v109;
    WORD6(v362) = v110;
    *(void *)&long long v360 = &CA::identity_transform;
    memset(v357, 0, sizeof(v357));
    CA::Shape::operator=((uint64_t)v357, &v347);
    if (v16) {
      int32x4_t v111 = (_OWORD *)v16;
    }
    else {
      int32x4_t v111 = v357;
    }
    long long v359 = (unint64_t)v111;
    uint64_t v358 = CA::OGL::Context::set_gstate(a1, (uint64_t)&v358);
    int v331 = *(unsigned __int8 *)(a1 + 64);
    *(unsigned char *)(*(void *)(a1 + 16) + 481) &= ~1u;
    *(unsigned char *)(a1 + 64) = 0;
    *(unsigned char *)(*(void *)(a1 + 16) + 16) = 0;
    double v112 = COERCE_DOUBLE(vcvt_f32_s32(*(int32x2_t *)&v366));
    *(double *)&long long v368 = v112;
    *((float32x2_t *)&v368 + 1) = vcvt_f32_s32(vadd_s32(*(int32x2_t *)((char *)&v366 + 8), *(int32x2_t *)&v366));
    if (*(void *)(a3 + 24)
      && (*(unsigned char *)(a3 + 48) & 1) == 0
      && (*(_DWORD *)(v338 + 32) != v345.i32[0]
       || *(_DWORD *)(v338 + 36) != v32
       || *(_DWORD *)(v338 + 40) != v29
       || *(_DWORD *)(v338 + 44) != v31
       || *(_DWORD *)(v338 + 24) != v29
       || *(_DWORD *)(v338 + 28) != v31))
    {
      float v113 = 32.0;
      if (*(_DWORD *)(a3 + 40)) {
        float v113 = 16.0;
      }
      CA::OGL::BlurState::copy((float32x2_t *)&v364, v113);
    }
    if (DWORD2(v371) == 2)
    {
      LODWORD(v112) = 1.0;
      CA::OGL::PingPongState::scale_and_dilate((CA::OGL::PingPongState *)&v364, v112, 1.0, 1, 1);
    }
    char v114 = *(unsigned char *)(a3 + 48);
    float v115 = *(float *)a3 * *(float *)a3;
    float v116 = *(float *)(a3 + 4) * *(float *)(a3 + 4);
    int v117 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 184))(a1, 15);
    if (v117 >= 27) {
      int v118 = 27;
    }
    else {
      int v118 = v117;
    }
    if (v118 <= 15) {
      uint64_t v119 = 15;
    }
    else {
      uint64_t v119 = v118;
    }
    if (v119 <= 0x1A)
    {
      double v120 = 5.25;
      uint64_t v121 = (_DWORD *)v339;
      if (v119 <= 0x16)
      {
        double v120 = 4.35;
        if (v119 <= 0x12) {
          double v120 = 3.5;
        }
      }
    }
    else
    {
      double v120 = 6.1;
      uint64_t v121 = (_DWORD *)v339;
    }
    uint64_t v122 = &v365;
    double v123 = v115;
    double v124 = v116;
    uint64_t v334 = a3;
    unint64_t v332 = v16;
    double v330 = v120;
    if ((v114 & 4) != 0)
    {
      BOOL v131 = (v114 & 2) == 0;
      BOOL v132 = fmax(v123, v124) > 100.0;
      BOOL v133 = v131 && v132;
      if (v131 && v132) {
        double v134 = 7.5;
      }
      else {
        double v134 = 3.5;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 184))(a1, 13))
      {
LABEL_157:
        double v137 = v124 * 0.0625 + -1.1025;
        while (1)
        {
          v136.n128_u32[1] = 1068498944;
          double v138 = v123 * 0.0625 + -1.1025;
          if (v138 < v134) {
            break;
          }
          v136.n128_u32[0] = 0.25;
          CA::OGL::PingPongState::scale_and_dilate((CA::OGL::PingPongState *)&v364, v136.n128_f64[0], 1.0, 4, 0);
          CA::OGL::BlurState::downsample_blur_4((float32x2_t *)&v364, 4.0, 1.0, flt_1849997E0, v139);
          double v123 = v123 * 0.0625 + -1.1025;
          if (v137 >= v134)
          {
LABEL_162:
            v136.n128_u32[0] = 1.0;
            CA::OGL::PingPongState::scale_and_dilate((CA::OGL::PingPongState *)&v364, v136.n128_f64[0], 0.25, 0, 4);
            double v123 = v138;
            double v124 = v124 * 0.0625 + -1.1025;
            goto LABEL_157;
          }
        }
        double v138 = v123;
        if (v137 >= v134) {
          goto LABEL_162;
        }
      }
      v136.n128_u32[1] = 1076396032;
      if (v133) {
        double v141 = 56.25;
      }
      else {
        double v141 = 12.25;
      }
      BOOL v142 = v124 > v141;
      BOOL v143 = v123 > v141;
      if (v123 <= v141 && v124 <= v141)
      {
        uint64_t v122 = &v365;
      }
      else
      {
        uint64_t v122 = &v365;
        do
        {
          if (v143)
          {
            v136.n128_u32[0] = 0.5;
            CA::OGL::PingPongState::scale_and_dilate((CA::OGL::PingPongState *)&v364, v136.n128_f64[0], 1.0, 2, 0);
            CA::OGL::BlurState::downsample_blur_2((float32x2_t *)&v364, 2.0, 1.0, flt_184999834, v145);
            double v123 = v123 * 0.25 + -2.56;
          }
          if (v142)
          {
            v136.n128_u32[0] = 1.0;
            CA::OGL::PingPongState::scale_and_dilate((CA::OGL::PingPongState *)&v364, v136.n128_f64[0], 0.5, 0, 2);
            double v124 = v124 * 0.25 + -2.56;
          }
          BOOL v142 = v124 > v141;
          BOOL v143 = v123 > v141;
        }
        while (v123 > v141 || v124 > v141);
      }
    }
    else
    {
      if ((v114 & 2) != 0)
      {
        double v130 = 20.0;
        double v129 = 5.5;
        double v329 = 3.5;
      }
      else
      {
        double v125 = fmax(v123, v124);
        double v126 = 5.5;
        if (v125 <= 100.0) {
          double v127 = 3.5;
        }
        else {
          double v127 = 5.5;
        }
        if (v125 > 100.0) {
          double v126 = 9.5;
        }
        double v128 = v127 + 1.0;
        if (v125 > 3600.0)
        {
          double v129 = v126 + 1.0;
        }
        else
        {
          double v128 = v127;
          double v129 = v126;
        }
        if (v125 <= 3600.0) {
          double v130 = 20.0;
        }
        else {
          double v130 = 21.0;
        }
        if (v125 <= 10000.0)
        {
          double v329 = v128;
        }
        else
        {
          double v329 = v128 + 1.0;
          double v129 = v129 + 1.0;
          double v130 = v130 + 1.0;
        }
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 184))(a1, 14))
      {
        double v148 = v130 * v130;
        if (v148 < v123 && v148 < v124)
        {
          HIDWORD(v149) = 0;
          do
          {
            LODWORD(v149) = 0.125;
            CA::OGL::PingPongState::scale_and_dilate((CA::OGL::PingPongState *)&v364, v149, 0.125, 0, 0);
            if ((CA::OGL::BlurState::tile_downsample((float32x2_t *)&v364, 8) & 1) == 0)
            {
              uint64_t v150 = v364;
              uint64_t v151 = (BYTE12(v371) & 1) != 0 ? 16 : 32;
              if (CA::OGL::PingPongState::attach_dest((float32x2_t *)&v364, 1, v151))
              {
                uint64_t v152 = (uint64_t *)&v370 + (v367 & 1) + 1;
                if ((v367 & 0x8000u) != 0) {
                  uint64_t v152 = &v365;
                }
                uint64_t v153 = *v152;
                int v154 = *(_DWORD *)(*v152 + 32);
                int v155 = *(_DWORD *)(*v152 + 36);
                v353[0] = (CA::Shape *)__PAIR64__(v155, v154);
                CA::OGL::Context::bind_surface((uint64_t)v364, v153, 0, 1u, 1, 0.0);
                float v156 = 32.0;
                if (BYTE12(v371)) {
                  float v156 = 16.0;
                }
                CA::OGL::BlurState::process_edges((CA::OGL::BlurState *)&v364, v156, 8.0, 8.0, (int *)v353);
                *(unsigned char *)(*((void *)v150 + 2) + 16) = 28;
                uint64_t v157 = *((void *)v150 + 2);
                float v158 = *(float *)(v157 + 100);
                v372[0].i32[0] = *(_DWORD *)(v157 + 96);
                *(uint64_t *)((char *)v372[0].i64 + 4) = __PAIR64__(v372[0].u32[0], LODWORD(v158));
                v372[0].f32[3] = v158 * 3.0;
                v372[1].f32[0] = v372[0].f32[0] * 3.0;
                v372[1].f32[1] = v158;
                v372[1].f32[2] = v372[0].f32[0] * 3.0;
                v372[1].f32[3] = v158 * 3.0;
                (*(void (**)(CA::OGL::Context *, void, uint64_t, uint64_t, float32x4_t *))(*(void *)v150 + 1000))(v150, 0, 2, 4, v372);
                *((void *)v150 + 16) = 0;
                *((void *)v150 + 12) = (char *)v150 + 834;
                *(_OWORD *)((char *)v150 + 104) = xmmword_184997E70;
                *(void *)&v349[0] = 0;
                CA::OGL::PingPongState::render_pass((uint64_t)&v364, v154, v155, 0, (uint64_t *)v349, 8.0, 8.0, 0.0, 0.0);
                CA::OGL::Context::array_flush((uint64_t)v150);
                signed int v159 = (uint64_t *)&v370 + (v367 & 1) + 1;
                if ((v367 & 0x8000u) != 0) {
                  signed int v159 = &v365;
                }
                CA::OGL::Context::unbind_surface(v364, *v159, 0);
                *(unsigned char *)(*((void *)v150 + 2) + 16) = 0;
                CA::OGL::Context::pop_surface(v364);
                LOWORD(v367) = v367 + 1;
              }
            }
            HIDWORD(v149) = 1066401792;
            double v123 = v123 * 0.015625 + -0.140625;
            double v124 = v124 * 0.015625 + -0.140625;
          }
          while (v123 > v148 && v124 > v148);
        }
      }
      double v161 = v129 * v129;
      if (v123 > v129 * v129 && v124 > v161)
      {
        HIDWORD(v163) = 0;
        do
        {
          LODWORD(v163) = 0.25;
          CA::OGL::PingPongState::scale_and_dilate((CA::OGL::PingPongState *)&v364, v163, 0.25, 0, 0);
          if ((CA::OGL::BlurState::tile_downsample((float32x2_t *)&v364, 4) & 1) == 0)
          {
            int v164 = v364;
            uint64_t v165 = (BYTE12(v371) & 1) != 0 ? 16 : 32;
            if (CA::OGL::PingPongState::attach_dest((float32x2_t *)&v364, 1, v165))
            {
              uint64_t v166 = (uint64_t *)&v370 + (v367 & 1) + 1;
              if ((v367 & 0x8000u) != 0) {
                uint64_t v166 = &v365;
              }
              uint64_t v167 = *v166;
              int v169 = *(_DWORD *)(*v166 + 32);
              int v168 = *(_DWORD *)(*v166 + 36);
              v353[0] = (CA::Shape *)__PAIR64__(v168, v169);
              CA::OGL::Context::bind_surface((uint64_t)v364, v167, 0, 1u, 1, 0.0);
              if (BYTE12(v371)) {
                float v170 = 16.0;
              }
              else {
                float v170 = 32.0;
              }
              CA::OGL::BlurState::process_edges((CA::OGL::BlurState *)&v364, v170, 4.0, 4.0, (int *)v353);
              *(unsigned char *)(*((void *)v164 + 2) + 16) = 26;
              uint64_t v171 = *((void *)v164 + 2);
              int32x4_t v172 = (int32x4_t)vmulq_n_f32((float32x4_t)xmmword_184997F00, *(float *)(v171 + 100));
              int32x4_t v173 = (int32x4_t)vmulq_n_f32((float32x4_t)xmmword_184997EF0, *(float *)(v171 + 96));
              v372[1] = (float32x4_t)vzip2q_s32(v173, v172);
              v372[0] = (float32x4_t)vzip1q_s32(v173, v172);
              if ((*(unsigned int (**)(CA::OGL::Context *))(*(void *)v164 + 984))(v164))
              {
                (*(void (**)(CA::OGL::Context *, void, uint64_t, uint64_t, float32x4_t *))(*(void *)v164 + 1000))(v164, 0, 2, 4, v372);
                (*(void (**)(CA::OGL::Context *, uint64_t, uint64_t, uint64_t, void *))(*(void *)v164 + 1000))(v164, 1, 4, 1, &CA::OGL::BlurState::downsample_box_4(void)::weight);
                *((void *)v164 + 16) = 0;
                *((void *)v164 + 12) = (char *)v164 + 834;
                *(_OWORD *)((char *)v164 + 104) = xmmword_184997E70;
                *(void *)&v349[0] = 0;
                CA::OGL::PingPongState::render_pass((uint64_t)&v364, v169, v168, 0, (uint64_t *)v349, 4.0, 4.0, 0.0, 0.0);
                CA::OGL::Context::array_flush((uint64_t)v164);
              }
              else
              {
                uint64_t v174 = 0;
                *(unsigned char *)(*((void *)v164 + 2) + 16) = 3;
                *(unsigned char *)(*((void *)v164 + 2) + 480) = 12;
                *((void *)v164 + 16) = 0;
                uint64_t v175 = (char *)v164 + 834;
                *((void *)v164 + 12) = (char *)v164 + 834;
                *(_OWORD *)((char *)v164 + 104) = xmmword_184997E70;
                do
                {
                  if (*((_DWORD *)v164 + 23)) {
                    uint64_t v176 = 6;
                  }
                  else {
                    uint64_t v176 = 4;
                  }
                  if ((unint64_t)(*((void *)v164 + 16) + 4) > *((void *)v164 + 17)
                    || (unint64_t v177 = *((void *)v164 + 14)) != 0 && *((void *)v164 + 13) + v176 > v177)
                  {
                    *((_WORD *)v164 + 416) |= 0x20u;
                    CA::OGL::Context::array_flush((uint64_t)v164);
                    *((void *)v164 + 16) = 0;
                    *((void *)v164 + 12) = v175;
                    *(_OWORD *)((char *)v164 + 104) = xmmword_184997E70;
                  }
                  *(void *)&v349[0] = 0x3400340034003400;
                  CA::OGL::PingPongState::render_pass((uint64_t)&v364, v169, v168, 1, (uint64_t *)v349, 4.0, 4.0, *(float *)((char *)&CA::OGL::BlurState::downsample_box_4(void)::offset + v174), *(float *)((char *)&CA::OGL::BlurState::downsample_box_4(void)::offset + v174 + 4));
                  if (!v174)
                  {
                    CA::OGL::Context::array_flush((uint64_t)v164);
                    *(unsigned char *)(*((void *)v164 + 2) + 481) |= 1u;
                    *((void *)v164 + 16) = 0;
                    *((void *)v164 + 12) = v175;
                    *(_OWORD *)((char *)v164 + 104) = xmmword_184997E70;
                  }
                  v174 += 8;
                }
                while (v174 != 32);
                CA::OGL::Context::array_flush((uint64_t)v164);
                *(unsigned char *)(*((void *)v164 + 2) + 481) &= ~1u;
                uint64_t v122 = &v365;
                a3 = v334;
              }
              long long v178 = (uint64_t *)&v370 + (v367 & 1) + 1;
              if ((v367 & 0x8000u) != 0) {
                long long v178 = &v365;
              }
              CA::OGL::Context::unbind_surface(v364, *v178, 0);
              *(unsigned char *)(*((void *)v164 + 2) + 16) = 0;
              CA::OGL::Context::pop_surface(v364);
              LOWORD(v367) = v367 + 1;
            }
          }
          HIDWORD(v163) = 1068498944;
          double v123 = v123 * 0.0625 + -0.47265625;
          double v124 = v124 * 0.0625 + -0.47265625;
        }
        while (v123 > v161 && v124 > v161);
      }
      v136.n128_f64[0] = v329;
      double v180 = v136.n128_f64[0] * v136.n128_f64[0];
      if (v123 <= v136.n128_f64[0] * v136.n128_f64[0] || v124 <= v180)
      {
        uint64_t v121 = (_DWORD *)v339;
        uint64_t v119 = v119;
      }
      else
      {
        uint64_t v121 = (_DWORD *)v339;
        uint64_t v119 = v119;
        do
        {
          v136.n128_u32[0] = 0.5;
          CA::OGL::PingPongState::scale_and_dilate((CA::OGL::PingPongState *)&v364, v136.n128_f64[0], 0.5, 0, 0);
          if ((CA::OGL::BlurState::tile_downsample((float32x2_t *)&v364, 2) & 1) == 0) {
            CA::OGL::BlurState::downsample_box_2((float32x2_t *)&v364, 2.0, 2.0);
          }
          double v123 = v123 * 0.25 + -0.765625;
          double v124 = v124 * 0.25 + -0.765625;
        }
        while (v123 > v180 && v124 > v180);
      }
      BOOL v183 = v124 > v180;
      for (BOOL i = v123 > v180; v123 > v180 || v124 > v180; BOOL i = v123 > v180)
      {
        if (i)
        {
          v136.n128_u32[0] = 0.5;
          CA::OGL::PingPongState::scale_and_dilate((CA::OGL::PingPongState *)&v364, v136.n128_f64[0], 1.0, 0, 0);
          CA::OGL::BlurState::downsample_box_2((float32x2_t *)&v364, 2.0, 1.0);
          double v123 = v123 * 0.25 + -0.765625;
        }
        if (v183)
        {
          v136.n128_u32[0] = 1.0;
          CA::OGL::PingPongState::scale_and_dilate((CA::OGL::PingPongState *)&v364, v136.n128_f64[0], 0.5, 0, 0);
          CA::OGL::BlurState::downsample_box_2((float32x2_t *)&v364, 1.0, 2.0);
          double v124 = v124 * 0.25 + -0.765625;
        }
        BOOL v183 = v124 > v180;
      }
    }
    if (v123 <= v124) {
      double v187 = v124;
    }
    else {
      double v187 = v123;
    }
    v136.n128_u32[0] = v370;
    int v188 = 0;
    if (*(float *)&v370 == *((float *)&v370 + 1))
    {
      BOOL v189 = *(float *)&v370 != 1.0 && v121 == 0;
      BOOL v190 = !v189;
      if (v16 && v190) {
        int v188 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)a1 + 1080))(a1, v136) ^ 1;
      }
    }
    if (v187 <= 0.6 && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 992))(a1, 41))
    {
      LODWORD(v191) = 1.0;
      CA::OGL::PingPongState::scale_and_dilate((CA::OGL::PingPongState *)&v364, v191, 1.0, 1, 1);
      if (v188)
      {
        CA::OGL::Context::set_gstate(a1, **(void **)(a1 + 248));
        *(void *)(a1 + 16) = __dst.i64[0];
        __dst.i64[0] = 0;
        v353[0] = 0;
        v373.i64[0] = 0;
        memset(v372, 0, sizeof(v372));
        CA::OGL::copy_gstate((uint64_t)v372, *(void *)(a1 + 248));
        LODWORD(v192) = v370;
        v372[0].i64[0] = CA::OGL::Context::set_gstate(a1, (uint64_t)v372);
        float v198 = v123;
        float v199 = v124;
        CA::OGL::BlurState::single_pass_blur((float32x2_t *)&v364, v198, v199, 1);
        CA::OGL::BlurState::in_place_color_matrix(&v364, *(const CA::ColorMatrix **)(a3 + 16), 1);
        CA::OGL::Context::set_gstate(a1, **(void **)(a1 + 248));
        if (v353[0]) {
          CA::Shape::unref(v353[0]);
        }
        int v188 = 1;
      }
      else
      {
        float v280 = v123;
        float v281 = v124;
        CA::OGL::BlurState::single_pass_blur((float32x2_t *)&v364, v280, v281, 0);
      }
    }
    else
    {
      if ((v188 & 1) != 0
        || ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 184))(a1, 38)
          ? (BOOL v201 = DWORD2(v371) == 1)
          : (BOOL v201 = 1),
            v201 || (BYTE12(v371) & 2) != 0))
      {
        int v219 = vcvtpd_s64_f64(v123 / (v330 * v330));
        memset(v352, 0, sizeof(v352));
        uint64_t v356 = 0;
        long long v354 = 0u;
        long long v355 = 0u;
        *(_OWORD *)uint64_t v353 = 0u;
        memset(v351, 0, sizeof(v351));
        uint64_t v350 = 0;
        memset(v349, 0, sizeof(v349));
        unsigned int v220 = v219 & ~(v219 >> 31);
        float v221 = v123 / (double)(int)v220;
        int v343 = ((v119 - 8) & 0xFFFFFFFC) + 11;
        unsigned int v223 = (v119 - 8) >> 1;
        int v224 = (v223 & 0x7FFFFFFE) + 5;
        uint64_t v225 = -2;
        uint64_t v226 = 8;
        while (*(float *)((char *)v352 + v226) != 0.0)
        {
          v225 += 2;
          v226 += 4;
          if ((v223 & 0x7FFFFFFE) == v225)
          {
            long long v227 = (CA::OGL::_anonymous_namespace_ *)v119;
            int v336 = ((v119 - 8) & 0xFFFFFFFC) + 11;
            int v228 = (v223 & 0x7FFFFFFE) + 5;
            goto LABEL_315;
          }
        }
        long long v227 = (CA::OGL::_anonymous_namespace_ *)v119;
        int v228 = v225 + 5;
        int v336 = v226 - 1;
LABEL_315:
        int v229 = vcvtpd_s64_f64(v124 / (v330 * v330));
        unsigned int v230 = v229 & ~(v229 >> 31);
        float v231 = v124 / (double)(int)v230;
        uint64_t v233 = -2;
        uint64_t v234 = 8;
        while (*(float *)((char *)v351 + v234) != 0.0)
        {
          v233 += 2;
          v234 += 4;
          if ((v223 & 0x7FFFFFFE) == v233) {
            goto LABEL_320;
          }
        }
        int v224 = v233 + 5;
        int v343 = v234 - 1;
LABEL_320:
        BOOL v235 = v230 >= v220;
        BOOL v236 = v229 > 0;
        if (v229 <= 0) {
          BOOL v235 = 0;
        }
        v188 &= v235;
        BOOL v237 = v219 > 0;
        if (v219 > 0 || v229 >= 1)
        {
          int v238 = 1;
          do
          {
            unsigned int v239 = v238;
            BOOL v241 = (BYTE12(v371) & 1) == 0 || DWORD2(v371) == 1;
            if (v237 && v241) {
              signed int v242 = v228;
            }
            else {
              signed int v242 = 1;
            }
            if (v236 && v241) {
              signed int v243 = v224;
            }
            else {
              signed int v243 = 1;
            }
            LODWORD(v232) = 1.0;
            CA::OGL::PingPongState::scale_and_dilate((CA::OGL::PingPongState *)&v364, v232, 1.0, v242, v243);
            if (v237) {
              CA::OGL::BlurState::narrow_blur((float32x2_t *)&v364, v336, (const float *)v353, (const float *)v352, 0);
            }
            if (v236)
            {
              if (v230 == v239) {
                int v244 = v188;
              }
              else {
                int v244 = 0;
              }
              if (v244 == 1)
              {
                CA::OGL::Context::set_gstate(a1, **(void **)(a1 + 248));
                *(void *)(a1 + 16) = __dst.i64[0];
                __dst.i64[0] = 0;
                BOOL v346 = 0;
                v373.i64[0] = 0;
                v372[3] = 0u;
                v372[2] = 0u;
                v372[1] = 0u;
                v372[0] = 0u;
                uint64_t v245 = *(void *)(a1 + 248);
                *(float32x4_t *)((char *)v372 + 8) = *(float32x4_t *)(v245 + 8);
                uint64_t v246 = *(void *)(v245 + 32);
                v372[1].i64[1] = *(void *)(v245 + 24);
                v372[2].i64[0] = v246;
                *(float32x4_t *)((char *)&v372[2] + 8) = *(float32x4_t *)(v245 + 40);
                v372[3].i64[1] = *(void *)(v245 + 56);
                __int16 v247 = *(unsigned __int8 *)(v245 + 68);
                v373.i16[2] = v247;
                v373.i32[0] = *(_DWORD *)(v245 + 64);
                v373.i16[2] = *(_WORD *)(v245 + 68) & 0x100 | v247;
                v373.i16[2] |= *(_WORD *)(v245 + 68) & 0x400;
                v372[0].i64[0] = CA::OGL::Context::set_gstate(a1, (uint64_t)v372);
                CA::OGL::BlurState::narrow_blur((float32x2_t *)&v364, v343, (const float *)v349, (const float *)v351, 1);
                CA::OGL::BlurState::in_place_color_matrix(&v364, *(const CA::ColorMatrix **)(v334 + 16), 1);
                CA::OGL::Context::set_gstate(a1, **(void **)(a1 + 248));
                if (v346) {
                  CA::Shape::unref(v346);
                }
              }
              else
              {
                CA::OGL::BlurState::narrow_blur((float32x2_t *)&v364, v343, (const float *)v349, (const float *)v351, 0);
              }
            }
            BOOL v236 = v239 < v230;
            int v238 = v239 + 1;
            BOOL v237 = v239 < v220;
          }
          while (v239 < v220 || v239 < v230);
        }
      }
      else
      {
        LODWORD(v349[0]) = 0;
        int v202 = vcvtpd_s64_f64(v123 / (v330 * v330));
        LODWORD(v352[0]) = 0;
        unsigned int v203 = v202 & ~(v202 >> 31);
        float v204 = v123 / (double)(int)v203;
        int v205 = vcvtpd_s64_f64(v124 / (v330 * v330));
        unsigned int v206 = v205 & ~(v205 >> 31);
        float v207 = v124 / (double)(int)v206;
        BOOL v210 = v205 > 0;
        BOOL v86 = v202 <= 0;
        BOOL v211 = v202 > 0;
        if (!v86 || v205 >= 1)
        {
          int v212 = v349[0];
          int v213 = 1;
          int v214 = v352[0];
          do
          {
            unsigned int v215 = v213;
            BOOL v216 = (BYTE12(v371) & 1) == 0;
            if (v211 && v216) {
              signed int v217 = v212;
            }
            else {
              signed int v217 = 1;
            }
            if (v210 && v216) {
              signed int v218 = v214;
            }
            else {
              signed int v218 = 1;
            }
            LODWORD(v209) = 1.0;
            CA::OGL::PingPongState::scale_and_dilate((CA::OGL::PingPongState *)&v364, v209, 1.0, v217, v218);
            if (v211) {
              CA::OGL::BlurState::tile_simd_blur((float32x2_t *)&v364, v212, v372[0].f32);
            }
            if (v210) {
              CA::OGL::BlurState::tile_simd_blur((float32x2_t *)&v364, v214, (const float *)v353);
            }
            BOOL v210 = v215 < v206;
            int v213 = v215 + 1;
            BOOL v211 = v215 < v203;
          }
          while (v215 < v203 || v215 < v206);
        }
        int v188 = 0;
      }
      unint64_t v16 = v332;
      uint64_t v122 = &v365;
      a3 = v334;
      uint64_t v121 = (_DWORD *)v339;
    }
    if ((*(unsigned char *)(a3 + 48) & 8) != 0)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 688))(a1, v333, v338);
      CA::OGL::Context::release_surface(a1, v338);
    }
    if (v331) {
      *(unsigned char *)(a1 + 64) = 1;
    }
    if (v188)
    {
      if (v121) {
        *uint64_t v121 = v370;
      }
LABEL_418:
      if (__dst.i64[0]) {
        __assert_rtn("~ContextState", "ogl-context.h", 551, "!next && \"Imbalanced ContextState push/pop\"");
      }
LABEL_419:
      CA::OGL::PingPongState::~PingPongState((CA::OGL::PingPongState *)&v364);
      return;
    }
    int v253 = CA::OGL::BlurState::in_place_color_matrix(&v364, *(const CA::ColorMatrix **)(a3 + 16), 0);
    CA::OGL::Context::set_gstate(a1, **(void **)(a1 + 248));
    *(void *)(a1 + 16) = __dst.i64[0];
    __dst.i64[0] = 0;
    if (v253) {
      int8x16_t v254 = 0;
    }
    else {
      int8x16_t v254 = *(float32x4_t **)(a3 + 16);
    }
    char v344 = *(unsigned char *)(a3 + 48);
    int32x2_t v255 = v364;
    char v256 = BYTE12(v371);
    int v257 = (__int16)v367;
    if ((BYTE12(v371) & 4) != 0 && ((__int16)v367 & 0x80000000) == 0)
    {
      *(_WORD *)(*((void *)&v370 + (v367 & 1) + 1) + 75) |= 0x200u;
      char v256 = BYTE12(v371);
    }
    if (v257 >= 0) {
      uint64_t v122 = (uint64_t *)&v370 + (v257 & 1) + 1;
    }
    uint64_t v258 = *v122;
    int v259 = *(_DWORD *)(*v122 + 32);
    int v260 = *(_DWORD *)(*v122 + 36);
    if ((v256 & 2) != 0)
    {
      *uint64_t v122 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t, void))(*(void *)v255 + 680))(v255, *v122, 0);
      CA::OGL::Context::release_surface((uint64_t)v364, v258);
      uint64_t v258 = *v122;
      unint64_t v261 = v364;
    }
    else
    {
      unint64_t v261 = v255;
    }
    CA::OGL::Context::bind_surface((uint64_t)v261, v258, 0, 1u, 1, 0.0);
    if ((v344 & 0x20) != 0) {
      CA::OGL::Context::bind_surface((uint64_t)v364, v365, 1u, 0, 0, 0.0);
    }
    uint64_t v265 = v368;
    float v267 = *((float *)&v368 + 3);
    float v266 = *((float *)&v368 + 2);
    float v268 = *((float *)&v370 + 1);
    float v269 = *(float *)&v370;
    float v271 = *(float *)(v334 + 8);
    float v270 = *(float *)(v334 + 12);
    uint64_t v272 = *((void *)v255 + 2);
    int v273 = *(unsigned __int8 *)(v272 + 16);
    float v274 = a5 / a6;
    if (v254)
    {
      if (v273 == 3)
      {
        _Q0.i16[0] = *(_WORD *)(v272 + 8);
        float v341 = *((float *)&v370 + 1);
        _H1 = *(_WORD *)(v272 + 14);
        __asm
        {
          FCVT            S2, H1
          FCMP            H1, #0
        }
        v263.i32[0] = 0;
        if (!(_NF ^ _VF | _ZF)) {
          *(float *)v263.i32 = 1.0 / _S2;
        }
        __asm { FCVT            S0, H0 }
        *(float *)_Q0.i32 = *(float *)v263.i32 * *(float *)_Q0.i32;
        v264.i32[0] = *(_DWORD *)(v272 + 10);
        float v275 = *((float *)&v368 + 2);
        v372[0] = *v254;
        v372[1] = v254[1];
        v372[2] = v254[2];
        v372[3] = v254[3];
        float32x4_t v373 = v254[4];
        *(float32x2_t *)v263.i8 = vmul_n_f32((float32x2_t)*(_OWORD *)&vcvtq_f32_f16(v264), *(float *)v263.i32);
        float32x4_t v285 = vmulq_n_f32(v372[0], *(float *)_Q0.i32);
        int32x4_t v286 = vzip1q_s32(_Q0, v263);
        float v276 = *((float *)&v368 + 3);
        v372[0] = v285;
        v372[1] = vmulq_f32(v372[1], (float32x4_t)vzip1q_s32(v286, vdupq_lane_s32(*(int32x2_t *)v286.i8, 1)));
        float32x4_t v287 = vmulq_f32(v372[2], (float32x4_t)vzip1q_s32(v263, v263));
        *(int32x2_t *)v263.i8 = vdup_lane_s32(*(int32x2_t *)v263.i8, 1);
        int32x4_t v288 = v263;
        *(float *)&v288.i32[1] = _S2;
        float32x4_t v289 = (float32x4_t)vzip1q_s32(v288, v288);
        v289.i32[2] = v263.i32[0];
        v372[2] = v287;
        v372[3] = vmulq_f32(v372[3], v289);
        float32x4_t v373 = vmulq_n_f32(v373, _S2);
        float v277 = v270;
        CA::OGL::color_matrix_function(v255, (CA::OGL::Context *)v372, (const CA::ColorMatrix *)(DWORD2(v371) == 2), 0, 1);
        float v268 = v341;
      }
      else
      {
        if (v273 != 1) {
          goto LABEL_385;
        }
        float v276 = *((float *)&v368 + 3);
        float v275 = *((float *)&v368 + 2);
        float v277 = *(float *)(v334 + 12);
        float v278 = *((float *)&v370 + 1);
        float v340 = *(float *)&v370;
        CA::OGL::color_matrix_function(v255, (CA::OGL::Context *)v254, (const CA::ColorMatrix *)(DWORD2(v371) == 2), 0, 1);
        float v268 = v278;
        float v269 = v340;
      }
      float v270 = v277;
      float v267 = v276;
      float v266 = v275;
    }
    else
    {
      if (DWORD2(v371) != 2) {
        goto LABEL_385;
      }
      if (v273 == 3)
      {
        char v279 = 4;
      }
      else
      {
        if (v273 != 1) {
          goto LABEL_385;
        }
        char v279 = 2;
      }
      *(unsigned char *)(v272 + 16) = v279;
    }
LABEL_385:
    float v290 = (float)v259;
    float v291 = (float)v260;
    float v292 = v274 / v269;
    int v293 = (_DWORD *)*((void *)v255 + 33);
    float v294 = v274 / v268;
    if (v293)
    {
      int v295 = v293[8];
      int v296 = v293[9];
      int v298 = v293[10];
      int v297 = v293[11];
    }
    else
    {
      int v297 = 0;
      int v298 = 0;
      int v296 = 0;
      int v295 = 0;
    }
    float v299 = *(float *)&v265 - v290;
    float v300 = *((float *)&v265 + 1) - v291;
    float v301 = v266 - v290;
    float v302 = v267 - v291;
    float v303 = v271 + (float)(*(float *)&v265 * v292);
    float v304 = v270 + (float)(*((float *)&v265 + 1) * v294);
    float v305 = v271 + (float)(v266 * v292);
    float v306 = v270 + (float)(v267 * v294);
    _ZF = v293 == 0;
    int v337 = *((unsigned __int8 *)v255 + 64);
    *((unsigned char *)v255 + 64) = 1;
    v349[0] = 0uLL;
    uint64_t v307 = *(CA::Shape **)(*((void *)v255 + 31) + 8);
    v353[1] = 0;
    *(void *)&long long v354 = 0;
    v353[0] = v307;
    char v309 = !_ZF && v16 != 0;
    int v310 = v295 + v298;
    int v311 = v296 + v297;
    while (CA::ShapeIterator::iterate((uint64_t *)v353, (int *)v349))
    {
      int v312 = v349[0];
      if (v309)
      {
        if (LODWORD(v349[0]) == v295)
        {
          LODWORD(v349[0]) = v295 - 1;
          ++DWORD2(v349[0]);
          int v312 = v295 - 1;
        }
        int v313 = DWORD1(v349[0]);
        if (DWORD1(v349[0]) == v296)
        {
          DWORD1(v349[0]) = v296 - 1;
          ++HIDWORD(v349[0]);
          int v313 = v296 - 1;
        }
        int v314 = DWORD2(v349[0]);
        if (DWORD2(v349[0]) + v312 == v310) {
          int v314 = ++DWORD2(v349[0]);
        }
        int v315 = HIDWORD(v349[0]);
        if (HIDWORD(v349[0]) + v313 == v311) {
          int v315 = ++HIDWORD(v349[0]);
        }
      }
      else
      {
        int v313 = DWORD1(v349[0]);
        int v314 = DWORD2(v349[0]);
        int v315 = HIDWORD(v349[0]);
      }
      *((void *)v255 + 16) = 0;
      *((void *)v255 + 12) = (char *)v255 + 834;
      *(_OWORD *)((char *)v255 + 104) = xmmword_184997E70;
      *((_DWORD *)v255 + 8) = v312;
      *((_DWORD *)v255 + 9) = v313;
      *((_DWORD *)v255 + 10) = v314;
      *((_DWORD *)v255 + 11) = v315;
      CA::OGL::Context::array_rect(v255, v303, v304, v305, v306);
      uint64_t v316 = *(void *)(*((void *)v255 + 2) + 8);
      uint64_t v317 = *((void *)v255 + 15) + 48 * *((void *)v255 + 16);
      *(void *)(v317 - 160) = v316;
      *(void *)(v317 - 112) = v316;
      *(void *)(v317 - 64) = v316;
      *(void *)(v317 - 16) = v316;
      uint64_t v318 = *((void *)v255 + 15) + 48 * *((void *)v255 + 16);
      *(float *)(v318 - 176) = v299;
      *(float *)(v318 - 172) = v300;
      *(float *)(v318 - 128) = v301;
      *(float *)(v318 - 124) = v300;
      *(float *)(v318 - 80) = v301;
      *(float *)(v318 - 76) = v302;
      *(float *)(v318 - 32) = v299;
      *(float *)(v318 - 28) = v302;
      if ((v344 & 0x20) != 0)
      {
        *(unsigned char *)(*((void *)v255 + 2) + 16) = 14;
        float v319 = (float)*(int *)(v365 + 32);
        float v320 = v303 - v319;
        float v321 = (float)*(int *)(v365 + 36);
        float v322 = v304 - v321;
        float v323 = v305 - v319;
        float v324 = v306 - v321;
        uint64_t v325 = *((void *)v255 + 15) + 48 * *((void *)v255 + 16);
        *(float *)(v325 - 168) = v320;
        *(float *)(v325 - 164) = v322;
        *(float *)(v325 - 120) = v323;
        *(float *)(v325 - 116) = v322;
        *(float *)(v325 - 72) = v323;
        *(float *)(v325 - 68) = v324;
        *(float *)(v325 - 24) = v320;
        *(float *)(v325 - 20) = v324;
      }
      CA::OGL::Context::array_flush((uint64_t)v255);
    }
    if (!v337) {
      *((unsigned char *)v255 + 64) = 0;
    }
    float v326 = (uint64_t *)&v370 + (v367 & 1) + 1;
    if ((v367 & 0x8000u) != 0) {
      float v326 = &v365;
    }
    CA::OGL::Context::unbind_surface(v364, *v326, 0);
    if ((v344 & 0x20) != 0) {
      CA::OGL::Context::unbind_surface(v364, v365, 1);
    }
    uint64_t v327 = *((void *)v255 + 2);
    if (*(unsigned char *)(v327 + 16) == 12)
    {
      *(double *)v372[0].i64 = v303;
      *(double *)&v372[0].i64[1] = v304;
      v372[1] = (float32x4_t)xmmword_184997D60;
      *(double *)v372[2].i64 = v305;
      *(double *)&v372[2].i64[1] = v304;
      v372[3] = (float32x4_t)xmmword_184997D60;
      *(double *)v373.i64 = v305;
      *(double *)&v373.i64[1] = v306;
      long long v374 = xmmword_184997D60;
      double v375 = v303;
      double v376 = v306;
      long long v377 = xmmword_184997D60;
      *(void *)&v352[0] = *(void *)(v327 + 8);
      CA::OGL::emit_quad_surround((uint64_t)v255, (const double *)v372[0].i64, (uint64_t *)v352);
      uint64_t v327 = *((void *)v255 + 2);
    }
    *(unsigned char *)(v327 + 16) = v273;
    goto LABEL_418;
  }
}

void CA::OGL::PingPongState::scale_and_dilate(CA::OGL::PingPongState *this, double a2, float32_t a3, signed int a4, signed int a5)
{
  *((float32x2_t *)this + 10) = vmul_f32(*(float32x2_t *)((char *)this + 80), (float32x2_t)__PAIR64__(LODWORD(a3), LODWORD(a2)));
  float v6 = floorf(*((float *)this + 13) * a3);
  *((float *)this + 12) = floorf(*((float *)this + 12) * *(float *)&a2) - (float)a4;
  *((float *)this + 13) = v6 - (float)a5;
  float v7 = ceilf(*((float *)this + 15) * a3) + (float)a5;
  *((float *)this + 14) = ceilf(*((float *)this + 14) * *(float *)&a2) + (float)a4;
  *((float *)this + 15) = v7;
  int64x2_t v8 = (CA::Shape *)*((void *)this + 5);
  if (v8)
  {
    uint64_t v9 = CA::Shape::scale_and_dilate(v8, *(float32x2_t *)&a2, a3, a4, a5);
    CA::Shape::unref(*((CA::Shape **)this + 5));
    *((void *)this + 5) = v9;
  }
}

void CA::OGL::anonymous namespace'::narrowBlurParameters(CA::OGL::_anonymous_namespace_ *this, float a2, int a3, float *a4, float *a5, float *a6)
{
  int v9 = (int)this;
  uint64_t v10 = 0;
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  double v57 = 0.0;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  double v11 = 0.0;
  double v12 = 1.0 / a2;
  do
  {
    long double v13 = exp((double)((int)v10 - 13) * (double)((int)v10 - 13) * -0.5 * v12);
    *((long double *)&v51 + v10) = v13;
    double v11 = v13 + v11;
    ++v10;
  }
  while (v10 != 13);
  uint64_t v14 = 0;
  double v58 = 1.0;
  do
  {
    *(long long *)((char *)&v51 + v14) = (__int128)vmulq_n_f64(*(float64x2_t *)((char *)&v51 + v14), 1.0 / (v11 * 2.0 + 1.0));
    v14 += 16;
  }
  while (v14 != 112);
  double v15 = *(double *)&v56 + *((double *)&v56 + 1);
  double v16 = *(double *)&v55 + *((double *)&v55 + 1);
  double v17 = *(double *)&v54 + *((double *)&v54 + 1);
  double v18 = *(double *)&v53 + *((double *)&v53 + 1);
  double v19 = *(double *)&v52 + *((double *)&v52 + 1);
  double v20 = *(double *)&v51 + *((double *)&v51 + 1);
  BOOL v22 = *(double *)&v53 + *((double *)&v53 + 1) < 0.002 || v9 < 19;
  BOOL v24 = v19 < 0.002 || v9 < 23;
  BOOL v26 = v20 < 0.002 || v9 < 27;
  if (v15 >= 0.002) {
    double v27 = *(double *)&v56 / (*(double *)&v56 + *((double *)&v56 + 1)) + 2.0;
  }
  else {
    double v27 = 0.0;
  }
  if (v15 < 0.002) {
    double v15 = 0.0;
  }
  if (v16 >= 0.002) {
    double v28 = *(double *)&v55 / (*(double *)&v55 + *((double *)&v55 + 1)) + 4.0;
  }
  else {
    double v28 = 0.0;
  }
  if (v16 < 0.002) {
    double v16 = 0.0;
  }
  if (v17 >= 0.002) {
    double v29 = *(double *)&v54 / (*(double *)&v54 + *((double *)&v54 + 1)) + 6.0;
  }
  else {
    double v29 = 0.0;
  }
  float v30 = *(double *)&v53 / (*(double *)&v53 + *((double *)&v53 + 1)) + 8.0;
  float v31 = *(double *)&v52 / (*(double *)&v52 + *((double *)&v52 + 1)) + 10.0;
  float v32 = *(double *)&v51 / (*(double *)&v51 + *((double *)&v51 + 1)) + 12.0;
  if (v17 < 0.002) {
    double v17 = 0.0;
  }
  if (v22)
  {
    float v30 = 0.0;
    double v18 = 0.0;
  }
  if (v24)
  {
    float v31 = 0.0;
    double v19 = 0.0;
  }
  if (v26) {
    float v32 = 0.0;
  }
  float v33 = v57 / (v57 + v58 * 0.5);
  float v34 = v27;
  float v35 = v28;
  float v36 = v29;
  if (v26) {
    double v20 = 0.0;
  }
  if (a3) {
    float v37 = v57 / (v57 + v58 * 0.5);
  }
  else {
    float v37 = 0.0;
  }
  if (a3)
  {
    float v33 = 0.0;
    float v38 = v34;
  }
  else
  {
    float v38 = 0.0;
  }
  if (a3)
  {
    float v34 = 0.0;
    float v39 = v35;
  }
  else
  {
    float v39 = 0.0;
  }
  if (a3)
  {
    float v35 = 0.0;
    float v40 = v36;
  }
  else
  {
    float v40 = 0.0;
  }
  if (a3)
  {
    float v36 = 0.0;
    float v41 = v30;
  }
  else
  {
    float v41 = 0.0;
  }
  if (a3)
  {
    float v30 = 0.0;
    float v42 = v31;
  }
  else
  {
    float v42 = 0.0;
  }
  if (a3)
  {
    float v31 = 0.0;
    float v43 = v32;
  }
  else
  {
    float v43 = 0.0;
  }
  if (a3) {
    float v32 = 0.0;
  }
  *a4 = v37;
  a4[1] = v33;
  a4[2] = v38;
  a4[3] = v34;
  a4[4] = v39;
  a4[5] = v35;
  a4[6] = v40;
  a4[7] = v36;
  a4[8] = v41;
  a4[9] = v30;
  a4[10] = v42;
  a4[11] = v31;
  a4[12] = v43;
  a4[13] = v32;
  float v44 = 0.5 - (v15 + v16 + v19 + v17 + v18 + v20);
  float v45 = v15;
  *a5 = v44;
  a5[1] = v45;
  float v46 = v16;
  float v47 = v17;
  a5[2] = v46;
  a5[3] = v47;
  float v48 = v18;
  float v49 = v19;
  a5[4] = v48;
  a5[5] = v49;
  float v50 = v20;
  a5[6] = v50;
  a5[7] = 0.0;
}

void CA::OGL::BlurState::narrow_blur(float32x2_t *this, int a2, const float *a3, const float *a4, int a5)
{
  int v5 = a5;
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (void *)*this;
  if ((a5 & 1) != 0
    || ((this[13].i8[4] & 1) != 0 ? (uint64_t v11 = 16) : (uint64_t v11 = 32), CA::OGL::PingPongState::attach_dest(this, 1, v11)))
  {
    if (a2 <= 26)
    {
      if (a2 <= 22)
      {
        if (a2 <= 18)
        {
          if (a2 <= 14)
          {
            if (a2 <= 10) {
              char v12 = 32;
            }
            else {
              char v12 = 33;
            }
          }
          else
          {
            char v12 = 34;
          }
        }
        else
        {
          char v12 = 35;
        }
      }
      else
      {
        char v12 = 36;
      }
    }
    else
    {
      char v12 = 37;
    }
    char v13 = *(unsigned char *)(v10[2] + 16);
    __int16 v14 = this[4].i16[0];
    int v15 = v14;
    double v16 = (uint64_t *)&this[1];
    double v17 = &this[(v14 & 1) + 11];
    if (v15 < 0) {
      double v17 = this + 1;
    }
    uint64_t v18 = (uint64_t)*v17;
    int v52 = *(_DWORD *)(*(void *)v17 + 36);
    int v53 = *(_DWORD *)(*(void *)v17 + 32);
    v62[0] = v53;
    v62[1] = v52;
    CA::OGL::Context::bind_surface((uint64_t)*this, v18, 0, 1u, 1, 0.0);
    if ((v5 & 1) == 0)
    {
      float v19 = 32.0;
      if (this[13].i8[4]) {
        float v19 = 16.0;
      }
      CA::OGL::BlurState::process_edges((CA::OGL::BlurState *)this, v19, 1.0, 1.0, v62);
    }
    uint64_t v20 = 0;
    *(unsigned char *)(v10[2] + 16) = v12;
    float32x2_t v21 = *(float32x2_t *)(v10[2] + 96);
    uint64_t v61 = 0;
    memset(v60, 0, sizeof(v60));
    unint64_t v22 = -2;
    do
    {
      *(float32x2_t *)((char *)v60 + v20 * 4) = vmul_f32(*(float32x2_t *)&a3[v20], v21);
      v22 += 2;
      v20 += 2;
    }
    while (v22 < 0xC);
    if ((*(uint64_t (**)(void *))(*v10 + 984))(v10))
    {
      float v23 = 1.0;
      if (this[13].i32[0] == 2)
      {
        if ((v5 & 1) == 0)
        {
          float v23 = 1.0;
          if ((this[13].i8[4] & 2) == 0) {
            float v23 = 0.0;
          }
        }
      }
      else
      {
        float v23 = 0.0;
      }
      *(float *)double v58 = v23;
      (*(void (**)(void *, void, uint64_t, uint64_t, _OWORD *))(*v10 + 1000))(v10, 0, 2, 7, v60);
      (*(void (**)(void *, uint64_t, uint64_t, uint64_t, const float *))(*v10 + 1000))(v10, 1, 4, 2, a4);
      (*(void (**)(void *, uint64_t, uint64_t, uint64_t, void *))(*v10 + 1000))(v10, 2, 1, 1, v58);
      if (v5)
      {
        int v24 = (this[13].u8[4] >> 1) & 1;
        uint64_t v57 = 0;
        CA::OGL::PingPongState::render_pass_final_dest(*this, v53, v52, v24, &v57);
      }
      else
      {
        v10[16] = 0;
        v10[12] = (char *)v10 + 834;
        *(_OWORD *)(v10 + 13) = xmmword_184997E70;
        uint64_t v56 = 0;
        CA::OGL::PingPongState::render_pass((uint64_t)this, v53, v52, 0, &v56, 1.0, 1.0, 0.0, 0.0);
        CA::OGL::Context::array_flush((uint64_t)v10);
      }
    }
    else
    {
      char v48 = v13;
      int v49 = v5;
      uint64_t v25 = 0;
      *(unsigned char *)(v10[2] + 16) = 3;
      *(unsigned char *)(v10[2] + 480) = 12;
      v10[16] = 0;
      long long v51 = (char *)v10 + 834;
      v10[12] = (char *)v10 + 834;
      *(_OWORD *)(v10 + 13) = xmmword_184997E70;
      memset(v58, 0, sizeof(v58));
      int v59 = 0;
      int v26 = 255;
      do
      {
        unsigned int v27 = (float)((float)(a4[v25] * 255.0) + 0.5);
        *(_DWORD *)((char *)v58 + v25 * 4) = v27;
        v26 -= 2 * v27;
        ++v25;
      }
      while (v25 != 7);
      uint64_t v28 = 0;
      unsigned int v29 = v26 & ~(v26 >> 31);
      LODWORD(v58[0]) += v29 >> 1;
      char v50 = v29 & 1;
      uint64_t v30 = a2 - 3;
      char v31 = 1;
      float v32 = (int *)v58;
      do
      {
        if (v28 <= v30)
        {
          uint64_t v33 = 12;
          if (!*((_DWORD *)v10 + 23)) {
            uint64_t v33 = 8;
          }
          if ((unint64_t)(v10[16] + 8) > v10[17] || (unint64_t v34 = v10[14]) != 0 && v10[13] + v33 > v34)
          {
            *((_WORD *)v10 + 416) |= 0x20u;
            CA::OGL::Context::array_flush((uint64_t)v10);
            v10[16] = 0;
            v10[12] = v51;
            *(_OWORD *)(v10 + 13) = xmmword_184997E70;
          }
          int v35 = *v32;
          *(float *)&_S0 = (float)*v32 * 0.0039216;
          __asm { FCVT            H0, S0 }
          uint64_t v41 = _S0;
          uint64_t v55 = 0x1000100010001 * _S0;
          float v42 = &a3[v28];
          CA::OGL::PingPongState::render_pass((uint64_t)this, v53, v52, 1, &v55, 1.0, 1.0, -*v42, -v42[1]);
          if (v31)
          {
            CA::OGL::Context::array_flush((uint64_t)v10);
            *(unsigned char *)(v10[2] + 481) |= 1u;
            v10[16] = 0;
            v10[12] = v51;
            *(_OWORD *)(v10 + 13) = xmmword_184997E70;
            *(float *)&_S0 = (float)(v35 + v50) * 0.0039216;
            __asm { FCVT            H0, S0 }
            uint64_t v41 = _S0;
          }
          uint64_t v54 = (v41 << 32) | (v41 << 48) | (v41 << 16) | v41;
          CA::OGL::PingPongState::render_pass((uint64_t)this, v53, v52, 1, &v54, 1.0, 1.0, a3[v28], v42[1]);
          char v31 = 0;
        }
        v28 += 2;
        ++v32;
      }
      while (v28 != 12);
      CA::OGL::Context::array_flush((uint64_t)v10);
      *(unsigned char *)(v10[2] + 481) &= ~1u;
      char v13 = v48;
      int v5 = v49;
      double v16 = (uint64_t *)&this[1];
    }
    __int16 v44 = this[4].i16[0];
    int v45 = v44;
    float v46 = (uint64_t *)&this[(v44 & 1) + 11];
    if (v45 < 0) {
      float v46 = v16;
    }
    CA::OGL::Context::unbind_surface(*this, *v46, 0);
    if (v5) {
      char v47 = v13;
    }
    else {
      char v47 = 0;
    }
    *(unsigned char *)(v10[2] + 16) = v47;
    if ((v5 & 1) == 0)
    {
      CA::OGL::Context::pop_surface(*(CA::OGL::Context **)this);
      ++this[4].i16[0];
    }
  }
}

void *CA::OGL::MetalContext::function_uniform(CA::OGL::MetalContext *this, unsigned int a2, uint64_t a3, uint64_t a4, const float *__src)
{
  if ((unint64_t)(a4 * a3) >= 0x15) {
    __assert_rtn("function_uniform", "ogl-metal.mm", 5663, "total_elements <= kMaxFunctionUniformSize * 4");
  }
  float v6 = (char *)this + 80 * a2 + 2256;
  return memcpy(v6, __src, 4 * a4 * a3);
}

uint64_t CA::OGL::Context::bind_surface(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, float a6)
{
  if (a2 && (*(unsigned char *)(a2 + 72) & 1) != 0)
  {
    uint64_t v10 = (void *)result;
    if (a4 == 11) {
      unsigned int v11 = 2;
    }
    else {
      unsigned int v11 = a4;
    }
    if (v11 == 10) {
      uint64_t v12 = 1;
    }
    else {
      uint64_t v12 = v11;
    }
    uint64_t v13 = CA::OGL::state_image_texture_unit(*(void *)(result + 16), a3);
    uint64_t result = (*(uint64_t (**)(void *, uint64_t, void, uint64_t, uint64_t, uint64_t, float))(*v10 + 776))(v10, a2, 0, v13, v12, a5, a6);
    uint64_t v14 = v10[2];
    int v15 = (float32x2_t *)(v14 + 16 * a3);
    float32x2_t v16 = vcvt_f32_s32(*(int32x2_t *)(a2 + 24));
    __asm { FMOV            V0.2S, #1.0 }
    v15[40] = v16;
    v15[41] = vdiv_f32(_D0, v16);
    *(unsigned char *)(v14 + a3 + 17) = *(unsigned char *)(a2 + 73) & 0x3F;
    if ((*(_WORD *)(a2 + 75) & 0x10) != 0)
    {
      __asm { FMOV            V1.2S, #1.0 }
      _D0 = vdiv_f32(_D1, vcvt_f32_s32(*(int32x2_t *)(a2 + 24)));
    }
    uint64_t v22 = v10[2];
    float v23 = (float32x2_t *)(v22 + 16 * a3);
    v23[12] = _D0;
    v23[13] = 0;
    if ((*(unsigned char *)(a2 + 76) & 2) != 0)
    {
      *(unsigned char *)(v22 + 481) |= 2u;
      uint64_t v22 = v10[2];
      *(_DWORD *)(v22 + 352) = 1065353216;
    }
    float v24 = *(float *)(a2 + 64);
    if (v24 != 0.0 && v24 != 1.0)
    {
      *(float *)(v22 + 4 * a3 + 312) = 1.0 / v24;
      *(unsigned char *)(v22 + 305) |= 1 << a3;
    }
  }
  return result;
}

CA::OGL::MetalContext *CA::OGL::MetalContext::bind_surface_impl(CA::OGL::MetalContext *result, uint64_t a2, int a3, int a4, int a5, char a6, float a7)
{
  uint64_t v7 = a2 + 8 * a3;
  uint64_t v9 = *(void *)(v7 + 96);
  int64x2_t v8 = (id *)(v7 + 96);
  if (v9)
  {
    int v15 = result;
    uint64_t v16 = a2 + 8 * a3;
    uint64_t v18 = (uint64_t *)(v16 + 160);
    unint64_t v17 = *(void *)(v16 + 160);
    if (!v17)
    {
      CA::OGL::MetalContext::new_image(result);
      uint64_t *v18 = v19;
      *(void *)(*v18 + 64) = *v8;
      *(_WORD *)(*v18 + 123) = *(_WORD *)(*v18 + 123) & 0xFFBF | (*(_WORD *)(a2 + 232) >> 1) & 0x40;
      *(_WORD *)(*v18 + 123) = *(_WORD *)(*v18 + 123) & 0xFEFF | (*(_WORD *)(a2 + 232) >> 1) & 0x100;
      unint64_t v17 = *v18;
      *(unsigned char *)(*v18 + 122) = 1;
    }
    uint64_t result = (CA::OGL::MetalContext *)CA::OGL::MetalContext::update_texture_plane(v15, v17, a4, 0, *(_DWORD *)(v16 + 120), *(_DWORD *)(a2 + 24), *(_DWORD *)(a2 + 28));
    if (a5 == 11) {
      int v20 = 2;
    }
    else {
      int v20 = a5;
    }
    if (v20 == 2)
    {
      if ((*(unsigned char *)(a2 + 68) & 0x40) != 0)
      {
        if ((*(_WORD *)(a2 + 232) & 0x100) != 0)
        {
          uint64_t result = (CA::OGL::MetalContext *)CA::OGL::MetalContext::generate_mipmaps_for_texture(v15, *v18);
          *(_WORD *)(a2 + 232) &= ~0x100u;
          *(_WORD *)(*v18 + 123) |= 1u;
          *(_WORD *)(*v18 + 123) |= 0x10u;
        }
        LOBYTE(v20) = 2;
      }
      else
      {
        LOBYTE(v20) = 1;
      }
    }
    *(_DWORD *)(*v18 + 52) = *(_DWORD *)(*v18 + 52) & 0xFFF0FFFF | ((v20 & 0xF) << 16);
    *(_DWORD *)(*v18 + 52) = *(_DWORD *)(*v18 + 52) & 0xFF0FFFFF | ((a6 & 0xF) << 20);
    *(_WORD *)(*v18 + 123) |= 8u;
    uint64_t v21 = *v18;
    *(float *)(*v18 + 48) = a7;
    if (*(void *)(a2 + 200) || *(void *)(*((void *)v15 + 33) + 200) == a2)
    {
      *(_WORD *)(v21 + 123) &= ~8u;
      char v22 = *(unsigned char *)(a2 + 212);
      uint64_t v21 = *v18;
    }
    else
    {
      char v22 = -1;
    }
    *(unsigned char *)(v21 + 125) = v22;
  }
  return result;
}

void *CA::OGL::MetalContext::update_texture_plane(void *result, unint64_t a2, int a3, unsigned int a4, unsigned int a5, unsigned int a6, unsigned int a7)
{
  uint64_t v7 = a4;
  uint64_t v8 = result[2];
  *(_WORD *)(v8 + 2 * (a4 + a3) + 144) = *(_DWORD *)(a2 + 52);
  *(void *)(v8 + 8 * (a4 + a3) + 176) = a4 | a2;
  unsigned int v9 = *(unsigned __int8 *)(a2 + 122);
  if (v9 <= a4)
  {
    *(unsigned char *)(a2 + 122) = v9 + 1;
    uint64_t v12 = a6;
    uint64_t result = (id)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:a5 width:a6 height:a7 mipmapped:*(_WORD *)(a2 + 123) & 1];
    unint64_t v13 = a2 + 8 * v7;
    *(void *)(v13 + 88) = result;
    uint64_t v14 = (void **)(v13 + 88);
    if ((*(_WORD *)(a2 + 123) & 0x400) != 0)
    {
      [result setTextureType:7];
      int v15 = *v14;
      if (a7 == 1)
      {
        uint64_t v16 = 1;
        [v15 setHeight:1];
      }
      else
      {
        [v15 setHeight:v12];
        uint64_t v16 = *(unsigned __int16 *)(a2 + 120);
      }
      unint64_t v17 = *v14;
      return (void *)[v17 setDepth:v16];
    }
  }
  return result;
}

BOOL CA::OGL::MetalContext::function_supported(CA::OGL::MetalContext *this)
{
  uint64_t v1 = *((void *)this + 2);
  uint64_t v2 = *(unsigned __int8 *)(v1 + 16);
  if ((CA::OGL::MetalContext::texture_function_info[8 * v2 - v2] & 0x3F) == 0) {
    return 1;
  }
  uint64_t v3 = CA::OGL::tex_image_count[v2];
  if (!v3) {
    return 1;
  }
  uint64_t v4 = (unsigned __int8 *)(v1 + 17);
  uint64_t v5 = v3 - 1;
  do
  {
    int v7 = *v4++;
    int v6 = v7;
    BOOL result = v7 == 0;
    BOOL v10 = v5-- != 0;
  }
  while (!v6 && v10);
  return result;
}

uint64_t CA::OGL::BlurState::process_edges(CA::OGL::BlurState *this, float a2, float a3, float a4, int *a5)
{
  v20[3] = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(*(void *)(*(void *)this + 16) + 16) = 1;
  uint64_t v10 = *((void *)this + 5);
  if (v10)
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    v20[1] = 0;
    void v20[2] = 0;
    v20[0] = v10;
    while (1)
    {
      uint64_t result = CA::ShapeIterator::iterate(v20, (int *)&v18);
      if (!result) {
        break;
      }
      float v12 = (float)(int)v18;
      if (*((_DWORD *)this + 26) == 1) {
        CA::OGL::PingPongState::replicate_edges(*(CA::OGL::PingPongState **)this, a2, v12, (float)SHIDWORD(v18), (float)(v19 + v18), (float)(HIDWORD(v19) + HIDWORD(v18)), -(float)((float)*a5 - (float)(v12 * a3)), -(float)((float)a5[1] - (float)((float)SHIDWORD(v18) * a4)), -(float)((float)*a5 - (float)((float)(v19 + v18) * a3)), -(float)((float)a5[1] - (float)((float)(HIDWORD(v19) + HIDWORD(v18)) * a4)));
      }
      else {
        CA::OGL::PingPongState::clear_edges(*(CA::OGL::PingPongState **)this, a2, v12, (float)SHIDWORD(v18), (float)(v19 + v18), (float)(HIDWORD(v19) + HIDWORD(v18)));
      }
    }
  }
  else
  {
    float v13 = *((float *)this + 12);
    if (*((_DWORD *)this + 26) == 1)
    {
      return CA::OGL::PingPongState::replicate_edges(*(CA::OGL::PingPongState **)this, a2, v13, *((float *)this + 13), *((float *)this + 14), *((float *)this + 15), -(float)((float)*a5 - (float)(v13 * a3)), -(float)((float)a5[1] - (float)(*((float *)this + 13) * a4)), -(float)((float)*a5 - (float)(*((float *)this + 14) * a3)), -(float)((float)a5[1] - (float)(*((float *)this + 15) * a4)));
    }
    else
    {
      float v14 = *((float *)this + 13);
      float v15 = *((float *)this + 14);
      float v16 = *((float *)this + 15);
      unint64_t v17 = *(CA::OGL::PingPongState **)this;
      return CA::OGL::PingPongState::clear_edges(v17, a2, v13, v14, v15, v16);
    }
  }
  return result;
}

uint64_t CA::OGL::PingPongState::render_pass(uint64_t a1, int a2, int a3, int a4, uint64_t *a5, float a6, float a7, float a8, float a9)
{
  v63[3] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = *(void *)a1;
  uint64_t v17 = *(void *)(a1 + 40);
  if (v17)
  {
    uint64_t v61 = 0;
    uint64_t v62 = 0;
    v63[1] = 0;
    v63[2] = 0;
    v63[0] = v17;
    float v18 = a8 - (float)a2;
    float v19 = a9 - (float)a3;
    while (1)
    {
      uint64_t result = CA::ShapeIterator::iterate(v63, (int *)&v61);
      if (!result) {
        break;
      }
      int v22 = v61;
      int v21 = HIDWORD(v61);
      int v23 = v62;
      int v24 = HIDWORD(v62);
      if (*(_DWORD *)(v16 + 92)) {
        uint64_t v25 = 6;
      }
      else {
        uint64_t v25 = 4;
      }
      if ((unint64_t)(*(void *)(v16 + 128) + 4) > *(void *)(v16 + 136)
        || (unint64_t v26 = *(void *)(v16 + 112)) != 0 && *(void *)(v16 + 104) + v25 > v26)
      {
        *(_WORD *)(v16 + 832) |= 0x20u;
        CA::OGL::Context::array_flush(v16);
        *(void *)(v16 + 128) = 0;
        *(void *)(v16 + 96) = v16 + 834;
        *(_OWORD *)(v16 + 104) = xmmword_184997E70;
      }
      CA::OGL::Context::array_rect((void *)v16, (float)v22, (float)v21, (float)(v23 + v22), (float)(v24 + v21));
      if (a4)
      {
        uint64_t v27 = *a5;
        uint64_t v28 = *(void *)(v16 + 120) + 48 * *(void *)(v16 + 128);
        *(void *)(v28 - 160) = *a5;
        *(void *)(v28 - 112) = v27;
        *(void *)(v28 - 64) = v27;
        *(void *)(v28 - 16) = v27;
      }
      float v29 = v18 + (float)((float)v22 * a6);
      float v30 = v19 + (float)((float)v21 * a7);
      float v31 = v18 + (float)((float)(v23 + v22) * a6);
      uint64_t v32 = *(void *)(v16 + 120) + 48 * *(void *)(v16 + 128);
      *(float *)(v32 - 176) = v29;
      *(float *)(v32 - 172) = v30;
      float v33 = v19 + (float)((float)(v24 + v21) * a7);
      *(float *)(v32 - 128) = v31;
      *(float *)(v32 - 124) = v30;
      *(float *)(v32 - 80) = v31;
      *(float *)(v32 - 76) = v33;
      *(float *)(v32 - 32) = v29;
      *(float *)(v32 - 28) = v33;
    }
  }
  else
  {
    float v35 = *(float *)(a1 + 48);
    float v36 = *(float *)(a1 + 52);
    float v37 = *(float *)(a1 + 56);
    float v38 = *(float *)(a1 + 60);
    uint64_t v39 = 6;
    if (!*(_DWORD *)(v16 + 92)) {
      uint64_t v39 = 4;
    }
    if ((unint64_t)(*(void *)(v16 + 128) + 4) > *(void *)(v16 + 136)) {
      goto LABEL_19;
    }
    unint64_t v40 = *(void *)(v16 + 112);
    float v41 = *(float *)(a1 + 60);
    float v42 = *(float *)(a1 + 56);
    float v43 = *(float *)(a1 + 52);
    float v44 = *(float *)(a1 + 48);
    if (v40)
    {
      float v41 = *(float *)(a1 + 60);
      float v42 = *(float *)(a1 + 56);
      float v43 = *(float *)(a1 + 52);
      float v44 = *(float *)(a1 + 48);
      if (*(void *)(v16 + 104) + v39 > v40)
      {
LABEL_19:
        *(_WORD *)(v16 + 832) |= 0x20u;
        float v45 = v37;
        float v46 = v38;
        CA::OGL::Context::array_flush(v16);
        float v38 = v46;
        float v37 = v45;
        *(void *)(v16 + 128) = 0;
        *(void *)(v16 + 96) = v16 + 834;
        *(_OWORD *)(v16 + 104) = xmmword_184997E70;
        float v44 = *(float *)(a1 + 48);
        float v43 = *(float *)(a1 + 52);
        float v42 = *(float *)(a1 + 56);
        float v41 = *(float *)(a1 + 60);
      }
    }
    float v47 = (float)a2;
    float v48 = v35 * a6;
    float v49 = v36 * a7;
    float v50 = (float)a3;
    float v51 = v37 * a6;
    float v52 = v38 * a7;
    uint64_t result = (uint64_t)CA::OGL::Context::array_rect((void *)v16, v44, v43, v42, v41);
    if (a4)
    {
      uint64_t v53 = *a5;
      uint64_t v54 = *(void *)(v16 + 120) + 48 * *(void *)(v16 + 128);
      *(void *)(v54 - 160) = *a5;
      *(void *)(v54 - 112) = v53;
      *(void *)(v54 - 64) = v53;
      *(void *)(v54 - 16) = v53;
    }
    float v55 = (float)(a8 - v47) + v48;
    float v56 = (float)(a9 - v50) + v49;
    float v57 = (float)(a8 - v47) + v51;
    uint64_t v58 = *(void *)(v16 + 120) + 48 * *(void *)(v16 + 128);
    *(float *)(v58 - 176) = v55;
    *(float *)(v58 - 172) = v56;
    float v59 = (float)(a9 - v50) + v52;
    *(float *)(v58 - 128) = v57;
    *(float *)(v58 - 124) = v56;
    *(float *)(v58 - 80) = v57;
    *(float *)(v58 - 76) = v59;
    *(float *)(v58 - 32) = v55;
    *(float *)(v58 - 28) = v59;
  }
  return result;
}

uint64_t CA::OGL::Context::sw_renderer_p(CA::OGL::Context *this)
{
  return 0;
}

double CA::OGL::MetalContext::new_image(CA::OGL::MetalContext *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v2 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x80uLL, 0x743898A5uLL);
  if (v2)
  {
    *((void *)v2 + 14) = 0;
    double result = 0.0;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_WORD *)v2 + 60) = 1;
    v2[122] = 0;
    *(_WORD *)(v2 + 123) |= 8u;
    v2[125] = -1;
    *((_WORD *)v2 + 29) |= 0x500u;
  }
  return result;
}

void CA::OGL::PingPongState::render_pass_final_dest(void *a1, int a2, int a3, int a4, uint64_t *a5)
{
  v28[3] = *MEMORY[0x1E4F143B8];
  unsigned int v9 = (_DWORD *)a1[33];
  if (v9) {
    BOOL v10 = a4 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    unsigned int v9 = (_DWORD *)(*(uint64_t (**)(void *, _DWORD *, uint64_t))(*a1 + 680))(a1, v9, 1);
    CA::OGL::Context::push_surface((uint64_t)a1, (uint64_t)v9, 0, 64, 0);
  }
  uint64_t v11 = 0;
  a1[16] = 0;
  uint64_t v26 = 0;
  a1[12] = (char *)a1 + 834;
  *(_OWORD *)(a1 + 13) = xmmword_184997E70;
  uint64_t v12 = *(void *)(a1[31] + 8);
  v28[1] = 0;
  v28[2] = 0;
  uint64_t v27 = 0;
  v28[0] = v12;
  while (CA::ShapeIterator::iterate(v28, (int *)&v26))
  {
    if (v9)
    {
      if (v27 + v26 == v9[10] + v9[8]) {
        LODWORD(v27) = v27 + 1;
      }
      if (HIDWORD(v27) + HIDWORD(v26) == v9[11] + v9[9]) {
        ++HIDWORD(v27);
      }
    }
    uint64_t v13 = 6;
    if (!*((_DWORD *)a1 + 23)) {
      uint64_t v13 = 4;
    }
    if ((unint64_t)(v11 + 4) > a1[17] || (unint64_t v14 = a1[14]) != 0 && a1[13] + v13 > v14)
    {
      *((_WORD *)a1 + 416) |= 0x20u;
      CA::OGL::Context::array_flush((uint64_t)a1);
      a1[16] = 0;
      a1[12] = (char *)a1 + 834;
      *(_OWORD *)(a1 + 13) = xmmword_184997E70;
    }
    int v15 = v26;
    int v16 = HIDWORD(v26);
    int v18 = v27;
    int v17 = HIDWORD(v27);
    CA::OGL::Context::array_rect(a1, (float)(int)v26, (float)SHIDWORD(v26), (float)(v27 + v26), (float)(HIDWORD(v27) + HIDWORD(v26)));
    uint64_t v19 = *a5;
    uint64_t v20 = a1[15] + 48 * a1[16];
    *(void *)(v20 - 160) = *a5;
    *(void *)(v20 - 112) = v19;
    *(void *)(v20 - 64) = v19;
    float v21 = (float)(v15 - a2);
    float v22 = (float)(v15 - a2 + v18);
    float v23 = (float)(v16 - a3 + v17);
    *(void *)(v20 - 16) = v19;
    uint64_t v11 = a1[16];
    uint64_t v24 = a1[15] + 48 * v11;
    *(float *)(v24 - 176) = v21;
    *(float *)(v24 - 172) = (float)(v16 - a3);
    *(float *)(v24 - 128) = v22;
    *(float *)(v24 - 124) = (float)(v16 - a3);
    *(float *)(v24 - 80) = v22;
    *(float *)(v24 - 76) = v23;
    *(float *)(v24 - 32) = v21;
    *(float *)(v24 - 28) = v23;
  }
  CA::OGL::Context::array_flush((uint64_t)a1);
  if (v9 && a4)
  {
    CA::OGL::Context::pop_surface((CA::OGL::Context *)a1);
    (*(void (**)(void *, void, _DWORD *))(*a1 + 688))(a1, a1[33], v9);
    CA::OGL::Context::release_surface((uint64_t)a1, (uint64_t)v9);
  }
}

uint64_t CA::OGL::BlurState::in_place_color_matrix(CA::OGL **this, const CA::ColorMatrix *a2, char a3)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (a3)
    {
      uint64_t v5 = *this;
      uint64_t v6 = (uint64_t)*this + 16;
      *(unsigned char *)(*(void *)v6 + 17) = 38;
      uint64_t v7 = *((void *)v5 + 33);
      CA::OGL::color_matrix_function(v5, a2, 0, 0, 1);
      int v8 = *(_DWORD *)(v7 + 32);
      int v9 = *(_DWORD *)(v7 + 36);
      v16[0] = *(void *)(*(void *)v6 + 8);
      CA::OGL::PingPongState::render_pass_final_dest(*this, v8, v9, 0, v16);
LABEL_6:
      *(unsigned char *)(*(void *)v6 + 16) = 0;
      *(unsigned char *)(*(void *)v6 + 17) = 0;
      return 1;
    }
    if (((__int16)this[4] & 0x80000000) == 0)
    {
      uint64_t v10 = (uint64_t)*this;
      uint64_t v6 = (uint64_t)*this + 16;
      *(unsigned char *)(*(void *)v6 + 17) = 38;
      uint64_t v11 = (uint64_t)this[((_WORD)this[4] & 1) + 11];
      CA::OGL::Context::push_surface(v10, v11, 0, 64, 0);
      CA::OGL::color_matrix_function((CA::OGL *)v10, a2, 0, 0, 1);
      *(void *)(v10 + 128) = 0;
      *(void *)(v10 + 96) = v10 + 834;
      *(_OWORD *)(v10 + 104) = xmmword_184997E70;
      int v12 = *(_DWORD *)(v11 + 32);
      int v13 = *(_DWORD *)(v11 + 36);
      uint64_t v15 = *(void *)(*(void *)v6 + 8);
      CA::OGL::PingPongState::render_pass((uint64_t)this, v12, v13, 1, &v15, 1.0, 1.0, 0.0, 0.0);
      CA::OGL::Context::array_flush(v10);
      CA::OGL::Context::pop_surface((CA::OGL::Context *)v10);
      goto LABEL_6;
    }
  }
  return 0;
}

uint64_t CA::OGL::BlurState::tile_downsample(float32x2_t *this, int a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (this[5]) {
    return 0;
  }
  if (this[13].i8[4])
  {
    uint64_t v2 = 0;
    if ((this[13].i8[4] & 2) != 0 || this[13].i32[0] == 1) {
      return v2;
    }
  }
  else if ((this[13].i8[4] & 2) != 0)
  {
    return 0;
  }
  uint64_t v6 = (void *)*this;
  if (!(*(unsigned int (**)(float32x2_t, uint64_t))(**(void **)this + 184))(*this, 34)) {
    return 0;
  }
  __int16 v9 = this[4].i16[0];
  int v10 = v9;
  uint64_t v11 = v9 & 1;
  int v12 = (CA::OGL::BlurState *)(v10 >= 0 ? &this[v11 + 11] : &this[1]);
  uint64_t v13 = *(void *)v12;
  if (v6[34] != *(void *)v12 || (*(_WORD *)(v13 + 75) & 0xF) < a2) {
    return 0;
  }
  uint64_t v14 = v11 ^ 1;
  uint64_t v15 = *(void *)(v13 + 32);
  v7.i64[0] = *(void *)(v13 + 40);
  v16.i64[0] = (int)v15;
  v16.i64[1] = SHIDWORD(v15);
  int8x16_t v17 = (int8x16_t)vcvtq_f64_s64(v16);
  int v18 = v7.i32[1];
  v16.i64[0] = v7.i32[0];
  v16.i64[1] = v7.i32[1];
  int64x2_t v19 = v16;
  if (v7.i32[0] > v7.i32[1]) {
    int v18 = *(void *)(v13 + 40);
  }
  v7.i32[0] = v18;
  v8.i32[0] = 1073741822;
  int8x16_t v20 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v7, v8), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v17);
  int32x2_t v21 = vdup_n_s32(v18 > 1073741822);
  v22.i64[0] = v21.u32[0];
  v22.i64[1] = v21.u32[1];
  int8x16_t v23 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v22, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), (int8x16_t)vcvtq_f64_s64(v19));
  float v24 = 1.0 / (float)a2;
  double v25 = v24;
  BOOL v26 = *(double *)v23.i64 >= 1.79769313e308 || v24 == 1.0;
  v27.i64[1] = v20.i64[1];
  v28.i64[1] = v23.i64[1];
  if (v26) {
    unint64_t v29 = 0;
  }
  else {
    unint64_t v29 = -1;
  }
  int8x16_t v30 = (int8x16_t)vdupq_n_s64(v29);
  *(double *)v28.i64 = v25 * *(double *)v23.i64;
  float64x2_t v31 = (float64x2_t)vbslq_s8(v30, v28, v23);
  *(double *)v27.i64 = v25 * *(double *)v20.i64;
  float64x2_t v32 = (float64x2_t)vbslq_s8(v30, v27, v20);
  if (v24 != 1.0 && v31.f64[1] < 1.79769313e308)
  {
    v32.f64[1] = vmuld_lane_f64(v25, v32, 1);
    v31.f64[1] = v31.f64[1] * v25;
  }
  int8x16_t v33 = (int8x16_t)vceqzq_f64(v31);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v33, 1), v33).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v34 = vorrq_s8((int8x16_t)vcltzq_f64(v31), (int8x16_t)vcgezq_f64(v31)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v34), 1), v34).u64[0] & 0x8000000000000000) != 0))
  {
    int32x4_t v40 = 0uLL;
    int32x2_t v37 = (int32x2_t)0x100000001;
  }
  else
  {
    float64x2_t v35 = vminnmq_f64(vaddq_f64(v32, v31), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
    int32x4_t v36 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v32, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    int32x4_t v40 = vuzp1q_s32(v36, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v35), (int64x2_t)v36));
    int32x2_t v37 = vadd_s32((int32x2_t)v40.u64[1], (int32x2_t)0x100000001);
  }
  v40.u64[1] = (unint64_t)v37;
  this[4].i32[1] |= 0x4000u;
  if (!CA::OGL::PingPongState::create_surface((CA::OGL::PingPongState *)this, v14, (const CA::Bounds *)&v40)) {
    return 0;
  }
  this[7] = vcvt_f32_s32(vadd_s32((int32x2_t)v40.u64[1], *(int32x2_t *)v40.i8));
  float32x2_t v38 = this[v14 + 11];
  int v39 = *(_DWORD *)(v13 + 36) / a2 - *(_DWORD *)(*(void *)&v38 + 36);
  int v41 = *(_DWORD *)(v13 + 32) / a2 - *(_DWORD *)(*(void *)&v38 + 32);
  int v42 = v39;
  uint64_t v2 = (*(uint64_t (**)(void *))(*v6 + 880))(v6);
  if (v2)
  {
    (*(void (**)(void *))(*v6 + 752))(v6);
    ++this[4].i16[0];
  }
  return v2;
}

uint64_t CA::OGL::anonymous namespace'::set_destination_bounds(uint64_t result, int32x4_t *a2, uint64_t *a3, uint64_t a4, double a5, float a6, double a7, int32x4_t a8, double a9, double a10, int32x4_t a11)
{
  if (*(float *)&a5 != 1.0 && a4 != 0)
  {
    uint64_t v13 = result;
    uint64_t v15 = a2[2].i64[0];
    a8.i64[0] = a2[2].i64[1];
    uint64_t v14 = a2 + 2;
    v16.i64[0] = (int)v15;
    v16.i64[1] = SHIDWORD(v15);
    int8x16_t v17 = (int8x16_t)vcvtq_f64_s64(v16);
    signed __int32 v18 = a8.i32[1];
    v16.i64[0] = a8.i32[0];
    v16.i64[1] = a8.i32[1];
    int64x2_t v19 = v16;
    if (a8.i32[0] > a8.i32[1]) {
      signed __int32 v18 = a8.i32[0];
    }
    a8.i32[0] = v18;
    a11.i32[0] = 1073741822;
    int8x16_t v20 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a8, a11), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v17);
    int32x2_t v21 = vdup_n_s32(v18 > 1073741822);
    int8x16_t v22 = (int8x16_t)vcvtq_f64_s64(v19);
    v23.i64[0] = v21.u32[0];
    v23.i64[1] = v21.u32[1];
    int8x16_t v24 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v23, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v22);
    v22.i64[0] = 0x7FEFFFFFFFFFFFFFLL;
    int8x16_t v25 = (int8x16_t)vdupq_lane_s64(vcgtq_f64((float64x2_t)v22, (float64x2_t)v24).i64[0], 0);
    v26.i64[1] = v24.i64[1];
    *(double *)v26.i64 = *(float *)&a5 * *(double *)v24.i64;
    float64x2_t v27 = (float64x2_t)vbslq_s8(v25, v26, v24);
    v28.i64[1] = v20.i64[1];
    *(double *)v28.i64 = *(float *)&a5 * *(double *)v20.i64;
    float64x2_t v29 = (float64x2_t)vbslq_s8(v25, v28, v20);
    if (a6 != 1.0 && v27.f64[1] < 1.79769313e308)
    {
      v29.f64[1] = vmuld_lane_f64(a6, v29, 1);
      v27.f64[1] = v27.f64[1] * a6;
    }
    int8x16_t v30 = (int8x16_t)vceqzq_f64(v27);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v30, 1), v30).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v31 = vorrq_s8((int8x16_t)vcltzq_f64(v27), (int8x16_t)vcgezq_f64(v27)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v31), 1), v31).u64[0] & 0x8000000000000000) != 0))
    {
      v14->i64[0] = 0;
      v14->i64[1] = 0;
    }
    else
    {
      float64x2_t v32 = vminnmq_f64(vaddq_f64(v29, v27), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
      int32x4_t v33 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v29, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      int32x4_t *v14 = vuzp1q_s32(v33, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v32), (int64x2_t)v33));
    }
    double result = CA::Shape::scale_and_dilate(*(CA::Shape **)(result + 8), *(float32x2_t *)&a5, a6, 1u, 1u);
    *a3 = result;
    *(void *)(v13 + 8) = result;
  }
  return result;
}

void CA::OGL::BlurState::tile_simd_blur(float32x2_t *this, int a2, const float *a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  __int16 v5 = this[4].i16[0];
  int v6 = v5;
  int32x4_t v7 = this + 1;
  uint64_t v8 = v5 & 1;
  __int16 v9 = &this[v8 + 11];
  if (v6 < 0) {
    __int16 v9 = this + 1;
  }
  if (this[13].i8[4]) {
    uint64_t v10 = 16;
  }
  else {
    uint64_t v10 = 32;
  }
  uint64_t v11 = v8 ^ 1;
  float32x2_t v12 = this[6];
  float32x2_t v13 = vsub_f32(this[7], v12);
  int32x2_t v14 = vceqz_f32(v13);
  v15.i64[0] = v14.i32[0];
  v15.i64[1] = v14.i32[1];
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v15, 1), (int8x16_t)v15).u64[0] & 0x8000000000000000) != 0
    || (int8x8_t v16 = vmvn_s8(vorr_s8((int8x8_t)vcltz_f32(v13), (int8x8_t)vcgez_f32(v13))),
        v17.i64[0] = v16.i32[0],
        v17.i64[1] = v16.i32[1],
        (vorrq_s8((int8x16_t)vdupq_laneq_s64(v17, 1), (int8x16_t)v17).u64[0] & 0x8000000000000000) != 0))
  {
    memset(&v42, 0, sizeof(v42));
    int32x2_t v24 = 0;
    int32x2_t v23 = (int32x2_t)-1;
  }
  else
  {
    float64x2_t v18 = vcvtq_f64_f32(v12);
    float64x2_t v19 = vmaxnmq_f64(v18, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000));
    float64x2_t v20 = vminnmq_f64(vaddq_f64(v18, vcvtq_f64_f32(v13)), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
    int32x4_t v21 = (int32x4_t)vcvtmq_s64_f64(v19);
    int32x4_t v22 = (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v20), (int64x2_t)v21);
    int32x4_t v42 = vuzp1q_s32(v21, v22);
    int32x2_t v23 = vadd_s32(vmovn_s64((int64x2_t)v21), (int32x2_t)-1);
    int32x2_t v24 = vmovn_s64((int64x2_t)v22);
  }
  if (this[4].i8[2])
  {
    int v25 = v24.i32[0];
    if (v24.i32[0] <= v24.i32[1]) {
      int v26 = v24.i32[1];
    }
    else {
      int v26 = v24.i32[0];
    }
    if (v24.i32[0] >= v24.i32[1]) {
      int v25 = v24.i32[1];
    }
    if (v26 <= 1073741822 && v25 >= 1)
    {
      int8x8_t v28 = (int8x8_t)vadd_s32(v24, (int32x2_t)0x200000002);
      if (v28.i32[1] < 1 || v28.i32[0] < 1) {
        unsigned int v30 = -1;
      }
      else {
        unsigned int v30 = 0;
      }
      *(int32x2_t *)v42.i8 = v23;
      v42.u64[1] = (unint64_t)vbic_s8(v28, (int8x8_t)vdup_n_s32(v30));
    }
  }
  float32x2_t v31 = *v9;
  if (CA::OGL::PingPongState::create_surface((CA::OGL::PingPongState *)this, v11, (const CA::Bounds *)&v42))
  {
    uint64_t v32 = (uint64_t)this[v11 + 11];
    (*(void (**)(float32x2_t, uint64_t, uint64_t, uint64_t))(**(void **)this + 704))(*this, v32, v10, v10);
    CA::OGL::Context::push_surface((uint64_t)*this, v32, 0, 64, 0);
    float32x2_t v33 = *this;
    float32x2_t v34 = this[6];
    int32x2_t v35 = vcvt_s32_f32(vsub_f32(this[7], v34));
    v41[0] = vcvt_s32_f32(v34);
    v41[1] = v35;
    (*(void (**)(float32x2_t, float32x2_t, void *, const float *))(**(void **)&v33 + 888))(v33, v31, v41, a3);
    v42.i64[0] = *(void *)(*(void *)&v31 + 32);
    float v36 = 32.0;
    if (this[13].i8[4]) {
      float v36 = 16.0;
    }
    CA::OGL::BlurState::process_edges((CA::OGL::BlurState *)this, v36, 1.0, 1.0, v42.i32);
    int32x2_t v37 = (CA::OGL::Context *)*this;
    if ((*(_WORD *)(*(void *)this + 832) & 0x7000) != 0)
    {
      __int16 v38 = this[4].i16[0];
      int v39 = v38;
      int32x4_t v40 = &this[(v38 & 1) + 11];
      if (v39 < 0) {
        int32x4_t v40 = v7;
      }
      *(unsigned char *)(*((void *)v37 + 33) + 73) = *(unsigned char *)(*((void *)v37 + 33) + 73) & 0xC0 | *(unsigned char *)(*(void *)v40 + 73) & 0x3F;
      int32x2_t v37 = (CA::OGL::Context *)*this;
    }
    CA::OGL::Context::pop_surface(v37);
    ++this[4].i16[0];
  }
}

void CA::OGL::anonymous namespace'::simdBlurParameters(CA::OGL::_anonymous_namespace_ *this, float a2, float *a3, int *a4)
{
  uint64_t v6 = 0;
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v21 = 0;
  memset(v20, 0, sizeof(v20));
  double v7 = 0.0;
  double v8 = 1.0 / a2;
  do
  {
    long double v9 = exp((double)((int)v6 - 13) * (double)((int)v6 - 13) * -0.5 * v8);
    *((long double *)v20 + v6) = v9;
    double v7 = v9 + v7;
    ++v6;
  }
  while (v6 != 13);
  uint64_t v10 = 0;
  uint64_t v22 = 0x3FF0000000000000;
  do
  {
    v20[v10] = vmulq_n_f64((float64x2_t)v20[v10], 1.0 / (v7 * 2.0 + 1.0));
    ++v10;
  }
  while (v10 != 7);
  uint64_t v11 = 0;
  double v12 = 0.0;
  while (1)
  {
    double v13 = *((double *)v20 + v11);
    if (v13 >= 0.002) {
      break;
    }
    double v12 = v13 + v12;
    if (++v11 == 11) {
      goto LABEL_10;
    }
  }
  if (v11 > 0xD)
  {
    LODWORD(v14) = 0;
    goto LABEL_14;
  }
LABEL_10:
  uint64_t v14 = (14 - v11);
  int64x2_t v15 = (double *)v20 + v11;
  uint64_t v16 = v14;
  double v17 = 1.0 / (1.0 - v12);
  do
  {
    double v18 = *v15++;
    float v19 = v18 * v17;
    *(float *)this = v19;
    this = (CA::OGL::_anonymous_namespace_ *)((char *)this + 4);
    --v16;
  }
  while (v16);
LABEL_14:
  *(_DWORD *)a3 = v14;
}

void CA::OGL::BlurState::downsample_blur_2(float32x2_t *this, float a2, float a3, const float *a4, const float *a5)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  long double v9 = (void *)*this;
  if (this[13].i8[4]) {
    uint64_t v10 = 16;
  }
  else {
    uint64_t v10 = 32;
  }
  if (CA::OGL::PingPongState::attach_dest(this, 1, v10))
  {
    __int16 v11 = this[4].i16[0];
    int v12 = v11;
    double v13 = (uint64_t *)&this[1];
    uint64_t v14 = &this[(v11 & 1) + 11];
    if (v12 < 0) {
      uint64_t v14 = this + 1;
    }
    uint64_t v15 = (uint64_t)*v14;
    int v16 = *(_DWORD *)(*(void *)v14 + 32);
    int v17 = *(_DWORD *)(*(void *)v14 + 36);
    v40[0] = v16;
    v40[1] = v17;
    CA::OGL::Context::bind_surface((uint64_t)*this, v15, 0, 1u, 1, 0.0);
    unint64_t v18 = 0;
    float32x2_t v19 = *(float32x2_t *)(v9[2] + 96);
    memset(v39, 0, sizeof(v39));
    unint64_t v20 = -2;
    do
    {
      v39[v18 / 2] = vmul_f32(*(float32x2_t *)&a4[v18], v19);
      v20 += 2;
      v18 += 2;
    }
    while (v20 < 4);
    float v21 = a4[4];
    if (v21 <= a4[5]) {
      float v21 = a4[5];
    }
    CA::OGL::BlurState::process_edges((CA::OGL::BlurState *)this, v21 + v21, a2, a3, v40);
    *(unsigned char *)(v9[2] + 16) = 30;
    if ((*(uint64_t (**)(void *))(*v9 + 984))(v9))
    {
      (*(void (**)(void *, void, uint64_t, uint64_t, void *))(*v9 + 1000))(v9, 0, 2, 3, v39);
      v9[16] = 0;
      v9[12] = (char *)v9 + 834;
      *(_OWORD *)(v9 + 13) = xmmword_184997E70;
      uint64_t v38 = 0;
      CA::OGL::PingPongState::render_pass((uint64_t)this, v16, v17, 0, &v38, a2, a3, 0.0, 0.0);
      CA::OGL::Context::array_flush((uint64_t)v9);
    }
    else
    {
      *(unsigned char *)(v9[2] + 16) = 3;
      v9[16] = 0;
      v9[12] = (char *)v9 + 834;
      *(_OWORD *)(v9 + 13) = xmmword_184997E70;
      uint64_t v37 = 0x340E340E340E340ELL;
      CA::OGL::PingPongState::render_pass((uint64_t)this, v16, v17, 1, &v37, a2, a3, 0.0, 0.0);
      CA::OGL::Context::array_flush((uint64_t)v9);
      *(unsigned char *)(v9[2] + 481) |= 1u;
      *(unsigned char *)(v9[2] + 480) = 12;
      v9[16] = 0;
      v9[12] = (char *)v9 + 834;
      *(_OWORD *)(v9 + 13) = xmmword_184997E70;
      uint64_t v22 = a4 + 1;
      uint64_t v23 = 4u;
      do
      {
        uint64_t v24 = 12;
        if (!*((_DWORD *)v9 + 23)) {
          uint64_t v24 = 8;
        }
        if ((unint64_t)(v9[16] + 8) > v9[17] || (unint64_t v25 = v9[14]) != 0 && v9[13] + v24 > v25)
        {
          *((_WORD *)v9 + 416) |= 0x20u;
          CA::OGL::Context::array_flush((uint64_t)v9);
          v9[16] = 0;
          v9[12] = (char *)v9 + 834;
          *(_OWORD *)(v9 + 13) = xmmword_184997E70;
        }
        __asm { FCVT            H0, S0 }
        uint64_t v31 = 0x1000100010001 * _S0;
        uint64_t v36 = v31;
        CA::OGL::PingPongState::render_pass((uint64_t)this, v16, v17, 1, &v36, a2, a3, -*(v22 - 1), -*v22);
        uint64_t v35 = v31;
        CA::OGL::PingPongState::render_pass((uint64_t)this, v16, v17, 1, &v35, a2, a3, *(v22 - 1), *v22);
        v23 += 4;
        v22 += 2;
      }
      while (v23 != 16);
      CA::OGL::Context::array_flush((uint64_t)v9);
      *(unsigned char *)(v9[2] + 481) &= ~1u;
      double v13 = (uint64_t *)&this[1];
    }
    __int16 v32 = this[4].i16[0];
    int v33 = v32;
    float32x2_t v34 = (uint64_t *)&this[(v32 & 1) + 11];
    if (v33 < 0) {
      float32x2_t v34 = v13;
    }
    CA::OGL::Context::unbind_surface(*this, *v34, 0);
    *(unsigned char *)(v9[2] + 16) = 0;
    CA::OGL::Context::pop_surface(*(CA::OGL::Context **)this);
    ++this[4].i16[0];
  }
}

void CA::OGL::BlurState::downsample_box_2(float32x2_t *this, float a2, float a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (uint64_t)*this;
  if (this[13].i8[4]) {
    uint64_t v7 = 16;
  }
  else {
    uint64_t v7 = 32;
  }
  if (CA::OGL::PingPongState::attach_dest(this, 1, v7))
  {
    __int16 v8 = this[4].i16[0];
    int v9 = v8;
    uint64_t v10 = &this[(v8 & 1) + 11];
    if (v9 < 0) {
      uint64_t v10 = this + 1;
    }
    uint64_t v11 = (uint64_t)*v10;
    int v12 = *(_DWORD *)(*(void *)v10 + 32);
    int v13 = *(_DWORD *)(*(void *)v10 + 36);
    v19[0] = v12;
    v19[1] = v13;
    CA::OGL::Context::bind_surface((uint64_t)*this, v11, 0, 1u, 1, 0.0);
    float v14 = 32.0;
    if (this[13].i8[4]) {
      float v14 = 16.0;
    }
    CA::OGL::BlurState::process_edges((CA::OGL::BlurState *)this, v14, a2, a3, v19);
    *(unsigned char *)(*(void *)(v6 + 16) + 16) = 1;
    *(void *)(v6 + 128) = 0;
    *(void *)(v6 + 96) = v6 + 834;
    *(_OWORD *)(v6 + 104) = xmmword_184997E70;
    uint64_t v18 = 0;
    CA::OGL::PingPongState::render_pass((uint64_t)this, v12, v13, 0, &v18, a2, a3, 0.0, 0.0);
    CA::OGL::Context::array_flush(v6);
    __int16 v15 = this[4].i16[0];
    int v16 = v15;
    int v17 = (uint64_t *)&this[(v15 & 1) + 11];
    if (v16 < 0) {
      int v17 = (uint64_t *)&this[1];
    }
    CA::OGL::Context::unbind_surface(*this, *v17, 0);
    *(unsigned char *)(*(void *)(v6 + 16) + 16) = 0;
    CA::OGL::Context::pop_surface(*(CA::OGL::Context **)this);
    ++this[4].i16[0];
  }
}

void CA::OGL::BlurState::downsample_blur_4(float32x2_t *this, float a2, float a3, const float *a4, const float *a5)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = (uint64_t)*this;
  if (this[13].i8[4]) {
    uint64_t v10 = 16;
  }
  else {
    uint64_t v10 = 32;
  }
  if (CA::OGL::PingPongState::attach_dest(this, 1, v10))
  {
    __int16 v11 = this[4].i16[0];
    int v12 = v11;
    int v13 = &this[(v11 & 1) + 11];
    if (v12 < 0) {
      int v13 = this + 1;
    }
    uint64_t v14 = (uint64_t)*v13;
    int v15 = *(_DWORD *)(*(void *)v13 + 32);
    int v16 = *(_DWORD *)(*(void *)v13 + 36);
    v26[0] = v15;
    v26[1] = v16;
    CA::OGL::Context::bind_surface((uint64_t)*this, v14, 0, 1u, 1, 0.0);
    uint64_t v17 = 0;
    float32x2_t v18 = *(float32x2_t *)(*(void *)(v9 + 16) + 96);
    memset(v25, 0, sizeof(v25));
    unint64_t v19 = -2;
    do
    {
      *(float32x2_t *)((char *)v25 + v17 * 4) = vmul_f32(*(float32x2_t *)&a4[v17], v18);
      v19 += 2;
      v17 += 2;
    }
    while (v19 < 0xA);
    float v20 = a4[10];
    if (v20 <= a4[11]) {
      float v20 = a4[11];
    }
    CA::OGL::BlurState::process_edges((CA::OGL::BlurState *)this, v20 + v20, a2, a3, v26);
    *(unsigned char *)(*(void *)(v9 + 16) + 16) = 31;
    if ((*(uint64_t (**)(uint64_t))(*(void *)v9 + 984))(v9))
    {
      (*(void (**)(uint64_t, void, uint64_t, uint64_t, _OWORD *))(*(void *)v9 + 1000))(v9, 0, 2, 6, v25);
      *(void *)(v9 + 128) = 0;
      *(void *)(v9 + 96) = v9 + 834;
      *(_OWORD *)(v9 + 104) = xmmword_184997E70;
      uint64_t v24 = 0;
      CA::OGL::PingPongState::render_pass((uint64_t)this, v15, v16, 0, &v24, a2, a3, 0.0, 0.0);
      CA::OGL::Context::array_flush(v9);
      __int16 v21 = this[4].i16[0];
      int v22 = v21;
      uint64_t v23 = (uint64_t *)&this[(v21 & 1) + 11];
      if (v22 < 0) {
        uint64_t v23 = (uint64_t *)&this[1];
      }
      CA::OGL::Context::unbind_surface(*this, *v23, 0);
      *(unsigned char *)(*(void *)(v9 + 16) + 16) = 0;
      CA::OGL::Context::pop_surface(*(CA::OGL::Context **)this);
      ++this[4].i16[0];
    }
  }
}

uint64_t CA::OGL::MetalContext::reset_attached_surface(uint64_t this)
{
  *(void *)(this + 272) = 0;
  *(void *)(this + 3992) = 0;
  return this;
}

void CA::OGL::BlurState::single_pass_blur(float32x2_t *this, float a2, float a3, int a4)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (uint64_t)*this;
  char v9 = *(unsigned char *)(*(void *)(*(void *)this + 16) + 16);
  uint64_t v10 = (uint64_t)*this;
  if ((a4 & 1) == 0)
  {
    if (!CA::OGL::PingPongState::attach_dest(this, 1, 0)) {
      return;
    }
    uint64_t v10 = (uint64_t)*this;
  }
  __int16 v11 = this[4].i16[0];
  int v12 = v11;
  int v13 = (uint64_t *)&this[(v11 & 1) + 11];
  if (v12 < 0) {
    int v13 = (uint64_t *)&this[1];
  }
  int v14 = *(_DWORD *)(*v13 + 32);
  int v15 = *(_DWORD *)(*v13 + 36);
  CA::OGL::Context::bind_surface(v10, *v13, 0, 1u, 1, 0.0);
  *(unsigned char *)(*(void *)(v8 + 16) + 16) = 41;
  int v46 = 0;
  uint64_t v45 = 0;
  long double v16 = exp(-0.5 / a2);
  long double v17 = v16 * 2.0 + 1.0;
  double v18 = v16 / v17;
  double v19 = 1.0 / v17;
  double v20 = 1.0 / v17;
  double v21 = v18;
  if (a2 != a3)
  {
    if (a2 < 0.0 == a3 >= 0.0) {
      goto LABEL_11;
    }
    unsigned int v22 = LODWORD(a2) - LODWORD(a3);
    if (LODWORD(a2) - LODWORD(a3) < 0) {
      unsigned int v22 = LODWORD(a3) - LODWORD(a2);
    }
    double v20 = v19;
    double v21 = v18;
    if (v22 >= 4)
    {
LABEL_11:
      long double v23 = exp(-0.5 / a3);
      long double v24 = v23 * 2.0 + 1.0;
      double v21 = v23 / v24;
      double v20 = 1.0 / v24;
    }
  }
  *(float *)&unsigned int v25 = v19 * 4.0 * v18;
  *(float *)&unsigned int v26 = v20 * (4.0 * v21);
  int v44 = 1048576000;
  v43.f32[0] = -*(float *)&v25;
  v43.f32[1] = -*(float *)&v26;
  v43.i32[2] = v25;
  v43.f32[3] = -*(float *)&v26;
  uint64_t v27 = *(void *)(v8 + 16);
  unsigned int v29 = *(_DWORD *)(v27 + 96);
  unsigned int v28 = *(_DWORD *)(v27 + 100);
  v30.i64[0] = __PAIR64__(v28, v29);
  v42.f32[0] = -*(float *)&v25;
  *(uint64_t *)((char *)v42.i64 + 4) = __PAIR64__(v25, v26);
  v30.i64[1] = __PAIR64__(v28, v29);
  v42.i32[3] = v26;
  float32x4_t v42 = vmulq_f32(v42, v30);
  float32x4_t v43 = vmulq_f32(v43, v30);
  float v31 = 1.0;
  if (this[13].i32[0] == 2)
  {
    if ((a4 & 1) == 0)
    {
      float v31 = 1.0;
      if ((this[13].i8[4] & 2) == 0) {
        float v31 = 0.0;
      }
    }
  }
  else
  {
    float v31 = 0.0;
  }
  float v41 = v31;
  (*(void (**)(uint64_t, void, uint64_t, uint64_t, float32x4_t *))(*(void *)v8 + 1000))(v8, 0, 2, 4, &v42);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(*(void *)v8 + 1000))(v8, 1, 4, 1, &v44);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, float *))(*(void *)v8 + 1000))(v8, 2, 1, 1, &v41);
  if (a4)
  {
    int v32 = (this[13].u8[4] >> 1) & 1;
    uint64_t v40 = 0;
    CA::OGL::PingPongState::render_pass_final_dest(*this, v14, v15, v32, &v40);
  }
  else
  {
    *(void *)(v8 + 128) = 0;
    *(void *)(v8 + 96) = v8 + 834;
    *(_OWORD *)(v8 + 104) = xmmword_184997E70;
    uint64_t v39 = 0;
    CA::OGL::PingPongState::render_pass((uint64_t)this, v14, v15, 0, &v39, 1.0, 1.0, 0.0, 0.0);
    CA::OGL::Context::array_flush(v8);
  }
  __int16 v33 = this[4].i16[0];
  int v34 = v33;
  uint64_t v35 = (uint64_t *)&this[(v33 & 1) + 11];
  if (v34 < 0) {
    uint64_t v35 = (uint64_t *)&this[1];
  }
  CA::OGL::Context::unbind_surface(*this, *v35, 0);
  *(unsigned char *)(*(void *)(v8 + 16) + 16) = v9;
  if ((a4 & 1) == 0)
  {
    if ((*(_WORD *)(v8 + 832) & 0x7000) != 0)
    {
      __int16 v36 = this[4].i16[0];
      int v37 = v36;
      uint64_t v38 = &this[(v36 & 1) + 11];
      if (v37 < 0) {
        uint64_t v38 = this + 1;
      }
      *(unsigned char *)(*(void *)(v8 + 264) + 73) = *(unsigned char *)(*(void *)(v8 + 264) + 73) & 0xC0 | *(unsigned char *)(*(void *)v38 + 73) & 0x3F;
    }
    CA::OGL::Context::pop_surface(*(CA::OGL::Context **)this);
    ++this[4].i16[0];
  }
}

uint64_t CA::OGL::Context::function_supported(void *a1, char a2)
{
  uint64_t v3 = a1[2];
  char v4 = *(unsigned char *)(v3 + 16);
  *(unsigned char *)(v3 + 16) = a2;
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 984))(a1);
  *(unsigned char *)(a1[2] + 16) = v4;
  return result;
}

char *CAML::anonymous namespace'::sax_characters(char **this, const char *a2, const unsigned __int8 *a3)
{
  return CAML::State::characters(this[6], a2, (int)a3);
}

uint64_t CA::OGL::MaskNode::prepare(CA::OGL::MaskNode *this)
{
  uint64_t result = (uint64_t)CA::OGL::ImagingNode::prepare(this);
  uint64_t v3 = *((void *)this + 2);
  if ((*(unsigned char *)(v3 + 32) & 2) != 0)
  {
    if (*((unsigned char *)this + 224))
    {
      uint64_t result = *((void *)this + 29);
      if (!result) {
        return result;
      }
    }
    else
    {
      uint64_t result = CA::OGL::prepare_layer(*((void *)this + 1), *(void *)(*(void *)(v3 + 16) + 128), (const CA::Render::TransitionSubclass *)v3, (uint64_t)this + 56, 0x4000000, (*((_DWORD *)this + 55) >> 22) & 1);
      *((void *)this + 29) = result;
      *((unsigned char *)this + 224) |= 1u;
      if (!result) {
        return result;
      }
    }
    int v5 = *(_DWORD *)(*(void *)(result + 104) + 220);
    if ((v5 & 0x100000) != 0)
    {
      *((_DWORD *)this + 55) |= 0x100000u;
      int v5 = *(_DWORD *)(*(void *)(result + 104) + 220);
    }
    if ((v5 & 0x800000) != 0) {
      *((_DWORD *)this + 55) |= 0x800000u;
    }
  }
  else
  {
    uint64_t v4 = *((void *)this + 3);
    if (v4)
    {
      if ((*(unsigned char *)(v4 + 222) & 0x10) == 0) {
        *(_DWORD *)(v4 + 216) |= 0x800u;
      }
    }
  }
  return result;
}

_DWORD *CA::OGL::ImagingNode::prepare(CA::OGL::ImagingNode *this)
{
  uint64_t v2 = 0;
  char v3 = 1;
  do
  {
    char v4 = v3;
    int v5 = (char *)this + 8 * v2;
    uint64_t v8 = (_DWORD *)*((void *)v5 + 3);
    uint64_t v7 = v5 + 24;
    uint64_t result = v8;
    if (v8)
    {
      if ((*((unsigned char *)this + 222) & 0x40) != 0)
      {
        result[55] |= 0x400000u;
        uint64_t result = *(_DWORD **)v7;
      }
      uint64_t result = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)result + 88))(result);
      char v9 = *(_DWORD **)v7;
      int v10 = *(_DWORD *)(*(void *)v7 + 220);
      if ((v10 & 0x300000) != 0)
      {
        *((_DWORD *)this + 55) |= 0x100000u;
        int v10 = v9[55];
      }
      if ((v10 & 0x800000) != 0) {
        *((_DWORD *)this + 55) |= 0x800000u;
      }
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while ((v4 & 1) != 0);
  return result;
}

BOOL CA::ColorMatrix::is_diagonal(CA::ColorMatrix *this)
{
  return *((float *)this + 1) == 0.0
      && *((float *)this + 2) == 0.0
      && *((float *)this + 3) == 0.0
      && *((float *)this + 4) == 0.0
      && *((float *)this + 5) == 0.0
      && *((float *)this + 7) == 0.0
      && *((float *)this + 8) == 0.0
      && *((float *)this + 9) == 0.0
      && *((float *)this + 10) == 0.0
      && *((float *)this + 11) == 0.0
      && *((float *)this + 13) == 0.0
      && *((float *)this + 14) == 0.0
      && *((float *)this + 15) == 0.0
      && *((float *)this + 16) == 0.0
      && *((float *)this + 17) == 0.0
      && *((float *)this + 19) == 0.0;
}

void sub_184725808(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2CA3OGL12MetalContext22add_completed_callbackEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

float64_t CA::OGL::get_filter_color_matrix(CA::OGL *this, const CA::Render::Filter *a2, CA::ColorMatrix *a3)
{
  if (!this) {
    goto LABEL_14;
  }
  uint64_t v3 = *((unsigned int *)this + 4);
  if (!v3) {
    goto LABEL_14;
  }
  uint64_t v4 = 0;
  while (1)
  {
    uint64_t v5 = *((void *)this + v4 + 3);
    if (*(_DWORD *)(v5 + 16) == 290) {
      break;
    }
    if (v3 == ++v4) {
      goto LABEL_14;
    }
  }
  if ((v4 & 0x80000000) == 0
    && (uint64_t v6 = *(void *)(v5 + 24)) != 0
    && *(unsigned char *)(v6 + 12) == 56
    && *(_DWORD *)(v6 + 16) == 20)
  {
    uint64_t v7 = 0;
    uint64_t v8 = (float64x2_t *)(v6 + 24);
    do
    {
      float64x2_t v10 = *v8;
      float64x2_t v9 = v8[1];
      v8 += 2;
      *(float32x4_t *)((char *)a2 + v7) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v10), v9);
      v7 += 16;
    }
    while (v7 != 80);
  }
  else
  {
LABEL_14:
    *(_DWORD *)a2 = 1065353216;
    *(void *)&v9.f64[0] = 1065353216;
    *((void *)a2 + 9) = 1065353216;
    *(void *)((char *)a2 + 12) = 0;
    *(void *)((char *)a2 + 4) = 0;
    *(void *)((char *)a2 + 20) = 0x3F80000000000000;
    *(void *)((char *)a2 + 44) = 0x3F80000000000000;
    *(void *)((char *)a2 + 36) = 0;
    *(void *)((char *)a2 + 28) = 0;
    *(void *)((char *)a2 + 60) = 0;
    *(void *)((char *)a2 + 52) = 0;
    *((_DWORD *)a2 + 17) = 0;
  }
  return v9.f64[0];
}

uint64_t CA::OGL::MetalContext::create_texture(id *this, uint64_t a2, unint64_t a3, MTLPixelFormat a4, uint64_t a5, const unsigned __int8 *a6, BOOL a7, const char *a8)
{
  v29[6] = *MEMORY[0x1E4F143B8];
  if (a4 == MTLPixelFormatInvalid) {
    return 0;
  }
  MTLPixelFormat v9 = a4;
  double v14 = CA::OGL::MetalContext::new_image((CA::OGL::MetalContext *)this);
  uint64_t v15 = v13;
  __int16 v16 = a3 > 1;
  if (a3 <= 1) {
    int v17 = 1114112;
  }
  else {
    int v17 = 1179648;
  }
  unsigned int v18 = v17 | *(_DWORD *)(v13 + 52) & 0xFF00FFFF;
  *(_DWORD *)(v13 + 48) = -1098907648;
  *(_DWORD *)(v13 + 52) = v18;
  *(unsigned char *)(v13 + 56) = *(unsigned char *)(v13 + 56) & 0xC0 | 0x17;
  *(_WORD *)(v13 + 58) &= 0xFFE7u;
  *(_WORD *)(v13 + 123) = *(_WORD *)(v13 + 123) & 0xFFEF | (16 * v16);
  switch(a2)
  {
    case 80:
      unsigned int v19 = v18 & 0xC013FFFF;
      uint64_t v20 = 4;
      break;
    case 25:
      unsigned int v19 = v18 & 0xC013FFFF | 0x14000000;
      uint64_t v20 = 2;
      break;
    case 1:
      unsigned int v19 = v18 & 0xC013FFFF | 0x15000000;
      uint64_t v20 = 1;
      break;
    default:
      __assert_rtn("create_texture", "ogl-metal.mm", 10879, "false");
  }
  *(_DWORD *)(v13 + 52) = v19;
  id v21 = (id)objc_msgSend(MEMORY[0x1E4F35330], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", a2, 32, 32, a3 > 1, v14);
  *(void *)(v15 + 88) = v21;
  [v21 setMipmapLevelCount:a3];
  [*(id *)(v15 + 88) setUsage:1];
  uint64_t v22 = [this[369] newTextureWithDescriptor:*(void *)(v15 + 88)];
  *(void *)(v15 + 64) = v22;
  if (!v22)
  {

    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, (void *)v15);
    return 0;
  }
  objc_msgSend(*(id *)(v15 + 64), "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a5));
  uint64_t v23 = 0;
  unint64_t v24 = 32;
  unint64_t v25 = 32;
  do
  {
    unsigned int v26 = *(void **)(v15 + 64);
    memset(v29, 0, 24);
    v29[3] = v24;
    v29[4] = v25;
    v29[5] = 1;
    [v26 replaceRegion:v29 mipmapLevel:v23++ withBytes:v9 bytesPerRow:v24 * v20];
    v9 += v24 * v20 * v25;
    if (v24 <= 1) {
      unint64_t v24 = 1;
    }
    else {
      v24 >>= 1;
    }
    if (v25 <= 1) {
      unint64_t v25 = 1;
    }
    else {
      v25 >>= 1;
    }
  }
  while (a3 != v23);
  *(unsigned char *)(v15 + 122) = 1;
  *(_WORD *)(v15 + 123) = *(_WORD *)(v15 + 123) & 0xFFF8 | v16 | 2;
  return v15;
}

void CA::OGL::MetalContext::update_surface(uint64_t a1, unint64_t a2, unsigned int *a3, int a4, uint64_t a5)
{
  uint64_t v130 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a2 + 32);
  if (!v6) {
    return;
  }
  uint64_t v8 = a3;
  if (*(void *)(a2 + 8))
  {
    float64x2_t v10 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 160))(v6);
    int v113 = (*(uint64_t (**)(void))(**(void **)(a2 + 8) + 104))(*(void *)(a2 + 8));
    float v11 = (*(float (**)(void))(**(void **)(a2 + 8) + 152))(*(void *)(a2 + 8));
    if (!v10) {
      return;
    }
    goto LABEL_8;
  }
  float v11 = (*(float (**)(unsigned int *))(*(void *)a3 + 152))(a3);
  uint64_t v12 = *(void *)(a2 + 40);
  if (!v12) {
    uint64_t v12 = *(void *)(a2 + 32);
  }
  float64x2_t v10 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(void *)v12 + 160))(v12);
  int v113 = -1;
  if (v10)
  {
LABEL_8:
    uint64_t v108 = a5;
    char v122 = 0;
    buffer = v10;
    OSType PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(v10);
    unint64_t v15 = 0;
    char v115 = 0;
    uint64_t v109 = 0;
    __int16 v110 = (CA::Render::Surface *)v8;
    uint64_t v111 = 0;
    char v107 = 0;
    __int16 v16 = (id *)(a2 + 88);
    unsigned int v116 = 1;
    char v117 = 0;
    while (1)
    {
      unsigned int v18 = v8[4];
      unsigned int v17 = v8[5];
      int v19 = CA::Render::Surface::chroma_location((__IOSurface **)v8, v13) == 2 ? -1 : -2;
      MTLPixelFormat v20 = v113 == -1 ? MTLPixelFormatInvalid : CA::OGL::MetalContext::image_parameters(a1, v113, v15, &v122);
      id v21 = (CA::Render *)CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0);
      OSType PixelFormat = v21;
      if (v15) {
        break;
      }
      if (v18 < 2) {
        BYTE4(v111) = 0;
      }
      else {
        HIDWORD(v111) = CA::Render::fourcc_is_444(v21) ^ 1;
      }
      if (v17 < 2)
      {
        LOBYTE(v111) = 0;
        if (v20 == MTLPixelFormatInvalid) {
          goto LABEL_17;
        }
      }
      else
      {
        LOBYTE(v111) = CA::Render::fourcc_is_420(PixelFormat);
        if (v20 == MTLPixelFormatInvalid) {
          goto LABEL_17;
        }
      }
LABEL_18:
      if ((int)PixelFormat <= 1936077361)
      {
        if ((int)PixelFormat > 1882468913)
        {
          if ((int)PixelFormat > 1886680623)
          {
            if ((int)PixelFormat > 1932550514)
            {
              if ((int)PixelFormat > 1932812658)
              {
                if (PixelFormat == 1932812659) {
                  goto LABEL_211;
                }
                unsigned __int16 v24 = 12848;
                goto LABEL_209;
              }
              if (PixelFormat == 1932550515) {
                goto LABEL_211;
              }
              int v38 = 1932681587;
LABEL_210:
              if (PixelFormat == v38) {
                goto LABEL_211;
              }
              goto LABEL_247;
            }
            if ((PixelFormat - 1886680624) > 4 || ((1 << ((_BYTE)PixelFormat - 48)) & 0x15) == 0)
            {
              if (PixelFormat == 1919365992)
              {
                char v122 = 36;
                unsigned int v116 = 3;
                if ((v117 & 1) == 0)
                {
                  char v117 = 0;
                  MTLPixelFormat v20 = MTLPixelFormatR16Float;
                  goto LABEL_293;
                }
                MTLPixelFormat v20 = MTLPixelFormatR16Float;
                goto LABEL_248;
              }
              goto LABEL_247;
            }
          }
          else
          {
            if ((int)PixelFormat <= 1885745713)
            {
              if (PixelFormat == 1882468914 || PixelFormat == 1882469428) {
                goto LABEL_216;
              }
              unsigned __int16 v25 = 12848;
LABEL_214:
              int v54 = v25 | 0x70660000;
              goto LABEL_215;
            }
            if ((PixelFormat - 1886676528) > 4 || ((1 << ((_BYTE)PixelFormat - 48)) & 0x15) == 0)
            {
              if (PixelFormat == 1885745714) {
                goto LABEL_216;
              }
              unsigned __int16 v25 = 13364;
              goto LABEL_214;
            }
          }
          int CompressionTypeOfPlane = IOSurfaceGetCompressionTypeOfPlane();
          if ((~*(_DWORD *)(a1 + 2724) & 0xC0) != 0
            || (int v34 = CompressionTypeOfPlane, CA::Render::Surface::ycbcr_matrix(v110, v33) > 6)
            || v34 != 3)
          {
            MTLPixelFormat v20 = MTLPixelFormatInvalid;
          }
          else
          {
            if ((v111 & 0x100000000) != 0) {
              int v35 = v19;
            }
            else {
              int v35 = -1;
            }
            v18 &= v35;
            if (v111) {
              int v36 = v19;
            }
            else {
              int v36 = -1;
            }
            v17 &= v36;
            HIDWORD(v109) = 1;
          }
          uint64_t v8 = (unsigned int *)v110;
          goto LABEL_247;
        }
        if ((int)PixelFormat <= 875836533)
        {
          if ((int)PixelFormat <= 875704437)
          {
            if ((int)PixelFormat <= 846624120)
            {
              if (PixelFormat != 843264104)
              {
                int v23 = 843264310;
                goto LABEL_98;
              }
              goto LABEL_199;
            }
            if (PixelFormat == 846624121) {
              goto LABEL_113;
            }
            unsigned __int16 v30 = 12390;
            goto LABEL_112;
          }
          if ((int)PixelFormat > 875704949)
          {
            if (PixelFormat == 875704950) {
              goto LABEL_152;
            }
            int v26 = 875836518;
          }
          else
          {
            if (PixelFormat == 875704438) {
              goto LABEL_152;
            }
            unsigned __int16 v30 = 12902;
LABEL_112:
            int v26 = v30 | 0x34320000;
          }
LABEL_151:
          if (PixelFormat != v26) {
            goto LABEL_247;
          }
          goto LABEL_152;
        }
        if ((int)PixelFormat > 1278555444)
        {
          if ((int)PixelFormat <= 1279342647)
          {
            if (PixelFormat == 1278555445)
            {
              char v43 = 1;
              goto LABEL_246;
            }
            int v23 = 1279340600;
LABEL_98:
            if (PixelFormat != v23) {
              goto LABEL_247;
            }
LABEL_199:
            char v27 = 31;
            goto LABEL_200;
          }
          if (PixelFormat == 1279342648) {
            goto LABEL_199;
          }
          int v54 = 1882468912;
LABEL_215:
          if (PixelFormat != v54) {
            goto LABEL_247;
          }
LABEL_216:
          int v56 = *(_DWORD *)(a1 + 2724);
          if ((v56 & 0x80) != 0)
          {
            if (CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v22) <= 5)
            {
              int v56 = *(_DWORD *)(a1 + 2724);
              goto LABEL_219;
            }
          }
          else
          {
LABEL_219:
            if ((v56 & 0x80) != 0
              || CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v22) < 5)
            {
              goto LABEL_247;
            }
          }
          char v122 = 32;
          LOBYTE(v109) = CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v22);
          if ((int)PixelFormat > 1885745711)
          {
            if (PixelFormat == 1885746228) {
              goto LABEL_350;
            }
            if (PixelFormat == 1885745714) {
              goto LABEL_352;
            }
            if (PixelFormat != 1885745712) {
              goto LABEL_247;
            }
          }
          else if (PixelFormat != 1882468912)
          {
            if (PixelFormat != 1882468914)
            {
              if (PixelFormat != 1882469428) {
                goto LABEL_247;
              }
LABEL_350:
              if ((v117 & 1) == 0)
              {
                char v117 = 0;
                MTLPixelFormat v20 = 548;
                goto LABEL_293;
              }
              MTLPixelFormat v20 = 548;
              goto LABEL_248;
            }
LABEL_352:
            v18 &= v19;
            if ((v117 & 1) == 0)
            {
              char v117 = 0;
              MTLPixelFormat v20 = MTLPixelFormatRG8Sint|MTLPixelFormatA8Unorm|0x200;
              goto LABEL_293;
            }
            MTLPixelFormat v20 = MTLPixelFormatRG8Sint|MTLPixelFormatA8Unorm|0x200;
            goto LABEL_248;
          }
          v18 &= v19;
          v17 &= v19;
          if ((v117 & 1) == 0)
          {
            char v117 = 0;
            MTLPixelFormat v20 = MTLPixelFormatRG8Sint|0x200;
            goto LABEL_293;
          }
          MTLPixelFormat v20 = MTLPixelFormatRG8Sint|0x200;
          goto LABEL_248;
        }
        if ((int)PixelFormat > 1278226487)
        {
          if (PixelFormat != 1278226488 && PixelFormat != 1278226742) {
            goto LABEL_247;
          }
          char v43 = 30;
LABEL_246:
          char v122 = v43;
          goto LABEL_247;
        }
        if (PixelFormat != 875836534)
        {
          if (PixelFormat != 1093677112 || v113 == 8) {
            goto LABEL_247;
          }
          char v27 = 21;
LABEL_200:
          char v122 = v27;
          goto LABEL_247;
        }
      }
      else if ((int)PixelFormat <= 1983013175)
      {
        if ((int)PixelFormat <= 1952854575)
        {
          if ((int)PixelFormat <= 1937126451)
          {
            if ((int)PixelFormat > 1937125935)
            {
              if (PixelFormat == 1937125936) {
                goto LABEL_211;
              }
              int v38 = 1937125938;
            }
            else
            {
              if (PixelFormat == 1936077362) {
                goto LABEL_211;
              }
              unsigned __int16 v24 = 13364;
LABEL_209:
              int v38 = v24 | 0x73660000;
            }
            goto LABEL_210;
          }
          if ((int)PixelFormat <= 1949458802)
          {
            if (PixelFormat == 1937126452) {
              goto LABEL_211;
            }
            int v31 = 1949327731;
            goto LABEL_171;
          }
          if (PixelFormat != 1949458803)
          {
            int v31 = 1949589875;
LABEL_171:
            if (PixelFormat != v31) {
              goto LABEL_247;
            }
          }
          if (IOSurfaceGetCompressionTypeOfPlane() != 3
            || CA::Render::ycbcr_fourcc_depth(PixelFormat) != 12)
          {
            goto LABEL_211;
          }
          char v122 = 41;
          LOBYTE(v109) = CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v50);
          if (v15 > 1)
          {
            if ((v117 & 1) == 0)
            {
              unsigned int v116 = 3;
              char v117 = 0;
              MTLPixelFormat v20 = MTLPixelFormatR16Unorm;
              goto LABEL_301;
            }
            MTLPixelFormat v20 = MTLPixelFormatR16Unorm;
LABEL_238:
            char v117 = 1;
LABEL_360:
            unsigned int v116 = 3;
            goto LABEL_301;
          }
          switch(PixelFormat)
          {
            case 0x74346173:
              unsigned int v116 = 3;
              if ((v117 & 1) == 0)
              {
                char v117 = 0;
                MTLPixelFormat v20 = MTLPixelFormatRGBA8Unorm|0x200;
                goto LABEL_293;
              }
              MTLPixelFormat v20 = MTLPixelFormatRGBA8Unorm|0x200;
              goto LABEL_248;
            case 0x74326173:
              v18 &= v19;
              unsigned int v116 = 3;
              if ((v117 & 1) == 0)
              {
                char v117 = 0;
                MTLPixelFormat v20 = 581;
                goto LABEL_293;
              }
              MTLPixelFormat v20 = 581;
              goto LABEL_248;
            case 0x74306173:
              v18 &= v19;
              v17 &= v19;
              unsigned int v116 = 3;
              if ((v117 & 1) == 0)
              {
                char v117 = 0;
                MTLPixelFormat v20 = 580;
                goto LABEL_293;
              }
              MTLPixelFormat v20 = 580;
              goto LABEL_248;
          }
          unsigned int v116 = 3;
LABEL_247:
          if ((v117 & 1) == 0)
          {
            char v117 = 0;
            goto LABEL_293;
          }
          goto LABEL_248;
        }
        if ((int)PixelFormat <= 1953903153)
        {
          if ((int)PixelFormat > 1952855091)
          {
            if (PixelFormat == 1952855092) {
              goto LABEL_137;
            }
            unsigned __int16 v37 = 12848;
LABEL_135:
            int v28 = v37 | 0x74760000;
          }
          else
          {
            if (PixelFormat == 1952854576) {
              goto LABEL_137;
            }
            int v28 = 1952854578;
          }
          if (PixelFormat == v28) {
            goto LABEL_137;
          }
          goto LABEL_247;
        }
        if ((int)PixelFormat <= 1982882103)
        {
          if (PixelFormat != 1953903154)
          {
            unsigned __int16 v37 = 13364;
            goto LABEL_135;
          }
LABEL_137:
          if ((~*(_DWORD *)(a1 + 2724) & 0xA0) != 0
            || CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v22) > 6
            || CA::Render::ycbcr_fourcc_depth(PixelFormat) != 12)
          {
LABEL_211:
            char v115 = 1;
            goto LABEL_248;
          }
          goto LABEL_188;
        }
        if (PixelFormat != 1982882104)
        {
          if (PixelFormat == 1983000886)
          {
            char v122 = 40;
            if (v15) {
              MTLPixelFormat v20 = MTLPixelFormatRGBA16Unorm;
            }
            else {
              MTLPixelFormat v20 = MTLPixelFormatRG16Unorm;
            }
            v18 >>= v15 != 0;
            LOBYTE(v109) = CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v22);
            char v107 = CA::Render::Surface::chroma_location((__IOSurface **)v8, v55);
            unsigned int v116 = 2;
            BYTE4(v111) = 1;
          }
          goto LABEL_247;
        }
      }
      else
      {
        if ((int)PixelFormat > 2016687155)
        {
          if ((int)PixelFormat <= 2019963441)
          {
            if ((int)PixelFormat <= 2016698738)
            {
              if (PixelFormat != 2016687156)
              {
                int v29 = 2016698680;
LABEL_128:
                if (PixelFormat != v29) {
                  goto LABEL_247;
                }
                goto LABEL_144;
              }
              goto LABEL_183;
            }
            if (PixelFormat == 2016698739) {
              goto LABEL_144;
            }
            unsigned __int16 v39 = 12848;
          }
          else
          {
            if ((int)PixelFormat > 2033463605)
            {
              if (PixelFormat == 2033463606)
              {
                char v122 = 39;
                LOBYTE(v109) = CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v22);
              }
              else if (PixelFormat == 2037741158 || PixelFormat == 2037741171)
              {
LABEL_113:
                if ((*(unsigned char *)(a1 + 2724) & 4) == 0
                  || ((unsigned int v40 = CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v22),
                       int v41 = *(_DWORD *)(a1 + 2724),
                       (v41 & 0x80) != 0)
                    ? (unsigned int v42 = 6)
                    : (unsigned int v42 = 4),
                      v42 < v40 || (v41 & 8) == 0 && PixelFormat == 846624121))
                {
                  char v122 = 32;
                  LOBYTE(v109) = CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v22);
                  if (PixelFormat == 846624121) {
                    MTLPixelFormat v20 = MTLPixelFormatBGRG422;
                  }
                  else {
                    MTLPixelFormat v20 = MTLPixelFormatGBGR422;
                  }
                  v18 &= v19;
                }
              }
              goto LABEL_247;
            }
            if (PixelFormat == 2019963442) {
              goto LABEL_183;
            }
            unsigned __int16 v39 = 13364;
          }
          int v44 = v39 | 0x78660000;
LABEL_182:
          if (PixelFormat != v44) {
            goto LABEL_247;
          }
LABEL_183:
          int v51 = *(_DWORD *)(a1 + 2724);
          if ((v51 & 0x10) != 0)
          {
            if (CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v22) < 5) {
              goto LABEL_188;
            }
            int v51 = *(_DWORD *)(a1 + 2724);
          }
          if ((v51 & 0x80) == 0 || CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v22) > 6) {
            goto LABEL_211;
          }
LABEL_188:
          if ((CA::Render::ycbcr_fourcc_is_triplanar(PixelFormat) & 1) == 0)
          {
            if ((v111 & 0x100000000) != 0) {
              int v52 = v19;
            }
            else {
              int v52 = -1;
            }
            v18 &= v52;
            if (v111) {
              int v53 = v19;
            }
            else {
              int v53 = -1;
            }
            v17 &= v53;
            char v115 = 1;
            if ((v117 & 1) == 0)
            {
              char v117 = 0;
              HIDWORD(v109) = 1;
              goto LABEL_293;
            }
            HIDWORD(v109) = 1;
            goto LABEL_248;
          }
          goto LABEL_211;
        }
        if ((int)PixelFormat > 2016567607)
        {
          if ((int)PixelFormat <= 2016686639)
          {
            if (PixelFormat == 2016567608) {
              goto LABEL_144;
            }
            int v29 = 2016567667;
            goto LABEL_128;
          }
          if (PixelFormat != 2016686640)
          {
            int v44 = 2016686642;
            goto LABEL_182;
          }
          goto LABEL_183;
        }
        if ((int)PixelFormat > 2016436535)
        {
          if (PixelFormat != 2016436536)
          {
            int v29 = 2016436595;
            goto LABEL_128;
          }
LABEL_144:
          int v106 = v19;
          if (v15 == 2)
          {
            char v115 = 0;
            if (PixelFormat == 2016436536 || PixelFormat == 2016567608)
            {
              uint64_t v45 = 10;
            }
            else
            {
              uint64_t v45 = 10;
              if (PixelFormat != 2016698680) {
                goto LABEL_148;
              }
            }
          }
          else
          {
LABEL_148:
            char v115 = 1;
            uint64_t v45 = 20;
          }
          if (IOSurfaceGetCompressionTypeOfPlane() != 3)
          {
            int v19 = v106;
            goto LABEL_248;
          }
          char v122 = 41;
          LOBYTE(v109) = CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v57);
          if (v15 > 1)
          {
            if (v15 == 2) {
              MTLPixelFormat v20 = v45;
            }
            if (v117) {
              goto LABEL_238;
            }
            char v117 = 0;
            goto LABEL_360;
          }
          unsigned int v116 = 3;
          if ((int)PixelFormat > 2016567666)
          {
            int v19 = v106;
            if (PixelFormat != 2016567667)
            {
              if (PixelFormat == 2016698680 || PixelFormat == 2016698739)
              {
                unsigned int v116 = 3;
                if ((v117 & 1) == 0)
                {
                  char v117 = 0;
                  MTLPixelFormat v20 = MTLPixelFormatX24_Stencil8|MTLPixelFormatGBGR422|0x8;
                  goto LABEL_293;
                }
                MTLPixelFormat v20 = MTLPixelFormatX24_Stencil8|MTLPixelFormatGBGR422|0x8;
                goto LABEL_248;
              }
              goto LABEL_247;
            }
          }
          else
          {
            int v19 = v106;
            if (PixelFormat == 2016436536 || PixelFormat == 2016436595)
            {
              v18 &= v106;
              v17 &= v106;
              unsigned int v116 = 3;
              if ((v117 & 1) == 0)
              {
                char v117 = 0;
                MTLPixelFormat v20 = MTLPixelFormatDepth32Float_Stencil8|MTLPixelFormatGBGR422|0x8;
                goto LABEL_293;
              }
              MTLPixelFormat v20 = MTLPixelFormatDepth32Float_Stencil8|MTLPixelFormatGBGR422|0x8;
              goto LABEL_248;
            }
            if (PixelFormat != 2016567608) {
              goto LABEL_247;
            }
          }
          v18 &= v19;
          unsigned int v116 = 3;
          if ((v117 & 1) == 0)
          {
            char v117 = 0;
            MTLPixelFormat v20 = MTLPixelFormatX32_Stencil8|MTLPixelFormatGBGR422|0x8;
            goto LABEL_293;
          }
          MTLPixelFormat v20 = MTLPixelFormatX32_Stencil8|MTLPixelFormatGBGR422|0x8;
          goto LABEL_248;
        }
        if (PixelFormat != 1983013176)
        {
          int v26 = 1983144248;
          goto LABEL_151;
        }
      }
LABEL_152:
      if ((v15 != 0) | v115 & 1)
      {
        if (((v15 != 0) & BYTE4(v109)) == 1)
        {
LABEL_154:
          if ((v111 & 0x100000000) != 0) {
            int v46 = v19;
          }
          else {
            int v46 = -1;
          }
          v18 &= v46;
          if (v111) {
            int v47 = v19;
          }
          else {
            int v47 = -1;
          }
          v17 &= v47;
          HIDWORD(v109) = 1;
          goto LABEL_247;
        }
        HIDWORD(v109) = 0;
LABEL_248:
        if (v15)
        {
          if (v15 == 1)
          {
            unsigned int WidthOfPlane = IOSurfaceGetWidthOfPlane(buffer, 1uLL);
            unsigned int HeightOfPlane = IOSurfaceGetHeightOfPlane(buffer, 1uLL);
            if ((*(unsigned char *)(a1 + 2726) & 4) != 0)
            {
              unsigned int v60 = v18 >> 1;
              if (v18 >> 1 >= WidthOfPlane) {
                unsigned int v60 = WidthOfPlane;
              }
              if ((v111 & 0x100000000) != 0) {
                unsigned int WidthOfPlane = v60;
              }
              else {
                unsigned int WidthOfPlane = v18;
              }
              if (v111)
              {
                if (v17 >> 1 < HeightOfPlane) {
                  unsigned int HeightOfPlane = v17 >> 1;
                }
              }
              else
              {
                unsigned int HeightOfPlane = v17;
              }
            }
            if (v115) {
              MTLPixelFormat v20 = MTLPixelFormatRG16Unorm;
            }
            else {
              MTLPixelFormat v20 = MTLPixelFormatRG8Unorm;
            }
            char v117 = 1;
            unsigned int v17 = HeightOfPlane;
            unsigned int v18 = WidthOfPlane;
            uint64_t v8 = (unsigned int *)v110;
          }
          else
          {
            if (v122 == 37)
            {
              if (v115) {
                MTLPixelFormat v20 = MTLPixelFormatR16Unorm;
              }
              else {
                MTLPixelFormat v20 = MTLPixelFormatR8Unorm;
              }
              if (v18 <= 1) {
                int v70 = -1;
              }
              else {
                int v70 = v19;
              }
              v18 &= v70;
              if (v17 <= 1) {
                int v71 = -1;
              }
              else {
                int v71 = v19;
              }
              v17 &= v71;
            }
            char v117 = 1;
          }
          goto LABEL_301;
        }
        int v49 = v19;
        goto LABEL_261;
      }
      if ((*(unsigned char *)(a1 + 2724) & 4) != 0
        && (CA::Render::ycbcr_fourcc_is_triplanar(PixelFormat) & 1) == 0
        && (*(_DWORD *)(a2 + 52) & 0xF0000) != 0x20000
        && CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v48) <= 4
        && ((PixelFormat & 0xFFFFFFEF) == 0x34323066 || (*(unsigned char *)(a1 + 2724) & 0x10) != 0))
      {
        goto LABEL_154;
      }
      int v49 = v19;
      HIDWORD(v109) = 0;
      char v115 = 0;
LABEL_261:
      int is_triplanar = CA::Render::ycbcr_fourcc_is_triplanar(PixelFormat);
      if (is_triplanar) {
        int v63 = 3;
      }
      else {
        int v63 = 2;
      }
      unsigned int v116 = v63;
      if (is_triplanar) {
        char v64 = 37;
      }
      else {
        char v64 = 22;
      }
      char v122 = v64;
      LOBYTE(v109) = CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)v8, v62);
      char v66 = CA::Render::Surface::chroma_location((__IOSurface **)v8, v65);
      if ((v111 & 0x100000000) != 0) {
        int v67 = v49;
      }
      else {
        int v67 = -1;
      }
      v18 &= v67;
      if (v111) {
        int v68 = v49;
      }
      else {
        int v68 = -1;
      }
      v17 &= v68;
      if ((BYTE4(v111) | v111)) {
        char v69 = v66;
      }
      else {
        char v69 = 2;
      }
      char v107 = v69;
      if (v115) {
        MTLPixelFormat v20 = MTLPixelFormatR16Unorm;
      }
      else {
        MTLPixelFormat v20 = MTLPixelFormatR8Unorm;
      }
      char v117 = 1;
LABEL_293:
      if (!v15 && ((HIDWORD(v109) ^ ((*(_WORD *)(a2 + 123) & 0x20) >> 5)) & 1) != 0) {
        CA::OGL::MetalContext::delete_image(a1, a2);
      }
LABEL_301:
      if (v20 == MTLPixelFormatInvalid || !v18 || !v17)
      {
LABEL_383:
        if (v116 != *(unsigned __int8 *)(a2 + 122))
        {
          if (x_log_hook_p())
          {
            if ((PixelFormat & 0x80000000) != 0) {
              __maskrune(PixelFormat >> 24, 0x40000uLL);
            }
            if (BYTE2(PixelFormat) > 0x7Fu) {
              __maskrune(BYTE2(PixelFormat), 0x40000uLL);
            }
            if (BYTE1(PixelFormat) > 0x7Fu) {
              __maskrune(BYTE1(PixelFormat), 0x40000uLL);
            }
            if (PixelFormat > 0x7Fu) {
              __maskrune(PixelFormat, 0x40000uLL);
            }
            x_log_();
            uint64_t v8 = (unsigned int *)v110;
          }
          else
          {
            unsigned int v87 = x_log_category_ogl_metal;
            if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
            {
              unsigned int v88 = PixelFormat >> 24;
              uint64_t v89 = MEMORY[0x1E4F14390];
              if ((PixelFormat & 0x80000000) != 0) {
                int v90 = __maskrune(v88, 0x40000uLL);
              }
              else {
                int v90 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v88 + 60) & 0x40000;
              }
              if (v90) {
                int v93 = (int)PixelFormat >> 24;
              }
              else {
                int v93 = 32;
              }
              if (BYTE2(PixelFormat) <= 0x7Fu) {
                int v94 = *(_DWORD *)(v89 + 4 * BYTE2(PixelFormat) + 60) & 0x40000;
              }
              else {
                int v94 = __maskrune(BYTE2(PixelFormat), 0x40000uLL);
              }
              if (v94) {
                int v95 = SBYTE2(PixelFormat);
              }
              else {
                int v95 = 32;
              }
              if (BYTE1(PixelFormat) <= 0x7Fu) {
                int v96 = *(_DWORD *)(v89 + 4 * BYTE1(PixelFormat) + 60) & 0x40000;
              }
              else {
                int v96 = __maskrune(BYTE1(PixelFormat), 0x40000uLL);
              }
              if (v96) {
                int v97 = SBYTE1(PixelFormat);
              }
              else {
                int v97 = 32;
              }
              if (PixelFormat <= 0x7Fu) {
                int v98 = *(_DWORD *)(v89 + 4 * PixelFormat + 60) & 0x40000;
              }
              else {
                int v98 = __maskrune(PixelFormat, 0x40000uLL);
              }
              uint64_t v8 = (unsigned int *)v110;
              *(_DWORD *)CGRect buf = 67109888;
              int v99 = (char)PixelFormat;
              *(_DWORD *)&uint8_t buf[4] = v93;
              __int16 v124 = 1024;
              if (!v98) {
                int v99 = 32;
              }
              int v125 = v95;
              __int16 v126 = 1024;
              int v127 = v97;
              __int16 v128 = 1024;
              int v129 = v99;
              _os_log_impl(&dword_184668000, v87, OS_LOG_TYPE_ERROR, "unsupported surface format: %c%c%c%c\n", buf, 0x1Au);
            }
          }
        }
        *(_DWORD *)(a2 + 52) = *(_DWORD *)(a2 + 52) & 0xC0FFFFFF | ((v122 & 0x3F) << 24);
        if ((*(unsigned int (**)(unsigned int *))(*(void *)v8 + 128))(v8)) {
          __int16 v100 = 32;
        }
        else {
          __int16 v100 = 0;
        }
        __int16 v101 = *(_WORD *)(a2 + 58) & 0xFF18 | v100;
        __int16 v102 = *(_WORD *)(a2 + 123);
        *(unsigned char *)(a2 + 57) = *(unsigned char *)(a2 + 57) & 0xF0 | v109 & 0xF;
        if ((v111 & 0x100000000) != 0) {
          __int16 v103 = 64;
        }
        else {
          __int16 v103 = 0;
        }
        if (v111) {
          __int16 v104 = 128;
        }
        else {
          __int16 v104 = 0;
        }
        *(_WORD *)(a2 + 58) = v103 & 0xFFF8 | v107 & 7 | v104 | v101;
        if ((v109 & 0x100000000) != 0) {
          __int16 v105 = 32;
        }
        else {
          __int16 v105 = 0;
        }
        *(_WORD *)(a2 + 123) = v102 & 0xFF5B | v105 | ((v11 != 1.0) << 7) | 4;
        *(_DWORD *)(a2 + 16) = v8[9];
        return;
      }
      if (!v15)
      {
        uint64_t v72 = CA::Render::ycbcr_fourcc_depth(PixelFormat);
        char v73 = 32 * (v72 == 10);
        if (v72 == 8) {
          char v73 = 16;
        }
        *(unsigned char *)(a2 + 57) = v73 | *(unsigned char *)(a2 + 57) & 0xCF;
      }
      CA::OGL::MetalContext::update_texture_plane((void *)a1, a2, a4, v15, v20, v18, v17);
      int8x16_t v74 = *(v16 - 3);
      if (!v74 || *(_DWORD *)(a2 + 16) != v8[9] && (unint64_t)[*v16 mipmapLevelCount] >= 2)
      {
        *(v16 - 3) = 0;
        if (*(_WORD *)(a2 + 120) != 1) {
          __assert_rtn("update_surface", "ogl-metal.mm", 12343, "tex->depth == 1 && \"surface textures must be 2D\"");
        }
        [*v16 setUsage:1];
        if (!CA::OGL::MetalContext::is_viable_texture_from_iosurface((CA::OGL::MetalContext *)a1, buffer, v20))
        {

          return;
        }
        [*v16 setMipmapLevelCount:1];
        [*v16 setProtectionOptions:IOSurfaceGetProtectionOptions()];
        if (v122 == 40) {
          unint64_t v75 = 0;
        }
        else {
          unint64_t v75 = v15;
        }
        uint64_t v76 = [*(id *)(a1 + 2952) newTextureWithDescriptor:*v16 iosurface:buffer plane:v75];
        if (!v76)
        {

          if (x_log_hook_p())
          {
            IOSurfaceGetID(buffer);
            x_log_();
          }
          else
          {
            int32x2_t v91 = x_log_category_ogl_metal;
            if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
            {
              IOSurfaceID ID = IOSurfaceGetID(buffer);
              *(_DWORD *)CGRect buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = ID;
              _os_log_impl(&dword_184668000, v91, OS_LOG_TYPE_ERROR, "Failed to allocate MTLTexture from IOSurface 0x%x.", buf, 8u);
            }
          }
          return;
        }
        int32x4_t v77 = (void *)v76;
        BOOL v121 = 0;
        if (PixelFormat == 1983000886)
        {
          unsigned int v78 = *(_DWORD *)(a1 + 2724);
          *(void *)CGRect buf = v20;
          if ((*(_DWORD *)(a2 + 52) & 0xF0000) == 0x20000)
          {
            int v79 = (v78 >> 17) & 1;
            goto LABEL_322;
          }
          if ((v78 & 0x20000) != 0)
          {
LABEL_329:
            if (v18 <= v17) {
              unsigned int v82 = v17;
            }
            else {
              unsigned int v82 = v18;
            }
            [*v16 setMipmapLevelCount:(floor(log2((double)v82)) + 1.0)];
            id v83 = v74;
            if (v83 || (id v83 = (id)[*(id *)(a1 + 2952) newTextureWithDescriptor:*v16]) != 0)
            {
              [v77 setLabel:@"com.apple.coreanimation.surface-source"];
              if (CA::OGL::MetalContext::start_blit_encoder((CA::OGL::MetalContext *)a1, [*v16 protectionOptions]))
              {
                int32x2_t v84 = *(void **)(a1 + 2992);
                v119[0] = v18;
                v119[1] = v17;
                v119[2] = 1;
                memset(v120, 0, sizeof(v120));
                memset(v118, 0, sizeof(v118));
                [v84 copyFromTexture:v77 sourceSlice:0 sourceLevel:0 sourceOrigin:v120 sourceSize:v119 toTexture:v83 destinationSlice:0 destinationLevel:0 destinationOrigin:v118];
                if ((*(_DWORD *)(a2 + 52) & 0xF0000) == 0x20000)
                {
                  if (v116 == *(unsigned __int8 *)(a2 + 122)) {
                    *(_WORD *)(a2 + 123) |= 1u;
                  }
                  [*(id *)(a1 + 2992) generateMipmapsForTexture:v83];
                }
              }
              *(v16 - 3) = v83;

              goto LABEL_342;
            }
            [*v16 setMipmapLevelCount:1];
          }
        }
        else
        {
          *(void *)CGRect buf = v20;
          if ((*(_DWORD *)(a2 + 52) & 0xF0000) == 0x20000)
          {
            LOBYTE(v79) = 0;
LABEL_322:
            char can_generate_mipmaps_for_format = CA::OGL::MetalContext::can_generate_mipmaps_for_format((CA::OGL::MetalContext *)a1, (MTLPixelFormat *)buf, &v121);
            char v81 = v121 ? 0 : can_generate_mipmaps_for_format;
            if (v81 & 1) != 0 || (v79) {
              goto LABEL_329;
            }
          }
        }
        *(v16 - 3) = v77;
LABEL_342:
        uint64_t v8 = (unsigned int *)v110;
        if (v108)
        {
          int v85 = (__CFString *)objc_msgSend(NSString, "stringWithUTF8String:");
          BOOL v86 = *(v16 - 3);
        }
        else
        {
          BOOL v86 = *(v16 - 3);
          int v85 = @"com.apple.coreanimation.surface";
        }
        [v86 setLabel:v85];
        CA::OGL::MetalContext::update_texture_ownership(a1, *(v16 - 3));
        if (v74) {
      }
        }
      ++v15;
      ++v16;
      if (v15 >= v116) {
        goto LABEL_383;
      }
    }
    if (v20) {
      goto LABEL_18;
    }
LABEL_17:
    MTLPixelFormat v20 = CA::OGL::four_cc_to_mtl_format(PixelFormat, *(_DWORD *)(a1 + 2724));
    goto LABEL_18;
  }
}

uint64_t CA::Render::Surface::image_format(CA::Render::Surface *this)
{
  return *((unsigned int *)this + 27);
}

void CA::OGL::MetalContext::update_image(uint64_t a1, unint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v42 = 0;
  MTLPixelFormat v41 = CA::OGL::MetalContext::image_parameters(a1, *(unsigned __int8 *)(a3 + 152), 0, (char *)&v42);
  if (v41)
  {
    int v10 = v42;
    int v11 = *(_DWORD *)(a2 + 52);
    int v12 = v11 & 0xF0000;
    unsigned int v13 = v11 & 0xC0FFFFFF | ((v42 & 0x3F) << 24);
    *(_DWORD *)(a2 + 52) = v13;
    BOOL v15 = *(unsigned __int8 *)(a3 + 153) > 1u || v12 == 0x20000;
    unsigned int v17 = *(_DWORD *)(a3 + 16);
    unsigned int v16 = *(_DWORD *)(a3 + 20);
    uint64_t v18 = *(void *)(a3 + 96);
    if (v10 == 32)
    {
      v17 &= ~1u;
      *(unsigned char *)(a2 + 57) = *(unsigned char *)(a2 + 57) & 0xF0 | 3;
    }
    BOOL v40 = 0;
    if (!v18) {
      BOOL v15 = 0;
    }
    if (v15
      && (can_generate_mipmaps_for_format = CA::OGL::MetalContext::can_generate_mipmaps_for_format((CA::OGL::MetalContext *)a1, &v41, &v40), unsigned int v13 = *(_DWORD *)(a2 + 52), can_generate_mipmaps_for_format))
    {
      *(_WORD *)(a2 + 123) |= 0x11u;
      int v20 = 0x20000;
    }
    else
    {
      *(_WORD *)(a2 + 123) &= 0xFFEEu;
      int v20 = 0x10000;
    }
    *(_DWORD *)(a2 + 52) = v13 & 0xFFF0FFFF | v20;
    CA::OGL::MetalContext::update_texture_plane((void *)a1, a2, a4, 0, v41, v17, v16);
    if (*(void *)(a2 + 64))
    {
      if (!v18)
      {
LABEL_64:
        *(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 36);
        return;
      }
LABEL_36:
      unsigned __int16 v24 = *(void **)(a2 + 64);
      if (v24 && (*(_WORD *)(a2 + 123) & 0x200) == 0)
      {
        uint64_t v25 = *(unsigned __int16 *)(a2 + 120);
        if (v25 == 1)
        {
          unint64_t v26 = *(unsigned __int8 *)(a3 + 153);
          if ([*(id *)(a2 + 88) mipmapLevelCount] <= v26) {
            unsigned int v27 = [*(id *)(a2 + 88) mipmapLevelCount];
          }
          else {
            unsigned int v27 = *(unsigned __int8 *)(a3 + 153);
          }
          uint64_t v30 = v27;
          if (v27)
          {
            uint64_t v32 = 0;
            uint64_t v33 = a3 + 160;
            do
            {
              uint64_t v34 = *(void *)(v33 + 8 * v32);
              int v35 = *(void **)(a2 + 64);
              memset(v39, 0, 24);
              void v39[3] = v17;
              v39[4] = v16;
              v39[5] = 1;
              [v35 replaceRegion:v39 mipmapLevel:v32 slice:0 withBytes:v18 bytesPerRow:v34 bytesPerImage:0];
              v18 += *(void *)(v33 + 8 * v32) * v16;
              if (v17 <= 1) {
                unsigned int v17 = 1;
              }
              else {
                v17 >>= 1;
              }
              if (v16 <= 1) {
                unsigned int v16 = 1;
              }
              else {
                v16 >>= 1;
              }
              ++v32;
            }
            while (v30 != v32);
          }
        }
        else
        {
          uint64_t v28 = *(void *)(a3 + 160);
          if (v16 == 1) {
            uint64_t v29 = 1;
          }
          else {
            uint64_t v29 = v17;
          }
          if (v16 == 1) {
            uint64_t v25 = 1;
          }
          memset(v38, 0, 24);
          v38[3] = v17;
          v38[4] = v29;
          v38[5] = v25;
          [v24 replaceRegion:v38 mipmapLevel:0 slice:0 withBytes:v18 bytesPerRow:v28 bytesPerImage:v28 * v17];
          uint64_t v30 = 1;
        }
        *(void *)(a1 + 728) += CA::Render::Image::data_size((CA::Render::Image *)a3);
        if ((*(unsigned char *)(a2 + 123) & 1) != 0 && v30 != [*(id *)(a2 + 88) mipmapLevelCount]) {
          CA::OGL::MetalContext::generate_mipmaps_for_texture((CA::OGL::MetalContext *)a1, a2);
        }
        if (v40)
        {
          int v36 = *(void **)(a2 + 64);
          unsigned __int16 v37 = (void *)[v36 newTextureViewWithPixelFormat:1];
          *(void *)(a2 + 64) = v37;
          [v37 setLabel:@"com.apple.coreanimation.image-a8"];
        }
      }
      goto LABEL_64;
    }
    [*(id *)(a2 + 88) setUsage:1];
    BOOL v21 = v40;
    if (v40) {
      objc_msgSend(*(id *)(a2 + 88), "setUsage:", objc_msgSend(*(id *)(a2 + 88), "usage") | 0x10);
    }
    if (*(unsigned __int8 *)(a3 + 153) >= 2uLL) {
      objc_msgSend(*(id *)(a2 + 88), "setMipmapLevelCount:");
    }
    if (v18
      && *(_WORD *)(a2 + 120) == 1
      && (*(_WORD *)(a2 + 123) & 0x400) == 0
      && !v21
      && *(unsigned char *)(a3 + 153) == 1
      && CA::OGL::MetalContext::copy_image_to_texture(a1, (CA::Render::Image *)a3, a2))
    {
      goto LABEL_64;
    }
    uint64_t v22 = (void *)[*(id *)(a1 + 2952) newTextureWithDescriptor:*(void *)(a2 + 88)];
    *(void *)(a2 + 64) = v22;
    if (v22)
    {
      if (a5)
      {
        int v23 = (__CFString *)[NSString stringWithUTF8String:a5];
        uint64_t v22 = *(void **)(a2 + 64);
      }
      else
      {
        int v23 = @"com.apple.coreanimation.image";
      }
      [v22 setLabel:v23];
      CA::OGL::MetalContext::update_texture_ownership(a1, *(void **)(a2 + 64));
      if (!v18) {
        goto LABEL_64;
      }
      goto LABEL_36;
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      int v31 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CGRect buf = 0;
        _os_log_impl(&dword_184668000, v31, OS_LOG_TYPE_ERROR, "Failed to allocate MTLTexture\n", buf, 2u);
      }
    }
  }
}

uint64_t CA::OGL::MetalContext::image_parameters(uint64_t a1, int a2, int a3, char *a4)
{
  *a4 = 0;
  if (a3) {
    return 0;
  }
  uint64_t result = 0;
  switch(a2)
  {
    case 0:
      char v8 = 2;
      goto LABEL_21;
    case 1:
      return 80;
    case 2:
      char v8 = 3;
      goto LABEL_21;
    case 3:
      char v8 = 1;
LABEL_21:
      *a4 = v8;
      return 80;
    case 5:
      *a4 = 1;
      goto LABEL_24;
    case 6:
      if ((*(unsigned char *)(a1 + 2724) & 8) != 0) {
        return 562;
      }
      *a4 = 32;
      return 241;
    case 7:
      if ((*(unsigned char *)(a1 + 2724) & 4) != 0) {
        return 501;
      }
      *a4 = 32;
      return 240;
    case 8:
      return 1;
    case 9:
      *a4 = 21;
      return 1;
    case 10:
      *a4 = 30;
      return 10;
    case 11:
    case 29:
      return 70;
    case 12:
      char v9 = 1;
      goto LABEL_35;
    case 13:
      return 115;
    case 14:
      return 125;
    case 15:
      char v9 = 6;
      goto LABEL_35;
    case 16:
      char v9 = 7;
      goto LABEL_35;
    case 17:
      *a4 = 1;
      return 115;
    case 18:
      *a4 = 31;
      return 30;
    case 19:
      uint64_t result = 30;
      *a4 = 30;
      return result;
    case 20:
LABEL_24:
      BOOL v6 = (*(unsigned char *)(a1 + 2725) & 4) == 0;
      uint64_t v7 = 43;
      goto LABEL_40;
    case 21:
      return 110;
    case 22:
      *a4 = 1;
      return 110;
    case 23:
    case 25:
      *a4 = 20;
      return 25;
    case 24:
    case 26:
      *a4 = 20;
      return 55;
    case 27:
      *a4 = 31;
      return 60;
    case 28:
      *a4 = 31;
      return 65;
    case 30:
      char v9 = 28;
LABEL_35:
      *a4 = v9;
      return 70;
    case 31:
      return 94;
    case 32:
      return 90;
    case 33:
      BOOL v6 = (*(unsigned char *)(a1 + 2725) & 2) == 0;
      uint64_t v7 = 554;
      goto LABEL_40;
    case 34:
      BOOL v6 = (*(unsigned char *)(a1 + 2725) & 2) == 0;
      uint64_t v7 = 552;
      goto LABEL_40;
    case 35:
      BOOL v6 = (*(unsigned char *)(a1 + 2725) & 1) == 0;
      uint64_t v7 = 550;
LABEL_40:
      if (v6) {
        uint64_t result = 0;
      }
      else {
        uint64_t result = v7;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t CA::Render::ycbcr_fourcc_depth(CA::Render *this)
{
  int v1 = CA::Render::fourcc_compressed_of_type(this, 0, 0);
  uint64_t v2 = 8;
  if (v1 > 1949458802)
  {
    if (v1 > 2016567666)
    {
      if (v1 <= 2019963439)
      {
        if (v1 <= 2016687155)
        {
          if (v1 == 2016567667 || v1 == 2016686640) {
            return 10;
          }
          unsigned __int16 v9 = 12850;
        }
        else if (v1 > 2016698679)
        {
          if (v1 == 2016698680) {
            return 10;
          }
          unsigned __int16 v9 = 24947;
        }
        else
        {
          if (v1 == 2016687156) {
            return 10;
          }
          unsigned __int16 v9 = 13424;
        }
        int v11 = v9 | 0x78340000;
      }
      else
      {
        if (v1 > 2033463605)
        {
          if (v1 > 2037741157)
          {
            if (v1 == 2037741158) {
              return v2;
            }
            int v4 = 2037741171;
          }
          else
          {
            if (v1 == 2033463606) {
              return 16;
            }
            int v4 = 2033463856;
          }
          goto LABEL_93;
        }
        if (v1 > 2019963955)
        {
          if (v1 == 2019963956) {
            return 10;
          }
          unsigned __int16 v5 = 13424;
        }
        else
        {
          if (v1 == 2019963440) {
            return 10;
          }
          unsigned __int16 v5 = 12850;
        }
        int v11 = v5 | 0x78660000;
      }
    }
    else
    {
      if (v1 <= 1953903667)
      {
        if (v1 <= 1952854577)
        {
          if (v1 == 1949458803 || v1 == 1949589875) {
            return 12;
          }
          unsigned __int16 v8 = 12848;
        }
        else
        {
          if (v1 > 1953903151)
          {
            if (v1 == 1953903152) {
              return 12;
            }
            int v12 = 1953903154;
            goto LABEL_97;
          }
          if (v1 == 1952854578) {
            return 12;
          }
          unsigned __int16 v8 = 13364;
        }
        int v12 = v8 | 0x74660000;
LABEL_97:
        if (v1 != v12) {
          return 0;
        }
        return 12;
      }
      if (v1 <= 1983144247)
      {
        if (v1 > 1983000885)
        {
          if (v1 == 1983000886) {
            return 16;
          }
          int v4 = 1983013176;
        }
        else
        {
          if (v1 == 1953903668) {
            return 12;
          }
          int v4 = 1982882104;
        }
        goto LABEL_93;
      }
      if (v1 > 2016436594)
      {
        if (v1 == 2016436595) {
          return 10;
        }
        int v11 = 2016567608;
      }
      else
      {
        if (v1 == 1983144248) {
          return v2;
        }
        int v11 = 2016436536;
      }
    }
    goto LABEL_89;
  }
  if (v1 > 1886676527)
  {
    if (v1 <= 1932812658)
    {
      if (v1 <= 1886680623)
      {
        if ((v1 - 1886676528) > 4 || ((1 << (v1 - 48)) & 0x15) == 0) {
          return 0;
        }
      }
      else if ((v1 - 1886680624) > 4 || ((1 << (v1 - 48)) & 0x15) == 0)
      {
        if (v1 != 1932550515)
        {
          int v3 = 1932681587;
          goto LABEL_77;
        }
        return 16;
      }
      return 12;
    }
    if (v1 <= 1937125935)
    {
      if (v1 > 1936077361)
      {
        if (v1 == 1936077362) {
          return 16;
        }
        unsigned __int16 v7 = 13364;
      }
      else
      {
        if (v1 == 1932812659) {
          return 16;
        }
        unsigned __int16 v7 = 12848;
      }
      int v3 = v7 | 0x73660000;
LABEL_77:
      if (v1 == v3) {
        return 16;
      }
      return 0;
    }
    if (v1 <= 1937126451)
    {
      if (v1 == 1937125936) {
        return 16;
      }
      int v3 = 1937125938;
      goto LABEL_77;
    }
    if (v1 == 1937126452) {
      return 16;
    }
    int v12 = 1949327731;
    goto LABEL_97;
  }
  if (v1 > 1714696751)
  {
    if (v1 <= 1882469427)
    {
      if (v1 == 1714696752) {
        return v2;
      }
      if (v1 == 1882468912) {
        return 10;
      }
      int v11 = 1882468914;
    }
    else
    {
      if (v1 > 1885745713)
      {
        if (v1 == 1885745714) {
          return 10;
        }
        unsigned __int16 v10 = 13364;
      }
      else
      {
        if (v1 == 1882469428) {
          return 10;
        }
        unsigned __int16 v10 = 12848;
      }
      int v11 = v10 | 0x70660000;
    }
LABEL_89:
    if (v1 != v11) {
      return 0;
    }
    return 10;
  }
  if (v1 > 875704933)
  {
    if (v1 <= 875836517)
    {
      if (v1 != 875704934)
      {
        unsigned __int16 v6 = 12918;
LABEL_56:
        int v4 = v6 | 0x34320000;
        goto LABEL_93;
      }
      return v2;
    }
    if (v1 == 875836518) {
      return v2;
    }
    int v4 = 875836534;
LABEL_93:
    if (v1 == v4) {
      return v2;
    }
    return 0;
  }
  if (v1 != 846624121 && v1 != 875704422)
  {
    unsigned __int16 v6 = 12406;
    goto LABEL_56;
  }
  return v2;
}

uint64_t CA::Render::Surface::is_unpremultiplied(CA::Render::Surface *this)
{
  return (*((unsigned __int16 *)this + 168) >> 3) & 1;
}

uint64_t CA::Render::fourcc_is_420(CA::Render *this)
{
  int v1 = (int)this;
  uint64_t result = 1;
  if (v1 > 875704437)
  {
    if (v1 > 1952854575)
    {
      if (v1 > 2084070959)
      {
        if (v1 > 2088003119)
        {
          if (v1 > 2088265263)
          {
            if (v1 == 2088265264) {
              return result;
            }
            int v3 = 2088269360;
          }
          else
          {
            if (v1 == 2088003120) {
              return result;
            }
            int v3 = 2088007216;
          }
        }
        else if (v1 > 2087937583)
        {
          if (v1 == 2087937584) {
            return result;
          }
          int v3 = 2087941680;
        }
        else
        {
          if (v1 == 2084070960) {
            return result;
          }
          int v3 = 2084075056;
        }
        goto LABEL_90;
      }
      if (v1 > 2016436535)
      {
        if (v1 > 2016686639)
        {
          if (v1 == 2016686640) {
            return result;
          }
          int v3 = 2019963440;
        }
        else
        {
          if (v1 == 2016436536) {
            return result;
          }
          int v3 = 2016436595;
        }
        goto LABEL_90;
      }
      if (v1 != 1952854576 && v1 != 1953903152)
      {
        int v3 = 1982882104;
        goto LABEL_90;
      }
    }
    else
    {
      if (v1 > 1882468911)
      {
        if (v1 > 1932550514)
        {
          if (v1 > 1937125935)
          {
            if (v1 == 1937125936) {
              return result;
            }
            int v3 = 1949327731;
          }
          else
          {
            if (v1 == 1932550515) {
              return result;
            }
            int v3 = 1936077360;
          }
        }
        else if (v1 > 1886676527)
        {
          if (v1 == 1886676528) {
            return result;
          }
          int v3 = 1886680624;
        }
        else
        {
          if (v1 == 1882468912) {
            return result;
          }
          int v3 = 1885745712;
        }
        goto LABEL_90;
      }
      if (v1 > 1534354991)
      {
        if (v1 > 1534617135)
        {
          if (v1 == 1534617136) {
            return result;
          }
          int v3 = 1534621232;
        }
        else
        {
          if (v1 == 1534354992) {
            return result;
          }
          int v3 = 1534359088;
        }
        goto LABEL_90;
      }
      if (v1 != 875704438 && v1 != 1530422832)
      {
        int v3 = 1530426928;
        goto LABEL_90;
      }
    }
  }
  else if (v1 > 762537519)
  {
    if (v1 > 792229423)
    {
      if (v1 > 796161583)
      {
        if (v1 > 796423727)
        {
          if (v1 == 796423728) {
            return result;
          }
          int v3 = 875704422;
        }
        else
        {
          if (v1 == 796161584) {
            return result;
          }
          int v3 = 796419632;
        }
      }
      else if (v1 > 796096047)
      {
        if (v1 == 796096048) {
          return result;
        }
        int v3 = 796157488;
      }
      else
      {
        if (v1 == 792229424) {
          return result;
        }
        int v3 = 796091952;
      }
      goto LABEL_90;
    }
    if (v1 > 762607151)
    {
      if (v1 > 762869295)
      {
        if (v1 == 762869296) {
          return result;
        }
        int v3 = 792225328;
      }
      else
      {
        if (v1 == 762607152) {
          return result;
        }
        int v3 = 762865200;
      }
      goto LABEL_90;
    }
    if (v1 != 762537520 && v1 != 762541616)
    {
      int v3 = 762603056;
      goto LABEL_90;
    }
  }
  else
  {
    if (v1 > 645166639)
    {
      if (v1 > 645424687)
      {
        if (v1 > 758670895)
        {
          if (v1 == 758670896) {
            return result;
          }
          int v3 = 758674992;
          goto LABEL_90;
        }
        if (v1 == 645424688) {
          return result;
        }
        unsigned __int16 v5 = 30256;
      }
      else
      {
        if (v1 <= 645410871)
        {
          if (v1 == 645166640) {
            return result;
          }
          int v3 = 645279800;
          goto LABEL_90;
        }
        if (v1 == 645410872) {
          return result;
        }
        unsigned __int16 v5 = 12403;
      }
      int v3 = v5 | 0x26780000;
LABEL_90:
      if (v1 != v3) {
        return 0;
      }
      return result;
    }
    if (v1 > 645097007)
    {
      if (v1 > 645148786)
      {
        if (v1 == 645148787) {
          return result;
        }
        int v3 = 645162544;
        goto LABEL_90;
      }
      if (v1 == 645097008) {
        return result;
      }
      unsigned __int16 v4 = 30256;
      goto LABEL_55;
    }
    if (v1 != 641230384 && v1 != 641234480)
    {
      unsigned __int16 v4 = 12403;
LABEL_55:
      int v3 = v4 | 0x26730000;
      goto LABEL_90;
    }
  }
  return result;
}

uint64_t CA::Render::Surface::chroma_location(__IOSurface **this, __IOSurface *a2)
{
  unsigned int v2 = *((unsigned __int8 *)this + 329);
  if ((v2 & 0x70) == 0)
  {
    int v4 = CA::Render::Surface::ycbcr_matrix((CA::Render::Surface *)this, a2);
    unsigned __int16 v5 = this[14];
    if (v5)
    {
      int v6 = 16 * CA::Render::iosurface_chroma_location(v5, v4);
    }
    else if (((v4 - 1) & 0xF9) != 0)
    {
      int v6 = 32;
    }
    else
    {
      int v6 = 16;
    }
    unsigned int v2 = *((unsigned char *)this + 329) & 0x8F | v6;
    *((unsigned char *)this + 329) = *((unsigned char *)this + 329) & 0x8F | v6;
    unsigned __int16 v7 = this[12];
    if (v7)
    {
      *((unsigned char *)v7 + 329) = *((unsigned char *)v7 + 329) & 0x8F | v6;
      unsigned int v2 = *((unsigned __int8 *)this + 329);
    }
  }
  return (v2 >> 4) & 7;
}

uint64_t CA::Render::fourcc_is_444(CA::Render *this)
{
  int v1 = (int)this;
  uint64_t result = 1;
  if (v1 <= 875836533)
  {
    if (v1 <= 762537523)
    {
      if (v1 > 645166643)
      {
        if (v1 > 645424691)
        {
          if (v1 > 758670899)
          {
            if (v1 == 758670900) {
              return result;
            }
            int v3 = 758674996;
            goto LABEL_93;
          }
          if (v1 == 645424692) {
            return result;
          }
          unsigned __int16 v6 = 30260;
        }
        else
        {
          if (v1 <= 645411895)
          {
            if (v1 == 645166644) {
              return result;
            }
            int v3 = 645280824;
            goto LABEL_93;
          }
          if (v1 == 645411896) {
            return result;
          }
          unsigned __int16 v6 = 13427;
        }
        int v3 = v6 | 0x26780000;
        goto LABEL_93;
      }
      if (v1 <= 645097011)
      {
        if (v1 == 641230388 || v1 == 641234484) {
          return result;
        }
        unsigned __int16 v4 = 13427;
      }
      else
      {
        if (v1 > 645149810)
        {
          if (v1 == 645149811) {
            return result;
          }
          int v3 = 645162548;
          goto LABEL_93;
        }
        if (v1 == 645097012) {
          return result;
        }
        unsigned __int16 v4 = 30260;
      }
      int v3 = v4 | 0x26730000;
      goto LABEL_93;
    }
    if (v1 > 792229427)
    {
      if (v1 > 796161587)
      {
        if (v1 > 796423731)
        {
          if (v1 == 796423732) {
            return result;
          }
          int v3 = 875836518;
        }
        else
        {
          if (v1 == 796161588) {
            return result;
          }
          int v3 = 796419636;
        }
      }
      else if (v1 > 796096051)
      {
        if (v1 == 796096052) {
          return result;
        }
        int v3 = 796157492;
      }
      else
      {
        if (v1 == 792229428) {
          return result;
        }
        int v3 = 796091956;
      }
      goto LABEL_93;
    }
    if (v1 > 762607155)
    {
      if (v1 > 762869299)
      {
        if (v1 == 762869300) {
          return result;
        }
        int v3 = 792225332;
      }
      else
      {
        if (v1 == 762607156) {
          return result;
        }
        int v3 = 762865204;
      }
      goto LABEL_93;
    }
    if (v1 != 762537524 && v1 != 762541620)
    {
      int v3 = 762603060;
      goto LABEL_93;
    }
  }
  else
  {
    if (v1 > 1952855091)
    {
      if (v1 > 2084070963)
      {
        if (v1 > 2088003123)
        {
          if (v1 > 2088265267)
          {
            if (v1 == 2088265268) {
              return result;
            }
            int v3 = 2088269364;
          }
          else
          {
            if (v1 == 2088003124) {
              return result;
            }
            int v3 = 2088007220;
          }
        }
        else if (v1 > 2087937587)
        {
          if (v1 == 2087937588) {
            return result;
          }
          int v3 = 2087941684;
        }
        else
        {
          if (v1 == 2084070964) {
            return result;
          }
          int v3 = 2084075060;
        }
        goto LABEL_93;
      }
      if (v1 > 2016698679)
      {
        if (v1 > 2019963955)
        {
          if (v1 == 2019963956) {
            return result;
          }
          int v3 = 2033463606;
          goto LABEL_93;
        }
        if (v1 == 2016698680) {
          return result;
        }
        unsigned __int16 v5 = 24947;
      }
      else
      {
        if (v1 <= 1983144247)
        {
          if (v1 == 1952855092) {
            return result;
          }
          int v3 = 1953903668;
          goto LABEL_93;
        }
        if (v1 == 1983144248) {
          return result;
        }
        unsigned __int16 v5 = 13364;
      }
      int v3 = v5 | 0x78340000;
LABEL_93:
      if (v1 != v3) {
        return 0;
      }
      return result;
    }
    if (v1 > 1882469427)
    {
      if (v1 > 1932812658)
      {
        if (v1 > 1937126451)
        {
          if (v1 == 1937126452) {
            return result;
          }
          int v3 = 1949589875;
        }
        else
        {
          if (v1 == 1932812659) {
            return result;
          }
          int v3 = 1936077876;
        }
      }
      else if (v1 > 1886676531)
      {
        if (v1 == 1886676532) {
          return result;
        }
        int v3 = 1886680628;
      }
      else
      {
        if (v1 == 1882469428) {
          return result;
        }
        int v3 = 1885746228;
      }
      goto LABEL_93;
    }
    if (v1 > 1534354995)
    {
      if (v1 > 1534617139)
      {
        if (v1 == 1534617140) {
          return result;
        }
        int v3 = 1534621236;
      }
      else
      {
        if (v1 == 1534354996) {
          return result;
        }
        int v3 = 1534359092;
      }
      goto LABEL_93;
    }
    if (v1 != 875836534 && v1 != 1530422836)
    {
      int v3 = 1530426932;
      goto LABEL_93;
    }
  }
  return result;
}

uint64_t CA::OGL::MetalContext::image_surface(uint64_t a1, uint64_t a2, CA::Render::Image *a3)
{
  return *(void *)(a2 + 32);
}

CA::Render::Image *CA::OGL::MetalContext::retain_image(uint64_t a1, uint64_t a2, CA::Render::Image *a3, uint64_t a4)
{
  while (1)
  {
    uint64_t v4 = a4;
    unsigned __int16 v5 = a3;
    uint64_t v6 = a2;
    uint64_t v7 = a1;
    __int16 v8 = 0;
    unsigned __int16 v9 = 0;
    __int16 v50 = 0;
    char v51 = 0;
    uint64_t v53 = 0;
    __int16 v54 = 0;
    long long v47 = 0u;
    long long v48 = 0u;
    char v49 = 0;
    long long v52 = 0uLL;
    unsigned int v10 = *((unsigned __int8 *)a3 + 12);
    long long v46 = xmmword_184998280;
    long long v45 = xmmword_184998350;
    uint64_t v11 = 0x100000001;
    double v12 = 0.5;
    double v13 = 4.0;
    float v14 = 1.0;
    int v15 = -1;
    float v16 = 0.0;
    if (v10 <= 0x21)
    {
      if (v10 == 9)
      {
LABEL_14:
        if (!*(void *)(a2 + 8))
        {
          *(void *)(a2 + 8) = a3;
          (*(void (**)(CA::Render::Image *))(*(void *)a3 + 176))(a3);
        }
        goto LABEL_25;
      }
      if (v10 != 23)
      {
        int v18 = 0;
        int v19 = 0;
        char v20 = 0;
        goto LABEL_42;
      }
      if (*(void *)(a2 + 8))
      {
        if (!a4) {
          goto LABEL_25;
        }
      }
      else
      {
        *(void *)(a2 + 8) = a3;
        atomic_fetch_add((atomic_uint *volatile)a3 + 37, 1u);
        if (!a4) {
          goto LABEL_25;
        }
      }
      uint64_t v22 = *(void *)(a2 + 32);
      if (!v22)
      {
        uint64_t v43 = v7;
        long long v46 = xmmword_184998280;
        long long v45 = xmmword_184998350;
        unint64_t v26 = CA::Render::Image::retain_iosurface(a3);
        __int16 v8 = 0;
        char v20 = 0;
        int v19 = 0;
        int v18 = 0;
        unsigned __int16 v9 = 0;
        if (v26) {
          goto LABEL_39;
        }
        goto LABEL_42;
      }
      int v23 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(void *)v22 + 160))(v22);
      CA::Render::Image::update_iosurface((__IOSurface **)v5, v23);
LABEL_25:
      __int16 v8 = 0;
      unsigned __int16 v9 = 0;
      int v18 = 0;
      int v19 = 0;
      char v20 = 0;
      goto LABEL_42;
    }
    if (v10 == 34) {
      goto LABEL_14;
    }
    if (v10 == 51) {
      break;
    }
    uint64_t v17 = a1;
    int v18 = 0;
    int v19 = 0;
    char v20 = 0;
    if (v10 != 38) {
      goto LABEL_42;
    }
    BOOL v21 = CA::Render::PixelBuffer::image(a3);
    if (!v21) {
      return 0;
    }
    *(unsigned char *)(v6 + 56) = *(unsigned char *)(v6 + 56) & 0xC0 | 0x17;
    a3 = v21;
    a1 = v17;
    a2 = v6;
    a4 = v4;
  }
  if (!*(void *)(a2 + 8))
  {
    *(void *)(a2 + 8) = a3;
    (*(void (**)(CA::Render::Image *))(*(void *)a3 + 176))(a3);
  }
  if (*(void *)(v6 + 32) || (unsigned __int16 v24 = (const void *)*((void *)v5 + 14)) == 0)
  {
    IOSurfaceRef buffer = 0;
  }
  else
  {
    IOSurfaceRef buffer = (IOSurfaceRef)*((void *)v5 + 14);
    CFRetain(v24);
  }
  char v20 = *((unsigned char *)v5 + 328);
  float v16 = (*(float (**)(CA::Render::Image *))(*(void *)v5 + 152))(v5);
  int v25 = (*(uint64_t (**)(CA::Render::Image *))(*(void *)v5 + 272))(v5);
  uint64_t v43 = v7;
  if ((*(unsigned int (**)(CA::Render::Image *))(*(void *)v5 + 280))(v5))
  {
    unsigned __int16 v9 = (atomic_uint *)*((void *)v5 + 21);
    if (v9) {
      atomic_fetch_add(v9 + 4, 1u);
    }
    int v19 = v25;
    long long v45 = *((_OWORD *)v5 + 11);
    long long v46 = *((_OWORD *)v5 + 12);
    double v12 = *((double *)v5 + 26);
    double v13 = *((double *)v5 + 27);
    __int16 v8 = *((_WORD *)v5 + 117);
    uint64_t v11 = *(void *)((char *)v5 + 236);
    float v14 = *((float *)v5 + 70);
    int v15 = *((_DWORD *)v5 + 75);
    uint64_t v53 = *((void *)v5 + 28);
    __int16 v54 = *((_WORD *)v5 + 116);
    char v49 = *((unsigned char *)v5 + 276);
    long long v47 = *(_OWORD *)((char *)v5 + 244);
    long long v48 = *(_OWORD *)((char *)v5 + 260);
    char v51 = *((unsigned char *)v5 + 279);
    __int16 v50 = *(_WORD *)((char *)v5 + 277);
    long long v52 = *(_OWORD *)((char *)v5 + 284);
    unint64_t v26 = buffer;
    if (v9 && atomic_fetch_add(v9 + 4, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v9 + 8))(v9);
    }
    int v18 = 1;
    if (!buffer) {
      goto LABEL_42;
    }
LABEL_39:
    unsigned int v27 = *(CA::WindowServer::IOSurface **)(v43 + 192);
    if (v27) {
      unsigned int v27 = (CA::WindowServer::IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(void *)v27 + 16))(v27);
    }
    *(void *)(v6 + 32) = CA::WindowServer::IOSurface::wrap_buffer(v27, v26, 0, 1);
  }
  else
  {
    __int16 v8 = 0;
    int v18 = 0;
    unsigned __int16 v9 = 0;
    long long v46 = xmmword_184998280;
    long long v45 = xmmword_184998350;
    int v19 = v25;
    unint64_t v26 = buffer;
    if (buffer) {
      goto LABEL_39;
    }
  }
LABEL_42:
  uint64_t v28 = *(unsigned char **)(v6 + 32);
  if (v28)
  {
    v28[229] = v20;
    (*(void (**)(unsigned char *, float))(*(void *)v28 + 200))(v28, v16);
    uint64_t v29 = *(void *)(v6 + 32);
    unsigned int v31 = *(_DWORD *)(v29 + 224);
    uint64_t v30 = v29 + 224;
    unint64_t v32 = v31 | ((unint64_t)*(unsigned __int8 *)(v30 + 4) << 32);
    uint64_t v33 = 0x1000000000;
    if (!v19) {
      uint64_t v33 = 0;
    }
    unint64_t v34 = v32 & 0xFFFFFFEFFFFFFFFFLL;
    *(_DWORD *)uint64_t v30 = v34;
    *(unsigned char *)(v30 + 4) = (v34 | v33) >> 32;
    uint64_t v35 = *(void *)(v6 + 32);
    unsigned int v37 = *(_DWORD *)(v35 + 224);
    uint64_t v36 = v35 + 224;
    unint64_t v38 = v37 | ((unint64_t)*(unsigned __int8 *)(v36 + 4) << 32);
    char v39 = 32;
    if (!v18) {
      char v39 = 0;
    }
    unint64_t v40 = v38 & 0xFFFFFFDFFFFFFFFFLL;
    *(_DWORD *)uint64_t v36 = v40;
    *(unsigned char *)(v36 + 4) = BYTE4(v40) | v39;
    if (v18)
    {
      CA::WindowServer::Surface::set_hdr_processor(*(CA::WindowServer::Surface **)(v6 + 32), v9);
      uint64_t v41 = *(void *)(v6 + 32);
      *(_OWORD *)(v41 + 96) = v45;
      *(_OWORD *)(v41 + 112) = v46;
      *(double *)(v41 + 128) = v12;
      *(double *)(v41 + 136) = v13;
      *(void *)(v41 + 144) = v53;
      *(_WORD *)(v41 + 152) = v54;
      *(_WORD *)(v41 + 154) = v8;
      *(void *)(v41 + 156) = v11;
      *(_OWORD *)(v41 + 164) = v47;
      *(_OWORD *)(v41 + 180) = v48;
      *(unsigned char *)(v41 + 196) = v49;
      *(unsigned char *)(v41 + 199) = v51;
      *(_WORD *)(v41 + 197) = v50;
      *(float *)(v41 + 200) = v14;
      *(_OWORD *)(v41 + 204) = v52;
      *(_DWORD *)(v41 + 220) = v15;
    }
  }
  return v5;
}

uint64_t CA::Render::Surface::should_display_tonemap(CA::Render::Surface *this)
{
  return (*((unsigned __int16 *)this + 168) >> 9) & 1;
}

float CA::Render::Surface::edr_factor(CA::Render::Surface *this)
{
  return *((float *)this + 33);
}

uint64_t CA::Render::Surface::did_gpu_tonemap(CA::Render::Surface *this)
{
  return HIBYTE(*((unsigned __int16 *)this + 168)) & 1;
}

float *CA::WindowServer::IOSurface::wrap_buffer(CA::WindowServer::IOSurface *this, IOSurfaceRef buffer, __IOSurface *a3, char a4)
{
  if (a3) {
    CFRetain(buffer);
  }
  int Width = IOSurfaceGetWidth(buffer);
  int Height = IOSurfaceGetHeight(buffer);
  OSType PixelFormat = IOSurfaceGetPixelFormat(buffer);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v11 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x130uLL, 0x743898A5uLL);
  double v12 = (float *)v11;
  if (v11)
  {
    *((void *)v11 + 1) = this;
    *((_OWORD *)v11 + 1) = 0u;
    *((_OWORD *)v11 + 2) = 0u;
    *((void *)v11 + 6) = 0;
    *((_DWORD *)v11 + 14) = Width;
    *((_DWORD *)v11 + 15) = Height;
    *((_DWORD *)v11 + 16) = PixelFormat;
    *((_DWORD *)v11 + 17) = 1065353216;
    *((void *)v11 + 11) = 0;
    *((void *)v11 + 12) = 0;
    *((void *)v11 + 10) = 0;
    *((_DWORD *)v11 + 26) = 0;
    *(_OWORD *)(v11 + 108) = xmmword_184997E20;
    *((_DWORD *)v11 + 31) = 1065353216;
    *((_OWORD *)v11 + 8) = xmmword_184997E30;
    *((void *)v11 + 18) = 0;
    *((_WORD *)v11 + 76) = 0;
    *(void *)(v11 + 156) = 0x100000001;
    v11[196] = 0;
    *(_OWORD *)(v11 + 180) = 0u;
    *(_OWORD *)(v11 + 164) = 0u;
    *((_DWORD *)v11 + 50) = 1065353216;
    *(void *)(v11 + 204) = 0;
    *(void *)(v11 + 212) = 0;
    *((_DWORD *)v11 + 55) = -1;
    unint64_t v13 = (*((unsigned int *)v11 + 56) | ((unint64_t)v11[228] << 32)) & 0xC038000000 | 0x140000001;
    *((_DWORD *)v11 + 56) = *((_DWORD *)v11 + 56) & 0x38000000 | 0x40000001;
    *((_WORD *)v11 + 114) = BYTE4(v13);
    *((void *)v11 + 29) = 0;
    *((void *)v11 + 30) = buffer;
    *(void *)uint64_t v11 = &unk_1ED0272D8;
    *((_DWORD *)v11 + 62) = IOSurfaceGetID(buffer);
    v12[63] = CA::Render::iosurface_get_edr_factor(buffer, v14);
    *((_OWORD *)v12 + 16) = xmmword_1849983B0;
    v12[68] = 0.0;
    *((void *)v12 + 35) = 0;
    *((_WORD *)v12 + 144) = 256;
    *((unsigned char *)v12 + 290) = a4;
    v12[74] = 0.0;
    v12[73] = 0.0;
    PlaneCFIndex Count = IOSurfaceGetPlaneCount(buffer);
    size_t v16 = 0;
    if (PlaneCount <= 1) {
      uint64_t v17 = 1;
    }
    else {
      uint64_t v17 = PlaneCount;
    }
    do
    {
      *((_DWORD *)v12 + 73) |= IOSurfaceGetBaseAddressOfPlane(buffer, v16);
      *((_DWORD *)v12 + 74) |= IOSurfaceGetBytesPerRowOfPlane(buffer, v16++);
    }
    while (v17 != v16);
    if (!IOSurfaceGetBulkAttachments()) {
      *((unsigned char *)v12 + 289) = 1;
    }
  }
  return v12;
}

uint64_t CA::Render::CompressedImage::ref_image_data(uint64_t this)
{
  return this;
}

uint64_t CA::Render::Surface::ref_image_data(uint64_t this)
{
  return this;
}

uint64_t CA::Render::Surface::ycbcr_matrix(CA::Render::Surface *this, __IOSurface *a2)
{
  char v2 = *((unsigned char *)this + 329);
  if ((v2 & 0xF) == 0)
  {
    uint64_t v4 = (CA::Render *)*((void *)this + 14);
    if (v4)
    {
      char v5 = CA::Render::iosurface_ycbcr_matrix(v4, a2);
      char v2 = *((unsigned char *)this + 329);
    }
    else
    {
      char v5 = 1;
    }
    char v2 = v2 & 0xF0 | v5;
    *((unsigned char *)this + 329) = v2;
    uint64_t v6 = *((void *)this + 12);
    if (v6)
    {
      *(unsigned char *)(v6 + 329) = *(unsigned char *)(v6 + 329) & 0xF0 | v5;
      char v2 = *((unsigned char *)this + 329);
    }
  }
  return v2 & 0xF;
}

uint64_t CA::Render::ycbcr_fourcc_is_triplanar(CA::Render *this)
{
  int v1 = (int)this;
  uint64_t result = 1;
  if (v1 > 1983013175)
  {
    if (v1 > 2016567607)
    {
      if (v1 > 2016698679)
      {
        if (v1 == 2016698680) {
          return result;
        }
        int v3 = 2016698739;
      }
      else
      {
        if (v1 == 2016567608) {
          return result;
        }
        int v3 = 2016567667;
      }
    }
    else if (v1 > 2016436535)
    {
      if (v1 == 2016436536) {
        return result;
      }
      int v3 = 2016436595;
    }
    else
    {
      if (v1 == 1983013176) {
        return result;
      }
      int v3 = 1983144248;
    }
    goto LABEL_22;
  }
  if (v1 > 1949327730)
  {
    if (v1 > 1949589874)
    {
      if (v1 == 1949589875) {
        return result;
      }
      int v3 = 1982882104;
    }
    else
    {
      if (v1 == 1949327731) {
        return result;
      }
      int v3 = 1949458803;
    }
    goto LABEL_22;
  }
  if (v1 != 1932550515 && v1 != 1932681587)
  {
    int v3 = 1932812659;
LABEL_22:
    if (v1 != v3) {
      return 0;
    }
  }
  return result;
}

uint64_t CA::Render::iosurface_chroma_location(__IOSurface *a1, int a2)
{
  if (((a2 - 1) & 0xF9) != 0) {
    unsigned __int8 v2 = 2;
  }
  else {
    unsigned __int8 v2 = 1;
  }
  CFTypeRef v3 = IOSurfaceCopyValue(a1, (CFStringRef)*MEMORY[0x1E4F2EFF8]);
  if (v3)
  {
    uint64_t v4 = v3;
    if (CFEqual(v3, (CFTypeRef)*MEMORY[0x1E4F2F018]))
    {
      unsigned __int8 v2 = 1;
    }
    else if (CFEqual(v4, (CFTypeRef)*MEMORY[0x1E4F2F010]))
    {
      unsigned __int8 v2 = 2;
    }
    else if (CFEqual(v4, (CFTypeRef)*MEMORY[0x1E4F2F028]))
    {
      unsigned __int8 v2 = 3;
    }
    else if (CFEqual(v4, (CFTypeRef)*MEMORY[0x1E4F2F020]))
    {
      unsigned __int8 v2 = 4;
    }
    else if (CFEqual(v4, (CFTypeRef)*MEMORY[0x1E4F2F008]))
    {
      unsigned __int8 v2 = 5;
    }
    else if (CFEqual(v4, (CFTypeRef)*MEMORY[0x1E4F2F000]))
    {
      unsigned __int8 v2 = 6;
    }
    CFRelease(v4);
  }
  return v2;
}

uint64_t CA::Render::iosurface_ycbcr_matrix(CA::Render *this, __IOSurface *a2)
{
  signed int PixelFormat = IOSurfaceGetPixelFormat(this);
  int v3 = 0;
  if (PixelFormat > 1952854575)
  {
    if (PixelFormat <= 2019963439)
    {
      if (PixelFormat == 1952854576 || PixelFormat == 1952854578) {
        goto LABEL_23;
      }
      int v6 = 1952855092;
    }
    else
    {
      if (PixelFormat > 2019963955)
      {
        if (PixelFormat == 2037741158) {
          goto LABEL_23;
        }
        unsigned __int16 v5 = 13364;
      }
      else
      {
        if (PixelFormat == 2019963440) {
          goto LABEL_23;
        }
        unsigned __int16 v5 = 12850;
      }
      int v6 = v5 | 0x78660000;
    }
  }
  else
  {
    if (PixelFormat > 1714696751)
    {
      if (PixelFormat > 1936077361)
      {
        if (PixelFormat != 1936077362)
        {
          unsigned __int16 v4 = 13364;
          goto LABEL_18;
        }
      }
      else if (PixelFormat != 1714696752)
      {
        unsigned __int16 v4 = 12848;
LABEL_18:
        int v6 = v4 | 0x73660000;
        goto LABEL_22;
      }
LABEL_23:
      int v3 = 1;
      goto LABEL_24;
    }
    if (PixelFormat == 875704422 || PixelFormat == 875704934) {
      goto LABEL_23;
    }
    int v6 = 875836518;
  }
LABEL_22:
  if (PixelFormat == v6) {
    goto LABEL_23;
  }
LABEL_24:
  IOSurfaceGetYCbCrMatrix();
  return (v3 + 1);
}

uint64_t CA::OGL::MetalContext::can_generate_mipmaps_for_format(CA::OGL::MetalContext *this, MTLPixelFormat *a2, BOOL *a3)
{
  uint64_t v4 = *a2;
  if ((unint64_t)(v4 - 550) < 6) {
    return 0;
  }
  if (v4 == 1)
  {
    *a2 = MTLPixelFormatR8Unorm;
    *a3 = 1;
  }
  MTLPixelFormatGetInfoForDevice();
  return 0;
}

uint64_t CA::OGL::MetalContext::start_blit_encoder(CA::OGL::MetalContext *this, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 374)) {
    return 1;
  }
  CA::OGL::MetalContext::stop_encoders(this);
  uint64_t result = CA::OGL::MetalContext::start_command_buffer(this, a2, v4);
  if (!result) {
    return result;
  }
  id v6 = (id)[*((id *)this + 372) blitCommandEncoder];
  *((void *)this + 374) = v6;
  if (v6)
  {
    if (BYTE3(xmmword_1EB2ACC70)) {
      uint64_t v7 = mach_continuous_time();
    }
    else {
      uint64_t v7 = 0;
    }
    *((void *)this + 388) = v7;
    return 1;
  }
  if (x_log_hook_p())
  {
    x_log_();
    return 0;
  }
  __int16 v8 = x_log_category_ogl_metal;
  uint64_t result = os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)unsigned __int16 v9 = 0;
    _os_log_impl(&dword_184668000, v8, OS_LOG_TYPE_ERROR, "Unable to start blit command encoder\n", v9, 2u);
    return 0;
  }
  return result;
}

uint64_t CA::DynamicFrameRateSource::commit_deadline(CA::DynamicFrameRateSource *this)
{
  unint64_t v2 = mach_absolute_time();
  uint64_t result = *((void *)this + 5);
  if (v2 >= result)
  {
    uint64_t result = CA::DynamicFrameRateSource::_commit_deadline_at_timestamp(this, v2);
    *((void *)this + 5) = result;
  }
  return result;
}

BOOL CA::WindowServer::IOMFBDisplay::can_update_(CA::WindowServer::IOMFBDisplay *this, char a2, double a3, double a4, uint64_t a5, uint64_t a6, double *a7)
{
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (int32x2_t *)((char *)this + 25704);
  uint64_t v111 = 0;
  if (!*((unsigned char *)this + 28164)) {
    goto LABEL_9;
  }
  uint64_t v11 = (CA::IOMobileFramebuffer *)*((unsigned int *)this + 6484);
  if (!v11) {
    goto LABEL_9;
  }
  int v12 = CA::WindowServer::swap_wait_timeout((CA::WindowServer::IOMFBDisplay *)((char *)this + 25568), v11, 0x80000001, (double *)&v111, a7);
  int v13 = v12;
  if (BYTE9(xmmword_1EB2ACC10))
  {
    kdebug_trace();
    if (v13) {
      goto LABEL_9;
    }
  }
  else if (v12)
  {
    goto LABEL_9;
  }
  v10[29].i32[0] = 0;
  v10[307].i8[4] = 0;
  if (!byte_1EB2ACC0A)
  {
    uint64_t v14 = *((void *)this + 3304);
    if (v14)
    {
      --*(_DWORD *)(v14 + 8);
      *((void *)this + 3304) = 0;
    }
  }
  v10[307].i8[5] = 1;
LABEL_9:
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
  unsigned int v16 = v10[1].u32[0];
  if (v16 >= 2) {
    uint64_t v17 = 2;
  }
  else {
    uint64_t v17 = v16;
  }
  if (!v17) {
    goto LABEL_99;
  }
  int v18 = 0;
  uint64_t v19 = a2 & 1;
  uint64_t v20 = v10->u32[0];
  char v107 = (CA::WindowServer::IOMFBDisplay *)((char *)this + 25568);
  char v105 = 1;
  uint64_t v109 = v10;
  while (1)
  {
    uint64_t v21 = v20 == v10[1].i32[0] ? 0 : v20;
    if (v21 != v10->i32[1] || CA::WindowServer::page_flipping_disabled == 1) {
      break;
    }
LABEL_66:
    uint64_t v20 = v21 + 1;
    if (!--v17) {
      goto LABEL_100;
    }
  }
  BOOL v22 = (*((_DWORD *)this + 156) & 0x100) != 0
     && (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 136))(this) == 3;
  int v23 = (char *)this + 48 * v21 + 25824;
  if ((*v23 & 3) == 2) {
    char v24 = v19;
  }
  else {
    char v24 = 1;
  }
  if ((v24 & 1) == 0 && !v22) {
    v10[1].i32[1] = 4;
  }
  int v25 = (unsigned int *)((char *)this + 48 * v21 + 25784);
  if (!*v25)
  {
LABEL_59:
    uint64_t v44 = (char *)this + 48 * v21;
    if (*((void *)v44 + 3227))
    {
      long long v45 = v44 + 25816;
      (*(void (**)(void))(**((void **)this + 3312) + 32))(*((void *)this + 3312));
      *long long v45 = 0;
    }
    long long v46 = (char *)this + 48 * v21;
    uint64_t v47 = *((void *)v46 + 3224);
    if (v47)
    {
      *((void *)v46 + 3224) = 0;
      --*(_DWORD *)(v47 + 8);
      *(unsigned char *)(v47 + 132) &= ~1u;
    }
    long long v48 = (char *)this + 48 * v21;
    char v49 = (CA::WindowServer::Surface *)*((void *)v48 + 3225);
    if (v49)
    {
      __int16 v50 = v48 + 25800;
      CA::WindowServer::Surface::unref(v49);
      *__int16 v50 = 0;
    }
    *v23 &= 0xFCu;
    ++v18;
    goto LABEL_66;
  }
  unint64_t v26 = (unsigned int *)((char *)this + 48 * v21 + 25808);
  unsigned int v27 = *v26;
  if (!*v26)
  {
    char v51 = (char *)this + 48 * v21;
    uint64_t v52 = *((void *)v51 + 3225);
    if (v52 && *(void *)(v52 + 16))
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v53 = x_log_category_sharedevent;
        if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)CGRect buf = 0;
          _os_log_impl(&dword_184668000, v53, OS_LOG_TYPE_DEFAULT, "swap canceled or aborted, ensure shared events are complete for detached", buf, 2u);
        }
      }
      CA::WindowServer::SharedEvent::force_complete(*(CA::WindowServer::SharedEvent **)(*((void *)v51 + 3225) + 16), 0);
      uint64_t v10 = v109;
    }
    __int16 v54 = (char *)this + 48 * v21;
    uint64_t v55 = *((void *)v54 + 3224);
    if (!v55) {
      goto LABEL_54;
    }
    uint64_t v56 = *(void *)(v55 + 32);
    if (!v56 || !*(void *)(v56 + 16)) {
      goto LABEL_54;
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      float v57 = x_log_category_sharedevent;
      if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CGRect buf = 0;
        _os_log_impl(&dword_184668000, v57, OS_LOG_TYPE_DEFAULT, "swap canceled or aborted, ensure shared events are complete for framebuffer", buf, 2u);
      }
    }
    CA::WindowServer::SharedEvent::force_complete(*(CA::WindowServer::SharedEvent **)(*(void *)(*((void *)v54 + 3224) + 32) + 16), 0);
LABEL_53:
    uint64_t v10 = v109;
LABEL_54:
    unsigned int v41 = *v25;
    unsigned int v42 = v10[28].u32[1];
    if (v10[28].i32[0] > *v25) {
      unsigned int v41 = v10[28].u32[0];
    }
    v10[28].i32[0] = v41;
    unsigned int v43 = *v25;
    if (v42 > *v25) {
      unsigned int v43 = v42;
    }
    v10[28].i32[1] = v43;
    *int v25 = 0;
    *v23 &= 0xF3u;
    goto LABEL_59;
  }
  uint64_t v28 = v19;
  int v110 = v18;
  if (CA::WindowServer::page_flipping_disabled) {
    unsigned int v29 = 0;
  }
  else {
    unsigned int v29 = 0x80000000;
  }
  unsigned int v106 = v10[1].u32[1];
  unsigned int v30 = *((_DWORD *)this + 12 * ((v21 + 1) % (unint64_t)v10[1].u32[0]) + 6452);
  if ((a2 & 2) != 0) {
    unsigned int v31 = 0;
  }
  else {
    unsigned int v31 = v29;
  }
  BOOL v32 = v30 > v27;
  if (v30 <= v27) {
    unint64_t v33 = v27;
  }
  else {
    unint64_t v33 = v30;
  }
  if (CADeviceUseVBL::once[0] != -1) {
    dispatch_once(CADeviceUseVBL::once, &__block_literal_global_17);
  }
  if (CADeviceUseVBL::use_vbl || ((v109[306].i8[2] == 0) & v105) != 1)
  {
    int v34 = CA::IOMobileFramebuffer::swap_wait(v107);
  }
  else
  {
    int v34 = CA::WindowServer::swap_wait_timeout(v107, (CA::IOMobileFramebuffer *)v33, v31 | v32, (double *)&v111, v15);
    char v105 = 0;
  }
  uint64_t v19 = v28;
  if (!v34)
  {
    if ((*((_DWORD *)this + 156) & 4) == 0
      || (uint64_t v35 = (char *)this + 48 * v21, (v36 = *((void *)v35 + 3224)) == 0)
      || (uint64_t v37 = *(void *)(v36 + 32)) == 0
      || (uint64_t v38 = *(void *)(v37 + 16)) == 0
      || (char v39 = *(void **)(v38 + 8)) == 0
      || [v39 signaledValue] == *(void *)(v38 + 16)
      || (uint64_t v40 = *(void *)(*(void *)(*((void *)v35 + 3224) + 32) + 16),
          *(void *)(v40 + 32) - 1 < (unint64_t)([*(id *)(v40 + 8) signaledValue] + 1)))
    {
      *unint64_t v26 = 0;
      int v18 = v110;
      goto LABEL_53;
    }
  }
  BOOL v59 = (a2 & 1) == 0 && v106 != 0;
  unsigned int v60 = (char *)this + 48 * v21;
  int v18 = v110;
  uint64_t v10 = v109;
  if (!*((void *)v60 + 3227)
    || !(*(unsigned int (**)(void))(**((void **)this + 3312) + 24))(*((void *)this + 3312)))
  {
LABEL_98:
    if (!v59) {
      goto LABEL_100;
    }
LABEL_99:
    int v18 = 0;
    goto LABEL_100;
  }
  if (CADeviceUseVBL::once[0] != -1) {
    dispatch_once(CADeviceUseVBL::once, &__block_literal_global_17);
  }
  if (!CADeviceUseVBL::use_vbl && !v109[306].i8[2])
  {
    if (!CA::WindowServer::swap_wait_timeout(v107, (CA::IOMobileFramebuffer *)*v26, 0x80000001, (double *)&v111, v61))goto LABEL_194; {
    goto LABEL_98;
    }
  }
  if (CA::IOMobileFramebuffer::swap_wait(v107)) {
    goto LABEL_98;
  }
LABEL_194:
  __int16 v103 = v60 + 25816;
  (*(void (**)(void, void))(**((void **)this + 3312) + 32))(*((void *)this + 3312), *v103);
  void *v103 = 0;
  unsigned int v104 = v109[28].u32[1];
  if (v104 <= *v25) {
    unsigned int v104 = *v25;
  }
  v109[28].i32[1] = v104;
  if (v59) {
    goto LABEL_99;
  }
LABEL_100:
  int v62 = v18 - v10[307].i8[4];
  BOOL v63 = v62 > 0;
  unsigned int v64 = v10->u32[1];
  if ((*((unsigned char *)this + 48 * v64 + 25824) & 4) != 0)
  {
    if ((*((unsigned char *)this + 48 * v64 + 25824) & 8) != 0
      || (int v65 = CA::IOMobileFramebuffer::swap_wait((CA::WindowServer::IOMFBDisplay *)((char *)this + 25568)),
          *((unsigned char *)this + 48 * v64 + 25824) = *((unsigned char *)this + 48 * v64 + 25824) & 0xF7 | (8 * (v65 != -536870187)),
          v65 != -536870187))
    {
      unsigned int v66 = *((_DWORD *)this + 12 * v64 + 6446) - 1;
      if (v10[28].i32[0] > v66) {
        unsigned int v66 = v10[28].u32[0];
      }
      v10[28] = vdup_n_s32(v66);
    }
  }
  if (v10[306].i8[2])
  {
    int v67 = (uint64_t *)*((void *)this + 3503);
    if (*((uint64_t **)this + 3504) != v67)
    {
      do
      {
        uint64_t v68 = *v67;
        if (!(*(unsigned int (**)(void, uint64_t))(**((void **)this + 3312) + 24))(*((void *)this + 3312), *v67))break; {
        (*(void (**)(void, uint64_t))(**((void **)this + 3312) + 32))(*((void *)this + 3312), v68);
        }
        unsigned int v69 = v10[302].u32[0];
        if (v69 <= *((_DWORD *)v67 + 2)) {
          unsigned int v69 = *((_DWORD *)v67 + 2);
        }
        v10[302].i32[0] = v69;
        unint64_t v70 = *((void *)this + 3503);
        int v71 = v67 + 2;
        unint64_t v72 = *((void *)this + 3504);
        while (v71 != (uint64_t *)v72)
        {
          *(v71 - 2) = *v71;
          *((_DWORD *)v71 - 2) = *((_DWORD *)v71 + 2);
          v71 += 2;
        }
        if (v72 <= v70) {
          __assert_rtn("pop_back", "x-small-vector.h", 410, "_end > _begin && \"pop_back on empty container\"");
        }
        char v73 = (uint64_t *)(v72 - 16);
        *((void *)this + 3504) = v73;
      }
      while (v67 != v73);
    }
    if (!*((void *)this + 6 * v64 + 3227)
      || (*(unsigned int (**)(void))(**((void **)this + 3312) + 24))(*((void *)this + 3312)))
    {
      unsigned int v74 = v10[28].u32[1];
      if (v74 <= v10[302].i32[0]) {
        unsigned int v74 = v10[302].u32[0];
      }
      v10[28].i32[1] = v74;
    }
  }
  if ((a2 & 1) == 0)
  {
    unsigned int v75 = v10[1].u32[1];
    if (v75) {
      v10[1].i32[1] = v75 - 1;
    }
  }
  uint64_t v76 = *((void *)this + 3255);
  if (v76) {
    int v77 = *(unsigned char *)(v76 + 292) & 1;
  }
  else {
    int v77 = 1;
  }
  v10[310].i16[1] = 0;
  double v78 = *((double *)this + 3471);
  if (v78 != 0.0)
  {
    unint64_t v79 = CAHostTimeWithTime(v78);
    int v80 = 1;
    int v81 = CA::WindowServer::IOMFBDisplay::timing_granularity((os_unfair_lock_s *)this, 1);
    unint64_t v82 = 2 * v81 * (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 768))(this);
    BOOL v88 = v79 > v82;
    unint64_t v83 = v79 - v82;
    unint64_t v84 = v82 >> 5;
    BOOL v85 = v88 && v83 >= v84;
    char v86 = !v85;
    v10[310].i8[2] = v86;
    if (v85)
    {
      unint64_t v87 = CAHostTimeWithTime(*((double *)this + 3472));
      BOOL v88 = v87 > v83 && v87 - v83 > v83 >> 5;
      int v80 = v88;
      v10[310].i8[2] = v80;
    }
    if (v80 && v62 == 1) {
      BOOL v63 = v10[307].i8[4] != 0;
    }
  }
  if (a3 == 0.0) {
    goto LABEL_159;
  }
  if (CADeviceNeedsTripleBufferedTTL::once[0] != -1) {
    dispatch_once(CADeviceNeedsTripleBufferedTTL::once, &__block_literal_global_360);
  }
  int v89 = CADeviceNeedsTripleBufferedTTL::wants_triple_buffered_ttl;
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  BOOL v90 = *(float *)&dword_1EB2ACB84 != 1 && v89 == 0;
  if (v90 || *(float *)&dword_1EB2ACB84 == 2)
  {
LABEL_159:
    int v92 = 0;
  }
  else
  {
    if (*((double *)this + 3266) > a4) {
      *((double *)this + 3266) = a4;
    }
    double v93 = (*(double (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 744))(this);
    double v94 = v93 + v93;
    if (v94 < 0.026) {
      double v94 = 0.026;
    }
    if (v10[310].i8[2] || v10[310].i8[3] || !v10[310].i8[4])
    {
      int v92 = 1;
    }
    else
    {
      int v92 = 1;
      if (*((double *)this + 3267) < a3 && v62 >= 2)
      {
        BOOL v99 = a3 - *((double *)this + 3266) < v94;
        int v95 = (char *)&v10[310] + 1;
        BOOL v96 = v10[310].i8[1] == 0;
        int v92 = 1;
LABEL_174:
        if (a2) {
          char v100 = v77;
        }
        else {
          char v100 = 1;
        }
        if (v99 | byte_1EB2ACC85)
        {
          int v98 = (pthread_mutex_t *)((char *)this + 25720);
          if (v100) {
            goto LABEL_179;
          }
        }
        else
        {
          int v98 = (pthread_mutex_t *)((char *)this + 25720);
        }
LABEL_184:
        *int v95 = 0;
        if (!v96 && v92) {
LABEL_186:
        }
          kdebug_trace();
        goto LABEL_188;
      }
    }
  }
  int v95 = (char *)&v10[310] + 1;
  BOOL v96 = v10[310].i8[1] == 0;
  if (v62 != 1)
  {
    BOOL v99 = 0;
    goto LABEL_174;
  }
  if (a2) {
    int v97 = v77;
  }
  else {
    int v97 = 1;
  }
  int v98 = (pthread_mutex_t *)((char *)this + 25720);
  if (v97 != 1) {
    goto LABEL_184;
  }
LABEL_179:
  int v101 = v10[307].u8[4];
  v10[310].i8[1] = v101 ^ 1;
  if (v92)
  {
    if (v101)
    {
      if (!v96) {
        goto LABEL_186;
      }
    }
    else
    {
      *((double *)this + 3266) = a3;
    }
  }
LABEL_188:
  pthread_mutex_unlock(v98);
  return v63;
}

uint64_t CA::WindowServer::swap_wait_timeout(CA::WindowServer *this, CA::IOMobileFramebuffer *a2, unsigned int a3, double *a4, double *a5)
{
  if (a4) {
    double v7 = 0.001 - *a4;
  }
  else {
    double v7 = 0.001;
  }
  uint64_t v8 = mach_absolute_time();
  double v9 = CATimeWithHostTime(v8);
  while (1)
  {
    uint64_t v10 = CA::IOMobileFramebuffer::swap_wait(this);
    uint64_t v11 = mach_absolute_time();
    double v12 = CATimeWithHostTime(v11) - v9;
    if (!v10 || v12 > v7) {
      break;
    }
    usleep(0x64u);
  }
  if (a4) {
    *a4 = *a4 + v12;
  }
  return v10;
}

uint64_t CA::IOMobileFramebuffer::swap_wait(CA::IOMobileFramebuffer *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = mach_absolute_time();
  double v3 = CATimeWithHostTime(v2);
  if (*((unsigned char *)this + 8))
  {
    *(void *)CGRect buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x2000000000;
    int v10 = 0;
    BMMonitorBlockExecutionWithSignature();
    uint64_t v4 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
  }
  else
  {
    uint64_t v4 = IOMobileFramebufferSwapWait();
  }
  uint64_t v5 = mach_absolute_time();
  double v6 = CATimeWithHostTime(v5) - v3;
  if (v6 > 3.0)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      double v7 = x_log_category_windowserver;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CGRect buf = 136315394;
        *(void *)&uint8_t buf[4] = "IOMobileFramebufferSwapWait";
        *(_WORD *)&buf[12] = 2048;
        *(double *)&buf[14] = v6;
        _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_ERROR, "%s took %.2f seconds", buf, 0x16u);
      }
    }
  }
  return v4;
}

uint64_t CA::WindowServer::IOMFBServer::vsync_callback(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (pthread_mutex_t *)(a5 + 544);
  pthread_mutex_lock((pthread_mutex_t *)(a5 + 544));
  if (BYTE9(xmmword_1EB2ACC10)) {
    CA::WindowServer::IOMFBDisplay::emit_server_timing_info(*(os_unfair_lock_s **)(a5 + 96));
  }
  double v9 = CATimeWithHostTime(a3);
  (*(void (**)(uint64_t, double))(*(void *)a5 + 480))(a5, v9);
  *(void *)(a5 + 920) = a3;
  if (*(void *)(a5 + 912) <= a3)
  {
    kdebug_trace();
    uint64_t v11 = *(void *)(a5 + 96);
    if ((*(_DWORD *)(v11 + 624) & 0x100) != 0 && byte_1EB2ACC45)
    {
      float v57 = (os_unfair_lock_s *)(v11 + 27448);
      os_unfair_lock_lock((os_unfair_lock_t)(v11 + 27448));
      locuint64_t k = (os_unfair_lock_s *)(v11 + 27396);
      os_unfair_lock_lock((os_unfair_lock_t)(v11 + 27396));
      long long v58 = 0uLL;
      *(void *)&long long v59 = 0;
      x_stream_printf((uint64_t)&v58, "Frame Rate Requests %ld\n", v20, v21, v22, v23, v24, v25, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v11 + 27408) - *(void *)(v11 + 27400)) >> 3));
      uint64_t v32 = *(void *)(v11 + 27400);
      for (uint64_t i = *(void *)(v11 + 27408); v32 != i; v32 += 24)
        x_stream_printf((uint64_t)&v58, "%s[%d]: %u %u %u %s%s\n", v26, v27, v28, v29, v30, v31, (uint64_t)"");
      x_stream_printf((uint64_t)&v58, "\nFrame Rate Reasons %ld\n", v26, v27, v28, v29, v30, v31, 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v11 + 27464) - *(void *)(v11 + 27456)) >> 2));
      uint64_t v40 = *(unsigned int **)(v11 + 27456);
      uint64_t v55 = v11;
      for (uint64_t j = *(unsigned int **)(v11 + 27464); v40 != j; v40 += 7)
      {
        x_stream_printf((uint64_t)&v58, "[%d]: ", v34, v35, v36, v37, v38, v39, *v40);
        for (uint64_t k = 2; k != 6; ++k)
        {
          unsigned int v49 = v40[k];
          if (!v49) {
            break;
          }
          x_stream_printf((uint64_t)&v58, "%u'%u ", v42, v43, v44, v45, v46, v47, HIWORD(v49));
        }
        __int16 v50 = "suspended";
        if (!*((unsigned char *)v40 + 24)) {
          __int16 v50 = "";
        }
        x_stream_printf((uint64_t)&v58, "%s\n", v42, v43, v44, v45, v46, v47, (uint64_t)v50);
      }
      char v51 = x_stream_finish((uint64_t)&v58);
      if (v51)
      {
        uint64_t v52 = v51;
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          uint64_t v53 = x_log_category_frame_rate;
          if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT))
          {
            int v54 = *(unsigned __int8 *)(v55 + 28214);
            *(_DWORD *)CGRect buf = 136315394;
            *(void *)&uint8_t buf[4] = v52;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v54;
            _os_log_impl(&dword_184668000, v53, OS_LOG_TYPE_DEFAULT, "CAFrameRateServer: post_frame_rate_log\n%s\nserver_source_compat_quanta_mode: %i\n", buf, 0x12u);
          }
        }
        free(v52);
      }
      os_unfair_lock_unlock(lock);
      os_unfair_lock_unlock(v57);
    }
    if (fabs(*(double *)(a5 + 864)) == INFINITY
      && *(_DWORD *)(a5 + 1008)
      && atomic_fetch_add((atomic_uint *volatile)(a5 + 1008), 0xFFFFFFFF) == 1)
    {
      CA::WindowServer::IOMFBServer::set_vsync_disabled((CA::WindowServer::IOMFBServer *)a5);
      (*(void (**)(void))(**(void **)(a5 + 96) + 440))(*(void *)(a5 + 96));
    }
    pthread_mutex_unlock(v8);
    unint64_t v12 = a4 + a3;
    double v13 = CATimeWithHostTime(v12);
    uint64_t v14 = *(void *)(a5 + 96);
    if (atomic_load((unsigned __int8 *)CA::WindowServer::IOMFBDisplay::_latching_vsync))
    {
      atomic_fetch_add(CA::WindowServer::IOMFBDisplay::_latching_vsync, 0xFFu);
    }
    else
    {
      unint64_t v16 = atomic_load((unint64_t *)&CA::WindowServer::IOMFBDisplay::hint_agx_timing(unsigned long long,unsigned long long)::next_agx_hint);
      if (v16 > v12)
      {
LABEL_17:
        if (v13 >= *(double *)(a5 + 864))
        {
          long long v61 = 0u;
          long long v60 = 0u;
          long long v58 = 0u;
          long long v62 = 0xAuLL;
          long long v59 = v12;
          *(void *)&long long v60 = (uint64_t)(CATimeWithHostTime(a4) * 1000000.0);
          DWORD1(v58) = 1000000;
          memset(buf, 0, 24);
          CA::WindowServer::IOMFBDisplay::timing_reference((CA::WindowServer::IOMFBDisplay *)buf, *(void *)(a5 + 96), 1);
          *(void *)(a5 + 864) = 0x7FF0000000000000;
          *(void *)(a5 + 880) = 0;
          *(void *)(a5 + 872) = 0;
          CA::WindowServer::Server::render_for_time(a5);
        }
        else
        {
          CA::Render::collect(0, v13);
        }
        pthread_mutex_lock(v8);
        *(unsigned char *)(a5 + 1014) |= 1u;
        return pthread_mutex_unlock(v8);
      }
    }
    int v17 = *(_DWORD *)(v14 + 24);
    unsigned int v18 = atomic_load(CA::WindowServer::IOMFBDisplay::_fastest_display_id);
    if (v17 == v18)
    {
      if (CA::WindowServer::IOMFBDisplay::hint_agx_timing(unsigned long long,unsigned long long)::once[0] != -1) {
        dispatch_once(CA::WindowServer::IOMFBDisplay::hint_agx_timing(unsigned long long,unsigned long long)::once, &__block_literal_global_134);
      }
      if (CA::WindowServer::IOMFBDisplay::hint_agx_timing(unsigned long long,unsigned long long)::agx_device)
      {
        IOGPUDeviceSetDisplayParamsFunc(CA::WindowServer::IOMFBDisplay::hint_agx_timing(unsigned long long,unsigned long long)::agx_device, v12, a4);
        if (initialized != -1) {
          dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
        }
        double v19 = (double)*(float *)&dword_1EB2ACB6C * 0.001;
        if (!*(float *)&dword_1EB2ACB6C) {
          double v19 = 1.0;
        }
        atomic_store(CAHostTimeWithTime(v19) + v12, (unint64_t *)&CA::WindowServer::IOMFBDisplay::hint_agx_timing(unsigned long long,unsigned long long)::next_agx_hint);
      }
    }
    goto LABEL_17;
  }
  *(unsigned char *)(a5 + 1014) |= 1u;
  if (BYTE9(xmmword_1EB2ACC10)) {
    kdebug_trace();
  }

  return pthread_mutex_unlock(v8);
}

void CA::WindowServer::IOMFBDisplay::emit_server_timing_info(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 6512;
  os_unfair_lock_lock(this + 6512);
  CA::WindowServer::IOMFBDisplay::initialize_timings((CA::WindowServer::IOMFBDisplay *)this);
  double v3 = *(unsigned __int8 **)&this[6516]._os_unfair_lock_opaque;
  if (v3)
  {
    unsigned __int8 v4 = atomic_load(v3);
    if (v4)
    {
      atomic_load((unsigned int *)(*(void *)&this[6516]._os_unfair_lock_opaque + 36));
      atomic_load((unint64_t *)(*(void *)&this[6516]._os_unfair_lock_opaque + 48));
      atomic_load((unint64_t *)(*(void *)&this[6516]._os_unfair_lock_opaque + 64));
      uint64_t v5 = atomic_load((unint64_t *)(*(void *)&this[6516]._os_unfair_lock_opaque + 24));
      if (v5 && v5 < mach_absolute_time())
      {
        atomic_load((unsigned int *)(*(void *)&this[6516]._os_unfair_lock_opaque + 40));
        atomic_load((unint64_t *)(*(void *)&this[6516]._os_unfair_lock_opaque + 56));
      }
      kdebug_trace();
    }
  }

  os_unfair_lock_unlock(v2);
}

double CA::WindowServer::IOMFBDisplay::initialize_timings(CA::WindowServer::IOMFBDisplay *this)
{
  int v1 = (char *)this + 26052;
  if (!*((unsigned char *)this + 26052))
  {
    if (*((unsigned char *)this + 28154)) {
      goto LABEL_3;
    }
    if (!*((void *)this + 3257))
    {
      double v3 = CA::Render::Shmem::new_shmem((CA::Render::Shmem *)0x48);
      *((void *)this + 3257) = v3;
      *((void *)this + 3258) = *((void *)v3 + 3);
    }
    double v4 = (*(double (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 760))(this);
    atomic_store(CAHostTimeWithTime(v4), (unsigned int *)(*((void *)this + 3258) + 4));
    if ((*((_DWORD *)this + 156) & 0x100) != 0)
    {
      if (CAPrefers60HzAPT(void)::once[0] != -1) {
        dispatch_once(CAPrefers60HzAPT(void)::once, &__block_literal_global_3);
      }
      unsigned __int8 v5 = CAPrefers60HzAPT(void)::enabled != 0;
    }
    else
    {
      unsigned __int8 v5 = 0;
    }
    atomic_store(v5, (unsigned __int8 *)(*((void *)this + 3258) + 2));
    double result = (*(double (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 760))(this);
    if (result != 0.0) {
LABEL_3:
    }
      *int v1 = 1;
  }
  return result;
}

double CA::WindowServer::IOMFBServer::set_low_latency_threshold(CA::WindowServer::IOMFBServer *this, double a2)
{
  unint64_t v4 = (*(uint64_t (**)(CA::WindowServer::IOMFBServer *))(*(void *)this + 48))(this);
  double result = CATimeWithHostTime(v4) + a2;
  *((double *)this + 111) = result;
  return result;
}

unint64_t CA::WindowServer::IOMFBServer::vbl_delta(CA::WindowServer::IOMFBServer *this)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 12);
  uint64_t v3 = *v2;
  if ((v2[78] & 0x100) != 0)
  {
    double v8 = (*(double (**)(void))(v3 + 760))();
    unint64_t v9 = CAHostTimeWithTime(v8);
    unsigned int v10 = (*(uint64_t (**)(void))(**((void **)this + 12) + 136))(*((void *)this + 12));
    if (!v10) {
      unsigned int v10 = (*(uint64_t (**)(void))(**((void **)this + 12) + 784))(*((void *)this + 12));
    }
    return v9 * v10;
  }
  else
  {
    double v4 = (*(double (**)(void))(v3 + 744))();
    unint64_t v5 = CAHostTimeWithTime(v4);
    double v6 = (unsigned int *)(*((void *)this + 12) + 25560);
    if (*((unsigned char *)v6 + 2603)
      && CA::WindowServer::IOMFBDisplay::service_int_property((CA::WindowServer::IOMFBDisplay *)*v6, @"VRRIsIdle"))
    {
      if (CA::WindowServer::IOMFBDisplay::vrr_rate(void)::initialized == 1)
      {
        int v7 = CA::WindowServer::IOMFBDisplay::vrr_rate(void)::rate;
      }
      else
      {
        int v7 = CA::WindowServer::IOMFBDisplay::service_int_property((CA::WindowServer::IOMFBDisplay *)*v6, @"VRRDivisor");
        CA::WindowServer::IOMFBDisplay::vrr_rate(void)::rate = v7;
        CA::WindowServer::IOMFBDisplay::vrr_rate(void)::initialized = 1;
      }
      char v12 = (int)(float)(3932200.0 / (float)v7) == 30;
    }
    else
    {
      char v12 = 0;
    }
    return v5 << v12;
  }
}

uint64_t CA::WindowServer::IOMFBServer::timer_callback(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  _OWORD v16[3] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CA::WindowServer::IOMFBDisplay::timing_reference((CA::WindowServer::IOMFBDisplay *)v16, *(void *)(a5 + 96), 1);
    a4 += CADisplayTimerAlignPhase(a1, v16);
  }
  unsigned int v9 = CA::WindowServer::IOMFBDisplay::timing_granularity(*(os_unfair_lock_s **)(a5 + 96), 1);
  unsigned int v10 = (*(uint64_t (**)(void))(**(void **)(a5 + 96) + 768))(*(void *)(a5 + 96));
  uint64_t v11 = *(_DWORD **)(a5 + 96);
  if ((v11[156] & 0x100) != 0)
  {
    int v12 = (*(uint64_t (**)(_DWORD *))(*(void *)v11 + 136))(v11);
    if (!v12) {
      int v12 = (*(uint64_t (**)(void))(**(void **)(a5 + 96) + 784))(*(void *)(a5 + 96));
    }
    if (v12 != *(_DWORD *)(a5 + 940))
    {
      pthread_mutex_lock((pthread_mutex_t *)(a5 + 544));
      CA::WindowServer::IOMFBServer::refresh_timer_interval((CA::WindowServer::IOMFBServer *)a5);
      pthread_mutex_unlock((pthread_mutex_t *)(a5 + 544));
    }
  }
  uint64_t result = *(void *)(a5 + 96);
  if ((*(_DWORD *)(result + 624) & 0x100) == 0) {
    goto LABEL_9;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 136))(result);
  if (!result)
  {
    if (CAPrefers60HzAPT(void)::once[0] != -1) {
      dispatch_once(CAPrefers60HzAPT(void)::once, &__block_literal_global_3);
    }
    if (!CAPrefers60HzAPT(void)::enabled)
    {
LABEL_9:
      uint64_t v14 = ++CA::WindowServer::IOMFBServer::timer_callback(_CADisplayTimer *,unsigned long long,unsigned long long,unsigned long long,void *)::serial;
LABEL_18:
      return CA::WindowServer::IOMFBServer::vsync_callback(result, v14, a2, v10 * (unint64_t)v9, a5);
    }
    uint64_t result = 4;
  }
  unint64_t v15 = result;
  if (byte_1EB2ACC46) {
    uint64_t result = kdebug_trace();
  }
  uint64_t v14 = ++CA::WindowServer::IOMFBServer::timer_callback(_CADisplayTimer *,unsigned long long,unsigned long long,unsigned long long,void *)::serial;
  if (!(a4 % v15)) {
    goto LABEL_18;
  }
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::timing_server_frame_interval(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 6512;
  os_unfair_lock_lock(this + 6512);
  uint64_t v3 = *(unsigned __int8 **)&this[6516]._os_unfair_lock_opaque;
  if (v3 && (unsigned __int8 v4 = atomic_load(v3), (v4 & 1) != 0))
  {
    uint64_t v6 = atomic_load((unint64_t *)(*(void *)&this[6516]._os_unfair_lock_opaque + 24));
    if (v6 && v6 < mach_absolute_time()) {
      int v7 = (unsigned int *)(*(void *)&this[6516]._os_unfair_lock_opaque + 40);
    }
    else {
      int v7 = (unsigned int *)(*(void *)&this[6516]._os_unfair_lock_opaque + 36);
    }
    uint64_t v5 = atomic_load(v7);
  }
  else
  {
    uint64_t v5 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v5;
}

void CA::WindowServer::IOMFBDisplay::timing_reference(CA::WindowServer::IOMFBDisplay *this, uint64_t a2, int a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a2 + 26048);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 26048));
  int v7 = *(unsigned __int8 **)(a2 + 26064);
  if (v7 && ((unsigned __int8 v8 = atomic_load(v7), (v8 & 1) != 0) || !a3))
  {
    *(void *)this = 0;
    *((void *)this + 1) = 0;
    *((void *)this + 2) = 0;
    uint64_t v9 = atomic_load((unsigned int *)(*(void *)(a2 + 26064) + 4));
    *((void *)this + 2) = v9;
    int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 128))(a2);
    uint64_t v11 = *(void **)(a2 + 26064);
    if (v10)
    {
      uint64_t v12 = v11[3];
      uint64_t v13 = v11[6];
      uint64_t v14 = v11[7];
      uint64_t v15 = v11[8];
      *(void *)this = v13;
      *((void *)this + 1) = v15;
      if (v12 && v12 < mach_absolute_time()) {
        *(void *)this = v14;
      }
    }
    else
    {
      uint64_t v16 = v11[6];
      uint64_t v17 = v11[8];
      *(void *)this = v16;
      *((void *)this + 1) = v17;
    }
  }
  else
  {
    *(void *)this = 0;
    *((void *)this + 1) = 0;
    *((void *)this + 2) = 0;
  }

  os_unfair_lock_unlock(v6);
}

uint64_t CA::WindowServer::AppleInternalDisplay::uses_extended_display_timings(CA::WindowServer::AppleInternalDisplay *this)
{
  return (*((_DWORD *)this + 156) >> 8) & 1;
}

uint64_t CA::DynamicFrameRateSource::_commit_deadline_at_timestamp(CA::DynamicFrameRateSource *this, uint64_t a2)
{
  v47[1] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 104)) {
    return a2;
  }
  unint64_t v4 = mach_absolute_time();
  if (*((void *)this + 7) - 1 < v4
    || (uint64_t v5 = *((void *)this + 8),
        v5 != CA::Display::DisplayTimingsControl::server_frame_interval(*((CA::Display::DisplayTimingsControl **)this + 1), v4)))
  {
    CA::DynamicFrameRateSource::set_preferred_fps_range(this, *(CAFrameRateRange *)((char *)this + 16), 0);
  }
  long long v45 = 0uLL;
  uint64_t v46 = 0;
  CA::Display::DisplayTimingsControl::timing_reference((CA::Display::DisplayTimingsControl *)&v45, *((void *)this + 1), a2);
  if (*((void *)this + 7) - 1 < a2
    || (int v6 = *((_DWORD *)this + 12),
        uint64_t v7 = *((void *)this + 8),
        v7 != CA::Display::DisplayTimingsControl::server_frame_interval(*((CA::Display::DisplayTimingsControl **)this + 1), a2)))
  {
    float v8 = *((float *)this + 4);
    float v9 = *((float *)this + 5);
    float v10 = *((float *)this + 6);
    int v11 = CA::Display::DisplayTimingsControl::server_compat_quanta_mode(*((CA::Display::DisplayTimingsControl **)this + 1), a2);
    v50.float minimum = v8;
    v50.float maximum = v9;
    v50.float preferred = v10;
    unint64_t v12 = CA::Display::DisplayTimingsControl::fps_range_to_frame_interval_range(*((CA::Display::DisplayTimingsControl **)this + 1), v50, v11);
    v49.unsigned int var2 = v13;
    *(void *)&v49.unsigned int var0 = v12;
    int v6 = CA::DynamicFrameRateSource::frame_interval_range_adapt_to_server_interval((CA::Display::DisplayTimingsControl **)this, v49, a2);
  }
  uint64_t v14 = *((void *)this + 1);
  if (v6)
  {
    unint64_t v15 = v6;
  }
  else
  {
    if (*(unsigned char *)(v14 + 233)) {
      unsigned int v39 = 2;
    }
    else {
      unsigned int v39 = 1;
    }
    if (v39 <= *(_DWORD *)(v14 + 56)) {
      unsigned int v39 = *(_DWORD *)(v14 + 56);
    }
    if (v39 <= *(_DWORD *)(v14 + 88)) {
      unsigned int v39 = *(_DWORD *)(v14 + 88);
    }
    if (v39 <= *(_DWORD *)(v14 + 60)) {
      LOBYTE(v39) = *(_DWORD *)(v14 + 60);
    }
    unint64_t v15 = v39;
  }
  if (CA::Display::DisplayTimingsControl::server_timing_expiry(*((os_unfair_lock_s **)this + 1)) - 1 >= a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Display::DisplayLink::_next_wakeup_info_lock);
    if (CA::Display::DisplayLink::_next_wakeup_info_count
      && (uint64_t v27 = mach_absolute_time(),
          uint64_t v28 = CA::Display::DisplayLink::_next_wakeup_info_count,
          CA::Display::DisplayLink::_next_wakeup_info_count))
    {
      unint64_t v26 = -1;
      uint64_t v29 = &qword_1EB2A8EE0;
      do
      {
        unint64_t v30 = *v29;
        if (*v29 >= v26) {
          unint64_t v30 = v26;
        }
        if (*(v29 - 1) > v27) {
          unint64_t v26 = v30;
        }
        v29 += 5;
        --v28;
      }
      while (v28);
    }
    else
    {
      unint64_t v26 = -1;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Display::DisplayLink::_next_wakeup_info_lock);
    if (!v26) {
      goto LABEL_47;
    }
    goto LABEL_35;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v14 + 92));
  uint64_t v16 = *(void *)(v14 + 112);
  uint64_t v17 = *(void *)(v14 + 120);
  BOOL v18 = v16 == v17;
  if (v16 == v17) {
    double v19 = (uint64_t *)&CAFrameIntervalRangeZero;
  }
  else {
    double v19 = (uint64_t *)(v14 + 96);
  }
  uint64_t v20 = (unsigned int *)&unk_18499B1F0;
  if (!v18) {
    uint64_t v20 = (unsigned int *)(v14 + 104);
  }
  unsigned int v21 = *v20;
  uint64_t v22 = *v19;
  os_unfair_lock_unlock((os_unfair_lock_t)(v14 + 92));
  if (v22) {
    BOOL v23 = 0;
  }
  else {
    BOOL v23 = v21 == 0;
  }
  if (v23)
  {
    unint64_t v26 = -1;
    goto LABEL_35;
  }
  uint64_t v24 = CA::Display::DisplayTimingsControl::server_frame_interval((CA::Display::DisplayTimingsControl *)v14, a2);
  *(void *)&v48.unsigned int var0 = v22;
  v48.unsigned int var2 = v21;
  unsigned int v25 = CAFrameIntervalRangeAdaptToFrameInterval(v48, v24, (*(unsigned __int8 *)(v14 + 233) >> 1) & 1);
  unint64_t v26 = v25;
  if (v25)
  {
LABEL_35:
    unint64_t v31 = *((void *)this + 1);
    if (*(unsigned char *)(v31 + 233)) {
      unsigned int v32 = 2;
    }
    else {
      unsigned int v32 = 1;
    }
    if (v32 <= *(_DWORD *)(v31 + 56)) {
      unsigned int v32 = *(_DWORD *)(v31 + 56);
    }
    LODWORD(v31) = *(_DWORD *)(v31 + 88);
    if (v32 <= v31) {
      unint64_t v31 = v31;
    }
    else {
      unint64_t v31 = v32;
    }
    if (v26 > v31) {
      unint64_t v31 = v26;
    }
    if (v31 < v15) {
      unint64_t v15 = v31;
    }
  }
LABEL_47:
  unint64_t v33 = v46 * v15;
  long long v43 = v45;
  uint64_t v44 = v46;
  v47[0] = v46 * v15;
  unint64_t phase = get_phase((unint64_t *)&v43, a2, v47);
  unint64_t v35 = a2 - phase + v47[0];
  if (!phase) {
    unint64_t v35 = a2;
  }
  if (v35 == a2) {
    unint64_t v36 = v33 + a2;
  }
  else {
    unint64_t v36 = v35;
  }
  unint64_t v37 = *((void *)this + 7);
  if (v37 > a2)
  {
    unint64_t v40 = *((void *)this + 8);
    if (!v40)
    {
      unint64_t v40 = *((void *)this + 1);
      if (*(unsigned char *)(v40 + 233)) {
        unsigned int v41 = 2;
      }
      else {
        unsigned int v41 = 1;
      }
      unsigned int v42 = *(_DWORD *)(v40 + 60);
      if (v41 <= *(_DWORD *)(v40 + 56)) {
        unsigned int v41 = *(_DWORD *)(v40 + 56);
      }
      LODWORD(v40) = *(_DWORD *)(v40 + 88);
      if (v41 > v40) {
        LODWORD(v40) = v41;
      }
      if (v40 <= v42) {
        LOBYTE(v40) = v42;
      }
      unint64_t v40 = v40;
    }
    if (v36 >= v37 || v40 > v15) {
      unint64_t v36 = CA::DynamicFrameRateSource::_commit_deadline_at_timestamp(this, v37);
    }
  }
  kdebug_trace();
  return v36;
}

uint64_t CA::Display::DisplayTimingsControl::server_frame_interval(CA::Display::DisplayTimingsControl *this, uint64_t a2)
{
  if ((*((unsigned char *)this + 233) & 4) == 0) {
    return 0;
  }
  uint64_t v5 = (os_unfair_lock_s *)((char *)this + 12);
  os_unfair_lock_lock((os_unfair_lock_t)this + 3);
  uint64_t v6 = *((void *)this + 3);
  if (v6)
  {
    do
    {
      do
      {
        unsigned int explicit = atomic_load_explicit((atomic_uint *volatile)(v6 + 16), memory_order_acquire);
        uint64_t v8 = *(void *)(v6 + 24);
        unsigned int v9 = *(_DWORD *)(v6 + 36);
        unsigned int v10 = *(_DWORD *)(v6 + 40);
        __dmb(9u);
      }
      while ((explicit & 1) != 0);
    }
    while (explicit != *(_DWORD *)(v6 + 16));
    if (!a2) {
      a2 = mach_absolute_time();
    }
    if (v8 - 1 >= a2) {
      uint64_t v2 = v9;
    }
    else {
      uint64_t v2 = v10;
    }
  }
  else
  {
    uint64_t v2 = 0;
  }
  os_unfair_lock_unlock(v5);
  return v2;
}

void display_timer_callback(__CFMachPort *a1, void *a2, uint64_t a3, char *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (void *)MEMORY[0x185324A30](a1, a2);
  uint64_t v6 = mach_absolute_time();
  pthread_mutex_lock((pthread_mutex_t *)(a4 + 16));
  kdebug_trace();
  uint64_t v7 = *((void *)a4 + 28);
  if (v6 <= v7)
  {
    unsigned int v9 = a4 + 201;
  }
  else
  {
    double v8 = CATimeWithHostTime(v6 - v7);
    unsigned int v9 = a4 + 201;
    if (a4[201])
    {
      double v10 = v8;
      if (v8 > 1.0)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          unsigned int v25 = x_log_category_windowserver;
          if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 134217984;
            *(double *)((char *)&buf + 4) = v10;
            _os_log_impl(&dword_184668000, v25, OS_LOG_TYPE_ERROR, "Timer delayed by %.2fs", (uint8_t *)&buf, 0xCu);
          }
        }
        uint64_t v7 = *((void *)a4 + 28);
      }
    }
  }
  int64_t v11 = *((void *)a4 + 27);
  int64_t v12 = v6 - v7;
  if ((uint64_t)(v6 - v7) < 0 || v12 > v11)
  {
    if (*v9 && v12 > v11)
    {
      unint64_t v13 = 0;
      uint64_t v7 = v6 - v11;
    }
    else
    {
      unint64_t v13 = (unint64_t)v11 >> 2;
      uint64_t v7 = v6;
    }
  }
  else
  {
    unint64_t v13 = *((void *)a4 + 29) >> 2;
  }
  unint64_t v14 = v7 - v13;
  uint64_t v15 = *((void *)a4 + 30);
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = v15;
  uint64_t v28 = v11;
  unint64_t v26 = 0;
  unint64_t phase = get_phase((unint64_t *)&buf, v14, &v26);
  unint64_t v17 = v14 - phase + v26;
  if (!phase) {
    unint64_t v17 = v14;
  }
  *((void *)a4 + 28) = v17 + v11;
  mk_timer_cancel();
  a4[200] = 1;
  mk_timer_arm_leeway();
  a4[200] = 0;
  BOOL v18 = (void (*)(char *, uint64_t, void, void, void))*((void *)a4 + 24);
  if (v18) {
    v18(a4, 1, *((void *)a4 + 28), *((void *)a4 + 27), *((void *)a4 + 23));
  }
  uint64_t v19 = *((void *)a4 + 30);
  if (*((void *)a4 + 29)) {
    unint64_t v20 = *((void *)a4 + 29);
  }
  else {
    unint64_t v20 = v11;
  }
  uint64_t v22 = (void (*)(char *, uint64_t, int64_t, uint64_t, uint64_t))*((void *)a4 + 18);
  uint64_t v21 = *((void *)a4 + 19);
  BOOL v23 = (uint64_t (*)(void))*((void *)a4 + 20);
  uint64_t v24 = (void (*)(uint64_t))*((void *)a4 + 21);
  if (v23) {
    uint64_t v21 = v23(*((void *)a4 + 19));
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a4 + 16));
  if (v22) {
    v22(a4, v7, v11, (v7 - v19) / v20 % 0xF0, v21);
  }
  if (v24) {
    v24(v21);
  }
}

unint64_t get_phase(unint64_t *a1, unint64_t a2, unint64_t *a3)
{
  unint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  if (v4) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v3 == 0;
  }
  if (!v5) {
    unint64_t v3 = 0;
  }
  unint64_t v6 = 240 * (v3 / 0xF0);
  unint64_t v7 = v3 % 0xF0;
  unint64_t v8 = a1[2];
  *a1 = v6;
  a1[1] = v4 - v8 * v7;
  unint64_t v9 = *a3;
  if (!*a3) {
    goto LABEL_10;
  }
  double v10 = round((double)v9 / (double)v8) * (double)v8;
  unint64_t v8 = (unint64_t)v10;
  unint64_t v11 = (unint64_t)v10 - v9;
  if (v9 >= (unint64_t)v10) {
    unint64_t v11 = v9 - (unint64_t)v10;
  }
  if (v11 <= v9 >> 5)
  {
LABEL_10:
    *a3 = v8;
    unint64_t v12 = a1[1];
    unint64_t v13 = a2 - v12;
    if (v12 >= a2) {
      unint64_t v13 = v12 - a2;
    }
    unint64_t v14 = v13 % v8;
    if (v14)
    {
      unint64_t v15 = v8 - v14;
      if (v12 >= a2) {
        return v15;
      }
      else {
        return v14;
      }
    }
    else
    {
      return 0;
    }
  }
  return a2;
}

void CA::Display::DisplayLink::unref(atomic_uint *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Display::DisplayLink::_list_lock);
  unsigned int add = atomic_fetch_add(this + 10, 0xFFFFFFFF);
  if (this && add == 1) {
    (*(void (**)(atomic_uint *))(*(void *)this + 8))(this);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Display::DisplayLink::_list_lock);
}

uint64_t CA::Display::DisplayTimingsControl::server_timing_expiry(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 3;
  os_unfair_lock_lock(this + 3);
  uint64_t v3 = *(void *)&this[6]._os_unfair_lock_opaque;
  if (v3)
  {
    do
    {
      do
      {
        unsigned int explicit = atomic_load_explicit((atomic_uint *volatile)(v3 + 16), memory_order_acquire);
        uint64_t v5 = *(void *)(v3 + 24);
        __dmb(9u);
      }
      while ((explicit & 1) != 0);
    }
    while (explicit != *(_DWORD *)(v3 + 16));
  }
  else
  {
    uint64_t v5 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v5;
}

void CA::Display::DisplayLink::callback(unint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (!a5) {
    return;
  }
  if ((CA::Display::DisplayTimingsControl::power_state((CA::Display::DisplayTimingsControl *)(*(void *)(a5 + 8)
                                                                                             + 464)) & 1) == 0
    && (*(_WORD *)(*(void *)(a5 + 8) + 760) & 0x100) == 0)
  {
    CA::Display::DisplayLink::set_display_active((CA::Display::DisplayLink *)a5, 0);
    pthread_mutex_lock((pthread_mutex_t *)(a5 + 56));
    CA::Display::DisplayLink::pause_timer_locked(a5);
    pthread_mutex_unlock((pthread_mutex_t *)(a5 + 56));
    return;
  }
  pthread_mutex_lock((pthread_mutex_t *)(a5 + 56));
  unint64_t v10 = CA::Display::DisplayLink::align_phase_locked((CA::Display::DisplayLink *)a5);
  pthread_mutex_unlock((pthread_mutex_t *)(a5 + 56));
  char v11 = CA::Display::DisplayTimingsControl::compat_quanta_mode((CA::Display::DisplayTimingsControl *)(*(void *)(a5 + 8) + 464));
  pthread_mutex_lock((pthread_mutex_t *)(a5 + 56));
  uint64_t v12 = mach_absolute_time();
  unint64_t v13 = *(uint64_t **)(a5 + 120);
  unint64_t v14 = *(uint64_t **)(a5 + 128);
  if (v13 == v14)
  {
LABEL_17:
    BOOL v18 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v15 = *v13;
      if (*(_DWORD *)(*v13 + 112) != *(_DWORD *)(a5 + 176)) {
        break;
      }
      uint64_t v16 = *(void *)(v15 + 104);
      if ((v11 & 1) == 0 && *(unsigned __int8 *)(a5 + 180) != *(unsigned __int8 *)(v15 + 128)) {
        break;
      }
      if (v16 && v16 < v12) {
        break;
      }
      if (++v13 == v14) {
        goto LABEL_17;
      }
    }
    BOOL v18 = 1;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a5 + 56));
  int v19 = CA::Display::DisplayTimingsControl::server_frame_interval((CA::Display::DisplayTimingsControl *)(*(void *)(a5 + 8) + 464), 0);
  int v20 = CA::Display::DisplayTimingsControl::server_compat_quanta_mode((CA::Display::DisplayTimingsControl *)(*(void *)(a5 + 8) + 464), 0);
  if (*(_DWORD *)(a5 + 176) != v19)
  {
    *(_DWORD *)(a5 + 176) = v19;
    BOOL v18 = 1;
  }
  if (*(unsigned __int8 *)(a5 + 180) != v20)
  {
    *(unsigned char *)(a5 + 180) = v20;
    BOOL v18 = 1;
  }
  unint64_t v21 = v10 + a3;
  CA::Display::DisplayLink::update_timer((CA::Display::DisplayLink *)a5, v18);
  pthread_mutex_lock((pthread_mutex_t *)(a5 + 56));
  double v22 = *(double *)(a5 + 160);
  pthread_mutex_unlock((pthread_mutex_t *)(a5 + 56));
  unint64_t v23 = CAHostTimeWithTime(v22);
  if (v23)
  {
    v34[1] = v23;
    uint64_t v35 = 0;
    v34[0] = a1;
    LODWORD(v35) = *(_DWORD *)(*(void *)(a5 + 8) + 104);
    if (*(void *)(a5 + 240))
    {
      pthread_mutex_lock((pthread_mutex_t *)(a5 + 56));
      if (*(void *)(a5 + 120) == *(void *)(a5 + 128))
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a5 + 56));
      }
      else
      {
        int v26 = (*(uint64_t (**)(void, void *, uint64_t, uint64_t))(*(void *)(a5 + 240) + 16))(*(void *)(a5 + 240), v34, v24, v25);
        pthread_mutex_unlock((pthread_mutex_t *)(a5 + 56));
        if (v26)
        {
LABEL_28:
          *(unsigned char *)(a5 + 200) = 1;
          *(void *)(a5 + 208) = a1;
          *(void *)(a5 + 216) = a2;
          *(void *)(a5 + 224) = v21;
          kdebug_trace();
          return;
        }
      }
    }
    else if (a4 {
           && _CFRunLoopCurrentIsMain()
    }
           && CA::Display::DisplayLink::_will_fire_handler_external
           && (*(unsigned int (**)(uint64_t, void *, uint64_t, uint64_t))(CA::Display::DisplayLink::_will_fire_handler_external
                                                                                  + 16))(CA::Display::DisplayLink::_will_fire_handler_external, v34, v27, v28) != 1)
    {
      goto LABEL_28;
    }
  }
  *(unsigned char *)(a5 + 200) = 0;
  uint64_t v29 = *(void *)(a5 + 8);
  unint64_t v30 = (CA::Display::DisplayTimingsControl *)(v29 + 464);
  uint64_t v31 = 528;
  if ((*(unsigned char *)(v29 + 697) & 8) == 0) {
    uint64_t v31 = 512;
  }
  unint64_t v32 = CAHostTimeWithTime(*(double *)(v29 + v31));
  uint64_t v33 = CA::Display::DisplayTimingsControl::granularity(v30, v32);

  CA::Display::DisplayLink::dispatch_items((CA::Display::DisplayLink *)a5, v21, a1, v33);
}

void sub_18472C18C(_Unwind_Exception *exception_object)
{
}

uint64_t CA::Display::DisplayTimingsControl::compat_quanta_mode(CA::Display::DisplayTimingsControl *this)
{
  if (*((_DWORD *)this + 14) < 2u) {
    return 0;
  }
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  uint64_t result = *(float *)&dword_1EB2ACB68 == 1;
  if (!*(float *)&dword_1EB2ACB68)
  {
    if ((*((unsigned char *)this + 233) & 2) != 0) {
      return dyld_program_sdk_at_least() ^ 1;
    }
    else {
      return 1;
    }
  }
  return result;
}

uint64_t CA::Display::DisplayTimingsControl::server_compat_quanta_mode(CA::Display::DisplayTimingsControl *this, uint64_t a2)
{
  if ((*((unsigned char *)this + 233) & 4) == 0) {
    return 0;
  }
  uint64_t v5 = (os_unfair_lock_s *)((char *)this + 12);
  os_unfair_lock_lock((os_unfair_lock_t)this + 3);
  uint64_t v6 = *((void *)this + 3);
  if (v6)
  {
    do
    {
      do
      {
        unsigned int explicit = atomic_load_explicit((atomic_uint *volatile)(v6 + 16), memory_order_acquire);
        uint64_t v8 = *(void *)(v6 + 24);
        char v9 = *(unsigned char *)(v6 + 32);
        char v10 = *(unsigned char *)(v6 + 33);
        __dmb(9u);
      }
      while ((explicit & 1) != 0);
    }
    while (explicit != *(_DWORD *)(v6 + 16));
    if (!a2) {
      a2 = mach_absolute_time();
    }
    if (v8 - 1 >= a2) {
      char v11 = v9;
    }
    else {
      char v11 = v10;
    }
    uint64_t v2 = v11 & 1;
  }
  else
  {
    uint64_t v2 = 0;
  }
  os_unfair_lock_unlock(v5);
  return v2;
}

unint64_t CA::Display::DisplayTimingsControl::granularity(CA::Display::DisplayTimingsControl *this, unint64_t a2)
{
  unint64_t v4 = (os_unfair_lock_s *)((char *)this + 12);
  os_unfair_lock_lock((os_unfair_lock_t)this + 3);
  if ((*((unsigned char *)this + 233) & 8) != 0)
  {
    a2 = CAHostTimeWithTime(*((double *)this + 8));
  }
  else
  {
    uint64_t v5 = *((void *)this + 3);
    if (v5) {
      a2 = atomic_load((unsigned int *)(v5 + 4));
    }
  }
  os_unfair_lock_unlock(v4);
  return a2;
}

unint64_t CA::Display::DisplayLink::align_phase_locked(CA::Display::DisplayLink *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (!*((void *)this + 19)) {
    return 0;
  }
  long long v7 = 0uLL;
  uint64_t v8 = 0;
  CA::Display::DisplayTimingsControl::timing_reference((CA::Display::DisplayTimingsControl *)&v7, *((void *)this + 1) + 464, 0);
  uint64_t v2 = *((void *)this + 31);
  if (v2)
  {
    if (*((void *)this + 15) != *((void *)this + 16)) {
      (*(void (**)(uint64_t, long long *))(v2 + 16))(v2, &v7);
    }
  }
  uint64_t v3 = *((void *)this + 19);
  long long v5 = v7;
  uint64_t v6 = v8;
  return CADisplayTimerAlignPhase(v3, &v5);
}

void CA::Display::DisplayTimingsControl::timing_reference(CA::Display::DisplayTimingsControl *this, uint64_t a2, uint64_t a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  char v5 = *(unsigned char *)(a2 + 233);
  if ((v5 & 0x10) != 0)
  {
    *(_OWORD *)this = *(_OWORD *)(a2 + 72);
    BOOL v18 = (v5 & 8) == 0;
    uint64_t v19 = 64;
    if (v18) {
      uint64_t v19 = 48;
    }
    *((void *)this + 2) = CAHostTimeWithTime(*(double *)(a2 + v19));
  }
  else
  {
    uint64_t v6 = *(void *)(a2 + 184);
    if (v6)
    {
      unint64_t v33 = 0;
      uint64_t v34 = 0;
      uint64_t v32 = 1;
      int v7 = (*(uint64_t (**)(uint64_t, uint64_t *))(v6 + 16))(v6, &v32);
      uint64_t v8 = v34;
      if (v34) {
        int v9 = v7;
      }
      else {
        int v9 = 0;
      }
      if (v9 != 1) {
        goto LABEL_21;
      }
      unint64_t v10 = *(void *)(a2 + 200);
      unint64_t v11 = v33;
      if (v10 - 1 >= v33)
      {
        *(void *)(a2 + 192) = 0;
        *(void *)(a2 + 200) = v11;
        unint64_t v10 = v11;
      }
      char v12 = *(unsigned char *)(a2 + 233);
      uint64_t v13 = 64;
      if ((v12 & 8) == 0) {
        uint64_t v13 = 48;
      }
      unint64_t v14 = CAHostTimeWithTime(*(double *)(a2 + v13));
      if (!v14)
      {
        unint64_t v16 = *(void *)(a2 + 192);
        goto LABEL_20;
      }
      unint64_t v15 = vcvtad_u64_f64((double)(v11 - v10) / (double)v14);
      unint64_t v16 = *(void *)(a2 + 192) + v15;
      *(void *)(a2 + 192) = v16;
      *(void *)(a2 + 200) = v11;
      if ((v12 & 1) != 0 && v15 && *(double *)(a2 + 48) != *(double *)(a2 + 32))
      {
        if ((v16 & 1) == 0)
        {
LABEL_18:
          *(unsigned char *)(a2 + 232) = 10;
          goto LABEL_19;
        }
        char v17 = *(unsigned char *)(a2 + 232) - 1;
        *(unsigned char *)(a2 + 232) = v17;
        if (!v17)
        {
          *(void *)(a2 + 192) = ++v16;
          goto LABEL_18;
        }
      }
LABEL_19:
      unint64_t v10 = v11;
LABEL_20:
      *(void *)(a2 + 208) = v16;
      *(void *)(a2 + 216) = v10;
      *(void *)(a2 + 224) = v8;
LABEL_21:
      *(_OWORD *)this = *(_OWORD *)(a2 + 208);
      *((void *)this + 2) = *(void *)(a2 + 224);
      return;
    }
    unint64_t v21 = (os_unfair_lock_s *)(a2 + 12);
    os_unfair_lock_lock((os_unfair_lock_t)(a2 + 12));
    uint64_t v22 = *(void *)(a2 + 24);
    if (v22)
    {
      *(void *)this = 0;
      *((void *)this + 1) = 0;
      *((void *)this + 2) = 0;
      uint64_t v23 = atomic_load((unsigned int *)(v22 + 4));
      *((void *)this + 2) = v23;
      uint64_t v24 = *(void *)(a2 + 24);
      if ((*(unsigned char *)(a2 + 233) & 4) != 0)
      {
        do
        {
          do
          {
            unsigned int explicit = atomic_load_explicit((atomic_uint *volatile)(v24 + 16), memory_order_acquire);
            uint64_t v28 = *(void *)(v24 + 24);
            uint64_t v29 = *(void *)(v24 + 56);
            uint64_t v30 = *(void *)(v24 + 64);
            *(void *)this = *(void *)(v24 + 48);
            *((void *)this + 1) = v30;
            __dmb(9u);
          }
          while ((explicit & 1) != 0);
        }
        while (explicit != *(_DWORD *)(v24 + 16));
        if (!a3) {
          a3 = mach_absolute_time();
        }
        if (v28 - 1 < a3) {
          *(void *)this = v29;
        }
      }
      else
      {
        do
        {
          do
          {
            unsigned int v25 = atomic_load_explicit((atomic_uint *volatile)(v24 + 16), memory_order_acquire);
            uint64_t v26 = *(void *)(v24 + 64);
            *(void *)this = *(void *)(v24 + 48);
            *((void *)this + 1) = v26;
            __dmb(9u);
          }
          while ((v25 & 1) != 0);
        }
        while (v25 != *(_DWORD *)(v24 + 16));
      }
    }
    else
    {
      *(void *)this = 0;
      *((void *)this + 1) = 0;
      uint64_t v31 = 64;
      if ((*(unsigned char *)(a2 + 233) & 8) == 0) {
        uint64_t v31 = 48;
      }
      *((void *)this + 2) = CAHostTimeWithTime(*(double *)(a2 + v31));
    }
    os_unfair_lock_unlock(v21);
  }
}

unint64_t CADisplayTimerAlignPhase(uint64_t a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (a2[1])
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    unint64_t v4 = *(void *)(a1 + 232);
    uint64_t v5 = *(void *)(a1 + 240);
    uint64_t v6 = a2[1];
    unint64_t v7 = vcvtad_u64_f64((double)(unint64_t)(v6 - v5) / (double)v4) % 0xF0;
    unint64_t v8 = *a2 % 0xF0uLL;
    unint64_t v9 = v8 + 240;
    if (v7 <= v8) {
      unint64_t v9 = *a2 % 0xF0uLL;
    }
    unint64_t v10 = v9 - v7;
    if (v7 == v8) {
      unint64_t v11 = 0;
    }
    else {
      unint64_t v11 = v10;
    }
    unint64_t v12 = ((v6 - v5) % v4);
    unint64_t v13 = v4 - v12;
    if (v12 >= v13) {
      unint64_t v14 = v13;
    }
    else {
      unint64_t v14 = v12;
    }
    unint64_t v15 = a2[2];
    BOOL v16 = v14 >= v15 >> 7 || v5 == 0;
    if (v16 || v11)
    {
      unint64_t v17 = vcvtad_u64_f64((double)*(unint64_t *)(a1 + 208) / (double)v15);
      uint64_t v18 = *(void *)(a1 + 216);
      if (v17)
      {
        unint64_t v19 = v15 * v17;
        *(void *)(a1 + 216) = v15 * v17;
        *(void *)(a1 + 232) = v15;
        *(void *)(a1 + 240) = v6 - v8 * v15;
      }
      else
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          uint64_t v27 = x_log_category_windowserver;
          if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
          {
            uint64_t v28 = *(void *)(a1 + 208);
            *(_DWORD *)long long buf = 134218240;
            *(void *)&uint8_t buf[4] = v28;
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v15;
            _os_log_impl(&dword_184668000, v27, OS_LOG_TYPE_ERROR, "CADisplayTimerAlignPhase: unexpected state (interval:%llx, heartbeat:%llx)", buf, 0x16u);
          }
        }
        unint64_t v19 = *(void *)(a1 + 216);
      }
      if (BYTE9(xmmword_1EB2ACC10))
      {
        kdebug_trace();
        unint64_t v19 = *(void *)(a1 + 216);
      }
      uint64_t v20 = *(void *)(a1 + 224) - v18 + (v19 >> 1);
      if (v20 <= mach_absolute_time()) {
        uint64_t v20 = mach_absolute_time();
      }
      uint64_t v21 = *(void *)(a1 + 240);
      uint64_t v22 = *(void *)(a1 + 216);
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = v21;
      *(void *)&uint8_t buf[16] = v22;
      unint64_t v29 = 0;
      unint64_t phase = get_phase((unint64_t *)buf, v20, &v29);
      uint64_t v24 = v20 - phase + v29;
      if (!phase) {
        uint64_t v24 = v20;
      }
      *(void *)(a1 + 224) = v24;
      mk_timer_cancel();
      *(unsigned char *)(a1 + 200) = 1;
      mk_timer_arm_leeway();
      *(unsigned char *)(a1 + 200) = 0;
      unsigned int v25 = *(void (**)(uint64_t, uint64_t, void, void, void))(a1 + 192);
      if (v25) {
        v25(a1, 1, *(void *)(a1 + 224), *(void *)(a1 + 216), *(void *)(a1 + 184));
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
  else
  {
    unint64_t v11 = 0;
    *(void *)(a1 + 232) = a2[2];
  }
  return v11;
}

uint64_t CA::Display::DisplayLink::update_timer(CA::Display::DisplayLink *this, int a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 56);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 56));
  CA::Display::DisplayLink::update_timer_locked(this, a2);

  return pthread_mutex_unlock(v4);
}

void sub_18472C9E8(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::Display::DisplayLink::update_timer_locked(CA::Display::DisplayLink *this, int a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (_opaque_pthread_t *)*((void *)this + 23);
  if (v4 && v4 != pthread_self()) {
    return 0;
  }
  *((void *)this + 23) = pthread_self();
  uint64_t v6 = *((void *)this + 1);
  uint64_t v7 = 528;
  if ((*(unsigned char *)(v6 + 697) & 8) == 0) {
    uint64_t v7 = 512;
  }
  double v8 = *(double *)(v6 + v7);
  if (v8 <= 0.0)
  {
    unint64_t v14 = (CFTypeRef *)((char *)this + 152);
    uint64_t v13 = *((void *)this + 19);
    if (v13)
    {
      CADisplayTimerInvalidate(v13);
      CFRelease(*v14);
      CFTypeRef *v14 = 0;
      *((void *)this + 20) = 0;
    }
  }
  else
  {
    if (a2)
    {
      CA::Display::DisplayLink::refresh_item_properties_locked(this);
      CA::Display::DisplayLink::compute_firing_rate_multiplier_locked((uint64_t)this);
    }
    uint64_t v9 = *((void *)this + 19);
    if (v9)
    {
      uint64_t v10 = *((int *)this + 42);
      double v11 = v8 * (double)(int)v10;
      if (*((double *)this + 20) != v11)
      {
        *((double *)this + 20) = v11;
        unint64_t v12 = CAHostTimeWithTime(v8);
        CADisplayTimerSetInterval(v9, v12, v10);
      }
    }
    else
    {
      *(void *)&long long v19 = this;
      *((void *)&v19 + 1) = CA::Display::DisplayLink::update_timer_locked(BOOL)::$_0::__invoke;
      uint64_t v20 = CA::Display::DisplayLink::update_timer_locked(BOOL)::$_1::__invoke;
      uint64_t v21 = 0;
      long long v18 = 0uLL;
      if (CFRunLoopGetMain() == *((CFRunLoopRef *)this + 2) && !*(void *)(*((void *)this + 1) + 448))
      {
        *(void *)&long long v18 = this;
        *((void *)&v18 + 1) = CA::Display::DisplayLink::timer_status_callback;
      }
      *((double *)this + 20) = v8 * (double)*((int *)this + 42);
      uint64_t v15 = mach_absolute_time();
      double v16 = CATimeWithHostTime(v15);
      *((void *)this + 19) = CADisplayTimerCreate((uint64_t)CA::Display::DisplayLink::callback, &v19, &v18, v16, *((double *)this + 20));
      CA::Display::DisplayLink::align_phase_locked(this);
      if (*((void *)this + 19))
      {
        for (uint64_t i = *((void *)this + 3); i; uint64_t i = *(void *)(i + 8))
          CADisplayTimerAddToRunLoop(*((void *)this + 19), *((__CFRunLoop **)this + 2), *(const __CFString **)i);
      }
    }
  }
  *((void *)this + 23) = 0;
  if (*((unsigned char *)this + 192))
  {
    *((unsigned char *)this + 192) = 0;
    CA::Display::DisplayLink::start_timer_locked(this);
  }
  return 1;
}

uint64_t CA::Display::DisplayTimingsControl::power_state(CA::Display::DisplayTimingsControl *this)
{
  v9[3] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 23);
  if (v2)
  {
    v9[1] = 0;
    _OWORD v9[2] = 0;
    v9[0] = 1;
    unsigned int v3 = (*(uint64_t (**)(uint64_t, void *))(v2 + 16))(v2, v9) ^ 1;
    if (BYTE4(v9[0])) {
      return 1;
    }
    else {
      return v3;
    }
  }
  else
  {
    uint64_t v5 = (os_unfair_lock_s *)((char *)this + 12);
    os_unfair_lock_lock((os_unfair_lock_t)this + 3);
    uint64_t v6 = *((void *)this + 3);
    if (v6)
    {
      unsigned __int8 v7 = atomic_load((unsigned __int8 *)(v6 + 1));
      uint64_t v4 = v7 & 1;
    }
    else
    {
      uint64_t v4 = 1;
    }
    os_unfair_lock_unlock(v5);
  }
  return v4;
}

unint64_t CA::WindowServer::IOMFBDisplay::timing_granularity(os_unfair_lock_s *this, int a2)
{
  uint64_t v4 = this + 6512;
  os_unfair_lock_lock(this + 6512);
  uint64_t v5 = *(unsigned __int8 **)&this[6516]._os_unfair_lock_opaque;
  if (v5 && ((unsigned __int8 v6 = atomic_load(v5), (v6 & 1) != 0) || !a2))
  {
    unint64_t v8 = atomic_load((unsigned int *)(*(void *)&this[6516]._os_unfair_lock_opaque + 4));
  }
  else
  {
    double v7 = (*(double (**)(os_unfair_lock_s *))(*(void *)&this->_os_unfair_lock_opaque + 760))(this);
    unint64_t v8 = CAHostTimeWithTime(v7);
  }
  os_unfair_lock_unlock(v4);
  return v8;
}

void CA::Render::collect(CA::Render *this, double a2)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    BOOL v3 = 1;
  }
  else
  {
    double v4 = a2 + -5.0;
    if (CA::Render::memory_once[0] != -1) {
      dispatch_once_f(CA::Render::memory_once, 0, (dispatch_function_t)CA::Render::init_memory_warnings_);
    }
    BOOL v3 = *(double *)&CA::Render::last_memory_warning > v4;
  }
  if (CA::Render::subimage_head)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    if (v3) {
      unint64_t v5 = 0x100000;
    }
    else {
      unint64_t v5 = 0x800000;
    }
    if (v3) {
      double v6 = 0.1;
    }
    else {
      double v6 = 1.0;
    }
    uint64_t v7 = CA::Render::subimage_head;
    if (CA::Render::subimage_head)
    {
      unint64_t v8 = 0;
      unint64_t v9 = 0;
      while (1)
      {
        uint64_t v10 = (double *)v7;
        uint64_t v7 = *(void *)(v7 + 8);
        double v11 = a2 - v10[10];
        unint64_t v12 = (_DWORD *)*((void *)v10 + 3);
        if (!v12) {
          goto LABEL_35;
        }
        int v13 = *((_DWORD *)v10 + 13);
        if (v13) {
          goto LABEL_35;
        }
        if (v11 >= 30.0 || (v11 >= v6 ? (BOOL v14 = *((void *)v10 + 4) + v9 > v5) : (BOOL v14 = 0), v14))
        {
          char v15 = v11 >= 600.0 || v3;
          double v16 = (void *)v7;
          if (v15) {
            goto LABEL_38;
          }
          double v16 = (void *)v7;
          if (*((void *)v10 + 4) + v8 > 0x10000000) {
            goto LABEL_38;
          }
          if ((v13 & 0x20000) != 0)
          {
            v8 += *((void *)v10 + 4);
LABEL_35:
            if (!v7) {
              goto LABEL_48;
            }
          }
          else
          {
            double v16 = (void *)v7;
            if (v12[2] == 1)
            {
              if (((*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)v12 + 192))(v12, 1) & 1) == 0)
              {
                double v16 = (void *)*((void *)v10 + 1);
                goto LABEL_38;
              }
              *((_DWORD *)v10 + 13) |= 0x20000u;
              v8 += *((void *)v10 + 4);
              if (!v7) {
                goto LABEL_48;
              }
            }
            else
            {
LABEL_38:
              if (v16) {
                *double v16 = *(void *)v10;
              }
              if (*(void *)v10) {
                unint64_t v17 = (uint64_t *)(*(void *)v10 + 8);
              }
              else {
                unint64_t v17 = &CA::Render::subimage_head;
              }
              uint64_t *v17 = (uint64_t)v16;
              long long v18 = (atomic_uint *)*((void *)v10 + 3);
              if (atomic_fetch_add(v18 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v18 + 16))(v18);
              }
              x_hash_table_remove_ptr(*(void *)(*((void *)v10 + 2) + 144), (uint64_t)(v10 + 5));
              malloc_zone = (malloc_zone_t *)get_malloc_zone();
              malloc_zone_free(malloc_zone, v10);
              if (!v7) {
                goto LABEL_48;
              }
            }
          }
        }
        else
        {
          v9 += *((void *)v10 + 4);
          if (!v7) {
            goto LABEL_48;
          }
        }
      }
    }
    unint64_t v9 = 0;
    unint64_t v8 = 0;
    double v11 = 0.0;
LABEL_48:
    if (BYTE8(ca_debug_options)
      && *(double *)&CA::Render::ImageProvider::collect(double,BOOL)::last_log_time + 1.0 <= a2)
    {
      CA::Render::ImageProvider::collect(double,BOOL)::last_log_time = *(void *)&a2;
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unsigned int v39 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          if (CA::Render::subimage_head) {
            double v40 = a2 - *(double *)(CA::Render::subimage_head + 80);
          }
          else {
            double v40 = 0.0;
          }
          *(_DWORD *)long long buf = 134218752;
          *(double *)&uint8_t buf[4] = (double)v9 * 0.000001;
          __int16 v42 = 2048;
          double v43 = (double)v8 * 0.000001;
          __int16 v44 = 2048;
          double v45 = v40;
          __int16 v46 = 2048;
          double v47 = v11;
          _os_log_impl(&dword_184668000, v39, OS_LOG_TYPE_DEFAULT, "CAImageProvider: %.3gMB cached (%.3gMB purgeable); idle %.3gs -> %.3gs\n",
            buf,
            0x2Au);
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
  }
  if (CA::Render::pattern_cache) {
    BOOL v20 = qword_1EB2A8A98 == (void)&CA::Render::pattern_cache_list;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::pattern_lock);
    uint64_t v21 = qword_1EB2A8A98;
    if ((uint64_t *)qword_1EB2A8A98 == &CA::Render::pattern_cache_list)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::pattern_lock);
    }
    else
    {
      uint64_t v22 = 0;
      while (*(double *)(v21 + 32) <= a2)
      {
        uint64_t v23 = (void *)v21;
        uint64_t v21 = *(void *)(v21 + 8);
        x_hash_table_remove(CA::Render::pattern_cache, v23[2]);
        uint64_t v25 = *v23;
        uint64_t v24 = (void *)v23[1];
        *(void *)(v25 + 8) = v24;
        *uint64_t v24 = v25;
        *uint64_t v23 = v23;
        v23[1] = v22;
        uint64_t v22 = v23;
        if ((uint64_t *)v21 == &CA::Render::pattern_cache_list) {
          goto LABEL_61;
        }
      }
      uint64_t v23 = v22;
LABEL_61:
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::pattern_lock);
      while (v23)
      {
        uint64_t v26 = v23;
        uint64_t v23 = (void *)v23[1];
        uint64_t v27 = (atomic_uint *)v26[3];
        if (v27 && atomic_fetch_add(v27 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v27 + 16))(v27);
        }
        uint64_t v28 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v28, v26);
      }
    }
  }
  if (CA::Render::image_cache) {
    BOOL v29 = qword_1EB2AC540 == (void)&CA::Render::image_cache_list;
  }
  else {
    BOOL v29 = 1;
  }
  if (!v29)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::image_cache_lock);
    uint64_t v30 = qword_1EB2AC540;
    if ((uint64_t *)qword_1EB2AC540 == &CA::Render::image_cache_list)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::image_cache_lock);
    }
    else
    {
      uint64_t v31 = 0;
      while (*(double *)(v30 + 32) <= a2)
      {
        uint64_t v32 = (void *)v30;
        uint64_t v30 = *(void *)(v30 + 8);
        x_hash_table_remove(CA::Render::image_cache, v32[2]);
        uint64_t v34 = *v32;
        unint64_t v33 = (void *)v32[1];
        *(void *)(v34 + 8) = v33;
        *unint64_t v33 = v34;
        *uint64_t v32 = v32;
        v32[1] = v31;
        uint64_t v31 = v32;
        if ((uint64_t *)v30 == &CA::Render::image_cache_list) {
          goto LABEL_77;
        }
      }
      uint64_t v32 = v31;
LABEL_77:
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::image_cache_lock);
      while (v32)
      {
        uint64_t v35 = v32;
        uint64_t v32 = (void *)v32[1];
        uint64_t v36 = (atomic_uint *)v35[3];
        if (v36 && atomic_fetch_add(v36 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v36 + 16))(v36);
        }
        unint64_t v37 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v37, v35);
      }
    }
  }
  *(double *)long long buf = a2;
  if ((CA::Render::Image::_subimage_deadline & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Image::_subimage_table_lock);
    if (*(double *)&CA::Render::Image::_subimage_deadline <= a2 && CA::Render::Image::_subimage_table != 0)
    {
      CA::Render::Image::_subimage_deadline = 0x7FF0000000000000;
      x_hash_table_remove_if (CA::Render::Image::_subimage_table, (unsigned int (*)(void, void, uint64_t))CA::Render::Image::collect_subimages_, (uint64_t)buf);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Image::_subimage_table_lock);
  }
}

uint64_t CA::Display::DisplayLink::update_timer_locked(BOOL)::$_0::__invoke(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      int v1 = *(_DWORD *)(result + 40);
      if (!v1) {
        break;
      }
      int v2 = *(_DWORD *)(result + 40);
      atomic_compare_exchange_strong((atomic_uint *volatile)(result + 40), (unsigned int *)&v2, v1 + 1);
      if (v2 == v1) {
        return result;
      }
    }
    return 0;
  }
  return result;
}

void CA::Display::DisplayLink::callback(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
}

void CA::Display::DisplayLink::update_timer_locked(BOOL)::$_1::__invoke(atomic_uint *this)
{
  if (this) {
    CA::Display::DisplayLink::unref(this);
  }
}

void CA::OGL::AsynchronousDispatcher::timer_callback(int a1, int a2, int a3, int a4, CA::OGL::AsynchronousDispatcher *this)
{
}

uint64_t CADisplayTimerCreate(uint64_t a1, _OWORD *a2, _OWORD *a3, double a4, double a5)
{
  if (CADisplayTimerGetTypeID::once[0] != -1) {
    dispatch_once(CADisplayTimerGetTypeID::once, &__block_literal_global_7146);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v11 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = 850045863;
    *(_OWORD *)(Instance + 24) = 0u;
    *(_OWORD *)(Instance + 40) = 0u;
    *(_OWORD *)(Instance + 56) = 0u;
    *(void *)(Instance + 72) = 0;
    *(void *)(Instance + 80) = 1;
    uint64_t v12 = MEMORY[0x1E4F1C280];
    *(void *)(Instance + 88) = Instance;
    *(void *)(Instance + 96) = v12;
    *(void *)(Instance + 104) = MEMORY[0x1E4F1C278];
    *(void *)(Instance + 112) = 0;
    mach_port_t v13 = mk_timer_create();
    *(_DWORD *)(v11 + 120) = v13;
    if (v13)
    {
      BOOL v14 = CFMachPortCreateWithPort(0, v13, (CFMachPortCallBack)display_timer_callback, (CFMachPortContext *)(v11 + 80), 0);
      *(void *)(v11 + 128) = v14;
      if (v14)
      {
        CFRunLoopSourceRef RunLoopSource = CFMachPortCreateRunLoopSource(0, v14, -1);
        *(void *)(v11 + 136) = RunLoopSource;
        if (RunLoopSource)
        {
          *(_WORD *)(v11 + 200) = 1;
          *(void *)(v11 + 240) = 0;
          *(void *)(v11 + 224) = CAHostTimeWithTime(a4);
          unint64_t v16 = CAHostTimeWithTime(a5);
          *(_OWORD *)(v11 + 152) = 0u;
          *(void *)(v11 + 232) = v16;
          *(void *)(v11 + 208) = v16;
          *(void *)(v11 + 216) = v16;
          *(void *)(v11 + 144) = a1;
          *(_OWORD *)(v11 + 168) = 0u;
          if (a2)
          {
            long long v17 = a2[1];
            *(_OWORD *)(v11 + 152) = *a2;
            *(_OWORD *)(v11 + 168) = v17;
          }
          *(void *)(v11 + 184) = 0;
          *(void *)(v11 + 192) = 0;
          if (a3) {
            *(_OWORD *)(v11 + 184) = *a3;
          }
          return v11;
        }
      }
      CADisplayTimerInvalidate(v11);
    }
    return 0;
  }
  return v11;
}

uint64_t CA::WindowServer::IOMFBServer::refresh_timer_interval(CA::WindowServer::IOMFBServer *this)
{
  double v2 = (*(double (**)(void))(**((void **)this + 12) + 760))(*((void *)this + 12));
  unint64_t v3 = CAHostTimeWithTime(v2);
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 12) + 768))();
  unint64_t v5 = (_DWORD *)*((void *)this + 12);
  if ((v5[156] & 0x100) != 0)
  {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)v5 + 136))(*((void *)this + 12));
    if (!result) {
      uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 12) + 784))(*((void *)this + 12));
    }
    *((_DWORD *)this + 235) = result;
  }
  if (*((void *)this + 100))
  {
    uint64_t v6 = result;
    uint64_t v7 = *((void *)this + 100);
    return CADisplayTimerSetInterval(v7, v3, v6);
  }
  return result;
}

void *CA::WindowServer::IOMFBDisplay::activate_replay(CA::WindowServer::IOMFBDisplay *this)
{
  double v2 = (char *)this + 25560;
  uint64_t result = (void *)CA::WindowServer::IOMFBDisplay::service_int_property((CA::WindowServer::IOMFBDisplay *)*((unsigned int *)this + 6390), @"IdleState");
  if (!v2[2578] && (*((_WORD *)this + 328) & 0x1C00) != 0x1000)
  {
    BOOL v8 = v2[2600] && byte_1EB2ACC09 == 0;
    BOOL v9 = !v8 || result == 2;
    if (!v9 && result != 1)
    {
      if (v2[2604]
        || (uint64_t result = (void *)CA::WindowServer::IOMFBDisplay::framebuffer_available(this, v4, v5, v6, v7),
            result))
      {
        return CA::WindowServer::IOMFBDisplay::activate_replay_(this);
      }
    }
  }
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::service_int_property(CA::WindowServer::IOMFBDisplay *this, const __CFString *a2)
{
  if (!this) {
    return 0;
  }
  CFPropertdouble y = IORegistryEntryCreateCFProperty((io_registry_entry_t)this, a2, 0, 0);
  if (!CFProperty) {
    return 0;
  }
  unint64_t v3 = CFProperty;
  uint64_t v4 = CA_CFIntValue(CFProperty);
  CFRelease(v3);
  return v4;
}

uint64_t CA::WindowServer::IOMFBDisplay::framebuffer_available(CA::WindowServer::IOMFBDisplay *this, uint64_t a2, uint64_t a3, uint64_t a4, double *a5)
{
  CA::WindowServer::IOMFBDisplay::can_update_(this, 0, 0.0, 0.0, a3, a4, a5);
  uint64_t v6 = (uint64_t *)*((void *)this + 3254);
  if (!v6) {
    return 0;
  }
  while (!v6[4] || *((_DWORD *)v6 + 2))
  {
    uint64_t v6 = (uint64_t *)*v6;
    if (!v6) {
      return 0;
    }
  }
  return 1;
}

void sub_18472D8E4(_Unwind_Exception *exception_object)
{
  if (atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
  }
  _Unwind_Resume(exception_object);
}

void _XGetDisplayEDRState(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)a1 & 0x80000000) != 0 || *(_DWORD *)(a1 + 4) != 36)
  {
    int v3 = -304;
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 36) || *(_DWORD *)(a1 + 40) <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return;
  }
  *(void *)(a2 + 32) = 0x13000000000000;
  int v4 = *(_DWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 72);
  v11[0] = *(_OWORD *)(a1 + 56);
  v11[1] = v5;
  if ((CA::Render::Server::audit_token_cache_lookup((CA::Render::Server *)v11, (const audit_token_t *)a2) & 0x80) != 0
    || (CA::Render::Server::audit_token_cache_lookup((CA::Render::Server *)v11, v6) & 0x20000) != 0)
  {
    int v3 = -81182719;
    goto LABEL_7;
  }
  v9[0] = 0;
  object_handle = 0;
  v9[1] = v4;
  CA::Render::post_notification(0x1Cu, 0, (uint64_t)v9, 0);
  if (!LOBYTE(v9[0]))
  {
    int v3 = 56;
    goto LABEL_7;
  }
  if (object_handle)
  {
    int v7 = CA::Render::Shmem::port(object_handle);
    BOOL v8 = object_handle;
    *(_DWORD *)(a2 + 28) = v7;
    if (v8) {
      BOOL v8 = (mach_port_t *)*((void *)v8 + 2);
    }
  }
  else
  {
    BOOL v8 = 0;
    *(_DWORD *)(a2 + 28) = 0;
  }
  *(void *)(a2 + 40) = *MEMORY[0x1E4F14068];
  *(void *)(a2 + 48) = v8;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
}

void CA::Render::GroupAnimation::~GroupAnimation(CA::Render::GroupAnimation *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02DDF0;
  int v3 = (atomic_uint *)*((void *)this + 12);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  --dword_1EB2ADE1C;
  CA::Render::Animation::~Animation(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  uint64_t vars8;

  *(void *)this = &unk_1ED02DDF0;
  int v3 = (atomic_uint *)*((void *)this + 12);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  --dword_1EB2ADE1C;

  CA::Render::Animation::~Animation(this, a2);
}

uint64_t CA::Render::Context::set_layer_id(uint64_t this, uint64_t a2)
{
  if (*(void *)(this + 272) != a2)
  {
    uint64_t v3 = this;
    uint64_t v4 = CA::Render::Context::root_layer_handle((CA::Render::Context *)this);
    if (v4)
    {
      uint64_t v7 = *(void *)(v4 + 16);
      if (v7)
      {
        BOOL v8 = *(int32x2_t **)(v7 + 144);
        if (v8)
        {
          CA::Render::Context::invalidate((CA::Render::Context *)v3, v8 + 14, v6);
          *(void *)&v8[12] |= 8uLL;
        }
      }
    }
    if (a2)
    {
      uint64_t v9 = CA::Render::Context::lookup_object(*(void *)(v3 + 136), *(_DWORD *)(v3 + 148), a2, 0, 29, 0);
      if (v9)
      {
        uint64_t v10 = *(void *)(v9 + 144);
        if (v10) {
          *(void *)(v10 + 96) |= 2uLL;
        }
      }
    }
    this = *(void *)(v3 + 280);
    if (this)
    {
      *(_DWORD *)(this + 12) &= ~0x100u;
      CA::Render::Handle::update_container_state(this, v5);
      this = *(void *)(v3 + 280);
      if (this)
      {
        if (atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
          this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
        }
        *(void *)(v3 + 280) = 0;
      }
    }
    *(void *)(v3 + 272) = a2;
  }
  return this;
}

uint64_t CA::Render::Context::lookup_object(uint64_t a1, int a2, uint64_t a3, int a4, int a5, int *a6)
{
  unint64_t v6 = ((a3 ^ 0x8000000000000000) + ~(a3 << 32)) ^ (((a3 ^ 0x8000000000000000) + ~(a3 << 32)) >> 22);
  unint64_t v7 = 9 * ((v6 + ~(v6 << 13)) ^ ((v6 + ~(v6 << 13)) >> 8));
  unint64_t v8 = (v7 ^ (v7 >> 15)) + ~((v7 ^ (v7 >> 15)) << 27);
  uint64_t v9 = (uint64_t *)(a1 + 8 * (((v8 >> 31) ^ v8) & a2));
  do
  {
    uint64_t v9 = (uint64_t *)*v9;
    if (!v9)
    {
      if (!a6) {
        return 0;
      }
      uint64_t result = 0;
      int v12 = 1;
      goto LABEL_23;
    }
  }
  while (v9[1] != (a3 ^ 0x8000000000000000));
  if (a4 && *((_DWORD *)v9 + 6) != a4)
  {
    if (!a6) {
      return 0;
    }
    uint64_t result = 0;
    int v12 = 2;
    goto LABEL_23;
  }
  uint64_t result = v9[2];
  if (!result)
  {
    if (!a6) {
      return 0;
    }
    uint64_t result = 0;
    int v12 = 3;
    goto LABEL_23;
  }
  int v11 = *(unsigned __int8 *)(result + 12);
  if (v11 != 22)
  {
    if (!a5 || v11 == a5) {
      return result;
    }
    if (!a6) {
      return 0;
    }
    uint64_t result = 0;
    int v12 = 5;
LABEL_23:
    *a6 = v12;
    return result;
  }
  if (!a5 || a5 == 29) {
    return *(void *)(result + 16);
  }
  if (a6)
  {
    uint64_t result = 0;
    int v12 = 4;
    goto LABEL_23;
  }
  return 0;
}

void CA::Render::LayerHost::~LayerHost(atomic_uint **this)
{
  CA::Render::LayerHost::~LayerHost(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  const CA::Render::Object *v2;
  atomic_uint *v3;
  atomic_uint *v4;
  atomic_uint *v5;

  *this = (atomic_uint *)&unk_1ED0300E8;
  CA::Render::LayerHost::invalidate((CA::Render::LayerHost *)this);
  uint64_t v3 = this[5];
  if (v3)
  {
    this[6] = v3;
    operator delete(v3);
  }
  uint64_t v4 = this[4];
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  long long v5 = this[3];
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  --dword_1EB2ADE40;
  *this = (atomic_uint *)&unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate((CA::Render::Encoder::ObjectCache *)this, v2);
  }
}

void CA::Render::Handle::~Handle(CA::Render::Handle *this)
{
  CA::Render::Handle::~Handle(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  CA::Render::LayerNode *v2;
  CA::Render::Animation *v3;
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t v7;
  atomic_uint *v8;

  *(void *)this = &unk_1ED02F600;
  CA::Render::Handle::set_current_layer((uint64_t)this, 0);
  uint64_t v4 = *((void *)this + 6);
  if (v4)
  {
    do
    {
      CA::Render::invalidate_animation(this, *(Handle **)v4, v3);
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4);
    long long v5 = (void *)*((void *)this + 6);
    if (v5)
    {
      do
      {
        unint64_t v6 = (void *)v5[1];
        free(v5);
        long long v5 = v6;
      }
      while (v6);
    }
  }
  unint64_t v7 = *((void *)this + 5);
  if (v7)
  {
    *(void *)(v7 + 40) = 0;
    if (atomic_fetch_add((atomic_uint *volatile)(v7 + 16), 0xFFFFFFFF) == 1) {
      CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v7, v2);
    }
  }
  unint64_t v8 = (atomic_uint *)*((void *)this + 2);
  if (v8 && atomic_fetch_add(v8 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v8 + 16))(v8);
  }
  --dword_1EB2ADE20;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, v2);
  }
}

void CA::Render::LayerHost::invalidate(CA::Render::LayerHost *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
  uint64_t v2 = *((void *)this + 9);
  if (v2)
  {
    *(void *)(v2 + 416) = 0;
    *((void *)this + 9) = 0;
    atomic_fetch_add(CA::Render::LayerHost::_seed, 1u);
    uint64_t v3 = (atomic_uint *)v2;
    if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
    {
      uint64_t v3 = 0;
      atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 0xFFFFFFFF);
    }
    CA::Render::Context::set_visible_locked((CA::Render::Context *)v2, 0);
    CA::Render::Context::update_backdrop_namespaces_locked(v2, 0);
  }
  else
  {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *((void *)this + 10);
  if (v4)
  {
    *(void *)(v4 + 424) = x_list_remove(*(void **)(v4 + 424), (uint64_t)this);
    *((void *)this + 10) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
  if (v3)
  {
    CA::Render::invalidate_context((CA::Render *)v3, v5);
    if (atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1)
    {
      unint64_t v6 = *(void (**)(atomic_uint *))(*(void *)v3 + 16);
      v6(v3);
    }
  }
}

void CA::Render::Context::remove_animation(CA::Render::Context *this, CA::Render::Object *a2, const __CFString *a3)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = CA::Render::Context::lookup_handle(this, a2, 0, 0, 0);
  if (!v4) {
    return;
  }
  unint64_t v6 = v4;
  unint64_t v7 = (void **)((char *)v4 + 48);
  unint64_t v8 = (void *)*((void *)v4 + 6);
  if (!v8) {
    return;
  }
  if (a3)
  {
    CFHashCode v9 = CFHash(a3);
    unint64_t v8 = *v7;
    if (!*v7) {
      return;
    }
    CFHashCode v10 = v9;
  }
  else
  {
    CFHashCode v10 = 0;
  }
  do
  {
    uint64_t v11 = *v8;
    int v12 = *(const void **)(*v8 + 56);
    if (a3)
    {
      if (!v12 || v10 != *(void *)(v11 + 64) || !CFEqual(a3, v12))
      {
LABEL_16:
        mach_port_t v13 = (void *)v8[1];
        unint64_t v7 = (void **)(v8 + 1);
        goto LABEL_17;
      }
    }
    else if (v12)
    {
      goto LABEL_16;
    }
    if (!byte_1EB2ACBE7) {
      goto LABEL_12;
    }
    x_log_begin();
    if (x_log_hook_p())
    {
      uint64_t v15 = mach_absolute_time();
      CATimeWithHostTime(v15);
      x_log_();
    }
    else
    {
      long long v17 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = mach_absolute_time();
        double v19 = CATimeWithHostTime(v18);
        uint64_t v20 = *((void *)v6 + 3);
        if (v20) {
          LODWORD(v20) = *(_DWORD *)(v20 + 16);
        }
        uint64_t v21 = *((void *)v6 + 2);
        if (v21)
        {
          uint64_t v22 = *(void *)(v21 + 120);
          if (v22) {
            uint64_t v21 = v22 + 28;
          }
          else {
            uint64_t v21 = 0;
          }
        }
        int v23 = *(_DWORD *)(v11 + 80);
        int v24 = *(_DWORD *)(v11 + 84);
        *(_DWORD *)long long buf = 134219522;
        double v42 = v19;
        __int16 v43 = 1024;
        int v44 = v20;
        __int16 v45 = 2080;
        __int16 v46 = (char *)v21;
        __int16 v47 = 2048;
        uint64_t v48 = v6;
        __int16 v49 = 2048;
        uint64_t v50 = v11;
        __int16 v51 = 1024;
        int v52 = v23;
        __int16 v53 = 1024;
        int v54 = v24;
        _os_log_impl(&dword_184668000, v17, OS_LOG_TYPE_DEFAULT, "%f %x \"%s\" (%p): removing %p (eval %u; frames %u):\n",
          buf,
          0x3Cu);
      }
    }
    CA::Render::show_object((CA::Render *)v11, v16);
    uint64_t v36 = (void **)x_stream_pop_(0);
    uint64_t v38 = x_stream_get(v36);
    int v25 = 0;
    while (2)
    {
      uint64_t v26 = 0;
      uint64_t v27 = &v38[v25];
      int v28 = -1;
      while (1)
      {
        if (v27[v26] == 10)
        {
          int v28 = v26;
          goto LABEL_35;
        }
        if (!v27[v26]) {
          break;
        }
LABEL_35:
        ++v26;
        unsigned int v29 = 32512;
        if (v26 == 32512) {
          goto LABEL_36;
        }
      }
      unsigned int v29 = v26;
LABEL_36:
      if (v28 <= -1 || v27[v29] == 0) {
        int v31 = v29;
      }
      else {
        int v31 = v28 + 1;
      }
      if (v31 > 0)
      {
        int v39 = v31;
        int v40 = v25;
        if (x_log_hook_p())
        {
          x_log_();
          int v32 = v39;
          int v33 = v40;
        }
        else
        {
          log = x_log_category_render;
          BOOL v34 = os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT);
          int v33 = v40;
          int v32 = v39;
          if (v34)
          {
            *(_DWORD *)long long buf = 136315650;
            uint64_t v35 = "continued...\n";
            if (!v40) {
              uint64_t v35 = "";
            }
            double v42 = *(double *)&v35;
            __int16 v43 = 1040;
            int v44 = v39;
            __int16 v45 = 2080;
            __int16 v46 = v27;
            _os_log_impl(&dword_184668000, log, OS_LOG_TYPE_DEFAULT, "%s%.*s", buf, 0x1Cu);
            int v32 = v39;
            int v33 = v40;
          }
        }
        int v25 = v32 + v33;
        continue;
      }
      break;
    }
    x_log_end_free_(v36);
LABEL_12:
    if (BYTE9(xmmword_1EB2ACC10)) {
      kdebug_trace();
    }
    CA::Render::invalidate_animation(v6, (Handle *)v11, v5);
    mach_port_t v13 = (void *)v8[1];
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v8);
    double *v7 = v13;
    *((void *)v6 + 12) |= 0x10080003uLL;
LABEL_17:
    unint64_t v8 = v13;
  }
  while (v13);
}

atomic_uint *CA::Render::invalidate_animation(CA::Render *this, Handle *a2, CA::Render::Animation *a3)
{
  uint64_t result = (atomic_uint *)((uint64_t (*)(Handle *, CA::Render *, CA::Render::Animation *))(*a2)[19])(a2, this, a3);
  int v5 = *((_DWORD *)a2 + 3);
  *((_DWORD *)a2 + 3) = v5 | 0x20000;
  if (v5 == 55)
  {
    uint64_t result = (atomic_uint *)a2[16];
    if (result)
    {
      if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
        uint64_t result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
      }
      a2[16] = 0;
    }
  }
  if (atomic_fetch_add((atomic_uint *volatile)a2 + 2, 0xFFFFFFFF) == 1)
  {
    Ptr v6 = (*a2)[2];
    return (atomic_uint *)((uint64_t (*)(Handle *))v6)(a2);
  }
  return result;
}

uint64_t CA::Render::Animation::was_removed(uint64_t this, Handle *a2)
{
  int v2 = *(_DWORD *)(this + 12);
  if ((v2 & 0x1000) == 0)
  {
    if ((v2 & 0x2000) == 0) {
      return this;
    }
LABEL_5:
    a2[12] = (Handle)((unint64_t)a2[12] | 0x10);
    return this;
  }
  a2[12] = (Handle)((unint64_t)a2[12] | 8);
  if ((*(_DWORD *)(this + 12) & 0x2000) != 0) {
    goto LABEL_5;
  }
  return this;
}

void CA::Render::KeyframeAnimation::~KeyframeAnimation(CA::Render::KeyframeAnimation *this, void **a2)
{
  CA::Render::KeyframeAnimation::~KeyframeAnimation(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  atomic_uint *v4;
  atomic_uint *v5;
  atomic_uint *v6;
  atomic_uint *v7;
  atomic_uint *v8;
  atomic_uint *v9;
  uint64_t vars8;

  *(void *)this = &unk_1ED02E758;
  uint64_t v3 = (atomic_uint *)*((void *)this + 21);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 20);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  int v5 = (atomic_uint *)*((void *)this + 19);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  Ptr v6 = (atomic_uint *)*((void *)this + 17);
  if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
  }
  unint64_t v7 = (atomic_uint *)*((void *)this + 16);
  if (v7 && atomic_fetch_add(v7 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v7 + 16))(v7);
  }
  unint64_t v8 = (atomic_uint *)*((void *)this + 15);
  if (v8 && atomic_fetch_add(v8 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v8 + 16))(v8);
  }
  CFHashCode v9 = (atomic_uint *)*((void *)this + 14);
  if (v9 && atomic_fetch_add(v9 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v9 + 16))(v9);
  }
  --dword_1EB2ADE34;

  CA::Render::PropertyAnimation::~PropertyAnimation((CA::Render **)this, a2);
}

void CA::Render::SpringAnimation::~SpringAnimation(CA::Render::SpringAnimation *this, void **a2)
{
  --dword_1EB2ADE88;
  *(void *)this = &unk_1ED02DF68;
  uint64_t v3 = (atomic_uint *)*((void *)this + 16);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 15);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  int v5 = (atomic_uint *)*((void *)this + 14);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  CA::Render::PropertyAnimation::~PropertyAnimation((CA::Render **)this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  atomic_uint *v4;
  atomic_uint *v5;
  uint64_t vars8;

  --dword_1EB2ADE88;
  *(void *)this = &unk_1ED02DF68;
  uint64_t v3 = (atomic_uint *)*((void *)this + 16);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 15);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  int v5 = (atomic_uint *)*((void *)this + 14);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }

  CA::Render::PropertyAnimation::~PropertyAnimation((CA::Render **)this, a2);
}

void CA::Render::BasicAnimation::~BasicAnimation(CA::Render::BasicAnimation *this, void **a2)
{
  --dword_1EB2ADDDC;
  *(void *)this = &unk_1ED02DF68;
  uint64_t v3 = (atomic_uint *)*((void *)this + 16);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 15);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  int v5 = (atomic_uint *)*((void *)this + 14);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  CA::Render::PropertyAnimation::~PropertyAnimation((CA::Render **)this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  atomic_uint *v4;
  atomic_uint *v5;
  uint64_t vars8;

  --dword_1EB2ADDDC;
  *(void *)this = &unk_1ED02DF68;
  uint64_t v3 = (atomic_uint *)*((void *)this + 16);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 15);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  int v5 = (atomic_uint *)*((void *)this + 14);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }

  CA::Render::PropertyAnimation::~PropertyAnimation((CA::Render **)this, a2);
}

void CA::Render::Animation::~Animation(CA::Render::Animation *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED030030;
  uint64_t v3 = (const void *)*((void *)this + 7);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 6);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  int v5 = (atomic_uint *)*((void *)this + 5);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

{
  malloc_zone_t *malloc_zone;
  uint64_t vars8;

  CA::Render::Animation::~Animation(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::Render::PropertyAnimation::~PropertyAnimation(CA::Render **this, void **a2)
{
  *this = (CA::Render *)&unk_1ED02E820;
  CA::Render::key_path_free(this[12], a2);
  uint64_t v4 = (atomic_uint *)this[13];
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }

  CA::Render::Animation::~Animation((CA::Render::Animation *)this, v3);
}

{
  malloc_zone_t *malloc_zone;
  uint64_t vars8;

  CA::Render::PropertyAnimation::~PropertyAnimation(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

uint64_t CASRegisterClient(mach_port_name_t a1, const audit_token_t *a2, mach_port_name_t a3, mach_port_name_t a4, char a5, const UInt8 *a6, unsigned int a7, _DWORD *a8, _DWORD *a9, pid_t *a10, CA::Render::Server *a11)
{
  mach_port_name_t v16 = a2;
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  CFIndex v18 = a7;
  __int16 v19 = CA::Render::Server::audit_token_cache_lookup(a11, a2);
  uint64_t v21 = (ipc_space_t *)MEMORY[0x1E4F14960];
  mach_vm_size_t size = v18;
  if ((v19 & 0x2000) != 0)
  {
    uint64_t v28 = 4213784577;
    if (a4) {
LABEL_28:
    }
      mach_port_deallocate(*v21, a4);
  }
  else
  {
    __int16 v43 = a6;
    if (a7
      && (CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF98],
          (CFDataRef v23 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF98], a6, v18)) != 0))
    {
      CFDataRef v24 = v23;
      CFPropertyListRef v25 = CFPropertyListCreateWithData(v22, v23, 0, 0, 0);
      uint64_t v26 = v25;
      if (v25)
      {
        CFTypeID v27 = CFGetTypeID(v25);
        if (v27 != CFDictionaryGetTypeID())
        {
          CFRelease(v26);
          uint64_t v26 = 0;
        }
      }
      CFRelease(v24);
    }
    else
    {
      uint64_t v26 = 0;
    }
    unsigned int v29 = CA::Render::Server::audit_token_cache_lookup(a11, v20);
    unsigned int v30 = *((_DWORD *)a11 + 5);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    int v32 = (CA::Render::Context *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x2E8uLL, 0x743898A5uLL);
    int v33 = v32;
    if (v32)
    {
      BOOL v34 = CA::Render::Context::Context(v32, (const __CFDictionary *)v26, (v29 >> 9) & 4 | (v29 >> 1) & 3, a5 & 8, v30);
      *((_DWORD *)v33 + 63) = a1;
      *((_DWORD *)v33 + 64) = v16;
      *((_DWORD *)v33 + 65) = a3;
      *((_DWORD *)v33 + 66) = a4;
      mach_port_t previous = 0;
      ipc_space_t v35 = *v21;
      mach_port_t v36 = CA::Render::Server::notify_port(v34);
      mach_port_request_notification(v35, v16, 72, 0, v36, 0x15u, &previous);
      if (previous) {
        mach_port_deallocate(*v21, previous);
      }
      *((_DWORD *)v33 + 3) |= 0x1401000u;
      CA::Render::Context::set_display_mask(v33, *((_DWORD *)v33 + 152));
      CA::Render::Context::set_display_id(v33, *((_DWORD *)v33 + 153));
      task_name_t v37 = *((_DWORD *)v33 + 63);
      if (v37)
      {
        mach_msg_type_number_t task_info_outCnt = 8;
        task_info(v37, 0xFu, (task_info_t)v33 + 49, &task_info_outCnt);
        atomic_store(*((_DWORD *)v33 + 54), (unsigned int *)v33 + 57);
        if ((CA::Render::Server::audit_token_cache_lookup((CA::Render::Context *)((char *)v33 + 196), v38) & 0x400) != 0) {
          LOWORD(v40) = 256;
        }
        else {
          unsigned int v40 = (CA::Render::Server::audit_token_cache_lookup((CA::Render::Context *)((char *)v33 + 196), v39) >> 9) & 0x100;
        }
        *((_WORD *)v33 + 276) = *((_WORD *)v33 + 276) & 0xFEFF | v40;
        *((_WORD *)v33 + 276) = *((_WORD *)v33 + 276) & 0xFDFF | (CA::Render::Server::audit_token_cache_lookup((CA::Render::Context *)((char *)v33 + 196), v39) >> 3) & 0x200;
        *((_WORD *)v33 + 276) = *((_WORD *)v33 + 276) & 0xFBFF | ((unsigned __int16)CA::Render::Server::audit_token_cache_lookup((CA::Render::Context *)((char *)v33 + 196), v41) << 8) & 0x400;
      }
      *a8 = CA::Render::Context::server_port((mach_port_name_t *)v33);
      *a9 = *((_DWORD *)v33 + 4);
      *a10 = getpid();
      if (atomic_fetch_add((atomic_uint *volatile)v33 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(CA::Render::Context *))(*(void *)v33 + 16))(v33);
      }
      a1 = 0;
      mach_port_name_t v16 = 0;
      a3 = 0;
      a4 = 0;
    }
    if (v26) {
      CFRelease(v26);
    }
    if (v33) {
      uint64_t v28 = 0;
    }
    else {
      uint64_t v28 = 5;
    }
    a6 = v43;
    if (a4) {
      goto LABEL_28;
    }
  }
  if (a3) {
    mach_port_deallocate(*v21, a3);
  }
  if (v16) {
    mach_port_deallocate(*v21, v16);
  }
  if (a1) {
    mach_port_deallocate(*v21, a1);
  }
  mach_vm_deallocate(*v21, (mach_vm_address_t)a6, size);
  return v28;
}

uint64_t CA::Render::Server::audit_token_cache_lookup(CA::Render::Server *this, const audit_token_t *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Server::_audit_token_lock);
  if (CA::Render::Server::_audit_token_cache)
  {
    unint64_t v3 = 0;
    uint64_t v4 = (uint64_t *)CA::Render::Server::_audit_token_cache;
    do
    {
      uint64_t v5 = *v4;
      if (*(_DWORD *)(*v4 + 20) == *((_DWORD *)this + 5))
      {
        BOOL v6 = *(void *)v5 == *(void *)this && *(void *)(v5 + 8) == *((void *)this + 1);
        BOOL v7 = v6 && *(void *)(v5 + 16) == *((void *)this + 2);
        if (v7 && *(void *)(v5 + 24) == *((void *)this + 3))
        {
          CFDataRef v23 = x_list_remove((void *)CA::Render::Server::_audit_token_cache, *v4);
          CA::Render::Server::_audit_token_cache = (uint64_t)v23;
          goto LABEL_35;
        }
      }
      uint64_t v4 = (uint64_t *)v4[1];
      ++v3;
    }
    while (v4);
    if (v3 < 0x10) {
      goto LABEL_19;
    }
    uint64_t v9 = CA::Render::Server::_audit_token_cache;
    do
    {
      CFHashCode v10 = (uint64_t *)v9;
      uint64_t v9 = *(void *)(v9 + 8);
    }
    while (v9);
    uint64_t v5 = *v10;
    CA::Render::Server::_audit_token_cache = (uint64_t)x_list_remove((void *)CA::Render::Server::_audit_token_cache, *v10);
  }
  else
  {
LABEL_19:
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v5 = (uint64_t)malloc_type_zone_malloc(malloc_zone, 0x24uLL, 0x8BB15036uLL);
  }
  long long v12 = *((_OWORD *)this + 1);
  *(_OWORD *)uint64_t v5 = *(_OWORD *)this;
  *(_OWORD *)(v5 + 16) = v12;
  long long v13 = *((_OWORD *)this + 1);
  *(_OWORD *)v28.val = *(_OWORD *)this;
  *(_OWORD *)&v28.val[4] = v13;
  SecTaskRef v14 = SecTaskCreateWithAuditToken(0, &v28);
  if (v14)
  {
    uint64_t v15 = v14;
    int v16 = 0;
    for (uint64_t i = 0; i != 17; ++i)
    {
      CFTypeRef v18 = SecTaskCopyValueForEntitlement(v15, CA::Render::Server::entitlements_for_audit_token(audit_token_t const&)::str[i], 0);
      if (v18)
      {
        __int16 v19 = v18;
        v16 |= CA_CFBoolValue(v18) << i;
        CFRelease(v19);
      }
    }
    unint64_t v20 = 0;
    BOOL v21 = 1;
    while (1)
    {
      CFTypeRef v22 = SecTaskCopyValueForEntitlement(v15, CA::Render::Server::has_restricted_client_entitlement(__SecTask *)::entitlements[v20], 0);
      if (v22) {
        break;
      }
      BOOL v21 = v20++ < 2;
      if (v20 == 3) {
        goto LABEL_32;
      }
    }
    CFRelease(v22);
    if (v21) {
      v16 |= 0x20000u;
    }
LABEL_32:
    CFRelease(v15);
  }
  else
  {
    int v16 = 0;
  }
  *(_DWORD *)(v5 + 32) = v16;
  CFDataRef v23 = (void *)CA::Render::Server::_audit_token_cache;
LABEL_35:
  CFDataRef v24 = (malloc_zone_t *)get_malloc_zone();
  CFPropertyListRef v25 = malloc_type_zone_malloc(v24, 0x10uLL, 0x8BB15036uLL);
  *CFPropertyListRef v25 = v5;
  v25[1] = v23;
  CA::Render::Server::_audit_token_cache = (uint64_t)v25;
  uint64_t v26 = *(unsigned int *)(v5 + 32);
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_audit_token_lock);
  return v26;
}

void *x_list_remove(void *result, uint64_t a2)
{
  BOOL v6 = result;
  if (result)
  {
    unint64_t v3 = result;
    uint64_t v4 = &v6;
    do
    {
      if (*v3 == a2)
      {
        void *v4 = v3[1];
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, v3);
      }
      else
      {
        uint64_t v4 = v3 + 1;
      }
      unint64_t v3 = (void *)*v4;
    }
    while (*v4);
    return v6;
  }
  return result;
}

void CA::Render::LayerHost::commit_layer(CA::Render::LayerHost *this, CA::Render::Context *a2, CA::Render::Layer *a3, CA::Render::Handle *a4, int a5)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (atomic_uint *)*((void *)this + 3);
  if (v8 != (atomic_uint *)a4)
  {
    uint64_t v9 = a4;
    if (v8 && atomic_fetch_add(v8 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *, CA::Render::Context *, CA::Render::Layer *))(*(void *)v8 + 16))(v8, a2, a3);
    }
    if (v9)
    {
      CFHashCode v10 = (atomic_uint *)((char *)v9 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)v9 + 2, 1u))
      {
        uint64_t v9 = 0;
        atomic_fetch_add(v10, 0xFFFFFFFF);
      }
    }
    *((void *)this + 3) = v9;
  }
  if ((a5 & 0x200000) != 0)
  {
    CA::Render::LayerHost::retain_hosted_context((CA::Render::LayerHost *)v13, this, (uint64_t)a2, 0);
    uint64_t v11 = v13[0];
    if (v13[0] && atomic_fetch_add((atomic_uint *volatile)(v13[0] + 8), 0xFFFFFFFF) == 1)
    {
      long long v12 = *(void (**)(void))(*(void *)v11 + 16);
      v12();
    }
  }
  else
  {
    CA::Render::LayerHost::invalidate(this);
  }
}

void CA::Render::LayerHost::retain_hosted_context(CA::Render::LayerHost *this, CA::Render::Context *a2, uint64_t a3, int a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  unsigned int v41 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
  if (a4)
  {
    uint64_t v8 = *((void *)a2 + 9);
    if (v8)
    {
      uint64_t v9 = (atomic_uint *)(v8 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v8 + 8), 1u))
      {
        uint64_t v8 = 0;
        atomic_fetch_add(v9, 0xFFFFFFFF);
      }
    }
    goto LABEL_9;
  }
  uint64_t v10 = *((void *)a2 + 10);
  if (!v10)
  {
    *((void *)a2 + 10) = a3;
    uint64_t v11 = *(void *)(a3 + 424);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    long long v13 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    *long long v13 = a2;
    v13[1] = v11;
    *(void *)(a3 + 424) = v13;
    uint64_t v10 = *((void *)a2 + 10);
  }
  if (v10 != a3)
  {
    uint64_t v8 = 0;
LABEL_9:
    *(void *)this = v8;
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
    return;
  }
  uint64_t v14 = *((void *)a2 + 9);
  if (v14)
  {
    uint64_t v15 = (atomic_uint *)(v14 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v14 + 8), 1u))
    {
      uint64_t v14 = 0;
      atomic_fetch_add(v15, 0xFFFFFFFF);
    }
    goto LABEL_15;
  }
  __int16 v19 = (CA::Render::Context *)*((unsigned int *)a2 + 4);
  if (v19)
  {
    if (a3)
    {
      uint64_t v20 = a3;
      while (v19 != *(_DWORD *)(v20 + 16))
      {
        uint64_t v21 = *(void *)(v20 + 416);
        if (v21)
        {
          uint64_t v20 = *(void *)(v21 + 80);
          if (v20) {
            continue;
          }
        }
        goto LABEL_38;
      }
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        CFTypeRef v22 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          int v23 = *((_DWORD *)a2 + 4);
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v23;
          _os_log_impl(&dword_184668000, v22, OS_LOG_TYPE_DEFAULT, "CoreAnimation: LayerHost trying to host itself or one of its ancestors (context id %d)\n", buf, 8u);
        }
      }
      __int16 v19 = 0;
      *((_DWORD *)a2 + 4) = 0;
    }
LABEL_38:
    uint64_t v24 = CA::Render::Context::context_by_id(v19);
    uint64_t v14 = v24;
    if (!v24) {
      goto LABEL_15;
    }
    CFPropertyListRef v25 = *(void **)(v24 + 416);
    if (v25)
    {
      uint64_t v26 = v25[10];
      *(void *)(v26 + 424) = x_list_remove(*(void **)(v26 + 424), *(void *)(v24 + 416));
      *(void *)(v14 + 416) = 0;
      v25[9] = 0;
      v25[10] = 0;
      *(_DWORD *)(v26 + 12) |= 0x2000u;
      X::Ref<CA::Render::Texture>::operator=((atomic_uint **)&v41, (atomic_uint *)v14);
      uint64_t v27 = v25[4];
      v25[4] = 0;
      *((void *)a2 + 9) = v14;
      *(void *)long long buf = v27;
      if ((*((unsigned char *)a2 + 13) & 4) == 0) {
        goto LABEL_58;
      }
      if (v27)
      {
        X::Ref<CA::Render::AsynchronousState>::operator=((atomic_uint **)a2 + 4, (atomic_uint **)buf);
LABEL_57:
        uint64_t v37 = *((void *)a2 + 4);
        *(unsigned char *)(v37 + 21) = (*((_DWORD *)a2 + 3) & 0x800) != 0;
        *(void *)(v37 + 64) = *((void *)a2 + 8);
        std::vector<unsigned long long>::__move_assign(v37 + 40, (__n128 *)((char *)a2 + 40));
        *((void *)a2 + 6) = *((void *)a2 + 5);
LABEL_58:
        *(void *)(v14 + 416) = a2;
        if (*(_WORD *)(*((void *)a2 + 10) + 552)) {
          uint64_t v38 = (const CA::Render::Context *)*((void *)a2 + 10);
        }
        else {
          uint64_t v38 = 0;
        }
        CA::Render::Context::update_backdrop_namespaces_locked(v14, v38);
        CA::Render::Context::set_visible_locked((CA::Render::Context *)v14, *(_DWORD *)(a3 + 352) != 0);
        atomic_fetch_add(CA::Render::LayerHost::_seed, 1u);
        uint64_t v39 = *(void *)buf;
        if (*(void *)buf && atomic_fetch_add((atomic_uint *volatile)(*(void *)buf + 8), 0xFFFFFFFF) == 1) {
          (*(void (**)(uint64_t))(*(void *)v39 + 16))(v39);
        }
        goto LABEL_15;
      }
    }
    else
    {
      X::Ref<CA::Render::Texture>::operator=((atomic_uint **)&v41, (atomic_uint *)v24);
      *((void *)a2 + 9) = v14;
      *(void *)long long buf = 0;
      if ((*((unsigned char *)a2 + 13) & 4) == 0) {
        goto LABEL_58;
      }
    }
    audit_token_t v28 = (malloc_zone_t *)get_malloc_zone();
    uint64_t v29 = malloc_type_zone_malloc(v28, 0x48uLL, 0x8BB15036uLL);
    if (v29)
    {
      int v31 = (atomic_uint *)*((void *)a2 + 3);
      if (v31)
      {
        int v32 = v31 + 2;
        if (!atomic_fetch_add(v31 + 2, 1u))
        {
          int v31 = 0;
          atomic_fetch_add(v32, 0xFFFFFFFF);
        }
      }
      unsigned int v40 = v31;
      v33.n128_f64[0] = CA::Render::AsynchronousState::AsynchronousState((uint64_t)v29, (uint64_t *)&v40, *((_DWORD *)a2 + 4));
      BOOL v34 = (atomic_uint *)*((void *)a2 + 4);
      *((void *)a2 + 4) = v35;
      if (v34 && atomic_fetch_add(v34 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *, double))(*(void *)v34 + 16))(v34, v33.n128_f64[0]);
      }
      if (v31 && atomic_fetch_add(v31 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *, __n128))(*(void *)v31 + 16))(v31, v33);
      }
    }
    else
    {
      mach_port_t v36 = (atomic_uint *)*((void *)a2 + 4);
      *((void *)a2 + 4) = 0;
      if (v36 && atomic_fetch_add(v36 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *, __n128))(*(void *)v36 + 16))(v36, v30);
      }
    }
    goto LABEL_57;
  }
  uint64_t v14 = 0;
LABEL_15:
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
  if (v41) {
    CA::Render::invalidate_context(v41, v16);
  }
  if (v14)
  {
    CA::Render::Context::set_display_mask((CA::Render::Context *)v14, *(_DWORD *)(a3 + 608));
    CA::Render::Context::set_display_id((CA::Render::Context *)v14, *(_DWORD *)(a3 + 612));
    uint64_t v17 = *(void *)(a3 + 600);
    if (*(void *)(v14 + 600) != v17)
    {
      *(void *)(v14 + 600) = v17;
      if (*(_DWORD *)(v14 + 256)) {
        *(_DWORD *)(v14 + 12) |= 0x400000u;
      }
    }
  }
  *(void *)this = v14;
  CFTypeRef v18 = v41;
  if (v41 && atomic_fetch_add((atomic_uint *volatile)v41 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(CA::Render *))(*(void *)v18 + 16))(v18);
  }
}

void CA::Render::Context::set_display_mask(CA::Render::Context *this, int a2)
{
  mach_msg_return_t v4;
  mach_msg_header_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;

  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 152) != a2)
  {
    *((_DWORD *)this + 152) = a2;
    if (*((_DWORD *)this + 64)) {
      *((_DWORD *)this + 3) |= 0x1000u;
    }
  }
  if ((*((unsigned char *)this + 13) & 0x10) != 0)
  {
    mach_port_t v3 = *((_DWORD *)this + 64);
    BOOL v6 = *MEMORY[0x1E4F14068];
    BOOL v7 = a2;
    *(void *)&v5.uint64_t msgh_bits = 19;
    v5.uint64_t msgh_voucher_port = 0;
    v5.mach_msg_id_t msgh_id = 40400;
    v5.mach_port_t msgh_remote_port = v3;
    v5.mach_port_t msgh_local_port = 0;
    if (MEMORY[0x1E4F14B18]) {
      voucher_mach_msg_set(&v5);
    }
    uint64_t v4 = mach_msg(&v5, 17, 0x24u, 0, 0, 0, 0);
    if ((v4 - 268435459) > 1)
    {
      if (!v4) {
        *((_DWORD *)this + 3) &= ~0x1000u;
      }
    }
    else
    {
      if ((v5.msgh_bits & 0x1F00) == 0x1100) {
        mach_port_deallocate(*MEMORY[0x1E4F14960], v5.msgh_local_port);
      }
      mach_msg_destroy(&v5);
    }
  }
}

void CA::Render::Context::set_display_id(CA::Render::Context *this, int a2)
{
  mach_msg_return_t v4;
  mach_msg_header_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;

  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 153) != a2)
  {
    *((_DWORD *)this + 153) = a2;
    if (*((_DWORD *)this + 64)) {
      *((_DWORD *)this + 3) |= 0x1000000u;
    }
  }
  if (*((unsigned char *)this + 15))
  {
    mach_port_t v3 = *((_DWORD *)this + 64);
    BOOL v6 = *MEMORY[0x1E4F14068];
    BOOL v7 = a2;
    *(void *)&v5.uint64_t msgh_bits = 19;
    v5.uint64_t msgh_voucher_port = 0;
    v5.mach_msg_id_t msgh_id = 40401;
    v5.mach_port_t msgh_remote_port = v3;
    v5.mach_port_t msgh_local_port = 0;
    if (MEMORY[0x1E4F14B18]) {
      voucher_mach_msg_set(&v5);
    }
    uint64_t v4 = mach_msg(&v5, 17, 0x24u, 0, 0, 0, 0);
    if ((v4 - 268435459) > 1)
    {
      if (!v4) {
        *((_DWORD *)this + 3) &= ~0x1000000u;
      }
    }
    else
    {
      if ((v5.msgh_bits & 0x1F00) == 0x1100) {
        mach_port_deallocate(*MEMORY[0x1E4F14960], v5.msgh_local_port);
      }
      mach_msg_destroy(&v5);
    }
  }
}

uint64_t CA::Render::Context::context_by_id(CA::Render::Context *this)
{
  uint64_t v1 = 0;
  if (this && CA::Render::Context::_context_table)
  {
    unsigned int v2 = this;
    os_unfair_lock_lock(&CA::Render::Context::_context_lock);
    uint64_t v3 = x_hash_table_lookup(CA::Render::Context::_context_table, v2, 0);
    uint64_t v1 = v3;
    if (v3)
    {
      if ((*(unsigned char *)(v3 + 13) & 4) != 0)
      {
        uint64_t v1 = 0;
      }
      else if (!atomic_fetch_add((atomic_uint *volatile)(v3 + 8), 1u))
      {
        uint64_t v1 = 0;
        atomic_fetch_add((atomic_uint *volatile)(v3 + 8), 0xFFFFFFFF);
      }
    }
    os_unfair_lock_unlock(&CA::Render::Context::_context_lock);
  }
  return v1;
}

atomic_uint **X::Ref<CA::Render::Texture>::operator=(atomic_uint **a1, atomic_uint *a2)
{
  uint64_t v3 = *a1;
  if (v3 != a2)
  {
    uint64_t v4 = a2;
    if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
    }
    if (v4)
    {
      uint64_t v5 = v4 + 2;
      if (!atomic_fetch_add(v4 + 2, 1u))
      {
        uint64_t v4 = 0;
        atomic_fetch_add(v5, 0xFFFFFFFF);
      }
    }
    *a1 = v4;
  }
  return a1;
}

uint64_t CA::Render::Context::update_backdrop_namespaces_locked(uint64_t this, const CA::Render::Context *a2)
{
  if (*(_WORD *)(this + 552)) {
    a2 = (const CA::Render::Context *)this;
  }
  *(void *)(this + 544) = a2;
  uint64_t v3 = *(void **)(this + 424);
  if (v3)
  {
    uint64_t v4 = this;
    do
    {
      this = *(void *)(*v3 + 72);
      if (this) {
        this = CA::Render::Context::update_backdrop_namespaces_locked((CA::Render::Context *)this, *(const CA::Render::Context **)(v4 + 544));
      }
      uint64_t v3 = (void *)v3[1];
    }
    while (v3);
  }
  return this;
}

void CA::Render::Context::set_visible_locked(CA::Render::Context *this, int a2)
{
  if (*((_DWORD *)this + 88) != a2)
  {
    *((_DWORD *)this + 88) = a2;
    uint64_t v4 = (uint64_t *)*((void *)this + 53);
    if (v4)
    {
      uint64_t v5 = 0;
      do
      {
        uint64_t v6 = *v4;
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        uint64_t v8 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
        *uint64_t v8 = v6;
        v8[1] = v5;
        uint64_t v4 = (uint64_t *)v4[1];
        uint64_t v5 = v8;
      }
      while (v4);
    }
    else
    {
      uint64_t v8 = 0;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Context::_image_queues_lock);
    uint64_t v10 = (CA::Render::ImageQueue **)*((void *)this + 45);
    uint64_t v9 = (CA::Render::ImageQueue **)*((void *)this + 46);
    while (v10 != v9)
    {
      uint64_t v11 = *v10++;
      CA::Render::ImageQueue::set_visible(v11, a2);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Context::_image_queues_lock);
    if (v8)
    {
      do
      {
        long long v12 = *(CA::Render::Context **)(*v8 + 72);
        if (v12) {
          CA::Render::Context::set_visible_locked(v12, a2);
        }
        long long v13 = (void *)v8[1];
        uint64_t v14 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v14, v8);
        uint64_t v8 = v13;
      }
      while (v13);
    }
  }
}

uint64_t CA::Render::invalidate_context(CA::Render *this, CA::Render::Context *a2)
{
  uint64_t v3 = (pthread_mutex_t *)((char *)this + 72);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 72));
  uint64_t v4 = (int32x2_t *)CA::Render::Context::root_layer_handle(this);
  if (v4)
  {
    uint64_t v6 = v4;
    CA::Render::Context::invalidate(this, v4 + 14, v5);
    *(void *)&v6[12] |= 0xBuLL;
  }

  return pthread_mutex_unlock(v3);
}

void CA::Render::Update::add_context(CA::Render::Update *this, CA::Render::Context *a2)
{
  uint64_t v4 = CA::Render::Context::root_layer_handle(a2);
  if (v4) {
    uint64_t v5 = *(CA::Render::Layer **)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }

  CA::Render::Update::add_context(this, a2, v5, 0);
}

uint64_t CA::Render::Context::root_layer_handle(CA::Render::Context *this)
{
  unint64_t v1 = *((void *)this + 34);
  if (!v1) {
    return 0;
  }
  uint64_t result = *((void *)this + 35);
  if (result) {
    return result;
  }
  uint64_t v5 = CA::Render::Context::lookup_handle(this, v1, 0, 0, 0);
  uint64_t v6 = (atomic_uint *)*((void *)this + 35);
  if (v6 != (atomic_uint *)v5)
  {
    if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
    }
    if (v5)
    {
      BOOL v7 = (atomic_uint *)(v5 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v5 + 8), 1u))
      {
        uint64_t v5 = 0;
        atomic_fetch_add(v7, 0xFFFFFFFF);
      }
    }
    *((void *)this + 35) = v5;
  }
  if (!v5) {
    return 0;
  }
  *(_DWORD *)(v5 + 12) |= 0x100u;
  CA::Render::Handle::update_container_state(v5, v4);
  return *((void *)this + 35);
}

CA::Render::Context *CA::Render::Context::Context(CA::Render::Context *this, const __CFDictionary *a2, char a3, int a4, unsigned int a5)
{
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = 10;
  ++dword_1EB2ADDF0;
  *(void *)this = &unk_1ED02F880;
  *((_DWORD *)this + 13) = 0;
  *((void *)this + 18) = 0xF00000010;
  *((_DWORD *)this + 38) = 4;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  *((void *)this + 17) = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x80uLL, 0x743898A5uLL);
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *(void *)&long long v11 = -1;
  *((void *)&v11 + 1) = -1;
  *(_OWORD *)((char *)this + 196) = v11;
  *(_OWORD *)((char *)this + 212) = v11;
  *((void *)this + 35) = 0;
  *(void *)((char *)this + 236) = 0;
  *(void *)((char *)this + 228) = 0;
  *((_DWORD *)this + 61) = 0;
  *((_DWORD *)this + 77) = 1065353216;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *((_DWORD *)this + 86) = 1065353216;
  *((_DWORD *)this + 88) = 0;
  *((_DWORD *)this + 110) = 0;
  *((_DWORD *)this + 120) = 0;
  *((void *)this + 61) = 0;
  *((void *)this + 62) = 0;
  *((void *)this + 63) = 0;
  *((void *)this + 66) = 0;
  *((_DWORD *)this + 158) = 0;
  *((_OWORD *)this + 40) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *((void *)this + 51) = 0;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *((_DWORD *)this + 168) = 1065353216;
  *((_DWORD *)this + 170) = 0;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *((void *)this + 90) = 0;
  *((_DWORD *)this + 182) = 1065353216;
  uint64_t v12 = mach_absolute_time();
  *((double *)this + 58) = CATimeWithHostTime(v12);
  *((void *)this + 57) = 0x7FF0000000000000;
  *((void *)this + 64) = 0x7FF0000000000000;
  *((void *)this + 59) = -1;
  while (1)
  {
    do
    {
      long long v13 = (CA::Render::Context *)arc4random();
      *((_DWORD *)this + 4) = v13;
    }
    while (!v13);
    uint64_t v14 = (atomic_uint *)CA::Render::Context::context_by_id(v13);
    if (!v14) {
      break;
    }
    if (atomic_fetch_add(v14 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v14 + 16))(v14);
    }
  }
  x_thread_init_mutex((pthread_mutex_t *)((char *)this + 72), 1);
  if (a2)
  {
    *((void *)this + 4) = CFRetain(a2);
    Value = CFDictionaryGetValue(a2, @"disableGroupOpacity");
    if (Value && CA_CFBoolValue(Value)) {
      *((void *)this + 3) |= 0x80uLL;
    }
    int v16 = CFDictionaryGetValue(a2, @"disableEdgeAA");
    if (v16 && CA_CFBoolValue(v16)) {
      *((void *)this + 3) |= 0x100uLL;
    }
    CFStringRef v17 = (const __CFString *)CFDictionaryGetValue(a2, @"name");
    if (v17)
    {
      CFStringRef v18 = v17;
      CFTypeID v19 = CFGetTypeID(v17);
      if (v19 == CFStringGetTypeID())
      {
        uint64_t v21 = CA::Render::String::new_string(v18, v20);
        CFTypeRef v22 = (atomic_uint *)*((void *)this + 30);
        *((void *)this + 30) = v21;
        if (v22)
        {
          if (atomic_fetch_add(v22 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v22 + 16))(v22);
          }
        }
      }
    }
    int v23 = CFDictionaryGetValue(a2, @"backdropNamespace");
    if (v23 && CA_CFBoolValue(v23)) {
      *((_WORD *)this + 276) |= 1u;
    }
    uint64_t v24 = CFDictionaryGetValue(a2, @"ignoresHitTest");
    if (v24 && CA_CFBoolValue(v24)) {
      *((void *)this + 3) |= 0x200uLL;
    }
    CFPropertyListRef v25 = CFDictionaryGetValue(a2, @"displayable");
    if (v25)
    {
      BOOL v26 = CA_CFBoolValue(v25);
      if ((a3 & 1) != 0 && v26)
      {
        *((_DWORD *)this + 3) |= 0x4000u;
        os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
        os_unfair_lock_lock(&CA::Render::Context::_context_lock);
        CA::Render::Context::set_visible_locked(this, 1);
        os_unfair_lock_unlock(&CA::Render::Context::_context_lock);
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
      }
    }
    uint64_t v27 = CFDictionaryGetValue(a2, @"secure");
    if (v27)
    {
      BOOL v28 = CA_CFBoolValue(v27);
      if ((a3 & 2) != 0 && v28) {
        *((_WORD *)this + 276) |= 4u;
      }
    }
    uint64_t v29 = CFDictionaryGetValue(a2, @"allowsOcclusionDetectionOverride");
    if (v29)
    {
      BOOL v30 = CA_CFBoolValue(v29);
      if ((a3 & 4) != 0 && v30) {
        *((_WORD *)this + 276) |= 8u;
      }
    }
    int v31 = CFDictionaryGetValue(a2, @"startSecureSuperlayersValidation");
    if (v31 && CA_CFBoolValue(v31)) {
      *((_WORD *)this + 276) |= 0x10u;
    }
    int v32 = CFDictionaryGetValue(a2, @"stopSecureSuperlayersValidation");
    if (v32)
    {
      BOOL v33 = CA_CFBoolValue(v32);
      if ((a3 & 2) != 0 && v33) {
        *((_WORD *)this + 276) |= 0x20u;
      }
    }
  }
  atomic_store(a5, (unsigned int *)this + 57);
  *((_DWORD *)this + 3) |= a4 << 8;
  *((void *)this + 72) = 1;
  *((void *)this + 71) = 0;
  *((_WORD *)this + 276) &= ~2u;
  os_unfair_lock_lock(&CA::Render::Context::_context_lock);
  BOOL v34 = (int *)CA::Render::Context::_context_table;
  if (!CA::Render::Context::_context_table)
  {
    CA::Render::Context::_context_table = (uint64_t)x_hash_table_new_(0, 0, 0, 0, 0, 0);
    CA::Render::add_observer(0x30u, 0, (uint64_t)CA::Render::Context::get_debug_log, CA::Render::Context::_context_table, 0);
    BOOL v34 = (int *)CA::Render::Context::_context_table;
  }
  uint64_t v35 = *((unsigned int *)this + 4);
  mach_port_t v36 = this;
  if (!atomic_fetch_add((atomic_uint *volatile)this + 2, 1u))
  {
    mach_port_t v36 = 0;
    atomic_fetch_add((atomic_uint *volatile)this + 2, 0xFFFFFFFF);
  }
  hash_table_modify(v34, v35, (uint64_t)v36, 0);
  os_unfair_lock_unlock(&CA::Render::Context::_context_lock);
  CA::Render::post_notification(1u, (unint64_t)this, 0, 0);
  return this;
}

BOOL CA_CFBoolValue(const void *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFBooleanGetTypeID())
  {
    BOOL v3 = *MEMORY[0x1E4F1CFC8] == (void)a1;
  }
  else
  {
    if (v2 != CFNumberGetTypeID()) {
      return 0;
    }
    int valuePtr = 0;
    CFNumberGetValue((CFNumberRef)a1, kCFNumberIntType, &valuePtr);
    BOOL v3 = valuePtr == 0;
  }
  return !v3;
}

uint64_t CA::Render::Context::server_port(mach_port_name_t *this)
{
  os_unfair_lock_lock(&CA::Render::Context::_context_lock);
  CFTypeID v2 = this + 62;
  uint64_t v3 = this[62];
  if (!v3)
  {
    if ((*((unsigned char *)this + 13) & 4) != 0)
    {
      uint64_t v3 = 0;
    }
    else
    {
      uint64_t v4 = (ipc_space_t *)MEMORY[0x1E4F14960];
      mach_port_allocate(*MEMORY[0x1E4F14960], 1u, this + 62);
      inserted = (CA::Render::Server *)mach_port_insert_right(*v4, *v2, *v2, 0x14u);
      LODWORD(v4) = *v4;
      mach_port_name_t v6 = *v2;
      mach_port_name_t v7 = CA::Render::Server::port_set(inserted);
      mach_port_move_member((ipc_space_t)v4, v6, v7);
      uint64_t v8 = (int *)CA::Render::Context::_port_table;
      if (!CA::Render::Context::_port_table)
      {
        uint64_t v8 = (int *)x_hash_table_new_(0, 0, 0, 0, 0, 0);
        CA::Render::Context::_port_table = (uint64_t)v8;
      }
      hash_table_modify(v8, this[62], (uint64_t)this, 0);
      uint64_t v3 = this[62];
    }
  }
  os_unfair_lock_unlock(&CA::Render::Context::_context_lock);
  return v3;
}

void CAML::ObjCContext::warningv(id *this, const char *a2, char *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (((_BYTE)this[14] & 0x40) != 0)
  {
    [this[12] CAMLParser:this[10] formatWarningString:a2 arguments:a3 lineNumber:*(int *)(*((void *)this[1] + 7) + 52)];
    return;
  }
  x_log_begin();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    uint64_t v4 = x_log_category_api;
    if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*((void *)this[1] + 7) + 52);
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v19) = v5;
      _os_log_impl(&dword_184668000, v4, OS_LOG_TYPE_DEFAULT, "CAML warning:%d: ", buf, 8u);
    }
  }
  x_logv();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    mach_port_name_t v6 = x_log_category_api;
    if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_184668000, v6, OS_LOG_TYPE_DEFAULT, "\n", buf, 2u);
    }
  }
  CFStringRef v17 = (void **)x_stream_pop_(0);
  mach_port_name_t v7 = x_stream_get(v17);
  int v8 = 0;
  while (2)
  {
    uint64_t v9 = 0;
    uint64_t v10 = &v7[v8];
    int v11 = -1;
    while (1)
    {
      if (v10[v9] == 10)
      {
        int v11 = v9;
        goto LABEL_17;
      }
      if (!v10[v9]) {
        break;
      }
LABEL_17:
      ++v9;
      unsigned int v12 = 32512;
      if (v9 == 32512) {
        goto LABEL_18;
      }
    }
    unsigned int v12 = v9;
LABEL_18:
    if (v11 <= -1 || v10[v12] == 0) {
      int v14 = v12;
    }
    else {
      int v14 = v11 + 1;
    }
    if (v14 > 0)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v15 = x_log_category_api;
        if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315650;
          if (v8) {
            int v16 = "continued...\n";
          }
          else {
            int v16 = "";
          }
          CFTypeID v19 = v16;
          __int16 v20 = 1040;
          int v21 = v14;
          __int16 v22 = 2080;
          int v23 = &v7[v8];
          _os_log_impl(&dword_184668000, v15, OS_LOG_TYPE_DEFAULT, "%s%.*s", buf, 0x1Cu);
        }
      }
      v8 += v14;
      continue;
    }
    break;
  }
  x_log_end_free_(v17);
}

void x_log_()
{
}

void x_logv()
{
  char v0 = MEMORY[0x1F4188790]();
  CFTypeID v2 = v1;
  char v3 = v0;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  va_list v13 = v4;
  if (x_log_once != -1) {
    dispatch_once_f(&x_log_once, 0, (dispatch_function_t)x_log_init);
  }
  if (x_log_stream_slot)
  {
    int v5 = (uint64_t *)pthread_getspecific(x_log_stream_slot);
    if (v5)
    {
      mach_port_name_t v6 = v5;
      unsigned int v12 = 0;
      mach_port_name_t v7 = (char *)__str;
      int v8 = vsnprintf((char *)__str, 0x1000uLL, v2, v13);
      if ((v8 - 1) > 0xFFE)
      {
        int v8 = vasprintf(&v12, v2, v13);
        if (v8 < 1) {
          goto LABEL_18;
        }
        mach_port_name_t v7 = v12;
      }
      else
      {
        unsigned int v12 = (char *)__str;
      }
      x_stream_write(*v6, v7, v8);
LABEL_18:
      int v11 = v12;
      if (v12 == (char *)__str) {
        return;
      }
      goto LABEL_19;
    }
  }
  if (x_log_function)
  {
    *(void *)__str = v13;
    x_log_function(v2);
  }
  else if (x_log_file_handle)
  {
    *(void *)__str = v13;
    vfprintf((FILE *)x_log_file_handle, v2, v13);
  }
  unsigned int v12 = 0;
  vasprintf(&v12, v2, v13);
  uint64_t v9 = v12;
  if (v12)
  {
    os_log_type_t v10 = (0x20111100000uLL >> (8 * v3));
    if (os_log_type_enabled(MEMORY[0x1E4F14500], v10))
    {
      *(_DWORD *)__str = 136315138;
      *(void *)&__str[4] = v9;
      _os_log_impl(&dword_184668000, MEMORY[0x1E4F14500], v10, "%s", __str, 0xCu);
      uint64_t v9 = v12;
    }
    int v11 = v9;
LABEL_19:
    free(v11);
  }
}

char *x_stream_write(uint64_t a1, void *__src, size_t __n)
{
  mach_port_name_t v6 = *(char **)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)&v6[__n] < v7) {
    goto LABEL_7;
  }
  size_t v9 = v7 - *(void *)a1;
  BOOL v8 = v9 == 0;
  uint64_t v10 = 2 * v9;
  uint64_t v11 = 1024;
  if (!v8) {
    uint64_t v11 = v10;
  }
  do
  {
    size_t v12 = v11;
    size_t v13 = *(void *)a1 - (void)v6 + v11;
    v11 *= 2;
  }
  while (v13 < __n);
  uint64_t result = (char *)malloc_type_realloc(*(void **)a1, v12, 0xFFAC0152uLL);
  if (result)
  {
    uint64_t v15 = result;
    mach_port_name_t v6 = &result[*(void *)(a1 + 8) - *(void *)a1];
    *(void *)a1 = v15;
    *(void *)(a1 + 8) = v6;
    *(void *)(a1 + 16) = &v15[v12];
LABEL_7:
    uint64_t result = (char *)memcpy(v6, __src, __n);
    *(void *)(a1 + 8) += __n;
  }
  return result;
}

uint64_t x_log_begin()
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  unint64_t v1 = malloc_type_zone_malloc(malloc_zone, 0x18uLL, 0x8BB15036uLL);
  v1[1] = 0;
  v1[2] = 0;
  *unint64_t v1 = 0;

  return x_stream_push((uint64_t)v1);
}

uint64_t x_stream_push(uint64_t a1)
{
  if (x_log_stream_once != -1) {
    dispatch_once_f(&x_log_stream_once, 0, (dispatch_function_t)x_log_stream_init);
  }
  CFTypeID v2 = pthread_getspecific(x_log_stream_slot);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  va_list v4 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
  void *v4 = a1;
  v4[1] = v2;
  pthread_key_t v5 = x_log_stream_slot;

  return pthread_setspecific(v5, v4);
}

char *x_stream_get(void *a1)
{
  CFTypeID v2 = (char *)a1[1];
  unint64_t v3 = a1[2];
  if ((unint64_t)(v2 + 1) < v3) {
    goto LABEL_8;
  }
  va_list v4 = (unsigned char *)*a1;
  unint64_t v6 = v3 - *a1;
  BOOL v5 = v6 == 0;
  uint64_t v7 = 2 * v6;
  if (v5) {
    uint64_t v7 = 1024;
  }
  uint64_t v8 = v4 - v2;
  do
  {
    size_t v9 = v7;
    v7 *= 2;
  }
  while (!(v8 + v9));
  uint64_t result = (char *)malloc_type_realloc(v4, v9, 0xFFAC0152uLL);
  if (result)
  {
    CFTypeID v2 = &result[a1[1] - *a1];
    *a1 = result;
    a1[1] = v2;
    a1[2] = &result[v9];
LABEL_8:
    *CFTypeID v2 = 0;
    return (char *)*a1;
  }
  return result;
}

void x_log_end_free_(void **a1)
{
  if (a1)
  {
    CFTypeID v2 = *a1;
    if (v2)
    {
      free(v2);
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, a1);
  }
}

uint64_t x_stream_pop_(uint64_t a1)
{
  if (x_log_stream_once != -1) {
    dispatch_once_f(&x_log_stream_once, 0, (dispatch_function_t)x_log_stream_init);
  }
  CFTypeID v2 = (uint64_t *)pthread_getspecific(x_log_stream_slot);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = v2;
  uint64_t v4 = *v2;
  if (a1)
  {
    if (v4 != a1) {
      return 0;
    }
  }
  BOOL v5 = (const void *)v2[1];
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, v3);
  pthread_setspecific(x_log_stream_slot, v5);
  return v4;
}

CA::Render::Object *CA::Render::ImageQueue::decode(CA::Render::Context **this, CA::Render::Decoder *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = (atomic_uint *)CA::Render::Decoder::decode_object(this, 47);
  unsigned int v4 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)this);
  BOOL v14 = 0;
  mach_port_name_t v5 = CA::Render::Decoder::decode_port((CA::Render::Decoder *)this, 17, &v14);
  int v6 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)this);
  int v7 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)this);
  uint64_t v8 = 0;
  if (v3 && !(((unint64_t)v4 - 1) >> 16))
  {
    if (*((void *)v3 + 2) < 160 * (unint64_t)v4 + 464)
    {
LABEL_4:
      uint64_t v8 = 0;
      goto LABEL_9;
    }
    int v9 = v7;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v11 = (CA::Render::ImageQueue *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x118uLL, 0x743898A5uLL);
    if (!v11)
    {
      if (atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
      }
      goto LABEL_4;
    }
    uint64_t v8 = v11;
    double v12 = CA::Render::ImageQueue::ImageQueue(v11, v3, v4);
    if (atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *, double))(*(void *)v3 + 16))(v3, v12);
    }
    CA::Render::ImageQueue::set_client_port((uint64_t)v8, v5);
    *((_DWORD *)v8 + 50) = v6;
    *((_DWORD *)v8 + 46) = v9;
    CA::Render::Context::add_image_queue(this[9], v8);
  }
LABEL_9:
  if (v14) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v5);
  }
  return v8;
}

void CA::Render::Context::add_image_queue(CA::Render::Context *this, CA::Render::Object *a2)
{
  if (*((unsigned char *)a2 + 12) == 25)
  {
    CA::Render::ImageQueue::set_visible(a2, *((_DWORD *)this + 88) != 0);
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Context::_image_queues_lock);
    *((void *)a2 + 29) = this;
    mach_port_name_t v5 = (void *)*((void *)this + 46);
    unint64_t v4 = *((void *)this + 47);
    if ((unint64_t)v5 >= v4)
    {
      int v7 = (void *)*((void *)this + 45);
      uint64_t v8 = v5 - v7;
      unint64_t v9 = v8 + 1;
      if ((unint64_t)(v8 + 1) >> 61) {
        abort();
      }
      uint64_t v10 = v4 - (void)v7;
      if (v10 >> 2 > v9) {
        unint64_t v9 = v10 >> 2;
      }
      if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v11 = v9;
      }
      if (v11)
      {
        if (v11 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        double v12 = (char *)operator new(8 * v11);
      }
      else
      {
        double v12 = 0;
      }
      size_t v13 = &v12[8 * v8];
      *(void *)size_t v13 = a2;
      int v6 = v13 + 8;
      if (v5 != v7)
      {
        do
        {
          uint64_t v14 = *--v5;
          *((void *)v13 - 1) = v14;
          v13 -= 8;
        }
        while (v5 != v7);
        mach_port_name_t v5 = (void *)*((void *)this + 45);
      }
      *((void *)this + 45) = v13;
      *((void *)this + 46) = v6;
      *((void *)this + 47) = &v12[8 * v11];
      if (v5) {
        operator delete(v5);
      }
    }
    else
    {
      void *v5 = a2;
      int v6 = v5 + 1;
    }
    *((void *)this + 46) = v6;
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Context::_image_queues_lock);
  }
}

void CA::Render::ImageQueue::set_visible(CA::Render::ImageQueue *this, int a2)
{
  uint64_t v3 = *(void *)(*((void *)this + 2) + 24);
  if (*(_DWORD *)(v3 + 32) != a2)
  {
    *(_DWORD *)(v3 + 32) = a2;
    if ((a2 & 1) == 0) {
      CAShmemImageQueueCollectable(v3, *((unsigned int *)this + 49), 0, 0);
    }
  }
}

void CA::Render::TransitionAnimation::~TransitionAnimation(CA::Render::TransitionAnimation *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02EBE0;
  uint64_t v3 = (atomic_uint *)*((void *)this + 16);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  unint64_t v4 = (atomic_uint *)*((void *)this + 15);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  mach_port_name_t v5 = (atomic_uint *)*((void *)this + 14);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  --dword_1EB2ADEA4;
  CA::Render::Animation::~Animation(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  atomic_uint *v4;
  atomic_uint *v5;
  uint64_t vars8;

  *(void *)this = &unk_1ED02EBE0;
  uint64_t v3 = (atomic_uint *)*((void *)this + 16);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  unint64_t v4 = (atomic_uint *)*((void *)this + 15);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  mach_port_name_t v5 = (atomic_uint *)*((void *)this + 14);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  --dword_1EB2ADEA4;

  CA::Render::Animation::~Animation(this, a2);
}

__n128 std::vector<unsigned long long>::__move_assign(uint64_t a1, __n128 *a2)
{
  unint64_t v4 = *(void **)a1;
  if (v4)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  __n128 result = *a2;
  *(__n128 *)a1 = *a2;
  *(void *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

double CA::Render::AsynchronousState::AsynchronousState(uint64_t a1, uint64_t *a2, int a3)
{
  *(_DWORD *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 12) = 35;
  ++dword_1EB2ADE54;
  *(void *)a1 = &unk_1ED02E628;
  *(_DWORD *)(a1 + 16) = a3;
  *(_WORD *)(a1 + 20) = 0;
  *(void *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v4 = (atomic_uint *)(v3 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v3 + 8), 1u))
    {
      uint64_t v3 = 0;
      atomic_fetch_add(v4, 0xFFFFFFFF);
    }
  }
  *(void *)(a1 + 32) = v3;
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  return result;
}

void CA::Render::MatchMoveAnimation::~MatchMoveAnimation(CA::Render::MatchMoveAnimation *this, void **a2)
{
  *(void *)this = &unk_1ED02EB00;
  uint64_t v3 = (atomic_uint *)*((void *)this + 17);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  --dword_1EB2ADE44;
  *(void *)this = &unk_1ED02DEA8;
  CA::Render::key_path_free(*((CA::Render **)this + 15), a2);
  CA::Render::Animation::~Animation(this, v4);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  const CA::Render::Object *v4;
  uint64_t vars8;

  *(void *)this = &unk_1ED02EB00;
  uint64_t v3 = (atomic_uint *)*((void *)this + 17);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  --dword_1EB2ADE44;
  *(void *)this = &unk_1ED02DEA8;
  CA::Render::key_path_free(*((CA::Render **)this + 15), a2);

  CA::Render::Animation::~Animation(this, v4);
}

uint64_t CA::Render::MatchAnimation::was_removed(CA::Render::MatchAnimation *this, CA::Render::Handle *a2)
{
  uint64_t result = *((void *)this + 16);
  if (result)
  {
    CA::Render::Handle::remove_dependence(result);
    uint64_t result = *((void *)this + 16);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
    }
    *((void *)this + 16) = 0;
  }
  int v5 = *((_DWORD *)this + 3);
  if ((v5 & 0x1000) != 0)
  {
    *((void *)a2 + 12) |= 8uLL;
    int v5 = *((_DWORD *)this + 3);
  }
  if ((v5 & 0x2000) != 0) {
    *((void *)a2 + 12) |= 0x10uLL;
  }
  return result;
}

uint64_t CA::Render::Handle::remove_dependence(uint64_t a1)
{
  uint64_t v2 = CA::Render::Context::context_by_id((CA::Render::Context *)*(unsigned int *)(a1 + 8));
  uint64_t result = *(unsigned int *)(a1 + 12);
  if (*(_DWORD *)(a1 + 8) == result)
  {
    if (!v2) {
      return result;
    }
    uint64_t v4 = v2;
    if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
    {
      uint64_t v4 = 0;
      atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 0xFFFFFFFF);
    }
  }
  else
  {
    uint64_t result = CA::Render::Context::context_by_id((CA::Render::Context *)result);
    uint64_t v4 = result;
    if (!v2)
    {
      if (!result) {
        return result;
      }
      char v11 = 1;
      goto LABEL_18;
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 72));
  int v5 = CA::Render::Context::lookup_handle((CA::Render::Context *)v2, *(CA::Render::Object **)(a1 + 16), 0, 0, 0);
  if (v5)
  {
    int v7 = v5;
    unint64_t v9 = (void *)((char *)v5 + 56);
    uint64_t v8 = *((void *)v5 + 7);
    if (v8)
    {
      if (v8 == a1)
      {
LABEL_12:
        void *v9 = *(void *)(a1 + 32);
      }
      else
      {
        while (1)
        {
          uint64_t v10 = v8;
          uint64_t v8 = *(void *)(v8 + 32);
          if (!v8) {
            break;
          }
          if (v8 == a1)
          {
            unint64_t v9 = (void *)(v10 + 32);
            goto LABEL_12;
          }
        }
      }
    }
    CA::Render::Handle::update_container_state((uint64_t)v5, v6);
    *((void *)v7 + 12) |= 0x1BuLL;
  }
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v2 + 72));
  if (!v4) {
    goto LABEL_29;
  }
  char v11 = 0;
LABEL_18:
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 72));
  double v12 = CA::Render::Context::lookup_handle((CA::Render::Context *)v4, *(CA::Render::Object **)(a1 + 24), 0, 0, 0);
  if (v12)
  {
    uint64_t v14 = v12;
    int v16 = (void *)((char *)v12 + 64);
    uint64_t v15 = *((void *)v12 + 8);
    if (v15)
    {
      if (v15 == a1)
      {
LABEL_24:
        *int v16 = *(void *)(a1 + 40);
      }
      else
      {
        while (1)
        {
          uint64_t v17 = v15;
          uint64_t v15 = *(void *)(v15 + 40);
          if (!v15) {
            break;
          }
          if (v15 == a1)
          {
            int v16 = (void *)(v17 + 40);
            goto LABEL_24;
          }
        }
      }
    }
    CA::Render::Handle::update_container_state((uint64_t)v12, v13);
    *((void *)v14 + 12) |= 0x1BuLL;
  }
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v4 + 72));
  if (atomic_fetch_add((atomic_uint *volatile)(v4 + 8), 0xFFFFFFFF) == 1) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  }
  if ((v11 & 1) == 0)
  {
LABEL_29:
    if (atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 0xFFFFFFFF) == 1)
    {
      CFStringRef v18 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 16);
      return v18(v2);
    }
  }
  return result;
}

void CA::Render::MatchMoveDependence::~MatchMoveDependence(CA::Render::MatchMoveDependence *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

CATransform3D *__cdecl CATransform3DMakeScale(CATransform3D *__return_ptr retstr, CGFloat sx, CGFloat sy, CGFloat sz)
{
  *(_OWORD *)&retstr->m11 = xmmword_184997D50;
  *(_OWORD *)&retstr->m13 = 0u;
  *(_OWORD *)&retstr->m21 = xmmword_184997D60;
  *(_OWORD *)&retstr->m23 = 0u;
  *(_OWORD *)&retstr->m31 = 0u;
  *(_OWORD *)&retstr->m33 = xmmword_184997D50;
  *(_OWORD *)&retstr->m41 = 0u;
  *(_OWORD *)&retstr->m43 = xmmword_184997D60;
  retstr->m11 = sx;
  retstr->m22 = sy;
  retstr->m33 = sz;
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::finish_work_interval(uint64_t this, int a2)
{
  uint64_t v2 = *(void *)(this + 25536);
  if (v2 && *(void *)(v2 + 40))
  {
    uint64_t v4 = mach_absolute_time();
    if (a2)
    {
      work_interval_instance_set_deadline();
      work_interval_instance_set_complexity();
    }
    else
    {
      work_interval_instance_set_complexity();
      *(void *)(v2 + 24) = v4;
    }
    work_interval_instance_set_finish();
    work_interval_instance_finish();
    this = kdebug_trace();
    *(void *)(v2 + 24) = 0;
  }
  return this;
}

uint64_t CA::WindowServer::Server::context_changed(uint64_t this, CA::Render::Object *a2, double *a3, void *a4, __n128 a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(this + 416))
  {
    if (!a3 || *(unsigned char *)a3 || (a5.n128_f64[0] = a3[1], a5.n128_f64[0] <= 0.0))
    {
      __n128 v9 = (__n128)vdupq_n_s64(4uLL);
      uint64_t v13 = 0;
      __n128 v14 = v9;
      v9.n128_u64[0] = 0;
      this = (*(uint64_t (**)(CA::Render::Object *, uint64_t *, __n128))(*(void *)a2 + 184))(a2, &v13, v9);
    }
    else
    {
      if (*((unsigned char *)a3 + 16))
      {
        double v7 = (*(double (**)(void))(**((void **)a2 + 12) + 760))(*((void *)a2 + 12));
        a5.n128_f64[0] = a3[1] + ((double)(*(unsigned int (**)(void))(**((void **)a2 + 12) + 768))() + -0.25) * v7;
        a3[1] = a5.n128_f64[0];
      }
      unint64_t v11 = a5.n128_u64[0];
      int64x2_t v12 = vdupq_n_s64(4uLL);
      a5.n128_u64[0] = 0;
      this = (*(uint64_t (**)(CA::Render::Object *, unint64_t *, __n128))(*(void *)a2 + 184))(a2, &v11, a5);
    }
    if (!BYTE6(xmmword_1EB2ACBF0))
    {
      this = CA::WindowServer::Display::benchmark_mode(0, v8);
      if (a3)
      {
        if ((this & 1) == 0 && *(unsigned char *)a3)
        {
          if (BYTE7(xmmword_1EB2ACBF0)) {
            BOOL v10 = 0;
          }
          else {
            BOOL v10 = *((unsigned char *)a3 + 1) != 0;
          }
          return (*(uint64_t (**)(CA::Render::Object *, BOOL))(*(void *)a2 + 416))(a2, v10);
        }
      }
    }
  }
  return this;
}

_DWORD *CA::WindowServer::IOMFBDisplay::allocate_buffer(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4 = *(_DWORD **)(a2 + 8);
  if (!v4)
  {
    double v7 = *(void **)(a1 + 26032);
    if (!v7) {
      goto LABEL_17;
    }
    uint64_t v4 = 0;
    uint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    do
    {
      uint64_t v11 = v7[4];
      if ((!v11
         || (*(uint64_t (**)(uint64_t))(*(void *)v11 + 216))(v11) == a4
         && (!a3 || (*(_DWORD *)(v7[4] + 224) & 0x8000000) == 0))
        && !*((_DWORD *)v7 + 2))
      {
        int64x2_t v12 = (CA::Shape *)v7[2];
        if (v12)
        {
          uint64_t v13 = CA::Shape::area(v12);
          if (v13 < v10)
          {
            uint64_t v4 = v7;
            uint64_t v10 = v13;
          }
        }
        else
        {
          uint64_t v10 = 0;
          uint64_t v4 = v7;
        }
      }
      double v7 = (void *)*v7;
    }
    while (v7);
    if (v4)
    {
      ++v4[2];
    }
    else
    {
LABEL_17:
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      uint64_t v4 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x88uLL, 0x743898A5uLL);
      *(void *)uint64_t v4 = *(void *)(a1 + 26032);
      *(void *)(a1 + 26032) = v4;
      *((_OWORD *)v4 + 4) = xmmword_184997DC0;
      *((_OWORD *)v4 + 5) = xmmword_184997DD0;
      *((_OWORD *)v4 + 6) = xmmword_184997DE0;
      *((_OWORD *)v4 + 7) = xmmword_184997DF0;
      id v4[2] = 1;
    }
    *(void *)(a2 + 8) = v4;
  }
  return v4;
}

uint64_t CA::WindowServer::IOMFBDisplay::begin_update(CA::WindowServer::IOMFBDisplay *this, CA::Render::Update *a2)
{
  uint64_t v169 = *MEMORY[0x1E4F143B8];
  uint64_t result = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 216))(this);
  if (!result) {
    return result;
  }
  if (!*((void *)this + 80)) {
    return result;
  }
  int v5 = (void *)((char *)this + 26572);
  if (*((unsigned char *)this + 28162)) {
    return result;
  }
  if (*((unsigned char *)this + 28161))
  {
    *((unsigned char *)this + 28149) = 1;
    uint64_t v6 = *((unsigned int *)a2 + 271);
    unint64_t v7 = v6 & 0xFFFFFFFFFFEFFFFFLL | ((unint64_t)*((unsigned __int16 *)a2 + 544) << 32);
    *((_DWORD *)a2 + 271) = v6 & 0xFFEFFFFF;
    *((_WORD *)a2 + 544) = WORD2(v7);
  }
  CA::WindowServer::IOMFBDisplay::mark_buffers_non_static((uint64_t)this, *((void *)a2 + 36));
  if ((*((_DWORD *)a2 + 271) & 0x800000) == 0)
  {
    char v8 = 0;
    __n128 v9 = 0;
LABEL_13:
    char v10 = 0;
    goto LABEL_19;
  }
  __n128 v9 = (CA::Shape *)*((void *)a2 + 4);
  if (!v9)
  {
    char v8 = 0;
    goto LABEL_13;
  }
  if (v9)
  {
    if (v9 != (CA::Shape *)1)
    {
LABEL_17:
      char v10 = 0;
      goto LABEL_18;
    }
  }
  else if (*((_DWORD *)v9 + 1) != 6)
  {
    goto LABEL_17;
  }
  if ((*((unsigned char *)a2 + 268) & 4) != 0) {
    goto LABEL_17;
  }
  char v10 = options_are_visual ^ 1;
LABEL_18:
  char v8 = 1;
LABEL_19:
  CA::WindowServer::IOMFBDisplay::update_color_matrix(this, *((double *)a2 + 9));
  int v156 = *((unsigned __int8 *)this + 28174);
  uint64_t v166 = 0x3F80000000000000;
  uint64_t v165 = 0;
  uint64_t v167 = 0;
  uint64_t v168 = 0x3F80000000000000;
  int __s2 = 1065353216;
  *((unsigned char *)this + 28174) = memcmp((char *)this + 26808, &__s2, 0x24uLL) != 0;
  if ((*((unsigned char *)this + 745) & 4) != 0)
  {
    uint64_t v12 = *((void *)a2 + 4);
    if (v12)
    {
      if (v12 == 1) {
        goto LABEL_20;
      }
    }
    else if (*(_DWORD *)(v12 + 4) == 6)
    {
      goto LABEL_20;
    }
    if (CADeviceNeedsSurfaceAlphaUnpremultiply::once != -1) {
      dispatch_once(&CADeviceNeedsSurfaceAlphaUnpremultiply::once, &__block_literal_global_83_12101);
    }
    BOOL v11 = CADeviceNeedsSurfaceAlphaUnpremultiply::needs != 0;
    goto LABEL_28;
  }
LABEL_20:
  BOOL v11 = 0;
LABEL_28:
  *((unsigned char *)this + 28197) = v11;
  float v13 = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 920))(this);
  float v15 = CA::WindowServer::Display::edr_headroom(this) * v13;
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  int v155 = (char *)this + 745;
  int v16 = v10 & 1;
  float v17 = truncf(*(float *)&dword_1EB2ACB20);
  float v18 = truncf(*(float *)&dword_1EB2ACB14);
  float v19 = truncf(*(float *)&dword_1EB2ACB1C);
  if (!*(float *)&dword_1EB2ACB14) {
    float v18 = 30.0;
  }
  if (*(float *)&dword_1EB2ACB1C) {
    float v20 = v19;
  }
  else {
    float v20 = 80.0;
  }
  float v21 = *((float *)this + 6641);
  if (v15 <= v21) {
    float v22 = v17;
  }
  else {
    float v22 = -v17;
  }
  float v23 = v22 + v18;
  *((float *)this + 6641) = v23;
  if (v21 != v23)
  {
    *(void *)&long long v159 = vcvts_n_u32_f32(v23, 0x10uLL);
    IOMobileFramebufferSetParameter();
  }
  if (v15 <= *((float *)this + 6640)) {
    float v24 = v17;
  }
  else {
    float v24 = -v17;
  }
  *((float *)this + 6640) = v24 + v20;
  *((unsigned char *)this + 28177) = 0;
  int v25 = *((unsigned __int8 *)this + 28175);
  int v26 = *((unsigned __int8 *)this + 28176);
  if (*((unsigned char *)this + 28138))
  {
    int v27 = 0;
    BOOL v28 = 0;
    *((unsigned char *)this + 28175) = 0;
    goto LABEL_62;
  }
  int v27 = 0;
  if ((*((_WORD *)this + 328) & 0x1C00) == 0x1000) {
    goto LABEL_58;
  }
  char v29 = 0;
  if (byte_1EB2ACC06) {
    goto LABEL_59;
  }
  int v27 = 0;
  if (v15 >= *((float *)this + 6641))
  {
LABEL_58:
    char v29 = 0;
    goto LABEL_59;
  }
  char v29 = 0;
  if ((v16 & 1) == 0)
  {
    if (((*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 848))(this) & 1) != 0
      || *((void *)this + 5)
      || !CA::WindowServer::Display::Mode::operator==(*((void *)this + 80), *((void *)this + 81)))
    {
      goto LABEL_57;
    }
    uint64_t v30 = *((void *)this + 3255);
    char v31 = v8 ^ 1;
    if (!v30) {
      char v31 = 1;
    }
    if ((v31 & 1) != 0
      || (double v32 = (double)(*((_DWORD *)this + 53) * *((_DWORD *)this + 52)),
          *(double *)(v30 + 120) * *(double *)(v30 + 112) <= v32 * 0.9)
      || v32 * 0.3 <= (double)CA::Shape::area(v9))
    {
      if (CADeviceNeedsDisplayWorkarounds::once[0] != -1) {
        dispatch_once(CADeviceNeedsDisplayWorkarounds::once, &__block_literal_global_73);
      }
      char v29 = CADeviceNeedsDisplayWorkarounds::needs_workarounds;
      if (CADeviceNeedsDisplayWorkarounds::needs_workarounds) {
        char v29 = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1048))(this) != 0.0;
      }
      int v27 = 1;
    }
    else
    {
LABEL_57:
      int v27 = 0;
      char v29 = 0;
    }
  }
LABEL_59:
  int v33 = *((unsigned __int8 *)this + 28138);
  *((unsigned char *)this + 28175) = v29;
  if (v33 || (*((_WORD *)this + 328) & 0x1C00) == 0x1000) {
    goto LABEL_61;
  }
  if (CADeviceNeedsDisplayWorkarounds::once[0] != -1)
  {
    int v151 = v27;
    dispatch_once(CADeviceNeedsDisplayWorkarounds::once, &__block_literal_global_73);
    int v27 = v151;
  }
  BOOL v28 = 0;
  if (CADeviceNeedsDisplayWorkarounds::needs_workarounds && !byte_1EB2ACC07)
  {
    if (v15 <= *((float *)this + 6640))
    {
LABEL_61:
      BOOL v28 = 0;
      goto LABEL_62;
    }
    BOOL v28 = *((unsigned char *)this + 28175) == 0;
  }
LABEL_62:
  *((unsigned char *)this + 28176) = v28;
  int v154 = v27;
  if (BYTE9(xmmword_1EB2ACC10))
  {
    if (CADeviceNeedsDisplayWorkarounds::once[0] != -1) {
      dispatch_once(CADeviceNeedsDisplayWorkarounds::once, &__block_literal_global_73);
    }
    LOBYTE(v27) = v154;
    if (CADeviceNeedsDisplayWorkarounds::needs_workarounds)
    {
      int v146 = 0;
      valuePtr[0] = 0uLL;
      unint64_t v147 = *((void *)a2 + 3);
      *(void *)&long long v160 = 0;
      long long v159 = v147;
      while (CA::ShapeIterator::iterate((uint64_t *)&v159, (int *)valuePtr))
      {
        CA::BoundsImpl::intersect((int32x2_t *)valuePtr, *(int32x2_t *)((char *)a2 + 192), *(int32x2_t *)((char *)a2 + 200));
        v146 += HIDWORD(valuePtr[0]) * DWORD2(valuePtr[0]);
      }
      (*(void (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 848))(this);
      kdebug_trace();
      (*(void (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 920))(this);
      CA::WindowServer::Display::edr_headroom(this);
      kdebug_trace();
      (*(void (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1048))(this);
      (*(void (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 984))(this);
      (*(void (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 920))(this);
      v150.n128_f32[0] = CA::WindowServer::Display::edr_headroom(this);
      (*(void (**)(CA::WindowServer::IOMFBDisplay *, __n128))(*(void *)this + 1528))(this, v150);
      kdebug_trace();
      LOBYTE(v27) = v154;
    }
  }
  int v34 = *((unsigned __int8 *)this + 28175);
  BOOL v35 = v26 == *((unsigned __int8 *)this + 28176) && v25 == v34;
  int v36 = !v35;
  uint64_t v163 = 0;
  long long v161 = 0u;
  long long v162 = 0u;
  long long v159 = 0u;
  long long v160 = 0u;
  if (v34)
  {
    if (!IOMobileFramebufferGetMatrix())
    {
      uint64_t v41 = 0;
      double v42 = &v159;
      uint64_t v43 = (char *)this + 26572;
      do
      {
        for (uint64_t i = 0; i != 3; ++i)
        {
          uint64_t v45 = *((void *)v42 + i);
          BOOL v46 = v45 < 0;
          if (v45 < 0) {
            uint64_t v45 = -v45;
          }
          double v47 = -((double)v45 * 2.32830644e-10);
          if (!v46) {
            double v47 = (double)v45 * 2.32830644e-10;
          }
          float v48 = v47;
          *(float *)&v43[4 * i] = v48;
        }
        ++v41;
        v43 += 16;
        double v42 = (long long *)((char *)v42 + 24);
      }
      while (v41 != 3);
      CA::Mat4Impl::mat4_concat((float32x4_t *)((char *)this + 26572), (float *)this + 6643, flt_1849A8294, v14);
      uint64_t v39 = (float32x4_t *)((char *)this + 26572);
      uint64_t v38 = flt_1849A8294;
      unsigned int v40 = (const float *)((char *)this + 26572);
      goto LABEL_86;
    }
    int v34 = *((unsigned __int8 *)this + 28175);
    LOBYTE(v27) = v154;
  }
  BOOL v35 = v34 == 0;
  char v37 = v27 ^ 1;
  if (!v35) {
    char v37 = 1;
  }
  if ((v37 & 1) == 0)
  {
    void *v5 = *((void *)this + 3351);
    *((_DWORD *)this + 6645) = *((_DWORD *)this + 6704);
    *(void *)((char *)this + 26588) = *(void *)((char *)this + 26820);
    *((_DWORD *)this + 6649) = *((_DWORD *)this + 6707);
    *(void *)((char *)this + 26604) = *((void *)this + 3354);
    uint64_t v38 = (float *)((char *)this + 26904);
    *((_DWORD *)this + 6653) = *((_DWORD *)this + 6710);
    uint64_t v39 = (float32x4_t *)((char *)this + 26572);
    unsigned int v40 = (const float *)((char *)this + 26572);
LABEL_86:
    CA::Mat4Impl::mat4_concat(v39, v38, v40, v14);
    goto LABEL_87;
  }
  *(_OWORD *)int v5 = xmmword_184997DC0;
  *(_OWORD *)((char *)this + 26588) = xmmword_184997DD0;
  *(_OWORD *)((char *)this + 26604) = xmmword_184997DE0;
  *(_OWORD *)((char *)this + 26620) = xmmword_184997DF0;
LABEL_87:
  *((unsigned char *)this + 28194) = 0;
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  float v49 = *(float *)&dword_1EB2ACB38;
  float v50 = *(float *)&dword_1EB2ACB3C;
  if (*((unsigned char *)this + 28138)) {
    goto LABEL_90;
  }
  int v51 = 0;
  if ((*((_WORD *)this + 328) & 0x1C00) == 0x1000 || byte_1EB2ACC2E) {
    goto LABEL_91;
  }
  if (CADeviceNeedsLumaBoost::once[0] != -1) {
    dispatch_once(CADeviceNeedsLumaBoost::once, &__block_literal_global_76);
  }
  if (!CADeviceNeedsLumaBoost::needs_luma_bost
    || (float)(v15 / *((float *)a2 + 93)) >= v50
    || ((*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 848))(this) & 1) != 0
    || *((void *)this + 5))
  {
LABEL_90:
    int v51 = 0;
  }
  else
  {
    int v51 = CA::WindowServer::Display::Mode::operator==(*((void *)this + 80), *((void *)this + 81));
  }
LABEL_91:
  *((_DWORD *)this + 6642) = 1065353216;
  if (*((unsigned char *)this + 28175) || v51)
  {
    CFNumberRef v52 = (const __CFNumber *)IOMobileFramebufferCopyProperty();
    if (v52)
    {
      CFNumberRef v53 = v52;
      LODWORD(valuePtr[0]) = 0;
      CFNumberGetValue(v52, kCFNumberIntType, valuePtr);
      CFRelease(v53);
      *((float *)this + 6642) = (float)SLODWORD(valuePtr[0]) * 0.000015259;
    }
  }
  if (v51)
  {
    float v54 = (float)(*((float *)this + 6642) * v15) / *((float *)a2 + 93);
    float v55 = 1.0;
    if (v54 >= v49)
    {
      float v55 = 0.0;
      if (v54 <= v50 && v49 != v50)
      {
        float v57 = (float)((float)((float)((float)((float)((float)((float)(v54 * 0.000008375) + -0.00027092) * v54)
                                            + 0.0038907)
                                    * v54)
                            + -0.094163)
                    * v54)
            + 1.156;
        if (v57 > 1.0) {
          float v57 = 1.0;
        }
        if (v57 >= 0.0) {
          float v55 = v57;
        }
        else {
          float v55 = 0.0;
        }
      }
    }
    int v58 = *((unsigned __int8 *)this + 28195);
    float v59 = *((float *)this + 6660);
    uint64_t v60 = *((void *)this + 3255);
    *((unsigned char *)this + 28195) = v60 != 0;
    if (v60)
    {
      *((_DWORD *)this + 6661) = 0;
    }
    else
    {
      if (v58 || !*((unsigned char *)this + 28196)) {
        int v62 = 2;
      }
      else {
        int v62 = 1;
      }
      *((_DWORD *)this + 6662) = v62;
    }
    float v63 = (*(double (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 744))(this) * 0.666666667;
    int v64 = *((_DWORD *)this + 6662);
    if (v64 == 1)
    {
      float v65 = *((float *)this + 6661) - v63;
    }
    else if (v64 == 2)
    {
      float v65 = *((float *)this + 6661) + v63;
    }
    else
    {
      float v65 = *((float *)this + 6661);
    }
    if (v65 > 1.0) {
      float v65 = 1.0;
    }
    if (v65 < 0.0) {
      float v65 = 0.0;
    }
    *((float *)this + 6660) = v65 * v55;
    *((float *)this + 6661) = v65;
    *((unsigned char *)this + 28196) = 0;
    if (CADeviceSupportsAndromeda::once != -1) {
      dispatch_once(&CADeviceSupportsAndromeda::once, &__block_literal_global_86);
    }
    if (CADeviceSupportsAndromeda::supports_andromeda)
    {
      float v66 = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1272))(this);
      float v67 = *((float *)this + 6660);
      if ((LODWORD(v66) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
      {
        float v68 = 1.0 - v66;
        if (v68 > 1.0) {
          float v68 = 1.0;
        }
        if (v68 < 0.0) {
          float v68 = 0.0;
        }
        float v67 = v67 * v68;
        *((float *)this + 6660) = v67;
      }
    }
    else
    {
      float v67 = *((float *)this + 6660);
    }
    *((float *)this + 6659) = (float)(*((float *)a2 + 93) * v50) / *((float *)this + 6642);
    BOOL v61 = v67 == 0.0;
    if (v67 == 0.0 || (float v114 = *((float *)this + 6661), v114 == 0.0) || v114 == 1.0) {
      *((_DWORD *)this + 6662) = 0;
    }
    if (v59 != 0.0 || v67 == 0.0)
    {
      if (v59 == 0.0) {
        BOOL v61 = 0;
      }
    }
    else
    {
      BOOL v61 = 1;
    }
  }
  else
  {
    BOOL v61 = 0;
    *((unsigned char *)this + 28196) = 0;
    *(void *)((char *)this + 26636) = 0;
    *((_DWORD *)this + 6662) = 0;
  }
  if (*((unsigned char *)this + 28175) || *((unsigned char *)this + 28176)) {
    *((unsigned char *)this + 28174) = 0;
  }
  if (*((unsigned char *)this + 28200))
  {
    int v69 = *((unsigned __int8 *)this + 28147);
    if (*((unsigned __int8 *)this + 28148) == v69)
    {
      int v70 = *((unsigned __int8 *)this + 28139);
      if (*((unsigned __int8 *)this + 28145) == v70) {
        goto LABEL_164;
      }
    }
    else
    {
      LOBYTE(v70) = *((unsigned char *)this + 28139);
    }
    *((unsigned char *)this + 28148) = v69;
    *((unsigned char *)this + 28145) = v70;
    *((unsigned char *)this + 28201) = 1;
  }
LABEL_164:
  int v71 = 0;
  int v72 = *((_DWORD *)a2 + 67);
  int v73 = *((unsigned __int8 *)this + 28178);
  *((unsigned char *)this + 28178) = v16;
  uint64_t v74 = *((void *)this + 3255);
  if (v74 && (v72 & 0x200000) == 0)
  {
    if ((v72 & 4) != 0) {
      goto LABEL_172;
    }
    if ((v72 & 2) == 0) {
      BOOL v61 = 1;
    }
    if (((v36 | v61) & 1) != 0
      || v73 != v16
      || *((unsigned char *)this + 28161)
      || (*((_DWORD *)this + 156) & 4) != 0
      && CA::WindowServer::Display::clones_support_detaching(*((CA::WindowServer::Display **)this + 5))
      && (uint64_t v74 = *((void *)this + 3255), (v117 = *(CA::Render::LayerNode ****)(*(void *)v74 + 40)) != 0)
      && (CA::Render::LayerNode::clear_above_and_black_below(v117, 1, v115, v116) & 1) == 0)
    {
LABEL_172:
      if (v73 == v16) {
        int v75 = v36;
      }
      else {
        int v75 = 1;
      }
      CA::WindowServer::IOMFBDisplay::release_detached_handle(v74);
      if (v75) {
        char v77 = 3;
      }
      else {
        char v77 = 1;
      }
      *(unsigned char *)(v74 + 292) = v77 | *(unsigned char *)(v74 + 292) & 0xFC;
      *((unsigned char *)this + 28137) = 1;
      *((unsigned char *)this + 26424) = *((unsigned char *)this + 26426);
      float64x2_t v78 = *(float64x2_t *)(v74 + 112);
      int64x2_t v79 = vceqzq_f64(v78);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v79, 1), (int8x16_t)v79).u64[0] & 0x8000000000000000) != 0
        || (int8x16_t v80 = vorrq_s8((int8x16_t)vcltzq_f64(v78), (int8x16_t)vcgezq_f64(v78)),
            (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v80), 1), v80).u64[0] & 0x8000000000000000) != 0))
      {
        valuePtr[0] = 0uLL;
      }
      else
      {
        float64x2_t v81 = *(float64x2_t *)(v74 + 96);
        int32x4_t v82 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v81, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        valuePtr[0] = vuzp1q_s32(v82, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v81, v78), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v82));
      }
      for (uint64_t j = (CA::Shape **)*((void *)this + 3254); j; uint64_t j = (CA::Shape **)*j)
      {
        if (j[2]) {
          CA::shape_union(j + 2, (CA::Shape **)valuePtr, v76);
        }
      }
      int v84 = *((_DWORD *)a2 + 67);
      if ((v84 & 0x8000) != 0) {
        *((_DWORD *)a2 + 67) = v84 | 0x10000;
      }
      int v71 = 1;
    }
    else
    {
      int v71 = 0;
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
  unsigned int v153 = *((_DWORD *)this + 6426);
  BOOL v85 = (char *)this + 48 * v153 + 25784;
  BOOL v35 = v156 == *((unsigned __int8 *)this + 28174);
  uint64_t v157 = (uint64_t *)((char *)this + 216);
  uint64_t v152 = (uint64_t *)((char *)a2 + 16);
  if (v35) {
    char v86 = (char *)a2 + 16;
  }
  else {
    char v86 = (char *)this + 216;
  }
  uint64_t v87 = *(void *)v86;
  char updated = CA::WindowServer::IOMFBDisplay::update_display_edr_factor(this);
  int v90 = *((_DWORD *)a2 + 67);
  int32x2_t v91 = (char *)this + 48 * v153 + 25824;
  *v91 &= ~0x10u;
  if ((v72 & 0x200000) != 0)
  {
    if (v71) {
      __assert_rtn("begin_update", "windowserver-iomfb-display.cpp", 3271, "!invalidated_detached");
    }
    uint64_t v92 = *((void *)this + 6 * *((unsigned int *)this + 6427) + 3224);
    if (v92)
    {
      ++*(_DWORD *)(v92 + 8);
      *((void *)this + 6 * v153 + 3224) = v92;
      *v91 |= 0x10u;
      kdebug_trace();
    }
    goto LABEL_242;
  }
  char v93 = updated;
  if (v87)
  {
    if (v87 != 1) {
      goto LABEL_237;
    }
  }
  else if (*(_DWORD *)(v87 + 4) != 6)
  {
    goto LABEL_237;
  }
  if (((*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1544))(this) & 1) != 0
    || (*((_DWORD *)this + 156) & 4) != 0
    || (*((unsigned char *)this + 28164) ? (char v94 = 1) : (char v94 = v93), (v94 & 1) != 0 || (*((unsigned char *)a2 + 271) & 1) != 0))
  {
LABEL_237:
    if ((v90 & 0x100000) == 0)
    {
      for (uint64_t k = (CA::Shape **)*((void *)this + 3254); k; uint64_t k = (CA::Shape **)*k)
      {
        if (k[2]) {
          CA::shape_union(k + 2, (CA::Shape **)v87, v89);
        }
      }
    }
    goto LABEL_242;
  }
  if (*((_DWORD *)this + 6428) < 2u) {
    char v95 = 1;
  }
  else {
    char v95 = v71;
  }
  if ((v95 & 1) == 0)
  {
    uint64_t v96 = *((void *)this + 6 * *((unsigned int *)this + 6427) + 3224);
    if (v96)
    {
      if ((*(unsigned char *)(v96 + 132) & 0x50) == 0 && !*(void *)(v96 + 24))
      {
        if (CADeviceNeedsDisplayWorkarounds::once[0] != -1) {
          dispatch_once(CADeviceNeedsDisplayWorkarounds::once, &__block_literal_global_73);
        }
        if (CADeviceNeedsDisplayWorkarounds::needs_workarounds)
        {
          (*(void (**)(_OWORD *__return_ptr, CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1496))(valuePtr, this);
          if (*(float *)(v96 + 64) != *(float *)valuePtr) {
            goto LABEL_242;
          }
          uint64_t v97 = 0;
          while (v97 != 15)
          {
            uint64_t v98 = v97 + 1;
            float v99 = *(float *)(v96 + 68 + 4 * v97);
            float v100 = *((float *)valuePtr + ++v97);
            if (v99 != v100)
            {
              if ((unint64_t)(v98 - 1) <= 0xE) {
                goto LABEL_242;
              }
              break;
            }
          }
        }
        uint64_t v101 = *(void *)(v96 + 32);
        if (v101)
        {
          uint64_t v102 = *(unsigned int *)(v101 + 224);
          BOOL v103 = (v102 & 0x8000000) == 0 || (*v155 & 0x80) == 0;
          BOOL v104 = v103 && ((v102 | ((unint64_t)*(unsigned __int8 *)(v101 + 228) << 32)) & 0x200000000) == 0;
          if (v104
            && *(void *)(v96 + 16)
            && (*(unsigned char *)(v96 + 132) & 8) == 0
            && *(float *)(v96 + 128) == *((float *)this + 6660)
            && (CA::WindowServer::IOMFBDisplay::edr_factor_changed(this, (const CA::Render::LayerNode *)v96, a2) & 1) == 0
            && (*(uint64_t (**)(uint64_t))(*(void *)v101 + 216))(v101) == *((void *)a2 + 36))
          {
            ++*(_DWORD *)(v96 + 8);
            *((void *)this + 6 * v153 + 3224) = v96;
            *v91 |= 0x10u;
          }
        }
      }
    }
  }
LABEL_242:
  IOSurfaceRef buffer = CA::WindowServer::IOMFBDisplay::allocate_buffer((uint64_t)this, (uint64_t)v85, (*(_DWORD *)v155 >> 7) & 1, *((void *)a2 + 36));
  uint64_t v108 = buffer;
  if ((v90 & 0x100000) != 0)
  {
    uint64_t v109 = (CA::Shape **)(buffer + 4);
    if (*((void *)v108 + 2)) {
      CA::shape_union(v109, (CA::Shape **)v87, v107);
    }
  }
  uint64_t v110 = *((void *)v108 + 2);
  if (v110
    && (uint64_t v111 = *((void *)v108 + 4)) != 0
    && ((*(unsigned int *)(v111 + 224) | ((unint64_t)*(unsigned __int8 *)(v111 + 228) << 32)) & 0x200000000) == 0
    && (CA::WindowServer::IOMFBDisplay::edr_factor_changed(this, (const CA::Render::LayerNode *)v108, a2) & 1) == 0
    && (v108[33] & 8) == 0
    && (!CA::WindowServer::IOMFBDisplay::use_assembly_surface(this) || *((void *)v108 + 5))
    && *((float *)v108 + 32) == *((float *)this + 6660))
  {
    BOOL v112 = (*(uint64_t (**)(void))(**((void **)v108 + 4) + 216))(*((void *)v108 + 4)) != *((void *)a2 + 36);
    if ((v72 & 0x200000) != 0) {
      goto LABEL_254;
    }
  }
  else
  {
    BOOL v112 = 1;
    if ((v72 & 0x200000) != 0)
    {
LABEL_254:
      int v113 = 0;
      uint64_t v110 = 1;
      goto LABEL_301;
    }
  }
  if (v112)
  {
    int v113 = 0;
    goto LABEL_275;
  }
  (*(void (**)(_OWORD *__return_ptr, CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1496))(valuePtr, this);
  if (*((float *)v108 + 16) == *(float *)valuePtr)
  {
    uint64_t v119 = 0;
    while (v119 != 15)
    {
      uint64_t v120 = v119 + 1;
      float v121 = *(float *)&v108[v119 + 17];
      float v122 = *((float *)valuePtr + ++v119);
      if (v121 != v122)
      {
        if ((unint64_t)(v120 - 1) <= 0xE) {
          goto LABEL_272;
        }
        break;
      }
    }
    int v113 = 0;
LABEL_288:
    uint64_t v123 = *((void *)v108 + 4);
    if (v123)
    {
      int v124 = *(_DWORD *)(v123 + 64);
      if (v124 == 1647534392 || v124 == 643969848)
      {
        int v126 = *((_DWORD *)a2 + 67);
        if ((v126 & 0x2000) != 0 || (v126 & 2) != 0 || BYTE8(xmmword_1EB2ACC10))
        {
          if ((*(_DWORD *)(v123 + 224) & 0x40000000) == 0) {
            goto LABEL_275;
          }
        }
        else if (((*(unsigned __int8 *)(v123 + 228) >> 1) & 1) != ((*(_DWORD *)(v123 + 224) >> 30) & 1))
        {
          goto LABEL_275;
        }
      }
    }
    BOOL v112 = 0;
    goto LABEL_301;
  }
LABEL_272:
  if (CADeviceNeedsDisplayWorkarounds::once[0] != -1) {
    dispatch_once(CADeviceNeedsDisplayWorkarounds::once, &__block_literal_global_73);
  }
  int v113 = 1;
  if (!CADeviceNeedsDisplayWorkarounds::needs_workarounds) {
    goto LABEL_288;
  }
LABEL_275:
  uint64_t v110 = *v157;
  uint64_t v118 = *v152;
  if (*v152)
  {
    if (v118 != 1) {
      goto LABEL_278;
    }
    goto LABEL_277;
  }
  if (*(_DWORD *)(v118 + 4) == 6) {
LABEL_277:
  }
    *((unsigned char *)this + 28199) = 1;
LABEL_278:
  if ((*v91 & 0x10) != 0)
  {
    --v108[2];
    *((void *)this + 6 * v153 + 3224) = 0;
    uint64_t v108 = CA::WindowServer::IOMFBDisplay::allocate_buffer((uint64_t)this, (uint64_t)v85, (*(_DWORD *)v155 >> 7) & 1, *((void *)a2 + 36));
    *v91 &= ~0x10u;
  }
  BOOL v112 = 1;
LABEL_301:
  char v127 = *((unsigned char *)v108 + 132);
  *((unsigned char *)v108 + 132) = v127 & 0xBF;
  char v128 = *((unsigned char *)this + 28175);
  if (v128)
  {
    if (v87) {
      BOOL v129 = v87 == 1;
    }
    else {
      BOOL v129 = *(_DWORD *)(v87 + 4) == 6;
    }
    if (v129) {
      char v128 = 0;
    }
    else {
      char v128 = 16;
    }
  }
  *((unsigned char *)v108 + 132) = v128 | v127 & 0xAF;
  (*(void (**)(_OWORD *__return_ptr, CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1496))(valuePtr, this);
  long long v131 = valuePtr[1];
  long long v132 = valuePtr[2];
  long long v133 = valuePtr[3];
  *((_OWORD *)v108 + 4) = valuePtr[0];
  *((_OWORD *)v108 + 5) = v131;
  *((_OWORD *)v108 + 6) = v132;
  *((_OWORD *)v108 + 7) = v133;
  v108[32] = *((_DWORD *)this + 6660);
  CA::Render::Update::set_shape(a2, (const CA::Shape *)v110);
  uint64_t v134 = *((void *)v108 + 3);
  if (v134)
  {
    BOOL v135 = (const CA::Shape *)CA::Shape::Union(v110, v134);
    CA::Render::Update::set_shape(a2, v135);
    CA::Shape::unref(v135);
    CA::Shape::unref(*((CA::Shape **)v108 + 3));
    *((void *)v108 + 3) = 0;
  }
  char v136 = *((unsigned char *)v108 + 132);
  *((unsigned char *)v108 + 132) = v136 & 0xDF;
  if (!(ca_debug_options | BYTE14(xmmword_1EB2ACC10))) {
    goto LABEL_314;
  }
  if ((_BYTE)ca_debug_options) {
    unint64_t v144 = *((void *)v108 + 2);
  }
  else {
    unint64_t v144 = 0;
  }
  if (BYTE14(xmmword_1EB2ACC10)) {
    BOOL v145 = v112;
  }
  else {
    BOOL v145 = 0;
  }
  if (v145)
  {
    *((unsigned char *)v108 + 132) = v136 | 0x20;
    unint64_t v144 = v110;
    if (!v110) {
      goto LABEL_314;
    }
  }
  else if (!v144)
  {
    goto LABEL_314;
  }
  if (v144)
  {
    if (v144 != 1) {
LABEL_346:
    }
      *((void *)v108 + 3) = CA::Shape::ref(v144);
  }
  else if (*(_DWORD *)(v144 + 4) != 6)
  {
    goto LABEL_346;
  }
LABEL_314:
  if (BYTE5(xmmword_1EB2ACBF0))
  {
    double v148 = (unsigned int *)((char *)this + 48 * v153 + 25808);
    unsigned int v149 = *v148;
    if (!*v148)
    {
      CA::IOMobileFramebuffer::swap_begin((CA::WindowServer::IOMFBDisplay *)((char *)this + 25568), (unsigned int *)this + 12 * v153 + 6452);
      unsigned int v149 = *v148;
    }
    qword_1E8F86558 = v149;
  }
  double v137 = (CA::Shape *)CA::Shape::intersect(v110, *v157);
  float v138 = (float)CA::Shape::area(v137);
  float v139 = fminf(v138 / (float)CA::Shape::area((CA::Shape *)*v157), 1.0);
  CA::Shape::unref(v137);
  if (v139 <= 0.0)
  {
    int v140 = 0;
    double v141 = (pthread_mutex_t *)((char *)this + 25720);
  }
  else
  {
    int v140 = (int)(float)(ceilf(v139 * 10.0) + -1.0);
    double v141 = (pthread_mutex_t *)((char *)this + 25720);
    if ((v154 & v113) == 1)
    {
      ++*((_DWORD *)this + 6372);
    }
    else
    {
      if (v154) {
        uint64_t v142 = 25408;
      }
      else {
        uint64_t v142 = 25448;
      }
      ++*(_DWORD *)((char *)this + 4 * v140 + v142);
    }
  }
  *((_DWORD *)this + 6383) = v140;
  uint64_t v143 = mach_absolute_time();
  *((double *)this + 3315) = CATimeWithHostTime(v143);
  CA::WindowServer::IOMFBDisplay::update_brightness_deadline((double *)this, *((double *)a2 + 9));
  return pthread_mutex_unlock(v141);
}

uint64_t CA::Shape::area(CA::Shape *this)
{
  if (this) {
    return ((this >> 2) & 0x7FFF) * (this >> 17);
  }
  unint64_t v1 = (char *)this + 12;
  int v2 = *((_DWORD *)this + 3);
  if (v2 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    uint64_t v4 = *((int *)v1 + 1);
    int v5 = &v1[4 * v4];
    int v6 = *(_DWORD *)v5;
    int v7 = v4 - 2;
    if (v7 >= 2)
    {
      int v8 = v6 - v2;
      int v9 = v7 >> 1;
      char v10 = v1 + 12;
      do
      {
        result += (*v10 - *(v10 - 1)) * v8;
        v10 += 2;
        --v9;
      }
      while (v9);
    }
    int v2 = *(_DWORD *)v5;
    unint64_t v1 = v5;
  }
  while (v6 != 0x7FFFFFFF);
  return result;
}

__n128 CA::WindowServer::IOMFBDisplay::workaround_matrix@<Q0>(CA::WindowServer::IOMFBDisplay *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result = *(__n128 *)((char *)this + 26572);
  long long v3 = *(_OWORD *)((char *)this + 26588);
  long long v4 = *(_OWORD *)((char *)this + 26604);
  long long v5 = *(_OWORD *)((char *)this + 26620);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  *(_OWORD *)(a2 + 32) = v4;
  *(_OWORD *)(a2 + 48) = v5;
  return result;
}

CA::Shape *CA::Render::Update::set_shape(CA::Render::Update *this, const CA::Shape *a2)
{
  __n128 result = (CA::Shape *)*((void *)this + 2);
  if (result != a2)
  {
    CA::Shape::unref(result);
    __n128 result = (CA::Shape *)CA::Shape::ref((unint64_t)a2);
    *((void *)this + 2) = result;
  }
  return result;
}

void CA::WindowServer::IOMFBServer::set_edr_enabled(CA::WindowServer::IOMFBServer *this, int a2, float a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (CADeviceHasBacklight::once != -1) {
    dispatch_once(&CADeviceHasBacklight::once, &__block_literal_global_120);
  }
  if (CADeviceHasBacklight::has_backlight == 1
    && (*(unsigned char *)(*((void *)this + 12) + 746) & 2) != 0
    && CA::WindowServer::IOMFBServer::edr_client(this))
  {
    uint64_t v6 = *((void *)this + 12);
    if ((*((unsigned char *)this + 1014) & 4) == 0 && a2 && !*(unsigned char *)(v6 + 28209))
    {
      CA::WindowServer::IOMFBServer::register_libedr_callbacks(this);
      uint64_t v6 = *((void *)this + 12);
    }
    if (*(unsigned char *)(v6 + 28209))
    {
      float v7 = 1.0;
      if (a2)
      {
        uint64_t v8 = *(void *)(v6 + 688);
        float v9 = 1.0;
        if (v8)
        {
          *(float *)&unsigned int v10 = COERCE_FLOAT(atomic_load((unsigned int *)(v8 + 4)));
          float v9 = *(float *)&v10;
        }
        if (a3 <= 1.0) {
          float v7 = v9;
        }
        else {
          float v7 = a3;
        }
        if (v7 >= v9) {
          float v7 = v9;
        }
      }
      if (v7 != *((float *)this + 210))
      {
        *((float *)this + 210) = v7;
        uint64_t v11 = *((void *)this + 31);
        if (v11)
        {
          uint64_t v12 = *(void (**)(void))(v11 + 16);
          v12();
        }
      }
      return;
    }
    float v13 = (pthread_mutex_t *)CA::WindowServer::IOMFBServer::edr_client(this);
    __n128 v14 = v13;
    if (a3 > 1.0)
    {
      pthread_mutex_lock(v13 + 1);
      if (*(float *)&v14[2].__opaque[12] != a3)
      {
        *(float *)&v14[2].__opaque[12] = a3;
        v14[2].__opaque[9] = 1;
        int v15 = CA::EDRClient::client(v14);
        if (v15)
        {
          sig = v14[2].__sig;
          uint64_t v20 = MEMORY[0x1E4F143A8];
          uint64_t v21 = 0x40000000;
          float v22 = ___ZN2CA9EDRClient20set_edr_max_headroomEf_block_invoke;
          float v23 = &__block_descriptor_tmp_9_18033;
          int v24 = v15;
          float v25 = a3;
          dispatch_async(sig, &v20);
        }
      }
      float v17 = v14 + 1;
LABEL_37:
      pthread_mutex_unlock(v17);
      return;
    }
    if (CADeviceHasBacklight::once != -1) {
      dispatch_once(&CADeviceHasBacklight::once, &__block_literal_global_120);
    }
    if (CADeviceHasBacklight::has_backlight == 1)
    {
      pthread_mutex_lock(v14 + 1);
      if (v14[2].__opaque[9] != a2 || *(float *)&v14[2].__opaque[12] != 0.0)
      {
        v14[2].__opaque[9] = a2;
        *(_DWORD *)&v14[2].__opaque[12] = 0;
        int v18 = CA::EDRClient::client(v14);
        if (v18)
        {
          float v19 = v14[2].__sig;
          uint64_t v20 = MEMORY[0x1E4F143A8];
          uint64_t v21 = 0x40000000;
          float v22 = ___ZN2CA9EDRClient15set_edr_enabledEb_block_invoke;
          float v23 = &__block_descriptor_tmp_8_18026;
          LOBYTE(v25) = a2;
          int v24 = v18;
          dispatch_async(v19, &v20);
        }
      }
      float v17 = v14 + 1;
      goto LABEL_37;
    }
  }
}

uint64_t CA::WindowServer::IOMFBServer::set_enabled(CA::WindowServer::IOMFBServer *this, uint64_t a2)
{
  long long v4 = (pthread_mutex_t *)((char *)this + 544);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 544));
  if ((a2 & 1) == 0)
  {
    CA::WindowServer::IOMFBServer::remove_vsync_source(this);
    CA::WindowServer::IOMFBServer::remove_power_log_timer(this);
    uint64_t v6 = (char *)this + 96;
    CA::WindowServer::IOMFBDisplay::post_power_log(*((CA::WindowServer::IOMFBDisplay **)this + 12));
    *((_DWORD *)this + 210) = 0;
    goto LABEL_7;
  }
  uint64_t v6 = (char *)this + 96;
  uint64_t v5 = *((void *)this + 12);
  if ((*(_WORD *)(v5 + 656) & 0x1C00) == 0 && (!*(void *)(v5 + 640) || !*(unsigned char *)(v5 + 28132)))
  {
    CA::WindowServer::IOMFBDisplay::enable_hotplug_info((CA::WindowServer::IOMFBDisplay *)v5);
LABEL_7:
    uint64_t v5 = *(void *)v6;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 224))(v5, a2);
  if (a2)
  {
    if ((*(unsigned int (**)(void))(**(void **)v6 + 216))())
    {
      CA::WindowServer::IOMFBServer::add_vsync_source(this, v7);
      CA::WindowServer::IOMFBServer::add_power_log_timer((CFRunLoopRef *)this);
      if ((*(unsigned int (**)(void))(**((void **)this + 12) + 208))(*((void *)this + 12))) {
        CA::WindowServer::IOMFBServer::register_libedr_callbacks(this);
      }
    }
  }

  return pthread_mutex_unlock(v4);
}

BOOL CA::WindowServer::IOMFBDisplay::is_ready(CA::WindowServer::IOMFBDisplay *this)
{
  uint64_t v2 = *((void *)this + 91);
  int v3 = *(unsigned __int8 *)(v2 + 2);
  int v4 = *(unsigned __int8 *)(v2 + 3);
  if (v3) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 1;
  }
  if (v5 && !CA::IOMobileFramebuffer::swap_wait((CA::WindowServer::IOMFBDisplay *)((char *)this + 25568)))
  {
    CA::WindowServer::Display::complete_powering_on((os_unfair_lock_s *)this);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 560));
    CA::WindowServer::IOMFBDisplay::update_framebuffer_locked(this, 0);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 560));
  }
  return (*(unsigned __int8 *)(*((void *)this + 91) + 2) | *(unsigned __int8 *)(*((void *)this + 91) + 3)) != 0;
}

uint64_t CA::WindowServer::IOMFBDisplay::can_update(CA::WindowServer::IOMFBDisplay *this, char a2, double a3, double a4)
{
  if (!(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 216))(this)) {
    return 255;
  }
  if (!*((void *)this + 80)) {
    return 254;
  }
  if (*((unsigned char *)this + 28162)) {
    return 253;
  }
  if ((**((unsigned char **)this + 91) & 0xFE) == 2) {
    return 252;
  }
  if (*((unsigned char *)this + 746)) {
    return 251;
  }
  if (CA::WindowServer::IOMFBDisplay::can_update_(this, a2, a3, a4, v8, v9, v10)) {
    return 0;
  }
  ++*((_DWORD *)this + 6343);
  return 250;
}

uint64_t CA::WindowServer::IOMFBServer::set_next_update(uint64_t a1, long long *a2, double a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (pthread_mutex_t *)(a1 + 544);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 544));
  if (!(*(unsigned int (**)(void))(**(void **)(a1 + 96) + 216))(*(void *)(a1 + 96))) {
    goto LABEL_21;
  }
  if ((*(unsigned char *)(a1 + 1014) & 2) != 0)
  {
    if (*(void *)(a1 + 784)) {
      goto LABEL_4;
    }
LABEL_21:
    long long v14 = *a2;
    v12.n128_u64[1] = *((void *)&v14 + 1);
    uint64_t v15 = *((void *)a2 + 2);
    v12.n128_f64[0] = a3;
    CA::WindowServer::Server::set_next_update(a1, (unint64_t *)&v14, v12);
    goto LABEL_22;
  }
  if (!*(void *)(a1 + 800)) {
    goto LABEL_21;
  }
LABEL_4:
  double v7 = *(double *)a2;
  double v8 = *(double *)(a1 + 864);
  if (*(double *)a2 < v8 && (*(void *)a2 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    if (!*(_DWORD *)(a1 + 1008)) {
      CA::WindowServer::IOMFBServer::set_vsync_enabled((CA::WindowServer::IOMFBServer *)a1);
    }
    *(_DWORD *)(a1 + 1008) = 3
                           * (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 768))(*(void *)(a1 + 96));
    double v7 = *(double *)a2;
    double v8 = *(double *)(a1 + 864);
  }
  uint64_t v10 = *((void *)a2 + 1);
  *(void *)(a1 + 880) |= *((void *)a2 + 2);
  if (v8 >= v7)
  {
    if (v7 == 0.0 || v8 <= v7) {
      v10 |= *(void *)(a1 + 872);
    }
    *(void *)(a1 + 872) = v10;
    *(double *)(a1 + 864) = v7;
  }
LABEL_22:

  return pthread_mutex_unlock(v6);
}

BOOL CA::WindowServer::IOMFBDisplay::is_enabled(CA::WindowServer::IOMFBDisplay *this)
{
  if (!*((void *)this + 80)) {
    return 0;
  }
  if (*((unsigned char *)this + 28132)) {
    return 1;
  }
  return *((unsigned char *)this + 28133) != 0;
}

void CA::WindowServer::IOMFBDisplay::set_enabled(CA::WindowServer::IOMFBDisplay *this, int a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v4 = (char *)this + 26168;
  if (*((unsigned __int8 *)this + 28132) == a2 && !*((unsigned char *)this + 28135))
  {
    if (a2) {
      return;
    }
    if (!*((unsigned char *)this + 28134)) {
      goto LABEL_30;
    }
  }
  else
  {
    if (*((unsigned char *)this + 28132)) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = a2 == 0;
    }
    if (!v5)
    {
      uint64_t v6 = mach_absolute_time();
      atomic_store(COERCE_UNSIGNED_INT64(CATimeWithHostTime(v6)), (unint64_t *)this + 3442);
    }
  }
  v4[1964] = a2;
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    double v7 = x_log_category_display_state;
    if (os_log_type_enabled((os_log_t)x_log_category_display_state, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v16 = a2;
      _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_DEFAULT, "IOMFBDisplay::set_enabled=%u", buf, 8u);
    }
  }
  if (a2)
  {
    if (v4[1967])
    {
      int v8 = v4[1977];
      if (v8 == (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 848))(this))
      {
        int v9 = 0;
      }
      else
      {
        v4[1977] = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 848))(this);
        int v9 = 16;
      }
      float v11 = *(float *)v4;
      if (v11 != (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 904))(this))
      {
        *(float *)int v4 = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 904))(this);
        v9 |= 0x20u;
      }
      float v12 = *((float *)v4 + 21);
      if (v12 != (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1000))(this))
      {
        *((float *)v4 + 21) = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1000))(this);
        v9 |= 0x100u;
      }
      v4[1981] = 1;
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 560));
      CA::WindowServer::IOMFBDisplay::update_framebuffer_locked(this, v9);
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 560));
    }
    else
    {
      int v10 = *((_DWORD *)v4 + 79);
      if (v10)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)this + 560));
        CA::WindowServer::IOMFBDisplay::update_framebuffer_locked(this, v10);
        pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 560));
        *((_DWORD *)v4 + 79) = 0;
      }
    }
  }
  if (((*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 696))(this) & 1) == 0)
  {
    v4[1967] = 0;
    CA::WindowServer::IOMFBDisplay::set_enabled_(this, a2);
  }
  if ((a2 & 1) == 0)
  {
LABEL_30:
    for (uint64_t i = (void *)*((void *)this + 5); i; uint64_t i = (void *)i[1])
    {
      long long v14 = (void **)*i;
      if ((*((unsigned char *)this + 56) & 0x20) != 0)
      {
        ((void (*)(void **, void))(*v14)[24])(v14, 0);
      }
      else if ((*(unsigned int (**)(void *))(*v14[12] + 696))(v14[12]))
      {
        (*(void (**)(void))(**(void **)(*i + 96) + 704))(*(void *)(*i + 96));
      }
    }
    CA::WindowServer::Display::update_clone_flags(this, 0);
  }
}

void CA::WindowServer::IOMFBServer::register_libedr_callbacks(CA::WindowServer::IOMFBServer *this)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 1014) & 4) != 0 && *(unsigned char *)(*((void *)this + 12) + 28209)) {
    CA::WindowServer::IOMFBServer::unregister_libedr_callbacks(this);
  }
  if (CA::WindowServer::IOMFBServer::edr_client(this))
  {
    uint64_t v2 = *((void *)this + 12);
    if (!*(unsigned char *)(v2 + 28209))
    {
      uint64_t v3 = CA::WindowServer::IOMFBServer::edr_client(this);
      pthread_mutex_lock((pthread_mutex_t *)v3);
      unsigned int v4 = *(_DWORD *)(v3 + 152);
      pthread_mutex_unlock((pthread_mutex_t *)v3);
      CA::WindowServer::Display::initialize_edr_state((_DWORD *)v2);
      uint64_t v5 = *(void *)(v2 + 688);
      if (v5) {
        atomic_store(v4, (unsigned int *)(v5 + 4));
      }
      if ((*((unsigned char *)this + 1014) & 4) == 0)
      {
        CA::WindowServer::IOMFBServer::unregister_libedr_callbacks(this);
        uint64_t v6 = (pthread_mutex_t *)CA::WindowServer::IOMFBServer::edr_client(this);
        v10[0] = MEMORY[0x1E4F143A8];
        v10[1] = 0x40000000;
        v10[2] = ___ZN2CA12WindowServer11IOMFBServer25register_libedr_callbacksEv_block_invoke;
        v10[3] = &__block_descriptor_tmp_95;
        _OWORD v10[4] = this;
        if (CADeviceHasBacklight::once != -1) {
          dispatch_once(&CADeviceHasBacklight::once, &__block_literal_global_120);
        }
        if (CADeviceHasBacklight::has_backlight == 1 && CA::EDRClient::client(v6))
        {
          pthread_mutex_lock(v6 + 1);
          if (v6[2].__opaque[11])
          {
            pthread_mutex_unlock(v6 + 1);
            CA::EDRClient::unregister_callback(v6);
            pthread_mutex_lock(v6 + 1);
          }
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            int v9 = x_log_category_utilities;
            if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl(&dword_184668000, v9, OS_LOG_TYPE_DEBUG, "registering libEDR callback\n", buf, 2u);
            }
          }
          CA::EDRClient::client(v6);
          *(void *)long long buf = MEMORY[0x1E4F143A8];
          uint64_t v12 = 0x40000000;
          float v13 = ___ZN2CA9EDRClient17register_callbackEU13block_pointerFvbfffE_block_invoke;
          long long v14 = &unk_1E527FAE8;
          uint64_t v15 = v10;
          int v16 = v6;
          EDRRegisterCallbackBlockOnQueue();
          v6[2].__opaque[11] = 1;
          pthread_mutex_unlock(v6 + 1);
          char v8 = 4;
        }
        else
        {
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            double v7 = x_log_category_utilities;
            if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_DEBUG, "cannot register libEDR callback\n", buf, 2u);
            }
          }
          char v8 = 0;
        }
        *((unsigned char *)this + 1014) = *((unsigned char *)this + 1014) & 0xFB | v8;
      }
    }
  }
}

uint64_t CA::WindowServer::IOMFBServer::edr_client(CA::WindowServer::IOMFBServer *this)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *((void *)this + 104);
  if (!v1)
  {
    if ((*(unsigned char *)(*((void *)this + 12) + 746) & 2) != 0) {
      operator new();
    }
    return 0;
  }
  return v1;
}

void CA::WindowServer::IOMFBServer::add_power_log_timer(CFRunLoopRef *this)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (!this[101])
  {
    v3.versiounint64_t n = 0;
    memset(&v3.retain, 0, 24);
    v3.info = this;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    this[101] = CFRunLoopTimerCreate(0, Current + 300.0, 300.0, 0, 0, (CFRunLoopTimerCallBack)CA::WindowServer::IOMFBServer::add_power_log_timer(void)::$_0::__invoke, &v3);
    CA::WindowServer::IOMFBServer::add_runloop_source((CA::WindowServer::IOMFBServer *)this, 0, 0);
    CFRunLoopAddTimer(this[96], this[101], (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
  }
}

void CA::WindowServer::IOMFBServer::add_vsync_source(CA::WindowServer::IOMFBServer *this, float *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 1014) & 2) != 0)
  {
    if (*((void *)this + 98)) {
      return;
    }
    if (CA::WindowServer::Display::benchmark_mode(0, a2)) {
      return;
    }
    VSyncCFRunLoopSourceRef RunLoopSource = (__CFRunLoopSource *)IOMobileFramebufferGetVSyncRunLoopSource();
    *((void *)this + 98) = VSyncRunLoopSource;
    if (!VSyncRunLoopSource) {
      return;
    }
    CA::WindowServer::IOMFBServer::add_runloop_source(this, VSyncRunLoopSource, 0);
  }
  else
  {
    if (*((void *)this + 100) || (CA::WindowServer::Display::benchmark_mode(0, a2) & 1) != 0) {
      return;
    }
    CA::WindowServer::IOMFBServer::add_runloop_source(this, 0, 0);
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    long long v11 = (unint64_t)this;
    (*(void (**)(void))(**((void **)this + 12) + 744))();
    uint64_t v4 = (_DWORD *)*((void *)this + 12);
    if ((v4[156] & 0x100) != 0) {
      double v3 = (*(double (**)(_DWORD *))(*(void *)v4 + 760))(v4);
    }
    double v5 = v3;
    uint64_t v6 = mach_absolute_time();
    double v7 = CATimeWithHostTime(v6);
    uint64_t v8 = CADisplayTimerCreate((uint64_t)CA::WindowServer::IOMFBServer::timer_callback, &v11, 0, v7, v5);
    *((void *)this + 100) = v8;
    pthread_mutex_lock((pthread_mutex_t *)(v8 + 16));
    *(unsigned char *)(v8 + 201) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 16));
    CA::WindowServer::IOMFBServer::refresh_timer_interval(this);
  }
  if (*((_DWORD *)this + 252)) {
    CA::WindowServer::IOMFBServer::set_vsync_enabled(this);
  }
  uint64_t v10 = *((void *)this + 12);
  if (*(unsigned char *)(v10 + 28209))
  {
    if ((*(_WORD *)(v10 + 656) & 0x1C00) != 0) {
      IOMobileFramebufferSetBrightnessControlCallback();
    }
  }
}

uint64_t CA::WindowServer::IOMFBDisplay::edr_factor_changed(CA::WindowServer::IOMFBDisplay *a1, const CA::Render::LayerNode *a2, CA::Render::Update *this)
{
  CA::Render::Update::render_edr_factor(this, a2);
  float v7 = v6;
  float v8 = *((float *)this + 93);
  int v9 = (float *)*((void *)a2 + 4);
  if (*((void *)a2 + 5))
  {
    if (CA::WindowServer::IOMFBDisplay::use_assembly_surface(a1)) {
      int v9 = (float *)*((void *)a2 + 5);
    }
    uint64_t v10 = v9;
    if (!*((void *)a2 + 4)) {
      return 0;
    }
  }
  else
  {
    uint64_t v10 = (float *)*((void *)a2 + 4);
    if (!v9) {
      return 0;
    }
  }
  if (((*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)a1 + 1536))(a1) & 1) == 0
    && (float)(1.0 / v8) != (*(float (**)(float *))(*(void *)v10 + 192))(v10))
  {
    return 1;
  }
  uint64_t result = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)a1 + 1536))(a1);
  if (!result) {
    return result;
  }
  return (float)(1.0 / v7) != v10[17];
}

void CA::WindowServer::IOMFBDisplay::update_display_headroom(CA::WindowServer::IOMFBDisplay *this)
{
  (*(void (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1104))(this);
  if (!(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 872))(this)) {
    goto LABEL_7;
  }
  if ((*((unsigned char *)this + 746) & 2) == 0)
  {
    if (CADeviceIsVirtualized::once != -1) {
      dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
    }
    if (!CADeviceIsVirtualized::is_virtualized
      && !CA::WindowServer::Display::Mode::is_hdr((CA::WindowServer::IOMFBDisplay *)((char *)this + 640)))
    {
LABEL_7:
      CA::WindowServer::Display::initialize_edr_state(this);
      uint64_t v2 = (unsigned int *)*((void *)this + 86);
      if (v2) {
        atomic_store(0x3F800000u, v2);
      }
    }
  }
}

uint64_t CA::WindowServer::IOMFBDisplay::allows_edr(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28146);
}

uint64_t CA::WindowServer::IOMFBDisplay::update_ui_scale_factor(CA::WindowServer::IOMFBDisplay *this)
{
  int v2 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1536))(this);
  v3.n128_u32[0] = 1.0;
  if (v2)
  {
    if (initialized != -1) {
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    }
    if (*(float *)&dword_1EB2ACB04) {
      v3.n128_f32[0] = truncf(*(float *)&dword_1EB2ACB04);
    }
    else {
      v3.n128_f32[0] = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 920))(this);
    }
    v3.n128_f32[0] = v3.n128_f32[0] * 0.01;
  }
  uint64_t v4 = *(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, __n128))(*(void *)this + 1088);

  return v4(this, v3);
}

BOOL CA::WindowServer::IOMFBDisplay::supports_edr_factor(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned char *)this + 28173) && byte_1EB2ACC05 == 0;
}

float CA::WindowServer::IOMFBDisplay::sdr_nits(CA::WindowServer::IOMFBDisplay *this)
{
  return *((float *)this + 6547);
}

uint64_t CA::WindowServer::IOMFBDisplay::set_ui_scale_factor(uint64_t this, float a2)
{
  *(float *)(this + 26172) = a2;
  return this;
}

double *CA::WindowServer::IOMFBDisplay::update_brightness_deadline(double *this, double a2)
{
  double v2 = this[3316];
  if (v2 != 0.0 && v2 <= a2)
  {
    uint64_t v4 = this;
    CA::WindowServer::IOMFBDisplay::save_brightness_preferences((CA::WindowServer::IOMFBDisplay *)this, 0);
    (*(void (**)(double *))(*(void *)v4 + 952))(v4);
    this = (double *)(*(uint64_t (**)(double *))(*(void *)v4 + 928))(v4);
    v4[3316] = 0.0;
  }
  return this;
}

uint64_t CA::WindowServer::IOMFBDisplay::update_display_edr_factor(CA::WindowServer::IOMFBDisplay *this)
{
  if (CADeviceDisplaySupportsEDRFactor::once[0] != -1) {
    dispatch_once(CADeviceDisplaySupportsEDRFactor::once, &__block_literal_global_69);
  }
  if (!CADeviceDisplaySupportsEDRFactor::supports_edr) {
    return 0;
  }
  double v2 = (float *)((char *)this + 26176);
  (*(void (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1072))(this);
  int v3 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1536))(this);
  float v4 = 0.0;
  if (v3)
  {
    if (CA::WindowServer::Display::Mode::hdr_type(*((void *)this + 80)) - 1 > 1) {
      float v4 = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1096))(this);
    }
    else {
      float v4 = 1.0 / CA::WindowServer::Display::edr_headroom(this);
    }
  }
  if (*v2 == v4) {
    return 0;
  }
  *double v2 = v4;
  if (!(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1840))(this)) {
    return 1;
  }
  if ((*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1872))(this)) {
    *((unsigned char *)this + 28205) = 1;
  }
  uint64_t v5 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1856))(this);
  uint64_t result = 1;
  if (v5) {
    *((unsigned char *)this + 28204) = 1;
  }
  return result;
}

float CA::WindowServer::Display::edr_headroom(CA::WindowServer::Display *this)
{
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  float result = *(float *)&dword_1EB2ACAE8;
  if (*(float *)&dword_1EB2ACAE8 == 0.0)
  {
    int v3 = (unsigned int *)*((void *)this + 86);
    if (v3) {
      return COERCE_FLOAT(atomic_load(v3));
    }
    else {
      return 1.0;
    }
  }
  return result;
}

uint64_t CA::WindowServer::Display::reconciled_display_attributes(CA::WindowServer::Display *this, uint64_t a2)
{
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  uint64_t result = CA::WindowServer::Display::display_attributes(this, (uint64_t *)a2);
  if ((*(_DWORD *)(a2 + 624) & 4) != 0 && (*(unsigned char *)(a2 + 746) & 0x40) == 0 && !byte_1EB2ACC62)
  {
    *((_DWORD *)this + 15) = 1;
    *((unsigned char *)this + 50) = 1;
    *((_DWORD *)this + 5) = 1065353216;
  }
  return result;
}

uint64_t CA::WindowServer::Display::display_attributes(CA::WindowServer::Display *this, uint64_t *a2)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 12) = xmmword_184997E20;
  *((_DWORD *)this + 7) = 1065353216;
  *((_OWORD *)this + 2) = xmmword_184997E30;
  *((void *)this + 6) = 0;
  *((_WORD *)this + 28) = 0;
  *(void *)((char *)this + 60) = 0x100000001;
  *(_OWORD *)((char *)this + 68) = 0u;
  float v4 = (char *)this + 68;
  *(_OWORD *)((char *)this + 84) = 0u;
  *((unsigned char *)this + 100) = 0;
  *((_DWORD *)this + 26) = 1065353216;
  *(void *)((char *)this + 116) = 0;
  *(void *)((char *)this + 108) = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t *))(*a2 + 1216))(&v36, a2);
  *(void *)this = v36;
  *((_DWORD *)this + 2) = v38;
  *((_DWORD *)this + 31) = (*(uint64_t (**)(uint64_t *))(*a2 + 1232))(a2);
  int v5 = (*((unsigned __int16 *)a2 + 328) >> 10) & 7;
  *((unsigned char *)this + 53) = v5 == 2;
  if (v5 == 2)
  {
    BOOL is_hdr = CA::WindowServer::Display::Mode::is_hdr((CA::WindowServer::Display::Mode *)(a2 + 80));
    float v7 = 100.0;
    if (is_hdr) {
      float v7 = 1000.0;
    }
    *((float *)this + 1) = v7;
  }
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  float v8 = *(float *)&dword_1EB2ACAE8;
  if (*(float *)&dword_1EB2ACAE8 == 0.0)
  {
    int v9 = (unsigned int *)a2[86];
    if (v9)
    {
      unsigned int v10 = atomic_load(v9);
      float v8 = *(float *)&v10;
    }
    else
    {
      float v8 = 1.0;
    }
  }
  *((float *)this + 5) = v8;
  *((float *)this + 7) = (*(float (**)(uint64_t *))(*a2 + 1096))(a2);
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  int v11 = dword_1EB2ACB08;
  if (*(float *)&dword_1EB2ACB08 != 0.0 || (int v11 = v37, *(float *)&v37 > 0.0)) {
    *((_DWORD *)this + 3) = v11;
  }
  float v12 = *(float *)&dword_1EB2ACB0C;
  uint64_t v13 = *a2;
  if (*(float *)&dword_1EB2ACB0C == 0.0) {
    float v12 = *((float *)&v37 + 1);
  }
  *((float *)this + 4) = v12;
  *((double *)this + 4) = (*(double (**)(uint64_t *))(v13 + 24))(a2);
  *((double *)this + 5) = (*(double (**)(uint64_t *))(*a2 + 32))(a2);
  *((unsigned char *)this + 48) = (*(uint64_t (**)(uint64_t *))(*a2 + 1264))(a2);
  *((unsigned char *)this + 49) = (*(float (**)(uint64_t *))(*a2 + 1272))(a2) > 0.0;
  int v14 = (*(_DWORD *)((char *)a2 + 745) >> 9) & 1;
  *((unsigned char *)this + 51) = (*(_DWORD *)((unsigned char *)a2 + 745) & 0x200) != 0;
  *((unsigned char *)this + 56) = (*(uint64_t (**)(uint64_t *))(*a2 + 1848))(a2);
  *((unsigned char *)this + 57) = (*(uint64_t (**)(uint64_t *))(*a2 + 1904))(a2);
  switch(CA::WindowServer::Display::Mode::hdr_type(a2[80]))
  {
    case 1u:
      v15.n128_u32[1] = 2;
      *(void *)((char *)this + 60) = 0x200000001;
      goto LABEL_40;
    case 2u:
      uint64_t v16 = a2[86];
      if (v16)
      {
        float v17 = COERCE_FLOAT(atomic_load((unsigned int *)(v16 + 4)));
        LOBYTE(v16) = v5 == 0;
        if (!v5 && v17 > 8.0)
        {
          LOBYTE(v16) = 1;
          int v18 = 6;
          goto LABEL_32;
        }
      }
      else
      {
        uint64_t v16 = v5 == 0;
      }
      int v18 = 0;
LABEL_32:
      *((_DWORD *)this + 15) = v18;
      if (CADeviceHasHeadroomDependentGamma::once[0] != -1)
      {
        char v35 = v16;
        dispatch_once(CADeviceHasHeadroomDependentGamma::once, &__block_literal_global_138);
        LOBYTE(v16) = v35;
      }
      char v20 = v16 ^ 1;
      if (!CADeviceHasHeadroomDependentGamma::supports_hdr_gamma) {
        char v20 = 1;
      }
      if (v20) {
        int v21 = 2;
      }
      else {
        int v21 = 3;
      }
      *((_DWORD *)this + 16) = v21;
LABEL_40:
      if (CADeviceIsVirtualized::once != -1) {
        dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
      }
      if (CADeviceIsVirtualized::is_virtualized && CA::WindowServer::Display::Mode::hdr_type(a2[80]) == 3)
      {
        *(void *)((char *)this + 60) = 0x100000005;
        *(void *)this = 0x447A000000000000;
        __n128 v15 = (__n128)xmmword_184998090;
        *(_OWORD *)((char *)this + 12) = xmmword_184998090;
      }
      if (initialized != -1) {
        dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
      }
      v15.n128_u32[0] = dword_1EB2ACB28;
      if (*(float *)&dword_1EB2ACB28 != 0.0)
      {
        float v22 = *((float *)this + 3);
        float v23 = *((float *)this + 5);
        if (*(float *)&dword_1EB2ACB28 >= v23) {
          v15.n128_u32[0] = *((_DWORD *)this + 5);
        }
        *((_DWORD *)this + 5) = v15.n128_u32[0];
        v15.n128_f32[0] = (float)(v15.n128_f32[0] * v22) / v23;
        *((_DWORD *)this + 3) = v15.n128_u32[0];
      }
      int v24 = *(_DWORD *)((char *)a2 + 745);
      *((unsigned char *)this + 54) = (v24 & 0x4000) != 0;
      if ((v24 & 0x4000) != 0) {
        *((_DWORD *)this + 16) = 1;
      }
      (*(void (**)(_OWORD *__return_ptr, uint64_t *, __n128))(*a2 + 1352))(v39, a2, v15);
      long long v25 = v39[1];
      *(_OWORD *)float v4 = v39[0];
      *((_OWORD *)v4 + 1) = v25;
      v4[32] = v40;
      uint64_t v26 = (*(uint64_t (**)(uint64_t *))(*a2 + 1240))(a2);
      if (!v26) {
        goto LABEL_67;
      }
      float v27 = *((float *)this + 3);
      BOOL v28 = *(float **)v26;
      float v29 = **(float **)v26;
      float v30 = 1.0;
      if (v29 >= v27) {
        goto LABEL_66;
      }
      unint64_t v31 = *(void *)(v26 + 32);
      if (v28[v31 - 1] <= v27)
      {
        float v30 = *(float *)(*(void *)(v26 + 8) + 4 * (v31 - 1));
        goto LABEL_66;
      }
      if (*(float *)(v26 + 44) == v27)
      {
        float v30 = *(float *)(v26 + 40);
        goto LABEL_66;
      }
      if (v31 < 2) {
        goto LABEL_63;
      }
      uint64_t v32 = 1;
      break;
    case 3u:
      if (v14) {
        int v19 = 5;
      }
      else {
        int v19 = 2;
      }
      goto LABEL_29;
    case 4u:
      int v19 = 4;
      goto LABEL_29;
    case 5u:
      int v19 = 3;
LABEL_29:
      *((_DWORD *)this + 15) = v19;
      goto LABEL_40;
    default:
      goto LABEL_40;
  }
  while (v28[v32] < v27)
  {
    if (v31 == ++v32)
    {
LABEL_63:
      uint64_t v33 = 0;
      uint64_t v32 = 1;
      goto LABEL_65;
    }
  }
  uint64_t v33 = v32 - 1;
  float v29 = v28[v32 - 1];
LABEL_65:
  float v30 = (float)((float)((float)(*(float *)(*(void *)(v26 + 8) + 4 * v32) - *(float *)(*(void *)(v26 + 8) + 4 * v33))
                      * (float)(v27 - v29))
              / (float)(v28[v32] - v29))
      + *(float *)(*(void *)(v26 + 8) + 4 * v33);
  *(float *)(v26 + 40) = v30;
  *(float *)(v26 + 44) = v27;
  float v29 = *v28;
LABEL_66:
  *((float *)this + 26) = v30;
  *(void *)((char *)this + 108) = *(void *)(v26 + 16);
  *((_DWORD *)this + 29) = *(_DWORD *)(v26 + 24);
  *((float *)this + 30) = v29;
LABEL_67:
  uint64_t result = (*(uint64_t (**)(uint64_t *))(*a2 + 80))(a2);
  *((unsigned char *)this + 55) = result;
  return result;
}

uint64_t CA::WindowServer::Display::Mode::hdr_type(unint64_t this)
{
  unint64_t v1 = (this >> 55) & 0x1F;
  if (!this || (this & 0x10000000) != 0)
  {
    if (CADeviceIsVirtualized::once != -1) {
      dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
    }
    if (((v1 - 22) & 0xFFFFFFFD) != 0) {
      unsigned int v3 = 2;
    }
    else {
      unsigned int v3 = 3;
    }
    if (CADeviceIsVirtualized::is_virtualized) {
      return v3;
    }
    else {
      return 2;
    }
  }
  else if ((v1 - 16) > 0xC)
  {
    return 1;
  }
  else
  {
    return dword_18499AEE8[(v1 - 16)];
  }
}

float CA::WindowServer::IOMFBDisplay::low_ambient_adaptation_strength(CA::WindowServer::IOMFBDisplay *this)
{
  return *((float *)this + 6554);
}

double CA::WindowServer::AppleDisplay::min_scale(CA::WindowServer::AppleDisplay *this)
{
  return *((double *)this + 3562);
}

double CA::WindowServer::AppleDisplay::max_scale(CA::WindowServer::AppleDisplay *this)
{
  return *((double *)this + 3563);
}

__n128 CA::WindowServer::IOMFBDisplay::luminance@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = this[1641];
  *a2 = result;
  a2[1].n128_u64[0] = this[1642].n128_u64[0];
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::average_pixel_constraints(CA::WindowServer::IOMFBDisplay *this)
{
  return *((void *)this + 3408);
}

uint64_t CA::WindowServer::IOMFBDisplay::supports_ambient_adaptation(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28180);
}

uint64_t CA::WindowServer::IOMFBDisplay::edr_scaling_applied_in_gp(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28222);
}

uint64_t CA::WindowServer::IOMFBDisplay::supports_display_tonemap(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28208);
}

uint64_t CA::WindowServer::IOMFBDisplay::dm_version(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned int *)this + 6570);
}

__n128 CA::WindowServer::IOMFBDisplay::chromaticity@<Q0>(CA::WindowServer::IOMFBDisplay *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result = *(__n128 *)((char *)this + 26284);
  long long v3 = *(_OWORD *)((char *)this + 26300);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 32) = *((_DWORD *)this + 6579);
  return result;
}

float CA::WindowServer::IOMFBDisplay::ui_scale_factor(CA::WindowServer::IOMFBDisplay *this)
{
  return *((float *)this + 6543);
}

uint64_t CA::WindowServer::IOMFBDisplay::mark_buffers_non_static(uint64_t this, uint64_t a2)
{
  double v2 = *(void **)(this + 26032);
  if (v2)
  {
    uint64_t v4 = this;
    int v5 = (_DWORD *)(this + 25388);
    do
    {
      this = v2[4];
      if (this)
      {
        uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)this + 216))(this);
        this = v2[4];
        if ((v6 != a2
           || *(_DWORD *)(this + 56) != *(_DWORD *)(v4 + 208)
           || *(_DWORD *)(this + 60) != *(_DWORD *)(v4 + 212))
          && (*(_DWORD *)(this + 224) & 0x4000000) != 0)
        {
          this = (*(uint64_t (**)(uint64_t))(*(void *)this + 216))(this);
          if (this)
          {
            uint64_t v7 = v2[4];
            if ((*(_DWORD *)(v7 + 224) & 0xC000000) == 0x4000000)
            {
              unint64_t v8 = *(_DWORD *)(v7 + 224) & 0xFBFFFFFF | ((unint64_t)*(unsigned __int8 *)(v7 + 228) << 32);
              *(_DWORD *)(v7 + 224) &= ~0x4000000u;
              *(unsigned char *)(v7 + 228) = BYTE4(v8);
              --*v5;
            }
          }
        }
      }
      double v2 = (void *)*v2;
    }
    while (v2);
  }
  return this;
}

uint64_t CA::WindowServer::IOSurface::protection_options(CA::WindowServer::IOSurface *this)
{
  uint64_t result = *((void *)this + 30);
  if (result) {
    return IOSurfaceGetProtectionOptions();
  }
  return result;
}

uint64_t CA::WindowServer::Display::benchmark_mode(CA::WindowServer::Display *this, float *a2)
{
  if ((CA::WindowServer::Display::benchmark_mode(float *)const::initialized & 1) == 0)
  {
    long long v3 = getenv("CA_BENCHMARK");
    if (v3 || (long long v3 = getenv("LK_BENCHMARK")) != 0)
    {
      int v4 = atoi(v3);
      CA::WindowServer::Display::benchmark_mode(float *)const::benchmark_mode = v4 != 0;
      if (v4 >= 61)
      {
        float v5 = 1.0 / (float)v4;
LABEL_8:
        CA::WindowServer::Display::benchmark_mode(float *)const::benchmark_rate = LODWORD(v5);
        CA::WindowServer::Display::benchmark_mode(float *)const::initialized = 1;
        goto LABEL_9;
      }
    }
    else
    {
      CA::WindowServer::Display::benchmark_mode(float *)const::benchmark_mode = 0;
    }
    float v5 = 0.002;
    goto LABEL_8;
  }
LABEL_9:
  if (this) {
    *(_DWORD *)this = CA::WindowServer::Display::benchmark_mode(float *)const::benchmark_rate;
  }
  return CA::WindowServer::Display::benchmark_mode(float *)const::benchmark_mode;
}

uint64_t CA::WindowServer::Server::set_next_update(uint64_t a1, unint64_t *a2, __n128 a3)
{
  double v4 = a3.n128_f64[0];
  a3.n128_u64[0] = *a2;
  if (*(double *)a2 == 0.0)
  {
    uint64_t v6 = mach_absolute_time();
    a3.n128_f64[0] = CATimeWithHostTime(v6);
    *a2 = a3.n128_u64[0];
    a2[1] = 0;
    a2[2] = 0;
  }
  if (v4 != 0.0)
  {
    double v7 = (*(double (**)(uint64_t, __n128))(*(void *)a1 + 408))(a1, a3) + v4;
    a3.n128_u64[0] = *a2;
    if (*(double *)a2 < v7)
    {
      *(double *)a2 = v7;
      a3.n128_f64[0] = v7;
      a2[1] = 0;
      a2[2] = 0;
    }
  }

  return CA::Render::Server::add_callback(3, (uint64_t)CA::WindowServer::Server::timer_callback, a1, a3.n128_f64[0]);
}

double CA::Render::SpringAnimation::time_derivative(CA::Render::SpringAnimation *this, double a2, const double *a3)
{
  uint64_t v5 = *((void *)this + 5);
  if (v5) {
    double v6 = *(double *)(v5 + 32);
  }
  else {
    double v6 = INFINITY;
  }
  double v7 = CA::Render::Animation::time_derivative(this, a2, a3);
  unint64_t v8 = (CA::Render::SpringAnimation *)((char *)this + 192);
  double v9 = v6 * a2;
  CA::Render::SpringAnimation::State::eval_derivative(v8, v9);
  double v11 = v10;
  CA::Render::SpringAnimation::State::eval_derivative(v8, v9 + 0.0166666667);
  if (fabs(v11) > fabs(v12)) {
    double v12 = v11;
  }
  return v7 * v6 * v12;
}

void CA::Render::GroupAnimation::apply(CA::Render::GroupAnimation *this, CA::Render::AnimationEvaluator *a2, __n128 a3, int a4, unsigned int a5)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v21 = a4;
  uint64_t v5 = *((void *)this + 12);
  if (v5)
  {
    double v7 = a3.n128_f64[0];
    uint64_t v9 = *((void *)this + 5);
    if (v9) {
      double v10 = *(double *)(v9 + 32);
    }
    else {
      double v10 = INFINITY;
    }
    float v11 = *((float *)a2 + 2);
    float v12 = v10
        * v11
        * (*(double (**)(CA::Render::GroupAnimation *, __n128))(*(void *)this + 128))(this, a3);
    *((float *)a2 + 2) = v12;
    unint64_t v13 = *(unsigned int *)(v5 + 16);
    if (v13)
    {
      unint64_t v14 = 0;
      double v15 = v10 * v7;
      do
      {
        uint64_t v16 = *(CA::Render::Animation **)(v5 + 24 + 8 * v14);
        if (*((unsigned char *)v16 + 13))
        {
          BOOL v20 = 0;
          double v19 = v15;
          if (CA::Render::Animation::map_time(v16, &v19, &v21, 0, &v20))
          {
            v17.n128_f64[0] = v19;
            if (v20) {
              uint64_t v18 = 1;
            }
            else {
              uint64_t v18 = a5;
            }
            (*(void (**)(CA::Render::Animation *, CA::Render::AnimationEvaluator *, void, uint64_t, __n128))(*(void *)v16 + 120))(v16, a2, v21, v18, v17);
          }
          unint64_t v13 = *(unsigned int *)(v5 + 16);
        }
        ++v14;
      }
      while (v14 < v13);
    }
    *((float *)a2 + 2) = v11;
  }
}

double CA::Render::Animation::time_derivative(CA::Render::Animation *this, double a2, const double *a3)
{
  uint64_t v3 = *((void *)this + 5);
  double v4 = 1.0;
  if (v3)
  {
    double v5 = *(double *)(v3 + 32);
    double v6 = *(float *)(v3 + 16);
  }
  else
  {
    double v5 = INFINITY;
    double v6 = 1.0;
  }
  uint64_t v7 = *((void *)this + 6);
  if (v7 && *(_DWORD *)(v7 + 16) == 4) {
    double v4 = CA::Render::TimingFunction::evaluate_derivative_inverse((CA::Render::TimingFunction *)(v7 + 24), a3, a2, 0.001 / v5);
  }
  return v4 * v6 / v5;
}

double CA::Render::TimingFunction::evaluate_derivative_inverse(CA::Render::TimingFunction *this, const double *a2, double a3, double a4)
{
  double v4 = *((double *)this + 1);
  double v5 = *(double *)this * 3.0;
  double v6 = (*((double *)this + 2) - *(double *)this) * 3.0;
  double v7 = v6 - v5;
  double v8 = 1.0 - v6;
  double v9 = v4 * 3.0;
  double v10 = (*((double *)this + 3) - v4) * 3.0;
  double v11 = v10 - v9;
  double v12 = 1.0 - v10;
  double v13 = v11 + v11;
  int v14 = 8;
  double v15 = a3;
  while (1)
  {
    double v16 = -(a3 - (v9 + (v11 + v15 * v12) * v15) * v15);
    if (fabs(v16) < a4) {
      break;
    }
    double v17 = v9 + (v13 + v12 * 3.0 * v15) * v15;
    if (fabs(v17) >= 0.000001)
    {
      double v15 = v15 - v16 / v17;
      if (--v14) {
        continue;
      }
    }
    double v15 = 0.0;
    if (a3 >= 0.0)
    {
      double v15 = 1.0;
      if (a3 <= 1.0)
      {
        double v18 = 0.0;
        double v19 = 1.0;
        int v20 = -1025;
        double v15 = a3;
        do
        {
          if (__CFADD__(v20++, 1)) {
            break;
          }
          double v22 = -(a3 - (v9 + (v11 + v15 * v12) * v15) * v15);
          if (fabs(v22) < a4) {
            break;
          }
          if (v22 >= 0.0) {
            double v19 = v15;
          }
          else {
            double v18 = v15;
          }
          double v15 = v18 + (v19 - v18) * 0.5;
        }
        while (v18 < v19);
      }
    }
    break;
  }
  double v23 = v9 + (v13 + v15 * 3.0 * v12) * v15;
  double v24 = v7 + v7;
  double v25 = v5 + (v24 + v15 * 3.0 * v8) * v15;
  if (v23 == 0.0 && v25 == 0.0)
  {
    double v23 = v13 + v15 * 6.0 * v12;
    double v25 = v24 + v15 * 6.0 * v8;
  }
  return v23 / v25;
}

void CA::Render::SpringAnimation::State::eval_derivative(CA::Render::SpringAnimation::State *this, double a2)
{
  double v4 = *((double *)this + 1);
  if (v4 >= 1.0)
  {
    if (v4 > 1.0 && *((unsigned char *)this + 40))
    {
      double v5 = *((double *)this + 2);
      double v6 = *(double *)this * v4;
      exp(-((v6 + v5) * a2));
      exp((v5 - v6) * a2);
    }
    else
    {
      exp(-(a2 * *(double *)this));
    }
  }
  else
  {
    exp(-(a2 * v4) * *(double *)this);
    __sincos_stret(*((double *)this + 2) * a2);
  }
}

uint64_t CASApplyFenceTransaction(unsigned int a1, mach_vm_address_t a2, unsigned int a3, vm_address_t a4, unsigned int a5, int a6, vm_address_t *a7, _DWORD *a8, vm_address_t *a9, unsigned int *a10, _DWORD *a11, _DWORD *a12, unsigned char *a13, void *a14)
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  vm_address_t v92 = a4;
  unint64_t v18 = a3;
  unint64_t v19 = a5;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  int v21 = malloc_type_zone_malloc(malloc_zone, 0x28uLL, 0x8BB15036uLL);
  unint64_t v22 = 0;
  v21[1] = 0;
  v21[2] = 0;
  *int v21 = 0;
  *((unsigned char *)v21 + 24) = 0;
  *((unsigned char *)v21 + 25) = a6 != 0;
  v21[4] = 0;
  uint64_t v95 = 1065353216;
  uint64_t v23 = a1;
  long long v93 = 0u;
  long long v94 = 0u;
  unsigned int v85 = a3;
  mach_vm_address_t v90 = a2;
  if (a1 < a3)
  {
    mach_vm_address_t v24 = a2;
    unint64_t v25 = 0;
    unint64_t v22 = v18 - a1;
    mach_vm_address_t v26 = v24 + 4 * a1;
    do
    {
      if (v25 < v19)
      {
        LODWORD(address) = *(_DWORD *)(v92 + 4 * v25);
        unsigned int v27 = address;
        if (!std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::find<unsigned int>(v93, *((unint64_t *)&v93 + 1), address))
        {
          uint64_t v28 = CA::Render::Context::context_by_server_port((CA::Render::Context *)*(unsigned int *)(v26 + 4 * v25));
          if (v28) {
            std::__hash_table<std::__hash_value_type<unsigned int,CA::Render::Context *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Context *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Context *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::Render::Context *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v93, v27, &address)[3] = v28;
          }
        }
      }
      ++v25;
    }
    while (v22 != v25);
    a2 = v90;
  }
  if (a1)
  {
    unint64_t v29 = 0;
    do
    {
      float v30 = (malloc_zone_t *)get_malloc_zone();
      unint64_t v31 = malloc_type_zone_malloc(v30, 0x20uLL, 0x8BB15036uLL);
      uint64_t v32 = v31;
      *(void *)unint64_t v31 = *v21;
      if (v29 >= v18) {
        int v33 = 0;
      }
      else {
        int v33 = *(_DWORD *)(a2 + 4 * v29);
      }
      v31[2] = v33;
      *((void *)v31 + 2) = 0;
      *((void *)v31 + 3) = 0;
      *int v21 = v31;
      if (v22 < v19)
      {
        while (1)
        {
          unsigned int v34 = *(_DWORD *)(v92 + 4 * v22);
          if (!v34) {
            break;
          }
          char v35 = std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::find<unsigned int>(v93, *((unint64_t *)&v93 + 1), v34);
          if (v35)
          {
            uint64_t v36 = v35;
            uint64_t v37 = (malloc_zone_t *)get_malloc_zone();
            uint64_t v38 = malloc_type_zone_malloc(v37, 0x18uLL, 0x8BB15036uLL);
            *uint64_t v38 = *((void *)v32 + 3);
            v38[1] = 0;
            void v38[2] = v36[3];
            *((void *)v32 + 3) = v38;
          }
          if (v19 == ++v22)
          {
            unint64_t v22 = v19;
            break;
          }
        }
      }
      ++v22;
      ++v29;
    }
    while (v29 != v23);
  }
  if (v22 < v19)
  {
    do
    {
      uint64_t v39 = std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::find<unsigned int>(v93, *((unint64_t *)&v93 + 1), *(_DWORD *)(v92 + 4 * v22));
      if (v39)
      {
        char v40 = v39;
        uint64_t v41 = (malloc_zone_t *)get_malloc_zone();
        double v42 = malloc_type_zone_malloc(v41, 0x18uLL, 0x8BB15036uLL);
        *double v42 = v21[1];
        v42[1] = 0;
        void v42[2] = v40[3];
        v21[1] = v42;
      }
      ++v22;
    }
    while (v19 != v22);
  }
  uint64_t v43 = CA::Render::Fence::applyTransaction((uint64_t **)v21);
  while (1)
  {
    int v44 = (uint64_t *)*v21;
    if (!*v21) {
      break;
    }
    uint64_t v45 = (void *)v44[3];
    if (v45)
    {
      do
      {
        BOOL v46 = (void *)*v45;
        double v47 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v47, v45);
        uint64_t v45 = v46;
      }
      while (v46);
      int v44 = (uint64_t *)*v21;
    }
    *int v21 = *v44;
    float v48 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v48, v44);
  }
  while (1)
  {
    float v50 = (void *)v21[1];
    if (!v50) {
      break;
    }
    v21[1] = *v50;
    float v49 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v49, v50);
  }
  mach_vm_size_t v51 = 4 * a5;
  CFNumberRef v52 = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(v52, v21);
  for (uint64_t i = (void *)v94; i; uint64_t i = (void *)*i)
  {
    float v54 = (atomic_uint *)i[3];
    if (v54 && atomic_fetch_add(v54 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v54 + 16))(v54);
    }
  }
  uint64_t j = (vm_map_t *)MEMORY[0x1E4F14960];
  if (!v43)
  {
    *a7 = 0;
    *a8 = 0;
    vm_address_t v92 = 0;
    *a9 = 0;
    *a10 = 0;
    *a11 = 0;
    *a12 = 0;
    *a13 = 0;
    *a14 = 0;
    goto LABEL_83;
  }
  uint64_t v56 = (void *)*v43;
  if (*v43)
  {
    uint64_t v57 = 0;
    unint64_t v58 = 0;
    do
    {
      float v59 = v56 + 3;
      do
      {
        float v59 = (void *)*v59;
        ++v57;
      }
      while (v59);
      ++v58;
      uint64_t v56 = (void *)*v56;
    }
    while (v56);
  }
  else
  {
    unint64_t v58 = 0;
    uint64_t v57 = 0;
  }
  uint64_t v60 = (void **)(v43 + 1);
  uint64_t v61 = v57 - 1;
  int v62 = v43 + 1;
  do
  {
    int v62 = (void *)*v62;
    ++v61;
  }
  while (v62);
  vm_address_t address = 0;
  float v63 = (void *)MEMORY[0x1E4F14B00];
  if (v58)
  {
    vm_allocate(*MEMORY[0x1E4F14960], &address, (*MEMORY[0x1E4F14B00] + 8 * v58 - 1) & -*MEMORY[0x1E4F14B00], 1);
    vm_address_t v64 = address;
    if (address) {
      unint64_t v65 = v58;
    }
    else {
      unint64_t v65 = 0;
    }
  }
  else
  {
    vm_address_t v64 = 0;
    unint64_t v65 = 0;
  }
  *a7 = v64;
  *a8 = v65;
  vm_address_t v92 = 0;
  if (v61)
  {
    vm_allocate(*MEMORY[0x1E4F14960], &v92, (*v63 + 4 * v61 - 1) & -*v63, 1);
    vm_address_t v66 = v92;
    if (v92) {
      unsigned int v67 = v61;
    }
    else {
      unsigned int v67 = 0;
    }
  }
  else
  {
    vm_address_t v66 = 0;
    unsigned int v67 = 0;
  }
  *a9 = v66;
  *a10 = v67;
  *a11 = 0;
  *a12 = 0;
  *a13 = 0;
  *a14 = 0;
  float v68 = (void *)*v43;
  if (*((unsigned char *)v43 + 24))
  {
    if (!v68) {
      goto LABEL_77;
    }
    int v69 = (void *)*v43;
    do
    {
      int v70 = v69;
      int v69 = (void *)*v69;
    }
    while (v69);
    if (v68 != v70)
    {
      void *v70 = v68;
      int v71 = (void *)*v68;
      *uint64_t v43 = *v68;
      *float v68 = 0;
      float v68 = v71;
    }
  }
  if (v68)
  {
    unint64_t v72 = 0;
    unint64_t v73 = 0;
    do
    {
      if (v72 < v65) {
        *(void *)(address + 8 * v72++) = v68[2];
      }
      while (1)
      {
        int v75 = (_DWORD *)v68[3];
        if (!v75) {
          break;
        }
        if (v73 < v67) {
          *(_DWORD *)(v92 + 4 * v73++) = v75[3];
        }
        v68[3] = *(void *)v75;
        uint64_t v74 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v74, v75);
      }
      if (v73 < v67) {
        *(_DWORD *)(v92 + 4 * v73++) = 0;
      }
      *uint64_t v43 = *v68;
      uint64_t v76 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v76, v68);
      float v68 = (void *)*v43;
    }
    while (*v43);
    goto LABEL_78;
  }
LABEL_77:
  unint64_t v73 = 0;
LABEL_78:
  char v77 = *v60;
  for (uint64_t j = (vm_map_t *)MEMORY[0x1E4F14960]; *v60; v77 = *v60)
  {
    if (v73 < v67) {
      *(_DWORD *)(v92 + 4 * v73++) = v77[3];
    }
    *uint64_t v60 = *(void **)v77;
    float64x2_t v78 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v78, v77);
  }
  *a11 = *((_DWORD *)v43 + 4);
  *a12 = *((_DWORD *)v43 + 5);
  *a13 = *((unsigned char *)v43 + 24);
  *a14 = v43[4];
  int64x2_t v79 = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(v79, v43);
  a2 = v90;
  mach_vm_size_t v51 = 4 * a5;
LABEL_83:
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v93);
  uint64_t result = mach_vm_deallocate(*j, a4, v51);
  if (a2 && v85)
  {
    float64x2_t v81 = (mach_port_name_t *)a2;
    unint64_t v82 = v18;
    do
    {
      mach_port_name_t v84 = *v81++;
      mach_port_name_t v83 = v84;
      if (v84) {
        mach_port_deallocate(*j, v83);
      }
      --v82;
    }
    while (v82);
    return mach_vm_deallocate(*j, a2, 4 * v18);
  }
  return result;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::find<unsigned int>(uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }
  else
  {
    unint64_t v4 = (a2 - 1) & a3;
  }
  double v5 = *(uint64_t ***)(a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (uint64_t result = *v5; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a3)
    {
      if (*((_DWORD *)result + 4) == a3) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= a2) {
          v7 %= a2;
        }
      }
      else
      {
        v7 &= a2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void CA::WindowServer::IOMFBDisplay::update_frame_interval_reason_statistics(CA::WindowServer::IOMFBDisplay *this, double a2, double a3, unsigned int *a4, unsigned int a5)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  double v5 = COERCE_DOUBLE(atomic_load((unint64_t *)this + 3442));
  if (v5 > a3) {
    a3 = v5;
  }
  if (*((unsigned char *)this + 28132))
  {
    double v6 = a2 - a3;
    if (a2 - a3 >= 0.0
      && v6 >= (*(double (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 760))(this) + -0.001)
    {
      double v10 = v6 + -0.001;
      unsigned int v29 = a5;
      if (v6 + -0.001 >= 0.00833333333)
      {
        if (v10 >= 0.0125)
        {
          if (v10 >= 0.0166666667)
          {
            BOOL v11 = v10 >= 0.0208333333;
            if (v10 < 0.0208333333) {
              uint64_t v12 = 0;
            }
            else {
              uint64_t v12 = -1;
            }
          }
          else
          {
            BOOL v11 = 0;
            uint64_t v12 = 4;
          }
        }
        else
        {
          BOOL v11 = 0;
          uint64_t v12 = 8;
        }
      }
      else
      {
        BOOL v11 = 0;
        uint64_t v12 = 12;
      }
      unsigned int v13 = (v10 * 1000.0 + 1.0);
      uint64_t v28 = (os_unfair_lock_s *)((char *)this + 27448);
      os_unfair_lock_lock((os_unfair_lock_t)this + 6862);
      locuint64_t k = (os_unfair_lock_s *)((char *)this + 27480);
      os_unfair_lock_lock((os_unfair_lock_t)this + 6870);
      memset(v32, 0, sizeof(v32));
      uint64_t v33 = 1065353216;
      uint64_t v14 = *((void *)this + 3432);
      float v30 = this;
      uint64_t v15 = *((void *)this + 3433);
      if (v14 != v15)
      {
        double v16 = (float *)((char *)this + 27488);
        do
        {
          if (!*(unsigned char *)(v14 + 24))
          {
            for (uint64_t i = 8; i != 24; i += 4)
            {
              unsigned int v18 = *(_DWORD *)(v14 + i);
              unsigned int v31 = v18;
              if (!v18) {
                break;
              }
              unint64_t v19 = std::__hash_table<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v16, v18, &v31);
              int v20 = v19;
              if (!v11) {
                ++*(_DWORD *)((char *)v19 + v12 + 20);
              }
              if (!std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v32, v18))
              {
                *((_DWORD *)v20 + 9) += v13;
                std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)v32, v18, v18);
              }
            }
          }
          v14 += 28;
        }
        while (v14 != v15);
      }
      if (v29)
      {
        uint64_t v21 = v29;
        do
        {
          unsigned int v23 = *a4++;
          unsigned int v22 = v23;
          unsigned int v31 = v23;
          mach_vm_address_t v24 = std::__hash_table<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)v30 + 6872, v23, &v31);
          unint64_t v25 = v24;
          if (!v11) {
            ++*(_DWORD *)((char *)v24 + v12 + 20);
          }
          if (!std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v32, v22))*((_DWORD *)v25 + 9) += v13; {
          --v21;
          }
        }
        while (v21);
      }
      mach_vm_address_t v26 = std::__hash_table<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)v30 + 6872, 0xFFFFFFFF, &kCAHighFrameRateReasonTotal);
      if (!v11) {
        ++*(_DWORD *)((char *)v26 + v12 + 20);
      }
      *((_DWORD *)v26 + 9) += v13;
      std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v32);
      os_unfair_lock_unlock(lock);
      os_unfair_lock_unlock(v28);
    }
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::FrameRateBuckets>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(float *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *((void *)a1 + 1);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    double v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      double v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          double v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  double v10 = operator new(0x28uLL);
  *double v10 = 0;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  *(void *)((char *)v10 + 28) = 0;
  *(void *)((char *)v10 + 20) = 0;
  *((_DWORD *)v10 + 9) = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    BOOL v14 = 1;
    if (v6 >= 3) {
      BOOL v14 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v6);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      int8x8_t prime = (int8x8_t)v16;
    }
    else {
      int8x8_t prime = (int8x8_t)v15;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v6 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v6) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v6)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v6 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (*(void *)&prime <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      if (*(void *)&prime >= v6)
      {
        unint64_t v6 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unsigned int v18 = operator new(8 * *(void *)&prime);
          unint64_t v19 = *(void **)a1;
          *(void *)a1 = v18;
          if (v19) {
            operator delete(v19);
          }
          uint64_t v20 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v20++) = 0;
          while (*(void *)&prime != v20);
          uint64_t v21 = (void *)*((void *)a1 + 2);
          if (v21)
          {
            unint64_t v22 = v21[1];
            uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
            v23.i16[0] = vaddlv_u8(v23);
            if (v23.u32[0] > 1uLL)
            {
              if (v22 >= *(void *)&prime) {
                v22 %= *(void *)&prime;
              }
            }
            else
            {
              v22 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
            unsigned int v27 = (void *)*v21;
            if (*v21)
            {
              do
              {
                unint64_t v28 = v27[1];
                if (v23.u32[0] > 1uLL)
                {
                  if (v28 >= *(void *)&prime) {
                    v28 %= *(void *)&prime;
                  }
                }
                else
                {
                  v28 &= *(void *)&prime - 1;
                }
                if (v28 != v22)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v28))
                  {
                    *(void *)(*(void *)a1 + 8 * v28) = v21;
                    goto LABEL_55;
                  }
                  *uint64_t v21 = *v27;
                  *unsigned int v27 = **(void **)(*(void *)a1 + 8 * v28);
                  **(void **)(*(void *)a1 + 8 * v28) = v27;
                  unsigned int v27 = v21;
                }
                unint64_t v28 = v22;
LABEL_55:
                uint64_t v21 = v27;
                unsigned int v27 = (void *)*v27;
                unint64_t v22 = v28;
              }
              while (v27);
            }
          }
          unint64_t v6 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v33 = *(void **)a1;
        *(void *)a1 = 0;
        if (v33) {
          operator delete(v33);
        }
        unint64_t v6 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  unsigned int v29 = *(void **)a1;
  float v30 = *(void **)(*(void *)a1 + 8 * v8);
  if (v30)
  {
    *double v10 = *v30;
LABEL_72:
    *float v30 = v10;
    goto LABEL_73;
  }
  *double v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v8] = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v31 >= v6) {
        v31 %= v6;
      }
    }
    else
    {
      v31 &= v6 - 1;
    }
    float v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

BOOL CA::Render::Fence::resolve_batches(CA::Render::Fence *this, double a2)
{
  v113[3] = *(void ***)MEMORY[0x1E4F143B8];
  long long v110 = 0u;
  long long v111 = 0u;
  uint64_t v112 = 1065353216;
  memset(v108, 0, sizeof(v108));
  uint64_t v109 = 1065353216;
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>((uint64_t)&v110, (unint64_t)(float)*(unint64_t *)(CA::Render::Fence::cleared_b_ports + 24));
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>((uint64_t)v108, (unint64_t)(float)*(unint64_t *)(CA::Render::Fence::batches_by_port + 24));
  for (uint64_t i = *(uint64_t **)(CA::Render::Fence::cleared_b_ports + 16); i; uint64_t i = (uint64_t *)*i)
  {
    unsigned int v4 = *((_DWORD *)i + 4);
    if (!std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(&v110, v4)&& !std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v108, v4))
    {
      *(_OWORD *)char v105 = 0u;
      *(_OWORD *)__p = 0u;
      uint64_t v107 = 1065353216;
      if (!CA::Render::Fence::is_batch_resolved(v4, v105, &v110, v108)) {
        goto LABEL_48;
      }
      unint64_t v5 = __p[0];
      if (!__p[0]) {
        goto LABEL_48;
      }
      unint64_t v6 = *((void *)&v110 + 1);
LABEL_7:
      while (2)
      {
        unint64_t v7 = *((unsigned int *)v5 + 4);
        if (v6)
        {
          uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
          v8.i16[0] = vaddlv_u8(v8);
          if (v8.u32[0] > 1uLL)
          {
            unint64_t v9 = *((unsigned int *)v5 + 4);
            if (v6 <= v7) {
              unint64_t v9 = v7 % v6;
            }
          }
          else
          {
            unint64_t v9 = (v6 - 1) & v7;
          }
          double v10 = *(uint64_t ***)(v110 + 8 * v9);
          if (v10)
          {
            for (uint64_t j = *v10; j; uint64_t j = (uint64_t *)*j)
            {
              unint64_t v12 = j[1];
              if (v12 == v7)
              {
                if (*((_DWORD *)j + 4) == v7)
                {
                  unint64_t v5 = (void *)*v5;
                  if (!v5) {
                    goto LABEL_48;
                  }
                  goto LABEL_7;
                }
              }
              else
              {
                if (v8.u32[0] > 1uLL)
                {
                  if (v12 >= v6) {
                    v12 %= v6;
                  }
                }
                else
                {
                  v12 &= v6 - 1;
                }
                if (v12 != v9) {
                  break;
                }
              }
            }
          }
        }
        float v13 = (float)(unint64_t)(*((void *)&v111 + 1) + 1);
        if (!v6 || (float)(*(float *)&v112 * (float)v6) < v13)
        {
          uint64_t v14 = 2 * v6;
          BOOL v15 = v6 < 3 || (v6 & (v6 - 1)) != 0;
          size_t v16 = v15 | v14;
          unint64_t v17 = vcvtps_u32_f32(v13 / *(float *)&v112);
          if (v16 <= v17) {
            size_t v18 = v17;
          }
          else {
            size_t v18 = v16;
          }
          std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>((uint64_t)&v110, v18);
        }
        unint64_t v19 = (void *)*v5;
        std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::remove((uint64_t)v113, v105, v5);
        v5[1] = v7;
        unint64_t v6 = *((void *)&v110 + 1);
        uint8x8_t v20 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v110 + 8));
        v20.i16[0] = vaddlv_u8(v20);
        if (v20.u32[0] > 1uLL)
        {
          if (*((void *)&v110 + 1) <= v7) {
            v7 %= *((void *)&v110 + 1);
          }
        }
        else
        {
          unint64_t v7 = (DWORD2(v110) - 1) & v7;
        }
        uint64_t v21 = *(void **)(v110 + 8 * v7);
        if (v21)
        {
          void *v5 = *v21;
          goto LABEL_44;
        }
        void *v5 = v111;
        *(void *)&long long v111 = v5;
        *(void *)(v110 + 8 * v7) = &v111;
        if (*v5)
        {
          unint64_t v22 = *(void *)(*v5 + 8);
          if (v20.u32[0] > 1uLL)
          {
            if (v22 >= v6) {
              v22 %= v6;
            }
          }
          else
          {
            v22 &= v6 - 1;
          }
          uint64_t v21 = (void *)(v110 + 8 * v22);
LABEL_44:
          *uint64_t v21 = v5;
        }
        ++*((void *)&v111 + 1);
        unint64_t v5 = v19;
        if (v19) {
          continue;
        }
        break;
      }
LABEL_48:
      std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v105);
    }
  }
  uint64_t v23 = *((void *)&v111 + 1);
  if (*((void *)&v111 + 1))
  {
    uint64_t v103 = *((void *)&v111 + 1);
    *(_OWORD *)char v105 = 0u;
    *(_OWORD *)__p = 0u;
    uint64_t v107 = 1065353216;
    unint64_t v24 = (uint64_t *)v111;
    if ((void)v111)
    {
      uint8x8_t v25 = &CA::Render::Fence::_bwait_writer_pending;
      do
      {
        uint64_t v26 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::batches_by_port, *((_DWORD *)v24 + 4));
        if (!v26) {
          goto LABEL_192;
        }
        uint64_t v27 = v26[3];
        if (a2 <= *(double *)(v27 + 16)) {
          a2 = *(double *)(v27 + 16);
        }
        unint64_t v28 = *(uint64_t **)(*(void *)(v27 + 24) + 16);
        if (v28)
        {
          unsigned int v29 = (void *)CA::Render::Fence::bcontexts_by_id;
          do
          {
            LODWORD(v113[0]) = *((_DWORD *)v28 + 4);
            unsigned int v30 = v113[0];
            unint64_t v31 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v29, v113[0]);
            if (v31)
            {
              uint64_t v32 = v31[3];
              std::__hash_table<std::__hash_value_type<unsigned int,CA::Render::Context *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Context *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Context *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::Render::Context *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)v105, v30, v113)[3] = v32;
              unsigned int v29 = (void *)CA::Render::Fence::bcontexts_by_id;
            }
            unint64_t v28 = (uint64_t *)*v28;
          }
          while (v28);
        }
        unint64_t v24 = (uint64_t *)*v24;
      }
      while (v24);
      if (__p[1])
      {
        pthread_mutex_lock(&CA::Render::Fence::_bwait_mutex);
        CA::Render::Fence::_bwait_writer_pending = 1;
        while (CA::Render::Fence::_bwait_readers_by_tid)
          pthread_cond_wait(&CA::Render::Fence::_bwait_cond_writer, &CA::Render::Fence::_bwait_mutex);
        CA::Render::Fence::_bwait_writer_int active = 1;
        CA::Render::Fence::_bwait_writer_pending = 0;
        pthread_mutex_unlock(&CA::Render::Fence::_bwait_mutex);
        uint64_t v33 = __p[0];
        if (__p[0])
        {
          do
          {
            BOOL v104 = v33;
            uint64_t v34 = (uint64_t *)v33[3];
            uint64_t v35 = *v34;
            uint64_t v36 = (os_unfair_lock_s *)(*v34 + 680);
            os_unfair_lock_lock(v36);
            if (*((void *)&v111 + 1))
            {
              os_unfair_lock_lock((os_unfair_lock_t)(v35 + 632));
              uint64_t v37 = (uint64_t *)v111;
              if ((void)v111)
              {
                char v38 = 0;
                uint64_t v39 = (void *)(v35 + 696);
                do
                {
                  unsigned int v40 = *((_DWORD *)v37 + 4);
                  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__erase_unique<unsigned int>((void *)(v35 + 640), v40);
                  uint64_t v41 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)(v35 + 696), v40);
                  if (v41)
                  {
                    double v42 = v41;
                    for (uint64_t k = *(void **)(v35 + 688); k; uint64_t k = (void *)*k)
                    {
                      int v44 = (void *)k[1];
                      if (v44)
                      {
                        uint64_t v45 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)k[1], v40);
                        if (v45)
                        {
                          std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::erase(v44, v45);
                          char v38 = 1;
                        }
                        if (k == (void *)v42[3]) {
                          break;
                        }
                      }
                    }
                    int8x8_t v46 = *(int8x8_t *)(v35 + 704);
                    unint64_t v47 = v42[1];
                    uint8x8_t v48 = (uint8x8_t)vcnt_s8(v46);
                    v48.i16[0] = vaddlv_u8(v48);
                    if (v48.u32[0] > 1uLL)
                    {
                      if (v47 >= *(void *)&v46) {
                        v47 %= *(void *)&v46;
                      }
                    }
                    else
                    {
                      v47 &= *(void *)&v46 - 1;
                    }
                    float v49 = *(uint64_t **)(*v39 + 8 * v47);
                    do
                    {
                      float v50 = v49;
                      float v49 = (uint64_t *)*v49;
                    }
                    while (v49 != v42);
                    if (v50 == (uint64_t *)(v35 + 712)) {
                      goto LABEL_93;
                    }
                    unint64_t v51 = v50[1];
                    if (v48.u32[0] > 1uLL)
                    {
                      if (v51 >= *(void *)&v46) {
                        v51 %= *(void *)&v46;
                      }
                    }
                    else
                    {
                      v51 &= *(void *)&v46 - 1;
                    }
                    if (v51 != v47)
                    {
LABEL_93:
                      if (!*v42) {
                        goto LABEL_94;
                      }
                      unint64_t v52 = *(void *)(*v42 + 8);
                      if (v48.u32[0] > 1uLL)
                      {
                        if (v52 >= *(void *)&v46) {
                          v52 %= *(void *)&v46;
                        }
                      }
                      else
                      {
                        v52 &= *(void *)&v46 - 1;
                      }
                      if (v52 != v47) {
LABEL_94:
                      }
                        *(void *)(*v39 + 8 * v47) = 0;
                    }
                    uint64_t v53 = *v42;
                    if (*v42)
                    {
                      unint64_t v54 = *(void *)(v53 + 8);
                      if (v48.u32[0] > 1uLL)
                      {
                        if (v54 >= *(void *)&v46) {
                          v54 %= *(void *)&v46;
                        }
                      }
                      else
                      {
                        v54 &= *(void *)&v46 - 1;
                      }
                      if (v54 != v47)
                      {
                        *(void *)(*v39 + 8 * v54) = v50;
                        uint64_t v53 = *v42;
                      }
                    }
                    *float v50 = v53;
                    --*(void *)(v35 + 720);
                    operator delete(v42);
                  }
                  uint64_t v37 = (uint64_t *)*v37;
                }
                while (v37);
                os_unfair_lock_unlock((os_unfair_lock_t)(v35 + 632));
                uint8x8_t v25 = &CA::Render::Fence::_bwait_writer_pending;
                if (v38) {
                  CA::Render::Context::drain_deferred(v35, a2);
                }
              }
              else
              {
                os_unfair_lock_unlock((os_unfair_lock_t)(v35 + 632));
              }
            }
            os_unfair_lock_unlock(v36);
            uint64_t v55 = v34[1];
            uint64_t v56 = *(void **)v55;
            if (*(void *)v55 == *(void *)(v55 + 8))
            {
              unint64_t v58 = *(void **)v55;
            }
            else
            {
              do
              {
                for (m = (uint64_t *)v111; m; m = (uint64_t *)*m)
                  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__erase_unique<unsigned int>(v56, *((_DWORD *)m + 4));
                if (v56[3])
                {
                  v56 += 5;
                  unint64_t v58 = *(void **)(v55 + 8);
                }
                else
                {
                  uint64_t v59 = (uint64_t)(v56 + 5);
                  uint64_t v60 = *(void **)(v55 + 8);
                  if (v56 + 5 == v60)
                  {
                    unint64_t v58 = v56;
                  }
                  else
                  {
                    uint64_t v61 = v56;
                    do
                    {
                      std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::clear(v61);
                      uint64_t v62 = v61[5];
                      v61[5] = 0;
                      float v63 = (void *)*v61;
                      *uint64_t v61 = v62;
                      if (v63) {
                        operator delete(v63);
                      }
                      uint64_t v64 = v61[7];
                      v61[2] = v64;
                      unint64_t v65 = v61[6];
                      v61[1] = v65;
                      v61[6] = 0;
                      uint64_t v66 = v61[8];
                      v61[3] = v66;
                      *((_DWORD *)v61 + 8) = *((_DWORD *)v61 + 18);
                      if (v66)
                      {
                        unint64_t v67 = *(void *)(v64 + 8);
                        if ((v65 & (v65 - 1)) != 0)
                        {
                          if (v67 >= v65) {
                            v67 %= v65;
                          }
                        }
                        else
                        {
                          v67 &= v65 - 1;
                        }
                        *(void *)(*v61 + 8 * v67) = v61 + 2;
                        v61[7] = 0;
                        v61[8] = 0;
                      }
                      unint64_t v58 = v61 + 5;
                      float v68 = v61 + 10;
                      v61 += 5;
                    }
                    while (v68 != v60);
                    uint64_t v59 = *(void *)(v55 + 8);
                  }
                  while ((void *)v59 != v58)
                    uint64_t v59 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v59 - 40);
                  *(void *)(v55 + 8) = v58;
                }
              }
              while (v56 != v58);
            }
            int v69 = (uint64_t *)v111;
            if ((void)v111)
            {
              do
              {
                std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__erase_unique<unsigned int>((void *)v34[2], *((_DWORD *)v69 + 4));
                int v69 = (uint64_t *)*v69;
              }
              while (v69);
              unint64_t v58 = *(void **)(v55 + 8);
            }
            if (*(void **)v55 == v58 && !*(void *)(v34[2] + 24))
            {
              v113[0] = (void **)v55;
              std::vector<std::unordered_set<unsigned long long>>::__destroy_vector::operator()[abi:nn180100](v113);
              MEMORY[0x185323DC0](v55, 0x20C40960023A9);
              uint64_t v70 = v34[2];
              if (v70)
              {
                uint64_t v71 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v70);
                MEMORY[0x185323DC0](v71, 0x10A0C408EF24B1CLL);
              }
              unint64_t v72 = (atomic_uint *)*v34;
              if (*v34 && atomic_fetch_add(v72 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v72 + 16))(v72);
              }
              malloc_zone = (malloc_zone_t *)get_malloc_zone();
              malloc_zone_free(malloc_zone, v34);
              uint64_t v74 = (void *)*((void *)v25 + 452);
              int v75 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v74, *((_DWORD *)v104 + 4));
              if (v75) {
                std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::erase(v74, v75);
              }
            }
            uint64_t v33 = (void *)*v104;
          }
          while (*v104);
        }
        pthread_mutex_lock(&CA::Render::Fence::_bwait_mutex);
        CA::Render::Fence::_bwait_writer_int active = 0;
        pthread_cond_broadcast(&CA::Render::Fence::_bwait_cond_reader);
        pthread_mutex_unlock(&CA::Render::Fence::_bwait_mutex);
      }
      uint64_t v76 = (uint64_t *)v111;
      if ((void)v111)
      {
        char v77 = (ipc_space_t *)MEMORY[0x1E4F14960];
        while (1)
        {
          unsigned int v78 = *((_DWORD *)v76 + 4);
          int64x2_t v79 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::batches_by_port, v78);
          if (!v79) {
            break;
          }
          uint64_t v80 = v79[3];
          if (*(unsigned char *)(v80 + 44))
          {
            for (unint64_t n = *(uint64_t **)(*(void *)(v80 + 24) + 16); n; unint64_t n = (uint64_t *)*n)
            {
              std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(*(void **)(v80 + 32), *((_DWORD *)n + 4));
              kdebug_trace();
            }
          }
          uint64_t v82 = *(void *)(v80 + 24);
          if (v82)
          {
            uint64_t v83 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v82);
            MEMORY[0x185323DC0](v83, 0x10A0C408EF24B1CLL);
          }
          uint64_t v84 = *(void *)(v80 + 32);
          if (v84)
          {
            uint64_t v85 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v84);
            MEMORY[0x185323DC0](v85, 0x10A0C408EF24B1CLL);
          }
          char v86 = (void *)CA::Render::Fence::batches_by_port;
          uint64_t v87 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::batches_by_port, v78);
          if (v87)
          {
            int8x8_t v88 = (int8x8_t)v86[1];
            unint64_t v89 = v87[1];
            uint8x8_t v90 = (uint8x8_t)vcnt_s8(v88);
            v90.i16[0] = vaddlv_u8(v90);
            if (v90.u32[0] > 1uLL)
            {
              if (v89 >= *(void *)&v88) {
                v89 %= *(void *)&v88;
              }
            }
            else
            {
              v89 &= *(void *)&v88 - 1;
            }
            int32x2_t v91 = *(uint64_t **)(*v86 + 8 * v89);
            do
            {
              vm_address_t v92 = v91;
              int32x2_t v91 = (uint64_t *)*v91;
            }
            while (v91 != v87);
            if (v92 == v86 + 2) {
              goto LABEL_173;
            }
            unint64_t v93 = v92[1];
            if (v90.u32[0] > 1uLL)
            {
              if (v93 >= *(void *)&v88) {
                v93 %= *(void *)&v88;
              }
            }
            else
            {
              v93 &= *(void *)&v88 - 1;
            }
            if (v93 != v89)
            {
LABEL_173:
              if (!*v87) {
                goto LABEL_174;
              }
              unint64_t v94 = *(void *)(*v87 + 8);
              if (v90.u32[0] > 1uLL)
              {
                if (v94 >= *(void *)&v88) {
                  v94 %= *(void *)&v88;
                }
              }
              else
              {
                v94 &= *(void *)&v88 - 1;
              }
              if (v94 != v89) {
LABEL_174:
              }
                *(void *)(*v86 + 8 * v89) = 0;
            }
            uint64_t v95 = *v87;
            if (*v87)
            {
              unint64_t v96 = *(void *)(v95 + 8);
              if (v90.u32[0] > 1uLL)
              {
                if (v96 >= *(void *)&v88) {
                  v96 %= *(void *)&v88;
                }
              }
              else
              {
                v96 &= *(void *)&v88 - 1;
              }
              if (v96 != v89)
              {
                *(void *)(*v86 + 8 * v96) = v92;
                uint64_t v95 = *v87;
              }
            }
            uint64_t *v92 = v95;
            *uint64_t v87 = 0;
            --v86[3];
            operator delete(v87);
          }
          std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__erase_unique<unsigned int>((void *)CA::Render::Fence::cleared_b_ports, v78);
          if (*(unsigned char *)(v80 + 44)) {
            kdebug_trace();
          }
          mach_port_destruct(*v77, v78, 0, *(void *)v80);
          uint64_t v97 = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(v97, (void *)v80);
          uint64_t v76 = (uint64_t *)*v76;
          if (!v76) {
            goto LABEL_186;
          }
        }
LABEL_192:
        abort();
      }
    }
LABEL_186:
    uint64_t v98 = __p[0];
    if (__p[0])
    {
      do
      {
        float v99 = (void *)*v98;
        operator delete(v98);
        uint64_t v98 = v99;
      }
      while (v99);
    }
    float v100 = v105[0];
    v105[0] = 0;
    if (v100) {
      operator delete(v100);
    }
    uint64_t v23 = v103;
  }
  BOOL v101 = v23 != 0;
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v108);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v110);
  return v101;
}

uint64_t std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::erase(void *a1, uint64_t *a2)
{
  __p[3] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v2 = *a2;
  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::remove((uint64_t)__p, a1, a2);
  if (__p[0]) {
    operator delete(__p[0]);
  }
  return v2;
}

uint64_t std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::remove(uint64_t result, void *a2, void *a3)
{
  int8x8_t v3 = (int8x8_t)a2[1];
  unint64_t v4 = a3[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  unint64_t v6 = *(void **)(*a2 + 8 * v4);
  do
  {
    unint64_t v7 = v6;
    unint64_t v6 = (void *)*v6;
  }
  while (v6 != a3);
  if (v7 == a2 + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a3) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a3 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*a2 + 8 * v4) = 0;
  }
  uint64_t v10 = *a3;
  if (*a3)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*a2 + 8 * v11) = v7;
      uint64_t v10 = *a3;
    }
  }
  void *v7 = v10;
  *a3 = 0;
  --a2[3];
  *(void *)uint64_t result = a3;
  *(void *)(result + 8) = a2 + 2;
  *(unsigned char *)(result + 16) = 1;
  return result;
}

uint64_t *std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__erase_unique<unsigned int>(void *a1, unsigned int a2)
{
  uint64_t result = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(a1, a2);
  if (result)
  {
    return (uint64_t *)std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::erase(a1, result);
  }
  return result;
}

void std::vector<std::unordered_set<unsigned long long>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint8x8_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v4 - 40);
      while ((void *)v4 != v2);
      uint8x8_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::erase(void *a1, void *__p)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  unint64_t v3 = __p[1];
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *(void *)&v2) {
      v3 %= *(void *)&v2;
    }
  }
  else
  {
    v3 &= *(void *)&v2 - 1;
  }
  uint8x8_t v5 = *(void **)(*a1 + 8 * v3);
  do
  {
    unint64_t v6 = v5;
    uint8x8_t v5 = (void *)*v5;
  }
  while (v5 != __p);
  if (v6 == a1 + 2) {
    goto LABEL_18;
  }
  unint64_t v7 = v6[1];
  if (v4.u32[0] > 1uLL)
  {
    if (v7 >= *(void *)&v2) {
      v7 %= *(void *)&v2;
    }
  }
  else
  {
    v7 &= *(void *)&v2 - 1;
  }
  if (v7 != v3)
  {
LABEL_18:
    if (!*__p) {
      goto LABEL_19;
    }
    unint64_t v8 = *(void *)(*__p + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v8 >= *(void *)&v2) {
        v8 %= *(void *)&v2;
      }
    }
    else
    {
      v8 &= *(void *)&v2 - 1;
    }
    if (v8 != v3) {
LABEL_19:
    }
      *(void *)(*a1 + 8 * v3) = 0;
  }
  uint64_t v9 = *__p;
  if (*__p)
  {
    unint64_t v10 = *(void *)(v9 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v10 >= *(void *)&v2) {
        v10 %= *(void *)&v2;
      }
    }
    else
    {
      v10 &= *(void *)&v2 - 1;
    }
    if (v10 != v3)
    {
      *(void *)(*a1 + 8 * v10) = v6;
      uint64_t v9 = *__p;
    }
  }
  *unint64_t v6 = v9;
  *__p = 0;
  --a1[3];
  operator delete(__p);
}

uint64_t CA::Render::Fence::is_batch_resolved(unsigned int a1, void *a2, void *a3, void *a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)a2, a1, a1);
  if (!std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::cleared_b_ports, a1))
  {
    std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)a4, a1, a1);
    return 0;
  }
  unint64_t v8 = *(void **)(CA::Render::Fence::bcontexts_by_id + 16);
  if (!v8) {
    return 1;
  }
  while (1)
  {
    uint64_t v9 = *(void **)(v8[3] + 8);
    uint64_t v10 = v9[1];
    if (v10 != *v9) {
      break;
    }
LABEL_16:
    unint64_t v8 = (void *)*v8;
    uint64_t result = 1;
    if (!v8) {
      return result;
    }
  }
  char v11 = 0;
  while (1)
  {
    uint64_t v17 = 0;
    v10 -= 40;
    long long v15 = 0u;
    long long v16 = 0u;
    std::unordered_set<unsigned int>::unordered_set((uint64_t)&v15, v10);
    if ((v11 & 1) == 0
      && !std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(&v15, a1))
    {
      char v11 = 0;
      goto LABEL_15;
    }
    unint64_t v12 = (uint64_t *)v16;
    if ((void)v16) {
      break;
    }
LABEL_13:
    char v11 = 1;
LABEL_15:
    std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v15);
    if (v10 == *v9) {
      goto LABEL_16;
    }
  }
  while (1)
  {
    uint64_t v13 = *((unsigned int *)v12 + 4);
    if (!std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(a2, *((_DWORD *)v12 + 4))&& !std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(a3, v13)&& (std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(a4, v13)|| !CA::Render::Fence::is_batch_resolved(v13, a2, a3, a4)))
    {
      break;
    }
    unint64_t v12 = (uint64_t *)*v12;
    if (!v12) {
      goto LABEL_13;
    }
  }
  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)a4, a1, a1);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v15);
  return 0;
}

void *CA::Render::Fence::applyTransaction(uint64_t **a1)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (CA::Render::Server::_thread) {
    BOOL v1 = BYTE7(xmmword_1EB2ACC70) == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (!v1) {
    return 0;
  }
  if (CA::Render::Fence::fence_info_once[0] != -1) {
    dispatch_once_f(CA::Render::Fence::fence_info_once, 0, (dispatch_function_t)CA::Render::Fence::fence_info_init);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Fence::_lock);
  long long v63 = 0u;
  long long v64 = 0u;
  uint64_t v65 = 1065353216;
  for (uint64_t i = *a1; i; uint64_t i = (uint64_t *)*i)
  {
    uint8x8_t v5 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::fences_by_port, *((_DWORD *)i + 2));
    if (v5)
    {
      unint64_t v6 = (CA::Render::Fence *)std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>((void *)CA::Render::Fence::cleared_f_names, *(void *)v5[3]);
      if (!v6)
      {
        for (uint64_t j = (void *)i[3]; j; uint64_t j = (void *)*j)
        {
          uint64_t v8 = j[2];
          if (v8 && (*(unsigned char *)(v8 + 13) & 4) == 0)
          {
            LODWORD(v60) = *(_DWORD *)(v8 + 16);
            CA::Render::Fence::_createTransactionInfo(v6);
          }
        }
      }
    }
  }
  long long v60 = 0u;
  long long v61 = 0u;
  uint64_t v62 = 1065353216;
  uint64_t v9 = a1[1];
  if (v9)
  {
    BOOL v10 = BYTE8(xmmword_1EB2ACC70) != 0;
    do
    {
      uint64_t v11 = v9[2];
      if (v11 && (*(unsigned char *)(v11 + 13) & 4) == 0)
      {
        *(_DWORD *)long long buf = *(_DWORD *)(v11 + 16);
        unsigned int v12 = *(_DWORD *)buf;
        std::__hash_table<std::__hash_value_type<unsigned int,CA::Render::Context *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Context *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Context *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::Render::Context *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v60, *(unsigned int *)buf, buf)[3] = v11;
        BOOL v10 = v10
           || std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::fcontexts_by_id, v12) != 0;
      }
      uint64_t v9 = (uint64_t *)*v9;
    }
    while (v9);
    if (*((void *)&v61 + 1) > 1uLL)
    {
      if (!v10) {
        goto LABEL_48;
      }
LABEL_33:
      uint64_t v13 = (uint64_t **)v61;
      uint64_t v14 = (CA::Render::Fence *)std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::find<unsigned int>(v63, *((unint64_t *)&v63 + 1), *(_DWORD *)(v61 + 16));
      if (v14)
      {
        uint64_t v59 = 0;
        *(_OWORD *)long long buf = 0u;
        long long v58 = 0u;
        std::unordered_set<unsigned long long>::unordered_set((uint64_t)buf, (uint64_t)v14 + 24);
        long long v15 = *v13;
        while (v15)
        {
          long long v16 = std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::find<unsigned int>(v63, *((unint64_t *)&v63 + 1), *((_DWORD *)v15 + 4));
          long long v15 = (uint64_t *)*v15;
          if (v16)
          {
            uint64_t v17 = v58;
            if ((void)v58)
            {
              uint64_t v18 = v16 + 3;
              do
              {
                if (std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(v18, *(void *)(v17 + 16)))
                {
                  uint64_t v17 = *(void *)v17;
                }
                else
                {
                  uint64_t v17 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(buf, (uint64_t *)v17);
                }
              }
              while (v17);
            }
          }
          else
          {
            std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::clear(buf);
          }
          if (!*((void *)&v58 + 1))
          {
            uint64_t v14 = (CA::Render::Fence *)std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)buf);
            goto LABEL_54;
          }
        }
        uint64_t v21 = *((void *)&v58 + 1);
        uint64_t v14 = (CA::Render::Fence *)std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)buf);
        if (v21) {
          goto LABEL_76;
        }
      }
LABEL_54:
      fence = (double *)CA::Render::Fence::_create_fence(v14);
      if (fence)
      {
        uint64_t v23 = fence;
        *((unsigned char *)fence + 20) = 1;
        kdebug_trace();
        uint64_t v24 = mach_absolute_time();
        double v25 = CATimeWithHostTime(v24) + 0.5;
        v23[1] = v25;
        uint64_t v26 = (CA::Render::Fence *)CA::Render::Server::add_callback(3, (uint64_t)CA::Render::Fence::ftimeout_callback, 0, v25);
        CA::Render::Fence::_createTransactionInfo(v26);
      }
      if (x_log_hook_p()) {
        goto LABEL_57;
      }
      uint64_t v35 = x_log_category_render;
      if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR)) {
        goto LABEL_76;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v36 = "Failed to create batch fence in applyTransaction.";
      goto LABEL_75;
    }
    if (*((void *)&v61 + 1) == 1)
    {
      if (*((unsigned char *)a1 + 25) != 0 && v10) {
        goto LABEL_33;
      }
      if (*((unsigned char *)a1 + 25))
      {
LABEL_48:
        uint64_t batch = CA::Render::Fence::create_batch((CA::Render::Fence *)(BYTE9(xmmword_1EB2ACC70) == 0));
        if (batch)
        {
          uint64_t v20 = batch;
          if (*(unsigned char *)(batch + 44)) {
            uint64_t v55 = *(void *)batch;
          }
          else {
            uint64_t v55 = 0;
          }
          uint64_t v27 = (uint64_t *)v61;
          int v56 = *(_DWORD *)(batch + 40);
          if ((void)v61)
          {
            unint64_t v28 = 0;
            do
            {
              *(_DWORD *)long long buf = *((_DWORD *)v27 + 4);
              unsigned int v29 = *(_DWORD *)buf;
              unsigned int v30 = (os_unfair_lock_s *)v27[3];
              std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(*(void *)(v20 + 24), *(unsigned int *)buf, *(int *)buf);
              if (*(unsigned char *)(v20 + 44)) {
                kdebug_trace();
              }
              CA::Render::Context::add_fence_batch_port(v30, *(_DWORD *)(v20 + 40));
              unint64_t v31 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::bcontexts_by_id, v29);
              if (!v31)
              {
                if (!atomic_fetch_add((atomic_uint *volatile)&v30[2], 1u)) {
                  atomic_fetch_add((atomic_uint *volatile)&v30[2], 0xFFFFFFFF);
                }
                malloc_zone = (malloc_zone_t *)get_malloc_zone();
                *(void *)malloc_type_zone_malloc(malloc_zone, 0x18uLL, 0x8BB15036uLL) = v30;
                operator new();
              }
              std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(*(void *)(v31[3] + 16), *(_DWORD *)(v20 + 40), *(_DWORD *)(v20 + 40));
              uint64_t v33 = (malloc_zone_t *)get_malloc_zone();
              uint64_t v34 = malloc_type_zone_malloc(v33, 0x18uLL, 0x8BB15036uLL);
              *(void *)uint64_t v34 = v28;
              void v34[2] = 0;
              v34[3] = v29;
              *((void *)v34 + 2) = 0;
              uint64_t v27 = (uint64_t *)*v27;
              unint64_t v28 = v34;
            }
            while (v27);
            uint64_t v9 = (uint64_t *)v34;
            goto LABEL_78;
          }
          goto LABEL_77;
        }
        if (x_log_hook_p())
        {
LABEL_57:
          x_log_();
          goto LABEL_76;
        }
        uint64_t v35 = x_log_category_render;
        if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR)) {
          goto LABEL_76;
        }
        *(_WORD *)long long buf = 0;
        uint64_t v36 = "Failed to create batch in applyTransaction.";
LABEL_75:
        _os_log_impl(&dword_184668000, v35, OS_LOG_TYPE_ERROR, v36, buf, 2u);
      }
    }
LABEL_76:
    int v56 = 0;
    uint64_t v55 = 0;
LABEL_77:
    uint64_t v9 = 0;
    goto LABEL_78;
  }
  int v56 = 0;
  uint64_t v55 = 0;
LABEL_78:
  for (uint64_t k = (uint64_t *)v64; k; uint64_t k = (uint64_t *)*k)
  {
    char v38 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::fcontexts_by_id, *((_DWORD *)k + 4));
    if (!v38) {
LABEL_106:
    }
      abort();
    uint64_t v39 = *(uint64_t **)(v38[3] + 8);
    unint64_t v40 = v39[1];
    unint64_t v41 = v39[2];
    if (v40 >= v41)
    {
      unint64_t v43 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v40 - *v39) >> 3);
      unint64_t v44 = v43 + 1;
      if (v43 + 1 > 0x666666666666666) {
        goto LABEL_106;
      }
      unint64_t v45 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v41 - *v39) >> 3);
      if (2 * v45 > v44) {
        unint64_t v44 = 2 * v45;
      }
      if (v45 >= 0x333333333333333) {
        unint64_t v46 = 0x666666666666666;
      }
      else {
        unint64_t v46 = v44;
      }
      if (v46)
      {
        if (v46 > 0x666666666666666) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v47 = (char *)operator new(40 * v46);
      }
      else
      {
        unint64_t v47 = 0;
      }
      uint8x8_t v48 = &v47[40 * v46];
      uint64_t v49 = std::__hash_table<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>>>::__hash_table((uint64_t)&v47[40 * v43], k + 3);
      uint64_t v42 = v49 + 40;
      unint64_t v51 = (uint64_t *)*v39;
      float v50 = (uint64_t *)v39[1];
      if (v50 == (uint64_t *)*v39)
      {
        uint64_t *v39 = v49;
        v39[1] = v42;
        _OWORD v39[2] = (uint64_t)v48;
      }
      else
      {
        do
        {
          v50 -= 5;
          uint64_t v49 = std::__hash_table<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>>>::__hash_table(v49 - 40, v50);
        }
        while (v50 != v51);
        unint64_t v52 = (uint64_t *)*v39;
        float v50 = (uint64_t *)v39[1];
        uint64_t *v39 = v49;
        v39[1] = v42;
        _OWORD v39[2] = (uint64_t)v48;
        if (v50 != v52)
        {
          do
          {
            v50 -= 5;
            std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v50);
          }
          while (v50 != v52);
          float v50 = v52;
        }
      }
      if (v50) {
        operator delete(v50);
      }
    }
    else
    {
      uint64_t v42 = std::__hash_table<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>>>::__hash_table(v40, k + 3)+ 40;
    }
    v39[1] = v42;
  }
  if ((v56 - 1) < 0xFFFFFFFE)
  {
    uint64_t v53 = (malloc_zone_t *)get_malloc_zone();
    int8x8_t v2 = malloc_type_zone_malloc(v53, 0x28uLL, 0x8BB15036uLL);
    *int8x8_t v2 = 0;
    v2[1] = v9;
    *((_DWORD *)v2 + 4) = 0;
    *((_DWORD *)v2 + 5) = v56;
    *((unsigned char *)v2 + 24) = 0;
    v2[4] = v55;
  }
  else
  {
    int8x8_t v2 = 0;
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v60);
  std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>>>::~__hash_table((uint64_t)&v63);
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Fence::_lock);
  return v2;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,CA::Render::Context *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Context *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Context *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::Render::Context *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(float *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *((void *)a1 + 1);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      BOOL v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          BOOL v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  BOOL v10 = operator new(0x20uLL);
  *BOOL v10 = 0;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  v10[3] = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    BOOL v14 = 1;
    if (v6 >= 3) {
      BOOL v14 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v6);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      int8x8_t prime = (int8x8_t)v16;
    }
    else {
      int8x8_t prime = (int8x8_t)v15;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v6 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v6) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v6)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v6 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (*(void *)&prime <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      if (*(void *)&prime >= v6)
      {
        unint64_t v6 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * *(void *)&prime);
          unint64_t v19 = *(void **)a1;
          *(void *)a1 = v18;
          if (v19) {
            operator delete(v19);
          }
          uint64_t v20 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v20++) = 0;
          while (*(void *)&prime != v20);
          uint64_t v21 = (void *)*((void *)a1 + 2);
          if (v21)
          {
            unint64_t v22 = v21[1];
            uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
            v23.i16[0] = vaddlv_u8(v23);
            if (v23.u32[0] > 1uLL)
            {
              if (v22 >= *(void *)&prime) {
                v22 %= *(void *)&prime;
              }
            }
            else
            {
              v22 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
            uint64_t v27 = (void *)*v21;
            if (*v21)
            {
              do
              {
                unint64_t v28 = v27[1];
                if (v23.u32[0] > 1uLL)
                {
                  if (v28 >= *(void *)&prime) {
                    v28 %= *(void *)&prime;
                  }
                }
                else
                {
                  v28 &= *(void *)&prime - 1;
                }
                if (v28 != v22)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v28))
                  {
                    *(void *)(*(void *)a1 + 8 * v28) = v21;
                    goto LABEL_55;
                  }
                  *uint64_t v21 = *v27;
                  *uint64_t v27 = **(void **)(*(void *)a1 + 8 * v28);
                  **(void **)(*(void *)a1 + 8 * v28) = v27;
                  uint64_t v27 = v21;
                }
                unint64_t v28 = v22;
LABEL_55:
                uint64_t v21 = v27;
                uint64_t v27 = (void *)*v27;
                unint64_t v22 = v28;
              }
              while (v27);
            }
          }
          unint64_t v6 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v33 = *(void **)a1;
        *(void *)a1 = 0;
        if (v33) {
          operator delete(v33);
        }
        unint64_t v6 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  unsigned int v29 = *(void **)a1;
  unsigned int v30 = *(void **)(*(void *)a1 + 8 * v8);
  if (v30)
  {
    *BOOL v10 = *v30;
LABEL_72:
    *unsigned int v30 = v10;
    goto LABEL_73;
  }
  *BOOL v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v8] = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v31 >= v6) {
        v31 %= v6;
      }
    }
    else
    {
      v31 &= v6 - 1;
    }
    unsigned int v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

uint64_t std::unordered_set<unsigned int>::unordered_set(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(uint64_t **)(a2 + 16); i; uint64_t i = (uint64_t *)*i)
    std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(a1, *((_DWORD *)i + 4), *((_DWORD *)i + 4));
  return a1;
}

void std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  float v12 = operator new(0x18uLL);
  v12[1] = v5;
  *((_DWORD *)v12 + 4) = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    BOOL v15 = 1;
    if (v6 >= 3) {
      BOOL v15 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v6);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>(a1, v18);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v8);
  if (v20)
  {
    *float v12 = *v20;
LABEL_38:
    *uint64_t v20 = v12;
    goto LABEL_39;
  }
  uint64_t v21 = *(void *)(a1 + 16);
  *float v12 = v21;
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v8) = a1 + 16;
  if (v21)
  {
    unint64_t v22 = *(void *)(v21 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v22 >= v6) {
        v22 %= v6;
      }
    }
    else
    {
      v22 &= v6 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      unint64_t v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v5 = operator new(8 * prime);
  unint64_t v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  unint64_t v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    float v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *unint64_t v8 = *v14;
          void *v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          float v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        unint64_t v8 = v14;
        float v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

void CA::Render::Context::add_fence_batch_port(os_unfair_lock_s *this, unsigned int a2)
{
  if (a2 - 1 <= 0xFFFFFFFD)
  {
    int8x8_t v4 = this + 158;
    os_unfair_lock_lock(this + 158);
    uint64_t v5 = *(void *)&this[166]._os_unfair_lock_opaque;
    std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)&this[160], a2, a2);
    os_unfair_lock_unlock(v4);
    if (!v5)
    {
      CA::Render::post_notification(6u, (unint64_t)this, 0, 0);
    }
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>>>::~__hash_table(uint64_t a1)
{
  int8x8_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)(v2 + 3));
      operator delete(v2);
      int8x8_t v2 = v3;
    }
    while (v3);
  }
  int8x8_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    size_t v9 = *(void **)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      for (uint64_t i = (void *)*v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  uint8x8_t v12 = operator new(0x18uLL);
  *uint8x8_t v12 = 0;
  v12[1] = a2;
  _OWORD v12[2] = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    BOOL v15 = 1;
    if (v6 >= 3) {
      BOOL v15 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v6);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>(a1, v18);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
      else {
        unint64_t v8 = a2;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v8);
  if (v20)
  {
    *uint8x8_t v12 = *v20;
LABEL_38:
    *uint64_t v20 = v12;
    goto LABEL_39;
  }
  *uint8x8_t v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v8) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v21 >= v6) {
        v21 %= v6;
      }
    }
    else
    {
      v21 &= v6 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

void sub_184739470(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  v23[3] = *MEMORY[0x1E4F143B8];
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    size_t v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      uint8x8_t v10 = (char *)*v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = *((void *)v10 + 1);
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          uint8x8_t v10 = *(char **)v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  uint8x8_t v12 = (void *)(a1 + 16);
  v23[2] = 1;
  uint8x8_t v10 = (char *)operator new(0x40uLL);
  v23[0] = v10;
  v23[1] = a1 + 16;
  *(void *)uint8x8_t v10 = 0;
  *((void *)v10 + 1) = v5;
  *((_DWORD *)v10 + 4) = *a3;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *((_DWORD *)v10 + 14) = 1065353216;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    BOOL v15 = 1;
    if (v6 >= 3) {
      BOOL v15 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v6);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>(a1, v18);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v8);
  if (v20)
  {
    *(void *)uint8x8_t v10 = *v20;
LABEL_38:
    *uint64_t v20 = v10;
    goto LABEL_39;
  }
  *(void *)uint8x8_t v10 = *v12;
  *uint8x8_t v12 = v10;
  *(void *)(v19 + 8 * v8) = v12;
  if (*(void *)v10)
  {
    unint64_t v21 = *(void *)(*(void *)v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v21 >= v6) {
        v21 %= v6;
      }
    }
    else
    {
      v21 &= v6 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  v23[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,void *>>>>::reset[abi:nn180100]((uint64_t)v23);
  return v10;
}

void sub_1847396F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  BOOL v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v1 + 24);
    }
    operator delete(v1);
  }
}

uint64_t CA::Render::Fence::create_batch(CA::Render::Fence *this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (CA::Render::Fence::fence_info_once[0] != -1) {
    dispatch_once_f(CA::Render::Fence::fence_info_once, 0, (dispatch_function_t)CA::Render::Fence::fence_info_init);
  }
  if ((CA::Render::Fence::_batch_counter + 1) > 1) {
    unsigned int v1 = CA::Render::Fence::_batch_counter + 1;
  }
  else {
    unsigned int v1 = 1;
  }
  CA::Render::Fence::_batch_counter = v1;
  mach_port_context_t v2 = v1 | (unint64_t)((uint64_t)getpid() << 32);
  mach_port_name_t name = 0;
  *(_OWORD *)&options.flags = xmmword_1849A8140;
  options.reserved[1] = 0;
  if (!mach_port_construct(*MEMORY[0x1E4F14960], &options, v2, &name))
  {
    uint64_t v3 = mach_absolute_time();
    double v4 = CATimeWithHostTime(v3) + 0.5;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    unint64_t v6 = (double *)malloc_type_zone_malloc(malloc_zone, 0x30uLL, 0x8BB15036uLL);
    *(void *)unint64_t v6 = v2;
    *((_DWORD *)v6 + 10) = name;
    v6[1] = v4;
    v6[2] = 0.0;
    operator new();
  }
  return 0;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::clear(void *result)
{
  if (result[3])
  {
    unsigned int v1 = result;
    uint64_t result = (void *)result[2];
    if (result)
    {
      do
      {
        mach_port_context_t v2 = (void *)*result;
        operator delete(result);
        uint64_t result = v2;
      }
      while (v2);
    }
    v1[2] = 0;
    uint64_t v3 = v1[1];
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*v1 + 8 * i) = 0;
    }
    v1[3] = 0;
  }
  return result;
}

void CA::Render::Fence::_createTransactionInfo(CA::Render::Fence *this)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  memset(&options.mpl, 0, 20);
  mach_port_name_t name = 0;
  options.flags = 16;
  if (!mach_port_construct(*MEMORY[0x1E4F14960], &options, 0, &name) && name + 1 > 1)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    mach_port_context_t v2 = malloc_type_zone_malloc(malloc_zone, 0x18uLL, 0x8BB15036uLL);
    v2[4] = name;
    operator new();
  }
  abort();
}

uint64_t CA::OGL::cache_node(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 72);
  if (v8) {
    *(void *)(a1 + 72) = *(void *)v8;
  }
  else {
    uint64_t v8 = x_heap_malloc_small_(*(uint64_t **)(a1 + 56), 0xF8uLL);
  }
  int v9 = *(_DWORD *)(*(void *)(a2 + 24) + 40);
  *(void *)(v8 + 8) = a1;
  *(void *)(v8 + 16) = a2;
  *(void *)(v8 + 48) = 0;
  *(void *)(v8 + 192) = 0;
  *(void *)(v8 + 200) = 0;
  *(_DWORD *)(v8 + 208) = 0;
  *(_WORD *)(v8 + 212) = *(_WORD *)(v8 + 212) & 0xC000 | 1;
  unsigned int v10 = *(_DWORD *)(v8 + 220) & 0xFC000000;
  *(_DWORD *)(v8 + 216) = *(_DWORD *)(v8 + 216) & 0xFFC00000 | 0xF;
  *(_DWORD *)(v8 + 220) = v10;
  *(void *)(v8 + 24) = a4;
  *(void *)(v8 + 32) = 0;
  *(_DWORD *)(v8 + 136) = -1;
  *(void *)uint64_t v8 = &unk_1ED02C228;
  *(unsigned char *)(v8 + 224) = *(unsigned char *)(v8 + 224) & 0xFE | ((v9 & 0x800000) != 0);
  *(void *)(v8 + 228) = *a3;
  *(_DWORD *)(a4 + 220) |= 0x400000u;
  CA::OGL::copy_gstate(v8 + 56, a4 + 56);
  *(_DWORD *)(v8 + 220) = *(_DWORD *)(v8 + 220) & 0xFFCE0000 | *(_DWORD *)(a4 + 220) & 0x200000 | 0x101000;
  return v8;
}

float CA::OGL::copy_gstate(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  __int16 v2 = *(unsigned __int8 *)(a2 + 68) | (*(unsigned __int8 *)(a1 + 69) << 8);
  *(_WORD *)(a1 + 68) = v2;
  float result = *(float *)(a2 + 64);
  *(float *)(a1 + 64) = result;
  __int16 v4 = *(_WORD *)(a2 + 68) & 0x100 | v2 & 0xFEFF;
  *(_WORD *)(a1 + 68) = v4;
  *(_WORD *)(a1 + 68) = v4 & 0xFBFF | *(_WORD *)(a2 + 68) & 0x400;
  return result;
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
}

void sub_18473A300(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_18473A4F4(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

CA::AttrList *CA::AttrList::remove(CA::AttrList *this, const void *a2)
{
  int v2 = (int)a2;
  uint64_t v3 = this;
  int v4 = *((_DWORD *)this + 2) & 7;
  if (v4)
  {
    do
    {
      uint64_t v5 = (CA::AttrList *)CA::AttrList::copy_(v3);
      *((void *)v3 + 1) = *((void *)v3 + 1) & 0xFFFFFFFFFFFFFFF8 | (v4 - 1);
      uint64_t v3 = v5;
      int v4 = *((_DWORD *)v5 + 2) & 7;
    }
    while (v4);
  }
  else
  {
    uint64_t v5 = this;
  }
  unint64_t v6 = *(CA::AttrList::Node **)v5;
  if (!*(void *)v5) {
    goto LABEL_16;
  }
  int v7 = *((_DWORD *)v6 + 2);
  if ((v7 & 0xFFFFFF) == v2)
  {
    *(void *)uint64_t v5 = *(void *)v6;
LABEL_12:
    if ((*((_DWORD *)v6 + 2) & 0x80000000) != 0)
    {
LABEL_14:
      CA::AttrList::splice_shared_node((uint64_t)v5, v6);
    }
    else
    {
      CA::AttrList::Node::free_memory(v6, a2);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v6);
    }
  }
  else
  {
    char v8 = 0;
    while (1)
    {
      int v9 = v6;
      unint64_t v6 = *(CA::AttrList::Node **)v6;
      if (!v6) {
        break;
      }
      v8 |= v7 < 0;
      int v7 = *((_DWORD *)v6 + 2);
      if ((v7 & 0xFFFFFF) == v2)
      {
        *(void *)int v9 = *(void *)v6;
        if (v8) {
          goto LABEL_14;
        }
        goto LABEL_12;
      }
    }
  }
  if (!*(void *)v5)
  {
LABEL_16:
    unint64_t v11 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v11, v5);
    return 0;
  }
  return v5;
}

uint64_t CA::AttrList::copy_(CA::AttrList *this)
{
  if (*((void *)this + 1) >= 8uLL)
  {
    uint64_t v5 = *(uint64_t **)this;
    if (*(void *)this)
    {
      unint64_t v6 = 0;
      do
      {
        int v7 = v6;
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        unint64_t v6 = malloc_type_zone_malloc(malloc_zone, 0x18uLL, 0x8BB15036uLL);
        *((_DWORD *)v6 + 2) = v5[1] & 0xFFFFFF;
        CA::AttrList::Node::alloc_memory(v6, *((unsigned char *)v5 + 11) & 0x7F);
        switch(*((unsigned char *)v5 + 11) & 0x7F)
        {
          case 1:
            **((void **)v6 + 2) = *(void *)v5[2];
            break;
          case 2:
            unint64_t v11 = (const void *)v5[2];
            if (v11) {
              unint64_t v11 = CFRetain(v11);
            }
            goto LABEL_16;
          case 3:
            unint64_t v11 = (const void *)CAValueCopyPointer((void *)v5[2]);
            goto LABEL_16;
          case 4:
            uint64_t v12 = v5[2];
            if (*(unsigned char *)(v12 + 8)) {
              id WeakRetained = objc_loadWeakRetained((id *)v12);
            }
            else {
              id WeakRetained = *(id *)v12;
            }
            unsigned int v30 = WeakRetained;
            X::WeakDetails::Ptr::set(*((id **)v6 + 2), WeakRetained, 1);

            break;
          case 5:
            unint64_t v11 = _Block_copy((const void *)v5[2]);
LABEL_16:
            *((void *)v6 + 2) = v11;
            break;
          case 6:
          case 7:
          case 8:
          case 9:
          case 0xA:
          case 0xB:
          case 0xC:
          case 0xD:
          case 0xE:
          case 0xF:
          case 0x10:
            *((void *)v6 + 2) = v5[2];
            break;
          case 0x11:
          case 0x12:
            *((void *)v6 + 2) = v5[2];
            break;
          case 0x13:
          case 0x14:
            uint64_t v9 = *((void *)v6 + 2);
            long long v10 = *(_OWORD *)v5[2];
            goto LABEL_21;
          case 0x15:
            float v14 = (long long *)v5[2];
            BOOL v15 = (_OWORD *)*((void *)v6 + 2);
            long long v16 = *v14;
            long long v17 = v14[1];
            goto LABEL_24;
          case 0x16:
            size_t v18 = (_OWORD *)v5[2];
            uint64_t v19 = (_OWORD *)*((void *)v6 + 2);
            long long v20 = v18[1];
            long long v21 = v18[2];
            long long v22 = v18[3];
            _OWORD *v19 = *v18;
            v19[1] = v20;
            int v19[2] = v21;
            v19[3] = v22;
            long long v23 = v18[5];
            long long v24 = v18[6];
            long long v25 = v18[7];
            unsigned int v19[4] = v18[4];
            v19[5] = v23;
            v19[6] = v24;
            v19[7] = v25;
            break;
          case 0x17:
            uint64_t v26 = (long long *)v5[2];
            BOOL v15 = (_OWORD *)*((void *)v6 + 2);
            long long v16 = *v26;
            long long v17 = v26[1];
            long long v27 = v26[2];
            goto LABEL_23;
          case 0x18:
            unint64_t v28 = (long long *)v5[2];
            uint64_t v9 = *((void *)v6 + 2);
            long long v10 = *v28;
            *(void *)(v9 + 16) = *((void *)v28 + 2);
LABEL_21:
            *(_OWORD *)uint64_t v9 = v10;
            break;
          case 0x19:
            unsigned int v29 = (long long *)v5[2];
            BOOL v15 = (_OWORD *)*((void *)v6 + 2);
            long long v16 = *v29;
            long long v17 = v29[1];
            long long v27 = v29[2];
            v15[3] = v29[3];
LABEL_23:
            void v15[2] = v27;
LABEL_24:
            _OWORD *v15 = v16;
            v15[1] = v17;
            break;
          default:
            break;
        }
        *(void *)unint64_t v6 = v7;
        uint64_t v5 = (uint64_t *)*v5;
      }
      while (v5);
    }
    else
    {
      unint64_t v6 = 0;
    }
    unint64_t v31 = (malloc_zone_t *)get_malloc_zone();
    uint64_t result = (uint64_t)malloc_type_zone_malloc(v31, 0x10uLL, 0x8BB15036uLL);
    *(void *)uint64_t result = v6;
    *(void *)(result + 8) = 0;
  }
  else
  {
    int v2 = (malloc_zone_t *)get_malloc_zone();
    uint64_t result = (uint64_t)malloc_type_zone_malloc(v2, 0x10uLL, 0x8BB15036uLL);
    *(void *)(result + 8) = this;
    uint64_t v4 = *((void *)this + 1);
    *(void *)uint64_t result = *(void *)this;
    *((void *)this + 1) = v4 & 7 | result;
    *(_DWORD *)(*(void *)this + 8) |= 0x80000000;
  }
  return result;
}

uint64_t CAValueCopyPointer(void *a1)
{
  if (objc_opt_respondsToSelector())
  {
    return [a1 copy];
  }
  else
  {
    if (a1) {
      CFRetain(a1);
    }
    return (uint64_t)a1;
  }
}

void CA::OGL::render_subclass(CA::OGL::Renderer &,CA::OGL::Layer const*)::visitor::visit_subclass(uint64_t a1)
{
  uint64_t v250 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 16);
  int v2 = *(uint64_t **)(*(void *)(v1 + 24) + 128);
  if (v2 && (uint64_t v3 = *v2) != 0)
  {
    if (*(unsigned char *)(v3 + 12) == 3) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  if ((*(unsigned char *)(v4 + 13) & 0x10) == 0)
  {
    uint64_t v5 = *(void *)(*(void *)(v1 + 16) + 256);
    if (v5)
    {
      unint64_t v6 = *(uint64_t **)(a1 + 8);
      int v7 = (os_unfair_lock_s *)(v5 + 36);
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 36));
      uint64_t v8 = *(void *)(v5 + 40);
      if (!v8)
      {
LABEL_185:
        os_unfair_lock_unlock(v7);
        return;
      }
      uint64_t v9 = (os_unfair_lock_s *)(v8 + 40);
      os_unfair_lock_lock((os_unfair_lock_t)(v8 + 40));
      uint64_t v11 = *(void *)(v8 + 64);
      uint64_t v10 = *(void *)(v8 + 72);
      if (v11 == v10) {
        goto LABEL_184;
      }
      uint64_t v12 = *v6;
      while (*(void *)v11 != *(void *)(v5 + 24))
      {
        v11 += 168;
        if (v11 == v10) {
          goto LABEL_184;
        }
      }
      BOOL v210 = v6;
      uint64_t v13 = *(void *)(v12 + 248);
      float64x2_t v201 = *(float64x2_t *)(v11 + 16);
      float64x2_t v203 = *(float64x2_t *)(v11 + 32);
      float64x2_t v227 = 0u;
      float64x2_t v228 = 0u;
      CA::Render::BackdropLayer::get_backdrop_bounds(v4, *(void *)(v1 + 24), (uint64_t)&v227);
      float64x2_t v15 = v228;
      int64x2_t v16 = vclezq_f64(v228);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v16, 1), (int8x16_t)v16).u64[0] & 0x8000000000000000) == 0)
      {
        int64x2_t v17 = vclezq_f64(v203);
        if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v17, 1), (int8x16_t)v17).u64[0] & 0x8000000000000000) != 0
          || (float64x2_t v18 = vmaxnmq_f64(v227, v201),
              float64x2_t v15 = vsubq_f64(vminnmq_f64(vaddq_f64(v227, v228), vaddq_f64(v201, v203)), v18),
              int64x2_t v19 = vclezq_f64(v15),
              (vorrq_s8((int8x16_t)vdupq_laneq_s64(v19, 1), (int8x16_t)v19).u64[0] & 0x8000000000000000) != 0))
        {
          float64x2_t v228 = 0uLL;
          float64x2_t v211 = 0u;
LABEL_21:
          long long v20 = *(float64x2_t **)(v13 + 24);
          uint64_t v21 = CA::OGL::transform_filter_bits(v20, v14, 1.0, 1.0);
          v22.i64[0] = 1.0;
          float64x2_t v207 = v227;
          int v25 = CA::OGL::rect_filter_bits(v20, v21, v23, v227, v211, v22, 1.0);
          long long v244 = 0u;
          long long v245 = 0u;
          uint64_t v199 = *(unsigned __int16 *)(v13 + 36);
          uint64_t v198 = *(unsigned int *)(v13 + 32);
          short float v200 = *(short float *)(v13 + 38);
          if (*(unsigned char *)(v11 + 160)
            && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v12 + 184))(v12, 27))
          {
            int v197 = v25;
            uint64_t v202 = v13;
            v226[0] = v207;
            v226[1] = v211;
            uint64_t v27 = *v210;
            if (!*(void *)(*(void *)(*v210 + 264) + 8))
            {
              uint64_t v74 = *(void *)(v8 + 560);
              if (v74)
              {
                int v75 = *(_DWORD *)(v74 + 16);
                if (v75)
                {
                  uint64_t v76 = *(void *)(v74 + 24);
                  if ((*(unsigned char *)(v76 + 13) & 1) != 0 && v75 == 1)
                  {
                    uint64_t v77 = *(void *)(v27 + 248);
                    if (*(unsigned char *)(v77 + 68) == 3
                      && *(float *)(*(void *)(v1 + 24) + 28) == 0.0
                      && *(_DWORD *)(v76 + 24) == 103)
                    {
                      uint64_t v78 = *(void *)(v27 + 192);
                      if (!v78
                        || (*(_DWORD *)(v210[1] + 1084) & 4) != 0
                        || (LOBYTE(v232) = 0,
                            (*(void (**)(uint64_t, void (*)(uint64_t, uint64_t, uint64_t, unsigned char *), long long *))(*(void *)v78 + 80))(v78, CA::OGL::render_in_place_backdrop_with_color_matrix(CA::OGL::Renderer &,CA::OGL::Layer const*,CA::Render::BackdropGroup *,CA::Rect)::$_0::__invoke, &v232), !(_BYTE)v232))
                      {
                        memset(v249, 0, sizeof(v249));
                        CA::OGL::get_filter_color_matrix(*(CA::OGL **)(v76 + 40), (const CA::Render::Filter *)v249, v24);
                        *(void *)&long long v232 = __PAIR64__(DWORD1(v249[1]), v249[0]);
                        *((void *)&v232 + 1) = __PAIR64__(HIDWORD(v249[3]), DWORD2(v249[2]));
                        *(void *)&long long v233 = __PAIR64__(DWORD2(v249[1]), DWORD1(v249[0]));
                        *((void *)&v233 + 1) = __PAIR64__(v249[4], HIDWORD(v249[2]));
                        *(void *)&long long v234 = __PAIR64__(HIDWORD(v249[1]), DWORD2(v249[0]));
                        *((void *)&v234 + 1) = __PAIR64__(DWORD1(v249[4]), v249[3]);
                        *(void *)&long long v235 = __PAIR64__(v249[2], HIDWORD(v249[0]));
                        *((void *)&v235 + 1) = __PAIR64__(DWORD2(v249[4]), DWORD1(v249[3]));
                        *(void *)&long long v236 = __PAIR64__(DWORD1(v249[2]), v249[1]);
                        *((void *)&v236 + 1) = __PAIR64__(HIDWORD(v249[4]), DWORD2(v249[3]));
                        double v248 = 0;
                        memset(v247, 0, sizeof(v247));
                        memset(v246, 0, sizeof(v246));
                        *(_OWORD *)((char *)v246 + 8) = *(_OWORD *)(v77 + 8);
                        uint64_t v79 = *(void *)(v77 + 32);
                        *((void *)&v246[1] + 1) = *(void *)(v77 + 24);
                        *(void *)&v247[0] = v79;
                        *(_OWORD *)((char *)v247 + 8) = *(_OWORD *)(v77 + 40);
                        __int16 v80 = *(_WORD *)(v77 + 68);
                        LODWORD(v248) = *(_DWORD *)(v77 + 64);
                        *((void *)&v247[1] + 1) = &v232;
                        HIDWORD(v248) = v80 & 0x500 | 0x2A;
                        *(void *)&v246[0] = CA::OGL::Context::set_gstate(v27, (uint64_t)v246);
                        *(void *)(*(void *)(v27 + 16) + 8) = *(void *)&v247[0];
                        uint64_t v81 = *(void *)(v27 + 16);
                        if (*(unsigned __int8 *)(v81 + 480) >= 2u) {
                          *(unsigned char *)(v81 + 481) |= 1u;
                        }
                        int v82 = (*(unsigned __int16 *)(v1 + 40) >> 6);
                        *(void *)&long long v240 = v226;
                        *((void *)&v240 + 1) = *((void *)&v246[1] + 1);
                        LODWORD(v241) = 0;
                        DWORD1(v241) = v82;
                        *((void *)&v241 + 1) = 0;
                        long long v242 = 0uLL;
                        uint64_t v83 = *(void *)(v1 + 24);
                        uint64_t v84 = *(void *)(v83 + 128);
                        float v85 = 0.0;
                        if (v84)
                        {
                          uint64_t v86 = *(void *)(v84 + 56);
                          if (v86)
                          {
                            uint64_t v87 = (double *)(*(uint64_t (**)(uint64_t, double))(*(void *)v86 + 80))(v86, 0.0);
                            uint64_t v88 = *(void *)(v1 + 24);
                            uint64_t v89 = *(void *)(v88 + 128);
                            if (v89)
                            {
                              uint64_t v90 = *(void *)(v89 + 64);
                              if (v90)
                              {
                                if (*(_DWORD *)(v90 + 16) > 3u)
                                {
                                  float64x2_t v179 = vsubq_f64(*(float64x2_t *)(v90 + 40), *(float64x2_t *)(v90 + 24));
                                  long long v229 = *(_OWORD *)(v90 + 24);
                                  float64x2_t v230 = v179;
                                }
                                else
                                {
                                  long long v229 = 0u;
                                  float64x2_t v230 = 0u;
                                }
                              }
                              else
                              {
                                __asm { FMOV            V0.2D, #0.5 }
                                long long v229 = _Q0;
                                float64x2_t v230 = 0uLL;
                              }
                              float v177 = *(float *)(v89 + 228);
                            }
                            else
                            {
                              __asm { FMOV            V0.2D, #0.5 }
                              long long v229 = _Q0;
                              float64x2_t v230 = 0uLL;
                              float v177 = 0.0;
                            }
                            CA::OGL::fill_corner_rect(v27, (double **)&v240, v87, (double *)&v229, *(_DWORD *)(*(void *)(v1 + 16) + 24) & 1, (*(void *)(v88 + 40) >> 41) & 1, 15, v177, v177);
                            goto LABEL_194;
                          }
                          float v85 = *(float *)(v84 + 228);
                        }
                        CA::OGL::fill_round_rect(v27, (float64x2_t **)&v240, (double *)(*(_WORD *)(v83 + 38) & 0xF), (double *)(*(_DWORD *)(v83 + 40) & 3), v85, v85);
LABEL_194:
                        *(unsigned char *)(*(void *)(v27 + 16) + 481) &= ~1u;
                        CA::OGL::Context::set_gstate(v27, **(void **)(v27 + 248));
                        goto LABEL_184;
                      }
                    }
                  }
                }
              }
            }
            uint64_t v28 = 0;
            float32x2_t v29 = vcvt_f32_f64(*(float64x2_t *)(v11 + 16));
            float32x2_t v30 = vadd_f32(vcvt_f32_f64(*(float64x2_t *)(v11 + 32)), v29);
            *(float32x2_t *)&long long v244 = v29;
            *((void *)&v244 + 1) = __PAIR64__(v29.u32[1], v30.u32[0]);
            v29.i32[1] = v30.i32[1];
            *(float32x2_t *)&long long v245 = v30;
            *((float32x2_t *)&v245 + 1) = v29;
            unint64_t v31 = *(float64x2_t **)(v202 + 24);
            do
            {
              CA::Transform::apply_to_point2(v31, (double *)((char *)&v244 + v28), (float *)v24);
              v28 += 8;
            }
            while (v28 != 32);
            float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)((char *)&v244 + 8), *(float32x2_t *)&v244), *(int8x8_t *)&v244, *(int8x8_t *)((char *)&v244 + 8));
            *(int8x8_t *)v32.i8 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v244, *(float32x2_t *)((char *)&v244 + 8)), *(int8x8_t *)&v244, *(int8x8_t *)((char *)&v244 + 8));
            float32x2_t v35 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)((char *)&v245 + 8), *(float32x2_t *)&v245), *(int8x8_t *)&v245, *(int8x8_t *)((char *)&v245 + 8));
            *(int8x8_t *)v33.i8 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v245, *(float32x2_t *)((char *)&v245 + 8)), *(int8x8_t *)&v245, *(int8x8_t *)((char *)&v245 + 8));
            float32x2_t v36 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v34), (int8x8_t)v34, (int8x8_t)v35);
            *(int8x8_t *)v32.i8 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)v32.i8, *(float32x2_t *)v33.i8), *(int8x8_t *)v32.i8, *(int8x8_t *)v33.i8);
            float32x2_t v37 = vsub_f32(*(float32x2_t *)v32.i8, v36);
            v32.i32[0] = COERCE_UNSIGNED_INT(vaddv_f32(v37)) & 0x7FFFFFFF;
            v33.i32[0] = 2139095040;
            int8x16_t v38 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v33, v32), 0);
            float64x2_t v39 = (float64x2_t)vbslq_s8(v38, (int8x16_t)vcvtq_f64_f32(v37), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL));
            int64x2_t v40 = vceqzq_f64(v39);
            if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v40, 1), (int8x16_t)v40).u64[0] & 0x8000000000000000) != 0
              || (int8x16_t v41 = vorrq_s8((int8x16_t)vcltzq_f64(v39), (int8x16_t)vcgezq_f64(v39)),
                  (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v41), 1), v41).u64[0] & 0x8000000000000000) != 0))
            {
              int8x16_t v225 = 0uLL;
              int32x4_t v44 = 0uLL;
            }
            else
            {
              float64x2_t v42 = (float64x2_t)vbslq_s8(v38, (int8x16_t)vcvtq_f64_f32(v36), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL));
              int32x4_t v43 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v42, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
              int32x4_t v44 = vuzp1q_s32(v43, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v42, v39), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v43));
              int8x16_t v225 = (int8x16_t)v44;
            }
            uint64_t v46 = v202;
            unint64_t v47 = v210;
            if ((v197 & 9) != 0)
            {
              int v48 = v44.i32[2];
              if (v44.i32[2] <= v44.i32[3]) {
                int v49 = v44.i32[3];
              }
              else {
                int v49 = v44.i32[2];
              }
              if (v44.i32[2] >= v44.i32[3]) {
                int v48 = v44.i32[3];
              }
              BOOL v50 = v49 > 1073741822 || v48 < 1;
              if (!v50)
              {
                int8x16_t v225 = (int8x16_t)vaddq_s32(v44, (int32x4_t)xmmword_184997F10);
                int32x2_t v51 = vcgt_s32((int32x2_t)0x100000001, vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8(v225, v225, 8uLL)));
                if ((v51.i32[1] | v51.i32[0])) {
                  v225.i64[1] = 0;
                }
              }
            }
            long long v224 = 0uLL;
            CA::Shape::get_bounds(*(void *)(*(void *)(v12 + 248) + 8), (int *)&v224);
            unint64_t v52 = *(int32x2_t **)(v12 + 264);
            if (v52) {
              uint64_t v53 = v52 + 4;
            }
            else {
              uint64_t v53 = (int32x2_t *)(v12 + 200);
            }
            int32x2_t v54 = *(int32x2_t *)((char *)&v224 + 8);
            uint32x2_t v55 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v224 + 8));
            if ((vpmax_u32(v55, v55).u32[0] & 0x80000000) == 0)
            {
              int32x2_t v56 = v53[1];
              uint32x2_t v57 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v56);
              if ((vpmax_u32(v57, v57).u32[0] & 0x80000000) != 0
                || (*(int32x2_t *)&long long v58 = vmax_s32(*(int32x2_t *)&v224, *v53),
                    int32x2_t v59 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)&v224, *(int32x2_t *)((char *)&v224 + 8)), vadd_s32(*v53, v56)), *(int32x2_t *)&v58), v60 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v59), (vpmax_u32(v60, v60).u32[0] & 0x80000000) != 0))
              {
                int32x2_t v54 = 0;
                *((void *)&v224 + 1) = 0;
              }
              else
              {
                *((int32x2_t *)&v58 + 1) = v59;
                long long v224 = v58;
                int32x2_t v54 = v59;
              }
            }
            uint32x2_t v61 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v225.u64[1]);
            if ((vpmax_u32(v61, v61).u32[0] & 0x80000000) == 0)
            {
              uint32x2_t v62 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v54);
              if ((vpmax_u32(v62, v62).u32[0] & 0x80000000) != 0
                || (int32x2_t v63 = vadd_s32(*(int32x2_t *)&v224, v54),
                    *(int32x2_t *)v64.i8 = vmax_s32(*(int32x2_t *)v225.i8, *(int32x2_t *)&v224),
                    int32x2_t v65 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)v225.i8, (int32x2_t)v225.u64[1]), v63), *(int32x2_t *)v64.i8), v66 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v65), (vpmax_u32(v66, v66).u32[0] & 0x80000000) != 0))
              {
                v225.i64[1] = 0;
              }
              else
              {
                v64.u64[1] = (unint64_t)v65;
                int8x16_t v225 = v64;
              }
            }
            double v196 = (os_unfair_lock_s *)(v8 + 40);
            uint64_t v67 = (*(uint64_t (**)(uint64_t, uint64_t, int8x16_t *, uint64_t))(*(void *)v12 + 656))(v12, 1, &v225, 2063);
            if (v67)
            {
              long long v242 = 0u;
              long long v243 = 0u;
              long long v240 = 0u;
              long long v241 = 0u;
              long long v238 = 0u;
              long long v239 = 0u;
              long long v236 = 0u;
              long long v237 = 0u;
              long long v234 = 0u;
              long long v235 = 0u;
              long long v232 = 0u;
              long long v233 = 0u;
              char v223 = 0;
              uint64_t v70 = *(void *)(v12 + 16);
              char v194 = *(unsigned char *)(v70 + 480);
              *(void *)(v70 + 8) = 0x3C003C003C003C00;
              float64x2_t v230 = 0u;
              long long v231 = 0u;
              long long v229 = 0u;
              CA::Shape::operator=((uint64_t)&v229, &v225);
              memset((char *)v249 + 8, 0, 64);
              uint64_t v71 = *(void *)(v12 + 248);
              v249[2] = 0x3C003C003C003C00uLL;
              v249[3] = 0uLL;
              WORD2(v249[4]) = 1;
              *(void *)&v249[0] = 0;
              if (v71)
              {
                *(_OWORD *)((char *)v249 + 8) = *(_OWORD *)(v71 + 8);
                *((void *)&v249[1] + 1) = *(void *)(v71 + 24);
                float v72 = *(float *)(v71 + 64);
                WORD2(v249[4]) = *(_WORD *)(v71 + 68) & 0x100 | 1;
                __int16 v73 = WORD2(v249[4]) | *(_WORD *)(v71 + 68) & 0x400;
              }
              else
              {
                v249[1] = 0uLL;
                __int16 v73 = 1025;
                float v72 = 1.0;
              }
              double v195 = v7;
              *(float *)&v249[4] = v72;
              WORD2(v249[4]) = v73;
              *((void *)&v249[0] + 1) = &v229;
              *(void *)&v249[0] = CA::OGL::Context::set_gstate(v12, (uint64_t)v249);
              uint64_t v205 = v67;
              CA::OGL::Context::push_surface(v12, v67, 1u, 8, 0);
              *(unsigned char *)(*(void *)(v12 + 16) + 481) &= ~1u;
              *(unsigned char *)(*(void *)(v12 + 16) + 16) = 1;
              char v222 = 0;
              uint64_t v93 = *(void *)(v12 + 192);
              if (v93 && (*(_DWORD *)(v210[1] + 1084) & 4) == 0 && !v223)
              {
                memset(v247, 0, sizeof(v247));
                v246[1] = 0u;
                *(void *)&v246[0] = v12;
                *((void *)&v246[0] + 1) = &v229;
                LODWORD(v246[1]) = 1065353216;
                BYTE8(v247[1]) = 1;
                double v248 = &v222;
              }
              uint64_t v94 = (v69 - 1);
              if (v69 >= 1)
              {
                uint64_t v95 = v12 + 834;
                unint64_t v96 = (int32x2_t *)((unint64_t)(&v232 + v94) | 8);
                uint64_t v97 = (v69 - 1);
                do
                {
                  if (v222) {
                    BOOL v98 = 1;
                  }
                  else {
                    BOOL v98 = v97 < v94;
                  }
                  if (v98)
                  {
                    *(unsigned char *)(*(void *)(v12 + 16) + 481) |= 1u;
                    *(unsigned char *)(*(void *)(v12 + 16) + 480) = 3;
                  }
                  int32x2_t v99 = (int32x2_t)vextq_s8(v225, v225, 8uLL).u64[0];
                  uint32x2_t v100 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v99);
                  if ((vpmax_u32(v100, v100).u32[0] & 0x80000000) == 0)
                  {
                    uint32x2_t v101 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *v96);
                    if ((vpmax_u32(v101, v101).u32[0] & 0x80000000) == 0)
                    {
                      int32x2_t v102 = v96[-1];
                      int32x2_t v103 = vmin_s32(vadd_s32(*(int32x2_t *)v225.i8, v99), vadd_s32(v102, *v96));
                      int32x2_t v213 = vmax_s32(*(int32x2_t *)v225.i8, v102);
                      int32x2_t v104 = vsub_s32(v103, v213);
                      uint32x2_t v105 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v104);
                      if ((vpmax_u32(v105, v105).u32[0] & 0x80000000) == 0)
                      {
                        *(int32x2_t *)&v208.f64[0] = v103;
                        uint64_t v106 = *((void *)&v240 + v97);
                        CA::OGL::Context::bind_surface(v12, v106, 0, 0, 0, 0.0);
                        *(void *)(v12 + 128) = 0;
                        *(void *)(v12 + 96) = v95;
                        *(_OWORD *)(v12 + 104) = xmmword_184997E70;
                        if (*(void *)(v12 + 136) <= 3uLL)
                        {
                          *(_WORD *)(v12 + 832) |= 0x20u;
                          CA::OGL::Context::array_flush(v12);
                          *(void *)(v12 + 128) = 0;
                          *(void *)(v12 + 96) = v95;
                          *(_OWORD *)(v12 + 104) = xmmword_184997E70;
                        }
                        CA::OGL::Context::array_rect((void *)v12, (float)v213.i32[0], (float)v213.i32[1], (float)SLODWORD(v208.f64[0]), (float)SHIDWORD(v208.f64[0]));
                        uint64_t v107 = *(void *)(v12 + 120) + 48 * *(void *)(v12 + 128);
                        int32x2_t v108 = vsub_s32(v213, v102);
                        float32x2_t v109 = vcvt_f32_s32(v108);
                        float32x2_t v110 = vcvt_f32_s32(vadd_s32(v108, v104));
                        *(float32x2_t *)(v107 - 176) = v109;
                        *(void *)(v107 - 128) = __PAIR64__(v109.u32[1], v110.u32[0]);
                        *(float32x2_t *)(v107 - 80) = v110;
                        v109.i32[1] = v110.i32[1];
                        *(float32x2_t *)(v107 - 32) = v109;
                        CA::OGL::Context::array_flush(v12);
                        CA::OGL::Context::unbind_surface((void *)v12, v106, 0);
                      }
                    }
                  }
                  v96 -= 2;
                  BOOL v50 = v97-- <= 0;
                }
                while (!v50);
              }
              float16x4_t v111 = vcvt_f16_f32(*(float32x4_t *)(*(void *)(v1 + 24) + 16));
              uint64_t v112 = *(void *)(v12 + 16);
              if (v111.u16[0] | (unint64_t)(v111.u16[1] << 16) | ((unint64_t)v111.u16[2] << 32) & 0xFFFFFFFFFFFFLL | ((unint64_t)v111.u16[3] << 48))
              {
                unint64_t v214 = (unint64_t)v111.u16[3] << 48;
                unint64_t v209 = (unint64_t)v111.u16[2] << 32;
                unint64_t v206 = (unint64_t)v111.u16[1] << 16;
                uint64_t v113 = v111.u16[0];
                *(unsigned char *)(v112 + 16) = 0;
                *(unsigned char *)(*(void *)(v12 + 16) + 481) |= 1u;
                *(unsigned char *)(*(void *)(v12 + 16) + 480) = 3;
                int v114 = v225.i32[0];
                int v115 = v225.i32[1];
                __int32 v116 = v225.i32[2];
                __int32 v117 = v225.i32[3];
                *(void *)(v12 + 128) = 0;
                *(void *)(v12 + 96) = v12 + 834;
                *(_OWORD *)(v12 + 104) = xmmword_184997E70;
                if (*(void *)(v12 + 136) <= 3uLL)
                {
                  *(_WORD *)(v12 + 832) |= 0x20u;
                  CA::OGL::Context::array_flush(v12);
                  *(void *)(v12 + 128) = 0;
                  *(void *)(v12 + 96) = v12 + 834;
                  *(_OWORD *)(v12 + 104) = xmmword_184997E70;
                }
                CA::OGL::Context::array_rect((void *)v12, (float)v114, (float)v115, (float)(v116 + v114), (float)(v117 + v115));
                uint64_t v118 = *(void *)(v12 + 120) + 48 * *(void *)(v12 + 128);
                unint64_t v119 = v214 | v209 | v206 | v113;
                *(void *)(v118 - 160) = v119;
                *(void *)(v118 - 112) = v119;
                *(void *)(v118 - 64) = v119;
                *(void *)(v118 - 16) = v119;
                CA::OGL::Context::array_flush(v12);
                uint64_t v112 = *(void *)(v12 + 16);
              }
              *(unsigned char *)(v112 + 480) = v194;
              int v7 = v195;
              uint64_t v46 = v202;
              unint64_t v47 = v210;
              uint64_t v67 = v205;
              if (v223) {
                __int16 v120 = 0;
              }
              else {
                __int16 v120 = ~(*(_WORD *)(v12 + 832) << 10) & 0x800;
              }
              *(_WORD *)(v205 + 75) = *(_WORD *)(v205 + 75) & 0xF7FF | v120;
              uint64_t v121 = *(void *)(v8 + 560);
              if (v121)
              {
                unint64_t v122 = *(unsigned int *)(v121 + 16);
                if (v122)
                {
                  if (*(unsigned char *)(*(void *)(v121 + 24) + 13))
                  {
LABEL_119:
                    LODWORD(v246[0]) = 0;
                    int v125 = CA::OGL::prepare_filters((CA::Render::Update **)v210, v1, (unsigned int *)v121, 1, (int *)v246, 1);
                    if (v125)
                    {
                      int v126 = v125;
                      char v127 = v125;
                      do
                      {
                        CA::OGL::emit_filter((CA::Render::Update **)v210, (uint64_t)v127, v1, (int *)v67, 0, 0, 0, 1.0, 1.0);
                        __int16 v128 = 0;
                        __int16 v129 = *(_WORD *)(v67 + 75);
                        if ((v129 & 0x800) != 0)
                        {
                          uint64_t v130 = (CA::ColorMatrix *)v126[6];
                          if (v130)
                          {
                            if (CA::ColorMatrix::is_opaque_identity(v130)) {
                              __int16 v128 = 2048;
                            }
                            else {
                              __int16 v128 = 0;
                            }
                          }
                          else
                          {
                            __int16 v128 = 0;
                          }
                        }
                        __int16 v131 = v129 & 0xF7FF | v128;
                        uint64_t v67 = v205;
                        *(_WORD *)(v205 + 75) = v131;
                        char v127 = (void *)*v127;
                      }
                      while (v127);
                      do
                      {
                        long long v132 = (void *)*v126;
                        CA::OGL::finalize_filter(v126);
                        int v126 = v132;
                      }
                      while (v132);
                    }
                  }
                  else
                  {
                    unint64_t v123 = 0;
                    while (v122 - 1 != v123)
                    {
                      uint64_t v124 = *(void *)(v121 + 32 + 8 * v123++);
                      if (*(unsigned char *)(v124 + 13))
                      {
                        if (v123 >= v122) {
                          break;
                        }
                        goto LABEL_119;
                      }
                    }
                  }
                }
              }
              if (byte_1EB2ACBE1)
              {
                double v248 = 0;
                memset(v247, 0, sizeof(v247));
                memset(v246, 0, sizeof(v246));
                uint64_t v180 = *(void *)(v12 + 248);
                *(_OWORD *)((char *)v246 + 8) = *(_OWORD *)(v180 + 8);
                uint64_t v181 = *(void *)(v180 + 32);
                *(_OWORD *)((char *)v247 + 8) = *(_OWORD *)(v180 + 40);
                *((void *)&v247[1] + 1) = *(void *)(v180 + 56);
                __int16 v182 = *(unsigned __int8 *)(v180 + 68);
                WORD2(v248) = v182;
                __int16 v183 = *(_WORD *)(v180 + 68) & 0x100 | v182;
                LODWORD(v248) = *(_DWORD *)(v180 + 64);
                WORD2(v248) = v183;
                WORD2(v248) = v183 | *(_WORD *)(v180 + 68) & 0x400;
                *(void *)&v247[0] = v181;
                *((void *)&v246[1] + 1) = &CA::identity_transform;
                *(void *)&v246[0] = CA::OGL::Context::set_gstate(v12, (uint64_t)v246);
                if ((*(_DWORD *)(v67 + 68) & 0x800) != 0) {
                  uint64_t v187 = 8388736;
                }
                else {
                  uint64_t v187 = 2155872384;
                }
                if (v225.i32[2] <= v225.i32[3]) {
                  int v188 = v225.i32[3];
                }
                else {
                  int v188 = v225.i32[2];
                }
                v185.i32[0] = 1073741822;
                v186.i32[0] = v188;
                int8x16_t v189 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v186, v185), 0);
                v190.i64[0] = v225.i32[0];
                v190.i64[1] = v225.i32[1];
                int8x16_t v192 = (int8x16_t)vcvtq_f64_s64(v190);
                int8x16_t v191 = vbslq_s8(v189, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v192);
                *(double *)v192.i64 = (double)v225.i32[2];
                double v193 = (double)v225.i32[3];
                if (v188 > 1073741822)
                {
                  *(double *)v192.i64 = 1.79769313e308;
                  double v193 = 1.79769313e308;
                }
                int8x16_t v219 = v191;
                uint64_t v220 = v192.i64[0];
                double v221 = v193;
                v216[0] = &v219;
                v216[1] = *((void *)&v246[1] + 1);
                long long v217 = 0u;
                long long v218 = 0u;
                CA::OGL::fill_color_rect(v12, (uint64_t)v216, (double *)v187, v184, 0.0, v192);
                CA::OGL::Context::set_gstate(v12, **(void **)(v12 + 248));
              }
              CA::OGL::Context::pop_surface((CA::OGL::Context *)v12);
              CA::OGL::Context::set_gstate(v12, **(void **)(v12 + 248));
            }
            LODWORD(v68) = 1.0;
            int v92 = 1;
            if (!v67) {
              goto LABEL_150;
            }
            goto LABEL_132;
          }
          uint64_t v45 = *(void *)(v8 + 48);
          if (v45)
          {
            if (*(void *)(v45 + 8) == v12)
            {
              uint64_t v204 = *(void *)(v45 + 32);
              if (v204)
              {
                int v197 = v25;
                double v196 = (os_unfair_lock_s *)(v8 + 40);
                uint64_t v91 = 0;
                LODWORD(v26) = *(_DWORD *)(v45 + 28);
                double v212 = v26;
                do
                {
                  *(void *)((char *)&v244 + v91) = *(void *)(v11 + v91 + 112);
                  CA::Transform::apply_to_point2((float64x2_t *)(v45 + 64), (double *)((char *)&v244 + v91), (float *)v24);
                  double v68 = v212;
                  *(float32x2_t *)((char *)&v244 + v91) = vmul_n_f32(*(float32x2_t *)((char *)&v244 + v91), *(float *)&v212);
                  v91 += 8;
                }
                while (v91 != 32);
                uint64_t v67 = *(void *)(v45 + 40);
                int v92 = 0;
                if (v67)
                {
                  uint64_t v46 = v13;
                  unint64_t v47 = v210;
                }
                else
                {
                  LODWORD(v68) = *(_DWORD *)(v45 + 24);
                  uint64_t v46 = v13;
                  unint64_t v47 = v210;
                  uint64_t v67 = v204;
                }
LABEL_132:
                double v215 = v68;
                uint64_t v133 = *(void *)(v67 + 48);
                if (((*(uint64_t (**)(uint64_t))(*(void *)v12 + 96))(v12) & v133) == v133)
                {
                  uint64_t v134 = *(void *)(v1 + 24);
                  int v135 = *(_DWORD *)(v134 + 36);
                  if ((v135 & 0xFu) > 0xA) {
                    unsigned int v136 = 1;
                  }
                  else {
                    unsigned int v136 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v135 & 0xF];
                  }
                  uint64_t v137 = v135 >> 4;
                  if (v137 > 0xA) {
                    uint64_t v138 = 1;
                  }
                  else {
                    uint64_t v138 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v137];
                  }
                  if ((*(_WORD *)(v1 + 40) & 0x10) != 0)
                  {
                    uint64_t v145 = *(void *)(v134 + 128);
                    if (v145) {
                      int v146 = *(os_unfair_lock_s **)(v145 + 112);
                    }
                    else {
                      int v146 = 0;
                    }
                    uint64_t v9 = v196;
                    CA::OGL::fill_surface_mesh(v12, v146, v134 + 64, v67, v136, v138, 1, v215, 0.0);
                    goto LABEL_184;
                  }
                  float v139 = 0.0;
                  CA::OGL::Context::bind_surface(v12, v67, 0, v136, v138, 0.0);
                  uint64_t v140 = *(void *)(v12 + 16);
                  *(_WORD *)(v140 + 12) = (v198 | (unint64_t)(v199 << 32)) >> 32;
                  *(_DWORD *)(v140 + 8) = v198;
                  *(short float *)(v140 + 14) = v200;
                  double v141 = *(float32x2_t **)(v12 + 16);
                  v141[13] = vmla_f32(v141[13], vcvt_f32_s32(vneg_s32(*(int32x2_t *)(v67 + 32))), v141[12]);
                  uint64_t v142 = *(void *)(*(void *)(v1 + 24) + 128);
                  if (v142) {
                    float v139 = *(float *)(v142 + 228);
                  }
                  if (v200 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                  {
                    if ((v197 & 9) != 0)
                    {
                      int v143 = 0;
                      BOOL v144 = 1;
                      if ((*(_WORD *)(v1 + 40) & 0x3C0) != 0 || (*(_WORD *)(v67 + 75) & 0x800) == 0) {
                        goto LABEL_161;
                      }
                      goto LABEL_154;
                    }
                    if ((*(_WORD *)(v67 + 75) & 0x800) != 0)
                    {
LABEL_154:
                      unint64_t v147 = v141[60].i8[0];
                      if (v147 > 3) {
                        int v143 = 0;
                      }
                      else {
                        int v143 = dword_184998860[v147];
                      }
                      BOOL v144 = v139 != 0.0;
                      if (v139 == 0.0 && v142) {
                        BOOL v144 = *(void *)(v142 + 72) != 0;
                      }
LABEL_161:
                      unsigned int v148 = v141[60].u8[0];
                      if (v148 >= 2 && (v148 != 3 || v144)) {
                        v141[60].i8[1] |= 1u;
                      }
                      v149.i32[1] = HIDWORD(v228.f64[0]);
                      float64x2_t v150 = vsubq_f64(v227, v201);
                      float32x2_t v151 = vcvt_f32_f64(vdivq_f64(v150, v203));
                      float32x2_t v152 = vcvt_f32_f64(vdivq_f64(vaddq_f64(v150, v228), v203));
                      *(float32x2_t *)&v246[0] = v151;
                      *((float32x2_t *)&v246[0] + 1) = v152;
                      if ((v92 & 1) == 0)
                      {
                        v149.i32[0] = *(_DWORD *)(v4 + 40);
                        if (*(float *)v149.i32 != 0.0)
                        {
                          float32x2_t v153 = (float32x2_t)vdup_lane_s32(v149, 0);
                          *(float32x2_t *)&v246[0] = vsub_f32(v151, v153);
                          *((float32x2_t *)&v246[0] + 1) = vadd_f32(v153, v152);
                        }
                        int v154 = *(float32x2_t **)(v12 + 16);
                        float32x2_t v155 = v154[12];
                        uint64_t v156 = *(void *)(v67 + 40);
                        v157.i64[0] = (int)v156;
                        v157.i64[1] = SHIDWORD(v156);
                        __asm { FMOV            V3.2D, #-0.5 }
                        v154[2].i8[3] = 5;
                        uint64_t v163 = *(float32x2_t **)(v12 + 16);
                        v163[46] = vmul_f32(v155, (float32x2_t)0x3F0000003F000000);
                        v163[47] = vcvt_f32_f64(vmulq_f64(vaddq_f64(vcvtq_f64_s64(v157), _Q3), vcvtq_f64_f32(v155)));
                      }
                      int v164 = (*(unsigned __int16 *)(v1 + 40) >> 6);
                      uint64_t v165 = *(void *)(v46 + 24);
                      *(void *)&long long v232 = &v227;
                      *((void *)&v232 + 1) = v165;
                      LODWORD(v233) = v143 | v197;
                      DWORD1(v233) = v164;
                      *((void *)&v234 + 1) = 0;
                      *(void *)&long long v235 = &v244;
                      uint64_t v166 = *(void *)(v1 + 24);
                      uint64_t v167 = *(void *)(v166 + 128);
                      if (v167)
                      {
                        uint64_t v168 = *(void *)(v167 + 72);
                        if (v168)
                        {
                          CA::OGL::fill_uneven_round_rect_tex((CA::OGL::Context *)v12, (uint64_t)&v232, (float64_t *)(v168 + 24), (uint64_t)v246, *(_DWORD *)(v166 + 40) & 3);
                          goto LABEL_180;
                        }
                        uint64_t v169 = *(void *)(v167 + 56);
                        if (v169)
                        {
                          float v170 = (uint32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v169 + 80))(v169);
                          uint64_t v171 = *(void *)(v1 + 24);
                          uint64_t v172 = *(void *)(v171 + 128);
                          if (v172 && (uint64_t v173 = *(void *)(v172 + 64)) != 0)
                          {
                            if (*(_DWORD *)(v173 + 16) > 3u)
                            {
                              float64x2_t v175 = vsubq_f64(*(float64x2_t *)(v173 + 40), *(float64x2_t *)(v173 + 24));
                              v249[0] = *(_OWORD *)(v173 + 24);
                              v249[1] = v175;
                            }
                            else
                            {
                              memset(v249, 0, 32);
                            }
                          }
                          else
                          {
                            __asm { FMOV            V0.2D, #0.5 }
                            v249[0] = _Q0;
                            v249[1] = 0uLL;
                          }
                          CA::OGL::fill_corner_rect_tex((CA::OGL::Context *)v12, (double **)&v232, v170, (double *)v249, *(_DWORD *)(*(void *)(v1 + 16) + 24) & 1, (*(void *)(v171 + 40) >> 41) & 1, (uint64_t)v246, *(_WORD *)(v171 + 38) & 0xF, v139, v139, 0);
                          goto LABEL_180;
                        }
                      }
                      CA::OGL::fill_round_rect_tex((CA::OGL::Context *)v12, (float64x2_t **)&v232, (uint64_t)v246, (double *)(*(_WORD *)(v166 + 38) & 0xF), *(_DWORD *)(v166 + 40) & 3, 0, v139, v139);
LABEL_180:
                      *(unsigned char *)(*(void *)(v12 + 16) + 481) &= ~1u;
                      CA::OGL::Context::unbind_surface((void *)v12, v67, 0);
                      if (v92) {
                        CA::OGL::Context::release_surface(v12, v67);
                      }
                      *(unsigned char *)(*(void *)(v12 + 16) + 19) = 0;
                      goto LABEL_183;
                    }
                  }
                  int v143 = 0;
                  BOOL v144 = 1;
                  goto LABEL_161;
                }
LABEL_150:
                *((unsigned char *)v47 + 100) = 1;
LABEL_183:
                uint64_t v9 = v196;
                goto LABEL_184;
              }
            }
          }
          *((unsigned char *)v210 + 100) = 1;
LABEL_184:
          os_unfair_lock_unlock(v9);
          goto LABEL_185;
        }
        float64x2_t v227 = v18;
        float64x2_t v228 = v15;
      }
      float64x2_t v211 = v15;
      goto LABEL_21;
    }
  }
}

{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  const void *v15;
  uint64_t v16;
  float v17;
  float v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void v22[9];
  void __dst[62];

  __dst[61] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 8);
  int v2 = *(void *)(v1 + 8);
  if (((*(unsigned int *)(v2 + 1084) | ((unint64_t)*(unsigned __int16 *)(v2 + 1088) << 32)) & 0x200000000) != 0)
  {
    *(unsigned char *)(v1 + 101) = 1;
  }
  else if ((*(unsigned char *)(v2 + 270) & 8) == 0)
  {
    uint64_t v3 = *(void *)v1;
    if ((*(_WORD *)(*(void *)v1 + 832) & 2) == 0)
    {
      uint64_t v4 = *(void *)(v3 + 192);
      if (v4)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
        if (v5)
        {
          unint64_t v6 = v5;
          if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 616))(v5))
          {
            int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 624))(v6);
            if (v7)
            {
              uint64_t v8 = *(void *)(v3 + 264);
              do
              {
                uint64_t v9 = (_DWORD *)v8;
                uint64_t v8 = *(void *)(v8 + 8);
              }
              while (v8);
              uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 928))(v3, v7, 1);
              uint64_t v12 = v9[8];
              uint64_t v11 = v9[9];
              float v14 = v9[10];
              uint64_t v13 = v9[11];
              CA::OGL::Context::push_surface(v3, v10, 0, 0, 0);
              float64x2_t v15 = *(const void **)(v3 + 16);
              memcpy(__dst, v15, 0x1E8uLL);
              *(void *)(v3 + 16) = __dst;
              v22[4] = 0x3C003C003C003C00;
              memset(&v22[5], 0, 24);
              __dst[0] = v15;
              v22[8] = 0x4013F800000;
              void v22[2] = 0;
              void v22[3] = &CA::identity_transform;
              v22[0] = 0;
              v22[1] = &CA::Shape::_infinite_shape;
              v22[0] = CA::OGL::Context::set_gstate(v3, (uint64_t)v22);
              *(unsigned char *)(*(void *)(v3 + 16) + 481) &= ~1u;
              *(unsigned char *)(*(void *)(v3 + 16) + 16) = 1;
              CA::OGL::Context::bind_surface(v3, (uint64_t)v9, 0, 0, 0, 0.0);
              *(void *)(v3 + 128) = 0;
              int64x2_t v16 = v3 + 834;
              *(void *)(v3 + 96) = v3 + 834;
              *(_OWORD *)(v3 + 104) = xmmword_184997E70;
              if (*(void *)(v3 + 136) <= 3uLL)
              {
                *(_WORD *)(v3 + 832) |= 0x20u;
                CA::OGL::Context::array_flush(v3);
                *(void *)(v3 + 128) = 0;
                *(void *)(v3 + 96) = v16;
                *(_OWORD *)(v3 + 104) = xmmword_184997E70;
              }
              int64x2_t v17 = (float)(v14 + v12);
              float64x2_t v18 = (float)(v13 + v11);
              CA::OGL::Context::array_rect((void *)v3, (float)v12, (float)v11, v17, v18);
              int64x2_t v19 = *(void *)(v3 + 120) + 48 * *(void *)(v3 + 128);
              *(float *)(v19 - 176) = (float)v12;
              *(float *)(v19 - 172) = (float)v11;
              *(float *)(v19 - 128) = v17;
              *(float *)(v19 - 124) = (float)v11;
              *(float *)(v19 - 80) = v17;
              *(float *)(v19 - 76) = v18;
              *(float *)(v19 - 32) = (float)v12;
              *(float *)(v19 - 28) = v18;
              CA::OGL::Context::array_flush(v3);
              CA::OGL::Context::unbind_surface((void *)v3, (uint64_t)v9, 0);
              if (BYTE3(xmmword_1EB2ACC50))
              {
                *(unsigned char *)(*(void *)(v3 + 16) + 481) |= 1u;
                long long v20 = *(void *)(v3 + 16);
                *(unsigned char *)(v20 + 480) = 3;
                *(unsigned char *)(v20 + 16) = 0;
                CA::OGL::Context::bind_surface(v3, (uint64_t)v9, 0, 0, 0, 0.0);
                *(void *)(v3 + 128) = 0;
                *(void *)(v3 + 96) = v16;
                *(_OWORD *)(v3 + 104) = xmmword_184997E70;
                if (*(void *)(v3 + 136) <= 3uLL)
                {
                  *(_WORD *)(v3 + 832) |= 0x20u;
                  CA::OGL::Context::array_flush(v3);
                  *(void *)(v3 + 128) = 0;
                  *(void *)(v3 + 96) = v16;
                  *(_OWORD *)(v3 + 104) = xmmword_184997E70;
                }
                CA::OGL::Context::array_rect((void *)v3, (float)v12, (float)v11, (float)(v14 + v12), v18);
                uint64_t v21 = *(void *)(v3 + 120) + 48 * *(void *)(v3 + 128);
                *(void *)(v21 - 160) = 0x3800000000003800;
                *(void *)(v21 - 112) = 0x3800000000003800;
                *(void *)(v21 - 64) = 0x3800000000003800;
                *(void *)(v21 - 16) = 0x3800000000003800;
                CA::OGL::Context::array_flush(v3);
              }
              CA::OGL::Context::set_gstate(v3, **(void **)(v3 + 248));
              *(void *)(v3 + 16) = __dst[0];
              __dst[0] = 0;
              CA::OGL::Context::pop_surface((CA::OGL::Context *)v3);
              if (__dst[0]) {
                __assert_rtn("~ContextState", "ogl-context.h", 551, "!next && \"Imbalanced ContextState push/pop\"");
              }
            }
          }
        }
      }
    }
  }
}

float32x2_t CA::Transform::apply_to_point2(float64x2_t *this, double *a2, float *a3)
{
  char v3 = LOBYTE(this[9].f64[0]);
  if ((v3 & 0x10) != 0) {
    return CA::Mat4Impl::mat4_apply_to_point2(this, a2, a3);
  }
  if ((LOBYTE(this[9].f64[0]) & 8) == 0)
  {
    v4.i32[0] = *(_DWORD *)a2;
    if ((LOBYTE(this[9].f64[0]) & 4) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  float32x2_t v4 = vcvt_f32_f64(vmulq_n_f64(vcvtq_f64_f32(*(float32x2_t *)a2), this[8].f64[0]));
  *a2 = *(double *)&v4;
  char v3 = LOBYTE(this[9].f64[0]);
  if ((v3 & 4) != 0)
  {
LABEL_7:
    float v6 = *((float *)a2 + 1);
    *((_DWORD *)a2 + 1) = v4.i32[0];
    v4.f32[0] = -v6;
    *(float *)a2 = -v6;
    char v3 = LOBYTE(this[9].f64[0]);
  }
LABEL_8:
  if ((v3 & 2) != 0)
  {
    v4.f32[0] = -v4.f32[0];
    *(_DWORD *)a2 = v4.i32[0];
    char v3 = LOBYTE(this[9].f64[0]);
  }
  float v7 = *((float *)a2 + 1);
  if (v3) {
    float v7 = -v7;
  }
  v4.f32[1] = v7;
  float32x2_t result = vcvt_f32_f64(vaddq_f64(this[6], vcvtq_f64_f32(v4)));
  *a2 = *(double *)&result;
  return result;
}

CA::OGL::Context *CA::OGL::fill_round_rect_tex(CA::OGL::Context *result, float64x2_t **a2, uint64_t a3, double *a4, uint64_t a5, double *a6, float64_t a7, float64_t a8)
{
  _WORD v68[4] = *(double *)MEMORY[0x1E4F143B8];
  double v8 = (*a2)[1].f64[0];
  double v9 = (*a2)[1].f64[1];
  if (v8 >= v9) {
    double v10 = (*a2)[1].f64[1];
  }
  else {
    double v10 = (*a2)[1].f64[0];
  }
  if (v10 > 0.0)
  {
    int v13 = (int)a4;
    uint64_t v16 = (uint64_t)result;
    double v51 = 0.0;
    double v52 = 0.0;
    uint64_t v57 = 0;
    int64x2_t v17 = a2[1];
    if ((LOBYTE(v17[9].f64[0]) & 0x10) != 0)
    {
      double v49 = a8;
      double v50 = a7;
      CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v17, &v52, &v51, a4);
      a8 = v49;
      a7 = v50;
      double v18 = v52;
    }
    else
    {
      double v18 = v17[8].f64[0];
      double v51 = v18;
      double v52 = v18;
    }
    v19.f64[0] = a7;
    v19.f64[1] = a8;
    float64x2_t v20 = vmulq_f64(v19, (float64x2_t)vdupq_n_s64(0x3FF875696E58A32FuLL));
    if (a5) {
      double v21 = v20.f64[1];
    }
    else {
      double v21 = a8;
    }
    if (a5) {
      double v22 = v20.f64[0];
    }
    else {
      double v22 = a7;
    }
    if (v18 * v22 < 1.0) {
      return CA::OGL::fill_rect_tex((CA::OGL::Context *)v16, (uint64_t)a2, a3, a4);
    }
    if (!v13) {
      return CA::OGL::fill_rect_tex((CA::OGL::Context *)v16, (uint64_t)a2, a3, a4);
    }
    double v23 = v51;
    if (v51 * v21 < 1.0) {
      return CA::OGL::fill_rect_tex((CA::OGL::Context *)v16, (uint64_t)a2, a3, a4);
    }
    double v24 = ceil(v18 * v22);
    double v25 = ceil(v51 * v21);
    if (v24 <= v25) {
      double v24 = v25;
    }
    uint64_t v26 = (int)v24;
    unsigned int v27 = *((_DWORD *)a2 + 4);
    *(unsigned char *)(*(void *)(v16 + 16) + 16) = 5;
    uint64_t v28 = (v27 >> 21) & 1;
    if (a5)
    {
      int8x16_t v29 = (int8x16_t)vaddq_f64(vdivq_f64(vmulq_f64((*a2)[1], (float64x2_t)vdupq_n_s64(0xBFF721E8A7A4B61BLL)), v20), (float64x2_t)vdupq_n_s64(0x400721E8A7A4B61BuLL));
      __asm { FMOV            V1.2D, #1.0 }
      int8x16_t v34 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v29, (float64x2_t)_Q1), _Q1, v29);
      *(float32x2_t *)&v68[0] = vcvt_f32_f64((float64x2_t)vbicq_s8(v34, (int8x16_t)vcltzq_f64((float64x2_t)v34)));
      (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t *, uint64_t, double *))(*(void *)v16 + 464))(v16, 1, v26, 0, v28, &v57, a5, v68);
    }
    else
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t *))(*(void *)v16 + 456))(v16, 1, v26, 0, v28, &v57);
    }
    float32x2_t v36 = *a2;
    v68[0] = (*a2)->f64[0];
    v68[1] = v68[0] + v22;
    double v37 = v36[1].f64[0];
    v68[2] = v37 + v68[0] - v22;
    v68[3] = v37 + v68[0];
    v67[0] = v36->f64[1];
    v67[1] = v67[0] + v21;
    double v38 = v36[1].f64[1];
    v67[2] = v38 + v67[0] - v21;
    v67[3] = v38 + v67[0];
    float v39 = v22 / v37;
    float v40 = v21 / v38;
    float v41 = *(float *)a3;
    float v42 = *(float *)(a3 + 4);
    float v43 = *(float *)(a3 + 8);
    float v44 = *(float *)(a3 + 12);
    unint64_t v64 = __PAIR64__(*(float *)a3 + (float)((float)(v43 - *(float *)a3) * v39), *(_DWORD *)a3);
    float v65 = v43 + (float)((float)(v41 - v43) * v39);
    float v66 = v43;
    v63[0] = v42;
    v63[1] = v42 + (float)((float)(v44 - v42) * v40);
    v63[2] = v44 + (float)((float)(v42 - v44) * v40);
    v63[3] = v44;
    LODWORD(v59) = v57;
    float v60 = *(float *)&v57 + (float)((float)(*((float *)&v57 + 1) - *(float *)&v57) * 0.5);
    float v61 = v60;
    int v62 = HIDWORD(v57);
    LODWORD(v58[0]) = v57;
    v58[1] = v60;
    _DWORD v58[2] = v60;
    void v58[3] = *((float *)&v57 + 1);
    if (v37 == v38
      && (fabs(v37 + v22 * -2.0) < 1.0 ? (_ZF = v22 == v21) : (_ZF = 0),
          _ZF && ((*((unsigned char *)a2 + 20) & 0xF) == 0 || ((_BYTE)a2[2] & 9) == 0)))
    {
      BOOL v46 = a6 == 0;
      if (v13 == 15 && !a6)
      {
        *(float *)int32x2_t v56 = v41;
        *(float *)&v56[1] = v42;
        *(float *)&v56[2] = v43;
        *(float *)&v56[3] = v44;
        int v53 = v57;
        uint64_t v54 = v57;
        int v55 = HIDWORD(v57);
        CA::OGL::emit_one_part_rect((CA::OGL::Context *)v16, (uint64_t)a2, (const CA::Transform *)v56, (uint64_t)&v53, 0);
LABEL_35:
        float32x2_t result = (CA::OGL::Context *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v16 + 520))(v16, 0, 1);
        *(unsigned char *)(*(void *)(v16 + 16) + 16) = 0;
        return result;
      }
    }
    else
    {
      BOOL v46 = a6 == 0;
    }
    int v47 = v23 * v18 * (v8 * v9) >= *(double *)(v16 + 72);
    if (v46
    {
      CA::OGL::emit_nine_part_rect(v16, (uint64_t)a2, (uint64_t)v68, (uint64_t)v67, (uint64_t)&v64, (uint64_t)v63, (uint64_t)&v59, (uint64_t)v58, (((v13 & 0xF) << 22) | (v47 << 16)) ^ 0x7C00000);
    }
    goto LABEL_35;
  }
  return result;
}

float CA::OGL::anonymous namespace'::clamp_nine_part_rect(CA::OGL::_anonymous_namespace_ *this, double *a2, double *a3, float *a4, float *a5, float *a6, float *a7)
{
  double v7 = *((double *)this + 1);
  double v8 = *((double *)this + 2);
  if (v7 > v8)
  {
    float v9 = (v8 + v7) * 0.5;
    double v10 = v9;
    float v11 = (v10 - *(double *)this) / (v7 - *(double *)this);
    *((double *)this + 1) = v10;
    *((double *)this + 2) = v10;
    if (a3)
    {
      float v12 = *((float *)a3 + 3) + (float)((float)(*((float *)a3 + 2) - *((float *)a3 + 3)) * v11);
      *((float *)a3 + 1) = *(float *)a3 + (float)((float)(*((float *)a3 + 1) - *(float *)a3) * v11);
      *((float *)a3 + 2) = v12;
    }
    if (a5)
    {
      float v13 = *a5 + (float)((float)(a5[1] - *a5) * v11);
      float v14 = a5[3] + (float)((float)(a5[2] - a5[3]) * v11);
      a5[1] = v13;
      a5[2] = v14;
    }
  }
  double v15 = a2[1];
  double v16 = a2[2];
  if (v15 > v16)
  {
    float v17 = (v16 + v15) * 0.5;
    double v18 = v17;
    *(float *)&double v15 = (v18 - *a2) / (v15 - *a2);
    a2[1] = v18;
    a2[2] = v18;
    if (a4)
    {
      float v19 = a4[3] + (float)((float)(a4[2] - a4[3]) * *(float *)&v15);
      a4[1] = *a4 + (float)((float)(a4[1] - *a4) * *(float *)&v15);
      a4[2] = v19;
    }
    if (a6)
    {
      float v20 = *a6 + (float)((float)(a6[1] - *a6) * *(float *)&v15);
      *(float *)&double v15 = a6[3] + (float)((float)(a6[2] - a6[3]) * *(float *)&v15);
      a6[1] = v20;
      a6[2] = *(float *)&v15;
    }
  }
  return *(float *)&v15;
}

CA::OGL::Context *CA::OGL::fill_corner_rect_tex(CA::OGL::Context *result, double **a2, uint32x2_t *a3, double *a4, int a5, int a6, uint64_t a7, int a8, double a9, double a10, double *a11)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  double v13 = (*a2)[2];
  if (v13 >= (*a2)[3]) {
    double v13 = (*a2)[3];
  }
  if (v13 > 0.0)
  {
    double v21 = result;
    double v41 = 0.0;
    double v42 = 0.0;
    double v22 = a2[1];
    if (((_BYTE)v22[18] & 0x10) != 0)
    {
      CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v22, &v42, &v41, a4);
      double v23 = v42;
    }
    else
    {
      double v23 = v22[16];
      double v41 = v23;
      double v42 = v23;
    }
    if (v23 * a9 >= 1.0
      && a8
      && a3
      && v41 * a10 >= 1.0
      && ((v52 = 0uLL, (*((_DWORD *)v21 + 108) & 2) != 0) ? (unsigned int v24 = 2358) : (unsigned int v24 = 310),
          !a5 ? (double v25 = (double *)v24) : (double v25 = (double *)(v24 ^ 0x800)),
          *(unsigned char *)(*((void *)v21 + 2) + 16) = 5,
          (uint64_t v26 = CA::OGL::Context::bind_image((uint64_t)v21, 1u, a3, v25, 1u, 1, 0, 0, 0.0, &v52, 0)) != 0))
    {
      uint64_t v28 = v26;
      Rect v44 = 0;
      uint64_t v45 = 0;
      v43[0] = 0;
      v43[1] = 0;
      int8x16_t v29 = *a2;
      double v30 = (*a2)[1];
      v51[0] = **a2;
      v51[1] = v51[0] + a9;
      double v31 = v29[2];
      double v32 = v29[3];
      v51[2] = v31 + v51[0] - a9;
      v51[3] = v31 + v51[0];
      v50[0] = v30;
      v50[1] = v30 + a10;
      void v50[2] = v32 + v30 - a10;
      void v50[3] = v32 + v30;
      float v33 = a9 / v31;
      double v34 = a10 / v32;
      LODWORD(v32) = *(_DWORD *)(a7 + 4);
      float v35 = *(float *)(a7 + 8);
      float v36 = *(float *)(a7 + 12);
      float v37 = *(float *)a7 + (float)((float)(v35 - *(float *)a7) * v33);
      LODWORD(v47) = *(_DWORD *)a7;
      *((float *)&v47 + 1) = v37;
      *(float *)&double v34 = v34;
      float v48 = v35 + (float)((float)(*(float *)&v47 - v35) * v33);
      float v49 = v35;
      v46[0] = *(float *)&v32;
      v46[1] = *(float *)&v32 + (float)((float)(v36 - *(float *)&v32) * *(float *)&v34);
      v46[2] = v36 + (float)((float)(*(float *)&v32 - v36) * *(float *)&v34);
      v46[3] = v36;
      if (a6) {
        int v39 = 0x4000000;
      }
      else {
        int v39 = 0x8000000;
      }
      if (!a11
      {
        CA::OGL::emit_nine_part_rect((uint64_t)v21, (uint64_t)a2, (uint64_t)v51, (uint64_t)v50, (uint64_t)&v47, (uint64_t)v46, (uint64_t)&v44, (uint64_t)v43, (v39 & 0xFC3FFFFF | ((a8 & 0xF) << 22)) ^ 0x3C10000);
      }
      float32x2_t result = (CA::OGL::Context *)(*(uint64_t (**)(CA::OGL::Context *, _OWORD *, uint64_t))(*(void *)v21 + 520))(v21, v28, 1);
      *(unsigned char *)(*((void *)v21 + 2) + 16) = 0;
    }
    else
    {
      return CA::OGL::fill_rect_tex(v21, (uint64_t)a2, a7, a4);
    }
  }
  return result;
}

float CA::OGL::anonymous namespace'::map_corner_texture_coordinates(CA::OGL::_anonymous_namespace_ *this, double *a2, const Rect *a3, float *a4, float *a5)
{
  uint64_t v5 = 0;
  double v6 = a2[1];
  double v7 = a2[3];
  float v8 = *a2;
  float v9 = a2[2] + *a2;
  *(float *)&a3->bottom = v8;
  *(float *)&a3[1].top = v9;
  *(_DWORD *)&a3->top = 0;
  *(_DWORD *)&a3[1].bottom = 1065353216;
  *a4 = 0.0;
  double v10 = v7 + v6;
  *(float *)&double v6 = v6;
  *(float *)&double v10 = v10;
  a4[1] = *(float *)&v6;
  a4[2] = *(float *)&v10;
  a4[3] = 1.0;
  do
  {
    *(float *)((char *)&a3->top + v5 * 4) = *(float *)this
                                          + (float)((float)(*((float *)this + 2) - *(float *)this)
                                                  * *(float *)((char *)&a3->top + v5 * 4));
    float result = *((float *)this + 1) + (float)((float)(*((float *)this + 3) - *((float *)this + 1)) * a4[v5]);
    a4[v5++] = result;
  }
  while (v5 != 4);
  return result;
}

uint64_t CA::OGL::anonymous namespace'::clip_nine_part_rect(CA::OGL::_anonymous_namespace_ *this, double *a2, double *a3, float *a4, float *a5, float *a6, double *a7, const Rect *a8)
{
  float v8 = *a7;
  double v9 = v8;
  float v10 = a7[2] + v8;
  double v11 = v10;
  if (*(double *)this > v10 || *((double *)this + 3) < v9) {
    return 0;
  }
  double v12 = a7[1];
  double v13 = a7[3];
  uint64_t v14 = 1;
  while (1)
  {
    double v15 = *((double *)this + v14);
    if (v15 > v11) {
      break;
    }
    if (++v14 == 4) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = (v14 << 32) - 0x100000000;
  uint64_t v17 = v16 >> 32;
  float v18 = (v11 - *(double *)((char *)this + (v16 >> 29))) / (v15 - *(double *)((char *)this + (v16 >> 29)));
  if (a3) {
    *((float *)a3 + v14) = *((float *)a3 + v17) + (float)((float)(*((float *)a3 + v14) - *((float *)a3 + v17)) * v18);
  }
  if (a5) {
    a5[v14] = a5[v17] + (float)((float)(a5[v14] - a5[v17]) * v18);
  }
  *((double *)this + v14) = v11;
  if (v14 <= 2)
  {
    uint64_t v19 = v14 - 1;
    do
    {
      *((void *)this + v19 + 2) = *((void *)this + v14);
      if (a3) {
        *((_DWORD *)a3 + v19 + 2) = *((_DWORD *)a3 + v14);
      }
      if (a5) {
        a5[v19 + 2] = a5[v14];
      }
      ++v19;
    }
    while (v19 != 2);
  }
LABEL_18:
  uint64_t v20 = 0;
  while (1)
  {
    double v21 = *((double *)this + v20 + 2);
    if (v21 < v9) {
      break;
    }
    if (--v20 == -3) {
      goto LABEL_33;
    }
  }
  uint64_t v22 = v20 + 2;
  uint64_t v23 = (v20 + 3);
  float v24 = (v9 - v21) / (*((double *)this + v23) - v21);
  if (a3) {
    *((float *)a3 + v22) = *((float *)a3 + v22) + (float)((float)(*((float *)a3 + v23) - *((float *)a3 + v22)) * v24);
  }
  if (a5) {
    a5[v22] = a5[v22] + (float)((float)(a5[v23] - a5[v22]) * v24);
  }
  *((double *)this + v22) = v9;
  if (v20 != -2)
  {
    unsigned int v25 = v20 + 1;
    do
    {
      uint64_t v26 = v25;
      *((void *)this + v25) = *((void *)this + v22);
      if (a3) {
        *((_DWORD *)a3 + v25) = *((_DWORD *)a3 + v22);
      }
      if (a5) {
        a5[v25] = a5[v22];
      }
      --v25;
    }
    while (v26);
  }
LABEL_33:
  float v27 = v12;
  double v28 = v27;
  float v29 = v13 + v28;
  double v30 = v29;
  if (*a2 > v30 || a2[3] < v28) {
    return 0;
  }
  uint64_t v32 = 1;
  while (1)
  {
    double v33 = a2[v32];
    if (v33 > v30) {
      break;
    }
    if (++v32 == 4) {
      goto LABEL_51;
    }
  }
  uint64_t v34 = (v32 << 32) - 0x100000000;
  uint64_t v35 = v34 >> 32;
  float v36 = (v30 - *(double *)((char *)a2 + (v34 >> 29))) / (v33 - *(double *)((char *)a2 + (v34 >> 29)));
  if (a4) {
    a4[v32] = a4[v35] + (float)((float)(a4[v32] - a4[v35]) * v36);
  }
  if (a6) {
    a6[v32] = a6[v35] + (float)((float)(a6[v32] - a6[v35]) * v36);
  }
  a2[v32] = v30;
  if (v32 <= 2)
  {
    uint64_t v37 = v32 - 1;
    do
    {
      a2[v37 + 2] = a2[v32];
      if (a4) {
        a4[v37 + 2] = a4[v32];
      }
      if (a6) {
        a6[v37 + 2] = a6[v32];
      }
      ++v37;
    }
    while (v37 != 2);
  }
LABEL_51:
  uint64_t v38 = 0;
  while (1)
  {
    double v39 = a2[v38 + 2];
    if (v39 < v28) {
      break;
    }
    if (--v38 == -3) {
      return 1;
    }
  }
  uint64_t v40 = v38 + 2;
  uint64_t v41 = (v38 + 3);
  float v42 = (v28 - v39) / (a2[v41] - v39);
  if (a4) {
    a4[v40] = a4[v40] + (float)((float)(a4[v41] - a4[v40]) * v42);
  }
  if (a6) {
    a6[v40] = a6[v40] + (float)((float)(a6[v41] - a6[v40]) * v42);
  }
  a2[v40] = v28;
  if (v38 == -2) {
    return 1;
  }
  unsigned int v43 = v38 + 1;
  uint64_t result = 1;
  do
  {
    uint64_t v44 = v43;
    a2[v43] = a2[v40];
    if (a4) {
      a4[v43] = a4[v40];
    }
    if (a6) {
      a6[v43] = a6[v40];
    }
    --v43;
  }
  while (v44);
  return result;
}

void CA::OGL::VariableBlurFilter::render(float a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  if (a7)
  {
    uint64_t v12 = *(void *)(a4 + 40);
    if (v12)
    {
      uint64_t v13 = *(unsigned int *)(v12 + 16);
      if (v13)
      {
        uint64_t v20 = 0;
        uint64_t v21 = v12 + 24;
        while (1)
        {
          uint64_t v22 = *(void *)(v21 + 8 * v20);
          if (*(_DWORD *)(v22 + 16) == 304) {
            break;
          }
          if (v13 == ++v20) {
            return;
          }
        }
        if ((v20 & 0x80000000) == 0)
        {
          uint64_t v23 = *(void *)(v22 + 24);
          if (v23)
          {
            uint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 80))(v23);
            if (v24)
            {
              uint64_t v26 = v24;
              long long v77 = 0u;
              long long v76 = 0u;
              long long v75 = 0u;
              DWORD1(v77) = 15;
              uint64_t v27 = *(void *)(*(void *)(a6 + 248) + 24);
              double v72 = 0.0;
              double v73 = 0.0;
              if ((*(unsigned char *)(v27 + 144) & 0x10) != 0)
              {
                CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v27, &v73, &v72, v25);
                double v28 = v72;
                double v29 = v73;
              }
              else
              {
                double v28 = *(double *)(v27 + 128);
                double v72 = v28;
                double v73 = v28;
                double v29 = v28;
              }
              float v30 = v29;
              float v31 = v28;
              uint64_t v32 = *(CA::Render::KeyValueArray **)(a4 + 40);
              float float_key = CA::Render::KeyValueArray::get_float_key(v32, 310, 0.0);
              float v34 = float_key * a2;
              v74[0] = v34 * v30;
              v74[1] = v34 * v31;
              uint64_t v35 = *(void *)(a5 + 24);
              float64x2_t v54 = *(float64x2_t *)(v35 + 80);
              v71[0] = *(int8x16_t *)(v35 + 64);
              v71[1] = (int8x16_t)v54;
              CA::Rect::apply_transform(v71, (const CA::Transform *)v27, v36);
              *(void *)&long long v76 = v71;
              *((void *)&v76 + 1) = a10;
              BYTE8(v77) = 16 * (CA::Render::KeyValueArray::get_int_key(v32, 292, 0) != 0);
              LODWORD(v77) = 0;
              LODWORD(v77) = 2 * (CA::Render::KeyValueArray::get_int_key(v32, 305, 0) != 0);
              float64x2_t v38 = *(float64x2_t *)v27;
              float64x2_t v39 = *(float64x2_t *)(v27 + 16);
              float64x2_t v40 = *(float64x2_t *)(v27 + 32);
              float64x2_t v41 = *(float64x2_t *)(v27 + 48);
              float64x2_t v43 = *(float64x2_t *)(v27 + 64);
              float64x2_t v42 = *(float64x2_t *)(v27 + 80);
              float64x2_t v44 = *(float64x2_t *)(v27 + 96);
              float64x2_t v45 = *(float64x2_t *)(v27 + 112);
              float64x2_t v69 = v44;
              float64x2_t v70 = v45;
              float64x2_t v46 = vmulq_n_f64(v38, v54.f64[0]);
              float64x2_t v47 = vmulq_n_f64(v39, v54.f64[0]);
              float64x2_t v48 = vmulq_laneq_f64(v40, v54, 1);
              float64x2_t v49 = vmulq_laneq_f64(v41, v54, 1);
              float64x2_t v63 = v46;
              float64x2_t v64 = v47;
              float64x2_t v65 = v48;
              float64x2_t v66 = v49;
              float64x2_t v67 = v43;
              float64x2_t v68 = v42;
              if (((*(unsigned char *)(a6 + 432) & 2) == 0) != (*(unsigned char *)(*(void *)(a5 + 16) + 24) & 1))
              {
                float64x2_t v69 = vmlaq_f64(vaddq_f64(vmlaq_f64(v44, (float64x2_t)0, v46), v48), (float64x2_t)0, v43);
                float64x2_t v70 = vmlaq_f64(vaddq_f64(vmlaq_f64(v45, (float64x2_t)0, v47), v49), (float64x2_t)0, v42);
                float64x2_t v64 = v47;
                float64x2_t v65 = vnegq_f64(v48);
                float64x2_t v66 = vnegq_f64(v49);
                float64x2_t v68 = v42;
              }
              long long v61 = 0u;
              long long v62 = 0u;
              long long v59 = 0u;
              long long v60 = 0u;
              float64x2_t v57 = 0u;
              float64x2_t v58 = 0u;
              float64x2_t v55 = 0u;
              float64x2_t v56 = 0u;
              CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)&v55, (CA::Mat4Impl *)&v63, v37);
              double v50 = (float)(1.0 / a2);
              float64x2_t v55 = vmulq_n_f64(v55, v50);
              float64x2_t v56 = vmulq_n_f64(v56, v50);
              float64x2_t v57 = vmulq_n_f64(v57, v50);
              float64x2_t v58 = vmulq_n_f64(v58, v50);
              uint64_t v51 = *(void *)(a6 + 16);
              unint64_t v52 = *(void *)(v51 + 16) & 0xFFFFFF00FF00FF00;
              if (*(void *)(v51 + 8) == 0x3C003C003C003C00) {
                int v53 = 1;
              }
              else {
                int v53 = 3;
              }
              *(_DWORD *)(v51 + 16) = v53 | v52;
              *(_DWORD *)(v51 + 20) = HIDWORD(v52);
              (*(void (**)(uint64_t, uint64_t, uint64_t, float64x2_t *, float *, uint64_t, float, float))(*(void *)a6 + 856))(a6, a7, v26, &v55, v74, a11, a1, a2);
              *(unsigned char *)(*(void *)(a6 + 16) + 16) = 0;
            }
          }
        }
      }
    }
  }
}

void CA::OGL::Context::variable_masked_blur_surface(uint64_t a1, uint64_t a2, uint32x2_t *a3, float64x2_t *a4, uint64_t a5, float a6, float a7)
{
  __dst[61] = *MEMORY[0x1E4F143B8];
  if (BYTE5(xmmword_1EB2ACBF0))
  {
    uint64_t PerfHud = CA::OGL::GetPerfHud((CA::OGL *)a1);
    if (PerfHud) {
      ++*(void *)(PerfHud + 464);
    }
  }
  int v14 = *(_DWORD *)(a2 + 24);
  if (v14)
  {
    int v15 = *(_DWORD *)(a2 + 28);
    if (v15)
    {
      float v16 = *(float *)a5;
      float v17 = *(float *)a5 * 2.6;
      if (v14 <= v15) {
        int v14 = *(_DWORD *)(a2 + 28);
      }
      unsigned int v18 = vcvtpd_u64_f64(log2((double)v14));
      float v19 = ceilf(log2f(v17)) + 1.0;
      v21.i32[1] = 0;
      if (v19 <= 0.0) {
        float v19 = 0.0;
      }
      if (v19 >= v18) {
        uint64_t v22 = v18;
      }
      else {
        uint64_t v22 = v19;
      }
      if (v22 >= 7) {
        int v23 = 7;
      }
      else {
        int v23 = v22;
      }
      float v24 = (float)(1 << v23);
      long long v25 = *(_OWORD *)(a2 + 32);
      int v26 = *(void *)(a2 + 40);
      if (SDWORD2(v25) <= SHIDWORD(v25)) {
        int v26 = HIDWORD(*(_OWORD *)(a2 + 32));
      }
      v21.i32[0] = 1073741822;
      v20.i32[0] = v26;
      v27.i64[0] = (int)v25;
      v27.i64[1] = SDWORD1(v25);
      int8x16_t v28 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v20, v21), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v27));
      v27.i64[0] = SDWORD2(v25);
      v27.i64[1] = SHIDWORD(v25);
      int8x16_t v29 = (int8x16_t)vcvtq_f64_s64(v27);
      int32x2_t v30 = vdup_n_s32(v26 > 1073741822);
      v27.i64[0] = v30.u32[0];
      v27.i64[1] = v30.u32[1];
      float64x2_t v123 = (float64x2_t)v28;
      int8x16_t v124 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v27, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v29);
      CA::BoundsImpl::inset(v123.f64, (float)-v16 * 2.8, (float)-*(float *)(a5 + 4) * 2.8);
      if ((float)(1.0 / v24) != 1.0)
      {
        double v31 = (float)(1.0 / v24);
        if (*(double *)v124.i64 < 1.79769313e308)
        {
          v123.f64[0] = v123.f64[0] * v31;
          *(double *)v124.i64 = *(double *)v124.i64 * v31;
        }
        if (*(double *)&v124.i64[1] < 1.79769313e308)
        {
          v123.f64[1] = v123.f64[1] * v31;
          *(double *)&v124.i64[1] = *(double *)&v124.i64[1] * v31;
        }
      }
      float64x2_t v32 = (float64x2_t)v124;
      double v33 = *(double *)&v124.i64[1];
      if (*(double *)v124.i64 <= *(double *)&v124.i64[1]) {
        double v34 = *(double *)&v124.i64[1];
      }
      else {
        double v34 = *(double *)v124.i64;
      }
      if (v34 < 1.79769313e308)
      {
        if (*(double *)v124.i64 < *(double *)&v124.i64[1]) {
          double v33 = *(double *)v124.i64;
        }
        if (v33 > 0.0)
        {
          float64x2_t v35 = vrndmq_f64(v123);
          float64x2_t v32 = vsubq_f64(vrndpq_f64(vaddq_f64(v123, (float64x2_t)v124)), v35);
          float64x2_t v123 = v35;
          int8x16_t v124 = (int8x16_t)v32;
        }
      }
      if (v23)
      {
        double v36 = (double)(1 << v23);
        if (v32.f64[0] < 1.79769313e308)
        {
          v123.f64[0] = v123.f64[0] * v36;
          *(double *)v124.i64 = v32.f64[0] * v36;
        }
        if (v32.f64[1] < 1.79769313e308)
        {
          v123.f64[1] = v123.f64[1] * v36;
          *(double *)&v124.i64[1] = v32.f64[1] * v36;
        }
      }
      float64x2_t v115 = v123;
      int64x2_t v37 = vceqzq_f64((float64x2_t)v124);
      int32x4_t v38 = 0uLL;
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v37, 1), (int8x16_t)v37).u64[0] & 0x8000000000000000) == 0)
      {
        int8x16_t v39 = vorrq_s8((int8x16_t)vcltzq_f64((float64x2_t)v124), (int8x16_t)vcgezq_f64((float64x2_t)v124));
        if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v39), 1), v39).u64[0] & 0x8000000000000000) == 0)
        {
          int32x4_t v40 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v123, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
          int32x4_t v38 = vuzp1q_s32(v40, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v123, (float64x2_t)v124), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v40));
        }
      }
      float v41 = (float)v38.i32[3];
      LODWORD(__dst[1]) = v38.i32[2];
      int8x16_t v114 = (int8x16_t)v38;
      __dst[0] = v38.i64[0];
      HIDWORD(__dst[1]) = (int)(float)v38.i32[3];
      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)a1 + 656))(a1, 1, __dst, 527);
      if (v42)
      {
        uint64_t v43 = v42;
        float v113 = a7;
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 704))(a1, v42, 16, 16);
        int v46 = *(_DWORD *)(a2 + 40);
        int v47 = *(_DWORD *)(a2 + 44);
        if (v46 <= v47) {
          int v48 = *(_DWORD *)(a2 + 44);
        }
        else {
          int v48 = *(_DWORD *)(a2 + 40);
        }
        v44.i32[0] = 1073741822;
        v45.i32[0] = v48;
        int32x4_t v49 = vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v45, v44), 0);
        uint64_t v50 = *(void *)(a2 + 32);
        v51.i64[0] = (int)v50;
        v51.i64[1] = SHIDWORD(v50);
        int8x16_t v117 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
        int8x16_t v118 = (int8x16_t)v49;
        int8x16_t v109 = (int8x16_t)vcvtq_f64_s64(v51);
        if (v48 <= 1073741822) {
          double v52 = (double)v46;
        }
        else {
          double v52 = 1.79769313e308;
        }
        if (v48 <= 1073741822) {
          double v53 = (double)v47;
        }
        else {
          double v53 = 1.79769313e308;
        }
        float64x2_t v54 = *(const void **)(a1 + 16);
        memcpy(__dst, v54, 0x1E8uLL);
        uint64_t v138 = 0;
        __dst[0] = v54;
        *(void *)(a1 + 16) = __dst;
        uint64_t v55 = *(void *)(a1 + 248);
        v137[4] = 0x3C003C003C003C00;
        memset(&v137[5], 0, 24);
        v137[0] = 0;
        if (v55)
        {
          float v56 = *(float *)(v55 + 64);
          __int16 v57 = *(_WORD *)(v55 + 68) & 0x500 | 1;
        }
        else
        {
          __int16 v57 = 1025;
          float v56 = 1.0;
        }
        float v111 = v17;
        float v112 = a6;
        int8x16_t v119 = vbslq_s8(v118, v117, v109);
        *(float *)&uint64_t v138 = v56;
        WORD2(v138) = v57;
        v137[2] = 0;
        v137[3] = &CA::identity_transform;
        v137[1] = &CA::Shape::_infinite_shape;
        v137[0] = CA::OGL::Context::set_gstate(a1, (uint64_t)v137);
        *(unsigned char *)(*(void *)(a1 + 16) + 481) &= ~1u;
        int v110 = *(unsigned __int8 *)(a1 + 64);
        *(unsigned char *)(a1 + 64) = 0;
        *(unsigned char *)(*(void *)(a1 + 16) + 16) = 1;
        CA::OGL::Context::push_surface(a1, v43, 1u, 0, 0);
        CA::OGL::Context::bind_surface(a1, a2, 0, 1u, 1, 0.0);
        *(void *)(a1 + 128) = 0;
        uint64_t v58 = a1 + 834;
        *(void *)(a1 + 96) = a1 + 834;
        *(_OWORD *)(a1 + 104) = xmmword_184997E70;
        if (*(void *)(a1 + 136) <= 3uLL)
        {
          *(_WORD *)(a1 + 832) |= 0x20u;
          CA::OGL::Context::array_flush(a1);
          *(void *)(a1 + 128) = 0;
          *(void *)(a1 + 96) = v58;
          *(_OWORD *)(a1 + 104) = xmmword_184997E70;
        }
        float v59 = *(double *)v119.i64;
        float v60 = *(double *)&v119.i64[1];
        float v61 = v52 + *(double *)v119.i64;
        float v62 = v53 + *(double *)&v119.i64[1];
        CA::OGL::Context::array_rect((void *)a1, v59, v60, v61, v62);
        float v63 = v52;
        float v64 = v53;
        uint64_t v65 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
        *(void *)(v65 - 176) = 0;
        *(float *)(v65 - 128) = v63;
        *(_DWORD *)(v65 - 124) = 0;
        *(float *)(v65 - 80) = v63;
        *(float *)(v65 - 76) = v64;
        *(_DWORD *)(v65 - 32) = 0;
        *(float *)(v65 - 28) = v64;
        CA::OGL::Context::array_flush(a1);
        CA::OGL::Context::unbind_surface((void *)a1, a2, 0);
        CA::OGL::Context::pop_surface((CA::OGL::Context *)a1);
        *(unsigned char *)(*(void *)(a1 + 16) + 16) = 38;
        CA::OGL::Context::bind_surface(a1, v43, 0, 1u, 1, 0.0);
        __asm { FMOV            V14.2S, #1.0 }
        v135[0] = _D14;
        if (v22 >= 2)
        {
          uint64_t v72 = 0;
          float32x2_t v73 = vcvt_f32_s32(*(int32x2_t *)(v43 + 24));
          uint64_t v76 = v22 - 1;
          LODWORD(v66) = 2.0;
          do
          {
            *(float *)&long long buf = (float)v72;
            float32x2_t v77 = vmul_f32(v73, (float32x2_t)0x3F0000003F000000);
            float32x2_t v78 = vrndm_f32(v77);
            float32x2_t v73 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(_D14, v78), (int8x8_t)_D14, (int8x8_t)v78);
            float32x2_t v79 = vcvt_f32_s32(*(int32x2_t *)(v43 + 24));
            long long v120 = v66;
            v135[v72 + 1] = vdiv_f32(v79, vmul_n_f32(v73, *(float *)&v66));
            CA::OGL::Context::push_surface(a1, v43, 1u, 0, v72 + 1);
            (*(void (**)(uint64_t, void, uint64_t, uint64_t, long long *))(*(void *)a1 + 1000))(a1, 0, 1, 1, &buf);
            *(void *)(a1 + 128) = 0;
            *(void *)(a1 + 96) = v58;
            *(_OWORD *)(a1 + 104) = xmmword_184997E70;
            if (*(void *)(a1 + 136) <= 3uLL)
            {
              *(_WORD *)(a1 + 832) |= 0x20u;
              CA::OGL::Context::array_flush(a1);
              *(void *)(a1 + 128) = 0;
              *(void *)(a1 + 96) = v58;
              *(_OWORD *)(a1 + 104) = xmmword_184997E70;
            }
            float32x2_t v80 = vdiv_f32(vmul_f32(v77, v79), v73);
            long long v81 = v120;
            *(float *)&long long v81 = *(float *)&v81 + *(float *)&v81;
            long long v121 = v81;
            *(float *)&long long v81 = v115.f64[0] + v80.f32[0];
            float v82 = v115.f64[1] + v80.f32[1];
            float v74 = v115.f64[0];
            float v75 = v115.f64[1];
            CA::OGL::Context::array_rect((void *)a1, v74, v75, *(float *)&v81, v82);
            float v83 = (float)*(int *)(v43 + 24);
            float v84 = (float)*(int *)(v43 + 28);
            uint64_t v85 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
            *(void *)(v85 - 176) = 0;
            *(float *)(v85 - 128) = v83;
            *(_DWORD *)(v85 - 124) = 0;
            *(float *)(v85 - 80) = v83;
            *(float *)(v85 - 76) = v84;
            *(_DWORD *)(v85 - 32) = 0;
            *(float *)(v85 - 28) = v84;
            CA::OGL::Context::array_flush(a1);
            CA::OGL::Context::pop_surface((CA::OGL::Context *)a1);
            long long v66 = v121;
            ++v72;
          }
          while (v76 != v72);
        }
        CA::OGL::Context::unbind_surface((void *)a1, v43, 0);
        CA::OGL::Context::set_gstate(a1, **(void **)(a1 + 248));
        uint64_t v86 = __dst[0];
        *(void *)(a1 + 16) = __dst[0];
        __dst[0] = 0;
        *(unsigned char *)(v86 + 16) = 39;
        *(_WORD *)(v43 + 75) |= 0x200u;
        CA::OGL::Context::bind_surface(a1, v43, 0, 1u, 1, 0.0);
        float32x4_t v134 = 0uLL;
        uint64_t v87 = CA::OGL::Context::bind_image(a1, 1u, a3, (double *)0x100, 1u, 1, 2, 0, 0.0, &v134, 0);
        uint64_t v88 = v87;
        if (v87)
        {
          unsigned int v89 = *((unsigned char *)v87 + 55) & 0x3F;
          if (v89 > 0x15 || ((1 << v89) & 0x200101) == 0)
          {
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              uint64_t v106 = x_log_category_ogl;
              if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR))
              {
                if ((*((unsigned char *)v88 + 55) & 0x3Fu) > 0x29) {
                  uint64_t v107 = "UNKNOWN";
                }
                else {
                  uint64_t v107 = CA::OGL::image_function_name(CA::OGL::ImageFunction)::names[*((unsigned char *)v88 + 55) & 0x3F];
                }
                LODWORD(buf) = 136315138;
                *(void *)((char *)&buf + 4) = v107;
                _os_log_impl(&dword_184668000, v106, OS_LOG_TYPE_ERROR, "Unsupported image function %s", (uint8_t *)&buf, 0xCu);
              }
            }
          }
        }
        __int32 v116 = v88;
        float v90 = 1.0;
        if ((*(unsigned char *)(a5 + 48) & 0x10) != 0) {
          float v91 = 1.0;
        }
        else {
          float v91 = 0.0;
        }
        *(float *)uint64_t v133 = v111;
        *(float *)&v133[1] = v91;
        if (*(_DWORD *)(a5 + 40) != 2) {
          float v90 = 0.0;
        }
        float v92 = 0.0 / (float)*(int *)(v43 + 28);
        *(float *)&v133[2] = v90;
        *(float *)&v133[3] = v92;
        (*(void (**)(uint64_t, void, uint64_t, uint64_t, _DWORD *))(*(void *)a1 + 1000))(a1, 0, 4, 1, v133);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 1000))(a1, 1, 4, 4, v135);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 1000))(a1, 2, 4, 4, &v136);
        uint64_t v94 = 0;
        float32x2_t v95 = vmul_n_f32(vcvt_f32_s32(vadd_s32((int32x2_t)*(_OWORD *)&vextq_s8(v114, v114, 8uLL), *(int32x2_t *)v114.i8)), v112 / v113);
        HIDWORD(v132) = v95.i32[1];
        *(float *)&uint64_t v129 = (float)(v112 / v113) * (float)v114.i32[0];
        *((float *)&v129 + 1) = (float)(v112 / v113) * (float)v114.i32[1];
        LODWORD(v130) = v95.i32[0];
        *((float *)&v130 + 1) = *((float *)&v129 + 1);
        float32x2_t v131 = v95;
        *(float *)&uint64_t v132 = *(float *)&v129;
        float32x2_t v96 = v95;
        do
        {
          CA::Mat4Impl::mat4_apply_to_point2(a4, (double *)((char *)&v129 + v94), v93);
          v94 += 8;
        }
        while (v94 != 32);
        long long v128 = 0u;
        uint64_t v97 = *(void *)(*(void *)(a1 + 248) + 8);
        *(void *)&long long buf = a1;
        *((void *)&buf + 1) = v97;
        long long v127 = 0u;
        uint64_t v126 = 0;
        WORD4(v127) = 256;
        CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)&buf);
        v122[0] = 0;
        v122[1] = 0;
        float v98 = (float)v114.i32[2];
        uint64_t v99 = v129;
        uint64_t v100 = v130;
        float32x2_t v102 = v131;
        uint64_t v101 = v132;
        while (CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)&buf, v122))
        {
          if (*(_DWORD *)(a1 + 92)) {
            uint64_t v103 = 6;
          }
          else {
            uint64_t v103 = 4;
          }
          if ((unint64_t)(*(void *)(a1 + 128) + 4) > *(void *)(a1 + 136)
            || (unint64_t v104 = *(void *)(a1 + 112)) != 0 && *(void *)(a1 + 104) + v103 > v104)
          {
            *(_WORD *)(a1 + 832) |= 0x20u;
            CA::OGL::Context::array_flush(a1);
            *(void *)(a1 + 128) = 0;
            *(void *)(a1 + 96) = v58;
            *(_OWORD *)(a1 + 104) = xmmword_184997E70;
          }
          CA::OGL::Context::array_rect((void *)a1, (float)(v112 / v113) * (float)v114.i32[0], (float)(v112 / v113) * (float)v114.i32[1], v96.f32[0], v96.f32[1]);
          uint64_t v105 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
          *(void *)(v105 - 176) = 0;
          *(void *)(v105 - 168) = v99;
          *(float *)(v105 - 128) = v98;
          *(_DWORD *)(v105 - 124) = 0;
          *(float *)(v105 - 80) = v98;
          *(float *)(v105 - 76) = v41;
          *(_DWORD *)(v105 - 32) = 0;
          *(float *)(v105 - 28) = v41;
          *(void *)(v105 - 120) = v100;
          *(float32x2_t *)(v105 - 72) = v102;
          *(void *)(v105 - 24) = v101;
        }
        (*(void (**)(uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 520))(a1, v116, 1);
        CA::OGL::Context::unbind_surface((void *)a1, v43, 0);
        CA::OGL::Context::release_surface(a1, v43);
        if (v110) {
          *(unsigned char *)(a1 + 64) = 1;
        }
        if (__dst[0]) {
          __assert_rtn("~ContextState", "ogl-context.h", 551, "!next && \"Imbalanced ContextState push/pop\"");
        }
      }
    }
  }
}

float32x2_t CA::Mat4Impl::mat4_apply_to_point2(float64x2_t *this, double *a2, float *a3)
{
  double v3 = *(float *)a2;
  double v4 = *((float *)a2 + 1);
  float v5 = this[7].f64[1] + this[1].f64[1] * v3 + this[3].f64[1] * v4;
  if (fabsf(v5 + -1.0) >= 0.000001)
  {
    if (v5 <= 0.0) {
      float v5 = INFINITY;
    }
    else {
      float v5 = 1.0 / v5;
    }
  }
  float32x2_t result = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(this[6], *this, v3), this[2], v4), v5));
  *a2 = *(double *)&result;
  return result;
}

void CA::OGL::MaskCorners::finish(CA::OGL::MaskCorners *this, CA::OGL::ImagingNode *a2)
{
  v105[1] = *(float32x2_t *)MEMORY[0x1E4F143B8];
  if (!*((void *)this + 24) && (*((unsigned char *)this + 244) & 4) == 0) {
    return;
  }
  double v3 = (void *)**((void **)a2 + 1);
  uint64_t v102 = 0;
  float32x4_t v101 = 0uLL;
  *(unsigned char *)(v3[2] + 16) = 15;
  if ((*(unsigned int (**)(void *))(*v3 + 984))(v3)
    && (*((unsigned char *)this + 244) & 4) == 0
    && ((*(uint64_t (**)(void *))(*v3 + 760))(v3) & 1) == 0)
  {
    *(unsigned char *)(v3[2] + 480) = 58;
    int32x4_t v40 = (uint32x2_t *)*((void *)this + 25);
    if (v40)
    {
      uint64_t v87 = CA::OGL::Context::bind_image((uint64_t)v3, 0, v40, (double *)*((unsigned int *)this + 60), 1u, 1, 0, 0, 0.0, &v101, 0);
    }
    else
    {
      unsigned int v41 = *((_DWORD *)this + 1);
      if (*(_DWORD *)this <= (signed int)v41) {
        uint64_t v42 = v41;
      }
      else {
        uint64_t v42 = *(unsigned int *)this;
      }
      if ((*((unsigned char *)this + 244) & 3) != 0) {
        (*(void (**)(void *, void, uint64_t, void, void, uint64_t *, void, char *))(*v3 + 464))(v3, 0, v42, 0, 0, &v102, *((unsigned char *)this + 244) & 3, (char *)this + 168);
      }
      else {
        (*(void (**)(void *, void, uint64_t, void, void, uint64_t *))(*v3 + 456))(v3, 0, v42, 0, 0, &v102);
      }
      uint64_t v87 = 0;
    }
    CA::OGL::Context::bind_surface((uint64_t)v3, *((void *)this + 24), 1u, 0, 0, 0.0);
    uint64_t v43 = *(void *)(v3[31] + 8);
    *(void *)&long long v98 = v3;
    *((void *)&v98 + 1) = v43;
    memset(v99, 0, 40);
    LOWORD(v99[1]) = 256;
    CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)&v98);
    v94[0] = 0uLL;
    if ((*((unsigned char *)this + 244) & 8) != 0)
    {
      float v44 = *(float *)&v102;
      float v45 = v44 + (float)((float)(*((float *)&v102 + 1) - v44) * 0.5);
      *(unsigned char *)(v3[2] + 19) = 5;
      int v46 = (float *)v3[2];
      v46[92] = v44;
      v46[93] = v44;
      v46[94] = v45;
      v46[95] = v45;
    }
    while (CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)&v98, (int32x2_t *)v94))
    {
      for (uint64_t i = 0; i != 4; ++i)
      {
        if (!*((unsigned char *)this + i + 184))
        {
          if (*((_DWORD *)v3 + 23)) {
            uint64_t v48 = 6;
          }
          else {
            uint64_t v48 = 4;
          }
          uint64_t v49 = v3[16];
          if ((unint64_t)(v49 + 4) > v3[17] || (unint64_t v50 = v3[14]) != 0 && v3[13] + v48 > v50)
          {
            *((_WORD *)v3 + 416) |= 0x20u;
            CA::OGL::Context::array_flush((uint64_t)v3);
            uint64_t v49 = 0;
            v3[12] = (char *)v3 + 834;
            *(_OWORD *)(v3 + 13) = xmmword_184997E70;
          }
          float32x2_t v51 = *(float32x2_t *)((char *)this + 8 * i + 40);
          float32x2_t v52 = vadd_f32(*(float32x2_t *)((char *)this + 8), v51);
          float32x2_t v53 = vadd_f32(*(float32x2_t *)((char *)this + 16), v51);
          float32x2_t v54 = vadd_f32(*(float32x2_t *)((char *)this + 24), v51);
          float32x2_t v55 = vadd_f32(*(float32x2_t *)((char *)this + 32), v51);
          uint64_t v56 = v3[15];
          __int16 v57 = (float32x2_t *)(v56 + 48 * v49);
          uint64_t v58 = v49 + 4;
          v3[16] = v49 + 4;
          float32x2_t *v57 = v52;
          v57[1] = (float32x2_t)0x3F80000000000000;
          v57[6] = v53;
          v57[7] = (float32x2_t)0x3F80000000000000;
          v57[12] = v54;
          v57[13] = (float32x2_t)0x3F80000000000000;
          v57[18] = v55;
          v57[19] = (float32x2_t)0x3F80000000000000;
          if (v3[12])
          {
            CA::OGL::Context::array_indices((uint64_t)v3, v49);
            uint64_t v56 = v3[15];
            uint64_t v58 = v3[16];
          }
          uint64_t v59 = v56 + 48 * v58;
          *(void *)(v59 - 160) = 0x3C003C003C003C00;
          *(void *)(v59 - 112) = 0x3C003C003C003C00;
          *(void *)(v59 - 64) = 0x3C003C003C003C00;
          *(void *)(v59 - 16) = 0x3C003C003C003C00;
          int8x16_t v95 = 0uLL;
          if (*((void *)this + 25)) {
            CA::OGL::MaskCorners::corner_contents_texcoord(this, i, v101.f32, (float *)v95.i32);
          }
          else {
            CA::OGL::MaskCorners::corner_circle_texcoord((uint64_t)this, i, (const float *)&v102, (float *)v95.i32);
          }
          int8x16_t v60 = v95;
          uint64_t v61 = v3[15] + 48 * v3[16];
          *(void *)(v61 - 176) = v95.i64[0];
          *(_DWORD *)(v61 - 128) = v60.i32[2];
          *(_DWORD *)(v61 - 124) = v60.i32[1];
          *(void *)(v61 - 80) = v60.i64[1];
          *(_DWORD *)(v61 - 32) = v60.i32[0];
          *(_DWORD *)(v61 - 28) = v60.i32[3];
          float32x2_t v103 = 0;
          v105[0] = 0;
          float32x2_t v92 = 0;
          float32x2_t v93 = 0;
          CA::OGL::MaskCorners::corner_quad((float32x2_t *)this, i, &v103, v105, &v93, &v92);
          *(float32x2_t *)(v61 - 168) = v103;
          *(float32x2_t *)(v61 - 120) = v105[0];
          *(float32x2_t *)(v61 - 72) = v93;
          *(float32x2_t *)(v61 - 24) = v92;
          if (!*((void *)this + 25))
          {
            uint64_t v62 = v3[15] + 48 * *((unsigned int *)v3 + 32) - 192;
            int v63 = CA::OGL::MaskCorners::finish(CA::OGL::ImagingNode *)::quad_inner_vertex_index[i];
            float v64 = (long long *)(v62 + 48 * (((_BYTE)v63 + 1) & 3));
            long long v65 = *v64;
            long long v66 = v64[2];
            float64x2_t v67 = (_OWORD *)(v62 + 48 * v63);
            v67[1] = v64[1];
            v67[2] = v66;
            _OWORD *v67 = v65;
          }
        }
      }
    }
    CA::OGL::Context::unbind_surface(v3, *((void *)this + 24), 1);
    (*(void (**)(void *, _OWORD *, void))(*v3 + 520))(v3, v87, 0);
    goto LABEL_81;
  }
  uint64_t v4 = 0;
  *(unsigned char *)(v3[2] + 481) |= 1u;
  char v86 = *((unsigned char *)this + 244);
  char v5 = 1;
  while (1)
  {
    v105[0] = 0;
    v94[0] = 0uLL;
    uint64_t v6 = v3[2];
    if (v5)
    {
      *(unsigned char *)(v6 + 16) = 1;
      *(unsigned char *)(v3[2] + 480) = 8;
      double v7 = (uint32x2_t *)*((void *)this + 25);
      if (v7)
      {
        float v8 = CA::OGL::Context::bind_image((uint64_t)v3, 0, v7, (double *)*((unsigned int *)this + 60), 1u, 1, 0, 0, 0.0, v94, 0);
LABEL_12:
        float v10 = v8;
        goto LABEL_26;
      }
      unsigned int v11 = *((_DWORD *)this + 1);
      uint64_t v12 = *(_DWORD *)this <= (signed int)v11 ? v11 : *(unsigned int *)this;
      if ((*((unsigned char *)this + 244) & 3) != 0) {
        (*(void (**)(void *, void, uint64_t, void, void, float32x2_t *))(*v3 + 464))(v3, 0, v12, 0, 0, v105);
      }
      else {
        (*(void (**)(void *, void, uint64_t, void, void, float32x2_t *))(*v3 + 456))(v3, 0, v12, 0, 0, v105);
      }
    }
    else
    {
      *(unsigned char *)(v6 + 16) = 6;
      *(unsigned char *)(v3[2] + 480) = 12;
      CA::OGL::Context::bind_surface((uint64_t)v3, *((void *)this + 24), 0, 0, 0, 0.0);
      double v9 = (uint32x2_t *)*((void *)this + 25);
      if (v9)
      {
        float v8 = CA::OGL::Context::bind_image((uint64_t)v3, 1u, v9, (double *)*((unsigned int *)this + 60), 1u, 1, 0, 0, 0.0, v94, 0);
        goto LABEL_12;
      }
      unsigned int v13 = *((_DWORD *)this + 1);
      uint64_t v14 = *(_DWORD *)this <= (signed int)v13 ? v13 : *(unsigned int *)this;
      if ((*((unsigned char *)this + 244) & 3) != 0) {
        (*(void (**)(void *, uint64_t, uint64_t, void, void, float32x2_t *))(*v3 + 464))(v3, 1, v14, 0, 0, v105);
      }
      else {
        (*(void (**)(void *, uint64_t, uint64_t, void, void, float32x2_t *))(*v3 + 456))(v3, 1, v14, 0, 0, v105);
      }
    }
    float v10 = 0;
LABEL_26:
    uint64_t v15 = *(void *)(v3[31] + 8);
    *(void *)&long long v98 = v3;
    *((void *)&v98 + 1) = v15;
    memset(v99, 0, 40);
    BYTE1(v99[1]) = 1;
    CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)&v98);
    int8x16_t v95 = 0uLL;
    if ((*((unsigned char *)this + 244) & 8) != 0)
    {
      float v16 = v105[0].f32[0] + (float)((float)(v105[0].f32[1] - v105[0].f32[0]) * 0.5);
      *(unsigned char *)(v3[2] + v4 + 19) = 5;
      __int32 v17 = v105[0].i32[0];
      uint64_t v18 = v3[2];
      *(_DWORD *)(v18 + 368) = v105[0].i32[0];
      *(_DWORD *)(v18 + 372) = v17;
      *(float *)(v18 + 376) = v16;
      *(float *)(v18 + 380) = v16;
    }
LABEL_45:
    if (CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)&v98, (int32x2_t *)&v95))
    {
      uint64_t v19 = 0;
      while (1)
      {
        if (!*((unsigned char *)this + v19 + 184))
        {
          if (*((_DWORD *)v3 + 23)) {
            uint64_t v20 = 6;
          }
          else {
            uint64_t v20 = 4;
          }
          uint64_t v21 = v3[16];
          if ((unint64_t)(v21 + 4) > v3[17] || (unint64_t v22 = v3[14]) != 0 && v3[13] + v20 > v22)
          {
            *((_WORD *)v3 + 416) |= 0x20u;
            CA::OGL::Context::array_flush((uint64_t)v3);
            uint64_t v21 = 0;
            v3[12] = (char *)v3 + 834;
            *(_OWORD *)(v3 + 13) = xmmword_184997E70;
          }
          float32x2_t v23 = *(float32x2_t *)((char *)this + 8 * v19 + 40);
          float32x2_t v24 = vadd_f32(*(float32x2_t *)((char *)this + 8), v23);
          float32x2_t v25 = vadd_f32(*(float32x2_t *)((char *)this + 16), v23);
          float32x2_t v26 = vadd_f32(*(float32x2_t *)((char *)this + 24), v23);
          float32x2_t v27 = vadd_f32(*(float32x2_t *)((char *)this + 32), v23);
          uint64_t v28 = v3[15];
          int8x16_t v29 = (float32x2_t *)(v28 + 48 * v21);
          uint64_t v30 = v21 + 4;
          v3[16] = v21 + 4;
          *int8x16_t v29 = v24;
          v29[1] = (float32x2_t)0x3F80000000000000;
          v29[6] = v25;
          void v29[7] = (float32x2_t)0x3F80000000000000;
          v29[12] = v26;
          v29[13] = (float32x2_t)0x3F80000000000000;
          v29[18] = v27;
          v29[19] = (float32x2_t)0x3F80000000000000;
          if (v3[12])
          {
            CA::OGL::Context::array_indices((uint64_t)v3, v21);
            uint64_t v28 = v3[15];
            uint64_t v30 = v3[16];
          }
          uint64_t v31 = v28 + 48 * v30;
          *(void *)(v31 - 160) = 0x3C003C003C003C00;
          *(void *)(v31 - 112) = 0x3C003C003C003C00;
          *(void *)(v31 - 64) = 0x3C003C003C003C00;
          *(void *)(v31 - 16) = 0x3C003C003C003C00;
          float32x2_t v103 = 0;
          uint64_t v104 = 0;
          if (*((void *)this + 25))
          {
            CA::OGL::MaskCorners::corner_contents_texcoord(this, v19, v94[0].f32, (float *)&v103);
            if ((v5 & 1) == 0) {
              goto LABEL_43;
            }
          }
          else
          {
            CA::OGL::MaskCorners::corner_circle_texcoord((uint64_t)this, v19, (const float *)v105, (float *)&v103);
            if ((v5 & 1) == 0)
            {
LABEL_43:
              float32x2_t v92 = 0;
              float32x2_t v93 = 0;
              float32x2_t v90 = 0;
              float32x2_t v91 = 0;
              CA::OGL::MaskCorners::corner_quad((float32x2_t *)this, v19, &v93, &v92, &v91, &v90);
              uint64_t v35 = v3[15] + 48 * v3[16];
              *(float32x2_t *)(v35 - 176) = v93;
              *(float32x2_t *)(v35 - 128) = v92;
              *(float32x2_t *)(v35 - 80) = v91;
              *(float32x2_t *)(v35 - 32) = v90;
              float32x2_t v36 = v103;
              uint64_t v37 = v104;
              uint64_t v38 = v3[15] + 48 * v3[16];
              *(float32x2_t *)(v38 - 168) = v103;
              *(_DWORD *)(v38 - 120) = v37;
              *(_DWORD *)(v38 - 116) = v36.i32[1];
              *(void *)(v38 - 72) = v37;
              *(_DWORD *)(v38 - 24) = v36.i32[0];
              *(_DWORD *)(v38 - 20) = HIDWORD(v37);
              goto LABEL_44;
            }
          }
          float32x2_t v32 = v103;
          uint64_t v33 = v104;
          uint64_t v34 = v3[15] + 48 * v3[16];
          *(float32x2_t *)(v34 - 176) = v103;
          *(_DWORD *)(v34 - 128) = v33;
          *(_DWORD *)(v34 - 124) = v32.i32[1];
          *(void *)(v34 - 80) = v33;
          *(_DWORD *)(v34 - 32) = v32.i32[0];
          *(_DWORD *)(v34 - 28) = HIDWORD(v33);
        }
LABEL_44:
        if (++v19 == 4) {
          goto LABEL_45;
        }
      }
    }
    int8x16_t v39 = *(void (**)(void *, _OWORD *, uint64_t))(*v3 + 520);
    if ((v5 & 1) == 0) {
      break;
    }
    v39(v3, v10, 0);
    char v5 = 0;
    uint64_t v4 = 1;
    if ((v86 & 4) != 0) {
      goto LABEL_81;
    }
  }
  v39(v3, v10, 1);
  CA::OGL::Context::unbind_surface(v3, *((void *)this + 24), 0);
LABEL_81:
  *(unsigned char *)(v3[2] + 481) &= ~1u;
  uint64_t v68 = v3[2];
  *(unsigned char *)(v68 + 480) = *(unsigned char *)(v3[31] + 68);
  *(unsigned char *)(v68 + 16) = 0;
  if (byte_1EB2ACBE1)
  {
    uint64_t v100 = 0;
    long long v98 = 0u;
    memset(v99, 0, sizeof(v99));
    CA::OGL::copy_gstate((uint64_t)&v98, v3[31]);
    *((void *)&v99[0] + 1) = &CA::identity_transform;
    uint64_t v70 = 0;
    *(void *)&long long v98 = CA::OGL::Context::set_gstate((uint64_t)v3, (uint64_t)&v98);
    uint64_t v72 = (int *)((char *)this + 116);
    v73.i32[0] = 1073741822;
    int32x4_t v89 = v73;
    int32x4_t v74 = (int32x4_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    int8x16_t v88 = (int8x16_t)v74;
    do
    {
      if (!*((unsigned char *)this + v70 + 184))
      {
        uint64_t v75 = *((void *)this + 24);
        uint64_t v76 = 2155872384;
        if (v75)
        {
          int v77 = *(_DWORD *)(v75 + 68);
          if ((v77 & 0x4000) != 0) {
            unsigned int v78 = -2147450752;
          }
          else {
            unsigned int v78 = -2139094912;
          }
          if ((v77 & 0x800) != 0) {
            uint64_t v76 = 8388736;
          }
          else {
            uint64_t v76 = v78;
          }
        }
        int v79 = *(v72 - 1);
        if (v79 <= *v72) {
          int v80 = *v72;
        }
        else {
          int v80 = *(v72 - 1);
        }
        v74.i32[0] = v80;
        uint64_t v81 = *(void *)(v72 - 3);
        v82.i64[0] = (int)v81;
        v82.i64[1] = SHIDWORD(v81);
        int8x16_t v85 = (int8x16_t)vcvtq_f64_s64(v82);
        double v83 = (double)v79;
        int8x16_t v84 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v74, v89), 0), v88, v85);
        v85.i64[0] = 0x7FEFFFFFFFFFFFFFLL;
        if (v80 <= 1073741822) {
          *(double *)v85.i64 = (double)*v72;
        }
        else {
          double v83 = 1.79769313e308;
        }
        int8x16_t v95 = v84;
        double v96 = v83;
        uint64_t v97 = v85.i64[0];
        v94[0].i64[0] = (uint64_t)&v95;
        v94[0].i64[1] = *((void *)&v99[0] + 1);
        memset(&v94[1], 0, 32);
        CA::OGL::fill_color_rect((uint64_t)v3, (uint64_t)v94, (double *)v76, v71, 0.0, v85);
      }
      ++v70;
      v72 += 4;
    }
    while (v70 != 4);
    CA::OGL::Context::set_gstate((uint64_t)v3, *(void *)v3[31]);
  }
  uint64_t v69 = *((void *)this + 24);
  if (v69) {
    CA::OGL::Context::release_surface((uint64_t)v3, v69);
  }
}

uint64_t CA::OGL::MetalContext::needs_destination_group(CA::OGL::MetalContext *this)
{
  return 0;
}

uint64_t CA::OGL::MaskCorners::corner_circle_texcoord(uint64_t this, int a2, const float *a3, float *a4)
{
  int v4 = *(_DWORD *)a3;
  float v5 = *a3 + (float)((float)(a3[1] - *a3) * 0.5);
  *a4 = *a3;
  int v6 = *(_DWORD *)a3;
  a4[1] = *a3;
  float v7 = *a3 + (float)(*(float *)(this + 176) * (float)(v5 - *a3));
  a4[2] = v7;
  float v8 = *a3 + (float)(*(float *)(this + 180) * (float)(v5 - *a3));
  a4[3] = v8;
  if ((*(unsigned char *)(this + 244) & 8) != 0)
  {
    uint64_t v9 = this + 8 * a2;
    float v7 = *a3 + (float)((float)((float)(v5 - *a3) * *(float *)(v9 + 72)) * *(float *)(this + 176));
    a4[2] = v7;
    float v8 = *a3 + (float)((float)((float)(v5 - *a3) * *(float *)(v9 + 76)) * *(float *)(this + 180));
    a4[3] = v8;
  }
  if (a2)
  {
    *a4 = v7;
    *((_DWORD *)a4 + 2) = v4;
  }
  if (a2 >= 2)
  {
    a4[1] = v8;
    *((_DWORD *)a4 + 3) = v6;
  }
  return this;
}

float32x2_t CA::OGL::MaskCorners::corner_quad(float32x2_t *a1, int a2, float32x2_t *a3, float32x2_t *a4, float32x2_t *a5, float32x2_t *a6)
{
  __int32 v6 = a1->i32[1];
  if (a1[4].f32[1] > a1[1].f32[1]) {
    int v7 = a1->i32[1];
  }
  else {
    int v7 = -v6;
  }
  if (a2) {
    int v8 = a1->i32[0] + 3;
  }
  else {
    int v8 = 1;
  }
  int32x2_t v9 = (int32x2_t)a1[2 * a2 + 13];
  float32x2_t v10 = a1[a2 + 5];
  *a3 = a1[1];
  *a4 = a1[2];
  *a5 = a1[3];
  *a6 = a1[4];
  if (a1[30].i8[5])
  {
    a3->f32[1] = (float)v7 - a3->f32[1];
    a4->f32[1] = (float)v7 - a4->f32[1];
    a5->f32[1] = (float)v7 - a5->f32[1];
    a6->f32[1] = (float)v7 - a6->f32[1];
  }
  int v11 = v6 + 3;
  if (a2 <= 1) {
    int v11 = 1;
  }
  float32x2_t v12 = vadd_f32(v10, vcvt_f32_s32(vsub_s32((int32x2_t)__PAIR64__(v11, v8), v9)));
  *a3 = vadd_f32(*a3, v12);
  *a4 = vadd_f32(*a4, v12);
  *a5 = vadd_f32(*a5, v12);
  float32x2_t result = vadd_f32(*a6, v12);
  *a6 = result;
  return result;
}

double CA::OGL::Context::bind_circle(CA::OGL::Context *this, unsigned int a2, int a3, BOOL a4, BOOL a5, float *a6)
{
  uint64_t v6 = *((void *)this + 2);
  *(_OWORD *)(v6 + 16 * a2 + 96) = xmmword_184997ED0;
  *(unsigned char *)(v6 + a2 + 17) = 10;
  double result = 0.00781250557;
  *(void *)a6 = 0x3F800000BF800000;
  return result;
}

uint64_t CARenderServerGetDirtyFrameCount(mach_port_name_t a1)
{
  return CARenderServerGetDirtyFrameCountByIndex(a1, 0);
}

uint64_t get_bounds(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(CGContextDelegateGetInfo() + 48);

  return MEMORY[0x1F40D9E38](v5, a2, a3);
}

uint64_t ___ZN2CA12MachPortUtil17call_with_timeoutIPFijjjEJjEEEijjbPKcT_DpT0__block_invoke(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  mach_error_t v2 = (*(uint64_t (**)(void, void, void))(a1 + 32))(*(unsigned int *)(a1 + 48), *(unsigned int *)(a1 + 52), *(unsigned int *)(a1 + 56));
  if (v2)
  {
    mach_error_t v4 = v2;
    if (v2 != 268435460 || *(unsigned char *)(a1 + 60) == 0)
    {
      if (x_log_hook_p())
      {
        mach_error_string(v4);
        x_log_();
      }
      else
      {
        uint64_t v6 = x_log_category_utilities;
        if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
        {
          uint64_t v7 = *(void *)(a1 + 40);
          *(_DWORD *)long long buf = 136315650;
          uint64_t v9 = v7;
          __int16 v10 = 1024;
          mach_error_t v11 = v4;
          __int16 v12 = 2080;
          unsigned int v13 = mach_error_string(v4);
          _os_log_impl(&dword_184668000, v6, OS_LOG_TYPE_ERROR, "%s client message err=0x%x : %s", buf, 0x1Cu);
        }
      }
    }
  }
  return mach_port_deallocate(*MEMORY[0x1E4F14960], *(_DWORD *)(a1 + 48));
}

void CA::WindowServer::IOMFBServer::frame_info_callback(const void *a1, uint64_t a2, const __CFDictionary *a3, uint64_t *a4)
{
  uint64_t v408 = *MEMORY[0x1E4F143B8];
  ++CA::WindowServer::IOMFBServer::frame_info_callback(__IOMobileFramebuffer *,unsigned int,__CFDictionary const*,void *)::frame_info_count;
  if (!(*(uint64_t (**)(uint64_t *))(*a4 + 384))(a4)) {
    __assert_rtn("frame_info_callback", "windowserver-iomfb-server.cpp", 1036, "run_loop != nullptr");
  }
  int32x4_t v386 = 0;
  CA::WindowServer::IOMFBDisplay::collect_frame_info(&v386, a4[12], a2);
  int v8 = v386;
  if (!v386) {
    return;
  }
  if ((*(_WORD *)((unsigned char *)v386 + 197) & 0x100) != 0)
  {
LABEL_10:
    int32x4_t v386 = 0;
    goto LABEL_431;
  }
  unsigned int v9 = *((_DWORD *)v386 + 1);
  CFDictionaryRef Int64 = CA_CFDictionaryGetInt64(a3, @"Presentation_time");
  CFDictionaryRef v11 = CA_CFDictionaryGetInt64(a3, @"Requested_presentation");
  CFDictionaryRef v12 = CA_CFDictionaryGetInt64(a3, @"Last_Fence_or_Event_Time");
  unsigned int v13 = (unsigned char *)a4[12];
  if (v13[28192])
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    mach_get_times();
    CFDictionaryRef Int64 = (const __CFDictionary *)((char *)Int64 - (*(void *)&buf[8] - *(void *)buf));
    CFDictionaryRef v11 = (const __CFDictionary *)((char *)v11 - (*(void *)&buf[8] - *(void *)buf));
  }
  if ((*(_WORD *)((unsigned char *)v8 + 197) & 0x400) != 0)
  {
    kdebug_trace();
    CA::WindowServer::IOMFBDisplay::add_timing((CA::WindowServer::IOMFBDisplay *)a4[12], (unint64_t)Int64);
    CA::WindowServer::IOMFBServer::forward_frame_info_callback((CA::WindowServer::IOMFBServer *)a4, a3, v8, v23);
    goto LABEL_10;
  }
  CFTypeRef cf = a1;
  uint64_t v366 = (uint64_t)a4;
  double v14 = CATimeWithHostTime((unint64_t)Int64);
  double v15 = CATimeWithHostTime((unint64_t)v11);
  double v16 = (*(double (**)(unsigned char *))(*(void *)v13 + 744))(v13);
  unint64_t v17 = CAHostTimeWithTime(v16);
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  mach_get_times();
  uint64_t v18 = *(void *)&buf[8] - *(void *)buf;
  unint64_t v19 = *((void *)v8 + 4) - (*(void *)&buf[8] - *(void *)buf);
  kdebug_trace();
  uint64_t v357 = v18;
  uint64_t v367 = (uint64_t)Int64 + v18;
  unint64_t v20 = *((void *)v8 + 4);
  __int16 v21 = *(_WORD *)((char *)v8 + 197);
  if ((v21 & 0x80) != 0) {
    uint64_t v22 = 2;
  }
  else {
    uint64_t v22 = *((unsigned __int8 *)v8 + 196) - 1;
  }
  unint64_t v24 = v367 - v20;
  if ((v21 & 0x40) != 0) {
    unint64_t v25 = v17;
  }
  else {
    unint64_t v25 = 0;
  }
  unint64_t v26 = v25 + v22 * v17;
  uint64_t v365 = a2;
  unsigned int v360 = v9;
  if (v20 >= *((void *)v8 + 5))
  {
    unint64_t v30 = 0;
    BOOL v29 = 0;
  }
  else if (*((void *)v8 + 7) == -1)
  {
    BOOL v29 = 0;
    unint64_t v30 = v17;
  }
  else
  {
    unint64_t v27 = v367 - v20;
    uint64_t v28 = *(_WORD **)(v366 + 96);
    if ((v28[328] & 0x1C00) != 0)
    {
      BOOL v29 = 0;
      unint64_t v30 = v17;
    }
    else
    {
      double v31 = (*(double (**)(_WORD *))(*(void *)v28 + 760))(v28);
      unint64_t v32 = CAHostTimeWithTime(v31);
      if (*((void *)v8 + 7) <= v19) {
        unint64_t v33 = v19;
      }
      else {
        unint64_t v33 = *((void *)v8 + 7);
      }
      __int16 v21 = *(_WORD *)((char *)v8 + 197);
      if ((v21 & 0x40) != 0) {
        unint64_t v34 = v17;
      }
      else {
        unint64_t v34 = 0;
      }
      BOOL v29 = v33 + v32 + v34 < *((void *)v8 + 5) - v357;
      unint64_t v30 = v33 - v19;
    }
    unint64_t v24 = v27;
  }
  unint64_t v35 = v26 + v30;
  unint64_t v363 = v17;
  unint64_t v358 = v24;
  int v36 = v24 > (v17 >> 1) + (v17 >> 6) + v35 || v29;
  int v37 = v21 & 0x20;
  if (v36 == 1)
  {
    kdebug_trace();
    if (v37) {
      kdebug_trace();
    }
  }
  unsigned int v354 = v37;
  unint64_t v355 = v35;
  uint64_t v38 = v366;
  if (v12)
  {
    int8x16_t v39 = *(unsigned char **)(v366 + 96);
    if (!v39[28192])
    {
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      mach_get_times();
      CFDictionaryRef v12 = (const __CFDictionary *)((char *)v12 + *(void *)&buf[8] - *(void *)buf);
    }
    unint64_t v40 = *((void *)v8 + 5);
    BOOL v41 = (unint64_t)v12 >= v40;
    uint64_t v42 = (char *)v12 - v40;
    if (v41) {
      unint64_t v43 = (unint64_t)v42;
    }
    else {
      unint64_t v43 = 0;
    }
    double v44 = CATimeWithHostTime(v43);
    if ((*(_WORD *)((unsigned char *)v8 + 197) & 0x800) != 0) {
      *(unsigned char *)(v366 + 1012) = (v44 < (*(double (**)(unsigned char *))(*(void *)v39 + 744))(v39) * 0.4375) | (2 * *(unsigned char *)(v366 + 1012));
    }
    if (v44 > 5.0)
    {
      if (x_log_hook_p())
      {
        unint64_t v348 = *(void *)&v44;
        x_log_();
      }
      else
      {
        float v45 = x_log_category_windowserver;
        if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v365;
          *(_WORD *)&uint8_t buf[8] = 2048;
          *(double *)&buf[10] = v44;
          _os_log_impl(&dword_184668000, v45, OS_LOG_TYPE_ERROR, "Long render detected. Swap %u took %.2gs", buf, 0x12u);
        }
      }
    }
  }
  if ((*(_WORD *)((unsigned char *)v8 + 197) & 0x1000) != 0)
  {
    double v46 = (*(double (**)(void))(**(void **)(v366 + 96) + 760))(*(void *)(v366 + 96));
    unint64_t v47 = CAHostTimeWithTime(v46);
    if ((*(_DWORD *)(*(void *)(v366 + 96) + 624) & 0x10) != 0) {
      unint64_t v48 = v47;
    }
    else {
      unint64_t v48 = 0;
    }
    double v49 = *(double *)(v366 + 944);
    if (Int64 >= (const __CFDictionary *)((char *)v11 + (v47 >> 2) + v48))
    {
      double v50 = v49 * 1.33333333;
      if (v50 > 10.0) {
        double v50 = 10.0;
      }
    }
    else
    {
      double v50 = v49 * 0.5;
      if (v50 < 0.25) {
        double v50 = 0.25;
      }
    }
    *(double *)(v366 + 944) = v50;
  }
  if ((atomic_exchange((atomic_uchar *volatile)(v366 + 464), 0) & 1) == 0
    && (atomic_exchange((atomic_uchar *volatile)(v366 + 465), 0) & 1) == 0
    && (atomic_exchange((atomic_uchar *volatile)(v366 + 466), 0) & 1) == 0)
  {
    unsigned int v51 = *(unsigned __int8 *)(v366 + 1014);
    if (BYTE2(qword_1EB2ACC90) == ((v51 >> 4) & 1)) {
      goto LABEL_65;
    }
    *(unsigned char *)(v366 + 1014) = v51 & 0xEF | (16 * BYTE2(qword_1EB2ACC90));
  }
  pthread_mutex_lock((pthread_mutex_t *)(v366 + 544));
  CA::WindowServer::IOMFBServer::set_throttle_reason(v366, 1u, *(unsigned __int8 *)(v366 + 518));
  CA::WindowServer::IOMFBServer::set_throttle_reason(v366, 0, *(unsigned __int8 *)(v366 + 517));
  CA::WindowServer::IOMFBServer::set_throttle_reason(v366, 2u, *(unsigned __int8 *)(v366 + 523));
  CA::WindowServer::IOMFBServer::update_throttle(v366);
  pthread_mutex_unlock((pthread_mutex_t *)(v366 + 544));
LABEL_65:
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  unsigned int v52 = *(float *)&dword_1EB2ACB58;
  if (*(_DWORD *)(v366 + 936) != *(float *)&dword_1EB2ACB58)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v366 + 544));
    *(_DWORD *)(v366 + 936) = v52;
    CA::WindowServer::IOMFBServer::refresh_timer_interval((CA::WindowServer::IOMFBServer *)v366);
    CA::WindowServer::IOMFBDisplay::minimum_frame_duration_changed(*(os_unfair_lock_s **)(v366 + 96));
    pthread_mutex_unlock((pthread_mutex_t *)(v366 + 544));
  }
  CA::WindowServer::IOMFBDisplay::add_timing(*(CA::WindowServer::IOMFBDisplay **)(v366 + 96), (unint64_t)Int64);
  uint64_t v53 = *(void *)(v366 + 96);
  double v54 = 0.003;
  if ((*(_DWORD *)(v53 + 624) & 0x10) != 0)
  {
    uint64_t v55 = v363;
    if ((*(void *)(v53 + 640) & 0x8000000000000000) != 0) {
      double v54 = (*(double (**)(uint64_t, double))(*(void *)v53 + 760))(v53, 0.003) + 0.003;
    }
  }
  else
  {
    uint64_t v55 = v363;
  }
  if (v14 < v15 - v54)
  {
    int v8 = v386;
    goto LABEL_430;
  }
  uint64_t v56 = *(void *)(v366 + 96);
  unint64_t v356 = *(void *)(v56 + 27144);
  *(void *)(v56 + 27144) = v367;
  if (CA::WindowServer::IOMFBServer::frame_info_callback(__IOMobileFramebuffer *,unsigned int,__CFDictionary const*,void *)::previous_swap_id) {
    BOOL v57 = CA::WindowServer::IOMFBServer::frame_info_callback(__IOMobileFramebuffer *,unsigned int,__CFDictionary const*,void *)::previous_swap_id == v365;
  }
  else {
    BOOL v57 = 1;
  }
  if (v57) {
    uint64_t v58 = 0;
  }
  else {
    uint64_t v58 = (char *)Int64
  }
        - CA::WindowServer::IOMFBServer::frame_info_callback(__IOMobileFramebuffer *,unsigned int,__CFDictionary const*,void *)::mt_previous_pres;
  CA::WindowServer::IOMFBServer::frame_info_callback(__IOMobileFramebuffer *,unsigned int,__CFDictionary const*,void *)::previous_swap_id = v365;
  CA::WindowServer::IOMFBServer::frame_info_callback(__IOMobileFramebuffer *,unsigned int,__CFDictionary const*,void *)::mt_previous_pres = (uint64_t)Int64;
  qword_1E8F86530 += (uint64_t)v58;
  int64_t v59 = Int64 - v11;
  if (Int64 - v11 < 0) {
    int64_t v59 = v11 - Int64;
  }
  *(void *)&xmmword_1E8F86560 = xmmword_1E8F86560 + v59;
  if (CADeviceSupportsBandwidthStatistics::once[0] != -1) {
    dispatch_once(CADeviceSupportsBandwidthStatistics::once, &__block_literal_global_328);
  }
  CFDictionaryRef v353 = Int64;
  if (CADeviceSupportsBandwidthStatistics::bw_stats)
  {
    CFDictionaryRef v60 = CA_CFDictionaryGetInt64(a3, @"GP0_Max_BW");
    CFDictionaryRef v61 = CA_CFDictionaryGetInt64(a3, @"GP1_Max_BW");
    CFDictionaryRef v62 = CA_CFDictionaryGetInt64(a3, @"GP0_Obs_BW");
    CFDictionaryRef v63 = CA_CFDictionaryGetInt64(a3, @"GP1_Obs_BW");
    atomic_store(COERCE_UNSIGNED_INT64((double)(unint64_t)v62), (unint64_t *)(*(void *)(v366 + 96) + 27784));
    atomic_store(COERCE_UNSIGNED_INT64((double)(unint64_t)v60), (unint64_t *)(*(void *)(v366 + 96) + 27792));
    atomic_store(COERCE_UNSIGNED_INT64((double)(unint64_t)v63), (unint64_t *)(*(void *)(v366 + 96) + 27800));
    atomic_store(COERCE_UNSIGNED_INT64((double)(unint64_t)v61), (unint64_t *)(*(void *)(v366 + 96) + 27808));
  }
  if (BYTE12(xmmword_1EB2ACBF0))
  {
    if (x_log_hook_p())
    {
      unint64_t v348 = *(void *)&v15;
      x_log_();
    }
    else
    {
      BOOL v346 = x_log_category_windowserver;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109888;
        *(_DWORD *)&uint8_t buf[4] = v365;
        *(_WORD *)&uint8_t buf[8] = 2048;
        *(double *)&buf[10] = v15;
        *(_WORD *)&buf[18] = 2048;
        *(double *)&buf[20] = v14;
        *(_WORD *)&buf[28] = 2048;
        *(double *)&buf[30] = v14 - v15;
        _os_log_impl(&dword_184668000, v346, OS_LOG_TYPE_DEFAULT, "CoreAnimation: swap %u : requested %.5f, presented at %.5f, diff %.5f\n", buf, 0x26u);
      }
    }
  }
  float v64 = v386;
  double v65 = *((double *)v386 + 3);
  unint64_t v361 = v55;
  if (v65 != 0.0) {
    unint64_t v361 = CAHostTimeWithTime(v65);
  }
  double v66 = *((double *)v64 + 8);
  if (v66 == 0.0)
  {
    CA::Render::invoke_presentation_handlers((void *)v8 + 12, v365, v367, v55, *((unsigned char *)v64 + 196), v14);
    unint64_t v349 = 0;
    if (v36)
    {
LABEL_95:
      kdebug_trace();
      int v377 = 1;
      goto LABEL_98;
    }
  }
  else
  {
    unint64_t v67 = CAHostTimeWithTime(v66);
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    mach_get_times();
    unint64_t v349 = *(void *)&buf[8] - *(void *)buf + v67;
    uint64_t v68 = v55;
    if (*((void *)v64 + 4) > (unint64_t)((double)v349 + (double)v361 * 2.1)) {
      char v69 = 1;
    }
    else {
      char v69 = v36;
    }
    CA::Render::invoke_presentation_handlers((void *)v8 + 12, v365, v367, v68, *((unsigned char *)v64 + 196), v14);
    if (v69) {
      goto LABEL_95;
    }
  }
  int v377 = 0;
LABEL_98:
  uint64_t v70 = (void *)*((void *)v8 + 12);
  long long v374 = (void *)((char *)v8 + 104);
  if (v70 == (void *)((char *)v8 + 104))
  {
    uint64_t v71 = 0;
  }
  else
  {
    CFDictionaryRef v350 = a3;
    uint64_t v71 = 0;
    uint64_t v383 = (float *)(*(void *)(v366 + 96) + 27152);
    unint64_t v72 = -1;
    do
    {
      int32x4_t v73 = v71;
      int32x4_t v74 = (_DWORD *)v70[4];
      unsigned int v75 = v74[4];
      unsigned int v368 = *((_DWORD *)v70 + 11);
      unint64_t v76 = atomic_load(v74 + 57);
      if (!v76)
      {
        if (v74[63]) {
          unsigned int v77 = 0;
        }
        else {
          unsigned int v77 = getpid();
        }
        unsigned int v78 = 0;
        atomic_compare_exchange_strong(v74 + 57, &v78, v77);
        if (v78) {
          unint64_t v76 = v78;
        }
        else {
          unint64_t v76 = v77;
        }
      }
      int v79 = CA::Render::Context::process_path((CA::Render::Context *)v70[4]);
      uint64_t v80 = *(void *)(v70[4] + 520);
      CFStringRef v81 = (const __CFString *)v70[6];
      *(_DWORD *)long long buf = v75;
      int64x2_t v82 = std::__hash_table<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::PreviousMCTRecord>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::PreviousMCTRecord>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::PreviousMCTRecord>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::PreviousMCTRecord>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v383, v75, buf);
      unint64_t v83 = v82[4];
      uint64_t v84 = *(unsigned int *)(v70[4] + 44);
      if (v84 != *((_DWORD *)v82 + 6))
      {
        *(_DWORD *)long long buf = v75;
        int8x16_t v85 = std::__hash_table<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::PreviousMCTRecord>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::PreviousMCTRecord>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::PreviousMCTRecord>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::PreviousMCTRecord>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v383, v75, buf);
        v85[3] = v84;
        v85[4] = v367;
      }
      if ((unint64_t)v81 >= v72) {
        uint64_t v71 = v73;
      }
      else {
        uint64_t v71 = v79;
      }
      if ((unint64_t)v81 < v72) {
        unint64_t v72 = (unint64_t)v81;
      }
      int v86 = v377;
      if (BYTE4(qword_1EB2ACC90)) {
        int v86 = 1;
      }
      if (v86 == 1)
      {
        kdebug_trace();
        unsigned int v89 = v79 + 28;
        unint64_t v90 = CAHostTimeWithTime(*(double *)(v70[4] + 624));
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        mach_get_times();
        CA::WindowServer::IOMFBServer::signpost_context((CA::WindowServer::IOMFBServer *)v368, v360, v75, v89, (const char *)v76, v80, v81, v83, *(void *)&buf[8] - *(void *)buf + v90, v348);
      }
      uint64_t v87 = (void *)v70[1];
      if (v87)
      {
        do
        {
          int8x16_t v88 = v87;
          uint64_t v87 = (void *)*v87;
        }
        while (v87);
      }
      else
      {
        do
        {
          int8x16_t v88 = (void *)v70[2];
          BOOL v57 = *v88 == (void)v70;
          uint64_t v70 = v88;
        }
        while (!v57);
      }
      uint64_t v70 = v88;
    }
    while (v88 != v374);
    float v64 = v386;
    a3 = v350;
    uint64_t v38 = v366;
  }
  double v91 = *((double *)v64 + 2);
  if (v91 == 0.0) {
    uint64_t v92 = 0;
  }
  else {
    uint64_t v92 = CAHostTimeWithTime(v91) + v357;
  }
  int v93 = *(_DWORD *)(*(void *)(v38 + 96) + 24);
  int v94 = *((_DWORD *)v64 + 48);
  if (v377)
  {
    if (CA::WindowServer::IOMFBServer::server_stall_log_handle(void)::once_token != -1) {
      dispatch_once(&CA::WindowServer::IOMFBServer::server_stall_log_handle(void)::once_token, &__block_literal_global_5_17260);
    }
    int8x16_t v95 = &CA::WindowServer::IOMFBServer::server_stall_log_handle(void)::handle;
  }
  else
  {
    if (CA::WindowServer::IOMFBServer::server_log_handle(void)::once_token != -1) {
      dispatch_once(&CA::WindowServer::IOMFBServer::server_log_handle(void)::once_token, &__block_literal_global_17255);
    }
    int8x16_t v95 = &CA::WindowServer::IOMFBServer::server_log_handle(void)::in_memory_handle;
  }
  int v96 = *(_DWORD *)v64;
  if (v92)
  {
    if (!v96 || !os_signpost_enabled((os_log_t)*v95)) {
      goto LABEL_144;
    }
    uint64_t v97 = *((void *)v64 + 4);
    int v98 = *((_DWORD *)v64 + 1);
    int v99 = *((unsigned __int8 *)v64 + 196);
    *(_DWORD *)long long buf = 134351616;
    *(void *)&uint8_t buf[4] = v97;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = v98;
    *(_WORD *)&buf[18] = 2050;
    *(void *)&buf[20] = v361;
    *(_WORD *)&buf[28] = 1026;
    *(_DWORD *)&buf[30] = v99;
    *(_WORD *)&unsigned char buf[34] = 2050;
    *(void *)&buf[36] = v367;
    *(_WORD *)&buf[44] = 2050;
    *(void *)&buf[46] = v356;
    *(_WORD *)&buf[54] = 1026;
    *(_DWORD *)&buf[56] = v354 >> 5;
    *(_WORD *)&buf[60] = 1026;
    *(_DWORD *)&buf[62] = v93;
    *(_WORD *)&buf[66] = 1026;
    *(_DWORD *)&buf[68] = v94;
    *(_WORD *)&unsigned char buf[72] = 2050;
    *(void *)&buf[74] = v349;
    *(_WORD *)&buf[82] = 2050;
    *(void *)&buf[84] = v92;
  }
  else
  {
    if (!v96 || !os_signpost_enabled((os_log_t)*v95)) {
      goto LABEL_144;
    }
    uint64_t v100 = *((void *)v64 + 4);
    int v101 = *((_DWORD *)v64 + 1);
    int v102 = *((unsigned __int8 *)v64 + 196);
    *(_DWORD *)long long buf = 134351360;
    *(void *)&uint8_t buf[4] = v100;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = v101;
    *(_WORD *)&buf[18] = 2050;
    *(void *)&buf[20] = v361;
    *(_WORD *)&buf[28] = 1026;
    *(_DWORD *)&buf[30] = v102;
    *(_WORD *)&unsigned char buf[34] = 2050;
    *(void *)&buf[36] = v367;
    *(_WORD *)&buf[44] = 2050;
    *(void *)&buf[46] = v356;
    *(_WORD *)&buf[54] = 1026;
    *(_DWORD *)&buf[56] = v354 >> 5;
    *(_WORD *)&buf[60] = 1026;
    *(_DWORD *)&buf[62] = v93;
    *(_WORD *)&buf[66] = 1026;
    *(_DWORD *)&buf[68] = v94;
    *(_WORD *)&unsigned char buf[72] = 2050;
    *(void *)&buf[74] = v349;
  }
  _os_signpost_emit_unreliably_with_name_impl();
LABEL_144:
  float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
  uint64_t v104 = *(void *)(v366 + 96);
  uint64_t v105 = (int *)(v104 + 27096);
  unint64_t v106 = v363;
  if (!*(unsigned char *)(v104 + 28169)) {
    goto LABEL_173;
  }
  memset(buf, 0, 96);
  os_unfair_lock_lock((os_unfair_lock_t)(v104 + 392));
  CA::WindowServer::Display::ModeSet::ModeSet((CA::WindowServer::Display::ModeSet *)buf, (const CA::WindowServer::Display::ModeSet *)(v104 + 400));
  os_unfair_lock_unlock((os_unfair_lock_t)(v104 + 392));
  uint64_t v107 = *(unint64_t **)buf;
  if (*(void *)buf == *(void *)&buf[8]) {
    goto LABEL_171;
  }
  for (uint64_t i = (unint64_t *)(*(void *)buf + 8); i != *(unint64_t **)&buf[8]; ++i)
  {
    unint64_t v109 = *i;
    if (((*v107 >> 54) & 1) == ((*i >> 54) & 1))
    {
      if (((*v107 >> 14) & 0x3FFF) * (*v107 & 0x3FFF) >= ((v109 >> 14) & 0x3FFF)
                                                                      * (v109 & 0x3FFF))
        continue;
LABEL_152:
      uint64_t v107 = i;
      continue;
    }
    if ((v109 & 0x40000000000000) == 0) {
      goto LABEL_152;
    }
  }
  unint64_t v110 = *v107;
  memset(v387, 0, 44);
  (*(void (**)(_OWORD *__return_ptr, uint64_t))(*(void *)v104 + 1368))(v387, v104);
  if (CA::WindowServer::Display::get_display_perf_log(void)::once_token[0] != -1) {
    dispatch_once(CA::WindowServer::Display::get_display_perf_log(void)::once_token, &__block_literal_global_71);
  }
  os_signpost_id_t v111 = *(unsigned int *)(v104 + 24);
  if (v111)
  {
    float v112 = CA::WindowServer::Display::get_display_perf_log(void)::log;
    if (os_signpost_enabled((os_log_t)CA::WindowServer::Display::get_display_perf_log(void)::log))
    {
      if (*(unsigned char *)(v104 + 28138)) {
        BOOL v113 = 0;
      }
      else {
        BOOL v113 = (*(_WORD *)(v104 + 656) & 0x1C00) != 4096;
      }
      if (LODWORD(v387[0]) > 3) {
        int8x16_t v114 = "Unspecified";
      }
      else {
        int8x16_t v114 = off_1E5280478[LODWORD(v387[0])];
      }
      int v115 = v110 & 0x3FFF;
      unsigned int v116 = (*(unsigned __int16 *)(v104 + 656) >> 13) - 1;
      CFDictionaryRef v351 = a3;
      BOOL v384 = v71;
      if (v116 > 4) {
        int8x16_t v117 = "Unspecified";
      }
      else {
        int8x16_t v117 = off_1E5280498[v116];
      }
      int v118 = *(unsigned __int8 *)(v104 + 28168);
      int v120 = *v105;
      int v119 = *(_DWORD *)(v104 + 27100);
      unsigned int v121 = (v110 >> 14) & 0x3FFF;
      double v122 = (double)((v110 >> 29) & 0x1FFFFFF) * 0.0000152587891;
      int v123 = BYTE4(v387[1]);
      CFArrayRef Count = *(const __CFArray **)(v104 + 27120);
      if (Count)
      {
        BOOL v125 = v113;
        uint64_t v126 = v114;
        double v375 = v112;
        long long v127 = v117;
        int v128 = v115;
        int v369 = v119;
        int v362 = v118;
        CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
        int v118 = v362;
        int v119 = v369;
        int v115 = v128;
        int8x16_t v117 = v127;
        float v112 = v375;
        int8x16_t v114 = v126;
        BOOL v113 = v125;
      }
      *(_DWORD *)int64x2_t v388 = 67243010;
      *(_DWORD *)&v388[4] = v111;
      LOWORD(v389) = 1026;
      *(_DWORD *)((char *)&v389 + 2) = v113;
      HIWORD(v389) = 1026;
      *(_DWORD *)int8x16_t v390 = v118;
      *(_WORD *)&v390[4] = 1026;
      *(_DWORD *)&v390[6] = v120;
      __int16 v391 = 1026;
      int v392 = v119;
      __int16 v393 = 1026;
      int v394 = v115;
      __int16 v395 = 1026;
      unsigned int v396 = v121;
      __int16 v397 = 2050;
      double v398 = v122;
      __int16 v399 = 2082;
      unsigned int v400 = v114;
      __int16 v401 = 1026;
      int v402 = v123;
      __int16 v403 = 2082;
      BOOL v404 = v117;
      __int16 v405 = 2050;
      CFArrayRef v406 = Count;
      _os_signpost_emit_with_name_impl(&dword_184668000, v112, OS_SIGNPOST_INTERVAL_END, v111, "HotPlug", "displayId=%{public, name=displayId}u isInternalPanel=%{public, BOOL, name=isInternalPanel}d state=%{public, BOOL, name=state}d vendorId=%{public, name=vendorId}u modelId=%{public, name=modelId}u bestWidth=%{public, name=bestWidth}d bestHeight=%{public, name=bestHeight}d bestRefreshRate=%{public, name=bestRefreshRate}.3f dolbyVision=%{public, name=dolbyVision}s legacyHDMI=%{public, BOOL, name=legacyHDMI}d preferredHdrType=%{public, name=preferredHdrType}s modeCount=%{public, name=modeCount}lu", v388, 0x5Au);
      a3 = v351;
      float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
      uint64_t v71 = v384;
      unint64_t v106 = v363;
    }
  }
  *((unsigned char *)v105 + 1073) = 0;
LABEL_171:
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&buf[48]);
  std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(*(void **)&buf[32]);
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
LABEL_173:
  unint64_t v129 = 0;
  double v130 = (double)(v367 - v356) / (double)v106;
  if (v130 < 0.95 || v130 > 1.05 || ((v377 ^ 1) & 1) != 0) {
    goto LABEL_409;
  }
  unint64_t v131 = v358 - v355;
  if (v358 == v355)
  {
    unint64_t v129 = v131 <= v106 ? v106 : v358 - v355;
    int v132 = 16;
  }
  else
  {
    unint64_t v129 = v131 <= v106 ? v106 : v358 - v355;
    int v132 = v356 >= *((void *)v64 + 4) ? 16 : 48;
  }
  unsigned int v133 = *(unsigned __int16 *)((char *)v64 + 197);
  if (os_variant_uses_ephemeral_storage()) {
    goto LABEL_409;
  }
  uint64_t v134 = mach_absolute_time();
  *(double *)&uint64_t v135 = CATimeWithHostTime(v134);
  if (*(double *)&CATailspinLastDefaultCheckTimestamp != 0.0
    && *(double *)&v135 - *(double *)&CATailspinLastDefaultCheckTimestamp <= 3600.0)
  {
    if (CATailspinCanGenerate) {
      goto LABEL_191;
    }
    goto LABEL_409;
  }
  BOOL v347 = should_emit_tailspins();
  CATailspinCanGenerate = v347;
  CATailspinLastDefaultCheckTimestamp = v135;
  if (!v347) {
    goto LABEL_409;
  }
LABEL_191:
  unsigned int v136 = v132 & 0xFFFFFFBF | (((v133 >> 5) & 1) << 6);
  BOOL v137 = *(double *)&CATailspinMinimumTimestamp == 0.0;
  if (*(double *)&v135 >= *(double *)&CATailspinMinimumTimestamp) {
    BOOL v137 = 1;
  }
  if (v136 <= 0x1F && v137 && *(double *)&v135 - *(double *)&CATailspinLastRequestTimestamp >= 1800.0)
  {
    char v364 = v136;
    CFDictionaryRef v352 = a3;
    {
      operator new();
    }
    uint64_t v138 = CATailspinGlitchHistory(void)::a;
    unint64_t v139 = CAHostTimeWithTime(1.0);
    unint64_t v140 = *(void *)(v138 + 32);
    uint64_t v141 = *(void *)(v138 + 8);
    uint64_t v142 = *(void *)(v138 + 16);
    int v143 = (uint64_t *)(v141 + 8 * (v140 >> 8));
    if (v142 == v141)
    {
      uint64_t v145 = 0;
      uint64_t v147 = 0;
      uint64_t v144 = *(void *)(v138 + 40);
      double v376 = (void *)(v138 + 40);
      int v146 = (char *)(v141 + 8 * ((v144 + v140) >> 8));
    }
    else
    {
      uint64_t v144 = *(void *)(v138 + 40);
      double v376 = (void *)(v138 + 40);
      uint64_t v145 = *v143 + 16 * v140;
      int v146 = (char *)(v141 + 8 * ((v144 + v140) >> 8));
      uint64_t v147 = *(void *)v146 + 16 * (v144 + v140);
    }
    if (v147 == v145
      || (uint64_t v148 = ((v147 - *(void *)v146) >> 4) + 32 * (v146 - (char *)v143),
          uint64_t v149 = v145 - *v143,
          unint64_t v150 = v148 - (v149 >> 4),
          v148 == v149 >> 4))
    {
      float32x2_t v152 = (void *)(v141 + 8 * (v140 >> 8));
    }
    else
    {
      unint64_t v151 = v367 - v139;
      float32x2_t v152 = (void *)(v141 + 8 * (v140 >> 8));
      do
      {
        unint64_t v153 = v150 >> 1;
        if (v150 == 1)
        {
          int v154 = v152;
          float32x2_t v155 = (unint64_t *)v145;
        }
        else
        {
          uint64_t v156 = v153 + ((v145 - *v152) >> 4);
          if (v156 < 1)
          {
            unint64_t v157 = 255 - v156;
            LOBYTE(v156) = ~(-1 - v156);
            int v154 = &v152[-(v157 >> 8)];
          }
          else
          {
            int v154 = &v152[(unint64_t)v156 >> 8];
          }
          float32x2_t v155 = (unint64_t *)(*v154 + 16 * v156);
        }
        if (*v155 >= v151) {
          unint64_t v158 = 1;
        }
        else {
          unint64_t v158 = 255;
        }
        if (*v155 != v151 && v158 >= 0x80)
        {
          uint64_t v145 = (uint64_t)(v155 + 2);
          if ((unint64_t *)((char *)v155 - *v154 + 16) == (unint64_t *)4096)
          {
            uint64_t v159 = v154[1];
            ++v154;
            uint64_t v145 = v159;
          }
          unint64_t v153 = v150 + ~v153;
          float32x2_t v152 = v154;
        }
        unint64_t v150 = v153;
      }
      while (v153);
    }
    if (v142 == v141) {
      uint64_t v160 = 0;
    }
    else {
      uint64_t v160 = *v143 + 16 * v140;
    }
    if (v145 == v160) {
      uint64_t v161 = 0;
    }
    else {
      uint64_t v161 = ((v145 - *v152) >> 4) + 32 * ((char *)v152 - (char *)v143) - ((v160 - *v143) >> 4);
    }
    if (v142 == v141) {
      uint64_t v162 = 0;
    }
    else {
      uint64_t v162 = *v143 + 16 * v140;
    }
    int32x4_t v385 = v71;
    if (v162 == v160) {
      unint64_t v163 = 0;
    }
    else {
      unint64_t v163 = ((v160 - *v143) >> 4) - ((v162 - *v143) >> 4);
    }
    uint64_t v378 = v162;
    int v164 = std::__deque_iterator<std::pair<unsigned long long,unsigned long long>,std::pair<unsigned long long,unsigned long long>*,std::pair<unsigned long long,unsigned long long>&,std::pair<unsigned long long,unsigned long long>**,long,256l>::operator+[abi:nn180100]((void *)(v141 + 8 * (v140 >> 8)), v162, v163);
    if (v161 < 1)
    {
      float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
    }
    else
    {
      uint64_t v166 = v164;
      uint64_t v370 = v165;
      uint64_t v167 = std::__deque_iterator<std::pair<unsigned long long,unsigned long long>,std::pair<unsigned long long,unsigned long long>*,std::pair<unsigned long long,unsigned long long>&,std::pair<unsigned long long,unsigned long long>**,long,256l>::operator+[abi:nn180100](v164, v165, v161);
      if (v163 <= (unint64_t)(v144 - v161) >> 1)
      {
        if (v143 == v166)
        {
          memset(buf, 0, 24);
          std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::pair<unsigned long long,unsigned long long> *,std::__deque_iterator<std::pair<unsigned long long,unsigned long long>,std::pair<unsigned long long,unsigned long long> *,std::pair<unsigned long long,unsigned long long>&,std::pair<unsigned long long,unsigned long long> **,long,256l>,0>(buf, v378, v370, v167, (uint64_t)v168);
          float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
        }
        else
        {
          uint64_t v172 = *v166;
          uint64_t v171 = v166 - 1;
          memset(buf, 0, 24);
          std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::pair<unsigned long long,unsigned long long> *,std::__deque_iterator<std::pair<unsigned long long,unsigned long long>,std::pair<unsigned long long,unsigned long long> *,std::pair<unsigned long long,unsigned long long>&,std::pair<unsigned long long,unsigned long long> **,long,256l>,0>(buf, v172, v370, v167, (uint64_t)v168);
          uint64_t v173 = *(uint64_t **)&buf[8];
          uint64_t v174 = *(void *)&buf[16];
          if (v171 == v143)
          {
            float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
          }
          else
          {
            float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
            do
            {
              uint64_t v175 = *v171--;
              memset(buf, 0, 24);
              std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::pair<unsigned long long,unsigned long long> *,std::__deque_iterator<std::pair<unsigned long long,unsigned long long>,std::pair<unsigned long long,unsigned long long> *,std::pair<unsigned long long,unsigned long long>&,std::pair<unsigned long long,unsigned long long> **,long,256l>,0>(buf, v175, v175 + 4096, v173, v174);
              uint64_t v173 = *(uint64_t **)&buf[8];
              uint64_t v174 = *(void *)&buf[16];
            }
            while (v171 != v143);
          }
          uint64_t v185 = *v143 + 4096;
          memset(buf, 0, 24);
          std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::pair<unsigned long long,unsigned long long> *,std::__deque_iterator<std::pair<unsigned long long,unsigned long long>,std::pair<unsigned long long,unsigned long long> *,std::pair<unsigned long long,unsigned long long>&,std::pair<unsigned long long,unsigned long long> **,long,256l>,0>(buf, v378, v185, v173, v174);
        }
        *(void *)(v138 + 40) -= v161;
        while (1)
        {
          unint64_t v140 = *(void *)(v138 + 32) + v161;
          *(void *)(v138 + 32) = v140;
          if (v140 < 0x200) {
            break;
          }
          operator delete(**(void ***)(v138 + 8));
          *(void *)(v138 + 8) += 8;
          uint64_t v161 = -256;
        }
        uint64_t v144 = *(void *)(v138 + 40);
      }
      else
      {
        uint64_t v169 = (uint64_t *)(v141 + 8 * ((v140 + v144) >> 8));
        if (v142 == v141) {
          uint64_t v170 = 0;
        }
        else {
          uint64_t v170 = *v169 + 16 * (v140 + v144);
        }
        if (v169 == v167)
        {
          memset(buf, 0, 24);
          uint64_t v181 = (char *)v170;
          long long v178 = (char *)v166;
          float64x2_t v179 = (char *)v370;
        }
        else
        {
          uint64_t v176 = (char **)(v167 + 1);
          float v177 = (char *)(*v167 + 4096);
          memset(buf, 0, 24);
          long long v178 = (char *)v166;
          float64x2_t v179 = (char *)v370;
          while (1)
          {
            std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::pair<unsigned long long,unsigned long long> *,std::__deque_iterator<std::pair<unsigned long long,unsigned long long>,std::pair<unsigned long long,unsigned long long> *,std::pair<unsigned long long,unsigned long long>&,std::pair<unsigned long long,unsigned long long> **,long,256l>,0>((char **)buf, v168, v177, v178, v179);
            long long v178 = *(char **)&buf[8];
            float64x2_t v179 = *(char **)&buf[16];
            if (v176 == (char **)v169) {
              break;
            }
            uint64_t v180 = *v176++;
            uint64_t v168 = v180;
            float v177 = v180 + 4096;
            memset(buf, 0, 24);
          }
          uint64_t v168 = (char *)*v169;
          memset(buf, 0, 24);
          uint64_t v181 = (char *)v170;
        }
        std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::pair<unsigned long long,unsigned long long> *,std::__deque_iterator<std::pair<unsigned long long,unsigned long long>,std::pair<unsigned long long,unsigned long long> *,std::pair<unsigned long long,unsigned long long>&,std::pair<unsigned long long,unsigned long long> **,long,256l>,0>((char **)buf, v168, v181, v178, v179);
        uint64_t v144 = *(void *)(v138 + 40) - v161;
        *(void *)(v138 + 40) = v144;
        uint64_t v182 = *(void *)(v138 + 16);
        float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
        while (1)
        {
          uint64_t v183 = *(void *)(v138 + 8);
          uint64_t v184 = v182 == v183 ? 0 : 32 * (v182 - v183) - 1;
          unint64_t v140 = *(void *)(v138 + 32);
          if (v184 - (v144 + v140) < 0x200) {
            break;
          }
          operator delete(*(void **)(v182 - 8));
          uint64_t v182 = *(void *)(v138 + 16) - 8;
          *(void *)(v138 + 16) = v182;
          uint64_t v144 = *(void *)(v138 + 40);
        }
      }
    }
    int32x4_t v186 = *(char **)(v138 + 16);
    uint64_t v187 = *(char **)(v138 + 8);
    uint64_t v188 = v186 - v187;
    if (v186 == v187) {
      uint64_t v189 = 0;
    }
    else {
      uint64_t v189 = 32 * (v186 - v187) - 1;
    }
    unint64_t v190 = v144 + v140;
    if (v189 == v144 + v140)
    {
      if (v140 >= 0x100)
      {
        *(void *)(v138 + 32) = v140 - 256;
        uint64_t v193 = *(void *)v187;
        int8x16_t v192 = v187 + 8;
        uint64_t v191 = v193;
        *(void *)(v138 + 8) = v192;
        char v194 = v385;
        if (*(char **)(v138 + 24) == v186)
        {
          uint64_t v195 = (uint64_t)&v192[-*(void *)v138];
          if ((unint64_t)v192 <= *(void *)v138)
          {
            if (v186 == *(char **)v138) {
              unint64_t v233 = 1;
            }
            else {
              unint64_t v233 = (uint64_t)&v186[-*(void *)v138] >> 2;
            }
            long long v234 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v233);
            long long v236 = &v234[8 * (v233 >> 2)];
            long long v237 = *(uint64_t **)(v138 + 8);
            int32x4_t v186 = v236;
            uint64_t v238 = *(void *)(v138 + 16) - (void)v237;
            if (v238)
            {
              int32x4_t v186 = &v236[v238 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v239 = 8 * (v238 >> 3);
              long long v240 = &v234[8 * (v233 >> 2)];
              do
              {
                uint64_t v241 = *v237++;
                *(void *)long long v240 = v241;
                v240 += 8;
                v239 -= 8;
              }
              while (v239);
            }
            long long v242 = *(void **)v138;
            *(void *)uint64_t v138 = v234;
            *(void *)(v138 + 8) = v236;
            *(void *)(v138 + 16) = v186;
            *(void *)(v138 + 24) = &v234[8 * v235];
            if (v242)
            {
              operator delete(v242);
              int32x4_t v186 = *(char **)(v138 + 16);
            }
          }
          else
          {
            uint64_t v196 = v195 >> 3;
            BOOL v197 = v195 >> 3 < -1;
            uint64_t v198 = (v195 >> 3) + 2;
            if (v197) {
              uint64_t v199 = v198;
            }
            else {
              uint64_t v199 = v196 + 1;
            }
            uint64_t v200 = -(v199 >> 1);
            uint64_t v201 = v199 >> 1;
            uint64_t v202 = &v192[-8 * v201];
            int64_t v203 = v186 - v192;
            if (v186 == v192)
            {
              uint64_t v204 = v186;
            }
            else
            {
              memmove(&v192[-8 * v201], v192, v186 - v192);
              uint64_t v204 = *(char **)(v138 + 8);
            }
            int32x4_t v186 = &v202[v203];
            *(void *)(v138 + 8) = &v204[8 * v200];
            *(void *)(v138 + 16) = &v202[v203];
            float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
          }
        }
        *(void *)int32x4_t v186 = v191;
        goto LABEL_384;
      }
      uint64_t v205 = v188 >> 3;
      unint64_t v206 = *(char **)(v138 + 24);
      uint64_t v207 = (uint64_t)&v206[-*(void *)v138];
      if (v188 >> 3 >= (unint64_t)(v207 >> 3))
      {
        uint64_t v220 = v207 >> 2;
        if (v206 == *(char **)v138) {
          unint64_t v221 = 1;
        }
        else {
          unint64_t v221 = v220;
        }
        char v222 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v221);
        uint64_t v224 = v223;
        int8x16_t v225 = &v222[8 * v205];
        *(void *)&long long v226 = v222;
        *((void *)&v226 + 1) = v225;
        long long v379 = v226;
        float64x2_t v227 = operator new(0x1000uLL);
        *(void *)&long long v228 = v225;
        *((void *)&v228 + 1) = &v222[8 * v224];
        if (v205 == v224)
        {
          uint64_t v229 = 8 * v205;
          if (v188 < 1)
          {
            uint64_t v245 = v229 >> 2;
            if (v186 == v187) {
              unint64_t v246 = 1;
            }
            else {
              unint64_t v246 = v245;
            }
            __int16 v247 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v246);
            int8x16_t v225 = &v247[8 * (v246 >> 2)];
            *(void *)&long long v249 = v247;
            *((void *)&v249 + 1) = v225;
            long long v380 = v249;
            *(void *)&long long v249 = v225;
            *((void *)&v249 + 1) = &v247[8 * v248];
            *(_OWORD *)long long v371 = v249;
            char v194 = v385;
            if (v222) {
              operator delete(v222);
            }
            long long v232 = v380;
            long long v228 = *(_OWORD *)v371;
          }
          else
          {
            uint64_t v230 = v229 >> 3;
            if (v230 >= -1) {
              unint64_t v231 = v230 + 1;
            }
            else {
              unint64_t v231 = v230 + 2;
            }
            v225 -= 8 * (v231 >> 1);
            *(void *)&long long v228 = v225;
            *(void *)&long long v232 = v379;
            *((void *)&v232 + 1) = v225;
            char v194 = v385;
          }
        }
        else
        {
          char v194 = v385;
          long long v232 = v379;
        }
        *(void *)int8x16_t v225 = v227;
        *(void *)&long long v228 = v228 + 8;
        for (uint64_t j = *(void *)(v138 + 16); j != *(void *)(v138 + 8); j -= 8)
        {
          double v251 = (void *)*((void *)&v232 + 1);
          if (*((void *)&v232 + 1) == (void)v232)
          {
            int v253 = (unsigned char *)v228;
            if ((unint64_t)v228 >= *((void *)&v228 + 1))
            {
              if (*((void *)&v228 + 1) == *((void *)&v232 + 1)) {
                unint64_t v258 = 1;
              }
              else {
                unint64_t v258 = (uint64_t)(*((void *)&v228 + 1) - *((void *)&v232 + 1)) >> 2;
              }
              int v259 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v258);
              int32x4_t v252 = &v259[(2 * v258 + 6) & 0xFFFFFFFFFFFFFFF8];
              unint64_t v261 = v252;
              uint64_t v262 = v253 - (unsigned char *)v251;
              if (v253 != (unsigned char *)v251)
              {
                unint64_t v261 = &v252[v262 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v263 = 8 * (v262 >> 3);
                float16x4_t v264 = &v259[(2 * v258 + 6) & 0xFFFFFFFFFFFFFFF8];
                uint64_t v265 = v251;
                do
                {
                  uint64_t v266 = *v265++;
                  *(void *)float16x4_t v264 = v266;
                  v264 += 8;
                  v263 -= 8;
                }
                while (v263);
              }
              *(void *)&long long v232 = v259;
              *((void *)&v232 + 1) = &v259[(2 * v258 + 6) & 0xFFFFFFFFFFFFFFF8];
              *(void *)&long long v228 = v261;
              *((void *)&v228 + 1) = &v259[8 * v260];
              if (v251)
              {
                long long v382 = v232;
                *(_OWORD *)unint64_t v372 = v228;
                operator delete(v251);
                long long v228 = *(_OWORD *)v372;
                long long v232 = v382;
              }
            }
            else
            {
              uint64_t v254 = (uint64_t)(*((void *)&v228 + 1) - v228) >> 3;
              if (v254 >= -1) {
                uint64_t v255 = v254 + 1;
              }
              else {
                uint64_t v255 = v254 + 2;
              }
              uint64_t v256 = v255 >> 1;
              uint64_t v257 = v228 + 8 * (v255 >> 1);
              int32x4_t v252 = (char *)(v257 - (v228 - *((void *)&v232 + 1)));
              if ((void)v228 == *((void *)&v232 + 1))
              {
                int v253 = (unsigned char *)*((void *)&v232 + 1);
              }
              else
              {
                uint64_t v381 = v232;
                uint64_t v373 = *((void *)&v228 + 1);
                memmove((void *)(v257 - (v228 - *((void *)&v232 + 1))), *((const void **)&v232 + 1), v228 - *((void *)&v232 + 1));
                *((void *)&v228 + 1) = v373;
                *(void *)&long long v232 = v381;
              }
              *((void *)&v232 + 1) = v252;
              *(void *)&long long v228 = &v253[8 * v256];
            }
          }
          else
          {
            int32x4_t v252 = (char *)*((void *)&v232 + 1);
          }
          uint64_t v267 = *(void *)(j - 8);
          *((void *)v252 - 1) = v267;
          *((void *)&v232 + 1) -= 8;
        }
        float v268 = *(void **)v138;
        *(_OWORD *)uint64_t v138 = v232;
        *(_OWORD *)(v138 + 16) = v228;
        if (v268)
        {
          operator delete(v268);
          int32x4_t v186 = *(char **)(v138 + 16);
        }
        else
        {
          int32x4_t v186 = (char *)v228;
        }
        float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
      }
      else
      {
        float64x2_t v208 = operator new(0x1000uLL);
        if (v206 == v186)
        {
          long long v243 = *(char **)(v138 + 8);
          char v194 = v385;
          if (v243 == *(char **)v138)
          {
            float v269 = *(unsigned char **)(v138 + 16);
            float v270 = *(unsigned char **)(v138 + 24);
            if (v269 >= v270)
            {
              if (v270 == v243) {
                unint64_t v284 = 1;
              }
              else {
                unint64_t v284 = (v270 - v243) >> 2;
              }
              uint64_t v285 = 2 * v284;
              int32x4_t v286 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v284);
              long long v244 = &v286[(v285 + 6) & 0xFFFFFFFFFFFFFFF8];
              int32x4_t v288 = *(uint64_t **)(v138 + 8);
              float32x4_t v289 = v244;
              uint64_t v290 = *(void *)(v138 + 16) - (void)v288;
              if (v290)
              {
                float32x4_t v289 = &v244[v290 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v291 = 8 * (v290 >> 3);
                float v292 = v244;
                do
                {
                  uint64_t v293 = *v288++;
                  *(void *)float v292 = v293;
                  v292 += 8;
                  v291 -= 8;
                }
                while (v291);
              }
              float v294 = *(void **)v138;
              *(void *)uint64_t v138 = v286;
              *(void *)(v138 + 8) = v244;
              *(void *)(v138 + 16) = v289;
              *(void *)(v138 + 24) = &v286[8 * v287];
              float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
              if (v294)
              {
                operator delete(v294);
                long long v244 = *(char **)(v138 + 8);
              }
            }
            else
            {
              uint64_t v271 = (v270 - v269) >> 3;
              if (v271 >= -1) {
                uint64_t v272 = v271 + 1;
              }
              else {
                uint64_t v272 = v271 + 2;
              }
              uint64_t v273 = v272 >> 1;
              long long v244 = &v243[8 * (v272 >> 1)];
              if (v269 != v243)
              {
                memmove(&v243[8 * (v272 >> 1)], v243, v269 - v243);
                long long v243 = *(char **)(v138 + 16);
              }
              *(void *)(v138 + 8) = v244;
              *(void *)(v138 + 16) = &v243[8 * v273];
              float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
            }
          }
          else
          {
            long long v244 = *(char **)(v138 + 8);
          }
          *((void *)v244 - 1) = v208;
          int v295 = *(char **)(v138 + 8);
          int v296 = *(char **)(v138 + 16);
          *(void *)(v138 + 8) = v295 - 8;
          uint64_t v297 = *((void *)v295 - 1);
          *(void *)(v138 + 8) = v295;
          if (v296 == *(char **)(v138 + 24))
          {
            uint64_t v298 = (uint64_t)&v295[-*(void *)v138];
            if ((unint64_t)v295 <= *(void *)v138)
            {
              if (v296 == *(char **)v138) {
                unint64_t v306 = 1;
              }
              else {
                unint64_t v306 = (uint64_t)&v296[-*(void *)v138] >> 2;
              }
              uint64_t v307 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v306);
              char v309 = &v307[8 * (v306 >> 2)];
              int v310 = *(uint64_t **)(v138 + 8);
              int v296 = v309;
              uint64_t v311 = *(void *)(v138 + 16) - (void)v310;
              if (v311)
              {
                int v296 = &v309[v311 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v312 = 8 * (v311 >> 3);
                int v313 = &v307[8 * (v306 >> 2)];
                do
                {
                  uint64_t v314 = *v310++;
                  *(void *)int v313 = v314;
                  v313 += 8;
                  v312 -= 8;
                }
                while (v312);
              }
              int v315 = *(void **)v138;
              *(void *)uint64_t v138 = v307;
              *(void *)(v138 + 8) = v309;
              *(void *)(v138 + 16) = v296;
              *(void *)(v138 + 24) = &v307[8 * v308];
              float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
              if (v315)
              {
                operator delete(v315);
                int v296 = *(char **)(v138 + 16);
              }
            }
            else
            {
              uint64_t v299 = v298 >> 3;
              BOOL v197 = v298 >> 3 < -1;
              uint64_t v300 = (v298 >> 3) + 2;
              if (v197) {
                uint64_t v301 = v300;
              }
              else {
                uint64_t v301 = v299 + 1;
              }
              uint64_t v302 = -(v301 >> 1);
              uint64_t v303 = v301 >> 1;
              float v304 = &v295[-8 * v303];
              int64_t v305 = v296 - v295;
              if (v296 != v295)
              {
                memmove(&v295[-8 * v303], v295, v296 - v295);
                int v295 = *(char **)(v138 + 8);
              }
              int v296 = &v304[v305];
              *(void *)(v138 + 8) = &v295[8 * v302];
              *(void *)(v138 + 16) = &v304[v305];
              float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
            }
          }
          *(void *)int v296 = v297;
        }
        else
        {
          unint64_t v209 = *(char **)(v138 + 16);
          char v194 = v385;
          if (v209 == *(char **)(v138 + 24))
          {
            BOOL v210 = *(char **)(v138 + 8);
            uint64_t v211 = (uint64_t)&v210[-*(void *)v138];
            if ((unint64_t)v210 <= *(void *)v138)
            {
              if (v209 == *(char **)v138) {
                unint64_t v274 = 1;
              }
              else {
                unint64_t v274 = (uint64_t)&v209[-*(void *)v138] >> 2;
              }
              float v275 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v274);
              float v277 = &v275[8 * (v274 >> 2)];
              float v278 = *(uint64_t **)(v138 + 8);
              unint64_t v209 = v277;
              uint64_t v279 = *(void *)(v138 + 16) - (void)v278;
              if (v279)
              {
                unint64_t v209 = &v277[v279 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v280 = 8 * (v279 >> 3);
                float v281 = &v275[8 * (v274 >> 2)];
                do
                {
                  uint64_t v282 = *v278++;
                  *(void *)float v281 = v282;
                  v281 += 8;
                  v280 -= 8;
                }
                while (v280);
                float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
              }
              int32x4_t v283 = *(void **)v138;
              *(void *)uint64_t v138 = v275;
              *(void *)(v138 + 8) = v277;
              *(void *)(v138 + 16) = v209;
              *(void *)(v138 + 24) = &v275[8 * v276];
              if (v283)
              {
                operator delete(v283);
                unint64_t v209 = *(char **)(v138 + 16);
              }
            }
            else
            {
              uint64_t v212 = v211 >> 3;
              BOOL v197 = v211 >> 3 < -1;
              uint64_t v213 = (v211 >> 3) + 2;
              if (v197) {
                uint64_t v214 = v213;
              }
              else {
                uint64_t v214 = v212 + 1;
              }
              uint64_t v215 = -(v214 >> 1);
              uint64_t v216 = v214 >> 1;
              long long v217 = &v210[-8 * v216];
              int64_t v218 = v209 - v210;
              if (v209 != v210)
              {
                memmove(&v210[-8 * v216], v210, v209 - v210);
                unint64_t v209 = *(char **)(v138 + 8);
              }
              int8x16_t v219 = &v209[8 * v215];
              unint64_t v209 = &v217[v218];
              *(void *)(v138 + 8) = v219;
              *(void *)(v138 + 16) = &v217[v218];
              float32x2_t v103 = (CA::WindowServer::IOMFBServer *)v366;
            }
          }
          *(void *)unint64_t v209 = v208;
        }
LABEL_384:
        int32x4_t v186 = (char *)(*(void *)(v138 + 16) + 8);
        *(void *)(v138 + 16) = v186;
      }
      unint64_t v140 = *(void *)(v138 + 32);
      uint64_t v144 = *(void *)(v138 + 40);
      uint64_t v187 = *(char **)(v138 + 8);
      unint64_t v190 = v140 + v144;
    }
    else
    {
      char v194 = v385;
    }
    uint64_t v316 = (uint64_t *)(*(void *)&v187[(v190 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v190);
    *uint64_t v316 = v367;
    v316[1] = v129;
    *(void *)(v138 + 40) = v144 + 1;
    if (v186 == v187
      || (uint64_t v317 = &v187[8 * (v140 >> 8)],
          uint64_t v318 = *(void *)v317,
          uint64_t v319 = *(void *)v317 + 16 * v140,
          uint64_t v320 = *(void *)&v187[((*v376 + v140) >> 5) & 0x7FFFFFFFFFFFFF8]
               + 16 * (*(unsigned char *)v376 + v140),
          v319 == v320))
    {
      unint64_t v324 = 0;
      a3 = v352;
    }
    else
    {
      int v321 = 0;
      a3 = v352;
      do
      {
        uint64_t v322 = v319 + 16;
        if (v319 + 16 - v318 == 4096)
        {
          uint64_t v323 = *((void *)v317 + 1);
          v317 += 8;
          uint64_t v318 = v323;
          uint64_t v322 = v323;
        }
        v321 += *(_DWORD *)(v319 + 8);
        uint64_t v319 = v322;
      }
      while (v322 != v320);
      unint64_t v324 = v321;
    }
    uint32_t v325 = (CATimeWithHostTime(v324) * 1000.0);
    if (arc4random_uniform(0xFAu) <= v325
      && (!objc_msgSend((id)objc_msgSend((id)objc_msgSend(NSString, "stringWithUTF8String:", v194 + 7), "lastPathComponent"), "isEqual:", @"SpringBoard")|| arc4random_uniform(0x64u) >= 0x55))
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        float v326 = x_log_category_utilities;
        if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_INFO))
        {
          uint64_t v327 = *v376;
          *(_DWORD *)long long buf = 134218240;
          *(void *)&uint8_t buf[4] = v327;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v325;
          _os_log_impl(&dword_184668000, v326, OS_LOG_TYPE_INFO, "Diagnostics (tailspin) allowed for %zu glitches with %d ms glitch time.", buf, 0x12u);
        }
      }
      CATailspinLastRequestTimestamp = v135;
      if (CADeviceHasInternalBuild::once[0] != -1) {
        dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
      }
      if (CADeviceHasInternalBuild::internal)
      {
        memset(buf, 0, 24);
        *(_DWORD *)&v388[4] = 0;
        uint64_t v389 = 0;
        *(_DWORD *)int64x2_t v388 = 14;
        *(void *)int8x16_t v390 = buf;
        CA::Render::post_notification(0x30u, 0, (uint64_t)v388, 0);
        int v328 = x_stream_finish((uint64_t)buf);
        if (*(void *)buf) {
          free(*(void **)buf);
        }
        CATailspinEmit(v365, v360, v364, (uint64_t)(v194 + 7), v328);
        if (v328) {
          free(v328);
        }
      }
      else
      {
        CATailspinEmit(v365, v360, v364, (uint64_t)(v194 + 7), 0);
      }
    }
  }
LABEL_409:
  qword_1E8F86630 += v129;
  *(void *)long long buf = cf;
  *(void *)&uint8_t buf[8] = 0;
  *(void *)&uint8_t buf[16] = 0;
  *(void *)&unsigned char buf[24] = cf;
  *(void *)&long long v329 = -1;
  *((void *)&v329 + 1) = -1;
  *(_OWORD *)&uint8_t buf[32] = v329;
  *(_OWORD *)&buf[48] = v329;
  if (cf) {
    CFRetain(cf);
  }
  CA::IOMobileFramebuffer::swap_wait((CA::IOMobileFramebuffer *)buf);
  int v8 = v386;
  double v330 = (char *)*((void *)v386 + 9);
  int v331 = (char *)v386 + 80;
  if (v330 != (char *)v386 + 80)
  {
    double v332 = v14 - v15;
    do
    {
      uint64_t v333 = (CA::Render::ImageQueue *)*((void *)v330 + 4);
      if (*((unsigned char *)v333 + 12) != 25) {
        __assert_rtn("frame_info_callback", "windowserver-iomfb-server.cpp", 1524, "obj->type () == Render::kTypeImageQueue");
      }
      uint64_t v334 = (_DWORD *)*((void *)v103 + 12);
      double v335 = 0.0;
      if ((v334[156] & 0x10) != 0) {
        double v335 = (*(double (**)(_DWORD *))(*(void *)v334 + 760))(v334);
      }
      CA::Render::ImageQueue::did_display(v333, v360, v14, v332, v335);
      int v336 = (char *)*((void *)v330 + 1);
      if (v336)
      {
        do
        {
          int v337 = v336;
          int v336 = *(char **)v336;
        }
        while (v336);
      }
      else
      {
        do
        {
          int v337 = (char *)*((void *)v330 + 2);
          BOOL v57 = *(void *)v337 == (void)v330;
          double v330 = v337;
        }
        while (!v57);
      }
      double v330 = v337;
    }
    while (v337 != v331);
  }
  double v338 = CATimeWithHostTime((unint64_t)v353 - *((void *)v103 + 116));
  double v339 = fmax(round(v338 / (*(double (**)(void))(**((void **)v103 + 12) + 760))(*((void *)v103 + 12)))+ -1.0, 0.0);
  float v340 = (void *)*((void *)v103 + 12);
  unint64_t v341 = 240;
  if ((unint64_t)v339 < 0xF0) {
    unint64_t v341 = (unint64_t)v339;
  }
  ++*(void *)(v340[3175] + 8 * v341);
  if ((unint64_t)v339 + 1 == (*(unsigned int (**)(void *))(*v340 + 768))(v340))
  {
    unsigned int v343 = *(_WORD *)((unsigned char *)v8 + 197) & 0xF;
    if (v343 >= 9) {
      unsigned int v343 = 9;
    }
    uint64_t v344 = *((void *)v103 + 12) + 4 * v343;
    ++*(_DWORD *)(v344 + 25492);
  }
  *((void *)v103 + 116) = v353;
  CA::WindowServer::IOMFBServer::forward_frame_info_callback(v103, a3, v8, v342);
  if (*(void *)buf) {
    CFRelease(*(CFTypeRef *)buf);
  }
LABEL_430:
  int32x4_t v386 = 0;
  if (v8)
  {
LABEL_431:
    CA::WindowServer::IOMFBDisplay::FrameInfo::~FrameInfo(v8);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v8);
  }
}

void sub_184740BC8(_Unwind_Exception *a1)
{
}

void *std::__hash_table<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::PreviousMCTRecord>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::PreviousMCTRecord>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::PreviousMCTRecord>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::WindowServer::IOMFBDisplay::PreviousMCTRecord>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(float *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *((void *)a1 + 1);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    unsigned int v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      __int16 v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          __int16 v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  __int16 v10 = operator new(0x28uLL);
  *__int16 v10 = 0;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  v10[3] = 0;
  _OWORD v10[4] = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    BOOL v14 = 1;
    if (v6 >= 3) {
      BOOL v14 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v6);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      int8x8_t prime = (int8x8_t)v16;
    }
    else {
      int8x8_t prime = (int8x8_t)v15;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v6 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v6) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v6)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v6 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (*(void *)&prime <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      if (*(void *)&prime >= v6)
      {
        unint64_t v6 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * *(void *)&prime);
          unint64_t v19 = *(void **)a1;
          *(void *)a1 = v18;
          if (v19) {
            operator delete(v19);
          }
          uint64_t v20 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v20++) = 0;
          while (*(void *)&prime != v20);
          __int16 v21 = (void *)*((void *)a1 + 2);
          if (v21)
          {
            unint64_t v22 = v21[1];
            uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
            v23.i16[0] = vaddlv_u8(v23);
            if (v23.u32[0] > 1uLL)
            {
              if (v22 >= *(void *)&prime) {
                v22 %= *(void *)&prime;
              }
            }
            else
            {
              v22 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
            unint64_t v27 = (void *)*v21;
            if (*v21)
            {
              do
              {
                unint64_t v28 = v27[1];
                if (v23.u32[0] > 1uLL)
                {
                  if (v28 >= *(void *)&prime) {
                    v28 %= *(void *)&prime;
                  }
                }
                else
                {
                  v28 &= *(void *)&prime - 1;
                }
                if (v28 != v22)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v28))
                  {
                    *(void *)(*(void *)a1 + 8 * v28) = v21;
                    goto LABEL_55;
                  }
                  *__int16 v21 = *v27;
                  *unint64_t v27 = **(void **)(*(void *)a1 + 8 * v28);
                  **(void **)(*(void *)a1 + 8 * v28) = v27;
                  unint64_t v27 = v21;
                }
                unint64_t v28 = v22;
LABEL_55:
                __int16 v21 = v27;
                unint64_t v27 = (void *)*v27;
                unint64_t v22 = v28;
              }
              while (v27);
            }
          }
          unint64_t v6 = (unint64_t)prime;
          goto LABEL_59;
        }
        unint64_t v33 = *(void **)a1;
        *(void *)a1 = 0;
        if (v33) {
          operator delete(v33);
        }
        unint64_t v6 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  BOOL v29 = *(void **)a1;
  unint64_t v30 = *(void **)(*(void *)a1 + 8 * v8);
  if (v30)
  {
    *__int16 v10 = *v30;
LABEL_72:
    *unint64_t v30 = v10;
    goto LABEL_73;
  }
  *__int16 v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v8] = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v31 >= v6) {
        v31 %= v6;
      }
    }
    else
    {
      v31 &= v6 - 1;
    }
    unint64_t v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

_DWORD *CA::Render::Context::process_path(CA::Render::Context *this)
{
  uint64_t v1 = MEMORY[0x1F4188790](this);
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  double result = *(_DWORD **)(v1 + 232);
  if (!result)
  {
    bzero(buffer, 0x1000uLL);
    pid_t v3 = atomic_load((unsigned int *)(v1 + 228));
    if (!v3)
    {
      pid_t v3 = *(_DWORD *)(v1 + 252) ? 0 : getpid();
      pid_t v4 = 0;
      atomic_compare_exchange_strong((atomic_uint *volatile)(v1 + 228), (unsigned int *)&v4, v3);
      if (v4) {
        pid_t v3 = v4;
      }
    }
    int v5 = proc_pidpath(v3, buffer, 0x1000u);
    double result = CA::Render::String::new_string((CA::Render::String *)v5, buffer, v6);
    uint8x8_t v7 = *(atomic_uint **)(v1 + 232);
    *(void *)(v1 + 232) = result;
    if (v7)
    {
      if (atomic_fetch_add(v7 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v7 + 16))(v7);
      }
      return *(_DWORD **)(v1 + 232);
    }
  }
  return result;
}

void CAShmemImageQueueCollectable(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a3) {
    BOOL v4 = *(_DWORD *)(a1 + 44) != a3;
  }
  else {
    BOOL v4 = 1;
  }
  uint64_t v5 = *(unsigned int *)(a1 + 28);
  int v6 = v4 | a4;
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    if (a2 && a3)
    {
      *(_DWORD *)(a1 + 44) = a3;
LABEL_12:
      *(unsigned char *)(a1 + 76) = CA::MachPortUtil::call_with_timeout<int (*)(unsigned int,unsigned int,unsigned int),unsigned int>(a2, *(unsigned char *)(a1 + 76), (uint64_t)"IQCollectable", (uint64_t (*)(uint64_t, void, uint64_t))_CACImageQueueCollectable, v5) == 268435460;
      return;
    }
    if (a2) {
      goto LABEL_12;
    }
    if (CA::MachPortUtil::reply_queue(void)::once != -1)
    {
      uint64_t v9 = *(unsigned int *)(a1 + 28);
      dispatch_once(&CA::MachPortUtil::reply_queue(void)::once, &__block_literal_global_9866);
      uint64_t v5 = v9;
    }
    unint64_t v8 = CA::MachPortUtil::reply_queue(void)::queue;
    dispatch_async_f(v8, (void *)v5, (dispatch_function_t)collectable_callback);
  }
}

uint64_t CA::MachPortUtil::call_with_timeout<int (*)(unsigned int,unsigned int,unsigned int),unsigned int>(uint64_t a1, char a2, uint64_t a3, uint64_t (*a4)(uint64_t, void, uint64_t), uint64_t a5)
{
  int v5 = a5;
  mach_port_name_t v9 = a1;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = a4(a1, 0, a5);
  uint64_t v11 = v10;
  if (!v10) {
    return v11;
  }
  if (v10 != 268435460)
  {
    if (x_log_hook_p())
    {
      mach_error_string(v11);
LABEL_10:
      x_log_();
      return v11;
    }
    uint64_t v13 = x_log_category_utilities;
    if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR)) {
      return v11;
    }
    *(_DWORD *)long long buf = 136315650;
    uint64_t v24 = a3;
    __int16 v25 = 1024;
    int v26 = v11;
    __int16 v27 = 2080;
    unint64_t v28 = mach_error_string(v11);
    BOOL v14 = "%s client message err=0x%x : %s";
    unint64_t v15 = v13;
    uint32_t v16 = 28;
LABEL_15:
    _os_log_impl(&dword_184668000, v15, OS_LOG_TYPE_ERROR, v14, buf, v16);
    return v11;
  }
  if (v9 - 1 > 0xFFFFFFFD || mach_port_mod_refs(*MEMORY[0x1E4F14960], v9, 0, 1))
  {
    if (x_log_hook_p()) {
      goto LABEL_10;
    }
    uint64_t v17 = x_log_category_utilities;
    if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR)) {
      return v11;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v24 = a3;
    BOOL v14 = "%s failed to retain right";
    unint64_t v15 = v17;
    uint32_t v16 = 12;
    goto LABEL_15;
  }
  if (CA::MachPortUtil::reply_queue(void)::once != -1) {
    dispatch_once(&CA::MachPortUtil::reply_queue(void)::once, &__block_literal_global_9866);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN2CA12MachPortUtil17call_with_timeoutIPFijjjEJjEEEijjbPKcT_DpT0__block_invoke;
  block[3] = &__block_descriptor_tmp_113;
  mach_port_name_t v19 = v9;
  int v20 = 2;
  int v21 = v5;
  char v22 = a2;
  block[4] = a4;
  block[5] = a3;
  dispatch_async((dispatch_queue_t)CA::MachPortUtil::reply_queue(void)::queue, block);
  return v11;
}

uint64_t _CACImageQueueCollectable(mach_port_t a1, mach_msg_timeout_t timeout, int a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *MEMORY[0x1E4F14068];
  int v8 = a3;
  *(void *)&v6.uint64_t msgh_bits = 19;
  v6.uint64_t msgh_voucher_port = 0;
  v6.mach_msg_id_t msgh_id = 40403;
  v6.mach_port_t msgh_remote_port = a1;
  v6.mach_port_t msgh_local_port = 0;
  if (MEMORY[0x1E4F14B18]) {
    voucher_mach_msg_set(&v6);
  }
  uint64_t v4 = mach_msg(&v6, 17, 0x24u, 0, 0, timeout, 0);
  if ((v4 - 268435459) <= 1)
  {
    if ((v6.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v6.msgh_local_port);
    }
    mach_msg_destroy(&v6);
  }
  return v4;
}

uint64_t CA::WindowServer::IOMFBServer::run_loop(CA::WindowServer::IOMFBServer *this)
{
  return *((void *)this + 96);
}

void CA::Render::invoke_presentation_handlers(void *a1, int a2, uint64_t a3, uint64_t a4, char a5, double a6)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  double v50 = 0;
  uint64_t v51 = 0;
  double v49 = &v50;
  mach_msg_header_t v6 = a1 + 1;
  uint64_t v7 = (void *)*a1;
  if ((void *)*a1 == a1 + 1)
  {
    float v45 = 0;
  }
  else
  {
    do
    {
      if (*((unsigned char *)v7 + 40))
      {
        uint64_t v10 = *((unsigned int *)v7 + 11);
        uint64_t v11 = v7[4];
        signed int v12 = atomic_load((unsigned int *)(v11 + 228));
        if (!v12)
        {
          if (*(_DWORD *)(v11 + 252)) {
            pid_t v13 = 0;
          }
          else {
            pid_t v13 = getpid();
          }
          signed int v14 = 0;
          atomic_compare_exchange_strong((atomic_uint *volatile)(v11 + 228), (unsigned int *)&v14, v13);
          if (v14) {
            signed int v12 = v14;
          }
          else {
            signed int v12 = v13;
          }
        }
        unint64_t v15 = v50;
        if (!v50) {
          goto LABEL_41;
        }
        uint32_t v16 = &v50;
        do
        {
          signed int v17 = *((_DWORD *)v15 + 7);
          BOOL v18 = v17 == v12;
          if (v17 >= v12) {
            char v19 = 1;
          }
          else {
            char v19 = -1;
          }
          if (v18)
          {
            unsigned int v20 = *((_DWORD *)v15 + 8);
            BOOL v21 = v20 == v10;
            char v19 = v20 >= v10 ? 1 : -1;
            if (v21) {
              char v19 = 0;
            }
          }
          BOOL v22 = (v19 & 0x80) == 0;
          if (v19 < 0) {
            uint8x8_t v23 = v15 + 1;
          }
          else {
            uint8x8_t v23 = v15;
          }
          if (v22) {
            uint32_t v16 = (uint64_t **)v15;
          }
          unint64_t v15 = (uint64_t *)*v23;
        }
        while (*v23);
        if (&v50 == v16) {
          goto LABEL_41;
        }
        signed int v24 = *((_DWORD *)v16 + 7);
        BOOL v25 = v12 == v24;
        if (v12 >= v24) {
          char v26 = 1;
        }
        else {
          char v26 = -1;
        }
        if (v25)
        {
          unsigned int v27 = *((_DWORD *)v16 + 8);
          BOOL v28 = v10 == v27;
          if (v10 >= v27) {
            char v29 = 1;
          }
          else {
            char v29 = -1;
          }
          if (v28) {
            char v26 = 0;
          }
          else {
            char v26 = v29;
          }
        }
        if (v26 < 0)
        {
LABEL_41:
          mach_port_t v30 = *(_DWORD *)(v7[4] + 256);
          uint64_t v53 = *MEMORY[0x1E4F14068];
          int v54 = v10;
          int v55 = a2;
          double v56 = a6;
          uint64_t v57 = a3;
          uint64_t v58 = a4;
          char v59 = a5;
          __int16 v60 = 0;
          char v61 = 0;
          *(void *)&msg.uint64_t msgh_bits = 19;
          msg.uint64_t msgh_voucher_port = 0;
          msg.mach_msg_id_t msgh_id = 40407;
          msg.mach_port_t msgh_remote_port = v30;
          msg.mach_port_t msgh_local_port = 0;
          if (MEMORY[0x1E4F14B18]) {
            voucher_mach_msg_set(&msg);
          }
          if ((mach_msg(&msg, 17, 0x44u, 0, 0, 0, 0) - 268435459) <= 1)
          {
            if ((msg.msgh_bits & 0x1F00) == 0x1100) {
              mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
            }
            mach_msg_destroy(&msg);
          }
          unint64_t v31 = v50;
          unint64_t v32 = &v50;
          for (i = &v50; v31; unint64_t v31 = v32[1])
          {
            while (1)
            {
              unint64_t v32 = (uint64_t **)v31;
              signed int v34 = *((_DWORD *)v31 + 7);
              if (v12 == v34) {
                break;
              }
              if (v12 >= v34)
              {
                if (v34 >= v12) {
                  char v38 = 1;
                }
                else {
                  char v38 = -1;
                }
                if ((v38 & 0x80) == 0) {
                  goto LABEL_69;
                }
                goto LABEL_64;
              }
LABEL_58:
              unint64_t v31 = *v32;
              uint64_t i = v32;
              if (!*v32) {
                goto LABEL_65;
              }
            }
            unsigned int v35 = *((_DWORD *)v32 + 8);
            if (v10 < v35) {
              goto LABEL_58;
            }
            BOOL v36 = v35 == v10;
            if (v35 >= v10) {
              char v37 = 1;
            }
            else {
              char v37 = -1;
            }
            if (v36) {
              char v37 = 0;
            }
            if ((v37 & 0x80) == 0) {
              goto LABEL_69;
            }
LABEL_64:
            uint64_t i = v32 + 1;
          }
LABEL_65:
          int8x16_t v39 = (uint64_t *)operator new(0x28uLL);
          *(uint64_t *)((char *)v39 + 28) = (v10 << 32) | v12;
          uint64_t *v39 = 0;
          v39[1] = 0;
          _OWORD v39[2] = (uint64_t)v32;
          *uint64_t i = v39;
          if (*v49)
          {
            double v49 = (uint64_t **)*v49;
            unint64_t v40 = *i;
          }
          else
          {
            unint64_t v40 = v39;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v50, v40);
          ++v51;
        }
LABEL_69:
        BOOL v41 = (pthread_mutex_t *)(v7[4] + 72);
        pthread_mutex_lock(v41);
        uint64_t v42 = v7[4];
        if (*(_DWORD *)(v42 + 292) && *(_DWORD *)(v42 + 296) <= *((_DWORD *)v7 + 11)) {
          *(void *)(v42 + 292) = 0;
        }
        pthread_mutex_unlock(v41);
      }
      unint64_t v43 = (void *)v7[1];
      if (v43)
      {
        do
        {
          double v44 = v43;
          unint64_t v43 = (void *)*v43;
        }
        while (v43);
      }
      else
      {
        do
        {
          double v44 = (void *)v7[2];
          BOOL v18 = *v44 == (void)v7;
          uint64_t v7 = v44;
        }
        while (!v18);
      }
      uint64_t v7 = v44;
    }
    while (v44 != v6);
    float v45 = v50;
  }
  std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(v45);
}

void CA::WindowServer::IOMFBServer::forward_frame_info_callback(CA::WindowServer::IOMFBServer *this, const __CFDictionary *a2, const __CFDictionary *a3, const CA::WindowServer::IOMFBDisplay::FrameInfo *a4)
{
  CFDictionaryRef Int64 = CA_CFDictionaryGetInt64(a2, @"Presentation_time");
  CFDictionaryRef v8 = CA_CFDictionaryGetInt64(a2, @"Requested_presentation");
  CFDictionaryRef v9 = CA_CFDictionaryGetInt64(a2, @"Min_FrameTime");
  CFDictionaryRef v10 = CA_CFDictionaryGetInt64(a2, @"Max_FrameTime");
  CFDictionaryRef v11 = CA_CFDictionaryGetInt64(a2, @"Vbl_FrameTime");
  double v46 = this;
  if (*(unsigned char *)(*((void *)this + 12) + 28192))
  {
    mach_get_times();
    CFDictionaryRef v12 = v9;
    if (!v9) {
      CFDictionaryRef v12 = 0;
    }
    CFDictionaryRef v41 = v8;
    CFDictionaryRef v42 = v12;
    if (!v10) {
      CFDictionaryRef v10 = 0;
    }
  }
  else
  {
    CFDictionaryRef v41 = v8;
    CFDictionaryRef v42 = v9;
  }
  CFDictionaryRef v40 = v11;
  pid_t v13 = (uint64_t *)*((void *)a3 + 15);
  signed int v14 = (uint64_t *)*((void *)a3 + 16);
  CFDictionaryRef v44 = a3;
  if (v13 == v14)
  {
    Mutable = 0;
  }
  else
  {
    Mutable = 0;
    uint32_t v16 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    signed int v17 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    do
    {
      uint64_t v18 = *v13;
      if (!Mutable)
      {
        Mutable = CFDictionaryCreateMutable(0, 0, v16, v17);
        CA_CFDictionarySetLongLong(Mutable, @"brightnessTransactionPresentationTime", (uint64_t)Int64);
      }
      (*(void (**)(uint64_t, __CFDictionary *))(v18 + 16))(v18, Mutable);
      ++v13;
    }
    while (v13 != v14);
  }
  char v19 = (os_unfair_lock_s *)((char *)v46 + 320);
  os_unfair_lock_lock((os_unfair_lock_t)v46 + 80);
  uint64_t v20 = *((void *)v46 + 1);
  os_unfair_lock_unlock((os_unfair_lock_t)v46 + 80);
  if (v20 || BYTE5(xmmword_1EB2ACBF0))
  {
    int64_t v21 = v42 - Int64;
    if (!v42) {
      int64_t v21 = 0;
    }
    int64_t v43 = v21;
    int64_t v22 = v10 - Int64;
    if (!v10) {
      int64_t v22 = 0;
    }
    int64_t v39 = v22;
    int Int = CA_CFDictionaryGetInt(a2, @"BrightOut_NoScale");
    int v37 = CA_CFDictionaryGetInt(a2, @"Bright_ScalingFactor");
    double v23 = (double)(int)CA_CFDictionaryGetInt(a2, @"Frame_APCE");
    unsigned __int8 Bool = CA_CFDictionaryGetBool(a2, @"RTPLC_RT_Trig");
    unsigned __int8 v25 = CA_CFDictionaryGetBool(a2, @"RTPLC_Bright_Capped");
    if (CADeviceSupportsRTPLC::once[0] != -1) {
      dispatch_once(CADeviceSupportsRTPLC::once, &__block_literal_global_301);
    }
    CFDictionaryRef v26 = v44;
    double v27 = v23 * 0.0000152587891;
    if (CADeviceSupportsRTPLC::rtplc)
    {
      atomic_store(*(unint64_t *)&v27, (unint64_t *)(*((void *)v46 + 12) + 27816));
      atomic_store(Bool, (unsigned __int8 *)(*((void *)v46 + 12) + 27824));
      atomic_store(v25, (unsigned __int8 *)(*((void *)v46 + 12) + 27825));
    }
    unsigned int v45 = *(_DWORD *)(*((void *)v46 + 12) + 24);
    uint64_t v28 = *((unsigned int *)v26 + 48);
    __int16 v29 = *(_WORD *)((char *)v26 + 197);
    uint64_t v31 = *(unsigned int *)v26;
    unsigned int v30 = *((_DWORD *)v26 + 1);
    os_unfair_lock_lock(v19);
    unint64_t v32 = (void (**)(void *, void, uint64_t, const __CFDictionary *, const __CFDictionary *, int64_t, int64_t, uint64_t, float, float, float, int, const __CFDictionary *, unsigned int))_Block_copy(*((const void **)v46 + 1));
    os_unfair_lock_unlock(v19);
    if (v32)
    {
      float v33 = v27;
      float v34 = (double)v37 * 0.0000152587891;
      float v35 = (double)Int * 0.0000152587891;
      BYTE2(v36) = v25;
      BYTE1(v36) = Bool;
      LOBYTE(v36) = (v29 & 0x200) != 0;
      v32[2](v32, v45, v28, v41, Int64, v43, v39, v31, v35, v34, v33, v36, v40, v30);
      _Block_release(v32);
    }
  }
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

CFDictionaryRef CA_CFDictionaryGetInt64(const __CFDictionary *result, const void *a2)
{
  v4[1] = *MEMORY[0x1E4F143B8];
  if (result)
  {
    double result = (const __CFDictionary *)CFDictionaryGetValue(result, a2);
    if (result)
    {
      CFNumberRef v2 = result;
      CFTypeID v3 = CFGetTypeID(result);
      if (v3 == CFBooleanGetTypeID())
      {
        return (const __CFDictionary *)(*MEMORY[0x1E4F1CFC8] != (void)v2);
      }
      else if (v3 == CFNumberGetTypeID())
      {
        v4[0] = 0;
        CFNumberGetValue(v2, kCFNumberSInt64Type, v4);
        return (const __CFDictionary *)v4[0];
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void CA::WindowServer::IOMFBDisplay::collect_frame_info(CA::WindowServer::IOMFBDisplay::FrameInfo **this, uint64_t a2, unsigned int a3)
{
  *this = 0;
  mach_msg_header_t v6 = (os_unfair_lock_s *)(a2 + 25940);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 25940));
  uint64_t v7 = *(CA::WindowServer::IOMFBDisplay::FrameInfo ***)(a2 + 25944);
  if (v7 != *(CA::WindowServer::IOMFBDisplay::FrameInfo ***)(a2 + 25952))
  {
    do
    {
      BOOL v8 = a3 == 0;
      unsigned int v9 = *(_DWORD *)*v7;
      if (v9 <= a3) {
        BOOL v8 = 1;
      }
      if (v9 == a3)
      {
        CFDictionaryRef v10 = *this;
        *this = *v7;
        void *v7 = v10;
      }
      if (v8)
      {
        CFDictionaryRef v11 = v7 + 1;
        CFDictionaryRef v12 = *(CA::WindowServer::IOMFBDisplay::FrameInfo ***)(a2 + 25952);
        if (v7 + 1 == v12)
        {
          pid_t v13 = v7;
        }
        else
        {
          do
          {
            pid_t v13 = v11;
            signed int v14 = v11 - 1;
            unint64_t v15 = *v11;
            *v11++ = 0;
            std::unique_ptr<CA::WindowServer::IOMFBDisplay::FrameInfo>::reset[abi:nn180100](v14, v15);
          }
          while (v11 != v12);
          CFDictionaryRef v11 = *(CA::WindowServer::IOMFBDisplay::FrameInfo ***)(a2 + 25952);
        }
        while (v11 != v13)
          std::unique_ptr<CA::WindowServer::IOMFBDisplay::FrameInfo>::reset[abi:nn180100](--v11, 0);
        *(void *)(a2 + 25952) = v13;
      }
      else
      {
        ++v7;
        pid_t v13 = *(CA::WindowServer::IOMFBDisplay::FrameInfo ***)(a2 + 25952);
      }
    }
    while (v7 != v13);
  }
  os_unfair_lock_unlock(v6);
  if (a3)
  {
    if ((*(_DWORD *)(a2 + 624) & 0x40) != 0)
    {
      uint32_t v16 = *(os_unfair_lock_s **)(a2 + 320);
      if (v16)
      {
        CA::WindowServer::FlipBook::swap_completed(v16, a3);
      }
    }
  }
}

void std::unique_ptr<CA::WindowServer::IOMFBDisplay::FrameInfo>::reset[abi:nn180100](CA::WindowServer::IOMFBDisplay::FrameInfo **a1, CA::WindowServer::IOMFBDisplay::FrameInfo *a2)
{
  CFNumberRef v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    CA::WindowServer::IOMFBDisplay::FrameInfo::~FrameInfo(v2);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v2);
  }
}

void CA::WindowServer::IOMFBDisplay::add_timing(CA::WindowServer::IOMFBDisplay *this, unint64_t a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 26048);
  os_unfair_lock_lock((os_unfair_lock_t)this + 6512);
  CA::WindowServer::IOMFBDisplay::initialize_timings(this);
  int v5 = (unsigned __int8 *)*((void *)this + 3258);
  if (v5)
  {
    unsigned __int8 v6 = atomic_load(v5);
    if (v6)
    {
      uint64_t v7 = mach_absolute_time();
      if (v7 < a2)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          CFDictionaryRef v40 = x_log_category_windowserver;
          if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 134218240;
            *(void *)&uint8_t buf[4] = a2;
            __int16 v42 = 2048;
            uint64_t v43 = v7;
            _os_log_impl(&dword_184668000, v40, OS_LOG_TYPE_ERROR, "unexpected presentation time %llu, now %llu", buf, 0x16u);
          }
        }
      }
      else if (*((void *)this + 3263))
      {
        *(void *)long long buf = 0;
        unint64_t v8 = atomic_load((unint64_t *)(*((void *)this + 3258) + 24));
        *(void *)long long buf = v8;
        if (v8) {
          CA::WindowServer::IOMFBDisplay::flush_timings_locked(this, v7, (unint64_t *)buf);
        }
        uint64_t v9 = *((void *)this + 3263);
        double v10 = (*(double (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 760))(this);
        unint64_t v11 = CAHostTimeWithTime(v10);
        unint64_t v12 = v11;
        unint64_t v13 = *((void *)this + 3263);
        if (v13 < a2 && (unint64_t v14 = a2 - v9, (v15 = vcvtad_u64_f64((double)(a2 - v9) / (double)v11)) != 0))
        {
          unint64_t v16 = v14 / v15;
          unint64_t v17 = v11 - v14 / v15;
          BOOL v18 = v14 / v15 >= v11;
          unint64_t v19 = v14 / v15 - v11;
          if (v19 != 0 && v18) {
            unint64_t v20 = v19;
          }
          else {
            unint64_t v20 = v17;
          }
          unint64_t v21 = *((void *)this + 3262) + v15;
          *((void *)this + 3262) = v21;
          *((void *)this + 3263) = a2;
          uint64_t v22 = *((void *)this + 3258);
          if (*(void *)buf)
          {
            unint64_t v23 = atomic_load((unint64_t *)(v22 + 48));
            unint64_t v24 = v21 - v23;
            unint64_t v25 = atomic_load((unint64_t *)(*((void *)this + 3258) + 56));
            unint64_t v26 = v24 + v25;
            uint64_t v22 = *((void *)this + 3258);
            unsigned int add = atomic_fetch_add((atomic_uint *volatile)(v22 + 16), 1u);
            atomic_store(*((void *)this + 3262), (unint64_t *)(v22 + 48));
            atomic_store(v26, (unint64_t *)(v22 + 56));
          }
          else
          {
            unsigned int add = atomic_fetch_add((atomic_uint *volatile)(v22 + 16), 1u);
            atomic_store(*((void *)this + 3262), (unint64_t *)(v22 + 48));
          }
          atomic_store(a2, (unint64_t *)(v22 + 64));
          atomic_store(add + 2, (unsigned int *)(v22 + 16));
          if (byte_1EB2ACC46) {
            CA::WindowServer::IOMFBDisplay::emit_server_timing_update_locked(this);
          }
          uint64_t v28 = (_DWORD *)((char *)this + 26072);
          if (v20 > v12 >> 4)
          {
            *uint64_t v28 = 0;
            *((void *)this + 3260) = 0;
          }
          else
          {
            uint64_t v29 = *v28;
            unint64_t v30 = *((void *)this + 3260);
            if (v29 > 0xFF)
            {
              unint64_t v31 = v30 - (v30 >> 8) + v16;
              unint64_t v33 = v31 >> 8;
            }
            else
            {
              unint64_t v31 = v30 + v16;
              unint64_t v32 = v29 + 1;
              *uint64_t v28 = v32;
              unint64_t v33 = v31 / v32;
            }
            *((void *)this + 3260) = v31;
            atomic_store(v33, (unsigned int *)(*((void *)this + 3258) + 4));
            *((void *)this + 3261) = v16;
            uint64_t v34 = *((void *)this + 3264);
            if (v34) {
              *((void *)this + 3264) = v34 - 1;
            }
            if ((*((_WORD *)this + 328) & 0x1C00) == 0)
            {
              int v35 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 768))(this);
              unsigned int v36 = atomic_load((unsigned int *)(*((void *)this + 3258) + 4));
              unint64_t v37 = v36 * v35;
              uint64_t v38 = *((void *)this + 3262);
              if (CA::OGL::AsynchronousDispatcher::dispatcher(void)::once != -1) {
                dispatch_once(&CA::OGL::AsynchronousDispatcher::dispatcher(void)::once, &__block_literal_global_1810);
              }
              uint64_t v39 = CA::OGL::AsynchronousDispatcher::dispatcher(void)::dispatcher;
              *(void *)(CA::OGL::AsynchronousDispatcher::dispatcher(void)::dispatcher + 72) = v38;
              *(void *)(v39 + 80) = a2 + (v37 >> 1);
              *(void *)(v39 + 88) = v37;
            }
            __dmb(0xBu);
          }
        }
        else if (v13 > a2 + (v11 >> 14))
        {
          *((_OWORD *)this + 1631) = 0u;
        }
      }
      else
      {
        *((void *)this + 3263) = a2;
      }
    }
  }
  os_unfair_lock_unlock(v4);
}

void CA::WindowServer::FlipBook::swap_completed(os_unfair_lock_s *this, unsigned int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this + 2;
  os_unfair_lock_lock(this + 2);
  uint64_t v5 = *(void *)&this[32]._os_unfair_lock_opaque;
  if (*(void *)&this[34]._os_unfair_lock_opaque != v5)
  {
    while (*(_DWORD *)(v5 + 48) < a2)
    {
      if (x_log_hook_p())
      {
        IOSurfaceGetID(*(IOSurfaceRef *)v5);
        x_log_();
      }
      else
      {
        unsigned __int8 v6 = x_log_category_flipbook;
        if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
        {
          IOSurfaceID ID = IOSurfaceGetID(*(IOSurfaceRef *)v5);
          int v8 = *(_DWORD *)(v5 + 48);
          *(_DWORD *)long long buf = 67109632;
          unsigned int v15 = a2;
          __int16 v16 = 1024;
          IOSurfaceID v17 = ID;
          __int16 v18 = 1024;
          int v19 = v8;
          _os_log_impl(&dword_184668000, v6, OS_LOG_TYPE_DEFAULT, "swap %u completed, recycling surface 0x%x from swap %u", buf, 0x14u);
        }
      }
      CA::WindowServer::FlipBook::reuse_frame(this, (void *)v5);
      uint64_t v9 = *(void *)&this[34]._os_unfair_lock_opaque;
      uint64_t v10 = v5;
      if (v5 + 104 == v9)
      {
        *(void *)&this[34]._uint32_t os_unfair_lock_opaque = v5;
        break;
      }
      do
      {
        uint64_t v11 = v10 + 104;
        long long v12 = *(_OWORD *)(v10 + 120);
        *(_OWORD *)uint64_t v10 = *(_OWORD *)(v10 + 104);
        *(_OWORD *)(v10 + 16) = v12;
        *(_OWORD *)(v10 + 32) = *(_OWORD *)(v10 + 136);
        *(_DWORD *)(v10 + 48) = *(_DWORD *)(v10 + 152);
        *(_OWORD *)(v10 + 52) = *(_OWORD *)(v10 + 156);
        *(void *)(v10 + 88) = *(void *)(v10 + 192);
        *(unsigned char *)(v10 + 96) = *(unsigned char *)(v10 + 200);
        uint64_t v13 = v10 + 208;
        *(_OWORD *)(v10 + 68) = *(_OWORD *)(v10 + 172);
        v10 += 104;
      }
      while (v13 != v9);
      *(void *)&this[34]._uint32_t os_unfair_lock_opaque = v11;
      if (v11 == v5) {
        break;
      }
    }
  }
  CA::WindowServer::FlipBook::collect((CA::WindowServer::FlipBook *)this);
  os_unfair_lock_unlock(v4);
}

void CA::WindowServer::FlipBook::collect(CA::WindowServer::FlipBook *this)
{
  uint64_t v1 = *((void *)this + 14);
  unint64_t v2 = 0x4EC4EC4EC4EC4EC5 * ((v1 - *((void *)this + 13)) >> 3)
     + 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*((void *)this + 17) - *((void *)this + 16)) >> 3)
     + 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*((void *)this + 11) - *((void *)this + 10)) >> 3);
  unint64_t v3 = *((void *)this + 8);
  uint64_t v4 = v2 - v3;
  if (v2 > v3)
  {
    do
    {
      if (*((void *)this + 13) == v1) {
        break;
      }
      CA::WindowServer::FlipBook::free_surface(this, (void *)(v1 - 104));
      uint64_t v1 = *((void *)this + 14) - 104;
      *((void *)this + 14) = v1;
      --v4;
    }
    while (v4);
  }
}

void CA_CFDictionarySetLongLong(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  v6[1] = *MEMORY[0x1E4F143B8];
  v6[0] = a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberLongLongType, v6);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

uint64_t CA::WindowServer::IOMFBDisplay::current_page_surface(CA::WindowServer::IOMFBDisplay *this, int a2, int a3, int a4, int a5, uint64_t a6)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = (char *)this + 25388;
  long long v12 = (pthread_mutex_t *)((char *)this + 25720);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
  unsigned int v13 = *((_DWORD *)v11 + 79);
  unint64_t v14 = (CA::Shape **)*((void *)this + 6 * v13 + 3224);
  int v15 = CA::WindowServer::IOMFBDisplay::use_assembly_surface(this);
  if (!v14)
  {
    uint64_t surface = 0;
    goto LABEL_65;
  }
  int v16 = v15;
  uint64_t v46 = a6;
  __int16 v18 = v14 + 5;
  IOSurfaceID v17 = v14[5];
  if (v17) {
    char v19 = v16;
  }
  else {
    char v19 = 1;
  }
  if ((v19 & 1) == 0)
  {
    CA::WindowServer::Surface::unref(v17);
    void *v18 = 0;
  }
  unsigned int v20 = *((_DWORD *)this + 160);
  uint64_t v49 = 0;
  int v50 = v20 & 0x3FFF;
  int v51 = (v20 >> 14) & 0x3FFF;
  unint64_t v47 = v12;
  if (v16 != a2 || BYTE13(xmmword_1EB2ACBF0))
  {
    if ((*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 80))(this)
      && *((unsigned char *)std::__hash_table<std::__hash_value_type<CA::WindowServer::Display::Mode,CA::WindowServer::IOMFBDisplay::ModeInfo>,std::__unordered_map_hasher<CA::WindowServer::Display::Mode,std::__hash_value_type<CA::WindowServer::Display::Mode,CA::WindowServer::IOMFBDisplay::ModeInfo>,CA::WindowServer::IOMFBDisplay::ModeHash,std::equal_to<CA::WindowServer::Display::Mode>,true>,std::__unordered_map_equal<CA::WindowServer::Display::Mode,std::__hash_value_type<CA::WindowServer::Display::Mode,CA::WindowServer::IOMFBDisplay::ModeInfo>,std::equal_to<CA::WindowServer::Display::Mode>,CA::WindowServer::IOMFBDisplay::ModeHash,true>,std::allocator<std::__hash_value_type<CA::WindowServer::Display::Mode,CA::WindowServer::IOMFBDisplay::ModeInfo>>>::__emplace_unique_key_args<CA::WindowServer::Display::Mode,std::piecewise_construct_t const&,std::tuple<CA::WindowServer::Display::Mode const&>,std::tuple<>>((float *)this + 6610, *((void *)this + 3388), (uint64_t *)this + 3388)+ 40))
    {
      unint64_t v21 = (CA::Shape **)&v49;
    }
    else
    {
      unint64_t v21 = (CA::Shape **)((char *)this + 152);
    }
  }
  else
  {
    unint64_t v21 = (CA::Shape **)((char *)this + 200);
  }
  int v43 = a3;
  if (a2)
  {
    int v23 = 0;
    unsigned int v45 = 0;
    uint64_t surface = (uint64_t)*v18;
    uint64_t v44 = @"CA Assembly Buffer";
  }
  else
  {
    int v23 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1544))(this);
    if (v23) {
      int v24 = 5;
    }
    else {
      int v24 = 1;
    }
    unsigned int v45 = v24;
    __int16 v18 = v14 + 4;
    uint64_t surface = (uint64_t)v14[4];
    uint64_t v44 = @"CA Framebuffer";
    if (v11[1036] == 2)
    {
      int v25 = 875704422;
      goto LABEL_23;
    }
  }
  int v25 = CA::WindowServer::IOMFBDisplay::framebuffer_pixel_format(this);
LABEL_23:
  if (a5) {
    unsigned int v26 = 1027423537;
  }
  else {
    unsigned int v26 = v25;
  }
  if ((CA::WindowServer::Display::has_hdr_clone(this) & a2) != 0) {
    uint64_t v27 = 1380411457;
  }
  else {
    uint64_t v27 = v26;
  }
  unsigned int v28 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, uint64_t, void))(*(void *)this + 2320))(this, v27, *((int *)v21 + 2));
  if (a4) {
    uint64_t v29 = 1111970369;
  }
  else {
    uint64_t v29 = v28;
  }
  if (!surface)
  {
    if (!v43)
    {
      uint64_t surface = 0;
      goto LABEL_64;
    }
LABEL_40:
    if ((*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1840))(this)) {
      unsigned int v30 = 16;
    }
    else {
      unsigned int v30 = 2;
    }
    uint64_t surface = CA::WindowServer::Display::allocate_surface((uint64_t)this, *((unsigned int *)v21 + 2), *((unsigned int *)v21 + 3), (CA::Render *)v29, 0, v30, v45, v46, (uint64_t)v44, 0);
    if (surface)
    {
      *((unsigned char *)this + 48 * v13 + 25824) &= ~0x10u;
      if (*v18) {
        CA::WindowServer::Surface::unref(*v18);
      }
      void *v18 = (CA::WindowServer::Surface *)surface;
      unint64_t v33 = v14[2];
      unint64_t v32 = v14 + 2;
      if (v33) {
        CA::shape_union(v32, v21, v31);
      }
      uint64_t v34 = *(unsigned int *)(surface + 224);
      uint64_t v35 = *(unsigned __int8 *)(surface + 228);
      *(_DWORD *)(surface + 224) = v34;
      *(unsigned char *)(surface + 228) = v35 | 2;
      if ((v45 & 1) != 0 && (a2 & 1) == 0 && (*((_WORD *)this + 328) & 0x1800) == 0 && *(_DWORD *)v11 <= 2u)
      {
        uint64_t v36 = v34 | (v35 << 32);
        if ((v36 & 0x4000000) == 0)
        {
          uint64_t v37 = v36 | 0x204000000;
          *(_DWORD *)(surface + 224) = v37;
          *(unsigned char *)(surface + 228) = BYTE4(v37);
          ++*(_DWORD *)v11;
        }
      }
      v11[1660] = 1;
      goto LABEL_55;
    }
LABEL_64:
    long long v12 = v47;
    goto LABEL_65;
  }
  if (*(_DWORD *)(surface + 56) != *((_DWORD *)v21 + 2)
    || *(_DWORD *)(surface + 60) != *((_DWORD *)v21 + 3)
    || *(_DWORD *)(surface + 64) != v29
    || v23 != (HIBYTE(*(_DWORD *)(surface + 224)) & 1)
    || (*(uint64_t (**)(uint64_t))(*(void *)surface + 216))(surface) != v46)
  {
    goto LABEL_40;
  }
LABEL_55:
  if (a2 && CA::WindowServer::Display::has_hdr_clone(this))
  {
    uint64_t v38 = 0;
  }
  else
  {
    BOOL is_hdr = CA::WindowServer::Display::Mode::is_hdr((CA::WindowServer::IOMFBDisplay *)((char *)this + 27104));
    uint64_t v38 = 0x100000000;
    if (is_hdr) {
      uint64_t v38 = 0;
    }
  }
  unint64_t v40 = (*(unsigned int *)(surface + 224) | ((unint64_t)*(unsigned __int8 *)(surface + 228) << 32)) & 0xFFFFFFFEFFFFFFFFLL | v38;
  *(_DWORD *)(surface + 224) = v40;
  *(unsigned char *)(surface + 228) = BYTE4(v40);
  long long v12 = v47;
  if ((*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1840))(this))
  {
    uint64_t v41 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1800))(this);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)surface + 96))(surface, v41, 0);
  }
  *(_OWORD *)(surface + 40) = 0u;
  *(_OWORD *)(surface + 24) = 0u;
LABEL_65:
  pthread_mutex_unlock(v12);
  return surface;
}

uint64_t CA::WindowServer::IOMFBDisplay::use_assembly_surface(CA::WindowServer::IOMFBDisplay *this)
{
  v15[1] = *MEMORY[0x1E4F143B8];
  unint64_t v2 = (char *)this + 26424;
  unint64_t v3 = (char *)this + 745;
  if (!(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 80))(this)
    || (unint64_t v4 = *((void *)this + 3306)) == 0)
  {
LABEL_18:
    LOBYTE(v9) = 0;
    goto LABEL_19;
  }
  uint64_t v5 = *((void *)this + 3388);
  uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)v4);
  v6.i16[0] = vaddlv_u8(v6);
  unint64_t v7 = v6.u32[0];
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v8 = (int)v5;
    if ((int)v5 >= v4) {
      unint64_t v8 = (int)v5 % v4;
    }
  }
  else
  {
    unint64_t v8 = (v4 - 1) & (int)v5;
  }
  uint64_t v9 = *(uint64_t ***)(*((void *)this + 3305) + 8 * v8);
  if (v9)
  {
    uint64_t v10 = *v9;
    if (*v9)
    {
      while (1)
      {
        unint64_t v11 = v10[1];
        if ((int)v5 == v11)
        {
          if (CA::WindowServer::Display::Mode::operator==(v10[2], v5))
          {
            LOBYTE(v9) = *((unsigned char *)v10 + 40) != 0;
            goto LABEL_19;
          }
        }
        else
        {
          if (v7 > 1)
          {
            if (v11 >= v4) {
              v11 %= v4;
            }
          }
          else
          {
            v11 &= v4 - 1;
          }
          if (v11 != v8) {
            goto LABEL_18;
          }
        }
        uint64_t v10 = (uint64_t *)*v10;
        if (!v10) {
          goto LABEL_18;
        }
      }
    }
    goto LABEL_18;
  }
LABEL_19:
  if ((*v3 & 4) != 0 && (HIBYTE(xmmword_1EB2ACC70) || !v2[1729])) {
    return 1;
  }
  if (*v2 == 2) {
    LOBYTE(v9) = 1;
  }
  if ((v9 & 1) != 0
    || ((*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1544))(this) & 1) != 0)
  {
    return 1;
  }
  if ((*((_DWORD *)this + 156) & 4) != 0 || (*((_DWORD *)this + 156) & 0x80) != 0)
  {
    unsigned int v13 = (void *)*((void *)this + 5);
    if (v13)
    {
      while (1)
      {
        if (*v13)
        {
          uint64_t v14 = *(void *)(*v13 + 96);
          if ((*(_WORD *)(v14 + 656) & 0x1C00) == 0x800)
          {
            v15[0] = *(void *)(v14 + 640);
            if (CA::WindowServer::Display::Mode::is_hdr((CA::WindowServer::Display::Mode *)v15)) {
              break;
            }
          }
        }
        unsigned int v13 = (void *)v13[1];
        if (!v13) {
          return 0;
        }
      }
      return 1;
    }
  }
  return 0;
}

BOOL CA::WindowServer::IOMFBDisplay::needs_passthrough(CA::WindowServer::IOMFBDisplay *this)
{
  BOOL result = CA::WindowServer::Display::Mode::is_hdr((CA::WindowServer::IOMFBDisplay *)((char *)this + 640));
  if (result) {
    return *((unsigned char *)this + 28171) == 0;
  }
  return result;
}

BOOL CA::WindowServer::Display::Mode::is_hdr(CA::WindowServer::Display::Mode *this)
{
  if (*(void *)this) {
    BOOL v1 = (*(void *)this & 0x10000000) == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (v1) {
    return ((*(void *)this >> 55) & 0x1F) - 16 < 0xD;
  }
  if (CADeviceIsVirtualized::once != -1) {
    dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
  }
  if (!CADeviceIsVirtualized::is_virtualized) {
    return 0;
  }
  uint64_t v3 = (*(void *)this >> 55) & 0x1FLL;
  return v3 == 22 || v3 == 24;
}

uint64_t CA::WindowServer::AppleDisplay::full_frame_required(CA::WindowServer::AppleDisplay *this)
{
  return HIBYTE(*((unsigned __int16 *)this + 14272)) & 1;
}

uint64_t CA::WindowServer::AppleDisplay::compressed_pixel_format(CA::WindowServer::AppleDisplay *this, CA::Render *a2, unint64_t a3)
{
  unint64_t v5 = *((void *)this + 3543);
  if (a3) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  int v8 = !v6 && v5 < a3;
  unint64_t v9 = *((void *)this + 3545);
  if (v9) {
    BOOL v10 = v9 >= CA::WindowServer::IOMFBDisplay::_compressed_display_count;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    BOOL v11 = 0;
  }
  else
  {
    if (*((unsigned char *)this + 28138))
    {
LABEL_78:
      unsigned int v12 = CA::Render::fourcc_compressed_of_type(a2, 0, 0);
      goto LABEL_79;
    }
    BOOL v11 = (*((_WORD *)this + 328) & 0x1C00) == 4096;
  }
  unsigned int v12 = 0;
  if (((v8 | v11) & 1) == 0 && (*((_WORD *)this + 14272) & 0x200) != 0)
  {
    if (CADeviceUseCompression::once[0] != -1) {
      dispatch_once(CADeviceUseCompression::once, &__block_literal_global_21);
    }
    if (!CADeviceUseCompression::enable_compression)
    {
      unsigned int v12 = 0;
      goto LABEL_72;
    }
    if (CADeviceSupportsUniversalCompression::once != -1) {
      dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
    }
    if (CADeviceSupportsUniversalCompression::universal) {
      int v13 = 3;
    }
    else {
      int v13 = 2;
    }
    if (CADeviceSupportsLossyUniversalCompression::once != -1)
    {
      int v19 = v13;
      dispatch_once(&CADeviceSupportsLossyUniversalCompression::once, &__block_literal_global_46);
      int v13 = v19;
    }
    if (!CADeviceSupportsLossyUniversalCompression::lossy)
    {
LABEL_67:
      unsigned int v12 = CA::Render::fourcc_compressed_of_type(a2, v13, 0);
      if (v12 != a2) {
        goto LABEL_72;
      }
      goto LABEL_68;
    }
    if ((int)a2 > 796161583)
    {
      if ((int)a2 <= 2084718400)
      {
        if ((int)a2 <= 796423727)
        {
          if ((a2 - 796161584) <= 4 && ((1 << ((_BYTE)a2 - 48)) & 0x15) != 0) {
            goto LABEL_68;
          }
          int v14 = -796419632;
        }
        else
        {
          if ((a2 - 796423728) <= 4 && ((1 << ((_BYTE)a2 - 48)) & 0x15) != 0
            || (a2 - 2084070960) <= 4 && ((1 << ((_BYTE)a2 - 48)) & 0x15) != 0)
          {
            goto LABEL_68;
          }
          int v14 = -2084075056;
        }
        goto LABEL_65;
      }
      if ((int)a2 > 2088265263)
      {
        if ((a2 - 2088265264) <= 4 && ((1 << ((_BYTE)a2 - 48)) & 0x15) != 0) {
          goto LABEL_68;
        }
        int v14 = -2088269360;
        goto LABEL_65;
      }
      if ((a2 - 2088003120) <= 4 && ((1 << ((_BYTE)a2 - 48)) & 0x15) != 0
        || (a2 - 2088007216) <= 4 && ((1 << ((_BYTE)a2 - 48)) & 0x15) != 0)
      {
        goto LABEL_68;
      }
      int v15 = 2084718401;
    }
    else if ((int)a2 <= 762865199)
    {
      if ((int)a2 <= 759318336)
      {
        if ((a2 - 758670896) <= 4 && ((1 << ((_BYTE)a2 - 48)) & 0x15) != 0) {
          goto LABEL_68;
        }
        int v14 = -758674992;
        goto LABEL_65;
      }
      if ((a2 - 762603056) <= 4 && ((1 << ((_BYTE)a2 - 48)) & 0x15) != 0
        || (a2 - 762607152) <= 4 && ((1 << ((_BYTE)a2 - 48)) & 0x15) != 0)
      {
        goto LABEL_68;
      }
      int v15 = 759318337;
    }
    else
    {
      if ((int)a2 <= 792229423)
      {
        if ((a2 - 762865200) <= 4 && ((1 << ((_BYTE)a2 - 48)) & 0x15) != 0
          || (a2 - 762869296) <= 4 && ((1 << ((_BYTE)a2 - 48)) & 0x15) != 0)
        {
          goto LABEL_68;
        }
        int v14 = -792225328;
LABEL_65:
        unsigned int v16 = a2 + v14;
        if (v16 > 4 || ((1 << v16) & 0x15) == 0) {
          goto LABEL_67;
        }
LABEL_68:
        if (CADeviceSupportsUniversalCompression::once != -1) {
          dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
        }
        unsigned int v12 = a2;
        if (!CADeviceSupportsUniversalCompression::universal) {
          unsigned int v12 = CA::Render::fourcc_compressed_of_type(a2, 1, 0);
        }
        goto LABEL_72;
      }
      if ((a2 - 792229424) <= 4 && ((1 << ((_BYTE)a2 - 48)) & 0x15) != 0
        || (a2 - 796157488) <= 4 && ((1 << ((_BYTE)a2 - 48)) & 0x15) != 0)
      {
        goto LABEL_68;
      }
      int v15 = 792872769;
    }
    if (a2 != v15) {
      goto LABEL_67;
    }
    goto LABEL_68;
  }
LABEL_72:
  if (BYTE1(xmmword_1EB2ACC10)) {
    int v17 = 1;
  }
  else {
    int v17 = v8;
  }
  if (((v17 | v11) & 1) != 0
    || (*((_WORD *)this + 328) & 0x1C00) == 0x1000
    || (*(unsigned int (**)(CA::WindowServer::AppleDisplay *))(*(void *)this + 1608))(this))
  {
    goto LABEL_78;
  }
LABEL_79:
  if (v12) {
    return v12;
  }
  else {
    return a2;
  }
}

uint64_t CA::Render::fourcc_compressed_of_type(CA::Render *this, int a2, int a3)
{
  switch(a2)
  {
    case 0:
      uint64_t v3 = 1111970369;
      if ((int)this > 762865203)
      {
        if ((int)this <= 1534354993)
        {
          if ((int)this > 796161585)
          {
            if ((int)this > 796423731)
            {
              if ((int)this > 1530426927)
              {
                if ((int)this > 1530426931)
                {
                  if (this != 1530426932)
                  {
                    uint64_t v3 = (uint64_t)this;
                    if (this == 1534354992) {
                      return 1952854576;
                    }
                    return v3;
                  }
                  goto LABEL_661;
                }
                if (this != 1530426928)
                {
                  int v6 = 1530426930;
LABEL_372:
                  uint64_t v3 = (uint64_t)this;
                  if (this != v6) {
                    return v3;
                  }
                  return 875704950;
                }
LABEL_654:
                int v63 = 875704422;
                return v63 | 0x10u;
              }
              if ((int)this <= 1530422833)
              {
                if (this != 796423732)
                {
                  int v19 = 1530422832;
                  goto LABEL_276;
                }
LABEL_671:
                int v60 = 1882468912;
                return (v60 + 516);
              }
              if (this == 1530422834) {
                goto LABEL_618;
              }
              int v53 = 1530422836;
LABEL_616:
              uint64_t v3 = (uint64_t)this;
              if (this != v53) {
                return v3;
              }
              return 875836518;
            }
            if ((int)this <= 796419633)
            {
              if (this == 796161586) {
                goto LABEL_541;
              }
              if (this == 796161588) {
                goto LABEL_543;
              }
              uint64_t v3 = (uint64_t)this;
              if (this != 796419632) {
                return v3;
              }
              return 1885745712;
            }
            if ((int)this <= 796423727)
            {
              if (this == 796419634) {
                return 1885745714;
              }
              uint64_t v3 = (uint64_t)this;
              if (this != 796419636) {
                return v3;
              }
              goto LABEL_524;
            }
            if (this != 796423728)
            {
              int v54 = 796423730;
LABEL_631:
              uint64_t v3 = (uint64_t)this;
              if (this != v54) {
                return v3;
              }
              goto LABEL_672;
            }
          }
          else
          {
            if ((int)this > 792229423)
            {
              if ((int)this <= 796157487)
              {
                if ((int)this > 792229427)
                {
                  if (this != 792229428)
                  {
                    int v22 = 792872769;
                    goto LABEL_636;
                  }
                  goto LABEL_661;
                }
                if (this != 792229424)
                {
                  int v6 = 792229426;
                  goto LABEL_372;
                }
                goto LABEL_654;
              }
              if ((int)this <= 796157491)
              {
                if (this == 796157488) {
                  goto LABEL_384;
                }
                int v17 = 796157490;
                goto LABEL_357;
              }
              if (this != 796157492)
              {
                int v61 = 796161584;
                goto LABEL_645;
              }
              goto LABEL_648;
            }
            if ((int)this > 762869299)
            {
              if ((int)this <= 792225329)
              {
                if (this != 762869300)
                {
                  int v19 = 792225328;
LABEL_276:
                  uint64_t v3 = (uint64_t)this;
                  if (this != v19) {
                    return v3;
                  }
                  return 875704422;
                }
                goto LABEL_671;
              }
              if (this == 792225330) {
                goto LABEL_618;
              }
              int v53 = 792225332;
              goto LABEL_616;
            }
            if (this == 762865204) {
              goto LABEL_524;
            }
            if (this != 762869296)
            {
              int v54 = 762869298;
              goto LABEL_631;
            }
          }
          return 1882468912;
        }
        if ((int)this > 2084075057)
        {
          if ((int)this > 2088007217)
          {
            if ((int)this > 2088265267)
            {
              if ((int)this <= 2088269361)
              {
                if (this != 2088265268)
                {
                  int v42 = 2088269360;
LABEL_382:
                  uint64_t v3 = (uint64_t)this;
                  if (this != v42) {
                    return v3;
                  }
                  return 1882468912;
                }
LABEL_524:
                int v36 = 1885745714;
                return (v36 + 514);
              }
              if (this != 2088269362)
              {
                int v62 = 2088269364;
LABEL_670:
                uint64_t v3 = (uint64_t)this;
                if (this != v62) {
                  return v3;
                }
                goto LABEL_671;
              }
LABEL_672:
              int v23 = 1882468912;
              return v23 | 2u;
            }
            if ((int)this <= 2088265263)
            {
              if (this != 2088007218)
              {
                int v20 = 2088007220;
                goto LABEL_377;
              }
              goto LABEL_541;
            }
            if (this == 2088265264) {
              return 1885745712;
            }
            int v59 = 2088265266;
            goto LABEL_665;
          }
          if ((int)this <= 2088003119)
          {
            if (this == 2084075058) {
              return 875704950;
            }
            if (this != 2084075060)
            {
              int v22 = 2084718401;
              goto LABEL_636;
            }
            goto LABEL_661;
          }
          if ((int)this <= 2088003123)
          {
            if (this == 2088003120) {
              goto LABEL_384;
            }
            int v17 = 2088003122;
LABEL_357:
            uint64_t v3 = (uint64_t)this;
            if (this == v17)
            {
              int v23 = 1886676528;
              return v23 | 2u;
            }
            return v3;
          }
          if (this != 2088003124)
          {
            int v61 = 2088007216;
            goto LABEL_645;
          }
LABEL_648:
          int v8 = 1886676528;
          return v8 | 4u;
        }
        if ((int)this > 1534617139)
        {
          if ((int)this <= 2084070959)
          {
            if ((int)this > 1534621233)
            {
              if (this == 1534621234)
              {
                int v23 = 2016686640;
                return v23 | 2u;
              }
              uint64_t v3 = (uint64_t)this;
              if (this != 1534621236) {
                return v3;
              }
              int v60 = 2016686640;
              return (v60 + 516);
            }
            if (this == 1534617140)
            {
              int v60 = 2019963440;
              return (v60 + 516);
            }
            uint64_t v3 = (uint64_t)this;
            if (this != 1534621232) {
              return v3;
            }
            unsigned __int16 v12 = 12848;
            return v12 | 0x78340000u;
          }
          if ((int)this > 2084070963)
          {
            if (this == 2084070964) {
              return 875836518;
            }
            uint64_t v3 = (uint64_t)this;
            if (this != 2084075056) {
              return v3;
            }
            goto LABEL_654;
          }
          if (this == 2084070960) {
            return 875704422;
          }
          uint64_t v3 = (uint64_t)this;
          if (this != 2084070962) {
            return v3;
          }
          goto LABEL_618;
        }
        if ((int)this <= 1534359089)
        {
          if (this == 1534354994)
          {
            int v23 = 1952854576;
            return v23 | 2u;
          }
          if (this != 1534354996)
          {
            uint64_t v3 = (uint64_t)this;
            if (this != 1534359088) {
              return v3;
            }
            int v55 = 1952854576;
            return v55 | 0x100000u;
          }
          int v60 = 1952854576;
          return (v60 + 516);
        }
        if ((int)this <= 1534617135)
        {
          if (this == 1534359090) {
            return 1953903154;
          }
          uint64_t v3 = (uint64_t)this;
          if (this != 1534359092) {
            return v3;
          }
          int v36 = 1953903154;
          return (v36 + 514);
        }
        if (this == 1534617136) {
          return 2019963440;
        }
        uint64_t v3 = (uint64_t)this;
        if (this != 1534617138) {
          return v3;
        }
        int v23 = 2019963440;
        return v23 | 2u;
      }
      if ((int)this > 645280823)
      {
        if ((int)this <= 758670895)
        {
          if ((int)this <= 645411895)
          {
            if ((int)this <= 645410871)
            {
              if (this == 645280824)
              {
                int v41 = 1982882104;
                return v41 | 0x40000u;
              }
              if (this == 645346162) {
                return 1999843442;
              }
              uint64_t v3 = (uint64_t)this;
              if (this == 645346401) {
                return 1999908961;
              }
              return v3;
            }
            if ((int)this > 645411383)
            {
              if (this == 645411384)
              {
                int v64 = 2016436536;
                return v64 | 0x20000u;
              }
              uint64_t v3 = (uint64_t)this;
              if (this == 645411443) {
                return 2016567667;
              }
              return v3;
            }
            if (this == 645410872) {
              return 2016436536;
            }
            uint64_t v3 = (uint64_t)this;
            if (this != 645410931) {
              return v3;
            }
            int v11 = 2016436536;
            return (v11 + 59);
          }
          if ((int)this <= 645424691)
          {
            if ((int)this <= 645424687)
            {
              if (this != 645411896)
              {
                uint64_t v3 = (uint64_t)this;
                if (this != 645411955) {
                  return v3;
                }
                int v11 = 2016698680;
                return (v11 + 59);
              }
              unsigned __int16 v12 = 24888;
              return v12 | 0x78340000u;
            }
            if (this != 645424688)
            {
              int v59 = 645424690;
              goto LABEL_665;
            }
            return 1885745712;
          }
          if ((int)this <= 645428785)
          {
            if (this != 645424692)
            {
              int v42 = 645428784;
              goto LABEL_382;
            }
            goto LABEL_524;
          }
          if (this != 645428786)
          {
            int v62 = 645428788;
            goto LABEL_670;
          }
          goto LABEL_672;
        }
        if ((int)this > 762603055)
        {
          if ((int)this <= 762607153)
          {
            if ((int)this > 762603059)
            {
              if (this != 762603060)
              {
                int v61 = 762607152;
                goto LABEL_645;
              }
              goto LABEL_648;
            }
            if (this != 762603056)
            {
              int v17 = 762603058;
              goto LABEL_357;
            }
LABEL_384:
            unsigned __int16 v43 = 26160;
            return v43 | 0x70740000u;
          }
          if ((int)this <= 762865199)
          {
            if (this != 762607154)
            {
              int v20 = 762607156;
LABEL_377:
              uint64_t v3 = (uint64_t)this;
              if (this != v20) {
                return v3;
              }
LABEL_543:
              int v34 = 1886680626;
              return (v34 + 2);
            }
LABEL_541:
            unsigned __int16 v43 = 30258;
            return v43 | 0x70740000u;
          }
          if (this == 762865200) {
            return 1885745712;
          }
          int v59 = 762865202;
LABEL_665:
          uint64_t v3 = (uint64_t)this;
          if (this != v59) {
            return v3;
          }
          return 1885745714;
        }
        if ((int)this > 758674991)
        {
          if ((int)this > 758674995)
          {
            if (this != 758674996)
            {
              int v22 = 759318337;
LABEL_636:
              if (this == v22) {
                return v3;
              }
              return (uint64_t)this;
            }
LABEL_661:
            int v63 = 875836518;
            return v63 | 0x10u;
          }
          if (this != 758674992)
          {
            int v6 = 758674994;
            goto LABEL_372;
          }
          goto LABEL_654;
        }
        if (this == 758670896) {
          return 875704422;
        }
        if (this != 758670898)
        {
          int v53 = 758670900;
          goto LABEL_616;
        }
LABEL_618:
        int v52 = 875704422;
        return v52 | 0x200u;
      }
      if ((int)this > 645097011)
      {
        if ((int)this > 645162543)
        {
          if ((int)this <= 645166641)
          {
            if ((int)this <= 645162547)
            {
              if (this != 645162544)
              {
                int v17 = 645162546;
                goto LABEL_357;
              }
              goto LABEL_384;
            }
            if (this != 645162548)
            {
              int v61 = 645166640;
LABEL_645:
              uint64_t v3 = (uint64_t)this;
              if (this != v61) {
                return v3;
              }
              int v39 = 1886676528;
              return v39 | 0x1000u;
            }
            goto LABEL_648;
          }
          if ((int)this > 645279799)
          {
            if (this == 645279800) {
              return 1982882104;
            }
            uint64_t v3 = (uint64_t)this;
            if (this == 645280312)
            {
              int v64 = 1982882104;
              return v64 | 0x20000u;
            }
            return v3;
          }
          if (this != 645166642)
          {
            int v20 = 645166644;
            goto LABEL_377;
          }
          goto LABEL_541;
        }
        if ((int)this > 645101107)
        {
          if ((int)this > 645149298)
          {
            if (this != 645149299)
            {
              uint64_t v3 = (uint64_t)this;
              if (this != 645149811) {
                return v3;
              }
              int v41 = 1949327731;
              return v41 | 0x40000u;
            }
            int v64 = 1949327731;
            return v64 | 0x20000u;
          }
          if (this != 645101108)
          {
            uint64_t v3 = (uint64_t)this;
            if (this == 645148787) {
              return 1949327731;
            }
            return v3;
          }
          int v36 = 1937125938;
          return (v36 + 514);
        }
        if (this != 645097012)
        {
          if (this != 645101104)
          {
            uint64_t v3 = (uint64_t)this;
            if (this == 645101106) {
              return 1937125938;
            }
            return v3;
          }
          int v55 = 1936077360;
          return v55 | 0x100000u;
        }
        int v60 = 1936077360;
        return (v60 + 516);
      }
      if ((int)this <= 642934848)
      {
        if ((int)this > 641234479)
        {
          if ((int)this <= 641234483)
          {
            if (this != 641234480)
            {
              int v6 = 641234482;
              goto LABEL_372;
            }
            goto LABEL_654;
          }
          if (this != 641234484)
          {
            int v22 = 641877825;
            goto LABEL_636;
          }
          goto LABEL_661;
        }
        if (this != 641230384)
        {
          if (this != 641230386)
          {
            int v53 = 641230388;
            goto LABEL_616;
          }
          goto LABEL_618;
        }
        return 875704422;
      }
      if ((int)this <= 645083762)
      {
        if ((int)this > 644624753)
        {
          if (this == 644624754)
          {
            return 1815162994;
          }
          else
          {
            uint64_t v3 = (uint64_t)this;
            if (this == 645083251) {
              return 1932550515;
            }
          }
        }
        else if (this == 642934849)
        {
          return 1380411457;
        }
        else
        {
          uint64_t v3 = (uint64_t)this;
          if (this == 643969848) {
            return 1647534392;
          }
        }
        return v3;
      }
      if ((int)this <= 645097007)
      {
        if (this != 645083763)
        {
          uint64_t v3 = (uint64_t)this;
          if (this != 645084275) {
            return v3;
          }
          int v41 = 1932550515;
          return v41 | 0x40000u;
        }
        int v64 = 1932550515;
        return v64 | 0x20000u;
      }
      if (this == 645097008) {
        return 1936077360;
      }
      uint64_t v3 = (uint64_t)this;
      if (this == 645097010)
      {
        int v23 = 1936077360;
        return v23 | 2u;
      }
      return v3;
    case 1:
      if ((int)this <= 1534617135)
      {
        uint64_t v3 = 1530426928;
        if ((int)this <= 1530426927)
        {
          if ((int)this > 875836517)
          {
            if ((int)this > 1530422831)
            {
              if (this != 1530422832)
              {
                if (this != 1530422834)
                {
                  if (this != 1530422836) {
                    return (uint64_t)this;
                  }
                  return 1530422836;
                }
                return 1530422834;
              }
              return 1530422832;
            }
            if (this == 875836518) {
              return 1530422836;
            }
            if (this != 875836534) {
              return (uint64_t)this;
            }
            goto LABEL_343;
          }
          if ((int)this <= 875704933)
          {
            if (this != 875704422)
            {
              int v22 = 875704438;
              goto LABEL_636;
            }
            return 1530422832;
          }
          if (this == 875704934) {
            return 1530422834;
          }
          int v24 = 875704950;
LABEL_322:
          if (this == v24) {
            return 1530426930;
          }
          return (uint64_t)this;
        }
        if ((int)this > 1534354993)
        {
          if ((int)this > 1534359087)
          {
            if (this != 1534359088)
            {
              if (this != 1534359090)
              {
                if (this != 1534359092) {
                  return (uint64_t)this;
                }
                goto LABEL_344;
              }
              goto LABEL_196;
            }
            goto LABEL_336;
          }
          if (this != 1534354994)
          {
            int v7 = 1534354996;
            goto LABEL_314;
          }
          goto LABEL_338;
        }
        if ((int)this <= 1530426931)
        {
          if (this == 1530426928) {
            return v3;
          }
          int v24 = 1530426930;
          goto LABEL_322;
        }
        if (this == 1530426932)
        {
LABEL_343:
          int v34 = 1530426930;
          return (v34 + 2);
        }
        if (this != 1534354992) {
          return (uint64_t)this;
        }
        goto LABEL_328;
      }
      if ((int)this > 1953903151)
      {
        if ((int)this <= 2016686641)
        {
          if ((int)this <= 1953903667)
          {
            if (this != 1953903152)
            {
              if (this != 1953903154) {
                return (uint64_t)this;
              }
LABEL_196:
              unsigned __int16 v25 = 30258;
              return v25 | 0x5B740000u;
            }
LABEL_336:
            int v39 = 1534354992;
            return v39 | 0x1000u;
          }
          if (this == 1953903668)
          {
LABEL_344:
            int v34 = 1534359090;
            return (v34 + 2);
          }
          int v38 = 2016686640;
LABEL_332:
          if (this == v38)
          {
            int v39 = 1534617136;
            return v39 | 0x1000u;
          }
          return (uint64_t)this;
        }
        if ((int)this <= 2019963439)
        {
          if (this != 2016686642)
          {
            int v37 = 2016687156;
            goto LABEL_318;
          }
          goto LABEL_339;
        }
        if (this == 2019963440) {
          goto LABEL_335;
        }
        if (this == 2019963442)
        {
LABEL_189:
          int v23 = 1534617136;
          return v23 | 2u;
        }
        if (this != 2019963956) {
          return (uint64_t)this;
        }
      }
      else
      {
        if ((int)this > 1534621233)
        {
          if ((int)this > 1952854575)
          {
            if (this != 1952854576)
            {
              if (this != 1952854578)
              {
                int v7 = 1952855092;
LABEL_314:
                if (this != v7) {
                  return (uint64_t)this;
                }
                int v8 = 1534354992;
                return v8 | 4u;
              }
LABEL_338:
              int v23 = 1534354992;
              return v23 | 2u;
            }
LABEL_328:
            unsigned __int16 v25 = 26160;
            return v25 | 0x5B740000u;
          }
          if (this != 1534621234)
          {
            int v37 = 1534621236;
LABEL_318:
            if (this != v37) {
              return (uint64_t)this;
            }
            int v34 = 1534621234;
            return (v34 + 2);
          }
LABEL_339:
          unsigned __int16 v40 = 30258;
          return v40 | 0x5B780000u;
        }
        if ((int)this <= 1534617139)
        {
          if (this != 1534617136)
          {
            if (this != 1534617138) {
              return (uint64_t)this;
            }
            goto LABEL_189;
          }
LABEL_335:
          unsigned __int16 v40 = 26160;
          return v40 | 0x5B780000u;
        }
        if (this != 1534617140)
        {
          int v38 = 1534621232;
          goto LABEL_332;
        }
      }
      int v8 = 1534617136;
      return v8 | 4u;
    case 2:
      return CA::Render::get_compressed_agx_universal_rgb_fourcc(this);
    case 3:
      uint64_t v3 = 643969848;
      this = (CA::Render *)CA::Render::get_compressed_agx_universal_rgb_fourcc(this);
      if ((int)this > 875704421)
      {
        if ((int)this > 1932681586)
        {
          if ((int)this <= 1949589874)
          {
            if ((int)this <= 1937125935)
            {
              if ((int)this <= 1936077359)
              {
                if (this != 1932681587)
                {
                  int v30 = 1932812659;
                  goto LABEL_481;
                }
                goto LABEL_565;
              }
              if (this != 1936077360)
              {
                if (this != 1936077362)
                {
                  if (this != 1936077876) {
                    return (uint64_t)this;
                  }
                  goto LABEL_552;
                }
LABEL_485:
                int v23 = 645097008;
                return v23 | 2u;
              }
LABEL_566:
              unsigned __int16 v33 = 26160;
              return v33 | 0x26730000u;
            }
            if ((int)this <= 1937126451)
            {
              if (this != 1937125936)
              {
                int v18 = 1937125938;
                goto LABEL_504;
              }
LABEL_573:
              int v39 = 645097008;
              return v39 | 0x1000u;
            }
            if (this != 1937126452)
            {
              if (this != 1949327731)
              {
                if (this != 1949458803) {
                  return (uint64_t)this;
                }
LABEL_555:
                int v52 = 645148787;
                return v52 | 0x200u;
              }
LABEL_508:
              unsigned __int16 v32 = 12403;
              return v32 | 0x26740000u;
            }
LABEL_574:
            int v34 = 645101106;
            return (v34 + 2);
          }
          if ((int)this <= 2016436594)
          {
            if ((int)this > 1983013175)
            {
              if (this != 1983013176)
              {
                if (this != 1983144248)
                {
                  if (this != 2016436536) {
                    return (uint64_t)this;
                  }
                  return 645410872;
                }
LABEL_553:
                int v35 = 645279800;
                return v35 | 0x400u;
              }
              goto LABEL_501;
            }
            if (this == 1949589875) {
              goto LABEL_569;
            }
            if (this != 1982882104) {
              return (uint64_t)this;
            }
            return 645279800;
          }
          if ((int)this > 2016567666)
          {
            if (this != 2016567667)
            {
              if (this != 2016698680)
              {
                if (this != 2016698739) {
                  return (uint64_t)this;
                }
                goto LABEL_267;
              }
              return 645411896;
            }
LABEL_491:
            int v52 = 645410931;
            return v52 | 0x200u;
          }
          if (this == 2016436595)
          {
LABEL_578:
            unsigned __int16 v57 = 12403;
            return v57 | 0x26780000u;
          }
          if (this != 2016567608) {
            return (uint64_t)this;
          }
          return 645411384;
        }
        if ((int)this <= 1885745711)
        {
          if ((int)this <= 875836533)
          {
            if ((int)this > 875704933)
            {
              if (this != 875704934)
              {
                if (this == 875704950)
                {
LABEL_551:
                  unsigned __int16 v56 = 30258;
                  return v56 | 0x26380000u;
                }
                if (this != 875836518) {
                  return (uint64_t)this;
                }
                goto LABEL_60;
              }
LABEL_472:
              int v23 = 641230384;
              return v23 | 2u;
            }
            if (this != 875704422)
            {
              if (this != 875704438) {
                return (uint64_t)this;
              }
              goto LABEL_475;
            }
LABEL_562:
            unsigned __int16 v56 = 26160;
            return v56 | 0x26380000u;
          }
          if ((int)this <= 1882468911)
          {
            if (this != 875836534)
            {
              int v22 = 1647534392;
              goto LABEL_636;
            }
            goto LABEL_571;
          }
          if (this != 1882468912)
          {
            if (this != 1882468914)
            {
              int v31 = 1882469428;
LABEL_261:
              if (this != v31) {
                return (uint64_t)this;
              }
              int v34 = 645428786;
              return (v34 + 2);
            }
LABEL_560:
            unsigned __int16 v57 = 30258;
            return v57 | 0x26780000u;
          }
LABEL_559:
          int v39 = 645424688;
          return v39 | 0x1000u;
        }
        if ((int)this > 1886676531)
        {
          if ((int)this > 1886680625)
          {
            if (this != 1886680626)
            {
              if (this != 1886680628)
              {
                if (this != 1932550515) {
                  return (uint64_t)this;
                }
LABEL_256:
                unsigned __int16 v33 = 12403;
                return v33 | 0x26730000u;
              }
LABEL_558:
              int v34 = 645166642;
              return (v34 + 2);
            }
LABEL_556:
            unsigned __int16 v32 = 30258;
            return v32 | 0x26740000u;
          }
          if (this != 1886676532)
          {
            if (this != 1886680624) {
              return (uint64_t)this;
            }
            goto LABEL_511;
          }
LABEL_576:
          int v8 = 645162544;
          return v8 | 4u;
        }
        if ((int)this > 1885746227)
        {
          if (this != 1885746228)
          {
            if (this == 1886676528)
            {
LABEL_251:
              unsigned __int16 v32 = 26160;
              return v32 | 0x26740000u;
            }
            if (this != 1886676530) {
              return (uint64_t)this;
            }
            goto LABEL_564;
          }
LABEL_514:
          int v8 = 645424688;
          return v8 | 4u;
        }
        if (this == 1885745712)
        {
LABEL_568:
          unsigned __int16 v57 = 26160;
          return v57 | 0x26780000u;
        }
        if (this != 1885745714) {
          return (uint64_t)this;
        }
      }
      else
      {
        if ((int)this <= 645162545)
        {
          if ((int)this <= 645097007)
          {
            if ((int)this <= 641234483)
            {
              if ((int)this > 641230387)
              {
                if (this != 641230388)
                {
                  if (this != 641234480)
                  {
                    if (this != 641234482) {
                      return (uint64_t)this;
                    }
                    goto LABEL_551;
                  }
LABEL_475:
                  int v39 = 641230384;
                  return v39 | 0x1000u;
                }
LABEL_60:
                int v8 = 641230384;
                return v8 | 4u;
              }
              if (this != 641230384)
              {
                if (this != 641230386) {
                  return (uint64_t)this;
                }
                goto LABEL_472;
              }
              goto LABEL_562;
            }
            if ((int)this > 645083250)
            {
              if (this != 645083251)
              {
                if (this != 645083763)
                {
                  int v30 = 645084275;
LABEL_481:
                  if (this != v30) {
                    return (uint64_t)this;
                  }
                  int v35 = 645083251;
                  return v35 | 0x400u;
                }
LABEL_565:
                int v52 = 645083251;
                return v52 | 0x200u;
              }
              goto LABEL_256;
            }
            if (this != 641234484)
            {
              int v22 = 643969848;
              goto LABEL_636;
            }
LABEL_571:
            int v34 = 641234482;
            return (v34 + 2);
          }
          if ((int)this <= 645101107)
          {
            if ((int)this > 645097011)
            {
              if (this != 645097012)
              {
                if (this != 645101104)
                {
                  int v18 = 645101106;
LABEL_504:
                  if (this != v18) {
                    return (uint64_t)this;
                  }
                  unsigned __int16 v33 = 30258;
                  return v33 | 0x26730000u;
                }
                goto LABEL_573;
              }
LABEL_552:
              int v8 = 645097008;
              return v8 | 4u;
            }
            if (this != 645097008)
            {
              if (this != 645097010) {
                return (uint64_t)this;
              }
              goto LABEL_485;
            }
            goto LABEL_566;
          }
          if ((int)this > 645149298)
          {
            if (this != 645149299)
            {
              if (this != 645149811)
              {
                if (this != 645162544) {
                  return (uint64_t)this;
                }
                goto LABEL_251;
              }
LABEL_569:
              int v35 = 645148787;
              return v35 | 0x400u;
            }
            goto LABEL_555;
          }
          if (this != 645101108)
          {
            if (this != 645148787) {
              return (uint64_t)this;
            }
            goto LABEL_508;
          }
          goto LABEL_574;
        }
        if ((int)this <= 645411383)
        {
          if ((int)this <= 645279799)
          {
            if ((int)this > 645166639)
            {
              if (this != 645166640)
              {
                if (this != 645166642)
                {
                  if (this != 645166644) {
                    return (uint64_t)this;
                  }
                  goto LABEL_558;
                }
                goto LABEL_556;
              }
LABEL_511:
              int v39 = 645162544;
              return v39 | 0x1000u;
            }
            if (this != 645162546)
            {
              if (this != 645162548) {
                return (uint64_t)this;
              }
              goto LABEL_576;
            }
LABEL_564:
            int v23 = 645162544;
            return v23 | 2u;
          }
          if ((int)this > 645280823)
          {
            if (this != 645280824)
            {
              if (this != 645410872)
              {
                if (this != 645410931) {
                  return (uint64_t)this;
                }
                goto LABEL_578;
              }
              return 645410872;
            }
            goto LABEL_553;
          }
          if (this != 645279800)
          {
            if (this != 645280312) {
              return (uint64_t)this;
            }
LABEL_501:
            int v52 = 645279800;
            return v52 | 0x200u;
          }
          return 645279800;
        }
        if ((int)this <= 645424689)
        {
          if ((int)this > 645411895)
          {
            if (this != 645411896)
            {
              if (this != 645411955)
              {
                if (this != 645424688) {
                  return (uint64_t)this;
                }
                goto LABEL_568;
              }
LABEL_267:
              int v35 = 645410931;
              return v35 | 0x400u;
            }
            return 645411896;
          }
          if (this != 645411384)
          {
            if (this != 645411443) {
              return (uint64_t)this;
            }
            goto LABEL_491;
          }
          return 645411384;
        }
        if ((int)this > 645428783)
        {
          if (this != 645428784)
          {
            if (this != 645428786)
            {
              int v31 = 645428788;
              goto LABEL_261;
            }
            goto LABEL_560;
          }
          goto LABEL_559;
        }
        if (this != 645424690)
        {
          if (this != 645424692) {
            return (uint64_t)this;
          }
          goto LABEL_514;
        }
      }
      int v23 = 645424688;
      return v23 | 2u;
    case 4:
      uint64_t v5 = 759318337;
      if ((int)this > 796157491)
      {
        if ((int)this <= 1886676529)
        {
          if ((int)this <= 875704933)
          {
            if ((int)this <= 796419635)
            {
              if ((int)this <= 796161587)
              {
                if (this != 796157492)
                {
                  if (this != 796161584)
                  {
                    uint64_t v3 = (uint64_t)this;
                    if (this != 796161586) {
                      return v3;
                    }
                    goto LABEL_417;
                  }
                  goto LABEL_422;
                }
                goto LABEL_423;
              }
              if (this != 796161588)
              {
                if (this != 796419632)
                {
                  uint64_t v3 = (uint64_t)this;
                  if (this != 796419634) {
                    return v3;
                  }
                  goto LABEL_451;
                }
                goto LABEL_432;
              }
              goto LABEL_416;
            }
            if ((int)this <= 796423731)
            {
              if (this != 796419636)
              {
                if (this != 796423728)
                {
                  uint64_t v3 = (uint64_t)this;
                  if (this != 796423730) {
                    return v3;
                  }
                  goto LABEL_468;
                }
LABEL_466:
                int v47 = 762865200;
                goto LABEL_467;
              }
LABEL_452:
              int v48 = 762865200;
              goto LABEL_453;
            }
            if (this != 796423732)
            {
              if (this != 875704422)
              {
                int v27 = 875704438;
                goto LABEL_443;
              }
              goto LABEL_584;
            }
LABEL_464:
            int v45 = 762869298;
            goto LABEL_465;
          }
          if ((int)this <= 1882468913)
          {
            if ((int)this <= 875836533)
            {
              if (this != 875704934)
              {
                if (this != 875704950)
                {
                  int v14 = 875836518;
                  goto LABEL_410;
                }
LABEL_438:
                unsigned __int16 v50 = 30258;
LABEL_585:
                uint64_t v5 = v50 | 0x2D380000u;
                goto LABEL_586;
              }
LABEL_582:
              int v51 = 758670896;
              goto LABEL_583;
            }
            if (this != 875836534)
            {
              if (this == 1111970369) {
                goto LABEL_586;
              }
              int v44 = 1882468912;
              goto LABEL_405;
            }
LABEL_439:
            int v45 = 758674994;
            goto LABEL_465;
          }
          if ((int)this <= 1885745713)
          {
            if (this != 1882468914)
            {
              if (this == 1882469428) {
                goto LABEL_464;
              }
              int v13 = 1885745712;
              goto LABEL_218;
            }
LABEL_468:
            unsigned __int16 v49 = 30258;
            goto LABEL_469;
          }
          if (this != 1885745714)
          {
            if (this == 1885746228) {
              goto LABEL_452;
            }
            int v21 = 1886676528;
LABEL_449:
            uint64_t v3 = (uint64_t)this;
            if (this != v21) {
              return v3;
            }
            goto LABEL_458;
          }
LABEL_451:
          int v51 = 762865200;
LABEL_583:
          uint64_t v5 = v51 | 2u;
          goto LABEL_586;
        }
        if ((int)this <= 2088003119)
        {
          if ((int)this <= 2084070961)
          {
            if ((int)this <= 1886680625)
            {
              if (this != 1886676530)
              {
                if (this != 1886676532)
                {
                  int v10 = 1886680624;
                  goto LABEL_421;
                }
                goto LABEL_423;
              }
              goto LABEL_457;
            }
            if (this != 1886680626)
            {
              if (this != 1886680628)
              {
                int v28 = 2084070960;
LABEL_397:
                uint64_t v3 = (uint64_t)this;
                if (this != v28) {
                  return v3;
                }
                goto LABEL_584;
              }
LABEL_416:
              int v45 = 762607154;
LABEL_465:
              uint64_t v5 = (v45 + 2);
              goto LABEL_586;
            }
            goto LABEL_417;
          }
          if ((int)this <= 2084075057)
          {
            if (this == 2084070962) {
              goto LABEL_582;
            }
            if (this != 2084070964)
            {
              int v27 = 2084075056;
              goto LABEL_443;
            }
            goto LABEL_445;
          }
          if (this == 2084075058) {
            goto LABEL_438;
          }
          if (this == 2084075060) {
            goto LABEL_439;
          }
          int v9 = 2084718401;
LABEL_436:
          uint64_t v3 = (uint64_t)this;
          if (this != v9) {
            return v3;
          }
          goto LABEL_586;
        }
        if ((int)this <= 2088265263)
        {
          if ((int)this <= 2088007215)
          {
            if (this != 2088003120)
            {
              if (this == 2088003122) {
                goto LABEL_457;
              }
              int v16 = 2088003124;
LABEL_392:
              uint64_t v3 = (uint64_t)this;
              if (this != v16) {
                return v3;
              }
              goto LABEL_423;
            }
            goto LABEL_458;
          }
          if (this != 2088007216)
          {
            if (this == 2088007218) {
              goto LABEL_417;
            }
            int v26 = 2088007220;
            goto LABEL_415;
          }
          goto LABEL_422;
        }
        if ((int)this <= 2088269359)
        {
          if (this != 2088265264)
          {
            if (this == 2088265266) {
              goto LABEL_451;
            }
            int v29 = 2088265268;
LABEL_430:
            uint64_t v3 = (uint64_t)this;
            if (this != v29) {
              return v3;
            }
            goto LABEL_452;
          }
          goto LABEL_432;
        }
        if (this == 2088269360) {
          goto LABEL_466;
        }
        if (this == 2088269362) {
          goto LABEL_468;
        }
        int v15 = 2088269364;
LABEL_463:
        uint64_t v3 = (uint64_t)this;
        if (this != v15) {
          return v3;
        }
        goto LABEL_464;
      }
      if ((int)this <= 758674993)
      {
        if ((int)this > 645166641)
        {
          if ((int)this <= 645428785)
          {
            if ((int)this > 645424689)
            {
              if (this != 645424690)
              {
                if (this == 645424692) {
                  goto LABEL_452;
                }
                int v44 = 645428784;
LABEL_405:
                uint64_t v3 = (uint64_t)this;
                if (this != v44) {
                  return v3;
                }
                goto LABEL_466;
              }
              goto LABEL_451;
            }
            if (this != 645166642)
            {
              if (this != 645166644)
              {
                int v13 = 645424688;
LABEL_218:
                uint64_t v3 = (uint64_t)this;
                if (this != v13) {
                  return v3;
                }
                goto LABEL_432;
              }
              goto LABEL_416;
            }
LABEL_417:
            unsigned __int16 v46 = 30258;
LABEL_459:
            uint64_t v5 = v46 | 0x2D740000u;
            goto LABEL_586;
          }
          if ((int)this <= 758670897)
          {
            if (this == 645428786) {
              goto LABEL_468;
            }
            if (this == 645428788) {
              goto LABEL_464;
            }
            int v28 = 758670896;
            goto LABEL_397;
          }
          if (this == 758670898) {
            goto LABEL_582;
          }
          if (this != 758670900)
          {
            int v27 = 758674992;
LABEL_443:
            uint64_t v3 = (uint64_t)this;
            if (this != v27) {
              return v3;
            }
            goto LABEL_444;
          }
LABEL_445:
          int v48 = 758670896;
          goto LABEL_453;
        }
        if ((int)this > 641234483)
        {
          if ((int)this <= 645162545)
          {
            if (this == 641234484) {
              goto LABEL_439;
            }
            if (this == 641877825) {
              goto LABEL_586;
            }
            int v21 = 645162544;
            goto LABEL_449;
          }
          if (this != 645162546)
          {
            if (this != 645162548)
            {
              int v10 = 645166640;
LABEL_421:
              uint64_t v3 = (uint64_t)this;
              if (this != v10) {
                return v3;
              }
              goto LABEL_422;
            }
LABEL_423:
            int v48 = 762603056;
LABEL_453:
            uint64_t v5 = v48 | 4u;
            goto LABEL_586;
          }
LABEL_457:
          int v51 = 762603056;
          goto LABEL_583;
        }
        if ((int)this <= 641230387)
        {
          if (this != 641230384)
          {
            uint64_t v3 = (uint64_t)this;
            if (this != 641230386) {
              return v3;
            }
            goto LABEL_582;
          }
          goto LABEL_584;
        }
        if (this == 641230388) {
          goto LABEL_445;
        }
        if (this != 641234480)
        {
          uint64_t v3 = (uint64_t)this;
          if (this != 641234482) {
            return v3;
          }
          goto LABEL_438;
        }
      }
      else
      {
        if ((int)this <= 762869295)
        {
          if ((int)this <= 762607151)
          {
            if ((int)this <= 762603055)
            {
              if (this == 758674994) {
                goto LABEL_438;
              }
              if (this == 758674996) {
                goto LABEL_439;
              }
              int v9 = 759318337;
              goto LABEL_436;
            }
            if (this != 762603056)
            {
              if (this == 762603058) {
                goto LABEL_457;
              }
              int v16 = 762603060;
              goto LABEL_392;
            }
LABEL_458:
            unsigned __int16 v46 = 26160;
            goto LABEL_459;
          }
          if ((int)this <= 762865199)
          {
            if (this != 762607152)
            {
              if (this == 762607154) {
                goto LABEL_417;
              }
              int v26 = 762607156;
LABEL_415:
              uint64_t v3 = (uint64_t)this;
              if (this != v26) {
                return v3;
              }
              goto LABEL_416;
            }
LABEL_422:
            int v47 = 762603056;
LABEL_467:
            uint64_t v5 = v47 | 0x1000u;
            goto LABEL_586;
          }
          if (this != 762865200)
          {
            if (this == 762865202) {
              goto LABEL_451;
            }
            int v29 = 762865204;
            goto LABEL_430;
          }
LABEL_432:
          unsigned __int16 v49 = 26160;
LABEL_469:
          uint64_t v5 = v49 | 0x2D780000u;
          goto LABEL_586;
        }
        if ((int)this <= 792229423)
        {
          if ((int)this <= 792225327)
          {
            if (this == 762869296) {
              goto LABEL_466;
            }
            if (this == 762869298) {
              goto LABEL_468;
            }
            int v15 = 762869300;
            goto LABEL_463;
          }
          if (this != 792225328)
          {
            if (this != 792225330)
            {
              int v14 = 792225332;
LABEL_410:
              uint64_t v3 = (uint64_t)this;
              if (this != v14) {
                return v3;
              }
              goto LABEL_445;
            }
            goto LABEL_582;
          }
LABEL_584:
          unsigned __int16 v50 = 26160;
          goto LABEL_585;
        }
        if ((int)this > 792872768)
        {
          if (this == 792872769)
          {
LABEL_586:
            if (a3)
            {
              if (a3 == 3) {
                return v5 & 0x7E7777 | 0x7C000000;
              }
              if (a3 != 2) {
                return v5;
              }
              int v58 = 788529152;
            }
            else
            {
              LODWORD(v5) = v5 & 0x7E7777;
              int v58 = 637534208;
            }
            return v5 | v58;
          }
          if (this == 796157488) {
            goto LABEL_458;
          }
          uint64_t v3 = (uint64_t)this;
          if (this != 796157490) {
            return v3;
          }
          goto LABEL_457;
        }
        if (this != 792229424)
        {
          if (this == 792229426) {
            goto LABEL_438;
          }
          uint64_t v3 = (uint64_t)this;
          if (this != 792229428) {
            return v3;
          }
          goto LABEL_439;
        }
      }
LABEL_444:
      int v47 = 758670896;
      goto LABEL_467;
    default:
      return (uint64_t)this;
  }
}

uint64_t CA::WindowServer::IOMFBDisplay::is_freezing(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28161);
}

uint64_t CA::Render::get_compressed_agx_universal_rgb_fourcc(CA::Render *this)
{
  uint64_t v1 = 641877825;
  if ((int)this > 1111970368)
  {
    if ((int)this > 1815162993)
    {
      switch(this)
      {
        case 0x6C313072:
          return 644624754;
        case 0x77343061:
          return 645346401;
        case 0x77333072:
          return 645346162;
      }
      return (uint64_t)this;
    }
    if (this == 1111970369) {
      return v1;
    }
    int v2 = 1380411457;
LABEL_16:
    if (this == v2) {
      return 642934849;
    }
    return (uint64_t)this;
  }
  if ((int)this <= 644624753)
  {
    if (this == 641877825) {
      return v1;
    }
    int v2 = 642934849;
    goto LABEL_16;
  }
  if (this == 644624754) {
    return 644624754;
  }
  if (this != 645346162)
  {
    if (this != 645346401) {
      return (uint64_t)this;
    }
    return 645346401;
  }
  return 645346162;
}

uint64_t CA::WindowServer::IOMFBDisplay::swap_set_layer(CA::WindowServer::IOMFBDisplay *this, CA::Render::Update *a2, CA::Render::Update *a3, const Rect *a4, const Rect *a5, const CA::Rect *a6, unsigned int a7, unsigned int a8, unsigned int a9, BOOL a10)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  int v18 = (CA::WindowServer::IOMFBDisplay *)((char *)this + 25568);
  int v19 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1840))(this);
  if (HIBYTE(xmmword_1EB2ACC30)) {
    int v21 = 0;
  }
  else {
    int v21 = v19;
  }
  if (a3)
  {
    uint64_t v87 = a4;
    int8x16_t v88 = v18;
    unsigned int v86 = a8;
    unsigned int v85 = a6;
    if ((v21 & 1) == 0)
    {
LABEL_57:
      int v52 = (__IOSurface *)(*(uint64_t (**)(CA::Render::Update *))(*(void *)a3 + 160))(a3);
      if (v52) {
        BOOL v53 = (a2 & 0xFFFFFFFD) == 0;
      }
      else {
        BOOL v53 = 0;
      }
      if (v53) {
        uint64_t v54 = v85 | 0x200;
      }
      else {
        uint64_t v54 = v85;
      }
      if (BYTE6(xmmword_1EB2ACC70))
      {
        if (x_log_hook_p())
        {
          unint64_t v72 = (__IOSurface *)(*(uint64_t (**)(CA::Render::Update *))(*(void *)a3 + 160))(a3);
          IOSurfaceGetID(v72);
          x_log_();
        }
        else
        {
          int32x4_t v73 = x_log_category_sharedevent;
          if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEBUG))
          {
            int32x4_t v74 = (__IOSurface *)(*(uint64_t (**)(CA::Render::Update *))(*(void *)a3 + 160))(a3);
            IOSurfaceID ID = IOSurfaceGetID(v74);
            uint64_t v76 = *((void *)a3 + 2);
            *(_DWORD *)long long buf = 67109632;
            *(_DWORD *)&uint8_t buf[4] = ID;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = a2;
            *(_WORD *)&buf[14] = 2048;
            *(void *)&long long v99 = v76;
            _os_log_impl(&dword_184668000, v73, OS_LOG_TYPE_DEBUG, "IOSurfaceID: 0x%x  layer: %d  SharedEvent: %p", buf, 0x18u);
          }
        }
      }
      int v55 = (uint64_t *)*((void *)a3 + 2);
      if (v55 && v55[1])
      {
        uint64_t v84 = (const CA::Rect *)a5;
        if (a2 > 3) {
          int v56 = 0;
        }
        else {
          int v56 = dword_184998840[a2];
        }
        unsigned __int16 v57 = (_DWORD *)v55[8];
        if (v57) {
          CA::WindowServer::SharedEvent::History::add(v57, *v55, v56, 1, 1, v55[5]);
        }
        int v58 = IOMobileFramebufferSwapSetEventWait();
        if (v58)
        {
          int v59 = v58;
          if (x_log_hook_p())
          {
            int v60 = (__IOSurface *)(*(uint64_t (**)(CA::Render::Update *))(*(void *)a3 + 160))(a3);
            IOSurfaceGetID(v60);
            x_log_();
          }
          else
          {
            int v61 = x_log_category_sharedevent;
            if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR))
            {
              int v62 = (__IOSurface *)(*(uint64_t (**)(CA::Render::Update *))(*(void *)a3 + 160))(a3);
              IOSurfaceID v63 = IOSurfaceGetID(v62);
              uint64_t v64 = *((void *)a3 + 2);
              *(_DWORD *)long long buf = 67109888;
              *(_DWORD *)&uint8_t buf[4] = v63;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = a2;
              *(_WORD *)&buf[14] = 2048;
              *(void *)&long long v99 = v64;
              WORD4(v99) = 1024;
              *(_DWORD *)((char *)&v99 + 10) = v59;
              _os_log_impl(&dword_184668000, v61, OS_LOG_TYPE_ERROR, "IOSurfaceID: 0x%x  layer: %d  SharedEvent: %p wait returned error: %x", buf, 0x1Eu);
            }
          }
        }
        CA::WindowServer::SharedEvent::inc_signal_value((uint64_t)v55, v56, 1);
        int v65 = IOMobileFramebufferSwapSetEventSignal();
        a5 = (const Rect *)v84;
        if (v65)
        {
          int v66 = v65;
          if (x_log_hook_p())
          {
            unint64_t v67 = (__IOSurface *)(*(uint64_t (**)(CA::Render::Update *))(*(void *)a3 + 160))(a3);
            IOSurfaceGetID(v67);
            x_log_();
          }
          else
          {
            uint64_t v68 = x_log_category_sharedevent;
            if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR))
            {
              char v69 = (__IOSurface *)(*(uint64_t (**)(CA::Render::Update *))(*(void *)a3 + 160))(a3);
              IOSurfaceID v70 = IOSurfaceGetID(v69);
              uint64_t v71 = *((void *)a3 + 2);
              *(_DWORD *)long long buf = 67109888;
              *(_DWORD *)&uint8_t buf[4] = v70;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = a2;
              *(_WORD *)&buf[14] = 2048;
              *(void *)&long long v99 = v71;
              WORD4(v99) = 1024;
              *(_DWORD *)((char *)&v99 + 10) = v66;
              _os_log_impl(&dword_184668000, v68, OS_LOG_TYPE_ERROR, "IOSurfaceID: 0x%x  layer: %d  SharedEvent: %p signal returned error: %x", buf, 0x1Eu);
            }
          }
        }
      }
      return CA::WindowServer::IOMFBDisplay::fb_swap_set_layer((CA::WindowServer::IOMFBDisplay *)*((unsigned int *)this + 6), v88, (uint64_t)a2, v52, v87, a5, v54, a7, v86);
    }
    int v31 = (const void *)(*(uint64_t (**)(CA::Render::Update *))(*(void *)a3 + 88))(a3);
    CFTypeRef cf = v31;
    if (!v31)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unsigned __int16 v32 = x_log_category_windowserver;
        if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_184668000, v32, OS_LOG_TYPE_DEBUG, "source surface has no colorspace, setting to sRGB", buf, 2u);
        }
      }
      int v31 = (const void *)CAGetColorSpace(0x1Du);
      CFTypeRef cf = v31;
    }
    if (CACGColorSpaceIsRec709((uint64_t)v31))
    {
      CA::WindowServer::Display::display_attributes((CA::WindowServer::Display *)buf, (uint64_t *)this);
      if (HIDWORD(v101) == 2
        || HIDWORD(v101) == 6
        && (CA::WindowServer::Display::display_attributes((CA::WindowServer::Display *)buf, (uint64_t *)this), BYTE6(v101)))
      {
        int v33 = 1;
        unsigned int v34 = 19;
      }
      else
      {
        int v33 = 0;
        unsigned int v34 = 29;
      }
      int v35 = (const void *)CAGetColorSpace(v34);
      CFTypeRef cf = v35;
    }
    else
    {
      int v33 = 0;
      int v35 = cf;
    }
    if ((CACGColorSpaceIsRec601NTSC((uint64_t)v35) & 1) == 0 && (CACGColorSpaceIsRec601PAL((uint64_t)cf) & 1) == 0)
    {
      int v37 = cf;
      goto LABEL_36;
    }
    CA::WindowServer::Display::display_attributes((CA::WindowServer::Display *)buf, (uint64_t *)this);
    if (HIDWORD(v101) == 6)
    {
      CA::WindowServer::Display::display_attributes((CA::WindowServer::Display *)buf, (uint64_t *)this);
      if (BYTE6(v101))
      {
LABEL_29:
        if (CACGColorSpaceIsRec601NTSC((uint64_t)cf)) {
          unsigned int v36 = 24;
        }
        else {
          unsigned int v36 = 25;
        }
        int v37 = (const void *)CAGetColorSpace(v36);
        CFTypeRef cf = v37;
        int v33 = 1;
LABEL_36:
        int v38 = (int *)((char *)this + 27336);
        if (v37 == (const void *)CAGetColorSpace(9u) || CGColorSpaceEqualToColorSpaceIgnoringRange())
        {
          CA::WindowServer::Display::display_attributes((CA::WindowServer::Display *)buf, (uint64_t *)this);
          if (!BYTE6(v101)) {
            CFTypeRef cf = (CFTypeRef)CAGetColorSpace(0x1Fu);
          }
        }
        CA::WindowServer::IOMFBDisplay::set_tonemapping_state(this, a3, a2, (uint64_t)&cf, v39);
        if (cf)
        {
          if (cf == *((CFTypeRef *)this + a2 + 3411)) {
            int v40 = 1;
          }
          else {
            int v40 = CGColorSpaceEqualToColorSpaceIgnoringRange();
          }
          int v41 = (const CA::Rect *)a5;
          int v42 = v40 ^ 1;
        }
        else
        {
          int v41 = (const CA::Rect *)a5;
          int v42 = 0;
        }
        int v43 = *((_DWORD *)this + 6836);
        int v44 = 1 << (char)a2;
        if ((v43 & (1 << (char)a2)) != 0)
        {
          *((_DWORD *)this + 6836) = v43 ^ v44;
          int v42 = 1;
        }
        int v45 = CA::WindowServer::IOMFBDisplay::color_program_cache(this);
        unsigned __int16 v46 = (CGColorSpace **)v45;
        int v47 = *v38;
        if (((BYTE6(xmmword_1EB2ACC30) == 0) & ~v33) != 0)
        {
          unsigned int v49 = *((unsigned __int8 *)this + 746);
          int v48 = (v49 >> 6) & 1;
          if ((((v47 & v44) == 0) ^ ((v49 & 0x40) >> 6)))
          {
LABEL_50:
            v45[63] = v48;
            a5 = (const Rect *)v41;
            if (!v42) {
              goto LABEL_57;
            }
LABEL_54:
            if (BYTE8(xmmword_1EB2ACC30))
            {
              uint64_t v77 = CGColorSpaceCopyICCProfileDescription();
              if (v77)
              {
                CFStringRef v78 = (const __CFString *)v77;
                long long v104 = 0u;
                long long v105 = 0u;
                long long v103 = 0u;
                long long v101 = 0u;
                long long v102 = 0u;
                long long v99 = 0u;
                long long v100 = 0u;
                *(_OWORD *)long long buf = 0u;
                if (x_log_hook_p())
                {
                  CA_CFStringGetCString(v78, (char *)buf, 128);
                  (*(float (**)(CA::Render::Update *))(*(void *)a3 + 192))(a3);
                  x_log_();
                }
                else
                {
                  uint64_t v80 = x_log_category_color;
                  if (os_log_type_enabled((os_log_t)x_log_category_color, OS_LOG_TYPE_DEFAULT))
                  {
                    int v81 = *((_DWORD *)this + 6);
                    CString = CA_CFStringGetCString(v78, (char *)buf, 128);
                    float v83 = (*(float (**)(CA::Render::Update *))(*(void *)a3 + 192))(a3);
                    *(_DWORD *)unint64_t v90 = 67109890;
                    int v91 = v81;
                    __int16 v92 = 1024;
                    int v93 = (int)a2;
                    __int16 v94 = 2080;
                    int8x16_t v95 = CString;
                    __int16 v96 = 2048;
                    double v97 = v83;
                    _os_log_impl(&dword_184668000, v80, OS_LOG_TYPE_DEFAULT, "Display %u setting IOMFB source layer %u colorspace to '%s' with EDR factor: %g", v90, 0x22u);
                  }
                }
                CFRelease(v78);
              }
            }
            unsigned __int16 v50 = (CGColorSpace *)CAGetColorSpace(0x1Eu);
            CA::ColorProgram::Cache::set_colorspace(v46, v50);
            int v51 = CA::ColorProgram::Cache::lookup(v46, (CGColorSpace *)cf, 0, 0);
            if (v51)
            {
              CA::WindowServer::IOMFBDisplay::set_icc_matrix_and_trc((uint64_t)this, (uint64_t)v51, 0, 0, (int)a2);
              X::CFRef<__CFDictionary const*>::operator=((const void **)this + a2 + 3411, cf);
            }
            goto LABEL_57;
          }
        }
        else
        {
          LOBYTE(v48) = 1;
          if ((v47 & v44) != 0) {
            goto LABEL_50;
          }
        }
        *int v38 = v47 ^ v44;
        v45[63] = v48;
        a5 = (const Rect *)v41;
        goto LABEL_54;
      }
    }
    else if (v33)
    {
      goto LABEL_29;
    }
    int v37 = (const void *)CAGetColorSpace(0x1Du);
    int v33 = 0;
    CFTypeRef cf = v37;
    goto LABEL_36;
  }
  if (v21) {
    CA::WindowServer::IOMFBDisplay::set_tonemapping_state(this, 0, a2, 0, v20);
  }
  if (BYTE6(xmmword_1EB2ACC70))
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      int v79 = x_log_category_sharedevent;
      if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = a2;
        _os_log_impl(&dword_184668000, v79, OS_LOG_TYPE_DEBUG, "layer: %d  surface: nullptr", buf, 8u);
      }
    }
  }
  kdebug_trace();
  return CA::IOMobileFramebuffer::swap_set_layer(v18, (uint64_t)a2, 0, a4, a5, (uint64_t)a6, v22, v23, v24, v25, v26, v27, v28, v29);
}

uint64_t CA::WindowServer::IOMFBDisplay::supports_icc_color_management(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28207);
}

uint64_t CA::WindowServer::IOSurface::iosurface(CA::WindowServer::IOSurface *this)
{
  return *((void *)this + 30);
}

uint64_t CA::IOMobileFramebuffer::swap_set_layer(CA::IOMobileFramebuffer *this, uint64_t a2, IOSurfaceRef buffer, const Rect *a4, const Rect *a5, uint64_t a6, __n128 a7, __n128 a8, __n128 a9, __n128 a10, __n128 a11, __n128 a12, __n128 a13, __n128 a14)
{
  if (buffer) {
    uint64_t ID = IOSurfaceGetID(buffer);
  }
  else {
    uint64_t ID = 0;
  }
  int v21 = (char *)this + 8 * a2;
  uint64_t v23 = *((void *)v21 + 4);
  __n128 v22 = v21 + 32;
  if (v23 != ID)
  {
    *((unsigned char *)this + 16) = 1;
    void *v22 = ID;
  }
  uint64_t v24 = *((void *)this + 3);
  a7.n128_u64[0] = (unint64_t)*a4;
  a8.n128_u64[0] = (unint64_t)a4[1];
  a9.n128_u64[0] = (unint64_t)a4[2];
  a10.n128_u64[0] = (unint64_t)a4[3];
  a11.n128_u64[0] = (unint64_t)*a5;
  a12.n128_u64[0] = (unint64_t)a5[1];
  a13.n128_u64[0] = (unint64_t)a5[2];
  a14.n128_u64[0] = (unint64_t)a5[3];

  return MEMORY[0x1F4124C10](v24, a2, buffer, a6, a7, a8, a9, a10, a11, a12, a13, a14);
}

uint64_t CA::WindowServer::IOMFBDisplay::fb_swap_set_layer(CA::WindowServer::IOMFBDisplay *this, CA::IOMobileFramebuffer *a2, uint64_t a3, IOSurfaceRef buffer, const Rect *a5, const Rect *a6, uint64_t a7, unsigned int a8, unsigned int a9)
{
  if (buffer) {
    IOSurfaceGetID(buffer);
  }
  kdebug_trace();

  return CA::IOMobileFramebuffer::swap_set_layer(a2, a3, buffer, a5, a6, a7, v15, v16, v17, v18, v19, v20, v21, v22);
}

BOOL CA::WindowServer::Display::has_hdr_clone(CA::WindowServer::Display *this)
{
  v3[1] = *MEMORY[0x1E4F143B8];
  if ((*((_DWORD *)this + 156) & 4) == 0) {
    return 0;
  }
  uint64_t v1 = (void *)*((void *)this + 5);
  if (!v1) {
    return 0;
  }
  do
  {
    v3[0] = *(void *)(*(void *)(*v1 + 96) + 640);
    BOOL result = CA::WindowServer::Display::Mode::is_hdr((CA::WindowServer::Display::Mode *)v3);
    if (result) {
      break;
    }
    uint64_t v1 = (void *)v1[1];
  }
  while (v1);
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::framebuffer_pixel_format(CA::WindowServer::IOMFBDisplay *this)
{
  uint64_t v2 = 1380411457;
  if (CA::WindowServer::Display::edr_headroom(this) > 1.0)
  {
    uint64_t v3 = *((void *)this + 86);
    if (v3)
    {
      float v4 = COERCE_FLOAT(atomic_load((unsigned int *)(v3 + 4)));
      if (v4 > 8.0) {
        return v2;
      }
    }
  }
  if (byte_1EB2ACC49
    || byte_1EB2ACC62
    || *((unsigned char *)this + 26368)
    || *((unsigned char *)this + 28138)
    && CA::WindowServer::Display::Mode::is_hdr((CA::WindowServer::IOMFBDisplay *)((char *)this + 27104))
    && *((unsigned char *)this + 28171))
  {
    return v2;
  }
  if (CADeviceIsVirtualized::once != -1) {
    dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
  }
  if (CADeviceIsVirtualized::is_virtualized) {
    return v2;
  }
  if (!(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1840))(this)) {
    goto LABEL_19;
  }
  if (CADeviceSupportsUniversalCompression::once != -1) {
    dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
  }
  if (!CADeviceSupportsUniversalCompression::universal)
  {
LABEL_19:
    if ((*((_DWORD *)this + 156) & 8) == 0)
    {
      uint64_t v6 = 1111970369;
      goto LABEL_21;
    }
    if (CADeviceUseFramebufferCompression::once != -1) {
      dispatch_once(&CADeviceUseFramebufferCompression::once, &__block_literal_global_30);
    }
    uint64_t v6 = 1647534392;
    if (CADeviceUseFramebufferCompression::enable_compression
      && !*((unsigned char *)this + 28138)
      && (*((_WORD *)this + 328) & 0x1C00) != 0x1000)
    {
      if (CADeviceSupportsUniversalCompression::once != -1)
      {
        dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
        uint64_t v6 = 1647534392;
      }
      if (!CADeviceSupportsUniversalCompression::universal)
      {
        if (*((unsigned char *)this + 28155)) {
          uint64_t v6 = 1999908961;
        }
        else {
          uint64_t v6 = 1380411457;
        }
      }
      goto LABEL_21;
    }
    return 1647534392;
  }
  uint64_t v6 = 1647534392;
LABEL_21:
  int v7 = *(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, uint64_t, void))(*(void *)this + 2320);

  return v7(this, v6, 0);
}

int *CAImageQueueSetFlags(int *a1, unsigned int a2, unsigned int a3)
{
  return CAImageQueueSetFlagsInternal(a1, a2, a3);
}

void CA::Render::LayerNode::depth_sort_sublayers(CA::Render::LayerNode *this)
{
  uint64_t v1 = (void *)MEMORY[0x1F4188790](this);
  v165[1020] = *MEMORY[0x1E4F143B8];
  unint64_t v160 = 0;
  uint64_t v161 = 0;
  unint64_t v158 = 0;
  uint64_t v159 = 0;
  uint64_t v3 = v1[3];
  if ((v3 & 0x20) != 0)
  {
    v1[3] = v3 & 0xFFFFFFFFFFFFFFDFLL;
    if ((*(unsigned char *)(v1[4] + 41) & 8) != 0)
    {
      float v4 = v1 + 12;
      uint64_t v5 = (uint64_t *)v1[13];
      if (v5 != v1 + 12)
      {
        LODWORD(v154) = 0;
        unint64_t v6 = 0;
        int v7 = 0;
        float32x2_t v155 = v1;
        uint64_t v156 = (uint64_t *)&v156;
        unint64_t v157 = &v156;
        uint64_t v8 = 16;
        if (v2) {
          uint64_t v8 = 0;
        }
        uint64_t v9 = v8 | 4;
        uint64_t v10 = v8 | 8;
        char v11 = 1;
        do
        {
          unsigned __int16 v12 = v7;
          int v7 = (double *)v5;
          while (1)
          {
            uint64_t v5 = (uint64_t *)*((void *)v7 + 1);
            uint64_t v13 = *((void *)v7 + 3);
            if ((v13 & v9) == 4)
            {
              CA::Render::LayerNode::update_z_range((CA::Render *)v7, v2);
              uint64_t v13 = *((void *)v7 + 3);
            }
            uint64_t v14 = v13 & v10;
            uint64_t v15 = v13 & 0x400000;
            BOOL v16 = v14 && v15 == 0;
            if (!v16) {
              break;
            }
            uint64_t v18 = *(void *)v7;
            __n128 v17 = (void *)*((void *)v7 + 1);
            *(void *)(v18 + 8) = v17;
            void *v17 = v18;
            *(void *)int v7 = v7;
            *((void *)v7 + 1) = &v156;
            __n128 v19 = v156;
            uint64_t v156 = (uint64_t *)v7;
            *(void *)int v7 = v19;
            v19[1] = (uint64_t)v7;
            int v7 = (double *)v5;
            if (v5 == v4) {
              goto LABEL_22;
            }
          }
          if (v6)
          {
            double v20 = v7[30];
            v11 &= v20 <= v12[30];
            int v21 = v154;
            if (v20 < v12[31]) {
              int v21 = 1;
            }
            LODWORD(v154) = v21;
          }
          ++v6;
        }
        while (v5 != v4);
LABEL_22:
        char v22 = v11;
        if (v11)
        {
          uint64_t v23 = v155;
          if ((v154 & (v6 > 1)) == 0) {
            goto LABEL_168;
          }
        }
        else
        {
          uint64_t v23 = v155;
          if (v6 < 2) {
            goto LABEL_168;
          }
        }
        unint64_t v24 = 32 * v6;
        if (32 * v6 > 0x1000)
        {
          __n128 v26 = (char *)malloc_type_malloc(32 * v6, 0xB17216D1uLL);
          __n128 v25 = v26;
          if (!v26) {
            goto LABEL_168;
          }
        }
        else
        {
          MEMORY[0x1F4188790](v1);
          __n128 v25 = (char *)&v150 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
          bzero(v25, 32 * v6);
        }
        if (4 * v6 <= 0x1000)
        {
          MEMORY[0x1F4188790](v26);
          __n128 v27 = (char *)&v150 - ((4 * v6 + 15) & 0xFFFFFFFFFFFFFFF0);
          bzero(v27, 4 * v6);
          goto LABEL_32;
        }
        __n128 v27 = (char *)malloc_type_malloc(4 * v6, 0x1461D055uLL);
        if (v27)
        {
LABEL_32:
          uint64_t v153 = 4 * v6;
          uint64_t v28 = v23[13];
          if ((uint64_t *)v28 != v4)
          {
            int v29 = v6 - 1;
            int v30 = &v27[4 * v6 - 4];
            int v31 = &v25[16 * v6 - 8];
            do
            {
              *((void *)v31 - 1) = ((*(uint64_t *)(v28 + 240) >> 63) | 0x8000000000000000) ^ *(void *)(v28 + 240);
              *(void *)int v31 = v28;
              *(void *)uint64_t v28 = 0;
              *(_DWORD *)int v30 = *(_DWORD *)(v28 + 116);
              v30 -= 4;
              *(_DWORD *)(v28 + 116) = v29;
              uint64_t v28 = *(void *)(v28 + 8);
              --v29;
              v31 -= 16;
            }
            while ((uint64_t *)v28 != v4);
          }
          float32x2_t v152 = v27;
          if ((v22 & 1) == 0)
          {
            if (v6 > 0x3F)
            {
              bzero(v163, 0x2000uLL);
              int v40 = (unint64_t *)v25;
              unint64_t v41 = v6;
              do
              {
                unint64_t v42 = *v40;
                v40 += 2;
                ++LODWORD(v163[4 * v42]);
                ++HIDWORD(v163[4 * BYTE1(v42)]);
                ++LODWORD(v163[4 * BYTE2(v42) + 1]);
                ++HIDWORD(v163[4 * BYTE3(v42) + 1]);
                ++LODWORD(v163[4 * BYTE4(v42) + 2]);
                ++DWORD1(v164[2 * BYTE5(v42)]);
                ++DWORD2(v164[2 * BYTE6(v42)]);
                ++HIDWORD(v164[2 * HIBYTE(v42)]);
                --v41;
              }
              while (v41);
              unint64_t v43 = 0;
              int32x4_t v44 = 0uLL;
              int32x4_t v45 = 0uLL;
              do
              {
                unsigned __int16 v46 = (int32x4_t *)&v163[4 * v43];
                int32x4_t v47 = v46[6];
                int32x4_t v48 = v46[7];
                int32x4_t v49 = vaddq_s32(*v46, v44);
                int32x4_t v50 = vaddq_s32(v46[1], v45);
                int32x4_t v51 = vaddq_s32(v50, v46[3]);
                int32x4_t v52 = vaddq_s32(v49, v46[2]);
                int32x4_t v53 = vaddq_s32(v52, v46[4]);
                int32x4_t v54 = vaddq_s32(v51, v46[5]);
                *unsigned __int16 v46 = v44;
                v46[1] = v45;
                int32x4_t v45 = vaddq_s32(v54, v48);
                int32x4_t v44 = vaddq_s32(v53, v47);
                v46[2] = v49;
                v46[3] = v50;
                float v46[4] = v52;
                v46[5] = v51;
                v46[6] = v53;
                v46[7] = v54;
                BOOL v55 = v43 >= 0xFC;
                v43 += 4;
              }
              while (!v55);
              uint64_t v56 = 0;
              v162[0] = v25;
              v162[1] = &v25[16 * v6];
              do
              {
                uint64_t v57 = v162[!(v56 & 1)];
                int v58 = (uint64_t *)(v162[v56 & 1] + 8);
                unint64_t v59 = v6;
                do
                {
                  unint64_t v60 = *(v58 - 1);
                  uint64_t v61 = *v58;
                  int v62 = &v163[4 * (v60 >> (8 * v56))];
                  uint64_t v63 = *((unsigned int *)v62 + v56);
                  *((_DWORD *)v62 + v56) = v63 + 1;
                  uint64_t v64 = (unint64_t *)(v57 + 16 * v63);
                  *uint64_t v64 = v60;
                  v64[1] = v61;
                  v58 += 2;
                  --v59;
                }
                while (v59);
                ++v56;
              }
              while (v56 != 8);
            }
            else if (v6 >= 2)
            {
              uint64_t v32 = 1;
              int v33 = v25;
              do
              {
                unsigned int v34 = &v25[16 * v32];
                unint64_t v35 = *(void *)v34;
                uint64_t v36 = *((void *)v34 + 1);
                int v37 = v33;
                uint64_t v38 = v32;
                while (*(void *)v37 > v35)
                {
                  --v38;
                  v37[1] = *v37;
                  --v37;
                  if (v38 + 1 <= 1)
                  {
                    uint64_t v38 = 0;
                    break;
                  }
                }
                int v39 = &v25[16 * v38];
                *(void *)int v39 = v35;
                *((void *)v39 + 1) = v36;
                ++v32;
                ++v33;
              }
              while (v32 != v6);
            }
          }
          unint64_t v158 = (CA::Render::LayerNode **)&v158;
          uint64_t v159 = (CA::Render::LayerNode **)&v158;
          if (v6)
          {
            uint64_t v65 = 8;
            unint64_t v66 = v6;
            do
            {
              unint64_t v67 = *(CA::Render::LayerNode ***)&v25[v65];
              __IOSurface *v67 = (CA::Render::LayerNode *)v67;
              v67[1] = (CA::Render::LayerNode *)&v158;
              uint64_t v68 = (CA::Render::LayerNode *)v158;
              unint64_t v158 = v67;
              __IOSurface *v67 = v68;
              *((void *)v68 + 1) = v67;
              v67[11] = 0;
              v67[3] = (CA::Render::LayerNode *)((unint64_t)v67[3] & 0xFFFFFFFFFFFFFFFDLL);
              v65 += 16;
              --v66;
            }
            while (v66);
            if (v24 > 0x1000) {
              free(v25);
            }
          }
          char v69 = (void ***)v163;
          v163[0] = 0;
          v163[1] = v165;
          v164[0] = xmmword_1849980F0;
          unint64_t v160 = 0;
          uint64_t v161 = (void ***)v163;
          uint64_t v70 = 0x2000;
          if (v6 * v6 < 0x2000) {
            uint64_t v70 = v6 * v6;
          }
          v23[12] = v23 + 12;
          v23[13] = v4;
          uint64_t v71 = (uint64_t)v159;
          if (v159 == (CA::Render::LayerNode **)&v158)
          {
LABEL_164:
            x_heap_free(v69);
            uint64_t v145 = v23[13];
            int v146 = v152;
            for (unint64_t i = v153; (uint64_t *)v145 != v4; v145 = *(void *)(v145 + 8))
              *(_DWORD *)(v145 + 116) = v146[*(unsigned int *)(v145 + 116)];
            if (i > 0x1000) {
              free(v146);
            }
            goto LABEL_168;
          }
          uint64_t v151 = v70;
          unint64_t v154 = 0;
          double v72 = -0.0000999999975;
LABEL_63:
          uint64_t v73 = *(void *)(v71 + 8);
          if ((CA::Render::LayerNode ***)v73 == &v158) {
            goto LABEL_128;
          }
          while (1)
          {
            while (1)
            {
              if (*(double *)(v71 + 248) <= *(double *)(v73 + 240))
              {
                if ((*(unsigned char *)(v73 + 24) & 2) == 0) {
                  goto LABEL_127;
                }
                goto LABEL_73;
              }
              unint64_t v74 = *(void *)(v71 + 88);
              if (!v74)
              {
                unint64_t v74 = CA::Render::compute_occlusion_data(&v160, v71);
                *(void *)(v71 + 88) = v74;
                if (!v74)
                {
                  uint64_t v130 = *(void *)v71;
                  unint64_t v129 = *(void **)(v71 + 8);
                  *(void *)(v130 + 8) = v129;
                  *unint64_t v129 = v130;
                  *(void *)uint64_t v71 = v71;
                  *(void *)(v71 + 8) = v71;
                  if (atomic_fetch_add((atomic_uint *volatile)(v71 + 16), 0xFFFFFFFF) == 1) {
                    CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v71, v75);
                  }
LABEL_135:
                  unint64_t v131 = v154;
                  uint64_t v23 = v155;
                  goto LABEL_136;
                }
              }
              unint64_t v76 = *(void *)(v73 + 88);
              if (v76) {
                break;
              }
              unint64_t v76 = CA::Render::compute_occlusion_data(&v160, v73);
              *(void *)(v73 + 88) = v76;
              if (v76) {
                break;
              }
              uint64_t v106 = *(CA::Render::LayerNode **)v73;
              uint64_t v107 = *(CA::Render::LayerNode ***)(v73 + 8);
              *((void *)v106 + 1) = v107;
              *uint64_t v107 = v106;
              *(void *)uint64_t v73 = v73;
              *(void *)(v73 + 8) = v73;
              if (atomic_fetch_add((atomic_uint *volatile)(v73 + 16), 0xFFFFFFFF) == 1) {
                CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v73, v77);
              }
              uint64_t v73 = (uint64_t)v107;
              if (v107 == (CA::Render::LayerNode **)&v158)
              {
LABEL_127:
                uint64_t v23 = v155;
                goto LABEL_128;
              }
            }
            if (*(double *)v74 >= *(double *)v76)
            {
              if (*(double *)(v76 + 16) <= *(double *)v74) {
                goto LABEL_73;
              }
            }
            else if (*(double *)(v74 + 16) <= *(double *)v76)
            {
              goto LABEL_73;
            }
            double v78 = *(double *)(v74 + 8);
            double v79 = *(double *)(v76 + 8);
            if (v78 >= v79)
            {
              if (*(double *)(v76 + 24) <= v78) {
                goto LABEL_73;
              }
            }
            else if (*(double *)(v74 + 24) <= v79)
            {
              goto LABEL_73;
            }
            double v80 = *(double *)(v76 + 56);
            double v81 = *(double *)(v74 + 56);
            if (vabdd_f64(v80, v81) > 0.0000999999975) {
              break;
            }
            double v96 = *(double *)(v76 + 32);
            double v97 = *(double *)(v76 + 40);
            double v86 = *(double *)(v74 + 32);
            double v85 = *(double *)(v74 + 40);
            double v99 = *(double *)(v76 + 48);
            double v88 = *(double *)(v74 + 48);
            float v108 = v86 * v96 + v85 * v97 + v88 * v99;
            if (1.0 - fabsf(v108) >= 0.0000999999975)
            {
              unint64_t v82 = *(unsigned int *)(v76 + 72);
              if (v82)
              {
                uint64_t v84 = *(double **)(v76 + 80);
                float v83 = *(double **)(v76 + 88);
                uint64_t v87 = *(double **)(v76 + 96);
                double v89 = *v84 * v86;
                double v90 = *v83 * v85;
                double v91 = *v87 * v88;
                if (fabs(v89 + v81 + v90 + v91) > 0.0000999999975) {
                  goto LABEL_84;
                }
                unint64_t v109 = 0;
                unint64_t v110 = v84 + 1;
                os_signpost_id_t v111 = v83 + 1;
                float v112 = v87 + 1;
                while (v82 - 1 != v109)
                {
                  double v113 = fabs(v81 + v110[v109] * v86 + v111[v109] * v85 + v112[v109] * v88);
                  ++v109;
                  if (v113 > 0.0000999999975)
                  {
                    if (v109 < v82) {
                      goto LABEL_82;
                    }
                    break;
                  }
                }
              }
            }
            if (*(_DWORD *)(v71 + 116) >= *(_DWORD *)(v73 + 116))
            {
              LODWORD(v93) = *(_DWORD *)(v74 + 72);
LABEL_105:
              if (v93) {
                goto LABEL_106;
              }
LABEL_112:
              unsigned int v116 = *(_DWORD *)(v76 + 72);
              if (!v116) {
                goto LABEL_137;
              }
              unsigned int v117 = 0;
              do
              {
                if (v117) {
                  unsigned int v118 = v117;
                }
                else {
                  unsigned int v118 = v116;
                }
                BOOL v119 = CA::Render::separating_axis(v76, v74, v118 - 1, v117);
                if (v119) {
                  break;
                }
                BOOL v16 = v116 - 1 == v117++;
              }
              while (!v16);
              if (!v119)
              {
LABEL_137:
                uint64_t v132 = *(void *)(v73 + 24);
                if ((v132 & 2) == 0
                  && ((CA::Render::in_positive_half_space((double *)v76, v74) & 1) != 0
                   || CA::Render::in_negative_half_space((double *)v74, v76)))
                {
                  uint64_t v134 = *(CA::Render::LayerNode **)v73;
                  unsigned int v133 = *(CA::Render::LayerNode ***)(v73 + 8);
                  *((void *)v134 + 1) = v133;
                  CGColorSpace *v133 = v134;
                  *(void *)(v73 + 8) = v73;
                  uint64_t v135 = v159;
                  uint64_t v159 = (CA::Render::LayerNode **)v73;
                  *(void *)uint64_t v73 = &v158;
                  *uint64_t v135 = v73;
                  *(void *)(v73 + 8) = v135;
                  *(void *)(v73 + 24) = v132 | 2;
                  goto LABEL_135;
                }
                uint64_t v136 = *(void *)(v71 + 152);
                if (v136) {
                  LODWORD(v136) = *(_DWORD *)(v136 + 8);
                }
                uint64_t v137 = *(void *)(v73 + 152);
                double v150 = v72;
                if (v137) {
                  int v138 = *(_DWORD *)(v137 + 8);
                }
                else {
                  int v138 = 0;
                }
                if (CA::Render::in_both_half_spaces((double *)v76, v74, (float)((float)((v136 + 1) * (v136 + 1)) * 0.0001)))
                {
                  unint64_t v139 = (double *)(v76 + 32);
                  if (fabs(v96) >= 0.0000999999975
                    || fabs(v97) >= 0.0000999999975
                    || fabs(v99 + -1.0) >= 0.0000999999975)
                  {
                    uint64_t v73 = v71;
                    unint64_t v76 = v74;
                    uint64_t v23 = v155;
                    unint64_t v140 = v151;
LABEL_158:
                    double v72 = v150;
LABEL_159:
                    unint64_t v131 = v154 + 1;
                    if (v154 > v140 || (uint64_t v141 = *(void *)(v73 + 152)) != 0 && *(_DWORD *)(v141 + 8) > 0x40u)
                    {
                      ++v154;
                      goto LABEL_128;
                    }
                    int v143 = *(CA::Render::LayerNode **)v73;
                    uint64_t v142 = *(CA::Render::LayerNode ***)(v73 + 8);
                    *((void *)v143 + 1) = v142;
                    void *v142 = v143;
                    *(void *)uint64_t v73 = v73;
                    *(void *)(v73 + 8) = v73;
                    *(void *)(v76 + 64) = v160;
                    unint64_t v160 = v76;
                    *(void *)(v73 + 88) = 0;
                    *(void *)(v73 + 24) &= ~2uLL;
                    uint64_t v144 = CA::Render::LayerNode::split_node((CA::Render::LayerNode *)v73, v139);
                    CA::Render::insert_node_by_minz((CA::Render::LayerNode **)&v158, v144);
                    CA::Render::insert_node_by_minz((CA::Render::LayerNode **)&v158, (CA::Render::LayerNode *)v73);
LABEL_136:
                    uint64_t v71 = (uint64_t)v159;
                    unint64_t v154 = v131;
                    goto LABEL_131;
                  }
                }
                if (!CA::Render::in_both_half_spaces((double *)v74, v76, (float)((float)((v138 + 1) * (v138 + 1)) * 0.0001)))
                {
                  uint64_t v23 = v155;
                  double v72 = v150;
                  goto LABEL_128;
                }
                unint64_t v139 = (double *)(v74 + 32);
                unint64_t v140 = v151;
                if (fabs(v86) >= 0.0000999999975 || fabs(v85) >= 0.0000999999975)
                {
                  uint64_t v23 = v155;
                  goto LABEL_158;
                }
                uint64_t v23 = v155;
                double v72 = v150;
                if (fabs(v88 + -1.0) >= 0.0000999999975) {
                  goto LABEL_159;
                }
LABEL_128:
                unint64_t v125 = *(void *)(v71 + 88);
                if (v125)
                {
                  *(void *)(v125 + 64) = v160;
                  unint64_t v160 = v125;
                }
                uint64_t v127 = *(void *)v71;
                uint64_t v126 = *(void **)(v71 + 8);
                *(void *)(v127 + 8) = v126;
                void *v126 = v127;
                *(void *)(v71 + 8) = v71;
                int v128 = (uint64_t *)v23[13];
                v23[13] = v71;
                *(void *)uint64_t v71 = v4;
                *int v128 = v71;
                *(void *)(v71 + 8) = v128;
                *(void *)(v71 + 88) = v23;
                *(void *)(v71 + 24) &= ~2uLL;
                uint64_t v71 = (uint64_t)v159;
LABEL_131:
                if ((CA::Render::LayerNode ***)v71 == &v158)
                {
                  char v69 = v161;
                  goto LABEL_164;
                }
                goto LABEL_63;
              }
            }
LABEL_73:
            uint64_t v73 = *(void *)(v73 + 8);
            if ((CA::Render::LayerNode ***)v73 == &v158) {
              goto LABEL_127;
            }
          }
          unint64_t v82 = *(unsigned int *)(v76 + 72);
LABEL_82:
          if (!v82) {
            goto LABEL_73;
          }
          uint64_t v84 = *(double **)(v76 + 80);
          float v83 = *(double **)(v76 + 88);
          double v86 = *(double *)(v74 + 32);
          double v85 = *(double *)(v74 + 40);
          uint64_t v87 = *(double **)(v76 + 96);
          double v88 = *(double *)(v74 + 48);
          double v89 = *v84 * v86;
          double v90 = *v83 * v85;
          double v91 = *v87 * v88;
LABEL_84:
          double v92 = v81 + 0.0000999999975;
          if (v92 + v91 + v89 + v90 >= 0.0)
          {
            unint64_t v120 = 0;
            unsigned int v121 = v84 + 1;
            double v122 = v83 + 1;
            int v123 = v87 + 1;
            while (v82 - 1 != v120)
            {
              double v124 = v92 + v121[v120] * v86 + v122[v120] * v85 + v123[v120] * v88;
              ++v120;
              if (v124 < 0.0)
              {
                if (v120 >= v82) {
                  goto LABEL_73;
                }
                goto LABEL_85;
              }
            }
            goto LABEL_73;
          }
LABEL_85:
          unint64_t v93 = *(unsigned int *)(v74 + 72);
          if (v93)
          {
            __int16 v94 = *(double **)(v74 + 80);
            int8x16_t v95 = *(double **)(v74 + 88);
            double v96 = *(double *)(v76 + 32);
            double v97 = *(double *)(v76 + 40);
            int v98 = *(double **)(v74 + 96);
            double v99 = *(double *)(v76 + 48);
            double v100 = v80 + v72;
            if (v100 + *v94 * v96 + *v95 * v97 + *v98 * v99 <= 0.0)
            {
              unint64_t v101 = 0;
              long long v102 = v94 + 1;
              long long v103 = v95 + 1;
              long long v104 = v98 + 1;
              while (v93 - 1 != v101)
              {
                double v105 = v100 + v102[v101] * v96 + v103[v101] * v97 + v104[v101] * v99;
                ++v101;
                if (v105 > 0.0)
                {
                  if (v101 >= v93) {
                    goto LABEL_73;
                  }
                  goto LABEL_105;
                }
              }
              goto LABEL_73;
            }
LABEL_106:
            unsigned int v114 = 0;
            while (1)
            {
              int v115 = v114 ? v114 : v93;
              if (CA::Render::separating_axis(v74, v76, v115 - 1, v114)) {
                goto LABEL_73;
              }
              if (v93 == ++v114) {
                goto LABEL_112;
              }
            }
          }
          goto LABEL_73;
        }
LABEL_168:
        uint64_t v148 = (uint64_t *)*v4;
        v148[1] = (uint64_t)v157;
        uint64_t *v157 = v148;
        uint64_t v149 = v156;
        v156[1] = (uint64_t)v4;
        uint64_t *v4 = (uint64_t)v149;
      }
    }
  }
}

void CA::Render::LayerNode::update_z_range(CA::Render *this, CA::Render::LayerNode *a2)
{
  uint64_t v2 = *((void *)this + 3);
  if ((v2 & 4) != 0)
  {
    *((void *)this + 3) = v2 & 0xFFFFFFFFFFFFFFF3;
    uint64_t v3 = (double *)*((void *)this + 7);
    if (v3)
    {
      if (!*((void *)this + 19))
      {
        uint64_t v5 = (double *)*((void *)this + 4);
        double v6 = v5[8];
        double v7 = v5[9];
        double v8 = v5[10];
        double v9 = v5[11];
        unsigned int v10 = -1;
        double v11 = INFINITY;
        double v12 = -INFINITY;
        while (1)
        {
          unsigned int v13 = v10 + 1;
          double v14 = v10 >= 2 ? 0.0 : v8;
          double v15 = v14 + v6;
          double v16 = (v13 & 2) != 0 ? v9 : 0.0;
          double v17 = v16 + v7;
          double v18 = v3[15] + v3[3] * v15 + v3[7] * v17;
          if (v18 <= 0.0) {
            break;
          }
          double v19 = (v3[14] + v3[2] * v15 + v3[6] * v17) / v18;
          if (v19 < v11) {
            double v11 = v19;
          }
          if (v19 > v12) {
            double v12 = v19;
          }
          ++v10;
          if (v13 == 3)
          {
            *((double *)this + 30) = v11;
            *((double *)this + 31) = v12;
            return;
          }
        }
      }
      CA::Render::update_z_range_clip(this, a2);
    }
    else
    {
      uint64_t v4 = *((void *)this + 10);
      *((void *)this + 30) = v4;
      *((void *)this + 31) = v4;
    }
  }
}

int64x2_t CA::Render::update_z_range_clip(CA::Render *this, CA::Render::LayerNode *a2)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](this);
  uint64_t v4 = (double *)((char *)v12 - ((v3 + 15) & 0xFFFFFFFF0));
  bzero(v4, v3);
  unsigned int v6 = CA::Render::clip_layer(this, 0, 0, v4, v5);
  if (v6)
  {
    uint64_t v8 = v6;
    result.i64[0] = 0x7FF0000000000000;
    double v9 = -INFINITY;
    do
    {
      double v10 = *v4++;
      double v11 = v10;
      if (v10 < *(double *)result.i64) {
        *(double *)result.i64 = v11;
      }
      if (v11 > v9) {
        double v9 = v11;
      }
      --v8;
    }
    while (v8);
    *((void *)this + 30) = result.i64[0];
    *((double *)this + 31) = v9;
  }
  else
  {
    int64x2_t result = vdupq_n_s64(0xFFF0000000000000);
    *((int64x2_t *)this + 15) = result;
    *((void *)this + 3) |= 8uLL;
  }
  return result;
}

uint64_t CA::Render::clip_layer(CA::Render *this, CA::Render::LayerNode *a2, double *a3, double *a4, double *a5)
{
  v76[1] = *MEMORY[0x1E4F143B8];
  double v9 = (uint64_t *)*((void *)this + 19);
  if (v9) {
    size_t v10 = (32 * (*((_DWORD *)v9 + 2) + 5)) | 0xF;
  }
  else {
    size_t v10 = 175;
  }
  MEMORY[0x1F4188790](this);
  uint64_t v11 = (v10 + 15) & 0x3FFFFFFFF0;
  double v12 = (char *)v76 - v11;
  bzero((char *)v76 - v11, v10);
  unint64_t v13 = ((unint64_t)&v76[1] - v11 + 7) & 0xFFFFFFFFFFFFFFF0;
  MEMORY[0x1F4188790](v14);
  bzero((char *)v76 - v11, v10);
  uint64_t v15 = 0;
  double v16 = (double *)*((void *)this + 4);
  double v17 = v16[8];
  double v18 = v16[9];
  double v19 = v16[10];
  double v20 = v16[11];
  int v21 = (double *)&CA::Render::compute_occlusion_data(CA::Render::occlusion_closure *,CA::Render::LayerNode *)::my;
  char v22 = (double *)&CA::Render::compute_occlusion_data(CA::Render::occlusion_closure *,CA::Render::LayerNode *)::mx;
  do
  {
    double v23 = *v22++;
    uint64_t v24 = v13 + v15;
    *(double *)uint64_t v24 = v17 + v23 * v19;
    double v25 = *v21++;
    *(double *)(v24 + 8) = v18 + v25 * v20;
    *(_OWORD *)(v24 + 16) = xmmword_184997D60;
    v15 += 32;
  }
  while (v15 != 128);
  unint64_t v26 = ((unint64_t)&v76[1] - v11 + 7) & 0xFFFFFFFFFFFFFFF0;
  __n128 v27 = (double *)*((void *)this + 7);
  if (v27)
  {
    for (uint64_t i = 0; i != 128; i += 32)
    {
      int v29 = (double *)(v13 + i);
      double v30 = *(double *)(v13 + i);
      double v31 = *(double *)(v13 + i + 8);
      double v32 = *(double *)(v13 + i + 16);
      double v33 = *(double *)(v13 + i + 24);
      *int v29 = *v27 * v30 + v27[4] * v31 + v27[8] * v32 + v27[12] * v33;
      v29[1] = v27[1] * v30 + v27[5] * v31 + v27[9] * v32 + v27[13] * v33;
      v29[2] = v27[2] * v30 + v27[6] * v31 + v27[10] * v32 + v27[14] * v33;
      v29[3] = v27[3] * v30 + v27[7] * v31 + v27[11] * v32 + v27[15] * v33;
    }
  }
  else
  {
    do
    {
      unsigned int v34 = (double *)((char *)v27 + v13);
      double v35 = *(double *)((char *)v27 + v13 + 8);
      *unsigned int v34 = *(double *)((char *)v27 + v13) + *((double *)this + 8);
      v34[1] = v35 + *((double *)this + 9);
      void v34[2] = *(double *)((char *)v27 + v13 + 16) + *((double *)this + 10);
      v27 += 4;
    }
    while (v27 != (double *)128);
  }
  int v36 = 0;
  for (uint64_t j = 24; j != 152; j += 32)
  {
    if (*(double *)(v13 + j) < 0.0001) {
      ++v36;
    }
  }
  if (!v36)
  {
    uint64_t result = 4;
    unint64_t v26 = (unint64_t)(v12 + 15) & 0xFFFFFFFFFFFFFFF0;
    unint64_t v13 = ((unint64_t)&v76[1] - v11 + 7) & 0xFFFFFFFFFFFFFFF0;
    goto LABEL_31;
  }
  if (v36 == 4) {
    return 0;
  }
  uint64_t v38 = 0;
  int v39 = 0;
  uint64_t result = 0;
  unint64_t v41 = v13 + 96;
  double v42 = *(double *)(((unint64_t)(v12 + 15) & 0xFFFFFFFFFFFFFFF0) + 0x78) + -0.0001;
  while (1)
  {
    unint64_t v43 = (float64x2_t *)v41;
    double v44 = v42;
    unint64_t v41 = v13 + v38;
    double v42 = *(double *)(v13 + v38 + 24) + -0.0001;
    if (v44 >= 0.0)
    {
      if (v42 >= 0.0)
      {
        *(void *)(v26 + 8 * (4 * result)) = *(void *)(v13 + v38);
        *(void *)(v26 + 8 * ((4 * result) | 1u)) = *(void *)(v13 + v38 + 8);
        *(void *)(v26 + 8 * ((4 * result) | 2u)) = *(void *)(v13 + v38 + 16);
        *(void *)(v26 + 8 * ((4 * result) | 3u)) = *(void *)(v41 + 24);
      }
      else
      {
        double v48 = v44 / (v44 - v42);
        int32x4_t v49 = (float64x2_t *)(v26 + 8 * (4 * result));
        float64x2_t v50 = vmlaq_n_f64(v43[1], vsubq_f64(*(float64x2_t *)(v41 + 16), v43[1]), v48);
        *int32x4_t v49 = vmlaq_n_f64(*v43, vsubq_f64(*(float64x2_t *)v41, *v43), v48);
        v49[1] = v50;
      }
      uint64_t result = (result + 1);
      goto LABEL_26;
    }
    if (v42 >= 0.0) {
      break;
    }
LABEL_26:
    v38 += 32;
    if (v38 == 128) {
      goto LABEL_30;
    }
  }
  if (!v39)
  {
    double v45 = v44 / (v44 - v42);
    unsigned __int16 v46 = (float64x2_t *)(v26 + 8 * (4 * result));
    float64x2_t v47 = vmlaq_n_f64(v43[1], vsubq_f64(*(float64x2_t *)(v13 + v38 + 16), v43[1]), v45);
    *unsigned __int16 v46 = vmlaq_n_f64(*v43, vsubq_f64(*(float64x2_t *)(v13 + v38), *v43), v45);
    v46[1] = v47;
    *(void *)(v26 + 8 * (4 * result + 4)) = *(void *)(v13 + v38);
    *(void *)(v26 + 8 * (4 * result + 5)) = *(void *)(v13 + v38 + 8);
    *(void *)(v26 + 8 * (4 * result + 6)) = *(void *)(v13 + v38 + 16);
    *(void *)(v26 + 8 * (4 * result + 7)) = *(void *)(v41 + 24);
    uint64_t result = (result + 2);
    int v39 = 1;
    goto LABEL_26;
  }
  uint64_t result = 0;
LABEL_30:
  double v9 = (uint64_t *)*((void *)this + 19);
LABEL_31:
  if (result >= 3 && v9)
  {
    do
    {
      int v51 = 0;
      int v52 = 0;
      unint64_t v53 = v13;
      unint64_t v54 = v26 + 8 * (4 * result - 4);
      double v55 = vaddvq_f64(vmlaq_f64(vmulq_f64(*(float64x2_t *)(v54 + 16), *((float64x2_t *)v9 + 2)), *((float64x2_t *)v9 + 1), *(float64x2_t *)v54));
      uint64_t v56 = result;
      uint64_t result = 0;
      do
      {
        uint64_t v57 = (float64x2_t *)v54;
        double v58 = v55;
        unint64_t v54 = v26 + 8 * (v51 & 0xFFFFFFFC);
        float64x2_t v59 = *(float64x2_t *)v54;
        float64x2_t v60 = *(float64x2_t *)(v54 + 16);
        double v55 = vaddvq_f64(vmlaq_f64(vmulq_f64(*((float64x2_t *)v9 + 2), v60), *(float64x2_t *)v54, *((float64x2_t *)v9 + 1)));
        if (v58 >= 0.0)
        {
          unsigned int v64 = 4 * result;
          if (v55 >= 0.0)
          {
            *(float64_t *)(v13 + 8 * v64) = v59.f64[0];
            *(void *)(v13 + 8 * ((4 * result) | 1u)) = *(void *)(v54 + 8);
            *(void *)(v13 + 8 * ((4 * result) | 2u)) = *(void *)(v54 + 16);
            *(void *)(v13 + 8 * ((4 * result) | 3u)) = *(void *)(v54 + 24);
          }
          else
          {
            double v65 = v58 / (v58 - v55);
            unint64_t v66 = (float64x2_t *)(v13 + 8 * v64);
            float64x2_t v67 = vmlaq_n_f64(v57[1], vsubq_f64(v60, v57[1]), v65);
            *unint64_t v66 = vmlaq_n_f64(*v57, vsubq_f64(v59, *v57), v65);
            v66[1] = v67;
          }
          uint64_t result = (result + 1);
        }
        else if (v55 >= 0.0)
        {
          if (v52) {
            return 0;
          }
          double v61 = v58 / (v58 - v55);
          int v62 = (float64x2_t *)(v13 + 8 * (4 * result));
          float64x2_t v63 = vmlaq_n_f64(v57[1], vsubq_f64(v60, v57[1]), v61);
          *int v62 = vmlaq_n_f64(*v57, vsubq_f64(v59, *v57), v61);
          v62[1] = v63;
          *(void *)(v13 + 8 * (4 * result + 4)) = *(void *)v54;
          *(void *)(v13 + 8 * (4 * result + 5)) = *(void *)(v54 + 8);
          *(void *)(v13 + 8 * (4 * result + 6)) = *(void *)(v54 + 16);
          *(void *)(v13 + 8 * (4 * result + 7)) = *(void *)(v54 + 24);
          uint64_t result = (result + 2);
          int v52 = 1;
        }
        v51 += 4;
        --v56;
      }
      while (v56);
      if (result < 3) {
        break;
      }
      double v9 = (uint64_t *)*v9;
      unint64_t v13 = v26;
      unint64_t v26 = v53;
    }
    while (v9);
  }
  else
  {
    unint64_t v53 = v26;
  }
  if (result < 3) {
    return 0;
  }
  uint64_t v68 = 0;
  char v69 = (double *)a2;
  uint64_t v70 = a3;
  uint64_t v71 = a4;
  do
  {
    double v72 = *(double *)(v53 + 8 * (v68 + 3));
    double v73 = 1.0 / v72;
    BOOL v74 = v72 <= 0.0;
    double v75 = INFINITY;
    if (!v74) {
      double v75 = v73;
    }
    if (a2) {
      *char v69 = *(double *)(v53 + 8 * v68) * v75;
    }
    if (a3) {
      double *v70 = *(double *)(v53 + 8 * (v68 + 1)) * v75;
    }
    if (a4) {
      *uint64_t v71 = *(double *)(v53 + 8 * (v68 + 2)) * v75;
    }
    v68 += 4;
    ++v71;
    ++v70;
    ++v69;
  }
  while (4 * result != v68);
  return result;
}

BOOL CA::Render::separating_axis(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (*(unsigned char *)(a1 + 104)) {
    unsigned int v4 = a4;
  }
  else {
    unsigned int v4 = a3;
  }
  uint64_t v5 = *(void *)(a1 + 80);
  uint64_t v6 = *(void *)(a1 + 88);
  double v7 = *(double *)(v5 + 8 * v4);
  double v8 = *(double *)(v6 + 8 * v4);
  if (*(unsigned char *)(a1 + 104)) {
    unsigned int v9 = a3;
  }
  else {
    unsigned int v9 = a4;
  }
  double v10 = *(double *)(v5 + 8 * v9) - v7;
  double v11 = *(double *)(v6 + 8 * v9) - v8;
  double v12 = v10 * v10 + v11 * v11;
  if (v12 < 0.01) {
    return 0;
  }
  uint64_t v14 = *(unsigned int *)(a2 + 72);
  if (!v14) {
    return 1;
  }
  uint64_t v15 = *(double **)(a2 + 80);
  double v16 = *(double **)(a2 + 88);
  double v17 = 1.0 / sqrt(v12);
  uint64_t v18 = v14 - 1;
  do
  {
    double v19 = *v15++;
    double v20 = v19;
    double v21 = *v16++;
    double v22 = ((v7 - v20) * v11 + (v21 - v8) * v10) * v17;
    BOOL v24 = v18-- != 0;
    BOOL result = v22 <= 0.5;
  }
  while (v22 <= 0.5 && v24);
  return result;
}

unint64_t CA::Render::compute_occlusion_data(unint64_t *a1, uint64_t a2)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 152);
  if (v4)
  {
    int v5 = *(_DWORD *)(v4 + 8) + 5;
  }
  else
  {
    int v36 = *(double **)(a2 + 32);
    double v38 = v36[8];
    double v37 = v36[9];
    double v39 = v36[10];
    double v40 = v36[11];
    unint64_t v41 = *(double **)(a2 + 56);
    if (!v41)
    {
      float64x2_t v59 = (void *)CA::Render::alloc_occlusion_data(a1, 4);
      unint64_t v6 = (unint64_t)v59;
      uint64_t v60 = 0;
      uint64_t v61 = *(void *)(a2 + 80);
      double v62 = *(double *)(a2 + 64) + v38;
      double v63 = *(double *)(a2 + 72) + v37;
      double v65 = (void *)v59[10];
      unsigned int v64 = (void *)v59[11];
      uint64_t v66 = v59[12];
      do
      {
        if ((v60 - 1) >= 2) {
          double v67 = 0.0;
        }
        else {
          double v67 = v39;
        }
        *(double *)&v65[v60] = v62 + v67;
        if ((v60 & 2) != 0) {
          double v68 = v40;
        }
        else {
          double v68 = 0.0;
        }
        *(double *)&v64[v60] = v63 + v68;
        *(void *)(v66 + 8 * v60++) = v61;
      }
      while (v60 != 4);
      *float64x2_t v59 = *v65;
      v59[2] = v65[1];
      v59[1] = *v64;
      v59[3] = v64[2];
      goto LABEL_37;
    }
    uint64_t v42 = 0;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    double v43 = v41[3];
    double v44 = v41[7];
    double v45 = v41[15];
    while (1)
    {
      double v46 = v38
          + *(double *)&CA::Render::compute_occlusion_data(CA::Render::occlusion_closure *,CA::Render::LayerNode *)::mx[v42]
          * v39;
      double v47 = v37
          + *(double *)&CA::Render::compute_occlusion_data(CA::Render::occlusion_closure *,CA::Render::LayerNode *)::my[v42]
          * v40;
      double v48 = v45 + v46 * v43 + v47 * v44;
      if (v48 <= 0.0) {
        break;
      }
      double v49 = v41[1];
      double v50 = v41[13];
      double v51 = v41[5];
      double v52 = 1.0 / v48;
      *(double *)((char *)&v83 + v42 * 8) = (v41[12] + *v41 * v46 + v41[4] * v47) * v52;
      *(double *)((char *)&v81 + v42 * 8) = (v50 + v49 * v46 + v51 * v47) * v52;
      *(double *)((char *)&v79 + v42 * 8) = (v41[14] + v41[2] * v46 + v41[6] * v47) * v52;
      if (++v42 == 4)
      {
        unint64_t v6 = CA::Render::alloc_occlusion_data(a1, 4);
        unint64_t v53 = *(_OWORD **)(v6 + 80);
        long long v54 = v84;
        *unint64_t v53 = v83;
        v53[1] = v54;
        double v55 = *(_OWORD **)(v6 + 88);
        long long v56 = v82;
        *double v55 = v81;
        v55[1] = v56;
        uint64_t v57 = *(_OWORD **)(v6 + 96);
        long long v58 = v80;
        _OWORD *v57 = v79;
        v57[1] = v58;
        unsigned int v8 = *(_DWORD *)(v6 + 72);
        goto LABEL_5;
      }
    }
    int v5 = 5;
  }
  unint64_t v6 = CA::Render::alloc_occlusion_data(a1, v5);
  unsigned int v8 = CA::Render::clip_layer((CA::Render *)a2, *(CA::Render::LayerNode **)(v6 + 80), *(double **)(v6 + 88), *(double **)(v6 + 96), v7);
  if (!v8) {
    goto LABEL_27;
  }
  *(_DWORD *)(v6 + 72) = v8;
LABEL_5:
  double v10 = *(double **)(v6 + 80);
  double v11 = *(double **)(v6 + 88);
  double v12 = *v10;
  *(double *)(v6 + 16) = *v10;
  *(double *)unint64_t v6 = v12;
  double v13 = *v11;
  *(double *)(v6 + 24) = *v11;
  *(double *)(v6 + 8) = v13;
  if (v8 >= 2)
  {
    uint64_t v14 = v8 - 1;
    uint64_t v15 = v11 + 1;
    double v16 = v10 + 1;
    double v17 = v13;
    double v18 = v12;
    do
    {
      double v19 = *v16;
      if (*v16 >= v18)
      {
        double v20 = *v16;
      }
      else
      {
        *(double *)unint64_t v6 = v19;
        double v20 = *v16;
        double v18 = v19;
      }
      if (v20 > v12)
      {
        *(double *)(v6 + 16) = v20;
        double v12 = v20;
      }
      double v21 = *v15;
      if (*v15 >= v17)
      {
        double v22 = *v15;
      }
      else
      {
        *(double *)(v6 + 8) = v21;
        double v22 = *v15;
        double v17 = v21;
      }
      if (v22 > v13)
      {
        *(double *)(v6 + 24) = v22;
        double v13 = v22;
      }
      ++v15;
      ++v16;
      --v14;
    }
    while (v14);
  }
  double v23 = *(CA::Mat4Impl **)(a2 + 56);
  if (!v23)
  {
LABEL_37:
    *(void *)(v6 + 32) = 0;
    *(void *)(v6 + 40) = 0;
    *(_OWORD *)(v6 + 48) = xmmword_184997D50;
    return v6;
  }
  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  BOOL v24 = *(double **)(v6 + 96);
  double v25 = v10[1];
  double v26 = v11[1];
  double v27 = v24[1];
  double v28 = v10[2];
  double v29 = v11[2];
  double v30 = v24[2];
  double v31 = v29 * (*v24 - v27) + (v30 - *v24) * v26 + (v27 - v30) * *v11;
  double v32 = (v28 - *v10) * v27 + (v25 - v28) * *v24 + v30 * (*v10 - v25);
  double v33 = v28 * (*v11 - v26) + (v29 - *v11) * v25 + (v26 - v29) * *v10;
  double v34 = v32 * v32 + v33 * v33 + v31 * v31;
  if (fabs(v34) <= 0.1)
  {
    CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)&v71, v23, v9);
    double v31 = *(double *)&v72 * (1.0 / *((double *)&v78 + 1));
    double v32 = *(double *)&v74 * (1.0 / *((double *)&v78 + 1));
    double v33 = *(double *)&v76 * (1.0 / *((double *)&v78 + 1));
    double v34 = v31 * v31 + v32 * v32 + v33 * v33;
    if (v34 >= 0.0000999999975)
    {
      double v35 = *(double *)&v78 * (1.0 / *((double *)&v78 + 1));
      goto LABEL_40;
    }
LABEL_27:
    *(void *)(v6 + 64) = *a1;
    *a1 = v6;
    return 0;
  }
  double v35 = -(v27 * *v11 - v26 * *v24) * v28 + -(v29 * *v24 - v30 * *v11) * v25 + -(v30 * v26 - v29 * v27) * *v10;
LABEL_40:
  if (fabs(v34 + -1.0) > 0.0001)
  {
    double v69 = 1.0 / sqrt(v34);
    double v31 = v69 * v31;
    double v32 = v69 * v32;
    double v33 = v69 * v33;
    double v35 = v69 * v35;
  }
  if (v33 < 0.0)
  {
    double v31 = -v31;
    double v32 = -v32;
    double v33 = -v33;
    double v35 = -v35;
    *(unsigned char *)(v6 + 104) = 1;
  }
  *(double *)(v6 + 32) = v31;
  *(double *)(v6 + 40) = v32;
  *(double *)(v6 + 48) = v33;
  *(double *)(v6 + 56) = v35;
  return v6;
}

unint64_t CA::Render::alloc_occlusion_data(unint64_t *a1, int a2)
{
  uint64_t v2 = a1;
  unsigned int v3 = (a2 + 1) & 0xFFFFFFFE;
  unint64_t result = *a1;
  if (!result)
  {
LABEL_7:
    unint64_t result = (x_heap_malloc((uint64_t *)v2[1], 24 * v3 + 128) + 15) & 0xFFFFFFFFFFFFFFF0;
    *(_DWORD *)(result + 76) = v3;
    uint64_t v6 = result + 112 + 8 * v3;
    *(void *)(result + 80) = result + 112;
    *(void *)(result + 88) = v6;
    *(void *)(result + 96) = v6 + 8 * v3;
    goto LABEL_8;
  }
  if (*(_DWORD *)(result + 76) < v3)
  {
    while (1)
    {
      unint64_t v5 = result;
      unint64_t result = *(void *)(result + 64);
      if (!result) {
        goto LABEL_7;
      }
      if (*(_DWORD *)(result + 76) >= v3)
      {
        uint64_t v2 = (unint64_t *)(v5 + 64);
        break;
      }
    }
  }
  *uint64_t v2 = *(void *)(result + 64);
LABEL_8:
  *(_DWORD *)(result + 72) = v3;
  *(unsigned char *)(result + 104) = 0;
  return result;
}

uint64_t CA::Render::in_positive_half_space(double *a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a2 + 72);
  if (!v2) {
    return 1;
  }
  unsigned int v3 = *(double **)(a2 + 80);
  uint64_t v4 = *(double **)(a2 + 88);
  double v5 = a1[4];
  double v6 = a1[5];
  double v7 = *(double **)(a2 + 96);
  double v8 = a1[6];
  double v9 = a1[7];
  if (v5 * *v3 + 0.0000999999975 + v6 * *v4 + v8 * *v7 + v9 < 0.0) {
    return 0;
  }
  unint64_t v11 = 0;
  double v12 = v3 + 1;
  double v13 = v4 + 1;
  uint64_t v14 = v7 + 1;
  while (v2 - 1 != v11)
  {
    double v15 = v5 * v12[v11] + 0.0000999999975 + v6 * v13[v11] + v8 * v14[v11] + v9;
    ++v11;
    if (v15 < 0.0) {
      return v11 >= v2;
    }
  }
  unint64_t v11 = *(unsigned int *)(a2 + 72);
  return v11 >= v2;
}

uint64_t CA::Render::in_negative_half_space(double *a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a2 + 72);
  if (!v2) {
    return 1;
  }
  unsigned int v3 = *(double **)(a2 + 80);
  uint64_t v4 = *(double **)(a2 + 88);
  double v5 = a1[4];
  double v6 = a1[5];
  double v7 = *(double **)(a2 + 96);
  double v8 = a1[6];
  double v9 = a1[7];
  if (v5 * *v3 + -0.0000999999975 + v6 * *v4 + v8 * *v7 + v9 > 0.0) {
    return 0;
  }
  unint64_t v11 = 0;
  double v12 = v3 + 1;
  double v13 = v4 + 1;
  uint64_t v14 = v7 + 1;
  while (v2 - 1 != v11)
  {
    double v15 = v5 * v12[v11] + -0.0000999999975 + v6 * v13[v11] + v8 * v14[v11] + v9;
    ++v11;
    if (v15 > 0.0) {
      return v11 >= v2;
    }
  }
  unint64_t v11 = *(unsigned int *)(a2 + 72);
  return v11 >= v2;
}

void CA::Render::insert_node_by_minz(CA::Render::LayerNode **a1, CA::Render::LayerNode *this)
{
  unint64_t v2 = this;
  CA::Render::LayerNode::update_z_range(this, this);
  if ((*((unsigned char *)v2 + 24) & 0x18) != 0)
  {
    uint64_t v4 = *a1;
    *a1 = v2;
    *(void *)unint64_t v2 = v4;
    *((void *)v2 + 1) = a1;
  }
  else
  {
    double v5 = (double *)a1;
    while (1)
    {
      double v5 = (double *)*((void *)v5 + 1);
      if (v5 == (double *)a1) {
        break;
      }
      if (v5[30] > *((double *)v2 + 30)) {
        goto LABEL_8;
      }
    }
    double v5 = (double *)a1;
LABEL_8:
    double v6 = (CA::Render::LayerNode *)*((void *)v2 + 1);
    uint64_t v4 = *(CA::Render::LayerNode **)v5;
    *((void *)v2 + 1) = v5;
    *(void *)double v5 = v2;
    *(void *)double v6 = v4;
    unint64_t v2 = v6;
  }
  *((void *)v4 + 1) = v2;
}

BOOL CA::Render::in_both_half_spaces(double *a1, uint64_t a2, double a3)
{
  uint64_t v3 = *(unsigned int *)(a2 + 72);
  if (!v3) {
    return 0;
  }
  int v4 = 0;
  int v5 = 0;
  double v6 = *(double **)(a2 + 80);
  double v7 = *(double **)(a2 + 88);
  double v8 = *(double **)(a2 + 96);
  do
  {
    double v9 = *v6++;
    double v10 = v9;
    double v11 = *v7++;
    double v12 = a1[7] + a1[4] * v10 + a1[5] * v11;
    double v13 = *v8++;
    double v14 = v12 + a1[6] * v13;
    v5 += COERCE_UNSIGNED_INT64(v14 + a3) >> 63;
    v4 += COERCE_UNSIGNED_INT64(a3 - v14) >> 63;
    --v3;
  }
  while (v3);
  if (v5) {
    BOOL v15 = v4 == 0;
  }
  else {
    BOOL v15 = 1;
  }
  return !v15;
}

CA::Render::LayerNode *CA::Render::LayerNode::split_node(CA::Render::LayerNode *this, double *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  int v4 = (CA::Shape *)*((void *)this + 26);
  if (v4)
  {
    CA::Shape::unref(v4);
    *((void *)this + 26) = 0;
  }
  int v5 = (CA::Render::LayerNode *)CA::Render::LayerNode::copy_node(this);
  CA::Render::LayerNode::clip_node(this, a2);
  float64x2_t v6 = vnegq_f64(*(float64x2_t *)(a2 + 2));
  v8[0] = vnegq_f64(*(float64x2_t *)a2);
  v8[1] = v6;
  CA::Render::LayerNode::clip_node(v5, (double *)v8);
  return v5;
}

double CA::Render::LayerNode::clip_node(CA::Render::LayerNode *this, double *a2)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  int v5 = (double *)malloc_type_zone_malloc(malloc_zone, 0x30uLL, 0x8BB15036uLL);
  uint64_t v6 = *((void *)this + 19);
  if (v6) {
    int v7 = *(_DWORD *)(v6 + 8) + 1;
  }
  else {
    int v7 = 1;
  }
  *((_DWORD *)v5 + 2) = v7;
  *(void *)int v5 = v6;
  _OWORD v5[2] = *a2;
  v5[3] = a2[1];
  v5[4] = a2[2];
  double result = a2[3];
  v5[5] = result;
  *((void *)this + 19) = v5;
  *((void *)this + 3) |= 4uLL;
  return result;
}

void *CA::Render::LayerNode::copy_node(CA::Render::LayerNode *this)
{
  unint64_t v2 = CA::Render::LayerNodeAllocator::alloc_node(this);
  uint64_t v3 = v2;
  uint64_t v4 = *((void *)this + 4);
  v2[3] = *((void *)this + 3);
  if (v4)
  {
    int v5 = (atomic_uint *)(v4 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v4 + 8), 1u))
    {
      uint64_t v4 = 0;
      atomic_fetch_add(v5, 0xFFFFFFFF);
    }
  }
  v2[4] = v4;
  uint64_t v6 = *((void *)this + 15);
  if (v6)
  {
    int v7 = (atomic_uint *)(v6 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v6 + 8), 1u))
    {
      uint64_t v6 = 0;
      atomic_fetch_add(v7, 0xFFFFFFFF);
    }
  }
  v2[15] = v6;
  v2[5] = 0;
  v2[11] = *((void *)this + 11);
  uint64_t v8 = *((void *)this + 6);
  if (v8)
  {
    uint64_t v9 = (atomic_uint *)(v8 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v8 + 8), 1u))
    {
      uint64_t v8 = 0;
      atomic_fetch_add(v9, 0xFFFFFFFF);
    }
    v2[6] = v8;
  }
  double v10 = (CA::Render::LayerNode *)*((void *)this + 13);
  if (v10 != (CA::Render::LayerNode *)((char *)this + 96))
  {
    double v11 = v2 + 12;
    do
    {
      uint64_t v12 = CA::Render::LayerNode::copy_node(v10);
      double v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v11;
      *(void *)(v12 + 8) = v11;
      *double v11 = v12;
      *double v13 = v14;
      *(void *)(v14 + 8) = v13;
      double v10 = (CA::Render::LayerNode *)*((void *)v10 + 1);
    }
    while (v10 != (CA::Render::LayerNode *)((char *)this + 96));
  }
  *((_OWORD *)v3 + 11) = *((_OWORD *)this + 11);
  uint64_t v15 = *((void *)this + 16);
  if (v15) {
    atomic_fetch_add((atomic_uint *volatile)(v15 + 16), 1u);
  }
  v3[16] = v15;
  uint64_t v16 = *((void *)this + 17);
  if (v16) {
    atomic_fetch_add((atomic_uint *volatile)(v16 + 16), 1u);
  }
  v3[17] = v16;
  if (*((void *)this + 7))
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    double v18 = malloc_type_zone_malloc(malloc_zone, 0x80uLL, 0x8BB15036uLL);
    v3[7] = v18;
    double v19 = (_OWORD *)*((void *)this + 7);
    long long v20 = v19[1];
    long long v21 = v19[2];
    long long v22 = v19[3];
    _OWORD *v18 = *v19;
    v18[1] = v20;
    v18[2] = v21;
    v18[3] = v22;
    long long v23 = v19[5];
    long long v24 = v19[6];
    long long v25 = v19[7];
    v18[4] = v19[4];
    v18[5] = v23;
    v18[6] = v24;
    v18[7] = v25;
  }
  else
  {
    v3[7] = 0;
    long long v26 = *((_OWORD *)this + 4);
    v3[10] = *((void *)this + 10);
    *((_OWORD *)v3 + 4) = v26;
  }
  unint64_t v27 = *((void *)this + 26);
  if (v27) {
    v3[26] = CA::Shape::ref(v27);
  }
  unint64_t v28 = *((void *)this + 27);
  if (v28) {
    v3[27] = CA::Shape::ref(v28);
  }
  unint64_t v29 = *((void *)this + 28);
  if (v29) {
    v3[28] = CA::Shape::ref(v29);
  }
  unint64_t v30 = *((void *)this + 29);
  if (v30) {
    v3[29] = CA::Shape::ref(v30);
  }
  long long v31 = *((_OWORD *)this + 15);
  v3[19] = 0;
  double v32 = v3 + 19;
  *((_OWORD *)v3 + 15) = v31;
  *((_DWORD *)v3 + 29) = *((_DWORD *)this + 29);
  for (i = (uint64_t *)*((void *)this + 19); i; double v32 = v35)
  {
    double v34 = (malloc_zone_t *)get_malloc_zone();
    double v35 = malloc_type_zone_malloc(v34, 0x30uLL, 0x8BB15036uLL);
    *double v35 = 0;
    *((_DWORD *)v35 + 2) = *((_DWORD *)i + 2);
    v35[2] = i[2];
    v35[3] = i[3];
    _OWORD v35[4] = i[4];
    v35[5] = i[5];
    *double v32 = v35;
    uint64_t i = (uint64_t *)*i;
  }
  *((_DWORD *)v3 + 28) = *((_DWORD *)this + 28);
  uint64_t v36 = *((void *)this + 32);
  if (v36)
  {
    double v37 = (atomic_uint *)(v36 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v36 + 8), 1u))
    {
      uint64_t v36 = 0;
      atomic_fetch_add(v37, 0xFFFFFFFF);
    }
  }
  v3[32] = v36;
  uint64_t v38 = *((void *)this + 33);
  if (v38)
  {
    double v39 = (atomic_uint *)(v38 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v38 + 8), 1u))
    {
      uint64_t v38 = 0;
      atomic_fetch_add(v39, 0xFFFFFFFF);
    }
  }
  v3[33] = v38;
  return v3;
}

void CA::Render::Update::set_display_attributes(uint64_t a1, float *a2)
{
  long long v4 = *(_OWORD *)a2;
  long long v5 = *((_OWORD *)a2 + 1);
  long long v6 = *((_OWORD *)a2 + 3);
  *(_OWORD *)(a1 + 384) = *((_OWORD *)a2 + 2);
  *(_OWORD *)(a1 + 400) = v6;
  *(_OWORD *)(a1 + 352) = v4;
  *(_OWORD *)(a1 + 368) = v5;
  long long v7 = *((_OWORD *)a2 + 4);
  long long v8 = *((_OWORD *)a2 + 5);
  long long v9 = *((_OWORD *)a2 + 7);
  *(_OWORD *)(a1 + 448) = *((_OWORD *)a2 + 6);
  *(_OWORD *)(a1 + 464) = v9;
  *(_OWORD *)(a1 + 416) = v7;
  *(_OWORD *)(a1 + 432) = v8;
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (*(float *)&dword_1EB2ACB08 != 0.0) {
    *(_DWORD *)(a1 + 364) = dword_1EB2ACB08;
  }
  if (*(float *)&dword_1EB2ACB0C != 0.0) {
    *(_DWORD *)(a1 + 368) = dword_1EB2ACB0C;
  }
  if (*(float *)&dword_1EB2ACAE8 != 0.0) {
    *(_DWORD *)(a1 + 372) = dword_1EB2ACAE8;
  }
  float v10 = *(float *)&dword_1EB2ACB28;
  if (*(float *)&dword_1EB2ACB28 != 0.0)
  {
    float v11 = *(float *)(a1 + 364);
    float v12 = a2[5];
    if (*(float *)&dword_1EB2ACB28 >= v12) {
      float v10 = a2[5];
    }
    *(float *)(a1 + 372) = v10;
    *(float *)(a1 + 364) = (float)(v10 * v11) / v12;
  }
  unsigned int v13 = *(float *)&dword_1EB2ACB10;
  if (*(float *)&dword_1EB2ACB10) {
    *(_DWORD *)(a1 + 412) = v13;
  }
  else {
    unsigned int v13 = *(_DWORD *)(a1 + 412);
  }
  if (v13 != 5)
  {
    if (v13 == 6)
    {
      if (!*(unsigned char *)(a1 + 406)) {
        return;
      }
    }
    else if (v13 - 2 > 2)
    {
      return;
    }
  }
  *(unsigned char *)(a1 + 404) = 1;
}

CA::Render::Layer *CA::Render::Layer::set_contents_multiply_color(CA::Render::Layer *result, float a2, float a3, float a4, float a5)
{
  if (*((void *)result + 16)) {
    BOOL v6 = 0;
  }
  else {
    BOOL v6 = a2 == 1.0;
  }
  if (!v6 || a3 != 1.0 || a4 != 1.0 || a5 != 1.0)
  {
    double result = (CA::Render::Layer *)CA::Render::Layer::ensure_ext(result);
    *((float *)result + 67) = a2;
    *((float *)result + 68) = a3;
    *((float *)result + 69) = a4;
    *((float *)result + 70) = a5;
  }
  return result;
}

uint64_t CAImageQueueCollect(uint64_t a1)
{
  return CAImageQueueCollect_(a1, 0, 0);
}

void CA::OGL::Renderer::update_detached_layer(CA::OGL::Renderer *this, CA::Render::Handle *a2, CA::Render::Texture *a3, CA::OGL::Context **a4, void *a5)
{
  BOOL v6 = *a4;
  if ((*((unsigned char *)this + 98) & 1) == 0)
  {
    if (*((CA::OGL::Context **)a3 + 11) != v6 || (uint64_t v7 = *((void *)a3 + 10)) == 0) {
      uint64_t v7 = CA::OGL::Context::lookup_image_(*a4, a3, 1);
    }
    *(_DWORD *)(v7 + 20) = *((_DWORD *)v6 + 57);
    return;
  }
  uint64_t v10 = *((void *)v6 + 24);
  if (!*((void *)this + 2))
  {
    uint64_t v19 = 0;
    uint64_t v13 = 0;
    goto LABEL_67;
  }
  uint64_t v13 = CA::Render::Handle::lock_context(this);
  if (!v13)
  {
    uint64_t v19 = 0;
    goto LABEL_67;
  }
  uint64_t v16 = *((void *)this + 2);
  if (v16)
  {
    uint64_t v17 = *(void *)(v16 + 96);
    if (v17)
    {
      double v18 = (atomic_uint *)(v17 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v17 + 8), 1u))
      {
        uint64_t v17 = 0;
        atomic_fetch_add(v18, 0xFFFFFFFF);
      }
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  long long v20 = (CA::Render::LayerNode ***)*((void *)this + 5);
  if (v20) {
    int v38 = CA::Render::LayerNode::clear_above_and_black_below(v20, 0, v14, v15);
  }
  else {
    int v38 = 0;
  }
  uint64_t v19 = *(void *)(v13 + 384);
  if (v19) {
    atomic_fetch_add((atomic_uint *volatile)(v19 + 16), 1u);
  }
  CA::Render::Handle::unlock_context((atomic_uint *)v13, v12);
  if (!v17)
  {
    uint64_t v13 = 0;
    uint64_t v22 = 0;
    if (!v19) {
      goto LABEL_43;
    }
LABEL_33:
    if (!v22)
    {
      double v37 = a2;
      long long v25 = *(atomic_uint **)(v19 + 48);
      if ((atomic_uint *)v13 == v25)
      {
        long long v25 = (atomic_uint *)v13;
        if (!v13) {
          goto LABEL_66;
        }
      }
      else
      {
        if (v17 && atomic_fetch_add((atomic_uint *volatile)(v13 + 8), 0xFFFFFFFF) == 1) {
          (*(void (**)(uint64_t))(*(void *)v13 + 16))(v13);
        }
        if (!v25)
        {
          uint64_t v13 = 0;
          goto LABEL_66;
        }
        if (!atomic_fetch_add(v25 + 2, 1u))
        {
          uint64_t v13 = 0;
          atomic_fetch_add(v25 + 2, 0xFFFFFFFF);
LABEL_66:
          a2 = v37;
          goto LABEL_67;
        }
      }
      uint64_t v22 = (*(uint64_t (**)(atomic_uint *))(*(void *)v25 + 80))(v25);
      uint64_t v13 = (uint64_t)v25;
      a2 = v37;
    }
LABEL_43:
    if (!v22) {
      goto LABEL_67;
    }
    goto LABEL_44;
  }
  uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 80))(v17);
  if (!v21)
  {
    int v23 = *(unsigned __int8 *)(v17 + 12);
    if (v23 == 26)
    {
      uint64_t v21 = (*(uint64_t (**)(void))(**(void **)(v17 + 32) + 80))(*(void *)(v17 + 32));
      if (v21) {
        goto LABEL_22;
      }
      int v23 = *(unsigned __int8 *)(v17 + 12);
    }
    if (v23 == 25 && (uint64_t v24 = *(void *)(v17 + 32)) != 0) {
      uint64_t v22 = (*(uint64_t (**)(void))(**(void **)(v24 + 32) + 80))(*(void *)(v24 + 32));
    }
    else {
      uint64_t v22 = 0;
    }
    uint64_t v13 = v17;
    if (!v19) {
      goto LABEL_43;
    }
    goto LABEL_33;
  }
LABEL_22:
  uint64_t v22 = v21;
  uint64_t v13 = v17;
LABEL_44:
  if (*(_DWORD *)(v22 + 16) == *((_DWORD *)a3 + 4) && *(_DWORD *)(v22 + 20) == *((_DWORD *)a3 + 5))
  {
    long long v26 = a2;
    if (*(CA::OGL::Context **)(v22 + 88) != v6 || (uint64_t v27 = *(void *)(v22 + 80)) == 0) {
      uint64_t v27 = CA::OGL::Context::lookup_image_(v6, (CA::Render::Texture *)v22, 1);
    }
    uint64_t v28 = (*(uint64_t (**)(uint64_t, CA::OGL::Context *, uint64_t, uint64_t))(*(void *)v10 + 24))(v10, v6, v27, v22);
    if (v28) {
      *(_DWORD *)(v27 + 20) = *((_DWORD *)v6 + 57);
    }
    unsigned int v29 = *(_DWORD *)(v22 + 12);
    unsigned int v30 = (v29 >> 8) & 0x200;
    unsigned int v31 = (v29 >> 19) & 0x20 | (v29 >> 12) & 0x4000 | (v29 >> 14) & 0x800 | v30;
    if (*(_DWORD *)(v22 + 12) == 51) {
      uint64_t v32 = v31;
    }
    else {
      uint64_t v32 = v30;
    }
    if (v38)
    {
      if ((~*((_DWORD *)a4[1] + 67) & 0xC0) != 0) {
        int v33 = 256;
      }
      else {
        int v33 = 4352;
      }
      uint64_t v32 = v33 | v32;
    }
    if (v13 && *(unsigned char *)(v13 + 12) == 25)
    {
      unint64_t v34 = atomic_load((unint64_t *)(*(void *)(*(void *)(v13 + 16) + 24) + 8));
      unsigned int v35 = (v34 >> 35) & 0x8000 | v32;
      if (*(_DWORD *)(v13 + 272) == *((_DWORD *)v6 + 57)) {
        uint64_t v32 = v35 | 0x2000;
      }
      else {
        uint64_t v32 = v35;
      }
    }
    (*(void (**)(uint64_t, CA::OGL::Renderer *, CA::Render::Handle *, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 64))(v10, this, v26, v22, v28, v32);
    *((void *)this + 12) &= ~0x10000uLL;
    *((_WORD *)v6 + 416) |= 0x100u;
    goto LABEL_68;
  }
LABEL_67:
  (*(void (**)(uint64_t, CA::OGL::Renderer *, CA::Render::Handle *))(*(void *)v10 + 56))(v10, this, a2);
  *((void *)this + 12) &= ~0x8000uLL;
LABEL_68:
  if (v13 && atomic_fetch_add((atomic_uint *volatile)(v13 + 8), 0xFFFFFFFF) == 1) {
    (*(void (**)(uint64_t))(*(void *)v13 + 16))(v13);
  }
  if (v19 && atomic_fetch_add((atomic_uint *volatile)(v19 + 16), 0xFFFFFFFF) == 1)
  {
    CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v19, v36);
  }
}

void CA::OGL::Context::image_deleted(CA::OGL::Context *this, CA::Render::Object *a2, void *a3, void *a4)
{
  BOOL v6 = (os_unfair_lock_s *)((char *)a2 + 304);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 76);
  uint64_t v7 = x_hash_table_remove(*((void *)a2 + 39), (uint64_t)this);
  if (v7) {
    CA::OGL::Context::prepend_deleted_image(a2, v7);
  }
  long long v8 = (CA::OGL::Context *)(*(uint64_t (**)(CA::OGL::Context *))(*(void *)this + 88))(this);
  if (v8 != this)
  {
    uint64_t v9 = x_hash_table_lookup(*((void *)a2 + 39), (uint64_t)v8, 0);
    if (v9)
    {
      uint64_t v10 = v9;
      if (!*(unsigned char *)(v9 + 61) && !*(unsigned char *)(v9 + 60))
      {
        uint64_t v11 = *((void *)a2 + 41);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        uint64_t v13 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
        *uint64_t v13 = v10;
        v13[1] = v11;
        *((void *)a2 + 41) = v13;
        *(unsigned char *)(v10 + 60) = 1;
      }
      uint64_t v14 = *(void *)v10;
      if (*(void *)v10)
      {
        if (*(CA::Render::Object **)(v14 + 88) == a2) {
          *(void *)(v14 + 88) = 0;
        }
        *(void *)uint64_t v10 = 0;
      }
    }
  }

  os_unfair_lock_unlock(v6);
}

uint64_t CA::OGL::Context::lookup_image_(CA::OGL::Context *this, CA::Render::Texture *a2, int a3)
{
  uint64_t v6 = (*(uint64_t (**)(CA::Render::Texture *))(*(void *)a2 + 88))(a2);
  os_unfair_lock_lock((os_unfair_lock_t)this + 76);
  uint64_t v7 = x_hash_table_lookup(*((void *)this + 39), v6, 0);
  if (v7) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = a3 == 0;
  }
  if (!v8)
  {
    uint64_t v7 = (*(uint64_t (**)(CA::OGL::Context *))(*(void *)this + 632))(this);
    hash_table_modify(*((int **)this + 39), v6, v7, 0);
  }
  if (v7)
  {
    uint64_t v9 = *(void *)v7;
    if (*(void *)v7 && *(CA::OGL::Context **)(v9 + 88) == this) {
      *(void *)(v9 + 88) = 0;
    }
    uint64_t v10 = 0;
    *(void *)uint64_t v7 = a2;
    *(unsigned char *)(v7 + 56) = *(unsigned char *)(v7 + 56) & 0xC0 | *((unsigned char *)a2 + 12) & 0x3F;
    atomic_compare_exchange_strong((atomic_ullong *volatile)a2 + 11, (unint64_t *)&v10, (unint64_t)this);
    if (!v10) {
      *((void *)a2 + 10) = v7;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 76);
  return v7;
}

CA::Render::Image *CA::Render::Image::ogl_image_key(CA::Render::Image *this)
{
  double result = (CA::Render::Image *)*((void *)this + 15);
  if (!result || (*((unsigned char *)result + 13) & 8) == 0) {
    return this;
  }
  return result;
}

uint64_t CA::Render::Surface::ogl_image_key(uint64_t this)
{
  if (*(void *)(this + 96)) {
    return *(void *)(this + 96);
  }
  return this;
}

void CA::OGL::ShadowNode::apply(uint64_t a1, uint64_t *a2, uint64_t a3, double *a4)
{
  uint64_t v163 = *MEMORY[0x1E4F143B8];
  if (*a2)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v7 = **(CA::OGL::Context ***)(a1 + 8);
    uint64_t v8 = *(void *)(v6 + 24);
    if ((*(unsigned char *)(v6 + 33) & 8) == 0) {
      goto LABEL_37;
    }
    uint64_t v9 = *(void *)(v8 + 40);
    uint64_t v10 = v9 & 0xA00000000;
    if ((v9 & 0x400000000) != 0)
    {
      long long v13 = *(_OWORD *)(v8 + 80);
      long long v136 = *(_OWORD *)(v8 + 64);
      long long v137 = v13;
      uint64_t v14 = *((void *)v7 + 2);
      if (*(unsigned __int8 *)(v14 + 480) >= 2u) {
        *(unsigned char *)(v14 + 481) |= 1u;
      }
      uint64_t v15 = *(void *)(v8 + 128);
      if (v15)
      {
        uint64_t v16 = *(void *)(v15 + 72);
        if (v16)
        {
          unint64_t v129 = *(float32x4_t **)(v15 + 216);
          double v40 = *(float *)(v15 + 224);
          float16x4_t v126 = vcvt_f16_f32(*(float32x4_t *)(v15 + 200));
          CA::OGL::emit_shadow_uneven_round_rect(v7, (float64x2_t *)&v136, (float32x2_t *)&v129, (double *)(v16 + 24), &v126, *(unsigned __int8 *)(v8 + 33), (*(void *)(v8 + 40) >> 33) & 1, v10 == 0x800000000, v40, *(_DWORD *)(v8 + 40) & 3, *(void *)(*((void *)v7 + 31) + 24));
          goto LABEL_37;
        }
        unint64_t v129 = *(float32x4_t **)(v15 + 216);
        double v17 = *(float *)(v15 + 228);
        double v18 = *(float *)(v15 + 224);
        float32x4_t v19 = *(float32x4_t *)(v15 + 200);
      }
      else
      {
        *(double *)&unint64_t v129 = -32.0;
        float32x4_t v19 = (float32x4_t)xmmword_184997DF0;
        double v18 = 3.0;
        double v17 = 0.0;
      }
      float16x4_t v125 = vcvt_f16_f32(v19);
      CA::OGL::emit_shadow_round_rect(v7, (float64x2_t *)&v136, (float32x2_t *)&v129, &v125, *(unsigned __int8 *)(v8 + 33), (*(void *)(v8 + 40) >> 33) & 1, v10 == 0x800000000, *(void *)(v8 + 40) & 3, v17, v18, *(_WORD *)(v8 + 38) & 0xF, *(void *)(a1 + 80));
      goto LABEL_37;
    }
    uint64_t v11 = *(void *)(v8 + 128);
    if (v11 && *(void *)(v11 + 120))
    {
      uint64_t v12 = *((void *)v7 + 2);
      if (*(unsigned __int8 *)(v12 + 480) <= 1u || (*(unsigned char *)(v12 + 481) |= 1u, (uint64_t v11 = *(void *)(v8 + 128)) != 0))
      {
        float64_t v38 = *(double *)(v11 + 216);
        float32x4_t v39 = *(float32x4_t *)(v11 + 200);
      }
      else
      {
        float32x4_t v39 = (float32x4_t)xmmword_184997DF0;
        float64_t v38 = -32.0;
      }
      *(float64_t *)&long long v136 = v38;
      *(float16x4_t *)&v124[1] = vcvt_f16_f32(v39);
      CA::OGL::emit_shadow_path((uint64_t)v7);
      goto LABEL_37;
    }
    *(unsigned char *)(*((void *)v7 + 2) + 481) &= ~1u;
    uint64_t v20 = *(void *)(v8 + 128);
    if (v20)
    {
      float v21 = *(float *)(v20 + 224);
      unint64_t v22 = *(void *)(v20 + 216);
      float16x4_t v23 = vcvt_f16_f32(*(float32x4_t *)(v20 + 200));
    }
    else
    {
      float16x4_t v23 = (float16x4_t)0x3C00000000000000;
      unint64_t v22 = 0xC040000000000000;
      float v21 = 3.0;
    }
    unsigned int v24 = *(unsigned __int8 *)(v8 + 33);
    uint64_t v25 = *(void *)(v8 + 40);
    uint64_t v26 = *a2;
    uint64_t v27 = *(void *)(a1 + 80);
    *(void *)&long long v139 = 0;
    long long v137 = 0u;
    long long v138 = 0u;
    HIDWORD(v138) = 15;
    *(double *)&unint64_t v129 = 0.0;
    *(void *)&long long v146 = 0;
    if ((*(unsigned char *)(v27 + 144) & 0x10) != 0)
    {
      unint64_t v121 = v22;
      CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v27, (double *)&v129, (double *)&v146, a4);
      unint64_t v22 = v121;
      double v29 = *(double *)&v129;
      double v28 = *(double *)&v146;
    }
    else
    {
      double v28 = *(double *)(v27 + 128);
      *(double *)&unint64_t v129 = v28;
      *(double *)&long long v146 = v28;
      double v29 = v28;
    }
    float v30 = v29;
    float v31 = v28;
    *(float *)&long long v136 = v21 * v30;
    *((float *)&v136 + 1) = v21 * v31;
    _D0 = (int16x4_t)vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)v27, *(float *)&v22), *(float64x2_t *)(v27 + 32), *((float *)&v22 + 1)));
    *((int16x4_t *)&v136 + 1) = _D0;
    LOBYTE(v139) = 32 * (v10 == 0x800000000);
    if (byte_1EB2ACC6F)
    {
      float16x4_t v23 = (float16x4_t)0x3C00340000003A00;
    }
    else if (*(void *)&v23 == 0x3C003C003C003C00)
    {
      *(float *)_D0.i32 = (float)v24 * 0.0039216;
      __asm { FCVT            H0, S0 }
      double v37 = COERCE_DOUBLE(vdup_lane_s16(_D0, 0));
LABEL_31:
      double v41 = COERCE_DOUBLE(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(*(float16x4_t *)(*((void *)v7 + 31) + 32)), vcvtq_f32_f16(*(float16x4_t *)&v37))));
      if (*(void *)(*((void *)v7 + 31) + 32) != 0x3C003C003C003C00) {
        double v37 = v41;
      }
      *(double *)(*((void *)v7 + 2) + 8) = v37;
      if ((v25 & 0x200000000) != 0) {
        char v42 = 12;
      }
      else {
        char v42 = 11;
      }
      *(unsigned char *)(*((void *)v7 + 2) + 16) = v42;
      (*(void (**)(CA::OGL::Context *, uint64_t, long long *, void, float, float))(*(void *)v7 + 848))(v7, v26, &v136, 0, 1.0, 1.0);
      *(unsigned char *)(*((void *)v7 + 2) + 16) = 0;
LABEL_37:
      int v43 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t))(*(void *)v7 + 184))(v7, 39);
      uint64_t v49 = *(void *)(*(void *)(a1 + 16) + 32);
      if (v43)
      {
        if ((v49 & 0x100000000) != 0)
        {
          uint64_t v50 = *(void *)(v8 + 40);
          if ((v50 & 0x1000000000) == 0)
          {
            float v51 = 1.0;
            if ((v50 & 0x4000000000) == 0) {
              float v51 = 0.0;
            }
            *(double *)&unint64_t v129 = 0.0;
            goto LABEL_52;
          }
        }
        if ((v49 & 0x40) != 0)
        {
          uint64_t v52 = *(void *)(v8 + 40);
          if ((v52 & 0x2000000000) == 0)
          {
            float v51 = 1.0;
            if ((v52 & 0x4000000000) == 0) {
              float v51 = 0.0;
            }
            *(double *)&unint64_t v129 = 0.0;
            if ((v49 & 0x100000000) == 0)
            {
              float16x4_t v53 = 0;
              double v54 = 0.0;
              goto LABEL_105;
            }
LABEL_52:
            float64x2_t v59 = *(float32x4_t **)(v8 + 128);
            if (v59)
            {
              double v54 = v59[18].f32[3];
              float16x4_t v60 = vcvt_f16_f32(v59[19]);
              float v61 = v59[20].f32[0];
            }
            else
            {
              HIWORD(v129) = 15360;
              float v61 = 0.0;
              double v54 = 0.0;
              float16x4_t v60 = (float16x4_t)v129;
            }
            float16x4_t v53 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v60), v61));
            if ((v49 & 0x40) == 0)
            {
              float16x4_t v108 = 0;
              goto LABEL_108;
            }
LABEL_105:
            unint64_t v109 = *(float32x4_t **)(v8 + 128);
            if (v109)
            {
              double v110 = v109[14].f32[3];
              float16x4_t v108 = vcvt_f16_f32(v109[15]);
LABEL_109:
              uint64_t v111 = *a2;
              int v112 = *(_DWORD *)(*a2 + 40);
              int v113 = *(_DWORD *)(*a2 + 44);
              if (v112 <= v113) {
                int v114 = *(_DWORD *)(*a2 + 44);
              }
              else {
                int v114 = *(_DWORD *)(*a2 + 40);
              }
              v47.i32[0] = 1073741822;
              v48.i32[0] = v114;
              int8x16_t v115 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v48, v47), 0);
              uint64_t v116 = *(void *)(v111 + 32);
              v117.i64[0] = (int)v116;
              v117.i64[1] = SHIDWORD(v116);
              int8x16_t v118 = vbslq_s8(v115, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v117));
              double v119 = (double)v112;
              double v120 = (double)v113;
              if (v114 > 1073741822)
              {
                double v119 = 1.79769313e308;
                double v120 = 1.79769313e308;
              }
              long long v136 = (__int128)v118;
              *(double *)&long long v137 = v119;
              *((double *)&v137 + 1) = v120;
              v124[0] = *(double *)&v53;
              float16x4_t v123 = v108;
              CA::OGL::emit_large_brim(v7, v111, (float64x2_t *)&v136, v124, &v123, *(CA::Mat4Impl **)(a1 + 80), 0, v54, v51, v110, 0.05);
LABEL_115:
              *(unsigned char *)(*((void *)v7 + 2) + 481) &= ~1u;
              return;
            }
            float16x4_t v108 = (float16x4_t)0x3C00000000000000;
LABEL_108:
            double v110 = 0.0;
            goto LABEL_109;
          }
        }
      }
      if ((v49 & 0x100000000) != 0)
      {
        double v55 = *(float32x4_t **)(v8 + 128);
        if (v55)
        {
          double v56 = v55[18].f32[3];
          float16x4_t v57 = vcvt_f16_f32(v55[19]);
          v45.i32[0] = v55[20].i32[0];
          uint64_t v58 = *(void *)(v8 + 40);
          v46.i32[0] = v55[14].i32[1];
        }
        else
        {
          float16x4_t v57 = (float16x4_t)0x3C00000000000000;
          uint64_t v58 = *(void *)(v8 + 40);
          double v56 = 0.0;
          v45.i64[0] = 0;
          v46.i32[0] = 0;
        }
        if ((v58 & 0x4000000000) != 0) {
          float v62 = 1.0;
        }
        else {
          float v62 = 0.0;
        }
        int32x4_t v63 = (int32x4_t)vmulq_n_f32(vcvtq_f32_f16(v57), *(float *)v45.i32);
        float16x4_t v64 = vcvt_f16_f32((float32x4_t)v63);
        if ((v58 & 0x1000000000) != 0)
        {
          int v77 = *(_WORD *)(v8 + 38) & 0xF;
          *(double *)v46.i64 = *(float *)v46.i32;
          long long v78 = *(_OWORD *)(v8 + 80);
          long long v136 = *(_OWORD *)(v8 + 64);
          long long v137 = v78;
          float16x4_t v122 = v64;
          CA::OGL::emit_rim_rounded_rect(v7, (float64x2_t *)&v136, &v122, (double *)(v58 & 3), v77, *(CA::Mat4Impl **)(*((void *)v7 + 31) + 24), v56, v62, v46, *(double *)v46.i64);
        }
        else
        {
          uint64_t v65 = *a2;
          int v66 = *(_DWORD *)(*a2 + 40);
          int v67 = *(_DWORD *)(*a2 + 44);
          if (v66 <= v67) {
            int v68 = *(_DWORD *)(*a2 + 44);
          }
          else {
            int v68 = *(_DWORD *)(*a2 + 40);
          }
          v63.i32[0] = 1073741822;
          v45.i32[0] = v68;
          int8x16_t v69 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v45, v63), 0);
          uint64_t v70 = *(void *)(v65 + 32);
          v71.i64[0] = (int)v70;
          v71.i64[1] = SHIDWORD(v70);
          int8x16_t v72 = vbslq_s8(v69, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v71));
          double v73 = (double)v66;
          double v74 = (double)v67;
          if (v68 > 1073741822)
          {
            double v73 = 1.79769313e308;
            double v74 = 1.79769313e308;
          }
          float32x4_t v149 = (float32x4_t)v72;
          double v150 = v73;
          double v151 = v74;
          uint64_t v75 = *(void *)(a1 + 80);
          if (byte_1EB2ACC6F) {
            float16x4_t v64 = (float16x4_t)0x3C00000000003A00;
          }
          *(unsigned char *)(*((void *)v7 + 2) + 481) |= 1u;
          *(unsigned char *)(*((void *)v7 + 2) + 16) = 57;
          uint64_t v145 = 0;
          long long v136 = xmmword_184997D50;
          long long v137 = 0u;
          long long v138 = xmmword_184997D60;
          long long v139 = 0u;
          long long v140 = 0u;
          long long v141 = xmmword_184997D50;
          long long v142 = 0u;
          long long v143 = xmmword_184997D60;
          __asm { FMOV            V0.2D, #1.0 }
          long long v144 = _Q0;
          *(double *)&unint64_t v129 = COERCE_DOUBLE(&v149);
          uint64_t v130 = &v136;
          int v131 = 63;
          uint64_t v132 = 0;
          uint64_t v134 = 0;
          uint64_t v133 = 0;
          int v135 = 0;
          double v127 = 0.0;
          double v128 = 0.0;
          if ((*(unsigned char *)(v75 + 144) & 0x10) != 0)
          {
            CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v75, &v128, &v127, v44);
          }
          else
          {
            double v127 = *(double *)(v75 + 128);
            double v128 = v127;
          }
          CA::OGL::Context::bind_surface((uint64_t)v7, v65, 0, 0, 0, 0.0);
          float32x4_t v162 = vcvtq_f32_f16(v64);
          double v79 = v128;
          if (v128 >= v127) {
            double v79 = v127;
          }
          float v80 = v79 * v56;
          if (v80 > 5.0) {
            float v80 = 5.0;
          }
          if (v80 >= 0.0) {
            float v81 = v80;
          }
          else {
            float v81 = 0.0;
          }
          *(void *)&double v160 = LODWORD(v81);
          float v161 = v62;
          (*(void (**)(CA::OGL::Context *, void, uint64_t, uint64_t, float32x4_t *))(*(void *)v7 + 1000))(v7, 0, 4, 1, &v162);
          (*(void (**)(CA::OGL::Context *, uint64_t, uint64_t, uint64_t, double *))(*(void *)v7 + 1000))(v7, 1, 3, 1, &v160);
          *(double *)&long long v146 = *(double *)v149.i64 - v81;
          *((void *)&v146 + 1) = v149.i64[0];
          *(double *)&long long v147 = v150 + *(double *)v149.i64;
          *((double *)&v147 + 1) = v150 + *(double *)v149.i64 + v81;
          *(double *)v158.i64 = *(double *)&v149.i64[1] - v81;
          v158.i64[1] = v149.i64[1];
          v159.f64[0] = v151 + *(double *)&v149.i64[1];
          v159.f64[1] = v151 + *(double *)&v149.i64[1] + v81;
          float v155 = -v81;
          LODWORD(v156) = 0;
          float v82 = v150;
          float v83 = v150 + v81;
          *((float *)&v156 + 1) = v82;
          float v157 = v83;
          *(float *)&double v152 = -v81;
          HIDWORD(v152) = 0;
          float v84 = v151;
          float v85 = v151 + v81;
          float v153 = v84;
          float v154 = v85;
          CA::OGL::emit_nine_part_rect((uint64_t)v7, (uint64_t)&v129, (uint64_t)&v146, (uint64_t)&v158, (uint64_t)&v155, (uint64_t)&v152, 0, 0, 0);
          CA::OGL::Context::unbind_surface(v7, v65, 0);
          *(unsigned char *)(*((void *)v7 + 2) + 16) = 0;
        }
      }
      *(unsigned char *)(*((void *)v7 + 2) + 481) |= 1u;
      long long v147 = 0u;
      long long v148 = 0u;
      long long v146 = 0u;
      CA::Shape::operator=((uint64_t)&v146, (_DWORD *)(*a2 + 32));
      uint64_t v87 = (CA::Shape *)CA::Shape::intersect((uint64_t)&v146, *(void *)(a1 + 64));
      if (!byte_1EB2ACC6E)
      {
        double v90 = (_DWORD *)*a2;
        long long v136 = 0uLL;
        CA::OGL::emit_combine((uint64_t)v7, 1u, v90, 0, v87, (unsigned int *)&v136);
      }
      if ((*(unsigned char *)(*(void *)(a1 + 16) + 32) & 0x40) != 0)
      {
        uint64_t v91 = *a2;
        int v92 = *(_DWORD *)(v91 + 40);
        int v93 = *(_DWORD *)(v91 + 44);
        if (v92 <= v93) {
          int v94 = *(_DWORD *)(v91 + 44);
        }
        else {
          int v94 = *(_DWORD *)(v91 + 40);
        }
        v88.i32[0] = 1073741822;
        v89.i32[0] = v94;
        int8x16_t v95 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v89, v88), 0);
        uint64_t v96 = *(void *)(v91 + 32);
        v97.i64[0] = (int)v96;
        v97.i64[1] = SHIDWORD(v96);
        int8x16_t v98 = vbslq_s8(v95, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v97));
        double v99 = (double)v92;
        double v100 = (double)v93;
        if (v94 > 1073741822)
        {
          double v99 = 1.79769313e308;
          double v100 = 1.79769313e308;
        }
        int8x16_t v158 = v98;
        v159.f64[0] = v99;
        v159.f64[1] = v100;
        unint64_t v101 = *(float32x4_t **)(v8 + 128);
        if (v101)
        {
          float16x4_t v102 = vcvt_f16_f32(v101[15]);
          double v103 = v101[14].f32[3];
        }
        else
        {
          float16x4_t v102 = (float16x4_t)0x3C00000000000000;
          double v103 = 0.0;
        }
        uint64_t v104 = *(void *)(a1 + 80);
        if (byte_1EB2ACC6F) {
          float16x4_t v102 = (float16x4_t)0x3C0034CD34CD3A66;
        }
        *(unsigned char *)(*((void *)v7 + 2) + 481) |= 1u;
        *(unsigned char *)(*((void *)v7 + 2) + 16) = 57;
        uint64_t v145 = 0;
        long long v136 = xmmword_184997D50;
        long long v137 = 0u;
        long long v138 = xmmword_184997D60;
        long long v139 = 0u;
        long long v140 = 0u;
        long long v141 = xmmword_184997D50;
        long long v142 = 0u;
        long long v143 = xmmword_184997D60;
        __asm { FMOV            V0.2D, #1.0 }
        long long v144 = _Q0;
        *(double *)&unint64_t v129 = COERCE_DOUBLE(&v158);
        uint64_t v130 = &v136;
        int v131 = 63;
        uint64_t v132 = 0;
        uint64_t v134 = 0;
        uint64_t v133 = 0;
        int v135 = 0;
        double v152 = 0.0;
        double v160 = 0.0;
        if ((*(unsigned char *)(v104 + 144) & 0x10) != 0)
        {
          CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v104, &v152, &v160, v86);
        }
        else
        {
          double v152 = *(double *)(v104 + 128);
          double v160 = v152;
        }
        CA::OGL::Context::bind_surface((uint64_t)v7, v91, 0, 0, 0, 0.0);
        float32x4_t v149 = vcvtq_f32_f16(v102);
        double v106 = v152;
        if (v152 >= v160) {
          double v106 = v160;
        }
        float v107 = v106 * v103;
        if (v107 > 5.0) {
          float v107 = 5.0;
        }
        if (v107 < 0.0) {
          float v107 = 0.0;
        }
        float v155 = v107;
        uint64_t v156 = 1065353216;
        (*(void (**)(CA::OGL::Context *, void, uint64_t, uint64_t, float32x4_t *))(*(void *)v7 + 1000))(v7, 0, 4, 1, &v149);
        (*(void (**)(CA::OGL::Context *, uint64_t, uint64_t, uint64_t, float *))(*(void *)v7 + 1000))(v7, 1, 3, 1, &v155);
        v162.i64[0] = 0;
        *(float32x2_t *)&v162.u32[2] = vcvt_f32_f64(v159);
        CA::OGL::emit_one_part_rect(v7, (uint64_t)&v129, (const CA::Transform *)&v162, 0, 0);
        CA::OGL::Context::unbind_surface(v7, v91, 0);
        *(unsigned char *)(*((void *)v7 + 2) + 16) = 0;
      }
      CA::Shape::unref(v87);
      goto LABEL_115;
    }
    double v37 = COERCE_DOUBLE(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v23), (float)v24 * 0.0039216)));
    goto LABEL_31;
  }
}

BOOL CA::OGL::detach_contents(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  uint64_t v145 = *MEMORY[0x1E4F143B8];
  if (a3) {
    uint64_t v8 = *(__IOSurface **)(a3 + 112);
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *a1;
  uint64_t v10 = *(void *)(*a1 + 192);
  uint64_t v11 = *(void *)(*(void *)(a2 + 16) + 24);
  if ((v11 & 0x4000000) != 0)
  {
    uint64_t v12 = 0;
    if (!v10)
    {
LABEL_11:
      unsigned int v13 = 1;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v12 = *(void **)(*(void *)(a2 + 24) + 144);
    if (!v10) {
      goto LABEL_11;
    }
  }
  if ((*(_WORD *)(v9 + 832) & 2) != 0) {
    goto LABEL_11;
  }
  if ((*(void *)(*(void *)(a2 + 24) + 40) & 0x30) == 0x20)
  {
    unsigned int v13 = 27;
    goto LABEL_12;
  }
  uint64_t v16 = *(void *)(v9 + 248);
  if ((*(unsigned char *)(a3 + 13) & 0x10) == 0 && (*(unsigned char *)(a5 + 309) & 2) == 0)
  {
    unsigned int v13 = 2;
    goto LABEL_12;
  }
  uint64_t v17 = *(void *)(v9 + 16);
  if (*(void *)(v17 + 8) != 0x3C003C003C003C00)
  {
    unsigned int v13 = 3;
    goto LABEL_12;
  }
  if (*(_DWORD *)(v9 + 740))
  {
    unsigned int v13 = 4;
    goto LABEL_12;
  }
  if (*(void *)(v17 + 360))
  {
    unsigned int v13 = 5;
    goto LABEL_12;
  }
  if ((*(_WORD *)(v16 + 68) & 0x100) == 0)
  {
    unsigned int v13 = 6;
    goto LABEL_12;
  }
  if (*(void *)(v16 + 16))
  {
    unsigned int v13 = 8;
    goto LABEL_12;
  }
  if (!v12)
  {
    unsigned int v13 = 9;
    goto LABEL_12;
  }
  if ((v11 & 0x40) == 0)
  {
    unsigned int v13 = 10;
    goto LABEL_12;
  }
  if (*(unsigned char *)(a5 + 337))
  {
    unsigned int v13 = 11;
    goto LABEL_12;
  }
  int v20 = *(_DWORD *)(a5 + 308);
  if ((v20 & 0x400) != 0)
  {
    unsigned int v13 = 12;
    goto LABEL_12;
  }
  uint64_t v133 = *a1;
  if ((v20 & 9) != 0 && (*(_WORD *)(a2 + 40) & 0x3C0) != 0)
  {
    unsigned int v13 = 13;
    goto LABEL_12;
  }
  if ((*(_DWORD *)(a2 + 32) & 0x100006) != 0)
  {
    unsigned int v13 = 14;
    goto LABEL_12;
  }
  uint64_t v26 = a1[1];
  if ((*(_DWORD *)(v26 + 1084) & 0x100000) == 0)
  {
    unsigned int v13 = 15;
    goto LABEL_12;
  }
  if ((*(unsigned char *)(v26 + 271) & 0x20) != 0)
  {
    unsigned int v13 = 26;
    goto LABEL_12;
  }
  if (byte_1EB2ACBE6)
  {
    unsigned int v13 = 16;
    goto LABEL_12;
  }
  uint64_t v129 = v12[12];
  uint64_t v130 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 24))(v10, v133, a4, a3);
  if (!v130)
  {
    unsigned int v13 = 17;
    goto LABEL_12;
  }
  if ((*(unsigned char *)(a5 + 248) & 0x1F) != 0)
  {
    if ((*(unsigned char *)(a5 + 248) & 0x10) != 0)
    {
      unsigned int v13 = 18;
      if (*(double *)(a5 + 128) != 0.0 || *(double *)(a5 + 160) != 0.0) {
        goto LABEL_12;
      }
    }
    float64x2_t v28 = *(float64x2_t *)(a5 + 104);
    int64x2_t v29 = *(int64x2_t *)(a5 + 136);
    double v30 = *(double *)(a5 + 112);
    if (vabdd_f64(v30, *(double *)v29.i64) >= 0.001 || fabs(v30) >= 0.001)
    {
      unsigned int v13 = 19;
      if (fabs(vsubq_f64(v28, (float64x2_t)vdupq_laneq_s64(v29, 1)).f64[0]) >= 0.001 || fabs(v28.f64[0]) >= 0.001) {
        goto LABEL_12;
      }
      if (v30 <= 0.0 || *(double *)v29.i64 <= 0.0)
      {
        if (v30 >= 0.0 || *(double *)v29.i64 >= 0.0)
        {
          if (*(double *)v29.i64 > 0.0 && v30 < 0.0) {
            int v31 = 7;
          }
          else {
            int v31 = 4;
          }
        }
        else
        {
          int v31 = 5;
        }
      }
      else
      {
        int v31 = 6;
      }
      v28.f64[0] = *(float64_t *)(a5 + 112);
    }
    else
    {
      v29.i64[0] = *(void *)(a5 + 144);
      if (v28.f64[0] >= 0.0 || *(double *)&v29.i64[1] <= 0.0)
      {
        if (v28.f64[0] <= 0.0 || *(double *)&v29.i64[1] >= 0.0)
        {
          if (*(double *)&v29.i64[1] < 0.0 && v28.f64[0] < 0.0) {
            int v31 = 3;
          }
          else {
            int v31 = 0;
          }
        }
        else
        {
          int v31 = 1;
        }
      }
      else
      {
        int v31 = 2;
      }
    }
    if (v28.f64[0] < 0.0) {
      v28.f64[0] = -v28.f64[0];
    }
    if (*(double *)v29.i64 < 0.0) {
      *(double *)v29.i64 = -*(double *)v29.i64;
    }
    double v32 = (*(double *)v29.i64 + v28.f64[0]) * 0.5;
  }
  else
  {
    int v31 = 0;
    double v32 = 1.0;
  }
  unsigned int v35 = *(_DWORD *)(a3 + 12);
  int v36 = v31 ^ (v35 >> 11) & 1 ^ (*(_DWORD *)(a5 + 308) >> 11) & 1 ^ 1;
  if (!a6 && v32 < 1.0 || !a7 && v32 > 1.0) {
    v36 |= 8u;
  }
  if (v36 & 4) != 0 && (*(void *)(*(void *)(a2 + 16) + 24)) {
    v36 ^= 3u;
  }
  double v38 = *(double *)(a5 + 24);
  double v39 = *(double *)(a5 + 32);
  double v41 = *(double *)(a5 + 256);
  double v40 = *(double *)(a5 + 264);
  double v42 = v40 * *(double *)(a5 + 16);
  v141.f64[0] = v40 * *(double *)(a5 + 8);
  v141.f64[1] = v42;
  v142.f64[0] = v40 * v38 / v41;
  v142.f64[1] = v40 * v39;
  int v43 = v36 | (v35 >> 19) & 0x20;
  if ((v35 & 0x4000000) != 0) {
    v43 |= ~*(unsigned __int16 *)(a1[1] + 270) & 0x4000;
  }
  double v44 = (Rect *)(v43 | (v35 >> 14) & 0x800);
  *(_OWORD *)&v139[0].top = 0u;
  float64x2_t v140 = 0u;
  CA::OGL::Context::raster_round_rect((CA::OGL::Context *)buf, (const Rect *)*a1, (double *)(a5 + 40));
  if (*(int *)&buf[8] <= *(int *)&buf[12]) {
    int v47 = *(_DWORD *)&buf[12];
  }
  else {
    int v47 = *(_DWORD *)&buf[8];
  }
  v45.i32[0] = 1073741822;
  v46.i32[0] = v47;
  v48.i64[0] = *(int *)buf;
  v48.i64[1] = *(int *)&buf[4];
  double v49 = (double)*(int *)&buf[8];
  int8x16_t v127 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
  int8x16_t v50 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v46, v45), 0), v127, (int8x16_t)vcvtq_f64_s64(v48));
  double v51 = 1.79769313e308;
  if (v47 <= 1073741822) {
    double v51 = (double)*(int *)&buf[12];
  }
  else {
    double v49 = 1.79769313e308;
  }
  *(int8x16_t *)&v139[0].top = v50;
  v140.f64[0] = v49;
  v140.f64[1] = v51;
  (*(void (**)(uint64_t, Rect *))(*(void *)v10 + 32))(v10, v139);
  if ((*(unsigned char *)(v133 + 432) & 1) == 0)
  {
    *(double *)&v139[1] = (double)*(int *)(v133 + 212) - (*(double *)&v139[1] + v140.f64[1]);
    double v44 = (Rect *)(v44 ^ 1);
  }
  uint64_t v59 = v12[14];
  v53.i64[0] = v12[15];
  v60.i64[0] = (int)v59;
  v60.i64[1] = SHIDWORD(v59);
  int64x2_t v61 = v60;
  int v62 = v53.i32[1];
  v60.i64[0] = v53.i32[0];
  v60.i64[1] = v53.i32[1];
  int64x2_t v63 = v60;
  if (v53.i32[0] > v53.i32[1]) {
    int v62 = v12[15];
  }
  v53.i32[0] = v62;
  v54.i32[0] = 1073741822;
  float64x2_t v64 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v53, v54), 0), v127, (int8x16_t)vcvtq_f64_s64(v61));
  int8x16_t v65 = (int8x16_t)vcvtq_f64_s64(v63);
  int32x2_t v66 = vdup_n_s32(v62 > 1073741822);
  v67.i64[0] = v66.u32[0];
  v67.i64[1] = v66.u32[1];
  int8x16_t v68 = (int8x16_t)vcltzq_s64(vshlq_n_s64(v67, 0x3FuLL));
  int8x16_t v69 = (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  CA::OGL::clip_detached_rects(&v141, v139, v44, v52, v64, (float64x2_t)vbslq_s8(v68, v69, v65), *(double *)v68.i64, *(double *)v69.i64, v55, v56, v57, v58);
  if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcgtzq_f64(v142), (int32x4_t)vcgtzq_f64(v140))))))
  {
    unsigned int v13 = 25;
    goto LABEL_12;
  }
  uint64_t v71 = *(void *)(a1[1] + 16);
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  CA::Bounds::set_exterior((int32x4_t *)buf, v70, *(float64x2_t *)&v139[0].top, v140);
  BOOL v72 = CA::Shape::contains(v71, (const CA::Bounds *)buf);
  unsigned int v75 = v44 | 0x400;
  if (v72) {
    unsigned int v75 = v44;
  }
  unsigned int v128 = v75;
  uint64_t v76 = *(void *)(a2 + 24);
  uint64_t v77 = *(void *)(v76 + 96);
  if (v77)
  {
    if (*(unsigned char *)(v77 + 12) == 25)
    {
      uint64_t v78 = *(void *)(v76 + 144);
      if (v78)
      {
        if (*(void *)(v78 + 24))
        {
          unint64_t v79 = atomic_load((unint64_t *)(*(void *)(*(void *)(v77 + 16) + 24) + 8));
          int v80 = (v79 >> 35) & 0x8000 | v128;
          if (*(_DWORD *)(v77 + 272) == *(_DWORD *)(v133 + 228)) {
            int v81 = v80 | 0x2000;
          }
          else {
            int v81 = v80;
          }
          unsigned int v128 = v81;
        }
      }
    }
  }
  uint64_t v82 = *(void *)(v133 + 192);
  if (v82 && (uint64_t v83 = (*(uint64_t (**)(uint64_t))(*(void *)v82 + 16))(v82)) != 0)
  {
    float v84 = (CA::WindowServer::Display *)v83;
    unsigned int v85 = *(_DWORD *)(v83 + 624);
    int v126 = (v85 >> 2) & 1;
    BOOL v86 = (*(_WORD *)(v83 + 656) & 0x1800) == 0;
    if ((v85 & 4) != 0) {
      char v87 = CA::WindowServer::Display::clones_support_detaching(*(CA::WindowServer::Display **)(v83 + 40));
    }
    else {
      char v87 = 0;
    }
    if (((*(uint64_t (**)(CA::WindowServer::Display *))(*(void *)v84 + 1536))(v84) & 1) == 0)
    {
      *(float *)&double v73 = CA::WindowServer::Display::edr_headroom(v84);
      float v74 = 1.0;
      if (*(float *)&v73 != 1.0 && (*(_WORD *)(a3 + 336) & 4) == 0)
      {
        unsigned int v13 = 21;
        goto LABEL_12;
      }
    }
  }
  else
  {
    char v87 = 0;
    BOOL v86 = 0;
    LOBYTE(v126) = 0;
  }
  if ((v87 & 1) != 0 || v86)
  {
    if (CA::Render::LayerNode::clear_above_and_black_below(*(CA::Render::LayerNode ****)(a2 + 16), v126, v73, v74))
    {
      if ((~*(_DWORD *)(a1[1] + 268) & 0xC0) != 0) {
        int v88 = 256;
      }
      else {
        int v88 = 4352;
      }
      v128 |= v88;
    }
    else if (v87)
    {
      unsigned int v13 = 22;
      goto LABEL_12;
    }
  }
  int v138 = 0;
  if ((*(unsigned int (**)(uint64_t, void *, void, uint64_t, uint64_t, float64x2_t *, Rect *, void, int *))(*(void *)v10 + 40))(v10, v12, 0, a3, v130, &v141, v139, v128, &v138))
  {
    v12[12] = v12[12] & 0xFFFFFFFFFFFE7FFFLL | 0x8000;
    *(_DWORD *)(a4 + 20) = *(_DWORD *)(v133 + 228);
    CA::Render::updater_mark_detached_layer(*(CA::Render::Context **)(a2 + 16), (CA::Render::LayerNode *)((v129 & 0x8000) == 0));
    if ((*(unsigned int (**)(uint64_t, void *, void))(*(void *)v10 + 48))(v10, v12, 0))
    {
      *(unsigned char *)(*(void *)(v133 + 16) + 481) &= ~1u;
      *(unsigned char *)(*(void *)(v133 + 16) + 16) = 0;
      if (byte_1EB2ACBE2) {
        uint64_t v89 = 0x3804380400000000;
      }
      else {
        uint64_t v89 = 0;
      }
      *(void *)(*(void *)(v133 + 16) + 8) = v89;
      int8x16_t v136 = 0u;
      long long v137 = 0u;
      CA::OGL::Context::raster_round_rect((CA::OGL::Context *)buf, (const Rect *)*a1, (double *)(a5 + 40));
      if (*(int *)&buf[8] <= *(int *)&buf[12]) {
        int v92 = *(_DWORD *)&buf[12];
      }
      else {
        int v92 = *(_DWORD *)&buf[8];
      }
      v90.i32[0] = 1073741822;
      v91.i32[0] = v92;
      v93.i64[0] = *(int *)buf;
      v93.i64[1] = *(int *)&buf[4];
      int8x16_t v94 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v91, v90), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v93));
      double v95 = (double)*(int *)&buf[8];
      int8x16_t v136 = v94;
      double v96 = 1.79769313e308;
      if (v92 <= 1073741822) {
        double v96 = (double)*(int *)&buf[12];
      }
      else {
        double v95 = 1.79769313e308;
      }
      *(double *)&long long v137 = v95;
      *((double *)&v137 + 1) = v96;
      *(void *)long long buf = &v136;
      *(void *)&uint8_t buf[8] = &CA::identity_transform;
      *(_OWORD *)&uint8_t buf[16] = 0u;
      long long v144 = 0u;
      CA::OGL::emit_one_part_rect((CA::OGL::Context *)v133, (uint64_t)buf, 0, 0, 0);
      if (byte_1EB2ACBE2)
      {
        __int16 v114 = v138;
        if (v138)
        {
          int8x16_t v115 = *(float16x4_t **)(v133 + 16);
          if ((v138 & 0x2000) != 0)
          {
            float16x4_t v119 = (float16x4_t)0x3804000038040000;
          }
          else
          {
            __asm { FMOV            V1.4S, #0.75 }
            float16x4_t v119 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v115[1]), _Q1));
          }
          int v120 = 0;
          v115[1] = v119;
          double v121 = 0.0;
          do
          {
            double v122 = *(double *)v136.i64;
            if ((v114 & 0x2000) != 0)
            {
              double v124 = *(double *)&v137;
              double v123 = *(double *)&v136.i64[1] + (double)v120 * 0.03125 * *((double *)&v137 + 1);
              double v125 = *((double *)&v137 + 1) * 0.015625;
            }
            else
            {
              double v123 = *(double *)&v136.i64[1];
              double v122 = *(double *)v136.i64 + v121 * 0.03125 * *(double *)&v137;
              double v124 = *(double *)&v137 * 0.015625;
              double v125 = *((double *)&v137 + 1);
            }
            v135[0] = *(CA::Shape **)&v122;
            v135[1] = *(CA::Shape **)&v123;
            v135[2] = *(CA::Shape **)&v124;
            v135[3] = *(CA::Shape **)&v125;
            v134[0].i64[0] = (uint64_t)v135;
            v134[0].i64[1] = (uint64_t)&CA::identity_transform;
            memset(&v134[1], 0, 32);
            CA::OGL::emit_one_part_rect((CA::OGL::Context *)v133, (uint64_t)v134, 0, 0, 0);
            double v121 = v121 + 1.0;
            ++v120;
          }
          while (v120 != 32);
        }
      }
      if ((v129 & 0x8000) == 0)
      {
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        v134[0] = 0uLL;
        CA::Bounds::set_exterior((int32x4_t *)buf, v97, *(float64x2_t *)(a5 + 40), *(float64x2_t *)(a5 + 56));
        uint64_t v100 = v12[14];
        v101.i64[0] = v12[15];
        v102.i64[0] = (int)v100;
        v102.i64[1] = SHIDWORD(v100);
        int8x16_t v103 = (int8x16_t)vcvtq_f64_s64(v102);
        int v104 = v101.i32[1];
        v102.i64[0] = v101.i32[0];
        v102.i64[1] = v101.i32[1];
        int64x2_t v105 = v102;
        if (v101.i32[0] > v101.i32[1]) {
          int v104 = v12[15];
        }
        v101.i32[0] = v104;
        v99.i32[0] = 1073741822;
        float64x2_t v106 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v101, v99), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v103);
        int8x16_t v107 = (int8x16_t)vcvtq_f64_s64(v105);
        int32x2_t v108 = vdup_n_s32(v104 > 1073741822);
        v109.i64[0] = v108.u32[0];
        v109.i64[1] = v108.u32[1];
        CA::Bounds::set_exterior(v134, v98, v106, (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v109, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v107));
        if (*(_DWORD *)buf != v134[0].i32[0]
          || *(void *)&buf[4] != *(uint64_t *)((char *)v134[0].i64 + 4)
          || *(_DWORD *)&buf[12] != v134[0].i32[3])
        {
          v135[0] = (CA::Shape *)CA::Shape::new_shape((unsigned int *)buf);
          CA::shape_subtract(v135, (CA::Shape **)v134, v110);
          *(unsigned char *)(*(void *)(v133 + 16) + 481) |= 1u;
          uint64_t v111 = *(void *)(v133 + 16);
          *(unsigned char *)(v111 + 480) = 12;
          *(void *)(v111 + 8) = 0x3C00000000000000;
          int v112 = v135[0];
          int8x16_t v136 = 0uLL;
          CA::OGL::emit_combine(v133, 0, 0, 0, v135[0], (unsigned int *)&v136);
          uint64_t v113 = *(void *)(v133 + 16);
          *(unsigned char *)(v113 + 480) = *(unsigned char *)(v16 + 68);
          *(unsigned char *)(v113 + 481) &= ~1u;
          CA::Shape::unref(v112);
        }
      }
      unsigned int v13 = 0;
    }
    else
    {
      unsigned int v13 = 0;
      *(_WORD *)(v133 + 832) |= 0x200u;
    }
  }
  else
  {
    unsigned int v13 = 23;
  }
LABEL_12:
  if (v8)
  {
    IOSurfaceSetDetachModeCode();
    if (!byte_1EB2ACBEE) {
      goto LABEL_16;
    }
    IOSurfaceID ID = IOSurfaceGetID(v8);
  }
  else
  {
    if (!byte_1EB2ACBEE) {
      goto LABEL_16;
    }
    IOSurfaceID ID = 0;
  }
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    double v18 = x_log_category_CADebug;
    if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO))
    {
      float32x4_t v19 = CA::detach_string_coreanimation(CA::CADetachReasonCode)::names[v13];
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = ID;
      *(_WORD *)&uint8_t buf[8] = 2080;
      *(void *)&buf[10] = v19;
      _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_INFO, "[CA] Surface ID:0x%x detach result: %s", buf, 0x12u);
    }
  }
LABEL_16:
  if (v13 < 2) {
    return v13 == 0;
  }
  if (v10 && v12)
  {
    (*(void (**)(uint64_t, void *, void))(*(void *)v10 + 56))(v10, v12, 0);
  }
  else if (!v12)
  {
    goto LABEL_22;
  }
  v12[12] &= ~0x8000uLL;
LABEL_22:
  if (HIBYTE(xmmword_1EB2ACC10))
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      unsigned int v24 = x_log_category_ogl;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_FAULT))
      {
        uint64_t v25 = CA::detach_string_coreanimation(CA::CADetachReasonCode)::names[v13];
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v25;
        _os_log_impl(&dword_184668000, v24, OS_LOG_TYPE_FAULT, "Failed to detach surface code: %s", buf, 0xCu);
      }
    }
  }
  return v13 == 0;
}

void CA::OGL::CombineNode::apply(uint64_t a1, void *a2, uint64_t a3, double a4, int32x4_t a5, int32x4_t a6)
{
  v31[2] = *(int32x2_t *)MEMORY[0x1E4F143B8];
  uint64_t v8 = **(void **)(a1 + 8);
  *(void *)(*(void *)(v8 + 16) + 8) = *(void *)(a1 + 88);
  uint64_t v9 = *(void *)(v8 + 16);
  if (*(unsigned __int8 *)(v9 + 480) >= 2u) {
    *(unsigned char *)(v9 + 481) |= 1u;
  }
  float v10 = *(float *)a3;
  a5.i32[0] = *(_DWORD *)(a3 + 4);
  unsigned int v11 = *(unsigned __int8 *)(a1 + 224);
  uint64_t v12 = (_DWORD *)*a2;
  uint64_t v13 = a2[1];
  uint64_t v14 = *(CA::Shape **)(a1 + 64);
  uint64_t v15 = (unsigned int *)(a1 + 228);
  a6.i32[0] = 1.0;
  if (v10 == 1.0 && *(float *)a5.i32 == 1.0) {
    CA::OGL::emit_combine(v8, v11, v12, v13, v14, v15);
  }
  else {
    CA::OGL::emit_combine_scaled(v8, v11, (uint64_t)v12, v13, v14, v15, v10, a5, a6);
  }
  unsigned int v17 = *(_DWORD *)(a1 + 220);
  if ((v17 & 0xE0000) != 0)
  {
    uint64_t v20 = 0;
    v31[0] = 0;
    v31[1] = 0;
    char v21 = 1;
    do
    {
      char v22 = v21;
      float16x4_t v23 = (int32x2_t *)a2[v20];
      if (v23) {
        CA::BoundsImpl::Union(v31, v23[4], v23[5]);
      }
      char v21 = 0;
      uint64_t v20 = 1;
    }
    while ((v22 & 1) != 0);
    unsigned int v24 = -2147467200;
    switch((v17 >> 17) & 7)
    {
      case 1u:
        break;
      case 2u:
        unsigned int v24 = 8388736;
        break;
      case 3u:
        unsigned int v24 = -2147483520;
        break;
      case 5u:
        unsigned int v24 = -2139094912;
        if (*a2)
        {
          if ((*(unsigned char *)(*a2 + 69) & 8) != 0) {
            unsigned int v24 = 8388736;
          }
          else {
            unsigned int v24 = -2139094912;
          }
        }
        break;
      case 6u:
        unsigned int v24 = -2147450752;
        break;
      case 7u:
        unsigned int v24 = 8421504;
        break;
      default:
        unsigned int v24 = 0;
        break;
    }
    uint64_t v25 = *(void *)(v8 + 16);
    *(unsigned char *)(v25 + 480) = 3;
    *(unsigned char *)(v25 + 481) |= 1u;
    unsigned int v26 = bswap32(v24);
    v19.i32[0] = v26;
    v19.i32[1] = v26 >> 8;
    v19.i32[2] = HIWORD(v26);
    v27.i64[0] = 0xFF000000FFLL;
    v27.i64[1] = 0xFF000000FFLL;
    int32x4_t v28 = (int32x4_t)vandq_s8(v19, v27);
    v28.i32[3] = vshrq_n_u32((uint32x4_t)vdupq_n_s32(v26), 0x18uLL).i32[3];
    *(float16x4_t *)(*(void *)(v8 + 16) + 8) = vcvt_f16_f32(vmulq_f32(vcvtq_f32_s32(v28), (float32x4_t)vdupq_n_s32(0x3B808081u)));
    int64x2_t v29 = (CA::Shape *)CA::Shape::intersect(*(CA::Shape **)(a1 + 64), (const CA::Bounds *)v31);
    v30[0] = 0;
    v30[1] = 0;
    CA::OGL::emit_combine(v8, 0, 0, 0, v29, (unsigned int *)v30);
    CA::Shape::unref(v29);
    uint64_t v18 = *(void *)(v8 + 16);
    *(unsigned char *)(v18 + 480) = *(unsigned char *)(a1 + 124);
  }
  else
  {
    uint64_t v18 = *(void *)(v8 + 16);
  }
  *(unsigned char *)(v18 + 481) &= ~1u;
}

void CA::OGL::emit_combine(uint64_t a1, unsigned int a2, _DWORD *a3, uint64_t a4, CA::Shape *a5, unsigned int *a6)
{
  v71[3] = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(*(void *)(a1 + 16) + 16) = a2;
  if (a3)
  {
    CA::OGL::Context::bind_surface(a1, (uint64_t)a3, 0, 0, 0, 0.0);
    unsigned int v12 = a3[8];
    unsigned int v13 = a3[9];
    unsigned int v14 = a3[10];
    unsigned int v15 = a3[11];
  }
  else
  {
    unsigned int v12 = 0;
    unsigned int v13 = 0;
    unsigned int v14 = 0;
    unsigned int v15 = 0;
  }
  unint64_t v66 = __PAIR64__(v13, v12);
  unsigned int v67 = v14;
  unsigned int v68 = v15;
  if (a4)
  {
    CA::OGL::Context::bind_surface(a1, a4, 1u, 0, 0, 0.0);
    int8x16_t v16 = *(int8x16_t *)(a4 + 32);
  }
  else
  {
    int8x16_t v16 = 0uLL;
  }
  int8x16_t v63 = v16;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 984))(a1))
  {
    int64x2_t v61 = a5;
    unint64_t v64 = 0;
    int32x2_t v65 = 0;
    unsigned int v17 = (const CA::Bounds *)&v66;
    if (a2 <= 0x3F)
    {
      if (((1 << a2) & 0xC043800001FC1B5ELL) != 0)
      {
LABEL_10:
        uint64_t v62 = CA::Shape::intersect(v61, v17);
LABEL_11:
        int v60 = 1;
        goto LABEL_12;
      }
      if (((1 << a2) & 0x480) != 0)
      {
        unint64_t v64 = __PAIR64__(v13, v12);
        int32x2_t v65 = (int32x2_t)__PAIR64__(v15, v14);
        int32x2_t v53 = (int32x2_t)vextq_s8(v63, v63, 8uLL).u64[0];
        uint32x2_t v54 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)__PAIR64__(v15, v14));
        uint32x2_t v55 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v53);
        unsigned __int32 v56 = vpmax_u32(v55, v55).u32[0];
        if ((vpmax_u32(v54, v54).u32[0] & 0x80000000) != 0)
        {
          if ((v56 & 0x80000000) != 0)
          {
            uint64_t v62 = 1;
            goto LABEL_11;
          }
          unint64_t v64 = v63.i64[0];
          v65.i32[0] = v63.i32[2];
          __int32 v59 = v63.i32[3];
        }
        else
        {
          if ((v56 & 0x80000000) != 0)
          {
LABEL_78:
            unsigned int v17 = (const CA::Bounds *)&v64;
            goto LABEL_10;
          }
          int32x2_t v57 = vmin_s32((int32x2_t)v64, *(int32x2_t *)v63.i8);
          int32x2_t v58 = vsub_s32(vmax_s32(vadd_s32((int32x2_t)v64, (int32x2_t)__PAIR64__(v15, v14)), vadd_s32(*(int32x2_t *)v63.i8, v53)), v57);
          unint64_t v64 = (unint64_t)v57;
          v65.i32[0] = v58.i32[0];
          __int32 v59 = v58.i32[1];
        }
        v65.i32[1] = v59;
        goto LABEL_78;
      }
      if (a2 == 5)
      {
        unint64_t v64 = __PAIR64__(v13, v12);
        int32x2_t v65 = (int32x2_t)__PAIR64__(v15, v14);
        unsigned int v17 = (const CA::Bounds *)&v64;
        if ((CA::BoundsImpl::intersect((int32x2_t *)&v64, *(int32x2_t *)v63.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v63, v63, 8uLL)) & 1) == 0)
        {
          unint64_t v19 = *(void *)(*(void *)(a1 + 16) + 8);
          unint64_t v20 = v19 >> 16;
          unint64_t v21 = HIDWORD(v19);
          unint64_t v22 = HIWORD(v19);
          int v60 = 1;
          uint64_t v62 = 1;
          goto LABEL_24;
        }
        goto LABEL_10;
      }
    }
    if (a2 - 68 >= 2)
    {
      int v60 = 0;
      uint64_t v62 = (uint64_t)v61;
LABEL_12:
      uint64_t v18 = *(void *)(a1 + 16);
      unint64_t v19 = *(void *)(v18 + 8);
      unint64_t v20 = v19 >> 16;
      unint64_t v21 = HIDWORD(v19);
      unint64_t v22 = HIWORD(v19);
      if (a2 - 8 >= 2)
      {
        if (a2 == 7)
        {
          _S0 = *a6;
          __asm { FCVT            H0, S0 }
          LOWORD(v19) = _S0;
          LOWORD(v20) = _S0;
          LOWORD(v21) = _S0;
          unint64_t v22 = _S0;
        }
      }
      else
      {
        *(_OWORD *)(v18 + 24) = *(_OWORD *)a6;
      }
LABEL_24:
      BOOL v29 = CA::OGL::Context::need_transparent_source((CA::OGL::Context *)a1);
      int v30 = *(unsigned __int8 *)(a1 + 64);
      if (*(unsigned char *)(a1 + 64)) {
        *(unsigned char *)(a1 + 64) = 0;
      }
      *(void *)(a1 + 128) = 0;
      uint64_t v31 = a1 + 834;
      *(void *)(a1 + 96) = a1 + 834;
      *(_OWORD *)(a1 + 104) = xmmword_184997E70;
      v71[1] = 0;
      int8x16_t v71[2] = 0;
      v71[0] = v62;
      unint64_t v32 = ((unint64_t)(unsigned __int16)v21 << 32) | (v22 << 48) | ((unint64_t)(unsigned __int16)v20 << 16) | (unsigned __int16)v19;
      int32x2_t v33 = (int32x2_t)v66;
      while (CA::ShapeIterator::iterate(v71, (int *)&v64))
      {
        if (*(_DWORD *)(a1 + 92)) {
          uint64_t v34 = 6;
        }
        else {
          uint64_t v34 = 4;
        }
        if ((unint64_t)(*(void *)(a1 + 128) + 4) > *(void *)(a1 + 136)
          || (unint64_t v35 = *(void *)(a1 + 112)) != 0 && *(void *)(a1 + 104) + v34 > v35)
        {
          *(_WORD *)(a1 + 832) |= 0x20u;
          CA::OGL::Context::array_flush(a1);
          *(void *)(a1 + 128) = 0;
          *(void *)(a1 + 96) = v31;
          *(_OWORD *)(a1 + 104) = xmmword_184997E70;
        }
        CA::OGL::Context::array_rect((void *)a1, (float)(int)v64, (float)SHIDWORD(v64), (float)(v65.i32[0] + (int)v64), (float)(v65.i32[1] + HIDWORD(v64)));
        uint64_t v36 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
        *(void *)(v36 - 160) = v32;
        *(void *)(v36 - 112) = v32;
        *(void *)(v36 - 64) = v32;
        *(void *)(v36 - 16) = v32;
        if (a3)
        {
          uint64_t v37 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
          int32x2_t v38 = vsub_s32((int32x2_t)v64, v33);
          float32x2_t v39 = vcvt_f32_s32(vadd_s32(v65, v38));
          float32x2_t v40 = vcvt_f32_s32(v38);
          *(float32x2_t *)(v37 - 176) = v40;
          *(void *)(v37 - 128) = __PAIR64__(v40.u32[1], v39.u32[0]);
          *(float32x2_t *)(v37 - 80) = v39;
          v40.i32[1] = v39.i32[1];
          *(float32x2_t *)(v37 - 32) = v40;
        }
        if (a4)
        {
          uint64_t v41 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
          int32x2_t v42 = vsub_s32((int32x2_t)v64, *(int32x2_t *)v63.i8);
          float32x2_t v43 = vcvt_f32_s32(vadd_s32(v65, v42));
          float32x2_t v44 = vcvt_f32_s32(v42);
          *(float32x2_t *)(v41 - 168) = v44;
          *(void *)(v41 - 120) = __PAIR64__(v44.u32[1], v43.u32[0]);
          *(float32x2_t *)(v41 - 72) = v43;
          v44.i32[1] = v43.i32[1];
          *(float32x2_t *)(v41 - 24) = v44;
        }
      }
      CA::OGL::Context::array_flush(a1);
      if (!v29) {
        goto LABEL_56;
      }
      unint64_t v47 = CA::Shape::subtract(v61, (const CA::Shape *)v62, v45, v46);
      int64x2_t v48 = (CA::Shape *)v47;
      if (v47)
      {
        if (v47 == 1)
        {
LABEL_55:
          CA::Shape::unref(v48);
LABEL_56:
          if (v30) {
            *(unsigned char *)(a1 + 64) = 1;
          }
          if (v60) {
            CA::Shape::unref((CA::Shape *)v62);
          }
          if (a4) {
            CA::OGL::Context::unbind_surface((void *)a1, a4, 1);
          }
          if (a3) {
            CA::OGL::Context::unbind_surface((void *)a1, (uint64_t)a3, 0);
          }
          *(unsigned char *)(*(void *)(a1 + 16) + 16) = 0;
          return;
        }
      }
      else if (*(_DWORD *)(v47 + 4) == 6)
      {
        goto LABEL_55;
      }
      double v49 = *(const void **)(a1 + 16);
      memcpy(buf, v49, sizeof(buf));
      v69[2] = 0;
      *(void *)long long buf = v49;
      *(void *)(a1 + 16) = buf;
      uint8_t buf[16] = 0;
      *(void *)(a1 + 128) = 0;
      *(void *)(a1 + 96) = v31;
      *(_OWORD *)(a1 + 104) = xmmword_184997E70;
      v69[0] = (uint64_t)v48;
      v69[1] = 0;
      while (CA::ShapeIterator::iterate(v69, (int *)&v64))
      {
        if (*(_DWORD *)(a1 + 92)) {
          uint64_t v50 = 6;
        }
        else {
          uint64_t v50 = 4;
        }
        if ((unint64_t)(*(void *)(a1 + 128) + 4) > *(void *)(a1 + 136)
          || (unint64_t v51 = *(void *)(a1 + 112)) != 0 && *(void *)(a1 + 104) + v50 > v51)
        {
          *(_WORD *)(a1 + 832) |= 0x20u;
          CA::OGL::Context::array_flush(a1);
          *(void *)(a1 + 128) = 0;
          *(void *)(a1 + 96) = v31;
          *(_OWORD *)(a1 + 104) = xmmword_184997E70;
        }
        CA::OGL::Context::array_rect((void *)a1, (float)(int)v64, (float)SHIDWORD(v64), (float)(v65.i32[0] + (int)v64), (float)(v65.i32[1] + HIDWORD(v64)));
        uint64_t v52 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
        *(void *)(v52 - 160) = 0;
        *(void *)(v52 - 112) = 0;
        *(void *)(v52 - 64) = 0;
        *(void *)(v52 - 16) = 0;
      }
      CA::OGL::Context::array_flush(a1);
      *(void *)(a1 + 16) = *(void *)buf;
      goto LABEL_55;
    }
    goto LABEL_10;
  }
  if (a4) {
    CA::OGL::Context::unbind_surface((void *)a1, a4, 1);
  }
  if (a3) {
    CA::OGL::Context::unbind_surface((void *)a1, (uint64_t)a3, 0);
  }
  *(unsigned char *)(*(void *)(a1 + 16) + 16) = 0;
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    float16x4_t v23 = x_log_category_ogl;
    if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a2;
      _os_log_impl(&dword_184668000, v23, OS_LOG_TYPE_DEFAULT, "CoreAnimation: unhandled combiner function: %d\n", buf, 8u);
    }
  }
}

uint64_t CA::BoundsImpl::intersect(int32x2_t *a1, int32x2_t a2, int32x2_t a3)
{
  int32x2_t v3 = a1[1];
  uint32x2_t v4 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v3);
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) != 0) {
    return 0;
  }
  uint32x2_t v5 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, a3);
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0
    || (int32x2_t v6 = vadd_s32(a2, a3),
        *(int32x2_t *)&long long v7 = vmax_s32(*a1, a2),
        int32x2_t v8 = vsub_s32(vmin_s32(vadd_s32(*a1, v3), v6), *(int32x2_t *)&v7),
        uint32x2_t v9 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v8),
        (vpmax_u32(v9, v9).u32[0] & 0x80000000) != 0))
  {
    uint64_t v10 = 0;
    a1[1] = 0;
  }
  else
  {
    *((int32x2_t *)&v7 + 1) = v8;
    *(_OWORD *)a1->i8 = v7;
    return 1;
  }
  return v10;
}

uint64_t CA::Render::LayerNode::clear_above_and_black_below(CA::Render::LayerNode ***this, char a2, double a3, float a4)
{
  uint32x2_t v4 = (CA::Render::LayerNode *)this;
  do
  {
    uint32x2_t v5 = v4;
    uint32x2_t v4 = (CA::Render::LayerNode *)*((void *)v4 + 11);
  }
  while (v4);
  int32x2_t v6 = *(_DWORD **)(*((void *)v5 + 4) + 144);
  if (v6)
  {
    if ((long long v7 = this[4][18], *((void *)v7 + 14) == *((void *)v6 + 14))
      && *((_DWORD *)v7 + 30) == v6[30]
      && *((_DWORD *)v7 + 31) == v6[31]
      || (a2 & 1) == 0)
    {
      for (uint64_t i = *(CA::Render::LayerNode **)v5; i != v5 && (*((unsigned char *)i + 24) & 0x40) != 0; uint64_t i = *(CA::Render::LayerNode **)i)
      {
        uint64_t v11 = *(void *)(*((void *)i + 4) + 144);
        if (v11 && (*(unsigned char *)(v11 + 98) & 0x80) != 0) {
          return 0;
        }
      }
      for (uint64_t j = (CA::Render::LayerNode ***)this[13]; j != this + 12; uint64_t j = (CA::Render::LayerNode ***)j[1])
      {
        unsigned int v13 = j[4][18];
        if (v13 && (*((unsigned char *)v13 + 98) & 0x80) != 0) {
          return 0;
        }
      }
      unsigned int v14 = this[11];
      if (!v14) {
        return 1;
      }
      unsigned int v15 = this[11];
      int8x16_t v16 = (CA::Render::LayerNode *)this;
      do
      {
        unsigned int v17 = (CA::Render::LayerNode *)v15;
        uint64_t v18 = (CA::Render::LayerNode *)(v15 + 12);
        for (uint64_t k = (CA::Render::LayerNode *)*((void *)v17 + 13);
              k != v18 && k != v16;
              uint64_t k = (CA::Render::LayerNode *)*((void *)k + 1))
        {
          uint64_t v21 = *((void *)k + 4);
          uint64_t v22 = *(void *)(v21 + 144);
          if (v22)
          {
            if ((*(unsigned char *)(v22 + 98) & 0x80) != 0)
            {
              LOBYTE(a4) = *(unsigned char *)(v21 + 32);
              a4 = (float)LODWORD(a4) * 0.0039216;
              if (a4 > 0.0) {
                return 0;
              }
            }
          }
        }
        unsigned int v15 = (CA::Render::LayerNode **)*((void *)v17 + 11);
        int8x16_t v16 = v17;
      }
      while (v15);
      float16x4_t v23 = (CA::Render::LayerNode *)this;
      while (1)
      {
        unsigned int v24 = (CA::Render::LayerNode *)v14;
        uint64_t v25 = (CA::Render::LayerNode *)(v14 + 12);
        unsigned int v26 = v14[13];
        if (v26 != v25) {
          break;
        }
LABEL_55:
        unsigned int v14 = (CA::Render::LayerNode **)*((void *)v24 + 11);
        uint64_t v8 = 1;
        float16x4_t v23 = v24;
        if (!v14) {
          return v8;
        }
      }
      char v27 = 0;
      while (1)
      {
        v27 |= v26 == v23;
        if (v26 != (CA::Render::LayerNode *)this && (v27 & 1) != 0)
        {
          int32x4_t v28 = (float32x4_t *)*((void *)v26 + 4);
          uint64_t v29 = v28[9].i64[0];
          if (v29)
          {
            uint64_t v30 = *(void *)(v29 + 96);
            if (v26 == v23)
            {
              if ((v30 & 0x20000000) != 0) {
                return 0;
              }
              if (v28[6].i64[0]) {
                goto LABEL_49;
              }
              if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(v28[1], (float32x4_t)xmmword_184997DF0)))))goto LABEL_49; {
              uint64_t v31 = v28[8].i64[0];
              }
              if (v31)
              {
                if (*(float *)(v31 + 228) > 0.0 || *(float *)(v31 + 236) > 0.0) {
                  goto LABEL_49;
                }
              }
            }
            else if ((v30 & 0x400000) != 0)
            {
              return 0;
            }
            if (*(_DWORD *)(v29 + 112) == v6[28]
              && *(_DWORD *)(v29 + 116) == v6[29]
              && *(_DWORD *)(v29 + 120) == v6[30]
              && *(_DWORD *)(v29 + 124) == v6[31])
            {
              return 1;
            }
          }
        }
LABEL_49:
        unsigned int v26 = (CA::Render::LayerNode *)*((void *)v26 + 1);
        if (v26 == v25) {
          goto LABEL_55;
        }
      }
    }
  }
  return 0;
}

uint64_t CA::WindowServer::anonymous namespace'::OGLDisplay::get_surface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 624))(a2, a3, a4);
}

float64_t CA::WindowServer::anonymous namespace'::OGLDisplay::round_logical_rect(CA::WindowServer::_anonymous_namespace_::OGLDisplay *this, Rect *a2)
{
  uint64_t v3 = *((void *)this + 1);
  if ((*(unsigned char *)(v3 + 745) & 4) != 0)
  {
    uint64_t v9 = *(void *)(v3 + 152);
    uint64_t v8 = *(void *)(v3 + 160);
    v10.i64[0] = (int)v8;
    v10.i64[1] = SHIDWORD(v8);
    float64x2_t v11 = vcvtq_f64_s64(v10);
    uint64_t v13 = *(void *)(v3 + 200);
    uint64_t v12 = *(void *)(v3 + 208);
    v10.i64[0] = (int)v12;
    v10.i64[1] = SHIDWORD(v12);
    float64x2_t v14 = vdivq_f64(v11, vcvtq_f64_s64(v10));
    v10.i64[0] = (int)v9;
    v10.i64[1] = SHIDWORD(v9);
    float64x2_t v15 = vcvtq_f64_s64(v10);
    v10.i64[0] = (int)v13;
    v10.i64[1] = SHIDWORD(v13);
    float64x2_t v23 = vmlsq_f64(v15, vcvtq_f64_s64(v10), v14);
    float64x2_t v16 = v14;
    CA::BoundsImpl::scale((double *)a2, v14.f64[0], v14.f64[1]);
    float64x2_t v17 = *(float64x2_t *)&a2[2].top;
    float64x2_t v18 = vaddq_f64(*(float64x2_t *)&a2->top, v23);
    double v19 = *(double *)&a2[3];
    if (v17.f64[0] <= v19) {
      double v20 = *(double *)&a2[3];
    }
    else {
      double v20 = *(double *)&a2[2];
    }
    if (v20 < 1.79769313e308)
    {
      if (v17.f64[0] < v19) {
        double v19 = *(double *)&a2[2];
      }
      if (v19 > 0.0)
      {
        float64x2_t v21 = vaddq_f64(v18, v17);
        float64x2_t v18 = vrndaq_f64(v18);
        *(float64x2_t *)&a2[2].top = vsubq_f64(vrndaq_f64(v21), v18);
      }
    }
    *(float64x2_t *)&a2->top = vsubq_f64(v18, v23);
    v4.f64[0] = CA::BoundsImpl::scale((double *)a2, 1.0 / v16.f64[0], 1.0 / v16.f64[1]);
  }
  else
  {
    float64x2_t v4 = *(float64x2_t *)&a2[2].top;
    double v5 = *(double *)&a2[3];
    if (v4.f64[0] <= v5) {
      double v6 = *(double *)&a2[3];
    }
    else {
      double v6 = *(double *)&a2[2];
    }
    if (v6 < 1.79769313e308)
    {
      if (v4.f64[0] < v5) {
        double v5 = *(double *)&a2[2];
      }
      if (v5 > 0.0)
      {
        float64x2_t v7 = vrndaq_f64(*(float64x2_t *)&a2->top);
        float64x2_t v4 = vsubq_f64(vrndaq_f64(vaddq_f64(*(float64x2_t *)&a2->top, v4)), v7);
        *(float64x2_t *)&a2->top = v7;
        *(float64x2_t *)&a2[2].top = v4;
      }
    }
  }
  return v4.f64[0];
}

uint64_t CA::WindowServer::anonymous namespace'::OGLDisplay::detach_layer(CA::WindowServer::_anonymous_namespace_::OGLDisplay *this, Handle *a2, uint64_t a3, CA::Render::Texture *a4, void *a5, const Rect *a6, const Rect *a7, unsigned int a8, unsigned int *a9)
{
  if (a5)
  {
    uint64_t v10 = a5[1];
    uint64_t v11 = *((void *)this + 1);
    if (v10 != v11)
    {
      a5[1] = v11;
      uint64_t v10 = v11;
    }
  }
  else
  {
    uint64_t v10 = *((void *)this + 1);
  }
  return (*(uint64_t (**)(uint64_t, Handle *, uint64_t, CA::Render::Texture *))(*(void *)v10 + 576))(v10, a2, a3, a4);
}

float64x2_t CA::OGL::clip_detached_rects(float64x2_t *this, Rect *a2, Rect *a3, const Rect *a4, float64x2_t a5, float64x2_t a6, double a7, double a8, double a9, double a10, double a11, int32x4_t a12)
{
  float64x2_t v12 = *(float64x2_t *)&a2->top;
  float64x2_t v13 = *(float64x2_t *)&a2[2].top;
  int64x2_t v14 = vclezq_f64(v13);
  unint64_t v15 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v14, 1), (int8x16_t)v14).u64[0];
  float64x2_t v16 = v13;
  float64x2_t v17 = *(float64x2_t *)&a2->top;
  if ((v15 & 0x8000000000000000) == 0)
  {
    int64x2_t v18 = vclezq_f64(a6);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v18, 1), (int8x16_t)v18).u64[0] & 0x8000000000000000) != 0)
    {
      float64x2_t v16 = 0uLL;
      float64x2_t v17 = *(float64x2_t *)&a2->top;
    }
    else
    {
      float64x2_t v19 = vaddq_f64(a5, a6);
      a5 = vmaxnmq_f64(v12, a5);
      float64x2_t v20 = vsubq_f64(vminnmq_f64(vaddq_f64(v12, v13), v19), a5);
      int64x2_t v21 = vclezq_f64(v20);
      int64x2_t v22 = vdupq_laneq_s64(v21, 1);
      int64x2_t v23 = (int64x2_t)vorrq_s8((int8x16_t)v22, (int8x16_t)v21);
      v22.i64[0] = -1;
      int8x16_t v24 = (int8x16_t)vdupq_lane_s64(vcgtq_s64(v23, v22).i64[0], 0);
      float64x2_t v17 = (float64x2_t)vbslq_s8(v24, (int8x16_t)a5, (int8x16_t)v12);
      float64x2_t v16 = (float64x2_t)vandq_s8((int8x16_t)v20, v24);
    }
  }
  LODWORD(a5.f64[0]) = 0;
  a12.i32[0] = a3 & 4;
  int8x16_t v25 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(a12, (int32x4_t)a5), 0);
  int8x16_t v26 = (int8x16_t)vaddq_f64(this[1], *this);
  int8x16_t v27 = vbslq_s8(v25, *(int8x16_t *)this, vextq_s8(v26, *(int8x16_t *)this, 8uLL));
  int8x16_t v28 = vbslq_s8(v25, v26, vextq_s8(*(int8x16_t *)this, v26, 8uLL));
  float64x2_t v29 = vaddq_f64(v13, v12);
  *(int32x2_t *)v26.i8 = vceqz_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(a3), (int8x8_t)0x100000002));
  v30.i64[0] = v26.i32[0];
  v30.i64[1] = v26.i32[1];
  float64x2_t v31 = (float64x2_t)vbslq_s8(v30, v28, v27);
  float64x2_t v32 = (float64x2_t)vbslq_s8(v30, v27, v28);
  float64x2_t v33 = vdivq_f64(vsubq_f64(v31, v32), v13);
  float64x2_t v34 = vsubq_f64(v17, v12);
  int8x16_t v35 = (int8x16_t)vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtzq_f64(v34), (int8x16_t)vmulq_f64(v34, v33), (int8x16_t)vdupq_n_s64(0x8000000000000000)), v32);
  float64x2_t v36 = vsubq_f64(v29, vaddq_f64(v17, v16));
  int8x16_t v37 = (int8x16_t)vsubq_f64(v31, (float64x2_t)vandq_s8((int8x16_t)vmulq_f64(v36, v33), (int8x16_t)vcgtzq_f64(v36)));
  int8x16_t v38 = vbslq_s8(v30, v37, v35);
  int8x16_t v39 = vbslq_s8(v30, v35, v37);
  float64x2_t v40 = (float64x2_t)vbslq_s8(v25, v39, vextq_s8(v39, v38, 8uLL));
  *(float64x2_t *)&a2->top = v17;
  *(float64x2_t *)&a2[2].top = v16;
  float64x2_t result = vsubq_f64((float64x2_t)vbslq_s8(v25, v38, vextq_s8(v38, v39, 8uLL)), v40);
  *this = v40;
  this[1] = result;
  return result;
}

uint64_t CA::WindowServer::anonymous namespace'::OGLDisplay::detached_layer_under_destination_p(CA::WindowServer::_anonymous_namespace_::OGLDisplay *this, Handle *a2)
{
  return 1;
}

uint64_t CA::WindowServer::IOMFBDisplay::release_detached_handle(uint64_t result)
{
  uint64_t v1 = *(CA::Render::Handle **)result;
  if (*(void *)result)
  {
    uint64_t v2 = result;
    float64x2_t result = CA::Render::Handle::lock_context(*(CA::Render::Handle **)result);
    if (result)
    {
      uint64_t v4 = result;
      *((void *)v1 + 12) &= ~0x8000uLL;
      double v5 = *(atomic_uint **)(result + 384);
      if (v5)
      {
        if (atomic_fetch_add(v5 + 4, 0xFFFFFFFF) == 1) {
          CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v5, v3);
        }
        *(void *)(v4 + 384) = 0;
      }
      float64x2_t result = CA::Render::Handle::unlock_context((atomic_uint *)v4, v3);
    }
    if (atomic_fetch_add((atomic_uint *volatile)v1 + 2, 0xFFFFFFFF) == 1) {
      float64x2_t result = (*(uint64_t (**)(CA::Render::Handle *))(*(void *)v1 + 16))(v1);
    }
    *(void *)uint64_t v2 = 0;
    *(_DWORD *)(v2 + 288) = 0;
  }
  return result;
}

CA::Render::Context *CA::Render::updater_mark_detached_layer(CA::Render::Context *this, CA::Render::LayerNode *a2)
{
  if (this)
  {
    uint64_t v2 = this;
    do
    {
      uint64_t v3 = *((void *)v2 + 4);
      uint64_t v4 = *(int32x2_t **)(v3 + 144);
      if (v4)
      {
        if (a2)
        {
          this = (CA::Render::Context *)CA::Render::Handle::lock_context(*(CA::Render::Handle **)(v3 + 144));
          if (this)
          {
            double v6 = (atomic_uint *)this;
            CA::Render::Context::invalidate(this, v4 + 14, v5);
            this = (CA::Render::Context *)CA::Render::Handle::unlock_context(v6, v7);
          }
        }
        int32x2_t v8 = v4[12];
        if ((v8.i32[0] & 0x20000) != 0) {
          return this;
        }
        LOBYTE(a2) = 0;
        v4[12] = (int32x2_t)(*(void *)&v8 | 0x20020);
      }
      uint64_t v2 = (CA::Render::Context *)*((void *)v2 + 11);
    }
    while (v2);
  }
  return this;
}

uint64_t CA::Render::Handle::unlock_context(atomic_uint *this, CA::Render::Context *a2)
{
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(this + 18));
  if (atomic_fetch_add(this + 2, 0xFFFFFFFF) == 1)
  {
    uint64_t v4 = *(uint64_t (**)(atomic_uint *))(*(void *)this + 16);
    return v4(this);
  }
  return result;
}

uint64_t CA::Render::Handle::lock_context(CA::Render::Handle *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Handle::_handle_lock);
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    if (atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Handle::_handle_lock);
      pthread_mutex_lock((pthread_mutex_t *)(v2 + 72));
    }
    else
    {
      atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 0xFFFFFFFF);
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Handle::_handle_lock);
      return 0;
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Handle::_handle_lock);
  }
  return v2;
}

void CA::shape_subtract(CA::Shape **this, CA::Shape **a2, const CA::Bounds *a3)
{
  uint64_t v4 = *this;
  if (*this)
  {
    if (v4 == (CA::Shape *)1) {
      return;
    }
    goto LABEL_5;
  }
  if (*((_DWORD *)v4 + 1) != 6)
  {
LABEL_5:
    unint64_t v5 = CA::Shape::subtract(*this, (const CA::Bounds *)a2);
    CA::Shape::unref(v4);
    *this = (CA::Shape *)v5;
  }
}

unint64_t CA::Shape::subtract(CA::Shape *this, const CA::Bounds *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (this) {
    BOOL v3 = this == (CA::Shape *)1;
  }
  else {
    BOOL v3 = *((_DWORD *)this + 1) == 6;
  }
  char v4 = v3;
  if ((v4 & 1) == 0 && *((_DWORD *)a2 + 2) && *((_DWORD *)a2 + 3))
  {
    memset(v8, 0, sizeof(v8));
    CA::Shape::operator=((uint64_t)v8, a2);
    return CA::Shape::subtract(this, (const CA::Shape *)v8, v5, v6);
  }
  else
  {
    return CA::Shape::ref((unint64_t)this);
  }
}

void init_debug(void *a1)
{
  if (CADeviceHasInternalBuild::once[0] != -1) {
    dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
  }
  if (CADeviceHasInternalBuild::internal) {
    CFDictionaryRef v1 = CFPreferencesCopyMultiple(0, @"com.apple.coreanimation", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  }
  else {
    CFDictionaryRef v1 = 0;
  }
  for (uint64_t i = 0; i != 200; ++i)
    *((unsigned char *)&ca_debug_options + i) = CADefaultsGetFloat(v1, 0.0, debug_option_env_vars[i]) != 0.0;
  if (CADeviceHasInternalBuild::once[0] != -1) {
    dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
  }
  float v3 = 0.0;
  if (CADeviceHasInternalBuild::internal) {
    float v3 = 1.0;
  }
  uint64_t v4 = 0;
  BYTE9(xmmword_1EB2ACC10) = CADefaultsGetFloat(v1, v3, "CA_EMIT_DEBUG_SIGNPOSTS") != 0.0;
  BYTE11(xmmword_1EB2ACC10) = 0;
  do
  {
    *(float *)&debug_values[v4] = CADefaultsGetFloat(v1, 0.0, debug_value_env_vars[v4]);
    ++v4;
  }
  while (v4 != 66);
  MGGetFloat32Answer();
  if (v5)
  {
    MGGetFloat32Answer();
    dword_1EB2ACAF8 = truncf(CADefaultsGetFloat(v1, (float)((48 * v6) | (v6 << 21)), "CA_PERF_HUD_ORIGIN"));
  }
  dword_1EB2ACB00 = 1133903872;
  dword_1EB2ACB20 = truncf(CADefaultsGetFloat(v1, 2.0, "CA_DISPLAY_HYSTERESIS_NITS"));
  *(_OWORD *)&dword_1EB2ACB30 = xmmword_184998470;
  if (*(float *)&dword_1EB2ACB44 != 0.0) {
    byte_1EB2ACC28 = 1;
  }
  uint64_t v7 = 0;
  dword_1EB2ACB48 = 0;
  options_are_visual = 0;
  while (!*((unsigned char *)&ca_debug_options + dword_1849A7CB4[v7]))
  {
    if (++v7 == 40) {
      goto LABEL_23;
    }
  }
  options_are_visual = 1;
LABEL_23:
  if (CADeviceSupportsHDRExternalDisplayBrightnessControl::once[0] != -1) {
    dispatch_once(CADeviceSupportsHDRExternalDisplayBrightnessControl::once, &__block_literal_global_385_12291);
  }
  byte_1EB2ACC8A |= CADeviceSupportsHDRExternalDisplayBrightnessControl::enabled;
  if (v1)
  {
    CFRelease(v1);
  }
}

float CADefaultsGetFloat(const __CFDictionary *a1, float a2, const char *a3)
{
  value[1] = *(void **)MEMORY[0x1E4F143B8];
  float v6 = getenv(a3);
  if (v6) {
    return atof(v6);
  }
  value[0] = 0;
  CFStringRef v7 = CFStringCreateWithCStringNoCopy(0, a3, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (a1
    && CFDictionaryGetValueIfPresent(a1, v7, (const void **)value)
    && (CFTypeID v8 = CFGetTypeID(value[0]), v8 == CFNumberGetTypeID()))
  {
    float valuePtr = a2;
    CFNumberGetValue((CFNumberRef)value[0], kCFNumberFloatType, &valuePtr);
    CFRelease(v7);
    return valuePtr;
  }
  else
  {
    CFRelease(v7);
  }
  return a2;
}

CFTypeRef CA::Display::Display::retain_uuid(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 18;
  os_unfair_lock_lock(this + 18);
  float v3 = *(const void **)&this[32]._os_unfair_lock_opaque;
  if (v3) {
    CFTypeRef v4 = CFRetain(v3);
  }
  else {
    CFTypeRef v4 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

void sub_18474C51C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::Render::SecureIndicatorLayer::visit_subclass(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 64))(a2, a1);
}

void CA::OGL::FilterNode::apply(uint64_t a1, int **a2, float *a3, int32x4_t a4, int32x4_t a5)
{
  float v7 = *(float *)a4.i32;
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(CA::Render::Update ***)(a1 + 8);
  uint64_t v10 = *v9;
  int v11 = *(_DWORD *)(a1 + 136);
  if (v11 < 0)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, a1 + 128);
    int v11 = *(_DWORD *)(a1 + 136);
  }
  int v12 = *(_DWORD *)(a1 + 140);
  if (v11 <= v12) {
    int v13 = *(_DWORD *)(a1 + 140);
  }
  else {
    int v13 = v11;
  }
  a4.i32[0] = 1073741822;
  a5.i32[0] = v13;
  int8x16_t v17 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a5, a4), 0);
  uint64_t v14 = *(void *)(a1 + 128);
  v15.i64[0] = (int)v14;
  v15.i64[1] = SHIDWORD(v14);
  int8x16_t v16 = vbslq_s8(v17, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v15));
  *(double *)v17.i64 = (double)v11;
  if (v13 <= 1073741822)
  {
    double v18 = (double)v12;
  }
  else
  {
    *(double *)v17.i64 = 1.79769313e308;
    double v18 = 1.79769313e308;
  }
  double v19 = v7;
  *(double *)&v17.i64[1] = v18;
  BOOL v20 = *(double *)v17.i64 >= 1.79769313e308 || v7 == 1.0;
  v21.i64[1] = v16.i64[1];
  *(double *)&v22.i64[1] = v18;
  if (v20) {
    unint64_t v23 = 0;
  }
  else {
    unint64_t v23 = -1;
  }
  int8x16_t v24 = (int8x16_t)vdupq_n_s64(v23);
  *(double *)v22.i64 = *(double *)v17.i64 * v7;
  float64x2_t v25 = (float64x2_t)vbslq_s8(v24, v22, v17);
  *(double *)v21.i64 = v19 * *(double *)v16.i64;
  float64x2_t v26 = (float64x2_t)vbslq_s8(v24, v21, v16);
  if (v7 != 1.0 && v25.f64[1] < 1.79769313e308)
  {
    v26.f64[1] = vmuld_lane_f64(v19, v26, 1);
    v25.f64[1] = v25.f64[1] * v19;
  }
  int64x2_t v27 = vceqzq_f64(v25);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v27, 1), (int8x16_t)v27).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v28 = vorrq_s8((int8x16_t)vcltzq_f64(v25), (int8x16_t)vcgezq_f64(v25)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v28), 1), v28).u64[0] & 0x8000000000000000) != 0))
  {
    int32x4_t v58 = 0uLL;
  }
  else
  {
    float64x2_t v29 = vminnmq_f64(vaddq_f64(v26, v25), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
    int32x4_t v30 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v26, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    int32x4_t v58 = vuzp1q_s32(v30, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v29), (int64x2_t)v30));
  }
  float64x2_t v31 = (CA::Shape *)CA::Shape::intersect(*(CA::Shape **)(*((void *)v10 + 31) + 8), (const CA::Bounds *)&v58);
  uint64_t v60 = 0;
  memset(&v59[2], 0, 32);
  memset(v59, 0, 32);
  uint64_t v32 = *((void *)v10 + 31);
  *(_OWORD *)((char *)v59 + 8) = *(_OWORD *)(v32 + 8);
  uint64_t v33 = *(void *)(v32 + 32);
  *((void *)&v59[1] + 1) = *(void *)(v32 + 24);
  *(void *)&v59[2] = v33;
  long long v34 = *(_OWORD *)(v32 + 40);
  *((void *)&v59[3] + 1) = *(void *)(v32 + 56);
  LOWORD(v33) = *(unsigned __int8 *)(v32 + 68);
  WORD2(v60) = v33;
  LOWORD(v33) = *(_WORD *)(v32 + 68) & 0x100 | v33;
  *(_OWORD *)((char *)&v59[2] + 8) = v34;
  LODWORD(v60) = *(_DWORD *)(v32 + 64);
  WORD2(v60) = v33;
  WORD2(v60) = v33 | *(_WORD *)(v32 + 68) & 0x400;
  *((void *)&v59[0] + 1) = v31;
  *(void *)&v59[0] = CA::OGL::Context::set_gstate((uint64_t)v10, (uint64_t)v59);
  if (((*a2)[19] & 8) != 0) {
    unsigned int v35 = (CA::OGL::filter_flags(*(void *)(a1 + 232), *(void *)(a1 + 16)) >> 6) & 1;
  }
  else {
    LOBYTE(v35) = 0;
  }
  uint64_t v36 = *((void *)v10 + 2);
  unsigned int v37 = *(unsigned __int8 *)(v36 + 480);
  if (v37 >= 2 && (v37 != 3 || (v35 & 1) == 0)) {
    *(unsigned char *)(v36 + 481) |= 1u;
  }
  uint64_t v38 = *(void *)(a1 + 16);
  int8x16_t v39 = *(void **)(*(void *)(v38 + 24) + 128);
  if (!v39 || !*v39) {
    goto LABEL_40;
  }
  uint64_t v40 = 0;
  if (*(unsigned char *)(*v39 + 12) == 3)
  {
    uint64_t v41 = v39[12];
    if (v41)
    {
      unint64_t v42 = *(unsigned int *)(v41 + 16);
      if (!v42) {
        goto LABEL_40;
      }
      uint64_t v43 = *(void *)(v41 + 24);
      if ((*(unsigned char *)(v43 + 13) & 1) == 0)
      {
        unint64_t v44 = 0;
        uint64_t v45 = v41 + 32;
        while (v42 - 1 != v44)
        {
          uint64_t v46 = *(void *)(v45 + 8 * v44++);
          if (*(unsigned char *)(v46 + 13))
          {
            if (v44 >= v42) {
              goto LABEL_40;
            }
            goto LABEL_39;
          }
        }
        goto LABEL_40;
      }
LABEL_39:
      if (v43 != *(void *)(*(void *)(a1 + 232) + 16))
      {
LABEL_40:
        uint64_t v40 = 0;
        goto LABEL_41;
      }
      uint64_t v40 = *(void *)(*(void *)(v38 + 16) + 256);
      if (v40)
      {
        double v49 = (os_unfair_lock_s *)(v40 + 36);
        os_unfair_lock_lock((os_unfair_lock_t)(v40 + 36));
        uint64_t v40 = *(void *)(v40 + 40);
        if (v40)
        {
          uint64_t v50 = (os_unfair_lock_s *)(v40 + 40);
          os_unfair_lock_lock((os_unfair_lock_t)(v40 + 40));
          uint64_t v51 = *(void *)(v40 + 48);
          if (v51 && *(CA::Render::Update **)(v51 + 8) == *v9) {
            uint64_t v40 = *(unsigned char *)(v51 + 216) & 1;
          }
          else {
            uint64_t v40 = 0;
          }
          os_unfair_lock_unlock(v50);
        }
        os_unfair_lock_unlock(v49);
        uint64_t v38 = *(void *)(a1 + 16);
      }
    }
  }
LABEL_41:
  CA::OGL::emit_filter(v9, *(void *)(a1 + 232), v38, *a2, v40, 0, 0, v7, *a3);
  CA::OGL::Context::set_gstate((uint64_t)v10, **((void **)v10 + 31));
  int v48 = (*(_DWORD *)(a1 + 220) >> 17) & 7;
  if (v48)
  {
    int v52 = v48 - 1;
    unsigned int v53 = -2147467200;
    switch(v52)
    {
      case 0:
        break;
      case 1:
        unsigned int v53 = 8388736;
        break;
      case 2:
        unsigned int v53 = -2147483520;
        break;
      case 4:
        unsigned int v53 = -2139094912;
        if (*a2)
        {
          if ((*((unsigned char *)*a2 + 69) & 8) != 0) {
            unsigned int v53 = 8388736;
          }
          else {
            unsigned int v53 = -2139094912;
          }
        }
        break;
      case 5:
        unsigned int v53 = -2147450752;
        break;
      case 6:
        unsigned int v53 = 8421504;
        break;
      default:
        unsigned int v53 = 0;
        break;
    }
    unsigned int v54 = bswap32(v53);
    v47.i32[0] = v54;
    v47.i32[1] = v54 >> 8;
    v47.i32[2] = HIWORD(v54);
    v55.i64[0] = 0xFF000000FFLL;
    v55.i64[1] = 0xFF000000FFLL;
    int32x4_t v56 = (int32x4_t)vandq_s8(v47, v55);
    v56.i32[3] = vshrq_n_u32((uint32x4_t)vdupq_n_s32(v54), 0x18uLL).i32[3];
    *(float16x4_t *)(*((void *)v10 + 2) + 8) = vcvt_f16_f32(vmulq_f32(vcvtq_f32_s32(v56), (float32x4_t)vdupq_n_s32(0x3B808081u)));
    v57[0] = 0;
    v57[1] = 0;
    CA::OGL::emit_combine((uint64_t)v10, 0, 0, 0, *((CA::Shape **)&v59[0] + 1), (unsigned int *)v57);
  }
  *(unsigned char *)(*((void *)v10 + 2) + 481) &= ~1u;
  if (v31) {
    CA::Shape::unref(v31);
  }
}

void CA::OGL::render_home_affordance_base(void *a1, uint64_t a2, int *a3, float a4)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  CFTypeID v8 = *(unsigned int **)(a2 + 40);
  double float_key = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v8, 276, 0.0);
  double v10 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v8, 307, 0.0);
  if (!v8) {
    goto LABEL_14;
  }
  uint64_t v11 = v8[4];
  if (!v11) {
    goto LABEL_14;
  }
  uint64_t v12 = 0;
  while (1)
  {
    uint64_t v13 = *(void *)&v8[2 * v12 + 6];
    if (*(_DWORD *)(v13 + 16) == 272) {
      break;
    }
    if (v11 == ++v12) {
      goto LABEL_14;
    }
  }
  if ((v12 & 0x80000000) == 0 && *(void *)(v13 + 24))
  {
    float32x4_t v39 = 0uLL;
    float_color_kedouble y = CA::Render::KeyValueArray::get_float_color_key((CA::Render::KeyValueArray *)v8, 286, &v39);
    int8x8_t v15 = (int8x8_t)vcvt_f16_f32(v39);
    if (float_color_key) {
      unsigned int v16 = -1;
    }
    else {
      unsigned int v16 = 0;
    }
    int16x4_t v17 = (int16x4_t)vbsl_s8((int8x8_t)vdup_n_s16(v16), v15, (int8x8_t)0x3C003C003C003C00);
    CFTypeID v8 = *(unsigned int **)(a2 + 40);
    if (!v8) {
      return;
    }
  }
  else
  {
LABEL_14:
    _S0 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v8, 273, 0.0);
    if (_S0 > 1.0) {
      _S0 = 1.0;
    }
    if (_S0 < 0.0) {
      _S0 = 0.0;
    }
    __asm { FCVT            H0, S0 }
    v24.i16[1] = 15360;
    v24.i32[1] = 1006648320;
    v24.i16[0] = _H0;
    int16x4_t v17 = vzip1_s16(v24, v24);
    v17.i16[2] = _H0;
    if (!v8) {
      return;
    }
  }
  uint64_t v25 = v8[4];
  if (v25)
  {
    uint64_t v26 = 0;
    float v27 = float_key;
    float v28 = v10;
    while (1)
    {
      uint64_t v29 = *(void *)&v8[2 * v26 + 6];
      if (*(_DWORD *)(v29 + 16) == 289) {
        break;
      }
      if (v25 == ++v26) {
        return;
      }
    }
    if ((v26 & 0x80000000) == 0)
    {
      uint64_t v30 = *(void *)(v29 + 24);
      if (v30)
      {
        float16x4_t v35 = (float16x4_t)v17;
        uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)v30 + 80))(v30);
        if (v31)
        {
          uint64_t v32 = (uint32x2_t *)v31;
          float v36 = v28;
          float v37 = v27;
          CA::OGL::bind_filter_surface((uint64_t)a1, (uint64_t)a3, a4);
          *(unsigned char *)(a1[2] + 16) = 55;
          float32x4_t v39 = vcvtq_f32_f16(v35);
          float32x4_t v38 = 0uLL;
          uint64_t v33 = CA::OGL::Context::bind_image((uint64_t)a1, 1u, v32, (double *)0x100, 1u, 1, 0, 0, 0.0, &v38, 0);
          if (v33)
          {
            long long v34 = v33;
            (*(void (**)(void *, void, uint64_t, uint64_t, float32x4_t *))(*a1 + 1000))(a1, 0, 4, 1, &v39);
            (*(void (**)(void *, uint64_t, uint64_t, uint64_t, float *))(*a1 + 1000))(a1, 1, 1, 1, &v37);
            (*(void (**)(void *, uint64_t, uint64_t, uint64_t, float *))(*a1 + 1000))(a1, 2, 1, 1, &v36);
            CA::OGL::emit_filter_quads((uint64_t)a1, a3, a4);
            (*(void (**)(void *, _OWORD *, uint64_t))(*a1 + 520))(a1, v34, 1);
          }
          if ((int *)a1[33] != a3) {
            CA::OGL::Context::unbind_surface(a1, (uint64_t)a3, 0);
          }
          *(unsigned char *)(a1[2] + 16) = 0;
          *(unsigned char *)(a1[2] + 19) = 0;
        }
      }
    }
  }
}

uint64_t CA::OGL::render_luminance_curve_map(void *a1, unsigned int *a2, int *a3, float a4)
{
  v23[1] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    goto LABEL_9;
  }
  uint64_t v8 = a2[4];
  if (!v8) {
    goto LABEL_9;
  }
  uint64_t v9 = 0;
  while (1)
  {
    uint64_t v10 = *(void *)&a2[2 * v9 + 6];
    if (*(_DWORD *)(v10 + 16) == 321) {
      break;
    }
    if (v8 == ++v9) {
      goto LABEL_9;
    }
  }
  if ((v9 & 0x80000000) == 0) {
    uint64_t v11 = *(CA::OGL **)(v10 + 24);
  }
  else {
LABEL_9:
  }
    uint64_t v11 = 0;
  float v12 = CA::OGL::curve_horner_coeffecients(v11, (CA::Render::Object *)a2);
  int v14 = v13;
  int v16 = v15;
  int v18 = v17;
  float float_key = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)a2, 276, 1.0);
  float v22 = float_key;
  CA::OGL::bind_filter_surface((uint64_t)a1, (uint64_t)a3, a4);
  *(unsigned char *)(a1[2] + 16) = 51;
  BOOL v20 = (float *)a1[2];
  _OWORD v20[6] = v12;
  *((_DWORD *)v20 + 7) = v14;
  *((_DWORD *)v20 + 8) = v16;
  *((_DWORD *)v20 + 9) = v18;
  v23[0] = (uint64_t)vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16((float16x4_t)0x3C003C003C003C00), v22));
  uint64_t result = CA::OGL::emit_filter_quads_color((uint64_t)a1, a3, v23, a4);
  if ((int *)a1[33] != a3) {
    uint64_t result = CA::OGL::Context::unbind_surface(a1, (uint64_t)a3, 0);
  }
  *(unsigned char *)(a1[2] + 16) = 0;
  *(unsigned char *)(a1[2] + 19) = 0;
  return result;
}

uint64_t CA::OGL::emit_color_matrix(CA::OGL *a1, float32x4_t *a2, uint64_t a3, int a4, float a5)
{
  uint64_t v8 = (CA::OGL::Context *)a2;
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  float32x4_t v40 = 0u;
  float32x4_t v41 = 0u;
  float32x4_t v38 = 0u;
  float32x4_t v39 = 0u;
  float32x4_t v37 = 0u;
  uint64_t v10 = (unsigned __int16 *)*((void *)a1 + 2);
  uint64_t v11 = v10[4];
  v12.i32[0] = v10[5];
  v12.i32[1] = v10[6];
  uint64_t v13 = v10[7];
  v14.i64[0] = v12.u32[0];
  v14.i64[1] = v12.u32[1];
  v15.i64[0] = 0xFFFFLL;
  v15.i64[1] = 0xFFFFLL;
  uint64x2_t v16 = (uint64x2_t)vandq_s8(v14, v15);
  _Q2 = (int32x4_t)xmmword_184998130;
  uint64x2_t v18 = vshlq_u64(v16, (uint64x2_t)xmmword_184998130);
  if ((v18.i64[0] | v11 | v18.i64[1] | (v13 << 48)) != 0x3C003C003C003C00)
  {
    _H1 = v13;
    float16x4_t v20 = (float16x4_t)vuzp1_s16(v12, v12);
    _Q2.i16[0] = v11;
    float32x4_t v21 = a2[1];
    float32x4_t v37 = *a2;
    float32x4_t v38 = v21;
    float32x4_t v22 = a2[3];
    float32x4_t v39 = a2[2];
    float32x4_t v40 = v22;
    float32x4_t v41 = a2[4];
    __asm
    {
      FCVT            S3, H1
      FCMP            H1, #0
    }
    float v29 = 0.0;
    if (!(_NF ^ _VF | _ZF)) {
      float v29 = 1.0 / _S3;
    }
    __asm { FCVT            S2, H2 }
    *(float *)_Q2.i32 = v29 * *(float *)_Q2.i32;
    int32x4_t v30 = (int32x4_t)vcvtq_f32_f16(v20);
    *(float32x2_t *)v30.i8 = vmul_n_f32(*(float32x2_t *)v30.i8, v29);
    int32x4_t v31 = vzip1q_s32(_Q2, v30);
    float32x4_t v37 = vmulq_n_f32(v37, *(float *)_Q2.i32);
    float32x4_t v38 = vmulq_f32(v38, (float32x4_t)vzip1q_s32(v31, vdupq_lane_s32(*(int32x2_t *)v31.i8, 1)));
    float32x4_t v32 = vmulq_f32(v39, (float32x4_t)vzip1q_s32(v30, v30));
    *(int32x2_t *)v30.i8 = vdup_lane_s32(*(int32x2_t *)v30.i8, 1);
    int32x4_t v33 = v30;
    *(float *)&v33.i32[1] = _S3;
    float32x4_t v34 = (float32x4_t)vzip1q_s32(v33, v33);
    v34.i32[2] = v30.i32[0];
    float32x4_t v39 = v32;
    float32x4_t v40 = vmulq_f32(v40, v34);
    float32x4_t v41 = vmulq_n_f32(v41, _S3);
    uint64_t v8 = (CA::OGL::Context *)&v37;
  }
  CA::OGL::bind_filter_surface((uint64_t)a1, a3, a5);
  CA::OGL::color_matrix_function(a1, v8, 0, (*(unsigned __int16 *)(a3 + 75) >> 11) & 1, a4);
  uint64_t v36 = *(void *)(*((void *)a1 + 2) + 8);
  uint64_t result = CA::OGL::emit_filter_quads_color((uint64_t)a1, (int *)a3, &v36, a5);
  if (*((void *)a1 + 33) != a3) {
    uint64_t result = CA::OGL::Context::unbind_surface(a1, a3, 0);
  }
  *(unsigned char *)(*((void *)a1 + 2) + 16) = 0;
  *(unsigned char *)(*((void *)a1 + 2) + 19) = 0;
  return result;
}

uint64_t CA::OGL::bind_filter_surface(uint64_t result, uint64_t a2, float a3)
{
  uint64_t v3 = result;
  if (*(void *)(result + 264) == a2)
  {
    *(unsigned char *)(*(void *)(result + 16) + 17) = 38;
  }
  else
  {
    uint64_t result = CA::OGL::Context::bind_surface(result, a2, 0, a3 != 1.0, a3 != 1.0, 0.0);
    if (a3 > 1.0)
    {
      float v6 = *(float32x2_t **)(v3 + 16);
      float32x2_t v7 = v6[12];
      uint64_t v8 = *(void *)(a2 + 40);
      v9.i64[0] = (int)v8;
      v9.i64[1] = SHIDWORD(v8);
      __asm { FMOV            V3.2D, #-0.5 }
      v6[2].i8[3] = 5;
      int8x16_t v15 = *(float32x2_t **)(v3 + 16);
      v15[46] = vmul_f32(v7, (float32x2_t)0x3F0000003F000000);
      v15[47] = vcvt_f32_f64(vmulq_f64(vaddq_f64(vcvtq_f64_s64(v9), _Q3), vcvtq_f64_f32(v7)));
    }
  }
  return result;
}

uint64_t CA::OGL::emit_filter_quads_color(uint64_t a1, int *a2, uint64_t *a3, float a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  long long v19 = 0u;
  uint64_t v8 = *(void *)(*(void *)(a1 + 248) + 8);
  v17[0] = a1;
  v17[1] = v8;
  long long v18 = 0u;
  void v17[2] = 0;
  WORD4(v18) = 256;
  CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v17);
  v16[0] = 0;
  v16[1] = 0;
  while (1)
  {
    uint64_t result = CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v17, v16);
    if (!result) {
      break;
    }
    if (*(_DWORD *)(a1 + 92)) {
      uint64_t v10 = 6;
    }
    else {
      uint64_t v10 = 4;
    }
    if ((unint64_t)(*(void *)(a1 + 128) + 4) > *(void *)(a1 + 136)
      || (unint64_t v11 = *(void *)(a1 + 112)) != 0 && *(void *)(a1 + 104) + v10 > v11)
    {
      *(_WORD *)(a1 + 832) |= 0x20u;
      CA::OGL::Context::array_flush(a1);
      *(void *)(a1 + 128) = 0;
      *(void *)(a1 + 96) = a1 + 834;
      *(_OWORD *)(a1 + 104) = xmmword_184997E70;
    }
    CA::OGL::Context::array_rect((void *)a1, (float)a2[8] * a4, (float)a2[9] * a4, (float)(a2[10] + a2[8]) * a4, (float)(a2[11] + a2[9]) * a4);
    float v12 = (float)a2[10];
    float v13 = (float)a2[11];
    uint64_t v14 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
    *(void *)(v14 - 176) = 0;
    *(float *)(v14 - 128) = v12;
    *(_DWORD *)(v14 - 124) = 0;
    *(float *)(v14 - 80) = v12;
    *(float *)(v14 - 76) = v13;
    *(_DWORD *)(v14 - 32) = 0;
    *(float *)(v14 - 28) = v13;
    uint64_t v15 = *a3;
    *(void *)(v14 - 160) = *a3;
    *(void *)(v14 - 112) = v15;
    *(void *)(v14 - 64) = v15;
    *(void *)(v14 - 16) = v15;
  }
  return result;
}

float CA::OGL::curve_horner_coeffecients(CA::OGL *this, CA::Render::Object *a2)
{
  float result = 0.0;
  if (this && *((unsigned char *)this + 12) == 56 && *((_DWORD *)this + 4) >= 4u)
  {
    float v3 = *((double *)this + 3);
    float v4 = *((double *)this + 4);
    float v5 = *((double *)this + 5);
    float v6 = *((double *)this + 6);
    return (float)(v6 - v3) + (float)((float)(v4 - v5) * 3.0);
  }
  return result;
}

uint64_t CA::OGL::emit_filter_quads(uint64_t a1, int *a2, float a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  long long v16 = 0u;
  uint64_t v6 = *(void *)(*(void *)(a1 + 248) + 8);
  v14[0] = a1;
  v14[1] = v6;
  long long v15 = 0u;
  double v14[2] = 0;
  WORD4(v15) = 256;
  CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v14);
  v13[0] = 0;
  v13[1] = 0;
  while (1)
  {
    uint64_t result = CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v14, v13);
    if (!result) {
      break;
    }
    if (*(_DWORD *)(a1 + 92)) {
      uint64_t v8 = 6;
    }
    else {
      uint64_t v8 = 4;
    }
    if ((unint64_t)(*(void *)(a1 + 128) + 4) > *(void *)(a1 + 136)
      || (unint64_t v9 = *(void *)(a1 + 112)) != 0 && *(void *)(a1 + 104) + v8 > v9)
    {
      *(_WORD *)(a1 + 832) |= 0x20u;
      CA::OGL::Context::array_flush(a1);
      *(void *)(a1 + 128) = 0;
      *(void *)(a1 + 96) = a1 + 834;
      *(_OWORD *)(a1 + 104) = xmmword_184997E70;
    }
    CA::OGL::Context::array_rect((void *)a1, (float)a2[8] * a3, (float)a2[9] * a3, (float)(a2[10] + a2[8]) * a3, (float)(a2[11] + a2[9]) * a3);
    float v10 = (float)a2[10];
    float v11 = (float)a2[11];
    uint64_t v12 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
    *(void *)(v12 - 176) = 0;
    *(float *)(v12 - 128) = v10;
    *(_DWORD *)(v12 - 124) = 0;
    *(float *)(v12 - 80) = v10;
    *(float *)(v12 - 76) = v11;
    *(_DWORD *)(v12 - 32) = 0;
    *(float *)(v12 - 28) = v11;
  }
  return result;
}

uint64_t CA::Context::commit_transaction(CA::Context *this, CA::Transaction *a2, double a3, double *a4, uint64_t a5, const __CFArray *a6)
{
  long long v466 = a2;
  i4 = (unsigned int *)this;
  uint64_t v577 = *MEMORY[0x1E4F143B8];
  long long v514 = 0u;
  long long v513 = 0u;
  long long v512 = 0u;
  uint64_t v515 = 0;
  float64x2x2_t v511 = this;
  memset(v563, 0, sizeof(v563));
  size_t v510 = 16;
  memset(v562, 0, sizeof(v562));
  size_t v509 = 16;
  uint64_t v8 = (CA::Context **)CA::Context::retain_all_contexts((CA::Context *)1, v563, &v510, *(unint64_t **)(*((void *)this + 13) + 120), a6);
  uint64_t v549 = 1065353216;
  long long v547 = 0u;
  long long v548 = 0u;
  uint64_t v546 = 1065353216;
  long long v544 = 0u;
  long long v545 = 0u;
  v543[4] = 1065353216;
  memset(v543, 0, 32);
  uint64_t v542 = 1065353216;
  long long v540 = 0u;
  long long v541 = 0u;
  uint64_t v539 = 1065353216;
  long long v537 = 0u;
  long long v538 = 0u;
  v536[4] = 1065353216;
  memset(v536, 0, 32);
  uint64_t v535 = 1065353216;
  long long v533 = 0u;
  long long v534 = 0u;
  uint64_t v508 = 0;
  int value = CA::Transaction::get_value(*((void *)i4 + 11), 111, (const CGAffineTransform *)0x12, (CA::Mat4Impl *)((char *)&v512 + 8));
  double v10 = *((double *)&v512 + 1);
  if (*((double *)&v512 + 1) <= a3) {
    double v10 = a3;
  }
  if (value) {
    double v11 = v10;
  }
  else {
    double v11 = 0.0;
  }
  *((double *)&v512 + 1) = v11;
  *(void *)&long long v513 = 0x7FF0000000000000;
  uint64_t v12 = CA::Transaction::run_commit_handlers((uint64_t)i4, 0);
  size_t v13 = v510;
  uint64_t v487 = i4;
  if (!v510)
  {
    LODWORD(v478) = 0;
    goto LABEL_822;
  }
  uint64_t v14 = (void *)MEMORY[0x185324A30](v12);
  size_t v15 = 0;
  int8x16_t v477 = (double *)&v513;
  do
  {
    long long v16 = v8[v15];
    *(void *)&long long v512 = v16;
    *((void *)i4 + 5) = v16;
    uint64_t v17 = (pthread_mutex_t *)((char *)v16 + 16);
    pthread_mutex_lock((pthread_mutex_t *)((char *)v16 + 16));
    uint64_t v18 = *(void *)(v512 + 96);
    if (v18)
    {
      long long v19 = *(atomic_uint **)(v18 + 16);
      do
      {
        atomic_uint v20 = *v19;
        if (!*v19) {
          break;
        }
        atomic_uint v21 = *v19;
        atomic_compare_exchange_strong(v19, (unsigned int *)&v21, v20 + 1);
      }
      while (v21 != v20);
      pthread_mutex_unlock(v17);
      CA::Layer::layout_and_display_if_needed((CA::Layer *)v19, (CA::Transaction *)i4);
      CA::Layer::prepare_commit((CA::Layer *)v19, (CA::Transaction *)i4);
      while (1)
      {
        atomic_uint v22 = *v19;
        if (!*v19) {
          break;
        }
        atomic_uint v23 = *v19;
        atomic_compare_exchange_strong(v19, (unsigned int *)&v23, v22 - 1);
        if (v23 == v22)
        {
          if (v22 == 1)
          {
            CA::Layer::destroy((CA::Layer *)v19);
            CA::Layer::~Layer((CA::AttrList **)v19);
            malloc_zone = (malloc_zone_t *)get_malloc_zone();
            malloc_zone_free(malloc_zone, v19);
          }
          break;
        }
      }
    }
    else
    {
      pthread_mutex_unlock(v17);
    }
    ++v15;
    size_t v25 = v510;
  }
  while (v15 < v510);
  size_t v464 = v13;
  CA::Transaction::run_commit_handlers((uint64_t)i4, 3);
  uint64_t v486 = (CA::Context **)CA::Context::retain_all_contexts((CA::Context *)1, v562, &v509, *(unint64_t **)(*((void *)v487 + 13) + 120), v26);
  if (v25)
  {
    float v27 = v8;
    do
    {
      CA::Context::unref(*v27++, 1);
      --v25;
    }
    while (v25);
  }
  kuint64_t k = v487;
  if (v8 != v563)
  {
    float v29 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v29, v8);
  }
  *((unsigned char *)v487 + 116) |= 2u;
  int32x4_t v30 = (char *)MEMORY[0x185324A30]();
  *(void *)&long long v467 = v30;
  uint64_t v31 = *((void *)kk + 13);
  unsigned int v475 = *(_DWORD *)(v31 + 40);
  uint64_t v32 = *(void *)(v31 + 48);
  LODWORD(v480) = v32 != 0;
  int v33 = (*(unsigned char *)(v31 + 204) & 0x40) != 0 && (v509 > 1 || v32 != 0);
  float16x4_t v35 = *(uint64_t **)(v31 + 32);
  if ((v33 & 1) == 0 && !v35)
  {
    uint64_t v36 = 0;
    char v37 = 0;
    goto LABEL_464;
  }
  uint64_t v557 = 1065353216;
  long long v555 = 0u;
  long long v556 = 0u;
  uint64_t v552 = 1065353216;
  long long v550 = 0u;
  long long v551 = 0u;
  uint64_t v462 = (uint64_t **)v35;
  uint64_t v470 = v32;
  if (v35)
  {
    uint64_t v484 = (void ***)v509;
    LODWORD(v483) = v33;
    while (1)
    {
      float32x4_t v38 = (uint64_t *)v35[2];
      if (v38) {
        break;
      }
LABEL_86:
      float16x4_t v35 = (uint64_t *)*v35;
      if (!v35) {
        goto LABEL_87;
      }
    }
    while (1)
    {
      unsigned int v39 = *((_DWORD *)v38 + 2);
      LODWORD(buf) = 0;
      float32x4_t v40 = v484;
      float32x4_t v41 = v486;
      LODWORD(v530) = 0;
      if (!v484) {
        break;
      }
      while (1)
      {
        uint64_t v42 = *v41;
        if (*((_DWORD *)*v41 + 2) == v39) {
          break;
        }
        ++v41;
        float32x4_t v40 = (void ***)((char *)v40 - 1);
        if (!v40) {
          goto LABEL_42;
        }
      }
      unsigned int v43 = *((_DWORD *)v42 + 1);
      LODWORD(buf) = v43;
      if (!v43) {
        goto LABEL_43;
      }
      int32x4_t v30 = (char *)CA::Context::retain_render_ctx(v42);
      uint64_t v45 = (atomic_uint *)v30;
      if (v30)
      {
        unsigned int v44 = 0;
        LODWORD(v485) = 0;
        goto LABEL_45;
      }
      unsigned int v44 = *((_DWORD *)v42 + 3);
      LODWORD(v530) = v44;
      int v59 = *((_DWORD *)v42 + 40);
      LODWORD(v485) = v59;
      if (v44) {
        BOOL v60 = v59 == 0;
      }
      else {
        BOOL v60 = 1;
      }
      if (!v60) {
        goto LABEL_45;
      }
      uint64_t v45 = 0;
LABEL_44:
      uint64_t v42 = 0;
LABEL_45:
      uint64_t v46 = v38[2];
      if (v46)
      {
        if (v42) {
          unsigned int v47 = v39;
        }
        else {
          unsigned int v47 = 0;
        }
        LODWORD(v527) = v47;
        int32x4_t v30 = (char *)std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::find<unsigned int>(v540, *((unint64_t *)&v540 + 1), v47);
        if (v30)
        {
          uint64_t v48 = *((void *)v30 + 3);
          if (v48)
          {
            do
            {
              uint64_t v49 = v48;
              uint64_t v48 = *(void *)(v48 + 8);
            }
            while (v48);
            uint64_t v50 = (mach_msg_header_t *)(v49 + 8);
          }
          else
          {
            uint64_t v50 = v564;
          }
          *(void *)&v50->mach_msg_bits_t msgh_bits = v46;
        }
        else
        {
          int32x4_t v30 = (char *)std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v540, v47, &v527);
          *((void *)v30 + 3) = v46;
        }
        void v38[2] = 0;
      }
      if (v42 && (*((_DWORD *)v35 + 6) + 1) >= 2)
      {
        uint64_t v51 = std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)&v555, v44, &v530);
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)(v51 + 3), v43, &buf)+ 5) = v39;
        int v52 = std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::find<unsigned int>(v550, *((unint64_t *)&v550 + 1), v44);
        if (v52)
        {
          unsigned int v53 = (void *)v52[3];
        }
        else
        {
          unsigned int v54 = (malloc_zone_t *)get_malloc_zone();
          unsigned int v53 = malloc_type_zone_malloc(v54, 0x28uLL, 0x8BB15036uLL);
          v53[1] = 0;
          float v53[2] = 0;
          *unsigned int v53 = 0;
          *((unsigned char *)v53 + 24) = 0;
          *((unsigned char *)v53 + 25) = (_BYTE)v480;
          v53[4] = 0;
          std::__hash_table<std::__hash_value_type<unsigned int,CA::Render::Fence::Transaction::Info *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Fence::Transaction::Info *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Fence::Transaction::Info *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::Render::Fence::Transaction::Info *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v550, v44, &v530)[3] = v53;
        }
        int32x4_t v30 = (char *)v53;
        while (1)
        {
          int32x4_t v30 = *(char **)v30;
          if (!v30) {
            break;
          }
          if (*((_DWORD *)v30 + 2) == *((_DWORD *)v35 + 6)) {
            goto LABEL_73;
          }
        }
        int8x16_t v55 = (malloc_zone_t *)get_malloc_zone();
        int32x4_t v30 = (char *)malloc_type_zone_malloc(v55, 0x20uLL, 0x8BB15036uLL);
        *(void *)int32x4_t v30 = *v53;
        *((_DWORD *)v30 + 2) = *((_DWORD *)v35 + 6);
        *((void *)v30 + 2) = 0;
        *((void *)v30 + 3) = 0;
        *unsigned int v53 = v30;
LABEL_73:
        int32x4_t v56 = v30 + 24;
        int32x2_t v57 = v30 + 24;
        while (1)
        {
          int32x2_t v57 = *(char **)v57;
          if (!v57) {
            break;
          }
          if (*((_DWORD *)v57 + 3) == v43) {
            goto LABEL_62;
          }
        }
        int32x4_t v58 = (malloc_zone_t *)get_malloc_zone();
        int32x4_t v30 = (char *)malloc_type_zone_malloc(v58, 0x18uLL, 0x8BB15036uLL);
        *(void *)int32x4_t v30 = *v56;
        *((_DWORD *)v30 + 2) = v485;
        *((_DWORD *)v30 + 3) = v43;
        *((void *)v30 + 2) = v45;
        void *v56 = v30;
      }
      else
      {
LABEL_62:
        if (v45 && atomic_fetch_add(v45 + 2, 0xFFFFFFFF) == 1) {
          int32x4_t v30 = (char *)(*(uint64_t (**)(atomic_uint *))(*(void *)v45 + 16))(v45);
        }
      }
      float32x4_t v38 = (uint64_t *)*v38;
      int v33 = (int)v483;
      if (!v38) {
        goto LABEL_86;
      }
    }
LABEL_42:
    unsigned int v43 = 0;
LABEL_43:
    unsigned int v44 = 0;
    uint64_t v45 = 0;
    LODWORD(v485) = 0;
    goto LABEL_44;
  }
LABEL_87:
  if (v33)
  {
    size_t v61 = v509;
    kuint64_t k = v487;
    uint64_t v62 = 0;
    if (v509)
    {
      int8x16_t v63 = v486;
      do
      {
        unint64_t v64 = *v63;
        mach_msg_bits_t v65 = *((_DWORD *)*v63 + 1);
        int v66 = *((_DWORD *)*v63 + 2);
        v564[0].mach_msg_bits_t msgh_bits = v65;
        LODWORD(buf) = 0;
        if (v65)
        {
          uint64_t v67 = v62;
          int32x4_t v30 = (char *)CA::Context::retain_render_ctx(v64);
          unsigned int v68 = v30;
          if (v30)
          {
            unsigned int v69 = 0;
            int v70 = 0;
LABEL_100:
            if (*((char *)v64 + 241) < 0) {
              uint64_t v67 = *((unsigned int *)v64 + 3);
            }
            BOOL v72 = std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)&v555, v69, &buf);
            *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)(v72 + 3), v65, v564)+ 5) = v66;
            double v73 = std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::find<unsigned int>(v550, *((unint64_t *)&v550 + 1), v69);
            if (v73)
            {
              float v74 = (void *)v73[3];
              kuint64_t k = v487;
            }
            else
            {
              unsigned int v75 = (malloc_zone_t *)get_malloc_zone();
              float v74 = malloc_type_zone_malloc(v75, 0x28uLL, 0x8BB15036uLL);
              v74[1] = 0;
              float v74[2] = 0;
              *float v74 = 0;
              *((unsigned char *)v74 + 24) = 0;
              *((unsigned char *)v74 + 25) = (_BYTE)v480;
              v74[4] = 0;
              kuint64_t k = v487;
              std::__hash_table<std::__hash_value_type<unsigned int,CA::Render::Fence::Transaction::Info *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Fence::Transaction::Info *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Fence::Transaction::Info *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::Render::Fence::Transaction::Info *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v550, v69, &buf)[3] = v74;
            }
            uint64_t v62 = v67;
            uint64_t v76 = (malloc_zone_t *)get_malloc_zone();
            int32x4_t v30 = (char *)malloc_type_zone_malloc(v76, 0x18uLL, 0x8BB15036uLL);
            *(void *)int32x4_t v30 = v74[1];
            *((_DWORD *)v30 + 2) = v70;
            *((_DWORD *)v30 + 3) = v65;
            *((void *)v30 + 2) = v68;
            v74[1] = v30;
            goto LABEL_106;
          }
          unsigned int v69 = *((_DWORD *)v64 + 3);
          LODWORD(buf) = v69;
          int v70 = *((_DWORD *)v64 + 40);
          if (v69) {
            BOOL v71 = v70 == 0;
          }
          else {
            BOOL v71 = 1;
          }
          if (!v71) {
            goto LABEL_100;
          }
          kuint64_t k = v487;
          uint64_t v62 = v67;
        }
        else
        {
          kuint64_t k = v487;
        }
LABEL_106:
        ++v63;
        --v61;
      }
      while (v61);
    }
  }
  else
  {
    LODWORD(v62) = 0;
    kuint64_t k = v487;
  }
  uint64_t v532 = 1065353216;
  *((void *)&v77 + 1) = 0;
  long long v531 = 0u;
  long long v530 = 0u;
  uint64_t v78 = v551;
  if (!(void)v551)
  {
    LODWORD(v479) = 0;
    __int16 v476 = 0;
    goto LABEL_356;
  }
  int v79 = 0;
  __int16 v476 = 0;
  float64x2_t v471 = (uint64_t *)((char *)&v564[3].msgh_remote_port + 1);
  p_msgh_mach_vm_size_t size = &v564[0].msgh_size;
  CFAllocatorRef v468 = (CFAllocatorRef)&v548;
  long long v481 = &v534;
  *(void *)&long long v77 = 67109634;
  long long v463 = v77;
  LODWORD(p_msgh_remote_port) = v62;
  do
  {
    int v80 = (mach_msg_header_t *)*(unsigned int *)(v78 + 16);
    LODWORD(v527) = *(_DWORD *)(v78 + 16);
    uint64_t v81 = *(void *)(v78 + 24);
    uint64_t v82 = *(uint64_t **)v81;
    long long v483 = (uint64_t **)v81;
    LODWORD(v479) = v79;
    long long v478 = (uint64_t *)v78;
    if (v82)
    {
      int v83 = *(_DWORD *)(v82[3] + 8);
      if (!v83) {
        goto LABEL_123;
      }
    }
    else
    {
      uint64_t v91 = *(void *)(v81 + 8);
      int v83 = *(_DWORD *)(v91 + 8);
      BOOL v92 = (*(void *)v91 | v470) != 0;
      if (!v83 && v92)
      {
LABEL_123:
        int64x2_t v93 = CA::Render::Fence::applyTransaction((uint64_t **)v81);
        if (!v93) {
          goto LABEL_325;
        }
        int8x16_t v94 = v93;
        if (*((_DWORD *)v93 + 5)) {
          abort();
        }
        goto LABEL_209;
      }
      if (!v92) {
        goto LABEL_325;
      }
    }
    LODWORD(v485) = v83;
    long long v474 = v80;
    uint64_t v570 = 1065353216;
    long long buf = 0u;
    long long v569 = 0u;
    float v84 = *(uint64_t **)v81;
    if (v84)
    {
      uint64_t v85 = 0;
      uint64_t v86 = 0;
      uint64_t v87 = 0;
      do
      {
        ++v86;
        for (uint64_t i = v84[3]; i; uint64_t i = *(void *)i)
        {
          unsigned int v89 = *(_DWORD *)(i + 12);
          int32x4_t v30 = (char *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(&buf, v89);
          if (!v30)
          {
            int v90 = *(_DWORD *)(i + 8);
            int32x4_t v30 = (char *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)&buf, v89, (_DWORD *)(i + 12));
            *((_DWORD *)v30 + 5) = v90;
            kuint64_t k = v487;
            ++v85;
            ++v86;
          }
          ++v85;
        }
        ++v87;
        ++v85;
        float v84 = (uint64_t *)*v84;
      }
      while (v84);
    }
    else
    {
      uint64_t v87 = 0;
      uint64_t v86 = 0;
      uint64_t v85 = 0;
    }
    for (uint64_t j = v483[1]; j; uint64_t j = (uint64_t *)*j)
    {
      unsigned int v96 = *((_DWORD *)j + 3);
      int32x4_t v30 = (char *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(&buf, v96);
      if (!v30)
      {
        int v97 = *((_DWORD *)j + 2);
        int32x4_t v30 = (char *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)&buf, v96, (_DWORD *)j + 3);
        *((_DWORD *)v30 + 5) = v97;
        ++v85;
        ++v86;
      }
      ++v85;
    }
    if ((unint64_t)(v86 - 1) >= 0x3FFFFFFFFFFFFFFFLL)
    {
      int32x4_t v99 = 0;
    }
    else
    {
      int8x16_t v98 = (malloc_zone_t *)get_malloc_zone();
      int32x4_t v30 = (char *)malloc_type_zone_malloc(v98, 4 * v86, 0x8BB15036uLL);
      int32x4_t v99 = v30;
    }
    uint64_t v100 = v483;
    if ((unint64_t)(v85 - 1) > 0x3FFFFFFFFFFFFFFELL)
    {
      int64x2_t v102 = 0;
    }
    else
    {
      int32x4_t v101 = (malloc_zone_t *)get_malloc_zone();
      int32x4_t v30 = (char *)malloc_type_zone_malloc(v101, 4 * v85, 0x8BB15036uLL);
      int64x2_t v102 = v30;
    }
    int8x16_t v103 = (uint64_t *)v569;
    if ((void)v569)
    {
      uint64_t v104 = 0;
      do
      {
        v99[v87 + v104] = *((_DWORD *)v103 + 5);
        v102[v104++] = *((_DWORD *)v103 + 4);
        int8x16_t v103 = (uint64_t *)*v103;
      }
      while (v103);
    }
    else
    {
      uint64_t v104 = 0;
    }
    int64x2_t v105 = *v100;
    if (*v100)
    {
      uint64_t v106 = 0;
      do
      {
        v99[v106] = *((_DWORD *)v105 + 2);
        for (uint64_t k = (uint64_t *)v105[3]; k; uint64_t k = (uint64_t *)*k)
          v102[v104++] = *((_DWORD *)k + 3);
        uint64_t v108 = v104 + 1;
        v102[v104] = 0;
        ++v106;
        int64x2_t v105 = (uint64_t *)*v105;
        ++v104;
      }
      while (v105);
    }
    else
    {
      uint64_t v108 = v104;
    }
    int64x2_t v109 = v100[1];
    if (v109)
    {
      double v110 = &v102[v108];
      do
      {
        *v110++ = *((_DWORD *)v109 + 3);
        int64x2_t v109 = (uint64_t *)*v109;
      }
      while (v109);
    }
    CA::work_around_59853502((CA *)v30);
    uint64_t v111 = p_msgh_size;
    p_msgh_size[28] = 0;
    *((_OWORD *)v111 + 5) = 0u;
    *((_OWORD *)v111 + 6) = 0u;
    *((_OWORD *)v111 + 3) = 0u;
    *((_OWORD *)v111 + 4) = 0u;
    *((_OWORD *)v111 + 1) = 0u;
    *((_OWORD *)v111 + 2) = 0u;
    *(_OWORD *)uint64_t v111 = 0u;
    *(void *)&v564[1].msgh_mach_vm_size_t size = v99;
    v564[1].mach_msg_bits_t msgh_bits = 2;
    v564[1].mach_port_t msgh_local_port = 34799616;
    *(void *)&v564[1].mach_msg_id_t msgh_id = v102;
    *(void *)&v564[2].mach_port_t msgh_local_port = *MEMORY[0x1E4F14068];
    v564[1].uint64_t msgh_voucher_port = v86;
    v564[2].msgh_mach_vm_size_t size = 16777472;
    v564[2].uint64_t msgh_remote_port = 4 * v85;
    v564[2].mach_msg_id_t msgh_id = v87;
    v564[3].mach_msg_bits_t msgh_bits = v86;
    v564[3].msgh_mach_vm_size_t size = v85;
    LOBYTE(v564[3].msgh_remote_port) = (_BYTE)v480;
    int v112 = v471;
    *(_WORD *)float64x2_t v471 = 0;
    *((unsigned char *)v112 + 2) = 0;
    mach_port_t reply_port = mig_get_reply_port();
    v564[0].mach_port_t msgh_local_port = reply_port;
    v564[0].mach_msg_bits_t msgh_bits = -2147478253;
    v564[0].uint64_t msgh_remote_port = v485;
    *(void *)&v564[0].uint64_t msgh_voucher_port = 0x9D1100000000;
    if (MEMORY[0x1E4F14B18])
    {
      voucher_mach_msg_set(v564);
      mach_port_t reply_port = v564[0].msgh_local_port;
    }
    uint64_t v114 = mach_msg(v564, 3, 0x54u, 0x78u, reply_port, 0, 0);
    uint64_t msgh_remote_port = v114;
    LODWORD(v80) = v474;
    if ((v114 - 268435458) > 0xE || ((1 << (v114 - 2)) & 0x4003) == 0)
    {
      if (v114)
      {
        mig_dealloc_reply_port(v564[0].msgh_local_port);
        goto LABEL_159;
      }
      if (v564[0].msgh_id == 71)
      {
        uint64_t msgh_remote_port = 4294966988;
      }
      else if (v564[0].msgh_id == 40309)
      {
        if ((v564[0].msgh_bits & 0x80000000) != 0)
        {
          uint64_t msgh_remote_port = 4294966996;
          if (v564[1].msgh_bits != 4 || v564[0].msgh_size != 112 || v564[0].msgh_remote_port) {
            goto LABEL_351;
          }
          if (HIBYTE(v564[1].msgh_local_port) == 1
            && HIBYTE(v564[2].msgh_size) == 1
            && HIWORD(v564[2].msgh_id) << 16 == 0x100000
            && HIWORD(v564[3].msgh_remote_port) << 16 == 1114112
            && v564[1].msgh_voucher_port >> 3 == v564[3].msgh_id
            && v564[2].msgh_remote_port >> 2 == v565)
          {
            long long v469 = v99;
            LODWORD(v484) = v564[2].msgh_remote_port >> 2;
            *(void *)&long long v485 = *(void *)&v564[1].msgh_size;
            mach_vm_address_t v120 = *(void *)&v564[1].msgh_id;
            mach_port_t msgh_local_port = v564[2].msgh_local_port;
            mach_msg_bits_t msgh_bits = v564[3].msgh_bits;
            int v123 = BYTE4(v565);
            uint64_t v124 = v564[1].msgh_voucher_port >> 3;
            uint64_t msgh_remote_port = *((void *)&v565 + 1);
            goto LABEL_179;
          }
        }
        else if (v564[0].msgh_size == 36 && v564[1].msgh_remote_port)
        {
          if (v564[0].msgh_remote_port) {
            uint64_t msgh_remote_port = 4294966996;
          }
          else {
            uint64_t msgh_remote_port = v564[1].msgh_remote_port;
          }
          goto LABEL_351;
        }
        uint64_t msgh_remote_port = 4294966996;
      }
      else
      {
        uint64_t msgh_remote_port = 4294966995;
      }
LABEL_351:
      mach_msg_destroy(v564);
      goto LABEL_159;
    }
    mig_put_reply_port(v564[0].msgh_local_port);
    if (!msgh_remote_port)
    {
      long long v469 = v99;
      mach_vm_address_t v120 = 0;
      *(void *)&long long v485 = 0;
      LODWORD(v484) = msgh_remote_port;
      mach_port_t msgh_local_port = msgh_remote_port;
      mach_msg_bits_t msgh_bits = msgh_remote_port;
      int v123 = msgh_remote_port;
      uint64_t v124 = msgh_remote_port;
      uint64_t msgh_remote_port = msgh_remote_port;
LABEL_179:
      double v125 = (malloc_zone_t *)get_malloc_zone();
      int8x16_t v94 = malloc_type_zone_malloc(v125, 0x28uLL, 0x8BB15036uLL);
      *(void *)int8x16_t v94 = 0;
      *((void *)v94 + 1) = 0;
      *((_DWORD *)v94 + 4) = msgh_local_port;
      *((_DWORD *)v94 + 5) = msgh_bits;
      *((unsigned char *)v94 + 24) = v123 != 0;
      *((unsigned char *)v94 + 25) = (_BYTE)v480;
      unsigned int v126 = v484;
      unint64_t v127 = v484;
      *((void *)v94 + 4) = msgh_remote_port;
      unsigned int v128 = (uint64_t *)v124;
      uint64_t v484 = (void ***)v127;
      if (v124)
      {
        uint64_t v129 = 0;
        unint64_t v130 = 0;
        uint64_t v131 = v126 - 1;
        long long v465 = v128;
        p_uint64_t msgh_voucher_port = (mach_port_name_t *)v128;
        do
        {
          uint64_t v132 = (malloc_zone_t *)get_malloc_zone();
          uint64_t v133 = malloc_type_zone_malloc(v132, 0x20uLL, 0x8BB15036uLL);
          *(void *)uint64_t v133 = *(void *)v94;
          v133[2] = 0;
          *((void *)v133 + 2) = *(void *)(v485 + 8 * (void)v129);
          *((void *)v133 + 3) = 0;
          if (v130 < (unint64_t)v484 && *(_DWORD *)(v120 + 4 * v130))
          {
            do
            {
              unint64_t v134 = v130;
              int v135 = (malloc_zone_t *)get_malloc_zone();
              int8x16_t v136 = malloc_type_zone_malloc(v135, 0x18uLL, 0x8BB15036uLL);
              *(void *)int8x16_t v136 = *((void *)v133 + 3);
              v136[2] = 0;
              v136[3] = *(_DWORD *)(v120 + 4 * v130);
              *((void *)v136 + 2) = 0;
              *((void *)v133 + 3) = v136;
              if (v131 == v130) {
                break;
              }
            }
            while (*(_DWORD *)(v120 + 4 * v130++ + 4));
            unint64_t v130 = v134 + 1;
          }
          ++v130;
          *(void *)int8x16_t v94 = v133;
          uint64_t v129 = (mach_port_name_t *)((char *)v129 + 1);
        }
        while (v129 != p_msgh_voucher_port);
        LODWORD(v128) = v465;
        unsigned int v138 = v465;
        unint64_t v127 = (unint64_t)v484;
      }
      else
      {
        unsigned int v138 = 0;
        unint64_t v130 = 0;
      }
      LODWORD(v80) = v474;
      int32x4_t v99 = v469;
      if (v130 < v127)
      {
        if (*(_DWORD *)(v120 + 4 * v130))
        {
          long long v139 = (char *)(~v130 + v127);
          float64x2_t v140 = (int *)(v120 + 4 * v130 + 4);
          do
          {
            float64x2_t v141 = (malloc_zone_t *)get_malloc_zone();
            float64x2_t v142 = malloc_type_zone_malloc(v141, 0x18uLL, 0x8BB15036uLL);
            *(void *)float64x2_t v142 = *((void *)v94 + 1);
            v142[2] = 0;
            v142[3] = *(v140 - 1);
            *((void *)v142 + 2) = 0;
            *((void *)v94 + 1) = v142;
            if (!v139) {
              break;
            }
            int v143 = *v140++;
            --v139;
          }
          while (v143);
          unsigned int v138 = v128;
          int32x4_t v99 = v469;
          unint64_t v127 = (unint64_t)v484;
        }
        else
        {
          unsigned int v138 = v128;
        }
      }
      kuint64_t k = v487;
      if ((void)v485 && v138) {
        mach_vm_deallocate(*MEMORY[0x1E4F14960], v485, (*MEMORY[0x1E4F14B00] + 8 * v138 - 1) & -*MEMORY[0x1E4F14B00]);
      }
      if (v120 && v127) {
        mach_vm_deallocate(*MEMORY[0x1E4F14960], v120, (*MEMORY[0x1E4F14B00] + 4 * v127 - 1) & -*MEMORY[0x1E4F14B00]);
      }
      goto LABEL_204;
    }
LABEL_159:
    if (msgh_remote_port == 268435459)
    {
      *(unsigned char *)(v512 + 241) |= 2u;
    }
    else if (msgh_remote_port == -81182719)
    {
LABEL_865:
      x_log_crash("Unentitled call to server!");
      abort();
    }
    if (x_log_hook_p())
    {
      uint64_t v116 = *(unsigned int *)(v512 + 4);
      uint64_t v458 = msgh_remote_port;
      uint64_t v459 = mach_error_string(msgh_remote_port);
      uint64_t v457 = v116;
      x_log_();
    }
    else
    {
      int64x2_t v117 = x_log_category_api;
      if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
      {
        mach_msg_size_t v118 = *(_DWORD *)(v512 + 4);
        float16x4_t v119 = mach_error_string(msgh_remote_port);
        v564[0].mach_msg_bits_t msgh_bits = v463;
        v564[0].msgh_mach_vm_size_t size = v118;
        LOWORD(v564[0].msgh_remote_port) = 1024;
        *(mach_port_t *)((char *)&v564[0].msgh_remote_port + 2) = msgh_remote_port;
        HIWORD(v564[0].msgh_local_port) = 2080;
        *(void *)&v564[0].uint64_t msgh_voucher_port = v119;
        _os_log_impl(&dword_184668000, v117, OS_LOG_TYPE_ERROR, "apply fence tx failed (client=0x%x) [0x%x %s]", (uint8_t *)v564, 0x18u);
      }
    }
    int8x16_t v94 = 0;
LABEL_204:
    if (v99)
    {
      long long v144 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v144, v99);
    }
    if (v102)
    {
      uint64_t v145 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v145, v102);
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&buf);
    if (!v94)
    {
      uint64_t v81 = (uint64_t)v483;
      goto LABEL_325;
    }
LABEL_209:
    if (*((_DWORD *)v94 + 4)) {
      operator new();
    }
    unsigned int v146 = *((_DWORD *)v94 + 5);
    if (v146 == -1)
    {
      mach_port_deallocate(*MEMORY[0x1E4F14960], 0xFFFFFFFF);
LABEL_218:
      LODWORD(v484) = 0;
      goto LABEL_219;
    }
    if (!v146)
    {
      LODWORD(v484) = 0;
      goto LABEL_219;
    }
    if (*((unsigned char *)v94 + 24))
    {
      mach_port_deallocate(*MEMORY[0x1E4F14960], *((_DWORD *)v94 + 5));
      goto LABEL_218;
    }
    std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)&v537, *((_DWORD *)v94 + 5), *((_DWORD *)v94 + 5));
    if (!v476)
    {
      __int16 v476 = 0;
      if (p_msgh_remote_port)
      {
        if (v80 == p_msgh_remote_port) {
          __int16 v476 = +[CABatchInfo _newInfoWithUnownedPort:name:]((uint64_t)CABatchInfo, v146, *((void *)v94 + 4));
        }
      }
    }
    uint64_t v197 = *((void *)kk + 13);
    unsigned int v475 = *(_DWORD *)(v197 + 40);
    LODWORD(v484) = v146;
    if (!v475)
    {
      unsigned int add = atomic_fetch_add(CA::Transaction::capture_ftx_seed(void)::next_ftx_seed, 1u);
      unsigned int v475 = add + 1;
      *(_DWORD *)(v197 + 40) = add + 1;
      if (add == -1)
      {
        *(void *)&long long v485 = 0;
        unsigned int v475 = atomic_fetch_add(CA::Transaction::capture_ftx_seed(void)::next_ftx_seed, 1u) + 1;
        *(_DWORD *)(v197 + 40) = v475;
        goto LABEL_220;
      }
    }
LABEL_219:
    *(void *)&long long v485 = 0;
LABEL_220:
    unsigned int v147 = v527;
    if ((void)v485)
    {
      uint64_t v148 = *(void *)v94 + 24;
      while (1)
      {
        uint64_t v148 = *(void *)v148;
        if (!v148) {
          break;
        }
        float32x4_t v149 = std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)&v555, v147, &v527);
        std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)(v149 + 3), *(_DWORD *)(v148 + 12), (_DWORD *)(v148 + 12));
        kdebug_trace();
      }
      [(id)v485 invalidate];

      unsigned int v147 = v527;
    }
    while (1)
    {
      float v153 = *(void **)v94;
      if (!*(void *)v94) {
        break;
      }
      while (1)
      {
        double v150 = (void *)v153[3];
        if (!v150) {
          break;
        }
        v153[3] = *v150;
        double v151 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v151, v150);
      }
      *(void *)int8x16_t v94 = *v153;
      double v152 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v152, v153);
    }
    unsigned int v154 = v484 - 1;
    uint64_t v81 = (uint64_t)v483;
    while (1)
    {
      float v155 = (_DWORD *)*((void *)v94 + 1);
      if (!v155) {
        break;
      }
      if (v154 > 0xFFFFFFFD) {
        goto LABEL_308;
      }
      uint64_t v156 = std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)&v555, v147, &v527);
      v564[0].mach_msg_bits_t msgh_bits = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)(v156 + 3), v155[3], v155 + 3)+ 5);
      unint64_t v157 = v564[0].msgh_bits;
      *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v536, v564[0].msgh_bits, v564)+ 5) = v484;
      if (!*((void *)v94 + 4)) {
        goto LABEL_308;
      }
      int v158 = v155[3];
      *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)&v530, v157, v564)+ 5) = v158;
      unint64_t v159 = *((void *)&v533 + 1);
      *(void *)&long long v485 = *((void *)v94 + 4);
      if (*((void *)&v533 + 1))
      {
        uint8x8_t v160 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v533 + 8));
        v160.i16[0] = vaddlv_u8(v160);
        if (v160.u32[0] > 1uLL)
        {
          unint64_t v161 = v157;
          if (*((void *)&v533 + 1) <= v157) {
            unint64_t v161 = v157 % *((void *)&v533 + 1);
          }
        }
        else
        {
          unint64_t v161 = (DWORD2(v533) - 1) & v157;
        }
        float32x4_t v162 = *(void ***)(v533 + 8 * v161);
        if (v162)
        {
          uint64_t v163 = *v162;
          if (*v162)
          {
            do
            {
              unint64_t v164 = v163[1];
              if (v164 == v157)
              {
                if (*((_DWORD *)v163 + 4) == v157)
                {
                  uint64_t v185 = v485;
                  goto LABEL_307;
                }
              }
              else
              {
                if (v160.u32[0] > 1uLL)
                {
                  if (v164 >= *((void *)&v533 + 1)) {
                    v164 %= *((void *)&v533 + 1);
                  }
                }
                else
                {
                  v164 &= *((void *)&v533 + 1) - 1;
                }
                if (v164 != v161) {
                  break;
                }
              }
              uint64_t v163 = (void *)*v163;
            }
            while (v163);
          }
        }
      }
      else
      {
        unint64_t v161 = 0;
      }
      uint64_t v163 = operator new(0x20uLL);
      *uint64_t v163 = 0;
      v163[1] = v157;
      *((_DWORD *)v163 + 4) = v157;
      v163[3] = 0;
      float v165 = (float)(unint64_t)(*((void *)&v534 + 1) + 1);
      if (v159 && (float)(*(float *)&v535 * (float)v159) >= v165)
      {
        unint64_t v157 = v161;
        uint64_t v185 = v485;
        goto LABEL_297;
      }
      BOOL v166 = (v159 & (v159 - 1)) != 0;
      if (v159 < 3) {
        BOOL v166 = 1;
      }
      unint64_t v167 = v166 | (2 * v159);
      unint64_t v168 = vcvtps_u32_f32(v165 / *(float *)&v535);
      if (v167 <= v168) {
        int8x8_t prime = (int8x8_t)v168;
      }
      else {
        int8x8_t prime = (int8x8_t)v167;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        unint64_t v159 = *((void *)&v533 + 1);
      }
      if (*(void *)&prime > v159) {
        goto LABEL_263;
      }
      if (*(void *)&prime < v159)
      {
        unint64_t v176 = vcvtps_u32_f32((float)*((unint64_t *)&v534 + 1) / *(float *)&v535);
        if (v159 < 3 || (uint8x8_t v177 = (uint8x8_t)vcnt_s8((int8x8_t)v159), v177.i16[0] = vaddlv_u8(v177), v177.u32[0] > 1uLL))
        {
          unint64_t v176 = std::__next_prime(v176);
        }
        else
        {
          uint64_t v178 = 1 << -(char)__clz(v176 - 1);
          if (v176 >= 2) {
            unint64_t v176 = v178;
          }
        }
        if (*(void *)&prime <= v176) {
          int8x8_t prime = (int8x8_t)v176;
        }
        if (*(void *)&prime < v159)
        {
          if (!*(void *)&prime)
          {
            int32x4_t v186 = (void *)v533;
            *(void *)&long long v533 = 0;
            uint64_t v185 = v485;
            if (v186) {
              operator delete(v186);
            }
            unint64_t v159 = 0;
            *((void *)&v533 + 1) = 0;
            goto LABEL_293;
          }
LABEL_263:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v170 = operator new(8 * *(void *)&prime);
          uint64_t v171 = (void *)v533;
          *(void *)&long long v533 = v170;
          if (v171) {
            operator delete(v171);
          }
          uint64_t v172 = 0;
          *((int8x8_t *)&v533 + 1) = prime;
          do
            *(void *)(v533 + 8 * v172++) = 0;
          while (*(void *)&prime != v172);
          uint64_t v173 = (void **)v534;
          if ((void)v534)
          {
            unint64_t v174 = *(void *)(v534 + 8);
            uint8x8_t v175 = (uint8x8_t)vcnt_s8(prime);
            v175.i16[0] = vaddlv_u8(v175);
            if (v175.u32[0] > 1uLL)
            {
              if (v174 >= *(void *)&prime) {
                v174 %= *(void *)&prime;
              }
            }
            else
            {
              v174 &= *(void *)&prime - 1;
            }
            *(void *)(v533 + 8 * v174) = v481;
            for (m = *v173; m; unint64_t v174 = v180)
            {
              unint64_t v180 = m[1];
              if (v175.u32[0] > 1uLL)
              {
                if (v180 >= *(void *)&prime) {
                  v180 %= *(void *)&prime;
                }
              }
              else
              {
                v180 &= *(void *)&prime - 1;
              }
              if (v180 != v174)
              {
                if (!*(void *)(v533 + 8 * v180))
                {
                  *(void *)(v533 + 8 * v180) = v173;
                  goto LABEL_288;
                }
                uint64_t *v173 = (void *)*m;
                void *m = **(void **)(v533 + 8 * v180);
                **(void **)(v533 + 8 * v180) = m;
                m = v173;
              }
              unint64_t v180 = v174;
LABEL_288:
              uint64_t v173 = (void **)m;
              m = (void *)*m;
            }
          }
          unint64_t v159 = (unint64_t)prime;
          goto LABEL_292;
        }
        unint64_t v159 = *((void *)&v533 + 1);
      }
LABEL_292:
      uint64_t v185 = v485;
LABEL_293:
      if ((v159 & (v159 - 1)) != 0)
      {
        if (v159 <= v157) {
          v157 %= v159;
        }
      }
      else
      {
        unint64_t v157 = (v159 - 1) & v157;
      }
LABEL_297:
      uint64_t v181 = v533;
      uint64_t v182 = *(void **)(v533 + 8 * v157);
      if (v182)
      {
        *uint64_t v163 = *v182;
      }
      else
      {
        *uint64_t v163 = v534;
        *(void *)&long long v534 = v163;
        *(void *)(v181 + 8 * v157) = v481;
        if (!*v163) {
          goto LABEL_306;
        }
        unint64_t v183 = *(void *)(*v163 + 8);
        if ((v159 & (v159 - 1)) != 0)
        {
          if (v183 >= v159) {
            v183 %= v159;
          }
        }
        else
        {
          v183 &= v159 - 1;
        }
        uint64_t v182 = (void *)(v533 + 8 * v183);
      }
      *uint64_t v182 = v163;
LABEL_306:
      ++*((void *)&v534 + 1);
LABEL_307:
      v163[3] = v185;
      uint64_t v81 = (uint64_t)v483;
LABEL_308:
      *((void *)v94 + 1) = *(void *)v155;
      uint64_t v184 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v184, v155);
    }
    uint64_t v187 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v187, v94);
    kuint64_t k = v487;
LABEL_325:
    while (1)
    {
      int8x16_t v192 = *(uint64_t **)v81;
      if (!*(void *)v81) {
        break;
      }
      while (1)
      {
        unint64_t v190 = (uint64_t *)v192[3];
        if (!v190) {
          break;
        }
        uint64_t v188 = (atomic_uint *)v190[2];
        if (v188 && atomic_fetch_add(v188 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v188 + 16))(v188);
        }
        v192[3] = *v190;
        uint64_t v189 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v189, v190);
      }
      *(void *)uint64_t v81 = *v192;
      uint64_t v191 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v191, v192);
    }
    while (1)
    {
      uint64_t v193 = *(void **)(v81 + 8);
      if (!v193) {
        break;
      }
      char v194 = (atomic_uint *)v193[2];
      if (v194 && atomic_fetch_add(v194 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v194 + 16))(v194);
      }
      *(void *)(v81 + 8) = *v193;
      uint64_t v195 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v195, v193);
    }
    uint64_t v196 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v196, (void *)v81);
    uint64_t v78 = *v478;
    int v79 = (int)v479;
  }
  while (*v478);
  for (unint64_t n = (void *)v531; n; unint64_t n = (void *)*n)
    kdebug_trace();
LABEL_356:
  uint64_t v200 = *((void *)kk + 13);
  uint64_t v201 = *(void **)(v200 + 48);
  if (v201)
  {
    do
    {
      (*(void (**)(void))(*v201 + 16))();
      uint64_t v201 = (void *)v201[1];
    }
    while (v201);
    CA::Transaction::free_batch_handlers_list(*(void **)(v200 + 48));
    *(void *)(v200 + 48) = 0;
  }
  uint64_t v36 = v476;
  for (iuint64_t i = v462; ii; iuint64_t i = (uint64_t **)*ii)
    [ii[1] invalidate];
  if (!*((void *)&v547 + 1)) {
    goto LABEL_463;
  }
  int64_t v203 = *(void ***)v547;
  if (!*(void *)v547) {
    goto LABEL_463;
  }
  uint64_t v204 = (long long *)*v203;
  if (!*v203) {
    goto LABEL_463;
  }
  uint8x8_t v205 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v547 + 8));
  v205.i16[0] = vaddlv_u8(v205);
  while (2)
  {
    unint64_t v206 = *((void *)v204 + 1);
    if (v206)
    {
      if (v205.u32[0] > 1uLL)
      {
        if (v206 < *((void *)&v547 + 1) || v206 % *((void *)&v547 + 1)) {
          goto LABEL_463;
        }
      }
      else if ((v206 & (*((void *)&v547 + 1) - 1)) != 0)
      {
        goto LABEL_463;
      }
      goto LABEL_373;
    }
    if (*((_DWORD *)v204 + 4))
    {
LABEL_373:
      uint64_t v204 = *(long long **)v204;
      if (!v204) {
        goto LABEL_463;
      }
      continue;
    }
    break;
  }
  uint64_t v207 = *((void *)v204 + 3);
  unint64_t v208 = *((void *)&v544 + 1);
  if (*((void *)&v544 + 1))
  {
    unint64_t v209 = *(void ***)v544;
    if (*(void *)v544)
    {
      BOOL v210 = (char *)*v209;
      if (*v209)
      {
        uint8x8_t v211 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v544 + 8));
        v211.i16[0] = vaddlv_u8(v211);
        do
        {
          unint64_t v212 = *((void *)v210 + 1);
          if (v212)
          {
            if (v211.u32[0] > 1uLL)
            {
              if (v212 < *((void *)&v544 + 1)) {
                break;
              }
              unint64_t v213 = v212 % *((void *)&v544 + 1);
            }
            else
            {
              unint64_t v213 = v212 & (*((void *)&v544 + 1) - 1);
            }
            if (v213) {
              break;
            }
          }
          else if (!*((_DWORD *)v210 + 4))
          {
            goto LABEL_406;
          }
          BOOL v210 = *(char **)v210;
        }
        while (v210);
      }
    }
  }
  *(void *)&v564[0].uint64_t msgh_voucher_port = 1;
  BOOL v210 = (char *)operator new(0x40uLL);
  *(void *)&v564[0].mach_msg_bits_t msgh_bits = v210;
  *(void *)&v564[0].uint64_t msgh_remote_port = &v545;
  *(_OWORD *)(v210 + 24) = 0u;
  *(_OWORD *)(v210 + 40) = 0u;
  *(void *)BOOL v210 = 0;
  *((void *)v210 + 1) = 0;
  *((_DWORD *)v210 + 4) = 0;
  *((_DWORD *)v210 + 14) = 1065353216;
  float v214 = (float)(unint64_t)(*((void *)&v545 + 1) + 1);
  if (!v208 || (float)(*(float *)&v546 * (float)v208) < v214)
  {
    BOOL v215 = 1;
    if (v208 >= 3) {
      BOOL v215 = (v208 & (v208 - 1)) != 0;
    }
    unint64_t v216 = v215 | (2 * v208);
    unint64_t v217 = vcvtps_u32_f32(v214 / *(float *)&v546);
    if (v216 <= v217) {
      size_t v218 = v217;
    }
    else {
      size_t v218 = v216;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>((uint64_t)&v544, v218);
    unint64_t v208 = *((void *)&v544 + 1);
  }
  int8x16_t v219 = (void *)v544;
  uint64_t v220 = *(void **)v544;
  if (*(void *)v544)
  {
    *(void *)BOOL v210 = *v220;
    goto LABEL_404;
  }
  *(void *)BOOL v210 = v545;
  *(void *)&long long v545 = v210;
  *int8x16_t v219 = &v545;
  if (*(void *)v210)
  {
    unint64_t v221 = *(void *)(*(void *)v210 + 8);
    if ((v208 & (v208 - 1)) != 0)
    {
      if (v221 >= v208) {
        v221 %= v208;
      }
    }
    else
    {
      v221 &= v208 - 1;
    }
    uint64_t v220 = (void *)(v544 + 8 * v221);
LABEL_404:
    *uint64_t v220 = v210;
  }
  *(void *)&v564[0].mach_msg_bits_t msgh_bits = 0;
  ++*((void *)&v545 + 1);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,void *>>>>::reset[abi:nn180100]((uint64_t)v564);
LABEL_406:
  uint64_t v36 = v476;
  if (*((void *)v210 + 6))
  {
    uint64_t v529 = 1065353216;
    long long v528 = 0u;
    long long v527 = 0u;
    os_unfair_lock_lock((os_unfair_lock_t)v207);
    if (!*(unsigned char *)(v207 + 28)) {
      __assert_rtn("activate_and_wait", "render-fence.cpp", 442, "_has_receive_right");
    }
    kdebug_trace();
    double v222 = 0.0;
    while (1)
    {
      long long v566 = 0u;
      long long v567 = 0u;
      long long v565 = 0u;
      memset(v564, 0, sizeof(v564));
      uint64_t v223 = (char *)mach_msg(v564, 258, 0, 0x90u, *(_DWORD *)(v207 + 24), 0x1F4u, 0);
      if (v223) {
        break;
      }
      uint64_t v570 = 1065353216;
      long long buf = 0u;
      long long v569 = 0u;
      double v518 = 0.0;
      unsigned int v517 = 0;
      if (CA::Render::Fence::extract_msg((uint64_t)v564, 0x90uLL, (uint64_t)&buf, &v518, &v517, &v516, 0, 0))
      {
        if (v564[0].msgh_id == 1919772259)
        {
          double v222 = 0.0;
          LODWORD(v223) = 1;
        }
        else if (v564[0].msgh_id == 1919706727)
        {
          for (juint64_t j = (void *)v569; jj; juint64_t j = (void *)*jj)
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__erase_unique<unsigned long long>((void *)v210 + 3, jj[2]);
          if (v518 > v222) {
            double v222 = v518;
          }
          unsigned int v225 = v517;
          if (v517 - 1 < 0xFFFFFFFE
            && !std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(&v527, v517))
          {
            std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)&v527, v225, v225);
            v564[1].mach_msg_id_t msgh_id = 0;
          }
          LODWORD(v223) = *((void *)v210 + 6) == 0;
        }
        else
        {
          LODWORD(v223) = 0;
        }
      }
      mach_msg_destroy(v564);
      std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&buf);
      if (v223) {
        goto LABEL_429;
      }
    }
    if (x_log_hook_p())
    {
      uint64_t v459 = v223;
      x_log_();
    }
    else
    {
      long long v226 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 67109120;
        DWORD1(buf) = v223;
        _os_log_impl(&dword_184668000, v226, OS_LOG_TYPE_DEFAULT, "failed to wait for fence tx reply: %x\n", (uint8_t *)&buf, 8u);
      }
    }
LABEL_429:
    kdebug_trace();
    os_unfair_lock_unlock((os_unfair_lock_t)v207);
    if (*((double *)&v512 + 1) == 0.0) {
      *((double *)&v512 + 1) = v222;
    }
    float64x2_t v227 = (uint64_t *)v528;
    for (kk = v487; v227; float64x2_t v227 = (uint64_t *)*v227)
      mach_port_deallocate(*MEMORY[0x1E4F14960], *((_DWORD *)v227 + 4));
    std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v527);
    uint64_t v36 = v476;
  }
  if (v207)
  {
    CA::Render::Fence::Transaction::Observer::~Observer((CA::Render::Fence::Transaction::Observer *)v207);
    MEMORY[0x185323DC0]();
  }
  unint64_t v228 = *((void *)&v547 + 1);
  unint64_t v229 = *((void *)v204 + 1);
  uint8x8_t v230 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v547 + 8));
  v230.i16[0] = vaddlv_u8(v230);
  if (v230.u32[0] > 1uLL)
  {
    if (v229 >= *((void *)&v547 + 1)) {
      v229 %= *((void *)&v547 + 1);
    }
  }
  else
  {
    v229 &= *((void *)&v547 + 1) - 1;
  }
  unint64_t v231 = *(long long **)(v547 + 8 * v229);
  do
  {
    long long v232 = v231;
    unint64_t v231 = *(long long **)v231;
  }
  while (v231 != v204);
  if (v232 == &v548) {
    goto LABEL_453;
  }
  unint64_t v233 = *((void *)v232 + 1);
  if (v230.u32[0] > 1uLL)
  {
    if (v233 >= *((void *)&v547 + 1)) {
      v233 %= *((void *)&v547 + 1);
    }
  }
  else
  {
    v233 &= *((void *)&v547 + 1) - 1;
  }
  if (v233 != v229)
  {
LABEL_453:
    if (!*(void *)v204) {
      goto LABEL_454;
    }
    unint64_t v234 = *(void *)(*(void *)v204 + 8);
    if (v230.u32[0] > 1uLL)
    {
      if (v234 >= *((void *)&v547 + 1)) {
        v234 %= *((void *)&v547 + 1);
      }
    }
    else
    {
      v234 &= *((void *)&v547 + 1) - 1;
    }
    if (v234 != v229) {
LABEL_454:
    }
      *(void *)(v547 + 8 * v229) = 0;
  }
  uint64_t v235 = *(long long **)v204;
  if (*(void *)v204)
  {
    unint64_t v236 = *((void *)v235 + 1);
    if (v230.u32[0] > 1uLL)
    {
      if (v236 >= v228) {
        v236 %= v228;
      }
    }
    else
    {
      v236 &= v228 - 1;
    }
    if (v236 != v229)
    {
      *(void *)(v547 + 8 * v236) = v232;
      uint64_t v235 = *(long long **)v204;
    }
  }
  *(void *)long long v232 = v235;
  *(void *)uint64_t v204 = 0;
  --*((void *)&v548 + 1);
  operator delete(v204);
LABEL_463:
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v530);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v550);
  std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>>>::~__hash_table((uint64_t)&v555);
  char v37 = v479 & 1;
LABEL_464:
  CA::Transaction::run_commit_handlers((uint64_t)kk, 1);
  uint64_t v237 = *((void *)kk + 13);
  if (*(void *)(v237 + 16))
  {
    uint64_t v238 = *(void **)(v237 + 16);
    if (v238)
    {
      uint64_t v239 = 0;
      do
      {
        long long v240 = v238;
        uint64_t v238 = (void *)*v238;
        *long long v240 = v239;
        uint64_t v239 = v240;
      }
      while (v238);
    }
    else
    {
      long long v240 = 0;
    }
    *((void *)kk + 2) = v240;
    *(void *)(v237 + 16) = 0;
  }
  uint64_t v241 = mach_absolute_time();
  double v242 = CATimeWithHostTime(v241);
  double v243 = *((double *)&v512 + 1);
  if (v11 != 0.0)
  {
    if (*((double *)&v512 + 1) <= v242) {
      double v243 = v242;
    }
    *((double *)&v512 + 1) = v243;
  }
  double v507 = 0.0;
  if (v243 == 0.0)
  {
    CA::Transaction::get_value(*((void *)kk + 11), 192, (const CGAffineTransform *)0x12, (CA::Mat4Impl *)&v507);
    LOBYTE(v564[0].msgh_bits) = 0;
    if (pthread_main_np()) {
      CA::Transaction::get_value(*((void *)kk + 11), 366, (const CGAffineTransform *)7, (CA::Mat4Impl *)v564);
    }
    if (LOBYTE(v564[0].msgh_bits)) {
      char v244 = 1;
    }
    else {
      char v244 = v37;
    }
    if ((v244 & 1) != 0
      || (double v245 = *(double *)(*((void *)kk + 13) + 176), v245 == 0.0)
      || (double v246 = v245 + 0.001, v246 <= v242))
    {
      double v246 = v507;
      if (v242 > v507) {
        double v246 = v242;
      }
    }
    else if (v246 <= v507)
    {
      double v246 = v507;
    }
    *((double *)&v512 + 1) = v246;
  }
  if (CA::Transaction::get_value(*((void *)kk + 11), 193, (const CGAffineTransform *)0x12, (CA::Mat4Impl *)&v507))
  {
    double v248 = *((double *)&v512 + 1);
    if (*((double *)&v512 + 1) <= v507) {
      double v248 = v507;
    }
    *((double *)&v512 + 1) = v248;
  }
  __int16 v476 = v36;
  if (!v509)
  {
    LODWORD(v249) = 0;
    LODWORD(v478) = 0;
    LODWORD(v470) = 0;
    goto LABEL_781;
  }
  float64x2_t v471 = 0;
  LODWORD(v470) = 0;
  LODWORD(v478) = 0;
  uint64_t v249 = 0;
  unint64_t v250 = 0;
  CFAllocatorRef v251 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  long long v481 = (long long *)v506;
  p_uint64_t msgh_voucher_port = (mach_port_name_t *)&v513 + 2;
  long long v480 = (long long *)v503;
  p_uint64_t msgh_remote_port = &v564[1].msgh_remote_port;
  long long v474 = &v564[1];
  p_msgh_mach_vm_size_t size = (mach_msg_size_t *)v500;
  double v252 = v242 - a3;
  CFAllocatorRef v468 = v251;
  long long v469 = (_DWORD *)v475;
  long long v465 = (uint64_t *)&v541;
  *(void *)&long long v247 = 67109634;
  long long v463 = v247;
  long long v467 = xmmword_1849981E0;
  while (2)
  {
    *(void *)&long long v512 = v486[v250];
    uint64_t v253 = v512;
    LOBYTE(v515) = 0;
    uint64_t v254 = p_msgh_voucher_port;
    *(void *)p_uint64_t msgh_voucher_port = 0;
    *((void *)v254 + 1) = 0;
    uint64_t v255 = *(unsigned int *)(v253 + 4);
    LODWORD(v550) = *(_DWORD *)(v253 + 8);
    char v256 = *(unsigned char *)(*((void *)v487 + 13) + 204);
    long long v483 = (uint64_t **)v255;
    if ((v256 & 0x20) == 0)
    {
      kdebug_trace();
      uint64_t v253 = v512;
    }
    uint64_t v257 = (pthread_mutex_t *)(v253 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(v253 + 16));
    uint64_t v262 = v512;
    uint64_t v263 = v487;
    *((void *)v487 + 5) = v512;
    *(void *)(v262 + 208) = &v511;
    unsigned int v264 = v263[25];
    v263[25] = v264 + 1;
    if (!v264)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
      uint64_t v262 = v512;
    }
    uint64_t v265 = *(CA::Render::Context **)(v262 + 104);
    if (v265)
    {
      *(void *)&long long v514 = *(void *)(v262 + 104);
      CA::Render::Context::will_commit(v265);
      uint64_t v262 = v512;
    }
    if (!*(_DWORD *)(v262 + 160) || (*(unsigned char *)(v262 + 241) & 2) != 0)
    {
      uint64_t v484 = 0;
      *(void *)&long long v485 = 0;
    }
    else
    {
      unsigned int v266 = v550;
      uint64_t v267 = std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::find<unsigned int>(v543[0], v543[1], v550);
      if (v267)
      {
        if (v267[6]) {
          operator new();
        }
        LODWORD(v479) = 0;
      }
      else
      {
        LODWORD(v479) = 0;
      }
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_deferred_lock);
      if (CA::Context::_deferred_by_lid
        && std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Context::_deferred_by_lid, v266))
      {
        float v268 = (malloc_zone_t *)get_malloc_zone();
        float v269 = malloc_type_zone_malloc(v268, 0x30uLL, 0x8BB15036uLL);
        v269[1] = 0;
        v269[2] = 0;
        *((unsigned char *)v269 + 44) = 0;
        *(void *)&long long v485 = v269;
        *float v269 = 0;
        if (!CA::Context::_deferred_by_lid) {
          operator new();
        }
        float v270 = (void *)std::__hash_table<std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)CA::Context::_deferred_by_lid, v266, &v550)[3];
        while (v270)
        {
          uint64_t v271 = v270;
          float v270 = (void *)*v270;
          if (!v270) {
            goto LABEL_522;
          }
        }
        uint64_t v271 = std::__hash_table<std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::Context::DeferredCommit *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)CA::Context::_deferred_by_lid, v266, &v550)+ 3;
LABEL_522:
        *uint64_t v271 = v485;
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_deferred_lock);
        float v275 = (malloc_zone_t *)get_malloc_zone();
        uint64_t v276 = malloc_type_zone_malloc(v275, 0xC0uLL, 0x8BB15036uLL);
        uint64_t v274 = (uint64_t)v276;
        if (v276)
        {
          CA::Render::Encoder::Encoder((uint64_t)v276, 0, 2, (int)v483, *((double *)&v512 + 1));
          *(void *)uint64_t v274 = &unk_1ED02E140;
          *(_OWORD *)(v274 + 120) = 0u;
          *(_OWORD *)(v274 + 136) = 0u;
          *(_OWORD *)(v274 + 152) = 0u;
          *(void *)(v274 + 168) = 0;
          *(_DWORD *)(v274 + 176) = 1065353216;
          *(void *)(v274 + 184) = 0;
        }
        char v277 = v256;
        uint64_t v278 = std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)&v540, v266, &v550)[3];
        long long v279 = v540;
        uint64_t v280 = std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::find<unsigned int>(v540, *((unint64_t *)&v540 + 1), v266);
        if (v280)
        {
          unint64_t v281 = v280[1];
          uint8x8_t v282 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v279 + 8));
          v282.i16[0] = vaddlv_u8(v282);
          if (v282.u32[0] > 1uLL)
          {
            if (v281 >= *((void *)&v279 + 1)) {
              v281 %= *((void *)&v279 + 1);
            }
          }
          else
          {
            v281 &= *((void *)&v279 + 1) - 1;
          }
          int32x4_t v283 = *(uint64_t **)(v279 + 8 * v281);
          do
          {
            unint64_t v284 = v283;
            int32x4_t v283 = (uint64_t *)*v283;
          }
          while (v283 != v280);
          if (v284 == v465) {
            goto LABEL_542;
          }
          unint64_t v285 = v284[1];
          if (v282.u32[0] > 1uLL)
          {
            if (v285 >= *((void *)&v279 + 1)) {
              v285 %= *((void *)&v279 + 1);
            }
          }
          else
          {
            v285 &= *((void *)&v279 + 1) - 1;
          }
          if (v285 != v281)
          {
LABEL_542:
            if (!*v280) {
              goto LABEL_543;
            }
            unint64_t v286 = *(void *)(*v280 + 8);
            if (v282.u32[0] > 1uLL)
            {
              if (v286 >= *((void *)&v279 + 1)) {
                v286 %= *((void *)&v279 + 1);
              }
            }
            else
            {
              v286 &= *((void *)&v279 + 1) - 1;
            }
            if (v286 != v281) {
LABEL_543:
            }
              *(void *)(v279 + 8 * v281) = 0;
          }
          uint64_t v287 = *v280;
          if (*v280)
          {
            unint64_t v288 = *(void *)(v287 + 8);
            if (v282.u32[0] > 1uLL)
            {
              if (v288 >= *((void *)&v279 + 1)) {
                v288 %= *((void *)&v279 + 1);
              }
            }
            else
            {
              v288 &= *((void *)&v279 + 1) - 1;
            }
            if (v288 != v281)
            {
              *(void *)(v540 + 8 * v288) = v284;
              uint64_t v287 = *v280;
            }
          }
          uint64_t *v284 = v287;
          --*((void *)&v541 + 1);
          operator delete(v280);
        }
        float32x4_t v289 = (_DWORD *)v512;
        uint64_t v290 = v485;
        *(void *)(v485 + 8) = v512;
        os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
        ++*v289;
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
        uint64_t v484 = 0;
        *(void *)(v290 + 24) = v274;
        *(void *)(v290 + 32) = v278;
        LODWORD(v470) = 1;
        *(_DWORD *)(v290 + 40) = v479;
        char v256 = v277;
      }
      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_deferred_lock);
        uint64_t v273 = v471;
        if (!v471)
        {
          MEMORY[0x1F4188790](v272);
          uint64_t v273 = &v461 - 4096;
          bzero(&v461 - 4096, 0x8000uLL);
        }
        uint64_t *v273 = 0;
        v273[1] = (uint64_t)(v273 + 4);
        *((_OWORD *)v273 + 1) = v467;
        uint64_t v274 = x_heap_malloc_small_(v273, 0x78uLL);
        CA::Render::Encoder::Encoder(v274, (uint64_t)v273, 0, (int)v483, *((double *)&v512 + 1));
        uint64_t v484 = (void ***)v273;
        *(void *)&long long v485 = 0;
        float64x2_t v471 = v273;
      }
      *((void *)&v513 + 1) = v274;
      uint64_t v291 = (os_unfair_lock_s *)(v512 + 164);
      os_unfair_lock_lock((os_unfair_lock_t)(v512 + 164));
      float v292 = *(atomic_uint **)(v512 + 168);
      if (!v292)
      {
        uint64_t v293 = (malloc_zone_t *)get_malloc_zone();
        float v294 = (atomic_uint *)malloc_type_zone_malloc(v293, 0x28uLL, 0x8BB15036uLL);
        float v292 = v294;
        if (v294)
        {
          *float v294 = 0;
          *((void *)v294 + 1) = x_hash_table_new_(0, 0, 0, 0, 0, 0);
          *((void *)v292 + 2) = 0;
          *((void *)v292 + 3) = 0;
          *((void *)v292 + 4) = 0;
          *float v292 = 1;
          os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Encoder::ObjectCache::_lock);
          uint64_t v295 = CA::Render::Encoder::ObjectCache::_cache_list;
          int v296 = (malloc_zone_t *)get_malloc_zone();
          uint64_t v297 = malloc_type_zone_malloc(v296, 0x10uLL, 0x8BB15036uLL);
          *uint64_t v297 = v292;
          v297[1] = v295;
          CA::Render::Encoder::ObjectCache::_cache_list = (uint64_t)v297;
          os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Encoder::ObjectCache::_lock);
        }
        *(void *)(v512 + 168) = v292;
      }
      os_unfair_lock_unlock(v291);
      CA::Render::Encoder::set_object_cache(*((CA::Render::Encoder **)&v513 + 1), v292, 1);
      uint64_t v262 = v512;
    }
    char v298 = *(unsigned char *)(v262 + 241);
    if ((v298 & 0x20) != 0)
    {
      uint64_t v299 = *(CA::Render::Context **)(v262 + 104);
      if (v299)
      {
        CA::Render::Context::set_colorspace(v299, *(CGColorSpace **)(v262 + 112));
        uint64_t v262 = v512;
      }
      uint64_t v300 = (CA::Render::Encoder *)*((void *)&v513 + 1);
      if (*((void *)&v513 + 1))
      {
        uint64_t v301 = *(CGColorSpace **)(v262 + 112);
        uint64_t v302 = *(unsigned char **)(*((void *)&v513 + 1) + 32);
        if ((unint64_t)(v302 + 1) > *(void *)(*((void *)&v513 + 1) + 40))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)&v513 + 1), 1);
          uint64_t v302 = (unsigned char *)*((void *)v300 + 4);
        }
        *((void *)v300 + 4) = v302 + 1;
        *uint64_t v302 = 9;
        CA::Render::Encoder::encode_colorspace(v300, v301);
        uint64_t v262 = v512;
      }
      char v298 = *(unsigned char *)(v262 + 241) & 0xDF;
      *(unsigned char *)(v262 + 241) = v298;
    }
    if ((v298 & 0x40) != 0)
    {
      CFStringRef v303 = *(const __CFString **)(v262 + 232);
      if (v303 && CFStringGetLength(*(CFStringRef *)(v262 + 232)) >= 256)
      {
        v578.locatiounint64_t n = 0;
        v578.length = 255;
        CFStringRef v303 = CFStringCreateWithSubstring(v468, v303, v578);
        int v304 = 1;
      }
      else
      {
        int v304 = 0;
      }
      int64_t v305 = *(CA::Render::Context **)(v512 + 104);
      if (v305) {
        CA::Render::Context::set_client_annotation(v305, v303);
      }
      unint64_t v306 = (CA::Render::Encoder *)*((void *)&v513 + 1);
      if (*((void *)&v513 + 1))
      {
        uint64_t v307 = *(unsigned char **)(*((void *)&v513 + 1) + 32);
        if ((unint64_t)(v307 + 1) > *(void *)(*((void *)&v513 + 1) + 40))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)&v513 + 1), 1);
          uint64_t v307 = (unsigned char *)*((void *)v306 + 4);
        }
        *((void *)v306 + 4) = v307 + 1;
        *uint64_t v307 = 10;
        CA::Render::Encoder::encode_cfobject(v306, v303);
      }
      if (v304) {
        CFRelease(v303);
      }
      uint64_t v262 = v512;
      *(unsigned char *)(v512 + 241) &= ~0x40u;
    }
    if (*((void *)&v513 + 1)) {
      *(void *)(*((void *)&v513 + 1) + 80) = *(void *)(v262 + 112);
    }
    int v308 = v550;
    for (mm = (uint64_t *)*((void *)v487 + 3); mm; mm = (uint64_t *)*mm)
    {
      int v310 = *((_DWORD *)mm + 5);
      if (v310) {
        BOOL v311 = v310 == v308;
      }
      else {
        BOOL v311 = 1;
      }
      if (v311) {
        CA::Context::commit_deleted((CA::Context *)mm[1], *((_DWORD *)mm + 4), (uint64_t)&v511, v258);
      }
    }
    for (nunint64_t n = (uint64_t *)*((void *)v487 + 2); nn; nunint64_t n = (uint64_t *)*nn)
    {
      int v313 = *((_DWORD *)nn + 8);
      if (v313) {
        BOOL v314 = v313 == v308;
      }
      else {
        BOOL v314 = 1;
      }
      if (v314) {
        CA::Context::commit_command((CA::Context *)*((unsigned int *)nn + 2), (CA::Render::Object *)nn[2], (__CFString *)nn[3], &v511, v259);
      }
    }
    uint64_t v315 = *(void *)(v512 + 96);
    if (v315) {
      uint64_t v316 = *(void *)(v315 + 16);
    }
    else {
      uint64_t v316 = 0;
    }
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &buf;
    *(void *)&long long v569 = 0x2020000000;
    DWORD2(v569) = 0;
    v505[0] = MEMORY[0x1E4F143A8];
    v505[1] = 3221225472;
    v506[0] = ___ZN2CA7Context18commit_transactionEPNS_11TransactionEdPd_block_invoke;
    v506[1] = &unk_1E5273DD8;
    v506[3] = &v511;
    v506[2] = &buf;
    if (v316) {
      CA::Layer::commit_if_needed(v316, v487, (uint64_t)v505);
    }
    v502[0] = MEMORY[0x1E4F143A8];
    v502[1] = 3221225472;
    v503[0] = ___ZN2CA7Context18commit_transactionEPNS_11TransactionEdPd_block_invoke_2;
    v503[1] = &unk_1E5273E00;
    int v504 = v308;
    v503[2] = v505;
    v503[3] = v487;
    uint64_t v317 = (CA::Layer *)*((void *)v487 + 6);
    if (!v317)
    {
LABEL_615:
      if (!v316) {
        goto LABEL_617;
      }
      goto LABEL_616;
    }
    uint64_t v318 = 0;
    *((void *)v487 + 6) = 0;
    uint64_t v319 = 1 << *(_DWORD *)v317;
    do
    {
      for (i1 = *(void **)(*((void *)v317 + 2) + 8 * v318); i1; i1 = (void *)*i1)
        CA::foreach_callback(i1[2], i1[3], (uint64_t)v502);
      ++v318;
    }
    while (v318 != v319);
    uint64_t v321 = *((void *)v487 + 6);
    if (v321)
    {
      long long v479 = (void *)v250;
      uint64_t v322 = v257;
      uint64_t v323 = v249;
      char v324 = v256;
      uint64_t v325 = 0;
      uint64_t v326 = 1 << *(_DWORD *)v321;
      do
      {
        for (i2 = *(uint64_t ***)(*(void *)(v321 + 16) + 8 * v325); i2; i2 = (uint64_t **)*i2)
          CA::move_root((CA *)i2[2], (CA::Layer *)i2[3], v317, v258);
        ++v325;
      }
      while (v325 != v326);
      int v328 = (void *)*((void *)v487 + 6);
      *((void *)v487 + 6) = v317;
      char v256 = v324;
      uint64_t v249 = v323;
      uint64_t v257 = v322;
      unint64_t v250 = (unint64_t)v479;
      if (v328) {
        x_hash_table_free(v328);
      }
      goto LABEL_615;
    }
    *((void *)v487 + 6) = v317;
    if (v316)
    {
LABEL_616:
      v260.i64[0] = *((void *)&v512 + 1);
      *(void *)&v564[0].mach_msg_bits_t msgh_bits = v487;
      *(void *)&v564[0].uint64_t msgh_remote_port = 1065353216;
      CA::Layer::collect_animations_(v316, v477, (uint64_t)v564, v260, v261);
    }
LABEL_617:
    uint64_t v329 = *((void *)v487 + 13);
    int v330 = *(_DWORD *)(v329 + 200);
    if ((void)v514) {
      *(_DWORD *)(v514 + 288) = v330;
    }
    int v331 = (CA::Render::Encoder *)*((void *)&v513 + 1);
    if (*((void *)&v513 + 1))
    {
      char v332 = *(unsigned char *)(v329 + 204);
      uint64_t v333 = *(unsigned char **)(*((void *)&v513 + 1) + 32);
      if ((unint64_t)(v333 + 1) > *(void *)(*((void *)&v513 + 1) + 40))
      {
        CA::Render::Encoder::grow(*((CA::Render::Encoder **)&v513 + 1), 1);
        uint64_t v333 = (unsigned char *)*((void *)v331 + 4);
      }
      *((void *)v331 + 4) = v333 + 1;
      *uint64_t v333 = 32;
      uint64_t v334 = (_DWORD *)*((void *)v331 + 4);
      if ((unint64_t)(v334 + 1) > *((void *)v331 + 5))
      {
        CA::Render::Encoder::grow(v331, 4);
        uint64_t v334 = (_DWORD *)*((void *)v331 + 4);
      }
      *uint64_t v334 = v330;
      uint64_t v335 = *((void *)v331 + 4);
      unint64_t v336 = *((void *)v331 + 5);
      int v337 = (BOOL *)(v335 + 4);
      *((void *)v331 + 4) = v335 + 4;
      if (v335 + 5 > v336)
      {
        CA::Render::Encoder::grow(v331, 1);
        int v337 = (BOOL *)*((void *)v331 + 4);
      }
      *((void *)v331 + 4) = v337 + 1;
      BOOL *v337 = (v332 & 4) != 0;
      uint64_t v329 = *((void *)v487 + 13);
    }
    double v338 = *(double *)(v329 + 176);
    if (v338 != 0.0)
    {
      if ((void)v514 && (*(_WORD *)(v514 + 552) & 0x40) == 0) {
        CA::Render::Context::add_begin_time((os_unfair_lock_s *)v514, v338);
      }
      double v339 = (CA::Render::Encoder *)*((void *)&v513 + 1);
      if (*((void *)&v513 + 1))
      {
        float v340 = *(unsigned char **)(*((void *)&v513 + 1) + 32);
        if ((unint64_t)(v340 + 1) > *(void *)(*((void *)&v513 + 1) + 40))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)&v513 + 1), 1);
          float v340 = (unsigned char *)*((void *)v339 + 4);
        }
        *((void *)v339 + 4) = v340 + 1;
        *float v340 = 29;
        unint64_t v341 = (double *)*((void *)v339 + 4);
        if ((unint64_t)(v341 + 1) > *((void *)v339 + 5))
        {
          CA::Render::Encoder::grow(v339, 8);
          unint64_t v341 = (double *)*((void *)v339 + 4);
        }
        double *v341 = v338;
        *((void *)v339 + 4) += 8;
      }
    }
    LOBYTE(v527) = 0;
    CA::Transaction::get_value(*((void *)v487 + 11), 211, (const CGAffineTransform *)7, (CA::Mat4Impl *)&v527);
    if (*((void *)&v513 + 1)
      && *(void *)(*((void *)&v513 + 1) + 32) - *(void *)(*((void *)&v513 + 1) + 24) != *(void *)(*((void *)&v513 + 1) + 96)
      || (_BYTE)v527)
    {
      LOBYTE(v555) = 0;
      CA::Transaction::get_value(*((void *)v487 + 11), 366, (const CGAffineTransform *)7, (CA::Mat4Impl *)&v555);
      if ((_BYTE)v527)
      {
        LOBYTE(v555) = 1;
        if (!pthread_main_np() || (void)v485) {
          goto LABEL_657;
        }
LABEL_645:
        if ((x_cpu_has_64bit::initialized & 1) == 0)
        {
          *(void *)&v564[0].mach_msg_bits_t msgh_bits = 4;
          sysctlbyname("hw.cpu64bit_capable", &x_cpu_has_64bit::has_64_bit, (size_t *)&v564[0].msgh_bits, 0, 0);
          x_cpu_has_64bit::initialized = 1;
        }
        if (x_cpu_has_64bit::has_64_bit)
        {
          if ((_BYTE)v555)
          {
            int32x2_t v342 = (CA::Render::Encoder *)*((void *)&v513 + 1);
            char v343 = v527;
            uint64_t v344 = *(unsigned char **)(*((void *)&v513 + 1) + 32);
            if ((unint64_t)(v344 + 1) > *(void *)(*((void *)&v513 + 1) + 40))
            {
              CA::Render::Encoder::grow(*((CA::Render::Encoder **)&v513 + 1), 1);
              uint64_t v344 = (unsigned char *)*((void *)v342 + 4);
            }
            *((void *)v342 + 4) = v344 + 1;
            unsigned char *v344 = 31;
            int32x4_t v345 = (unsigned char *)*((void *)v342 + 4);
            if ((unint64_t)(v345 + 1) > *((void *)v342 + 5))
            {
              CA::Render::Encoder::grow(v342, 1);
              int32x4_t v345 = (unsigned char *)*((void *)v342 + 4);
            }
            *((void *)v342 + 4) = v345 + 1;
            unsigned char *v345 = v343;
            if (BYTE9(xmmword_1EB2ACC10)) {
              kdebug_trace();
            }
          }
        }
        else
        {
LABEL_657:
          LOBYTE(v555) = 0;
        }
      }
      else if ((_BYTE)v555)
      {
        goto LABEL_645;
      }
      LOBYTE(v530) = 0;
      if (CA::Transaction::get_value(*((void *)v487 + 11), 249, (const CGAffineTransform *)6, (CA::Mat4Impl *)&v530))
      {
        if ((void)v514) {
          CA::Render::Context::set_frame_stall_skip_request((CA::Render::Context *)v514, v530);
        }
        if ((_BYTE)v530)
        {
          BOOL v346 = (CA::Render::Encoder *)*((void *)&v513 + 1);
          BOOL v347 = *(unsigned char **)(*((void *)&v513 + 1) + 32);
          if ((unint64_t)(v347 + 1) > *(void *)(*((void *)&v513 + 1) + 40))
          {
            CA::Render::Encoder::grow(*((CA::Render::Encoder **)&v513 + 1), 1);
            BOOL v347 = (unsigned char *)*((void *)v346 + 4);
          }
          *((void *)v346 + 4) = v347 + 1;
          *BOOL v347 = 27;
          unint64_t v348 = (unsigned char *)*((void *)v346 + 4);
          if ((unint64_t)(v348 + 1) > *((void *)v346 + 5))
          {
            CA::Render::Encoder::grow(v346, 1);
            unint64_t v348 = (unsigned char *)*((void *)v346 + 4);
          }
          *((void *)v346 + 4) = v348 + 1;
          *unint64_t v348 = 1;
        }
      }
      *(void *)&v564[0].mach_msg_bits_t msgh_bits = 0;
      if (CA::Transaction::_update_cycle_support_enabled == 1
        && CA::Transaction::get_value(*((void *)v487 + 11), 579, (const CGAffineTransform *)0x12, (CA::Mat4Impl *)v564))
      {
        unint64_t v349 = (CA::Render::Encoder *)*((void *)&v513 + 1);
        uint64_t v350 = *(void *)&v564[0].msgh_bits;
        CFDictionaryRef v351 = *(unsigned char **)(*((void *)&v513 + 1) + 32);
        if ((unint64_t)(v351 + 1) > *(void *)(*((void *)&v513 + 1) + 40))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)&v513 + 1), 1);
          CFDictionaryRef v351 = (unsigned char *)*((void *)v349 + 4);
        }
        *((void *)v349 + 4) = v351 + 1;
        unsigned char *v351 = 34;
        CFDictionaryRef v352 = (void *)*((void *)v349 + 4);
        if ((unint64_t)(v352 + 1) > *((void *)v349 + 5))
        {
          CA::Render::Encoder::grow(v349, 8);
          CFDictionaryRef v352 = (void *)*((void *)v349 + 4);
        }
        void *v352 = v350;
        *((void *)v349 + 4) += 8;
      }
    }
    uint64_t v353 = *((void *)v487 + 13);
    double v354 = *(double *)(v353 + 192);
    if (v354 != 0.0)
    {
      if ((void)v514) {
        CA::Render::Context::add_input_time((CA::Render::Context *)v514, *(double *)(v353 + 192));
      }
      unint64_t v355 = (CA::Render::Encoder *)*((void *)&v513 + 1);
      if (*((void *)&v513 + 1))
      {
        unint64_t v356 = *(unsigned char **)(*((void *)&v513 + 1) + 32);
        if (&v356[-*(void *)(*((void *)&v513 + 1) + 24)] != *(unsigned char **)(*((void *)&v513 + 1) + 96)
          || byte_1EB2ACC29)
        {
          if ((unint64_t)(v356 + 1) > *(void *)(*((void *)&v513 + 1) + 40))
          {
            CA::Render::Encoder::grow(*((CA::Render::Encoder **)&v513 + 1), 1);
            unint64_t v356 = (unsigned char *)*((void *)v355 + 4);
          }
          *((void *)v355 + 4) = v356 + 1;
          *unint64_t v356 = 26;
          uint64_t v357 = (double *)*((void *)v355 + 4);
          if ((unint64_t)(v357 + 1) > *((void *)v355 + 5))
          {
            CA::Render::Encoder::grow(v355, 8);
            uint64_t v357 = (double *)*((void *)v355 + 4);
          }
          *uint64_t v357 = v354;
          *((void *)v355 + 4) += 8;
        }
      }
    }
    *(void *)&long long v555 = 0;
    if (CA::Transaction::get_value(*((void *)v487 + 11), 465, (const CGAffineTransform *)0x10, (CA::Mat4Impl *)&v555))
    {
      if ((void)v514) {
        CA::Render::Context::add_remote_input_mach_time((CA::Render::Context *)v514, v555);
      }
      unint64_t v358 = (CA::Render::Encoder *)*((void *)&v513 + 1);
      if (*((void *)&v513 + 1))
      {
        long long v359 = *(unsigned char **)(*((void *)&v513 + 1) + 32);
        if (&v359[-*(void *)(*((void *)&v513 + 1) + 24)] != *(unsigned char **)(*((void *)&v513 + 1) + 96)
          || byte_1EB2ACC29)
        {
          uint64_t v360 = v555;
          if ((unint64_t)(v359 + 1) > *(void *)(*((void *)&v513 + 1) + 40))
          {
            CA::Render::Encoder::grow(*((CA::Render::Encoder **)&v513 + 1), 1);
            long long v359 = (unsigned char *)*((void *)v358 + 4);
          }
          *((void *)v358 + 4) = v359 + 1;
          *long long v359 = 28;
          unint64_t v361 = (void *)*((void *)v358 + 4);
          if ((unint64_t)(v361 + 1) > *((void *)v358 + 5))
          {
            CA::Render::Encoder::grow(v358, 8);
            unint64_t v361 = (void *)*((void *)v358 + 4);
          }
          *unint64_t v361 = v360;
          *((void *)v358 + 4) += 8;
        }
      }
    }
    CA::Transaction::unlock((CA::Transaction *)v487);
    int v362 = (_DWORD *)v512;
    uint64_t v363 = *((void *)&v513 + 1);
    char v364 = *(unsigned char *)(v512 + 241);
    int v365 = v364 & 0x18;
    if (v365 == 8 && *((void *)&v513 + 1))
    {
      *(unsigned char *)(v512 + 241) = v364 | 0x10;
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
      ++*v362;
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
      LODWORD(v530) = 0;
      uint64_t v366 = mach_port_allocate(*MEMORY[0x1E4F14960], 1u, (mach_port_name_t *)&v530);
      CA_CLIENT_MACH_PORT_ALLOCATE_FAILED(v366, v530);
      if (!CA::Render::encode_sync_request(*((CA::Render **)&v513 + 1), (CA::Render::Encoder *)v530)) {
        __assert_rtn("commit_transaction", "CAContextInternal.mm", 3631, "scheduled");
      }
      *(void *)&v564[0].mach_msg_bits_t msgh_bits = 0;
      *(void *)&v564[0].uint64_t msgh_remote_port = v564;
      *(void *)&v564[0].uint64_t msgh_voucher_port = 0x3052000000;
      *(void *)&v564[1].mach_msg_bits_t msgh_bits = __Block_byref_object_copy_;
      *(void *)&v564[1].uint64_t msgh_remote_port = __Block_byref_object_dispose_;
      *(void *)&v564[1].uint64_t msgh_voucher_port = 0;
      uint64_t v498 = MEMORY[0x1E4F143A8];
      uint64_t v499 = 3221225472;
      v500[0] = ___ZN2CA7Context18commit_transactionEPNS_11TransactionEdPd_block_invoke_49;
      v500[1] = &unk_1E5273E28;
      v500[2] = v564;
      v500[3] = v362;
      int v501 = v530;
      *(void *)&v564[1].uint64_t msgh_voucher_port = dispatch_mach_create();
      dispatch_mach_connect();
      _Block_object_dispose(v564, 8);
      uint64_t v363 = *((void *)&v513 + 1);
    }
    if (v363)
    {
      uint64_t v367 = *(void *)(*((void *)v487 + 13) + 104);
      if (!((unint64_t)v485 | v367) && *(void *)(v363 + 32) - *(void *)(v363 + 24) == *(void *)(v363 + 96)) {
        goto LABEL_709;
      }
      ++*(_DWORD *)(v512 + 128);
      unsigned int v368 = (CA::Render::Encoder *)HIDWORD(v508);
      if (v367 && !HIDWORD(v508))
      {
        uint64_t v369 = mach_port_allocate(*MEMORY[0x1E4F14960], 1u, (mach_port_name_t *)&v508 + 1);
        CA_CLIENT_MACH_PORT_ALLOCATE_FAILED(v369, SHIDWORD(v508));
        unsigned int v368 = (CA::Render::Encoder *)HIDWORD(v508);
        uint64_t v363 = *((void *)&v513 + 1);
      }
      if (v368)
      {
        BOOL v370 = CA::Render::encode_sync_request((CA::Render *)v363, v368);
        LODWORD(v478) = v478 + v370;
        uint64_t v363 = *((void *)&v513 + 1);
      }
      if ((void)v485)
      {
LABEL_709:
        mach_port_t v371 = 0;
        LODWORD(v372) = 0;
      }
      else
      {
        if (*(unsigned char *)(v363 + 104))
        {
          mach_port_t v371 = v508;
          if ((v508 - 1) >= 0xFFFFFFFE)
          {
            uint64_t v373 = mach_port_allocate(*MEMORY[0x1E4F14960], 1u, (mach_port_name_t *)&v508);
            mach_port_t v371 = v508;
            if ((v508 - 1) >= 0xFFFFFFFE)
            {
              uint64_t v374 = v373;
              if (x_log_hook_p())
              {
                double v375 = mach_error_string(v374);
                uint64_t v458 = v374;
                uint64_t v459 = v375;
                uint64_t v457 = (uint64_t)v483;
                x_log_();
              }
              else
              {
                double v376 = x_log_category_api;
                if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
                {
                  int v377 = mach_error_string(v374);
                  v564[0].mach_msg_bits_t msgh_bits = v463;
                  v564[0].msgh_mach_vm_size_t size = v483;
                  LOWORD(v564[0].msgh_remote_port) = 1024;
                  *(mach_port_t *)((char *)&v564[0].msgh_remote_port + 2) = v374;
                  HIWORD(v564[0].msgh_local_port) = 2080;
                  *(void *)&v564[0].uint64_t msgh_voucher_port = v377;
                  _os_log_impl(&dword_184668000, v376, OS_LOG_TYPE_ERROR, "Failed to make reply port for sync coder (client=0x%x) [0x%x %s]", (uint8_t *)v564, 0x18u);
                }
              }
              mach_port_t v371 = v508;
            }
          }
          uint64_t v363 = *((void *)&v513 + 1);
        }
        else
        {
          mach_port_t v371 = 0;
        }
        uint64_t v378 = *(unsigned char **)(v363 + 32);
        if ((unint64_t)(v378 + 1) > *(void *)(v363 + 40))
        {
          CA::Render::Encoder::grow((CA::Render::Encoder *)v363, 1);
          uint64_t v378 = *(unsigned char **)(v363 + 32);
        }
        *(void *)(v363 + 32) = v378 + 1;
        *uint64_t v378 = 30;
        long long v379 = *(double **)(v363 + 32);
        if ((unint64_t)(v379 + 1) > *(void *)(v363 + 40))
        {
          CA::Render::Encoder::grow((CA::Render::Encoder *)v363, 8);
          long long v379 = *(double **)(v363 + 32);
        }
        *long long v379 = v252;
        *(void *)(v363 + 32) += 8;
        LODWORD(v530) = 0;
        long long v380 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v536, v550);
        if (v380)
        {
          int v381 = *((_DWORD *)v380 + 5);
          LODWORD(v530) = v381;
        }
        else
        {
          int v381 = 0;
        }
        uint64_t v382 = CA::Render::Encoder::send_message(*((CA::Render::Encoder **)&v513 + 1), *(_DWORD *)(v512 + 160), v371, (unsigned int *)&v530, (v381 - 1) < 0xFFFFFFFE);
        uint64_t v372 = v382;
        if (v382)
        {
          if (v382 == 268435459)
          {
            *(unsigned char *)(v512 + 241) |= 2u;
          }
          else if (v382 == -81182719)
          {
            goto LABEL_865;
          }
          if (x_log_hook_p())
          {
            uint64_t v383 = *(unsigned int *)(v512 + 4);
            BOOL v384 = mach_error_string(v372);
            uint64_t v458 = v372;
            uint64_t v459 = v384;
            uint64_t v457 = v383;
            x_log_();
          }
          else
          {
            int32x4_t v385 = x_log_category_api;
            if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
            {
              mach_msg_size_t v386 = *(_DWORD *)(v512 + 4);
              int v387 = mach_error_string(v372);
              v564[0].mach_msg_bits_t msgh_bits = v463;
              v564[0].msgh_mach_vm_size_t size = v386;
              LOWORD(v564[0].msgh_remote_port) = 1024;
              *(mach_port_t *)((char *)&v564[0].msgh_remote_port + 2) = v372;
              HIWORD(v564[0].msgh_local_port) = 2080;
              *(void *)&v564[0].uint64_t msgh_voucher_port = v387;
              _os_log_impl(&dword_184668000, v385, OS_LOG_TYPE_ERROR, "Failed to commit transaction (client=0x%x) [0x%x %s]", (uint8_t *)v564, 0x18u);
            }
          }
        }
        uint64_t v363 = *((void *)&v513 + 1);
      }
      *(void *)(v363 + 80) = 0;
    }
    else
    {
      mach_port_t v371 = 0;
      LODWORD(v372) = 0;
    }
    *((void *)v487 + 5) = 0;
    int64x2_t v388 = (os_unfair_lock_s *)v514;
    *(void *)(v512 + 208) = 0;
    if (v388)
    {
      int v389 = CA::Render::Context::increment_commit_seed(v388);
      unint64_t v390 = v514;
      *(_DWORD *)(v512 + 128) = v389;
      CA::Render::Context::did_commit(v390, v515, 0, 1, 0, 0);
      CA::Render::Context::run_scheduled_handle_updates((CA::Render::Context *)v514);
      uint64_t v363 = *((void *)&v513 + 1);
    }
    if (v365 == 8 && !v363)
    {
      __int16 v391 = (CA::Context *)v512;
      *(unsigned char *)(v512 + 241) |= 0x10u;
      CA::Context::destroy(v391);
    }
    _Block_object_dispose(&buf, 8);
    pthread_mutex_unlock(v257);
    if ((v256 & 0x20) == 0) {
      kdebug_trace();
    }
    uint64_t v392 = v485;
    if ((void)v485)
    {
      *((void *)&v513 + 1) = 0;
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_deferred_lock);
      *(unsigned char *)(v392 + 44) = 1;
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_deferred_lock);
      goto LABEL_774;
    }
    if (!*((void *)&v533 + 1)) {
      goto LABEL_764;
    }
    uint8x8_t v393 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v533 + 8));
    v393.i16[0] = vaddlv_u8(v393);
    if (v393.u32[0] > 1uLL)
    {
      unint64_t v394 = v550;
      if (*((void *)&v533 + 1) <= (unint64_t)v550) {
        unint64_t v394 = (unint64_t)v550 % *((void *)&v533 + 1);
      }
    }
    else
    {
      unint64_t v394 = (DWORD2(v533) - 1) & v550;
    }
    __int16 v395 = *(uint64_t ***)(v533 + 8 * v394);
    if (!v395 || (unsigned int v396 = *v395) == 0)
    {
LABEL_764:
      if (std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::find<unsigned int>(v543[0], v543[1], v550))
      {
        goto LABEL_765;
      }
      goto LABEL_766;
    }
    while (2)
    {
      unint64_t v397 = v396[1];
      if (v397 != v550)
      {
        if (v393.u32[0] > 1uLL)
        {
          if (v397 >= *((void *)&v533 + 1)) {
            v397 %= *((void *)&v533 + 1);
          }
        }
        else
        {
          v397 &= *((void *)&v533 + 1) - 1;
        }
        if (v397 != v394) {
          goto LABEL_764;
        }
        goto LABEL_763;
      }
      if (*((_DWORD *)v396 + 4) != v550)
      {
LABEL_763:
        unsigned int v396 = (uint64_t *)*v396;
        if (!v396) {
          goto LABEL_764;
        }
        continue;
      }
      break;
    }
    if (!v396[3]) {
      goto LABEL_764;
    }
LABEL_765:
    kdebug_trace();
LABEL_766:
    if (*((void *)&v513 + 1))
    {
      if (v371 - 1 < 0xFFFFFFFE && v372 == 0) {
        uint64_t v249 = (v249 + 1);
      }
      else {
        uint64_t v249 = v249;
      }
      (***((void (****)(void))&v513 + 1))();
    }
LABEL_774:
    if (v484) {
      x_heap_free(v484);
    }
    CA::Context::unref((CA::Context *)v512, 1);
    if (++v250 < v509) {
      continue;
    }
    break;
  }
LABEL_781:
  __int16 v399 = v476;
  if (v476)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v476->_lock);
    v399->_invalidated = 1;
    os_unfair_lock_unlock((os_unfair_lock_t)&v399->_lock);
  }
  for (i3 = (uint64_t *)v538; i3; i3 = (uint64_t *)*i3)
    mach_port_deallocate(*MEMORY[0x1E4F14960], *((_DWORD *)i3 + 4));
  if (v249)
  {
    *(void *)&long long v247 = 67109378;
    long long v485 = v247;
    do
    {
      memset(v564, 0, 92);
      __int16 v401 = (char *)mach_msg(v564, 2, 0, 0x5Cu, v508, 0, 0);
      if (v401)
      {
        int v402 = v401;
        if (x_log_hook_p())
        {
          __int16 v403 = mach_error_string((mach_error_t)v402);
          uint64_t v459 = v402;
          int32x4_t v460 = v403;
          x_log_();
        }
        else
        {
          BOOL v404 = x_log_category_api;
          if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
          {
            __int16 v405 = mach_error_string((mach_error_t)v402);
            v564[0].mach_msg_bits_t msgh_bits = v485;
            v564[0].msgh_mach_vm_size_t size = v402;
            LOWORD(v564[0].msgh_remote_port) = 2080;
            *(void *)((char *)&v564[0].msgh_remote_port + 2) = v405;
            _os_log_impl(&dword_184668000, v404, OS_LOG_TYPE_ERROR, "Failed to receive sync coder reply [0x%x %s]", (uint8_t *)v564, 0x12u);
          }
        }
      }
      LODWORD(v249) = v249 - 1;
    }
    while (v249);
  }
  if ((v508 - 1) <= 0xFFFFFFFD) {
    mach_port_mod_refs(*MEMORY[0x1E4F14960], v508, 1u, -1);
  }
  CFArrayRef v406 = (uint64_t *)v548;
  if ((void)v548)
  {
    uint64_t v484 = (void ***)&v557;
    *(void *)&long long v485 = (char *)&v556 + 8;
    int8x16_t v477 = (double *)&v524;
    p_uint64_t msgh_voucher_port = &v564[0].msgh_voucher_port;
    long long v483 = (uint64_t **)v558;
    long long v481 = &v569;
    long long v479 = v559;
    long long v480 = &v551;
    do
    {
      LODWORD(v516) = *((_DWORD *)v406 + 4);
      uint64_t v407 = v406[3];
      uint64_t v408 = std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)&v544, v516, &v516);
      if (*((void *)v408 + 6))
      {
        std::__hash_table<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>>>::__hash_table((uint64_t)&v522, (uint64_t *)v408 + 3);
        if (!v525) {
          __assert_rtn("activate", "render-fence.cpp", 306, "!in_pending.empty ()");
        }
        os_unfair_lock_lock((os_unfair_lock_t)v407);
        if (!*(unsigned char *)(v407 + 28)) {
          __assert_rtn("activate", "render-fence.cpp", 310, "_has_receive_right");
        }
        *(void *)&long long v530 = 0;
        *((void *)&v530 + 1) = &v530;
        *(void *)&long long v531 = 0x2000000000;
        BYTE8(v531) = 0;
        *(void *)&long long v555 = 0;
        *((void *)&v555 + 1) = &v555;
        *(void *)&long long v556 = 0x5002000000;
        *((void *)&v556 + 1) = __Block_byref_object_copy__20341;
        uint64_t v409 = v522;
        unint64_t v410 = v523;
        unint64_t v523 = 0;
        uint64_t v522 = 0;
        uint64_t v557 = (uint64_t)__Block_byref_object_dispose__20342;
        v558[0] = v409;
        v558[1] = v410;
        v559[0] = v524;
        int v561 = 0;
        v559[1] = v525;
        int v560 = v526;
        if (v525)
        {
          unint64_t v411 = *(void *)(v524 + 8);
          if ((v410 & (v410 - 1)) != 0)
          {
            if (v411 >= v410) {
              v411 %= v410;
            }
          }
          else
          {
            v411 &= v410 - 1;
          }
          *(void *)(v409 + 8 * v411) = v479;
          int v412 = v477;
          *int8x16_t v477 = 0.0;
          v412[1] = 0.0;
        }
        int v413 = *(_DWORD *)(v407 + 24);
        if (CA::Render::Fence::_observer_callback_queue(void)::onceToken[0] != -1) {
          dispatch_once(CA::Render::Fence::_observer_callback_queue(void)::onceToken, &__block_literal_global_20343);
        }
        int64x2_t v414 = CA::Render::Fence::_observer_callback_queue(void)::q;
        *(void *)&long long v527 = 0;
        *((void *)&v527 + 1) = &v527;
        long long v528 = 0x2000000000uLL;
        double v518 = 0.0;
        v519 = &v518;
        uint64_t v520 = 0x2000000000;
        uint64_t v521 = 0;
        *(void *)&v564[0].mach_msg_bits_t msgh_bits = MEMORY[0x1E4F143A8];
        *(void *)&v564[0].uint64_t msgh_remote_port = 0x40000000;
        *(void *)&v564[0].uint64_t msgh_voucher_port = ___ZN2CA6Render5Fence11Transaction8Observer8activateENSt3__113unordered_setIyNS4_4hashIyEENS4_8equal_toIyEENS4_9allocatorIyEEEEPFvPS3_RKSC_djyEPFvSD_SF_jjEPFvSD_SF_E_block_invoke;
        *(void *)&v564[1].mach_msg_bits_t msgh_bits = &unk_1E5280068;
        *(void *)&v564[2].uint64_t msgh_voucher_port = v407;
        *(void *)&v564[1].uint64_t msgh_remote_port = &v530;
        *(void *)&v564[1].uint64_t msgh_voucher_port = &v555;
        *(void *)&v564[3].mach_msg_bits_t msgh_bits = CA::fo_fences_released;
        *(void *)&v564[3].uint64_t msgh_remote_port = CA::fo_completed;
        *(void *)&v564[2].mach_msg_bits_t msgh_bits = &v527;
        *(void *)&v564[2].uint64_t msgh_remote_port = &v518;
        *(void *)&v564[3].uint64_t msgh_voucher_port = CA::fo_removed_context;
        LODWORD(v565) = v413;
        *(void *)(v407 + 8) = dispatch_mach_create();
        BOOL v415 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, v414);
        *(void *)(v407 + 16) = v415;
        *(void *)&long long buf = MEMORY[0x1E4F143A8];
        *((void *)&buf + 1) = 0x40000000;
        *(void *)&long long v569 = ___ZN2CA6Render5Fence11Transaction8Observer8activateENSt3__113unordered_setIyNS4_4hashIyEENS4_8equal_toIyEENS4_9allocatorIyEEEEPFvPS3_RKSC_djyEPFvSD_SF_jjEPFvSD_SF_E_block_invoke_7;
        *((void *)&v569 + 1) = &unk_1E5280090;
        int v576 = v413;
        uint64_t v570 = (uint64_t)&v527;
        v571 = &v530;
        uint64_t v574 = 0x3FE3333333333333;
        v575 = CA::fo_completed;
        v572 = &v555;
        uint64_t v573 = v407;
        dispatch_source_set_event_handler(v415, &buf);
        dispatch_time_t v416 = dispatch_time(0, 600000000);
        dispatch_source_set_timer(*(dispatch_source_t *)(v407 + 16), v416, 0xFFFFFFFFFFFFFFFFLL, 0);
        *(unsigned char *)(v407 + 28) = 0;
        *(void *)(*((void *)&v527 + 1) + 24) = *(void *)(v407 + 8);
        v519[3] = *(double *)(v407 + 16);
        os_unfair_lock_unlock((os_unfair_lock_t)v407);
        *(void *)&long long v550 = MEMORY[0x1E4F143A8];
        *((void *)&v550 + 1) = 0x40000000;
        *(void *)&long long v551 = ___ZN2CA6Render5Fence11Transaction8Observer8activateENSt3__113unordered_setIyNS4_4hashIyEENS4_8equal_toIyEENS4_9allocatorIyEEEEPFvPS3_RKSC_djyEPFvSD_SF_jjEPFvSD_SF_E_block_invoke_11;
        *((void *)&v551 + 1) = &unk_1E52800B8;
        int v554 = v413;
        uint64_t v552 = (uint64_t)&v527;
        v553 = &v518;
        dispatch_sync(v414, &v550);
        _Block_object_dispose(&v518, 8);
        _Block_object_dispose(&v527, 8);
        _Block_object_dispose(&v555, 8);
        std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v483);
        _Block_object_dispose(&v530, 8);
        std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v522);
      }
      else if (v407)
      {
        CA::Render::Fence::Transaction::Observer::~Observer((CA::Render::Fence::Transaction::Observer *)v407);
        MEMORY[0x185323DC0]();
      }
      CFArrayRef v406 = (uint64_t *)*v406;
    }
    while (v406);
  }
  size_t v13 = v464;
  if (v470)
  {
    memset(v564, 0, 32);
    v564[1].uint64_t msgh_remote_port = 1065353216;
    uint64_t v417 = mach_absolute_time();
    double v418 = CATimeWithHostTime(v417);
    CA::Context::send_deferrals(0, 0, (uint64_t)v564, 0, v418);
    std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v564);
  }
  long long v419 = (void *)v541;
  for (i4 = v487; v419; long long v419 = (void *)*v419)
  {
    float64x2_t v420 = (void *)v419[3];
    if (v420)
    {
      do
      {
        BOOL v421 = (const void *)*v420;
        (*(void (**)(void))(*v420 + 16))(*v420);
        _Block_release(v421);
        float64x2_t v420 = (void *)v420[1];
      }
      while (v420);
      double v422 = (void *)v419[3];
      if (v422)
      {
        do
        {
          float v423 = (void *)v422[1];
          free(v422);
          double v422 = v423;
        }
        while (v423);
      }
    }
  }
  float64x2_t v424 = v486;
  if (v486 != v562)
  {
    int v425 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v425, v424);
  }
LABEL_822:
  unsigned int v426 = i4[25];
  i4[25] = v426 + 1;
  if (!v426) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  float64x2_t v427 = (uint64_t *)*((void *)i4 + 10);
  if (v427)
  {
    do
    {
      uint64_t v428 = *v427;
      if (*v427)
      {
        [*(id *)(v428 + 16) layerDidBecomeVisible:(*(_DWORD *)(v428 + 52) >> 20) & 1];
        while (1)
        {
          atomic_uint v429 = *(_DWORD *)v428;
          if (!*(_DWORD *)v428) {
            break;
          }
          atomic_uint v430 = *(_DWORD *)v428;
          atomic_compare_exchange_strong((atomic_uint *volatile)v428, (unsigned int *)&v430, v429 - 1);
          if (v430 == v429)
          {
            if (v429 == 1)
            {
              CA::Layer::destroy((CA::Layer *)v428);
              CA::Layer::~Layer((CA::AttrList **)v428);
              uint64_t v431 = (malloc_zone_t *)get_malloc_zone();
              malloc_zone_free(v431, (void *)v428);
            }
            break;
          }
        }
      }
      float64x2_t v427 = (uint64_t *)v427[1];
    }
    while (v427);
    v432 = (void *)*((void *)i4 + 10);
    if (v432)
    {
      do
      {
        BOOL v433 = (void *)v432[1];
        free(v432);
        v432 = v433;
      }
      while (v433);
    }
    *((void *)i4 + 10) = 0;
  }
  CA::Transaction::unlock((CA::Transaction *)i4);
  if (!v13)
  {
    CA::Transaction::run_commit_handlers((uint64_t)i4, 3);
    CA::Transaction::run_commit_handlers((uint64_t)v487, 1);
    i4 = v487;
    uint64_t v434 = *((void *)v487 + 13);
    if (*(void *)(v434 + 16))
    {
      int32x4_t v435 = *(void **)(v434 + 16);
      if (v435)
      {
        int32x4_t v436 = 0;
        do
        {
          uint64_t v437 = v435;
          int32x4_t v435 = (void *)*v435;
          *uint64_t v437 = v436;
          int32x4_t v436 = v437;
        }
        while (v435);
      }
      else
      {
        uint64_t v437 = 0;
      }
      *((void *)i4 + 2) = v437;
      *(void *)(v434 + 16) = 0;
    }
  }
  CA::Transaction::run_commit_handlers((uint64_t)i4, 2);
  int v440 = v487;
  uint64_t v441 = *((void *)v487 + 13);
  uint64_t v442 = *(void *)(v441 + 104);
  if (v442)
  {
    *(void *)(v441 + 104) = 0;
    int v443 = *(_DWORD *)(*((void *)v440 + 13) + 200);
    v496[0] = MEMORY[0x1E4F143A8];
    v496[1] = 3221225472;
    v496[2] = ___ZN2CA7Context18commit_transactionEPNS_11TransactionEdPd_block_invoke_54;
    v496[3] = &__block_descriptor_44_e5_v8__0l;
    int v497 = v443;
    v496[4] = v442;
    if (HIDWORD(v508) && v478)
    {
      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = &buf;
      *(void *)&long long v569 = 0x2020000000;
      DWORD2(v569) = v478;
      *(void *)&v564[0].mach_msg_bits_t msgh_bits = 0;
      *(void *)&v564[0].uint64_t msgh_remote_port = v564;
      *(void *)&v564[0].uint64_t msgh_voucher_port = 0x3052000000;
      *(void *)&v564[1].mach_msg_bits_t msgh_bits = __Block_byref_object_copy_;
      *(void *)&v564[1].uint64_t msgh_remote_port = __Block_byref_object_dispose_;
      *(void *)&v564[1].uint64_t msgh_voucher_port = 0;
      uint64_t v488 = MEMORY[0x1E4F143A8];
      uint64_t v489 = 3221225472;
      long long v490 = ___ZN2CA7Context18commit_transactionEPNS_11TransactionEdPd_block_invoke_2_57;
      long long v491 = &unk_1E5273E50;
      long long v492 = v496;
      p_long long buf = &buf;
      long long v494 = v564;
      int v495 = HIDWORD(v508);
      v444 = dispatch_mach_create();
      *(void *)(*(void *)&v564[0].msgh_remote_port + 40) = v444;
      dispatch_set_qos_class_floor(v444, QOS_CLASS_USER_INTERACTIVE, 0);
      dispatch_mach_connect();
      _Block_object_dispose(v564, 8);
      _Block_object_dispose(&buf, 8);
    }
    else
    {
      global_queue = dispatch_get_global_queue(33, 0);
      dispatch_async(global_queue, v496);
      unsigned int v438 = (CA::Transaction *)HIDWORD(v508);
      if (HIDWORD(v508)) {
        mach_port_mod_refs(*MEMORY[0x1E4F14960], HIDWORD(v508), 1u, -1);
      }
    }
  }
  else if (HIDWORD(v508))
  {
    abort();
  }
  double v446 = *((double *)&v512 + 1);
  if (*((double *)&v512 + 1) == 0.0)
  {
    uint64_t v447 = mach_absolute_time();
    double v446 = CATimeWithHostTime(v447);
    *((double *)&v512 + 1) = v446;
  }
  CA::Layer::set_next_animation_time((CA::Layer *)v440, v438, v446, *(double *)&v513, v439);
  double v448 = *((double *)&v512 + 1);
  float64x2_t v449 = CAGetStatsStruct(0);
  ++v449[4];
  CAMarkStatistic((uint64_t)v449, v448);
  if (buffer_list)
  {
    int v453 = 0;
    atomic_compare_exchange_strong(pending_async_collect, (unsigned int *)&v453, 1u);
    if (!v453) {
      CA::DispatchGroup::enqueue(v450, v451, v452);
    }
  }
  uint64_t v454 = *((void *)&v512 + 1);
  if (CA::CG::Queue::_queue && *(double *)&CA::CG::Queue::_next_collection <= *((double *)&v512 + 1))
  {
    *(double *)&CA::CG::Queue::_next_collectiounint64_t n = *((double *)&v512 + 1) + 0.2;
    dispatch_async_f((dispatch_queue_t)CA::CG::Queue::_queue, 0, (dispatch_function_t)CA::CG::Queue::collect_callback);
    uint64_t v454 = *((void *)&v512 + 1);
  }
  *(void *)long long v466 = v454;
  uint64_t v455 = v509;
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v533);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v536);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v537);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v540);
  std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>>>::~__hash_table((uint64_t)v543);
  std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>>>::~__hash_table((uint64_t)&v544);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v547);
  return v455;
}

void sub_184751B80(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,void *>>>>::reset[abi:nn180100](v1 + 1552);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v1 + 768);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v1 + 1152);
  std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>>>::~__hash_table(v1 + 1216);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v1 + 816);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v1 + 864);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v1 + 912);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v1 + 960);
  std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>>>::~__hash_table(v1 + 1008);
  std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>>>::~__hash_table(v1 + 1056);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v1 + 1104);
  _Unwind_Resume(a1);
}

uint64_t CA::foreach_callback(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(result + 16)) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 16))(a3, result);
  }
  return result;
}

uint64_t ___ZN2CA7Context18commit_transactionEPNS_11TransactionEdPd_block_invoke_2(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 268) == *(_DWORD *)(result + 48)) {
    return CA::Layer::commit_if_needed(a2, *(unsigned int **)(result + 40), *(void *)(result + 32));
  }
  return result;
}

CA::Render::Encoder *CA::Context::commit_deleted(CA::Context *this, int a2, uint64_t a3, void *a4)
{
  float32x2_t v7 = *(CA::Render::Context **)(a3 + 40);
  if (v7) {
    CA::Render::Context::delete_object(v7, this, a2);
  }
  uint64_t result = *(CA::Render::Encoder **)(a3 + 32);
  if (result)
  {
    return CA::Render::encode_delete_object(result, this, a2);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      double v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          double v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  double v10 = operator new(0x18uLL);
  *double v10 = 0;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    BOOL v14 = 1;
    if (v6 >= 3) {
      BOOL v14 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v6);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>(a1, v17);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v18 = *(void *)a1;
  long long v19 = *(void **)(*(void *)a1 + 8 * v8);
  if (v19)
  {
    *double v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  *double v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v8) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v20 >= v6) {
        v20 %= v6;
      }
    }
    else
    {
      v20 &= v6 - 1;
    }
    long long v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_map<unsigned int,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  v35[3] = *MEMORY[0x1E4F143B8];
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    unint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return i;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  float v12 = (void *)(a1 + 16);
  v35[2] = 1;
  float v13 = (char *)operator new(0x40uLL);
  v35[0] = v13;
  v35[1] = a1 + 16;
  *(void *)float v13 = 0;
  *((void *)v13 + 1) = v5;
  *((_DWORD *)v13 + 4) = *a3;
  *(_OWORD *)(v13 + 24) = 0u;
  *(_OWORD *)(v13 + 40) = 0u;
  *((_DWORD *)v13 + 14) = 1065353216;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (v6 && (float)(v15 * (float)v6) >= v14)
  {
    unint64_t v5 = v8;
    goto LABEL_64;
  }
  BOOL v16 = 1;
  if (v6 >= 3) {
    BOOL v16 = (v6 & (v6 - 1)) != 0;
  }
  unint64_t v17 = v16 | (2 * v6);
  unint64_t v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18) {
    int8x8_t prime = (int8x8_t)v18;
  }
  else {
    int8x8_t prime = (int8x8_t)v17;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v6 = *(void *)(a1 + 8);
  }
  if (*(void *)&prime <= v6)
  {
    if (*(void *)&prime >= v6) {
      goto LABEL_60;
    }
    unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v6 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
    {
      unint64_t v26 = std::__next_prime(v26);
    }
    else
    {
      uint64_t v28 = 1 << -(char)__clz(v26 - 1);
      if (v26 >= 2) {
        unint64_t v26 = v28;
      }
    }
    if (*(void *)&prime <= v26) {
      int8x8_t prime = (int8x8_t)v26;
    }
    if (*(void *)&prime >= v6)
    {
      unint64_t v6 = *(void *)(a1 + 8);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      float32x4_t v34 = *(void **)a1;
      *(void *)a1 = 0;
      if (v34) {
        operator delete(v34);
      }
      unint64_t v6 = 0;
      *(void *)(a1 + 8) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v20 = operator new(8 * *(void *)&prime);
  atomic_uint v21 = *(void **)a1;
  *(void *)a1 = v20;
  if (v21) {
    operator delete(v21);
  }
  uint64_t v22 = 0;
  *(int8x8_t *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v22++) = 0;
  while (*(void *)&prime != v22);
  atomic_uint v23 = (void *)*v12;
  if (*v12)
  {
    unint64_t v24 = v23[1];
    uint8x8_t v25 = (uint8x8_t)vcnt_s8(prime);
    v25.i16[0] = vaddlv_u8(v25);
    if (v25.u32[0] > 1uLL)
    {
      if (v24 >= *(void *)&prime) {
        v24 %= *(void *)&prime;
      }
    }
    else
    {
      v24 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v24) = v12;
    float v29 = (void *)*v23;
    if (*v23)
    {
      do
      {
        unint64_t v30 = v29[1];
        if (v25.u32[0] > 1uLL)
        {
          if (v30 >= *(void *)&prime) {
            v30 %= *(void *)&prime;
          }
        }
        else
        {
          v30 &= *(void *)&prime - 1;
        }
        if (v30 != v24)
        {
          if (!*(void *)(*(void *)a1 + 8 * v30))
          {
            *(void *)(*(void *)a1 + 8 * v30) = v23;
            goto LABEL_56;
          }
          *atomic_uint v23 = *v29;
          *float v29 = **(void **)(*(void *)a1 + 8 * v30);
          **(void **)(*(void *)a1 + 8 * v30) = v29;
          float v29 = v23;
        }
        unint64_t v30 = v24;
LABEL_56:
        atomic_uint v23 = v29;
        float v29 = (void *)*v29;
        unint64_t v24 = v30;
      }
      while (v29);
    }
  }
  unint64_t v6 = (unint64_t)prime;
LABEL_60:
  if ((v6 & (v6 - 1)) != 0)
  {
    if (v6 <= v5) {
      v5 %= v6;
    }
  }
  else
  {
    unint64_t v5 = (v6 - 1) & v5;
  }
LABEL_64:
  uint64_t v31 = *(void **)(*(void *)a1 + 8 * v5);
  uint64_t i = (uint64_t *)v35[0];
  if (v31)
  {
    *(void *)v35[0] = *v31;
LABEL_72:
    *uint64_t v31 = i;
    goto LABEL_73;
  }
  *(void *)v35[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(*(void *)a1 + 8 * v5) = v12;
  if (*i)
  {
    unint64_t v32 = *(void *)(*i + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v32 >= v6) {
        v32 %= v6;
      }
    }
    else
    {
      v32 &= v6 - 1;
    }
    uint64_t v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  v35[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,void *>>>>::reset[abi:nn180100]((uint64_t)v35);
  return i;
}

void sub_1847524C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL CA::Render::encode_sync_request(CA::Render *this, CA::Render::Encoder *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  float v4 = (unsigned char *)*((void *)this + 4);
  if ((unint64_t)(v4 + 1) > *((void *)this + 5))
  {
    CA::Render::Encoder::grow(this, 1);
    float v4 = (unsigned char *)*((void *)this + 4);
  }
  *((void *)this + 4) = v4 + 1;
  unsigned char *v4 = 33;
  uint64_t v15 = 0;
  int v5 = MEMORY[0x1853246C0](*MEMORY[0x1E4F14960], a2, 21, (char *)&v15 + 4, &v15);
  if (v5) {
    BOOL v6 = 0;
  }
  else {
    BOOL v6 = v15 == 18;
  }
  if (!v6 || HIDWORD(v15) == 0 || HIDWORD(v15) == -1)
  {
    int v9 = v5;
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      double v10 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 67109632;
        int v17 = v9;
        __int16 v18 = 1024;
        int v19 = HIDWORD(v15);
        __int16 v20 = 1024;
        int v21 = v15;
        _os_log_impl(&dword_184668000, v10, OS_LOG_TYPE_ERROR, "failed encode_port_make_once : r=%i so=%x t=%x", buf, 0x14u);
      }
    }
  }
  uint64_t v11 = x_heap_malloc_small_(*((uint64_t **)this + 1), 0x30uLL);
  *(_DWORD *)(v11 + 8) = 2;
  int v12 = HIDWORD(v15);
  *(_DWORD *)(v11 + 16) = HIDWORD(v15);
  *(_DWORD *)(v11 + 20) = 18;
  *(unsigned char *)(v11 + 24) = 1;
  *(void *)uint64_t v11 = *((void *)this + 6);
  uint64_t v13 = *((void *)this + 7) + 1;
  *((void *)this + 6) = v11;
  *((void *)this + 7) = v13;
  return (v12 - 1) < 0xFFFFFFFE;
}

void CA::Layer::set_next_animation_time(CA::Layer *this, CA::Transaction *a2, double a3, double a4, void *a5)
{
  v19[256] = *MEMORY[0x1E4F143B8];
  CFSetRef v8 = (const __CFSet *)non_visible_animating_layers;
  if (non_visible_animating_layers && (*((unsigned char *)this + 116) & 4) == 0)
  {
    int v9 = *((_DWORD *)this + 25);
    *((_DWORD *)this + 25) = v9 + 1;
    if (v9
      || (os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock),
          (CFSetRef v8 = (const __CFSet *)non_visible_animating_layers) != 0))
    {
      context = (const void **)v19;
      BOOL v16 = (const void **)v19;
      int v17 = (const void **)v19;
      uint64_t v18 = 256;
      CFSetApplyFunction(v8, (CFSetApplierFunction)CA::Layer::collect_non_visible_callback, &context);
      double v10 = context;
      uint64_t v11 = v16;
      while (v10 != v11)
        CFSetRemoveValue((CFMutableSetRef)non_visible_animating_layers, *v10++);
      if (!CFSetGetCount((CFSetRef)non_visible_animating_layers))
      {
        CFRelease((CFTypeRef)non_visible_animating_layers);
        non_visible_animating_layers = 0;
      }
      if (context != v17) {
        free(context);
      }
    }
    CA::Transaction::unlock(this);
  }
  if (a4 < INFINITY && (*((unsigned char *)this + 116) & 4) == 0)
  {
    double v12 = a3 + 0.0166666667;
    if (a3 + 0.0166666667 <= a4) {
      double v12 = a4;
    }
    CA::call_at_time((CA *)CA::Layer::animation_heart_beat, 0, v12, a5);
  }
  if (qword_1EB2A8C20) {
    BOOL v13 = 0;
  }
  else {
    BOOL v13 = (void)animation_state == 0;
  }
  if (!v13 || *((void *)&animation_state + 1) != 0) {
    operator new();
  }
}

void sub_184752934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *a12)
{
  if (a10 != a12) {
    free(a10);
  }
  CA::Transaction::unlock(v12);
  _Unwind_Resume(a1);
}

void CA::DispatchGroup::enqueue(CA::DispatchGroup *this, void (*a2)(void *), void *a3)
{
  if (CA::DispatchGroup::enqueue(void (*)(void *),void *)::once != -1) {
    dispatch_once_f(&CA::DispatchGroup::enqueue(void (*)(void *),void *)::once, 0, (dispatch_function_t)CA::DispatchGroup::init);
  }
  float v3 = CA::DispatchGroup::_queue;

  dispatch_async_f(v3, 0, (dispatch_function_t)async_collect_callback);
}

void *std::__hash_table<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,X::List<void({block_pointer})(void)> *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(float *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *((void *)a1 + 1);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    int v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      double v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          double v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  double v10 = operator new(0x20uLL);
  *double v10 = 0;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  v10[3] = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (v6 && (float)(v13 * (float)v6) >= v12)
  {
    unint64_t v5 = v8;
    goto LABEL_64;
  }
  BOOL v14 = 1;
  if (v6 >= 3) {
    BOOL v14 = (v6 & (v6 - 1)) != 0;
  }
  unint64_t v15 = v14 | (2 * v6);
  unint64_t v16 = vcvtps_u32_f32(v12 / v13);
  if (v15 <= v16) {
    int8x8_t prime = (int8x8_t)v16;
  }
  else {
    int8x8_t prime = (int8x8_t)v15;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v6 = *((void *)a1 + 1);
  }
  if (*(void *)&prime <= v6)
  {
    if (*(void *)&prime >= v6) {
      goto LABEL_60;
    }
    unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v6 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
    {
      unint64_t v24 = std::__next_prime(v24);
    }
    else
    {
      uint64_t v26 = 1 << -(char)__clz(v24 - 1);
      if (v24 >= 2) {
        unint64_t v24 = v26;
      }
    }
    if (*(void *)&prime <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    if (*(void *)&prime >= v6)
    {
      unint64_t v6 = *((void *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      int v33 = *(void **)a1;
      *(void *)a1 = 0;
      if (v33) {
        operator delete(v33);
      }
      unint64_t v6 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v18 = operator new(8 * *(void *)&prime);
  int v19 = *(void **)a1;
  *(void *)a1 = v18;
  if (v19) {
    operator delete(v19);
  }
  uint64_t v20 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v20++) = 0;
  while (*(void *)&prime != v20);
  int v21 = (void *)*((void *)a1 + 2);
  if (v21)
  {
    unint64_t v22 = v21[1];
    uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
    v23.i16[0] = vaddlv_u8(v23);
    if (v23.u32[0] > 1uLL)
    {
      if (v22 >= *(void *)&prime) {
        v22 %= *(void *)&prime;
      }
    }
    else
    {
      v22 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
    uint8x8_t v27 = (void *)*v21;
    if (*v21)
    {
      do
      {
        unint64_t v28 = v27[1];
        if (v23.u32[0] > 1uLL)
        {
          if (v28 >= *(void *)&prime) {
            v28 %= *(void *)&prime;
          }
        }
        else
        {
          v28 &= *(void *)&prime - 1;
        }
        if (v28 != v22)
        {
          if (!*(void *)(*(void *)a1 + 8 * v28))
          {
            *(void *)(*(void *)a1 + 8 * v28) = v21;
            goto LABEL_56;
          }
          *int v21 = *v27;
          *uint8x8_t v27 = **(void **)(*(void *)a1 + 8 * v28);
          **(void **)(*(void *)a1 + 8 * v28) = v27;
          uint8x8_t v27 = v21;
        }
        unint64_t v28 = v22;
LABEL_56:
        int v21 = v27;
        uint8x8_t v27 = (void *)*v27;
        unint64_t v22 = v28;
      }
      while (v27);
    }
  }
  unint64_t v6 = (unint64_t)prime;
LABEL_60:
  if ((v6 & (v6 - 1)) != 0)
  {
    if (v6 <= v5) {
      v5 %= v6;
    }
  }
  else
  {
    unint64_t v5 = (v6 - 1) & v5;
  }
LABEL_64:
  float v29 = *(void **)a1;
  unint64_t v30 = *(void **)(*(void *)a1 + 8 * v5);
  if (v30)
  {
    *double v10 = *v30;
LABEL_72:
    *unint64_t v30 = v10;
    goto LABEL_73;
  }
  *double v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v5] = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v31 >= v6) {
        v31 %= v6;
      }
    }
    else
    {
      v31 &= v6 - 1;
    }
    unint64_t v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}