void CA::CG::IOSurfaceDataProvider::~IOSurfaceDataProvider(CA::CG::IOSurfaceDataProvider *this, uint64_t a2, void *a3)
{
  malloc_zone_t *malloc_zone;
  uint64_t vars8;

  CA::CG::AccelDataProvider::~AccelDataProvider(this, a2, a3);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::CG::IOSurfaceDataProvider::copy_data(CA::CG::IOSurfaceDataProvider *this)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  v2 = (CA::CG::Queue **)*((void *)this + 2);
  if (v2 && !*((void *)this + 3) && !*((unsigned char *)this + 48))
  {
    int v3 = BYTE9(xmmword_1EB2ACC10);
    if (BYTE9(xmmword_1EB2ACC10))
    {
      kdebug_trace();
      v2 = (CA::CG::Queue **)*((void *)this + 2);
    }
    unsigned int v4 = *((_DWORD *)this + 11);
    if (v4 && v2[9])
    {
      CA::CG::Queue::wait_queue(v2[9], v4);
      v2 = (CA::CG::Queue **)*((void *)this + 2);
    }
    v5 = (__IOSurface *)(*((uint64_t (**)(CA::CG::Queue **))*v2 + 3))(v2);
    AllocSize = (CA::Render *)IOSurfaceGetAllocSize(v5);
    unint64_t v13 = 0;
    v7 = CA::Render::aligned_malloc(AllocSize, &v13, 0);
    unint64_t v8 = v13;
    *((void *)this + 3) = v7;
    *((void *)this + 4) = v8;
    if (v7)
    {
      v9 = v7;
      if (IOSurfaceLock(v5, 1u, 0))
      {
        if (x_log_hook_p())
        {
          IOSurfaceGetID(v5);
          x_log_();
        }
        else
        {
          v11 = x_log_category_cg;
          if (os_log_type_enabled((os_log_t)x_log_category_cg, OS_LOG_TYPE_ERROR))
          {
            IOSurfaceID ID = IOSurfaceGetID(v5);
            *(_DWORD *)buf = 67109120;
            IOSurfaceID v15 = ID;
            _os_log_impl(&dword_184668000, v11, OS_LOG_TYPE_ERROR, "CoreAnimation: failed to lock IOSurface %x\n", buf, 8u);
          }
        }
      }
      else
      {
        BaseAddress = IOSurfaceGetBaseAddress(v5);
        memcpy(v9, BaseAddress, (size_t)AllocSize);
        IOSurfaceUnlock(v5, 1u, 0);
      }
    }
    if (v3) {
      kdebug_trace();
    }
  }
}

CGAffineTransform *CAML::parse_affine_matrix(CGAffineTransform *this, CAML::Context *a2, char *a3, CAML *a4, const char *a5)
{
  v52 = (CAML::Context *)this;
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  *(void *)v63 = a2;
  long long v5 = *MEMORY[0x1E4F1DAB8];
  long long v6 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
  *((_OWORD *)a3 + 1) = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  *((_OWORD *)a3 + 2) = v6;
  *(_OWORD *)a3 = v5;
  if (a2 < a4)
  {
    uint64_t v10 = MEMORY[0x1E4F14390];
    memset(__dst, 0, sizeof(__dst));
    memset(&v64, 0, sizeof(v64));
    v11 = a2;
    do
    {
      if (!*(unsigned char *)v11) {
        return this;
      }
      v12 = CAML::skip_whitespace(v11, a4, a3);
      size_t v13 = 0;
      *(void *)v63 = v12;
      do
      {
        if (*(void *)v63 < (unint64_t)a4)
        {
          unsigned int v14 = *(char *)(*(void *)v63 + v13);
          if (!*(unsigned char *)(*(void *)v63 + v13)) {
            break;
          }
          if ((v14 & 0x80000000) != 0)
          {
            if (!__maskrune(v14, 0x100uLL)) {
              break;
            }
          }
          else if ((*(_DWORD *)(v10 + 4 * v14 + 60) & 0x100) == 0)
          {
            break;
          }
        }
        ++v13;
      }
      while (v13 != 31);
      IOSurfaceID v15 = *(char **)v63;
      memcpy(__dst, *(const void **)v63, v13);
      *((unsigned char *)__dst + v13) = 0;
      *(void *)v63 = &v15[v13];
      v17 = CAML::skip_whitespace((CAML *)&v15[v13], a4, v16);
      v11 = v17;
      *(void *)v63 = v17;
      if (v17 < a4 && *(unsigned char *)v17 == 40)
      {
        v11 = CAML::skip_whitespace((CAML *)((char *)v17 + 1), a4, v18);
        *(void *)v63 = v11;
      }
      if (v11 >= a4)
      {
        unint64_t v20 = 0;
      }
      else
      {
        unint64_t v20 = 0;
        do
        {
          int v21 = *(unsigned __int8 *)v11;
          if (!*(unsigned char *)v11) {
            break;
          }
          if (v21 == 41 || v20 > 5)
          {
            if (v21 == 41)
            {
              v11 = CAML::skip_whitespace((CAML *)((char *)v11 + 1), a4, v18);
              *(void *)v63 = v11;
            }
            break;
          }
          *(&v64.a + v20) = CAML::parse_real(v11, v63, (char **)a4, v19);
          v24 = CAML::skip_whitespace(*(CAML **)v63, a4, v23);
          v11 = v24;
          *(void *)v63 = v24;
          if (v24 < a4)
          {
            int v25 = *(unsigned __int8 *)v24;
            if (v25 == 59 || v25 == 44)
            {
              v11 = CAML::skip_whitespace((CAML *)((char *)v24 + 1), a4, v18);
              *(void *)v63 = v11;
            }
          }
          ++v20;
        }
        while (v11 < a4);
      }
      if (v11 < a4)
      {
        int v26 = *(unsigned __int8 *)v11;
        if (v26 == 59 || v26 == 44)
        {
          v11 = CAML::skip_whitespace((CAML *)((char *)v11 + 1), a4, v18);
          *(void *)v63 = v11;
        }
      }
      if (LODWORD(__dst[0]) == 1920229741 && *(_DWORD *)((char *)__dst + 3) == 7891314)
      {
        if (v20 != 6) {
          return (CGAffineTransform *)CAML::Context::error(v52, "Invalid transform: %s (position %ld)", (const char *)a2, v11 - a2);
        }
        CGAffineTransform t1 = v64;
        long long v34 = *((_OWORD *)a3 + 1);
        *(_OWORD *)&t2.CGFloat a = *(_OWORD *)a3;
        *(_OWORD *)&t2.c = v34;
        *(_OWORD *)&t2.tx = *((_OWORD *)a3 + 2);
        p_CGAffineTransform t1 = &t1;
        p_CGAffineTransform t2 = &t2;
      }
      else
      {
        if (*(void *)&__dst[0] == 0x74616C736E617274 && WORD4(__dst[0]) == 101 && v20 != 0 && v20 <= 2)
        {
          if (v20 >= 2)
          {
            CGFloat b = v64.b;
          }
          else
          {
            v64.CGFloat b = 0.0;
            CGFloat b = 0.0;
          }
          long long v40 = *((_OWORD *)a3 + 1);
          *(_OWORD *)&v59.CGFloat a = *(_OWORD *)a3;
          *(_OWORD *)&v59.c = v40;
          *(_OWORD *)&v59.tx = *((_OWORD *)a3 + 2);
          this = CGAffineTransformTranslate(&v62, &v59, v64.a, b);
          goto LABEL_77;
        }
        BOOL v32 = LODWORD(__dst[0]) == 1818321779 && WORD2(__dst[0]) == 101;
        if (v32 && v20 - 1 <= 1)
        {
          if (v20 == 1)
          {
            v64.CGFloat b = v64.a;
            CGFloat a = v64.a;
          }
          else
          {
            CGFloat a = v64.b;
          }
          long long v41 = *((_OWORD *)a3 + 1);
          *(_OWORD *)&v58.CGFloat a = *(_OWORD *)a3;
          *(_OWORD *)&v58.c = v41;
          *(_OWORD *)&v58.tx = *((_OWORD *)a3 + 2);
          this = CGAffineTransformScale(&v62, &v58, v64.a, a);
          goto LABEL_77;
        }
        BOOL v38 = LODWORD(__dst[0]) == 1635020658 && *(_DWORD *)((char *)__dst + 3) == 6648929;
        if (v38 && v20 == 1)
        {
          long long v39 = *((_OWORD *)a3 + 1);
          *(_OWORD *)&v57.CGFloat a = *(_OWORD *)a3;
          *(_OWORD *)&v57.c = v39;
          *(_OWORD *)&v57.tx = *((_OWORD *)a3 + 2);
          this = CGAffineTransformRotate(&v62, &v57, v64.a);
          goto LABEL_77;
        }
        if ((LODWORD(__dst[0]) != 2003135347 || WORD2(__dst[0]) != 88)
          && (LODWORD(__dst[0]) != 2003135347 || WORD2(__dst[0]) != 89))
        {
          return (CGAffineTransform *)CAML::Context::error(v52, "Invalid transform: %s (position %ld)", (const char *)a2, v11 - a2);
        }
        if (v20 != 1) {
          return (CGAffineTransform *)CAML::Context::error(v52, "Invalid transform: %s (position %ld)", (const char *)a2, v11 - a2);
        }
        uint64_t v45 = *MEMORY[0x1E4F1DAB8];
        double v46 = *(double *)(MEMORY[0x1E4F1DAB8] + 8);
        long long v51 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 24);
        uint64_t v47 = *(void *)(MEMORY[0x1E4F1DAB8] + 40);
        double v48 = tan(v64.a);
        if (BYTE4(__dst[0]) == 89) {
          double v49 = v48;
        }
        else {
          double v49 = v46;
        }
        if (BYTE4(__dst[0]) == 89) {
          double v48 = 0.0;
        }
        v54[0] = v45;
        *(double *)&v54[1] = v49;
        *(double *)&v54[2] = v48;
        long long v55 = v51;
        uint64_t v56 = v47;
        long long v50 = *((_OWORD *)a3 + 1);
        v53[0] = *(_OWORD *)a3;
        v53[1] = v50;
        v53[2] = *((_OWORD *)a3 + 2);
        p_CGAffineTransform t1 = (CGAffineTransform *)v54;
        p_CGAffineTransform t2 = (CGAffineTransform *)v53;
      }
      this = CGAffineTransformConcat(&v62, p_t1, p_t2);
LABEL_77:
      long long v42 = *(_OWORD *)&v62.c;
      *(_OWORD *)a3 = *(_OWORD *)&v62.a;
      *((_OWORD *)a3 + 1) = v42;
      *((_OWORD *)a3 + 2) = *(_OWORD *)&v62.tx;
    }
    while (v11 < a4);
  }
  return this;
}

CGImageSource *CAML::create_image_from_url(CFURLRef url, const __CFURL *a2)
{
  int v2 = (int)a2;
  if (CAML::create_image_from_url(__CFURL const*,BOOL)::once[0] != -1) {
    dispatch_once(CAML::create_image_from_url(__CFURL const*,BOOL)::once, &__block_literal_global_6077);
  }
  unsigned int v4 = &CAML::create_image_from_url(__CFURL const*,BOOL)::options_hdr;
  if (!v2) {
    unsigned int v4 = &CAML::create_image_from_url(__CFURL const*,BOOL)::options_sdr;
  }
  CFDictionaryRef v5 = (const __CFDictionary *)*v4;
  result = CGImageSourceCreateWithURL(url, (CFDictionaryRef)*v4);
  if (result)
  {
    v7 = result;
    CGImageRef ImageAtIndex = CGImageSourceCreateImageAtIndex(result, 0, v5);
    CFRelease(v7);
    return ImageAtIndex;
  }
  return result;
}

CFDictionaryRef ___ZN4CAML21create_image_from_urlEPK7__CFURLb_block_invoke()
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  keys[0] = @"kCGGenerateFlexGTC";
  values = (void *)*MEMORY[0x1E4F1CFD0];
  v0 = values;
  v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  int v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFDictionaryRef v3 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  unsigned int v4 = (void *)*MEMORY[0x1E4F2FF48];
  v8[0] = *(void **)MEMORY[0x1E4F2FEB0];
  v8[1] = v4;
  CFDictionaryRef v5 = (void *)*MEMORY[0x1E4F2FE60];
  v8[2] = *(void **)MEMORY[0x1E4F2FE58];
  v8[3] = v5;
  v7[0] = v0;
  v7[1] = v0;
  v7[2] = *(void **)MEMORY[0x1E4F2FE68];
  v7[3] = v3;
  CAML::create_image_from_url(__CFURL const*,BOOL)::options_hdr = (uint64_t)CFDictionaryCreate(0, (const void **)v8, (const void **)v7, 4, v1, v2);
  CFDictionaryRef result = CFDictionaryCreate(0, (const void **)v8, (const void **)v7, 2, v1, v2);
  CAML::create_image_from_url(__CFURL const*,BOOL)::options_sdr = (uint64_t)result;
  return result;
}

double CA::Transform::Transform(CA::Transform *this)
{
  CA::Transform::rotate90(void)::t = xmmword_184997D50;
  unk_1E8F85E80 = 0u;
  xmmword_1E8F85E90 = xmmword_184997D60;
  unk_1E8F85EA0 = 0u;
  xmmword_1E8F85EB0 = 0u;
  unk_1E8F85EC0 = xmmword_184997D50;
  xmmword_1E8F85ED0 = 0u;
  unk_1E8F85EE0 = xmmword_184997D60;
  __asm { FMOV            V0.2D, #1.0 }
  xmmword_1E8F85EF0 = _Q0;
  byte_1E8F85F00 = byte_1E8F85F00 & 0xE0 | 4;
  return CA::Transform::set_2x2((CA::Transform *)&CA::Transform::rotate90(void)::t);
}

float64x2_t CA::Transform::translate_right(float64x2_t *this, float64x2_t result, float64_t a3, double a4)
{
  if ((LOBYTE(this[9].f64[0]) & 0x10) != 0)
  {
    result.f64[1] = a3;
    float64x2_t v5 = this[1];
    float64x2_t v6 = this[3];
    float64x2_t v7 = this[5];
    float64x2_t v8 = this[7];
    float64x2_t v9 = vmlaq_laneq_f64(this[2], result, v6, 1);
    float64x2_t v10 = vmlaq_laneq_f64(this[4], result, v7, 1);
    float64x2_t v11 = vmlaq_laneq_f64(this[6], result, v8, 1);
    *this = vmlaq_laneq_f64(*this, result, v5, 1);
    this[1] = vmlaq_laneq_f64(v5, (float64x2_t)0, v5, 1);
    this[2] = v9;
    this[3] = vmlaq_laneq_f64(v6, (float64x2_t)0, v6, 1);
    this[4] = v10;
    this[5] = vmlaq_laneq_f64(v7, (float64x2_t)0, v7, 1);
    this[6] = v11;
    this[7] = vmlaq_laneq_f64(v8, (float64x2_t)0, v8, 1);
  }
  else
  {
    result.f64[0] = this[6].f64[0] + result.f64[0];
    float64_t v4 = this[6].f64[1] + a3;
    this[6].f64[0] = result.f64[0];
    this[6].f64[1] = v4;
  }
  return result;
}

float64_t CA::Transform::rotate90(CA::Transform *this, uint64_t a2, uint64_t a3, const double *a4)
{
  {
    float64x2_t v6 = this;
    this = v6;
    if (v5)
    {
      CA::Transform::Transform(v6);
      this = v6;
    }
  }

  return CA::Transform::concat_left(this, (float64x2_t *)&CA::Transform::rotate90(void)::t, a3, a4);
}

uint64_t CA::Transform::apply_to_point4(uint64_t this, float32x2_t *a2, float32x2_t *a3, const float *a4, uint64_t a5)
{
  if ((*(unsigned char *)(this + 144) & 0x10) != 0)
  {
    for (; a5; --a5)
    {
      *(float32x4_t *)a2->f32 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)this), *(float64x2_t *)(this + 16)), COERCE_FLOAT(*(_OWORD *)a3->f32)), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(this + 32)), *(float64x2_t *)(this + 48)), *a3, 1), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(this + 64)), *(float64x2_t *)(this + 80)), *(float32x4_t *)a3->f32, 2), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(this + 96)),
                                    *(float64x2_t *)(this + 112)),
                                  *(float32x4_t *)a3->f32,
                                  3);
      a2 += 2;
      a3 = (float32x2_t *)((char *)a4 + (void)a3);
    }
  }
  else
  {
    float64x2_t v5 = *(float64x2_t *)(this + 96);
    v6.f64[0] = *(float64_t *)this;
    v7.f64[1] = *(float64_t *)(this + 40);
    if (a2 == a3)
    {
      if (a5)
      {
        v6.f64[1] = *(float64_t *)(this + 8);
        v7.f64[0] = *(float64_t *)(this + 32);
        do
        {
          *a2 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(v5, v6, COERCE_FLOAT(*a2)), v7, COERCE_FLOAT(HIDWORD(*(unint64_t *)a2))));
          a2 += 2;
          --a5;
        }
        while (a5);
      }
    }
    else if (a5)
    {
      v6.f64[1] = *(float64_t *)(this + 8);
      v7.f64[0] = *(float64_t *)(this + 32);
      float64x2_t v8 = a3 + 1;
      do
      {
        *a2 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(v5, v6, COERCE_FLOAT(*(void *)&v8[-1])), v7, COERCE_FLOAT(HIDWORD(*(void *)&v8[-1]))));
        a2[1] = *v8;
        a2 += 2;
        float64x2_t v8 = (float32x2_t *)((char *)a4 + (void)v8);
        --a5;
      }
      while (a5);
    }
  }
  return this;
}

CA::OGL::Context *sw_new_context(void *a1, void *a2)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  CFDictionaryRef v3 = (CA::OGL::Context *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x5010uLL, 0x743898A5uLL);
  float64_t v4 = v3;
  if (v3)
  {
    bzero(v3, 0x5010uLL);
    CA::OGL::Context::Context(v4);
    *(void *)float64_t v4 = &unk_1ED02C7F0;
  }
  return v4;
}

CA::OGL::Context *new_null_context(void *a1, void *a2)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  CFDictionaryRef v3 = (CA::OGL::Context *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x748uLL, 0x743898A5uLL);
  float64_t v4 = v3;
  if (v3)
  {
    bzero(v3, 0x748uLL);
    CA::OGL::Context::Context(v4);
    *(void *)float64_t v4 = &unk_1ED02AA38;
  }
  return v4;
}

uint64_t CA::OGL::NullContext::sw_renderer_p(CA::OGL::NullContext *this)
{
  return 1;
}

uint64_t CA::OGL::NullContext::set_destination(CA::OGL::NullContext *this, void *a2, uint64_t a3, unint64_t a4, void *a5, uint64_t a6, int a7, int a8, int a9, int a10)
{
  return 1;
}

uint64_t CA::OGL::NullContext::function_supported(CA::OGL::NullContext *this)
{
  return 1;
}

uint64_t CA::OGL::NullContext::make_buffer_current(CA::OGL::NullContext *this, CA::WindowServer::Surface *a2)
{
  return 1;
}

uint64_t CA::OGL::NullContext::set_surface()
{
  return 1;
}

uint64_t CA::OGL::NullContext::needs_destination_group(CA::OGL::NullContext *this)
{
  return 0;
}

uint64_t CA::OGL::NullContext::create_null_surface(CA::OGL::NullContext *this)
{
  return 0;
}

uint64_t CA::OGL::NullContext::create_surface_from_iosurface(CA::OGL::NullContext *this, int a2, int a3, int a4, __IOSurface *a5)
{
  return 0;
}

uint64_t CA::OGL::NullContext::create_surface_from_data(CA::OGL::NullContext *this, void *a2)
{
  return 0;
}

uint64_t CA::OGL::NullContext::create_surface(CA::OGL::NullContext *this, int a2, const CA::Bounds *a3)
{
  return 0;
}

uint64_t CA::OGL::NullContext::new_image(CA::OGL::NullContext *this)
{
  return 0;
}

uint64_t CA::OGL::NullContext::image_surface()
{
  return 0;
}

uint64_t CA::OGL::NullContext::bind_image_impl()
{
  return 0;
}

uint64_t CA::OGL::NullContext::get()
{
  return 0;
}

void CA::OGL::NullContext::~NullContext(CA::OGL::NullContext *this)
{
  CA::OGL::Context::~Context(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

id *gles_new_context(void **a1, void *a2)
{
  if (*(_DWORD *)a1 != 3) {
    return 0;
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  CFDictionaryRef result = (id *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x8A8uLL, 0x743898A5uLL);
  if (result) {
    return CA::OGL::GLESContext::GLESContext(result, a1[1]);
  }
  return result;
}

uint64_t metal_new_context(void *a1, void *a2, int a3)
{
  return CA::OGL::new_metal_context(a1, a2, 0, a3, 0, @"com.apple.coreanimation.CARenderOGL");
}

void *CARenderOGLNew_(uint64_t (**a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (*a1)(a2, a3, a4);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  *(_WORD *)(v4 + 832) |= 2u;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  float64x2_t v7 = malloc_type_zone_malloc(malloc_zone, 0x68uLL, 0x8BB15036uLL);
  float64x2_t v8 = v7;
  if (v7)
  {
    v7[1] = 0;
    v7[2] = 0;
    void *v7 = v5;
    v7[6] = malloc_type_malloc(0x40000uLL, 0xA44586FDuLL);
    v8[7] = 0;
    *((_DWORD *)v8 + 24) = 1;
    *((_WORD *)v8 + 50) = 0;
  }
  return v8;
}

void *CARenderOGLNew(uint64_t (**a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return CARenderOGLNew_(a1, a2, 0, a3);
}

uint64_t CARenderOGLGetGLContext(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 184);
}

void *CARenderOGLSetGLContext(void *result, uint64_t a2)
{
  int v2 = (void *)*result;
  if (*(void *)(*result + 184) != a2)
  {
    CFDictionaryRef result = (void *)(*(uint64_t (**)(void))(*v2 + 1096))(*result);
    v2[23] = a2;
  }
  return result;
}

uint64_t CARenderOGLGetFeatureFlags(uint64_t a1)
{
  return *(unsigned int *)(*(void *)a1 + 432);
}

uint64_t CARenderOGLSetFeatureFlags(uint64_t *a1, int a2)
{
  uint64_t result = *a1;
  int v3 = *(_DWORD *)(result + 224);
  *(_DWORD *)(result + 224) = a2;
  *(_DWORD *)(result + 432) = global_feature_flags | a2;
  if (((v3 ^ a2) & 0x2000200) != 0) {
    return CA::OGL::Context::update_color_program_cache(result);
  }
  return result;
}

uint64_t CARenderOGLGetColorSpace(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 144);
}

uint64_t CARenderOGLGetFlags(uint64_t a1)
{
  return (*(unsigned __int16 *)(*(void *)a1 + 832) >> 7) & 1;
}

CGColorSpace *CARenderOGLSetColorSpace(CA::OGL::Context **a1, CGColorSpace *a2)
{
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (*(float *)&dword_1EB2ACB4C) {
    a2 = (CGColorSpace *)CAGetColorSpace(*(float *)&dword_1EB2ACB4C);
  }
  uint64_t v4 = *a1;

  return CA::OGL::Context::set_colorspace(v4, a2);
}

uint64_t CARenderOGLPurge(void *a1)
{
  return (*(uint64_t (**)(void, uint64_t))(*(void *)*a1 + 224))(*a1, 1);
}

uint64_t CARenderOGLCollect(CA::OGL::Renderer *a1, const CA::Render::Update *a2)
{
  uint64_t v4 = mach_absolute_time();
  double v5 = CATimeWithHostTime(v4);
  CA::Render::collect(0, v5);

  return CA::OGL::Renderer::collect(a1, a2, v5);
}

void CARenderOGLDestroy(CA::OGL::Renderer *a1)
{
  uint64_t v2 = *(void *)a1;
  (*(void (**)(void, uint64_t))(**(void **)a1 + 224))(*(void *)a1, 1);
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  CA::OGL::Renderer::~Renderer(a1);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, a1);
}

uint64_t CARenderOGLWarmup(void *a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)*a1 + 176))(*a1, 0);
}

void CARenderOGLPrepareUpdateShape(CA::OGL::Renderer *a1, uint64_t a2)
{
}

void CARenderOGLSetUpdateRect(CA::OGL::Renderer *a1, uint64_t a2, double a3, float64x2_t a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    int8x16_t v5 = *(int8x16_t *)(a2 + 16);
    a4.f64[0] = 0.0;
    int8x16_t v6 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a4, (float64x2_t)v5).i64[0], 0);
    v7.i64[1] = *(void *)(a2 + 24);
    *(double *)v7.i64 = -*(double *)v5.i64;
    int8x16_t v8 = vbslq_s8(v6, v7, v5);
    int8x16_t v9 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a4, (float64x2_t)vdupq_laneq_s64((int64x2_t)v5, 1)).i64[0], 0);
    v10.i64[0] = v8.i64[0];
    v10.i64[1] = *(void *)&vnegq_f64(*(float64x2_t *)&v5).f64[1];
    float64x2_t v11 = (float64x2_t)vbslq_s8(v9, v10, v8);
    int8x16_t v12 = (int8x16_t)vceqzq_f64(v11);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v12, 1), v12).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v13 = vorrq_s8((int8x16_t)vcltzq_f64(v11), (int8x16_t)vcgezq_f64(v11)),
          int8x16_t v14 = (int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v13), 1),
          (vornq_s8(v14, v13).u64[0] & 0x8000000000000000) != 0))
    {
      int32x4_t v20 = 0uLL;
    }
    else
    {
      v14.i64[0] = 0x8000000000000000;
      v15.i64[0] = *(_OWORD *)&vaddq_f64(*(float64x2_t *)a2, (float64x2_t)vbslq_s8(v6, v5, v14));
      v16.i64[0] = v15.i64[0];
      v16.i64[1] = *(void *)(a2 + 8);
      v15.i64[1] = *(void *)&vaddq_f64(*(float64x2_t *)&v5, *(float64x2_t *)a2).f64[1];
      float64x2_t v17 = (float64x2_t)vbslq_s8(v9, v15, v16);
      int32x4_t v18 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v17, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      int32x4_t v20 = vuzp1q_s32(v18, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v17, v11), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v18));
    }
    memset(v21, 0, sizeof(v21));
    CA::Shape::operator=((uint64_t)v21, &v20);
    CA::OGL::Renderer::set_clip_shape(a1, (CA::Shape *)v21);
  }
  else
  {
    v19 = (CA::Shape *)*((void *)a1 + 2);
    if (v19)
    {
      CA::Shape::unref(v19);
      *((void *)a1 + 2) = 0;
    }
  }
}

uint64_t CARenderOGLSetDisplay(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)result + 192) = a2;
  return result;
}

uint64_t CARenderOGLSetDestinationOffset(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 80))();
}

uint64_t CARenderOGLRender(CA::OGL *a1, CA::OGL::Renderer *a2)
{
  kdebug_trace();
  CA::OGL::render(a1, a2, v4);
  CA::Render::collect(0, *(double *)(*(void *)a1 + 240));
  CA::OGL::Renderer::collect(a1, a2, *(double *)(*(void *)a1 + 240));

  return kdebug_trace();
}

uint64_t CARenderOGLFlush(void *a1)
{
  return (*(uint64_t (**)(void, uint64_t))(*(void *)*a1 + 408))(*a1, 1);
}

uint64_t CARenderOGLFinish(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 416))();
}

uint64_t CARenderOGLSetDestinationTexture(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 16))();
}

uint64_t CARenderOGLSetDestinationIOSurface(void *a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(*(void *)*a1 + 32))(*a1, a2, a3, 0);
}

float CARenderOGLComputeSurfaceAPL(uint64_t *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 1057417593;
  uint64_t v16 = 0;
  uint64_t v17 = 0x3E851EB83E5A1CACLL;
  if (a4)
  {
    uint64_t v17 = *(void *)a4;
    LODWORD(v18) = *(_DWORD *)(a4 + 8);
  }
  if (a3) {
    char v5 = 8;
  }
  else {
    char v5 = 0;
  }
  BYTE4(v18) = v5;
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, void, void))(*(void *)*a1 + 672))(*a1, 1, 0, 0);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)*a1 + 872))(*a1, v6, &v16, v7);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)*a1 + 416))(*a1, v9, v10, v11);
  CA::OGL::Context::release_surface(*a1, v6);
  float v12 = *(float *)(*(void *)v8 + 32);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)*a1 + 832))(*a1, v8, v13, v14);
  return v12;
}

uint64_t CARenderOGLSetHDRScalingFactor(uint64_t a1, float a2)
{
  uint64_t v2 = *(void **)a1;
  v3.n128_f32[0] = powf(a2, *(float *)(*(void *)a1 + 152));
  uint64_t v4 = v2[33];
  if (v4) {
    *(_DWORD *)(v4 + 64) = v3.n128_u32[0];
  }
  char v5 = *(uint64_t (**)(void *, __n128))(*v2 + 1048);

  return v5(v2, v3);
}

uint64_t CARenderOGLSetEDRScalingFactor(void **a1, float a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = v2[33];
  if (v3) {
    *(float *)(v3 + 64) = a2;
  }
  return (*(uint64_t (**)(void))(*v2 + 1048))();
}

uint64_t CARenderSoftwareSetDestination(void *a1)
{
  return (*(uint64_t (**)(void))(*(void *)*a1 + 1064))(*a1);
}

uint64_t CARenderGLESSetBounds(uint64_t result, uint64_t a2, double a3, float64x2_t a4)
{
  float64x2_t v4 = *(float64x2_t *)(a2 + 16);
  a4.f64[0] = 0.0;
  int8x16_t v5 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a4, v4).i64[0], 0);
  v6.i64[1] = *(void *)(a2 + 24);
  *(double *)v6.i64 = -v4.f64[0];
  int8x16_t v7 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a4, (float64x2_t)vdupq_laneq_s64((int64x2_t)v4, 1)).i64[0], 0);
  int8x16_t v8 = vbslq_s8(v5, v6, (int8x16_t)v4);
  v9.i64[0] = v8.i64[0];
  v9.i64[1] = *(void *)&vnegq_f64(v4).f64[1];
  float64x2_t v10 = (float64x2_t)vbslq_s8(v7, v9, v8);
  int64x2_t v11 = vceqzq_f64(v10);
  unint64_t v12 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v11, 1), (int8x16_t)v11).u64[0];
  int32x4_t v13 = 0uLL;
  if ((v12 & 0x8000000000000000) == 0)
  {
    int8x16_t v14 = vorrq_s8((int8x16_t)vcltzq_f64(v10), (int8x16_t)vcgezq_f64(v10));
    int8x16_t v15 = vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v14), 1), v14);
    if ((v15.i64[0] & 0x8000000000000000) == 0)
    {
      v15.i64[0] = 0x8000000000000000;
      v16.i64[0] = *(_OWORD *)&vaddq_f64(*(float64x2_t *)a2, (float64x2_t)vbslq_s8(v5, (int8x16_t)v4, v15));
      v17.i64[0] = v16.i64[0];
      v17.i64[1] = *(void *)(a2 + 8);
      v16.i64[1] = *(void *)&vaddq_f64(v4, *(float64x2_t *)a2).f64[1];
      float64x2_t v18 = (float64x2_t)vbslq_s8(v7, v16, v17);
      float64x2_t v19 = vmaxnmq_f64(v18, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000));
      float64x2_t v20 = vminnmq_f64(vaddq_f64(v18, v10), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
      int32x4_t v21 = (int32x4_t)vcvtmq_s64_f64(v19);
      int32x4_t v13 = vuzp1q_s32(v21, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v20), (int64x2_t)v21));
    }
  }
  *(int32x4_t *)(*(void *)result + 200) = v13;
  return result;
}

uint64_t CARenderMTLGetState(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 112))();
}

uint64_t CARenderMTLSetState(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 104))();
}

uint64_t CARenderMTLCompileShader(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 120))();
}

uint64_t CARenderMTLLoadPipeline(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 128))();
}

uint64_t CARenderMTLSetDestinationTextures(void *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t, void))(*(void *)*a1 + 24))(*a1, 1, a2, a3, a4, 0);
}

uint64_t CARenderMTLSetAsyncCompileQueue(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 64))();
}

BOOL CARenderServerSnapshot(mach_port_t a1, NSDictionary *a2)
{
  return CARenderServerSnapshot_(a1, a2) != 0;
}

uint64_t CARenderServerSnapshot_(mach_port_t a1, NSDictionary *a2)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  uint64_t v66 = (void *)MEMORY[0x185324A30]();
  float64x2_t v4 = [(NSDictionary *)a2 objectForKey:@"mode"];
  CFStringRef v5 = [(NSDictionary *)a2 objectForKey:@"displayName"];
  CFStringRef v6 = [(NSDictionary *)a2 objectForKey:@"systemIdentifier"];
  mach_port_t v65 = a1;
  int v7 = v6 != 0;
  if (v6) {
    CFStringRef v8 = v6;
  }
  else {
    CFStringRef v8 = v5;
  }
  id v9 = [(NSDictionary *)a2 objectForKey:@"destination"];
  uint64_t v10 = 0;
  if (!v4) {
    goto LABEL_69;
  }
  if (!v8) {
    goto LABEL_69;
  }
  int64x2_t v11 = v9;
  if (!v9) {
    goto LABEL_69;
  }
  int v64 = objc_msgSend(-[NSDictionary objectForKey:](a2, "objectForKey:", @"originX"), "intValue");
  int v63 = objc_msgSend(-[NSDictionary objectForKey:](a2, "objectForKey:", @"originY"), "intValue");
  if (a2)
  {
    int v12 = objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", @"reuseBackdrops"), "BOOLValue");
    if (objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", @"enforceSecureMode"), "BOOLValue"))v12 |= 2u; {
    if (objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", @"ignoreAccessibility"), "BOOLValue"))v12 |= 4u;
    }
    if (objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", @"ignoreSublayers"), "BOOLValue"))v12 |= 8u; {
    if (objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", @"ignoreLayerFixup"), "BOOLValue"))v12 |= 0x10u;
    }
    if (objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", @"ignoreDisableUpdateMasks"), "BOOLValue"))v12 |= 0x20u; {
    if (objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", @"trackBackdropReuseFailures"), "BOOLValue"))v12 |= 0x40u;
    }
    if (objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", @"bottomLeftOrigin"), "BOOLValue"))v12 |= 0x80u; {
    if (objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", @"selfGenerated"), "BOOLValue"))v12 |= 0x100u;
    }
    if (objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", @"wantsHDR"), "BOOLValue"))v12 |= 0x400u; {
    if (objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", @"ignoreContextualAssistance"), "BOOLValue"))int v13 = v12 | 0x800;
    }
    else {
      int v13 = v12;
    }
  }
  else
  {
    int v13 = 0;
  }
  long long v89 = 0u;
  long long v90 = 0u;
  long long v87 = 0u;
  long long v88 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  id v14 = [(NSDictionary *)a2 objectForKey:@"transform"];
  id v15 = v14;
  if (v14)
  {
    [v14 CATransform3DValue];
    long long v87 = v79;
    long long v88 = v80;
    long long v89 = v81;
    long long v90 = v82;
    long long v83 = v75;
    long long v84 = v76;
    long long v85 = v77;
    long long v86 = v78;
  }
  CFTypeID v16 = CFGetTypeID(v11);
  unint64_t v17 = v13 | (v7 << 12);
  if (v16 == CFNumberGetTypeID())
  {
    if ([(NSDictionary *)a2 valueForKey:@"wantsHDR"]) {
      unint64_t v17 = v17;
    }
    else {
      unint64_t v17 = v17 | 0x400;
    }
  }
  else
  {
    CFTypeID v18 = CFGetTypeID(v11);
    if (v18 == IOSurfaceGetTypeID()
      && objc_msgSend(-[NSDictionary objectForKey:](a2, "objectForKey:", @"wantsHDR"), "BOOLValue"))
    {
      if (IOSurfaceGetPixelFormat((IOSurfaceRef)v11) == 1380411457) {
        unint64_t v17 = v17;
      }
      else {
        unint64_t v17 = v13 & 0xFFFFFBFF | (v7 << 12);
      }
    }
  }
  if (v4 == @"modeDisplay")
  {
    if (v15) {
      uint64_t v22 = &v83;
    }
    else {
      uint64_t v22 = 0;
    }
    LODWORD(v58) = 0;
    goto LABEL_68;
  }
  if (v4 == @"modeLayer")
  {
    int v23 = objc_msgSend(-[NSDictionary objectForKey:](a2, "objectForKey:", @"contextId"), "unsignedIntValue");
    uint64_t v24 = objc_msgSend(-[NSDictionary objectForKey:](a2, "objectForKey:", @"layerId"), "unsignedLongLongValue");
    objc_msgSend(-[NSDictionary objectForKey:](a2, "objectForKey:", @"timeOffset"), "doubleValue");
    double v26 = v25;
    id v27 = [(NSDictionary *)a2 objectForKey:@"transform"];
    if (v27)
    {
      [v27 CATransform3DValue];
      long long v79 = v71;
      long long v80 = v72;
      long long v81 = v73;
      long long v82 = v74;
      long long v75 = v67;
      long long v76 = v68;
      long long v28 = v69;
      long long v29 = v70;
    }
    else
    {
      long long v79 = *(_OWORD *)&CATransform3DIdentity.m31;
      long long v80 = *(_OWORD *)&CATransform3DIdentity.m33;
      long long v81 = *(_OWORD *)&CATransform3DIdentity.m41;
      long long v82 = *(_OWORD *)&CATransform3DIdentity.m43;
      long long v75 = *(_OWORD *)&CATransform3DIdentity.m11;
      long long v76 = *(_OWORD *)&CATransform3DIdentity.m13;
      long long v28 = *(_OWORD *)&CATransform3DIdentity.m21;
      long long v29 = *(_OWORD *)&CATransform3DIdentity.m23;
    }
    long long v77 = v28;
    long long v78 = v29;
    CFTypeID v43 = CFGetTypeID(v11);
    TypeIOSurfaceID ID = IOSurfaceGetTypeID();
    CFTypeID v45 = CFGetTypeID(v11);
    if (v45 == CFNumberGetTypeID())
    {
      uint64_t v21 = CARenderServerCaptureDisplayLayerWithTransformTimeOffsetAndFlags_(v65, v8, v23, v24, [v11 intValue], v64, v63, &v75, v26, v17);
    }
    else
    {
      if (v43 != TypeID) {
        goto LABEL_70;
      }
      uint64_t v21 = CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags_(v65, v8, v23, v24, v11, v64, v63, &v75, v26, v17);
    }
LABEL_68:
    uint64_t v10 = v21;
    goto LABEL_69;
  }
  if (v4 != @"includeContextList")
  {
    if (v4 != @"stopAfterContextList" && v4 != @"excludeContextList")
    {
      if (v4 == @"stopBeforeSlot")
      {
        float64x2_t v19 = (const void *)objc_msgSend(-[NSDictionary objectForKey:](a2, "objectForKey:", @"slotId"), "unsignedLongLongValue");
        if (v15) {
          float64x2_t v20 = &v83;
        }
        else {
          float64x2_t v20 = 0;
        }
        LODWORD(v58) = 3;
        goto LABEL_68;
      }
LABEL_70:
      uint64_t v10 = 0;
      goto LABEL_69;
    }
    v36 = [(NSDictionary *)a2 objectForKey:@"contextList"];
    v37 = v36;
    if (v36)
    {
      uint64_t v38 = [(_anonymous_namespace_ *)v36 count];
      uint64_t v39 = v38;
      size_t v40 = 4 * v38;
      if ((unint64_t)(4 * v38) > 0x1000)
      {
        long long v41 = (NSArray *)malloc_type_malloc(4 * v38, 0x6E707963uLL);
      }
      else
      {
        MEMORY[0x1F4188790](v38);
        long long v41 = (NSArray *)((char *)&v60 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0));
        bzero(v41, v40);
      }
    }
    else
    {
      uint64_t v39 = 0;
      long long v41 = 0;
      size_t v40 = 0;
    }
    if (v4 == @"excludeContextList") {
      int v55 = 2;
    }
    else {
      int v55 = 1;
    }
    if (v15) {
      uint64_t v56 = &v83;
    }
    else {
      uint64_t v56 = 0;
    }
    LODWORD(v58) = v55;
    if (v40 > 0x1000)
    {
      CGAffineTransform v57 = v41;
LABEL_98:
      free(v57);
      goto LABEL_69;
    }
    goto LABEL_69;
  }
  v30 = [(NSDictionary *)a2 objectForKey:@"contextList"];
  v31 = v30;
  if (v30)
  {
    uint64_t v32 = [(_anonymous_namespace_ *)v30 count];
    unint64_t v33 = v32;
    unint64_t v61 = 4 * v32;
    if ((unint64_t)(4 * v32) > 0x1000)
    {
      v35 = (NSArray *)malloc_type_malloc(4 * v32, 0x2D57B2CBuLL);
      CGAffineTransform v62 = v35;
    }
    else
    {
      MEMORY[0x1F4188790](v32);
      CGAffineTransform v62 = (NSArray *)((char *)&v60 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0));
      bzero(v62, v34);
    }
    unint64_t v48 = v33 << 7;
    if (v33 << 7 > 0x1000)
    {
      uint64_t v47 = (NSArray *)malloc_type_malloc(v33 << 7, 0x44D7E79DuLL);
    }
    else
    {
      MEMORY[0x1F4188790](v35);
      uint64_t v47 = (NSArray *)((char *)&v60 - ((v48 + 15) & 0xFFFFFFFFFFFFFFF0));
      bzero(v47, v33 << 7);
    }
  }
  else
  {
    unint64_t v33 = 0;
    unint64_t v61 = 0;
    CGAffineTransform v62 = 0;
    uint64_t v47 = 0;
    unint64_t v48 = 0;
  }
  CFTypeID v50 = CFGetTypeID(v11);
  CFTypeID v51 = IOSurfaceGetTypeID();
  CFTypeID v52 = CFGetTypeID(v11);
  if (v52 == CFNumberGetTypeID())
  {
    int v53 = [v11 intValue];
    uint64_t v54 = _CARenderServerCaptureDisplayContextList(v65, v8, v33, (uint64_t)v62, v53, v64, v63, v33, (uint64_t)v47, v17);
LABEL_82:
    uint64_t v10 = v54;
    goto LABEL_94;
  }
  if (v50 == v51)
  {
    uint64_t v54 = _CARenderServerRenderDisplayContextList(v65, v8, v33, (uint64_t)v62, v11, v64, v63, v33, (uint64_t)v47, v17);
    goto LABEL_82;
  }
  uint64_t v10 = 0;
LABEL_94:
  if (v61 > 0x1000) {
    free(v62);
  }
  if (v48 > 0x1000)
  {
    CGAffineTransform v57 = v47;
    goto LABEL_98;
  }
LABEL_69:
  return v10;
}

void sub_184875F08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::_CARenderServerSnapshotDisplay(_anonymous_namespace_ *this, const __CFString *a2, void *cf, const void *a4, int a5, int a6, long long *a7, const CATransform3D *a8, uint64_t a9, unint64_t a10, unsigned int *a11, unsigned int a12)
{
  int v24 = (int)a8;
  int v12 = (int)a4;
  mach_port_t v15 = this;
  CFTypeID v16 = CFGetTypeID(cf);
  TypeIOSurfaceID ID = IOSurfaceGetTypeID();
  CFTypeID v18 = CFGetTypeID(cf);
  if (v18 == CFNumberGetTypeID())
  {
    int v19 = [cf intValue];
    return CARenderServerCaptureDisplayWithTransform_(v15, a2, v19, v12, a5, a6, a7, v24, a9, a10, (int)a11);
  }
  else if (v16 == TypeID)
  {
    return CARenderServerRenderDisplay_(v15, a2, cf, v12, a5, a6, a7, v24, a9, a10, (int)a11);
  }
  else
  {
    return 0;
  }
}

uint64_t anonymous namespace'::get_context_list_info(_anonymous_namespace_ *this, NSArray *a2, unsigned int *a3, CATransform3D *a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  uint64_t result = [(_anonymous_namespace_ *)this countByEnumeratingWithState:&v28 objects:v27 count:16];
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)v29;
    do
    {
      uint64_t v10 = 0;
      int64x2_t v11 = &a3[32 * v8];
      uint64_t v18 = v8;
      int v12 = (char *)a2 + 4 * v8;
      do
      {
        if (*(void *)v29 != v9) {
          objc_enumerationMutation(this);
        }
        int v13 = *(void **)(*((void *)&v28 + 1) + 8 * v10);
        *(_DWORD *)&v12[4 * v10] = objc_msgSend((id)objc_msgSend(v13, "objectForKey:", @"contextId"), "unsignedIntValue");
        if (a3)
        {
          id v14 = (void *)[v13 objectForKey:@"transform"];
          if (v14)
          {
            [v14 CATransform3DValue];
            *((_OWORD *)v11 + 4) = v23;
            *((_OWORD *)v11 + 5) = v24;
            *((_OWORD *)v11 + 6) = v25;
            *((_OWORD *)v11 + 7) = v26;
            *(_OWORD *)int64x2_t v11 = v19;
            *((_OWORD *)v11 + 1) = v20;
            long long v15 = v21;
            long long v16 = v22;
          }
          else
          {
            *((_OWORD *)v11 + 4) = *(_OWORD *)&CATransform3DIdentity.m31;
            *((_OWORD *)v11 + 5) = *(_OWORD *)&CATransform3DIdentity.m33;
            *((_OWORD *)v11 + 6) = *(_OWORD *)&CATransform3DIdentity.m41;
            *((_OWORD *)v11 + 7) = *(_OWORD *)&CATransform3DIdentity.m43;
            *(_OWORD *)int64x2_t v11 = *(_OWORD *)&CATransform3DIdentity.m11;
            *((_OWORD *)v11 + 1) = *(_OWORD *)&CATransform3DIdentity.m13;
            long long v15 = *(_OWORD *)&CATransform3DIdentity.m21;
            long long v16 = *(_OWORD *)&CATransform3DIdentity.m23;
          }
          *((_OWORD *)v11 + 2) = v15;
          *((_OWORD *)v11 + 3) = v16;
        }
        ++v10;
        v11 += 32;
      }
      while (v7 != v10);
      uint64_t v8 = v18 + v10;
      uint64_t result = [(_anonymous_namespace_ *)this countByEnumeratingWithState:&v28 objects:v27 count:16];
      uint64_t v7 = result;
    }
    while (result);
  }
  return result;
}

uint64_t CARenderServerCreateSnapshots(mach_port_t a1, unint64_t a2, __IOSurface **a3, void *a4)
{
  uint64_t v8 = (void *)MEMORY[0x185324A30]();
  unsigned int v9 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", @"sizeWidth"), "unsignedIntValue");
  int v10 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", @"sizeHeight"), "unsignedIntValue");
  uint64_t v11 = 0;
  if (!v9) {
    goto LABEL_30;
  }
  int v12 = v10;
  if (!v10) {
    goto LABEL_30;
  }
  if (!(a2 | (unint64_t)a3))
  {
    uint64_t v11 = 0;
    goto LABEL_30;
  }
  if (a2) {
    *(void *)a2 = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  if (objc_msgSend((id)objc_msgSend(a4, "objectForKey:", @"formatWideGamut"), "BOOLValue"))
  {
    if (objc_msgSend((id)objc_msgSend(a4, "objectForKey:", @"formatOpaque"), "BOOLValue")) {
      uint64_t v13 = 1999843442;
    }
    else {
      uint64_t v13 = 1647534392;
    }
  }
  else
  {
    uint64_t v13 = 1111970369;
  }
  unsigned int v14 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", @"mapCacheAttribute"), "unsignedIntValue");
  unsigned int v16 = v14;
  if (v14)
  {
    if (v14 == 1) {
      int v17 = 32;
    }
    else {
      int v17 = 0;
    }
    if (v14 == 2) {
      unsigned int v16 = v17 | 0x10;
    }
    else {
      unsigned int v16 = v17;
    }
  }
  if (!a2)
  {
LABEL_29:
    uint64_t v11 = 1;
    goto LABEL_30;
  }
  unsigned int v26 = v13;
  iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v13, v9, v12, v16, 0, @"CA Snapshot (Unprotected)", v15);
  if (!iosurface_with_pixel_format)
  {
    *(void *)a2 = 0;
    goto LABEL_29;
  }
  long long v19 = iosurface_with_pixel_format;
  mach_port_t v27 = a1;
  long long v20 = (NSDictionary *)[a4 mutableCopy];
  [(NSDictionary *)v20 setObject:v19 forKey:@"destination"];
  uint64_t v21 = CARenderServerSnapshot_(a1, v20);

  *(void *)a2 = v19;
  uint64_t v11 = 1;
  if (a3 && (v21 & 0x7FFFFFFFFFFFFFFFLL) != 0)
  {
    long long v23 = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v26, v9, v12, v16 | 2, v21 & 0x7FFFFFFFFFFFFFFFLL, @"CA Snapshot (Protected)", v22);
    if (v23)
    {
      long long v24 = (NSDictionary *)[a4 mutableCopy];
      [(NSDictionary *)v24 setObject:v23 forKey:@"destination"];
      CARenderServerSnapshot_(v27, v24);
    }
    *a3 = v23;
  }
LABEL_30:
  return v11;
}

void sub_184876480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CARenderServerDumpVMRegions(void)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v0 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_184668000, v0, OS_LOG_TYPE_ERROR, "Dumping VM regions!", buf, 2u);
    }
  }
  uint64_t v1 = VMUGetFlagsForAllVMRegionStatistics() | 0x90181;
  uint64_t v2 = (void *)[objc_alloc(MEMORY[0x1E4FA8AC0]) initWithTask:*MEMORY[0x1E4F14960] options:v1];
  long long v38 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v29 = v2;
  uint64_t v3 = (void *)[v2 regions];
  uint64_t v4 = [v3 countByEnumeratingWithState:&v38 objects:v37 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v39;
    uint64_t v7 = (void *)MEMORY[0x1E4FA8AE0];
    uint64_t v8 = (int *)MEMORY[0x1E4FA8AD0];
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v39 != v6) {
          objc_enumerationMutation(v3);
        }
        int v10 = *(char **)(*((void *)&v38 + 1) + 8 * i);
        if ((objc_msgSend(v10, "isSubmap", v28) & 1) == 0
          && (objc_msgSend((id)objc_msgSend(v10, "type"), "hasPrefix:", *v7) & 1) == 0)
        {
          uint64_t v11 = &v10[*v8];
          unint64_t v12 = *(void *)v11;
          unint64_t v13 = *((void *)v11 + 1) + *(void *)v11;
          BOOL v14 = v12 >> 31 < 3 || v13 > 0x300000000;
          if (v14 || *(void *)&v10[*MEMORY[0x1E4FA8AC8]] + *(void *)&v10[*MEMORY[0x1E4FA8AD8]])
          {
            CFStringRef v15 = (void *)[v10 descriptionWithOptions:v1 maximumLength:0];
            if (x_log_hook_p())
            {
              uint64_t v28 = [v15 UTF8String];
              x_log_();
            }
            else
            {
              unsigned int v16 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
              {
                uint64_t v17 = [v15 UTF8String];
                *(_DWORD *)buf = 136315138;
                uint64_t v36 = v17;
                _os_log_impl(&dword_184668000, v16, OS_LOG_TYPE_ERROR, "%s", buf, 0xCu);
              }
            }
          }
        }
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v38 objects:v37 count:16];
    }
    while (v5);
  }
  uint64_t v18 = objc_msgSend((id)objc_msgSend(v29, "descriptionForRegionTotals:", v1, v28), "componentsSeparatedByString:", @"\n");
  if (x_log_hook_p())
  {
    x_log_();
    long long v19 = &CA::callback_timer;
  }
  else
  {
    long long v19 = &CA::callback_timer;
    long long v20 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_184668000, v20, OS_LOG_TYPE_ERROR, "SUMMARY:\n", buf, 2u);
    }
  }
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  uint64_t v21 = [v18 countByEnumeratingWithState:&v31 objects:v30 count:16];
  if (v21)
  {
    uint64_t v22 = v21;
    uint64_t v23 = *(void *)v32;
    do
    {
      for (uint64_t j = 0; j != v22; ++j)
      {
        if (*(void *)v32 != v23) {
          objc_enumerationMutation(v18);
        }
        long long v25 = *(void **)(*((void *)&v31 + 1) + 8 * j);
        if (x_log_hook_p())
        {
          [v25 UTF8String];
          x_log_();
        }
        else
        {
          unsigned int v26 = v19[100];
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            uint64_t v27 = [v25 UTF8String];
            *(_DWORD *)buf = 136315138;
            uint64_t v36 = v27;
            _os_log_impl(&dword_184668000, v26, OS_LOG_TYPE_ERROR, "%s\n", buf, 0xCu);
          }
        }
      }
      uint64_t v22 = [v18 countByEnumeratingWithState:&v31 objects:v30 count:16];
    }
    while (v22);
  }
}

uint64_t CA::WindowServer::Surface::lock(CA::WindowServer::Surface *this, unsigned __int8 **a2, unint64_t *a3)
{
  return 0;
}

void CA::WindowServer::SharedEvent::~SharedEvent(CA::WindowServer::SharedEvent *this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (BYTE6(xmmword_1EB2ACC70))
  {
    if (x_log_hook_p())
    {
      uint64_t v5 = (__IOSurface *)(*(uint64_t (**)(void))(**(void **)this + 160))();
      IOSurfaceGetID(v5);
      x_log_();
    }
    else
    {
      uint64_t v6 = x_log_category_sharedevent;
      if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v7 = (__IOSurface *)(*(uint64_t (**)(void))(**(void **)this + 160))();
        *(_DWORD *)buf = 67109120;
        IOSurfaceID ID = IOSurfaceGetID(v7);
        _os_log_impl(&dword_184668000, v6, OS_LOG_TYPE_DEBUG, "IOSurfaceID: 0x%x  Dealloc", buf, 8u);
      }
    }
  }
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2) {

  }
  *((void *)this + 1) = 0;
  uint64_t v3 = (void *)*((void *)this + 3);
  if (v3) {

  }
  *((void *)this + 3) = 0;
  uint64_t v4 = *((void *)this + 8);
  if (v4) {
    MEMORY[0x185323DC0](v4, 0x1000C4055D675C7);
  }
}

BOOL CA::WindowServer::SharedEvent::is_complete_with_timeout(CA::WindowServer::SharedEvent *this)
{
  uint64_t v2 = (void *)*((void *)this + 1);
  if (!v2) {
    return 1;
  }
  uint64_t v3 = [v2 signaledValue];
  uint64_t v4 = v3;
  uint64_t v5 = *((void *)this + 2);
  if (v3 != v5)
  {
    if (*((void *)this + 6) != v3)
    {
      *((void *)this + 6) = v3;
      goto LABEL_8;
    }
    uint64_t v6 = mach_continuous_time();
    if (CATimeWithHostTime(v6 - *((void *)this + 7)) > 10.0)
    {
      CA::WindowServer::SharedEvent::force_complete(this, 1);
      uint64_t v4 = [*((id *)this + 1) signaledValue];
      *((void *)this + 6) = v4;
LABEL_8:
      *((void *)this + 7) = mach_continuous_time();
    }
  }
  return v4 == v5;
}

void *CA::WindowServer::SharedEvent::force_complete(CA::WindowServer::SharedEvent *this, int a2)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t result = (void *)*((void *)this + 1);
  if (result)
  {
    uint64_t result = (void *)[result signaledValue];
    if (result != *((void **)this + 2))
    {
      unint64_t v5 = [*((id *)this + 1) signaledValue];
      uint64_t v6 = (char *)*((void *)this + 2);
      memset(v49, 0, sizeof(v49));
      if (x_log_hook_p())
      {
        if (a2) {
          uint64_t v7 = "True";
        }
        else {
          uint64_t v7 = "False";
        }
        CString = CA_CFStringGetCString(*(const __CFString **)(*(void *)this + 232), (char *)v49, 128);
        unsigned int v9 = (__IOSurface *)(*(uint64_t (**)(void))(**(void **)this + 160))();
        CFTypeID v43 = (char *)v5;
        v44 = v6;
        long long v41 = CString;
        IOSurfaceID ID = (char *)IOSurfaceGetID(v9);
        long long v40 = (char *)v7;
        x_log_();
      }
      else
      {
        uint64_t v10 = x_log_category_sharedevent;
        if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEFAULT))
        {
          if (a2) {
            uint64_t v11 = "True";
          }
          else {
            uint64_t v11 = "False";
          }
          unint64_t v12 = CA_CFStringGetCString(*(const __CFString **)(*(void *)this + 232), (char *)v49, 128);
          unint64_t v13 = (__IOSurface *)(*(uint64_t (**)(void))(**(void **)this + 160))();
          IOSurfaceID v14 = IOSurfaceGetID(v13);
          *(_DWORD *)buf = 136316162;
          *(void *)&uint8_t buf[4] = v11;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = v12;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v51) = v14;
          WORD2(v51) = 2048;
          *(void *)((char *)&v51 + 6) = v5;
          HIWORD(v51) = 2048;
          CFTypeID v52 = v6;
          _os_log_impl(&dword_184668000, v10, OS_LOG_TYPE_DEFAULT, "force_complete () force_immediately: %s  IOSurfaceName: %s  IOSurfaceID: 0x%x  Value Completed: 0x%llx  Last Value Requested: 0x%llx", buf, 0x30u);
        }
      }
      if (a2)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          CFStringRef v15 = x_log_category_sharedevent;
          if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_184668000, v15, OS_LOG_TYPE_ERROR, "shared event signal not complete and forcing immediate\n", buf, 2u);
          }
        }
      }
      unsigned int v16 = (int *)*((void *)this + 8);
      if (v16)
      {
        char v46 = a2;
        memset(buf, 0, sizeof(buf));
        if (*v16 <= 0x40) {
          LOBYTE(v17) = 64;
        }
        else {
          int v17 = *v16;
        }
        if (*v16 >= 0x40) {
          int v18 = 64;
        }
        else {
          int v18 = *v16;
        }
        if (v18)
        {
          int v19 = 0;
          uint64_t v20 = *(void *)this;
          do
          {
            uint64_t v21 = &v16[8 * (v17 & 0x3F)];
            unint64_t v22 = *((void *)v21 + 4);
            v19 |= v22 == v5;
            if (v19)
            {
              BOOL v23 = v22 >= v5;
              BOOL v24 = v22 == v5;
              long long v25 = "Not Completed";
              if (!v23) {
                long long v25 = "Completed";
              }
              if (v24) {
                unsigned int v26 = "Last Completed";
              }
              else {
                unsigned int v26 = v25;
              }
              uint64_t v27 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(void *)v20 + 160))(v20);
              uint64_t v28 = (const char *)IOSurfaceGetID(v27);
              v44 = CA::WindowServer::SharedEvent::AccessString[v21[6]];
              uint64_t v45 = *((void *)v21 + 4);
              IOSurfaceID ID = CA::WindowServer::SharedEvent::UsageString[v21[4]];
              CFTypeID v43 = CA::WindowServer::SharedEvent::OperationString[v21[5]];
              long long v41 = v28;
              x_stream_printf((uint64_t)buf, "%s IOSurfaceID: 0x%x  usage: %s  operation: %s  access: %s  value: 0x%llx\n", v29, v30, v31, v32, v33, v34, (uint64_t)v26);
            }
            LOBYTE(v17) = v17 + 1;
            --v18;
          }
          while (v18);
        }
        if (x_log_hook_p())
        {
          long long v40 = x_stream_get(buf);
          x_log_();
          LOBYTE(a2) = v46;
        }
        else
        {
          v35 = x_log_category_sharedevent;
          LOBYTE(a2) = v46;
          if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v47 = 136315138;
            unint64_t v48 = x_stream_get(buf);
            _os_log_impl(&dword_184668000, v35, OS_LOG_TYPE_DEFAULT, "%s\n", v47, 0xCu);
          }
        }
        if (*(void *)buf) {
          free(*(void **)buf);
        }
      }
      unint64_t v36 = v5 + 1;
      if (a2) {
        return objc_msgSend(*((id *)this + 1), "setSignaledValue:", v36, v40, v41, ID, v43, v44, v45);
      }
      unint64_t v37 = *((void *)this + 2);
      if (v36 >= v37)
      {
        return objc_msgSend(*((id *)this + 1), "setSignaledValue:", v36, v40, v41, ID, v43, v44, v45);
      }
      else
      {
        long long v38 = (void *)*((void *)this + 1);
        uint64_t v39 = *((void *)this + 3);
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 3221225472;
        *(void *)&buf[16] = ___ZN2CA11SurfaceUtil43CASurfaceAsyncWaitAndSignalSharedEventValueEPNS0_24CASurfaceSharedEventRef_EPNS0_29CASurfaceSharedEventListener_Eyy_block_invoke;
        *(void *)&long long v51 = &__block_descriptor_48_e33_v24__0__IOSurfaceSharedEvent_8Q16l;
        *((void *)&v51 + 1) = v37 - 1;
        CFTypeID v52 = (char *)v37;
        return objc_msgSend(v38, "notifyListener:atValue:block:", v39);
      }
    }
  }
  return result;
}

uint64_t CA::WindowServer::SharedEvent::get_wait_value(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = 16;
  if (a3 == 1) {
    uint64_t v3 = 40;
  }
  uint64_t v4 = *(void *)(a1 + v3);
  if (*(void *)(a1 + 64)) {
    CA::WindowServer::SharedEvent::History::add(*(_DWORD **)(a1 + 64), *(void *)a1, a2, 1, a3, v4);
  }
  return v4;
}

_DWORD *CA::WindowServer::SharedEvent::History::add(_DWORD *result, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (a3 != 1)
  {
    uint64_t v11 = result;
    if (initialized != -1) {
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    }
    if (BYTE6(xmmword_1EB2ACC70))
    {
      if (x_log_hook_p())
      {
        unsigned int v16 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 160))(a2);
        IOSurfaceGetID(v16);
        x_log_();
      }
      else
      {
        int v17 = x_log_category_sharedevent;
        if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_INFO))
        {
          int v18 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 160))(a2);
          IOSurfaceID ID = IOSurfaceGetID(v18);
          uint64_t v20 = CA::WindowServer::SharedEvent::UsageString[a3];
          uint64_t v21 = CA::WindowServer::SharedEvent::OperationString[a4];
          unint64_t v22 = CA::WindowServer::SharedEvent::AccessString[a5];
          *(_DWORD *)buf = 67110146;
          IOSurfaceID v24 = ID;
          __int16 v25 = 2080;
          unsigned int v26 = v20;
          __int16 v27 = 2080;
          uint64_t v28 = v21;
          __int16 v29 = 2080;
          uint64_t v30 = v22;
          __int16 v31 = 2048;
          uint64_t v32 = a6;
          _os_log_impl(&dword_184668000, v17, OS_LOG_TYPE_INFO, "IOSurfaceID: 0x%x  usage: %s  operation: %s  access: %s  value: %#llx", buf, 0x30u);
        }
      }
    }
    uint64_t v12 = *v11 & 0x3FLL;
    uint64_t v13 = mach_continuous_time();
    IOSurfaceID v14 = &v11[8 * v12];
    *((void *)v14 + 1) = v13;
    v14[4] = a3;
    v14[5] = a4;
    v14[6] = a5;
    *((void *)v14 + 4) = a6;
    ++*v11;
    CFStringRef v15 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 160))(a2);
    return (_DWORD *)IOSurfaceGetID(v15);
  }
  return result;
}

uint64_t CA::WindowServer::SharedEvent::inc_signal_value(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 16) + 1;
  *(void *)(a1 + 16) = v3;
  if ((a2 - 8) > 5)
  {
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v4 = v3;
    if (*(void *)(a1 + 32)) {
      goto LABEL_6;
    }
  }
  *(void *)(a1 + 32) = v4;
LABEL_6:
  if (a3 == 2) {
    *(void *)(a1 + 40) = v3;
  }
  if (*(void *)(a1 + 64)) {
    CA::WindowServer::SharedEvent::History::add(*(_DWORD **)(a1 + 64), *(void *)a1, a2, 2, a3, v3);
  }
  return v3;
}

uint64_t CA::WindowServer::Surface::bits_per_pixel(CA::WindowServer::Surface *this)
{
  if ((int)this > 1534354995)
  {
    if ((int)this <= 1886680623)
    {
      if ((int)this > 1647534391)
      {
        if ((int)this > 1885745711)
        {
          if ((int)this <= 1886676527)
          {
            if (this != 1885745712)
            {
              if (this != 1885745714)
              {
                int v2 = 1885746228;
                goto LABEL_121;
              }
              return 22;
            }
            return 16;
          }
          if (this == 1886676528) {
            return 20;
          }
          if (this == 1886676530) {
            return 26;
          }
          if (this != 1886676532) {
            return 0;
          }
          return 39;
        }
        if ((int)this > 1882468911)
        {
          if (this != 1882468912)
          {
            if (this != 1882468914)
            {
              int v2 = 1882469428;
              goto LABEL_121;
            }
            return 22;
          }
          return 16;
        }
        if (this == 1647534392) {
          return 40;
        }
        int v2 = 1815162994;
        goto LABEL_121;
      }
      if ((int)this <= 1534617137)
      {
        if ((int)this <= 1534359089)
        {
          if (this != 1534354996)
          {
            int v6 = 1534359088;
            goto LABEL_134;
          }
        }
        else
        {
          if (this == 1534359090) {
            return 32;
          }
          if (this != 1534359092)
          {
            int v6 = 1534617136;
            goto LABEL_134;
          }
        }
        return 48;
      }
      if ((int)this <= 1534621231)
      {
        if (this == 1534617138) {
          return 32;
        }
        unsigned __int16 v9 = 26164;
      }
      else
      {
        if (this == 1534621232) {
          return 24;
        }
        if (this == 1534621234) {
          return 32;
        }
        unsigned __int16 v9 = 30260;
      }
      int v4 = v9 | 0x5B780000;
LABEL_126:
      if (this != v4) {
        return 0;
      }
      return 48;
    }
    if ((int)this <= 1999908960)
    {
      if ((int)this <= 1952855091)
      {
        if ((int)this <= 1886680627)
        {
          if (this != 1886680624)
          {
            int v10 = 1886680626;
            goto LABEL_109;
          }
          return 20;
        }
        if (this == 1886680628) {
          return 39;
        }
        if (this != 1952854576)
        {
          int v2 = 1952854578;
          goto LABEL_121;
        }
        return 24;
      }
      if ((int)this <= 1953903153)
      {
        if (this != 1952855092)
        {
          int v6 = 1953903152;
          goto LABEL_134;
        }
      }
      else
      {
        if (this == 1953903154) {
          return 32;
        }
        if (this != 1953903668)
        {
          int v2 = 1999843442;
          goto LABEL_121;
        }
      }
    }
    else
    {
      if ((int)this > 2019963439)
      {
        if ((int)this > 2019964015)
        {
          if (this == 2019964016) {
            return 32;
          }
          if (this == 2037741171) {
            return 16;
          }
          int v8 = 2037741158;
          goto LABEL_130;
        }
        if (this == 2019963440) {
          return 24;
        }
        if (this == 2019963442) {
          return 32;
        }
        int v4 = 2019963956;
        goto LABEL_126;
      }
      if ((int)this <= 2016686641)
      {
        if (this == 1999908961) {
          return 64;
        }
        int v6 = 2016686640;
        goto LABEL_134;
      }
      if (this == 2016686642) {
        return 32;
      }
      if (this != 2016687156)
      {
        int v2 = 2016687216;
        goto LABEL_121;
      }
    }
    return 48;
  }
  uint64_t v1 = 12;
  if ((int)this > 645428783)
  {
    if ((int)this > 1111970368)
    {
      if ((int)this <= 1530422835)
      {
        if ((int)this <= 1380411456)
        {
          if (this == 1111970369) {
            return 32;
          }
          int v8 = 1278555701;
LABEL_130:
          if (this != v8) {
            return 0;
          }
          return 16;
        }
        if (this == 1380411457) {
          return 64;
        }
        if (this == 1530422832) {
          return v1;
        }
        unsigned __int16 v3 = 26162;
      }
      else
      {
        if ((int)this > 1530426931)
        {
          if (this == 1530426932 || this == 1534354992) {
            return 24;
          }
          int v2 = 1534354994;
          goto LABEL_121;
        }
        if (this == 1530422836) {
          return 24;
        }
        if (this == 1530426928) {
          return v1;
        }
        unsigned __int16 v3 = 30258;
      }
      int v8 = v3 | 0x5B380000;
      goto LABEL_130;
    }
    if ((int)this <= 875704933)
    {
      if ((int)this <= 645428787)
      {
        if (this != 645428784)
        {
          if (this != 645428786) {
            return 0;
          }
          return 22;
        }
        return 16;
      }
      if (this == 645428788) {
        return 32;
      }
      if (this != 875704422 && this != 875704438) {
        return 0;
      }
      return v1;
    }
    if ((int)this <= 875836467)
    {
      if (this == 875704934) {
        return 16;
      }
      int v8 = 875704950;
      goto LABEL_130;
    }
    if (this == 875836468) {
      return 16;
    }
    if (this == 875836518) {
      return 24;
    }
    int v6 = 875836534;
LABEL_134:
    if (this != v6) {
      return 0;
    }
    return 24;
  }
  if ((int)this > 645162543)
  {
    if ((int)this > 645166643)
    {
      if ((int)this <= 645424687)
      {
        if (this != 645166644)
        {
          if (this != 645346162)
          {
            if (this != 645346401) {
              return 0;
            }
            return 64;
          }
          return 32;
        }
        return 39;
      }
      if (this != 645424688)
      {
        if (this != 645424690)
        {
          int v2 = 645424692;
          goto LABEL_121;
        }
        return 22;
      }
      return 16;
    }
    if ((int)this <= 645162547)
    {
      if (this != 645162544)
      {
        unsigned __int16 v7 = 26162;
        goto LABEL_108;
      }
      return 20;
    }
    if (this != 645162548)
    {
      if (this != 645166640)
      {
        unsigned __int16 v7 = 30258;
LABEL_108:
        int v10 = v7 | 0x26740000;
LABEL_109:
        if (this != v10) {
          return 0;
        }
        return 26;
      }
      return 20;
    }
    return 39;
  }
  if ((int)this > 641234483)
  {
    if ((int)this > 642934848)
    {
      if (this != 642934849)
      {
        if (this != 643969848)
        {
          int v2 = 644624754;
          goto LABEL_121;
        }
        return 40;
      }
      return 64;
    }
    if (this == 641234484) {
      return 24;
    }
    int v2 = 641877825;
LABEL_121:
    if (this == v2) {
      return 32;
    }
    return 0;
  }
  if ((int)this <= 641230387)
  {
    if (this == 641230384) {
      return v1;
    }
    unsigned __int16 v5 = 26162;
    goto LABEL_98;
  }
  if (this == 641230388) {
    return 24;
  }
  if (this != 641234480)
  {
    unsigned __int16 v5 = 30258;
LABEL_98:
    int v8 = v5 | 0x26380000;
    goto LABEL_130;
  }
  return v1;
}

uint64_t ___ZN2CA12WindowServer19accelerator_runloopEv_block_invoke()
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  memset(&v4, 0, sizeof(v4));
  pthread_mutex_init(&v4, 0);
  memset(&v3, 0, sizeof(v3));
  pthread_cond_init(&v3, 0);
  v2[0] = &v4;
  v2[1] = &v3;
  v0 = x_thread_create((uint64_t)_ZZZN2CA12WindowServer19accelerator_runloopEvEUb_EN3__08__invokeEPv, (uint64_t)v2, 0);
  CA::Render::Server::set_thread_priority(v0, (_opaque_pthread_t *)0xFFFFFFFFLL);
  pthread_mutex_lock(&v4);
  while (!CA::WindowServer::accelerator_runloop(void)::runloop)
    pthread_cond_wait(&v3, &v4);
  pthread_mutex_unlock(&v4);
  pthread_cond_destroy(&v3);
  return pthread_mutex_destroy(&v4);
}

void _ZZZN2CA12WindowServer19accelerator_runloopEvEUb_EN3__08__invokeEPv(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v2 = pthread_setname_np("com.apple.coreanimation.msr_runloop");
  if (v2)
  {
    int v3 = v2;
    pthread_mutex_t v4 = x_log_category_utilities;
    if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
    {
      int v7 = 136315394;
      int v8 = "com.apple.coreanimation.msr_runloop";
      __int16 v9 = 1024;
      int v10 = v3;
      _os_log_error_impl(&dword_184668000, v4, OS_LOG_TYPE_ERROR, "pthread_setname_np(%s) returned %d\n", (uint8_t *)&v7, 0x12u);
    }
  }
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  CA::WindowServer::accelerator_runloop(void)::runloop = (uint64_t)CFRunLoopGetCurrent();
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  int v6 = CFRunLoopTimerCreate(0, Current + 3153600000.0, 3153600000.0, 0, 0, (CFRunLoopTimerCallBack)_ZZZZN2CA12WindowServer19accelerator_runloopEvEUb_ENK3__0clEPvENUlP16__CFRunLoopTimerS2_E_8__invokeES4_S2_, 0);
  CFRunLoopAddTimer((CFRunLoopRef)CA::WindowServer::accelerator_runloop(void)::runloop, v6, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
  pthread_cond_signal(*(pthread_cond_t **)(a1 + 8));
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  CFRunLoopRun();
}

void sub_184877ED4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::OGL::SWContext::sw_renderer_p(CA::OGL::SWContext *this)
{
  return 1;
}

uint64_t CA::OGL::SWContext::set_destination(CA::OGL::SWContext *this, char *a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, int a7, int a8, int a9, int a10)
{
  if (a2)
  {
    if (*((_DWORD *)this + 108)) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = (a10 - 1) * a3;
    }
    uint64_t v11 = &a2[v10];
    if (*((_DWORD *)this + 108)) {
      uint64_t v12 = a3;
    }
    else {
      uint64_t v12 = -a3;
    }
    unint64_t v13 = (unint64_t)(a4 + 7) >> 3;
  }
  else
  {
    LODWORD(v13) = 0;
    LODWORD(a4) = 0;
    uint64_t v12 = 0;
    uint64_t v11 = 0;
  }
  *((void *)this + 240) = v11;
  *((void *)this + 242) = v12;
  *((_DWORD *)this + 488) = a4;
  *((_DWORD *)this + 489) = v13;
  if (a5)
  {
    if (a5 == a2)
    {
      *((void *)this + 241) = v11;
      a6 = v12;
      a5 = v11;
    }
    else if (*((unsigned char *)this + 432))
    {
      *((void *)this + 241) = a5;
    }
    else
    {
      a5 += (a10 - 1) * a6;
      *((void *)this + 241) = a5;
      a6 = -a6;
    }
  }
  else
  {
    a6 = 0;
    *((void *)this + 241) = 0;
  }
  *((void *)this + 243) = a6;
  *((_DWORD *)this + 490) = a7;
  *((_DWORD *)this + 491) = a8;
  *((_DWORD *)this + 492) = a9;
  *((_DWORD *)this + 493) = a10;
  *((void *)this + 233) = v11;
  *((void *)this + 234) = a5;
  *((void *)this + 235) = v12;
  *((void *)this + 236) = a6;
  *((_DWORD *)this + 474) = a4;
  *((_DWORD *)this + 475) = v13;
  *((_DWORD *)this + 476) = a7;
  *((_DWORD *)this + 478) = a8;
  *((_DWORD *)this + 477) = a9 + a7;
  *((_DWORD *)this + 479) = a10 + a8;
  return 1;
}

float CA::OGL::SWContext::function_uniform(CA::OGL::SWContext *this, unsigned int a2, uint64_t a3, uint64_t a4, float *a5)
{
  int v5 = *(unsigned __int8 *)(*((void *)this + 2) + 16);
  switch(*(unsigned char *)(*((void *)this + 2) + 16))
  {
    case '/':
      goto LABEL_16;
    case '0':
    case '1':
      if (a2 <= 1 && a3 == 4 && a4 == 1 || a2 == 2 && a3 == 1 && a4 == 1)
      {
        int v6 = (float *)((char *)this + 16 * a2 + 1984);
        do
        {
          float v7 = *a5++;
          float result = v7;
          *v6++ = v7;
          --a3;
        }
        while (a3);
      }
      break;
    case '2':
    case '3':
    case '5':
    case '6':
      return result;
    case '4':
      uint64_t v11 = a4 * a3;
      if (a4 * a3)
      {
        uint64_t v12 = (float *)((char *)this + 1984);
        do
        {
          float v13 = *a5++;
          float result = v13;
          *v12++ = v13;
          --v11;
        }
        while (v11);
      }
      break;
    case '7':
      if (a3)
      {
        IOSurfaceID v14 = (float *)((char *)this + 16 * a2 + 1984);
        do
        {
          float v15 = *a5++;
          float result = v15;
          *v14++ = v15;
          --a3;
        }
        while (a3);
      }
      break;
    default:
      if (v5 == 20 || v5 == 24)
      {
LABEL_16:
        if (a3 == 4 && a4 == 5)
        {
          for (uint64_t i = 0; i != 20; ++i)
          {
            float result = a5[i];
            *(float *)((char *)this + i * 4 + 1984) = result;
          }
        }
      }
      break;
  }
  return result;
}

uint64_t CA::OGL::SWContext::function_supported(CA::OGL::SWContext *this)
{
  uint64_t v1 = *((void *)this + 2);
  unsigned int v2 = *(unsigned __int8 *)(v1 + 16);
  BOOL v3 = v2 > 0x37;
  uint64_t v4 = (1 << v2) & 0xBF80000213BFEBLL;
  if (!v3 && v4 != 0)
  {
    uint64_t result = 0;
    uint64_t v7 = v1 + 17;
    uint64_t v8 = v1 + 19;
    for (char i = 1; ; char i = 0)
    {
      char v10 = i;
      unsigned int v11 = *(unsigned __int8 *)(v7 + result);
      BOOL v3 = v11 > 0x26;
      uint64_t v12 = (1 << v11) & 0x4000200003;
      if (v3 || v12 == 0) {
        break;
      }
      unsigned int v14 = *(unsigned __int8 *)(v8 + result);
      BOOL v3 = v14 > 5;
      int v15 = (1 << v14) & 0x2B;
      if (v3 || v15 == 0) {
        break;
      }
      uint64_t result = 1;
      if ((v10 & 1) == 0) {
        return result;
      }
    }
  }
  return 0;
}

BOOL CA::OGL::SWContext::make_buffer_current(CA::OGL::SWContext *this, CA::WindowServer::Surface *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  BOOL v3 = (CA::WindowServer::Surface *)*((void *)this + 247);
  if (v3 == a2) {
    return 1;
  }
  uint64_t v23 = 0;
  IOSurfaceID v24 = 0;
  if (v3)
  {
    (*(void (**)(CA::WindowServer::Surface *))(*(void *)v3 + 144))(v3);
    *((void *)this + 247) = 0;
  }
  if (!a2
    || !(*(unsigned int (**)(CA::WindowServer::Surface *, char **, uint64_t *))(*(void *)a2 + 136))(a2, &v24, &v23))
  {
    return 1;
  }
  int v5 = *((_DWORD *)a2 + 16);
  if (v5 <= 1278226487)
  {
    if (v5 == 1093677112) {
      return 0;
    }
    if (v5 == 1111970369)
    {
      uint64_t v7 = v23;
      int v6 = v24;
      uint64_t v8 = 32;
      goto LABEL_16;
    }
  }
  else
  {
    switch(v5)
    {
      case 1278226488:
        int v6 = 0;
        uint64_t v7 = 0;
        uint64_t v8 = 8;
        goto LABEL_16;
      case 1278555445:
        int v6 = 0;
        uint64_t v7 = 0;
        uint64_t v8 = 15;
        goto LABEL_16;
      case 1278555701:
        int v6 = 0;
        uint64_t v7 = 0;
        uint64_t v8 = 16;
LABEL_16:
        CA::OGL::SWContext::set_destination(this, v24, v23, v8, v6, v7, *((_DWORD *)this + 50), *((_DWORD *)this + 51), *((_DWORD *)this + 52), *((_DWORD *)this + 53));
        *((void *)this + 247) = a2;
        return 1;
    }
  }
  if (x_log_hook_p())
  {
    int v10 = *((_DWORD *)a2 + 16);
    if (v10 < 0)
    {
      __maskrune(HIBYTE(*((_DWORD *)a2 + 16)), 0x40000uLL);
      int v10 = *((_DWORD *)a2 + 16);
    }
    if (BYTE2(v10) > 0x7Fu)
    {
      __maskrune(BYTE2(v10), 0x40000uLL);
      int v10 = *((_DWORD *)a2 + 16);
    }
    if (BYTE1(v10) > 0x7Fu)
    {
      __maskrune(BYTE1(v10), 0x40000uLL);
      int v10 = *((_DWORD *)a2 + 16);
    }
    if (v10 > 0x7Fu) {
      __maskrune(v10, 0x40000uLL);
    }
    x_log_();
    return 0;
  }
  unsigned int v11 = x_log_category_ogl;
  BOOL result = os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR);
  if (result)
  {
    unint64_t v12 = *((unsigned int *)a2 + 16);
    unint64_t v13 = v12 >> 24;
    uint64_t v14 = MEMORY[0x1E4F14390];
    if ((v12 & 0x80000000) != 0)
    {
      int v15 = __maskrune(v13, 0x40000uLL);
      LODWORD(v12) = *((_DWORD *)a2 + 16);
    }
    else
    {
      int v15 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v13 + 60) & 0x40000;
    }
    if (v15) {
      int v16 = (int)v12 >> 24;
    }
    else {
      int v16 = 32;
    }
    if (BYTE2(v12) <= 0x7Fu)
    {
      int v17 = *(_DWORD *)(v14 + 4 * BYTE2(v12) + 60) & 0x40000;
    }
    else
    {
      int v17 = __maskrune(BYTE2(v12), 0x40000uLL);
      LODWORD(v12) = *((_DWORD *)a2 + 16);
    }
    if (v17) {
      int v18 = (int)(v12 << 8) >> 24;
    }
    else {
      int v18 = 32;
    }
    if (BYTE1(v12) <= 0x7Fu)
    {
      int v19 = *(_DWORD *)(v14 + 4 * BYTE1(v12) + 60) & 0x40000;
    }
    else
    {
      int v19 = __maskrune(BYTE1(v12), 0x40000uLL);
      LODWORD(v12) = *((_DWORD *)a2 + 16);
    }
    if (v19) {
      int v20 = (__int16)v12 >> 8;
    }
    else {
      int v20 = 32;
    }
    if (v12 <= 0x7Fu) {
      int v21 = *(_DWORD *)(v14 + 4 * v12 + 60) & 0x40000;
    }
    else {
      int v21 = __maskrune(v12, 0x40000uLL);
    }
    if (v21) {
      int v22 = *((char *)a2 + 64);
    }
    else {
      int v22 = 32;
    }
    *(_DWORD *)buf = 67109888;
    int v26 = v16;
    __int16 v27 = 1024;
    int v28 = v18;
    __int16 v29 = 1024;
    int v30 = v20;
    __int16 v31 = 1024;
    int v32 = v22;
    _os_log_impl(&dword_184668000, v11, OS_LOG_TYPE_ERROR, "SW renderer invalid destination format %c%c%c%c", buf, 0x1Au);
    return 0;
  }
  return result;
}

uint64_t CA::OGL::SWContext::clear_region(uint64_t a1, uint64_t a2, CA::OGL::ExtendedColor *a3)
{
  _OWORD v21[3] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 272);
  if (v6 != *(void *)(a1 + 264)) {
    goto LABEL_2;
  }
  if (v6) {
    LODWORD(v6) = (*(unsigned __int8 *)(v6 + 72) >> 1) & 0x1F;
  }
  if (*(_DWORD *)(a1 + 260) != v6) {
LABEL_2:
  }
    CA::OGL::Context::prepare_destination_((CA::OGL::Context *)a1);
  CA::OGL::ExtendedColor::word32(a3);
  v7.i32[0] = *(_DWORD *)(a1 + 1904);
  v7.i32[1] = *(_DWORD *)(a1 + 1912);
  v8.i32[0] = *(_DWORD *)(a1 + 1908) - v7.i32[0];
  v8.i32[1] = *(_DWORD *)(a1 + 1916) - v7.i32[1];
  long long v20 = 0uLL;
  v21[1] = 0;
  v21[2] = 0;
  v21[0] = a2;
  uint32x2_t v9 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v8);
  int32x2_t v10 = vadd_s32(v7, v8);
  int32x2_t v18 = v7;
  unsigned __int32 v19 = vpmax_u32(v9, v9).u32[0];
  while (1)
  {
    uint64_t result = CA::ShapeIterator::iterate(v21, (int *)&v20);
    if (!result) {
      break;
    }
    uint32x2_t v12 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v20 + 8));
    if ((vpmax_u32(v12, v12).u32[0] & 0x80000000) == 0)
    {
      if ((v19 & 0x80000000) != 0
        || (int32x2_t v13 = vmax_s32(*(int32x2_t *)&v20, v18),
            int32x2_t v14 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)&v20, *(int32x2_t *)((char *)&v20 + 8)), v10), v13),
            uint32x2_t v15 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v14),
            (vpmax_u32(v15, v15).u32[0] & 0x80000000) != 0))
      {
        *((void *)&v20 + 1) = 0;
      }
      else
      {
        *(int32x2_t *)&long long v16 = v13;
        *((int32x2_t *)&v16 + 1) = v14;
        long long v20 = v16;
        if (*(void *)(a1 + 1864)) {
          CGBlt_fillBytes();
        }
        uint64_t v17 = *(void *)(a1 + 1872);
        if (v17)
        {
          if (v17 != *(void *)(a1 + 1864)) {
            CGBlt_fillBytes();
          }
        }
      }
    }
  }
  return result;
}

void CA::OGL::SWContext::blur_surface(CA::OGL::SWContext *this, uint64_t a2, uint64_t a3, uint64_t a4, float a5, float a6, double a7, double a8, float64x2_t a9)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (*(_OWORD *)(a3 + 16) == 0
    && !a4
    && ((LODWORD(a7) = 1.0, a5 == 1.0) ? (BOOL v12 = a6 == 1.0) : (BOOL v12 = 0),
        v12 ? (BOOL v13 = *(void *)(a3 + 32) == 0) : (BOOL v13 = 0),
        v13))
  {
    int32x2_t v14 = (int32x2_t)vand_s8((int8x8_t)vcvt_s32_f32(vrndp_f32(vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)vdup_n_s32(0x40347A2Bu), *(float32x2_t *)a3))), (int8x8_t)vmovn_s64(vcgtq_f64(vcvtq_f64_f32(*(float32x2_t *)a3), (float64x2_t)vdupq_n_s64(0x3FE3333333333333uLL))));
    unsigned __int32 v15 = v14.i32[0];
    if ((v14.i32[0] & 0x80000000) == 0)
    {
      uint64_t v16 = v14.u32[1];
      if ((v14.i32[1] & 0x80000000) == 0)
      {
        int8x16_t v17 = *(int8x16_t *)(a2 + 32);
        int8x16_t v46 = v17;
        int v18 = v17.i32[2];
        if (v17.i32[2] <= v17.i32[3]) {
          int v19 = v17.i32[3];
        }
        else {
          int v19 = v17.i32[2];
        }
        if (v17.i32[2] >= v17.i32[3]) {
          int v18 = v17.i32[3];
        }
        int32x2_t v20 = (int32x2_t)vextq_s8(v17, v17, 8uLL).u64[0];
        if (v19 <= 1073741822 && v18 >= 1)
        {
          *(int32x2_t *)v17.i8 = vsub_s32(*(int32x2_t *)v17.i8, v14);
          int32x2_t v20 = vadd_s32(vadd_s32(v14, v14), v20);
          v22.i64[0] = v17.i64[0];
          v22.u64[1] = (unint64_t)v20;
          int8x16_t v46 = v22;
          if (v20.i32[0] < 1 || v20.i32[1] <= 0)
          {
            int32x2_t v20 = 0;
            v46.i64[1] = 0;
          }
        }
        int32x2_t v41 = *(int32x2_t *)v17.i8;
        int32x2_t v43 = v20;
        char v24 = 8;
        if (*(unsigned __int8 *)(*((void *)this + 2) + 16) - 11 >= 2)
        {
          if ((*(unsigned char *)(a2 + 68) & 7) != 0) {
            char v24 = 15;
          }
          else {
            char v24 = 8;
          }
        }
        surface = CA::OGL::SWContext::create_surface(this, 1, (const CA::Bounds *)&v46, v24);
        if (surface)
        {
          uint64_t v26 = (uint64_t)surface;
          CA::OGL::Context::push_surface((uint64_t)this, (uint64_t)surface, 1u, 64, 0);
          uint64_t v27 = *((void *)this + 34);
          if (v27 != *((void *)this + 33)) {
            goto LABEL_34;
          }
          if (v27) {
            LODWORD(v27) = (*(unsigned __int8 *)(v27 + 72) >> 1) & 0x1F;
          }
          if (*((_DWORD *)this + 65) != v27) {
LABEL_34:
          }
            CA::OGL::Context::prepare_destination_(this);
          if ((*((_WORD *)this + 416) & 0x200) != 0) {
            CA::OGL::Context::flatten_detached_layers_((uint64_t)this);
          }
          if ((*(unsigned char *)(v26 + 68) & 7) != 0)
          {
            CGBlt_copyBytes();
            uint64_t v28 = 4;
          }
          else
          {
            if ((*(unsigned char *)(a2 + 68) & 7) != 0) {
              CA::convert_bgra8888_to_mask(*(char **)(a2 + 88), *(char **)(a2 + 80), (char *)(*(void *)(v26 + 88) + *(void *)(v26 + 80) * v16 + v15), *(char **)(v26 + 80), *(int *)(a2 + 40), *(int *)(a2 + 44));
            }
            else {
              CGBlt_copyBytes();
            }
            uint64_t v28 = 1;
          }
          CA::OGL::Context::marked_destination(this);
          CA::OGL::Context::pop_surface(this);
          float32x2_t v29 = vcvt_f32_s32(vadd_s32(v43, v41));
          float32x2_t v30 = *(float32x2_t *)(a3 + 8);
          float32x2_t v42 = vadd_f32(v30, vcvt_f32_s32(v41));
          float32x2_t v44 = vadd_f32(v30, v29);
          CA::OGL::Context::bind_surface((uint64_t)this, v26, 0, 0, 0, 0.0);
          long long v50 = 0u;
          uint64_t v31 = *(void *)(*((void *)this + 31) + 8);
          v48[0] = this;
          v48[1] = v31;
          long long v49 = 0u;
          v48[2] = 0;
          WORD4(v49) = 256;
          CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v48);
          while (CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v48, (int32x2_t *)&v46))
          {
            CA::OGL::Context::array_rect(this, v42.f32[0], v42.f32[1], v44.f32[0], v44.f32[1]);
            uint64_t v32 = *(void *)(*((void *)this + 2) + 8);
            uint64_t v33 = *((void *)this + 15) + 48 * *((void *)this + 16);
            *(void *)(v33 - 160) = v32;
            *(void *)(v33 - 112) = v32;
            *(void *)(v33 - 64) = v32;
            *(void *)(v33 - 16) = v32;
            float v34 = (float)*(int *)(v26 + 40);
            float v35 = (float)*(int *)(v26 + 44);
            uint64_t v36 = *((void *)this + 15) + 48 * *((void *)this + 16);
            *(void *)(v36 - 176) = 0;
            *(float *)(v36 - 128) = v34;
            *(_DWORD *)(v36 - 124) = 0;
            *(float *)(v36 - 80) = v34;
            *(float *)(v36 - 76) = v35;
            *(_DWORD *)(v36 - 32) = 0;
            *(float *)(v36 - 28) = v35;
          }
          CA::OGL::Context::unbind_surface(this, v26, 0);
          CA::OGL::Context::release_surface((uint64_t)this, v26);
          uint64_t v37 = *((void *)this + 2);
          if (*(unsigned char *)(v37 + 16) == 12)
          {
            float64x2_t v38 = vcvtq_f64_f32(v42);
            v47[0] = v38;
            v47[1] = xmmword_184997D60;
            float64x2_t v39 = vcvtq_f64_f32(v44);
            *(float64_t *)&long long v40 = v39.f64[0];
            *((void *)&v40 + 1) = *(void *)&v38.f64[1];
            v47[2] = v40;
            v47[3] = xmmword_184997D60;
            uint8_t v47[4] = v39;
            v47[5] = xmmword_184997D60;
            v38.f64[1] = v39.f64[1];
            v47[6] = v38;
            v47[7] = xmmword_184997D60;
            uint64_t v45 = *(void *)(v37 + 8);
            CA::OGL::emit_quad_surround((uint64_t)this, (const double *)v47, &v45);
          }
        }
      }
    }
  }
  else
  {
    CA::OGL::Context::blur_surface((uint64_t)this, a2, a3, a4, a5, a6, a7, a8, a9);
  }
}

char *CA::OGL::SWContext::create_surface(CA::OGL::SWContext *this, int a2, const CA::Bounds *a3, char a4)
{
  v23[1] = *(void **)MEMORY[0x1E4F143B8];
  int v4 = *((_DWORD *)a3 + 2);
  if (v4 < 1) {
    return 0;
  }
  unint64_t v6 = *((unsigned int *)a3 + 3);
  if ((int)v6 < 1) {
    return 0;
  }
  uint64_t result = 0;
  if (a2 == 1 && v4 <= 0x4000 && v6 <= 0x4000)
  {
    v23[0] = 0;
    char v9 = a4 | 7;
    if ((a4 & 7) == 0) {
      char v9 = a4;
    }
    int v10 = v9 & 0xF;
    LODWORD(v11) = 4 * v4;
    if (v10 == 8) {
      uint64_t v11 = v4;
    }
    else {
      uint64_t v11 = v11;
    }
    unint64_t v12 = (v11 + 15) & 0x1FFFFFFF0;
    unint64_t v13 = v12 * v6;
    if (!is_mul_ok(v12, v6)) {
      unint64_t v13 = 0;
    }
    unsigned __int32 v15 = (char *)*((void *)this + 10);
    int32x2_t v14 = (void *)((char *)this + 80);
    uint64_t result = v15;
    if (v15)
    {
      if (v13 <= *((void *)result + 13))
      {
LABEL_18:
        *int32x2_t v14 = *((void *)result + 1);
        *(_DWORD *)uint64_t result = 1;
        *((_DWORD *)result + 6) = v4;
        *((_DWORD *)result + 7) = v6;
        *((void *)result + 4) = *(void *)a3;
        *((_DWORD *)result + 10) = v4;
        *((_DWORD *)result + 11) = v6;
        *(_WORD *)(result + 75) &= ~0x200u;
        *((void *)result + 10) = v12;
        *((_DWORD *)result + 17) = v10;
        result[72] |= 1u;
        return result;
      }
      while (1)
      {
        uint64_t v16 = result;
        uint64_t result = (char *)*((void *)result + 1);
        if (!result) {
          break;
        }
        if (v13 <= *((void *)result + 13))
        {
          int32x2_t v14 = v16 + 8;
          goto LABEL_18;
        }
      }
    }
    uint64_t result = (char *)CA::Render::aligned_malloc((CA::Render *)v13, (unint64_t *)v23, 0);
    if (result)
    {
      int8x16_t v17 = (CA::Render *)result;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      uint64_t result = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x80uLL, 0x743898A5uLL);
      if (result)
      {
        *(_DWORD *)uint64_t result = 1;
        int v20 = *((_DWORD *)a3 + 2);
        *((_DWORD *)result + 6) = v20;
        int v21 = *((_DWORD *)a3 + 3);
        *((_DWORD *)result + 7) = v21;
        *((void *)result + 4) = *(void *)a3;
        *((_DWORD *)result + 10) = v20;
        *((_DWORD *)result + 11) = v21;
        *((_DWORD *)result + 17) = v10;
        result[72] |= 1u;
        int8x16_t v22 = v23[0];
        *((void **)result + 12) = v23[0];
        *((void *)result + 13) = v22;
        *((void *)result + 10) = v12;
        *((void *)result + 11) = v17;
        *(_WORD *)(result + 75) |= 0xD0u;
        result[74] = result[74] & 0xE0 | 4;
        return result;
      }
      CA::Render::aligned_free(v17, (size_t)v23[0], v19);
      return 0;
    }
  }
  return result;
}

uint64_t CA::OGL::SWContext::set_surface(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v3 = *(_DWORD *)(a2 + 68);
    if ((v3 & 7) != 0)
    {
      uint64_t v4 = *(void *)(a2 + 80);
      *(void *)(a1 + 1864) = *(void *)(a2 + 88);
      *(void *)(a1 + 1880) = v4;
      if ((v3 & 8) != 0)
      {
        uint64_t v6 = *(void *)(a2 + 80);
        uint64_t v5 = *(void *)(a2 + 88);
      }
      else
      {
        uint64_t v5 = 0;
        uint64_t v6 = 0;
      }
      *(void *)(a1 + 1872) = v5;
      uint64_t v10 = 0x400000020;
    }
    else
    {
      *(void *)(a1 + 1864) = 0;
      *(void *)(a1 + 1880) = 0;
      uint64_t v6 = *(void *)(a2 + 80);
      *(void *)(a1 + 1872) = *(void *)(a2 + 88);
      uint64_t v10 = 0;
    }
    *(void *)(a1 + 1888) = v6;
    *(void *)(a1 + 1896) = v10;
    int v11 = *(_DWORD *)(a2 + 32);
    int v12 = *(_DWORD *)(a2 + 36);
    *(_DWORD *)(a1 + 1904) = v11;
    *(_DWORD *)(a1 + 1912) = v12;
    int v13 = *(_DWORD *)(a2 + 44);
    *(_DWORD *)(a1 + 1908) = *(_DWORD *)(a2 + 40) + v11;
    *(_DWORD *)(a1 + 1916) = v13 + v12;
    if ((*(unsigned char *)(a2 + 75) & 0x20) != 0)
    {
      bzero(*(void **)(a2 + 88), *(void *)(a2 + 104));
      *(_WORD *)(a2 + 75) = *(_WORD *)(a2 + 75) & 0xFF1F | 0xC0;
    }
  }
  else
  {
    long long v7 = *(_OWORD *)(a1 + 1936);
    *(_OWORD *)(a1 + 1864) = *(_OWORD *)(a1 + 1920);
    *(_OWORD *)(a1 + 1880) = v7;
    *(void *)(a1 + 1896) = *(void *)(a1 + 1952);
    int v8 = *(_DWORD *)(a1 + 1960);
    *(_DWORD *)(a1 + 1904) = v8;
    int v9 = *(_DWORD *)(a1 + 1964);
    *(_DWORD *)(a1 + 1912) = v9;
    *(_DWORD *)(a1 + 1908) = *(_DWORD *)(a1 + 1968) + v8;
    *(_DWORD *)(a1 + 1916) = *(_DWORD *)(a1 + 1972) + v9;
  }
  return 1;
}

uint64_t CA::OGL::SWContext::bind_surface_impl(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6)
{
  uint64_t v6 = *(void *)(result + 16);
  *(_WORD *)(v6 + 2 * a4 + 144) = 3;
  *(void *)(v6 + 8 * a4 + 176) = a2;
  *(unsigned char *)(a2 + 120) = (a5 != 0) | (16 * (a6 != 0));
  return result;
}

uint64_t CA::OGL::SWContext::needs_destination_group(CA::OGL::SWContext *this)
{
  return 0;
}

void CA::OGL::SWContext::finalize_surface(uint64_t a1, uint64_t a2, void *a3)
{
  size_t v4 = *(void *)(a2 + 96);
  if (v4) {
    CA::Render::aligned_free(*(CA::Render **)(a2 + 88), v4, a3);
  }
  uint64_t v5 = *(__IOSurface **)(a2 + 112);
  if (v5)
  {
    IOSurfaceUnlock(v5, 0, 0);
    CFRelease(*(CFTypeRef *)(a2 + 112));
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, (void *)a2);
}

double CA::OGL::SWContext::create_null_surface(CA::OGL::SWContext *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  unsigned int v2 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x80uLL, 0x743898A5uLL);
  *(_DWORD *)unsigned int v2 = 1;
  *(_OWORD *)(v2 + 24) = xmmword_184998200;
  *(void *)&double result = 0x100000001;
  *((void *)v2 + 5) = 0x100000001;
  *((_DWORD *)v2 + 17) = 15;
  v2[72] |= 1u;
  *((void *)v2 + 12) = 0;
  *((void *)v2 + 13) = 0;
  *((void *)v2 + 10) = 4;
  *((void *)v2 + 11) = &CA::OGL::SWContext::create_null_surface(void)::pixel;
  v2[120] = 0;
  *(_WORD *)(v2 + 75) |= 0x80u;
  return result;
}

void CA::OGL::SWContext::copy_destination(CA::OGL::Context *this, uint64_t a2, int32x2_t *a3, uint64_t a4, int32x2_t *a5, int32x2_t *a6, unsigned char *a7)
{
  uint64_t v13 = *((void *)this + 34);
  if (v13 != *((void *)this + 33)) {
    goto LABEL_2;
  }
  if (v13) {
    LODWORD(v13) = (*(unsigned __int8 *)(v13 + 72) >> 1) & 0x1F;
  }
  if (*((_DWORD *)this + 65) != v13) {
LABEL_2:
  }
    CA::OGL::Context::prepare_destination_(this);
  if ((*((_WORD *)this + 416) & 0x200) != 0) {
    CA::OGL::Context::flatten_detached_layers_((uint64_t)this);
  }
  if (a4)
  {
    int32x2_t v14 = a5 + 1;
    do
    {
      v15.i32[0] = *((_DWORD *)this + 476);
      v15.i32[1] = *((_DWORD *)this + 478);
      int32x2_t v16 = vsub_s32(v14[-1], v15);
      int32x2_t v17 = vmax_s32(v16, 0);
      int32x2_t v18 = vmin_s32(v16, 0);
      int32x2_t v19 = vsub_s32(*a6, v18);
      int32x2_t v20 = vmin_s32(v19, 0);
      int32x2_t v21 = vsub_s32(v17, v20);
      int32x2_t v22 = vsub_s32(*v14, vadd_s32(v18, v20));
      int32x2_t v23 = vmax_s32(v19, 0);
      v19.i32[0] = *((_DWORD *)this + 477);
      v19.i32[1] = *((_DWORD *)this + 479);
      int32x2_t v24 = vsub_s32(v19, v15);
      int32x2_t v25 = (int32x2_t)vbsl_s8((int8x8_t)vcgt_s32(vadd_s32(v21, v22), v24), (int8x8_t)vsub_s32(v24, v21), (int8x8_t)v22);
      int32x2_t v26 = vcgt_s32((int32x2_t)0x100000001, (int32x2_t)vbsl_s8((int8x8_t)vcgt_s32(vadd_s32(v25, v23), a3[3]), (int8x8_t)vsub_s32(a3[3], v23), (int8x8_t)v25));
      if (((v26.i32[0] | v26.i32[1]) & 1) == 0)
      {
        if (*((_DWORD *)this + 474) != 32 || !*((void *)this + 233)) {
          break;
        }
        CGBlt_copyBytes();
      }
      ++a6;
      v14 += 2;
      --a4;
    }
    while (a4);
  }
  CA::OGL::Context::marked_surface((uint64_t)this, (uint64_t)a3);
  *a7 = 0;
}

void CA::OGL::SWContext::reuse_surface(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a2 + 32) = *(_OWORD *)a3;
  *(_WORD *)(a2 + 75) &= 0xFFF0u;
  uint64_t v3 = *(void *)(a3 + 8);
  *(void *)(a2 + 24) = v3;
  if ((*(_DWORD *)(a2 + 68) & 0xF) == 8) {
    int v4 = v3;
  }
  else {
    int v4 = 4 * v3;
  }
  *(void *)(a2 + 80) = (v4 + 15) & 0xFFFFFFFFFFFFFFF0;
}

char *CA::OGL::SWContext::create_surface_from_iosurface(CA::OGL::SWContext *this, int a2, int a3, int a4, IOSurfaceRef buffer)
{
  if (a2 != 1) {
    return 0;
  }
  int v8 = 0;
  if (!IOSurfaceLock(buffer, 0, 0))
  {
    BaseAddress = IOSurfaceGetBaseAddress(buffer);
    size_t BytesPerRow = IOSurfaceGetBytesPerRow(buffer);
    int Width = IOSurfaceGetWidth(buffer);
    Height = (CA::OGL::SWContext *)IOSurfaceGetHeight(buffer);
    surface_from_datCGFloat a = CA::OGL::SWContext::create_surface_from_data(Height, BaseAddress, BytesPerRow, a3, a4, Width, (int)Height, 0);
    int v8 = surface_from_data;
    if (surface_from_data)
    {
      *((void *)surface_from_data + 14) = buffer;
      CFRetain(buffer);
    }
  }
  return v8;
}

char *CA::OGL::SWContext::create_surface_from_data(CA::OGL::SWContext *this, void *a2, uint64_t a3, int a4, int a5, int a6, int a7, int a8)
{
  double result = 0;
  if (a6 >= 1)
  {
    uint64_t v10 = (a7 - 1);
    if (a7 >= 1)
    {
      double result = 0;
      if (a6 <= 0x4000 && a7 <= 0x4000)
      {
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        double result = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x80uLL, 0x743898A5uLL);
        if (result)
        {
          *(_DWORD *)double result = 1;
          *((_DWORD *)result + 6) = a6;
          *((_DWORD *)result + 7) = a7;
          *((_DWORD *)result + 8) = a4;
          *((_DWORD *)result + 9) = a5;
          *((_DWORD *)result + 10) = a6;
          *((_DWORD *)result + 11) = a7;
          if (a8) {
            int v18 = 8;
          }
          else {
            int v18 = 15;
          }
          *((_DWORD *)result + 17) = v18;
          result[72] |= 1u;
          if (a8) {
            char v19 = 0;
          }
          else {
            char v19 = 2;
          }
          *((void *)result + 12) = 0;
          *((void *)result + 13) = (a6 << v19) + v10 * a3;
          *((void *)result + 10) = a3;
          *((void *)result + 11) = a2;
          *(_WORD *)(result + 75) |= 0x190u;
        }
      }
    }
  }
  return result;
}

void CA::OGL::SWContext::delete_image(uint64_t a1, uint64_t a2, void *a3)
{
  int v4 = *(const void **)(a2 + 72);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a2 + 72) = 0;
  }
  uint64_t v5 = *(CA::Render **)(a2 + 88);
  if (v5)
  {
    CA::Render::aligned_free(v5, *(void *)(a2 + 96), a3);
    *(void *)(a2 + 88) = 0;
  }
  uint64_t v6 = *(CA::WindowServer::Surface **)(a2 + 32);
  if (v6)
  {
    CA::WindowServer::Surface::unref(v6);
    *(void *)(a2 + 32) = 0;
  }
  long long v7 = *(CA::WindowServer::Surface **)(a2 + 40);
  if (v7)
  {
    CA::WindowServer::Surface::unref(v7);
    *(void *)(a2 + 40) = 0;
  }
  *(unsigned char *)(a2 + 112) = 0;
}

double CA::OGL::SWContext::new_image(CA::OGL::SWContext *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  unsigned int v2 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x78uLL, 0x743898A5uLL);
  if (v2)
  {
    v2[14] = 0;
    double result = 0.0;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *(_OWORD *)unsigned int v2 = 0u;
  }
  return result;
}

void *CA::OGL::SWContext::image_surface(uint64_t a1, uint64_t a2, CA::Render::PixelBuffer *this)
{
  double result = CA::OGL::SWContext::retain_image(a2, this);
  if (result)
  {
    uint64_t v6 = (uint64_t)result;
    double result = *(void **)(a2 + 32);
    if (!result)
    {
      int v7 = *(unsigned __int8 *)(v6 + 12);
      if (v7 == 23)
      {
        int v8 = CA::Render::Image::retain_iosurface((CA::Render::Image *)v6);
        if (!v8) {
          return *(void **)(a2 + 32);
        }
      }
      else
      {
        if (v7 != 51) {
          return 0;
        }
        int v8 = *(__IOSurface **)(v6 + 112);
        if (!v8) {
          return 0;
        }
        CFRetain(*(CFTypeRef *)(v6 + 112));
      }
      int v9 = *(CA::WindowServer::IOSurface **)(a1 + 192);
      if (v9) {
        int v9 = (CA::WindowServer::IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(void *)v9 + 16))(v9);
      }
      double result = CA::WindowServer::IOSurface::wrap_buffer(v9, v8, 0, 1);
      *(void *)(a2 + 32) = result;
    }
  }
  return result;
}

CA::Render::PixelBuffer *CA::OGL::SWContext::retain_image(uint64_t a1, CA::Render::PixelBuffer *this)
{
  while (1)
  {
    int v4 = *((unsigned __int8 *)this + 12);
    if (v4 != 38) {
      break;
    }
    this = CA::Render::PixelBuffer::image(this);
    if (!this) {
      return this;
    }
  }
  switch(v4)
  {
    case 9:
      if (!*(void *)(a1 + 8))
      {
        *(void *)(a1 + 8) = this;
        (*(void (**)(CA::Render::PixelBuffer *))(*(void *)this + 176))(this);
      }
      break;
    case 23:
      *(unsigned char *)(a1 + 112) = 1;
      if (!*(void *)(a1 + 8))
      {
        *(void *)(a1 + 8) = this;
        atomic_fetch_add((atomic_uint *volatile)this + 37, 1u);
      }
      break;
    case 51:
      if (!*(void *)(a1 + 8))
      {
        *(void *)(a1 + 8) = this;
        (*(void (**)(CA::Render::PixelBuffer *))(*(void *)this + 176))(this);
      }
      if (!*(void *)(a1 + 72))
      {
        uint64_t v5 = *((void *)this + 14);
        if (v5) {
          CFRetain(*((CFTypeRef *)this + 14));
        }
        *(void *)(a1 + 72) = v5;
        *(_DWORD *)(a1 + 80) = (*(uint64_t (**)(CA::Render::PixelBuffer *))(*(void *)this + 104))(this);
      }
      break;
  }
  return this;
}

uint64_t CA::OGL::SWContext::bind_image_impl(CA::OGL::Context *this, unsigned int a2, CA::Render::Texture *a3, __int16 a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (*((CA::OGL::Context **)a3 + 11) == this && (uint64_t v15 = *((void *)a3 + 10)) != 0
    || (uint64_t v15 = CA::OGL::Context::lookup_image_(this, a3, 1)) != 0)
  {
    int32x2_t v16 = CA::OGL::SWContext::retain_image(v15, a3);
    if (v16)
    {
      uint64_t v17 = *(void *)(v15 + 64);
      if (v17)
      {
LABEL_10:
        if (*((_DWORD *)v16 + 3) & 0x1000 | a4 & 0x200) {
          __int16 v20 = 2;
        }
        else {
          __int16 v20 = 1;
        }
        *(_WORD *)(v15 + 52) = v20;
        *(_WORD *)(v15 + 58) |= 0x100u;
        uint64_t v21 = *((void *)this + 2);
        *(_WORD *)(v21 + 2 * a2 + 144) = v20;
        *(void *)(v21 + 8 * a2 + 176) = v17;
        *(unsigned char *)(v15 + 54) = (((a5 != 0) << 16) | ((a6 != 0) << 20)) >> 16;
        *(_OWORD *)a8 = xmmword_184998030;
        if (((a4 & 0x800) == 0) != (*((unsigned char *)v16 + 13) & 8) >> 3)
        {
          *(_DWORD *)(a8 + 4) = 1065353216;
          *(_DWORD *)(a8 + 12) = 0;
        }
        return v15;
      }
      int v19 = *((_DWORD *)v16 + 4);
      int v18 = *((_DWORD *)v16 + 5);
      if (v19 <= 0x4000 && v18 <= 0x4000)
      {
        *(void *)(v15 + 64) = v15;
        uint64_t v17 = v15;
        goto LABEL_10;
      }
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int32x2_t v22 = x_log_category_ogl;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          int v25 = v19;
          __int16 v26 = 1024;
          int v27 = v18;
          _os_log_impl(&dword_184668000, v22, OS_LOG_TYPE_DEFAULT, "CoreAnimation: %d by %d image is too large for software renderer, ignoring\n", buf, 0xEu);
        }
      }
    }
    return 0;
  }
  return v15;
}

double CA::OGL::SWContext::bind_gaussian(CA::OGL::SWContext *this, unsigned int a2, float *a3)
{
  uint64_t v5 = *((void *)this + 2);
  unsigned int v6 = CA::OGL::state_image_texture_unit(v5, a2);
  *(_WORD *)(v5 + 2 * v6 + 144) = 4;
  *(void *)(v5 + 8 * v6 + 176) = 6;
  *(void *)a3 = 0x3F80000000000000;
  double result = 0.00781250185;
  *(_OWORD *)(v5 + 16 * a2 + 96) = xmmword_184997ED0;
  return result;
}

__n128 CA::OGL::SWContext::bind_uneven_supercircle(uint64_t a1, unsigned int a2, uint64_t a3, void *a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  unsigned int v8 = CA::OGL::state_image_texture_unit(v7, a2);
  *(_WORD *)(v7 + 2 * v8 + 144) = 4;
  *(void *)(v7 + 8 * v8 + 176) = 5;
  *a4 = 0x3F80000000000000;
  *(_OWORD *)(v7 + 16 * a2 + 96) = xmmword_184997ED0;
  uint64_t v9 = v7 + 48 * a2;
  *(_OWORD *)(v9 + 384) = *(_OWORD *)a3;
  __n128 result = *(__n128 *)(a3 + 16);
  *(__n128 *)(v9 + 400) = result;
  return result;
}

__n128 CA::OGL::SWContext::bind_uneven_circle(uint64_t a1, unsigned int a2, uint64_t a3, void *a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  unsigned int v8 = CA::OGL::state_image_texture_unit(v7, a2);
  *(_WORD *)(v7 + 2 * v8 + 144) = 4;
  *(void *)(v7 + 8 * v8 + 176) = 4;
  *a4 = 0x3F80000000000000;
  *(_OWORD *)(v7 + 16 * a2 + 96) = xmmword_184997ED0;
  uint64_t v9 = v7 + 48 * a2;
  *(_OWORD *)(v9 + 384) = *(_OWORD *)a3;
  __n128 result = *(__n128 *)(a3 + 16);
  *(__n128 *)(v9 + 400) = result;
  return result;
}

double CA::OGL::SWContext::bind_supercircle(CA::OGL::SWContext *this, unsigned int a2, int a3, BOOL a4, BOOL a5, float *a6, unsigned int a7, float *a8)
{
  uint64_t v10 = *((void *)this + 2);
  unsigned int v11 = CA::OGL::state_image_texture_unit(v10, a2);
  *(_WORD *)(v10 + 2 * v11 + 144) = 4;
  *(void *)(v10 + 8 * v11 + 176) = 3;
  *(void *)a6 = 0x3F800000BF800000;
  double result = 0.00781250185;
  *(_OWORD *)(v10 + 16 * a2 + 96) = xmmword_184997ED0;
  return result;
}

double CA::OGL::SWContext::bind_circle(CA::OGL::SWContext *this, unsigned int a2, int a3, BOOL a4, BOOL a5, float *a6)
{
  uint64_t v8 = *((void *)this + 2);
  unsigned int v9 = CA::OGL::state_image_texture_unit(v8, a2);
  *(_WORD *)(v8 + 2 * v9 + 144) = 4;
  *(void *)(v8 + 8 * v9 + 176) = 2;
  *(void *)a6 = 0x3F800000BF800000;
  double result = 0.00781250185;
  *(_OWORD *)(v8 + 16 * a2 + 96) = xmmword_184997ED0;
  return result;
}

double CA::OGL::SWContext::bind_square(CA::OGL::SWContext *this, unsigned int a2, BOOL a3, BOOL a4, float *a5)
{
  uint64_t v7 = *((void *)this + 2);
  unsigned int v8 = CA::OGL::state_image_texture_unit(v7, a2);
  *(_WORD *)(v7 + 2 * v8 + 144) = 4;
  *(void *)(v7 + 8 * v8 + 176) = 1;
  *(void *)a5 = 0x3F800000BF800000;
  double result = 0.00781250185;
  *(_OWORD *)(v7 + 16 * a2 + 96) = xmmword_184997ED0;
  return result;
}

void CA::OGL::SWContext::draw_elements(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
}

void CA::OGL::SWContext::draw_elements(uint64_t this, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v13 = (CA::OGL::Context *)this;
  uint64_t v191 = *MEMORY[0x1E4F143B8];
  long long v188 = 0u;
  long long v189 = 0u;
  long long v187 = 0u;
  memset(v186, 0, sizeof(v186));
  int32x2_t v14 = *(unsigned __int8 **)(this + 16);
  uint64_t v15 = *(void *)(this + 272);
  if (v15 != *(void *)(this + 264)) {
    goto LABEL_2;
  }
  if (v15) {
    LODWORD(v15) = (*(unsigned __int8 *)(v15 + 72) >> 1) & 0x1F;
  }
  if (*(_DWORD *)(this + 260) != v15) {
LABEL_2:
  }
    this = CA::OGL::Context::prepare_destination_((CA::OGL::Context *)this);
  if ((*((_WORD *)v13 + 416) & 0x200) != 0) {
    this = CA::OGL::Context::flatten_detached_layers_((uint64_t)v13);
  }
  int v16 = *((_DWORD *)v13 + 476);
  LODWORD(v187) = v16;
  int v17 = *((_DWORD *)v13 + 478);
  DWORD1(v187) = v17;
  int v18 = *((_DWORD *)v13 + 477);
  DWORD2(v187) = v18;
  int v19 = *((_DWORD *)v13 + 479);
  HIDWORD(v187) = v19;
  if (*((unsigned char *)v13 + 64))
  {
    int v20 = *((_DWORD *)v13 + 8);
    int v21 = *((_DWORD *)v13 + 9);
    int v22 = *((_DWORD *)v13 + 10) + v20;
    int v23 = *((_DWORD *)v13 + 11) + v21;
    if (v16 <= v20) {
      int v16 = *((_DWORD *)v13 + 8);
    }
    LODWORD(v187) = v16;
    if (v17 <= v21) {
      int v17 = v21;
    }
    DWORD1(v187) = v17;
    if (v18 >= v22) {
      int v18 = v22;
    }
    DWORD2(v187) = v18;
    if (v19 >= v23) {
      int v19 = v23;
    }
    HIDWORD(v187) = v19;
  }
  unsigned int v171 = a2;
  unsigned int v172 = a3;
  uint64_t v173 = a4;
  uint64_t v174 = a5;
  v175 = a8;
  v185[0] = v16;
  v185[1] = v17;
  v185[2] = v18 - v16;
  v185[3] = v19 - v17;
  v176 = v13;
  if (v14[480])
  {
    uint64_t v24 = CA::OGL::tex_image_count[v14[16]];
    unsigned int v25 = ~(-1 << v24);
    DWORD1(v188) = v25;
    *(void *)&v186[0] = v13;
    LODWORD(v188) = 0;
    if (v24)
    {
      uint64_t v26 = 0;
      v178 = v14 + 17;
      CFAllocatorRef bytesDeallocator = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
      __asm { FMOV            V8.2S, #1.0 }
      int64x2_t v168 = vdupq_n_s64(2uLL);
      v177 = v14;
      while (1)
      {
        if ((v25 & 1) == 0) {
          goto LABEL_145;
        }
        uint64_t v32 = (char *)v186 + 88 * v26;
        unsigned int v33 = v178[v26];
        *((_DWORD *)v32 + 4) = -1;
        float v34 = (int *)(v32 + 16);
        float v35 = (unsigned int *)(v34 - 2);
        int v36 = *(unsigned __int16 *)&v14[2 * v26 + 144];
        uint64_t v37 = *(void *)&v14[8 * v26 + 176];
        *((void *)v34 + 8) = 0;
        float64x2_t v38 = v34 + 16;
        float64x2_t v39 = (char *)v34 + 57;
        *((_WORD *)v34 + 28) = 0;
        long long v40 = v34 + 14;
        if ((v36 - 1) < 2) {
          break;
        }
        if (v36 == 3)
        {
          *(void *)float v35 = *(void *)(v37 + 88);
          int8x16_t v46 = (void *)v186 + 11 * v26;
          v46[3] = *(void *)(v37 + 80);
          *long long v40 = 8 * ((*(unsigned char *)(v37 + 120) & 0xF) != 0);
          *float64x2_t v39 = 8 * (*(unsigned __int8 *)(v37 + 120) > 0xFu);
          v46[4] = *(void *)(v37 + 40);
          if ((*(_DWORD *)(v37 + 68) & 7) != 0) {
            int v47 = 1;
          }
          else {
            int v47 = 9;
          }
          *float v34 = v47;
          this = (uint64_t)&CA::OGL::SW::sampler_functions::samplers[16 * v47];
          v46[7] = this;
        }
        else if (v36 == 4)
        {
          *((void *)&v186[2] + 11 * v26) = 0x100000001;
          switch(v37)
          {
            case 1:
              {
                float64x2_t v39 = (char *)v34 + 57;
                if (v107)
                {
                  v108 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  uint64_t v109 = 0;
                  int8x16_t v110 = (int8x16_t)xmmword_184997FD0;
                  do
                  {
                    *(int8x16_t *)&v108[v109] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v110, (int8x16_t)vdupq_n_s64(4uLL))), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::square_sampler<false>), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::square_sampler<true>));
                    int8x16_t v110 = (int8x16_t)vaddq_s64((int64x2_t)v110, vdupq_n_s64(2uLL));
                    v109 += 16;
                  }
                  while (v109 != 128);
                  CA::OGL::SW::square_samplers(void)::s = (uint64_t)v108;
                  float64x2_t v39 = (char *)v34 + 57;
                }
              }
              this = CA::OGL::SW::square_samplers(void)::s;
              goto LABEL_86;
            case 2:
              {
                float64x2_t v39 = (char *)v34 + 57;
                if (v111)
                {
                  v112 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  uint64_t v113 = 0;
                  int8x16_t v114 = (int8x16_t)xmmword_184997FD0;
                  do
                  {
                    *(int8x16_t *)&v112[v113] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v114, (int8x16_t)vdupq_n_s64(4uLL))), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::circle_sampler<false,false>), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::circle_sampler<true,false>));
                    int8x16_t v114 = (int8x16_t)vaddq_s64((int64x2_t)v114, vdupq_n_s64(2uLL));
                    v113 += 16;
                  }
                  while (v113 != 128);
                  CA::OGL::SW::circle_samplers(void)::s = (uint64_t)v112;
                  float64x2_t v39 = (char *)v34 + 57;
                }
              }
              this = CA::OGL::SW::circle_samplers(void)::s;
              goto LABEL_86;
            case 3:
              {
                float64x2_t v39 = (char *)v34 + 57;
                if (v115)
                {
                  v116 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  uint64_t v117 = 0;
                  int8x16_t v118 = (int8x16_t)xmmword_184997FD0;
                  do
                  {
                    *(int8x16_t *)&v116[v117] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v118, (int8x16_t)vdupq_n_s64(4uLL))), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::circle_sampler<false,true>), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::circle_sampler<true,true>));
                    int8x16_t v118 = (int8x16_t)vaddq_s64((int64x2_t)v118, vdupq_n_s64(2uLL));
                    v117 += 16;
                  }
                  while (v117 != 128);
                  CA::OGL::SW::supercircle_samplers(void)::s = (uint64_t)v116;
                  float64x2_t v39 = (char *)v34 + 57;
                }
              }
              this = CA::OGL::SW::supercircle_samplers(void)::s;
              goto LABEL_86;
            case 4:
              {
                float64x2_t v39 = (char *)v34 + 57;
                if (v119)
                {
                  v120 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  uint64_t v121 = 0;
                  int8x16_t v122 = (int8x16_t)xmmword_184997FD0;
                  do
                  {
                    *(int8x16_t *)&v120[v121] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v122, (int8x16_t)vdupq_n_s64(4uLL))), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::uneven_circle_sampler<false,false>), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::uneven_circle_sampler<true,false>));
                    int8x16_t v122 = (int8x16_t)vaddq_s64((int64x2_t)v122, vdupq_n_s64(2uLL));
                    v121 += 16;
                  }
                  while (v121 != 128);
                  CA::OGL::SW::uneven_circle_samplers(void)::s = (uint64_t)v120;
                  float64x2_t v39 = (char *)v34 + 57;
                }
              }
              this = CA::OGL::SW::uneven_circle_samplers(void)::s;
              goto LABEL_86;
            case 5:
              {
                float64x2_t v39 = (char *)v34 + 57;
                if (v123)
                {
                  v124 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  uint64_t v125 = 0;
                  int8x16_t v126 = (int8x16_t)xmmword_184997FD0;
                  do
                  {
                    *(int8x16_t *)&v124[v125] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v126, (int8x16_t)vdupq_n_s64(4uLL))), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::uneven_circle_sampler<false,true>), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::uneven_circle_sampler<true,true>));
                    int8x16_t v126 = (int8x16_t)vaddq_s64((int64x2_t)v126, vdupq_n_s64(2uLL));
                    v125 += 16;
                  }
                  while (v125 != 128);
                  CA::OGL::SW::uneven_supercircle_samplers(void)::s = (uint64_t)v124;
                  float64x2_t v39 = (char *)v34 + 57;
                }
              }
              this = CA::OGL::SW::uneven_supercircle_samplers(void)::s;
LABEL_86:
              *((void *)&v186[3] + 11 * v26 + 1) = this;
              LODWORD(v188) = v188 | 1;
              break;
            case 6:
              {
                float v35 = (unsigned int *)(v34 - 2);
                float64x2_t v39 = (char *)v34 + 57;
                if (v127)
                {
                  v128 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  uint64_t v129 = 0;
                  int8x16_t v130 = (int8x16_t)xmmword_184997FD0;
                  do
                  {
                    *(int8x16_t *)&v128[v129] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v130, (int8x16_t)vdupq_n_s64(4uLL))), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::gaussian_sampler<false>), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::gaussian_sampler<true>));
                    int8x16_t v130 = (int8x16_t)vaddq_s64((int64x2_t)v130, vdupq_n_s64(2uLL));
                    v129 += 16;
                  }
                  while (v129 != 128);
                  CA::OGL::SW::gaussian_samplers(void)::s = (uint64_t)v128;
                  float64x2_t v39 = (char *)v34 + 57;
                  float v35 = (unsigned int *)(v34 - 2);
                }
              }
              this = CA::OGL::SW::gaussian_samplers(void)::s;
              *((void *)&v186[3] + 11 * v26 + 1) = CA::OGL::SW::gaussian_samplers(void)::s;
              *(void *)float v35 = &CA::OGL::gaussian_table;
              break;
            default:
              this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
              float64x2_t v39 = (char *)v34 + 57;
              goto LABEL_112;
          }
        }
        else
        {
          unint64_t v48 = (char *)v186 + 88 * v26;
          *((void *)v48 + 4) = 0x100000001;
          this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
          float64x2_t v39 = (char *)v34 + 57;
          *((void *)v48 + 7) = this;
        }
LABEL_113:
        long long v89 = (int32x2_t *)v186 + 11 * v26;
        int32x2_t v90 = v89[4];
        v89[5] = vadd_s32(vshl_n_s32(v90, 0x10uLL), (int32x2_t)-1);
        v89[6] = (int32x2_t)vdiv_f32(_D8, vcvt_f32_u32((uint32x2_t)v90));
        if (*v40 != *v39) {
          LODWORD(v188) = v188 | 1;
        }
        if (v33 > 0x26) {
          goto LABEL_127;
        }
        if (((1 << v33) & 0xF000000) != 0)
        {
          if (*v34 == 25)
          {
            {
              if (this)
              {
                v96 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                uint64_t v97 = 0;
                int8x16_t v98 = (int8x16_t)xmmword_184997FD0;
                do
                {
                  *(int8x16_t *)&v96[v97] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v98, (int8x16_t)vdupq_n_s64(4uLL))), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,CA::Vec4<float>,true,true,false,true>), (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,CA::Vec4<float>,true,true,true,true>));
                  int8x16_t v98 = (int8x16_t)vaddq_s64((int64x2_t)v98, v168);
                  v97 += 16;
                }
                while (v97 != 128);
                CA::OGL::SW::prepare_texture(CA::OGL::SWContext &,CA::OGL::SW::Texture *,unsigned int,unsigned long,CA::OGL::ImageFunction,unsigned int *)::Lh_samplers = (uint64_t)v96;
              }
            }
            switch(v33)
            {
              case 0x18u:
                {
                  v99 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v99, off_1ED033010, 0x80uLL);
                  CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s = (uint64_t)v99;
                }
                this = CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s;
                break;
              case 0x19u:
                {
                  v101 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v101, off_1ED033000, 0x80uLL);
                  CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s = (uint64_t)v101;
                }
                this = CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s;
                break;
              case 0x1Au:
                {
                  v102 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v102, off_1ED032FF0, 0x80uLL);
                  CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s = (uint64_t)v102;
                }
                this = CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s;
                break;
              case 0x1Bu:
                {
                  v103 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v103, off_1ED032FE0, 0x80uLL);
                  CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s = (uint64_t)v103;
                }
                this = CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s;
                break;
              default:
                this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
                break;
            }
            uint64_t v93 = CA::OGL::SW::prepare_texture(CA::OGL::SWContext &,CA::OGL::SW::Texture *,unsigned int,unsigned long,CA::OGL::ImageFunction,unsigned int *)::Lh_samplers;
            v94 = (char *)v186 + 88 * v26;
            *((void *)v94 + 7) = this;
            *((void *)v94 + 8) = v93;
          }
          else
          {
            v92 = (char *)v186 + 88 * v26;
            *((void *)v92 + 8) = this;
            switch(v33)
            {
              case 0x18u:
                {
                  v100 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v100, off_1ED033050, 0x80uLL);
                  CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s = (uint64_t)v100;
                }
                this = CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s;
                break;
              case 0x19u:
                {
                  v104 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v104, off_1ED033040, 0x80uLL);
                  CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s = (uint64_t)v104;
                }
                this = CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s;
                break;
              case 0x1Au:
                {
                  v105 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v105, off_1ED033030, 0x80uLL);
                  CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s = (uint64_t)v105;
                }
                this = CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s;
                break;
              case 0x1Bu:
                {
                  v106 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v106, off_1ED033020, 0x80uLL);
                  CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s = (uint64_t)v106;
                }
                this = CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s;
                break;
              default:
                this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
                break;
            }
            *((void *)v92 + 7) = this;
          }
          goto LABEL_145;
        }
        if (((1 << v33) & 0x4000200003) != 0)
        {
          uint64_t v91 = (char *)v186 + 88 * v26;
        }
        else
        {
LABEL_127:
          this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
          uint64_t v91 = (char *)v186 + 88 * v26;
          *((void *)v91 + 7) = this;
        }
        *((void *)v91 + 8) = 0;
LABEL_145:
        ++v26;
        BOOL v95 = v25 > 1;
        v25 >>= 1;
        if (!v95) {
          goto LABEL_192;
        }
      }
      *long long v40 = 8 * ((*(_DWORD *)(v37 + 52) & 0xF0000) != 0);
      *float64x2_t v39 = 8 * ((*(_DWORD *)(v37 + 52) & 0xF00000) != 0);
      uint64_t v41 = *(void *)(v37 + 8);
      if (!v41 || !*(unsigned char *)(v37 + 112))
      {
        float32x2_t v44 = *(__IOSurface **)(v37 + 72);
        if (v44)
        {
          v170 = (void **)(v34 - 2);
          uint64_t ProtectionOptions = IOSurfaceGetProtectionOptions();
          int32x2_t v14 = v177;
          if (ProtectionOptions) {
            goto LABEL_35;
          }
          int v57 = *(_DWORD *)(v37 + 80);
          *float v34 = v57;
          if (v57 == -1)
          {
            if (*(void *)(v37 + 88)) {
              goto LABEL_67;
            }
            v162 = *(CA::Render::Surface **)(v37 + 8);
            buffer = *(__IOSurface **)(v37 + 72);
            OSType PixelFormat = IOSurfaceGetPixelFormat(buffer);
            if ((PixelFormat | 0x10) == 0x34323076)
            {
              bytesPerRowCGFloat a = PixelFormat;
              heightCGFloat a = IOSurfaceGetWidth(buffer);
              unsigned int v59 = IOSurfaceGetHeight(buffer);
              unint64_t v60 = CA::Render::format_rowbytes((CA::Render *)1, heighta);
              widthCGFloat a = v60;
              if (is_mul_ok(v60, v59)) {
                unint64_t v61 = (CA::Render *)(v60 * v59);
              }
              else {
                unint64_t v61 = 0;
              }
              unint64_t v179 = 0;
              CGAffineTransform v62 = (CGImage *)CA::Render::aligned_malloc(v61, &v179, 0);
              if (v62)
              {
                imageCGFloat a = v62;
                if (!IOSurfaceLock(buffer, 1u, 0))
                {
                  if ((bytesPerRowa | 0x10) == 0x34323076)
                  {
                    bytesPerRowCGFloat b = IOSurfaceGetBaseAddressOfPlane(buffer, 0);
                    size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(buffer, 0);
                    cCGFloat a = (CGContextRef)IOSurfaceGetBaseAddressOfPlane(buffer, 1uLL);
                    size_t v147 = IOSurfaceGetBytesPerRowOfPlane(buffer, 1uLL);
                    unsigned int v149 = CA::Render::Surface::ycbcr_matrix(v162, v63);
                    CA::Render::Surface::chroma_location((__IOSurface **)v162, v64);
                    if (bytesPerRowb)
                    {
                      if (ca && v149 <= 6)
                      {
                        memset(&outInfo, 0, sizeof(outInfo));
                        vImageConvert_YpCbCrToARGB_GenerateConversion((const vImage_YpCbCrToARGBMatrix *)&CA::convert_ycbcr420_to_argb8888_host(void const*,long,void const*,long,void *,long,long,long,int,int)::ycbcr_matrices+ v149, (const vImage_YpCbCrPixelRange *)&CA::convert_ycbcr420_to_argb8888_host(void const*,long,void const*,long,void *,long,long,long,int,int)::ycbcr_ranges+ v149, &outInfo, kvImage420Yp8_CbCr8, kvImageARGB8888, 0);
                        srcYp.datCGFloat a = bytesPerRowb;
                        srcYp.size_t height = v59;
                        srcYp.size_t width = heighta;
                        srcYp.rowBytes = BytesPerRowOfPlane;
                        srcCbCr.datCGFloat a = ca;
                        srcCbCr.size_t height = v59;
                        srcCbCr.size_t width = heighta;
                        srcCbCr.rowBytes = v147;
                        dest.datCGFloat a = imagea;
                        dest.size_t height = v59;
                        dest.size_t width = heighta;
                        dest.rowBytes = widtha;
                        *(_DWORD *)permuteMap = 66051;
                        vImageConvert_420Yp8_CbCr8ToARGB8888(&srcYp, &srcCbCr, &dest, &outInfo, permuteMap, 0xFFu, 0x10u);
                      }
                    }
                  }
                  IOSurfaceUnlock(buffer, 1u, 0);
                }
                unint64_t v65 = v179;
                *(void *)(v37 + 88) = imagea;
                *(void *)(v37 + 96) = v65;
                *(void *)(v37 + 104) = widtha;
              }
              int32x2_t v14 = v177;
            }
            if (*(void *)(v37 + 88))
            {
LABEL_67:
              CA::OGL::Context::add_buffered_image(v176, v37);
              *float v34 = 1;
            }
          }
          if (v36 == 2)
          {
            int v66 = CA::Render::format_opaque_format((CA::Render *)*v34);
            if ((v66 & 0x80000000) == 0) {
              *float v34 = v66;
            }
          }
          long long v67 = *(void **)(v37 + 88);
          if (v67)
          {
            *v170 = v67;
            *((void *)&v186[1] + 11 * v26 + 1) = *(void *)(v37 + 104);
            *float64x2_t v38 = 0;
            *((void *)v34 + 9) = 0;
          }
          else
          {
            uint64_t ProtectionOptions = IOSurfaceLock(v44, 1u, 0);
            if (ProtectionOptions)
            {
LABEL_35:
              this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)ProtectionOptions);
              *((void *)&v186[3] + 11 * v26 + 1) = this;
              float64x2_t v39 = (char *)v34 + 57;
              goto LABEL_113;
            }
            *v170 = IOSurfaceGetBaseAddress(v44);
            size_t v72 = IOSurfaceGetBytesPerRow(v44);
            long long v73 = (char *)v186 + 88 * v26;
            *((void *)v73 + 3) = v72;
            *float64x2_t v38 = CA::OGL::SW::unlock_iosurface;
            *((void *)v73 + 11) = v44;
          }
          long long v68 = (char *)v186 + 88 * v26;
          *((_DWORD *)v68 + 8) = IOSurfaceGetWidth(v44);
          long long v69 = (CA::OGL::SW *)IOSurfaceGetHeight(v44);
          *((_DWORD *)v68 + 9) = v69;
          uint64_t v70 = *v34;
          if (v70 > 0x1C) {
            this = CA::OGL::SW::incomplete_samplers(v69);
          }
          else {
            this = (uint64_t)&CA::OGL::SW::sampler_functions::samplers[16 * v70];
          }
          float64x2_t v39 = (char *)v34 + 57;
        }
        else
        {
          if (*(unsigned char *)(v41 + 12) != 9)
          {
            this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
            float64x2_t v39 = (char *)v34 + 57;
LABEL_109:
            *((void *)&v186[3] + 11 * v26 + 1) = this;
            int32x2_t v14 = v177;
            goto LABEL_113;
          }
          if (*(unsigned char *)(v41 + 176))
          {
            if (*(void *)(v37 + 88)) {
              goto LABEL_101;
            }
            unint64_t v49 = *(unsigned int *)(v41 + 20);
            size_t width = *(unsigned int *)(v41 + 16);
            unint64_t v50 = CA::Render::format_rowbytes((CA::Render *)1, *(_DWORD *)(v41 + 16));
            uint64_t v51 = (CA::Render *)(v50 * v49);
            size_t height = v49;
            if (!is_mul_ok(v50, v49)) {
              uint64_t v51 = 0;
            }
            c = v51;
            size_t bytesPerRow = v50;
            uint64_t v52 = *(void *)(v41 + 96);
            uint64_t v53 = **(void **)(v41 + 128);
            CGImageRef image = **(CGImageRef **)(v41 + 136);
            uint64_t v54 = (char *)malloc_type_malloc((size_t)image + 68, 0x580F6D12uLL);
            *((_DWORD *)v54 + 2) = 169478669;
            *(void *)uint64_t v54 = 0xBB31312058544BABLL;
            v161 = (CA::Render::Surface *)v54;
            *(_OWORD *)(v54 + 12) = xmmword_184998210;
            unsigned int v55 = *(_DWORD *)(v41 + 156) - 1;
            if (v55 > 0x1B) {
              unsigned int v56 = 0;
            }
            else {
              unsigned int v56 = dword_1849A6688[v55];
            }
            long long v74 = (const void *)(v52 + v53);
            long long v75 = (CA::Render::Surface *)v54;
            *((_DWORD *)v54 + 7) = v56;
            *((_DWORD *)v54 + 8) = 6408;
            *((_DWORD *)v54 + 9) = width;
            *((_DWORD *)v54 + 10) = height;
            *(_OWORD *)(v54 + 44) = xmmword_184998220;
            *((_DWORD *)v54 + 15) = 0;
            *((_DWORD *)v54 + 16) = image;
            memcpy(v54 + 68, v74, (size_t)image);
            *(void *)outInfo.opaque = 0;
            CFDataRef v76 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)v161, (CFIndex)image + 68, bytesDeallocator);
            bufferCGFloat a = CGImageSourceCreateWithData(v76, 0);
            CFRelease(v76);
            if (buffera)
            {
              imageCGFloat b = CGImageSourceCreateImageAtIndex(buffera, 0, 0);
              CFRelease(buffera);
              if (imageb)
              {
                long long v77 = CA::Render::aligned_malloc(c, (unint64_t *)outInfo.opaque, 0);
                if (v77)
                {
                  long long v78 = v77;
                  bufferCGFloat b = (IOSurfaceRef)v77;
                  ColorSpace = CGImageGetColorSpace(imageb);
                  cCGFloat b = CGBitmapContextCreate(v78, width, height, 8uLL, bytesPerRow, ColorSpace, 0x2002u);
                  v192.size.size_t width = (double)width;
                  v192.size.size_t height = (double)height;
                  v192.origin.x = 0.0;
                  v192.origin.y = 0.0;
                  CGContextDrawImage(cb, v192, imageb);
                  CGImageRelease(imageb);
                  CGContextRelease(cb);
                  uint64_t v80 = *(void *)outInfo.opaque;
                  *(void *)(v37 + 88) = bufferb;
                  *(void *)(v37 + 96) = v80;
                  *(void *)(v37 + 104) = bytesPerRow;
                  long long v75 = v161;
                }
                else
                {
                  CGImageRelease(imageb);
                }
              }
            }
            free(v75);
            float64x2_t v39 = (char *)v34 + 57;
            float v35 = (unsigned int *)(v34 - 2);
            if (*(void *)(v37 + 88))
            {
LABEL_101:
              long long v81 = v35;
              this = (uint64_t)CA::OGL::Context::add_buffered_image(v176, v37);
              float v35 = v81;
              float64x2_t v39 = (char *)v34 + 57;
              *float v34 = 1;
            }
          }
          if (v36 == 2)
          {
            long long v82 = v39;
            long long v83 = v35;
            this = CA::Render::format_opaque_format((CA::Render *)*v34);
            float v35 = v83;
            float64x2_t v39 = v82;
            if ((this & 0x80000000) == 0) {
              *float v34 = this;
            }
          }
          uint64_t v84 = *(void *)(v37 + 88);
          if (!v84)
          {
            long long v87 = v39;
            this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
            float64x2_t v39 = v87;
            goto LABEL_109;
          }
          long long v85 = (char *)v186 + 88 * v26;
          *((void *)v85 + 4) = *(void *)(v41 + 16);
          *(void *)float v35 = v84;
          *((void *)v85 + 3) = *(void *)(v37 + 104);
          uint64_t v86 = *v34;
          if (v86 > 0x1C)
          {
            long long v88 = v39;
            this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
            float64x2_t v39 = v88;
          }
          else
          {
            this = (uint64_t)&CA::OGL::SW::sampler_functions::samplers[16 * v86];
          }
          int32x2_t v14 = v177;
        }
        goto LABEL_112;
      }
      *(void *)float v35 = *(void *)(v41 + 96);
      float32x2_t v42 = (CA::Render *)*(unsigned __int8 *)(v41 + 152);
      *float v34 = (int)v42;
      int32x2_t v43 = (char *)v186 + 88 * v26;
      *((void *)v43 + 3) = *(void *)(v41 + 160);
      *((void *)v43 + 4) = *(void *)(v41 + 16);
      if (v36 != 2 || (this = CA::Render::format_opaque_format(v42), float64x2_t v39 = (char *)v34 + 57, (this & 0x80000000) != 0))
      {
        int32x2_t v14 = v177;
        if (v42 > 0x1C)
        {
          long long v71 = v39;
          this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
          float64x2_t v39 = v71;
          goto LABEL_112;
        }
      }
      else
      {
        *float v34 = this;
        LODWORD(v42) = this;
        int32x2_t v14 = v177;
      }
      this = (uint64_t)&CA::OGL::SW::sampler_functions::samplers[16 * (int)v42];
LABEL_112:
      *((void *)&v186[3] + 11 * v26 + 1) = this;
      goto LABEL_113;
    }
  }
  else
  {
    *(void *)&v186[0] = v13;
    *(void *)&long long v188 = 0;
  }
LABEL_192:
  BYTE8(v189) = v14[481] & 1;
  if (BYTE8(v189))
  {
    unint64_t v139 = v14[480];
    uint64_t v132 = v174;
    v131 = v175;
    uint64_t v133 = v173;
    uint64_t v135 = v171;
    unsigned int v134 = v172;
    if (v139 > 0x37) {
      uint64_t v140 = 0;
    }
    else {
      uint64_t v140 = (uint64_t)*(&off_1ED033060 + v139);
    }
    v137 = v176;
    *((void *)&v188 + 1) = v140;
    HIDWORD(v141) = bswap32(CA::OGL::ExtendedColor::word32((CA::OGL::ExtendedColor *)(v14 + 288)));
    LODWORD(v141) = HIDWORD(v141);
    LODWORD(v189) = v141 >> 8;
    HIDWORD(v141) = bswap32(CA::OGL::ExtendedColor::word32((CA::OGL::ExtendedColor *)(v14 + 296)));
    LODWORD(v141) = HIDWORD(v141);
    DWORD1(v189) = v141 >> 8;
    if (!v140) {
      BYTE8(v189) = 0;
    }
  }
  else
  {
    uint64_t v132 = v174;
    v131 = v175;
    uint64_t v133 = v173;
    uint64_t v135 = v171;
    unsigned int v134 = v172;
    if ((v14[16] & 0xFE) == 0x10)
    {
      unint64_t v136 = v14[480];
      v137 = v176;
      if (v136 > 0x37) {
        uint64_t v138 = 0;
      }
      else {
        uint64_t v138 = (uint64_t)*(&off_1ED033060 + v136);
      }
      *((void *)&v188 + 1) = v138;
      HIDWORD(v142) = bswap32(CA::OGL::ExtendedColor::word32((CA::OGL::ExtendedColor *)(v14 + 288)));
      LODWORD(v142) = HIDWORD(v142);
      LODWORD(v189) = v142 >> 8;
      if (!v138) {
        *((void *)&v188 + 1) = CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Copy,false>::blend;
      }
    }
    else
    {
      *((void *)&v188 + 1) = 0;
      v137 = v176;
    }
  }
  v143 = (float64x2_t *)*((void *)v137 + 102);
  v184[0] = &unk_1ED030E58;
  v184[1] = v186;
  v184[3] = v184;
  CA::OGL::clip_primitives(v135, v134, v133, v132, v185, v131, v143, 0, 0, (uint64_t)v184, 0);
  std::__function::__value_func<BOOL ()(CA::OGL::Vertex *,unsigned int)>::~__value_func[abi:nn180100](v184);
  unsigned int v144 = DWORD1(v188);
  if (DWORD1(v188))
  {
    v145 = (void *)&v186[5] + 1;
    do
    {
      if (v144)
      {
        v146 = (void (*)(void))*(v145 - 1);
        if (v146) {
          v146(*v145);
        }
      }
      v145 += 11;
      BOOL v95 = v144 > 1;
      v144 >>= 1;
    }
    while (v95);
  }
  CA::OGL::Context::marked_destination(v137);
  ++*((_DWORD *)v137 + 177);
}

uint64_t std::__function::__func<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::operator()(uint64_t a1, uint64_t *a2, unsigned __int32 *a3)
{
  return 1;
}

void CA::OGL::SW::draw_polygon(uint64_t a1, unsigned __int32 a2, int *a3)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(*(void *)a3 + 16);
  uint64_t v7 = a2 - 1;
  MEMORY[0x1F4188790](a1);
  uint64_t v10 = (float32x4_t *)(((unint64_t)&v65 - v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v10)
  {
    bzero((char *)&v65 - v9, v8);
    v10->i32[0] = a2;
    if (a3[73]) {
      int v11 = 779;
    }
    else {
      int v11 = 11;
    }
    v10->i32[1] = v11;
    int v12 = a3[73];
    int v13 = v11 | 0xC00;
    if ((v12 & 2) == 0) {
      int v13 = v11;
    }
    int v14 = v13 | 0x3000;
    if ((v12 & 4) == 0) {
      int v14 = v13;
    }
    if ((v12 & 6) != 0)
    {
      v10->i32[1] = v14;
      int v11 = v14;
    }
    uint64_t v15 = *(void *)(a1 + 32);
    if (!*(unsigned char *)(v6 + 480)) {
      uint64_t v15 = 0;
    }
    uint64_t v66 = v15;
    if (!a2) {
      goto LABEL_35;
    }
    uint64_t v16 = 0;
    int v17 = (float *)(a1 + 20);
    int v18 = &v10[3].f32[1];
    uint64_t v19 = a2;
    do
    {
      int v20 = (uint64_t *)(a1 + 48 * v16);
      uint64_t v21 = *v20;
      float v22 = *((float *)v20 + 3);
      float v23 = 1.0;
      if (v22 != 1.0)
      {
        int v11 = v14 | 4;
        v10->i32[1] = v14 | 4;
        v14 |= 4u;
        float v23 = 1.0 / v22;
      }
      uint64_t v24 = &v10[4 * v16];
      v24[1].i64[0] = v21;
      v24[1].f32[2] = v22;
      v24[1].f32[3] = v23;
      v24[2] = 0uLL;
      v24[3] = 0uLL;
      v24[4] = 0uLL;
      if ((v14 & 0xF0) == 0 && *(void *)(a1 + 48 * v16 + 32) != v15 && *(unsigned char *)(v6 + 480) != 0)
      {
        unsigned int v26 = *(unsigned __int8 *)(v6 + 16);
        if (v26 <= 0x10 && ((1 << v26) & 0x138E9) != 0)
        {
          int v11 = v14 | 0xF0;
          v10->i32[1] = v14 | 0xF0;
          v14 |= 0xF0u;
        }
      }
      unsigned int v27 = a3[73];
      if (v27)
      {
        uint64_t v28 = (float *)(v6 + 108);
        float32x2_t v29 = v18;
        float32x2_t v30 = v17;
        do
        {
          if (v27)
          {
            *(v29 - 1) = *(v28 - 1) + (float)(*(v28 - 3) * *(v30 - 1));
            *float32x2_t v29 = *v28 + (float)(*(v28 - 2) * *v30);
          }
          v30 += 2;
          v29 += 2;
          v28 += 4;
          BOOL v31 = v27 > 1;
          v27 >>= 1;
        }
        while (v31);
      }
      ++v16;
      v17 += 12;
      v18 += 16;
    }
    while (v16 != a2);
    if ((v14 & 0xF0) != 0)
    {
      uint64_t v32 = v10 + 2;
      unsigned int v33 = (float16x4_t *)(a1 + 32);
      do
      {
        float16x4_t v34 = *v33;
        v33 += 6;
        *uint64_t v32 = vcvtq_f32_f16(v34);
        v32 += 4;
        --v19;
      }
      while (v19);
    }
    else
    {
LABEL_35:
      LOWORD(v66) = WORD2(v15);
      WORD1(v66) = WORD1(v15);
      WORD2(v66) = v15;
      HIWORD(v66) = HIWORD(v15);
    }
    int v35 = CA::OGL::ExtendedColor::word32((CA::OGL::ExtendedColor *)&v66);
    f32 = v10[4 * v7].f32;
    float v37 = f32[4];
    float v38 = f32[5];
    if ((v11 & 8) != 0)
    {
      float v39 = f32[7];
      float v37 = v39 * v37;
      float v38 = v39 * v38;
    }
    if (a2)
    {
      uint64_t v40 = 0;
      uint64_t v41 = &v10[1].f32[3];
      float v42 = 0.0;
      int v43 = -1;
      float v44 = INFINITY;
      float v45 = -INFINITY;
      float v46 = -INFINITY;
      float v47 = INFINITY;
      do
      {
        float v48 = *(v41 - 3);
        float v49 = *(v41 - 2);
        if ((v11 & 8) != 0)
        {
          float v48 = *v41 * v48;
          float v49 = *v41 * v49;
        }
        float v42 = (float)(v42 - (float)(v48 * v38)) + (float)(v49 * v37);
        if (v49 < v44)
        {
          int v43 = v40;
          float v44 = v49;
        }
        if (v49 > v45) {
          float v45 = v49;
        }
        if (v48 < v47) {
          float v47 = v48;
        }
        ++v40;
        if (v48 > v46) {
          float v46 = v48;
        }
        v41 += 16;
        float v38 = v49;
        float v37 = v48;
      }
      while (a2 != v40);
      float v50 = v42 * 0.5;
    }
    else
    {
      int v43 = -1;
      float v50 = 0.0;
      float v46 = -INFINITY;
      float v47 = INFINITY;
      float v44 = INFINITY;
      float v45 = -INFINITY;
    }
    if (fabsf(v50) >= 0.00005)
    {
      int v51 = a3[69];
      if (v45 >= (float)v51)
      {
        int v52 = a3[71];
        if (v44 < (float)v52 && v46 >= (float)a3[68] && v47 < (float)a3[70])
        {
          if ((v11 & 4) != 0)
          {
            if (a2)
            {
              uint64_t v54 = 0;
              do
              {
                if ((v11 & 0xFFFFFF03) != 0)
                {
                  unsigned int v55 = &v10[4 * v54];
                  float v56 = v55[1].f32[3];
                  int v57 = v55[1].f32;
                  unsigned int v58 = v11 & 0xFFFFFF03;
                  do
                  {
                    if (v58) {
                      *int v57 = *v57 * v56;
                    }
                    ++v57;
                    BOOL v31 = v58 > 1;
                    v58 >>= 1;
                  }
                  while (v31);
                }
                ++v54;
              }
              while (v54 != a2);
            }
            v11 &= ~4u;
            v10->i32[1] = v11;
            char v53 = 1;
          }
          else
          {
            char v53 = 0;
          }
          unsigned int v59 = vcvtps_s32_f32(v44 + -0.5);
          if ((float)(v44 - ceilf(v44 + -0.5)) == 0.5) {
            ++v59;
          }
          unsigned int v65 = v59;
          signed int v60 = vcvtms_s32_f32(v44);
          signed int v61 = vcvtps_s32_f32(v45);
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 0x40000000;
          block[2] = ___ZN2CA3OGL2SW12scan_convertEPKNS1_11RenderStateEPNS1_4PolyEj_block_invoke;
          block[3] = &__block_descriptor_tmp_6622;
          if (v51 <= v60) {
            int v51 = v60;
          }
          block[4] = a3;
          block[5] = v10;
          if (v52 >= v61) {
            int v52 = v61;
          }
          unsigned int v68 = v11 & 0xFFFFFFFD;
          int v69 = v35;
          int v62 = v52 - v51 + 3;
          if (v52 >= v51) {
            int v62 = v52 - v51;
          }
          float v70 = v50;
          unsigned int v63 = v62 >> 2;
          if (v52 - v51 <= 7) {
            size_t v64 = 1;
          }
          else {
            size_t v64 = v63;
          }
          int v71 = v43;
          unsigned int v72 = v59;
          int v73 = 4;
          int v74 = v51;
          int v75 = v52;
          unsigned int v76 = v59;
          char v77 = v53;
          __int16 v78 = 0;
          char v79 = 0;
          dispatch_apply(v64, 0, block);
        }
      }
    }
  }
}

uint64_t ___ZN2CA3OGL2SW12scan_convertEPKNS1_11RenderStateEPNS1_4PolyEj_block_invoke(uint64_t a1, double a2, float32x4_t a3, double a4, double a5, double a6)
{
  uint64_t v137 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = *(int **)(a1 + 40);
  uint64_t result = a1 + 32;
  v10.i32[1] = 0;
  float32x4_t v131 = 0u;
  float32x4_t v132 = 0u;
  float32x4_t v129 = 0u;
  float32x4_t v130 = 0u;
  float32x4_t v127 = 0u;
  float32x4_t v128 = 0u;
  float32x4_t v125 = 0u;
  float32x4_t v126 = 0u;
  float32x4_t v123 = 0u;
  float32x4_t v124 = 0u;
  float32x4_t v121 = 0u;
  float32x4_t v122 = 0u;
  float32x4_t v119 = 0u;
  float32x4_t v120 = 0u;
  float32x4_t v117 = 0u;
  float32x4_t v118 = 0u;
  uint64_t v11 = *v9;
  if ((int)v11 >= 1)
  {
    signed int v12 = *(_DWORD *)(result + 32);
    int v13 = *(_DWORD *)(result + 44);
    if (v12 < v13)
    {
      unsigned int v14 = *(_DWORD *)(result + 16);
      signed int v15 = v12 - 1;
      int v16 = *(_DWORD *)(a1 + 60);
      unsigned int v17 = v14 & 0xFFFFFFFE;
      unsigned int v18 = v14 & 0xFFFFFFFA | 4;
      long long v19 = 0uLL;
      int v20 = *(_DWORD *)(result + 32);
      signed int v21 = v12 - 1;
      int v22 = v16;
      int v23 = v20;
      while (2)
      {
        if (v21 <= v23)
        {
          do
          {
            int v25 = v22;
            if (v22 < 1) {
              int v25 = *v9;
            }
            int v26 = v25 - 1;
            unsigned int v27 = (float *)&v9[16 * (uint64_t)(v25 - 1) + 4];
            float v28 = v27[1];
            float32x2_t v29 = (float *)&v9[16 * (uint64_t)v22 + 4];
            float v30 = v29[1];
            *(float *)&a6 = 1.0 / (float)(v28 - v30);
            if ((float)(v28 - v30) == 0.0) {
              float v31 = 1.0;
            }
            else {
              float v31 = 1.0 / (float)(v28 - v30);
            }
            if (v14)
            {
              float v32 = (float)((float)v23 + 0.5) - v30;
              unsigned int v33 = &v129;
              float16x4_t v34 = &v121;
              unsigned int v35 = v14;
              do
              {
                if (v35)
                {
                  float v36 = *v29;
                  float32_t v37 = (float)(*v27 - *v29) * v31;
                  v34->f32[0] = v37;
                  *(float *)&a6 = v36 + (float)(v37 * v32);
                  v33->i32[0] = LODWORD(a6);
                }
                ++v29;
                ++v27;
                unsigned int v33 = (float32x4_t *)((char *)v33 + 4);
                float16x4_t v34 = (float32x4_t *)((char *)v34 + 4);
                BOOL v38 = v35 > 1;
                v35 >>= 1;
              }
              while (v38);
            }
            uint64_t v24 = (v11 - 1);
            signed int v21 = vcvtms_s32_f32(v28 + 0.5);
            BOOL v38 = v23 < v21 || (int)v11 <= 1;
            LODWORD(v11) = v11 - 1;
            int v22 = v26;
          }
          while (!v38);
          int v22 = v26;
        }
        else
        {
          uint64_t v24 = v11;
        }
        if (v15 > v23 || (int)v24 < 1)
        {
          uint64_t v11 = v24;
        }
        else
        {
          int v39 = *v9;
          float v40 = *(float *)&v9[16 * (uint64_t)v16 + 5];
          do
          {
            if (v16 + 1 < v39) {
              int v41 = v16 + 1;
            }
            else {
              int v41 = 0;
            }
            float v42 = *(float *)&v9[16 * (uint64_t)v41 + 5];
            *(float *)&a6 = 1.0 / (float)(v42 - v40);
            if ((float)(v42 - v40) == 0.0) {
              float v43 = 1.0;
            }
            else {
              float v43 = 1.0 / (float)(v42 - v40);
            }
            if (v14)
            {
              float v44 = (float)((float)v23 + 0.5) - v40;
              float v45 = (float *)&v9[16 * (uint64_t)v41 + 4];
              float v46 = &v125;
              float v47 = &v117;
              unsigned int v48 = v14;
              float v49 = (float *)&v9[16 * (uint64_t)v16 + 4];
              do
              {
                if (v48)
                {
                  float v50 = *v49;
                  float32_t v51 = (float)(*v45 - *v49) * v43;
                  v47->f32[0] = v51;
                  *(float *)&a6 = v50 + (float)(v51 * v44);
                  v46->i32[0] = LODWORD(a6);
                }
                ++v49;
                ++v45;
                float v46 = (float32x4_t *)((char *)v46 + 4);
                float v47 = (float32x4_t *)((char *)v47 + 4);
                BOOL v38 = v48 > 1;
                v48 >>= 1;
              }
              while (v38);
            }
            signed int v15 = vcvtms_s32_f32(v42 + 0.5);
            uint64_t v11 = (v24 - 1);
            BOOL v52 = v23 < v15 || (int)v24 <= 1;
            float v40 = v42;
            LODWORD(v24) = v24 - 1;
            int v16 = v41;
          }
          while (!v52);
          int v16 = v41;
        }
        if (v21 >= v15) {
          signed int v53 = v15;
        }
        else {
          signed int v53 = v21;
        }
        if (v53 >= v13) {
          int v54 = v13;
        }
        else {
          int v54 = v53;
        }
        while (v23 < v54)
        {
          if (v23 >= v12)
          {
            do
            {
              int v55 = *(_DWORD *)(a1 + 80);
              int v56 = *(_DWORD *)(a1 + 76);
              if (v55 >= v56) {
                return result;
              }
              int v57 = *(_DWORD *)(a1 + 68);
              if (v55 <= *(_DWORD *)(a1 + 72)) {
                int v20 = *(_DWORD *)(a1 + 72);
              }
              else {
                int v20 = *(_DWORD *)(a1 + 80);
              }
              if (v20 + v57 >= v56) {
                signed int v12 = *(_DWORD *)(a1 + 76);
              }
              else {
                signed int v12 = v20 + v57;
              }
              int v58 = *(_DWORD *)(a1 + 80);
              atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 80), (unsigned int *)&v58, v12);
            }
            while (v58 != v55);
          }
          if (v23 >= v20)
          {
            float v67 = v129.f32[0];
            if (v129.f32[0] <= v125.f32[0]) {
              a3.f32[0] = v129.f32[0];
            }
            else {
              a3.f32[0] = v125.f32[0];
            }
            if (v129.f32[0] <= v125.f32[0]) {
              unsigned int v68 = &v129;
            }
            else {
              unsigned int v68 = &v125;
            }
            if (v129.f32[0] > v125.f32[0])
            {
              int v69 = &v129;
            }
            else
            {
              float v67 = v125.f32[0];
              int v69 = &v125;
            }
            signed int v70 = vcvtps_s32_f32(a3.f32[0] + -0.5);
            *(float *)&a5 = floorf(v67 + -0.5);
            signed int v71 = vcvtms_s32_f32(v67 + -0.5) - ((float)(v67 - *(float *)&a5) == 0.5);
            if (*(_DWORD *)(v8 + 272) <= v70) {
              int v72 = v70;
            }
            else {
              int v72 = *(_DWORD *)(v8 + 272);
            }
            signed int v73 = *(_DWORD *)(v8 + 280);
            if (v71 >= v73) {
              signed int v74 = v73 - 1;
            }
            else {
              signed int v74 = v71;
            }
            BOOL v75 = __OFSUB__(v74, v72);
            int v76 = v74 - v72;
            if (v76 < 0 == v75)
            {
              signed int v106 = v53;
              v116[2] = v19;
              v116[3] = v19;
              v116[0] = v19;
              v116[1] = v19;
              v115[2] = v19;
              v115[3] = v19;
              v115[0] = v19;
              v115[1] = v19;
              v114[2] = v19;
              v114[3] = v19;
              v114[0] = v19;
              v114[1] = v19;
              v113[2] = v19;
              v113[3] = v19;
              v113[0] = v19;
              v113[1] = v19;
              if (*(unsigned char *)(a1 + 84)) {
                unsigned int v77 = v18;
              }
              else {
                unsigned int v77 = v17;
              }
              float v78 = v67 - a3.f32[0];
              *(float *)&a4 = 1.0 / v78;
              if (v78 == 0.0) {
                *(float *)&a4 = 1.0;
              }
              v10.f32[0] = (float)v72 + 0.5;
              if (v77)
              {
                char v79 = v116;
                a3.f32[0] = v10.f32[0] - a3.f32[0];
                uint64_t v80 = (float *)v115;
                long long v81 = (float *)v69;
                long long v82 = v68;
                unsigned int v83 = v77;
                do
                {
                  if (v83)
                  {
                    LODWORD(a6) = v82->i32[0];
                    float v84 = (float)(*v81 - v82->f32[0]) * *(float *)&a4;
                    *uint64_t v80 = v84;
                    *(float *)&a5 = *(float *)&a6 + (float)(v84 * a3.f32[0]);
                    *char v79 = LODWORD(a5);
                  }
                  long long v82 = (float32x4_t *)((char *)v82 + 4);
                  ++v81;
                  ++v79;
                  ++v80;
                  BOOL v38 = v83 > 1;
                  v83 >>= 1;
                }
                while (v38);
              }
              int8x16_t v110 = (unsigned int *)v9;
              uint64_t v111 = v8;
              unsigned int v108 = v17;
              int v109 = v13;
              unsigned int v107 = v18;
              if (*(unsigned char *)(v8 + 288))
              {
                uint64_t v87 = 0;
                v136[2] = v19;
                v136[3] = v19;
                v136[0] = v19;
                v136[1] = v19;
                unsigned int v88 = v77 | 1;
                unsigned int v89 = v77 | 1;
                do
                {
                  if (v89) {
                    *(float *)((char *)v136 + v87 * 4) = v121.f32[v87] + v68->f32[v87];
                  }
                  ++v87;
                  BOOL v38 = v89 > 1;
                  v89 >>= 1;
                }
                while (v38);
                uint64_t v90 = 0;
                v135[2] = v19;
                v135[3] = v19;
                v135[0] = v19;
                v135[1] = v19;
                do
                {
                  if (v88) {
                    *(float *)((char *)v135 + v90 * 4) = v117.f32[v90] + v69->f32[v90];
                  }
                  ++v90;
                  BOOL v38 = v88 > 1;
                  v88 >>= 1;
                }
                while (v38);
                LODWORD(a4) = v136[0];
                *(float *)&a5 = 1.0 / (float)(*(float *)v135 - *(float *)v136);
                if ((float)(*(float *)v135 - *(float *)v136) == 0.0) {
                  a3.f32[0] = 1.0;
                }
                else {
                  a3.f32[0] = 1.0 / (float)(*(float *)v135 - *(float *)v136);
                }
                if (v77)
                {
                  v10.f32[0] = v10.f32[0] - *(float *)v136;
                  v134[2] = v19;
                  v134[3] = v19;
                  v134[0] = v19;
                  v134[1] = v19;
                  v133[0] = v19;
                  v133[1] = v19;
                  uint64_t v91 = v136;
                  v92 = (float *)v135;
                  uint64_t v93 = v134;
                  v94 = (float *)v133;
                  unsigned int v95 = v77;
                  v133[2] = v19;
                  v133[3] = v19;
                  do
                  {
                    if (v95)
                    {
                      LODWORD(a5) = *v91;
                      float v96 = (float)(*v92 - *(float *)v91) * a3.f32[0];
                      float *v94 = v96;
                      *(float *)&a4 = *(float *)&a5 + (float)(v96 * v10.f32[0]);
                      *uint64_t v93 = LODWORD(a4);
                    }
                    ++v91;
                    ++v92;
                    ++v93;
                    ++v94;
                    BOOL v38 = v95 > 1;
                    v95 >>= 1;
                  }
                  while (v38);
                  uint64_t v97 = v114;
                  int8x16_t v98 = (float *)v134;
                  v99 = (unsigned __int32 *)v116;
                  unsigned int v100 = v77;
                  do
                  {
                    if (v100)
                    {
                      a3.i32[0] = *v99;
                      v10.f32[0] = *v98 - *(float *)v99;
                      *uint64_t v97 = v10.i32[0];
                    }
                    ++v97;
                    ++v98;
                    ++v99;
                    BOOL v38 = v100 > 1;
                    v100 >>= 1;
                  }
                  while (v38);
                  v101 = v113;
                  v102 = (float *)v133;
                  v103 = (unsigned __int32 *)v115;
                  unsigned int v104 = v77;
                  do
                  {
                    if (v104)
                    {
                      a3.i32[0] = *v103;
                      v10.f32[0] = *v102 - *(float *)v103;
                      _DWORD *v101 = v10.i32[0];
                    }
                    ++v101;
                    ++v102;
                    ++v103;
                    BOOL v38 = v104 > 1;
                    v104 >>= 1;
                  }
                  while (v38);
                }
                uint64_t v86 = (const unsigned int *)v113;
                long long v85 = v114;
              }
              else
              {
                long long v85 = 0;
                uint64_t v86 = 0;
              }
              uint64_t v112 = result;
              CA::OGL::SW::scanline((uint64_t *)result, v72, v23, (const CA::ColorProgram::Program *)(v76 + 1), (float *)v116, (uint64_t)v115, (uint64_t)v85, v86, *(double *)v10.i64, *(double *)a3.i64, a4, a5, a6, v77);
              uint64_t v8 = v111;
              uint64_t result = v112;
              uint64_t v9 = (int *)v110;
              unsigned int v17 = v108;
              int v13 = v109;
              signed int v53 = v106;
              unsigned int v18 = v107;
              long long v19 = 0uLL;
              int v54 = v105;
            }
            float32x4_t v129 = vaddq_f32(v129, v121);
            float32x4_t v130 = vaddq_f32(v130, v122);
            float32x4_t v131 = vaddq_f32(v131, v123);
            float32x4_t v132 = vaddq_f32(v132, v124);
            float32x4_t v125 = vaddq_f32(v125, v117);
            float32x4_t v126 = vaddq_f32(v126, v118);
            HIDWORD(a4) = v127.i32[1];
            HIDWORD(a5) = v128.i32[1];
            float32x4_t v10 = vaddq_f32(v127, v119);
            a3 = vaddq_f32(v128, v120);
            ++v23;
            float32x4_t v127 = v10;
            float32x4_t v128 = a3;
          }
          else
          {
            if (v53 >= v20) {
              int v59 = v20;
            }
            else {
              int v59 = v53;
            }
            float32x4_t v10 = v129;
            a3 = v125;
            int v60 = v59 - v23;
            if (v59 > v23)
            {
              HIDWORD(a4) = v121.i32[1];
              HIDWORD(a5) = v122.i32[1];
              a6 = *(double *)v123.i64;
              float32x4_t v62 = v130;
              float32x4_t v61 = v131;
              float32x4_t v63 = v132;
              float32x4_t v65 = v126;
              float32x4_t v64 = v127;
              float32x4_t v66 = v128;
              do
              {
                float32x4_t v10 = vaddq_f32(v10, v121);
                float32x4_t v62 = vaddq_f32(v62, v122);
                float32x4_t v61 = vaddq_f32(v61, v123);
                float32x4_t v63 = vaddq_f32(v63, v124);
                a3 = vaddq_f32(a3, v117);
                float32x4_t v65 = vaddq_f32(v65, v118);
                float32x4_t v64 = vaddq_f32(v64, v119);
                float32x4_t v66 = vaddq_f32(v66, v120);
                --v60;
              }
              while (v60);
              float32x4_t v130 = v62;
              float32x4_t v131 = v61;
              float32x4_t v132 = v63;
              float32x4_t v126 = v65;
              float32x4_t v127 = v64;
              int v23 = v59;
              float32x4_t v128 = v66;
            }
            float32x4_t v129 = v10;
            float32x4_t v125 = a3;
          }
        }
        if ((int)v11 >= 1 && v23 < v13) {
          continue;
        }
        break;
      }
    }
  }
  return result;
}

void CA::OGL::SW::scanline(uint64_t *a1, int a2, int a3, const CA::ColorProgram::Program *a4, float *a5, uint64_t a6, uint64_t a7, const unsigned int *a8, double a9, double a10, double a11, double a12, double a13, unsigned int a14)
{
  v419 = (float *)a8;
  uint64_t v15 = a6;
  int v16 = a5;
  uint64_t v439 = *MEMORY[0x1E4F143B8];
  uint64_t v427 = *a1;
  uint64_t v19 = *(void *)v427;
  uint64_t v20 = *(void *)(*(void *)v427 + 1864);
  if (v20) {
    signed int v21 = (unsigned int *)(v20
  }
                         + *(void *)(v19 + 1880) * (a3 - (uint64_t)*(int *)(v19 + 1912))
                         + ((a2 - *(_DWORD *)(v19 + 1904)) * *(_DWORD *)(v19 + 1900)));
  else {
    signed int v21 = 0;
  }
  uint64_t v22 = *(void *)(v19 + 1872);
  if (v22) {
    BOOL v23 = v22 == v20;
  }
  else {
    BOOL v23 = 1;
  }
  if (v23) {
    uint64_t v24 = 0;
  }
  else {
    uint64_t v24 = (unsigned __int8 *)(v22
  }
                            + *(void *)(v19 + 1888) * (a3 - (uint64_t)*(int *)(v19 + 1912))
                            - *(int *)(v19 + 1904)
                            + a2);
  unsigned int v425 = a14;
  int v25 = *(unsigned char **)(v19 + 16);
  uint64_t v424 = v19;
  v421 = v25;
  if (v21 && (*(_DWORD *)(v19 + 1896) == 32 ? (BOOL v26 = v24 == 0) : (BOOL v26 = 0), v26))
  {
    unsigned int v27 = 0;
  }
  else
  {
    MEMORY[0x1F4188790](a1);
    unsigned int v27 = (unsigned int *)v399;
    bzero(v399, 0x400uLL);
    int v25 = v421;
  }
  int v28 = *(_DWORD *)(v427 + 292);
  int v414 = v28;
  if (v28)
  {
    char v29 = v425;
    if (v28)
    {
      v420 = (unsigned __int8 *)(v427 + 8);
      if (*(unsigned char *)(v427 + 312)) {
        BOOL v31 = 0;
      }
      else {
        BOOL v31 = (v425 & 0xF0) == 0;
      }
      if (v31 && v27 == 0 && v28 == 1)
      {
        int v394 = v25[16];
        if (v394 == 1 || v394 == 3 && *((_DWORD *)a1 + 5) == -1)
        {
          uint64_t v395 = a7;
          v396 = v25;
          CA::OGL::SW::sample_texture(v424, (uint64_t)v420, 0, v425, (uint64_t)v16, v15, v395, (uint64_t)v419, v25[19], a4, (uint64_t)v21);
          v398 = (float **)*((void *)v396 + 5);
          if (v398) {
            CA::OGL::SW::tex_color_match(v398, a4, v21, v397);
          }
          return;
        }
      }
    }
    else
    {
      v420 = 0;
    }
  }
  else
  {
    v420 = 0;
    char v29 = v425;
    if (!v27 && !*(unsigned char *)(v427 + 312) && v25[16] != 13)
    {
      if ((v425 & 0xF0) != 0) {
        CA::OGL::SW::sample_color(v425, v16, v15, a4, (uint64_t)v21);
      }
      else {
        CGBlt_fillBytes();
      }
      return;
    }
  }
  v422 = (float *)a7;
  uint64_t v34 = v427 + 88 * (v25[17] != 38) + 8;
  uint64_t v411 = v34;
  if ((v414 & 2) != 0) {
    uint64_t v35 = v34;
  }
  else {
    uint64_t v35 = 0;
  }
  uint64_t v412 = v35;
  int v418 = v29 & 0xF0;
  if ((v29 & 0xF0) != 0)
  {
    MEMORY[0x1F4188790](a1);
    bzero(&v400 - 130, 0x40FuLL);
    float v36 = (unsigned int *)(((unint64_t)&v400 - 1025) & 0xFFFFFFFFFFFFFFF0);
  }
  else
  {
    float v36 = (unsigned int *)a1 + 5;
  }
  v416 = v36;
  uint64_t v37 = v424;
  if (*(unsigned char *)(v427 + 312))
  {
    MEMORY[0x1F4188790](a1);
    v426 = (unsigned int *)v399;
    bzero(v399, 0x400uLL);
  }
  else
  {
    v426 = 0;
  }
  BOOL v38 = v420;
  if (v420)
  {
    MEMORY[0x1F4188790](a1);
    bzero(&v400 - 130, 0x40FuLL);
    BOOL v38 = (unsigned __int8 *)(((unint64_t)&v400 - 1025) & 0xFFFFFFFFFFFFFFF0);
  }
  v417 = v38;
  char v39 = v414;
  if ((v414 & 2) != 0)
  {
    MEMORY[0x1F4188790](a1);
    bzero(&v400 - 130, 0x40FuLL);
    char v39 = v414;
    v413 = (unsigned __int8 *)(((unint64_t)&v400 - 1025) & 0xFFFFFFFFFFFFFFF0);
  }
  else
  {
    v413 = 0;
  }
  uint64_t v40 = v425;
  if ((int)a4 >= 1)
  {
    v406 = (float32x2_t *)(v37 + 1984);
    v415 = (void (*)(unsigned int *, const unsigned int *, const unsigned int *, unint64_t, const unsigned int *))(v427 + 304);
    v405 = &v435;
    v404 = &v437;
    uint64_t v41 = (int)a4;
    while (1)
    {
      uint64_t v423 = v41 - 256;
      if (v41 >= 256) {
        int v42 = 256;
      }
      else {
        int v42 = v41;
      }
      if ((int)v41 >= 256) {
        uint64_t v43 = 256;
      }
      else {
        uint64_t v43 = v41;
      }
      if (v27) {
        float v44 = v27;
      }
      else {
        float v44 = v21;
      }
      float v45 = v426;
      if (!*(unsigned char *)(v427 + 312)) {
        float v45 = v44;
      }
      v426 = v45;
      float v46 = v421;
      if (v420)
      {
        if (*(_DWORD *)(v427 + 292) == 1)
        {
          int v47 = v421[16];
          if (v47 == 1 || !v418 && v47 == 3 && *v416 == -1)
          {
            unsigned int v48 = v421;
            CA::OGL::SW::sample_texture(v424, (uint64_t)v420, 0, v40, (uint64_t)v16, v15, (uint64_t)v422, (uint64_t)v419, v421[19], v43, (uint64_t)v426);
            float v50 = (float **)*((void *)v48 + 5);
            if (v50) {
              CA::OGL::SW::tex_color_match(v50, (const CA::ColorProgram::Program *)v43, v426, v49);
            }
            goto LABEL_101;
          }
        }
        float32_t v51 = v24;
        BOOL v52 = v421;
        if (v421[17] == 38) {
          memcpy(v417, v21, 4 * v43);
        }
        else {
          CA::OGL::SW::sample_texture(v424, (uint64_t)v420, 0, v40, (uint64_t)v16, v15, (uint64_t)v422, (uint64_t)v419, v421[19], v43, (uint64_t)v417);
        }
        int v54 = (float **)*((void *)v52 + 5);
        uint64_t v40 = v425;
        float v46 = v52;
        uint64_t v24 = v51;
        char v39 = v414;
        if (v54)
        {
          CA::OGL::SW::tex_color_match(v54, (const CA::ColorProgram::Program *)v43, (unsigned int *)v417, v53);
          float v46 = v421;
          uint64_t v40 = v425;
        }
      }
      if ((v39 & 2) != 0)
      {
        int v55 = v46[20];
        if (v55 != 4)
        {
          if (v46[18] == 38) {
            memcpy(v413, v21, 4 * v43);
          }
          else {
            CA::OGL::SW::sample_texture(v424, v411, 1u, v40, (uint64_t)v16, v15, (uint64_t)v422, (uint64_t)v419, v55, v43, (uint64_t)v413);
          }
          float v46 = v421;
          int v57 = (float **)*((void *)v421 + 6);
          uint64_t v40 = v425;
          if (v57)
          {
            CA::OGL::SW::tex_color_match(v57, (const CA::ColorProgram::Program *)v43, (unsigned int *)v413, v56);
            float v46 = v421;
            uint64_t v40 = v425;
          }
        }
      }
      int v58 = v46[16];
      if (v58 == 13)
      {
        if (!v418)
        {
          unint64_t v74 = *v416;
          unint64_t v75 = ((((v74 | (v74 << 24)) & 0xFF00FF00FF00FFLL) + ((v74 | (v74 << 24)) & 0xFF00FF00FF00FFLL) * (v74 >> 24)) >> 8) & 0xFF00FF00FF00FFLL;
          LODWORD(__pattern4) = v74 & 0xFF000000 | ((v75 >> 24) | v75) & 0xFFFFFF;
LABEL_100:
          memset_pattern4(v426, &__pattern4, (4 * v43));
          goto LABEL_101;
        }
        CA::OGL::SW::sample_color(v40, v16, v15, v43, (uint64_t)v416);
        if (v43)
        {
          uint64_t v59 = v43;
          int v60 = v416;
          float32x4_t v61 = v426;
          do
          {
            unsigned int v62 = *v60++;
            unint64_t v63 = (v62 | ((unint64_t)v62 << 24)) & 0xFF00FF00FF00FFLL;
            unint64_t v64 = ((v63 + v63 * ((unint64_t)v62 >> 24)) >> 8) & 0xFF00FF00FF00FFLL;
            *v61++ = (v64 >> 24) | v64;
            --v59;
          }
          while (v59);
          float32x4_t v65 = (int *)v426;
          float32x4_t v66 = v416;
          uint64_t v67 = v43;
          do
          {
            int v68 = *v65;
            *v65 &= 0xFFFFFFu;
            *v65++ = v68 & 0xFFFFFF | (*((unsigned __int8 *)v66++ + 3) << 24);
            --v67;
          }
          while (v67);
        }
      }
      else
      {
        if (!v46[16])
        {
          if (v418)
          {
            CA::OGL::SW::sample_color(v40, v16, v15, v43, (uint64_t)v426);
            goto LABEL_101;
          }
          LODWORD(__pattern4) = *v416;
          goto LABEL_100;
        }
        if (*(_DWORD *)(v427 + 292))
        {
          if (v418)
          {
            CA::OGL::SW::sample_color(v425, v16, v15, v43, (uint64_t)v416);
            int v58 = v421[16];
          }
          int v69 = &qword_184997000;
          signed int v70 = &off_184996000;
          switch(v58)
          {
            case 1:
              size_t v71 = 4 * v43;
              int v72 = v426;
              signed int v73 = v417;
              goto LABEL_157;
            case 2:
              uint64_t v110 = 0;
              signed int v73 = v417;
              do
              {
                unsigned int v111 = v73[v110];
                float v112 = (float)HIBYTE(v111);
                float v113 = v112 * 0.0039216;
                float v115 = 255.0 / v112;
                if (v113 <= 0.001) {
                  float v115 = 1000.0;
                }
                float v114 = (float)v73[v110];
                signed int v116 = (float)(v115 * v114) & ~((int)(float)(v115 * v114) >> 31);
                if (v116 >= 255) {
                  signed int v116 = 255;
                }
                int32x2_t v117 = (int32x2_t)vshl_u32((uint32x2_t)vmin_s32(vmax_s32((int32x2_t)vcvt_u32_f32(vmul_n_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v111), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), v115)), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
                v73[v110++] = vorr_s8((int8x8_t)v117, (int8x8_t)vdup_lane_s32(v117, 1)).u32[0] | v116 | 0xFF000000;
              }
              while (v42 != v110);
              size_t v71 = 4 * v43;
              int v72 = v426;
LABEL_157:
              memcpy(v72, v73, v71);
              break;
            case 3:
              if (v418)
              {
                float32x4_t v118 = v426;
                float32x4_t v119 = (unsigned int *)v417;
                goto LABEL_168;
              }
              v346 = (const unsigned int *)*v416;
              v347 = v426;
              float32x4_t v119 = (unsigned int *)v417;
              goto LABEL_322;
            case 4:
              uint64_t v120 = 0;
              float32x4_t v119 = (unsigned int *)v417;
              do
              {
                unsigned int v121 = v119[v120];
                float v122 = (float)HIBYTE(v121);
                float v123 = v122 * 0.0039216;
                float v125 = 255.0 / v122;
                if (v123 <= 0.001) {
                  float v125 = 1000.0;
                }
                float v124 = (float)v119[v120];
                signed int v126 = (float)(v125 * v124) & ~((int)(float)(v125 * v124) >> 31);
                if (v126 >= 255) {
                  signed int v126 = 255;
                }
                int32x2_t v127 = (int32x2_t)vshl_u32((uint32x2_t)vmin_s32(vmax_s32((int32x2_t)vcvt_u32_f32(vmul_n_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v121), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), v125)), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
                v119[v120++] = vorr_s8((int8x8_t)v127, (int8x8_t)vdup_lane_s32(v127, 1)).u32[0] | v126 | 0xFF000000;
              }
              while (v42 != v120);
              if (v418)
              {
                float32x4_t v118 = v426;
LABEL_168:
                CA::OGL::SW::tex_multiply_color(v118, v119, v416, (const unsigned int *)v43);
              }
              else
              {
                v346 = (const unsigned int *)*v416;
                v347 = v426;
LABEL_322:
                CA::OGL::SW::tex_multiply_color(v347, v119, v346, v43);
              }
              break;
            case 5:
              if (v418)
              {
                if (v43)
                {
                  float32x4_t v128 = v426;
                  float32x4_t v129 = (unsigned int *)v417;
                  float32x4_t v130 = v413;
                  float32x4_t v131 = v416;
                  uint64_t v132 = v43;
                  do
                  {
                    unsigned int v134 = *v131++;
                    unsigned int v133 = v134;
                    unsigned int v135 = *v129++;
                    HIDWORD(a12) = 255;
                    a9 = COERCE_DOUBLE(vand_s8((int8x8_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v135 >> 8), (int8x8_t)0xFF0000FF00), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v133), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (int32x2_t)0x100000001)), (int8x8_t)0x1FF0001FF0000));
                    unsigned int v136 = (((v135 >> 8) & 0xFF0000) + ((v135 >> 8) & 0xFF0000) * HIBYTE(v133)) & 0xFF000000 | ((v135 * v133 + v135) >> 8);
                    unint64_t v137 = (v136 | LODWORD(a9) | HIDWORD(a9) | ((unint64_t)(v136 | LODWORD(a9) | HIDWORD(a9)) << 24)) & 0xFF00FF00FF00FFLL;
                    unint64_t v138 = ((v137 + v137 * v130[3]) >> 8) & 0xFF00FF00FF00FFLL;
                    *v128++ = (v138 >> 24) | v138;
                    v130 += 4;
                    --v132;
                  }
                  while (v132);
                }
              }
              else if (v43)
              {
                unsigned int v348 = *v416 >> 8;
                int v349 = *v416 + 1;
                int v350 = (v348 & 0xFF0000) + 0x10000;
                a9 = COERCE_DOUBLE(vadd_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v348), (int8x8_t)0xFF0000FF00), (int32x2_t)0x100000100));
                v351 = v426;
                v352 = (unsigned int *)v417;
                v353 = v413;
                uint64_t v354 = v43;
                do
                {
                  unsigned int v355 = *v352++;
                  int8x8_t v356 = vand_s8((int8x8_t)vmul_s32(*(int32x2_t *)&a9, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v355), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)0x1FF0001FF0000);
                  uint64_t v357 = (v350 * HIBYTE(v355)) & 0xFF000000 | ((v355 * v349) >> 8) | v356.i32[0] | v356.i32[1];
                  unint64_t v358 = ((((v357 | (v357 << 24)) & 0xFF00FF00FF00FFLL)
                         + ((v357 | (v357 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)v353[3]) >> 8) & 0xFF00FF00FF00FFLL;
                  *v351++ = (v358 >> 24) | v358;
                  v353 += 4;
                  --v354;
                }
                while (v354);
              }
              break;
            case 6:
              if (v418)
              {
                if (v43)
                {
                  unint64_t v139 = v426;
                  uint64_t v140 = (unsigned int *)v417;
                  unint64_t v141 = (int *)v413;
                  unint64_t v142 = v416;
                  uint64_t v143 = v43;
                  do
                  {
                    unsigned int v145 = *v140++;
                    unsigned int v144 = v145;
                    unsigned int v146 = *v142++;
                    a9 = COERCE_DOUBLE(vand_s8((int8x8_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v144 >> 8), (int8x8_t)0xFF0000FF00), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v146), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (int32x2_t)0x100000001)), (int8x8_t)0x1FF0001FF0000));
                    uint64_t v147 = (((v144 >> 8) & 0xFF0000) + ((v144 >> 8) & 0xFF0000) * HIBYTE(v146)) & 0xFF000000 | ((v144 * v146 + v144) >> 8) | LODWORD(a9) | HIDWORD(a9);
                    int v148 = *v141++;
                    unint64_t v149 = ((((v147 | (v147 << 24)) & 0xFF00FF00FF00FFLL)
                           * (unint64_t)((~v148 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
                    *v139++ = (v149 >> 24) | v149;
                    --v143;
                  }
                  while (v143);
                }
              }
              else if (v43)
              {
                unsigned int v359 = *v416 >> 8;
                int v360 = *v416 + 1;
                int v361 = (v359 & 0xFF0000) + 0x10000;
                a9 = COERCE_DOUBLE(vadd_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v359), (int8x8_t)0xFF0000FF00), (int32x2_t)0x100000100));
                v362 = v426;
                v363 = (unsigned int *)v417;
                v364 = (int *)v413;
                uint64_t v365 = v43;
                do
                {
                  unsigned int v366 = *v363++;
                  int8x8_t v367 = vand_s8((int8x8_t)vmul_s32(*(int32x2_t *)&a9, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v366), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)0x1FF0001FF0000);
                  uint64_t v368 = (v361 * HIBYTE(v366)) & 0xFF000000 | ((v366 * v360) >> 8) | v367.i32[0] | v367.i32[1];
                  int v369 = *v364++;
                  unint64_t v370 = ((((v368 | (v368 << 24)) & 0xFF00FF00FF00FFLL)
                         * (unint64_t)((~v369 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
                  *v362++ = (v370 >> 24) | v370;
                  --v365;
                }
                while (v365);
              }
              break;
            case 7:
              LOBYTE(a9) = *((unsigned char *)v416 + 3);
              unint64_t v150 = (float)((float)((float)LODWORD(a9) * 1.0039) + 0.5);
              v151 = v426;
              v152 = &v440;
              goto LABEL_182;
            case 8:
              *(float *)&a9 = (float)(*((float *)v421 + 6) * 256.0) + 0.5;
              unint64_t v150 = *(float *)&a9;
              if (v418)
              {
                v151 = v426;
                v152 = &v441;
LABEL_182:
                CA::OGL::SW::tex_interpolate(v151, (unsigned int *)*(v152 - 32), (unsigned int *)v417, (const unsigned int *)v150, v43);
              }
              else if (v43)
              {
                unsigned int v371 = *v416 & 0xFF00FF;
                unsigned int v372 = (*v416 >> 8) & 0xFF00FF;
                v373 = v426;
                v374 = (unsigned int *)v417;
                uint64_t v375 = v43;
                do
                {
                  unsigned int v376 = *v374++;
                  *v373++ = (v371 + ((((v376 & 0xFF00FF) - v371) * v150) >> 8)) & 0xFF00FF | ((v372 << 8) + (((v376 >> 8) & 0xFF00FF) - v372) * v150) & 0xFF00FF00;
                  --v375;
                }
                while (v375);
              }
              break;
            case 9:
              *(float *)&a9 = (float)(*((float *)v421 + 6) * 256.0) + 0.5;
              unsigned int v153 = *(float *)&a9;
              if (v418)
              {
                if (v43)
                {
                  v154 = v426;
                  v155 = v416;
                  v156 = (unsigned int *)v417;
                  uint64_t v157 = v43;
                  do
                  {
                    unsigned int v159 = *v155++;
                    uint64_t v158 = v159;
                    unsigned int v160 = *v156++;
                    unint64_t v161 = ((((v158 | (v158 << 24)) & 0xFF00FF00FF00FFLL)
                           + ((v158 | (v158 << 24)) & 0xFF00FF00FF00FFLL) * ((unint64_t)v160 >> 24)) >> 8) & 0xFF00FF00FF00FFLL;
                    LODWORD(v161) = (v161 >> 24) | v161;
                    *v154++ = ((v161 & 0xFF00FF) + ((((v160 & 0xFF00FF) - (v161 & 0xFF00FF)) * v153) >> 8)) & 0xFF00FF | ((((v160 >> 8) & 0xFF00FF) - ((v161 >> 8) & 0xFF00FF)) * v153 + (((v161 >> 8) & 0xFF00FF) << 8)) & 0xFF00FF00;
                    --v157;
                  }
                  while (v157);
                }
              }
              else if (v43)
              {
                unint64_t v377 = (*v416 | ((unint64_t)*v416 << 24)) & 0xFF00FF00FF00FFLL;
                v378 = v426;
                v379 = (unsigned int *)v417;
                uint64_t v380 = v43;
                do
                {
                  unsigned int v381 = *v379++;
                  unint64_t v382 = ((v377 + v377 * ((unint64_t)v381 >> 24)) >> 8) & 0xFF00FF00FF00FFLL;
                  LODWORD(v382) = (v382 >> 24) | v382;
                  *v378++ = ((v382 & 0xFF00FF) + ((((v381 & 0xFF00FF) - (v382 & 0xFF00FF)) * v153) >> 8)) & 0xFF00FF | ((((v381 >> 8) & 0xFF00FF) - ((v382 >> 8) & 0xFF00FF)) * v153 + (((v382 >> 8) & 0xFF00FF) << 8)) & 0xFF00FF00;
                  --v380;
                }
                while (v380);
              }
              break;
            case 10:
              if (v43)
              {
                v162 = v426;
                v163 = (unsigned int *)v413;
                v164 = (unsigned int *)v417;
                uint64_t v165 = v43;
                do
                {
                  unsigned int v167 = *v163++;
                  unsigned int v166 = v167;
                  unsigned int v168 = *v164++;
                  unsigned int v169 = (v168 & 0xFF00FF) + (v166 & 0xFF00FF);
                  int v170 = ((v168 >> 8) & 0xFF00FF) + ((v166 >> 8) & 0xFF00FF);
                  *v162++ = (v170 << 8) & 0xFF00FF00 | v169 & 0xFF00FF | (15 * (v170 & 0x1000100 | (v169 >> 8) & 0x10001)) | (240 * (v170 & 0x1000100 | (v169 >> 8) & 0x10001));
                  --v165;
                }
                while (v165);
              }
              break;
            case 11:
              if (v418)
              {
                unsigned int v171 = v426;
                unsigned int v172 = v416;
                uint64_t v173 = v43;
                uint64_t v174 = v417;
                do
                {
                  unsigned int v175 = *v172++;
                  unint64_t v176 = (v175 | ((unint64_t)v175 << 24)) & 0xFF00FF00FF00FFLL;
                  unint64_t v177 = ((v176 + v176 * v174[3]) >> 8) & 0xFF00FF00FF00FFLL;
                  *v171++ = (v177 >> 24) | v177;
                  v174 += 4;
                  --v173;
                }
                while (v173);
              }
              else
              {
                unint64_t v383 = (*v416 | ((unint64_t)*v416 << 24)) & 0xFF00FF00FF00FFLL;
                v384 = v426;
                v385 = v417;
                uint64_t v386 = v43;
                do
                {
                  unint64_t v387 = ((v383 + v383 * v385[3]) >> 8) & 0xFF00FF00FF00FFLL;
                  *v384++ = (v387 >> 24) | v387;
                  v385 += 4;
                  --v386;
                }
                while (v386);
              }
              break;
            case 12:
              if (v418)
              {
                v178 = v426;
                unint64_t v179 = v416;
                uint64_t v180 = v43;
                v181 = (int *)v417;
                do
                {
                  unsigned int v183 = *v179++;
                  uint64_t v182 = v183;
                  int v184 = *v181++;
                  unint64_t v185 = ((((v182 | (v182 << 24)) & 0xFF00FF00FF00FFLL)
                         * (unint64_t)((~v184 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
                  *v178++ = (v185 >> 24) | v185;
                  --v180;
                }
                while (v180);
              }
              else
              {
                unint64_t v388 = (*v416 | ((unint64_t)*v416 << 24)) & 0xFF00FF00FF00FFLL;
                v389 = v426;
                v390 = (int *)v417;
                uint64_t v391 = v43;
                do
                {
                  int v392 = *v390++;
                  unint64_t v393 = ((v388 * ((~v392 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
                  *v389++ = (v393 >> 24) | v393;
                  --v391;
                }
                while (v391);
              }
              break;
            case 15:
              if (v27) {
                CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1896), v43);
              }
              CA::OGL::SW::tex_blend_dest((CA::OGL::SW *)v426, v44, (unsigned int *)v413, (const unsigned int *)v417, (const unsigned int *)v43);
              break;
            case 16:
              if (v27) {
                CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1896), v43);
              }
              if (v418)
              {
                v186 = (CA::OGL::SW *)v426;
                long long v187 = *(void (**)(unsigned int *, unsigned int *, const unsigned int *, const unsigned int *, void))(v427 + 296);
                long long v188 = v44;
                long long v189 = &v441;
LABEL_210:
                CA::OGL::SW::tex_blend_image(v186, v188, (const unsigned int *)*(v189 - 32), (const unsigned int *)v417, (const unsigned int *)v43, v187, v415, a8);
              }
              else
              {
                CA::OGL::SW::tex_blend_color((CA::OGL::SW *)v426, v44, (const unsigned int *)*v416, (const unsigned int *)v417, (const unsigned int *)v43, *(void (**)(void *, unsigned int *, void *, const unsigned int *, void))(v427 + 296), v415, a8);
              }
              break;
            case 17:
              if (v27) {
                CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1896), v43);
              }
              v186 = (CA::OGL::SW *)v426;
              long long v187 = *(void (**)(unsigned int *, unsigned int *, const unsigned int *, const unsigned int *, void))(v427 + 296);
              long long v188 = v44;
              long long v189 = &v440;
              goto LABEL_210;
            case 20:
              v190 = v426;
              uint64_t v191 = (unsigned int *)v417;
              goto LABEL_219;
            case 24:
              uint64_t v192 = 0;
              uint64_t v191 = (unsigned int *)v417;
              do
              {
                unsigned int v193 = v191[v192];
                float v194 = (float)HIBYTE(v193);
                float v195 = v194 * 0.0039216;
                float v197 = 255.0 / v194;
                if (v195 <= 0.001) {
                  float v197 = 1000.0;
                }
                float v196 = (float)v191[v192];
                signed int v198 = (float)(v197 * v196) & ~((int)(float)(v197 * v196) >> 31);
                if (v198 >= 255) {
                  signed int v198 = 255;
                }
                int32x2_t v199 = (int32x2_t)vshl_u32((uint32x2_t)vmin_s32(vmax_s32((int32x2_t)vcvt_u32_f32(vmul_n_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v193), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), v197)), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
                v191[v192++] = vorr_s8((int8x8_t)v199, (int8x8_t)vdup_lane_s32(v199, 1)).u32[0] | v198 | 0xFF000000;
              }
              while (v42 != v192);
              v190 = v426;
LABEL_219:
              CA::OGL::SW::tex_color_matrix_4x4_bias(v190, v191, (const unsigned int *)v43, v406, a5);
              break;
            case 25:
              if (v43)
              {
                LODWORD(a9) = *((_DWORD *)v421 + 6);
                float32x2_t v200 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a9, 0);
                v201 = v426;
                v202 = (unsigned int *)v417;
                uint64_t v203 = v43;
                do
                {
                  unsigned int v204 = *v202;
                  if (*v202 + 1 >= 0x1000001)
                  {
                    float v205 = (float)HIBYTE(v204);
                    *(float *)&a12 = v205 * 0.0039216;
                    float v206 = 1.0 / v205;
                    int8x8_t v207 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v204), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
                    float v208 = (float)(1.0 / v205) * (float)*v202;
                    unsigned int v209 = (float)(v205 + 0.5);
                    float v210 = *(float *)&a12 + (float)((float)(*(float *)&a12 - v208) * *(float *)&a9);
                    float32x2_t v211 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a12, 0);
                    a13 = COERCE_DOUBLE(vmul_n_f32(vcvt_f32_u32((uint32x2_t)vand_s8(v207, (int8x8_t)0xFF000000FFLL)), v206));
                    float32x2_t v212 = vdiv_f32(vmul_f32(*(float32x2_t *)&a13, (float32x2_t)vdup_n_s32(0x437F0000u)), vmla_f32(v211, v200, vsub_f32(v211, *(float32x2_t *)&a13)));
                    HIDWORD(a13) = 1056964608;
                    a12 = COERCE_DOUBLE(vshl_u32(vcvt_u32_f32(vadd_f32(v212, (float32x2_t)0x3F0000003F000000)), (uint32x2_t)0x800000010));
                    unsigned int v204 = (float)((float)((float)(v208 * 255.0) / v210) + 0.5) | (v209 << 24) | LODWORD(a12) | HIDWORD(a12);
                  }
                  *v201++ = v204;
                  ++v202;
                  --v203;
                }
                while (v203);
              }
              break;
            case 47:
              if (v27) {
                CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1896), v43);
              }
              CA::OGL::SW::tex_vibrant_color_matrix((CA::OGL::SW *)v426, v44, (unsigned int *)v417, (const unsigned int *)v43, v406, (const float *)a6);
              break;
            case 48:
              if (v27) {
                CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1896), v43);
              }
              CA::OGL::SW::tex_vibrant_dark((CA::OGL::SW *)v426, v44, (unsigned int *)v417, (const unsigned int *)v43, (float *)v406, (const float *)a6);
              break;
            case 49:
              if (v27) {
                CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1896), v43);
              }
              CA::OGL::SW::tex_vibrant_light((CA::OGL::SW *)v426, v44, (unsigned int *)v417, (const unsigned int *)v43, (float *)v406, (const float *)a6);
              break;
            case 50:
              v400 = v24;
              v401 = v21;
              v402 = v16;
              uint64_t v403 = v15;
              LODWORD(a9) = *((_DWORD *)v421 + 6);
              v213 = v405;
              *((void *)v405 + 6) = 0;
              *((_OWORD *)v213 + 1) = 0u;
              *((_OWORD *)v213 + 2) = 0u;
              *(_OWORD *)v213 = 0u;
              uint64_t v214 = v412;
              uint64_t __pattern4 = v412;
              uint64_t v430 = 0;
              v431 = &CA::OGL::SW::tex_luminance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,unsigned int)::dummy;
              v432 = &CA::OGL::SW::tex_luminance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,unsigned int)::dummy;
              v433 = &CA::OGL::SW::tex_luminance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,unsigned int)::dummy;
              v434 = &CA::OGL::SW::tex_luminance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,unsigned int)::dummy;
              uint64_t v438 = 0;
              v215 = v404;
              *(void *)v404 = 0;
              *((_DWORD *)v215 + 2) = 0;
              if (v43)
              {
                unsigned int v216 = (float)((float)(*(float *)&a9 * 256.0) + 0.5);
                float v217 = (float)*(unsigned int *)(v214 + 24) * 0.0039216;
                v218 = v426;
                v219 = (unsigned int *)v417;
                uint64_t v220 = v43;
                do
                {
                  unsigned int v221 = *v219++;
                  int v436 = (int)(float)(v217
                                    * (float)(4725 * v221
                                            + 46884 * BYTE1(v221)
                                            + 13926 * BYTE2(v221)));
                  (*(void (**)(uint64_t *, uint64_t, unsigned int *, uint64_t))(*(void *)(v214 + 48) + 80))(&__pattern4, 1, v218, 10);
                  uint64_t v214 = v412;
                  unsigned int *v218 = ((v221 & 0xFF00FF) + ((((*v218 & 0xFF00FF) - (v221 & 0xFF00FF)) * v216) >> 8)) & 0xFF00FF | ((((*v218 >> 8) & 0xFF00FF) - ((v221 >> 8) & 0xFF00FF)) * v216 + (((v221 >> 8) & 0xFF00FF) << 8)) & 0xFF00FF00;
                  ++v218;
                  --v220;
                }
                while (v220);
              }
              uint64_t v15 = v403;
              int v16 = v402;
              signed int v21 = v401;
              uint64_t v24 = v400;
              char v39 = v414;
              break;
            case 51:
              if (v43)
              {
                LODWORD(a9) = *((_DWORD *)v421 + 6);
                float v222 = *((float *)v421 + 7);
                float v223 = *((float *)v421 + 8);
                float v224 = *((float *)v421 + 9);
                int v225 = *(unsigned __int8 *)v416 + 1;
                v226 = v426;
                v227 = (unsigned int *)v417;
                uint64_t v228 = v43;
                do
                {
                  unsigned int v230 = *v227++;
                  unsigned int v229 = v230;
                  float v231 = (float)((float)((float)v230 * 0.00028275)
                               + (float)((float)BYTE1(v230) * 0.0028055))
                       + (float)((float)BYTE2(v230) * 0.00083333);
                  float v232 = (float)(v224
                               + (float)((float)(v223 + (float)((float)(v222 + (float)(v231 * *(float *)&a9)) * v231))
                                       * v231))
                       * 255.0;
                  int v233 = (int)v232 & ~((int)v232 >> 31);
                  if (v233 >= 255) {
                    int v233 = 255;
                  }
                  *v226++ = ((v229 & 0xFF00FF) + (((v233 - (v229 & 0xFF00FF) + (v233 << 16)) * v225) >> 8)) & 0xFF00FF | ((v233 - ((v229 >> 8) & 0xFF00FF) + 16711680) * v225 + (((v229 >> 8) & 0xFF00FF) << 8)) & 0xFF00FF00;
                  --v228;
                }
                while (v228);
              }
              break;
            case 52:
              if (v43)
              {
                LODWORD(a9) = *(_DWORD *)(v424 + 1996);
                float v234 = *(float *)(v424 + 2012);
                float v235 = *(float *)(v424 + 2028);
                float v236 = *(float *)(v424 + 2044);
                a13 = *(double *)(v424 + 1984);
                float32x2_t v237 = *(float32x2_t *)(v424 + 2000);
                float32x2_t v238 = *(float32x2_t *)(v424 + 2016);
                float32x2_t v239 = *(float32x2_t *)(v424 + 2032);
                float v240 = *(float *)(v424 + 1992);
                float v241 = *(float *)(v424 + 2008);
                float v242 = *(float *)(v424 + 2024);
                v243 = (__int32 *)v426;
                v244 = (unsigned int *)v417;
                uint64_t v245 = v43;
                float v246 = *(float *)(v424 + 2040);
                do
                {
                  unsigned int v248 = *v244++;
                  unsigned __int8 v247 = v248;
                  float v249 = (float)HIBYTE(v248);
                  float v250 = v249 * 0.0039216;
                  float v251 = 1.0 / v249;
                  int8x8_t v252 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v248), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
                  if (v250 <= 0.005) {
                    float v251 = 0.78431;
                  }
                  uint32x2_t v253 = (uint32x2_t)vand_s8(v252, (int8x8_t)0xFF000000FFLL);
                  float v254 = v251 * (float)v247;
                  float v255 = (float)(v236
                               + (float)((float)(v235 + (float)((float)(v234 + (float)(v250 * *(float *)&a9)) * v250))
                                       * v250))
                       * 255.0;
                  int v256 = (int)v255 & ~((int)v255 >> 31);
                  if (v256 >= 255) {
                    int v256 = 255;
                  }
                  float v257 = v246 + (float)((float)(v242 + (float)((float)(v241 + (float)(v240 * v254)) * v254)) * v254);
                  float32x2_t v258 = vmul_n_f32(vcvt_f32_u32(v253), v251);
                  uint32x2_t v259 = vshl_u32((uint32x2_t)vmin_s32(vmax_s32(vcvt_s32_f32(vmla_n_f32((float32x2_t)0x3F0000003F000000, vmla_f32(v239, v258, vmla_f32(v238, v258, vmla_f32(v237, v258, *(float32x2_t *)&a13))), (float)v256)), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
                  if (((int)(float)((float)(v257 * (float)v256) + 0.5) & ~((int)(float)((float)(v257 * (float)v256)
                                                                                       + 0.5) >> 31)) >= 255)
                    int v260 = 255;
                  else {
                    int v260 = (int)(float)((float)(v257 * (float)v256) + 0.5) & ~((int)(float)((float)(v257 * (float)v256)
                  }
                                                                                          + 0.5) >> 31);
                  *v243++ = v260 | v259.i32[0] | (v256 << 24) | v259.i32[1];
                  --v245;
                }
                while (v245);
              }
              break;
            case 53:
              if (v43)
              {
                LODWORD(a9) = *((_DWORD *)v421 + 6);
                v261 = v426;
                v262 = (int *)v417;
                uint64_t v263 = v43;
                do
                {
                  int v264 = *v262;
                  float v265 = (float)HIBYTE(*v262);
                  float v266 = 1.0 / v265;
                  if (!HIBYTE(*v262)) {
                    float v266 = 200.0;
                  }
                  float v267 = v266 * (float)BYTE2(v264);
                  float v268 = v266 * (float)BYTE1(v264);
                  float v269 = v266 * (float)*v262;
                  if (v268 <= v269) {
                    float v270 = v266 * (float)*v262;
                  }
                  else {
                    float v270 = v266 * (float)BYTE1(v264);
                  }
                  if (v268 >= v269) {
                    float v271 = v269;
                  }
                  else {
                    float v271 = v268;
                  }
                  if (v267 > v270) {
                    float v270 = v267;
                  }
                  if (v267 < v271) {
                    float v271 = v267;
                  }
                  float v272 = v270 - v271;
                  float v273 = 0.16667 / v272;
                  if (v272 <= 0.005) {
                    float v273 = 33.333;
                  }
                  if (v267 == v270)
                  {
                    float v274 = v273 * (float)(v268 - v269);
                  }
                  else
                  {
                    if (v268 == v270)
                    {
                      float v275 = v269 - v267;
                      float v276 = 0.33333;
                    }
                    else
                    {
                      float v275 = v267 - v268;
                      float v276 = 0.66667;
                    }
                    float v274 = v276 + (float)(v273 * v275);
                  }
                  float v277 = v274 + *(float *)&a9;
                  float v278 = (float)(fabsf(fminf((float)(v274 + *(float *)&a9) - floorf(v274 + *(float *)&a9), 1.0) + -0.5)
                               * 6.0)
                       + -1.0;
                  float v279 = 1.0;
                  float v280 = 0.0;
                  if (v278 >= 0.0) {
                    float v280 = v278;
                  }
                  if (v278 <= 1.0) {
                    float v281 = v280;
                  }
                  else {
                    float v281 = 1.0;
                  }
                  float v282 = (float)(fabsf(fminf((float)(v277 + -0.33333) - floorf(v277 + -0.33333), 1.0) + -0.5) * 6.0)
                       + -1.0;
                  v283.i32[0] = 1.0;
                  if (v282 <= 1.0)
                  {
                    v283.i32[0] = 0;
                    if (v282 >= 0.0) {
                      v283.f32[0] = v282;
                    }
                  }
                  float v284 = (float)(fabsf(fminf((float)(v277 + -0.66667) - floorf(v277 + -0.66667), 1.0) + -0.5) * 6.0)
                       + -1.0;
                  if (v284 <= 1.0)
                  {
                    float v279 = 0.0;
                    if (v284 >= 0.0) {
                      float v279 = v284;
                    }
                  }
                  float v285 = v272 / fmaxf(v270, 0.005);
                  v283.f32[1] = v281;
                  float v286 = v270 * v265;
                  int v287 = (int)(float)(v286 * (float)((float)(1.0 - v285) + (float)(v279 * v285))) & ~((int)(float)(v286 * (float)((float)(1.0 - v285) + (float)(v279 * v285))) >> 31);
                  if (v287 >= 255) {
                    int v287 = 255;
                  }
                  *(float *)&a13 = 1.0 - v285;
                  uint32x2_t v288 = vshl_u32((uint32x2_t)vmin_s32(vmax_s32(vcvt_s32_f32(vmul_n_f32(vmla_n_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a13, 0), v283, v285), v286)), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x1000000008);
                  *v261++ = v287 | v288.i32[0] | v264 & 0xFF000000 | v288.i32[1];
                  ++v262;
                  --v263;
                }
                while (v263);
              }
              break;
            case 55:
              v402 = v16;
              uint64_t v403 = v15;
              v400 = v24;
              v401 = v21;
              v289 = v405;
              *((void *)v405 + 6) = 0;
              a9 = 0.0;
              *((_OWORD *)v289 + 1) = 0u;
              *((_OWORD *)v289 + 2) = 0u;
              *(_OWORD *)v289 = 0u;
              uint64_t v290 = v412;
              uint64_t __pattern4 = v412;
              uint64_t v430 = 0;
              v431 = &CA::OGL::SW::tex_home_affordance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,float const*)::dummy;
              v432 = &CA::OGL::SW::tex_home_affordance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,float const*)::dummy;
              v433 = &CA::OGL::SW::tex_home_affordance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,float const*)::dummy;
              v434 = &CA::OGL::SW::tex_home_affordance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,float const*)::dummy;
              uint64_t v438 = 0;
              v291 = v404;
              *(void *)v404 = 0;
              *((_DWORD *)v291 + 2) = 0;
              if (v43)
              {
                unsigned int v292 = (float)((float)(*(float *)(v424 + 2016) * 256.0) + 0.5);
                unsigned int v293 = (float)((float)(*(float *)(v424 + 2000) * 256.0) + 0.5);
                unsigned int v294 = ((float)((float)(*(float *)(v424 + 1988) * 255.0) + 0.5) << 8) | ((float)((float)(*(float *)(v424 + 1984) * 255.0) + 0.5) << 16) | (float)((float)(*(float *)(v424 + 1992) * 255.0) + 0.5);
                unsigned int v295 = v294 | ((float)((float)(*(float *)(v424 + 1996) * 255.0) + 0.5) << 24);
                float v296 = (float)*(unsigned int *)(v290 + 24);
                int v410 = v294 & 0xFF00FF;
                int v409 = (v295 >> 8) & 0xFF00FF;
                uint64_t v408 = v293 + 1;
                float v297 = v296 * 0.0039216;
                uint64_t v407 = v292 + 1;
                v298 = (int *)v426;
                v299 = v417;
                uint64_t v300 = v43;
                do
                {
                  unsigned int v428 = 0;
                  uint64_t v301 = *v299;
                  int v436 = (int)(float)(v297
                                    * (float)(4725 * *v299
                                            + 46884 * BYTE1(v301)
                                            + 13926 * BYTE2(v301)));
                  v302 = (uint32x2_t *)v70;
                  v303 = v69;
                  (*(void (**)(uint64_t *, uint64_t, unsigned int *, uint64_t))(*(void *)(v290 + 48) + 80))(&__pattern4, 1, &v428, 10);
                  int v69 = v303;
                  uint64_t v304 = ((((v428 >> 8) & 0xFF00FF) + v409) << 8) & 0xFF00FF00 | ((v428 & 0xFF00FF) + v410) & 0xFF00FF | (15 * ((((v428 >> 8) & 0xFF00FF) + v409) & 0x1000100 | (((v428 & 0xFF00FF) + v410) >> 8) & 0x10001)) | (240 * ((((v428 >> 8) & 0xFF00FF) + v409) & 0x1000100 | (((v428 & 0xFF00FF) + v410) >> 8) & 0x10001));
                  unint64_t v305 = ((((v304 | (v304 << 24)) & 0xFF00FF00FF00FFuLL) * v408) >> 8) & 0xFF00FF00FF00FFLL;
                  unint64_t v306 = (((v301 | (v301 << 24)) & 0xFF00FF00FF00FFLL)
                        * (unint64_t)((~(v305 >> 24) >> 24) + 1)) >> 8;
                  unint64_t v307 = (((v306 & 0xFF00FF00FF00FFLL) >> 24) | v306 & 0xFF00FF)
                       + ((v305 >> 24) | v305);
                  unint64_t v308 = ((((v307 | (v307 << 24)) & 0xFF00FF00FF00FFLL) * v407) >> 8) & 0xFF00FF00FF00FFLL;
                  unint64_t v309 = v308 >> 24;
                  unsigned int v310 = (v308 >> 24) | v308;
                  int v311 = BYTE3(v309);
                  uint32x2_t v312 = (uint32x2_t)v303[96];
                  unsigned int v313 = BYTE3(v307);
                  a12 = COERCE_DOUBLE(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v307), v312), (int8x8_t)0xFF000000FFLL));
                  unsigned int v314 = v307;
                  int8x8_t v315 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v310), v312);
                  int v316 = v311 + 1;
                  signed int v317 = (BYTE3(v307) * (v311 + 1)) >> 8;
                  double v318 = 0.0;
                  int32x2_t v319 = (int32x2_t)vand_s8(v315, (int8x8_t)0xFF000000FFLL);
                  uint32x2_t v320 = (uint32x2_t)vmul_s32(vdup_n_s32(BYTE3(v307) ^ 0xFF), vadd_s32(v319, (int32x2_t)0x100000001));
                  unsigned int v321 = ((v313 ^ 0xFF) + (v313 ^ 0xFF) * v310) >> 8;
                  if (BYTE3(v307) == 255) {
                    unsigned int v321 = 0;
                  }
                  double v322 = COERCE_DOUBLE(vshr_n_u32(v320, 8uLL));
                  if (v313 != 255) {
                    v317 += ((BYTE3(v307) ^ 0xFF) * (v311 + 1)) >> 8;
                  }
                  unsigned int v323 = v311 ^ 0xFF;
                  signed int v324 = v317 + ((v323 + v323 * v313) >> 8);
                  int32x2_t v325 = vadd_s32(*(int32x2_t *)&a12, (int32x2_t)0x100000001);
                  if (v313 != 255) {
                    double v318 = v322;
                  }
                  a13 = COERCE_DOUBLE(vdup_n_s32(v323));
                  unsigned int v326 = v321 + ((v323 + v323 * v307) >> 8);
                  unsigned int v327 = v313 + 1;
                  if (v311 != 255) {
                    unsigned int v321 = v326;
                  }
                  __int32 v328 = v319.i32[0];
                  __int32 v329 = v319.i32[1];
                  a6 = v327 * v319.i32[0];
                  if (v311 != 255) {
                    signed int v317 = v324;
                  }
                  unsigned int v330 = (a6 >> 8) + ((LODWORD(a12) * (v316 - v319.i32[0])) >> 8);
                  a5 = (float *)((v327 * v319.i32[1]) >> 8);
                  __int32 v331 = a5 + ((HIDWORD(a12) * (v316 - v319.i32[1])) >> 8);
                  double v332 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v318, (uint32x2_t)vmul_s32(v325, *(int32x2_t *)&a13), 8uLL));
                  if (v311 == 255) {
                    *(double *)&int32x2_t v333 = v318;
                  }
                  else {
                    *(double *)&int32x2_t v333 = v332;
                  }
                  unsigned int v334 = v307 >> 25;
                  unsigned int v335 = v327 * v311;
                  int v336 = 2 * v330 - (v335 >> 8);
                  unsigned int v337 = ((LODWORD(a12) + LODWORD(a12) * v328) >> 7) & 0x3FE;
                  int v338 = 2 * v331 - (v335 >> 8);
                  if (v334 < LODWORD(a12)) {
                    unsigned int v337 = v336;
                  }
                  signed int v70 = (char **__ptr32 *)v302;
                  unsigned int v339 = 2
                       * (((v327 * v310) >> 8) + ((int)(v314 * (v316 - v310)) >> 8))
                       - (v335 >> 8);
                  if (v334 >= HIDWORD(a12)) {
                    unsigned int v340 = ((HIDWORD(a12) + HIDWORD(a12) * v329) >> 7) & 0x3FE;
                  }
                  else {
                    unsigned int v340 = v338;
                  }
                  unsigned int v341 = ((v314 + v314 * v310) >> 7) & 0x3FE;
                  v342.i32[0] = v337;
                  if (v334 >= v314) {
                    unsigned int v343 = v341;
                  }
                  else {
                    unsigned int v343 = v339;
                  }
                  v342.i32[1] = v340;
                  int v344 = v343 + v321;
                  if (v344 >= v317) {
                    int v344 = v317;
                  }
                  a9 = COERCE_DOUBLE(vshl_u32((uint32x2_t)vmax_s32(vmin_s32(vadd_s32(v342, v333), vdup_n_s32(v317)), 0), v302[466]));
                  int v345 = LODWORD(a9) | (v317 << 24);
                  uint64_t v290 = v412;
                  *v298++ = v345 | v344 & ~(v344 >> 31) | HIDWORD(a9);
                  ++v299;
                  --v300;
                }
                while (v300);
              }
              signed int v21 = v401;
              uint64_t v24 = v400;
              char v39 = v414;
              uint64_t v15 = v403;
              int v16 = v402;
              break;
            default:
              break;
          }
        }
      }
LABEL_101:
      uint64_t v76 = v424;
      if (*(unsigned char *)(v427 + 312))
      {
        if (v27) {
          CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1896), v43);
        }
        (*(void (**)(unsigned int *, unsigned int *, unsigned int *, uint64_t, void))(v427 + 296))(v44, v44, v426, v43, v415);
      }
      uint64_t v40 = v425;
      if (v27)
      {
        int v77 = *(_DWORD *)(v76 + 1896);
        if (v77 <= 14)
        {
          if (v77)
          {
            if (v77 == 8)
            {
              long long v82 = v27;
              unsigned int v83 = v21;
              uint64_t v84 = v43;
              if (v24)
              {
                long long v85 = v24;
                if (v43)
                {
                  do
                  {
                    *v85++ = *((unsigned char *)v82 + 3);
                    int v86 = *v82++;
                    *(unsigned char *)unsigned int v83 = (unsigned __int16)(21 * v86 + 173 * BYTE1(v86) + 62 * BYTE2(v86)) >> 8;
                    unsigned int v83 = (unsigned int *)((char *)v83 + 1);
                    --v84;
                  }
                  while (v84);
                }
              }
              else if (v43)
              {
                do
                {
                  int v99 = *v82++;
                  *(unsigned char *)unsigned int v83 = (unsigned __int16)(21 * v99 + 173 * BYTE1(v99) + 62 * BYTE2(v99)) >> 8;
                  unsigned int v83 = (unsigned int *)((char *)v83 + 1);
                  --v84;
                }
                while (v84);
              }
            }
          }
          else if (v43)
          {
            float v96 = v27;
            uint64_t v97 = v43;
            int8x16_t v98 = v24;
            do
            {
              *v98++ = *((unsigned char *)v96++ + 3);
              --v97;
            }
            while (v97);
          }
        }
        else
        {
          switch(v77)
          {
            case 15:
              uint64_t v87 = v27;
              uint64_t v88 = v43;
              if (v24)
              {
                unsigned int v89 = v24;
                uint64_t v90 = v21;
                if (v43)
                {
                  do
                  {
                    *v89++ = *((unsigned char *)v87 + 3);
                    unsigned int v91 = *v87++;
                    *(_WORD *)uint64_t v90 = (v91 >> 6) & 0x3E0 | (v91 >> 3) | (v91 >> 9) & 0x7C00;
                    uint64_t v90 = (unsigned int *)((char *)v90 + 2);
                    --v88;
                  }
                  while (v88);
                }
              }
              else
              {
                unsigned int v100 = v21;
                if (v43)
                {
                  do
                  {
                    unsigned int v101 = *v87++;
                    *(_WORD *)unsigned int v100 = (v101 >> 6) & 0x3E0 | (v101 >> 3) | (v101 >> 9) & 0x7C00;
                    unsigned int v100 = (unsigned int *)((char *)v100 + 2);
                    --v88;
                  }
                  while (v88);
                }
              }
              break;
            case 16:
              v92 = v27;
              uint64_t v93 = v43;
              v94 = v21;
              if (v43)
              {
                do
                {
                  int v95 = *v92++;
                  *(_WORD *)v94 = HIWORD(v95) & 0xFF00 | ((21 * v95
                                                         + 173 * BYTE1(v95)
                                                         + 62 * BYTE2(v95)) >> 8);
                  v94 = (unsigned int *)((char *)v94 + 2);
                  --v93;
                }
                while (v93);
              }
              break;
            case 32:
              float v78 = v27;
              char v79 = v21;
              uint64_t v80 = v43;
              if (v43)
              {
                do
                {
                  unsigned int v81 = *v78++;
                  *v79++ = v81;
                  --v80;
                }
                while (v80);
              }
              break;
          }
        }
      }
      if ((int)v41 < 257) {
        return;
      }
      signed int v21 = (unsigned int *)((char *)v21 + (*(_DWORD *)(v76 + 1900) * v43));
      if (v24) {
        v24 += v43;
      }
      else {
        uint64_t v24 = 0;
      }
      uint64_t v41 = v423;
      if (v40)
      {
        *(float *)&a9 = (float)(int)v43;
        v102 = (float *)v15;
        v103 = v16;
        unsigned int v104 = v40;
        do
        {
          if (v104) {
            float *v103 = *v103 + (float)(*v102 * *(float *)&a9);
          }
          ++v103;
          ++v102;
          BOOL v105 = v104 > 1;
          v104 >>= 1;
        }
        while (v105);
        if (v422)
        {
          signed int v106 = v419;
          unsigned int v107 = v422;
          unsigned int v108 = v40;
          do
          {
            if (v108) {
              *unsigned int v107 = *v107 + (float)(*v106 * *(float *)&a9);
            }
            ++v107;
            ++v106;
            BOOL v109 = v108 >= 2;
            v108 >>= 1;
          }
          while (v109);
        }
      }
    }
  }
}

uint64_t CA::OGL::SW::sample_color(uint64_t result, float *a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  unsigned int v7 = (int)(float)(a2[4] * 16712000.0);
  signed int v8 = (int)(float)(a2[5] * 16712000.0);
  signed int v9 = (int)(float)(a2[6] * 16712000.0);
  unsigned int v10 = (int)(float)(a2[7] * 16712000.0);
  unsigned int v11 = (int)(float)(*(float *)(a3 + 16) * 16712000.0);
  unsigned int v12 = (int)(float)(*(float *)(a3 + 20) * 16712000.0);
  unsigned int v13 = (int)(float)(*(float *)(a3 + 24) * 16712000.0);
  unsigned int v14 = (int)(float)(*(float *)(a3 + 28) * 16712000.0);
  if ((result & 4) != 0)
  {
    if (a4)
    {
      unint64_t v20 = 0;
      uint64x2_t v21 = (uint64x2_t)vdupq_n_s64((unint64_t)a4 - 1);
      v5.i32[0] = *(_DWORD *)(a3 + 12);
      uint64_t v22 = a2 + 3;
      int32x4_t v23 = vmlaq_s32(vdupq_n_s32(v10), vdupq_n_s32(v14), (int32x4_t)xmmword_184997FC0);
      int32x4_t v24 = vdupq_n_s32(4 * v14);
      int32x4_t v25 = vmlaq_s32(vdupq_n_s32(v9), vdupq_n_s32(v13), (int32x4_t)xmmword_184997FC0);
      int32x4_t v26 = vdupq_n_s32(4 * v13);
      int32x4_t v27 = vmlaq_s32(vdupq_n_s32(v8), vdupq_n_s32(v12), (int32x4_t)xmmword_184997FC0);
      int32x4_t v28 = vdupq_n_s32(4 * v12);
      int32x4_t v29 = vmlaq_s32(vdupq_n_s32(v7), vdupq_n_s32(v11), (int32x4_t)xmmword_184997FC0);
      int32x4_t v30 = vdupq_n_s32(4 * v11);
      float32x4_t v31 = vld1q_dup_f32(v22);
      float32x4_t v32 = vmlaq_n_f32(v31, (float32x4_t)xmmword_184998230, *(float *)v5.i32);
      *(float *)v5.i32 = *(float *)v5.i32 * 4.0;
      float32x4_t v33 = (float32x4_t)vdupq_lane_s32(v5, 0);
      __asm { FMOV            V19.4S, #1.0 }
      v39.i64[0] = 0xFF000000FF000000;
      v39.i64[1] = 0xFF000000FF000000;
      v40.i64[0] = 0xFFFF0000FFFF0000;
      v40.i64[1] = 0xFFFF0000FFFF0000;
      do
      {
        int8x16_t v41 = (int8x16_t)vdupq_n_s64(v20);
        *(int32x2_t *)v6.i8 = vmovn_s64((int64x2_t)vcgeq_u64(v21, (uint64x2_t)vorrq_s8(v41, (int8x16_t)xmmword_184997FD0)));
        float32x4_t v42 = vdivq_f32(_Q19, v32);
        float32x4_t v43 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v42, _Q19), (int8x16_t)_Q19, (int8x16_t)v42);
        float32x4_t v44 = (float32x4_t)vbicq_s8((int8x16_t)v43, (int8x16_t)vcltzq_f32(v43));
        int8x16_t v45 = vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshrq_n_s32(vcvtq_s32_f32(vmulq_f32(v44, vcvtq_f32_s32(v25))), 0x10uLL), vandq_s8((int8x16_t)vcvtq_s32_f32(vmulq_f32(v44, vcvtq_f32_s32(v29))), v40)), vandq_s8((int8x16_t)vshlq_n_s32(vcvtq_s32_f32(vmulq_f32(v44, vcvtq_f32_s32(v23))), 8uLL), v39)), (int8x16_t)(*(_OWORD *)&vshrq_n_s32(vcvtq_s32_f32(vmulq_f32(v44, vcvtq_f32_s32(v27))), 8uLL) & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00)));
        if (vmovn_s32(v6).u8[0]) {
          *(_DWORD *)(a5 + 4 * v20) = v45.i32[0];
        }
        int32x2_t v46 = (int32x2_t)vmovn_s32(v6);
        if (v46.i8[2]) {
          *(_DWORD *)(a5 + 4 * v20 + 4) = v45.i32[1];
        }
        int64x2_t v47 = (int64x2_t)vcgeq_u64(v21, (uint64x2_t)vorrq_s8(v41, (int8x16_t)xmmword_184998240));
        int32x4_t v6 = vmovn_hight_s64(v46, v47);
        if (vmovn_s32(v6).i32[1]) {
          *(_DWORD *)(a5 + 4 * v20 + 8) = v45.i32[2];
        }
        if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v47, v47)).i8[6]) {
          *(_DWORD *)(a5 + 4 * v20 + 12) = v45.i32[3];
        }
        v20 += 4;
        int32x4_t v23 = vaddq_s32(v23, v24);
        int32x4_t v25 = vaddq_s32(v25, v26);
        int32x4_t v27 = vaddq_s32(v27, v28);
        int32x4_t v29 = vaddq_s32(v29, v30);
        float32x4_t v32 = vaddq_f32(v32, v33);
      }
      while (((a4 + 3) & 0x1FFFFFFFCLL) != v20);
    }
  }
  else if (a4)
  {
    unint64_t v15 = 0;
    uint64x2_t v16 = (uint64x2_t)vdupq_n_s64((unint64_t)a4 - 1);
    unsigned int v17 = (_DWORD *)(a5 + 4);
    uint64_t result = v14 << 8;
    unsigned int v18 = v10 << 8;
    do
    {
      int32x2_t v19 = vmovn_s64((int64x2_t)vcgeq_u64(v16, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v15), (int8x16_t)xmmword_184997FD0)));
      if (v19.i8[0]) {
        *(v17 - 1) = v7 & 0xFFFF0000 | (v8 >> 16 << 8) | (v9 >> 16) | v18 & 0xFF000000;
      }
      if (v19.i8[4]) {
        _DWORD *v17 = (v11 + v7) & 0xFFFF0000 | ((int)(v12 + v8) >> 16 << 8) | ((int)(v13 + v9) >> 16) | (result + v18) & 0xFF000000;
      }
      v15 += 2;
      v7 += 2 * v11;
      v17 += 2;
      v18 += v14 << 9;
      v9 += 2 * v13;
      v8 += 2 * v12;
    }
    while (((a4 + 1) & 0x1FFFFFFFELL) != v15);
  }
  return result;
}

uint64_t CA::OGL::SW::sample_texture(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, unsigned int a10, uint64_t a11)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  memset(v76, 0, sizeof(v76));
  long long v74 = 0u;
  long long v75 = 0u;
  uint64_t v67 = a2;
  unsigned int v68 = a3;
  int v69 = a4;
  uint64_t v70 = a5;
  uint64_t v71 = a6;
  uint64_t v72 = a7;
  uint64_t v73 = a8;
  LOBYTE(v74) = a9;
  uint64_t v13 = *(void *)(a1 + 16);
  uint64_t v77 = v13 + 384;
  if (a9 == 5 || a9 == 3) {
    *(_OWORD *)&v76[4] = *(_OWORD *)(v13 + 368);
  }
  int v14 = *(unsigned __int8 *)(a2 + 64);
  if (v14 == *(unsigned __int8 *)(a2 + 65))
  {
    unsigned int v15 = *(_DWORD *)(a2 + 28);
    uint64_t v16 = 2 * a3;
    float v17 = (float)*(unsigned int *)(a2 + 24);
    float v18 = (float)v15;
    int v19 = a4 & 4;
  }
  else
  {
    uint64_t v16 = 2 * a3;
    unint64_t v20 = (float *)(a6 + 4 * v16 + 32);
    uint64x2_t v21 = (float *)(a7 + 4 * v16 + 32);
    int v19 = a4 & 4;
    if ((a4 & 4) != 0)
    {
      float v25 = 1.0 / *(float *)(a5 + 12);
      float v23 = fabsf(*v21 * v25) + fabsf(*v20 * v25);
      float v24 = fabsf(*(float *)(a6 + 4 * v16 + 36) * v25);
      float v22 = *(float *)(a7 + 4 * v16 + 36) * v25;
    }
    else
    {
      float v22 = *(float *)(a7 + 4 * v16 + 36);
      float v23 = fabsf(*v21) + fabsf(*v20);
      float v24 = fabsf(*(float *)(a6 + 4 * v16 + 36));
    }
    float v26 = fabsf(v22) + v24;
    float v17 = (float)*(unsigned int *)(a2 + 24);
    unsigned int v15 = *(_DWORD *)(a2 + 28);
    float v18 = (float)v15;
    uint64_t v27 = 64;
    if ((float)((float)((float)(v23 * v17) + (float)(v26 * (float)v15)) * 0.5) < 0.99) {
      uint64_t v27 = 65;
    }
    int v14 = *(unsigned __int8 *)(a2 + v27);
  }
  uint64_t v28 = a5 + 4 * v16;
  float v29 = *(float *)(v28 + 32) * v17;
  uint64_t v30 = a6 + 4 * v16;
  float v31 = *(float *)(v30 + 36);
  float v32 = *(float *)(v30 + 32) * v17;
  uint64_t v33 = a11;
  uint64_t v34 = a10;
  float v35 = *(float *)(v28 + 36) * v18;
  float v36 = v31 * v18;
  unsigned int v37 = vcvts_n_s32_f32(v29, 0x10uLL);
  unsigned int v38 = vcvts_n_s32_f32(v35, 0x10uLL);
  int v39 = vcvts_n_s32_f32(v32, 0x10uLL);
  *(void *)((char *)&v74 + 4) = __PAIR64__(v39, v37);
  int v40 = vcvts_n_s32_f32(v36, 0x10uLL);
  HIDWORD(v74) = v38;
  LODWORD(v75) = v40;
  BOOL v42 = v31 != 0.0 && v15 != 1;
  unsigned int v43 = v14 | v42;
  if (v19 || a9)
  {
    v43 |= 6u;
  }
  else
  {
    unsigned int v44 = a10 - 1;
    unsigned int v45 = v37 + (a10 - 1) * v39;
    if (v39 >= 0) {
      unsigned int v46 = v37;
    }
    else {
      unsigned int v46 = v37 + (a10 - 1) * v39;
    }
    if (v39 < 0) {
      unsigned int v45 = v37;
    }
    if (v40 >= 0) {
      unsigned int v47 = v38;
    }
    else {
      unsigned int v47 = v38 + (a10 - 1) * v40;
    }
    if (v40 >= 0) {
      unsigned int v48 = v38 + (a10 - 1) * v40;
    }
    else {
      unsigned int v48 = v38;
    }
    signed int v49 = v45 + 0x8000;
    if ((v43 & 8) != 0) {
      v46 -= 0x8000;
    }
    else {
      signed int v49 = v45;
    }
    if ((v43 & 8) != 0) {
      unsigned int v50 = v47 - 0x8000;
    }
    else {
      unsigned int v50 = v47;
    }
    if ((v43 & 8) != 0) {
      signed int v51 = v48 + 0x8000;
    }
    else {
      signed int v51 = v48;
    }
    if ((v46 & 0x80000000) != 0 || v49 > *(_DWORD *)(a2 + 32) || (v50 & 0x80000000) != 0 || v51 > *(_DWORD *)(a2 + 36)) {
      goto LABEL_56;
    }
    float v52 = -v29;
    if (v29 >= 0.0) {
      float v52 = v29;
    }
    if (v52 > 8192.0) {
      goto LABEL_56;
    }
    float v53 = -v35;
    if (v35 >= 0.0) {
      float v53 = v35;
    }
    if (v53 > 8192.0) {
      goto LABEL_56;
    }
    float v54 = v29 + (float)(v32 * (float)v44);
    float v55 = -v54;
    if (v54 >= 0.0) {
      float v55 = v54;
    }
    if (v55 > 8192.0) {
      goto LABEL_56;
    }
    float v56 = v35 + (float)(v36 * (float)v44);
    float v57 = -v56;
    if (v56 >= 0.0) {
      float v57 = v56;
    }
    if (v57 > 8192.0) {
LABEL_56:
    }
      v43 |= 2u;
  }
  uint64_t v58 = *(void *)(v13 + 360);
  if (v58)
  {
    float v59 = -1.0;
    if (!*(unsigned char *)(v58 + 4)) {
      float v59 = 1.0;
    }
    *((float *)&v75 + 1) = v59;
    DWORD2(v75) = *(_DWORD *)(v58 + 16);
    float v60 = 0.5;
    float v61 = -0.5;
    switch(*(_DWORD *)v58)
    {
      case 1:
        HIDWORD(v75) = *(_DWORD *)(v58 + 8);
        break;
      case 2:
        goto LABEL_65;
      case 3:
        float v60 = 0.0;
        float v61 = -1.0;
        goto LABEL_65;
      case 4:
        float v60 = 1.0;
        float v61 = 0.0;
LABEL_65:
        float v62 = *(float *)(v58 + 8);
        float v63 = *(float *)(v58 + 12);
        float v64 = v62 + (float)(v63 * v61);
        float v65 = v62 + (float)(v63 * v60);
        *((float *)&v75 + 3) = v64;
        *(float *)uint64_t v76 = v65;
        if (v65 <= v64)
        {
          *((float *)&v75 + 3) = v65;
          *(float *)uint64_t v76 = v64;
        }
        break;
      default:
        break;
    }
  }
  uint64_t result = (*(uint64_t (**)(uint64_t *, void, uint64_t))(*(void *)(a2 + 48) + 8 * v43))(&v67, a10, a11);
  if (*(unsigned char *)(*(void *)(a1 + 16) + a3 + 17) == 21 && a10)
  {
    do
    {
      *(_DWORD *)uint64_t v33 = 16843009 * *(unsigned __int8 *)(v33 + 3);
      v33 += 4;
      --v34;
    }
    while (v34);
  }
  return result;
}

void CA::OGL::SW::tex_color_match(float **this, const CA::ColorProgram::Program *a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t v144 = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](this);
  signed int v9 = (char *)&v123 - v8;
  if (v6)
  {
    uint64_t v10 = v6;
    unint64_t v11 = (unint64_t)(v9 + 15) & 0xFFFFFFFFFFFFFFF0;
    bzero(v9, v7);
    unsigned int v132 = 0;
    *(int32x2_t *)v14.i8 = vdup_n_s32(0x3B808081u);
    v15.i32[1] = 255;
    uint64_t v16 = a3;
    uint64_t v17 = v10;
    do
    {
      unsigned int v19 = *v16++;
      unsigned int v18 = v19;
      unsigned int v20 = HIBYTE(v19);
      if (HIBYTE(v19))
      {
        float32x2_t v21 = vmul_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v18), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL)), *(float32x2_t *)v14.i8);
        float v22 = (float)v18 * 0.0039216;
        if (v20 != 255)
        {
          float v23 = 255.0 / (float)v20;
          float32x2_t v21 = vmul_n_f32(v21, v23);
          float v22 = v22 * v23;
        }
        unsigned int v24 = v132;
        *(_DWORD *)(v11 + 4 * v132) = v21.i32[1];
        *(_DWORD *)(v11 + 4 * (v24 + 1)) = v21.i32[0];
        *(float *)(v11 + 4 * (v24 + 2)) = v22;
        unsigned int v132 = v24 + 3;
      }
      --v17;
    }
    while (v17);
    if (v132)
    {
      uint64_t v124 = v10;
      float v125 = a3;
      unsigned int v25 = *((_DWORD *)this + 9) & 0x7FFFFFFF;
      unsigned int v26 = v132;
      if (v25)
      {
        uint64_t v27 = this[6];
        v28.i64[0] = 0x8000000080000000;
        v28.i64[1] = 0x8000000080000000;
        float v29 = 0.0031308;
        float v30 = 0.41667;
        float v31 = -0.055;
        float v32 = 1.055;
        float v142 = 12.92;
        float v141 = 0.052133;
        float v140 = 0.94787;
        float v139 = 2.4;
        float v138 = 0.077399;
        float v137 = -3.1309;
        float v136 = 5.5918;
        float v135 = 0.28467;
        float v134 = 0.33333;
        uint64_t v33 = &xmmword_184998000;
        v12.i32[1] = -1076742140;
        double v133 = -0.284668922;
        *(float *)&int v126 = 0.0031308;
        *(float *)&int v129 = -0.055;
        int v130 = 1054168405;
        *(float *)&int v128 = 1.055;
        do
        {
          switch(v25 & 0x1F)
          {
            case 1u:
              unsigned int v34 = 0;
              do
              {
                float v35 = *(float *)(v11 + 4 * v34);
                float v36 = *(float *)(v11 + 4 * (v34 + 1));
                float v37 = *(float *)(v11 + 4 * (v34 + 2));
                *(float *)(v11 + 4 * v34) = (float)((float)(v27[9] + (float)(*v27 * v35)) + (float)(v27[3] * v36))
                                            + (float)(v27[6] * v37);
                *(float *)(v11 + 4 * (v34 + 1)) = (float)((float)(v27[10] + (float)(v27[1] * v35))
                                                          + (float)(v27[4] * v36))
                                                  + (float)(v27[7] * v37);
                *(float *)(v11 + 4 * (v34 + 2)) = (float)((float)(v27[11] + (float)(v27[2] * v35))
                                                          + (float)(v27[5] * v36))
                                                  + (float)(v27[8] * v37);
                v34 += 3;
              }
              while (v34 < v26);
              v27 += 12;
              break;
            case 2u:
              unsigned int v131 = v25;
              unsigned int v38 = 0;
              do
              {
                for (uint64_t i = 0; i != 3; ++i)
                {
                  float v40 = v27[i];
                  v12.i32[0] = *(_DWORD *)(v11 + 4 * (v38 + i));
                  int8x16_t v143 = v12;
                  *(float *)v41.i32 = powf(fabsf(*(float *)v12.i32), v40);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  int8x16_t v14 = v143;
                  int8x16_t v12 = vbslq_s8(v28, v41, v143);
                  *(_DWORD *)(v11 + 4 * (v38 + i)) = v12.i32[0];
                }
                v38 += 3;
              }
              while (v38 < v26);
              v27 += 3;
              goto LABEL_82;
            case 3u:
              unsigned int v131 = v25;
              unsigned int v42 = 0;
              do
              {
                for (uint64_t j = 0; j != 3; ++j)
                {
                  unsigned int v44 = &v27[j];
                  float v45 = *v44;
                  float v46 = v44[3];
                  float v47 = v44[6];
                  v12.i32[0] = *(_DWORD *)(v11 + 4 * (v42 + j));
                  int8x16_t v143 = v12;
                  float v48 = fabsf(*(float *)v12.i32);
                  *(float *)v49.i32 = powf(v47 + (float)(v48 * v46), v45);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  if (v48 < (float)((float)-v47 / v46)) {
                    *(float *)v49.i32 = 0.0;
                  }
                  int8x16_t v14 = v143;
                  int8x16_t v12 = vbslq_s8(v28, v49, v143);
                  *(_DWORD *)(v11 + 4 * (v42 + j)) = v12.i32[0];
                }
                v42 += 3;
              }
              while (v42 < v26);
              v27 += 9;
              unsigned int v25 = v131;
              goto LABEL_49;
            case 4u:
              unsigned int v131 = v25;
              unsigned int v50 = 0;
              do
              {
                uint64_t v51 = 0;
                float v52 = v27 + 6;
                do
                {
                  float v53 = *(v52 - 6);
                  float v54 = *(v52 - 3);
                  float v55 = *v52;
                  float v56 = v52[3];
                  v12.i32[0] = *(_DWORD *)(v11 + 4 * (v50 + v51));
                  int8x16_t v143 = v12;
                  float v57 = fabsf(*(float *)v12.i32);
                  *(float *)v58.i32 = powf(v55 + (float)(v57 * v54), v53);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  if (v57 < (float)((float)-v55 / v54)) {
                    *(float *)v58.i32 = 0.0;
                  }
                  *(float *)v58.i32 = *(float *)v58.i32 + v56;
                  int8x16_t v14 = v143;
                  int8x16_t v12 = vbslq_s8(v28, v58, v143);
                  *(_DWORD *)(v11 + 4 * (v50 + v51++)) = v12.i32[0];
                  ++v52;
                }
                while (v51 != 3);
                v50 += 3;
                unsigned int v26 = v132;
              }
              while (v50 < v132);
              v27 += 12;
              unsigned int v25 = v131;
              goto LABEL_48;
            case 5u:
              unsigned int v131 = v25;
              unsigned int v59 = 0;
              do
              {
                uint64_t v60 = 0;
                float v61 = v27 + 6;
                do
                {
                  float v62 = *(v61 - 6);
                  float v63 = *(v61 - 3);
                  float v64 = *v61;
                  float v65 = v61[3];
                  float v66 = v61[6];
                  v13.i32[0] = *(_DWORD *)(v11 + 4 * (v59 + v60));
                  int8x16_t v143 = v13;
                  float v67 = fabsf(*(float *)v13.i32);
                  *(float *)v68.i32 = powf(v64 + (float)(v67 * v63), v62);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  if (v67 < v66) {
                    *(float *)v68.i32 = v67 * v65;
                  }
                  int8x16_t v14 = v143;
                  int8x16_t v12 = vbslq_s8(v28, v68, v143);
                  *(_DWORD *)(v11 + 4 * (v59 + v60++)) = v12.i32[0];
                  ++v61;
                }
                while (v60 != 3);
                v59 += 3;
                unsigned int v26 = v132;
              }
              while (v59 < v132);
              v27 += 15;
              unsigned int v25 = v131;
              float v29 = *(float *)&v126;
              goto LABEL_50;
            case 6u:
              unsigned int v131 = v25;
              unsigned int v69 = 0;
              do
              {
                uint64_t v70 = 0;
                uint64_t v71 = v27 + 9;
                do
                {
                  float v72 = *(v71 - 9);
                  float v73 = *(v71 - 6);
                  float v74 = *(v71 - 3);
                  float v75 = *v71;
                  float v76 = v71[3];
                  float v77 = v71[6];
                  float v78 = v71[9];
                  v13.i32[0] = *(_DWORD *)(v11 + 4 * (v69 + v70));
                  int8x16_t v143 = v13;
                  float v79 = fabsf(*(float *)v13.i32);
                  *(float *)v80.i32 = powf(v74 + (float)(v79 * v73), v72);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  *(float *)v80.i32 = *(float *)v80.i32 + v77;
                  if (v79 < v76) {
                    *(float *)v80.i32 = v78 + (float)(v79 * v75);
                  }
                  int8x16_t v14 = v143;
                  int8x16_t v12 = vbslq_s8(v28, v80, v143);
                  *(_DWORD *)(v11 + 4 * (v69 + v70++)) = v12.i32[0];
                  ++v71;
                }
                while (v70 != 3);
                v69 += 3;
                unsigned int v26 = v132;
              }
              while (v69 < v132);
              v27 += 21;
              unsigned int v25 = v131;
LABEL_48:
              float v29 = *(float *)&v126;
LABEL_49:
              float v30 = *(float *)&v130;
LABEL_50:
              float v32 = *(float *)&v128;
              float v31 = *(float *)&v129;
              goto LABEL_83;
            case 0xBu:
              unsigned int v131 = v25;
              unsigned int v81 = 0;
              do
              {
                for (uint64_t k = 0; k != 3; ++k)
                {
                  uint64_t v83 = v81 + k;
                  v14.i32[0] = *(_DWORD *)(v11 + 4 * v83);
                  float v84 = fabsf(*(float *)v14.i32);
                  if (v84 <= v29)
                  {
                    *(float *)v12.i32 = *(float *)v14.i32 * v142;
                  }
                  else
                  {
                    int8x16_t v143 = v14;
                    float v85 = powf(v84, v30);
                    v28.i64[0] = 0x8000000080000000;
                    v28.i64[1] = 0x8000000080000000;
                    *(float *)v86.i32 = v31 + (float)(v85 * v32);
                    int8x16_t v14 = v143;
                    int8x16_t v12 = vbslq_s8(v28, v86, v143);
                  }
                  *(_DWORD *)(v11 + 4 * v83) = v12.i32[0];
                }
                v81 += 3;
              }
              while (v81 < v26);
              goto LABEL_82;
            case 0xCu:
              unsigned int v131 = v25;
              unsigned int v87 = 0;
              do
              {
                for (uint64_t m = 0; m != 3; ++m)
                {
                  uint64_t v89 = v87 + m;
                  v14.i32[0] = *(_DWORD *)(v11 + 4 * v89);
                  float v90 = fabsf(*(float *)v14.i32);
                  if (v90 <= 0.04045)
                  {
                    *(float *)v12.i32 = *(float *)v14.i32 * v138;
                  }
                  else
                  {
                    int8x16_t v143 = v14;
                    *(float *)v91.i32 = powf(v141 + (float)(v90 * v140), v139);
                    v28.i64[0] = 0x8000000080000000;
                    v28.i64[1] = 0x8000000080000000;
                    int8x16_t v14 = v143;
                    int8x16_t v12 = vbslq_s8(v28, v91, v143);
                  }
                  *(_DWORD *)(v11 + 4 * v89) = v12.i32[0];
                }
                v87 += 3;
              }
              while (v87 < v26);
              goto LABEL_82;
            case 0xDu:
              unsigned int v131 = v25;
              unsigned int v92 = 0;
              do
              {
                for (uint64_t n = 0; n != 3; ++n)
                {
                  uint64_t v94 = v92 + n;
                  v15.i32[0] = *(_DWORD *)(v11 + 4 * v94);
                  if (fabsf(*(float *)v15.i32) <= 0.5)
                  {
                    *(float *)v12.i32 = (float)(*(float *)v15.i32 * *(float *)v15.i32) * v134;
                  }
                  else
                  {
                    int8x16_t v143 = v15;
                    *(float *)v12.i32 = expf(v137 + (float)(*(float *)v15.i32 * v136));
                    int8x16_t v15 = v143;
                    v28.i64[0] = 0x8000000080000000;
                    v28.i64[1] = 0x8000000080000000;
                    *(double *)v12.i64 = (float)(*(float *)v12.i32 + v135) * 0.0833333333;
                    *(float *)v12.i32 = *(double *)v12.i64;
                  }
                  *(float *)v12.i32 = *(float *)v12.i32 * 12.0;
                  int8x16_t v12 = vbslq_s8(v28, v12, v15);
                  *(_DWORD *)(v11 + 4 * v94) = v12.i32[0];
                }
                v92 += 3;
              }
              while (v92 < v26);
              goto LABEL_82;
            case 0xEu:
              unsigned int v131 = v25;
              unsigned int v95 = 0;
              do
              {
                for (iuint64_t i = 0; ii != 3; ++ii)
                {
                  uint64_t v97 = v95 + ii;
                  *(double *)v12.i64 = *(float *)(v11 + 4 * v97) * 0.0833333333;
                  *(float *)v15.i32 = *(double *)v12.i64;
                  *(float *)v12.i32 = fabsf(*(float *)v15.i32);
                  if (*(float *)v12.i32 <= 0.083333)
                  {
                    *(float *)v12.i32 = sqrtf(*(float *)v12.i32 * 3.0);
                  }
                  else
                  {
                    int8x16_t v143 = v15;
                    *(double *)v12.i64 = log(v133 + *(float *)v12.i32 * 12.0);
                    v28.i64[0] = 0x8000000080000000;
                    v28.i64[1] = 0x8000000080000000;
                    v14.i32[1] = 1071770313;
                    *(double *)v12.i64 = *(double *)v12.i64 * 0.178832769 + 0.559910715;
                    int8x16_t v15 = v143;
                    *(float *)v12.i32 = *(double *)v12.i64;
                  }
                  int8x16_t v12 = vbslq_s8(v28, v12, v15);
                  *(_DWORD *)(v11 + 4 * v97) = v12.i32[0];
                }
                v95 += 3;
              }
              while (v95 < v26);
LABEL_82:
              unsigned int v25 = v131;
LABEL_83:
              uint64_t v33 = &xmmword_184998000;
              break;
            case 0xFu:
              unsigned int v131 = v25;
              int32x2_t v127 = v27;
              unsigned int v99 = 0;
              do
              {
                for (juint64_t j = 0; jj != 3; ++jj)
                {
                  v12.i32[0] = *(_DWORD *)(v11 + 4 * (v99 + jj));
                  int8x16_t v143 = v12;
                  float v101 = powf(fabsf(*(float *)v12.i32), 0.012683);
                  float v102 = powf((float)(v101 + -0.83594) / (float)((float)(v101 * -18.688) + 18.852), 6.2774);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  *(float *)v103.i32 = v102 * 100.0;
                  int8x16_t v14 = v143;
                  int8x16_t v12 = vbslq_s8(v28, v103, v143);
                  *(_DWORD *)(v11 + 4 * (v99 + jj)) = v12.i32[0];
                }
                v99 += 3;
                unsigned int v26 = v132;
              }
              while (v99 < v132);
              uint64_t v27 = v127;
              uint64_t v33 = &xmmword_184998000;
              goto LABEL_96;
            case 0x10u:
              unsigned int v131 = v25;
              int32x2_t v127 = v27;
              unsigned int v104 = 0;
              do
              {
                for (kuint64_t k = 0; kk != 3; ++kk)
                {
                  *(double *)v12.i64 = *(float *)(v11 + 4 * (v104 + kk)) * 0.01;
                  *(float *)v12.i32 = *(double *)v12.i64;
                  int8x16_t v143 = v12;
                  float v106 = powf(fabsf(*(float *)v12.i32), 0.1593);
                  *(float *)v107.i32 = powf((float)((float)(v106 * 18.852) + 0.83594)/ (float)((float)(v106 * *((float *)v33 + 614)) + 1.0), 78.844);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  int8x16_t v14 = v143;
                  int8x16_t v12 = vbslq_s8(v28, v107, v143);
                  *(_DWORD *)(v11 + 4 * (v104 + kk)) = v12.i32[0];
                }
                v104 += 3;
                unsigned int v26 = v132;
              }
              while (v104 < v132);
              uint64_t v27 = v127;
              float v30 = *(float *)&v130;
LABEL_96:
              unsigned int v25 = v131;
              break;
            default:
              break;
          }
          BOOL v98 = v25 > 0x1F;
          v25 >>= 5;
        }
        while (v98);
      }
      unsigned int v108 = 0;
      BOOL v109 = v125;
      uint64_t v110 = v124;
      do
      {
        unint64_t v111 = *v109;
        if (v111)
        {
          float v112 = *(float *)(v11 + 4 * v108);
          float v113 = *(float *)(v11 + 4 * (v108 + 1));
          float v114 = *(float *)(v11 + 4 * (v108 + 2));
          if (v112 > 1.0) {
            float v112 = 1.0;
          }
          if (v113 > 1.0) {
            float v113 = 1.0;
          }
          if (v114 > 1.0) {
            float v114 = 1.0;
          }
          if (v112 >= 0.0) {
            float v115 = (float)(v112 * 255.0) + 0.5;
          }
          else {
            float v115 = 0.5;
          }
          unsigned int v116 = v115;
          float v117 = (float)(v113 * 255.0) + 0.5;
          if (v113 < 0.0) {
            float v117 = 0.5;
          }
          unsigned int v118 = v117;
          float v119 = (float)(v114 * 255.0) + 0.5;
          if (v114 < 0.0) {
            float v119 = 0.5;
          }
          uint64_t v120 = (v116 << 16) | (v118 << 8) | v119 | 0xFF000000;
          unint64_t v121 = v111 >> 24;
          if (v121 != 255)
          {
            unint64_t v122 = ((((v120 | (v120 << 24)) & 0xFF00FF00FF00FFLL) + ((v120 | (v120 << 24)) & 0xFF00FF00FF00FFLL) * v121) >> 8) & 0xFF00FF00FF00FFLL;
            LODWORD(v120) = (v122 >> 24) | v122;
          }
          v108 += 3;
          *BOOL v109 = v120;
        }
        ++v109;
        --v110;
      }
      while (v110);
    }
  }
}

unsigned __int32 *CA::OGL::SW::tex_multiply_color(unsigned __int32 *this, unsigned int *a2, const unsigned int *a3, uint64_t a4)
{
  if (a4)
  {
    int32x2_t v4 = vadd_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(a3 >> 8), (int8x8_t)0xFF0000FF00), (int32x2_t)0x100000100);
    do
    {
      unsigned int v5 = *a2++;
      int8x8_t v6 = vand_s8((int8x8_t)vmul_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v5), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)0x1FF0001FF0000);
      *this++ = ((((a3 >> 8) & 0xFF0000) + 0x10000) * HIBYTE(v5)) & 0xFF000000 | ((v5
                                                                                               * (a3
                                                                                                + 1)) >> 8) | v6.i32[0] | v6.i32[1];
      --a4;
    }
    while (a4);
  }
  return this;
}

unsigned __int32 *CA::OGL::SW::tex_multiply_color(unsigned __int32 *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4)
{
  for (; a4; a4 = (const unsigned int *)((char *)a4 - 1))
  {
    unsigned int v5 = *a2++;
    unsigned int v4 = v5;
    unsigned int v6 = *a3++;
    int8x8_t v7 = vand_s8((int8x8_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v4 >> 8), (int8x8_t)0xFF0000FF00), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (int32x2_t)0x100000001)), (int8x8_t)0x1FF0001FF0000);
    *this++ = (((v4 >> 8) & 0xFF0000) + ((v4 >> 8) & 0xFF0000) * HIBYTE(v6)) & 0xFF000000 | ((v4
                                                                                            * v6
                                                                                            + v4) >> 8) | v7.i32[0] | v7.i32[1];
  }
  return this;
}

unsigned int *CA::OGL::SW::tex_interpolate(unsigned int *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4, uint64_t a5)
{
  for (; a5; --a5)
  {
    unsigned int v6 = *a2++;
    unsigned int v5 = v6;
    unsigned int v7 = *a3++;
    *this++ = ((v5 & 0xFF00FF) + ((((v7 & 0xFF00FF) - (v5 & 0xFF00FF)) * a4) >> 8)) & 0xFF00FF | ((((v7 >> 8) & 0xFF00FF) - ((v5 >> 8) & 0xFF00FF)) * a4 + (((v5 >> 8) & 0xFF00FF) << 8)) & 0xFF00FF00;
  }
  return this;
}

unsigned int *CA::OGL::SW::convert_in(unsigned int *this, unsigned int *a2, unsigned __int8 *a3, void *a4, uint64_t a5)
{
  if ((int)a4 <= 14)
  {
    if (a4)
    {
      if (a4 == 8)
      {
        if (a3)
        {
          for (; a5; --a5)
          {
            int v7 = *a3++;
            int v6 = v7;
            int v8 = *(unsigned __int8 *)a2;
            a2 = (unsigned int *)((char *)a2 + 1);
            *this++ = (v8 << 8) | (v6 << 24) | v8 | (((v8 << 8) | (v6 << 24) | v8) << 8);
          }
        }
        else
        {
          for (; a5; --a5)
          {
            int v15 = *(unsigned __int8 *)a2;
            a2 = (unsigned int *)((char *)a2 + 1);
            *this++ = (65793 * v15) | 0xFF000000;
          }
        }
      }
    }
    else
    {
      for (; a5; --a5)
      {
        int v14 = *a3++;
        *this++ = v14 | (v14 << 8) | ((v14 | (v14 << 8)) << 16);
      }
    }
  }
  else if (a4 == 15)
  {
    if (a3)
    {
      for (; a5; --a5)
      {
        int v10 = *a3++;
        int v9 = v10;
        unsigned int v11 = *(unsigned __int16 *)a2;
        a2 = (unsigned int *)((char *)a2 + 2);
        unsigned int v12 = (v11 << 6) & 0xF800 | (8 * (v11 & 0x1F)) | (((v11 >> 10) & 0x1F) << 19);
        *this++ = (v12 >> 3) & 0x70707 | (v9 << 24) | v12;
      }
    }
    else
    {
      for (; a5; --a5)
      {
        unsigned int v16 = *(unsigned __int16 *)a2;
        a2 = (unsigned int *)((char *)a2 + 2);
        unsigned int v17 = (v16 << 6) & 0xF800 | (8 * (v16 & 0x1F)) | (((v16 >> 10) & 0x1F) << 19);
        *this++ = v17 | (v17 >> 3) & 0x70707 | 0xFF000000;
      }
    }
  }
  else if (a4 == 32)
  {
    if (a3)
    {
      for (; a5; --a5)
      {
        unsigned int v13 = *a2++;
        *this++ = v13;
      }
    }
    else
    {
      for (; a5; --a5)
      {
        int v18 = *a2++;
        *this++ = v18 | 0xFF000000;
      }
    }
  }
  else if (a4 == 16 && a5)
  {
    do
    {
      unsigned int v5 = *(unsigned __int16 *)a2;
      a2 = (unsigned int *)((char *)a2 + 2);
      *this++ = (65792 * v5) | (v5 >> 8 << 24) | v5;
      --a5;
    }
    while (a5);
  }
  return this;
}

unsigned int *CA::OGL::SW::tex_blend_dest(CA::OGL::SW *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4, const unsigned int *a5)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  size_t v10 = 4 * (void)a5;
  MEMORY[0x1F4188790](this);
  bzero((char *)v14 - ((v10 + 30) & 0xFFFFFFFFFFFFFFF0), v11);
  unsigned int v12 = (void *)(((unint64_t)&v14[1] - ((v10 + 30) & 0xFFFFFFFFFFFFFFF0) + 7) & 0xFFFFFFFFFFFFFFF0);
  memcpy(v12, a2, v10);
  return CA::OGL::SW::tex_mix((unsigned int *)this, a3, (unsigned int *)v12, a4, a5);
}

unsigned int *CA::OGL::SW::tex_blend_color(CA::OGL::SW *this, unsigned int *a2, const unsigned int *a3, const unsigned int *a4, const unsigned int *a5, void (*a6)(void *, unsigned int *, void *, const unsigned int *, void), void (*a7)(unsigned int *, const unsigned int *, const unsigned int *, unint64_t, const unsigned int *), const unsigned int *a8)
{
  int v12 = (int)a3;
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = 4 * (void)a5;
  MEMORY[0x1F4188790](this);
  bzero(&v19[-((v15 + 30) & 0xFFFFFFFFFFFFFFF0)], v16);
  unsigned int v17 = (void *)((unint64_t)&v19[-((v15 + 30) & 0xFFFFFFFFFFFFFFF0) + 15] & 0xFFFFFFFFFFFFFFF0);
  int __pattern4 = v12;
  memset_pattern4(v17, &__pattern4, v15 & 0xFFFFFFFC);
  a6(v17, a2, v17, a5, a7);
  return CA::OGL::SW::tex_mix((unsigned int *)this, a2, (unsigned int *)v17, a4, a5);
}

unsigned int *CA::OGL::SW::tex_blend_image(CA::OGL::SW *this, unsigned int *a2, const unsigned int *a3, const unsigned int *a4, const unsigned int *a5, void (*a6)(unsigned int *, unsigned int *, const unsigned int *, const unsigned int *, void), void (*a7)(unsigned int *, const unsigned int *, const unsigned int *, unint64_t, const unsigned int *), const unsigned int *a8)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](this);
  size_t v16 = (char *)v20 - ((v15 + 30) & 0xFFFFFFFFFFFFFFF0);
  bzero(v16, v17);
  int v18 = (unsigned int *)((unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  a6(v18, a2, a3, a5, a7);
  return CA::OGL::SW::tex_mix((unsigned int *)this, a2, v18, a4, a5);
}

unsigned int *CA::OGL::SW::tex_color_matrix_4x4_bias(unsigned int *this, unsigned int *a2, const unsigned int *a3, float32x2_t *a4, const float *a5)
{
  if (a3)
  {
    __asm { FMOV            V3.2S, #1.0 }
    float32x2_t v10 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      int v11 = *a2;
      unsigned int v12 = HIBYTE(*a2);
      if (v12)
      {
        float v14 = (float)v12 * 0.0039216;
        float v15 = 1.0 / (float)v12;
        float v16 = v15 * (float)BYTE2(v11);
        float v17 = v15 * (float)BYTE1(v11);
        float v18 = v15 * (float)*a2;
        float32x2_t v19 = vmla_n_f32(vmla_n_f32(vmla_n_f32(vmla_n_f32(a4[9], a4[1], v16), a4[3], v17), a4[5], v18), a4[7], v14);
        float v20 = v19.f32[1];
        float v21 = vmuls_lane_f32(v19.f32[0], v19, 1);
        if (v21 > 1.0) {
          float v21 = 1.0;
        }
        if (v19.f32[1] > 1.0) {
          float v20 = 1.0;
        }
        _NF = v20 < 0.0;
        float v22 = (float)(v20 * 255.0) + 0.5;
        if (_NF) {
          float v22 = 0.5;
        }
        float32x2_t v23 = vmul_lane_f32(vmla_n_f32(vmla_n_f32(vmla_n_f32(vmla_n_f32(a4[8], *a4, v16), a4[2], v17), a4[4], v18), a4[6], v14), v19, 1);
        float32x2_t v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v23, _D3), (int8x8_t)_D3, (int8x8_t)v23);
        uint32x2_t v26 = vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v24), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v10, v24))), (uint32x2_t)0x800000010);
        unsigned __int32 v25 = v26.i32[0] | (v22 << 24);
        *(float *)v26.i32 = (float)(v21 * 255.0) + 0.5;
        if (v21 < 0.0) {
          *(float *)v26.i32 = 0.5;
        }
        unsigned int v13 = v25 | v26.i32[1] | *(float *)v26.i32;
      }
      else
      {
        unsigned int v13 = 0;
      }
      *this++ = v13;
      ++a2;
      a3 = (const unsigned int *)((char *)a3 - 1);
    }
    while (a3);
  }
  return this;
}

unsigned int *CA::OGL::SW::tex_vibrant_color_matrix(CA::OGL::SW *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4, float32x2_t *a5, const float *a6)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](this);
  unsigned int v12 = (char *)v17 - ((v11 + 30) & 0xFFFFFFFFFFFFFFF0);
  bzero(v12, v13);
  float v14 = (unsigned int *)((unint64_t)(v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  CA::OGL::SW::tex_color_matrix_4x4_bias(v14, a2, a4, a5, v15);
  return CA::OGL::SW::tex_mix((unsigned int *)this, a2, v14, a3, a4);
}

unsigned __int32 *CA::OGL::SW::tex_vibrant_dark(CA::OGL::SW *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4, float *a5, const float *a6)
{
  int v9 = (unsigned int *)this;
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  float32x2_t v10 = (const unsigned int *)(((float)((float)(a5[1] * 255.0) + 0.5) << 8) | ((float)((float)(*a5 * 255.0) + 0.5) << 16) | (float)((float)(a5[2] * 255.0) + 0.5) | ((float)((float)(a5[3] * 255.0) + 0.5) << 24));
  uint64_t v11 = (const unsigned int *)(((float)((float)(a5[5] * 255.0) + 0.5) << 8) | ((float)((float)(a5[4] * 255.0) + 0.5) << 16) | (float)((float)(a5[6] * 255.0) + 0.5) | ((float)((float)(a5[7] * 255.0) + 0.5) << 24));
  float v12 = a5[8];
  MEMORY[0x1F4188790](this);
  float v14 = (char *)&v64 - ((v13 + 30) & 0xFFFFFFFFFFFFFFF0);
  bzero(v14, v15);
  float v16 = (unsigned __int32 *)((unint64_t)(v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v12 == 0.0)
  {
    uint64_t result = CA::OGL::SW::tex_multiply_color(v16, a3, v10, (uint64_t)a4);
    if (a4)
    {
      float v40 = 0;
      do
      {
        unsigned int v41 = v16[(void)v40];
        unsigned int v42 = a2[(void)v40];
        unsigned int v43 = HIBYTE(v41);
        int32x2_t v44 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v41), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
        unsigned int v45 = v41;
        unsigned int v46 = HIBYTE(v42);
        int v47 = HIBYTE(v41) + 1;
        signed int v48 = (HIBYTE(v42) * v47) >> 8;
        if (HIBYTE(v42) == 255)
        {
          unsigned int v49 = 0;
          int32x2_t v50 = 0;
        }
        else
        {
          v48 += ((v46 ^ 0xFF) * v47) >> 8;
          int32x2_t v50 = (int32x2_t)vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v46 ^ 0xFF), vadd_s32(v44, (int32x2_t)0x100000001)), 8uLL);
          unsigned int v49 = ((v46 ^ 0xFF) + (v46 ^ 0xFF) * v45) >> 8;
        }
        int32x2_t v51 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v42), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
        int v52 = a2[(void)v40];
        if (v43 != 255)
        {
          int v53 = v43 ^ 0xFF;
          v48 += (v53 + v53 * v46) >> 8;
          int32x2_t v50 = (int32x2_t)vsra_n_u32((uint32x2_t)v50, (uint32x2_t)vmul_s32(vadd_s32(v51, (int32x2_t)0x100000001), vdup_n_s32(v43 ^ 0xFF)), 8uLL);
          v49 += (v53 + v53 * v52) >> 8;
        }
        unsigned int v54 = v47 * v43;
        int v55 = v43;
        if (v43 > v44.i32[0])
        {
          int v55 = (int)(255 * ((v51.i32[0] + v51.i32[0] * (v54 >> 8)) >> 8)) / (int)(v43 - v44.i32[0]);
          if (v55 >= (int)v43) {
            int v55 = v43;
          }
        }
        int v56 = v43;
        if (v43 > v44.i32[1])
        {
          int v56 = (int)(255 * ((v51.i32[1] + v51.i32[1] * (v54 >> 8)) >> 8)) / (int)(v43 - v44.i32[1]);
          if (v56 >= (int)v43) {
            int v56 = v43;
          }
        }
        int v57 = (int)(255 * ((v52 + v52 * (v54 >> 8)) >> 8)) / (int)(v43 - v45);
        if (v57 >= (int)v43) {
          int v57 = v43;
        }
        if (v43 > v45) {
          unsigned int v43 = v57;
        }
        int32x2_t v58 = vadd_s32((int32x2_t)__PAIR64__(v56, v55), v50);
        int v59 = v43 + v49;
        if (v59 >= v48) {
          int v59 = v48;
        }
        uint32x2_t v60 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v58, vdup_n_s32(v48)), 0), (uint32x2_t)0x800000010);
        v9[(void)v40] = v60.i32[0] | (v48 << 24) | v59 & ~(v59 >> 31) | v60.i32[1];
        float v40 = (const unsigned int *)((char *)v40 + 1);
      }
      while (a4 != v40);
      CA::OGL::SW::tex_multiply_color(v16, a3, v11, (uint64_t)a4);
      do
      {
        unsigned __int32 v63 = *v16++;
        HIDWORD(v64) = *v9;
        uint64_t result = CA::OGL::SW::Blend::LightenSover::f((_DWORD *)&v64 + 1, (unsigned int *)v63, v61, v62);
        *v9++ = HIDWORD(v64);
        a4 = (const unsigned int *)((char *)a4 - 1);
      }
      while (a4);
    }
  }
  else
  {
    uint64_t result = CA::OGL::SW::tex_multiply_color(v16, a3, v11, (uint64_t)a4);
    if (a4)
    {
      float v20 = 0;
      do
      {
        float v21 = (unsigned int *)v16[(void)v20];
        HIDWORD(v64) = a2[(void)v20];
        CA::OGL::SW::Blend::LightenSover::f((_DWORD *)&v64 + 1, v21, v18, v19);
        v9[(void)v20] = HIDWORD(v64);
        float v20 = (const unsigned int *)((char *)v20 + 1);
      }
      while (a4 != v20);
      uint64_t result = CA::OGL::SW::tex_multiply_color(v16, a3, v10, (uint64_t)a4);
      do
      {
        unsigned int v22 = HIBYTE(*v16);
        int32x2_t v23 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v16), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
        unsigned int v24 = *v16;
        unsigned int v25 = HIBYTE(*v9);
        unsigned int v26 = v22 + 1;
        signed int v27 = (v25 * (v22 + 1)) >> 8;
        if (v25 == 255)
        {
          unsigned int v28 = 0;
          int32x2_t v29 = 0;
        }
        else
        {
          v27 += ((v25 ^ 0xFF) * v26) >> 8;
          int32x2_t v29 = (int32x2_t)vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v25 ^ 0xFF), vadd_s32(v23, (int32x2_t)0x100000001)), 8uLL);
          unsigned int v28 = ((v25 ^ 0xFF) + (v25 ^ 0xFF) * v24) >> 8;
        }
        int32x2_t v30 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v9), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
        int v31 = *v9;
        if (v22 != 255)
        {
          int v32 = v22 ^ 0xFF;
          v27 += (v32 + v32 * v25) >> 8;
          int32x2_t v29 = (int32x2_t)vsra_n_u32((uint32x2_t)v29, (uint32x2_t)vmul_s32(vadd_s32(v30, (int32x2_t)0x100000001), vdup_n_s32(v22 ^ 0xFF)), 8uLL);
          v28 += (v32 + v32 * v31) >> 8;
        }
        unsigned int v33 = v26 * v22;
        signed int v34 = HIBYTE(*v16);
        if (v22 > v23.i32[0])
        {
          signed int v34 = (int)(255 * ((v30.i32[0] + v30.i32[0] * (v33 >> 8)) >> 8)) / (int)(v22 - v23.i32[0]);
          if (v34 >= (int)v22) {
            signed int v34 = HIBYTE(*v16);
          }
        }
        signed int v35 = HIBYTE(*v16);
        if (v22 > v23.i32[1])
        {
          signed int v35 = (int)(255 * ((v30.i32[1] + v30.i32[1] * (v33 >> 8)) >> 8)) / (int)(v22 - v23.i32[1]);
          if (v35 >= (int)v22) {
            signed int v35 = HIBYTE(*v16);
          }
        }
        int v36 = (int)(255 * ((v31 + v31 * (v33 >> 8)) >> 8)) / (int)(v22 - v24);
        if (v36 >= (int)v22) {
          int v36 = HIBYTE(*v16);
        }
        if (v22 > v24) {
          unsigned int v22 = v36;
        }
        int32x2_t v37 = vadd_s32((int32x2_t)__PAIR64__(v35, v34), v29);
        int v38 = v22 + v28;
        if (v38 >= v27) {
          int v38 = v27;
        }
        uint32x2_t v39 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v37, vdup_n_s32(v27)), 0), (uint32x2_t)0x800000010);
        *v9++ = v39.i32[0] | (v27 << 24) | v38 & ~(v38 >> 31) | v39.i32[1];
        ++v16;
        a4 = (const unsigned int *)((char *)a4 - 1);
      }
      while (a4);
    }
  }
  return result;
}

void *CA::OGL::SW::tex_vibrant_light(CA::OGL::SW *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4, float *a5, const float *a6)
{
  int v9 = this;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  float32x2_t v10 = (const unsigned int *)(((float)((float)(a5[1] * 255.0) + 0.5) << 8) | ((float)((float)(*a5 * 255.0) + 0.5) << 16) | (float)((float)(a5[2] * 255.0) + 0.5) | ((float)((float)(a5[3] * 255.0) + 0.5) << 24));
  uint64_t v11 = (const unsigned int *)(((float)((float)(a5[5] * 255.0) + 0.5) << 8) | ((float)((float)(a5[4] * 255.0) + 0.5) << 16) | (float)((float)(a5[6] * 255.0) + 0.5) | ((float)((float)(a5[7] * 255.0) + 0.5) << 24));
  float v12 = a5[8];
  MEMORY[0x1F4188790](this);
  float v14 = (char *)&v28 - ((v13 + 30) & 0xFFFFFFFFFFFFFFF0);
  bzero(v14, v15);
  float v16 = (unsigned __int32 *)((unint64_t)(v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v12 == 0.0)
  {
    uint64_t result = CA::OGL::SW::tex_multiply_color(v16, a3, v10, (uint64_t)a4);
    if (a4)
    {
      int32x2_t v23 = 0;
      do
      {
        unsigned int v24 = v16[(void)v23];
        HIDWORD(v28) = a2[(void)v23];
        CA::OGL::SW::Blend::SeparableMode<CA::OGL::SW::Blend::ColorBurn>::f((int *)&v28 + 1, v24);
        *((_DWORD *)v9 + (void)v23) = HIDWORD(v28);
        int32x2_t v23 = (const unsigned int *)((char *)v23 + 1);
      }
      while (a4 != v23);
      CA::OGL::SW::tex_multiply_color(v16, a3, v11, (uint64_t)a4);
      do
      {
        unsigned __int32 v27 = *v16++;
        HIDWORD(v28) = *(_DWORD *)v9;
        uint64_t result = CA::OGL::SW::Blend::DarkenSover::f((_DWORD *)&v28 + 1, (unsigned int *)v27, v25, v26);
        *(_DWORD *)int v9 = HIDWORD(v28);
        int v9 = (CA::OGL::SW *)((char *)v9 + 4);
        a4 = (const unsigned int *)((char *)a4 - 1);
      }
      while (a4);
    }
  }
  else
  {
    uint64_t result = CA::OGL::SW::tex_multiply_color(v16, a3, v11, (uint64_t)a4);
    if (a4)
    {
      float v20 = 0;
      do
      {
        float v21 = (unsigned int *)v16[(void)v20];
        HIDWORD(v28) = a2[(void)v20];
        CA::OGL::SW::Blend::DarkenSover::f((_DWORD *)&v28 + 1, v21, v18, v19);
        *((_DWORD *)v9 + (void)v20) = HIDWORD(v28);
        float v20 = (const unsigned int *)((char *)v20 + 1);
      }
      while (a4 != v20);
      CA::OGL::SW::tex_multiply_color(v16, a3, v10, (uint64_t)a4);
      do
      {
        unsigned int v22 = *v16++;
        HIDWORD(v28) = *(_DWORD *)v9;
        uint64_t result = CA::OGL::SW::Blend::SeparableMode<CA::OGL::SW::Blend::ColorBurn>::f((int *)&v28 + 1, v22);
        *(_DWORD *)int v9 = HIDWORD(v28);
        int v9 = (CA::OGL::SW *)((char *)v9 + 4);
        a4 = (const unsigned int *)((char *)a4 - 1);
      }
      while (a4);
    }
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::DarkenSover::f(_DWORD *this, unsigned int *a2, unsigned int a3, const unsigned int *a4)
{
  uint64_t v4 = *this;
  unsigned int v5 = 19 * *this + 183 * BYTE1(v4) + 54 * BYTE2(v4);
  unsigned int v6 = (v5 >> 8) * (v5 >> 8) + (v5 >> 8);
  unint64_t v7 = ((((a2 | ((unint64_t)a2 << 24)) & 0xFF00FF00FF00FFLL)
       * ((((v6 >> 8) * (v6 >> 8) + (v6 >> 8)) >> 8) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
  unint64_t v8 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)((~(v7 >> 24) >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
  *this = ((v8 >> 24) | v8) + ((v7 >> 24) | v7);
  return this;
}

int *CA::OGL::SW::Blend::SeparableMode<CA::OGL::SW::Blend::ColorBurn>::f(int *result, unsigned int a2)
{
  unsigned int v2 = HIBYTE(a2);
  int v3 = BYTE2(a2);
  int v4 = BYTE1(a2);
  int v5 = a2;
  int v6 = *result;
  unsigned int v7 = HIBYTE(*result);
  unsigned int v8 = v2 + 1;
  unsigned int v9 = (v7 * (v2 + 1)) >> 8;
  if (v7 == 255)
  {
    signed int v10 = 0;
    signed int v11 = 0;
    signed int v12 = 0;
    signed int v13 = (255 * (v2 + 1)) >> 8;
  }
  else
  {
    int v14 = v7 ^ 0xFF;
    signed int v13 = v9 + (((v7 ^ 0xFF) * v8) >> 8);
    signed int v10 = (v14 + v14 * v3) >> 8;
    signed int v11 = (v14 + v14 * v4) >> 8;
    signed int v12 = (v14 + v14 * v5) >> 8;
  }
  int v15 = BYTE2(v6);
  int v16 = BYTE1(v6);
  int v17 = *result;
  if (v2 != 255)
  {
    int v18 = v2 ^ 0xFF;
    v13 += (v18 + v18 * v7) >> 8;
    v10 += (v18 + v18 * v15) >> 8;
    v11 += (v18 + v18 * v16) >> 8;
    v12 += (v18 + v18 * v17) >> 8;
  }
  if (v3) {
    signed int v10 = v10 + v9 - ((int)(((v8 * v2) >> 8) * ((int)(255 * (v7 - v15)) / v3) + ((v8 * v2) >> 8)) >> 8);
  }
  if (v4) {
    signed int v11 = v11 + v9 - ((int)(((v8 * v2) >> 8) * ((int)(255 * (v7 - v16)) / v4) + ((v8 * v2) >> 8)) >> 8);
  }
  if (v5) {
    signed int v12 = v12 + v9 - ((int)(((v8 * v2) >> 8) * ((int)(255 * (v7 - v17)) / v5) + ((v8 * v2) >> 8)) >> 8);
  }
  if (v11 >= v13) {
    int v19 = v13;
  }
  else {
    int v19 = v11;
  }
  int v20 = v19 & ~(v19 >> 31);
  if (v10 >= v13) {
    int v21 = v13;
  }
  else {
    int v21 = v10;
  }
  int v22 = v21 & ~(v21 >> 31);
  if (v12 >= v13) {
    int v23 = v13;
  }
  else {
    int v23 = v12;
  }
  void *result = (v22 << 16) | (v13 << 24) | (v20 << 8) | v23 & ~(v23 >> 31);
  return result;
}

_DWORD *CA::OGL::SW::Blend::LightenSover::f(_DWORD *this, unsigned int *a2, unsigned int a3, const unsigned int *a4)
{
  uint64_t v4 = *this;
  unsigned int v5 = 19 * *this + 183 * BYTE1(v4) + 54 * BYTE2(v4);
  unsigned int v6 = (255 - (v5 >> 8)) * (256 - (v5 >> 8));
  unint64_t v7 = ((((a2 | ((unint64_t)a2 << 24)) & 0xFF00FF00FF00FFLL)
       * ((((v6 >> 8) * (v6 >> 8) + (v6 >> 8)) >> 8) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
  unint64_t v8 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)((~(v7 >> 24) >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
  *this = ((v8 >> 24) | v8) + ((v7 >> 24) | v7);
  return this;
}

unsigned int *CA::OGL::SW::tex_mix(unsigned int *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4, const unsigned int *a5)
{
  for (; a5; a5 = (const unsigned int *)((char *)a5 - 1))
  {
    unsigned int v6 = *a2++;
    unsigned int v5 = v6;
    unsigned int v7 = *a3++;
    *this++ = ((v5 & 0xFF00FF) + (((*((unsigned __int8 *)a4 + 3) + 1) * ((v7 & 0xFF00FF) - (v5 & 0xFF00FF))) >> 8)) & 0xFF00FF | ((((v7 >> 8) & 0xFF00FF) - ((v5 >> 8) & 0xFF00FF)) * (*((unsigned __int8 *)a4 + 3) + 1) + (((v5 >> 8) & 0xFF00FF) << 8)) & 0xFF00FF00;
    ++a4;
  }
  return this;
}

uint64_t std::__function::__func<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED030E58;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1ED030E58;
  result[1] = v3;
  return result;
}

void std::__function::__func<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::~__func()
{
}

void *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Copy,false>::blend(void *a1, int a2, void *__src, uint64_t a4)
{
  return memcpy(a1, __src, 4 * a4);
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::SoverMulDMulSa,false>::blend(_DWORD *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    uint64_t v4 = v5;
    unsigned int v6 = *a2++;
    int v7 = BYTE3(v4);
    unint64_t v8 = (unint64_t)v6 >> 24;
    unint64_t v9 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) + ((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * v8) >> 8) & 0xFF00FF00FF00FFLL;
    unint64_t v10 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * (256 - ((v8 + v8 * v7) >> 8))) >> 8) & 0xFF00FF00FF00FFLL;
    LODWORD(v9) = (v9 >> 24) | v9;
    LODWORD(v10) = (v10 >> 24) | v10;
    unsigned int v11 = (v10 & 0xFF00FF) + (v9 & 0xFF00FF);
    LODWORD(v9) = ((v10 >> 8) & 0xFF00FF) + ((v9 >> 8) & 0xFF00FF);
    *result++ = v11 & 0xFF00FF | (v9 << 8) | (15 * (v9 & 0x1000100 | (v11 >> 8) & 0x10001)) | (240 * (v9 & 0x1000100 | (v11 >> 8) & 0x10001)) | 0xFF000000;
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Luminosity,false>::blend(_DWORD *result, unsigned int *a2, int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    int v5 = *a3++;
    int v4 = v5;
    unsigned int v6 = *a2++;
    unint64_t v7 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * ((~v4 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = v4 + ((v7 >> 24) | v7);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Color,false>::blend(_DWORD *result, unsigned int *a2, int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    int v5 = *a3++;
    int v4 = v5;
    unsigned int v6 = *a2++;
    unint64_t v7 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * ((~v4 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = v4 + ((v7 >> 24) | v7);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Saturation,false>::blend(_DWORD *result, unsigned int *a2, int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    int v5 = *a3++;
    int v4 = v5;
    unsigned int v6 = *a2++;
    unint64_t v7 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * ((~v4 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = v4 + ((v7 >> 24) | v7);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Hue,false>::blend(_DWORD *result, unsigned int *a2, int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    int v5 = *a3++;
    int v4 = v5;
    unsigned int v6 = *a2++;
    unint64_t v7 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * ((~v4 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = v4 + ((v7 >> 24) | v7);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::LightenSover,false>::blend(_DWORD *result, int *a2, unsigned int *a3, const unsigned int *a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    int v4 = a4;
    int v5 = a3;
    unint64_t v7 = result;
    do
    {
      unsigned int v9 = *v5++;
      unint64_t v8 = (unsigned int *)v9;
      int v10 = *a2++;
      int v11 = v10;
      uint64_t result = CA::OGL::SW::Blend::LightenSover::f(&v11, v8, a3, a4);
      *v7++ = v11;
      int v4 = (const unsigned int *)((char *)v4 - 1);
    }
    while (v4);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::DarkenSover,false>::blend(_DWORD *result, int *a2, unsigned int *a3, const unsigned int *a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    int v4 = a4;
    int v5 = a3;
    unint64_t v7 = result;
    do
    {
      unsigned int v9 = *v5++;
      unint64_t v8 = (unsigned int *)v9;
      int v10 = *a2++;
      int v11 = v10;
      uint64_t result = CA::OGL::SW::Blend::DarkenSover::f(&v11, v8, a3, a4);
      *v7++ = v11;
      int v4 = (const unsigned int *)((char *)v4 - 1);
    }
    while (v4);
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::VibrantLightSoverRev,false>::blend(int *result, int *a2, unsigned int *a3, const unsigned int *a4, _DWORD *a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    unsigned int v6 = a4;
    unint64_t v7 = a3;
    unsigned int v9 = result;
    do
    {
      unsigned int v11 = *v7++;
      unsigned int v10 = v11;
      int v12 = *a2++;
      unsigned int v13 = a5[1];
      int v16 = v12;
      int v14 = (v10 >> 8) & 0xFF0000;
      int v15 = (v10 >> 8) & 0xFF00;
      CA::OGL::SW::Blend::DarkenSover::f(&v16, (unsigned int *)((v14 + v14 * HIBYTE(v13)) & 0xFF000000 | ((v10 * v13+ v10) >> 8) | (v15 + v15 * BYTE2(v13)) & 0x1FF0000 | (BYTE1(v10) * BYTE1(v13) + BYTE1(v10)) & 0x1FF00), a3, a4);
      uint64_t result = CA::OGL::SW::Blend::SeparableMode<CA::OGL::SW::Blend::ColorBurn>::f(&v16, (v14 + v14 * HIBYTE(*a5)) & 0xFF000000 | ((v10 * *a5+ v10) >> 8) | (v15 + v15 * BYTE2(*a5)) & 0x1FF0000 | (BYTE1(v10) * BYTE1(*a5) + BYTE1(v10)) & 0x1FF00);
      *v9++ = v16;
      unsigned int v6 = (const unsigned int *)((char *)v6 - 1);
    }
    while (v6);
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::VibrantDarkSoverRev,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, const unsigned int *a4, _DWORD *a5)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    int v5 = a3;
    unint64_t v7 = result;
    do
    {
      signed int v35 = a4;
      unsigned int v8 = *v5;
      unsigned int v36 = *a2;
      int v9 = (v8 >> 8) & 0xFF0000;
      int v10 = (v8 >> 8) & 0xFF00;
      uint64_t result = CA::OGL::SW::Blend::LightenSover::f(&v36, (unsigned int *)((v9 + v9 * HIBYTE(a5[1])) & 0xFF000000 | ((v8* a5[1]+ v8) >> 8) | (v10 + v10 * BYTE2(a5[1])) & 0x1FF0000 | (BYTE1(v8) * BYTE1(a5[1]) + BYTE1(v8)) & 0x1FF00), a3, a4);
      unsigned int v11 = v8 * *a5 + v8;
      unsigned int v12 = (v9 + v9 * HIBYTE(*a5)) & 0xFF000000 | (v10 + v10 * BYTE2(*a5)) & 0x1FF0000;
      unsigned int v13 = (BYTE1(v8) * BYTE1(*a5) + BYTE1(v8)) & 0x1FF00 | (v11 >> 8) | v12;
      unsigned int v14 = HIBYTE(v12);
      int32x2_t v15 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v13), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
      unsigned int v16 = BYTE1(v11);
      unsigned int v17 = HIBYTE(v36);
      unsigned int v18 = v14 + 1;
      signed int v19 = (HIBYTE(v36) * (v14 + 1)) >> 8;
      if (HIBYTE(v36) == 255)
      {
        unsigned int v20 = 0;
        double v21 = 0.0;
      }
      else
      {
        v19 += ((v17 ^ 0xFF) * v18) >> 8;
        double v21 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v17 ^ 0xFF), vadd_s32(v15, (int32x2_t)0x100000001)), 8uLL));
        unsigned int v20 = ((v17 ^ 0xFF) + (v17 ^ 0xFF) * BYTE1(v11)) >> 8;
      }
      int32x2_t v22 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v36), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
      int v23 = v14 ^ 0xFF;
      signed int v24 = v19 + ((v23 + v23 * v17) >> 8);
      double v25 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v21, (uint32x2_t)vmul_s32(vadd_s32(v22, (int32x2_t)0x100000001), vdup_n_s32(v14 ^ 0xFF)), 8uLL));
      unsigned int v26 = v20 + ((v23 + v23 * v36) >> 8);
      if (v14 == 255)
      {
        unsigned int v26 = v20;
      }
      else
      {
        signed int v19 = v24;
        double v21 = v25;
      }
      unsigned int v27 = v18 * v14;
      int v28 = v14;
      if (v14 > v15.i32[0])
      {
        int v28 = (int)(255 * ((v22.i32[0] + v22.i32[0] * (v27 >> 8)) >> 8)) / (int)(v14 - v15.i32[0]);
        if (v28 >= (int)v14) {
          int v28 = v14;
        }
      }
      int v29 = v14;
      if (v14 > v15.i32[1])
      {
        int v29 = (int)(255 * ((v22.i32[1] + v22.i32[1] * (v27 >> 8)) >> 8)) / (int)(v14 - v15.i32[1]);
        if (v29 >= (int)v14) {
          int v29 = v14;
        }
      }
      int v30 = (int)(255 * ((v36 + v36 * (v27 >> 8)) >> 8)) / (int)(v14 - BYTE1(v11));
      if (v30 >= (int)v14) {
        int v30 = v14;
      }
      if (v14 > v16) {
        unsigned int v14 = v30;
      }
      int32x2_t v31 = vadd_s32((int32x2_t)__PAIR64__(v29, v28), *(int32x2_t *)&v21);
      int v32 = v14 + v26;
      if (v32 >= v19) {
        int v32 = v19;
      }
      uint32x2_t v33 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v31, vdup_n_s32(v19)), 0), (uint32x2_t)0x800000010);
      *v7++ = v33.i32[0] | (v19 << 24) | v32 & ~(v32 >> 31) | v33.i32[1];
      ++a2;
      ++v5;
      a4 = (const unsigned int *)((char *)v35 - 1);
    }
    while (v35 != (const unsigned int *)1);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::VibrantLightSover,false>::blend(_DWORD *result, int *a2, unsigned int *a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    uint64_t v6 = a4;
    int v9 = result;
    do
    {
      unsigned int v11 = *a3++;
      unsigned int v10 = v11;
      int v12 = *a2++;
      unsigned int v13 = *a5;
      int v18 = v12;
      int v14 = (v10 >> 8) & 0xFF0000;
      int v15 = (v10 >> 8) & 0xFF00;
      CA::OGL::SW::Blend::SeparableMode<CA::OGL::SW::Blend::ColorBurn>::f(&v18, (v14 + v14 * HIBYTE(v13)) & 0xFF000000 | ((v10 * v13+ v10) >> 8) | (v15 + v15 * BYTE2(v13)) & 0x1FF0000 | (BYTE1(v10) * BYTE1(v13) + BYTE1(v10)) & 0x1FF00);
      uint64_t result = CA::OGL::SW::Blend::DarkenSover::f(&v18, (unsigned int *)((v14 + v14 * HIBYTE(a5[1])) & 0xFF000000 | ((v10* a5[1]+ v10) >> 8) | (v15 + v15 * BYTE2(a5[1])) & 0x1FF0000 | (BYTE1(v10) * BYTE1(a5[1]) + BYTE1(v10)) & 0x1FF00), v16, v17);
      *v9++ = v18;
      --v6;
    }
    while (v6);
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::VibrantDarkSover,false>::blend(__int32 *result, unsigned int *a2, _DWORD *a3, const unsigned int *a4, _DWORD *a5)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    uint64_t v6 = a4;
    int v9 = result;
    do
    {
      int v10 = *a3 >> 8;
      int v11 = BYTE1(*a3);
      int v12 = *a3;
      int v13 = (v11 * BYTE1(*a5) + v10) & 0x1FF00;
      unsigned int v14 = v12 * *a5 + v12;
      int v15 = v10 & 0xFF0000;
      int v16 = v10 & 0xFF00;
      unsigned int v17 = (v15 + v15 * HIBYTE(*a5)) & 0xFF000000 | (v16 + v16 * BYTE2(*a5)) & 0x1FF0000;
      unsigned int v18 = v13 | (v14 >> 8) | v17;
      unsigned int v19 = HIBYTE(v17);
      int32x2_t v20 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v18), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
      unsigned int v21 = BYTE1(v14);
      unsigned int v22 = HIBYTE(*a2);
      unsigned int v23 = v19 + 1;
      unsigned int v24 = (v22 * (v19 + 1)) >> 8;
      if (v22 == 255)
      {
        unsigned int v25 = 0;
        double v26 = 0.0;
      }
      else
      {
        v24 += ((v22 ^ 0xFF) * v23) >> 8;
        double v26 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v22 ^ 0xFF), vadd_s32(v20, (int32x2_t)0x100000001)), 8uLL));
        unsigned int v25 = ((v22 ^ 0xFF) + (v22 ^ 0xFF) * v21) >> 8;
      }
      int32x2_t v27 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*a2), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
      int v28 = *a2;
      int v29 = v19 ^ 0xFF;
      signed int v30 = v24 + ((v29 + v29 * v22) >> 8);
      double v31 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v26, (uint32x2_t)vmul_s32(vadd_s32(v27, (int32x2_t)0x100000001), vdup_n_s32(v19 ^ 0xFF)), 8uLL));
      unsigned int v32 = v25 + ((v29 + v29 * v28) >> 8);
      if (v19 == 255) {
        unsigned int v33 = v25;
      }
      else {
        unsigned int v33 = v32;
      }
      if (v19 == 255) {
        signed int v34 = v24;
      }
      else {
        signed int v34 = v30;
      }
      if (v19 != 255) {
        double v26 = v31;
      }
      unsigned int v35 = v23 * v19;
      int v36 = v19;
      if (v19 > v20.i32[0])
      {
        int v36 = (int)(255 * ((v27.i32[0] + v27.i32[0] * (v35 >> 8)) >> 8)) / (int)(v19 - v20.i32[0]);
        if (v36 >= (int)v19) {
          int v36 = v19;
        }
      }
      int v37 = v19;
      signed int v38 = v19 - v20.i32[1];
      if (v19 > v20.i32[1])
      {
        unsigned int v39 = v27.i32[1] + v27.i32[1] * (v35 >> 8);
        a4 = (const unsigned int *)(v39 >> 8 << 8);
        int v37 = (int)(255 * (v39 >> 8)) / v38;
        if (v37 >= (int)v19) {
          int v37 = v19;
        }
      }
      int v40 = (int)(255 * ((v28 + v28 * (v35 >> 8)) >> 8)) / (int)(v19 - v21);
      if (v40 >= (int)v19) {
        int v40 = v19;
      }
      if (v19 > v21) {
        unsigned int v19 = v40;
      }
      int32x2_t v41 = vadd_s32((int32x2_t)__PAIR64__(v37, v36), *(int32x2_t *)&v26);
      int v42 = v19 + v33;
      if (v42 >= v34) {
        int v42 = v34;
      }
      uint32x2_t v43 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v41, vdup_n_s32(v34)), 0), (uint32x2_t)0x800000010);
      __int32 v44 = v43.i32[0] | (v34 << 24) | v42 & ~(v42 >> 31) | v43.i32[1];
      uint64_t result = CA::OGL::SW::Blend::LightenSover::f(&v44, (unsigned int *)((v15 + v15 * HIBYTE(a5[1])) & 0xFF000000 | ((v12+ v12* a5[1]) >> 8) | (v16 + v16 * BYTE2(a5[1])) & 0x1FF0000 | (v11 + v11 * BYTE1(a5[1])) & 0x1FF00), v38, a4);
      *v9++ = v44;
      ++a2;
      ++a3;
      uint64_t v6 = (const unsigned int *)((char *)v6 - 1);
    }
    while (v6);
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::PinLight,false>::blend(int *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = HIBYTE(v4);
    unsigned int v8 = BYTE2(v4);
    unsigned int v9 = BYTE1(v4);
    unsigned int v10 = v4;
    unsigned int v11 = HIBYTE(v6);
    int v12 = BYTE2(v6);
    int v13 = BYTE1(v6);
    int v14 = v6;
    int v15 = HIBYTE(v4) + 1;
    unsigned int v16 = (HIBYTE(v6) * v15) >> 8;
    int v17 = HIBYTE(v6) ^ 0xFF;
    unsigned int v18 = (v17 + v17 * BYTE2(v4)) >> 8;
    unsigned int v19 = v16 + ((v17 * v15) >> 8);
    unsigned int v20 = (v17 + v17 * BYTE1(v4)) >> 8;
    unsigned int v21 = (v17 + v17 * v4) >> 8;
    if (HIBYTE(v6) == 255) {
      unsigned int v18 = 0;
    }
    if (v11 == 255)
    {
      unsigned int v20 = 0;
      unsigned int v21 = 0;
      unsigned int v19 = v16;
    }
    BOOL v22 = v7 == 255;
    int v23 = v7 ^ 0xFF;
    unsigned int v24 = (v11 + 1) * v23;
    unsigned int v25 = v18 + ((v23 + v23 * v12) >> 8);
    unsigned int v26 = v20 + ((v23 + v23 * v13) >> 8);
    unsigned int v27 = v21 + ((v23 + v23 * v14) >> 8);
    signed int v28 = v19 + (v24 >> 8);
    unsigned int v29 = v11 + 1;
    if (v22)
    {
      unsigned int v27 = v21;
    }
    else
    {
      unsigned int v18 = v25;
      unsigned int v20 = v26;
    }
    unsigned int v30 = v12 * v15;
    if (v22) {
      signed int v31 = v19;
    }
    else {
      signed int v31 = v28;
    }
    signed int v32 = v30 >> 8;
    signed int v33 = ((v29 * BYTE2(v4)) >> 7) & 0x3FE;
    unsigned int v34 = v4 >> 25;
    unsigned int v35 = v33 - v16;
    if (v32 > (int)(v33 - v16)) {
      unsigned int v35 = v32;
    }
    if (v32 >= v33) {
      signed int v32 = v33;
    }
    BOOL v36 = v34 > v8;
    signed int v37 = (v13 * v15) >> 8;
    signed int v38 = ((v29 * v9) >> 7) & 0x3FE;
    signed int v39 = v38 - v16;
    if (!v36) {
      signed int v32 = v35;
    }
    if (v37 > v39) {
      signed int v39 = v37;
    }
    if (v37 >= v38) {
      signed int v37 = ((v29 * v9) >> 7) & 0x3FE;
    }
    BOOL v36 = v34 > v9;
    signed int v40 = (v14 * v15) >> 8;
    signed int v41 = ((v29 * v10) >> 7) & 0x3FE;
    signed int v42 = v41 - v16;
    if (v36) {
      signed int v43 = v37;
    }
    else {
      signed int v43 = v39;
    }
    if (v40 > v42) {
      signed int v42 = v40;
    }
    if (v40 >= v41) {
      signed int v40 = ((v29 * v10) >> 7) & 0x3FE;
    }
    if (v34 > v10) {
      signed int v44 = v40;
    }
    else {
      signed int v44 = v42;
    }
    signed int v45 = v43 + v20;
    if ((int)(v43 + v20) >= v31) {
      signed int v45 = v31;
    }
    signed int v46 = v32 + v18;
    if ((int)(v32 + v18) >= v31) {
      signed int v46 = v31;
    }
    signed int v47 = v44 + v27;
    int v48 = (v46 << 16) | (v31 << 24) | (v45 << 8);
    if (v47 >= v31) {
      signed int v47 = v31;
    }
    *result++ = v48 | v47;
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::LinearLight,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = HIBYTE(v4);
    int32x2_t v8 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    unsigned int v9 = HIBYTE(v6);
    int v10 = v6;
    unsigned int v11 = HIBYTE(v4) + 1;
    int32x2_t v12 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    unsigned int v13 = (HIBYTE(v6) * v11) >> 8;
    unsigned int v14 = v13 + (((HIBYTE(v6) ^ 0xFF) * v11) >> 8);
    unsigned int v15 = ((v9 ^ 0xFF) + (v9 ^ 0xFF) * v4) >> 8;
    double v16 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v8, (int32x2_t)0x100000001)), 8uLL));
    if (HIBYTE(v6) == 255) {
      unsigned int v15 = 0;
    }
    if (v9 == 255) {
      double v16 = 0.0;
    }
    else {
      unsigned int v13 = v14;
    }
    unsigned int v17 = v7 ^ 0xFF;
    BOOL v18 = v7 == 255;
    signed int v19 = v13 + ((v17 + v17 * v9) >> 8);
    uint32x2_t v20 = (uint32x2_t)vmul_s32(vadd_s32(v12, (int32x2_t)0x100000001), vdup_n_s32(v17));
    unsigned int v21 = v15 + ((v17 + v17 * v10) >> 8);
    if (!v18) {
      unsigned int v15 = v21;
    }
    int32x2_t v22 = vdup_n_s32(v11);
    double v23 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v16, v20, 8uLL));
    if (v18) {
      signed int v19 = v13;
    }
    uint32x2_t v24 = (uint32x2_t)vmul_s32(v12, v22);
    int32x2_t v25 = vadd_s32(v8, v8);
    unsigned int v26 = v10 * v11;
    unsigned int v27 = v11 - 2 * v4;
    if (!v18) {
      double v16 = v23;
    }
    int v28 = v15 - ((int)(v9 * v27) >> 8) + (v26 >> 8);
    int32x2_t v29 = vsub_s32((int32x2_t)vshr_n_u32(v24, 8uLL), vshr_n_s32(vmul_s32(vdup_n_s32(v9), vsub_s32(v22, v25)), 8uLL));
    if (v28 >= v19) {
      int v28 = v19;
    }
    uint32x2_t v30 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(vadd_s32(v29, *(int32x2_t *)&v16), vdup_n_s32(v19)), 0), (uint32x2_t)0x800000010);
    *result++ = v28 & ~(v28 >> 31) | (v19 << 24) | v30.i32[0] | v30.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::LinearBurn,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = HIBYTE(v4);
    unsigned int v8 = HIBYTE(v6);
    int v9 = v6;
    unsigned int v10 = HIBYTE(v4) + 1;
    int32x2_t v11 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    signed int v12 = (HIBYTE(v6) * v10) >> 8;
    signed int v13 = v12 + (((HIBYTE(v6) ^ 0xFF) * v10) >> 8);
    int32x2_t v14 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    double v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v11, (int32x2_t)0x100000001)), 8uLL));
    unsigned int v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255) {
      unsigned int v16 = 0;
    }
    if (v8 != 255) {
      signed int v12 = v13;
    }
    unsigned int v17 = v7 ^ 0xFF;
    if (v8 == 255) {
      double v15 = 0.0;
    }
    uint32x2_t v18 = (uint32x2_t)vmul_s32(vadd_s32(v14, (int32x2_t)0x100000001), vdup_n_s32(v17));
    BOOL v19 = v7 == 255;
    unsigned int v20 = v16 + ((v17 + v17 * v9) >> 8);
    if (v19) {
      unsigned int v20 = v16;
    }
    else {
      v12 += (v17 + v17 * v8) >> 8;
    }
    double v21 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v18, 8uLL));
    int32x2_t v22 = vdup_n_s32(v10);
    uint32x2_t v23 = (uint32x2_t)vmul_s32(v14, v22);
    int32x2_t v24 = vsub_s32(v22, v11);
    unsigned int v25 = v9 * v10;
    if (!v19) {
      double v15 = v21;
    }
    int v26 = v20 - ((int)(v8 * (v10 - v4)) >> 8) + (v25 >> 8);
    int32x2_t v27 = vsub_s32((int32x2_t)vshr_n_u32(v23, 8uLL), vshr_n_s32(vmul_s32(vdup_n_s32(v8), v24), 8uLL));
    if (v26 >= v12) {
      int v26 = v12;
    }
    uint32x2_t v28 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(vadd_s32(v27, *(int32x2_t *)&v15), vdup_n_s32(v12)), 0), (uint32x2_t)0x800000010);
    *result++ = v26 & ~(v26 >> 31) | (v12 << 24) | v28.i32[0] | v28.i32[1];
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Divide,false>::blend(int *result, int *a2, _DWORD *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    int v4 = *a2;
    int v5 = HIBYTE(*a3);
    int v6 = BYTE2(*a3);
    int v7 = BYTE1(*a3);
    int v8 = *a3;
    unsigned int v9 = HIBYTE(*a2);
    int v10 = v5 + 1;
    signed int v11 = (v9 * (v5 + 1)) >> 8;
    if (v9 == 255)
    {
      unsigned int v12 = 0;
      unsigned int v13 = 0;
      unsigned int v14 = 0;
    }
    else
    {
      int v15 = v9 ^ 0xFF;
      v11 += ((v9 ^ 0xFF) * v10) >> 8;
      unsigned int v12 = (v15 + v15 * v6) >> 8;
      unsigned int v13 = (v15 + v15 * v7) >> 8;
      unsigned int v14 = (v15 + v15 * v8) >> 8;
    }
    int v16 = BYTE2(v4);
    int v17 = BYTE1(v4);
    BOOL v18 = v5 == 255;
    int v19 = v5 ^ 0xFF;
    signed int v20 = v11 + (((v9 + 1) * v19) >> 8);
    unsigned int v21 = v13 + ((v19 + v19 * BYTE1(v4)) >> 8);
    unsigned int v22 = v14 + ((v19 + v19 * *a2) >> 8);
    unsigned int v23 = v9 + 1;
    if (v18) {
      unsigned int v24 = v12;
    }
    else {
      unsigned int v24 = v12 + ((v19 + v19 * BYTE2(v4)) >> 8);
    }
    if (v18) {
      unsigned int v25 = v13;
    }
    else {
      unsigned int v25 = v21;
    }
    if (v18) {
      unsigned int v26 = v14;
    }
    else {
      unsigned int v26 = v22;
    }
    if (!v18) {
      signed int v11 = v20;
    }
    unsigned int v27 = v23 * v6;
    if ((v16 * v10) < 0x100)
    {
      if (v27 <= 0xFF) {
        unsigned int v28 = 0;
      }
      else {
        unsigned int v28 = 255;
      }
    }
    else
    {
      unsigned int v28 = (unsigned __int16)(255 * (v27 >> 8)) / ((v16 * v10) >> 8);
    }
    unsigned int v29 = v23 * v7;
    unsigned int v30 = v17 * v10;
    if (v30 < 0x100)
    {
      if (v29 <= 0xFF) {
        unsigned int v31 = 0;
      }
      else {
        unsigned int v31 = 255;
      }
    }
    else
    {
      unsigned int v31 = (unsigned __int16)(255 * (v29 >> 8)) / (v30 >> 8);
    }
    unsigned int v32 = v23 * v8;
    unsigned int v33 = *a2 * v10;
    if (v33 < 0x100)
    {
      if (v32 <= 0xFF) {
        unsigned int v34 = 0;
      }
      else {
        unsigned int v34 = 255;
      }
    }
    else
    {
      unsigned int v34 = (unsigned __int16)(255 * (v32 >> 8)) / (v33 >> 8);
    }
    signed int v35 = v31 + v25;
    if ((int)(v31 + v25) >= v11) {
      signed int v35 = v11;
    }
    signed int v36 = v28 + v24;
    if ((int)(v28 + v24) >= v11) {
      signed int v36 = v11;
    }
    signed int v37 = v34 + v26;
    if (v37 >= v11) {
      signed int v37 = v11;
    }
    *result++ = (v36 << 16) | (v11 << 24) | (v35 << 8) | v37;
    ++a2;
    ++a3;
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Subtract,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = HIBYTE(v4);
    unsigned int v8 = HIBYTE(v6);
    int v9 = v6;
    unsigned int v10 = HIBYTE(v4) + 1;
    int32x2_t v11 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    signed int v12 = (HIBYTE(v6) * v10) >> 8;
    signed int v13 = v12 + (((HIBYTE(v6) ^ 0xFF) * v10) >> 8);
    double v14 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v11, (int32x2_t)0x100000001)), 8uLL));
    int32x2_t v15 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    unsigned int v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255) {
      unsigned int v16 = 0;
    }
    if (v8 == 255) {
      double v14 = 0.0;
    }
    else {
      signed int v12 = v13;
    }
    unsigned int v17 = v7 ^ 0xFF;
    BOOL v18 = v7 == 255;
    unsigned int v19 = v8 + 1;
    signed int v20 = v12 + (((v8 + 1) * v17) >> 8);
    uint32x2_t v21 = (uint32x2_t)vmul_s32(vadd_s32(v15, (int32x2_t)0x100000001), vdup_n_s32(v17));
    unsigned int v22 = v16 + ((v17 + v17 * v9) >> 8);
    if (!v18) {
      unsigned int v19 = v8 + 1;
    }
    double v23 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v14, v21, 8uLL));
    if (v18) {
      unsigned int v24 = v16;
    }
    else {
      unsigned int v24 = v22;
    }
    int32x2_t v25 = vdup_n_s32(v10);
    uint32x2_t v26 = (uint32x2_t)vmul_s32(vdup_n_s32(v19), v11);
    if (!v18) {
      signed int v12 = v20;
    }
    uint32x2_t v27 = (uint32x2_t)vmul_s32(v15, v25);
    unsigned int v28 = v19 * v4;
    unsigned int v29 = v24 - ((v9 * v10) >> 8);
    if (!v18) {
      double v14 = v23;
    }
    int v30 = v29 + (v28 >> 8);
    if (v30 >= v12) {
      int v30 = v12;
    }
    uint32x2_t v31 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(vadd_s32(vsub_s32((int32x2_t)vshr_n_u32(v26, 8uLL), (int32x2_t)vshr_n_u32(v27, 8uLL)), *(int32x2_t *)&v14), vdup_n_s32(v12)), 0), (uint32x2_t)0x800000010);
    *result++ = v30 & ~(v30 >> 31) | (v12 << 24) | v31.i32[0] | v31.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Difference,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = HIBYTE(v4);
    unsigned int v8 = HIBYTE(v6);
    int v9 = v6;
    unsigned int v10 = HIBYTE(v4) + 1;
    int32x2_t v11 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    signed int v12 = (HIBYTE(v6) * v10) >> 8;
    signed int v13 = v12 + (((HIBYTE(v6) ^ 0xFF) * v10) >> 8);
    int32x2_t v14 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    double v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v11, (int32x2_t)0x100000001)), 8uLL));
    unsigned int v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255) {
      unsigned int v16 = 0;
    }
    if (v8 == 255) {
      double v15 = 0.0;
    }
    else {
      signed int v12 = v13;
    }
    unsigned int v17 = v7 ^ 0xFF;
    BOOL v18 = v7 == 255;
    unsigned int v19 = v8 + 1;
    signed int v20 = v12 + (((v8 + 1) * v17) >> 8);
    uint32x2_t v21 = (uint32x2_t)vmul_s32(vadd_s32(v14, (int32x2_t)0x100000001), vdup_n_s32(v17));
    unsigned int v22 = v16 + ((v17 + v17 * v9) >> 8);
    if (v18)
    {
      unsigned int v23 = v16;
    }
    else
    {
      unsigned int v19 = v8 + 1;
      unsigned int v23 = v22;
    }
    uint32x2_t v24 = (uint32x2_t)vmul_s32(v14, vdup_n_s32(v10));
    int32x2_t v25 = vdup_n_s32(v19);
    double v26 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v21, 8uLL));
    if (!v18) {
      signed int v12 = v20;
    }
    uint32x2_t v27 = (uint32x2_t)vmul_s32(v25, v11);
    unsigned int v28 = (v9 * v10) >> 8;
    unsigned int v29 = v19 * v4;
    if (!v18) {
      double v15 = v26;
    }
    int v30 = v28 - (v29 >> 8);
    if (v30 < 0) {
      int v30 = -v30;
    }
    signed int v31 = v23 + v30;
    uint32x2_t v32 = (uint32x2_t)vmin_s32((int32x2_t)vaba_u32(*(uint32x2_t *)&v15, vshr_n_u32(v27, 8uLL), vshr_n_u32(v24, 8uLL)), vdup_n_s32(v12));
    if (v31 >= v12) {
      signed int v31 = v12;
    }
    uint32x2_t v33 = vshl_u32(v32, (uint32x2_t)0x800000010);
    *result++ = v31 | (v12 << 24) | v33.i32[0] | v33.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::HardLight,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = HIBYTE(v4);
    unsigned int v8 = v4;
    int32x2_t v9 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    unsigned int v10 = HIBYTE(v6);
    int v11 = v6;
    int v12 = HIBYTE(v4) + 1;
    int32x2_t v13 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    signed int v14 = (HIBYTE(v6) * v12) >> 8;
    signed int v15 = v14 + (((HIBYTE(v6) ^ 0xFF) * v12) >> 8);
    int32x2_t v16 = vadd_s32(v9, (int32x2_t)0x100000001);
    int32x2_t v17 = vdup_n_s32(HIBYTE(v6) ^ 0xFF);
    unsigned int v18 = ((v10 ^ 0xFF) + (v10 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255) {
      unsigned int v18 = 0;
    }
    uint32x2_t v19 = (uint32x2_t)vmul_s32(v17, v16);
    if (v10 != 255) {
      signed int v14 = v15;
    }
    unsigned int v20 = v7 ^ 0xFF;
    int32x2_t v21 = vadd_s32(v13, (int32x2_t)0x100000001);
    unsigned __int32 v22 = v9.u32[1];
    double v23 = COERCE_DOUBLE(vshr_n_u32(v19, 8uLL));
    unsigned __int32 v24 = v9.i32[0];
    __int32 v25 = v13.i32[1];
    if (v10 == 255) {
      double v26 = 0.0;
    }
    else {
      double v26 = v23;
    }
    __int32 v27 = v13.i32[0];
    int v28 = (v12 - v24) * (v10 - v13.i32[0]);
    BOOL v29 = v7 == 255;
    int v30 = (v12 - v22) * (v10 - v13.i32[1]);
    if (v7 != 255) {
      v18 += (v20 + v20 * v11) >> 8;
    }
    int32x2_t v31 = vdup_n_s32(v20);
    signed int v32 = v14 + ((v20 + v20 * v10) >> 8);
    uint32x2_t v33 = (uint32x2_t)vmul_s32(v21, v31);
    if (v7 != 255) {
      signed int v14 = v32;
    }
    double v34 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v26, v33, 8uLL));
    unsigned int v35 = v4 >> 25;
    unsigned int v36 = (v7 + v7 * v10) >> 8;
    if (!v29) {
      double v26 = v34;
    }
    unsigned int v37 = v36 - (char)(v28 >> 7);
    unsigned int v38 = ((v27 + v27 * v24) >> 7) & 0x3FE;
    if (v35 >= v24) {
      unsigned int v37 = v38;
    }
    int v39 = 2 * (v12 - v8) * (v10 - v11);
    if (v35 >= v22) {
      unsigned int v40 = ((v25 + v25 * v22) >> 7) & 0x3FE;
    }
    else {
      unsigned int v40 = v36 - (char)(v30 >> 7);
    }
    unsigned int v41 = v36 - (v39 >> 8);
    unsigned int v42 = ((v11 + v11 * v8) >> 7) & 0x3FE;
    if (v35 >= v8) {
      unsigned int v43 = v42;
    }
    else {
      unsigned int v43 = v41;
    }
    int v44 = v43 + v18;
    int32x2_t v45 = vadd_s32((int32x2_t)__PAIR64__(v40, v37), *(int32x2_t *)&v26);
    if (v44 >= v14) {
      int v44 = v14;
    }
    uint32x2_t v46 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v45, vdup_n_s32(v14)), 0), (uint32x2_t)0x800000010);
    *result++ = v46.i32[0] | (v14 << 24) | v44 & ~(v44 >> 31) | v46.i32[1];
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::SoftLight,false>::blend(int *result, _DWORD *a2, _DWORD *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    int v4 = HIBYTE(*a3);
    int v5 = BYTE2(*a3);
    int v6 = BYTE1(*a3);
    int v7 = *a3;
    unsigned int v8 = HIBYTE(*a2);
    int v9 = BYTE2(*a2);
    int v10 = BYTE1(*a2);
    int v11 = *a2;
    int v12 = v8 ^ 0xFF;
    signed int v13 = ((v8 * (v4 + 1)) >> 8) + (((v8 ^ 0xFF) * (v4 + 1)) >> 8);
    unsigned int v14 = (v12 + v12 * v5) >> 8;
    unsigned int v15 = (v12 + v12 * v6) >> 8;
    unsigned int v16 = (v12 + v12 * v7) >> 8;
    if (v8 == 255)
    {
      unsigned int v14 = 0;
      unsigned int v15 = 0;
      unsigned int v16 = 0;
      signed int v13 = (255 * (v4 + 1)) >> 8;
    }
    int v17 = v4 ^ 0xFF;
    signed int v18 = v13 + ((v17 + v17 * v8) >> 8);
    unsigned int v19 = v14 + ((v17 + v17 * v9) >> 8);
    unsigned int v20 = v15 + ((v17 + v17 * v10) >> 8);
    unsigned int v21 = v16 + ((v17 + v17 * v11) >> 8);
    if (v4 == 255)
    {
      unsigned int v19 = v14;
      unsigned int v22 = v15;
    }
    else
    {
      unsigned int v22 = v20;
    }
    if (v4 != 255)
    {
      unsigned int v16 = v21;
      signed int v13 = v18;
    }
    signed int v23 = v19 + (((v9 + v9 * v5) >> 7) & 0x3FE);
    if (v8)
    {
      v23 -= (int)(255 * v9 / v8 + 255 * v9 / v8 * ((v9 + v9 * (2 * v5 - v4)) >> 8)) >> 8;
      signed int v24 = v22
          + (((v10 + v10 * v6) >> 7) & 0x3FE)
          - ((int)(255 * v10 / v8 + 255 * v10 / v8 * ((v10 + v10 * (2 * v6 - v4)) >> 8)) >> 8);
      signed int v25 = v16
          + (((v11 + v11 * v7) >> 7) & 0x3FE)
          - ((int)(255 * v11 / v8 + 255 * v11 / v8 * ((v11 + v11 * (2 * v7 - v4)) >> 8)) >> 8);
    }
    else
    {
      signed int v24 = v22 + (((v10 + v10 * v6) >> 7) & 0x3FE);
      signed int v25 = v16 + (((v11 + v11 * v7) >> 7) & 0x3FE);
    }
    if (v24 >= v13) {
      int v26 = v13;
    }
    else {
      int v26 = v24;
    }
    int v27 = v26 & ~(v26 >> 31);
    if (v23 >= v13) {
      int v28 = v13;
    }
    else {
      int v28 = v23;
    }
    int v29 = v28 & ~(v28 >> 31);
    if (v25 >= v13) {
      signed int v25 = v13;
    }
    *result++ = (v29 << 16) | (v13 << 24) | (v27 << 8) | v25 & ~(v25 >> 31);
    ++a2;
    ++a3;
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::ColorBurn,false>::blend(int *result, int *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    uint64_t v4 = a4;
    int v7 = result;
    do
    {
      unsigned int v9 = *a3++;
      unsigned int v8 = v9;
      int v10 = *a2++;
      int v11 = v10;
      uint64_t result = CA::OGL::SW::Blend::SeparableMode<CA::OGL::SW::Blend::ColorBurn>::f(&v11, v8);
      *v7++ = v11;
      --v4;
    }
    while (v4);
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::ColorDodge,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v4 = HIBYTE(*a3);
    int32x2_t v5 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    unsigned int v6 = *a3;
    unsigned int v7 = HIBYTE(*a2);
    unsigned int v8 = v4 + 1;
    signed int v9 = (v7 * (v4 + 1)) >> 8;
    if (v7 == 255)
    {
      unsigned int v10 = 0;
      int32x2_t v11 = 0;
    }
    else
    {
      v9 += ((v7 ^ 0xFF) * v8) >> 8;
      int32x2_t v11 = (int32x2_t)vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v7 ^ 0xFF), vadd_s32(v5, (int32x2_t)0x100000001)), 8uLL);
      unsigned int v10 = ((v7 ^ 0xFF) + (v7 ^ 0xFF) * v6) >> 8;
    }
    int32x2_t v12 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*a2), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    int v13 = *a2;
    if (v4 != 255)
    {
      int v14 = v4 ^ 0xFF;
      v9 += (v14 + v14 * v7) >> 8;
      int32x2_t v11 = (int32x2_t)vsra_n_u32((uint32x2_t)v11, (uint32x2_t)vmul_s32(vadd_s32(v12, (int32x2_t)0x100000001), vdup_n_s32(v4 ^ 0xFF)), 8uLL);
      v10 += (v14 + v14 * v13) >> 8;
    }
    unsigned int v15 = v8 * v4;
    signed int v16 = HIBYTE(*a3);
    if (v4 > v5.i32[0])
    {
      signed int v16 = (int)(255 * ((v12.i32[0] + v12.i32[0] * (v15 >> 8)) >> 8)) / (int)(v4 - v5.i32[0]);
      if (v16 >= (int)v4) {
        signed int v16 = HIBYTE(*a3);
      }
    }
    signed int v17 = HIBYTE(*a3);
    if (v4 > v5.i32[1])
    {
      signed int v17 = (int)(255 * ((v12.i32[1] + v12.i32[1] * (v15 >> 8)) >> 8)) / (int)(v4 - v5.i32[1]);
      if (v17 >= (int)v4) {
        signed int v17 = HIBYTE(*a3);
      }
    }
    int v18 = (int)(255 * ((v13 + v13 * (v15 >> 8)) >> 8)) / (int)(v4 - v6);
    if (v18 >= (int)v4) {
      int v18 = HIBYTE(*a3);
    }
    if (v4 > v6) {
      unsigned int v4 = v18;
    }
    int32x2_t v19 = vadd_s32((int32x2_t)__PAIR64__(v17, v16), v11);
    int v20 = v4 + v10;
    if (v20 >= v9) {
      int v20 = v9;
    }
    uint32x2_t v21 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v19, vdup_n_s32(v9)), 0), (uint32x2_t)0x800000010);
    *result++ = v21.i32[0] | (v9 << 24) | v20 & ~(v20 >> 31) | v21.i32[1];
    ++a2;
    ++a3;
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Lighten,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = HIBYTE(v4);
    unsigned int v8 = HIBYTE(v6);
    int8x8_t v9 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
    int v10 = v6;
    unsigned int v11 = HIBYTE(v4) + 1;
    signed int v12 = (HIBYTE(v6) * v11) >> 8;
    int32x2_t v13 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    signed int v14 = v12 + (((HIBYTE(v6) ^ 0xFF) * v11) >> 8);
    double v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v13, (int32x2_t)0x100000001)), 8uLL));
    unsigned int v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255) {
      unsigned int v16 = 0;
    }
    if (v8 == 255) {
      double v15 = 0.0;
    }
    else {
      signed int v12 = v14;
    }
    BOOL v17 = v7 == 255;
    unsigned int v18 = v7 ^ 0xFF;
    int32x2_t v19 = (int32x2_t)vand_s8(v9, (int8x8_t)0xFF000000FFLL);
    signed int v20 = v12 + (((v8 + 1) * v18) >> 8);
    uint32x2_t v21 = (uint32x2_t)vmul_s32(vadd_s32(v19, (int32x2_t)0x100000001), vdup_n_s32(v18));
    unsigned int v22 = v16 + ((v18 + v18 * v10) >> 8);
    unsigned int v23 = v8 + 1;
    if (v17) {
      unsigned int v22 = v16;
    }
    double v24 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v21, 8uLL));
    if (!v17) {
      signed int v12 = v20;
    }
    int32x2_t v25 = vdup_n_s32(v23);
    int32x2_t v26 = vdup_n_s32(v11);
    if (!v17) {
      double v15 = v24;
    }
    uint32x2_t v27 = (uint32x2_t)vmul_s32(v25, v13);
    uint32x2_t v28 = (uint32x2_t)vmul_s32(v19, v26);
    signed int v29 = (v23 * v4) >> 8;
    if (v29 <= (int)((v10 * v11) >> 8)) {
      signed int v29 = (v10 * v11) >> 8;
    }
    signed int v30 = v22 + v29;
    uint32x2_t v31 = (uint32x2_t)vmin_s32(vadd_s32(*(int32x2_t *)&v15, vmax_s32((int32x2_t)vshr_n_u32(v27, 8uLL), (int32x2_t)vshr_n_u32(v28, 8uLL))), vdup_n_s32(v12));
    if (v30 >= v12) {
      signed int v30 = v12;
    }
    uint32x2_t v32 = vshl_u32(v31, (uint32x2_t)0x800000010);
    *result++ = v30 | (v12 << 24) | v32.i32[0] | v32.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Darken,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = HIBYTE(v4);
    unsigned int v8 = HIBYTE(v6);
    int8x8_t v9 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
    int v10 = v6;
    unsigned int v11 = HIBYTE(v4) + 1;
    signed int v12 = (HIBYTE(v6) * v11) >> 8;
    int32x2_t v13 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    signed int v14 = v12 + (((HIBYTE(v6) ^ 0xFF) * v11) >> 8);
    double v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v13, (int32x2_t)0x100000001)), 8uLL));
    unsigned int v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255) {
      unsigned int v16 = 0;
    }
    if (v8 == 255) {
      double v15 = 0.0;
    }
    else {
      signed int v12 = v14;
    }
    BOOL v17 = v7 == 255;
    unsigned int v18 = v7 ^ 0xFF;
    int32x2_t v19 = (int32x2_t)vand_s8(v9, (int8x8_t)0xFF000000FFLL);
    signed int v20 = v12 + (((v8 + 1) * v18) >> 8);
    uint32x2_t v21 = (uint32x2_t)vmul_s32(vadd_s32(v19, (int32x2_t)0x100000001), vdup_n_s32(v18));
    unsigned int v22 = v16 + ((v18 + v18 * v10) >> 8);
    unsigned int v23 = v8 + 1;
    if (v17) {
      unsigned int v22 = v16;
    }
    double v24 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v21, 8uLL));
    if (!v17) {
      signed int v12 = v20;
    }
    int32x2_t v25 = vdup_n_s32(v23);
    int32x2_t v26 = vdup_n_s32(v11);
    if (!v17) {
      double v15 = v24;
    }
    uint32x2_t v27 = (uint32x2_t)vmul_s32(v25, v13);
    uint32x2_t v28 = (uint32x2_t)vmul_s32(v19, v26);
    signed int v29 = (v23 * v4) >> 8;
    if (v29 >= (int)((v10 * v11) >> 8)) {
      signed int v29 = (v10 * v11) >> 8;
    }
    signed int v30 = v22 + v29;
    uint32x2_t v31 = (uint32x2_t)vmin_s32(vadd_s32(*(int32x2_t *)&v15, vmin_s32((int32x2_t)vshr_n_u32(v27, 8uLL), (int32x2_t)vshr_n_u32(v28, 8uLL))), vdup_n_s32(v12));
    if (v30 >= v12) {
      signed int v30 = v12;
    }
    uint32x2_t v32 = vshl_u32(v31, (uint32x2_t)0x800000010);
    *result++ = v30 | (v12 << 24) | v32.i32[0] | v32.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Overlay,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v4 = HIBYTE(*a3);
    int v5 = *a3;
    int32x2_t v6 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    unsigned int v7 = HIBYTE(*a2);
    unsigned int v8 = *a2;
    unsigned int v9 = v4 + 1;
    int32x2_t v10 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*a2), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    signed int v11 = (v7 * (v4 + 1)) >> 8;
    int32x2_t v12 = vadd_s32(v6, (int32x2_t)0x100000001);
    int32x2_t v13 = vdup_n_s32(v7 ^ 0xFF);
    unsigned int v14 = ((v7 ^ 0xFF) + (v7 ^ 0xFF) * v5) >> 8;
    if (v7 == 255) {
      unsigned int v14 = 0;
    }
    uint32x2_t v15 = (uint32x2_t)vmul_s32(v13, v12);
    if (v7 != 255) {
      v11 += ((v7 ^ 0xFF) * (v4 + 1)) >> 8;
    }
    int v16 = v4 ^ 0xFF;
    signed int v17 = v11 + ((v16 + v16 * v7) >> 8);
    int32x2_t v18 = vadd_s32(v10, (int32x2_t)0x100000001);
    double v19 = COERCE_DOUBLE(vshr_n_u32(v15, 8uLL));
    int32x2_t v20 = vdup_n_s32(v4 ^ 0xFF);
    unsigned int v21 = v16 + v16 * v8;
    unsigned __int32 v22 = v10.u32[1];
    if (v7 == 255) {
      double v19 = 0.0;
    }
    unsigned int v23 = v14 + (v21 >> 8);
    unsigned __int32 v24 = v10.i32[0];
    unsigned int v25 = v7 + 1;
    __int32 v26 = v6.i32[0];
    __int32 v27 = v6.i32[1];
    if (v4 != 255) {
      unsigned int v14 = v23;
    }
    unsigned int v28 = ((v25 * v6.i32[0]) >> 8) + ((int)(v10.i32[0] * (v9 - v6.i32[0])) >> 8);
    if (v4 != 255) {
      signed int v11 = v17;
    }
    unsigned int v29 = ((v25 * v6.i32[1]) >> 8) + ((int)(v10.i32[1] * (v9 - v6.i32[1])) >> 8);
    double v30 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v19, (uint32x2_t)vmul_s32(v18, v20), 8uLL));
    if (v4 == 255) {
      *(double *)&int32x2_t v31 = v19;
    }
    else {
      *(double *)&int32x2_t v31 = v30;
    }
    unsigned int v32 = *a2 >> 25;
    BOOL v33 = v32 >= v24;
    unsigned int v34 = v25 * v4;
    int v35 = 2 * v28 - (v34 >> 8);
    unsigned int v36 = ((v24 + v24 * v26) >> 7) & 0x3FE;
    int v37 = 2 * v29;
    if (v33) {
      int v35 = v36;
    }
    unsigned int v38 = v37 - (v34 >> 8);
    unsigned int v39 = 2 * (((v25 * v5) >> 8) + ((int)(v8 * (v9 - v5)) >> 8));
    if (v32 >= v22) {
      unsigned int v40 = ((v22 + v22 * v27) >> 7) & 0x3FE;
    }
    else {
      unsigned int v40 = v38;
    }
    unsigned int v41 = v39 - (v34 >> 8);
    unsigned int v42 = ((v8 + v8 * v5) >> 7) & 0x3FE;
    if (v32 < v8) {
      unsigned int v42 = v41;
    }
    int v43 = v42 + v14;
    int32x2_t v44 = vadd_s32((int32x2_t)__PAIR64__(v40, v35), v31);
    if (v43 >= v11) {
      int v43 = v11;
    }
    uint32x2_t v45 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v44, vdup_n_s32(v11)), 0), (uint32x2_t)0x800000010);
    *result++ = v45.i32[0] | (v11 << 24) | v43 & ~(v43 >> 31) | v45.i32[1];
    ++a2;
    ++a3;
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Multiply,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = HIBYTE(v4);
    int v8 = v4;
    unsigned int v9 = HIBYTE(v6);
    int32x2_t v10 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    int v11 = v6;
    int32x2_t v12 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    unsigned int v13 = (HIBYTE(v6) * (v7 + 1)) >> 8;
    signed int v14 = v13 + (((HIBYTE(v6) ^ 0xFF) * (v7 + 1)) >> 8);
    unsigned int v15 = ((v9 ^ 0xFF) + (v9 ^ 0xFF) * v8) >> 8;
    double v16 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v10, (int32x2_t)0x100000001)), 8uLL));
    if (HIBYTE(v6) == 255) {
      unsigned int v15 = 0;
    }
    if (v9 == 255)
    {
      signed int v14 = v13;
      double v16 = 0.0;
    }
    unsigned int v17 = v7 ^ 0xFF;
    BOOL v18 = v7 == 255;
    signed int v19 = v14 + ((v17 + v17 * v9) >> 8);
    int32x2_t v20 = vadd_s32(v12, (int32x2_t)0x100000001);
    uint32x2_t v21 = (uint32x2_t)vmul_s32(v20, vdup_n_s32(v17));
    unsigned int v22 = v15 + (((v11 + 1) * v17) >> 8);
    int v23 = v11 + 1;
    if (v18) {
      unsigned int v24 = v15;
    }
    else {
      unsigned int v24 = v22;
    }
    double v25 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v16, v21, 8uLL));
    if (!v18)
    {
      signed int v14 = v19;
      double v16 = v25;
    }
    signed int v26 = v24 + ((v23 * v8) >> 8);
    uint32x2_t v27 = (uint32x2_t)vmin_s32((int32x2_t)vsra_n_u32(*(uint32x2_t *)&v16, (uint32x2_t)vmul_s32(v20, v10), 8uLL), vdup_n_s32(v14));
    if (v26 >= v14) {
      signed int v26 = v14;
    }
    uint32x2_t v28 = vshl_u32(v27, (uint32x2_t)0x800000010);
    *result++ = v26 | (v14 << 24) | v28.i32[0] | v28.i32[1];
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::PlusD,true>::blend(int *result, unsigned int *a2, unsigned int *a3, unint64_t a4)
{
  if (a4 >= 2)
  {
    do
    {
      unsigned int v4 = *a3;
      unsigned int v5 = *a2;
      if ((*a2 & *a3) >> 24 == 255)
      {
        unsigned int v6 = ~v5;
        unsigned int v7 = (~v5 & 0xFF00FF) + (~v4 & 0xFF00FF);
        unsigned int v8 = ((v6 >> 8) & 0xFF00FF) + ((~v4 >> 8) & 0xFF00FF);
        int v9 = ~((v8 << 8) & 0x7F00FF00 | v7 & 0xFF00FF | (15 * (v8 & 0x1000100 | (v7 >> 8) & 0x10001)) | (240 * (v8 & 0x1000100 | (v7 >> 8) & 0x10001)));
      }
      else
      {
        unsigned int v10 = HIBYTE(v4);
        int8x8_t v11 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
        int8x8_t v12 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v5), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
        signed int v13 = HIBYTE(v5) + HIBYTE(v4);
        int v14 = v10 - (*a3 + v5) + HIBYTE(v5);
        if (v13 >= 255) {
          unsigned int v15 = 255;
        }
        else {
          unsigned int v15 = v13;
        }
        int v16 = v14 & ~(v14 >> 31);
        if (v16 >= 255) {
          int v16 = 255;
        }
        uint32x2_t v17 = vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v15), vmin_s32(vmax_s32(vsub_s32(vdup_n_s32(v13), vadd_s32((int32x2_t)vand_s8(v12, (int8x8_t)0xFF000000FFLL), (int32x2_t)vand_s8(v11, (int8x8_t)0xFF000000FFLL))), 0), (int32x2_t)0xFF000000FFLL)), (uint32x2_t)0x800000010);
        int v9 = (v15 - v16) | (v15 << 24) | v17.i32[0] | v17.i32[1];
      }
      unsigned int v18 = a3[1];
      unsigned int v19 = a2[1];
      if ((v19 & v18) >> 24 == 255)
      {
        unsigned int v20 = ~v19;
        unsigned int v21 = (~v19 & 0xFF00FF) + (~v18 & 0xFF00FF);
        unsigned int v22 = ((v20 >> 8) & 0xFF00FF) + ((~v18 >> 8) & 0xFF00FF);
        int v23 = ~((v22 << 8) & 0x7F00FF00 | v21 & 0xFF00FF | (15 * (v22 & 0x1000100 | (v21 >> 8) & 0x10001)) | (240 * (v22 & 0x1000100 | (v21 >> 8) & 0x10001)));
      }
      else
      {
        unsigned int v24 = HIBYTE(v18);
        int8x8_t v25 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v18), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
        int8x8_t v26 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v19), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
        signed int v27 = HIBYTE(v19) + HIBYTE(v18);
        int v28 = v24 - (a3[1] + v19) + HIBYTE(v19);
        if (v27 >= 255) {
          unsigned int v29 = 255;
        }
        else {
          unsigned int v29 = v27;
        }
        int v30 = v28 & ~(v28 >> 31);
        if (v30 >= 255) {
          int v30 = 255;
        }
        uint32x2_t v31 = vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v29), vmin_s32(vmax_s32(vsub_s32(vdup_n_s32(v27), vadd_s32((int32x2_t)vand_s8(v26, (int8x8_t)0xFF000000FFLL), (int32x2_t)vand_s8(v25, (int8x8_t)0xFF000000FFLL))), 0), (int32x2_t)0xFF000000FFLL)), (uint32x2_t)0x800000010);
        int v23 = (v29 - v30) | (v29 << 24) | v31.i32[0] | v31.i32[1];
      }
      a4 -= 2;
      void *result = v9;
      result[1] = v23;
      result += 2;
      a2 += 2;
      a3 += 2;
    }
    while (a4 > 1);
  }
  if (a4)
  {
    unsigned int v32 = *a3;
    unsigned int v33 = *a2;
    if ((*a2 & *a3) >> 24 == 255)
    {
      unsigned int v34 = ~v33;
      unsigned int v35 = (~v33 & 0xFF00FF) + (~v32 & 0xFF00FF);
      unsigned int v36 = ((v34 >> 8) & 0xFF00FF) + ((~v32 >> 8) & 0xFF00FF);
      int v37 = ~((v36 << 8) & 0x7F00FF00 | v35 & 0xFF00FF | (15 * (v36 & 0x1000100 | (v35 >> 8) & 0x10001)) | (240 * (v36 & 0x1000100 | (v35 >> 8) & 0x10001)));
    }
    else
    {
      unsigned int v38 = HIBYTE(v32);
      int8x8_t v39 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v32), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
      int8x8_t v40 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v33), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
      signed int v41 = HIBYTE(v33) + HIBYTE(v32);
      int v42 = v38 - (*a3 + v33) + HIBYTE(v33);
      if (v41 >= 255) {
        unsigned int v43 = 255;
      }
      else {
        unsigned int v43 = v41;
      }
      int v44 = v42 & ~(v42 >> 31);
      if (v44 >= 255) {
        int v44 = 255;
      }
      uint32x2_t v45 = vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v43), vmin_s32(vmax_s32(vsub_s32(vdup_n_s32(v41), vadd_s32((int32x2_t)vand_s8(v40, (int8x8_t)0xFF000000FFLL), (int32x2_t)vand_s8(v39, (int8x8_t)0xFF000000FFLL))), 0), (int32x2_t)0xFF000000FFLL)), (uint32x2_t)0x800000010);
      int v37 = (v43 - v44) | (v43 << 24) | v45.i32[0] | v45.i32[1];
    }
    void *result = v37;
  }
  return result;
}

unsigned int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::AlphaMul,false>::blend(unsigned int *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    *result++ = ((((v4 >> 8) & 0xFF0000) + 0x10000) * HIBYTE(v6)) & 0xFF000000 | v6 & 0xFFFFFF;
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::AlphaCopy,false>::blend(int *result, int *a2, uint64_t a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    int v4 = *a2++;
    *result++ = v4 & 0xFFFFFF | (*(unsigned __int8 *)(a3 + 3) << 24);
    a3 += 4;
  }
  return result;
}

unsigned int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::SoverMulD,false>::blend(unsigned int *result, unsigned int *a2, int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    int v5 = *a3++;
    int v4 = v5;
    unsigned int v6 = *a2++;
    *result++ = ((v4 & 0xFF00FF) + ((((v6 & 0xFF00FF) - (v4 & 0xFF00FF)) * (HIBYTE(v6) + 1)) >> 8)) & 0xFF00FF | ((v4 & 0xFF00) + (BYTE1(v6) - (unsigned __int16)BYTE1(v4)) * (HIBYTE(v6) + 1)) & 0xFF00 | 0xFF000000;
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Exclusion,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = HIBYTE(v4);
    unsigned int v8 = HIBYTE(v6);
    int v9 = v6;
    unsigned int v10 = HIBYTE(v4) + 1;
    signed int v11 = (HIBYTE(v6) * v10) >> 8;
    int32x2_t v12 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    signed int v13 = v11 + (((HIBYTE(v6) ^ 0xFF) * v10) >> 8);
    int32x2_t v14 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    double v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v12, (int32x2_t)0x100000001)), 8uLL));
    unsigned int v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255) {
      unsigned int v16 = 0;
    }
    if (v8 == 255) {
      double v15 = 0.0;
    }
    else {
      signed int v11 = v13;
    }
    BOOL v17 = v7 == 255;
    unsigned int v18 = v7 ^ 0xFF;
    signed int v19 = v11 + (((v8 + 1) * v18) >> 8);
    uint32x2_t v20 = (uint32x2_t)vmul_s32(vadd_s32(v14, (int32x2_t)0x100000001), vdup_n_s32(v18));
    unsigned int v21 = v16 + ((v18 + v18 * v9) >> 8);
    unsigned int v22 = v8 + 1;
    if (v17) {
      unsigned int v21 = v16;
    }
    int32x2_t v23 = vdup_n_s32(v10);
    double v24 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v20, 8uLL));
    if (!v17) {
      signed int v11 = v19;
    }
    uint32x2_t v25 = (uint32x2_t)vmul_s32(v14, v23);
    int32x2_t v26 = vadd_s32(v14, v14);
    unsigned int v27 = v9 * v10;
    unsigned int v28 = v22 - 2 * v9;
    if (!v17) {
      double v15 = v24;
    }
    int v29 = ((int)(v28 * v4) >> 8) + (v27 >> 8) + v21;
    if (v29 >= v11) {
      int v29 = v11;
    }
    uint32x2_t v30 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(vadd_s32((int32x2_t)vsra_n_u32((uint32x2_t)vshr_n_s32(vmul_s32(vsub_s32(vdup_n_s32(v22), v26), v12), 8uLL), v25, 8uLL), *(int32x2_t *)&v15), vdup_n_s32(v11)), 0), (uint32x2_t)0x800000010);
    *result++ = v29 & ~(v29 >> 31) | (v11 << 24) | v30.i32[0] | v30.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::LinearDodge,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = HIBYTE(v4);
    unsigned int v8 = HIBYTE(v6);
    int v9 = v6;
    unsigned int v10 = HIBYTE(v4) + 1;
    signed int v11 = (HIBYTE(v6) * v10) >> 8;
    int32x2_t v12 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    signed int v13 = v11 + (((HIBYTE(v6) ^ 0xFF) * v10) >> 8);
    int32x2_t v14 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    double v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v12, (int32x2_t)0x100000001)), 8uLL));
    unsigned int v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255) {
      unsigned int v16 = 0;
    }
    if (v8 == 255) {
      double v15 = 0.0;
    }
    else {
      signed int v11 = v13;
    }
    signed int v17 = v11 + (((v8 + 1) * (v7 ^ 0xFF)) >> 8);
    BOOL v18 = v7 == 255;
    uint32x2_t v19 = (uint32x2_t)vmul_s32(vadd_s32(v14, (int32x2_t)0x100000001), vdup_n_s32(v7 ^ 0xFF));
    unsigned int v20 = v16 + (((v7 ^ 0xFF) + (v7 ^ 0xFF) * v9) >> 8);
    unsigned int v21 = v8 + 1;
    if (v18) {
      unsigned int v20 = v16;
    }
    if (!v18) {
      signed int v11 = v17;
    }
    double v22 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v19, 8uLL));
    uint32x2_t v23 = (uint32x2_t)vmul_s32(v14, vdup_n_s32(v10));
    uint32x2_t v24 = (uint32x2_t)vmul_s32(vdup_n_s32(v21), v12);
    unsigned int v25 = v9 * v10;
    if (!v18) {
      double v15 = v22;
    }
    signed int v26 = ((v21 * v4) >> 8) + (v25 >> 8) + v20;
    uint32x2_t v27 = (uint32x2_t)vmin_s32(vadd_s32((int32x2_t)vsra_n_u32(vshr_n_u32(v23, 8uLL), v24, 8uLL), *(int32x2_t *)&v15), vdup_n_s32(v11));
    if (v26 >= v11) {
      signed int v26 = v11;
    }
    uint32x2_t v28 = vshl_u32(v27, (uint32x2_t)0x800000010);
    *result++ = v26 | (v11 << 24) | v28.i32[0] | v28.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Min,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v7 = *a2++;
    unsigned int v6 = v7;
    int v8 = v4;
    unsigned int v9 = HIBYTE(v7);
    int v10 = v7;
    if (v4 >= v7) {
      int v8 = v10;
    }
    uint32x2_t v11 = (uint32x2_t)vdup_n_s32(v4);
    if (HIBYTE(v4) >= HIBYTE(v6)) {
      unsigned int v12 = v9;
    }
    else {
      unsigned int v12 = HIBYTE(v4);
    }
    uint32x2_t v13 = vshl_u32(vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32(v11, (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), (uint32x2_t)0x800000010);
    *result++ = v13.i32[0] | (v12 << 24) | v8 | v13.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Screen,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = HIBYTE(v4);
    unsigned int v8 = HIBYTE(v6);
    int8x8_t v9 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
    int v10 = v6;
    unsigned int v11 = HIBYTE(v4) + 1;
    signed int v12 = (HIBYTE(v6) * v11) >> 8;
    int32x2_t v13 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    signed int v14 = v12 + (((HIBYTE(v6) ^ 0xFF) * v11) >> 8);
    double v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v13, (int32x2_t)0x100000001)), 8uLL));
    unsigned int v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255) {
      unsigned int v16 = 0;
    }
    if (v8 == 255) {
      double v15 = 0.0;
    }
    else {
      signed int v12 = v14;
    }
    BOOL v17 = v7 == 255;
    unsigned int v18 = v7 ^ 0xFF;
    int32x2_t v19 = (int32x2_t)vand_s8(v9, (int8x8_t)0xFF000000FFLL);
    signed int v20 = v12 + (((v8 + 1) * v18) >> 8);
    uint32x2_t v21 = (uint32x2_t)vmul_s32(vadd_s32(v19, (int32x2_t)0x100000001), vdup_n_s32(v18));
    unsigned int v22 = v16 + ((v18 + v18 * v10) >> 8);
    unsigned int v23 = v8 + 1;
    if (v17) {
      unsigned int v22 = v16;
    }
    if (!v17) {
      signed int v12 = v20;
    }
    double v24 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v21, 8uLL));
    uint32x2_t v25 = (uint32x2_t)vmul_s32(v19, vdup_n_s32(v11));
    int32x2_t v26 = vdup_n_s32(v23);
    if (!v17) {
      double v15 = v24;
    }
    int32x2_t v27 = vsub_s32(v26, v19);
    int v28 = ((int)((v23 - v10) * v4) >> 8) + ((v10 * v11) >> 8) + v22;
    if (v28 >= v12) {
      int v28 = v12;
    }
    uint32x2_t v29 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(vadd_s32((int32x2_t)vsra_n_u32((uint32x2_t)vshr_n_s32(vmul_s32(v27, v13), 8uLL), v25, 8uLL), *(int32x2_t *)&v15), vdup_n_s32(v12)), 0), (uint32x2_t)0x800000010);
    *result++ = v28 & ~(v28 >> 31) | (v12 << 24) | v29.i32[0] | v29.i32[1];
  }
  return result;
}

unsigned __int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Mul,false>::blend(unsigned __int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    int8x8_t v7 = vand_s8((int8x8_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v4 >> 8), (int8x8_t)0xFF0000FF00), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (int32x2_t)0x100000001)), (int8x8_t)0x1FF0001FF0000);
    *result++ = (((v4 >> 8) & 0xFF0000) + ((v4 >> 8) & 0xFF0000) * HIBYTE(v6)) & 0xFF000000 | ((v4
                                                                                              * v6
                                                                                              + v4) >> 8) | v7.i32[0] | v7.i32[1];
  }
  return result;
}

unsigned __int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::SubD,false>::blend(unsigned __int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    uint32x2_t v7 = vshl_u32((uint32x2_t)vmax_s32(vsub_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), 0), (uint32x2_t)0x800000010);
    *result++ = (v4 - v6) & ~((v4 - v6) >> 31) | (((HIBYTE(v4) - HIBYTE(v6)) & ~((int)(HIBYTE(v4) - HIBYTE(v6)) >> 31)) << 24) | v7.i32[0] | v7.i32[1];
  }
  return result;
}

unsigned __int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::SubS,false>::blend(unsigned __int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unsigned int v4 = v5;
    unsigned int v6 = *a2++;
    uint32x2_t v7 = vshl_u32((uint32x2_t)vmax_s32(vsub_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), 0), (uint32x2_t)0x800000010);
    *result++ = (v6 - v4) & ~((v6 - v4) >> 31) | (((HIBYTE(v6) - HIBYTE(v4)) & ~((int)(HIBYTE(v6) - HIBYTE(v4)) >> 31)) << 24) | v7.i32[0] | v7.i32[1];
  }
  return result;
}

uint8x16_t *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Add,true>::blend(uint8x16_t *result, uint8x16_t *a2, uint8x16_t *a3, unint64_t a4)
{
  if (a4 >= 4)
  {
    do
    {
      uint8x16_t v4 = *a3++;
      uint8x16_t v5 = v4;
      uint8x16_t v6 = *a2++;
      *result++ = vqaddq_u8(v5, v6);
      a4 -= 4;
    }
    while (a4 > 3);
  }
  for (; a4; --a4)
  {
    __int32 v8 = a3->i32[0];
    a3 = (uint8x16_t *)((char *)a3 + 4);
    unsigned __int32 v7 = v8;
    unsigned __int32 v9 = a2->i32[0];
    a2 = (uint8x16_t *)((char *)a2 + 4);
    unsigned int v10 = (v9 & 0xFF00FF) + (v7 & 0xFF00FF);
    int v11 = ((v9 >> 8) & 0xFF00FF) + ((v7 >> 8) & 0xFF00FF);
    result->i32[0] = (v11 << 8) & 0xFF00FF00 | v10 & 0xFF00FF | (15 * (v11 & 0x1000100 | (v10 >> 8) & 0x10001)) | (240 * (v11 & 0x1000100 | (v10 >> 8) & 0x10001));
    uint64_t result = (uint8x16_t *)((char *)result + 4);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Xor,false>::blend(_DWORD *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    uint64_t v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = ~v4 >> 24;
    unint64_t v8 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)((~v6 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    unint64_t v9 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * (v7 + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = ((v9 >> 24) | v9) + ((v8 >> 24) | v8);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Datop,false>::blend(_DWORD *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    unint64_t v4 = v5;
    unsigned int v6 = *a2++;
    unint64_t v7 = (v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL;
    unint64_t v8 = ((v7 + v7 * (v4 >> 24)) >> 8) & 0xFF00FF00FF00FFLL;
    unint64_t v9 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * ((~v6 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = ((v8 >> 24) | v8) + ((v9 >> 24) | v9);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Dout,false>::blend(_DWORD *result, unsigned int *a2, int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    int v5 = *a3++;
    int v4 = v5;
    unsigned int v6 = *a2++;
    unint64_t v7 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * ((~v4 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = (v7 >> 24) | v7;
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Din,false>::blend(_DWORD *result, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v4 = *a2++;
    unint64_t v5 = (v4 | ((unint64_t)v4 << 24)) & 0xFF00FF00FF00FFLL;
    unint64_t v6 = ((v5 + v5 * *(unsigned __int8 *)(a3 + 3)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = (v6 >> 24) | v6;
    a3 += 4;
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Dover,false>::blend(_DWORD *result, int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    uint64_t v4 = v5;
    int v6 = *a2++;
    unint64_t v7 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)((~v6 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = v6 + ((v7 >> 24) | v7);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Satop,false>::blend(_DWORD *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    uint64_t v4 = v5;
    unsigned int v6 = *a2++;
    unsigned int v7 = ~v4 >> 24;
    unint64_t v8 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL)
         + ((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * ((unint64_t)v6 >> 24)) >> 8) & 0xFF00FF00FF00FFLL;
    unint64_t v9 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * (v7 + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = ((v9 >> 24) | v9) + ((v8 >> 24) | v8);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Sout,false>::blend(_DWORD *result, int *a2, unsigned int *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    unsigned int v5 = *a3++;
    uint64_t v4 = v5;
    int v6 = *a2++;
    unint64_t v7 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)((~v6 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = (v7 >> 24) | v7;
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Sin,true>::blend(_DWORD *result, uint64_t a2, unsigned int *a3, unint64_t a4)
{
  if (a4 >= 2)
  {
    do
    {
      uint64_t v4 = *a3;
      uint64_t v5 = a3[1];
      a3 += 2;
      unint64_t v6 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL)
           + ((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)*(unsigned __int8 *)(a2 + 3)) >> 8) & 0xFF00FF00FF00FFLL;
      unint64_t v7 = ((((v5 | (v5 << 24)) & 0xFF00FF00FF00FFLL)
           + ((v5 | (v5 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)*(unsigned __int8 *)(a2 + 7)) >> 8) & 0xFF00FF00FF00FFLL;
      void *result = (v6 >> 24) | v6;
      result[1] = (v7 >> 24) | v7;
      result += 2;
      a4 -= 2;
      a2 += 8;
    }
    while (a4 > 1);
  }
  if (a4)
  {
    unint64_t v8 = (*a3 | ((unint64_t)*a3 << 24)) & 0xFF00FF00FF00FFLL;
    unint64_t v9 = ((v8 + v8 * *(unsigned __int8 *)(a2 + 3)) >> 8) & 0xFF00FF00FF00FFLL;
    void *result = (v9 >> 24) | v9;
  }
  return result;
}

vImage_Error CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Sover,true>::blend(void *a1, void *a2, void *a3, vImagePixelCount a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  srcTop.datCGFloat a = a3;
  srcTop.size_t height = 1;
  srcTop.size_t width = a4;
  srcTop.rowBytes = 4 * a4;
  srcBottom.datCGFloat a = a2;
  srcBottom.size_t height = 1;
  srcBottom.size_t width = a4;
  srcBottom.rowBytes = 4 * a4;
  dest.datCGFloat a = a1;
  dest.size_t height = 1;
  dest.size_t width = a4;
  dest.rowBytes = 4 * a4;
  return vImagePremultipliedAlphaBlend_BGRA8888(&srcTop, &srcBottom, &dest, 0x10u);
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Dest,false>::blend(_DWORD *result, int *a2, uint64_t a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    int v4 = *a2++;
    *result++ = v4;
  }
  return result;
}

void CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Clear,false>::blend(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4) {
    bzero(a1, 4 * a4);
  }
}

uint64_t CA::OGL::SW::incomplete_samplers(CA::OGL::SW *this)
{
  uint64_t v1 = &unk_1E8F85000;
  {
    uint64_t v3 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
    memset_pattern16(v3, off_1ED032FD0, 0x80uLL);
    CA::OGL::SW::incomplete_samplers(void)::samplers = (uint64_t)v3;
    uint64_t v1 = (void *)&unk_1E8F85000;
  }
  return v1[506];
}

uint64_t CA::OGL::SW::render_sampler<unsigned int,true,true>(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  v29[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1);
  unint64_t v9 = (char *)v29 - v8;
  bzero((char *)v29 - v8, v10);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char *, uint64_t))(*(void *)(*(void *)a1 + 56)
                                                                        + 8 * a4))(a1, a2, v9, a4);
  if (a2)
  {
    float32x2_t v14 = *(float32x2_t *)(a1 + 76);
    *(float *)v12.i32 = 1.0 / *(float *)(a1 + 72);
    float v15 = *(float *)(a1 + 68) * 0.0039216;
    float32x2_t v16 = (float32x2_t)vdup_lane_s32(v12, 0);
    __asm
    {
      FMOV            V4.2S, #1.0
      FMOV            V6.2S, #3.0
    }
    do
    {
      _D7.i8[0] = v9[2];
      *(float *)_D7.i32 = v15 * (float)_D7.u32[0];
      float32x2_t v23 = vmla_f32((float32x2_t)0x3F0000003F000000, v16, vsub_f32(v14, (float32x2_t)vdup_lane_s32(_D7, 0)));
      float32x2_t v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v23, _D4), (int8x8_t)_D4, (int8x8_t)v23);
      float32x2_t v25 = (float32x2_t)vbic_s8((int8x8_t)v24, (int8x8_t)vcltz_f32(v24));
      float32x2_t v26 = vmla_f32(_D6, (float32x2_t)0xC0000000C0000000, v25);
      v25.i32[1] = vmul_f32(v25, v25).i32[1];
      _D16 = vmul_f32(v25, v26);
      v25.i32[1] = 1132396544;
      _D7 = (int32x2_t)vmul_f32(_D16, v25);
      _D16.f32[0] = 1.0 - *(float *)_D7.i32;
      __asm { FMLA            S17, S16, V7.S[1] }
      *a3++ = _S17 | (_S17 << 8) | ((_S17 | (_S17 << 8)) << 16);
      v9 += 4;
      LODWORD(a2) = a2 - 1;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::render_sampler<unsigned int,true,false>(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  v25[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1);
  unint64_t v9 = (char *)v25 - v8;
  bzero((char *)v25 - v8, v10);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char *, uint64_t))(*(void *)(*(void *)a1 + 56)
                                                                        + 8 * a4))(a1, a2, v9, a4);
  if (a2)
  {
    float32x2_t v13 = *(float32x2_t *)(a1 + 76);
    float v14 = *(float *)(a1 + 68) * 0.0039216;
    __asm { FMOV            V3.2S, #1.0 }
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      v12.i8[0] = v9[2];
      *(float *)v12.i32 = v14 * (float)v12.u32[0];
      float32x2_t v21 = vadd_f32(vsub_f32(v13, (float32x2_t)vdup_lane_s32(v12, 0)), (float32x2_t)0x3F0000003F000000);
      float32x2_t v22 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v21, _D3), (int8x8_t)_D3, (int8x8_t)v21);
      v23.i32[0] = vsub_f32(_D3, v22).u32[0];
      v23.i32[1] = vmul_f32(v22, v20).i32[1];
      float32x2_t v24 = (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v22), (int8x8_t)1065353216, v23);
      int32x2_t v12 = (int32x2_t)vmul_lane_f32(v24, v24, 1);
      *(float *)v12.i32 = *(float *)v12.i32 + 0.5;
      *a3++ = *(float *)v12.i32 | (*(float *)v12.i32 << 8) | ((*(float *)v12.i32 | (*(float *)v12.i32 << 8)) << 16);
      v9 += 4;
      LODWORD(a2) = a2 - 1;
    }
    while (a2);
  }
  return result;
}

float CA::OGL::SW::render_sampler<unsigned int,false,true>(float *a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1);
  unint64_t v9 = (char *)v16 - v8;
  bzero((char *)v16 - v8, v10);
  (*(void (**)(float *, uint64_t, char *, uint64_t))(*(void *)(*(void *)a1 + 56) + 8 * a4))(a1, a2, v9, a4);
  if (a2)
  {
    float result = a1[19];
    float v13 = a1[17] * 0.0039216;
    float v14 = 1.0 / a1[18];
    do
    {
      LOBYTE(v12) = v9[2];
      float v15 = (float)((float)(result - (float)(v13 * (float)LODWORD(v12))) * v14) + 0.5;
      if (v15 > 1.0) {
        float v15 = 1.0;
      }
      if (v15 < 0.0) {
        float v15 = 0.0;
      }
      float v12 = (float)((float)((float)(v15 * v15) * -255.0) * (float)((float)(v15 * 2.0) + -3.0)) + 0.5;
      *a3++ = v12 | (v12 << 8) | ((v12 | (v12 << 8)) << 16);
      v9 += 4;
      LODWORD(a2) = a2 - 1;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::render_sampler<unsigned int,false,false>(float *a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1);
  unint64_t v9 = (char *)v16 - v8;
  bzero((char *)v16 - v8, v10);
  uint64_t result = (*(uint64_t (**)(float *, uint64_t, char *, uint64_t))(*(void *)(*(void *)a1 + 56)
                                                                        + 8 * a4))(a1, a2, v9, a4);
  if (a2)
  {
    float v13 = a1[19];
    float v14 = a1[17] * 0.0039216;
    do
    {
      LOBYTE(v12) = v9[2];
      float v15 = (float)(v13 - (float)(v14 * (float)LODWORD(v12))) + 0.5;
      if (v15 > 1.0) {
        float v15 = 1.0;
      }
      if (v15 >= 0.0) {
        float v12 = (float)(v15 * 255.0) + 0.5;
      }
      else {
        float v12 = 0.5;
      }
      *a3++ = v12 | (v12 << 8) | ((v12 | (v12 << 8)) << 16);
      v9 += 4;
      LODWORD(a2) = a2 - 1;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::render_sampler<CA::Vec4<float>,true,true>(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  v30[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1);
  unint64_t v9 = (float *)&v30[-2 * v8];
  bzero(v9, v10);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, float *, uint64_t))(*(void *)(*(void *)a1 + 56)
                                                                         + 8 * a4))(a1, a2, v9, a4);
  if (a2)
  {
    float32x2_t v14 = *(float32x2_t *)(a1 + 76);
    float v15 = *(float *)(a1 + 68);
    *(float *)v12.i32 = 1.0 / *(float *)(a1 + 72);
    float32x2_t v16 = (float32x2_t)vdup_lane_s32(v12, 0);
    __asm
    {
      FMOV            V4.2S, #1.0
      FMOV            V6.2S, #3.0
    }
    do
    {
      float v23 = *v9;
      v9 += 4;
      *(float *)_D7.i32 = v23 * v15;
      float32x2_t v24 = vmla_f32((float32x2_t)0x3F0000003F000000, v16, vsub_f32(v14, (float32x2_t)vdup_lane_s32(_D7, 0)));
      float32x2_t v25 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, _D4), (int8x8_t)_D4, (int8x8_t)v24);
      float32x2_t v26 = (float32x2_t)vbic_s8((int8x8_t)v25, (int8x8_t)vcltz_f32(v25));
      float32x2_t v27 = vmla_f32(_D6, (float32x2_t)0xC0000000C0000000, v26);
      v26.i32[1] = vmul_f32(v26, v26).i32[1];
      _D16 = vmul_f32(v26, v27);
      v26.i32[1] = 1132396544;
      _D7 = (int32x2_t)vmul_f32(_D16, v26);
      _D16.f32[0] = 1.0 - *(float *)_D7.i32;
      __asm { FMLA            S17, S16, V7.S[1] }
      *a3++ = _S17 | (_S17 << 8) | ((_S17 | (_S17 << 8)) << 16);
      LODWORD(a2) = a2 - 1;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::render_sampler<CA::Vec4<float>,true,false>(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  v26[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1);
  unint64_t v9 = (float *)&v26[-2 * v8];
  bzero(v9, v10);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, float *, uint64_t))(*(void *)(*(void *)a1 + 56)
                                                                         + 8 * a4))(a1, a2, v9, a4);
  if (a2)
  {
    float v13 = *(float *)(a1 + 68);
    float32x2_t v14 = *(float32x2_t *)(a1 + 76);
    __asm { FMOV            V3.2S, #1.0 }
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      float v21 = *v9;
      v9 += 4;
      *(float *)v12.i32 = v21 * v13;
      float32x2_t v22 = vadd_f32(vsub_f32(v14, (float32x2_t)vdup_lane_s32(v12, 0)), (float32x2_t)0x3F0000003F000000);
      float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, _D3), (int8x8_t)_D3, (int8x8_t)v22);
      v24.i32[0] = vsub_f32(_D3, v23).u32[0];
      v24.i32[1] = vmul_f32(v23, v20).i32[1];
      float32x2_t v25 = (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v23), (int8x8_t)1065353216, v24);
      int32x2_t v12 = (int32x2_t)vmul_lane_f32(v25, v25, 1);
      *a3++ = (float)(*(float *)v12.i32 + 0.5) | ((float)(*(float *)v12.i32 + 0.5) << 8) | (((float)(*(float *)v12.i32 + 0.5) | ((float)(*(float *)v12.i32 + 0.5) << 8)) << 16);
      LODWORD(a2) = a2 - 1;
    }
    while (a2);
  }
  return result;
}

float CA::OGL::SW::render_sampler<CA::Vec4<float>,false,true>(float *a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1);
  unint64_t v9 = (float *)&v17[-2 * v8];
  bzero(v9, v10);
  (*(void (**)(float *, uint64_t, float *, uint64_t))(*(void *)(*(void *)a1 + 56) + 8
                                                                                                 * a4))(a1, a2, v9, a4);
  if (a2)
  {
    float result = a1[19];
    float v12 = a1[17];
    float v13 = 1.0 / a1[18];
    do
    {
      float v14 = *v9;
      v9 += 4;
      float v15 = (float)((float)(result - (float)(v14 * v12)) * v13) + 0.5;
      if (v15 > 1.0) {
        float v15 = 1.0;
      }
      if (v15 < 0.0) {
        float v15 = 0.0;
      }
      float v16 = (float)((float)((float)(v15 * v15) * -255.0) * (float)((float)(v15 * 2.0) + -3.0)) + 0.5;
      *a3++ = v16 | (v16 << 8) | ((v16 | (v16 << 8)) << 16);
      LODWORD(a2) = a2 - 1;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::render_sampler<CA::Vec4<float>,false,false>(float *a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1);
  unint64_t v9 = (float *)&v17[-2 * v8];
  bzero(v9, v10);
  uint64_t result = (*(uint64_t (**)(float *, uint64_t, float *, uint64_t))(*(void *)(*(void *)a1 + 56)
                                                                         + 8 * a4))(a1, a2, v9, a4);
  if (a2)
  {
    float v12 = a1[17];
    float v13 = a1[19];
    do
    {
      float v14 = *v9;
      v9 += 4;
      float v15 = (float)(v13 - (float)(v14 * v12)) + 0.5;
      if (v15 > 1.0) {
        float v15 = 1.0;
      }
      if (v15 >= 0.0) {
        float v16 = (float)(v15 * 255.0) + 0.5;
      }
      else {
        float v16 = 0.5;
      }
      *a3++ = v16 | (v16 << 8) | ((v16 | (v16 << 8)) << 16);
      LODWORD(a2) = a2 - 1;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,CA::Vec4<float>,true,true,true,true>(uint64_t **a1, int a2, float32x4_t *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v64 = (*a1)[2];
    uint64_t v65 = **a1;
    int32x2_t v58 = (float *)*a1;
    float v5 = *((float *)a1[3] + 3);
    float v6 = *((float *)a1[2] + 3);
    int v7 = *((_DWORD *)a1 + 15);
    int v61 = *((_DWORD *)a1 + 16);
    int v62 = *((_DWORD *)*a1 + 9);
    int v8 = *((_DWORD *)a1 + 13);
    int v60 = *((_DWORD *)a1 + 14);
    int v63 = *((_DWORD *)*a1 + 8);
    int v9 = *((unsigned __int8 *)a1 + 48) - 1;
    __asm { FMOV            V0.4S, #1.0 }
    int32x4_t v70 = _Q0;
    float32x2_t v15 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v16 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v17 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v59 = v9;
    do
    {
      v18.f32[0] = (float)(1.0 / v6) * (float)v8;
      v18.f32[1] = (float)(1.0 / v6) * (float)v7;
      int32x2_t v19 = vcvt_s32_f32(v18);
      switch(v9)
      {
        case 0:
          float32x2_t v20 = vmul_f32(*(float32x2_t *)(v58 + 10), vcvt_f32_s32(v19));
          float32x2_t v21 = vmul_f32(v20, v20);
          float32x2_t v22 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 1), v21);
          v21.f32[0] = fmaxf(vaddv_f32(v21), 0.00001);
          v21.i32[0] = vmul_f32(v22, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 0))).u32[0];
          v21.i32[1] = 0.5;
          float32x2_t v23 = vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v58 + 6)));
          goto LABEL_8;
        case 1:
          float v24 = atan2f(v58[11] * (float)v19.i32[1], v58[10] * (float)v19.i32[0]);
          v25.i32[1] = 1056964608;
          v25.f32[0] = (float)(v24 * -10430.0) + 32768.0;
          float32x2_t v23 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v58 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v26 = vmul_f32(vcvt_f32_s32(v19), vmul_f32(v15, *(float32x2_t *)(v58 + 10)));
          float32x2_t v23 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v26, vrndm_f32(v26)), v16)), vmul_f32(v17, vcvt_f32_u32(*(uint32x2_t *)(v58 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v27 = vcvt_f32_s32(v19);
          float32x2_t v28 = vcvt_f32_s32(*(int32x2_t *)(v58 + 8));
          float32x2_t v29 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v28);
          float32x2_t v30 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v28);
          float32x2_t v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v30), (int8x8_t)v30, (int8x8_t)v27);
          float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, v31), (int8x8_t)v29, (int8x8_t)v31);
LABEL_8:
          int32x2_t v19 = vcvt_s32_f32(v23);
          break;
        default:
          break;
      }
      --v4;
      int v32 = v19.i32[0];
      int v33 = v63 - 0x8000;
      if (v19.i32[0] < v63 - 0x8000) {
        int v33 = v19.i32[0];
      }
      if (v33 <= -32768) {
        int v33 = -32768;
      }
      unsigned int v34 = v33 + 0x8000;
      if (v19.i32[0] <= 0x8000) {
        int v32 = 0x8000;
      }
      int v35 = v32 - 0x8000;
      if (v35 >= v63) {
        int v36 = v63;
      }
      else {
        int v36 = v35;
      }
      int v37 = v19.i32[1];
      int v38 = v62 - 0x8000;
      if (v19.i32[1] < v62 - 0x8000) {
        int v38 = v19.i32[1];
      }
      if (v38 <= -32768) {
        int v38 = -32768;
      }
      unsigned int v39 = v38 + 0x8000;
      if (v19.i32[1] <= 0x8000) {
        int v37 = 0x8000;
      }
      int v40 = v37 - 0x8000;
      if (v40 >= v62) {
        int v41 = v62;
      }
      else {
        int v41 = v40;
      }
      uint64_t v42 = v65 + v64 * ((uint64_t)v41 >> 16);
      uint64_t v43 = v65 + v64 * HIWORD(v39);
      unint64_t v44 = ((uint64_t)v36 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v45 = (v34 >> 15) & 0x1FFFE;
      float v67 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v42 + v44));
      int32x4_t v46 = v70;
      *(float *)v46.i32 = v67;
      int32x4_t v47 = vzip1q_s32(v46, v46);
      *(float *)&v47.i32[2] = v67;
      float32x4_t v69 = (float32x4_t)v47;
      float v66 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v42 + v45));
      int32x4_t v48 = v70;
      *(float *)v48.i32 = v66;
      int32x4_t v49 = vzip1q_s32(v48, v48);
      *(float *)&v49.i32[2] = v66;
      float32x4_t v68 = (float32x4_t)v49;
      float v50 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v43 + v44));
      float v51 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v43 + v45));
      float v52 = (float)BYTE1(v41) * 0.0039062;
      float32x4_t v53 = (float32x4_t)vzip1q_s32((int32x4_t)COERCE_UNSIGNED_INT(v50 - v67), (int32x4_t)COERCE_UNSIGNED_INT(v50 - v67));
      v53.f32[2] = v50 - v67;
      *(float *)&unsigned int v54 = v51 - v66;
      float32x4_t v55 = vmlaq_n_f32(v69, v53, v52);
      float32x4_t v56 = (float32x4_t)vzip1q_s32((int32x4_t)v54, (int32x4_t)v54);
      v56.i32[2] = v54;
      float v6 = v6 + v5;
      v8 += v60;
      v7 += v61;
      *a3++ = vmlaq_n_f32(v55, vmlaq_n_f32(vsubq_f32(v68, v55), v56, v52), (float)BYTE1(v36) * 0.0039062);
      int v9 = v59;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,CA::Vec4<float>,true,true,false,true>(int *a1, int a2, float32x4_t *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v40 = *(void *)(*(void *)a1 + 16);
    uint64_t v41 = **(void **)a1;
    int v5 = a1[15];
    int v6 = a1[13];
    int v36 = a1[14];
    int v37 = a1[16];
    int v38 = *(_DWORD *)(*(void *)a1 + 36);
    int v39 = *(_DWORD *)(*(void *)a1 + 32);
    __asm { FMOV            V0.4S, #1.0 }
    int32x4_t v46 = _Q0;
    do
    {
      --v4;
      int v12 = v39 - 0x8000;
      if (v6 < v39 - 0x8000) {
        int v12 = v6;
      }
      if (v12 <= -32768) {
        int v12 = -32768;
      }
      unsigned int v13 = v12 + 0x8000;
      if (v6 <= 0x8000) {
        int v14 = 0x8000;
      }
      else {
        int v14 = v6;
      }
      int v15 = v14 - 0x8000;
      if (v15 >= v39) {
        int v16 = v39;
      }
      else {
        int v16 = v15;
      }
      int v17 = v38 - 0x8000;
      if (v5 < v38 - 0x8000) {
        int v17 = v5;
      }
      if (v17 <= -32768) {
        int v17 = -32768;
      }
      unsigned int v18 = v17 + 0x8000;
      if (v5 <= 0x8000) {
        int v19 = 0x8000;
      }
      else {
        int v19 = v5;
      }
      int v20 = v19 - 0x8000;
      if (v20 >= v38) {
        int v21 = v38;
      }
      else {
        int v21 = v20;
      }
      uint64_t v22 = v41 + v40 * ((uint64_t)v21 >> 16);
      uint64_t v23 = v41 + v40 * HIWORD(v18);
      unint64_t v24 = ((uint64_t)v16 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v25 = (v13 >> 15) & 0x1FFFE;
      float v43 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v22 + v24));
      int32x4_t v26 = v46;
      *(float *)v26.i32 = v43;
      int32x4_t v27 = vzip1q_s32(v26, v26);
      *(float *)&v27.i32[2] = v43;
      float32x4_t v45 = (float32x4_t)v27;
      float v42 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v22 + v25));
      int32x4_t v28 = v46;
      *(float *)v28.i32 = v42;
      int32x4_t v29 = vzip1q_s32(v28, v28);
      *(float *)&v29.i32[2] = v42;
      float32x4_t v44 = (float32x4_t)v29;
      float v30 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v24));
      float v31 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v25));
      float32x4_t v32 = (float32x4_t)vzip1q_s32((int32x4_t)COERCE_UNSIGNED_INT(v30 - v43), (int32x4_t)COERCE_UNSIGNED_INT(v30 - v43));
      v32.f32[2] = v30 - v43;
      float v33 = (float)BYTE1(v21) * 0.0039062;
      float32x4_t v34 = vmlaq_n_f32(v45, v32, v33);
      float32x4_t v35 = (float32x4_t)vzip1q_s32((int32x4_t)COERCE_UNSIGNED_INT(v31 - v42), (int32x4_t)COERCE_UNSIGNED_INT(v31 - v42));
      v35.f32[2] = v31 - v42;
      v6 += v36;
      *a3++ = vmlaq_n_f32(v34, vmlaq_n_f32(vsubq_f32(v44, v34), v35, v33), (float)BYTE1(v16) * 0.0039062);
      v5 += v37;
    }
    while (v4);
  }
}

uint64_t **CA::OGL::SW::gaussian_sampler<true>(uint64_t **result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = (2 * *((_DWORD *)result + 2));
    int v5 = result[2];
    int v4 = result[3];
    float32x2_t v6 = *(float32x2_t *)((char *)v4 + 4 * v3 + 32);
    float v7 = *((float *)v4 + 3);
    uint64_t v8 = **result;
    float v9 = *((float *)v5 + 3);
    float32x2_t v10 = *(float32x2_t *)((char *)v5 + 4 * v3 + 32);
    do
    {
      uint32x2_t v11 = vmin_u32(vcvt_u32_f32(vmla_n_f32((float32x2_t)0x3F0000003F000000, v10, 512.0 / v9)), (uint32x2_t)0x100000001);
      unsigned int v12 = *(unsigned __int8 *)(v8 + v11.u32[0])
          + *(unsigned __int8 *)(v8 + v11.u32[0]) * *(unsigned __int8 *)(v8 + v11.u32[1]);
      float v9 = v9 + v7;
      float32x2_t v10 = vadd_f32(v10, v6);
      *a3++ = v12 & 0x1FF00 | (v12 >> 8) | ((v12 & 0x1FF00 | (v12 >> 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::gaussian_sampler<false>(uint64_t **result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = (2 * *((_DWORD *)result + 2));
    float32x2_t v4 = *(float32x2_t *)((char *)result[3] + 4 * v3 + 32);
    uint64_t v5 = **result;
    float32x2_t v6 = *(float32x2_t *)((char *)result[2] + 4 * v3 + 32);
    do
    {
      uint32x2_t v7 = vmin_u32(vcvt_u32_f32(vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x4400000044000000, v6)), (uint32x2_t)0x100000001);
      unsigned int v8 = *(unsigned __int8 *)(v5 + v7.u32[0])
         + *(unsigned __int8 *)(v5 + v7.u32[0]) * *(unsigned __int8 *)(v5 + v7.u32[1]);
      float32x2_t v6 = vadd_f32(v6, v4);
      *a3++ = v8 & 0x1FF00 | (v8 >> 8) | ((v8 & 0x1FF00 | (v8 >> 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::uneven_circle_sampler<true,true>(uint64_t result, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  if (a2)
  {
    unint64_t v23 = 0;
    unsigned int v24 = *(_DWORD *)(result + 8);
    uint64_t v25 = (__int32 *)(*(void *)(result + 104) + 48 * v24);
    LODWORD(a6) = v25[6];
    LODWORD(a5) = v25[7];
    *(float *)v11.i32 = 1.0 / *(float *)&a5;
    *(float *)v18.i32 = 1.0 / *(float *)&a6;
    LODWORD(a9) = v25[4];
    LODWORD(a8) = v25[5];
    *(float *)v19.i32 = 1.0 / *(float *)&a8;
    *(float *)v20.i32 = 1.0 / *(float *)&a9;
    LODWORD(a7) = v25[2];
    LODWORD(a10) = v25[3];
    *(float *)v21.i32 = 1.0 / *(float *)&a10;
    v12.i32[0] = *v25;
    LODWORD(a11) = v25[1];
    int32x4_t v27 = *(const float **)(result + 16);
    uint64_t v26 = *(void *)(result + 24);
    v14.i32[0] = *(_DWORD *)(v26 + 12);
    v24 *= 2;
    *(float *)v22.i32 = 1.0 / *(float *)&a11;
    uint64_t v28 = *(void *)(result + 40) + 4 * v24;
    float v29 = *(float *)(v28 + 32);
    v16.i32[0] = *(_DWORD *)(v28 + 36);
    uint64_t v30 = v26 + 4 * v24;
    v15.i32[0] = *(_DWORD *)(v30 + 32);
    v17.i32[0] = *(_DWORD *)(v30 + 36);
    float v31 = &v27[v24];
    float32x4_t v32 = v31 + 8;
    float v33 = v31 + 9;
    uint64_t v34 = *(void *)(result + 32) + 4 * v24;
    float32x4_t v35 = (const float *)(v34 + 32);
    int v36 = (const float *)(v34 + 36);
    v27 += 3;
    uint64x2_t v146 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    float32x4_t v37 = vld1q_dup_f32(v32);
    *(float *)v13.i32 = *(float *)v15.i32 * 4.0;
    float32x4_t v145 = (float32x4_t)vdupq_lane_s32(v13, 0);
    float v147 = *(float *)v15.i32;
    float v148 = *(float *)v17.i32;
    float32x4_t v38 = vmlaq_n_f32(v37, (float32x4_t)xmmword_184998230, *(float *)v15.i32);
    float32x4_t v39 = vld1q_dup_f32(v33);
    *(float *)v15.i32 = *(float *)v17.i32 * 4.0;
    float32x4_t v144 = (float32x4_t)vdupq_lane_s32(v15, 0);
    float32x4_t v40 = vmlaq_n_f32(v39, (float32x4_t)xmmword_184998230, *(float *)v17.i32);
    float32x4_t v41 = vld1q_dup_f32(v35);
    *(float *)v17.i32 = v29 * 4.0;
    int32x4_t v42 = vdupq_lane_s32(v17, 0);
    float32x4_t v143 = (float32x4_t)v42;
    float32x4_t v43 = vmlaq_n_f32(v41, (float32x4_t)xmmword_184998230, v29);
    float32x4_t v44 = vld1q_dup_f32(v36);
    *(float *)v42.i32 = *(float *)v16.i32 * 4.0;
    float32x4_t v142 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.i8, 0);
    float32x4_t v45 = vmlaq_n_f32(v44, (float32x4_t)xmmword_184998230, *(float *)v16.i32);
    float32x4_t v46 = vld1q_dup_f32(v27);
    *(float *)v16.i32 = *(float *)v14.i32 * 4.0;
    float32x4_t v47 = vmlaq_n_f32(v46, (float32x4_t)xmmword_184998230, *(float *)v14.i32);
    *(float *)v14.i32 = 1.0 / *(float *)v12.i32;
    float v140 = 1.0 / *(float *)v12.i32;
    float32x4_t v141 = (float32x4_t)vdupq_lane_s32(v16, 0);
    float v149 = 1.0 / *(float *)&a11;
    float32x4_t v138 = (float32x4_t)vdupq_lane_s32(v22, 0);
    float32x4_t v139 = (float32x4_t)vdupq_lane_s32(v14, 0);
    float32x4_t v136 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a11, 0);
    float32x4_t v137 = (float32x4_t)vdupq_lane_s32(v12, 0);
    float32x4_t v134 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a10, 0);
    float32x4_t v135 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0);
    float32x4_t v132 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    float32x4_t v133 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    float32x4_t v130 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 0);
    float32x4_t v131 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a6, 0);
    *(float *)&a4 = 1.0 / *(float *)&a7;
    float v129 = 1.0 / *(float *)&a7;
    float v150 = 1.0 / *(float *)&a9;
    float32x4_t v127 = (float32x4_t)vdupq_lane_s32(v21, 0);
    float32x4_t v128 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
    float v151 = 1.0 / *(float *)&a8;
    float v152 = 1.0 / *(float *)&a6;
    float32x4_t v125 = (float32x4_t)vdupq_lane_s32(v19, 0);
    float32x4_t v126 = (float32x4_t)vdupq_lane_s32(v20, 0);
    float32x4_t v124 = (float32x4_t)vdupq_lane_s32(v18, 0);
    float v153 = 1.0 / *(float *)&a5;
    float32x4_t v123 = (float32x4_t)vdupq_lane_s32(v11, 0);
    v48.i64[0] = 0x3F0000003F000000;
    v48.i64[1] = 0x3F0000003F000000;
    v49.i64[0] = 0xFF000000FFLL;
    v49.i64[1] = 0xFF000000FFLL;
    __asm { FMOV            V22.4S, #1.0 }
    do
    {
      float32x4_t v55 = vdivq_f32(_Q22, v47);
      float32x4_t v56 = vmulq_f32(v38, v55);
      float32x4_t v57 = vmulq_f32(v40, v55);
      float32x4_t v58 = vaddq_f32(vabsq_f32(vmulq_f32(v43, v55)), vabsq_f32(vmulq_n_f32(v55, v147)));
      float32x4_t v59 = vaddq_f32(vabsq_f32(vmulq_n_f32(v55, v148)), vabsq_f32(vmulq_f32(v45, v55)));
      __asm { FMOV            V0.4S, #-1.0 }
      float32x4_t v61 = vminnmq_f32(vmlaq_f32(_Q0, v139, v56), (float32x4_t)0);
      float32x4_t v62 = vsubq_f32(_Q22, v57);
      float32x4_t v63 = vminnmq_f32(vmlaq_f32(_Q0, v138, v62), (float32x4_t)0);
      float32x4_t v64 = vsubq_f32(_Q22, v56);
      float32x4_t v65 = vminnmq_f32(vmlaq_f32(_Q0, v128, v64), (float32x4_t)0);
      float32x4_t v66 = vminnmq_f32(vmlaq_f32(_Q0, v127, v62), (float32x4_t)0);
      float32x4_t v67 = vminnmq_f32(vmlaq_f32(_Q0, v126, v64), (float32x4_t)0);
      float32x4_t v68 = vminnmq_f32(vmlaq_f32(_Q0, v125, v57), (float32x4_t)0);
      float32x4_t v69 = vminnmq_f32(vmlaq_f32(_Q0, v124, v56), (float32x4_t)0);
      float32x4_t v70 = vminnmq_f32(vmlaq_f32(_Q0, v123, v57), (float32x4_t)0);
      float32x4_t v71 = vminnmq_f32(v137, vmulq_n_f32(v58, v140));
      float32x4_t v72 = vminnmq_f32(v136, vmulq_n_f32(v59, v149));
      float32x4_t v73 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v71, v72), (int8x16_t)v71, (int8x16_t)v72);
      float32x4_t v74 = vabsq_f32(v63);
      float32x4_t v75 = vabsq_f32(v61);
      float32x4_t v76 = vdivq_f32(vminnmq_f32(v75, v74), vmaxnmq_f32(v75, v74));
      float32x4_t v77 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v76, _Q22), (int8x16_t)_Q22, (int8x16_t)v76);
      float32x4_t v78 = (float32x4_t)vdupq_n_s32(0x3F6D11E0u);
      float32x4_t v79 = (float32x4_t)vdupq_n_s32(0xC049FC11);
      float32x4_t v80 = (float32x4_t)vdupq_n_s32(0x406909C0u);
      float32x4_t v81 = (float32x4_t)vdupq_n_s32(0xBFA24ECF);
      float32x4_t v82 = (float32x4_t)vdupq_n_s32(0xBE897CE5);
      float32x4_t v83 = vmlaq_f32(_Q22, vmlaq_f32(v82, v77, vmlaq_f32(v81, v77, vmlaq_f32(v80, v77, vmlaq_f32(v79, v78, v77)))), vmulq_f32(v77, v77));
      float32x4_t v84 = vminnmq_f32(v135, vmulq_n_f32(v58, v129));
      float32x4_t v85 = vminnmq_f32(v134, vmulq_n_f32(v59, 1.0 / *(float *)&a10));
      float32x4_t v86 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v84, v85), (int8x16_t)v84, (int8x16_t)v85);
      float32x4_t v87 = vabsq_f32(v66);
      float32x4_t v88 = vabsq_f32(v65);
      float32x4_t v89 = vdivq_f32(vminnmq_f32(v88, v87), vmaxnmq_f32(v88, v87));
      float32x4_t v90 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v89, _Q22), (int8x16_t)_Q22, (int8x16_t)v89);
      float32x4_t v91 = vmlaq_f32(_Q22, vmlaq_f32(v82, v90, vmlaq_f32(v81, v90, vmlaq_f32(v80, v90, vmlaq_f32(v79, v78, v90)))), vmulq_f32(v90, v90));
      float32x4_t v92 = vminnmq_f32(v133, vmulq_n_f32(v58, v150));
      float32x4_t v93 = vminnmq_f32(v132, vmulq_n_f32(v59, v151));
      float32x4_t v94 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v92, v93), (int8x16_t)v92, (int8x16_t)v93);
      float32x4_t v95 = vabsq_f32(v68);
      float32x4_t v96 = vabsq_f32(v67);
      float32x4_t v97 = vdivq_f32(vminnmq_f32(v96, v95), vmaxnmq_f32(v96, v95));
      float32x4_t v98 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v97, _Q22), (int8x16_t)_Q22, (int8x16_t)v97);
      float32x4_t v99 = vmlaq_f32(_Q22, vmlaq_f32(v82, v98, vmlaq_f32(v81, v98, vmlaq_f32(v80, v98, vmlaq_f32(v79, v78, v98)))), vmulq_f32(v98, v98));
      float32x4_t v100 = vminnmq_f32(v131, vmulq_n_f32(v58, v152));
      float32x4_t v101 = vminnmq_f32(v130, vmulq_n_f32(v59, v153));
      float32x4_t v102 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v100, v101), (int8x16_t)v100, (int8x16_t)v101);
      float32x4_t v103 = vabsq_f32(v70);
      float32x4_t v104 = vabsq_f32(v69);
      float32x4_t v105 = vdivq_f32(vminnmq_f32(v104, v103), vmaxnmq_f32(v104, v103));
      float32x4_t v106 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v105, _Q22), (int8x16_t)_Q22, (int8x16_t)v105);
      float32x4_t v107 = vmlaq_f32(_Q22, vmlaq_f32(v82, v106, vmlaq_f32(v81, v106, vmlaq_f32(v80, v106, vmlaq_f32(v79, v78, v106)))), vmulq_f32(v106, v106));
      int8x16_t v108 = (int8x16_t)vdupq_n_s64(v23);
      uint64x2_t v109 = (uint64x2_t)vorrq_s8(v108, (int8x16_t)xmmword_184997FD0);
      int32x4_t v110 = (int32x4_t)vcgeq_u64(v146, (uint64x2_t)vorrq_s8(v108, (int8x16_t)xmmword_184998240));
      int32x4_t v111 = (int32x4_t)vcgeq_u64(v146, v109);
      float32x4_t v112 = vmlaq_f32(vmulq_f32(v61, v61), v63, v63);
      int8x16_t v113 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q22, v73), v112);
      float32x4_t v114 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      float32x4_t v115 = vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v112)), v48, v73), vdivq_f32(_Q22, v83)), v114), v73);
      int32x4_t v116 = vuzp1q_s32(v111, v110);
      float32x4_t v117 = vmlaq_f32(vmulq_f32(v66, v66), v65, v65);
      uint32x4_t v118 = (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v116, (int8x16_t)vcgtq_f32(vsubq_f32(_Q22, v86), v117)), v49, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v117)), v48, v86), vdivq_f32(_Q22, v91)), v114), v86), v48)), (int32x4_t)0), (uint32x4_t)v49));
      float32x4_t v119 = vmlaq_f32(vmulq_f32(v68, v68), v67, v67);
      uint32x4_t v120 = (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v116, (int8x16_t)vcgtq_f32(vsubq_f32(_Q22, v94), v119)), v49, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v119)), v48, v94), vdivq_f32(_Q22, v99)), v114), v94), v48)), (int32x4_t)0), (uint32x4_t)v49));
      float32x4_t v121 = vmlaq_f32(vmulq_f32(v70, v70), v69, v69);
      uint32x4_t v122 = vminq_u32(vminq_u32((uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v116, v113), v49, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(v115, v48)), (int32x4_t)0), (uint32x4_t)v49)), v118), vminq_u32(v120, (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v116, (int8x16_t)vcgtq_f32(vsubq_f32(_Q22, v102), v121)), v49, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(
                                                                  vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v121)), v48, v102), vdivq_f32(_Q22, v107)), v114), v102), v48)), (int32x4_t)0), (uint32x4_t)v49))));
      if (vmovn_s32(v116).u8[0]) {
        *(_DWORD *)(a3 + 4 * v23) = 16843009 * v122.i32[0];
      }
      *(int32x2_t *)v111.i8 = vmovn_s64((int64x2_t)v111);
      *(int16x4_t *)v111.i8 = vmovn_s32(v111);
      if (v111.i8[2])
      {
        uint64_t result = (16843009 * v122.i32[1]);
        *(_DWORD *)(a3 + 4 * v23 + 4) = result;
      }
      if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v111, *(int64x2_t *)&v110)).i32[1])
      {
        uint64_t result = (16843009 * v122.i32[2]);
        *(_DWORD *)(a3 + 4 * v23 + 8) = result;
      }
      if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v110, *(int64x2_t *)&v110)).i8[6])
      {
        uint64_t result = (16843009 * v122.i32[3]);
        *(_DWORD *)(a3 + 4 * v23 + 12) = result;
      }
      v23 += 4;
      float32x4_t v38 = vaddq_f32(v38, v145);
      float32x4_t v40 = vaddq_f32(v40, v144);
      float32x4_t v43 = vaddq_f32(v43, v143);
      float32x4_t v45 = vaddq_f32(v45, v142);
      float32x4_t v47 = vaddq_f32(v47, v141);
    }
    while (((a2 + 3) & 0x1FFFFFFFCLL) != v23);
  }
  return result;
}

uint64_t CA::OGL::SW::uneven_circle_sampler<false,true>(uint64_t result, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  if (a2)
  {
    unint64_t v25 = 0;
    unsigned int v26 = *(_DWORD *)(result + 8);
    int32x4_t v27 = (__int32 *)(*(void *)(result + 104) + 48 * v26);
    LODWORD(a7) = v27[6];
    LODWORD(a5) = v27[7];
    *(float *)v20.i32 = 1.0 / *(float *)&a5;
    *(float *)v21.i32 = 1.0 / *(float *)&a7;
    LODWORD(a6) = v27[4];
    LODWORD(a8) = v27[5];
    *(float *)v22.i32 = 1.0 / *(float *)&a8;
    v10.i32[0] = v27[2];
    LODWORD(a9) = v27[3];
    *(float *)v23.i32 = 1.0 / *(float *)&a9;
    *(float *)v24.i32 = 1.0 / *(float *)v10.i32;
    v14.i32[0] = *v27;
    v12.i32[0] = v27[1];
    LODWORD(v27) = 2 * v26;
    uint64_t v28 = *(void *)(result + 40) + 8 * v26;
    *(float *)v9.i32 = 1.0 / *(float *)v12.i32;
    v15.i32[0] = *(_DWORD *)(v28 + 32);
    v16.i32[0] = *(_DWORD *)(v28 + 36);
    uint64_t v29 = *(void *)(result + 24) + 4 * v27;
    v11.i32[0] = *(_DWORD *)(v29 + 32);
    v13.i32[0] = *(_DWORD *)(v29 + 36);
    *(float *)v17.i32 = fabsf(*(float *)v13.i32);
    *(float *)v18.i32 = fabsf(*(float *)v11.i32);
    uint64_t v30 = (const float *)(*(void *)(result + 16) + 4 * v27);
    float v31 = v30 + 8;
    v30 += 9;
    uint64_t v32 = *(void *)(result + 32) + 4 * v27;
    float v33 = (const float *)(v32 + 32);
    uint64_t v34 = (const float *)(v32 + 36);
    uint64x2_t v35 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    float32x4_t v36 = vld1q_dup_f32(v31);
    float32x4_t v37 = vmlaq_n_f32(v36, (float32x4_t)xmmword_184998230, *(float *)v11.i32);
    *(float *)v11.i32 = *(float *)v11.i32 * 4.0;
    float32x4_t v141 = (float32x4_t)vdupq_lane_s32(v11, 0);
    float32x4_t v38 = vld1q_dup_f32(v30);
    float32x4_t v39 = vmlaq_n_f32(v38, (float32x4_t)xmmword_184998230, *(float *)v13.i32);
    *(float *)v13.i32 = *(float *)v13.i32 * 4.0;
    float32x4_t v140 = (float32x4_t)vdupq_lane_s32(v13, 0);
    float32x4_t v40 = vld1q_dup_f32(v33);
    float32x4_t v41 = vmlaq_n_f32(v40, (float32x4_t)xmmword_184998230, *(float *)v15.i32);
    *(float *)v15.i32 = *(float *)v15.i32 * 4.0;
    float32x4_t v139 = (float32x4_t)vdupq_lane_s32(v15, 0);
    float32x4_t v42 = vld1q_dup_f32(v34);
    *(float *)v19.i32 = *(float *)v16.i32 * 4.0;
    float32x4_t v137 = (float32x4_t)vdupq_lane_s32(v18, 0);
    float32x4_t v138 = (float32x4_t)vdupq_lane_s32(v19, 0);
    float32x4_t v43 = vmlaq_n_f32(v42, (float32x4_t)xmmword_184998230, *(float *)v16.i32);
    *(float *)v16.i32 = 1.0 / *(float *)v14.i32;
    float v135 = 1.0 / *(float *)v14.i32;
    float32x4_t v136 = (float32x4_t)vdupq_lane_s32(v17, 0);
    float v142 = 1.0 / *(float *)v12.i32;
    float v143 = 1.0 / *(float *)v10.i32;
    float32x4_t v133 = (float32x4_t)vdupq_lane_s32(v9, 0);
    float32x4_t v134 = (float32x4_t)vdupq_lane_s32(v16, 0);
    float32x4_t v131 = (float32x4_t)vdupq_lane_s32(v23, 0);
    float32x4_t v132 = (float32x4_t)vdupq_lane_s32(v24, 0);
    float32x4_t v129 = (float32x4_t)vdupq_lane_s32(v12, 0);
    float32x4_t v130 = (float32x4_t)vdupq_lane_s32(v14, 0);
    float32x4_t v127 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    float32x4_t v128 = (float32x4_t)vdupq_lane_s32(v10, 0);
    float32x4_t v125 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    float32x4_t v126 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a6, 0);
    float32x4_t v123 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 0);
    float32x4_t v124 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0);
    *(float *)&a4 = 1.0 / *(float *)&a6;
    float v122 = 1.0 / *(float *)&a6;
    float v144 = 1.0 / *(float *)&a8;
    float v145 = 1.0 / *(float *)&a7;
    float32x4_t v120 = (float32x4_t)vdupq_lane_s32(v22, 0);
    float32x4_t v121 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
    float32x4_t v119 = (float32x4_t)vdupq_lane_s32(v21, 0);
    float v146 = 1.0 / *(float *)&a5;
    float32x4_t v118 = (float32x4_t)vdupq_lane_s32(v20, 0);
    v44.i64[0] = 0x3F0000003F000000;
    v44.i64[1] = 0x3F0000003F000000;
    v45.i64[0] = 0xFF000000FFLL;
    v45.i64[1] = 0xFF000000FFLL;
    do
    {
      float32x4_t v46 = vaddq_f32(vabsq_f32(v41), v137);
      float32x4_t v47 = vaddq_f32(vabsq_f32(v43), v136);
      __asm { FMOV            V0.4S, #-1.0 }
      float32x4_t v53 = vminnmq_f32(vmlaq_f32(_Q0, v134, v37), (float32x4_t)0);
      __asm { FMOV            V20.4S, #1.0 }
      float32x4_t v55 = vsubq_f32(_Q20, v39);
      float32x4_t v56 = vminnmq_f32(vmlaq_f32(_Q0, v133, v55), (float32x4_t)0);
      float32x4_t v57 = vsubq_f32(_Q20, v37);
      float32x4_t v58 = vminnmq_f32(vmlaq_f32(_Q0, v132, v57), (float32x4_t)0);
      float32x4_t v59 = vminnmq_f32(vmlaq_f32(_Q0, v131, v55), (float32x4_t)0);
      float32x4_t v60 = vminnmq_f32(vmlaq_f32(_Q0, v121, v57), (float32x4_t)0);
      float32x4_t v61 = vminnmq_f32(vmlaq_f32(_Q0, v120, v39), (float32x4_t)0);
      float32x4_t v62 = vminnmq_f32(vmlaq_f32(_Q0, v119, v37), (float32x4_t)0);
      float32x4_t v63 = vminnmq_f32(vmlaq_f32(_Q0, v118, v39), (float32x4_t)0);
      float32x4_t v64 = vminnmq_f32(v130, vmulq_n_f32(v46, v135));
      float32x4_t v65 = vminnmq_f32(v129, vmulq_n_f32(v47, v142));
      float32x4_t v66 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v64, v65), (int8x16_t)v64, (int8x16_t)v65);
      float32x4_t v67 = vabsq_f32(v56);
      float32x4_t v68 = vabsq_f32(v53);
      float32x4_t v69 = vdivq_f32(vminnmq_f32(v68, v67), vmaxnmq_f32(v68, v67));
      float32x4_t v70 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v69, _Q20), (int8x16_t)_Q20, (int8x16_t)v69);
      float32x4_t v71 = (float32x4_t)vdupq_n_s32(0x3F6D11E0u);
      float32x4_t v72 = (float32x4_t)vdupq_n_s32(0xC049FC11);
      float32x4_t v73 = (float32x4_t)vdupq_n_s32(0x406909C0u);
      float32x4_t v74 = (float32x4_t)vdupq_n_s32(0xBFA24ECF);
      float32x4_t v75 = (float32x4_t)vdupq_n_s32(0xBE897CE5);
      float32x4_t v76 = vmlaq_f32(_Q20, vmlaq_f32(v75, v70, vmlaq_f32(v74, v70, vmlaq_f32(v73, v70, vmlaq_f32(v72, v71, v70)))), vmulq_f32(v70, v70));
      float32x4_t v77 = vminnmq_f32(v128, vmulq_n_f32(v46, v143));
      float32x4_t v78 = vminnmq_f32(v127, vmulq_n_f32(v47, 1.0 / *(float *)&a9));
      float32x4_t v79 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v77, v78), (int8x16_t)v77, (int8x16_t)v78);
      float32x4_t v80 = vabsq_f32(v59);
      float32x4_t v81 = vabsq_f32(v58);
      float32x4_t v82 = vdivq_f32(vminnmq_f32(v81, v80), vmaxnmq_f32(v81, v80));
      float32x4_t v83 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v82, _Q20), (int8x16_t)_Q20, (int8x16_t)v82);
      float32x4_t v84 = vmlaq_f32(_Q20, vmlaq_f32(v75, v83, vmlaq_f32(v74, v83, vmlaq_f32(v73, v83, vmlaq_f32(v72, v71, v83)))), vmulq_f32(v83, v83));
      float32x4_t v85 = vminnmq_f32(v126, vmulq_n_f32(v46, v122));
      float32x4_t v86 = vminnmq_f32(v125, vmulq_n_f32(v47, v144));
      float32x4_t v87 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v85, v86), (int8x16_t)v85, (int8x16_t)v86);
      float32x4_t v88 = vabsq_f32(v61);
      float32x4_t v89 = vabsq_f32(v60);
      float32x4_t v90 = vdivq_f32(vminnmq_f32(v89, v88), vmaxnmq_f32(v89, v88));
      float32x4_t v91 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v90, _Q20), (int8x16_t)_Q20, (int8x16_t)v90);
      float32x4_t v92 = vmlaq_f32(_Q20, vmlaq_f32(v75, v91, vmlaq_f32(v74, v91, vmlaq_f32(v73, v91, vmlaq_f32(v72, v71, v91)))), vmulq_f32(v91, v91));
      float32x4_t v93 = vminnmq_f32(v124, vmulq_n_f32(v46, v145));
      float32x4_t v94 = vminnmq_f32(v123, vmulq_n_f32(v47, v146));
      float32x4_t v95 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v93, v94), (int8x16_t)v93, (int8x16_t)v94);
      float32x4_t v96 = vabsq_f32(v63);
      float32x4_t v97 = vabsq_f32(v62);
      float32x4_t v98 = vdivq_f32(vminnmq_f32(v97, v96), vmaxnmq_f32(v97, v96));
      float32x4_t v99 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v98, _Q20), (int8x16_t)_Q20, (int8x16_t)v98);
      float32x4_t v100 = vmlaq_f32(_Q20, vmlaq_f32(v75, v99, vmlaq_f32(v74, v99, vmlaq_f32(v73, v99, vmlaq_f32(v72, v71, v99)))), vmulq_f32(v99, v99));
      int8x16_t v101 = (int8x16_t)vdupq_n_s64(v25);
      int32x4_t v102 = (int32x4_t)vcgeq_u64(v35, (uint64x2_t)vorrq_s8(v101, (int8x16_t)xmmword_184998240));
      int32x4_t v103 = (int32x4_t)vcgeq_u64(v35, (uint64x2_t)vorrq_s8(v101, (int8x16_t)xmmword_184997FD0));
      float32x4_t v104 = vmlaq_f32(vmulq_f32(v53, v53), v56, v56);
      int8x16_t v105 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q20, v66), v104);
      float32x4_t v106 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      float32x4_t v107 = vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v104)), v44, v66), vdivq_f32(_Q20, v76)), v106), v66);
      int32x4_t v108 = vuzp1q_s32(v103, v102);
      uint32x4_t v109 = (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v108, v105), v45, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(v107, v44)), (int32x4_t)0), (uint32x4_t)v45));
      float32x4_t v110 = vmlaq_f32(vmulq_f32(v59, v59), v58, v58);
      uint32x4_t v111 = (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(vsubq_f32(_Q20, v79), v110)), v45, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v110)), v44, v79), vdivq_f32(_Q20, v84)), v106), v79), v44)), (int32x4_t)0), (uint32x4_t)v45));
      float32x4_t v112 = vmlaq_f32(vmulq_f32(v61, v61), v60, v60);
      uint32x4_t v113 = (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(vsubq_f32(_Q20, v87), v112)), v45, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v112)), v44, v87), vdivq_f32(_Q20, v92)), v106), v87), v44)), (int32x4_t)0), (uint32x4_t)v45));
      float32x4_t v114 = vmlaq_f32(vmulq_f32(v63, v63), v62, v62);
      int32x4_t v115 = (int32x4_t)vminq_u32(v113, (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(vsubq_f32(_Q20, v95), v114)), v45, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v114)), v44, v95), vdivq_f32(_Q20, v100)), v106), v95), v44)),
                                                                   (int32x4_t)0),
                                                     (uint32x4_t)v45)));
      uint32x4_t v116 = vminq_u32(vminq_u32(v109, v111), (uint32x4_t)v115);
      if (vmovn_s32(v108).u8[0]) {
        *(_DWORD *)(a3 + 4 * v25) = 16843009 * v116.i32[0];
      }
      *(int32x2_t *)v115.i8 = vmovn_s64((int64x2_t)v103);
      *(int16x4_t *)v115.i8 = vmovn_s32(v115);
      if (v115.i8[2])
      {
        uint64_t result = (16843009 * v116.i32[1]);
        *(_DWORD *)(a3 + 4 * v25 + 4) = result;
      }
      int32x2_t v117 = (int32x2_t)vmovn_s32(vmovn_hight_s64(*(int32x2_t *)v115.i8, (int64x2_t)v102));
      if (v117.i8[4])
      {
        uint64_t result = (16843009 * v116.i32[2]);
        *(_DWORD *)(a3 + 4 * v25 + 8) = result;
      }
      if (vmovn_s32(vmovn_hight_s64(v117, *(int64x2_t *)&v102)).i8[6])
      {
        uint64_t result = (16843009 * v116.i32[3]);
        *(_DWORD *)(a3 + 4 * v25 + 12) = result;
      }
      v25 += 4;
      float32x4_t v37 = vaddq_f32(v37, v141);
      float32x4_t v39 = vaddq_f32(v39, v140);
      float32x4_t v41 = vaddq_f32(v41, v139);
      float32x4_t v43 = vaddq_f32(v43, v138);
    }
    while (((a2 + 3) & 0x1FFFFFFFCLL) != v25);
  }
  return result;
}

uint64_t CA::OGL::SW::uneven_circle_sampler<true,false>(uint64_t result, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  if (a2)
  {
    unint64_t v23 = 0;
    unsigned int v24 = *(_DWORD *)(result + 8);
    unint64_t v25 = (__int32 *)(*(void *)(result + 104) + 48 * v24);
    LODWORD(a6) = v25[6];
    LODWORD(a4) = v25[7];
    *(float *)v19.i32 = 1.0 / *(float *)&a6;
    LODWORD(a8) = v25[4];
    LODWORD(a7) = v25[5];
    *(float *)v21.i32 = 1.0 / *(float *)&a8;
    LODWORD(a10) = v25[2];
    LODWORD(a9) = v25[3];
    *(float *)v22.i32 = 1.0 / *(float *)&a9;
    *(float *)v11.i32 = 1.0 / *(float *)&a10;
    v13.i32[0] = *v25;
    LODWORD(a11) = v25[1];
    int32x4_t v27 = *(const float **)(result + 16);
    uint64_t v26 = *(void *)(result + 24);
    v15.i32[0] = *(_DWORD *)(v26 + 12);
    v24 *= 2;
    *(float *)v12.i32 = 1.0 / *(float *)&a11;
    uint64_t v28 = *(void *)(result + 40) + 4 * v24;
    v18.i32[0] = *(_DWORD *)(v28 + 32);
    float v29 = *(float *)(v28 + 36);
    uint64_t v30 = v26 + 4 * v24;
    v16.i32[0] = *(_DWORD *)(v30 + 32);
    v17.i32[0] = *(_DWORD *)(v30 + 36);
    float v31 = &v27[v24];
    uint64_t v32 = v31 + 8;
    v31 += 9;
    float v33 = (const float *)(*(void *)(result + 32) + 4 * v24);
    uint64x2_t v34 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    uint64x2_t v35 = v33 + 8;
    v33 += 9;
    v27 += 3;
    float32x4_t v36 = vld1q_dup_f32(v32);
    *(float *)v14.i32 = *(float *)v16.i32 * 4.0;
    float32x4_t v138 = (float32x4_t)vdupq_lane_s32(v14, 0);
    float v139 = *(float *)v16.i32;
    float32x4_t v37 = vld1q_dup_f32(v31);
    float32x4_t v38 = vmlaq_n_f32(v36, (float32x4_t)xmmword_184998230, *(float *)v16.i32);
    *(float *)v16.i32 = *(float *)v17.i32 * 4.0;
    int32x4_t v39 = vdupq_lane_s32(v16, 0);
    float32x4_t v40 = vld1q_dup_f32(v35);
    float v140 = *(float *)v17.i32;
    float v141 = 1.0 / *(float *)&a11;
    float32x4_t v41 = vmlaq_n_f32(v37, (float32x4_t)xmmword_184998230, *(float *)v17.i32);
    *(float *)v17.i32 = *(float *)v18.i32 * 4.0;
    float32x4_t v136 = (float32x4_t)vdupq_lane_s32(v17, 0);
    float32x4_t v137 = (float32x4_t)v39;
    float32x4_t v42 = vld1q_dup_f32(v33);
    float32x4_t v43 = vmlaq_n_f32(v40, (float32x4_t)xmmword_184998230, *(float *)v18.i32);
    *(float *)v18.i32 = v29 * 4.0;
    float32x4_t v44 = vld1q_dup_f32(v27);
    float32x4_t v45 = vmlaq_n_f32(v42, (float32x4_t)xmmword_184998230, v29);
    float32x4_t v46 = vmlaq_n_f32(v44, (float32x4_t)xmmword_184998230, *(float *)v15.i32);
    *(float *)v15.i32 = *(float *)v15.i32 * 4.0;
    int32x4_t v47 = vdupq_lane_s32(v15, 0);
    float32x4_t v134 = (float32x4_t)v47;
    float32x4_t v135 = (float32x4_t)vdupq_lane_s32(v18, 0);
    *(float *)v47.i32 = 1.0 / *(float *)v13.i32;
    float32x4_t v132 = (float32x4_t)vdupq_lane_s32(v12, 0);
    float32x4_t v133 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.i8, 0);
    float32x4_t v130 = (float32x4_t)vdupq_lane_s32(v13, 0);
    float32x4_t v131 = (float32x4_t)vdupq_lane_s32(v11, 0);
    float32x4_t v128 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a10, 0);
    float32x4_t v129 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a11, 0);
    float32x4_t v126 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    float32x4_t v127 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    float32x4_t v124 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a6, 0);
    float32x4_t v125 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0);
    *(float *)&a5 = 1.0 / *(float *)&a4;
    float32x4_t v121 = (float32x4_t)vdupq_lane_s32(v22, 0);
    float32x4_t v122 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
    float v123 = 1.0 / *(float *)&a8;
    *(float *)&a7 = 1.0 / *(float *)&a7;
    v20.i32[0] = SLODWORD(a7);
    float32x4_t v119 = (float32x4_t)vdupq_lane_s32(v20, 0);
    float32x4_t v120 = (float32x4_t)vdupq_lane_s32(v21, 0);
    float v48 = 1.0 / *(float *)&a6;
    float v49 = 1.0 / *(float *)&a4;
    float32x4_t v117 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 0);
    float32x4_t v118 = (float32x4_t)vdupq_lane_s32(v19, 0);
    v50.i64[0] = 0x3F0000003F000000;
    v50.i64[1] = 0x3F0000003F000000;
    v51.i64[0] = 0xFF000000FFLL;
    v51.i64[1] = 0xFF000000FFLL;
    do
    {
      int8x16_t v52 = (int8x16_t)vdupq_n_s64(v23);
      uint64x2_t v53 = (uint64x2_t)vorrq_s8(v52, (int8x16_t)xmmword_184997FD0);
      int32x4_t v54 = (int32x4_t)vcgeq_u64(v34, (uint64x2_t)vorrq_s8(v52, (int8x16_t)xmmword_184998240));
      int32x4_t v55 = (int32x4_t)vcgeq_u64(v34, v53);
      int32x4_t v56 = vuzp1q_s32(v55, v54);
      __asm { FMOV            V2.4S, #1.0 }
      float32x4_t v62 = vdivq_f32(_Q2, v46);
      float32x4_t v63 = vmulq_f32(v38, v62);
      float32x4_t v64 = vmulq_f32(v41, v62);
      float32x4_t v65 = vaddq_f32(vabsq_f32(vmulq_f32(v43, v62)), vabsq_f32(vmulq_n_f32(v62, v139)));
      float32x4_t v66 = vaddq_f32(vabsq_f32(vmulq_n_f32(v62, v140)), vabsq_f32(vmulq_f32(v45, v62)));
      __asm { FMOV            V29.4S, #-1.0 }
      float32x4_t v68 = vminnmq_f32(vmlaq_f32(_Q29, v133, v63), (float32x4_t)0);
      float32x4_t v69 = vsubq_f32(_Q2, v64);
      float32x4_t v70 = vminnmq_f32(vmlaq_f32(_Q29, v132, v69), (float32x4_t)0);
      float32x4_t v71 = vsubq_f32(_Q2, v63);
      float32x4_t v72 = vminnmq_f32(vmlaq_f32(_Q29, v131, v71), (float32x4_t)0);
      float32x4_t v73 = vminnmq_f32(vmlaq_f32(_Q29, v121, v69), (float32x4_t)0);
      float32x4_t v74 = vmlaq_f32(_Q29, v120, v71);
      float32x4_t v75 = vmlaq_f32(_Q29, v119, v64);
      float32x4_t v76 = vmlaq_f32(_Q29, v118, v63);
      float32x4_t v77 = vmlaq_f32(_Q29, v117, v64);
      float32x4_t v78 = vminnmq_f32(v130, vmulq_n_f32(v65, 1.0 / *(float *)v13.i32));
      float32x4_t v79 = vminnmq_f32(v129, vmulq_n_f32(v66, v141));
      float32x4_t v80 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v78, v79), (int8x16_t)v78, (int8x16_t)v79);
      float32x4_t v81 = vmlaq_f32(vmulq_f32(v68, v68), v70, v70);
      int8x16_t v82 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q2, v80), v81);
      int8x16_t v83 = (int8x16_t)vcgtq_f32(v81, vaddq_f32(v80, _Q2));
      float32x4_t v84 = vsqrtq_f32(v81);
      float32x4_t v85 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      uint32x4_t v86 = (uint32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v56, v82), v51, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q2, v50, v80), v84), v85), v80), v50)), (int32x4_t)0), (uint32x4_t)v51)), vandq_s8(vbicq_s8((int8x16_t)v56, v82), v83));
      float32x4_t v87 = vminnmq_f32(v128, vmulq_n_f32(v65, 1.0 / *(float *)&a10));
      float32x4_t v88 = vminnmq_f32(v127, vmulq_n_f32(v66, 1.0 / *(float *)&a9));
      float32x4_t v89 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v87, v88), (int8x16_t)v87, (int8x16_t)v88);
      float32x4_t v90 = vmlaq_f32(vmulq_f32(v73, v73), v72, v72);
      int8x16_t v91 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q2, v89), v90);
      float32x4_t v92 = vminnmq_f32(v126, vmulq_n_f32(v65, v123));
      float32x4_t v93 = vminnmq_f32(v125, vmulq_n_f32(v66, *(float *)&a7));
      float32x4_t v94 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v92, v93), (int8x16_t)v92, (int8x16_t)v93);
      int8x16_t v95 = (int8x16_t)vcgtq_f32(v90, vaddq_f32(v89, _Q2));
      float32x4_t v96 = vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q2, v50, v89), vsqrtq_f32(v90)), v85), v89);
      int8x16_t v97 = vandq_s8(vbicq_s8((int8x16_t)v56, v91), v95);
      int8x16_t v98 = vbslq_s8(vandq_s8((int8x16_t)v56, v91), v51, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(v96, v50)), (int32x4_t)0), (uint32x4_t)v51));
      float32x4_t v99 = vminnmq_f32(v74, (float32x4_t)0);
      float32x4_t v100 = vminnmq_f32(v75, (float32x4_t)0);
      uint32x4_t v101 = (uint32x4_t)vbicq_s8(v98, v97);
      float32x4_t v102 = vmlaq_f32(vmulq_f32(v100, v100), v99, v99);
      int8x16_t v103 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q2, v94), v102);
      float32x4_t v104 = vminnmq_f32(v124, vmulq_n_f32(v65, v48));
      float32x4_t v105 = vminnmq_f32(v122, vmulq_n_f32(v66, v49));
      float32x4_t v106 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v104, v105), (int8x16_t)v104, (int8x16_t)v105);
      int8x16_t v107 = (int8x16_t)vcgtq_f32(v102, vaddq_f32(v94, _Q2));
      int8x16_t v108 = vbicq_s8((int8x16_t)v56, v103);
      int8x16_t v109 = vbslq_s8(vandq_s8((int8x16_t)v56, v103), v51, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q2, v50, v94), vsqrtq_f32(v102)), v85), v94), v50)), (int32x4_t)0), (uint32x4_t)v51));
      float32x4_t v110 = vminnmq_f32(v76, (float32x4_t)0);
      float32x4_t v111 = vminnmq_f32(v77, (float32x4_t)0);
      float32x4_t v112 = vmlaq_f32(vmulq_f32(v111, v111), v110, v110);
      int8x16_t v113 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q2, v106), v112);
      int32x4_t v114 = (int32x4_t)vminq_u32(v86, v101);
      uint32x4_t v115 = vminq_u32((uint32x4_t)v114, vminq_u32((uint32x4_t)vbicq_s8(v109, vandq_s8(v108, v107)), (uint32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v56, v113), v51, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q2, v50, v106), vsqrtq_f32(v112)), v85), v106), v50)),
                                                            (int32x4_t)0),
                                              (uint32x4_t)v51)),
                               vandq_s8(vbicq_s8((int8x16_t)v56, v113), (int8x16_t)vcgtq_f32(v112, vaddq_f32(v106, _Q2))))));
      if (vmovn_s32(v56).u8[0]) {
        *(_DWORD *)(a3 + 4 * v23) = 16843009 * v115.i32[0];
      }
      *(int32x2_t *)v114.i8 = vmovn_s64((int64x2_t)v55);
      *(int16x4_t *)v114.i8 = vmovn_s32(v114);
      if (v114.i8[2]) {
        *(_DWORD *)(a3 + 4 * v23 + 4) = 16843009 * v115.i32[1];
      }
      int32x2_t v116 = (int32x2_t)vmovn_s32(vmovn_hight_s64(*(int32x2_t *)v114.i8, (int64x2_t)v54));
      if (v116.i8[4]) {
        *(_DWORD *)(a3 + 4 * v23 + 8) = 16843009 * v115.i32[2];
      }
      if (vmovn_s32(vmovn_hight_s64(v116, *(int64x2_t *)&v54)).i8[6]) {
        *(_DWORD *)(a3 + 4 * v23 + 12) = 16843009 * v115.i32[3];
      }
      v23 += 4;
      float32x4_t v38 = vaddq_f32(v38, v138);
      float32x4_t v41 = vaddq_f32(v41, v137);
      float32x4_t v43 = vaddq_f32(v43, v136);
      float32x4_t v45 = vaddq_f32(v45, v135);
      float32x4_t v46 = vaddq_f32(v46, v134);
    }
    while (((a2 + 3) & 0x1FFFFFFFCLL) != v23);
  }
  return result;
}

uint64_t CA::OGL::SW::uneven_circle_sampler<false,false>(uint64_t result, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  if (a2)
  {
    unint64_t v23 = 0;
    unsigned int v24 = *(_DWORD *)(result + 8);
    unint64_t v25 = (__int32 *)(*(void *)(result + 104) + 48 * v24);
    LODWORD(a6) = v25[6];
    LODWORD(a4) = v25[7];
    *(float *)v19.i32 = 1.0 / *(float *)&a6;
    LODWORD(a8) = v25[4];
    LODWORD(a7) = v25[5];
    *(float *)v20.i32 = 1.0 / *(float *)&a7;
    *(float *)v21.i32 = 1.0 / *(float *)&a8;
    v12.i32[0] = v25[2];
    LODWORD(a9) = v25[3];
    *(float *)v22.i32 = 1.0 / *(float *)&a9;
    *(float *)v9.i32 = 1.0 / *(float *)v12.i32;
    v14.i32[0] = *v25;
    v13.i32[0] = v25[1];
    LODWORD(v25) = 2 * v24;
    uint64_t v26 = *(void *)(result + 40) + 8 * v24;
    *(float *)v10.i32 = 1.0 / *(float *)v13.i32;
    float v27 = *(float *)(v26 + 32);
    float v28 = *(float *)(v26 + 36);
    uint64_t v29 = *(void *)(result + 24) + 4 * v25;
    float v30 = *(float *)(v29 + 32);
    float v31 = *(float *)(v29 + 36);
    *(float *)v15.i32 = fabsf(v31);
    *(float *)v16.i32 = fabsf(v30);
    uint64_t v32 = (const float *)(*(void *)(result + 16) + 4 * v25);
    uint64x2_t v33 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    uint64x2_t v34 = v32 + 8;
    v32 += 9;
    uint64_t v35 = *(void *)(result + 32) + 4 * v25;
    float32x4_t v36 = (const float *)(v35 + 32);
    float32x4_t v37 = (const float *)(v35 + 36);
    float32x4_t v38 = vld1q_dup_f32(v34);
    *(float *)v18.i32 = v30 * 4.0;
    int32x4_t v39 = vdupq_lane_s32(v18, 0);
    float32x4_t v130 = (float32x4_t)v39;
    float32x4_t v40 = vmlaq_n_f32(v38, (float32x4_t)xmmword_184998230, v30);
    float32x4_t v41 = vld1q_dup_f32(v32);
    *(float *)v39.i32 = v31 * 4.0;
    int32x4_t v42 = vdupq_lane_s32(*(int32x2_t *)v39.i8, 0);
    float32x4_t v129 = (float32x4_t)v42;
    float32x4_t v43 = vmlaq_n_f32(v41, (float32x4_t)xmmword_184998230, v31);
    float32x4_t v44 = vld1q_dup_f32(v36);
    *(float *)v42.i32 = v27 * 4.0;
    float32x4_t v45 = vmlaq_n_f32(v44, (float32x4_t)xmmword_184998230, v27);
    float32x4_t v46 = vld1q_dup_f32(v37);
    *(float *)v17.i32 = v28 * 4.0;
    float32x4_t v127 = (float32x4_t)vdupq_lane_s32(v17, 0);
    float32x4_t v128 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.i8, 0);
    float32x4_t v47 = vmlaq_n_f32(v46, (float32x4_t)xmmword_184998230, v28);
    int32x4_t v48 = vdupq_lane_s32(v15, 0);
    float32x4_t v125 = (float32x4_t)v48;
    float32x4_t v126 = (float32x4_t)vdupq_lane_s32(v16, 0);
    *(float *)v48.i32 = 1.0 / *(float *)v14.i32;
    float v124 = 1.0 / *(float *)v14.i32;
    float v131 = 1.0 / *(float *)v13.i32;
    float v132 = 1.0 / *(float *)v12.i32;
    float32x4_t v122 = (float32x4_t)vdupq_lane_s32(v10, 0);
    float32x4_t v123 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.i8, 0);
    float32x4_t v120 = (float32x4_t)vdupq_lane_s32(v22, 0);
    float32x4_t v121 = (float32x4_t)vdupq_lane_s32(v9, 0);
    float32x4_t v118 = (float32x4_t)vdupq_lane_s32(v14, 0);
    float32x4_t v119 = (float32x4_t)vdupq_lane_s32(v21, 0);
    float32x4_t v116 = (float32x4_t)vdupq_lane_s32(v12, 0);
    float32x4_t v117 = (float32x4_t)vdupq_lane_s32(v13, 0);
    float32x4_t v114 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    float32x4_t v115 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    float32x4_t v112 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a6, 0);
    float32x4_t v113 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0);
    *(float *)v11.i32 = 1.0 / *(float *)&a4;
    float32x4_t v111 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
    float32x4_t v49 = (float32x4_t)vdupq_lane_s32(v20, 0);
    float v50 = 1.0 / *(float *)&a6;
    float32x4_t v51 = (float32x4_t)vdupq_lane_s32(v19, 0);
    float32x4_t v52 = (float32x4_t)vdupq_lane_s32(v11, 0);
    v53.i64[0] = 0x3F0000003F000000;
    v53.i64[1] = 0x3F0000003F000000;
    v54.i64[0] = 0xFF000000FFLL;
    v54.i64[1] = 0xFF000000FFLL;
    do
    {
      int8x16_t v55 = (int8x16_t)vdupq_n_s64(v23);
      uint64x2_t v56 = (uint64x2_t)vorrq_s8(v55, (int8x16_t)xmmword_184997FD0);
      int32x4_t v57 = (int32x4_t)vcgeq_u64(v33, (uint64x2_t)vorrq_s8(v55, (int8x16_t)xmmword_184998240));
      int32x4_t v58 = (int32x4_t)vcgeq_u64(v33, v56);
      int32x4_t v59 = vuzp1q_s32(v58, v57);
      float32x4_t v60 = vaddq_f32(vabsq_f32(v45), v126);
      float32x4_t v61 = vaddq_f32(vabsq_f32(v47), v125);
      __asm { FMOV            V26.4S, #-1.0 }
      float32x4_t v67 = vminnmq_f32(vmlaq_f32(_Q26, v123, v40), (float32x4_t)0);
      __asm { FMOV            V24.4S, #1.0 }
      float32x4_t v69 = vsubq_f32(_Q24, v43);
      float32x4_t v70 = vminnmq_f32(vmlaq_f32(_Q26, v122, v69), (float32x4_t)0);
      float32x4_t v71 = vsubq_f32(_Q24, v40);
      float32x4_t v72 = vminnmq_f32(vmlaq_f32(_Q26, v121, v71), (float32x4_t)0);
      float32x4_t v73 = vminnmq_f32(vmlaq_f32(_Q26, v120, v69), (float32x4_t)0);
      float32x4_t v74 = vmlaq_f32(_Q26, v119, v71);
      float32x4_t v75 = vminnmq_f32(v118, vmulq_n_f32(v60, v124));
      float32x4_t v76 = vminnmq_f32(v117, vmulq_n_f32(v61, v131));
      float32x4_t v77 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v75, v76), (int8x16_t)v75, (int8x16_t)v76);
      float32x4_t v78 = vmlaq_f32(vmulq_f32(v67, v67), v70, v70);
      int8x16_t v79 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q24, v77), v78);
      float32x4_t v80 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      uint32x4_t v81 = (uint32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v59, v79), v54, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q24, v53, v77), vsqrtq_f32(v78)), v80), v77), v53)), (int32x4_t)0), (uint32x4_t)v54)), vandq_s8(vbicq_s8((int8x16_t)v59, v79), (int8x16_t)vcgtq_f32(v78, vaddq_f32(v77, _Q24))));
      float32x4_t v82 = vminnmq_f32(v116, vmulq_n_f32(v60, v132));
      float32x4_t v83 = vminnmq_f32(v115, vmulq_n_f32(v61, 1.0 / *(float *)&a9));
      float32x4_t v84 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v82, v83), (int8x16_t)v82, (int8x16_t)v83);
      float32x4_t v85 = vmlaq_f32(vmulq_f32(v73, v73), v72, v72);
      int8x16_t v86 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q24, v84), v85);
      float32x4_t v87 = vminnmq_f32(v114, vmulq_n_f32(v60, 1.0 / *(float *)&a8));
      float32x4_t v88 = vminnmq_f32(v113, vmulq_n_f32(v61, 1.0 / *(float *)&a7));
      float32x4_t v89 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v87, v88), (int8x16_t)v87, (int8x16_t)v88);
      int8x16_t v90 = (int8x16_t)vcgtq_f32(v85, vaddq_f32(v84, _Q24));
      float32x4_t v91 = vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q24, v53, v84), vsqrtq_f32(v85)), v80), v84);
      int8x16_t v92 = vandq_s8(vbicq_s8((int8x16_t)v59, v86), v90);
      float32x4_t v93 = vminnmq_f32(v74, (float32x4_t)0);
      int8x16_t v94 = vbslq_s8(vandq_s8((int8x16_t)v59, v86), v54, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(v91, v53)), (int32x4_t)0), (uint32x4_t)v54));
      float32x4_t v95 = vminnmq_f32(vmlaq_f32(_Q26, v49, v43), (float32x4_t)0);
      uint32x4_t v96 = (uint32x4_t)vbicq_s8(v94, v92);
      float32x4_t v97 = vmlaq_f32(vmulq_f32(v95, v95), v93, v93);
      int8x16_t v98 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q24, v89), v97);
      float32x4_t v99 = vminnmq_f32(v112, vmulq_n_f32(v60, v50));
      float32x4_t v100 = vminnmq_f32(v111, vmulq_n_f32(v61, *(float *)v11.i32));
      float32x4_t v101 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v99, v100), (int8x16_t)v99, (int8x16_t)v100);
      int8x16_t v102 = (int8x16_t)vcgtq_f32(v97, vaddq_f32(v89, _Q24));
      int8x16_t v103 = vbicq_s8((int8x16_t)v59, v98);
      int8x16_t v104 = vbslq_s8(vandq_s8((int8x16_t)v59, v98), v54, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q24, v53, v89), vsqrtq_f32(v97)), v80), v89), v53)), (int32x4_t)0), (uint32x4_t)v54));
      float32x4_t v105 = vminnmq_f32(vmlaq_f32(_Q26, v51, v40), (float32x4_t)0);
      float32x4_t v106 = vminnmq_f32(vmlaq_f32(_Q26, v52, v43), (float32x4_t)0);
      uint32x4_t v107 = (uint32x4_t)vbicq_s8(v104, vandq_s8(v103, v102));
      float32x4_t v108 = vmlaq_f32(vmulq_f32(v106, v106), v105, v105);
      int8x16_t v109 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q24, v101), v108);
      uint32x4_t v110 = vminq_u32(vminq_u32(v81, v96), vminq_u32(v107, (uint32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v59, v109), v54, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q24, v53, v101), vsqrtq_f32(v108)), v80), v101), v53)),
                                                            (int32x4_t)0),
                                              (uint32x4_t)v54)),
                               vandq_s8(vbicq_s8((int8x16_t)v59, v109), (int8x16_t)vcgtq_f32(v108, vaddq_f32(v101, _Q24))))));
      if (vmovn_s32(v59).u8[0]) {
        *(_DWORD *)(a3 + 4 * v23) = 16843009 * v110.i32[0];
      }
      *(int32x2_t *)v58.i8 = vmovn_s64((int64x2_t)v58);
      *(int16x4_t *)v58.i8 = vmovn_s32(v58);
      if (v58.i8[2]) {
        *(_DWORD *)(a3 + 4 * v23 + 4) = 16843009 * v110.i32[1];
      }
      if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v58, *(int64x2_t *)&v57)).i32[1]) {
        *(_DWORD *)(a3 + 4 * v23 + 8) = 16843009 * v110.i32[2];
      }
      if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v57, *(int64x2_t *)&v57)).i8[6]) {
        *(_DWORD *)(a3 + 4 * v23 + 12) = 16843009 * v110.i32[3];
      }
      v23 += 4;
      float32x4_t v40 = vaddq_f32(v40, v130);
      float32x4_t v43 = vaddq_f32(v43, v129);
      float32x4_t v45 = vaddq_f32(v45, v128);
      float32x4_t v47 = vaddq_f32(v47, v127);
    }
    while (((a2 + 3) & 0x1FFFFFFFCLL) != v23);
  }
  return result;
}

float CA::OGL::SW::circle_sampler<true,true>(uint64_t a1, int a2, _DWORD *a3, float result)
{
  if (a2)
  {
    uint64_t v4 = (2 * *(_DWORD *)(a1 + 8));
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 24);
    uint64_t v7 = v5 + 4 * v4;
    uint64_t result = *(float *)(v7 + 32);
    float v8 = *(float *)(v7 + 36);
    uint64_t v9 = *(void *)(a1 + 40) + 4 * v4;
    float v10 = *(float *)(v9 + 32);
    float v11 = *(float *)(v9 + 36);
    float v12 = *(float *)(v5 + 12);
    float v13 = *(float *)(v6 + 12);
    uint64_t v14 = *(void *)(a1 + 32) + 4 * v4;
    float v16 = *(float *)(v14 + 32);
    float v15 = *(float *)(v14 + 36);
    uint64_t v17 = v6 + 4 * v4;
    float v19 = *(float *)(v17 + 32);
    float v18 = *(float *)(v17 + 36);
    int v20 = *(unsigned __int8 *)(a1 + 48);
    do
    {
      float v21 = 1.0 / v13;
      float v22 = v19 * (float)(1.0 / v13);
      float v23 = v18 * (float)(1.0 / v13);
      if (v20 == 5)
      {
        if (*(float *)(a1 + 92) < v22) {
          float v22 = *(float *)(a1 + 92);
        }
        if (*(float *)(a1 + 84) > v22) {
          float v22 = *(float *)(a1 + 84);
        }
        if (*(float *)(a1 + 96) < v23) {
          float v23 = *(float *)(a1 + 96);
        }
        if (*(float *)(a1 + 88) > v23) {
          float v23 = *(float *)(a1 + 88);
        }
      }
      float v24 = fabsf(v21 * result) + fabsf(v21 * v16);
      float v25 = fabsf(v21 * v8) + fabsf(v21 * v15);
      if (v24 > v25) {
        float v25 = v24;
      }
      float v26 = (float)(v22 * v22) + (float)(v23 * v23);
      if (v26 >= (float)(1.0 - v25))
      {
        float v28 = fabsf(v23);
        float v29 = fabsf(v22);
        float v30 = sqrtf(v26);
        float v31 = fminf(v29, v28) / fmaxf(v29, v28);
        if (v31 > 1.0) {
          float v31 = 1.0;
        }
        float v32 = (float)((float)((float)((float)(1.0
                                            / (float)((float)((float)(v31 * v31)
                                                            * (float)((float)((float)((float)((float)((float)((float)((float)(v31 * 0.92605) + -3.156) * v31) + 3.6412)
                                                                                            * v31)
                                                                                    + -1.268)
                                                                            * v31)
                                                                    + -0.26853))
                                                    + 1.0))
                                    - (float)(v30 - (float)(v25 * 0.5)))
                            * 255.0)
                    / v25)
            + 0.5;
        unsigned int v27 = (int)v32 & ~((int)v32 >> 31);
        if (v27 >= 0xFF) {
          unsigned int v27 = 255;
        }
      }
      else
      {
        unsigned int v27 = 255;
      }
      float v13 = v13 + v12;
      float v19 = v19 + result;
      float v18 = v18 + v8;
      float v16 = v16 + v10;
      float v15 = v15 + v11;
      *a3++ = 16843009 * v27;
      --a2;
    }
    while (a2);
  }
  return result;
}

float CA::OGL::SW::circle_sampler<false,true>(uint64_t a1, int a2, _DWORD *a3, float result)
{
  if (a2)
  {
    uint64_t v4 = (2 * *(_DWORD *)(a1 + 8));
    uint64_t v5 = *(void *)(a1 + 24) + 4 * v4;
    uint64_t result = *(float *)(v5 + 32);
    float v6 = *(float *)(v5 + 36);
    uint64_t v7 = *(void *)(a1 + 40) + 4 * v4;
    float v8 = *(float *)(v7 + 32);
    float v9 = *(float *)(v7 + 36);
    uint64_t v10 = *(void *)(a1 + 32) + 4 * v4;
    float v12 = *(float *)(v10 + 32);
    float v11 = *(float *)(v10 + 36);
    uint64_t v13 = *(void *)(a1 + 16) + 4 * v4;
    float v15 = *(float *)(v13 + 32);
    float v14 = *(float *)(v13 + 36);
    float v16 = fabsf(result);
    float v17 = fabsf(v6);
    int v18 = *(unsigned __int8 *)(a1 + 48);
    do
    {
      float v19 = v15;
      float v20 = v14;
      if (v18 == 5)
      {
        float v19 = *(float *)(a1 + 92);
        float v20 = *(float *)(a1 + 96);
        if (v19 >= v15) {
          float v19 = v15;
        }
        if (*(float *)(a1 + 84) > v19) {
          float v19 = *(float *)(a1 + 84);
        }
        if (v20 >= v14) {
          float v20 = v14;
        }
        if (*(float *)(a1 + 88) > v20) {
          float v20 = *(float *)(a1 + 88);
        }
      }
      float v21 = fabsf(v12) + v16;
      float v22 = fabsf(v11) + v17;
      if (v21 <= v22) {
        float v21 = v22;
      }
      float v23 = (float)(v19 * v19) + (float)(v20 * v20);
      if (v23 >= (float)(1.0 - v21))
      {
        float v25 = fabsf(v20);
        float v26 = fabsf(v19);
        float v27 = sqrtf(v23);
        float v28 = fminf(v26, v25) / fmaxf(v26, v25);
        if (v28 > 1.0) {
          float v28 = 1.0;
        }
        float v29 = (float)((float)((float)((float)(1.0
                                            / (float)((float)((float)(v28 * v28)
                                                            * (float)((float)((float)((float)((float)((float)((float)((float)(v28 * 0.92605) + -3.156) * v28) + 3.6412)
                                                                                            * v28)
                                                                                    + -1.268)
                                                                            * v28)
                                                                    + -0.26853))
                                                    + 1.0))
                                    - (float)(v27 - (float)(v21 * 0.5)))
                            * 255.0)
                    / v21)
            + 0.5;
        unsigned int v24 = (int)v29 & ~((int)v29 >> 31);
        if (v24 >= 0xFF) {
          unsigned int v24 = 255;
        }
      }
      else
      {
        unsigned int v24 = 255;
      }
      float v15 = v15 + result;
      float v14 = v14 + v6;
      float v12 = v12 + v8;
      float v11 = v11 + v9;
      *a3++ = 16843009 * v24;
      --a2;
    }
    while (a2);
  }
  return result;
}

float CA::OGL::SW::circle_sampler<true,false>(uint64_t a1, int a2, _DWORD *a3, float result)
{
  if (a2)
  {
    uint64_t v4 = (2 * *(_DWORD *)(a1 + 8));
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 24);
    uint64_t v7 = v5 + 4 * v4;
    uint64_t result = *(float *)(v7 + 32);
    float v8 = *(float *)(v7 + 36);
    uint64_t v9 = *(void *)(a1 + 40) + 4 * v4;
    float v10 = *(float *)(v9 + 32);
    float v11 = *(float *)(v9 + 36);
    float v12 = *(float *)(v5 + 12);
    float v13 = *(float *)(v6 + 12);
    uint64_t v14 = *(void *)(a1 + 32) + 4 * v4;
    float v16 = *(float *)(v14 + 32);
    float v15 = *(float *)(v14 + 36);
    uint64_t v17 = v6 + 4 * v4;
    float v19 = *(float *)(v17 + 32);
    float v18 = *(float *)(v17 + 36);
    int v20 = *(unsigned __int8 *)(a1 + 48);
    do
    {
      float v21 = 1.0 / v13;
      float v22 = v19 * (float)(1.0 / v13);
      float v23 = v18 * (float)(1.0 / v13);
      if (v20 == 5)
      {
        if (*(float *)(a1 + 92) < v22) {
          float v22 = *(float *)(a1 + 92);
        }
        if (*(float *)(a1 + 84) > v22) {
          float v22 = *(float *)(a1 + 84);
        }
        if (*(float *)(a1 + 96) < v23) {
          float v23 = *(float *)(a1 + 96);
        }
        if (*(float *)(a1 + 88) > v23) {
          float v23 = *(float *)(a1 + 88);
        }
      }
      float v24 = fabsf(v21 * result) + fabsf(v21 * v16);
      float v25 = fabsf(v21 * v8) + fabsf(v21 * v15);
      if (v24 > v25) {
        float v25 = v24;
      }
      float v26 = (float)(v22 * v22) + (float)(v23 * v23);
      if (v26 >= (float)(1.0 - v25))
      {
        if (v26 <= (float)(v25 + 1.0))
        {
          float v28 = (float)((float)((float)((float)((float)(v25 * 0.5) + 1.0) - sqrtf(v26)) * 255.0) / v25) + 0.5;
          unsigned int v27 = (int)v28 & ~((int)v28 >> 31);
          if (v27 >= 0xFF) {
            unsigned int v27 = 255;
          }
        }
        else
        {
          unsigned int v27 = 0;
        }
      }
      else
      {
        unsigned int v27 = 255;
      }
      float v13 = v13 + v12;
      float v19 = v19 + result;
      float v18 = v18 + v8;
      float v16 = v16 + v10;
      float v15 = v15 + v11;
      *a3++ = 16843009 * v27;
      --a2;
    }
    while (a2);
  }
  return result;
}

float CA::OGL::SW::circle_sampler<false,false>(uint64_t a1, int a2, _DWORD *a3, float result)
{
  if (a2)
  {
    uint64_t v4 = (2 * *(_DWORD *)(a1 + 8));
    uint64_t v5 = *(void *)(a1 + 24) + 4 * v4;
    uint64_t result = *(float *)(v5 + 32);
    float v6 = *(float *)(v5 + 36);
    uint64_t v7 = *(void *)(a1 + 40) + 4 * v4;
    float v8 = *(float *)(v7 + 32);
    float v9 = *(float *)(v7 + 36);
    uint64_t v10 = *(void *)(a1 + 32) + 4 * v4;
    float v12 = *(float *)(v10 + 32);
    float v11 = *(float *)(v10 + 36);
    uint64_t v13 = *(void *)(a1 + 16) + 4 * v4;
    float v15 = *(float *)(v13 + 32);
    float v14 = *(float *)(v13 + 36);
    float v16 = fabsf(result);
    float v17 = fabsf(v6);
    int v18 = *(unsigned __int8 *)(a1 + 48);
    do
    {
      float v19 = v15;
      float v20 = v14;
      if (v18 == 5)
      {
        float v19 = *(float *)(a1 + 92);
        float v20 = *(float *)(a1 + 96);
        if (v19 >= v15) {
          float v19 = v15;
        }
        if (*(float *)(a1 + 84) > v19) {
          float v19 = *(float *)(a1 + 84);
        }
        if (v20 >= v14) {
          float v20 = v14;
        }
        if (*(float *)(a1 + 88) > v20) {
          float v20 = *(float *)(a1 + 88);
        }
      }
      float v21 = fabsf(v12) + v16;
      float v22 = fabsf(v11) + v17;
      if (v21 <= v22) {
        float v21 = v22;
      }
      float v23 = (float)(v19 * v19) + (float)(v20 * v20);
      if (v23 >= (float)(1.0 - v21))
      {
        if (v23 <= (float)(v21 + 1.0))
        {
          float v25 = (float)((float)((float)((float)((float)(v21 * 0.5) + 1.0) - sqrtf(v23)) * 255.0) / v21) + 0.5;
          unsigned int v24 = (int)v25 & ~((int)v25 >> 31);
          if (v24 >= 0xFF) {
            unsigned int v24 = 255;
          }
        }
        else
        {
          unsigned int v24 = 0;
        }
      }
      else
      {
        unsigned int v24 = 255;
      }
      float v15 = v15 + result;
      float v14 = v14 + v6;
      float v12 = v12 + v8;
      float v11 = v11 + v9;
      *a3++ = 16843009 * v24;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::square_sampler<true>(uint64_t result, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  if (a2)
  {
    unint64_t v13 = 0;
    float v15 = *(const float **)(result + 16);
    uint64_t v14 = *(void *)(result + 24);
    v12.i32[0] = *(_DWORD *)(v14 + 12);
    unsigned int v16 = 2 * *(_DWORD *)(result + 8);
    uint64_t v17 = *(void *)(result + 40) + 4 * v16;
    v10.i32[0] = *(_DWORD *)(v17 + 32);
    v11.i32[0] = *(_DWORD *)(v17 + 36);
    uint64_t v18 = v14 + 4 * v16;
    float v20 = *(float *)(v18 + 32);
    float v19 = *(float *)(v18 + 36);
    float v21 = &v15[v16];
    float v22 = v21 + 8;
    v21 += 9;
    float v23 = (const float *)(*(void *)(result + 32) + 4 * v16);
    uint64x2_t v24 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    float v25 = v23 + 8;
    v23 += 9;
    v15 += 3;
    float32x4_t v26 = vld1q_dup_f32(v22);
    float32x4_t v27 = vmlaq_n_f32(v26, (float32x4_t)xmmword_184998230, v20);
    *(float *)&a8 = v20 * 4.0;
    float32x4_t v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    float32x4_t v29 = vld1q_dup_f32(v21);
    float32x4_t v30 = vmlaq_n_f32(v29, (float32x4_t)xmmword_184998230, v19);
    *(float *)&a10 = v19 * 4.0;
    float32x4_t v31 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a10, 0);
    float32x4_t v32 = vld1q_dup_f32(v25);
    float32x4_t v33 = vmlaq_n_f32(v32, (float32x4_t)xmmword_184998230, *(float *)v10.i32);
    *(float *)v10.i32 = *(float *)v10.i32 * 4.0;
    float32x4_t v34 = (float32x4_t)vdupq_lane_s32(v10, 0);
    float32x4_t v35 = vld1q_dup_f32(v23);
    float32x4_t v36 = vmlaq_n_f32(v35, (float32x4_t)xmmword_184998230, *(float *)v11.i32);
    *(float *)v11.i32 = *(float *)v11.i32 * 4.0;
    float32x4_t v37 = (float32x4_t)vdupq_lane_s32(v11, 0);
    float32x4_t v38 = vld1q_dup_f32(v15);
    float32x4_t v39 = vmlaq_n_f32(v38, (float32x4_t)xmmword_184998230, *(float *)v12.i32);
    *(float *)v12.i32 = *(float *)v12.i32 * 4.0;
    float32x4_t v40 = (float32x4_t)vdupq_lane_s32(v12, 0);
    __asm { FMOV            V23.4S, #1.0 }
    v46.i64[0] = 0x3F0000003F000000;
    v46.i64[1] = 0x3F0000003F000000;
    float32x4_t v47 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    v48.i64[0] = 0xFF000000FFLL;
    v48.i64[1] = 0xFF000000FFLL;
    v49.i64[0] = 0x100000001;
    v49.i64[1] = 0x100000001;
    v50.i64[0] = 0x10000000100;
    v50.i64[1] = 0x10000000100;
    do
    {
      int8x16_t v51 = (int8x16_t)vdupq_n_s64(v13);
      uint64x2_t v52 = (uint64x2_t)vorrq_s8(v51, (int8x16_t)xmmword_184997FD0);
      int32x4_t v53 = (int32x4_t)vcgeq_u64(v24, (uint64x2_t)vorrq_s8(v51, (int8x16_t)xmmword_184998240));
      int32x4_t v54 = (int32x4_t)vcgeq_u64(v24, v52);
      int32x4_t v55 = vuzp1q_s32(v54, v53);
      unsigned __int8 v56 = vmovn_s32(v55).u8[0];
      float32x4_t v57 = vdivq_f32(_Q23, v39);
      float32x4_t v58 = vmulq_f32(v27, v57);
      float32x4_t v59 = vmulq_f32(v30, v57);
      float32x4_t v60 = vaddq_f32(vabsq_f32(vmulq_f32(v33, v57)), vabsq_f32(vmulq_n_f32(v57, v20)));
      float32x4_t v61 = vaddq_f32(vabsq_f32(vmulq_n_f32(v57, v19)), vabsq_f32(vmulq_f32(v36, v57)));
      float32x4_t v62 = vabsq_f32(v58);
      float32x4_t v63 = vmulq_f32(v60, v46);
      int8x16_t v64 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q23, v63), v62);
      float32x4_t v65 = vaddq_f32(v63, _Q23);
      int32x4_t v66 = (int32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v55, v64), v48, (int8x16_t)vcvtq_u32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(v65, v62), v47), v60), v46))), vandq_s8(vbicq_s8((int8x16_t)v55, v64), (int8x16_t)vcgtq_f32(v62, v65)));
      float32x4_t v67 = vabsq_f32(v59);
      float32x4_t v68 = vmulq_f32(v61, v46);
      int8x16_t v69 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q23, v68), v67);
      float32x4_t v70 = vaddq_f32(v68, _Q23);
      int32x4_t v71 = (int32x4_t)vcvtq_u32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(v70, v67), v47), v61), v46));
      int32x4_t v72 = (int32x4_t)vandq_s8(vbicq_s8((int8x16_t)v55, v69), (int8x16_t)vcgtq_f32(v67, v70));
      uint32x4_t v73 = (uint32x4_t)vmulq_s32(vsubq_s32((int32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v55, v69), v50, (int8x16_t)vaddq_s32(v71, v49)), (int8x16_t)v72), v72), v66);
      int8x16_t v74 = vorrq_s8((int8x16_t)vshrq_n_u32(v73, 8uLL), (int8x16_t)(*(_OWORD *)&v73 & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00)));
      if (v56) {
        *(_DWORD *)(a3 + 4 * v13) = v74.i32[0] | (v74.i32[0] << 16);
      }
      *(int32x2_t *)v54.i8 = vmovn_s64((int64x2_t)v54);
      *(int16x4_t *)v54.i8 = vmovn_s32(v54);
      if (v54.i8[2]) {
        *(_DWORD *)(a3 + 4 * v13 + 4) = v74.i32[1] | (v74.i32[1] << 16);
      }
      if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v54, *(int64x2_t *)&v53)).i32[1]) {
        *(_DWORD *)(a3 + 4 * v13 + 8) = v74.i32[2] | (v74.i32[2] << 16);
      }
      if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v53, *(int64x2_t *)&v53)).i8[6]) {
        *(_DWORD *)(a3 + 4 * v13 + 12) = v74.i32[3] | (v74.i32[3] << 16);
      }
      v13 += 4;
      float32x4_t v27 = vaddq_f32(v27, v28);
      float32x4_t v30 = vaddq_f32(v30, v31);
      float32x4_t v33 = vaddq_f32(v33, v34);
      float32x4_t v36 = vaddq_f32(v36, v37);
      float32x4_t v39 = vaddq_f32(v39, v40);
    }
    while (((a2 + 3) & 0x1FFFFFFFCLL) != v13);
  }
  return result;
}

uint64_t CA::OGL::SW::square_sampler<false>(uint64_t result, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  if (a2)
  {
    unint64_t v13 = 0;
    unsigned int v14 = 2 * *(_DWORD *)(result + 8);
    uint64_t v15 = *(void *)(result + 40) + 4 * v14;
    LODWORD(a10) = *(_DWORD *)(v15 + 32);
    v10.i32[0] = *(_DWORD *)(v15 + 36);
    uint64_t v16 = *(void *)(result + 24) + 4 * v14;
    LODWORD(a6) = *(_DWORD *)(v16 + 32);
    LODWORD(a8) = *(_DWORD *)(v16 + 36);
    *(float *)v12.i32 = fabsf(*(float *)&a8);
    *(float *)v11.i32 = fabsf(*(float *)&a6);
    uint64_t v17 = (const float *)(*(void *)(result + 16) + 4 * v14);
    uint64x2_t v18 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    float v19 = v17 + 8;
    v17 += 9;
    uint64_t v20 = *(void *)(result + 32) + 4 * v14;
    float v21 = (const float *)(v20 + 32);
    float v22 = (const float *)(v20 + 36);
    float32x4_t v23 = vld1q_dup_f32(v19);
    float32x4_t v24 = vmlaq_n_f32(v23, (float32x4_t)xmmword_184998230, *(float *)&a6);
    *(float *)&a6 = *(float *)&a6 * 4.0;
    float32x4_t v25 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a6, 0);
    float32x4_t v26 = vld1q_dup_f32(v17);
    float32x4_t v27 = vmlaq_n_f32(v26, (float32x4_t)xmmword_184998230, *(float *)&a8);
    *(float *)&a8 = *(float *)&a8 * 4.0;
    float32x4_t v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    float32x4_t v29 = vld1q_dup_f32(v21);
    float32x4_t v30 = vmlaq_n_f32(v29, (float32x4_t)xmmword_184998230, *(float *)&a10);
    *(float *)&a10 = *(float *)&a10 * 4.0;
    float32x4_t v31 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a10, 0);
    float32x4_t v32 = vld1q_dup_f32(v22);
    float32x4_t v33 = vmlaq_n_f32(v32, (float32x4_t)xmmword_184998230, *(float *)v10.i32);
    *(float *)v10.i32 = *(float *)v10.i32 * 4.0;
    float32x4_t v34 = (float32x4_t)vdupq_lane_s32(v10, 0);
    float32x4_t v35 = (float32x4_t)vdupq_lane_s32(v11, 0);
    float32x4_t v36 = (float32x4_t)vdupq_lane_s32(v12, 0);
    v37.i64[0] = 0x3F0000003F000000;
    v37.i64[1] = 0x3F0000003F000000;
    __asm { FMOV            V22.4S, #1.0 }
    float32x4_t v43 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    v44.i64[0] = 0xFF000000FFLL;
    v44.i64[1] = 0xFF000000FFLL;
    v45.i64[0] = 0x100000001;
    v45.i64[1] = 0x100000001;
    v46.i64[0] = 0x10000000100;
    v46.i64[1] = 0x10000000100;
    do
    {
      int8x16_t v47 = (int8x16_t)vdupq_n_s64(v13);
      uint64x2_t v48 = (uint64x2_t)vorrq_s8(v47, (int8x16_t)xmmword_184997FD0);
      int32x4_t v49 = (int32x4_t)vcgeq_u64(v18, (uint64x2_t)vorrq_s8(v47, (int8x16_t)xmmword_184998240));
      int32x4_t v50 = (int32x4_t)vcgeq_u64(v18, v48);
      int32x4_t v51 = vuzp1q_s32(v50, v49);
      unsigned __int8 v52 = vmovn_s32(v51).u8[0];
      float32x4_t v53 = vaddq_f32(vabsq_f32(v30), v35);
      float32x4_t v54 = vaddq_f32(vabsq_f32(v33), v36);
      float32x4_t v55 = vabsq_f32(v24);
      float32x4_t v56 = vmulq_f32(v53, v37);
      int8x16_t v57 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q22, v56), v55);
      float32x4_t v58 = vaddq_f32(v56, _Q22);
      int32x4_t v59 = (int32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v51, v57), v44, (int8x16_t)vcvtq_u32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(v58, v55), v43), v53), v37))), vandq_s8(vbicq_s8((int8x16_t)v51, v57), (int8x16_t)vcgtq_f32(v55, v58)));
      float32x4_t v60 = vabsq_f32(v27);
      float32x4_t v61 = vmulq_f32(v54, v37);
      int8x16_t v62 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q22, v61), v60);
      float32x4_t v63 = vaddq_f32(v61, _Q22);
      int32x4_t v64 = (int32x4_t)vcvtq_u32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(v63, v60), v43), v54), v37));
      int32x4_t v65 = (int32x4_t)vandq_s8(vbicq_s8((int8x16_t)v51, v62), (int8x16_t)vcgtq_f32(v60, v63));
      uint32x4_t v66 = (uint32x4_t)vmulq_s32(vsubq_s32((int32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v51, v62), v46, (int8x16_t)vaddq_s32(v64, v45)), (int8x16_t)v65), v65), v59);
      int8x16_t v67 = vorrq_s8((int8x16_t)vshrq_n_u32(v66, 8uLL), (int8x16_t)(*(_OWORD *)&v66 & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00)));
      if (v52) {
        *(_DWORD *)(a3 + 4 * v13) = v67.i32[0] | (v67.i32[0] << 16);
      }
      *(int32x2_t *)v50.i8 = vmovn_s64((int64x2_t)v50);
      *(int16x4_t *)v50.i8 = vmovn_s32(v50);
      if (v50.i8[2]) {
        *(_DWORD *)(a3 + 4 * v13 + 4) = v67.i32[1] | (v67.i32[1] << 16);
      }
      if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v50, *(int64x2_t *)&v49)).i32[1]) {
        *(_DWORD *)(a3 + 4 * v13 + 8) = v67.i32[2] | (v67.i32[2] << 16);
      }
      if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v49, *(int64x2_t *)&v49)).i8[6]) {
        *(_DWORD *)(a3 + 4 * v13 + 12) = v67.i32[3] | (v67.i32[3] << 16);
      }
      v13 += 4;
      float32x4_t v24 = vaddq_f32(v24, v25);
      float32x4_t v27 = vaddq_f32(v27, v28);
      float32x4_t v30 = vaddq_f32(v30, v31);
      float32x4_t v33 = vaddq_f32(v33, v34);
    }
    while (((a2 + 3) & 0x1FFFFFFFCLL) != v13);
  }
  return result;
}

uint64_t CA::OGL::SW::unlock_iosurface(CA::OGL::SW *this, void *a2)
{
  return IOSurfaceUnlock(this, 1u, 0);
}

void *CA::OGL::SW::incomplete_sampler(int a1, unsigned int a2, void *__b)
{
  if (a2) {
    return memset(__b, 255, 4 * a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,true,true,true,true>(uint64_t **a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v75 = (*a1)[2];
    uint64_t v76 = **a1;
    int8x16_t v69 = (float *)*a1;
    float v5 = *((float *)a1[3] + 3);
    float v6 = *((float *)a1[2] + 3);
    int v7 = *((_DWORD *)a1 + 15);
    int v72 = *((_DWORD *)a1 + 16);
    int v73 = *((_DWORD *)*a1 + 9);
    int v8 = *((_DWORD *)a1 + 13);
    int v71 = *((_DWORD *)a1 + 14);
    int v74 = *((_DWORD *)*a1 + 8);
    int v9 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v10 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V12.2S, #1.0 }
    int v70 = v9;
    do
    {
      v16.f32[0] = (float)(1.0 / v6) * (float)v8;
      v16.f32[1] = (float)(1.0 / v6) * (float)v7;
      int32x2_t v17 = vcvt_s32_f32(v16);
      switch(v9)
      {
        case 0:
          float32x2_t v18 = vmul_f32(*(float32x2_t *)(v69 + 10), vcvt_f32_s32(v17));
          float32x2_t v19 = vmul_f32(v18, v18);
          float32x2_t v20 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v19, 1), v19);
          v19.f32[0] = fmaxf(vaddv_f32(v19), 0.00001);
          v19.i32[0] = vmul_f32(v20, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v19, 0))).u32[0];
          v19.i32[1] = 0.5;
          float32x2_t v21 = vmul_f32(v19, vcvt_f32_u32(*(uint32x2_t *)(v69 + 6)));
          goto LABEL_8;
        case 1:
          float v22 = atan2f(v69[11] * (float)v17.i32[1], v69[10] * (float)v17.i32[0]);
          v23.i32[1] = 1056964608;
          v23.f32[0] = (float)(v22 * -10430.0) + 32768.0;
          float32x2_t v21 = vmul_f32(v23, vcvt_f32_u32(*(uint32x2_t *)(v69 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v24 = vmul_f32(vcvt_f32_s32(v17), vmul_f32((float32x2_t)vdup_n_s32(0x37800000u), *(float32x2_t *)(v69 + 10)));
          float32x2_t v21 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v24, vrndm_f32(v24)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu))), vmul_f32((float32x2_t)vdup_n_s32(0x47800000u), vcvt_f32_u32(*(uint32x2_t *)(v69 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v25 = vcvt_f32_s32(v17);
          float32x2_t v26 = vcvt_f32_s32(*(int32x2_t *)(v69 + 8));
          float32x2_t v27 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v26);
          float32x2_t v28 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v26);
          float32x2_t v29 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v25, v28), (int8x8_t)v28, (int8x8_t)v25);
          float32x2_t v21 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v29), (int8x8_t)v27, (int8x8_t)v29);
LABEL_8:
          int32x2_t v17 = vcvt_s32_f32(v21);
          break;
        default:
          break;
      }
      --v4;
      int v30 = v17.i32[0];
      int v31 = v74 - 0x8000;
      if (v17.i32[0] < v74 - 0x8000) {
        int v31 = v17.i32[0];
      }
      if (v31 <= -32768) {
        int v31 = -32768;
      }
      unsigned int v32 = v31 + 0x8000;
      if (v17.i32[0] <= 0x8000) {
        int v30 = 0x8000;
      }
      int v33 = v30 - 0x8000;
      int v34 = v17.i32[1];
      if (v33 >= v74) {
        int v35 = v74;
      }
      else {
        int v35 = v33;
      }
      int v36 = v73 - 0x8000;
      if (v17.i32[1] < v73 - 0x8000) {
        int v36 = v17.i32[1];
      }
      if (v36 <= -32768) {
        int v36 = -32768;
      }
      unsigned int v37 = v36 + 0x8000;
      if (v17.i32[1] <= 0x8000) {
        int v34 = 0x8000;
      }
      int v38 = v34 - 0x8000;
      if (v38 >= v73) {
        int v39 = v73;
      }
      else {
        int v39 = v38;
      }
      uint64_t v40 = v76 + v75 * ((uint64_t)v39 >> 16);
      uint64_t v41 = v76 + v75 * HIWORD(v37);
      unint64_t v42 = ((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v43 = v40 + v42;
      int8x16_t v44 = (unsigned __int16 *)(v41 + v42);
      uint64_t v45 = (v32 >> 14) & 0x3FFFC;
      int8x16_t v46 = (unsigned __int16 *)(v40 + v45);
      int8x16_t v47 = (unsigned __int16 *)(v41 + v45);
      float v77 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v40 + v42));
      float v48 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v43 + 2));
      float32x2_t v49 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v48), LODWORD(v77)), _D12), (int8x8_t)_D12, (int8x8_t)__PAIR64__(LODWORD(v48), LODWORD(v77)));
      int32x2_t v50 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v49), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v10, v49)));
      int32x2_t v51 = (int32x2_t)vshl_u32((uint32x2_t)v50, (uint32x2_t)0x1800000010);
      float v78 = CA::HalfFloat::to_float((CA::HalfFloat *)*v46);
      float v52 = CA::HalfFloat::to_float((CA::HalfFloat *)v46[1]);
      float32x2_t v53 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v52), LODWORD(v78)), _D12), (int8x8_t)_D12, (int8x8_t)__PAIR64__(LODWORD(v52), LODWORD(v78)));
      int32x2_t v54 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v53), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v10, v53)));
      int32x2_t v55 = (int32x2_t)vshl_u32((uint32x2_t)v54, (uint32x2_t)0x1800000010);
      int32x2_t v56 = vzip1_s32(v50, v54);
      uint8x8_t v57 = (uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v51, v55), (int8x8_t)vshl_n_s32(v56, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v51, v55), (int8x8_t)v56));
      float v79 = CA::HalfFloat::to_float((CA::HalfFloat *)*v44);
      float v58 = CA::HalfFloat::to_float((CA::HalfFloat *)v44[1]);
      float32x2_t v59 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v58), LODWORD(v79)), _D12), (int8x8_t)_D12, (int8x8_t)__PAIR64__(LODWORD(v58), LODWORD(v79)));
      int32x2_t v60 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v59), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v10, v59)));
      int32x2_t v61 = (int32x2_t)vshl_u32((uint32x2_t)v60, (uint32x2_t)0x1800000010);
      float v80 = CA::HalfFloat::to_float((CA::HalfFloat *)*v47);
      float v62 = CA::HalfFloat::to_float((CA::HalfFloat *)v47[1]);
      float32x2_t v63 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v62), LODWORD(v80)), _D12), (int8x8_t)_D12, (int8x8_t)__PAIR64__(LODWORD(v62), LODWORD(v80)));
      int32x2_t v64 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v63), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v10, v63)));
      int32x2_t v65 = (int32x2_t)vshl_u32((uint32x2_t)v64, (uint32x2_t)0x1800000010);
      int32x2_t v66 = vzip1_s32(v60, v64);
      int8x16_t v67 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v61, v65), (int8x8_t)vshl_n_s32(v66, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v61, v65), (int8x8_t)v66)), v57), vdupq_n_s16((v39 >> 1) & 0x7F80)), v57);
      *(int16x4_t *)v67.i8 = vadd_s16(*(int16x4_t *)v67.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v67, v67, 8uLL), *(int16x4_t *)v67.i8), vdup_n_s16((v35 >> 1) & 0x7F80)));
      float v6 = v6 + v5;
      v8 += v71;
      v7 += v72;
      *a3++ = vuzp1_s8(*(int8x8_t *)v67.i8, *(int8x8_t *)v67.i8).u32[0];
      int v9 = v70;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v55 = *(void *)(*(void *)a1 + 16);
    uint64_t v56 = **(void **)a1;
    int v5 = a1[15];
    int v6 = a1[13];
    int v51 = a1[14];
    int v52 = a1[16];
    int v53 = *(_DWORD *)(*(void *)a1 + 36);
    int v54 = *(_DWORD *)(*(void *)a1 + 32);
    __asm { FMOV            V8.2S, #1.0 }
    float32x2_t v12 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      int v13 = v54 - 0x8000;
      if (v6 < v54 - 0x8000) {
        int v13 = v6;
      }
      if (v13 <= -32768) {
        int v13 = -32768;
      }
      unsigned int v14 = v13 + 0x8000;
      if (v6 <= 0x8000) {
        int v15 = 0x8000;
      }
      else {
        int v15 = v6;
      }
      int v16 = v15 - 0x8000;
      if (v16 >= v54) {
        int v17 = v54;
      }
      else {
        int v17 = v16;
      }
      int v18 = v53 - 0x8000;
      if (v5 < v53 - 0x8000) {
        int v18 = v5;
      }
      if (v18 <= -32768) {
        int v18 = -32768;
      }
      unsigned int v19 = v18 + 0x8000;
      if (v5 <= 0x8000) {
        int v20 = 0x8000;
      }
      else {
        int v20 = v5;
      }
      int v21 = v20 - 0x8000;
      if (v21 >= v53) {
        int v22 = v53;
      }
      else {
        int v22 = v21;
      }
      uint64_t v23 = v56 + v55 * ((uint64_t)v22 >> 16);
      uint64_t v24 = v56 + v55 * HIWORD(v19);
      unint64_t v25 = ((uint64_t)v17 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v26 = v23 + v25;
      float32x2_t v27 = (unsigned __int16 *)(v24 + v25);
      uint64_t v28 = (v14 >> 14) & 0x3FFFC;
      float32x2_t v29 = (unsigned __int16 *)(v23 + v28);
      int v30 = (unsigned __int16 *)(v24 + v28);
      float v57 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v25));
      float v31 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v26 + 2));
      float32x2_t v32 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v31), LODWORD(v57)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v31), LODWORD(v57)));
      int32x2_t v33 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v32), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v32)));
      int32x2_t v34 = (int32x2_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x1800000010);
      float v58 = CA::HalfFloat::to_float((CA::HalfFloat *)*v29);
      float v35 = CA::HalfFloat::to_float((CA::HalfFloat *)v29[1]);
      float32x2_t v36 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v35), LODWORD(v58)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v35), LODWORD(v58)));
      int32x2_t v37 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v36), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v36)));
      int32x2_t v38 = (int32x2_t)vshl_u32((uint32x2_t)v37, (uint32x2_t)0x1800000010);
      int32x2_t v39 = vzip1_s32(v33, v37);
      uint8x8_t v40 = (uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v34, v38), (int8x8_t)vshl_n_s32(v39, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v34, v38), (int8x8_t)v39));
      float v59 = CA::HalfFloat::to_float((CA::HalfFloat *)*v27);
      float v41 = CA::HalfFloat::to_float((CA::HalfFloat *)v27[1]);
      float32x2_t v42 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v41), LODWORD(v59)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v41), LODWORD(v59)));
      int32x2_t v43 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v42), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v42)));
      int32x2_t v44 = (int32x2_t)vshl_u32((uint32x2_t)v43, (uint32x2_t)0x1800000010);
      float v60 = CA::HalfFloat::to_float((CA::HalfFloat *)*v30);
      float v45 = CA::HalfFloat::to_float((CA::HalfFloat *)v30[1]);
      float32x2_t v46 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v45), LODWORD(v60)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v45), LODWORD(v60)));
      int32x2_t v47 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v46), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v46)));
      int32x2_t v48 = (int32x2_t)vshl_u32((uint32x2_t)v47, (uint32x2_t)0x1800000010);
      int32x2_t v49 = vzip1_s32(v43, v47);
      int8x16_t v50 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v44, v48), (int8x8_t)vshl_n_s32(v49, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v44, v48), (int8x8_t)v49)), v40), vdupq_n_s16((v22 >> 1) & 0x7F80)), v40);
      *(int16x4_t *)v50.i8 = vadd_s16(*(int16x4_t *)v50.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL), *(int16x4_t *)v50.i8), vdup_n_s16((v17 >> 1) & 0x7F80)));
      v6 += v51;
      *a3++ = vuzp1_s8(*(int8x8_t *)v50.i8, *(int8x8_t *)v50.i8).u32[0];
      v5 += v52;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,false,true,false,true>(_DWORD *a1, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v5 = a2;
    int v6 = a1[15];
    int v55 = a1[14];
    int v7 = a1[13];
    int v8 = *(_DWORD *)(*(void *)a1 + 36);
    uint64_t v9 = *(void *)(*(void *)a1 + 16);
    uint64_t v10 = **(void **)a1;
    int v54 = *(_DWORD *)(*(void *)a1 + 32);
    int v11 = v8 - 0x8000;
    if (v6 < v8 - 0x8000) {
      int v11 = a1[15];
    }
    if (v11 <= -32768) {
      int v11 = -32768;
    }
    unsigned int v12 = v11 + 0x8000;
    if (v6 <= 0x8000) {
      int v6 = 0x8000;
    }
    int v13 = v6 - 0x8000;
    if (v13 >= v8) {
      int v13 = *(_DWORD *)(*(void *)a1 + 36);
    }
    uint64_t v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    uint64_t v15 = v10 + v9 * HIWORD(v12);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    int16x4_t v53 = a4;
    __asm { FMOV            V8.2S, #1.0 }
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v5;
      int v22 = v54 - 0x8000;
      if (v7 < v54 - 0x8000) {
        int v22 = v7;
      }
      if (v22 <= -32768) {
        int v22 = -32768;
      }
      unsigned int v23 = v22 + 0x8000;
      if (v7 <= 0x8000) {
        int v24 = 0x8000;
      }
      else {
        int v24 = v7;
      }
      int v25 = v24 - 0x8000;
      if (v25 >= v54) {
        int v26 = v54;
      }
      else {
        int v26 = v25;
      }
      unint64_t v27 = ((uint64_t)v26 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v28 = v14 + v27;
      float32x2_t v29 = (unsigned __int16 *)(v15 + v27);
      uint64_t v30 = (v23 >> 14) & 0x3FFFC;
      float v31 = (unsigned __int16 *)(v14 + v30);
      float32x2_t v32 = (unsigned __int16 *)(v15 + v30);
      float v56 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v14 + v27));
      float v33 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v28 + 2));
      float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v33), LODWORD(v56)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v33), LODWORD(v56)));
      int32x2_t v35 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v34), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v21, v34)));
      int32x2_t v36 = (int32x2_t)vshl_u32((uint32x2_t)v35, (uint32x2_t)0x1800000010);
      float v57 = CA::HalfFloat::to_float((CA::HalfFloat *)*v31);
      float v37 = CA::HalfFloat::to_float((CA::HalfFloat *)v31[1]);
      float32x2_t v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v37), LODWORD(v57)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v37), LODWORD(v57)));
      int32x2_t v39 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v38), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v21, v38)));
      int32x2_t v40 = (int32x2_t)vshl_u32((uint32x2_t)v39, (uint32x2_t)0x1800000010);
      int32x2_t v41 = vzip1_s32(v35, v39);
      uint8x8_t v42 = (uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v36, v40), (int8x8_t)vshl_n_s32(v41, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v36, v40), (int8x8_t)v41));
      float v58 = CA::HalfFloat::to_float((CA::HalfFloat *)*v29);
      float v43 = CA::HalfFloat::to_float((CA::HalfFloat *)v29[1]);
      float32x2_t v44 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v43), LODWORD(v58)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v43), LODWORD(v58)));
      int32x2_t v45 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v44), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v21, v44)));
      int32x2_t v46 = (int32x2_t)vshl_u32((uint32x2_t)v45, (uint32x2_t)0x1800000010);
      float v59 = CA::HalfFloat::to_float((CA::HalfFloat *)*v32);
      float v47 = CA::HalfFloat::to_float((CA::HalfFloat *)v32[1]);
      float32x2_t v48 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v47), LODWORD(v59)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v47), LODWORD(v59)));
      int32x2_t v49 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v48), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v21, v48)));
      int32x2_t v50 = (int32x2_t)vshl_u32((uint32x2_t)v49, (uint32x2_t)0x1800000010);
      int32x2_t v51 = vzip1_s32(v45, v49);
      int8x16_t v52 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v46, v50), (int8x8_t)vshl_n_s32(v51, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v46, v50), (int8x8_t)v51)), v42), v53, 0), v42);
      *(int16x4_t *)v52.i8 = vadd_s16(*(int16x4_t *)v52.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL), *(int16x4_t *)v52.i8), vdup_n_s16((v26 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v52.i8, *(int8x8_t *)v52.i8).u32[0];
      v7 += v55;
    }
    while (v5);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = **(void **)a1;
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    int v43 = a1[14];
    int v44 = a1[16];
    int v7 = a1[13] - 0x8000;
    int v8 = a1[15] - 0x8000;
    __asm { FMOV            V8.2S, #1.0 }
    float32x2_t v14 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      uint64_t v15 = v5 + v6 * ((uint64_t)v8 >> 16);
      uint64_t v16 = v5 + v6 * ((uint64_t)(v8 + 0x10000) >> 16);
      unint64_t v17 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v18 = v15 + v17;
      unsigned int v19 = (unsigned __int16 *)(v16 + v17);
      unint64_t v20 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      float32x2_t v21 = (unsigned __int16 *)(v15 + v20);
      int v22 = (unsigned __int16 *)(v16 + v20);
      float v45 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v17));
      float v23 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v18 + 2));
      float32x2_t v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v23), LODWORD(v45)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v23), LODWORD(v45)));
      int32x2_t v25 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v24), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v24)));
      int32x2_t v26 = (int32x2_t)vshl_u32((uint32x2_t)v25, (uint32x2_t)0x1800000010);
      float v46 = CA::HalfFloat::to_float((CA::HalfFloat *)*v21);
      float v27 = CA::HalfFloat::to_float((CA::HalfFloat *)v21[1]);
      float32x2_t v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v27), LODWORD(v46)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v27), LODWORD(v46)));
      int32x2_t v29 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v28), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v28)));
      int32x2_t v30 = (int32x2_t)vshl_u32((uint32x2_t)v29, (uint32x2_t)0x1800000010);
      int32x2_t v31 = vzip1_s32(v25, v29);
      uint8x8_t v32 = (uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v26, v30), (int8x8_t)vshl_n_s32(v31, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v26, v30), (int8x8_t)v31));
      float v47 = CA::HalfFloat::to_float((CA::HalfFloat *)*v19);
      float v33 = CA::HalfFloat::to_float((CA::HalfFloat *)v19[1]);
      float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v33), LODWORD(v47)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v33), LODWORD(v47)));
      int32x2_t v35 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v34), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v34)));
      int32x2_t v36 = (int32x2_t)vshl_u32((uint32x2_t)v35, (uint32x2_t)0x1800000010);
      float v48 = CA::HalfFloat::to_float((CA::HalfFloat *)*v22);
      float v37 = CA::HalfFloat::to_float((CA::HalfFloat *)v22[1]);
      float32x2_t v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v37), LODWORD(v48)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v37), LODWORD(v48)));
      int32x2_t v39 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v38), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v38)));
      int32x2_t v40 = (int32x2_t)vshl_u32((uint32x2_t)v39, (uint32x2_t)0x1800000010);
      int32x2_t v41 = vzip1_s32(v35, v39);
      int8x16_t v42 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v36, v40), (int8x8_t)vshl_n_s32(v41, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v36, v40), (int8x8_t)v41)), v32), vdupq_n_s16((v8 >> 1) & 0x7F80)), v32);
      *(int16x4_t *)v42.i8 = vadd_s16(*(int16x4_t *)v42.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL), *(int16x4_t *)v42.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v42.i8, *(int8x8_t *)v42.i8).u32[0];
      v7 += v43;
      v8 += v44;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,false,false,false,true>(_DWORD *a1, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v5 = a2;
    int v7 = a1[14];
    unsigned int v6 = a1[15];
    uint64_t v8 = *(void *)(*(void *)a1 + 16);
    uint64_t v9 = **(void **)a1;
    unsigned int v10 = v6 + 0x8000;
    v6 -= 0x8000;
    uint64_t v11 = v9 + v8 * ((uint64_t)(int)v6 >> 16);
    uint64_t v12 = v9 + v8 * ((uint64_t)(int)v10 >> 16);
    a4.i32[0] = (v6 >> 1) & 0x7F80;
    int16x4_t v46 = a4;
    int v13 = a1[13] - 0x8000;
    __asm { FMOV            V8.2S, #1.0 }
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v5;
      unint64_t v20 = ((uint64_t)v13 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v21 = v11 + v20;
      int v22 = (unsigned __int16 *)(v12 + v20);
      unint64_t v23 = ((uint64_t)(v13 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      float32x2_t v24 = (unsigned __int16 *)(v11 + v23);
      int32x2_t v25 = (unsigned __int16 *)(v12 + v23);
      float v47 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v11 + v20));
      float v26 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v21 + 2));
      float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v26), LODWORD(v47)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v26), LODWORD(v47)));
      int32x2_t v28 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v27), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v27)));
      int32x2_t v29 = (int32x2_t)vshl_u32((uint32x2_t)v28, (uint32x2_t)0x1800000010);
      float v48 = CA::HalfFloat::to_float((CA::HalfFloat *)*v24);
      float v30 = CA::HalfFloat::to_float((CA::HalfFloat *)v24[1]);
      float32x2_t v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v30), LODWORD(v48)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v30), LODWORD(v48)));
      int32x2_t v32 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v31), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v31)));
      int32x2_t v33 = (int32x2_t)vshl_u32((uint32x2_t)v32, (uint32x2_t)0x1800000010);
      int32x2_t v34 = vzip1_s32(v28, v32);
      uint8x8_t v35 = (uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v29, v33), (int8x8_t)vshl_n_s32(v34, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v29, v33), (int8x8_t)v34));
      float v49 = CA::HalfFloat::to_float((CA::HalfFloat *)*v22);
      float v36 = CA::HalfFloat::to_float((CA::HalfFloat *)v22[1]);
      float32x2_t v37 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v36), LODWORD(v49)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v36), LODWORD(v49)));
      int32x2_t v38 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v37), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v37)));
      int32x2_t v39 = (int32x2_t)vshl_u32((uint32x2_t)v38, (uint32x2_t)0x1800000010);
      float v50 = CA::HalfFloat::to_float((CA::HalfFloat *)*v25);
      float v40 = CA::HalfFloat::to_float((CA::HalfFloat *)v25[1]);
      float32x2_t v41 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v40), LODWORD(v50)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v40), LODWORD(v50)));
      int32x2_t v42 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v41), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v41)));
      int32x2_t v43 = (int32x2_t)vshl_u32((uint32x2_t)v42, (uint32x2_t)0x1800000010);
      int32x2_t v44 = vzip1_s32(v38, v42);
      int8x16_t v45 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v39, v43), (int8x8_t)vshl_n_s32(v44, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v39, v43), (int8x8_t)v44)), v35), v46, 0), v35);
      *(int16x4_t *)v45.i8 = vadd_s16(*(int16x4_t *)v45.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL), *(int16x4_t *)v45.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v45.i8, *(int8x8_t *)v45.i8).u32[0];
      v13 += v7;
    }
    while (v5);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,true,true,true,false>(uint64_t **a1, int a2, __int32 *a3)
{
  if (a2)
  {
    int v4 = a2;
    unsigned int v6 = (float *)*a1;
    uint64_t v46 = (*a1)[2];
    uint64_t v47 = **a1;
    __int32 v7 = *((_DWORD *)*a1 + 8);
    int v8 = *((_DWORD *)*a1 + 9);
    float v9 = *((float *)a1[3] + 3);
    float v10 = *((float *)a1[2] + 3);
    int v11 = *((_DWORD *)a1 + 15);
    int v12 = *((_DWORD *)a1 + 13);
    int v44 = *((_DWORD *)a1 + 14);
    int v45 = *((_DWORD *)a1 + 16);
    int v13 = *((unsigned __int8 *)a1 + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x437F0000u);
    float32x2_t v43 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      v22.f32[0] = (float)(1.0 / v10) * (float)v12;
      v22.f32[1] = (float)(1.0 / v10) * (float)v11;
      int32x2_t v23 = vcvt_s32_f32(v22);
      switch(v13)
      {
        case 0:
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v23));
          float32x2_t v25 = vmul_f32(v24, v24);
          float32x2_t v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          float32x2_t v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v28 = atan2f(v6[11] * (float)v23.i32[1], v6[10] * (float)v23.i32[0]);
          v29.i32[1] = 1056964608;
          v29.f32[0] = (float)(v28 * -10430.0) + 32768.0;
          float32x2_t v27 = vmul_f32(v29, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v30 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v43, *(float32x2_t *)(v6 + 10)));
          float32x2_t v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v30, vrndm_f32(v30)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v31 = vcvt_f32_s32(v23);
          float32x2_t v32 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v32);
          float32x2_t v34 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v32);
          float32x2_t v35 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v31, v34), (int8x8_t)v34, (int8x8_t)v31);
          float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v33, v35), (int8x8_t)v33, (int8x8_t)v35);
LABEL_8:
          int32x2_t v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      --v4;
      __int32 v36 = v23.i32[0] & ~(v23.i32[0] >> 31);
      if (v36 >= v7) {
        __int32 v36 = v7;
      }
      int v37 = v23.i32[1] & ~(v23.i32[1] >> 31);
      if (v37 >= v8) {
        int v37 = v8;
      }
      int32x2_t v38 = (unsigned __int16 *)(v47 + v46 * ((uint64_t)v37 >> 16) + (((uint64_t)v36 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      float v48 = CA::HalfFloat::to_float((CA::HalfFloat *)*v38);
      float v39 = CA::HalfFloat::to_float((CA::HalfFloat *)v38[1]);
      float32x2_t v40 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v39), LODWORD(v48)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v39), LODWORD(v48)));
      uint32x2_t v41 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v40), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v40)));
      uint32x2_t v42 = vshl_u32(v41, (uint32x2_t)0x1800000010);
      float v10 = v10 + v9;
      v12 += v44;
      v11 += v45;
      *a3++ = v42.i32[0] | (v41.i32[0] << 8) | v41.i32[0] | v42.i32[1];
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,true,true,false,false>(int *a1, int a2, __int32 *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v25 = **(void **)a1;
    uint64_t v5 = *(void *)(*(void *)a1 + 16);
    int v6 = *(_DWORD *)(*(void *)a1 + 32);
    int v7 = *(_DWORD *)(*(void *)a1 + 36);
    int v9 = a1[15];
    int v8 = a1[16];
    int v11 = a1[13];
    int v10 = a1[14];
    __asm { FMOV            V8.2S, #1.0 }
    float32x2_t v17 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      int v18 = v11 & ~(v11 >> 31);
      if (v18 >= v6) {
        int v18 = v6;
      }
      int v19 = v9 & ~(v9 >> 31);
      if (v19 >= v7) {
        int v19 = v7;
      }
      float32x2_t v20 = (unsigned __int16 *)(v25 + v5 * ((uint64_t)v19 >> 16) + (((uint64_t)v18 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      float v26 = CA::HalfFloat::to_float((CA::HalfFloat *)*v20);
      float v21 = CA::HalfFloat::to_float((CA::HalfFloat *)v20[1]);
      float32x2_t v22 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v21), LODWORD(v26)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v21), LODWORD(v26)));
      uint32x2_t v23 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v22), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v17, v22)));
      uint32x2_t v24 = vshl_u32(v23, (uint32x2_t)0x1800000010);
      v11 += v10;
      *a3++ = v24.i32[0] | (v23.i32[0] << 8) | v23.i32[0] | v24.i32[1];
      v9 += v8;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,false,true,false,false>(_DWORD *a1, int a2, __int32 *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v5 = a1[14];
    int v6 = a1[13];
    int v7 = *(_DWORD *)(*(void *)a1 + 32);
    int v8 = a1[15] & ~((int)a1[15] >> 31);
    if (v8 >= *(_DWORD *)(*(void *)a1 + 36)) {
      int v8 = *(_DWORD *)(*(void *)a1 + 36);
    }
    uint64_t v9 = **(void **)a1 + *(void *)(*(void *)a1 + 16) * ((uint64_t)v8 >> 16);
    __asm { FMOV            V8.2S, #1.0 }
    float32x2_t v15 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      int v16 = v6 & ~(v6 >> 31);
      if (v16 >= v7) {
        int v16 = v7;
      }
      float32x2_t v17 = (unsigned __int16 *)(v9 + (((uint64_t)v16 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      float v22 = CA::HalfFloat::to_float((CA::HalfFloat *)*v17);
      float v18 = CA::HalfFloat::to_float((CA::HalfFloat *)v17[1]);
      float32x2_t v19 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v18), LODWORD(v22)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v18), LODWORD(v22)));
      uint32x2_t v20 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v19), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v19)));
      uint32x2_t v21 = vshl_u32(v20, (uint32x2_t)0x1800000010);
      v6 += v5;
      *a3++ = v21.i32[0] | (v20.i32[0] << 8) | v20.i32[0] | v21.i32[1];
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,true,false,false,false>(_DWORD *a1, int a2, __int32 *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = **(void **)a1;
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    int v8 = a1[15];
    int v7 = a1[16];
    int v10 = a1[13];
    int v9 = a1[14];
    __asm { FMOV            V8.2S, #1.0 }
    float32x2_t v16 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      float32x2_t v17 = (unsigned __int16 *)(v5 + v6 * ((uint64_t)v8 >> 16) + (((uint64_t)v10 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      float v22 = CA::HalfFloat::to_float((CA::HalfFloat *)*v17);
      float v18 = CA::HalfFloat::to_float((CA::HalfFloat *)v17[1]);
      float32x2_t v19 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v18), LODWORD(v22)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v18), LODWORD(v22)));
      uint32x2_t v20 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v19), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v19)));
      uint32x2_t v21 = vshl_u32(v20, (uint32x2_t)0x1800000010);
      v10 += v9;
      *a3++ = v21.i32[0] | (v20.i32[0] << 8) | v20.i32[0] | v21.i32[1];
      v8 += v7;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,false,false,false,false>(uint64_t a1, int a2, __int32 *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v6 = *(_DWORD *)(a1 + 52);
    int v5 = *(_DWORD *)(a1 + 56);
    uint64_t v7 = **(void **)a1 + *(void *)(*(void *)a1 + 16) * *(__int16 *)(a1 + 62);
    __asm { FMOV            V8.2S, #1.0 }
    float32x2_t v13 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      float32x2_t v14 = (unsigned __int16 *)(v7 + (((uint64_t)v6 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      float v19 = CA::HalfFloat::to_float((CA::HalfFloat *)*v14);
      float v15 = CA::HalfFloat::to_float((CA::HalfFloat *)v14[1]);
      float32x2_t v16 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v15), LODWORD(v19)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v15), LODWORD(v19)));
      uint32x2_t v17 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v16), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v13, v16)));
      uint32x2_t v18 = vshl_u32(v17, (uint32x2_t)0x1800000010);
      v6 += v5;
      *a3++ = v18.i32[0] | (v17.i32[0] << 8) | v17.i32[0] | v18.i32[1];
    }
    while (v4);
  }
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v65 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v69 = v8;
    int v70 = v12;
    int v67 = v9 - 0x8000;
    int v68 = v8 - 0x8000;
    int v66 = v18;
    do
    {
      v21.f32[0] = (float)(1.0 / v11) * (float)v15;
      v21.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v18)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          float32x2_t v21 = vcvt_f32_u32(*(uint32x2_t *)(v5 + 6));
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, v21);
          goto LABEL_8;
        case 1:
          float32x2_t v27 = result;
          float v28 = v5;
          uint64_t v29 = v6;
          uint64_t v30 = v9;
          uint64_t v31 = v14;
          float v32 = atan2f(v5[11] * (float)v22.i32[1], v5[10] * (float)v22.i32[0]);
          uint64_t v14 = v31;
          int v8 = v69;
          int v12 = v70;
          uint64_t v9 = v30;
          int v18 = v66;
          uint64_t v6 = v29;
          int v5 = v28;
          int v17 = v67;
          int v16 = v68;
          uint64_t result = v27;
          float32x2_t v21 = vcvt_f32_u32(*(uint32x2_t *)(v5 + 6));
          v33.i32[1] = 1056964608;
          v33.f32[0] = (float)(v32 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v33, v21);
          goto LABEL_8;
        case 2:
          float32x2_t v34 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v65, *(float32x2_t *)(v5 + 10)));
          float32x2_t v21 = *(float32x2_t *)((char *)result + 84);
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), v21, vminnm_f32(vsub_f32(v34, vrndm_f32(v34)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v35 = vcvt_f32_s32(v22);
          float32x2_t v36 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v21 = vmul_f32(*(float32x2_t *)((char *)result + 84), v36);
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v36);
          float32x2_t v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v37), (int8x8_t)v37, (int8x8_t)v35);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v21, v38), (int8x8_t)v21, (int8x8_t)v38);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      int v39 = v22.i32[0];
      if (v22.i32[0] >= v16) {
        int v40 = v16;
      }
      else {
        int v40 = v22.i32[0];
      }
      if (v40 <= -32768) {
        int v40 = -32768;
      }
      unsigned int v41 = v40 + 0x8000;
      if (v22.i32[0] <= 0x8000) {
        int v39 = 0x8000;
      }
      int v42 = v39 - 0x8000;
      int v43 = v22.i32[1];
      if (v42 >= v8) {
        int v42 = v8;
      }
      if (v22.i32[1] >= v17) {
        int v44 = v17;
      }
      else {
        int v44 = v22.i32[1];
      }
      if (v44 <= -32768) {
        int v44 = -32768;
      }
      unsigned int v45 = v44 + 0x8000;
      if (v22.i32[1] <= 0x8000) {
        int v43 = 0x8000;
      }
      int v46 = v43 - 0x8000;
      if (v46 >= (int)v9) {
        int v46 = v9;
      }
      uint64_t v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      uint64_t v48 = v6 + v7 * HIWORD(v45);
      unint64_t v49 = ((uint64_t)v42 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      float v50 = (__int16 *)(v47 + v49);
      int32x2_t v51 = (__int16 *)(v48 + v49);
      uint64_t v52 = (v41 >> 14) & 0x3FFFC;
      int16x4_t v53 = (__int16 *)(v47 + v52);
      int v54 = (__int16 *)(v48 + v52);
      v22.i16[0] = v50[1];
      v22.i16[2] = *v53;
      uint32x2_t v55 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v22, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v21.i16[0] = *v50;
      v21.i16[2] = v53[1];
      int32x2_t v56 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v21, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int8x8_t v57 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v56, (uint32x2_t)0x1800000010), (int8x8_t)vshl_u32(v55, (uint32x2_t)0x1000000018));
      v56.i32[1] = v55.i32[1];
      int8x8_t v58 = (int8x8_t)vshl_n_s32(v56, 8uLL);
      int8x8_t v59 = vorr_s8(v57, (int8x8_t)v56);
      uint8x8_t v60 = (uint8x8_t)vorr_s8(v59, v58);
      v59.i16[0] = v51[1];
      v59.i16[2] = *v54;
      v57.i16[0] = *v51;
      uint32x2_t v61 = vshr_n_u32((uint32x2_t)vand_s8(v59, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v57.i16[2] = v54[1];
      int32x2_t v62 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(v57, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int8x8_t v63 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v62, (uint32x2_t)0x1800000010), (int8x8_t)vshl_u32(v61, (uint32x2_t)0x1000000018));
      v62.i32[1] = v61.i32[1];
      int8x16_t v64 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8(v63, (int8x8_t)v62), (int8x8_t)vshl_n_s32(v62, 8uLL)), v60), vdupq_n_s16((v46 >> 1) & 0x7F80)), v60);
      *(int16x4_t *)v64.i8 = vadd_s16(*(int16x4_t *)v64.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v64, v64, 8uLL), *(int16x4_t *)v64.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v64.i8, *(int8x8_t *)v64.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, double a6, int8x8_t a7, int8x8_t a8, int8x8_t a9, int16x8_t a10)
{
  if (a2)
  {
    uint64_t v10 = **(void **)result;
    uint64_t v11 = *(void *)(*(void *)result + 16);
    int v12 = *(_DWORD *)(*(void *)result + 32);
    int v13 = *(_DWORD *)(*(void *)result + 36);
    int v15 = *(_DWORD *)(result + 60);
    int v14 = *(_DWORD *)(result + 64);
    int v17 = *(_DWORD *)(result + 52);
    int v16 = *(_DWORD *)(result + 56);
    uint64_t result = 4294934528;
    do
    {
      if (v17 >= v12 - 0x8000) {
        int v18 = v12 - 0x8000;
      }
      else {
        int v18 = v17;
      }
      if (v18 <= -32768) {
        int v19 = -32768;
      }
      else {
        int v19 = v18;
      }
      if (v17 <= 0x8000) {
        int v20 = 0x8000;
      }
      else {
        int v20 = v17;
      }
      int v21 = v20 - 0x8000;
      if (v21 >= v12) {
        int v21 = v12;
      }
      if (v15 >= v13 - 0x8000) {
        int v22 = v13 - 0x8000;
      }
      else {
        int v22 = v15;
      }
      if (v22 <= -32768) {
        int v22 = -32768;
      }
      unsigned int v23 = v22 + 0x8000;
      if (v15 <= 0x8000) {
        int v24 = 0x8000;
      }
      else {
        int v24 = v15;
      }
      int v25 = v24 - 0x8000;
      if (v25 >= v13) {
        int v25 = v13;
      }
      uint64_t v26 = v10 + v11 * ((uint64_t)v25 >> 16);
      uint64_t v27 = v10 + v11 * HIWORD(v23);
      unint64_t v28 = ((uint64_t)v21 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v29 = (__int16 *)(v26 + v28);
      uint64_t v30 = (unsigned __int16 *)(v27 + v28);
      uint64_t v31 = ((v19 + 0x8000) >> 14) & 0x3FFFC;
      float v32 = (__int16 *)(v27 + v31);
      float32x2_t v33 = (__int16 *)(v26 + v31);
      a7.i16[0] = v29[1];
      a7.i16[2] = *v33;
      a8.i16[0] = *v29;
      a8.i16[2] = v33[1];
      a9.i16[0] = v30[1];
      a9.i16[2] = *v32;
      int32x2_t v34 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      uint32x2_t v35 = vshr_n_u32((uint32x2_t)vand_s8(a9, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a10.i16[0] = *v30;
      uint32x2_t v36 = vshr_n_u32((uint32x2_t)vand_s8(a7, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a10.i16[2] = v32[1];
      int32x2_t v37 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(*(int8x8_t *)a10.i8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int8x8_t v38 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v37, (uint32x2_t)0x1800000010), (int8x8_t)vshl_u32(v35, (uint32x2_t)0x1000000018));
      int8x8_t v39 = (int8x8_t)vshl_u32((uint32x2_t)v34, (uint32x2_t)0x1800000010);
      v34.i32[1] = v36.i32[1];
      v37.i32[1] = v35.i32[1];
      int8x8_t v40 = (int8x8_t)vshl_n_s32(v34, 8uLL);
      int8x8_t v41 = vorr_s8(vorr_s8(v39, (int8x8_t)vshl_u32(v36, (uint32x2_t)0x1000000018)), (int8x8_t)v34);
      uint8x8_t v42 = (uint8x8_t)vorr_s8(vorr_s8(v38, (int8x8_t)v37), (int8x8_t)vshl_n_s32(v37, 8uLL));
      a10 = vdupq_n_s16((v25 >> 1) & 0x7F80);
      uint8x8_t v43 = (uint8x8_t)vorr_s8(v41, v40);
      int8x16_t v44 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v42, v43), a10), v43);
      a9 = (int8x8_t)vdup_n_s16((v21 >> 1) & 0x7F80);
      a8 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL), *(int16x4_t *)v44.i8), (int16x4_t)a9);
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v44.i8, (int16x4_t)a8), (int8x8_t)0xFFFF0000FFFFLL);
      v17 += v16;
      v15 += v14;
      *a3++ = a7.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, double a7, int8x8_t a8, int8x8_t a9, double a10, int8x8_t a11)
{
  if (a2)
  {
    int v11 = result[14];
    int v12 = result[15];
    int v13 = result[13];
    int v14 = *(_DWORD *)(*(void *)result + 32);
    int v15 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v16 = *(void *)(*(void *)result + 16);
    uint64_t v17 = **(void **)result;
    if (v12 >= v15 - 0x8000) {
      int v18 = v15 - 0x8000;
    }
    else {
      int v18 = result[15];
    }
    if (v18 <= -32768) {
      int v18 = -32768;
    }
    if (v12 <= 0x8000) {
      int v12 = 0x8000;
    }
    int v19 = v12 - 0x8000;
    if (v19 >= v15) {
      int v20 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v20 = v19;
    }
    uint64_t v21 = v17 + v16 * ((uint64_t)v20 >> 16);
    uint64_t v22 = v17 + v16 * ((v18 + 0x8000) >> 16);
    a4.i32[0] = (v20 >> 1) & 0x7F80;
    do
    {
      if (v13 >= v14 - 0x8000) {
        int v23 = v14 - 0x8000;
      }
      else {
        int v23 = v13;
      }
      if (v23 <= -32768) {
        int v23 = -32768;
      }
      if (v13 <= 0x8000) {
        int v24 = 0x8000;
      }
      else {
        int v24 = v13;
      }
      unsigned int v25 = v23 + 0x8000;
      int v26 = v24 - 0x8000;
      if (v24 - 0x8000 >= v14) {
        int v26 = v14;
      }
      unint64_t v27 = ((uint64_t)v26 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v28 = (__int16 *)(v21 + v27);
      uint64_t v29 = (__int16 *)(v22 + v27);
      uint64_t v30 = (v25 >> 14) & 0x3FFFC;
      uint64_t v31 = (__int16 *)(v21 + v30);
      uint64_t result = (_DWORD *)(v22 + v30);
      a8.i16[0] = v28[1];
      a8.i16[2] = *v31;
      a9.i16[0] = *v28;
      a9.i16[2] = v31[1];
      uint32x2_t v32 = vshr_n_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int32x2_t v33 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(a9, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int8x8_t v34 = (int8x8_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x1800000010);
      a11.i16[0] = v29[1];
      int8x8_t v35 = (int8x8_t)vshl_u32(v32, (uint32x2_t)0x1000000018);
      a11.i16[2] = *(_WORD *)result;
      int8x8_t v36 = vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL);
      v33.i32[1] = v32.i32[1];
      uint32x2_t v37 = vshr_n_u32((uint32x2_t)v36, 8uLL);
      v36.i16[0] = *v29;
      v36.i16[2] = *((_WORD *)result + 1);
      int8x8_t v38 = vorr_s8(v34, v35);
      int32x2_t v39 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(v36, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int8x8_t v40 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v39, (uint32x2_t)0x1800000010), (int8x8_t)vshl_u32(v37, (uint32x2_t)0x1000000018));
      v39.i32[1] = v37.i32[1];
      int8x8_t v41 = (int8x8_t)vshl_n_s32(v39, 8uLL);
      a11 = vorr_s8(v40, (int8x8_t)v39);
      uint8x8_t v42 = (uint8x8_t)vorr_s8(vorr_s8(v38, (int8x8_t)v33), (int8x8_t)vshl_n_s32(v33, 8uLL));
      int8x16_t v43 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(a11, v41), v42), a4, 0), v42);
      a9 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL), *(int16x4_t *)v43.i8), vdup_n_s16((v26 >> 1) & 0x7F80));
      a8 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v43.i8, (int16x4_t)a9), (int8x8_t)a4);
      v13 += v11;
      *a3++ = a8.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,true,false,false,true>(uint64_t **result, int a2, _DWORD *a3, double a4, double a5, double a6, int8x8_t a7, int8x8_t a8, double a9, double a10, int8x8_t a11)
{
  if (a2)
  {
    uint64_t v11 = **result;
    uint64_t v12 = (*result)[2];
    int v13 = *((_DWORD *)result + 16);
    int v14 = *((_DWORD *)result + 14);
    int v15 = *((_DWORD *)result + 13) - 0x8000;
    int v16 = *((_DWORD *)result + 15) - 0x8000;
    do
    {
      uint64_t v17 = v11 + v12 * ((uint64_t)v16 >> 16);
      uint64_t v18 = v11 + v12 * ((uint64_t)(v16 + 0x10000) >> 16);
      unint64_t v19 = ((uint64_t)v15 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t result = (uint64_t **)(v17 + v19);
      int v20 = (__int16 *)(v18 + v19);
      unint64_t v21 = ((uint64_t)(v15 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v22 = (__int16 *)(v17 + v21);
      int v23 = (__int16 *)(v18 + v21);
      a7.i16[0] = *((_WORD *)result + 1);
      a7.i16[2] = *v22;
      a8.i16[0] = *(_WORD *)result;
      a8.i16[2] = v22[1];
      uint32x2_t v24 = vshr_n_u32((uint32x2_t)vand_s8(a7, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int32x2_t v25 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int8x8_t v26 = (int8x8_t)vshl_u32((uint32x2_t)v25, (uint32x2_t)0x1800000010);
      int8x8_t v27 = (int8x8_t)vshl_u32(v24, (uint32x2_t)0x1000000018);
      a11.i16[0] = v20[1];
      a11.i16[2] = *v23;
      v25.i32[1] = v24.i32[1];
      uint32x2_t v28 = (uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL);
      a11.i16[0] = *v20;
      a11.i16[2] = v23[1];
      int8x8_t v29 = vorr_s8(v26, v27);
      uint32x2_t v30 = vshr_n_u32(v28, 8uLL);
      int32x2_t v31 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a11 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v31, (uint32x2_t)0x1800000010), (int8x8_t)vshl_u32(v30, (uint32x2_t)0x1000000018));
      v31.i32[1] = v30.i32[1];
      uint8x8_t v32 = (uint8x8_t)vorr_s8(vorr_s8(v29, (int8x8_t)v25), (int8x8_t)vshl_n_s32(v25, 8uLL));
      int8x16_t v33 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8(a11, (int8x8_t)v31), (int8x8_t)vshl_n_s32(v31, 8uLL)), v32), vdupq_n_s16((v16 >> 1) & 0x7F80)), v32);
      a8 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL), *(int16x4_t *)v33.i8), vdup_n_s16((v15 >> 1) & 0x7F80));
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v33.i8, (int16x4_t)a8), (int8x8_t)0xFFFF0000FFFFLL);
      *a3++ = a7.i32[0];
      v15 += v14;
      v16 += v13;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, double a7, int8x8_t a8, int8x8_t a9, double a10, int8x8_t a11)
{
  if (a2)
  {
    int v11 = result[14];
    int v12 = result[15];
    uint64_t v13 = *(void *)(*(void *)result + 16);
    uint64_t v14 = **(void **)result;
    int v15 = v12 + 0x8000;
    unsigned int v16 = v12 - 0x8000;
    uint64_t v17 = v14 + v13 * ((uint64_t)(v12 - 0x8000) >> 16);
    uint64_t v18 = v14 + v13 * ((uint64_t)v15 >> 16);
    a4.i32[0] = (v16 >> 1) & 0x7F80;
    int v19 = result[13] - 0x8000;
    do
    {
      unint64_t v20 = ((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v21 = (__int16 *)(v17 + v20);
      uint64_t v22 = (__int16 *)(v18 + v20);
      unint64_t v23 = ((uint64_t)(v19 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint32x2_t v24 = (__int16 *)(v17 + v23);
      int32x2_t v25 = (__int16 *)(v18 + v23);
      a8.i16[0] = v21[1];
      a8.i16[2] = *v24;
      a9.i16[0] = *v21;
      a9.i16[2] = v24[1];
      uint32x2_t v26 = vshr_n_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int32x2_t v27 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(a9, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int8x8_t v28 = (int8x8_t)vshl_u32((uint32x2_t)v27, (uint32x2_t)0x1800000010);
      a11.i16[0] = v22[1];
      int8x8_t v29 = (int8x8_t)vshl_u32(v26, (uint32x2_t)0x1000000018);
      a11.i16[2] = *v25;
      int8x8_t v30 = vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL);
      v27.i32[1] = v26.i32[1];
      uint32x2_t v31 = vshr_n_u32((uint32x2_t)v30, 8uLL);
      v30.i16[0] = *v22;
      v30.i16[2] = v25[1];
      int8x8_t v32 = vorr_s8(v28, v29);
      int32x2_t v33 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(v30, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int8x8_t v34 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x1800000010), (int8x8_t)vshl_u32(v31, (uint32x2_t)0x1000000018));
      v33.i32[1] = v31.i32[1];
      int8x8_t v35 = (int8x8_t)vshl_n_s32(v33, 8uLL);
      a11 = vorr_s8(v34, (int8x8_t)v33);
      uint8x8_t v36 = (uint8x8_t)vorr_s8(vorr_s8(v32, (int8x8_t)v27), (int8x8_t)vshl_n_s32(v27, 8uLL));
      int8x16_t v37 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(a11, v35), v36), a4, 0), v36);
      a9 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL), *(int16x4_t *)v37.i8), vdup_n_s16((v19 >> 1) & 0x7F80));
      a8 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v37.i8, (int16x4_t)a9), (int8x8_t)a4);
      *a3++ = a8.i32[0];
      v19 += v11;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v40 = v13;
    int v38 = v17;
    uint64_t v39 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v38;
          uint64_t v8 = v39;
          int v13 = v40;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      int8x16_t v37 = (unsigned __int16 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = (v37[1] << 16) & 0xFF000000 | (HIBYTE(*v37) << 16) | (HIBYTE(*v37) << 8) | HIBYTE(*v37);
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      int v13 = (unsigned __int16 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      unsigned int v14 = *v13;
      uint64_t result = (int *)(v14 >> 8);
      v10 += v9;
      v8 += v7;
      *a3++ = (v13[1] << 16) & 0xFF000000 | (result << 16) | (result << 8) | (v14 >> 8);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      int v9 = (unsigned __int16 *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v4 += v3;
      *a3++ = (v9[1] << 16) & 0xFF000000 | (HIBYTE(*v9) << 16) | (HIBYTE(*v9) << 8) | HIBYTE(*v9);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      int v9 = (unsigned __int16 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v8 += v7;
      v6 += v5;
      *a3++ = (v9[1] << 16) & 0xFF000000 | (HIBYTE(*v9) << 16) | (HIBYTE(*v9) << 8) | HIBYTE(*v9);
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      int v6 = (unsigned __int16 *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v4 += v3;
      *a3++ = (v6[1] << 16) & 0xFF000000 | (HIBYTE(*v6) << 16) | (HIBYTE(*v6) << 8) | HIBYTE(*v6);
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    uint64_t v8 = *((unsigned int *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    float32x2_t v24 = (float32x2_t)vdup_n_s32(0x437F0000u);
    float32x2_t v64 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v65 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v25 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v70 = v12;
    uint64_t v69 = v6;
    int v67 = v9 - 0x8000;
    int v68 = v8 - 0x8000;
    int v66 = v18;
    do
    {
      v26.f32[0] = (float)(1.0 / v11) * (float)v15;
      v26.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v27 = vcvt_s32_f32(v26);
      switch(v18)
      {
        case 0:
          float32x2_t v28 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v27));
          float32x2_t v29 = vmul_f32(v28, v28);
          float32x2_t v30 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v29, 1), v29);
          v29.f32[0] = fmaxf(vaddv_f32(v29), 0.00001);
          v29.i32[0] = vmul_f32(v30, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v29, 0))).u32[0];
          v29.i32[1] = 0.5;
          float32x2_t v31 = vmul_f32(v29, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float32x2_t v32 = result;
          uint64_t v33 = v8;
          uint64_t v34 = v9;
          uint64_t v35 = v14;
          float v36 = atan2f(v5[11] * (float)v27.i32[1], v5[10] * (float)v27.i32[0]);
          uint64_t v14 = v35;
          int v17 = v67;
          int v16 = v68;
          int v12 = v70;
          uint64_t v9 = v34;
          uint64_t v8 = v33;
          int v18 = v66;
          uint64_t v6 = v69;
          uint64_t result = v32;
          v37.i32[1] = 1056964608;
          v37.f32[0] = (float)(v36 * -10430.0) + 32768.0;
          float32x2_t v31 = vmul_f32(v37, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v38 = vmul_f32(vcvt_f32_s32(v27), vmul_f32(v65, *(float32x2_t *)(v5 + 10)));
          float32x2_t v31 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v38, vrndm_f32(v38)), v64)), vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v39 = vcvt_f32_s32(v27);
          float32x2_t v40 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v41 = vmul_f32(*(float32x2_t *)((char *)result + 84), v40);
          float32x2_t v42 = vmul_f32(*(float32x2_t *)((char *)result + 92), v40);
          float32x2_t v43 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v39, v42), (int8x8_t)v42, (int8x8_t)v39);
          float32x2_t v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v41, v43), (int8x8_t)v41, (int8x8_t)v43);
LABEL_8:
          int32x2_t v27 = vcvt_s32_f32(v31);
          break;
        default:
          break;
      }
      int v44 = v27.i32[0];
      if (v27.i32[0] >= v16) {
        int v45 = v16;
      }
      else {
        int v45 = v27.i32[0];
      }
      if (v45 <= -32768) {
        int v45 = -32768;
      }
      unsigned int v46 = v45 + 0x8000;
      if (v27.i32[0] <= 0x8000) {
        int v44 = 0x8000;
      }
      int v47 = v44 - 0x8000;
      if (v47 >= (int)v8) {
        int v47 = v8;
      }
      int v48 = v27.i32[1];
      if (v27.i32[1] >= v17) {
        int v49 = v17;
      }
      else {
        int v49 = v27.i32[1];
      }
      if (v49 <= -32768) {
        int v49 = -32768;
      }
      unsigned int v50 = v49 + 0x8000;
      if (v27.i32[1] <= 0x8000) {
        int v48 = 0x8000;
      }
      int v51 = v48 - 0x8000;
      if (v51 >= (int)v9) {
        int v51 = v9;
      }
      uint64_t v52 = v6 + v7 * ((uint64_t)v51 >> 16);
      uint64_t v53 = v6 + v7 * HIWORD(v50);
      unint64_t v54 = ((uint64_t)v47 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v55 = (v46 >> 14) & 0x3FFFC;
      v56.i32[0] = *(_DWORD *)(v52 + v54);
      v56.i32[1] = *(_DWORD *)(v52 + v55);
      float32x2_t v57 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v56, _D11), (int8x8_t)_D11, (int8x8_t)v56);
      int8x8_t v58 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v57), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v57)));
      v59.i32[0] = *(_DWORD *)(v53 + v54);
      v59.i32[1] = *(_DWORD *)(v53 + v55);
      float32x2_t v60 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v59, _D11), (int8x8_t)_D11, (int8x8_t)v59);
      int8x8_t v61 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v60), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v60)));
      unint64_t v62 = *(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v58, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v58, (uint32x2_t)0x1000000008)), v58) | 0xFF000000FF000000;
      int8x16_t v63 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v61, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v61, (uint32x2_t)0x1000000008)), v61) | 0xFF000000FF000000), (uint8x8_t)v62), vdupq_n_s16((v51 >> 1) & 0x7F80)), (uint8x8_t)v62);
      *(int16x4_t *)v63.i8 = vadd_s16(*(int16x4_t *)v63.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v63, v63, 8uLL), *(int16x4_t *)v63.i8), vdup_n_s16((v47 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v63.i8, *(int8x8_t *)v63.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = *(_DWORD *)(result + 60);
    int v7 = *(_DWORD *)(result + 64);
    int v10 = *(_DWORD *)(result + 52);
    int v9 = *(_DWORD *)(result + 56);
    uint64_t result = 4294934528;
    float32x2_t v11 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V1.2S, #1.0 }
    do
    {
      if (v10 >= v5 - 0x8000) {
        int v17 = v5 - 0x8000;
      }
      else {
        int v17 = v10;
      }
      if (v17 <= -32768) {
        int v18 = -32768;
      }
      else {
        int v18 = v17;
      }
      if (v10 <= 0x8000) {
        int v19 = 0x8000;
      }
      else {
        int v19 = v10;
      }
      int v20 = v19 - 0x8000;
      if (v20 >= v5) {
        int v20 = v5;
      }
      if (v8 >= v6 - 0x8000) {
        int v21 = v6 - 0x8000;
      }
      else {
        int v21 = v8;
      }
      if (v21 <= -32768) {
        int v21 = -32768;
      }
      if (v8 <= 0x8000) {
        int v22 = 0x8000;
      }
      else {
        int v22 = v8;
      }
      int v23 = v22 - 0x8000;
      unsigned int v24 = v21 + 0x8000;
      if (v23 >= v6) {
        int v23 = v6;
      }
      uint64_t v25 = v3 + v4 * ((uint64_t)v23 >> 16);
      uint64_t v26 = v3 + v4 * HIWORD(v24);
      unint64_t v27 = ((uint64_t)v20 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v28 = ((v18 + 0x8000) >> 14) & 0x3FFFC;
      v29.i32[0] = *(_DWORD *)(v25 + v27);
      v29.i32[1] = *(_DWORD *)(v25 + v28);
      float32x2_t v30 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, _D1), (int8x8_t)_D1, (int8x8_t)v29);
      int8x8_t v31 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v30), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v11, v30)));
      v32.i32[0] = *(_DWORD *)(v26 + v27);
      v32.i32[1] = *(_DWORD *)(v26 + v28);
      float32x2_t v33 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, _D1), (int8x8_t)_D1, (int8x8_t)v32);
      int8x8_t v34 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v33), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v11, v33)));
      unint64_t v35 = *(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v31, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v31, (uint32x2_t)0x1000000008)), v31) | 0xFF000000FF000000;
      int8x16_t v36 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v34, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v34, (uint32x2_t)0x1000000008)), v34) | 0xFF000000FF000000), (uint8x8_t)v35), vdupq_n_s16((v23 >> 1) & 0x7F80)), (uint8x8_t)v35);
      v10 += v9;
      v8 += v7;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v36.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL), *(int16x4_t *)v36.i8), vdup_n_s16((v20 >> 1) & 0x7F80))), (int8x8_t)v11).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    int v6 = result[13];
    int v7 = *(_DWORD *)(*(void *)result + 32);
    int v8 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v9 = *(void *)(*(void *)result + 16);
    uint64_t v10 = **(void **)result;
    if (v5 >= v8 - 0x8000) {
      int v11 = v8 - 0x8000;
    }
    else {
      int v11 = result[15];
    }
    if (v11 <= -32768) {
      int v11 = -32768;
    }
    if (v5 <= 0x8000) {
      int v5 = 0x8000;
    }
    int v12 = v5 - 0x8000;
    if (v12 >= v8) {
      int v13 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v13 = v12;
    }
    uint64_t v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    uint64_t v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    float32x2_t v16 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V2.2S, #1.0 }
    do
    {
      if (v6 >= v7 - 0x8000) {
        int v22 = v7 - 0x8000;
      }
      else {
        int v22 = v6;
      }
      if (v22 <= -32768) {
        int v22 = -32768;
      }
      unsigned int v23 = v22 + 0x8000;
      if (v6 <= 0x8000) {
        int v24 = 0x8000;
      }
      else {
        int v24 = v6;
      }
      int v25 = v24 - 0x8000;
      if (v25 >= v7) {
        int v25 = v7;
      }
      uint64_t result = (_DWORD *)(((uint64_t)v25 >> 14) & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v26 = (v23 >> 14) & 0x3FFFC;
      v27.i32[0] = *(_DWORD *)((char *)result + v14);
      v27.i32[1] = *(_DWORD *)(v14 + v26);
      float32x2_t v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, _D2), (int8x8_t)_D2, (int8x8_t)v27);
      int8x8_t v29 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v28), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v28)));
      v30.i32[0] = *(_DWORD *)((char *)result + v15);
      v30.i32[1] = *(_DWORD *)(v15 + v26);
      float32x2_t v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, _D2), (int8x8_t)_D2, (int8x8_t)v30);
      int8x8_t v32 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v31), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v31)));
      unint64_t v33 = *(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v29, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v29, (uint32x2_t)0x1000000008)), v29) | 0xFF000000FF000000;
      int8x16_t v34 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v32, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v32, (uint32x2_t)0x1000000008)), v32) | 0xFF000000FF000000), (uint8x8_t)v33), a4, 0), (uint8x8_t)v33);
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v34.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL), *(int16x4_t *)v34.i8), vdup_n_s16((v25 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,true,false,false,true>(_DWORD *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = result[16];
    int v6 = result[14];
    int v7 = result[13] - 0x8000;
    int v8 = result[15] - 0x8000;
    float32x2_t v9 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V1.2S, #1.0 }
    do
    {
      uint64_t v15 = v3 + v4 * ((uint64_t)v8 >> 16);
      uint64_t v16 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      unint64_t v17 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v18 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t result = (_DWORD *)(v15 + v18);
      v19.i32[0] = *(_DWORD *)(v15 + v17);
      v19.i32[1] = *(_DWORD *)(v15 + v18);
      float32x2_t v20 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v19, _D1), (int8x8_t)_D1, (int8x8_t)v19);
      int8x8_t v21 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v20), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v9, v20)));
      v22.i32[0] = *(_DWORD *)(v16 + v17);
      v22.i32[1] = *(_DWORD *)(v16 + v18);
      float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, _D1), (int8x8_t)_D1, (int8x8_t)v22);
      int8x8_t v24 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v23), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v9, v23)));
      unint64_t v25 = *(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v21, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v21, (uint32x2_t)0x1000000008)), v21) | 0xFF000000FF000000;
      int8x16_t v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v24, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v24, (uint32x2_t)0x1000000008)), v24) | 0xFF000000FF000000), (uint8x8_t)v25), vdupq_n_s16((v8 >> 1) & 0x7F80)), (uint8x8_t)v25);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v7 >> 1) & 0x7F80))), (int8x8_t)v9).u32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    uint64_t v6 = *(void *)(*(void *)result + 16);
    uint64_t v7 = **(void **)result;
    int v8 = v5 + 0x8000;
    unsigned int v9 = v5 - 0x8000;
    uint64_t v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    uint64_t v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    int v12 = result[13] - 0x8000;
    float32x2_t v13 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V2.2S, #1.0 }
    do
    {
      unint64_t v19 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v20 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21.i32[0] = *(_DWORD *)(v10 + v19);
      v21.i32[1] = *(_DWORD *)(v10 + v20);
      float32x2_t v22 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v21, _D2), (int8x8_t)_D2, (int8x8_t)v21);
      int8x8_t v23 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v22), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v13, v22)));
      v24.i32[0] = *(_DWORD *)(v11 + v19);
      v24.i32[1] = *(_DWORD *)(v11 + v20);
      float32x2_t v25 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, _D2), (int8x8_t)_D2, (int8x8_t)v24);
      int8x8_t v26 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v25), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v13, v25)));
      unint64_t v27 = *(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v23, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v23, (uint32x2_t)0x1000000008)), v23) | 0xFF000000FF000000;
      int8x16_t v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v26, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v26, (uint32x2_t)0x1000000008)), v26) | 0xFF000000FF000000), (uint8x8_t)v27), a4, 0), (uint8x8_t)v27);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v28.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float v18 = 0.5;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v42 = v13;
    int v40 = v17;
    uint64_t v41 = v8;
    do
    {
      v22.f32[0] = (float)(1.0 / v12) * (float)v15;
      v22.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v23 = vcvt_s32_f32(v22);
      switch(v17)
      {
        case 0:
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v23));
          float32x2_t v25 = vmul_f32(v24, v24);
          float32x2_t v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.f32[1] = v18;
          float32x2_t v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v28 = atan2f(v6[11] * (float)v23.i32[1], v6[10] * (float)v23.i32[0]);
          float v18 = 0.5;
          int v17 = v40;
          uint64_t v8 = v41;
          int v13 = v42;
          v29.i32[1] = 1056964608;
          v29.f32[0] = (float)(v28 * -10430.0) + 32768.0;
          float32x2_t v27 = vmul_f32(v29, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v30 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, *(float32x2_t *)(v6 + 10)));
          float32x2_t v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v30, vrndm_f32(v30)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v31 = vcvt_f32_s32(v23);
          float32x2_t v32 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v32);
          float32x2_t v34 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v32);
          float32x2_t v35 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v31, v34), (int8x8_t)v34, (int8x8_t)v31);
          float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v33, v35), (int8x8_t)v33, (int8x8_t)v35);
LABEL_8:
          int32x2_t v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      __int32 v36 = v23.i32[0] & ~(v23.i32[0] >> 31);
      if (v36 >= v10) {
        __int32 v36 = v10;
      }
      int v37 = v23.i32[1] & ~(v23.i32[1] >> 31);
      if (v37 >= v9) {
        int v37 = v9;
      }
      float v38 = *(float *)(v7 + v8 * ((uint64_t)v37 >> 16) + (((uint64_t)v36 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v38 > 1.0) {
        float v38 = 1.0;
      }
      if (v38 >= 0.0) {
        float v39 = v18 + (float)(v38 * 255.0);
      }
      else {
        float v39 = v18;
      }
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = (v39 << 16) | (v39 << 8) | v39 | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      float v13 = *(float *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v13 > 1.0) {
        float v13 = 1.0;
      }
      if (v13 >= 0.0) {
        float v14 = (float)(v13 * 255.0) + 0.5;
      }
      else {
        float v14 = 0.5;
      }
      uint64_t result = (int *)((v14 << 16) | (v14 << 8));
      v10 += v9;
      v8 += v7;
      *a3++ = result | v14 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      float v9 = *(float *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v9 > 1.0) {
        float v9 = 1.0;
      }
      if (v9 >= 0.0) {
        float v10 = (float)(v9 * 255.0) + 0.5;
      }
      else {
        float v10 = 0.5;
      }
      v4 += v3;
      *a3++ = (v10 << 16) | (v10 << 8) | v10 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      float v9 = *(float *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v9 > 1.0) {
        float v9 = 1.0;
      }
      if (v9 >= 0.0) {
        float v10 = (float)(v9 * 255.0) + 0.5;
      }
      else {
        float v10 = 0.5;
      }
      v8 += v7;
      v6 += v5;
      *a3++ = (v10 << 16) | (v10 << 8) | v10 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      float v6 = *(float *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v6 > 1.0) {
        float v6 = 1.0;
      }
      if (v6 >= 0.0) {
        float v7 = (float)(v6 * 255.0) + 0.5;
      }
      else {
        float v7 = 0.5;
      }
      v4 += v3;
      *a3++ = (v7 << 16) | (v7 << 8) | v7 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,true,true,true,true>(uint64_t **a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v62 = (*a1)[2];
    uint64_t v63 = **a1;
    float32x2_t v56 = (float *)*a1;
    float v5 = *((float *)a1[3] + 3);
    float v6 = *((float *)a1[2] + 3);
    int v7 = *((_DWORD *)a1 + 15);
    int v59 = *((_DWORD *)a1 + 16);
    int v60 = *((_DWORD *)*a1 + 9);
    int v8 = *((_DWORD *)a1 + 13);
    int v58 = *((_DWORD *)a1 + 14);
    int v61 = *((_DWORD *)*a1 + 8);
    int v9 = *((unsigned __int8 *)a1 + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    float32x2_t v15 = (float32x2_t)vdup_n_s32(0x437F0000u);
    float32x2_t v53 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v54 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v52 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v57 = v9;
    do
    {
      v16.f32[0] = (float)(1.0 / v6) * (float)v8;
      v16.f32[1] = (float)(1.0 / v6) * (float)v7;
      int32x2_t v17 = vcvt_s32_f32(v16);
      switch(v9)
      {
        case 0:
          float32x2_t v18 = vmul_f32(*(float32x2_t *)(v56 + 10), vcvt_f32_s32(v17));
          float32x2_t v19 = vmul_f32(v18, v18);
          float32x2_t v20 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v19, 1), v19);
          v19.f32[0] = fmaxf(vaddv_f32(v19), 0.00001);
          v19.i32[0] = vmul_f32(v20, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v19, 0))).u32[0];
          v19.i32[1] = 0.5;
          float32x2_t v21 = vmul_f32(v19, vcvt_f32_u32(*(uint32x2_t *)(v56 + 6)));
          goto LABEL_8;
        case 1:
          float v22 = atan2f(v56[11] * (float)v17.i32[1], v56[10] * (float)v17.i32[0]);
          v23.i32[1] = 1056964608;
          v23.f32[0] = (float)(v22 * -10430.0) + 32768.0;
          float32x2_t v21 = vmul_f32(v23, vcvt_f32_u32(*(uint32x2_t *)(v56 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v24 = vmul_f32(vcvt_f32_s32(v17), vmul_f32(v54, *(float32x2_t *)(v56 + 10)));
          float32x2_t v21 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v24, vrndm_f32(v24)), v53)), vmul_f32(v52, vcvt_f32_u32(*(uint32x2_t *)(v56 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v25 = vcvt_f32_s32(v17);
          float32x2_t v26 = vcvt_f32_s32(*(int32x2_t *)(v56 + 8));
          float32x2_t v27 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v26);
          float32x2_t v28 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v26);
          float32x2_t v29 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v25, v28), (int8x8_t)v28, (int8x8_t)v25);
          float32x2_t v21 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v29), (int8x8_t)v27, (int8x8_t)v29);
LABEL_8:
          int32x2_t v17 = vcvt_s32_f32(v21);
          break;
        default:
          break;
      }
      --v4;
      int v30 = v17.i32[0];
      int v31 = v61 - 0x8000;
      if (v17.i32[0] < v61 - 0x8000) {
        int v31 = v17.i32[0];
      }
      if (v31 <= -32768) {
        int v31 = -32768;
      }
      unsigned int v32 = v31 + 0x8000;
      if (v17.i32[0] <= 0x8000) {
        int v30 = 0x8000;
      }
      int v33 = v30 - 0x8000;
      if (v33 >= v61) {
        int v34 = v61;
      }
      else {
        int v34 = v33;
      }
      int v35 = v17.i32[1];
      int v36 = v60 - 0x8000;
      if (v17.i32[1] < v60 - 0x8000) {
        int v36 = v17.i32[1];
      }
      if (v36 <= -32768) {
        int v36 = -32768;
      }
      unsigned int v37 = v36 + 0x8000;
      if (v17.i32[1] <= 0x8000) {
        int v35 = 0x8000;
      }
      int v38 = v35 - 0x8000;
      if (v38 >= v60) {
        int v39 = v60;
      }
      else {
        int v39 = v38;
      }
      uint64_t v40 = v63 + v62 * ((uint64_t)v39 >> 16);
      uint64_t v41 = v63 + v62 * HIWORD(v37);
      unint64_t v42 = ((uint64_t)v34 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v43 = (v32 >> 15) & 0x1FFFE;
      float v64 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v40 + v42));
      float v44 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v40 + v43));
      float32x2_t v45 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v44), LODWORD(v64)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v44), LODWORD(v64)));
      int8x8_t v46 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v45), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v45)));
      int8x8_t v47 = vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v46, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v46, (uint32x2_t)0x1000000008)), v46);
      float v65 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v41 + v42));
      float v48 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v41 + v43));
      float32x2_t v49 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v48), LODWORD(v65)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v48), LODWORD(v65)));
      int8x8_t v50 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v49), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v49)));
      int8x16_t v51 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v50, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v50, (uint32x2_t)0x1000000008)), v50) | 0xFF000000FF000000), (uint8x8_t)(*(void *)&v47 | 0xFF000000FF000000)), vdupq_n_s16((v39 >> 1) & 0x7F80)), (uint8x8_t)(*(void *)&v47 | 0xFF000000FF000000));
      *(int16x4_t *)v51.i8 = vadd_s16(*(int16x4_t *)v51.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v51, v51, 8uLL), *(int16x4_t *)v51.i8), vdup_n_s16((v34 >> 1) & 0x7F80)));
      float v6 = v6 + v5;
      v8 += v58;
      v7 += v59;
      *a3++ = vuzp1_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v51.i8).u32[0];
      int v9 = v57;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v39 = *(void *)(*(void *)a1 + 16);
    uint64_t v40 = **(void **)a1;
    int v5 = a1[15];
    int v6 = a1[13];
    int v35 = a1[14];
    int v36 = a1[16];
    int v37 = *(_DWORD *)(*(void *)a1 + 36);
    int v38 = *(_DWORD *)(*(void *)a1 + 32);
    float32x2_t v7 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V9.2S, #1.0 }
    do
    {
      --v4;
      int v13 = v38 - 0x8000;
      if (v6 < v38 - 0x8000) {
        int v13 = v6;
      }
      if (v13 <= -32768) {
        int v13 = -32768;
      }
      unsigned int v14 = v13 + 0x8000;
      if (v6 <= 0x8000) {
        int v15 = 0x8000;
      }
      else {
        int v15 = v6;
      }
      int v16 = v15 - 0x8000;
      if (v16 >= v38) {
        int v17 = v38;
      }
      else {
        int v17 = v16;
      }
      int v18 = v37 - 0x8000;
      if (v5 < v37 - 0x8000) {
        int v18 = v5;
      }
      if (v18 <= -32768) {
        int v18 = -32768;
      }
      unsigned int v19 = v18 + 0x8000;
      if (v5 <= 0x8000) {
        int v20 = 0x8000;
      }
      else {
        int v20 = v5;
      }
      int v21 = v20 - 0x8000;
      if (v21 >= v37) {
        int v22 = v37;
      }
      else {
        int v22 = v21;
      }
      uint64_t v23 = v40 + v39 * ((uint64_t)v22 >> 16);
      uint64_t v24 = v40 + v39 * HIWORD(v19);
      unint64_t v25 = ((uint64_t)v17 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v26 = (v14 >> 15) & 0x1FFFE;
      float v41 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v25));
      float v27 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v26));
      float32x2_t v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v27), LODWORD(v41)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v27), LODWORD(v41)));
      int8x8_t v29 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v28), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v7, v28)));
      int8x8_t v30 = vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v29, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v29, (uint32x2_t)0x1000000008)), v29);
      float v42 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v24 + v25));
      float v31 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v24 + v26));
      float32x2_t v32 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v31), LODWORD(v42)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v31), LODWORD(v42)));
      int8x8_t v33 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v32), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v7, v32)));
      int8x16_t v34 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x1000000008)), v33) | 0xFF000000FF000000), (uint8x8_t)(*(void *)&v30 | 0xFF000000FF000000)), vdupq_n_s16((v22 >> 1) & 0x7F80)), (uint8x8_t)(*(void *)&v30 | 0xFF000000FF000000));
      *(int16x4_t *)v34.i8 = vadd_s16(*(int16x4_t *)v34.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL), *(int16x4_t *)v34.i8), vdup_n_s16((v17 >> 1) & 0x7F80)));
      v6 += v35;
      *a3++ = vuzp1_s8(*(int8x8_t *)v34.i8, *(int8x8_t *)v34.i8).u32[0];
      v5 += v36;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,false,true,false,true>(_DWORD *a1, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v5 = a2;
    int v6 = a1[15];
    int v39 = a1[14];
    int v7 = a1[13];
    int v9 = *(_DWORD *)(*(void *)a1 + 32);
    int v8 = *(_DWORD *)(*(void *)a1 + 36);
    uint64_t v10 = *(void *)(*(void *)a1 + 16);
    uint64_t v11 = **(void **)a1;
    int v12 = v8 - 0x8000;
    if (v6 < v8 - 0x8000) {
      int v12 = a1[15];
    }
    if (v12 <= -32768) {
      int v12 = -32768;
    }
    unsigned int v13 = v12 + 0x8000;
    if (v6 <= 0x8000) {
      int v6 = 0x8000;
    }
    int v14 = v6 - 0x8000;
    if (v14 >= v8) {
      int v14 = *(_DWORD *)(*(void *)a1 + 36);
    }
    uint64_t v15 = v11 + v10 * ((uint64_t)v14 >> 16);
    uint64_t v16 = v11 + v10 * HIWORD(v13);
    a4.i32[0] = (v14 >> 1) & 0x7F80;
    int16x4_t v38 = a4;
    float32x2_t v17 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V9.2S, #1.0 }
    do
    {
      --v5;
      if (v7 >= v9 - 0x8000) {
        int v23 = v9 - 0x8000;
      }
      else {
        int v23 = v7;
      }
      if (v23 <= -32768) {
        int v23 = -32768;
      }
      unsigned int v24 = v23 + 0x8000;
      if (v7 <= 0x8000) {
        int v25 = 0x8000;
      }
      else {
        int v25 = v7;
      }
      int v26 = v25 - 0x8000;
      if (v26 >= v9) {
        int v27 = v9;
      }
      else {
        int v27 = v26;
      }
      unint64_t v28 = ((uint64_t)v27 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v29 = (v24 >> 15) & 0x1FFFE;
      float v40 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v28));
      float v30 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v29));
      float32x2_t v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v30), LODWORD(v40)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v30), LODWORD(v40)));
      int8x8_t v32 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v31), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v17, v31)));
      int8x8_t v33 = vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v32, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v32, (uint32x2_t)0x1000000008)), v32);
      float v41 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v28));
      float v34 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v29));
      float32x2_t v35 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v34), LODWORD(v41)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v34), LODWORD(v41)));
      int8x8_t v36 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v35), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v17, v35)));
      int8x16_t v37 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v36, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v36, (uint32x2_t)0x1000000008)), v36) | 0xFF000000FF000000), (uint8x8_t)(*(void *)&v33 | 0xFF000000FF000000)), v38, 0), (uint8x8_t)(*(void *)&v33 | 0xFF000000FF000000));
      *(int16x4_t *)v37.i8 = vadd_s16(*(int16x4_t *)v37.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL), *(int16x4_t *)v37.i8), vdup_n_s16((v27 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v37.i8, *(int8x8_t *)v37.i8).u32[0];
      v7 += v39;
    }
    while (v5);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = **(void **)a1;
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    int v27 = a1[14];
    int v28 = a1[16];
    int v7 = a1[13] - 0x8000;
    int v8 = a1[15] - 0x8000;
    float32x2_t v9 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V9.2S, #1.0 }
    do
    {
      --v4;
      uint64_t v15 = v5 + v6 * ((uint64_t)v8 >> 16);
      uint64_t v16 = v5 + v6 * ((uint64_t)(v8 + 0x10000) >> 16);
      unint64_t v17 = ((uint64_t)v7 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v18 = ((uint64_t)(v7 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      float v29 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v17));
      float v19 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v18));
      float32x2_t v20 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v19), LODWORD(v29)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v19), LODWORD(v29)));
      int8x8_t v21 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v20), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v9, v20)));
      int8x8_t v22 = vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v21, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v21, (uint32x2_t)0x1000000008)), v21);
      float v30 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v17));
      float v23 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v18));
      float32x2_t v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v23), LODWORD(v30)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v23), LODWORD(v30)));
      int8x8_t v25 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v24), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v9, v24)));
      int8x16_t v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v25, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v25, (uint32x2_t)0x1000000008)), v25) | 0xFF000000FF000000), (uint8x8_t)(*(void *)&v22 | 0xFF000000FF000000)), vdupq_n_s16((v8 >> 1) & 0x7F80)), (uint8x8_t)(*(void *)&v22 | 0xFF000000FF000000));
      *(int16x4_t *)v26.i8 = vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v26.i8, *(int8x8_t *)v26.i8).u32[0];
      v7 += v27;
      v8 += v28;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,false,false,false,true>(_DWORD *a1, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v5 = a2;
    int v7 = a1[14];
    unsigned int v6 = a1[15];
    uint64_t v8 = *(void *)(*(void *)a1 + 16);
    uint64_t v9 = **(void **)a1;
    unsigned int v10 = v6 + 0x8000;
    v6 -= 0x8000;
    uint64_t v11 = v9 + v8 * ((uint64_t)(int)v6 >> 16);
    uint64_t v12 = v9 + v8 * ((uint64_t)(int)v10 >> 16);
    a4.i32[0] = (v6 >> 1) & 0x7F80;
    int16x4_t v30 = a4;
    int v13 = a1[13] - 0x8000;
    float32x2_t v14 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V9.2S, #1.0 }
    do
    {
      --v5;
      unint64_t v20 = ((uint64_t)v13 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v21 = ((uint64_t)(v13 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      float v31 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v11 + v20));
      float v22 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v11 + v21));
      float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v22), LODWORD(v31)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v22), LODWORD(v31)));
      int8x8_t v24 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v23), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v23)));
      int8x8_t v25 = vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v24, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v24, (uint32x2_t)0x1000000008)), v24);
      float v32 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v12 + v20));
      float v26 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v12 + v21));
      float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v26), LODWORD(v32)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v26), LODWORD(v32)));
      int8x8_t v28 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v27), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v27)));
      int8x16_t v29 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v28, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v28, (uint32x2_t)0x1000000008)), v28) | 0xFF000000FF000000), (uint8x8_t)(*(void *)&v25 | 0xFF000000FF000000)), v30, 0), (uint8x8_t)(*(void *)&v25 | 0xFF000000FF000000));
      *(int16x4_t *)v29.i8 = vadd_s16(*(int16x4_t *)v29.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL), *(int16x4_t *)v29.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v29.i8, *(int8x8_t *)v29.i8).u32[0];
      v13 += v7;
    }
    while (v5);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v5 = (float *)*a1;
    uint64_t v38 = (*a1)[2];
    uint64_t v39 = **a1;
    __int32 v6 = *((_DWORD *)*a1 + 8);
    int v7 = *((_DWORD *)*a1 + 9);
    float v8 = *((float *)a1[3] + 3);
    float v9 = *((float *)a1[2] + 3);
    int v10 = *((_DWORD *)a1 + 15);
    int v11 = *((_DWORD *)a1 + 16);
    int v12 = *((_DWORD *)a1 + 13);
    int v13 = *((_DWORD *)a1 + 14);
    int v14 = *((unsigned __int8 *)a1 + 48) - 1;
    float v15 = 0.5;
    float32x2_t v16 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v17 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      v19.f32[0] = (float)(1.0 / v9) * (float)v12;
      v19.f32[1] = (float)(1.0 / v9) * (float)v10;
      int32x2_t v20 = vcvt_s32_f32(v19);
      switch(v14)
      {
        case 0:
          float32x2_t v21 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v20));
          float32x2_t v22 = vmul_f32(v21, v21);
          float32x2_t v23 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v22, 1), v22);
          v22.f32[0] = fmaxf(vaddv_f32(v22), 0.00001);
          v22.i32[0] = vmul_f32(v23, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v22, 0))).u32[0];
          v22.f32[1] = v15;
          float32x2_t v24 = vmul_f32(v22, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float v25 = atan2f(v5[11] * (float)v20.i32[1], v5[10] * (float)v20.i32[0]);
          v26.i32[1] = 1056964608;
          v26.f32[0] = (float)(v25 * -10430.0) + 32768.0;
          float32x2_t v24 = vmul_f32(v26, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v27 = vmul_f32(vcvt_f32_s32(v20), vmul_f32(v16, *(float32x2_t *)(v5 + 10)));
          float32x2_t v24 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v27, vrndm_f32(v27)), v17)), vmul_f32(v18, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v28 = vcvt_f32_s32(v20);
          float32x2_t v29 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v30 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v29);
          float32x2_t v31 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v29);
          float32x2_t v32 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v28, v31), (int8x8_t)v31, (int8x8_t)v28);
          float32x2_t v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v32), (int8x8_t)v30, (int8x8_t)v32);
LABEL_8:
          int32x2_t v20 = vcvt_s32_f32(v24);
          break;
        default:
          break;
      }
      --v4;
      __int32 v33 = v20.i32[0] & ~(v20.i32[0] >> 31);
      if (v33 >= v6) {
        __int32 v33 = v6;
      }
      int v34 = v20.i32[1] & ~(v20.i32[1] >> 31);
      if (v34 >= v7) {
        int v34 = v7;
      }
      float v35 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v39
                                                                         + v38 * ((uint64_t)v34 >> 16)
                                                                         + (((uint64_t)v33 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v35 > 1.0) {
        float v35 = 1.0;
      }
      float v15 = 0.5;
      if (v35 >= 0.0) {
        float v36 = (float)(v35 * 255.0) + 0.5;
      }
      else {
        float v36 = 0.5;
      }
      float v9 = v9 + v8;
      v12 += v13;
      v10 += v11;
      *a3++ = (v36 << 16) | (v36 << 8) | v36 | 0xFF000000;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,true,true,false,false>(int *a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = **(void **)a1;
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    int v7 = *(_DWORD *)(*(void *)a1 + 32);
    int v8 = *(_DWORD *)(*(void *)a1 + 36);
    int v10 = a1[15];
    int v9 = a1[16];
    int v12 = a1[13];
    int v11 = a1[14];
    do
    {
      --v4;
      int v13 = v12 & ~(v12 >> 31);
      if (v13 >= v7) {
        int v13 = v7;
      }
      int v14 = v10 & ~(v10 >> 31);
      if (v14 >= v8) {
        int v14 = v8;
      }
      float v15 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v5
                                                                         + v6 * ((uint64_t)v14 >> 16)
                                                                         + (((uint64_t)v13 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v15 > 1.0) {
        float v15 = 1.0;
      }
      if (v15 >= 0.0) {
        float v16 = (float)(v15 * 255.0) + 0.5;
      }
      else {
        float v16 = 0.5;
      }
      v12 += v11;
      v10 += v9;
      *a3++ = (v16 << 16) | (v16 << 8) | v16 | 0xFF000000;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,false,true,false,false>(_DWORD *a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v5 = a1[14];
    int v6 = a1[13];
    int v7 = *(_DWORD *)(*(void *)a1 + 32);
    int v8 = a1[15] & ~((int)a1[15] >> 31);
    if (v8 >= *(_DWORD *)(*(void *)a1 + 36)) {
      int v8 = *(_DWORD *)(*(void *)a1 + 36);
    }
    uint64_t v9 = **(void **)a1 + *(void *)(*(void *)a1 + 16) * ((uint64_t)v8 >> 16);
    do
    {
      --v4;
      int v10 = v6 & ~(v6 >> 31);
      if (v10 >= v7) {
        int v10 = v7;
      }
      float v11 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v9
                                                                         + (((uint64_t)v10 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v11 > 1.0) {
        float v11 = 1.0;
      }
      if (v11 >= 0.0) {
        float v12 = (float)(v11 * 255.0) + 0.5;
      }
      else {
        float v12 = 0.5;
      }
      v6 += v5;
      *a3++ = (v12 << 16) | (v12 << 8) | v12 | 0xFF000000;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,true,false,false,false>(_DWORD *a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = **(void **)a1;
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    int v8 = a1[15];
    int v7 = a1[16];
    int v10 = a1[13];
    int v9 = a1[14];
    do
    {
      --v4;
      float v11 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v5
                                                                         + v6 * ((uint64_t)v8 >> 16)
                                                                         + (((uint64_t)v10 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v11 > 1.0) {
        float v11 = 1.0;
      }
      if (v11 >= 0.0) {
        float v12 = (float)(v11 * 255.0) + 0.5;
      }
      else {
        float v12 = 0.5;
      }
      v10 += v9;
      v8 += v7;
      *a3++ = (v12 << 16) | (v12 << 8) | v12 | 0xFF000000;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,false,false,false,false>(uint64_t a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v6 = *(_DWORD *)(a1 + 52);
    int v5 = *(_DWORD *)(a1 + 56);
    uint64_t v7 = **(void **)a1 + *(void *)(*(void *)a1 + 16) * *(__int16 *)(a1 + 62);
    do
    {
      --v4;
      float v8 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v7
                                                                        + (((uint64_t)v6 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v8 > 1.0) {
        float v8 = 1.0;
      }
      if (v8 >= 0.0) {
        float v9 = (float)(v8 * 255.0) + 0.5;
      }
      else {
        float v9 = 0.5;
      }
      v6 += v5;
      *a3++ = (v9 << 16) | (v9 << 8) | v9 | 0xFF000000;
    }
    while (v4);
  }
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    uint64_t v8 = *((unsigned int *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    float32x2_t v24 = (float32x2_t)vdup_n_s32(0x437F0000u);
    float32x2_t v25 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v26 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v27 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v72 = v12;
    uint64_t v71 = v6;
    int v69 = v9 - 0x8000;
    int v70 = v8 - 0x8000;
    int v68 = v18;
    do
    {
      v28.f32[0] = (float)(1.0 / v11) * (float)v15;
      v28.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v29 = vcvt_s32_f32(v28);
      switch(v18)
      {
        case 0:
          float32x2_t v30 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v29));
          float32x2_t v31 = vmul_f32(v30, v30);
          float32x2_t v32 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v31, 1), v31);
          v31.f32[0] = fmaxf(vaddv_f32(v31), 0.00001);
          v31.i32[0] = vmul_f32(v32, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v31, 0))).u32[0];
          v31.i32[1] = 0.5;
          float32x2_t v33 = vmul_f32(v31, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          int v34 = result;
          uint64_t v35 = v8;
          uint64_t v36 = v9;
          uint64_t v37 = v14;
          float v38 = atan2f(v5[11] * (float)v29.i32[1], v5[10] * (float)v29.i32[0]);
          uint64_t v14 = v37;
          int v17 = v69;
          int v16 = v70;
          int v12 = v72;
          uint64_t v9 = v36;
          uint64_t v8 = v35;
          int v18 = v68;
          uint64_t v6 = v71;
          uint64_t result = v34;
          v39.i32[1] = 1056964608;
          v39.f32[0] = (float)(v38 * -10430.0) + 32768.0;
          float32x2_t v33 = vmul_f32(v39, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v40 = vmul_f32(vcvt_f32_s32(v29), vmul_f32(v25, *(float32x2_t *)(v5 + 10)));
          float32x2_t v33 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v40, vrndm_f32(v40)), v26)), vmul_f32(v27, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v41 = vcvt_f32_s32(v29);
          float32x2_t v42 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v43 = vmul_f32(*(float32x2_t *)((char *)result + 84), v42);
          float32x2_t v44 = vmul_f32(*(float32x2_t *)((char *)result + 92), v42);
          float32x2_t v45 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v41, v44), (int8x8_t)v44, (int8x8_t)v41);
          float32x2_t v33 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v43, v45), (int8x8_t)v43, (int8x8_t)v45);
LABEL_8:
          int32x2_t v29 = vcvt_s32_f32(v33);
          break;
        default:
          break;
      }
      int v46 = v29.i32[0];
      if (v29.i32[0] >= v16) {
        int v47 = v16;
      }
      else {
        int v47 = v29.i32[0];
      }
      if (v47 <= -32768) {
        int v47 = -32768;
      }
      unsigned int v48 = v47 + 0x8000;
      if (v29.i32[0] <= 0x8000) {
        int v46 = 0x8000;
      }
      int v49 = v46 - 0x8000;
      if (v49 >= (int)v8) {
        int v49 = v8;
      }
      int v50 = v29.i32[1];
      if (v29.i32[1] >= v17) {
        int v51 = v17;
      }
      else {
        int v51 = v29.i32[1];
      }
      if (v51 <= -32768) {
        int v51 = -32768;
      }
      unsigned int v52 = v51 + 0x8000;
      if (v29.i32[1] <= 0x8000) {
        int v50 = 0x8000;
      }
      int v53 = v50 - 0x8000;
      if (v53 >= (int)v9) {
        int v53 = v9;
      }
      uint64_t v54 = v6 + v7 * ((uint64_t)v53 >> 16);
      uint64_t v55 = v6 + v7 * HIWORD(v52);
      unint64_t v56 = ((uint64_t)v49 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v57 = (v48 >> 14) & 0x3FFFC;
      v58.i32[0] = *(_DWORD *)(v54 + v56);
      v58.i32[1] = *(_DWORD *)(v54 + v57);
      float32x2_t v59 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v58, _D11), (int8x8_t)_D11, (int8x8_t)v58);
      int32x2_t v60 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v59), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v59)));
      int32x2_t v61 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v60, 8uLL), (int8x8_t)v60);
      uint8x8_t v62 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v61, 0x10uLL), (int8x8_t)v61);
      v63.i32[0] = *(_DWORD *)(v55 + v56);
      v63.i32[1] = *(_DWORD *)(v55 + v57);
      float32x2_t v64 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v63, _D11), (int8x8_t)_D11, (int8x8_t)v63);
      int32x2_t v65 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v64), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v64)));
      int32x2_t v66 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v65, 8uLL), (int8x8_t)v65);
      int8x16_t v67 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v66, 0x10uLL), (int8x8_t)v66), v62), vdupq_n_s16((v53 >> 1) & 0x7F80)), v62);
      *(int16x4_t *)v67.i8 = vadd_s16(*(int16x4_t *)v67.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v67, v67, 8uLL), *(int16x4_t *)v67.i8), vdup_n_s16((v49 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v67.i8, *(int8x8_t *)v67.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = *(_DWORD *)(result + 60);
    int v7 = *(_DWORD *)(result + 64);
    int v10 = *(_DWORD *)(result + 52);
    int v9 = *(_DWORD *)(result + 56);
    uint64_t result = 4294934528;
    __asm { FMOV            V0.2S, #1.0 }
    float32x2_t v16 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      if (v10 >= v5 - 0x8000) {
        int v17 = v5 - 0x8000;
      }
      else {
        int v17 = v10;
      }
      if (v17 <= -32768) {
        int v17 = -32768;
      }
      unsigned int v18 = v17 + 0x8000;
      if (v10 <= 0x8000) {
        int v19 = 0x8000;
      }
      else {
        int v19 = v10;
      }
      int v20 = v19 - 0x8000;
      if (v20 >= v5) {
        int v20 = v5;
      }
      if (v8 >= v6 - 0x8000) {
        int v21 = v6 - 0x8000;
      }
      else {
        int v21 = v8;
      }
      if (v21 <= -32768) {
        int v21 = -32768;
      }
      unsigned int v22 = v21 + 0x8000;
      if (v8 <= 0x8000) {
        int v23 = 0x8000;
      }
      else {
        int v23 = v8;
      }
      int v24 = v23 - 0x8000;
      if (v24 >= v6) {
        int v24 = v6;
      }
      uint64_t v25 = v3 + v4 * ((uint64_t)v24 >> 16);
      uint64_t v26 = v3 + v4 * HIWORD(v22);
      uint64_t v27 = (v18 >> 14) & 0x3FFFC;
      unint64_t v28 = ((uint64_t)v20 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v29.i32[0] = *(_DWORD *)(v25 + v28);
      v29.i32[1] = *(_DWORD *)(v25 + v27);
      float32x2_t v30 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, _D0), (int8x8_t)_D0, (int8x8_t)v29);
      int32x2_t v31 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v30), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v30)));
      v32.i32[0] = *(_DWORD *)(v26 + v28);
      v32.i32[1] = *(_DWORD *)(v26 + v27);
      float32x2_t v33 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, _D0), (int8x8_t)_D0, (int8x8_t)v32);
      int32x2_t v34 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v31, 8uLL), (int8x8_t)v31);
      int32x2_t v35 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v33), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v33)));
      int32x2_t v36 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v35, 8uLL), (int8x8_t)v35);
      uint8x8_t v37 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v34, 0x10uLL), (int8x8_t)v34);
      int8x16_t v38 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v36, 0x10uLL), (int8x8_t)v36), v37), vdupq_n_s16((v24 >> 1) & 0x7F80)), v37);
      v10 += v9;
      v8 += v7;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v38.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL), *(int16x4_t *)v38.i8), vdup_n_s16((v20 >> 1) & 0x7F80))), (int8x8_t)_D0).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    int v6 = result[13];
    int v7 = *(_DWORD *)(*(void *)result + 32);
    int v8 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v9 = *(void *)(*(void *)result + 16);
    uint64_t v10 = **(void **)result;
    if (v5 >= v8 - 0x8000) {
      int v11 = v8 - 0x8000;
    }
    else {
      int v11 = result[15];
    }
    if (v11 <= -32768) {
      int v11 = -32768;
    }
    if (v5 <= 0x8000) {
      int v5 = 0x8000;
    }
    int v12 = v5 - 0x8000;
    if (v12 >= v8) {
      int v13 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v13 = v12;
    }
    uint64_t v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    uint64_t v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    __asm { FMOV            V1.2S, #1.0 }
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      if (v6 >= v7 - 0x8000) {
        int v22 = v7 - 0x8000;
      }
      else {
        int v22 = v6;
      }
      if (v22 <= -32768) {
        int v22 = -32768;
      }
      unsigned int v23 = v22 + 0x8000;
      if (v6 <= 0x8000) {
        int v24 = 0x8000;
      }
      else {
        int v24 = v6;
      }
      int v25 = v24 - 0x8000;
      if (v25 >= v7) {
        int v25 = v7;
      }
      uint64_t v26 = (v23 >> 14) & 0x3FFFC;
      uint64_t result = (_DWORD *)(((uint64_t)v25 >> 14) & 0xFFFFFFFFFFFFFFFCLL);
      v27.i32[0] = *(_DWORD *)((char *)result + v14);
      v27.i32[1] = *(_DWORD *)(v14 + v26);
      float32x2_t v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, _D1), (int8x8_t)_D1, (int8x8_t)v27);
      int32x2_t v29 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v28), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v21, v28)));
      v30.i32[0] = *(_DWORD *)((char *)result + v15);
      v30.i32[1] = *(_DWORD *)(v15 + v26);
      int32x2_t v31 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v29, 8uLL), (int8x8_t)v29);
      float32x2_t v32 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, _D1), (int8x8_t)_D1, (int8x8_t)v30);
      int32x2_t v33 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v32), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v21, v32)));
      int32x2_t v34 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v33, 8uLL), (int8x8_t)v33);
      uint8x8_t v35 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v31, 0x10uLL), (int8x8_t)v31);
      int8x16_t v36 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v34, 0x10uLL), (int8x8_t)v34), v35), a4, 0), v35);
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v36.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL), *(int16x4_t *)v36.i8), vdup_n_s16((v25 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,true,false,false,true>(_DWORD *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = result[16];
    int v6 = result[14];
    int v7 = result[13] - 0x8000;
    int v8 = result[15] - 0x8000;
    __asm { FMOV            V0.2S, #1.0 }
    float32x2_t v14 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      uint64_t v15 = v3 + v4 * ((uint64_t)v8 >> 16);
      uint64_t v16 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      unint64_t v17 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v18 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t result = (_DWORD *)(v15 + v17);
      v19.i32[0] = *(_DWORD *)(v15 + v18);
      v19.i32[1] = *(_DWORD *)(v15 + v17);
      float32x2_t v20 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v19, _D0), (int8x8_t)_D0, (int8x8_t)v19);
      int32x2_t v21 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v20), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v20)));
      v22.i32[0] = *(_DWORD *)(v16 + v18);
      v22.i32[1] = *(_DWORD *)(v16 + v17);
      int32x2_t v23 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v21, 8uLL), (int8x8_t)v21);
      float32x2_t v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, _D0), (int8x8_t)_D0, (int8x8_t)v22);
      int32x2_t v25 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v24), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v24)));
      int32x2_t v26 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v25, 8uLL), (int8x8_t)v25);
      uint8x8_t v27 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v23, 0x10uLL), (int8x8_t)v23);
      int8x16_t v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v26, 0x10uLL), (int8x8_t)v26), v27), vdupq_n_s16((v8 >> 1) & 0x7F80)), v27);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v28.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), vdup_n_s16((v7 >> 1) & 0x7F80))), (int8x8_t)_D0).u32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    uint64_t v6 = *(void *)(*(void *)result + 16);
    uint64_t v7 = **(void **)result;
    int v8 = v5 + 0x8000;
    unsigned int v9 = v5 - 0x8000;
    uint64_t v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    uint64_t v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    int v12 = result[13] - 0x8000;
    __asm { FMOV            V1.2S, #1.0 }
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      unint64_t v19 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v20 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21.i32[0] = *(_DWORD *)(v10 + v19);
      v21.i32[1] = *(_DWORD *)(v10 + v20);
      float32x2_t v22 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v21, _D1), (int8x8_t)_D1, (int8x8_t)v21);
      int32x2_t v23 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v22), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v18, v22)));
      v24.i32[0] = *(_DWORD *)(v11 + v19);
      v24.i32[1] = *(_DWORD *)(v11 + v20);
      int32x2_t v25 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v23, 8uLL), (int8x8_t)v23);
      float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, _D1), (int8x8_t)_D1, (int8x8_t)v24);
      int32x2_t v27 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v26), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v18, v26)));
      int32x2_t v28 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v27, 8uLL), (int8x8_t)v27);
      uint8x8_t v29 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v25, 0x10uLL), (int8x8_t)v25);
      int8x16_t v30 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v28, 0x10uLL), (int8x8_t)v28), v29), a4, 0), v29);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v30.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL), *(int16x4_t *)v30.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float v18 = 0.5;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v42 = v13;
    int v40 = v17;
    uint64_t v41 = v8;
    do
    {
      v22.f32[0] = (float)(1.0 / v12) * (float)v15;
      v22.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v23 = vcvt_s32_f32(v22);
      switch(v17)
      {
        case 0:
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v23));
          float32x2_t v25 = vmul_f32(v24, v24);
          float32x2_t v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.f32[1] = v18;
          float32x2_t v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v28 = atan2f(v6[11] * (float)v23.i32[1], v6[10] * (float)v23.i32[0]);
          float v18 = 0.5;
          int v17 = v40;
          uint64_t v8 = v41;
          int v13 = v42;
          v29.i32[1] = 1056964608;
          v29.f32[0] = (float)(v28 * -10430.0) + 32768.0;
          float32x2_t v27 = vmul_f32(v29, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v30 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, *(float32x2_t *)(v6 + 10)));
          float32x2_t v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v30, vrndm_f32(v30)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v31 = vcvt_f32_s32(v23);
          float32x2_t v32 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v32);
          float32x2_t v34 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v32);
          float32x2_t v35 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v31, v34), (int8x8_t)v34, (int8x8_t)v31);
          float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v33, v35), (int8x8_t)v33, (int8x8_t)v35);
LABEL_8:
          int32x2_t v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      __int32 v36 = v23.i32[0] & ~(v23.i32[0] >> 31);
      if (v36 >= v10) {
        __int32 v36 = v10;
      }
      int v37 = v23.i32[1] & ~(v23.i32[1] >> 31);
      if (v37 >= v9) {
        int v37 = v9;
      }
      float v38 = *(float *)(v7 + v8 * ((uint64_t)v37 >> 16) + (((uint64_t)v36 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v38 > 1.0) {
        float v38 = 1.0;
      }
      if (v38 >= 0.0) {
        float v39 = v18 + (float)(v38 * 255.0);
      }
      else {
        float v39 = v18;
      }
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = v39 | (v39 << 8) | ((v39 | (v39 << 8)) << 16);
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      uint64_t result = (int *)(v3 + v4 * ((uint64_t)v12 >> 16));
      float v13 = *(float *)((char *)result + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v13 > 1.0) {
        float v13 = 1.0;
      }
      if (v13 >= 0.0) {
        float v14 = (float)(v13 * 255.0) + 0.5;
      }
      else {
        float v14 = 0.5;
      }
      v10 += v9;
      v8 += v7;
      *a3++ = v14 | (v14 << 8) | ((v14 | (v14 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      float v9 = *(float *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v9 > 1.0) {
        float v9 = 1.0;
      }
      if (v9 >= 0.0) {
        float v10 = (float)(v9 * 255.0) + 0.5;
      }
      else {
        float v10 = 0.5;
      }
      v4 += v3;
      *a3++ = v10 | (v10 << 8) | ((v10 | (v10 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      float v9 = *(float *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v9 > 1.0) {
        float v9 = 1.0;
      }
      if (v9 >= 0.0) {
        float v10 = (float)(v9 * 255.0) + 0.5;
      }
      else {
        float v10 = 0.5;
      }
      v8 += v7;
      v6 += v5;
      *a3++ = v10 | (v10 << 8) | ((v10 | (v10 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      float v6 = *(float *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v6 > 1.0) {
        float v6 = 1.0;
      }
      if (v6 >= 0.0) {
        float v7 = (float)(v6 * 255.0) + 0.5;
      }
      else {
        float v7 = 0.5;
      }
      v4 += v3;
      *a3++ = v7 | (v7 << 8) | ((v7 | (v7 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,true,true,true,true>(uint64_t **a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v64 = (*a1)[2];
    uint64_t v65 = **a1;
    float32x2_t v58 = (float *)*a1;
    float v5 = *((float *)a1[3] + 3);
    float v6 = *((float *)a1[2] + 3);
    int v7 = *((_DWORD *)a1 + 15);
    int v61 = *((_DWORD *)a1 + 16);
    int v62 = *((_DWORD *)*a1 + 9);
    int v8 = *((_DWORD *)a1 + 13);
    int v60 = *((_DWORD *)a1 + 14);
    int v63 = *((_DWORD *)*a1 + 8);
    int v9 = *((unsigned __int8 *)a1 + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    float32x2_t v15 = (float32x2_t)vdup_n_s32(0x437F0000u);
    float32x2_t v56 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v16 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v17 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v59 = v9;
    do
    {
      v18.f32[0] = (float)(1.0 / v6) * (float)v8;
      v18.f32[1] = (float)(1.0 / v6) * (float)v7;
      int32x2_t v19 = vcvt_s32_f32(v18);
      switch(v9)
      {
        case 0:
          float32x2_t v20 = vmul_f32(*(float32x2_t *)(v58 + 10), vcvt_f32_s32(v19));
          float32x2_t v21 = vmul_f32(v20, v20);
          float32x2_t v22 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 1), v21);
          v21.f32[0] = fmaxf(vaddv_f32(v21), 0.00001);
          v21.i32[0] = vmul_f32(v22, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 0))).u32[0];
          v21.i32[1] = 0.5;
          float32x2_t v23 = vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v58 + 6)));
          goto LABEL_8;
        case 1:
          float v24 = atan2f(v58[11] * (float)v19.i32[1], v58[10] * (float)v19.i32[0]);
          v25.i32[1] = 1056964608;
          v25.f32[0] = (float)(v24 * -10430.0) + 32768.0;
          float32x2_t v23 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v58 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v26 = vmul_f32(vcvt_f32_s32(v19), vmul_f32(v56, *(float32x2_t *)(v58 + 10)));
          float32x2_t v23 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v26, vrndm_f32(v26)), v16)), vmul_f32(v17, vcvt_f32_u32(*(uint32x2_t *)(v58 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v27 = vcvt_f32_s32(v19);
          float32x2_t v28 = vcvt_f32_s32(*(int32x2_t *)(v58 + 8));
          float32x2_t v29 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v28);
          float32x2_t v30 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v28);
          float32x2_t v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v30), (int8x8_t)v30, (int8x8_t)v27);
          float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, v31), (int8x8_t)v29, (int8x8_t)v31);
LABEL_8:
          int32x2_t v19 = vcvt_s32_f32(v23);
          break;
        default:
          break;
      }
      --v4;
      int v32 = v19.i32[0];
      int v33 = v63 - 0x8000;
      if (v19.i32[0] < v63 - 0x8000) {
        int v33 = v19.i32[0];
      }
      if (v33 <= -32768) {
        int v33 = -32768;
      }
      unsigned int v34 = v33 + 0x8000;
      if (v19.i32[0] <= 0x8000) {
        int v32 = 0x8000;
      }
      int v35 = v32 - 0x8000;
      if (v35 >= v63) {
        int v36 = v63;
      }
      else {
        int v36 = v35;
      }
      int v37 = v19.i32[1];
      int v38 = v62 - 0x8000;
      if (v19.i32[1] < v62 - 0x8000) {
        int v38 = v19.i32[1];
      }
      if (v38 <= -32768) {
        int v38 = -32768;
      }
      unsigned int v39 = v38 + 0x8000;
      if (v19.i32[1] <= 0x8000) {
        int v37 = 0x8000;
      }
      int v40 = v37 - 0x8000;
      if (v40 >= v62) {
        int v41 = v62;
      }
      else {
        int v41 = v40;
      }
      uint64_t v42 = v65 + v64 * ((uint64_t)v41 >> 16);
      uint64_t v43 = v65 + v64 * HIWORD(v39);
      unint64_t v44 = ((uint64_t)v36 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v45 = (v34 >> 15) & 0x1FFFE;
      float v66 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v42 + v44));
      float v46 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v42 + v45));
      float32x2_t v47 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v46), LODWORD(v66)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v46), LODWORD(v66)));
      int32x2_t v48 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v47), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v47)));
      int32x2_t v49 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v48, 8uLL), (int8x8_t)v48);
      uint8x8_t v50 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v49, 0x10uLL), (int8x8_t)v49);
      float v67 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v43 + v44));
      float v51 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v43 + v45));
      float32x2_t v52 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v51), LODWORD(v67)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v51), LODWORD(v67)));
      int32x2_t v53 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v52), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v52)));
      int32x2_t v54 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v53, 8uLL), (int8x8_t)v53);
      int8x16_t v55 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v54, 0x10uLL), (int8x8_t)v54), v50), vdupq_n_s16((v41 >> 1) & 0x7F80)), v50);
      *(int16x4_t *)v55.i8 = vadd_s16(*(int16x4_t *)v55.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL), *(int16x4_t *)v55.i8), vdup_n_s16((v36 >> 1) & 0x7F80)));
      float v6 = v6 + v5;
      v8 += v60;
      v7 += v61;
      *a3++ = vuzp1_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v55.i8).u32[0];
      int v9 = v59;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v41 = *(void *)(*(void *)a1 + 16);
    uint64_t v42 = **(void **)a1;
    int v5 = a1[15];
    int v6 = a1[13];
    int v37 = a1[14];
    int v38 = a1[16];
    int v39 = *(_DWORD *)(*(void *)a1 + 36);
    int v40 = *(_DWORD *)(*(void *)a1 + 32);
    __asm { FMOV            V8.2S, #1.0 }
    float32x2_t v12 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      int v13 = v40 - 0x8000;
      if (v6 < v40 - 0x8000) {
        int v13 = v6;
      }
      if (v13 <= -32768) {
        int v13 = -32768;
      }
      unsigned int v14 = v13 + 0x8000;
      if (v6 <= 0x8000) {
        int v15 = 0x8000;
      }
      else {
        int v15 = v6;
      }
      int v16 = v15 - 0x8000;
      if (v16 >= v40) {
        int v17 = v40;
      }
      else {
        int v17 = v16;
      }
      int v18 = v39 - 0x8000;
      if (v5 < v39 - 0x8000) {
        int v18 = v5;
      }
      if (v18 <= -32768) {
        int v18 = -32768;
      }
      unsigned int v19 = v18 + 0x8000;
      if (v5 <= 0x8000) {
        int v20 = 0x8000;
      }
      else {
        int v20 = v5;
      }
      int v21 = v20 - 0x8000;
      if (v21 >= v39) {
        int v22 = v39;
      }
      else {
        int v22 = v21;
      }
      uint64_t v23 = v42 + v41 * ((uint64_t)v22 >> 16);
      uint64_t v24 = v42 + v41 * HIWORD(v19);
      unint64_t v25 = ((uint64_t)v17 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v26 = (v14 >> 15) & 0x1FFFE;
      float v43 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v25));
      float v27 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v26));
      float32x2_t v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v27), LODWORD(v43)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v27), LODWORD(v43)));
      int32x2_t v29 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v28), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v28)));
      int32x2_t v30 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v29, 8uLL), (int8x8_t)v29);
      uint8x8_t v31 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v30, 0x10uLL), (int8x8_t)v30);
      float v44 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v24 + v25));
      float v32 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v24 + v26));
      float32x2_t v33 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v32), LODWORD(v44)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v32), LODWORD(v44)));
      int32x2_t v34 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v33), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v33)));
      int32x2_t v35 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v34, 8uLL), (int8x8_t)v34);
      int8x16_t v36 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v35, 0x10uLL), (int8x8_t)v35), v31), vdupq_n_s16((v22 >> 1) & 0x7F80)), v31);
      *(int16x4_t *)v36.i8 = vadd_s16(*(int16x4_t *)v36.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL), *(int16x4_t *)v36.i8), vdup_n_s16((v17 >> 1) & 0x7F80)));
      v6 += v37;
      *a3++ = vuzp1_s8(*(int8x8_t *)v36.i8, *(int8x8_t *)v36.i8).u32[0];
      v5 += v38;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,false,true,false,true>(_DWORD *a1, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v5 = a2;
    int v6 = a1[15];
    int v41 = a1[14];
    int v7 = a1[13];
    int v9 = *(_DWORD *)(*(void *)a1 + 32);
    int v8 = *(_DWORD *)(*(void *)a1 + 36);
    uint64_t v10 = *(void *)(*(void *)a1 + 16);
    uint64_t v11 = **(void **)a1;
    int v12 = v8 - 0x8000;
    if (v6 < v8 - 0x8000) {
      int v12 = a1[15];
    }
    if (v12 <= -32768) {
      int v12 = -32768;
    }
    unsigned int v13 = v12 + 0x8000;
    if (v6 <= 0x8000) {
      int v6 = 0x8000;
    }
    int v14 = v6 - 0x8000;
    if (v14 >= v8) {
      int v14 = *(_DWORD *)(*(void *)a1 + 36);
    }
    uint64_t v15 = v11 + v10 * ((uint64_t)v14 >> 16);
    uint64_t v16 = v11 + v10 * HIWORD(v13);
    a4.i32[0] = (v14 >> 1) & 0x7F80;
    int16x4_t v40 = a4;
    __asm { FMOV            V8.2S, #1.0 }
    float32x2_t v22 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v5;
      if (v7 >= v9 - 0x8000) {
        int v23 = v9 - 0x8000;
      }
      else {
        int v23 = v7;
      }
      if (v23 <= -32768) {
        int v23 = -32768;
      }
      unsigned int v24 = v23 + 0x8000;
      if (v7 <= 0x8000) {
        int v25 = 0x8000;
      }
      else {
        int v25 = v7;
      }
      int v26 = v25 - 0x8000;
      if (v26 >= v9) {
        int v27 = v9;
      }
      else {
        int v27 = v26;
      }
      unint64_t v28 = ((uint64_t)v27 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v29 = (v24 >> 15) & 0x1FFFE;
      float v42 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v28));
      float v30 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v29));
      float32x2_t v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v30), LODWORD(v42)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v30), LODWORD(v42)));
      int32x2_t v32 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v31), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v22, v31)));
      int32x2_t v33 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v32, 8uLL), (int8x8_t)v32);
      uint8x8_t v34 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v33, 0x10uLL), (int8x8_t)v33);
      float v43 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v28));
      float v35 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v29));
      float32x2_t v36 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v35), LODWORD(v43)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v35), LODWORD(v43)));
      int32x2_t v37 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v36), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v22, v36)));
      int32x2_t v38 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v37, 8uLL), (int8x8_t)v37);
      int8x16_t v39 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v38, 0x10uLL), (int8x8_t)v38), v34), v40, 0), v34);
      *(int16x4_t *)v39.i8 = vadd_s16(*(int16x4_t *)v39.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL), *(int16x4_t *)v39.i8), vdup_n_s16((v27 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v39.i8, *(int8x8_t *)v39.i8).u32[0];
      v7 += v41;
    }
    while (v5);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = **(void **)a1;
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    int v29 = a1[14];
    int v30 = a1[16];
    int v7 = a1[13] - 0x8000;
    int v8 = a1[15] - 0x8000;
    __asm { FMOV            V8.2S, #1.0 }
    float32x2_t v14 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      uint64_t v15 = v5 + v6 * ((uint64_t)v8 >> 16);
      uint64_t v16 = v5 + v6 * ((uint64_t)(v8 + 0x10000) >> 16);
      unint64_t v17 = ((uint64_t)v7 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v18 = ((uint64_t)(v7 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      float v31 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v17));
      float v19 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v18));
      float32x2_t v20 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v19), LODWORD(v31)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v19), LODWORD(v31)));
      int32x2_t v21 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v20), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v20)));
      int32x2_t v22 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v21, 8uLL), (int8x8_t)v21);
      uint8x8_t v23 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v22, 0x10uLL), (int8x8_t)v22);
      float v32 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v17));
      float v24 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v18));
      float32x2_t v25 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v24), LODWORD(v32)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v24), LODWORD(v32)));
      int32x2_t v26 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v25), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v25)));
      int32x2_t v27 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v26, 8uLL), (int8x8_t)v26);
      int8x16_t v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v27, 0x10uLL), (int8x8_t)v27), v23), vdupq_n_s16((v8 >> 1) & 0x7F80)), v23);
      *(int16x4_t *)v28.i8 = vadd_s16(*(int16x4_t *)v28.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v28.i8, *(int8x8_t *)v28.i8).u32[0];
      v7 += v29;
      v8 += v30;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,false,false,false,true>(_DWORD *a1, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v5 = a2;
    int v7 = a1[14];
    unsigned int v6 = a1[15];
    uint64_t v8 = *(void *)(*(void *)a1 + 16);
    uint64_t v9 = **(void **)a1;
    unsigned int v10 = v6 + 0x8000;
    v6 -= 0x8000;
    uint64_t v11 = v9 + v8 * ((uint64_t)(int)v6 >> 16);
    uint64_t v12 = v9 + v8 * ((uint64_t)(int)v10 >> 16);
    a4.i32[0] = (v6 >> 1) & 0x7F80;
    int16x4_t v32 = a4;
    int v13 = a1[13] - 0x8000;
    __asm { FMOV            V8.2S, #1.0 }
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v5;
      unint64_t v20 = ((uint64_t)v13 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v21 = ((uint64_t)(v13 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      float v33 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v11 + v20));
      float v22 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v11 + v21));
      float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v22), LODWORD(v33)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v22), LODWORD(v33)));
      int32x2_t v24 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v23), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v23)));
      int32x2_t v25 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v24, 8uLL), (int8x8_t)v24);
      uint8x8_t v26 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v25, 0x10uLL), (int8x8_t)v25);
      float v34 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v12 + v20));
      float v27 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v12 + v21));
      float32x2_t v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v27), LODWORD(v34)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v27), LODWORD(v34)));
      int32x2_t v29 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v28), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v28)));
      int32x2_t v30 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v29, 8uLL), (int8x8_t)v29);
      int8x16_t v31 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v30, 0x10uLL), (int8x8_t)v30), v26), v32, 0), v26);
      *(int16x4_t *)v31.i8 = vadd_s16(*(int16x4_t *)v31.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL), *(int16x4_t *)v31.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v31.i8, *(int8x8_t *)v31.i8).u32[0];
      v13 += v7;
    }
    while (v5);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v5 = (float *)*a1;
    uint64_t v38 = (*a1)[2];
    uint64_t v39 = **a1;
    __int32 v6 = *((_DWORD *)*a1 + 8);
    int v7 = *((_DWORD *)*a1 + 9);
    float v8 = *((float *)a1[3] + 3);
    float v9 = *((float *)a1[2] + 3);
    int v10 = *((_DWORD *)a1 + 15);
    int v11 = *((_DWORD *)a1 + 16);
    int v12 = *((_DWORD *)a1 + 13);
    int v13 = *((_DWORD *)a1 + 14);
    int v14 = *((unsigned __int8 *)a1 + 48) - 1;
    float v15 = 0.5;
    float32x2_t v16 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v17 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      v19.f32[0] = (float)(1.0 / v9) * (float)v12;
      v19.f32[1] = (float)(1.0 / v9) * (float)v10;
      int32x2_t v20 = vcvt_s32_f32(v19);
      switch(v14)
      {
        case 0:
          float32x2_t v21 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v20));
          float32x2_t v22 = vmul_f32(v21, v21);
          float32x2_t v23 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v22, 1), v22);
          v22.f32[0] = fmaxf(vaddv_f32(v22), 0.00001);
          v22.i32[0] = vmul_f32(v23, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v22, 0))).u32[0];
          v22.f32[1] = v15;
          float32x2_t v24 = vmul_f32(v22, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float v25 = atan2f(v5[11] * (float)v20.i32[1], v5[10] * (float)v20.i32[0]);
          v26.i32[1] = 1056964608;
          v26.f32[0] = (float)(v25 * -10430.0) + 32768.0;
          float32x2_t v24 = vmul_f32(v26, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v27 = vmul_f32(vcvt_f32_s32(v20), vmul_f32(v16, *(float32x2_t *)(v5 + 10)));
          float32x2_t v24 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v27, vrndm_f32(v27)), v17)), vmul_f32(v18, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v28 = vcvt_f32_s32(v20);
          float32x2_t v29 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v30 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v29);
          float32x2_t v31 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v29);
          float32x2_t v32 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v28, v31), (int8x8_t)v31, (int8x8_t)v28);
          float32x2_t v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v32), (int8x8_t)v30, (int8x8_t)v32);
LABEL_8:
          int32x2_t v20 = vcvt_s32_f32(v24);
          break;
        default:
          break;
      }
      --v4;
      __int32 v33 = v20.i32[0] & ~(v20.i32[0] >> 31);
      if (v33 >= v6) {
        __int32 v33 = v6;
      }
      int v34 = v20.i32[1] & ~(v20.i32[1] >> 31);
      if (v34 >= v7) {
        int v34 = v7;
      }
      float v35 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v39
                                                                         + v38 * ((uint64_t)v34 >> 16)
                                                                         + (((uint64_t)v33 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v35 > 1.0) {
        float v35 = 1.0;
      }
      float v15 = 0.5;
      if (v35 >= 0.0) {
        float v36 = (float)(v35 * 255.0) + 0.5;
      }
      else {
        float v36 = 0.5;
      }
      float v9 = v9 + v8;
      v12 += v13;
      v10 += v11;
      *a3++ = v36 | (v36 << 8) | ((v36 | (v36 << 8)) << 16);
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,true,true,false,false>(int *a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = **(void **)a1;
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    int v7 = *(_DWORD *)(*(void *)a1 + 32);
    int v8 = *(_DWORD *)(*(void *)a1 + 36);
    int v10 = a1[15];
    int v9 = a1[16];
    int v12 = a1[13];
    int v11 = a1[14];
    do
    {
      --v4;
      int v13 = v12 & ~(v12 >> 31);
      if (v13 >= v7) {
        int v13 = v7;
      }
      int v14 = v10 & ~(v10 >> 31);
      if (v14 >= v8) {
        int v14 = v8;
      }
      float v15 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v5
                                                                         + v6 * ((uint64_t)v14 >> 16)
                                                                         + (((uint64_t)v13 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v15 > 1.0) {
        float v15 = 1.0;
      }
      if (v15 >= 0.0) {
        float v16 = (float)(v15 * 255.0) + 0.5;
      }
      else {
        float v16 = 0.5;
      }
      v12 += v11;
      v10 += v9;
      *a3++ = v16 | (v16 << 8) | ((v16 | (v16 << 8)) << 16);
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,false,true,false,false>(_DWORD *a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v5 = a1[14];
    int v6 = a1[13];
    int v7 = *(_DWORD *)(*(void *)a1 + 32);
    int v8 = a1[15] & ~((int)a1[15] >> 31);
    if (v8 >= *(_DWORD *)(*(void *)a1 + 36)) {
      int v8 = *(_DWORD *)(*(void *)a1 + 36);
    }
    uint64_t v9 = **(void **)a1 + *(void *)(*(void *)a1 + 16) * ((uint64_t)v8 >> 16);
    do
    {
      --v4;
      int v10 = v6 & ~(v6 >> 31);
      if (v10 >= v7) {
        int v10 = v7;
      }
      float v11 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v9
                                                                         + (((uint64_t)v10 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v11 > 1.0) {
        float v11 = 1.0;
      }
      if (v11 >= 0.0) {
        float v12 = (float)(v11 * 255.0) + 0.5;
      }
      else {
        float v12 = 0.5;
      }
      v6 += v5;
      *a3++ = v12 | (v12 << 8) | ((v12 | (v12 << 8)) << 16);
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,true,false,false,false>(_DWORD *a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = **(void **)a1;
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    int v8 = a1[15];
    int v7 = a1[16];
    int v10 = a1[13];
    int v9 = a1[14];
    do
    {
      --v4;
      float v11 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v5
                                                                         + v6 * ((uint64_t)v8 >> 16)
                                                                         + (((uint64_t)v10 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v11 > 1.0) {
        float v11 = 1.0;
      }
      if (v11 >= 0.0) {
        float v12 = (float)(v11 * 255.0) + 0.5;
      }
      else {
        float v12 = 0.5;
      }
      v10 += v9;
      v8 += v7;
      *a3++ = v12 | (v12 << 8) | ((v12 | (v12 << 8)) << 16);
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,false,false,false,false>(uint64_t a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v6 = *(_DWORD *)(a1 + 52);
    int v5 = *(_DWORD *)(a1 + 56);
    uint64_t v7 = **(void **)a1 + *(void *)(*(void *)a1 + 16) * *(__int16 *)(a1 + 62);
    do
    {
      --v4;
      float v8 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v7
                                                                        + (((uint64_t)v6 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v8 > 1.0) {
        float v8 = 1.0;
      }
      if (v8 >= 0.0) {
        float v9 = (float)(v8 * 255.0) + 0.5;
      }
      else {
        float v9 = 0.5;
      }
      v6 += v5;
      *a3++ = v9 | (v9 << 8) | ((v9 | (v9 << 8)) << 16);
    }
    while (v4);
  }
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3, double a4, double a5, double a6, int8x8_t a7)
{
  if (a2)
  {
    int v8 = a2;
    float v9 = (float *)*result;
    uint64_t v10 = **result;
    uint64_t v11 = (*result)[2];
    int v12 = *((_DWORD *)*result + 8);
    uint64_t v13 = *((unsigned int *)*result + 9);
    float v14 = *((float *)result[3] + 3);
    float v15 = *((float *)result[2] + 3);
    int v17 = *((_DWORD *)result + 15);
    int v16 = *((_DWORD *)result + 16);
    int v19 = *((_DWORD *)result + 13);
    uint64_t v18 = *((unsigned int *)result + 14);
    int v20 = v12 - 0x8000;
    int v21 = v13 - 0x8000;
    int v22 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v23 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v24 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v25 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v66 = v12;
    int v67 = v16;
    int v64 = v13 - 0x8000;
    int v65 = v12 - 0x8000;
    int v63 = v22;
    do
    {
      *(float *)&a6 = (float)v17;
      v26.f32[0] = (float)(1.0 / v15) * (float)v19;
      v26.f32[1] = (float)(1.0 / v15) * (float)v17;
      int32x2_t v27 = vcvt_s32_f32(v26);
      switch(v22)
      {
        case 0:
          float32x2_t v28 = vmul_f32(*(float32x2_t *)(v9 + 10), vcvt_f32_s32(v27));
          float32x2_t v29 = vmul_f32(v28, v28);
          float32x2_t v30 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v29, 1), v29);
          v29.f32[0] = fmaxf(vaddv_f32(v29), 0.00001);
          v29.i32[0] = vmul_f32(v30, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v29, 0))).u32[0];
          float32x2_t v26 = vcvt_f32_u32(*(uint32x2_t *)(v9 + 6));
          LODWORD(a6) = 0.5;
          v29.i32[1] = 0.5;
          float32x2_t v31 = vmul_f32(v29, v26);
          goto LABEL_8;
        case 1:
          float32x2_t v32 = result;
          __int32 v33 = v9;
          uint64_t v34 = v10;
          uint64_t v35 = v13;
          uint64_t v36 = v18;
          float v37 = atan2f(v9[11] * (float)v27.i32[1], v9[10] * (float)v27.i32[0]);
          uint64_t v18 = v36;
          int v12 = v66;
          int v16 = v67;
          uint64_t v13 = v35;
          int v22 = v63;
          uint64_t v10 = v34;
          float v9 = v33;
          int v21 = v64;
          int v20 = v65;
          uint64_t result = v32;
          float32x2_t v26 = vcvt_f32_u32(*(uint32x2_t *)(v9 + 6));
          HIDWORD(a6) = 1056964608;
          *(float *)&a6 = (float)(v37 * -10430.0) + 32768.0;
          float32x2_t v31 = vmul_f32(*(float32x2_t *)&a6, v26);
          goto LABEL_8;
        case 2:
          float32x2_t v38 = vmul_f32(vcvt_f32_s32(v27), vmul_f32(v23, *(float32x2_t *)(v9 + 10)));
          float32x2_t v26 = *(float32x2_t *)((char *)result + 84);
          a6 = COERCE_DOUBLE(vmla_f32(*(float32x2_t *)((char *)result + 92), v26, vminnm_f32(vsub_f32(v38, vrndm_f32(v38)), v24)));
          float32x2_t v31 = vmul_f32(*(float32x2_t *)&a6, vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v9 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v39 = vcvt_f32_s32(v27);
          float32x2_t v40 = vcvt_f32_s32(*(int32x2_t *)(v9 + 8));
          float32x2_t v26 = vmul_f32(*(float32x2_t *)((char *)result + 84), v40);
          float32x2_t v41 = vmul_f32(*(float32x2_t *)((char *)result + 92), v40);
          a7 = (int8x8_t)vcgt_f32(v39, v41);
          float32x2_t v42 = (float32x2_t)vbsl_s8(a7, (int8x8_t)v41, (int8x8_t)v39);
          a6 = COERCE_DOUBLE(vcgt_f32(v26, v42));
          float32x2_t v31 = (float32x2_t)vbsl_s8(*(int8x8_t *)&a6, (int8x8_t)v26, (int8x8_t)v42);
LABEL_8:
          int32x2_t v27 = vcvt_s32_f32(v31);
          break;
        default:
          break;
      }
      int v43 = v27.i32[0];
      if (v27.i32[0] >= v20) {
        int v44 = v20;
      }
      else {
        int v44 = v27.i32[0];
      }
      if (v44 <= -32768) {
        int v44 = -32768;
      }
      unsigned int v45 = v44 + 0x8000;
      if (v27.i32[0] <= 0x8000) {
        int v43 = 0x8000;
      }
      int v46 = v43 - 0x8000;
      int v47 = v27.i32[1];
      if (v46 >= v12) {
        int v46 = v12;
      }
      if (v27.i32[1] >= v21) {
        int v48 = v21;
      }
      else {
        int v48 = v27.i32[1];
      }
      if (v48 <= -32768) {
        int v48 = -32768;
      }
      unsigned int v49 = v48 + 0x8000;
      if (v27.i32[1] <= 0x8000) {
        int v47 = 0x8000;
      }
      int v50 = v47 - 0x8000;
      if (v50 >= (int)v13) {
        int v50 = v13;
      }
      uint64_t v51 = v10 + v11 * ((uint64_t)v50 >> 16);
      uint64_t v52 = v10 + v11 * HIWORD(v49);
      unint64_t v53 = ((uint64_t)v46 >> 13) & 0xFFFFFFFFFFFFFFF8;
      int32x2_t v54 = (__int16 *)(v51 + v53);
      int8x16_t v55 = (__int16 *)(v52 + v53);
      uint64_t v56 = (v45 >> 13) & 0x7FFF8;
      uint64_t v57 = (__int16 *)(v51 + v56);
      float32x2_t v58 = (__int16 *)(v52 + v56);
      v27.i16[0] = *v54;
      v27.i16[2] = *v57;
      v26.i16[0] = v54[1];
      v26.i16[2] = v57[1];
      LOWORD(a6) = v54[2];
      WORD2(a6) = v57[2];
      int8x8_t v59 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(*(int8x8_t *)&a6, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int8x8_t v60 = vorr_s8(vand_s8((int8x8_t)v26, (int8x8_t)0xFF000000FF00), v59);
      int8x8_t v61 = vorr_s8((int8x8_t)(*(void *)&vshl_n_s32((int32x2_t)vand_s8((int8x8_t)v27, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), v60);
      v60.i16[0] = *v55;
      v60.i16[2] = *v58;
      v59.i16[0] = v55[1];
      v59.i16[2] = v58[1];
      a7.i16[0] = v55[2];
      a7.i16[2] = v58[2];
      a7 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a7, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int8x16_t v62 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8((int8x8_t)(*(void *)&vshl_n_s32((int32x2_t)vand_s8(v60, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), vorr_s8(vand_s8(v59, (int8x8_t)0xFF000000FF00), a7)) | 0xFF000000FF000000), (uint8x8_t)(*(void *)&v61 | 0xFF000000FF000000)), vdupq_n_s16((v50 >> 1) & 0x7F80)), (uint8x8_t)(*(void *)&v61 | 0xFF000000FF000000));
      a6 = COERCE_DOUBLE(vdup_n_s16((v46 >> 1) & 0x7F80));
      *(int16x4_t *)v62.i8 = vadd_s16(*(int16x4_t *)v62.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v62, v62, 8uLL), *(int16x4_t *)v62.i8), *(int16x4_t *)&a6));
      float v15 = v15 + v14;
      v19 += v18;
      v17 += v16;
      *a3++ = vuzp1_s8(*(int8x8_t *)v62.i8, *(int8x8_t *)v62.i8).u32[0];
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, int8x8_t a6, int8x8_t a7, int8x8_t a8, int8x8_t a9, int8x8_t a10)
{
  if (a2)
  {
    uint64_t v10 = **(void **)result;
    uint64_t v11 = *(void *)(*(void *)result + 16);
    int v12 = *(_DWORD *)(*(void *)result + 32);
    int v13 = *(_DWORD *)(*(void *)result + 36);
    int v15 = *(_DWORD *)(result + 60);
    int v14 = *(_DWORD *)(result + 64);
    int v17 = *(_DWORD *)(result + 52);
    int v16 = *(_DWORD *)(result + 56);
    uint64_t result = 4294934528;
    do
    {
      if (v17 >= v12 - 0x8000) {
        int v18 = v12 - 0x8000;
      }
      else {
        int v18 = v17;
      }
      if (v18 <= -32768) {
        int v19 = -32768;
      }
      else {
        int v19 = v18;
      }
      if (v17 <= 0x8000) {
        int v20 = 0x8000;
      }
      else {
        int v20 = v17;
      }
      int v21 = v20 - 0x8000;
      if (v21 >= v12) {
        int v21 = v12;
      }
      if (v15 >= v13 - 0x8000) {
        int v22 = v13 - 0x8000;
      }
      else {
        int v22 = v15;
      }
      if (v22 <= -32768) {
        int v22 = -32768;
      }
      unsigned int v23 = v22 + 0x8000;
      if (v15 <= 0x8000) {
        int v24 = 0x8000;
      }
      else {
        int v24 = v15;
      }
      int v25 = v24 - 0x8000;
      if (v25 >= v13) {
        int v25 = v13;
      }
      unsigned int v26 = v19 + 0x8000;
      uint64_t v27 = v10 + v11 * ((uint64_t)v25 >> 16);
      uint64_t v28 = v10 + v11 * HIWORD(v23);
      unint64_t v29 = ((uint64_t)v21 >> 13) & 0xFFFFFFFFFFFFFFF8;
      float32x2_t v30 = (__int16 *)(v27 + v29);
      float32x2_t v31 = (__int16 *)(v28 + v29);
      uint64_t v32 = (v26 >> 13) & 0x7FFF8;
      __int32 v33 = (__int16 *)(v28 + v32);
      uint64_t v34 = (__int16 *)(v27 + v32);
      a6.i16[0] = *v30;
      a6.i16[2] = *v34;
      a7.i16[0] = v30[1];
      a7.i16[2] = v34[1];
      a8.i16[0] = v30[2];
      a8.i16[2] = v34[2];
      a9.i16[0] = v31[1];
      a9.i16[2] = v33[1];
      a10.i16[0] = v31[2];
      a10.i16[2] = v33[2];
      a10 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a9 = vorr_s8(vand_s8(a9, (int8x8_t)0xFF000000FF00), a10);
      a10.i16[0] = *v31;
      a10.i16[2] = *v33;
      int8x8_t v35 = vorr_s8((int8x8_t)(*(void *)&vshl_n_s32((int32x2_t)vand_s8(a6, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), vorr_s8(vand_s8(a7, (int8x8_t)0xFF000000FF00), (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL)));
      int8x16_t v36 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8((int8x8_t)(*(void *)&vshl_n_s32((int32x2_t)vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), a9) | 0xFF000000FF000000), (uint8x8_t)(*(void *)&v35 | 0xFF000000FF000000)), vdupq_n_s16((v25 >> 1) & 0x7F80)), (uint8x8_t)(*(void *)&v35 | 0xFF000000FF000000));
      a8 = (int8x8_t)vdup_n_s16((v21 >> 1) & 0x7F80);
      a7 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL), *(int16x4_t *)v36.i8), (int16x4_t)a8);
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v36.i8, (int16x4_t)a7), (int8x8_t)0xFFFF0000FFFFLL);
      v17 += v16;
      v15 += v14;
      *a3++ = a6.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, int8x8_t a7, int8x8_t a8, int8x8_t a9, int8x8_t a10, int8x8_t a11)
{
  if (a2)
  {
    int v11 = result[14];
    int v12 = result[15];
    int v13 = result[13];
    int v14 = *(_DWORD *)(*(void *)result + 32);
    int v15 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v16 = *(void *)(*(void *)result + 16);
    uint64_t v17 = **(void **)result;
    if (v12 >= v15 - 0x8000) {
      int v18 = v15 - 0x8000;
    }
    else {
      int v18 = result[15];
    }
    if (v18 <= -32768) {
      int v18 = -32768;
    }
    if (v12 <= 0x8000) {
      int v12 = 0x8000;
    }
    int v19 = v12 - 0x8000;
    if (v19 >= v15) {
      int v20 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v20 = v19;
    }
    uint64_t v21 = v17 + v16 * ((uint64_t)v20 >> 16);
    uint64_t v22 = v17 + v16 * ((v18 + 0x8000) >> 16);
    a4.i32[0] = (v20 >> 1) & 0x7F80;
    do
    {
      if (v13 >= v14 - 0x8000) {
        int v23 = v14 - 0x8000;
      }
      else {
        int v23 = v13;
      }
      if (v23 <= -32768) {
        int v23 = -32768;
      }
      if (v13 <= 0x8000) {
        int v24 = 0x8000;
      }
      else {
        int v24 = v13;
      }
      unsigned int v25 = v23 + 0x8000;
      int v26 = v24 - 0x8000;
      if (v24 - 0x8000 >= v14) {
        int v26 = v14;
      }
      unint64_t v27 = ((uint64_t)v26 >> 13) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v28 = (__int16 *)(v21 + v27);
      unint64_t v29 = (__int16 *)(v22 + v27);
      uint64_t v30 = (v25 >> 13) & 0x7FFF8;
      float32x2_t v31 = (__int16 *)(v21 + v30);
      uint64_t result = (_DWORD *)(v22 + v30);
      a7.i16[0] = *v28;
      a7.i16[2] = *v31;
      a8.i16[0] = v28[1];
      a8.i16[2] = v31[1];
      a9.i16[0] = v28[2];
      a9.i16[2] = v31[2];
      int8x8_t v32 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a9, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a10.i16[0] = *v29;
      a10.i16[2] = *(_WORD *)result;
      a10 = vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL);
      a11.i16[0] = v29[1];
      a11.i16[2] = *((_WORD *)result + 1);
      a11 = vand_s8(a11, (int8x8_t)0xFF000000FF00);
      int8x8_t v33 = vorr_s8(vand_s8(a8, (int8x8_t)0xFF000000FF00), v32);
      v32.i16[0] = v29[2];
      v32.i16[2] = *((_WORD *)result + 2);
      int8x8_t v34 = vorr_s8((int8x8_t)(*(void *)&vshl_n_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), v33);
      int8x16_t v35 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8((int8x8_t)(*(void *)&vshl_n_s32((int32x2_t)a10, 8uLL) & 0xFFFF00FFFFFF00FFLL), vorr_s8(a11, (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v32, (int8x8_t)0xFFFF0000FFFFLL), 8uLL))) | 0xFF000000FF000000), (uint8x8_t)(*(void *)&v34 | 0xFF000000FF000000)), a4, 0), (uint8x8_t)(*(void *)&v34 | 0xFF000000FF000000));
      a9 = (int8x8_t)vdup_n_s16((v26 >> 1) & 0x7F80);
      a8 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL), *(int16x4_t *)v35.i8), (int16x4_t)a9);
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v35.i8, (int16x4_t)a8), (int8x8_t)a4);
      v13 += v11;
      *a3++ = a7.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_WORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,true,false,false,true>(_WORD *result, int a2, _DWORD *a3, double a4, double a5, int8x8_t a6, int8x8_t a7, int8x8_t a8, int8x8_t a9, int8x8_t a10)
{
  if (a2)
  {
    uint64_t v10 = **(void **)result;
    uint64_t v11 = *(void *)(*(void *)result + 16);
    int v12 = *((_DWORD *)result + 16);
    int v13 = *((_DWORD *)result + 14);
    int v14 = *((_DWORD *)result + 13) - 0x8000;
    int v15 = *((_DWORD *)result + 15) - 0x8000;
    do
    {
      uint64_t v16 = v10 + v11 * ((uint64_t)v15 >> 16);
      uint64_t v17 = v10 + v11 * ((uint64_t)(v15 + 0x10000) >> 16);
      unint64_t v18 = ((uint64_t)v14 >> 13) & 0xFFFFFFFFFFFFFFF8;
      int v19 = (__int16 *)(v16 + v18);
      int v20 = (__int16 *)(v17 + v18);
      unint64_t v21 = ((uint64_t)(v14 + 0x10000) >> 13) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v22 = (__int16 *)(v16 + v21);
      int v23 = (__int16 *)(v17 + v21);
      a6.i16[0] = *v19;
      a6.i16[2] = *v22;
      a7.i16[0] = v19[1];
      a7.i16[2] = v22[1];
      a8.i16[0] = v19[2];
      a8.i16[2] = v22[2];
      uint64_t result = v23 + 1;
      a9.i16[0] = *v20;
      a9.i16[2] = *v23;
      a10.i16[0] = v20[1];
      a10.i16[2] = v23[1];
      int8x8_t v24 = vorr_s8(vand_s8(a7, (int8x8_t)0xFF000000FF00), (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL));
      int8x8_t v25 = vand_s8(a10, (int8x8_t)0xFF000000FF00);
      a10.i16[0] = v20[2];
      a10.i16[2] = v23[2];
      int8x8_t v26 = vorr_s8((int8x8_t)(*(void *)&vshl_n_s32((int32x2_t)vand_s8(a6, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), v24);
      a9 = (int8x8_t)(*(void *)&vshl_n_s32((int32x2_t)vand_s8(a9, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL);
      int8x16_t v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(a9, vorr_s8(v25, (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL), 8uLL))) | 0xFF000000FF000000), (uint8x8_t)(*(void *)&v26 | 0xFF000000FF000000)), vdupq_n_s16((v15 >> 1) & 0x7F80)), (uint8x8_t)(*(void *)&v26 | 0xFF000000FF000000));
      a8 = (int8x8_t)vdup_n_s16((v14 >> 1) & 0x7F80);
      a7 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), (int16x4_t)a8);
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v27.i8, (int16x4_t)a7), (int8x8_t)0xFFFF0000FFFFLL);
      *a3++ = a6.i32[0];
      v14 += v13;
      v15 += v12;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, int8x8_t a7, int8x8_t a8, int8x8_t a9, int8x8_t a10, int8x8_t a11)
{
  if (a2)
  {
    int v11 = result[14];
    int v12 = result[15];
    uint64_t v13 = *(void *)(*(void *)result + 16);
    uint64_t v14 = **(void **)result;
    int v15 = v12 + 0x8000;
    unsigned int v16 = v12 - 0x8000;
    uint64_t v17 = v14 + v13 * ((uint64_t)(v12 - 0x8000) >> 16);
    uint64_t v18 = v14 + v13 * ((uint64_t)v15 >> 16);
    a4.i32[0] = (v16 >> 1) & 0x7F80;
    int v19 = result[13] - 0x8000;
    do
    {
      unint64_t v20 = ((uint64_t)v19 >> 13) & 0xFFFFFFFFFFFFFFF8;
      unint64_t v21 = (__int16 *)(v17 + v20);
      uint64_t v22 = (__int16 *)(v18 + v20);
      unint64_t v23 = ((uint64_t)(v19 + 0x10000) >> 13) & 0xFFFFFFFFFFFFFFF8;
      int8x8_t v24 = (_WORD *)(v17 + v23);
      int8x8_t v25 = (__int16 *)(v18 + v23);
      uint64_t result = v24 + 1;
      a7.i16[0] = *v21;
      a7.i16[2] = *v24;
      a8.i16[0] = v21[1];
      a8.i16[2] = v24[1];
      a9.i16[0] = v21[2];
      a9.i16[2] = v24[2];
      int8x8_t v26 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a9, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a10.i16[0] = *v22;
      a10.i16[2] = *v25;
      a10 = vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL);
      a11.i16[0] = v22[1];
      a11.i16[2] = v25[1];
      a11 = vand_s8(a11, (int8x8_t)0xFF000000FF00);
      int8x8_t v27 = vorr_s8(vand_s8(a8, (int8x8_t)0xFF000000FF00), v26);
      v26.i16[0] = v22[2];
      v26.i16[2] = v25[2];
      int8x8_t v28 = vorr_s8((int8x8_t)(*(void *)&vshl_n_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), v27);
      int8x16_t v29 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8((int8x8_t)(*(void *)&vshl_n_s32((int32x2_t)a10, 8uLL) & 0xFFFF00FFFFFF00FFLL), vorr_s8(a11, (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v26, (int8x8_t)0xFFFF0000FFFFLL), 8uLL))) | 0xFF000000FF000000), (uint8x8_t)(*(void *)&v28 | 0xFF000000FF000000)), a4, 0), (uint8x8_t)(*(void *)&v28 | 0xFF000000FF000000));
      a9 = (int8x8_t)vdup_n_s16((v19 >> 1) & 0x7F80);
      a8 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL), *(int16x4_t *)v29.i8), (int16x4_t)a9);
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v29.i8, (int16x4_t)a8), (int8x8_t)a4);
      *a3++ = a7.i32[0];
      v19 += v11;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v40 = v13;
    int v38 = v17;
    uint64_t v39 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v38;
          uint64_t v8 = v39;
          int v13 = v40;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      float v37 = (unsigned __int16 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 13) & 0xFFFFFFFFFFFFFFF8));
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = (*v37 << 8) & 0xFF0000 | (*((unsigned __int8 *)v37 + 3) << 8) | *((unsigned __int8 *)v37 + 5) | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      int v13 = (unsigned __int16 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 13) & 0xFFFFFFFFFFFFFFF8));
      uint64_t result = (int *)*((unsigned __int8 *)v13 + 3);
      v10 += v9;
      v8 += v7;
      *a3++ = (*v13 << 8) & 0xFF0000 | (result << 8) | *((unsigned __int8 *)v13 + 5) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      v4 += v3;
      *a3++ = (*(unsigned __int16 *)(v7 + (((uint64_t)v8 >> 13) & 0xFFFFFFFFFFFFFFF8)) << 8) & 0xFF0000 | (*(unsigned __int8 *)(v7 + (((uint64_t)v8 >> 13) & 0xFFFFFFFFFFFFFFF8) + 3) << 8) | *(unsigned __int8 *)(v7 + (((uint64_t)v8 >> 13) & 0xFFFFFFFFFFFFFFF8) + 5) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      int v9 = (unsigned __int16 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 13) & 0xFFFFFFFFFFFFFFF8));
      v8 += v7;
      v6 += v5;
      *a3++ = (*v9 << 8) & 0xFF0000 | (*((unsigned __int8 *)v9 + 3) << 8) | *((unsigned __int8 *)v9 + 5) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      unsigned int v6 = (*(unsigned __int16 *)(v5 + (((uint64_t)v4 >> 13) & 0xFFFFFFFFFFFFFFF8)) << 8) & 0xFF0000 | (*(unsigned __int8 *)(v5 + (((uint64_t)v4 >> 13) & 0xFFFFFFFFFFFFFFF8) + 3) << 8) | *(unsigned __int8 *)(v5 + (((uint64_t)v4 >> 13) & 0xFFFFFFFFFFFFFFF8) + 5) | 0xFF000000;
      v4 += v3;
      *a3++ = v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3, double a4, double a5, double a6, int8x8_t a7, int8x8_t a8)
{
  if (a2)
  {
    int v9 = a2;
    int v10 = (float *)*result;
    uint64_t v11 = **result;
    uint64_t v12 = (*result)[2];
    uint64_t v13 = *((unsigned int *)*result + 8);
    uint64_t v14 = *((unsigned int *)*result + 9);
    float v15 = *((float *)result[3] + 3);
    float v16 = *((float *)result[2] + 3);
    int v18 = *((_DWORD *)result + 15);
    int v17 = *((_DWORD *)result + 16);
    int v19 = *((_DWORD *)result + 13);
    int v20 = *((_DWORD *)result + 14);
    int v21 = v13 - 0x8000;
    int v22 = v14 - 0x8000;
    float v23 = 1.0;
    int v24 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v65 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v66 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v64 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v70 = v20;
    int v71 = v17;
    int v68 = v14 - 0x8000;
    int v69 = v13 - 0x8000;
    int v67 = v24;
    do
    {
      *(float *)&a6 = (float)v18;
      v25.f32[0] = (float)(v23 / v16) * (float)v19;
      v25.f32[1] = (float)(v23 / v16) * (float)v18;
      int32x2_t v26 = vcvt_s32_f32(v25);
      switch(v24)
      {
        case 0:
          float32x2_t v27 = vmul_f32(*(float32x2_t *)(v10 + 10), vcvt_f32_s32(v26));
          float32x2_t v28 = vmul_f32(v27, v27);
          float32x2_t v29 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 1), v28);
          v28.f32[0] = fmaxf(vaddv_f32(v28), 0.00001);
          v28.i32[0] = vmul_f32(v29, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 0))).u32[0];
          float32x2_t v25 = vcvt_f32_u32(*(uint32x2_t *)(v10 + 6));
          LODWORD(a6) = 0.5;
          v28.i32[1] = 0.5;
          float32x2_t v30 = vmul_f32(v28, v25);
          goto LABEL_8;
        case 1:
          float32x2_t v31 = result;
          float32x2_t v32 = v10;
          uint64_t v33 = v11;
          uint64_t v34 = v12;
          uint64_t v35 = v13;
          uint64_t v36 = v14;
          float v37 = atan2f(v10[11] * (float)v26.i32[1], v10[10] * (float)v26.i32[0]);
          float v23 = 1.0;
          uint64_t v14 = v36;
          uint64_t v13 = v35;
          int v22 = v68;
          int v21 = v69;
          uint64_t v12 = v34;
          uint64_t v11 = v33;
          int v10 = v32;
          int v20 = v70;
          int v17 = v71;
          uint64_t result = v31;
          int v24 = v67;
          float32x2_t v25 = vcvt_f32_u32(*(uint32x2_t *)(v10 + 6));
          HIDWORD(a6) = 1056964608;
          *(float *)&a6 = (float)(v37 * -10430.0) + 32768.0;
          float32x2_t v30 = vmul_f32(*(float32x2_t *)&a6, v25);
          goto LABEL_8;
        case 2:
          float32x2_t v38 = vmul_f32(vcvt_f32_s32(v26), vmul_f32(v66, *(float32x2_t *)(v10 + 10)));
          a6 = COERCE_DOUBLE(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v38, vrndm_f32(v38)), v65)));
          float32x2_t v25 = v64;
          float32x2_t v30 = vmul_f32(*(float32x2_t *)&a6, vmul_f32(v64, vcvt_f32_u32(*(uint32x2_t *)(v10 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v39 = vcvt_f32_s32(v26);
          float32x2_t v40 = vcvt_f32_s32(*(int32x2_t *)(v10 + 8));
          float32x2_t v25 = vmul_f32(*(float32x2_t *)((char *)result + 84), v40);
          float32x2_t v41 = vmul_f32(*(float32x2_t *)((char *)result + 92), v40);
          a7 = (int8x8_t)vcgt_f32(v39, v41);
          float32x2_t v42 = (float32x2_t)vbsl_s8(a7, (int8x8_t)v41, (int8x8_t)v39);
          a6 = COERCE_DOUBLE(vcgt_f32(v25, v42));
          float32x2_t v30 = (float32x2_t)vbsl_s8(*(int8x8_t *)&a6, (int8x8_t)v25, (int8x8_t)v42);
LABEL_8:
          int32x2_t v26 = vcvt_s32_f32(v30);
          break;
        default:
          break;
      }
      int v43 = v26.i32[0];
      if (v26.i32[0] >= v21) {
        int v44 = v21;
      }
      else {
        int v44 = v26.i32[0];
      }
      if (v44 <= -32768) {
        int v44 = -32768;
      }
      unsigned int v45 = v44 + 0x8000;
      if (v26.i32[0] <= 0x8000) {
        int v43 = 0x8000;
      }
      int v46 = v43 - 0x8000;
      int v47 = v26.i32[1];
      if (v46 >= (int)v13) {
        int v46 = v13;
      }
      if (v26.i32[1] >= v22) {
        int v48 = v22;
      }
      else {
        int v48 = v26.i32[1];
      }
      if (v48 <= -32768) {
        int v48 = -32768;
      }
      unsigned int v49 = v48 + 0x8000;
      if (v26.i32[1] <= 0x8000) {
        int v47 = 0x8000;
      }
      int v50 = v47 - 0x8000;
      if (v50 >= (int)v14) {
        int v50 = v14;
      }
      uint64_t v51 = v11 + v12 * ((uint64_t)v50 >> 16);
      uint64_t v52 = v11 + v12 * HIWORD(v49);
      unint64_t v53 = ((uint64_t)v46 >> 13) & 0xFFFFFFFFFFFFFFF8;
      int32x2_t v54 = (__int16 *)(v51 + v53);
      int8x16_t v55 = (__int16 *)(v52 + v53);
      uint64_t v56 = (v45 >> 13) & 0x7FFF8;
      uint64_t v57 = (__int16 *)(v51 + v56);
      float32x2_t v58 = (__int16 *)(v52 + v56);
      v26.i16[0] = v54[3];
      v26.i16[2] = *v57;
      v25.i16[0] = v54[1];
      v25.i16[2] = v57[1];
      LOWORD(a6) = v54[2];
      WORD2(a6) = v57[2];
      a7.i16[0] = *v54;
      a7.i16[2] = v57[3];
      int8x8_t v59 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(*(int8x8_t *)&a6, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int8x8_t v60 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a7, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000);
      int8x8_t v61 = vorr_s8(v60, vand_s8((int8x8_t)v25, (int8x8_t)0xFF000000FF00));
      uint8x8_t v62 = (uint8x8_t)vorr_s8(v61, vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8((int8x8_t)v26, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), v59));
      v61.i16[0] = v55[3];
      v61.i16[2] = *v58;
      v59.i16[0] = v55[1];
      v59.i16[2] = v58[1];
      v60.i16[0] = v55[2];
      v60.i16[2] = v58[2];
      a7 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v60, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a8.i16[0] = *v55;
      a8.i16[2] = v58[3];
      a8 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000);
      int8x16_t v63 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8(a8, vand_s8(v59, (int8x8_t)0xFF000000FF00)), vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v61, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), a7)), v62), vdupq_n_s16((v50 >> 1) & 0x7F80)), v62);
      a6 = COERCE_DOUBLE(vdup_n_s16((v46 >> 1) & 0x7F80));
      *(int16x4_t *)v63.i8 = vadd_s16(*(int16x4_t *)v63.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v63, v63, 8uLL), *(int16x4_t *)v63.i8), *(int16x4_t *)&a6));
      float v16 = v16 + v15;
      v19 += v20;
      v18 += v17;
      *a3++ = vuzp1_s8(*(int8x8_t *)v63.i8, *(int8x8_t *)v63.i8).u32[0];
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, int8x8_t a10, int8x8_t a11)
{
  if (a2)
  {
    uint64_t v17 = **(void **)result;
    uint64_t v18 = *(void *)(*(void *)result + 16);
    int v19 = *(_DWORD *)(*(void *)result + 32);
    int v20 = *(_DWORD *)(*(void *)result + 36);
    int v22 = *(_DWORD *)(result + 60);
    int v21 = *(_DWORD *)(result + 64);
    int v24 = *(_DWORD *)(result + 52);
    int v23 = *(_DWORD *)(result + 56);
    uint64_t result = 4294934528;
    do
    {
      if (v24 >= v19 - 0x8000) {
        int v25 = v19 - 0x8000;
      }
      else {
        int v25 = v24;
      }
      if (v25 <= -32768) {
        int v26 = -32768;
      }
      else {
        int v26 = v25;
      }
      if (v24 <= 0x8000) {
        int v27 = 0x8000;
      }
      else {
        int v27 = v24;
      }
      int v28 = v27 - 0x8000;
      if (v28 >= v19) {
        int v28 = v19;
      }
      if (v22 >= v20 - 0x8000) {
        int v29 = v20 - 0x8000;
      }
      else {
        int v29 = v22;
      }
      if (v29 <= -32768) {
        int v29 = -32768;
      }
      unsigned int v30 = v29 + 0x8000;
      if (v22 <= 0x8000) {
        int v31 = 0x8000;
      }
      else {
        int v31 = v22;
      }
      int v32 = v31 - 0x8000;
      if (v32 >= v20) {
        int v32 = v20;
      }
      uint64_t v33 = v17 + v18 * ((uint64_t)v32 >> 16);
      uint64_t v34 = v17 + v18 * HIWORD(v30);
      unint64_t v35 = ((uint64_t)v28 >> 13) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v36 = (__int16 *)(v33 + v35);
      float v37 = (__int16 *)(v34 + v35);
      uint64_t v38 = ((v26 + 0x8000) >> 13) & 0x7FFF8;
      float32x2_t v39 = (__int16 *)(v34 + v38);
      float32x2_t v40 = (__int16 *)(v33 + v38);
      a10.i16[0] = v36[3];
      a11.i16[0] = *v36;
      v11.i16[0] = v36[1];
      v12.i16[0] = v36[2];
      v13.i16[0] = v37[3];
      a10.i16[2] = *v40;
      v13.i16[2] = *v39;
      v14.i16[0] = v37[1];
      v11.i16[2] = v40[1];
      v14.i16[2] = v39[1];
      v15.i16[0] = v37[2];
      v12.i16[2] = v40[2];
      v15.i16[2] = v39[2];
      v16.i16[0] = *v37;
      v16.i16[2] = v39[3];
      int8x8_t v16 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v16, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000);
      int8x8_t v14 = vorr_s8(v16, vand_s8(v14, (int8x8_t)0xFF000000FF00));
      int8x8_t v15 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v15, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      int8x8_t v13 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v13, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), v15);
      a11.i16[2] = v40[3];
      int8x8_t v41 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(*(int8x8_t *)v12.i8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL));
      int16x8_t v12 = vdupq_n_s16((v32 >> 1) & 0x7F80);
      uint8x8_t v42 = (uint8x8_t)vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000), vand_s8((int8x8_t)v11, (int8x8_t)0xFF000000FF00)), v41);
      int8x16_t v43 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(v14, v13), v42), v12), v42);
      int16x4_t v11 = vdup_n_s16((v28 >> 1) & 0x7F80);
      a11 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL), *(int16x4_t *)v43.i8), v11);
      a10 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v43.i8, (int16x4_t)a11), (int8x8_t)0xFFFF0000FFFFLL);
      v24 += v23;
      v22 += v21;
      *a3++ = a10.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  if (a2)
  {
    int v17 = result[14];
    int v18 = result[15];
    int v19 = result[13];
    int v20 = *(_DWORD *)(*(void *)result + 32);
    int v21 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v22 = *(void *)(*(void *)result + 16);
    uint64_t v23 = **(void **)result;
    if (v18 >= v21 - 0x8000) {
      int v24 = v21 - 0x8000;
    }
    else {
      int v24 = result[15];
    }
    if (v24 <= -32768) {
      int v24 = -32768;
    }
    if (v18 <= 0x8000) {
      int v18 = 0x8000;
    }
    int v25 = v18 - 0x8000;
    if (v25 >= v21) {
      int v26 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v26 = v25;
    }
    uint64_t v27 = v23 + v22 * ((uint64_t)v26 >> 16);
    uint64_t v28 = v23 + v22 * ((v24 + 0x8000) >> 16);
    a4.i32[0] = (v26 >> 1) & 0x7F80;
    do
    {
      if (v19 >= v20 - 0x8000) {
        int v29 = v20 - 0x8000;
      }
      else {
        int v29 = v19;
      }
      if (v29 <= -32768) {
        int v29 = -32768;
      }
      if (v19 <= 0x8000) {
        int v30 = 0x8000;
      }
      else {
        int v30 = v19;
      }
      unsigned int v31 = v29 + 0x8000;
      int v32 = v30 - 0x8000;
      if (v30 - 0x8000 >= v20) {
        int v32 = v20;
      }
      unint64_t v33 = ((uint64_t)v32 >> 13) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v34 = (__int16 *)(v27 + v33);
      unint64_t v35 = (__int16 *)(v28 + v33);
      uint64_t v36 = (v31 >> 13) & 0x7FFF8;
      float v37 = (__int16 *)(v27 + v36);
      uint64_t result = (_DWORD *)(v28 + v36);
      a11.i16[0] = v34[3];
      a11.i16[2] = *v37;
      v11.i16[0] = v34[1];
      v11.i16[2] = v37[1];
      v12.i16[0] = v34[2];
      v12.i16[2] = v37[2];
      v13.i16[0] = *v34;
      v13.i16[2] = v37[3];
      v14.i16[0] = v35[3];
      v14.i16[2] = *(_WORD *)result;
      v15.i16[0] = v35[1];
      v15.i16[2] = *((_WORD *)result + 1);
      int8x8_t v15 = vand_s8(v15, (int8x8_t)0xFF000000FF00);
      v16.i16[0] = *v35;
      v16.i16[2] = *((_WORD *)result + 3);
      int8x8_t v16 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v16, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000);
      int8x8_t v38 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v13, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000), vand_s8((int8x8_t)v11, (int8x8_t)0xFF000000FF00));
      int8x8_t v13 = vorr_s8(v16, v15);
      v15.i16[0] = v35[2];
      v15.i16[2] = *((_WORD *)result + 2);
      int8x8_t v14 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v14, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000);
      uint8x8_t v39 = (uint8x8_t)vorr_s8(v38, vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v12, (int8x8_t)0xFFFF0000FFFFLL), 8uLL)));
      int8x16_t v40 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(v13, vorr_s8(v14, (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v15, (int8x8_t)0xFFFF0000FFFFLL), 8uLL))), v39), a4, 0), v39);
      int16x4_t v12 = vdup_n_s16((v32 >> 1) & 0x7F80);
      int16x4_t v11 = vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v40, v40, 8uLL), *(int16x4_t *)v40.i8), v12);
      a11 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v40.i8, v11), (int8x8_t)a4);
      v19 += v17;
      *a3++ = a11.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_WORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,true,false,false,true>(_WORD *result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, int8x8_t a10, int8x8_t a11)
{
  if (a2)
  {
    uint64_t v16 = **(void **)result;
    uint64_t v17 = *(void *)(*(void *)result + 16);
    int v18 = *((_DWORD *)result + 16);
    int v19 = *((_DWORD *)result + 14);
    int v20 = *((_DWORD *)result + 13) - 0x8000;
    int v21 = *((_DWORD *)result + 15) - 0x8000;
    do
    {
      uint64_t v22 = v16 + v17 * ((uint64_t)v21 >> 16);
      uint64_t v23 = v16 + v17 * ((uint64_t)(v21 + 0x10000) >> 16);
      unint64_t v24 = ((uint64_t)v20 >> 13) & 0xFFFFFFFFFFFFFFF8;
      int v25 = (__int16 *)(v22 + v24);
      int v26 = (__int16 *)(v23 + v24);
      unint64_t v27 = ((uint64_t)(v20 + 0x10000) >> 13) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v28 = (__int16 *)(v22 + v27);
      int v29 = (__int16 *)(v23 + v27);
      a10.i16[0] = v25[3];
      a11.i16[0] = v25[1];
      a10.i16[2] = *v28;
      a11.i16[2] = v28[1];
      v11.i16[0] = v25[2];
      v11.i16[2] = v28[2];
      v12.i16[0] = *v25;
      v12.i16[2] = v28[3];
      v13.i16[0] = v26[3];
      uint64_t result = v29 + 2;
      v13.i16[2] = *v29;
      v14.i16[0] = v26[1];
      v14.i16[2] = v29[1];
      v15.i16[0] = v26[2];
      int8x8_t v30 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(*(int8x8_t *)v12.i8, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000), vand_s8(a11, (int8x8_t)0xFF000000FF00));
      int8x8_t v31 = vand_s8(v14, (int8x8_t)0xFF000000FF00);
      v15.i16[2] = v29[2];
      v14.i16[0] = *v26;
      int8x8_t v32 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v11, (int8x8_t)0xFFFF0000FFFFLL), 8uLL));
      v14.i16[2] = v29[3];
      int8x8_t v33 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v14, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000), v31);
      uint32x2_t v34 = (uint32x2_t)vand_s8(v13, (int8x8_t)0xFFFF0000FFFFLL);
      int8x8_t v13 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v15, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      uint8x8_t v35 = (uint8x8_t)vorr_s8(v30, v32);
      int8x8_t v36 = vorr_s8(vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), v13);
      int16x8_t v12 = vdupq_n_s16((v21 >> 1) & 0x7F80);
      int8x16_t v37 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(v33, v36), v35), v12), v35);
      int16x4_t v11 = vdup_n_s16((v20 >> 1) & 0x7F80);
      a11 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL), *(int16x4_t *)v37.i8), v11);
      a10 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v37.i8, (int16x4_t)a11), (int8x8_t)0xFFFF0000FFFFLL);
      *a3++ = a10.i32[0];
      v20 += v19;
      v21 += v18;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  if (a2)
  {
    int v17 = result[14];
    int v18 = result[15];
    uint64_t v19 = *(void *)(*(void *)result + 16);
    uint64_t v20 = **(void **)result;
    int v21 = v18 + 0x8000;
    unsigned int v22 = v18 - 0x8000;
    uint64_t v23 = v20 + v19 * ((uint64_t)(v18 - 0x8000) >> 16);
    uint64_t v24 = v20 + v19 * ((uint64_t)v21 >> 16);
    a4.i32[0] = (v22 >> 1) & 0x7F80;
    int v25 = result[13] - 0x8000;
    do
    {
      unint64_t v26 = ((uint64_t)v25 >> 13) & 0xFFFFFFFFFFFFFFF8;
      unint64_t v27 = (__int16 *)(v23 + v26);
      uint64_t v28 = (__int16 *)(v24 + v26);
      unint64_t v29 = ((uint64_t)(v25 + 0x10000) >> 13) & 0xFFFFFFFFFFFFFFF8;
      int8x8_t v30 = (__int16 *)(v23 + v29);
      int8x8_t v31 = (_WORD *)(v24 + v29);
      a11.i16[0] = v27[3];
      a11.i16[2] = *v30;
      v11.i16[0] = v27[1];
      v11.i16[2] = v30[1];
      v12.i16[0] = v27[2];
      v12.i16[2] = v30[2];
      v13.i16[0] = *v27;
      v13.i16[2] = v30[3];
      uint64_t result = v31 + 2;
      v14.i16[0] = v28[3];
      v14.i16[2] = *v31;
      v15.i16[0] = v28[1];
      v15.i16[2] = v31[1];
      v16.i16[0] = v28[2];
      int8x8_t v32 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v13, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000), vand_s8((int8x8_t)v11, (int8x8_t)0xFF000000FF00));
      int8x8_t v33 = vand_s8(v15, (int8x8_t)0xFF000000FF00);
      v16.i16[2] = v31[2];
      v15.i16[0] = *v28;
      int8x8_t v34 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v12, (int8x8_t)0xFFFF0000FFFFLL), 8uLL));
      v15.i16[2] = v31[3];
      int8x8_t v35 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v15, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000), v33);
      int8x8_t v14 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v14, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000);
      int8x8_t v13 = vorr_s8(v14, (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v16, (int8x8_t)0xFFFF0000FFFFLL), 8uLL));
      uint8x8_t v36 = (uint8x8_t)vorr_s8(v32, v34);
      int8x16_t v37 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(v35, v13), v36), a4, 0), v36);
      int16x4_t v12 = vdup_n_s16((v25 >> 1) & 0x7F80);
      int16x4_t v11 = vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL), *(int16x4_t *)v37.i8), v12);
      a11 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v37.i8, v11), (int8x8_t)a4);
      *a3++ = a11.i32[0];
      v25 += v17;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,true,true,true,false>(uint64_t **a1, int a2, int *a3)
{
  if (a2)
  {
    int v4 = a2;
    unsigned int v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v40 = v13;
    int v38 = v17;
    uint64_t v39 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v38;
          uint64_t v8 = v39;
          int v13 = v40;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      int8x16_t v37 = (unsigned __int16 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 13) & 0xFFFFFFFFFFFFFFF8));
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = (*v37 << 8) & 0xFF0000 | (HIBYTE(v37[3]) << 24) | (*((unsigned __int8 *)v37 + 3) << 8) | *((unsigned __int8 *)v37 + 5);
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,true,true,false,false>(int *result, int a2, int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      int v13 = (unsigned __int16 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 13) & 0xFFFFFFFFFFFFFFF8));
      uint64_t result = (int *)*((unsigned __int8 *)v13 + 3);
      v10 += v9;
      v8 += v7;
      *a3++ = (*v13 << 8) & 0xFF0000 | (HIBYTE(v13[3]) << 24) | (result << 8) | *((unsigned __int8 *)v13 + 5);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,false,true,false,false>(_DWORD *result, int a2, int *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      int v9 = (unsigned __int16 *)(v7 + (((uint64_t)v8 >> 13) & 0xFFFFFFFFFFFFFFF8));
      v4 += v3;
      *a3++ = (*v9 << 8) & 0xFF0000 | (HIBYTE(v9[3]) << 24) | (*((unsigned __int8 *)v9 + 3) << 8) | *((unsigned __int8 *)v9 + 5);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,true,false,false,false>(_DWORD *result, int a2, int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      int v9 = (unsigned __int16 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 13) & 0xFFFFFFFFFFFFFFF8));
      v8 += v7;
      v6 += v5;
      *a3++ = (*v9 << 8) & 0xFF0000 | (HIBYTE(v9[3]) << 24) | (*((unsigned __int8 *)v9 + 3) << 8) | *((unsigned __int8 *)v9 + 5);
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,false,false,false,false>(uint64_t result, int a2, int *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      int v6 = (unsigned __int16 *)(v5 + (((uint64_t)v4 >> 13) & 0xFFFFFFFFFFFFFFF8));
      v4 += v3;
      *a3++ = (*v6 << 8) & 0xFF0000 | (HIBYTE(v6[3]) << 24) | (*((unsigned __int8 *)v6 + 3) << 8) | *((unsigned __int8 *)v6 + 5);
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    uint64_t v12 = *((unsigned int *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    int v14 = *((_DWORD *)result + 14);
    uint64_t v16 = (v8 - 0x8000);
    int v17 = v9 - 0x8000;
    float v18 = 1.0;
    int v19 = *((unsigned __int8 *)result + 48) - 1;
    int8x8_t v20 = (int8x8_t)vdup_n_s32(0x70707u);
    float32x2_t v59 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v60 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v58 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v64 = v14;
    int v65 = v8;
    int8x16_t v63 = result;
    int v62 = v9 - 0x8000;
    int v61 = v19;
    do
    {
      v21.f32[0] = (float)(v18 / v11) * (float)v15;
      v21.f32[1] = (float)(v18 / v11) * (float)v13;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v19)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = v5;
          uint64_t v28 = v9;
          uint64_t v29 = v12;
          uint64_t v30 = v16;
          float v31 = atan2f(v5[11] * (float)v22.i32[1], v5[10] * (float)v22.i32[0]);
          float v18 = 1.0;
          uint64_t v16 = v30;
          int v14 = v64;
          int v8 = v65;
          uint64_t v12 = v29;
          int v19 = v61;
          uint64_t v9 = v28;
          uint64_t v5 = v27;
          int v17 = v62;
          uint64_t result = v63;
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v32, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v33 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v60, *(float32x2_t *)(v5 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v59)), vmul_f32(v58, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v34 = vcvt_f32_s32(v22);
          float32x2_t v35 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v36 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          float32x2_t v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v37), (int8x8_t)v37, (int8x8_t)v34);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v36, (int8x8_t)v38);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      int v39 = v22.i32[0];
      if (v22.i32[0] >= (int)v16) {
        int v40 = v16;
      }
      else {
        int v40 = v22.i32[0];
      }
      if (v40 <= -32768) {
        int v40 = -32768;
      }
      unsigned int v41 = v40 + 0x8000;
      if (v22.i32[0] <= 0x8000) {
        int v39 = 0x8000;
      }
      int v42 = v39 - 0x8000;
      if (v42 >= v8) {
        int v42 = v8;
      }
      int v43 = v22.i32[1];
      if (v22.i32[1] >= v17) {
        int v44 = v17;
      }
      else {
        int v44 = v22.i32[1];
      }
      if (v44 <= -32768) {
        int v44 = -32768;
      }
      unsigned int v45 = v44 + 0x8000;
      if (v22.i32[1] <= 0x8000) {
        int v43 = 0x8000;
      }
      int v46 = v43 - 0x8000;
      if (v46 >= (int)v9) {
        int v46 = v9;
      }
      uint64_t v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      uint64_t v48 = v6 + v7 * HIWORD(v45);
      unint64_t v49 = ((uint64_t)v42 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v50 = (v41 >> 15) & 0x1FFFE;
      v22.i16[0] = *(_WORD *)(v47 + v49);
      v22.i16[2] = *(_WORD *)(v47 + v50);
      uint32x2_t v51 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v22, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      int8x8_t v52 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v51, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v51, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v22, 8uLL), (int8x8_t)0xF8000000F80000));
      int32x2_t v53 = (int32x2_t)vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v52, 3uLL), v20);
      int8x8_t v54 = vorr_s8(v52, (int8x8_t)v53);
      v53.i16[0] = *(_WORD *)(v48 + v49);
      v53.i16[2] = *(_WORD *)(v48 + v50);
      uint32x2_t v55 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v53, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      int8x8_t v56 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v55, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v55, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v53, 8uLL), (int8x8_t)0xF8000000F80000));
      int8x16_t v57 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(v56, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v56, 3uLL), v20)) | 0xFF000000FF000000), (uint8x8_t)(*(void *)&v54 | 0xFF000000FF000000)), vdupq_n_s16((v46 >> 1) & 0x7F80)), (uint8x8_t)(*(void *)&v54 | 0xFF000000FF000000));
      *(int16x4_t *)v57.i8 = vadd_s16(*(int16x4_t *)v57.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL), *(int16x4_t *)v57.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v57.i8, *(int8x8_t *)v57.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  if (a2)
  {
    uint64_t v12 = **(void **)result;
    uint64_t v13 = *(void *)(*(void *)result + 16);
    int v14 = *(_DWORD *)(*(void *)result + 32);
    int v15 = *(_DWORD *)(*(void *)result + 36);
    int v17 = *(_DWORD *)(result + 60);
    int v16 = *(_DWORD *)(result + 64);
    int v19 = *(_DWORD *)(result + 52);
    int v18 = *(_DWORD *)(result + 56);
    uint64_t result = 4294934528;
    int8x8_t v20 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      if (v19 >= v14 - 0x8000) {
        int v21 = v14 - 0x8000;
      }
      else {
        int v21 = v19;
      }
      if (v21 <= -32768) {
        int v22 = -32768;
      }
      else {
        int v22 = v21;
      }
      if (v19 <= 0x8000) {
        int v23 = 0x8000;
      }
      else {
        int v23 = v19;
      }
      int v24 = v23 - 0x8000;
      if (v24 >= v14) {
        int v24 = v14;
      }
      if (v17 >= v15 - 0x8000) {
        int v25 = v15 - 0x8000;
      }
      else {
        int v25 = v17;
      }
      if (v25 <= -32768) {
        int v25 = -32768;
      }
      if (v17 <= 0x8000) {
        int v26 = 0x8000;
      }
      else {
        int v26 = v17;
      }
      int v27 = v26 - 0x8000;
      unsigned int v28 = v25 + 0x8000;
      if (v27 >= v15) {
        int v29 = v15;
      }
      else {
        int v29 = v27;
      }
      uint64_t v30 = v12 + v13 * ((uint64_t)v29 >> 16);
      uint64_t v31 = v12 + v13 * HIWORD(v28);
      unint64_t v32 = ((uint64_t)v24 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v33 = ((v22 + 0x8000) >> 15) & 0x1FFFE;
      a11.i16[0] = *(_WORD *)(v30 + v32);
      a11.i16[2] = *(_WORD *)(v30 + v33);
      uint32x2_t v34 = vshr_n_u32((uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v11.i16[0] = *(_WORD *)(v31 + v32);
      v11.i16[2] = *(_WORD *)(v31 + v33);
      uint32x2_t v35 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v11, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      int8x8_t v36 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32((int32x2_t)a11, 8uLL), (int8x8_t)0xF8000000F80000));
      int8x8_t v37 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v35, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v35, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v11, 8uLL), (int8x8_t)0xF8000000F80000));
      int32x2_t v11 = (int32x2_t)vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v37, 3uLL), v20);
      unint64_t v38 = *(void *)&vorr_s8(v36, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v36, 3uLL), v20)) | 0xFF000000FF000000;
      int8x16_t v39 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(v37, (int8x8_t)v11) | 0xFF000000FF000000), (uint8x8_t)v38), vdupq_n_s16((v29 >> 1) & 0x7F80)), (uint8x8_t)v38);
      a11 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v39.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL), *(int16x4_t *)v39.i8), vdup_n_s16((v24 >> 1) & 0x7F80))), (int8x8_t)0xFFFF0000FFFFLL);
      v19 += v18;
      v17 += v16;
      *a3++ = a11.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v6 = result[14];
    int v7 = result[15];
    int v8 = result[13];
    int v9 = *(_DWORD *)(*(void *)result + 32);
    int v10 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v11 = *(void *)(*(void *)result + 16);
    uint64_t v12 = **(void **)result;
    if (v7 >= v10 - 0x8000) {
      int v13 = v10 - 0x8000;
    }
    else {
      int v13 = result[15];
    }
    if (v13 <= -32768) {
      int v13 = -32768;
    }
    if (v7 <= 0x8000) {
      int v7 = 0x8000;
    }
    int v14 = v7 - 0x8000;
    if (v14 >= v10) {
      int v15 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v15 = v14;
    }
    uint64_t v16 = v12 + v11 * ((uint64_t)v15 >> 16);
    uint64_t v17 = v12 + v11 * ((v13 + 0x8000) >> 16);
    a4.i32[0] = (v15 >> 1) & 0x7F80;
    int8x8_t v18 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      if (v8 >= v9 - 0x8000) {
        int v19 = v9 - 0x8000;
      }
      else {
        int v19 = v8;
      }
      if (v19 <= -32768) {
        int v19 = -32768;
      }
      unsigned int v20 = v19 + 0x8000;
      if (v8 <= 0x8000) {
        int v21 = 0x8000;
      }
      else {
        int v21 = v8;
      }
      int v22 = v21 - 0x8000;
      if (v22 >= v9) {
        int v22 = v9;
      }
      unint64_t v23 = ((uint64_t)v22 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      int v24 = (__int16 *)(v16 + v23);
      uint64_t v25 = (v20 >> 15) & 0x1FFFE;
      uint64_t result = (_DWORD *)(v17 + v23);
      v4.i16[0] = *v24;
      v4.i16[2] = *(_WORD *)(v16 + v25);
      uint32x2_t v26 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v4, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v5.i16[0] = *(_WORD *)result;
      v5.i16[2] = *(_WORD *)(v17 + v25);
      uint32x2_t v27 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v5, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      int8x8_t v28 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v26, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v26, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v4, 8uLL), (int8x8_t)0xF8000000F80000));
      int32x2_t v5 = vshl_n_s32(v5, 8uLL);
      int8x8_t v29 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v27, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v27, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)v5, (int8x8_t)0xF8000000F80000));
      unint64_t v30 = *(void *)&vorr_s8(v28, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v28, 3uLL), v18)) | 0xFF000000FF000000;
      int8x16_t v31 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(v29, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v29, 3uLL), v18)) | 0xFF000000FF000000), (uint8x8_t)v30), a4, 0), (uint8x8_t)v30);
      int32x2_t v4 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v31.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL), *(int16x4_t *)v31.i8), vdup_n_s16((v22 >> 1) & 0x7F80))), (int8x8_t)a4);
      v8 += v6;
      *a3++ = v4.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,true,false,false,true>(_DWORD *result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  if (a2)
  {
    uint64_t v12 = **(void **)result;
    uint64_t v13 = *(void *)(*(void *)result + 16);
    int v14 = result[16];
    int v15 = result[14];
    int v16 = result[13] - 0x8000;
    int v17 = result[15] - 0x8000;
    int8x8_t v18 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      uint64_t v19 = v12 + v13 * ((uint64_t)v17 >> 16);
      uint64_t v20 = v12 + v13 * ((uint64_t)(v17 + 0x10000) >> 16);
      unint64_t v21 = ((uint64_t)v16 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t result = (_DWORD *)(v19 + v21);
      unint64_t v22 = ((uint64_t)(v16 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      a11.i16[0] = *(_WORD *)(v19 + v21);
      a11.i16[2] = *(_WORD *)(v19 + v22);
      uint32x2_t v23 = vshr_n_u32((uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v11.i16[0] = *(_WORD *)(v20 + v21);
      v11.i16[2] = *(_WORD *)(v20 + v22);
      uint32x2_t v24 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v11, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      int8x8_t v25 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v23, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v23, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32((int32x2_t)a11, 8uLL), (int8x8_t)0xF8000000F80000));
      int8x8_t v26 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v24, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v24, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v11, 8uLL), (int8x8_t)0xF8000000F80000));
      unint64_t v27 = *(void *)&vorr_s8(v25, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v25, 3uLL), v18)) | 0xFF000000FF000000;
      int8x16_t v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(v26, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v26, 3uLL), v18)) | 0xFF000000FF000000), (uint8x8_t)v27), vdupq_n_s16((v17 >> 1) & 0x7F80)), (uint8x8_t)v27);
      a11 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v28.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), vdup_n_s16((v16 >> 1) & 0x7F80))), (int8x8_t)0xFFFF0000FFFFLL);
      *a3++ = a11.i32[0];
      v16 += v15;
      v17 += v14;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v6 = result[14];
    int v7 = result[15];
    uint64_t v8 = *(void *)(*(void *)result + 16);
    uint64_t v9 = **(void **)result;
    int v10 = v7 + 0x8000;
    unsigned int v11 = v7 - 0x8000;
    uint64_t v12 = v9 + v8 * ((uint64_t)(v7 - 0x8000) >> 16);
    uint64_t v13 = v9 + v8 * ((uint64_t)v10 >> 16);
    a4.i32[0] = (v11 >> 1) & 0x7F80;
    int v14 = result[13] - 0x8000;
    int8x8_t v15 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      unint64_t v16 = ((uint64_t)v14 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v17 = ((uint64_t)(v14 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v4.i16[0] = *(_WORD *)(v12 + v16);
      v4.i16[2] = *(_WORD *)(v12 + v17);
      uint32x2_t v18 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v4, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v5.i16[0] = *(_WORD *)(v13 + v16);
      v5.i16[2] = *(_WORD *)(v13 + v17);
      uint32x2_t v19 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v5, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      int8x8_t v20 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v18, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v18, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v4, 8uLL), (int8x8_t)0xF8000000F80000));
      int32x2_t v5 = vshl_n_s32(v5, 8uLL);
      int8x8_t v21 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v19, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v19, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)v5, (int8x8_t)0xF8000000F80000));
      unint64_t v22 = *(void *)&vorr_s8(v20, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v20, 3uLL), v15)) | 0xFF000000FF000000;
      int8x16_t v23 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(v21, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v21, 3uLL), v15)) | 0xFF000000FF000000), (uint8x8_t)v22), a4, 0), (uint8x8_t)v22);
      int32x2_t v4 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v23.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL), *(int16x4_t *)v23.i8), vdup_n_s16((v14 >> 1) & 0x7F80))), (int8x8_t)a4);
      *a3++ = v4.i32[0];
      v14 += v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v41 = v13;
    int v39 = v17;
    uint64_t v40 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v39;
          uint64_t v8 = v40;
          int v13 = v41;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      unsigned int v37 = *(unsigned __int16 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      unsigned int v38 = (32 * v37) & 0xF800 | (8 * ((v37 >> 1) & 0x1F)) & 0xFF07FFFF | ((unsigned __int16)v37 >> 11 << 19);
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = v38 | (v38 >> 3) & 0x7070707 | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      unsigned int v13 = *(unsigned __int16 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      uint64_t result = (int *)(v13 >> 1);
      unsigned int v14 = (32 * v13) & 0xF800 | (8 * (result & 0x1F)) | ((unsigned __int16)v13 >> 11 << 19);
      v10 += v9;
      v8 += v7;
      *a3++ = v14 | (v14 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      unsigned int v9 = *(unsigned __int16 *)(v7 + (((uint64_t)v8 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      unsigned int v10 = (32 * v9) & 0xF800 | (8 * ((v9 >> 1) & 0x1F)) & 0xFF07FFFF | ((unsigned __int16)v9 >> 11 << 19);
      v4 += v3;
      *a3++ = v10 | (v10 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      unsigned int v9 = *(unsigned __int16 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      unsigned int v10 = (32 * v9) & 0xF800 | (8 * ((v9 >> 1) & 0x1F)) & 0xFF07FFFF | ((unsigned __int16)v9 >> 11 << 19);
      v8 += v7;
      v6 += v5;
      *a3++ = v10 | (v10 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      unsigned int v6 = *(unsigned __int16 *)(v5 + (((uint64_t)v4 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      unsigned int v7 = (32 * v6) & 0xF800 | (8 * ((v6 >> 1) & 0x1F)) & 0xFF07FFFF | ((unsigned __int16)v6 >> 11 << 19);
      v4 += v3;
      *a3++ = v7 | (v7 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LX8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    int32x2_t v19 = vdup_n_s32(0x10101u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v22 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v57 = v8;
    int v58 = v12;
    int v55 = v9 - 0x8000;
    int v56 = v8 - 0x8000;
    int v54 = v18;
    do
    {
      v23.f32[0] = (float)(1.0 / v11) * (float)v15;
      v23.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v24 = vcvt_s32_f32(v23);
      switch(v18)
      {
        case 0:
          float32x2_t v25 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v24));
          float32x2_t v26 = vmul_f32(v25, v25);
          float32x2_t v27 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v26, 1), v26);
          v26.f32[0] = fmaxf(vaddv_f32(v26), 0.00001);
          v26.i32[0] = vmul_f32(v27, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v26, 0))).u32[0];
          float32x2_t v23 = vcvt_f32_u32(*(uint32x2_t *)(v5 + 6));
          v26.i32[1] = 0.5;
          float32x2_t v28 = vmul_f32(v26, v23);
          goto LABEL_8;
        case 1:
          float32x2_t v29 = result;
          uint64_t v30 = v7;
          uint64_t v31 = v9;
          uint64_t v32 = v14;
          float v33 = atan2f(v5[11] * (float)v24.i32[1], v5[10] * (float)v24.i32[0]);
          int v16 = v56;
          int v8 = v57;
          uint64_t v14 = v32;
          int v18 = v54;
          int v12 = v58;
          uint64_t v9 = v31;
          uint64_t v7 = v30;
          int v17 = v55;
          uint64_t result = v29;
          float32x2_t v23 = vcvt_f32_u32(*(uint32x2_t *)(v5 + 6));
          v34.i32[1] = 1056964608;
          v34.f32[0] = (float)(v33 * -10430.0) + 32768.0;
          float32x2_t v28 = vmul_f32(v34, v23);
          goto LABEL_8;
        case 2:
          float32x2_t v35 = vmul_f32(vcvt_f32_s32(v24), vmul_f32(v20, *(float32x2_t *)(v5 + 10)));
          float32x2_t v23 = *(float32x2_t *)((char *)result + 84);
          float32x2_t v28 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), v23, vminnm_f32(vsub_f32(v35, vrndm_f32(v35)), v21)), vmul_f32(v22, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v36 = vcvt_f32_s32(v24);
          float32x2_t v37 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v23 = vmul_f32(*(float32x2_t *)((char *)result + 84), v37);
          float32x2_t v38 = vmul_f32(*(float32x2_t *)((char *)result + 92), v37);
          float32x2_t v39 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v38, (int8x8_t)v36);
          float32x2_t v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v23, v39), (int8x8_t)v23, (int8x8_t)v39);
LABEL_8:
          int32x2_t v24 = vcvt_s32_f32(v28);
          break;
        default:
          break;
      }
      int v40 = v24.i32[0];
      if (v24.i32[0] >= v16) {
        int v41 = v16;
      }
      else {
        int v41 = v24.i32[0];
      }
      if (v41 <= -32768) {
        int v41 = -32768;
      }
      unsigned int v42 = v41 + 0x8000;
      if (v24.i32[0] <= 0x8000) {
        int v40 = 0x8000;
      }
      int v43 = v40 - 0x8000;
      int v44 = v24.i32[1];
      if (v43 >= v8) {
        int v43 = v8;
      }
      if (v24.i32[1] >= v17) {
        int v45 = v17;
      }
      else {
        int v45 = v24.i32[1];
      }
      if (v45 <= -32768) {
        int v45 = -32768;
      }
      unsigned int v46 = v45 + 0x8000;
      if (v24.i32[1] <= 0x8000) {
        int v44 = 0x8000;
      }
      int v47 = v44 - 0x8000;
      if (v47 >= (int)v9) {
        int v47 = v9;
      }
      uint64_t v48 = v6 + v7 * ((uint64_t)v47 >> 16);
      uint64_t v49 = v6 + v7 * HIWORD(v46);
      unint64_t v50 = ((uint64_t)v43 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v51 = (v42 >> 15) & 0x1FFFE;
      v24.i8[0] = *(unsigned char *)(v48 + v50);
      v24.i8[4] = *(unsigned char *)(v48 + v51);
      v23.i8[0] = *(unsigned char *)(v49 + v50);
      v23.i8[4] = *(unsigned char *)(v49 + v51);
      unint64_t v52 = *(void *)&vmul_s32((int32x2_t)vand_s8((int8x8_t)v24, (int8x8_t)0xFF000000FFLL), v19) | 0xFF000000FF000000;
      int8x16_t v53 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vmul_s32((int32x2_t)vand_s8((int8x8_t)v23, (int8x8_t)0xFF000000FFLL), v19) | 0xFF000000FF000000), (uint8x8_t)v52), vdupq_n_s16((v47 >> 1) & 0x7F80)), (uint8x8_t)v52);
      *(int16x4_t *)v53.i8 = vadd_s16(*(int16x4_t *)v53.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v53, v53, 8uLL), *(int16x4_t *)v53.i8), vdup_n_s16((v43 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v53.i8, *(int8x8_t *)v53.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LX8,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, int8x8_t a6, int8x8_t a7)
{
  if (a2)
  {
    uint64_t v7 = **(void **)result;
    uint64_t v8 = *(void *)(*(void *)result + 16);
    int v9 = *(_DWORD *)(*(void *)result + 32);
    int v10 = *(_DWORD *)(*(void *)result + 36);
    int v12 = *(_DWORD *)(result + 60);
    int v11 = *(_DWORD *)(result + 64);
    int v14 = *(_DWORD *)(result + 52);
    int v13 = *(_DWORD *)(result + 56);
    uint64_t result = 4294934528;
    int32x2_t v15 = vdup_n_s32(0x10101u);
    do
    {
      if (v14 >= v9 - 0x8000) {
        int v16 = v9 - 0x8000;
      }
      else {
        int v16 = v14;
      }
      if (v16 <= -32768) {
        int v16 = -32768;
      }
      if (v14 <= 0x8000) {
        int v17 = 0x8000;
      }
      else {
        int v17 = v14;
      }
      int v18 = v17 - 0x8000;
      if (v18 >= v9) {
        int v18 = v9;
      }
      if (v12 >= v10 - 0x8000) {
        int v19 = v10 - 0x8000;
      }
      else {
        int v19 = v12;
      }
      if (v19 <= -32768) {
        int v19 = -32768;
      }
      unsigned int v20 = v19 + 0x8000;
      if (v12 <= 0x8000) {
        int v21 = 0x8000;
      }
      else {
        int v21 = v12;
      }
      int v22 = v21 - 0x8000;
      if (v22 >= v10) {
        int v22 = v10;
      }
      uint64_t v23 = v7 + v8 * ((uint64_t)v22 >> 16);
      uint64_t v24 = v7 + v8 * HIWORD(v20);
      unint64_t v25 = ((uint64_t)v18 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v26 = ((v16 + 0x8000) >> 15) & 0x1FFFE;
      a6.i8[0] = *(unsigned char *)(v23 + v25);
      a7.i8[0] = *(unsigned char *)(v24 + v25);
      a6.i8[4] = *(unsigned char *)(v23 + v26);
      a7.i8[4] = *(unsigned char *)(v24 + v26);
      unint64_t v27 = *(void *)&vmul_s32((int32x2_t)vand_s8(a6, (int8x8_t)0xFF000000FFLL), v15) | 0xFF000000FF000000;
      int8x16_t v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vmul_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFF000000FFLL), v15) | 0xFF000000FF000000), (uint8x8_t)v27), vdupq_n_s16((v22 >> 1) & 0x7F80)), (uint8x8_t)v27);
      a7 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), vdup_n_s16((v18 >> 1) & 0x7F80));
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v28.i8, (int16x4_t)a7), (int8x8_t)0xFF000000FFLL);
      v14 += v13;
      v12 += v11;
      *a3++ = a6.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LX8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v39 = v13;
    int v37 = v17;
    uint64_t v38 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v37;
          uint64_t v8 = v38;
          int v13 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = (65793
             * *(unsigned __int8 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 15) & 0xFFFFFFFFFFFFFFFELL))) | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LX8,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      uint64_t result = (int *)(v3 + v4 * ((uint64_t)v12 >> 16));
      v10 += v9;
      v8 += v7;
      *a3++ = (65793 * *((unsigned __int8 *)result + (((uint64_t)v11 >> 15) & 0xFFFFFFFFFFFFFFFELL))) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    uint64_t v8 = *((unsigned int *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v60 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v65 = v12;
    uint64_t v64 = v6;
    int v62 = v9 - 0x8000;
    int v63 = v8 - 0x8000;
    int v61 = v18;
    do
    {
      v21.f32[0] = (float)(1.0 / v11) * (float)v15;
      v21.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v18)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          float32x2_t v21 = vcvt_f32_u32(*(uint32x2_t *)(v5 + 6));
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, v21);
          goto LABEL_8;
        case 1:
          float v27 = result;
          uint64_t v28 = v8;
          uint64_t v29 = v9;
          uint64_t v30 = v14;
          float v31 = atan2f(v5[11] * (float)v22.i32[1], v5[10] * (float)v22.i32[0]);
          uint64_t v14 = v30;
          int v17 = v62;
          int v16 = v63;
          int v12 = v65;
          uint64_t v9 = v29;
          uint64_t v8 = v28;
          int v18 = v61;
          uint64_t v6 = v64;
          uint64_t result = v27;
          float32x2_t v21 = vcvt_f32_u32(*(uint32x2_t *)(v5 + 6));
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v32, v21);
          goto LABEL_8;
        case 2:
          float32x2_t v33 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v60, *(float32x2_t *)(v5 + 10)));
          float32x2_t v21 = *(float32x2_t *)((char *)result + 84);
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), v21, vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v34 = vcvt_f32_s32(v22);
          float32x2_t v35 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v21 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          float32x2_t v36 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          float32x2_t v37 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v36), (int8x8_t)v36, (int8x8_t)v34);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v21, v37), (int8x8_t)v21, (int8x8_t)v37);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      int v38 = v22.i32[0];
      if (v22.i32[0] >= v16) {
        int v39 = v16;
      }
      else {
        int v39 = v22.i32[0];
      }
      if (v39 <= -32768) {
        int v39 = -32768;
      }
      unsigned int v40 = v39 + 0x8000;
      if (v22.i32[0] <= 0x8000) {
        int v38 = 0x8000;
      }
      int v41 = v38 - 0x8000;
      if (v41 >= (int)v8) {
        int v41 = v8;
      }
      int v42 = v22.i32[1];
      if (v22.i32[1] >= v17) {
        int v43 = v17;
      }
      else {
        int v43 = v22.i32[1];
      }
      if (v43 <= -32768) {
        int v43 = -32768;
      }
      unsigned int v44 = v43 + 0x8000;
      if (v22.i32[1] <= 0x8000) {
        int v42 = 0x8000;
      }
      int v45 = v42 - 0x8000;
      if (v45 >= (int)v9) {
        int v45 = v9;
      }
      uint64_t v46 = v6 + v7 * ((uint64_t)v45 >> 16);
      uint64_t v47 = v6 + v7 * HIWORD(v44);
      unint64_t v48 = ((uint64_t)v41 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v49 = (__int8 *)(v46 + v48);
      unint64_t v50 = (__int8 *)(v47 + v48);
      uint64_t v51 = (v40 >> 15) & 0x1FFFE;
      unint64_t v52 = (__int8 *)(v46 + v51);
      int8x16_t v53 = (__int8 *)(v47 + v51);
      v22.i8[0] = *v49;
      v22.i8[4] = *v52;
      int8x8_t v54 = vand_s8((int8x8_t)v22, (int8x8_t)0xFF000000FFLL);
      v21.i8[0] = v49[1];
      v21.i8[4] = v52[1];
      int8x8_t v55 = (int8x8_t)vshl_n_s32((int32x2_t)v21, 0x18uLL);
      int32x2_t v56 = (int32x2_t)vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v54, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v54, (uint32x2_t)0x1000000008));
      uint8x8_t v57 = (uint8x8_t)vorr_s8((int8x8_t)v56, vorr_s8(v55, v54));
      v55.i8[0] = *v50;
      v55.i8[4] = *v53;
      v56.i8[0] = v50[1];
      v56.i8[4] = v53[1];
      int8x8_t v58 = vand_s8(v55, (int8x8_t)0xFF000000FFLL);
      int8x16_t v59 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v58, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v58, (uint32x2_t)0x1000000008)), vorr_s8((int8x8_t)vshl_n_s32(v56, 0x18uLL), v58)), v57), vdupq_n_s16((v45 >> 1) & 0x7F80)), v57);
      *(int16x4_t *)v59.i8 = vadd_s16(*(int16x4_t *)v59.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v59, v59, 8uLL), *(int16x4_t *)v59.i8), vdup_n_s16((v41 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v59.i8, *(int8x8_t *)v59.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA8,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, double a6, int8x8_t a7, int32x2_t a8, int8x8_t a9)
{
  if (a2)
  {
    uint64_t v9 = **(void **)result;
    uint64_t v10 = *(void *)(*(void *)result + 16);
    int v11 = *(_DWORD *)(*(void *)result + 32);
    int v12 = *(_DWORD *)(*(void *)result + 36);
    int v14 = *(_DWORD *)(result + 60);
    int v13 = *(_DWORD *)(result + 64);
    int v16 = *(_DWORD *)(result + 52);
    int v15 = *(_DWORD *)(result + 56);
    uint64_t result = 4294934528;
    do
    {
      if (v16 >= v11 - 0x8000) {
        int v17 = v11 - 0x8000;
      }
      else {
        int v17 = v16;
      }
      if (v17 <= -32768) {
        int v17 = -32768;
      }
      unsigned int v18 = v17 + 0x8000;
      if (v16 <= 0x8000) {
        int v19 = 0x8000;
      }
      else {
        int v19 = v16;
      }
      int v20 = v19 - 0x8000;
      if (v20 >= v11) {
        int v20 = v11;
      }
      if (v14 >= v12 - 0x8000) {
        int v21 = v12 - 0x8000;
      }
      else {
        int v21 = v14;
      }
      if (v21 <= -32768) {
        int v21 = -32768;
      }
      unsigned int v22 = v21 + 0x8000;
      if (v14 <= 0x8000) {
        int v23 = 0x8000;
      }
      else {
        int v23 = v14;
      }
      int v24 = v23 - 0x8000;
      if (v24 >= v12) {
        int v24 = v12;
      }
      uint64_t v25 = v9 + v10 * ((uint64_t)v24 >> 16);
      uint64_t v26 = v9 + v10 * HIWORD(v22);
      unint64_t v27 = ((uint64_t)v20 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v28 = (__int8 *)(v26 + v27);
      uint64_t v29 = (__int8 *)(v25 + v27);
      uint64_t v30 = (v18 >> 15) & 0x1FFFE;
      float v31 = (__int8 *)(v25 + v30);
      float32x2_t v32 = (__int8 *)(v26 + v30);
      a7.i8[0] = *v29;
      a8.i8[0] = v29[1];
      a7.i8[4] = *v31;
      a9.i8[0] = *v28;
      a8.i8[4] = v31[1];
      a9.i8[4] = *v32;
      int8x8_t v33 = vand_s8(a9, (int8x8_t)0xFF000000FFLL);
      int32x2_t v34 = (int32x2_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x1000000008);
      int8x8_t v35 = vand_s8(a7, (int8x8_t)0xFF000000FFLL);
      int8x8_t v36 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x800000010), (int8x8_t)v34);
      v34.i8[0] = v28[1];
      v34.i8[4] = v32[1];
      uint8x8_t v37 = (uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v35, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v35, (uint32x2_t)0x1000000008)), vorr_s8((int8x8_t)vshl_n_s32(a8, 0x18uLL), v35));
      int8x16_t v38 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(v36, vorr_s8((int8x8_t)vshl_n_s32(v34, 0x18uLL), v33)), v37), vdupq_n_s16((v24 >> 1) & 0x7F80)), v37);
      a9 = (int8x8_t)vdup_n_s16((v20 >> 1) & 0x7F80);
      a8 = (int32x2_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL), *(int16x4_t *)v38.i8), (int16x4_t)a9);
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v38.i8, (int16x4_t)a8), (int8x8_t)0xFF000000FFLL);
      v16 += v15;
      v14 += v13;
      *a3++ = a7.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v40 = v13;
    int v38 = v17;
    uint64_t v39 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v38;
          uint64_t v8 = v39;
          int v13 = v40;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      uint8x8_t v37 = (unsigned __int8 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = (*v37 << 8) | (*v37 << 16) | (v37[1] << 24) | *v37;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA8,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      int v13 = (unsigned __int8 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      int v14 = *v13;
      uint64_t result = (int *)((v14 << 8) | (v14 << 16));
      v10 += v9;
      v8 += v7;
      *a3++ = result | (v13[1] << 24) | v14;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBXh,unsigned int,true,true,true,true>(uint64_t **a1, int a2, const unsigned __int8 *a3)
{
  v58[1] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    uint64_t v55 = (*a1)[2];
    uint64_t v56 = **a1;
    uint64_t v49 = (float *)*a1;
    float v5 = *((float *)a1[3] + 3);
    float v6 = *((float *)a1[2] + 3);
    int v7 = *((_DWORD *)a1 + 15);
    int v52 = *((_DWORD *)a1 + 16);
    int v53 = *((_DWORD *)*a1 + 9);
    int v8 = *((_DWORD *)a1 + 13);
    int v51 = *((_DWORD *)a1 + 14);
    int v54 = *((_DWORD *)*a1 + 8);
    int v9 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v10 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v11 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v12 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v50 = v9;
    do
    {
      v13.f32[0] = (float)(1.0 / v6) * (float)v8;
      v13.f32[1] = (float)(1.0 / v6) * (float)v7;
      int32x2_t v14 = vcvt_s32_f32(v13);
      switch(v9)
      {
        case 0:
          float32x2_t v15 = vmul_f32(*(float32x2_t *)(v49 + 10), vcvt_f32_s32(v14));
          float32x2_t v16 = vmul_f32(v15, v15);
          float32x2_t v17 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 1), v16);
          v16.f32[0] = fmaxf(vaddv_f32(v16), 0.00001);
          v16.i32[0] = vmul_f32(v17, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 0))).u32[0];
          v16.i32[1] = 0.5;
          float32x2_t v18 = vmul_f32(v16, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 1:
          float v19 = atan2f(v49[11] * (float)v14.i32[1], v49[10] * (float)v14.i32[0]);
          v20.i32[1] = 1056964608;
          v20.f32[0] = (float)(v19 * -10430.0) + 32768.0;
          float32x2_t v18 = vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v21 = vmul_f32(vcvt_f32_s32(v14), vmul_f32(v10, *(float32x2_t *)(v49 + 10)));
          float32x2_t v18 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v21, vrndm_f32(v21)), v11)), vmul_f32(v12, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v22 = vcvt_f32_s32(v14);
          float32x2_t v23 = vcvt_f32_s32(*(int32x2_t *)(v49 + 8));
          float32x2_t v24 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v23);
          float32x2_t v25 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v23);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, v25), (int8x8_t)v25, (int8x8_t)v22);
          float32x2_t v18 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, v26), (int8x8_t)v24, (int8x8_t)v26);
LABEL_8:
          int32x2_t v14 = vcvt_s32_f32(v18);
          break;
        default:
          break;
      }
      --v4;
      int v27 = v14.i32[0];
      int v28 = v54 - 0x8000;
      if (v14.i32[0] < v54 - 0x8000) {
        int v28 = v14.i32[0];
      }
      if (v28 <= -32768) {
        int v28 = -32768;
      }
      unsigned int v29 = v28 + 0x8000;
      if (v14.i32[0] <= 0x8000) {
        int v27 = 0x8000;
      }
      int v30 = v27 - 0x8000;
      if (v30 >= v54) {
        int v31 = v54;
      }
      else {
        int v31 = v30;
      }
      int v32 = v14.i32[1];
      if (v14.i32[1] >= v53 - 0x8000) {
        int v33 = v53 - 0x8000;
      }
      else {
        int v33 = v14.i32[1];
      }
      if (v33 <= -32768) {
        int v33 = -32768;
      }
      unsigned int v34 = v33 + 0x8000;
      if (v14.i32[1] <= 0x8000) {
        int v32 = 0x8000;
      }
      int v35 = v32 - 0x8000;
      if (v35 >= v53) {
        int v36 = v53;
      }
      else {
        int v36 = v35;
      }
      uint64_t v37 = v56 + v55 * ((uint64_t)v36 >> 16);
      uint64_t v38 = v56 + v55 * HIWORD(v34);
      signed int v39 = (v31 >> 13) & 0xFFFFFFF8;
      int v40 = (unsigned int *)(v38 + v39);
      uint64_t v57 = 0;
      v58[0] = 0;
      uint64_t v41 = (v29 >> 13) & 0x7FFF8;
      int v42 = (unsigned int *)(v37 + v41);
      int v43 = (unsigned int *)(v38 + v41);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)((char *)v58 + 4), (unsigned int *)(v37 + v39), a3);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)v58, v42, v44);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)((char *)&v57 + 4), v40, v45);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)&v57, v43, v46);
      int8x16_t v47 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v57, HIDWORD(v57)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0]))), vdupq_n_s16((v36 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0])));
      *(int16x4_t *)v47.i8 = vadd_s16(*(int16x4_t *)v47.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL), *(int16x4_t *)v47.i8), vdup_n_s16((v31 >> 1) & 0x7F80)));
      float v6 = v6 + v5;
      v8 += v51;
      v7 += v52;
      *(_DWORD *)uint64_t v3 = vuzp1_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v47.i8).u32[0];
      v3 += 4;
      int v9 = v50;
    }
    while (v4);
  }
}

int8x8_t CA::OGL::SW::Format::RGBXh::load_1(CA::OGL::SW::Format::RGBXh *this, unsigned int *a2, const unsigned __int8 *a3)
{
  float v18 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)a2);
  float v17 = CA::HalfFloat::to_float((CA::HalfFloat *)*((unsigned __int16 *)a2 + 1));
  float v5 = CA::HalfFloat::to_float((CA::HalfFloat *)*((unsigned __int16 *)a2 + 2));
  float32x2_t v6 = (float32x2_t)vdup_n_s32(0x437F0000u);
  if (v5 > 1.0) {
    float v5 = 1.0;
  }
  if (v5 >= 0.0) {
    float v7 = (float)(v5 * 255.0) + 0.5;
  }
  else {
    float v7 = 0.5;
  }
  unsigned int v8 = v7;
  __asm { FMOV            V0.2S, #1.0 }
  float32x2_t v14 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v17), LODWORD(v18)), _D0), (int8x8_t)_D0, (int8x8_t)__PAIR64__(LODWORD(v17), LODWORD(v18)));
  int32x2_t v15 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v14), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v6, v14))), (uint32x2_t)0x800000010);
  int8x8_t result = vorr_s8((int8x8_t)v15, (int8x8_t)vdup_lane_s32(v15, 1));
  *(_DWORD *)this = result.i32[0] | v8 | 0xFF000000;
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBXh,unsigned int,true,true,false,true>(int *a1, int a2, const unsigned __int8 *a3)
{
  v36[1] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    uint64_t v33 = *(void *)(*(void *)a1 + 16);
    uint64_t v34 = **(void **)a1;
    int v5 = a1[15];
    int v31 = *(_DWORD *)(*(void *)a1 + 36);
    int v32 = *(_DWORD *)(*(void *)a1 + 32);
    int v30 = a1[16];
    int v6 = a1[13];
    int v29 = a1[14];
    do
    {
      --v4;
      int v7 = v32 - 0x8000;
      if (v6 < v32 - 0x8000) {
        int v7 = v6;
      }
      if (v7 <= -32768) {
        int v7 = -32768;
      }
      unsigned int v8 = v7 + 0x8000;
      if (v6 <= 0x8000) {
        int v9 = 0x8000;
      }
      else {
        int v9 = v6;
      }
      int v10 = v9 - 0x8000;
      if (v10 >= v32) {
        int v11 = v32;
      }
      else {
        int v11 = v10;
      }
      if (v5 >= v31 - 0x8000) {
        int v12 = v31 - 0x8000;
      }
      else {
        int v12 = v5;
      }
      if (v12 <= -32768) {
        int v12 = -32768;
      }
      unsigned int v13 = v12 + 0x8000;
      if (v5 <= 0x8000) {
        int v14 = 0x8000;
      }
      else {
        int v14 = v5;
      }
      int v15 = v14 - 0x8000;
      if (v15 >= v31) {
        int v16 = v31;
      }
      else {
        int v16 = v15;
      }
      uint64_t v17 = v34 + v33 * ((uint64_t)v16 >> 16);
      uint64_t v18 = v34 + v33 * HIWORD(v13);
      signed int v19 = (v11 >> 13) & 0xFFFFFFF8;
      float32x2_t v20 = (unsigned int *)(v18 + v19);
      uint64_t v35 = 0;
      v36[0] = 0;
      uint64_t v21 = (v8 >> 13) & 0x7FFF8;
      float32x2_t v22 = (unsigned int *)(v17 + v21);
      float32x2_t v23 = (unsigned int *)(v18 + v21);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)((char *)v36 + 4), (unsigned int *)(v17 + v19), a3);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)v36, v22, v24);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)((char *)&v35 + 4), v20, v25);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)&v35, v23, v26);
      int8x16_t v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v35, HIDWORD(v35)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0]))), vdupq_n_s16((v16 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0])));
      *(int16x4_t *)v27.i8 = vadd_s16(*(int16x4_t *)v27.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), vdup_n_s16((v11 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v27.i8, *(int8x8_t *)v27.i8);
      v6 += v29;
      v5 += v30;
      *(_DWORD *)uint64_t v3 = result.i32[0];
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBXh,unsigned int,true,true,true,false>(uint64_t **a1, int a2, const unsigned __int8 *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    int v5 = (float *)*a1;
    uint64_t v35 = (*a1)[2];
    uint64_t v36 = **a1;
    int v6 = *((_DWORD *)*a1 + 8);
    int v7 = *((_DWORD *)*a1 + 9);
    float v8 = *((float *)a1[3] + 3);
    float v9 = *((float *)a1[2] + 3);
    int v10 = *((_DWORD *)a1 + 15);
    int v11 = *((_DWORD *)a1 + 16);
    int v12 = *((_DWORD *)a1 + 13);
    int v13 = *((_DWORD *)a1 + 14);
    int v14 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v15 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v16 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v17 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      int v37 = 0;
      v18.f32[0] = (float)(1.0 / v9) * (float)v12;
      v18.f32[1] = (float)(1.0 / v9) * (float)v10;
      int32x2_t v19 = vcvt_s32_f32(v18);
      switch(v14)
      {
        case 0:
          float32x2_t v20 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v19));
          float32x2_t v21 = vmul_f32(v20, v20);
          float32x2_t v22 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 1), v21);
          v21.f32[0] = fmaxf(vaddv_f32(v21), 0.00001);
          v21.i32[0] = vmul_f32(v22, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 0))).u32[0];
          v21.i32[1] = 0.5;
          float32x2_t v23 = vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float v24 = atan2f(v5[11] * (float)v19.i32[1], v5[10] * (float)v19.i32[0]);
          v25.i32[1] = 1056964608;
          v25.f32[0] = (float)(v24 * -10430.0) + 32768.0;
          float32x2_t v23 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v26 = vmul_f32(vcvt_f32_s32(v19), vmul_f32(v15, *(float32x2_t *)(v5 + 10)));
          float32x2_t v23 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v26, vrndm_f32(v26)), v16)), vmul_f32(v17, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v27 = vcvt_f32_s32(v19);
          float32x2_t v28 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v29 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v28);
          float32x2_t v30 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v28);
          float32x2_t v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v30), (int8x8_t)v30, (int8x8_t)v27);
          float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, v31), (int8x8_t)v29, (int8x8_t)v31);
LABEL_8:
          int32x2_t v19 = vcvt_s32_f32(v23);
          break;
        default:
          break;
      }
      --v4;
      int v32 = v19.i32[0] & ~(v19.i32[0] >> 31);
      if (v32 >= v6) {
        int v32 = v6;
      }
      int v33 = v19.i32[1] & ~(v19.i32[1] >> 31);
      if (v33 >= v7) {
        int v33 = v7;
      }
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)&v37, (unsigned int *)(v36 + v35 * ((uint64_t)v33 >> 16) + (int)((v32 >> 13) & 0xFFFFFFF8)), a3);
      float v9 = v9 + v8;
      v12 += v13;
      v10 += v11;
      *(_DWORD *)uint64_t v3 = v37;
      v3 += 4;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBXh,unsigned int,true,true,false,false>(int *a1, int a2, const unsigned __int8 *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    uint64_t v5 = **(void **)a1;
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    int v7 = *(_DWORD *)(*(void *)a1 + 32);
    int v8 = *(_DWORD *)(*(void *)a1 + 36);
    int v10 = a1[15];
    int v9 = a1[16];
    int v12 = a1[13];
    int v11 = a1[14];
    do
    {
      --v4;
      int v15 = 0;
      int v13 = v12 & ~(v12 >> 31);
      if (v13 >= v7) {
        int v13 = v7;
      }
      int v14 = v10 & ~(v10 >> 31);
      if (v14 >= v8) {
        int v14 = v8;
      }
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)&v15, (unsigned int *)(v5 + v6 * ((uint64_t)v14 >> 16) + (int)((v13 >> 13) & 0xFFFFFFF8)), a3);
      v12 += v11;
      v10 += v9;
      *(_DWORD *)uint64_t v3 = v15;
      v3 += 4;
    }
    while (v4);
  }
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v59 = v8;
    int v60 = v12;
    int v57 = v9 - 0x8000;
    int v58 = v8 - 0x8000;
    int v56 = v18;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v23));
          float32x2_t v25 = vmul_f32(v24, v24);
          float32x2_t v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          float32x2_t v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float32x2_t v28 = result;
          uint64_t v29 = v7;
          uint64_t v30 = v9;
          uint64_t v31 = v14;
          float v32 = atan2f(v5[11] * (float)v23.i32[1], v5[10] * (float)v23.i32[0]);
          int v16 = v58;
          int v8 = v59;
          uint64_t v14 = v31;
          int v18 = v56;
          int v12 = v60;
          uint64_t v9 = v30;
          uint64_t v7 = v29;
          int v17 = v57;
          int8x8_t result = v28;
          v33.i32[1] = 1056964608;
          v33.f32[0] = (float)(v32 * -10430.0) + 32768.0;
          float32x2_t v27 = vmul_f32(v33, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v34 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, *(float32x2_t *)(v5 + 10)));
          float32x2_t v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v34, vrndm_f32(v34)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v35 = vcvt_f32_s32(v23);
          float32x2_t v36 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 84), v36);
          float32x2_t v38 = vmul_f32(*(float32x2_t *)((char *)result + 92), v36);
          float32x2_t v39 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v38), (int8x8_t)v38, (int8x8_t)v35);
          float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v37, v39), (int8x8_t)v37, (int8x8_t)v39);
LABEL_8:
          int32x2_t v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      int v40 = v23.i32[0];
      if (v23.i32[0] >= v16) {
        int v41 = v16;
      }
      else {
        int v41 = v23.i32[0];
      }
      if (v41 <= -32768) {
        int v41 = -32768;
      }
      unsigned int v42 = v41 + 0x8000;
      if (v23.i32[0] <= 0x8000) {
        int v40 = 0x8000;
      }
      int v43 = v40 - 0x8000;
      if (v43 >= v8) {
        int v43 = v8;
      }
      int v44 = v23.i32[1];
      if (v23.i32[1] >= v17) {
        int v45 = v17;
      }
      else {
        int v45 = v23.i32[1];
      }
      if (v45 <= -32768) {
        int v45 = -32768;
      }
      unsigned int v46 = v45 + 0x8000;
      if (v23.i32[1] <= 0x8000) {
        int v44 = 0x8000;
      }
      int v47 = v44 - 0x8000;
      if (v47 >= (int)v9) {
        int v47 = v9;
      }
      uint64_t v48 = v6 + v7 * ((uint64_t)v47 >> 16);
      uint64_t v49 = v6 + v7 * HIWORD(v46);
      unint64_t v50 = ((uint64_t)v43 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v51 = (v42 >> 14) & 0x3FFFC;
      v52.i32[0] = *(_DWORD *)(v48 + v50);
      v52.i32[1] = *(_DWORD *)(v48 + v51);
      v53.i32[0] = *(_DWORD *)(v49 + v50);
      v53.i32[1] = *(_DWORD *)(v49 + v51);
      unint64_t v54 = *(void *)&vshr_n_u32(v52, 8uLL) | 0xFF000000FF000000;
      int8x16_t v55 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vshr_n_u32(v53, 8uLL) | 0xFF000000FF000000), (uint8x8_t)v54), vdupq_n_s16((v47 >> 1) & 0x7F80)), (uint8x8_t)v54);
      *(int16x4_t *)v55.i8 = vadd_s16(*(int16x4_t *)v55.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL), *(int16x4_t *)v55.i8), vdup_n_s16((v43 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v55.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = *(_DWORD *)(*(void *)a1 + 32);
    int v6 = *(_DWORD *)(*(void *)a1 + 36);
    int v8 = a1[15];
    int v7 = a1[16];
    int v10 = a1[13];
    int v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000) {
        int v11 = v5 - 0x8000;
      }
      else {
        int v11 = v10;
      }
      if (v11 <= -32768) {
        int v11 = -32768;
      }
      unsigned int v12 = v11 + 0x8000;
      if (v10 <= 0x8000) {
        int v13 = 0x8000;
      }
      else {
        int v13 = v10;
      }
      int v14 = v13 - 0x8000;
      if (v14 >= v5) {
        int v14 = v5;
      }
      if (v8 >= v6 - 0x8000) {
        int v15 = v6 - 0x8000;
      }
      else {
        int v15 = v8;
      }
      if (v15 <= -32768) {
        int v15 = -32768;
      }
      unsigned int v16 = v15 + 0x8000;
      if (v8 <= 0x8000) {
        int v17 = 0x8000;
      }
      else {
        int v17 = v8;
      }
      int v18 = v17 - 0x8000;
      if (v18 >= v6) {
        int v18 = v6;
      }
      uint64_t v19 = v3 + v4 * ((uint64_t)v18 >> 16);
      uint64_t v20 = v3 + v4 * HIWORD(v16);
      uint64_t v21 = (v12 >> 14) & 0x3FFFC;
      unint64_t v22 = ((uint64_t)v14 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v23.i32[0] = *(_DWORD *)(v19 + v22);
      v23.i32[1] = *(_DWORD *)(v19 + v21);
      v24.i32[0] = *(_DWORD *)(v20 + v22);
      v24.i32[1] = *(_DWORD *)(v20 + v21);
      unint64_t v25 = *(void *)&vshr_n_u32(v23, 8uLL) | 0xFF000000FF000000;
      int8x16_t v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vshr_n_u32(v24, 8uLL) | 0xFF000000FF000000), (uint8x8_t)v25), vdupq_n_s16((v18 >> 1) & 0x7F80)), (uint8x8_t)v25);
      *(int16x4_t *)v26.i8 = vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v14 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v26.i8, *(int8x8_t *)v26.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    int v6 = result[13];
    int v7 = *(_DWORD *)(*(void *)result + 32);
    int v8 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v9 = *(void *)(*(void *)result + 16);
    uint64_t v10 = **(void **)result;
    if (v5 >= v8 - 0x8000) {
      int v11 = v8 - 0x8000;
    }
    else {
      int v11 = result[15];
    }
    if (v11 <= -32768) {
      int v11 = -32768;
    }
    if (v5 <= 0x8000) {
      int v5 = 0x8000;
    }
    int v12 = v5 - 0x8000;
    if (v12 >= v8) {
      int v13 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v13 = v12;
    }
    uint64_t v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    uint64_t v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    do
    {
      if (v6 >= v7 - 0x8000) {
        int v16 = v7 - 0x8000;
      }
      else {
        int v16 = v6;
      }
      if (v16 <= -32768) {
        int v16 = -32768;
      }
      unsigned int v17 = v16 + 0x8000;
      if (v6 <= 0x8000) {
        int v18 = 0x8000;
      }
      else {
        int v18 = v6;
      }
      int v19 = v18 - 0x8000;
      if (v19 >= v7) {
        int v19 = v7;
      }
      uint64_t v20 = (v17 >> 14) & 0x3FFFC;
      int8x8_t result = (_DWORD *)(((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL);
      v21.i32[0] = *(_DWORD *)((char *)result + v14);
      v21.i32[1] = *(_DWORD *)(v14 + v20);
      v22.i32[0] = *(_DWORD *)((char *)result + v15);
      v22.i32[1] = *(_DWORD *)(v15 + v20);
      unint64_t v23 = *(void *)&vshr_n_u32(v21, 8uLL) | 0xFF000000FF000000;
      int8x16_t v24 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vshr_n_u32(v22, 8uLL) | 0xFF000000FF000000), (uint8x8_t)v23), a4, 0), (uint8x8_t)v23);
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v24.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), *(int16x4_t *)v24.i8), vdup_n_s16((v19 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = a1[16];
    int v6 = a1[14];
    int v7 = a1[13] - 0x8000;
    int v8 = a1[15] - 0x8000;
    do
    {
      uint64_t v9 = v3 + v4 * ((uint64_t)v8 >> 16);
      uint64_t v10 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      unint64_t v11 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v12 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v13.i32[0] = *(_DWORD *)(v9 + v12);
      v13.i32[1] = *(_DWORD *)(v9 + v11);
      v14.i32[0] = *(_DWORD *)(v10 + v12);
      v14.i32[1] = *(_DWORD *)(v10 + v11);
      unint64_t v15 = *(void *)&vshr_n_u32(v13, 8uLL) | 0xFF000000FF000000;
      int8x16_t v16 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vshr_n_u32(v14, 8uLL) | 0xFF000000FF000000), (uint8x8_t)v15), vdupq_n_s16((v8 >> 1) & 0x7F80)), (uint8x8_t)v15);
      *(int16x4_t *)v16.i8 = vadd_s16(*(int16x4_t *)v16.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), *(int16x4_t *)v16.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v16.i8, *(int8x8_t *)v16.i8);
      *a3++ = result.i32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    uint64_t v6 = *(void *)(*(void *)result + 16);
    uint64_t v7 = **(void **)result;
    int v8 = v5 + 0x8000;
    unsigned int v9 = v5 - 0x8000;
    uint64_t v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    uint64_t v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    int v12 = result[13] - 0x8000;
    do
    {
      unint64_t v13 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v14 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v15.i32[0] = *(_DWORD *)(v10 + v13);
      v15.i32[1] = *(_DWORD *)(v10 + v14);
      v16.i32[0] = *(_DWORD *)(v11 + v13);
      v16.i32[1] = *(_DWORD *)(v11 + v14);
      unint64_t v17 = *(void *)&vshr_n_u32(v15, 8uLL) | 0xFF000000FF000000;
      int8x16_t v18 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vshr_n_u32(v16, 8uLL) | 0xFF000000FF000000), (uint8x8_t)v17), a4, 0), (uint8x8_t)v17);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v18.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), *(int16x4_t *)v18.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v39 = v13;
    int v37 = v17;
    uint64_t v38 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v37;
          uint64_t v8 = v38;
          int v13 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = (*(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) >> 8) | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      v10 += v9;
      v8 += v7;
      *a3++ = (*(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) >> 8) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      v4 += v3;
      *a3++ = (*(_DWORD *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) >> 8) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      unsigned int v9 = (*(_DWORD *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) >> 8) | 0xFF000000;
      v8 += v7;
      v6 += v5;
      *a3++ = v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      unsigned int v6 = (*(_DWORD *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) >> 8) | 0xFF000000;
      v4 += v3;
      *a3++ = v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v59 = v8;
    int v60 = v12;
    int v57 = v9 - 0x8000;
    int v58 = v8 - 0x8000;
    int v56 = v18;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v23));
          float32x2_t v25 = vmul_f32(v24, v24);
          float32x2_t v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          float32x2_t v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float32x2_t v28 = result;
          uint64_t v29 = v7;
          uint64_t v30 = v9;
          uint64_t v31 = v14;
          float v32 = atan2f(v5[11] * (float)v23.i32[1], v5[10] * (float)v23.i32[0]);
          int v16 = v58;
          int v8 = v59;
          uint64_t v14 = v31;
          int v18 = v56;
          int v12 = v60;
          uint64_t v9 = v30;
          uint64_t v7 = v29;
          int v17 = v57;
          int8x8_t result = v28;
          v33.i32[1] = 1056964608;
          v33.f32[0] = (float)(v32 * -10430.0) + 32768.0;
          float32x2_t v27 = vmul_f32(v33, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v34 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, *(float32x2_t *)(v5 + 10)));
          float32x2_t v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v34, vrndm_f32(v34)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v35 = vcvt_f32_s32(v23);
          float32x2_t v36 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 84), v36);
          float32x2_t v38 = vmul_f32(*(float32x2_t *)((char *)result + 92), v36);
          float32x2_t v39 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v38), (int8x8_t)v38, (int8x8_t)v35);
          float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v37, v39), (int8x8_t)v37, (int8x8_t)v39);
LABEL_8:
          int32x2_t v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      int v40 = v23.i32[0];
      if (v23.i32[0] >= v16) {
        int v41 = v16;
      }
      else {
        int v41 = v23.i32[0];
      }
      if (v41 <= -32768) {
        int v41 = -32768;
      }
      unsigned int v42 = v41 + 0x8000;
      if (v23.i32[0] <= 0x8000) {
        int v40 = 0x8000;
      }
      int v43 = v40 - 0x8000;
      if (v43 >= v8) {
        int v43 = v8;
      }
      int v44 = v23.i32[1];
      if (v23.i32[1] >= v17) {
        int v45 = v17;
      }
      else {
        int v45 = v23.i32[1];
      }
      if (v45 <= -32768) {
        int v45 = -32768;
      }
      unsigned int v46 = v45 + 0x8000;
      if (v23.i32[1] <= 0x8000) {
        int v44 = 0x8000;
      }
      int v47 = v44 - 0x8000;
      if (v47 >= (int)v9) {
        int v47 = v9;
      }
      uint64_t v48 = v6 + v7 * ((uint64_t)v47 >> 16);
      uint64_t v49 = v6 + v7 * HIWORD(v46);
      unint64_t v50 = ((uint64_t)v43 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v51 = (v42 >> 14) & 0x3FFFC;
      HIDWORD(v53) = *(_DWORD *)(v48 + v50);
      LODWORD(v53) = HIDWORD(v53);
      unsigned int v52 = v53 >> 8;
      HIDWORD(v53) = *(_DWORD *)(v48 + v51);
      LODWORD(v53) = HIDWORD(v53);
      LODWORD(v48) = v53 >> 8;
      HIDWORD(v53) = *(_DWORD *)(v49 + v50);
      LODWORD(v53) = HIDWORD(v53);
      LODWORD(v50) = v53 >> 8;
      HIDWORD(v53) = *(_DWORD *)(v49 + v51);
      LODWORD(v53) = HIDWORD(v53);
      v54.i32[0] = v50;
      v54.i32[1] = v53 >> 8;
      int8x16_t v55 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v54, (uint8x8_t)__PAIR64__(v48, v52)), vdupq_n_s16((v47 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v48, v52));
      *(int16x4_t *)v55.i8 = vadd_s16(*(int16x4_t *)v55.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL), *(int16x4_t *)v55.i8), vdup_n_s16((v43 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v55.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = *(_DWORD *)(*(void *)a1 + 32);
    int v6 = *(_DWORD *)(*(void *)a1 + 36);
    int v8 = a1[15];
    int v7 = a1[16];
    int v10 = a1[13];
    int v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000) {
        int v11 = v5 - 0x8000;
      }
      else {
        int v11 = v10;
      }
      if (v11 <= -32768) {
        int v11 = -32768;
      }
      if (v10 <= 0x8000) {
        int v12 = 0x8000;
      }
      else {
        int v12 = v10;
      }
      int v13 = v12 - 0x8000;
      if (v13 >= v5) {
        int v13 = v5;
      }
      if (v8 >= v6 - 0x8000) {
        int v14 = v6 - 0x8000;
      }
      else {
        int v14 = v8;
      }
      if (v14 <= -32768) {
        int v14 = -32768;
      }
      if (v8 <= 0x8000) {
        int v15 = 0x8000;
      }
      else {
        int v15 = v8;
      }
      int v16 = v15 - 0x8000;
      unsigned int v17 = v14 + 0x8000;
      if (v16 >= v6) {
        int v16 = v6;
      }
      uint64_t v18 = v3 + v4 * ((uint64_t)v16 >> 16);
      uint64_t v19 = v3 + v4 * HIWORD(v17);
      unint64_t v20 = ((uint64_t)v13 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v21 = ((v11 + 0x8000) >> 14) & 0x3FFFC;
      int v22 = *(_DWORD *)(v18 + v20);
      LODWORD(v18) = *(_DWORD *)(v18 + v21);
      HIDWORD(v24) = v22;
      LODWORD(v24) = v22;
      unsigned int v23 = v24 >> 8;
      HIDWORD(v24) = *(_DWORD *)(v19 + v20);
      LODWORD(v24) = HIDWORD(v24);
      LODWORD(v20) = v24 >> 8;
      LODWORD(v21) = *(_DWORD *)(v19 + v21);
      HIDWORD(v24) = v18;
      LODWORD(v24) = v18;
      LODWORD(v19) = v24 >> 8;
      HIDWORD(v24) = v21;
      LODWORD(v24) = v21;
      v25.i32[0] = v20;
      v25.i32[1] = v24 >> 8;
      int8x16_t v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v25, (uint8x8_t)__PAIR64__(v19, v23)), vdupq_n_s16((v16 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v19, v23));
      *(int16x4_t *)v26.i8 = vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v26.i8, *(int8x8_t *)v26.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

unint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,false,true,false,true>(unint64_t result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 56);
    int v5 = *(_DWORD *)(result + 60);
    int v6 = *(_DWORD *)(result + 52);
    int v7 = *(_DWORD *)(*(void *)result + 32);
    int v8 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v9 = *(void *)(*(void *)result + 16);
    uint64_t v10 = **(void **)result;
    if (v5 >= v8 - 0x8000) {
      int v11 = v8 - 0x8000;
    }
    else {
      int v11 = *(_DWORD *)(result + 60);
    }
    if (v11 <= -32768) {
      int v11 = -32768;
    }
    if (v5 <= 0x8000) {
      int v5 = 0x8000;
    }
    int v12 = v5 - 0x8000;
    if (v12 >= v8) {
      int v13 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v13 = v12;
    }
    uint64_t v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    uint64_t v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    do
    {
      if (v6 >= v7 - 0x8000) {
        int v16 = v7 - 0x8000;
      }
      else {
        int v16 = v6;
      }
      if (v16 <= -32768) {
        int v16 = -32768;
      }
      unsigned int v17 = v16 + 0x8000;
      if (v6 <= 0x8000) {
        int v18 = 0x8000;
      }
      else {
        int v18 = v6;
      }
      int v19 = v18 - 0x8000;
      if (v19 >= v7) {
        int v19 = v7;
      }
      unint64_t v20 = ((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v21 = (v17 >> 14) & 0x3FFFC;
      HIDWORD(v23) = *(_DWORD *)(v14 + v21);
      LODWORD(v23) = HIDWORD(v23);
      unsigned int v22 = v23 >> 8;
      HIDWORD(v23) = *(_DWORD *)(v14 + v20);
      LODWORD(v23) = HIDWORD(v23);
      unsigned int v24 = v23 >> 8;
      HIDWORD(v23) = *(_DWORD *)(v15 + v20);
      LODWORD(v23) = HIDWORD(v23);
      int8x8_t result = (v23 >> 8);
      HIDWORD(v23) = *(_DWORD *)(v15 + v21);
      LODWORD(v23) = HIDWORD(v23);
      v25.i32[0] = result;
      v25.i32[1] = v23 >> 8;
      int8x16_t v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v25, (uint8x8_t)__PAIR64__(v22, v24)), a4, 0), (uint8x8_t)__PAIR64__(v22, v24));
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v19 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = a1[16];
    int v6 = a1[14];
    int v7 = a1[13] - 0x8000;
    int v8 = a1[15] - 0x8000;
    do
    {
      uint64_t v9 = v3 + v4 * ((uint64_t)v8 >> 16);
      uint64_t v10 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      unint64_t v11 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v12 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      HIDWORD(v14) = *(_DWORD *)(v9 + v11);
      LODWORD(v14) = HIDWORD(v14);
      unsigned int v13 = v14 >> 8;
      HIDWORD(v14) = *(_DWORD *)(v10 + v11);
      LODWORD(v14) = HIDWORD(v14);
      LODWORD(v11) = v14 >> 8;
      HIDWORD(v14) = *(_DWORD *)(v9 + v12);
      LODWORD(v14) = HIDWORD(v14);
      LODWORD(v9) = v14 >> 8;
      HIDWORD(v14) = *(_DWORD *)(v10 + v12);
      LODWORD(v14) = HIDWORD(v14);
      v15.i32[0] = v11;
      v15.i32[1] = v14 >> 8;
      int8x16_t v16 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v15, (uint8x8_t)__PAIR64__(v9, v13)), vdupq_n_s16((v8 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v9, v13));
      *(int16x4_t *)v16.i8 = vadd_s16(*(int16x4_t *)v16.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), *(int16x4_t *)v16.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v16.i8, *(int8x8_t *)v16.i8);
      *a3++ = result.i32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    uint64_t v6 = *(void *)(*(void *)result + 16);
    uint64_t v7 = **(void **)result;
    int v8 = v5 + 0x8000;
    unsigned int v9 = v5 - 0x8000;
    uint64_t v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    uint64_t v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    int v12 = result[13] - 0x8000;
    do
    {
      unint64_t v13 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v14 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      HIDWORD(v16) = *(_DWORD *)(v10 + v13);
      LODWORD(v16) = HIDWORD(v16);
      unsigned int v15 = v16 >> 8;
      HIDWORD(v16) = *(_DWORD *)(v10 + v14);
      LODWORD(v16) = HIDWORD(v16);
      unsigned int v17 = v16 >> 8;
      HIDWORD(v16) = *(_DWORD *)(v11 + v13);
      LODWORD(v16) = HIDWORD(v16);
      LODWORD(v13) = v16 >> 8;
      HIDWORD(v16) = *(_DWORD *)(v11 + v14);
      LODWORD(v16) = HIDWORD(v16);
      v18.i32[0] = v13;
      v18.i32[1] = v16 >> 8;
      int8x16_t v19 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v18, (uint8x8_t)__PAIR64__(v17, v15)), a4, 0), (uint8x8_t)__PAIR64__(v17, v15));
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v19.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL), *(int16x4_t *)v19.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v40 = v13;
    int v38 = v17;
    uint64_t v39 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v38;
          uint64_t v8 = v39;
          int v13 = v40;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      HIDWORD(v37) = *(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      LODWORD(v37) = HIDWORD(v37);
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = v37 >> 8;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      HIDWORD(v13) = *(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      LODWORD(v13) = HIDWORD(v13);
      v10 += v9;
      v8 += v7;
      *a3++ = v13 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,false,true,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      HIDWORD(v9) = *(_DWORD *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      LODWORD(v9) = HIDWORD(v9);
      v4 += v3;
      *a3++ = v9 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,true,false,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      HIDWORD(v9) = *(_DWORD *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      LODWORD(v9) = HIDWORD(v9);
      v8 += v7;
      v6 += v5;
      *a3++ = v9 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,false,false,false,false>(uint64_t result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      HIDWORD(v6) = *(_DWORD *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      LODWORD(v6) = HIDWORD(v6);
      v4 += v3;
      *a3++ = v6 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAf,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (uint32x2_t *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    uint64_t v8 = *((unsigned int *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V12.2S, #1.0 }
    int v89 = v12;
    float32x4_t v88 = result;
    int v86 = v9 - 0x8000;
    int v87 = v8 - 0x8000;
    int v85 = v18;
    do
    {
      v25.f32[0] = (float)(1.0 / v11) * (float)v15;
      v25.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v26 = vcvt_s32_f32(v25);
      switch(v18)
      {
        case 0:
          float32x2_t v27 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v26));
          float32x2_t v28 = vmul_f32(v27, v27);
          float32x2_t v29 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 1), v28);
          v28.f32[0] = fmaxf(vaddv_f32(v28), 0.00001);
          v28.i32[0] = vmul_f32(v29, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 0))).u32[0];
          v28.i32[1] = 0.5;
          float32x2_t v30 = vmul_f32(v28, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          float32x2_t v31 = v5;
          uint64_t v32 = v7;
          uint64_t v33 = v8;
          uint64_t v34 = v9;
          uint64_t v35 = v14;
          float v36 = atan2f(*(float *)&v5[5].i32[1] * (float)v26.i32[1], *(float *)v5[5].i32 * (float)v26.i32[0]);
          uint64_t v14 = v35;
          int v17 = v86;
          int v16 = v87;
          int v12 = v89;
          uint64_t v9 = v34;
          uint64_t v8 = v33;
          uint64_t v7 = v32;
          int v18 = v85;
          uint64_t v5 = v31;
          int8x8_t result = v88;
          v37.i32[1] = 1056964608;
          v37.f32[0] = (float)(v36 * -10430.0) + 32768.0;
          float32x2_t v30 = vmul_f32(v37, vcvt_f32_u32(v31[3]));
          goto LABEL_8;
        case 2:
          float32x2_t v38 = vmul_f32(vcvt_f32_s32(v26), vmul_f32((float32x2_t)vdup_n_s32(0x37800000u), (float32x2_t)v5[5]));
          float32x2_t v30 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v38, vrndm_f32(v38)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu))), vmul_f32((float32x2_t)vdup_n_s32(0x47800000u), vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          float32x2_t v39 = vcvt_f32_s32(v26);
          float32x2_t v40 = vcvt_f32_s32((int32x2_t)v5[4]);
          float32x2_t v41 = vmul_f32(*(float32x2_t *)((char *)result + 84), v40);
          float32x2_t v42 = vmul_f32(*(float32x2_t *)((char *)result + 92), v40);
          float32x2_t v43 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v39, v42), (int8x8_t)v42, (int8x8_t)v39);
          float32x2_t v30 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v41, v43), (int8x8_t)v41, (int8x8_t)v43);
LABEL_8:
          int32x2_t v26 = vcvt_s32_f32(v30);
          break;
        default:
          break;
      }
      int v44 = v26.i32[0];
      if (v26.i32[0] >= v16) {
        int v45 = v16;
      }
      else {
        int v45 = v26.i32[0];
      }
      if (v45 <= -32768) {
        int v45 = -32768;
      }
      unsigned int v46 = v45 + 0x8000;
      if (v26.i32[0] <= 0x8000) {
        int v44 = 0x8000;
      }
      int v47 = v44 - 0x8000;
      if (v47 >= (int)v8) {
        int v47 = v8;
      }
      int v48 = v26.i32[1];
      if (v26.i32[1] >= v17) {
        int v49 = v17;
      }
      else {
        int v49 = v26.i32[1];
      }
      if (v49 <= -32768) {
        int v49 = -32768;
      }
      unsigned int v50 = v49 + 0x8000;
      if (v26.i32[1] <= 0x8000) {
        int v48 = 0x8000;
      }
      int v51 = v48 - 0x8000;
      if (v51 >= (int)v9) {
        int v51 = v9;
      }
      uint64_t v52 = v6 + v7 * ((uint64_t)v51 >> 16);
      uint64_t v53 = v6 + v7 * HIWORD(v50);
      unint64_t v54 = ((uint64_t)v47 >> 12) & 0xFFFFFFFFFFFFFFF0;
      int8x16_t v55 = (float32x2_t *)(v52 + v54);
      int v56 = (float32x2_t *)(v53 + v54);
      uint64_t v57 = (v46 >> 12) & 0xFFFF0;
      int v58 = (float32x2_t *)(v52 + v57);
      float32x2_t v59 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v55, _D12), (int8x8_t)_D12, (int8x8_t)*v55);
      int32x2_t v60 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v59), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v59))), (uint32x2_t)0x800000010);
      int v61 = (float32x2_t *)(v53 + v57);
      int32x2_t v62 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v60, 1), (int8x8_t)v60);
      float32x2_t v63 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v55[1], _D12), (int8x8_t)_D12, (int8x8_t)v55[1]);
      int8x8_t v64 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v63), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v63)));
      float32x2_t v65 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v58, _D12), (int8x8_t)_D12, (int8x8_t)*v58);
      int32x2_t v66 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v65), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v65))), (uint32x2_t)0x800000010);
      int32x2_t v67 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v66, 1), (int8x8_t)v66);
      int8x8_t v68 = (int8x8_t)vzip1_s32(v62, v67);
      v62.i32[1] = 24;
      float32x2_t v69 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v58[1], _D12), (int8x8_t)_D12, (int8x8_t)v58[1]);
      int8x8_t v70 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v69), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v69)));
      v67.i32[1] = 24;
      uint8x8_t v71 = (uint8x8_t)vorr_s8((int8x8_t)vzip1_s32((int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v64, (uint32x2_t)v62), 1), v64), (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v70, (uint32x2_t)v67), 1), v70)), v68);
      float32x2_t v72 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v56, _D12), (int8x8_t)_D12, (int8x8_t)*v56);
      int32x2_t v73 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v72), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v72))), (uint32x2_t)0x800000010);
      int32x2_t v74 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v73, 1), (int8x8_t)v73);
      float32x2_t v75 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v56[1], _D12), (int8x8_t)_D12, (int8x8_t)v56[1]);
      int8x8_t v76 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v75), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v75)));
      float32x2_t v77 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v61, _D12), (int8x8_t)_D12, (int8x8_t)*v61);
      int32x2_t v78 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v77), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v77))), (uint32x2_t)0x800000010);
      int32x2_t v79 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v78, 1), (int8x8_t)v78);
      int8x8_t v80 = (int8x8_t)vzip1_s32(v74, v79);
      v74.i32[1] = 24;
      int32x2_t v81 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v76, (uint32x2_t)v74), 1), v76);
      float32x2_t v82 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v61[1], _D12), (int8x8_t)_D12, (int8x8_t)v61[1]);
      v79.i32[1] = 24;
      int8x8_t v83 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v82), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v82)));
      int8x16_t v84 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vzip1_s32(v81, (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v83, (uint32x2_t)v79), 1), v83)), v80), v71), vdupq_n_s16((v51 >> 1) & 0x7F80)), v71);
      *(int16x4_t *)v84.i8 = vadd_s16(*(int16x4_t *)v84.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v84, v84, 8uLL), *(int16x4_t *)v84.i8), vdup_n_s16((v47 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v84.i8, *(int8x8_t *)v84.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAf,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = *(_DWORD *)(result + 60);
    int v7 = *(_DWORD *)(result + 64);
    int v10 = *(_DWORD *)(result + 52);
    int v9 = *(_DWORD *)(result + 56);
    int8x8_t result = 4294934528;
    __asm { FMOV            V0.2S, #1.0 }
    float32x2_t v16 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      if (v10 >= v5 - 0x8000) {
        int v17 = v5 - 0x8000;
      }
      else {
        int v17 = v10;
      }
      if (v17 <= -32768) {
        int v18 = -32768;
      }
      else {
        int v18 = v17;
      }
      if (v10 <= 0x8000) {
        int v19 = 0x8000;
      }
      else {
        int v19 = v10;
      }
      int v20 = v19 - 0x8000;
      if (v20 >= v5) {
        int v20 = v5;
      }
      if (v8 >= v6 - 0x8000) {
        int v21 = v6 - 0x8000;
      }
      else {
        int v21 = v8;
      }
      if (v21 <= -32768) {
        int v21 = -32768;
      }
      if (v8 <= 0x8000) {
        int v22 = 0x8000;
      }
      else {
        int v22 = v8;
      }
      int v23 = v22 - 0x8000;
      unsigned int v24 = v21 + 0x8000;
      if (v23 >= v6) {
        int v25 = v6;
      }
      else {
        int v25 = v23;
      }
      uint64_t v26 = v3 + v4 * ((uint64_t)v25 >> 16);
      uint64_t v27 = v3 + v4 * HIWORD(v24);
      unint64_t v28 = ((uint64_t)v20 >> 12) & 0xFFFFFFFFFFFFFFF0;
      float32x2_t v29 = (float32x2_t *)(v27 + v28);
      uint64_t v30 = ((v18 + 0x8000) >> 12) & 0xFFFF0;
      float32x2_t v31 = (float32x2_t *)(v26 + v28);
      uint64_t v32 = (float32x2_t *)(v26 + v30);
      uint64_t v33 = (float32x2_t *)(v27 + v30);
      float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v31, _D0), (int8x8_t)_D0, (int8x8_t)*v31);
      uint32x2_t v35 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v34), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v34)));
      float32x2_t v36 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v31[1], _D0), (int8x8_t)_D0, (int8x8_t)v31[1]);
      int8x8_t v37 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v36), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v36)));
      float32x2_t v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v32, _D0), (int8x8_t)_D0, (int8x8_t)*v32);
      int32x2_t v39 = (int32x2_t)vshl_u32(v35, (uint32x2_t)0x800000010);
      int32x2_t v40 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v38), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v38))), (uint32x2_t)0x800000010);
      float32x2_t v41 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32[1], _D0), (int8x8_t)_D0, (int8x8_t)v32[1]);
      int32x2_t v42 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v39, 1), (int8x8_t)v39);
      int8x8_t v43 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v41), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v41)));
      int32x2_t v44 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v40, 1), (int8x8_t)v40);
      int8x8_t v45 = (int8x8_t)vzip1_s32(v42, v44);
      float32x2_t v46 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v29, _D0), (int8x8_t)_D0, (int8x8_t)*v29);
      int32x2_t v47 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v46), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v46))), (uint32x2_t)0x800000010);
      int32x2_t v48 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v47, 1), (int8x8_t)v47);
      v42.i32[1] = 24;
      float32x2_t v49 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29[1], _D0), (int8x8_t)_D0, (int8x8_t)v29[1]);
      v44.i32[1] = 24;
      float32x2_t v50 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v33, _D0), (int8x8_t)_D0, (int8x8_t)*v33);
      int32x2_t v51 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v50), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v50))), (uint32x2_t)0x800000010);
      int8x8_t v52 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v49), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v49)));
      int32x2_t v53 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v51, 1), (int8x8_t)v51);
      int8x8_t v54 = (int8x8_t)vzip1_s32(v48, v53);
      v48.i32[1] = 24;
      int32x2_t v55 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v52, (uint32x2_t)v48), 1), v52);
      float32x2_t v56 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v33[1], _D0), (int8x8_t)_D0, (int8x8_t)v33[1]);
      int32x2_t v57 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v37, (uint32x2_t)v42), 1), v37);
      int8x8_t v58 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v56), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v56)));
      v53.i32[1] = 24;
      uint8x8_t v59 = (uint8x8_t)vorr_s8((int8x8_t)vzip1_s32(v57, (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v43, (uint32x2_t)v44), 1), v43)), v45);
      int8x16_t v60 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vzip1_s32(v55, (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v58, (uint32x2_t)v53), 1), v58)), v54), v59), vdupq_n_s16((v25 >> 1) & 0x7F80)), v59);
      v10 += v9;
      v8 += v7;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v60.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v60, v60, 8uLL), *(int16x4_t *)v60.i8), vdup_n_s16((v20 >> 1) & 0x7F80))), (int8x8_t)_D0).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAf,unsigned int,true,true,true,false>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    __int32 v9 = *((_DWORD *)*result + 8);
    int v8 = *((_DWORD *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    int v14 = *((_DWORD *)result + 14);
    int v16 = *((unsigned __int8 *)result + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    float32x2_t v22 = (float32x2_t)vdup_n_s32(0x437F0000u);
    float32x2_t v47 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v23 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v24 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v50 = v12;
    int v48 = v16;
    float32x2_t v49 = result;
    do
    {
      v25.f32[0] = (float)(1.0 / v11) * (float)v15;
      v25.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v26 = vcvt_s32_f32(v25);
      switch(v16)
      {
        case 0:
          float32x2_t v27 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v26));
          float32x2_t v28 = vmul_f32(v27, v27);
          float32x2_t v29 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 1), v28);
          v28.f32[0] = fmaxf(vaddv_f32(v28), 0.00001);
          v28.i32[0] = vmul_f32(v29, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 0))).u32[0];
          v28.i32[1] = 0.5;
          float32x2_t v30 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float v31 = atan2f(v5[11] * (float)v26.i32[1], v5[10] * (float)v26.i32[0]);
          int v16 = v48;
          int8x8_t result = v49;
          int v12 = v50;
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          float32x2_t v30 = vmul_f32(v32, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v33 = vmul_f32(vcvt_f32_s32(v26), vmul_f32(v47, *(float32x2_t *)(v5 + 10)));
          float32x2_t v30 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v23)), vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v34 = vcvt_f32_s32(v26);
          float32x2_t v35 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v36 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          float32x2_t v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v37), (int8x8_t)v37, (int8x8_t)v34);
          float32x2_t v30 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v36, (int8x8_t)v38);
LABEL_8:
          int32x2_t v26 = vcvt_s32_f32(v30);
          break;
        default:
          break;
      }
      __int32 v39 = v26.i32[0] & ~(v26.i32[0] >> 31);
      if (v39 >= v9) {
        __int32 v39 = v9;
      }
      int v40 = v26.i32[1] & ~(v26.i32[1] >> 31);
      if (v40 >= v8) {
        int v40 = v8;
      }
      float32x2_t v41 = (float32x2_t *)(v6 + v7 * ((uint64_t)v40 >> 16) + (((uint64_t)v39 >> 12) & 0xFFFFFFFFFFFFFFF0));
      float32x2_t v42 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v41, _D11), (int8x8_t)_D11, (int8x8_t)*v41);
      int32x2_t v43 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v42), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v22, v42))), (uint32x2_t)0x800000010);
      int8x8_t v44 = vorr_s8((int8x8_t)vdup_lane_s32(v43, 1), (int8x8_t)v43);
      float32x2_t v45 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v41[1], _D11), (int8x8_t)_D11, (int8x8_t)v41[1]);
      int8x8_t v46 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v45), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v22, v45)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v46, (uint32x2_t)(v44.u32[0] | 0x1800000000)), 1), vorr_s8(v46, v44)).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAf,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    __asm { FMOV            V0.2S, #1.0 }
    float32x2_t v14 = (float32x2_t)vdup_n_s32(0x437F0000u);
    int v16 = result[13];
    int v15 = result[14];
    do
    {
      int v17 = v16 & ~(v16 >> 31);
      if (v17 >= v5) {
        int v17 = v5;
      }
      int v18 = v8 & ~(v8 >> 31);
      if (v18 >= v6) {
        int v18 = v6;
      }
      int8x8_t result = (int *)(v3 + v4 * ((uint64_t)v18 >> 16));
      int v19 = (float32x2_t *)((char *)result + (((uint64_t)v17 >> 12) & 0xFFFFFFFFFFFFFFF0));
      float32x2_t v20 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v19, _D0), (int8x8_t)_D0, (int8x8_t)*v19);
      int32x2_t v21 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v20), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v20))), (uint32x2_t)0x800000010);
      float32x2_t v22 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v19[1], _D0), (int8x8_t)_D0, (int8x8_t)v19[1]);
      int8x8_t v23 = vorr_s8((int8x8_t)vdup_lane_s32(v21, 1), (int8x8_t)v21);
      int8x8_t v24 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v22), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v22)));
      int8x8_t v25 = vorr_s8(v24, v23);
      v23.i32[1] = 24;
      v16 += v15;
      v8 += v7;
      *a3++ = vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v24, (uint32x2_t)v23), 1), v25).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAh,unsigned int,true,true,true,true>(uint64_t **a1, int a2, const unsigned __int8 *a3)
{
  v58[1] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    uint64_t v55 = (*a1)[2];
    uint64_t v56 = **a1;
    float32x2_t v49 = (float *)*a1;
    float v5 = *((float *)a1[3] + 3);
    float v6 = *((float *)a1[2] + 3);
    int v7 = *((_DWORD *)a1 + 15);
    int v52 = *((_DWORD *)a1 + 16);
    int v53 = *((_DWORD *)*a1 + 9);
    int v8 = *((_DWORD *)a1 + 13);
    int v51 = *((_DWORD *)a1 + 14);
    int v54 = *((_DWORD *)*a1 + 8);
    int v9 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v10 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v11 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v12 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v50 = v9;
    do
    {
      v13.f32[0] = (float)(1.0 / v6) * (float)v8;
      v13.f32[1] = (float)(1.0 / v6) * (float)v7;
      int32x2_t v14 = vcvt_s32_f32(v13);
      switch(v9)
      {
        case 0:
          float32x2_t v15 = vmul_f32(*(float32x2_t *)(v49 + 10), vcvt_f32_s32(v14));
          float32x2_t v16 = vmul_f32(v15, v15);
          float32x2_t v17 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 1), v16);
          v16.f32[0] = fmaxf(vaddv_f32(v16), 0.00001);
          v16.i32[0] = vmul_f32(v17, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 0))).u32[0];
          v16.i32[1] = 0.5;
          float32x2_t v18 = vmul_f32(v16, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 1:
          float v19 = atan2f(v49[11] * (float)v14.i32[1], v49[10] * (float)v14.i32[0]);
          v20.i32[1] = 1056964608;
          v20.f32[0] = (float)(v19 * -10430.0) + 32768.0;
          float32x2_t v18 = vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v21 = vmul_f32(vcvt_f32_s32(v14), vmul_f32(v10, *(float32x2_t *)(v49 + 10)));
          float32x2_t v18 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v21, vrndm_f32(v21)), v11)), vmul_f32(v12, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v22 = vcvt_f32_s32(v14);
          float32x2_t v23 = vcvt_f32_s32(*(int32x2_t *)(v49 + 8));
          float32x2_t v24 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v23);
          float32x2_t v25 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v23);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, v25), (int8x8_t)v25, (int8x8_t)v22);
          float32x2_t v18 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, v26), (int8x8_t)v24, (int8x8_t)v26);
LABEL_8:
          int32x2_t v14 = vcvt_s32_f32(v18);
          break;
        default:
          break;
      }
      --v4;
      int v27 = v14.i32[0];
      int v28 = v54 - 0x8000;
      if (v14.i32[0] < v54 - 0x8000) {
        int v28 = v14.i32[0];
      }
      if (v28 <= -32768) {
        int v28 = -32768;
      }
      unsigned int v29 = v28 + 0x8000;
      if (v14.i32[0] <= 0x8000) {
        int v27 = 0x8000;
      }
      int v30 = v27 - 0x8000;
      if (v30 >= v54) {
        int v31 = v54;
      }
      else {
        int v31 = v30;
      }
      int v32 = v14.i32[1];
      if (v14.i32[1] >= v53 - 0x8000) {
        int v33 = v53 - 0x8000;
      }
      else {
        int v33 = v14.i32[1];
      }
      if (v33 <= -32768) {
        int v33 = -32768;
      }
      unsigned int v34 = v33 + 0x8000;
      if (v14.i32[1] <= 0x8000) {
        int v32 = 0x8000;
      }
      int v35 = v32 - 0x8000;
      if (v35 >= v53) {
        int v36 = v53;
      }
      else {
        int v36 = v35;
      }
      uint64_t v37 = v56 + v55 * ((uint64_t)v36 >> 16);
      uint64_t v38 = v56 + v55 * HIWORD(v34);
      signed int v39 = (v31 >> 13) & 0xFFFFFFF8;
      int v40 = (unsigned int *)(v38 + v39);
      uint64_t v57 = 0;
      v58[0] = 0;
      uint64_t v41 = (v29 >> 13) & 0x7FFF8;
      float32x2_t v42 = (unsigned int *)(v37 + v41);
      int32x2_t v43 = (unsigned int *)(v38 + v41);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)((char *)v58 + 4), (unsigned int *)(v37 + v39), a3);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)v58, v42, v44);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)((char *)&v57 + 4), v40, v45);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)&v57, v43, v46);
      int8x16_t v47 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v57, HIDWORD(v57)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0]))), vdupq_n_s16((v36 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0])));
      *(int16x4_t *)v47.i8 = vadd_s16(*(int16x4_t *)v47.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL), *(int16x4_t *)v47.i8), vdup_n_s16((v31 >> 1) & 0x7F80)));
      float v6 = v6 + v5;
      v8 += v51;
      v7 += v52;
      *(_DWORD *)uint64_t v3 = vuzp1_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v47.i8).u32[0];
      v3 += 4;
      int v9 = v50;
    }
    while (v4);
  }
}

int8x8_t CA::OGL::SW::Format::RGBAh::load_1(CA::OGL::SW::Format::RGBAh *this, unsigned int *a2, const unsigned __int8 *a3)
{
  float v20 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)a2);
  float v19 = CA::HalfFloat::to_float((CA::HalfFloat *)*((unsigned __int16 *)a2 + 1));
  float v21 = CA::HalfFloat::to_float((CA::HalfFloat *)*((unsigned __int16 *)a2 + 2));
  float v5 = CA::HalfFloat::to_float((CA::HalfFloat *)*((unsigned __int16 *)a2 + 3));
  __asm { FMOV            V1.2S, #1.0 }
  float32x2_t v11 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v20), LODWORD(v19)), _D1), (int8x8_t)_D1, (int8x8_t)__PAIR64__(LODWORD(v20), LODWORD(v19)));
  float32x2_t v12 = (float32x2_t)vdup_n_s32(0x437F0000u);
  int32x2_t v13 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v11), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v11))), (uint32x2_t)0x1000000008);
  float32x2_t v14 = (float32x2_t)__PAIR64__(LODWORD(v5), LODWORD(v21));
  int8x8_t v15 = vorr_s8((int8x8_t)v13, (int8x8_t)vdup_lane_s32(v13, 1));
  float32x2_t v16 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v14, _D1), (int8x8_t)_D1, (int8x8_t)v14);
  int8x8_t v17 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v16), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v16)));
  int8x8_t result = vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v17, (uint32x2_t)(v15.u32[0] | 0x1800000000)), 1), vorr_s8(v17, v15));
  *(_DWORD *)this = result.i32[0];
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAh,unsigned int,true,true,false,true>(int *a1, int a2, const unsigned __int8 *a3)
{
  v36[1] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    uint64_t v33 = *(void *)(*(void *)a1 + 16);
    uint64_t v34 = **(void **)a1;
    int v5 = a1[15];
    int v31 = *(_DWORD *)(*(void *)a1 + 36);
    int v32 = *(_DWORD *)(*(void *)a1 + 32);
    int v30 = a1[16];
    int v6 = a1[13];
    int v29 = a1[14];
    do
    {
      --v4;
      int v7 = v32 - 0x8000;
      if (v6 < v32 - 0x8000) {
        int v7 = v6;
      }
      if (v7 <= -32768) {
        int v7 = -32768;
      }
      unsigned int v8 = v7 + 0x8000;
      if (v6 <= 0x8000) {
        int v9 = 0x8000;
      }
      else {
        int v9 = v6;
      }
      int v10 = v9 - 0x8000;
      if (v10 >= v32) {
        int v11 = v32;
      }
      else {
        int v11 = v10;
      }
      if (v5 >= v31 - 0x8000) {
        int v12 = v31 - 0x8000;
      }
      else {
        int v12 = v5;
      }
      if (v12 <= -32768) {
        int v12 = -32768;
      }
      unsigned int v13 = v12 + 0x8000;
      if (v5 <= 0x8000) {
        int v14 = 0x8000;
      }
      else {
        int v14 = v5;
      }
      int v15 = v14 - 0x8000;
      if (v15 >= v31) {
        int v16 = v31;
      }
      else {
        int v16 = v15;
      }
      uint64_t v17 = v34 + v33 * ((uint64_t)v16 >> 16);
      uint64_t v18 = v34 + v33 * HIWORD(v13);
      signed int v19 = (v11 >> 13) & 0xFFFFFFF8;
      float v20 = (unsigned int *)(v18 + v19);
      uint64_t v35 = 0;
      v36[0] = 0;
      uint64_t v21 = (v8 >> 13) & 0x7FFF8;
      float32x2_t v22 = (unsigned int *)(v17 + v21);
      float32x2_t v23 = (unsigned int *)(v18 + v21);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)((char *)v36 + 4), (unsigned int *)(v17 + v19), a3);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)v36, v22, v24);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)((char *)&v35 + 4), v20, v25);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)&v35, v23, v26);
      int8x16_t v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v35, HIDWORD(v35)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0]))), vdupq_n_s16((v16 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0])));
      *(int16x4_t *)v27.i8 = vadd_s16(*(int16x4_t *)v27.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), vdup_n_s16((v11 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v27.i8, *(int8x8_t *)v27.i8);
      v6 += v29;
      v5 += v30;
      *(_DWORD *)uint64_t v3 = result.i32[0];
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAh,unsigned int,true,true,true,false>(uint64_t **a1, int a2, const unsigned __int8 *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    int v5 = (float *)*a1;
    uint64_t v35 = (*a1)[2];
    uint64_t v36 = **a1;
    int v6 = *((_DWORD *)*a1 + 8);
    int v7 = *((_DWORD *)*a1 + 9);
    float v8 = *((float *)a1[3] + 3);
    float v9 = *((float *)a1[2] + 3);
    int v10 = *((_DWORD *)a1 + 15);
    int v11 = *((_DWORD *)a1 + 16);
    int v12 = *((_DWORD *)a1 + 13);
    int v13 = *((_DWORD *)a1 + 14);
    int v14 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v15 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v16 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v17 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      int v37 = 0;
      v18.f32[0] = (float)(1.0 / v9) * (float)v12;
      v18.f32[1] = (float)(1.0 / v9) * (float)v10;
      int32x2_t v19 = vcvt_s32_f32(v18);
      switch(v14)
      {
        case 0:
          float32x2_t v20 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v19));
          float32x2_t v21 = vmul_f32(v20, v20);
          float32x2_t v22 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 1), v21);
          v21.f32[0] = fmaxf(vaddv_f32(v21), 0.00001);
          v21.i32[0] = vmul_f32(v22, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 0))).u32[0];
          v21.i32[1] = 0.5;
          float32x2_t v23 = vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float v24 = atan2f(v5[11] * (float)v19.i32[1], v5[10] * (float)v19.i32[0]);
          v25.i32[1] = 1056964608;
          v25.f32[0] = (float)(v24 * -10430.0) + 32768.0;
          float32x2_t v23 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v26 = vmul_f32(vcvt_f32_s32(v19), vmul_f32(v15, *(float32x2_t *)(v5 + 10)));
          float32x2_t v23 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v26, vrndm_f32(v26)), v16)), vmul_f32(v17, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v27 = vcvt_f32_s32(v19);
          float32x2_t v28 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v29 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v28);
          float32x2_t v30 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v28);
          float32x2_t v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v30), (int8x8_t)v30, (int8x8_t)v27);
          float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, v31), (int8x8_t)v29, (int8x8_t)v31);
LABEL_8:
          int32x2_t v19 = vcvt_s32_f32(v23);
          break;
        default:
          break;
      }
      --v4;
      int v32 = v19.i32[0] & ~(v19.i32[0] >> 31);
      if (v32 >= v6) {
        int v32 = v6;
      }
      int v33 = v19.i32[1] & ~(v19.i32[1] >> 31);
      if (v33 >= v7) {
        int v33 = v7;
      }
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)&v37, (unsigned int *)(v36 + v35 * ((uint64_t)v33 >> 16) + (int)((v32 >> 13) & 0xFFFFFFF8)), a3);
      float v9 = v9 + v8;
      v12 += v13;
      v10 += v11;
      *(_DWORD *)uint64_t v3 = v37;
      v3 += 4;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAh,unsigned int,true,true,false,false>(int *a1, int a2, const unsigned __int8 *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    uint64_t v5 = **(void **)a1;
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    int v7 = *(_DWORD *)(*(void *)a1 + 32);
    int v8 = *(_DWORD *)(*(void *)a1 + 36);
    int v10 = a1[15];
    int v9 = a1[16];
    int v12 = a1[13];
    int v11 = a1[14];
    do
    {
      --v4;
      int v15 = 0;
      int v13 = v12 & ~(v12 >> 31);
      if (v13 >= v7) {
        int v13 = v7;
      }
      int v14 = v10 & ~(v10 >> 31);
      if (v14 >= v8) {
        int v14 = v8;
      }
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)&v15, (unsigned int *)(v5 + v6 * ((uint64_t)v14 >> 16) + (int)((v13 >> 13) & 0xFFFFFFF8)), a3);
      v12 += v11;
      v10 += v9;
      *(_DWORD *)uint64_t v3 = v15;
      v3 += 4;
    }
    while (v4);
  }
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v59 = v8;
    int v60 = v12;
    int v57 = v9 - 0x8000;
    int v58 = v8 - 0x8000;
    int v56 = v18;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v23));
          float32x2_t v25 = vmul_f32(v24, v24);
          float32x2_t v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          float32x2_t v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float32x2_t v28 = result;
          uint64_t v29 = v7;
          uint64_t v30 = v9;
          uint64_t v31 = v14;
          float v32 = atan2f(v5[11] * (float)v23.i32[1], v5[10] * (float)v23.i32[0]);
          int v16 = v58;
          int v8 = v59;
          uint64_t v14 = v31;
          int v18 = v56;
          int v12 = v60;
          uint64_t v9 = v30;
          uint64_t v7 = v29;
          int v17 = v57;
          int8x8_t result = v28;
          v33.i32[1] = 1056964608;
          v33.f32[0] = (float)(v32 * -10430.0) + 32768.0;
          float32x2_t v27 = vmul_f32(v33, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v34 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, *(float32x2_t *)(v5 + 10)));
          float32x2_t v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v34, vrndm_f32(v34)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v35 = vcvt_f32_s32(v23);
          float32x2_t v36 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 84), v36);
          float32x2_t v38 = vmul_f32(*(float32x2_t *)((char *)result + 92), v36);
          float32x2_t v39 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v38), (int8x8_t)v38, (int8x8_t)v35);
          float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v37, v39), (int8x8_t)v37, (int8x8_t)v39);
LABEL_8:
          int32x2_t v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      int v40 = v23.i32[0];
      if (v23.i32[0] >= v16) {
        int v41 = v16;
      }
      else {
        int v41 = v23.i32[0];
      }
      if (v41 <= -32768) {
        int v41 = -32768;
      }
      unsigned int v42 = v41 + 0x8000;
      if (v23.i32[0] <= 0x8000) {
        int v40 = 0x8000;
      }
      int v43 = v40 - 0x8000;
      if (v43 >= v8) {
        int v43 = v8;
      }
      int v44 = v23.i32[1];
      if (v23.i32[1] >= v17) {
        int v45 = v17;
      }
      else {
        int v45 = v23.i32[1];
      }
      if (v45 <= -32768) {
        int v45 = -32768;
      }
      unsigned int v46 = v45 + 0x8000;
      if (v23.i32[1] <= 0x8000) {
        int v44 = 0x8000;
      }
      int v47 = v44 - 0x8000;
      if (v47 >= (int)v9) {
        int v47 = v9;
      }
      uint64_t v48 = v6 + v7 * ((uint64_t)v47 >> 16);
      uint64_t v49 = v6 + v7 * HIWORD(v46);
      unint64_t v50 = ((uint64_t)v43 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v51 = (v42 >> 14) & 0x3FFFC;
      v52.i32[0] = *(_DWORD *)(v48 + v50);
      v52.i32[1] = *(_DWORD *)(v48 + v51);
      v53.i32[0] = *(_DWORD *)(v49 + v50);
      v53.i32[1] = *(_DWORD *)(v49 + v51);
      unint64_t v54 = *(void *)&vshr_n_u32((uint32x2_t)vrev32_s8(v52), 8uLL) | 0xFF000000FF000000;
      int8x16_t v55 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vrev32_s8(v53), 8uLL) | 0xFF000000FF000000), (uint8x8_t)v54), vdupq_n_s16((v47 >> 1) & 0x7F80)), (uint8x8_t)v54);
      *(int16x4_t *)v55.i8 = vadd_s16(*(int16x4_t *)v55.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL), *(int16x4_t *)v55.i8), vdup_n_s16((v43 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v55.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = *(_DWORD *)(*(void *)a1 + 32);
    int v6 = *(_DWORD *)(*(void *)a1 + 36);
    int v8 = a1[15];
    int v7 = a1[16];
    int v10 = a1[13];
    int v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000) {
        int v11 = v5 - 0x8000;
      }
      else {
        int v11 = v10;
      }
      if (v11 <= -32768) {
        int v11 = -32768;
      }
      if (v10 <= 0x8000) {
        int v12 = 0x8000;
      }
      else {
        int v12 = v10;
      }
      int v13 = v12 - 0x8000;
      if (v13 >= v5) {
        int v13 = v5;
      }
      if (v8 >= v6 - 0x8000) {
        int v14 = v6 - 0x8000;
      }
      else {
        int v14 = v8;
      }
      if (v14 <= -32768) {
        int v14 = -32768;
      }
      if (v8 <= 0x8000) {
        int v15 = 0x8000;
      }
      else {
        int v15 = v8;
      }
      int v16 = v15 - 0x8000;
      unsigned int v17 = v14 + 0x8000;
      if (v16 >= v6) {
        int v16 = v6;
      }
      uint64_t v18 = v3 + v4 * ((uint64_t)v16 >> 16);
      uint64_t v19 = v3 + v4 * HIWORD(v17);
      unint64_t v20 = ((uint64_t)v13 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v21 = ((v11 + 0x8000) >> 14) & 0x3FFFC;
      v22.i32[0] = *(_DWORD *)(v18 + v20);
      v23.i32[0] = *(_DWORD *)(v19 + v20);
      v22.i32[1] = *(_DWORD *)(v18 + v21);
      v23.i32[1] = *(_DWORD *)(v19 + v21);
      unint64_t v24 = *(void *)&vshr_n_u32((uint32x2_t)vrev32_s8(v22), 8uLL) | 0xFF000000FF000000;
      int8x16_t v25 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vrev32_s8(v23), 8uLL) | 0xFF000000FF000000), (uint8x8_t)v24), vdupq_n_s16((v16 >> 1) & 0x7F80)), (uint8x8_t)v24);
      *(int16x4_t *)v25.i8 = vadd_s16(*(int16x4_t *)v25.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL), *(int16x4_t *)v25.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v25.i8, *(int8x8_t *)v25.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    int v6 = result[13];
    int v7 = *(_DWORD *)(*(void *)result + 32);
    int v8 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v9 = *(void *)(*(void *)result + 16);
    uint64_t v10 = **(void **)result;
    if (v5 >= v8 - 0x8000) {
      int v11 = v8 - 0x8000;
    }
    else {
      int v11 = result[15];
    }
    if (v11 <= -32768) {
      int v11 = -32768;
    }
    if (v5 <= 0x8000) {
      int v5 = 0x8000;
    }
    int v12 = v5 - 0x8000;
    if (v12 >= v8) {
      int v13 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v13 = v12;
    }
    uint64_t v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    uint64_t v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    do
    {
      if (v6 >= v7 - 0x8000) {
        int v16 = v7 - 0x8000;
      }
      else {
        int v16 = v6;
      }
      if (v16 <= -32768) {
        int v16 = -32768;
      }
      unsigned int v17 = v16 + 0x8000;
      if (v6 <= 0x8000) {
        int v18 = 0x8000;
      }
      else {
        int v18 = v6;
      }
      int v19 = v18 - 0x8000;
      if (v19 >= v7) {
        int v19 = v7;
      }
      int8x8_t result = (_DWORD *)(((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v20 = (v17 >> 14) & 0x3FFFC;
      v21.i32[0] = *(_DWORD *)((char *)result + v14);
      v21.i32[1] = *(_DWORD *)(v14 + v20);
      v22.i32[0] = *(_DWORD *)((char *)result + v15);
      v22.i32[1] = *(_DWORD *)(v15 + v20);
      unint64_t v23 = *(void *)&vshr_n_u32((uint32x2_t)vrev32_s8(v21), 8uLL) | 0xFF000000FF000000;
      int8x16_t v24 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vrev32_s8(v22), 8uLL) | 0xFF000000FF000000), (uint8x8_t)v23), a4, 0), (uint8x8_t)v23);
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v24.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), *(int16x4_t *)v24.i8), vdup_n_s16((v19 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = a1[16];
    int v6 = a1[14];
    int v7 = a1[13] - 0x8000;
    int v8 = a1[15] - 0x8000;
    do
    {
      uint64_t v9 = v3 + v4 * ((uint64_t)v8 >> 16);
      uint64_t v10 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      unint64_t v11 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v12 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v13.i32[0] = *(_DWORD *)(v9 + v11);
      v13.i32[1] = *(_DWORD *)(v9 + v12);
      v14.i32[0] = *(_DWORD *)(v10 + v11);
      v14.i32[1] = *(_DWORD *)(v10 + v12);
      unint64_t v15 = *(void *)&vshr_n_u32((uint32x2_t)vrev32_s8(v13), 8uLL) | 0xFF000000FF000000;
      int8x16_t v16 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vrev32_s8(v14), 8uLL) | 0xFF000000FF000000), (uint8x8_t)v15), vdupq_n_s16((v8 >> 1) & 0x7F80)), (uint8x8_t)v15);
      *(int16x4_t *)v16.i8 = vadd_s16(*(int16x4_t *)v16.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), *(int16x4_t *)v16.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v16.i8, *(int8x8_t *)v16.i8);
      *a3++ = result.i32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    uint64_t v6 = *(void *)(*(void *)result + 16);
    uint64_t v7 = **(void **)result;
    int v8 = v5 + 0x8000;
    unsigned int v9 = v5 - 0x8000;
    uint64_t v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    uint64_t v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    int v12 = result[13] - 0x8000;
    do
    {
      unint64_t v13 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v14 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v15.i32[0] = *(_DWORD *)(v10 + v13);
      v15.i32[1] = *(_DWORD *)(v10 + v14);
      v16.i32[0] = *(_DWORD *)(v11 + v13);
      v16.i32[1] = *(_DWORD *)(v11 + v14);
      unint64_t v17 = *(void *)&vshr_n_u32((uint32x2_t)vrev32_s8(v15), 8uLL) | 0xFF000000FF000000;
      int8x16_t v18 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vrev32_s8(v16), 8uLL) | 0xFF000000FF000000), (uint8x8_t)v17), a4, 0), (uint8x8_t)v17);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v18.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), *(int16x4_t *)v18.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v39 = v13;
    int v37 = v17;
    uint64_t v38 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v37;
          uint64_t v8 = v38;
          int v13 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = (bswap32(*(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL))) >> 8) | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      v10 += v9;
      v8 += v7;
      *a3++ = (bswap32(*(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL))) >> 8) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      v4 += v3;
      *a3++ = (bswap32(*(_DWORD *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL))) >> 8) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      unsigned int v9 = bswap32(*(_DWORD *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      v8 += v7;
      v6 += v5;
      *a3++ = (v9 >> 8) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      unsigned int v6 = bswap32(*(_DWORD *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      v4 += v3;
      *a3++ = (v6 >> 8) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v59 = v8;
    int v60 = v12;
    int v57 = v9 - 0x8000;
    int v58 = v8 - 0x8000;
    int v56 = v18;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v23));
          float32x2_t v25 = vmul_f32(v24, v24);
          float32x2_t v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          float32x2_t v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float32x2_t v28 = result;
          uint64_t v29 = v7;
          uint64_t v30 = v9;
          uint64_t v31 = v14;
          float v32 = atan2f(v5[11] * (float)v23.i32[1], v5[10] * (float)v23.i32[0]);
          int v16 = v58;
          int v8 = v59;
          uint64_t v14 = v31;
          int v18 = v56;
          int v12 = v60;
          uint64_t v9 = v30;
          uint64_t v7 = v29;
          int v17 = v57;
          int8x8_t result = v28;
          v33.i32[1] = 1056964608;
          v33.f32[0] = (float)(v32 * -10430.0) + 32768.0;
          float32x2_t v27 = vmul_f32(v33, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v34 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, *(float32x2_t *)(v5 + 10)));
          float32x2_t v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v34, vrndm_f32(v34)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v35 = vcvt_f32_s32(v23);
          float32x2_t v36 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 84), v36);
          float32x2_t v38 = vmul_f32(*(float32x2_t *)((char *)result + 92), v36);
          float32x2_t v39 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v38), (int8x8_t)v38, (int8x8_t)v35);
          float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v37, v39), (int8x8_t)v37, (int8x8_t)v39);
LABEL_8:
          int32x2_t v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      int v40 = v23.i32[0];
      if (v23.i32[0] >= v16) {
        int v41 = v16;
      }
      else {
        int v41 = v23.i32[0];
      }
      if (v41 <= -32768) {
        int v41 = -32768;
      }
      unsigned int v42 = v41 + 0x8000;
      if (v23.i32[0] <= 0x8000) {
        int v40 = 0x8000;
      }
      int v43 = v40 - 0x8000;
      if (v43 >= v8) {
        int v43 = v8;
      }
      int v44 = v23.i32[1];
      if (v23.i32[1] >= v17) {
        int v45 = v17;
      }
      else {
        int v45 = v23.i32[1];
      }
      if (v45 <= -32768) {
        int v45 = -32768;
      }
      unsigned int v46 = v45 + 0x8000;
      if (v23.i32[1] <= 0x8000) {
        int v44 = 0x8000;
      }
      int v47 = v44 - 0x8000;
      if (v47 >= (int)v9) {
        int v47 = v9;
      }
      uint64_t v48 = v6 + v7 * ((uint64_t)v47 >> 16);
      unint64_t v49 = ((uint64_t)v43 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      HIDWORD(v51) = bswap32(*(_DWORD *)(v48 + v49));
      LODWORD(v51) = HIDWORD(v51);
      unsigned int v50 = v51 >> 8;
      uint64_t v52 = (v42 >> 14) & 0x3FFFC;
      HIDWORD(v51) = bswap32(*(_DWORD *)(v48 + v52));
      LODWORD(v51) = HIDWORD(v51);
      LODWORD(v48) = v51 >> 8;
      uint64_t v53 = v6 + v7 * HIWORD(v46);
      HIDWORD(v51) = bswap32(*(_DWORD *)(v53 + v49));
      LODWORD(v51) = HIDWORD(v51);
      LODWORD(v49) = v51 >> 8;
      HIDWORD(v51) = bswap32(*(_DWORD *)(v53 + v52));
      LODWORD(v51) = HIDWORD(v51);
      v54.i32[0] = v49;
      v54.i32[1] = v51 >> 8;
      int8x16_t v55 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v54, (uint8x8_t)__PAIR64__(v48, v50)), vdupq_n_s16((v47 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v48, v50));
      *(int16x4_t *)v55.i8 = vadd_s16(*(int16x4_t *)v55.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL), *(int16x4_t *)v55.i8), vdup_n_s16((v43 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v55.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = *(_DWORD *)(*(void *)a1 + 32);
    int v6 = *(_DWORD *)(*(void *)a1 + 36);
    int v8 = a1[15];
    int v7 = a1[16];
    int v10 = a1[13];
    int v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000) {
        int v11 = v5 - 0x8000;
      }
      else {
        int v11 = v10;
      }
      if (v11 <= -32768) {
        int v11 = -32768;
      }
      unsigned int v12 = v11 + 0x8000;
      if (v10 <= 0x8000) {
        int v13 = 0x8000;
      }
      else {
        int v13 = v10;
      }
      int v14 = v13 - 0x8000;
      if (v14 >= v5) {
        int v14 = v5;
      }
      if (v8 >= v6 - 0x8000) {
        int v15 = v6 - 0x8000;
      }
      else {
        int v15 = v8;
      }
      if (v15 <= -32768) {
        int v15 = -32768;
      }
      unsigned int v16 = v15 + 0x8000;
      if (v8 <= 0x8000) {
        int v17 = 0x8000;
      }
      else {
        int v17 = v8;
      }
      int v18 = v17 - 0x8000;
      if (v18 >= v6) {
        int v18 = v6;
      }
      uint64_t v19 = v3 + v4 * ((uint64_t)v18 >> 16);
      uint64_t v20 = v3 + v4 * HIWORD(v16);
      unint64_t v21 = ((uint64_t)v14 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v22 = (v12 >> 14) & 0x3FFFC;
      unsigned int v23 = bswap32(*(_DWORD *)(v19 + v21));
      HIDWORD(v24) = bswap32(*(_DWORD *)(v20 + v21));
      LODWORD(v24) = HIDWORD(v24);
      LODWORD(v21) = v24 >> 8;
      HIDWORD(v24) = v23;
      LODWORD(v24) = v23;
      unsigned int v25 = v24 >> 8;
      LODWORD(v19) = bswap32(*(_DWORD *)(v19 + v22));
      LODWORD(v22) = bswap32(*(_DWORD *)(v20 + v22));
      HIDWORD(v24) = v19;
      LODWORD(v24) = v19;
      LODWORD(v20) = v24 >> 8;
      HIDWORD(v24) = v22;
      LODWORD(v24) = v22;
      v26.i32[0] = v21;
      v26.i32[1] = v24 >> 8;
      int8x16_t v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v26, (uint8x8_t)__PAIR64__(v20, v25)), vdupq_n_s16((v18 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v20, v25));
      *(int16x4_t *)v27.i8 = vadd_s16(*(int16x4_t *)v27.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), vdup_n_s16((v14 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v27.i8, *(int8x8_t *)v27.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

unint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,false,true,false,true>(unint64_t result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 56);
    int v5 = *(_DWORD *)(result + 60);
    int v6 = *(_DWORD *)(result + 52);
    int v7 = *(_DWORD *)(*(void *)result + 32);
    int v8 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v9 = *(void *)(*(void *)result + 16);
    uint64_t v10 = **(void **)result;
    if (v5 >= v8 - 0x8000) {
      int v11 = v8 - 0x8000;
    }
    else {
      int v11 = *(_DWORD *)(result + 60);
    }
    if (v11 <= -32768) {
      int v11 = -32768;
    }
    if (v5 <= 0x8000) {
      int v5 = 0x8000;
    }
    int v12 = v5 - 0x8000;
    if (v12 >= v8) {
      int v13 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v13 = v12;
    }
    uint64_t v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    uint64_t v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    do
    {
      if (v6 >= v7 - 0x8000) {
        int v16 = v7 - 0x8000;
      }
      else {
        int v16 = v6;
      }
      if (v16 <= -32768) {
        int v16 = -32768;
      }
      unsigned int v17 = v16 + 0x8000;
      if (v6 <= 0x8000) {
        int v18 = 0x8000;
      }
      else {
        int v18 = v6;
      }
      int v19 = v18 - 0x8000;
      if (v19 >= v7) {
        int v19 = v7;
      }
      unint64_t v20 = ((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v21 = (v17 >> 14) & 0x3FFFC;
      HIDWORD(v23) = bswap32(*(_DWORD *)(v14 + v21));
      LODWORD(v23) = HIDWORD(v23);
      unsigned int v22 = v23 >> 8;
      HIDWORD(v23) = bswap32(*(_DWORD *)(v14 + v20));
      LODWORD(v23) = HIDWORD(v23);
      unsigned int v24 = v23 >> 8;
      HIDWORD(v23) = bswap32(*(_DWORD *)(v15 + v20));
      LODWORD(v23) = HIDWORD(v23);
      int8x8_t result = (v23 >> 8);
      HIDWORD(v23) = bswap32(*(_DWORD *)(v15 + v21));
      LODWORD(v23) = HIDWORD(v23);
      v25.i32[0] = result;
      v25.i32[1] = v23 >> 8;
      int8x16_t v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v25, (uint8x8_t)__PAIR64__(v22, v24)), a4, 0), (uint8x8_t)__PAIR64__(v22, v24));
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v19 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = a1[16];
    int v6 = a1[14];
    int v7 = a1[13] - 0x8000;
    int v8 = a1[15] - 0x8000;
    do
    {
      uint64_t v9 = v3 + v4 * ((uint64_t)v8 >> 16);
      unint64_t v10 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v11 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      HIDWORD(v13) = bswap32(*(_DWORD *)(v9 + v10));
      LODWORD(v13) = HIDWORD(v13);
      unsigned int v12 = v13 >> 8;
      uint64_t v14 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      HIDWORD(v13) = bswap32(*(_DWORD *)(v14 + v10));
      LODWORD(v13) = HIDWORD(v13);
      LODWORD(v10) = v13 >> 8;
      LODWORD(v9) = bswap32(*(_DWORD *)(v9 + v11));
      LODWORD(v11) = bswap32(*(_DWORD *)(v14 + v11));
      HIDWORD(v13) = v9;
      LODWORD(v13) = v9;
      LODWORD(v14) = v13 >> 8;
      HIDWORD(v13) = v11;
      LODWORD(v13) = v11;
      v15.i32[0] = v10;
      v15.i32[1] = v13 >> 8;
      int8x16_t v16 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v15, (uint8x8_t)__PAIR64__(v14, v12)), vdupq_n_s16((v8 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v14, v12));
      *(int16x4_t *)v16.i8 = vadd_s16(*(int16x4_t *)v16.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), *(int16x4_t *)v16.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v16.i8, *(int8x8_t *)v16.i8);
      *a3++ = result.i32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    uint64_t v6 = *(void *)(*(void *)result + 16);
    uint64_t v7 = **(void **)result;
    int v8 = v5 + 0x8000;
    unsigned int v9 = v5 - 0x8000;
    uint64_t v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    uint64_t v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    int v12 = result[13] - 0x8000;
    do
    {
      unint64_t v13 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v14 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      HIDWORD(v16) = bswap32(*(_DWORD *)(v10 + v13));
      LODWORD(v16) = HIDWORD(v16);
      unsigned int v15 = v16 >> 8;
      HIDWORD(v16) = bswap32(*(_DWORD *)(v11 + v13));
      LODWORD(v16) = HIDWORD(v16);
      LODWORD(v13) = v16 >> 8;
      HIDWORD(v16) = bswap32(*(_DWORD *)(v10 + v14));
      LODWORD(v16) = HIDWORD(v16);
      unsigned int v17 = v16 >> 8;
      HIDWORD(v16) = bswap32(*(_DWORD *)(v11 + v14));
      LODWORD(v16) = HIDWORD(v16);
      v18.i32[0] = v13;
      v18.i32[1] = v16 >> 8;
      int8x16_t v19 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v18, (uint8x8_t)__PAIR64__(v17, v15)), a4, 0), (uint8x8_t)__PAIR64__(v17, v15));
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v19.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL), *(int16x4_t *)v19.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v40 = v13;
    int v38 = v17;
    uint64_t v39 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v38;
          uint64_t v8 = v39;
          int v13 = v40;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      HIDWORD(v37) = bswap32(*(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      LODWORD(v37) = HIDWORD(v37);
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = v37 >> 8;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      HIDWORD(v13) = bswap32(*(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      LODWORD(v13) = HIDWORD(v13);
      v10 += v9;
      v8 += v7;
      *a3++ = v13 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,false,true,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      HIDWORD(v9) = bswap32(*(_DWORD *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      LODWORD(v9) = HIDWORD(v9);
      v4 += v3;
      *a3++ = v9 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,true,false,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      HIDWORD(v9) = bswap32(*(_DWORD *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      LODWORD(v9) = HIDWORD(v9);
      v8 += v7;
      v6 += v5;
      *a3++ = v9 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,false,false,false,false>(uint64_t result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      HIDWORD(v6) = bswap32(*(_DWORD *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      LODWORD(v6) = HIDWORD(v6);
      v4 += v3;
      *a3++ = v6 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    int32x2_t v19 = vdup_n_s32(0x10101u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v22 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v55 = v8;
    int v56 = v12;
    int v53 = v9 - 0x8000;
    int v54 = v8 - 0x8000;
    int v52 = v18;
    do
    {
      v23.f32[0] = (float)(1.0 / v11) * (float)v15;
      v23.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v24 = vcvt_s32_f32(v23);
      switch(v18)
      {
        case 0:
          float32x2_t v25 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v24));
          float32x2_t v26 = vmul_f32(v25, v25);
          float32x2_t v27 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v26, 1), v26);
          v26.f32[0] = fmaxf(vaddv_f32(v26), 0.00001);
          v26.i32[0] = vmul_f32(v27, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v26, 0))).u32[0];
          float32x2_t v23 = vcvt_f32_u32(*(uint32x2_t *)(v5 + 6));
          v26.i32[1] = 0.5;
          float32x2_t v28 = vmul_f32(v26, v23);
          goto LABEL_8;
        case 1:
          float32x2_t v29 = result;
          uint64_t v30 = v7;
          uint64_t v31 = v9;
          uint64_t v32 = v14;
          float v33 = atan2f(v5[11] * (float)v24.i32[1], v5[10] * (float)v24.i32[0]);
          int v16 = v54;
          int v8 = v55;
          uint64_t v14 = v32;
          int v18 = v52;
          int v12 = v56;
          uint64_t v9 = v31;
          uint64_t v7 = v30;
          int v17 = v53;
          int8x8_t result = v29;
          float32x2_t v23 = vcvt_f32_u32(*(uint32x2_t *)(v5 + 6));
          v34.i32[1] = 1056964608;
          v34.f32[0] = (float)(v33 * -10430.0) + 32768.0;
          float32x2_t v28 = vmul_f32(v34, v23);
          goto LABEL_8;
        case 2:
          float32x2_t v35 = vmul_f32(vcvt_f32_s32(v24), vmul_f32(v20, *(float32x2_t *)(v5 + 10)));
          float32x2_t v23 = *(float32x2_t *)((char *)result + 84);
          float32x2_t v28 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), v23, vminnm_f32(vsub_f32(v35, vrndm_f32(v35)), v21)), vmul_f32(v22, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v36 = vcvt_f32_s32(v24);
          float32x2_t v37 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v23 = vmul_f32(*(float32x2_t *)((char *)result + 84), v37);
          float32x2_t v38 = vmul_f32(*(float32x2_t *)((char *)result + 92), v37);
          float32x2_t v39 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v38, (int8x8_t)v36);
          float32x2_t v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v23, v39), (int8x8_t)v23, (int8x8_t)v39);
LABEL_8:
          int32x2_t v24 = vcvt_s32_f32(v28);
          break;
        default:
          break;
      }
      int v40 = v24.i32[0];
      if (v24.i32[0] >= v16) {
        int v41 = v16;
      }
      else {
        int v41 = v24.i32[0];
      }
      if (v41 <= -32768) {
        int v41 = -32768;
      }
      unint64_t v42 = (v41 + 0x8000);
      if (v24.i32[0] <= 0x8000) {
        int v40 = 0x8000;
      }
      int v43 = v40 - 0x8000;
      if (v43 >= v8) {
        int v43 = v8;
      }
      int v44 = v24.i32[1];
      if (v24.i32[1] >= v17) {
        int v45 = v17;
      }
      else {
        int v45 = v24.i32[1];
      }
      if (v45 <= -32768) {
        int v45 = -32768;
      }
      unsigned int v46 = v45 + 0x8000;
      if (v24.i32[1] <= 0x8000) {
        int v44 = 0x8000;
      }
      int v47 = v44 - 0x8000;
      if (v47 >= (int)v9) {
        int v47 = v9;
      }
      uint64_t v48 = v6 + v7 * ((uint64_t)v47 >> 16);
      uint64_t v49 = v6 + v7 * HIWORD(v46);
      v24.i8[0] = *(unsigned char *)(v48 + (v43 >> 16));
      v24.i8[4] = *(unsigned char *)(v48 + (v42 >> 16));
      v23.i8[0] = *(unsigned char *)(v49 + (v43 >> 16));
      v23.i8[4] = *(unsigned char *)(v49 + (v42 >> 16));
      unint64_t v50 = *(void *)&vmul_s32((int32x2_t)vand_s8((int8x8_t)v24, (int8x8_t)0xFF000000FFLL), v19) | 0xFF000000FF000000;
      int8x16_t v51 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vmul_s32((int32x2_t)vand_s8((int8x8_t)v23, (int8x8_t)0xFF000000FFLL), v19) | 0xFF000000FF000000), (uint8x8_t)v50), vdupq_n_s16((v47 >> 1) & 0x7F80)), (uint8x8_t)v50);
      *(int16x4_t *)v51.i8 = vadd_s16(*(int16x4_t *)v51.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v51, v51, 8uLL), *(int16x4_t *)v51.i8), vdup_n_s16((v43 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v51.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, int8x8_t a6, int8x8_t a7)
{
  if (a2)
  {
    uint64_t v7 = **(void **)result;
    uint64_t v8 = *(void *)(*(void *)result + 16);
    int v9 = *(_DWORD *)(*(void *)result + 32);
    int v10 = *(_DWORD *)(*(void *)result + 36);
    int v12 = *(_DWORD *)(result + 60);
    int v11 = *(_DWORD *)(result + 64);
    int v14 = *(_DWORD *)(result + 52);
    int v13 = *(_DWORD *)(result + 56);
    int8x8_t result = 4294934528;
    int32x2_t v15 = vdup_n_s32(0x10101u);
    do
    {
      if (v14 >= v9 - 0x8000) {
        int v16 = v9 - 0x8000;
      }
      else {
        int v16 = v14;
      }
      if (v16 <= -32768) {
        int v16 = -32768;
      }
      if (v14 <= 0x8000) {
        int v17 = 0x8000;
      }
      else {
        int v17 = v14;
      }
      int v18 = v17 - 0x8000;
      if (v18 >= v9) {
        int v18 = v9;
      }
      unint64_t v19 = (v16 + 0x8000);
      if (v12 >= v10 - 0x8000) {
        int v20 = v10 - 0x8000;
      }
      else {
        int v20 = v12;
      }
      if (v20 <= -32768) {
        int v20 = -32768;
      }
      if (v12 <= 0x8000) {
        int v21 = 0x8000;
      }
      else {
        int v21 = v12;
      }
      unsigned int v22 = v20 + 0x8000;
      int v23 = v21 - 0x8000;
      if (v23 >= v10) {
        int v23 = v10;
      }
      uint64_t v24 = v7 + v8 * ((uint64_t)v23 >> 16);
      uint64_t v25 = v7 + v8 * HIWORD(v22);
      a6.i8[0] = *(unsigned char *)(v24 + (v18 >> 16));
      a7.i8[0] = *(unsigned char *)(v25 + (v18 >> 16));
      a6.i8[4] = *(unsigned char *)(v24 + (v19 >> 16));
      a7.i8[4] = *(unsigned char *)(v25 + (v19 >> 16));
      unint64_t v26 = *(void *)&vmul_s32((int32x2_t)vand_s8(a6, (int8x8_t)0xFF000000FFLL), v15) | 0xFF000000FF000000;
      int8x16_t v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vmul_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFF000000FFLL), v15) | 0xFF000000FF000000), (uint8x8_t)v26), vdupq_n_s16((v23 >> 1) & 0x7F80)), (uint8x8_t)v26);
      a7 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), vdup_n_s16((v18 >> 1) & 0x7F80));
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v27.i8, (int16x4_t)a7), (int8x8_t)0xFF000000FFLL);
      v14 += v13;
      v12 += v11;
      *a3++ = a6.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, int8x8_t a7, int8x8_t a8)
{
  if (a2)
  {
    int v8 = result[14];
    int v9 = result[15];
    int v10 = result[13];
    int v11 = *(_DWORD *)(*(void *)result + 32);
    int v12 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v13 = *(void *)(*(void *)result + 16);
    uint64_t v14 = **(void **)result;
    if (v9 >= v12 - 0x8000) {
      int v15 = v12 - 0x8000;
    }
    else {
      int v15 = result[15];
    }
    if (v15 <= -32768) {
      int v15 = -32768;
    }
    if (v9 <= 0x8000) {
      int v9 = 0x8000;
    }
    int v16 = v9 - 0x8000;
    if (v16 >= v12) {
      int v17 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v17 = v16;
    }
    uint64_t v18 = v14 + v13 * ((uint64_t)v17 >> 16);
    uint64_t v19 = v14 + v13 * ((v15 + 0x8000) >> 16);
    a4.i32[0] = (v17 >> 1) & 0x7F80;
    int32x2_t v20 = vdup_n_s32(0x10101u);
    do
    {
      if (v10 >= v11 - 0x8000) {
        int v21 = v11 - 0x8000;
      }
      else {
        int v21 = v10;
      }
      if (v21 <= -32768) {
        int v21 = -32768;
      }
      if (v10 <= 0x8000) {
        int v22 = 0x8000;
      }
      else {
        int v22 = v10;
      }
      int v23 = v22 - 0x8000;
      if (v23 >= v11) {
        int v23 = v11;
      }
      unint64_t v24 = (v21 + 0x8000);
      int8x8_t result = (_DWORD *)(v19 + (v23 >> 16));
      a7.i8[0] = *(unsigned char *)(v18 + (v23 >> 16));
      a7.i8[4] = *(unsigned char *)(v18 + (v24 >> 16));
      a8.i8[0] = *(unsigned char *)result;
      a8.i8[4] = *(unsigned char *)(v19 + (v24 >> 16));
      unint64_t v25 = *(void *)&vmul_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFF000000FFLL), v20) | 0xFF000000FF000000;
      int8x16_t v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vmul_s32((int32x2_t)vand_s8(a8, (int8x8_t)0xFF000000FFLL), v20) | 0xFF000000FF000000), (uint8x8_t)v25), a4, 0), (uint8x8_t)v25);
      a8 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v23 >> 1) & 0x7F80));
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v26.i8, (int16x4_t)a8), (int8x8_t)a4);
      v10 += v8;
      *a3++ = a7.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,true,false,false,true>(_DWORD *result, int a2, _DWORD *a3, double a4, double a5, int8x8_t a6, int8x8_t a7)
{
  if (a2)
  {
    uint64_t v7 = **(void **)result;
    uint64_t v8 = *(void *)(*(void *)result + 16);
    int v9 = result[16];
    int v10 = result[14];
    int v11 = result[13] - 0x8000;
    int v12 = result[15] - 0x8000;
    int32x2_t v13 = vdup_n_s32(0x10101u);
    do
    {
      uint64_t v14 = v7 + v8 * ((uint64_t)v12 >> 16);
      uint64_t v15 = v7 + v8 * ((uint64_t)(v12 + 0x10000) >> 16);
      int8x8_t result = (_DWORD *)(v14 + (v11 >> 16));
      int v16 = (v11 + 0x10000) >> 16;
      a6.i8[0] = *(unsigned char *)result;
      a6.i8[4] = *(unsigned char *)(v14 + v16);
      a7.i8[0] = *(unsigned char *)(v15 + (v11 >> 16));
      a7.i8[4] = *(unsigned char *)(v15 + v16);
      unint64_t v17 = *(void *)&vmul_s32((int32x2_t)vand_s8(a6, (int8x8_t)0xFF000000FFLL), v13) | 0xFF000000FF000000;
      int8x16_t v18 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vmul_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFF000000FFLL), v13) | 0xFF000000FF000000), (uint8x8_t)v17), vdupq_n_s16((v12 >> 1) & 0x7F80)), (uint8x8_t)v17);
      a7 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), *(int16x4_t *)v18.i8), vdup_n_s16((v11 >> 1) & 0x7F80));
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v18.i8, (int16x4_t)a7), (int8x8_t)0xFF000000FFLL);
      *a3++ = a6.i32[0];
      v11 += v10;
      v12 += v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, int8x8_t a7, int8x8_t a8)
{
  if (a2)
  {
    int v8 = result[14];
    int v9 = result[15];
    uint64_t v10 = *(void *)(*(void *)result + 16);
    uint64_t v11 = **(void **)result;
    int v12 = v9 + 0x8000;
    unsigned int v13 = v9 - 0x8000;
    uint64_t v14 = v11 + v10 * ((uint64_t)(v9 - 0x8000) >> 16);
    uint64_t v15 = v11 + v10 * ((uint64_t)v12 >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    int v16 = result[13] - 0x8000;
    int32x2_t v17 = vdup_n_s32(0x10101u);
    do
    {
      int v18 = (v16 + 0x10000) >> 16;
      a7.i8[0] = *(unsigned char *)(v14 + (v16 >> 16));
      a7.i8[4] = *(unsigned char *)(v14 + v18);
      a8.i8[0] = *(unsigned char *)(v15 + (v16 >> 16));
      a8.i8[4] = *(unsigned char *)(v15 + v18);
      unint64_t v19 = *(void *)&vmul_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFF000000FFLL), v17) | 0xFF000000FF000000;
      int8x16_t v20 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vmul_s32((int32x2_t)vand_s8(a8, (int8x8_t)0xFF000000FFLL), v17) | 0xFF000000FF000000), (uint8x8_t)v19), a4, 0), (uint8x8_t)v19);
      a8 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL), *(int16x4_t *)v20.i8), vdup_n_s16((v16 >> 1) & 0x7F80));
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v20.i8, (int16x4_t)a8), (int8x8_t)a4);
      *a3++ = a7.i32[0];
      v16 += v8;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    int v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v39 = v13;
    int v37 = v17;
    uint64_t v38 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v37;
          uint64_t v8 = v38;
          int v13 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      int v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        int v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = (65793 * *(unsigned __int8 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (v35 >> 16))) | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      int8x8_t result = (int *)(v3 + v4 * ((uint64_t)v12 >> 16));
      v10 += v9;
      v8 += v7;
      *a3++ = (65793 * *((unsigned __int8 *)result + (v11 >> 16))) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      v4 += v3;
      *a3++ = (65793 * *(unsigned __int8 *)(v7 + (v8 >> 16))) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,true,false,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      unsigned int v9 = (65793 * *(unsigned __int8 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (v8 >> 16))) | 0xFF000000;
      v8 += v7;
      v6 += v5;
      *a3++ = v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      unsigned int v6 = (65793 * *(unsigned __int8 *)(v5 + (v4 >> 16))) | 0xFF000000;
      v4 += v3;
      *a3++ = v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3, double a4, double a5, double a6)
{
  if (a2)
  {
    int v7 = a2;
    int v8 = (float *)*result;
    uint64_t v9 = **result;
    uint64_t v10 = (*result)[2];
    int v11 = *((_DWORD *)*result + 8);
    uint64_t v12 = *((unsigned int *)*result + 9);
    float v13 = *((float *)result[3] + 3);
    float v14 = *((float *)result[2] + 3);
    int v16 = *((_DWORD *)result + 15);
    int v15 = *((_DWORD *)result + 16);
    int v18 = *((_DWORD *)result + 13);
    uint64_t v17 = *((unsigned int *)result + 14);
    int v19 = v11 - 0x8000;
    int v20 = v12 - 0x8000;
    int v21 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v22 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v23 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v24 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v59 = v11;
    int v60 = v15;
    int v57 = v12 - 0x8000;
    int v58 = v11 - 0x8000;
    int v56 = v21;
    do
    {
      *(float *)&a6 = (float)v16;
      v25.f32[0] = (float)(1.0 / v14) * (float)v18;
      v25.f32[1] = (float)(1.0 / v14) * (float)v16;
      int32x2_t v26 = vcvt_s32_f32(v25);
      switch(v21)
      {
        case 0:
          float32x2_t v27 = vmul_f32(*(float32x2_t *)(v8 + 10), vcvt_f32_s32(v26));
          float32x2_t v28 = vmul_f32(v27, v27);
          float32x2_t v29 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 1), v28);
          v28.f32[0] = fmaxf(vaddv_f32(v28), 0.00001);
          v28.i32[0] = vmul_f32(v29, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 0))).u32[0];
          LODWORD(a6) = 0.5;
          v28.i32[1] = 0.5;
          float32x2_t v30 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v8 + 6)));
          goto LABEL_8;
        case 1:
          float32x2_t v31 = result;
          uint64_t v32 = v10;
          uint64_t v33 = v12;
          uint64_t v34 = v17;
          float v35 = atan2f(v8[11] * (float)v26.i32[1], v8[10] * (float)v26.i32[0]);
          int v19 = v58;
          int v11 = v59;
          uint64_t v17 = v34;
          int v21 = v56;
          int v15 = v60;
          uint64_t v12 = v33;
          uint64_t v10 = v32;
          int v20 = v57;
          int8x8_t result = v31;
          HIDWORD(a6) = 1056964608;
          *(float *)&a6 = (float)(v35 * -10430.0) + 32768.0;
          float32x2_t v30 = vmul_f32(*(float32x2_t *)&a6, vcvt_f32_u32(*(uint32x2_t *)(v8 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v36 = vmul_f32(vcvt_f32_s32(v26), vmul_f32(v22, *(float32x2_t *)(v8 + 10)));
          a6 = COERCE_DOUBLE(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v36, vrndm_f32(v36)), v23)));
          float32x2_t v30 = vmul_f32(*(float32x2_t *)&a6, vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v8 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v37 = vcvt_f32_s32(v26);
          float32x2_t v38 = vcvt_f32_s32(*(int32x2_t *)(v8 + 8));
          float32x2_t v39 = vmul_f32(*(float32x2_t *)((char *)result + 84), v38);
          float32x2_t v40 = vmul_f32(*(float32x2_t *)((char *)result + 92), v38);
          float32x2_t v41 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v37, v40), (int8x8_t)v40, (int8x8_t)v37);
          a6 = COERCE_DOUBLE(vcgt_f32(v39, v41));
          float32x2_t v30 = (float32x2_t)vbsl_s8(*(int8x8_t *)&a6, (int8x8_t)v39, (int8x8_t)v41);
LABEL_8:
          int32x2_t v26 = vcvt_s32_f32(v30);
          break;
        default:
          break;
      }
      int v42 = v26.i32[0];
      if (v26.i32[0] >= v19) {
        int v43 = v19;
      }
      else {
        int v43 = v26.i32[0];
      }
      if (v43 <= -32768) {
        int v43 = -32768;
      }
      unint64_t v44 = (v43 + 0x8000);
      if (v26.i32[0] <= 0x8000) {
        int v42 = 0x8000;
      }
      int v45 = v42 - 0x8000;
      if (v45 >= v11) {
        int v45 = v11;
      }
      int v46 = v26.i32[1];
      if (v26.i32[1] >= v20) {
        int v47 = v20;
      }
      else {
        int v47 = v26.i32[1];
      }
      if (v47 <= -32768) {
        int v47 = -32768;
      }
      unsigned int v48 = v47 + 0x8000;
      if (v26.i32[1] <= 0x8000) {
        int v46 = 0x8000;
      }
      int v49 = v46 - 0x8000;
      if (v49 >= (int)v12) {
        int v49 = v12;
      }
      uint64_t v50 = v9 + v10 * ((uint64_t)v49 >> 16);
      uint64_t v51 = v9 + v10 * HIWORD(v48);
      v26.i8[0] = *(unsigned char *)(v50 + (v45 >> 16));
      v26.i8[4] = *(unsigned char *)(v50 + (v44 >> 16));
      int32x2_t v52 = vsli_n_s32(v26, (int32x2_t)vand_s8((int8x8_t)v26, (int8x8_t)0xFF000000FFLL), 8uLL);
      LOBYTE(a6) = *(unsigned char *)(v51 + (v45 >> 16));
      uint8x8_t v53 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v52, 0x10uLL), (int8x8_t)v52);
      BYTE4(a6) = *(unsigned char *)(v51 + (v44 >> 16));
      int32x2_t v54 = vsli_n_s32(*(int32x2_t *)&a6, (int32x2_t)vand_s8(*(int8x8_t *)&a6, (int8x8_t)0xFF000000FFLL), 8uLL);
      int8x16_t v55 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v54, 0x10uLL), (int8x8_t)v54), v53), vdupq_n_s16((v49 >> 1) & 0x7F80)), v53);
      a6 = COERCE_DOUBLE(vdup_n_s16((v45 >> 1) & 0x7F80));
      *(int16x4_t *)v55.i8 = vadd_s16(*(int16x4_t *)v55.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL), *(int16x4_t *)v55.i8), *(int16x4_t *)&a6));
      float v14 = v14 + v13;
      v18 += v17;
      v16 += v15;
      *a3++ = vuzp1_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v55.i8).u32[0];
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, int32x2_t a5, double a6, int32x2_t a7)
{
  if (a2)
  {
    uint64_t v7 = **(void **)result;
    uint64_t v8 = *(void *)(*(void *)result + 16);
    int v9 = *(_DWORD *)(*(void *)result + 32);
    int v10 = *(_DWORD *)(*(void *)result + 36);
    int v12 = *(_DWORD *)(result + 60);
    int v11 = *(_DWORD *)(result + 64);
    int v14 = *(_DWORD *)(result + 52);
    int v13 = *(_DWORD *)(result + 56);
    int8x8_t result = 4294934528;
    do
    {
      if (v14 >= v9 - 0x8000) {
        int v15 = v9 - 0x8000;
      }
      else {
        int v15 = v14;
      }
      if (v15 <= -32768) {
        int v15 = -32768;
      }
      if (v14 <= 0x8000) {
        int v16 = 0x8000;
      }
      else {
        int v16 = v14;
      }
      int v17 = v16 - 0x8000;
      if (v17 >= v9) {
        int v17 = v9;
      }
      if (v12 >= v10 - 0x8000) {
        int v18 = v10 - 0x8000;
      }
      else {
        int v18 = v12;
      }
      unint64_t v19 = (v15 + 0x8000);
      if (v18 <= -32768) {
        int v18 = -32768;
      }
      if (v12 <= 0x8000) {
        int v20 = 0x8000;
      }
      else {
        int v20 = v12;
      }
      int v21 = v20 - 0x8000;
      unsigned int v22 = v18 + 0x8000;
      if (v21 >= v10) {
        int v21 = v10;
      }
      uint64_t v23 = v7 + v8 * ((uint64_t)v21 >> 16);
      uint64_t v24 = v7 + v8 * HIWORD(v22);
      a5.i8[0] = *(unsigned char *)(v23 + (v17 >> 16));
      a5.i8[4] = *(unsigned char *)(v23 + (v19 >> 16));
      a7.i8[0] = *(unsigned char *)(v24 + (v17 >> 16));
      int32x2_t v25 = vsli_n_s32(a5, (int32x2_t)vand_s8((int8x8_t)a5, (int8x8_t)0xFF000000FFLL), 8uLL);
      a7.i8[4] = *(unsigned char *)(v24 + (v19 >> 16));
      int32x2_t v26 = vsli_n_s32(a7, (int32x2_t)vand_s8((int8x8_t)a7, (int8x8_t)0xFF000000FFLL), 8uLL);
      uint8x8_t v27 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v25, 0x10uLL), (int8x8_t)v25);
      int8x16_t v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v26, 0x10uLL), (int8x8_t)v26), v27), vdupq_n_s16((v21 >> 1) & 0x7F80)), v27);
      a7 = (int32x2_t)vdup_n_s16((v17 >> 1) & 0x7F80);
      a5 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v28.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), (int16x4_t)a7)), (int8x8_t)0xFF000000FFLL);
      v14 += v13;
      v12 += v11;
      *a3++ = a5.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, int8x8_t a6)
{
  if (a2)
  {
    int v6 = result[14];
    int v7 = result[15];
    int v8 = result[13];
    int v9 = *(_DWORD *)(*(void *)result + 32);
    int v10 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v11 = *(void *)(*(void *)result + 16);
    uint64_t v12 = **(void **)result;
    if (v7 >= v10 - 0x8000) {
      int v13 = v10 - 0x8000;
    }
    else {
      int v13 = result[15];
    }
    if (v13 <= -32768) {
      int v13 = -32768;
    }
    if (v7 <= 0x8000) {
      int v7 = 0x8000;
    }
    int v14 = v7 - 0x8000;
    if (v14 >= v10) {
      int v15 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v15 = v14;
    }
    uint64_t v16 = v12 + v11 * ((uint64_t)v15 >> 16);
    uint64_t v17 = v12 + v11 * ((v13 + 0x8000) >> 16);
    a4.i32[0] = (v15 >> 1) & 0x7F80;
    do
    {
      if (v8 >= v9 - 0x8000) {
        int v18 = v9 - 0x8000;
      }
      else {
        int v18 = v8;
      }
      if (v18 <= -32768) {
        int v18 = -32768;
      }
      unint64_t v19 = (v18 + 0x8000);
      if (v8 <= 0x8000) {
        int v20 = 0x8000;
      }
      else {
        int v20 = v8;
      }
      int v21 = v20 - 0x8000;
      if (v21 >= v9) {
        int v21 = v9;
      }
      int8x8_t result = (_DWORD *)(v17 + (v21 >> 16));
      a6.i8[0] = *(unsigned char *)(v16 + (v21 >> 16));
      a6.i8[4] = *(unsigned char *)(v16 + (v19 >> 16));
      int32x2_t v22 = (int32x2_t)vand_s8(a6, (int8x8_t)0xFF000000FFLL);
      int32x2_t v23 = vsli_n_s32((int32x2_t)a6, v22, 8uLL);
      v22.i8[0] = *(unsigned char *)result;
      v22.i8[4] = *(unsigned char *)(v17 + (v19 >> 16));
      int32x2_t v24 = vsli_n_s32(v22, (int32x2_t)vand_s8((int8x8_t)v22, (int8x8_t)0xFF000000FFLL), 8uLL);
      uint8x8_t v25 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v23, 0x10uLL), (int8x8_t)v23);
      int8x16_t v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v24, 0x10uLL), (int8x8_t)v24), v25), a4, 0), v25);
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v21 >> 1) & 0x7F80))), (int8x8_t)a4);
      v8 += v6;
      *a3++ = a6.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,true,false,false,true>(_DWORD *result, int a2, _DWORD *a3, double a4, int32x2_t a5, double a6, int32x2_t a7)
{
  if (a2)
  {
    uint64_t v7 = **(void **)result;
    uint64_t v8 = *(void *)(*(void *)result + 16);
    int v9 = result[16];
    int v10 = result[14];
    int v11 = result[13] - 0x8000;
    int v12 = result[15] - 0x8000;
    do
    {
      uint64_t v13 = v7 + v8 * ((uint64_t)v12 >> 16);
      uint64_t v14 = v7 + v8 * ((uint64_t)(v12 + 0x10000) >> 16);
      int8x8_t result = (_DWORD *)(v13 + (v11 >> 16));
      int v15 = (v11 + 0x10000) >> 16;
      a5.i8[0] = *(unsigned char *)result;
      a5.i8[4] = *(unsigned char *)(v13 + v15);
      a7.i8[0] = *(unsigned char *)(v14 + (v11 >> 16));
      int32x2_t v16 = vsli_n_s32(a5, (int32x2_t)vand_s8((int8x8_t)a5, (int8x8_t)0xFF000000FFLL), 8uLL);
      a7.i8[4] = *(unsigned char *)(v14 + v15);
      int32x2_t v17 = vsli_n_s32(a7, (int32x2_t)vand_s8((int8x8_t)a7, (int8x8_t)0xFF000000FFLL), 8uLL);
      uint8x8_t v18 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v16, 0x10uLL), (int8x8_t)v16);
      int8x16_t v19 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v17, 0x10uLL), (int8x8_t)v17), v18), vdupq_n_s16((v12 >> 1) & 0x7F80)), v18);
      a7 = (int32x2_t)vdup_n_s16((v11 >> 1) & 0x7F80);
      a5 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v19.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL), *(int16x4_t *)v19.i8), (int16x4_t)a7)), (int8x8_t)0xFF000000FFLL);
      *a3++ = a5.i32[0];
      v11 += v10;
      v12 += v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, int8x8_t a6)
{
  if (a2)
  {
    int v6 = result[14];
    int v7 = result[15];
    uint64_t v8 = *(void *)(*(void *)result + 16);
    uint64_t v9 = **(void **)result;
    int v10 = v7 + 0x8000;
    unsigned int v11 = v7 - 0x8000;
    uint64_t v12 = v9 + v8 * ((uint64_t)(v7 - 0x8000) >> 16);
    uint64_t v13 = v9 + v8 * ((uint64_t)v10 >> 16);
    a4.i32[0] = (v11 >> 1) & 0x7F80;
    int v14 = result[13] - 0x8000;
    do
    {
      int v15 = (v14 + 0x10000) >> 16;
      a6.i8[0] = *(unsigned char *)(v12 + (v14 >> 16));
      a6.i8[4] = *(unsigned char *)(v12 + v15);
      int32x2_t v16 = (int32x2_t)vand_s8(a6, (int8x8_t)0xFF000000FFLL);
      int32x2_t v17 = vsli_n_s32((int32x2_t)a6, v16, 8uLL);
      v16.i8[0] = *(unsigned char *)(v13 + (v14 >> 16));
      v16.i8[4] = *(unsigned char *)(v13 + v15);
      int32x2_t v18 = vsli_n_s32(v16, (int32x2_t)vand_s8((int8x8_t)v16, (int8x8_t)0xFF000000FFLL), 8uLL);
      uint8x8_t v19 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v17, 0x10uLL), (int8x8_t)v17);
      int8x16_t v20 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v18, 0x10uLL), (int8x8_t)v18), v19), a4, 0), v19);
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v20.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL), *(int16x4_t *)v20.i8), vdup_n_s16((v14 >> 1) & 0x7F80))), (int8x8_t)a4);
      *a3++ = a6.i32[0];
      v14 += v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, int *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    int v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v40 = v13;
    int v38 = v17;
    uint64_t v39 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v38;
          uint64_t v8 = v39;
          int v13 = v40;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      int v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        int v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      int v37 = *(unsigned __int8 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (v35 >> 16));
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = v37 | (v37 << 8) | ((v37 | (v37 << 8)) << 16);
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,true,true,false,false>(int *result, int a2, int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      int v13 = *(unsigned __int8 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (v11 >> 16));
      v10 += v9;
      v8 += v7;
      *a3++ = v13 | (v13 << 8) | ((v13 | (v13 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,false,true,false,false>(_DWORD *result, int a2, int *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      int v9 = *(unsigned __int8 *)(v7 + (v8 >> 16));
      v4 += v3;
      *a3++ = v9 | (v9 << 8) | ((v9 | (v9 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,true,false,false,false>(int *result, int a2, int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      int v9 = *(unsigned __int8 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (v8 >> 16));
      v8 += v7;
      v6 += v5;
      *a3++ = v9 | (v9 << 8) | ((v9 | (v9 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,false,false,false,false>(uint64_t result, int a2, int *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      int v6 = *(unsigned __int8 *)(v5 + (v4 >> 16));
      v4 += v3;
      *a3++ = v6 | (v6 << 8) | ((v6 | (v6 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v54 = v8;
    int v55 = v12;
    int v52 = v9 - 0x8000;
    int v53 = v8 - 0x8000;
    int v51 = v18;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v23));
          float32x2_t v25 = vmul_f32(v24, v24);
          float32x2_t v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          float32x2_t v22 = vcvt_f32_u32(*(uint32x2_t *)(v5 + 6));
          v25.i32[1] = 0.5;
          float32x2_t v27 = vmul_f32(v25, v22);
          goto LABEL_8;
        case 1:
          float32x2_t v28 = result;
          uint64_t v29 = v7;
          uint64_t v30 = v9;
          uint64_t v31 = v14;
          float v32 = atan2f(v5[11] * (float)v23.i32[1], v5[10] * (float)v23.i32[0]);
          int v16 = v53;
          int v8 = v54;
          uint64_t v14 = v31;
          int v18 = v51;
          int v12 = v55;
          uint64_t v9 = v30;
          uint64_t v7 = v29;
          int v17 = v52;
          int8x8_t result = v28;
          float32x2_t v22 = vcvt_f32_u32(*(uint32x2_t *)(v5 + 6));
          v33.i32[1] = 1056964608;
          v33.f32[0] = (float)(v32 * -10430.0) + 32768.0;
          float32x2_t v27 = vmul_f32(v33, v22);
          goto LABEL_8;
        case 2:
          float32x2_t v34 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, *(float32x2_t *)(v5 + 10)));
          float32x2_t v22 = *(float32x2_t *)((char *)result + 84);
          float32x2_t v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), v22, vminnm_f32(vsub_f32(v34, vrndm_f32(v34)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v35 = vcvt_f32_s32(v23);
          float32x2_t v36 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v22 = vmul_f32(*(float32x2_t *)((char *)result + 84), v36);
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v36);
          float32x2_t v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v37), (int8x8_t)v37, (int8x8_t)v35);
          float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, v38), (int8x8_t)v22, (int8x8_t)v38);
LABEL_8:
          int32x2_t v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      int v39 = v23.i32[0];
      if (v23.i32[0] >= v16) {
        int v40 = v16;
      }
      else {
        int v40 = v23.i32[0];
      }
      if (v40 <= -32768) {
        int v40 = -32768;
      }
      unint64_t v41 = (v40 + 0x8000);
      if (v23.i32[0] <= 0x8000) {
        int v39 = 0x8000;
      }
      int v42 = v39 - 0x8000;
      if (v42 >= v8) {
        int v42 = v8;
      }
      int v43 = v23.i32[1];
      if (v23.i32[1] >= v17) {
        int v44 = v17;
      }
      else {
        int v44 = v23.i32[1];
      }
      if (v44 <= -32768) {
        int v44 = -32768;
      }
      unsigned int v45 = v44 + 0x8000;
      if (v23.i32[1] <= 0x8000) {
        int v43 = 0x8000;
      }
      int v46 = v43 - 0x8000;
      if (v46 >= (int)v9) {
        int v46 = v9;
      }
      uint64_t v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      uint64_t v48 = v6 + v7 * HIWORD(v45);
      v23.i8[0] = *(unsigned char *)(v47 + (v42 >> 16));
      v23.i8[4] = *(unsigned char *)(v47 + (v41 >> 16));
      uint8x8_t v49 = (uint8x8_t)vshl_n_s32(v23, 0x18uLL);
      v22.i8[0] = *(unsigned char *)(v48 + (v42 >> 16));
      v22.i8[4] = *(unsigned char *)(v48 + (v41 >> 16));
      int8x16_t v50 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vshl_n_s32((int32x2_t)v22, 0x18uLL), v49), vdupq_n_s16((v46 >> 1) & 0x7F80)), v49);
      *(int16x4_t *)v50.i8 = vadd_s16(*(int16x4_t *)v50.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL), *(int16x4_t *)v50.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v50.i8, *(int8x8_t *)v50.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

int32x2_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3, int32x2_t result, int32x2_t a5)
{
  if (a2)
  {
    uint64_t v5 = **(void **)a1;
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    int v7 = *(_DWORD *)(*(void *)a1 + 32);
    int v8 = *(_DWORD *)(*(void *)a1 + 36);
    int v10 = a1[15];
    int v9 = a1[16];
    int v12 = a1[13];
    int v11 = a1[14];
    do
    {
      if (v12 >= v7 - 0x8000) {
        int v13 = v7 - 0x8000;
      }
      else {
        int v13 = v12;
      }
      if (v13 <= -32768) {
        int v13 = -32768;
      }
      if (v12 <= 0x8000) {
        int v14 = 0x8000;
      }
      else {
        int v14 = v12;
      }
      int v15 = v14 - 0x8000;
      if (v15 >= v7) {
        int v15 = v7;
      }
      if (v10 >= v8 - 0x8000) {
        int v16 = v8 - 0x8000;
      }
      else {
        int v16 = v10;
      }
      unint64_t v17 = (v13 + 0x8000);
      if (v16 <= -32768) {
        int v16 = -32768;
      }
      if (v10 <= 0x8000) {
        int v18 = 0x8000;
      }
      else {
        int v18 = v10;
      }
      int v19 = v18 - 0x8000;
      unsigned int v20 = v16 + 0x8000;
      if (v19 >= v8) {
        int v19 = v8;
      }
      uint64_t v21 = v5 + v6 * ((uint64_t)v19 >> 16);
      uint64_t v22 = v5 + v6 * HIWORD(v20);
      result.i8[0] = *(unsigned char *)(v21 + (v15 >> 16));
      a5.i8[0] = *(unsigned char *)(v22 + (v15 >> 16));
      a5.i8[4] = *(unsigned char *)(v22 + (v17 >> 16));
      result.i8[4] = *(unsigned char *)(v21 + (v17 >> 16));
      uint8x8_t v23 = (uint8x8_t)vshl_n_s32(result, 0x18uLL);
      int8x16_t v24 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vshl_n_s32(a5, 0x18uLL), v23), vdupq_n_s16((v19 >> 1) & 0x7F80)), v23);
      a5 = (int32x2_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), *(int16x4_t *)v24.i8), vdup_n_s16((v15 >> 1) & 0x7F80));
      *(int16x4_t *)v24.i8 = vadd_s16(*(int16x4_t *)v24.i8, (int16x4_t)a5);
      int8x8_t result = (int32x2_t)vuzp1_s8(*(int8x8_t *)v24.i8, *(int8x8_t *)v24.i8);
      v12 += v11;
      v10 += v9;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, int32x2_t a5, int32x2_t a6)
{
  if (a2)
  {
    int v6 = result[14];
    int v7 = result[15];
    int v8 = result[13];
    int v9 = *(_DWORD *)(*(void *)result + 32);
    int v10 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v11 = *(void *)(*(void *)result + 16);
    uint64_t v12 = **(void **)result;
    if (v7 >= v10 - 0x8000) {
      int v13 = v10 - 0x8000;
    }
    else {
      int v13 = result[15];
    }
    if (v13 <= -32768) {
      int v13 = -32768;
    }
    if (v7 <= 0x8000) {
      int v7 = 0x8000;
    }
    int v14 = v7 - 0x8000;
    if (v14 >= v10) {
      int v15 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v15 = v14;
    }
    uint64_t v16 = v12 + v11 * ((uint64_t)v15 >> 16);
    uint64_t v17 = v12 + v11 * ((v13 + 0x8000) >> 16);
    a4.i32[0] = (v15 >> 1) & 0x7F80;
    do
    {
      if (v8 >= v9 - 0x8000) {
        int v18 = v9 - 0x8000;
      }
      else {
        int v18 = v8;
      }
      if (v18 <= -32768) {
        int v18 = -32768;
      }
      unint64_t v19 = (v18 + 0x8000);
      if (v8 <= 0x8000) {
        int v20 = 0x8000;
      }
      else {
        int v20 = v8;
      }
      int v21 = v20 - 0x8000;
      if (v21 >= v9) {
        int v21 = v9;
      }
      int8x8_t result = (_DWORD *)(v17 + (v21 >> 16));
      a5.i8[0] = *(unsigned char *)(v16 + (v21 >> 16));
      a5.i8[4] = *(unsigned char *)(v16 + (v19 >> 16));
      a6.i8[0] = *(unsigned char *)result;
      a6.i8[4] = *(unsigned char *)(v17 + (v19 >> 16));
      uint8x8_t v22 = (uint8x8_t)vshl_n_s32(a5, 0x18uLL);
      int8x16_t v23 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vshl_n_s32(a6, 0x18uLL), v22), a4, 0), v22);
      a6 = (int32x2_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL), *(int16x4_t *)v23.i8), vdup_n_s16((v21 >> 1) & 0x7F80));
      a5 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v23.i8, (int16x4_t)a6), (int8x8_t)a4);
      v8 += v6;
      *a3++ = a5.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int32x2_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3, int32x2_t result, int32x2_t a5)
{
  if (a2)
  {
    uint64_t v5 = **(void **)a1;
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    int v7 = a1[16];
    int v8 = a1[14];
    int v9 = a1[13] - 0x8000;
    int v10 = a1[15] - 0x8000;
    do
    {
      uint64_t v11 = v5 + v6 * ((uint64_t)v10 >> 16);
      uint64_t v12 = v5 + v6 * ((uint64_t)(v10 + 0x10000) >> 16);
      int v13 = (v9 + 0x10000) >> 16;
      result.i8[0] = *(unsigned char *)(v11 + (v9 >> 16));
      result.i8[4] = *(unsigned char *)(v11 + v13);
      a5.i8[0] = *(unsigned char *)(v12 + (v9 >> 16));
      a5.i8[4] = *(unsigned char *)(v12 + v13);
      uint8x8_t v14 = (uint8x8_t)vshl_n_s32(result, 0x18uLL);
      int8x16_t v15 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vshl_n_s32(a5, 0x18uLL), v14), vdupq_n_s16((v10 >> 1) & 0x7F80)), v14);
      a5 = (int32x2_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL), *(int16x4_t *)v15.i8), vdup_n_s16((v9 >> 1) & 0x7F80));
      *(int16x4_t *)v15.i8 = vadd_s16(*(int16x4_t *)v15.i8, (int16x4_t)a5);
      int8x8_t result = (int32x2_t)vuzp1_s8(*(int8x8_t *)v15.i8, *(int8x8_t *)v15.i8);
      *a3++ = result.i32[0];
      v9 += v8;
      v10 += v7;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, int32x2_t a5, int32x2_t a6)
{
  if (a2)
  {
    int v6 = result[14];
    int v7 = result[15];
    uint64_t v8 = *(void *)(*(void *)result + 16);
    uint64_t v9 = **(void **)result;
    int v10 = v7 + 0x8000;
    unsigned int v11 = v7 - 0x8000;
    uint64_t v12 = v9 + v8 * ((uint64_t)(v7 - 0x8000) >> 16);
    uint64_t v13 = v9 + v8 * ((uint64_t)v10 >> 16);
    a4.i32[0] = (v11 >> 1) & 0x7F80;
    int v14 = result[13] - 0x8000;
    do
    {
      int v15 = (v14 + 0x10000) >> 16;
      a5.i8[0] = *(unsigned char *)(v12 + (v14 >> 16));
      a5.i8[4] = *(unsigned char *)(v12 + v15);
      a6.i8[0] = *(unsigned char *)(v13 + (v14 >> 16));
      a6.i8[4] = *(unsigned char *)(v13 + v15);
      uint8x8_t v16 = (uint8x8_t)vshl_n_s32(a5, 0x18uLL);
      int8x16_t v17 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vshl_n_s32(a6, 0x18uLL), v16), a4, 0), v16);
      a6 = (int32x2_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL), *(int16x4_t *)v17.i8), vdup_n_s16((v14 >> 1) & 0x7F80));
      a5 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v17.i8, (int16x4_t)a6), (int8x8_t)a4);
      *a3++ = a5.i32[0];
      v14 += v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    int v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v39 = v13;
    int v37 = v17;
    uint64_t v38 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v37;
          uint64_t v8 = v38;
          int v13 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      int v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        int v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = *(unsigned __int8 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (v35 >> 16)) << 24;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      v10 += v9;
      v8 += v7;
      *a3++ = *(unsigned __int8 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (v11 >> 16)) << 24;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,false,true,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      v4 += v3;
      *a3++ = *(unsigned __int8 *)(v7 + (v8 >> 16)) << 24;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,true,false,false,false>(int *result, int a2, int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      int v9 = *(unsigned __int8 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (v8 >> 16)) << 24;
      v8 += v7;
      v6 += v5;
      *a3++ = v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,false,false,false,false>(uint64_t result, int a2, int *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      int v6 = *(unsigned __int8 *)(v5 + (v4 >> 16)) << 24;
      v4 += v3;
      *a3++ = v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

unsigned int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::YCbYCr8,unsigned int,true,true,true,true>(unsigned int *result, int a2, const unsigned __int8 *a3)
{
  uint64_t v48 = result;
  v58[1] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    int v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    uint64_t v55 = *(void *)(*(void *)result + 16);
    uint64_t v56 = **(void **)result;
    uint8x8_t v49 = *(float **)result;
    float v5 = *(float *)(*((void *)result + 3) + 12);
    float v6 = *(float *)(*((void *)result + 2) + 12);
    int v7 = result[15];
    unsigned int v52 = result[16];
    int v53 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[13];
    unsigned int v51 = result[14];
    int v54 = *(_DWORD *)(*(void *)result + 32);
    int v9 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v10 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v11 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v12 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v50 = v9;
    do
    {
      v13.f32[0] = (float)(1.0 / v6) * (float)v8;
      v13.f32[1] = (float)(1.0 / v6) * (float)v7;
      int32x2_t v14 = vcvt_s32_f32(v13);
      switch(v9)
      {
        case 0:
          float32x2_t v15 = vmul_f32(*(float32x2_t *)(v49 + 10), vcvt_f32_s32(v14));
          float32x2_t v16 = vmul_f32(v15, v15);
          float32x2_t v17 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 1), v16);
          v16.f32[0] = fmaxf(vaddv_f32(v16), 0.00001);
          v16.i32[0] = vmul_f32(v17, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 0))).u32[0];
          v16.i32[1] = 0.5;
          float32x2_t v18 = vmul_f32(v16, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 1:
          float v19 = atan2f(v49[11] * (float)v14.i32[1], v49[10] * (float)v14.i32[0]);
          v20.i32[1] = 1056964608;
          v20.f32[0] = (float)(v19 * -10430.0) + 32768.0;
          float32x2_t v18 = vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v21 = vmul_f32(vcvt_f32_s32(v14), vmul_f32(v10, *(float32x2_t *)(v49 + 10)));
          float32x2_t v18 = vmul_f32(vmla_f32(*(float32x2_t *)(v48 + 23), *(float32x2_t *)(v48 + 21), vminnm_f32(vsub_f32(v21, vrndm_f32(v21)), v11)), vmul_f32(v12, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v22 = vcvt_f32_s32(v14);
          float32x2_t v23 = vcvt_f32_s32(*(int32x2_t *)(v49 + 8));
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v48 + 21), v23);
          float32x2_t v25 = vmul_f32(*(float32x2_t *)(v48 + 23), v23);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, v25), (int8x8_t)v25, (int8x8_t)v22);
          float32x2_t v18 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, v26), (int8x8_t)v24, (int8x8_t)v26);
LABEL_8:
          int32x2_t v14 = vcvt_s32_f32(v18);
          break;
        default:
          break;
      }
      --v4;
      int v27 = v14.i32[0];
      int v28 = v54 - 0x8000;
      if (v14.i32[0] < v54 - 0x8000) {
        int v28 = v14.i32[0];
      }
      if (v28 <= -32768) {
        int v28 = -32768;
      }
      unsigned int v29 = v28 + 0x8000;
      if (v14.i32[0] <= 0x8000) {
        int v27 = 0x8000;
      }
      int v30 = v27 - 0x8000;
      if (v30 >= v54) {
        int v31 = v54;
      }
      else {
        int v31 = v30;
      }
      int v32 = v14.i32[1];
      if (v14.i32[1] >= v53 - 0x8000) {
        int v33 = v53 - 0x8000;
      }
      else {
        int v33 = v14.i32[1];
      }
      if (v33 <= -32768) {
        int v33 = -32768;
      }
      unsigned int v34 = v33 + 0x8000;
      if (v14.i32[1] <= 0x8000) {
        int v32 = 0x8000;
      }
      int v35 = v32 - 0x8000;
      if (v35 >= v53) {
        int v36 = v53;
      }
      else {
        int v36 = v35;
      }
      uint64_t v37 = v56 + v55 * ((uint64_t)v36 >> 16);
      uint64_t v38 = v56 + v55 * HIWORD(v34);
      signed int v39 = (v31 >> 15) & 0xFFFFFFFE;
      unint64_t v40 = v38 + v39;
      uint64_t v57 = 0;
      v58[0] = 0;
      uint64_t v41 = (v29 >> 15) & 0x1FFFE;
      unint64_t v42 = v37 + v41;
      unint64_t v43 = v38 + v41;
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)v58 + 1, v37 + v39, a3);
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)v58, v42, v44);
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)&v57 + 1, v40, v45);
      int8x8_t result = CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)&v57, v43, v46);
      int8x16_t v47 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v57, HIDWORD(v57)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0]))), vdupq_n_s16((v36 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0])));
      *(int16x4_t *)v47.i8 = vadd_s16(*(int16x4_t *)v47.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL), *(int16x4_t *)v47.i8), vdup_n_s16((v31 >> 1) & 0x7F80)));
      float v6 = v6 + v5;
      v8 += v51;
      v7 += v52;
      *(_DWORD *)int v3 = vuzp1_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v47.i8).u32[0];
      v3 += 4;
      int v9 = v50;
    }
    while (v4);
  }
  return result;
}

unsigned int *CA::OGL::SW::Format::YCbYCr8::load_1(unsigned int *this, unint64_t a2, const unsigned __int8 *a3)
{
  int v3 = *(unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFDLL) + 1) - 128;
  int v4 = *(unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFDLL) + 3) - 128;
  int v5 = 38155 * *(unsigned __int8 *)a2 - 610480;
  int v6 = (v5 + 52299 * v4) >> 15;
  if (v6 >= 255) {
    int v6 = 255;
  }
  if (v6 >= 0) {
    unsigned int v7 = (v6 << 16) | 0xFF000000;
  }
  else {
    unsigned int v7 = -16777216;
  }
  int v8 = (v5 - 12836 * v3 - 26638 * v4) >> 15;
  if (v8 >= 255) {
    int v8 = 255;
  }
  if (v8 >= 0) {
    int v9 = v8 << 8;
  }
  else {
    int v9 = 0;
  }
  int v10 = (v5 + 66101 * v3) >> 15;
  if (v10 >= 255) {
    int v10 = 255;
  }
  *this = v9 | v10 & ~(v10 >> 31) | v7;
  return this;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::YCbYCr8,unsigned int,true,true,false,true>(int *a1, int a2, const unsigned __int8 *a3)
{
  v36[1] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    int v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    uint64_t v33 = *(void *)(*(void *)a1 + 16);
    uint64_t v34 = **(void **)a1;
    int v5 = a1[15];
    int v31 = *(_DWORD *)(*(void *)a1 + 36);
    int v32 = *(_DWORD *)(*(void *)a1 + 32);
    int v30 = a1[16];
    int v6 = a1[13];
    int v29 = a1[14];
    do
    {
      --v4;
      int v7 = v32 - 0x8000;
      if (v6 < v32 - 0x8000) {
        int v7 = v6;
      }
      if (v7 <= -32768) {
        int v7 = -32768;
      }
      unsigned int v8 = v7 + 0x8000;
      if (v6 <= 0x8000) {
        int v9 = 0x8000;
      }
      else {
        int v9 = v6;
      }
      int v10 = v9 - 0x8000;
      if (v10 >= v32) {
        int v11 = v32;
      }
      else {
        int v11 = v10;
      }
      if (v5 >= v31 - 0x8000) {
        int v12 = v31 - 0x8000;
      }
      else {
        int v12 = v5;
      }
      if (v12 <= -32768) {
        int v12 = -32768;
      }
      unsigned int v13 = v12 + 0x8000;
      if (v5 <= 0x8000) {
        int v14 = 0x8000;
      }
      else {
        int v14 = v5;
      }
      int v15 = v14 - 0x8000;
      if (v15 >= v31) {
        int v16 = v31;
      }
      else {
        int v16 = v15;
      }
      uint64_t v17 = v34 + v33 * ((uint64_t)v16 >> 16);
      uint64_t v18 = v34 + v33 * HIWORD(v13);
      signed int v19 = (v11 >> 15) & 0xFFFFFFFE;
      unint64_t v20 = v18 + v19;
      uint64_t v35 = 0;
      v36[0] = 0;
      uint64_t v21 = (v8 >> 15) & 0x1FFFE;
      unint64_t v22 = v17 + v21;
      unint64_t v23 = v18 + v21;
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)v36 + 1, v17 + v19, a3);
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)v36, v22, v24);
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)&v35 + 1, v20, v25);
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)&v35, v23, v26);
      int8x16_t v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v35, HIDWORD(v35)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0]))), vdupq_n_s16((v16 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0])));
      *(int16x4_t *)v27.i8 = vadd_s16(*(int16x4_t *)v27.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), vdup_n_s16((v11 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v27.i8, *(int8x8_t *)v27.i8);
      v6 += v29;
      v5 += v30;
      *(_DWORD *)int v3 = result.i32[0];
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

unsigned int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::YCbYCr8,unsigned int,true,true,true,false>(unsigned int *result, int a2, const unsigned __int8 *a3)
{
  uint64_t v34 = result;
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    int v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    int v5 = *(float **)result;
    uint64_t v35 = *(void *)(*(void *)result + 16);
    uint64_t v36 = **(void **)result;
    int v6 = *(_DWORD *)(*(void *)result + 32);
    int v7 = *(_DWORD *)(*(void *)result + 36);
    float v8 = *(float *)(*((void *)result + 3) + 12);
    float v9 = *(float *)(*((void *)result + 2) + 12);
    int v10 = result[15];
    unsigned int v11 = result[16];
    int v12 = result[13];
    unsigned int v13 = result[14];
    int v14 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v15 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v16 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v17 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      unsigned int v37 = 0;
      v18.f32[0] = (float)(1.0 / v9) * (float)v12;
      v18.f32[1] = (float)(1.0 / v9) * (float)v10;
      int32x2_t v19 = vcvt_s32_f32(v18);
      switch(v14)
      {
        case 0:
          float32x2_t v20 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v19));
          float32x2_t v21 = vmul_f32(v20, v20);
          float32x2_t v22 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 1), v21);
          v21.f32[0] = fmaxf(vaddv_f32(v21), 0.00001);
          v21.i32[0] = vmul_f32(v22, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 0))).u32[0];
          v21.i32[1] = 0.5;
          float32x2_t v23 = vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float v24 = atan2f(v5[11] * (float)v19.i32[1], v5[10] * (float)v19.i32[0]);
          v25.i32[1] = 1056964608;
          v25.f32[0] = (float)(v24 * -10430.0) + 32768.0;
          float32x2_t v23 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v26 = vmul_f32(vcvt_f32_s32(v19), vmul_f32(v15, *(float32x2_t *)(v5 + 10)));
          float32x2_t v23 = vmul_f32(vmla_f32(*(float32x2_t *)(v34 + 23), *(float32x2_t *)(v34 + 21), vminnm_f32(vsub_f32(v26, vrndm_f32(v26)), v16)), vmul_f32(v17, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v27 = vcvt_f32_s32(v19);
          float32x2_t v28 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v29 = vmul_f32(*(float32x2_t *)(v34 + 21), v28);
          float32x2_t v30 = vmul_f32(*(float32x2_t *)(v34 + 23), v28);
          float32x2_t v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v30), (int8x8_t)v30, (int8x8_t)v27);
          float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, v31), (int8x8_t)v29, (int8x8_t)v31);
LABEL_8:
          int32x2_t v19 = vcvt_s32_f32(v23);
          break;
        default:
          break;
      }
      --v4;
      int v32 = v19.i32[0] & ~(v19.i32[0] >> 31);
      if (v32 >= v6) {
        int v32 = v6;
      }
      int v33 = v19.i32[1] & ~(v19.i32[1] >> 31);
      if (v33 >= v7) {
        int v33 = v7;
      }
      int8x8_t result = CA::OGL::SW::Format::YCbYCr8::load_1(&v37, v36 + v35 * ((uint64_t)v33 >> 16) + (int)((v32 >> 15) & 0xFFFFFFFE), a3);
      float v9 = v9 + v8;
      v12 += v13;
      v10 += v11;
      *(_DWORD *)int v3 = v37;
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

unsigned int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::YCbYCr8,unsigned int,true,true,false,false>(unsigned int *result, int a2, const unsigned __int8 *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    int v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    uint64_t v5 = **(void **)result;
    uint64_t v6 = *(void *)(*(void *)result + 16);
    int v7 = *(_DWORD *)(*(void *)result + 32);
    int v8 = *(_DWORD *)(*(void *)result + 36);
    int v10 = result[15];
    unsigned int v9 = result[16];
    int v12 = result[13];
    unsigned int v11 = result[14];
    do
    {
      --v4;
      unsigned int v15 = 0;
      int v13 = v12 & ~(v12 >> 31);
      if (v13 >= v7) {
        int v13 = v7;
      }
      int v14 = v10 & ~(v10 >> 31);
      if (v14 >= v8) {
        int v14 = v8;
      }
      int8x8_t result = CA::OGL::SW::Format::YCbYCr8::load_1(&v15, v5 + v6 * ((uint64_t)v14 >> 16) + (int)((v13 >> 15) & 0xFFFFFFFE), a3);
      v12 += v11;
      v10 += v9;
      *(_DWORD *)int v3 = v15;
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

unsigned int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::CbYCrY8,unsigned int,true,true,true,true>(unsigned int *result, int a2, const unsigned __int8 *a3)
{
  uint64_t v48 = result;
  v58[1] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    int v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    uint64_t v55 = *(void *)(*(void *)result + 16);
    uint64_t v56 = **(void **)result;
    uint8x8_t v49 = *(float **)result;
    float v5 = *(float *)(*((void *)result + 3) + 12);
    float v6 = *(float *)(*((void *)result + 2) + 12);
    int v7 = result[15];
    unsigned int v52 = result[16];
    int v53 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[13];
    unsigned int v51 = result[14];
    int v54 = *(_DWORD *)(*(void *)result + 32);
    int v9 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v10 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v11 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v12 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v50 = v9;
    do
    {
      v13.f32[0] = (float)(1.0 / v6) * (float)v8;
      v13.f32[1] = (float)(1.0 / v6) * (float)v7;
      int32x2_t v14 = vcvt_s32_f32(v13);
      switch(v9)
      {
        case 0:
          float32x2_t v15 = vmul_f32(*(float32x2_t *)(v49 + 10), vcvt_f32_s32(v14));
          float32x2_t v16 = vmul_f32(v15, v15);
          float32x2_t v17 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 1), v16);
          v16.f32[0] = fmaxf(vaddv_f32(v16), 0.00001);
          v16.i32[0] = vmul_f32(v17, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 0))).u32[0];
          v16.i32[1] = 0.5;
          float32x2_t v18 = vmul_f32(v16, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 1:
          float v19 = atan2f(v49[11] * (float)v14.i32[1], v49[10] * (float)v14.i32[0]);
          v20.i32[1] = 1056964608;
          v20.f32[0] = (float)(v19 * -10430.0) + 32768.0;
          float32x2_t v18 = vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v21 = vmul_f32(vcvt_f32_s32(v14), vmul_f32(v10, *(float32x2_t *)(v49 + 10)));
          float32x2_t v18 = vmul_f32(vmla_f32(*(float32x2_t *)(v48 + 23), *(float32x2_t *)(v48 + 21), vminnm_f32(vsub_f32(v21, vrndm_f32(v21)), v11)), vmul_f32(v12, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v22 = vcvt_f32_s32(v14);
          float32x2_t v23 = vcvt_f32_s32(*(int32x2_t *)(v49 + 8));
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v48 + 21), v23);
          float32x2_t v25 = vmul_f32(*(float32x2_t *)(v48 + 23), v23);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, v25), (int8x8_t)v25, (int8x8_t)v22);
          float32x2_t v18 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, v26), (int8x8_t)v24, (int8x8_t)v26);
LABEL_8:
          int32x2_t v14 = vcvt_s32_f32(v18);
          break;
        default:
          break;
      }
      --v4;
      int v27 = v14.i32[0];
      int v28 = v54 - 0x8000;
      if (v14.i32[0] < v54 - 0x8000) {
        int v28 = v14.i32[0];
      }
      if (v28 <= -32768) {
        int v28 = -32768;
      }
      unsigned int v29 = v28 + 0x8000;
      if (v14.i32[0] <= 0x8000) {
        int v27 = 0x8000;
      }
      int v30 = v27 - 0x8000;
      if (v30 >= v54) {
        int v31 = v54;
      }
      else {
        int v31 = v30;
      }
      int v32 = v14.i32[1];
      if (v14.i32[1] >= v53 - 0x8000) {
        int v33 = v53 - 0x8000;
      }
      else {
        int v33 = v14.i32[1];
      }
      if (v33 <= -32768) {
        int v33 = -32768;
      }
      unsigned int v34 = v33 + 0x8000;
      if (v14.i32[1] <= 0x8000) {
        int v32 = 0x8000;
      }
      int v35 = v32 - 0x8000;
      if (v35 >= v53) {
        int v36 = v53;
      }
      else {
        int v36 = v35;
      }
      uint64_t v37 = v56 + v55 * ((uint64_t)v36 >> 16);
      uint64_t v38 = v56 + v55 * HIWORD(v34);
      signed int v39 = (v31 >> 15) & 0xFFFFFFFE;
      unint64_t v40 = v38 + v39;
      uint64_t v57 = 0;
      v58[0] = 0;
      uint64_t v41 = (v29 >> 15) & 0x1FFFE;
      unint64_t v42 = v37 + v41;
      unint64_t v43 = v38 + v41;
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)v58 + 1, v37 + v39, a3);
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)v58, v42, v44);
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)&v57 + 1, v40, v45);
      int8x8_t result = CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)&v57, v43, v46);
      int8x16_t v47 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v57, HIDWORD(v57)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0]))), vdupq_n_s16((v36 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0])));
      *(int16x4_t *)v47.i8 = vadd_s16(*(int16x4_t *)v47.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL), *(int16x4_t *)v47.i8), vdup_n_s16((v31 >> 1) & 0x7F80)));
      float v6 = v6 + v5;
      v8 += v51;
      v7 += v52;
      *(_DWORD *)int v3 = vuzp1_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v47.i8).u32[0];
      v3 += 4;
      int v9 = v50;
    }
    while (v4);
  }
  return result;
}

unsigned int *CA::OGL::SW::Format::CbYCrY8::load_1(unsigned int *this, unint64_t a2, const unsigned __int8 *a3)
{
  int v3 = *(unsigned __int8 *)(a2 & 0xFFFFFFFFFFFFFFFDLL) - 128;
  int v4 = *(unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFDLL) + 2) - 128;
  int v5 = 38155 * *(unsigned __int8 *)(a2 + 1) - 610480;
  int v6 = (v5 + 52299 * v4) >> 15;
  if (v6 >= 255) {
    int v6 = 255;
  }
  if (v6 >= 0) {
    unsigned int v7 = (v6 << 16) | 0xFF000000;
  }
  else {
    unsigned int v7 = -16777216;
  }
  int v8 = (v5 - 12836 * v3 - 26638 * v4) >> 15;
  if (v8 >= 255) {
    int v8 = 255;
  }
  if (v8 >= 0) {
    int v9 = v8 << 8;
  }
  else {
    int v9 = 0;
  }
  int v10 = (v5 + 66101 * v3) >> 15;
  if (v10 >= 255) {
    int v10 = 255;
  }
  *this = v9 | v10 & ~(v10 >> 31) | v7;
  return this;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::CbYCrY8,unsigned int,true,true,false,true>(int *a1, int a2, const unsigned __int8 *a3)
{
  v36[1] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    int v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    uint64_t v33 = *(void *)(*(void *)a1 + 16);
    uint64_t v34 = **(void **)a1;
    int v5 = a1[15];
    int v31 = *(_DWORD *)(*(void *)a1 + 36);
    int v32 = *(_DWORD *)(*(void *)a1 + 32);
    int v30 = a1[16];
    int v6 = a1[13];
    int v29 = a1[14];
    do
    {
      --v4;
      int v7 = v32 - 0x8000;
      if (v6 < v32 - 0x8000) {
        int v7 = v6;
      }
      if (v7 <= -32768) {
        int v7 = -32768;
      }
      unsigned int v8 = v7 + 0x8000;
      if (v6 <= 0x8000) {
        int v9 = 0x8000;
      }
      else {
        int v9 = v6;
      }
      int v10 = v9 - 0x8000;
      if (v10 >= v32) {
        int v11 = v32;
      }
      else {
        int v11 = v10;
      }
      if (v5 >= v31 - 0x8000) {
        int v12 = v31 - 0x8000;
      }
      else {
        int v12 = v5;
      }
      if (v12 <= -32768) {
        int v12 = -32768;
      }
      unsigned int v13 = v12 + 0x8000;
      if (v5 <= 0x8000) {
        int v14 = 0x8000;
      }
      else {
        int v14 = v5;
      }
      int v15 = v14 - 0x8000;
      if (v15 >= v31) {
        int v16 = v31;
      }
      else {
        int v16 = v15;
      }
      uint64_t v17 = v34 + v33 * ((uint64_t)v16 >> 16);
      uint64_t v18 = v34 + v33 * HIWORD(v13);
      signed int v19 = (v11 >> 15) & 0xFFFFFFFE;
      unint64_t v20 = v18 + v19;
      uint64_t v35 = 0;
      v36[0] = 0;
      uint64_t v21 = (v8 >> 15) & 0x1FFFE;
      unint64_t v22 = v17 + v21;
      unint64_t v23 = v18 + v21;
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)v36 + 1, v17 + v19, a3);
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)v36, v22, v24);
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)&v35 + 1, v20, v25);
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)&v35, v23, v26);
      int8x16_t v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v35, HIDWORD(v35)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0]))), vdupq_n_s16((v16 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0])));
      *(int16x4_t *)v27.i8 = vadd_s16(*(int16x4_t *)v27.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), vdup_n_s16((v11 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v27.i8, *(int8x8_t *)v27.i8);
      v6 += v29;
      v5 += v30;
      *(_DWORD *)int v3 = result.i32[0];
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

unsigned int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::CbYCrY8,unsigned int,true,true,true,false>(unsigned int *result, int a2, const unsigned __int8 *a3)
{
  uint64_t v34 = result;
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    int v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    int v5 = *(float **)result;
    uint64_t v35 = *(void *)(*(void *)result + 16);
    uint64_t v36 = **(void **)result;
    int v6 = *(_DWORD *)(*(void *)result + 32);
    int v7 = *(_DWORD *)(*(void *)result + 36);
    float v8 = *(float *)(*((void *)result + 3) + 12);
    float v9 = *(float *)(*((void *)result + 2) + 12);
    int v10 = result[15];
    unsigned int v11 = result[16];
    int v12 = result[13];
    unsigned int v13 = result[14];
    int v14 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v15 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v16 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v17 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      unsigned int v37 = 0;
      v18.f32[0] = (float)(1.0 / v9) * (float)v12;
      v18.f32[1] = (float)(1.0 / v9) * (float)v10;
      int32x2_t v19 = vcvt_s32_f32(v18);
      switch(v14)
      {
        case 0:
          float32x2_t v20 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v19));
          float32x2_t v21 = vmul_f32(v20, v20);
          float32x2_t v22 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 1), v21);
          v21.f32[0] = fmaxf(vaddv_f32(v21), 0.00001);
          v21.i32[0] = vmul_f32(v22, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 0))).u32[0];
          v21.i32[1] = 0.5;
          float32x2_t v23 = vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float v24 = atan2f(v5[11] * (float)v19.i32[1], v5[10] * (float)v19.i32[0]);
          v25.i32[1] = 1056964608;
          v25.f32[0] = (float)(v24 * -10430.0) + 32768.0;
          float32x2_t v23 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v26 = vmul_f32(vcvt_f32_s32(v19), vmul_f32(v15, *(float32x2_t *)(v5 + 10)));
          float32x2_t v23 = vmul_f32(vmla_f32(*(float32x2_t *)(v34 + 23), *(float32x2_t *)(v34 + 21), vminnm_f32(vsub_f32(v26, vrndm_f32(v26)), v16)), vmul_f32(v17, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v27 = vcvt_f32_s32(v19);
          float32x2_t v28 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v29 = vmul_f32(*(float32x2_t *)(v34 + 21), v28);
          float32x2_t v30 = vmul_f32(*(float32x2_t *)(v34 + 23), v28);
          float32x2_t v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v30), (int8x8_t)v30, (int8x8_t)v27);
          float32x2_t v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, v31), (int8x8_t)v29, (int8x8_t)v31);
LABEL_8:
          int32x2_t v19 = vcvt_s32_f32(v23);
          break;
        default:
          break;
      }
      --v4;
      int v32 = v19.i32[0] & ~(v19.i32[0] >> 31);
      if (v32 >= v6) {
        int v32 = v6;
      }
      int v33 = v19.i32[1] & ~(v19.i32[1] >> 31);
      if (v33 >= v7) {
        int v33 = v7;
      }
      int8x8_t result = CA::OGL::SW::Format::CbYCrY8::load_1(&v37, v36 + v35 * ((uint64_t)v33 >> 16) + (int)((v32 >> 15) & 0xFFFFFFFE), a3);
      float v9 = v9 + v8;
      v12 += v13;
      v10 += v11;
      *(_DWORD *)int v3 = v37;
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

unsigned int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::CbYCrY8,unsigned int,true,true,false,false>(unsigned int *result, int a2, const unsigned __int8 *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    int v3 = (unsigned __int8 *)a3;
    int v4 = a2;
    uint64_t v5 = **(void **)result;
    uint64_t v6 = *(void *)(*(void *)result + 16);
    int v7 = *(_DWORD *)(*(void *)result + 32);
    int v8 = *(_DWORD *)(*(void *)result + 36);
    int v10 = result[15];
    unsigned int v9 = result[16];
    int v12 = result[13];
    unsigned int v11 = result[14];
    do
    {
      --v4;
      unsigned int v15 = 0;
      int v13 = v12 & ~(v12 >> 31);
      if (v13 >= v7) {
        int v13 = v7;
      }
      int v14 = v10 & ~(v10 >> 31);
      if (v14 >= v8) {
        int v14 = v8;
      }
      int8x8_t result = CA::OGL::SW::Format::CbYCrY8::load_1(&v15, v5 + v6 * ((uint64_t)v14 >> 16) + (int)((v13 >> 15) & 0xFFFFFFFE), a3);
      v12 += v11;
      v10 += v9;
      *(_DWORD *)int v3 = v15;
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    uint64_t v12 = *((unsigned int *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    int v14 = *((_DWORD *)result + 14);
    uint64_t v16 = (v8 - 0x8000);
    int v17 = v9 - 0x8000;
    float v18 = 1.0;
    int v19 = *((unsigned __int8 *)result + 48) - 1;
    int8x8_t v20 = (int8x8_t)vdup_n_s32(0x70707u);
    float32x2_t v59 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v60 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v58 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v64 = v14;
    int v65 = v8;
    float32x2_t v63 = result;
    int v62 = v9 - 0x8000;
    int v61 = v19;
    do
    {
      v21.f32[0] = (float)(v18 / v11) * (float)v15;
      v21.f32[1] = (float)(v18 / v11) * (float)v13;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v19)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float32x2_t v27 = v5;
          uint64_t v28 = v9;
          uint64_t v29 = v12;
          uint64_t v30 = v16;
          float v31 = atan2f(v5[11] * (float)v22.i32[1], v5[10] * (float)v22.i32[0]);
          float v18 = 1.0;
          uint64_t v16 = v30;
          int v14 = v64;
          int v8 = v65;
          uint64_t v12 = v29;
          int v19 = v61;
          uint64_t v9 = v28;
          uint64_t v5 = v27;
          int v17 = v62;
          int8x8_t result = v63;
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v32, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v33 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v60, *(float32x2_t *)(v5 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v59)), vmul_f32(v58, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v34 = vcvt_f32_s32(v22);
          float32x2_t v35 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v36 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          float32x2_t v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v37), (int8x8_t)v37, (int8x8_t)v34);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v36, (int8x8_t)v38);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      int v39 = v22.i32[0];
      if (v22.i32[0] >= (int)v16) {
        int v40 = v16;
      }
      else {
        int v40 = v22.i32[0];
      }
      if (v40 <= -32768) {
        int v40 = -32768;
      }
      unsigned int v41 = v40 + 0x8000;
      if (v22.i32[0] <= 0x8000) {
        int v39 = 0x8000;
      }
      int v42 = v39 - 0x8000;
      if (v42 >= v8) {
        int v42 = v8;
      }
      int v43 = v22.i32[1];
      if (v22.i32[1] >= v17) {
        int v44 = v17;
      }
      else {
        int v44 = v22.i32[1];
      }
      if (v44 <= -32768) {
        int v44 = -32768;
      }
      unsigned int v45 = v44 + 0x8000;
      if (v22.i32[1] <= 0x8000) {
        int v43 = 0x8000;
      }
      int v46 = v43 - 0x8000;
      if (v46 >= (int)v9) {
        int v46 = v9;
      }
      uint64_t v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      uint64_t v48 = v6 + v7 * HIWORD(v45);
      unint64_t v49 = ((uint64_t)v42 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v50 = (v41 >> 15) & 0x1FFFE;
      v22.i16[0] = *(_WORD *)(v47 + v49);
      v22.i16[2] = *(_WORD *)(v47 + v50);
      uint32x2_t v51 = (uint32x2_t)vand_s8((int8x8_t)v22, (int8x8_t)0xFFFF0000FFFFLL);
      int8x8_t v52 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v51, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v51, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v22, 9uLL), (int8x8_t)0xF8000000F80000));
      int32x2_t v53 = (int32x2_t)vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v52, 3uLL), v20);
      int8x8_t v54 = vorr_s8(v52, (int8x8_t)v53);
      v53.i16[0] = *(_WORD *)(v48 + v49);
      v53.i16[2] = *(_WORD *)(v48 + v50);
      uint32x2_t v55 = (uint32x2_t)vand_s8((int8x8_t)v53, (int8x8_t)0xFFFF0000FFFFLL);
      int8x8_t v56 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v55, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v55, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v53, 9uLL), (int8x8_t)0xF8000000F80000));
      int8x16_t v57 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(v56, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v56, 3uLL), v20)) | 0xFF000000FF000000), (uint8x8_t)(*(void *)&v54 | 0xFF000000FF000000)), vdupq_n_s16((v46 >> 1) & 0x7F80)), (uint8x8_t)(*(void *)&v54 | 0xFF000000FF000000));
      *(int16x4_t *)v57.i8 = vadd_s16(*(int16x4_t *)v57.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL), *(int16x4_t *)v57.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v57.i8, *(int8x8_t *)v57.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  if (a2)
  {
    uint64_t v12 = **(void **)result;
    uint64_t v13 = *(void *)(*(void *)result + 16);
    int v14 = *(_DWORD *)(*(void *)result + 32);
    int v15 = *(_DWORD *)(*(void *)result + 36);
    int v17 = *(_DWORD *)(result + 60);
    int v16 = *(_DWORD *)(result + 64);
    int v19 = *(_DWORD *)(result + 52);
    int v18 = *(_DWORD *)(result + 56);
    int8x8_t result = 4294934528;
    int8x8_t v20 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      if (v19 >= v14 - 0x8000) {
        int v21 = v14 - 0x8000;
      }
      else {
        int v21 = v19;
      }
      if (v21 <= -32768) {
        int v21 = -32768;
      }
      unsigned int v22 = v21 + 0x8000;
      if (v19 <= 0x8000) {
        int v23 = 0x8000;
      }
      else {
        int v23 = v19;
      }
      int v24 = v23 - 0x8000;
      if (v24 >= v14) {
        int v24 = v14;
      }
      if (v17 >= v15 - 0x8000) {
        int v25 = v15 - 0x8000;
      }
      else {
        int v25 = v17;
      }
      if (v25 <= -32768) {
        int v25 = -32768;
      }
      unsigned int v26 = v25 + 0x8000;
      if (v17 <= 0x8000) {
        int v27 = 0x8000;
      }
      else {
        int v27 = v17;
      }
      int v28 = v27 - 0x8000;
      if (v28 >= v15) {
        int v28 = v15;
      }
      uint64_t v29 = v12 + v13 * ((uint64_t)v28 >> 16);
      uint64_t v30 = v12 + v13 * HIWORD(v26);
      unint64_t v31 = ((uint64_t)v24 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v32 = (v22 >> 15) & 0x1FFFE;
      a11.i16[0] = *(_WORD *)(v29 + v31);
      a11.i16[2] = *(_WORD *)(v29 + v32);
      uint32x2_t v33 = (uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL);
      v11.i16[0] = *(_WORD *)(v30 + v31);
      v11.i16[2] = *(_WORD *)(v30 + v32);
      uint32x2_t v34 = (uint32x2_t)vand_s8((int8x8_t)v11, (int8x8_t)0xFFFF0000FFFFLL);
      int8x8_t v35 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v33, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v33, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32((int32x2_t)a11, 9uLL), (int8x8_t)0xF8000000F80000));
      int8x8_t v36 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v11, 9uLL), (int8x8_t)0xF8000000F80000));
      int32x2_t v11 = (int32x2_t)vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v36, 3uLL), v20);
      unint64_t v37 = *(void *)&vorr_s8(v35, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v35, 3uLL), v20)) | 0xFF000000FF000000;
      int8x16_t v38 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(v36, (int8x8_t)v11) | 0xFF000000FF000000), (uint8x8_t)v37), vdupq_n_s16((v28 >> 1) & 0x7F80)), (uint8x8_t)v37);
      a11 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v38.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL), *(int16x4_t *)v38.i8), vdup_n_s16((v24 >> 1) & 0x7F80))), (int8x8_t)0xFFFF0000FFFFLL);
      v19 += v18;
      v17 += v16;
      *a3++ = a11.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v6 = result[14];
    int v7 = result[15];
    int v8 = result[13];
    int v9 = *(_DWORD *)(*(void *)result + 32);
    int v10 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v11 = *(void *)(*(void *)result + 16);
    uint64_t v12 = **(void **)result;
    if (v7 >= v10 - 0x8000) {
      int v13 = v10 - 0x8000;
    }
    else {
      int v13 = result[15];
    }
    if (v13 <= -32768) {
      int v13 = -32768;
    }
    if (v7 <= 0x8000) {
      int v7 = 0x8000;
    }
    int v14 = v7 - 0x8000;
    if (v14 >= v10) {
      int v15 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v15 = v14;
    }
    uint64_t v16 = v12 + v11 * ((uint64_t)v15 >> 16);
    uint64_t v17 = v12 + v11 * ((v13 + 0x8000) >> 16);
    a4.i32[0] = (v15 >> 1) & 0x7F80;
    int8x8_t v18 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      if (v8 >= v9 - 0x8000) {
        int v19 = v9 - 0x8000;
      }
      else {
        int v19 = v8;
      }
      if (v19 <= -32768) {
        int v19 = -32768;
      }
      if (v8 <= 0x8000) {
        int v20 = 0x8000;
      }
      else {
        int v20 = v8;
      }
      int v21 = v20 - 0x8000;
      unsigned int v22 = v19 + 0x8000;
      if (v21 >= v9) {
        int v21 = v9;
      }
      unint64_t v23 = ((uint64_t)v21 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      int v24 = (__int16 *)(v16 + v23);
      int8x8_t result = (_DWORD *)(v17 + v23);
      uint64_t v25 = (v22 >> 15) & 0x1FFFE;
      v4.i16[0] = *v24;
      v4.i16[2] = *(_WORD *)(v16 + v25);
      uint32x2_t v26 = (uint32x2_t)vand_s8((int8x8_t)v4, (int8x8_t)0xFFFF0000FFFFLL);
      v5.i16[0] = *(_WORD *)result;
      v5.i16[2] = *(_WORD *)(v17 + v25);
      uint32x2_t v27 = (uint32x2_t)vand_s8((int8x8_t)v5, (int8x8_t)0xFFFF0000FFFFLL);
      int8x8_t v28 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v26, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v26, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v4, 9uLL), (int8x8_t)0xF8000000F80000));
      int32x2_t v5 = vshl_n_s32(v5, 9uLL);
      int8x8_t v29 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v27, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v27, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)v5, (int8x8_t)0xF8000000F80000));
      unint64_t v30 = *(void *)&vorr_s8(v28, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v28, 3uLL), v18)) | 0xFF000000FF000000;
      int8x16_t v31 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(v29, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v29, 3uLL), v18)) | 0xFF000000FF000000), (uint8x8_t)v30), a4, 0), (uint8x8_t)v30);
      int32x2_t v4 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v31.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL), *(int16x4_t *)v31.i8), vdup_n_s16((v21 >> 1) & 0x7F80))), (int8x8_t)a4);
      v8 += v6;
      *a3++ = v4.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,true,false,false,true>(_DWORD *result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  if (a2)
  {
    uint64_t v12 = **(void **)result;
    uint64_t v13 = *(void *)(*(void *)result + 16);
    int v14 = result[16];
    int v15 = result[14];
    int v16 = result[13] - 0x8000;
    int v17 = result[15] - 0x8000;
    int8x8_t v18 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      uint64_t v19 = v12 + v13 * ((uint64_t)v17 >> 16);
      uint64_t v20 = v12 + v13 * ((uint64_t)(v17 + 0x10000) >> 16);
      unint64_t v21 = ((uint64_t)v16 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      int8x8_t result = (_DWORD *)(v19 + v21);
      unint64_t v22 = ((uint64_t)(v16 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      a11.i16[0] = *(_WORD *)(v19 + v21);
      a11.i16[2] = *(_WORD *)(v19 + v22);
      uint32x2_t v23 = (uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL);
      v11.i16[0] = *(_WORD *)(v20 + v21);
      v11.i16[2] = *(_WORD *)(v20 + v22);
      uint32x2_t v24 = (uint32x2_t)vand_s8((int8x8_t)v11, (int8x8_t)0xFFFF0000FFFFLL);
      int8x8_t v25 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v23, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v23, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32((int32x2_t)a11, 9uLL), (int8x8_t)0xF8000000F80000));
      int8x8_t v26 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v24, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v24, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v11, 9uLL), (int8x8_t)0xF8000000F80000));
      unint64_t v27 = *(void *)&vorr_s8(v25, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v25, 3uLL), v18)) | 0xFF000000FF000000;
      int8x16_t v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(v26, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v26, 3uLL), v18)) | 0xFF000000FF000000), (uint8x8_t)v27), vdupq_n_s16((v17 >> 1) & 0x7F80)), (uint8x8_t)v27);
      a11 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v28.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), vdup_n_s16((v16 >> 1) & 0x7F80))), (int8x8_t)0xFFFF0000FFFFLL);
      *a3++ = a11.i32[0];
      v16 += v15;
      v17 += v14;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v6 = result[14];
    int v7 = result[15];
    uint64_t v8 = *(void *)(*(void *)result + 16);
    uint64_t v9 = **(void **)result;
    int v10 = v7 + 0x8000;
    unsigned int v11 = v7 - 0x8000;
    uint64_t v12 = v9 + v8 * ((uint64_t)(v7 - 0x8000) >> 16);
    uint64_t v13 = v9 + v8 * ((uint64_t)v10 >> 16);
    a4.i32[0] = (v11 >> 1) & 0x7F80;
    int v14 = result[13] - 0x8000;
    int8x8_t v15 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      unint64_t v16 = ((uint64_t)v14 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v17 = ((uint64_t)(v14 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v4.i16[0] = *(_WORD *)(v12 + v16);
      v4.i16[2] = *(_WORD *)(v12 + v17);
      uint32x2_t v18 = (uint32x2_t)vand_s8((int8x8_t)v4, (int8x8_t)0xFFFF0000FFFFLL);
      v5.i16[0] = *(_WORD *)(v13 + v16);
      v5.i16[2] = *(_WORD *)(v13 + v17);
      uint32x2_t v19 = (uint32x2_t)vand_s8((int8x8_t)v5, (int8x8_t)0xFFFF0000FFFFLL);
      int8x8_t v20 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v18, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v18, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v4, 9uLL), (int8x8_t)0xF8000000F80000));
      int32x2_t v5 = vshl_n_s32(v5, 9uLL);
      int8x8_t v21 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v19, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v19, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)v5, (int8x8_t)0xF8000000F80000));
      unint64_t v22 = *(void *)&vorr_s8(v20, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v20, 3uLL), v15)) | 0xFF000000FF000000;
      int8x16_t v23 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(v21, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v21, 3uLL), v15)) | 0xFF000000FF000000), (uint8x8_t)v22), a4, 0), (uint8x8_t)v22);
      int32x2_t v4 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v23.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL), *(int16x4_t *)v23.i8), vdup_n_s16((v14 >> 1) & 0x7F80))), (int8x8_t)a4);
      *a3++ = v4.i32[0];
      v14 += v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v41 = v13;
    int v39 = v17;
    uint64_t v40 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v39;
          uint64_t v8 = v40;
          int v13 = v41;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      unsigned int v37 = *(unsigned __int16 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      unsigned int v38 = (v37 << 6) & 0xF800 | (8 * (v37 & 0x1F)) | (((v37 >> 10) & 0x1F) << 19);
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = v38 | (v38 >> 3) & 0x7070707 | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      unsigned int v13 = *(unsigned __int16 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      int8x8_t result = (int *)((v13 << 6) & 0xF800 | (8 * (v13 & 0x1F)) | (((v13 >> 10) & 0x1F) << 19));
      v10 += v9;
      v8 += v7;
      *a3++ = result | (result >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      unsigned int v9 = *(unsigned __int16 *)(v7 + (((uint64_t)v8 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      unsigned int v10 = (v9 << 6) & 0xF800 | (8 * (v9 & 0x1F)) | (((v9 >> 10) & 0x1F) << 19);
      v4 += v3;
      *a3++ = v10 | (v10 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      unsigned int v9 = *(unsigned __int16 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      unsigned int v10 = (v9 << 6) & 0xF800 | (8 * (v9 & 0x1F)) | (((v9 >> 10) & 0x1F) << 19);
      v8 += v7;
      v6 += v5;
      *a3++ = v10 | (v10 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      unsigned int v6 = *(unsigned __int16 *)(v5 + (((uint64_t)v4 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      unsigned int v7 = (v6 << 6) & 0xF800 | (8 * (v6 & 0x1F)) | (((v6 >> 10) & 0x1F) << 19);
      v4 += v3;
      *a3++ = v7 | (v7 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Rev,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    float v18 = 1.0;
    int v19 = *((unsigned __int8 *)result + 48) - 1;
    int8x8_t v20 = (int8x8_t)vdup_n_s32(0x70707u);
    float32x2_t v61 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v62 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v60 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v66 = v8;
    int v67 = v12;
    int v64 = v9 - 0x8000;
    int v65 = v8 - 0x8000;
    int v63 = v19;
    do
    {
      v21.f32[0] = (float)(v18 / v11) * (float)v15;
      v21.f32[1] = (float)(v18 / v11) * (float)v13;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v19)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = result;
          float32x2_t v28 = v5;
          uint64_t v29 = v9;
          uint64_t v30 = v14;
          float v31 = atan2f(v5[11] * (float)v22.i32[1], v5[10] * (float)v22.i32[0]);
          float v18 = 1.0;
          int v16 = v65;
          int v8 = v66;
          uint64_t v14 = v30;
          int v19 = v63;
          int v12 = v67;
          uint64_t v9 = v29;
          uint64_t v5 = v28;
          int v17 = v64;
          int8x8_t result = v27;
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v32, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v33 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v62, *(float32x2_t *)(v5 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v61)), vmul_f32(v60, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v34 = vcvt_f32_s32(v22);
          float32x2_t v35 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v36 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          float32x2_t v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v37), (int8x8_t)v37, (int8x8_t)v34);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v36, (int8x8_t)v38);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      int v39 = v22.i32[0];
      if (v22.i32[0] >= v16) {
        int v40 = v16;
      }
      else {
        int v40 = v22.i32[0];
      }
      if (v40 <= -32768) {
        int v40 = -32768;
      }
      unsigned int v41 = v40 + 0x8000;
      if (v22.i32[0] <= 0x8000) {
        int v39 = 0x8000;
      }
      int v42 = v39 - 0x8000;
      if (v42 >= v8) {
        int v42 = v8;
      }
      int v43 = v22.i32[1];
      if (v22.i32[1] >= v17) {
        int v44 = v17;
      }
      else {
        int v44 = v22.i32[1];
      }
      if (v44 <= -32768) {
        int v44 = -32768;
      }
      unsigned int v45 = v44 + 0x8000;
      if (v22.i32[1] <= 0x8000) {
        int v43 = 0x8000;
      }
      int v46 = v43 - 0x8000;
      if (v46 >= (int)v9) {
        int v46 = v9;
      }
      uint64_t v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      uint64_t v48 = v6 + v7 * HIWORD(v45);
      unint64_t v49 = ((uint64_t)v42 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v50 = (v41 >> 15) & 0x1FFFE;
      v22.i16[0] = *(_WORD *)(v47 + v49);
      v22.i16[2] = *(_WORD *)(v47 + v50);
      uint32x2_t v51 = (uint32x2_t)vrev32_s8((int8x8_t)v22);
      uint32x2_t v52 = vshr_n_u32(v51, 0x10uLL);
      int8x8_t v53 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v52, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v52, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshr_n_u32(v51, 7uLL), (int8x8_t)0xF8000000F80000));
      int8x8_t v54 = vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v53, 3uLL), v20);
      int8x8_t v55 = vorr_s8(v53, v54);
      v54.i16[0] = *(_WORD *)(v48 + v49);
      v54.i16[2] = *(_WORD *)(v48 + v50);
      uint32x2_t v56 = (uint32x2_t)vrev32_s8(v54);
      uint32x2_t v57 = vshr_n_u32(v56, 0x10uLL);
      int8x8_t v58 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v57, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v57, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshr_n_u32(v56, 7uLL), (int8x8_t)0xF8000000F80000));
      int8x16_t v59 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(v58, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v58, 3uLL), v20)) | 0xFF000000FF000000), (uint8x8_t)(*(void *)&v55 | 0xFF000000FF000000)), vdupq_n_s16((v46 >> 1) & 0x7F80)), (uint8x8_t)(*(void *)&v55 | 0xFF000000FF000000));
      *(int16x4_t *)v59.i8 = vadd_s16(*(int16x4_t *)v59.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v59, v59, 8uLL), *(int16x4_t *)v59.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v59.i8, *(int8x8_t *)v59.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Rev,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, int8x8_t a10)
{
  if (a2)
  {
    uint64_t v11 = **(void **)result;
    uint64_t v12 = *(void *)(*(void *)result + 16);
    int v13 = *(_DWORD *)(*(void *)result + 32);
    int v14 = *(_DWORD *)(*(void *)result + 36);
    int v16 = *(_DWORD *)(result + 60);
    int v15 = *(_DWORD *)(result + 64);
    int v18 = *(_DWORD *)(result + 52);
    int v17 = *(_DWORD *)(result + 56);
    int8x8_t result = 4294934528;
    int8x8_t v19 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      if (v18 >= v13 - 0x8000) {
        int v20 = v13 - 0x8000;
      }
      else {
        int v20 = v18;
      }
      if (v20 <= -32768) {
        int v21 = -32768;
      }
      else {
        int v21 = v20;
      }
      if (v18 <= 0x8000) {
        int v22 = 0x8000;
      }
      else {
        int v22 = v18;
      }
      int v23 = v22 - 0x8000;
      if (v23 >= v13) {
        int v23 = v13;
      }
      if (v16 >= v14 - 0x8000) {
        int v24 = v14 - 0x8000;
      }
      else {
        int v24 = v16;
      }
      if (v24 <= -32768) {
        int v24 = -32768;
      }
      if (v16 <= 0x8000) {
        int v25 = 0x8000;
      }
      else {
        int v25 = v16;
      }
      int v26 = v25 - 0x8000;
      unsigned int v27 = v24 + 0x8000;
      if (v26 >= v14) {
        int v28 = v14;
      }
      else {
        int v28 = v26;
      }
      uint64_t v29 = v11 + v12 * ((uint64_t)v28 >> 16);
      uint64_t v30 = v11 + v12 * HIWORD(v27);
      unint64_t v31 = ((uint64_t)v23 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v32 = ((v21 + 0x8000) >> 15) & 0x1FFFE;
      a10.i16[0] = *(_WORD *)(v29 + v31);
      a10.i16[2] = *(_WORD *)(v29 + v32);
      uint32x2_t v33 = (uint32x2_t)vrev32_s8(a10);
      uint32x2_t v34 = vshr_n_u32(v33, 0x10uLL);
      v10.i16[0] = *(_WORD *)(v30 + v31);
      v10.i16[2] = *(_WORD *)(v30 + v32);
      uint32x2_t v35 = (uint32x2_t)vrev32_s8(v10);
      uint32x2_t v36 = vshr_n_u32(v35, 0x10uLL);
      int8x8_t v37 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshr_n_u32(v33, 7uLL), (int8x8_t)0xF8000000F80000));
      int8x8_t v38 = vorr_s8(vand_s8((int8x8_t)vshl_u32(v36, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v36, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8));
      int8x8_t v10 = vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v37, 3uLL), v19);
      int8x8_t v39 = vorr_s8(v38, vand_s8((int8x8_t)vshr_n_u32(v35, 7uLL), (int8x8_t)0xF8000000F80000));
      unint64_t v40 = *(void *)&vorr_s8(v37, v10) | 0xFF000000FF000000;
      int8x16_t v41 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(void *)&vorr_s8(v39, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v39, 3uLL), v19)) | 0xFF000000FF000000), (uint8x8_t)v40), vdupq_n_s16((v28 >> 1) & 0x7F80)), (uint8x8_t)v40);
      a10 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v41.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL), *(int16x4_t *)v41.i8), vdup_n_s16((v23 >> 1) & 0x7F80))), (int8x8_t)0x300000006);
      v18 += v17;
      v16 += v15;
      *a3++ = a10.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Rev,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v41 = v13;
    int v39 = v17;
    uint64_t v40 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v39;
          uint64_t v8 = v40;
          int v13 = v41;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      unsigned int v37 = bswap32(*(unsigned __int16 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      unsigned int v38 = (v37 >> 13) & 0xF8 | (v37 >> 10) & 0xF800 | (v37 >> 7) & 0xF80000;
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = v38 | (v38 >> 3) & 0x7070707 | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Rev,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      unsigned int v13 = bswap32(*(unsigned __int16 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      int8x8_t result = (int *)((v13 >> 10) & 0xF800);
      unsigned int v14 = (v13 >> 13) & 0xF8 | result | (v13 >> 7) & 0xF80000;
      v10 += v9;
      v8 += v7;
      *a3++ = v14 | (v14 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v58 = v8;
    int v59 = v12;
    int v56 = v9 - 0x8000;
    int v57 = v8 - 0x8000;
    int v55 = v18;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v23));
          float32x2_t v25 = vmul_f32(v24, v24);
          float32x2_t v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          float32x2_t v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float32x2_t v28 = result;
          uint64_t v29 = v7;
          uint64_t v30 = v9;
          uint64_t v31 = v14;
          float v32 = atan2f(v5[11] * (float)v23.i32[1], v5[10] * (float)v23.i32[0]);
          int v16 = v57;
          int v8 = v58;
          uint64_t v14 = v31;
          int v18 = v55;
          int v12 = v59;
          uint64_t v9 = v30;
          uint64_t v7 = v29;
          int v17 = v56;
          int8x8_t result = v28;
          v33.i32[1] = 1056964608;
          v33.f32[0] = (float)(v32 * -10430.0) + 32768.0;
          float32x2_t v27 = vmul_f32(v33, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v34 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, *(float32x2_t *)(v5 + 10)));
          float32x2_t v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v34, vrndm_f32(v34)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v35 = vcvt_f32_s32(v23);
          float32x2_t v36 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 84), v36);
          float32x2_t v38 = vmul_f32(*(float32x2_t *)((char *)result + 92), v36);
          float32x2_t v39 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v38), (int8x8_t)v38, (int8x8_t)v35);
          float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v37, v39), (int8x8_t)v37, (int8x8_t)v39);
LABEL_8:
          int32x2_t v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      int v40 = v23.i32[0];
      if (v23.i32[0] >= v16) {
        int v41 = v16;
      }
      else {
        int v41 = v23.i32[0];
      }
      if (v41 <= -32768) {
        int v41 = -32768;
      }
      unsigned int v42 = v41 + 0x8000;
      if (v23.i32[0] <= 0x8000) {
        int v40 = 0x8000;
      }
      int v43 = v40 - 0x8000;
      int v44 = v23.i32[1];
      if (v43 >= v8) {
        int v43 = v8;
      }
      if (v23.i32[1] >= v17) {
        int v45 = v17;
      }
      else {
        int v45 = v23.i32[1];
      }
      if (v45 <= -32768) {
        int v45 = -32768;
      }
      unsigned int v46 = v45 + 0x8000;
      if (v23.i32[1] <= 0x8000) {
        int v44 = 0x8000;
      }
      int v47 = v44 - 0x8000;
      if (v47 >= (int)v9) {
        int v47 = v9;
      }
      uint64_t v48 = v6 + v7 * ((uint64_t)v47 >> 16);
      uint64_t v49 = v6 + v7 * HIWORD(v46);
      unint64_t v50 = ((uint64_t)v43 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v51 = (v42 >> 14) & 0x3FFFC;
      v52.i32[0] = *(_DWORD *)(v49 + v50) | 0xFF000000;
      v52.i32[1] = *(_DWORD *)(v49 + v51) | 0xFF000000;
      v53.i32[0] = *(_DWORD *)(v48 + v50) | 0xFF000000;
      v53.i32[1] = *(_DWORD *)(v48 + v51) | 0xFF000000;
      int8x16_t v54 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v52, v53), vdupq_n_s16((v47 >> 1) & 0x7F80)), v53);
      *(int16x4_t *)v54.i8 = vadd_s16(*(int16x4_t *)v54.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL), *(int16x4_t *)v54.i8), vdup_n_s16((v43 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v54.i8, *(int8x8_t *)v54.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = *(_DWORD *)(*(void *)a1 + 32);
    int v6 = *(_DWORD *)(*(void *)a1 + 36);
    int v8 = a1[15];
    int v7 = a1[16];
    int v10 = a1[13];
    int v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000) {
        int v11 = v5 - 0x8000;
      }
      else {
        int v11 = v10;
      }
      if (v11 <= -32768) {
        int v11 = -32768;
      }
      if (v10 <= 0x8000) {
        int v12 = 0x8000;
      }
      else {
        int v12 = v10;
      }
      int v13 = v12 - 0x8000;
      if (v13 >= v5) {
        int v13 = v5;
      }
      if (v8 >= v6 - 0x8000) {
        int v14 = v6 - 0x8000;
      }
      else {
        int v14 = v8;
      }
      if (v14 <= -32768) {
        int v14 = -32768;
      }
      unsigned int v15 = v14 + 0x8000;
      if (v8 <= 0x8000) {
        int v16 = 0x8000;
      }
      else {
        int v16 = v8;
      }
      int v17 = v16 - 0x8000;
      if (v17 >= v6) {
        int v17 = v6;
      }
      uint64_t v18 = v3 + v4 * ((uint64_t)v17 >> 16);
      uint64_t v19 = v3 + v4 * HIWORD(v15);
      unint64_t v20 = ((uint64_t)v13 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v21 = ((v11 + 0x8000) >> 14) & 0x3FFFC;
      v22.i32[0] = *(_DWORD *)(v19 + v20) | 0xFF000000;
      v22.i32[1] = *(_DWORD *)(v19 + v21) | 0xFF000000;
      v23.i32[0] = *(_DWORD *)(v18 + v20) | 0xFF000000;
      v23.i32[1] = *(_DWORD *)(v18 + v21) | 0xFF000000;
      int8x16_t v24 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v22, v23), vdupq_n_s16((v17 >> 1) & 0x7F80)), v23);
      *(int16x4_t *)v24.i8 = vadd_s16(*(int16x4_t *)v24.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), *(int16x4_t *)v24.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v24.i8, *(int8x8_t *)v24.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    int v6 = result[13];
    int v7 = *(_DWORD *)(*(void *)result + 32);
    int v8 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v9 = *(void *)(*(void *)result + 16);
    uint64_t v10 = **(void **)result;
    if (v5 >= v8 - 0x8000) {
      int v11 = v8 - 0x8000;
    }
    else {
      int v11 = result[15];
    }
    if (v11 <= -32768) {
      int v11 = -32768;
    }
    if (v5 <= 0x8000) {
      int v5 = 0x8000;
    }
    int v12 = v5 - 0x8000;
    if (v12 >= v8) {
      int v13 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v13 = v12;
    }
    uint64_t v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    uint64_t v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    do
    {
      if (v6 >= v7 - 0x8000) {
        int v16 = v7 - 0x8000;
      }
      else {
        int v16 = v6;
      }
      if (v16 <= -32768) {
        int v16 = -32768;
      }
      if (v6 <= 0x8000) {
        int v17 = 0x8000;
      }
      else {
        int v17 = v6;
      }
      unsigned int v18 = v16 + 0x8000;
      int v19 = v17 - 0x8000;
      if (v19 >= v7) {
        int v19 = v7;
      }
      int8x8_t result = (_DWORD *)(((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v20 = (v18 >> 14) & 0x3FFFC;
      v21.i32[0] = *(_DWORD *)((char *)result + v15) | 0xFF000000;
      v21.i32[1] = *(_DWORD *)(v15 + v20) | 0xFF000000;
      v22.i32[0] = *(_DWORD *)((char *)result + v14) | 0xFF000000;
      v22.i32[1] = *(_DWORD *)(v14 + v20) | 0xFF000000;
      int8x16_t v23 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v21, v22), a4, 0), v22);
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v23.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL), *(int16x4_t *)v23.i8), vdup_n_s16((v19 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = a1[16];
    int v6 = a1[14];
    int v7 = a1[13] - 0x8000;
    int v8 = a1[15] - 0x8000;
    do
    {
      uint64_t v9 = v3 + v4 * ((uint64_t)v8 >> 16);
      uint64_t v10 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      unint64_t v11 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v12 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v13.i32[0] = *(_DWORD *)(v9 + v11) | 0xFF000000;
      v13.i32[1] = *(_DWORD *)(v9 + v12) | 0xFF000000;
      v14.i32[0] = *(_DWORD *)(v10 + v11) | 0xFF000000;
      v14.i32[1] = *(_DWORD *)(v10 + v12) | 0xFF000000;
      int8x16_t v15 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v14, v13), vdupq_n_s16((v8 >> 1) & 0x7F80)), v13);
      *(int16x4_t *)v15.i8 = vadd_s16(*(int16x4_t *)v15.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL), *(int16x4_t *)v15.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v15.i8, *(int8x8_t *)v15.i8);
      *a3++ = result.i32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    uint64_t v6 = *(void *)(*(void *)result + 16);
    uint64_t v7 = **(void **)result;
    int v8 = v5 + 0x8000;
    unsigned int v9 = v5 - 0x8000;
    uint64_t v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    uint64_t v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    int v12 = result[13] - 0x8000;
    do
    {
      unint64_t v13 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v14 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v15.i32[0] = *(_DWORD *)(v11 + v13) | 0xFF000000;
      v15.i32[1] = *(_DWORD *)(v11 + v14) | 0xFF000000;
      v16.i32[0] = *(_DWORD *)(v10 + v13) | 0xFF000000;
      v16.i32[1] = *(_DWORD *)(v10 + v14) | 0xFF000000;
      int8x16_t v17 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v15, v16), a4, 0), v16);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v17.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL), *(int16x4_t *)v17.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v39 = v13;
    int v37 = v17;
    uint64_t v38 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v37;
          uint64_t v8 = v38;
          int v13 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = *(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      v10 += v9;
      v8 += v7;
      *a3++ = *(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      v4 += v3;
      *a3++ = *(_DWORD *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      unsigned int v9 = *(_DWORD *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF000000;
      v8 += v7;
      v6 += v5;
      *a3++ = v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      unsigned int v6 = *(_DWORD *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF000000;
      v4 += v3;
      *a3++ = v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Rev,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v59 = v8;
    int v60 = v12;
    int v57 = v9 - 0x8000;
    int v58 = v8 - 0x8000;
    int v56 = v18;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v23));
          float32x2_t v25 = vmul_f32(v24, v24);
          float32x2_t v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          float32x2_t v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float32x2_t v28 = result;
          uint64_t v29 = v7;
          uint64_t v30 = v9;
          uint64_t v31 = v14;
          float v32 = atan2f(v5[11] * (float)v23.i32[1], v5[10] * (float)v23.i32[0]);
          int v16 = v58;
          int v8 = v59;
          uint64_t v14 = v31;
          int v18 = v56;
          int v12 = v60;
          uint64_t v9 = v30;
          uint64_t v7 = v29;
          int v17 = v57;
          int8x8_t result = v28;
          v33.i32[1] = 1056964608;
          v33.f32[0] = (float)(v32 * -10430.0) + 32768.0;
          float32x2_t v27 = vmul_f32(v33, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v34 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, *(float32x2_t *)(v5 + 10)));
          float32x2_t v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v34, vrndm_f32(v34)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v35 = vcvt_f32_s32(v23);
          float32x2_t v36 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 84), v36);
          float32x2_t v38 = vmul_f32(*(float32x2_t *)((char *)result + 92), v36);
          float32x2_t v39 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v38), (int8x8_t)v38, (int8x8_t)v35);
          float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v37, v39), (int8x8_t)v37, (int8x8_t)v39);
LABEL_8:
          int32x2_t v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      int v40 = v23.i32[0];
      if (v23.i32[0] >= v16) {
        int v41 = v16;
      }
      else {
        int v41 = v23.i32[0];
      }
      if (v41 <= -32768) {
        int v41 = -32768;
      }
      unsigned int v42 = v41 + 0x8000;
      if (v23.i32[0] <= 0x8000) {
        int v40 = 0x8000;
      }
      int v43 = v40 - 0x8000;
      if (v43 >= v8) {
        int v43 = v8;
      }
      int v44 = v23.i32[1];
      if (v23.i32[1] >= v17) {
        int v45 = v17;
      }
      else {
        int v45 = v23.i32[1];
      }
      if (v45 <= -32768) {
        int v45 = -32768;
      }
      unsigned int v46 = v45 + 0x8000;
      if (v23.i32[1] <= 0x8000) {
        int v44 = 0x8000;
      }
      int v47 = v44 - 0x8000;
      if (v47 >= (int)v9) {
        int v47 = v9;
      }
      uint64_t v48 = v6 + v7 * ((uint64_t)v47 >> 16);
      uint64_t v49 = v6 + v7 * HIWORD(v46);
      unint64_t v50 = ((uint64_t)v43 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v51 = (v42 >> 14) & 0x3FFFC;
      v52.i32[0] = *(_DWORD *)(v48 + v50) | 0xFF;
      v52.i32[1] = *(_DWORD *)(v48 + v51) | 0xFF;
      uint8x8_t v53 = (uint8x8_t)vrev32_s8(v52);
      v54.i32[0] = *(_DWORD *)(v49 + v50) | 0xFF;
      v54.i32[1] = *(_DWORD *)(v49 + v51) | 0xFF;
      int8x16_t v55 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vrev32_s8(v54), v53), vdupq_n_s16((v47 >> 1) & 0x7F80)), v53);
      *(int16x4_t *)v55.i8 = vadd_s16(*(int16x4_t *)v55.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL), *(int16x4_t *)v55.i8), vdup_n_s16((v43 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v55.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Rev,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = *(_DWORD *)(*(void *)a1 + 32);
    int v6 = *(_DWORD *)(*(void *)a1 + 36);
    int v8 = a1[15];
    int v7 = a1[16];
    int v10 = a1[13];
    int v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000) {
        int v11 = v5 - 0x8000;
      }
      else {
        int v11 = v10;
      }
      if (v11 <= -32768) {
        int v11 = -32768;
      }
      unsigned int v12 = v11 + 0x8000;
      if (v10 <= 0x8000) {
        int v13 = 0x8000;
      }
      else {
        int v13 = v10;
      }
      int v14 = v13 - 0x8000;
      if (v14 >= v5) {
        int v14 = v5;
      }
      if (v8 >= v6 - 0x8000) {
        int v15 = v6 - 0x8000;
      }
      else {
        int v15 = v8;
      }
      if (v15 <= -32768) {
        int v15 = -32768;
      }
      unsigned int v16 = v15 + 0x8000;
      if (v8 <= 0x8000) {
        int v17 = 0x8000;
      }
      else {
        int v17 = v8;
      }
      int v18 = v17 - 0x8000;
      if (v18 >= v6) {
        int v18 = v6;
      }
      uint64_t v19 = v3 + v4 * ((uint64_t)v18 >> 16);
      uint64_t v20 = v3 + v4 * HIWORD(v16);
      uint64_t v21 = (v12 >> 14) & 0x3FFFC;
      unint64_t v22 = ((uint64_t)v14 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v23.i32[0] = *(_DWORD *)(v20 + v22) | 0xFF;
      v23.i32[1] = *(_DWORD *)(v20 + v21) | 0xFF;
      v24.i32[0] = *(_DWORD *)(v19 + v22) | 0xFF;
      v24.i32[1] = *(_DWORD *)(v19 + v21) | 0xFF;
      uint8x8_t v25 = (uint8x8_t)vrev32_s8(v24);
      int8x16_t v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vrev32_s8(v23), v25), vdupq_n_s16((v18 >> 1) & 0x7F80)), v25);
      *(int16x4_t *)v26.i8 = vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v14 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v26.i8, *(int8x8_t *)v26.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Rev,unsigned int,true,true,true,false>(uint64_t **a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v39 = v13;
    int v37 = v17;
    uint64_t v38 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v37;
          uint64_t v8 = v38;
          int v13 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = bswap32(*(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF);
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Rev,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      v10 += v9;
      v8 += v7;
      *a3++ = bswap32(*(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF);
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v58 = v8;
    int v59 = v12;
    int v56 = v9 - 0x8000;
    int v57 = v8 - 0x8000;
    int v55 = v18;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v23));
          float32x2_t v25 = vmul_f32(v24, v24);
          float32x2_t v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          float32x2_t v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float32x2_t v28 = result;
          uint64_t v29 = v7;
          uint64_t v30 = v9;
          uint64_t v31 = v14;
          float v32 = atan2f(v5[11] * (float)v23.i32[1], v5[10] * (float)v23.i32[0]);
          int v16 = v57;
          int v8 = v58;
          uint64_t v14 = v31;
          int v18 = v55;
          int v12 = v59;
          uint64_t v9 = v30;
          uint64_t v7 = v29;
          int v17 = v56;
          int8x8_t result = v28;
          v33.i32[1] = 1056964608;
          v33.f32[0] = (float)(v32 * -10430.0) + 32768.0;
          float32x2_t v27 = vmul_f32(v33, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v34 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, *(float32x2_t *)(v5 + 10)));
          float32x2_t v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v34, vrndm_f32(v34)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v35 = vcvt_f32_s32(v23);
          float32x2_t v36 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 84), v36);
          float32x2_t v38 = vmul_f32(*(float32x2_t *)((char *)result + 92), v36);
          float32x2_t v39 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v38), (int8x8_t)v38, (int8x8_t)v35);
          float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v37, v39), (int8x8_t)v37, (int8x8_t)v39);
LABEL_8:
          int32x2_t v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      int v40 = v23.i32[0];
      if (v23.i32[0] >= v16) {
        int v41 = v16;
      }
      else {
        int v41 = v23.i32[0];
      }
      if (v41 <= -32768) {
        int v41 = -32768;
      }
      unsigned int v42 = v41 + 0x8000;
      if (v23.i32[0] <= 0x8000) {
        int v40 = 0x8000;
      }
      int v43 = v40 - 0x8000;
      if (v43 >= v8) {
        int v43 = v8;
      }
      int v44 = v23.i32[1];
      if (v23.i32[1] >= v17) {
        int v45 = v17;
      }
      else {
        int v45 = v23.i32[1];
      }
      if (v45 <= -32768) {
        int v45 = -32768;
      }
      unsigned int v46 = v45 + 0x8000;
      if (v23.i32[1] <= 0x8000) {
        int v44 = 0x8000;
      }
      int v47 = v44 - 0x8000;
      if (v47 >= (int)v9) {
        int v47 = v9;
      }
      uint64_t v48 = v6 + v7 * ((uint64_t)v47 >> 16);
      uint64_t v49 = v6 + v7 * HIWORD(v46);
      unint64_t v50 = ((uint64_t)v43 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v51 = (v42 >> 14) & 0x3FFFC;
      v52.i32[0] = *(_DWORD *)(v48 + v50);
      v52.i32[1] = *(_DWORD *)(v48 + v51);
      v53.i32[0] = *(_DWORD *)(v49 + v50);
      v53.i32[1] = *(_DWORD *)(v49 + v51);
      int8x16_t v54 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v53, v52), vdupq_n_s16((v47 >> 1) & 0x7F80)), v52);
      *(int16x4_t *)v54.i8 = vadd_s16(*(int16x4_t *)v54.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL), *(int16x4_t *)v54.i8), vdup_n_s16((v43 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v54.i8, *(int8x8_t *)v54.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = *(_DWORD *)(*(void *)a1 + 32);
    int v6 = *(_DWORD *)(*(void *)a1 + 36);
    int v8 = a1[15];
    int v7 = a1[16];
    int v10 = a1[13];
    int v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000) {
        int v11 = v5 - 0x8000;
      }
      else {
        int v11 = v10;
      }
      if (v11 <= -32768) {
        int v11 = -32768;
      }
      if (v10 <= 0x8000) {
        int v12 = 0x8000;
      }
      else {
        int v12 = v10;
      }
      int v13 = v12 - 0x8000;
      if (v13 >= v5) {
        int v13 = v5;
      }
      if (v8 >= v6 - 0x8000) {
        int v14 = v6 - 0x8000;
      }
      else {
        int v14 = v8;
      }
      if (v14 <= -32768) {
        int v14 = -32768;
      }
      if (v8 <= 0x8000) {
        int v15 = 0x8000;
      }
      else {
        int v15 = v8;
      }
      int v16 = v15 - 0x8000;
      unsigned int v17 = v14 + 0x8000;
      if (v16 >= v6) {
        int v16 = v6;
      }
      uint64_t v18 = v3 + v4 * ((uint64_t)v16 >> 16);
      uint64_t v19 = v3 + v4 * HIWORD(v17);
      unint64_t v20 = ((uint64_t)v13 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v21 = ((v11 + 0x8000) >> 14) & 0x3FFFC;
      v22.i32[0] = *(_DWORD *)(v18 + v20);
      v23.i32[0] = *(_DWORD *)(v19 + v20);
      v22.i32[1] = *(_DWORD *)(v18 + v21);
      v23.i32[1] = *(_DWORD *)(v19 + v21);
      int8x16_t v24 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v23, v22), vdupq_n_s16((v16 >> 1) & 0x7F80)), v22);
      *(int16x4_t *)v24.i8 = vadd_s16(*(int16x4_t *)v24.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), *(int16x4_t *)v24.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v24.i8, *(int8x8_t *)v24.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    int v6 = result[13];
    int v7 = *(_DWORD *)(*(void *)result + 32);
    int v8 = *(_DWORD *)(*(void *)result + 36);
    uint64_t v9 = *(void *)(*(void *)result + 16);
    uint64_t v10 = **(void **)result;
    if (v5 >= v8 - 0x8000) {
      int v11 = v8 - 0x8000;
    }
    else {
      int v11 = result[15];
    }
    if (v11 <= -32768) {
      int v11 = -32768;
    }
    if (v5 <= 0x8000) {
      int v5 = 0x8000;
    }
    int v12 = v5 - 0x8000;
    if (v12 >= v8) {
      int v13 = *(_DWORD *)(*(void *)result + 36);
    }
    else {
      int v13 = v12;
    }
    uint64_t v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    uint64_t v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    do
    {
      if (v6 >= v7 - 0x8000) {
        int v16 = v7 - 0x8000;
      }
      else {
        int v16 = v6;
      }
      if (v16 <= -32768) {
        int v16 = -32768;
      }
      unsigned int v17 = v16 + 0x8000;
      if (v6 <= 0x8000) {
        int v18 = 0x8000;
      }
      else {
        int v18 = v6;
      }
      int v19 = v18 - 0x8000;
      if (v19 >= v7) {
        int v19 = v7;
      }
      int8x8_t result = (_DWORD *)(((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v20 = (v17 >> 14) & 0x3FFFC;
      v21.i32[0] = *(_DWORD *)((char *)result + v14);
      v21.i32[1] = *(_DWORD *)(v14 + v20);
      v22.i32[0] = *(_DWORD *)((char *)result + v15);
      v22.i32[1] = *(_DWORD *)(v15 + v20);
      int8x16_t v23 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v22, v21), a4, 0), v21);
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v23.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL), *(int16x4_t *)v23.i8), vdup_n_s16((v19 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = a1[16];
    int v6 = a1[14];
    int v7 = a1[13] - 0x8000;
    int v8 = a1[15] - 0x8000;
    do
    {
      uint64_t v9 = v3 + v4 * ((uint64_t)v8 >> 16);
      uint64_t v10 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      unint64_t v11 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v12 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v13.i32[0] = *(_DWORD *)(v9 + v11);
      v14.i32[0] = *(_DWORD *)(v10 + v11);
      v13.i32[1] = *(_DWORD *)(v9 + v12);
      v14.i32[1] = *(_DWORD *)(v10 + v12);
      int8x16_t v15 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v14, v13), vdupq_n_s16((v8 >> 1) & 0x7F80)), v13);
      *(int16x4_t *)v15.i8 = vadd_s16(*(int16x4_t *)v15.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL), *(int16x4_t *)v15.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v15.i8, *(int8x8_t *)v15.i8);
      *a3++ = result.i32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  if (a2)
  {
    int v4 = result[14];
    int v5 = result[15];
    uint64_t v6 = *(void *)(*(void *)result + 16);
    uint64_t v7 = **(void **)result;
    int v8 = v5 + 0x8000;
    unsigned int v9 = v5 - 0x8000;
    uint64_t v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    uint64_t v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    int v12 = result[13] - 0x8000;
    do
    {
      unint64_t v13 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v14 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v15.i32[0] = *(_DWORD *)(v10 + v13);
      v15.i32[1] = *(_DWORD *)(v10 + v14);
      v16.i32[0] = *(_DWORD *)(v11 + v13);
      v16.i32[1] = *(_DWORD *)(v11 + v14);
      int8x16_t v17 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v16, v15), a4, 0), v15);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v17.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL), *(int16x4_t *)v17.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,true,true,true,false>(uint64_t **a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v39 = v13;
    int v37 = v17;
    uint64_t v38 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v37;
          uint64_t v8 = v38;
          int v13 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = *(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      v10 += v9;
      v8 += v7;
      *a3++ = *(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,false,true,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v3 = result[14];
    int v4 = result[13];
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(void *)result + 36)) {
      int v6 = *(_DWORD *)(*(void *)result + 36);
    }
    uint64_t v7 = **(void **)result + *(void *)(*(void *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      int v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5) {
        int v8 = v5;
      }
      v4 += v3;
      *a3++ = *(_DWORD *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,true,false,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v6 = result[15];
    int v5 = result[16];
    int v8 = result[13];
    int v7 = result[14];
    do
    {
      int v9 = *(_DWORD *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v8 += v7;
      v6 += v5;
      *a3++ = v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,false,false,false,false>(uint64_t result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(result + 52);
    int v3 = *(_DWORD *)(result + 56);
    uint64_t v5 = **(void **)result + *(void *)(*(void *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      int v6 = *(_DWORD *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v4 += v3;
      *a3++ = v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Rev,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = (float *)*result;
    uint64_t v6 = **result;
    uint64_t v7 = (*result)[2];
    int v8 = *((_DWORD *)*result + 8);
    uint64_t v9 = *((unsigned int *)*result + 9);
    float v10 = *((float *)result[3] + 3);
    float v11 = *((float *)result[2] + 3);
    int v13 = *((_DWORD *)result + 15);
    int v12 = *((_DWORD *)result + 16);
    int v15 = *((_DWORD *)result + 13);
    uint64_t v14 = *((unsigned int *)result + 14);
    int v16 = v8 - 0x8000;
    int v17 = v9 - 0x8000;
    int v18 = *((unsigned __int8 *)result + 48) - 1;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v59 = v8;
    int v60 = v12;
    int v57 = v9 - 0x8000;
    int v58 = v8 - 0x8000;
    int v56 = v18;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      int32x2_t v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          float32x2_t v24 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v23));
          float32x2_t v25 = vmul_f32(v24, v24);
          float32x2_t v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          float32x2_t v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          float32x2_t v28 = result;
          uint64_t v29 = v7;
          uint64_t v30 = v9;
          uint64_t v31 = v14;
          float v32 = atan2f(v5[11] * (float)v23.i32[1], v5[10] * (float)v23.i32[0]);
          int v16 = v58;
          int v8 = v59;
          uint64_t v14 = v31;
          int v18 = v56;
          int v12 = v60;
          uint64_t v9 = v30;
          uint64_t v7 = v29;
          int v17 = v57;
          int8x8_t result = v28;
          v33.i32[1] = 1056964608;
          v33.f32[0] = (float)(v32 * -10430.0) + 32768.0;
          float32x2_t v27 = vmul_f32(v33, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v34 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, *(float32x2_t *)(v5 + 10)));
          float32x2_t v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v34, vrndm_f32(v34)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v35 = vcvt_f32_s32(v23);
          float32x2_t v36 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          float32x2_t v37 = vmul_f32(*(float32x2_t *)((char *)result + 84), v36);
          float32x2_t v38 = vmul_f32(*(float32x2_t *)((char *)result + 92), v36);
          float32x2_t v39 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v38), (int8x8_t)v38, (int8x8_t)v35);
          float32x2_t v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v37, v39), (int8x8_t)v37, (int8x8_t)v39);
LABEL_8:
          int32x2_t v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      int v40 = v23.i32[0];
      if (v23.i32[0] >= v16) {
        int v41 = v16;
      }
      else {
        int v41 = v23.i32[0];
      }
      if (v41 <= -32768) {
        int v41 = -32768;
      }
      unsigned int v42 = v41 + 0x8000;
      if (v23.i32[0] <= 0x8000) {
        int v40 = 0x8000;
      }
      int v43 = v40 - 0x8000;
      int v44 = v23.i32[1];
      if (v43 >= v8) {
        int v43 = v8;
      }
      if (v23.i32[1] >= v17) {
        int v45 = v17;
      }
      else {
        int v45 = v23.i32[1];
      }
      if (v45 <= -32768) {
        int v45 = -32768;
      }
      unsigned int v46 = v45 + 0x8000;
      if (v23.i32[1] <= 0x8000) {
        int v44 = 0x8000;
      }
      int v47 = v44 - 0x8000;
      if (v47 >= (int)v9) {
        int v47 = v9;
      }
      uint64_t v48 = v6 + v7 * ((uint64_t)v47 >> 16);
      uint64_t v49 = v6 + v7 * HIWORD(v46);
      unint64_t v50 = ((uint64_t)v43 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v51 = (v42 >> 14) & 0x3FFFC;
      v52.i32[0] = *(_DWORD *)(v48 + v50);
      v52.i32[1] = *(_DWORD *)(v48 + v51);
      uint8x8_t v53 = (uint8x8_t)vrev32_s8(v52);
      v54.i32[0] = *(_DWORD *)(v49 + v50);
      v54.i32[1] = *(_DWORD *)(v49 + v51);
      int8x16_t v55 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vrev32_s8(v54), v53), vdupq_n_s16((v47 >> 1) & 0x7F80)), v53);
      *(int16x4_t *)v55.i8 = vadd_s16(*(int16x4_t *)v55.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL), *(int16x4_t *)v55.i8), vdup_n_s16((v43 >> 1) & 0x7F80)));
      float v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v55.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Rev,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)a1;
    uint64_t v4 = *(void *)(*(void *)a1 + 16);
    int v5 = *(_DWORD *)(*(void *)a1 + 32);
    int v6 = *(_DWORD *)(*(void *)a1 + 36);
    int v8 = a1[15];
    int v7 = a1[16];
    int v10 = a1[13];
    int v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000) {
        int v11 = v5 - 0x8000;
      }
      else {
        int v11 = v10;
      }
      if (v11 <= -32768) {
        int v11 = -32768;
      }
      if (v10 <= 0x8000) {
        int v12 = 0x8000;
      }
      else {
        int v12 = v10;
      }
      int v13 = v12 - 0x8000;
      if (v13 >= v5) {
        int v13 = v5;
      }
      if (v8 >= v6 - 0x8000) {
        int v14 = v6 - 0x8000;
      }
      else {
        int v14 = v8;
      }
      if (v14 <= -32768) {
        int v14 = -32768;
      }
      unsigned int v15 = v14 + 0x8000;
      if (v8 <= 0x8000) {
        int v16 = 0x8000;
      }
      else {
        int v16 = v8;
      }
      int v17 = v16 - 0x8000;
      if (v17 >= v6) {
        int v17 = v6;
      }
      uint64_t v18 = v3 + v4 * ((uint64_t)v17 >> 16);
      uint64_t v19 = v3 + v4 * HIWORD(v15);
      unint64_t v20 = ((uint64_t)v13 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v21 = ((v11 + 0x8000) >> 14) & 0x3FFFC;
      v22.i32[0] = *(_DWORD *)(v18 + v20);
      v23.i32[0] = *(_DWORD *)(v19 + v20);
      v23.i32[1] = *(_DWORD *)(v19 + v21);
      v22.i32[1] = *(_DWORD *)(v18 + v21);
      uint8x8_t v24 = (uint8x8_t)vrev32_s8(v22);
      int8x16_t v25 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vrev32_s8(v23), v24), vdupq_n_s16((v17 >> 1) & 0x7F80)), v24);
      *(int16x4_t *)v25.i8 = vadd_s16(*(int16x4_t *)v25.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL), *(int16x4_t *)v25.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      int8x8_t result = vuzp1_s8(*(int8x8_t *)v25.i8, *(int8x8_t *)v25.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Rev,unsigned int,true,true,true,false>(uint64_t **a1, int a2, _DWORD *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v6 = (float *)*a1;
    uint64_t v7 = **a1;
    uint64_t v8 = (*a1)[2];
    __int32 v10 = *((_DWORD *)*a1 + 8);
    int v9 = *((_DWORD *)*a1 + 9);
    float v11 = *((float *)a1[3] + 3);
    float v12 = *((float *)a1[2] + 3);
    int v14 = *((_DWORD *)a1 + 15);
    int v13 = *((_DWORD *)a1 + 16);
    int v15 = *((_DWORD *)a1 + 13);
    int v16 = *((_DWORD *)a1 + 14);
    int v17 = *((unsigned __int8 *)a1 + 48) - 1;
    float32x2_t v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    float32x2_t v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    int v39 = v13;
    int v37 = v17;
    uint64_t v38 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v15;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      int32x2_t v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          float32x2_t v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          float32x2_t v24 = vmul_f32(v23, v23);
          float32x2_t v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          float32x2_t v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          float v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          int v17 = v37;
          uint64_t v8 = v38;
          int v13 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          float32x2_t v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          float32x2_t v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          float32x2_t v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          float32x2_t v30 = vcvt_f32_s32(v22);
          float32x2_t v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          float32x2_t v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          float32x2_t v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          float32x2_t v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          float32x2_t v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          int32x2_t v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      __int32 v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10) {
        __int32 v35 = v10;
      }
      int v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9) {
        int v36 = v9;
      }
      float v12 = v12 + v11;
      v15 += v16;
      v14 += v13;
      *a3++ = bswap32(*(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      --v4;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Rev,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = **(void **)result;
    uint64_t v4 = *(void *)(*(void *)result + 16);
    int v5 = *(_DWORD *)(*(void *)result + 32);
    int v6 = *(_DWORD *)(*(void *)result + 36);
    int v8 = result[15];
    int v7 = result[16];
    int v10 = result[13];
    int v9 = result[14];
    do
    {
      int v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5) {
        int v11 = v5;
      }
      int v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6) {
        int v12 = v6;
      }
      v10 += v9;
      v8 += v7;
      *a3++ = bswap32(*(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SWContext::get(uint64_t a1, int a2)
{
  uint64_t result = 1;
  switch(a2)
  {
    case 1:
    case 2:
      uint64_t result = 4096;
      break;
    case 3:
      uint64_t result = 3;
      break;
    case 4:
    case 7:
      uint64_t result = 0x4000;
      break;
    case 5:
      goto LABEL_7;
    case 6:
    case 8:
      return result;
    default:
      if (a2 != 21)
      {
        if (a2 == 28) {
          uint64_t result = 0;
        }
        else {
LABEL_7:
        }
          uint64_t result = a2 == 28 || a2 == 16;
      }
      break;
  }
  return result;
}

void CA::OGL::SWContext::~SWContext(CA::OGL::SWContext *this)
{
  CA::OGL::Context::~Context(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void *CA::Transaction::reset_animators(void *this)
{
  uint64_t v1 = this[1];
  if (v1)
  {
    uint64_t v2 = this;
    do
    {
      if (*(void *)v1) {
        _Block_release(*(const void **)v1);
      }
      uint64_t v1 = *(void *)(v1 + 8);
    }
    while (v1);
    this = (void *)v2[1];
    if (this)
    {
      do
      {
        uint64_t v3 = (void *)this[1];
        free(this);
        this = v3;
      }
      while (v3);
    }
    v2[1] = 0;
  }
  return this;
}

void CA::Transaction::release_thread(CA::Transaction *this, void *a2, uint64_t a3, void *a4)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)this + 13);
  if (!*(_DWORD *)v5) {
    goto LABEL_8;
  }
  kdebug_trace();
  if (!CA::Transaction::_debug_transactions)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      int v9 = x_log_category_api;
      BOOL v6 = os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT);
      if (v6)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_184668000, v9, OS_LOG_TYPE_DEFAULT, "CoreAnimation: warning, deleted thread with uncommitted CATransaction; set CA_DEBUG_TRANSACTIONS=1 in environm"
          "ent to log backtraces, or set CA_ASSERT_MAIN_THREAD_TRANSACTIONS=1 to abort when an implicit transaction isn't"
          " created on a main thread.\n",
          buf,
          2u);
      }
    }
    goto LABEL_7;
  }
  x_log_begin();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    float32x2_t v32 = x_log_category_api;
    if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_184668000, v32, OS_LOG_TYPE_DEFAULT, "CoreAnimation: warning, deleted thread with uncommitted CATransaction; created by:\n",
        buf,
        2u);
    }
  }
  float32x2_t v33 = backtrace_symbols(*(void *const **)(v5 + 240), *(unsigned __int16 *)(v5 + 206));
  if (v33)
  {
    if (*(_WORD *)(v5 + 206))
    {
      unint64_t v34 = 0;
      do
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          __int32 v35 = x_log_category_api;
          if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
          {
            int v36 = v33[v34];
            *(_DWORD *)buf = 136315138;
            uint64_t v51 = v36;
            _os_log_impl(&dword_184668000, v35, OS_LOG_TYPE_DEFAULT, "%s\n", buf, 0xCu);
          }
        }
        ++v34;
      }
      while (v34 < *(unsigned __int16 *)(v5 + 206));
    }
    free(v33);
  }
  int v47 = (void **)x_stream_pop_(0);
  int v37 = x_stream_get(v47);
  int v38 = 0;
  while (2)
  {
    uint64_t v39 = 0;
    int v40 = &v37[v38];
    int v41 = -1;
    while (1)
    {
      if (v40[v39] == 10)
      {
        int v41 = v39;
        goto LABEL_71;
      }
      if (!v40[v39]) {
        break;
      }
LABEL_71:
      ++v39;
      unsigned int v42 = 32512;
      if (v39 == 32512) {
        goto LABEL_72;
      }
    }
    unsigned int v42 = v39;
LABEL_72:
    if (v41 <= -1 || v40[v42] == 0) {
      int v44 = v42;
    }
    else {
      int v44 = v41 + 1;
    }
    if (v44 >= 1)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int v45 = x_log_category_api;
        if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          if (v38) {
            unsigned int v46 = "continued...\n";
          }
          else {
            unsigned int v46 = "";
          }
          uint64_t v51 = v46;
          __int16 v52 = 1040;
          int v53 = v44;
          __int16 v54 = 2080;
          int8x16_t v55 = &v37[v38];
          _os_log_impl(&dword_184668000, v45, OS_LOG_TYPE_DEFAULT, "%s%.*s", buf, 0x1Cu);
        }
      }
      v38 += v44;
      continue;
    }
    break;
  }
  x_log_end_free_(v47);
LABEL_7:
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  *(void *)(StatusReg + 576) = this;
  int v11 = (void *)MEMORY[0x185324A30](v6, v7, v8);
  CA::Transaction::commit(this);
  *(void *)(StatusReg + 576) = 0;
  kdebug_trace();
LABEL_8:
  int v12 = (CA::Layer *)*((void *)this + 6);
  if (v12)
  {
    int v13 = 0;
    while (*((void *)v12 + 3))
    {
      if (v13)
      {
        uint64_t v14 = 0;
        uint64_t v15 = 1 << *(_DWORD *)v12;
        do
        {
          for (uint64_t i = *(uint64_t ***)(*((void *)v12 + 2) + 8 * v14); i; uint64_t i = (uint64_t **)*i)
            CA::move_root((CA *)i[2], (CA::Layer *)i[3], v13, a4);
          ++v14;
        }
        while (v14 != v15);
        x_hash_table_remove_all(*((void **)this + 6));
      }
      else
      {
        *((void *)this + 6) = 0;
        int v13 = v12;
      }
      uint64_t v17 = 0;
      v48[0] = &unk_1ED030D18;
      uint64_t v49 = v48;
      uint64_t v18 = 1 << *(_DWORD *)v13;
      do
      {
        for (uint64_t j = *(void **)(*((void *)v13 + 2) + 8 * v17); j; uint64_t j = (void *)*j)
          X::HashTable<CA::Layer *,CA::Layer *>::foreach(std::function<void ()(CA::Layer *,CA::Layer *)>)::{lambda(void *,void *,void *)#1}::__invoke(j[2], j[3], (uint64_t)v48);
        ++v17;
      }
      while (v17 != v18);
      if (v49 == v48)
      {
        (*(void (**)(void *))(v48[0] + 32))(v48);
      }
      else if (v49)
      {
        (*(void (**)(void *, void *, uint64_t))(*v49 + 40))(v49, a2, a3);
      }
      x_hash_table_remove_all(v13);
      int v12 = (CA::Layer *)*((void *)this + 6);
      if (!v12) {
        goto LABEL_27;
      }
    }
    x_hash_table_free(v12);
    if (v13) {
LABEL_27:
    }
      x_hash_table_free(v13);
  }
  float32x2_t v20 = (__CFRunLoopObserver *)*((void *)this + 8);
  if (v20)
  {
    CFRunLoopObserverInvalidate(v20);
    CFRelease(*((CFTypeRef *)this + 8));
  }
  if (*(void *)(v5 + 16)) {
    CA::Transaction::free_command_list(*(void **)(v5 + 16));
  }
  float32x2_t v21 = *(void **)(v5 + 64);
  if (v21) {
    CA::Transaction::free_commit_handlers_list(v21);
  }
  int32x2_t v22 = *(void **)(v5 + 72);
  if (v22) {
    CA::Transaction::free_commit_handlers_list(v22);
  }
  float32x2_t v23 = *(void **)(v5 + 80);
  if (v23) {
    CA::Transaction::free_commit_handlers_list(v23);
  }
  float32x2_t v24 = *(void **)(v5 + 88);
  if (v24) {
    CA::Transaction::free_commit_handlers_list(v24);
  }
  float32x2_t v25 = *(void **)(v5 + 96);
  if (v25) {
    CA::Transaction::free_commit_handlers_list(v25);
  }
  float32x2_t v26 = *(void **)(v5 + 104);
  if (v26) {
    CA::Transaction::free_commit_handlers_list(v26);
  }
  float v27 = *(void **)(v5 + 48);
  if (v27)
  {
    CA::Transaction::free_batch_handlers_list(v27);
    *(void *)(v5 + 48) = 0;
  }
  if (*(void *)(v5 + 24))
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    float32x2_t v29 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    *float32x2_t v29 = *(void *)(v5 + 24);
    v29[1] = 0;
    do
    {
      uint64_t v30 = CA::Transaction::global_deleted[0];
      v29[1] = CA::Transaction::global_deleted[0];
      uint64_t v31 = v30;
      atomic_compare_exchange_strong(CA::Transaction::global_deleted, (unint64_t *)&v31, (unint64_t)v29);
    }
    while (v31 != v30);
  }
  CA::Transaction::reset_animators(this);
  free(this);
}

void sub_18489CD28(_Unwind_Exception *a1)
{
}

void CA::Transaction::free_commit_handlers_list(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = (const void **)a1;
  do
  {
    _Block_release(*v2);
    uint64_t v2 = (const void **)v2[1];
  }
  while (v2);
  if (v1)
  {
    do
    {
      uint64_t v3 = (void *)v1[1];
      free(v1);
      uint64_t v1 = v3;
    }
    while (v3);
  }
}

void CA::Transaction::free_batch_handlers_list(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    uint64_t v2 = (const void **)a1;
    do
    {
      _Block_release(*v2);
      uint64_t v2 = (const void **)v2[1];
    }
    while (v2);
    do
    {
      uint64_t v3 = (void *)v1[1];
      free(v1);
      uint64_t v1 = v3;
    }
    while (v3);
  }
}

uint64_t X::HashTable<CA::Layer *,CA::Layer *>::foreach(std::function<void ()(CA::Layer *,CA::Layer *)>)::{lambda(void *,void *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6[1] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2;
  v6[0] = a1;
  uint64_t v3 = *(void *)(a3 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:nn180100]();
  }
  return (*(uint64_t (**)(uint64_t, void *, uint64_t *))(*(void *)v3 + 48))(v3, v6, &v5);
}

void std::__function::__func<CA::Transaction::release_thread(void *)::$_0,std::allocator<CA::Transaction::release_thread(void *)::$_0>,void ()(CA::Layer *,CA::Layer *)>::operator()(uint64_t a1, atomic_uint **a2)
{
  uint64_t v2 = *a2;
  while (1)
  {
    atomic_uint v3 = *v2;
    if (!*v2) {
      break;
    }
    atomic_uint v4 = *v2;
    atomic_compare_exchange_strong(v2, (unsigned int *)&v4, v3 - 1);
    if (v4 == v3)
    {
      if (v3 == 1)
      {
        CA::Layer::destroy((CA::Layer *)v2);
        CA::Layer::~Layer((CA::AttrList **)v2);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, v2);
      }
      return;
    }
  }
}

void std::__function::__func<CA::Transaction::release_thread(void *)::$_0,std::allocator<CA::Transaction::release_thread(void *)::$_0>,void ()(CA::Layer *,CA::Layer *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ED030D18;
}

void *std::__function::__func<CA::Transaction::release_thread(void *)::$_0,std::allocator<CA::Transaction::release_thread(void *)::$_0>,void ()(CA::Layer *,CA::Layer *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1ED030D18;
  return result;
}

void std::__function::__func<CA::Transaction::release_thread(void *)::$_0,std::allocator<CA::Transaction::release_thread(void *)::$_0>,void ()(CA::Layer *,CA::Layer *)>::~__func()
{
}

void CA::CA_ABORT_ON_NON_MAIN_THREAD_TRANSACTION_PUSH(CA *this)
{
}

BOOL CA::HDRProcessorInternal::prefers_async(CA::HDRProcessorInternal *this, const CA::Render::Update *a2)
{
  unsigned int v2 = *((_DWORD *)a2 + 120);
  if (CADeviceHasHardwareAcceleratedHDR::once[0] != -1) {
    dispatch_once(CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_132);
  }
  BOOL v4 = v2 < 2 || v2 == 3;
  return CADeviceHasHardwareAcceleratedHDR::has_capability && v4;
}

uint64_t CA::HDRProcessorInternal::configure_display_pipe_tonemap(os_unfair_lock_s *a1, __IOSurface *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  if (hdrprocessing_init_once != -1) {
    dispatch_once_f(&hdrprocessing_init_once, 0, (dispatch_function_t)load_hdrprocessing_symbols);
  }
  if (hdr_handle)
  {
    uint64_t v15 = (void *)MEMORY[0x185324A30]();
    IOSurfaceGetPixelFormat(a2);
    int v96 = 0;
    long long v94 = 0u;
    long long v95 = 0u;
    long long v92 = 0u;
    long long v93 = 0u;
    long long v90 = 0u;
    long long v91 = 0u;
    long long v89 = 0u;
    uint64_t v88 = 116;
    if (IOSurfaceGetBulkAttachments())
    {
      uint64_t v16 = 0;
LABEL_89:
      return v16;
    }
    CFDictionaryRef cf = IOSurfaceCopyAllValues(a2);
    if (CFDictionaryGetValue(cf, (const void *)_kHDRProcessingDolbyVisionRPUDataKey))
    {
      if (x_log_hook_p())
      {
LABEL_7:
        x_log_();
        goto LABEL_86;
      }
      uint64_t v18 = x_log_category_utilities;
      if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR)) {
        goto LABEL_86;
      }
      *(_WORD *)buf = 0;
      float32x2_t v19 = "HDR surface with RPUData unsupported for display tone map";
      float32x2_t v20 = v18;
      uint32_t v21 = 2;
LABEL_17:
      _os_log_impl(&dword_184668000, v20, OS_LOG_TYPE_ERROR, v19, buf, v21);
      goto LABEL_86;
    }
    if (BYTE12(v92) != 18)
    {
      if (BYTE12(v92) == 16 && BYTE11(v92) <= 0xCu && ((1 << SBYTE11(v92)) & 0x1202) != 0)
      {
        uint64_t v17 = &_kHDRProcessingSourceContentTypeHDR10;
        goto LABEL_20;
      }
      if (!CA_CFDictionaryGetBool(cf, @"isHLG"))
      {
        if (x_log_hook_p()) {
          goto LABEL_7;
        }
        uint64_t v41 = x_log_category_utilities;
        if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR)) {
          goto LABEL_86;
        }
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = BYTE12(v92);
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = BYTE11(v92);
        float32x2_t v19 = "HDR surface with transfer index %d color index %d unsupported for display tone map";
        float32x2_t v20 = v41;
        uint32_t v21 = 14;
        goto LABEL_17;
      }
    }
    uint64_t v17 = &_kHDRProcessingSourceContentTypeHLG;
LABEL_20:
    uint64_t v22 = *v17;
    if (!*v17) {
      goto LABEL_86;
    }
    float32x2_t v23 = (CA::Render *)CA::HDRProcessorInternal::output_pixel_format((uint64_t)a1, a4, 3u, a2, 1);
    int v77 = CA::Render::fourcc_compressed_of_type(v23, 0, 0);
    int v87 = 0;
    uint64_t v86 = 0;
    long long v84 = 0u;
    long long v85 = 0u;
    char v83 = 0;
    CA::HDRProcessorInternal::get_config((uint64_t)buf, 0, a2, a4, &v87, 0, &v83, v23);
    long long v84 = *(_OWORD *)buf;
    long long v85 = *(_OWORD *)&buf[16];
    uint64_t v86 = *(void *)&buf[32];
    if (*MEMORY[0x1E4F24AB0] == *(void *)&buf[24])
    {
      unsigned int v24 = 26;
    }
    else if (*MEMORY[0x1E4F24AC0] == *(void *)&buf[24])
    {
      unsigned int v24 = 15;
    }
    else
    {
      if (*MEMORY[0x1E4F24AA8] != *(void *)&buf[24]) {
        goto LABEL_32;
      }
      unsigned int v24 = 10;
    }
    uint64_t v25 = CAGetColorSpace(v24);
    if (a5 && v25) {
      *a5 = v25;
    }
LABEL_32:
    float v26 = *(float *)(a4 + 12);
    HIDWORD(v86) = 2;
    HIDWORD(v84) = v26;
    float v27 = a1 + 5;
    os_unfair_lock_lock(a1 + 5);
    if (!CA::HDRProcessorInternal::get_or_create_hdr_processor_instance((uint64_t)a1, (__CFRunLoop *)2, (uint64_t)&v84))
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unsigned int v42 = x_log_category_utilities;
        if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184668000, v42, OS_LOG_TYPE_ERROR, "Failed to create HDRProcessor for display", buf, 2u);
        }
      }
      goto LABEL_82;
    }
    os_unfair_lock_unlock(a1 + 5);
    id v80 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    id v28 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    [v28 setObject:v22 forKeyedSubscript:_kHDRProcessingSourceContentTypeKey];
    [v80 setObject:v28 forKeyedSubscript:_kHDRProcessingSourceContentKey];

    if (_hdrp_version >= 1) {
      [v80 setObject:&unk_1ED057750 forKeyedSubscript:_kHDRProcessingApiInterfaceVersionKey];
    }
    unsigned int v30 = *(_DWORD *)(a4 + 60);
    uint64_t v79 = 3;
    float v31 = 100.0;
    if (v30 > 6)
    {
      float v27 = a1 + 5;
      float32x2_t v32 = v80;
    }
    else
    {
      float v27 = a1 + 5;
      float32x2_t v32 = v80;
      if (((1 << v30) & 0x61) != 0)
      {
        if (*(float *)(a4 + 12) == 0.0) {
          float v31 = 100.0;
        }
        else {
          float v31 = *(float *)(a4 + 12);
        }
        LODWORD(v29) = *(_DWORD *)(a4 + 20);
        uint64_t v33 = [NSNumber numberWithFloat:v29];
        [v80 setObject:v33 forKeyedSubscript:_kHDRProcessingMaximumExtendedDynamicRangeColorComponentValueKey];
        if (v77 == 1380411457 || v77 == 1919365992 || v83 == 16)
        {
          [v80 setObject:&unk_1ED05B9C8 forKeyedSubscript:_kHDRProcessingEDRFactorKey];
        }
        else
        {
          *(float *)&double v34 = 1.0 / *(float *)(a4 + 20);
          uint64_t v43 = [NSNumber numberWithFloat:v34];
          [v80 setObject:v43 forKeyedSubscript:_kHDRProcessingEDRFactorKey];
        }
        LODWORD(v35) = *(_DWORD *)(a4 + 16);
        uint64_t v36 = [NSNumber numberWithFloat:v35];
        [v80 setObject:v36 forKeyedSubscript:_kHDRProcessingAmbientLightInNitsKey];
        if (*(unsigned char *)(a4 + 48)) {
          [v80 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:_kHDRProcessingDisplaySupportsAmbientAdaptationKey];
        }
        if (*(unsigned __int8 *)(a4 + 54) | BYTE12(xmmword_1EB2ACC10))
        {
          uint64_t v37 = [NSNumber numberWithUnsignedInt:1];
          [v80 setObject:v37 forKeyedSubscript:_kHDRProcessingOperationEnum];
          uint64_t v38 = 1;
        }
        else
        {
          uint64_t v38 = 3;
        }
        uint64_t v79 = v38;
        unsigned int v30 = *(_DWORD *)(a4 + 60);
        if (v30 <= 6 && ((1 << v30) & 0x61) != 0)
        {
          int v39 = *(_DWORD *)(a4 + 64);
          int v40 = &_kHDRProcessingDisplayPipelineCompensationTypeNone;
          if (v39 == 1 || byte_1EB2ACC0E) {
            goto LABEL_65;
          }
          if (v39 == 3)
          {
            int v40 = &_kHDRProcessingDisplayPipelineCompensationTypeHeadroomDependent;
            goto LABEL_65;
          }
          if (v39 == 2)
          {
            int v40 = &_kHDRProcessingDisplayPipelineCompensationTypePurePower;
LABEL_65:
            [v80 setObject:*v40 forKeyedSubscript:_kHDRProcessingDisplayPipelineCompensationType];
            unsigned int v30 = *(_DWORD *)(a4 + 60);
          }
        }
      }
    }
    if (v30 == 2 && !(*(unsigned __int8 *)(a4 + 53) | BYTE4(xmmword_1EB2ACC10))) {
      float v31 = 1000.0;
    }
    *(float *)&double v29 = v31;
    uint64_t v44 = [NSNumber numberWithFloat:v29];
    [v32 setObject:v44 forKeyedSubscript:_kHDRProcessingCurrentMaxPanelNitsKey];
    int v45 = forward_display_params_from_attributes(a4, 1);
    if (v45) {
      [v32 setObject:v45 forKeyedSubscript:_kHDRProcessingDisplayKey];
    }
    if (!BYTE12(xmmword_1EB2ACC30)) {
      goto LABEL_72;
    }
    uint64_t v78 = objc_msgSend((id)objc_msgSend(v32, "debugDescription", v45), "UTF8String");
    if (x_log_hook_p())
    {
      IOSurfaceGetID(a2);
      IOSurfaceGetWidth(a2);
      IOSurfaceGetHeight(a2);
      OSType PixelFormat = IOSurfaceGetPixelFormat(a2);
      unsigned int v52 = HIBYTE(PixelFormat);
      if ((PixelFormat & 0x80000000) != 0) {
        int v53 = __maskrune(v52, 0x40000uLL);
      }
      else {
        int v53 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v52 + 60) & 0x40000;
      }
      if (v53) {
        IOSurfaceGetPixelFormat(a2);
      }
      unsigned int v58 = (IOSurfaceGetPixelFormat(a2) >> 16);
      if (v58 <= 0x7F) {
        int v59 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v58 + 60) & 0x40000;
      }
      else {
        int v59 = __maskrune(v58, 0x40000uLL);
      }
      if (v59) {
        IOSurfaceGetPixelFormat(a2);
      }
      unsigned int v60 = ((unsigned __int16)IOSurfaceGetPixelFormat(a2) >> 8);
      if (v60 <= 0x7F) {
        int v61 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v60 + 60) & 0x40000;
      }
      else {
        int v61 = __maskrune(v60, 0x40000uLL);
      }
      if (v61) {
        IOSurfaceGetPixelFormat(a2);
      }
      unsigned int v62 = IOSurfaceGetPixelFormat(a2);
      if (v62 <= 0x7F) {
        int v63 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v62 + 60) & 0x40000;
      }
      else {
        int v63 = __maskrune(v62, 0x40000uLL);
      }
      if (v63) {
        IOSurfaceGetPixelFormat(a2);
      }
      x_log_();
    }
    else
    {
      __int16 v54 = x_log_category_utilities;
      float v27 = a1 + 5;
      float32x2_t v32 = v80;
      if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT))
      {
LABEL_72:
        os_unfair_lock_lock(v27);
        hdr_processor_instance = CA::HDRProcessorInternal::get_or_create_hdr_processor_instance((uint64_t)a1, (__CFRunLoop *)2, (uint64_t)&v84);
        if (hdr_processor_instance)
        {
          v82[0] = MEMORY[0x1E4F143A8];
          v82[1] = 3221225472;
          v82[2] = ___ZN2CA20HDRProcessorInternal30configure_display_pipe_tonemapEP11__IOSurfacejPKNS_6Render17DisplayAttributesEPP12CGColorSpaceU13block_pointerFvP18IOMFBToneMapConfigEU13block_pointerFv13IOMFBCurveLocPK14IOMFBCurveDataEU13block_pointerFv14IOMFBICCMatLocPK16IOMFBColorMatrixE_block_invoke;
          v82[3] = &unk_1E5274148;
          v82[4] = a6;
          v82[5] = a7;
          v82[6] = a8;
          uint64_t v47 = [hdr_processor_instance iterateDisplayConfigWithType:0 operation:v79 inputSurface:a2 options:v32 config:v82];
          os_unfair_lock_unlock(v27);
          if (v47 == -17000)
          {

            uint64_t v16 = 1;
            goto LABEL_87;
          }
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            uint64_t v49 = x_log_category_utilities;
            if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134218496;
              *(void *)&uint8_t buf[4] = v47;
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = a2;
              *(_WORD *)&buf[22] = 2048;
              *(void *)&uint8_t buf[24] = v32;
              _os_log_impl(&dword_184668000, v49, OS_LOG_TYPE_ERROR, "HDRProcessor error (%ld) (src:%p, md:%p)", buf, 0x20u);
            }
          }

LABEL_86:
          uint64_t v16 = 0;
LABEL_87:
          if (cf) {
            CFRelease(cf);
          }
          goto LABEL_89;
        }
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          uint64_t v48 = x_log_category_utilities;
          if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_184668000, v48, OS_LOG_TYPE_ERROR, "Failed to create HDRProcessor for display", buf, 2u);
          }
        }

LABEL_82:
        os_unfair_lock_unlock(v27);
        goto LABEL_86;
      }
      IOSurfaceID ID = IOSurfaceGetID(a2);
      size_t Width = IOSurfaceGetWidth(a2);
      size_t Height = IOSurfaceGetHeight(a2);
      OSType v55 = IOSurfaceGetPixelFormat(a2);
      unsigned int v56 = HIBYTE(v55);
      if ((v55 & 0x80000000) != 0) {
        int v57 = __maskrune(v56, 0x40000uLL);
      }
      else {
        int v57 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v56 + 60) & 0x40000;
      }
      if (v57) {
        signed int v64 = IOSurfaceGetPixelFormat(a2) & 0xFF000000;
      }
      else {
        signed int v64 = 0x20000000;
      }
      unsigned int v65 = (IOSurfaceGetPixelFormat(a2) >> 16);
      if (v65 <= 0x7F) {
        int v66 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v65 + 60) & 0x40000;
      }
      else {
        int v66 = __maskrune(v65, 0x40000uLL);
      }
      if (v66) {
        char v67 = IOSurfaceGetPixelFormat(a2) >> 16;
      }
      else {
        char v67 = 32;
      }
      unsigned int v68 = ((unsigned __int16)IOSurfaceGetPixelFormat(a2) >> 8);
      if (v68 <= 0x7F) {
        int v69 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v68 + 60) & 0x40000;
      }
      else {
        int v69 = __maskrune(v68, 0x40000uLL);
      }
      if (v69) {
        char v70 = (unsigned __int16)IOSurfaceGetPixelFormat(a2) >> 8;
      }
      else {
        char v70 = 32;
      }
      unsigned int v71 = IOSurfaceGetPixelFormat(a2);
      if (v71 <= 0x7F) {
        int v72 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v71 + 60) & 0x40000;
      }
      else {
        int v72 = __maskrune(v71, 0x40000uLL);
      }
      if (v72) {
        int v73 = (char)IOSurfaceGetPixelFormat(a2);
      }
      else {
        int v73 = 32;
      }
      *(_DWORD *)buf = 134220290;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = ID;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = Width;
      *(_WORD *)&buf[28] = 2048;
      *(void *)&buf[30] = Height;
      *(_WORD *)&buf[38] = 1024;
      int v98 = v64 >> 24;
      __int16 v99 = 1024;
      int v100 = v67;
      __int16 v101 = 1024;
      int v102 = v70;
      __int16 v103 = 1024;
      int v104 = v73;
      __int16 v105 = 1024;
      int v106 = v79;
      __int16 v107 = 2080;
      uint64_t v108 = v78;
      _os_log_impl(&dword_184668000, v54, OS_LOG_TYPE_DEFAULT, "HDRProcessor %p accelerator Display src surface 0x%x [%zu x %zu] (%c%c%c%c) operation 0x%x metadata: %s\n", buf, 0x4Eu);
    }
    float v27 = a1 + 5;
    float32x2_t v32 = v80;
    goto LABEL_72;
  }
  return 0;
}

void sub_18489E3B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(a1);
}

uint64_t CA::HDRProcessorInternal::output_pixel_format(uint64_t a1, uint64_t a2, unsigned int a3, IOSurfaceRef buffer, int a5)
{
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (!dword_1EB2ACB7C)
  {
    if (CADeviceSupportsToneMapAcceleratorSwitching::once[0] != -1) {
      dispatch_once(CADeviceSupportsToneMapAcceleratorSwitching::once, &__block_literal_global_248);
    }
    uint64_t v10 = 1380411457;
    if (CADeviceSupportsToneMapAcceleratorSwitching::accelerator_switching)
    {
      if (CADeviceHasHardwareAcceleratedHDR::once[0] != -1) {
        dispatch_once(CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_132);
      }
      if (a3 == 2 && CADeviceHasHardwareAcceleratedHDR::has_capability)
      {
        CFTypeRef v11 = IOSurfaceCopyValue(buffer, (CFStringRef)_kHDRProcessingDolbyVisionRPUDataKey);
        if (!v11) {
          return v10;
        }
        CFRelease(v11);
      }
    }
    OSType PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(buffer);
    if (CADeviceHasHardwareAcceleratedHDR::once[0] != -1) {
      dispatch_once(CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_132);
    }
    int v13 = CADeviceHasHardwareAcceleratedHDR::has_capability;
    if (CADeviceHasHardwareAcceleratedHDR::has_capability)
    {
      int v13 = a3 < 2;
      if (a3 == 3) {
        int v13 = 1;
      }
      *(unsigned char *)(a1 + 89) = v13;
      uint64_t v14 = (unsigned char *)(a1 + 89);
      if (a3 <= 3 && a3 != 2)
      {
        if (PixelFormat == 642934849 || PixelFormat == 1380411457) {
          return v10;
        }
        if (PixelFormat == 2033463606) {
          return 2033463606;
        }
      }
    }
    else
    {
      *(unsigned char *)(a1 + 89) = 0;
      uint64_t v14 = (unsigned char *)(a1 + 89);
    }
    unsigned int v15 = *(_DWORD *)(a2 + 60);
    if (v15 - 2 >= 5)
    {
      if (v15 > 1) {
        return 0;
      }
      if (!v13) {
        return 1999843442;
      }
      uint64_t v10 = 1882468912;
      if ((CA::Render::fourcc_is_420(PixelFormat) & 1) == 0)
      {
        if (CA::Render::fourcc_is_422(PixelFormat))
        {
          return 1882468914;
        }
        else
        {
          uint64_t v10 = 1882469428;
          if ((CA::Render::fourcc_is_444(PixelFormat) & 1) == 0)
          {
            if (CA::Render::fourcc_is_rgb(PixelFormat)) {
              return 1882469428;
            }
            else {
              return 1882468912;
            }
          }
        }
      }
      return v10;
    }
    if (CADeviceIsVirtualized::once != -1) {
      dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
    }
    if (!CADeviceIsVirtualized::is_virtualized)
    {
      if (!*v14) {
        return 1919365992;
      }
      if (CADevicePrefersHDR444::once != -1) {
        dispatch_once(&CADevicePrefersHDR444::once, &__block_literal_global_379);
      }
      if (CADevicePrefersHDR444::b)
      {
LABEL_33:
        if (a5) {
          return 1886680628;
        }
        else {
          return 1953903668;
        }
      }
      if (CA::Render::fourcc_is_420(PixelFormat))
      {
        unsigned int v16 = 1886680624;
        BOOL v17 = a5 == 0;
        unsigned int v18 = 1953903152;
      }
      else
      {
        if (!CA::Render::fourcc_is_422(PixelFormat))
        {
          uint64_t v10 = 1953903152;
          if ((CA::Render::fourcc_is_444(PixelFormat) & 1) == 0
            && !CA::Render::fourcc_is_rgb(PixelFormat))
          {
            return v10;
          }
          goto LABEL_33;
        }
        unsigned int v16 = 1886680626;
        unsigned int v18 = 1953903154;
        BOOL v17 = a5 == 0;
      }
      if (v17) {
        return v18;
      }
      else {
        return v16;
      }
    }
    return v10;
  }
  float32x2_t v20 = (CA::Render *)dword_1EB2ACB7C;

  return CA::Render::fourcc_compressed_of_type(v20, 0, 0);
}

void CA::HDRProcessorInternal::get_config(uint64_t a1, __IOSurface *a2, __IOSurface *a3, uint64_t a4, _DWORD *a5, int a6, unsigned char *a7, CA::Render *PixelFormat)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (a2) {
    unsigned int v15 = a2;
  }
  else {
    unsigned int v15 = a3;
  }
  *(_DWORD *)a1 = IOSurfaceGetWidth(v15);
  *(_DWORD *)(a1 + 4) = IOSurfaceGetHeight(v15);
  if (a2) {
    OSType PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(a2);
  }
  *(_DWORD *)(a1 + 16) = PixelFormat;
  uint64_t v30 = *MEMORY[0x1E4F24AB0];
  *(void *)(a1 + 24) = *MEMORY[0x1E4F24AB0];
  *a5 = 3;
  int v16 = CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0);
  BOOL v17 = (CA::Render *)IOSurfaceGetPixelFormat(a3);
  int v18 = CA::Render::fourcc_compressed_of_type(v17, 0, 0);
  int v19 = *(_DWORD *)(a4 + 60);
  if (v19 == 4)
  {
    unsigned int v20 = *(float *)(a4 + 4);
  }
  else
  {
    unsigned int v20 = 100;
    if (v19 == 1 && *(unsigned char *)(a4 + 50))
    {
      if (initialized != -1)
      {
        int v29 = v18;
        dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
        int v18 = v29;
      }
      unsigned int v20 = *(float *)&dword_1EB2ACB04;
      if (!*(float *)&dword_1EB2ACB04) {
        unsigned int v20 = 200;
      }
    }
  }
  *(_DWORD *)(a1 + 12) = v20;
  LOBYTE(v21) = 13;
  if (v16 <= 1919365991)
  {
    if (v16 <= 1882468913)
    {
      if (v16 != 1380411457)
      {
        if (v16 != 1815162994)
        {
          unsigned __int16 v22 = 12848;
          goto LABEL_29;
        }
        goto LABEL_30;
      }
      *(void *)(a1 + 24) = *MEMORY[0x1E4F24AC0];
      LOBYTE(v21) = 8;
      goto LABEL_47;
    }
    if ((v16 - 1886680624) > 4 || ((1 << (v16 - 48)) & 0x15) == 0)
    {
      if (v16 != 1882468914)
      {
        unsigned __int16 v22 = 13364;
LABEL_29:
        if (v16 != (v22 | 0x70340000)) {
          goto LABEL_47;
        }
      }
LABEL_30:
      *(void *)(a1 + 24) = *MEMORY[0x1E4F24AC0];
      goto LABEL_47;
    }
    goto LABEL_39;
  }
  if (v16 > 1953903667)
  {
    if (v16 > 2016686639)
    {
      if (v16 != 2016686640)
      {
        if (v16 != 2033463606) {
          goto LABEL_47;
        }
        unsigned int v23 = *(_DWORD *)(a4 + 60);
        if (v23 <= 1) {
          goto LABEL_30;
        }
        goto LABEL_40;
      }
    }
    else if (v16 != 1953903668)
    {
      if (v16 == 1999843442 && v18 == 1380411457) {
        *a5 = 2;
      }
      goto LABEL_47;
    }
LABEL_39:
    unsigned int v23 = *(_DWORD *)(a4 + 60);
LABEL_40:
    *(void *)(a1 + 24) = *MEMORY[0x1E4F24AA8];
    if ((v23 > 6 || ((1 << v23) & 0x73) == 0) && !*(unsigned char *)(a4 + 50)) {
      *a5 = 1;
    }
    LOBYTE(v21) = 16;
    if (*(unsigned char *)(a4 + 53) && v18 == 1380411457) {
      *a5 = 4;
    }
    goto LABEL_47;
  }
  if (v16 == 1919365992)
  {
    LOBYTE(v21) = 8;
    goto LABEL_47;
  }
  if (v16 == 1953903152 || v16 == 1953903154) {
    goto LABEL_39;
  }
LABEL_47:
  int BulkAttachments = IOSurfaceGetBulkAttachments();
  if (a6)
  {
    *(void *)buf = 116;
    if (!IOSurfaceGetBulkAttachments()) {
      LOBYTE(v21) = 0;
    }
  }
  else if (*(unsigned char *)(a4 + 54))
  {
    if (!BulkAttachments)
    {
      CFTypeRef v25 = IOSurfaceCopyValue(a3, (CFStringRef)_kHDRProcessingDolbyVisionRPUDataKey);
      if (v25) {
        CFRelease(v25);
      }
    }
  }
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (*(float *)&dword_1EB2ACB74)
  {
    switch(*(float *)&dword_1EB2ACB74)
    {
      case 1u:
        goto LABEL_79;
      case 2u:
      case 3u:
      case 4u:
      case 7u:
      case 8u:
      case 0xAu:
        break;
      case 5u:
        id v28 = (uint64_t *)MEMORY[0x1E4F24AA0];
        goto LABEL_78;
      case 6u:
        id v28 = (uint64_t *)MEMORY[0x1E4F24AC8];
        goto LABEL_78;
      case 9u:
        id v28 = (uint64_t *)MEMORY[0x1E4F24AA8];
        goto LABEL_78;
      case 0xBu:
        id v28 = (uint64_t *)MEMORY[0x1E4F24A98];
        goto LABEL_78;
      case 0xCu:
        id v28 = (uint64_t *)MEMORY[0x1E4F24AC0];
        goto LABEL_78;
      default:
        if (*(float *)&dword_1EB2ACB74 != 22) {
          break;
        }
        id v28 = (uint64_t *)MEMORY[0x1E4F24AB8];
LABEL_78:
        uint64_t v30 = *v28;
LABEL_79:
        *(void *)(a1 + 24) = v30;
        break;
    }
  }
  if (*(float *)&dword_1EB2ACB78)
  {
    unsigned int v21 = *(float *)&dword_1EB2ACB78;
    if (!a2) {
      goto LABEL_67;
    }
  }
  else if (!a2)
  {
    goto LABEL_67;
  }
  int v26 = IOSurfaceSetBulkAttachments2();
  if (v26)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      float v27 = x_log_category_utilities;
      if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v26;
        _os_log_impl(&dword_184668000, v27, OS_LOG_TYPE_ERROR, "Error setting bulk attachments: 0x%x", buf, 8u);
      }
    }
  }
LABEL_67:
  *a7 = v21;
}

void *CA::HDRProcessorInternal::get_or_create_hdr_processor_instance(uint64_t a1, __CFRunLoop *a2, uint64_t a3)
{
  atomic_uint v3 = (void **)(a1 + 96);
  BOOL v4 = (void **)(a1 + 48);
  if (a2 == 2) {
    BOOL v4 = (void **)(a1 + 112);
  }
  if (a2 != 1) {
    atomic_uint v3 = v4;
  }
  if (_hdrp_supports_new_init) {
    uint64_t v5 = (void **)(a1 + 40);
  }
  else {
    uint64_t v5 = v3;
  }
  if (!a3) {
    __assert_rtn("get_or_create_hdr_processor_instance", "CAHDRProcessing.mm", 1019, "config");
  }
  int v7 = (int)a2;
  uint64_t result = *v5;
  if (!*v5)
  {
LABEL_15:

    if (!v7 || _hdrp_supports_new_init)
    {
      CA::HDRProcessorInternal::initialize_metal((CA::HDRProcessorInternal *)a1);
      if (!*(void *)(a1 + 24))
      {
        uint64_t result = 0;
        float *v5 = 0;
        return result;
      }
      if (_hdrp_supports_new_init) {
        uint64_t v14 = *(void *)(a1 + 24);
      }
      else {
        uint64_t v14 = 0;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t result = (void *)CA::create_hdrprocessor(v14, a3);
    float *v5 = result;
    int v12 = *(_DWORD *)(a3 + 36);
    goto LABEL_23;
  }
  int v10 = *(_DWORD *)(a1 + 120);
  unsigned int v11 = 2;
  if (v10 != 2) {
    unsigned int v11 = v10 == 1;
  }
  int v12 = *(_DWORD *)(a3 + 36);
  if (v10 == v12)
  {
    uint64_t v13 = a1 + 40 * v11;
    if (*(_DWORD *)(v13 + 144) == *(_DWORD *)(a3 + 16) && *(void *)(v13 + 152) == *(void *)(a3 + 24)) {
      return result;
    }
    goto LABEL_15;
  }
LABEL_23:
  BOOL v15 = v12 == 1;
  BOOL v16 = v12 == 2;
  unsigned int v17 = 2;
  if (!v16) {
    unsigned int v17 = v15;
  }
  uint64_t v18 = a1 + 40 * v17;
  long long v19 = *(_OWORD *)a3;
  long long v20 = *(_OWORD *)(a3 + 16);
  *(void *)(v18 + 160) = *(void *)(a3 + 32);
  *(_OWORD *)(v18 + 128) = v19;
  *(_OWORD *)(v18 + 144) = v20;
  LODWORD(v18) = *(_DWORD *)(a3 + 36);
  *(_DWORD *)(a1 + 120) = v18;
  if (v18 == 1 && *(unsigned char *)(a1 + 89) && !*(void *)(a1 + 104))
  {
    if (CA::WindowServer::accelerator_runloop(void)::once != -1) {
      dispatch_once(&CA::WindowServer::accelerator_runloop(void)::once, &__block_literal_global_6465);
    }
    CA::IOSAManager::create_new_iosa_manager((CA::IOSAManager *)CA::WindowServer::accelerator_runloop(void)::runloop, a2);
  }
  return result;
}

void *forward_display_params_from_attributes(uint64_t a1, int a2)
{
  uint64_t v4 = [MEMORY[0x1E4F1CA60] dictionary];
  int v5 = *(_DWORD *)(a1 + 60);
  BOOL v6 = (void *)v4;
  int v7 = &_kHDRProcessingDestinationDisplayTypeSDRTV;
  switch(v5)
  {
    case 0:
      if (_hdrp_version <= 0)
      {
        if (!_kHDRProcessingDestinationDisplayTypeInternalPanelLCD) {
          goto LABEL_20;
        }
        if (CADeviceHasLCDPanel::once != -1) {
          dispatch_once(&CADeviceHasLCDPanel::once, &__block_literal_global_98);
        }
        if (CADeviceHasLCDPanel::has_lcd | BYTE11(xmmword_1EB2ACC10)) {
          int v7 = &_kHDRProcessingDestinationDisplayTypeInternalPanelLCD;
        }
        else {
LABEL_20:
        }
          int v7 = &_kHDRProcessingDestinationDisplayTypeInternalPanel;
      }
      else
      {
        if (!_kHDRProcessingDestinationDisplayTypeInternalPanelLCD) {
          goto LABEL_14;
        }
        if (CADeviceHasLCDPanel::once != -1) {
          dispatch_once(&CADeviceHasLCDPanel::once, &__block_literal_global_98);
        }
        if (CADeviceHasLCDPanel::has_lcd | BYTE11(xmmword_1EB2ACC10)) {
          int v7 = &_kHDRProcessingDestinationDisplayTypeInternalPanel0DBL;
        }
        else {
LABEL_14:
        }
          int v7 = &_kHDRProcessingDestinationDisplayTypeInternalPanelOLED;
      }
      goto LABEL_21;
    case 1:
      goto LABEL_21;
    case 2:
      int v7 = &_kHDRProcessingDestinationDisplayTypeHDR10TV;
      goto LABEL_21;
    case 3:
      int v7 = &_kHDRProcessingDestinationDisplayTypeDolbyVisionTV;
      goto LABEL_21;
    case 4:
      int v7 = &_kHDRProcessingDestinationDisplayTypeLowLatencyDolbyVisionTV;
      goto LABEL_21;
    case 5:
    case 6:
      if (_hdrp_version >= 1) {
        int v7 = &_kHDRProcessingDestinationDisplayTypeInternalPanel2DBL;
      }
      else {
        int v7 = &_kHDRProcessingDestinationDisplayTypeReferenceDisplay;
      }
LABEL_21:
      [v6 setObject:*v7 forKeyedSubscript:_kHDRProcessingDestinationDisplayTypeKey];
      if (_kHDRProcessingEdrRangeTypeKey) {
        BOOL v9 = a2 == 0;
      }
      else {
        BOOL v9 = 1;
      }
      if (v9) {
        goto LABEL_27;
      }
      if (v5 || !*(unsigned char *)(a1 + 57))
      {
        objc_msgSend(v6, "setObject:forKeyedSubscript:", _kHDRProcessingEdrRangeTypeNonNormalized);
LABEL_27:
        switch(v5)
        {
          case 0:
          case 6:
            goto LABEL_38;
          case 1:
          case 5:
            if (_hdrp_version >= 1) {
              goto LABEL_41;
            }
            goto LABEL_35;
          case 2:
            goto LABEL_34;
          case 3:
          case 4:
            if (*(int *)(a1 + 124) >= 1 && _kHDRProcessingDisplayDolbyVisionDMVersionKey)
            {
              uint64_t v10 = objc_msgSend(NSNumber, "numberWithInt:");
              [v6 setObject:v10 forKeyedSubscript:_kHDRProcessingDisplayDolbyVisionDMVersionKey];
            }
LABEL_34:
            LODWORD(v8) = *(_DWORD *)a1;
            uint64_t v11 = [NSNumber numberWithFloat:v8];
            [v6 setObject:v11 forKeyedSubscript:_kHDRProcessingDisplayMinimumBrightnessInNitsKey];
            LODWORD(v12) = *(_DWORD *)(a1 + 4);
            uint64_t v13 = [NSNumber numberWithFloat:v12];
            [v6 setObject:v13 forKeyedSubscript:_kHDRProcessingDisplayMaximumBrightnessInNitsKey];
            [v6 setObject:&unk_1ED0577C8 forKeyedSubscript:_kHDRProcessingDisplayAverageBrightnessInNitsKey];
            if (_hdrp_version > 0) {
              goto LABEL_41;
            }
LABEL_35:
            uint64_t v14 = &unk_1ED057798;
            break;
          default:
            return 0;
        }
        goto LABEL_40;
      }
      objc_msgSend(v6, "setObject:forKeyedSubscript:", _kHDRProcessingEdrRangeTypeNormalized);
LABEL_38:
      if (_hdrp_version < 1)
      {
        uint64_t v14 = &unk_1ED0577B0;
LABEL_40:
        [v6 setObject:v14 forKeyedSubscript:_kHDRProcessingDisplayDiagonalSizeInInchesKey];
      }
LABEL_41:
      if (*(unsigned char *)(a1 + 100) && _kHDRProcessingDisplayChromaticityBx)
      {
        LODWORD(v8) = *(_DWORD *)(a1 + 84);
        uint64_t v15 = [NSNumber numberWithFloat:v8];
        [v6 setObject:v15 forKeyedSubscript:_kHDRProcessingDisplayChromaticityBx];
        LODWORD(v16) = *(_DWORD *)(a1 + 88);
        uint64_t v17 = [NSNumber numberWithFloat:v16];
        [v6 setObject:v17 forKeyedSubscript:_kHDRProcessingDisplayChromaticityBy];
        LODWORD(v18) = *(_DWORD *)(a1 + 76);
        uint64_t v19 = [NSNumber numberWithFloat:v18];
        [v6 setObject:v19 forKeyedSubscript:_kHDRProcessingDisplayChromaticityGx];
        LODWORD(v20) = *(_DWORD *)(a1 + 80);
        uint64_t v21 = [NSNumber numberWithFloat:v20];
        [v6 setObject:v21 forKeyedSubscript:_kHDRProcessingDisplayChromaticityGy];
        LODWORD(v22) = *(_DWORD *)(a1 + 68);
        uint64_t v23 = [NSNumber numberWithFloat:v22];
        [v6 setObject:v23 forKeyedSubscript:_kHDRProcessingDisplayChromaticityRx];
        LODWORD(v24) = *(_DWORD *)(a1 + 72);
        uint64_t v25 = [NSNumber numberWithFloat:v24];
        [v6 setObject:v25 forKeyedSubscript:_kHDRProcessingDisplayChromaticityRy];
        LODWORD(v26) = *(_DWORD *)(a1 + 92);
        uint64_t v27 = [NSNumber numberWithFloat:v26];
        [v6 setObject:v27 forKeyedSubscript:_kHDRProcessingDisplayChromaticityWx];
        LODWORD(v28) = *(_DWORD *)(a1 + 96);
        uint64_t v29 = [NSNumber numberWithFloat:v28];
        [v6 setObject:v29 forKeyedSubscript:_kHDRProcessingDisplayChromaticityWy];
      }
      if (_kHDRProcessingDisplayAveragePixelThresholdKey)
      {
        if (_kHDRProcessingDisplayAveragePixelWeightR)
        {
          if (_kHDRProcessingDisplayAveragePixelWeightG)
          {
            if (_kHDRProcessingDisplayAveragePixelWeightB)
            {
              if (*(float *)(a1 + 104) != 1.0)
              {
                uint64_t v30 = objc_msgSend(NSNumber, "numberWithFloat:");
                [v6 setObject:v30 forKeyedSubscript:_kHDRProcessingDisplayAveragePixelThresholdKey];
                LODWORD(v31) = *(_DWORD *)(a1 + 108);
                uint64_t v32 = [NSNumber numberWithFloat:v31];
                [v6 setObject:v32 forKeyedSubscript:_kHDRProcessingDisplayAveragePixelWeightR];
                LODWORD(v33) = *(_DWORD *)(a1 + 112);
                uint64_t v34 = [NSNumber numberWithFloat:v33];
                [v6 setObject:v34 forKeyedSubscript:_kHDRProcessingDisplayAveragePixelWeightG];
                LODWORD(v35) = *(_DWORD *)(a1 + 116);
                uint64_t v36 = [NSNumber numberWithFloat:v35];
                [v6 setObject:v36 forKeyedSubscript:_kHDRProcessingDisplayAveragePixelWeightB];
                if (*(float *)(a1 + 120) > 0.0)
                {
                  if (_kHDRProcessingDisplaySustainedBrightnessInNitsKey)
                  {
                    uint64_t v37 = objc_msgSend(NSNumber, "numberWithFloat:");
                    [v6 setObject:v37 forKeyedSubscript:_kHDRProcessingDisplaySustainedBrightnessInNitsKey];
                  }
                }
              }
            }
          }
        }
      }
      return v6;
    default:
      return 0;
  }
}

void ___ZN2CA20HDRProcessorInternal30configure_display_pipe_tonemapEP11__IOSurfacejPKNS_6Render17DisplayAttributesEPP12CGColorSpaceU13block_pointerFvP18IOMFBToneMapConfigEU13block_pointerFv13IOMFBCurveLocPK14IOMFBCurveDataEU13block_pointerFv14IOMFBICCMatLocPK16IOMFBColorMatrixE_block_invoke(void *a1, int a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a2 == 2)
  {
    uint64_t v4 = a1[5];
  }
  else
  {
    if (a2 != 1)
    {
      if (a2)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          BOOL v6 = x_log_category_utilities;
          if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            int v8 = a2;
            _os_log_impl(&dword_184668000, v6, OS_LOG_TYPE_ERROR, "unexpected HDRProcessingDisplayConfigType: %u", buf, 8u);
          }
        }
      }
      else
      {
        atomic_uint v3 = *(void (**)(void))(a1[4] + 16);
        v3();
      }
      return;
    }
    uint64_t v4 = a1[6];
  }
  int v5 = *(void (**)(void))(v4 + 16);

  v5();
}

void CA::HDRProcessorInternal::initialize_metal(CA::HDRProcessorInternal *this)
{
  if (!*((unsigned char *)this + 88))
  {
    *((unsigned char *)this + 88) = 1;
    id v2 = MTLCreateSystemDefaultDevice();
    *((void *)this + 3) = v2;
    atomic_uint v3 = (void *)[v2 newCommandQueue];
    *((void *)this + 4) = v3;
    [v3 setLabel:@"com.apple.QuartzCore-HDRProcessing"];
    if (CA::_root_queue_once[0] != -1) {
      dispatch_once(CA::_root_queue_once, &__block_literal_global_23119);
    }
    uint64_t v4 = CA::_root_queue;
    if (CA::_root_queue)
    {
      int v5 = dispatch_queue_create_with_target_V2("com.apple.coreanimation.hdr_submission", 0, (dispatch_queue_t)CA::_root_queue);
      BOOL v6 = dispatch_queue_create_with_target_V2("com.apple.coreanimation.hdr_completion", 0, v4);
      [*((id *)this + 4) setSubmissionQueue:v5];
      [*((id *)this + 4) setCompletionQueue:v6];
      dispatch_release(v5);
      dispatch_release(v6);
    }
  }
}

uint64_t CA::create_hdrprocessor(uint64_t a1, uint64_t a2)
{
  if (_hdrp_supports_new_init)
  {
    uint64_t result = [objc_alloc((Class)hdr_processor_class) initProcessingEngine:a1 config:a2];
    if (!result)
    {
LABEL_8:
      x_log_crash("Error initializing HDRProcessor.");
      abort();
    }
  }
  else
  {
    int v5 = *(_DWORD *)(a2 + 36);
    id v6 = objc_alloc((Class)hdr_processor_class);
    if (v5)
    {
      uint64_t result = [v6 initWithConfig:a2];
      if (!result) {
        goto LABEL_8;
      }
    }
    else
    {
      uint64_t result = [v6 initWithDevice:a1 config:a2];
      if (!result) {
        goto LABEL_8;
      }
    }
  }
  return result;
}

uint64_t CA::HDRProcessorInternal::create_surface_with_forward_dm(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, int a5, int a6, int a7, unsigned int a8, float a9, char a10, char a11)
{
  v145[4] = *MEMORY[0x1E4F143B8];
  if (a10) {
    int v17 = 1;
  }
  else {
    int v17 = *(_DWORD *)(a3 + 480);
  }
  unsigned int v118 = v17;
  if (CADeviceHasHardwareAcceleratedHDR::once[0] != -1) {
    dispatch_once(CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_132);
  }
  char v18 = CADeviceHasHardwareAcceleratedHDR::has_capability;
  if (CADeviceHasHardwareAcceleratedHDR::has_capability)
  {
    BOOL v19 = v118 < 2 || v118 == 3;
    char v18 = v19;
  }
  uint64_t v110 = a3;
  *(unsigned char *)(a1 + 89) = v18;
  *(void *)&v131[1] = *(void *)(a2 + 112);
  {
    CA::HDRProcessorInternal::create_surface_with_forward_dm(CA::Render::Surface const*,CA::Render::Update *,CA::Render::DisplayAttributes const*,BOOL,float,CA::Render::TextureFlags,BOOL,BOOL,BOOL,BOOL)::sdr_attrs = xmmword_184998270;
    *(_OWORD *)algn_1E8F860F0 = xmmword_184998280;
    xmmword_1E8F86100 = xmmword_184997E30;
    qword_1E8F86110 = 0;
    word_1E8F86118 = 0;
    unk_1E8F8611C = 0x100000001;
    unk_1E8F86124 = 0u;
    unk_1E8F86134 = 0u;
    byte_1E8F86144 = 0;
    dword_1E8F86148 = 1065353216;
    unk_1E8F86154 = 0;
    unk_1E8F8614C = 0;
    dword_1E8F8615C = -1;
  }
  if (a7) {
    double v20 = &CA::HDRProcessorInternal::create_surface_with_forward_dm(CA::Render::Surface const*,CA::Render::Update *,CA::Render::DisplayAttributes const*,BOOL,float,CA::Render::TextureFlags,BOOL,BOOL,BOOL,BOOL)::sdr_attrs;
  }
  else {
    double v20 = a4;
  }
  uint64_t v117 = (uint64_t)v20;
  OSType PixelFormat = IOSurfaceGetPixelFormat(*(IOSurfaceRef *)&v131[1]);
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  unsigned int v112 = *(float *)&dword_1EB2ACAAC;
  int v22 = dword_1EB2ACB7C;
  int v109 = a7;
  if (CA::Render::fourcc_compressed_of_type((CA::Render *)dword_1EB2ACB7C, 0, 0) == v22)
  {
    if (CADeviceSupportsUniversalCompression::once != -1) {
      dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
    }
    if (CADeviceSupportsUniversalCompression::universal)
    {
      if (*(unsigned char *)(a1 + 89)) {
        BOOL v23 = v112 == 0;
      }
      else {
        BOOL v23 = 0;
      }
      int v24 = v23;
    }
    else
    {
      int v24 = 0;
    }
  }
  else
  {
    int v24 = 1;
  }
  v131[0] = CA::HDRProcessorInternal::output_pixel_format(a1, v117, v118, *(IOSurfaceRef *)&v131[1], v24);
  size_t Width = IOSurfaceGetWidth(*(IOSurfaceRef *)&v131[1]);
  size_t Height = IOSurfaceGetHeight(*(IOSurfaceRef *)&v131[1]);
  uint64_t ProtectionOptions = (CA::ScalerUtil::ScalerLimits *)IOSurfaceGetProtectionOptions();
  uint64_t v111 = (uint64_t)ProtectionOptions;
  if (*(unsigned char *)(a1 + 89))
  {
    CA::ScalerUtil::ScalerLimits::limits(ProtectionOptions);
    float v28 = *(float *)&xmmword_1E8F85270;
    if (*(float *)&xmmword_1E8F85270 <= *((float *)&xmmword_1E8F85270 + 1)) {
      float v28 = *((float *)&xmmword_1E8F85270 + 1);
    }
    double v29 = a9;
    if (a9 > 1.0) {
      double v29 = 1.0;
    }
    if (v29 >= v28) {
      a9 = v29;
    }
    else {
      a9 = v28;
    }
  }
  if (byte_1EB2ACC6D && a8 && a9 != 1.0)
  {
    if (x_log_hook_p())
    {
      double v106 = a9;
      uint64_t ID = IOSurfaceGetID(*(IOSurfaceRef *)&v131[1]);
      x_log_();
    }
    else
    {
      int v102 = x_log_category_filmgrain;
      if (os_log_type_enabled((os_log_t)x_log_category_filmgrain, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)float32x4_t v137 = 67109376;
        *(_DWORD *)&v137[4] = IOSurfaceGetID(*(IOSurfaceRef *)&v131[1]);
        *(_WORD *)&v137[8] = 2048;
        *(double *)&v137[10] = a9;
        _os_log_impl(&dword_184668000, v102, OS_LOG_TYPE_INFO, "[0x%x] combine scale + FG in next MSR pass (scale: %f)", v137, 0x12u);
      }
    }
  }
  double v30 = (float)(a9 * (float)Height) + 0.5;
  *(void *)float32x4_t v129 = ((unint64_t)v30 + 1) & 0xFFFFFFFFFFFFFFFELL;
  *(void *)float32x4_t v130 = ((unint64_t)((float)(a9 * (float)Width) + 0.5) + 1) & 0xFFFFFFFFFFFFFFFELL;
  if ((a6 & 4) != 0)
  {
    *(void *)float32x4_t v129 = ((unint64_t)((float)(a9 * (float)Width) + 0.5) + 1) & 0xFFFFFFFFFFFFFFFELL;
    *(void *)float32x4_t v130 = ((unint64_t)v30 + 1) & 0xFFFFFFFFFFFFFFFELL;
  }
  if (*(void *)(a1 + 80) && (a10 & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 20));
    if (!*(void *)(a1 + 104) || !*(void *)(a1 + 40))
    {
      float32x4_t v138 = 0;
      memset(v137, 0, sizeof(v137));
      double v31 = (CA::Render *)IOSurfaceGetPixelFormat(*(IOSurfaceRef *)(a1 + 80));
      CA::HDRProcessorInternal::get_config((uint64_t)&v126, 0, *(__IOSurface **)&v131[1], v117, &v134, 0, v145, v31);
      float32x4_t v138 = (unsigned int *)(v128 | 0x100000000);
      *(_OWORD *)float32x4_t v137 = v126;
      *(_OWORD *)&v137[16] = *(_OWORD *)v127;
      *(_DWORD *)float32x4_t v137 = IOSurfaceGetWidth(*(IOSurfaceRef *)(a1 + 80));
      *(_DWORD *)&v137[4] = IOSurfaceGetHeight(*(IOSurfaceRef *)(a1 + 80));
      CA::HDRProcessorInternal::get_or_create_hdr_processor_instance(a1, (__CFRunLoop *)1, (uint64_t)v137);
    }
    OSType v32 = PixelFormat;
    if (CADeviceSupportsToneMapAcceleratorSwitching::once[0] != -1) {
      dispatch_once(CADeviceSupportsToneMapAcceleratorSwitching::once, &__block_literal_global_248);
    }
    if (!CADeviceSupportsToneMapAcceleratorSwitching::accelerator_switching) {
      goto LABEL_69;
    }
    if (CADeviceHasHardwareAcceleratedHDR::once[0] != -1) {
      dispatch_once(CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_132);
    }
    if (v118 == 2 && CADeviceHasHardwareAcceleratedHDR::has_capability) {
      goto LABEL_55;
    }
    int v39 = *(__IOSurface **)(a1 + 80);
    if (!v39) {
      goto LABEL_69;
    }
    int v107 = v131[0];
    uint64_t v40 = *(void *)v130;
    uint64_t v108 = *(void *)v129;
    uint64_t v41 = (CA::Render *)IOSurfaceGetPixelFormat(v39);
    if (initialized != -1) {
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    }
    if (((unsigned int v42 = *(float *)&dword_1EB2ACAAC,
           int v43 = CA::Render::fourcc_compressed_of_type(v41, 0, 0),
           int v44 = v43,
           !v42)
       || v43 == v41)
      && IOSurfaceGetWidth(v39) == v40
      && IOSurfaceGetHeight(v39) == v108
      && v44 == v107
      && (IOSurfaceGetProtectionOptions(), IOSurfaceSupportsProtectionOptions()))
    {
LABEL_55:
      double v33 = *(__IOSurface **)&v131[1];
      uint64_t v34 = *(__IOSurface **)(a1 + 80);
      unsigned int v35 = *(_DWORD *)(v110 + 412);
      uint64_t v36 = mach_absolute_time();
      double v37 = CATimeWithHostTime(v36);
      OSType PixelFormat = v32;
      if (!CA::HDRProcessorInternal::should_switch_accelerator(a1, v33, v34, v35, a6, a8, v118, 1, v37 + *(double *)(v110 + 112) * 2.0))
      {
LABEL_71:
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 20));
        goto LABEL_72;
      }
      if (v118 == 2) {
        int v38 = 1;
      }
      else {
        int v38 = 2;
      }
      *(_DWORD *)(v110 + 480) = v38;
    }
    else
    {
LABEL_69:
      OSType PixelFormat = v32;
      if (!a11) {
        goto LABEL_71;
      }
      memset(v137, 0, 24);
      CA::HDRProcessorInternal::get_msr_estimate(v137, a1, *(uint64_t *)&v131[1], *(void *)(a1 + 80), a6, a8);
      if (*(float *)v137 <= 0.975) {
        goto LABEL_71;
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 20));
    return 0;
  }
LABEL_72:
  unsigned int v125 = 0;
  float v124 = 0;
  *(void *)float32x4_t v137 = &v125;
  *(void *)&v137[8] = &v124;
  *(void *)&v137[16] = &v131[1];
  *(void *)&v137[24] = v131;
  float32x4_t v138 = v130;
  float v139 = v129;
  uint64_t v140 = a1;
  uint64_t v45 = *(void *)(a1 + 64);
  if (!v45
    || (CA::HDRProcessorInternal::create_surface_with_forward_dm(CA::Render::Surface const*,CA::Render::Update *,CA::Render::DisplayAttributes const*,BOOL,float,CA::Render::TextureFlags,BOOL,BOOL,BOOL,BOOL)::$_0::operator()((uint64_t)v137, *(uint64_t **)(v45 + 8), 0), !v124)|| !*(_DWORD *)(a1 + 72))
  {
    CA::HDRProcessorInternal::create_surface_with_forward_dm(CA::Render::Surface const*,CA::Render::Update *,CA::Render::DisplayAttributes const*,BOOL,float,CA::Render::TextureFlags,BOOL,BOOL,BOOL,BOOL)::$_0::operator()((uint64_t)v137, *(uint64_t **)(a1 + 56), *(uint64_t **)(a1 + 64));
  }
  if (v125 < 2)
  {
    int v48 = 3;
  }
  else
  {
    int v47 = *(_DWORD *)(a1 + 72);
    if (!v47) {
      goto LABEL_81;
    }
    int v48 = v47 - 1;
  }
  *(_DWORD *)(a1 + 72) = v48;
LABEL_81:
  if (!v124)
  {
LABEL_85:
    if (v24)
    {
      OSType v51 = HIBYTE(PixelFormat);
      if (HIBYTE(PixelFormat) == 45)
      {
        unsigned int v52 = 0;
      }
      else if (v51 == 124)
      {
        unsigned int v52 = 2;
      }
      else if (v51 == 47)
      {
        unsigned int v52 = 1;
      }
      else
      {
        unsigned int v52 = -1;
      }
      __int16 v54 = (CA::Render *)v131[0];
      if (v131[0] == 1882469428) {
        unsigned int v52 = -1;
      }
      if (v52 > 2) {
        int v53 = 2;
      }
      else {
        int v53 = dword_18499B49C[v52];
      }
    }
    else
    {
      int v53 = 0;
      __int16 v54 = (CA::Render *)v131[0];
    }
    unsigned int v55 = (MEMORY[0xFFFFFC020] >> 9) & 4 | v53;
    iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format(v54, v130[0], v129[0], v55, v111, @"CA Forward DM", v46);
    unsigned int v58 = *(__IOSurface **)(a1 + 80);
    if (!v58) {
      goto LABEL_240;
    }
    int v59 = v131[0];
    uint64_t v61 = *(void *)v129;
    uint64_t v60 = *(void *)v130;
    unsigned int v62 = (CA::Render *)IOSurfaceGetPixelFormat(*(IOSurfaceRef *)(a1 + 80));
    if (initialized != -1) {
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    }
    if (*(float *)&dword_1EB2ACAAC
      && CA::Render::fourcc_compressed_of_type(v62, 0, 0) != v62
      || IOSurfaceGetWidth(v58) != v60
      || (int v63 = CA::Render::fourcc_compressed_of_type(v62, 0, 0), IOSurfaceGetHeight(v58) != v61)
      || v63 != v59
      || (IOSurfaceGetProtectionOptions(), (IOSurfaceSupportsProtectionOptions() & 1) == 0))
    {
LABEL_240:
      if (*(unsigned char *)(a1 + 89))
      {
        if (CADeviceSupportsToneMapAcceleratorSwitching::once[0] != -1) {
          dispatch_once(CADeviceSupportsToneMapAcceleratorSwitching::once, &__block_literal_global_248);
        }
        if (CADeviceSupportsToneMapAcceleratorSwitching::accelerator_switching)
        {
          signed int v64 = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v131[0], v130[0], v129[0], v55, v111, @"CA Estimate Surface", v56);
          unsigned int v65 = *(const void **)(a1 + 80);
          if (v65) {
            CFRelease(v65);
          }
          *(void *)(a1 + 80) = v64;
        }
        else
        {
          long long v84 = *(__IOSurface **)(a1 + 80);
          if (v84 != iosurface_with_pixel_format)
          {
            if (v84) {
              CFRelease(v84);
            }
            *(void *)(a1 + 80) = iosurface_with_pixel_format;
            if (!iosurface_with_pixel_format) {
              return 0;
            }
            CFRetain(iosurface_with_pixel_format);
LABEL_117:
            malloc_zone = (malloc_zone_t *)get_malloc_zone();
            char v67 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x158uLL, 0x743898A5uLL);
            if (v67)
            {
              CA::Render::Surface::Surface((uint64_t)v67, iosurface_with_pixel_format, -1, 63, 0, 0, 0);
              operator new();
            }
            operator new();
          }
        }
      }
    }
    if (iosurface_with_pixel_format) {
      goto LABEL_117;
    }
    return 0;
  }
  uint64_t v49 = **v124;
  if (!v49)
  {
    *(void *)(a1 + 64) = v124;
    goto LABEL_85;
  }
  atomic_fetch_add((atomic_uint *volatile)(v49 + 8), 1u);
  unint64_t v50 = *(__IOSurface **)(v49 + 112);
  *(void *)(a1 + 64) = v124;
  unsigned int v123 = 0;
  uint64_t v128 = 0;
  long long v126 = 0u;
  *(_OWORD *)float32x4_t v127 = 0u;
  char v122 = 0;
  CA::HDRProcessorInternal::get_config((uint64_t)&v134, v50, *(__IOSurface **)&v131[1], v117, &v123, 0, &v122, (CA::Render *)0x42475241);
  long long v126 = v134;
  *(_OWORD *)float32x4_t v127 = v135;
  uint64_t v128 = v136;
  if (CADeviceSupportsToneMapAcceleratorSwitching::once[0] != -1) {
    dispatch_once(CADeviceSupportsToneMapAcceleratorSwitching::once, &__block_literal_global_248);
  }
  if (CADeviceSupportsToneMapAcceleratorSwitching::accelerator_switching)
  {
    if (CADeviceHasHardwareAcceleratedHDR::once[0] != -1) {
      dispatch_once(CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_132);
    }
    if (v118 == 2 && CADeviceHasHardwareAcceleratedHDR::has_capability) {
      v127[1] = *(CA::Render **)MEMORY[0x1E4F24AA8];
    }
  }
  if (*(unsigned char *)(a1 + 89))
  {
    unsigned int v71 = 0;
  }
  else
  {
    id started = CA::HDRProcessorInternal::start_command_buffer((id *)a1, v111, v70);
    unsigned int v71 = started;
  }
  if (v112)
  {
    a5 = 0;
    if (*(float *)&dword_1EB2ACAAC > 0.0) {
      *(float *)&dword_1EB2ACAAC = *(float *)&dword_1EB2ACAAC + -1.0;
    }
  }
  char v121 = 0;
  float v120 = (float)HIDWORD(v126);
  char v72 = v109 & a8;
  if ((v109 & a8) == 1)
  {
    int v73 = *(CGColorSpace **)(a2 + 48);
    if (v73)
    {
      CA::Render::Texture::set_colorspace((CA::Render::Texture *)v49, *(CGColorSpace **)(a2 + 48));
      CA::Render::iosurface_set_colorspace(v50, v73, v74);
    }
    float32x2_t v75 = *(__IOSurface **)&v131[1];
    contextCGFloat a = (void *)MEMORY[0x185324A30](started, v69);
    if (*(unsigned char *)(a1 + 89) && !*(void *)(a1 + 104))
    {
      if (CA::WindowServer::accelerator_runloop(void)::once != -1) {
        dispatch_once(&CA::WindowServer::accelerator_runloop(void)::once, &__block_literal_global_6465);
      }
      CA::IOSAManager::create_new_iosa_manager((CA::IOSAManager *)CA::WindowServer::accelerator_runloop(void)::runloop, v76);
    }
    int v77 = qword_1EB2ACC90;
    uint64_t v78 = *MEMORY[0x1E4F6ED60];
    *(void *)&long long v134 = MEMORY[0x1E4F1CC28];
    uint64_t v79 = *MEMORY[0x1E4F6ED68];
    v145[0] = v78;
    v145[1] = v79;
    *((void *)&v134 + 1) = objc_msgSend(NSNumber, "numberWithUnsignedInt:", a6 & 7, ID, *(void *)&v106);
    v145[2] = *MEMORY[0x1E4F6EC78];
    *(void *)&long long v135 = [NSNumber numberWithBool:1];
    v145[3] = *MEMORY[0x1E4F6EC50];
    *((void *)&v135 + 1) = [NSNumber numberWithBool:v77 == 0];
    [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v134 forKeys:v145 count:4];
    uint64_t v133 = qword_1ED033280;
    long long v132 = xmmword_1ED033270;
    IOSurfaceID v80 = IOSurfaceAcceleratorTransformSurface();
    if ((a5 & 1) == 0) {
      ((void (*)(void, void, uint64_t))v132)(*((void *)&v132 + 1), 0, v133);
    }
    if (v80)
    {
      if (x_log_hook_p())
      {
        IOSurfaceGetID(v75);
        x_log_();
      }
      else
      {
        long long v89 = x_log_category_utilities;
        if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
        {
          IOSurfaceID v90 = IOSurfaceGetID(v75);
          *(_DWORD *)buf = 67109376;
          IOSurfaceID v142 = v80;
          __int16 v143 = 1024;
          IOSurfaceID v144 = v90;
          _os_log_impl(&dword_184668000, v89, OS_LOG_TYPE_ERROR, "MSR failed err=0x%x sur=0x%x", buf, 0xEu);
        }
      }
      goto LABEL_179;
    }
    if (byte_1EB2ACC6D)
    {
      if (x_log_hook_p())
      {
        IOSurfaceGetID(v75);
        x_log_();
      }
      else
      {
        __int16 v103 = x_log_category_filmgrain;
        if (os_log_type_enabled((os_log_t)x_log_category_filmgrain, OS_LOG_TYPE_INFO))
        {
          IOSurfaceID v104 = IOSurfaceGetID(v75);
          *(_DWORD *)buf = 67109120;
          IOSurfaceID v142 = v104;
          _os_log_impl(&dword_184668000, v103, OS_LOG_TYPE_INFO, "[0x%x] [SDR] MSR Successfully applied film grain", buf, 8u);
        }
      }
    }
  }
  else if ((CA::HDRProcessorInternal::tonemap_surface_internal(a1, v50, *(__IOSurface **)&v131[1], v110, 0, 0, (uint64_t)&v126, &v120, v123, v117, v118, a5, v71, &v121, a6, SHIWORD(a6), a8, 0, 0, {
               0) & 1) == 0)
  }
  {
LABEL_179:

    if (atomic_fetch_add((atomic_uint *volatile)(v49 + 8), 0xFFFFFFFF) == 1) {
      (*(void (**)(uint64_t))(*(void *)v49 + 16))(v49);
    }
    return 0;
  }
  if (*(unsigned char *)(v110 + 405))
  {
    CFTypeRef v82 = IOSurfaceCopyValue(*(IOSurfaceRef *)&v131[1], (CFStringRef)_kHDRProcessingDolbyVisionRPUDataKey);
    if (v82)
    {
      char v83 = (const void **)(v49 + 144);
LABEL_162:
      X::CFRef<__CFData const*>::operator=(v83, v82);
      CFRelease(v82);
    }
  }
  else if (*(unsigned char *)(v110 + 407))
  {
    CFTypeRef v82 = IOSurfaceCopyValue(v50, (CFStringRef)_kHDRProcessingDolbyVisionHDMIDataKey);
    if (v82)
    {
      char v83 = (const void **)(v49 + 152);
      goto LABEL_162;
    }
  }
  CA::Render::Surface::reload_iosurface_color_attributes((CA::Render::Surface *)v49, v81);
  uint64_t v85 = v117;
  if (v71)
  {
    CA::HDRProcessorInternal::commit_command_buffer(v71, a5);
    uint64_t v85 = v117;
    if (a5)
    {
      aBlock[0] = MEMORY[0x1E4F143A8];
      aBlock[1] = 3221225472;
      aBlock[2] = ___ZN2CA20HDRProcessorInternal30create_surface_with_forward_dmEPKNS_6Render7SurfaceEPNS1_6UpdateEPKNS1_17DisplayAttributesEbfNS1_12TextureFlagsEbbbb_block_invoke;
      aBlock[3] = &unk_1E5274120;
      aBlock[4] = v71;
      uint64_t v86 = *(void *)(v49 + 312);
      if (v86)
      {
        (*(void (**)(uint64_t, uint64_t))(v86 + 16))(v86, 1);
        _Block_release(*(const void **)(v49 + 312));
        *(void *)(v49 + 312) = 0;
      }
      *(void *)(v49 + 312) = _Block_copy(aBlock);
    }
  }
  int v87 = CA::Render::fourcc_compressed_of_type((CA::Render *)LODWORD(v127[0]), 0, 0);
  if ((v72 & 1) == 0)
  {
    switch(v122)
    {
      case 16:
        if ((CA::Render *)*MEMORY[0x1E4F24AA8] == v127[1])
        {
          unsigned int v88 = 13;
        }
        else if ((CA::Render *)*MEMORY[0x1E4F24AC0] == v127[1])
        {
          unsigned int v88 = 7;
        }
        else
        {
          if ((CA::Render *)*MEMORY[0x1E4F24AB0] != v127[1]) {
            goto LABEL_199;
          }
          unsigned int v88 = 18;
        }
        break;
      case 13:
        if ((CA::Render *)*MEMORY[0x1E4F24AA8] == v127[1])
        {
          unsigned int v88 = 14;
        }
        else if ((CA::Render *)*MEMORY[0x1E4F24AC0] == v127[1])
        {
          unsigned int v88 = 5;
        }
        else
        {
          if ((CA::Render *)*MEMORY[0x1E4F24AB0] != v127[1]) {
            goto LABEL_199;
          }
          unsigned int v88 = 29;
        }
        break;
      case 8:
        if ((CA::Render *)*MEMORY[0x1E4F24AB0] == v127[1])
        {
          unsigned int v88 = 26;
        }
        else if ((CA::Render *)*MEMORY[0x1E4F24AC0] == v127[1])
        {
          unsigned int v88 = 15;
        }
        else
        {
          if ((CA::Render *)*MEMORY[0x1E4F24AA8] != v127[1]) {
            goto LABEL_199;
          }
          unsigned int v88 = 10;
        }
        break;
      default:
        goto LABEL_199;
    }
    long long v92 = (CGColorSpace *)CAGetColorSpace(v88);
    if (v92) {
      CA::Render::Texture::set_colorspace((CA::Render::Texture *)v49, v92);
    }
  }
LABEL_199:
  unsigned int v93 = *(_DWORD *)(v85 + 60);
  if (v93 <= 6)
  {
    int v94 = 1 << v93;
    if ((v94 & 0x1C) != 0)
    {
      if (v87 != 1919365992 && v87 != 1380411457) {
        goto LABEL_216;
      }
      (*(void (**)(uint64_t))(*(void *)v49 + 152))(v49);
      uint64_t v85 = v117;
      if (*(unsigned char *)(a1 + 89)
        && *(_DWORD *)(v117 + 60) == 2
        && !(*(unsigned __int8 *)(v117 + 53) | BYTE4(xmmword_1EB2ACC10)))
      {
        float v96 = *(float *)(v117 + 28);
        float v97 = v96 * 0.1;
        BOOL v19 = v96 == 0.0;
        float v95 = 0.2;
        if (!v19) {
          float v95 = v97;
        }
      }
      else if ((*(_WORD *)(v49 + 336) & 4) == 0)
      {
        float v95 = (float)HIDWORD(v126);
      }
    }
    else
    {
      float v95 = 1.0;
      if ((v94 & 0x61) != 0 && (v87 != 1919365992 && v87 != 1380411457 || *(unsigned char *)(a1 + 89))) {
        float v95 = 1.0 / *(float *)(v85 + 20);
      }
    }
    CA::Render::Surface::set_edr_factor(v49, v95);
  }
LABEL_216:
  if (v122 == 16)
  {
    float v98 = *(float *)(v85 + 28);
    if (v98 == 0.0) {
      float v98 = 1.0;
    }
    if (v121) {
      float v98 = (float)(v120 * v98) / *(float *)(v85 + 12);
    }
    CA::Render::Surface::set_edr_factor(v49, v98);
  }
  if (v118 == 2) {
    __int16 v99 = 272;
  }
  else {
    __int16 v99 = 16;
  }
  *(_WORD *)(v49 + 336) = v99 | *(_WORD *)(v49 + 336) & 0xFECF;
  *(_DWORD *)(v49 + 12) &= 0xFFFFF8FF;
  if (v112)
  {
    int v100 = CAIOSurfaceWriteToFileWithSuffix(*(__IOSurface **)&v131[1], "hdr-tonemap-src");
    free(v100);
    __int16 v101 = CAIOSurfaceWriteToFileWithSuffix(v50, "hdr-tonemap-dst");
    free(v101);
  }
  return v49;
}

void sub_1848A0C2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *context)
{
}

uint64_t CA::HDRProcessorInternal::should_switch_accelerator(uint64_t a1, IOSurfaceRef buffer, __IOSurface *a3, unsigned int a4, char a5, uint64_t a6, int a7, char a8, double a9)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  OSType PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(buffer);
  int v19 = CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0);
  int v44 = 0;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v39 = 0u;
  memset(buf, 0, sizeof(buf));
  if (IOSurfaceGetBulkAttachments())
  {
    uint64_t v21 = 0;
  }
  else
  {
    CFDictionaryRef v20 = IOSurfaceCopyAllValues(buffer);
    if (CFDictionaryGetValue(v20, (const void *)_kHDRProcessingDolbyVisionRPUDataKey) && (BYTE12(v40) & 0xFD) == 0x10)
    {
      uint64_t v21 = _kHDRProcessingSourceContentTypeDolbyVision;
      if (!v20) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
    if (BYTE12(v40) == 18) {
      goto LABEL_12;
    }
    if (BYTE12(v40) != 16 || BYTE11(v40) > 0xCu || ((1 << SBYTE11(v40)) & 0x1202) == 0)
    {
      if (CA_CFDictionaryGetBool(v20, @"isHLG"))
      {
LABEL_12:
        uint64_t v21 = _kHDRProcessingSourceContentTypeHLG;
        if (!v20) {
          goto LABEL_17;
        }
        goto LABEL_16;
      }
      if (v19 != 1380411457)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          uint64_t v34 = x_log_category_utilities;
          if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)unsigned int v35 = 67109376;
            *(_DWORD *)&v35[4] = BYTE12(v40);
            LOWORD(v36) = 1024;
            *(_DWORD *)((char *)&v36 + 2) = BYTE11(v40);
            _os_log_impl(&dword_184668000, v34, OS_LOG_TYPE_ERROR, "Unknown HDR surface with transfer index %d color index %d", v35, 0xEu);
          }
        }
        uint64_t v21 = 0;
        if (!v20) {
          goto LABEL_17;
        }
        goto LABEL_16;
      }
    }
    uint64_t v21 = _kHDRProcessingSourceContentTypeHDR10;
    if (v20) {
LABEL_16:
    }
      CFRelease(v20);
  }
LABEL_17:
  if (CADeviceSupportsToneMapAcceleratorSwitching::once[0] != -1) {
    dispatch_once(CADeviceSupportsToneMapAcceleratorSwitching::once, &__block_literal_global_248);
  }
  uint64_t result = 0;
  if (CADeviceSupportsToneMapAcceleratorSwitching::accelerator_switching)
  {
    if (!byte_1EB2ACC0D)
    {
      uint64_t result = 0;
      if (a4 <= 6 && ((1 << a4) & 0x61) != 0)
      {
        if (v21 != _kHDRProcessingSourceContentTypeHDR10 && v21 != _kHDRProcessingSourceContentTypeHLG) {
          return 0;
        }
        BOOL v23 = (CA::Render *)IOSurfaceGetPixelFormat(a3);
        int v24 = (CA::Render *)IOSurfaceGetPixelFormat(buffer);
        if ((a8 & 1) != 0
          || !_hdrp_supports_pixel_format_query
          || (uint64_t v25 = CA::Render::fourcc_compressed_of_type(v24, 0, 0),
              int v26 = objc_msgSend(*(id *)(a1 + 40), "isFormatSupported:inputFormat:outputFormat:device:", 0, v25, CA::Render::fourcc_compressed_of_type(v23, 0, 0), *(void *)(a1 + 24)), result = 0, v26))
        {
          *(void *)unsigned int v35 = 0;
          uint64_t v36 = 0;
          unint64_t v37 = 0;
          CA::HDRProcessorInternal::get_msr_estimate(v35, a1, (uint64_t)buffer, (uint64_t)a3, a5, a6);
          uint64_t v27 = mach_absolute_time();
          double v28 = CATimeWithHostTime(v27);
          double v29 = v28 + (double)(v37 + v36) * 0.000001;
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            double v30 = x_log_category_utilities;
            if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEBUG))
            {
              double v31 = "beat";
              if (v29 > a9) {
                double v31 = "missed";
              }
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = v31;
              *(_WORD *)&buf[12] = 2048;
              *(double *)&buf[14] = a9;
              *(_WORD *)&buf[22] = 2048;
              *(double *)&uint8_t buf[24] = v29;
              LOWORD(v39) = 2048;
              *(double *)((char *)&v39 + 2) = (float)(*(float *)v35 * 100.0);
              _os_log_impl(&dword_184668000, v30, OS_LOG_TYPE_DEBUG, "IOSA %s deadline: %f, with completion estimate: %f.\nCurrent MSR utilization: %.2f%%", buf, 0x2Au);
            }
          }
          uint64_t v32 = mach_absolute_time();
          if (a7 == 2)
          {
            double v33 = CATimeWithHostTime(v32);
            if ((double)v37 / ((a9 - v33) * 1000000.0) + *(float *)v35 < 0.9) {
              return 1;
            }
          }
          else if (*(float *)v35 > 0.975)
          {
            return 1;
          }
          return 0;
        }
      }
    }
  }
  return result;
}

void sub_1848A113C(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CA::HDRProcessorInternal::get_msr_estimate(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  v18[5] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = malloc_type_calloc(1uLL, 0x28uLL, 0x10000407607B2BCuLL);
  *(_DWORD *)uint64_t v9 = 3;
  v9[2] = 0;
  v9[3] = 0;
  v9[1] = 0;
  *((_DWORD *)v9 + 8) = 0;
  uint64_t v10 = [MEMORY[0x1E4F1C9B8] dataWithBytesNoCopy:v9 length:40 freeWhenDone:1];
  uint64_t v11 = *MEMORY[0x1E4F6EC48];
  uint64_t v16 = v10;
  v17[0] = v11;
  uint64_t v12 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v16 count:1];
  uint64_t v13 = *MEMORY[0x1E4F6EC88];
  v18[0] = v12;
  v18[1] = MEMORY[0x1E4F1CC38];
  uint64_t v14 = *MEMORY[0x1E4F6ED60];
  v17[1] = v13;
  void v17[2] = v14;
  v18[2] = MEMORY[0x1E4F1CC28];
  v17[3] = *MEMORY[0x1E4F6ED68];
  v18[3] = [NSNumber numberWithUnsignedInt:a5 & 7];
  v17[4] = *MEMORY[0x1E4F6EC78];
  v18[4] = [NSNumber numberWithBool:a6];
  [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v18 forKeys:v17 count:5];
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  return IOSurfaceAcceleratorGetTransformEstimation();
}

uint64_t CA::HDRProcessorInternal::create_surface_with_forward_dm(CA::Render::Surface const*,CA::Render::Update *,CA::Render::DisplayAttributes const*,BOOL,float,CA::Render::TextureFlags,BOOL,BOOL,BOOL,BOOL)::$_0::operator()(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = result;
    uint64_t v6 = *(void *)(result + 48);
    do
    {
      uint64_t v8 = *v4;
      int v7 = (uint64_t *)v4[1];
      uint64_t result = IOSurfaceIsInUse(*(IOSurfaceRef *)(*(void *)*v4 + 112));
      if (!result)
      {
        uint64_t v9 = *(atomic_uint **)v8;
        if (*(_DWORD *)(*(void *)v8 + 8) == 1)
        {
          uint64_t v10 = *(void **)(v5 + 8);
          ++**(_DWORD **)v5;
          if (*v10) {
            goto LABEL_6;
          }
          uint64_t v12 = (__IOSurface *)*((void *)v9 + 14);
          if (!v12) {
            goto LABEL_6;
          }
          int v18 = **(_DWORD **)(v5 + 24);
          uint64_t v13 = **(void **)(v5 + 32);
          uint64_t v14 = **(void **)(v5 + 40);
          OSType PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(v12);
          if (initialized != -1) {
            dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
          }
          if ((!*(float *)&dword_1EB2ACAAC
             || CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0) == PixelFormat)
            && IOSurfaceGetWidth(v12) == v13
            && ((int v16 = CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0), IOSurfaceGetHeight(v12) == v14)
              ? (BOOL v17 = v16 == v18)
              : (BOOL v17 = 0),
                v17 && (IOSurfaceGetProtectionOptions(), uint64_t result = IOSurfaceSupportsProtectionOptions(), result)))
          {
            **(void **)(v5 + 8) = v4;
            if (*(_DWORD *)(v6 + 72)) {
              return result;
            }
          }
          else
          {
LABEL_6:
            --**(_DWORD **)v5;
            *(void *)(v6 + 56) = x_list_remove(*(void **)(v6 + 56), v8);
            uint64_t v11 = *(atomic_uint **)v8;
            if (*(void *)v8)
            {
              if (atomic_fetch_add(v11 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v11 + 16))(v11);
              }
            }
            uint64_t result = MEMORY[0x185323DC0](v8, 0x20C4093837F09);
          }
        }
      }
      uint64_t v4 = v7;
    }
    while (v7 != a3);
  }
  return result;
}

id CA::HDRProcessorInternal::start_command_buffer(id *this, uint64_t a2, const char *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  CA::HDRProcessorInternal::initialize_metal((CA::HDRProcessorInternal *)this);
  id v5 = (id)[this[4] commandBuffer];
  id v6 = v5;
  if (v5)
  {
    [v5 setProtectionOptions:a2];
  }
  else if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    int v7 = x_log_category_utilities;
    if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
    {
      __int16 v9 = 0;
      _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_ERROR, "command buffer allocation failed!\n", (uint8_t *)&v9, 2u);
    }
  }
  return v6;
}

uint64_t CA::HDRProcessorInternal::tonemap_surface_internal(uint64_t a1, __IOSurface *a2, __IOSurface *a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7, float *a8, unsigned int a9, uint64_t a10, unsigned int a11, char a12, void *a13, unsigned char *a14, char a15, __int16 a16, char a17, uint64_t a18, char a19, _DWORD *a20)
{
  uint64_t v284 = *MEMORY[0x1E4F143B8];
  if (hdrprocessing_init_once != -1)
  {
    uint64_t v115 = a4;
    dispatch_once_f(&hdrprocessing_init_once, 0, (dispatch_function_t)load_hdrprocessing_symbols);
    a4 = v115;
  }
  if (hdr_handle)
  {
    uint64_t v223 = a7;
    uint64_t v224 = a1;
    uint64_t v220 = a5;
    unsigned int v221 = a6;
    uint64_t v219 = a4;
    uint64_t v27 = (void *)MEMORY[0x185324A30]();
    OSType PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(a2);
    int v29 = CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0);
    double v30 = (CA::Render *)IOSurfaceGetPixelFormat(a3);
    int v31 = CA::Render::fourcc_compressed_of_type(v30, 0, 0);
    int v242 = 0;
    long long v240 = 0u;
    long long v241 = 0u;
    long long v238 = 0u;
    long long v239 = 0u;
    long long v236 = 0u;
    long long v237 = 0u;
    long long v235 = 0u;
    int v234 = 0;
    long long v232 = 0u;
    long long v233 = 0u;
    long long v230 = 0u;
    long long v231 = 0u;
    long long v228 = 0u;
    long long v229 = 0u;
    long long v227 = 0u;
    v226[1] = (id)116;
    int BulkAttachments = IOSurfaceGetBulkAttachments();
    int v33 = IOSurfaceGetBulkAttachments();
    CFDictionaryRef v34 = 0;
    if (v33 | BulkAttachments) {
      goto LABEL_31;
    }
    CFDictionaryRef v222 = IOSurfaceCopyAllValues(a3);
    Value = CFDictionaryGetValue(v222, (const void *)_kHDRProcessingDolbyVisionRPUDataKey);
    CFDictionaryRef v34 = v222;
    uint64_t v36 = Value;
    v218 = v27;
    if (Value && (BYTE12(v238) & 0xFD) == 0x10)
    {
      unint64_t v37 = &_kHDRProcessingSourceContentTypeDolbyVision;
    }
    else if (BYTE12(v238) == 18)
    {
      unint64_t v37 = &_kHDRProcessingSourceContentTypeHLG;
    }
    else if (BYTE12(v238) == 16 && BYTE11(v238) <= 0xCu && ((1 << SBYTE11(v238)) & 0x1202) != 0)
    {
      unint64_t v37 = &_kHDRProcessingSourceContentTypeHDR10;
    }
    else
    {
      if (CA_CFDictionaryGetBool(v222, @"isHLG"))
      {
        unint64_t v37 = &_kHDRProcessingSourceContentTypeHLG;
      }
      else
      {
        if (v31 != 1380411457)
        {
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            uint64_t v85 = x_log_category_utilities;
            if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109376;
              *(_DWORD *)&uint8_t buf[4] = BYTE12(v238);
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = BYTE11(v238);
              _os_log_impl(&dword_184668000, v85, OS_LOG_TYPE_ERROR, "Unknown HDR surface with transfer index %d color index %d", buf, 0xEu);
            }
          }
          CFDictionaryRef v34 = v222;
          goto LABEL_31;
        }
        unint64_t v37 = &_kHDRProcessingSourceContentTypeHDR10;
      }
      CFDictionaryRef v34 = v222;
    }
    uint64_t v39 = *v37;
    if (*v37)
    {
      if (CADeviceHasHardwareAcceleratedHDR::once[0] != -1) {
        dispatch_once(CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_132);
      }
      buffer = a2;
      if (CADeviceHasHardwareAcceleratedHDR::has_capability)
      {
        BOOL v40 = a11 < 2;
        if (a11 == 3) {
          BOOL v40 = 1;
        }
        *(unsigned char *)(v224 + 89) = v40;
        unsigned int v216 = (unsigned char *)(v224 + 89);
        if (a11 <= 3 && a11 != 2)
        {
          long long v41 = a20;
          uint64_t v42 = 1;
          goto LABEL_40;
        }
        long long v41 = a20;
      }
      else
      {
        long long v41 = a20;
        *(unsigned char *)(v224 + 89) = 0;
        unsigned int v216 = (unsigned char *)(v224 + 89);
      }
      uint64_t v42 = 0;
LABEL_40:
      *(_DWORD *)(v223 + 36) = v42;
      os_unfair_lock_lock((os_unfair_lock_t)(v224 + 20));
      unsigned int v215 = v42;
      hdr_processor_instance = CA::HDRProcessorInternal::get_or_create_hdr_processor_instance(v224, (__CFRunLoop *)v42, v223);
      uint64_t v45 = v41;
      if (!hdr_processor_instance)
      {
        if (x_log_hook_p())
        {
          x_log_();
          uint64_t v27 = v218;
          int v63 = (os_unfair_lock_s *)(v224 + 20);
        }
        else
        {
          signed int v64 = x_log_category_utilities;
          uint64_t v27 = v218;
          int v63 = (os_unfair_lock_s *)(v224 + 20);
          if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
          {
            unsigned int v65 = "GPU";
            if (v215) {
              unsigned int v65 = "MSR";
            }
            *(_DWORD *)buf = 136315138;
            *(void *)&uint8_t buf[4] = v65;
            _os_log_impl(&dword_184668000, v64, OS_LOG_TYPE_ERROR, "Failed to create HDRProcessor for %s", buf, 0xCu);
          }
        }
        if (v41) {
          *long long v41 = -17001;
        }
        int v66 = v63;
        goto LABEL_204;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v224 + 20));
      id v225 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
      if (_hdrp_version >= 1) {
        [v225 setObject:&unk_1ED057750 forKeyedSubscript:_kHDRProcessingApiInterfaceVersionKey];
      }
      id v217 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
      CFStringRef v46 = (const char *)buffer;
      [v217 setObject:v39 forKeyedSubscript:_kHDRProcessingSourceContentTypeKey];
      if (_kHDRProcessingSourceContentHDRMaxBrightnessInNitsKey) {
        objc_msgSend(v217, "setObject:forKeyedSubscript:", &unk_1ED057768);
      }
      int v47 = a10;
      uint64_t v214 = a9;
      float v48 = *(float *)(a10 + 20);
      unsigned int v49 = *(_DWORD *)(a10 + 60);
      if (v49 > 6 || ((1 << v49) & 0x61) == 0)
      {
        if (*(unsigned char *)(a10 + 50))
        {
          uint64_t v67 = [NSNumber numberWithUnsignedInt:*(unsigned int *)(v223 + 12)];
          uint64_t v61 = (os_unfair_lock_s *)(v224 + 20);
          [v225 setObject:v67 forKeyedSubscript:_kHDRProcessingCurrentMaxPanelNitsKey];
          [v225 setObject:&unk_1ED057780 forKeyedSubscript:_kHDRProcessingAmbientLightInNitsKey];
        }
        else
        {
          uint64_t v61 = (os_unfair_lock_s *)(v224 + 20);
        }
        goto LABEL_101;
      }
      float v50 = *(float *)(a10 + 12);
      if (CADeviceSupportsTwilight::once != -1) {
        dispatch_once(&CADeviceSupportsTwilight::once, &__block_literal_global_304_12248);
      }
      if (CADeviceSupportsTwilight::twilight && v36 && *(unsigned char *)(a10 + 49) && !byte_1EB2ACC64)
      {
        *(void *)float v280 = 0;
        float v281 = v280;
        uint64_t v282 = 0x2020000000;
        OSType v51 = (int (*)(const void *))getCMGetDMVersionLevelFromRPUSymbolLoc(void)::ptr;
        float32x2_t v283 = getCMGetDMVersionLevelFromRPUSymbolLoc(void)::ptr;
        if (!getCMGetDMVersionLevelFromRPUSymbolLoc(void)::ptr)
        {
          *(void *)buf = MEMORY[0x1E4F143A8];
          *(void *)&uint8_t buf[8] = 3221225472;
          *(void *)&buf[16] = ___ZL38getCMGetDMVersionLevelFromRPUSymbolLocv_block_invoke;
          *(void *)unsigned __int8 v247 = &unk_1E5274170;
          *(void *)&v247[8] = v280;
          ___ZL38getCMGetDMVersionLevelFromRPUSymbolLocv_block_invoke((uint64_t)buf);
          OSType v51 = (int (*)(const void *))*((void *)v281 + 3);
        }
        _Block_object_dispose(v280, 8);
        if (!v51)
        {
          unint64_t v177 = dlerror();
          unsigned int v121 = abort_report_np();
          __break(1u);
          goto LABEL_267;
        }
        if (v51(v36) <= 3)
        {
          double v52 = v48 * 0.125 + -1.0;
          if (v52 > 1.0) {
            double v52 = 1.0;
          }
          if (v52 < 0.0) {
            double v52 = 0.0;
          }
          float v53 = v52;
          float v54 = (float)((float)(v53 * -2.0) + 6.0) * v48;
          if (v50 <= v54) {
            float v50 = v54;
          }
          if (a14) {
            *a14 = 1;
          }
        }
      }
      float v55 = 100.0;
      if (v50 != 0.0) {
        float v55 = v50;
      }
      *(_DWORD *)(v223 + 12) = v55;
      *a8 = v55;
      uint64_t v56 = objc_msgSend(NSNumber, "numberWithFloat:");
      [v225 setObject:v56 forKeyedSubscript:_kHDRProcessingCurrentMaxPanelNitsKey];
      *(float *)&double v57 = v48;
      uint64_t v58 = [NSNumber numberWithFloat:v57];
      [v225 setObject:v58 forKeyedSubscript:_kHDRProcessingMaximumExtendedDynamicRangeColorComponentValueKey];
      if (v29 != 1919365992)
      {
        if (v29 == 1380411457)
        {
          if (*v216)
          {
LABEL_70:
            *(float *)&double v59 = 1.0 / v48;
            uint64_t v60 = [NSNumber numberWithFloat:v59];
            uint64_t v61 = (os_unfair_lock_s *)(v224 + 20);
            [v225 setObject:v60 forKeyedSubscript:_kHDRProcessingEDRFactorKey];
LABEL_84:
            LODWORD(v62) = *(_DWORD *)(a10 + 16);
            uint64_t v68 = [NSNumber numberWithFloat:v62];
            [v225 setObject:v68 forKeyedSubscript:_kHDRProcessingAmbientLightInNitsKey];
            if (*(unsigned char *)(a10 + 48) && _kHDRProcessingDisplaySupportsAmbientAdaptationKey) {
              objc_msgSend(v225, "setObject:forKeyedSubscript:", MEMORY[0x1E4F1CC38]);
            }
            if (*(unsigned __int8 *)(a10 + 54) | BYTE12(xmmword_1EB2ACC10))
            {
              uint64_t v69 = [NSNumber numberWithUnsignedInt:1];
              [v225 setObject:v69 forKeyedSubscript:_kHDRProcessingOperationEnum];
              uint64_t v214 = 1;
            }
            unsigned int v70 = *(_DWORD *)(a10 + 60);
            if (v70 <= 6 && ((1 << v70) & 0x61) != 0)
            {
              int v71 = *(_DWORD *)(a10 + 64);
              char v72 = &_kHDRProcessingDisplayPipelineCompensationTypeNone;
              if (v71 == 1 || byte_1EB2ACC0E) {
                goto LABEL_100;
              }
              if (v71 == 3)
              {
                char v72 = &_kHDRProcessingDisplayPipelineCompensationTypeHeadroomDependent;
                goto LABEL_100;
              }
              if (v71 == 2)
              {
                char v72 = &_kHDRProcessingDisplayPipelineCompensationTypePurePower;
LABEL_100:
                [v225 setObject:*v72 forKeyedSubscript:_kHDRProcessingDisplayPipelineCompensationType];
              }
            }
LABEL_101:
            if (v39 == _kHDRProcessingSourceContentTypeDolbyVision && v36) {
              [v225 setObject:v36 forKeyedSubscript:_kHDRProcessingDolbyVisionRPUDataKey];
            }
            int v73 = forward_display_params_from_attributes(a10, 0);
            if (v73) {
              [v225 setObject:v73 forKeyedSubscript:_kHDRProcessingDisplayKey];
            }
            if (v31 == 1380411457 && BYTE12(v238) != 16)
            {
              CFTypeRef v75 = IOSurfaceCopyValue(a3, @"SDRBrightnessInNits");
              int v77 = v75;
              if (v75)
              {
                float v78 = CA_CFFloatValue(v75);
                CFRelease(v77);
              }
              else
              {
                float v78 = 100.0;
              }
              *(float *)&double v76 = v78;
              uint64_t v79 = [NSNumber numberWithFloat:v76];
              [v217 setObject:v79 forKeyedSubscript:_kHDRProcessingSourceContentSDRMaxBrightnessInNitsKey];
            }
            if (*(unsigned char *)(a10 + 53))
            {
              if (v214 == 4)
              {
                if (initialized != -1) {
                  dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
                }
                *(float *)&double v74 = truncf(*(float *)&dword_1EB2ACB04);
                if (!*(float *)&dword_1EB2ACB04) {
                  *(float *)&double v74 = 200.0;
                }
                uint64_t v80 = [NSNumber numberWithFloat:v74];
                [v217 setObject:v80 forKeyedSubscript:_kHDRProcessingSourceContentSDRMaxBrightnessInNitsKey];
                if (!a18 && a19 != 2 && (*(_DWORD *)(a10 + 60) - 3) <= 1)
                {
                  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                  CFTypeRef v82 = Mutable;
                  if (Mutable)
                  {
                    float v83 = flt_1849974C0[a19 == 0];
                    float v84 = flt_1849974C8[a19 == 0];
                    CA_CFDictionarySetFloat(Mutable, (const void *)*MEMORY[0x1E4F2F0E0], 0.015);
                    CA_CFDictionarySetFloat(v82, (const void *)*MEMORY[0x1E4F2F0D8], v83);
                    CA_CFDictionarySetFloat(v82, (const void *)*MEMORY[0x1E4F2F0D0], v84);
                    CA_CFDictionarySetInt(v82, (const void *)*MEMORY[0x1E4F2F0C8], 16);
                    IOSurfaceSetValue(buffer, (CFStringRef)*MEMORY[0x1E4F2F0C0], v82);
                    CFRelease(v82);
                  }
                  else if (x_log_hook_p())
                  {
                    x_log_();
                  }
                  else
                  {
                    uint64_t v86 = x_log_category_utilities;
                    if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_impl(&dword_184668000, v86, OS_LOG_TYPE_DEFAULT, "CoreAnimation: unable to set static PQ stats, no dictionary created.", buf, 2u);
                    }
                  }
                }
              }
              if (BYTE12(v238) == 18)
              {
                LODWORD(v74) = *(_DWORD *)(a10 + 4);
                uint64_t v87 = [NSNumber numberWithFloat:v74];
                [v225 setObject:v87 forKeyedSubscript:_kHDRProcessingCurrentMaxPanelNitsKey];
                uint64_t v214 = 3;
              }
              if (a18) {
                [v225 setObject:a18 forKeyedSubscript:_kHDRProcessingDolbyVisionRPUDataKey];
              }
            }
            [v225 setObject:v217 forKeyedSubscript:_kHDRProcessingSourceContentKey];

            if (*v216)
            {
              uint64_t v27 = v218;
              uint64_t v88 = v224;
              if (*(_DWORD *)(a10 + 60) != 2 || *(unsigned __int8 *)(a10 + 53) | BYTE4(xmmword_1EB2ACC10))
              {
LABEL_139:
                IOSurfaceGetID(a3);
                IOSurfaceGetID(buffer);
                if (BYTE9(xmmword_1EB2ACC10)) {
                  kdebug_trace();
                }
                if (*(_DWORD *)(a10 + 60)) {
                  IOSurfaceRemoveValue(buffer, (CFStringRef)*MEMORY[0x1E4F2F090]);
                }
                if (!BYTE12(xmmword_1EB2ACC30))
                {
LABEL_144:
                  os_unfair_lock_lock(v61);
                  if (!CA::HDRProcessorInternal::get_or_create_hdr_processor_instance(v88, (__CFRunLoop *)v215, v223))
                  {
                    if (x_log_hook_p())
                    {
                      x_log_();
                    }
                    else
                    {
                      int v102 = x_log_category_utilities;
                      if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
                      {
                        __int16 v103 = "GPU";
                        if (v215) {
                          __int16 v103 = "MSR";
                        }
                        *(_DWORD *)buf = 136315138;
                        *(void *)&uint8_t buf[4] = v103;
                        _os_log_impl(&dword_184668000, v102, OS_LOG_TYPE_ERROR, "Failed to create HDRProcessor for %s", buf, 0xCu);
                      }
                    }
                    if (v45) {
                      *uint64_t v45 = -17001;
                    }

                    goto LABEL_203;
                  }
                  if (*v216)
                  {
                    v226[0] = 0;
                    uint64_t v89 = 40;
                    if (!_hdrp_supports_new_init) {
                      uint64_t v89 = 96;
                    }
                    uint64_t v90 = objc_msgSend(*(id *)(v88 + v89), "generateMSRColorConfigWithOperation:inputSurface:outputSurface:metadata:histogram:config:", v214, a3, v46, v225, 0, v226, v177, v178, v179, v180, v181, v182, v183, v184, v185, v186, v187,
                            v188,
                            v189,
                            v190,
                            v191,
                            v192,
                            v193,
                            v194,
                            v195,
                            v196,
                            v197,
                            v198);
                    os_unfair_lock_unlock(v61);
                    uint64_t v91 = [v226[0] bytes];
                    int v92 = [v226[0] length];
                    id v93 = v226[0];
                    if (v90 != -17000)
                    {
                      if (x_log_hook_p())
                      {
                        x_log_();
                      }
                      else
                      {
                        IOSurfaceID v104 = x_log_category_utilities;
                        if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)buf = 134218752;
                          *(void *)&uint8_t buf[4] = v90;
                          *(_WORD *)&buf[12] = 2048;
                          *(void *)&buf[14] = a3;
                          *(_WORD *)&buf[22] = 2048;
                          *(void *)unsigned __int8 v247 = v46;
                          *(_WORD *)&v247[8] = 2048;
                          *(void *)&v247[10] = v225;
                          _os_log_impl(&dword_184668000, v104, OS_LOG_TYPE_ERROR, "HDRProcessor error (%ld) (src:%p, dst:%p, md:%p)", buf, 0x2Au);
                        }
                      }
                      if (v45) {
                        *uint64_t v45 = v90;
                      }

                      goto LABEL_202;
                    }
                    int v94 = malloc_type_malloc(0x28uLL, 0x10000407607B2BCuLL);
                    *(_DWORD *)int v94 = 3;
                    v94[1] = v91;
                    *((_DWORD *)v94 + 4) = v92;
                    *(void *)((char *)v94 + 28) = 0;
                    *(void *)((char *)v94 + 20) = 0;
                    uint64_t v95 = (uint64_t)v220;
                    uint64_t v96 = [MEMORY[0x1E4F1C9B8] dataWithBytesNoCopy:v94 length:40 freeWhenDone:1];
                    if (v221)
                    {
                      uint64_t v97 = v221[5];
                      float v98 = (_DWORD *)v221[8];
                      if (v98) {
                        CA::WindowServer::SharedEvent::History::add(v98, *v221, 6, 1, 1, v221[5]);
                      }
                      uint64_t v99 = CA::WindowServer::SharedEvent::inc_signal_value((uint64_t)v221, 6, 1);
                    }
                    else
                    {
                      uint64_t v97 = 0;
                      uint64_t v99 = 0;
                    }
                    if (v220)
                    {
                      uint64_t v105 = v220[2];
                      double v106 = (_DWORD *)v220[8];
                      if (v106) {
                        CA::WindowServer::SharedEvent::History::add(v106, *v220, 7, 1, 2, v220[2]);
                      }
                      uint64_t v95 = CA::WindowServer::SharedEvent::inc_signal_value((uint64_t)v220, 7, 2);
                    }
                    else
                    {
                      uint64_t v105 = 0;
                    }
                    int v107 = qword_1EB2ACC90;
                    v244[0] = *MEMORY[0x1E4F6EC48];
                    uint64_t v243 = v96;
                    v245[0] = [MEMORY[0x1E4F1C978] arrayWithObjects:&v243 count:1];
                    v245[1] = MEMORY[0x1E4F1CC38];
                    uint64_t v108 = *MEMORY[0x1E4F6ED60];
                    v244[1] = *MEMORY[0x1E4F6EC88];
                    v244[2] = v108;
                    v245[2] = MEMORY[0x1E4F1CC28];
                    v244[3] = *MEMORY[0x1E4F6ED68];
                    v245[3] = [NSNumber numberWithUnsignedInt:a15 & 7];
                    v244[4] = *MEMORY[0x1E4F6EC78];
                    v245[4] = objc_msgSend(NSNumber, "numberWithBool:");
                    v244[5] = *MEMORY[0x1E4F6ED00];
                    v245[5] = [NSNumber numberWithLongLong:v97];
                    v244[6] = *MEMORY[0x1E4F6ECF8];
                    v245[6] = [NSNumber numberWithLongLong:v99];
                    v244[7] = *MEMORY[0x1E4F6ECE8];
                    v245[7] = [NSNumber numberWithLongLong:v105];
                    v244[8] = *MEMORY[0x1E4F6ECE0];
                    v245[8] = [NSNumber numberWithLongLong:v95];
                    v244[9] = *MEMORY[0x1E4F6EC50];
                    v245[9] = [NSNumber numberWithBool:v107 == 0];
                    [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v245 forKeys:v244 count:10];
                    atomic_fetch_add((atomic_uint *volatile)(*(void *)(v224 + 104) + 24), 1u);
                    uint64_t v109 = *(void *)(v224 + 104);
                    *(void *)buf = CA::release_hdr_iosa_param;
                    *(void *)&uint8_t buf[8] = v109;
                    *(id *)&buf[16] = v226[0];
                    uint64_t v61 = (os_unfair_lock_s *)(v224 + 20);
                    int v110 = IOSurfaceAcceleratorTransformSurface();
                    int v111 = v110;
                    if (v219) {
                      ++*(_DWORD *)(v219 + 488);
                    }
                    if (!a12 || v110)
                    {
                      (*(void (**)(void, void, void))buf)(*(void *)&buf[8], 0, *(void *)&buf[16]);
                      if (v111)
                      {
                        if (x_log_hook_p())
                        {
                          IOSurfaceGetID(a3);
                          x_log_();
                        }
                        else
                        {
                          float32x4_t v113 = x_log_category_utilities;
                          if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
                          {
                            IOSurfaceID ID = IOSurfaceGetID(a3);
                            *(_DWORD *)float v280 = 67109376;
                            *(_DWORD *)&v280[4] = v111;
                            LOWORD(v281) = 1024;
                            *(_DWORD *)((char *)&v281 + 2) = ID;
                            _os_log_impl(&dword_184668000, v113, OS_LOG_TYPE_ERROR, "MSR failed err=0x%x sur=0x%x", v280, 0xEu);
                          }
                        }
                        if (v45) {
                          *uint64_t v45 = v111;
                        }

LABEL_202:
                        os_unfair_lock_lock(v61);
LABEL_203:
                        int v66 = v61;
LABEL_204:
                        os_unfair_lock_unlock(v66);
                        uint64_t v38 = 0;
LABEL_205:
                        CFDictionaryRef v34 = v222;
                        if (!v222) {
                          goto LABEL_35;
                        }
                        goto LABEL_34;
                      }
                    }
                    if (byte_1EB2ACC6D && a17)
                    {
                      if (x_log_hook_p())
                      {
                        uint64_t v27 = v218;
                        uint64_t v61 = (os_unfair_lock_s *)(v224 + 20);
                        IOSurfaceGetID(a3);
                        x_log_();
                      }
                      else
                      {
                        unsigned int v175 = x_log_category_filmgrain;
                        uint64_t v27 = v218;
                        uint64_t v61 = (os_unfair_lock_s *)(v224 + 20);
                        if (os_log_type_enabled((os_log_t)x_log_category_filmgrain, OS_LOG_TYPE_INFO))
                        {
                          IOSurfaceID v176 = IOSurfaceGetID(a3);
                          *(_DWORD *)float v280 = 67109120;
                          *(_DWORD *)&v280[4] = v176;
                          _os_log_impl(&dword_184668000, v175, OS_LOG_TYPE_INFO, "[0x%x] [HDR] MSR Successfully applied film grain", v280, 8u);
                          uint64_t v27 = v218;
                          uint64_t v61 = (os_unfair_lock_s *)(v224 + 20);
                        }
                      }
                    }
                  }
                  else
                  {
                    CA::shared_event_submit(*(void **)(v88 + 24), a13, (uint64_t)v221, 1, 1);
                    CA::shared_event_submit(*(void **)(v88 + 24), a13, (uint64_t)v220, 1, 2);
                    uint64_t v100 = 40;
                    if (!_hdrp_supports_new_init) {
                      uint64_t v100 = 48;
                    }
                    uint64_t v101 = objc_msgSend(*(id *)(v88 + v100), "encodeToCommandBuffer:inputSurfaceLayer0:inputSurfacelayer1:outputSurface:metadata:", a13, a3, 0, v46, v225, v177, v178, v179, v180, v181, v182, v183, v184, v185, v186, v187, v188,
                             v189,
                             v190,
                             v191,
                             v192,
                             v193,
                             v194,
                             v195,
                             v196,
                             v197,
                             v198);
                    os_unfair_lock_unlock(v61);
                    CA::shared_event_submit(*(void **)(v88 + 24), a13, (uint64_t)v221, 0, 1);
                    CA::shared_event_submit(*(void **)(v88 + 24), a13, (uint64_t)v220, 0, 2);
                    if (v219) {
                      ++*(_DWORD *)(v219 + 492);
                    }
                    if (v101 != -17000)
                    {
                      if (x_log_hook_p())
                      {
                        x_log_();
                      }
                      else
                      {
                        unsigned int v112 = x_log_category_utilities;
                        if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)buf = 134219008;
                          *(void *)&uint8_t buf[4] = v101;
                          *(_WORD *)&buf[12] = 2048;
                          *(void *)&buf[14] = a13;
                          *(_WORD *)&buf[22] = 2048;
                          *(void *)unsigned __int8 v247 = a3;
                          *(_WORD *)&v247[8] = 2048;
                          *(void *)&v247[10] = v46;
                          *(_WORD *)&v247[18] = 2048;
                          *(void *)&v247[20] = v225;
                          _os_log_impl(&dword_184668000, v112, OS_LOG_TYPE_ERROR, "HDRProcessor error (%ld) (cmd:%p, src:%p, dst:%p, md:%p)", buf, 0x34u);
                        }
                      }
                      if (v45) {
                        *uint64_t v45 = v101;
                      }

                      goto LABEL_202;
                    }
                  }
                  os_unfair_lock_lock(v61);
                  os_unfair_lock_unlock(v61);

                  uint64_t v38 = 1;
                  goto LABEL_205;
                }
                id v217 = v45;
                uint64_t v212 = objc_msgSend((id)objc_msgSend(v225, "debugDescription"), "UTF8String");
                if (x_log_hook_p())
                {
                  if (*v216) {
                    float32x4_t v116 = "MSR";
                  }
                  else {
                    float32x4_t v116 = "GPU";
                  }
                  uint64_t v211 = IOSurfaceGetID(a3);
                  size_t Width = IOSurfaceGetWidth(a3);
                  size_t Height = IOSurfaceGetHeight(a3);
                  OSType v117 = IOSurfaceGetPixelFormat(a3);
                  unsigned int v118 = HIBYTE(v117);
                  if ((v117 & 0x80000000) != 0) {
                    int v119 = __maskrune(v118, 0x40000uLL);
                  }
                  else {
                    int v119 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v118 + 60) & 0x40000;
                  }
                  if (v119) {
                    OSType v123 = IOSurfaceGetPixelFormat(a3) & 0xFF000000;
                  }
                  else {
                    OSType v123 = 0x20000000;
                  }
                  int v204 = v123;
                  unsigned int v124 = (IOSurfaceGetPixelFormat(a3) >> 16);
                  if (v124 <= 0x7F) {
                    int v125 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v124 + 60) & 0x40000;
                  }
                  else {
                    int v125 = __maskrune(v124, 0x40000uLL);
                  }
                  if (v125) {
                    char v126 = IOSurfaceGetPixelFormat(a3) >> 16;
                  }
                  else {
                    char v126 = 32;
                  }
                  char v202 = v126;
                  unsigned int v127 = ((unsigned __int16)IOSurfaceGetPixelFormat(a3) >> 8);
                  if (v127 <= 0x7F) {
                    int v128 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v127 + 60) & 0x40000;
                  }
                  else {
                    int v128 = __maskrune(v127, 0x40000uLL);
                  }
                  if (v128) {
                    char v129 = (unsigned __int16)IOSurfaceGetPixelFormat(a3) >> 8;
                  }
                  else {
                    char v129 = 32;
                  }
                  char v200 = v129;
                  unsigned int v130 = IOSurfaceGetPixelFormat(a3);
                  if (v130 <= 0x7F) {
                    int v131 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v130 + 60) & 0x40000;
                  }
                  else {
                    int v131 = __maskrune(v130, 0x40000uLL);
                  }
                  if (v131) {
                    char v132 = IOSurfaceGetPixelFormat(a3);
                  }
                  else {
                    char v132 = 32;
                  }
                  uint64_t v133 = IOSurfaceGetID(buffer);
                  size_t v134 = IOSurfaceGetWidth(buffer);
                  size_t v135 = IOSurfaceGetHeight(buffer);
                  OSType v136 = IOSurfaceGetPixelFormat(buffer);
                  unsigned int v137 = HIBYTE(v136);
                  if ((v136 & 0x80000000) != 0) {
                    int v138 = __maskrune(v137, 0x40000uLL);
                  }
                  else {
                    int v138 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v137 + 60) & 0x40000;
                  }
                  if (v138) {
                    signed int v139 = IOSurfaceGetPixelFormat(buffer) & 0xFF000000;
                  }
                  else {
                    signed int v139 = 0x20000000;
                  }
                  unsigned int v140 = (IOSurfaceGetPixelFormat(buffer) >> 16);
                  if (v140 <= 0x7F) {
                    int v141 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v140 + 60) & 0x40000;
                  }
                  else {
                    int v141 = __maskrune(v140, 0x40000uLL);
                  }
                  if (v141) {
                    char v142 = IOSurfaceGetPixelFormat(buffer) >> 16;
                  }
                  else {
                    char v142 = 32;
                  }
                  unsigned int v143 = ((unsigned __int16)IOSurfaceGetPixelFormat(buffer) >> 8);
                  if (v143 <= 0x7F) {
                    int v144 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v143 + 60) & 0x40000;
                  }
                  else {
                    int v144 = __maskrune(v143, 0x40000uLL);
                  }
                  if (v144) {
                    char v145 = (unsigned __int16)IOSurfaceGetPixelFormat(buffer) >> 8;
                  }
                  else {
                    char v145 = 32;
                  }
                  unsigned int v146 = IOSurfaceGetPixelFormat(buffer);
                  if (v146 <= 0x7F) {
                    int v147 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v146 + 60) & 0x40000;
                  }
                  else {
                    int v147 = __maskrune(v146, 0x40000uLL);
                  }
                  if (v147) {
                    char v148 = IOSurfaceGetPixelFormat(buffer);
                  }
                  else {
                    char v148 = 32;
                  }
                  uint64_t v197 = v214;
                  uint64_t v198 = v212;
                  uint64_t v195 = BYTE11(v230);
                  uint64_t v196 = BYTE12(v230);
                  uint64_t v193 = v145;
                  uint64_t v194 = v148;
                  uint64_t v191 = (v139 >> 24);
                  uint64_t v192 = v142;
                  size_t v189 = v134;
                  size_t v190 = v135;
                  uint64_t v187 = BYTE12(v238);
                  uint64_t v188 = v133;
                  uint64_t v185 = v132;
                  uint64_t v186 = BYTE11(v238);
                  uint64_t v183 = v202;
                  uint64_t v184 = v200;
                  size_t v181 = Height;
                  uint64_t v182 = (v204 >> 24);
                  uint64_t v179 = v211;
                  size_t v180 = Width;
                  uint64_t v88 = v224;
                  unint64_t v177 = (char *)v224;
                  v178 = v116;
                  x_log_();
LABEL_314:
                  uint64_t v45 = v217;
                  uint64_t v27 = v218;
                  uint64_t v61 = (os_unfair_lock_s *)(v224 + 20);
                  CFStringRef v46 = (const char *)buffer;
                  goto LABEL_144;
                }
                int v47 = x_log_category_utilities;
                uint64_t v27 = v218;
                uint64_t v61 = (os_unfair_lock_s *)(v224 + 20);
                uint64_t v88 = v224;
                CFStringRef v46 = (const char *)buffer;
                if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_144;
                }
                if (*v216) {
                  CFStringRef v46 = "MSR";
                }
                else {
                  CFStringRef v46 = "GPU";
                }
                IOSurfaceID v210 = IOSurfaceGetID(a3);
                size_t v208 = IOSurfaceGetWidth(a3);
                size_t v206 = IOSurfaceGetHeight(a3);
                OSType v120 = IOSurfaceGetPixelFormat(a3);
                unsigned int v121 = HIBYTE(v120);
                if ((v120 & 0x80000000) == 0)
                {
                  int v122 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v121 + 60) & 0x40000;
LABEL_268:
                  if (v122) {
                    OSType v149 = IOSurfaceGetPixelFormat(a3) & 0xFF000000;
                  }
                  else {
                    OSType v149 = 0x20000000;
                  }
                  int v205 = v149;
                  unsigned int v150 = (IOSurfaceGetPixelFormat(a3) >> 16);
                  if (v150 <= 0x7F) {
                    int v151 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v150 + 60) & 0x40000;
                  }
                  else {
                    int v151 = __maskrune(v150, 0x40000uLL);
                  }
                  if (v151) {
                    char v152 = IOSurfaceGetPixelFormat(a3) >> 16;
                  }
                  else {
                    char v152 = 32;
                  }
                  char v203 = v152;
                  unsigned int v153 = ((unsigned __int16)IOSurfaceGetPixelFormat(a3) >> 8);
                  if (v153 <= 0x7F) {
                    int v154 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v153 + 60) & 0x40000;
                  }
                  else {
                    int v154 = __maskrune(v153, 0x40000uLL);
                  }
                  if (v154) {
                    char v155 = (unsigned __int16)IOSurfaceGetPixelFormat(a3) >> 8;
                  }
                  else {
                    char v155 = 32;
                  }
                  char v201 = v155;
                  unsigned int v156 = IOSurfaceGetPixelFormat(a3);
                  if (v156 <= 0x7F) {
                    int v157 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v156 + 60) & 0x40000;
                  }
                  else {
                    int v157 = __maskrune(v156, 0x40000uLL);
                  }
                  if (v157) {
                    char v158 = IOSurfaceGetPixelFormat(a3);
                  }
                  else {
                    char v158 = 32;
                  }
                  IOSurfaceID v199 = IOSurfaceGetID(buffer);
                  size_t v159 = IOSurfaceGetWidth(buffer);
                  size_t v160 = IOSurfaceGetHeight(buffer);
                  OSType v161 = IOSurfaceGetPixelFormat(buffer);
                  unsigned int v162 = HIBYTE(v161);
                  if ((v161 & 0x80000000) != 0) {
                    int v163 = __maskrune(v162, 0x40000uLL);
                  }
                  else {
                    int v163 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v162 + 60) & 0x40000;
                  }
                  if (v163) {
                    signed int v164 = IOSurfaceGetPixelFormat(buffer) & 0xFF000000;
                  }
                  else {
                    signed int v164 = 0x20000000;
                  }
                  unsigned int v165 = (IOSurfaceGetPixelFormat(buffer) >> 16);
                  if (v165 <= 0x7F) {
                    int v166 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v165 + 60) & 0x40000;
                  }
                  else {
                    int v166 = __maskrune(v165, 0x40000uLL);
                  }
                  if (v166) {
                    char v167 = IOSurfaceGetPixelFormat(buffer) >> 16;
                  }
                  else {
                    char v167 = 32;
                  }
                  unsigned int v168 = ((unsigned __int16)IOSurfaceGetPixelFormat(buffer) >> 8);
                  if (v168 <= 0x7F) {
                    int v169 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v168 + 60) & 0x40000;
                  }
                  else {
                    int v169 = __maskrune(v168, 0x40000uLL);
                  }
                  if (v169) {
                    char v170 = (unsigned __int16)IOSurfaceGetPixelFormat(buffer) >> 8;
                  }
                  else {
                    char v170 = 32;
                  }
                  unsigned int v171 = IOSurfaceGetPixelFormat(buffer);
                  if (v171 <= 0x7F) {
                    int v172 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v171 + 60) & 0x40000;
                  }
                  else {
                    int v172 = __maskrune(v171, 0x40000uLL);
                  }
                  if (v172) {
                    char v173 = IOSurfaceGetPixelFormat(buffer);
                  }
                  else {
                    char v173 = 32;
                  }
                  *(_DWORD *)buf = 134223362;
                  int v174 = v158;
                  uint64_t v88 = v224;
                  *(void *)&uint8_t buf[4] = v224;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v46;
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)unsigned __int8 v247 = v210;
                  *(_WORD *)&v247[4] = 2048;
                  *(void *)&v247[6] = v208;
                  *(_WORD *)&v247[14] = 2048;
                  *(void *)&v247[16] = v206;
                  *(_WORD *)&v247[24] = 1024;
                  *(_DWORD *)&v247[26] = v205 >> 24;
                  __int16 v248 = 1024;
                  int v249 = v203;
                  __int16 v250 = 1024;
                  int v251 = v201;
                  __int16 v252 = 1024;
                  int v253 = v174;
                  __int16 v254 = 1024;
                  int v255 = BYTE11(v238);
                  __int16 v256 = 1024;
                  int v257 = BYTE12(v238);
                  __int16 v258 = 1024;
                  IOSurfaceID v259 = v199;
                  __int16 v260 = 2048;
                  size_t v261 = v159;
                  __int16 v262 = 2048;
                  size_t v263 = v160;
                  __int16 v264 = 1024;
                  int v265 = v164 >> 24;
                  __int16 v266 = 1024;
                  int v267 = v167;
                  __int16 v268 = 1024;
                  int v269 = v170;
                  __int16 v270 = 1024;
                  int v271 = v173;
                  __int16 v272 = 1024;
                  int v273 = BYTE11(v230);
                  __int16 v274 = 1024;
                  int v275 = BYTE12(v230);
                  __int16 v276 = 1024;
                  int v277 = v214;
                  __int16 v278 = 2080;
                  uint64_t v279 = v212;
                  _os_log_impl(&dword_184668000, v47, OS_LOG_TYPE_DEFAULT, "HDRProcessor %p accelerator %s src surface 0x%x [%zu x %zu] (%c%c%c%c) Primaries: 0x%x, TransferFunction: 0x%x dst surface 0x%x [%zu x %zu] (%c%c%c%c) Primaries: 0x%x, TransferFunction: 0x%x operation 0x%x metadata: %s\n", buf, 0xA2u);
                  goto LABEL_314;
                }
LABEL_267:
                int v122 = __maskrune(v121, 0x40000uLL);
                goto LABEL_268;
              }
              [v225 setObject:&unk_1ED0576F0 forKeyedSubscript:_kHDRProcessingCurrentMaxPanelNitsKey];
              uint64_t v214 = 3;
            }
            uint64_t v27 = v218;
            uint64_t v88 = v224;
            goto LABEL_139;
          }
        }
        else if (BYTE12(v230) != 16)
        {
          goto LABEL_70;
        }
      }
      [v225 setObject:&unk_1ED05B9C8 forKeyedSubscript:_kHDRProcessingEDRFactorKey];
      uint64_t v61 = (os_unfair_lock_s *)(v224 + 20);
      goto LABEL_84;
    }
    uint64_t v27 = v218;
LABEL_31:
    uint64_t v38 = 0;
    if (a20) {
      *a20 = -17006;
    }
    if (!v34) {
      goto LABEL_35;
    }
LABEL_34:
    CFRelease(v34);
LABEL_35:
    return v38;
  }
  uint64_t v38 = 0;
  if (a20) {
    *a20 = -17010;
  }
  return v38;
}

void sub_1848A32F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,os_unfair_lock_t lock,uint64_t a46,void *context,uint64_t a48,uint64_t a49,uint64_t a50,CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(a1);
}

void CA::HDRProcessorInternal::commit_command_buffer(void *a1, int a2)
{
  block[5] = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  if (CA::_root_queue_once[0] == -1)
  {
    if (a2)
    {
LABEL_3:
      atomic_uint v3 = CA::_root_queue;
      dispatch_time_t v4 = dispatch_time(0, 14000000);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[3] = &unk_1E52807A0;
      block[4] = v5;
      block[2] = ___ZN2CA20HDRProcessorInternal21commit_command_bufferEPU27objcproto16MTLCommandBuffer11objc_objectb_block_invoke;
      dispatch_after(v4, v3, block);
      return;
    }
  }
  else
  {
    dispatch_once(CA::_root_queue_once, &__block_literal_global_23119);
    a1 = v5;
    if (a2) {
      goto LABEL_3;
    }
  }
  if (([a1 commitAndWaitUntilSubmitted] & 1) == 0) {
    [v5 waitUntilScheduled];
  }
}

void ___ZN2CA20HDRProcessorInternal30create_surface_with_forward_dmEPKNS_6Render7SurfaceEPNS1_6UpdateEPKNS1_17DisplayAttributesEbfNS1_12TextureFlagsEbbbb_block_invoke(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0) {
    [*(id *)(a1 + 32) waitUntilScheduled];
  }
  atomic_uint v3 = *(void **)(a1 + 32);
}

uint64_t ___ZN2CA20HDRProcessorInternal21commit_command_bufferEPU27objcproto16MTLCommandBuffer11objc_objectb_block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) commit];
}

void *___ZL38getCMGetDMVersionLevelFromRPUSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!CoreMediaLibraryCore(char **)::frameworkLibrary)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 3221225472;
    v5[3] = ___ZL20CoreMediaLibraryCorePPc_block_invoke;
    v5[4] = &__block_descriptor_40_e5_v8__0l;
    v5[5] = v5;
    long long v6 = xmmword_1E5274190;
    uint64_t v7 = 0;
    CoreMediaLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
    atomic_uint v3 = (void *)v5[0];
    id v2 = (void *)CoreMediaLibraryCore(char **)::frameworkLibrary;
    if (CoreMediaLibraryCore(char **)::frameworkLibrary)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      atomic_uint v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  id v2 = (void *)CoreMediaLibraryCore(char **)::frameworkLibrary;
LABEL_5:
  uint64_t result = dlsym(v2, "CMGetDMVersionLevelFromRPU");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getCMGetDMVersionLevelFromRPUSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void CA::shared_event_submit(void *a1, void *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return;
  }
  if (!a2)
  {
    if (x_log_hook_p()) {
      goto LABEL_19;
    }
    uint64_t v13 = x_log_category_sharedevent;
    if (!os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)buf = 0;
    uint64_t v14 = "Invalid command buffer";
LABEL_30:
    _os_log_impl(&dword_184668000, v13, OS_LOG_TYPE_ERROR, v14, buf, 2u);
    return;
  }
  uint64_t v8 = *(void **)(a3 + 8);
  if (!v8)
  {
    if (x_log_hook_p()) {
      goto LABEL_19;
    }
    uint64_t v13 = x_log_category_sharedevent;
    if (!os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)buf = 0;
    uint64_t v14 = "Invalid metal shared event";
    goto LABEL_30;
  }
  uint64_t v11 = [v8 newSharedEventHandle];
  if (!v11)
  {
    if (x_log_hook_p()) {
      goto LABEL_19;
    }
    uint64_t v13 = x_log_category_sharedevent;
    if (!os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)buf = 0;
    uint64_t v14 = "Invalid metal shared event handle";
    goto LABEL_30;
  }
  uint64_t v12 = (void *)v11;
  id v15 = (id)[a1 newSharedEventWithHandle:v11];

  if (v15)
  {
    if (a4) {
      objc_msgSend(a2, "encodeWaitForEvent:value:", v15, CA::WindowServer::SharedEvent::get_wait_value(a3, 15, a5));
    }
    else {
      objc_msgSend(a2, "encodeSignalEvent:value:", v15, CA::WindowServer::SharedEvent::inc_signal_value(a3, 15, a5));
    }

    return;
  }
  if (!x_log_hook_p())
  {
    uint64_t v13 = x_log_category_sharedevent;
    if (!os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)buf = 0;
    uint64_t v14 = "Invalid metal shared event with handle";
    goto LABEL_30;
  }
LABEL_19:

  x_log_();
}

void CA::release_hdr_iosa_param(CA *this, void *a2, void *a3, void *a4)
{
  CA::IOSAManager::unref((uint64_t)this);
}

uint64_t ___ZL20CoreMediaLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CoreMediaLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

uint64_t CA::HDRProcessorInternal::tonemap_surface(uint64_t a1, __IOSurface *a2, __IOSurface *a3, uint64_t *a4, uint64_t *a5, uint64_t a6, uint64_t a7, int a8, unint64_t a9, char a10, _DWORD *a11)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  unsigned int v34 = 0;
  uint64_t v33 = 0;
  memset(v32, 0, sizeof(v32));
  CA::HDRProcessorInternal::get_config((uint64_t)v32, a2, a3, a6, &v34, a8, &v31, (CA::Render *)0x42475241);
  if (a7)
  {
    if (*(unsigned char *)(a1 + 89))
    {
      HIDWORD(v33) = 1;
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 20));
      if (!*(void *)(a1 + 104) || !*(void *)(a1 + 40)) {
        CA::HDRProcessorInternal::get_or_create_hdr_processor_instance(a1, (__CFRunLoop *)1, (uint64_t)v32);
      }
      unsigned int v19 = *(_DWORD *)(a6 + 60);
      uint64_t v20 = mach_absolute_time();
      double v21 = CATimeWithHostTime(v20);
      if (CA::HDRProcessorInternal::should_switch_accelerator(a1, a3, a2, v19, 0, 0, 0, 0, v21 + *(double *)(a7 + 112) * 2.0))*(_DWORD *)(a7 + 480) = 2; {
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 20));
      }
    }
    unsigned int v22 = *(_DWORD *)(a7 + 480);
  }
  else
  {
    unsigned int v22 = 2;
  }
  if (CADeviceHasHardwareAcceleratedHDR::once[0] != -1) {
    dispatch_once(CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_132);
  }
  if (CADeviceHasHardwareAcceleratedHDR::has_capability)
  {
    BOOL v23 = v22 < 2;
    if (v22 == 3) {
      BOOL v23 = 1;
    }
    *(unsigned char *)(a1 + 89) = v23;
    if (v22 <= 3 && v22 != 2)
    {
      id started = 0;
      goto LABEL_21;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 89) = 0;
  }
  id started = CA::HDRProcessorInternal::start_command_buffer((id *)a1, a9, v18);
LABEL_21:
  if (a7) {
    uint64_t v25 = CA::HDRProcessorInternal::tonemap_surface_internal(a1, a2, a3, a7, a4, a5, (uint64_t)v32, &v30, v34, a6, v22, a10, started, 0, 0, 0, 0, *(void *)(a7 + 896), *(unsigned char *)(a7 + 1084) & 3,
  }
            a11);
  else {
    uint64_t v25 = CA::HDRProcessorInternal::tonemap_surface_internal(a1, a2, a3, 0, a4, a5, (uint64_t)v32, &v30, v34, a6, v22, a10, started, 0, 0, 0, 0, 0, 0,
  }
            a11);
  uint64_t v26 = v25;
  if (started) {
    CA::HDRProcessorInternal::commit_command_buffer(started, 0);
  }
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (*(float *)&dword_1EB2ACAAC)
  {
    if (*(float *)&dword_1EB2ACAAC > 0.0) {
      *(float *)&dword_1EB2ACAAC = *(float *)&dword_1EB2ACAAC + -1.0;
    }
    uint64_t v27 = CAIOSurfaceWriteToFileWithSuffix(a3, "hdr-tonemap-src");
    free(v27);
    double v28 = CAIOSurfaceWriteToFileWithSuffix(a2, "hdr-tonemap-dst");
    free(v28);
  }
  return v26;
}

void sub_1848A3D44(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::HDRProcessorInternal::~HDRProcessorInternal(CA::HDRProcessorInternal *this)
{
  CA::HDRProcessorInternal::~HDRProcessorInternal(this);

  JUMPOUT(0x185323DC0);
}

{
  uint64_t v2;
  atomic_uint **v3;
  atomic_uint *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  const void *v8;

  *(void *)this = &unk_1ED027400;
  id v2 = *((void *)this + 7);
  if (v2)
  {
    do
    {
      atomic_uint v3 = *(atomic_uint ***)v2;
      if (*(void *)v2)
      {
        dispatch_time_t v4 = *v3;
        if (*v3 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
        }
        MEMORY[0x185323DC0](v3, 0x20C4093837F09);
      }
      id v2 = *(void *)(v2 + 8);
    }
    while (v2);
    id v5 = (void *)*((void *)this + 7);
    if (v5)
    {
      do
      {
        long long v6 = (void *)v5[1];
        free(v5);
        id v5 = v6;
      }
      while (v6);
    }
  }

  uint64_t v7 = *((void *)this + 13);
  if (v7)
  {
    CA::IOSAManager::unref(v7);
    *((void *)this + 13) = 0;
  }

  uint64_t v8 = (const void *)*((void *)this + 10);
  if (v8) {
    CFRelease(v8);
  }
}

void sub_1848A3EB4(_Unwind_Exception *exception_object)
{
  atomic_uint v3 = *(const void **)(v1 + 80);
  if (v3) {
    CFRelease(v3);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN2CA14CAHDRProcessor14warmup_shadersEPv_block_invoke(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (CADeviceSupportsHDRProcessing::once[0] != -1) {
    dispatch_once(CADeviceSupportsHDRProcessing::once, &__block_literal_global_175);
  }
  if (CADeviceSupportsHDRProcessing::supports_hdr)
  {
    long long v4 = 0u;
    long long v3 = 0u;
    uint64_t v2 = 0x87000000F00;
    *(void *)&long long v4 = *MEMORY[0x1E4F24AB0];
    *(void *)((char *)&v3 + 4) = 0x7267336800000064;
  }
}

BOOL CA::CAHDRProcessor::iomfb_hdr10plus_convert_sei_to_metadata(CA::CAHDRProcessor *this, const __CFData *a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (hdrprocessing_init_once != -1) {
    dispatch_once_f(&hdrprocessing_init_once, 0, (dispatch_function_t)load_hdrprocessing_symbols);
  }
  if (hdr_handle)
  {
    uint64_t v5 = NSSelectorFromString(&cfstr_Parsehdr10plus.isa);
    if (objc_opt_respondsToSelector())
    {
      id v6 = objc_msgSend((id)hdr_processor_class, v5, this, a2);
      if (v6 == (id)-17000) {
        return 1;
      }
      id v8 = v6;
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        __int16 v9 = x_log_category_utilities;
        BOOL result = os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        *(_DWORD *)buf = 134218496;
        id v11 = v8;
        __int16 v12 = 2048;
        uint64_t v13 = this;
        __int16 v14 = 2048;
        CFDataRef v15 = a2;
        _os_log_impl(&dword_184668000, v9, OS_LOG_TYPE_ERROR, "HDRProcessor error (%ld) converting hdr10plus SEI to metadata (sei:%p, metadata:%p)", buf, 0x20u);
      }
    }
  }
  return 0;
}

BOOL CA::CAHDRProcessor::can_display_tonemap(CA::CAHDRProcessor *this, CA::Render::Surface *a2)
{
  if (IOSurfaceGetBulkAttachments()) {
    return 0;
  }
  CFDictionaryRef v3 = IOSurfaceCopyAllValues(this);
  if (CFDictionaryGetValue(v3, (const void *)_kHDRProcessingDolbyVisionRPUDataKey))
  {
    BOOL Bool = 0;
    if (!v3) {
      return Bool;
    }
    goto LABEL_7;
  }
  BOOL Bool = CA_CFDictionaryGetBool(v3, @"isHLG");
  if (v3) {
LABEL_7:
  }
    CFRelease(v3);
  return Bool;
}

void sub_1848A4238(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CA::CAHDRProcessor::should_invalidate_tonemapping(CA::CAHDRProcessor *this, float a2, float a3, float a4, float a5)
{
  unsigned int v5 = BYTE11(xmmword_1EB2ACC30);
  if (BYTE11(xmmword_1EB2ACC30)) {
    return 1;
  }
  if (a2 != 0.0 && a3 != 0.0) {
    unsigned int v5 = vabds_f32(a2, a3) > (float)(fminf(a2, a3) * 0.01);
  }
  BOOL v6 = a3 == 1.0 && a2 == 1.0;
  float v7 = 0.05;
  if (v6) {
    float v7 = 0.01;
  }
  if (vabds_f32(a4, a5) > (float)(v7 * a4)) {
    return 1;
  }
  else {
    return v5;
  }
}

void native_window_release(_CAEAGLNativeWindow *a1, void *a2)
{
  if (atomic_fetch_add((atomic_uint *volatile)a1 + 32, 0xFFFFFFFF) == 1)
  {
    CA::Render::remove_every_observer(a1, a2);
    if (*((void *)a1 + 18))
    {
      pthread_setspecific(collect_slot, a1);
      CAImageQueueInvalidate(*((void *)a1 + 18));
      pthread_setspecific(collect_slot, 0);
    }
    uint64_t v3 = *((void *)a1 + 22);
    if (v3)
    {
      do
      {
        long long v4 = *(void **)v3;
        if (*(void *)v3)
        {
          uint64_t v5 = *((void *)a1 + 18);
          if (v5)
          {
            uint64_t v6 = v4[3];
            if (v6) {
              CAImageQueueUnregisterBuffer(v5, v6);
            }
          }
          float v7 = (const void *)v4[5];
          if (v7) {
            CFRelease(v7);
          }
          free(v4);
        }
        uint64_t v3 = *(void *)(v3 + 8);
      }
      while (v3);
      id v8 = (void *)*((void *)a1 + 22);
      if (v8)
      {
        do
        {
          __int16 v9 = (void *)v8[1];
          free(v8);
          id v8 = v9;
        }
        while (v9);
      }
    }
    uint64_t v10 = (void *)*((void *)a1 + 13);
    if (v10)
    {
      do
      {
        id v11 = (void *)v10[1];
        free(v10);
        uint64_t v10 = v11;
      }
      while (v11);
    }
    __int16 v12 = (void *)*((void *)a1 + 24);
    if (v12)
    {
      uint64_t v13 = *((void *)a1 + 18);
      if (v13)
      {
        uint64_t v14 = v12[3];
        if (v14) {
          CAImageQueueUnregisterBuffer(v13, v14);
        }
      }
      CFDataRef v15 = (const void *)v12[5];
      if (v15) {
        CFRelease(v15);
      }
      free(v12);
    }
    uint64_t v16 = *((void *)a1 + 29);
    if (v16) {
      dispatch_release(v16);
    }
    uint64_t v17 = (const void *)*((void *)a1 + 18);
    if (v17) {
      CFRelease(v17);
    }
    free(a1);
  }
}

intptr_t layer_collectable_signal(_CAImageQueue *a1, void *a2)
{
  if (atomic_exchange((atomic_uint *volatile)a2 + 60, 2u) == 1) {
    return dispatch_semaphore_signal(*((dispatch_semaphore_t *)a2 + 29));
  }
  return result;
}

void will_suspend_callback(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (os_unfair_lock_s *)(a2 + 136);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 136));
  pthread_setspecific(collect_slot, (const void *)a2);
  CAImageQueueConsumeUnconsumed_(*(void *)(a2 + 144), 1);
  CAImageQueueCollect_(*(void *)(a2 + 144), 0, 0);
  pthread_setspecific(collect_slot, 0);
  for (uint64_t i = *(uint64_t **)(a2 + 176); i; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v5 = *i;
    *(unsigned char *)(v5 + 48) = 1;
    uint64_t v6 = *(__IOSurface **)(v5 + 40);
    uint32_t oldState = 0;
    IOSurfaceSetPurgeable(v6, 1u, &oldState);
  }

  os_unfair_lock_unlock(v3);
}

void sub_1848A4DCC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t native_window_estimated_size(_EAGLNativeWindowObject *a1)
{
  p_var2 = (os_unfair_lock_s *)&a1[2].var2;
  os_unfair_lock_lock((os_unfair_lock_t)&a1[2].var2);
  if ((a1[2].var1 & 2) == 0)
  {
    uint64_t v3 = 0;
    goto LABEL_21;
  }
  int var3 = (int)a1[3].var3;
  int var3_high = HIDWORD(a1[3].var3);
  int var4 = (int)a1[3].var4;
  int var8 = (int)a1[2].var8;
  if (var8 <= 1278555700)
  {
    if (var8 != 875836468)
    {
      if (var8 == 1111970369)
      {
        int v8 = 4;
        goto LABEL_14;
      }
      if (var8 != 1278555445) {
        goto LABEL_11;
      }
    }
LABEL_12:
    int v8 = 2;
    goto LABEL_14;
  }
  if (var8 == 1278555701) {
    goto LABEL_12;
  }
  int v8 = 8;
  if (var8 != 1380411457 && var8 != 1999908961) {
LABEL_11:
  }
    int v8 = 0;
LABEL_14:
  if ((var4 & 4) != 0) {
    int v9 = HIDWORD(a1[3].var3);
  }
  else {
    int v9 = (int)a1[3].var3;
  }
  int v10 = MEMORY[0x1853234F0](*MEMORY[0x1E4F2EFE0], (v8 * v9));
  if ((var4 & 4) != 0) {
    int v11 = var3;
  }
  else {
    int v11 = var3_high;
  }
  uint64_t v3 = MEMORY[0x1853234F0](*MEMORY[0x1E4F2EFB8], ((v10 + 255) & 0xFFFFFF00) * v11);
LABEL_21:
  os_unfair_lock_unlock(p_var2);
  return v3;
}

void sub_1848A4F14(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t native_window_begin_properties(_EAGLNativeWindowObject *a1)
{
  p_var2 = (os_unfair_lock_s *)&a1[2].var2;
  os_unfair_lock_lock((os_unfair_lock_t)&a1[2].var2);
  if ((a1[2].var1 & 2) == 0 || *(void *)&a1[3].var0)
  {
    uint64_t v3 = 0;
    goto LABEL_4;
  }
  if ((a1[4].var0 & 2) == 0 || (uint64_t v5 = *((void *)a1[2].var3 + 6)) == 0 || !*(_DWORD *)(*(void *)(v5 + 24) + 32))
  {
    atomic_fetch_and((atomic_uint *volatile)&a1[2].var1, 0xFFFFFFF7);
    var5 = (atomic_uint *)a1[3].var5;
    if (!var5)
    {
      var2 = a1[3].var2;
      if (var2)
      {
        preflight_buffer = get_preflight_buffer((_CAEAGLNativeWindow *)a1, a1[3].var3, HIDWORD(a1[3].var3), var2[4], (CA::Render *)LODWORD(a1[2].var8));
        LODWORD(a1[3].var4) = preflight_buffer[4];
        atomic_fetch_or((atomic_uint *volatile)&a1[2].var1, 1u);
        a1[3].var5 = preflight_buffer;
        atomic_fetch_add(preflight_buffer, 1u);
        uint64_t v3 = preflight_buffer[4];
        goto LABEL_4;
      }
      goto LABEL_14;
    }
    goto LABEL_11;
  }
  atomic_fetch_or((atomic_uint *volatile)&a1[2].var1, 8u);
  var5 = (atomic_uint *)a1[3].var5;
  if (var5)
  {
LABEL_11:
    if (atomic_fetch_add(var5, 0xFFFFFFFF) == 1)
    {
      var7 = a1[2].var7;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      int v9 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
      void *v9 = var5;
      v9[1] = var7;
      a1[2].var7 = v9;
    }
    a1[3].var5 = 0;
  }
LABEL_14:
  uint64_t v10 = *((void *)a1[2].var3 + 6);
  if (v10)
  {
    unint64_t v11 = atomic_load((unint64_t *)(*(void *)(v10 + 24) + 8));
    if ((v11 & 0x800000000000000) == 0) {
      goto LABEL_19;
    }
    if (CADeviceUseCompression::once[0] != -1) {
      dispatch_once(CADeviceUseCompression::once, &__block_literal_global_21);
    }
    if (!CADeviceUseCompression::enable_compression) {
      LODWORD(v10) = *(unsigned char *)(*(void *)(*((void *)a1[2].var3 + 6) + 24) + 92) & 7;
    }
    else {
LABEL_19:
    }
      LODWORD(v10) = 0;
  }
  if (LODWORD(a1[2].var8) == 1111970369) {
    uint64_t v3 = v10 | 0x10;
  }
  else {
    uint64_t v3 = v10;
  }
  int var4 = a1[1].var4;
  if (var4)
  {
    if (((uint64_t (*)(void, void, void, uint64_t))var4)(*(void *)&a1[1].var0, LODWORD(a1[3].var3), HIDWORD(a1[3].var3), v3))uint64_t v3 = v3; {
    else
    }
      v3 &= 0x10u;
  }
  LODWORD(a1[3].var4) = v3;
  atomic_fetch_or((atomic_uint *volatile)&a1[2].var1, 1u);
LABEL_4:
  os_unfair_lock_unlock(p_var2);
  return v3;
}

void sub_1848A50F8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

_DWORD *get_preflight_buffer(_CAEAGLNativeWindow *a1, unsigned int a2, unsigned int a3, int a4, CA::Render *a5)
{
  pthread_setspecific(collect_slot, a1);
  CAImageQueueConsumeUnconsumed_(*((void *)a1 + 18), 0);
  CAImageQueueCollect_(*((void *)a1 + 18), 0, 0);
  pthread_setspecific(collect_slot, 0);
  __int16 v12 = (uint64_t *)*((void *)a1 + 22);
  if (v12)
  {
    while (1)
    {
      buffer = (_DWORD *)*v12;
      if (*(_DWORD *)(*v12 + 4) == a2 && buffer[2] == a3 && buffer[4] == a4 && buffer[3] == a5) {
        break;
      }
      __int16 v12 = (uint64_t *)v12[1];
      if (*((_DWORD *)a1 + 28) - buffer[5] >= 1)
      {
        *((void *)a1 + 22) = x_list_remove(*((void **)a1 + 22), (uint64_t)buffer);
        release_buffer(a1, (CAEAGLBuffer *)buffer);
      }
      if (!v12) {
        goto LABEL_9;
      }
    }
    *((void *)a1 + 22) = x_list_remove(*((void **)a1 + 22), *v12);
  }
  else
  {
LABEL_9:
    buffer = allocate_buffer(a2, a3, a4, a5, *((_CAImageQueue **)a1 + 18), v10, v11);
    if ((call_create_buffer(a1, (CAEAGLBuffer *)buffer) & 1) == 0 && buffer)
    {
      uint64_t v14 = *((void *)a1 + 18);
      if (v14)
      {
        uint64_t v15 = *((void *)buffer + 3);
        if (v15) {
          CAImageQueueUnregisterBuffer(v14, v15);
        }
      }
      uint64_t v16 = (const void *)*((void *)buffer + 5);
      if (v16) {
        CFRelease(v16);
      }
      free(buffer);
      return 0;
    }
  }
  return buffer;
}

void release_buffer(_CAEAGLNativeWindow *a1, CAEAGLBuffer *a2)
{
  uint64_t v5 = (CAEAGLBuffer **)((char *)a1 + 104);
  long long v4 = (CAEAGLBuffer **)*((void *)a1 + 13);
  if (v4)
  {
    if (*v4 == a2)
    {
LABEL_6:
      float v7 = v4[1];
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v4);
      const char *v5 = v7;
      --*((void *)a1 + 15);
      int v9 = (void (*)(void, void))*((void *)a1 + 10);
      if (v9) {
        v9(*((void *)a1 + 8), *((void *)a2 + 5));
      }
    }
    else
    {
      while (1)
      {
        uint64_t v6 = v4;
        long long v4 = (CAEAGLBuffer **)v4[1];
        if (!v4) {
          break;
        }
        if (*v4 == a2)
        {
          uint64_t v5 = v6 + 1;
          goto LABEL_6;
        }
      }
    }
  }
  if (*((CAEAGLBuffer **)a1 + 25) == a2)
  {
    *((void *)a1 + 25) = 0;
    if (!a2) {
      return;
    }
  }
  else if (!a2)
  {
    return;
  }
  uint64_t v10 = *((void *)a1 + 18);
  if (v10)
  {
    uint64_t v11 = *((void *)a2 + 3);
    if (v11) {
      CAImageQueueUnregisterBuffer(v10, v11);
    }
  }
  __int16 v12 = (const void *)*((void *)a2 + 5);
  if (v12) {
    CFRelease(v12);
  }

  free(a2);
}

_DWORD *allocate_buffer(unsigned int a1, unsigned int a2, int a3, CA::Render *this, _CAImageQueue *a5, uint64_t a6, const __CFString *a7)
{
  int v8 = (int)this;
  unsigned int v10 = a2;
  if ((a3 & 4) != 0)
  {
    int v12 = a1;
  }
  else
  {
    a2 = a1;
    int v12 = v10;
  }
  iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format(this, a2, v12, (MEMORY[0xFFFFFC020] >> 9) & 4, 0, @"CAEAGLLayer Drawable", a7);
  uint64_t v14 = malloc_type_calloc(1uLL, 0x38uLL, 0x10200404E9E88B7uLL);
  v14[1] = a1;
  void v14[2] = v10;
  v14[3] = v8;
  v14[4] = a3;
  *((void *)v14 + 5) = iosurface_with_pixel_format;
  if (a5) {
    *((void *)v14 + 3) = CAImageQueueRegisterIOSurfaceBuffer((_anonymous_namespace_ *)a5, iosurface_with_pixel_format, 0);
  }
  return v14;
}

uint64_t call_create_buffer(_CAEAGLNativeWindow *a1, CAEAGLBuffer *a2)
{
  if (!a2) {
    return 1;
  }
  uint64_t v3 = (uint64_t (*)(void, void))*((void *)a1 + 9);
  if (v3)
  {
    uint64_t v5 = *((void *)a1 + 13);
    if (v5)
    {
      while (*(CAEAGLBuffer **)v5 != a2)
      {
        uint64_t v5 = *(void *)(v5 + 8);
        if (!v5) {
          goto LABEL_6;
        }
      }
    }
    else
    {
LABEL_6:
      uint64_t result = v3(*((void *)a1 + 8), *((void *)a2 + 5));
      if (!result) {
        return result;
      }
      uint64_t v7 = *((void *)a1 + 13);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      int v9 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
      void *v9 = a2;
      v9[1] = v7;
      *((void *)a1 + 13) = v9;
      ++*((void *)a1 + 15);
    }
  }
  return 1;
}

void native_window_collect(_EAGLNativeWindowObject *a1)
{
  p_var2 = (os_unfair_lock_s *)&a1[2].var2;
  os_unfair_lock_lock((os_unfair_lock_t)&a1[2].var2);
  native_window_collect_(a1, 0);

  os_unfair_lock_unlock(p_var2);
}

void sub_1848A5528(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void native_window_collect_(_EAGLNativeWindowObject *a1, int a2)
{
  pthread_setspecific(collect_slot, a1);
  CAImageQueueCollect_((uint64_t)a1[2].var3, a2, 0);
  pthread_setspecific(collect_slot, 0);
  var7 = (CAEAGLBuffer **)a1[2].var7;
  if (var7)
  {
    a1[2].var7 = 0;
    uint64_t v5 = var7;
    do
    {
      release_buffer((_CAEAGLNativeWindow *)a1, *v5);
      uint64_t v5 = (CAEAGLBuffer **)v5[1];
    }
    while (v5);
    do
    {
      uint64_t v6 = (CAEAGLBuffer **)var7[1];
      free(var7);
      var7 = v6;
    }
    while (v6);
  }
}

uint64_t native_window_begin_iosurface(_EAGLNativeWindowObject *a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  p_var2 = (os_unfair_lock_s *)&a1[2].var2;
  os_unfair_lock_lock((os_unfair_lock_t)&a1[2].var2);
  if ((a1[2].var1 & 2) == 0 || *(void *)&a1[3].var0)
  {
LABEL_3:
    os_unfair_lock_unlock(p_var2);
    return 0;
  }
  if (a1[2].var1)
  {
    atomic_fetch_and((atomic_uint *volatile)&a1[2].var1, 0xFFFFFFFE);
    int var4 = (int)a1[3].var4;
    LODWORD(a1[3].var4) = 0;
    var5 = a1[3].var5;
    if (var5)
    {
      *(void *)&a1[3].var0 = var5;
      a1[3].var5 = 0;
      pthread_setspecific(collect_slot, a1);
      CAImageQueueCollect_((uint64_t)a1[2].var3, 0, 0);
      pthread_setspecific(collect_slot, 0);
      call_create_buffer((_CAEAGLNativeWindow *)a1, (CAEAGLBuffer *)var5);
      uint64_t v7 = mach_absolute_time();
      *((double *)var5 + 4) = CATimeWithHostTime(v7);
      IOSurfaceGetID(*((IOSurfaceRef *)var5 + 5));
      kdebug_trace();
      goto LABEL_10;
    }
  }
  else
  {
    if ((a1[2].var1 & 8) == 0)
    {
      var5 = get_preflight_buffer((_CAEAGLNativeWindow *)a1, a1[3].var3, HIDWORD(a1[3].var3), 0, (CA::Render *)LODWORD(a1[2].var8));
      atomic_fetch_add((atomic_uint *volatile)var5, 1u);
      *(void *)&a1[3].var0 = var5;
      pthread_setspecific(collect_slot, a1);
      CAImageQueueCollect_((uint64_t)a1[2].var3, 0, 0);
      pthread_setspecific(collect_slot, 0);
      call_create_buffer((_CAEAGLNativeWindow *)a1, (CAEAGLBuffer *)var5);
      uint64_t v5 = mach_absolute_time();
      *((double *)var5 + 4) = CATimeWithHostTime(v5);
      IOSurfaceGetID(*((IOSurfaceRef *)var5 + 5));
      kdebug_trace();
LABEL_10:
      os_unfair_lock_unlock(p_var2);
      goto LABEL_57;
    }
    int var4 = 0;
  }
  if ((a1[2].var1 & 8) == 0) {
    CAImageQueueConsumeUnconsumed_((uint64_t)a1[2].var3, 0);
  }
  char v8 = 0;
  double v9 = 0.0;
  while (1)
  {
    pthread_setspecific(collect_slot, a1);
    uint64_t v10 = CAImageQueueCollect_((uint64_t)a1[2].var3, 0, 0);
    pthread_setspecific(collect_slot, 0);
    if (v10) {
      break;
    }
    os_unfair_lock_unlock(p_var2);
    uint64_t v13 = mach_absolute_time();
    double v14 = CATimeWithHostTime(v13);
    double v15 = v14;
    if (v9 == 0.0)
    {
      double v9 = v14;
    }
    else if (v8 & 1 | (v14 <= v9 + 0.05) || (dyld_program_sdk_at_least() & 1) != 0)
    {
      if (v15 > *(double *)&a1[2].var6 + v9)
      {
        os_unfair_lock_lock(p_var2);
        goto LABEL_3;
      }
    }
    else
    {
      uint64_t v16 = (void *)MEMORY[0x185324A30]();
      +[CATransaction flush];
      char v8 = 1;
    }
    kdebug_trace();
    int v17 = 2;
    atomic_compare_exchange_strong((atomic_uint *volatile)&a1[3].var7, (unsigned int *)&v17, 0);
    if (v17 != 2)
    {
      while (1)
      {
        int v18 = 0;
        atomic_compare_exchange_strong((atomic_uint *volatile)&a1[3].var7, (unsigned int *)&v18, 1u);
        if (!v18)
        {
          dispatch_time_t v19 = dispatch_time(0, (uint64_t)(*(double *)&a1[2].var6 * 1000000000.0));
          if (dispatch_semaphore_wait((dispatch_semaphore_t)a1[3].var6, v19)) {
            break;
          }
        }
        int v20 = 2;
        atomic_compare_exchange_strong((atomic_uint *volatile)&a1[3].var7, (unsigned int *)&v20, 0);
        if (v20 == 2) {
          goto LABEL_30;
        }
      }
      int v21 = 1;
      atomic_compare_exchange_strong((atomic_uint *volatile)&a1[3].var7, (unsigned int *)&v21, 0);
      if (v21 != 1) {
        dispatch_semaphore_wait((dispatch_semaphore_t)a1[3].var6, 0xFFFFFFFFFFFFFFFFLL);
      }
    }
LABEL_30:
    kdebug_trace();
    os_unfair_lock_lock(p_var2);
  }
  var7 = (void **)a1[2].var7;
  if (var7)
  {
    BOOL v23 = 0;
    while (1)
    {
      var5 = *var7;
      int v24 = var7[1];
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, var7);
      a1[2].var7 = v24;
      if (*((_DWORD *)var5 + 1) == LODWORD(a1[3].var3)
        && *((_DWORD *)var5 + 2) == HIDWORD(a1[3].var3)
        && *((_DWORD *)var5 + 4) == var4
        && *((_DWORD *)var5 + 3) == LODWORD(a1[2].var8))
      {
        break;
      }
      if (LODWORD(a1[1].var7) - *((_DWORD *)var5 + 5) < 1)
      {
        BOOL v23 = var5;
      }
      else
      {
        release_buffer((_CAEAGLNativeWindow *)a1, (CAEAGLBuffer *)var5);
        int v24 = a1[2].var7;
      }
      var7 = (void **)v24;
      if (!v24)
      {
        if (!v23) {
          goto LABEL_44;
        }
        var5 = 0;
        int v24 = 0;
        int v26 = 1;
        goto LABEL_43;
      }
    }
    if (!v23) {
      goto LABEL_60;
    }
    int v26 = 0;
LABEL_43:
    uint64_t v27 = (malloc_zone_t *)get_malloc_zone();
    double v28 = malloc_type_zone_malloc(v27, 0x10uLL, 0x8BB15036uLL);
    *double v28 = v23;
    v28[1] = v24;
    a1[2].var7 = v28;
    if (v26) {
      goto LABEL_44;
    }
LABEL_60:
    if (*((unsigned char *)var5 + 48))
    {
      unsigned int v34 = (__IOSurface *)*((void *)var5 + 5);
      uint32_t oldState = 0;
      IOSurfaceSetPurgeable(v34, 0, &oldState);
      *((unsigned char *)var5 + 48) = 0;
    }
  }
  else
  {
LABEL_44:
    var5 = allocate_buffer(a1[3].var3, HIDWORD(a1[3].var3), var4, (CA::Render *)LODWORD(a1[2].var8), (_CAImageQueue *)a1[2].var3, v11, v12);
  }
  if (call_create_buffer((_CAEAGLNativeWindow *)a1, (CAEAGLBuffer *)var5))
  {
    *(void *)&a1[3].var0 = var5;
    if (var5)
    {
      atomic_fetch_add((atomic_uint *volatile)var5, 1u);
      uint64_t v29 = mach_absolute_time();
      *((double *)var5 + 4) = CATimeWithHostTime(v29);
      IOSurfaceGetID(*((IOSurfaceRef *)var5 + 5));
    }
  }
  else
  {
    if (var5)
    {
      int var3 = a1[2].var3;
      if (var3)
      {
        uint64_t v31 = *((void *)var5 + 3);
        if (v31) {
          CAImageQueueUnregisterBuffer((uint64_t)var3, v31);
        }
      }
      uint64_t v32 = (const void *)*((void *)var5 + 5);
      if (v32) {
        CFRelease(v32);
      }
      free(var5);
    }
    var5 = 0;
    *(void *)&a1[3].var0 = 0;
  }
  kdebug_trace();
  os_unfair_lock_unlock(p_var2);
  if (!var5) {
    return 0;
  }
LABEL_57:
  int v33 = LODWORD(a1[1].var7) + 1;
  LODWORD(a1[1].var7) = v33;
  *((_DWORD *)var5 + 5) = v33;
  return *((void *)var5 + 5);
}

void sub_1848A5B68()
{
  objc_end_catch();
  os_unfair_lock_lock(v0);
  JUMPOUT(0x1848A5B98);
}

uint64_t native_window_swap_zero_time(_EAGLNativeWindowObject *a1, double a2)
{
  return native_window_swap(a1, 0.0);
}

uint64_t native_window_swap(_EAGLNativeWindowObject *a1, double a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a2 == 0.0) {
    int v4 = (LOBYTE(a1[4].var0) >> 3) & 1;
  }
  else {
    int v4 = 0;
  }
  p_var2 = (os_unfair_lock_s *)&a1[2].var2;
  os_unfair_lock_lock((os_unfair_lock_t)&a1[2].var2);
  if ((a1[2].var1 & 2) == 0 || (uint64_t v6 = *(void *)&a1[3].var0) == 0)
  {
    os_unfair_lock_unlock(p_var2);
    return 0;
  }
  *(void *)&a1[3].var0 = 0;
  if (a2 <= 0.0005)
  {
    if ((a1[4].var0 & 4) != 0) {
      int v8 = 1073741828;
    }
    else {
      int v8 = 1073741826;
    }
    if ((a1[4].var0 & 4) != 0) {
      int v4 = 0;
    }
    double v7 = 0.0;
    goto LABEL_18;
  }
  double v7 = a2 + -0.0005;
  if ((a1[4].var0 & 4) != 0) {
    int v4 = 0;
  }
  int v8 = 0x40000000;
  if (v7 == 0.0)
  {
LABEL_18:
    if (CADeviceSupportsAPT::once[0] != -1) {
      dispatch_once(CADeviceSupportsAPT::once, &__block_literal_global_52);
    }
    if (CADeviceSupportsAPT::supports_apt && !CADeviceDisableMinimumFrameDuration())
    {
      int v4 = 0;
      int v8 = -1073741824;
      double v7 = 0.014;
    }
  }
  int v10 = v8 | 0x20;
  if (!v4) {
    int v10 = v8;
  }
  unsigned int v11 = v10 | a1[4].var0 & 1;
  if (!(v10 & 1 | a1[4].var0 & 1))
  {
    int v12 = v10 | 1;
    if (!CA::Render::fourcc_has_alpha((CA::Render *)*(unsigned int *)(v6 + 12))) {
      unsigned int v11 = v12;
    }
  }
  char v13 = image_queue_rotation_from_logical_rotation(CAMetalLayerRotation,BOOL)::invert_table[*(_DWORD *)(v6 + 16) & 7];
  int var3 = a1[2].var3;
  uint64_t v15 = *(void *)(v6 + 24);
  var5 = a1[2].var5;
  double v17 = *(double *)(v6 + 32);
  long long v23 = xmmword_184998040;
  if (CAImageQueueInsertImage_((uint64_t)var3, 3, v15, v11, v13, &v23, (uint64_t)release_sample, v6, v7, *(double *)&var5, v17, 0.0, 0.0))
  {
    a1[3].var2 = (void *)v6;
    if ((v11 & 2) != 0)
    {
      atomic_fetch_and((atomic_uint *volatile)&a1[2].var1, 0xFFFFFFFB);
    }
    else if ((v11 & 4) != 0)
    {
      atomic_fetch_or((atomic_uint *volatile)&a1[2].var1, 4u);
      os_unfair_lock_unlock(p_var2);
      int v18 = (CA::Transaction *)+[CATransaction lock];
      if (v4) {
        int v18 = (CA::Transaction *)+[CATransaction setLowLatency:1];
      }
      if (*(double *)&a1[2].var5 != 0.0) {
        int v18 = (CA::Transaction *)+[CATransaction setInputTime:](CATransaction, "setInputTime:");
      }
      int var4 = (CA::Layer **)a1[2].var4;
      if (var4)
      {
        int v20 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
        if (!v20) {
          int v20 = (CA::Transaction *)CA::Transaction::create(v18);
        }
        CA::Layer::set_commit_needed(var4[2], v20, 0);
      }
      +[CATransaction unlock];
      goto LABEL_43;
    }
  }
  else
  {
    unsigned int v21 = pthread_setspecific(collect_slot, a1);
    release_sample(v21, v22, (CAEAGLBuffer *)v6);
    pthread_setspecific(collect_slot, 0);
  }
  os_unfair_lock_unlock(p_var2);
LABEL_43:
  a1[2].var5 = 0;
  return 1;
}

void sub_1848A5E60(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void release_sample(unsigned int a1, unint64_t a2, CAEAGLBuffer *a3)
{
  if (atomic_fetch_add((atomic_uint *volatile)a3, 0xFFFFFFFF) == 1)
  {
    int v4 = (_CAEAGLNativeWindow *)pthread_getspecific(collect_slot);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*((void *)v4 + 15) > *((void *)v4 + 31)
        && (*((_DWORD *)v4 + 33) & 8) != 0
        && *((_DWORD *)v4 + 28) - *((_DWORD *)a3 + 5) >= 1)
      {
        release_buffer(v4, a3);
      }
      else
      {
        uint64_t v6 = *((void *)v4 + 22);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        int v8 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
        *int v8 = a3;
        v8[1] = v6;
        *((void *)v5 + 22) = v8;
      }
    }
    else if (a3)
    {
      double v9 = (const void *)*((void *)a3 + 5);
      if (v9) {
        CFRelease(v9);
      }
      free(a3);
    }
  }
}

void native_window_detach(_EAGLNativeWindowObject *a1)
{
  p_var2 = (os_unfair_lock_s *)&a1[2].var2;
  os_unfair_lock_lock((os_unfair_lock_t)&a1[2].var2);
  if ((a1[2].var1 & 2) != 0)
  {
    uint64_t v3 = *(atomic_uint **)&a1[3].var0;
    if (v3)
    {
      if (atomic_fetch_add(v3, 0xFFFFFFFF) == 1)
      {
        var7 = a1[2].var7;
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        uint64_t v6 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
        *uint64_t v6 = v3;
        v6[1] = var7;
        a1[2].var7 = v6;
      }
      *(void *)&a1[3].var0 = 0;
    }
    var5 = (atomic_uint *)a1[3].var5;
    if (var5)
    {
      if (atomic_fetch_add(var5, 0xFFFFFFFF) == 1)
      {
        int v8 = a1[2].var7;
        double v9 = (malloc_zone_t *)get_malloc_zone();
        int v10 = malloc_type_zone_malloc(v9, 0x10uLL, 0x8BB15036uLL);
        *int v10 = var5;
        v10[1] = v8;
        a1[2].var7 = v10;
      }
      a1[3].var5 = 0;
    }
    atomic_fetch_and((atomic_uint *volatile)&a1[2].var1, 0xFFFFFFFC);
    a1[3].int var3 = 0;
    LODWORD(a1[2].var8) = 0;
    a1[3].var5 = 0;
    a1[1].var2 = 0;
    a1[1].int var3 = 0;
    *(void *)&a1[1].var0 = 0;
    var6 = a1[1].var6;
    if (var6)
    {
      do
      {
        int v12 = (void *)var6[1];
        free(var6);
        var6 = v12;
      }
      while (v12);
    }
    a1[1].var6 = 0;
    a1[1].int var8 = 0;
    native_window_collect_(a1, 1);
    os_unfair_lock_unlock(p_var2);
    native_window_release((_CAEAGLNativeWindow *)a1, v13);
  }
  else
  {
    os_unfair_lock_unlock(p_var2);
  }
}

void sub_1848A60AC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t native_window_attach(uint64_t a1, int a2, _OWORD *a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 136);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 136));
  if ((*(_DWORD *)(a1 + 132) & 2) != 0) {
    goto LABEL_6;
  }
  double v7 = *(void **)(a1 + 152);
  if (!v7) {
    goto LABEL_6;
  }
  [v7 bounds];
  double v9 = v8;
  double v11 = v10;
  [*(id *)(a1 + 152) contentsScale];
  atomic_fetch_or((atomic_uint *volatile)(a1 + 132), 2u);
  uint32_t v13 = (v12 * v9);
  uint32_t v14 = (v12 * v11);
  *(_DWORD *)(a1 + 208) = v13;
  *(_DWORD *)(a1 + 212) = v14;
  CAImageQueueSetSize(*(os_unfair_lock_s **)(a1 + 144), v13, v14);
  *(_DWORD *)(a1 + 184) = a2;
  if (a3)
  {
    *(_OWORD *)(a1 + 64) = *a3;
    *(_OWORD *)(a1 + 80) = a3[1];
  }
  if ((*(_DWORD *)(a1 + 132) & 2) != 0)
  {
    double v17 = (atomic_uint *)(a1 + 128);
    uint64_t v15 = 1;
    atomic_fetch_add(v17, 1u);
  }
  else
  {
LABEL_6:
    uint64_t v15 = 0;
  }
  os_unfair_lock_unlock(v6);
  return v15;
}

void sub_1848A6190(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t __CADisplayTimerGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CADisplayTimerGetTypeID::type = result;
  return result;
}

CFStringRef displayTimerCopyDebugDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CADisplayTimer %p>", a1);
}

CFStringRef displayTimerCopyFormatDescription(const void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, @"<CADisplayTimer %p>", a1);
}

double *CA::Render::BackdropLayer::set_property(double *this, uint64_t a2, const unsigned int *a3, const unsigned int *a4, unint64_t a5, double *a6, const double *a7)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return this;
  }
  double v7 = this;
  if (a2 != 1)
  {
    if (*a3 != 53) {
      return this;
    }
    float64x2_t v11 = *(float64x2_t *)(this + 8);
    long long v18 = *((_OWORD *)this + 3);
    float64x2_t v19 = v11;
    this = CA::Render::set_rect_property((double *)&v18, (Rect *)(a2 - 1), (int *)a3 + 1, a4, a5, a6, a7);
    long long v12 = v18;
    float64x2_t v13 = v19;
    goto LABEL_12;
  }
  int v8 = *a3;
  if (*(int *)a3 > 374)
  {
    if (v8 == 375)
    {
      if (a5)
      {
        float v16 = *a6;
        *((float *)this + 9) = v16;
      }
    }
    else if (v8 == 486)
    {
      if (a5)
      {
        float v17 = *a6;
        *((float *)this + 8) = v17;
      }
    }
    else if (v8 == 616 && a5)
    {
      float v14 = *a6;
      *((float *)this + 10) = v14;
    }
    return this;
  }
  if (v8 == 53)
  {
    if (a5 < 4) {
      return this;
    }
    long long v12 = *(_OWORD *)a6;
    float64x2_t v13 = vsubq_f64(*(float64x2_t *)(a6 + 2), *(float64x2_t *)a6);
LABEL_12:
    *((_OWORD *)v7 + 3) = v12;
    *((float64x2_t *)v7 + 4) = v13;
    return this;
  }
  if (v8 == 82)
  {
    if (!a5) {
      return this;
    }
    int v15 = *((_DWORD *)this + 3);
    if (*a6 == 0.0) {
      unsigned int v10 = v15 & 0xFFFFEFFF;
    }
    else {
      unsigned int v10 = v15 | 0x1000;
    }
    goto LABEL_29;
  }
  if (v8 == 212 && a5)
  {
    int v9 = *((_DWORD *)this + 3);
    if (*a6 <= 0.5) {
      unsigned int v10 = v9 & 0xFFFFFEFF;
    }
    else {
      unsigned int v10 = v9 | 0x100;
    }
LABEL_29:
    *((_DWORD *)this + 3) = v10;
  }
  return this;
}

uint64_t CA::Render::BackdropLayer::get_property(CA::Render::BackdropLayer *this, uint64_t a2, const unsigned int *a3, unint64_t a4, double *a5, double **a6)
{
  if (a4 >= 4)
  {
    if (a6) {
      *a6 = a5;
    }
    if (!a2) {
      return a2;
    }
    if (a2 == 1)
    {
      a2 = 0;
      int v6 = *a3;
      if (*(int *)a3 > 374)
      {
        switch(v6)
        {
          case 375:
            float v9 = *((float *)this + 9);
            break;
          case 486:
            float v9 = *((float *)this + 8);
            break;
          case 616:
            float v9 = *((float *)this + 10);
            break;
          default:
            return a2;
        }
        double v12 = v9;
      }
      else
      {
        switch(v6)
        {
          case 53:
            double v10 = *((double *)this + 6);
            *a5 = v10;
            double v11 = *((double *)this + 7);
            a5[1] = v11;
            a5[2] = *((double *)this + 8) + v10;
            a5[3] = *((double *)this + 9) + v11;
            return 4;
          case 82:
            BOOL v7 = (*((_DWORD *)this + 3) & 0x1000) == 0;
            break;
          case 212:
            BOOL v7 = (*((_DWORD *)this + 3) & 0x100) == 0;
            break;
          default:
            return a2;
        }
        double v12 = 0.0;
        if (!v7) {
          double v12 = 1.0;
        }
      }
      *a5 = v12;
      return 1;
    }
    if (*a3 == 53) {
      return CA::Render::get_rect_property((CA::Render::BackdropLayer *)((char *)this + 48), (const CA::Rect *)(a2 - 1), (int *)a3 + 1, (unsigned int *)a5, a5);
    }
  }
  return 0;
}

void CA::Render::BackdropLayer::show(CA::Render::BackdropLayer *this, int a2, char a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  BOOL v6 = x_log_hook_p();
  if ((a3 & 1) == 0)
  {
    if (v6)
    {
      x_log_();
    }
    else
    {
      BOOL v7 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = *((void *)this + 2);
        *(_DWORD *)buf = 134217984;
        *(void *)long long v43 = v8;
        _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_DEFAULT, "(backdrop-layer %ld", buf, 0xCu);
      }
    }
    if ((*((unsigned char *)this + 13) & 1) == 0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        float v9 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184668000, v9, OS_LOG_TYPE_DEFAULT, "(enabled false)", buf, 2u);
        }
      }
    }
    if (*((void *)this + 3))
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        double v10 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = *((void *)this + 3) + 28;
          *(_DWORD *)buf = 136315138;
          *(void *)long long v43 = v11;
          _os_log_impl(&dword_184668000, v10, OS_LOG_TYPE_DEFAULT, "(group \"%s\")", buf, 0xCu);
        }
      }
    }
    if (*((unsigned char *)this + 80))
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      int v12 = *((unsigned __int8 *)this + 80);
      BOOL v13 = x_log_hook_p();
      if (v12 == 2)
      {
        if (v13) {
          goto LABEL_21;
        }
        float v14 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          int v15 = "(groupNamespace global)";
LABEL_26:
          _os_log_impl(&dword_184668000, v14, OS_LOG_TYPE_DEFAULT, v15, buf, 2u);
        }
      }
      else
      {
        if (v13)
        {
LABEL_21:
          x_log_();
          goto LABEL_27;
        }
        float v14 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          int v15 = "(groupNamespace hostingNamespacedContext)";
          goto LABEL_26;
        }
      }
    }
LABEL_27:
    if (*((float *)this + 8) != 1.0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        float v16 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          double v17 = *((float *)this + 8);
          *(_DWORD *)buf = 134217984;
          *(double *)long long v43 = v17;
          _os_log_impl(&dword_184668000, v16, OS_LOG_TYPE_DEFAULT, "(scale %g)", buf, 0xCu);
        }
      }
    }
    if (*((float *)this + 10) != 0.0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        long long v18 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          double v19 = *((float *)this + 10);
          *(_DWORD *)buf = 134217984;
          *(double *)long long v43 = v19;
          _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_DEFAULT, "(zoom %g)", buf, 0xCu);
        }
      }
    }
    if (*((float *)this + 9) != 0.0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v20 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          double v21 = *((float *)this + 9);
          *(_DWORD *)buf = 134217984;
          *(double *)long long v43 = v21;
          _os_log_impl(&dword_184668000, v20, OS_LOG_TYPE_DEFAULT, "(marginWidth %g)", buf, 0xCu);
        }
      }
    }
    double v22 = *((double *)this + 8);
    if (v22 >= *((double *)this + 9)) {
      double v22 = *((double *)this + 9);
    }
    if (v22 > 0.0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        long long v23 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v24 = *((void *)this + 6);
          uint64_t v25 = *((void *)this + 7);
          uint64_t v26 = *((void *)this + 8);
          uint64_t v27 = *((void *)this + 9);
          *(_DWORD *)buf = 134218752;
          *(void *)long long v43 = v24;
          *(_WORD *)&v43[8] = 2048;
          *(void *)int v44 = v25;
          *(_WORD *)&v44[8] = 2048;
          uint64_t v45 = v26;
          __int16 v46 = 2048;
          uint64_t v47 = v27;
          _os_log_impl(&dword_184668000, v23, OS_LOG_TYPE_DEFAULT, "(backdropRect [%g %g; %g %g])", buf, 0x2Au);
        }
      }
    }
    if ((*((unsigned char *)this + 13) & 0x10) != 0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        double v28 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184668000, v28, OS_LOG_TYPE_DEFAULT, "(captureOnly true)", buf, 2u);
        }
      }
    }
    if ((*((unsigned char *)this + 13) & 2) != 0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v29 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184668000, v29, OS_LOG_TYPE_DEFAULT, "(allowsInPlaceFiltering true)", buf, 2u);
        }
      }
    }
    if ((*((unsigned char *)this + 13) & 0x20) != 0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        float v30 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184668000, v30, OS_LOG_TYPE_DEFAULT, "(reducesCaptureBitDepth true)", buf, 2u);
        }
      }
    }
    if (*((unsigned char *)this + 14))
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v31 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184668000, v31, OS_LOG_TYPE_DEFAULT, "(ignoresScreenClip true)", buf, 2u);
        }
      }
    }
    if ((*((unsigned char *)this + 14) & 2) != 0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v32 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184668000, v32, OS_LOG_TYPE_DEFAULT, "(preallocatesScreenArea true)", buf, 2u);
        }
      }
    }
    if ((*((unsigned char *)this + 13) & 4) != 0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int v33 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184668000, v33, OS_LOG_TYPE_DEFAULT, "(tracksLuma true)", buf, 2u);
        }
      }
    }
    uint64_t v34 = *((void *)this + 11);
    if (v34)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v34 + 36));
      uint64_t v35 = *(void *)(v34 + 40);
      if (v35)
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v35 + 40));
        uint64_t v36 = *(void *)(v35 + 48);
        if (v36)
        {
          uint64_t v41 = 0;
          float v40 = 0.0;
          (*(void (**)(uint64_t, char *, uint64_t *, float *))(*(void *)v36 + 24))(v36, (char *)&v41 + 4, &v41, &v40);
          CA::Render::show_newline((CA::Render *)(a2 + 1));
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            unint64_t v37 = x_log_category_render;
            if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109632;
              *(_DWORD *)long long v43 = HIDWORD(v41);
              *(_WORD *)&v43[4] = 1024;
              *(_DWORD *)&v43[6] = v41;
              *(_WORD *)int v44 = 2048;
              *(double *)&v44[2] = v40;
              _os_log_impl(&dword_184668000, v37, OS_LOG_TYPE_DEFAULT, "(buffer [%d x %d] scale %g)", buf, 0x18u);
            }
          }
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(v35 + 40));
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v34 + 36));
    }
    if (x_log_hook_p())
    {
      x_log_();
      return;
    }
    uint64_t v38 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      uint64_t v39 = ")";
LABEL_92:
      _os_log_impl(&dword_184668000, v38, OS_LOG_TYPE_DEFAULT, v39, buf, 2u);
      return;
    }
    return;
  }
  if (v6)
  {
    x_log_();
  }
  else
  {
    uint64_t v38 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      uint64_t v39 = "backdrop-layer";
      goto LABEL_92;
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xCF3CF3CF3CF3CF3DLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(_DWORD *)(*(void *)(a2 - 160) + 112) < *(_DWORD *)(*(void *)(a1 + 8) + 112))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)a1, (long long *)(a2 - 168));
        return 1;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, a1 + 168, a2 - 168);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, a1 + 168, a1 + 336, a2 - 168);
      return 1;
    case 5uLL:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *,0>(a1, a1 + 168, a1 + 336, a1 + 504, a2 - 168);
      return 1;
    default:
      uint64_t v6 = a1 + 336;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, a1 + 168, a1 + 336);
      uint64_t v7 = a1 + 504;
      if (a1 + 504 == a2) {
        return 1;
      }
      uint64_t v8 = 0;
      int v9 = 0;
      break;
  }
  while (1)
  {
    uint64_t v10 = *(void *)(v7 + 8);
    if (*(_DWORD *)(v10 + 112) < *(_DWORD *)(*(void *)(v6 + 8) + 112))
    {
      uint64_t v11 = *(void *)v7;
      long long v12 = *(_OWORD *)(v7 + 16);
      long long v13 = *(_OWORD *)(v7 + 32);
      long long v14 = *(_OWORD *)(v7 + 48);
      long long v15 = *(_OWORD *)(v7 + 64);
      long long v16 = *(_OWORD *)(v7 + 80);
      long long v17 = *(_OWORD *)(v7 + 96);
      long long v30 = *(_OWORD *)(v7 + 112);
      long long v31 = *(_OWORD *)(v7 + 128);
      uint64_t v33 = *(void *)(v7 + 160);
      uint64_t v18 = v8;
      long long v32 = *(_OWORD *)(v7 + 144);
      while (1)
      {
        uint64_t v19 = v18;
        uint64_t v20 = a1 + v18;
        long long v21 = *(_OWORD *)(v20 + 352);
        *(_OWORD *)(v20 + 504) = *(_OWORD *)(v20 + 336);
        *(_OWORD *)(v20 + 520) = v21;
        long long v22 = *(_OWORD *)(v20 + 384);
        *(_OWORD *)(v20 + 536) = *(_OWORD *)(v20 + 368);
        *(_OWORD *)(v20 + 552) = v22;
        long long v23 = *(_OWORD *)(v20 + 416);
        *(_OWORD *)(v20 + 568) = *(_OWORD *)(v20 + 400);
        *(_OWORD *)(v20 + 584) = v23;
        long long v24 = *(_OWORD *)(v20 + 448);
        *(_OWORD *)(v20 + 600) = *(_OWORD *)(v20 + 432);
        long long v25 = *(_OWORD *)(v20 + 464);
        long long v26 = *(_OWORD *)(v20 + 480);
        *(void *)(v20 + 664) = *(void *)(v20 + 496);
        *(_OWORD *)(v20 + 632) = v25;
        *(_OWORD *)(v20 + 648) = v26;
        *(_OWORD *)(v20 + 616) = v24;
        if (v19 == -336) {
          break;
        }
        unsigned int v27 = *(_DWORD *)(*(void *)(v20 + 176) + 112);
        uint64_t v18 = v19 - 168;
        if (*(_DWORD *)(v10 + 112) >= v27)
        {
          uint64_t v28 = a1 + v18 + 504;
          uint64_t v29 = a1 + v19 + 448;
          goto LABEL_12;
        }
      }
      uint64_t v29 = v20 + 448;
      uint64_t v28 = a1;
LABEL_12:
      *(void *)uint64_t v28 = v11;
      *(void *)(v28 + 8) = v10;
      *(_OWORD *)(v28 + 16) = v12;
      *(_OWORD *)(v28 + 32) = v13;
      *(_OWORD *)(v28 + 48) = v14;
      *(_OWORD *)(v28 + 64) = v15;
      *(_OWORD *)(v28 + 80) = v16;
      *(_OWORD *)(v28 + 96) = v17;
      *(_OWORD *)uint64_t v29 = v30;
      *(_OWORD *)(v29 + 16) = v31;
      *(_OWORD *)(v29 + 32) = v32;
      ++v9;
      *(void *)(v29 + 48) = v33;
      if (v9 == 8) {
        return v7 + 168 == a2;
      }
    }
    uint64_t v6 = v7;
    v8 += 168;
    v7 += 168;
    if (v7 == a2) {
      return 1;
    }
  }
}

void CA::Render::Transition::show(CA::Render::Transition *this, int a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if ((a3 & 1) == 0)
  {
    if (x_log_hook_p())
    {
      [(__CFString *)CAAtomGetString(*((_DWORD *)this + 4)) cStringUsingEncoding:4];
      x_log_();
    }
    else
    {
      uint64_t v6 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = [(__CFString *)CAAtomGetString(*((_DWORD *)this + 4)) cStringUsingEncoding:4];
        *(_DWORD *)buf = 136315138;
        uint64_t v11 = v7;
        _os_log_impl(&dword_184668000, v6, OS_LOG_TYPE_DEFAULT, "(transition %s", buf, 0xCu);
      }
    }
    if (*((void *)this + 5))
    {
      uint64_t v8 = (CA::Render *)(a2 + 1);
      CA::Render::show_newline(v8);
      (*(void (**)(void, CA::Render *, uint64_t))(**((void **)this + 5) + 40))(*((void *)this + 5), v8, a3);
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      int v9 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_184668000, v9, OS_LOG_TYPE_DEFAULT, ")", buf, 2u);
      }
    }
  }
}

uint64_t CA::Render::TransitionSubclass::is_ogl_transition(CA::Render::TransitionSubclass *this)
{
  return 0;
}

double CA::Render::TransitionSubclass::ROI(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _OWORD *a6, _OWORD *a7)
{
  double result = 0.0;
  *a7 = 0u;
  a7[1] = 0u;
  *a6 = 0u;
  a6[1] = 0u;
  return result;
}

double CA::Render::TransitionSubclass::DOD@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t CA::Render::BuiltinTransition::implements_apply(CA::Render::BuiltinTransition *this)
{
  return 1;
}

CA::Render::Layer *CA::Render::BuiltinTransition::apply(CA::Render::BuiltinTransition *this, const CA::Render::TransitionAnimation *a2, CA::Render::Layer *a3, int a4, float a5)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  int v8 = *((_DWORD *)a2 + 24);
  int v9 = (atomic_uint *)*((void *)a2 + 16);
  if (a4 != 393 && a4 != 475 && a4 != 452) {
    return 0;
  }
  if (!v8) {
    int v8 = 240;
  }
  double v10 = *((double *)a3 + 10);
  double v11 = a5;
  double v12 = round(v10 * a5);
  double v13 = -v10;
  double v14 = 0.0;
  if ((v8 & 0xFFFFFFFE) != 0xF0)
  {
    double v12 = 0.0;
    double v13 = 0.0;
  }
  if (v8 == 242 || (double v15 = 0.0, v8 == 239))
  {
    double v16 = *((double *)a3 + 11);
    double v14 = round(v16 * v11);
    double v15 = -v16;
  }
  double v17 = v8 == 241 ? -v12 : v12;
  double v18 = v8 == 241 ? -v13 : v13;
  double v19 = v8 == 242 ? -v14 : v14;
  double v20 = v8 == 242 ? -v15 : v15;
  long long v21 = (CA::Render::KeyValueArray *)*((void *)a2 + 15);
  if (v21 && !CA::Render::KeyValueArray::get_int_key(v21, 219, 1))
  {
    float v24 = 1.0;
    float v22 = 1.0;
  }
  else
  {
    float v22 = a5 + a5;
    if (a5 >= 0.5) {
      float v22 = 1.0;
    }
    if (a5 <= 0.5)
    {
      float v24 = 1.0;
    }
    else
    {
      float v23 = 2.0 - v11 * 2.0;
      float v24 = v23;
    }
  }
  double v25 = 0.0;
  if (a4 == 393) {
    double v26 = 0.0;
  }
  else {
    double v26 = v17;
  }
  if (a4 == 393) {
    double v27 = 0.0;
  }
  else {
    double v27 = v19;
  }
  double v28 = v17 + v18;
  if (a4 == 475) {
    double v28 = 0.0;
  }
  else {
    double v25 = v20 + v19;
  }
  uint64_t v29 = CA::Render::layer_apply((atomic_uint *)a3, a2, v22, v28, v25);
  v52.i64[0] = (uint64_t)v29;
  long long v31 = CA::Render::layer_apply(v9, v30, v24, v26, v27);
  v52.i64[1] = (uint64_t)v31;
  if (a4 == 393)
  {
    v52.i64[0] = (uint64_t)v31;
    v52.i64[1] = (uint64_t)v29;
  }
  uint64_t v32 = vaddvq_s64((int64x2_t)vbslq_s8((int8x16_t)vceqzq_s64(v52), (int8x16_t)xmmword_184997E50, (int8x16_t)xmmword_184998290));
  uint64_t v33 = (CA::Render::Array *)v32;
  if (!v32) {
    return 0;
  }
  if (v32 == 1)
  {
    char v34 = 0;
    uint64_t v35 = 0;
    while (1)
    {
      uint64_t v36 = (CA::Render::Layer *)v52.i64[v35];
      if (v36) {
        break;
      }
      char v37 = v34;
      char v34 = 1;
      uint64_t v35 = 1;
      if (v37) {
        goto LABEL_47;
      }
    }
  }
  else
  {
LABEL_47:
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v39 = (CA::Render::Layer *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x98uLL, 0x743898A5uLL);
    uint64_t v36 = v39;
    if (v39)
    {
      *((_DWORD *)v39 + 2) = 1;
      *((_DWORD *)v39 + 3) = 29;
      ++dword_1EB2ADE3C;
      *(void *)uint64_t v39 = &unk_1ED02F440;
      *((void *)v39 + 2) = 0;
      *((void *)v39 + 3) = 0;
      *((_DWORD *)v39 + 8) = 16843007;
      *((_DWORD *)v39 + 9) = *((_DWORD *)v39 + 9) & 0x80000000 | 0xF9F11;
      *((void *)v39 + 5) = *((void *)v39 + 5) & 0xFFFF800000000000 | 0x1030C0004C00;
      *((_OWORD *)v39 + 3) = 0u;
      *((_OWORD *)v39 + 4) = 0u;
      *((_OWORD *)v39 + 5) = 0u;
      *((void *)v39 + 12) = 0;
      *((_OWORD *)v39 + 7) = 0u;
      *((_OWORD *)v39 + 8) = 0u;
      *((void *)v39 + 18) = 0;
    }
    float v40 = CA::Render::Array::new_array(v33, 0, 0, 0);
    uint64_t v41 = v40;
    char v42 = 0;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    do
    {
      char v45 = v42;
      uint64_t v46 = v52.i64[v43];
      if (v46)
      {
        uint64_t v47 = &v40[2 * v44++];
        *((void *)v47 + 3) = v46;
      }
      char v42 = 1;
      uint64_t v43 = 1;
    }
    while ((v45 & 1) == 0);
    uint64_t v48 = (atomic_uint *)*((void *)v36 + 13);
    if (v48 && atomic_fetch_add(v48 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v48 + 16))(v48);
    }
    *((void *)v36 + 13) = v41;
  }
  if (v36 != a3)
  {
    uint64_t v49 = *((void *)a3 + 16);
    if (v49) {
      float v50 = *(CA::Render::Timing **)(v49 + 8);
    }
    else {
      float v50 = 0;
    }
    CA::Render::Layer::set_timing((uint64_t)v36, v50);
  }
  return v36;
}

CA::Render *CA::Render::layer_apply(atomic_uint *this, CA::Render::Layer *a2, float a3, double a4, double a5)
{
  uint64_t v5 = (CA::Render *)this;
  if (this)
  {
    uint64_t v9 = *((void *)this + 16);
    if (v9) {
      BOOL v10 = *(void *)(v9 + 8) == 0;
    }
    else {
      BOOL v10 = 1;
    }
    if (a3 == 1.0 && a4 == 0.0 && a5 == 0.0 && v10)
    {
      if (!atomic_fetch_add(this + 2, 1u))
      {
        uint64_t v5 = 0;
        atomic_fetch_add(this + 2, 0xFFFFFFFF);
      }
    }
    else
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      double v12 = (double *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x98uLL, 0x743898A5uLL);
      if (v12)
      {
        double v13 = v12;
        uint64_t v14 = CA::Render::Layer::Layer((uint64_t)v12, (uint64_t)v5);
        CA::Render::Layer::set_timing(v14, 0);
        unsigned int v16 = 1.0;
        if (a3 != 1.0)
        {
          LOBYTE(v16) = *((unsigned char *)v5 + 32);
          *((unsigned char *)v13 + 32) = (int)(float)((float)((float)v16 * a3) + 0.5);
        }
        if (a4 != 0.0 || a5 != 0.0)
        {
          double v17 = *((double *)v5 + 7) + a5;
          v13[6] = *((double *)v5 + 6) + a4;
          v13[7] = v17;
        }
        int v18 = *((_DWORD *)v13 + 3);
        if ((v18 & 0x1000) != 0 || !CA::Render::Layer::is_containerable((CA::Render::Layer *)v13, v15)) {
          unsigned int v19 = v18 & 0xFFFFF7FF;
        }
        else {
          unsigned int v19 = v18 | 0x800;
        }
        *((_DWORD *)v13 + 3) = v19;
        return (CA::Render *)v13;
      }
      else
      {
        return 0;
      }
    }
  }
  return v5;
}

const void *CAML::ObjCContext::failed_to_load_resource(CAML::ObjCContext *this, const __CFURL *a2)
{
  if ((*((unsigned char *)this + 112) & 4) == 0) {
    return 0;
  }
  uint64_t v5 = (void *)MEMORY[0x185324A30]();
  uint64_t v6 = (const void *)[*((id *)this + 12) CAMLParser:*((void *)this + 10) didFailToLoadResourceFromURL:a2];
  CFAllocatorRef v2 = v6;
  if (v6) {
    CFRetain(v6);
  }
  return v2;
}

void sub_1848A8754(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CAML::ObjCContext::did_load_resource(id *this, const __CFURL *a2, const void *a3)
{
  CAML::Context::did_load_resource((CAML::Context *)this, a2, a3);
  if (a3 && ((_BYTE)this[14] & 2) != 0)
  {
    uint64_t v6 = (void *)MEMORY[0x185324A30]();
    [this[12] CAMLParser:this[10] didLoadResource:a3 fromURL:a2];
  }
}

void sub_1848A87E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const void *CAML::ObjCContext::will_load_resource(CAML::ObjCContext *this, const __CFURL *key)
{
  CFDictionaryRef v4 = (const __CFDictionary *)*((void *)this + 9);
  if (!v4 || (double result = CFDictionaryGetValue(v4, key)) == 0)
  {
    if (*((unsigned char *)this + 112))
    {
      uint64_t v6 = (void *)*((void *)this + 12);
      uint64_t v7 = *((void *)this + 10);
      return (const void *)[v6 CAMLParser:v7 resourceForURL:key];
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void CAML::ObjCContext::end_script(id *this, char *a2, uint64_t a3)
{
  if (!a3)
  {
    CFDictionaryRef v4 = "Null <script> contents";
    goto LABEL_5;
  }
  if (((_BYTE)this[14] & 0x10) == 0)
  {
    CFDictionaryRef v4 = "Delegate does not support <script>.";
LABEL_5:
    CAML::Context::error((CAML::Context *)this, v4);
    return;
  }
  uint64_t v7 = (void *)MEMORY[0x185324A30]();
  int v8 = (void *)[[NSString alloc] initWithBytes:a2 length:a3 encoding:4];
  [this[12] CAMLParser:this[10] evaluateScriptElement:v8 sourceURL:this[3] lineNumber:*(unsigned int *)(*((void *)this[1] + 7) + 52)];
}

void sub_1848A893C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CAML::ObjCContext::start_script(id *this, const char **a2)
{
  v13[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = CAML::Context::parse_src_attribute((CAML::Context *)this, a2);
  if (v3)
  {
    CFDictionaryRef v4 = (char *)v3;
    uint64_t v5 = CAML::Context::push_state((uint64_t)this, 0, 0, 0, 0);
    double v11 = 0;
    if (((_BYTE)this[14] & 0x10) == 0)
    {
      CAML::Context::error((CAML::Context *)this, "Delegate does not support <script>.");
LABEL_15:
      CFRelease(v4);
      return;
    }
    uint64_t v6 = (void *)MEMORY[0x185324A30](v5);
    uint64_t v7 = (void *)[[NSString alloc] initWithContentsOfURL:v4 encoding:4 error:&v11];
    uint64_t v8 = [NSString stringWithFormat:@"Unable to load CAPackage from URL: %@", v4];
    if (v11)
    {
      uint64_t v9 = *MEMORY[0x1E4F28A50];
      v12[0] = *MEMORY[0x1E4F28568];
      v12[1] = v9;
      v13[0] = v8;
      v13[1] = v11;
      BOOL v10 = (const void *)objc_msgSend(MEMORY[0x1E4F28C58], "errorWithDomain:code:userInfo:", @"CoreAnimationErrorDomain", 2, objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v13, v12, 2));
      double v11 = v10;
      if (!v7)
      {
        if (v10)
        {
          CAML::Context::set_error((CAML::Context *)this, v10);
LABEL_14:
          goto LABEL_15;
        }
LABEL_13:
        CAML::Context::error((CAML::Context *)this, "Unable to open script: %s", (const char *)objc_msgSend((id)objc_msgSend(v4, "absoluteString"), "UTF8String"));
        goto LABEL_14;
      }
    }
    else if (!v7)
    {
      goto LABEL_13;
    }
    [this[12] CAMLParser:this[10] evaluateScriptElement:v7 sourceURL:v4 lineNumber:1];

    goto LABEL_14;
  }

  CAML::Context::push_state((uint64_t)this, 7, 0, 0, 0);
}

void sub_1848A8B58(_Unwind_Exception *exception_object)
{
}

void CAML::ObjCContext::errorv(id *this, const char *a2, va_list a3)
{
  CFDictionaryRef v4 = this;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if ((char)this[14] < 0)
  {
    [this[12] CAMLParser:this[10] formatErrorString:a2 arguments:a3 lineNumber:*(int *)(*((void *)this[1] + 7) + 52)];
    goto LABEL_34;
  }
  x_log_begin();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    uint64_t v5 = x_log_category_api;
    if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(_DWORD *)(*((void *)v4[1] + 7) + 52);
      *(_DWORD *)buf = 67109120;
      LODWORD(v22) = v6;
      _os_log_impl(&dword_184668000, v5, OS_LOG_TYPE_DEFAULT, "CAML error:%d: ", buf, 8u);
    }
  }
  x_logv();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    uint64_t v7 = x_log_category_api;
    if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_DEFAULT, "\n", buf, 2u);
    }
  }
  unsigned int v19 = v4;
  int v18 = (void **)x_stream_pop_(0);
  uint64_t v8 = x_stream_get(v18);
  int v9 = 0;
  while (2)
  {
    uint64_t v10 = 0;
    double v11 = &v8[v9];
    int v12 = -1;
    while (1)
    {
      if (v11[v10] == 10)
      {
        int v12 = v10;
        goto LABEL_17;
      }
      if (!v11[v10]) {
        break;
      }
LABEL_17:
      ++v10;
      unsigned int v13 = 32512;
      if (v10 == 32512) {
        goto LABEL_18;
      }
    }
    unsigned int v13 = v10;
LABEL_18:
    if (v12 <= -1 || v11[v13] == 0) {
      int v15 = v13;
    }
    else {
      int v15 = v12 + 1;
    }
    if (v15 > 0)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unsigned int v16 = x_log_category_api;
        if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          if (v9) {
            double v17 = "continued...\n";
          }
          else {
            double v17 = "";
          }
          float v22 = v17;
          __int16 v23 = 1040;
          int v24 = v15;
          __int16 v25 = 2080;
          double v26 = &v8[v9];
          _os_log_impl(&dword_184668000, v16, OS_LOG_TYPE_ERROR, "%s%.*s", buf, 0x1Cu);
        }
      }
      v9 += v15;
      continue;
    }
    break;
  }
  x_log_end_free_(v18);
  CFDictionaryRef v4 = v19;
LABEL_34:
  CAML::Context::errorv((CAML::Context *)v4, a2, a3);
}

uint64_t CA::Render::Server::set_thread_priority(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  int v3 = a2 + 55;
  sched_param v6 = 0;
  int v5 = 0;
  pthread_getschedparam(this, &v5, &v6);
  int v5 = 4;
  v6.sched_priority = v3;
  return pthread_setschedparam(this, 4, &v6);
}

uint64_t CA::Render::Server::port_set_qlimit(uint64_t name)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  mach_msg_type_number_t v4 = 1;
  integer_t port_info_out = 0;
  CFAllocatorRef v2 = (unsigned int *)MEMORY[0x1E4F14960];
  mach_port_get_attributes(*MEMORY[0x1E4F14960], name, 1, &port_info_out, &v4);
  integer_t port_info_out = 3;
  return MEMORY[0x185324720](*v2, name, 1, &port_info_out, 1);
}

uint64_t CA::Render::Server::add_dead_name_watch(CA::Render::Server *this, mach_port_t *a2, unsigned int *a3, BOOL (*a4)(unsigned int))
{
  mach_port_name_t v6 = this;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Server::_dead_name_watch_list_lock);
  CA::Render::Server::dead_name_watch_list(v7);
  unint64_t v8 = *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
  if (*((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1))
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 8));
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = v6;
      if (*((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) <= (unint64_t)v6) {
        unint64_t v10 = (unint64_t)v6 % *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
      }
    }
    else
    {
      unint64_t v10 = (DWORD2(CA::Render::Server::dead_name_watch_list(void)::watch_list) - 1) & v6;
    }
    double v11 = *(void **)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v10);
    if (v11)
    {
      int v12 = (void *)*v11;
      if (*v11)
      {
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v6)
          {
            if (*((_DWORD *)v12 + 4) == v6) {
              goto LABEL_74;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v13 >= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1)) {
                v13 %= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
              }
            }
            else
            {
              v13 &= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) - 1;
            }
            if (v13 != v10) {
              break;
            }
          }
          int v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
  else
  {
    unint64_t v10 = 0;
  }
  int v12 = operator new(0x20uLL);
  void *v12 = 0;
  v12[1] = v6;
  *((_DWORD *)v12 + 4) = v6;
  v12[3] = 0;
  float v14 = (float)(unint64_t)(qword_1E8F85E30 + 1);
  if (!v8 || (float)(*(float *)&dword_1E8F85E38 * (float)v8) < v14)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v14 / *(float *)&dword_1E8F85E38);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v8 = *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
    }
    if (*(void *)&prime > v8) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v8)
    {
      unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)qword_1E8F85E30 / *(float *)&dword_1E8F85E38);
      if (v8 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v8)
      {
        unint64_t v8 = *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unsigned int v19 = operator new(8 * *(void *)&prime);
          double v20 = (void *)CA::Render::Server::dead_name_watch_list(void)::watch_list;
          *(void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list = v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          *((int8x8_t *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) = prime;
          do
            *(void *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          float v22 = (void **)qword_1E8F85E28;
          if (qword_1E8F85E28)
          {
            unint64_t v23 = *(void *)(qword_1E8F85E28 + 8);
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v23) = &qword_1E8F85E28;
            for (i = *v22; i; unint64_t v23 = v29)
            {
              unint64_t v29 = i[1];
              if (v24.u32[0] > 1uLL)
              {
                if (v29 >= *(void *)&prime) {
                  v29 %= *(void *)&prime;
                }
              }
              else
              {
                v29 &= *(void *)&prime - 1;
              }
              if (v29 != v23)
              {
                if (!*(void *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v29))
                {
                  *(void *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v29) = v22;
                  goto LABEL_55;
                }
                *float v22 = (void *)*i;
                *uint64_t i = **(void **)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v29);
                **(void **)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v29) = i;
                uint64_t i = v22;
              }
              unint64_t v29 = v23;
LABEL_55:
              float v22 = (void **)i;
              uint64_t i = (void *)*i;
            }
          }
          unint64_t v8 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v38 = (void *)CA::Render::Server::dead_name_watch_list(void)::watch_list;
        *(void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list = 0;
        if (v38) {
          operator delete(v38);
        }
        unint64_t v8 = 0;
        *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) = 0;
      }
    }
LABEL_59:
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v6) {
        unint64_t v10 = v6 % v8;
      }
      else {
        unint64_t v10 = v6;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & v6;
    }
  }
  uint64_t v30 = CA::Render::Server::dead_name_watch_list(void)::watch_list;
  long long v31 = *(void **)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v10);
  if (v31)
  {
    void *v12 = *v31;
LABEL_72:
    void *v31 = v12;
    goto LABEL_73;
  }
  uint64_t v32 = qword_1E8F85E28;
  void *v12 = qword_1E8F85E28;
  qword_1E8F85E28 = (uint64_t)v12;
  *(void *)(v30 + 8 * v10) = &qword_1E8F85E28;
  if (v32)
  {
    unint64_t v33 = *(void *)(v32 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v33 >= v8) {
        v33 %= v8;
      }
    }
    else
    {
      v33 &= v8 - 1;
    }
    long long v31 = (void *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v33);
    goto LABEL_72;
  }
LABEL_73:
  ++qword_1E8F85E30;
LABEL_74:
  v12[3] = a3;
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_dead_name_watch_list_lock);
  ipc_space_t v34 = *MEMORY[0x1E4F14960];
  mach_port_t v36 = CA::Render::Server::notify_port(v35);

  return mach_port_request_notification(v34, v6, 72, 0, v36, 0x15u, a2);
}

void CA::Render::Server::remove_dead_name_watch(CA::Render::Server *this)
{
  unsigned int v1 = this;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Server::_dead_name_watch_list_lock);
  CA::Render::Server::dead_name_watch_list(v2);
  int v3 = std::__hash_table<std::__hash_value_type<unsigned int,BOOL (*)>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,BOOL (*)>>>::find<unsigned int>(v1);
  if (v3) {
    std::__hash_table<std::__hash_value_type<unsigned int,BOOL (*)>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,BOOL (*)>>>::erase(v3);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_dead_name_watch_list_lock);
}

void std::__hash_table<std::__hash_value_type<unsigned int,BOOL (*)(unsigned int)>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)(unsigned int)>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)(unsigned int)>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,BOOL (*)(unsigned int)>>>::erase(void *__p)
{
  unint64_t v1 = *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
  unint64_t v2 = *((void *)__p + 1);
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 8));
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    if (v2 >= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1)) {
      v2 %= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
    }
  }
  else
  {
    v2 &= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) - 1;
  }
  mach_msg_type_number_t v4 = *(uint64_t **)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v2);
  do
  {
    int v5 = v4;
    mach_msg_type_number_t v4 = (uint64_t *)*v4;
  }
  while (v4 != __p);
  if (v5 == &qword_1E8F85E28) {
    goto LABEL_18;
  }
  unint64_t v6 = v5[1];
  if (v3.u32[0] > 1uLL)
  {
    if (v6 >= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1)) {
      v6 %= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
    }
  }
  else
  {
    v6 &= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) - 1;
  }
  if (v6 != v2)
  {
LABEL_18:
    if (!*(void *)__p) {
      goto LABEL_19;
    }
    unint64_t v7 = *(void *)(*(void *)__p + 8);
    if (v3.u32[0] > 1uLL)
    {
      if (v7 >= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1)) {
        v7 %= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
      }
    }
    else
    {
      v7 &= *((void *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) - 1;
    }
    if (v7 != v2) {
LABEL_19:
    }
      *(void *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v2) = 0;
  }
  uint64_t v8 = *(void *)__p;
  if (*(void *)__p)
  {
    unint64_t v9 = *(void *)(v8 + 8);
    if (v3.u32[0] > 1uLL)
    {
      if (v9 >= v1) {
        v9 %= v1;
      }
    }
    else
    {
      v9 &= v1 - 1;
    }
    if (v9 != v2)
    {
      *(void *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v9) = v5;
      uint64_t v8 = *(void *)__p;
    }
  }
  uint64_t *v5 = v8;
  *(void *)__p = 0;
  --qword_1E8F85E30;
  operator delete(__p);
}

BOOL CA::Render::Server::register_name(CA::Render::Server *this, const char *a2)
{
  kern_return_t v4;
  BOOL v5;
  kern_return_t v6;
  NSObject *v7;
  CA::Render::Server *v8;
  ipc_space_t v9;
  mach_port_t v10;
  mach_port_name_t v11;
  uint64_t v12;
  uint64_t v13;
  malloc_zone_t *malloc_zone;
  void *v15;
  NSObject *v16;
  mach_port_t sp;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  kern_return_t v22;
  uint64_t v23;

  unint64_t v23 = *MEMORY[0x1E4F143B8];
  if (this) {
    unint64_t v2 = (const char *)this;
  }
  else {
    unint64_t v2 = "com.apple.CARenderServer";
  }
  mach_port_t v3 = *MEMORY[0x1E4F14638];
  if ((*MEMORY[0x1E4F14638] - 1) >= 0xFFFFFFFE)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      unint64_t v7 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_ERROR, "unable to find bootstrap server", buf, 2u);
      }
    }
    return 0;
  }
  else
  {
    sp = 0;
    mach_msg_type_number_t v4 = bootstrap_check_in(v3, v2, &sp);
    int v5 = v4 == 0;
    if (v4)
    {
      unint64_t v6 = v4;
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unint64_t v16 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          double v20 = v2;
          uint64_t v21 = 1024;
          float v22 = v6;
          _os_log_impl(&dword_184668000, v16, OS_LOG_TYPE_ERROR, "unable to register bootstrap port %s: %x\n", buf, 0x12u);
        }
      }
    }
    else
    {
      uint64_t v8 = (CA::Render::Server *)CA::Render::Server::port_set_qlimit(sp);
      unint64_t v9 = *MEMORY[0x1E4F14960];
      unint64_t v10 = sp;
      double v11 = CA::Render::Server::port_set(v8);
      mach_port_move_member(v9, v10, v11);
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Server::_checked_in_lock);
      int v12 = CA::Render::Server::_checked_in_ports;
      unint64_t v13 = sp;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      BOOL v15 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
      *BOOL v15 = v13;
      v15[1] = v12;
      CA::Render::Server::_checked_in_ports = (uint64_t)v15;
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_checked_in_lock);
    }
  }
  return v5;
}

BOOL CA::Render::Server::start(CA::Render::Server *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (CA::Render::memory_once[0] != -1) {
    dispatch_once_f(CA::Render::memory_once, 0, (dispatch_function_t)CA::Render::init_memory_warnings_);
  }
  pthread_mutex_lock(&CA::Render::Server::_mutex);
  uint64_t v1 = CA::Render::Server::_thread;
  if (!CA::Render::Server::_thread)
  {
    char v5 = 0;
    unint64_t v2 = x_thread_create((uint64_t)CA::Render::Server::server_thread, (uint64_t)&v5, 1);
    if (v2)
    {
      CA::Render::Server::set_thread_priority(v2, 0);
      while (!v5)
        pthread_cond_wait(&CA::Render::Server::_cond, &CA::Render::Server::_mutex);
    }
    uint64_t v1 = CA::Render::Server::_thread;
  }
  BOOL v3 = v1 != 0;
  pthread_mutex_unlock(&CA::Render::Server::_mutex);
  return v3;
}

void CA::Render::Server::ca_mach_msg_error_f(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_e(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_d(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_c(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_b(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_a(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_9(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_8(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_7(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_6(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_5(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_4(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_3(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_2(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_1(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_0(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

uint64_t CA::Render::Server::release_vm(mach_vm_address_t address, mach_vm_size_t size, void *a3)
{
  return mach_vm_deallocate(*MEMORY[0x1E4F14960], address, size);
}

void CA::Render::Server::stop(CA::Render::Server *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  CA::Render::Server::kick_server(this);
  if (CA::Render::Server::_server_port)
  {
    MEMORY[0x1F4188790](v1);
    uint64_t v3 = 0x1C00000013;
    int v4 = v2;
    long long v5 = xmmword_1849982B0;
    mach_msg((mach_msg_header_t *)&v3, 1, 0x1Cu, 0, 0, 0, 0);
    pthread_mutex_lock(&CA::Render::Server::_mutex);
    while (CA::Render::Server::_thread)
      pthread_cond_wait(&CA::Render::Server::_cond, &CA::Render::Server::_mutex);
    pthread_mutex_unlock(&CA::Render::Server::_mutex);
  }
}

dispatch_queue_t ___Z13dealloc_queuev_block_invoke()
{
  v0 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  dispatch_queue_t result = dispatch_queue_create("CA::Render::DeallocQueue", v0);
  dealloc_queue(void)::queue = (uint64_t)result;
  return result;
}

uint64_t CASGetClientProcessId(CA::Render::Context *a1, audit_token_t *a2, CA::Render::Server *this)
{
  uint64_t v6 = 4213784577;
  a2->val[0] = 0;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v7) & 0x20000) == 0)
  {
    uint64_t v8 = CA::Render::Context::context_by_client_port(a1);
    if (v8)
    {
      unint64_t v9 = (atomic_uint *)v8;
      unsigned int v10 = atomic_load((unsigned int *)(v8 + 228));
      if (!v10)
      {
        unsigned int v11 = *(_DWORD *)(v8 + 252) ? 0 : getpid();
        unsigned int v10 = 0;
        atomic_compare_exchange_strong(v9 + 57, &v10, v11);
        if (!v10) {
          unsigned int v10 = v11;
        }
      }
      a2->val[0] = v10;
      if (atomic_fetch_add(v9 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v9 + 16))(v9);
      }
      uint64_t v6 = 0;
    }
    else
    {
      uint64_t v6 = 56;
    }
  }
  if (a1) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], (mach_port_name_t)a1);
  }
  return v6;
}

uint64_t CASSetMessageFile(const char *a1, CA::Render::Server *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, (const audit_token_t *)this) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v5) & 0x20000) == 0)
  {
    if ((CA::Render::Server::audit_token_cache_lookup(this, v6) & 0x100) != 0)
    {
      memset(v8, 0, sizeof(v8));
      strlcpy((char *)v8, a1, 0x100uLL);
      return 0;
    }
    else
    {
      return 53;
    }
  }
  return v4;
}

uint64_t CASSetDebugMessage(const char *a1, const audit_token_t *a2, CA::Render::Server *this)
{
  int v4 = (int)a2;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v7) & 0x20000) == 0)
  {
    if ((CA::Render::Server::audit_token_cache_lookup(this, v8) & 0x100) != 0)
    {
      memset(v10, 0, sizeof(v10));
      strlcpy((char *)v10, a1, 0x100uLL);
      CASetDebugMessage((char *)v10, v4);
      return 0;
    }
    else
    {
      return 53;
    }
  }
  return v6;
}

uint64_t CASSetLUTFile(const char *a1, CA::Render::Server *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, (const audit_token_t *)this) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v5) & 0x20000) == 0)
  {
    if ((CA::Render::Server::audit_token_cache_lookup(this, v6) & 0x100) != 0)
    {
      memset(v8, 0, sizeof(v8));
      strlcpy((char *)v8, a1, 0x100uLL);
      CASetLUTFile((const char *)v8);
      return 0;
    }
    else
    {
      return 53;
    }
  }
  return v4;
}

uint64_t CASRenderDisplaySurface(const char *a1, _anonymous_namespace_ *a2, unsigned int *a3, mach_port_t a4, int a5, int a6, int a7, CA::Mat4Impl *a8, double a9, int a10, unsigned int a11, unint64_t *a12, CA::Render::Server *a13)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v21 = 4213784577;
  mach_vm_size_t v22 = 4 * a3;
  if ((CA::Render::Server::audit_token_cache_lookup(a13, (const audit_token_t *)a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a13, v23) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01
      && (CFStringRef v24 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0])) != 0)
    {
      CFRelease(v24);
      uint64_t v42 = 0;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      unint64_t v25 = IOSurfaceLookupFromMachPort(a4);
      if (v25)
      {
        uint64_t v32 = &unk_1ED02DCF0;
        uint64_t v35 = v25;
        uint8x8_t v26 = v25;
        int Width = IOSurfaceGetWidth(v25);
        int Height = IOSurfaceGetHeight(v26);
        *(void *)&long long v37 = &v32;
        HIDWORD(v40) = a5;
        uint64_t v27 = v26;
        BOOL v28 = IOSurfaceGetProtectionOptions() != 0;
        CFRelease(v27);
      }
      else
      {
        uint64_t v21 = 5;
      }
    }
    else
    {
      uint64_t v21 = 4;
    }
  }
  unint64_t v29 = (ipc_space_t *)MEMORY[0x1E4F14960];
  mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)a2, v22);
  if (a4) {
    mach_port_deallocate(*v29, a4);
  }
  return v21;
}

uint64_t anonymous namespace'::render_display(const char *a1, _anonymous_namespace_ *a2, unsigned int *a3, int a4, int a5, CA::Mat4Impl *this, int a7, BOOL *a8, double a9, unint64_t *a10, _anonymous_namespace_ *a11, uint64_t a12, char a13)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v31 = 0;
  memset(v30, 0, sizeof(v30));
  CA::Transform::set((uint64_t)v30, this, 1);
  if (a13)
  {
    *(_DWORD *)a12 = 0;
    *(unsigned char *)(a12 + 4) = 1;
    char v21 = *(unsigned char *)(a12 + 96) & 0xFB;
  }
  else
  {
    if ((a13 & 2) == 0) {
      *(_DWORD *)(a12 + 68) = 0x10000;
    }
    char v21 = *(unsigned char *)(a12 + 96) | 4;
  }
  *(unsigned char *)(a12 + 96) = v21;
  *(void *)(a12 + 8) = CFStringCreateWithCString(0, a1, 0x8000100u);
  *(_DWORD *)(a12 + 44) = a4;
  *(_DWORD *)(a12 + 48) = a5;
  *(double *)(a12 + 56) = a9;
  *(void *)(a12 + 24) = a3;
  *(void *)(a12 + 32) = a2;
  mach_vm_size_t v22 = v30;
  if (*(double *)v30 == 0.0)
  {
    uint64_t v23 = 1;
    do
    {
      if (v23 == 16) {
        goto LABEL_11;
      }
      uint64_t v24 = v23;
      double v25 = *((double *)v30 + v23++);
    }
    while (v25 == 0.0);
    if ((unint64_t)(v24 - 1) >= 0xF)
    {
LABEL_11:
      mach_vm_size_t v22 = 0;
      goto LABEL_13;
    }
    mach_vm_size_t v22 = v30;
  }
LABEL_13:
  *(_DWORD *)(a12 + 64) = a7;
  *(void *)(a12 + 80) = v22;
  *(void *)(a12 + 88) = 0;
  char v26 = *(unsigned char *)(a12 + 96) & 0xCD;
  *(unsigned char *)(a12 + 7) = ((unsigned __int16)a8 & 0x400) != 0;
  *(unsigned char *)(a12 + 96) = v26 | BYTE1(a8) & 0x10 | (a8 >> 10) & 2;
  if (*(void *)(a12 + 16)) {
    CA::Render::post_notification(0x13u, 0, a12, 0);
  }
  uint64_t v27 = *(const void **)(a12 + 8);
  if (v27) {
    CFRelease(v27);
  }
  char v28 = *(unsigned char *)(a12 + 96);
  if (a10)
  {
    *a10 = *(void *)(a12 + 88) | ((unint64_t)(*(unsigned char *)(a12 + 96) & 0x20) << 58);
    char v28 = *(unsigned char *)(a12 + 96);
  }
  if ((v28 & 0x20) != 0) {
    return 0;
  }
  else {
    return 5;
  }
}

uint64_t anonymous namespace'::check_capture_entitlements(uint64_t this, audit_token_t *a2, int *a3, BOOL *a4, BOOL *a5, BOOL *a6)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    __int16 v6 = (__int16)a6;
    long long v11 = *(_OWORD *)(this + 16);
    long long v15 = *(_OWORD *)this;
    long long v16 = v11;
    a2->val[0] = 0;
    unsigned int v12 = DWORD1(v16);
    if (DWORD1(v16) != getpid()
      && (CA::Render::Server::audit_token_cache_lookup((CA::Render::Server *)&v15, v13) & 1) == 0)
    {
      a2->val[0] = v12;
    }
    if ((CA::Render::Server::audit_token_cache_lookup((CA::Render::Server *)&v15, v13) & 8) != 0)
    {
      *(unsigned char *)a3 = (v6 & 2) == 0;
      *a4 = (v6 & 0x20) != 0;
    }
    this = CA::Render::Server::audit_token_cache_lookup((CA::Render::Server *)&v15, v14);
    if ((this & 0x800) != 0) {
      *a5 = HIBYTE(v6) & 1;
    }
  }
  return this;
}

float anonymous namespace'::get_max_context_level(_anonymous_namespace_ *this, unsigned int *a2)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    int v6 = 2139095040;
    return *(float *)&v6;
  }
  unsigned int v2 = a2;
  size_t v4 = 8 * a2;
  if (a2 <= 0x200)
  {
    MEMORY[0x1F4188790](this);
    long long v5 = (char *)v18 - ((v4 + 15) & 0xFFFFFFFF0);
    bzero(v5, v4);
    goto LABEL_6;
  }
  long long v5 = (char *)malloc_type_malloc(8 * a2, 0xE5FF92F3uLL);
  bzero(v5, v4);
  if (!v5)
  {
    int v6 = -8388608;
    return *(float *)&v6;
  }
LABEL_6:
  uint64_t v7 = 0;
  while (1)
  {
    uint64_t v8 = CA::Render::Context::context_by_id((CA::Render::Context *)*((unsigned int *)this + v7));
    *(void *)&v5[8 * v7] = v8;
    if (!v8) {
      break;
    }
    if (v2 == ++v7) {
      goto LABEL_11;
    }
  }
  if (v7 != v2)
  {
    float v10 = -INFINITY;
    goto LABEL_26;
  }
LABEL_11:
  uint64_t v9 = 0;
  float v10 = -INFINITY;
  do
  {
    long long v11 = *(atomic_uint **)&v5[8 * v9];
    unsigned int v12 = v11 + 2;
    if (!atomic_fetch_add(v11 + 2, 1u))
    {
      long long v11 = 0;
      atomic_fetch_add(v12, 0xFFFFFFFF);
    }
    unint64_t v13 = 0;
    do
    {
      float v14 = v11;
      long long v11 = (atomic_uint *)CA::Render::Context::retain_host_context((CA::Render::Context *)v11);
      if (v13 && atomic_fetch_add(v13 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v13 + 16))(v13);
      }
      unint64_t v13 = v14;
    }
    while (v11);
    if (*((float *)v14 + 48) > v10) {
      float v10 = *((float *)v14 + 48);
    }
    if (atomic_fetch_add(v14 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v14 + 16))(v14);
    }
    ++v9;
  }
  while (v9 != v2);
LABEL_26:
  for (uint64_t i = 0; i != v2; ++i)
  {
    long long v16 = *(atomic_uint **)&v5[8 * i];
    if (v16)
    {
      if (atomic_fetch_add(v16 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v16 + 16))(v16);
      }
      *(void *)&v5[8 * i] = 0;
    }
  }
  if (v2 >= 0x201) {
    free(v5);
  }
  return v10;
}

uint64_t CA::Render::RenderSurface::is_iosurface(CA::Render::RenderSurface *this)
{
  return 1;
}

void CA::Render::RenderSurface::~RenderSurface(CA::Render::RenderSurface *this)
{
}

uint64_t CASRenderDisplayShmem(const char *a1, _anonymous_namespace_ *a2, unsigned int *a3, int a4, int a5, uint64_t a6, mem_entry_name_port_t a7, mach_vm_size_t a8, double a9, int a10, int a11, int a12, CA::Mat4Impl *a13, int a14, unsigned int a15, unint64_t *a16, CA::Render::Server *a17)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = 4213784577;
  mach_vm_size_t v26 = 4 * a3;
  if ((CA::Render::Server::audit_token_cache_lookup(a17, (const audit_token_t *)a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a17, v27) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01)
    {
      CFStringRef v28 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
      if (v28)
      {
        CFRelease(v28);
        uint64_t v45 = 0;
        long long v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        uint64_t v37 = a6;
        ipc_space_t v34 = &unk_1ED022498;
        int v35 = a4;
        int v36 = a5;
        long long v38 = CA::Render::Shmem::new_shmem(a7, a8, 1, a10);
        unint64_t v29 = &v34;
        if (!v38) {
          unint64_t v29 = 0;
        }
        *(void *)&long long v40 = v29;
        ipc_space_t v34 = &unk_1ED022498;
        uint64_t v30 = v38;
        if (v38 && atomic_fetch_add(v38 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(_DWORD *))(*(void *)v30 + 16))(v30);
        }
        mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)a2, v26);
        return v25;
      }
    }
    uint64_t v25 = 4;
  }
  uint64_t v31 = (ipc_space_t *)MEMORY[0x1E4F14960];
  mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)a2, v26);
  if (a7) {
    mach_port_deallocate(*v31, a7);
  }
  return v25;
}

uint64_t CA::Render::RenderTarget::is_iosurface(CA::Render::RenderTarget *this)
{
  return 0;
}

void anonymous namespace'::MIGRenderBuffer::~MIGRenderBuffer(_anonymous_namespace_::MIGRenderBuffer *this)
{
  *(void *)this = &unk_1ED022498;
  uint64_t v1 = (atomic_uint *)*((void *)this + 3);
  if (v1 && atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
  }

  JUMPOUT(0x185323DC0);
}

{
  atomic_uint *v1;

  *(void *)this = &unk_1ED022498;
  uint64_t v1 = (atomic_uint *)*((void *)this + 3);
  if (v1)
  {
    if (atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
    }
  }
}

uint64_t CASRenderDisplayLayerSurface(const char *a1, CA::Render::Context *a2, uint64_t a3, mach_port_t a4, int a5, int a6, CA::Mat4Impl *a7, BOOL *a8, double a9, unint64_t *a10, CA::Render::Server *a11)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v20 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(a11, (const audit_token_t *)a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a11, v21) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01)
    {
      CFStringRef v22 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
      if (v22)
      {
        CFRelease(v22);
        uint64_t v36 = 0;
        long long v34 = 0u;
        long long v35 = 0u;
        long long v33 = 0u;
        memset(v32, 0, sizeof(v32));
        uint64_t v23 = IOSurfaceLookupFromMachPort(a4);
        if (v23)
        {
          uint64_t v31 = v23;
          CFStringRef v28 = &unk_1ED02DCF0;
          uint64_t v24 = v23;
          CFDictionaryRef cf = v23;
          int Width = IOSurfaceGetWidth(v23);
          int Height = IOSurfaceGetHeight(v24);
          *(void *)&long long v33 = &v28;
          BOOL v25 = IOSurfaceGetProtectionOptions() != 0;
          CFRelease(cf);
          if (!a4) {
            return v20;
          }
        }
        else
        {
          uint64_t v20 = 5;
          if (!a4) {
            return v20;
          }
        }
        goto LABEL_10;
      }
    }
    uint64_t v20 = 4;
  }
  if (a4) {
LABEL_10:
  }
    mach_port_deallocate(*MEMORY[0x1E4F14960], a4);
  return v20;
}

uint64_t anonymous namespace'::render_display_layer(const char *a1, CA::Render::Context *this, uint64_t a3, int a4, int a5, CA::Mat4Impl *a6, BOOL *a7, unint64_t *a8, double a9, _anonymous_namespace_ *a10, uint64_t a11, char a12)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v20 = CA::Render::Context::context_by_id(this);
  if (!v20) {
    return 56;
  }
  char v21 = (atomic_uint *)v20;
  uint64_t v29 = 0;
  memset(v28, 0, sizeof(v28));
  CA::Transform::set((uint64_t)v28, a6, 1);
  if (a12)
  {
    *(_DWORD *)a11 = 0;
    *(unsigned char *)(a11 + 4) = 1;
    __int16 v22 = *(_WORD *)(a11 + 80) & 0xFFFE;
  }
  else
  {
    if ((a12 & 2) == 0) {
      *(_DWORD *)(a11 + 56) = 0x10000;
    }
    __int16 v22 = *(_WORD *)(a11 + 80) | 1;
  }
  *(_WORD *)(a11 + 80) = v22;
  CFStringRef v24 = CFStringCreateWithCString(0, a1, 0x8000100u);
  *(void *)(a11 + 16) = v21;
  *(void *)(a11 + 24) = a3;
  *(void *)(a11 + 8) = v24;
  *(_DWORD *)(a11 + 40) = a4;
  *(_DWORD *)(a11 + 44) = a5;
  *(double *)(a11 + 48) = a9;
  *(void *)(a11 + 64) = v28;
  *(void *)(a11 + 72) = 0;
  __int16 v25 = *(_WORD *)(a11 + 80) & 0xFC80;
  *(unsigned char *)(a11 + 7) = ((unsigned __int16)a7 & 0x400) != 0;
  *(_WORD *)(a11 + 80) = (2 * (_WORD)a7) & 0x1A | (a7 >> 4) & 4 | (a7 >> 2) & 0x20 | (a7 >> 4) & 0x100 | (a7 >> 5) & 0x40 | v25 | 1;
  if (*(void *)(a11 + 32))
  {
    CA::Render::post_notification(0x14u, 0, a11, 0);
    CFStringRef v24 = *(CFStringRef *)(a11 + 8);
  }
  if (v24) {
    CFRelease(v24);
  }
  __int16 v26 = *(_WORD *)(a11 + 80);
  if (a8)
  {
    *a8 = *(void *)(a11 + 72) | ((unint64_t)(*(_WORD *)(a11 + 80) & 0x200) << 54);
    __int16 v26 = *(_WORD *)(a11 + 80);
  }
  if ((v26 & 0x200) != 0) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = 5;
  }
  if (atomic_fetch_add(v21 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v21 + 16))(v21);
  }
  return v23;
}

uint64_t CASRenderDisplayLayerShmem(const char *a1, CA::Render::Context *a2, uint64_t a3, int a4, int a5, uint64_t a6, mem_entry_name_port_t a7, mach_vm_size_t a8, double a9, int a10, int a11, int a12, CA::Mat4Impl *a13, unsigned int a14, unint64_t *a15, CA::Render::Server *a16)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(a16, (const audit_token_t *)a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a16, v26) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01)
    {
      CFStringRef v27 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
      if (v27)
      {
        CFRelease(v27);
        uint64_t v40 = 0;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v37 = 0u;
        memset(v36, 0, sizeof(v36));
        uint64_t v34 = a6;
        uint64_t v31 = &unk_1ED022498;
        int v32 = a4;
        int v33 = a5;
        long long v35 = CA::Render::Shmem::new_shmem(a7, a8, 1, a10);
        CFStringRef v28 = &v31;
        if (!v35) {
          CFStringRef v28 = 0;
        }
        *(void *)&long long v37 = v28;
        uint64_t v31 = &unk_1ED022498;
        uint64_t v29 = v35;
        if (v35 && atomic_fetch_add(v35 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(_DWORD *))(*(void *)v29 + 16))(v29);
        }
        return v25;
      }
    }
    uint64_t v25 = 4;
  }
  if (a7) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], a7);
  }
  return v25;
}

uint64_t CASRenderDisplayContextListSurface(const char *a1, const audit_token_t *a2, unsigned int a3, mach_port_t a4, int a5, int a6, CA::Mat4Impl *a7, unsigned int a8, double a9, unsigned int a10, unint64_t *a11, CA::Render::Server *a12)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = 4213784577;
  mach_vm_size_t v20 = 4 * a3;
  mach_vm_size_t v21 = (unint64_t)a8 << 7;
  if ((CA::Render::Server::audit_token_cache_lookup(a12, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a12, v22) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01
      && (CFStringRef v23 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0])) != 0)
    {
      CFRelease(v23);
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      memset(v36, 0, sizeof(v36));
      CFStringRef v24 = IOSurfaceLookupFromMachPort(a4);
      if (v24)
      {
        int v32 = &unk_1ED02DCF0;
        long long v35 = v24;
        uint64_t v25 = v24;
        CFDictionaryRef cf = v24;
        int Width = IOSurfaceGetWidth(v24);
        int Height = IOSurfaceGetHeight(v25);
        *(void *)&long long v37 = &v32;
        BOOL v26 = IOSurfaceGetProtectionOptions() != 0;
        CFRelease(cf);
      }
      else
      {
        uint64_t v19 = 5;
      }
    }
    else
    {
      uint64_t v19 = 4;
    }
  }
  CFStringRef v27 = (vm_map_t *)MEMORY[0x1E4F14960];
  mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)a7, v21);
  mach_vm_deallocate(*v27, (mach_vm_address_t)a2, v20);
  if (a4) {
    mach_port_deallocate(*v27, a4);
  }
  return v19;
}

uint64_t anonymous namespace'::render_display_context_list(const char *a1, uint64_t a2, unsigned int a3, int a4, int a5, CA::Mat4Impl *a6, unsigned int a7, BOOL *a8, double a9, unint64_t *a10, _anonymous_namespace_ *a11, uint64_t a12, char a13)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  if (a3 > 0x200)
  {
    CFStringRef v24 = (char *)malloc_type_malloc(8 * a3, 0x79E90E77uLL);
    CFStringRef v23 = v24;
  }
  else
  {
    MEMORY[0x1F4188790](a1);
    CFStringRef v23 = (char *)&v45 - ((v22 + 15) & 0xFFFFFFFF0);
    bzero(v23, v22);
  }
  if (a7 <= 0x1A)
  {
    MEMORY[0x1F4188790](v24);
    BOOL v26 = (char *)&v45 - ((v25 + 15) & 0x1FFFFFFFFF0);
    bzero(v26, v25);
    if (v23) {
      goto LABEL_6;
    }
LABEL_19:
    uint64_t v38 = 5;
    goto LABEL_41;
  }
  BOOL v26 = (char *)malloc_type_malloc(152 * a7, 0xC8972095uLL);
  if (!v23) {
    goto LABEL_19;
  }
LABEL_6:
  uint64_t v46 = a1;
  int v47 = a4;
  int v48 = a5;
  uint64_t v49 = a7;
  if (a7)
  {
    CFStringRef v27 = v26 + 144;
    uint64_t v28 = v49;
    do
    {
      CA::Transform::set((uint64_t)v50, a6, 1);
      long long v29 = v50[1];
      long long v30 = v50[2];
      long long v31 = v50[3];
      *((_OWORD *)v27 - 9) = v50[0];
      *((_OWORD *)v27 - 8) = v29;
      *((_OWORD *)v27 - 7) = v30;
      *((_OWORD *)v27 - 6) = v31;
      long long v32 = v50[5];
      long long v33 = v50[6];
      long long v34 = v50[7];
      *((_OWORD *)v27 - 5) = v50[4];
      *((_OWORD *)v27 - 4) = v32;
      *((_OWORD *)v27 - 3) = v33;
      *((_OWORD *)v27 - 2) = v34;
      *((_OWORD *)v27 - 1) = v50[8];
      *CFStringRef v27 = *v27 & 0xE0 | v51 & 0x1F;
      v27 += 152;
      a6 = (CA::Mat4Impl *)((char *)a6 + 128);
      --v28;
    }
    while (v28);
  }
  if (a3)
  {
    uint64_t v35 = 0;
    while (1)
    {
      uint64_t v36 = CA::Render::Context::context_by_id((CA::Render::Context *)*(unsigned int *)(a2 + 4 * v35));
      *(void *)&v23[8 * v35] = v36;
      if (!v36) {
        break;
      }
      if (a3 == ++v35)
      {
        LODWORD(v35) = a3;
        break;
      }
    }
    if ((a13 & 1) == 0) {
      goto LABEL_15;
    }
  }
  else
  {
    LODWORD(v35) = 0;
    if ((a13 & 1) == 0)
    {
LABEL_15:
      if ((a13 & 2) == 0) {
        *(_DWORD *)(a12 + 56) = 0x10000;
      }
      char v37 = *(unsigned char *)(a12 + 88) | 1;
      goto LABEL_22;
    }
  }
  *(_DWORD *)a12 = 0;
  *(unsigned char *)(a12 + 4) = 1;
  char v37 = *(unsigned char *)(a12 + 88) & 0xFE;
LABEL_22:
  *(unsigned char *)(a12 + 88) = v37;
  uint64_t v38 = 5;
  if (a3 && v35 == a3)
  {
    CFStringRef v39 = CFStringCreateWithCString(0, v46, 0x8000100u);
    *(void *)(a12 + 8) = v39;
    *(void *)(a12 + 16) = a3;
    *(void *)(a12 + 24) = v23;
    int v40 = v48;
    *(_DWORD *)(a12 + 40) = v47;
    *(_DWORD *)(a12 + 44) = v40;
    *(double *)(a12 + 48) = a9;
    *(void *)(a12 + 64) = v49;
    *(void *)(a12 + 72) = v26;
    *(void *)(a12 + 80) = 0;
    LOBYTE(v40) = *(unsigned char *)(a12 + 88) & 0xC9;
    *(unsigned char *)(a12 + 7) = ((unsigned __int16)a8 & 0x400) != 0;
    *(unsigned char *)(a12 + 88) = BYTE1(a8) & 0x10 | (a8 >> 5) & 4 | (a8 >> 10) & 2 | v40;
    if (*(void *)(a12 + 32))
    {
      CA::Render::post_notification(0x15u, 0, a12, 0);
      CFStringRef v39 = *(CFStringRef *)(a12 + 8);
    }
    if (v39) {
      CFRelease(v39);
    }
    char v41 = *(unsigned char *)(a12 + 88);
    if (a10)
    {
      *a10 = *(void *)(a12 + 80) | ((unint64_t)(*(unsigned char *)(a12 + 88) & 0x20) << 58);
      char v41 = *(unsigned char *)(a12 + 88);
    }
    if ((v41 & 0x20) != 0) {
      uint64_t v38 = 0;
    }
    else {
      uint64_t v38 = 5;
    }
  }
  if (v35)
  {
    uint64_t v35 = v35;
    long long v42 = (atomic_uint **)v23;
    do
    {
      long long v43 = *v42;
      if (*v42 && atomic_fetch_add(v43 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v43 + 16))(v43);
      }
      ++v42;
      --v35;
    }
    while (v35);
  }
  if (a3 > 0x200) {
    free(v23);
  }
LABEL_41:
  if (a7 >= 0x1B && v26) {
    free(v26);
  }
  return v38;
}

uint64_t CASRenderDisplayContextListShmem(const char *a1, const audit_token_t *a2, unsigned int a3, int a4, int a5, uint64_t a6, mem_entry_name_port_t a7, mach_vm_size_t a8, double a9, int a10, int a11, int a12, CA::Mat4Impl *a13, unsigned int a14, unsigned int a15, unint64_t *a16, CA::Render::Server *a17)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v22 = 4213784577;
  mach_vm_size_t v23 = 4 * a3;
  if ((CA::Render::Server::audit_token_cache_lookup(a17, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a17, v24) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01
      && (CFStringRef v25 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0])) != 0)
    {
      CFRelease(v25);
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      memset(v39, 0, sizeof(v39));
      long long v34 = &unk_1ED022498;
      int v35 = a4;
      int v36 = a5;
      uint64_t v37 = a6;
      uint64_t v38 = CA::Render::Shmem::new_shmem(a7, a8, 1, a10);
      BOOL v26 = &v34;
      if (!v38) {
        BOOL v26 = 0;
      }
      *(void *)&long long v40 = v26;
      long long v34 = &unk_1ED022498;
      CFStringRef v27 = v38;
      if (v38 && atomic_fetch_add(v38 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(_DWORD *))(*(void *)v27 + 16))(v27);
      }
      a7 = 0;
    }
    else
    {
      uint64_t v22 = 4;
    }
  }
  uint64_t v28 = (vm_map_t *)MEMORY[0x1E4F14960];
  mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)a13, (unint64_t)a14 << 7);
  mach_vm_deallocate(*v28, (mach_vm_address_t)a2, v23);
  if (a7) {
    mach_port_deallocate(*v28, a7);
  }
  return v22;
}

uint64_t CASCaptureDisplay(const char *a1, _anonymous_namespace_ *a2, unsigned int *a3, _anonymous_namespace_ *a4, int a5, int a6, int a7, int a8, double a9, CA::Mat4Impl *a10, int a11, unsigned int a12, CA::Render::Server *a13)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v22 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(a13, (const audit_token_t *)a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a13, v23) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01
      && (CFStringRef v24 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0])) != 0)
    {
      CFRelease(v24);
      uint64_t v34 = 8;
      uint64_t v30 = 0;
      long long v33 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      int v31 = a6;
      int v32 = a5;
      if ((void)v27) {
        (*(void (**)(void))(*(void *)v27 + 8))(v27);
      }
    }
    else
    {
      uint64_t v22 = 4;
    }
  }
  mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)a2, 4 * a3);
  return v22;
}

void *anonymous namespace'::retain_slot_buffer(_anonymous_namespace_ *this)
{
  uint64_t v1 = CA::Render::Context::copy_slot(this);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = v1;
  int v3 = *(unsigned __int8 *)(v1 + 12);
  switch(v3)
  {
    case 51:
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      uint64_t v9 = malloc_type_zone_malloc(malloc_zone, 0x20uLL, 0x8BB15036uLL);
      int v6 = v9;
      if (v9)
      {
        void *v9 = &unk_1ED022458;
        uint64_t v10 = v2;
        if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
        {
          uint64_t v10 = 0;
          atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 0xFFFFFFFF);
        }
        v9[2] = *(void *)(v2 + 112);
        v9[3] = v10;
        v9[1] = *(void *)(v2 + 16);
      }
      goto LABEL_20;
    case 23:
      if (*(void *)(v1 + 120))
      {
        long long v11 = (malloc_zone_t *)get_malloc_zone();
        unsigned int v12 = malloc_type_zone_malloc(v11, 0x28uLL, 0x8BB15036uLL);
        int v6 = v12;
        if (v12)
        {
          void *v12 = &unk_1ED022510;
          uint64_t v13 = v2;
          if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
          {
            uint64_t v13 = 0;
            atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 0xFFFFFFFF);
          }
          v12[4] = v13;
          v12[1] = *(void *)(v2 + 16);
          uint64_t v14 = *(void *)(v2 + 120);
          void v12[2] = *(void *)(v2 + 160);
          v12[3] = v14;
        }
        goto LABEL_20;
      }
      break;
    case 11:
      size_t v4 = (malloc_zone_t *)get_malloc_zone();
      long long v5 = malloc_type_zone_malloc(v4, 0x20uLL, 0x8BB15036uLL);
      int v6 = v5;
      if (v5)
      {
        void *v5 = &unk_1ED022550;
        uint64_t v7 = v2;
        if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
        {
          uint64_t v7 = 0;
          atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 0xFFFFFFFF);
        }
        v5[1] = *(void *)(v2 + 24);
        v5[2] = 0;
        v5[3] = v7;
      }
      goto LABEL_20;
  }
  int v6 = 0;
LABEL_20:
  if (atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 0xFFFFFFFF) == 1) {
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
  }
  return v6;
}

void anonymous namespace'::SlotRenderBuffer::~SlotRenderBuffer(_anonymous_namespace_::SlotRenderBuffer *this)
{
  *(void *)this = &unk_1ED022510;
  uint64_t v2 = (atomic_uint *)*((void *)this + 4);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v1;

  *(void *)this = &unk_1ED022510;
  uint64_t v1 = (atomic_uint *)*((void *)this + 4);
  if (v1)
  {
    if (atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
    }
  }
}

uint64_t anonymous namespace'::SlotIOSurface::set_edr_factor(_anonymous_namespace_::SlotIOSurface *this, float a2)
{
  *(_WORD *)(*((void *)this + 3) + 336) = *(_WORD *)(*((void *)this + 3) + 336) & 0xFFEF | (16 * (a2 != 1.0));
  return CA::Render::Surface::set_edr_factor(*((void *)this + 3), a2);
}

void anonymous namespace'::SlotIOSurface::~SlotIOSurface(_anonymous_namespace_::SlotIOSurface *this)
{
  *(void *)this = &unk_1ED022458;
  uint64_t v2 = (atomic_uint *)*((void *)this + 3);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v1;

  *(void *)this = &unk_1ED022458;
  uint64_t v1 = (atomic_uint *)*((void *)this + 3);
  if (v1)
  {
    if (atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
    }
  }
}

uint64_t anonymous namespace'::DeferredImageSlotIOSurface::set_edr_factor(_anonymous_namespace_::DeferredImageSlotIOSurface *this, float a2)
{
  uint64_t result = *(void *)(*((void *)this + 3) + 16);
  if (result)
  {
    *(_WORD *)(result + 336) = *(_WORD *)(result + 336) & 0xFFEF | (16 * (a2 != 1.0));
    return CA::Render::Surface::set_edr_factor(result, a2);
  }
  return result;
}

void anonymous namespace'::DeferredImageSlotIOSurface::realize_buffer(_anonymous_namespace_::DeferredImageSlotIOSurface *this, uint64_t a2, unsigned int a3, int a4, CGColorSpace *a5, uint64_t a6, const __CFString *a7)
{
  uint64_t v11 = *((void *)this + 3);
  uint64_t v12 = *(void *)(v11 + 16);
  if (v12)
  {
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 240))(v12);
    uint64_t v14 = *(atomic_uint **)(v11 + 16);
    if ((a2 & ~v13) != 0)
    {
      if (v14)
      {
        if (atomic_fetch_add(v14 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v14 + 16))(v14);
        }
        *(void *)(v11 + 16) = 0;
      }
    }
    else if (v14)
    {
      goto LABEL_41;
    }
  }
  if (*(unsigned char *)(v11 + 32)) {
    int v15 = 35;
  }
  else {
    int v15 = 33;
  }
  if (*(unsigned char *)(v11 + 32)) {
    int v16 = 1;
  }
  else {
    int v16 = 3;
  }
  if (*(unsigned char *)(v11 + 33)) {
    int v17 = v15;
  }
  else {
    int v17 = v16;
  }
  if (a4) {
    int v18 = 13;
  }
  else {
    int v18 = v17;
  }
  if (v18 == 3) {
    int v19 = 1;
  }
  else {
    int v19 = v18;
  }
  if (((0x61CB910CuLL >> v19) & 1) == 0)
  {
    mach_vm_size_t v20 = (CA::Render *)dword_1849995EC[v19];
    if (initialized != -1) {
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    }
    iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format(v20, *(_DWORD *)(v11 + 24), *(_DWORD *)(v11 + 28), 2 * (*(float *)&dword_1EB2ACAC0 == 0), a2, @"CA Image Slot", a7);
    if (iosurface_with_pixel_format)
    {
      uint64_t v22 = iosurface_with_pixel_format;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      CFStringRef v24 = (atomic_uint *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x158uLL, 0x743898A5uLL);
      if (v24)
      {
        CFStringRef v25 = v24;
        CA::Render::Surface::Surface((uint64_t)v24, v22, v18, 0, 0, 0, 0);
        if (a5) {
          CA::Render::Texture::set_colorspace((CA::Render::Texture *)v25, a5);
        }
        long long v26 = *(atomic_uint **)(v11 + 16);
        if (v26 != v25)
        {
          if (v26 && atomic_fetch_add(v26 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v26 + 16))(v26);
          }
          long long v27 = v25;
          if (!atomic_fetch_add(v25 + 2, 1u))
          {
            long long v27 = 0;
            atomic_fetch_add(v25 + 2, 0xFFFFFFFF);
          }
          *(void *)(v11 + 16) = v27;
        }
        IOSurfaceSetOwnershipIdentity();
        if (atomic_fetch_add(v25 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v25 + 16))(v25);
        }
      }
      else
      {
        CFRelease(v22);
      }
    }
  }
LABEL_41:
  uint64_t v28 = *(void *)(*((void *)this + 3) + 16);
  if (v28) {
    uint64_t v28 = *(void *)(v28 + 112);
  }
  *((void *)this + 2) = v28;
}

void anonymous namespace'::DeferredImageSlotIOSurface::~DeferredImageSlotIOSurface(_anonymous_namespace_::DeferredImageSlotIOSurface *this)
{
  *(void *)this = &unk_1ED022550;
  uint64_t v2 = (atomic_uint *)*((void *)this + 3);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v1;

  *(void *)this = &unk_1ED022550;
  uint64_t v1 = (atomic_uint *)*((void *)this + 3);
  if (v1)
  {
    if (atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
    }
  }
}

uint64_t CASCaptureDisplayLayer(const char *a1, CA::Render::Context *a2, uint64_t a3, _anonymous_namespace_ *a4, int a5, int a6, int a7, CA::Mat4Impl *a8, double a9, unsigned int a10, CA::Render::Server *a11)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v20 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(a11, (const audit_token_t *)a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a11, v21) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01
      && (CFStringRef v22 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0])) != 0)
    {
      CFRelease(v22);
      uint64_t v28 = 128;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v25 = 0u;
      memset(v24, 0, sizeof(v24));
      HIDWORD(v26) = a5;
      if ((void)v25) {
        (*(void (**)(void))(*(void *)v25 + 8))(v25);
      }
    }
    else
    {
      return 4;
    }
  }
  return v20;
}

uint64_t CASCaptureDisplayContextList(const char *a1, const audit_token_t *a2, unsigned int a3, _anonymous_namespace_ *a4, int a5, int a6, int a7, CA::Mat4Impl *a8, double a9, unsigned int a10, unsigned int a11, CA::Render::Server *a12)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v20 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(a12, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a12, v21) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01
      && (CFStringRef v22 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0])) != 0)
    {
      CFRelease(v22);
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      memset(v26, 0, sizeof(v26));
      BYTE8(v30) = 8;
      HIDWORD(v28) = a5;
      if ((void)v27) {
        (*(void (**)(void))(*(void *)v27 + 8))(v27);
      }
    }
    else
    {
      uint64_t v20 = 4;
    }
  }
  mach_vm_size_t v23 = (vm_map_t *)MEMORY[0x1E4F14960];
  mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)a8, (unint64_t)a10 << 7);
  mach_vm_deallocate(*v23, (mach_vm_address_t)a2, 4 * a3);
  return v20;
}

uint64_t CASSetDisplayProperties(int a1, const audit_token_t *a2, int a3, uint64_t a4, int a5, char a6, unsigned int a7, int a8, float a9, float a10, int a11, unsigned __int8 a12, unsigned int a13, mach_port_name_t a14, CA::Render::Server *a15)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (a14 - 1 > 0xFFFFFFFD) {
    return 5;
  }
  int v23 = (int)a2;
  uint64_t v24 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(a15, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a15, v25) & 0x20000) == 0)
  {
    if (initialized != -1) {
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    }
    uint64_t v24 = 5;
    if (!a3 && !byte_1EB2ACC22)
    {
      char v27 = CA::Render::Server::audit_token_cache_lookup(a15, v26);
      unsigned int v28 = a13 & 0xFFFFFFCF;
      long long v30 = 0u;
      long long v31 = 0u;
      if ((v27 & 2) != 0) {
        unsigned int v28 = a13;
      }
      LODWORD(v30) = v23;
      *((void *)&v30 + 1) = a4;
      LODWORD(v31) = a5;
      BYTE4(v31) = a6;
      *((void *)&v31 + 1) = __PAIR64__(LODWORD(a9), a7);
      float v32 = a10;
      int v33 = a8;
      int v34 = a12;
      unsigned int v35 = v28;
      uint64_t v36 = a14;
      CA::Render::post_notification(0x20u, 0, (uint64_t)&v30, 0);
      uint64_t v24 = 0;
    }
  }
  mach_port_deallocate(*MEMORY[0x1E4F14960], a14);
  return v24;
}

uint64_t CASSetDisplayPresetProperties(int a1, const audit_token_t *a2, mach_port_name_t a3, CA::Render::Server *this, double a5, double a6, double a7, double a8)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (a3 - 1 > 0xFFFFFFFD) {
    return 5;
  }
  unsigned __int8 v14 = a2;
  uint64_t v16 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v17) & 0x20000) == 0)
  {
    if ((CA::Render::Server::audit_token_cache_lookup(this, v18) & 0x4000) == 0) {
      goto LABEL_8;
    }
    if (initialized != -1) {
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    }
    if (!byte_1EB2ACC22)
    {
      v20[0] = a1;
      v20[1] = v14;
      double v21 = a5;
      double v22 = a6;
      double v23 = a7;
      double v24 = a8;
      uint64_t v25 = a3;
      CA::Render::post_notification(0x21u, 0, (uint64_t)v20, 0);
      uint64_t v16 = 0;
    }
    else
    {
LABEL_8:
      uint64_t v16 = 5;
    }
  }
  mach_port_deallocate(*MEMORY[0x1E4F14960], a3);
  return v16;
}

uint64_t CASSetDisplayLatency(int a1, const audit_token_t *a2, uint64_t a3, CA::Render::Server *this, double a5)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v11) & 0x20000) == 0)
  {
    if (LOBYTE(a2->val[0]))
    {
      v15[0] = 0;
      v15[1] = a1;
      long long v12 = *(_OWORD *)&a2->val[4];
      long long v16 = *(_OWORD *)a2->val;
      long long v17 = v12;
      long long v13 = *(_OWORD *)&a2[1].val[4];
      long long v18 = *(_OWORD *)a2[1].val;
      long long v19 = v13;
      uint64_t v20 = a3;
      double v21 = a5;
      CA::Render::post_notification(0x23u, 0, (uint64_t)v15, 0);
      if (LOBYTE(v15[0])) {
        return 0;
      }
      else {
        return 56;
      }
    }
    else
    {
      return 5;
    }
  }
  return v10;
}

uint64_t CASRegisterForDisallowedLayersNotification(mach_port_name_t a1, const audit_token_t *a2, CA::Render::Server *this)
{
  int v4 = (int)a2;
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v7) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v8) & 0x10000) != 0)
  {
    if (a1 - 1 > 0xFFFFFFFD)
    {
      return 4;
    }
    else
    {
      v10[1] = a1;
      int v11 = 0;
      v10[0] = v4;
      CA::Render::post_notification(0x24u, 0, (uint64_t)v10, 0);
      uint64_t v6 = 0;
      if (!(_BYTE)v11)
      {
        mach_port_deallocate(*MEMORY[0x1E4F14960], a1);
        return 56;
      }
    }
  }
  return v6;
}

uint64_t CASUnregisterForDisallowedLayersNotification(int a1, const audit_token_t *a2, int a3, CA::Render::Server *this)
{
  mach_port_name_t v6 = a2;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v9) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v10) & 0x10000) != 0)
  {
    if (v6 - 1 > 0xFFFFFFFD) {
      return 5;
    }
    v12[1] = a1;
    int v13 = 0;
    v12[0] = a3;
    CA::Render::post_notification(0x25u, 0, (uint64_t)v12, 0);
    uint64_t v8 = 0;
    if (!(_BYTE)v13)
    {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v6);
      return 5;
    }
  }
  return v8;
}

uint64_t CASContentStreamModify(mach_port_name_t a1, const audit_token_t *a2, uint64_t a3, CA::Render::Server *this)
{
  mach_port_name_t v6 = a2;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = 4213784577;
  char v9 = CA::Render::Server::audit_token_cache_lookup(this, a2);
  int v11 = (ipc_space_t *)MEMORY[0x1E4F14960];
  if (v9 < 0
    || (CA::Render::Server::audit_token_cache_lookup(this, v10) & 0x20000) != 0
    || (CA::Render::Server::audit_token_cache_lookup(this, v12) & 0x8000) == 0)
  {
    goto LABEL_11;
  }
  if (*(unsigned char *)(a3 + 65) != 1) {
    goto LABEL_7;
  }
  if (!v6)
  {
    uint64_t v8 = 4;
    if (!a1) {
      return v8;
    }
    goto LABEL_14;
  }
  if (*(_DWORD *)a3)
  {
LABEL_7:
    uint64_t v17 = 0;
    uint64_t v14 = a3;
    mach_port_name_t v15 = a1;
    mach_port_name_t v16 = v6;
    CA::Render::post_notification(0x40u, 0, (uint64_t)&v14, 0);
    if (BYTE1(v17)) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = 5;
    }
    if ((_BYTE)v17) {
      return v8;
    }
LABEL_11:
    if (!v6) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v8 = 4;
LABEL_12:
  mach_port_deallocate(*v11, v6);
LABEL_13:
  if (a1) {
LABEL_14:
  }
    mach_port_deallocate(*v11, a1);
  return v8;
}

uint64_t CASContentStreamStartStop(CA::Render::ContentStream *a1, const audit_token_t *a2, unsigned int a3, unsigned int a4, unsigned int a5, CA::Render::Server *this)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v13) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v14) & 0x8000) != 0)
  {
    stream_and_locuint64_t k = (char *)CA::Render::ContentStream::get_or_create_stream_and_lock(a1, 0, 0);
    if (stream_and_lock)
    {
      if (a5 + a4 != a3) {
        __assert_rtn("CASContentStreamStartStop", "render-server.cpp", 5048, "included_count + excluded_count == contexts_count");
      }
      mach_port_name_t v16 = stream_and_lock;
      X::small_vector_base<unsigned int>::resize((uint64_t)(stream_and_lock + 136), a4);
      X::small_vector_base<unsigned int>::resize((uint64_t)(v16 + 200), a5);
      memcpy(*((void **)v16 + 17), a2, 4 * a4);
      memcpy(*((void **)v16 + 25), &a2->val[a4], 4 * a5);
      v16[400] = a3 != 0;
      uint64_t v30 = 0;
      memset(v29, 0, sizeof(v29));
      *(_OWORD *)char v27 = 0u;
      long long v28 = 0u;
      memset(v26, 0, sizeof(v26));
      *(_OWORD *)&v24[16] = 0u;
      long long v25 = 0u;
      long long v17 = *((_OWORD *)v16 + 7);
      v23[2] = *((_OWORD *)v16 + 6);
      *(_OWORD *)double v24 = v17;
      *(_DWORD *)&v24[15] = *(_DWORD *)(v16 + 127);
      long long v18 = *((_OWORD *)v16 + 5);
      v23[0] = *((_OWORD *)v16 + 4);
      v23[1] = v18;
      *(void *)&v24[24] = (char *)v26 + 8;
      *(void *)&long long v25 = (char *)v26 + 8;
      *((void *)&v25 + 1) = (char *)v26 + 8;
      *(void *)&v26[0] = 8;
      X::small_vector_base<unsigned int>::append<unsigned int const*>((uint64_t)&v24[24], *((int **)v16 + 17), *((int **)v16 + 18));
      v27[1] = (char *)v29 + 8;
      *(void *)&long long v28 = (char *)v29 + 8;
      *((void *)&v28 + 1) = (char *)v29 + 8;
      *(void *)&v29[0] = 8;
      X::small_vector_base<unsigned int>::append<unsigned int const*>((uint64_t)&v27[1], *((int **)v16 + 25), *((int **)v16 + 26));
      pthread_mutex_unlock((pthread_mutex_t *)v16);
      v22[0] = v23;
      v22[1] = a3 != 0;
      if (!DWORD1(v23[0])) {
        __assert_rtn("CASContentStreamStartStop", "render-server.cpp", 5065, "!\"implicit display not yet implemented\"");
      }
      CA::Render::post_notification(0x3Fu, 0, (uint64_t)v22, 0);
      if (v27[1] != *((void **)&v28 + 1)) {
        free(v27[1]);
      }
      if (*(void *)&v24[24] != *((void *)&v25 + 1)) {
        free(*(void **)&v24[24]);
      }
      uint64_t v12 = 0;
    }
    else
    {
      uint64_t v12 = 56;
    }
  }
  mach_vm_size_t v19 = 4 * a3;
  uint64_t v20 = (ipc_space_t *)MEMORY[0x1E4F14960];
  mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)a2, v19);
  if (a1) {
    mach_port_deallocate(*v20, (mach_port_name_t)a1);
  }
  return v12;
}

void X::small_vector_base<unsigned int>::append<unsigned int const*>(uint64_t a1, int *a2, int *a3)
{
  int v4 = a2;
  unint64_t v6 = a3 - a2;
  uint64_t v7 = *(_DWORD **)(a1 + 8);
  uint64_t v8 = (uint64_t)v7 - *(void *)a1;
  if (v6 > *(void *)(a1 + 24) - (v8 >> 2))
  {
    X::small_vector_base<unsigned int>::grow((int **)a1, (v8 >> 2) + v6);
    uint64_t v7 = *(_DWORD **)(a1 + 8);
  }
  if (v4 != a3)
  {
    char v9 = v7;
    do
    {
      int v10 = *v4++;
      *v9++ = v10;
    }
    while (v4 != a3);
  }
  *(void *)(a1 + 8) = &v7[v6];
}

uint64_t CASContentStreamReleaseSurf(CA::Render::ContentStream *a1, const audit_token_t *a2, CA::Render::Server *this)
{
  int v4 = (int)a2;
  uint64_t v6 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v7) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v8) & 0x8000) != 0)
  {
    stream_and_locuint64_t k = (CA::Render::ContentStream *)CA::Render::ContentStream::get_or_create_stream_and_lock(a1, 0, 0);
    if (!stream_and_lock)
    {
      uint64_t v6 = 56;
      if (!a1) {
        return v6;
      }
      goto LABEL_9;
    }
    int v10 = (pthread_mutex_t *)stream_and_lock;
    BOOL v11 = CA::Render::ContentStream::reuse_surface(stream_and_lock, v4);
    pthread_mutex_unlock(v10);
    if (v11) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = 5;
    }
  }
  if (a1) {
LABEL_9:
  }
    mach_port_deallocate(*MEMORY[0x1E4F14960], (mach_port_name_t)a1);
  return v6;
}

uint64_t CASSetDisplayState(int a1, const audit_token_t *a2, unsigned __int8 a3, char a4, CA::Render::Server *this)
{
  int v8 = (int)a2;
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v11) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v12) & 0x10000) != 0)
  {
    v14[1] = a1;
    v14[0] = v8;
    int v15 = a3;
    BYTE1(v15) = a4;
    CA::Render::post_notification(0x42u, 0, (uint64_t)v14, 0);
    return 0;
  }
  return v10;
}

uint64_t _CreateDisplayPowerAssertion(int a1, const audit_token_t *a2, mach_port_name_t a3, int a4, unsigned __int8 a5, CA::Render::Server *this, audit_token_t *a7)
{
  int v11 = (int)a2;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v14) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v15) & 0x10000) != 0)
  {
    v17[3] = a4;
    v17[0] = a1;
    v17[1] = v11;
    void v17[2] = a3;
    int v18 = a5;
    CA::Render::post_notification(0x43u, 0, (uint64_t)v17, 0);
    uint64_t v13 = 0;
    if (!BYTE1(v18))
    {
      if (a3) {
        mach_port_deallocate(*MEMORY[0x1E4F14960], a3);
      }
      return 5;
    }
  }
  return v13;
}

uint64_t CASDestroyDisplayPowerAssertion(int a1, const audit_token_t *a2, CA::Render::Server *this)
{
  mach_port_name_t v4 = a2;
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v7) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v8) & 0x10000) != 0)
  {
    v10[1] = v4;
    int v11 = 0;
    v10[0] = a1;
    CA::Render::post_notification(0x44u, 0, (uint64_t)v10, 0);
    if (v4) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v4);
    }
    if ((_BYTE)v11) {
      return 0;
    }
    else {
      return 5;
    }
  }
  return v6;
}

char *CA::convert_bgra8888_to_mask(char *this, char *a2, char *a3, char *a4, uint64_t a5, uint64_t a6)
{
  if (a6 >= 1)
  {
    do
    {
      uint64_t v6 = a3;
      uint64_t v7 = a5;
      int v8 = this;
      if (a5 >= 4)
      {
        do
        {
          char v9 = v8[3];
          char v10 = v8[7];
          char v11 = v8[11];
          char v12 = v8[15];
          v8 += 16;
          *uint64_t v6 = v9;
          v6[1] = v10;
          void v6[2] = v11;
          v6[3] = v12;
          v6 += 4;
          BOOL v13 = (unint64_t)v7 > 7;
          v7 -= 4;
        }
        while (v13);
      }
      if (v7 >= 1)
      {
        uint64_t v14 = v8 + 3;
        unint64_t v15 = v7 + 1;
        do
        {
          char v16 = *v14;
          v14 += 4;
          *v6++ = v16;
          --v15;
        }
        while (v15 > 1);
      }
      this = &a2[(void)this];
      a3 = &a4[(void)a3];
      BOOL v13 = a6-- <= 1;
    }
    while (!v13);
  }
  return this;
}

float CA::Render::Texture::opacity_at(CA::Render::Texture *this)
{
  return 1.0;
}

uint64_t CA::Render::Texture::get_tiled_texture_size(CA::Render::Texture *this, unsigned int *a2, unsigned int *a3)
{
  return 0;
}

uint64_t CA::Render::Texture::copy_tiled_texture(CA::Render::Texture *this)
{
  return 0;
}

uint64_t CA::Render::PixelBuffer::implicitly_opaque(CA::Render::PixelBuffer *this)
{
  return CA::Render::fourcc_has_alpha((CA::Render *)*((unsigned int *)this + 28)) ^ 1;
}

uint64_t CA::Render::PixelBuffer::image_format(CA::Render::PixelBuffer *this)
{
  return CA::Render::fourcc_to_format((CA::Render *)*((unsigned int *)this + 28));
}

void CA::Render::PixelBuffer::show(CA::Render::PixelBuffer *this, unsigned int a2, char a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *((unsigned int *)this + 28);
  BOOL v6 = x_log_hook_p();
  if (a3)
  {
    if (v6)
    {
LABEL_15:
      x_log_();
      return;
    }
    uint64_t v23 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      int v24 = *((_DWORD *)this + 4);
      int v25 = *((_DWORD *)this + 5);
      *(_DWORD *)buf = 67109376;
      int v27 = v24;
      __int16 v28 = 1024;
      int v29 = v25;
      uint64_t v20 = "(pixel-buffer [%d %d])";
      double v21 = v23;
      uint32_t v22 = 14;
LABEL_38:
      _os_log_impl(&dword_184668000, v21, OS_LOG_TYPE_DEFAULT, v20, buf, v22);
    }
  }
  else
  {
    if (v6)
    {
      if ((v5 & 0x80000000) != 0) {
        __maskrune(v5 >> 24, 0x40000uLL);
      }
      if (BYTE2(v5) > 0x7Fu) {
        __maskrune(BYTE2(v5), 0x40000uLL);
      }
      if (BYTE1(v5) > 0x7Fu) {
        __maskrune(BYTE1(v5), 0x40000uLL);
      }
      if (v5 > 0x7Fu) {
        __maskrune(v5, 0x40000uLL);
      }
      goto LABEL_15;
    }
    uint64_t v7 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v8 = v5 >> 24;
      uint64_t v9 = MEMORY[0x1E4F14390];
      if ((v5 & 0x80000000) != 0) {
        int v10 = __maskrune(v8, 0x40000uLL);
      }
      else {
        int v10 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v8 + 60) & 0x40000;
      }
      if (v10) {
        int v11 = (int)v5 >> 24;
      }
      else {
        int v11 = 32;
      }
      if (BYTE2(v5) <= 0x7Fu) {
        int v12 = *(_DWORD *)(v9 + 4 * BYTE2(v5) + 60) & 0x40000;
      }
      else {
        int v12 = __maskrune(BYTE2(v5), 0x40000uLL);
      }
      if (v12) {
        int v13 = SBYTE2(v5);
      }
      else {
        int v13 = 32;
      }
      if (BYTE1(v5) <= 0x7Fu) {
        int v14 = *(_DWORD *)(v9 + 4 * BYTE1(v5) + 60) & 0x40000;
      }
      else {
        int v14 = __maskrune(BYTE1(v5), 0x40000uLL);
      }
      if (v14) {
        int v15 = SBYTE1(v5);
      }
      else {
        int v15 = 32;
      }
      if (v5 <= 0x7Fu) {
        int v16 = *(_DWORD *)(v9 + 4 * v5 + 60) & 0x40000;
      }
      else {
        int v16 = __maskrune(v5, 0x40000uLL);
      }
      int v17 = (char)v5;
      int v18 = *((_DWORD *)this + 4);
      int v19 = *((_DWORD *)this + 5);
      if (!v16) {
        int v17 = 32;
      }
      *(_DWORD *)buf = 67110400;
      int v27 = v11;
      __int16 v28 = 1024;
      int v29 = v13;
      __int16 v30 = 1024;
      int v31 = v15;
      __int16 v32 = 1024;
      int v33 = v17;
      __int16 v34 = 1024;
      int v35 = v18;
      __int16 v36 = 1024;
      int v37 = v19;
      uint64_t v20 = "(pixel-buffer %c%c%c%c [%d %d])";
      double v21 = v7;
      uint32_t v22 = 38;
      goto LABEL_38;
    }
  }
}

double CA::Render::PixelBuffer::encode(CA::Render::PixelBuffer *this, CA::Render::Encoder *a2)
{
  int v4 = *((_DWORD *)this + 3) >> 8;
  unint64_t v5 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    unint64_t v5 = (_DWORD *)*((void *)a2 + 4);
  }
  _DWORD *v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = *((void *)a2 + 5);
  unint64_t v8 = (_DWORD *)(v6 + 4);
  *((void *)a2 + 4) = v6 + 4;
  int v9 = *((_DWORD *)this + 4);
  if (v6 + 8 > v7)
  {
    CA::Render::Encoder::grow(a2, 4);
    unint64_t v8 = (_DWORD *)*((void *)a2 + 4);
  }
  *unint64_t v8 = v9;
  uint64_t v10 = *((void *)a2 + 4);
  unint64_t v11 = *((void *)a2 + 5);
  int v12 = (_DWORD *)(v10 + 4);
  *((void *)a2 + 4) = v10 + 4;
  int v13 = *((_DWORD *)this + 5);
  if (v10 + 8 > v11)
  {
    CA::Render::Encoder::grow(a2, 4);
    int v12 = (_DWORD *)*((void *)a2 + 4);
  }
  _DWORD *v12 = v13;
  *((void *)a2 + 4) += 4;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 12));
  uint64_t v14 = *((void *)this + 13);
  int v15 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v15 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    int v15 = (void *)*((void *)a2 + 4);
  }
  *int v15 = v14;
  uint64_t v16 = *((void *)a2 + 4);
  unint64_t v17 = *((void *)a2 + 5);
  int v18 = (_DWORD *)(v16 + 8);
  *((void *)a2 + 4) = v16 + 8;
  int v19 = *((_DWORD *)this + 28);
  if (v16 + 12 > v17)
  {
    CA::Render::Encoder::grow(a2, 4);
    int v18 = (_DWORD *)*((void *)a2 + 4);
  }
  _DWORD *v18 = v19;
  *((void *)a2 + 4) += 4;
  CA::Render::Encoder::encode_cfobject(a2, *((const void **)this + 15));

  *(void *)&double result = CA::Render::Texture::encode((CGColorSpaceRef *)this, a2).n128_u64[0];
  return result;
}

void CA::Render::PixelBuffer::finalize(CA::Render::PixelBuffer *this)
{
  CA::Render::post_notification(3u, (unint64_t)this, 0, 1);
  if (this)
  {
    uint64_t v2 = *(void (**)(CA::Render::PixelBuffer *))(*(void *)this + 8);
    v2(this);
  }
}

void CA::Render::PixelBuffer::~PixelBuffer(CA::Render::PixelBuffer *this)
{
  CA::Render::PixelBuffer::~PixelBuffer(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  const void *v2;
  const void *v3;
  atomic_uint *v4;
  atomic_uint *v5;
  uint64_t vars8;

  *(void *)this = &unk_1ED02CFB8;
  uint64_t v2 = (const void *)*((void *)this + 15);
  if (v2) {
    CFRelease(v2);
  }
  int v3 = (const void *)*((void *)this + 17);
  if (v3) {
    CFRelease(v3);
  }
  int v4 = (atomic_uint *)*((void *)this + 16);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  unint64_t v5 = (atomic_uint *)*((void *)this + 12);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  --dword_1EB2ADE60;

  CA::Render::Texture::~Texture((CGColorSpaceRef *)this);
}

void CA::Render::release_cvpixelbuffer(CA::Render *this, CVPixelBufferRef pixelBuffer, void *a3)
{
  CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);

  CVPixelBufferRelease(pixelBuffer);
}

CA::Render::Texture *CA::Render::PixelBuffer::image(CA::Render::PixelBuffer *this)
{
  double result = (CA::Render::Texture *)*((void *)this + 16);
  if (!result)
  {
    int v3 = (CGColorSpace **)*((void *)this + 12);
    if (!v3) {
      goto LABEL_8;
    }
    uint64_t v4 = CA::Render::fourcc_to_format((CA::Render *)*((unsigned int *)this + 28));
    if ((v4 & 0x80000000) != 0) {
      return 0;
    }
    double result = CA::Render::Image::new_image((CA::Render::Image *)v4, *((_DWORD *)this + 4), *((_DWORD *)this + 5), 1u, *((CGColorSpace **)this + 6), v3, (CA::Render::PixelBuffer *)((char *)this + 104), v5);
    if (!result)
    {
LABEL_8:
      double result = (CA::Render::Texture *)*((void *)this + 16);
      if (!result) {
        return result;
      }
      goto LABEL_9;
    }
    *((_DWORD *)result + 3) |= *((_DWORD *)this + 3) & 0x1800;
    uint64_t v6 = (atomic_uint *)*((void *)this + 16);
    *((void *)this + 16) = result;
    if (v6)
    {
      if (atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
      }
      goto LABEL_8;
    }
  }
LABEL_9:
  *((_DWORD *)result + 9) = *((_DWORD *)this + 9);
  return result;
}

CA::Render::Texture *CA::Render::PixelBuffer::decode(CA::Render::PixelBuffer *this, CA::Render::Decoder *a2)
{
  int v3 = CA::Render::Decoder::decode_int32(this);
  int v4 = CA::Render::Decoder::decode_int32(this);
  unsigned int v5 = CA::Render::Decoder::decode_int32(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  unint64_t v7 = (CA::Render::Texture *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x90uLL, 0x743898A5uLL);
  unint64_t v8 = v7;
  if (v7)
  {
    CA::Render::Texture::Texture(v7, v4, v5);
    unsigned int v9 = *((_DWORD *)v8 + 3) & 0xFFFFFF00 | 0x26;
    ++dword_1EB2ADE60;
    *(void *)unint64_t v8 = &unk_1ED02CFB8;
    *((void *)v8 + 12) = 0;
    *((void *)v8 + 16) = 0;
  }
  else
  {
    unsigned int v9 = MEMORY[0xC];
  }
  *((_DWORD *)v8 + 3) = v9 | (v3 << 8);
  uint64_t v10 = CA::Render::Decoder::decode_object(this, 47);
  unint64_t v11 = (atomic_uint *)*((void *)v8 + 12);
  *((void *)v8 + 12) = v10;
  if (v11 && atomic_fetch_add(v11 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v11 + 16))(v11);
  }
  *((void *)v8 + 13) = CA::Render::Decoder::decode_size_t(this);
  *((_DWORD *)v8 + 28) = CA::Render::Decoder::decode_int32(this);
  CFDictionaryGetTypeID();
  *((void *)v8 + 15) = CA::Render::Decoder::decode_cfobject(this);
  *((void *)v8 + 17) = 0;
  CA::Render::Texture::decode(v8, this);
  unint64_t v12 = *((void *)v8 + 13);
  if (is_mul_ok(v12, v5)) {
    unint64_t v13 = v12 * v5;
  }
  else {
    unint64_t v13 = 0;
  }
  int v14 = CA::Render::fourcc_to_format((CA::Render *)*((unsigned int *)v8 + 28));
  if ((v14 & 0x80000000) == 0)
  {
    uint64_t v15 = v12 - (dword_184999468[v14] * v4);
    v13 -= v15 & ~(v15 >> 63);
  }
  if (!v4 || !v5 || (v5 | v4) >> 24 || (uint64_t v16 = *((void *)v8 + 12)) == 0 || *(void *)(v16 + 16) < v13)
  {
    if (atomic_fetch_add((atomic_uint *volatile)v8 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(CA::Render::Texture *))(*(void *)v8 + 16))(v8);
    }
    return 0;
  }
  return v8;
}

uint64_t CA::OGL::anonymous namespace'::FlipTransition::source_requirement()
{
  return 3;
}

void CA::OGL::anonymous namespace'::FlipTransition::render(uint64_t a1, uint64_t a2, CA::OGL::Context *a3, float64x2_t *a4, CA::Transform *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  if (BYTE4(v30)) {
    uint64_t v12 = a6;
  }
  else {
    uint64_t v12 = a7;
  }
  if (v12)
  {
    _S0 = v30;
    __asm { FCVT            H0, S0 }
    int v18 = (_WORD *)*((void *)a3 + 2);
    v18[4] = _S0;
    v18[5] = _S0;
    void v18[6] = _S0;
    v18[7] = 15360;
    *(unsigned char *)(*((void *)a3 + 2) + 481) |= 1u;
    v20[0] = v22;
    v20[1] = v23;
    _DWORD v20[2] = v24;
    v20[3] = v25;
    v20[4] = v26;
    v20[5] = v27;
    v20[6] = v28;
    v20[7] = v29;
    __asm { FMOV            V0.2D, #1.0 }
    v20[8] = _Q0;
    uint64_t v21 = 16;
    CA::OGL::fill_surface_rect(a3, v12, a5, (uint64_t)v20, *a4, a4[1]);
    *(unsigned char *)(*((void *)a3 + 2) + 481) &= ~1u;
  }
}

void CA::OGL::anonymous namespace'::FlipTransition::set_state(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, float64x2_t *a5)
{
  v43[16] = *(double *)MEMORY[0x1E4F143B8];
  float v7 = *(float *)(a3 + 48);
  BOOL v8 = v7 < 0.5;
  float v9 = v7 + v7;
  if (v7 >= 0.5)
  {
    float v9 = 2.0 - (float)(v7 + v7);
    float v7 = v7 + 1.0;
  }
  *(unsigned char *)(a2 + 132) = v8;
  *(float *)(a2 + 128) = (float)(v9 * -0.75) + 1.0;
  int v10 = *(_DWORD *)(a3 + 20);
  if (!v10) {
    int v10 = 242;
  }
  if ((v10 & 0xFFFFFFFD) == 0xF0) {
    double v11 = -(v7 * 3.14159265);
  }
  else {
    double v11 = v7 * 3.14159265;
  }
  unsigned int v12 = v10 & 0xFFFFFFFE;
  if (v12 == 240) {
    double v13 = 0.0;
  }
  else {
    double v13 = 1.0;
  }
  double v35 = 0.0;
  if (v12 == 240) {
    double v14 = 1.0;
  }
  else {
    double v14 = 0.0;
  }
  double v15 = *a4;
  double v16 = a4[1];
  double v17 = a4[2];
  double v18 = a4[3];
  uint64_t v19 = *(void *)(a3 + 32);
  if (v19) {
    uint64_t v20 = (CA::Render::KeyValueArray **)(v19 + 40);
  }
  else {
    uint64_t v20 = (CA::Render::KeyValueArray **)(a3 + 24);
  }
  uint64_t v21 = *v20;
  if (CA::Render::KeyValueArray::get_int_key(*v20, 5, *(unsigned __int8 *)(a1 + 8))) {
    double v35 = fabs(sin(v11)) * 0.5 * (v17 * v14 + v18 * v13);
  }
  double v37 = v16 + v18 * 0.5;
  double v36 = v15 + v17 * 0.5;
  v38[0] = xmmword_184997D50;
  v38[1] = 0u;
  v38[2] = xmmword_184997D60;
  memset(&v38[3], 0, 32);
  uint64_t v39 = 0x3FF0000000000000;
  long long v41 = 0u;
  long long v42 = xmmword_184997D60;
  double v40 = -1.0 / (CA::Render::KeyValueArray::get_float_key(v21, 276, 3.0) * (0.5 * (v18 + v17)));
  float64x2_t v22 = *a5;
  float64x2_t v23 = a5[1];
  float64x2_t v24 = a5[2];
  float64x2_t v25 = a5[3];
  *(float64x2_t *)a2 = *a5;
  *(float64x2_t *)(a2 + 16) = v23;
  *(float64x2_t *)(a2 + 32) = v24;
  *(float64x2_t *)(a2 + 48) = v25;
  float64x2_t v26 = a5[4];
  float64x2_t v27 = a5[5];
  float64x2_t v28 = a5[6];
  float64x2_t v29 = a5[7];
  *(float64x2_t *)(a2 + 64) = v26;
  *(float64x2_t *)(a2 + 80) = v27;
  *(float64x2_t *)(a2 + 96) = vmlaq_f64(vmlaq_n_f64(vmlaq_n_f64(v28, v22, v36), v24, v37), (float64x2_t)0, v26);
  *(float64x2_t *)(a2 + 112) = vmlaq_f64(vmlaq_n_f64(vmlaq_n_f64(v29, v23, v36), v25, v37), (float64x2_t)0, v27);
  CA::Mat4Impl::mat4_concat((float64x2_t *)a2, (double *)v38, (const double *)a2, v30);
  float64x2_t v31 = vmlsq_lane_f64(vmlaq_f64(vmlaq_f64(*(float64x2_t *)(a2 + 112), (float64x2_t)0, *(float64x2_t *)(a2 + 16)), (float64x2_t)0, *(float64x2_t *)(a2 + 48)), *(float64x2_t *)(a2 + 80), v35, 0);
  *(float64x2_t *)(a2 + 96) = vmlsq_lane_f64(vmlaq_f64(vmlaq_f64(*(float64x2_t *)(a2 + 96), (float64x2_t)0, *(float64x2_t *)a2), (float64x2_t)0, *(float64x2_t *)(a2 + 32)), *(float64x2_t *)(a2 + 64), v35, 0);
  *(float64x2_t *)(a2 + 112) = v31;
  CA::Mat4Impl::mat4_set_rotation((CA::Mat4Impl *)v43, v32, -v11, v13, v14, 0.0);
  CA::Mat4Impl::mat4_concat((float64x2_t *)a2, v43, (const double *)a2, v33);
  float64x2_t v34 = vmlaq_f64(vmlsq_lane_f64(vmlsq_lane_f64(*(float64x2_t *)(a2 + 112), *(float64x2_t *)(a2 + 16), v36, 0), *(float64x2_t *)(a2 + 48), v37, 0), (float64x2_t)0, *(float64x2_t *)(a2 + 80));
  *(float64x2_t *)(a2 + 96) = vmlaq_f64(vmlsq_lane_f64(vmlsq_lane_f64(*(float64x2_t *)(a2 + 96), *(float64x2_t *)a2, v36, 0), *(float64x2_t *)(a2 + 32), v37, 0), (float64x2_t)0, *(float64x2_t *)(a2 + 64));
  *(float64x2_t *)(a2 + 112) = v34;
}

__n128 CA::OGL::anonymous namespace'::FlipTransition::ROI(uint64_t a1, uint64_t a2, __n128 *a3, uint64_t a4, uint64_t a5, __n128 *a6, __n128 *a7)
{
  *a6 = *a3;
  a6[1] = a3[1];
  *a7 = *a3;
  __n128 result = a3[1];
  a7[1] = result;
  return result;
}

void CA::OGL::anonymous namespace'::FlipTransition::DOD(uint64_t a1@<X0>, uint64_t a2@<X1>, double *a3@<X2>, float64x2_t *a4@<X3>, _OWORD *a5@<X4>, _OWORD *a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  if (BYTE4(v14)) {
    double v11 = a5;
  }
  else {
    double v11 = a6;
  }
  long long v12 = v11[1];
  *(_OWORD *)a7 = *v11;
  *(_OWORD *)(a7 + 16) = v12;
  CA::Mat4Impl::mat4_apply_to_rect(v13, (int8x16_t *)a7, v10);
}

uint64_t CA::Render::ImageProvider::prefetch_border(CA::Render::ImageProvider *this)
{
  return *((unsigned int *)this + 35);
}

void CA::Render::ImageProvider::prefetch_subtexture(CA::Render::ImageProvider *this, __int32 a2, __int32 a3, __int32 a4, __int32 a5, double a6)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if ((a2 & 0x80000000) == 0 && *((_DWORD *)this + 26) > a2)
  {
    v13[0] = a2;
    v13[1] = a3;
    v13[2] = a4;
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    uint64_t v8 = x_hash_table_lookup(*((void *)this + 18), (uint64_t)v13, 0);
    if (v8)
    {
      double v9 = *(double *)(v8 + 80);
      if (v9 <= *((double *)this + 24)) {
        double v9 = *((double *)this + 24);
      }
      *(double *)(v8 + 80) = v9;
      if (*(void *)(v8 + 24))
      {
        int v10 = *(void **)(v8 + 8);
        if (v10) {
          *int v10 = *(void *)v8;
        }
        if (*(void *)v8) {
          double v11 = (uint64_t *)(*(void *)v8 + 8);
        }
        else {
          double v11 = &CA::Render::subimage_head;
        }
        uint64_t *v11 = (uint64_t)v10;
        *(void *)uint64_t v8 = 0;
        long long v12 = (uint64_t *)CA::Render::subimage_head;
        *(void *)(v8 + 8) = CA::Render::subimage_head;
        if (v12) {
          uint64_t *v12 = v8;
        }
        CA::Render::subimage_head = v8;
      }
    }
    CA::Render::ImageProvider::add_needed((int32x2_t *)this, v13, a5, (int32x2_t *)v8);
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    CA::Render::ImageProvider::signal_client(this);
  }
}

int32x2_t *CA::Render::ImageProvider::add_needed(int32x2_t *result, __int32 *a2, __int32 a3, int32x2_t *a4)
{
  if ((a3 & 0x80000000) == 0)
  {
    float v7 = result;
    if (!a4 || (a4[6].i32[1] & 0x10002) != 0)
    {
      __int32 v8 = *a2;
      if ((*a2 & 0x80000000) == 0 && result[13].i32[0] > v8)
      {
        __int32 v9 = a2[1];
        __int32 v10 = result[13].i32[1];
        BOOL v11 = __OFSUB__(v8, v10);
        int v12 = v8 - v10;
        unsigned __int32 v13 = result[2].u32[0];
        unsigned int v14 = v13 >> v12;
        unsigned int v15 = v13 << -(char)v12;
        if (v12 < 0 == v11) {
          unsigned int v15 = v14;
        }
        if (result[12].i32[0] * v9 < v15)
        {
          __int32 v16 = a2[2];
          unsigned __int32 v17 = result[2].u32[1];
          unsigned int v18 = v12 < 0 ? v17 << -(char)v12 : v17 >> v12;
          if (result[12].i32[1] * v16 < v18)
          {
            uint64_t v19 = result + 19;
            for (__n128 result = (int32x2_t *)result[20]; ; __n128 result = (int32x2_t *)result[1])
            {
              if (result == v19)
              {
                malloc_zone = (malloc_zone_t *)get_malloc_zone();
                __n128 result = (int32x2_t *)malloc_type_zone_malloc(malloc_zone, 0x30uLL, 0x8BB15036uLL);
                CA::Render::Texture *result = (int32x2_t)result;
                result[1] = (int32x2_t)result;
                __int32 v21 = a2[2];
                result[2] = *(int32x2_t *)a2;
                result[3].i32[0] = v21;
                goto LABEL_20;
              }
              if (result[2].i32[0] == v8 && result[2].i32[1] == v9 && result[3].i32[0] == v16) {
                break;
              }
            }
            int32x2_t v30 = *result;
            float64x2_t v29 = (int32x2_t *)result[1];
            *(void *)(*(void *)&v30 + 8) = v29;
            *float64x2_t v29 = v30;
            CA::Render::Texture *result = (int32x2_t)result;
            result[1] = (int32x2_t)result;
LABEL_20:
            result[3].i32[1] = a3;
            if (a4) {
              int32x2_t v22 = a4[7];
            }
            else {
              int32x2_t v22 = 0;
            }
            result[4] = vrev64_s32(v22);
            __int32 v23 = v7[25].i32[0];
            result[5].i32[0] = v23;
            float64x2_t v24 = (int32x2_t *)v7[20];
            if (v24 != v19)
            {
              __int32 v25 = result[2].i32[0];
              while (1)
              {
                __int32 v26 = v24[2].i32[0];
                if (v26 < v25) {
                  break;
                }
                if (v26 <= v25)
                {
                  unsigned int v27 = v24[4].u32[1];
                  if (v27 > v22.i32[0] || v27 >= v22.i32[0] && v24[3].i32[1] >= a3) {
                    break;
                  }
                }
                float64x2_t v24 = (int32x2_t *)v24[1];
                if (v24 == v19) {
                  goto LABEL_33;
                }
              }
              uint64_t v19 = v24;
            }
LABEL_33:
            int32x2_t v28 = *v19;
            int32x2_t *v19 = (int32x2_t)result;
            CA::Render::Texture *result = v28;
            result[1] = (int32x2_t)v19;
            *(void *)(*(void *)&v28 + 8) = result;
            v7[25].i32[1] = v23;
          }
        }
      }
    }
  }
  return result;
}

void CA::Render::ImageProvider::signal_client(CA::Render::ImageProvider *this)
{
  mach_msg_return_t v6;
  mach_msg_header_t msg;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;

  BOOL v11 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
  if (*((_DWORD *)this + 52) == *((_DWORD *)this + 51) || (uint64_t v2 = *((void *)this + 21)) == 0) {
    mach_port_t v3 = 0;
  }
  else {
    mach_port_t v3 = *(_DWORD *)(v2 + 256);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
  int v4 = *((_DWORD *)this + 51);
  if (*((_DWORD *)this + 52) != v4)
  {
    uint64_t v5 = *((void *)this + 22);
    if (v3)
    {
      __int32 v8 = *MEMORY[0x1E4F14068];
      __int32 v9 = v5;
      __int32 v10 = v4;
      *(void *)&msg.msgh_bits = 19;
      msg.msgh_voucher_port = 0;
      msg.msgh_id = 40408;
      msg.msgh_remote_port = v3;
      msg.msgh_local_port = 0;
      if (MEMORY[0x1E4F14B18]) {
        voucher_mach_msg_set(&msg);
      }
      uint64_t v6 = mach_msg(&msg, 17, 0x2Cu, 0, 0, 0, 0);
      if ((v6 - 268435459) <= 1)
      {
        if ((msg.msgh_bits & 0x1F00) == 0x1100) {
          mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
        }
        mach_msg_destroy(&msg);
        return;
      }
      if (v6) {
        return;
      }
    }
    else
    {
      CAImageProviderSignal(v5, v4);
    }
    *((_DWORD *)this + 52) = *((_DWORD *)this + 51);
  }
}

atomic_uint *CA::Render::ImageProvider::generate_subtexture(CA::Render::ImageProvider *this, int a2, int a3, int a4, int a5, unsigned int a6, double a7, unsigned int *a8)
{
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  *(void *)&v106[0] = __PAIR64__(a3, a2);
  DWORD2(v106[0]) = a4;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
  uint64_t v14 = x_hash_table_lookup(*((void *)this + 18), (uint64_t)v106, 0);
  if (v14 && (*(_DWORD *)(v14 + 52) & 0x20002) == 2)
  {
    unsigned int v15 = *(atomic_uint **)(v14 + 24);
    if (v15)
    {
      __int32 v16 = v15 + 2;
      if (!atomic_fetch_add(v15 + 2, 1u))
      {
        unsigned int v15 = 0;
        atomic_fetch_add(v16, 0xFFFFFFFF);
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    return v15;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
  unsigned int v101 = a2 - 1;
  uint64_t v91 = a8;
  int v90 = a2;
  if (a2 >= 1 && *((_DWORD *)this + 26) >= a2)
  {
    int v19 = *((_DWORD *)this + 27);
    BOOL v20 = __OFSUB__(v101, v19);
    int v21 = v101 - v19;
    unsigned int v22 = *((_DWORD *)this + 4);
    unsigned int v23 = *((_DWORD *)this + 5);
    unsigned int v24 = v22 >> v21;
    unsigned int v25 = v22 << -(char)v21;
    if (v21 < 0 != v20) {
      unsigned int v17 = v25;
    }
    else {
      unsigned int v17 = v24;
    }
    unsigned int v26 = v23 << -(char)v21;
    unsigned int v27 = v23 >> v21;
    if (v21 >= 0) {
      unsigned int v18 = v27;
    }
    else {
      unsigned int v18 = v26;
    }
  }
  else
  {
    unsigned int v17 = 0;
    unsigned int v18 = 0;
  }
  uint64_t v28 = 0;
  int v29 = 0;
  memset(v106, 0, sizeof(v106));
  int v92 = a3;
  int v93 = a4;
  int v30 = 2 * a3;
  int v95 = 2 * a4;
  char v96 = 0;
  char v99 = 0;
  unint64_t v98 = -1;
  do
  {
    uint64_t v31 = 0;
    int v32 = 0;
    int v97 = v29;
    int v33 = v29 + v95;
    do
    {
      float64x2_t v34 = (uint64_t *)&v106[v28] + v31;
      *float64x2_t v34 = 0;
      if (*((_DWORD *)this + 24) * (v30 + v32) < v17 && *((_DWORD *)this + 25) * v33 < v18)
      {
        uint64_t v105 = 0;
        uint64_t v35 = (*(uint64_t (**)(CA::Render::ImageProvider *, void, void, void, uint64_t, uint64_t, void, void, double, char *, uint64_t *))(*(void *)this + 256))(this, v101, v30 | v31, v95 | v28, 0xFFFFFFFFLL, 1, 0, a6, a7, (char *)&v105 + 4, &v105);
        if (!v35) {
          goto LABEL_32;
        }
        if (*(unsigned char *)(v35 + 12) != 23 || (unsigned int v36 = *(unsigned __int8 *)(v35 + 152), (v36 & 0xFFFFFFFD) != 1))
        {
          if (atomic_fetch_add((atomic_uint *volatile)(v35 + 8), 0xFFFFFFFF) == 1) {
            (*(void (**)(uint64_t))(*(void *)v35 + 16))(v35);
          }
LABEL_32:
          char v99 = 1;
          goto LABEL_33;
        }
        if (v98 >= v36) {
          unsigned int v37 = *(unsigned __int8 *)(v35 + 152);
        }
        else {
          unsigned int v37 = v98;
        }
        unsigned int v38 = HIDWORD(v98);
        if (HIDWORD(v98) >= v105) {
          unsigned int v38 = v105;
        }
        unint64_t v98 = __PAIR64__(v38, v37);
        *float64x2_t v34 = v35;
        char v96 = 1;
      }
LABEL_33:
      ++v32;
      uint64_t v31 = 1;
    }
    while (v32 != 2);
    int v29 = v97 + 1;
    uint64_t v28 = 1;
  }
  while (v97 != 1);
  if ((v96 & 1) == 0) {
    return 0;
  }
  int v39 = *((_DWORD *)this + 24);
  int v40 = *((_DWORD *)this + 25);
  int v41 = v92;
  if (v39 * v92 + v39 <= v17 >> 1) {
    unsigned int v42 = *((_DWORD *)this + 24);
  }
  else {
    unsigned int v42 = (v17 >> 1) - v39 * v92;
  }
  int v43 = v93;
  if (v40 * v93 + v40 <= v18 >> 1) {
    unsigned int v44 = *((_DWORD *)this + 25);
  }
  else {
    unsigned int v44 = (v18 >> 1) - v40 * v93;
  }
  if ((v99 & 1) == 0)
  {
    float v50 = CA::Render::Shmem::new_bitmap((CA::Render::Shmem *)v98, v42, v44, 0, 0, 1u);
    if (v50)
    {
      uint64_t v100 = v50;
      int v47 = (_DWORD *)*((void *)v50 + 3);
      goto LABEL_53;
    }
LABEL_90:
    unsigned int v15 = 0;
    int v81 = 6;
    int v80 = HIDWORD(v98);
    goto LABEL_91;
  }
  if (*((void *)this + 15)) {
    goto LABEL_90;
  }
  uint64_t v45 = *((unsigned char *)this + 112) == 0xFF ? (CA::Render::Shmem *)v98 : (CA::Render::Shmem *)1;
  uint64_t v46 = CA::Render::Shmem::new_bitmap(v45, v42, v44, 0, 0, 1u);
  if (!v46) {
    goto LABEL_90;
  }
  int v47 = (_DWORD *)*((void *)v46 + 3);
  uint64_t v100 = v46;
  if (*((_DWORD *)this + 28))
  {
    HIDWORD(v48) = *((_DWORD *)this + 28);
    LODWORD(v48) = HIDWORD(v48);
    CA::Render::ShmemBitmap::fill_pixels((uint64_t)v47, (v48 >> 8), 0);
    int v49 = 262150;
    goto LABEL_54;
  }
LABEL_53:
  int v49 = 6;
LABEL_54:
  int v102 = v49;
  int v51 = 0;
  uint64_t v52 = 0;
  char v53 = 1;
  while (2)
  {
    uint64_t v54 = 0;
    char v104 = v53;
    int v55 = v51 & a5;
    char v56 = v51 | a5;
    char v57 = 1;
    while (2)
    {
      char v58 = v57;
      uint64_t v59 = *((void *)&v106[v52] + v54);
      if (v59)
      {
        unsigned int v60 = v47[4] <= 1u ? 1 : v47[4];
        unint64_t v61 = CA::Render::format_rowbytes((CA::Render *)v47[3], v60);
        double v62 = (char *)v47 + (int)v47[2];
        if (v55)
        {
          unint64_t v63 = (unint64_t)*((unsigned int *)this + 25) >> 1;
          v62 += v61 * v63;
          int v64 = v44 - v63;
        }
        else if (v56)
        {
          int v64 = v44;
        }
        else
        {
          unsigned int v65 = *((_DWORD *)this + 25);
          int v64 = v44;
          if (v44 > v65 >> 1)
          {
            int v64 = v65 >> 1;
            v62 += v61 * (v44 - (v65 >> 1));
          }
        }
        if (v58)
        {
          unsigned int v66 = v42;
        }
        else
        {
          unsigned int v67 = *((_DWORD *)this + 24);
          v62 += (2 * v67) & 0xFFFFFFFC;
          unsigned int v66 = v42 - (v67 >> 1);
        }
        if ((int)v66 >= 1 && v64 >= 1)
        {
          uint64_t v68 = *(void *)(v59 + 160);
          uint64_t v69 = *(void *)(v59 + 96);
          unint64_t v71 = *(unsigned int *)(v59 + 16);
          unsigned int v70 = *(_DWORD *)(v59 + 20);
          unsigned int v72 = v71 >> 1;
          if (v66 < v71 >> 1) {
            unsigned int v72 = v66;
          }
          if (*(unsigned char *)(v59 + 152) == 3) {
            int v73 = -16777216;
          }
          else {
            int v73 = 0;
          }
          if (v64 < v70 >> 1)
          {
LABEL_79:
            uint64_t v74 = 2 * v68;
            uint64_t v75 = v69 + v68;
            unint64_t v76 = v71 >> 1;
            if (v76 < v66) {
              unsigned int v66 = v76;
            }
            do
            {
              if (v72)
              {
                uint64_t v77 = 0;
                do
                {
                  v78.i64[0] = *(void *)(v69 + 8 * v77);
                  v78.i64[1] = *(void *)(v75 + 8 * v77);
                  unsigned long long v79 = *(_OWORD *)&vshrq_n_u32(v78, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL);
                  v78.i16[0] = v78.u8[0];
                  v78.i16[1] = BYTE2(*(void *)(v69 + 8 * v77));
                  v78.i16[2] = BYTE4(*(void *)(v69 + 8 * v77));
                  v78.i16[3] = BYTE6(*(void *)(v69 + 8 * v77));
                  v78.i16[4] = v78.u8[8];
                  v78.i16[5] = BYTE2(*(void *)(v75 + 8 * v77));
                  v78.i16[6] = BYTE4(*(void *)(v75 + 8 * v77));
                  v78.i16[7] = BYTE6(*(void *)(v75 + 8 * v77));
                  *(_DWORD *)&v62[4 * v77++] = (vaddvq_s32((int32x4_t)v78) >> 2) & 0xFF00FF | v73 | (vaddvq_s32((int32x4_t)v79) << 6) & 0xFF00FF00;
                }
                while (v66 != v77);
              }
              v62 += v61;
              v69 += v74;
              v75 += v74;
              --v64;
            }
            while (v64);
          }
          else if (v70 >= 2)
          {
            int v64 = v70 >> 1;
            goto LABEL_79;
          }
        }
      }
      char v57 = 0;
      uint64_t v54 = 1;
      if (v58) {
        continue;
      }
      break;
    }
    char v53 = 0;
    int v51 = 1;
    uint64_t v52 = 1;
    if (v104) {
      continue;
    }
    break;
  }
  unsigned int v15 = (atomic_uint *)CA::Render::Shmem::copy_image((CA::Render::Shmem *)v100, 0);
  if (atomic_fetch_add(v100 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v100 + 16))(v100);
  }
  int v41 = v92;
  int v43 = v93;
  int v80 = HIDWORD(v98);
  int v81 = v102;
LABEL_91:
  CA::Render::ImageProvider::set_subimage(this, v90, v41, v43, v15, v81, v80);
  uint64_t v82 = 0;
  char v83 = 1;
  do
  {
    uint64_t v84 = 0;
    char v85 = v83;
    char v86 = 1;
    do
    {
      char v87 = v86;
      uint64_t v88 = (atomic_uint *)*((void *)&v106[v82] + v84);
      if (v88 && atomic_fetch_add(v88 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v88 + 16))(v88);
      }
      char v86 = 0;
      uint64_t v84 = 1;
    }
    while ((v87 & 1) != 0);
    char v83 = 0;
    uint64_t v82 = 1;
  }
  while ((v85 & 1) != 0);
  *uint64_t v91 = v80;
  return v15;
}

void CA::Render::ImageProvider::set_subimage(CA::Render::ImageProvider *this, int a2, int a3, int a4, atomic_uint *a5, int a6, int a7)
{
  *(void *)&v32[3] = *MEMORY[0x1E4F143B8];
  if (a5)
  {
    unint64_t v12 = a5[4];
    unint64_t v11 = a5[5];
    if (a2 < 0) {
      return;
    }
  }
  else
  {
    unint64_t v12 = 0;
    unint64_t v11 = 0;
    if (a2 < 0) {
      return;
    }
  }
  if (*((_DWORD *)this + 26) > a2 && v12 <= *((unsigned int *)this + 24) && v11 <= *((unsigned int *)this + 25))
  {
    v32[0] = a2;
    v32[1] = a3;
    _OWORD v32[2] = a4;
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    uint64_t v13 = x_hash_table_lookup(*((void *)this + 18), (uint64_t)v32, 0);
    if (!v13)
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      uint64_t v13 = (uint64_t)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x58uLL, 0x743898A5uLL);
      *(_DWORD *)(v13 + 48) = v32[2];
      *(void *)(v13 + 40) = *(void *)v32;
      *(void *)(v13 + 16) = this;
      uint64_t v15 = mach_absolute_time();
      *(double *)(v13 + 80) = CATimeWithHostTime(v15);
      hash_table_modify(*((int **)this + 18), v13 + 40, v13, 0);
    }
    __int32 v16 = *(atomic_uint **)(v13 + 24);
    if (a5)
    {
      unsigned int v17 = a5;
      if (!atomic_fetch_add(a5 + 2, 1u))
      {
        unsigned int v17 = 0;
        atomic_fetch_add(a5 + 2, 0xFFFFFFFF);
      }
      *(void *)(v13 + 24) = v17;
      uint64_t v18 = (*(uint64_t (**)(atomic_uint *))(*(void *)a5 + 168))(a5);
    }
    else
    {
      uint64_t v18 = 0;
      *(void *)(v13 + 24) = 0;
    }
    *(void *)(v13 + 32) = v18;
    *(_DWORD *)(v13 + 52) = a6;
    int v19 = *(_DWORD *)(v13 + 60);
    if (a7)
    {
      *(_DWORD *)(v13 + 56) = a7;
      if (v19 != a7) {
        *(_DWORD *)(v13 + 52) = a6 | 0x10000;
      }
      if ((a6 & 0x40000) == 0) {
        goto LABEL_19;
      }
    }
    else
    {
      *(_DWORD *)(v13 + 56) = v19;
      if ((a6 & 0x40000) == 0)
      {
LABEL_19:
        int v20 = 0;
        goto LABEL_22;
      }
    }
    int v20 = *((_DWORD *)this + 28);
LABEL_22:
    *(_DWORD *)(v13 + 64) = v20;
    if ((a6 & 4) != 0 || v16)
    {
      *(void *)(v13 + 72) = 0xD4B249AD2594C37DLL;
      if (v16)
      {
        unsigned int v25 = *(void **)(v13 + 8);
        if (v25) {
          *unsigned int v25 = *(void *)v13;
        }
        if (*(void *)v13) {
          unsigned int v26 = (uint64_t *)(*(void *)v13 + 8);
        }
        else {
          unsigned int v26 = &CA::Render::subimage_head;
        }
        *unsigned int v26 = (uint64_t)v25;
      }
    }
    else
    {
      uint64_t v21 = mach_absolute_time();
      double v22 = CATimeWithHostTime(v21);
      *(double *)(v13 + 72) = v22;
      float v23 = *((float *)this + 33);
      if (v23 > 0.0)
      {
        double v24 = v22 + v23;
        if (*((double *)this + 23) > v24) {
          double v24 = *((double *)this + 23);
        }
        *((double *)this + 23) = v24;
      }
    }
    if (a5)
    {
      *(void *)uint64_t v13 = 0;
      unsigned int v27 = (uint64_t *)CA::Render::subimage_head;
      *(void *)(v13 + 8) = CA::Render::subimage_head;
      if (v27) {
        *unsigned int v27 = v13;
      }
      CA::Render::subimage_head = v13;
    }
    if ((a6 & 2) == 0)
    {
      uint64_t v28 = (uint64_t *)*((void *)this + 20);
      while (v28 != (uint64_t *)((char *)this + 152))
      {
        int v29 = v28;
        uint64_t v28 = (uint64_t *)v28[1];
        if ((*((_DWORD *)this + 50) - *((_DWORD *)v29 + 10)) > 4
          || (*(_DWORD *)(v13 + 52) & 0x10002) == 0
          && *((_DWORD *)v29 + 4) == v32[0]
          && *(uint64_t *)((char *)v29 + 20) == *(void *)&v32[1])
        {
          uint64_t v30 = *v29;
          *(void *)(v30 + 8) = v28;
          *uint64_t v28 = v30;
          *int v29 = (uint64_t)v29;
          v29[1] = (uint64_t)v29;
          uint64_t v31 = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(v31, v29);
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    if (v16)
    {
      if (atomic_fetch_add(v16 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v16 + 16))(v16);
      }
    }
  }
}

uint64_t CA::Render::ImageProvider::copy_subtexture(CA::Render::ImageProvider *this, __int32 a2, __int32 a3, __int32 a4, __int32 a5, int a6, char a7, int a8, double a9, float *a10, unsigned int *a11)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if ((a2 & 0x80000000) == 0 && *((_DWORD *)this + 26) > a2)
  {
    int v12 = *((_DWORD *)this + 34);
    if (v12 < 1 || v12 >= a6)
    {
      *((_DWORD *)this + 50) = a8;
      *((double *)this + 24) = a9;
      v34[0] = a2;
      v34[1] = a3;
      v34[2] = a4;
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
      uint64_t v16 = x_hash_table_lookup(*((void *)this + 18), (uint64_t)v34, 0);
      unsigned int v17 = (int32x2_t *)v16;
      if (!v16)
      {
LABEL_52:
        int32x2_t v21 = 0;
LABEL_53:
        CA::Render::ImageProvider::add_needed((int32x2_t *)this, v34, a5, v17);
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
        CA::Render::ImageProvider::signal_client(this);
        return (uint64_t)v21;
      }
      uint64_t v18 = *(void *)(v16 + 24);
      unsigned int v19 = v17[6].u32[1];
      if (v18) {
        BOOL v20 = (v19 & 0x20000) == 0;
      }
      else {
        BOOL v20 = 1;
      }
      if (!v20)
      {
        if (!(*(unsigned int (**)(uint64_t, void))(*(void *)v18 + 192))(v18, 0))
        {
          uint64_t v28 = (int32x2_t *)v17[1];
          if (v28) {
            *uint64_t v28 = *v17;
          }
          if (*v17) {
            int v29 = (uint64_t *)(*(void *)v17 + 8);
          }
          else {
            int v29 = &CA::Render::subimage_head;
          }
          *int v29 = (uint64_t)v28;
          uint64_t v30 = (atomic_uint *)v17[3];
LABEL_49:
          if (atomic_fetch_add(v30 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v30 + 16))(v30);
          }
LABEL_51:
          x_hash_table_remove_ptr(*((void *)this + 18), (uint64_t)&v17[5]);
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(malloc_zone, v17);
          unsigned int v17 = 0;
          goto LABEL_52;
        }
        unsigned int v19 = v17[6].i32[1] & 0xFFFDFFFF;
        v17[6].i32[1] = v19;
      }
      if ((v19 & 0x40000) == 0 || v17[8].i32[0] == *((_DWORD *)this + 28))
      {
        v17[10] = *(int32x2_t *)((char *)this + 192);
        if (a7) {
          v17[9] = (int32x2_t)0xD4B249AD2594C37DLL;
        }
        int32x2_t v21 = v17[3];
        if (v21)
        {
          double v22 = (atomic_uint *)(*(void *)&v21 + 8);
          if (!atomic_fetch_add((atomic_uint *volatile)(*(void *)&v21 + 8), 1u))
          {
            int32x2_t v21 = 0;
            atomic_fetch_add(v22, 0xFFFFFFFF);
          }
          float v23 = 1.0;
          if ((v17[6].i8[4] & 4) == 0)
          {
            float v23 = (*((double *)this + 24) - *(double *)&v17[9]) / *((float *)this + 33);
            if (v23 > 1.0) {
              float v23 = 1.0;
            }
            if (v23 < 0.0) {
              float v23 = 0.0;
            }
          }
          *a10 = v23;
          double v24 = (int32x2_t *)v17[1];
          if (v24) {
            int32x2_t *v24 = *v17;
          }
          if (*v17) {
            unsigned int v25 = (uint64_t *)(*(void *)v17 + 8);
          }
          else {
            unsigned int v25 = &CA::Render::subimage_head;
          }
          *unsigned int v25 = (uint64_t)v24;
          int32x2_t *v17 = 0;
          unsigned int v26 = (int32x2_t **)CA::Render::subimage_head;
          v17[1] = (int32x2_t)CA::Render::subimage_head;
          if (v26) {
            *unsigned int v26 = v17;
          }
          CA::Render::subimage_head = (uint64_t)v17;
        }
        *a11 = v17[7].u32[0];
        goto LABEL_53;
      }
      uint64_t v31 = (int32x2_t *)v17[1];
      if (v31) {
        int32x2_t *v31 = *v17;
      }
      if (*v17) {
        int v32 = (uint64_t *)(*(void *)v17 + 8);
      }
      else {
        int v32 = &CA::Render::subimage_head;
      }
      *int v32 = (uint64_t)v31;
      uint64_t v30 = (atomic_uint *)v17[3];
      if (!v30) {
        goto LABEL_51;
      }
      goto LABEL_49;
    }
  }
  return 0;
}

uint64_t CA::Render::ImageProvider::implicitly_opaque(CA::Render::ImageProvider *this)
{
  return *((unsigned __int8 *)this + 128);
}

void CA::Render::ImageProvider::show(CA::Render::ImageProvider *this, int a2, uint64_t a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  BOOL v6 = x_log_hook_p();
  if ((a3 & 1) == 0)
  {
    if (v6)
    {
      x_log_();
    }
    else
    {
      float v7 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = *((_DWORD *)this + 4);
        int v9 = *((_DWORD *)this + 5);
        int v10 = *((_DWORD *)this + 24);
        int v11 = *((_DWORD *)this + 25);
        int v12 = *((_DWORD *)this + 26);
        int v13 = *((_DWORD *)this + 27);
        *(_DWORD *)buf = 67110400;
        int v30 = v8;
        __int16 v31 = 1024;
        int v32 = v9;
        __int16 v33 = 1024;
        int v34 = v10;
        __int16 v35 = 1024;
        int v36 = v11;
        __int16 v37 = 1024;
        int v38 = v12;
        __int16 v39 = 1024;
        int v40 = v13;
        _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_DEFAULT, "(image-provider [%d %d] [%d %d] [%d %d]", buf, 0x26u);
      }
    }
    if (*((void *)this + 15))
    {
      uint64_t v14 = (CA::Render *)(a2 + 1);
      CA::Render::show_newline(v14);
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v15 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184668000, v15, OS_LOG_TYPE_DEFAULT, "(fillColor ", buf, 2u);
        }
      }
      (*(void (**)(void, CA::Render *, uint64_t))(**((void **)this + 15) + 40))(*((void *)this + 15), v14, a3);
      if (x_log_hook_p())
      {
LABEL_15:
        x_log_();
        goto LABEL_21;
      }
      uint64_t v16 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        unsigned int v17 = ")";
        uint64_t v18 = v16;
        uint32_t v19 = 2;
LABEL_20:
        _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_DEFAULT, v17, buf, v19);
      }
    }
    else
    {
      if (!*((_DWORD *)this + 28)) {
        goto LABEL_21;
      }
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p()) {
        goto LABEL_15;
      }
      uint64_t v20 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        int v21 = *((_DWORD *)this + 28);
        *(_DWORD *)buf = 67109120;
        int v30 = v21;
        unsigned int v17 = "(fillColor #%08x ";
        uint64_t v18 = v20;
        uint32_t v19 = 8;
        goto LABEL_20;
      }
    }
LABEL_21:
    if (x_log_hook_p())
    {
LABEL_22:
      x_log_();
      return;
    }
    uint64_t v22 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      float v23 = ")";
      double v24 = v22;
      uint32_t v25 = 2;
LABEL_25:
      _os_log_impl(&dword_184668000, v24, OS_LOG_TYPE_DEFAULT, v23, buf, v25);
      return;
    }
    return;
  }
  if (v6) {
    goto LABEL_22;
  }
  uint64_t v26 = x_log_category_render;
  if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
  {
    int v27 = *((_DWORD *)this + 4);
    int v28 = *((_DWORD *)this + 5);
    *(_DWORD *)buf = 67109376;
    int v30 = v27;
    __int16 v31 = 1024;
    int v32 = v28;
    float v23 = "<image-provider [%d %d]>";
    double v24 = v26;
    uint32_t v25 = 14;
    goto LABEL_25;
  }
}

void CA::Render::ImageProvider::~ImageProvider(CA::Render::ImageProvider *this)
{
  CA::Render::ImageProvider::~ImageProvider(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t **i;
  CA::Render::ImageProvider *v6;
  CA::Render::ImageProvider *v7;
  malloc_zone_t *malloc_zone;
  atomic_uint *v9;
  uint64_t vars8;

  *(void *)this = &unk_1ED02DAB0;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
  uint64_t v2 = 0;
  mach_port_t v3 = *((void *)this + 18);
  int v4 = 1 << *(_DWORD *)v3;
  do
  {
    for (uint64_t i = *(uint64_t ***)(*(void *)(v3 + 16) + 8 * v2); i; uint64_t i = (uint64_t **)*i)
      CA::Render::free_subimage((uint64_t)i[2], i[3]);
    ++v2;
  }
  while (v2 != v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
  x_hash_table_free(*((void **)this + 18));
  BOOL v6 = (CA::Render::ImageProvider *)*((void *)this + 20);
  if (v6 != (CA::Render::ImageProvider *)((char *)this + 152))
  {
    do
    {
      float v7 = (CA::Render::ImageProvider *)*((void *)v6 + 1);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v6);
      BOOL v6 = v7;
    }
    while (v7 != (CA::Render::ImageProvider *)((char *)this + 152));
  }
  --dword_1EB2ADE28;
  *(void *)this = &unk_1ED02D680;
  int v9 = (atomic_uint *)*((void *)this + 15);
  if (v9 && atomic_fetch_add(v9 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v9 + 16))(v9);
  }

  CA::Render::Texture::~Texture((CGColorSpaceRef *)this);
}

uint64_t CA::Render::TiledTexture::prefetch_border(CA::Render::TiledTexture *this)
{
  return 0;
}

uint64_t CA::Render::TiledTexture::generate_subtexture(CA::Render::TiledTexture *this, int a2, unsigned int a3, unsigned int a4, BOOL a5, unsigned int a6, double a7, unsigned int *a8)
{
  return 0;
}

uint64_t CA::Render::Texture::implicitly_opaque(CA::Render::Texture *this)
{
  return 0;
}

void CA::Render::free_subimage(uint64_t a1, void *a2)
{
  mach_port_t v3 = (atomic_uint *)a2[3];
  if (v3)
  {
    if (atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
    }
    int v4 = (void *)a2[1];
    if (v4) {
      *int v4 = *a2;
    }
    if (*a2) {
      uint64_t v5 = (uint64_t *)(*a2 + 8);
    }
    else {
      uint64_t v5 = &CA::Render::subimage_head;
    }
    uint64_t *v5 = (uint64_t)v4;
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, a2);
}

BOOL CA::Render::key_compare(_DWORD *a1, _DWORD *a2)
{
  return *a1 != *a2 || a1[1] != a2[1] || a1[2] != a2[2];
}

unint64_t CA::Render::key_hash(_DWORD *a1)
{
  uint64_t v1 = ((a1[1] << 10) ^ (*a1 << 20)) ^ a1[2];
  unint64_t v2 = (~(v1 << 32) + v1) ^ ((unint64_t)(~(v1 << 32) + v1) >> 22);
  unint64_t v3 = 9 * ((v2 + ~(v2 << 13)) ^ ((v2 + ~(v2 << 13)) >> 8));
  unint64_t v4 = (v3 ^ (v3 >> 15)) + ~((v3 ^ (v3 >> 15)) << 27);
  return v4 ^ (v4 >> 31);
}

void CA::Render::ImageProvider::create(CA::Render::ImageProvider *this, CA::Render::Context *a2, unsigned int a3, unsigned int a4, unsigned int a5, int a6, int a7, int a8, float a9, int a10, char a11, BOOL a12, int a13, unsigned int a14, CA::Render::Pattern *a15)
{
  if (a6 && a7 && ((a10 | a8) & 0x80000000) == 0)
  {
    if (a4 >= a5) {
      unsigned int v23 = a5;
    }
    else {
      unsigned int v23 = a4;
    }
    int v24 = 1;
    if (v23 >= 2)
    {
      do
      {
        ++v24;
        BOOL v25 = v23 > 3;
        v23 >>= 1;
      }
      while (v25);
    }
    int v26 = v24 + a10;
    if (!__OFADD__(v24, a10))
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      int v28 = (CA::Render::Texture *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xD8uLL, 0x743898A5uLL);
      if (v28)
      {
        int v29 = v28;
        if (v26 >= a8) {
          int v26 = a8;
        }
        int v30 = CA::Render::Texture::Texture(v28, a4, a5);
        *((_DWORD *)v30 + 24) = a6;
        *((_DWORD *)v30 + 25) = a7;
        *((_DWORD *)v30 + 26) = v26;
        *((_DWORD *)v30 + 27) = a10;
        *((_DWORD *)v30 + 28) = 0;
        *((void *)v30 + 15) = 0;
        *((unsigned char *)v30 + 12) = 24;
        ++dword_1EB2ADE28;
        *(void *)int v30 = &unk_1ED02DAB0;
        *((unsigned char *)v30 + 128) = a11;
        *((float *)v30 + 33) = a9;
        *((_DWORD *)v30 + 34) = 0;
        *((_DWORD *)v30 + 35) = a13;
        __int16 v31 = x_hash_table_new_((unint64_t (*)(uint64_t))CA::Render::key_hash, (BOOL (*)(uint64_t, uint64_t))CA::Render::key_compare, 0, 0, 0, 0);
        *((void *)v29 + 23) = 0;
        *((void *)v29 + 24) = 0;
        *((void *)v29 + 25) = 0;
        *((void *)v29 + 26) = 0x100000000;
        *((void *)v29 + 18) = v31;
        *((void *)v29 + 19) = (char *)v29 + 152;
        *((void *)v29 + 20) = (char *)v29 + 152;
        if (*((unsigned char *)v29 + 128)) {
          *((_DWORD *)v29 + 3) |= 0x1000u;
        }
        *((void *)v29 + 21) = this;
        *((void *)v29 + 22) = a2;
        CA::Render::TiledTexture::set_fill_color(v29, a14, (Pattern *)a15);
        CA::Render::Context::set_object(this, (unint64_t)a2, a3, v29);
      }
    }
  }
}

void CA::Render::ImageProvider::invalidate(CA::Render::ImageProvider *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  unsigned int v7 = a2 & ~(a2 >> 31);
  unsigned int v8 = a3 & ~(a3 >> 31);
  signed int v9 = *((_DWORD *)this + 4);
  signed int v10 = *((_DWORD *)this + 5);
  if ((int)((a2 & (a2 >> 31)) + a4 + v7) <= v9) {
    int v11 = (a2 & (a2 >> 31)) + a4;
  }
  else {
    int v11 = v9 - v7;
  }
  if ((int)((a3 & (a3 >> 31)) + a5 + v8) <= v10) {
    int v12 = (a3 & (a3 >> 31)) + a5;
  }
  else {
    int v12 = v10 - v8;
  }
  if (v11 >= 1 && v12 >= 1)
  {
    char v14 = a7;
    uint64_t v33 = 0;
    int v34 = 0;
    v32[1] = a7;
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    int v17 = *((_DWORD *)this + 53);
    if (a6 == -1 && (v14 & 1) == 0) {
      *((_DWORD *)this + 53) = ++v17;
    }
    unsigned int v18 = *((_DWORD *)this + 24);
    unsigned int v19 = *((_DWORD *)this + 25);
    int v20 = v7 / v18;
    int v21 = v8 / v19;
    unsigned int v22 = (v7 + v11 - 1) / v18;
    v32[0] = v17;
    LODWORD(v33) = a6;
    int v23 = *((_DWORD *)this + 27);
    unsigned int v24 = (v8 + v12 - 1) / v19;
    if (v23 >= 1)
    {
      do
      {
        v20 *= 2;
        v21 *= 2;
        unsigned int v22 = (2 * v22) | 1;
        unsigned int v24 = (2 * v24) | 1;
        --v23;
      }
      while (v23);
    }
    uint64_t v25 = 0;
    _OWORD v32[2] = v20;
    v32[3] = v21;
    v32[4] = v22;
    _DWORD v32[5] = v24;
    uint64_t v26 = *((void *)this + 18);
    uint64_t v27 = 1 << *(_DWORD *)v26;
    do
    {
      for (uint64_t i = *(void **)(*(void *)(v26 + 16) + 8 * v25); i; uint64_t i = (void *)*i)
        CA::Render::invalidate_callback(i[2], i[3], (uint64_t)v32);
      ++v25;
    }
    while (v25 != v27);
    int v29 = v34;
    if (v34)
    {
      int v30 = v34;
      do
      {
        x_hash_table_remove_ptr(*((void *)this + 18), (uint64_t)(v30 + 5));
        int v30 = (void *)*v30;
      }
      while (v30);
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
      do
      {
        __int16 v31 = (atomic_uint *)v29[3];
        if (v31)
        {
          if (atomic_fetch_add(v31 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v31 + 16))(v31);
          }
        }
        int v29 = (void *)*v29;
      }
      while (v29);
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    }
  }
}

void CA::Render::invalidate_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3 || (*(unsigned char *)(a3 + 4) & 1) == 0)
  {
    int v4 = *(_DWORD *)(a2 + 40);
    int v5 = *(_DWORD *)(a3 + 24);
    if (v5 == -1 || v4 == v5)
    {
      int v7 = *(_DWORD *)(a2 + 44);
      if (v7 >= *(int *)(a3 + 8) >> v4 && v7 <= *(int *)(a3 + 16) >> v4)
      {
        int v8 = *(_DWORD *)(a2 + 48);
        if (v8 >= *(int *)(a3 + 12) >> v4 && v8 <= *(int *)(a3 + 20) >> v4)
        {
          *(_DWORD *)(a2 + 60) = *(_DWORD *)a3;
          *(_DWORD *)(a2 + 52) |= 0x10000u;
          if (v3)
          {
            if ((*(unsigned char *)(a3 + 4) & 2) != 0)
            {
              signed int v9 = *(void **)(a2 + 8);
              if (v9) {
                void *v9 = *(void *)a2;
              }
              if (*(void *)a2) {
                signed int v10 = (uint64_t *)(*(void *)a2 + 8);
              }
              else {
                signed int v10 = &CA::Render::subimage_head;
              }
              *signed int v10 = (uint64_t)v9;
              *(void *)a2 = *(void *)(a3 + 32);
              *(void *)(a3 + 32) = a2;
            }
          }
        }
      }
    }
  }
}

void CA::Render::ImageProvider::set_image_size(CA::Render::ImageProvider *this, CA::Render::Context *a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  int v7 = (int *)CA::Render::Context::lookup_object((uint64_t)this, (int)a2, a3, 0, 24, 0);
  if (v7)
  {
    int v8 = v7;
    unsigned int v10 = v7[4];
    unsigned int v9 = v7[5];
    if (a4 != v10 || a5 != v9)
    {
      if (a4 <= v10)
      {
        int v14 = a5 - v9;
        if (a5 > v9)
        {
          int v12 = 0;
          int v13 = v7[5];
          int v15 = a4;
          goto LABEL_11;
        }
      }
      else
      {
        CA::Render::ImageProvider::invalidate((CA::Render::ImageProvider *)v7, v7[4], 0, a4 - v10, a5, -1, 0);
        if (a5 > v9)
        {
          CA::Render::ImageProvider::invalidate((CA::Render::ImageProvider *)v8, 0, v9, a5 - v9, a4, -1, 0);
          int v7 = v8;
          int v12 = v10;
          int v13 = v9;
          int v14 = a4 - v10;
          int v15 = a5 - v9;
LABEL_11:
          CA::Render::ImageProvider::invalidate((CA::Render::ImageProvider *)v7, v12, v13, v14, v15, -1, 0);
        }
      }
      v8[4] = a4;
      v8[5] = a5;
    }
  }
}

CA::Render::TiledTexture *CA::Render::ImageProvider::set_fill_color(CA::Render::ImageProvider *this, CA::Render::Context *a2, uint64_t a3, int a4, Pattern *a5)
{
  __n128 result = (CA::Render::TiledTexture *)CA::Render::Context::lookup_object((uint64_t)this, (int)a2, a3, 0, 24, 0);
  if (result)
  {
    return (CA::Render::TiledTexture *)CA::Render::TiledTexture::set_fill_color(result, a4, a5);
  }
  return result;
}

void CA::Render::ImageProvider::set_subimage(CA::Render::ImageProvider *this, CA::Render::Context *a2, uint64_t a3, int a4, int a5, int a6, CA::Render::Texture *a7, int a8, unsigned int a9)
{
  int v14 = (CA::Render::ImageProvider *)CA::Render::Context::lookup_object((uint64_t)this, (int)a2, a3, 0, 24, 0);
  if (v14)
  {
    if (a7)
    {
      if (*((unsigned char *)a7 + 12) == 24) {
        return;
      }
      int v15 = a4;
      int v16 = a5;
      int v17 = a6;
      unsigned int v18 = (atomic_uint *)a7;
    }
    else
    {
      int v15 = a4;
      int v16 = a5;
      int v17 = a6;
      unsigned int v18 = 0;
    }
    CA::Render::ImageProvider::set_subimage(v14, v15, v16, v17, v18, a8, a9);
  }
}

void CA::Render::ImageProvider::invalidate(CA::Render::ImageProvider *this, CA::Render::Context *a2, uint64_t a3, int a4, int a5, int a6, int a7, int a8, unsigned int a9)
{
  int v14 = (CA::Render::ImageProvider *)CA::Render::Context::lookup_object((uint64_t)this, (int)a2, a3, 0, 24, 0);
  if (v14)
  {
    CA::Render::ImageProvider::invalidate(v14, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t CA::Render::ImageProvider::needed_subimage(CA::Render::ImageProvider *this, CA::Render::Context *a2, uint64_t a3, unsigned int *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7)
{
  uint64_t result = CA::Render::Context::lookup_object((uint64_t)this, (int)a2, a3, 0, 24, 0);
  if (result)
  {
    uint64_t v12 = result;
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    int v13 = (void *)(v12 + 152);
    int v14 = *(void **)(v12 + 160);
    if (v14 == v13)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
      return 0;
    }
    else
    {
      uint64_t v16 = *v14;
      int v15 = (void *)v14[1];
      *(void *)(v16 + 8) = v15;
      *int v15 = v16;
      *int v14 = v14;
      v14[1] = v14;
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
      *a4 = *((_DWORD *)v14 + 4);
      *a5 = *((_DWORD *)v14 + 5);
      *a6 = *((_DWORD *)v14 + 6);
      *a7 = *((_DWORD *)v14 + 8);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v14);
      return 1;
    }
  }
  return result;
}

uint64_t CARenderServerGetDebugOption(mach_port_name_t a1, int a2)
{
  mach_msg_return_t v7;
  int v8;
  BOOL v9;
  int v10;
  int msg;
  unsigned char msg_4[44];
  uint64_t v13;

  int v13 = *MEMORY[0x1E4F143B8];
  mach_port_name_t v4 = a1;
  if (a1 || (result = CARenderServerGetServerPort(0), (mach_port_name_t v4 = result) != 0))
  {
    memset(&msg_4[16], 0, 28);
    *(_OWORD *)msg_4 = 0u;
    *(void *)&msg_4[20] = *MEMORY[0x1E4F14068];
    *(_DWORD *)&msg_4[28] = a2;
    mach_port_t reply_port = mig_get_reply_port();
    *(_DWORD *)&msg_4[4] = v4;
    *(_DWORD *)&msg_4[8] = reply_port;
    msg = 5395;
    *(void *)&msg_4[12] = 0x9D4300000000;
    if (MEMORY[0x1E4F14B18])
    {
      voucher_mach_msg_set((mach_msg_header_t *)&msg);
      mach_port_t reply_port = *(_DWORD *)&msg_4[8];
    }
    int v7 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x30u, reply_port, 0, 0);
    int v8 = v7;
    if ((v7 - 268435458) <= 0xE && ((1 << (v7 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
      goto LABEL_27;
    }
    if (v7)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
      goto LABEL_26;
    }
    if (*(_DWORD *)&msg_4[16] == 71)
    {
      int v8 = -308;
    }
    else if (*(_DWORD *)&msg_4[16] == 40359)
    {
      if ((msg & 0x80000000) == 0)
      {
        if (*(_DWORD *)msg_4 == 40)
        {
          if (!*(_DWORD *)&msg_4[4])
          {
            int v8 = *(_DWORD *)&msg_4[28];
            if (!*(_DWORD *)&msg_4[28])
            {
              unsigned int v10 = *(_DWORD *)&msg_4[32];
              if (a1) {
                return v10 != 0;
              }
              goto LABEL_28;
            }
            goto LABEL_25;
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          if (*(_DWORD *)&msg_4[4]) {
            unsigned int v9 = 1;
          }
          else {
            unsigned int v9 = *(_DWORD *)&msg_4[28] == 0;
          }
          if (v9) {
            int v8 = -300;
          }
          else {
            int v8 = *(_DWORD *)&msg_4[28];
          }
          goto LABEL_25;
        }
      }
      int v8 = -300;
    }
    else
    {
      int v8 = -301;
    }
LABEL_25:
    mach_msg_destroy((mach_msg_header_t *)&msg);
LABEL_26:
    if (v8 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
LABEL_27:
    unsigned int v10 = 0;
    if (a1) {
      return v10 != 0;
    }
LABEL_28:
    mach_port_deallocate(*MEMORY[0x1E4F14960], v4);
    return v10 != 0;
  }
  return result;
}

void CARenderServerSetDebugOption(mach_port_name_t a1, int a2, int a3)
{
  mach_msg_return_t v8;
  int v9;
  ipc_space_t v10;
  unsigned char msg[36];
  uint64_t v12;
  uint64_t v13;
  uint64_t vars8;

  int v13 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return;
    }
  }
  memset(&msg[4], 0, 32);
  uint64_t v12 = 0;
  *(void *)&msg[24] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&msg[32] = a2;
  LODWORD(v12) = a3;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = ServerPort;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(void *)&msg[16] = 0x9D4400000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_t reply_port = *(_DWORD *)&msg[12];
  }
  int v8 = mach_msg((mach_msg_header_t *)msg, 3, 0x28u, 0x2Cu, reply_port, 0, 0);
  unsigned int v9 = v8;
  if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_21;
  }
  if (v8)
  {
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_20;
  }
  if (*(_DWORD *)&msg[20] == 71)
  {
    unsigned int v9 = -308;
LABEL_19:
    mach_msg_destroy((mach_msg_header_t *)msg);
LABEL_20:
    if (v9 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
  if (*(_DWORD *)&msg[20] != 40360)
  {
    unsigned int v9 = -301;
    goto LABEL_19;
  }
  unsigned int v9 = -300;
  if ((*(_DWORD *)msg & 0x80000000) != 0) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[4] != 36) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[8]) {
    goto LABEL_19;
  }
  unsigned int v9 = *(_DWORD *)&msg[32];
  if (*(_DWORD *)&msg[32]) {
    goto LABEL_19;
  }
LABEL_21:
  if (!a1)
  {
    unsigned int v10 = *MEMORY[0x1E4F14960];
    mach_port_deallocate(v10, ServerPort);
  }
}

void CARenderServerClearDebugOptions(mach_port_name_t a1)
{
  mach_msg_return_t v4;
  int v5;
  ipc_space_t v6;
  unsigned char msg[36];
  uint64_t v8;
  uint64_t v9;
  uint64_t vars8;

  unsigned int v9 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return;
    }
  }
  int v8 = 0;
  *(_DWORD *)&msg[4] = 0;
  *(_OWORD *)&msg[20] = 0u;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = ServerPort;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(void *)&msg[16] = 0x9D4500000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_t reply_port = *(_DWORD *)&msg[12];
  }
  mach_port_name_t v4 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x2Cu, reply_port, 0, 0);
  int v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_21;
  }
  if (v4)
  {
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_20;
  }
  if (*(_DWORD *)&msg[20] == 71)
  {
    int v5 = -308;
LABEL_19:
    mach_msg_destroy((mach_msg_header_t *)msg);
LABEL_20:
    if (v5 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
  if (*(_DWORD *)&msg[20] != 40361)
  {
    int v5 = -301;
    goto LABEL_19;
  }
  int v5 = -300;
  if ((*(_DWORD *)msg & 0x80000000) != 0) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[4] != 36) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[8]) {
    goto LABEL_19;
  }
  int v5 = *(_DWORD *)&msg[32];
  if (*(_DWORD *)&msg[32]) {
    goto LABEL_19;
  }
LABEL_21:
  if (!a1)
  {
    BOOL v6 = *MEMORY[0x1E4F14960];
    mach_port_deallocate(v6, ServerPort);
  }
}

void CARenderServerClearColorDebugOptions(mach_port_name_t a1)
{
  mach_msg_return_t v4;
  int v5;
  ipc_space_t v6;
  unsigned char msg[36];
  uint64_t v8;
  uint64_t v9;
  uint64_t vars8;

  unsigned int v9 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return;
    }
  }
  int v8 = 0;
  *(_DWORD *)&msg[4] = 0;
  *(_OWORD *)&msg[20] = 0u;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = ServerPort;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(void *)&msg[16] = 0x9D4600000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_t reply_port = *(_DWORD *)&msg[12];
  }
  mach_port_name_t v4 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x2Cu, reply_port, 0, 0);
  int v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_21;
  }
  if (v4)
  {
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_20;
  }
  if (*(_DWORD *)&msg[20] == 71)
  {
    int v5 = -308;
LABEL_19:
    mach_msg_destroy((mach_msg_header_t *)msg);
LABEL_20:
    if (v5 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
  if (*(_DWORD *)&msg[20] != 40362)
  {
    int v5 = -301;
    goto LABEL_19;
  }
  int v5 = -300;
  if ((*(_DWORD *)msg & 0x80000000) != 0) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[4] != 36) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[8]) {
    goto LABEL_19;
  }
  int v5 = *(_DWORD *)&msg[32];
  if (*(_DWORD *)&msg[32]) {
    goto LABEL_19;
  }
LABEL_21:
  if (!a1)
  {
    BOOL v6 = *MEMORY[0x1E4F14960];
    mach_port_deallocate(v6, ServerPort);
  }
}

uint64_t CARenderServerGetDebugFlags(mach_port_t a1)
{
  mach_msg_return_t v4;
  mach_port_t msgh_remote_port;
  BOOL v6;
  uint64_t msgh_local_port;
  mach_msg_header_t msg[2];
  uint64_t v10;

  unsigned int v10 = *MEMORY[0x1E4F143B8];
  mach_port_t ServerPort = a1;
  if (!a1)
  {
    mach_port_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0;
    }
  }
  *(_OWORD *)&msg[1].msgh_remote_port = 0u;
  *(_OWORD *)&msg[0].msgh_id = 0u;
  msg[0].msgh_size = 0;
  mach_port_t reply_port = mig_get_reply_port();
  msg[0].msgh_remote_port = ServerPort;
  msg[0].msgh_local_port = reply_port;
  msg[0].msgh_bits = 5395;
  *(void *)&msg[0].msgh_voucher_port = 0x9D4700000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(msg);
    mach_port_t reply_port = msg[0].msgh_local_port;
  }
  mach_port_name_t v4 = mach_msg(msg, 3, 0x18u, 0x30u, reply_port, 0, 0);
  msgh_remote_port = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg[0].msgh_local_port);
    goto LABEL_28;
  }
  if (v4)
  {
    mig_dealloc_reply_port(msg[0].msgh_local_port);
    goto LABEL_27;
  }
  if (msg[0].msgh_id == 71)
  {
    msgh_remote_port = -308;
  }
  else if (msg[0].msgh_id == 40363)
  {
    if ((msg[0].msgh_bits & 0x80000000) == 0)
    {
      if (msg[0].msgh_size == 40)
      {
        if (!msg[0].msgh_remote_port)
        {
          msgh_remote_port = msg[1].msgh_remote_port;
          if (!msg[1].msgh_remote_port)
          {
            msgh_local_port = msg[1].msgh_local_port;
            if (a1) {
              return msgh_local_port;
            }
            goto LABEL_29;
          }
          goto LABEL_26;
        }
      }
      else if (msg[0].msgh_size == 36)
      {
        if (msg[0].msgh_remote_port) {
          BOOL v6 = 1;
        }
        else {
          BOOL v6 = msg[1].msgh_remote_port == 0;
        }
        if (v6) {
          msgh_remote_port = -300;
        }
        else {
          msgh_remote_port = msg[1].msgh_remote_port;
        }
        goto LABEL_26;
      }
    }
    msgh_remote_port = -300;
  }
  else
  {
    msgh_remote_port = -301;
  }
LABEL_26:
  mach_msg_destroy(msg);
LABEL_27:
  if (msgh_remote_port == -81182719)
  {
    x_log_crash("Unentitled call to server!");
    abort();
  }
LABEL_28:
  msgh_local_port = 0;
  if (!a1) {
LABEL_29:
  }
    mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
  return msgh_local_port;
}

void CARenderServerSetDebugFlags(mach_port_name_t a1, int a2, int a3)
{
  mach_msg_return_t v8;
  int v9;
  ipc_space_t v10;
  unsigned char msg[36];
  uint64_t v12;
  uint64_t v13;
  uint64_t vars8;

  int v13 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return;
    }
  }
  memset(&msg[4], 0, 32);
  uint64_t v12 = 0;
  *(void *)&msg[24] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&msg[32] = a2;
  LODWORD(v12) = a3;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = ServerPort;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(void *)&msg[16] = 0x9D4800000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_t reply_port = *(_DWORD *)&msg[12];
  }
  int v8 = mach_msg((mach_msg_header_t *)msg, 3, 0x28u, 0x2Cu, reply_port, 0, 0);
  unsigned int v9 = v8;
  if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_21;
  }
  if (v8)
  {
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_20;
  }
  if (*(_DWORD *)&msg[20] == 71)
  {
    unsigned int v9 = -308;
LABEL_19:
    mach_msg_destroy((mach_msg_header_t *)msg);
LABEL_20:
    if (v9 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
  if (*(_DWORD *)&msg[20] != 40364)
  {
    unsigned int v9 = -301;
    goto LABEL_19;
  }
  unsigned int v9 = -300;
  if ((*(_DWORD *)msg & 0x80000000) != 0) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[4] != 36) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[8]) {
    goto LABEL_19;
  }
  unsigned int v9 = *(_DWORD *)&msg[32];
  if (*(_DWORD *)&msg[32]) {
    goto LABEL_19;
  }
LABEL_21:
  if (!a1)
  {
    unsigned int v10 = *MEMORY[0x1E4F14960];
    mach_port_deallocate(v10, ServerPort);
  }
}

float CARenderServerGetDebugValueFloat(mach_port_name_t a1, int a2)
{
  mach_msg_return_t v6;
  int v7;
  float v8;
  BOOL v9;
  int msg;
  unsigned char msg_4[44];
  uint64_t v13;

  int v13 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0.0;
    }
  }
  memset(&msg_4[16], 0, 28);
  *(_OWORD *)msg_4 = 0u;
  *(void *)&msg_4[20] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&msg_4[28] = a2;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = ServerPort;
  *(_DWORD *)&msg_4[8] = reply_port;
  msg = 5395;
  *(void *)&msg_4[12] = 0x9D4900000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    mach_port_t reply_port = *(_DWORD *)&msg_4[8];
  }
  BOOL v6 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x30u, reply_port, 0, 0);
  int v7 = v6;
  if ((v6 - 268435458) > 0xE || ((1 << (v6 - 2)) & 0x4003) == 0)
  {
    if (v6)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
      goto LABEL_28;
    }
    if (*(_DWORD *)&msg_4[16] == 71)
    {
      int v7 = -308;
    }
    else if (*(_DWORD *)&msg_4[16] == 40365)
    {
      if ((msg & 0x80000000) == 0)
      {
        if (*(_DWORD *)msg_4 == 40)
        {
          if (!*(_DWORD *)&msg_4[4])
          {
            int v7 = *(_DWORD *)&msg_4[28];
            if (!*(_DWORD *)&msg_4[28])
            {
              int v8 = *(float *)&msg_4[32];
              if (a1) {
                return v8;
              }
              goto LABEL_30;
            }
            goto LABEL_27;
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          if (*(_DWORD *)&msg_4[4]) {
            unsigned int v9 = 1;
          }
          else {
            unsigned int v9 = *(_DWORD *)&msg_4[28] == 0;
          }
          if (v9) {
            int v7 = -300;
          }
          else {
            int v7 = *(_DWORD *)&msg_4[28];
          }
          goto LABEL_27;
        }
      }
      int v7 = -300;
    }
    else
    {
      int v7 = -301;
    }
LABEL_27:
    mach_msg_destroy((mach_msg_header_t *)&msg);
LABEL_28:
    int v8 = 0.0;
    if (v7 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    if (!a1) {
      goto LABEL_30;
    }
    return v8;
  }
  mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
  int v8 = 0.0;
  if (!a1) {
LABEL_30:
  }
    mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
  return v8;
}

uint64_t CARenderServerGetDebugValue(mach_port_name_t a1, int a2)
{
  return CARenderServerGetDebugValueFloat(a1, a2);
}

void CARenderServerSetDebugValueFloat(mach_port_name_t a1, int a2, float a3)
{
  mach_msg_return_t v8;
  int v9;
  ipc_space_t v10;
  unsigned char msg[36];
  uint64_t v12;
  uint64_t v13;
  uint64_t vars8;

  int v13 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return;
    }
  }
  memset(&msg[4], 0, 32);
  uint64_t v12 = 0;
  *(void *)&msg[24] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&msg[32] = a2;
  *(float *)&uint64_t v12 = a3;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = ServerPort;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(void *)&msg[16] = 0x9D4A00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_t reply_port = *(_DWORD *)&msg[12];
  }
  int v8 = mach_msg((mach_msg_header_t *)msg, 3, 0x28u, 0x2Cu, reply_port, 0, 0);
  unsigned int v9 = v8;
  if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_21;
  }
  if (v8)
  {
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_20;
  }
  if (*(_DWORD *)&msg[20] == 71)
  {
    unsigned int v9 = -308;
LABEL_19:
    mach_msg_destroy((mach_msg_header_t *)msg);
LABEL_20:
    if (v9 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
  if (*(_DWORD *)&msg[20] != 40366)
  {
    unsigned int v9 = -301;
    goto LABEL_19;
  }
  unsigned int v9 = -300;
  if ((*(_DWORD *)msg & 0x80000000) != 0) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[4] != 36) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[8]) {
    goto LABEL_19;
  }
  unsigned int v9 = *(_DWORD *)&msg[32];
  if (*(_DWORD *)&msg[32]) {
    goto LABEL_19;
  }
LABEL_21:
  if (!a1)
  {
    unsigned int v10 = *MEMORY[0x1E4F14960];
    mach_port_deallocate(v10, ServerPort);
  }
}

void CARenderServerSetDebugValue(mach_port_name_t a1, int a2, unsigned int a3)
{
}

void CARenderServerDebugBrightness(int a1, double a2)
{
  if (a1)
  {
    _CASDebugBrightness(a1, a2);
  }
  else
  {
    int ServerPort = CARenderServerGetServerPort(0);
    if (ServerPort)
    {
      mach_port_name_t v4 = ServerPort;
      _CASDebugBrightness(ServerPort, a2);
      ipc_space_t v5 = *MEMORY[0x1E4F14960];
      mach_port_deallocate(v5, v4);
    }
  }
}

void CARenderServerDebugPreset(int a1, int a2)
{
  if (a1)
  {
    _CASDebugPreset(a1, a2);
  }
  else
  {
    int ServerPort = CARenderServerGetServerPort(0);
    if (ServerPort)
    {
      mach_port_name_t v4 = ServerPort;
      _CASDebugPreset(ServerPort, a2);
      ipc_space_t v5 = *MEMORY[0x1E4F14960];
      mach_port_deallocate(v5, v4);
    }
  }
}

void CARenderServerDebugFrameInfo(int a1)
{
  if (a1)
  {
    _CASDebugFrameInfo(a1);
  }
  else
  {
    int ServerPort = CARenderServerGetServerPort(0);
    if (ServerPort)
    {
      mach_port_name_t v2 = ServerPort;
      _CASDebugFrameInfo(ServerPort);
      ipc_space_t v3 = *MEMORY[0x1E4F14960];
      mach_port_deallocate(v3, v2);
    }
  }
}

void CARenderServerSetMessageFile(mach_port_name_t a1, char *__source)
{
  mach_msg_return_t v8;
  mach_port_t msgh_remote_port;
  _OWORD v10[16];
  mach_msg_header_t msg[12];
  uint64_t v12;
  uint64_t v13;

  int v13 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (a1 || (mach_port_name_t ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    memset(v10, 0, sizeof(v10));
    strlcpy((char *)v10, __source, 0x100uLL);
    uint64_t v12 = 0;
    memset(msg, 0, sizeof(msg));
    *(void *)&msg[1].msgh_bits = *MEMORY[0x1E4F14068];
    if (MEMORY[0x1E4F149B0]) {
      mach_port_t v5 = mig_strncpy_zerofill((char *)&msg[1].msgh_voucher_port, (const char *)v10, 256);
    }
    else {
      mach_port_t v5 = mig_strncpy((char *)&msg[1].msgh_voucher_port, (const char *)v10, 256);
    }
    msg[1].msgh_local_port = v5;
    msg[1].msgh_remote_port = 0;
    mach_msg_size_t v6 = ((v5 + 3) & 0xFFFFFFFC) + 40;
    mach_port_t reply_port = mig_get_reply_port();
    msg[0].msgh_bits = 5395;
    *(void *)&msg[0].msgh_remote_port = __PAIR64__(reply_port, ServerPort);
    *(void *)&msg[0].msgh_voucher_port = 0x9D4E00000000;
    if (MEMORY[0x1E4F14B18])
    {
      voucher_mach_msg_set(msg);
      mach_port_t reply_port = msg[0].msgh_local_port;
    }
    int v8 = mach_msg(msg, 3, v6, 0x2Cu, reply_port, 0, 0);
    msgh_remote_port = v8;
    if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(msg[0].msgh_local_port);
LABEL_23:
      if (!a1) {
        mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
      }
      return;
    }
    if (v8)
    {
      mig_dealloc_reply_port(msg[0].msgh_local_port);
    }
    else
    {
      if (msg[0].msgh_id == 71)
      {
        msgh_remote_port = -308;
      }
      else if (msg[0].msgh_id == 40370)
      {
        msgh_remote_port = -300;
        if ((msg[0].msgh_bits & 0x80000000) == 0 && *(void *)&msg[0].msgh_size == 36)
        {
          msgh_remote_port = msg[1].msgh_remote_port;
          if (!msg[1].msgh_remote_port) {
            goto LABEL_23;
          }
        }
      }
      else
      {
        msgh_remote_port = -301;
      }
      mach_msg_destroy(msg);
    }
    if (msgh_remote_port == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_23;
  }
}

void CARenderServerSetDebugMessage(mach_port_name_t a1, char *__source, int a3)
{
  mach_msg_return_t v12;
  int v13;
  long long v14;
  long long v15;
  long long v16;
  long long v17;
  long long v18;
  long long v19;
  long long v20;
  long long v21;
  long long v22;
  long long v23;
  long long v24;
  long long v25;
  long long v26;
  long long v27;
  long long v28;
  long long v29;
  unsigned char msg[32];
  _OWORD v31[15];
  _OWORD v32[2];
  uint64_t v33;

  uint64_t v33 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (a1 || (mach_port_name_t ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    long long v7 = 0uLL;
    int v28 = 0u;
    int v29 = 0u;
    uint64_t v26 = 0u;
    uint64_t v27 = 0u;
    unsigned int v24 = 0u;
    uint64_t v25 = 0u;
    unsigned int v22 = 0u;
    int v23 = 0u;
    int v20 = 0u;
    int v21 = 0u;
    unsigned int v18 = 0u;
    unsigned int v19 = 0u;
    uint64_t v16 = 0u;
    int v17 = 0u;
    int v14 = 0u;
    int v15 = 0u;
    if (__source)
    {
      strlcpy((char *)&v14, __source, 0x100uLL);
      long long v7 = 0uLL;
    }
    *(_OWORD *)((char *)v32 + 12) = v7;
    if ((a3 & 0xF) != 0) {
      int v8 = a3;
    }
    else {
      int v8 = -1;
    }
    v31[14] = v7;
    v32[0] = v7;
    v31[12] = v7;
    v31[13] = v7;
    v31[10] = v7;
    v31[11] = v7;
    v31[8] = v7;
    v31[9] = v7;
    v31[6] = v7;
    v31[7] = v7;
    v31[4] = v7;
    v31[5] = v7;
    v31[2] = v7;
    v31[3] = v7;
    v31[0] = v7;
    v31[1] = v7;
    *(_OWORD *)msg = v7;
    *(_OWORD *)&msg[16] = v7;
    *(void *)&msg[24] = *MEMORY[0x1E4F14068];
    if (MEMORY[0x1E4F149B0]) {
      int v9 = mig_strncpy_zerofill((char *)v31 + 8, (const char *)&v14, 256);
    }
    else {
      int v9 = mig_strncpy((char *)v31 + 8, (const char *)&v14, 256);
    }
    DWORD1(v31[0]) = v9;
    LODWORD(v31[0]) = 0;
    mach_msg_size_t v10 = ((v9 + 3) & 0xFFFFFFFC) + 44;
    *(_DWORD *)((char *)v31 + ((v9 + 3) & 0xFFFFFFFC) + 8) = v8;
    mach_port_t reply_port = mig_get_reply_port();
    *(_DWORD *)msg = 5395;
    *(void *)&msg[8] = __PAIR64__(reply_port, ServerPort);
    *(void *)&msg[16] = 0x9D4F00000000;
    if (MEMORY[0x1E4F14B18])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      mach_port_t reply_port = *(_DWORD *)&msg[12];
    }
    uint64_t v12 = mach_msg((mach_msg_header_t *)msg, 3, v10, 0x2Cu, reply_port, 0, 0);
    int v13 = v12;
    if ((v12 - 268435458) <= 0xE && ((1 << (v12 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
LABEL_28:
      if (!a1) {
        mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
      }
      return;
    }
    if (v12)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    }
    else
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        int v13 = -308;
      }
      else if (*(_DWORD *)&msg[20] == 40371)
      {
        int v13 = -300;
        if ((*(_DWORD *)msg & 0x80000000) == 0 && *(void *)&msg[4] == 36)
        {
          int v13 = v31[0];
          if (!LODWORD(v31[0])) {
            goto LABEL_28;
          }
        }
      }
      else
      {
        int v13 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
    if (v13 == -81182719)
    {
      x_log_crash("Unentitled call to server!", v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29);
      abort();
    }
    goto LABEL_28;
  }
}

void CARenderServerSetOverdriveLUTFile(mach_port_name_t a1, char *__source)
{
  mach_msg_return_t v8;
  mach_port_t msgh_remote_port;
  _OWORD v10[16];
  mach_msg_header_t msg[12];
  uint64_t v12;
  uint64_t v13;

  int v13 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (a1 || (mach_port_name_t ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    memset(v10, 0, sizeof(v10));
    strlcpy((char *)v10, __source, 0x100uLL);
    uint64_t v12 = 0;
    memset(msg, 0, sizeof(msg));
    *(void *)&msg[1].msgh_bits = *MEMORY[0x1E4F14068];
    if (MEMORY[0x1E4F149B0]) {
      mach_port_t v5 = mig_strncpy_zerofill((char *)&msg[1].msgh_voucher_port, (const char *)v10, 256);
    }
    else {
      mach_port_t v5 = mig_strncpy((char *)&msg[1].msgh_voucher_port, (const char *)v10, 256);
    }
    msg[1].msgh_local_port = v5;
    msg[1].msgh_remote_port = 0;
    mach_msg_size_t v6 = ((v5 + 3) & 0xFFFFFFFC) + 40;
    mach_port_t reply_port = mig_get_reply_port();
    msg[0].msgh_bits = 5395;
    *(void *)&msg[0].msgh_remote_port = __PAIR64__(reply_port, ServerPort);
    *(void *)&msg[0].msgh_voucher_port = 0x9D5000000000;
    if (MEMORY[0x1E4F14B18])
    {
      voucher_mach_msg_set(msg);
      mach_port_t reply_port = msg[0].msgh_local_port;
    }
    int v8 = mach_msg(msg, 3, v6, 0x2Cu, reply_port, 0, 0);
    msgh_remote_port = v8;
    if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(msg[0].msgh_local_port);
LABEL_23:
      if (!a1) {
        mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
      }
      return;
    }
    if (v8)
    {
      mig_dealloc_reply_port(msg[0].msgh_local_port);
    }
    else
    {
      if (msg[0].msgh_id == 71)
      {
        msgh_remote_port = -308;
      }
      else if (msg[0].msgh_id == 40372)
      {
        msgh_remote_port = -300;
        if ((msg[0].msgh_bits & 0x80000000) == 0 && *(void *)&msg[0].msgh_size == 36)
        {
          msgh_remote_port = msg[1].msgh_remote_port;
          if (!msg[1].msgh_remote_port) {
            goto LABEL_23;
          }
        }
      }
      else
      {
        msgh_remote_port = -301;
      }
      mach_msg_destroy(msg);
    }
    if (msgh_remote_port == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_23;
  }
}

void CARenderServerSetAXMatrix(mach_port_t a1, long long *a2)
{
  mach_msg_return_t v7;
  int v8;
  mach_msg_header_t v9;
  uint64_t v10;
  long long v11;
  long long v12;
  uint64_t v13;
  uint64_t v14;

  int v14 = *MEMORY[0x1E4F143B8];
  mach_port_t ServerPort = a1;
  if (a1 || (mach_port_t ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    long long v5 = a2[1];
    int v11 = *a2;
    uint64_t v12 = v5;
    int v13 = *((void *)a2 + 4);
    mach_msg_size_t v10 = *MEMORY[0x1E4F14068];
    mach_port_t reply_port = mig_get_reply_port();
    *(void *)&v9.msgh_bits = 5395;
    v9.msgh_remote_port = ServerPort;
    v9.msgh_local_port = reply_port;
    *(void *)&v9.msgh_voucher_port = 0x9D5100000000;
    if (MEMORY[0x1E4F14B18])
    {
      voucher_mach_msg_set(&v9);
      mach_port_t reply_port = v9.msgh_local_port;
    }
    long long v7 = mach_msg(&v9, 3, 0x48u, 0x2Cu, reply_port, 0, 0);
    int v8 = v7;
    if ((v7 - 268435458) <= 0xE && ((1 << (v7 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(v9.msgh_local_port);
LABEL_20:
      if (!a1) {
        mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
      }
      return;
    }
    if (v7)
    {
      mig_dealloc_reply_port(v9.msgh_local_port);
    }
    else
    {
      if (v9.msgh_id == 71)
      {
        int v8 = -308;
      }
      else if (v9.msgh_id == 40373)
      {
        int v8 = -300;
        if ((v9.msgh_bits & 0x80000000) == 0 && *(void *)&v9.msgh_size == 36)
        {
          int v8 = v11;
          if (!v11) {
            goto LABEL_20;
          }
        }
      }
      else
      {
        int v8 = -301;
      }
      mach_msg_destroy(&v9);
    }
    if (v8 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_20;
  }
}

void CARenderServerSetScreenTelemetryParameters()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v0 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v1 = 0;
      _os_log_impl(&dword_184668000, v0, OS_LOG_TYPE_ERROR, "CARenderServerSetScreenTelemetryParameters is deprecated!", v1, 2u);
    }
  }
}

unsigned char *CARenderServerGetInfo(mach_port_name_t a1, int a2, uint64_t a3)
{
  mach_msg_return_t v8;
  int v9;
  unsigned char *v10;
  unsigned int v11;
  const void *v12;
  size_t v14;
  unsigned char *v15;
  int msg;
  unsigned char msg_4[60];
  uint64_t v18;

  unsigned int v18 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0;
    }
  }
  memset(&msg_4[16], 0, 44);
  *(_OWORD *)msg_4 = 0u;
  *(void *)&msg_4[20] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&msg_4[28] = a2;
  *(void *)&msg_4[32] = a3;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = ServerPort;
  *(_DWORD *)&msg_4[8] = reply_port;
  msg = 5395;
  *(void *)&msg_4[12] = 0x9D5200000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    mach_port_t reply_port = *(_DWORD *)&msg_4[8];
  }
  int v8 = mach_msg((mach_msg_header_t *)&msg, 3, 0x2Cu, 0x40u, reply_port, 0, 0);
  int v9 = v8;
  if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
  }
  else
  {
    if (v8)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
    }
    else
    {
      if (*(_DWORD *)&msg_4[16] == 71)
      {
        int v9 = -308;
      }
      else if (*(_DWORD *)&msg_4[16] == 40374)
      {
        if (msg < 0)
        {
          int v9 = -300;
          if (*(_DWORD *)&msg_4[20] == 1 && *(_DWORD *)msg_4 == 56 && !*(_DWORD *)&msg_4[4] && msg_4[35] == 1)
          {
            int v11 = *(_DWORD *)&msg_4[36];
            if (*(_DWORD *)&msg_4[36] == *(_DWORD *)&msg_4[48])
            {
              int v9 = 0;
              uint64_t v12 = *(const void **)&msg_4[24];
              goto LABEL_31;
            }
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          int v9 = -300;
          if (*(_DWORD *)&msg_4[28])
          {
            if (*(_DWORD *)&msg_4[4]) {
              int v9 = -300;
            }
            else {
              int v9 = *(_DWORD *)&msg_4[28];
            }
          }
        }
        else
        {
          int v9 = -300;
        }
      }
      else
      {
        int v9 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
    }
    if (v9 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
  }
  uint64_t v12 = 0;
  int v11 = 0;
LABEL_31:
  if (v9)
  {
    mach_msg_size_t v10 = 0;
    if (!a1) {
LABEL_33:
    }
      mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
  }
  else
  {
    int v14 = v11;
    int v15 = malloc_type_malloc(v11 + 1, 0x636A25D7uLL);
    mach_msg_size_t v10 = v15;
    if (v15)
    {
      memcpy(v15, v12, v14);
      v10[v14] = 0;
    }
    mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)v12, v14);
    if (!a1) {
      goto LABEL_33;
    }
  }
  return v10;
}

CFPropertyListRef CARenderServerCopyUpdateHistograms(mach_port_name_t a1, int a2)
{
  mach_msg_return_t v6;
  int v7;
  unsigned int v8;
  const UInt8 *v9;
  CFAllocatorRef v10;
  CFDataRef v11;
  CFPropertyListRef v12;
  int msg;
  unsigned char msg_4[60];
  uint64_t v16;

  uint64_t v16 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0;
    }
  }
  memset(&msg_4[16], 0, 44);
  *(_OWORD *)msg_4 = 0u;
  *(void *)&msg_4[20] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&msg_4[28] = a2;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = ServerPort;
  *(_DWORD *)&msg_4[8] = reply_port;
  msg = 5395;
  *(void *)&msg_4[12] = 0x9D3D00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    mach_port_t reply_port = *(_DWORD *)&msg_4[8];
  }
  mach_msg_size_t v6 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x40u, reply_port, 0, 0);
  long long v7 = v6;
  if ((v6 - 268435458) <= 0xE && ((1 << (v6 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
  }
  else
  {
    if (v6)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
    }
    else
    {
      if (*(_DWORD *)&msg_4[16] == 71)
      {
        long long v7 = -308;
      }
      else if (*(_DWORD *)&msg_4[16] == 40353)
      {
        if (msg < 0)
        {
          long long v7 = -300;
          if (*(_DWORD *)&msg_4[20] == 1 && *(_DWORD *)msg_4 == 56 && !*(_DWORD *)&msg_4[4] && msg_4[35] == 1)
          {
            int v8 = *(_DWORD *)&msg_4[36];
            if (*(_DWORD *)&msg_4[36] == *(_DWORD *)&msg_4[48])
            {
              long long v7 = 0;
              int v9 = *(const UInt8 **)&msg_4[24];
              goto LABEL_30;
            }
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          long long v7 = -300;
          if (*(_DWORD *)&msg_4[28])
          {
            if (*(_DWORD *)&msg_4[4]) {
              long long v7 = -300;
            }
            else {
              long long v7 = *(_DWORD *)&msg_4[28];
            }
          }
        }
        else
        {
          long long v7 = -300;
        }
      }
      else
      {
        long long v7 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
    }
    if (v7 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
  }
  int v9 = 0;
  int v8 = 0;
LABEL_30:
  if (!a1)
  {
    mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
    if (!v7) {
      goto LABEL_34;
    }
    return 0;
  }
  if (v7) {
    return 0;
  }
LABEL_34:
  mach_msg_size_t v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF98];
  int v11 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF98], v9, v8);
  mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)v9, v8);
  if (!v11) {
    return 0;
  }
  uint64_t v12 = CFPropertyListCreateWithData(v10, v11, 0, 0, 0);
  CFRelease(v11);
  return v12;
}

CFPropertyListRef CARenderServerCopyODStatistics(mach_port_name_t a1)
{
  mach_msg_return_t v4;
  int v5;
  unsigned int v6;
  const UInt8 *v7;
  CFAllocatorRef v8;
  CFDataRef v9;
  CFPropertyListRef v10;
  int msg;
  int msg_4;
  mach_port_name_t msg_8;
  mach_port_t msg_12;
  unsigned char msg_16[48];
  uint64_t v17;

  int v17 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0;
    }
  }
  memset(&msg_16[4], 0, 44);
  msg_4 = 0;
  mach_port_t reply_port = mig_get_reply_port();
  msg_8 = ServerPort;
  msg_12 = reply_port;
  msg = 5395;
  *(void *)msg_16 = 0x9D3E00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    mach_port_t reply_port = msg_12;
  }
  mach_port_name_t v4 = mach_msg((mach_msg_header_t *)&msg, 3, 0x18u, 0x40u, reply_port, 0, 0);
  long long v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg_12);
  }
  else
  {
    if (v4)
    {
      mig_dealloc_reply_port(msg_12);
    }
    else
    {
      if (*(_DWORD *)&msg_16[4] == 71)
      {
        long long v5 = -308;
      }
      else if (*(_DWORD *)&msg_16[4] == 40354)
      {
        if (msg < 0)
        {
          long long v5 = -300;
          if (*(_DWORD *)&msg_16[8] == 1 && msg_4 == 56 && !msg_8 && msg_16[23] == 1)
          {
            mach_msg_size_t v6 = *(_DWORD *)&msg_16[24];
            if (*(_DWORD *)&msg_16[24] == *(_DWORD *)&msg_16[36])
            {
              long long v5 = 0;
              long long v7 = *(const UInt8 **)&msg_16[12];
              goto LABEL_30;
            }
          }
        }
        else if (msg_4 == 36)
        {
          long long v5 = -300;
          if (*(_DWORD *)&msg_16[16])
          {
            if (msg_8) {
              long long v5 = -300;
            }
            else {
              long long v5 = *(_DWORD *)&msg_16[16];
            }
          }
        }
        else
        {
          long long v5 = -300;
        }
      }
      else
      {
        long long v5 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
    }
    if (v5 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
  }
  long long v7 = 0;
  mach_msg_size_t v6 = 0;
LABEL_30:
  if (!a1)
  {
    mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
    if (!v5) {
      goto LABEL_34;
    }
    return 0;
  }
  if (v5) {
    return 0;
  }
LABEL_34:
  int v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF98];
  int v9 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF98], v7, v6);
  mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)v7, v6);
  if (!v9) {
    return 0;
  }
  mach_msg_size_t v10 = CFPropertyListCreateWithData(v8, v9, 0, 0, 0);
  CFRelease(v9);
  return v10;
}

CFIndex CARenderServerGetStatistics(mach_port_name_t a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  CFArrayRef v3 = (const __CFArray *)CARenderServerCopyDictionaries(a1);
  if (!v3) {
    return 0;
  }
  CFArrayRef v4 = v3;
  CFIndex Count = CFArrayGetCount(v3);
  mach_msg_size_t v6 = malloc_type_malloc(8 * Count, 0x10040436913F5uLL);
  *a2 = v6;
  if (v6)
  {
    int v23 = a2;
    if (Count)
    {
      uint64_t v7 = 0;
      CFIndex v8 = 0;
      int v9 = @"kCADisplayDeviceName";
      do
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v4, v8);
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"kCADisplayName");
        uint64_t v12 = CFDictionaryGetValue(ValueAtIndex, v9);
        if (Value && v12)
        {
          memset(v26, 0, sizeof(v26));
          int Int = CA_CFDictionaryGetInt(ValueAtIndex, @"kCADisplayFrameCount");
          int v25 = CA_CFDictionaryGetInt(ValueAtIndex, @"kCADisplaySkippedFrameCount");
          int v24 = CA_CFDictionaryGetInt(ValueAtIndex, @"kCADisplayClonedFrameCount");
          int v14 = v9;
          int v15 = CA_CFDictionaryGetInt(ValueAtIndex, @"kCADisplaySkippedClonedFrameCount");
          CFIndex v16 = Count;
          int v17 = Int - CA_CFDictionaryGetInt(ValueAtIndex, @"kCADisplayDirtyFrameCount");
          unsigned int v18 = (char **)(*v23 + v7);
          CString = CA_CFStringGetCString(Value, (char *)v26, 256);
          int v21 = v15;
          int v22 = v17;
          CFIndex Count = v16;
          int v9 = v14;
          asprintf(v18, "%s display:\n\tTotal Frames:\t\t%d\n\tSkipped Frames:\t\t%d\n\tTotal Cloned Frames:\t%d\n\tSkipped Cloned Frames:\t%d\n\tNon-Dirty Frames:\t%d\n\n", CString, Int, v25, v24, v21, v22);
        }
        ++v8;
        v7 += 8;
      }
      while (Count != v8);
    }
  }
  else
  {
    CFIndex Count = 0;
  }
  CFRelease(v4);
  return Count;
}

uint64_t CARenderServerGetClientPort(mach_port_name_t a1, int a2)
{
  mach_msg_return_t v6;
  int v7;
  uint64_t v8;
  int msg;
  unsigned char msg_4[44];
  uint64_t v12;

  uint64_t v12 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0;
    }
  }
  memset(&msg_4[16], 0, 28);
  *(_OWORD *)msg_4 = 0u;
  *(void *)&msg_4[20] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&msg_4[28] = a2;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = ServerPort;
  *(_DWORD *)&msg_4[8] = reply_port;
  msg = 5395;
  *(void *)&msg_4[12] = 0x9D0E00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    mach_port_t reply_port = *(_DWORD *)&msg_4[8];
  }
  mach_msg_size_t v6 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x30u, reply_port, 0, 0);
  uint64_t v7 = v6;
  if ((v6 - 268435458) <= 0xE && ((1 << (v6 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
  }
  else
  {
    if (v6)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
    }
    else
    {
      if (*(_DWORD *)&msg_4[16] == 71)
      {
        uint64_t v7 = -308;
      }
      else if (*(_DWORD *)&msg_4[16] == 40306)
      {
        if (msg < 0)
        {
          uint64_t v7 = -300;
          if (*(_DWORD *)&msg_4[20] == 1
            && *(_DWORD *)msg_4 == 40
            && !*(_DWORD *)&msg_4[4]
            && *(unsigned __int16 *)&msg_4[34] << 16 == 1114112)
          {
            CFIndex v8 = *(unsigned int *)&msg_4[24];
            goto LABEL_30;
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          uint64_t v7 = -300;
          if (*(_DWORD *)&msg_4[28])
          {
            if (*(_DWORD *)&msg_4[4]) {
              uint64_t v7 = -300;
            }
            else {
              uint64_t v7 = *(_DWORD *)&msg_4[28];
            }
          }
        }
        else
        {
          uint64_t v7 = -300;
        }
      }
      else
      {
        uint64_t v7 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
    }
    if (v7 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
  }
  CFIndex v8 = 0;
LABEL_30:
  if (!a1) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
  }
  return v8;
}

uint64_t CARenderServerGetClientProcessId(mach_port_t a1, int a2)
{
  mach_msg_return_t v6;
  int v7;
  BOOL v8;
  uint64_t v9;
  mach_msg_header_t msg;
  int v12;
  int v13;
  long long v14;
  uint64_t v15;

  int v15 = *MEMORY[0x1E4F143B8];
  mach_port_t ServerPort = a1;
  if (!a1)
  {
    mach_port_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0;
    }
  }
  int v14 = 0u;
  msg.msgh_size = 0;
  uint64_t v12 = 1;
  int v13 = a2;
  DWORD1(v14) = 1245184;
  mach_port_t reply_port = mig_get_reply_port();
  msg.msgh_remote_port = ServerPort;
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = -2147478253;
  *(void *)&msg.msgh_voucher_port = 0x9D0F00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t reply_port = msg.msgh_local_port;
  }
  mach_msg_size_t v6 = mach_msg(&msg, 3, 0x28u, 0x30u, reply_port, 0, 0);
  uint64_t v7 = v6;
  if ((v6 - 268435458) <= 0xE && ((1 << (v6 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
    goto LABEL_28;
  }
  if (v6)
  {
    mig_dealloc_reply_port(msg.msgh_local_port);
    goto LABEL_27;
  }
  if (msg.msgh_id == 71)
  {
    uint64_t v7 = -308;
  }
  else if (msg.msgh_id == 40307)
  {
    if ((msg.msgh_bits & 0x80000000) == 0)
    {
      if (msg.msgh_size == 40)
      {
        if (!msg.msgh_remote_port)
        {
          uint64_t v7 = v14;
          if (!v14)
          {
            int v9 = DWORD1(v14);
            if (a1) {
              return v9;
            }
            goto LABEL_29;
          }
          goto LABEL_26;
        }
      }
      else if (msg.msgh_size == 36)
      {
        if (msg.msgh_remote_port) {
          CFIndex v8 = 1;
        }
        else {
          CFIndex v8 = v14 == 0;
        }
        if (v8) {
          uint64_t v7 = -300;
        }
        else {
          uint64_t v7 = v14;
        }
        goto LABEL_26;
      }
    }
    uint64_t v7 = -300;
  }
  else
  {
    uint64_t v7 = -301;
  }
LABEL_26:
  mach_msg_destroy(&msg);
LABEL_27:
  if (v7 == -81182719)
  {
    x_log_crash("Unentitled call to server!");
    abort();
  }
LABEL_28:
  int v9 = 0;
  if (!a1) {
LABEL_29:
  }
    mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
  return v9;
}

uint64_t CARenderServerRenderDisplay_(mach_port_t a1, const __CFString *a2, void *cf, int a4, int a5, int a6, long long *a7, int a8, uint64_t a9, uint64_t a10, int a11)
{
  mach_msg_return_t v37;
  int v38;
  uint64_t v39;
  BOOL v40;
  long long v41;
  long long v42;
  long long v43;
  long long v44;
  long long v45;
  long long v46;
  long long v47;
  long long v48;
  mach_port_t v49;
  char buffer[16];
  long long v51;
  long long v52;
  long long v53;
  long long v54;
  long long v55;
  long long v56;
  long long v57;
  long long v58;
  long long v59;
  long long v60;
  long long v61;
  long long v62;
  long long v63;
  long long v64;
  long long v65;
  mach_msg_header_t msg;
  int v67;
  uint64_t v68;
  uint64_t v69;
  mach_port_t v70;
  long long v71;
  _OWORD v72[26];
  uint64_t v73;
  uint64_t v74;

  uint64_t v74 = *MEMORY[0x1E4F143B8];
  CFTypeID v19 = CFGetTypeID(cf);
  if (v19 != IOSurfaceGetTypeID()) {
    return 0;
  }
  int v64 = 0u;
  unsigned int v65 = 0u;
  double v62 = 0u;
  unint64_t v63 = 0u;
  unsigned int v60 = 0u;
  unint64_t v61 = 0u;
  char v58 = 0u;
  uint64_t v59 = 0u;
  char v56 = 0u;
  char v57 = 0u;
  uint64_t v54 = 0u;
  int v55 = 0u;
  uint64_t v52 = 0u;
  char v53 = 0u;
  *(_OWORD *)buffer = 0u;
  int v51 = 0u;
  if (!a2) {
    return 0;
  }
  if (!CFStringGetCString(a2, buffer, 256, 0x8000100u)) {
    return 0;
  }
  mach_port_t ServerPort = a1;
  if (!a1)
  {
    mach_port_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0;
    }
  }
  int v49 = ServerPort;
  long long v21 = 0uLL;
  long long v22 = 0uLL;
  long long v23 = 0uLL;
  long long v24 = 0uLL;
  long long v25 = 0uLL;
  long long v26 = 0uLL;
  long long v27 = 0uLL;
  long long v28 = 0uLL;
  if (a7)
  {
    long long v21 = *a7;
    long long v22 = a7[1];
    long long v23 = a7[2];
    long long v24 = a7[3];
    long long v25 = a7[4];
    long long v26 = a7[5];
    long long v27 = a7[6];
    long long v28 = a7[7];
  }
  uint64_t v41 = v28;
  unsigned int v42 = v27;
  int v43 = v26;
  unsigned int v44 = v25;
  uint64_t v45 = v24;
  uint64_t v46 = v23;
  int v47 = v22;
  unint64_t v48 = v21;
  mach_port_t MachPort = IOSurfaceCreateMachPort((IOSurfaceRef)cf);
  uint64_t v30 = mach_absolute_time();
  double v31 = CATimeWithHostTime(v30);
  int v73 = 0;
  memset(v72, 0, sizeof(v72));
  unint64_t v71 = 0u;
  memset(&msg, 0, sizeof(msg));
  unsigned int v67 = 2;
  uint64_t v68 = a10;
  HIDWORD(v69) = 4 * a9;
  LODWORD(v69) = 16777472;
  unsigned int v70 = MachPort;
  DWORD1(v71) = 1245184;
  *((void *)&v71 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v32 = mig_strncpy_zerofill((char *)v72 + 8, buffer, 256);
  }
  else {
    int v32 = mig_strncpy((char *)v72 + 8, buffer, 256);
  }
  DWORD1(v72[0]) = v32;
  LODWORD(v72[0]) = 0;
  mach_msg_size_t v34 = ((v32 + 3) & 0xFFFFFFFC) + 232;
  uint64_t v35 = (char *)&msg + ((v32 + 3) & 0xFFFFFFFC);
  *((_DWORD *)v35 + 18) = a9;
  *((_DWORD *)v35 + 19) = a4;
  *((_DWORD *)v35 + 20) = a5;
  *((_DWORD *)v35 + 21) = a6;
  *((double *)v35 + 11) = v31;
  *((_OWORD *)v35 + 6) = v48;
  *((_OWORD *)v35 + 7) = v47;
  *((_OWORD *)v35 + 8) = v46;
  *((_OWORD *)v35 + 9) = v45;
  *((_OWORD *)v35 + 10) = v44;
  *((_OWORD *)v35 + 11) = v43;
  *((_OWORD *)v35 + 12) = v42;
  *((_OWORD *)v35 + 13) = v41;
  *((_DWORD *)v35 + 56) = a11;
  *((_DWORD *)v35 + 57) = a8;
  mach_port_t reply_port = mig_get_reply_port();
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = -2147478253;
  msg.msgh_remote_port = v49;
  *(void *)&msg.msgh_voucher_port = 0x9D1C00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t reply_port = msg.msgh_local_port;
  }
  __int16 v37 = mach_msg(&msg, 3, v34, 0x34u, reply_port, 0, 0);
  int v38 = v37;
  if ((v37 - 268435458) <= 0xE && ((1 << (v37 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
    __int16 v39 = 0;
    goto LABEL_17;
  }
  if (v37)
  {
    mig_dealloc_reply_port(msg.msgh_local_port);
    goto LABEL_40;
  }
  if (msg.msgh_id == 71)
  {
    int v38 = -308;
  }
  else if (msg.msgh_id == 40320)
  {
    if ((msg.msgh_bits & 0x80000000) == 0)
    {
      if (msg.msgh_size == 44)
      {
        if (!msg.msgh_remote_port)
        {
          int v38 = HIDWORD(v68);
          if (!HIDWORD(v68))
          {
            __int16 v39 = v69;
LABEL_17:
            mach_port_deallocate(*MEMORY[0x1E4F14960], MachPort);
            if (a1) {
              goto LABEL_19;
            }
            goto LABEL_18;
          }
          goto LABEL_39;
        }
      }
      else if (msg.msgh_size == 36)
      {
        if (msg.msgh_remote_port) {
          int v40 = 1;
        }
        else {
          int v40 = HIDWORD(v68) == 0;
        }
        if (v40) {
          int v38 = -300;
        }
        else {
          int v38 = HIDWORD(v68);
        }
        goto LABEL_39;
      }
    }
    int v38 = -300;
  }
  else
  {
    int v38 = -301;
  }
LABEL_39:
  mach_msg_destroy(&msg);
LABEL_40:
  mach_port_deallocate(*MEMORY[0x1E4F14960], MachPort);
  if (v38 == -81182719)
  {
    x_log_crash("Unentitled call to server!");
    abort();
  }
  __int16 v39 = 0;
  if (a1) {
    goto LABEL_19;
  }
LABEL_18:
  mach_port_deallocate(*MEMORY[0x1E4F14960], v49);
LABEL_19:
  if (v38) {
    return 0;
  }
  else {
    return v39;
  }
}

uint64_t CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags_(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, void *cf, int a6, int a7, long long *a8, double a9, int a10)
{
  mach_msg_return_t v30;
  int v31;
  uint64_t v32;
  BOOL v33;
  long long v34;
  long long v35;
  long long v36;
  long long v37;
  long long v38;
  long long v39;
  long long v40;
  long long v41;
  char buffer[16];
  long long v43;
  long long v44;
  long long v45;
  long long v46;
  long long v47;
  long long v48;
  long long v49;
  long long v50;
  long long v51;
  long long v52;
  long long v53;
  long long v54;
  long long v55;
  long long v56;
  long long v57;
  mach_msg_header_t msg;
  int v59;
  mach_port_t v60;
  long long v61;
  _OWORD v62[26];
  uint64_t v63;
  uint64_t v64;

  int v64 = *MEMORY[0x1E4F143B8];
  CFTypeID v19 = CFGetTypeID(cf);
  if (v19 != IOSurfaceGetTypeID()) {
    return 0;
  }
  char v56 = 0u;
  char v57 = 0u;
  uint64_t v54 = 0u;
  int v55 = 0u;
  uint64_t v52 = 0u;
  char v53 = 0u;
  float v50 = 0u;
  int v51 = 0u;
  unint64_t v48 = 0u;
  int v49 = 0u;
  uint64_t v46 = 0u;
  int v47 = 0u;
  unsigned int v44 = 0u;
  uint64_t v45 = 0u;
  *(_OWORD *)buffer = 0u;
  int v43 = 0u;
  if (!a2) {
    return 0;
  }
  if (!CFStringGetCString(a2, buffer, 256, 0x8000100u)) {
    return 0;
  }
  mach_port_t ServerPort = a1;
  if (!a1)
  {
    mach_port_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0;
    }
  }
  if ((a10 & 0x10) == 0) {
    a4 = CA::Render::Object::render_id(*(CA::Render::Object **)(a4 + 16));
  }
  int v40 = a8[1];
  uint64_t v41 = *a8;
  int v38 = a8[3];
  __int16 v39 = a8[2];
  int v36 = a8[5];
  __int16 v37 = a8[4];
  mach_msg_size_t v34 = a8[7];
  uint64_t v35 = a8[6];
  mach_port_t MachPort = IOSurfaceCreateMachPort((IOSurfaceRef)cf);
  uint64_t v22 = mach_absolute_time();
  double v23 = CATimeWithHostTime(v22);
  unint64_t v63 = 0;
  double v24 = v23 + a9;
  memset(v62, 0, sizeof(v62));
  unint64_t v61 = 0u;
  memset(&msg, 0, sizeof(msg));
  uint64_t v59 = 1;
  unsigned int v60 = MachPort;
  DWORD1(v61) = 1245184;
  *((void *)&v61 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v25 = mig_strncpy_zerofill((char *)v62 + 8, buffer, 256);
  }
  else {
    int v25 = mig_strncpy((char *)v62 + 8, buffer, 256);
  }
  DWORD1(v62[0]) = v25;
  LODWORD(v62[0]) = 0;
  mach_msg_size_t v27 = ((v25 + 3) & 0xFFFFFFFC) + 216;
  long long v28 = (char *)&msg + ((v25 + 3) & 0xFFFFFFFC);
  *((_DWORD *)v28 + 14) = a3;
  *(void *)(v28 + 60) = a4;
  *((_DWORD *)v28 + 17) = a6;
  *((_DWORD *)v28 + 18) = a7;
  *(double *)(v28 + 76) = v24;
  *(_OWORD *)(v28 + 84) = v41;
  *(_OWORD *)(v28 + 100) = v40;
  *(_OWORD *)(v28 + 116) = v39;
  *(_OWORD *)(v28 + 132) = v38;
  *(_OWORD *)(v28 + 148) = v37;
  *(_OWORD *)(v28 + 164) = v36;
  *(_OWORD *)(v28 + 180) = v35;
  *(_OWORD *)(v28 + 196) = v34;
  *((_DWORD *)v28 + 53) = a10;
  mach_port_t reply_port = mig_get_reply_port();
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = -2147478253;
  msg.msgh_remote_port = ServerPort;
  *(void *)&msg.msgh_voucher_port = 0x9D1E00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t reply_port = msg.msgh_local_port;
  }
  uint64_t v30 = mach_msg(&msg, 3, v27, 0x34u, reply_port, 0, 0);
  double v31 = v30;
  if ((v30 - 268435458) <= 0xE && ((1 << (v30 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
    int v32 = 0;
    goto LABEL_17;
  }
  if (v30)
  {
    mig_dealloc_reply_port(msg.msgh_local_port);
    goto LABEL_40;
  }
  if (msg.msgh_id == 71)
  {
    double v31 = -308;
  }
  else if (msg.msgh_id == 40322)
  {
    if ((msg.msgh_bits & 0x80000000) == 0)
    {
      if (msg.msgh_size == 44)
      {
        if (!msg.msgh_remote_port)
        {
          double v31 = v61;
          if (!v61)
          {
            int v32 = *(void *)((char *)&v61 + 4);
LABEL_17:
            mach_port_deallocate(*MEMORY[0x1E4F14960], MachPort);
            if (a1) {
              goto LABEL_19;
            }
            goto LABEL_18;
          }
          goto LABEL_39;
        }
      }
      else if (msg.msgh_size == 36)
      {
        if (msg.msgh_remote_port) {
          uint64_t v33 = 1;
        }
        else {
          uint64_t v33 = v61 == 0;
        }
        if (v33) {
          double v31 = -300;
        }
        else {
          double v31 = v61;
        }
        goto LABEL_39;
      }
    }
    double v31 = -300;
  }
  else
  {
    double v31 = -301;
  }
LABEL_39:
  mach_msg_destroy(&msg);
LABEL_40:
  mach_port_deallocate(*MEMORY[0x1E4F14960], MachPort);
  if (v31 == -81182719)
  {
    x_log_crash("Unentitled call to server!");
    abort();
  }
  int v32 = 0;
  if (a1) {
    goto LABEL_19;
  }
LABEL_18:
  mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
LABEL_19:
  if (v31) {
    return 0;
  }
  else {
    return v32;
  }
}

BOOL CARenderServerCaptureDisplayLayerWithTransformTimeOffsetAndFlags_(mach_port_t a1, CFStringRef theString, int a3, uint64_t a4, int a5, int a6, int a7, long long *a8, double a9, int a10)
{
  mach_msg_return_t v27;
  int v28;
  long long v29;
  long long v30;
  long long v31;
  long long v32;
  long long v33;
  long long v34;
  long long v35;
  long long v36;
  char buffer[16];
  long long v38;
  long long v39;
  long long v40;
  long long v41;
  long long v42;
  long long v43;
  long long v44;
  long long v45;
  long long v46;
  long long v47;
  long long v48;
  long long v49;
  long long v50;
  long long v51;
  long long v52;
  mach_msg_header_t msg;
  int v54;
  task_id_token_t v55;
  long long v56;
  _OWORD v57[27];
  uint64_t v58;

  char v58 = *MEMORY[0x1E4F143B8];
  if (!theString) {
    return 0;
  }
  int v51 = 0u;
  uint64_t v52 = 0u;
  int v49 = 0u;
  float v50 = 0u;
  int v47 = 0u;
  unint64_t v48 = 0u;
  uint64_t v45 = 0u;
  uint64_t v46 = 0u;
  int v43 = 0u;
  unsigned int v44 = 0u;
  uint64_t v41 = 0u;
  unsigned int v42 = 0u;
  __int16 v39 = 0u;
  int v40 = 0u;
  *(_OWORD *)buffer = 0u;
  int v38 = 0u;
  if (!CFStringGetCString(theString, buffer, 256, 0x8000100u)) {
    return 0;
  }
  mach_port_t ServerPort = a1;
  if (!a1)
  {
    mach_port_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0;
    }
  }
  if ((a10 & 0x10) == 0) {
    a4 = CA::Render::Object::render_id(*(CA::Render::Object **)(a4 + 16));
  }
  uint64_t v35 = a8[1];
  int v36 = *a8;
  uint64_t v33 = a8[3];
  mach_msg_size_t v34 = a8[2];
  double v31 = a8[5];
  int v32 = a8[4];
  int v29 = a8[7];
  uint64_t v30 = a8[6];
  task_id_token_t v19 = CA::MachPortUtil::task_identity_port(void)::task[0];
  if (!CA::MachPortUtil::task_identity_port(void)::task[0])
  {
    task_create_identity_token(*MEMORY[0x1E4F14960], CA::MachPortUtil::task_identity_port(void)::task);
    task_id_token_t v19 = CA::MachPortUtil::task_identity_port(void)::task[0];
  }
  uint64_t v20 = mach_absolute_time();
  double v21 = CATimeWithHostTime(v20) + a9;
  memset(v57, 0, 428);
  char v56 = 0u;
  memset(&msg, 0, sizeof(msg));
  uint64_t v54 = 1;
  int v55 = v19;
  DWORD1(v56) = 1245184;
  *((void *)&v56 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v22 = mig_strncpy_zerofill((char *)v57 + 8, buffer, 256);
  }
  else {
    int v22 = mig_strncpy((char *)v57 + 8, buffer, 256);
  }
  DWORD1(v57[0]) = v22;
  LODWORD(v57[0]) = 0;
  mach_msg_size_t v24 = ((v22 + 3) & 0xFFFFFFFC) + 220;
  int v25 = (char *)&msg + ((v22 + 3) & 0xFFFFFFFC);
  *((_DWORD *)v25 + 14) = a3;
  *(void *)(v25 + 60) = a4;
  *((_DWORD *)v25 + 17) = a5;
  *((_DWORD *)v25 + 18) = a6;
  *((_DWORD *)v25 + 19) = a7;
  *((double *)v25 + 10) = v21;
  *(_OWORD *)(v25 + 88) = v36;
  *(_OWORD *)(v25 + 104) = v35;
  *(_OWORD *)(v25 + 120) = v34;
  *(_OWORD *)(v25 + 136) = v33;
  *(_OWORD *)(v25 + 152) = v32;
  *(_OWORD *)(v25 + 168) = v31;
  *(_OWORD *)(v25 + 184) = v30;
  *(_OWORD *)(v25 + 200) = v29;
  *((_DWORD *)v25 + 54) = a10;
  mach_port_t reply_port = mig_get_reply_port();
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = -2147478253;
  msg.msgh_remote_port = ServerPort;
  *(void *)&msg.msgh_voucher_port = 0x9D2200000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t reply_port = msg.msgh_local_port;
  }
  mach_msg_size_t v27 = mach_msg(&msg, 3, v24, 0x2Cu, reply_port, 0, 0);
  long long v28 = v27;
  if ((v27 - 268435458) <= 0xE && ((1 << (v27 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
    goto LABEL_31;
  }
  if (v27)
  {
    mig_dealloc_reply_port(msg.msgh_local_port);
    goto LABEL_30;
  }
  if (msg.msgh_id == 71)
  {
    long long v28 = -308;
LABEL_29:
    mach_msg_destroy(&msg);
LABEL_30:
    if (v28 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_31;
  }
  if (msg.msgh_id != 40326)
  {
    long long v28 = -301;
    goto LABEL_29;
  }
  long long v28 = -300;
  if ((msg.msgh_bits & 0x80000000) != 0) {
    goto LABEL_29;
  }
  if (msg.msgh_size != 36) {
    goto LABEL_29;
  }
  if (msg.msgh_remote_port) {
    goto LABEL_29;
  }
  long long v28 = v56;
  if (v56) {
    goto LABEL_29;
  }
LABEL_31:
  if (!a1) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
  }
  return v28 == 0;
}

BOOL CARenderServerCaptureDisplayWithTransform_(mach_port_t a1, CFStringRef theString, int a3, int a4, int a5, int a6, long long *a7, __int16 a8, uint64_t a9, uint64_t a10, int a11)
{
  mach_msg_return_t v29;
  int v30;
  long long v31;
  long long v32;
  long long v33;
  long long v34;
  long long v35;
  long long v36;
  long long v37;
  long long v38;
  mach_port_t v39;
  char buffer[16];
  long long v41;
  long long v42;
  long long v43;
  long long v44;
  long long v45;
  long long v46;
  long long v47;
  long long v48;
  long long v49;
  long long v50;
  long long v51;
  long long v52;
  long long v53;
  long long v54;
  long long v55;
  mach_msg_header_t msg;
  int v57;
  uint64_t v58;
  int v59;
  int v60;
  int v61;
  long long v62;
  _OWORD v63[27];
  uint64_t v64;

  int v64 = *MEMORY[0x1E4F143B8];
  if (!theString) {
    return 0;
  }
  uint64_t v54 = 0u;
  int v55 = 0u;
  uint64_t v52 = 0u;
  char v53 = 0u;
  float v50 = 0u;
  int v51 = 0u;
  unint64_t v48 = 0u;
  int v49 = 0u;
  uint64_t v46 = 0u;
  int v47 = 0u;
  unsigned int v44 = 0u;
  uint64_t v45 = 0u;
  unsigned int v42 = 0u;
  int v43 = 0u;
  *(_OWORD *)buffer = 0u;
  uint64_t v41 = 0u;
  if (!CFStringGetCString(theString, buffer, 256, 0x8000100u)) {
    return 0;
  }
  mach_port_t ServerPort = a1;
  if (!a1)
  {
    mach_port_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0;
    }
  }
  __int16 v39 = ServerPort;
  if (a7)
  {
    __int16 v37 = a7[1];
    int v38 = *a7;
    uint64_t v35 = a7[3];
    int v36 = a7[2];
    uint64_t v33 = a7[5];
    mach_msg_size_t v34 = a7[4];
    int v32 = a7[6];
    long long v19 = a7[7];
  }
  else
  {
    long long v19 = 0uLL;
    __int16 v37 = 0u;
    int v38 = 0u;
    uint64_t v35 = 0u;
    int v36 = 0u;
    uint64_t v33 = 0u;
    mach_msg_size_t v34 = 0u;
    int v32 = 0u;
  }
  double v31 = v19;
  int v21 = a8 & 0x1000 | 0x400;
  int v22 = CA::MachPortUtil::task_identity_port(void)::task[0];
  if (!CA::MachPortUtil::task_identity_port(void)::task[0])
  {
    task_create_identity_token(*MEMORY[0x1E4F14960], CA::MachPortUtil::task_identity_port(void)::task);
    int v22 = CA::MachPortUtil::task_identity_port(void)::task[0];
  }
  uint64_t v23 = mach_absolute_time();
  double v24 = CATimeWithHostTime(v23);
  memset(v63, 0, 428);
  double v62 = 0u;
  memset(&msg, 0, sizeof(msg));
  char v57 = 2;
  char v58 = a10;
  unsigned int v60 = 4 * a9;
  uint64_t v59 = 16777472;
  unint64_t v61 = v22;
  DWORD1(v62) = 1245184;
  *((void *)&v62 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v25 = mig_strncpy_zerofill((char *)v63 + 8, buffer, 256);
  }
  else {
    int v25 = mig_strncpy((char *)v63 + 8, buffer, 256);
  }
  DWORD1(v63[0]) = v25;
  LODWORD(v63[0]) = 0;
  mach_msg_size_t v26 = ((v25 + 3) & 0xFFFFFFFC) + 236;
  mach_msg_size_t v27 = (char *)&msg + ((v25 + 3) & 0xFFFFFFFC);
  *((_DWORD *)v27 + 18) = a9;
  *((_DWORD *)v27 + 19) = a3;
  *((_DWORD *)v27 + 20) = a4;
  *((_DWORD *)v27 + 21) = a5;
  *((_DWORD *)v27 + 22) = a6;
  *(double *)(v27 + 92) = v24;
  *(_OWORD *)(v27 + 100) = v38;
  *(_OWORD *)(v27 + 116) = v37;
  *(_OWORD *)(v27 + 132) = v36;
  *(_OWORD *)(v27 + 148) = v35;
  *(_OWORD *)(v27 + 164) = v34;
  *(_OWORD *)(v27 + 180) = v33;
  *(_OWORD *)(v27 + 196) = v32;
  *(_OWORD *)(v27 + 212) = v31;
  *((_DWORD *)v27 + 57) = a11;
  *((_DWORD *)v27 + 58) = v21;
  mach_port_t reply_port = mig_get_reply_port();
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = -2147478253;
  msg.msgh_remote_port = v39;
  *(void *)&msg.msgh_voucher_port = 0x9D2300000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&msg);
    mach_port_t reply_port = msg.msgh_local_port;
  }
  int v29 = mach_msg(&msg, 3, v26, 0x2Cu, reply_port, 0, 0);
  uint64_t v30 = v29;
  if ((v29 - 268435458) <= 0xE && ((1 << (v29 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
    goto LABEL_32;
  }
  if (v29)
  {
    mig_dealloc_reply_port(msg.msgh_local_port);
    goto LABEL_31;
  }
  if (msg.msgh_id == 71)
  {
    uint64_t v30 = -308;
LABEL_30:
    mach_msg_destroy(&msg);
LABEL_31:
    if (v30 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_32;
  }
  if (msg.msgh_id != 40327)
  {
    uint64_t v30 = -301;
    goto LABEL_30;
  }
  uint64_t v30 = -300;
  if ((msg.msgh_bits & 0x80000000) != 0) {
    goto LABEL_30;
  }
  if (msg.msgh_size != 36) {
    goto LABEL_30;
  }
  if (msg.msgh_remote_port) {
    goto LABEL_30;
  }
  uint64_t v30 = HIDWORD(v58);
  if (HIDWORD(v58)) {
    goto LABEL_30;
  }
LABEL_32:
  if (!a1) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v39);
  }
  return v30 == 0;
}

BOOL _CARenderServerCaptureDisplayContextList(mach_port_t a1, CFStringRef theString, int a3, uint64_t a4, int a5, int a6, int a7, unint64_t a8, uint64_t a9, int a10)
{
  mach_msg_return_t v40;
  int v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  mach_port_t v45;
  char *v46;
  _OWORD v47[16];
  mach_msg_header_t v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  task_id_token_t v53;
  int v54;
  int v55;
  char *v56;
  long long v57;
  _DWORD v58[72];
  uint64_t v59;
  uint64_t v60;

  unsigned int v60 = *MEMORY[0x1E4F143B8];
  if (!theString) {
    return 0;
  }
  memset(v47, 0, sizeof(v47));
  uint64_t CString = CFStringGetCString(theString, (char *)v47, 256, 0x8000100u);
  if (!CString) {
    return 0;
  }
  mach_port_t v18 = a1;
  if (!a1)
  {
    uint64_t CString = CARenderServerGetServerPort(0);
    mach_port_t v18 = CString;
    if (!CString) {
      return 0;
    }
  }
  if (a8 >> 57) {
    return 0;
  }
  unsigned int v44 = a8 << 7;
  if (a8 << 7 > 0x1000)
  {
    uint64_t v46 = (char *)malloc_type_malloc(a8 << 7, 0x2433DF79uLL);
  }
  else
  {
    MEMORY[0x1F4188790](CString);
    uint64_t v46 = (char *)&v43 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v46, v20);
  }
  uint64_t v45 = v18;
  if (a8)
  {
    int v21 = (long long *)(a9 + 64);
    int v22 = v46 + 64;
    unint64_t v23 = a8;
    do
    {
      long long v24 = *(v21 - 3);
      long long v25 = *(v21 - 2);
      long long v26 = *(v21 - 1);
      long long v27 = *v21;
      long long v28 = v21[1];
      long long v29 = v21[2];
      long long v30 = v21[3];
      *(v22 - 4) = *(v21 - 4);
      *(v22 - 3) = v24;
      *(v22 - 2) = v25;
      *(v22 - 1) = v26;
      *int v22 = v27;
      v22[1] = v28;
      v21 += 8;
      void v22[2] = v29;
      v22[3] = v30;
      v22 += 8;
      --v23;
    }
    while (v23);
  }
  task_id_token_t v31 = CA::MachPortUtil::task_identity_port(void)::task[0];
  if (!CA::MachPortUtil::task_identity_port(void)::task[0])
  {
    task_create_identity_token(*MEMORY[0x1E4F14960], CA::MachPortUtil::task_identity_port(void)::task);
    task_id_token_t v31 = CA::MachPortUtil::task_identity_port(void)::task[0];
  }
  uint64_t v32 = mach_absolute_time();
  double v33 = CATimeWithHostTime(v32);
  uint64_t v59 = 0;
  memset(v58, 0, sizeof(v58));
  uint64_t v54 = 0;
  char v57 = 0u;
  memset(&v48, 0, sizeof(v48));
  int v49 = 3;
  float v50 = a4;
  uint64_t v52 = 4 * a3;
  int v51 = 16777472;
  char v53 = v31;
  int v55 = 1245184;
  char v56 = v46;
  DWORD1(v57) = a8 << 7;
  LODWORD(v57) = 16777472;
  *((void *)&v57 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v34 = mig_strncpy_zerofill((char *)&v58[2], (const char *)v47, 256);
  }
  else {
    int v34 = mig_strncpy((char *)&v58[2], (const char *)v47, 256);
  }
  mach_port_t v35 = v45;
  v58[1] = v34;
  v58[0] = 0;
  uint64_t v36 = (v34 + 3) & 0xFFFFFFFC;
  mach_msg_size_t v37 = v36 + 120;
  int v38 = (char *)&v48 + v36;
  *((_DWORD *)v38 + 22) = a3;
  *((_DWORD *)v38 + 23) = a5;
  *((_DWORD *)v38 + 24) = a6;
  *((_DWORD *)v38 + 25) = a7;
  *((double *)v38 + 13) = v33;
  *((_DWORD *)v38 + 28) = a8;
  *((_DWORD *)v38 + 29) = a10;
  mach_port_t reply_port = mig_get_reply_port();
  v48.msgh_local_port = reply_port;
  v48.msgh_bits = -2147478253;
  v48.msgh_remote_port = v35;
  *(void *)&v48.msgh_voucher_port = 0x9D2400000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&v48);
    mach_port_t reply_port = v48.msgh_local_port;
  }
  int v40 = mach_msg(&v48, 3, v37, 0x2Cu, reply_port, 0, 0);
  uint64_t v41 = v40;
  if ((v40 - 268435458) > 0xE || ((1 << (v40 - 2)) & 0x4003) == 0)
  {
    if (v40)
    {
      mig_dealloc_reply_port(v48.msgh_local_port);
    }
    else
    {
      if (v48.msgh_id == 71)
      {
        uint64_t v41 = -308;
      }
      else if (v48.msgh_id == 40328)
      {
        uint64_t v41 = -300;
        if ((v48.msgh_bits & 0x80000000) == 0 && v48.msgh_size == 36 && !v48.msgh_remote_port)
        {
          uint64_t v41 = HIDWORD(v50);
          if (!HIDWORD(v50)) {
            goto LABEL_23;
          }
        }
      }
      else
      {
        uint64_t v41 = -301;
      }
      mach_msg_destroy(&v48);
    }
    unsigned int v42 = v44;
    if (v41 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_37;
  }
  mig_put_reply_port(v48.msgh_local_port);
LABEL_23:
  unsigned int v42 = v44;
LABEL_37:
  if (v42 > 0x1000) {
    free(v46);
  }
  if (!a1) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v35);
  }
  return v41 == 0;
}

uint64_t _CARenderServerRenderDisplayContextList(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, void *cf, int a6, int a7, unint64_t a8, uint64_t a9, int a10)
{
  mach_msg_return_t v42;
  int v43;
  uint64_t v44;
  BOOL v45;
  unint64_t v46;
  char *v47;
  _OWORD v48[16];
  mach_msg_header_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  mach_port_t v53;
  int v54;
  int v55;
  char *v56;
  long long v57;
  _DWORD v58[74];
  uint64_t v59;

  uint64_t v59 = *MEMORY[0x1E4F143B8];
  CFTypeID v18 = CFGetTypeID(cf);
  if (v18 != IOSurfaceGetTypeID()) {
    return 0;
  }
  memset(v48, 0, sizeof(v48));
  if (!a2) {
    return 0;
  }
  uint64_t CString = CFStringGetCString(a2, (char *)v48, 256, 0x8000100u);
  if (!CString) {
    return 0;
  }
  mach_port_t v20 = a1;
  if (!a1)
  {
    uint64_t CString = CARenderServerGetServerPort(0);
    mach_port_t v20 = CString;
    if (!CString) {
      return 0;
    }
  }
  if (a8 >> 57) {
    return 0;
  }
  uint64_t v46 = a8 << 7;
  if (a8 << 7 > 0x1000)
  {
    int v47 = (char *)malloc_type_malloc(a8 << 7, 0xA928DAFEuLL);
  }
  else
  {
    MEMORY[0x1F4188790](CString);
    int v47 = (char *)&v46 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v47, v22);
  }
  if (a8)
  {
    unint64_t v23 = (long long *)(a9 + 64);
    long long v24 = v47 + 64;
    unint64_t v25 = a8;
    do
    {
      long long v26 = *(v23 - 3);
      long long v27 = *(v23 - 2);
      long long v28 = *(v23 - 1);
      long long v29 = *v23;
      long long v30 = v23[1];
      long long v31 = v23[2];
      long long v32 = v23[3];
      *(v24 - 4) = *(v23 - 4);
      *(v24 - 3) = v26;
      *(v24 - 2) = v27;
      *(v24 - 1) = v28;
      _OWORD *v24 = v29;
      v24[1] = v30;
      v23 += 8;
      _OWORD v24[2] = v31;
      v24[3] = v32;
      v24 += 8;
      --v25;
    }
    while (v25);
  }
  mach_port_t MachPort = IOSurfaceCreateMachPort((IOSurfaceRef)cf);
  uint64_t v34 = mach_absolute_time();
  double v35 = CATimeWithHostTime(v34);
  memset(v58, 0, 292);
  uint64_t v54 = 0;
  char v57 = 0u;
  memset(&v49, 0, sizeof(v49));
  float v50 = 3;
  int v51 = a4;
  mach_port_name_t v36 = MachPort;
  HIDWORD(v52) = 4 * a3;
  LODWORD(v52) = 16777472;
  char v53 = MachPort;
  int v55 = 1245184;
  char v56 = v47;
  DWORD1(v57) = a8 << 7;
  LODWORD(v57) = 16777472;
  *((void *)&v57 + 1) = *MEMORY[0x1E4F14068];
  if (MEMORY[0x1E4F149B0]) {
    int v37 = mig_strncpy_zerofill((char *)&v58[2], (const char *)v48, 256);
  }
  else {
    int v37 = mig_strncpy((char *)&v58[2], (const char *)v48, 256);
  }
  v58[1] = v37;
  v58[0] = 0;
  uint64_t v38 = (v37 + 3) & 0xFFFFFFFC;
  mach_msg_size_t v39 = v38 + 116;
  int v40 = (char *)&v49 + v38;
  *((_DWORD *)v40 + 22) = a3;
  *((_DWORD *)v40 + 23) = a6;
  *((_DWORD *)v40 + 24) = a7;
  *(double *)(v40 + 100) = v35;
  *((_DWORD *)v40 + 27) = a8;
  *((_DWORD *)v40 + 28) = a10;
  mach_port_t reply_port = mig_get_reply_port();
  v49.msgh_local_port = reply_port;
  v49.msgh_bits = -2147478253;
  v49.msgh_remote_port = v20;
  *(void *)&v49.msgh_voucher_port = 0x9D2000000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&v49);
    mach_port_t reply_port = v49.msgh_local_port;
  }
  unsigned int v42 = mach_msg(&v49, 3, v39, 0x34u, reply_port, 0, 0);
  int v43 = v42;
  if ((v42 - 268435458) > 0xE || ((1 << (v42 - 2)) & 0x4003) == 0)
  {
    if (v42)
    {
      mig_dealloc_reply_port(v49.msgh_local_port);
LABEL_41:
      mach_port_deallocate(*MEMORY[0x1E4F14960], v36);
      if (v43 == -81182719)
      {
        x_log_crash("Unentitled call to server!");
        abort();
      }
      unsigned int v44 = 0;
      goto LABEL_43;
    }
    if (v49.msgh_id == 71)
    {
      int v43 = -308;
    }
    else if (v49.msgh_id == 40324)
    {
      if ((v49.msgh_bits & 0x80000000) == 0)
      {
        if (v49.msgh_size == 44)
        {
          if (!v49.msgh_remote_port)
          {
            int v43 = HIDWORD(v51);
            if (!HIDWORD(v51))
            {
              unsigned int v44 = v52;
              goto LABEL_22;
            }
            goto LABEL_40;
          }
        }
        else if (v49.msgh_size == 36)
        {
          if (v49.msgh_remote_port) {
            uint64_t v45 = 1;
          }
          else {
            uint64_t v45 = HIDWORD(v51) == 0;
          }
          if (v45) {
            int v43 = -300;
          }
          else {
            int v43 = HIDWORD(v51);
          }
          goto LABEL_40;
        }
      }
      int v43 = -300;
    }
    else
    {
      int v43 = -301;
    }
LABEL_40:
    mach_msg_destroy(&v49);
    goto LABEL_41;
  }
  mig_put_reply_port(v49.msgh_local_port);
  unsigned int v44 = 0;
LABEL_22:
  mach_port_deallocate(*MEMORY[0x1E4F14960], v36);
LABEL_43:
  if (v46 > 0x1000) {
    free(v47);
  }
  if (!a1) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v20);
  }
  if (v43) {
    return 0;
  }
  else {
    return v44;
  }
}

BOOL CARenderServerRenderLayer(mach_port_t a1, int a2, uint64_t a3, void *cf, int a5, int a6)
{
  return CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags_(a1, @"defaultDisplay", a2, a3, cf, a5, a6, (long long *)&CATransform3DIdentity, 0.0, 0) != 0;
}

BOOL CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, void *a5, int a6, int a7, long long *a8, double a9, int a10)
{
  return CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags_(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) != 0;
}

BOOL CARenderServerRenderLayerWithTransform(mach_port_t a1, int a2, uint64_t a3, void *cf, int a5, int a6, long long *a7)
{
  return CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags_(a1, @"defaultDisplay", a2, a3, cf, a5, a6, a7, 0.0, 0) != 0;
}

BOOL CARenderServerRenderLayerWithTransformAndTimeOffset(mach_port_t a1, int a2, uint64_t a3, void *cf, int a5, int a6, long long *a7, double a8)
{
  return CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags_(a1, @"defaultDisplay", a2, a3, cf, a5, a6, a7, a8, 0) != 0;
}

BOOL CARenderServerRenderDisplay(mach_port_t a1, const __CFString *a2, void *a3, int a4, int a5)
{
  return CARenderServerRenderDisplay_(a1, a2, a3, 0, a4, a5, 0, 0, 0, 0, 0) != 0;
}

BOOL CARenderServerRenderDisplayClientList(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, void *a5, int a6, int a7)
{
  return _CARenderServerRenderDisplayContextList(a1, a2, a3, a4, a5, a6, a7, 1uLL, (uint64_t)&CATransform3DIdentity, 0) != 0;
}

BOOL CARenderServerRenderDisplayClientListWithTransform(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, void *a5, int a6, int a7, uint64_t a8)
{
  return _CARenderServerRenderDisplayContextList(a1, a2, a3, a4, a5, a6, a7, 1uLL, a8, 0) != 0;
}

BOOL CARenderServerRenderDisplayClientListWithTransformList(mach_port_t a1, const __CFString *a2, unint64_t a3, uint64_t a4, void *a5, int a6, int a7, uint64_t a8)
{
  return _CARenderServerRenderDisplayContextList(a1, a2, a3, a4, a5, a6, a7, a3, a8, 0) != 0;
}

BOOL CARenderServerRenderDisplayLayerWithTransformAndTimeOffset(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, void *a5, int a6, int a7, long long *a8, double a9)
{
  return CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags_(a1, a2, a3, a4, a5, a6, a7, a8, a9, 0) != 0;
}

BOOL CARenderServerCaptureLayer(mach_port_t a1, int a2, uint64_t a3, int a4, int a5, int a6)
{
  return CARenderServerCaptureDisplayLayerWithTransformTimeOffsetAndFlags_(a1, @"defaultDisplay", a2, a3, a4, a5, a6, (long long *)&CATransform3DIdentity, 0.0, 1024);
}

BOOL CARenderServerCaptureDisplayLayerWithTransformTimeOffsetAndFlags(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, int a5, int a6, int a7, long long *a8, double a9, int a10)
{
  return CARenderServerCaptureDisplayLayerWithTransformTimeOffsetAndFlags_(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 | 0x400);
}

BOOL CARenderServerCaptureLayerWithTransform(mach_port_t a1, int a2, uint64_t a3, int a4, int a5, int a6, long long *a7)
{
  return CARenderServerCaptureDisplayLayerWithTransformTimeOffsetAndFlags_(a1, @"defaultDisplay", a2, a3, a4, a5, a6, a7, 0.0, 1024);
}

BOOL CARenderServerCaptureLayerWithTransformAndTimeOffset(mach_port_t a1, int a2, uint64_t a3, int a4, int a5, int a6, long long *a7, double a8)
{
  return CARenderServerCaptureDisplayLayerWithTransformTimeOffsetAndFlags_(a1, @"defaultDisplay", a2, a3, a4, a5, a6, a7, a8, 1024);
}

BOOL CARenderServerCaptureDisplay(mach_port_t a1, const __CFString *a2, int a3, int a4, int a5)
{
  return CARenderServerCaptureDisplayWithTransform_(a1, a2, a3, 0, a4, a5, 0, 0, 0, 0, 0);
}

BOOL CARenderServerCaptureDisplayWithTransform(mach_port_t a1, const __CFString *a2, int a3, int a4, int a5, long long *a6)
{
  return CARenderServerCaptureDisplayWithTransform_(a1, a2, a3, 0, a4, a5, a6, 0, 0, 0, 0);
}

BOOL CARenderServerCaptureDisplayClientList(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, int a5, int a6, int a7)
{
  return _CARenderServerCaptureDisplayContextList(a1, a2, a3, a4, a5, a6, a7, 1uLL, (uint64_t)&CATransform3DIdentity, 1024);
}

BOOL CARenderServerCaptureDisplayClientListWithTransform(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, int a5, int a6, int a7, uint64_t a8)
{
  return _CARenderServerCaptureDisplayContextList(a1, a2, a3, a4, a5, a6, a7, 1uLL, a8, 1024);
}

BOOL CARenderServerCaptureDisplayClientListWithTransformList(mach_port_t a1, const __CFString *a2, unint64_t a3, uint64_t a4, int a5, int a6, int a7, uint64_t a8)
{
  return _CARenderServerCaptureDisplayContextList(a1, a2, a3, a4, a5, a6, a7, a3, a8, 1024);
}

void CARenderServerSetCacheAsynchronousSurfaces(int a1, int a2)
{
  mach_msg_return_t v5;
  unsigned char msg[36];
  uint64_t v7;
  uint64_t v8;

  int ServerPort = a1;
  CFIndex v8 = *MEMORY[0x1E4F143B8];
  if (a1 || (int ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    memset(&msg[4], 0, 32);
    uint64_t v7 = 0;
    *(void *)&msg[24] = *MEMORY[0x1E4F14068];
    *(_DWORD *)&msg[32] = a2;
    mach_port_t reply_port = mig_get_reply_port();
    *(_DWORD *)&msg[8] = ServerPort;
    *(_DWORD *)&msg[12] = reply_port;
    *(_DWORD *)msg = 5395;
    *(void *)&msg[16] = 0x9D2500000000;
    if (MEMORY[0x1E4F14B18])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      mach_port_t reply_port = *(_DWORD *)&msg[12];
    }
    long long v5 = mach_msg((mach_msg_header_t *)msg, 3, 0x24u, 0x2Cu, reply_port, 0, 0);
    if ((v5 - 268435458) <= 0xE && ((1 << (v5 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
    }
    else if (v5)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    }
    else if (*(_DWORD *)&msg[20] != 40329 {
           || (*(_DWORD *)msg & 0x80000000) != 0
    }
           || *(_DWORD *)&msg[4] != 36
           || *(_DWORD *)&msg[8]
           || *(_DWORD *)&msg[32])
    {
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
  }
}

void CARenderServerFlushIRDC(mach_port_t ServerPort)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if (CADeviceNeedsIRDCFlush::once != -1) {
    dispatch_once(&CADeviceNeedsIRDCFlush::once, &__block_literal_global_390);
  }
  if (CADeviceNeedsIRDCFlush::b)
  {
    if (ServerPort || (int ServerPort = CARenderServerGetServerPort(0)) != 0)
    {
      v2.msgh_size = 0;
      v2.msgh_bits = 19;
      v2.msgh_remote_port = ServerPort;
      v2.msgh_local_port = 0;
      *(void *)&v2.msgh_voucher_port = 0x9D2600000000;
      if (MEMORY[0x1E4F14B18]) {
        voucher_mach_msg_set(&v2);
      }
      mach_msg(&v2, 1, 0x18u, 0, 0, 0, 0);
    }
  }
}

void CARenderServerPostPowerLog(mach_port_name_t a1)
{
  mach_msg_return_t v4;
  int v5;
  ipc_space_t v6;
  unsigned char msg[36];
  uint64_t v8;
  uint64_t v9;
  uint64_t vars8;

  int v9 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return;
    }
  }
  CFIndex v8 = 0;
  *(_DWORD *)&msg[4] = 0;
  *(_OWORD *)&msg[20] = 0u;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = ServerPort;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(void *)&msg[16] = 0x9D3F00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_t reply_port = *(_DWORD *)&msg[12];
  }
  CFArrayRef v4 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x2Cu, reply_port, 0, 0);
  long long v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_21;
  }
  if (v4)
  {
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_20;
  }
  if (*(_DWORD *)&msg[20] == 71)
  {
    long long v5 = -308;
LABEL_19:
    mach_msg_destroy((mach_msg_header_t *)msg);
LABEL_20:
    if (v5 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
  if (*(_DWORD *)&msg[20] != 40355)
  {
    long long v5 = -301;
    goto LABEL_19;
  }
  long long v5 = -300;
  if ((*(_DWORD *)msg & 0x80000000) != 0) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[4] != 36) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[8]) {
    goto LABEL_19;
  }
  long long v5 = *(_DWORD *)&msg[32];
  if (*(_DWORD *)&msg[32]) {
    goto LABEL_19;
  }
LABEL_21:
  if (!a1)
  {
    mach_msg_size_t v6 = *MEMORY[0x1E4F14960];
    mach_port_deallocate(v6, ServerPort);
  }
}

void CARenderServerPurgeServer(mach_port_name_t a1)
{
  mach_msg_return_t v4;
  int v5;
  ipc_space_t v6;
  unsigned char msg[36];
  uint64_t v8;
  uint64_t v9;
  uint64_t vars8;

  int v9 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return;
    }
  }
  CFIndex v8 = 0;
  *(_DWORD *)&msg[4] = 0;
  *(_OWORD *)&msg[20] = 0u;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = ServerPort;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(void *)&msg[16] = 0x9D3C00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_t reply_port = *(_DWORD *)&msg[12];
  }
  CFArrayRef v4 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x2Cu, reply_port, 0, 0);
  long long v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_21;
  }
  if (v4)
  {
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_20;
  }
  if (*(_DWORD *)&msg[20] == 71)
  {
    long long v5 = -308;
LABEL_19:
    mach_msg_destroy((mach_msg_header_t *)msg);
LABEL_20:
    if (v5 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
  if (*(_DWORD *)&msg[20] != 40352)
  {
    long long v5 = -301;
    goto LABEL_19;
  }
  long long v5 = -300;
  if ((*(_DWORD *)msg & 0x80000000) != 0) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[4] != 36) {
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg[8]) {
    goto LABEL_19;
  }
  long long v5 = *(_DWORD *)&msg[32];
  if (*(_DWORD *)&msg[32]) {
    goto LABEL_19;
  }
LABEL_21:
  if (!a1)
  {
    mach_msg_size_t v6 = *MEMORY[0x1E4F14960];
    mach_port_deallocate(v6, ServerPort);
  }
}

CFPropertyListRef CARenderServerGetPerformanceInfo(mach_port_name_t a1)
{
  mach_msg_return_t v4;
  int v5;
  unsigned int v6;
  const UInt8 *v7;
  CFAllocatorRef v8;
  CFDataRef v9;
  CFPropertyListRef v10;
  int msg;
  int msg_4;
  mach_port_name_t msg_8;
  mach_port_t msg_12;
  unsigned char msg_16[48];
  uint64_t v17;

  int v17 = *MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0;
    }
  }
  memset(&msg_16[4], 0, 44);
  msg_4 = 0;
  mach_port_t reply_port = mig_get_reply_port();
  msg_8 = ServerPort;
  msg_12 = reply_port;
  msg = 5395;
  *(void *)msg_16 = 0x9D4000000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    mach_port_t reply_port = msg_12;
  }
  CFArrayRef v4 = mach_msg((mach_msg_header_t *)&msg, 3, 0x18u, 0x40u, reply_port, 0, 0);
  long long v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg_12);
  }
  else
  {
    if (v4)
    {
      mig_dealloc_reply_port(msg_12);
    }
    else
    {
      if (*(_DWORD *)&msg_16[4] == 71)
      {
        long long v5 = -308;
      }
      else if (*(_DWORD *)&msg_16[4] == 40356)
      {
        if (msg < 0)
        {
          long long v5 = -300;
          if (*(_DWORD *)&msg_16[8] == 1 && msg_4 == 56 && !msg_8 && msg_16[23] == 1)
          {
            mach_msg_size_t v6 = *(_DWORD *)&msg_16[24];
            if (*(_DWORD *)&msg_16[24] == *(_DWORD *)&msg_16[36])
            {
              long long v5 = 0;
              uint64_t v7 = *(const UInt8 **)&msg_16[12];
              goto LABEL_30;
            }
          }
        }
        else if (msg_4 == 36)
        {
          long long v5 = -300;
          if (*(_DWORD *)&msg_16[16])
          {
            if (msg_8) {
              long long v5 = -300;
            }
            else {
              long long v5 = *(_DWORD *)&msg_16[16];
            }
          }
        }
        else
        {
          long long v5 = -300;
        }
      }
      else
      {
        long long v5 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
    }
    if (v5 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
  }
  uint64_t v7 = 0;
  mach_msg_size_t v6 = 0;
LABEL_30:
  if (!a1)
  {
    mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
    if (!v5) {
      goto LABEL_34;
    }
    return 0;
  }
  if (v5) {
    return 0;
  }
LABEL_34:
  CFIndex v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF98];
  int v9 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF98], v7, v6);
  mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)v7, v6);
  if (!v9) {
    return 0;
  }
  mach_msg_size_t v10 = CFPropertyListCreateWithData(v8, v9, 0, 0, 0);
  CFRelease(v9);
  return v10;
}

uint64_t CARenderServerGetDisplayLogicalBounds(int a1, int a2, void *a3)
{
  mach_msg_return_t v8;
  int v9;
  unsigned int v10;
  const void *v11;
  mach_vm_size_t v12;
  int msg;
  unsigned char msg_4[60];
  uint64_t v15;

  int v5 = a1;
  int v15 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t result = CARenderServerGetServerPort(0);
    int v5 = result;
    if (!result) {
      return result;
    }
  }
  memset(&msg_4[16], 0, 44);
  *(_OWORD *)msg_4 = 0u;
  *(void *)&msg_4[20] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&msg_4[28] = a2;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = v5;
  *(_DWORD *)&msg_4[8] = reply_port;
  msg = 5395;
  *(void *)&msg_4[12] = 0x9D2A00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    mach_port_t reply_port = *(_DWORD *)&msg_4[8];
  }
  CFIndex v8 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x40u, reply_port, 0, 0);
  int v9 = v8;
  if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
  }
  else
  {
    if (v8)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
    }
    else
    {
      if (*(_DWORD *)&msg_4[16] == 71)
      {
        int v9 = -308;
      }
      else if (*(_DWORD *)&msg_4[16] == 40334)
      {
        if (msg < 0)
        {
          int v9 = -300;
          if (*(_DWORD *)&msg_4[20] == 1 && *(_DWORD *)msg_4 == 56 && !*(_DWORD *)&msg_4[4] && msg_4[35] == 1)
          {
            mach_msg_size_t v10 = *(_DWORD *)&msg_4[36];
            if (*(_DWORD *)&msg_4[36] == *(_DWORD *)&msg_4[48])
            {
              int v9 = 0;
              int v11 = *(const void **)&msg_4[24];
              goto LABEL_30;
            }
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          int v9 = -300;
          if (*(_DWORD *)&msg_4[28])
          {
            if (*(_DWORD *)&msg_4[4]) {
              int v9 = -300;
            }
            else {
              int v9 = *(_DWORD *)&msg_4[28];
            }
          }
        }
        else
        {
          int v9 = -300;
        }
      }
      else
      {
        int v9 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
    }
    if (v9 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
  }
  int v11 = 0;
  mach_msg_size_t v10 = 0;
LABEL_30:
  uint64_t result = v9 == 0;
  if (a3)
  {
    if (!v9)
    {
      uint64_t v12 = v10;
      memcpy(a3, v11, v10);
      mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)v11, v12);
      return 1;
    }
  }
  return result;
}

uint64_t CARenderServerGetVsyncOffSupportsRGBCompression(mach_port_t a1)
{
  mach_msg_return_t v4;
  mach_msg_header_t msg[2];
  uint64_t v6;

  mach_port_t v1 = a1;
  mach_msg_size_t v6 = *MEMORY[0x1E4F143B8];
  if (a1 || (uint64_t result = CARenderServerGetServerPort(0), (v1 = result) != 0))
  {
    *(_OWORD *)&msg[1].msgh_remote_port = 0u;
    *(_OWORD *)&msg[0].msgh_id = 0u;
    msg[0].msgh_size = 0;
    mach_port_t reply_port = mig_get_reply_port();
    msg[0].msgh_remote_port = v1;
    msg[0].msgh_local_port = reply_port;
    msg[0].msgh_bits = 5395;
    *(void *)&msg[0].msgh_voucher_port = 0x9D2C00000000;
    if (MEMORY[0x1E4F14B18])
    {
      voucher_mach_msg_set(msg);
      mach_port_t reply_port = msg[0].msgh_local_port;
    }
    CFArrayRef v4 = mach_msg(msg, 3, 0x18u, 0x30u, reply_port, 0, 0);
    if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(msg[0].msgh_local_port);
    }
    else if (v4)
    {
      mig_dealloc_reply_port(msg[0].msgh_local_port);
    }
    else
    {
      if (msg[0].msgh_id == 40336
        && (msg[0].msgh_bits & 0x80000000) == 0
        && msg[0].msgh_size == 40
        && !msg[0].msgh_remote_port
        && !msg[1].msgh_remote_port)
      {
        return LOBYTE(msg[1].msgh_local_port) != 0;
      }
      mach_msg_destroy(msg);
    }
    return 0;
  }
  return result;
}

BOOL CARenderServerIsRunning()
{
  return CA::Render::Server::_thread != 0;
}

void CARenderServerSetRootQueue(uint64_t a1)
{
  v1[5] = *MEMORY[0x1E4F143B8];
  v1[0] = MEMORY[0x1E4F143A8];
  v1[1] = 3221225472;
  v1[2] = __CASetRootQueue_block_invoke;
  v1[3] = &unk_1E52807A0;
  v1[4] = a1;
  if (CA::_root_queue_once[0] != -1) {
    dispatch_once(CA::_root_queue_once, v1);
  }
}

CFDataRef CARenderClientGetArchivedLayerTree(uint64_t a1)
{
  kern_return_t v5;
  mach_error_t v6;
  mach_msg_return_t v7;
  NSObject *v8;
  char *v9;
  CFDataRef v10;
  CFAllocatorRef v12;
  CFAllocatorContext context;
  mach_port_name_t name;
  unsigned char msg[36];
  int v16;
  CFIndex length;
  int v18;
  uint64_t v19;

  MEMORY[0x1F4188790](a1);
  long long v19 = *MEMORY[0x1E4F143B8];
  if (v1)
  {
    int v2 = v1;
    int v3 = BYTE1(xmmword_1EB2ACC50);
    name = 0;
    CFArrayRef v4 = (ipc_space_t *)MEMORY[0x1E4F14960];
    int v5 = mach_port_allocate(*MEMORY[0x1E4F14960], 1u, &name);
    if (v5)
    {
      mach_msg_size_t v6 = v5;
      if (x_log_hook_p())
      {
        mach_error_string(v6);
        x_log_();
      }
      else
      {
        CFIndex v8 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          int v9 = mach_error_string(v6);
          *(_DWORD *)msg = 136315394;
          *(void *)&msg[4] = v9;
          *(_WORD *)&msg[12] = 1024;
          *(_DWORD *)&msg[14] = v6;
          _os_log_impl(&dword_184668000, v8, OS_LOG_TYPE_ERROR, "Failed to allocate reply port: %s [0x%x]", msg, 0x12u);
        }
      }
      return 0;
    }
    *(_OWORD *)&msg[20] = 0u;
    *(_DWORD *)&msg[28] = name;
    CFIndex v16 = 1376256;
    *(_OWORD *)&msg[4] = 0u;
    length = *MEMORY[0x1E4F14068];
    CFTypeID v18 = v3;
    *(_DWORD *)msg = -2147483629;
    *(_DWORD *)&msg[8] = v2;
    *(void *)&msg[20] = 0x100009DDALL;
    if (MEMORY[0x1E4F14B18]) {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
    }
    uint64_t v7 = mach_msg((mach_msg_header_t *)msg, 17, 0x34u, 0, 0, 0, 0);
    if ((v7 - 268435459) > 1)
    {
      if (!v7)
      {
        bzero(msg, 0x1000uLL);
        mach_msg_size_t v10 = 0;
        if (mach_msg((mach_msg_header_t *)msg, 2, 0, 0x1000u, name, 0, 0)) {
          goto LABEL_16;
        }
        if (*(_DWORD *)&msg[20] != 1195461716) {
          goto LABEL_16;
        }
        mach_msg_size_t v10 = 0;
        if ((*(_DWORD *)msg & 0x80000000) == 0 || *(_DWORD *)&msg[24] != 1) {
          goto LABEL_16;
        }
        if (HIBYTE(v16) == 1)
        {
          context.versiouint64_t n = 0;
          memset(&context.retain, 0, 40);
          context.info = (void *)length;
          context.deallocate = (CFAllocatorDeallocateCallBack)deallocate_vm_region;
          context.preferredSize = 0;
          uint64_t v12 = CFAllocatorCreate(0, &context);
          mach_msg_size_t v10 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)&msg[28], length, v12);
          CFRelease(v12);
          goto LABEL_16;
        }
      }
    }
    else
    {
      if ((*(_WORD *)msg & 0x1F00) == 0x1100) {
        mach_port_deallocate(*v4, *(mach_port_name_t *)&msg[12]);
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
    mach_msg_size_t v10 = 0;
LABEL_16:
    mach_port_mod_refs(*v4, name, 1u, -1);
    return v10;
  }
  return 0;
}

uint64_t deallocate_vm_region(mach_vm_address_t address, mach_vm_size_t size)
{
  return mach_vm_deallocate(*MEMORY[0x1E4F14960], address, size);
}

CFDataRef CARenderServerGetLocalArchivedLayerTree(uint64_t a1)
{
  kern_return_t v7;
  mach_error_t v8;
  CFDataRef v9;
  NSObject *v10;
  char *v11;
  CFAllocatorRef v13;
  CFAllocatorContext context;
  mach_port_name_t name;
  unsigned char msg[36];
  int v17;
  CFIndex length;
  int v19;
  int v20;
  uint64_t v21;

  MEMORY[0x1F4188790](a1);
  int v21 = *MEMORY[0x1E4F143B8];
  if (!v1) {
    return 0;
  }
  int v3 = v2;
  int v4 = v1;
  int v5 = BYTE1(xmmword_1EB2ACC50);
  name = 0;
  mach_msg_size_t v6 = (ipc_space_t *)MEMORY[0x1E4F14960];
  uint64_t v7 = mach_port_allocate(*MEMORY[0x1E4F14960], 1u, &name);
  if (v7)
  {
    CFIndex v8 = v7;
    if (x_log_hook_p())
    {
      mach_error_string(v8);
      x_log_();
    }
    else
    {
      mach_msg_size_t v10 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        int v11 = mach_error_string(v8);
        *(_DWORD *)msg = 136315394;
        *(void *)&msg[4] = v11;
        *(_WORD *)&msg[12] = 1024;
        *(_DWORD *)&msg[14] = v8;
        _os_log_impl(&dword_184668000, v10, OS_LOG_TYPE_ERROR, "Failed to allocate reply port: %s [0x%x]", msg, 0x12u);
      }
    }
    return 0;
  }
  *(_OWORD *)&msg[20] = 0u;
  *(_OWORD *)&msg[4] = 0u;
  *(_DWORD *)&msg[28] = name;
  int v17 = 1376256;
  length = *MEMORY[0x1E4F14068];
  long long v19 = v3;
  mach_port_t v20 = v5;
  *(_DWORD *)msg = -2147483629;
  *(_DWORD *)&msg[8] = v4;
  *(void *)&msg[20] = 0x100009D62;
  if (MEMORY[0x1E4F14B18]) {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
  }
  if (mach_msg((mach_msg_header_t *)msg, 1, 0x38u, 0, 0, 0, 0)) {
    goto LABEL_8;
  }
  bzero(msg, 0x1000uLL);
  int v9 = 0;
  if (mach_msg((mach_msg_header_t *)msg, 2, 0, 0x1000u, name, 0, 0)) {
    goto LABEL_9;
  }
  if (*(_DWORD *)&msg[20] != 1195461716) {
    goto LABEL_9;
  }
  int v9 = 0;
  if ((*(_DWORD *)msg & 0x80000000) == 0 || *(_DWORD *)&msg[24] != 1) {
    goto LABEL_9;
  }
  if (HIBYTE(v17) != 1)
  {
LABEL_8:
    int v9 = 0;
  }
  else
  {
    context.versiouint64_t n = 0;
    memset(&context.retain, 0, 40);
    context.info = (void *)length;
    context.deallocate = (CFAllocatorDeallocateCallBack)deallocate_vm_region;
    context.preferredSize = 0;
    int v13 = CFAllocatorCreate(0, &context);
    int v9 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)&msg[28], length, v13);
    CFRelease(v13);
  }
LABEL_9:
  mach_port_mod_refs(*v6, name, 1u, -1);
  return v9;
}

uint64_t CARenderServerDebugDisplayStateOldInterface(int a1, char a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)&msg[20] = 0u;
  uint64_t v8 = 0;
  *(_OWORD *)&msg[4] = 0u;
  *(void *)&msg[24] = *MEMORY[0x1E4F14068];
  msg[32] = a2;
  *(_WORD *)&msg[33] = 0;
  msg[35] = 0;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(void *)&msg[16] = 0x9D6000000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_t reply_port = *(_DWORD *)&msg[12];
  }
  uint64_t v4 = mach_msg((mach_msg_header_t *)msg, 3, 0x24u, 0x2Cu, reply_port, 0, 0);
  uint64_t v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
    return v5;
  }
  if (v4)
  {
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    return v5;
  }
  if (*(_DWORD *)&msg[20] == 71)
  {
    uint64_t v5 = 4294966988;
LABEL_17:
    mach_msg_destroy((mach_msg_header_t *)msg);
    return v5;
  }
  if (*(_DWORD *)&msg[20] != 40388)
  {
    uint64_t v5 = 4294966995;
    goto LABEL_17;
  }
  uint64_t v5 = 4294966996;
  if ((*(_DWORD *)msg & 0x80000000) != 0) {
    goto LABEL_17;
  }
  if (*(_DWORD *)&msg[4] != 36) {
    goto LABEL_17;
  }
  if (*(_DWORD *)&msg[8]) {
    goto LABEL_17;
  }
  uint64_t v5 = *(unsigned int *)&msg[32];
  if (*(_DWORD *)&msg[32]) {
    goto LABEL_17;
  }
  return v5;
}

uint64_t CAMetalTextureGetBytesPerRow(void *a1)
{
  uint64_t v2 = [a1 pixelFormat];
  uint64_t v3 = 32;
  if ((unint64_t)(v2 - 70) > 0x2D) {
    goto LABEL_5;
  }
  if (((1 << (v2 - 70)) & 0xC03) != 0) {
    goto LABEL_6;
  }
  if (v2 == 115)
  {
    uint64_t v3 = 64;
  }
  else
  {
LABEL_5:
    if ((unint64_t)(v2 - 554) >= 2) {
      return 0;
    }
  }
LABEL_6:
  uint64_t v4 = (void *)[a1 device];
  uint64_t v5 = [a1 pixelFormat];
  uint64_t v6 = [a1 width];
  uint64_t v7 = [v4 minimumLinearTextureAlignmentForPixelFormat:v5];
  uint64_t v8 = 8 * v7 - 1;
  unint64_t v9 = v8 + v6 * v3;
  if ((v8 & (8 * v7)) != 0) {
    return v9 / (8 * v7) * 8 * v7;
  }
  else {
    return v9 & (-8 * v7);
  }
}

uint64_t CAMetalTextureGetBytes(void *a1, void *a2, unint64_t *a3)
{
  v13[6] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = [a1 width];
  uint64_t v7 = [a1 height];
  uint64_t BytesPerRow = CAMetalTextureGetBytesPerRow(a1);
  if (!BytesPerRow) {
    return 0;
  }
  uint64_t v9 = BytesPerRow;
  uint64_t v10 = BytesPerRow * v7;
  int v11 = CA::Render::aligned_malloc((CA::Render *)(BytesPerRow * v7), a3, 0);
  memset(v13, 0, 24);
  __int32 v13[3] = v6;
  v13[4] = v7;
  v13[5] = 1;
  [a1 getBytes:v11 bytesPerRow:v9 fromRegion:v13 mipmapLevel:0];
  *a2 = v11;
  return v10;
}

uint64_t CAMetalTextureGetPixelFormat(void *a1)
{
  uint64_t v1 = [a1 pixelFormat];
  if (v1 <= 114)
  {
    if ((unint64_t)(v1 - 70) < 2)
    {
      unsigned __int16 v3 = 16961;
      return v3 | 0x52470000u;
    }
    if ((unint64_t)(v1 - 80) < 2) {
      return 1111970369;
    }
  }
  else
  {
    if ((unint64_t)(v1 - 550) < 2) {
      return 1647534392;
    }
    if ((unint64_t)(v1 - 554) < 2) {
      return 1999843442;
    }
    if (v1 == 115)
    {
      unsigned __int16 v3 = 26689;
      return v3 | 0x52470000u;
    }
  }
  return 0;
}

uint64_t CA::WindowServer::FlipBook::get_destination_surface(CA::WindowServer::FlipBook *this)
{
  return 0;
}

__n128 CA::WindowServer::FlipBook::debug_surface_bounds@<Q0>(CA::WindowServer::FlipBook *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = *(__n128 *)(*((void *)this + 2) + 168);
  *a2 = result;
  return result;
}

BOOL CA::WindowServer::FlipBook::needs_debug_surface(CA::WindowServer::FlipBook *this)
{
  return byte_1EB2ACC23 && *((_DWORD *)this + 73) == 0;
}

uint64_t CA::WindowServer::FlipBook::supports_individual_frame_cancels(CA::WindowServer::FlipBook *this)
{
  return 0;
}

uint64_t CA::WindowServer::FlipBook::swapped_frame_displayed_p()
{
  return 0;
}

void CA::WindowServer::FlipBook::_resume(uint64_t *a1, int a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if ((a1[3] & 3) != 2) {
    __assert_rtn("_resume", "windowserver-flipbook.cpp", 867, "_state == kFlipBookStateSuspended");
  }
  if ((a2 & 0xFF00) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 2);
    int v11 = (void *)a1[19];
    uint64_t v12 = (void *)a1[20];
    if (v11 != v12)
    {
      do
      {
        CA::WindowServer::FlipBook::reuse_frame(a1, v11);
        v11 += 13;
      }
      while (v11 != v12);
      int v11 = (void *)a1[19];
    }
    a1[20] = (uint64_t)v11;
    *((unsigned char *)a1 + 24) = a1[3] & 0xFC | 1;
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 2);
    return;
  }
  uint64_t v4 = mach_continuous_time();
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 2);
  uint64_t v5 = a1[19];
  uint64_t v6 = a1[20];
  if (v5 == v6) {
    goto LABEL_32;
  }
  if (*(void *)(v5 + 40) >= v4)
  {
    unint64_t v10 = 0;
  }
  else
  {
    uint64_t v7 = v5 + 104;
    do
    {
      uint64_t v8 = v7;
      if (v7 == v6) {
        break;
      }
      uint64_t v9 = *(void *)(v7 + 40);
      v7 += 104;
    }
    while (v9 < v4);
    unint64_t v10 = *(void *)(v8 - 72);
  }
  int v13 = (long long *)(v5 - 104);
  do
  {
    int v14 = (long long *)((char *)v13 + 104);
    unint64_t v15 = *((void *)v13 + 17);
    if (v15 < v10)
    {
      (*(void (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, (uint64_t)v13 + 104);
      CA::WindowServer::FlipBook::reuse_frame(a1, (void *)v13 + 13);
      goto LABEL_30;
    }
    if (v15 == v10)
    {
      uint64_t v16 = *a1;
      if ((a2 & 0x10000) != 0)
      {
        (*(void (**)(uint64_t *, uint64_t))(v16 + 56))(a1, (uint64_t)v13 + 104);
        CA::WindowServer::FlipBook::reuse_frame(a1, (void *)v13 + 13);
        (*(void (**)(uint64_t *))(*a1 + 64))(a1);
        goto LABEL_30;
      }
      (*(void (**)(uint64_t *))(v16 + 64))(a1);
      *((void *)v13 + 18) = v4;
      uint64_t v33 = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      int v30 = 0;
      v34 &= 0xFCu;
      (*(void (**)(uint64_t *, uint64_t, long long *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
      uint64_t v33 = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      int v30 = 0;
      v34 &= 0xFCu;
      (*(void (**)(uint64_t *, uint64_t, long long *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
      uint64_t v33 = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      int v30 = 0;
      v34 &= 0xFCu;
      (*(void (**)(uint64_t *, uint64_t, long long *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
      uint64_t v33 = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      int v30 = 0;
      v34 &= 0xFCu;
      (*(void (**)(uint64_t *, uint64_t, long long *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
      uint64_t v33 = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      int v30 = 0;
      v34 &= 0xFCu;
      (*(void (**)(uint64_t *, uint64_t, long long *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
      uint64_t v33 = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      int v30 = 0;
      v34 &= 0xFCu;
      (*(void (**)(uint64_t *, uint64_t, long long *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
LABEL_24:
      uint64_t v33 = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      int v30 = 0;
      v34 &= 0xFCu;
      goto LABEL_25;
    }
    if (v14 == (long long *)a1[19]) {
      goto LABEL_24;
    }
    long long v17 = *v13;
    long long v18 = v13[1];
    long long v19 = v13[2];
    int v30 = *((_DWORD *)v13 + 12);
    long long v28 = v18;
    long long v29 = v19;
    long long v27 = v17;
    long long v31 = *(long long *)((char *)v13 + 52);
    long long v32 = *(long long *)((char *)v13 + 68);
    uint64_t v20 = *((void *)v13 + 11);
    char v34 = *((unsigned char *)v13 + 96);
    uint64_t v33 = v20;
LABEL_25:
    (*(void (**)(uint64_t *, uint64_t, long long *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
    unint64_t v21 = a1[17];
    if (v21 >= a1[18])
    {
      long long v26 = std::vector<CA::WindowServer::FlipBook::Frame>::__push_back_slow_path<CA::WindowServer::FlipBook::Frame const&>((void **)a1 + 16, (long long *)((char *)v13 + 104));
    }
    else
    {
      long long v22 = *v14;
      long long v23 = *(long long *)((char *)v13 + 120);
      long long v24 = *(long long *)((char *)v13 + 136);
      *(_DWORD *)(v21 + 48) = *((_DWORD *)v13 + 38);
      *(_OWORD *)(v21 + 16) = v23;
      *(_OWORD *)(v21 + 32) = v24;
      *(_OWORD *)unint64_t v21 = v22;
      *(_OWORD *)(v21 + 52) = *(long long *)((char *)v13 + 156);
      *(_OWORD *)(v21 + 68) = *(long long *)((char *)v13 + 172);
      uint64_t v25 = *((void *)v13 + 24);
      *(unsigned char *)(v21 + 96) = *((unsigned char *)v13 + 200);
      *(void *)(v21 + 88) = v25;
      long long v26 = (void *)(v21 + 104);
    }
    a1[17] = (uint64_t)v26;
LABEL_30:
    int v13 = (long long *)((char *)v13 + 104);
  }
  while ((long long *)((char *)v14 + 104) != (long long *)a1[20]);
  uint64_t v5 = a1[19];
LABEL_32:
  a1[20] = v5;
  CA::WindowServer::FlipBook::swap_enqueued_locked(a1);
  *((unsigned char *)a1 + 24) = a1[3] & 0xFC | 1;
  os_unfair_lock_unlock((os_unfair_lock_t)a1 + 2);
}

void CA::WindowServer::FlipBook::reuse_frame(void *a1, void *a2)
{
  if (*a2 == a1[22]) {
    __assert_rtn("reuse_frame", "windowserver-flipbook.cpp", 1520, "frame.surface != _apl_scratch_buffer.surface");
  }

  CA::WindowServer::FlipBook::free_surface(a1, a2);
}

void *CA::WindowServer::FlipBook::swap_enqueued_locked(void *this)
{
  uint64_t v1 = (uint64_t)this;
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (long long *)this[10];
  if (v2 != (long long *)this[11])
  {
    do
    {
      if (x_log_hook_p())
      {
        IOSurfaceGetID(*(IOSurfaceRef *)v2);
        x_log_();
      }
      else
      {
        unsigned __int16 v3 = x_log_category_flipbook;
        if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
        {
          IOSurfaceID ID = IOSurfaceGetID(*(IOSurfaceRef *)v2);
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = ID;
          _os_log_impl(&dword_184668000, v3, OS_LOG_TYPE_DEFAULT, "previously enqueued surface: 0x%x", buf, 8u);
        }
      }
      if (*(_DWORD *)(v1 + 292) == 1
        && (uint64_t v5 = CA::WindowServer::FlipBook::previous_frame_with_seed((CA::WindowServer::FlipBook *)v1, *((void *)v2 + 4) - 1)) != 0)
      {
        long long v6 = *(_OWORD *)v5;
        long long v7 = *(_OWORD *)(v5 + 16);
        long long v8 = *(_OWORD *)(v5 + 32);
        int v18 = *(_DWORD *)(v5 + 48);
        long long v16 = v7;
        long long v17 = v8;
        *(_OWORD *)buf = v6;
        long long v19 = *(_OWORD *)(v5 + 52);
        long long v20 = *(_OWORD *)(v5 + 68);
        char v9 = *(unsigned char *)(v5 + 96);
        uint64_t v21 = *(void *)(v5 + 88);
        char v22 = v9;
      }
      else
      {
        uint64_t v21 = 0;
        *(_OWORD *)buf = 0u;
        long long v16 = 0u;
        long long v17 = 0u;
        int v18 = 0;
        v22 &= 0xFCu;
      }
      (*(void (**)(uint64_t, long long *, uint8_t *))(*(void *)v1 + 96))(v1, v2, buf);
      unint64_t v10 = *(void *)(v1 + 136);
      if (v10 >= *(void *)(v1 + 144))
      {
        this = std::vector<CA::WindowServer::FlipBook::Frame>::__push_back_slow_path<CA::WindowServer::FlipBook::Frame const&>((void **)(v1 + 128), v2);
      }
      else
      {
        long long v11 = *v2;
        long long v12 = v2[1];
        long long v13 = v2[2];
        *(_DWORD *)(v10 + 48) = *((_DWORD *)v2 + 12);
        *(_OWORD *)(v10 + 16) = v12;
        *(_OWORD *)(v10 + 32) = v13;
        *(_OWORD *)unint64_t v10 = v11;
        *(_OWORD *)(v10 + 52) = *(long long *)((char *)v2 + 52);
        *(_OWORD *)(v10 + 68) = *(long long *)((char *)v2 + 68);
        uint64_t v14 = *((void *)v2 + 11);
        *(unsigned char *)(v10 + 96) = *((unsigned char *)v2 + 96);
        *(void *)(v10 + 88) = v14;
        this = (void *)(v10 + 104);
      }
      *(void *)(v1 + 136) = this;
      uint64_t v2 = (long long *)((char *)v2 + 104);
    }
    while (v2 != *(long long **)(v1 + 88));
    uint64_t v2 = *(long long **)(v1 + 80);
  }
  *(void *)(v1 + 88) = v2;
  return this;
}

void *std::vector<CA::WindowServer::FlipBook::Frame>::__push_back_slow_path<CA::WindowServer::FlipBook::Frame const&>(void **a1, long long *a2)
{
  uint64_t v2 = 0x4EC4EC4EC4EC4EC5 * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x276276276276276) {
    abort();
  }
  if (0x9D89D89D89D89D8ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x9D89D89D89D89D8ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3)) >= 0x13B13B13B13B13BLL) {
    unint64_t v6 = 0x276276276276276;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6) {
    unint64_t v6 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::WindowServer::FlipBook::Frame>>(v6);
  }
  else {
    uint64_t v7 = 0;
  }
  unint64_t v8 = v6 + 104 * v2;
  unint64_t v9 = v6 + 104 * v7;
  long long v10 = *a2;
  long long v11 = a2[1];
  long long v12 = a2[2];
  *(_DWORD *)(v8 + 48) = *((_DWORD *)a2 + 12);
  *(_OWORD *)(v8 + 16) = v11;
  *(_OWORD *)(v8 + 32) = v12;
  *(_OWORD *)unint64_t v8 = v10;
  *(_OWORD *)(v8 + 52) = *(long long *)((char *)a2 + 52);
  *(_OWORD *)(v8 + 68) = *(long long *)((char *)a2 + 68);
  uint64_t v13 = *((void *)a2 + 11);
  *(unsigned char *)(v8 + 96) = *((unsigned char *)a2 + 96);
  *(void *)(v8 + 88) = v13;
  uint64_t v14 = (void *)(v8 + 104);
  long long v16 = (char *)*a1;
  unint64_t v15 = (char *)a1[1];
  if (v15 != *a1)
  {
    do
    {
      long long v17 = *(_OWORD *)(v15 - 104);
      long long v18 = *(_OWORD *)(v15 - 88);
      long long v19 = *(_OWORD *)(v15 - 72);
      *(_DWORD *)(v8 - 56) = *((_DWORD *)v15 - 14);
      *(_OWORD *)(v8 - 72) = v19;
      *(_OWORD *)(v8 - 88) = v18;
      *(_OWORD *)(v8 - 104) = v17;
      *(_OWORD *)(v8 - 52) = *(_OWORD *)(v15 - 52);
      *(_OWORD *)(v8 - 36) = *(_OWORD *)(v15 - 36);
      uint64_t v20 = *((void *)v15 - 2);
      *(unsigned char *)(v8 - 8) = *(v15 - 8);
      *(void *)(v8 - 16) = v20;
      v8 -= 104;
      v15 -= 104;
    }
    while (v15 != v16);
    unint64_t v15 = (char *)*a1;
  }
  *a1 = (void *)v8;
  a1[1] = v14;
  a1[2] = (void *)v9;
  if (v15) {
    operator delete(v15);
  }
  return v14;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CA::WindowServer::FlipBook::Frame>>(unint64_t a1)
{
  if (a1 >= 0x276276276276277) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(104 * a1);
}

uint64_t CA::WindowServer::FlipBook::previous_frame_with_seed(CA::WindowServer::FlipBook *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 17);
  if (*((void *)this + 16) != v2 && *(void *)(v2 - 72) == a2) {
    return v2 - 104;
  }
  uint64_t v2 = *((void *)this + 11);
  if (*((void *)this + 10) != v2 && *(void *)(v2 - 72) == a2) {
    return v2 - 104;
  }
  uint64_t v4 = *((void *)this + 20);
  if (*((void *)this + 19) == v4) {
    return 0;
  }
  if (*(void *)(v4 - 72) == a2) {
    return v4 - 104;
  }
  return 0;
}

void CA::WindowServer::FlipBook::free_surface(void *a1, void *a2)
{
  uint64_t v4 = *(void *)(*(uint64_t (**)(void *))(*a1 + 88))(a1);
  a1[9] -= a2[11];
  (*(void (**)(uint64_t, void))(*(void *)v4 + 40))(v4, *a2);
  CFRelease((CFTypeRef)*a2);
  uint64_t v5 = a2[1];
  if (v5) {
    CA::OGL::Context::release_surface_async(v4, v5);
  }
  if (a2[2])
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    CFRelease((CFTypeRef)a2[2]);
    uint64_t v6 = a2[3];
    if (v6)
    {
      CA::OGL::Context::release_surface_async(v4, v6);
    }
  }
}

CA::Render::Context *CA::WindowServer::FlipBook::_suspend(uint64_t a1)
{
  v4[1] = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 24) & 3) != 1) {
    __assert_rtn("_suspend", "windowserver-flipbook.cpp", 847, "_state == kFlipBookStateActive");
  }
  v4[0] = 0;
  unsigned __int8 v3 = 0;
  CA::WindowServer::FlipBook::cancel((CA::WindowServer::FlipBook *)a1, v4, &v3, 0, 1);
  if (v4[0]) {
    (*(void (**)(uint64_t, void))(*(void *)a1 + 48))(a1, v3);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 112))(a1);
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a1 + 24) & 0xFC | 2;
  __n128 result = CA::WindowServer::FlipBook::invalidate_context((CA::Render::Context *)*(unsigned int *)(a1 + 48));
  *(_DWORD *)(a1 + 48) = 0;
  return result;
}

void CA::WindowServer::FlipBook::cancel(CA::WindowServer::FlipBook *this, unint64_t *a2, unsigned __int8 *a3, unsigned int *a4, int a5)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  *a3 = 0;
  if ((*((unsigned char *)this + 24) & 3) == 2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 2);
    uint64_t v6 = (void *)*((void *)this + 19);
    uint64_t v7 = (void *)*((void *)this + 20);
    uint64_t v8 = v7 - v6;
    if (v7 != v6)
    {
      do
      {
        CA::WindowServer::FlipBook::reuse_frame(this, v6);
        v6 += 13;
      }
      while (v6 != v7);
      uint64_t v7 = (void *)*((void *)this + 19);
    }
    *((void *)this + 20) = v7;
    if (x_log_hook_p())
    {
      unint64_t v9 = *((void *)this + 9);
      if (v9 >= 0x400)
      {
        double v32 = 1.0;
        do
          double v32 = v32 * 0.0009765625;
        while (v32 * (double)v9 >= 1024.0);
      }
      x_log_();
    }
    else
    {
      long long v18 = x_log_category_flipbook;
      if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v19 = *((void *)this + 9);
        double v20 = (double)v19;
        if (v19 >= 0x400)
        {
          double v66 = 1.0;
          do
          {
            double v66 = v66 * 0.0009765625;
            double v21 = v66 * v20;
          }
          while (v66 * v20 >= 1024.0);
        }
        else
        {
          double v21 = (double)v19;
        }
        uint64_t v67 = v19 > 0x3FF;
        if ((v19 & 0xFFFFFFFFFFF00000) != 0) {
          ++v67;
        }
        if ((v19 & 0xFFFFFFFFC0000000) != 0) {
          ++v67;
        }
        if (v19 >> 40) {
          ++v67;
        }
        if (v19 >> 50) {
          ++v67;
        }
        if (v19 >> 60) {
          uint64_t v68 = v67 + 1;
        }
        else {
          uint64_t v68 = v67;
        }
        uint64_t v69 = off_1E527FCB0[v68];
        *(_DWORD *)buf = 134218498;
        uint64_t v77 = 0x4EC4EC4EC4EC4EC5 * v8;
        __int16 v78 = 2048;
        double v79 = v21;
        __int16 v80 = 2080;
        int v81 = v69;
        _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_DEFAULT, "FlipBook::cancel(), cancelled %zu suppressed frames, memory usage = %.2lf %s", buf, 0x20u);
      }
    }
    unsigned int v70 = (os_unfair_lock_s *)((char *)this + 8);
LABEL_125:
    os_unfair_lock_unlock(v70);
    return;
  }
  (*(void (**)(CA::WindowServer::FlipBook *, void))(*(void *)this + 72))(this, 0);
  if ((*(uint64_t (**)(CA::WindowServer::FlipBook *))(*(void *)this + 128))(this))
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 2);
    uint64_t v14 = *((void *)this + 17);
    uint64_t v15 = 0x4EC4EC4EC4EC4EC5 * ((v14 - *((void *)this + 16)) >> 3);
    uint64_t v75 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*((void *)this + 11) - *((void *)this + 10)) >> 3);
    *((void *)this + 7) = 0;
    do
    {
      uint64_t v16 = v14;
      if (v14 == *((void *)this + 16))
      {
        int v17 = 0;
        goto LABEL_28;
      }
      v14 -= 104;
    }
    while (((*(uint64_t (**)(CA::WindowServer::FlipBook *, uint64_t))(*(void *)this + 104))(this, v16 - 104) & 1) != 0);
    *a2 = *(void *)(v16 - 72);
    *a3 = *(unsigned char *)(v16 - 8) & 1;
    int v17 = *(_DWORD *)(v16 - 56);
    if (a4)
    {
      if (CADeviceHasInternalBuild::once[0] != -1) {
        dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
      }
      if (CADeviceHasInternalBuild::internal) {
        CA::WindowServer::FlipBook::copy_surface((uint64_t)this, *(IOSurfaceRef *)v14, *(unsigned char *)(v16 - 8), a4);
      }
    }
    *((void *)this + 7) = *(void *)(v16 - 64);
    uint64_t v14 = *((void *)this + 16);
LABEL_28:
    long long v29 = (long long *)*((void *)this + 17);
    if (a5)
    {
      if (v16 == v14) {
        int v30 = (long long *)v14;
      }
      else {
        int v30 = (long long *)(v16 - 104);
      }
      uint64_t v31 = 0x4EC4EC4EC4EC4EC5 * (((char *)v29 - (char *)v30) >> 3);
      std::vector<CA::WindowServer::FlipBook::Frame>::__insert_with_size[abi:nn180100]<std::__wrap_iter<CA::WindowServer::FlipBook::Frame*>,std::__wrap_iter<CA::WindowServer::FlipBook::Frame*>>((unint64_t *)this + 19, *((void *)this + 20), v30, v29, v31);
      std::vector<CA::WindowServer::FlipBook::Frame>::erase((uint64_t)this + 128, (uint64_t)v30, *((void *)this + 17));
      uint64_t v14 = *((void *)this + 16);
      long long v29 = (long long *)*((void *)this + 17);
    }
    else
    {
      uint64_t v31 = 0;
    }
    while ((long long *)v14 != v29)
    {
      if (*(void *)(v14 + 32) <= *a2)
      {
        v14 += 104;
      }
      else
      {
        CA::WindowServer::FlipBook::reuse_frame(this, (void *)v14);
        uint64_t v33 = *((void *)this + 17);
        long long v29 = (long long *)v14;
        if (v14 + 104 != v33)
        {
          uint64_t v34 = v14;
          do
          {
            long long v29 = (long long *)(v34 + 104);
            long long v35 = *(_OWORD *)(v34 + 120);
            *(_OWORD *)uint64_t v34 = *(_OWORD *)(v34 + 104);
            *(_OWORD *)(v34 + 16) = v35;
            *(_OWORD *)(v34 + 32) = *(_OWORD *)(v34 + 136);
            *(_DWORD *)(v34 + 48) = *(_DWORD *)(v34 + 152);
            *(_OWORD *)(v34 + 52) = *(_OWORD *)(v34 + 156);
            *(void *)(v34 + 88) = *(void *)(v34 + 192);
            *(unsigned char *)(v34 + 96) = *(unsigned char *)(v34 + 200);
            uint64_t v36 = v34 + 208;
            *(_OWORD *)(v34 + 68) = *(_OWORD *)(v34 + 172);
            v34 += 104;
          }
          while (v36 != v33);
        }
        *((void *)this + 17) = v29;
        ++v31;
      }
    }
    uint64_t v38 = *((void *)this + 10);
    uint64_t v37 = *((void *)this + 11);
    if (a5)
    {
      if (v38 != v37)
      {
        mach_msg_size_t v39 = (char *)*((void *)this + 20);
        do
        {
          if ((unint64_t)v39 >= *((void *)this + 21))
          {
            mach_msg_size_t v39 = (char *)std::vector<CA::WindowServer::FlipBook::Frame>::__push_back_slow_path<CA::WindowServer::FlipBook::Frame const&>((void **)this + 19, (long long *)v38);
          }
          else
          {
            long long v40 = *(_OWORD *)v38;
            long long v41 = *(_OWORD *)(v38 + 16);
            long long v42 = *(_OWORD *)(v38 + 32);
            *((_DWORD *)v39 + 12) = *(_DWORD *)(v38 + 48);
            *((_OWORD *)v39 + 1) = v41;
            *((_OWORD *)v39 + 2) = v42;
            *(_OWORD *)mach_msg_size_t v39 = v40;
            *(_OWORD *)(v39 + 52) = *(_OWORD *)(v38 + 52);
            *(_OWORD *)(v39 + 68) = *(_OWORD *)(v38 + 68);
            uint64_t v43 = *(void *)(v38 + 88);
            v39[96] = *(unsigned char *)(v38 + 96);
            *((void *)v39 + 11) = v43;
            v39 += 104;
          }
          *((void *)this + 20) = v39;
          v38 += 104;
        }
        while (v38 != *((void *)this + 11));
      }
    }
    else if (v38 != v37)
    {
      do
      {
        CA::WindowServer::FlipBook::reuse_frame(this, (void *)v38);
        v38 += 104;
      }
      while (v38 != *((void *)this + 11));
    }
    *((void *)this + 11) = *((void *)this + 10);
    if (x_log_hook_p())
    {
      unint64_t v44 = *((void *)this + 9);
      if (v44 >= 0x400)
      {
        double v71 = 1.0;
        do
          double v71 = v71 * 0.0009765625;
        while (v71 * (double)v44 >= 1024.0);
      }
      x_log_();
    }
    else
    {
      uint64_t v45 = x_log_category_flipbook;
      if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v46 = *a2;
        uint64_t v47 = *((void *)this + 7);
        unint64_t v48 = *((void *)this + 9);
        double v49 = (double)v48;
        if (v48 >= 0x400)
        {
          double v72 = 1.0;
          uint64_t v51 = v75;
          do
          {
            double v72 = v72 * 0.0009765625;
            double v50 = v72 * v49;
          }
          while (v72 * v49 >= 1024.0);
        }
        else
        {
          double v50 = (double)v48;
          uint64_t v51 = v75;
        }
        uint64_t v73 = v48 > 0x3FF;
        if ((v48 & 0xFFFFFFFFFFF00000) != 0) {
          ++v73;
        }
        if ((v48 & 0xFFFFFFFFC0000000) != 0) {
          ++v73;
        }
        if (v48 >> 40) {
          ++v73;
        }
        if (v48 >> 50) {
          ++v73;
        }
        if (v48 >> 60) {
          ++v73;
        }
        uint64_t v74 = off_1E527FCB0[v73];
        *(_DWORD *)buf = 134219778;
        uint64_t v77 = v31;
        __int16 v78 = 2048;
        double v79 = *(double *)&v15;
        __int16 v80 = 2048;
        int v81 = (char *)v51;
        __int16 v82 = 1024;
        int v83 = v17;
        __int16 v84 = 2048;
        uint64_t v85 = v46;
        __int16 v86 = 2048;
        uint64_t v87 = v47;
        __int16 v88 = 2048;
        double v89 = v50;
        __int16 v90 = 2080;
        uint64_t v91 = v74;
        _os_log_impl(&dword_184668000, v45, OS_LOG_TYPE_DEFAULT, "FlipBook::cancel(), cancelled %zu/%zu swapped frames and %zu enqueued frames, last frame = swap %u (seed %llu, timestamp %llu), memory usage = %.2lf %s", buf, 0x4Eu);
      }
    }
    CA::WindowServer::FlipBook::collect(this);
    unsigned int v70 = (os_unfair_lock_s *)((char *)this + 8);
    goto LABEL_125;
  }
  (*(void (**)(CA::WindowServer::FlipBook *))(*(void *)this + 112))(this);
  *a2 = 0;
  *a3 = 0;
  uint64_t v22 = mach_continuous_time();
  *((void *)this + 7) = 0;
  os_unfair_lock_lock((os_unfair_lock_t)this + 2);
  uint64_t v25 = (long long *)*((void *)this + 16);
  uint64_t v23 = (long long *)*((void *)this + 17);
  long long v24 = (long long **)((char *)this + 128);
  if (v25 == v23)
  {
    uint64_t v23 = (long long *)*((void *)this + 16);
    long long v26 = v23;
  }
  else
  {
    long long v26 = (long long *)*((void *)this + 16);
    if (*((void *)v25 + 5) < v22)
    {
      long long v27 = v25 + 6;
      while (1)
      {
        long long v28 = v27;
        *a2 = *((void *)v27 - 8);
        *a3 = *v27 & 1;
        long long v26 = (long long *)(v27 + 8);
        uint64_t v23 = (long long *)*((void *)this + 17);
        if (v26 == v23) {
          break;
        }
        long long v27 = v28 + 104;
        if (*((void *)v28 + 6) >= v22)
        {
          long long v26 = (long long *)(v28 + 8);
          goto LABEL_109;
        }
      }
      uint64_t v23 = v26;
LABEL_109:
      uint64_t v25 = *v24;
      if (!a5) {
        goto LABEL_66;
      }
      goto LABEL_62;
    }
  }
  if (a5)
  {
LABEL_62:
    if (v26 == v25) {
      uint64_t v52 = 0;
    }
    else {
      uint64_t v52 = -1;
    }
    char v53 = (long long *)((char *)v26 + 104 * v52);
    std::vector<CA::WindowServer::FlipBook::Frame>::__insert_with_size[abi:nn180100]<std::__wrap_iter<CA::WindowServer::FlipBook::Frame*>,std::__wrap_iter<CA::WindowServer::FlipBook::Frame*>>((unint64_t *)this + 19, *((void *)this + 20), v53, v23, 0x4EC4EC4EC4EC4EC5 * (((char *)v23 - (char *)v53) >> 3));
    std::vector<CA::WindowServer::FlipBook::Frame>::erase((uint64_t)this + 128, (uint64_t)v53, *((void *)this + 17));
    uint64_t v25 = (long long *)*((void *)this + 16);
    uint64_t v23 = (long long *)*((void *)this + 17);
  }
LABEL_66:
  if (v25 == v23)
  {
    char v58 = v23;
  }
  else
  {
    do
    {
      if (*((void *)v25 + 4) == *a2)
      {
        uint64_t v25 = (long long *)((char *)v25 + 104);
      }
      else
      {
        CA::WindowServer::FlipBook::reuse_frame(this, v25);
        uint64_t v54 = (long long *)*((void *)this + 17);
        uint64_t v23 = v25;
        if ((long long *)((char *)v25 + 104) != v54)
        {
          int v55 = v25;
          do
          {
            uint64_t v23 = (long long *)((char *)v55 + 104);
            long long v56 = *(long long *)((char *)v55 + 120);
            *int v55 = *(long long *)((char *)v55 + 104);
            v55[1] = v56;
            v55[2] = *(long long *)((char *)v55 + 136);
            *((_DWORD *)v55 + 12) = *((_DWORD *)v55 + 38);
            *(long long *)((char *)v55 + 52) = *(long long *)((char *)v55 + 156);
            *((void *)v55 + 11) = *((void *)v55 + 24);
            *((unsigned char *)v55 + 96) = *((unsigned char *)v55 + 200);
            char v57 = v55 + 13;
            *(long long *)((char *)v55 + 68) = *(long long *)((char *)v55 + 172);
            int v55 = (long long *)((char *)v55 + 104);
          }
          while (v57 != v54);
        }
        *((void *)this + 17) = v23;
      }
    }
    while (v25 != v23);
    char v58 = *v24;
  }
  if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v23 - (char *)v58) >> 3)) >= 2) {
    __assert_rtn("cancel_all", "windowserver-flipbook.cpp", 306, "_swapped.size () <= 1");
  }
  uint64_t v60 = *((void *)this + 10);
  uint64_t v59 = *((void *)this + 11);
  if (a5)
  {
    if (v60 != v59)
    {
      unint64_t v61 = (char *)*((void *)this + 20);
      do
      {
        if ((unint64_t)v61 >= *((void *)this + 21))
        {
          unint64_t v61 = (char *)std::vector<CA::WindowServer::FlipBook::Frame>::__push_back_slow_path<CA::WindowServer::FlipBook::Frame const&>((void **)this + 19, (long long *)v60);
        }
        else
        {
          long long v62 = *(_OWORD *)v60;
          long long v63 = *(_OWORD *)(v60 + 16);
          long long v64 = *(_OWORD *)(v60 + 32);
          *((_DWORD *)v61 + 12) = *(_DWORD *)(v60 + 48);
          *((_OWORD *)v61 + 1) = v63;
          *((_OWORD *)v61 + 2) = v64;
          *(_OWORD *)unint64_t v61 = v62;
          *(_OWORD *)(v61 + 52) = *(_OWORD *)(v60 + 52);
          *(_OWORD *)(v61 + 68) = *(_OWORD *)(v60 + 68);
          uint64_t v65 = *(void *)(v60 + 88);
          v61[96] = *(unsigned char *)(v60 + 96);
          *((void *)v61 + 11) = v65;
          v61 += 104;
        }
        *((void *)this + 20) = v61;
        v60 += 104;
      }
      while (v60 != *((void *)this + 11));
    }
  }
  else if (v60 != v59)
  {
    do
    {
      CA::WindowServer::FlipBook::reuse_frame(this, (void *)v60);
      v60 += 104;
    }
    while (v60 != *((void *)this + 11));
  }
  *((void *)this + 11) = *((void *)this + 10);
  CA::WindowServer::FlipBook::collect(this);

  os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
}

CA::Render::Context *CA::WindowServer::FlipBook::invalidate_context(CA::Render::Context *this)
{
  if (this)
  {
    this = (CA::Render::Context *)CA::Render::Context::context_by_id(this);
    if (this)
    {
      uint64_t v2 = (atomic_uint *)this;
      this = (CA::Render::Context *)CA::WindowServer::FlipBook::invalidate_context(this, v1);
      if (atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1)
      {
        unsigned __int8 v3 = *(uint64_t (**)(atomic_uint *))(*(void *)v2 + 16);
        return (CA::Render::Context *)v3(v2);
      }
    }
  }
  return this;
}

uint64_t CA::WindowServer::FlipBook::invalidate_context(CA::WindowServer::FlipBook *this, CA::Render::Context *a2)
{
  unsigned __int8 v3 = (pthread_mutex_t *)((char *)this + 72);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 72));
  uint64_t v4 = CA::Render::Context::root_layer_handle(this);
  if (v4)
  {
    *(void *)(v4 + 96) |= 7uLL;
    *(_DWORD *)(v4 + 12) |= 0x400u;
  }

  return pthread_mutex_unlock(v3);
}

void CA::WindowServer::FlipBook::copy_surface(uint64_t a1, IOSurfaceRef buffer, char a3, mach_port_t *a4)
{
  if (*(_DWORD *)(a1 + 292) == 1) {
    buffer = (IOSurfaceRef)(*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 152))(a1, a3 & 1);
  }
  if (buffer)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    unsigned int v8 = *(_DWORD *)(v7 + 176);
    int v9 = *(_DWORD *)(v7 + 180);
    if (CADeviceUseCIF10::once != -1) {
      dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_12019);
    }
    if (CADeviceUseCIF10::enable_cif10) {
      uint64_t v10 = 1999843442;
    }
    else {
      uint64_t v10 = 1111970369;
    }
    long long v11 = CA::WindowServer::IOSurface::wrap_buffer(*(CA::WindowServer::IOSurface **)(a1 + 16), buffer, 0, 0);
    iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v10, v8, v9, 0, 0, 0, v12);
    uint64_t v14 = CA::WindowServer::IOSurface::wrap_buffer(*(CA::WindowServer::IOSurface **)(a1 + 16), iosurface_with_pixel_format, 0, 0);
    (*(void (**)(float *, float *, uint64_t, void, void, void, void, float))(*(void *)v14 + 176))(v14, v11, 4096, 0, 0, 0, 0, 1.0);
    *a4 = IOSurfaceCreateMachPort(iosurface_with_pixel_format);
    CA::WindowServer::Surface::unref((CA::WindowServer::Surface *)v11);
    CA::WindowServer::Surface::unref((CA::WindowServer::Surface *)v14);
    CFRelease(iosurface_with_pixel_format);
  }
}

__n128 std::vector<CA::WindowServer::FlipBook::Frame>::__insert_with_size[abi:nn180100]<std::__wrap_iter<CA::WindowServer::FlipBook::Frame*>,std::__wrap_iter<CA::WindowServer::FlipBook::Frame*>>(unint64_t *a1, uint64_t a2, long long *a3, long long *a4, uint64_t a5)
{
  if (a5 < 1) {
    return result;
  }
  uint64_t v6 = a3;
  int v9 = (char *)*a1;
  unint64_t v8 = a1[1];
  uint64_t v10 = (uint64_t)(a2 - *a1) / 104;
  uint64_t v11 = *a1 + 104 * v10;
  unint64_t v12 = a1[2];
  if (0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v12 - v8) >> 3) >= a5)
  {
    if (0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v8 - v11) >> 3) >= a5)
    {
      int v17 = (long long *)((char *)a3 + 104 * a5);
      unint64_t v19 = a1[1];
    }
    else
    {
      int v17 = (long long *)((char *)a3 + 8 * ((uint64_t)(v8 - v11) >> 3));
      if (v17 == a4)
      {
        unint64_t v19 = a1[1];
      }
      else
      {
        long long v18 = (long long *)((char *)a3 + 8 * ((uint64_t)(v8 - v11) >> 3));
        unint64_t v19 = a1[1];
        do
        {
          long long v20 = *v18;
          long long v21 = v18[1];
          long long v22 = v18[2];
          *(_DWORD *)(v19 + 48) = *((_DWORD *)v18 + 12);
          *(_OWORD *)(v19 + 16) = v21;
          *(_OWORD *)(v19 + 32) = v22;
          *(_OWORD *)unint64_t v19 = v20;
          *(_OWORD *)(v19 + 52) = *(long long *)((char *)v18 + 52);
          __n128 result = *(__n128 *)((char *)v18 + 68);
          *(__n128 *)(v19 + 68) = result;
          uint64_t v24 = *((void *)v18 + 11);
          *(unsigned char *)(v19 + 96) = *((unsigned char *)v18 + 96);
          *(void *)(v19 + 88) = v24;
          v19 += 104;
          long long v18 = (long long *)((char *)v18 + 104);
        }
        while (v18 != a4);
      }
      a1[1] = v19;
      if ((uint64_t)(v8 - v11) < 1) {
        return result;
      }
    }
    uint64_t v47 = v11 + 104 * a5;
    unint64_t v48 = (long long *)(v19 - 104 * a5);
    unint64_t v49 = v19;
    if ((unint64_t)v48 < v8)
    {
      unint64_t v49 = v19;
      do
      {
        long long v50 = *v48;
        long long v51 = v48[1];
        long long v52 = v48[2];
        *(_DWORD *)(v49 + 48) = *((_DWORD *)v48 + 12);
        *(_OWORD *)(v49 + 16) = v51;
        *(_OWORD *)(v49 + 32) = v52;
        *(_OWORD *)unint64_t v49 = v50;
        *(_OWORD *)(v49 + 52) = *(long long *)((char *)v48 + 52);
        __n128 result = *(__n128 *)((char *)v48 + 68);
        *(__n128 *)(v49 + 68) = result;
        uint64_t v53 = *((void *)v48 + 11);
        *(unsigned char *)(v49 + 96) = *((unsigned char *)v48 + 96);
        *(void *)(v49 + 88) = v53;
        v49 += 104;
        unint64_t v48 = (long long *)((char *)v48 + 104);
      }
      while ((unint64_t)v48 < v8);
    }
    a1[1] = v49;
    if (v19 != v47)
    {
      uint64_t v54 = 8 * ((uint64_t)(v19 - v47) >> 3);
      unint64_t v55 = v19 - 52;
      do
      {
        long long v56 = *(_OWORD *)(v11 + v54 - 104);
        long long v57 = *(_OWORD *)(v11 + v54 - 88);
        long long v58 = *(_OWORD *)(v11 + v54 - 72);
        *(_DWORD *)(v55 - 4) = *(_DWORD *)(v11 + v54 - 56);
        *(_OWORD *)(v55 - 20) = v58;
        *(_OWORD *)(v55 - 36) = v57;
        *(_OWORD *)(v55 - 52) = v56;
        *(_OWORD *)unint64_t v55 = *(_OWORD *)(v11 + v54 - 52);
        __n128 result = *(__n128 *)(v11 + v54 - 36);
        *(__n128 *)(v55 + 16) = result;
        uint64_t v59 = *(void *)(v11 + v54 - 16);
        *(unsigned char *)(v55 + 44) = *(unsigned char *)(v11 + v54 - 8);
        *(void *)(v55 + 36) = v59;
        v55 -= 104;
        v54 -= 104;
      }
      while (v54);
    }
    if (v17 != a3)
    {
      do
      {
        long long v60 = *v6;
        long long v61 = v6[1];
        long long v62 = v6[2];
        *(_DWORD *)(v11 + 48) = *((_DWORD *)v6 + 12);
        *(_OWORD *)(v11 + 16) = v61;
        *(_OWORD *)(v11 + 32) = v62;
        *(_OWORD *)uint64_t v11 = v60;
        *(_OWORD *)(v11 + 52) = *(long long *)((char *)v6 + 52);
        __n128 result = *(__n128 *)((char *)v6 + 68);
        *(__n128 *)(v11 + 68) = result;
        uint64_t v63 = *((void *)v6 + 11);
        *(unsigned char *)(v11 + 96) = *((unsigned char *)v6 + 96);
        *(void *)(v11 + 88) = v63;
        uint64_t v6 = (long long *)((char *)v6 + 104);
        v11 += 104;
      }
      while (v6 != v17);
    }
  }
  else
  {
    unint64_t v13 = a5 + 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v8 - (void)v9) >> 3);
    if (v13 > 0x276276276276276) {
      abort();
    }
    unint64_t v14 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v12 - (void)v9) >> 3);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x13B13B13B13B13BLL) {
      unint64_t v15 = 0x276276276276276;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15) {
      unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::WindowServer::FlipBook::Frame>>(v15);
    }
    else {
      uint64_t v16 = 0;
    }
    unint64_t v25 = v15 + 104 * v10;
    unint64_t v26 = v25 + 104 * a5;
    unint64_t v27 = v25;
    do
    {
      long long v28 = *v6;
      long long v29 = v6[1];
      long long v30 = v6[2];
      *(_DWORD *)(v27 + 48) = *((_DWORD *)v6 + 12);
      *(_OWORD *)(v27 + 16) = v29;
      *(_OWORD *)(v27 + 32) = v30;
      *(_OWORD *)unint64_t v27 = v28;
      *(_OWORD *)(v27 + 52) = *(long long *)((char *)v6 + 52);
      __n128 result = *(__n128 *)((char *)v6 + 68);
      *(__n128 *)(v27 + 68) = result;
      uint64_t v31 = *((void *)v6 + 11);
      *(unsigned char *)(v27 + 96) = *((unsigned char *)v6 + 96);
      *(void *)(v27 + 88) = v31;
      v27 += 104;
      uint64_t v6 = (long long *)((char *)v6 + 104);
    }
    while (v27 != v26);
    double v32 = (char *)*a1;
    if (v11 != *a1)
    {
      uint64_t v33 = 104 * v10;
      unint64_t v34 = v15;
      do
      {
        unint64_t v35 = v34 + v33;
        long long v36 = *(_OWORD *)&v9[v33 - 104];
        long long v37 = *(_OWORD *)&v9[v33 - 88];
        long long v38 = *(_OWORD *)&v9[v33 - 72];
        *(_DWORD *)(v35 - 56) = *(_DWORD *)&v9[v33 - 56];
        *(_OWORD *)(v35 - 72) = v38;
        *(_OWORD *)(v35 - 88) = v37;
        *(_OWORD *)(v35 - 104) = v36;
        *(_OWORD *)(v35 - 52) = *(_OWORD *)&v9[v33 - 52];
        __n128 result = *(__n128 *)&v9[v33 - 36];
        *(__n128 *)(v35 - 36) = result;
        uint64_t v39 = *(void *)&v9[v33 - 16];
        *(unsigned char *)(v35 - 8) = v9[v33 - 8];
        *(void *)(v35 - 16) = v39;
        v34 -= 104;
        v9 -= 104;
      }
      while (&v9[v33] != v32);
      unint64_t v25 = v34 + 104 * v10;
    }
    unint64_t v40 = v15 + 104 * v16;
    unint64_t v41 = a1[1];
    while (v11 != v41)
    {
      long long v42 = *(_OWORD *)v11;
      long long v43 = *(_OWORD *)(v11 + 16);
      long long v44 = *(_OWORD *)(v11 + 32);
      *(_DWORD *)(v26 + 48) = *(_DWORD *)(v11 + 48);
      *(_OWORD *)(v26 + 16) = v43;
      *(_OWORD *)(v26 + 32) = v44;
      *(_OWORD *)unint64_t v26 = v42;
      *(_OWORD *)(v26 + 52) = *(_OWORD *)(v11 + 52);
      __n128 result = *(__n128 *)(v11 + 68);
      *(__n128 *)(v26 + 68) = result;
      uint64_t v45 = *(void *)(v11 + 88);
      *(unsigned char *)(v26 + 96) = *(unsigned char *)(v11 + 96);
      *(void *)(v26 + 88) = v45;
      v26 += 104;
      v11 += 104;
    }
    uint64_t v46 = (void *)*a1;
    *a1 = v25;
    a1[1] = v26;
    a1[2] = v40;
    if (v46)
    {
      operator delete(v46);
    }
  }
  return result;
}

uint64_t std::vector<CA::WindowServer::FlipBook::Frame>::erase(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v3 = *(void *)(result + 8);
    if (a3 != v3)
    {
      uint64_t v4 = 8 * ((a3 - a2) >> 3);
      do
      {
        long long v5 = *(_OWORD *)(a2 + v4);
        long long v6 = *(_OWORD *)(a2 + v4 + 16);
        long long v7 = *(_OWORD *)(a2 + v4 + 32);
        *(_DWORD *)(a2 + 48) = *(_DWORD *)(a2 + v4 + 48);
        *(_OWORD *)(a2 + 16) = v6;
        *(_OWORD *)(a2 + 32) = v7;
        *(_OWORD *)a2 = v5;
        *(_OWORD *)(a2 + 52) = *(_OWORD *)(a2 + v4 + 52);
        *(_OWORD *)(a2 + 68) = *(_OWORD *)(a2 + v4 + 68);
        char v8 = *(unsigned char *)(a2 + v4 + 96);
        *(void *)(a2 + 88) = *(void *)(a2 + v4 + 88);
        *(unsigned char *)(a2 + 96) = v8;
        a2 += 104;
      }
      while (a2 + v4 != v3);
    }
    *(void *)(result + 8) = a2;
  }
  return result;
}

void CA::WindowServer::FlipBook::_exit(uint64_t a1)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 112))(a1);
  *(unsigned char *)(a1 + 24) &= 0xFCu;
  CA::WindowServer::FlipBook::invalidate_context((CA::Render::Context *)*(unsigned int *)(a1 + 48));
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 56) = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8));
  uint64_t v2 = *(void **)(a1 + 80);
  uint64_t v3 = *(void **)(a1 + 88);
  if (v2 != v3)
  {
    do
    {
      CA::WindowServer::FlipBook::reuse_frame((void *)a1, v2);
      v2 += 13;
    }
    while (v2 != v3);
    uint64_t v2 = *(void **)(a1 + 80);
  }
  *(void *)(a1 + 88) = v2;
  CA::WindowServer::FlipBook::collect((CA::WindowServer::FlipBook *)a1);

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 8));
}

void CA::WindowServer::FlipBook::_enter(uint64_t a1, __int16 a2)
{
  if ((*(unsigned char *)(a1 + 24) & 3) != 0) {
    __assert_rtn("_enter", "windowserver-flipbook.cpp", 808, "_state == kFlipBookStateDisabled");
  }
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a1 + 24) & 0xFC | 1;
  if ((a2 & 0xFF00) != 0x200)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8));
    CA::WindowServer::FlipBook::swap_enqueued_locked((void *)a1);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 8));
  }
}

void CA::WindowServer::FlipBook::free_surfaces(os_unfair_lock_s *this)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  locuint64_t k = this + 2;
  os_unfair_lock_lock(this + 2);
  uint64_t v2 = mach_absolute_time();
  double v3 = CATimeWithHostTime(v2);
  uint64_t v4 = *(char **)&this[20]._os_unfair_lock_opaque;
  long long v5 = *(char **)&this[22]._os_unfair_lock_opaque;
  uint64_t v6 = *(void *)&this[26]._os_unfair_lock_opaque;
  uint64_t v7 = *(void *)&this[28]._os_unfair_lock_opaque;
  uint64_t v9 = *(void *)&this[32]._os_unfair_lock_opaque;
  uint64_t v8 = *(void *)&this[34]._os_unfair_lock_opaque;
  uint64_t v39 = *(void *)&this[38]._os_unfair_lock_opaque;
  uint64_t v40 = *(void *)&this[40]._os_unfair_lock_opaque;
  uint64_t v10 = v5 - v4;
  if (v5 == v4)
  {
    unint64_t v12 = *(void **)&this[28]._os_unfair_lock_opaque;
    uint64_t v11 = *(void **)&this[26]._os_unfair_lock_opaque;
  }
  else
  {
    do
    {
      CA::WindowServer::FlipBook::free_surface(this, v4);
      v4 += 104;
    }
    while (v4 != v5);
    long long v5 = *(char **)&this[20]._os_unfair_lock_opaque;
    uint64_t v11 = *(void **)&this[26]._os_unfair_lock_opaque;
    unint64_t v12 = *(void **)&this[28]._os_unfair_lock_opaque;
  }
  uint64_t v13 = v7 - v6;
  uint64_t v14 = v10 >> 3;
  *(void *)&this[22]._os_unfair_lock_opaque = v5;
  if (v11 != v12)
  {
    do
    {
      CA::WindowServer::FlipBook::free_surface(this, v11);
      v11 += 13;
    }
    while (v11 != v12);
    unint64_t v12 = *(void **)&this[26]._os_unfair_lock_opaque;
  }
  uint64_t v15 = v8 - v9;
  uint64_t v16 = 0x4EC4EC4EC4EC4EC5 * v14;
  uint64_t v17 = v13 >> 3;
  *(void *)&this[28]._os_unfair_lock_opaque = v12;
  long long v18 = *(void **)&this[32]._os_unfair_lock_opaque;
  unint64_t v19 = *(void **)&this[34]._os_unfair_lock_opaque;
  if (v18 != v19)
  {
    do
    {
      CA::WindowServer::FlipBook::free_surface(this, v18);
      v18 += 13;
    }
    while (v18 != v19);
    long long v18 = *(void **)&this[32]._os_unfair_lock_opaque;
  }
  uint64_t v20 = v16 + 0x4EC4EC4EC4EC4EC5 * v17;
  uint64_t v21 = v15 >> 3;
  *(void *)&this[34]._os_unfair_lock_opaque = v18;
  long long v22 = *(void **)&this[38]._os_unfair_lock_opaque;
  uint64_t v23 = *(void **)&this[40]._os_unfair_lock_opaque;
  if (v22 != v23)
  {
    do
    {
      CA::WindowServer::FlipBook::free_surface(this, v22);
      v22 += 13;
    }
    while (v22 != v23);
    long long v22 = *(void **)&this[38]._os_unfair_lock_opaque;
  }
  uint64_t v24 = v20 + 0x4EC4EC4EC4EC4EC5 * v21;
  uint64_t v25 = *(void *)&this[44]._os_unfair_lock_opaque;
  *(void *)&this[40]._os_unfair_lock_opaque = v22;
  if (v25)
  {
    CA::WindowServer::FlipBook::free_surface(this, &this[44]._os_unfair_lock_opaque);
    *(void *)&this[66]._os_unfair_lock_opaque = 0;
    LOBYTE(this[68]._os_unfair_lock_opaque) = 0;
    *(_OWORD *)&this[44]._os_unfair_lock_opaque = 0u;
    *(_OWORD *)&this[48]._os_unfair_lock_opaque = 0u;
    *(_OWORD *)&this[52]._os_unfair_lock_opaque = 0u;
    this[56]._os_unfair_lock_opaque = 0;
  }
  if (x_log_hook_p())
  {
    uint64_t v26 = mach_absolute_time();
    CATimeWithHostTime(v26);
    unint64_t v27 = *(void *)&this[18]._os_unfair_lock_opaque;
    if (v27 >= 0x400)
    {
      double v34 = 1.0;
      do
        double v34 = v34 * 0.0009765625;
      while (v34 * (double)v27 >= 1024.0);
    }
    x_log_();
  }
  else
  {
    long long v28 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v29 = mach_absolute_time();
      double v30 = (CATimeWithHostTime(v29) - v3) * 1000.0;
      unint64_t v31 = *(void *)&this[18]._os_unfair_lock_opaque;
      double v32 = (double)v31;
      if (v31 >= 0x400)
      {
        double v35 = 1.0;
        do
        {
          double v35 = v35 * 0.0009765625;
          double v33 = v35 * v32;
        }
        while (v35 * v32 >= 1024.0);
      }
      else
      {
        double v33 = (double)v31;
      }
      uint64_t v36 = v31 > 0x3FF;
      if ((v31 & 0xFFFFFFFFFFF00000) != 0) {
        ++v36;
      }
      if ((v31 & 0xFFFFFFFFC0000000) != 0) {
        ++v36;
      }
      if (v31 >> 40) {
        ++v36;
      }
      if (v31 >> 50) {
        ++v36;
      }
      if (v31 >> 60) {
        uint64_t v37 = v36 + 1;
      }
      else {
        uint64_t v37 = v36;
      }
      long long v38 = off_1E527FCB0[v37];
      *(_DWORD *)buf = 134218754;
      uint64_t v43 = v24 + 0x4EC4EC4EC4EC4EC5 * ((v40 - v39) >> 3);
      __int16 v44 = 2048;
      double v45 = v30;
      __int16 v46 = 2048;
      double v47 = v33;
      __int16 v48 = 2080;
      unint64_t v49 = v38;
      _os_log_impl(&dword_184668000, v28, OS_LOG_TYPE_DEFAULT, "%zu surfaces freed in %g ms, memory usage = %.2lf %s", buf, 0x2Au);
    }
  }
  os_unfair_lock_unlock(lock);
}

void CA::WindowServer::FlipBook::recycle(os_unfair_lock_s *this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (CADeviceSupportsDCP::once[0] != -1) {
    dispatch_once(CADeviceSupportsDCP::once, &__block_literal_global_295);
  }
  if (CADeviceSupportsDCP::has_dcp)
  {
    uint64_t v2 = mach_continuous_time();
    os_unfair_lock_lock(this + 2);
    uint64_t v3 = *(void *)&this[32]._os_unfair_lock_opaque;
    uint64_t v4 = *(void *)&this[34]._os_unfair_lock_opaque;
    if (v4 == v3)
    {
LABEL_9:
      os_unfair_lock_unlock(this + 2);
      return;
    }
    while (1)
    {
      uint64_t v5 = v4 - 104;
      if (*(void *)(v4 - 64) < v2)
      {
        if ((*(uint64_t (**)(os_unfair_lock_s *, uint64_t))(*(void *)&this->_os_unfair_lock_opaque + 120))(this, v4 - 104))
        {
          unsigned int v6 = *(_DWORD *)(v4 - 56);
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            uint64_t v7 = x_log_category_flipbook;
            if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109120;
              unsigned int v9 = v6;
              _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_DEFAULT, "manually recycling swaps prior to %u", buf, 8u);
            }
          }
          os_unfair_lock_unlock(this + 2);
          if (v6) {
            CA::WindowServer::FlipBook::swap_completed(this, v6);
          }
          return;
        }
        uint64_t v3 = *(void *)&this[32]._os_unfair_lock_opaque;
      }
      v4 -= 104;
      if (v5 == v3) {
        goto LABEL_9;
      }
    }
  }
}

void CA::WindowServer::FlipBook::next_frame(CA::WindowServer::FlipBook *this, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  *((void *)this + 12) = 0;
  uint64_t v8 = (char *)this + 88;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  unsigned int v9 = (os_unfair_lock_s *)(a2 + 8);
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 8));
  uint64_t v13 = *(void *)(a2 + 112);
  if (v13 == *(void *)(a2 + 104))
  {
    if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 3)
                          + 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a2 + 136) - *(void *)(a2 + 128)) >> 3)) < *(void *)(a2 + 64))
    {
      CA::WindowServer::FlipBook::allocate_frame((CA::WindowServer::FlipBook *)v18, a2, a3, a4, v10, v11, v12);
      long long v17 = v18[1];
      *(_OWORD *)this = v18[0];
      *((_OWORD *)this + 1) = v17;
      *((_OWORD *)this + 2) = v18[2];
      *((_DWORD *)this + 12) = v19;
      *(_OWORD *)((char *)this + 52) = v20;
      *(_OWORD *)((char *)this + 68) = v21;
      *(void *)uint64_t v8 = v22;
      v8[8] = v23;
    }
  }
  else
  {
    if (*(_DWORD *)(a2 + 292) == 1) {
      __assert_rtn("next_frame", "windowserver-flipbook.cpp", 1463, "type () != kFlipBookType_DirtyRegionOnly");
    }
    long long v14 = *(_OWORD *)(v13 - 88);
    *(_OWORD *)this = *(_OWORD *)(v13 - 104);
    *((_OWORD *)this + 1) = v14;
    *((_OWORD *)this + 2) = *(_OWORD *)(v13 - 72);
    *((_DWORD *)this + 12) = *(_DWORD *)(v13 - 56);
    *(_OWORD *)((char *)this + 52) = *(_OWORD *)(v13 - 52);
    *(_OWORD *)((char *)this + 68) = *(_OWORD *)(v13 - 36);
    v8[8] = *(unsigned char *)(v13 - 8);
    *(void *)uint64_t v8 = *(void *)(v13 - 16);
    *(void *)(a2 + 112) = v13 - 104;
    char v15 = *((unsigned char *)this + 96);
    if ((v15 & 2) != 0)
    {
      IOSurfaceSetPurgeable(*(IOSurfaceRef *)this, 0, 0);
      uint64_t v16 = (__IOSurface *)*((void *)this + 2);
      if (v16) {
        IOSurfaceSetPurgeable(v16, 0, 0);
      }
      *((unsigned char *)this + 96) = v15 & 0xFD;
    }
  }

  os_unfair_lock_unlock(v9);
}

uint64_t CA::WindowServer::FlipBook::allocate_frame(CA::WindowServer::FlipBook *this, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, const __CFString *a7)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  *((void *)this + 12) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 1) = 0u;
  if (*(_DWORD *)(a2 + 292))
  {
    if (a3 <= 0x40) {
      unsigned int v9 = 64;
    }
    else {
      unsigned int v9 = a3;
    }
    if (a4 <= 0x40) {
      int v10 = 64;
    }
    else {
      int v10 = a4;
    }
  }
  else
  {
    uint64_t v11 = *(void *)(a2 + 16);
    unsigned int v9 = *(_DWORD *)(v11 + 176);
    int v10 = *(_DWORD *)(v11 + 180);
  }
  if (CADeviceUseCIF10::once != -1) {
    dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_12019);
  }
  if (CADeviceUseCIF10::enable_cif10) {
    uint64_t v12 = 1999843442;
  }
  else {
    uint64_t v12 = 1111970369;
  }
  unsigned int v13 = 2 * (*(_DWORD *)(a2 + 292) != 1);
  iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v12, v9, v10, v13, 0, @"CA Server Flipbook Frame", a7);
  *(void *)this = iosurface_with_pixel_format;
  uint64_t v15 = **(void **)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 88))(a2);
  *((void *)this + 1) = (*(uint64_t (**)(void))(v15 + 672))();
  *((_DWORD *)this + 13) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 15) = v9;
  *((_DWORD *)this + 16) = v10;
  size_t AllocSize = IOSurfaceGetAllocSize(iosurface_with_pixel_format);
  *((void *)this + 11) = AllocSize;
  *(void *)(a2 + 72) += AllocSize;
  if (x_log_hook_p())
  {
    IOSurfaceGetID(iosurface_with_pixel_format);
    unint64_t v17 = *(void *)(a2 + 72);
    if (v17 >= 0x400)
    {
      double v23 = 1.0;
      do
        double v23 = v23 * 0.0009765625;
      while (v23 * (double)v17 >= 1024.0);
    }
    x_log_();
  }
  else
  {
    long long v18 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      IOSurfaceID ID = IOSurfaceGetID(iosurface_with_pixel_format);
      unint64_t v20 = *(void *)(a2 + 72);
      double v21 = (double)v20;
      if (v20 >= 0x400)
      {
        double v24 = 1.0;
        do
        {
          double v24 = v24 * 0.0009765625;
          double v22 = v24 * v21;
        }
        while (v24 * v21 >= 1024.0);
      }
      else
      {
        double v22 = (double)v20;
      }
      uint64_t v25 = v20 > 0x3FF;
      if ((v20 & 0xFFFFFFFFFFF00000) != 0) {
        ++v25;
      }
      if ((v20 & 0xFFFFFFFFC0000000) != 0) {
        ++v25;
      }
      if (v20 >> 40) {
        ++v25;
      }
      if (v20 >> 50) {
        ++v25;
      }
      if (v20 >> 60) {
        ++v25;
      }
      uint64_t v26 = off_1E527FCB0[v25];
      LODWORD(buf) = 67110146;
      HIDWORD(buf) = ID;
      LOWORD(v33) = 1024;
      *(_DWORD *)((char *)&v33 + 2) = v9;
      HIWORD(v33) = 1024;
      int v34 = v10;
      __int16 v35 = 2048;
      double v36 = v22;
      __int16 v37 = 2080;
      long long v38 = v26;
      _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_DEFAULT, "allocated surface 0x%x, %dx%d for the flipbook, memory usage = %.2lf %s", (uint8_t *)&buf, 0x28u);
    }
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 136))(a2);
  if (result)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a2 + 144))(&buf, a2);
    if (*(_DWORD *)(a2 + 292) == 1) {
      unsigned int v29 = v13 | 4;
    }
    else {
      unsigned int v29 = v13;
    }
    double v30 = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v12, v33, SHIDWORD(v33), v29, 0, @"CA Server Flipbook Frame DEBUG", v28);
    *((void *)this + 2) = v30;
    uint64_t v31 = *(void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 88))(a2);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void, __IOSurface *))(*(void *)v31 + 672))(v31, 1, 0, 0, v30);
    *((void *)this + 3) = result;
  }
  return result;
}

void CA::WindowServer::FlipBook::transition_to_state(unsigned __int8 *a1, unsigned int a2, int a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = (os_unfair_lock_s *)(a1 + 12);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 3);
  unsigned int v7 = a1[24];
  unsigned int v8 = v7;
  if ((v7 & 4) != 0 && (unsigned int v8 = v7 & 0xFFFFFFFB, a1[24] = v7 & 0xFB, a2 == 1) && (v7 & 3) == 0)
  {
    unsigned int v9 = 2;
  }
  else if (a2)
  {
    unsigned int v9 = a2;
  }
  else
  {
    unsigned int v9 = (v8 >> 4) & 2;
  }
  uint64_t v10 = v8 & 3;
  if (v10 == v9) {
    goto LABEL_37;
  }
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    uint64_t v11 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = CA::WindowServer::FlipBook::transition_to_state(CA::WindowServer::FlipBookState,BOOL)::state_to_name[a1[24] & 3];
      unsigned int v13 = CA::WindowServer::FlipBook::transition_to_state(CA::WindowServer::FlipBookState,BOOL)::state_to_name[v9];
      *(_DWORD *)uint64_t buf = 136315650;
      unint64_t v20 = v12;
      __int16 v21 = 2080;
      double v22 = v13;
      __int16 v23 = 1024;
      int v24 = a3;
      _os_log_impl(&dword_184668000, v11, OS_LOG_TYPE_DEFAULT, "flipbook transition from %s to %s, has_live_frame %i", buf, 0x1Cu);
    }
  }
  if ((v9 & 0xFFFFFFFD) == 0)
  {
    (*(void (**)(unsigned __int8 *, void))(*(void *)a1 + 72))(a1, 0);
    (*(void (**)(unsigned __int8 *, void))(*(void *)a1 + 80))(a1, 0);
  }
  unsigned int v14 = a1[24];
  if (v9 > (v14 & 3))
  {
    if ((v14 & 3) == 0)
    {
      uint64_t v15 = 0x10000;
      if (!a3) {
        uint64_t v15 = 0;
      }
      (*(void (**)(unsigned __int8 *, unint64_t))(*(void *)a1 + 16))(a1, v15 | ((unint64_t)v9 << 8) | v10);
      unsigned int v14 = a1[24];
    }
    if (v9 >= 2 && (v14 & 3) == 1)
    {
      uint64_t v16 = 512;
      if (a3) {
        uint64_t v16 = 66048;
      }
      (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)a1 + 32))(a1, v16 | v10);
      goto LABEL_37;
    }
    goto LABEL_35;
  }
  if (v9 <= 1 && (v14 & 3) == 2)
  {
    uint64_t v17 = 0x10000;
    if (!a3) {
      uint64_t v17 = 0;
    }
    (*(void (**)(unsigned __int8 *, unint64_t))(*(void *)a1 + 40))(a1, v17 | ((unint64_t)v9 << 8) | v10);
    unsigned int v14 = a1[24];
  }
  if (v9 || (v14 & 3) != 1)
  {
LABEL_35:
    if (v9 == 1)
    {
      (*(void (**)(unsigned __int8 *, void))(*(void *)a1 + 72))(a1, (v14 >> 3) & 1);
      (*(void (**)(unsigned __int8 *, void))(*(void *)a1 + 80))(a1, (a1[24] >> 4) & 1);
    }
    goto LABEL_37;
  }
  uint64_t v18 = 0x10000;
  if (!a3) {
    uint64_t v18 = 0;
  }
  (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)a1 + 24))(a1, v18 | v10);
LABEL_37:
  os_unfair_lock_unlock(v6);
}

double CA::OGL::MetalContext::last_command_buffer_duration(CA::OGL::MetalContext *this)
{
  return *((double *)this + 510);
}

uint64_t CA::OGL::MetalContext::surface_pixel_size(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 69) & 8) != 0 || (*(unsigned char *)(a2 + 72) & 1) == 0) {
    return 0;
  }
  unint64_t v3 = *(void *)(a2 + 120);
  char v4 = v3 - 70;
  if (v3 - 70 <= 0x37)
  {
    if (((1 << v4) & 0x1100C03) != 0) {
      return 4;
    }
    if (((1 << v4) & 0x210000000000) != 0) {
      return 8;
    }
    if (v3 == 125) {
      return 16;
    }
  }
  if (v3 <= 0x2B)
  {
    if (((1 << v3) & 0xA00C0000000) != 0) {
      return 2;
    }
    if (((1 << v3) & 0xC02) != 0) {
      return 1;
    }
  }
  unint64_t v5 = v3 - 550;
  if (v5 > 5) {
    return 4;
  }
  if (((1 << v5) & 3) == 0)
  {
    if (((1 << v5) & 0xC) != 0) {
      return 8;
    }
    return 4;
  }
  return 5;
}

void ___ZN2CA3OGL12MetalContext5flushEb_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  char v4 = CA::OGL::MetalContext::_perf_log;
  if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::_perf_log))
  {
    uint64_t v5 = *(void *)(a1 + 40);
    int v6 = *(_DWORD *)(*(void *)(a1 + 32) + 8);
    int v7 = *(_DWORD *)(a1 + 56);
    int v8 = *(_DWORD *)(a1 + 60);
    uint64_t v9 = *(void *)(a1 + 48);
    [a2 kernelStartTime];
    uint64_t v11 = CAHostTimeWithTime(v10) + v9;
    uint64_t v12 = *(void *)(a1 + 48);
    [a2 kernelEndTime];
    v14[0] = 67241472;
    v14[1] = v6;
    __int16 v15 = 1026;
    int v16 = v7;
    __int16 v17 = 1026;
    int v18 = v8;
    __int16 v19 = 2050;
    uint64_t v20 = v5;
    __int16 v21 = 2050;
    uint64_t v22 = v11;
    __int16 v23 = 2050;
    uint64_t v24 = CAHostTimeWithTime(v13) + v12;
    _os_signpost_emit_with_name_impl(&dword_184668000, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Scheduling", "context=%{public,name=context}u update=0x%{public,name=update}x cmdbuf=%{public,name=cmdbuf}u thread=%{public,name=thread}llx begin=%{public,signpost.description:begin_time}llu end=%{public,signpost.description:end_time}llu", (uint8_t *)v14, 0x32u);
  }
}

void ___ZN2CA3OGL12MetalContext5flushEb_block_invoke_75(uint64_t a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  [a2 GPUEndTime];
  uint64_t v7 = CAHostTimeWithTime(v6) + v4;
  int v8 = CA::OGL::MetalContext::_perf_log;
  if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::_perf_log))
  {
    int v9 = *(_DWORD *)(v5 + 8);
    int v10 = *(_DWORD *)(a1 + 64);
    int v11 = *(_DWORD *)(a1 + 68);
    uint64_t v12 = *(void *)(a1 + 40);
    uint64_t v13 = *(void *)(a1 + 48);
    [a2 GPUStartTime];
    int v20 = 67241472;
    int v21 = v9;
    __int16 v22 = 1026;
    int v23 = v10;
    __int16 v24 = 1026;
    *(_DWORD *)uint64_t v25 = v11;
    *(_WORD *)&v25[4] = 2050;
    *(void *)&v25[6] = v13;
    *(_WORD *)&v25[14] = 2050;
    *(void *)&v25[16] = CAHostTimeWithTime(v14) + v12;
    *(_WORD *)&v25[24] = 2050;
    *(void *)&v25[26] = v7;
    _os_signpost_emit_with_name_impl(&dword_184668000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Executing", "context=%{public,name=context}u update=0x%{public,name=update}x cmdbuf=%{public,name=cmdbuf}u thread=%{public,name=thread}llx begin=%{public,signpost.description:begin_time}llu end=%{public,signpost.description:end_time}llu", (uint8_t *)&v20, 0x32u);
  }
  uint64_t v15 = *(void *)(a1 + 56);
  if (v15)
  {
    int v16 = CA::OGL::MetalContext::_perf_log;
    if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::_perf_log))
    {
      int v17 = *(_DWORD *)(v5 + 8);
      int v18 = *(_DWORD *)(a1 + 64);
      uint64_t v19 = *(void *)(a1 + 48);
      int v20 = 67241216;
      int v21 = v17;
      __int16 v22 = 1026;
      int v23 = v18;
      __int16 v24 = 2050;
      *(void *)uint64_t v25 = v19;
      *(_WORD *)&v25[8] = 2050;
      *(void *)&v25[10] = v15;
      *(_WORD *)&v25[18] = 2050;
      *(void *)&v25[20] = v7;
      _os_signpost_emit_with_name_impl(&dword_184668000, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "RenderToCompletion", "context=%{public,name=context}u update=0x%{public,name=update}x thread=%{public,name=thread}llx begin=%{public,signpost.description:begin_time}llu end=%{public,signpost.description:end_time}llu", (uint8_t *)&v20, 0x2Cu);
    }
  }
}

double ___ZN2CA3OGL12MetalContext5flushEb_block_invoke_77(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  [a2 GPUEndTime];
  double v5 = v4;
  [a2 GPUStartTime];
  double result = v5 - v6;
  *(double *)(v3 + 4080) = result;
  return result;
}

uint64_t ___ZN2CA3OGL12MetalContext24copy_submitted_callbacksEPU27objcproto16MTLCommandBuffer11objc_object_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void CA::OGL::MetalContext::issue_cache_drop_hints(CA::OGL::MetalContext *this)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    unsigned int v3 = -1;
    uint64_t v4 = *((void *)this + 10);
    do
    {
      unsigned int v5 = v3;
      uint64_t v4 = *(void *)(v4 + 8);
      ++v3;
    }
    while (v4);
    size_t v6 = 8 * (v5 + 2);
    if (v3 > 0x1FF)
    {
      uint64_t v7 = (char *)malloc_type_malloc(8 * (v5 + 2), 0x80040B8603338uLL);
      uint64_t v2 = *((void *)this + 10);
      if (!v2) {
        goto LABEL_28;
      }
      goto LABEL_9;
    }
  }
  else
  {
    size_t v6 = 0;
  }
  MEMORY[0x1F4188790](this);
  uint64_t v7 = (char *)&v20 - ((v6 + 15) & 0xFFFFFFFF0);
  bzero(v7, v6);
  if (!v2) {
    goto LABEL_28;
  }
LABEL_9:
  int v9 = 0;
  int v10 = &CA::callback_timer;
  *(void *)&long long v8 = 134219010;
  do
  {
    __int16 v11 = *(_WORD *)(v2 + 232);
    if ((v11 & 0x40) != 0 && *(void *)(v2 + 152) == *((void *)this + 372))
    {
      if (byte_1EB2ACC2B && (*(unsigned char *)(v2 + 72) & 1) != 0)
      {
        long long v24 = v8;
        if (x_log_hook_p())
        {
          Name = (char *)MTLPixelFormatGetName();
          int v12 = strncmp(Name, "MTLPixelFormat", 0xEuLL);
          uint64_t v13 = 14;
          if (v12) {
            uint64_t v13 = 0;
          }
          Name += v13;
          __int16 v22 = (const char *)[*(id *)(v2 + 96) width];
          [*(id *)(v2 + 96) height];
          x_log_();
          int v10 = &CA::callback_timer;
          long long v8 = v24;
        }
        else
        {
          Name = (char *)x_log_category_ogl_metal;
          BOOL v14 = os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEBUG);
          int v10 = &CA::callback_timer;
          long long v8 = v24;
          if (v14)
          {
            __int16 v22 = (const char *)MTLPixelFormatGetName();
            int v15 = strncmp(v22, "MTLPixelFormat", 0xEuLL);
            uint64_t v16 = 14;
            if (v15) {
              uint64_t v16 = 0;
            }
            v22 += v16;
            uint64_t v21 = [*(id *)(v2 + 96) width];
            int v17 = [*(id *)(v2 + 96) height];
            *(_DWORD *)uint64_t buf = v24;
            uint64_t v26 = v2;
            __int16 v27 = 1024;
            int v28 = 0;
            __int16 v29 = 2080;
            double v30 = v22;
            __int16 v31 = 1024;
            int v32 = v21;
            __int16 v33 = 1024;
            int v34 = v17;
            _os_log_impl(&dword_184668000, (os_log_t)Name, OS_LOG_TYPE_DEBUG, "> drop surface %p texture %d %s %dx%d\n", buf, 0x28u);
            long long v8 = v24;
            int v10 = &CA::callback_timer;
          }
        }
      }
      *(void *)&v7[8 * v9] = *(void *)(v2 + 144);
      __int16 v11 = *(_WORD *)(v2 + 232);
      ++v9;
    }
    *(_WORD *)(v2 + 232) = v11 & 0xFFBF;
    uint64_t v2 = *(void *)(v2 + 8);
  }
  while (v2);
  if (v9 > 0)
  {
    if (byte_1EB2ACC2B)
    {
      int v18 = v10;
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v19 = v18[95];
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)uint64_t buf = 67109120;
          LODWORD(v26) = v9;
          _os_log_impl(&dword_184668000, v19, OS_LOG_TYPE_DEBUG, "issuing drop hints for %d surfaces", buf, 8u);
        }
      }
    }
    objc_msgSend(*((id *)this + 372), "encodeCacheHintFinalize:resourceGroups:count:", 1, v7, v9, *(double *)&v8);
  }
LABEL_28:
  if (v6 > 0x1000) {
    free(v7);
  }
}

uint64_t ___ZN2CA3OGLL15layer_flags_strEj_block_invoke()
{
  uint64_t result = objc_opt_new();
  CA::OGL::layer_flags_str::str_cache = result;
  return result;
}

BOOL CA::OGL::MetalContext::backward_dm(uint64_t a1, void *a2, void *a3, double *a4, double *a5, __IOSurface *a6, double *a7, double *a8, uint64_t *a9, _OWORD *a10, uint64_t a11)
{
  uint64_t v141 = *MEMORY[0x1E4F143B8];
  if (CADeviceSupportsHDRProcessing::once[0] != -1)
  {
    int v119 = a7;
    dispatch_once(CADeviceSupportsHDRProcessing::once, &__block_literal_global_175);
    a7 = v119;
  }
  if (!CADeviceSupportsHDRProcessing::supports_hdr) {
    return 0;
  }
  if (a2 && a2[2]) {
    __assert_rtn("backward_dm", "ogl-metal.mm", 16600, "!dst || !dst->shared_event ()");
  }
  if (a3 && a3[2]) {
    __assert_rtn("backward_dm", "ogl-metal.mm", 16601, "!srcVideo || !srcVideo->shared_event ()");
  }
  size_t v135 = a7;
  if (a6)
  {
    if (*((void *)a6 + 2)) {
      __assert_rtn("backward_dm", "ogl-metal.mm", 16602, "!srcUI || !srcUI->shared_event ()");
    }
    a6 = (__IOSurface *)(*(uint64_t (**)(__IOSurface *))(*(void *)a6 + 160))(a6);
  }
  if (a3)
  {
    unint64_t v18 = (*(uint64_t (**)(void *))(*a3 + 160))(a3);
    if (a2)
    {
LABEL_13:
      uint64_t v19 = (__IOSurface *)(*(uint64_t (**)(void *))(*a2 + 160))(a2);
      goto LABEL_16;
    }
  }
  else
  {
    unint64_t v18 = 0;
    if (a2) {
      goto LABEL_13;
    }
  }
  uint64_t v19 = 0;
LABEL_16:
  uint64_t v20 = (__IOSurface *)CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface;
  if (byte_1EB2ACC04)
  {
    if (!CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface)
    {
      int Width = (CA::Render *)IOSurfaceGetWidth(v19);
      unsigned int Height = IOSurfaceGetHeight(v19);
      CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface = (uint64_t)CA::Render::create_iosurface((CA::Render *)0x23, Width, Height, 0, v122, v123);
      CA::OGL::fillB3A8SurfaceWithColor((CA::OGL *)CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface, v124, v125, v126, v127, v128);
      uint64_t v20 = (__IOSurface *)CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface;
    }
  }
  else
  {
    if (CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface)
    {
      CFRelease((CFTypeRef)CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface);
      CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface = 0;
    }
    uint64_t v20 = a6;
  }
  if (!((unint64_t)v20 | v18) || !v19)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v59 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl(&dword_184668000, v59, OS_LOG_TYPE_ERROR, "Backward DM has no inputs\n", buf, 2u);
      }
    }
    return 0;
  }
  uint64_t v133 = a8;
  int v21 = IOSurfaceGetWidth(v19);
  buffer = v19;
  int v22 = IOSurfaceGetHeight(v19);
  int v23 = v22;
  unint64_t v134 = v18;
  if (!*(_DWORD *)(a1 + 3152)
    && !*(_DWORD *)(a1 + 3156)
    && *(_DWORD *)(a1 + 3160) == v21
    && *(_DWORD *)(a1 + 3164) == v22
    && *(float *)(a1 + 3172) == *(float *)(a11 + 4)
    && *(_DWORD *)(a1 + 3228) == *(_DWORD *)(a11 + 60)
    && CA::Render::Chromaticity::operator==(a1 + 3236, a11 + 68))
  {
    char v132 = (id *)(a1 + 3136);
    if (*(void *)(a1 + 3136)) {
      goto LABEL_45;
    }
  }
  else
  {
    char v132 = (id *)(a1 + 3136);

    *(void *)(a1 + 3136) = 0;
    *(void *)(a1 + 3152) = 0;
    *(_DWORD *)(a1 + 3160) = v21;
    *(_DWORD *)(a1 + 3164) = v23;
  }
  uint64_t v24 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "bundleWithPath:", @"/System/Library/PrivateFrameworks/HDRProcessing.framework"), "classNamed:", @"HDRBackwardDisplayManagement");
  unsigned int v25 = *(_DWORD *)(a11 + 60) - 2;
  if (v25 > 2) {
    goto LABEL_112;
  }
  uint64_t v26 = (objc_class *)v24;
  uint64_t v27 = *off_1E52741C0[v25];
  uint64_t v28 = *off_1E52741A8[v25];
  id v29 = objc_alloc(MEMORY[0x1E4F1CA60]);
  double v30 = objc_msgSend(v29, "initWithObjectsAndKeys:", v28, _kHDRProcessingDisplayColorFormatKey, v27, _kHDRProcessingDestinationDisplayTypeKey, 0);
  if (*(float *)(a11 + 4) != 0.0)
  {
    uint64_t v32 = objc_msgSend(NSNumber, "numberWithFloat:");
    [v30 setObject:v32 forKeyedSubscript:_kHDRProcessingDisplayMaximumBrightnessInNitsKey];
    LODWORD(v33) = *(_DWORD *)a11;
    uint64_t v34 = [NSNumber numberWithFloat:v33];
    [v30 setObject:v34 forKeyedSubscript:_kHDRProcessingDisplayMinimumBrightnessInNitsKey];
  }
  if (*(int *)(a11 + 124) >= 1 && _kHDRProcessingDisplayDolbyVisionDMVersionKey)
  {
    uint64_t v35 = objc_msgSend(NSNumber, "numberWithInt:");
    [v30 setObject:v35 forKeyedSubscript:_kHDRProcessingDisplayDolbyVisionDMVersionKey];
  }
  if (*(unsigned char *)(a11 + 100) && _kHDRProcessingDisplayChromaticityBx)
  {
    LODWORD(v31) = *(_DWORD *)(a11 + 84);
    uint64_t v36 = [NSNumber numberWithFloat:v31];
    [v30 setObject:v36 forKeyedSubscript:_kHDRProcessingDisplayChromaticityBx];
    LODWORD(v37) = *(_DWORD *)(a11 + 88);
    uint64_t v38 = [NSNumber numberWithFloat:v37];
    [v30 setObject:v38 forKeyedSubscript:_kHDRProcessingDisplayChromaticityBy];
    LODWORD(v39) = *(_DWORD *)(a11 + 76);
    uint64_t v40 = [NSNumber numberWithFloat:v39];
    [v30 setObject:v40 forKeyedSubscript:_kHDRProcessingDisplayChromaticityGx];
    LODWORD(v41) = *(_DWORD *)(a11 + 80);
    uint64_t v42 = [NSNumber numberWithFloat:v41];
    [v30 setObject:v42 forKeyedSubscript:_kHDRProcessingDisplayChromaticityGy];
    LODWORD(v43) = *(_DWORD *)(a11 + 68);
    uint64_t v44 = [NSNumber numberWithFloat:v43];
    [v30 setObject:v44 forKeyedSubscript:_kHDRProcessingDisplayChromaticityRx];
    LODWORD(v45) = *(_DWORD *)(a11 + 72);
    uint64_t v46 = [NSNumber numberWithFloat:v45];
    [v30 setObject:v46 forKeyedSubscript:_kHDRProcessingDisplayChromaticityRy];
    LODWORD(v47) = *(_DWORD *)(a11 + 92);
    uint64_t v48 = [NSNumber numberWithFloat:v47];
    [v30 setObject:v48 forKeyedSubscript:_kHDRProcessingDisplayChromaticityWx];
    LODWORD(v49) = *(_DWORD *)(a11 + 96);
    uint64_t v50 = [NSNumber numberWithFloat:v49];
    [v30 setObject:v50 forKeyedSubscript:_kHDRProcessingDisplayChromaticityWy];
  }
  if (!v30)
  {
LABEL_112:
    x_log_crash("FATAL: Could not create backwardDM display properties!");
    goto LABEL_114;
  }
  *(void *)(a1 + 3136) = [[v26 alloc] initWithDevice:*(void *)(a1 + 2952) displayProperties:v30];
  long long v51 = *(_OWORD *)(a11 + 32);
  long long v52 = *(_OWORD *)(a11 + 48);
  long long v53 = *(_OWORD *)(a11 + 16);
  *(_OWORD *)(a1 + 3168) = *(_OWORD *)a11;
  *(_OWORD *)(a1 + 3216) = v52;
  *(_OWORD *)(a1 + 3200) = v51;
  *(_OWORD *)(a1 + 3184) = v53;
  long long v54 = *(_OWORD *)(a11 + 96);
  long long v55 = *(_OWORD *)(a11 + 112);
  long long v56 = *(_OWORD *)(a11 + 80);
  *(_OWORD *)(a1 + 3232) = *(_OWORD *)(a11 + 64);
  *(_OWORD *)(a1 + 3280) = v55;
  *(_OWORD *)(a1 + 3264) = v54;
  *(_OWORD *)(a1 + 3248) = v56;
  CFRelease(v30);
  if (!*(void *)(a1 + 3136))
  {
    x_log_crash("Failed to initialize HDRBackwardDisplayManagement!");
LABEL_114:
    abort();
  }
LABEL_45:
  CA::OGL::MetalContext::stop_encoders((CA::OGL::MetalContext *)a1);
  if (a2) {
    uint64_t v58 = (*(uint64_t (**)(void *))(*a2 + 216))(a2);
  }
  else {
    uint64_t v58 = 0;
  }
  if (!CA::OGL::MetalContext::start_command_buffer((CA::OGL::MetalContext *)a1, v58, v57)) {
    return 0;
  }
  if (BYTE9(xmmword_1EB2ACC10))
  {
    if (v20) {
      IOSurfaceGetID(v20);
    }
    if (v18) {
      IOSurfaceGetID((IOSurfaceRef)v18);
    }
    IOSurfaceGetID(buffer);
    kdebug_trace();
  }
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  int v63 = dword_1EB2ACB04;
  if (*(float *)&dword_1EB2ACB04 == 0.0) {
    int v63 = *(_DWORD *)(a11 + 4);
  }
  if (v18) {
    [*(id *)(a1 + 3144) setObject:IOSurfaceCopyAllValues((IOSurfaceRef)v18) forKeyedSubscript:_kHDRProcessingDolbyVisionBackwardDMDictinary];
  }
  LODWORD(v62) = v63;
  uint64_t v64 = [NSNumber numberWithFloat:v62];
  [*(id *)(a1 + 3144) setObject:v64 forKeyedSubscript:_kHDRProcessingSDRMaxBrightnessInNits];
  if (a10)
  {
    long long v65 = a10[1];
    long long v66 = a10[2];
    *(_OWORD *)signed int v139 = *a10;
    long long v140 = v65;
    *(_DWORD *)uint64_t buf = *(_DWORD *)v139;
    *(void *)&long long v67 = *(void *)&v139[4];
    *((void *)&v67 + 1) = v65;
    *(_DWORD *)&buf[20] = DWORD2(v65);
    *(_OWORD *)&uint8_t buf[4] = v67;
    *(void *)&unsigned char buf[24] = v66;
    int v138 = DWORD2(v66);
    [*v132 setAccessibilityMatrix:buf];
  }
  uint64_t v68 = a9;
  if (v18)
  {
    double v69 = a4[2];
    double v70 = a4[3];
    if (v69 >= v70) {
      double v71 = a4[3];
    }
    else {
      double v71 = a4[2];
    }
    if (v71 > 0.0)
    {
      uint64_t v74 = a4[1];
      unint64_t v76 = v69 | ((unint64_t)v70 << 32);
      uint64_t v75 = *a4 & 0xFFFFFFFE;
    }
    else
    {
      unsigned int v72 = IOSurfaceGetWidth((IOSurfaceRef)v18);
      unsigned int v73 = IOSurfaceGetHeight((IOSurfaceRef)v18);
      uint64_t v74 = 0;
      uint64_t v75 = 0;
      unint64_t v76 = v72 | ((unint64_t)v73 << 32);
    }
    double v87 = a5[2];
    double v88 = a5[3];
    if (v87 >= v88) {
      double v89 = a5[3];
    }
    else {
      double v89 = a5[2];
    }
    if (v89 > 0.0)
    {
      uint64_t v78 = a5[1];
      unint64_t v94 = v87 | ((unint64_t)v88 << 32);
      uint64_t v79 = *a5 & 0xFFFFFFFE;
    }
    else
    {
      uint64_t v90 = v74;
      uint64_t v91 = v75;
      unsigned int v92 = IOSurfaceGetWidth(buffer);
      unsigned int v93 = IOSurfaceGetHeight(buffer);
      uint64_t v75 = v91;
      uint64_t v74 = v90;
      uint64_t v78 = 0;
      uint64_t v79 = 0;
      unint64_t v94 = v92 | ((unint64_t)v93 << 32);
    }
    __int16 v80 = v135;
    unint64_t v18 = v76 & 0xFFFFFFFFFFFFFFFELL;
    unint64_t v77 = v94 & 0xFFFFFFFFFFFFFFFELL;
    if (v20) {
      goto LABEL_78;
    }
LABEL_69:
    unint64_t v81 = 0;
    unint64_t v82 = 0;
    uint64_t v83 = 0;
    size_t v84 = 0;
    uint64_t v85 = 0;
    unsigned int v86 = 0;
    goto LABEL_91;
  }
  unint64_t v77 = 0;
  uint64_t v78 = 0;
  uint64_t v79 = 0;
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  __int16 v80 = v135;
  if (!v20) {
    goto LABEL_69;
  }
LABEL_78:
  uint64_t v131 = v78;
  double v95 = v80[2];
  double v96 = v80[3];
  if (v95 >= v96) {
    double v97 = v80[3];
  }
  else {
    double v97 = v80[2];
  }
  uint64_t v129 = v75;
  uint64_t v130 = v74;
  if (v97 > 0.0)
  {
    unsigned int v86 = *v80;
    uint64_t v85 = v80[1];
    uint64_t v98 = v95;
    size_t v99 = v96;
  }
  else
  {
    uint64_t v98 = IOSurfaceGetWidth(v20);
    size_t v99 = IOSurfaceGetHeight(v20);
    uint64_t v85 = 0;
    unsigned int v86 = 0;
  }
  size_t v84 = v98 | (v99 << 32);
  double v100 = v133[2];
  double v101 = v133[3];
  if (v100 >= v101) {
    double v102 = v133[3];
  }
  else {
    double v102 = v133[2];
  }
  if (v102 > 0.0)
  {
    uint64_t v83 = *v133;
    unint64_t v81 = v100 | ((unint64_t)v101 << 32);
    unint64_t v82 = (unint64_t)v133[1] << 32;
  }
  else
  {
    unsigned int v103 = IOSurfaceGetWidth(buffer);
    unsigned int v104 = IOSurfaceGetHeight(buffer);
    unint64_t v82 = 0;
    uint64_t v83 = 0;
    unint64_t v81 = v103 | ((unint64_t)v104 << 32);
  }
  uint64_t v75 = v129;
  uint64_t v74 = v130;
  uint64_t v78 = v131;
  uint64_t v68 = a9;
LABEL_91:
  _D0 = *v68;
  _H1 = WORD1(*v68);
  __asm
  {
    FCVT            D1, H1
    FCVT            D0, H0
  }
  *((void *)&_Q0 + 1) = _D1;
  LODWORD(_D1) = *((_DWORD *)v68 + 1);
  _H2 = WORD1(_D1);
  __asm
  {
    FCVT            D2, H2
    FCVT            D1, H1
  }
  *((void *)&_Q1 + 1) = _D2;
  *(_OWORD *)uint64_t buf = _Q0;
  *(_OWORD *)&uint8_t buf[16] = _Q1;
  uint64_t v116 = objc_msgSend(*(id *)(a1 + 3136), "encodeToCommandBuffer:video:videoSrcRegion:videoDstRegion:ui:uiSrcRegion:uiDstRegion:backgroundColor:output:frameProperties:", *(void *)(a1 + 2976), v134, v75 | (v74 << 32), v18, v79 | (v78 << 32), v77, v20, v86 | (unint64_t)(v85 << 32), v84, v83 | v82, v81, buf, buffer, *(void *)(a1 + 3144));
  [*(id *)(a1 + 3144) removeObjectForKey:_kHDRProcessingDolbyVisionBackwardDMDictinary];
  BOOL v60 = v116 == -17000;
  if (v116 != -17000)
  {
    if (x_log_hook_p())
    {
      if ((unint64_t)(v116 + 17008) >= 8) {
        snprintf(CA::OGL::hdr_processing_error_str(HDRError)::err_buffer, 0x20uLL, "%d", v116);
      }
      x_log_();
    }
    else
    {
      OSType v117 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        if ((unint64_t)(v116 + 17008) >= 8)
        {
          unsigned int v118 = CA::OGL::hdr_processing_error_str(HDRError)::err_buffer;
          snprintf(CA::OGL::hdr_processing_error_str(HDRError)::err_buffer, 0x20uLL, "%d", v116);
        }
        else
        {
          unsigned int v118 = off_1E527BF00[v116 + 17008];
        }
        *(_DWORD *)signed int v139 = 136315138;
        *(void *)&v139[4] = v118;
        _os_log_impl(&dword_184668000, v117, OS_LOG_TYPE_ERROR, "Backward DM failed to convert surface: %s\n", v139, 0xCu);
      }
    }
  }
  return v60;
}

uint64_t CA::OGL::fillB3A8SurfaceWithColor(CA::OGL *this, __IOSurface *a2, float a3, float a4, float a5, float a6)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  IOSurfaceLock(this, 0, 0);
  int __pattern4 = -537525888;
  BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(this, 0);
  if ((IOSurfaceGetBytesPerRow(this) & 3) != 0) {
    __assert_rtn("fillB3A8SurfaceWithColor", "ogl-metal.mm", 16444, "IOSurfaceGetBytesPerRow (surface) % 4 == 0");
  }
  size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(this, 0);
  size_t Height = IOSurfaceGetHeight(this);
  memset_pattern4(BaseAddressOfPlane, &__pattern4, Height * BytesPerRowOfPlane);
  int v14 = -2139062144;
  int v10 = IOSurfaceGetBaseAddressOfPlane(this, 1uLL);
  size_t v11 = IOSurfaceGetBytesPerRowOfPlane(this, 1uLL);
  size_t v12 = IOSurfaceGetHeight(this);
  memset_pattern4(v10, &v14, v12 * v11);

  return IOSurfaceUnlock(this, 0, 0);
}

void CA::OGL::MetalContext::mark_cache_drop_hints(CA::OGL::MetalContext *this)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    unsigned int v3 = -1;
    uint64_t v4 = *((void *)this + 10);
    do
    {
      unsigned int v5 = v3;
      uint64_t v4 = *(void *)(v4 + 8);
      ++v3;
    }
    while (v4);
    size_t v6 = 8 * (v5 + 2);
    if (v3 > 0x1FF)
    {
      uint64_t v7 = (char *)malloc_type_malloc(8 * (v5 + 2), 0x80040B8603338uLL);
      uint64_t v2 = *((void *)this + 10);
      if (!v2) {
        goto LABEL_29;
      }
      goto LABEL_9;
    }
  }
  else
  {
    size_t v6 = 0;
  }
  MEMORY[0x1F4188790](this);
  uint64_t v7 = (char *)&v18 - ((v6 + 15) & 0xFFFFFFFF0);
  bzero(v7, v6);
  if (!v2) {
    goto LABEL_29;
  }
LABEL_9:
  int v9 = 0;
  *(void *)&long long v8 = 134219010;
  long long v22 = v8;
  do
  {
    if (*(void *)(v2 + 144)
      || (uint64_t v10 = [*((id *)this + 369) newResourceGroupFromResources:v2 + 96 count:*(unsigned char *)(v2 + 72) & 1], (*(void *)(v2 + 144) = v10) != 0))
    {
      if (byte_1EB2ACC2B && (*(unsigned char *)(v2 + 72) & 1) != 0)
      {
        if (x_log_hook_p())
        {
          Name = (char *)MTLPixelFormatGetName();
          int v12 = strncmp(Name, "MTLPixelFormat", 0xEuLL);
          uint64_t v13 = 14;
          if (v12) {
            uint64_t v13 = 0;
          }
          Name += v13;
          uint64_t v20 = (const char *)[*(id *)(v2 + 96) width];
          [*(id *)(v2 + 96) height];
          x_log_();
        }
        else
        {
          Name = (char *)x_log_category_ogl_metal;
          if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v20 = (const char *)MTLPixelFormatGetName();
            int v14 = strncmp(v20, "MTLPixelFormat", 0xEuLL);
            uint64_t v15 = 14;
            if (v14) {
              uint64_t v15 = 0;
            }
            v20 += v15;
            uint64_t v19 = [*(id *)(v2 + 96) width];
            int v16 = [*(id *)(v2 + 96) height];
            *(_DWORD *)uint64_t buf = v22;
            uint64_t v24 = v2;
            __int16 v25 = 1024;
            int v26 = 0;
            __int16 v27 = 2080;
            uint64_t v28 = v20;
            __int16 v29 = 1024;
            int v30 = v19;
            __int16 v31 = 1024;
            int v32 = v16;
            _os_log_impl(&dword_184668000, (os_log_t)Name, OS_LOG_TYPE_DEBUG, "> mark surface %p texture %d %s %dx%d\n", buf, 0x28u);
          }
        }
      }
      *(void *)&v7[8 * v9] = *(void *)(v2 + 144);
      uint64_t v11 = *((void *)this + 372);
      ++v9;
    }
    else
    {
      uint64_t v11 = 0;
    }
    *(void *)(v2 + 152) = v11;
    *(_WORD *)(v2 + 232) &= ~0x40u;
    uint64_t v2 = *(void *)(v2 + 8);
  }
  while (v2);
  if (v9 > 0)
  {
    if (byte_1EB2ACC2B)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int v17 = x_log_category_ogl_metal;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)uint64_t buf = 67109120;
          LODWORD(v24) = v9;
          _os_log_impl(&dword_184668000, v17, OS_LOG_TYPE_DEBUG, "marking %d surfaces for cache drop hints", buf, 8u);
        }
      }
    }
    [*((id *)this + 372) encodeCacheHintTag:1 resourceGroups:v7 count:v9];
  }
LABEL_29:
  if (v6 > 0x1000) {
    free(v7);
  }
}

void CA::OGL::MetalContext::clear_surface(CA::OGL::MetalContext *this, CA::WindowServer::Surface *a2)
{
  double v4 = MEMORY[0x1F4188790](this);
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (v3)
  {
    uint64_t v5 = v3;
    uint64_t v6 = v2;
    uint64_t v7 = (void *)MEMORY[0x185324A30](v4);
    if (CA::OGL::MetalContext::make_buffer_current((CA::OGL::MetalContext *)v6, (CA::WindowServer::Surface *)v5))
    {
      bzero(v12, 0x3D0uLL);
      CA::OGL::Context::prepare_context(v6, (uint64_t)v12);
      *(void *)(v6 + 120) = &v11;
      *(void *)(v6 + 136) = 128;
      v10[4] = 0x3C003C003C003C00;
      memset(&v10[5], 0, 24);
      v10[8] = 0x4013F800000;
      _DWORD v10[2] = 0;
      v10[3] = &CA::identity_transform;
      v10[0] = 0;
      v10[1] = &CA::Shape::_infinite_shape;
      CA::OGL::MetalContext::begin_rendering(v6, (uint64_t)v10);
      CA::OGL::MetalContext::shared_event_submit((CA::OGL::MetalContext *)v6, *(void *)(v5 + 16), (const char *)1, 2);
      *(unsigned char *)(*(void *)(v6 + 16) + 481) &= ~1u;
      *(unsigned char *)(*(void *)(v6 + 16) + 16) = 0;
      *(void *)(v6 + 128) = 0;
      *(void *)(v6 + 96) = v6 + 834;
      *(_OWORD *)(v6 + 104) = xmmword_184997E70;
      CA::OGL::Context::array_rect((void *)v6, 0.0, 0.0, (float)*(unsigned int *)(v5 + 56), (float)*(unsigned int *)(v5 + 60));
      uint64_t v8 = *(void *)(v6 + 120) + 48 * *(void *)(v6 + 128);
      *(void *)(v8 - 160) = 0x3C00000000000000;
      *(void *)(v8 - 112) = 0x3C00000000000000;
      *(void *)(v8 - 64) = 0x3C00000000000000;
      *(void *)(v8 - 16) = 0x3C00000000000000;
      CA::OGL::Context::array_flush(v6);
      CA::OGL::MetalContext::shared_event_submit((CA::OGL::MetalContext *)v6, *(void *)(v5 + 16), 0, 2);
      CA::OGL::MetalContext::end_rendering(v6);
      CA::OGL::MetalContext::make_buffer_current((CA::OGL::MetalContext *)v6, 0);
      CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)v6, 1);
      [*(id *)(v6 + 2968) waitUntilCompleted];

      *(void *)(v6 + 2968) = 0;
      for (uint64_t i = 488; i != -488; i -= 488)
      {
        if (*(void *)&v12[i]) {
          __assert_rtn("~ContextState", "ogl-context.h", 551, "!next && \"Imbalanced ContextState push/pop\"");
        }
      }
    }
  }
}

void CA::OGL::MetalContext::release_display_surfaces(CA::OGL::MetalContext *this, CA::WindowServer::Surface *a2, void *a3)
{
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = (os_unfair_lock_s *)(*(void *)a2 + 2792);
  os_unfair_lock_lock(v5);
  uint64_t v6 = *(void **)(v4 + 2800);
  if (v6) {
    *(void *)(v4 + 2800) = x_list_remove(v6, (uint64_t)a2);
  }
  os_unfair_lock_unlock(v5);
  if (*(void *)a2)
  {
    for (uint64_t i = 8; i != 24; i += 8)
      CA::OGL::Context::release_surface(*(void *)a2, *(void *)((char *)a2 + i));
  }

  JUMPOUT(0x185323DC0);
}

void CA::OGL::MetalContext::shared_event_signal_read(CA::OGL::MetalContext *this, CA::WindowServer::SharedEvent *a2)
{
}

void CA::OGL::MetalContext::shared_event_wait_read(CA::OGL::MetalContext *this, CA::WindowServer::SharedEvent *a2)
{
}

void *CA::OGL::MetalContext::compute_surface_apl_dimming_factor(uint64_t a1, int32x2_t *a2, uint64_t a3)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (uint64_t)a2[6];
  external_buffer = CA::OGL::MetalBufferPool::create_external_buffer(*(CA::OGL::MetalBufferPool **)(a1 + 4040), 0x30u, 4uLL, v6);
  if (!external_buffer) {
    return external_buffer;
  }
  if (byte_1EB2ACC66)
  {
    CA::OGL::MetalContext::compute_surface_apl_dimming_factor(CA::OGL::Surface *,CA::OGL::APLFilterParams const&)::$_0::operator()(a1, (uint64_t)external_buffer);
    return external_buffer;
  }
  if ((*(unsigned char *)(a3 + 20) & 0x10) != 0 && (*(unsigned char *)(a1 + 2726) & 0x80) != 0)
  {
    int v9 = 0;
    unsigned int v8 = 2;
  }
  else
  {
    unsigned int v8 = 0;
    int v9 = 1;
  }
  compute_pipeline = (void *)CA::OGL::MetalContext::get_compute_pipeline(a1, v8);
  uint64_t v11 = CA::OGL::MetalContext::get_compute_pipeline(a1, 1u);
  if ((CA::OGL::MetalContext::start_compute_encoder((CA::OGL::MetalContext *)a1, *(void *)(a1 + 3088)) & 1) == 0)
  {
LABEL_39:
    uint64_t v40 = external_buffer[2];
    if (v40)
    {
      if (!CA::OGL::MetalContext::start_blit_encoder((CA::OGL::MetalContext *)a1, v40)) {
        return external_buffer;
      }
      *(void *)uint64_t buf = 0;
      LODWORD(v67) = 0;
      double v41 = CA::OGL::MetalBufferPool::alloc_bytes(*(CA::OGL::MetalBufferPool **)(a1 + 4040), *((_DWORD *)external_buffer + 2), 4u, buf, (unsigned int *)&v67);
      if (!v41) {
        return external_buffer;
      }
      memset_pattern16(v41, &unk_1849987D0, 0x30uLL);
      uint64_t v42 = *(void **)(a1 + 2992);
      uint64_t v43 = *(void *)buf;
      uint64_t v44 = v67;
LABEL_43:
      [v42 copyFromBuffer:v43 sourceOffset:v44 toBuffer:external_buffer[4] destinationOffset:*((unsigned int *)external_buffer + 10) size:external_buffer[1]];
      return external_buffer;
    }
LABEL_54:
    memset_pattern16((void *)*external_buffer, &unk_1849987D0, 0x30uLL);
    return external_buffer;
  }
  uint64_t v54 = v11;
  [*(id *)(a1 + 3000) setComputePipelineState:compute_pipeline];
  unsigned __int32 v12 = [compute_pipeline threadExecutionWidth];
  unint64_t v13 = [compute_pipeline maxTotalThreadsPerThreadgroup];
  unint64_t v14 = [compute_pipeline threadExecutionWidth];
  v15.i32[0] = v12;
  float32x2_t v16 = vcvt_f32_s32(a2[5]);
  int8x8_t v17 = (int8x8_t)vrndp_f32(vmul_f32(v16, (float32x2_t)0x3F0000003F000000));
  int v52 = v9;
  if (v9) {
    unsigned int v18 = -1;
  }
  else {
    unsigned int v18 = 0;
  }
  float32x2_t v19 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v18), (int8x8_t)v16, v17);
  v19.i32[0] = ceilf(0.125 * v19.f32[0]);
  int32x2_t v20 = (int32x2_t)vcvt_u32_f32(v19);
  v15.i32[1] = v13 / v14;
  int32x2_t v21 = vadd_s32(vadd_s32(v15, (int32x2_t)-1), v20);
  unint64_t v53 = v13 / v14;
  unsigned int v22 = v21.i32[1] / (v13 / v14);
  v20.i32[0] = v21.i32[0] / v12;
  unsigned int v56 = v21.i32[0] / v12;
  unsigned __int32 v23 = vmul_s32(v20, vdup_n_s32(v22)).u32[0];
  uint64_t v24 = CA::OGL::MetalBufferPool::create_external_buffer(*(CA::OGL::MetalBufferPool **)(a1 + 4040), 16 * v23, 0x10uLL, v6);
  uint64_t v25 = (uint64_t)v24;
  if (v24)
  {
    uint64_t v58 = v24[4];
    unsigned int v26 = *((_DWORD *)v24 + 10);
  }
  else
  {
    uint64_t v58 = 0;
    unsigned int v26 = 0;
  }
  gamma_lut_buffer = *(void **)(a1 + 4048);
  if (!gamma_lut_buffer)
  {
    gamma_lut_buffer = CA::OGL::create_gamma_lut_buffer(*(void **)(a1 + 2952));
    *(void *)(a1 + 4048) = gamma_lut_buffer;
  }
  if (!v58 || !gamma_lut_buffer)
  {
    if (v25) {
      CA::OGL::MetalBufferPool::release_external_buffer(*(void *)(a1 + 4040), v25);
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      double v39 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl(&dword_184668000, v39, OS_LOG_TYPE_ERROR, "Failed to allocate Metal buffer\n", buf, 2u);
      }
    }
    goto LABEL_39;
  }
  if (v23 >= 8) {
    unsigned int v28 = 8;
  }
  else {
    unsigned int v28 = v23;
  }
  unint64_t v29 = (v23 / v28 - 1) | (((unint64_t)(v23 / v28) - 1) >> 1);
  unint64_t v30 = v29 | (v29 >> 2) | ((v29 | (v29 >> 2)) >> 4);
  unint64_t v31 = v30 | (v30 >> 8) | ((v30 | (v30 >> 8)) >> 16);
  unint64_t v55 = (v31 | HIDWORD(v31)) + 1;
  if (v55 >= [compute_pipeline maxTotalThreadsPerThreadgroup]) {
    LODWORD(v55) = [compute_pipeline maxTotalThreadsPerThreadgroup];
  }
  uint64_t v67 = 0;
  unsigned int v66 = 0;
  int v32 = CA::OGL::MetalBufferPool::alloc_bytes(*(CA::OGL::MetalBufferPool **)(a1 + 4040), 0x30u, 0x10u, &v67, &v66);
  if (!v32)
  {
    if (v25) {
      CA::OGL::MetalBufferPool::release_external_buffer(*(void *)(a1 + 4040), v25);
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      double v45 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl(&dword_184668000, v45, OS_LOG_TYPE_ERROR, "Failed to allocate uniform Metal buffer\n", buf, 2u);
      }
    }
    uint64_t v46 = external_buffer[2];
    if (v46)
    {
      if (!CA::OGL::MetalContext::start_blit_encoder((CA::OGL::MetalContext *)a1, v46)) {
        return external_buffer;
      }
      *(void *)uint64_t buf = 0;
      unsigned int v68 = 0;
      double v47 = CA::OGL::MetalBufferPool::alloc_bytes(*(CA::OGL::MetalBufferPool **)(a1 + 4040), *((_DWORD *)external_buffer + 2), 4u, buf, &v68);
      if (!v47) {
        return external_buffer;
      }
      memset_pattern16(v47, &unk_1849987D0, 0x30uLL);
      uint64_t v42 = *(void **)(a1 + 2992);
      uint64_t v43 = *(void *)buf;
      uint64_t v44 = v68;
      goto LABEL_43;
    }
    goto LABEL_54;
  }
  uint64_t v33 = v32;
  unint64_t v57 = __PAIR64__(v22, v56);
  __int16 v34 = a2[5].i16[0];
  v32[16] = v34;
  v32[17] = a2[5].i16[2];
  v32[16] = v34;
  if (v52) {
    char v35 = 1;
  }
  else {
    char v35 = 4;
  }
  *((unsigned char *)v32 + 44) = v35;
  *(void *)int v32 = *(void *)a3;
  *((_OWORD *)v32 + 1) = *(_OWORD *)(a3 + 8);
  *((_DWORD *)v32 + 9) = (v23 + v55 - 1) / v55;
  *((_DWORD *)v32 + 10) = v23;
  *((unsigned char *)v32 + 45) = (*(unsigned char *)(a3 + 20) & 8) != 0;
  *((unsigned char *)v32 + 46) = 0;
  uint64_t v36 = *(void *)(a1 + 192);
  if (v36)
  {
    uint64_t v37 = (*(uint64_t (**)(uint64_t))(*(void *)v36 + 16))(v36);
    if (v37)
    {
      if ((*(unsigned char *)(a3 + 20) & 4) != 0)
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)v37 + 864))(v37))
        {
          if ((*(_WORD *)(a1 + 832) & 2) != 0) {
            int v38 = (*(unsigned __int8 *)(a3 + 20) >> 1) & 1;
          }
          else {
            LOBYTE(v38) = 1;
          }
        }
        else
        {
          LOBYTE(v38) = 0;
        }
        *((unsigned char *)v33 + 46) = v38;
      }
    }
  }
  [*(id *)(a1 + 3000) setTexture:*(void *)&a2[12] atIndex:0];
  [*(id *)(a1 + 3000) setBuffer:v67 offset:v66 atIndex:0];
  [*(id *)(a1 + 3000) setBuffer:v58 offset:v26 atIndex:2];
  [*(id *)(a1 + 3000) setBuffer:*(void *)(a1 + 4048) offset:0 atIndex:4];
  [*(id *)(a1 + 3000) setThreadgroupMemoryLength:16 * v12 * v53 atIndex:0];
  uint64_t v48 = *(void **)(a1 + 3000);
  *(void *)&long long v49 = v57;
  *((void *)&v49 + 1) = HIDWORD(v57);
  long long v64 = v49;
  uint64_t v65 = 1;
  v63[0] = v12;
  v63[1] = v53;
  v63[2] = 1;
  [v48 dispatchThreadgroups:&v64 threadsPerThreadgroup:v63];
  [*(id *)(a1 + 3000) setComputePipelineState:v54];
  [*(id *)(a1 + 3000) setBuffer:v58 offset:v26 atIndex:1];
  [*(id *)(a1 + 3000) setBuffer:external_buffer[4] offset:*((unsigned int *)external_buffer + 10) atIndex:2];
  [*(id *)(a1 + 3000) setThreadgroupMemoryLength:16 * v55 atIndex:0];
  uint64_t v50 = *(void **)(a1 + 3000);
  int64x2_t v60 = vdupq_n_s64(1uLL);
  int64x2_t v61 = v60;
  uint64_t v62 = 1;
  uint64_t v59 = v55;
  [v50 dispatchThreadgroups:&v61 threadsPerThreadgroup:&v59];
  if (v25) {
    CA::OGL::MetalBufferPool::release_external_buffer(*(void *)(a1 + 4040), v25);
  }
  return external_buffer;
}

uint64_t CA::OGL::MetalContext::compute_surface_apl_dimming_factor(CA::OGL::Surface *,CA::OGL::APLFilterParams const&)::$_0::operator()(uint64_t a1, uint64_t a2)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3)
  {
    if (CA::OGL::MetalContext::start_blit_encoder((CA::OGL::MetalContext *)a1, v3))
    {
      v8[0] = 0;
      unsigned int v7 = 0;
      uint64_t v5 = CA::OGL::MetalBufferPool::alloc_bytes(*(CA::OGL::MetalBufferPool **)(a1 + 4040), *(_DWORD *)(a2 + 8), 4u, v8, &v7);
      if (v5)
      {
        memset_pattern16(v5, &unk_1849987D0, 0x30uLL);
        [*(id *)(a1 + 2992) copyFromBuffer:v8[0] sourceOffset:v7 toBuffer:*(void *)(a2 + 32) destinationOffset:*(unsigned int *)(a2 + 40) size:*(void *)(a2 + 8)];
      }
    }
  }
  else
  {
    memset_pattern16(*(void **)a2, &unk_1849987D0, 0x30uLL);
  }
  return a2;
}

uint64_t CA::OGL::MetalContext::get_compute_pipeline(uint64_t a1, unsigned int a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1 + 8 * a2;
  uint64_t result = *(void *)(v3 + 2648);
  if (!result)
  {
    id v17 = 0;
    uint64_t v5 = CA::OGL::MetalContext::get_compute_pipeline(CA::OGL::MetalContext::ComputeShaderType)::compute_fct_names[a2];
    shader_functiouint64_t n = CA::OGL::MetalContext::load_shader_function(a1, *(void **)(a1 + 3336), v5, 0, 0, 0, (uint64_t)&v17);
    if (shader_function)
    {
      unsigned int v7 = shader_function;
      unsigned int v8 = (uint64_t *)(v3 + 2648);
      *unsigned int v8 = [*(id *)(a1 + 2952) newComputePipelineStateWithFunction:shader_function error:&v17];

      uint64_t result = *v8;
      if (*v8) {
        return result;
      }
      bzero(__str, 0x7FFuLL);
      uint64_t v11 = (const char *)[(__CFString *)v5 UTF8String];
      if (v17) {
        unsigned __int32 v12 = (const char *)objc_msgSend((id)objc_msgSend(v17, "localizedDescription"), "UTF8String");
      }
      else {
        unsigned __int32 v12 = "";
      }
      snprintf(__str, 0x800uLL, "pipeline with function=%s\n%s", v11, v12);
      char v23 = 0;
      if (!x_log_hook_p())
      {
        unint64_t v14 = x_log_category_ogl_metal;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t buf = 136315394;
          float32x2_t v19 = "Metal failed to build compute pipeline";
          __int16 v20 = 2080;
          int32x2_t v21 = __str;
          _os_log_impl(&dword_184668000, v14, OS_LOG_TYPE_ERROR, "%s: %s\n", buf, 0x16u);
        }
        goto LABEL_19;
      }
    }
    else
    {
      bzero(__str, 0x7FFuLL);
      int v9 = (const char *)[(__CFString *)v5 UTF8String];
      if (v17) {
        uint64_t v10 = (const char *)objc_msgSend((id)objc_msgSend(v17, "localizedDescription"), "UTF8String");
      }
      else {
        uint64_t v10 = "";
      }
      snprintf(__str, 0x800uLL, "function=%s\n%s", v9, v10);
      char v23 = 0;
      if (!x_log_hook_p())
      {
        unint64_t v13 = x_log_category_ogl_metal;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t buf = 136315394;
          float32x2_t v19 = "Metal failed to load compute shader";
          __int16 v20 = 2080;
          int32x2_t v21 = __str;
          _os_log_impl(&dword_184668000, v13, OS_LOG_TYPE_ERROR, "%s: %s\n", buf, 0x16u);
        }
        goto LABEL_19;
      }
    }
    x_log_();
LABEL_19:
    strlen(__str);
    int32x2_t v15 = (CA::OGL::MetalContext *)abort_with_payload();
    return CA::OGL::MetalContext::start_compute_encoder(v15, v16);
  }
  return result;
}

uint64_t CA::OGL::MetalContext::start_compute_encoder(CA::OGL::MetalContext *this, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 375)) {
    return 1;
  }
  CA::OGL::MetalContext::stop_encoders(this);
  uint64_t result = CA::OGL::MetalContext::start_command_buffer(this, a2, v4);
  if (!result) {
    return result;
  }
  id v6 = (id)[*((id *)this + 372) computeCommandEncoderWithDispatchType:0];
  *((void *)this + 375) = v6;
  if (v6)
  {
    if (BYTE3(xmmword_1EB2ACC70)) {
      uint64_t v7 = mach_continuous_time();
    }
    else {
      uint64_t v7 = 0;
    }
    *((void *)this + 388) = v7;
    return 1;
  }
  if (x_log_hook_p())
  {
    x_log_();
    return 0;
  }
  unsigned int v8 = x_log_category_ogl_metal;
  uint64_t result = os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)int v9 = 0;
    _os_log_impl(&dword_184668000, v8, OS_LOG_TYPE_ERROR, "Unable to start compute command encoder\n", v9, 2u);
    return 0;
  }
  return result;
}

void CA::OGL::MetalContext::finalize_buffer(uint64_t a1, uint64_t a2)
{
}

void *CA::OGL::MetalContext::create_buffer(CA::OGL::MetalBufferPool **this, unsigned int a2, unint64_t a3)
{
  return CA::OGL::MetalBufferPool::create_external_buffer(this[505], a2, a3, 0);
}

uint64_t std::__function::__func<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0,std::allocator<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0>,BOOL ()(CA::OGL::Vertex *,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED030D68;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0,std::allocator<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0>,BOOL ()(CA::OGL::Vertex *,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1ED030D68;
  result[1] = v3;
  return result;
}

void std::__function::__func<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0,std::allocator<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0>,BOOL ()(CA::OGL::Vertex *,unsigned int)>::~__func()
{
}

uint64_t CA::OGL::MetalContext::emit_new_render_pipeline(CA::OGL::MetalContext *this, NSString *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unsigned int add = atomic_fetch_add(CA::OGL::MetalContext::_next_pipeline_id, 1u);
  if (CA::OGL::MetalContext::get_pipeline_log(void)::pipeline_once != -1) {
    dispatch_once(&CA::OGL::MetalContext::get_pipeline_log(void)::pipeline_once, &__block_literal_global_307);
  }
  uint64_t v4 = CA::OGL::MetalContext::get_pipeline_log(void)::pipeline_log;
  uint64_t result = os_signpost_enabled((os_log_t)CA::OGL::MetalContext::get_pipeline_log(void)::pipeline_log);
  if (result)
  {
    uint64_t v7 = (CA::OGL::MetalContext *)(*((_WORD *)this + 416) & 1 | 2u);
    *(void *)__str = 0;
    uint64_t result = CA::OGL::MetalContext::format_new_pipeline_flags_string(v7, __str, v6);
    if (add)
    {
      uint64_t result = os_signpost_enabled(v4);
      if (result) {
        return _os_signpost_emit_unreliably_with_name_impl();
      }
    }
  }
  return result;
}

void *___ZN2CA3OGL12MetalContext18get_Opcode_decoderEv_block_invoke()
{
  uint64_t result = &unk_1ED057490;
  CA::OGL::MetalContext::get_Opcode_decoder(void)::decoder = (uint64_t)result;
  return result;
}

uint64_t CA::OGL::MetalContext::get_TextureFilter_decoder(CA::OGL::MetalContext *this)
{
  if (CA::OGL::MetalContext::get_TextureFilter_decoder(void)::once[0] != -1) {
    dispatch_once(CA::OGL::MetalContext::get_TextureFilter_decoder(void)::once, &__block_literal_global_2553);
  }
  return CA::OGL::MetalContext::get_TextureFilter_decoder(void)::decoder;
}

void *___ZN2CA3OGL12MetalContext25get_TextureFilter_decoderEv_block_invoke()
{
  uint64_t result = &unk_1ED057468;
  CA::OGL::MetalContext::get_TextureFilter_decoder(void)::decoder = (uint64_t)result;
  return result;
}

void *___ZN2CA3OGL12MetalContext25get_CoordFunction_decoderEv_block_invoke()
{
  uint64_t result = &unk_1ED057440;
  CA::OGL::MetalContext::get_CoordFunction_decoder(void)::decoder = (uint64_t)result;
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_17::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xDFFF | ((a2 != 0) << 13);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_16::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xEFFF | ((a2 != 0) << 12);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_15::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFFF7 | (8 * (a2 != 0));
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_14::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFBFF | ((a2 != 0) << 10);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_13::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFDFF | ((a2 != 0) << 9);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_12::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFEFF | ((a2 != 0) << 8);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_11::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFF7F | ((a2 != 0) << 7);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_6::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFFFB | (4 * (a2 != 0));
  return result;
}

uint64_t CA::OGL::MetalContext::get_VertexLayout_decoder(CA::OGL::MetalContext *this)
{
  if (CA::OGL::MetalContext::get_VertexLayout_decoder(void)::once != -1) {
    dispatch_once(&CA::OGL::MetalContext::get_VertexLayout_decoder(void)::once, &__block_literal_global_2319);
  }
  return CA::OGL::MetalContext::get_VertexLayout_decoder(void)::decoder;
}

void *___ZN2CA3OGL12MetalContext24get_VertexLayout_decoderEv_block_invoke()
{
  uint64_t result = &unk_1ED0573F0;
  CA::OGL::MetalContext::get_VertexLayout_decoder(void)::decoder = (uint64_t)result;
  return result;
}

uint64_t CA::OGL::MetalContext::get_DestinationFunction_decoder(CA::OGL::MetalContext *this)
{
  if (CA::OGL::MetalContext::get_DestinationFunction_decoder(void)::once[0] != -1) {
    dispatch_once(CA::OGL::MetalContext::get_DestinationFunction_decoder(void)::once, &__block_literal_global_2298);
  }
  return CA::OGL::MetalContext::get_DestinationFunction_decoder(void)::decoder;
}

void *___ZN2CA3OGL12MetalContext31get_DestinationFunction_decoderEv_block_invoke()
{
  uint64_t result = &unk_1ED0573C8;
  CA::OGL::MetalContext::get_DestinationFunction_decoder(void)::decoder = (uint64_t)result;
  return result;
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::decode_segment(char const**)::$_2::__invoke(uint64_t result, int a2)
{
  *(unsigned char *)(result + 23) = *(unsigned char *)(result + 23) & 0xFE | (a2 != 0);
  return result;
}

uint64_t CA::OGL::MetalContext::generate_mipmaps_for_texture(CA::OGL::MetalContext *a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a2 + 64);
  if (!v3) {
    __assert_rtn("generate_mipmaps_for_texture", "ogl-metal.mm", 12467, "tex->textures[0] && \"nil mtl texture?\"");
  }
  uint64_t result = CA::OGL::MetalContext::start_blit_encoder(a1, [v3 protectionOptions]);
  if (result)
  {
    id v6 = (void *)*((void *)a1 + 374);
    uint64_t v7 = *(void *)(a2 + 64);
    return [v6 generateMipmapsForTexture:v7];
  }
  return result;
}

uint64_t CA::OGL::MetalContext::state_requires_disjoint_primitives(CA::OGL::MetalContext *this)
{
  return 0;
}

void CA::OGL::MetalContext::copy_surface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, float64x2_t *a6, float64x2_t *a7)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a4) {
    BOOL v14 = *(_DWORD *)(a3 + 24) < *(_DWORD *)(a2 + 24) || *(_DWORD *)(a3 + 28) < *(_DWORD *)(a2 + 28);
  }
  else {
    BOOL v14 = 0;
  }
  *(void *)(a1 + 3088) = [*(id *)(a2 + 96) protectionOptions];
  if (CA::ScalerUtil::get_io_service(void)::once != -1) {
    dispatch_once(&CA::ScalerUtil::get_io_service(void)::once, &__block_literal_global_77);
  }
  if (!CA::ScalerUtil::get_io_service(void)::scaler_service && *(void *)(a2 + 120) == 500)
  {
    int32x2_t v15 = (void *)MEMORY[0x185324A30]();
    unsigned int v16 = *(_DWORD *)(a2 + 24);
    if (*(_DWORD *)(a3 + 24) == v16)
    {
      unsigned int v17 = *(_DWORD *)(a2 + 28);
      surface = (char *)a3;
      if (*(_DWORD *)(a3 + 28) == v17)
      {
LABEL_29:
        if (CA::OGL::MetalContext::start_compute_encoder((CA::OGL::MetalContext *)a1, *(void *)(a1 + 3088)))
        {
          uint64_t compute_pipeline = CA::OGL::MetalContext::get_compute_pipeline(a1, 3u);
          int32x2_t v28 = *(int32x2_t *)(a3 + 24);
          uint64_t v29 = [*(id *)(a2 + 96) iosurface];
          unint64_t v30 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:10 width:*(int *)(a2 + 24) height:*(int *)(a2 + 28) mipmapped:0];
          [v30 setUsage:2];
          id v31 = (id)[*(id *)(a1 + 2952) newTextureWithDescriptor:v30 iosurface:v29 plane:0];
          int v32 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:30 width:vcvtpd_u64_f64((double)*(int *)(a2 + 24) * 0.5) height:vcvtpd_u64_f64((double)*(int *)(a2 + 28) * 0.5) mipmapped:0];
          [v32 setUsage:2];
          id v33 = (id)[*(id *)(a1 + 2952) newTextureWithDescriptor:v32 iosurface:v29 plane:1];
          [*(id *)(a1 + 3000) setComputePipelineState:compute_pipeline];
          [*(id *)(a1 + 3000) setTexture:*((void *)surface + 12) atIndex:1];
          [*(id *)(a1 + 3000) setTexture:v31 atIndex:2];
          [*(id *)(a1 + 3000) setTexture:v33 atIndex:3];
          __asm { FMOV            V1.2D, #0.125 }
          double v39 = *(void **)(a1 + 3000);
          uint64x2_t v43 = vcvtq_u64_f64(vmulq_f64(vcvtq_f64_u64((uint64x2_t)vaddw_s32(vdupq_n_s64(0xFuLL), v28)), _Q1));
          uint64_t v44 = 1;
          int64x2_t v41 = vdupq_n_s64(0x10uLL);
          uint64_t v42 = 1;
          [v39 dispatchThreadgroups:&v43 threadsPerThreadgroup:&v41];
          if (surface != (char *)a3) {
            CA::OGL::Context::release_surface(a1, (uint64_t)surface);
          }
        }
        goto LABEL_32;
      }
    }
    else
    {
      unsigned int v17 = *(_DWORD *)(a2 + 28);
    }
    v43.i64[0] = 0;
    v43.i64[1] = __PAIR64__(v17, v16);
    surface = CA::OGL::MetalContext::create_surface((CA::OGL::MetalContext *)a1, MTLPixelFormatA8Unorm, (int32x2_t *)&v43, 1048591);
    if (surface)
    {
      CA::OGL::MetalContext::copy_surface(a1, surface, a3, 0, 0, 0, 0);
      goto LABEL_29;
    }
LABEL_32:
    return;
  }
  if (a7) {
    char v19 = 1;
  }
  else {
    char v19 = v14;
  }
  if ((a5 & 7) == 0 && !a6 && (v19 & 1) == 0)
  {
    int32x2_t v15 = (void *)MEMORY[0x185324A30]();
    uint64_t v20 = *(void *)(a3 + 120);
    if (v20 == 550) {
      uint64_t v20 = 554;
    }
    if (*(void *)(a2 + 120) == v20
      && *(_DWORD *)(a3 + 40) == *(_DWORD *)(a2 + 40)
      && *(_DWORD *)(a3 + 44) == *(_DWORD *)(a2 + 44))
    {
      uint64_t v21 = [*(id *)(a2 + 96) protectionOptions];
      uint64_t v22 = *(int *)(a3 + 40);
      uint64_t v23 = *(int *)(a3 + 44);
      if (CA::OGL::MetalContext::start_blit_encoder((CA::OGL::MetalContext *)a1, v21))
      {
        uint64_t v24 = *(void **)(a1 + 2992);
        uint64_t v25 = *(void *)(a3 + 96);
        uint64_t v44 = 0;
        uint64x2_t v43 = 0uLL;
        v41.i64[0] = v22;
        v41.i64[1] = v23;
        uint64_t v42 = 1;
        uint64_t v26 = *(void *)(a2 + 96);
        memset(v40, 0, sizeof(v40));
        [v24 copyFromTexture:v25 sourceSlice:0 sourceLevel:0 sourceOrigin:&v43 sourceSize:&v41 toTexture:v26 destinationSlice:0 destinationLevel:0 destinationOrigin:v40];
        *(_DWORD *)(a2 + 64) = *(_DWORD *)(a3 + 64);
        goto LABEL_32;
      }
      *(_DWORD *)(a2 + 64) = *(_DWORD *)(a3 + 64);
    }
  }

  CA::OGL::Context::copy_surface(a1, a2, a3, a4, a5, a6, a7);
}

void sub_1848BC6B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN2CA3OGL12MetalContext22calculate_average_lumaEPNS0_7SurfaceEU13block_pointerFvfE_block_invoke(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void **)(*(void *)(a1 + 48) + 96);
  int v17 = 0;
  memset(v14, 0, sizeof(v14));
  int64x2_t v15 = vdupq_n_s64(1uLL);
  uint64_t v16 = 1;
  [v3 getBytes:&v17 bytesPerRow:4 bytesPerImage:4 fromRegion:v14 mipmapLevel:0 slice:0];
  if (HIBYTE(v17))
  {
    LOBYTE(v4) = BYTE2(v17);
    unsigned int v5 = 1046066128;
    LOBYTE(v5) = BYTE1(v17);
    *(float *)&unsigned int v6 = (float)v5;
    float v7 = (float)((float)v4 * 0.2126) + (float)(*(float *)&v6 * 0.7152);
    LOBYTE(v6) = v17;
    float v8 = (float)(v7 + (float)((float)v6 * 0.0722)) / (float)HIBYTE(v17);
    if (v8 > 1.0) {
      float v8 = 1.0;
    }
    if (v8 >= 0.0) {
      float v9 = v8;
    }
    else {
      float v9 = 0.0;
    }
  }
  else
  {
    float v9 = -1.0;
  }
  float v10 = *(float *)(a1 + 56);
  CA::OGL::Context::release_surface_async(v2, *(void *)(a1 + 48));
  unsigned __int32 v12 = *(uint64_t (**)(__n128))(*(void *)(a1 + 32) + 16);

  v11.n128_f32[0] = v10 * v9;
  return v12(v11);
}

uint64_t CA::OGL::srgb_pixel_format(uint64_t this, MTLPixelFormat a2)
{
  if (this <= 79)
  {
    switch(this)
    {
      case 10:
        return 11;
      case 30:
        return 31;
      case 70:
        return 71;
    }
  }
  else if (this > 551)
  {
    if (this == 552)
    {
      return 553;
    }
    else if (this == 554)
    {
      return 555;
    }
  }
  else if (this == 80)
  {
    return 81;
  }
  else if (this == 550)
  {
    return 551;
  }
  return this;
}

const char *CA::OGL::MetalContext::metal_pixel_format_name(CA::OGL::MetalContext *this, MTLPixelFormat a2)
{
  Name = (const char *)MTLPixelFormatGetName();
  if (!strncmp(Name, "MTLPixelFormat", 0xEuLL)) {
    uint64_t v3 = 14;
  }
  else {
    uint64_t v3 = 0;
  }
  return &Name[v3];
}

double CA::OGL::MetalContext::create_null_surface(CA::OGL::MetalContext *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v2 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xF0uLL, 0x743898A5uLL);
  *(_DWORD *)uint64_t v2 = 1;
  double result = 0.0;
  *((_OWORD *)v2 + 2) = xmmword_184998020;
  *((_DWORD *)v2 + 17) = 15;
  v2[72] |= 1u;
  __int16 v4 = *((_WORD *)v2 + 116) & 0xFFC0;
  v2[73] = v2[73] & 0xC0 | 0x13;
  *(_WORD *)(v2 + 75) |= 0x80u;
  *((_WORD *)v2 + 116) = v4 | 0x31;
  return result;
}

char *CA::OGL::MetalContext::create_reinterpreted_surface(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = [*(id *)(a2 + 96) pixelFormat];
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  float v9 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xF0uLL, 0x743898A5uLL);
  *(_DWORD *)float v9 = 1;
  *(_OWORD *)(v9 + 24) = *(_OWORD *)(a2 + 24);
  *((void *)v9 + 5) = *(void *)(a2 + 40);
  *((void *)v9 + 6) = *(void *)(a2 + 48);
  *((_DWORD *)v9 + 16) = *(_DWORD *)(a2 + 64);
  v9[72] = v9[72] & 0xFE | *(unsigned char *)(a2 + 72) & 1;
  int v10 = *(_WORD *)(v9 + 75) & 0xFFF0 | *(_WORD *)(a2 + 75) & 0xF;
  *(_WORD *)(v9 + 75) = *(_WORD *)(v9 + 75) & 0xFFF0 | *(_WORD *)(a2 + 75) & 0xF;
  unsigned int v11 = *(_WORD *)(a2 + 75) & 0x10 | v10 & 0xFFFFFFEF | 0x100;
  *(_WORD *)(v9 + 75) = *(_WORD *)(a2 + 75) & 0x10 | v10 & 0xFFEF | 0x100;
  *(_OWORD *)(v9 + 184) = *(_OWORD *)(a2 + 184);
  int v12 = *((_WORD *)v9 + 116) & 0xFFF0 | *(_WORD *)(a2 + 232) & 0xF;
  *((_WORD *)v9 + 116) = *((_WORD *)v9 + 116) & 0xFFF0 | *(_WORD *)(a2 + 232) & 0xF;
  unsigned int v13 = v12 & 0xFFFFFEFF | ((HIBYTE(*(unsigned __int16 *)(a2 + 232)) & 1) << 8);
  *((_WORD *)v9 + 116) = v13;
  *(_DWORD *)(v9 + 214) = *(_DWORD *)(a2 + 214);
  unsigned int v14 = v13 & 0xFFFFFDFF | (((*(unsigned __int16 *)(a2 + 232) >> 9) & 1) << 9);
  *((_WORD *)v9 + 116) = v14;
  *((_WORD *)v9 + 116) = v14 & 0xFBFF | *(_WORD *)(a2 + 232) & 0x400;
  unsigned int v15 = v11 & 0xFFFFFFDF | (32 * ((*(unsigned __int16 *)(a2 + 75) >> 5) & 1));
  *(_WORD *)(v9 + 75) = v15;
  LOWORD(v15) = v15 & 0xFFBF | (((*(_WORD *)(a2 + 75) >> 6) & 1) << 6);
  *(_WORD *)(v9 + 75) = v15;
  *(_WORD *)(v9 + 75) = v15 & 0xFF7F | *(_WORD *)(a2 + 75) & 0x80;
  int v16 = *(_DWORD *)(a2 + 68);
  if (a3)
  {
    unsigned int v17 = v16 | 0x80;
    uint64_t v18 = CA::OGL::srgb_pixel_format(v6, v8);
  }
  else
  {
    unsigned int v17 = v16 & 0xFFFFFF7F;
    uint64_t v18 = CA::OGL::non_srgb_pixel_format(v6, v8);
  }
  uint64_t v19 = v18;
  *((_DWORD *)v9 + 17) = v17;
  uint64_t v20 = (void *)[*(id *)(a2 + 96) newTextureViewWithPixelFormat:v18];
  *((void *)v9 + 12) = v20;
  *((void *)v9 + 15) = v19;
  if (v20)
  {
    [v20 setLabel:@"com.apple.coreanimation.reinterpreted-surface"];
    if ((__int16)(*(_WORD *)(a2 + 232) << 12) > 4096)
    {
      uint64_t v21 = 0;
      uint64_t v22 = a2 + 104;
      do
      {
        uint64_t v23 = &v9[8 * v21];
        *((void *)v23 + 13) = *(id *)(v22 + 8 * v21);
        *((void *)v23 + 16) = [*(id *)(v22 + 8 * v21) pixelFormat];
        uint64_t v24 = v21 + 2;
        ++v21;
      }
      while (v24 < *(unsigned __int16 *)(a2 + 232) << 28 >> 28);
    }
  }
  else
  {
    CA::OGL::MetalContext::finalize_surface(a1, (uint64_t)v9);
    return 0;
  }
  return v9;
}

atomic_uint *CA::WindowServer::Surface::set_hdr_processor(CA::WindowServer::Surface *this, atomic_uint *a2)
{
  double result = (atomic_uint *)*((void *)this + 11);
  if (result != a2)
  {
    if (result && atomic_fetch_add(result + 4, 0xFFFFFFFF) == 1) {
      double result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 8))(result);
    }
    if (a2) {
      atomic_fetch_add(a2 + 4, 1u);
    }
    *((void *)this + 11) = a2;
  }
  return result;
}

uint64_t CA::OGL::MetalContext::can_render_to_format(CA::OGL::MetalContext *this, CA::Render *a2)
{
  return 0;
}

void *CA::OGL::MetalContext::modify_subimage_impl(void *result, unint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  v20[6] = *MEMORY[0x1E4F143B8];
  if (a2 && *(unsigned char *)(a3 + 153) == 1 && !*(void *)(a3 + 160))
  {
    unsigned int v15 = result;
    unint64_t v16 = *(unsigned __int8 *)(a3 + 152);
    if (v16 > 0x25) {
      int v17 = 0;
    }
    else {
      int v17 = dword_184999468[v16];
    }
    int v18 = v17 * a7;
    CA::OGL::MetalContext::update_texture_plane(result, a2, a4, 0, v16, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 20));
    uint64_t v19 = *(void **)(a2 + 64);
    v20[0] = a5;
    v20[1] = a6;
    _DWORD v20[2] = 0;
    v20[3] = a7;
    v20[4] = a8;
    v20[5] = 1;
    double result = (void *)[v19 replaceRegion:v20 mipmapLevel:0 withBytes:a9 bytesPerRow:v18];
    atomic_fetch_add((atomic_uint *volatile)(a3 + 36), 1u);
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 36);
    *(_WORD *)(a2 + 123) &= ~1u;
    v15[91] += v18 * a8;
  }
  return result;
}

CA::Render::Texture *CA::OGL::MetalContext::create_mutable_image(CA::OGL::MetalContext *this, CA::Render::Image *a2, unsigned int a3, unsigned int a4, CGColorSpace *a5)
{
  v7[1] = *MEMORY[0x1E4F143B8];
  v7[0] = 0;
  return CA::Render::Image::new_image(a2, a3, a4, 1u, a5, 0, v7, 0, 0, v6);
}

uint64_t CA::OGL::MetalContext::bind_lut_texture(CA::OGL::MetalContext *this, unsigned int a2, CA::Render::Texture *a3)
{
  if (*((CA::OGL::MetalContext **)a3 + 11) == this && (uint64_t v6 = *((void *)a3 + 10)) != 0
    || (uint64_t v6 = CA::OGL::Context::lookup_image_(this, a3, 1)) != 0)
  {
    CA::OGL::MetalContext::bind_color_cube(this, a2, a3);
    *(unsigned char *)(*((void *)this + 2) + 308) = a2;
  }
  return v6;
}

void CA::OGL::MetalContext::bind_color_cube(CA::OGL::MetalContext *this, unsigned int a2, CA::Render::Texture *a3)
{
  if (*((CA::OGL::MetalContext **)a3 + 11) == this && (uint64_t v6 = *((void *)a3 + 10)) != 0
    || (uint64_t v6 = CA::OGL::Context::lookup_image_(this, a3, 1)) != 0)
  {
    float v7 = CA::OGL::MetalContext::retain_image((uint64_t)this, v6, a3, 0);
    uint64_t v9 = (uint64_t)v7;
    if (*(unsigned char *)(v6 + 122))
    {
      if (*(_DWORD *)(v6 + 16) == *((_DWORD *)v7 + 9))
      {
        uint64_t v10 = *((void *)this + 2);
        *(_WORD *)(v10 + 2 * a2 + 144) = *(_DWORD *)(v6 + 52);
        *(void *)(v10 + 8 * a2 + 176) = v6;
        return;
      }
    }
    else
    {
      int v11 = *((_DWORD *)v7 + 4);
      int v12 = *((_DWORD *)v7 + 5);
      __int16 v13 = (*(uint64_t (**)(CA::Render::Image *))(*(void *)v7 + 144))(v7);
      *(_WORD *)(v6 + 120) = v13;
      __int16 v14 = *(_WORD *)(v6 + 123) | 0x400;
      *(_WORD *)(v6 + 123) = v14;
      if (v12 >= 2 && v13 == 1)
      {
        if (v12 != v11 * v11)
        {
          int v16 = v11 * v11 * v11;
          LOWORD(v11) = v11 * v11;
          if (v12 != v16) {
            return;
          }
        }
        *(_WORD *)(v6 + 120) = v11;
      }
      *(_WORD *)(v6 + 123) = v14 & 0xFFF7;
    }
    CA::OGL::MetalContext::update_texture((uint64_t)this, v6, v9, a2, 0, v8);
  }
}

atomic_uint *CA::OGL::MetalContext::create_lut_texture(CA::OGL::MetalContext *this, const CA::Render::Interpolator *a2, int a3)
{
  v23[6] = *MEMORY[0x1E4F143B8];
  if (a3 != 3) {
    return 0;
  }
  uint64_t v4 = *((void *)a2 + 3);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = *((void *)a2 + 4);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = 0;
  int v7 = *(unsigned __int8 *)(v4 + 12);
  if (v7 == 23) {
    uint64_t v8 = *((void *)a2 + 3);
  }
  else {
    uint64_t v8 = 0;
  }
  if (*(unsigned char *)(v5 + 12) == 23 && v7 == 23)
  {
    int v11 = (uint64_t *)*((void *)this + 45);
    if (v11)
    {
      uint64_t v12 = *v11;
      uint64_t v13 = v11[1];
      while (v12 != v13)
      {
        if (*(void *)v12 == (v8 | ((unint64_t)v5 << 32)))
        {
          *(_WORD *)(v12 + 26) = *(_WORD *)(v12 + 24);
          uint64_t v6 = *(atomic_uint **)(v12 + 16);
          if (v6) {
            return v6;
          }
          break;
        }
        v12 += 32;
      }
    }
    uint64_t v15 = *(unsigned int *)(v8 + 16);
    id v16 = objc_alloc_init(MEMORY[0x1E4F35330]);
    [v16 setTextureType:7];
    [v16 setWidth:v15];
    [v16 setHeight:v15];
    [v16 setDepth:2 * v15];
    [v16 setPixelFormat:115];
    [v16 setUsage:1];
    int v17 = (objc_object *)[*((id *)this + 369) newTextureWithDescriptor:v16];
    [(objc_object *)v17 setLabel:@"com.apple.coreanimation.interpolated_3d_lut"];

    uint64_t v18 = *(unsigned int *)(v8 + 160);
    memset(v23, 0, 24);
    _OWORD v23[3] = v15;
    v23[4] = v15;
    v23[5] = v15;
    [(objc_object *)v17 replaceRegion:v23 mipmapLevel:0 slice:0 withBytes:*(void *)(v8 + 96) bytesPerRow:v18 bytesPerImage:v18 * (unint64_t)v15];
    uint64_t v19 = *(unsigned int *)(v5 + 160);
    v22[0] = 0;
    v22[1] = 0;
    void v22[2] = v15;
    v22[3] = v15;
    v22[4] = v15;
    v22[5] = v15;
    [(objc_object *)v17 replaceRegion:v22 mipmapLevel:0 slice:0 withBytes:*(void *)(v5 + 96) bytesPerRow:v19 bytesPerImage:v19 * (unint64_t)v15];
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v21 = (CA::Render::MetalTexture *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x70uLL, 0x743898A5uLL);
    if (!v21)
    {

      __assert_rtn("add_transient_render_texture", "ogl-context.cpp", 2518, "key && img && !lookup_transient_render_texture (key, false)");
    }
    uint64_t v6 = (atomic_uint *)v21;
    CA::Render::MetalTexture::MetalTexture(v21, v17);

    CA::OGL::Context::add_transient_render_texture(this, v8 | ((unint64_t)v5 << 32), (atomic_uint *)a2, v6);
    if (atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
    }
  }
  return v6;
}

atomic_uint *CA::OGL::MetalContext::create_lut_texture(CA::OGL::MetalContext *this, const CA::Render::Vector *a2, int a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a3 != 3) {
    return 0;
  }
  unsigned int v5 = *((_DWORD *)a2 + 4);
  unsigned int v6 = v5 >> 2;
  double v7 = cbrt((double)(v5 >> 2));
  if (v5 < 0x20
    || ((unsigned int v8 = v7, v9 = v8 * v8, v7 <= 0x80) ? (_ZF = v9 * v8 == v6) : (_ZF = 0), !_ZF))
  {
    if (x_log_hook_p())
    {
LABEL_8:
      x_log_();
      return 0;
    }
    uint64_t v11 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)uint64_t buf = 67109120;
    unsigned int v40 = v6;
    uint64_t v12 = "Invalid 3D lut input data with pixel count of %u";
    uint64_t v13 = v11;
    uint32_t v14 = 8;
LABEL_11:
    _os_log_impl(&dword_184668000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
    return 0;
  }
  uint64_t v15 = (uint64_t *)*((void *)this + 45);
  if (v15)
  {
    uint64_t v16 = *v15;
    uint64_t v17 = v15[1];
    while (v16 != v17)
    {
      if (*(const CA::Render::Vector **)v16 == a2)
      {
        *(_WORD *)(v16 + 26) = *(_WORD *)(v16 + 24);
        uint64_t v18 = *(atomic_uint **)(v16 + 16);
        if (v18) {
          return v18;
        }
        break;
      }
      v16 += 32;
    }
  }
  unint64_t v19 = CA::Render::format_rowbytes((CA::Render *)0xD, v7);
  unint64_t v20 = v19;
  uint64_t v37 = 0;
  unint64_t v38 = v19;
  if (is_mul_ok(v19, v9)) {
    uint64_t v21 = (CA::Render *)(v19 * v9);
  }
  else {
    uint64_t v21 = 0;
  }
  uint64_t v22 = (CGColorSpace *)CA::Render::aligned_malloc(v21, (unint64_t *)&v37, 0);
  if (!v22) {
    return 0;
  }
  if (!v8) {
    goto LABEL_40;
  }
  uint64_t v23 = 0;
  uint64_t v24 = v9 <= 1 ? 1 : v9;
  uint64_t v25 = 24;
  do
  {
    uint64_t v26 = (_WORD *)((char *)v22 + 2 * (v20 >> 1) * v23);
    uint64_t v27 = v25;
    uint64_t v28 = 4 * v8;
    do
    {
      _D0 = *(void *)((char *)a2 + v27);
      __asm { FCVT            H0, D0 }
      *v26++ = _D0;
      v27 += 8;
      --v28;
    }
    while (v28);
    ++v23;
    v25 += 32 * v8;
  }
  while (v23 != v24);
  id v33 = CA::Render::Image::new_image((CA::Render::Image *)0xD, v8, v8 * v8, 1u, 0, v22, &v38, (const unint64_t *)CA::Render::aligned_free, v37, v36);
  if (!v33)
  {
LABEL_40:
    if (x_log_hook_p()) {
      goto LABEL_8;
    }
    uint64_t v34 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)uint64_t buf = 67109632;
    unsigned int v40 = v8;
    __int16 v41 = 1024;
    unsigned int v42 = v8;
    __int16 v43 = 1024;
    unsigned int v44 = v8;
    uint64_t v12 = "Unable to allocate 3D LUT texture of size %ux%ux%u";
    uint64_t v13 = v34;
    uint32_t v14 = 20;
    goto LABEL_11;
  }
  uint64_t v18 = (atomic_uint *)v33;
  CA::OGL::Context::add_transient_render_texture(this, (uint64_t)a2, (atomic_uint *)a2, (atomic_uint *)v33);
  if (atomic_fetch_add(v18 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v18 + 16))(v18);
  }
  return v18;
}

void CA::OGL::MetalContext::bind_table_image(CA::OGL::MetalContext *this, unsigned int a2, atomic_uint *a3)
{
  if (*((CA::OGL::MetalContext **)a3 + 11) == this && (unint64_t v6 = *((void *)a3 + 10)) != 0
    || (unint64_t v6 = CA::OGL::Context::lookup_image_(this, (CA::Render::Texture *)a3, 1)) != 0)
  {
    if (!*(void *)(v6 + 8))
    {
      *(void *)(v6 + 8) = a3;
      atomic_fetch_add(a3 + 37, 1u);
    }
    if (*(unsigned char *)(v6 + 122))
    {
      if (*(_DWORD *)(v6 + 16) == a3[9])
      {
        uint64_t v7 = *((void *)this + 2);
        *(_WORD *)(v7 + 2 * a2 + 144) = *(_DWORD *)(v6 + 52);
        *(void *)(v7 + 8 * a2 + 176) = v6;
        return;
      }
    }
    else
    {
      *(_WORD *)(v6 + 123) &= ~8u;
    }
    CA::OGL::MetalContext::update_image((uint64_t)this, v6, (uint64_t)a3, a2, 0);
  }
}

void *CA::OGL::MetalContext::bind_luma_boost(void *this, unsigned int a2)
{
  uint64_t v3 = this;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this[363];
  if (!v4)
  {
    unint64_t v6 = 0;
    memset(v31, 0, sizeof(v31));
    int32x2_t v7 = 0;
    memset(v30, 0, sizeof(v30));
    do
    {
      float v8 = (float)v6 * 0.007874;
      float v9 = (float)((float)(1.0 - v8) * (float)(1.0 - v8)) * v8;
      float v10 = v9
          + (float)((float)(v8 * v8) * v8)
          + (v8 * v8 + v8 * v8 + (float)(1.0 - v8) * (float)(1.0 - v8) * 0.5) * (float)(1.0 - v8);
      float v11 = (float)(v10 - v8) * v9;
      *((float *)v31 + v6) = v11;
      if (v11 >= *(float *)v7.i32) {
        *(float *)v7.i32 = v11;
      }
      ++v6;
    }
    while (v6 != 128);
    uint64_t v12 = 0;
    *(float *)v7.i32 = 255.0 / *(float *)v7.i32;
    float32x4_t v13 = (float32x4_t)vdupq_lane_s32(v7, 0);
    uint32_t v14 = (float32x4_t *)v31;
    do
    {
      v15.i64[0] = 0x3F0000003F000000;
      v15.i64[1] = 0x3F0000003F000000;
      v16.i64[0] = 0x3F0000003F000000;
      v16.i64[1] = 0x3F0000003F000000;
      v17.i64[0] = 0x3F0000003F000000;
      v17.i64[1] = 0x3F0000003F000000;
      v18.i64[0] = 0x3F0000003F000000;
      v18.i64[1] = 0x3F0000003F000000;
      int16x4_t v19 = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v18, v14[1], v13)));
      *(int16x4_t *)v18.f32 = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v17, *v14, v13)));
      *(int16x4_t *)&v18.u32[2] = v19;
      *(int16x4_t *)v20.i8 = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v16, v14[2], v13)));
      v20.u64[1] = (unint64_t)vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v15, v14[3], v13)));
      v30[v12++] = vuzp1q_s8((int8x16_t)v18, v20);
      v14 += 4;
    }
    while (v12 != 8);
    CA::OGL::MetalContext::new_image((CA::OGL::MetalContext *)this);
    uint64_t v4 = v21;
    int v22 = *(_DWORD *)(v21 + 52);
    *(unsigned char *)(v21 + 56) = *(unsigned char *)(v21 + 56) & 0xC0 | 0x17;
    *(_WORD *)(v21 + 58) &= 0xFFE7u;
    __int16 v23 = *(_WORD *)(v21 + 123);
    *(_DWORD *)(v21 + 48) = -1098907648;
    *(_DWORD *)(v21 + 52) = v22 & 0xC000FFFF | 0x110000;
    *(unsigned char *)(v21 + 122) = 1;
    *(_WORD *)(v21 + 123) = v23 & 0xFFE0 | 2;
    id v24 = objc_alloc_init(MEMORY[0x1E4F35330]);
    [v24 setTextureType:2];
    [v24 setWidth:128];
    [v24 setHeight:1];
    [v24 setPixelFormat:10];
    [v24 setUsage:1];
    *(void *)(v4 + 88) = v24;
    uint64_t v25 = (void *)[(id)v3[369] newTextureWithDescriptor:v24];
    *(void *)(v4 + 64) = v25;
    [v25 setLabel:@"com.apple.coreanimation.luma-boost-texture"];
    uint64_t v26 = *(void **)(v4 + 64);
    memset(v27, 0, sizeof(v27));
    long long v28 = xmmword_184998360;
    uint64_t v29 = 1;
    this = (void *)[v26 replaceRegion:v27 mipmapLevel:0 withBytes:v30 bytesPerRow:128];
    v3[363] = v4;
  }
  uint64_t v5 = v3[2];
  *(_WORD *)(v5 + 2 * a2 + 144) = 0;
  *(void *)(v5 + 8 * a2 + 176) = v4;
  return this;
}

void CA::OGL::MetalContext::bind_overdrive(void **this, unsigned int a2, unsigned int a3, float a4, float a5, CA::OGL *a6, float a7, int *a8, float *a9, float *a10)
{
  double v100 = a10;
  float v11 = a9;
  double v97 = a8;
  float32x4_t v18 = (CA::OGL::MetalContext *)this;
  v110[1] = *MEMORY[0x1E4F143B8];
  if (ca_debug_lut_changed == 1)
  {
    float v10 = (CA::OGL::MetalContext *)this;
    if (this[358])
    {
      unint64_t v85 = 0;
      double v87 = (unint64_t *)(this + 358);
      do
      {
        CA::OGL::MetalContext::delete_image((uint64_t)this, *((void *)this[359] + v85));
        double v88 = (void *)*((void *)this[359] + v85);
        if (v88)
        {
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(malloc_zone, v88);
        }
        ++v85;
      }
      while (v85 < *v87);
      float v10 = (CA::OGL::MetalContext *)this;
      free(this[359]);
      *double v87 = 0;
      v87[1] = 0;
    }
    uint64_t v90 = (void *)*((void *)v10 + 360);
    if (v90)
    {
      free(v90);
      *((void *)v10 + 360) = 0;
    }
    uint64_t v91 = (void *)*((void *)v10 + 362);
    float v11 = a9;
    float32x4_t v18 = v10;
    if (v91)
    {
      free(v91);
      *((void *)v10 + 362) = 0;
    }
    ca_debug_lut_changed = 0;
  }
  unint64_t v19 = *((void *)v18 + 358);
  if (!v19)
  {
    double v96 = (void *)MEMORY[0x185324A30]();
    uint64_t v109 = 0;
    v110[0] = 0;
    double v102 = v18;
    if (lut_file)
    {
      int8x16_t v20 = objc_msgSend(MEMORY[0x1E4F1C9B8], "dataWithContentsOfFile:options:error:", objc_msgSend(NSString, "stringWithUTF8String:"), 1, 0);
      uint64_t v21 = (const uint8_t *)[v20 bytes];
      size_t v22 = [v20 length];
      *(void *)&long long v23 = 0;
      long long v107 = v23;
      if (v22 != 1310772)
      {
        id v24 = malloc_type_malloc(0x140034uLL, 0x6A82C100uLL);
        if (compression_decode_buffer((uint8_t *)v24, 0x140034uLL, v21, v22, 0, COMPRESSION_LZFSE) == 1310772) {
          int8x16_t v20 = (void *)[MEMORY[0x1E4F1C9B8] dataWithBytesNoCopy:v24 length:1310772];
        }
        else {
          free(v24);
        }
      }
    }
    else
    {
      if (a7 == 0.0) {
        goto LABEL_44;
      }
      LODWORD(v10) = vcvtms_s32_f32(a7);
      int8x16_t v20 = (void *)CA::OGL::overdrive_texture_data(a6, (uint64_t)v10);
      LODWORD(v25) = vcvtps_s32_f32(a7);
      *(float *)&long long v26 = a7 - floorf(a7);
      long long v107 = v26;
      if (v10 != v25)
      {
        id v106 = (id)CA::OGL::overdrive_texture_data(a6, v25);
        if (!v20) {
          goto LABEL_44;
        }
LABEL_13:
        if (![v20 length]) {
          goto LABEL_44;
        }
        objc_msgSend(v20, "getBytes:range:", (char *)v110 + 4, 0, 4);
        uint64_t v27 = v102;
        objc_msgSend(v20, "getBytes:range:", v110, 4, 4);
        objc_msgSend(v20, "getBytes:range:", (char *)&v109 + 4, 8, 4);
        objc_msgSend(v20, "getBytes:range:", &v109, 12, 4);
        long long v28 = malloc_type_malloc(4 * HIDWORD(v109), 0x100004052888210uLL);
        *((void *)v102 + 362) = v28;
        objc_msgSend(v20, "getBytes:range:", v28, 16, (4 * HIDWORD(v109)));
        uint64_t v29 = malloc_type_malloc(4 * v109, 0x100004052888210uLL);
        *((void *)v27 + 360) = v29;
        objc_msgSend(v20, "getBytes:range:", v29, (4 * HIDWORD(v109) + 16), (4 * v109));
        double v95 = v11;
        uint64_t v30 = [v20 bytes];
        unsigned int v93 = a2;
        unsigned int v94 = a3;
        uint64_t v32 = v109;
        uint64_t v31 = HIDWORD(v109);
        uint64_t v33 = [v106 bytes];
        uint64_t v35 = v109;
        uint64_t v34 = HIDWORD(v109);
        *((void *)v27 + 361) = HIDWORD(v109);
        uint64_t v36 = (CA::OGL::MetalContext *)malloc_type_malloc(8 * v35, 0x2004093837F09uLL);
        *((void *)v27 + 359) = v36;
        int v38 = v109;
        unsigned int v37 = HIDWORD(v109);
        *((void *)v27 + 358) = v109;
        uint64_t v39 = (LODWORD(v110[0]) * HIDWORD(v110[0]));
        if (v106)
        {
          if (v39 > 0x400)
          {
            uint64_t v36 = (CA::OGL::MetalContext *)malloc_type_malloc(4 * (LODWORD(v110[0]) * HIDWORD(v110[0])), 0x67BA75BEuLL);
            __int16 v41 = v36;
            if (!v109)
            {
LABEL_41:
              a3 = v94;
              a2 = v93;
              float v11 = v95;
              if (v41 && v39 > 0x400) {
                free(v41);
              }
LABEL_44:
              float32x4_t v18 = v102;
              unint64_t v19 = *((void *)v102 + 358);
              if (!v19) {
                return;
              }
              goto LABEL_45;
            }
          }
          else
          {
            MEMORY[0x1F4188790](v36);
            __int16 v41 = (CA::OGL::MetalContext *)((char *)&v92 - ((v40 + 15) & 0x7FFFFFFF0));
            bzero(v41, v40);
            if (!v38) {
              goto LABEL_41;
            }
          }
        }
        else
        {
          __int16 v41 = 0;
          if (!v38) {
            goto LABEL_41;
          }
        }
        uint64_t v99 = v30 + 4 * v31 + 4 * v32 + 16;
        unint64_t v98 = v37 * (unint64_t)v39;
        if (v106) {
          BOOL v42 = v39 == 0;
        }
        else {
          BOOL v42 = 1;
        }
        char v43 = v42;
        uint64_t v44 = 4 * v34;
        unint64_t v45 = 0;
        float32x2_t v46 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v107, 0);
        uint64_t v47 = 4 * v31 + 4 * v32 + v30;
        uint64_t v48 = 4 * v39;
        uint64_t v104 = v47 + 16;
        uint64_t v105 = v44 + 4 * v35 + v33 + 16;
        unint64_t v101 = 4 * v37 * (unint64_t)v39;
        do
        {
          CA::OGL::MetalContext::new_image(v36);
          uint64_t v50 = v49;
          int v51 = *(_DWORD *)(v49 + 52);
          *(unsigned char *)(v49 + 56) = *(unsigned char *)(v49 + 56) & 0xC0 | 0x17;
          *(_WORD *)(v49 + 58) &= 0xFFE7u;
          *(_WORD *)(v49 + 123) &= ~0x10u;
          *(_DWORD *)(v49 + 48) = -1098907648;
          *(_DWORD *)(v49 + 52) = v51 & 0xC000FFFF | 0x110000;
          id v52 = objc_alloc_init(MEMORY[0x1E4F35330]);
          [v52 setTextureType:7];
          [v52 setWidth:HIDWORD(v110[0])];
          [v52 setHeight:LODWORD(v110[0])];
          [v52 setDepth:HIDWORD(v109)];
          [v52 setPixelFormat:555];
          [v52 setUsage:1];
          *(void *)(v50 + 88) = v52;
          *(void *)(v50 + 64) = [*((id *)v102 + 369) newTextureWithDescriptor:v52];
          uint64_t v36 = (CA::OGL::MetalContext *)[*(id *)(v50 + 64) setLabel:objc_msgSend(NSString, "stringWithFormat:", @"com.apple.coreanimation.od-texture-%zu", v45)];
          unint64_t v103 = v45;
          if (HIDWORD(v109))
          {
            unint64_t v53 = 0;
            uint64_t v54 = v104;
            unint64_t v55 = v99 + 4 * v98 * v103;
            uint64_t v56 = v105;
            do
            {
              if (v106) {
                unint64_t v57 = v41;
              }
              else {
                unint64_t v57 = (CA::OGL::MetalContext *)(v55 + 4 * v53 * v39);
              }
              if ((v43 & 1) == 0)
              {
                uint64_t v58 = 0;
                do
                {
                  unsigned int v59 = *(_DWORD *)(v54 + v58);
                  unsigned int v60 = *(_DWORD *)(v56 + v58);
                  if (v59 != v60)
                  {
                    float32x2_t v61 = vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v59), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003));
                    uint32x2_t v62 = vshl_u32(vcvt_u32_f32(vmla_f32(v61, v46, vsub_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v60), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003)), v61))), (uint32x2_t)0x140000000ALL);
                    unsigned int v59 = v62.i32[0] | (float)((float)(*(_DWORD *)(v54 + v58) & 0x3FF)
                                                           + (float)((float)((float)(*(_DWORD *)(v56 + v58) & 0x3FF)
                                                                           - (float)(*(_DWORD *)(v54 + v58) & 0x3FF))
                                                                   * *(float *)&v107)) | v62.i32[1] | 0xC0000000;
                  }
                  *(_DWORD *)((char *)v41 + v58) = v59;
                  v58 += 4;
                }
                while (v48 != v58);
                unint64_t v57 = v41;
              }
              int v63 = *(void **)(v50 + 64);
              v108[0] = 0;
              v108[1] = 0;
              v108[2] = v53;
              v108[3] = HIDWORD(v110[0]);
              v108[4] = LODWORD(v110[0]);
              v108[5] = 1;
              uint64_t v36 = (CA::OGL::MetalContext *)[v63 replaceRegion:v108 mipmapLevel:0 withBytes:v57 bytesPerRow:(4 * HIDWORD(v110[0]))];
              ++v53;
              v56 += v48;
              v54 += v48;
            }
            while (v53 < HIDWORD(v109));
          }
          *(unsigned char *)(v50 + 122) = 1;
          *(_WORD *)(v50 + 123) = *(_WORD *)(v50 + 123) & 0xFFF0 | 2;
          unint64_t v64 = v103;
          *(void *)(*((void *)v102 + 359) + 8 * v103) = v50;
          unint64_t v45 = v64 + 1;
          v105 += v101;
          v104 += v101;
        }
        while (v45 < v109);
        goto LABEL_41;
      }
    }
    id v106 = 0;
    if (!v20) {
      goto LABEL_44;
    }
    goto LABEL_13;
  }
LABEL_45:
  uint64_t v65 = **((void **)v18 + 359);
  unsigned int v66 = *(void **)(v65 + 88);
  uint64_t v67 = v100;
  if (v66)
  {
    int v68 = [v66 width];
    double v69 = v97;
    *double v97 = v68;
    v69[1] = [*(id *)(v65 + 88) height];
    v69[2] = [*(id *)(v65 + 88) depth];
    unint64_t v19 = *((void *)v18 + 358);
  }
  float *v11 = 0.0;
  *uint64_t v67 = 0.0;
  if (v19 < 2)
  {
    unint64_t v73 = 0;
    unint64_t v70 = 0;
  }
  else
  {
    unint64_t v70 = 0;
    uint64_t v71 = *((void *)v18 + 360);
    while (1)
    {
      float v72 = *(float *)(v71 + 4 * v70);
      if (v72 > a5) {
        break;
      }
      if (v19 == ++v70) {
        goto LABEL_54;
      }
    }
    if (v70 == v19)
    {
LABEL_54:
      unint64_t v73 = v19 - 1;
      float v74 = 1.0;
      unint64_t v70 = v73;
LABEL_55:
      *uint64_t v67 = v74;
      goto LABEL_56;
    }
    if (v70)
    {
      unint64_t v73 = v70 - 1;
      float v74 = (float)(a5 - *(float *)(v71 + 4 * (v70 - 1))) / (float)(v72 - *(float *)(v71 + 4 * (v70 - 1)));
      goto LABEL_55;
    }
    unint64_t v73 = 0;
  }
LABEL_56:
  unint64_t v75 = *((void *)v18 + 361);
  if (v75 >= 2)
  {
    uint64_t v76 = 0;
    uint64_t v77 = *((void *)v18 + 362);
    while (1)
    {
      float v78 = *(float *)(v77 + 4 * v76);
      if (v78 > a4) {
        break;
      }
      if (v75 == ++v76)
      {
        float v79 = 1.0;
        goto LABEL_64;
      }
    }
    float v79 = 1.0;
    if (v76 != v75)
    {
      if (!v76) {
        goto LABEL_65;
      }
      float v79 = (float)((float)((float)(unint64_t)(v76 - 1) + 0.5)
                  + (float)((float)(a4 - *(float *)(v77 + 4 * (v76 - 1)))
                          / (float)(v78 - *(float *)(v77 + 4 * (v76 - 1)))))
          / (float)v75;
    }
LABEL_64:
    float *v11 = v79;
  }
LABEL_65:
  uint64_t v80 = *((void *)v18 + 359);
  uint64_t v81 = *(void *)(v80 + 8 * v73);
  uint64_t v82 = *((void *)v18 + 2);
  *(_WORD *)(v82 + 144 + 2 * a2) = 0;
  *(void *)(v82 + 176 + 8 * a2) = v81;
  uint64_t v83 = *(void *)(v80 + 8 * v70);
  *(_WORD *)(v82 + 144 + 2 * a3) = 0;
  *(void *)(v82 + 176 + 8 * a3) = v83;
  *(_OWORD *)(v82 + 96 + 16 * a2) = xmmword_184997ED0;
  *(_OWORD *)(v82 + 96 + 16 * a3) = xmmword_184997ED0;
}

void sub_1848BE2D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CA::OGL::overdrive_texture_data(CA::OGL *this, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)[MEMORY[0x1E4F28B50] bundleForClass:objc_opt_class()];
  uint64_t v5 = objc_msgSend(NSString, "stringWithFormat:", @"odt_%d_%d", this, a2);
  uint64_t v6 = [v4 pathForResource:v5 ofType:@"dat"];
  if (!v6)
  {
    if (x_log_hook_p())
    {
      [v5 UTF8String];
      x_log_();
    }
    else
    {
      float32x4_t v13 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 136315138;
        uint64_t v15 = [v5 UTF8String];
        _os_log_impl(&dword_184668000, v13, OS_LOG_TYPE_ERROR, "LUT file \"%s.dat\" not found!\n", buf, 0xCu);
      }
    }
    return 0;
  }
  int32x2_t v7 = (void *)[MEMORY[0x1E4F1C9B8] dataWithContentsOfFile:v6 options:1 error:0];
  float v8 = (const uint8_t *)[v7 bytes];
  size_t v9 = [v7 length];
  float v10 = malloc_type_malloc(0x140034uLL, 0x917E8D12uLL);
  if (compression_decode_buffer((uint8_t *)v10, 0x140034uLL, v8, v9, 0, COMPRESSION_LZFSE) != 1310772)
  {
    free(v10);
    return 0;
  }
  float v11 = (void *)MEMORY[0x1E4F1C9B8];

  return [v11 dataWithBytesNoCopy:v10 length:1310772];
}

uint64_t CA::OGL::MetalContext::pop_group_marker(id *this)
{
  return [this[373] popDebugGroup];
}

uint64_t CA::OGL::MetalContext::push_group_marker(CA::OGL::MetalContext *this, const char *a2)
{
  uint64_t v2 = (void *)*((void *)this + 373);
  uint64_t v3 = [NSString stringWithUTF8String:a2];

  return [v2 pushDebugGroup:v3];
}

uint64_t CA::OGL::MetalContext::insert_event_marker(CA::OGL::MetalContext *this, const char *a2)
{
  uint64_t v2 = (void *)*((void *)this + 373);
  uint64_t v3 = [NSString stringWithUTF8String:a2];

  return [v2 insertDebugSignpost:v3];
}

void CA::OGL::MetalContext::draw_apl_dimming_factor(CA::OGL::Context *a1, unsigned int a2, char *a3, uint64_t a4)
{
  if (*(unsigned char *)(*((void *)a1 + 2) + 16) != 100) {
    __assert_rtn("draw_apl_dimming_factor", "ogl-metal.mm", 8375, "get_texture_function () == OGL_TEX_APL_DIMMING");
  }
  CA::OGL::MetalContext::draw(a1, 4, a2, 1u, a3, 0x30uLL, 0x10u, 0, a2, 0, 0, a4);
}

void CA::OGL::MetalContext::draw_image_rects(CA::OGL::Context *a1, unsigned int a2, char *a3)
{
  if (*(unsigned char *)(*((void *)a1 + 2) + 16) != 94) {
    __assert_rtn("draw_image_rects", "ogl-metal.mm", 8366, "get_texture_function () == OGL_TEX_IMAGE_RECT_BLIT");
  }
  CA::OGL::MetalContext::draw(a1, 4, 4u, a2, a3, 0x28uLL, 8u, 0, a2, 0, 0, 0);
}

void CA::OGL::MetalContext::draw_buffer_image_rects(CA::OGL::Context *a1, unsigned int a2, char *a3, uint64_t a4)
{
  if (*(unsigned char *)(*((void *)a1 + 2) + 16) != 93) {
    __assert_rtn("draw_buffer_image_rects", "ogl-metal.mm", 8357, "get_texture_function () == OGL_TEX_BUFFER_IMAGE_BLIT");
  }
  CA::OGL::MetalContext::draw(a1, 4, 4u, a2, a3, 0, 0, 0, a2, 0, 0, a4);
}

void CA::OGL::MetalContext::draw_path_joins(CA::OGL::Context *a1, unsigned int a2, char *a3)
{
  if ((*(unsigned char *)(*((void *)a1 + 2) + 16) & 0xFE) != 0x58) {
    __assert_rtn("draw_path_joins", "ogl-metal.mm", 8338, "get_texture_function () == OGL_TEX_PATH_STROKE_MITER_JOIN || get_texture_function () == OGL_TEX_PATH_STROKE_ROUND_JOIN");
  }
  CA::OGL::MetalContext::draw(a1, 4, 4u, a2, a3, 0x18uLL, 8u, 0, a2, 0, 0, 0);
}

void CA::OGL::MetalContext::draw_path_curves(CA::OGL::Context *a1, int a2, int a3, char *a4)
{
  if (*(unsigned char *)(*((void *)a1 + 2) + 16) != 87) {
    __assert_rtn("draw_path_curves", "ogl-metal.mm", 8322, "get_texture_function () == OGL_TEX_PATH_STROKE_CURVE");
  }
  CA::OGL::MetalContext::draw(a1, 4, 4u, a3 + 32 * a2, a4, 8uLL, 8u, 0, 2 * a3 + 4 * a2, 0, 0, 0);
}

void CA::OGL::MetalContext::draw_path_lines(CA::OGL::Context *a1, int a2, char *a3)
{
  if (*(unsigned char *)(*((void *)a1 + 2) + 16) != 86) {
    __assert_rtn("draw_path_lines", "ogl-metal.mm", 8313, "get_texture_function () == OGL_TEX_PATH_STROKE_LINE");
  }
  CA::OGL::MetalContext::draw(a1, 4, 4u, a2 - 1, a3, 8uLL, 8u, 0, a2, 0, 0, 0);
}

void CA::OGL::MetalContext::draw_path_rects(CA::OGL::Context *a1, unsigned int a2, char *a3)
{
  if (*(unsigned char *)(*((void *)a1 + 2) + 16) != 85) {
    __assert_rtn("draw_path_rects", "ogl-metal.mm", 8305, "get_texture_function () == OGL_TEX_PATH_RECT");
  }
  CA::OGL::MetalContext::draw(a1, 4, 4u, a2, a3, 0x14uLL, 4u, 0, a2, 0, 0, 0);
}

void CA::OGL::MetalContext::draw_path_cubics(CA::OGL::Context *a1, int a2, char *a3)
{
  int v3 = *(unsigned __int8 *)(*((void *)a1 + 2) + 16);
  if ((v3 - 85) <= 0xFFFFFFFD) {
    __assert_rtn("draw_path_cubics", "ogl-metal.mm", 8295, "get_texture_function () == OGL_TEX_PATH_CUBIC_0 || get_texture_function () == OGL_TEX_PATH_CUBIC_1");
  }
  if (v3 == 83) {
    char v4 = 1;
  }
  else {
    char v4 = 3;
  }
  CA::OGL::MetalContext::draw(a1, 4, 4u, a2 << v4, a3, 0x28uLL, 8u, 0, a2, 0, 0, 0);
}

void CA::OGL::MetalContext::stroke_lines(CA::OGL::Context *a1, unsigned int a2, char *a3)
{
  if (*(unsigned char *)(*((void *)a1 + 2) + 16) != 81) {
    __assert_rtn("stroke_lines", "ogl-metal.mm", 8286, "get_texture_function () == OGL_TEX_STROKE_LINE");
  }
  CA::OGL::MetalContext::draw(a1, 4, 4u, a2 >> 1, a3, 8uLL, 8u, 0, a2, 0, 0, 0);
}

void CA::OGL::MetalContext::draw_points(CA::OGL::Context *a1, int a2, unsigned int a3, char *a4)
{
  if (*(unsigned __int8 *)(*((void *)a1 + 2) + 16) - 83 <= 9) {
    __assert_rtn("draw_points", "ogl-metal.mm", 8278, "get_texture_function() < OGL_TEX_PATH_FIRST || get_texture_function() > OGL_TEX_PATH_LAST");
  }
  CA::OGL::MetalContext::draw(a1, 0, a3, 1u, a4, 0x10uLL, 4u, a2, a3, 0, 0, 0);
}

void CA::OGL::MetalContext::draw_elements(CA::OGL::Context *a1, int a2, unsigned int a3, unsigned __int16 *a4, char *a5, int a6, int a7)
{
}

uint64_t CA::OGL::MetalContext::purge_shaders(CA::OGL::MetalContext *this)
{
  if (*((void *)this + 342))
  {
    for (uint64_t i = 0; i != 2048; i += 8)

    free(*((void **)this + 342));
    *((void *)this + 342) = 0;
  }
  CA::OGL::MetalContext::stop_pipeline_queue(this);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1904));
  for (uint64_t j = (void *)*((void *)this + 235); j; uint64_t j = (void *)*j)
  {
    char v4 = (id *)j[5];
    if (v4)
    {

      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v4);
    }
  }
  if (*((void *)this + 236))
  {
    uint64_t v6 = (void *)*((void *)this + 235);
    if (v6)
    {
      do
      {
        int32x2_t v7 = (void *)*v6;
        operator delete(v6);
        uint64_t v6 = v7;
      }
      while (v7);
    }
    *((void *)this + 235) = 0;
    uint64_t v8 = *((void *)this + 234);
    if (v8)
    {
      for (uint64_t k = 0; k != v8; ++k)
        *(void *)(*((void *)this + 233) + 8 * k) = 0;
    }
    *((void *)this + 236) = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 1904));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 2016));
  for (uint64_t m = (void *)*((void *)this + 249); m; uint64_t m = (void *)*m)
  {
    float v11 = (id *)m[3];
    if (v11)
    {

      uint64_t v12 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v12, v11);
    }
  }
  if (*((void *)this + 250))
  {
    float32x4_t v13 = (void *)*((void *)this + 249);
    if (v13)
    {
      do
      {
        uint32_t v14 = (void *)*v13;
        operator delete(v13);
        float32x4_t v13 = v14;
      }
      while (v14);
    }
    *((void *)this + 249) = 0;
    uint64_t v15 = *((void *)this + 248);
    if (v15)
    {
      for (uint64_t n = 0; n != v15; ++n)
        *(void *)(*((void *)this + 247) + 8 * n) = 0;
    }
    *((void *)this + 250) = 0;
  }

  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 2016));
}

void CA::OGL::MetalContext::stop_pipeline_queue(CA::OGL::MetalContext *this)
{
  uint64_t v2 = (unsigned __int8 *)this + 2152;
  atomic_store(1u, (unsigned __int8 *)this + 2152);
  dispatch_barrier_sync(*((dispatch_queue_t *)this + 268), &__block_literal_global_72);
  atomic_store(0, v2);
  for (uint64_t i = (void *)*((void *)this + 263); i; uint64_t i = (void *)*i)
  {
    char v4 = (unint64_t *)i[6];
    if (v4)
    {
      uint64_t v5 = (void *)atomic_load(v4);

      uint64_t v6 = (const void *)v4[1];
      if (v6) {
        _Block_release(v6);
      }
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v4);
    }
  }
  if (*((void *)this + 264))
  {
    uint64_t v8 = (void *)*((void *)this + 263);
    if (v8)
    {
      do
      {
        size_t v9 = (void *)*v8;
        operator delete(v8);
        uint64_t v8 = v9;
      }
      while (v9);
    }
    *((void *)this + 263) = 0;
    uint64_t v10 = *((void *)this + 262);
    if (v10)
    {
      for (uint64_t j = 0; j != v10; ++j)
        *(void *)(*((void *)this + 261) + 8 * j) = 0;
    }
    *((void *)this + 264) = 0;
  }
  *((_DWORD *)this + 532) = 0;
}

unint64_t CA::OGL::MetalContext::subimage_max_rowbytes(CA::OGL::MetalContext *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if ((*((unsigned char *)this + 2726) & 0x20) == 0) {
    return *((void *)this + 339);
  }
  if (a2 == -1) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = a2;
  }
  unint64_t result = CA::Render::format_rowbytes((CA::Render *)v7, a3);
  if (result)
  {
    unint64_t v8 = result + 16;
    if (a4 >= 0x100) {
      unint64_t v8 = result;
    }
    if (a4 <= 0x7F) {
      unint64_t v8 = result + 32;
    }
    if (a4 <= 0x3F) {
      unint64_t v8 = result + 64;
    }
    unint64_t v9 = *((void *)this + 339);
    if (v8 <= v9 || v9 == 0) {
      return v8;
    }
    else {
      return *((void *)this + 339);
    }
  }
  return result;
}

void CA::OGL::MetalContext::warmup_shaders(CA::OGL::MetalContext *this)
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v2 = os_signpost_id_generate((os_log_t)x_log_category_ogl_metal);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    int v3 = x_log_category_ogl_metal;
    if (os_signpost_enabled((os_log_t)x_log_category_ogl_metal))
    {
      LOWORD(buf[0]) = 0;
      _os_signpost_emit_with_name_impl(&dword_184668000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "WarmupShaders", (const char *)&unk_1849E4FC6, (uint8_t *)buf, 2u);
    }
  }
  uint64_t v4 = mach_absolute_time();
  double v5 = CATimeWithHostTime(v4);
  long long v94 = 0u;
  long long v95 = 0u;
  *(_OWORD *)uint64_t buf = 0u;
  long long v93 = 0u;
  if (CADeviceUseCIF10::once != -1) {
    dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_12019);
  }
  int v6 = CADeviceUseCIF10::enable_cif10;
  if (CADeviceUseCIF10::enable_cif10)
  {
    if (CADeviceUseCompression::once[0] != -1) {
      dispatch_once(CADeviceUseCompression::once, &__block_literal_global_21);
    }
    if (CADeviceUseCompression::enable_compression)
    {
      buf[0] = 552;
      unsigned int v7 = 1;
    }
    else
    {
      unsigned int v7 = 0;
    }
    int v8 = v7 + 1;
    *(void *)((unint64_t)buf | (8 * v7)) = 115;
    if (CADeviceIsVirtualized::once != -1) {
      dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
    }
    if (!CADeviceIsVirtualized::is_virtualized)
    {
      buf[v8] = 550;
      int v8 = v7 | 2;
    }
    int v6 = v8 + 1;
    buf[v8] = 554;
  }
  int v9 = v6 + 1;
  buf[v6] = 80;
  os_signpost_id_t v56 = v2;
  if ((*((unsigned char *)this + 2725) & 4) != 0)
  {
    buf[v9] = 43;
    int v9 = v6 + 2;
  }
  uint64_t v59 = (v9 + 2);
  *(_OWORD *)&buf[v9] = xmmword_184998370;
  unint64_t v57 = (void *)MEMORY[0x185324A30]();
  uint64_t v10 = objc_msgSend((id)objc_msgSend(*((id *)this + 369), "newCommandQueue"), "commandBuffer");
  float v11 = (void *)[MEMORY[0x1E4F352E0] renderPassDescriptor];
  [v11 setFineGrainedBackgroundVisibilityEnabled:1];
  id v58 = (id)[*((id *)this + 369) newBufferWithLength:1024 options:0];
  uint64_t v12 = 0;
  int64x2_t v69 = vdupq_n_s64(8uLL);
  int64x2_t v66 = vdupq_n_s64(0x20uLL);
  unsigned int v60 = this;
  do
  {
    context = (void *)MEMORY[0x185324A30]();
    uint64_t v65 = v12;
    MTLPixelFormat v83 = buf[v12];
    BOOL v82 = 0;
    int can_generate_mipmaps_for_format = CA::OGL::MetalContext::can_generate_mipmaps_for_format(this, &v83, &v82);
    MTLPixelFormat v14 = v83;
    int v63 = can_generate_mipmaps_for_format;
    uint64_t v15 = objc_msgSend(MEMORY[0x1E4F35330], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", v83, 776, 24);
    [v15 setUsage:5];
    [v15 setStorageMode:2];
    id v16 = (id)[*((id *)this + 369) newTextureWithDescriptor:v15];
    [v15 setAllowGPUOptimizedContents:0];
    id v61 = (id)[*((id *)this + 369) newTextureWithDescriptor:v15];
    [v15 setAllowGPUOptimizedContents:1];
    id v62 = v16;
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setTexture:", v16);
    if ((*((_WORD *)this + 1664) & 8) != 0)
    {
      char v37 = 1;
      while (1)
      {
        char v38 = v37;
        if ((uint64_t)v14 <= (uint64_t)(MTLPixelFormatBGRA8Unorm_sRGB|0x8)) {
          break;
        }
        uint64_t v39 = 110;
        if (v14 != MTLPixelFormatRGB10A2Unorm && v14 != MTLPixelFormatBGR10A2Unorm)
        {
          if (v14 != MTLPixelFormatBGR10_XR) {
            goto LABEL_60;
          }
          if (CADeviceIsVirtualized::once != -1) {
            dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
          }
          if (CADeviceIsVirtualized::is_virtualized) {
            uint64_t v39 = 115;
          }
          else {
            uint64_t v39 = 550;
          }
        }
LABEL_61:
        uint64_t v40 = CA::OGL::non_srgb_pixel_format(v39, v17);
        if (v38)
        {
          uint64_t v41 = 0;
        }
        else
        {
          uint64_t v41 = 2;
          if (v40 != 125 && v40 != 115) {
            goto LABEL_21;
          }
        }
        [v15 setPixelFormat:v40];
        [v15 setStorageMode:3];
        objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", 1), "setTexture:", (id)objc_msgSend(*((id *)this + 369), "newTextureWithDescriptor:", v15));
        objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", 1), "setLoadAction:", v41);
        uint64_t v42 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", 1), "setStoreAction:", 0);
        for (uint64_t i = 0; i != 3; ++i)
        {
          uint64_t v44 = qword_18499B4F0[i];
          unint64_t v45 = (void *)MEMORY[0x185324A30](v42);
          objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setLoadAction:", v44);
          objc_msgSend((id)objc_msgSend(v10, "renderCommandEncoderWithDescriptor:", v11), "endEncoding");
        }
        char v37 = 0;
        if ((v38 & 1) == 0) {
          goto LABEL_21;
        }
      }
      switch(v14)
      {
        case MTLPixelFormatR8Unorm:
          uint64_t v39 = 30;
          goto LABEL_61;
        case MTLPixelFormatBGR5A1Unorm:
          uint64_t v39 = 80;
          goto LABEL_61;
        case MTLPixelFormatRG16Uint:
          uint64_t v39 = 113;
          goto LABEL_61;
      }
LABEL_60:
      uint64_t v39 = v14;
      goto LABEL_61;
    }
LABEL_21:
    if ((*((unsigned char *)this + 2726) & 0x40) != 0)
    {
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setLoadAction:", 1);
      float32x4_t v18 = (void *)[v10 renderCommandEncoderWithDescriptor:v11];
      [v15 setUsage:7];
      [v15 setStorageMode:2];
      id v67 = (id)[*((id *)this + 369) newTextureWithDescriptor:v15];
      uint64_t v68 = v14;
      uint64_t v19 = 0;
      int8x16_t v20 = this;
      do
      {
        unsigned int v21 = byte_18499B508[v19];
        unint64_t v22 = *((unsigned __int8 *)&CA::OGL::MetalContext::tile_shader_type_info
              + 16 * byte_18499B508[v19]
              + 8);
        LODWORD(v90) = 0;
        unint64_t v23 = [v18 tileWidth] / v22;
        unint64_t v24 = [v18 tileHeight];
        LOWORD(v79) = COERCE_UNSIGNED_INT(1.0);
        unint64_t v25 = v24 / v22;
        objc_msgSend(v18, "setRenderPipelineState:", CA::OGL::MetalContext::get_tile_pipeline((uint64_t)v20, v21, v68));
        [v18 setTileTexture:v67 atIndex:0];
        [v18 setTileBytes:&v90 length:4 atIndex:9];
        [v18 setTileBytes:&v79 length:2 atIndex:6];
        v81[0] = v23;
        v81[1] = v25;
        v81[2] = 1;
        [v18 dispatchThreadsPerTile:v81];
        ++v19;
      }
      while (v19 != 3);
      int v26 = *((_DWORD *)v20 + 681);
      MTLPixelFormat v14 = v68;
      if ((v26 & 0x1000000) != 0)
      {
        for (uint64_t j = 0; j != 7; ++j)
        {
          unsigned int v28 = byte_18499B50B[j];
          int v80 = 0;
          uint64_t v79 = 0;
          objc_msgSend(v18, "setRenderPipelineState:", CA::OGL::MetalContext::get_tile_pipeline((uint64_t)v60, v28, v68));
          [v18 setTileTexture:v67 atIndex:0];
          [v18 setTileBytes:&v79 length:12 atIndex:0];
          [v18 setTileBytes:&v90 length:54 atIndex:1];
          int64x2_t v77 = v66;
          uint64_t v78 = 1;
          [v18 dispatchThreadsPerTile:&v77];
        }
        int v26 = *((_DWORD *)v60 + 681);
      }
      if ((v26 & 0x2000000) != 0)
      {
        uint64_t tile_pipeline = CA::OGL::MetalContext::get_tile_pipeline((uint64_t)v60, 0xBu, v68);
        unint64_t v30 = (unint64_t)[v18 tileWidth] >> 1;
        unint64_t v31 = (unint64_t)[v18 tileHeight] >> 1;
        *(void *)&long long v90 = 2097184;
        [v18 setRenderPipelineState:tile_pipeline];
        [v18 setTileBuffer:v58 offset:0 atIndex:2];
        [v18 setTileBytes:&v90 length:8 atIndex:0];
        v76[0] = v30;
        v76[1] = v31;
        v76[2] = 1;
        [v18 dispatchThreadsPerTile:v76];
      }
      [v18 endEncoding];
    }
    uint64_t v32 = (void *)[v10 blitCommandEncoder];
    int64x2_t v33 = v69;
    if (v14 != 550)
    {
      for (int k = 0; k != 4; ++k)
      {
        if (k) {
          id v35 = v61;
        }
        else {
          id v35 = v62;
        }
        memset(v75, 0, sizeof(v75));
        int64x2_t v73 = v33;
        uint64_t v74 = 1;
        if ((k & 2) != 0) {
          id v36 = v61;
        }
        else {
          id v36 = v62;
        }
        int64x2_t v71 = v33;
        uint64_t v72 = 0;
        [v32 copyFromTexture:v35 sourceSlice:0 sourceLevel:0 sourceOrigin:v75 sourceSize:&v73 toTexture:v36 destinationSlice:0 destinationLevel:0 destinationOrigin:&v71];
        int64x2_t v33 = v69;
      }
    }
    if (v63) {
      objc_msgSend(v32, "generateMipmapsForTexture:", v62, *(double *)v33.i64);
    }
    objc_msgSend(v32, "endEncoding", *(double *)v33.i64);
    uint64_t v12 = v65 + 1;
    this = v60;
  }
  while (v65 + 1 != v59);
  float32x2_t v46 = &qword_1E52743D8;
  uint64_t v47 = 23040;
  do
  {
    if ((!*((unsigned char *)v46 - 8) || [*((id *)v60 + 369) supportsFamily:*v46])
      && (!*((unsigned char *)v46 + 8) || ([*((id *)v60 + 369) supportsFamily:v46[2]] & 1) == 0))
    {
      long long v90 = 0u;
      long long v91 = 0u;
      CA::OGL::MetalContext::Pipeline::Spec::decode_name((CA::OGL::MetalContext::Pipeline::Spec *)&v90, (char *)*(v46 - 2));
      if (((WORD4(v91) | (BYTE10(v91) << 16)) & 0x20000) == 0)
      {
        if ((BYTE1(v91) & 4) != 0)
        {
          if (byte_1EB2ACC26) {
            goto LABEL_82;
          }
        }
        else if ((CA::OGL::MetalContext::texture_function_info[8 * (BYTE14(v90) & 0x7F) - (BYTE14(v90) & 0x7F)] & 0x3F) == 0)
        {
          goto LABEL_82;
        }
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        uint64_t v49 = (CA::OGL::MetalContext::Pipeline *)malloc_type_zone_malloc(malloc_zone, 0x20uLL, 0x8BB15036uLL);
        uint64_t v50 = v49;
        if (v49)
        {
          *((_WORD *)v49 + 12) = 0;
          *(void *)uint64_t v49 = 0;
          *((void *)v49 + 1) = 0;
          *((void *)v49 + 2) = 0;
          *((unsigned char *)v49 + 26) = 1;
          *((unsigned char *)v49 + 24) = 1;
          int v51 = v60;
          id v52 = (dispatch_queue_t *)v60;
          unint64_t v53 = v50;
        }
        else
        {
          MEMORY[0x18] = 1;
          int v51 = v60;
          id v52 = (dispatch_queue_t *)v60;
          unint64_t v53 = 0;
        }
        CA::OGL::MetalContext::dispatch_async_pipeline(v52, (const CA::OGL::MetalContext::Pipeline::Spec *)&v90, v53, 1, 0);
        std::__hash_table<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::__unordered_map_hasher<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::__unordered_map_equal<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::allocator<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>>>::__emplace_unique_key_args<CA::OGL::MetalContext::Pipeline::Spec,std::piecewise_construct_t const&,std::tuple<CA::OGL::MetalContext::Pipeline::Spec const&>,std::tuple<>>((float *)v60 + 522, &v90, &v90)[6] = v50;
        uint64_t v54 = *((void *)v51 + 267);
        *((void *)v51 + 267) = v54 + 1;
        *((void *)v50 + 2) = v54;
        *((unsigned char *)v50 + 25) = (BYTE1(v91) & 4) == 0;
        ++*((_DWORD *)v51 + 532);
      }
    }
LABEL_82:
    v46 += 5;
    v47 -= 40;
  }
  while (v47);
  if (CADeviceHasHardwareAcceleratedHDR::once[0] != -1) {
    dispatch_once(CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_132);
  }
  if (!CADeviceHasHardwareAcceleratedHDR::has_capability)
  {
    unint64_t v55 = *((void *)v60 + 268);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___ZN2CA3OGL12MetalContext14warmup_shadersEb_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = v60;
    dispatch_async(v55, block);
  }
  v84[0] = MEMORY[0x1E4F143A8];
  v84[1] = 3221225472;
  v84[2] = ___ZN2CA3OGL12MetalContext14warmup_shadersEb_block_invoke_2;
  v84[3] = &__block_descriptor_124_e5_v8__0l;
  v84[4] = v60;
  v84[5] = v56;
  *(double *)&v84[6] = v5;
  int v89 = v59;
  long long v85 = *(_OWORD *)buf;
  long long v86 = v93;
  long long v87 = v94;
  long long v88 = v95;
  dispatch_barrier_sync(*((dispatch_queue_t *)v60 + 268), v84);
}

void ___ZN2CA3OGL12MetalContext14warmup_shadersEb_block_invoke(uint64_t a1)
{
  v4[5] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 2152));
  if ((v2 & 1) == 0)
  {
    uint64_t v3 = *(void *)(v1 + 2952);
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 3221225472;
    unint64_t v4[2] = ___ZN2CA14CAHDRProcessor14warmup_shadersEPv_block_invoke;
    v4[3] = &unk_1E52807A0;
    v4[4] = v3;
    if (CA::CAHDRProcessor::warmup_shaders(void *)::once[0] != -1) {
      dispatch_once(CA::CAHDRProcessor::warmup_shaders(void *)::once, v4);
    }
  }
}

void ___ZN2CA3OGL12MetalContext14warmup_shadersEb_block_invoke_2(uint64_t a1)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v2 = *(void *)(a1 + 40);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = x_log_category_ogl_metal;
    if (os_signpost_enabled((os_log_t)x_log_category_ogl_metal))
    {
      unsigned __int8 v5 = atomic_load((unsigned __int8 *)(v3 + 2152));
      *(_DWORD *)uint64_t buf = 67240192;
      LODWORD(v35) = v5 & 1;
      _os_signpost_emit_with_name_impl(&dword_184668000, v4, OS_SIGNPOST_INTERVAL_END, v2, "WarmupShaders", "cancelled=%{public, name=cancelled}u", buf, 8u);
    }
  }
  uint64_t v6 = mach_absolute_time();
  double v7 = CATimeWithHostTime(v6);
  if (!x_log_hook_p())
  {
    MTLPixelFormat v14 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_INFO)) {
      return;
    }
    double v15 = v7 - *(double *)(a1 + 48);
    if (*(int *)(a1 + 120) < 1)
    {
      unint64_t v30 = "N/A";
      unint64_t v24 = "N/A";
      float32x4_t v18 = "N/A";
    }
    else
    {
      Name = (const char *)MTLPixelFormatGetName();
      if (!strncmp(Name, "MTLPixelFormat", 0xEuLL)) {
        uint64_t v17 = 14;
      }
      else {
        uint64_t v17 = 0;
      }
      float32x4_t v18 = &Name[v17];
      if (*(int *)(a1 + 120) >= 2)
      {
        uint64_t v19 = (const char *)MTLPixelFormatGetName();
        if (!strncmp(v19, "MTLPixelFormat", 0xEuLL)) {
          uint64_t v20 = 14;
        }
        else {
          uint64_t v20 = 0;
        }
        unsigned int v21 = &v19[v20];
        if (*(int *)(a1 + 120) < 3)
        {
          unint64_t v30 = "N/A";
          unint64_t v24 = "N/A";
        }
        else
        {
          unint64_t v22 = (const char *)MTLPixelFormatGetName();
          if (!strncmp(v22, "MTLPixelFormat", 0xEuLL)) {
            uint64_t v23 = 14;
          }
          else {
            uint64_t v23 = 0;
          }
          unint64_t v24 = &v22[v23];
          if (*(int *)(a1 + 120) >= 4)
          {
            unint64_t v25 = (const char *)MTLPixelFormatGetName();
            if (!strncmp(v25, "MTLPixelFormat", 0xEuLL)) {
              uint64_t v26 = 14;
            }
            else {
              uint64_t v26 = 0;
            }
            uint64_t v27 = &v25[v26];
            if (*(int *)(a1 + 120) >= 5)
            {
              unsigned int v28 = (const char *)MTLPixelFormatGetName();
              if (!strncmp(v28, "MTLPixelFormat", 0xEuLL)) {
                uint64_t v29 = 14;
              }
              else {
                uint64_t v29 = 0;
              }
              unint64_t v30 = &v28[v29];
              if (*(int *)(a1 + 120) < 6)
              {
                int64x2_t v33 = "N/A";
              }
              else
              {
                unint64_t v31 = (const char *)MTLPixelFormatGetName();
                if (!strncmp(v31, "MTLPixelFormat", 0xEuLL)) {
                  uint64_t v32 = 14;
                }
                else {
                  uint64_t v32 = 0;
                }
                int64x2_t v33 = &v31[v32];
              }
              goto LABEL_45;
            }
            unint64_t v30 = "N/A";
LABEL_44:
            int64x2_t v33 = "N/A";
LABEL_45:
            *(_DWORD *)uint64_t buf = 134219522;
            double v35 = v15;
            __int16 v36 = 2080;
            char v37 = v18;
            __int16 v38 = 2080;
            uint64_t v39 = v21;
            __int16 v40 = 2080;
            uint64_t v41 = v24;
            __int16 v42 = 2080;
            char v43 = v27;
            __int16 v44 = 2080;
            unint64_t v45 = v30;
            __int16 v46 = 2080;
            uint64_t v47 = v33;
            _os_log_impl(&dword_184668000, v14, OS_LOG_TYPE_INFO, "Render pipeline warmup took %0.2fs, MTLPixelFormats: {%s, %s, %s, %s, %s, %s}\n", buf, 0x48u);
            return;
          }
          unint64_t v30 = "N/A";
        }
LABEL_43:
        uint64_t v27 = "N/A";
        goto LABEL_44;
      }
      unint64_t v30 = "N/A";
      unint64_t v24 = "N/A";
    }
    unsigned int v21 = "N/A";
    goto LABEL_43;
  }
  if (*(int *)(a1 + 120) >= 1)
  {
    int v8 = (const char *)MTLPixelFormatGetName();
    strncmp(v8, "MTLPixelFormat", 0xEuLL);
    if (*(int *)(a1 + 120) >= 2)
    {
      int v9 = (const char *)MTLPixelFormatGetName();
      strncmp(v9, "MTLPixelFormat", 0xEuLL);
      if (*(int *)(a1 + 120) >= 3)
      {
        uint64_t v10 = (const char *)MTLPixelFormatGetName();
        strncmp(v10, "MTLPixelFormat", 0xEuLL);
        if (*(int *)(a1 + 120) >= 4)
        {
          float v11 = (const char *)MTLPixelFormatGetName();
          strncmp(v11, "MTLPixelFormat", 0xEuLL);
          if (*(int *)(a1 + 120) >= 5)
          {
            uint64_t v12 = (const char *)MTLPixelFormatGetName();
            strncmp(v12, "MTLPixelFormat", 0xEuLL);
            if (*(int *)(a1 + 120) >= 6)
            {
              float32x4_t v13 = (const char *)MTLPixelFormatGetName();
              strncmp(v13, "MTLPixelFormat", 0xEuLL);
            }
          }
        }
      }
    }
  }
  x_log_();
}

BOOL CA::OGL::MetalContext::add_completed_callback(uint64_t a1, uint64_t a2)
{
  v5[5] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void **)(a1 + 2976);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZN2CA3OGL12MetalContext22add_completed_callbackEU13block_pointerFvvE_block_invoke;
  v5[3] = &unk_1E527BE88;
  v5[4] = a2;
  [v3 addCompletedHandler:v5];
  return *(void *)(a1 + 2976) != 0;
}

uint64_t CA::OGL::MetalContext::load_pipeline(id *this, const char *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    float v11 = &qword_1E52743D8;
    uint64_t v12 = 23040;
    while (1)
    {
      float32x4_t v13 = (void *)MEMORY[0x185324A30]();
      if ((!*((unsigned char *)v11 - 8) || [this[369] supportsFamily:*v11])
        && (!*((unsigned char *)v11 + 8) || ([this[369] supportsFamily:v11[2]] & 1) == 0))
      {
        long long v21 = 0u;
        long long v22 = 0u;
        MTLPixelFormat v14 = (char *)*(v11 - 2);
        CA::OGL::MetalContext::Pipeline::Spec::decode_name((CA::OGL::MetalContext::Pipeline::Spec *)&v21, v14);
        if ((BYTE7(v22) & 1) == 0)
        {
          pipeline_state = (void *)CA::OGL::MetalContext::load_pipeline_state((CA::OGL::MetalContext *)this, (NSString *)[NSString stringWithUTF8String:v14]);
          if (!pipeline_state)
          {
            NSLog(&cfstr_FailedToLoadPr.isa, v14);
            return 0;
          }
        }
      }
      v11 += 5;
      v12 -= 40;
      if (!v12) {
        return 1;
      }
    }
  }
  if (CA::OGL::MetalContext::get_offline_compilation_index(void)::index_once[0] != -1) {
    dispatch_once(CA::OGL::MetalContext::get_offline_compilation_index(void)::index_once, &__block_literal_global_2946);
  }
  uint64_t v4 = objc_msgSend((id)CA::OGL::MetalContext::get_offline_compilation_index(void)::index, "objectForKey:", objc_msgSend(NSString, "stringWithUTF8String:", a2));
  if (!v4)
  {
    NSLog(&cfstr_PipelineSDoesN.isa, a2);
    return 0;
  }
  unsigned __int8 v5 = &(&CA::OGL::MetalContext::offline_compilation_manifest)[5 * (int)[v4 intValue]];
  char v6 = *((unsigned char *)v5 + 24);
  double v7 = (__CFString *)v5[4];
  if ((_BYTE)v5[1])
  {
    int v8 = (__CFString *)v5[2];
    if (([this[369] supportsFamily:v8] & 1) == 0)
    {
      uint64_t v20 = CA::OGL::mtl_gpu_family_name(v8, v9);
      NSLog(&cfstr_PipelineSRequi.isa, a2, v20);
      return 0;
    }
  }
  if ((v6 & 1) != 0 && [this[369] supportsFamily:v7])
  {
    uint64_t v19 = CA::OGL::mtl_gpu_family_name(v7, v10);
    NSLog(&cfstr_PipelineSExclu.isa, a2, v19);
    return 0;
  }
  uint64_t v16 = CA::OGL::MetalContext::load_pipeline_state((CA::OGL::MetalContext *)this, (NSString *)[NSString stringWithUTF8String:a2]);
  if (!v16)
  {
    NSLog(&cfstr_FailedToLoadPr.isa, a2);
    return 0;
  }
  uint64_t v17 = (void *)v16;
  NSLog(&cfstr_PipelineSLoade.isa, a2);

  return 1;
}

__CFString *CA::OGL::mtl_gpu_family_name(__CFString *this, MTLGPUFamily a2)
{
  if ((uint64_t)this > 2001)
  {
    if ((uint64_t)this <= 3001)
    {
      if (this == (__CFString *)2002) {
        return @"mac2";
      }
      if (this == (__CFString *)3001) {
        return @"common1";
      }
    }
    else
    {
      if (this == (__CFString *)3002) {
        return @"common2";
      }
      if (this == (__CFString *)3003) {
        return @"common3";
      }
      if (this == (__CFString *)5001) {
        return @"metal3";
      }
    }
    return (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @"unknown:%u", this);
  }
  else
  {
    os_signpost_id_t v2 = (char *)&this[-32].data + 7;
    this = @"apple1";
    switch((unint64_t)v2)
    {
      case 0uLL:
        return this;
      case 1uLL:
        this = @"apple2";
        break;
      case 2uLL:
        this = @"apple3";
        break;
      case 3uLL:
        this = @"apple4";
        break;
      case 4uLL:
        this = @"apple5";
        break;
      case 5uLL:
        this = @"apple6";
        break;
      case 6uLL:
        this = @"apple7";
        break;
      case 7uLL:
        this = @"apple8";
        break;
      case 8uLL:
        this = @"apple9";
        break;
      default:
        return (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @"unknown:%u", this);
    }
  }
  return this;
}

BOOL CA::OGL::MetalContext::compile_shader(void **this, char *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x185324A30]();
  x_set_log_file((FILE *)*MEMORY[0x1E4F143D8]);
  int v5 = *a2;
  if ((v5 - 85) < 2)
  {
    int v24 = 0;
    *(void *)uint64_t buf = a2;
    CA::OGL::MetalContext::decode_segment((unsigned char **)buf, (uint64_t)&v24, byte_1ED033AC0, 7u);
    if (x_log_hook_p())
    {
      [(id)CA::OGL::MetalContext::VertexShader::Spec::encode_segment((CA::OGL::MetalContext::VertexShader::Spec *)&v24) UTF8String];
      x_log_();
    }
    else
    {
      int v8 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = [(id)CA::OGL::MetalContext::VertexShader::Spec::encode_segment((CA::OGL::MetalContext::VertexShader::Spec *)&v24) UTF8String];
        *(_DWORD *)uint64_t buf = 136315138;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl(&dword_184668000, v8, OS_LOG_TYPE_DEFAULT, "Compiling vertex shader: %s\n", buf, 0xCu);
      }
    }
    vertex_shader = (id *)CA::OGL::MetalContext::create_vertex_shader(this, (const CA::OGL::MetalContext::VertexShader::Spec *)&v24, 0);
    if (x_log_hook_p()) {
      goto LABEL_24;
    }
    float v11 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_34;
    }
    *(_DWORD *)uint64_t buf = 134217984;
    *(void *)&uint8_t buf[4] = vertex_shader;
    uint64_t v12 = buf;
    goto LABEL_33;
  }
  if (v5 == 84)
  {
    *(void *)uint64_t buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    *(_DWORD *)&buf[15] = 0;
    CA::OGL::MetalContext::FragmentShader::Spec::decode_name((CA::OGL::MetalContext::FragmentShader::Spec *)buf, a2);
    if (x_log_hook_p())
    {
      [(id)CA::OGL::MetalContext::FragmentShader::Spec::name((CA::OGL::MetalContext::FragmentShader::Spec *)buf) UTF8String];
      x_log_();
    }
    else
    {
      uint64_t v17 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = 136315138;
        uint64_t v25 = [(id)CA::OGL::MetalContext::FragmentShader::Spec::name((CA::OGL::MetalContext::FragmentShader::Spec *)buf) UTF8String];
        _os_log_impl(&dword_184668000, v17, OS_LOG_TYPE_DEFAULT, "Compiling fragment shader: %s\n", (uint8_t *)&v24, 0xCu);
      }
    }
    vertex_shader = (id *)CA::OGL::MetalContext::create_fragment_shader(this, (const CA::OGL::MetalContext::FragmentShader::Spec *)buf, 0);
    if (x_log_hook_p())
    {
LABEL_24:
      x_log_();
      goto LABEL_34;
    }
    float v11 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
    {
LABEL_34:
      if (vertex_shader)
      {

        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, vertex_shader);
      }
      goto LABEL_36;
    }
    int v24 = 134217984;
    uint64_t v25 = (uint64_t)vertex_shader;
    uint64_t v12 = (uint8_t *)&v24;
LABEL_33:
    _os_log_impl(&dword_184668000, v11, OS_LOG_TYPE_DEFAULT, "Resulting function: %p\n", v12, 0xCu);
    goto LABEL_34;
  }
  if (v5 == 80)
  {
    memset(buf, 0, 32);
    CA::OGL::MetalContext::Pipeline::Spec::decode_name((CA::OGL::MetalContext::Pipeline::Spec *)buf, a2);
    if (x_log_hook_p())
    {
      char v6 = NSString;
      uint64_t v7 = CA::OGL::MetalContext::Pipeline::Spec::encode_segment((CA::OGL::MetalContext::Pipeline::Spec *)buf);
      [(id)objc_msgSend(v6 stringWithFormat:@"%@_%@", v7, CA::OGL::MetalContext::FragmentShader::Spec::name((CA::OGL::MetalContext::FragmentShader::Spec *)buf)), "UTF8String"];
      x_log_();
    }
    else
    {
      float32x4_t v13 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
      {
        MTLPixelFormat v14 = NSString;
        uint64_t v15 = CA::OGL::MetalContext::Pipeline::Spec::encode_segment((CA::OGL::MetalContext::Pipeline::Spec *)buf);
        int v24 = 136315138;
        uint64_t v25 = [(id)objc_msgSend(v14 stringWithFormat:@"%@_%@", v15, CA::OGL::MetalContext::FragmentShader::Spec::name((CA::OGL::MetalContext::FragmentShader::Spec *)buf)), "UTF8String"];
        _os_log_impl(&dword_184668000, v13, OS_LOG_TYPE_DEFAULT, "Compiling render pipeline: %s\n", (uint8_t *)&v24, 0xCu);
      }
    }
    unsigned int v23 = 32;
    vertex_shader = (id *)CA::OGL::MetalContext::create_pipeline_state((uint64_t)this, (CA::OGL::MetalContext::Pipeline::Spec *)buf, &v23, 0);
    *(void *)__str = 0;
    CA::OGL::MetalContext::format_new_pipeline_flags_string((CA::OGL::MetalContext *)v23, __str, v16);
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v20 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = 134218242;
        uint64_t v25 = (uint64_t)vertex_shader;
        __int16 v26 = 2080;
        uint64_t v27 = __str;
        _os_log_impl(&dword_184668000, v20, OS_LOG_TYPE_DEFAULT, "Resulting pipeline state: %p (flags=%s)\n", (uint8_t *)&v24, 0x16u);
      }
    }

LABEL_36:
    BOOL v19 = vertex_shader != 0;
    goto LABEL_37;
  }
  if (x_log_hook_p())
  {
    x_log_();
LABEL_27:
    BOOL v19 = 0;
    goto LABEL_37;
  }
  float32x4_t v18 = x_log_category_ogl_metal;
  BOOL v19 = 0;
  if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 136315138;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_DEFAULT, "Unrecognized shader spec: %s\n", buf, 0xCu);
    goto LABEL_27;
  }
LABEL_37:
  return v19;
}

uint64_t CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_6::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 2) = *(_WORD *)(result + 2) & 0xFDFF | ((a2 != 0) << 9);
  return result;
}

uint64_t CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_5::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 2) = *(_WORD *)(result + 2) & 0xFEFF | ((a2 != 0) << 8);
  return result;
}

uint64_t CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_4::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 2) = *(_WORD *)(result + 2) & 0xFF7F | ((a2 != 0) << 7);
  return result;
}

uint64_t CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_3::__invoke(uint64_t result, char a2)
{
  *(_WORD *)(result + 2) = *(_WORD *)(result + 2) & 0xFF9F | (32 * (a2 & 3));
  return result;
}

uint64_t CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_2::__invoke(uint64_t result, char a2)
{
  *(unsigned char *)(result + 1) = *(unsigned char *)(result + 1) & 0xFC | a2 & 3;
  return result;
}

unsigned char *CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_1::__invoke(unsigned char *result, char a2)
{
  atomic_uint *result = *result & 0xFC | a2 & 3;
  return result;
}

uint64_t CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_0::__invoke(uint64_t result, char a2)
{
  *(_WORD *)(result + 2) = *(_WORD *)(result + 2) & 0xFFE0 | a2 & 0x1F;
  return result;
}

uint64_t CA::OGL::MetalContext::get_VertexShaderType_decoder(CA::OGL::MetalContext *this)
{
  if (CA::OGL::MetalContext::get_VertexShaderType_decoder(void)::once != -1) {
    dispatch_once(&CA::OGL::MetalContext::get_VertexShaderType_decoder(void)::once, &__block_literal_global_2674);
  }
  return CA::OGL::MetalContext::get_VertexShaderType_decoder(void)::decoder;
}

void *___ZN2CA3OGL12MetalContext28get_VertexShaderType_decoderEv_block_invoke()
{
  unint64_t result = &unk_1ED0574B8;
  CA::OGL::MetalContext::get_VertexShaderType_decoder(void)::decoder = (uint64_t)result;
  return result;
}

double CA::OGL::MetalContext::get_metal_state(CA::OGL::MetalContext *this, uint64_t a2)
{
  uint64_t v4 = (void *)*((void *)this + 382);
  if (v4)
  {

    *((void *)this + 382) = 0;
  }
  uint64_t v5 = *((void *)this + 34);
  if (v5
    && (*(_WORD *)(v5 + 214) && (*((_WORD *)this + 1664) & 2) == 0 || byte_1EB2ACC40 || *((void *)this + 415) != v5))
  {
    CA::OGL::MetalContext::stop_encoders(this);
  }
  long long v6 = *((_OWORD *)this + 186);
  *(_OWORD *)a2 = v6;
  *(_DWORD *)(a2 + 16) = *((_DWORD *)this + 824);
  uint64_t v7 = (void *)v6;
  if ((void)v6)
  {
    int v8 = (void *)*((void *)this + 371);
    if ((void *)v6 != v8)
    {

      *((void *)this + 371) = *((id *)this + 372);
      uint64_t v7 = (void *)*((void *)this + 372);
    }
    *(void *)(a2 + 24) = CA::OGL::MetalContext_FlushSharedState;
    *(void *)(a2 + 32) = this;
  }
  else
  {
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
  }
  CA::OGL::MetalContext::copy_submitted_callbacks((uint64_t)this, v7);
  *((_WORD *)this + 1664) &= ~1u;
  *((void *)this + 372) = 0;
  *((void *)this + 373) = 0;
  double result = 0.0;
  *((_OWORD *)this + 188) = 0u;
  *((_OWORD *)this + 189) = 0u;
  *((void *)this + 380) = 0;
  *((void *)this + 413) = 0;
  *((void *)this + 415) = 0;
  *((void *)this + 414) = 0;
  return result;
}

void CA::OGL::MetalContext_FlushSharedState(CA::OGL::MetalContext *a1)
{
}

uint64_t CA::OGL::MetalContext::set_metal_state(uint64_t a1, uint64_t a2)
{
  v14[5] = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 2976)) {
    __assert_rtn("set_metal_state", "ogl-metal.mm", 10403, "_command_buffer == nil");
  }
  if (*(void *)(a1 + 2984)) {
    __assert_rtn("set_metal_state", "ogl-metal.mm", 10404, "_encoder == nil");
  }
  uint64_t v4 = *(void **)(a1 + 3056);
  if (v4)
  {

    *(void *)(a1 + 3056) = 0;
  }
  uint64_t v5 = *(void *)(a1 + 264);
  *(void *)(a1 + 3320) = v5;
  if (*(void *)a2)
  {
    *(void *)(a1 + 2976) = *(void *)a2;
    uint64_t v6 = *(void *)(a2 + 32);
    if (v6 != a1)
    {
      *(void *)(a1 + 3304) = *(void *)(a2 + 24);
      *(void *)(a1 + 3312) = v6;
    }
    if ((*(unsigned char *)(a2 + 16) & 1) == 0)
    {
      uint64_t v7 = *(void *)(a1 + 4040);
      *(void *)(v7 + 16) = atomic_fetch_add((atomic_ullong *volatile)(a1 + 4024), 1uLL) + 1;
      *(_DWORD *)(v7 + 40) = 0;
      int v8 = *(void **)(a1 + 2976);
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 3221225472;
      _DWORD v14[2] = ___ZN2CA3OGL12MetalContext26prepare_new_command_bufferEv_block_invoke;
      void v14[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
      v14[4] = a1;
      [v8 addCompletedHandler:v14];
    }
    uint64_t v9 = *(void **)(a2 + 8);
    if (v9)
    {
      if ((*(_WORD *)(v5 + 75) & 0x20) != 0) {
        __assert_rtn("set_metal_state", "ogl-metal.mm", 10428, "!surf->needs_clear");
      }
      *(void *)(a1 + 2984) = v9;
      *(void *)(a1 + 3008) = [v9 methodForSelector:sel_setRenderPipelineState_];
      *(void *)(a1 + 3016) = [*(id *)(a1 + 2984) methodForSelector:sel_setFragmentTexture_atIndex_];
      *(void *)(a1 + 3024) = [*(id *)(a1 + 2984) methodForSelector:sel_setFragmentSamplerState_atIndex_];
      *(void *)(a1 + 3032) = [*(id *)(a1 + 2984) methodForSelector:sel_setScissorRect_];
      *(void *)(a1 + 3040) = [*(id *)(a1 + 2984) methodForSelector:sel_drawPrimitives_vertexStart_vertexCount_instanceCount_];
      if (*(_WORD *)(v5 + 214))
      {
        __int16 v12 = *(_WORD *)(a1 + 3328);
        if ((v12 & 2) == 0 || byte_1EB2ACC40) {
          goto LABEL_15;
        }
      }
      else
      {
        if (byte_1EB2ACC40)
        {
LABEL_15:
          CA::OGL::MetalContext::stop_encoders((CA::OGL::MetalContext *)a1);
          return CA::OGL::MetalBufferPool::set_encoder(*(void *)(a1 + 4040), *(objc_object **)(a1 + 2984));
        }
        __int16 v12 = *(_WORD *)(a1 + 3328);
      }
      *(_WORD *)(a1 + 3328) = v12 | 1;
      *(_DWORD *)(a1 + 3296) = 0;
      CA::OGL::MetalContext::update_encoder_state(a1, v5, *(_DWORD *)(a2 + 16), v10, v11);
    }
  }
  return CA::OGL::MetalBufferPool::set_encoder(*(void *)(a1 + 4040), *(objc_object **)(a1 + 2984));
}

float CA::OGL::MetalContext::destination_offset(CA::OGL::MetalContext *this)
{
  return (float)*((int *)this + 710);
}

void CA::OGL::MetalContext::set_async_compile_queue(dispatch_object_t *this, NSObject *a2)
{
  if (this[268] != a2)
  {
    CA::OGL::MetalContext::stop_pipeline_queue((CA::OGL::MetalContext *)this);
    dispatch_release(this[268]);
    this[268] = a2;
    dispatch_retain(a2);
  }
}

void CA::OGL::MetalContext::free_destination_textures(CA::OGL::MetalContext *this, unsigned int a2, void **a3)
{
  if (a2)
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v5 = *a3++;

      --v4;
    }
    while (v4);
  }
}

void CA::OGL::MetalContext::~MetalContext(CA::OGL::MetalContext *this)
{
  CA::OGL::MetalContext::~MetalContext(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  void *v2;
  uint64_t v3;
  void *v4;
  malloc_zone_t *malloc_zone;
  uint64_t v6;
  void *v7;
  malloc_zone_t *v8;
  unint64_t v9;
  void *v10;
  malloc_zone_t *v11;
  void *v12;
  void *v13;
  uint64_t i;
  uint64_t j;
  uint64_t k;
  id *m;
  uint64_t v18;
  uint64_t *v19;
  void *v20;
  malloc_zone_t *v21;
  uint64_t v22;
  unint64_t v23;
  void *v24;
  id *v25;
  uint64_t v26;
  id *v27;
  uint64_t v28;
  unint64_t v29;
  void *v30;
  id *v31;
  uint64_t v32;
  id *v33;
  void *v34;
  void *v35;
  void *v36;
  BOOL v37;
  malloc_zone_t *v38;
  id *v39;
  uint64_t v40;
  id *v41;
  uint64_t v42;
  void *v43;
  uint64_t vars8;

  CA::OGL::MetalContext::flush(this, 1);
  [*((id *)this + 371) waitUntilCompleted];

  *((void *)this + 371) = 0;
  CA::OGL::MetalContext::stop_idle_collect_timer(this);
  os_unfair_lock_lock((os_unfair_lock_t)this + 702);
  os_signpost_id_t v2 = (void *)*((void *)this + 352);
  if (v2)
  {
    x_hash_table_free(v2);
    *((void *)this + 352) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 702);

  uint64_t v3 = *((void *)this + 356);
  if (v3)
  {
    CA::OGL::MetalContext::delete_image((uint64_t)this, v3);
    uint64_t v4 = (void *)*((void *)this + 356);
    if (v4)
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v4);
    }
  }
  uint64_t v6 = *((void *)this + 357);
  if (v6)
  {
    CA::OGL::MetalContext::delete_image((uint64_t)this, v6);
    uint64_t v7 = (void *)*((void *)this + 357);
    if (v7)
    {
      int v8 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v8, v7);
    }
  }
  if (*((void *)this + 358))
  {
    uint64_t v9 = 0;
    do
    {
      CA::OGL::MetalContext::delete_image((uint64_t)this, *(void *)(*((void *)this + 359) + 8 * v9));
      double v10 = *(void **)(*((void *)this + 359) + 8 * v9);
      if (v10)
      {
        double v11 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v11, v10);
      }
      ++v9;
    }
    while (v9 < *((void *)this + 358));
    free(*((void **)this + 359));
  }
  __int16 v12 = (void *)*((void *)this + 360);
  if (v12) {
    free(v12);
  }
  float32x4_t v13 = (void *)*((void *)this + 362);
  if (v13) {
    free(v13);
  }
  dispatch_sync(*((dispatch_queue_t *)this + 500), &__block_literal_global_51);
  CA::OGL::MetalContext::purge_shaders(this);
  dispatch_release(*((dispatch_object_t *)this + 268));
  for (uint64_t i = 2160; i != 2184; i += 8)

  for (uint64_t j = 2648; j != 2680; j += 8)
  for (int k = 4064; k != 4080; k += 8)

  for (uint64_t m = (id *)((char *)this + 2624); ; m[3])
  {
    uint64_t m = (id *)*m;
    if (!m) {
      break;
    }
  }

  float32x4_t v18 = *((void *)this + 505);
  if (v18)
  {
    BOOL v19 = *(uint64_t **)(v18 + 48);
    if (v19)
    {
      CA::OGL::MetalBufferPool::retire_metal_buffer(*((void *)this + 505), *v19);
      uint64_t v20 = *(void **)(v18 + 48);
      if (v20)
      {
        long long v21 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v21, v20);
      }
    }
    long long v22 = *(void *)(v18 + 248);
    if (*(void *)(v18 + 256) != v22)
    {
      unsigned int v23 = *(void *)(v18 + 272);
      int v24 = (void *)(v22 + 8 * (v23 >> 9));
      uint64_t v25 = (id *)(*v24 + 8 * (v23 & 0x1FF));
      __int16 v26 = *(void *)(v22 + (((*(void *)(v18 + 280) + v23) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((*(void *)(v18 + 280) + v23) & 0x1FF);
      while (v25 != (id *)v26)
      {

        if ((id *)((char *)v25 - *v24) == (id *)4096)
        {
          uint64_t v27 = (id *)v24[1];
          ++v24;
          uint64_t v25 = v27;
        }
      }
    }
    unsigned int v28 = *(void *)(v18 + 296);
    if (*(void *)(v18 + 304) != v28)
    {
      uint64_t v29 = *(void *)(v18 + 320);
      uint64_t v30 = (void *)(v28 + 8 * (v29 >> 9));
      unint64_t v31 = (id *)(*v30 + 8 * (v29 & 0x1FF));
      uint64_t v32 = *(void *)(v28 + (((*(void *)(v18 + 328) + v29) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((*(void *)(v18 + 328) + v29) & 0x1FF);
      while (v31 != (id *)v32)
      {

        if ((id *)((char *)v31 - *v30) == (id *)4096)
        {
          int64x2_t v33 = (id *)v30[1];
          ++v30;
          unint64_t v31 = v33;
        }
      }
    }
    uint64_t v34 = *(void **)(v18 + 336);
    if (v34 != (void *)(v18 + 344))
    {
      do
      {

        double v35 = (void *)v34[1];
        if (v35)
        {
          do
          {
            __int16 v36 = v35;
            double v35 = (void *)*v35;
          }
          while (v35);
        }
        else
        {
          do
          {
            __int16 v36 = (void *)v34[2];
            char v37 = *v36 == (void)v34;
            uint64_t v34 = v36;
          }
          while (!v37);
        }
        uint64_t v34 = v36;
      }
      while (v36 != (void *)(v18 + 344));
    }

    std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(*(void **)(v18 + 344));
    std::deque<objc_object  {objcproto9MTLBuffer}*>::~deque[abi:nn180100](v18 + 288);
    std::deque<objc_object  {objcproto9MTLBuffer}*>::~deque[abi:nn180100](v18 + 240);
    __int16 v38 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v38, (void *)v18);
  }
  dispatch_release(*((dispatch_object_t *)this + 500));
  if (atomic_fetch_add(CA::OGL::MetalContext::_context_count, 0xFFFFFFFF) == 1)
  {
    pthread_mutex_lock(&CA::OGL::MetalContext::_library_lock);
    uint64_t v39 = (id *)CA::OGL::MetalContext::_libraries;
    __int16 v40 = qword_1E8F83E10;
    if (CA::OGL::MetalContext::_libraries != (_UNKNOWN *)qword_1E8F83E10)
    {
      do

      while (v39 != (id *)v40);
      uint64_t v39 = (id *)CA::OGL::MetalContext::_libraries;
    }
    qword_1E8F83E10 = (uint64_t)v39;
    pthread_mutex_unlock(&CA::OGL::MetalContext::_library_lock);
    pthread_mutex_lock(&CA::OGL::MetalContext::_library_lock);
    uint64_t v41 = (id *)CA::OGL::MetalContext::_binary_archives;
    __int16 v42 = qword_1E8F83E40;
    if (CA::OGL::MetalContext::_binary_archives != (_UNKNOWN *)qword_1E8F83E40)
    {
      do

      while (v41 != (id *)v42);
      uint64_t v41 = (id *)CA::OGL::MetalContext::_binary_archives;
    }
    qword_1E8F83E40 = (uint64_t)v41;
    pthread_mutex_unlock(&CA::OGL::MetalContext::_library_lock);
  }
  char v43 = (void *)*((void *)this + 383);
  if (v43)
  {
    *((void *)this + 384) = v43;
    operator delete(v43);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)this + 2744);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)this + 2608);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)this + 2088);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 2016));
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)this + 1976);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 1904));
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)this + 1864);

  CA::OGL::Context::~Context(this);
}

void sub_1848C1214(_Unwind_Exception *a1)
{
  std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(*(void **)(v1 + 344));
  std::deque<objc_object  {objcproto9MTLBuffer}*>::~deque[abi:nn180100](v1 + 288);
  std::deque<objc_object  {objcproto9MTLBuffer}*>::~deque[abi:nn180100](v1 + 240);
  _Unwind_Resume(a1);
}

uint64_t std::deque<objc_object  {objcproto9MTLBuffer}*>::~deque[abi:nn180100](uint64_t a1)
{
  os_signpost_id_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      os_signpost_id_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 512;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t CAML::Context::failed_to_load_resource(CAML::Context *this, const __CFURL *a2)
{
  return 0;
}

void CAML::Context::did_load_resource(CAML::Context *this, const __CFURL *key, const void *value)
{
  Mutable = (__CFDictionary *)*((void *)this + 9);
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *((void *)this + 9) = Mutable;
  }

  CFDictionarySetValue(Mutable, key, value);
}

const __CFDictionary *CAML::Context::will_load_resource(CAML::Context *this, const __CFURL *a2)
{
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 9);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  }
  return result;
}

uint64_t CAML::Context::start_script(CAML::Context *this, const char **a2)
{
  return CAML::Context::error(this, "<script> element not supported");
}

uint64_t CAML::Context::error(CAML::Context *this, const char *a2, ...)
{
  va_start(va, a2);
  return (*(uint64_t (**)(CAML::Context *, const char *, uint64_t *))(*(void *)this + 24))(this, a2, (uint64_t *)va);
}

void CAML::Context::errorv(CAML::Context *this, const char *a2, va_list a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!*((void *)this + 4))
  {
    uint64_t v6 = __str;
    bzero(__str, 0x400uLL);
    int v7 = vsnprintf(__str, 0x400uLL, a2, a3);
    size_t v8 = v7 + 1;
    if (v8 >= 0x401)
    {
      uint64_t v9 = (char *)malloc_type_malloc(v7 + 1, 0xFAF74C40uLL);
      if (!v9) {
        return;
      }
      uint64_t v6 = v9;
      vsnprintf(v9, v8, a2, a3);
    }
    keys = @"message";
    values = (void *)CFStringCreateWithCString(0, v6, 0x8000100u);
    if (values)
    {
      CFDictionaryRef v10 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFRelease(values);
      *((void *)this + 4) = CFErrorCreate(0, @"CAML", 1, v10);
      CFRelease(v10);
    }
    if (v6 != __str) {
      free(v6);
    }
  }
}

void CAML::anonymous namespace'::entity_free(void **this, void *a2)
{
  free(this[2]);
  free(this[12]);
  free(this[13]);
  free(this[10]);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

uint64_t CAML::anonymous namespace'::sax_error(CAML::_anonymous_namespace_ *this, void *a2, const char *a3, ...)
{
  va_start(va, a3);
  return (*(uint64_t (**)(CAML::_anonymous_namespace_ *, void *, uint64_t *))(*(void *)this + 24))(this, a2, (uint64_t *)va);
}

uint64_t CAML::anonymous namespace'::sax_warning(CAML::_anonymous_namespace_ *this, void *a2, const char *a3, ...)
{
  va_start(va, a3);
  return (*(uint64_t (**)(CAML::_anonymous_namespace_ *, void *, uint64_t *))(*(void *)this + 16))(this, a2, (uint64_t *)va);
}

void CAML::anonymous namespace'::object_attribute(CAML::_anonymous_namespace_ *this, CAML::Context *a2, const CAML::Type *cStr, const char *a4, uint64_t a5, void (*a6)(CAML::Context *, CAML::State *))
{
  int v7 = (int)a4;
  CFStringRef v10 = CFStringCreateWithCString(0, (const char *)cStr, 0x8000100u);
  CFDictionaryRef v11 = (const __CFDictionary *)*((void *)this + 8);
  if (!v11 || (CFStringRef Value = (uint64_t *)CFDictionaryGetValue(v11, v10)) == 0)
  {
    CFRelease(v10);
    goto LABEL_8;
  }
  uint64_t v14 = *Value;
  float32x4_t v13 = (const void *)Value[1];
  CFRelease(v10);
  if (!v13)
  {
LABEL_8:
    goto LABEL_9;
  }
  if (!a2)
  {
    uint64_t v15 = this;
    int v16 = v7;
    uint64_t v17 = 0;
    goto LABEL_13;
  }
  if ((*(unsigned int (**)(CAML::_anonymous_namespace_ *, CAML::Context *, uint64_t))(*(void *)this + 40))(this, a2, v14))
  {
    uint64_t v15 = this;
    int v16 = v7;
    uint64_t v17 = a2;
LABEL_13:
    float32x4_t v18 = (CAML::State *)CAML::Context::push_state((uint64_t)v15, 0, v16, (uint64_t)v17, a5);
    CAML::State::set_value(v18, v13);
    return;
  }
LABEL_9:

  CAML::Context::push_state((uint64_t)this, 0, 0, 0, 0);
}

void CAML::anonymous namespace'::set_set(CAML::_anonymous_namespace_ *this, CAML::Context *a2, CAML::State *a3)
{
  uint64_t v3 = (const void *)*((void *)a2 + 8);
  if (v3) {
    CFSetAddValue(*(CFMutableSetRef *)(*((void *)this + 6) + 64), v3);
  }
}

uint64_t CAML::anonymous namespace'::sax_entity_decl(CAML::_anonymous_namespace_ *this, const char *a2, const unsigned __int8 *a3, const char *a4, const char *a5, const char *a6, unsigned __int8 *a7)
{
  int v10 = (int)a3;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v14 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x88uLL, 0x743898A5uLL);
  _DWORD v14[2] = 17;
  v14[23] = v10;
  uint64_t v15 = strdup(a2);
  *((void *)v14 + 2) = v15;
  if (a4) {
    *((void *)v14 + 12) = strdup(a4);
  }
  if (a5) {
    *((void *)v14 + 13) = strdup(a5);
  }
  *((void *)v14 + 10) = strdup(a6);
  v14[22] = strlen(a6);
  int v16 = (int *)*((void *)this + 7);
  if (!v16)
  {
    *((void *)this + 7) = v16;
  }

  return hash_table_modify(v16, (uint64_t)v15, (uint64_t)v14, 1);
}

xmlEntityPtr CAML::anonymous namespace'::sax_get_entity(CAML::_anonymous_namespace_ *this, xmlChar *name, const unsigned __int8 *a3)
{
  uint64_t v4 = *((void *)this + 7);
  if (!v4 || (xmlEntityPtr result = (xmlEntityPtr)x_hash_table_lookup(v4, (uint64_t)name, 0)) == 0)
  {
    return xmlGetPredefinedEntity(name);
  }
  return result;
}

CFTypeRef CAML::Context::set_error(CAML::Context *this, CFTypeRef cf)
{
  uint64_t v4 = (const void *)*((void *)this + 4);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 4) = 0;
  }
  CFTypeRef result = CFRetain(cf);
  *((void *)this + 4) = result;
  return result;
}

uint64_t CA::OGL::emitter_cells_have_offscreens(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(unsigned int *)(result + 16);
    if (v1)
    {
      uint64_t v2 = result + 24;
      uint64_t v3 = 8 * v1;
      while ((*(unsigned char *)(*(void *)v2 + 13) & 4) == 0
           && !CA::OGL::emitter_cells_have_offscreens(*(void *)(*(void *)v2 + 40)))
      {
        v2 += 8;
        v3 -= 8;
        if (!v3) {
          return 0;
        }
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint32x2_t *CA::OGL::render_emitter_cells(uint32x2_t *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v196 = a3;
  uint64_t v219 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    uint64_t v5 = a5;
    uint64_t v6 = a4;
    if (*(_DWORD *)(a4 + 16) == *(_DWORD *)(a5 + 8))
    {
      int v7 = result;
      uint64_t v8 = (uint64_t)*result;
      *(unsigned char *)(*(void *)(*(void *)result + 16) + 16) = 3;
      if (*(_DWORD *)(a5 + 8))
      {
        uint64_t v9 = a2;
        uint64_t v10 = 0;
        uint64_t v168 = *(void *)(*(void *)(a2 + 16) + 24);
        uint64_t v187 = (CA::OGL::ExtendedColor *)&v210;
        uint64_t v179 = &v216;
        char v170 = &v204;
        uint64_t v190 = v8 + 834;
        unint64_t v177 = v211;
        v178 = &v217;
        int v169 = v205;
        __asm { FMOV            V0.4S, #1.0 }
        float32x4_t v197 = _Q0;
        float32x4_t v195 = (float32x4_t)vdupq_n_s32(0x437F0000u);
        uint32x2_t v188 = (uint32x2_t)0xFFFFFFF8FFFFFFF0;
        long long v189 = xmmword_184997E70;
        float v186 = 0.15915;
        float v185 = 6.2832;
        uint64_t v171 = a4;
        uint64_t v172 = a5;
        uint64_t v173 = a2;
        size_t v180 = result;
        while (1)
        {
          uint64_t v183 = v10;
          uint64_t v191 = *(void *)(v6 + 8 * v10 + 24);
          if (*(unsigned char *)(v191 + 13)) {
            break;
          }
LABEL_152:
          uint64_t v10 = v183 + 1;
          if (v183 + 1 >= (unint64_t)*(unsigned int *)(v5 + 8)) {
            goto LABEL_179;
          }
        }
        uint64_t v184 = *(void *)(*(void *)v5 + 8 * v183);
        if (BYTE5(xmmword_1EB2ACBF0))
        {
          uint64_t PerfHud = CA::OGL::GetPerfHud((CA::OGL *)result);
          if (PerfHud) {
            ++*(void *)(PerfHud + 472);
          }
        }
        CFTypeRef result = *(uint32x2_t **)(v191 + 24);
        if (!result) {
          goto LABEL_146;
        }
        CFTypeRef result = (uint32x2_t *)(*(uint64_t (**)(uint32x2_t *))(*(void *)result + 80))(result);
        if (!result) {
          goto LABEL_146;
        }
        uint64_t v17 = result;
        unint64_t v18 = *(unsigned int *)(v191 + 12);
        unsigned int v19 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[(v18 >> 9) & 3];
        int v20 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[(v18 >> 11) & 3];
        int v21 = *(_DWORD *)(v191 + 212);
        if ((*(_DWORD *)(v8 + 432) & 2) != 0) {
          unsigned int v22 = 2111;
        }
        else {
          unsigned int v22 = 63;
        }
        if (*(void *)(*(void *)(v9 + 16) + 24)) {
          unsigned int v23 = (double *)(v22 ^ 0x800);
        }
        else {
          unsigned int v23 = (double *)v22;
        }
        uint32x2_t v24 = result[2];
        v25.i64[0] = v24.u32[0];
        v25.i64[1] = v24.u32[1];
        float64x2_t v26 = vcvtq_f64_u64(v25);
        float32x4_t v214 = 0uLL;
        uint64_t v27 = *(void *)(v191 + 32);
        if (v27)
        {
          float32x2_t v28 = vcvt_f32_f64(*(float64x2_t *)(v27 + 24));
          float64x2_t v29 = *(float64x2_t *)(v27 + 40);
          float32x4_t v214 = vcvt_hight_f32_f64((int32x2_t)v28, v29);
          float64x2_t v16 = vcvtq_f64_f32(vsub_f32(vcvt_f32_f64(v29), v28));
          float64x2_t v26 = vmulq_f64(v16, v26);
          unsigned int v23 = (double *)(v23 | 0x400);
        }
        *(float32x2_t *)&v16.f64[0] = vcvt_f32_f64(v26);
        float v30 = *(float *)(v191 + 216);
        _ZF = v30 == 1.0;
        double v31 = COERCE_DOUBLE(vmul_n_f32(*(float32x2_t *)&v16.f64[0], 1.0 / v30));
        if (!_ZF) {
          v16.f64[0] = v31;
        }
        float64x2_t v194 = v16;
        int v213 = 0;
        uint64_t v210 = 0x3C003C003C003C00;
        uint64_t v32 = v177;
        v177[1] = 0;
        _OWORD v32[2] = 0;
        *uint64_t v32 = 0;
        long long v208 = 0uLL;
        uint64_t v207 = 0;
        int v212 = 1065353216;
        int64x2_t v33 = vceqzq_f64(v26);
        int v199 = v21;
        if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v33, 1), (int8x16_t)v33).u64[0] & 0x8000000000000000) != 0
          || (int8x16_t v34 = vorrq_s8((int8x16_t)vcltzq_f64(v26), (int8x16_t)vcgezq_f64(v26)),
              (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v34), 1), v34).u64[0] & 0x8000000000000000) != 0))
        {
          int32x4_t v202 = 0uLL;
        }
        else
        {
          int32x4_t v35 = (int32x4_t)vcvtmq_s64_f64((float64x2_t)0);
          int32x4_t v202 = vuzp1q_s32(v35, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(v26, (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v35));
        }
        memset(v206, 0, 48);
        CA::Shape::operator=((uint64_t)v206, &v202);
        *(void *)&long long v208 = v206;
        unsigned int v209 = (float64x2_t *)&CA::identity_transform;
        LOWORD(v213) = 1283;
        uint64_t v207 = CA::OGL::Context::set_gstate(v8, (uint64_t)&v207);
        __int16 v36 = CA::OGL::Context::bind_image(v8, 0, v17, v23, v19, v20, 0, 0, *(float *)&v199, &v214, 0);
        CFTypeRef result = (uint32x2_t *)CA::OGL::Context::set_gstate(v8, **(void **)(v8 + 248));
        int v7 = v180;
        if (!v36)
        {
LABEL_146:
          if (*(void *)(v191 + 40))
          {
            uint64_t v144 = *(unsigned int *)(v184 + 16);
            if (v144)
            {
              uint64_t v145 = *(void *)(v184 + 8);
              do
              {
                if (*(float *)(v145 + 24) != 0.0)
                {
                  --v144;
                  CFTypeRef result = (uint32x2_t *)CA::OGL::render_emitter_cells(v7, v9, v196, *(void *)(v191 + 40), v145);
                }
                v145 += 128;
              }
              while (v144);
            }
          }
          goto LABEL_152;
        }
        uint64_t v37 = *(void *)(v8 + 248);
        long long v208 = *(_OWORD *)(v37 + 8);
        uint64_t v38 = *(void *)(v37 + 32);
        unsigned int v209 = *(float64x2_t **)(v37 + 24);
        uint64_t v210 = v38;
        *(_OWORD *)unint64_t v177 = *(_OWORD *)(v37 + 40);
        v211[2] = *(void *)(v37 + 56);
        LOWORD(v213) = *(unsigned __int8 *)(v37 + 68) | (BYTE1(v213) << 8);
        int v212 = *(_DWORD *)(v37 + 64);
        LOWORD(v213) = *(_WORD *)(v37 + 68) & 0x100 | v213 & 0xFEFF;
        __int16 v39 = v213 & 0xFBFF | *(_WORD *)(v37 + 68) & 0x400;
        int v40 = *(_DWORD *)(v196 + 72);
        __int16 v41 = 16;
        if (v40 > 383)
        {
          if (v40 != 489)
          {
            if (v40 == 384) {
LABEL_29:
            }
              __int16 v41 = 18;
            else {
LABEL_34:
            }
              __int16 v41 = 3;
          }
        }
        else
        {
          switch(v40)
          {
            case 'T':
              break;
            case 'U':
              __int16 v41 = 32;
              goto LABEL_35;
            case 'V':
              goto LABEL_29;
            case 'W':
              goto LABEL_35;
            default:
              if (v40 != 3) {
                goto LABEL_34;
              }
              break;
          }
          LOWORD(v213) = v39 & 0xFF00 | 0xC;
          if ((v168 & 0x400) != 0
            || !(*(unsigned int (**)(uint32x2_t, uint64_t))(**(void **)v7 + 184))(*v7, 33))
          {
LABEL_36:
            uint64_t v42 = CA::OGL::Context::set_gstate(v8, (uint64_t)&v207);
            uint64_t v207 = v42;
            uint64_t v176 = *(unsigned int *)(v184 + 16);
            int v43 = *(_DWORD *)(v196 + 72);
            if ((v43 - 405) < 2 || v43 == 52)
            {
              if (v176 > 0x80)
              {
                unint64_t v45 = (char *)malloc_type_malloc(32 * v176, 0x70D7DFAuLL);
                if (!v45)
                {
LABEL_145:
                  CA::OGL::Context::set_gstate(v8, **(void **)(v8 + 248));
                  CFTypeRef result = (uint32x2_t *)(*(uint64_t (**)(uint64_t, _OWORD *, void))(*(void *)v8 + 520))(v8, v36, 0);
                  goto LABEL_146;
                }
              }
              else
              {
                MEMORY[0x1F4188790](v42);
                unint64_t v45 = (char *)&v168 - ((v44 + 15) & 0x3FFFFFFFF0);
                bzero(v45, v44);
              }
              uint64_t v46 = *(unsigned int *)(v184 + 16);
              uint64_t v182 = v45;
              uint64_t v47 = v45;
              if (v46)
              {
                uint64_t v48 = *(void *)(v184 + 8);
                uint64_t v47 = v182;
                do
                {
                  if (*(float *)(v48 + 24) != 0.0)
                  {
                    int v49 = *(_DWORD *)(v196 + 72);
                    if (v49 == 405)
                    {
                      float v50 = *(double *)(v48 + 16);
                    }
                    else if (v49 == 52)
                    {
                      float v50 = *(float *)(v48 + 40);
                    }
                    else
                    {
                      float v51 = *(double *)(v48 + 16);
                      float v50 = -v51;
                    }
                    --v46;
                    *(_DWORD *)uint64_t v47 = ((SLODWORD(v50) >> 31) | 0x80000000) ^ LODWORD(v50);
                    *((void *)v47 + 1) = v48;
                    v47 += 16;
                  }
                  v48 += 128;
                }
                while (v46);
              }
              uint64_t v52 = (v47 - v182) >> 4;
              CA::radix_sort(v52);
            }
            else
            {
              uint64_t v182 = 0;
              uint64_t v52 = v176;
            }
            unint64_t v181 = v52;
            if (!v52)
            {
LABEL_142:
              if (v182 && v176 >= 0x81) {
                free(v182);
              }
              goto LABEL_145;
            }
            int v174 = v36;
            int v53 = *(_DWORD *)(v191 + 64);
            int v199 = (*(uint64_t (**)(uint64_t))(*(void *)v196 + 176))(v196);
            if (v53 == 436)
            {
              int v199 = 3;
              int v56 = 1;
              int v54 = 1;
            }
            else if (v53 == 532)
            {
              int v54 = v199 ^ 1;
              if (v181 < 0x81) {
                char v55 = 1;
              }
              else {
                char v55 = v199;
              }
              if (v55)
              {
                int v175 = 0;
                int v56 = 0;
LABEL_66:
                uint64_t v57 = *(void *)(v8 + 16);
                if (*(unsigned __int8 *)(v57 + 480) >= 2u) {
                  *(unsigned char *)(v57 + 481) |= 1u;
                }
                v201[0] = 0;
                v201[1] = 0;
                if (v56 && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v8 + 184))(v8, 11))
                {
                  uint64_t v58 = 768;
                  if (v181 < 0x300) {
                    uint64_t v58 = v181;
                  }
                  uint64_t v198 = v58;
                  size_t v59 = 16 * v58;
                  malloc_zone = (malloc_zone_t *)get_malloc_zone();
                  rect = (CA::OGL *)malloc_type_zone_malloc(malloc_zone, v59, 0x8BB15036uLL);
                  int v63 = rect;
                  if (rect)
                  {
                    unint64_t v64 = *(float32x4_t **)(v184 + 8);
                    __int32 v65 = *(_DWORD *)(v191 + 224);
                    int64x2_t v66 = *(float32x2_t **)(v8 + 16);
                    v66[12] = vsub_f32(*(float32x2_t *)&v214.u32[2], *(float32x2_t *)v214.f32);
                    v66[13].i32[0] = v65;
                    v66[13].i32[1] = 0;
                    if ((LOBYTE(v209[9].f64[0]) & 0x10) != 0) {
                      double scale = CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v209, 0, 0, v62);
                    }
                    else {
                      double scale = v209[8].f64[0];
                    }
                    unint64_t v146 = v181;
                    int v147 = v182;
                    int v199 = 0;
                    float v148 = scale * *(float *)v194.f64;
                    *(float *)v194.f64 = v148;
                    do
                    {
                      uint64_t v149 = 0;
                      float32x4_t v150 = 0uLL;
                      while (v146)
                      {
                        int v151 = v64;
                        while (1)
                        {
                          if (v147)
                          {
                            unint64_t v64 = v151;
                            int v151 = (float32x4_t *)*((void *)v147 + 1);
                            v147 += 16;
                            --v146;
                            goto LABEL_166;
                          }
                          unint64_t v64 = v151 + 8;
                          float v152 = v151[1].f32[2];
                          if (v152 != 0.0)
                          {
                            --v146;
                            if (v151[3].f32[3] < v152) {
                              break;
                            }
                          }
                          int v147 = 0;
                          v151 += 8;
                          if (!v146)
                          {
                            int v147 = 0;
                            goto LABEL_170;
                          }
                        }
                        int v147 = 0;
LABEL_166:
                        unsigned int v153 = (char *)v63 + 16 * v149;
                        uint64_t v154 = v210;
                        uint64_t v200 = v210;
                        *(void *)unsigned int v153 = v151[2].i64[0];
                        *((float *)v153 + 2) = v151[5].f32[1] * *(float *)v194.f64;
                        int32x4_t v155 = (int32x4_t)vmaxq_f32(vminq_f32(v151[4], v197), v150);
                        float32x4_t v156 = (float32x4_t)vdupq_laneq_s32(v155, 3);
                        v156.i32[3] = 1.0;
                        v157.i64[0] = 0x3F0000003F000000;
                        v157.i64[1] = 0x3F0000003F000000;
                        *(int16x4_t *)v155.i8 = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v157, v156, vmulq_f32((float32x4_t)v155, v195))));
                        unsigned __int32 v158 = vuzp1_s8(*(int8x8_t *)v155.i8, *(int8x8_t *)v155.i8).u32[0];
                        *((_DWORD *)v153 + 3) = v158;
                        size_t v159 = (unsigned __int32 *)(v153 + 12);
                        if (v154 != 0x3C003C003C003C00)
                        {
                          unsigned int v160 = CA::OGL::ExtendedColor::word32((CA::OGL::ExtendedColor *)&v200);
                          float32x4_t v150 = 0uLL;
                          int8x8_t v161 = vand_s8((int8x8_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v158 >> 8), (int8x8_t)0xFF0000FF00), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v160), v188), (int8x8_t)0xFF000000FFLL), (int32x2_t)0x100000001)), (int8x8_t)0x1FF0001FF0000);
                          *size_t v159 = (((v158 >> 8) & 0xFF0000) + ((v158 >> 8) & 0xFF0000) * HIBYTE(v160)) & 0xFF000000 | ((v158 * v160 + v158) >> 8) | v161.i32[0] | v161.i32[1];
                        }
                        ++v149;
                        int v7 = v180;
                        if (v149 == v198)
                        {
                          uint64_t v149 = v198;
                          break;
                        }
                      }
LABEL_170:
                      unsigned int v162 = v178;
                      v178->i64[0] = 0;
                      v162->i64[1] = 0;
                      v162[1].i64[0] = 0;
                      uint64_t v163 = *(void *)(*(void *)(v8 + 248) + 8);
                      v215.i64[0] = v8;
                      v215.i64[1] = v163;
                      signed int v164 = v179;
                      v179->i64[0] = 0;
                      v164->i64[1] = 0;
                      v164[1].i16[0] = 0;
                      CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)&v215);
                      while (CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)&v215, v201))(*(void (**)(uint64_t, void, uint64_t, CA::OGL *))(*(void *)v8 + 304))(v8, 0, v149, v63);
                      v199 += v149;
                    }
                    while (v146);
                    unsigned int v165 = (malloc_zone_t *)get_malloc_zone();
                    malloc_zone_free(v165, v63);
                    uint64_t v6 = v171;
                    uint64_t v5 = v172;
                    __int16 v36 = v174;
                    LODWORD(v63) = v199;
                    goto LABEL_138;
                  }
LABEL_137:
                  __int16 v36 = v174;
LABEL_138:
                  uint64_t v9 = v173;
                  if (BYTE5(xmmword_1EB2ACBF0))
                  {
                    uint64_t v167 = CA::OGL::GetPerfHud(rect);
                    if (v167) {
                      *(void *)(v167 + 480) += v63;
                    }
                  }
                  if (v175)
                  {
                    *(void *)(v8 + 816) = 0;
                    ++*(_DWORD *)(v8 + 256);
                  }
                  *(unsigned char *)(*(void *)(v8 + 16) + 481) &= ~1u;
                  goto LABEL_142;
                }
                uint64_t v68 = v169;
                *((void *)v169 + 1) = 0;
                v68[2] = 0;
                *uint64_t v68 = 0;
                uint64_t v69 = *(void *)(*(void *)(v8 + 248) + 8);
                v203[0] = v8;
                v203[1] = v69;
                unint64_t v70 = v170;
                *char v170 = 0;
                v70[1] = 0;
                *((unsigned char *)v70 + 16) = 0;
                v205[1] = 1;
                CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v203);
                LODWORD(v63) = 0;
                int v71 = v175;
                if (v199 != 1) {
                  int v71 = 1;
                }
                int v192 = v54 & (v175 ^ 1);
                int v193 = v71;
LABEL_78:
                rect = (CA::OGL *)CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v203, v201);
                if (!rect)
                {
                  uint64_t v6 = v171;
                  uint64_t v5 = v172;
                  int v7 = v180;
                  goto LABEL_137;
                }
                uint64_t v74 = *(float32x4_t **)(v184 + 8);
                unint64_t v76 = v181;
                unint64_t v75 = v182;
                float32x4_t v77 = 0uLL;
                while (!v75)
                {
                  uint64_t v78 = v74 + 8;
                  float v88 = v74[1].f32[2];
                  unint64_t v75 = 0;
                  if (v88 != 0.0)
                  {
                    --v76;
                    if (v74[3].f32[3] < v88) {
                      goto LABEL_82;
                    }
                  }
LABEL_134:
                  uint64_t v74 = v78;
                  if (!v76) {
                    goto LABEL_78;
                  }
                }
                uint64_t v78 = v74;
                uint64_t v74 = (float32x4_t *)*((void *)v75 + 1);
                v75 += 16;
                --v76;
LABEL_82:
                uint64_t v198 = (uint64_t)v78;
                uint64_t v79 = 4;
                if (*(_DWORD *)(v8 + 92)) {
                  uint64_t v79 = 6;
                }
                uint64_t v80 = *(void *)(v8 + 128);
                if ((unint64_t)(v80 + 4) > *(void *)(v8 + 136)
                  || (unint64_t v81 = *(void *)(v8 + 112)) != 0 && *(void *)(v8 + 104) + v79 > v81)
                {
                  *(_WORD *)(v8 + 832) |= 0x20u;
                  CA::OGL::Context::array_flush(v8);
                  float32x4_t v77 = 0uLL;
                  LODWORD(v80) = 0;
                  *(void *)(v8 + 128) = 0;
                  *(void *)(v8 + 96) = v190;
                  *(_OWORD *)(v8 + 104) = v189;
                }
                uint64_t v82 = *(void *)(v8 + 120);
                float32x4_t v217 = v77;
                float32x4_t v218 = v77;
                float32x4_t v215 = v77;
                float32x4_t v216 = v77;
                v72.i64[0] = v74[2].i64[0];
                __int32 v83 = 1.0;
                v84.i64[0] = v72.i64[0];
                v84.i32[2] = v74[2].i32[2];
                v84.i32[3] = 1.0;
                if ((v193 & 1) == 0)
                {
                  if ((LOBYTE(v209[9].f64[0]) & 0x10) != 0)
                  {
                    int32x4_t v73 = (int32x4_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*v209), v209[1]);
                    int8x16_t v84 = (int8x16_t)vmlaq_laneq_f32(vmlaq_lane_f32(vmlaq_n_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v209[6]), v209[7]), (float32x4_t)v73, *(float *)v72.i32), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v209[2]), v209[3]), *(float32x2_t *)v72.i8, 1), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v209[4]), v209[5]), (float32x4_t)v84, 2);
                  }
                  else
                  {
                    if ((LOBYTE(v209[9].f64[0]) & 8) != 0)
                    {
                      v73.i64[0] = *(void *)&v209[8].f64[0];
                      *(float32x2_t *)v72.i8 = vcvt_f32_f64(vmulq_n_f64(vcvtq_f64_f32(*(float32x2_t *)v72.i8), *(double *)v73.i64));
                      v72.i64[1] = vextq_s8(v84, v84, 8uLL).u64[0];
                      int8x16_t v84 = (int8x16_t)v72;
                    }
                    if ((LOBYTE(v209[9].f64[0]) & 4) != 0)
                    {
                      v73.i64[1] = v84.i64[1];
                      *(float *)v73.i32 = -*(float *)&v84.i32[1];
                      v73.i32[1] = v84.i32[0];
                      int8x16_t v84 = (int8x16_t)v73;
                    }
                    v72.i32[0] = 0;
                    v73.i32[0] = LOBYTE(v209[9].f64[0]) & 2;
                    int8x16_t v85 = v84;
                    *(float *)v85.i32 = -*(float *)v84.i32;
                    int8x16_t v86 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v73, v72), 0), v84, v85);
                    float v87 = *(float *)&v86.i32[1];
                    if (LOBYTE(v209[9].f64[0])) {
                      float v87 = -*(float *)&v86.i32[1];
                    }
                    int32x4_t v73 = (int32x4_t)vextq_s8(v86, v86, 8uLL);
                    *(float *)&v86.i32[1] = v87;
                    int32x4_t v72 = (int32x4_t)v209[6];
                    *(float32x2_t *)v84.i8 = vcvt_f32_f64(vaddq_f64((float64x2_t)v72, vcvtq_f64_f32(*(float32x2_t *)v86.i8)));
                    v84.i64[1] = v73.i64[0];
                  }
                  __int32 v83 = v84.i32[3];
                }
                float v89 = v74[5].f32[2];
                float32x2_t v90 = vmul_n_f32(*(float32x2_t *)&v194.f64[0], v74[5].f32[1]);
                *(float32x2_t *)v215.f32 = vmul_f32(v90, (float32x2_t)0xBF000000BF000000);
                v215.i32[3] = v83;
                v216.i32[3] = v83;
                float32x2_t v91 = vmul_f32(v90, (float32x2_t)0x3F0000003F000000);
                *(float32x2_t *)v217.f32 = v91;
                v91.i32[1] = v215.i32[1];
                *(float32x2_t *)v216.f32 = v91;
                v217.i32[3] = v83;
                *(float32x2_t *)v218.f32 = vmul_f32(v90, (float32x2_t)0x3F000000BF000000);
                v218.i32[3] = v83;
                float v92 = *(float *)(v196 + 124) + v89;
                if (v92 < -3.1416 || v92 > 3.1416) {
                  float v92 = (float)((float)((float)((float)(v92 * v186) + 0.5) - floorf((float)(v92 * v186) + 0.5)) * v185)
                }
                      + -3.1416;
                float v93 = v92 * v92;
                float v94 = (float)((float)((float)((float)((float)(v92 * v92) * 0.0054654) + -0.15346) * (float)(v92 * v92))
                            + 0.98442)
                    * v92;
                float v95 = (float)((float)((float)((float)(v93 * -0.00096967) + 0.039228) * v93) + -0.49535) * v93;
                float v96 = v95 + 0.99861;
                if (v199 == 2
                  && ((v98 = v74[7].f32[0], float v97 = v74[7].f32[1], v99 = v74[7].f32[2], fabsf(v98) >= 0.001)
                   || fabsf(v97) >= 0.001
                   || fabsf(v99 + -1.0) >= 0.001))
                {
                  int v100 = (int)v63;
                  uint64_t v107 = 0;
                  v108.i64[0] = v74[7].i64[0];
                  v108.i64[1] = LODWORD(v99);
                  float32x4_t v109 = vmulq_f32(v108, v108);
                  float32x4_t v110 = vmlaq_n_f32(v109, vsubq_f32(v197, v109), v96);
                  float v111 = 0.0013933 - v95;
                  float v112 = (float)(v97 * v98) * v111;
                  float v113 = (float)(v99 * v97) * v111;
                  float v114 = (float)(v99 * v98) * v111;
                  float v115 = v94 * v98;
                  float v116 = v94 * v97;
                  float v117 = v94 * v99;
                  float32_t v118 = v112 + v117;
                  float32_t v119 = v114 - v116;
                  *(float *)v72.i32 = v112 - v117;
                  *(float *)v73.i32 = v114 + v116;
                  v72.i32[1] = v110.i32[1];
                  *(float *)&v73.i32[1] = v113 - v115;
                  v73.i32[2] = v110.i32[2];
                  float32x4_t v120 = v110;
                  v120.f32[1] = v118;
                  v120.f32[2] = v119;
                  *(float *)&v72.i32[2] = v113 + v115;
                  do
                  {
                    float32x4_t v121 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v120, v215.f32[v107]), (float32x4_t)v72, v215.f32[v107 + 1]), (float32x4_t)v73, v215.f32[v107 + 2]);
                    v121.i32[3] = v215.i32[v107 + 3];
                    *(float32x4_t *)((char *)&v215 + v107 * 4) = v121;
                    v107 += 4;
                  }
                  while (v107 != 16);
                }
                else
                {
                  int v100 = (int)v63;
                  uint64_t v101 = 0;
                  double v102 = v94;
                  do
                  {
                    int8x16_t v103 = (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)&v215.f32[v101]);
                    float64x2_t v104 = vmulq_n_f64((float64x2_t)vextq_s8(v103, v103, 8uLL), v102);
                    float64x2_t v105 = vmulq_n_f64((float64x2_t)v103, v96);
                    *(void *)&v106.f64[0] = *(_OWORD *)&vsubq_f64(v105, v104);
                    v106.f64[1] = vaddq_f64(v105, v104).f64[1];
                    *(float32x2_t *)&v215.f32[v101] = vcvt_f32_f64(v106);
                    v101 += 4;
                  }
                  while (v101 != 16);
                }
                v84.i32[3] = 0;
                float32x4_t v215 = vaddq_f32(v215, (float32x4_t)v84);
                float32x4_t v216 = vaddq_f32(v216, (float32x4_t)v84);
                unsigned int v122 = v80;
                CFStringRef v123 = (float32x4_t *)(v82 + 48 * v80);
                float32x4_t v217 = vaddq_f32(v217, (float32x4_t)v84);
                float32x4_t v218 = vaddq_f32(v218, (float32x4_t)v84);
                if (v192)
                {
                  if ((LOBYTE(v209[9].f64[0]) & 0x1F) != 0)
                  {
                    CA::Transform::apply_to_point4((uint64_t)v209, (float32x2_t *)&v215, (float32x2_t *)&v215, (const float *)0x10, 4);
                    float32x4_t v77 = 0uLL;
                    uint64_t v124 = 0;
                    float v125 = v123;
                    do
                    {
                      *float v125 = *(float32x4_t *)((char *)&v215 + v124);
                      v125 += 3;
                      v124 += 16;
                    }
                    while (v124 != 64);
                  }
                  else
                  {
                    unint64_t v128 = 0;
                    float64x2_t v129 = v209[6];
                    uint64_t v130 = (void *)(v82 + 48 * v122 + 8);
                    do
                    {
                      *(v130 - 1) = vcvt_f32_f64(vaddq_f64(v129, vcvtq_f64_f32(*(float32x2_t *)&v215.f32[v128 / 4])));
                      *uint64_t v130 = v215.i64[v128 / 8 + 1];
                      v130 += 6;
                      v128 += 16;
                    }
                    while (v128 != 64);
                  }
                }
                else
                {
                  uint64_t v126 = 0;
                  float v127 = v123;
                  do
                  {
                    *float v127 = *(float32x4_t *)((char *)&v215 + v126);
                    v127 += 3;
                    v126 += 16;
                  }
                  while (v126 != 64);
                }
                *(void *)(v82 + 48 * v122 + 16) = v214.i64[0];
                v123[4].i32[0] = v214.i32[2];
                v123[4].i32[1] = v214.i32[1];
                v123[7].i64[0] = v214.i64[1];
                v123[10].i32[0] = v214.i32[0];
                v123[10].i32[1] = v214.i32[3];
                float v131 = v74[5].f32[0];
                if (v131 != 0.0)
                {
                  float v132 = *(float *)(v191 + 224);
                  float v133 = floorf(v131 / v132);
                  v134.f32[0] = floorf(v131 - (float)(v133 * v132));
                  v134.f32[1] = v133;
                  float32x2_t v135 = vmul_f32(v134, vsub_f32(*(float32x2_t *)&v214.u32[2], *(float32x2_t *)v214.f32));
                  for (uint64_t i = 1; i != 13; i += 3)
                    *(float32x2_t *)v123[i].f32 = vadd_f32(*(float32x2_t *)v123[i].f32, v135);
                }
                int32x4_t v137 = (int32x4_t)vmaxq_f32(vminq_f32(v74[4], v197), v77);
                float32x4_t v138 = (float32x4_t)vdupq_laneq_s32(v137, 3);
                v138.i32[3] = 1.0;
                v139.i64[0] = 0x3F0000003F000000;
                v139.i64[1] = 0x3F0000003F000000;
                int32x4_t v140 = vcvtq_s32_f32(vmlaq_f32(v139, v138, vmulq_f32((float32x4_t)v137, v195)));
                *(int16x4_t *)v140.i8 = vmovn_s32(v140);
                unsigned int v141 = vuzp1_s8(*(int8x8_t *)v140.i8, *(int8x8_t *)v140.i8).u32[0];
                if (v210 != 0x3C003C003C003C00)
                {
                  unsigned int v142 = CA::OGL::ExtendedColor::word32(v187);
                  float32x4_t v77 = 0uLL;
                  *(int8x8_t *)v140.i8 = vand_s8((int8x8_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v141 >> 8), (int8x8_t)0xFF0000FF00), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v142), v188), (int8x8_t)0xFF000000FFLL), (int32x2_t)0x100000001)), (int8x8_t)0x1FF0001FF0000);
                  unsigned int v141 = (((v141 >> 8) & 0xFF0000) + ((v141 >> 8) & 0xFF0000) * HIBYTE(v142)) & 0xFF000000 | ((v141 * v142 + v141) >> 8) | v140.i32[0] | v140.i32[1];
                }
                v140.i32[0] = v141;
                v140.i32[1] = v141 >> 8;
                v140.i32[2] = HIWORD(v141);
                v73.i64[0] = 0xFF000000FFLL;
                v73.i64[1] = 0xFF000000FFLL;
                int32x4_t v143 = (int32x4_t)vandq_s8((int8x16_t)v140, (int8x16_t)v73);
                v143.i32[3] = vshrq_n_u32((uint32x4_t)vdupq_n_s32(v141), 0x18uLL).i32[3];
                int32x4_t v72 = vdupq_n_s32(0x3B808081u);
                *(float16x4_t *)v143.i8 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_s32(v143), (float32x4_t)v72));
                *(void *)(v82 + 48 * v122 + 32) = v143.i64[0];
                v123[5].i64[0] = v143.i64[0];
                v123[8].i64[0] = v143.i64[0];
                v123[11].i64[0] = v143.i64[0];
                if (!v199)
                {
                  v123[9].i32[2] = 0;
                  v123[6].i32[2] = 0;
                  v123[3].i32[2] = 0;
                  *(_DWORD *)(v82 + 48 * v122 + 8) = 0;
                }
                if (*(void *)(v8 + 96))
                {
                  CA::OGL::Context::array_indices(v8, *(_DWORD *)(v8 + 128));
                  float32x4_t v77 = 0uLL;
                }
                *(void *)(v8 + 128) += 4;
                LODWORD(v63) = v100 + 1;
                uint64_t v78 = (float32x4_t *)v198;
                goto LABEL_134;
              }
              int v56 = 0;
              int v199 = 0;
            }
            else
            {
              int v56 = 0;
              int v175 = 0;
              int v199 = 2;
              int v54 = 1;
              if (v181 < 0x81) {
                goto LABEL_66;
              }
            }
            *(void *)(v8 + 816) = v209;
            ++*(_DWORD *)(v8 + 256);
            int v175 = 1;
            goto LABEL_66;
          }
          __int16 v41 = 56;
          __int16 v39 = v213;
        }
LABEL_35:
        LOWORD(v213) = v39 & 0xFF00 | v41;
        goto LABEL_36;
      }
LABEL_179:
      *(unsigned char *)(*(void *)(v8 + 16) + 16) = 0;
    }
  }
  return result;
}

void sub_1848C313C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::FrameRateRangeGroup::remove(int8x8_t *this, CAFrameRateRange a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  CAFrameRateRange v24 = a2;
  unint64_t v3 = CA::FrameRateRangeGroup::fps_range_to_frame_interval_range((CA::FrameRateRangeGroup *)this, a2);
  unsigned int v5 = v4;
  uint64_t v6 = this + 7;
  int v7 = std::__hash_table<std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,std::__unordered_map_hasher<CAFrameRateRange,std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,CAFrameRateRangeHasher,std::equal_to<CAFrameRateRange>,true>,std::__unordered_map_equal<CAFrameRateRange,std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,std::equal_to<CAFrameRateRange>,CAFrameRateRangeHasher,true>,std::allocator<std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>>>::find<CAFrameRateRange>(&this[7], &v24.minimum);
  if (v7)
  {
    uint64_t v8 = *((void *)v7 + 6);
    if (!v8 || *((_DWORD *)v7 + 8) != v3 || *(void *)(v7 + 9) != __PAIR64__(v5, HIDWORD(v3))) {
      __assert_rtn("remove", "CAFrameRateRangeGroup.mm", 178, "info.count > 0 && info.range == range");
    }
    uint64_t v9 = v8 - 1;
    if (v9)
    {
      *((void *)v7 + 6) = v9;
    }
    else
    {
      int8x8_t v11 = this[12];
      int8x8_t v10 = this[13];
      if (*(void *)&v11 != *(void *)&v10)
      {
        while (**(_DWORD **)&v11 != v3 || *(void *)(*(void *)&v11 + 4) != __PAIR64__(v5, HIDWORD(v3)))
        {
          *(void *)&v11 += 12;
          if (*(void *)&v11 == *(void *)&v10)
          {
            int8x8_t v11 = this[13];
            break;
          }
        }
      }
      if (*(void *)&v11 == *(void *)&v10) {
        __assert_rtn("remove", "CAFrameRateRangeGroup.mm", 183, "it != _ranges.end ()");
      }
      uint64_t v12 = *(void *)&v10 - (*(void *)&v11 + 12);
      if (*(void *)&v10 != *(void *)&v11 + 12) {
        memmove(*(void **)&v11, (const void *)(*(void *)&v11 + 12), *(void *)&v10 - (*(void *)&v11 + 12));
      }
      this[13] = (int8x8_t)(*(void *)&v11 + v12);
      float32x4_t v13 = std::__hash_table<std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,std::__unordered_map_hasher<CAFrameRateRange,std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,CAFrameRateRangeHasher,std::equal_to<CAFrameRateRange>,true>,std::__unordered_map_equal<CAFrameRateRange,std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,std::equal_to<CAFrameRateRange>,CAFrameRateRangeHasher,true>,std::allocator<std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>>>::find<CAFrameRateRange>(&this[7], &v24.minimum);
      if (v13)
      {
        int8x8_t v14 = this[8];
        unint64_t v15 = *((void *)v13 + 1);
        uint8x8_t v16 = (uint8x8_t)vcnt_s8(v14);
        v16.i16[0] = vaddlv_u8(v16);
        if (v16.u32[0] > 1uLL)
        {
          if (v15 >= *(void *)&v14) {
            v15 %= *(void *)&v14;
          }
        }
        else
        {
          v15 &= *(void *)&v14 - 1;
        }
        unint64_t v18 = *(float **)(*(void *)v6 + 8 * v15);
        do
        {
          unsigned int v19 = v18;
          unint64_t v18 = *(float **)v18;
        }
        while (v18 != v13);
        if (v19 == (float *)&this[9]) {
          goto LABEL_40;
        }
        unint64_t v20 = *((void *)v19 + 1);
        if (v16.u32[0] > 1uLL)
        {
          if (v20 >= *(void *)&v14) {
            v20 %= *(void *)&v14;
          }
        }
        else
        {
          v20 &= *(void *)&v14 - 1;
        }
        if (v20 != v15)
        {
LABEL_40:
          if (!*(void *)v13) {
            goto LABEL_41;
          }
          unint64_t v21 = *(void *)(*(void *)v13 + 8);
          if (v16.u32[0] > 1uLL)
          {
            if (v21 >= *(void *)&v14) {
              v21 %= *(void *)&v14;
            }
          }
          else
          {
            v21 &= *(void *)&v14 - 1;
          }
          if (v21 != v15) {
LABEL_41:
          }
            *(void *)(*(void *)v6 + 8 * v15) = 0;
        }
        uint64_t v22 = *(void *)v13;
        if (*(void *)v13)
        {
          unint64_t v23 = *(void *)(v22 + 8);
          if (v16.u32[0] > 1uLL)
          {
            if (v23 >= *(void *)&v14) {
              v23 %= *(void *)&v14;
            }
          }
          else
          {
            v23 &= *(void *)&v14 - 1;
          }
          if (v23 != v15)
          {
            *(void *)(*(void *)v6 + 8 * v23) = v19;
            uint64_t v22 = *(void *)v13;
          }
        }
        *(void *)unsigned int v19 = v22;
        *(void *)float32x4_t v13 = 0;
        --*(void *)&this[10];
        operator delete(v13);
      }
    }
  }
  else if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    uint64_t v17 = x_log_category_utilities;
    if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl(&dword_184668000, v17, OS_LOG_TYPE_ERROR, "Unmatched FrameRateRangeGroup remove.", buf, 2u);
    }
  }
}

float *std::__hash_table<std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,std::__unordered_map_hasher<CAFrameRateRange,std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,CAFrameRateRangeHasher,std::equal_to<CAFrameRateRange>,true>,std::__unordered_map_equal<CAFrameRateRange,std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,std::equal_to<CAFrameRateRange>,CAFrameRateRangeHasher,true>,std::allocator<std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>>>::find<CAFrameRateRange>(void *a1, float *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  float v3 = a2[1];
  float v4 = a2[2];
  unint64_t v5 = ((uint64_t)(int)v3 << 16) | ((unint64_t)(int)*a2 << 32) | (int)v4;
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = ((uint64_t)(int)v3 << 16) | ((unint64_t)(int)*a2 << 32) | (int)v4;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  uint64_t v8 = *(float ***)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  for (CFTypeRef result = *v8; result; CFTypeRef result = *(float **)result)
  {
    unint64_t v10 = *((void *)result + 1);
    if (v10 == v5)
    {
      if (result[4] == *a2 && result[5] == v3 && result[6] == v4) {
        return result;
      }
    }
    else
    {
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(void *)&v2) {
          v10 %= *(void *)&v2;
        }
      }
      else
      {
        v10 &= *(void *)&v2 - 1;
      }
      if (v10 != v7) {
        return 0;
      }
    }
  }
  return result;
}

void sub_1848C362C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1848C3798(_Unwind_Exception *a1)
{
  MEMORY[0x185323DC0](v1, 0x10A0C40DF5EECE8);
  _Unwind_Resume(a1);
}

void CA::Render::LayerNode::MapRects::apply(uint64_t a1, float64x2_t *this, double *a3)
{
  if (*(void *)(a1 + 8))
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      CA::Mat4Impl::mat4_apply_to_rect(this, (int8x16_t *)(*(void *)(a1 + 16) + v5), a3);
      ++v6;
      v5 += 32;
    }
    while (v6 < *(void *)(a1 + 8));
  }
}

double CA::Render::LayerNode::MapTransform::apply(uint64_t a1, const double *a2, uint64_t a3, const double *a4)
{
  *(void *)&double result = *(_OWORD *)&CA::Mat4Impl::mat4_concat((float64x2_t *)*(void *)(a1 + 8), (double *)*(void *)(a1 + 8), a2, a4);
  return result;
}

char *___ZN2CA6Render18LayerNodeAllocator10alloc_nodeEv_block_invoke()
{
  v5[1] = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!vm_allocate(*MEMORY[0x1E4F14960], v5, (*MEMORY[0x1E4F14B00] + 1146879) & -*MEMORY[0x1E4F14B00], 1)) {
    CA::Render::LayerNodeAllocator::_datCGFloat a = v5[0];
  }
  double result = (char *)malloc_type_malloc(0x2000uLL, 0x1000040BDFB0063uLL);
  uint64_t v1 = 0;
  CA::Render::LayerNodeAllocator::_free_offsets = (uint64_t)result;
  int16x8_t v2 = (int16x8_t)xmmword_184998380;
  v3.i64[0] = 0xF000F000F000F000;
  v3.i64[1] = 0xF000F000F000F000;
  v4.i64[0] = 0x8000800080008;
  v4.i64[1] = 0x8000800080008;
  do
  {
    *(int16x8_t *)&result[v1] = vsubq_s16(v3, v2);
    int16x8_t v2 = vaddq_s16(v2, v4);
    v1 += 16;
  }
  while (v1 != 0x2000);
  CA::Render::LayerNodeAllocator::_free_offsets_count = 4096;
  return result;
}

void sub_1848C3A28(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1848C3EBC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1848C3F40(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

xpc_object_t encode_batch_handle_port(unint64_t a1, uint64_t a2, int a3)
{
  do
    unsigned int add = atomic_fetch_add(next_batch_encode_count(void)::last_encode_count, 1u);
  while (add == -1);
  uint64_t v6 = (add + 1) | (unint64_t)((uint64_t)getpid() << 32);
  kdebug_trace();
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v7, "e", v6);
  if (a2) {
    xpc_dictionary_set_uint64(v7, "f", a2);
  }
  if ((a3 - 1) <= 0xFFFFFFFD) {
    xpc_dictionary_set_mach_send();
  }
  return v7;
}

void sub_1848C4268(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

CFStringRef CA::Render::key_path_copy_string(unint64_t this, void *const *a2)
{
  unint64_t v2 = this;
  v18[1] = *MEMORY[0x1E4F143B8];
  if (!this) {
    return (CFStringRef)v2;
  }
  if ((this & 1) == 0)
  {
    CFIndex v3 = *(unsigned int *)this;
    MEMORY[0x1F4188790](this);
    uint64_t v5 = (const void **)((char *)v18 - ((v4 + 15) & 0xFFFFFFFF0));
    bzero(v5, v4);
    if (v3)
    {
      uint64_t v6 = (unsigned int *)(v2 + 4);
      CFIndex v7 = v3;
      uint64_t v8 = v5;
      do
      {
        unsigned int v10 = *v6++;
        unsigned int v9 = v10;
        if ((v10 & 0x40000000) != 0)
        {
          uint64_t v12 = (void *)CFStringCreateWithFormat(0, 0, @"@index(%d)", v9 & 0xBFFFFFFF);
        }
        else
        {
          String = CAAtomGetString(v9);
          uint64_t v12 = (void *)CFRetain(String);
        }
        *v8++ = v12;
        --v7;
      }
      while (v7);
    }
    CFArrayRef v13 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF98], v5, v3, 0);
    unint64_t v2 = (unint64_t)CFStringCreateByCombiningStrings(0, v13, @".");
    CFRelease(v13);
    if (v3)
    {
      do
      {
        int8x8_t v14 = *v5++;
        CFRelease(v14);
        --v3;
      }
      while (v3);
    }
    return (CFStringRef)v2;
  }
  unint64_t v16 = this >> 1;
  if (((v2 >> 1) & 0x40000000) != 0) {
    return CFStringCreateWithFormat(0, 0, @"@index(%d)", v16 & 0xBFFFFFFF);
  }
  uint64_t v17 = CAAtomGetString(v16);

  return (CFStringRef)CFRetain(v17);
}

void CA::Render::Path::show(CA::Render::Path *this, int a2, char a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if ((a3 & 1) == 0)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v5 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl(&dword_184668000, v5, OS_LOG_TYPE_DEFAULT, "(path", buf, 2u);
      }
    }
    uint64_t v6 = (unsigned char *)*((void *)this + 5);
    if (*v6 != 5)
    {
      CFIndex v7 = (CA::Render *)(a2 + 1);
      uint64_t v8 = v6 + 1;
      unsigned int v9 = (uint64_t *)*((void *)this + 4);
      do
      {
        CA::Render::show_newline(v7);
        switch(*(v8 - 1))
        {
          case 0u:
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              unsigned int v10 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)uint64_t buf = 0;
                _os_log_impl(&dword_184668000, v10, OS_LOG_TYPE_DEFAULT, "h", buf, 2u);
              }
            }
            break;
          case 1u:
            if (x_log_hook_p()) {
              goto LABEL_14;
            }
            uint64_t v11 = x_log_category_render;
            if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_26;
            }
            uint64_t v12 = *v9;
            uint64_t v13 = v9[1];
            *(_DWORD *)uint64_t buf = 134218240;
            uint64_t v34 = v12;
            __int16 v35 = 2048;
            uint64_t v36 = v13;
            int8x8_t v14 = v11;
            unint64_t v15 = "%g %g m";
            goto LABEL_25;
          case 2u:
            if (x_log_hook_p())
            {
LABEL_14:
              x_log_();
            }
            else
            {
              uint64_t v16 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v17 = *v9;
                uint64_t v18 = v9[1];
                *(_DWORD *)uint64_t buf = 134218240;
                uint64_t v34 = v17;
                __int16 v35 = 2048;
                uint64_t v36 = v18;
                int8x8_t v14 = v16;
                unint64_t v15 = "%g %g l";
LABEL_25:
                _os_log_impl(&dword_184668000, v14, OS_LOG_TYPE_DEFAULT, v15, buf, 0x16u);
              }
            }
LABEL_26:
            v9 += 2;
            break;
          case 3u:
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              unsigned int v19 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v20 = *v9;
                uint64_t v21 = v9[1];
                uint64_t v22 = v9[2];
                uint64_t v23 = v9[3];
                *(_DWORD *)uint64_t buf = 134218752;
                uint64_t v34 = v20;
                __int16 v35 = 2048;
                uint64_t v36 = v21;
                __int16 v37 = 2048;
                uint64_t v38 = v22;
                __int16 v39 = 2048;
                uint64_t v40 = v23;
                _os_log_impl(&dword_184668000, v19, OS_LOG_TYPE_DEFAULT, "%g %g %g %g q", buf, 0x2Au);
              }
            }
            v9 += 4;
            break;
          case 4u:
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              CAFrameRateRange v24 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v25 = *v9;
                uint64_t v26 = v9[1];
                uint64_t v27 = v9[2];
                uint64_t v28 = v9[3];
                uint64_t v29 = v9[4];
                uint64_t v30 = v9[5];
                *(_DWORD *)uint64_t buf = 134219264;
                uint64_t v34 = v25;
                __int16 v35 = 2048;
                uint64_t v36 = v26;
                __int16 v37 = 2048;
                uint64_t v38 = v27;
                __int16 v39 = 2048;
                uint64_t v40 = v28;
                __int16 v41 = 2048;
                uint64_t v42 = v29;
                __int16 v43 = 2048;
                uint64_t v44 = v30;
                _os_log_impl(&dword_184668000, v24, OS_LOG_TYPE_DEFAULT, "%g %g %g %g %g %g c", buf, 0x3Eu);
              }
            }
            v9 += 6;
            break;
          default:
            break;
        }
        int v31 = *v8++;
      }
      while (v31 != 5);
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v32 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl(&dword_184668000, v32, OS_LOG_TYPE_DEFAULT, ")", buf, 2u);
      }
    }
  }
}

uint64_t CA::Render::Path::interpolate(CA::Render::Path *this, int a2, int a3, float64x2_t *a4, float64x2_t *a5, float64x2_t *a6, long double *a7, unint64_t a8, float a9, float a10)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  if (!a3 || (uint64_t result = (uint64_t)CA::Render::Path::keyframe_lengths(this)) != 0)
  {
    uint64_t v21 = (unsigned char *)*((void *)this + 5);
    int v22 = *v21;
    if (*v21) {
      _ZF = v22 == 5;
    }
    else {
      _ZF = 1;
    }
    if (_ZF) {
      return 0;
    }
    CAFrameRateRange v24 = (float64x2_t *)*((void *)this + 4);
    __int32 v83 = a6;
    if (v22 == 1)
    {
      if (a5) {
        *a5 = *v24;
      }
      uint64_t v25 = v24++;
    }
    else
    {
      uint64_t v25 = 0;
    }
    uint64_t v26 = v21 + 1;
    if (a2 >= 1)
    {
      int v27 = 0;
      uint64_t v28 = v25;
      while (2)
      {
        switch(*v26)
        {
          case 0:
            goto LABEL_19;
          case 1:
            uint64_t v28 = v24;
            uint64_t v25 = v24++;
            goto LABEL_20;
          case 2:
            uint64_t v25 = v24++;
            goto LABEL_19;
          case 3:
            uint64_t v25 = v24 + 1;
            v24 += 2;
            goto LABEL_19;
          case 4:
            uint64_t v25 = v24 + 2;
            v24 += 3;
LABEL_19:
            ++v27;
LABEL_20:
            ++v26;
            if (v27 < a2) {
              continue;
            }
            if (!v25) {
              return 0;
            }
            goto LABEL_24;
          default:
            return 0;
        }
      }
    }
    uint64_t v28 = v25;
    if (!v25)
    {
      return 0;
    }
    else
    {
LABEL_24:
      while (*v26 == 1)
      {
        uint64_t v28 = v24;
        uint64_t v25 = v24++;
        ++v26;
      }
      switch(*v26)
      {
        case 0:
          *a4 = vmlaq_n_f64(*v25, vsubq_f64(*v28, *v25), a9);
          if (a7) {
            *a7 = atan2(v28->f64[1] - v25->f64[1], v28->f64[0] - v25->f64[0]);
          }
          uint64_t v29 = v28;
          if (!a8) {
            goto LABEL_81;
          }
          goto LABEL_35;
        case 2:
          *a4 = vmlaq_n_f64(*v25, vsubq_f64(*v24, *v25), a9);
          if (a7) {
            *a7 = atan2(v24->f64[1] - v25->f64[1], v24->f64[0] - v25->f64[0]);
          }
          uint64_t v29 = v24;
          if (!a8) {
            goto LABEL_81;
          }
LABEL_35:
          float64x2_t v30 = vsubq_f64(*v29, *v25);
          goto LABEL_80;
        case 3:
          float64x2_t v31 = *v25;
          float64x2_t v32 = v24[1];
          float64x2_t v33 = vaddq_f64(*v24, *v24);
          float64x2_t v34 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
          float64x2_t v35 = vmulq_f64(vaddq_f64(v33, *v25), v34);
          float64x2_t v36 = vmulq_f64(vaddq_f64(v33, v32), v34);
          if (!a3) {
            goto LABEL_74;
          }
          goto LABEL_39;
        case 4:
          float64x2_t v31 = *v25;
          float64x2_t v35 = *v24;
          float64x2_t v36 = v24[1];
          float64x2_t v32 = v24[2];
          if (!a3) {
            goto LABEL_74;
          }
LABEL_39:
          double v37 = *(double *)(*((void *)this + 8) + 8 * a2) * a9;
          uint64_t v105 = 0;
          memset(v104, 0, sizeof(v104));
          uint64_t v103 = 0;
          memset(v102, 0, sizeof(v102));
          uint64_t v101 = 0;
          memset(v100, 0, sizeof(v100));
          uint64_t v99 = 0;
          memset(v98, 0, sizeof(v98));
          uint64_t v97 = 0;
          memset(v96, 0, sizeof(v96));
          uint64_t v95 = 0;
          memset(v94, 0, sizeof(v94));
          uint64_t v93 = 0;
          memset(v92, 0, sizeof(v92));
          uint64_t v91 = 0;
          memset(v90, 0, sizeof(v90));
          memset(v88, 0, sizeof(v88));
          memset(v86, 0, sizeof(v86));
          memset(v84, 0, sizeof(v84));
          a9 = 0.0;
          uint64_t v89 = 0;
          uint64_t v87 = 0;
          uint64_t v85 = 0;
          if (v37 == 0.0) {
            goto LABEL_74;
          }
          float64x2_t v38 = vsubq_f64(v32, v36);
          double v39 = v36.f64[1];
          double v40 = v32.f64[1];
          float64x2_t v41 = vsubq_f64(v35, v31);
          double v42 = vaddvq_f64(vmulq_f64(v41, v41));
          double v43 = vmulq_f64(v38, v38).f64[0] + (v32.f64[1] - v36.f64[1]) * (v32.f64[1] - v36.f64[1]);
          double v44 = v42 <= 0.0 ? 1.79769313e308 : 1.0 / sqrt(v42);
          double v45 = v44 * v42;
          double v46 = v43 <= 0.0 ? 1.79769313e308 : 1.0 / sqrt(v43);
          double v47 = v46 * v43;
          if (COERCE__INT64(fabs(v46 * v43 + v45)) > 0x7FEFFFFFFFFFFFFFLL) {
            goto LABEL_74;
          }
          LODWORD(v48) = 0;
          double v49 = v31.f64[1];
          double v50 = v35.f64[1];
          double v51 = 0.0;
          double v52 = v35.f64[0];
          double v53 = v36.f64[0];
          double v54 = v32.f64[0];
          double v55 = v31.f64[0];
          double v56 = 0.0;
          double v57 = 1.0;
          break;
        default:
          return 0;
      }
      while (1)
      {
        uint64_t v58 = (int)v48;
        if ((int)v48 <= 29) {
          LODWORD(v48) = 29;
        }
        if (v58 <= 29) {
          uint64_t v59 = 29;
        }
        else {
          uint64_t v59 = v58;
        }
        while (1)
        {
          double v60 = (v53 - v52) * (v53 - v52) + (v39 - v50) * (v39 - v50);
          double v61 = v60 <= 0.0 ? 1.79769313e308 : 1.0 / sqrt(v60);
          double v62 = (v40 - v49) * (v40 - v49) + (v54 - v55) * (v54 - v55);
          double v63 = v62 <= 0.0 ? 1.79769313e308 : 1.0 / sqrt(v62);
          double v64 = v61 * v60;
          double v65 = v63 * v62;
          double v66 = v47 + v45 + v64;
          if (v59 == v58) {
            break;
          }
          double v67 = vabdd_f64(v45, v64) + vabdd_f64(v64, v47);
          if (v66 - v65 <= v57 && v67 < 1.0)
          {
            LODWORD(v48) = v58;
            break;
          }
          double v57 = v57 * 0.5;
          *((double *)v84 + v58) = v57;
          *((double *)v98 + v58) = v54;
          *((double *)v86 + v58) = v40;
          *((double *)v100 + v58) = (v54 + v53) * 0.5;
          *((double *)v88 + v58) = (v40 + v39) * 0.5;
          *((double *)v102 + v58) = (v52 + v53 * 2.0 + v54) * 0.25;
          *((double *)v90 + v58) = (v50 + v39 * 2.0 + v40) * 0.25;
          double v54 = (v54 + (v53 + v52) * 3.0 + v55) * 0.125;
          *((double *)v104 + v58) = v54;
          double v40 = (v49 + (v39 + v50) * 3.0 + v40) * 0.125;
          *((double *)v92 + v58) = v40;
          double v53 = (v53 + v52 * 2.0 + v55) * 0.25;
          *((double *)v94 + v58) = v47 * 0.5;
          double v39 = (v49 + v50 * 2.0 + v39) * 0.25;
          double v69 = (v40 - v39) * (v40 - v39) + (v54 - v53) * (v54 - v53);
          if (v69 <= 0.0) {
            double v70 = 1.79769313e308;
          }
          else {
            double v70 = 1.0 / sqrt(v69);
          }
          double v52 = (v55 + v52) * 0.5;
          double v50 = (v50 + v49) * 0.5;
          double v45 = v45 * 0.5;
          double v47 = v70 * v69;
          *((double *)v96 + v58++) = v47;
        }
        double v71 = (v65 + v66) * 0.5;
        double v72 = v71 + v51;
        if (v71 + v51 >= v37)
        {
          a9 = fmin(v57 * (v37 - v51) / v71 + v56, 1.0);
          goto LABEL_74;
        }
        if (!v48) {
          break;
        }
        uint64_t v48 = (int)v48 - 1;
        double v56 = v57 + v56;
        double v55 = *((double *)v104 + v48);
        double v49 = *((double *)v92 + v48);
        double v52 = *((double *)v102 + v48);
        double v50 = *((double *)v90 + v48);
        double v53 = *((double *)v100 + v48);
        double v39 = *((double *)v88 + v48);
        double v54 = *((double *)v98 + v48);
        double v40 = *((double *)v86 + v48);
        double v45 = *((double *)v96 + v48);
        double v51 = v72;
        double v47 = *((double *)v94 + v48);
        double v57 = *((double *)v84 + v48);
      }
      a9 = 1.0;
LABEL_74:
      double v73 = 1.0 - a9;
      *a4 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v32, a9 * a9 * a9), v35, v73 * v73 * (a9 * 3.0)), v31, v73 * v73 * v73), v36, a9 * 3.0 * a9 * v73);
      if ((unint64_t)a7 | a8)
      {
        __asm { FMOV            V16.2D, #3.0 }
        float64x2_t v30 = vmlaq_n_f64(vmlaq_n_f64(vmulq_f64(vsubq_f64(v35, v31), _Q16), vaddq_f64(vsubq_f64(v36, vaddq_f64(v35, v35)), v31), a9 * 6.0), vmlaq_f64(vsubq_f64(v32, v31), _Q16, vsubq_f64(v35, v36)), a9 * a9 * 3.0);
        if (a7)
        {
          float64x2_t v82 = v30;
          long double v77 = atan2(v30.f64[1], v30.f64[0]);
          float64x2_t v30 = v82;
          *a7 = v77;
        }
        if (a3) {
          float64x2_t v30 = vmulq_n_f64(v30, *(double *)(*((void *)this + 8) + 8 * a2) / sqrt(vaddvq_f64(vmulq_f64(v30, v30))));
        }
        if (a8) {
LABEL_80:
        }
          *(float64x2_t *)a8 = vmulq_n_f64(v30, a10);
      }
LABEL_81:
      if (v83)
      {
        int v78 = *v26;
        if (v78 == 5)
        {
          uint64_t v79 = v83;
        }
        else
        {
          uint64_t v80 = v26 + 1;
          uint64_t v79 = v83;
          do
          {
            switch(v78)
            {
              case 0:
                uint64_t v25 = v28;
                break;
              case 1:
                uint64_t v28 = v24;
                goto LABEL_88;
              case 2:
LABEL_88:
                uint64_t v25 = v24++;
                break;
              case 3:
                uint64_t v25 = v24 + 1;
                v24 += 2;
                break;
              case 4:
                uint64_t v25 = v24 + 2;
                v24 += 3;
                break;
              default:
                break;
            }
            int v81 = *v80++;
            int v78 = v81;
          }
          while (v81 != 5);
        }
        *uint64_t v79 = *v25;
      }
      return 1;
    }
  }
  return result;
}

void std::vector<unsigned char>::push_back[abi:nn180100](unint64_t *a1, char a2)
{
  uint64_t v5 = (unsigned char *)a1[1];
  unint64_t v4 = a1[2];
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = *a1;
    uint64_t v8 = &v5[-*a1];
    unint64_t v9 = (unint64_t)(v8 + 1);
    if ((uint64_t)(v8 + 1) < 0) {
      abort();
    }
    unint64_t v10 = v4 - v7;
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v9;
    }
    if (v11) {
      unint64_t v12 = (unint64_t)operator new(v11);
    }
    else {
      unint64_t v12 = 0;
    }
    uint64_t v13 = (char *)(v12 + v11);
    v8[v12] = a2;
    uint64_t v6 = (uint64_t)&v8[v12 + 1];
    if (v5 == (unsigned char *)v7)
    {
      v12 += (unint64_t)v8;
    }
    else
    {
      int8x8_t v14 = &v5[~v7];
      do
      {
        char v15 = *--v5;
        (v14--)[v12] = v15;
      }
      while (v5 != (unsigned char *)v7);
      uint64_t v5 = (unsigned char *)*a1;
    }
    *a1 = v12;
    a1[1] = v6;
    a1[2] = (unint64_t)v13;
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    unsigned char *v5 = a2;
    uint64_t v6 = (uint64_t)(v5 + 1);
  }
  a1[1] = v6;
}

float64x2_t CA::Render::point_interpolate(float64x2_t *this, double *a2, const double *a3, const double *a4, float64x2_t a5, float64x2_t a6, double a7, double a8, double a9)
{
  float v9 = a8;
  if (v9 < -3.1416 || v9 > 3.1416) {
    float v9 = (float)((float)((float)((float)(v9 * 0.15915) + 0.5) - floorf((float)(v9 * 0.15915) + 0.5)) * 6.2832) + -3.1416;
  }
  float v10 = a9;
  if (v10 < -3.1416 || v10 > 3.1416) {
    float v10 = (float)((float)((float)((float)(v10 * 0.15915) + 0.5) - floorf((float)(v10 * 0.15915) + 0.5)) * 6.2832)
  }
        + -3.1416;
  float32x2_t v11 = vcvt_f32_f64(a6);
  float32x2_t v12 = vcvt_f32_f64(a5);
  float v13 = (float)((float)((float)((float)(0.039228 - (float)((float)(v9 * v9) * 0.00096967)) * (float)(v9 * v9)) + -0.49535)
              * (float)(v9 * v9))
      + 0.99861;
  float v14 = 1.0 - a7;
  float v15 = v14 * v14;
  float v16 = a7 * (v14 + v14);
  float32x2_t v17 = vsub_f32(v11, v12);
  float32x2_t v18 = vmul_n_f32((float32x2_t)vrev64_s32((int32x2_t)v17), (float)((float)((float)((float)((float)(v9 * v9) * 0.0054654) + -0.15346) * (float)(v9 * v9)) + 0.98442) * v9);
  float32x2_t v19 = vmul_n_f32(v17, (float)((float)((float)((float)(0.039228 - (float)((float)(v10 * v10) * 0.00096967)) * (float)(v10 * v10))+ -0.49535)* (float)(v10 * v10))+ 0.99861);
  float32x2_t v20 = vsub_f32(v19, v18);
  float32x2_t v21 = (float32x2_t)vdup_lane_s32((int32x2_t)v20, 0);
  v20.i32[1] = vadd_f32(v19, v18).i32[1];
  float32x2_t v22 = vsub_f32(v12, v11);
  float32x2_t v23 = vmul_n_f32((float32x2_t)vrev64_s32((int32x2_t)v22), (float)((float)((float)((float)((float)(v10 * v10) * 0.0054654) + -0.15346) * (float)(v10 * v10)) + 0.98442)* v10);
  float32x2_t v24 = vmul_n_f32(v22, v13);
  v25.i32[0] = vsub_f32(v24, v23).u32[0];
  v25.i32[1] = vadd_f32(v24, v23).i32[1];
  float v26 = a7 * a7;
  v21.i32[0] = v22.i32[1];
  v22.i32[1] = v20.i32[1];
  float32x2_t v27 = vmla_f32(vneg_f32(vmul_f32(v22, (float32x2_t)vrev64_s32(v25))), (float32x2_t)v25, v21);
  float64x2_t result = vcvtq_f64_f32(vmla_n_f32(vmla_n_f32(vmul_n_f32(v12, v15), v11, v26), vmla_n_f32(v12, v20, vdiv_f32(v27, (float32x2_t)vdup_lane_s32((int32x2_t)v27, 1)).f32[0]), v16));
  *this = result;
  return result;
}

BOOL CA::Render::InterpolatedFunction::apply(CA::Render::InterpolatedFunction *this, uint64_t a2, const double *a3, uint64_t a4, double *a5, uint64_t a6, double (*a7)(unsigned int, const unsigned int *, unint64_t, void *), void *a8)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *((unsigned int *)this + 6);
  if (v8 <= 0x40)
  {
    MEMORY[0x1F4188790](this);
    float v15 = (char *)&v44 - ((v14 + 15) & 0x7FFFFFFF0);
    uint64_t v46 = v16;
    bzero(v15, v14);
    uint64_t v17 = v46;
    if (a2)
    {
      uint64_t v18 = 0;
      unint64_t v19 = *((void *)this + 2);
      unint64_t v44 = v19 - 1;
      unint64_t v45 = v19 - 2;
      unint64_t v20 = v8;
      unint64_t v21 = v8;
      unint64_t v22 = v8;
      unint64_t v23 = v8;
      unint64_t v24 = v8;
      while (1)
      {
        if (v19 < 2) {
          goto LABEL_40;
        }
        float v25 = *a3;
        float v26 = (float *)*((void *)this + 5);
        if (!v26) {
          break;
        }
        if (*v26 < v25)
        {
          if (*((unsigned char *)this + 13))
          {
            unint64_t v27 = 1;
            if (v45 >= 3)
            {
              unint64_t v28 = v44;
              unint64_t v29 = v45;
              unint64_t v27 = 1;
              do
              {
                unint64_t v30 = v27 + (v29 >> 1);
                if (v26[v30] <= v25) {
                  unint64_t v27 = v30;
                }
                else {
                  unint64_t v28 = v30;
                }
                unint64_t v29 = v28 - v27;
              }
              while (v28 - v27 > 2);
            }
          }
          else
          {
            unint64_t v27 = 1;
          }
          if (v27 < v19)
          {
            while (v26[v27] <= v25)
            {
              if (v19 == ++v27)
              {
                unint64_t v32 = v44;
                goto LABEL_32;
              }
            }
          }
          unint64_t v32 = v27 - 1;
          if (v27 == v19)
          {
LABEL_32:
            if (v23)
            {
              float64x2_t v33 = (const void *)(*((void *)this + 4) + 4 * v32 * v23);
              unint64_t v24 = v23;
LABEL_34:
              memmove(v15, v33, 4 * v24);
              uint64_t v17 = v46;
LABEL_40:
              unint64_t v20 = 0;
              if (v8)
              {
                float64x2_t v41 = (float *)v15;
                do
                {
                  float v42 = *v41++;
                  *(double *)((char *)a5 + v20) = v42;
                  v20 += 8;
                }
                while (8 * v8 != v20);
                unint64_t v20 = v8;
                unint64_t v21 = v8;
                unint64_t v22 = v8;
                unint64_t v23 = v8;
                unint64_t v24 = v8;
                goto LABEL_48;
              }
LABEL_44:
              unint64_t v21 = 0;
LABEL_45:
              unint64_t v22 = 0;
LABEL_46:
              unint64_t v23 = 0;
            }
            unint64_t v24 = 0;
            goto LABEL_48;
          }
          float v25 = (float)(v25 - v26[v32]) / (float)(v26[v27] - v26[v32]);
          if (!v20) {
            goto LABEL_44;
          }
          goto LABEL_38;
        }
        if (v24)
        {
          float64x2_t v33 = (const void *)*((void *)this + 4);
          goto LABEL_34;
        }
LABEL_48:
        a3 = (const double *)((char *)a3 + a4);
        a5 = (double *)((char *)a5 + v17);
        if (++v18 == a2) {
          return v8 < 0x41;
        }
      }
      if (v25 <= 0.0)
      {
        if (v22)
        {
          float64x2_t v33 = (const void *)*((void *)this + 4);
          unint64_t v24 = v22;
          goto LABEL_34;
        }
        goto LABEL_46;
      }
      if (v25 >= 1.0)
      {
        if (v21)
        {
          float64x2_t v33 = (const void *)(*((void *)this + 4) + 4 * v44 * v21);
          unint64_t v24 = v21;
          goto LABEL_34;
        }
        goto LABEL_45;
      }
      if (v19 < 3)
      {
        unint64_t v32 = 0;
        if (!v20) {
          goto LABEL_44;
        }
      }
      else
      {
        float v31 = *((float *)this + 7) * v25;
        unint64_t v32 = (unint64_t)v31;
        float v25 = v31 - truncf(v31);
        if (!v20) {
          goto LABEL_44;
        }
      }
LABEL_38:
      uint64_t v34 = *((void *)this + 4);
      float64x2_t v35 = (float *)(v34 + 4 * v32 * v20);
      float64x2_t v36 = (float *)(v34 + (4 * v32 + 4) * v20);
      double v37 = (float *)v15;
      do
      {
        float v38 = *v35++;
        float v39 = v38;
        float v40 = *v36++;
        *v37++ = v39 + (float)((float)(v40 - v39) * v25);
        --v20;
      }
      while (v20);
      goto LABEL_40;
    }
  }
  return v8 < 0x41;
}

uint64_t CA::Render::Function::name(CA::Render::Function *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t CA::Render::InterpolatedFunction::output_count(CA::Render::InterpolatedFunction *this)
{
  return *((unsigned int *)this + 6);
}

uint64_t CA::Render::InterpolatedFunction::input_count(CA::Render::InterpolatedFunction *this)
{
  return 1;
}

uint64_t CA::Render::InterpolatedFunction::function_type(CA::Render::InterpolatedFunction *this)
{
  return 2;
}

BOOL CA::Render::NamedFunction::apply(CA::Render::NamedFunction *this, double *a2, double *a3, uint64_t a4, double *a5, uint64_t a6, double (*a7)(unsigned int, const unsigned int *, unint64_t, void *), void *a8)
{
  if (a2)
  {
    BOOL v13 = 0;
    size_t v14 = 0;
    float v15 = a5 + 14;
    long long v16 = xmmword_184997D50;
    long long v17 = 0uLL;
    long long v18 = xmmword_184997D60;
    while (2)
    {
      switch(*((_DWORD *)this + 4))
      {
        case 0:
          double v19 = *a3;
          double v20 = 1.0;
          double v21 = 0.0;
          goto LABEL_6;
        case 1:
          double v19 = *a3;
          double v20 = 0.0;
          double v21 = 1.0;
LABEL_6:
          double v22 = 0.0;
          goto LABEL_8;
        case 2:
          double v19 = *a3;
          double v20 = 0.0;
          double v21 = 0.0;
          double v22 = 1.0;
LABEL_8:
          CA::Mat4Impl::mat4_set_rotation((CA::Mat4Impl *)(v15 - 14), a2, v19, v20, v21, v22);
          long long v18 = xmmword_184997D60;
          long long v16 = xmmword_184997D50;
          long long v17 = 0uLL;
          goto LABEL_23;
        case 3:
          uint64_t v23 = *(void *)a3;
          uint64_t v24 = *((void *)a3 + 1);
          uint64_t v25 = *((void *)a3 + 2);
          *((_OWORD *)v15 - 7) = v16;
          *((_OWORD *)v15 - 6) = v17;
          *((_OWORD *)v15 - 5) = v18;
          *((_OWORD *)v15 - 4) = v17;
          *((_OWORD *)v15 - 3) = v17;
          *((_OWORD *)v15 - 2) = v16;
          *((_OWORD *)v15 - 1) = v17;
          *(_OWORD *)float v15 = v18;
          *((void *)v15 - 14) = v23;
          *((void *)v15 - 9) = v24;
          *((void *)v15 - 4) = v25;
          goto LABEL_23;
        case 4:
          uint64_t v26 = *(void *)a3;
          *((_OWORD *)v15 - 7) = v16;
          *((_OWORD *)v15 - 6) = v17;
          *((_OWORD *)v15 - 5) = v18;
          *((_OWORD *)v15 - 4) = v17;
          *((_OWORD *)v15 - 3) = v17;
          *((_OWORD *)v15 - 2) = v16;
          *((_OWORD *)v15 - 1) = v17;
          *(_OWORD *)float v15 = v18;
          *((void *)v15 - 14) = v26;
          *(v15 - 9) = 1.0;
          goto LABEL_15;
        case 5:
          uint64_t v27 = *(void *)a3;
          *((_OWORD *)v15 - 7) = v16;
          *((_OWORD *)v15 - 6) = v17;
          *((_OWORD *)v15 - 5) = v18;
          *((_OWORD *)v15 - 4) = v17;
          *((_OWORD *)v15 - 3) = v17;
          *((_OWORD *)v15 - 2) = v16;
          *((_OWORD *)v15 - 1) = v17;
          *(_OWORD *)float v15 = v18;
          *(v15 - 14) = 1.0;
          goto LABEL_14;
        case 6:
          uint64_t v28 = *(void *)a3;
          *((_OWORD *)v15 - 7) = v16;
          *((_OWORD *)v15 - 6) = v17;
          *((_OWORD *)v15 - 5) = v18;
          *((_OWORD *)v15 - 4) = v17;
          *((_OWORD *)v15 - 3) = v17;
          *((_OWORD *)v15 - 2) = v16;
          *((_OWORD *)v15 - 1) = v17;
          *(_OWORD *)float v15 = v18;
          *(v15 - 14) = 1.0;
          *(v15 - 9) = 1.0;
          goto LABEL_17;
        case 7:
          uint64_t v27 = *(void *)a3;
          *((_OWORD *)v15 - 7) = v16;
          *((_OWORD *)v15 - 6) = v17;
          *((_OWORD *)v15 - 5) = v18;
          *((_OWORD *)v15 - 4) = v17;
          *((_OWORD *)v15 - 3) = v17;
          *((_OWORD *)v15 - 2) = v16;
          *((_OWORD *)v15 - 1) = v17;
          *(_OWORD *)float v15 = v18;
          *((void *)v15 - 14) = v27;
LABEL_14:
          *((void *)v15 - 9) = v27;
LABEL_15:
          *(v15 - 4) = 1.0;
          goto LABEL_23;
        case 8:
          uint64_t v28 = *(void *)a3;
          *((_OWORD *)v15 - 7) = v16;
          *((_OWORD *)v15 - 6) = v17;
          *((_OWORD *)v15 - 5) = v18;
          *((_OWORD *)v15 - 4) = v17;
          *((_OWORD *)v15 - 3) = v17;
          *((_OWORD *)v15 - 2) = v16;
          *((_OWORD *)v15 - 1) = v17;
          *(_OWORD *)float v15 = v18;
          *((void *)v15 - 14) = v28;
          *((void *)v15 - 9) = v28;
LABEL_17:
          *((void *)v15 - 4) = v28;
          goto LABEL_23;
        case 9:
          uint64_t v29 = *((void *)a3 + 2);
          long long v30 = *(_OWORD *)a3;
          *((_OWORD *)v15 - 7) = v16;
          *(v15 - 12) = 0.0;
          *(v15 - 11) = 0.0;
          *((_OWORD *)v15 - 5) = v18;
          *((_OWORD *)v15 - 4) = v17;
          *((_OWORD *)v15 - 3) = v17;
          *((_OWORD *)v15 - 2) = v16;
          *((_OWORD *)v15 - 1) = v30;
          *(_OWORD *)float v15 = v18;
          goto LABEL_22;
        case 0xA:
          uint64_t v31 = *(void *)a3;
          *((_OWORD *)v15 - 7) = v16;
          *(v15 - 12) = 0.0;
          *(v15 - 11) = 0.0;
          *((_OWORD *)v15 - 5) = v18;
          *((_OWORD *)v15 - 4) = v17;
          *((_OWORD *)v15 - 3) = v17;
          *((_OWORD *)v15 - 2) = v16;
          *(_OWORD *)float v15 = v18;
          *((void *)v15 - 2) = v31;
          *(v15 - 1) = 0.0;
          *float v15 = 0.0;
          goto LABEL_23;
        case 0xB:
          uint64_t v32 = *(void *)a3;
          *((_OWORD *)v15 - 7) = v16;
          *(v15 - 12) = 0.0;
          *(v15 - 11) = 0.0;
          *((_OWORD *)v15 - 5) = v18;
          *((_OWORD *)v15 - 4) = v17;
          *((_OWORD *)v15 - 3) = v17;
          *((_OWORD *)v15 - 2) = v16;
          *(_OWORD *)float v15 = v18;
          *(v15 - 2) = 0.0;
          *((void *)v15 - 1) = v32;
          *float v15 = 0.0;
          goto LABEL_23;
        case 0xC:
          uint64_t v29 = *(void *)a3;
          *((_OWORD *)v15 - 7) = v16;
          *(v15 - 12) = 0.0;
          *(v15 - 11) = 0.0;
          *((_OWORD *)v15 - 5) = v18;
          *((_OWORD *)v15 - 4) = v17;
          *((_OWORD *)v15 - 3) = v17;
          *((_OWORD *)v15 - 2) = v16;
          *(_OWORD *)float v15 = v18;
          *(v15 - 2) = 0.0;
          *(v15 - 1) = 0.0;
LABEL_22:
          *(void *)float v15 = v29;
LABEL_23:
          a3 = (double *)((char *)a3 + a4);
          size_t v14 = (double *)((char *)v14 + 1);
          BOOL v13 = v14 >= a2;
          float v15 = (double *)((char *)v15 + a6);
          if (a2 == v14) {
            return v13;
          }
          continue;
        default:
          return v13;
      }
    }
  }
  return 1;
}

uint64_t CA::Render::NamedFunction::name(CA::Render::NamedFunction *this)
{
  return *((unsigned int *)this + 4);
}

uint64_t CA::Render::NamedFunction::output_count(CA::Render::NamedFunction *this)
{
  return 16 * (*((_DWORD *)this + 4) < 0xDu);
}

uint64_t CA::Render::NamedFunction::input_count(CA::Render::NamedFunction *this)
{
  uint64_t v1 = *((unsigned int *)this + 4);
  if (v1 > 0xC) {
    return 0;
  }
  else {
    return dword_18499CFA8[v1];
  }
}

uint64_t CA::Render::NamedFunction::function_type(CA::Render::NamedFunction *this)
{
  return 1;
}

void CA::Render::NamedFunction::show(CA::Render::NamedFunction *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    unint64_t v2 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      CFIndex v3 = off_1E527BF80[*((int *)this + 4)];
      *(_DWORD *)uint64_t buf = 136315138;
      uint64_t v5 = v3;
      _os_log_impl(&dword_184668000, v2, OS_LOG_TYPE_DEFAULT, "(function %s)", buf, 0xCu);
    }
  }
}

void *CA::Render::NamedFunction::encode(CA::Render::NamedFunction *this, CA::Render::Encoder *a2)
{
  float64x2_t result = (void *)(*(uint64_t (**)(CA::Render::NamedFunction *))(*(void *)this + 96))(this);
  char v5 = (char)result;
  uint64_t v6 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v6 + 1) > *((void *)a2 + 5))
  {
    float64x2_t result = CA::Render::Encoder::grow(a2, 1);
    uint64_t v6 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v6 + 1;
  *uint64_t v6 = v5;
  int v7 = *((_DWORD *)this + 4);
  unint64_t v8 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v8 + 1) > *((void *)a2 + 5))
  {
    float64x2_t result = CA::Render::Encoder::grow(a2, 1);
    unint64_t v8 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v8 + 1;
  *unint64_t v8 = v7;
  return result;
}

void CA::Render::NamedFunction::~NamedFunction(CA::Render::NamedFunction *this, const CA::Render::Object *a2)
{
  --dword_1EB2ADE10;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  --dword_1EB2ADE10;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

CA::Render::InterpolatedFunction *CA::Render::Function::decode(CA::Render::Function *this, CA::Render::Decoder *a2)
{
  int v3 = CA::Render::Decoder::decode_int8(this);
  switch(v3)
  {
    case 3:
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      float64x2_t result = (CA::Render::InterpolatedFunction *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x38uLL, 0x743898A5uLL);
      if (result) {
        return CA::Render::Gradient::Gradient(result, this);
      }
      break;
    case 2:
      int v7 = (malloc_zone_t *)get_malloc_zone();
      float64x2_t result = (CA::Render::InterpolatedFunction *)malloc_type_zone_calloc(v7, 1uLL, 0x38uLL, 0x743898A5uLL);
      if (result) {
        return CA::Render::InterpolatedFunction::InterpolatedFunction(result, this);
      }
      break;
    case 1:
      unsigned int v4 = CA::Render::Decoder::decode_int8(this);
      return (CA::Render::InterpolatedFunction *)CA::Render::NamedFunction::new_function(v4);
    default:
      return 0;
  }
  return result;
}

atomic_ullong CA::Render::NamedFunction::new_function(unsigned int a1)
{
  if (a1 > 0xC) {
    return 0;
  }
  atomic_ullong result = CA::Render::NamedFunction::new_function(CA::Render::FunctionName)::table[a1];
  if (result) {
    goto LABEL_10;
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  unsigned int v4 = (atomic_uint *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x18uLL, 0x743898A5uLL);
  uint64_t v5 = 0;
  if (v4)
  {
    unint64_t v4[2] = 1;
    v4[3] = 18;
    ++dword_1EB2ADE10;
    *(void *)unsigned int v4 = &unk_1ED02DC58;
    v4[4] = a1;
    atomic_compare_exchange_strong(&CA::Render::NamedFunction::new_function(CA::Render::FunctionName)::table[a1], (unint64_t *)&v5, (unint64_t)v4);
    if (v5 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
    }
  }
  else
  {
    atomic_compare_exchange_strong(&CA::Render::NamedFunction::new_function(CA::Render::FunctionName)::table[a1], (unint64_t *)&v5, 0);
  }
  atomic_ullong result = CA::Render::NamedFunction::new_function(CA::Render::FunctionName)::table[a1];
  if (result)
  {
LABEL_10:
    uint64_t v6 = (atomic_uint *)(result + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(result + 8), 1u))
    {
      atomic_ullong result = 0;
      atomic_fetch_add(v6, 0xFFFFFFFF);
    }
  }
  return result;
}

uint64_t CA::Render::Gradient::function_type(CA::Render::Gradient *this)
{
  return 3;
}

void CA::Render::Gradient::~Gradient(void **this)
{
  CA::Render::InterpolatedFunction::~InterpolatedFunction(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::Render::InterpolatedFunction::set_locations(uint64_t this, const double *a2)
{
  uint64_t v2 = *(void *)(this + 40);
  if (v2)
  {
    uint64_t v3 = *(void *)(this + 16);
    if (v3)
    {
      uint64_t v4 = 0;
      char v5 = 1;
LABEL_4:
      uint64_t v6 = (float *)(v2 + 4 * v4);
      do
      {
        float v7 = a2[v4];
        *uint64_t v6 = v7;
        if (v4 && *(v6 - 1) > v7)
        {
          char v5 = 0;
          if (++v4 != v3) {
            goto LABEL_4;
          }
          goto LABEL_13;
        }
        ++v4;
        ++v6;
      }
      while (v3 != v4);
      if (v5) {
        goto LABEL_12;
      }
LABEL_13:
      unsigned int v8 = *(_DWORD *)(this + 12) & 0xFFFFFEFF;
    }
    else
    {
LABEL_12:
      unsigned int v8 = *(_DWORD *)(this + 12) | 0x100;
    }
    *(_DWORD *)(this + 12) = v8 | 0x200;
  }
  return this;
}

uint64_t CA::Render::InterpolatedFunction::set_location(uint64_t this, unint64_t a2, float a3)
{
  uint64_t v3 = *(void *)(this + 40);
  if (v3 && *(void *)(this + 16) > a2)
  {
    *(float *)(v3 + 4 * a2) = a3;
    if (a2)
    {
      if (*(float *)(v3 + 4 * a2 - 4) > a3) {
        *(_DWORD *)(this + 12) &= ~0x100u;
      }
    }
    *(_DWORD *)(this + 12) |= 0x200u;
  }
  return this;
}

uint64_t CA::Render::Gradient::set_colors(uint64_t this, const double *a2)
{
  uint64_t v2 = *(float32x4_t **)(this + 32);
  if (v2)
  {
    uint64_t v3 = *(void *)(this + 16);
    if (!v3) {
      goto LABEL_6;
    }
    char v4 = 1;
    do
    {
      float64x2_t v6 = *(float64x2_t *)a2;
      float64x2_t v5 = *(float64x2_t *)(a2 + 2);
      a2 += 4;
      *uint64_t v2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v6), v5);
      v4 &= v2->f32[3] >= 1.0;
      ++v2;
      --v3;
    }
    while (v3);
    if ((v4 & 1) == 0) {
      unsigned int v7 = *(_DWORD *)(this + 12) & 0xFFFFF7FF;
    }
    else {
LABEL_6:
    }
      unsigned int v7 = *(_DWORD *)(this + 12) | 0x800;
    *(_DWORD *)(this + 12) = v7;
  }
  return this;
}

uint64_t CA::Render::Gradient::set_color(uint64_t this, unint64_t a2, const double *a3)
{
  uint64_t v3 = *(void *)(this + 32);
  if (v3 && *(void *)(this + 16) > a2)
  {
    char v4 = (float32x4_t *)(v3 + 16 * a2);
    *char v4 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)a3), *(float64x2_t *)(a3 + 2));
    if (v4->f32[3] < 1.0) {
      *(_DWORD *)(this + 12) &= ~0x800u;
    }
  }
  return this;
}

uint64_t CA::Render::Image::TiledImage::copy_subtexture(CA::Render::Image::TiledImage *this, unsigned int a2, unsigned int a3, int a4, int a5, int a6, unsigned int a7, unsigned int a8, double a9, float *a10, unsigned int *a11)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  unint64_t v24 = __PAIR64__(a3, a2);
  int v25 = a4;
  float v15 = (os_unfair_lock_s *)((char *)this + 152);
  os_unfair_lock_lock((os_unfair_lock_t)this + 38);
  uint64_t v16 = x_hash_table_lookup(*((void *)this + 18), (uint64_t)&v24, 0);
  if (!v16)
  {
    int v17 = *((_DWORD *)this + 24);
    int v18 = *((_DWORD *)this + 25);
    v23[0] = v17 * a3;
    v23[1] = v18 * a4;
    v23[2] = v17;
    _OWORD v23[3] = v18;
    uint64_t v16 = (uint64_t)CA::Render::Image::copy_subimage(*((CA::Render::Image **)this + 17), a2, (const CA::Bounds *)v23, *((void *)this + 20), *((unsigned char *)this + 168) == 0);
    if (!v16)
    {
      os_unfair_lock_unlock(v15);
      goto LABEL_7;
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    double v20 = malloc_type_zone_malloc(malloc_zone, 0xCuLL, 0x8BB15036uLL);
    unint64_t v21 = v24;
    _DWORD v20[2] = v25;
    *(void *)double v20 = v21;
    hash_table_modify(*((int **)this + 18), (uint64_t)v20, v16, 0);
  }
  if (!atomic_fetch_add((atomic_uint *volatile)(v16 + 8), 1u)) {
    atomic_fetch_add((atomic_uint *volatile)(v16 + 8), 0xFFFFFFFF);
  }
  os_unfair_lock_unlock(v15);
  *(_DWORD *)(v16 + 36) = *(_DWORD *)(*((void *)this + 17) + 36);
LABEL_7:
  *a10 = 1.0;
  *a11 = 0;
  return v16;
}

uint64_t CA::Render::Image::TiledImage::image_format(CA::Render::Image::TiledImage *this)
{
  return *(unsigned __int8 *)(*((void *)this + 17) + 152);
}

uint64_t CA::Render::Image::TiledImage::finalize(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 38;
  os_unfair_lock_lock(this + 38);
  uint64_t v3 = *(void *)&this[34]._os_unfair_lock_opaque;
  if (v3)
  {
    CA::Render::remove_observer(3u, v3, (uint64_t)CA::Render::Image::TiledImage::will_deallocate, (uint64_t)this);
    *(void *)&this[34]._os_unfair_lock_opaque = 0;
  }
  os_unfair_lock_unlock(v2);
  char v4 = *(uint64_t (**)(os_unfair_lock_s *))(*(void *)&this->_os_unfair_lock_opaque + 8);

  return v4(this);
}

void CA::Render::Image::TiledImage::will_deallocate(CA::Render::Image::TiledImage *this, os_unfair_lock_s *a2, void *a3, void *a4)
{
  float64x2_t v5 = a2 + 38;
  os_unfair_lock_lock(a2 + 38);
  uint64_t v6 = 0;
  *(void *)&a2[34]._os_unfair_lock_opaque = 0;
  uint64_t v7 = *(void *)&a2[36]._os_unfair_lock_opaque;
  uint64_t v8 = 1 << *(_DWORD *)v7;
  do
  {
    for (uint64_t i = *(uint64_t ***)(*(void *)(v7 + 16) + 8 * v6); i; uint64_t i = (uint64_t **)*i)
      CA::Render::Image::TiledImage::free_tile(i[2], (atomic_uint *)i[3]);
    ++v6;
  }
  while (v6 != v8);
  x_hash_table_remove_all(*(void **)&a2[36]._os_unfair_lock_opaque);

  os_unfair_lock_unlock(v5);
}

void CA::Render::Image::TiledImage::free_tile(void *a1, atomic_uint *a2)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, a1);
  if (atomic_fetch_add(a2 + 2, 0xFFFFFFFF) == 1)
  {
    float64x2_t v5 = *(void (**)(atomic_uint *))(*(void *)a2 + 16);
    v5(a2);
  }
}

void CA::Render::Image::TiledImage::~TiledImage(CA::Render::Image::TiledImage *this)
{
  CA::Render::Image::TiledImage::~TiledImage(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t **i;
  atomic_uint *v6;
  uint64_t vars8;

  uint64_t v2 = 0;
  *(void *)this = &unk_1ED02F1F0;
  uint64_t v3 = *((void *)this + 18);
  char v4 = 1 << *(_DWORD *)v3;
  do
  {
    for (uint64_t i = *(uint64_t ***)(*(void *)(v3 + 16) + 8 * v2); i; uint64_t i = (uint64_t **)*i)
      CA::Render::Image::TiledImage::free_tile(i[2], (atomic_uint *)i[3]);
    ++v2;
  }
  while (v2 != v4);
  x_hash_table_free(*((void **)this + 18));
  --CA::Render::Object::_instance_counts[0];
  *(void *)this = &unk_1ED02D680;
  uint64_t v6 = (atomic_uint *)*((void *)this + 15);
  if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
  }

  CA::Render::Texture::~Texture((CGColorSpaceRef *)this);
}

BOOL CA::Render::Image::TiledImage::Key::compare(_DWORD *a1, _DWORD *a2)
{
  return *a1 != *a2 || a1[1] != a2[1] || a1[2] != a2[2];
}

unint64_t CA::Render::Image::TiledImage::Key::hash(_DWORD *a1)
{
  uint64_t v1 = ((a1[1] << 10) ^ (*a1 << 20)) ^ a1[2];
  unint64_t v2 = (~(v1 << 32) + v1) ^ ((unint64_t)(~(v1 << 32) + v1) >> 22);
  unint64_t v3 = 9 * ((v2 + ~(v2 << 13)) ^ ((v2 + ~(v2 << 13)) >> 8));
  unint64_t v4 = (v3 ^ (v3 >> 15)) + ~((v3 ^ (v3 >> 15)) << 27);
  return v4 ^ (v4 >> 31);
}

uint64_t CA::Render::Image::copy_tiled_texture(CA::Render::Image *this, uint64_t a2, int a3)
{
  if (CA::Render::tiled_image_mutex_once[0] != -1) {
    dispatch_once_f(CA::Render::tiled_image_mutex_once, 0, (dispatch_function_t)CA::Render::Image::tiled_image_mutex_init);
  }
  pthread_mutex_lock(&CA::Render::Image::_tiled_image_lock);
  uint64_t v6 = *((void *)this + 16);
  if (v6)
  {
    while (*(void *)(v6 + 160) != a2 || *(unsigned __int8 *)(v6 + 168) != a3)
    {
      uint64_t v6 = *(void *)(v6 + 128);
      if (!v6) {
        goto LABEL_7;
      }
    }
    goto LABEL_31;
  }
LABEL_7:
  unsigned int v7 = *((_DWORD *)this + 4);
  if (v7 >= 0x40) {
    int v8 = 64;
  }
  else {
    int v8 = 32;
  }
  if (v7 >= 0x40) {
    int v9 = 1024;
  }
  else {
    int v9 = 2048;
  }
  if (v7 <= 0x7F)
  {
    int v10 = v9;
  }
  else
  {
    int v8 = 128;
    int v10 = 512;
  }
  if (v7 <= 0xFF) {
    int v11 = v8;
  }
  else {
    int v11 = 256;
  }
  if (v7 <= 0xFF) {
    unsigned int v12 = v10;
  }
  else {
    unsigned int v12 = 256;
  }
  while (v12 > *((_DWORD *)this + 5))
  {
    unsigned int v13 = v12 >> 1;
    v11 *= 2;
    BOOL v14 = v12 > 0x41;
    v12 >>= 1;
    if (!v14) {
      goto LABEL_26;
    }
  }
  unsigned int v13 = v12;
LABEL_26:
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v16 = (CA::Render::Texture *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xB0uLL, 0x743898A5uLL);
  uint64_t v6 = (uint64_t)v16;
  if (v16)
  {
    int v17 = *((unsigned __int8 *)this + 153);
    int v18 = CA::Render::Texture::Texture(v16, *((_DWORD *)this + 4), *((_DWORD *)this + 5));
    *(_DWORD *)(v6 + 96) = v11;
    *(_DWORD *)(v6 + 100) = v13;
    *(_DWORD *)(v6 + 108) = 0;
    *(_DWORD *)(v6 + 112) = 0;
    *(_DWORD *)(v6 + 104) = v17;
    *(void *)(v6 + 120) = 0;
    *(_DWORD *)(v6 + 12) &= 0xFFFFFF00;
    ++CA::Render::Object::_instance_counts[0];
    *(void *)uint64_t v6 = &unk_1ED02F1F0;
    *(void *)(v6 + 136) = this;
    *(_DWORD *)(v6 + 152) = 0;
    *(void *)(v6 + 160) = a2;
    *(unsigned char *)(v6 + 168) = a3;
    CA::Render::Texture::set_colorspace(v18, *((CGColorSpace **)this + 6));
    *(void *)(v6 + 144) = x_hash_table_new_((unint64_t (*)(uint64_t))CA::Render::Image::TiledImage::Key::hash, (BOOL (*)(uint64_t, uint64_t))CA::Render::Image::TiledImage::Key::compare, 0, 0, 0, 0);
    CA::Render::add_observer(3u, *(void *)(v6 + 136), (uint64_t)CA::Render::Image::TiledImage::will_deallocate, v6, 0);
    unint64_t v19 = *((unsigned __int8 *)this + 152);
    if (v19 > 0x23 || ((0xC99B4EB03uLL >> v19) & 1) == 0) {
      *(_DWORD *)(v6 + 12) |= 0x1000u;
    }
    *(void *)(v6 + 128) = *((void *)this + 16);
    *((void *)this + 16) = v6;
LABEL_31:
    double v20 = (atomic_uint *)(v6 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v6 + 8), 1u))
    {
      uint64_t v6 = 0;
      atomic_fetch_add(v20, 0xFFFFFFFF);
    }
  }
  pthread_mutex_unlock(&CA::Render::Image::_tiled_image_lock);
  return v6;
}

uint64_t CA::Render::Image::tiled_image_mutex_init(CA::Render::Image *this)
{
  return x_thread_init_mutex(&CA::Render::Image::_tiled_image_lock, 1);
}

uint64_t CA::Render::Image::get_tiled_texture_size(CA::Render::Image *this, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *((_DWORD *)this + 4);
  if (v3 >= 0x40) {
    int v4 = 64;
  }
  else {
    int v4 = 32;
  }
  if (v3 >= 0x40) {
    int v5 = 1024;
  }
  else {
    int v5 = 2048;
  }
  if (v3 <= 0x7F) {
    int v6 = v4;
  }
  else {
    int v6 = 128;
  }
  if (v3 <= 0x7F) {
    int v7 = v5;
  }
  else {
    int v7 = 512;
  }
  if (v3 <= 0xFF) {
    unsigned int v8 = v6;
  }
  else {
    unsigned int v8 = 256;
  }
  if (v3 <= 0xFF) {
    unsigned int v9 = v7;
  }
  else {
    unsigned int v9 = 256;
  }
  while (v9 > *((_DWORD *)this + 5))
  {
    unsigned int v10 = v9 >> 1;
    v8 *= 2;
    BOOL v11 = v9 > 0x41;
    v9 >>= 1;
    if (!v11) {
      goto LABEL_23;
    }
  }
  unsigned int v10 = v9;
LABEL_23:
  *a2 = v8;
  *a3 = v10;
  return 1;
}

uint64_t CAImageProviderMaxLOD(unsigned int a1, unsigned int a2)
{
  if (a1 >= a2) {
    unsigned int v2 = a2;
  }
  else {
    unsigned int v2 = a1;
  }
  uint64_t result = 1;
  if (v2 >= 2)
  {
    do
    {
      uint64_t result = (result + 1);
      BOOL v4 = v2 > 3;
      v2 >>= 1;
    }
    while (v4);
  }
  return result;
}

uint64_t CAImageProviderCreate(unsigned int a1, unsigned int a2, int a3, int a4, int a5, int a6, int a7, double a8)
{
  if (a1 >= a2) {
    unsigned int v15 = a2;
  }
  else {
    unsigned int v15 = a1;
  }
  unsigned int v16 = 1;
  if (v15 >= 2)
  {
    do
    {
      ++v16;
      BOOL v17 = v15 > 3;
      v15 >>= 1;
    }
    while (v17);
  }
  if (a5 - a6 <= v16) {
    int v18 = a5;
  }
  else {
    int v18 = v16 + a6;
  }
  if (CAImageProviderGetTypeID::once != -1) {
    dispatch_once(&CAImageProviderGetTypeID::once, &__block_literal_global_5_8974);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v20 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 224) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    do
    {
      unsigned int add = atomic_fetch_add(CA::Render::next_sequence(void)::sequence, 1u);
      BOOL v22 = __CFADD__(add, 1);
      unsigned int v23 = add + 1;
    }
    while (v22);
    *(_DWORD *)(Instance + 20) = v23;
    pthread_mutex_init((pthread_mutex_t *)(Instance + 88), 0);
    pthread_cond_init((pthread_cond_t *)(v20 + 152), 0);
    *(void *)(v20 + 200) = v20 + 200;
    *(void *)(v20 + 208) = v20 + 200;
    *(_DWORD *)(v20 + 216) = a7;
    *(_DWORD *)(v20 + 220) = a1;
    *(_DWORD *)(v20 + 224) = a2;
    *(_DWORD *)(v20 + 228) = a3;
    *(_DWORD *)(v20 + 232) = a4;
    *(_DWORD *)(v20 + 236) = v18;
    *(_DWORD *)(v20 + 240) = a6;
    float v24 = a8;
    *(float *)(v20 + 244) = v24;
    *(void *)(v20 + 56) = ++CAImageProviderCreate::id;
    if (CAImageProviderCreate::once != -1) {
      dispatch_once(&CAImageProviderCreate::once, &__block_literal_global_8975);
    }
  }
  return v20;
}

dispatch_queue_t __CAImageProviderCreate_block_invoke()
{
  v0 = dispatch_queue_attr_make_with_qos_class(MEMORY[0x1E4F14430], QOS_CLASS_USER_INITIATED, 0);
  dispatch_queue_t result = dispatch_queue_create("com.apple.coreanimation.imageprovider.concurrent", v0);
  provider_queue = (uint64_t)result;
  return result;
}

uint64_t __CAImageProviderGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CAImageProviderGetTypeID::type = result;
  return result;
}

CFStringRef imageProviderCopyDebugDescription(unsigned int *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CAImageProvider %p: %u x %u>", a1, a1[55], a1[56]);
}

CFStringRef imageProviderCopyFormatDescription(unsigned int *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, @"<CAImageProvider %p: %u x %u>", a1, a1[55], a1[56]);
}

uint64_t imageProviderFinalize(char *a1)
{
  if (*((void *)a1 + 8)) {
    CAImageProviderSetCallback((uint64_t)a1, 0, 0);
  }
  CFAllocatorRef v2 = (void *)*((void *)a1 + 5);
  if (v2) {
    CFRelease(v2);
  }
  unsigned int v3 = CA::Transaction::ensure_compat((CA::Transaction *)v2);
  CA::Transaction::add_deleted_id(*((CA::Transaction **)v3 + 13), *((void *)a1 + 7), *((_DWORD *)a1 + 5), 0);
  CGColorRelease(*((CGColorRef *)a1 + 32));
  CFAllocatorRef v4 = (void *)*((void *)a1 + 4);
  if (v4)
  {
    do
    {
      int v5 = (void *)v4[1];
      free(v4);
      CFAllocatorRef v4 = v5;
    }
    while (v5);
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 88));

  return pthread_cond_destroy((pthread_cond_t *)(a1 + 152));
}

void CAImageProviderSetCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)&provider_lock);
  uint64_t v6 = *(void *)(a1 + 64);
  if (v6 == a2 && *(void *)(a1 + 72) == a3) {
    goto LABEL_15;
  }
  if (a2)
  {
    if (!v6)
    {
      uint64_t v7 = provider_list;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      unsigned int v9 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
      void *v9 = a1;
      v9[1] = v7;
      provider_list = (uint64_t)v9;
      CFRetain((CFTypeRef)a1);
      int v10 = *(_DWORD *)(a1 + 48);
      *(void *)(a1 + 64) = a2;
      *(void *)(a1 + 72) = a3;
      os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
      if (v10)
      {
        int v11 = *(_DWORD *)(a1 + 48);
        _CAImageProviderSignal(a1, v11);
      }
      return;
    }
    goto LABEL_14;
  }
  if (!v6)
  {
LABEL_14:
    *(void *)(a1 + 64) = a2;
    *(void *)(a1 + 72) = a3;
LABEL_15:
    os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
    return;
  }
  provider_list = (uint64_t)x_list_remove((void *)provider_list, a1);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = a3;
  os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 88));
  while (*(_DWORD *)(a1 + 80))
  {
    timespec v12 = (timespec)xmmword_184998390;
    pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 152), (pthread_mutex_t *)(a1 + 88), &v12);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 88));
  CFRelease((CFTypeRef)a1);
}

void _CAImageProviderSignal(uint64_t a1, int a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)&provider_lock);
  *(_DWORD *)(a1 + 48) = a2;
  if (*(void *)(a1 + 64))
  {
    int v5 = *(_DWORD *)(a1 + 216);
    if ((v5 & 2) != 0)
    {
      if (!provider_main_thread_count)
      {
        CA::call_at_time((CA *)CAImageProviderMainThread, (void (*)(double, void *))&provider_main_thread_count, 0.0, v4);
        ++provider_main_thread_count;
      }
    }
    else
    {
      if ((v5 & 4) != 0)
      {
        unsigned int v6 = x_cpu_count::n_cpus;
        if (!x_cpu_count::n_cpus)
        {
          *(void *)unsigned int v8 = 0x300000006;
          size_t v7 = 4;
          sysctl(v8, 2u, &x_cpu_count::n_cpus, &v7, 0, 0);
          unsigned int v6 = x_cpu_count::n_cpus;
          if (x_cpu_count::n_cpus <= 0)
          {
            unsigned int v6 = 1;
            x_cpu_count::n_cpus = 1;
          }
        }
      }
      else
      {
        unsigned int v6 = 1;
      }
      for (; provider_bg_thread_count < v6; ++provider_bg_thread_count)
        dispatch_async_f((dispatch_queue_t)provider_queue, &provider_bg_thread_count, (dispatch_function_t)CAImageProviderBackgroundThread);
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
}

void CAImageProviderBackgroundThread(unsigned int *a1)
{
}

void CAImageProviderThread(unsigned int *a1, uint64_t a2)
{
  mach_msg_return_t v23;
  int v24;
  BOOL v25;
  os_unfair_lock_s *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  _OWORD *v30;
  void *v31;
  uint64_t v32;
  const void *v33;
  void *v34;
  CA::Transaction *v35;
  unint64_t StatusReg;
  void (*v38)(uint64_t, void, void, void, void, uint64_t);
  unsigned int v39[2];
  unsigned int v40[2];
  unsigned char msg[52];
  uint64_t v42;
  uint64_t v43;

  double v43 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)&provider_lock);
  *(void *)float v39 = 0;
  *(void *)float v40 = 0;
  CFAllocatorRef v4 = (void *)provider_list;
  if (provider_list)
  {
    unsigned int v5 = 0;
    uint64_t v6 = 0;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    size_t v7 = (os_unfair_lock_s *)&provider_lock;
    while (1)
    {
      do
      {
        uint64_t v8 = *v4;
        if (*(_DWORD *)(*v4 + 48) > v5
          && *(void *)(v8 + 64)
          && (((*(_DWORD *)(v8 + 216) >> 1) & 1) == 0) == a2)
        {
          uint64_t v6 = *v4;
          unsigned int v5 = *(_DWORD *)(*v4 + 48);
        }
        CFAllocatorRef v4 = (void *)v4[1];
      }
      while (v4);
      if (!v6) {
        goto LABEL_65;
      }
      CFRetain((CFTypeRef)v6);
      uint64_t v9 = *(void *)(v6 + 72);
      float v38 = *(void (**)(uint64_t, void, void, void, void, uint64_t))(v6 + 64);
      atomic_fetch_add((atomic_uint *volatile)(v6 + 80), 1u);
      int v10 = v7;
      os_unfair_lock_unlock(v7);
      CA::Transaction::begin_transaction(v11);
      timespec v12 = CA::Context::retain_context_with_id((CA::Context *)*(unsigned int *)(v6 + 24));
      if (!v12) {
        goto LABEL_42;
      }
      uint64_t v13 = v12;
      uint64_t v14 = CA::Context::retain_render_ctx((CA::Context *)v12);
      if (!v14) {
        break;
      }
      uint64_t v15 = v14;
      uint64_t v16 = a2;
      BOOL v17 = v3;
      int v18 = (pthread_mutex_t *)(v14 + 72);
      pthread_mutex_lock((pthread_mutex_t *)(v14 + 72));
      char v19 = CA::Render::ImageProvider::needed_subimage(*(CA::Render::ImageProvider **)(v15 + 136), (CA::Render::Context *)*(unsigned int *)(v15 + 148), *(void *)(v6 + 56), &v40[1], v40, &v39[1], v39);
      pthread_mutex_unlock(v18);
      if (atomic_fetch_add((atomic_uint *volatile)(v15 + 8), 0xFFFFFFFF) == 1) {
        (*(void (**)(uint64_t))(*(void *)v15 + 16))(v15);
      }
      CA::Context::unref((CA::Context *)v13, 0);
      unsigned int v3 = v17;
      a2 = v16;
      if (v19)
      {
LABEL_45:
        *(_DWORD *)&msg[16] = v40[1];
        *(_DWORD *)&msg[20] = v40[0];
        *(_DWORD *)&msg[24] = v39[1];
        *(_DWORD *)&msg[28] = v39[0];
        *(void *)msg = msg;
        *(void *)&msg[8] = msg;
        os_unfair_lock_lock((os_unfair_lock_t)(v6 + 16));
        uint64_t v27 = (uint64_t *)(v6 + 200);
        uint64_t v28 = *(void *)(v6 + 208);
        if (v28 == v6 + 200)
        {
LABEL_50:
          uint64_t v29 = *v27;
          *uint64_t v27 = (uint64_t)msg;
          *(void *)msg = v29;
          *(void *)&msg[8] = v6 + 200;
          *(void *)(v29 + 8) = msg;
          os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 16));
          if (a2)
          {
            long long v30 = *(_OWORD **)(StatusReg + 576);
            if (!v30) {
              long long v30 = CA::Transaction::create(0);
            }
            *((unsigned char *)v30 + 116) |= 4u;
          }
          v38(v6, v40[1], v40[0], v39[1], v39[0], v9);
          os_unfair_lock_lock((os_unfair_lock_t)(v6 + 16));
          uint64_t v32 = *(void *)msg;
          uint64_t v31 = *(void **)&msg[8];
          *(void *)(*(void *)msg + 8) = *(void *)&msg[8];
          const char *v31 = v32;
          *(void *)msg = msg;
          *(void *)&msg[8] = msg;
        }
        else
        {
          while (*(_DWORD *)&msg[16] != *(_DWORD *)(v28 + 16)
               || *(_DWORD *)&msg[20] != *(_DWORD *)(v28 + 20)
               || *(void *)&msg[24] != *(void *)(v28 + 24))
          {
            uint64_t v28 = *(void *)(v28 + 8);
            if ((uint64_t *)v28 == v27) {
              goto LABEL_50;
            }
          }
        }
        uint64_t v26 = (os_unfair_lock_s *)(v6 + 16);
        goto LABEL_56;
      }
LABEL_42:
      os_unfair_lock_lock((os_unfair_lock_t)(v6 + 16));
      if (*(_DWORD *)(v6 + 48) == v5) {
        *(_DWORD *)(v6 + 48) = 0;
      }
      uint64_t v26 = (os_unfair_lock_s *)(v6 + 16);
LABEL_56:
      os_unfair_lock_unlock(v26);
      size_t v7 = v10;
      if (atomic_fetch_add((atomic_uint *volatile)(v6 + 80), 0xFFFFFFFF) == 1) {
        pthread_cond_broadcast((pthread_cond_t *)(v6 + 152));
      }
      CFRelease((CFTypeRef)v6);
      uint64_t v34 = (void *)MEMORY[0x185324A30]();
      float64x2_t v35 = *(CA::Transaction **)(StatusReg + 576);
      if (v35 && **((_DWORD **)v35 + 13)) {
        CA::Transaction::pop(v35, v33);
      }
      os_unfair_lock_lock(v10);
      unsigned int v5 = 0;
      uint64_t v6 = 0;
      *(void *)float v39 = 0;
      *(void *)float v40 = 0;
      CFAllocatorRef v4 = (void *)v3[66];
      if (!v4) {
        goto LABEL_65;
      }
    }
    int v20 = v13[40];
    if (!v20)
    {
      CA::Context::unref((CA::Context *)v13, 0);
      goto LABEL_42;
    }
    uint64_t v21 = *(void *)(v6 + 56);
    float v42 = 0;
    memset(&msg[4], 0, 48);
    *(void *)&msg[24] = *MEMORY[0x1E4F14068];
    *(void *)&msg[32] = v21;
    mach_port_t reply_port = mig_get_reply_port();
    *(_DWORD *)&msg[8] = v20;
    *(_DWORD *)&msg[12] = reply_port;
    *(_DWORD *)msg = 5395;
    *(void *)&msg[16] = 0x9D5300000000;
    if (MEMORY[0x1E4F14B18])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      mach_port_t reply_port = *(_DWORD *)&msg[12];
    }
    unsigned int v23 = mach_msg((mach_msg_header_t *)msg, 3, 0x28u, 0x3Cu, reply_port, 0, 0);
    float v24 = v23;
    if ((v23 - 268435458) <= 0xE && ((1 << (v23 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
      goto LABEL_41;
    }
    if (v23)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
      goto LABEL_40;
    }
    if (*(_DWORD *)&msg[20] == 71)
    {
      float v24 = -308;
    }
    else if (*(_DWORD *)&msg[20] == 40375)
    {
      if ((*(_DWORD *)msg & 0x80000000) == 0)
      {
        if (*(_DWORD *)&msg[4] == 52)
        {
          if (!*(_DWORD *)&msg[8])
          {
            float v24 = *(_DWORD *)&msg[32];
            if (!*(_DWORD *)&msg[32])
            {
              v40[0] = *(_DWORD *)&msg[40];
              v40[1] = *(_DWORD *)&msg[36];
              v39[0] = *(_DWORD *)&msg[48];
              v39[1] = *(_DWORD *)&msg[44];
              goto LABEL_41;
            }
            goto LABEL_39;
          }
        }
        else if (*(_DWORD *)&msg[4] == 36)
        {
          if (*(_DWORD *)&msg[8]) {
            int v25 = 1;
          }
          else {
            int v25 = *(_DWORD *)&msg[32] == 0;
          }
          if (v25) {
            float v24 = -300;
          }
          else {
            float v24 = *(_DWORD *)&msg[32];
          }
          goto LABEL_39;
        }
      }
      float v24 = -300;
    }
    else
    {
      float v24 = -301;
    }
LABEL_39:
    mach_msg_destroy((mach_msg_header_t *)msg);
LABEL_40:
    if (v24 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
LABEL_41:
    CA::Context::unref((CA::Context *)v13, 0);
    if (!v24) {
      goto LABEL_45;
    }
    goto LABEL_42;
  }
LABEL_65:
  --*a1;
  os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
}

void CAImageProviderMainThread(double a1, unsigned int *a2)
{
}

uint64_t CAImageProviderGetTypeID()
{
  if (CAImageProviderGetTypeID::once != -1) {
    dispatch_once(&CAImageProviderGetTypeID::once, &__block_literal_global_5_8974);
  }
  return CAImageProviderGetTypeID::type;
}

uint64_t CAImageProviderGetFlags(uint64_t a1)
{
  return *(unsigned int *)(a1 + 216);
}

void CAImageProviderSetImageSize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 220) != a2 || *(_DWORD *)(a1 + 224) != a3)
  {
    *(_DWORD *)(a1 + 220) = a2;
    *(_DWORD *)(a1 + 224) = a3;
    if (*(_DWORD *)(a1 + 24))
    {
      CFArrayRef cfarray = create_cfarray(2, a2, a2, 2, a3, 0);
      CA::Transaction::add_command((CA::Transaction *)0x10, *(_DWORD *)(a1 + 24), *(void *)(a1 + 56), cfarray, v5);
      CFRelease(cfarray);
    }
  }
}

CFArrayRef create_cfarray(int a1, uint64_t a2, ...)
{
  unsigned int v2 = 0;
  CFIndex v3 = 0;
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)values = 0u;
  long long v15 = 0u;
  int valuePtr = 0;
  uint64_t v13 = (void **)&a2;
  CFAllocatorRef v4 = (void *)*MEMORY[0x1E4F1D260];
  while (1)
  {
    if (a1 == 1)
    {
      uint64_t v6 = v13++;
      size_t v7 = *v6;
      if (!v7) {
        size_t v7 = v4;
      }
      values[v3] = v7;
      goto LABEL_10;
    }
    if (a1 != 2) {
      break;
    }
    unsigned int v5 = v13++;
    int valuePtr = *(_DWORD *)v5;
    v2 |= 1 << v3;
    values[v3] = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
LABEL_10:
    ++v3;
LABEL_11:
    uint64_t v8 = v13++;
    a1 = *(_DWORD *)v8;
  }
  if (a1) {
    goto LABEL_11;
  }
  CFArrayRef v9 = CFArrayCreate(0, (const void **)values, v3, MEMORY[0x1E4F1D510]);
  if (v3)
  {
    for (uint64_t i = 0; i != v3; ++i)
    {
      if ((v2 >> i)) {
        CFRelease(values[i]);
      }
    }
  }
  return v9;
}

uint64_t CAImageProviderGetImageWidth(uint64_t a1)
{
  return *(unsigned int *)(a1 + 220);
}

uint64_t CAImageProviderGetImageHeight(uint64_t a1)
{
  return *(unsigned int *)(a1 + 224);
}

uint64_t CAImageProviderGetSubImageWidth(uint64_t a1)
{
  return *(unsigned int *)(a1 + 228);
}

uint64_t CAImageProviderGetSubImageHeight(uint64_t a1)
{
  return *(unsigned int *)(a1 + 232);
}

uint64_t CAImageProviderGetLODCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 236);
}

uint64_t CAImageProviderGetLODBias(uint64_t a1)
{
  return *(unsigned int *)(a1 + 240);
}

uint64_t CAImageProviderGetLODWidth(_DWORD *a1, unsigned int a2)
{
  if (a1[59] <= a2) {
    return 0;
  }
  unsigned int v2 = a1[55];
  int v3 = a2 - a1[60];
  if (v3 < 0) {
    return v2 << (*((unsigned char *)a1 + 240) - a2);
  }
  else {
    return v2 >> v3;
  }
}

uint64_t CAImageProviderGetLODHeight(_DWORD *a1, unsigned int a2)
{
  if (a1[59] <= a2) {
    return 0;
  }
  unsigned int v2 = a1[56];
  int v3 = a2 - a1[60];
  if (v3 < 0) {
    return v2 << (*((unsigned char *)a1 + 240) - a2);
  }
  else {
    return v2 >> v3;
  }
}

float64x2_t CAImageProviderGetLODScale(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 236) <= a2)
  {
    return *(float64x2_t *)MEMORY[0x1E4F1DB30];
  }
  else
  {
    uint32x2_t v2 = *(uint32x2_t *)(a1 + 220);
    int8x8_t v3 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32((int)(a2 - *(_DWORD *)(a1 + 240)) < 0), 0x1FuLL)), (int8x8_t)vshl_u32(v2, (uint32x2_t)vdup_n_s32(*(_DWORD *)(a1 + 240) - a2)), (int8x8_t)vshl_u32(v2, (uint32x2_t)vneg_s32(vdup_n_s32(a2 - *(_DWORD *)(a1 + 240)))));
    v4.i64[0] = v3.u32[0];
    v4.i64[1] = v3.u32[1];
    float64x2_t v5 = vcvtq_f64_u64(v4);
    v4.i64[0] = v2.u32[0];
    v4.i64[1] = v2.u32[1];
    return vdivq_f64(v5, vcvtq_f64_u64(v4));
  }
}

void CAImageProviderSetSubImageWithSeed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  CFArrayRef cfarray = create_cfarray(2, a2, a2, 2, a3, 2, a4, 1, a5, 2, a6, 2, a7, 0);
  CFArrayRef v10 = cfarray;
  int v11 = *(_DWORD *)(a1 + 24);
  if (v11)
  {
    CA::Transaction::add_command((CA::Transaction *)0x13, v11, *(void *)(a1 + 56), cfarray, v9);
  }
  else
  {
    timespec v12 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
    if (!v12) {
      timespec v12 = (CA::Transaction *)CA::Transaction::create(cfarray);
    }
    int v13 = *((_DWORD *)v12 + 25);
    *((_DWORD *)v12 + 25) = v13 + 1;
    if (!v13) {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    }
    Mutable = *(__CFArray **)(a1 + 40);
    if (!Mutable)
    {
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
      *(void *)(a1 + 40) = Mutable;
    }
    CFArrayAppendValue(Mutable, v10);
    CA::Transaction::unlock(v12);
  }
  CFRelease(v10);

  CAImageProviderChanged(a1);
}

void CAImageProviderChanged(uint64_t a1)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 32))
  {
    uint32x2_t v2 = (os_unfair_lock_s *)(a1 + 16);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4)
    {
      float64x2_t v5 = 0;
      do
      {
        uint64_t v6 = v5;
        MEMORY[0x1F4188790](v3);
        float64x2_t v5 = &v10[-2];
        v10[-2] = 0;
        v10[-1] = 0;
        CFTypeRef v3 = CFRetain(*(CFTypeRef *)v4);
        v10[-2] = v3;
        v10[-1] = v6;
        uint64_t v4 = *(void *)(v4 + 8);
      }
      while (v4);
      os_unfair_lock_unlock(v2);
      do
      {
        int v7 = *(_DWORD *)(a1 + 24);
        uint64_t v8 = CA::Render::Object::render_id(*(CA::Render::Object **)(*v5 + 16));
        CA::Transaction::add_command((CA::Transaction *)2, v7, v8, 0, v9);
        CFRelease((CFTypeRef)*v5);
        float64x2_t v5 = (void *)v5[1];
      }
      while (v5);
    }
    else
    {
      os_unfair_lock_unlock(v2);
    }
  }
}

void CAImageProviderSetSubImage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
}

void CAImageProviderInvalidate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
}

void CAImageProviderInvalidateLOD(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (!v14) {
    uint64_t v14 = (CA::Transaction *)CA::Transaction::create((CA::Transaction *)a1);
  }
  int v15 = *((_DWORD *)v14 + 25);
  *((_DWORD *)v14 + 25) = v15 + 1;
  if (!v15) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  long long v16 = *(const void **)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  CA::Transaction::unlock(v14);
  if (v16) {
    CFRelease(v16);
  }
  if (*(_DWORD *)(a1 + 24))
  {
    CFArrayRef cfarray = create_cfarray(2, v17, a2, 2, a3, 2, a4, 2, a5, 2, a6, 2, a7, 0);
    CA::Transaction::add_command((CA::Transaction *)0x14, *(_DWORD *)(a1 + 24), *(void *)(a1 + 56), cfarray, v19);
    CFRelease(cfarray);
  }
}

void CAImageProviderDraw(uint64_t a1, int a2, int a3, int a4, int a5, int a6)
{
  if (*(void *)(a1 + 64))
  {
    unsigned int v7 = a2 & ~(a2 >> 31);
    unsigned int v8 = a3 & ~(a3 >> 31);
    signed int v9 = *(_DWORD *)(a1 + 220);
    signed int v10 = *(_DWORD *)(a1 + 224);
    int v11 = v9 - v7;
    if ((int)((a2 & (a2 >> 31)) + a4 + v7) <= v9) {
      int v11 = (a2 & (a2 >> 31)) + a4;
    }
    if ((int)((a3 & (a3 >> 31)) + a5 + v8) <= v10) {
      int v12 = (a3 & (a3 >> 31)) + a5;
    }
    else {
      int v12 = v10 - v8;
    }
    if (v11 >= 1 && v12 >= 1)
    {
      unsigned int v15 = *(_DWORD *)(a1 + 228);
      unsigned int v16 = *(_DWORD *)(a1 + 232);
      uint64_t v17 = v7 / v15;
      uint64_t v18 = v8 / v16;
      int v19 = (v7 + v11 - 1) / v15;
      unsigned int v20 = v8 + v12 - 1;
      int v21 = *(_DWORD *)(a1 + 240);
      for (int i = v20 / v16; v21; --v21)
      {
        uint64_t v17 = (2 * v17);
        uint64_t v18 = (2 * v18);
        int v19 = (2 * v19) | 1;
        int i = (2 * i) | 1;
      }
      os_unfair_lock_lock((os_unfair_lock_t)&provider_lock);
      long long v23 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, void))(a1 + 64);
      long long v24 = (atomic_uint *)(a1 + 80);
      atomic_fetch_add((atomic_uint *volatile)(a1 + 80), 1u);
      if (v23)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
        unsigned int v25 = *(_DWORD *)(a1 + 236);
        if (v25)
        {
          uint64_t v26 = 0;
          int v31 = a6;
          do
          {
            BOOL v27 = v26 == a6 || a6 == -1;
            if (v27 && (int)v18 <= i)
            {
              uint64_t v29 = v18;
              do
              {
                uint64_t v30 = v17;
                if ((int)v17 <= v19)
                {
                  do
                  {
                    v23(a1, v26, v30, v29, 0, *(void *)(a1 + 72));
                    uint64_t v30 = (v30 + 1);
                  }
                  while (v19 + 1 != v30);
                }
                BOOL v27 = v29 == i;
                uint64_t v29 = (v29 + 1);
              }
              while (!v27);
              unsigned int v25 = *(_DWORD *)(a1 + 236);
              a6 = v31;
            }
            uint64_t v17 = ((int)v17 >> 1);
            uint64_t v18 = ((int)v18 >> 1);
            v19 >>= 1;
            i >>= 1;
            uint64_t v26 = (v26 + 1);
          }
          while (v26 < v25);
        }
        os_unfair_lock_lock((os_unfair_lock_t)&provider_lock);
        long long v24 = (atomic_uint *)(a1 + 80);
      }
      if (atomic_fetch_add(v24, 0xFFFFFFFF) == 1) {
        pthread_cond_broadcast((pthread_cond_t *)(a1 + 152));
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
    }
  }
}

_DWORD *CAImageProviderCopyRenderValue(uint64_t a1, uint64_t a2)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v4 = *(void *)(StatusReg + 576);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = *(void *)(v4 + 40);
  if (!v5 || !*(void *)(v5 + 208)) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 24) != *(_DWORD *)(v5 + 8))
  {
    LODWORD(v2) = vcvtd_n_s64_f64(*(float *)(a1 + 244), 0x10uLL);
    CFArrayRef cfarray = (__CFString *)create_cfarray(2, a2, *(unsigned int *)(a1 + 20), 2, *(unsigned int *)(a1 + 220), 2, *(unsigned int *)(a1 + 224), 2, *(unsigned int *)(a1 + 228), 2, *(unsigned int *)(a1 + 232), 2, *(unsigned int *)(a1 + 236), 2, *(unsigned int *)(a1 + 240), 2, *(_DWORD *)(a1 + 216) & 1, 2, v2,
                              2,
                              *(unsigned int *)(a1 + 248),
                              1,
                              *(void *)(a1 + 256),
                              0);
    CA::Context::commit_command((CA::Context *)0xF, *(CA::Render::Object **)(a1 + 56), cfarray, *(const void **)(v5 + 208), v8);
    CFRelease(cfarray);
    signed int v10 = *(CA::Transaction **)(StatusReg + 576);
    if (!v10) {
      signed int v10 = (CA::Transaction *)CA::Transaction::create(v9);
    }
    int v11 = *((_DWORD *)v10 + 25);
    *((_DWORD *)v10 + 25) = v11 + 1;
    if (!v11) {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    }
    CFArrayRef v12 = *(const __CFArray **)(a1 + 40);
    *(void *)(a1 + 40) = 0;
    CA::Transaction::unlock(v10);
    if (v12)
    {
      CFIndex Count = CFArrayGetCount(v12);
      if (Count)
      {
        CFIndex v15 = Count;
        for (CFIndex i = 0; i != v15; ++i)
        {
          uint64_t v17 = *(CA::Render::Object **)(a1 + 56);
          CFDictionaryRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v12, i);
          CA::Context::commit_command((CA::Context *)0x13, v17, ValueAtIndex, *(const void **)(v5 + 208), v19);
        }
      }
      CFRelease(v12);
    }
    if (*(_DWORD *)(a1 + 264))
    {
      unsigned int v20 = (__CFString *)create_cfarray(2, v13, *(unsigned int *)(a1 + 264), 0);
      CA::Context::commit_command((CA::Context *)0x12, *(CA::Render::Object **)(a1 + 56), v20, *(const void **)(v5 + 208), v21);
      CFRelease(v20);
    }
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(v5 + 8);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t result = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x18uLL, 0x743898A5uLL);
  if (result)
  {
    uint64_t v24 = *(void *)(a1 + 56);
    result[2] = 1;
    ++dword_1EB2ADE74;
    *(void *)uint64_t result = &unk_1ED02F4B0;
    *((void *)result + 2) = v24;
    result[3] = 299;
  }
  return result;
}

void CAImageProviderRemoveLayer(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  *(void *)(a1 + 32) = x_list_remove(*(void **)(a1 + 32), a2);

  os_unfair_lock_unlock(v4);
}

void CAImageProviderSignal(uint64_t a1, int a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&provider_lock);
  uint64_t v4 = (CFTypeRef *)provider_list;
  if (provider_list)
  {
    while (1)
    {
      CFTypeRef v5 = *v4;
      if (*((void *)*v4 + 7) == a1) {
        break;
      }
      uint64_t v4 = (CFTypeRef *)v4[1];
      if (!v4) {
        goto LABEL_4;
      }
    }
    CFRetain(*v4);
    os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
    _CAImageProviderSignal((uint64_t)v5, a2);
    CFRelease(v5);
  }
  else
  {
LABEL_4:
    os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
  }
}

void CAImageProviderSetFillColor(uint64_t a1, CGColor *a2)
{
  CFTypeRef v3 = *(CGColor **)(a1 + 256);
  if (v3 != a2)
  {
    CGColorRelease(v3);
    *(void *)(a1 + 256) = CGColorRetain(a2);
    if (*(_DWORD *)(a1 + 24))
    {
      CFArrayRef cfarray = create_cfarray(1, v5, a2, 0);
      CA::Transaction::add_command((CA::Transaction *)0x11, *(_DWORD *)(a1 + 24), *(void *)(a1 + 56), cfarray, v7);
      CFRelease(cfarray);
    }
  }
}

uint64_t CAImageProviderGetFillColor(uint64_t a1)
{
  return *(void *)(a1 + 256);
}

_DWORD *CA::CG::ColorMatrixStyle::copy(CA::CG::ColorMatrixStyle *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  CFTypeRef v3 = malloc_type_zone_malloc(malloc_zone, 0xA0uLL, 0x8BB15036uLL);
  uint64_t v4 = v3;
  if (v3)
  {
    *(void *)CFTypeRef v3 = &unk_1ED029D48;
    int v5 = *((_DWORD *)this + 3);
    v3[2] = 0;
    v3[3] = v5;
    *((void *)v3 + 2) = CGStyleRetain();
    long long v6 = *(_OWORD *)((char *)this + 56);
    long long v7 = *(_OWORD *)((char *)this + 40);
    *(_OWORD *)(v4 + 6) = *(_OWORD *)((char *)this + 24);
    *(_OWORD *)(v4 + 10) = v7;
    *(_OWORD *)(v4 + 14) = v6;
    v4[18] = *((_DWORD *)this + 18);
    unint64_t v4[2] = 1;
    *(void *)uint64_t v4 = &unk_1ED028B80;
    *(_OWORD *)(v4 + 19) = *(_OWORD *)((char *)this + 76);
    long long v8 = *(_OWORD *)((char *)this + 108);
    long long v9 = *(_OWORD *)((char *)this + 124);
    long long v10 = *(_OWORD *)((char *)this + 140);
    *(_OWORD *)(v4 + 23) = *(_OWORD *)((char *)this + 92);
    *(_OWORD *)(v4 + 35) = v10;
    *(_OWORD *)(v4 + 31) = v9;
    *(_OWORD *)(v4 + 27) = v8;
  }
  return v4;
}

uint64_t CA::CG::ColorMatrixStyle::visit(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, a1);
}

void CA::CG::ColorMatrixStyle::~ColorMatrixStyle(CA::CG::Renderer **this, const void *a2)
{
  *this = (CA::CG::Renderer *)&unk_1ED029D48;
  CA::CG::Renderer::release_object(this[2], a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  *this = (CA::CG::Renderer *)&unk_1ED029D48;
  CA::CG::Renderer::release_object(this[2], a2);
}

uint64_t CA::OGL::GLContext::destination_texture_target(CA::OGL::GLContext *this)
{
  return 0;
}

uint64_t CA::OGL::GLContext::ensure_destination_texture(CA::OGL::GLContext *this, const CA::Bounds *a2)
{
  return 0;
}

const char *CA::OGL::GLContext::shader_preamble(CA::OGL::GLContext *this)
{
  return "";
}

void CA::OGL::GLContext::function_uniform(uint64_t **this, uint64_t a2, uint64_t a3, const float *a4, const float *a5, float64x2_t a6, __n128 a7)
{
  unsigned int v8 = a2;
  CA::OGL::GLContext::update_shader((CA::OGL::GLContext *)this, a6, a7, a2, a3, a4);
  if (v8 <= 6)
  {
    long long v10 = this[233];
    if (v10)
    {
      if (*((_DWORD *)v10 + v8 + 36) != -1)
      {
        int v11 = this[262];
        switch(a3)
        {
          case 1:
            uint64_t v12 = 611;
            goto LABEL_10;
          case 2:
            uint64_t v12 = 612;
            goto LABEL_10;
          case 3:
            uint64_t v12 = 613;
            goto LABEL_10;
          case 4:
            uint64_t v12 = 614;
LABEL_10:
            uint64_t v13 = (void (*)(uint64_t))v11[v12];
            uint64_t v14 = *v11;
            v13(v14);
            break;
          default:
            return;
        }
      }
    }
  }
}

void CA::OGL::GLContext::update_shader(CA::OGL::GLContext *this, float64x2_t a2, __n128 a3, uint64_t a4, uint64_t a5, const float *a6)
{
  long long v6 = this;
  v145[1] = *MEMORY[0x1E4F143B8];
  long long v7 = (void *)*((void *)this + 262);
  uint64_t v8 = *((void *)this + 2);
  uint64_t v9 = *((void *)this + 233);
  if (!v9)
  {
    if (*(unsigned char *)(v8 + 16) == 102) {
      return;
    }
LABEL_26:
    uint64_t v24 = *(void *)(v8 + 16);
    unint64_t v25 = CA::OGL::tex_image_count[v24];
    if (CA::OGL::tex_image_count[v24])
    {
      uint64_t v26 = 0;
      unsigned int v27 = 0;
      do
      {
        v27 += CA::OGL::image_plane_count[*(unsigned __int8 *)(v8 + v26 + 17)];
        uint64_t v28 = *(void *)(v8 + 8 * v26 + 40);
        if (v28)
        {
          uint64_t v29 = *(void *)(v28 + 80);
          _ZF = v29 == 0;
          BOOL v30 = v29 != 0;
          int v31 = *(_DWORD *)(v28 + 56);
          if (_ZF) {
            int v32 = 1;
          }
          else {
            int v32 = 2;
          }
          if (v31) {
            int v33 = v32;
          }
          else {
            int v33 = v30;
          }
          v27 += v33;
        }
        ++v26;
      }
      while (v25 != v26);
    }
    else
    {
      unsigned int v27 = 0;
    }
    long long v142 = 0u;
    long long v143 = 0u;
    long long v140 = 0u;
    long long v141 = 0u;
    long long v138 = 0u;
    long long v139 = 0u;
    long long v136 = 0u;
    long long v137 = 0u;
    long long v135 = 0u;
    uint64_t v144 = 0;
    long long v134 = 0u;
    long long v133 = 0u;
    long long v132 = 0u;
    long long v131 = 0u;
    long long v130 = 0u;
    long long v129 = 0u;
    long long v128 = 0u;
    long long v127 = 0u;
    long long v126 = 0u;
    long long v125 = 0u;
    long long v124 = 0u;
    memset(&v123[8], 0, 80);
    *(void *)CFStringRef v123 = v24;
    DWORD1(v134) = -1;
    unsigned int v34 = *(unsigned __int8 *)(v8 + 481);
    unsigned int v35 = *(unsigned __int8 *)(v8 + 480);
    if (((v34 & 1) == 0 || v35 <= 0x19) && *(unsigned char *)(v8 + 480) && (v24 & 0xFE) != 0x10) {
      LOWORD(v35) = 58;
    }
    HIDWORD(v134) = -1;
    v123[38] = (*((unsigned __int16 *)this + 416) >> 12) & 7;
    *(_WORD *)&v123[36] = (v34 >> 1) & 1 | ((_WORD)v35 << 8);
    BYTE6(v124) = (*((unsigned char *)this + 2108) & 2) != 0;
    v123[39] = *(unsigned char *)(v8 + 304);
    if ((int)v27 < 1 || (memcpy(&v123[8], (const void *)(v8 + 144), 2 * v27), v27 <= 0xC)) {
      bzero(&v123[2 * v27 + 8], 2 * (12 - v27) + 2);
    }
    char v36 = v123[36];
    if ((*(_WORD *)&v123[36] & 0xFF00) != 0x3A00 || (CA::OGL::tex_fragment_shader_flags[v123[0]] & 0x10) != 0) {
      goto LABEL_51;
    }
    v145[0] = v24;
    if (!v25) {
      goto LABEL_58;
    }
    if ((v24 & 0xFF00) == 0x2600)
    {
LABEL_51:
      if ((*(unsigned int (**)(CA::OGL::GLContext *, uint64_t))(*(void *)v6 + 184))(v6, 18))
      {
        DWORD2(v134) = 1;
        goto LABEL_58;
      }
      uint64_t v37 = *(void *)v6;
      if (*((void *)v6 + 33))
      {
        int v38 = (*(uint64_t (**)(CA::OGL::GLContext *))(v37 + 1152))(v6);
        if (!v38) {
          goto LABEL_58;
        }
      }
      else
      {
        int v38 = (*(uint64_t (**)(CA::OGL::GLContext *))(v37 + 1160))(v6);
        if (!v38) {
          goto LABEL_58;
        }
      }
      *(_WORD *)&v123[2 * v27 + 8] = v38;
      *(void *)((char *)&v134 + 4) = v27++ | 0x100000000;
      char v36 = v123[36];
      goto LABEL_58;
    }
    unint64_t v86 = 0;
    while (v25 - 1 != v86)
    {
      int v87 = *((unsigned __int8 *)v145 + v86++ + 2);
      if (v87 == 38)
      {
        if (v86 < v25) {
          goto LABEL_51;
        }
        break;
      }
    }
LABEL_58:
    uint64_t v39 = (uint64_t)v6;
    if (v36)
    {
      *(_WORD *)&v123[2 * v27 + 8] = 3553;
      HIDWORD(v134) = v27++;
    }
    unint64_t v40 = 0;
    unint64_t v41 = CA::OGL::tex_image_count[v123[0]];
    long long v136 = 0u;
    long long v137 = 0u;
    long long v138 = 0u;
    long long v139 = 0u;
    char v42 = 1;
    do
    {
      char v43 = v42;
      if (v40 < v41 && (uint64_t v44 = *(void *)(v8 + 8 * v40 + 40)) != 0)
      {
        unint64_t v45 = &v123[32 * v40];
        *((_DWORD *)v45 + 70) = *(_DWORD *)(v44 + 36);
        *((_WORD *)v45 + 147) = *(_DWORD *)(v44 + 40);
        uint64_t v46 = *(void *)(v44 + 80);
        if (v46) {
          LODWORD(v46) = *(_DWORD *)(v44 + 92);
        }
        uint64_t v47 = v45 + 280;
        *((_WORD *)v45 + 144) = v46;
        uint64_t v48 = *(void *)(v44 + 64);
        if (v48)
        {
          *((_WORD *)v47 + 2) = *(_DWORD *)(v48 + 20);
          *((_WORD *)v47 + 3) = *(_DWORD *)(v48 + 16);
        }
        uint64_t v49 = v8 + v40;
        v47[18] = *(unsigned char *)(v49 + 56);
        v47[19] = *(unsigned char *)(v49 + 58);
        uint64_t v50 = *(void *)(v44 + 80);
        _ZF = v50 == 0;
        __int16 v51 = v50 != 0;
        if (_ZF) {
          __int16 v52 = 1;
        }
        else {
          __int16 v52 = 2;
        }
        if (*(_DWORD *)(v44 + 56)) {
          __int16 v51 = v52;
        }
        *((_WORD *)v47 + 8) = v51;
        *((_WORD *)v47 + 5) = CGColorSpaceGetNumberOfComponents(*(CGColorSpaceRef *)(v44 + 16));
        *((_WORD *)v47 + 6) = CGColorSpaceGetNumberOfComponents(*(CGColorSpaceRef *)(v44 + 24));
      }
      else
      {
        double v53 = &v123[32 * v40];
        *((_DWORD *)v53 + 70) = 0;
        *((_WORD *)v53 + 147) = 0;
      }
      char v42 = 0;
      unint64_t v40 = 1;
    }
    while ((v43 & 1) != 0);
    long long v6 = (CA::OGL::GLContext *)v39;
    double v54 = *(void **)(v39 + 1904);
    if (!v54)
    {
      double v54 = x_hash_table_new_((unint64_t (*)(uint64_t))CA::OGL::gl_shader_hash, (BOOL (*)(uint64_t, uint64_t))CA::OGL::gl_shader_compare, 0, 0, 0, 0);
      *(void *)(v39 + 1904) = v54;
    }
    uint64_t v9 = x_hash_table_lookup((uint64_t)v54, (uint64_t)v123, 0);
    if (!v9)
    {
      shader = CA::OGL::GLContext::create_shader(v39, v123, v27);
      if (!shader)
      {
        if (!*(void *)(v39 + 1864)) {
          return;
        }
        goto LABEL_24;
      }
      uint64_t v9 = (uint64_t)shader;
      hash_table_modify(*(int **)(v39 + 1904), v9, v9, 0);
    }
    if (*(void *)(v39 + 1864) == v9) {
      goto LABEL_83;
    }
    unsigned int v56 = *(_DWORD *)(v9 + 56);
LABEL_82:
    ((void (*)(void, void))v7[601])(*v7, v56);
    *((void *)v6 + 233) = v9;
LABEL_83:
    if (!v9) {
      return;
    }
    goto LABEL_84;
  }
  if (*(_DWORD *)v9 != *(_DWORD *)(v8 + 16) || *(_DWORD *)(v9 + 4) != *(_DWORD *)(v8 + 20))
  {
LABEL_23:
    if (*(_DWORD *)(v8 + 16) == 102)
    {
LABEL_24:
      uint64_t v9 = 0;
      unsigned int v56 = 0;
      goto LABEL_82;
    }
    goto LABEL_26;
  }
  uint64_t v10 = *(unsigned __int8 *)(v9 + 34);
  if (*(unsigned char *)(v9 + 34))
  {
    int v11 = (unsigned __int16 *)(v9 + 8);
    uint64_t v12 = (unsigned __int16 *)(v8 + 144);
    do
    {
      int v14 = *v12++;
      int v13 = v14;
      int v15 = *v11++;
      if (v13 != v15) {
        goto LABEL_23;
      }
    }
    while (--v10);
  }
  uint64_t v16 = *(unsigned __int8 *)(v9 + 35);
  if (*(unsigned char *)(v9 + 35))
  {
    uint64_t v17 = (_DWORD *)(v9 + 280);
    uint64_t v18 = (uint64_t *)(v8 + 40);
    do
    {
      uint64_t v19 = *v18;
      if (*v18) {
        LODWORD(v19) = *(_DWORD *)(v19 + 36);
      }
      if (*v17 != v19) {
        goto LABEL_23;
      }
      v17 += 8;
      ++v18;
    }
    while (--v16);
  }
  __int16 v20 = *(_WORD *)(v9 + 36);
  unsigned int v21 = *(unsigned __int8 *)(v8 + 481);
  unsigned int v22 = *(unsigned __int8 *)(v8 + 480);
  if (((v21 & 1) == 0 || v22 <= 0x19) && *(unsigned char *)(v8 + 480) && (*(_DWORD *)v9 & 0xFE) != 0x10) {
    unsigned int v22 = 58;
  }
  _ZF = v22 == HIBYTE(v20) && (v20 & 1) == ((v21 >> 1) & 1);
  if (!_ZF || *(unsigned char *)(v9 + 94) != ((*((unsigned __int8 *)this + 2108) >> 1) & 1)) {
    goto LABEL_23;
  }
LABEL_84:
  if (*(unsigned char *)(v9 + 92))
  {
    double v57 = (__n128 *)(v8 + 24);
    if (*(float *)(v9 + 60) != *(float *)(v8 + 24)
      || *(float *)(v9 + 64) != *(float *)(v8 + 28)
      || *(float *)(v9 + 68) != *(float *)(v8 + 32)
      || *(float *)(v9 + 72) != *(float *)(v8 + 36))
    {
      ((void (*)(void, void, uint64_t, uint64_t))v7[614])(*v7, *(unsigned int *)(v9 + 144), 1, v8 + 24);
      a2 = *(float64x2_t *)v57;
      *(__n128 *)(v9 + 60) = *v57;
    }
  }
  if (*(unsigned char *)(v9 + 93)
    && (*(float *)(v9 + 76) != *(float *)(v8 + 368)
     || *(float *)(v9 + 80) != *(float *)(v8 + 372)
     || *(float *)(v9 + 84) != *(float *)(v8 + 376)
     || *(float *)(v9 + 88) != *(float *)(v8 + 380)))
  {
    ((void (*)(void, void, uint64_t, uint64_t))v7[614])(*v7, *(unsigned int *)(v9 + 148), 1, v8 + 368);
    a2 = *(float64x2_t *)(v8 + 368);
    *(float64x2_t *)(v9 + 76) = a2;
  }
  if (*(_DWORD *)(v9 + 408) != *((_DWORD *)v6 + 64))
  {
    if (*(_DWORD *)(v9 + 232) != -1)
    {
      HIDWORD(a2.f64[0]) = 0;
      a2.f64[1] = 0.0;
      memset(v123, 0, 64);
      uint64_t v58 = (float *)*((void *)v6 + 257);
      uint64_t v59 = (float *)*((void *)v6 + 102);
      if (v59)
      {
        a2 = CA::Mat4Impl::mat4_concat((float32x4_t *)v123, v59, (const double *)*((void *)v6 + 257), a6);
        uint64_t v58 = (float *)v123;
      }
      if (*(float *)(v9 + 168) == *v58)
      {
        uint64_t v82 = 0;
        while (v82 != 15)
        {
          uint64_t v83 = v82 + 1;
          float v84 = *(float *)(v9 + 172 + 4 * v82);
          float v85 = v58[++v82];
          if (v84 != v85)
          {
            if ((unint64_t)(v83 - 1) <= 0xE) {
              goto LABEL_101;
            }
            break;
          }
        }
      }
      else
      {
LABEL_101:
        long long v60 = *((_OWORD *)v58 + 1);
        long long v61 = *((_OWORD *)v58 + 2);
        long long v62 = *((_OWORD *)v58 + 3);
        *(_OWORD *)(v9 + 168) = *(_OWORD *)v58;
        *(_OWORD *)(v9 + 184) = v60;
        *(_OWORD *)(v9 + 200) = v61;
        *(_OWORD *)(v9 + 216) = v62;
        ((void (*)(void, void, uint64_t, void))v7[621])(*v7, *(unsigned int *)(v9 + 232), 1, 0);
      }
    }
    if ((*(_DWORD *)(v9 + 272) & 0x80000000) == 0)
    {
      float32x2_t v63 = vmul_f32(vcvt_f32_s32(*(int32x2_t *)((char *)v6 + 2072)), (float32x2_t)0x3F0000003F000000);
      float32x2_t v64 = vadd_f32(v63, vcvt_f32_s32(*(int32x2_t *)((char *)v6 + 2064)));
      *(float32x2_t *)CFStringRef v123 = v63;
      *(float32x2_t *)&v123[8] = v64;
      ((void (*)(void))v7[614])(*v7);
    }
    *(_DWORD *)(v9 + 408) = *((_DWORD *)v6 + 64);
  }
  unsigned int v65 = *(unsigned __int8 *)(v9 + 35);
  if (*(unsigned char *)(v9 + 35))
  {
    unint64_t v66 = 0;
    double v67 = (unsigned int *)(v9 + 304);
    do
    {
      if (*((_WORD *)v67 - 5))
      {
        uint64_t v68 = *(void *)(v8 + 40 + 8 * v66);
        unsigned int v69 = *(_DWORD *)(v68 + 8);
        if (*(v67 - 1) != v69)
        {
          uint64_t v70 = *(unsigned int *)(v68 + 40);
          if (v70)
          {
            ((void (*)(void, void, uint64_t, void))v7[614])(*v7, *v67, v70, *(void *)(v68 + 48));
            unsigned int v69 = *(_DWORD *)(v68 + 8);
            unsigned int v65 = *(unsigned __int8 *)(v9 + 35);
          }
          *(v67 - 1) = v69;
        }
      }
      ++v66;
      v67 += 8;
    }
    while (v66 < v65);
    if (v65)
    {
      uint64_t v71 = 0;
      unint64_t v72 = 0;
      uint64_t v73 = 396;
      do
      {
        unsigned int v74 = *(unsigned __int8 *)(v8 + v72 + 17);
        BOOL v75 = v74 > 0x28;
        uint64_t v76 = (1 << v74) & 0x18000400000;
        if (!v75 && v76 != 0)
        {
          if ((*(_DWORD *)(v9 + v73 - 16) & 0x80000000) == 0)
          {
            uint64_t v78 = v8 + v72;
            if (*(unsigned __int8 *)(v9 + v72 + 344) != *(unsigned __int8 *)(v8 + v72 + 60))
            {
              ((void (*)(void))v7[620])(*v7);
              ((void (*)(void, void, uint64_t, char *))v7[613])(*v7, *(unsigned int *)(v9 + v73 - 8), 1, &CA::OGL::ycbcr_matrices[48 * *(unsigned __int8 *)(v78 + 60) + 36]);
              *(unsigned char *)(v9 + v72 + 344) = *(unsigned char *)(v78 + 60);
            }
          }
          if ((*(_DWORD *)(v9 + v73) & 0x80000000) == 0)
          {
            uint64_t v79 = v9 + v71;
            if (*(float *)(v9 + v71 + 348) != *(float *)(v8 + v71 + 64)
              || *(float *)(v79 + 352) != *(float *)(v8 + v71 + 68)
              || *(float *)(v9 + v71 + 356) != *(float *)(v8 + v71 + 72)
              || *(float *)(v9 + v71 + 360) != *(float *)(v8 + v71 + 76))
            {
              *(_OWORD *)(v79 + 348) = *(_OWORD *)(v8 + v71 + 64);
              ((void (*)(void, void, uint64_t))v7[614])(*v7, *(unsigned int *)(v9 + v73), 1);
            }
          }
        }
        ++v72;
        v71 += 16;
        v73 += 4;
      }
      while (v72 < *(unsigned __int8 *)(v9 + 35));
    }
  }
  if ((*(_DWORD *)(v9 + 404) & 0x80000000) == 0)
  {
    uint64_t v80 = *(void *)(*((void *)v6 + 2) + 360);
    if (v80)
    {
      *(void *)&v123[8] = 0;
      float v81 = -1.0;
      if (!*(unsigned char *)(v80 + 4)) {
        float v81 = 1.0;
      }
      *(void *)CFStringRef v123 = __PAIR64__(*(_DWORD *)(v80 + 16), LODWORD(v81));
      LODWORD(a2.f64[0]) = 0.5;
      a3.n128_u32[0] = -0.5;
      switch(*(_DWORD *)v80)
      {
        case 1:
          LODWORD(a2.f64[0]) = *(_DWORD *)(v80 + 8);
          *(_DWORD *)&v123[8] = LODWORD(a2.f64[0]);
          break;
        case 2:
          goto LABEL_149;
        case 3:
          a2.f64[0] = 0.0;
          a3.n128_u32[0] = -1.0;
          goto LABEL_149;
        case 4:
          LODWORD(a2.f64[0]) = 1.0;
          a3.n128_u64[0] = 0;
LABEL_149:
          float v88 = *(float *)(v80 + 12);
          a3.n128_f32[0] = *(float *)(v80 + 8) + (float)(v88 * a3.n128_f32[0]);
          *(_DWORD *)&v123[8] = a3.n128_u32[0];
          *(float *)a2.f64 = *(float *)(v80 + 8) + (float)(v88 * *(float *)a2.f64);
          *(_DWORD *)&v123[12] = LODWORD(a2.f64[0]);
          if (*(float *)a2.f64 <= a3.n128_f32[0]) {
            *(void *)&v123[8] = __PAIR64__(a3.n128_u32[0], LODWORD(a2.f64[0]));
          }
          break;
        default:
          break;
      }
      ((void (*)(void, __n128, __n128))v7[614])(*v7, (__n128)a2, a3);
    }
  }
  uint64_t v89 = 0;
  char v90 = 1;
  do
  {
    char v91 = v90;
    uint64_t v92 = v9 + 8 * v89;
    uint64_t v94 = *(void *)(v92 + 40);
    uint64_t v93 = (void *)(v92 + 40);
    uint64_t v95 = *(void *)(v8 + 8 * v89 + 288);
    if (v94 != v95 && (*(_DWORD *)(v9 + 4 * v89 + 236) & 0x80000000) == 0)
    {
      *uint64_t v93 = v95;
      _H0 = v95;
      __asm { FCVT            S0, H0 }
      _H1 = WORD1(v95);
      __asm { FCVT            S1, H1 }
      _H2 = WORD2(v95);
      __asm { FCVT            S2, H2 }
      _H3 = HIWORD(v95);
      __asm { FCVT            S3, H3 }
      ((void (*)(void, float, float, float, float))v7[606])(*v7, _S0, _S1, _S2, _S3);
    }
    char v90 = 0;
    uint64_t v89 = 1;
  }
  while ((v91 & 1) != 0);
  if ((*(_DWORD *)(v9 + 252) & 0x80000000) == 0)
  {
    uint64_t v107 = *((void *)v6 + 33);
    if (v107)
    {
      if (*(_DWORD *)(v9 + 256))
      {
        uint64_t v108 = 0;
        do
        {
          (*(void (**)(CA::OGL::GLContext *, uint64_t, uint64_t, void, void, void, double))(*(void *)v6 + 776))(v6, v107, v108, (v108 + *(_DWORD *)(v9 + 252)), 0, 0, 0.0);
          uint64_t v108 = (v108 + 1);
        }
        while (v108 < *(_DWORD *)(v9 + 256));
      }
      *(void *)&long long v109 = 0x3F0000003F000000;
      if ((*(_WORD *)(v107 + 75) & 0x10) == 0) {
        *(float32x2_t *)&long long v109 = vmul_f32(vcvt_f32_s32(*(int32x2_t *)(v107 + 24)), (float32x2_t)0x3F0000003F000000);
      }
      *((void *)&v109 + 1) = v109;
      *(_OWORD *)(*((void *)v6 + 2) + 128) = v109;
    }
    else
    {
      (*(void (**)(CA::OGL::GLContext *))(*(void *)v6 + 1168))(v6);
    }
    if ((*(_DWORD *)(v9 + 268) & 0x80000000) == 0
      && (*(float *)(v9 + 128) != *(float *)(v8 + 128)
       || *(float *)(v9 + 132) != *(float *)(v8 + 132)
       || *(float *)(v9 + 136) != *(float *)(v8 + 136)
       || *(float *)(v9 + 140) != *(float *)(v8 + 140)))
    {
      *(_OWORD *)(v9 + 128) = *(_OWORD *)(v8 + 128);
      ((void (*)(void))v7[614])(*v7);
    }
  }
  if ((*(_DWORD *)(v9 + 260) & 0x80000000) == 0) {
    (*(void (**)(CA::OGL::GLContext *))(*(void *)v6 + 1128))(v6);
  }
  if ((*(_DWORD *)(v9 + 264) & 0x80000000) == 0)
  {
    float v110 = *((float *)v6 + 526) * (*(float *)(*((void *)v6 + 2) + 352) + *(float *)(*((void *)v6 + 2) + 352));
    ((void (*)(void, float))v7[603])(*v7, v110);
  }
  uint64_t v111 = 0;
  char v112 = 1;
  do
  {
    char v113 = v112;
    if ((*(_DWORD *)(v9 + 4 * v111 + 244) & 0x80000000) == 0)
    {
      uint64_t v114 = v9 + 16 * v111;
      float v116 = *(float *)(v114 + 96);
      float v115 = (_OWORD *)(v114 + 96);
      float v117 = v116;
      uint64_t v118 = v8 + 16 * v111;
      float v120 = *(float *)(v118 + 96);
      float32_t v119 = (_OWORD *)(v118 + 96);
      if (v117 != v120
        || *(float *)(v9 + 16 * v111 + 100) != *(float *)(v8 + 16 * v111 + 100)
        || (uint64_t v121 = v9 + 16 * v111, v122 = v8 + 16 * v111, *(float *)(v121 + 104) != *(float *)(v122 + 104))
        || *(float *)(v121 + 108) != *(float *)(v122 + 108))
      {
        *float v115 = *v119;
        ((void (*)(void))v7[614])(*v7);
      }
    }
    char v112 = 0;
    uint64_t v111 = 1;
  }
  while ((v113 & 1) != 0);
}

char *CA::OGL::GLContext::create_shader(uint64_t a1, unsigned __int8 *a2, int a3)
{
  uint64_t v4 = a1;
  v613[1] = *MEMORY[0x1E4F143B8];
  int v5 = *(void **)(a1 + 2096);
  if (*(void *)(a1 + 1864))
  {
    *(void *)(a1 + 1864) = 0;
    ((void (*)(void, void))v5[601])(*v5, 0);
  }
  uint64_t v6 = *a2;
  uint64_t v7 = CA::OGL::tex_image_count[v6];
  if (a2[94]) {
    unsigned int v8 = 7;
  }
  else {
    unsigned int v8 = CA::OGL::tex_vertex_shader_indices[v6];
  }
  int v9 = byte_1EB2ACBEC;
  if (v8) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = v7 == 0;
  }
  uint64_t v597 = *a2;
  v598 = v5;
  uint64_t v599 = v4;
  v600 = a2;
  if (v10)
  {
LABEL_11:
    if (a2[94])
    {
LABEL_12:
      int v11 = 0;
    }
    else
    {
      unsigned int v12 = *(_DWORD *)(v4 + 4 * CA::OGL::tex_vertex_shader_indices[v6] + 1872);
      int v11 = 1;
      if (v12) {
        goto LABEL_101;
      }
    }
  }
  else
  {
    uint64_t v15 = 0;
    while (1)
    {
      int v11 = 0;
      int v16 = a2[v15 + 1];
      if (v16 == 22 || v16 == 40) {
        break;
      }
      if ((a2[39] >> v15)) {
        goto LABEL_12;
      }
      if (v7 == ++v15) {
        goto LABEL_11;
      }
    }
  }
  unsigned int v12 = ((uint64_t (*)(void, uint64_t))v5[595])(*v5, 35633);
  uint64_t v589 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 1112))(v4);
  *(void *)&long long v605 = v589;
  unsigned int v593 = v8;
  if (!v8)
  {
    if (v11) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = a2;
    }
    memset(buf, 0, sizeof(buf));
    *(void *)&v608[0] = 0;
    if (v17)
    {
      uint64_t v18 = *v17;
      int v601 = CA::OGL::tex_fragment_shader_flags[v18];
      int v19 = CA::OGL::tex_image_count[v18];
    }
    else
    {
      int v19 = 0;
      LOBYTE(v601) = -1;
    }
    x_stream_write((uint64_t)buf, "uniform highp mat4 vertex_matrix;\n", 0x22uLL);
    x_stream_write((uint64_t)buf, "uniform highp vec4 texmat0, texmat1, texmat2;\n", 0x2EuLL);
    unsigned int v587 = v12;
    int v585 = v9;
    if (v17)
    {
      if ((*((_DWORD *)v17 + 63) & 0x80000000) == 0) {
        x_stream_write((uint64_t)buf, "uniform highp vec4 texmatD;\n", 0x1CuLL);
      }
      if ((*((_DWORD *)v17 + 65) & 0x80000000) != 0)
      {
LABEL_35:
        if (v17 && v19)
        {
          for (uint64_t i = 0; i != v19; ++i)
          {
            int v27 = v17[i + 1];
            if (v27 == 40 || v27 == 22) {
              x_stream_printf((uint64_t)buf, "uniform highp vec4 chroma_matrix%d;\n", v20, v21, v22, v23, v24, v25, i);
            }
          }
        }
        int v580 = v19;
        x_stream_write((uint64_t)buf, "attribute highp vec4 vertex_position;\n", 0x26uLL);
        x_stream_write((uint64_t)buf, "attribute lowp vec4 vertex_color;\n", 0x22uLL);
        x_stream_write((uint64_t)buf, "attribute highp vec2 vertex_texcoord0, vertex_texcoord1;\n", 0x39uLL);
        x_stream_write((uint64_t)buf, "attribute mediump vec3 vertex_normal;\n", 0x26uLL);
        if (v601) {
          x_stream_write((uint64_t)buf, "varying lowp vec4 color;\n", 0x19uLL);
        }
        unsigned int v35 = v17;
        if (v17)
        {
          int v36 = v11;
          if (v580)
          {
            for (uint64_t j = 0; j != v580; ++j)
            {
              if ((v35[39] >> j)) {
                int v38 = 4 * byte_18499EBD8[v35[j + 1]];
              }
              else {
                int v38 = byte_18499EBD8[v35[j + 1]];
              }
              if (v38)
              {
                for (int k = 0; k != v38; ++k)
                  x_stream_printf((uint64_t)buf, "varying highp vec2 texcoord%d_%d;\n", v29, v30, v31, v32, v33, v34, j);
              }
            }
          }
          unsigned int v12 = v587;
          if ((*((_DWORD *)v35 + 63) & 0x80000000) == 0) {
            x_stream_write((uint64_t)buf, "varying highp vec3 texcoordD;\n", 0x1EuLL);
          }
          uint64_t v6 = v597;
          int v11 = v36;
          if ((*((_DWORD *)v35 + 65) & 0x80000000) != 0)
          {
LABEL_63:
            x_stream_write((uint64_t)buf, "\nvoid main() {\n", 0xFuLL);
            x_stream_write((uint64_t)buf, "  gl_Positiouint64_t n = vertex_matrix * vertex_position;\n", 0x31uLL);
            if (v601) {
              x_stream_write((uint64_t)buf, "  color = vertex_color;\n", 0x18uLL);
            }
            if (v35)
            {
              __int16 v52 = v35;
              uint64_t v583 = v7;
              if (v580)
              {
                uint64_t v53 = 0;
                while (1)
                {
                  uint64_t v54 = v52[v53 + 1];
                  if (((0x4200080000uLL >> v54) & 1) == 0) {
                    break;
                  }
LABEL_84:
                  ++v53;
                  __int16 v52 = v35;
                  if (v53 == v580) {
                    goto LABEL_85;
                  }
                }
                int v55 = 0;
                if (byte_18499EBD8[v54] <= 1u) {
                  int v56 = 1;
                }
                else {
                  int v56 = byte_18499EBD8[v54];
                }
                while (1)
                {
                  if (v54 == 40 || v54 == 22)
                  {
                    if (!v55) {
                      goto LABEL_82;
                    }
                    x_stream_printf((uint64_t)buf, "  texcoord%d_%d = texcoord%d_0 * chroma_matrix%d.xy + chroma_matrix%d.zw;\n",
                      v46,
                      v47,
                      v48,
                      v49,
                      v50,
                      v51,
                      v53);
                  }
                  else
                  {
                    if (((1 << v53) & v35[39]) != 0)
                    {
                      uint64_t v57 = 0;
                      uint64_t v58 = (char *)&unk_18499D0DC;
                      do
                      {
                        x_stream_printf((uint64_t)buf, "  texcoord%d_%d = (vertex_texcoord%d + vec2(%g, %g)) * texmat%d.xy + texmat%d.zw;\n",
                          v46,
                          v47,
                          v48,
                          v49,
                          v50,
                          v51,
                          v53);
                        ++v57;
                        v58 += 8;
                      }
                      while (v57 != 4);
                      goto LABEL_83;
                    }
                    if (!v55)
                    {
LABEL_82:
                      x_stream_printf((uint64_t)buf, "  texcoord%d_0 = vertex_texcoord%d * texmat%d.xy + texmat%d.zw;\n",
                        v46,
                        v47,
                        v48,
                        v49,
                        v50,
                        v51,
                        v53);
                      goto LABEL_83;
                    }
                    x_stream_printf((uint64_t)buf, "  texcoord%d_%d = texcoord%d_0;\n",
                      v46,
                      v47,
                      v48,
                      v49,
                      v50,
                      v51,
                      v53);
                  }
LABEL_83:
                  if (++v55 == v56) {
                    goto LABEL_84;
                  }
                }
              }
LABEL_85:
              if ((*((_DWORD *)v52 + 63) & 0x80000000) == 0) {
                x_stream_write((uint64_t)buf, "  texcoordD = vec3(gl_Position.xy * texmatD.xy + texmatD.zw * gl_Position.w, gl_Position.w);\n",
              }
                  0x5DuLL);
              uint64_t v6 = v597;
              uint64_t v7 = v583;
              unsigned int v12 = v587;
              int v9 = v585;
              if ((*((_DWORD *)v52 + 65) & 0x80000000) != 0)
              {
LABEL_91:
                x_stream_write((uint64_t)buf, "}\n", 2uLL);
                int v14 = x_stream_finish((uint64_t)buf);
                int v13 = v14;
                goto LABEL_92;
              }
            }
            else
            {
              x_stream_printf((uint64_t)buf, "  texcoord%d_0 = vertex_texcoord%d * texmat%d.xy + texmat%d.zw;\n",
                v46,
                v47,
                v48,
                v49,
                v50,
                v51,
                0);
              x_stream_printf((uint64_t)buf, "  texcoord%d_0 = vertex_texcoord%d * texmat%d.xy + texmat%d.zw;\n",
                v59,
                v60,
                v61,
                v62,
                v63,
                v64,
                1);
              x_stream_write((uint64_t)buf, "  texcoordD = vec3(gl_Position.xy * texmatD.xy + texmatD.zw * gl_Position.w, gl_Position.w);\n",
                0x5DuLL);
            }
            x_stream_write((uint64_t)buf, "  texcoordN = vec3(gl_Position.xy * texmatW.xy + texmatW.zw * gl_Position.w, gl_Position.w * float(NOISE_SIZE));\n",
              0x71uLL);
            goto LABEL_91;
          }
        }
        else
        {
          x_stream_printf((uint64_t)buf, "varying highp vec2 texcoord%d_0;\n", v29, v30, v31, v32, v33, v34, 0);
          x_stream_printf((uint64_t)buf, "varying highp vec2 texcoord%d_0;\n", v40, v41, v42, v43, v44, v45, 1);
          x_stream_write((uint64_t)buf, "varying highp vec3 texcoordD;\n", 0x1EuLL);
          unsigned int v12 = v587;
        }
        x_stream_write((uint64_t)buf, "varying highp vec3 texcoordN;\n", 0x1EuLL);
        goto LABEL_63;
      }
    }
    else
    {
      x_stream_write((uint64_t)buf, "uniform highp vec4 texmatD;\n", 0x1CuLL);
    }
    x_stream_write((uint64_t)buf, "uniform highp vec4 texmatW;\n", 0x1CuLL);
    goto LABEL_35;
  }
  int v13 = 0;
  int v14 = (unsigned char *)CA::OGL::vertex_shaders[v8];
LABEL_92:
  *((void *)&v605 + 1) = v14;
  if (v9)
  {
    if (x_log_hook_p())
    {
      uint64_t v557 = *(unsigned int *)a2;
      x_log_();
    }
    else
    {
      unsigned int v65 = x_log_category_CADebug;
      if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO))
      {
        int v66 = *(_DWORD *)a2;
        int v67 = *((_DWORD *)a2 + 1);
        *(_DWORD *)uint64_t buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v66;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v67;
        *(_WORD *)&buf[14] = 2080;
        *(void *)&v608[0] = v589;
        WORD4(v608[0]) = 2080;
        *(void *)((char *)v608 + 10) = v14;
        _os_log_impl(&dword_184668000, v65, OS_LOG_TYPE_INFO, "%08x %08x vertex shader:\n---\n%s%s---\n", buf, 0x22u);
      }
    }
  }
  int v5 = v598;
  ((void (*)(void, void, uint64_t, long long *, void))v598[596])(*v598, v12, 2, &v605, 0);
  ((void (*)(void, void))v5[597])(*v5, v12);
  if (v13) {
    free(v13);
  }
  uint64_t v4 = v599;
  if (v11) {
    *(_DWORD *)(v599 + 4 * v593 + 1872) = v12;
  }
LABEL_101:
  if (v6 > 0x2E || ((1 << v6) & 0x7A3FEC000000) == 0)
  {
    unint64_t v125 = *a2;
    if (v125 > 0x66 || !CA::OGL::tex_fragment_shaders[v125]) {
      return 0;
    }
    uint64_t v126 = v4;
    int v586 = v9;
    unsigned int v588 = v12;
    char v577 = v11;
    long long v127 = (void *)CA::OGL::tex_image_count[*a2];
    uint64_t v612 = 0;
    v613[0] = 0;
    v610[1] = 0;
    uint64_t v611 = 0;
    v610[0] = 0;
    v595 = v127;
    if (v127)
    {
      long long v128 = 0;
      unint64_t v129 = 0;
      unsigned int v130 = 0;
      char v131 = 0;
      LODWORD(v127) = 0;
      unsigned int v132 = a2[39];
      long long v133 = (unsigned __int16 *)(a2 + 296);
      do
      {
        uint64_t v134 = *((unsigned __int8 *)v128 + (void)a2 + 1);
        int v135 = CA::OGL::image_fragment_shader_flags[v134];
        if (v135) {
          long long v136 = "mediump";
        }
        else {
          long long v136 = "lowp";
        }
        v610[(void)v128] = v136;
        int v137 = CA::OGL::image_plane_count[v134];
        *((_DWORD *)v613 + (void)v128) = v137;
        unsigned __int8 v138 = *((unsigned char *)v128 + (void)a2 + 3);
        int v139 = byte_18499EBD8[v134];
        if ((v132 >> (char)v128)) {
          v139 *= 4;
        }
        *((_DWORD *)&v613[-1] + (void)v128) = v139;
        *((_DWORD *)&v611 + (void)v128) = v137;
        if (*((_DWORD *)v133 - 4))
        {
          v137 += *v133;
          *((_DWORD *)&v611 + (void)v128) = v137;
        }
        v129 |= 1 << v134;
        v130 |= 1 << v138;
        v131 |= v135;
        LODWORD(v127) = v137 + v127;
        long long v128 = (char *)v128 + 1;
        v133 += 16;
        a2 = v600;
      }
      while (v595 != v128);
    }
    else
    {
      char v131 = 0;
      unsigned int v130 = 0;
      unint64_t v129 = 0;
    }
    if ((*((_DWORD *)a2 + 63) & 0x80000000) == 0) {
      LODWORD(v127) = *((_DWORD *)a2 + 64) + v127;
    }
    unsigned int v12 = v588;
    uint64_t v143 = v127 + (*((_DWORD *)a2 + 65) >= 0);
    if ((int)v143 > 13)
    {
      int v602 = 0;
      uint64_t v68 = 0;
      LOBYTE(v11) = v577;
      uint64_t v4 = v126;
      goto LABEL_467;
    }
    uint64_t v609 = 0;
    *(_OWORD *)uint64_t buf = 0u;
    memset(v608, 0, sizeof(v608));
    uint64_t v144 = v143;
    if ((int)v143 >= 1)
    {
      uint64_t v145 = (unsigned __int16 *)(a2 + 8);
      unint64_t v146 = buf;
      uint64_t v147 = v144;
      do
      {
        int v149 = *v145++;
        int v148 = v149;
        if (v149 == 32879) {
          float32x4_t v150 = "3D";
        }
        else {
          float32x4_t v150 = "2DRect";
        }
        if (v148 == 3553) {
          int v151 = "2D";
        }
        else {
          int v151 = v150;
        }
        *(void *)unint64_t v146 = v151;
        v146 += 8;
        --v147;
      }
      while (v147);
    }
    long long v605 = 0uLL;
    uint64_t v606 = 0;
    if ((v131 & 2) != 0) {
      x_stream_write((uint64_t)&v605, "#extension GL_OES_standard_derivatives : require\n\n", 0x32uLL);
    }
    if (*((_DWORD *)a2 + 64) && (*((_DWORD *)a2 + 63) & 0x80000000) != 0) {
      x_stream_write((uint64_t)&v605, "#extension GL_EXT_shader_framebuffer_fetch : require\n\n", 0x36uLL);
    }
    int v152 = CA::OGL::tex_fragment_shader_flags[*a2];
    char v591 = CA::OGL::blend_modes[a2[37]];
    x_stream_write((uint64_t)&v605, "uniform highp vec4 texmat0, texmat1, texmat2;\n", 0x2EuLL);
    __int16 v570 = v152;
    if ((v152 & 4) != 0) {
      x_stream_printf((uint64_t)&v605, "uniform lowp vec4 function_arg;\n", v153, v154, v155, v156, v157, v158, v557);
    }
    int v159 = a2[3];
    if (v159 == 5 || v159 == 3) {
      x_stream_printf((uint64_t)&v605, "uniform lowp vec4 coord_arg;\n", v153, v154, v155, v156, v157, v158, v557);
    }
    if ((*((_DWORD *)a2 + 65) & 0x80000000) == 0) {
      x_stream_write((uint64_t)&v605, "uniform mediump float noise_scale;\n", 0x23uLL);
    }
    int v602 = v144;
    uint64_t v584 = v7;
    int v160 = (int)v595;
    if (v595)
    {
      int8x8_t v161 = 0;
      int v160 = 0;
      do
      {
        int v162 = *((_DWORD *)&v611 + (void)v161);
        if (v162 >= 1)
        {
          uint64_t v163 = v610[(void)v161];
          int v164 = v160;
          do
          {
            x_stream_printf((uint64_t)&v605, "uniform %s sampler%s texture%d;\n",
              v153,
              v154,
              v155,
              v156,
              v157,
              v158,
              v163);
            ++v164;
            --v162;
          }
          while (v162);
          int v160 = v164;
        }
        int8x8_t v161 = (char *)v161 + 1;
      }
      while (v161 != v595);
    }
    if (v160 < v602)
    {
      unsigned int v165 = (uint64_t *)&buf[8 * v160];
      int v166 = v160;
      do
      {
        uint64_t v167 = *v165++;
        x_stream_printf((uint64_t)&v605, "uniform lowp sampler%s texture%d;\n", v153, v154, v155, v156, v157, v158, v167);
        ++v166;
      }
      while (v602 != v166);
    }
    if ((v591 & 4) != 0)
    {
      x_stream_write((uint64_t)&v605, "uniform lowp vec4 blend_color0;\n", 0x20uLL);
      x_stream_write((uint64_t)&v605, "uniform lowp vec4 blend_color1;\n", 0x20uLL);
    }
    if (v595)
    {
      uint64_t v168 = 0;
      int v169 = (unsigned __int16 *)(v600 + 294);
      do
      {
        int v170 = *v169;
        v169 += 16;
        if (v170) {
          x_stream_printf((uint64_t)&v605, "uniform mediump vec4 colorP%d[%d];\n",
        }
            v153,
            v154,
            v155,
            v156,
            v157,
            v158,
            v168);
        ++v168;
      }
      while (v595 != (void *)v168);
      if ((v129 & 0x18000400000) != 0)
      {
        for (uint64_t m = 0; (void *)m != v595; ++m)
        {
          unsigned int v172 = v600[m + 1];
          BOOL v173 = v172 > 0x28;
          uint64_t v174 = (1 << v172) & 0x18000400000;
          if (!v173 && v174 != 0)
          {
            x_stream_printf((uint64_t)&v605, "uniform mediump mat3 ycbcr_matrix%d;\n",
              v153,
              v154,
              v155,
              v156,
              v157,
              v158,
              m);
            x_stream_printf((uint64_t)&v605, "uniform mediump vec3 ycbcr_bias%d;\n",
              v176,
              v177,
              v178,
              v179,
              v180,
              v181,
              m);
          }
        }
      }
    }
    if ((v131 & 4) != 0) {
      x_stream_printf((uint64_t)&v605, "uniform mediump vec4 render_state;\n", v153, v154, v155, v156, v157, v158, v557);
    }
    unsigned int v182 = *v600;
    if (v182 > 0x16)
    {
      LOBYTE(v11) = v577;
      if (*v600 > 0x2Fu)
      {
        uint64_t v7 = v584;
        switch(v182)
        {
          case '0':
            x_stream_printf((uint64_t)&v605, "uniform lowp vec4 color_dodge;\n",
              v153,
              v154,
              v155,
              v156,
              v157,
              v158,
              v557);
            uint64_t v190 = "uniform lowp vec4 color_lighten;\n";
            break;
          case '1':
            x_stream_printf((uint64_t)&v605, "uniform lowp vec4 color_burn;\n", v153, v154, v155, v156, v157, v158, v557);
            uint64_t v190 = "uniform lowp vec4 color_darken;\n";
            break;
          case '4':
            uint64_t v183 = "uniform lowp vec4 curves[4];\n";
            goto LABEL_260;
          default:
            goto LABEL_261;
        }
        x_stream_printf((uint64_t)&v605, v190, v184, v185, v186, v187, v188, v189, v558);
        uint64_t v183 = "uniform lowp float reversed;\n";
LABEL_260:
        x_stream_printf((uint64_t)&v605, v183, v153, v154, v155, v156, v157, v158, v557);
        goto LABEL_261;
      }
      uint64_t v7 = v584;
      if (v182 != 23)
      {
        if (v182 != 24) {
          goto LABEL_261;
        }
LABEL_256:
        uint64_t v183 = "uniform lowp vec4 color_matrix[5];\n";
        goto LABEL_260;
      }
LABEL_255:
      uint64_t v183 = "uniform lowp vec3 color_matrix[4];\n";
      goto LABEL_260;
    }
    uint64_t v183 = "uniform lowp vec3 color_matrix[3];\n";
    LOBYTE(v11) = v577;
    if (*v600 > 0x13u)
    {
      uint64_t v7 = v584;
      if (v182 == 20) {
        goto LABEL_256;
      }
      if (v182 == 22) {
        goto LABEL_260;
      }
    }
    else
    {
      uint64_t v7 = v584;
      if (v182 == 18) {
        goto LABEL_260;
      }
      if (v182 == 19) {
        goto LABEL_255;
      }
    }
LABEL_261:
    if (v570) {
      x_stream_printf((uint64_t)&v605, "varying lowp vec4 color;\n", v153, v154, v155, v156, v157, v158, v557);
    }
    if (v595)
    {
      for (uint64_t n = 0; (void *)n != v595; ++n)
      {
        int v192 = *((_DWORD *)&v613[-1] + n);
        if (v192 >= 1)
        {
          for (iuint64_t i = 0; ii != v192; ++ii)
            x_stream_printf((uint64_t)&v605, "varying highp vec2 texcoord%d_%d;\n",
              v153,
              v154,
              v155,
              v156,
              v157,
              v158,
              n);
        }
      }
    }
    a2 = v600;
    if ((*((_DWORD *)v600 + 63) & 0x80000000) == 0) {
      x_stream_write((uint64_t)&v605, "varying highp vec3 texcoordD;\n", 0x1EuLL);
    }
    int v5 = v598;
    if ((*((_DWORD *)v600 + 65) & 0x80000000) == 0) {
      x_stream_write((uint64_t)&v605, "varying highp vec3 texcoordN;\n", 0x1EuLL);
    }
    if (v130)
    {
      float64x2_t v194 = (const char **)&CA::OGL::coord_fragment_functions;
      unsigned int v195 = -3;
      do
      {
        if ((v130 & 1) != 0 && v195 >= 0xFFFFFFFE)
        {
          size_t v196 = strlen(*v194);
          x_stream_write((uint64_t)&v605, (void *)*v194, v196);
        }
        ++v194;
        ++v195;
        BOOL v173 = v130 > 1;
        v130 >>= 1;
      }
      while (v173);
    }
    if (v129)
    {
      float32x4_t v197 = (const char **)&CA::OGL::image_fragment_functions;
      unint64_t v198 = v129;
      do
      {
        if ((v198 & 1) != 0 && *v197)
        {
          size_t v199 = strlen(*v197);
          x_stream_write((uint64_t)&v605, (void *)*v197, v199);
        }
        ++v197;
        BOOL v173 = v198 > 1;
        v198 >>= 1;
      }
      while (v173);
    }
    if (v591 & 0x10 | v570 & 0x20)
    {
      x_stream_write((uint64_t)&v605, "\nlowp vec4 mixLin(lowp vec4 D, lowp vec4 S, lowp vec4 M) {\n  D.rgCGFloat b = D.rgb / max(D.a, .005);\n"
        "  D.rgCGFloat b = D.rgb*D.rgb;\n"
        "  S.rgCGFloat b = S.rgb / max(S.a, .005);\n"
        "  S.rgCGFloat b = S.rgb*S.rgb;\n"
        "  lowp vec4 R = mix(D, S, M);\n"
        "  R.rgCGFloat b = sqrt(max(R.rgb, 0.))*R.a;\n"
        "  return R;\n"
        "}\n",
        0xFDuLL);
      if ((v591 & 0x40) == 0)
      {
LABEL_287:
        if ((v591 & 0x20) == 0) {
          goto LABEL_289;
        }
        goto LABEL_288;
      }
    }
    else if ((v591 & 0x40) == 0)
    {
      goto LABEL_287;
    }
    x_stream_write((uint64_t)&v605, "\nlowp vec4 vibrantLightenSover(lowp vec4 S, lowp vec4 D) {\n  lowp float y = 1. - dot(D.rgb, vec3(.2125, .7154, .0721));\n"
      "  S = S * (y * y) * (y * y);\n"
      "  return D*(1. - S.a) + S;\n"
      "}\n"
      "\n"
      "lowp vec4 vibrantColorDodge(lowp vec4 S, lowp vec4 D) {\n"
      "  lowp vec4 R = D*(1. - S.a) + S*(1. - D.a);\n"
      "  R.rgb += mix(S.aaa, D.rgb*S.a*S.a/max(S.a - S.rgb, .005),\n"
      "               step(.005, S.a - S.rgb));\n"
      "  R.a += D.a*S.a;\n"
      "  R.rgCGFloat b = clamp(R.rgb, 0.0, R.a);\n"
      "  return R;\n"
      "}\n"
      "\n"
      "lowp vec4 vibrantDark(lowp vec4 s0, lowp vec4 d0) {\n"
      "  return vibrantLightenSover(s0 * blend_color1,\n"
      "                             vibrantColorDodge(s0 * blend_color0, d0));\n"
      "}\n"
      "\n"
      "lowp vec4 vibrantDarkReversed(lowp vec4 s0, lowp vec4 d0) {\n"
      "  return vibrantColorDodge(s0 * blend_color0,\n"
      "                           vibrantLightenSover(s0 * blend_color1, d0));\n"
      "}\n",
      0x323uLL);
    x_stream_write((uint64_t)&v605, "\nlowp vec4 vibrantDarkenSover(lowp vec4 S, lowp vec4 D) {\n  lowp float y = dot(D.rgb, vec3(.2125, .7154, .0721));\n"
      "  S = S * (y * y) * (y * y);\n"
      "  return D*(1. - S.a) + S;\n"
      "}\n"
      "\n"
      "lowp vec4 vibrantColorBurn(lowp vec4 S, lowp vec4 D) {\n"
      "  lowp vec4 R = D*(1. - S.a) + S*(1. - D.a);\n"
      "  lowp float dasCGFloat a = D.a*S.a;\n"
      "  R.rgb += step(.005, S.rgb)\n"
      "           * (dasa - S.a*S.a*(D.a - D.rgb)/max(S.rgb, .005));\n"
      "  R.a += dasa;\n"
      "  R.rgCGFloat b = clamp(R.rgb, 0.0, R.a);\n"
      "  return R;\n"
      "}\n"
      "\n"
      "lowp vec4 vibrantLight(lowp vec4 s0, lowp vec4 d0) {\n"
      "  return vibrantDarkenSover(s0 * blend_color1,\n"
      "                            vibrantColorBurn(s0 * blend_color0, d0));\n"
      "}\n"
      "\n"
      "lowp vec4 vibrantLightReversed(lowp vec4 s0, lowp vec4 d0) {\n"
      "  return vibrantColorBurn(s0 * blend_color0,\n"
      "                          vibrantDarkenSover(s0 * blend_color1, d0));\n"
      "}\n",
      0x328uLL);
    if ((v591 & 0x20) == 0)
    {
LABEL_289:
      unsigned int v200 = *v600;
      if (v200 > 0x2F)
      {
        switch(*v600)
        {
          case '0':
            char v201 = "\n"
                   "lowp vec4 vibrantLightenSover(lowp vec4 S, lowp vec4 D) {\n"
                   "  lowp float y = 1. - dot(D.rgb, vec3(.2125, .7154, .0721));\n"
                   "  S = S * (y * y) * (y * y);\n"
                   "  return D*(1. - S.a) + S;\n"
                   "}\n"
                   "\n"
                   "lowp vec4 vibrantColorDodge(lowp vec4 S, lowp vec4 D) {\n"
                   "  lowp vec4 R = D*(1. - S.a) + S*(1. - D.a);\n"
                   "  R.rgb += mix(S.aaa, D.rgb*S.a*S.a/max(S.a - S.rgb, .005),\n"
                   "               step(.005, S.a - S.rgb));\n"
                   "  R.a += D.a*S.a;\n"
                   "  R.rgCGFloat b = clamp(R.rgb, 0.0, R.a);\n"
                   "  return R;\n"
                   "}\n"
                   "\n"
                   "lowp vec4 vibrantDark(lowp vec4 s0, lowp vec4 d0) {\n"
                   "  if (reversed != 0.0)\n"
                   "    return vibrantColorDodge(s0 * color_dodge,\n"
                   "                               vibrantLightenSover(s0 * color_lighten, d0));\n"
                   "  else\n"
                   "    return vibrantLightenSover(s0 * color_lighten,\n"
                   "                               vibrantColorDodge(s0 * color_dodge, d0));\n"
                   "}\n";
            goto LABEL_300;
          case '1':
            char v201 = "\n"
                   "lowp vec4 vibrantDarkenSover(lowp vec4 S, lowp vec4 D) {\n"
                   "  lowp float y = dot(D.rgb, vec3(.2125, .7154, .0721));\n"
                   "  S = S * (y * y) * (y * y);\n"
                   "  return D*(1. - S.a) + S;\n"
                   "}\n"
                   "\n"
                   "lowp vec4 vibrantColorBurn(lowp vec4 S, lowp vec4 D) {\n"
                   "  lowp vec4 R = D*(1. - S.a) + S*(1. - D.a);\n"
                   "  lowp float dasCGFloat a = D.a*S.a;\n"
                   "  R.rgb += step(.005, S.rgb)\n"
                   "           * (dasa - S.a*S.a*(D.a - D.rgb)/max(S.rgb, .005));\n"
                   "  R.a += dasa;\n"
                   "  R.rgCGFloat b = clamp(R.rgb, 0.0, R.a);\n"
                   "  return R;\n"
                   "}\n"
                   "\n"
                   "lowp vec4 vibrantLight(lowp vec4 s0, lowp vec4 d0) {\n"
                   "  if (reversed != 0.0)\n"
                   "    return vibrantColorBurn(s0 * color_burn,\n"
                   "                              vibrantDarkenSover(s0 * color_darken, d0));\n"
                   "  else\n"
                   "    return vibrantDarkenSover(s0 * color_darken,\n"
                   "                              vibrantColorBurn(s0 * color_burn, d0));\n"
                   "}\n";
LABEL_300:
            size_t v202 = 780;
            goto LABEL_306;
          case '3':
            char v201 = "\n"
                   "lowp vec4 luminanceCurve(lowp vec4 s0, lowp vec4 p, lowp float a) {\n"
                   "  lowp float x = dot(s0.rgb, vec3(.2125, .7154, .0721));\n"
                   "  x = clamp((((p.x * x) + p.y) * x + p.z) * x + p.w, 0.0, 1.0);\n"
                   "  return vec4(mix (s0.rgb, vec3 (x, x, x), a), s0.a);\n"
                   "}\n";
            size_t v202 = 246;
            goto LABEL_306;
          case '4':
            char v201 = "\n"
                   "lowp vec4 colorCurves(lowp vec4 s) {\n"
                   "  lowp float inv_CGFloat a = 1.0 / max(s.a, 0.005);\n"
                   "  s.rgb *= inv_a;\n"
                   "  lowp vec4 r = (((curves[0] * s) + curves[1]) * s + curves[2]) * s + curves[3];  r.CGFloat a = clamp(r.a, 0."
                   ", 1.);\n"
                   "  return vec4 (r.rgb * r.a, r.a);\n"
                   "}\n";
            goto LABEL_305;
          default:
            goto LABEL_307;
        }
      }
      switch(v200)
      {
        case 0x14u:
          char v201 = "\n"
                 "lowp vec4 colorMatrix4x4Bias(lowp vec4 s) {\n"
                 "  s.rgCGFloat b = s.rgb / max(s.a, .005);\n"
                 "  s = s.r * color_matrix[0] + s.g * color_matrix[1]\n"
                 "    + s.b * color_matrix[2] + s.a * color_matrix[3]\n"
                 "    + color_matrix[4];\n"
                 "  s.rgCGFloat b = s.rgb * s.a;\n"
                 "  return s;\n"
                 "}\n";
          size_t v202 = 243;
          break;
        case 0x18u:
          char v201 = "\n"
                 "lowp vec4 colorMatrix4x4BiasDivideAlpha(lowp vec4 s) {\n"
                 "  s = vec4(s.rgb / s.a, 1.0);\n"
                 "  s = s.r * color_matrix[0] + s.g * color_matrix[1]\n"
                 "    + s.b * color_matrix[2] + color_matrix[3]\n"
                 "    + color_matrix[4];\n"
                 "  s.rgCGFloat b = s.rgb * s.a;\n"
                 "  return s;\n"
                 "}\n";
LABEL_305:
          size_t v202 = 244;
          break;
        case 0x19u:
          char v201 = "\n"
                 "lowp vec4 perlinBias(lowp vec4 s, lowp float a) {\n"
                 "  s.rgCGFloat b = s.rgb / (a * (s.a - s.rgb) + s.a);\n"
                 "  return s;\n"
                 "}\n";
          size_t v202 = 110;
          break;
        default:
          goto LABEL_307;
      }
LABEL_306:
      x_stream_write((uint64_t)&v605, v201, v202);
LABEL_307:
      int v203 = v600[37];
      if (v203 == 50)
      {
        uint64_t v204 = "\n"
               "lowp vec4 lightenSover(lowp vec4 S, lowp vec4 D) {\n"
               "  lowp float y = 1. - dot(D.rgb, vec3(.2125, .7154, .0721));\n"
               "  S = S * (y * y) * (y * y);\n"
               "  return D*(1. - S.a) + S;\n"
               "}\n";
        size_t v205 = 171;
      }
      else
      {
        if (v203 != 49)
        {
LABEL_312:
          x_stream_printf((uint64_t)&v605, "\nvoid main(void) {\n", v153, v154, v155, v156, v157, v158, v557);
          if ((CA::OGL::GLContext::assemble_fragment_shader(CA::OGL::GLShader const*,int *)::initialized & 1) == 0)
          {
            int v212 = getenv("CA_EMPTY_SHADERS");
            if (v212) {
              CA::OGL::GLContext::assemble_fragment_shader(CA::OGL::GLShader const*,int *)::empty_shaders = atoi(v212) != 0;
            }
            CA::OGL::GLContext::assemble_fragment_shader(CA::OGL::GLShader const*,int *)::initialized = 1;
          }
          if (CA::OGL::GLContext::assemble_fragment_shader(CA::OGL::GLShader const*,int *)::empty_shaders)
          {
            x_stream_write((uint64_t)&v605, "  gl_FragData[0] = vec4(0.0);\n", 0x1EuLL);
            x_stream_write((uint64_t)&v605, "  return;\n}\n", 0xCuLL);
            uint64_t v68 = x_stream_finish((uint64_t)&v605);
            unsigned int v12 = v588;
            int v9 = v586;
            uint64_t v4 = v599;
            goto LABEL_467;
          }
          if (v595 && v600[94]) {
            x_stream_write((uint64_t)&v605, "highp vec2 texcoord0_0 = vec2(gl_PointCoord.s, 1.0 - gl_PointCoord.t);\n",
          }
              0x47uLL);
          if (v600[37] << 8 != 14848 || (v570 & 0x10) != 0 || (v129 & 0x4000000000) != 0)
          {
            int v213 = *((_DWORD *)v600 + 64);
            if ((*((_DWORD *)v600 + 63) & 0x80000000) != 0)
            {
              if (v213)
              {
                uint64_t v215 = 0;
                do
                {
                  x_stream_printf((uint64_t)&v605, "  lowp vec4 d%d = gl_LastFragData[%d];\n",
                    v206,
                    v207,
                    v208,
                    v209,
                    v210,
                    v211,
                    v215);
                  uint64_t v215 = (v215 + 1);
                }
                while (v215 < *((_DWORD *)v600 + 64));
              }
            }
            else if (v213)
            {
              uint64_t v214 = 0;
              do
              {
                x_stream_printf((uint64_t)&v605, "  lowp vec4 d%d = texture%sProj(texture%d, texcoordD);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v214);
                uint64_t v214 = (v214 + 1);
              }
              while (v214 < *((_DWORD *)v600 + 64));
            }
          }
          v604[0] = 0;
          v604[1] = 0;
          uint64_t v603 = 0;
          uint64_t v216 = v599;
          if (!v595)
          {
LABEL_453:
            if ((v570 & 0xC0) != 0)
            {
              if ((v570 & 0x80) != 0) {
                x_stream_write((uint64_t)&v605, "  lowp vec4 s1 = color;\n", 0x18uLL);
              }
              x_stream_write((uint64_t)&v605, "  lowp vec4 s2;\n", 0x10uLL);
              x_stream_write((uint64_t)&v605, "  {\n", 4uLL);
              x_stream_write((uint64_t)&v605, "    lowp vec4 S = s1, D = d0;\n", 0x1EuLL);
              CA::OGL::GLContext::inline_blend_function((uint64_t)&v605, a2[37], v510, v511, v512, v513, v514, v515);
              x_stream_write((uint64_t)&v605, "    s2 = R; s1 = d0;\n", 0x15uLL);
              x_stream_write((uint64_t)&v605, "  }\n", 4uLL);
            }
            uint64_t v516 = v216;
            x_stream_printf((uint64_t)&v605, "  gl_FragData[0] = %s;\n",
              v206,
              v207,
              v208,
              v209,
              v210,
              v211,
              (uint64_t)CA::OGL::tex_fragment_shaders[*a2]);
            if (a2[37] << 8 != 14848 && (v570 & 0x1C0) == 0)
            {
              int v523 = *((_DWORD *)a2 + 64);
              if (v523)
              {
                uint64_t v524 = 0;
                do
                {
                  x_stream_write((uint64_t)&v605, "  {\n", 4uLL);
                  x_stream_printf((uint64_t)&v605, "    lowp vec4 S = gl_FragData[%d];\n",
                    v525,
                    v526,
                    v527,
                    v528,
                    v529,
                    v530,
                    v524);
                  x_stream_printf((uint64_t)&v605, "    lowp vec4 D = d%d;\n", v531, v532, v533, v534, v535, v536, v524);
                  CA::OGL::GLContext::inline_blend_function((uint64_t)&v605, a2[37], v537, v538, v539, v540, v541, v542);
                  x_stream_printf((uint64_t)&v605, "    gl_FragData[%d] = R;\n",
                    v543,
                    v544,
                    v545,
                    v546,
                    v547,
                    v548,
                    v524);
                  x_stream_write((uint64_t)&v605, "  }\n", 4uLL);
                  uint64_t v524 = (v524 + 1);
                }
                while (v523 != v524);
              }
            }
            if ((*((_DWORD *)a2 + 65) & 0x80000000) == 0)
            {
              x_stream_write((uint64_t)&v605, "  {\n", 4uLL);
              x_stream_printf((uint64_t)&v605, "    mediump vec3 uint64_t n = texture%sProj(texture%d, texcoordN).xyz;\n",
                v549,
                v550,
                v551,
                v552,
                v553,
                v554,
                *(void *)&buf[8 * *((int *)a2 + 65)]);
              x_stream_write((uint64_t)&v605, "    uint64_t n = (n - .5) * noise_scale;\n", 0x20uLL);
              x_stream_write((uint64_t)&v605, "    lowp vec3 c = gl_FragData[0].rgb + n*gl_FragData[0].a;\n", 0x3BuLL);
              x_stream_write((uint64_t)&v605, "    gl_FragData[0].rgCGFloat b = clamp(c, 0., gl_FragData[0].a);\n", 0x39uLL);
              x_stream_write((uint64_t)&v605, "  }\n", 4uLL);
            }
            unsigned int v555 = *((unsigned __int16 *)a2 + 18) | (a2[38] << 16);
            int v5 = v598;
            LOBYTE(v11) = v577;
            unsigned int v12 = v588;
            int v9 = v586;
            if (v555 >= 0x10000) {
              x_stream_printf((uint64_t)&v605, "gl_FragData[0] = %s;\n",
            }
                v517,
                v518,
                v519,
                v520,
                v521,
                v522,
                CA::OGL::destination_shaders[HIWORD(v555)]);
            x_stream_write((uint64_t)&v605, "}\n", 2uLL);
            uint64_t v68 = x_stream_finish((uint64_t)&v605);
            uint64_t v4 = v516;
LABEL_467:
            int v75 = 1;
            if (!v68) {
              return 0;
            }
            goto LABEL_116;
          }
          uint64_t v217 = 0;
          int v218 = 0;
          int v219 = 0;
          do
          {
            switch(a2[v217 + 3])
            {
              case 0u:
                v604[v217] = "texcoord";
                break;
              case 1u:
                v604[v217] = "tc";
                int v220 = *((_DWORD *)&v613[-1] + v217);
                if (v220 >= 1)
                {
                  for (juint64_t j = 0; jj != v220; ++jj)
                    x_stream_printf((uint64_t)&v605, "  mediump vec2 tc%d_%d = radialCoord(texcoord%d_%d);\n",
                      v206,
                      v207,
                      v208,
                      v209,
                      v210,
                      v211,
                      v217);
                }
                break;
              case 2u:
                v604[v217] = "tc";
                int v222 = *((_DWORD *)&v613[-1] + v217);
                if (v222 >= 1)
                {
                  for (kint k = 0; kk != v222; ++kk)
                    x_stream_printf((uint64_t)&v605, "  mediump vec2 tc%d_%d = conicCoord(texcoord%d_%d);\n",
                      v206,
                      v207,
                      v208,
                      v209,
                      v210,
                      v211,
                      v217);
                }
                break;
              case 3u:
                v604[v217] = "tc";
                int v224 = *((_DWORD *)&v613[-1] + v217);
                if (v224 >= 1)
                {
                  for (muint64_t m = 0; mm != v224; ++mm)
                    x_stream_printf((uint64_t)&v605, "  mediump vec2 tc%d_%d = fract(texcoord%d_%d) * coord_arg.xy + coord_arg.zw;\n",
                      v206,
                      v207,
                      v208,
                      v209,
                      v210,
                      v211,
                      v217);
                }
                break;
              case 4u:
                if (!v217) {
                  __assert_rtn("assemble_fragment_shader", "ogl-gl.cpp", 2210, "i > 0");
                }
                if (v600[v217] && v600[v217] != 38) {
                  __assert_rtn("assemble_fragment_shader", "ogl-gl.cpp", 2212, "key->function.f.image_func[i - 1] == OGL_IMAGE_IDENTITY || key->function.f.image_func[i - 1] == OGL_IMAGE_DEST");
                }
                v604[v217] = "tlum";
                int v226 = *((_DWORD *)&v613[-1] + v217);
                if (v226 >= 1)
                {
                  for (nuint64_t n = 0; nn != v226; ++nn)
                    x_stream_printf((uint64_t)&v605, "  mediump vec2 tlum%d_%d = vec2(dot(%c%d.rgb, vec3(.2125, .7154, .0721)) * texcoord%d_%d.y + texcoord%d_%d.x, 0.5);\n",
                      v206,
                      v207,
                      v208,
                      v209,
                      v210,
                      v211,
                      v217);
                }
                break;
              case 5u:
                v604[v217] = "tc";
                int v228 = *((_DWORD *)&v613[-1] + v217);
                if (v228 >= 1)
                {
                  for (int i1 = 0; i1 != v228; ++i1)
                    x_stream_printf((uint64_t)&v605, "  mediump vec2 tc%d_%d = clamp(texcoord%d_%d, coord_arg.xy, coord_arg.zw);\n",
                      v206,
                      v207,
                      v208,
                      v209,
                      v210,
                      v211,
                      v217);
                }
                break;
              default:
                break;
            }
            uint64_t v230 = *((unsigned int *)v613 + v217);
            a2 = v600;
            if ((int)v230 + v218 > v602) {
              break;
            }
            int v576 = v218;
            int v574 = v600[v217 + 1];
            int v572 = v219;
            if ((int)v230 >= 1)
            {
              uint64_t v231 = 0;
              int v579 = 1 << v217;
              if (v600[v217 + 1]) {
                uint64_t v232 = 116;
              }
              else {
                uint64_t v232 = 115;
              }
              uint64_t v581 = v610[v217];
              uint64_t v578 = v217;
              do
              {
                if ((v579 & a2[39]) != 0)
                {
                  x_stream_printf((uint64_t)&v605, "  %s vec4 %c%d;\n", v206, v207, v208, v209, v210, v211, v581);
                  x_stream_write((uint64_t)&v605, "  {\n", 4uLL);
                  x_stream_write((uint64_t)&v605, "    highp vec4 f;\n", 0x12uLL);
                  if (*(_WORD *)&v600[2 * v576 + 8 + 2 * v231] == 3553) {
                    x_stream_printf((uint64_t)&v605, "    f.xy = fract(%s%d_0 / texmat%d.xy);\n",
                  }
                      v233,
                      v234,
                      v235,
                      v236,
                      v237,
                      v238,
                      v604[v217]);
                  else {
                    x_stream_printf((uint64_t)&v605, "    f.xy = fract(%s%d_0);\n",
                  }
                      v233,
                      v234,
                      v235,
                      v236,
                      v237,
                      v238,
                      v604[v217]);
                  x_stream_write((uint64_t)&v605, "    f.zw = vec2(1.) - f.xy;\n", 0x1CuLL);
                  x_stream_write((uint64_t)&v605, "    f = f.xzxz * f.yyww;\n", 0x19uLL);
                  x_stream_printf((uint64_t)&v605, "    %c%d = texture%s (texture%d, %s%d_%d) * f.w;\n",
                    v239,
                    v240,
                    v241,
                    v242,
                    v243,
                    v244,
                    v232);
                  x_stream_printf((uint64_t)&v605, "    %c%d = texture%s (texture%d, %s%d_%d) * f.z + %c%d;\n",
                    v245,
                    v246,
                    v247,
                    v248,
                    v249,
                    v250,
                    v232);
                  x_stream_printf((uint64_t)&v605, "    %c%d = texture%s (texture%d, %s%d_%d) * f.y + %c%d;\n",
                    v251,
                    v252,
                    v253,
                    v254,
                    v255,
                    v256,
                    v232);
                  x_stream_printf((uint64_t)&v605, "    %c%d = texture%s (texture%d, %s%d_%d) * f.x + %c%d;\n",
                    v257,
                    v258,
                    v259,
                    v260,
                    v261,
                    v262,
                    v232);
                  x_stream_write((uint64_t)&v605, "  }\n", 4uLL);
                  uint64_t v7 = v584;
                  a2 = v600;
                  uint64_t v217 = v578;
                }
                else
                {
                  x_stream_printf((uint64_t)&v605, "  %s vec4 %c%d = texture%s(texture%d, %s%d_%d);\n",
                    v206,
                    v207,
                    v208,
                    v209,
                    v210,
                    v211,
                    v581);
                }
                ++v231;
              }
              while (v230 != v231);
            }
            *((_DWORD *)&v604[-1] + v217) = v572;
            int v263 = v574 ? v230 : 0;
            int v219 = v263 + v572;
            int v218 = *((_DWORD *)&v611 + v217++) + v576;
          }
          while ((void *)v217 != v595);
          uint64_t v264 = 0;
          uint64_t v216 = v599;
          while (1)
          {
            switch(a2[v264 + 1])
            {
              case 1u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(t%d.rgb, 1.);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 2u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = t%d.yxwz;\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 3u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(t%d.yxw, 1.);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 4u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = t%d.zyxw;\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 5u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(t%d.zyx, 1.);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 6u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = t%d.wzyx;\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 7u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(t%d.wzy, 1.);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 8u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(0., 0., 0., t%d.a);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 9u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = squareImage(%s%d_0);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0xAu:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = circleImage(%s%d_0);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0xBu:
              case 0xCu:
              case 0xDu:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = supercircleImage(%s%d_0);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x13u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(0.);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x14u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(t%d.r);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x15u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(t%d.a);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x16u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(clamp(ycbcr_matrix%d * vec3(t%d.r + ycbcr_bias%d.x, t%d.rg + ycbcr_bias%d.yz), 0., 1.), 1.);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x17u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = t%d*vec4(2.0) + vec4(-0.75);\n  s%d = vec4(s%d.zyx, 1.0);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x18u:
              case 0x19u:
              case 0x1Au:
              case 0x1Bu:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = renderImage(t%d.r);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x1Cu:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(1.) - t%d;\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x1Eu:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(t%d.rrr, 1.h);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x1Fu:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = t%d.rrrg;\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x21u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(1.0);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x22u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = t%d.gggg;\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x23u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = t%d.bbbb;\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x26u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = d0;\n", v206, v207, v208, v209, v210, v211, v264);
                break;
              case 0x27u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(clamp(ycbcr_matrix%d * vec3(t%d.yzw + ycbcr_bias%d.xyz), 0., 1.)*t%d.x , t%d.x);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              case 0x28u:
                x_stream_printf((uint64_t)&v605, "  lowp vec4 s%d = vec4(clamp(ycbcr_matrix%d * vec3(t%d.g + ycbcr_bias%d.x, t%d.rb + ycbcr_bias%d.yz), 0., 1.), 1.);\n",
                  v206,
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v264);
                break;
              default:
                break;
            }
            int v265 = &a2[32 * v264];
            int v266 = *((_DWORD *)v265 + 70);
            if (!v266) {
              goto LABEL_452;
            }
            int v267 = v265 + 280;
            uint64_t v268 = v264;
            x_stream_write((uint64_t)&v605, "  {\n", 4uLL);
            uint64_t v573 = v264;
            if (*((_WORD *)v267 + 4) == 5) {
              break;
            }
            x_stream_printf((uint64_t)&v605, "    lowp vec3 c = s%d.rgb, t;\n", v269, v270, v271, v272, v273, v274, v264);
            int v275 = "    c = c / max(s%d.a, .005);\n";
            if ((v266 & 0x80000000) == 0) {
              goto LABEL_408;
            }
LABEL_409:
            int v571 = v266;
            unsigned int v276 = v266 & 0x7FFFFFFF;
            if (v276)
            {
              int v277 = 0;
              int v592 = *((unsigned __int16 *)v267 + 5);
              v582 = v267;
              uint64_t v575 = v264;
              do
              {
                uint64_t v278 = v276 & 0x1F;
                if ((v276 & 0x1F) > 7 || v278 == 1) {
                  int v592 = *((unsigned __int16 *)v267 + 6);
                }
                switch(v276 & 0x1F)
                {
                  case 1u:
                    x_stream_printf((uint64_t)&v605, "    c = c.r * colorP%d[%d].rgb + c.g * colorP%d[%d].rgb + c.b * colorP%d[%d].rgb + colorP%d[%d].rgb;\n",
                      v269,
                      v270,
                      v271,
                      v272,
                      v273,
                      v274,
                      v268);
                    break;
                  case 2u:
                    x_stream_printf((uint64_t)&v605, "    t = abs(c);\n", v269, v270, v271, v272, v273, v274, v559);
                    if (v592 > 3)
                    {
                      x_stream_printf((uint64_t)&v605, "    t = pow(t, colorP%d[%d].rgba);\n",
                        v280,
                        v281,
                        v282,
                        v283,
                        v284,
                        v285,
                        v268);
                      x_stream_printf((uint64_t)&v605, "    c.CGFloat a = c.a < 0.0 ? t.a * -1.0 : t.a;",
                        v462,
                        v463,
                        v464,
                        v465,
                        v466,
                        v467,
                        v566);
                    }
                    else
                    {
                      x_stream_printf((uint64_t)&v605, "    t = pow(t, colorP%d[%d].rgb);\n",
                        v280,
                        v281,
                        v282,
                        v283,
                        v284,
                        v285,
                        v268);
                    }
                    v426 = "    c.r = c.r < 0.0 ? t.r * -1.0 : t.r; c.g = c.g < 0.0 ? t.g * -1.0 : t.g; c.CGFloat b = c.b < 0.0 ?"
                           " t.b * -1.0 : t.b;\n";
                    goto LABEL_446;
                  case 3u:
                    x_stream_printf((uint64_t)&v605, "    t = abs(c);\n", v269, v270, v271, v272, v273, v274, v559);
                    x_stream_printf((uint64_t)&v605, "    t.r = t.r < -colorP%d[%d].r / colorP%d[%d].r ? 0.0 : pow (colorP%d[%d].r * t.r + colorP%d[%d].r, colorP%d[%d].r)\n", v292, v293, v294, v295, v296, v297, v268);
                    x_stream_printf((uint64_t)&v605, "    t.g = t.g < -colorP%d[%d].g / colorP%d[%d].g ? 0.0 : pow (colorP%d[%d].g * t.g + colorP%d[%d].g, colorP%d[%d].g)\n", v298, v299, v300, v301, v302, v303, v268);
                    x_stream_printf((uint64_t)&v605, "    t.CGFloat b = t.b < -colorP%d[%d].b / colorP%d[%d].b ? 0.0 : pow (colorP%d[%d].b * t.b + colorP%d[%d].b, colorP%d[%d].b)\n", v304, v305, v306, v307, v308, v309, v268);
                    if (v592 == 4)
                    {
                      x_stream_printf((uint64_t)&v605, "    t.CGFloat a = t.a < -colorP%d[%d].a / colorP%d[%d].a ? 0.0 : pow (colorP%d[%d].a * t.a + colorP%d[%d].a, colorP%d[%d].a)\n", v310, v311, v312, v313, v314, v315, v268);
                      x_stream_printf((uint64_t)&v605, "    c.CGFloat a = c.a < 0.0 ? t.a * -1.0 : t.a;",
                        v316,
                        v317,
                        v318,
                        v319,
                        v320,
                        v321,
                        v562);
                    }
                    goto LABEL_434;
                  case 4u:
                    x_stream_printf((uint64_t)&v605, "    t = abs(c);\n", v269, v270, v271, v272, v273, v274, v559);
                    x_stream_printf((uint64_t)&v605, "    t.r = t.r < -colorP%d[%d].r / colorP%d[%d].r ? colorP%d[%d].r : pow (colorP%d[%d].r * t.r + colorP%d[%d].r, colorP%d[%d].r) + colorP%d[%d].r\n", v322, v323, v324, v325, v326, v327, v268);
                    x_stream_printf((uint64_t)&v605, "    t.g = t.g < -colorP%d[%d].g / colorP%d[%d].g ? colorP%d[%d].g : pow (colorP%d[%d].g * t.g + colorP%d[%d].g, colorP%d[%d].g) + colorP%d[%d].g\n", v328, v329, v330, v331, v332, v333, v268);
                    x_stream_printf((uint64_t)&v605, "    t.CGFloat b = t.b < -colorP%d[%d].b / colorP%d[%d].b ? colorP%d[%d].b : pow (colorP%d[%d].b * t.b + colorP%d[%d].b, colorP%d[%d].b) + colorP%d[%d].b\n", v334, v335, v336, v337, v338, v339, v268);
                    if (v592 == 4)
                    {
                      x_stream_printf((uint64_t)&v605, "    t.CGFloat a = t.a < -colorP%d[%d].a / colorP%d[%d].a ? colorP%d[%d].a : pow (colorP%d[%d].a * t.a + colorP%d[%d].a, colorP%d[%d].a) + colorP%d[%d].a\n", v310, v311, v312, v313, v314, v315, v268);
                      x_stream_printf((uint64_t)&v605, "    c.CGFloat a = c.a < 0.0 ? t.a * -1.0 : t.a;",
                        v340,
                        v341,
                        v342,
                        v343,
                        v344,
                        v345,
                        v563);
                    }
                    goto LABEL_434;
                  case 5u:
                    x_stream_printf((uint64_t)&v605, "    t = abs(c);\n", v269, v270, v271, v272, v273, v274, v559);
                    x_stream_printf((uint64_t)&v605, "    t.r = t.r < colorP%d[%d].r ? colorP%d[%d].r * t.r : pow(colorP%d[%d].r * t.r + colorP%d[%d].r,colorP%d[%d].r);\n",
                      v346,
                      v347,
                      v348,
                      v349,
                      v350,
                      v351,
                      v268);
                    x_stream_printf((uint64_t)&v605, "    t.g = t.g < colorP%d[%d].g ? colorP%d[%d].g * t.g : pow(colorP%d[%d].g * t.g + colorP%d[%d].g,colorP%d[%d].g);\n",
                      v352,
                      v353,
                      v354,
                      v355,
                      v356,
                      v357,
                      v268);
                    x_stream_printf((uint64_t)&v605, "    t.CGFloat b = t.b < colorP%d[%d].b ? colorP%d[%d].b * t.b : pow(colorP%d[%d].b * t.b + colorP%d[%d].b,colorP%d[%d].b);\n",
                      v358,
                      v359,
                      v360,
                      v361,
                      v362,
                      v363,
                      v268);
                    if (v592 != 4) {
                      goto LABEL_434;
                    }
                    x_stream_printf((uint64_t)&v605, "    t.CGFloat a = t.a < colorP%d[%d].a ? colorP%d[%d].a * t.a : pow(colorP%d[%d].a * t.a + colorP%d[%d].a,colorP%d[%d].a);\n",
                      v310,
                      v311,
                      v312,
                      v313,
                      v314,
                      v315,
                      v268);
                    goto LABEL_433;
                  case 6u:
                    x_stream_printf((uint64_t)&v605, "    t = abs(c);\n", v269, v270, v271, v272, v273, v274, v559);
                    x_stream_printf((uint64_t)&v605, "    t.r = t.r < colorP%d[%d].r ? colorP%d[%d].r * t.r + colorP%d[%d].r : pow (colorP%d[%d].r * t.r + colorP%d[%d].r, colorP%d[%d].r) + colorP%d[%d].r;\n",
                      v427,
                      v428,
                      v429,
                      v430,
                      v431,
                      v432,
                      v268);
                    x_stream_printf((uint64_t)&v605, "    t.g = t.g < colorP%d[%d].g ? colorP%d[%d].g * t.g + colorP%d[%d].g : pow (colorP%d[%d].g * t.g + colorP%d[%d].g, colorP%d[%d].g) + colorP%d[%d].g;\n",
                      v433,
                      v434,
                      v435,
                      v436,
                      v437,
                      v438,
                      v268);
                    uint64_t v569 = v268;
                    uint64_t v268 = v575;
                    x_stream_printf((uint64_t)&v605, "    t.CGFloat b = t.b < colorP%d[%d].b ? colorP%d[%d].b * t.b + colorP%d[%d].b : pow (colorP%d[%d].b * t.b + colorP%d[%d].b, colorP%d[%d].b) + colorP%d[%d].b;\n",
                      v439,
                      v440,
                      v441,
                      v442,
                      v443,
                      v444,
                      v569);
                    if (v592 != 4) {
                      goto LABEL_434;
                    }
                    x_stream_printf((uint64_t)&v605, "    t.CGFloat a = t.a < colorP%d[%d].a ? colorP%d[%d].a * t.a + colorP%d[%d].a : pow (colorP%d[%d].a * t.a + colorP%d[%d].a, colorP%d[%d].a) + colorP%d[%d].a;\n",
                      v310,
                      v311,
                      v312,
                      v313,
                      v314,
                      v315,
                      v575);
LABEL_433:
                    x_stream_printf((uint64_t)&v605, "    c.CGFloat a = c.a < 0.0 ? t.a * -1.0 : t.a;",
                      v364,
                      v365,
                      v366,
                      v367,
                      v368,
                      v369,
                      v564);
LABEL_434:
                    x_stream_printf((uint64_t)&v605, "    c.r = c.r < 0.0 ? t.r * -1.0: t.r; c.g = c.g < 0.0 ? t.g * -1.0 : t.g; c.CGFloat b = c.b < 0.0 ? t.b * -1.0 : t.b;\n",
                      v310,
                      v311,
                      v312,
                      v313,
                      v314,
                      v315,
                      v561);
                    int v267 = v582;
                    break;
                  case 7u:
                    unsigned int v445 = v592 - 1;
                    if (v592 >= 1)
                    {
                      if (v445 >= 3) {
                        unsigned int v445 = 3;
                      }
                      uint64_t v446 = v445 + 1;
                      v447 = "xyzw";
                      do
                      {
                        uint64_t v448 = *v447++;
                        x_stream_printf((uint64_t)&v605, "    c.%c = texture2D(texture%d, vec2(c.%c*colorP%d[%d].%c, colorP%d[%d].%c)).r;\n",
                          v269,
                          v270,
                          v271,
                          v272,
                          v273,
                          v274,
                          v448);
                        --v446;
                      }
                      while (v446);
                    }
                    break;
                  case 8u:
                    uint64_t v370 = v267[19];
                    x_stream_printf((uint64_t)&v605, "    mediump vec2 c_st = vec2(c.r * colorP%d[%d].x + colorP%d[%d].y, 0.5);\n",
                      v269,
                      v270,
                      v271,
                      v272,
                      v273,
                      v274,
                      v268);
                    x_stream_printf((uint64_t)&v605, "    c = texture2D(texture%d, c_st).rgb;\n",
                      v371,
                      v372,
                      v373,
                      v374,
                      v375,
                      v376,
                      v370);
                    break;
                  case 9u:
                    uint64_t v449 = v267[19];
                    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v599 + 184))(v599, 16))
                    {
                      x_stream_printf((uint64_t)&v605, "    c = c * colorP%d[%d].x + colorP%d[%d].y;\n",
                        v450,
                        v451,
                        v452,
                        v453,
                        v454,
                        v455,
                        v268);
                      x_stream_printf((uint64_t)&v605, "    c = texture3D(texture%d, c).rgb;\n",
                        v456,
                        v457,
                        v458,
                        v459,
                        v460,
                        v461,
                        v449);
                    }
                    else
                    {
                      x_stream_printf((uint64_t)&v605, "    c.CGFloat b = c.b * colorP%d[%d].z;\n",
                        v450,
                        v451,
                        v452,
                        v453,
                        v454,
                        v455,
                        v268);
                      x_stream_printf((uint64_t)&v605, "    lowp float b_mix = fract(c.b);\n",
                        v468,
                        v469,
                        v470,
                        v471,
                        v472,
                        v473,
                        v567);
                      x_stream_printf((uint64_t)&v605, "    c.CGFloat b = floor(c.b) * colorP%d[%d].w;\n",
                        v474,
                        v475,
                        v476,
                        v477,
                        v478,
                        v479,
                        v268);
                      x_stream_printf((uint64_t)&v605, "    mediump vec2 c_st = vec2(c.r, c.g);\n",
                        v480,
                        v481,
                        v482,
                        v483,
                        v484,
                        v485,
                        v568);
                      x_stream_printf((uint64_t)&v605, "    c_st.r = c_st.r * colorP%d[%d].x + colorP%d[%d].y;\n",
                        v486,
                        v487,
                        v488,
                        v489,
                        v490,
                        v491,
                        v268);
                      x_stream_printf((uint64_t)&v605, "    c_st.g = c_st.g * colorP%d[%d].x * colorP%d[%d].w + colorP%d[%d].y * colorP%d[%d].w + c.b;\n",
                        v492,
                        v493,
                        v494,
                        v495,
                        v496,
                        v497,
                        v268);
                      x_stream_printf((uint64_t)&v605, "    lowp vec3 c0 = texture2D(texture%d, c_st).rgb;\n",
                        v498,
                        v499,
                        v500,
                        v501,
                        v502,
                        v503,
                        v449);
                      x_stream_printf((uint64_t)&v605, "    lowp vec3 c1 = texture2D(texture%d, c_st + vec2(0., colorP%d[%d].w)).rgb;\n",
                        v504,
                        v505,
                        v506,
                        v507,
                        v508,
                        v509,
                        v449);
                      v426 = "    c = mix(c0, c1, b_mix);\n";
LABEL_446:
                      x_stream_printf((uint64_t)&v605, v426, v286, v287, v288, v289, v290, v291, v560);
                    }
                    break;
                  case 0xAu:
                    uint64_t v377 = v267[19];
                    x_stream_printf((uint64_t)&v605, "    mediump vec3 c_stp = c.rgb;\n",
                      v269,
                      v270,
                      v271,
                      v272,
                      v273,
                      v274,
                      v559);
                    x_stream_printf((uint64_t)&v605, "    c.CGFloat a = c.a * colorP%d[%d].z;\n",
                      v378,
                      v379,
                      v380,
                      v381,
                      v382,
                      v383,
                      v268);
                    x_stream_printf((uint64_t)&v605, "    lowp float a_mix = fract(c.a);\n",
                      v384,
                      v385,
                      v386,
                      v387,
                      v388,
                      v389,
                      v565);
                    x_stream_printf((uint64_t)&v605, "    c.CGFloat a = floor(c.a) * colorP%d[%d].w;\n",
                      v390,
                      v391,
                      v392,
                      v393,
                      v394,
                      v395,
                      v268);
                    x_stream_printf((uint64_t)&v605, "    c_stp.r = c_stp.r * colorP%d[%d].x + colorP%d[%d].y;\n",
                      v396,
                      v397,
                      v398,
                      v399,
                      v400,
                      v401,
                      v268);
                    x_stream_printf((uint64_t)&v605, "    c_stp.g = c_stp.g * colorP%d[%d].x + colorP%d[%d].y;\n",
                      v402,
                      v403,
                      v404,
                      v405,
                      v406,
                      v407,
                      v268);
                    x_stream_printf((uint64_t)&v605, "    c_stp.CGFloat b = c_stp.b * colorP%d[%d].x * colorP%d[%d].w + colorP%d[%d].y * colorP%d[%d].w + c.a;\n",
                      v408,
                      v409,
                      v410,
                      v411,
                      v412,
                      v413,
                      v268);
                    x_stream_printf((uint64_t)&v605, "    lowp vec3 c0 = texture3D(texture%d, c_stp).rgb;\n",
                      v414,
                      v415,
                      v416,
                      v417,
                      v418,
                      v419,
                      v377);
                    x_stream_printf((uint64_t)&v605, "    lowp vec3 c1 = texture3D(texture%d, c_stp + vec3(0., 0., colorP%d[%d].w)).rgb;\n",
                      v420,
                      v421,
                      v422,
                      v423,
                      v424,
                      v425,
                      v377);
                    v426 = "    c = vec4(mix(c0, c1, a_mix), 1.);\n";
                    goto LABEL_446;
                  default:
                    break;
                }
                v277 += CA::ColorProgram::kOpcodeParamCount[v278];
                BOOL v173 = v276 > 0x1F;
                v276 >>= 5;
              }
              while (v173);
            }
            if (v571 < 0) {
              x_stream_printf((uint64_t)&v605, "    s%d = vec4(c.rgb, 1.);\n", v269, v270, v271, v272, v273, v274, v268);
            }
            else {
              x_stream_printf((uint64_t)&v605, "    s%d.rgCGFloat b = c * s%d.a;\n", v269, v270, v271, v272, v273, v274, v268);
            }
            a2 = v600;
            uint64_t v264 = v573;
            x_stream_write((uint64_t)&v605, "  }\n", 4uLL);
            uint64_t v216 = v599;
            uint64_t v7 = v584;
LABEL_452:
            if ((void *)++v264 == v595) {
              goto LABEL_453;
            }
          }
          int v275 = "    lowp vec4 c = s%d, t;\n";
          if ((v266 & 0x80000000) == 0) {
            __assert_rtn("inline_color_shader", "ogl-gl.cpp", 1608, "opaque && \"4DLUT must be opaque!\"");
          }
LABEL_408:
          x_stream_printf((uint64_t)&v605, v275, v269, v270, v271, v272, v273, v274, v264);
          goto LABEL_409;
        }
        uint64_t v204 = "\n"
               "lowp vec4 darkenSover(lowp vec4 S, lowp vec4 D) {\n"
               "  lowp float y = dot(D.rgb, vec3(.2125, .7154, .0721));\n"
               "  S = S * (y * y) * (y * y);\n"
               "  return D*(1. - S.a) + S;\n"
               "}\n";
        size_t v205 = 165;
      }
      x_stream_write((uint64_t)&v605, v204, v205);
      goto LABEL_312;
    }
LABEL_288:
    x_stream_write((uint64_t)&v605, "\nlowp vec3 colorSort(lowp vec3 c) {\n  lowp vec3 cs = (c.r > c.g) ? c : c.grb;\n"
      "  cs = (cs.g > cs.b) ? cs : cs.rbg;\n"
      "  cs = (cs.r > cs.g) ? cs : cs.grb;\n"
      "  return cs;\n"
      "}\n"
      "\n"
      "lowp float lum(lowp vec3 c) {\n"
      "  return dot(c, vec3(0.3, 0.59, 0.11));\n"
      "}\n"
      "\n"
      "lowp vec3 clipColor(lowp vec3 c) {\n"
      "  lowp float l = lum(c);\n"
      "  lowp vec3 cs = colorSort(c);\n"
      "  c = cs.b < 0.0 ? l + (c - l) * (l / (l - cs.b)) : c;\n"
      "  c = cs.r > 1.0 ? l + (c - l) * ((1.0 - l) / (cs.r - l)) : c;\n"
      "  return c;\n"
      "}\n"
      "\n"
      "lowp vec3 setLum(lowp vec3 c, lowp float l) {\n"
      "  lowp float d = l - lum(c);\n"
      "  return clipColor(c + d);\n"
      "}\n"
      "\n"
      "lowp float sat(lowp vec3 c) {\n"
      "  lowp vec3 cs = colorSort(c);\n"
      "  return cs.r - cs.b;\n"
      "}\n"
      "\n"
      "lowp vec3 setSat(lowp vec3 c, lowp float s) {\n"
      "  lowp vec3 cs = colorSort(c);\n"
      "  lowp vec3 fmax = cs.r == c.r ? vec3(1.,0.,0.) :    cs.r == c.g ? vec3(0.,1.,0.) : vec3(0.,0.,1.);\n"
      "  c = c - fmax * c;\n"
      "  lowp vec3 fmid = cs.g == c.r ? vec3(1.,0.,0.) :    cs.g == c.g ? vec3(0.,1.,0.) : vec3(0.,0.,1.);\n"
      "  c = cs.r > cs.b ? fmax * s + fmid * ((cs.g - cs.b) * s / (cs.r - cs.b)) :    vec3(0.0);\n"
      "  return c;\n"
      "}\n",
      0x41FuLL);
    goto LABEL_289;
  }
  uint64_t v68 = CA::OGL::tex_fragment_shaders[v6];
  if ((v6 - 44) >= 3) {
    int v69 = 1;
  }
  else {
    int v69 = 2;
  }
  int v602 = v69;
  if (*((_WORD *)a2 + 4) == 3553)
  {
    uint64_t v70 = strdup(v68);
    if (v70)
    {
      uint64_t v71 = v70;
      while (1)
      {
        unint64_t v72 = strstr(v70, "2DRect");
        if (!v72) {
          break;
        }
        uint64_t v73 = v72;
        int v74 = v72[6];
        uint64_t v70 = v72 + 6;
        if ((v74 | 8) == 0x28) {
          v73[2] = 32;
        }
        *(_WORD *)(v73 + 3) = 8224;
        v73[5] = 32;
      }
      int v75 = 1;
      uint64_t v68 = v71;
      a2 = v600;
      goto LABEL_116;
    }
    return 0;
  }
  int v75 = 0;
  if (!v68) {
    return 0;
  }
LABEL_116:
  int v590 = v75;
  char v76 = v11;
  long double v77 = a2;
  uint64_t v78 = v68;
  unsigned int v79 = ((uint64_t (*)(void, uint64_t))v5[595])(*v5, 35632);
  long long v605 = 0uLL;
  *(void *)&long long v605 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 1112))(v4);
  *((void *)&v605 + 1) = v78;
  v594 = (char *)v78;
  uint64_t v80 = v77;
  if (v9)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      float v81 = x_log_category_CADebug;
      if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO))
      {
        int v82 = *v77;
        int v83 = v77[1];
        *(_DWORD *)uint64_t buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v82;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v83;
        *(_WORD *)&buf[14] = 2080;
        *(void *)&v608[0] = v605;
        WORD4(v608[0]) = 2080;
        *(void *)((char *)v608 + 10) = *((void *)&v605 + 1);
        _os_log_impl(&dword_184668000, v81, OS_LOG_TYPE_INFO, "%08x %08x fragment shader:\n---\n%s%s---\n", buf, 0x22u);
      }
    }
  }
  float v84 = (void (*)(uint64_t, void, uint64_t, long long *, void))v5[596];
  uint64_t v85 = *v5;
  unint64_t v86 = v5;
  uint64_t v87 = v79;
  v84(v85, v79, 2, &v605, 0);
  ((void (*)(void, void))v86[597])(*v86, v79);
  unsigned int v88 = ((uint64_t (*)(void))v86[598])(*v86);
  uint64_t v89 = v88;
  ((void (*)(void, void, void))v86[599])(*v86, v88, v12);
  ((void (*)(void, void, uint64_t))v86[599])(*v86, v88, v87);
  for (uint64_t i2 = 0; i2 != 5; ++i2)
    ((void (*)(void, void, uint64_t, char *))v86[631])(*v86, v88, i2, CA::OGL::vertex_attribute_names[i2]);
  ((void (*)(void, void))v86[600])(*v86, v88);
  if ((v76 & 1) == 0) {
    ((void (*)(void, void))v86[592])(*v86, v12);
  }
  ((void (*)(void, uint64_t))v86[592])(*v86, v87);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v92 = (char *)malloc_type_zone_malloc(malloc_zone, 0x1A0uLL, 0x8BB15036uLL);
  uint64_t v93 = v92;
  *(_DWORD *)uint64_t v92 = *v80;
  *((_DWORD *)v92 + 1) = v80[1];
  __int16 v94 = *((_WORD *)v92 + 18) | (*((unsigned __int8 *)v80 + 37) << 8);
  *((_WORD *)v92 + 18) = v94;
  *((_WORD *)v92 + 18) = v94 & 0xFF00 | v80[9] & 1;
  *((_DWORD *)v92 + 65) = v80[65];
  if (a3 < 1) {
    goto LABEL_129;
  }
  uint64_t v95 = a3;
  float v96 = v92 + 8;
  uint64_t v97 = (__int16 *)(v80 + 2);
  do
  {
    __int16 v98 = *v97++;
    *v96++ = v98;
    --v95;
  }
  while (v95);
  if (a3 <= 12) {
LABEL_129:
  }
    bzero(&v92[2 * a3 + 8], 2 * (12 - a3) + 2);
  v93[34] = a3;
  v93[35] = v7;
  long long v99 = *(_OWORD *)(v80 + 70);
  long long v100 = *(_OWORD *)(v80 + 74);
  long long v101 = *(_OWORD *)(v80 + 82);
  *(_OWORD *)(v93 + 312) = *(_OWORD *)(v80 + 78);
  *(_OWORD *)(v93 + 328) = v101;
  *(_OWORD *)(v93 + 280) = v99;
  *(_OWORD *)(v93 + 296) = v100;
  *((_DWORD *)v93 + 14) = v88;
  *(_OWORD *)(v93 + 60) = 0u;
  *(_OWORD *)(v93 + 76) = 0u;
  v93[94] = *((unsigned char *)v80 + 94);
  *((_DWORD *)v93 + 102) = 0;
  *((_OWORD *)v93 + 7) = 0u;
  *((_OWORD *)v93 + 8) = 0u;
  *((_OWORD *)v93 + 6) = 0u;
  *(_OWORD *)(v93 + 216) = 0u;
  *(_OWORD *)(v93 + 200) = 0u;
  *(_OWORD *)(v93 + 184) = 0u;
  *(_OWORD *)(v93 + 168) = 0u;
  ((void (*)(void, void))v598[601])(*v598, v88);
  if (v602 >= 1)
  {
    uint64_t v102 = 0;
    do
    {
      *(_OWORD *)uint64_t buf = 0u;
      v608[0] = 0u;
      snprintf((char *)buf, 0x20uLL, "texture%d", v102);
      uint64_t v103 = ((uint64_t (*)(void, void, uint8_t *))v598[626])(*v598, v88, buf);
      ((void (*)(void, uint64_t, uint64_t))v598[607])(*v598, v103, v102);
      uint64_t v102 = (v102 + 1);
    }
    while (v602 != v102);
  }
  *(void *)(v93 + 252) = *(void *)(v600 + 252);
  v93[38] = v600[38];
  *((_DWORD *)v93 + 58) = ((uint64_t (*)(void, void, const char *))v598[626])(*v598, v88, "vertex_matrix");
  *((_DWORD *)v93 + 59) = ((uint64_t (*)(void, void, const char *))v598[626])(*v598, v88, "blend_color0");
  *((_DWORD *)v93 + 60) = ((uint64_t (*)(void, void, const char *))v598[626])(*v598, v88, "blend_color1");
  if (!v7) {
    goto LABEL_474;
  }
  float64x2_t v104 = v93 + 244;
  uint64_t v105 = CA::OGL::GLContext::create_shader(CA::OGL::ContextState const*,CA::OGL::GLShader const*,int)::names;
  uint64_t v106 = v7;
  do
  {
    uint64_t v107 = (uint64_t)*v105++;
    *v104++ = ((uint64_t (*)(void, void, uint64_t))v598[626])(*v598, v88, v107);
    --v106;
  }
  while (v106);
  if (v7 <= 1)
  {
LABEL_474:
    do
    {
      uint64_t v108 = v7;
      *(_DWORD *)&v93[4 * v7 + 244] = -1;
      uint64_t v7 = 1;
    }
    while (!v108);
  }
  if ((*((_DWORD *)v93 + 63) & 0x80000000) != 0) {
    int v109 = -1;
  }
  else {
    int v109 = ((uint64_t (*)(void, void, const char *))v598[626])(*v598, v88, "texmatD");
  }
  *((_DWORD *)v93 + 67) = v109;
  if ((*((_DWORD *)v93 + 65) & 0x80000000) != 0)
  {
    int v110 = -1;
    *((_DWORD *)v93 + 66) = -1;
  }
  else
  {
    *((_DWORD *)v93 + 66) = ((uint64_t (*)(void, void, const char *))v598[626])(*v598, v88, "noise_scale");
    int v110 = ((uint64_t (*)(void, void, const char *))v598[626])(*v598, v88, "texmatW");
  }
  *((_DWORD *)v93 + 68) = v110;
  uint64_t v111 = 96;
  __n128 v112 = (__n128)xmmword_1849983A0;
  do
  {
    *(_OWORD *)&v93[v111] = xmmword_1849983A0;
    v111 += 16;
  }
  while (v111 != 144);
  uint64_t v113 = 0;
  char v114 = 1;
  do
  {
    char v115 = v114;
    float v116 = &v93[32 * v113];
    *((_DWORD *)v116 + 75) = 0;
    if (*((_WORD *)v116 + 147))
    {
      int v117 = ((uint64_t (*)(void, void, char *, __n128))v598[626])(*v598, v88, CA::OGL::GLContext::create_shader(CA::OGL::ContextState const*,CA::OGL::GLShader const*,int)::names[v113], v112);
      __n128 v112 = (__n128)xmmword_1849983A0;
    }
    else
    {
      int v117 = -1;
    }
    char v114 = 0;
    *((_DWORD *)v116 + 76) = v117;
    uint64_t v113 = 1;
  }
  while ((v115 & 1) != 0);
  uint64_t v118 = 0;
  char v119 = 1;
  do
  {
    char v120 = v119;
    v93[v118 + 344] = 0;
    *(__n128 *)&v93[16 * v118 + 348] = v112;
    uint64_t v121 = &v93[4 * v118];
    *((_DWORD *)v121 + 95) = ((uint64_t (*)(void, uint64_t, char *))v598[626])(*v598, v89, CA::OGL::GLContext::create_shader(CA::OGL::ContextState const*,CA::OGL::GLShader const*,int)::ycbcr_names[v118]);
    *((_DWORD *)v121 + 97) = ((uint64_t (*)(void, uint64_t, char *))v598[626])(*v598, v89, CA::OGL::GLContext::create_shader(CA::OGL::ContextState const*,CA::OGL::GLShader const*,int)::ycbcr_bias_names[v118]);
    int v122 = ((uint64_t (*)(void, uint64_t, char *))v598[626])(*v598, v89, CA::OGL::GLContext::create_shader(CA::OGL::ContextState const*,CA::OGL::GLShader const*,int)::chroma_names[v118]);
    __n128 v112 = (__n128)xmmword_1849983A0;
    char v119 = 0;
    *((_DWORD *)v121 + 99) = v122;
    uint64_t v118 = 1;
  }
  while ((v120 & 1) != 0);
  *((_DWORD *)v93 + 101) = ((uint64_t (*)(void, void, const char *, __n128))v598[626])(*v598, v89, "render_state", xmmword_1849983A0);
  *((_WORD *)v93 + 46) = 0;
  switch((int)v597)
  {
    case 18:
    case 19:
    case 20:
    case 22:
    case 23:
    case 24:
      int v123 = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "color_matrix");
      goto LABEL_155;
    case 26:
    case 27:
    case 30:
    case 31:
      goto LABEL_157;
    case 29:
      int v123 = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "axis");
      goto LABEL_155;
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
      *((_DWORD *)v93 + 38) = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "divide");
LABEL_157:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "offset");
      int v124 = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "weight");
      goto LABEL_158;
    case 43:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "minmax");
      int v124 = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "bgcolor");
LABEL_158:
      *((_DWORD *)v93 + 37) = v124;
      break;
    case 44:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "minmax");
      *((_DWORD *)v93 + 37) = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "bgcolor");
      int v140 = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "map");
      goto LABEL_180;
    case 45:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "minmax_dir");
      *((_DWORD *)v93 + 37) = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "bgcolor");
      *((_DWORD *)v93 + 38) = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "map");
      *((_DWORD *)v93 + 39) = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "args");
      break;
    case 46:
      int v123 = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "map");
      goto LABEL_155;
    case 48:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "color_dodge");
      int v141 = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "color_lighten");
      goto LABEL_179;
    case 49:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "color_burn");
      int v141 = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "color_darken");
LABEL_179:
      *((_DWORD *)v93 + 37) = v141;
      int v140 = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "reversed");
LABEL_180:
      *((_DWORD *)v93 + 38) = v140;
      break;
    case 52:
      int v123 = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "curves");
LABEL_155:
      *((_DWORD *)v93 + 36) = v123;
      break;
    default:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "function_arg");
      int v142 = ((uint64_t (*)(void, uint64_t, const char *))v598[626])(*v598, v89, "coord_arg");
      *((_DWORD *)v93 + 37) = v142;
      v93[92] = *((_DWORD *)v93 + 36) >= 0;
      v93[93] = v142 >= 0;
      break;
  }
  if (v590) {
    free(v594);
  }
  ((void (*)(void, void))v598[601])(*v598, 0);
  *(void *)(v599 + 1864) = 0;
  ++*(_DWORD *)(v599 + 720);
  return v93;
}

char *CA::OGL::GLContext::inline_blend_function(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a2;
  if ((0x787FC001FFFFFFFuLL >> a2))
  {
    if ((0x701840008C00000uLL >> a2)) {
      LOBYTE(v9) = 3;
    }
    uint64_t result = x_stream_printf(a1, "%Wlowp vec4 R = %s;\n", a3, a4, a5, a6, a7, a8, 4);
  }
  else
  {
    x_stream_printf(a1, "%Wlowp vec4 R = D*(1. - S.a) + S*(1. - D.a);\n", a3, a4, a5, a6, a7, a8, 4);
    x_stream_printf(a1, "%Wlowp float DaSCGFloat a = D.a*S.a;\n", v10, v11, v12, v13, v14, v15, 4);
    if ((unint64_t)(v9 - 55) >= 0xFFFFFFFFFFFFFFFCLL)
    {
      x_stream_printf(a1, "%WS = S/max(S.a, 0.005);\n", v16, v17, v18, v19, v20, v21, 4);
      x_stream_printf(a1, "%WD = D/max(D.a, 0.005);\n", v30, v31, v32, v33, v34, v35, 4);
      uint64_t v22 = "%WR.rgb += %s * DaSa;\n";
    }
    else
    {
      uint64_t v22 = "%WR.rgb += %s;\n";
    }
    x_stream_printf(a1, v22, v16, v17, v18, v19, v20, v21, 4);
    uint64_t result = x_stream_printf(a1, "%WR.a += DaSa;\n", v36, v37, v38, v39, v40, v41, 4);
  }
  if (((0x7FFFE9CFFFFFFFFuLL >> v9) & 1) == 0) {
    return x_stream_printf(a1, "%WR.rgCGFloat b = min(R.rgb, R.a);\n", v24, v25, v26, v27, v28, v29, 4);
  }
  return result;
}

uint64_t CA::OGL::gl_shader_compare(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 == *(_DWORD *)a2
    && *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4)
    && ((*(_WORD *)(a2 + 36) ^ *(_WORD *)(a1 + 36)) & 0xFF01) == 0
    && !((((*(unsigned __int16 *)(a2 + 36) | (*(unsigned __int8 *)(a2 + 38) << 16)) ^ (*(unsigned __int16 *)(a1 + 36) | (*(unsigned __int8 *)(a1 + 38) << 16))) & 0xFFFFFFu) >> 16)
    && *(unsigned __int8 *)(a1 + 94) == *(unsigned __int8 *)(a2 + 94))
  {
    uint64_t v5 = 0;
    while (*(unsigned __int16 *)(a1 + 8 + v5) == *(unsigned __int16 *)(a2 + 8 + v5))
    {
      v5 += 2;
      if (v5 == 26)
      {
        uint64_t v6 = 0;
        char v7 = 1;
        do
        {
          uint64_t v8 = a1 + 32 * v6;
          uint64_t v9 = a2 + 32 * v6;
          uint64_t v11 = *(void *)(v8 + 280);
          uint64_t v10 = *(void *)(v8 + 288);
          uint64_t v13 = *(void *)(v9 + 280);
          uint64_t v12 = *(void *)(v9 + 288);
          BOOL v3 = v11 != v13 || v10 != v12;
          if ((v7 & 1) == 0) {
            break;
          }
          char v7 = 0;
          uint64_t v6 = 1;
        }
        while (!v3);
        return v3;
      }
    }
  }
  return 1;
}

uint64_t CA::OGL::gl_shader_hash(unsigned int *a1)
{
  uint64_t v1 = 0;
  unsigned int v2 = *((unsigned __int16 *)a1 + 18);
  uint64_t v3 = 33 * *a1 + a1[1] + (v2 >> 8);
  BOOL v4 = (v2 & 1) == 0;
  uint64_t v5 = 33;
  if (v4) {
    uint64_t v5 = 0;
  }
  uint64_t v6 = 33 * *((unsigned __int8 *)a1 + 94) + *((unsigned __int8 *)a1 + 38) + 33 * (v3 + v5);
  do
  {
    uint64_t v6 = 33 * v6 + *(unsigned __int16 *)((char *)a1 + v1 + 8);
    v1 += 2;
  }
  while (v1 != 26);
  uint64_t v7 = 0;
  char v8 = 1;
  do
  {
    char v9 = v8;
    uint64_t v6 = 33 * v6 + a1[8 * v7 + 70];
    uint64_t v7 = 1;
    char v8 = 0;
  }
  while ((v9 & 1) != 0);
  return v6;
}

BOOL CA::OGL::GLContext::function_supported(CA::OGL::GLContext *this)
{
  uint64_t v1 = *((void *)this + 2);
  BOOL result = 1;
  switch(*(unsigned char *)(v1 + 16))
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x66:
      return result;
    case 0x1A:
    case 0x1B:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
      BOOL result = *(unsigned __int8 *)(v1 + 17) == 0;
      break;
    default:
      BOOL result = 0;
      break;
  }
  return result;
}

uint64_t CA::OGL::GLContext::clear_region(uint64_t a1, uint64_t a2, void *a3)
{
  _OWORD v23[3] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void **)(a1 + 2096);
  uint64_t v7 = *(void *)(a1 + 272);
  if (v7 != *(void *)(a1 + 264)) {
    goto LABEL_2;
  }
  if (v7) {
    LODWORD(v7) = (*(unsigned __int8 *)(v7 + 72) >> 1) & 0x1F;
  }
  if (*(_DWORD *)(a1 + 260) != v7) {
LABEL_2:
  }
    CA::OGL::Context::prepare_destination_((CA::OGL::Context *)a1);
  if ((*(_WORD *)(a1 + 832) & 0x200) != 0) {
    CA::OGL::Context::flatten_detached_layers_(a1);
  }
  if (*a3)
  {
    _H3 = HIWORD(*a3);
    _H2 = WORD2(*a3);
    _H1 = WORD1(*a3);
    _H0 = *a3;
    __asm
    {
      FCVT            S0, H0
      FCVT            S1, H1
      FCVT            S2, H2
      FCVT            S3, H3
    }
    ((void (*)(void, float, float, float, float))v6[13])(*v6, _S0, _S1, _S2, _S3);
  }
  ((void (*)(void, uint64_t))v6[73])(*v6, 3089);
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  v23[1] = 0;
  v23[2] = 0;
  v23[0] = a2;
  while (CA::ShapeIterator::iterate(v23, (int *)&v21))
  {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 1120))(a1, &v21);
    ((void (*)(void, void, void, void, void))v6[252])(*v6, v21, HIDWORD(v21), v22, HIDWORD(v22));
    ((void (*)(void, uint64_t))v6[11])(*v6, 0x4000);
  }
  uint64_t result = ((uint64_t (*)(void, uint64_t))v6[64])(*v6, 3089);
  if (*a3) {
    return ((uint64_t (*)(void, double, double, double, double))v6[13])(*v6, 0.0, 0.0, 0.0, 0.0);
  }
  return result;
}

BOOL CA::OGL::GLContext::state_requires_disjoint_primitives(CA::OGL::GLContext *this)
{
  uint64_t v1 = (unsigned __int8 *)*((void *)this + 2);
  return ((CA::OGL::tex_fragment_shader_flags[v1[16]] & 0x10) != 0 || (v1[481] & 1) != 0 && v1[480] >= 0x1Au)
      && (*(unsigned int (**)(CA::OGL::GLContext *, uint64_t))(*(void *)this + 184))(this, 18) == 0;
}

uint64_t CA::OGL::GLContext::needs_destination_group(CA::OGL::GLContext *this)
{
  if ((*(unsigned int (**)(CA::OGL::GLContext *, uint64_t))(*(void *)this + 184))(this, 18)) {
    return 0;
  }
  else {
    return (*(unsigned int (**)(CA::OGL::GLContext *, char *))(*(void *)this + 1136))(this, (char *)this + 1912) ^ 1;
  }
}

CA::OGL::Context *CA::OGL::GLContext::bind_table_image(CA::OGL::Context *this, unsigned int a2, atomic_uint *a3)
{
  uint64_t v5 = this;
  if (*((CA::OGL::Context **)a3 + 11) == this && (uint64_t v6 = (CA::OGL::Context *)*((void *)a3 + 10)) != 0
    || (this = (CA::OGL::Context *)CA::OGL::Context::lookup_image_(this, (CA::Render::Texture *)a3, 1),
        (uint64_t v6 = this) != 0))
  {
    if (!*((void *)v6 + 1))
    {
      *((void *)v6 + 1) = a3;
      atomic_fetch_add(a3 + 37, 1u);
    }
    int v7 = *((_DWORD *)v6 + 13);
    if ((_WORD)v7)
    {
      if (!*((unsigned char *)v6 + 72)) {
        return this;
      }
      if (*((_DWORD *)v6 + 4) == a3[9])
      {
        uint64_t v8 = *((unsigned int *)v6 + 16);
        uint64_t v9 = *((void *)v5 + 2);
        *(_WORD *)(v9 + 2 * a2 + 144) = v7;
        *(void *)(v9 + 8 * a2 + 176) = v8;
        return this;
      }
    }
    else
    {
      *((_DWORD *)v6 + 13) = v7 & 0xFFFF0000 | 0xDE1;
      *((_WORD *)v6 + 29) |= 0x100u;
    }
    uint64_t v10 = *(uint64_t (**)(CA::OGL::Context *))(*(void *)v5 + 1184);
    return (CA::OGL::Context *)v10(v5);
  }
  return this;
}

CA::OGL::Context *CA::OGL::GLContext::bind_color_cube(CA::OGL::Context *this, uint64_t a2, atomic_uint *a3)
{
  uint64_t v5 = this;
  if (*((CA::OGL::Context **)a3 + 11) == this && (uint64_t v6 = (CA::OGL::Context *)*((void *)a3 + 10)) != 0
    || (this = (CA::OGL::Context *)CA::OGL::Context::lookup_image_(this, (CA::Render::Texture *)a3, 1),
        (uint64_t v6 = this) != 0))
  {
    if (*((unsigned char *)a3 + 12) == 23)
    {
      if (!*((void *)v6 + 1))
      {
        *((void *)v6 + 1) = a3;
        atomic_fetch_add(a3 + 37, 1u);
      }
      int v7 = *((_DWORD *)v6 + 13);
      if ((_WORD)v7)
      {
        if (*((unsigned char *)v6 + 72))
        {
          if (*((_DWORD *)v6 + 4) == a3[9])
          {
            uint64_t v8 = *((unsigned int *)v6 + 16);
            uint64_t v9 = *((void *)v5 + 2);
            *(_WORD *)(v9 + 2 * a2 + 144) = v7;
            *(void *)(v9 + 8 * a2 + 176) = v8;
          }
          else
          {
            uint64_t v11 = *(uint64_t (**)(CA::OGL::Context *, CA::OGL::Context *, atomic_uint *, uint64_t, void))(*(void *)v5 + 1184);
            return (CA::OGL::Context *)v11(v5, v6, a3, a2, 0);
          }
        }
      }
      else
      {
        if (a3[5] == 1)
        {
          int v10 = 3553;
        }
        else
        {
          int v12 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t))(*(void *)v5 + 184))(v5, 16);
          int v7 = *((_DWORD *)v6 + 13);
          if (v12) {
            int v10 = 32879;
          }
          else {
            int v10 = 3553;
          }
        }
        *((_DWORD *)v6 + 13) = v7 & 0xFFFF0000 | v10;
        *((_WORD *)v6 + 29) |= 0x100u;
        uint64_t v13 = *(uint64_t (**)(CA::OGL::Context *, CA::OGL::Context *, atomic_uint *, uint64_t, void))(*(void *)v5 + 1184);
        return (CA::OGL::Context *)v13(v5, v6, a3, a2, 0);
      }
    }
  }
  return this;
}

uint64_t CA::OGL::GLContext::pop_group_marker(CA::OGL::GLContext *this)
{
  return (*(uint64_t (**)(void))(*((void *)this + 262) + 6552))(**((void **)this + 262));
}

uint64_t CA::OGL::GLContext::push_group_marker(CA::OGL::GLContext *this, const char *a2)
{
  return (*(uint64_t (**)(void, void, const char *))(*((void *)this + 262) + 6544))(**((void **)this + 262), 0, a2);
}

uint64_t CA::OGL::GLContext::insert_event_marker(CA::OGL::GLContext *this, const char *a2)
{
  return (*(uint64_t (**)(void, void, const char *))(*((void *)this + 262) + 6536))(**((void **)this + 262), 0, a2);
}

uint64_t CA::OGL::GLContext::finish(CA::OGL::GLContext *this)
{
  return (*(uint64_t (**)(void))(*((void *)this + 262) + 720))(**((void **)this + 262));
}

uint64_t CA::OGL::GLContext::flush(CA::OGL::GLContext *this)
{
  return (*(uint64_t (**)(void))(*((void *)this + 262) + 728))(**((void **)this + 262));
}

void CA::OGL::GLContext::draw_points(CA::OGL::Context *this, uint64_t a2, uint64_t a3, const float *a4, float64x2_t a5, __n128 a6)
{
  uint64_t v10 = *((void *)this + 34);
  if (v10 != *((void *)this + 33)) {
    goto LABEL_2;
  }
  if (v10) {
    LODWORD(v10) = (*(unsigned __int8 *)(v10 + 72) >> 1) & 0x1F;
  }
  if (*((_DWORD *)this + 65) != v10) {
LABEL_2:
  }
    CA::OGL::Context::prepare_destination_(this);
  if ((*((_WORD *)this + 416) & 0x200) != 0) {
    CA::OGL::Context::flatten_detached_layers_((uint64_t)this);
  }
  *((unsigned char *)this + 2108) |= 2u;
  CA::OGL::GLContext::update_state(this, a2, a3, a4, a5, a6);
  *((unsigned char *)this + 2108) &= ~2u;
  if (*((const float **)this + 260) != a4 || *((_DWORD *)this + 522) != 3)
  {
    uint64_t v11 = (void *)*((void *)this + 262);
    ((void (*)(void, void, uint64_t, uint64_t, void, uint64_t, const float *))v11[512])(*v11, 0, 2, 5126, 0, 16, a4);
    ((void (*)(void, void))v11[513])(*v11, 0);
    ((void (*)(void, uint64_t, uint64_t, uint64_t, void, uint64_t, const float *))v11[512])(*v11, 4, 1, 5126, 0, 16, a4 + 2);
    ((void (*)(void, uint64_t))v11[513])(*v11, 4);
    ((void (*)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, const float *))v11[512])(*v11, 1, 4, 5121, 1, 16, a4 + 3);
    ((void (*)(void, uint64_t))v11[513])(*v11, 1);
    ((void (*)(void, uint64_t))v11[514])(*v11, 2);
    ((void (*)(void, uint64_t))v11[514])(*v11, 3);
    *((void *)this + 260) = a4;
    *((_DWORD *)this + 522) = 3;
  }
  (*(void (**)(void, void, uint64_t, uint64_t))(*((void *)this + 262) + 528))(**((void **)this + 262), 0, a2, a3);
  CA::OGL::GLContext::unload_state((uint64_t)this);
  CA::OGL::Context::marked_destination(this);
  ++*((_DWORD *)this + 177);
}

void CA::OGL::GLContext::update_state(CA::OGL::GLContext *this, uint64_t a2, uint64_t a3, const float *a4, float64x2_t a5, __n128 a6)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  int v7 = (void *)*((void *)this + 262);
  uint64_t v8 = *((void *)this + 2);
  uint64_t v32 = *((void *)this + 3);
  CA::OGL::GLContext::update_shader(this, a5, a6, a2, a3, a4);
  uint64_t v9 = *((unsigned int *)this + 465);
  uint64_t v10 = *((void *)this + 233);
  if (v10)
  {
    unsigned int v11 = *(unsigned __int8 *)(v10 + 34);
  }
  else
  {
    unsigned int v11 = *((_DWORD *)this + 22);
    if (v11 >= 0xD) {
      unsigned int v11 = 13;
    }
  }
  uint64_t v12 = v32;
  if (v11)
  {
    uint64_t v13 = 0;
    uint64_t v14 = v8 + 176;
    uint64_t v15 = v32 + 176;
    uint64_t v16 = v11;
    do
    {
      uint64_t v17 = v12 + 2 * v13;
      uint64_t v18 = *(unsigned __int16 *)(v17 + 144);
      uint64_t v19 = v8 + 2 * v13;
      int v20 = *(unsigned __int16 *)(v19 + 144);
      uint64_t v21 = *(void *)(v15 + 8 * v13);
      if (v18 != v20)
      {
        if (v21)
        {
          if (v13 != v9)
          {
            ((void (*)(void, void))v7[343])(*v7, (v13 + 33984));
            uint64_t v18 = *(unsigned __int16 *)(v17 + 144);
            uint64_t v9 = v13;
          }
          ((void (*)(void, uint64_t, void))v7[6])(*v7, v18, 0);
          *(void *)(v15 + 8 * v13) = 0;
          LOWORD(v20) = *(_WORD *)(v19 + 144);
          uint64_t v12 = v32;
        }
        uint64_t v21 = 0;
        *(_WORD *)(v17 + 144) = v20;
      }
      uint64_t v22 = *(void *)(v14 + 8 * v13);
      if (v22 != v21)
      {
        if (v13 != v9)
        {
          ((void (*)(void, void))v7[343])(*v7, (v13 + 33984));
          uint64_t v22 = *(void *)(v14 + 8 * v13);
          uint64_t v9 = v13;
        }
        ((void (*)(void, void, uint64_t))v7[6])(*v7, *(unsigned __int16 *)(v19 + 144), v22);
        *(void *)(v15 + 8 * v13) = *(void *)(v14 + 8 * v13);
        uint64_t v12 = v32;
      }
      ++v13;
    }
    while (v16 != v13);
  }
  *((_DWORD *)this + 465) = v9;
  unsigned int v23 = *(unsigned __int8 *)(v8 + 480);
  char v24 = (v23 < 0x1A) & *(unsigned char *)(v8 + 481);
  if (!v24)
  {
    if ((*(unsigned char *)(v12 + 481) & 1) == 0) {
      goto LABEL_26;
    }
    uint64_t v26 = (unsigned char *)(v12 + 481);
    uint64_t v27 = (void (**)(void, uint64_t))(v7 + 64);
    goto LABEL_25;
  }
  unsigned int v25 = *(unsigned __int8 *)(v12 + 480);
  if (v23 != v25)
  {
    CA::OGL::GLContext::load_blend_func((uint64_t)this, v23, v25);
    uint64_t v12 = v32;
    *(unsigned char *)(v32 + 480) = *(unsigned char *)(v8 + 480);
  }
  if ((*(unsigned char *)(v12 + 481) & 1) == 0)
  {
    uint64_t v26 = (unsigned char *)(v12 + 481);
    uint64_t v27 = (void (**)(void, uint64_t))(v7 + 73);
LABEL_25:
    (*v27)(*v7, 3042);
    *uint64_t v26 = *v26 & 0xFE | v24;
  }
LABEL_26:
  if (*((unsigned char *)this + 64))
  {
    unsigned int v28 = *((_DWORD *)this + 9);
    if (*((_DWORD *)this + 8) == *((_DWORD *)this + 12)
      && v28 == *((_DWORD *)this + 13)
      && *((_DWORD *)this + 10) == *((_DWORD *)this + 14)
      && *((_DWORD *)this + 11) == *((_DWORD *)this + 15))
    {
      if (*((unsigned char *)this + 65)) {
        goto LABEL_39;
      }
      goto LABEL_35;
    }
    unsigned int v33 = *((_DWORD *)this + 8);
    unsigned int v34 = v28;
    uint64_t v35 = *((void *)this + 5);
    (*(void (**)(CA::OGL::GLContext *, unsigned int *))(*(void *)this + 1120))(this, &v33);
    ((void (*)(void, void, void, void, void))v7[252])(*v7, v33, v34, v35, HIDWORD(v35));
    *((_OWORD *)this + 3) = *((_OWORD *)this + 2);
    if (*((unsigned char *)this + 64) != (*((unsigned char *)this + 65) & 1))
    {
      if (*((unsigned char *)this + 64))
      {
LABEL_35:
        uint64_t v29 = (void (**)(void, uint64_t))(v7 + 73);
LABEL_38:
        (*v29)(*v7, 3089);
        *((unsigned char *)this + 65) = *((unsigned char *)this + 65) & 0xFE | *((unsigned char *)this + 64);
        goto LABEL_39;
      }
LABEL_37:
      uint64_t v29 = (void (**)(void, uint64_t))(v7 + 64);
      goto LABEL_38;
    }
  }
  else if (*((unsigned char *)this + 65))
  {
    goto LABEL_37;
  }
LABEL_39:
  uint64_t v30 = *((void *)this + 233);
  if (v30 && (*(_DWORD *)(v30 + 252) & 0x80000000) == 0 && *(_DWORD *)(v30 + 256))
  {
    unsigned int v31 = 0;
    do
    {
      (*(void (**)(CA::OGL::GLContext *, void))(*(void *)this + 1176))(this, v31 + *(_DWORD *)(v30 + 252));
      ++v31;
      uint64_t v30 = *((void *)this + 233);
    }
    while (v31 < *(_DWORD *)(v30 + 256));
  }
}

uint64_t CA::OGL::GLContext::unload_state(uint64_t this)
{
  uint64_t v1 = *(_DWORD **)(this + 1864);
  if (v1)
  {
    uint64_t v2 = v1[65];
    if ((v2 & 0x80000000) == 0)
    {
      uint64_t v3 = *(void *)(this + 16);
      *(_WORD *)(v3 + 2 * v2 + 144) = 0;
      *(void *)(v3 + 8 * v2 + 176) = 0;
    }
    unsigned int v4 = v1[63];
    if ((v4 & 0x80000000) == 0)
    {
      uint64_t v5 = v1[64];
      if (v5)
      {
        uint64_t v6 = *(void *)(this + 16);
        do
        {
          *(_WORD *)(v6 + 2 * v4 + 144) = 0;
          *(void *)(v6 + 8 * v4++ + 176) = 0;
          --v5;
        }
        while (v5);
      }
    }
  }
  return this;
}

uint64_t CA::OGL::GLContext::load_blend_func(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 <= 0x14) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = 3;
  }
  if (a3 <= 0x14) {
    unsigned int v4 = a3;
  }
  else {
    unsigned int v4 = 3;
  }
  if (v3 != v4)
  {
    uint64_t v5 = *(uint64_t **)(result + 2096);
    if (CA::OGL::GLContext::load_blend_func(CA::OGL::BlendFunction,CA::OGL::BlendFunction)::functions[3 * v3] != CA::OGL::GLContext::load_blend_func(CA::OGL::BlendFunction,CA::OGL::BlendFunction)::functions[3 * v4]) {
      ((void (*)(void))v5[339])(*v5);
    }
    uint64_t v6 = *v5;
    int v7 = (char *)&CA::OGL::GLContext::load_blend_func(CA::OGL::BlendFunction,CA::OGL::BlendFunction)::functions[3 * v3];
    uint64_t v8 = *((unsigned int *)v7 + 1);
    uint64_t v9 = *((unsigned int *)v7 + 2);
    if (v3 > 0x12)
    {
      unsigned int v11 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v5[337];
      return v11(v6, v8, v9, 1, 771);
    }
    else
    {
      uint64_t v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v5[8];
      return v10(v6, v8, v9);
    }
  }
  return result;
}

void CA::OGL::GLContext::draw_lines(CA::OGL::Context *this, uint64_t a2, uint64_t a3, const float *a4, float64x2_t a5, __n128 a6)
{
  uint64_t v10 = *((void *)this + 34);
  if (v10 != *((void *)this + 33)) {
    goto LABEL_2;
  }
  if (v10) {
    LODWORD(v10) = (*(unsigned __int8 *)(v10 + 72) >> 1) & 0x1F;
  }
  if (*((_DWORD *)this + 65) != v10) {
LABEL_2:
  }
    CA::OGL::Context::prepare_destination_(this);
  if ((*((_WORD *)this + 416) & 0x200) != 0) {
    CA::OGL::Context::flatten_detached_layers_((uint64_t)this);
  }
  CA::OGL::GLContext::update_state(this, a2, a3, a4, a5, a6);
  if (*((const float **)this + 260) != a4 || *((_DWORD *)this + 522) != 2)
  {
    unsigned int v11 = (void *)*((void *)this + 262);
    ((void (*)(void, void, uint64_t, uint64_t, void, uint64_t, const float *))v11[512])(*v11, 0, 2, 5126, 0, 16, a4);
    ((void (*)(void, void))v11[513])(*v11, 0);
    ((void (*)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, const float *))v11[512])(*v11, 1, 4, 5131, 1, 16, a4 + 2);
    ((void (*)(void, uint64_t))v11[513])(*v11, 1);
    ((void (*)(void, uint64_t))v11[514])(*v11, 2);
    ((void (*)(void, uint64_t))v11[514])(*v11, 3);
    ((void (*)(void, uint64_t))v11[514])(*v11, 4);
    *((void *)this + 260) = a4;
    *((_DWORD *)this + 522) = 2;
  }
  (*(void (**)(void, uint64_t, uint64_t, uint64_t))(*((void *)this + 262) + 528))(**((void **)this + 262), 1, a2, a3);
  CA::OGL::GLContext::unload_state((uint64_t)this);
  CA::OGL::Context::marked_destination(this);
  ++*((_DWORD *)this + 177);
}

void CA::OGL::GLContext::draw_elements(uint64_t **this, uint64_t a2, uint64_t a3, const float *a4, uint64_t a5, float64x2_t a6, __n128 a7, uint64_t a8, uint64_t a9, void *a10)
{
  v27[4] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v15 = (CA::OGL::Context *)this;
    uint64_t v16 = this[262];
    uint64_t v17 = CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::primitive_modes[a2];
    uint64_t v18 = this[34];
    if (v18 != this[33]) {
      goto LABEL_3;
    }
    if (v18) {
      LODWORD(v18) = (*((unsigned __int8 *)v18 + 72) >> 1) & 0x1F;
    }
    if (*((_DWORD *)this + 65) != v18) {
LABEL_3:
    }
      this = (uint64_t **)CA::OGL::Context::prepare_destination_((CA::OGL::Context *)this);
    if ((*((_WORD *)v15 + 416) & 0x200) != 0) {
      this = (uint64_t **)CA::OGL::Context::flatten_detached_layers_((uint64_t)v15);
    }
    if (a10)
    {
      uint64_t v19 = (float64x2_t *)*((void *)v15 + 102);
      if (v19)
      {
        *((void *)v15 + 102) = 0;
        ++*((_DWORD *)v15 + 64);
      }
      MEMORY[0x1F4188790](this);
      bzero(v26, 0x300FuLL);
      CA::OGL::GLContext::update_state(v15, v20, v21, v22, v23, v24);
      CA::OGL::GLContext::init_client_state((uint64_t)v15, (uint64_t)v26);
      v27[0] = &unk_1ED030E08;
      v27[1] = v15;
      void v27[3] = v27;
      CA::OGL::clip_primitives(a2, a3, (uint64_t)a4, a5, 0, a10, v19, v26, 0x100u, (uint64_t)v27, 1u);
      std::__function::__value_func<BOOL ()(CA::OGL::Vertex *,unsigned int)>::~__value_func[abi:nn180100](v27);
      if (v19)
      {
        *((void *)v15 + 102) = v19;
        ++*((_DWORD *)v15 + 64);
      }
    }
    else
    {
      CA::OGL::GLContext::update_state(v15, a2, a3, a4, a6, a7);
      CA::OGL::GLContext::init_client_state((uint64_t)v15, a5);
      uint64_t v25 = *v16;
      if (a4) {
        ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, const float *))v16[68])(v25, v17, a3, 5123, a4);
      }
      else {
        ((void (*)(uint64_t, uint64_t, void, uint64_t))v16[66])(v25, v17, 0, a3);
      }
    }
    CA::OGL::GLContext::unload_state((uint64_t)v15);
    CA::OGL::Context::marked_destination(v15);
    ++*((_DWORD *)v15 + 177);
  }
}

uint64_t CA::OGL::GLContext::init_client_state(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(result + 2080) != a2 || *(_DWORD *)(result + 2088) != 1)
  {
    unsigned int v4 = *(void **)(result + 2096);
    ((void (*)(void, void, uint64_t, uint64_t, void, uint64_t, uint64_t))v4[512])(*v4, 0, 4, 5126, 0, 48, a2);
    ((void (*)(void, void))v4[513])(*v4, 0);
    ((void (*)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v4[512])(*v4, 1, 4, 5131, 1, 48, a2 + 32);
    ((void (*)(void, uint64_t))v4[513])(*v4, 1);
    ((void (*)(void, uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t))v4[512])(*v4, 2, 2, 5126, 0, 48, a2 + 16);
    ((void (*)(void, uint64_t))v4[513])(*v4, 2);
    ((void (*)(void, uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t))v4[512])(*v4, 3, 2, 5126, 0, 48, a2 + 24);
    ((void (*)(void, uint64_t))v4[513])(*v4, 3);
    uint64_t result = ((uint64_t (*)(void, uint64_t))v4[514])(*v4, 4);
    *(void *)(v3 + 2080) = a2;
    *(_DWORD *)(v3 + 2088) = 1;
  }
  return result;
}

uint64_t std::__function::__func<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::operator()(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  return 1;
}

uint64_t std::__function::__func<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED030E08;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1ED030E08;
  result[1] = v3;
  return result;
}

void std::__function::__func<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::~__func()
{
}

uint64_t CA::OGL::GLContext::restore_state(CA::OGL::GLContext *this, __n128 a2)
{
  uint64_t v3 = (void *)*((void *)this + 262);
  if (*((_DWORD *)this + 522))
  {
    ((void (*)(void, void))v3[514])(*v3, 0);
    ((void (*)(void, void, uint64_t, uint64_t, void, void, void))v3[512])(*v3, 0, 4, 5126, 0, 0, 0);
    ((void (*)(void, uint64_t))v3[514])(*v3, 1);
    ((void (*)(void, uint64_t, uint64_t, uint64_t, void, void, void))v3[512])(*v3, 1, 4, 5121, 0, 0, 0);
    ((void (*)(void, uint64_t))v3[514])(*v3, 2);
    ((void (*)(void, uint64_t, uint64_t, uint64_t, void, void, void))v3[512])(*v3, 2, 2, 5126, 0, 0, 0);
    ((void (*)(void, uint64_t))v3[514])(*v3, 3);
    ((void (*)(void, uint64_t, uint64_t, uint64_t, void, void, void))v3[512])(*v3, 3, 2, 5126, 0, 0, 0);
    *((_DWORD *)this + 522) = 0;
  }
  if (*((void *)this + 233))
  {
    *((void *)this + 233) = 0;
    (*(void (**)(void, void))(*((void *)this + 262) + 4808))(**((void **)this + 262), 0);
  }
  uint64_t v4 = *((void *)this + 3);
  unsigned int v5 = *((_DWORD *)this + 22);
  if (v5 >= 0xD) {
    uint64_t v6 = 13;
  }
  else {
    uint64_t v6 = v5;
  }
  uint64_t v7 = *((unsigned int *)this + 465);
  if (v6)
  {
    uint64_t v8 = 0;
    uint64_t v9 = v4 + 144;
    do
    {
      uint64_t v10 = *(unsigned __int16 *)(v9 + 2 * v8);
      if (*(_WORD *)(v9 + 2 * v8))
      {
        uint64_t v11 = v9 + 8 * v8;
        if (*(void *)(v11 + 32))
        {
          if (v8 != v7)
          {
            ((void (*)(void, void))v3[343])(*v3, (v8 + 33984));
            uint64_t v10 = *(unsigned __int16 *)(v9 + 2 * v8);
            uint64_t v7 = v8;
          }
          ((void (*)(void, uint64_t, void))v3[6])(*v3, v10, 0);
          *(void *)(v11 + 32) = 0;
        }
        *(_WORD *)(v9 + 2 * v8) = 0;
      }
      ++v8;
    }
    while (v6 != v8);
  }
  uint64_t v12 = 0;
  char v13 = 1;
  long long v14 = xmmword_184997ED0;
  do
  {
    char v15 = v13;
    {
      uint64_t v27 = v12;
      char v20 = v13;
      long long v26 = v14;
      long long v14 = v26;
      char v15 = v20;
      uint64_t v12 = v27;
      if (v21)
      {
        CA::OGL::GLContext::restore_state(void)::identity = v26;
        long long v14 = v26;
        char v15 = v20;
        uint64_t v12 = v27;
      }
    }
    uint64_t v16 = v4 + 16 * v12;
    float v18 = *(float *)(v16 + 96);
    uint64_t v17 = (long long *)(v16 + 96);
    a2.n128_f32[0] = v18;
    if (v18 != *(float *)&CA::OGL::GLContext::restore_state(void)::identity
      || (a2.n128_u32[0] = *(_DWORD *)(v4 + 16 * v12 + 100),
          a2.n128_f32[0] != *((float *)&CA::OGL::GLContext::restore_state(void)::identity + 1))
      || (uint64_t v19 = v4 + 16 * v12,
          a2.n128_u32[0] = *(_DWORD *)(v19 + 104),
          a2.n128_f32[0] != *((float *)&CA::OGL::GLContext::restore_state(void)::identity + 2))
      || (a2.n128_u32[0] = *(_DWORD *)(v19 + 108),
          a2.n128_f32[0] != *((float *)&CA::OGL::GLContext::restore_state(void)::identity + 3)))
    {
      long long *v17 = v14;
    }
    char v13 = 0;
    uint64_t v12 = 1;
  }
  while ((v15 & 1) != 0);
  if (v7)
  {
    ((void (*)(void, uint64_t, __n128))v3[343])(*v3, 33984, a2);
    *((_DWORD *)this + 465) = 0;
  }
  unsigned int v22 = *(unsigned __int8 *)(v4 + 480);
  if (v22 != 1)
  {
    CA::OGL::GLContext::load_blend_func((uint64_t)this, 1u, v22);
    *(unsigned char *)(v4 + 480) = 1;
  }
  if (*(unsigned char *)(v4 + 481))
  {
    ((void (*)(void, uint64_t))v3[64])(*v3, 3042);
    *(unsigned char *)(v4 + 481) &= ~1u;
  }
  if (*((unsigned char *)this + 65))
  {
    ((void (*)(void, uint64_t))v3[64])(*v3, 3089);
    *((unsigned char *)this + 65) &= ~1u;
  }
  memset_pattern16((char *)this + 48, &unk_1849987E0, 0x10uLL);
  ((void (*)(void, void, void, void, void))v3[252])(*v3, 0, 0, 0, 0);
  float64x2_t v23 = (uint64_t (*)(uint64_t, uint64_t))v3[73];
  uint64_t v24 = *v3;

  return v23(v24, 3024);
}

uint64_t CA::OGL::GLContext::init_state(CA::OGL::GLContext *this)
{
  uint64_t v2 = (void *)*((void *)this + 262);
  if (!*((void *)this + 33))
  {
    ((void (*)(void, uint64_t, char *))v2[105])(*v2, 2978, (char *)this + 1912);
    *((_OWORD *)this + 129) = *(_OWORD *)((char *)this + 1912);
    *((unsigned char *)this + 2108) &= ~1u;
    if (*((CA::OGL::GLContext **)this + 257) != (CA::OGL::GLContext *)((char *)this + 1928))
    {
      *((void *)this + 257) = (char *)this + 1928;
      ++*((_DWORD *)this + 64);
    }
  }
  uint64_t v3 = 0;
  *(unsigned char *)(*((void *)this + 3) + 16) = 0;
  *(unsigned char *)(*((void *)this + 3) + 17) = 0;
  *(unsigned char *)(*((void *)this + 3) + 18) = 0;
  *(unsigned char *)(*((void *)this + 3) + 19) = 0;
  *(unsigned char *)(*((void *)this + 3) + 20) = 0;
  uint64_t v4 = *((void *)this + 3);
  *(unsigned char *)(v4 + 480) = 1;
  uint64_t v5 = v4 + 96;
  do
  {
    *(_OWORD *)(v5 + v3) = xmmword_184997ED0;
    v3 += 16;
  }
  while (v3 != 48);
  *((unsigned char *)this + 65) &= ~1u;
  *((void *)this + 7) = -1;
  ((void (*)(void, uint64_t))v2[64])(*v2, 3024);
  ((void (*)(void, double, double, double, double))v2[13])(*v2, 0.0, 0.0, 0.0, 0.0);
  *((_DWORD *)this + 465) = 0;
  uint64_t result = ((uint64_t (*)(void, uint64_t))v2[343])(*v2, 33984);
  *((_DWORD *)this + 522) = 0;
  return result;
}

uint64_t CA::OGL::GLContext::purge(CA::OGL::GLContext *this, int a2)
{
  if (a2)
  {
    uint64_t v4 = (void *)*((void *)this + 262);
    if (*((void *)this + 233))
    {
      *((void *)this + 233) = 0;
      ((void (*)(void, void))v4[601])(*v4, 0);
    }
    uint64_t v5 = *((void *)this + 238);
    if (v5)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 1 << *(_DWORD *)v5;
      do
      {
        for (uint64_t i = *(uint64_t ***)(*(void *)(v5 + 16) + 8 * v6); i; uint64_t i = (uint64_t **)*i)
          CA::OGL::gl_delete_shader((uint64_t)i[2], (unsigned int *)i[3], (uint64_t)this);
        ++v6;
      }
      while (v6 != v7);
      x_hash_table_free(*((void **)this + 238));
      *((void *)this + 238) = 0;
    }
    uint64_t v9 = 0;
    uint64_t v10 = (char *)this + 1872;
    do
    {
      if (*(_DWORD *)&v10[v9])
      {
        ((void (*)(void))v4[592])(*v4);
        *(_DWORD *)&v10[v9] = 0;
      }
      v9 += 4;
    }
    while (v9 != 32);
  }

  return CA::OGL::Context::purge(this, a2);
}

void CA::OGL::gl_delete_shader(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  (*(void (**)(void, void))(*(void *)(a3 + 2096) + 4736))(**(void **)(a3 + 2096), a2[14]);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, a2);
}

void CA::OGL::GLContext::collect(CA::OGL::GLContext *this, char a2)
{
  CA::OGL::Context::collect(this, a2);
  if ((a2 & 1) != 0 || (*((_WORD *)this + 416) & 0x400) == 0)
  {
    uint64_t v4 = *(void (**)(CA::OGL::GLContext *))(*(void *)this + 1144);
    v4(this);
  }
}

const char *CA::OGL::GLContext::get_error_string(CA::OGL::GLContext *this, int a2)
{
  switch(a2)
  {
    case 1280:
      uint64_t v2 = "GL_INVALID_ENUM";
      break;
    case 1281:
      uint64_t v2 = "GL_INVALID_VALUE";
      break;
    case 1282:
      uint64_t v2 = "GL_INVALID_OPERATION";
      break;
    case 1283:
      uint64_t v2 = "GL_STACK_OVERFLOW";
      break;
    case 1284:
      uint64_t v2 = "GL_STACK_UNDERFLOW";
      break;
    case 1285:
      uint64_t v2 = "GL_OUT_OF_MEMORY";
      break;
    case 1286:
      uint64_t v2 = "GL_INVALID_FRAMEBUFFER_OPERATION;";
      break;
    default:
      if (a2)
      {
        uint64_t v2 = CA::OGL::Context::get_error_string(int)const::buf;
        snprintf(CA::OGL::Context::get_error_string(int)const::buf, 0xCuLL, "0x%x", a2);
      }
      else
      {
        uint64_t v2 = "GL_NO_ERROR";
      }
      break;
  }
  return v2;
}

uint64_t CA::OGL::GLContext::get(uint64_t a1, int a2)
{
  uint64_t result = 0;
  switch(a2)
  {
    case 8:
      return result;
    case 9:
    case 13:
    case 14:
      goto LABEL_5;
    case 10:
    case 11:
    case 12:
      uint64_t result = 1;
      break;
    case 15:
      uint64_t result = 27;
      break;
    default:
      if (a2) {
LABEL_5:
      }
        uint64_t result = a2 == 28 || a2 == 16;
      else {
        uint64_t result = (*(uint64_t (**)(void))(MEMORY[0x830] + 824))(*MEMORY[0x830]);
      }
      break;
  }
  return result;
}

uint64_t CA::OGL::GLContext::check_extension(CA::OGL::GLContext *this, char *a2, const char *a3, const char *a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (CA::OGL::GLContext::check_extension(char const*,char const*,char const*)::initialized == 1)
  {
    uint64_t v7 = (char *)CA::OGL::GLContext::check_extension(char const*,char const*,char const*)::disabled_extensions;
  }
  else
  {
    uint64_t v7 = getenv("CA_DISABLED_EXTENSIONS");
    CA::OGL::GLContext::check_extension(char const*,char const*,char const*)::disabled_extensions = (uint64_t)v7;
    CA::OGL::GLContext::check_extension(char const*,char const*,char const*)::initialized = 1;
  }
  if (CA::OGL::search_extension_list(v7, a3, a3))
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v11 = x_log_category_ogl_opengl;
      BOOL v12 = os_log_type_enabled((os_log_t)x_log_category_ogl_opengl, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (!v12) {
        return result;
      }
      *(_DWORD *)uint64_t buf = 136315138;
      long long v14 = a3;
      _os_log_impl(&dword_184668000, v11, OS_LOG_TYPE_DEFAULT, "CoreAnimation: disabling OpenGL extension %s\n", buf, 0xCu);
    }
    return 0;
  }
  else if (CA::OGL::search_extension_list((char *)this, a3, v8))
  {
    return 1;
  }
  else
  {
    return (uint64_t)CA::OGL::search_extension_list(a2, a3, v9);
  }
}

char *CA::OGL::search_extension_list(char *this, const char *a2, const char *a3)
{
  if (this)
  {
    uint64_t v4 = this;
    this = strstr(this, a2);
    if (this)
    {
      if (this <= v4 || *(this - 1) == 32) {
        return (char *)((this[strlen(a2)] & 0xDF) == 0);
      }
      else {
        return 0;
      }
    }
  }
  return this;
}

uint64_t CA::OGL::GLContext::projection_matrix(uint64_t this, float a2, float a3, float a4, float a5, int a6)
{
  if (a6) {
    float v6 = a5;
  }
  else {
    float v6 = a2;
  }
  if (a6) {
    float v7 = a4;
  }
  else {
    float v7 = a3;
  }
  if (a6) {
    a4 = a2;
  }
  else {
    a3 = a5;
  }
  float v8 = 1.0 / (float)(v7 - v6);
  float v9 = 1.0 / (float)(a3 - a4);
  uint64_t v10 = 1928;
  if (*(void *)(this + 264))
  {
    uint64_t v10 = 1992;
    uint64_t v11 = this + 1992;
  }
  else
  {
    uint64_t v11 = this + 1928;
  }
  float v12 = v8 + v8;
  if (a6) {
    float v13 = 0.0;
  }
  else {
    float v13 = v8 + v8;
  }
  *(float *)(this + v10) = v13;
  if (!a6) {
    float v12 = 0.0;
  }
  float v14 = -(float)((float)(v7 + v6) * v8);
  float v15 = v9 + v9;
  if (a6) {
    float v16 = v9 + v9;
  }
  else {
    float v16 = 0.0;
  }
  *(float *)(v11 + 4) = v16;
  if (a6) {
    float v15 = 0.0;
  }
  *(float *)(v11 + 16) = v12;
  *(float *)(v11 + 20) = v15;
  *(float *)(v11 + 48) = v14;
  *(float *)(v11 + 52) = -(float)((float)(a3 + a4) * v9);
  *(void *)(v11 + 8) = 0;
  *(void *)(v11 + 32) = 0;
  *(void *)(v11 + 40) = 0;
  *(void *)(v11 + 24) = 0;
  *(void *)(v11 + 56) = 0x3F80000000000000;
  uint64_t v17 = *(float **)(this + 2056);
  if (v17 && (float *)v11 != v17 && *v17 == v13)
  {
    uint64_t v18 = 1;
    while (v18 != 16)
    {
      uint64_t v19 = v18;
      float v20 = v17[v18];
      float v21 = *(float *)(v11 + 4 * v18++);
      if (v20 != v21)
      {
        if ((unint64_t)(v19 - 1) <= 0xE) {
          goto LABEL_26;
        }
        break;
      }
    }
  }
  else
  {
LABEL_26:
    ++*(_DWORD *)(this + 256);
  }
  *(void *)(this + 2056) = v11;
  return this;
}

uint64_t CA::OGL::GLContext::update_texture(uint64_t this, unsigned int a2)
{
  uint64_t v3 = *(void **)(this + 2096);
  uint64_t v4 = *(void *)(this + 16);
  uint64_t v5 = *(void *)(this + 24);
  if (*(_DWORD *)(this + 1860) != a2)
  {
    uint64_t v6 = this;
    this = ((uint64_t (*)(void, void))v3[343])(*v3, a2 + 33984);
    *(_DWORD *)(v6 + 1860) = a2;
  }
  uint64_t v7 = a2;
  uint64_t v8 = v5 + 2 * a2;
  int v11 = *(unsigned __int16 *)(v8 + 144);
  uint64_t v10 = (_WORD *)(v8 + 144);
  int v9 = v11;
  uint64_t v12 = v4 + 2 * a2;
  int v15 = *(unsigned __int16 *)(v12 + 144);
  float v14 = (_WORD *)(v12 + 144);
  int v13 = v15;
  uint64_t v16 = v5 + 8 * a2;
  uint64_t v19 = *(void *)(v16 + 176);
  uint64_t v18 = (void *)(v16 + 176);
  uint64_t v17 = v19;
  if (v9 != v13)
  {
    if (v17)
    {
      this = ((uint64_t (*)(void))v3[6])(*v3);
      void *v18 = 0;
      LOWORD(v13) = *v14;
    }
    uint64_t v17 = 0;
    *uint64_t v10 = v13;
  }
  uint64_t v20 = v4 + 8 * v7;
  uint64_t v22 = *(void *)(v20 + 176);
  float v21 = (void *)(v20 + 176);
  if (v22 != v17)
  {
    this = ((uint64_t (*)(void, void))v3[6])(*v3, (unsigned __int16)*v14);
    void *v18 = *v21;
  }
  return this;
}

uint64_t CA::ASEScalerStatistics::update_with_stats(uint64_t this, void *a2)
{
  if (a2)
  {
    uint64_t v3 = this;
    uint64_t v4 = (pthread_mutex_t *)(this + 16);
    pthread_mutex_lock((pthread_mutex_t *)(this + 16));
    memcpy((void *)(v3 + 104), a2, 0x17CuLL);
    return pthread_mutex_unlock(v4);
  }
  return this;
}

uint64_t CA::ASEScalerStatistics::create_iosa_params(CA::ASEScalerStatistics *this, __IOSurface *a2, __IOSurface *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (id *)malloc_type_calloc(1uLL, 0x1B0uLL, 0x10800408F598EA5uLL);
  if (((*((unsigned char *)this + 12) - 1) & 0xFC) != 0) {
    int v7 = 4;
  }
  else {
    int v7 = (*((unsigned char *)this + 12) - 1) + 1;
  }
  LODWORD(v22) = 1;
  DWORD1(v22) = v7;
  DWORD2(v22) = IOSurfaceGetWidth(a2);
  HIDWORD(v22) = IOSurfaceGetHeight(a2);
  uint64_t v8 = (void *)*((void *)this + 10);
  if (v8
    && ((void)v22 == *((void *)this + 11) ? (BOOL v9 = *((void *)&v22 + 1) == *((void *)this + 12)) : (BOOL v9 = 0), v9)
    || (v8,
        uint64_t v10 = [objc_alloc(MEMORY[0x1E4F47880]) initWithConfig:&v22],
        *((void *)this + 10) = v10,
        *(_OWORD *)((char *)this + 88) = v22,
        v10))
  {
    [*((id *)this + 10) setDestinationWidth:IOSurfaceGetWidth(a3)];
    [*((id *)this + 10) setDestinationHeight:IOSurfaceGetHeight(a3)];
    int v11 = (pthread_mutex_t *)((char *)this + 16);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
    uint64_t v12 = [*((id *)this + 10) processFrameWithInput:(char *)this + 104 outputData:v6 + 5];
    id v13 = v6[5];
    uint64_t v14 = [v6[5] bytes];
    int v15 = [v6[5] length];
    pthread_mutex_unlock(v11);
    if (v12 == -18000)
    {
      *(_DWORD *)uint64_t v6 = 4;
      v6[1] = (id)v14;
      *((_DWORD *)v6 + 4) = v15;
      *((_DWORD *)v6 + 5) = 1;
      v6[3] = v6 + 6;
      *((_DWORD *)v6 + 8) = 380;
      operator new();
    }
    if (x_log_hook_p()) {
      goto LABEL_15;
    }
    uint64_t v16 = x_log_category_utilities;
    if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_DWORD *)uint64_t buf = 134217984;
    uint64_t v24 = v12;
    uint64_t v17 = "ASEProcessing error: %ld";
    uint64_t v18 = v16;
    uint32_t v19 = 12;
LABEL_20:
    _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_ERROR, v17, buf, v19);
    goto LABEL_21;
  }
  if (!x_log_hook_p())
  {
    uint64_t v20 = x_log_category_utilities;
    if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_WORD *)uint64_t buf = 0;
    uint64_t v17 = "Could not create ASEProcessor";
    uint64_t v18 = v20;
    uint32_t v19 = 2;
    goto LABEL_20;
  }
LABEL_15:
  x_log_();
LABEL_21:
  free(v6);
  return 0;
}

void sub_1848CF2A0(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::ASEScalerStatistics::~ASEScalerStatistics(id *this)
{
  *this = &unk_1ED0273D0;

  JUMPOUT(0x185323DC0);
}

{
  *this = &unk_1ED0273D0;
}

uint64_t ___ZN2CA16ScalerStatistics14should_enhanceEmmmm_block_invoke()
{
  objc_opt_class();
  uint64_t result = objc_opt_respondsToSelector();
  CA::ScalerStatistics::should_enhance(unsigned long,unsigned long,unsigned long,unsigned long)::exists = result & 1;
  return result;
}

uint64_t CA::CG::ContextDelegate::draw_conic_gradient_(double a1, double a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7)
{
  Info = (const double *)CGContextDelegateGetInfo();
  uint64_t v14 = (CA::CG::Queue *)(*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
  if (v14)
  {
    uint64_t v15 = (uint64_t)v14;
    uint64_t v16 = CA::CG::Queue::alloc(v14, 144);
    if (v16)
    {
      uint64_t v17 = (uint64_t)v16;
      uint64_t v18 = CA::CG::DrawGradient::DrawGradient((uint64_t)v16, Info, a5, a6, a7, 0);
      *(void *)uint64_t v18 = &unk_1ED028E78;
      *(double *)(v18 + 120) = a1;
      *(double *)(v18 + 128) = a2;
      *(double *)(v18 + 136) = a3;
      CA::CG::ContextDelegate::submit((uint64_t)Info, v15, v17, a5, a6);
    }
  }
  return 0;
}

uint64_t CA::CG::ContextDelegate::resolve_style(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  v9[0] = &unk_1ED030F40;
  v9[1] = a2;
  v9[2] = a1;
  v9[3] = a3;
  v9[4] = a4;
  uint64_t v10 = 0;
  uint64_t result = (*(uint64_t (**)(_DWORD *, void *))(*(void *)a5 + 32))(a5, v9);
  if (v10)
  {
    *(void *)(a2 + 104) = v10;
    unsigned int v8 = a5[18];
    if (v8 <= 2) {
      *(_DWORD *)(a2 + 100) |= 24 - 8 * v8;
    }
  }
  return result;
}

uint64_t CA::CG::ContextDelegate::resolve_style(CA::CG::Queue *,CA::CG::DrawOp *,CGRenderingState *,CGGState *,CA::CG::Style const*)::visitor::visit(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, void, void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8), *(void *)(a1 + 16), a2, *(void *)(a1 + 24), *(void *)(a1 + 32));
  *(void *)(a1 + 40) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, void, void))(**(void **)(a1 + 8) + 72))(*(void *)(a1 + 8), *(void *)(a1 + 16), a2, *(void *)(a1 + 24), *(void *)(a1 + 32));
  *(void *)(a1 + 40) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, void, void))(**(void **)(a1 + 8) + 64))(*(void *)(a1 + 8), *(void *)(a1 + 16), a2, *(void *)(a1 + 24), *(void *)(a1 + 32));
  *(void *)(a1 + 40) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, void, void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8), *(void *)(a1 + 16), a2, *(void *)(a1 + 24), *(void *)(a1 + 32));
  *(void *)(a1 + 40) = result;
  return result;
}

uint64_t CA::CG::ContextDelegate::draw_path_direct_(uint64_t a1, uint64_t a2, uint64_t a3, int a4, const CGPath *a5, uint64_t a6)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  Info = (const double *)CGContextDelegateGetInfo();
  uint64_t v12 = (*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
  if (v12)
  {
    id v13 = (CA::CG::Queue *)v12;
    if (a4 == 2) {
      goto LABEL_22;
    }
    if (!a6) {
      goto LABEL_14;
    }
    double v14 = *(double *)a6;
    uint64_t v15 = *(void *)(a6 + 8);
    uint64_t v16 = *(void *)(a6 + 16);
    uint64_t v17 = *(void *)(a6 + 24);
    CTM = (_OWORD *)CGGStateGetCTM();
    long long v20 = CTM[1];
    long long v19 = CTM[2];
    *(_OWORD *)&v44.CGFloat a = *CTM;
    *(_OWORD *)&v44.c = v20;
    *(_OWORD *)&v44.tCGFloat x = v19;
    *(double *)&long long v19 = v14;
    *(void *)&long long v20 = v15;
    uint64_t v21 = v16;
    uint64_t v22 = v17;
    CGRect v46 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v20 - 8), &v44);
    CGFloat x = v46.origin.x;
    CGFloat y = v46.origin.y;
    CGFloat width = v46.size.width;
    CGFloat height = v46.size.height;
    int v27 = *((_DWORD *)Info + 6);
    int v28 = *((_DWORD *)Info + 7);
    int v29 = v27 <= v28 ? *((_DWORD *)Info + 7) : *((_DWORD *)Info + 6);
    LODWORD(v46.origin.x) = 1073741822;
    LODWORD(v46.origin.y) = v29;
    int8x16_t v30 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(*(int32x4_t *)&v46.origin.y, (int32x4_t)v46.origin), 0);
    uint64_t v31 = *((void *)Info + 2);
    v32.i64[0] = (int)v31;
    v32.i64[1] = SHIDWORD(v31);
    int8x16_t v33 = vbslq_s8(v30, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v32));
    double v34 = v29 <= 1073741822 ? (double)v27 : 1.79769313e308;
    double v35 = v29 <= 1073741822 ? (double)v28 : 1.79769313e308;
    uint64_t v36 = v33.i64[1];
    if (CGRectIntersectsRect(*(CGRect *)v33.i8, *(CGRect *)&x))
    {
LABEL_14:
      FillColor = (CGColor *)CGGStateGetFillColor();
      BOOL v39 = a4 == 1 || a4 == 4;
      uint64_t v40 = CA::CG::ContextDelegate::fill_path(Info, v13, a2, a3, FillColor, a5, v39, 0, (double *)a6, 1, 1);
      CA::CG::ContextDelegate::submit((uint64_t)Info, (uint64_t)v13, v40, a2, a3);
    }
    if (a4 >= 2)
    {
LABEL_22:
      StrokeColor = (CGColor *)CGGStateGetStrokeColor();
      uint64_t v42 = CA::CG::ContextDelegate::stroke_path(Info, v13, a2, a3, StrokeColor, a5, 0);
      CA::CG::ContextDelegate::submit((uint64_t)Info, (uint64_t)v13, (uint64_t)v42, a2, a3);
    }
  }
  return 0;
}

uint64_t CA::CG::ContextDelegate::fill_path(const double *a1, CA::CG::Queue *a2, uint64_t a3, uint64_t a4, CGColor *a5, const CGPath *a6, int a7, int a8, double *a9, char a10, char a11)
{
  uint64_t v124 = *MEMORY[0x1E4F143B8];
  if (!CGPathIsPrimitive()) {
    goto LABEL_35;
  }
  memset(&rect, 0, sizeof(rect));
  float64x2_t v94 = 0uLL;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  if (a8 && !CGGStateGetStyle())
  {
    long long v100 = 0u;
    long long v101 = 0u;
    long long v99 = 0u;
    CTM = (long long *)CGGStateGetCTM();
    long long v29 = CTM[1];
    long long v28 = CTM[2];
    long long v96 = *CTM;
    long long v97 = v29;
    long long v98 = v28;
    if (CGPathIsRectWithTransform())
    {
      CGGStateSetCTM();
      uint64_t v30 = CA::CG::ContextDelegate::fill_rects((int)a1, a2, a3, a4, (int)a5, (int)&rect, 1, 0, a11);
    }
    else
    {
      if (CGPathIsEllipseWithTransform())
      {
        CGGStateSetCTM();
        uint64_t v36 = CA::CG::Queue::alloc(a2, 144);
        if (!v36) {
          goto LABEL_35;
        }
        uint64_t v19 = (uint64_t)v36;
        uint64_t v37 = CA::CG::DrawOp::DrawOp((uint64_t)v36, a1, a3, a4, a5, 0);
        *(void *)uint64_t v37 = &unk_1ED027850;
        CGSize size = rect.size;
        *(CGPoint *)(v37 + 112) = rect.origin;
        *(CGSize *)(v37 + 128) = size;
        *(void *)uint64_t v37 = &unk_1ED0279E0;
        goto LABEL_34;
      }
      if (CGPathIsRoundedRectWithTransform())
      {
        CGGStateSetCTM();
        float64x2_t v94 = vabsq_f64(v94);
        CA::CG::ContextDelegate::fill_rounded_rect(a1, a2, a3, a4, a5, &rect, (__n128 *)&v94);
      }
      else
      {
        if (!CGPathIsUnevenCornersRoundedRectWithTransform()) {
          goto LABEL_35;
        }
        CGGStateSetCTM();
        CA::CG::ContextDelegate::fill_uneven_rounded_rect(a1, a2, a3, a4, a5, &rect, (uint64_t)&v106);
      }
    }
    uint64_t v19 = v30;
    if (!v30) {
      goto LABEL_35;
    }
LABEL_34:
    CGGStateSetCTM();
    return v19;
  }
  if (CGPathIsRect(a6, &rect)) {
    return CA::CG::ContextDelegate::fill_rects((int)a1, a2, a3, a4, (int)a5, (int)&rect, 1, a8, a11);
  }
  if (CGPathIsEllipse())
  {
    long long v20 = CA::CG::Queue::alloc(a2, 144);
    uint64_t v19 = (uint64_t)v20;
    if (!v20) {
      return v19;
    }
    if (a8) {
      int v21 = 4;
    }
    else {
      int v21 = 0;
    }
    CA::CG::DrawOp::DrawOp((uint64_t)v20, a1, a3, a4, a5, v21);
    *(void *)uint64_t v19 = &unk_1ED027850;
    CGSize v22 = rect.size;
    *(CGPoint *)(v19 + 112) = rect.origin;
    *(CGSize *)(v19 + 128) = v22;
    float64x2_t v23 = &unk_1ED0279E0;
LABEL_104:
    *(void *)uint64_t v19 = v23;
    return v19;
  }
  if (CGPathIsRoundedRect())
  {
    float64x2_t v94 = vabsq_f64(v94);
    uint64_t v24 = CA::CG::Queue::alloc(a2, 160);
    uint64_t v19 = (uint64_t)v24;
    if (!v24) {
      return v19;
    }
    if (a8) {
      int v25 = 4;
    }
    else {
      int v25 = 0;
    }
    CA::CG::DrawOp::DrawOp((uint64_t)v24, a1, a3, a4, a5, v25);
    *(void *)uint64_t v19 = &unk_1ED028918;
    CGSize v26 = rect.size;
    *(CGPoint *)(v19 + 112) = rect.origin;
    *(CGSize *)(v19 + 128) = v26;
    *(float64x2_t *)(v19 + 144) = v94;
    float64x2_t v23 = &unk_1ED028AB8;
    goto LABEL_104;
  }
  if (CGPathIsUnevenCornersRoundedRectWithTransform())
  {
    uint64_t v31 = CA::CG::Queue::alloc(a2, 208);
    uint64_t v19 = (uint64_t)v31;
    if (v31)
    {
      if (a8) {
        int v32 = 4;
      }
      else {
        int v32 = 0;
      }
      CA::CG::DrawOp::DrawOp((uint64_t)v31, a1, a3, a4, a5, v32);
      *(void *)uint64_t v19 = &unk_1ED029780;
      CGSize v33 = rect.size;
      *(CGPoint *)(v19 + 112) = rect.origin;
      *(CGSize *)(v19 + 128) = v33;
      long long v34 = v107;
      *(_OWORD *)(v19 + 144) = v106;
      *(_OWORD *)(v19 + 160) = v34;
      long long v35 = v109;
      *(_OWORD *)(v19 + 176) = v108;
      *(_OWORD *)(v19 + 192) = v35;
    }
    return v19;
  }
LABEL_35:
  updated = CA::CG::ContextDelegate::update_style((uint64_t)a1);
  if (!updated)
  {
LABEL_96:
    uint64_t v85 = CA::CG::Queue::alloc(a2, 152);
    uint64_t v19 = (uint64_t)v85;
    if (!v85) {
      return v19;
    }
    if (a8) {
      int v86 = 4;
    }
    else {
      int v86 = 0;
    }
    if (a7) {
      int v87 = 0x1000000;
    }
    else {
      int v87 = 0;
    }
    CA::CG::DrawPath::DrawPath((uint64_t)v85, a1, a3, a4, a5, a6, v86 | v87, a9, a10);
    float64x2_t v23 = &unk_1ED029F50;
    goto LABEL_104;
  }
  float64x2_t v104 = 0;
  uint64_t v105 = 0;
  uint64_t v103 = &unk_1ED030F70;
  (*(void (**)(double *, void **))(*(void *)updated + 32))(updated, &v103);
  uint64_t v40 = CA::CG::ContextDelegate::clip_stack((uint64_t)a1);
  if (v40)
  {
    uint64_t v43 = *(void *)(v40 + 40);
    v41.i64[0] = *(void *)(v40 + 48);
    v44.i64[0] = (int)v43;
    v44.i64[1] = SHIDWORD(v43);
    int64x2_t v45 = v44;
    int v46 = v41.i32[1];
    v44.i64[0] = v41.i32[0];
    v44.i64[1] = v41.i32[1];
    int64x2_t v47 = v44;
    if (v41.i32[0] > v41.i32[1]) {
      int v46 = *(void *)(v40 + 48);
    }
    v41.i32[0] = v46;
    v42.i32[0] = 1073741822;
    cornerint Width = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v41, v42), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v45));
    int32x2_t v48 = vdup_n_s32(v46 > 1073741822);
    v49.i64[0] = v48.u32[0];
    v49.i64[1] = v48.u32[1];
    int64x2_t v50 = (int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v49, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), (int8x16_t)vcvtq_f64_s64(v47));
  }
  else
  {
    int64x2_t v50 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    cornerint Width = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
  }
  uint64_t v51 = a6;
  float64x2_t v90 = (float64x2_t)v50;
  if ((a8 & 1) == 0)
  {
    uint64_t v52 = CGGStateGetCTM();
    uint64_t v51 = (const CGPath *)MEMORY[0x1853223D0](a6, v52);
  }
  if (!v104 || !a7) {
    goto LABEL_94;
  }
  BoundingBoCGFloat x = CGPathGetBoundingBox(v51);
  v53.i64[0] = *(void *)&BoundingBox.origin.x;
  v53.i64[1] = *(void *)&BoundingBox.origin.y;
  v54.f64[0] = 0.0;
  v55.i64[0] = *(void *)&BoundingBox.size.width;
  v55.i64[1] = *(void *)&BoundingBox.size.height;
  int8x16_t v56 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(v54, (float64x2_t)BoundingBox.size).i64[0], 0);
  v57.i64[1] = *(void *)&BoundingBox.origin.y;
  *(double *)v57.i64 = BoundingBox.size.width + BoundingBox.origin.x;
  float64x2_t v58 = (float64x2_t)vbslq_s8(v56, v57, v53);
  v53.i64[1] = *(void *)&BoundingBox.size.height;
  *(double *)v53.i64 = -BoundingBox.size.width;
  float64x2_t v59 = (float64x2_t)vbslq_s8(v56, v53, v55);
  if (BoundingBox.size.height < 0.0)
  {
    v58.f64[1] = BoundingBox.size.height + BoundingBox.origin.y;
    v59.f64[1] = -BoundingBox.size.height;
  }
  int64x2_t v60 = vclezq_f64(v90);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v60, 1), (int8x16_t)v60).u64[0] & 0x8000000000000000) == 0)
  {
    int64x2_t v61 = vclezq_f64(v59);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v61, 1), (int8x16_t)v61).u64[0] & 0x8000000000000000) == 0)
    {
      int64x2_t v62 = vclezq_f64(vsubq_f64(vminnmq_f64(vaddq_f64(cornerWidth, v90), vaddq_f64(v58, v59)), vmaxnmq_f64(cornerWidth, v58)));
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v62, 1), (int8x16_t)v62).u64[0] & 0x8000000000000000) == 0)
      {
LABEL_94:
        if ((a8 & 1) == 0) {
          CGPathRelease(v51);
        }
        goto LABEL_96;
      }
    }
  }
  float64x2_t v95 = v90;
  float64x2_t v94 = vsubq_f64(cornerWidth, vcvtq_f64_f32(*v104));
  CA::BoundsImpl::inset(v94.f64, *(float *)&v105 * -2.7, *(float *)&v105 * -2.7);
  bzero(&v106, 0x230uLL);
  v93[0] = v94;
  v93[1] = v95;
  *(void *)&long long v99 = MEMORY[0x1E4F143A8];
  *((void *)&v99 + 1) = 0x40000000;
  *(void *)&long long v100 = ___ZN2CA2CG19PathInverseDetector6detectEPK6CGPathNS_4RectE_block_invoke;
  *((void *)&v100 + 1) = &__block_descriptor_tmp_16951;
  *(void *)&long long v101 = &v106;
  CGPathApplyWithBlock2();
  if (v106 != 2) {
    goto LABEL_92;
  }
  CGFloat x = rect1.origin.x;
  CGFloat y = rect1.origin.y;
  CGRect rect = rect1;
  CGFloat width = rect1.size.width;
  CGFloat height = rect1.size.height;
  if (rect1.size.width < 0.0)
  {
    rect.origin.CGFloat x = rect1.size.width + rect1.origin.x;
    rect.size.CGFloat width = -rect1.size.width;
  }
  if (rect1.size.height < 0.0)
  {
    rect.origin.CGFloat y = rect1.size.height + rect1.origin.y;
    rect.size.CGFloat height = -rect1.size.height;
  }
  if (!CA::BoundsImpl::contains(&rect.origin.x, (double *)v93)) {
    goto LABEL_92;
  }
  CGSize v67 = *(CGSize *)(MEMORY[0x1E4F1DB28] + 16);
  rect.origiuint64_t n = (CGPoint)*MEMORY[0x1E4F1DB28];
  rect.CGSize size = v67;
  if (!CA::CG::PathInverseDetector::detect_rect((CA::CG::PathInverseDetector *)&v106, &rect)) {
    goto LABEL_60;
  }
  double v68 = rect.origin.y;
  double v69 = rect.size.width;
  double v70 = rect.size.height;
  v126.origin.CGFloat x = x;
  v126.origin.CGFloat y = y;
  double v71 = rect.origin.x;
  v126.size.CGFloat width = width;
  v126.size.CGFloat height = height;
  if (!CGRectContainsRect(v126, rect))
  {
LABEL_60:
    uint64_t v73 = *((void *)&v106 + 1);
    if (*((void *)&v106 + 1) == 5)
    {
      if ((_BYTE)v107) {
        goto LABEL_84;
      }
      uint64_t v74 = 0;
      while (v74 != 5)
      {
        uint64_t v75 = v74 + 1;
        int v76 = *((unsigned __int8 *)&v107 + v74 + 1);
        int v77 = dword_1849A78DC[++v74];
        if (v77 != v76)
        {
          if ((unint64_t)(v75 - 1) < 5) {
            goto LABEL_84;
          }
          break;
        }
      }
      if (v113.f64[1] != v118 || v111 != v115) {
        goto LABEL_84;
      }
      double v71 = v113.f64[0];
      double v68 = v112;
      double v69 = v117 - v113.f64[0];
      double v70 = v116 - v112;
      rect.origin.CGFloat x = v113.f64[0];
      rect.origin.CGFloat y = v112;
      rect.size.CGFloat width = v117 - v113.f64[0];
      rect.size.CGFloat height = v116 - v112;
      v131.origin.CGFloat x = v113.f64[0];
      v131.origin.CGFloat y = v112;
      v131.size.CGFloat width = v117 - v113.f64[0];
      v131.size.CGFloat height = v116 - v112;
      if (CGRectContainsRect(rect1, v131))
      {
        v128.origin.CGFloat x = v71;
        v128.origin.CGFloat y = v68;
        v128.size.CGFloat width = v69;
        v128.size.CGFloat height = v70;
        unint64_t v72 = CGPathCreateWithEllipseInRect(v128, 0);
        goto LABEL_59;
      }
      uint64_t v73 = *((void *)&v106 + 1);
    }
    if (v73 == 9 && !(_BYTE)v107)
    {
      uint64_t v78 = 0;
      while (v78 != 9)
      {
        uint64_t v79 = v78 + 1;
        int v80 = *((unsigned __int8 *)&v107 + v78 + 1);
        int v81 = dword_1849A78F4[++v78];
        if (v81 != v80)
        {
          if ((unint64_t)(v79 - 1) < 9) {
            goto LABEL_84;
          }
          break;
        }
      }
      float64x2_t v82 = vabdq_f64(v110, v113);
      double v71 = v110.f64[0] >= v119 ? v119 : v110.f64[0];
      double v68 = v120 >= v114 ? v114 : v120;
      double v69 = vabdd_f64(v110.f64[0], v119);
      double v70 = vabdd_f64(v120, v114);
      rect.origin.CGFloat x = v71;
      rect.origin.CGFloat y = v68;
      rect.size.CGFloat width = v69;
      rect.size.CGFloat height = v70;
      if (v82.f64[0] + v82.f64[0] <= v69)
      {
        double v89 = v82.f64[1];
        if (v89 + v89 <= v70)
        {
          cornerWidthCGFloat a = v82.f64[0];
          v132.origin.CGFloat x = v71;
          v132.origin.CGFloat y = v68;
          v132.size.CGFloat width = v69;
          v132.size.CGFloat height = v70;
          if (CGRectContainsRect(rect1, v132))
          {
            v130.origin.CGFloat x = v71;
            v130.origin.CGFloat y = v68;
            v130.size.CGFloat width = v69;
            v130.size.CGFloat height = v70;
            unint64_t v72 = CGPathCreateWithRoundedRect(v130, cornerWidtha, v89, 0);
            goto LABEL_59;
          }
        }
LABEL_85:
        LODWORD(v106) = 3;
        goto LABEL_86;
      }
    }
LABEL_84:
    double v71 = rect.origin.x;
    double v68 = rect.origin.y;
    double v69 = rect.size.width;
    double v70 = rect.size.height;
    goto LABEL_85;
  }
  v127.origin.CGFloat x = v71;
  v127.origin.CGFloat y = v68;
  v127.size.CGFloat width = v69;
  v127.size.CGFloat height = v70;
  unint64_t v72 = CGPathCreateWithRect(v127, 0);
LABEL_59:
  CGPathRef path = v72;
LABEL_86:
  v129.origin.CGFloat x = v71;
  v129.origin.CGFloat y = v68;
  v129.size.CGFloat width = v69;
  v129.size.CGFloat height = v70;
  CGFloat MidY = CGRectGetMidY(v129);
  *((void *)&v106 + 1) = 0;
  if (v106 == 3
    || (*(void *)&long long v96 = MEMORY[0x1E4F143A8],
        *((void *)&v96 + 1) = 0x40000000,
        *(void *)&long long v97 = ___ZN2CA2CG19PathInverseDetector6detectEPK6CGPathNS_4RectE_block_invoke_2,
        *((void *)&v97 + 1) = &__block_descriptor_tmp_1_16952,
        *(void *)&long long v98 = &v106,
        CGPathApplyWithBlock2(),
        v106 != 2))
  {
LABEL_92:
    float v84 = path;
LABEL_93:
    CGPathRelease(v84);
    goto LABEL_94;
  }
  CGPathRef v83 = path;
  if (!path)
  {
    float v84 = 0;
    goto LABEL_93;
  }
  if ((a8 & 1) == 0) {
    CGPathRelease(v51);
  }
  uint64_t v19 = CA::CG::ContextDelegate::fill_path(a1, a2, a3, a4, a5, v83, 1, 1, 0, 257);
  *(_DWORD *)(v19 + 100) |= 0x400u;
  CGPathRelease(path);
  return v19;
}

unint64_t *CA::CG::ContextDelegate::stroke_path(const double *a1, CA::CG::Queue *a2, uint64_t a3, uint64_t a4, CGColor *a5, const CGPath *a6, int a7)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  memset(&rect, 0, sizeof(rect));
  memset(v74, 0, sizeof(v74));
  float64x2_t v72 = 0uLL;
  v71[0] = 0;
  v71[1] = 0;
  unint64_t v69 = 0;
  double v70 = 0.0;
  double v68 = 0.0;
  if (!CGPathIsLine())
  {
    if (!CGPathIsPrimitive() || CGGStateGetLineDash()) {
      goto LABEL_6;
    }
    LineJoiuint64_t n = CGGStateGetLineJoin();
    if (CGGStateGetStyle())
    {
      if (!LineJoin && CGPathIsRect(a6, &rect)) {
        return CA::CG::ContextDelegate::stroke_rects(a1, a2, a3, a4, a5, (uint64_t)&rect, 1uLL, a7);
      }
      if (CGPathIsEllipse())
      {
        CGSize v22 = CA::CG::Queue::alloc(a2, 184);
        uint64_t v15 = v22;
        if (!v22) {
          return v15;
        }
        if (a7) {
          int v23 = 4;
        }
        else {
          int v23 = 0;
        }
        CA::CG::DrawOp::DrawOp((uint64_t)v22, a1, a3, a4, a5, v23);
        *uint64_t v15 = (unint64_t)&unk_1ED027850;
        CGSize size = rect.size;
        *((_OWORD *)v15 + 7) = rect.origin;
        *((CGSize *)v15 + 8) = size;
        *uint64_t v15 = (unint64_t)&unk_1ED028328;
        uint64_t v19 = (uint64_t)(v15 + 18);
        goto LABEL_11;
      }
      if (CGPathIsRoundedRect())
      {
        float64x2_t v72 = vabsq_f64(v72);
        return CA::CG::ContextDelegate::stroke_rounded_rect(a1, a2, a3, a4, a5, &rect, &v72, a7);
      }
LABEL_6:
      uint64_t v16 = CA::CG::Queue::alloc(a2, 192);
      uint64_t v15 = v16;
      if (!v16) {
        return v15;
      }
      if (a7) {
        int v17 = 4;
      }
      else {
        int v17 = 0;
      }
      uint64_t v18 = (void *)CA::CG::DrawPath::DrawPath((uint64_t)v16, a1, a3, a4, a5, a6, v17, 0, 1);
      void *v18 = &unk_1ED027780;
      uint64_t v19 = (uint64_t)(v18 + 19);
LABEL_11:
      CA::CG::StrokeState::StrokeState(v19);
      return v15;
    }
    float64x2_t v66 = 0u;
    long long v67 = 0u;
    float64x2_t v65 = 0u;
    if (LineJoin || (CGPathIsRectWithTransform() & 1) == 0)
    {
      if (CGPathIsEllipseWithTransform())
      {
        BOOL v25 = 0;
        int v27 = 0;
        uint64_t v57 = 0;
        int v26 = 1;
      }
      else if (CGPathIsRoundedRectWithTransform())
      {
        BOOL v25 = 0;
        int v27 = 0;
        int v26 = 0;
        uint64_t v57 = 0x100000000;
      }
      else if (CGPathIsArc())
      {
        if (v68 == 0.0) {
          return 0;
        }
        int LineCap = CGGStateGetLineCap();
        int v27 = 0;
        int v26 = 0;
        uint64_t v57 = LineCap == 0;
        BOOL v25 = LineCap != 0;
      }
      else
      {
        int v27 = 0;
        int v26 = 0;
        uint64_t v57 = 0;
        BOOL v25 = 1;
      }
    }
    else
    {
      BOOL v25 = 0;
      int v26 = 0;
      uint64_t v57 = 0;
      int v27 = 1;
    }
    uint64_t CTM = CGGStateGetCTM();
    int64x2_t v31 = *(int64x2_t *)(CTM + 16);
    long long v30 = *(_OWORD *)(CTM + 32);
    int64x2_t v62 = *(int64x2_t *)CTM;
    int64x2_t v63 = v31;
    long long v64 = v30;
    if ((a7 & 1) == 0)
    {
      *(float64x2_t *)&t1.CGFloat a = v65;
      *(float64x2_t *)&t1.c = v66;
      *(_OWORD *)&t1.tCGFloat x = v67;
      *(int64x2_t *)&t2.CGFloat a = v62;
      *(int64x2_t *)&t2.c = v63;
      *(_OWORD *)&t2.tCGFloat x = v64;
      CGAffineTransformConcat(&v61, &t1, &t2);
      float64x2_t v65 = *(float64x2_t *)&v61.a;
      float64x2_t v66 = *(float64x2_t *)&v61.c;
      long long v67 = *(_OWORD *)&v61.tx;
    }
    if (v25 || -(v66.f64[0] * v65.f64[1] - v66.f64[1] * v65.f64[0]) == 0.0) {
      goto LABEL_6;
    }
    float64x2_t v32 = (float64x2_t)vzip1q_s64(v62, v63);
    float64x2_t v33 = (float64x2_t)vzip2q_s64(v62, v63);
    int8x16_t v34 = (int8x16_t)vmlaq_f64(vmulq_f64(v32, v32), v33, v33);
    unsigned int v35 = *(double *)v34.i64 != 1.0;
    if (*(double *)&v34.i64[1] != 1.0) {
      unsigned int v35 = 1;
    }
    int32x2_t v36 = vdup_n_s32(v35);
    v37.i64[0] = v36.u32[0];
    v37.i64[1] = v36.u32[1];
    float64x2_t v38 = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v37, 0x3FuLL)), (int8x16_t)vsqrtq_f64((float64x2_t)v34), v34);
    float64x2_t v39 = (float64x2_t)vzip1q_s64((int64x2_t)v65, (int64x2_t)v66);
    float64x2_t v40 = (float64x2_t)vzip2q_s64((int64x2_t)v65, (int64x2_t)v66);
    int8x16_t v41 = (int8x16_t)vmlaq_f64(vmulq_f64(v39, v39), v40, v40);
    unsigned int v42 = *(double *)v41.i64 != 1.0;
    if (*(double *)&v41.i64[1] != 1.0) {
      unsigned int v42 = 1;
    }
    int32x2_t v43 = vdup_n_s32(v42);
    v44.i64[0] = v43.u32[0];
    v44.i64[1] = v43.u32[1];
    int64x2_t v45 = (int64x2_t)vdivq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v44, 0x3FuLL)), (int8x16_t)vsqrtq_f64((float64x2_t)v41), v41), v38);
    CGFloat v46 = *(double *)&v45.i64[1];
    double v47 = *(double *)v45.i64 / *(double *)&v45.i64[1];
    if (*(double *)v45.i64 / *(double *)&v45.i64[1] < 0.0) {
      double v47 = -(*(double *)v45.i64 / *(double *)&v45.i64[1]);
    }
    double v48 = 1.0 - v47;
    if (v47 + -1.0 >= 0.0) {
      double v48 = v47 + -1.0;
    }
    if (v48 >= 0.001) {
      goto LABEL_6;
    }
    float64x2_t v65 = vdivq_f64(v65, (float64x2_t)vdupq_lane_s64(v45.i64[0], 0));
    float64x2_t v66 = vdivq_f64(v66, (float64x2_t)vdupq_laneq_s64(v45, 1));
    sCGFloat x = (float64x2_t)v45;
    CGGStateSetCTM();
    CGFloat x = rect.origin.x;
    CGFloat y = rect.origin.y;
    CGFloat width = rect.size.width;
    CGFloat height = rect.size.height;
    CGAffineTransformMakeScale(&v58, sx.f64[0], v46);
    v76.origin.CGFloat x = x;
    v76.origin.CGFloat y = y;
    v76.size.CGFloat width = width;
    v76.size.CGFloat height = height;
    CGRect v77 = CGRectApplyAffineTransform(v76, &v58);
    CGRect rect = v77;
    if (v27)
    {
      int8x16_t v53 = CA::CG::ContextDelegate::stroke_rects(a1, a2, a3, a4, a5, (uint64_t)&rect, 1uLL, 0);
      goto LABEL_60;
    }
    if (v26)
    {
      int8x16_t v53 = CA::CG::ContextDelegate::stroke_ellipse(a1, a2, a3, a4, a5, &rect);
      goto LABEL_60;
    }
    if (HIDWORD(v57))
    {
      float64x2_t v72 = vabsq_f64(vmulq_f64(v72, sx));
      CGFloat v54 = v72.f64[0] + v72.f64[0];
      if (v54 <= CGRectGetWidth(v77))
      {
        CGFloat v55 = v72.f64[1] + v72.f64[1];
        if (v55 <= CGRectGetHeight(rect))
        {
          int8x16_t v53 = CA::CG::ContextDelegate::stroke_rounded_rect(a1, a2, a3, a4, a5, &rect, &v72, 0);
          goto LABEL_60;
        }
      }
    }
    else if (v57)
    {
      v61.CGFloat a = v70 * sx.f64[0];
      int8x16_t v53 = CA::CG::ContextDelegate::stroke_arc(a1, a2, a3, a4, a5, v71, (unint64_t *)&v61, &v69, (unint64_t *)&v68);
LABEL_60:
      uint64_t v15 = v53;
      CGGStateSetCTM();
      if (v15) {
        return v15;
      }
      goto LABEL_6;
    }
    CGGStateSetCTM();
    goto LABEL_6;
  }
  return (unint64_t *)CA::CG::ContextDelegate::draw_lines(a1, (CA::CG::DrawOp **)a2, a3, a4, a5, v74, 2uLL, a7);
}

CA::CG::DrawOp *CA::CG::ContextDelegate::draw_lines(const double *a1, CA::CG::DrawOp **this, uint64_t a3, uint64_t a4, CGColor *a5, long long *a6, unint64_t a7, int a8)
{
  uint64_t v16 = 16 * a7;
  int v17 = CA::CG::Queue::alloc((CA::CG::Queue *)this, 16 * a7 + 160);
  uint64_t v18 = v17;
  unint64_t v19 = 0;
  unint64_t v20 = a7;
  do
  {
    *(_OWORD *)&v17[v19 / 8 + 20] = a6[v19 / 0x10];
    v19 += 16;
    --v20;
  }
  while (v20);
  if (a8) {
    int v21 = 4;
  }
  else {
    int v21 = 0;
  }
  CA::CG::DrawOp::DrawOp((uint64_t)v17, a1, a3, a4, a5, v21);
  unint64_t *v18 = (unint64_t)&unk_1ED02A1C0;
  CA::CG::StrokeState::StrokeState((uint64_t)(v18 + 14));
  v18[19] = a7;
  CGSize v22 = this[5];
  if (v22
    && !*((void *)v22 + 13)
    && !CGGStateGetStyle()
    && (*(unsigned int (**)(CA::CG::DrawOp *, unint64_t *))(*(void *)v22 + 104))(v22, v18)
    && CA::CG::Queue::cancel_and_grow((CA::CG::Queue *)this, (CA::CG::DrawOp *)v18, v22, v16))
  {
    uint64_t v23 = *((void *)v22 + 19);
    uint64_t v24 = 16 * v23 + 160;
    unint64_t v25 = a7;
    do
    {
      long long v26 = *a6++;
      *(_OWORD *)((char *)v22 + v24) = v26;
      v24 += 16;
      --v25;
    }
    while (v25);
    *((void *)v22 + 19) = v23 + a7;
    return v22;
  }
  return (CA::CG::DrawOp *)v18;
}

unint64_t *CA::CG::ContextDelegate::stroke_rects(const double *a1, CA::CG::Queue *this, uint64_t a3, uint64_t a4, CGColor *a5, uint64_t a6, unint64_t a7, int a8)
{
  uint64_t v15 = CA::CG::Queue::alloc(this, 32 * a7 + 160);
  uint64_t v16 = v15;
  uint64_t v17 = 0;
  unint64_t v18 = a7;
  do
  {
    unint64_t v19 = &v15[v17];
    long long v20 = *(_OWORD *)(a6 + v17 * 8 + 16);
    *((_OWORD *)v19 + 10) = *(_OWORD *)(a6 + v17 * 8);
    *((_OWORD *)v19 + 11) = v20;
    v17 += 4;
    --v18;
  }
  while (v18);
  if (a8) {
    int v21 = 4;
  }
  else {
    int v21 = 0;
  }
  CA::CG::DrawOp::DrawOp((uint64_t)v15, a1, a3, a4, a5, v21 | ((a7 == 1) << 24));
  v16[14] = a7;
  *uint64_t v16 = (unint64_t)&unk_1ED027AF0;
  CA::CG::StrokeState::StrokeState((uint64_t)(v16 + 15));
  return v16;
}

unint64_t *CA::CG::ContextDelegate::stroke_ellipse(const double *a1, CA::CG::Queue *this, uint64_t a3, uint64_t a4, CGColor *a5, _OWORD *a6)
{
  uint64_t v11 = CA::CG::Queue::alloc(this, 184);
  uint64_t v12 = v11;
  if (v11)
  {
    CA::CG::DrawOp::DrawOp((uint64_t)v11, a1, a3, a4, a5, 0);
    unint64_t *v12 = (unint64_t)&unk_1ED027850;
    long long v13 = a6[1];
    *((_OWORD *)v12 + 7) = *a6;
    *((_OWORD *)v12 + 8) = v13;
    unint64_t *v12 = (unint64_t)&unk_1ED028328;
    CA::CG::StrokeState::StrokeState((uint64_t)(v12 + 18));
  }
  return v12;
}

unint64_t *CA::CG::ContextDelegate::stroke_rounded_rect(const double *a1, CA::CG::Queue *this, uint64_t a3, uint64_t a4, CGColor *a5, _OWORD *a6, _OWORD *a7, int a8)
{
  uint64_t v15 = CA::CG::Queue::alloc(this, 200);
  uint64_t v16 = v15;
  if (v15)
  {
    if (a8) {
      int v17 = 4;
    }
    else {
      int v17 = 0;
    }
    CA::CG::DrawOp::DrawOp((uint64_t)v15, a1, a3, a4, a5, v17);
    *uint64_t v16 = (unint64_t)&unk_1ED028918;
    long long v18 = a6[1];
    *((_OWORD *)v16 + 7) = *a6;
    *((_OWORD *)v16 + 8) = v18;
    *((_OWORD *)v16 + 9) = *a7;
    *uint64_t v16 = (unint64_t)&unk_1ED029170;
    CA::CG::StrokeState::StrokeState((uint64_t)(v16 + 20));
  }
  return v16;
}

unint64_t *CA::CG::ContextDelegate::stroke_arc(const double *a1, CA::CG::Queue *this, uint64_t a3, uint64_t a4, CGColor *a5, unint64_t *a6, unint64_t *a7, unint64_t *a8, unint64_t *a9)
{
  uint64_t v16 = CA::CG::Queue::alloc(this, 192);
  int v17 = v16;
  if (v16)
  {
    unint64_t v18 = *a6;
    unint64_t v19 = a6[1];
    unint64_t v20 = *a7;
    unint64_t v21 = *a8;
    unint64_t v22 = *a9;
    CA::CG::DrawOp::DrawOp((uint64_t)v16, a1, a3, a4, a5, 0);
    unint64_t *v17 = (unint64_t)&unk_1ED020970;
    CA::CG::StrokeState::StrokeState((uint64_t)(v17 + 14));
    v17[19] = v18;
    v17[20] = v19;
    v17[21] = v20;
    v17[22] = v21;
    v17[23] = v22;
  }
  return v17;
}

uint64_t CA::CG::DrawPath::DrawPath(uint64_t a1, const double *a2, uint64_t a3, uint64_t a4, CGColor *a5, const CGPath *a6, int a7, double *a8, char a9)
{
  *(void *)CA::CG::DrawOp::DrawOp(a1, a2, a3, a4, a5, a7) = &unk_1ED029E88;
  if (a9) {
    CGPathRef v12 = CGPathRetain(a6);
  }
  else {
    CGPathRef v12 = (CGPathRef)MEMORY[0x1853223C0](a6);
  }
  *(void *)(a1 + 112) = v12;
  if (a8)
  {
    double v13 = *a8;
    double v14 = a8[1];
    double v15 = a8[2];
    double v16 = a8[3];
  }
  else
  {
    *(CGRect *)&double v13 = CGPathGetBoundingBox(a6);
  }
  *(double *)(a1 + 120) = v13;
  *(double *)(a1 + 128) = v14;
  *(double *)(a1 + 136) = v15;
  *(double *)(a1 + 144) = v16;
  if (v15 < 0.0)
  {
    *(double *)(a1 + 120) = v15 + v13;
    *(double *)(a1 + 136) = -v15;
  }
  if (v16 < 0.0)
  {
    *(double *)(a1 + 128) = v16 + v14;
    *(double *)(a1 + 144) = -v16;
  }
  return a1;
}

uint64_t CA::CG::DrawEllipse::debug_color(CA::CG::DrawEllipse *this)
{
  return 1109371872;
}

uint64_t CA::CG::DrawRoundedRect::debug_color(CA::CG::DrawRoundedRect *this)
{
  return 1249126880;
}

__n128 CA::CG::ContextDelegate::fill_rounded_rect(const double *a1, CA::CG::Queue *this, uint64_t a3, uint64_t a4, CGColor *a5, _OWORD *a6, __n128 *a7)
{
  double v13 = CA::CG::Queue::alloc(this, 160);
  if (v13)
  {
    uint64_t v15 = CA::CG::DrawOp::DrawOp((uint64_t)v13, a1, a3, a4, a5, 0);
    *(void *)uint64_t v15 = &unk_1ED028918;
    long long v16 = a6[1];
    *(_OWORD *)(v15 + 112) = *a6;
    *(_OWORD *)(v15 + 128) = v16;
    __n128 result = *a7;
    *(__n128 *)(v15 + 144) = *a7;
    *(void *)uint64_t v15 = &unk_1ED028AB8;
  }
  return result;
}

__n128 CA::CG::ContextDelegate::fill_uneven_rounded_rect(const double *a1, CA::CG::Queue *this, uint64_t a3, uint64_t a4, CGColor *a5, _OWORD *a6, uint64_t a7)
{
  double v13 = CA::CG::Queue::alloc(this, 208);
  if (v13)
  {
    uint64_t v15 = CA::CG::DrawOp::DrawOp((uint64_t)v13, a1, a3, a4, a5, 0);
    *(void *)uint64_t v15 = &unk_1ED029780;
    long long v16 = a6[1];
    *(_OWORD *)(v15 + 112) = *a6;
    *(_OWORD *)(v15 + 128) = v16;
    *(_OWORD *)(v15 + 144) = *(_OWORD *)a7;
    *(_OWORD *)(v15 + 160) = *(_OWORD *)(a7 + 16);
    *(_OWORD *)(v15 + 176) = *(_OWORD *)(a7 + 32);
    __n128 result = *(__n128 *)(a7 + 48);
    *(__n128 *)(v15 + 192) = result;
  }
  return result;
}

float CA::CG::ContextDelegate::fill_path(CA::CG::Queue *,CGRenderingState *,CGGState *,CGColor *,CGPath const*,BOOL,BOOL,CGRect const*,BOOL,BOOL)::ShadowParamDetector::visit(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2 + 80;
  float result = *(float *)(a2 + 76);
  *(float *)(a1 + 16) = result;
  return result;
}

uint64_t CA::CG::ContextDelegate::draw_layer_()
{
  v0 = *(CA::CG::IOSurfaceDrawable **)(CGContextDelegateGetInfo() + 336);
  if (!v0) {
    return 1004;
  }
  uint64_t v1 = *((void *)v0 + 9);
  if (v1) {
    CA::CG::Queue::flush(v1, 3, 1);
  }
  CGImageRef v2 = CA::CG::IOSurfaceDrawable::copy_cgimage(v0);
  if (!v2) {
    return 1004;
  }
  uint64_t v3 = v2;
  uint64_t v4 = CGContextDelegateDrawImage();
  CGImageRelease(v3);
  return v4;
}

uint64_t CA::CG::ContextDelegate::get_layer_(double a1, double a2, float64x2_t a3, double a4)
{
  Info = (CGColorSpace **)CGContextDelegateGetInfo();
  uint64_t v7 = (*((uint64_t (**)(CGColorSpace **))*Info + 3))(Info);
  if (v7)
  {
    *(double *)v9.i64 = a1;
    *(double *)&v9.i64[1] = a2;
    v8.f64[0] = 0.0;
    v10.i64[0] = *(void *)&a3.f64[0];
    *(double *)&v10.i64[1] = a4;
    int8x16_t v11 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(v8, a3).i64[0], 0);
    *(double *)&v12.i64[1] = a4;
    *(double *)v12.i64 = -a3.f64[0];
    float64x2_t v13 = (float64x2_t)vbslq_s8(v11, v12, v10);
    *(double *)&v12.i64[1] = a2;
    *(double *)v12.i64 = a3.f64[0] + a1;
    float64x2_t v14 = (float64x2_t)vbslq_s8(v11, v12, v9);
    if (a4 < 0.0)
    {
      v14.f64[1] = a4 + a2;
      v13.f64[1] = -a4;
    }
    int8x16_t v15 = (int8x16_t)vceqzq_f64(v13);
    int32x4_t v16 = 0uLL;
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v15, 1), v15).u64[0] & 0x8000000000000000) == 0)
    {
      int8x16_t v17 = vorrq_s8((int8x16_t)vcltzq_f64(v13), (int8x16_t)vcgezq_f64(v13));
      if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v17), 1), v17).u64[0] & 0x8000000000000000) == 0)
      {
        float64x2_t v18 = vminnmq_f64(vaddq_f64(v14, v13), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
        int32x4_t v19 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v14, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        int32x4_t v16 = vuzp1q_s32(v19, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v18), (int64x2_t)v19));
      }
    }
    uint64_t v31 = v16.i64[0];
    iosurface = CA::Render::create_iosurface((CA::Render *)1, (CA::Render *)v16.u32[2], v16.u32[3], @"CA Whippet GetLayer", v5, v6);
    if (iosurface)
    {
      unint64_t v21 = iosurface;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      uint64_t v23 = (CA::CG::IOSurfaceDrawable *)malloc_type_zone_malloc(malloc_zone, 0x70uLL, 0x8BB15036uLL);
      uint64_t v24 = v23;
      if (v23)
      {
        CA::CG::IOSurfaceDrawable::IOSurfaceDrawable(v23, v21, 1, 8194, Info[4], v31, HIDWORD(v31), 0, 0);
        CFRelease(v21);
        uint64_t v25 = *((void *)v24 + 9);
        if (!v25)
        {
          uint64_t v25 = (*(uint64_t (**)(CA::CG::IOSurfaceDrawable *))(*(void *)v24 + 72))(v24);
          *((void *)v24 + 9) = v25;
          if (!v25) {
LABEL_15:
          }
            operator new();
        }
      }
      else
      {
        CFRelease(v21);
        uint64_t v25 = MEMORY[0x48];
      }
      *(void *)(v25 + 200) = v7;
      goto LABEL_15;
    }
    return 0;
  }
  return v7;
}

uint64_t CA::CG::AccelContextDelegate<CA::CG::IOSurfaceDrawable>::gpu_registry_id(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 336) + 72);
  if (v1) {
    return *(void *)(v1 + 200);
  }
  else {
    return 0;
  }
}

void CA::CG::IOSurfaceContextDelegate::~IOSurfaceContextDelegate(CA::CG::IOSurfaceContextDelegate *this)
{
  *(void *)this = &unk_1ED029520;
  CGImageRef v2 = (atomic_uint *)*((void *)this + 42);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1)
  {
    (**(void (***)(atomic_uint *))v2)(v2);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  CA::CG::ContextDelegate::~ContextDelegate((CGColorSpaceRef *)this);

  JUMPOUT(0x185323DC0);
}

{
  atomic_uint *v2;
  uint64_t vars8;

  *(void *)this = &unk_1ED029520;
  CGImageRef v2 = (atomic_uint *)*((void *)this + 42);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1)
  {
    (**(void (***)(atomic_uint *))v2)(v2);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }

  CA::CG::ContextDelegate::~ContextDelegate((CGColorSpaceRef *)this);
}

void CA::CG::ContextDelegate::~ContextDelegate(CGColorSpaceRef *this)
{
  *this = (CGColorSpaceRef)&unk_1ED028810;
  CGColorSpaceRelease(this[4]);
  CGImageRef v2 = this[41];
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)v2[1];
      free(v2);
      CGImageRef v2 = v3;
    }
    while (v3);
  }
  CGColorSpaceRef v4 = this[37];
  if (v4)
  {
    CA::ColorProgram::Cache::~Cache(this[37]);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v4);
  }
  CFStringRef v6 = (atomic_uint *)this[40];
  if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = (void (***)(char *))this[39];
  if (v7)
  {
    if (atomic_fetch_add((atomic_uint *volatile)v7, 0xFFFFFFFF) == 1) {
      CA::CG::ClipStack::destroy_clip_stack(v7);
    }
  }
}

void CA::CG::AccelContextDelegate<CA::CG::IOSurfaceDrawable>::~AccelContextDelegate(CA::CG::ContextDelegate *this)
{
  *(void *)this = &unk_1ED029520;
  CGImageRef v2 = (atomic_uint *)*((void *)this + 42);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1)
  {
    (**(void (***)(atomic_uint *))v2)(v2);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  CA::CG::ContextDelegate::~ContextDelegate((CGColorSpaceRef *)this);

  JUMPOUT(0x185323DC0);
}

{
  atomic_uint *v2;
  uint64_t vars8;

  *(void *)this = &unk_1ED029520;
  CGImageRef v2 = (atomic_uint *)*((void *)this + 42);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1)
  {
    (**(void (***)(atomic_uint *))v2)(v2);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }

  CA::CG::ContextDelegate::~ContextDelegate((CGColorSpaceRef *)this);
}

uint64_t CA::CG::ContextDelegate::end_transparency_layer_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  Info = (const double *)CGContextDelegateGetInfo();
  uint64_t v7 = (void *)*((void *)Info + 41);
  if (v7)
  {
    uint64_t v8 = *v7;
    int8x16_t v9 = *(atomic_uint **)(*v7 + 184);
    int8x16_t v10 = (void (***)(char *))*((void *)Info + 39);
    if (v10 != (void (***)(char *))v9)
    {
      if (v10 && atomic_fetch_add((atomic_uint *volatile)v10, 0xFFFFFFFF) == 1) {
        CA::CG::ClipStack::destroy_clip_stack(v10);
      }
      if (v9) {
        atomic_fetch_add(v9, 1u);
      }
      *((void *)Info + 39) = v9;
      uint64_t v7 = (void *)*((void *)Info + 41);
    }
    *((_DWORD *)Info + 76) = *(_DWORD *)(v8 + 192);
    int8x16_t v11 = (atomic_uint **)x_list_remove_head(v7);
    *((void *)Info + 41) = v11;
    if (v11) {
      int8x16_t v12 = *v11;
    }
    else {
      int8x16_t v12 = 0;
    }
    uint64_t v13 = (*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
    if (v13)
    {
      uint64_t v14 = v13;
      int8x16_t v15 = *(atomic_uint **)(v13 + 16);
      if (v15 != v12)
      {
        if (v15) {
          CA::CG::TransparencyLayer::unref(v15);
        }
        if (v12) {
          atomic_fetch_add(v12, 1u);
        }
        *(void *)(v14 + 16) = v12;
      }
    }
    uint64_t v16 = (*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
    if (v16)
    {
      int8x16_t v17 = (CA::CG::Queue *)v16;
      updated = CA::CG::ContextDelegate::update_style((uint64_t)Info);
      if ((*(unsigned char *)(v8 + 196) & 2) != 0) {
        goto LABEL_33;
      }
      uint64_t v19 = *((void *)v17 + 5);
      if (!v19) {
        goto LABEL_33;
      }
      unint64_t v20 = updated;
      if (updated)
      {
        if (*(void *)(v19 + 104)) {
          goto LABEL_33;
        }
      }
      if (CGGStateGetCompositeOperation() != 2) {
        goto LABEL_33;
      }
      uint64_t v21 = *((void *)v17 + 5);
      if (*(_DWORD *)(v21 + 56) != 2 || (*(unsigned char *)(v21 + 101) & 0x10) != 0) {
        goto LABEL_33;
      }
      uint64_t v22 = *(void *)(v21 - 8);
      if (!v22 || v22 != v8) {
        goto LABEL_33;
      }
      if (*(void *)(v21 + 72)) {
        goto LABEL_33;
      }
      uint64_t v28 = *(void *)(v21 + 104);
      if (v28)
      {
        if (*(void *)(v28 + 72)) {
          goto LABEL_33;
        }
      }
      CA::CG::TransparencyLayer::unref((atomic_uint *)v8);
      long long v29 = (atomic_uint *)*((void *)v17 + 2);
      if (v29)
      {
        atomic_fetch_add(v29, 1u);
        *(void *)(v21 - 8) = v29;
        uint64_t v30 = *((void *)v17 + 2);
        char v31 = *(unsigned char *)(v30 + 196);
        char v32 = (v31 + 1) & 3;
        if ((v31 & 2) != 0) {
          char v32 = 2;
        }
        *(unsigned char *)(v30 + 196) = v32 | v31 & 0xFC;
      }
      else
      {
        *(void *)(v21 - 8) = 0;
      }
      float64x2_t v33 = (float16x4_t *)*((void *)v17 + 5);
      if (!v33)
      {
LABEL_33:
        uint64_t v24 = CA::CG::Queue::alloc(v17, 120);
        if (v24)
        {
          uint64_t v25 = (uint64_t)v24;
          long long v26 = (void *)CA::CG::DrawOp::DrawOp((uint64_t)v24, Info, a2, a3, 0, 0x2000);
          *long long v26 = &unk_1ED0295D8;
          atomic_fetch_add((atomic_uint *volatile)v8, 1u);
          v26[14] = v8;
          CA::CG::ContextDelegate::submit((uint64_t)Info, (uint64_t)v17, v25, a2, a3);
        }
      }
      else
      {
        int8x16_t v34 = (atomic_uint *)CA::CG::ContextDelegate::clip_stack((uint64_t)Info);
        CA::CG::DrawOp::set_clip_stack((CA::CG::DrawOp *)v33, v34);
        unsigned int v35 = (CA::CG::DrawOp *)v33[13];
        if (v35) {
          CA::CG::DrawOp::set_clip_stack(v35, v34);
        }
        CGGStateGetAlpha();
        float v37 = v36;
        if (v37 != 1.0) {
          v33[11] = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v33[11]), v37));
        }
        if (v20) {
          CA::CG::ContextDelegate::resolve_style((uint64_t)Info, (uint64_t)v33, a2, a3, v20);
        }
      }
    }
    CA::CG::TransparencyLayer::unref((atomic_uint *)v8);
  }
  return a1;
}

void CA::CG::DrawOp::set_clip_stack(CA::CG::DrawOp *this, atomic_uint *a2)
{
  uint64_t v3 = (void (***)(char *))*((void *)this + 9);
  if (v3 != (void (***)(char *))a2)
  {
    if (v3 && atomic_fetch_add((atomic_uint *volatile)v3, 0xFFFFFFFF) == 1) {
      CA::CG::ClipStack::destroy_clip_stack(v3);
    }
    if (a2) {
      atomic_fetch_add(a2, 1u);
    }
    *((void *)this + 9) = a2;
  }
}

uint64_t CA::CG::ContextDelegate::begin_transparency_layer_(uint64_t a1, float64_t a2, float64_t a3, double a4, double a5)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  uint64_t Info = CGContextDelegateGetInfo();
  v75.f64[0] = a2;
  v75.f64[1] = a3;
  v76.f64[0] = a4;
  v76.f64[1] = a5;
  if (a4 < 0.0)
  {
    double v12 = a4 + a2;
    a4 = -a4;
    v75.f64[0] = v12;
    v76.f64[0] = a4;
  }
  if (a5 < 0.0)
  {
    double v13 = a5 + a3;
    a5 = -a5;
    v75.f64[1] = v13;
    v76.f64[1] = a5;
  }
  if (a4 <= a5) {
    double v14 = a5;
  }
  else {
    double v14 = a4;
  }
  if (v14 < 1.79769313e308)
  {
    uint64_t CTM = (const CGAffineTransform *)CGGStateGetCTM();
    CA::Rect::apply_transform(&v75, CTM);
  }
  uint64_t v16 = *(uint64_t **)(Info + 328);
  if (v16 && (uint64_t v17 = *v16) != 0)
  {
    int8x16_t v18 = (int8x16_t)vclezq_f64(v76);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v18, 1), v18).u64[0] & 0x8000000000000000) == 0)
    {
      float64x2_t v19 = *(float64x2_t *)(v17 + 24);
      int8x16_t v20 = (int8x16_t)vclezq_f64(v19);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v20, 1), v20).u64[0] & 0x8000000000000000) == 0)
      {
        float64x2_t v21 = *(float64x2_t *)(v17 + 8);
        float64x2_t v22 = vaddq_f64(v75, v76);
        float64x2_t v23 = vaddq_f64(v21, v19);
        float64x2_t v24 = vmaxnmq_f64(v75, v21);
        goto LABEL_20;
      }
      goto LABEL_22;
    }
    float64x2_t v74 = v76;
  }
  else
  {
    uint64_t v25 = *(void *)(Info + 24);
    int v26 = HIDWORD(v25);
    if ((int)v25 > SHIDWORD(v25)) {
      int v26 = v25;
    }
    int8x16_t v27 = (int8x16_t)vclezq_f64(v76);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v27, 1), v27).u64[0] & 0x8000000000000000) == 0)
    {
      v28.i64[0] = (int)v25;
      v28.i64[1] = SHIDWORD(v25);
      int8x16_t v29 = (int8x16_t)vcvtq_f64_s64(v28);
      int32x2_t v30 = vdup_n_s32(v26 > 1073741822);
      v28.i64[0] = v30.u32[0];
      v28.i64[1] = v30.u32[1];
      float64x2_t v31 = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v28, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v29);
      int8x16_t v32 = (int8x16_t)vclezq_f64(v31);
      int32x4_t v33 = (int32x4_t)vdupq_laneq_s64((int64x2_t)v32, 1);
      if ((vorrq_s8((int8x16_t)v33, v32).u64[0] & 0x8000000000000000) == 0)
      {
        uint64_t v34 = *(void *)(Info + 16);
        v35.i64[0] = (int)v34;
        v35.i64[1] = SHIDWORD(v34);
        v33.i32[0] = v26;
        v11.i32[0] = 1073741822;
        float64x2_t v36 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v33, v11), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v35));
        float64x2_t v22 = vaddq_f64(v75, v76);
        float64x2_t v23 = vaddq_f64(v36, v31);
        float64x2_t v24 = vmaxnmq_f64(v75, v36);
LABEL_20:
        float64x2_t v37 = vsubq_f64(vminnmq_f64(v22, v23), v24);
        int8x16_t v38 = (int8x16_t)vclezq_f64(v37);
        if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v38, 1), v38).u64[0] & 0x8000000000000000) == 0)
        {
          float64x2_t v74 = v37;
          float64x2_t v75 = v24;
          float64x2_t v76 = v37;
          goto LABEL_25;
        }
      }
LABEL_22:
      float64x2_t v76 = 0uLL;
      float64x2_t v74 = 0u;
      goto LABEL_25;
    }
    float64x2_t v74 = v76;
  }
LABEL_25:
  uint64_t v39 = CA::CG::ContextDelegate::clip_stack(Info);
  if (v39)
  {
    int v40 = *(_DWORD *)(v39 + 48);
    int v41 = *(_DWORD *)(v39 + 52);
    if (v40 <= v41) {
      int v42 = *(_DWORD *)(v39 + 52);
    }
    else {
      int v42 = *(_DWORD *)(v39 + 48);
    }
    v43.f64[0] = (double)v40;
    double v44 = (double)v41;
    if (v42 > 1073741822)
    {
      v43.f64[0] = 1.79769313e308;
      double v44 = 1.79769313e308;
    }
    if (fmax(v43.f64[0], v44) < 1.79769313e308)
    {
      int8x16_t v45 = (int8x16_t)vclezq_f64(v74);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v45, 1), v45).u64[0] & 0x8000000000000000) == 0)
      {
        v43.f64[1] = v44;
        int8x16_t v46 = (int8x16_t)vclezq_f64(v43);
        int32x4_t v47 = (int32x4_t)vdupq_laneq_s64((int64x2_t)v46, 1);
        int32x4_t v48 = (int32x4_t)vorrq_s8((int8x16_t)v47, v46);
        if (v48.i64[0] < 0) {
          goto LABEL_36;
        }
        v48.i32[0] = 1073741822;
        v47.i32[0] = v42;
        int8x16_t v49 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v47, v48), 0);
        uint64_t v50 = *(void *)(v39 + 40);
        v51.i64[0] = (int)v50;
        v51.i64[1] = SHIDWORD(v50);
        float64x2_t v52 = (float64x2_t)vbslq_s8(v49, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v51));
        float64x2_t v53 = vaddq_f64(v52, v43);
        float64x2_t v54 = vmaxnmq_f64(v75, v52);
        float64x2_t v55 = vsubq_f64(vminnmq_f64(vaddq_f64(v75, v74), v53), v54);
        int8x16_t v56 = (int8x16_t)vclezq_f64(v55);
        if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v56, 1), v56).u64[0] & 0x8000000000000000) != 0)
        {
LABEL_36:
          float64x2_t v76 = 0uLL;
        }
        else
        {
          float64x2_t v75 = v54;
          float64x2_t v76 = v55;
        }
      }
    }
  }
  updated = CA::CG::ContextDelegate::update_style(Info);
  if (updated) {
    (*(void (**)(double *, float64x2_t *))(*(void *)updated + 24))(updated, &v75);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  float64x2_t v59 = (char *)malloc_type_zone_malloc(malloc_zone, 0xC8uLL, 0x8BB15036uLL);
  int64x2_t v60 = (atomic_uint *)v59;
  if (v59)
  {
    CGAffineTransform v61 = *(atomic_uint **)(Info + 312);
    int v62 = *(_DWORD *)(Info + 304);
    *(_DWORD *)float64x2_t v59 = 0;
    float64x2_t v63 = v76;
    *(float64x2_t *)(v59 + 8) = v75;
    *(float64x2_t *)(v59 + 24) = v63;
    *((void *)v59 + 5) = 0;
    *((void *)v59 + 6) = 0;
    if (v61) {
      atomic_fetch_add(v61, 1u);
    }
    *((void *)v59 + 23) = v61;
    *((_DWORD *)v59 + 48) = v62;
    v59[196] = v59[196] & 0xF0 | 4;
    *(_DWORD *)float64x2_t v59 = 1;
    *((void *)v59 + 17) = 0x3C003C003C003C00;
    *((void *)v59 + 19) = 0;
    *((void *)v59 + 20) = 0;
    *((void *)v59 + 18) = 0;
    __int16 v64 = *((_WORD *)v59 + 86);
    *((void *)v59 + 13) = 0;
    *((void *)v59 + 14) = 0;
    *((_DWORD *)v59 + 42) = 1065353216;
    *((void *)v59 + 15) = 0;
    *((void *)v59 + 16) = &CA::identity_transform;
    *((void *)v59 + 14) = v59 + 56;
    *((_WORD *)v59 + 86) = v64 & 0xF800 | 0x503;
    uint64_t v65 = *(void *)(Info + 328);
    float64x2_t v66 = (malloc_zone_t *)get_malloc_zone();
    long long v67 = malloc_type_zone_malloc(v66, 0x10uLL, 0x8BB15036uLL);
    *long long v67 = v60;
    v67[1] = v65;
  }
  else
  {
    uint64_t v68 = *(void *)(Info + 328);
    unint64_t v69 = (malloc_zone_t *)get_malloc_zone();
    long long v67 = malloc_type_zone_malloc(v69, 0x10uLL, 0x8BB15036uLL);
    *long long v67 = 0;
    v67[1] = v68;
  }
  *(void *)(Info + 328) = v67;
  uint64_t v70 = (*(uint64_t (**)(uint64_t))(*(void *)Info + 16))(Info);
  if (v70)
  {
    uint64_t v71 = v70;
    float64x2_t v72 = *(atomic_uint **)(v70 + 16);
    if (v72 != v60)
    {
      if (v72) {
        CA::CG::TransparencyLayer::unref(v72);
      }
      if (v60) {
        atomic_fetch_add(v60, 1u);
      }
      *(void *)(v71 + 16) = v60;
    }
  }
  return a1;
}

uint64_t CA::CG::ContextDelegate::draw_image_from_rect_(double a1, double a2, double a3, double a4, double a5, double a6, float64x2_t a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, CGImage *AlternateImage)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  *(double *)&long long v53 = a1;
  *((double *)&v53 + 1) = a2;
  double v54 = a3;
  double v55 = a4;
  uint64_t Info = (const double *)CGContextDelegateGetInfo();
  uint64_t v16 = (*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
  if (v16)
  {
    uint64_t v17 = (CA::CG::Queue *)v16;
    if (CGImageIsMask(AlternateImage)) {
      FillColor = (CGColor *)CGGStateGetFillColor();
    }
    else {
      FillColor = 0;
    }
    unsigned int Width = CGImageGetWidth(AlternateImage);
    unsigned int Height = CGImageGetHeight(AlternateImage);
    *(double *)v21.i64 = a5;
    *(double *)&v21.i64[1] = a6;
    v22.f64[0] = 0.0;
    v23.i64[0] = *(void *)&a7.f64[0];
    *(double *)&v23.i64[1] = a8;
    int8x16_t v24 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(v22, a7).i64[0], 0);
    *(double *)&v25.i64[1] = a8;
    *(double *)v25.i64 = -a7.f64[0];
    float64x2_t v26 = (float64x2_t)vbslq_s8(v24, v25, v23);
    *(double *)&v25.i64[1] = a6;
    *(double *)v25.i64 = a7.f64[0] + a5;
    float64x2_t v27 = (float64x2_t)vbslq_s8(v24, v25, v21);
    if (a8 < 0.0)
    {
      v27.f64[1] = a8 + a6;
      v26.f64[1] = -a8;
    }
    int8x16_t v28 = (int8x16_t)vceqzq_f64(v26);
    unint64_t v29 = vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v28, 1), v28).u64[0];
    int8x16_t v30 = 0uLL;
    if ((v29 & 0x8000000000000000) == 0)
    {
      int8x16_t v31 = vorrq_s8((int8x16_t)vcltzq_f64(v26), (int8x16_t)vcgezq_f64(v26));
      if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v31), 1), v31).u64[0] & 0x8000000000000000) == 0)
      {
        int32x4_t v32 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v27, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        int8x16_t v30 = (int8x16_t)vuzp1q_s32(v32, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v27, v26), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v32));
      }
    }
    int32x2_t v33 = (int32x2_t)vextq_s8(v30, v30, 8uLL).u64[0];
    uint32x2_t v34 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v33);
    if ((vpmax_u32(v34, v34).u32[0] & 0x80000000) == 0)
    {
      uint32x2_t v35 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)__PAIR64__(Height, Width));
      if ((vpmax_u32(v35, v35).u32[0] & 0x80000000) == 0)
      {
        int32x2_t v36 = vadd_s32(*(int32x2_t *)v30.i8, v33);
        int32x2_t v37 = vmax_s32(*(int32x2_t *)v30.i8, 0);
        int32x2_t v38 = vsub_s32(vmin_s32(v36, (int32x2_t)__PAIR64__(Height, Width)), v37);
        uint32x2_t v39 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v38);
        if ((vpmax_u32(v39, v39).u32[0] & 0x80000000) == 0)
        {
          if (v38.i32[0] == Width && v38.i32[1] == Height)
          {
            if (CGImageGetEPSRep()) {
              AlternateImage = (CGImage *)CGImageEPSRepGetAlternateImage();
            }
            double v44 = CA::CG::Queue::alloc(v17, 160);
            uint64_t v42 = (uint64_t)v44;
            if (v44) {
              CA::CG::DrawImage::DrawImage((uint64_t)v44, Info, a10, a11, FillColor, &v53, AlternateImage);
            }
          }
          else
          {
            int32x2_t v49 = v38;
            int32x2_t v51 = v37;
            int v41 = CA::CG::Queue::alloc(v17, 176);
            uint64_t v42 = (uint64_t)v41;
            if (v41)
            {
              *(int32x2_t *)&long long v43 = v51;
              *((int32x2_t *)&v43 + 1) = v49;
              long long v52 = v43;
              CA::CG::DrawImage::DrawImage((uint64_t)v41, Info, a10, a11, FillColor, &v53, AlternateImage);
              *(void *)uint64_t v42 = &unk_1ED027CD0;
              *(_OWORD *)(v42 + 160) = v52;
            }
          }
          CA::CG::ContextDelegate::submit((uint64_t)Info, (uint64_t)v17, v42, a10, a11);
        }
      }
    }
  }
  return 0;
}

uint64_t CA::CG::DrawImage::DrawImage(uint64_t a1, const double *a2, uint64_t a3, uint64_t a4, CGColor *a5, _OWORD *a6, CGImage *a7)
{
  *(void *)CA::CG::DrawOp::DrawOp(a1, a2, a3, a4, a5, 0) = &unk_1ED02A0F0;
  InterpolationQualitCGFloat y = CGGStateGetInterpolationQuality();
  if (InterpolationQuality) {
    int v11 = InterpolationQuality;
  }
  else {
    int v11 = 4;
  }
  MinInterpolationQualitCGFloat y = CGRenderingStateGetMinInterpolationQuality();
  if (v11 < MinInterpolationQuality && MinInterpolationQuality != 0) {
    int v11 = MinInterpolationQuality;
  }
  MaxInterpolationQualitCGFloat y = CGRenderingStateGetMaxInterpolationQuality();
  if (v11 <= MaxInterpolationQuality || MaxInterpolationQuality == 0) {
    char v16 = v11;
  }
  else {
    char v16 = MaxInterpolationQuality;
  }
  *(unsigned char *)(a1 + 112) = v16;
  CGGStateGetEDRTargetHeadroom();
  *(_DWORD *)(a1 + 116) = v17;
  *(void *)(a1 + 120) = CGImageRetain(a7);
  long long v18 = a6[1];
  *(_OWORD *)(a1 + 128) = *a6;
  *(_OWORD *)(a1 + 144) = v18;
  int v19 = *(_DWORD *)(a1 + 100);
  if ((v19 & 2) == 0) {
    *(_DWORD *)(a1 + 100) = v19 | 0x2000;
  }
  return a1;
}

uint64_t CA::CG::ContextDelegate::draw_images_(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, CGImageRef *a5, _OWORD *a6, uint64_t a7)
{
  if (a7)
  {
    uint64_t v7 = a7;
    uint64_t Info = (const double *)CGContextDelegateGetInfo();
    uint64_t v13 = (*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
    if (v13)
    {
      double v14 = (CA::CG::Queue *)v13;
      int8x16_t v15 = a6;
      uint64_t v32 = v13;
      do
      {
        if (CGImageIsMask(*a5)) {
          FillColor = (CGColor *)CGGStateGetFillColor();
        }
        else {
          FillColor = 0;
        }
        CGImageRef image = *a5;
        int v17 = CA::CG::Queue::alloc(v14, 192);
        if (v17)
        {
          uint64_t v18 = (uint64_t)v17;
          if (a6) {
            int v19 = v15;
          }
          else {
            int v19 = a4;
          }
          *(void *)CA::CG::DrawOp::DrawOp((uint64_t)v17, Info, a2, a3, FillColor, 0) = &unk_1ED028520;
          InterpolationQualitCGFloat y = CGGStateGetInterpolationQuality();
          if (InterpolationQuality) {
            int v21 = InterpolationQuality;
          }
          else {
            int v21 = 4;
          }
          MinInterpolationQualitCGFloat y = CGRenderingStateGetMinInterpolationQuality();
          if (v21 < MinInterpolationQuality && MinInterpolationQuality != 0) {
            int v21 = MinInterpolationQuality;
          }
          MaxInterpolationQualitCGFloat y = CGRenderingStateGetMaxInterpolationQuality();
          if (v21 <= MaxInterpolationQuality || MaxInterpolationQuality == 0) {
            char v26 = v21;
          }
          else {
            char v26 = MaxInterpolationQuality;
          }
          *(unsigned char *)(v18 + 112) = v26;
          CGGStateGetEDRTargetHeadroom();
          *(_DWORD *)(v18 + 116) = v27;
          *(void *)(v18 + 120) = CGImageRetain(image);
          long long v28 = a4[1];
          *(_OWORD *)(v18 + 128) = *a4;
          *(_OWORD *)(v18 + 144) = v28;
          long long v29 = v19[1];
          *(_OWORD *)(v18 + 160) = *v19;
          *(_OWORD *)(v18 + 176) = v29;
          int v30 = *(_DWORD *)(v18 + 100);
          if ((v30 & 2) == 0) {
            *(_DWORD *)(v18 + 100) = v30 | 0x2000;
          }
          double v14 = (CA::CG::Queue *)v32;
          CA::CG::ContextDelegate::submit((uint64_t)Info, v32, v18, a2, a3);
        }
        v15 += 2;
        a4 += 2;
        ++a5;
        --v7;
      }
      while (v7);
    }
  }
  return 0;
}

uint64_t CA::CG::ContextDelegate::draw_radial_gradient_(double a1, double a2, double a3, double a4, double a5, double a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, char a11)
{
  uint64_t Info = (const double *)CGContextDelegateGetInfo();
  float64x2_t v22 = (CA::CG::Queue *)(*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
  if (v22)
  {
    uint64_t v23 = (uint64_t)v22;
    int8x16_t v24 = CA::CG::Queue::alloc(v22, 168);
    if (v24)
    {
      uint64_t v25 = (uint64_t)v24;
      uint64_t v26 = CA::CG::DrawGradient::DrawGradient((uint64_t)v24, Info, a8, a9, a10, a11);
      *(void *)uint64_t v26 = &unk_1ED029300;
      *(double *)(v26 + 120) = a1;
      *(double *)(v26 + 128) = a2;
      *(double *)(v26 + 136) = a4;
      *(double *)(v26 + 144) = a5;
      *(double *)(v26 + 152) = a3;
      *(double *)(v26 + 160) = a6;
      CA::CG::ContextDelegate::submit((uint64_t)Info, v23, v25, a8, a9);
    }
  }
  return 0;
}

uint64_t CA::CG::ContextDelegate::draw_linear_gradient_(double a1, double a2, double a3, double a4, uint64_t a5, uint64_t a6, uint64_t a7, const void *a8, char a9)
{
  uint64_t Info = (const double *)CGContextDelegateGetInfo();
  uint64_t v18 = (CA::CG::Queue *)(*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
  if (v18)
  {
    uint64_t v19 = (uint64_t)v18;
    int8x16_t v20 = CA::CG::Queue::alloc(v18, 152);
    if (v20)
    {
      uint64_t v21 = (uint64_t)v20;
      uint64_t v22 = CA::CG::DrawGradient::DrawGradient((uint64_t)v20, Info, a6, a7, a8, a9);
      *(void *)uint64_t v22 = &unk_1ED029238;
      *(double *)(v22 + 120) = a1;
      *(double *)(v22 + 128) = a2;
      *(double *)(v22 + 136) = a3;
      *(double *)(v22 + 144) = a4;
      if ((unint64_t)CGGradientGetLocationCount() <= 0x2000)
      {
        ColorSpace = (CGColorSpace *)CGGradientGetColorSpace();
        if (CGColorSpaceGetModel(ColorSpace) <= kCGColorSpaceModelRGB) {
          *(_DWORD *)(v21 + 100) |= 0x4000000u;
        }
      }
      unsigned int v24 = *(_DWORD *)(v21 + 56);
      BOOL v25 = v24 > 9;
      int v26 = (1 << v24) & 0x29B;
      if (!v25 && v26 != 0)
      {
        int v28 = *(_DWORD *)(v21 + 100);
        if ((v28 & 0x4000000) == 0 && (v28 & 0x3000000) != 0x3000000) {
          *(_DWORD *)(v21 + 100) = v28 | 0x100;
        }
      }
      CA::CG::ContextDelegate::submit((uint64_t)Info, v19, v21, a6, a7);
    }
  }
  return 0;
}

uint64_t CA::CG::ContextDelegate::draw_shading_(uint64_t a1, uint64_t a2, uint64_t a3, CGShading *a4)
{
  if (CGShadingGetType())
  {
    uint64_t Info = (const double *)CGContextDelegateGetInfo();
    uint64_t v8 = (CA::CG::Queue *)(*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
    if (v8)
    {
      uint64_t v9 = (uint64_t)v8;
      int8x16_t v10 = CA::CG::Queue::alloc(v8, 120);
      if (v10)
      {
        uint64_t v11 = (uint64_t)v10;
        *(void *)CA::CG::DrawOp::DrawOp((uint64_t)v10, Info, a2, a3, 0, 10240) = &unk_1ED027918;
        *(void *)(v11 + 112) = CGShadingRetain(a4);
        int Type = CGShadingGetType();
        if ((Type - 1) <= 1)
        {
          unsigned int v13 = *(_DWORD *)(v11 + 56);
          BOOL v14 = v13 > 9;
          int v15 = (1 << v13) & 0x29B;
          if (!v14 && v15 != 0 && Type == 1)
          {
            uint64_t Descriptor = CGShadingGetDescriptor();
            if (!*(unsigned char *)(Descriptor + 16) || !*(unsigned char *)(Descriptor + 40)) {
              *(_DWORD *)(v11 + 100) |= 0x100u;
            }
          }
        }
        CA::CG::ContextDelegate::submit((uint64_t)Info, v9, v11, a2, a3);
      }
    }
  }
  else
  {
    CGShadingDrawInContextDelegate();
  }
  return 0;
}

uint64_t CA::CG::ContextDelegate::draw_glyphs_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 *a5, long long *a6, unint64_t a7)
{
  int TextDrawingMode = CGGStateGetTextDrawingMode();
  if (TextDrawingMode == 3) {
    return 0;
  }
  int v14 = TextDrawingMode;
  uint64_t Info = (const double *)CGContextDelegateGetInfo();
  uint64_t v16 = (*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
  if (!v16) {
    return 0;
  }
  int v17 = (CA::CG::Queue *)v16;
  if ((v14 & 0xFFFFFFFD) == 0)
  {
    FillColor = (CGColor *)CGGStateGetFillColor();
    uint64_t v18 = CA::CG::Queue::alloc(v17, 18 * a7 + 192);
    uint64_t v19 = (CA::CG::DrawOp *)v18;
    if (a7)
    {
      int8x16_t v20 = v18 + 24;
      uint64_t v21 = &v18[2 * a7 + 24];
      uint64_t v22 = a5;
      uint64_t v23 = a6;
      unint64_t v24 = a7;
      do
      {
        __int16 v25 = *v22++;
        *(_WORD *)uint64_t v21 = v25;
        uint64_t v21 = (unint64_t *)((char *)v21 + 2);
        long long v26 = *v23++;
        *v20++ = v26;
        --v24;
      }
      while (v24);
      unint64_t v27 = a7;
    }
    else
    {
      if (!v18) {
        goto LABEL_11;
      }
      unint64_t v27 = 0;
    }
    CA::CG::DrawGlyphs::DrawGlyphs((uint64_t)v18, Info, a2, a3, FillColor, (_OWORD *)a4, v27);
    *(void *)uint64_t v19 = &unk_1ED027658;
LABEL_11:
    uint64_t v28 = *((void *)v17 + 5);
    if (v28)
    {
      if (!*(void *)(v28 + 104))
      {
        float64x2_t v66 = (CA::CG::DrawOp *)*((void *)v17 + 5);
        if (!CGGStateGetStyle()
          && (*(unsigned int (**)(CA::CG::DrawOp *, CA::CG::DrawOp *))(*(void *)v66 + 88))(v66, v19)
          && CA::CG::Queue::cancel_and_grow(v17, v19, v66, 18 * a7))
        {
          double v30 = *(double *)a4;
          double v29 = *(double *)(a4 + 8);
          double v32 = *(double *)(a4 + 16);
          double v31 = *(double *)(a4 + 24);
          double v33 = *(double *)(a4 + 32);
          double v34 = *(double *)(a4 + 40);
          uint64_t v19 = v66;
          double v35 = *((double *)v66 + 21);
          double v36 = *((double *)v66 + 22);
          uint64_t v37 = *((void *)v66 + 23);
          if (v37 - 1 >= 0)
          {
            int32x2_t v38 = (_WORD *)((char *)v66 + 18 * v37 + 190);
            uint64_t v39 = *((void *)v66 + 23);
            do
            {
              v38[8 * a7] = *v38;
              --v38;
              --v39;
            }
            while (v39);
          }
          uint64_t v40 = v37 + a7;
          if (a7)
          {
            double v41 = v34 - v36;
            double v42 = v35 - v33;
            double v43 = 1.0 / -(v32 * v29 - v31 * v30);
            double v44 = (v41 * v30 + v42 * v29) * v43;
            v46.f64[0] = (v41 * v32 + v42 * v31) * v43;
            int8x16_t v45 = (_OWORD *)((char *)v66 + 16 * v37 + 192);
            v46.f64[1] = v44;
            int32x4_t v47 = (_WORD *)((char *)v66 + 18 * v37 + 16 * a7 + 192);
            int32x4_t v48 = a5;
            int32x2_t v49 = (float64x2_t *)a6;
            unint64_t v50 = a7;
            do
            {
              __int16 v51 = *v48++;
              *v47++ = v51;
              float64x2_t v52 = *v49++;
              *(void *)&long long v53 = *(_OWORD *)&vsubq_f64(v52, v46);
              *((void *)&v53 + 1) = *(void *)&vaddq_f64(v52, v46).f64[1];
              *v45++ = v53;
              --v50;
            }
            while (v50);
          }
          *((void *)v66 + 23) = v40;
        }
      }
    }
    CA::CG::ContextDelegate::submit((uint64_t)Info, (uint64_t)v17, (uint64_t)v19, a2, a3);
  }
  if ((v14 - 1) <= 1)
  {
    StrokeColor = (CGColor *)CGGStateGetStrokeColor();
    if (CGColorGetAlpha(StrokeColor) != 0.0
      || (CompositeOperatiouint64_t n = CGGStateGetCompositeOperation(), CompositeOperation <= 9)
      && ((0x164u >> CompositeOperation) & 1) == 0)
    {
      uint64_t v56 = CA::CG::Queue::alloc(v17, 18 * a7 + 232);
      uint64_t v57 = (uint64_t)v56;
      if (a7)
      {
        CGAffineTransform v58 = v56 + 29;
        float64x2_t v59 = &v56[2 * a7 + 29];
        unint64_t v60 = a7;
        do
        {
          __int16 v61 = *a5++;
          *(_WORD *)float64x2_t v59 = v61;
          float64x2_t v59 = (unint64_t *)((char *)v59 + 2);
          long long v62 = *a6++;
          *v58++ = v62;
          --v60;
        }
        while (v60);
        goto LABEL_34;
      }
      if (v56)
      {
        a7 = 0;
LABEL_34:
        float64x2_t v63 = (void *)CA::CG::DrawGlyphs::DrawGlyphs((uint64_t)v56, Info, a2, a3, StrokeColor, (_OWORD *)a4, a7);
        *float64x2_t v63 = &unk_1ED027DF0;
        CA::CG::StrokeState::StrokeState((uint64_t)(v63 + 24));
        CA::CG::ContextDelegate::submit((uint64_t)Info, (uint64_t)v17, v57, a2, a3);
      }
    }
  }
  return 0;
}

uint64_t CA::CG::DrawGlyphs::DrawGlyphs(uint64_t a1, const double *a2, uint64_t a3, uint64_t a4, CGColor *a5, _OWORD *a6, unint64_t a7)
{
  *(void *)CA::CG::DrawOp::DrawOp(a1, a2, a3, a4, a5, 512) = &unk_1ED0274B8;
  Font = (const void *)CGGStateGetFont();
  *(void *)(a1 + 112) = Font;
  if (Font) {
    CFRetain(Font);
  }
  CGGStateGetFontSize();
  *(void *)(a1 + 120) = v12;
  int FontRenderingStyle = CGGStateGetFontRenderingStyle();
  *(_DWORD *)(a1 + 128) = MEMORY[0x1853227C0](a3) & FontRenderingStyle;
  *(_DWORD *)(a1 + 132) = CGGStateGetTextDrawingMode();
  long long v15 = a6[1];
  long long v14 = a6[2];
  *(_OWORD *)(a1 + 136) = *a6;
  *(_OWORD *)(a1 + 152) = v15;
  *(_OWORD *)(a1 + 168) = v14;
  *(void *)(a1 + 184) = a7;
  if (CGGStateGetShouldDrawBitmapRuns()) {
    *(_DWORD *)(a1 + 100) |= 0x1000000u;
  }
  if (a7 >= 2) {
    *(_DWORD *)(a1 + 100) |= 0x1000u;
  }
  return a1;
}

uint64_t CA::CG::DrawGlyphs::debug_color(CA::CG::DrawGlyphs *this)
{
  return 3912966880;
}

uint64_t CA::CG::ContextDelegate::draw_image_(double a1, double a2, double a3, double a4, uint64_t a5, uint64_t a6, uint64_t a7, CGImage *AlternateImage)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  *(double *)&long long v18 = a1;
  *((double *)&v18 + 1) = a2;
  double v19 = a3;
  double v20 = a4;
  uint64_t Info = (const double *)CGContextDelegateGetInfo();
  if (CGImageIsMask(AlternateImage)) {
    FillColor = (CGColor *)CGGStateGetFillColor();
  }
  else {
    FillColor = 0;
  }
  uint64_t v13 = (*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
  if (v13)
  {
    long long v14 = (CA::CG::Queue *)v13;
    if (CGImageGetEPSRep()) {
      AlternateImage = (CGImage *)CGImageEPSRepGetAlternateImage();
    }
    long long v15 = CA::CG::Queue::alloc(v14, 160);
    if (v15)
    {
      uint64_t v16 = (uint64_t)v15;
      CA::CG::DrawImage::DrawImage((uint64_t)v15, Info, a6, a7, FillColor, &v18, AlternateImage);
      CA::CG::ContextDelegate::submit((uint64_t)Info, (uint64_t)v14, v16, a6, a7);
    }
  }
  return 0;
}

uint64_t CA::CG::ContextDelegate::draw_path_(uint64_t a1, uint64_t a2, uint64_t a3, int a4, const CGPath *a5)
{
  uint64_t Info = (const double *)CGContextDelegateGetInfo();
  uint64_t v10 = (*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
  if (v10)
  {
    uint64_t v11 = (CA::CG::Queue *)v10;
    if (a4 == 2
      || ((FillColor = (CGColor *)CGGStateGetFillColor(), a4 != 1) ? (BOOL v13 = a4 == 4) : (BOOL v13 = 1),
          !v13 ? (int v14 = 0) : (int v14 = 1),
          uint64_t v15 = CA::CG::ContextDelegate::fill_path(Info, v11, a2, a3, FillColor, a5, v14, 1, 0, 1, 1),
          CA::CG::ContextDelegate::submit((uint64_t)Info, (uint64_t)v11, v15, a2, a3),
          a4 >= 2))
    {
      StrokeColor = (CGColor *)CGGStateGetStrokeColor();
      int v17 = CA::CG::ContextDelegate::stroke_path(Info, v11, a2, a3, StrokeColor, a5, 1);
      CA::CG::ContextDelegate::submit((uint64_t)Info, (uint64_t)v11, (uint64_t)v17, a2, a3);
    }
  }
  return 0;
}

void CA::CG::ContextDelegate::draw_lines_(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, unint64_t a5)
{
  if (a5)
  {
    uint64_t Info = (const double *)CGContextDelegateGetInfo();
    StrokeColor = (CGColor *)CGGStateGetStrokeColor();
    uint64_t v11 = (CA::CG::DrawOp **)(*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
    if (v11)
    {
      uint64_t v12 = (uint64_t)v11;
      BOOL v13 = CA::CG::ContextDelegate::draw_lines(Info, v11, a2, a3, StrokeColor, a4, a5, 0);
      CA::CG::ContextDelegate::submit((uint64_t)Info, v12, (uint64_t)v13, a2, a3);
    }
  }
}

double CA::CG::ContextDelegate::get_transform_@<D0>(uint64_t a1@<X8>)
{
  uint64_t Info = CGContextDelegateGetInfo();
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0x3FF0000000000000;
  *(_OWORD *)(a1 + 24) = xmmword_184997E00;
  double result = (float)-(float)*(int *)(Info + 28);
  *(double *)(a1 + 40) = result;
  return result;
}

int8x16_t CA::CG::ContextDelegate::get_bounds_()
{
  uint64_t Info = CGContextDelegateGetInfo();
  if (*(_DWORD *)(Info + 24) <= *(_DWORD *)(Info + 28)) {
    __int32 v3 = *(_DWORD *)(Info + 28);
  }
  else {
    __int32 v3 = *(_DWORD *)(Info + 24);
  }
  v1.i32[0] = 1073741822;
  v2.i32[0] = v3;
  int8x16_t v4 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v2, v1), 0);
  uint64_t v5 = *(void *)(Info + 16);
  v6.i64[0] = (int)v5;
  v6.i64[1] = SHIDWORD(v5);
  return vbslq_s8(v4, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v6));
}

uint64_t CA::CG::ContextDelegate::finalize_()
{
  uint64_t result = CGContextDelegateGetInfo();
  if (result)
  {
    int32x4_t v1 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v1();
  }
  return result;
}

CA::Render *CA::WindowServer::IOSurface::reload_edr_factor(CA::WindowServer::IOSurface *this)
{
  uint64_t result = (CA::Render *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(void *)this + 160))(this);
  if (result)
  {
    v4.n128_f32[0] = CA::Render::iosurface_get_edr_factor(result, v3);
    uint64_t v5 = *(uint64_t (**)(CA::WindowServer::IOSurface *, __n128))(*(void *)this + 200);
    return (CA::Render *)v5(this, v4);
  }
  return result;
}

float CA::WindowServer::IOSurface::edr_factor(CA::WindowServer::IOSurface *this)
{
  return *((float *)this + 63);
}

uint64_t CA::WindowServer::IOSurface::copy_iosurface(CA::WindowServer::IOSurface *this, CA::WindowServer::Surface *a2, uint64_t a3, int a4, CA::Rect *a5, CA::Rect *a6, atomic_uint *a7, float a8)
{
  uint64_t v319 = *MEMORY[0x1E4F143B8];
  int v286 = a4;
  uint64_t v15 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::Surface *, float))(*(void *)a2 + 160))(a2, a8);
  uint64_t v16 = *((void *)this + 1);
  if (v16) {
    _ZF = v15 == 0;
  }
  else {
    _ZF = 1;
  }
  if (_ZF) {
    return 0;
  }
  long long v18 = v15;
  unint64_t v274 = (unint64_t)a5;
  size_t Width = IOSurfaceGetWidth(v15);
  size_t Height = IOSurfaceGetHeight(v18);
  if ((a3 & 0x100) == 0
    && !(*(unsigned int (**)(uint64_t, size_t, size_t, void, void))(*(void *)v16 + 144))(v16, Width, Height, *((unsigned int *)this + 14), *((unsigned int *)this + 15)))
  {
    return 0;
  }
  if (a4 && ((*(uint64_t (**)(uint64_t))(*(void *)v16 + 160))(v16) & 1) == 0) {
    int v286 = 0;
  }
  uint64_t v22 = CA::WindowServer::Display::copy_iosa_manager((CA::WindowServer::Display *)v16, v20);
  if (!*(void *)(v22 + 16))
  {
LABEL_69:
    CA::IOSAManager::unref(v22);
    return 0;
  }
  uint64_t v259 = (double *)a6;
  unint64_t v261 = Height;
  unint64_t v267 = Width;
  unsigned int v23 = a3 & 0x2000;
  __int16 v24 = a3 & 7;
  int valuePtr = a3 & 7;
  uint64_t v273 = a3;
  if ((a3 & 0x200) != 0) {
    __int16 v24 = a3 & 7 | 8;
  }
  if ((a3 & 0x2000) != 0) {
    __int16 v25 = v24 | 0x10;
  }
  else {
    __int16 v25 = v24;
  }
  unsigned int theString = v23;
  unsigned int v26 = v23 >> 13;
  unint64_t v27 = (__CFDictionary *)*((void *)a2 + 2);
  uint64_t v28 = (__CFDictionary *)*((void *)this + 2);
  uint64_t v264 = v28;
  uint64_t v270 = v27;
  if (BYTE6(xmmword_1EB2ACC70))
  {
    if (x_log_hook_p())
    {
      CGRect v131 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)a2 + 160))(a2);
      IOSurfaceGetID(v131);
      x_log_();
    }
    else
    {
      int v137 = x_log_category_sharedevent;
      if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEBUG))
      {
        unsigned __int8 v138 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)a2 + 160))(a2);
        IOSurfaceID ID = IOSurfaceGetID(v138);
        uint64_t v140 = *((void *)a2 + 2);
        LODWORD(keys[0]) = 67109376;
        HIDWORD(keys[0]) = ID;
        LOWORD(keys[1]) = 2048;
        *(void *)((char *)&keys[1] + 2) = v140;
        _os_log_impl(&dword_184668000, v137, OS_LOG_TYPE_DEBUG, "IOSurfaceID: 0x%x  copy_iosurface (SRC) SharedEvent: %p", (uint8_t *)keys, 0x12u);
      }
    }
    if (x_log_hook_p())
    {
      int v141 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(void *)this + 160))(this);
      IOSurfaceGetID(v141);
      x_log_();
    }
    else
    {
      int v142 = x_log_category_sharedevent;
      BOOL v143 = os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEBUG);
      unint64_t v27 = v270;
      if (!v143) {
        goto LABEL_17;
      }
      uint64_t v144 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(void *)this + 160))(this);
      IOSurfaceID v145 = IOSurfaceGetID(v144);
      uint64_t v146 = *((void *)this + 2);
      LODWORD(keys[0]) = 67109376;
      HIDWORD(keys[0]) = v145;
      LOWORD(keys[1]) = 2048;
      *(void *)((char *)&keys[1] + 2) = v146;
      _os_log_impl(&dword_184668000, v142, OS_LOG_TYPE_DEBUG, "IOSurfaceID: 0x%x  copy_iosurface (DST) SharedEvent: %p", (uint8_t *)keys, 0x12u);
    }
    unint64_t v27 = v270;
  }
LABEL_17:
  uint64_t v29 = 0;
  __int16 v30 = v25 | 0x20;
  BOOL v31 = v27 == 0;
  if (!v27) {
    __int16 v30 = v25;
  }
  unsigned int v32 = v26 + 3;
  if (v31) {
    unsigned int v32 = v26;
  }
  if (v28)
  {
    v30 |= 0x40u;
    unsigned int v33 = v32 + 3;
  }
  else
  {
    unsigned int v33 = v32;
  }
  int v34 = (unsigned __int16)(v30 | ((_WORD)v286 << 8));
  while (*(_DWORD *)(v16 + v29 + 336) != v34)
  {
    v29 += 16;
    if (v29 == 64)
    {
      double v35 = 0;
      goto LABEL_29;
    }
  }
  double v35 = *(__CFDictionary **)(v16 + v29 + 328);
LABEL_29:
  double v36 = (void **)MEMORY[0x1E4F1CFD0];
  uint64_t v37 = (void **)MEMORY[0x1E4F1CFC8];
  if ((_BYTE)qword_1EB2ACC90) {
    int32x2_t v38 = (void **)MEMORY[0x1E4F1CFC8];
  }
  else {
    int32x2_t v38 = (void **)MEMORY[0x1E4F1CFD0];
  }
  theDict = v35;
  if (!v35)
  {
    uint64_t v254 = v18;
    uint64_t v39 = *v38;
    memset(&keys[1], 0, 56);
    long long v317 = 0u;
    long long v318 = 0u;
    *(_OWORD *)values = 0u;
    long long v316 = 0u;
    keys[0] = *MEMORY[0x1E4F6ED68];
    CFNumberRef v40 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    uint64_t v41 = *MEMORY[0x1E4F6ED78];
    double v42 = *v36;
    double v43 = *v37;
    if ((v273 & 0x200) != 0) {
      double v43 = v42;
    }
    values[0] = v40;
    values[1] = v43;
    uint64_t v44 = *MEMORY[0x1E4F6EC40];
    keys[1] = v41;
    keys[2] = v44;
    *(void *)&long long v316 = CFNumberCreate(0, kCFNumberIntType, &v286);
    if (theString)
    {
      uint64_t v45 = *MEMORY[0x1E4F6ECC8];
      keys[3] = *MEMORY[0x1E4F6EC70];
      keys[4] = v45;
      *((void *)&v316 + 1) = v42;
      *(void *)&long long v317 = v42;
      keys[5] = *MEMORY[0x1E4F6EC58];
      *((void *)&v317 + 1) = v42;
      int v46 = 6;
    }
    else
    {
      int v46 = 3;
    }
    keys[v46] = *MEMORY[0x1E4F6EC50];
    values[v46] = v39;
    CFDictionaryRef v47 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, (v46 + 1), MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionaryRef v48 = v47;
    if (v33)
    {
      CFIndex Count = CFDictionaryGetCount(v47);
      MutableCopCGFloat y = CFDictionaryCreateMutableCopy(0, Count + v33, v48);
      CFRelease(v48);
      CFDictionaryRef v48 = MutableCopy;
    }
    long long v18 = v254;
    __int16 v51 = *(const void **)(v16 + 376);
    if (v51) {
      CFRelease(v51);
    }
    float64x2_t v52 = (_OWORD *)(v16 + 376);
    for (unint64_t i = 4; i > 1; --i)
    {
      _OWORD *v52 = *(v52 - 1);
      --v52;
    }
    theDict = v48;
    *(void *)(v16 + 328) = v48;
    *(_DWORD *)(v16 + 336) = v34;
    *(_DWORD *)(v16 + 340) = 0;
    CFRelease(values[0]);
    CFRelease((CFTypeRef)v316);
  }
  double v54 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(void *)this + 160))(this);
  uint64_t v55 = v273;
  BOOL v252 = (v273 & 0x1000) == 0;
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (*(float *)&dword_1EB2ACAB0) {
    BOOL v252 = 0;
  }
  uint64_t v283 = v22;
  uint64_t v284 = 0;
  unsigned int v258 = *(float *)&dword_1EB2ACAB0;
  if (!theString || !a7)
  {
    if (!theString) {
      goto LABEL_58;
    }
    goto LABEL_55;
  }
  uint64_t v56 = (void *)(*(uint64_t (**)(atomic_uint *, __IOSurface *, __IOSurface *))(*(void *)a7 + 16))(a7, v18, v54);
  if (!v56)
  {
LABEL_55:
    CFDictionaryRemoveValue(theDict, (const void *)*MEMORY[0x1E4F6EC48]);
    goto LABEL_58;
  }
  uint64_t v57 = v56;
  uint64_t v255 = v18;
  uint64_t v58 = *v56;
  float64x2_t v59 = (const void *)*MEMORY[0x1E4F6EC48];
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F6EC48]);
  if (Value)
  {
    CFDictionaryRef ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(Value, 0);
  }
  else
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 1, MEMORY[0x1E4F1D510]);
    CFDictionarySetValue(theDict, v59, Mutable);
    CFRelease(Mutable);
    CFDictionaryRef ValueAtIndex = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 40);
    CFDataSetLength(ValueAtIndex, 40);
    float64x2_t v63 = Mutable;
    uint64_t v55 = v273;
    CFArraySetValueAtIndex(v63, 0, ValueAtIndex);
    CFRelease(ValueAtIndex);
  }
  MutableBytePtr = CFDataGetMutableBytePtr(ValueAtIndex);
  uint64_t v65 = *(void *)(v58 + 32);
  long long v66 = *(_OWORD *)(v58 + 16);
  *(_OWORD *)MutableBytePtr = *(_OWORD *)v58;
  *((_OWORD *)MutableBytePtr + 1) = v66;
  *((void *)MutableBytePtr + 4) = v65;
  atomic_fetch_add(a7 + 2, 1u);
  v57[1] = a7;
  uint64_t v284 = v57;
  long long v18 = v255;
LABEL_58:
  IOSurfaceGetProtectionOptions();
  if ((IOSurfaceSupportsProtectionOptions() & 1) == 0)
  {
    if (x_log_hook_p())
    {
      IOSurfaceGetProtectionOptions();
      IOSurfaceGetProtectionOptions();
      x_log_();
    }
    else
    {
      unint64_t v69 = x_log_category_windowserver;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
      {
        uint64_t ProtectionOptions = IOSurfaceGetProtectionOptions();
        uint64_t v71 = IOSurfaceGetProtectionOptions();
        LODWORD(keys[0]) = 134218240;
        *(void *)((char *)keys + 4) = ProtectionOptions;
        WORD2(keys[1]) = 2048;
        *(void *)((char *)&keys[1] + 6) = v71;
        _os_log_impl(&dword_184668000, v69, OS_LOG_TYPE_ERROR, "protection mismatch src: 0x%llx  dst: 0x%llx", (uint8_t *)keys, 0x16u);
      }
    }
    goto LABEL_69;
  }
  if (v270) {
    CA::WindowServer::dict_shared_event_set_value(theDict, v270, (CA::WindowServer::SharedEvent *)1, 1);
  }
  if (v264) {
    CA::WindowServer::dict_shared_event_set_value(theDict, v264, (CA::WindowServer::SharedEvent *)1, 0);
  }
  long long v316 = 0u;
  long long v317 = 0u;
  *(_OWORD *)values = 0u;
  if (v274)
  {
    double v67 = *(double *)(v274 + 16);
    double v68 = *(double *)(v274 + 24);
  }
  else
  {
    double v67 = (double)IOSurfaceGetWidth(v54);
    double v68 = (double)IOSurfaceGetHeight(v54);
  }
  double v74 = v67 * (4095.0 * v68) / (float)(*(_DWORD *)(v16 + 180) * *(_DWORD *)(v16 + 176));
  unsigned int v75 = (int)(trunc(v74) * 0.25);
  if (theString) {
    uint64_t v76 = (int)v74;
  }
  else {
    uint64_t v76 = v75;
  }
  (*(void (**)(uint64_t, void, void, uint64_t, uint64_t))(*(void *)v16 + 384))(v16, 0, 0, v76, 4);
  if (v274 | (unint64_t)v259)
  {
    if (v259)
    {
      size_t v77 = (unint64_t)v259[2];
      size_t v78 = (unint64_t)v259[3];
      double v79 = *v259;
      double v80 = v259[1];
    }
    else
    {
      size_t v77 = IOSurfaceGetWidth(v18);
      size_t v78 = IOSurfaceGetHeight(v18);
      double v79 = 0.0;
      double v80 = 0.0;
    }
    OSType PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(v18);
    if ((int)PixelFormat > 645410930)
    {
      if (PixelFormat == 645410931 || PixelFormat == 645411443) {
        goto LABEL_93;
      }
      int v92 = 645411955;
    }
    else
    {
      if (PixelFormat == 645148787 || PixelFormat == 645149299) {
        goto LABEL_93;
      }
      int v92 = 645149811;
    }
    if (PixelFormat == v92)
    {
LABEL_93:
      double v93 = (double)((int)v79 % 6);
      double v94 = (double)((int)v80 % 6);
      double v79 = v79 - v93;
      double v80 = v80 - v94;
      size_t v77 = ((unint64_t)((double)v77 + v93) + 1) & 0xFFFFFFFFFFFFFFFELL;
      size_t v78 = ((unint64_t)(v94 + (double)v78) + 1) & 0xFFFFFFFFFFFFFFFELL;
LABEL_94:
      unint64_t v267 = v77;
      unint64_t v261 = v78;
      if (v274)
      {
        double v95 = *(double *)v274 - v93;
        double v96 = *(double *)(v274 + 8) - v94;
      }
      else
      {
        double v95 = -v93;
        double v96 = -v94;
      }
      int v81 = v54;
      LODWORD(v89) = v95;
      LODWORD(v90) = v96;
      signed int v87 = v67;
      signed int v88 = v68;
      values[0] = (void *)vcvtd_n_u64_f64(v79, 0x10uLL);
      values[1] = (void *)vcvtd_n_u64_f64(v80, 0x10uLL);
      *(void *)&long long v316 = v77 << 16;
      goto LABEL_98;
    }
    int v117 = CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0);
    double v93 = 0.0;
    if (v117 > 1885746227)
    {
      if ((v117 - 1886676528) <= 4 && ((1 << (v117 - 48)) & 0x15) != 0
        || (v117 - 1886680624) <= 4 && ((1 << (v117 - 48)) & 0x15) != 0)
      {
        goto LABEL_93;
      }
      unsigned __int16 v118 = 13364;
    }
    else
    {
      if (v117 <= 1882469427)
      {
        if (v117 == 1882468912) {
          goto LABEL_93;
        }
        int v119 = 1882468914;
        goto LABEL_168;
      }
      if (v117 == 1882469428 || v117 == 1885745712) {
        goto LABEL_93;
      }
      unsigned __int16 v118 = 12850;
    }
    int v119 = v118 | 0x70660000;
LABEL_168:
    if (v117 != v119)
    {
      double v94 = 0.0;
      goto LABEL_94;
    }
    goto LABEL_93;
  }
  int v81 = v54;
  if ((v55 & 0x8000) == 0)
  {
    float64x2_t v82 = 0;
    unint64_t v83 = v261;
    goto LABEL_99;
  }
  uint64_t v84 = *((unsigned int *)this + 14);
  uint64_t v85 = *((unsigned int *)this + 15);
  double v86 = (double)v84 / (double)v267;
  if (v86 >= (double)v85 / (double)v261) {
    double v86 = (double)v85 / (double)v261;
  }
  signed int v87 = vcvtmd_s64_f64(v86 * (double)v267 + 0.5);
  signed int v88 = vcvtmd_s64_f64(v86 * (double)v261 + 0.5);
  unint64_t v89 = (unint64_t)(v84 - v87) >> 1;
  unint64_t v90 = (unint64_t)(v85 - v88) >> 1;
  values[0] = 0;
  values[1] = 0;
  *(void *)&long long v316 = v267 << 16;
LABEL_98:
  unint64_t v83 = v261;
  *((void *)&v316 + 1) = v261 << 16;
  *(void *)&long long v317 = __PAIR64__(v90, v89);
  float64x2_t v82 = values;
  *((void *)&v317 + 1) = __PAIR64__(v88, v87);
LABEL_99:
  uint64_t v97 = 3758097090;
  if (!(*(unsigned int (**)(uint64_t, unint64_t, unint64_t, unint64_t, unint64_t, BOOL, void))(*(void *)v16 + 152))(v16, v267, v83, (unint64_t)v67, (unint64_t)v68, theString != 0, (v55 >> 2) & 1))
  {
LABEL_131:
    double v120 = v264;
LABEL_132:
    if (v270)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v121 = x_log_category_sharedevent;
        if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(keys[0]) = 0;
          _os_log_impl(&dword_184668000, v121, OS_LOG_TYPE_DEFAULT, "copy_iosurface error, ensure shared event signal is complete for source", (uint8_t *)keys, 2u);
        }
      }
      CA::WindowServer::SharedEvent::force_complete(v270, 0);
    }
    if (v120)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int v122 = x_log_category_sharedevent;
        if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(keys[0]) = 0;
          _os_log_impl(&dword_184668000, v122, OS_LOG_TYPE_DEFAULT, "copy_iosurface error, ensure shared event signal is complete for destination", (uint8_t *)keys, 2u);
        }
      }
      CA::WindowServer::SharedEvent::force_complete(v120, 0);
    }
    uint64_t v72 = 0;
    goto LABEL_145;
  }
  if ((v55 & 0x10000) == 0 || !v82) {
    goto LABEL_128;
  }
  long long v98 = v317;
  long long v99 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(void *)this + 160))(this);
  size_t v100 = IOSurfaceGetWidth(v99);
  size_t v101 = IOSurfaceGetHeight(v99);
  unint64_t v102 = v101;
  if (v101 * v100 < 0x7A120) {
    goto LABEL_112;
  }
  v103.i64[0] = DWORD2(v98);
  v103.i64[1] = HIDWORD(v98);
  _Q2 = vcvtq_f64_u64(v103);
  __asm { FMLS            D0, D2, V2.D[1] }
  if ((double)(v101 * v100) * 0.85 < trunc(_D0))
  {
LABEL_112:
    if (((*(uint64_t (**)(CA::WindowServer::IOSurface *, CA::WindowServer::Surface *, uint64_t, void))(*(void *)this + 168))(this, a2, v55, 0) & 1) == 0)
    {
      if (x_log_hook_p()) {
        goto LABEL_130;
      }
      uint64_t v126 = x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR)) {
        goto LABEL_131;
      }
      LODWORD(keys[0]) = 134218240;
      *(void *)((char *)keys + 4) = v100;
      WORD2(keys[1]) = 2048;
      *(void *)((char *)&keys[1] + 6) = v102;
      CGRect v127 = "Full clear failed IOSurface: %zux%zu";
      CGRect v128 = v126;
      uint32_t v129 = 22;
LABEL_179:
      _os_log_impl(&dword_184668000, v128, OS_LOG_TYPE_ERROR, v127, (uint8_t *)keys, v129);
      goto LABEL_131;
    }
    goto LABEL_128;
  }
  v109.i64[0] = v98;
  v109.i64[1] = DWORD1(v98);
  float64x2_t v110 = vcvtq_f64_u64(v109);
  long long v287 = 0u;
  long long v288 = 0u;
  *(float64x2_t *)theStringCGFloat a = _Q2;
  float64x2_t v275 = v110;
  if (v110.f64[0] > 0.0)
  {
    long long v287 = 0uLL;
    *(float64_t *)&long long v288 = v110.f64[0];
    *((double *)&v288 + 1) = (double)v101;
    char v111 = (*(uint64_t (**)(CA::WindowServer::IOSurface *, CA::WindowServer::Surface *, uint64_t, long long *))(*(void *)this + 168))(this, a2, v55, &v287);
    float64x2_t v110 = v275;
    _Q2 = *(float64x2_t *)theStringa;
    if ((v111 & 1) == 0)
    {
      if (x_log_hook_p()) {
        goto LABEL_130;
      }
      uint64_t v130 = x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR)) {
        goto LABEL_131;
      }
      LODWORD(keys[0]) = 134219264;
      *(void *)((char *)keys + 4) = v287;
      WORD2(keys[1]) = 2048;
      *(void *)((char *)&keys[1] + 6) = *((void *)&v287 + 1);
      HIWORD(keys[2]) = 2048;
      keys[3] = v288;
      LOWORD(keys[4]) = 2048;
      *(void *)((char *)&keys[4] + 2) = *((void *)&v288 + 1);
      WORD1(keys[5]) = 2048;
      *(void *)((char *)&keys[5] + 4) = v100;
      WORD2(keys[6]) = 2048;
      *(void *)((char *)&keys[6] + 6) = v102;
      CGRect v127 = "Left clear failed %f,%f %fx%f  IOSurface: %zux%zu";
      goto LABEL_178;
    }
  }
  double v112 = v110.f64[1];
  if (v110.f64[1] > 0.0)
  {
    long long v287 = *(unint64_t *)&v110.f64[0];
    *(float64_t *)&long long v288 = _Q2.f64[0];
    *((void *)&v288 + 1) = *(void *)&v110.f64[1];
    char v113 = (*(uint64_t (**)(CA::WindowServer::IOSurface *, CA::WindowServer::Surface *, uint64_t, long long *))(*(void *)this + 168))(this, a2, v55, &v287);
    float64x2_t v110 = v275;
    _Q2 = *(float64x2_t *)theStringa;
    if ((v113 & 1) == 0)
    {
      if (x_log_hook_p()) {
        goto LABEL_130;
      }
      uint64_t v130 = x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR)) {
        goto LABEL_131;
      }
      LODWORD(keys[0]) = 134219264;
      *(void *)((char *)keys + 4) = v287;
      WORD2(keys[1]) = 2048;
      *(void *)((char *)&keys[1] + 6) = *((void *)&v287 + 1);
      HIWORD(keys[2]) = 2048;
      keys[3] = v288;
      LOWORD(keys[4]) = 2048;
      *(void *)((char *)&keys[4] + 2) = *((void *)&v288 + 1);
      WORD1(keys[5]) = 2048;
      *(void *)((char *)&keys[5] + 4) = v100;
      WORD2(keys[6]) = 2048;
      *(void *)((char *)&keys[6] + 6) = v102;
      CGRect v127 = "Top clear failed %f,%f %fx%f  IOSurface: %zux%zu";
      goto LABEL_178;
    }
  }
  double v114 = vaddq_f64(_Q2, v110).f64[0];
  if (v114 >= (double)v100)
  {
    double v115 = (double)v102;
  }
  else
  {
    long long v287 = *(unint64_t *)&v114;
    double v115 = (double)v102;
    *(double *)&long long v288 = (double)v100 - v114;
    *((double *)&v288 + 1) = (double)v102;
    char v116 = (*(uint64_t (**)(CA::WindowServer::IOSurface *, CA::WindowServer::Surface *, uint64_t, long long *))(*(void *)this + 168))(this, a2, v55, &v287);
    v110.f64[0] = v275.f64[0];
    _Q2 = *(float64x2_t *)theStringa;
    if ((v116 & 1) == 0)
    {
      if (x_log_hook_p())
      {
LABEL_130:
        x_log_();
        goto LABEL_131;
      }
      uint64_t v130 = x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR)) {
        goto LABEL_131;
      }
      LODWORD(keys[0]) = 134219264;
      *(void *)((char *)keys + 4) = v287;
      WORD2(keys[1]) = 2048;
      *(void *)((char *)&keys[1] + 6) = *((void *)&v287 + 1);
      HIWORD(keys[2]) = 2048;
      keys[3] = v288;
      LOWORD(keys[4]) = 2048;
      *(void *)((char *)&keys[4] + 2) = *((void *)&v288 + 1);
      WORD1(keys[5]) = 2048;
      *(void *)((char *)&keys[5] + 4) = v100;
      WORD2(keys[6]) = 2048;
      *(void *)((char *)&keys[6] + 6) = v102;
      CGRect v127 = "Right clear failed %f,%f %fx%f  IOSurface: %zux%zu";
      goto LABEL_178;
    }
  }
  if (_Q2.f64[1] + v112 < v115)
  {
    *(float64_t *)&long long v287 = v110.f64[0];
    *((double *)&v287 + 1) = _Q2.f64[1] + v112;
    *(float64_t *)&long long v288 = _Q2.f64[0];
    *((double *)&v288 + 1) = v115 - (_Q2.f64[1] + v112);
    if (((*(uint64_t (**)(CA::WindowServer::IOSurface *, CA::WindowServer::Surface *, uint64_t, long long *))(*(void *)this + 168))(this, a2, v55, &v287) & 1) == 0)
    {
      if (x_log_hook_p()) {
        goto LABEL_130;
      }
      uint64_t v130 = x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR)) {
        goto LABEL_131;
      }
      LODWORD(keys[0]) = 134219264;
      *(void *)((char *)keys + 4) = v287;
      WORD2(keys[1]) = 2048;
      *(void *)((char *)&keys[1] + 6) = *((void *)&v287 + 1);
      HIWORD(keys[2]) = 2048;
      keys[3] = v288;
      LOWORD(keys[4]) = 2048;
      *(void *)((char *)&keys[4] + 2) = *((void *)&v288 + 1);
      WORD1(keys[5]) = 2048;
      *(void *)((char *)&keys[5] + 4) = v100;
      WORD2(keys[6]) = 2048;
      *(void *)((char *)&keys[6] + 6) = v102;
      CGRect v127 = "Bottom clear failed %f,%f %fx%f  IOSurface: %zux%zud";
LABEL_178:
      CGRect v128 = v130;
      uint32_t v129 = 62;
      goto LABEL_179;
    }
  }
LABEL_128:
  uint64_t v97 = IOSurfaceAcceleratorTransformSurface();
  if (v97)
  {
    if (!x_log_hook_p())
    {
      unint64_t v125 = x_log_category_windowserver;
      double v120 = v264;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
      {
        LODWORD(keys[0]) = 67109120;
        HIDWORD(keys[0]) = v97;
        _os_log_impl(&dword_184668000, v125, OS_LOG_TYPE_ERROR, "IOSurfaceAcceleratorTransformSurface returned: 0x%x", (uint8_t *)keys, 8u);
      }
      goto LABEL_132;
    }
    goto LABEL_130;
  }
  uint64_t v72 = 1;
  if (!v252) {
LABEL_145:
  }
    ((void (*)(uint64_t, uint64_t, void *))CA::WindowServer::msr_transfer_complete)(v283, v97, v284);
  if (byte_1EB2ACC2D)
  {
    int v276 = v97;
    CGRect v132 = v18;
    theStringCGFloat b = CFCopyDescription(theDict);
    BOOL v133 = x_log_hook_p();
    if (v259)
    {
      if (v133)
      {
        OSType v134 = IOSurfaceGetPixelFormat(v18);
        unsigned int v135 = HIBYTE(v134);
        if ((v134 & 0x80000000) != 0) {
          int v136 = __maskrune(v135, 0x40000uLL);
        }
        else {
          int v136 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v135 + 60) & 0x40000;
        }
        if (v136) {
          IOSurfaceGetPixelFormat(v18);
        }
        unsigned int v160 = (IOSurfaceGetPixelFormat(v18) >> 16);
        if (v160 <= 0x7F) {
          int v161 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v160 + 60) & 0x40000;
        }
        else {
          int v161 = __maskrune(v160, 0x40000uLL);
        }
        if (v161) {
          IOSurfaceGetPixelFormat(v18);
        }
        unsigned int v162 = ((unsigned __int16)IOSurfaceGetPixelFormat(v18) >> 8);
        if (v162 <= 0x7F) {
          int v163 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v162 + 60) & 0x40000;
        }
        else {
          int v163 = __maskrune(v162, 0x40000uLL);
        }
        if (v163) {
          IOSurfaceGetPixelFormat(v18);
        }
        unsigned int v164 = IOSurfaceGetPixelFormat(v18);
        if (v164 <= 0x7F) {
          int v165 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v164 + 60) & 0x40000;
        }
        else {
          int v165 = __maskrune(v164, 0x40000uLL);
        }
        if (v165) {
          IOSurfaceGetPixelFormat(v18);
        }
        IOSurfaceGetWidth(v18);
        IOSurfaceGetHeight(v18);
        IOSurfaceGetID(v18);
        OSType v166 = IOSurfaceGetPixelFormat(v81);
        unsigned int v167 = HIBYTE(v166);
        if ((v166 & 0x80000000) != 0) {
          int v168 = __maskrune(v167, 0x40000uLL);
        }
        else {
          int v168 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v167 + 60) & 0x40000;
        }
        if (v168) {
          IOSurfaceGetPixelFormat(v81);
        }
        unsigned int v169 = (IOSurfaceGetPixelFormat(v81) >> 16);
        if (v169 <= 0x7F) {
          int v170 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v169 + 60) & 0x40000;
        }
        else {
          int v170 = __maskrune(v169, 0x40000uLL);
        }
        if (v170) {
          IOSurfaceGetPixelFormat(v81);
        }
        unsigned int v171 = ((unsigned __int16)IOSurfaceGetPixelFormat(v81) >> 8);
        if (v171 <= 0x7F) {
          int v172 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v171 + 60) & 0x40000;
        }
        else {
          int v172 = __maskrune(v171, 0x40000uLL);
        }
        if (v172) {
          IOSurfaceGetPixelFormat(v81);
        }
        unsigned int v173 = IOSurfaceGetPixelFormat(v81);
        if (v173 <= 0x7F) {
          int v174 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v173 + 60) & 0x40000;
        }
        else {
          int v174 = __maskrune(v173, 0x40000uLL);
        }
        if (!v174) {
          goto LABEL_282;
        }
        goto LABEL_281;
      }
      theDictCGFloat a = (CFDictionaryRef)x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_378;
      }
      float32x4_t v150 = "failed with";
      if (v72) {
        float32x4_t v150 = "copied";
      }
      uint64_t v271 = (CA::WindowServer::SharedEvent *)v150;
      OSType v151 = IOSurfaceGetPixelFormat(v18);
      unsigned int v152 = HIBYTE(v151);
      if ((v151 & 0x80000000) != 0) {
        int v153 = __maskrune(v152, 0x40000uLL);
      }
      else {
        int v153 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v152 + 60) & 0x40000;
      }
      if (v153) {
        int v190 = (int)IOSurfaceGetPixelFormat(v18) >> 24;
      }
      else {
        int v190 = 32;
      }
      int v256 = v190;
      unsigned int v191 = (IOSurfaceGetPixelFormat(v18) >> 16);
      if (v191 <= 0x7F) {
        int v192 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v191 + 60) & 0x40000;
      }
      else {
        int v192 = __maskrune(v191, 0x40000uLL);
      }
      if (v192) {
        int v193 = (int)(IOSurfaceGetPixelFormat(v18) << 8) >> 24;
      }
      else {
        int v193 = 32;
      }
      int v253 = v193;
      unsigned int v194 = ((unsigned __int16)IOSurfaceGetPixelFormat(v18) >> 8);
      if (v194 <= 0x7F) {
        int v195 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v194 + 60) & 0x40000;
      }
      else {
        int v195 = __maskrune(v194, 0x40000uLL);
      }
      if (v195) {
        int v196 = (__int16)IOSurfaceGetPixelFormat(v18) >> 8;
      }
      else {
        int v196 = 32;
      }
      int v251 = v196;
      unsigned int v197 = IOSurfaceGetPixelFormat(v18);
      if (v197 <= 0x7F) {
        int v198 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v197 + 60) & 0x40000;
      }
      else {
        int v198 = __maskrune(v197, 0x40000uLL);
      }
      if (v198) {
        int v199 = (char)IOSurfaceGetPixelFormat(v18);
      }
      else {
        int v199 = 32;
      }
      int v250 = v199;
      size_t v268 = IOSurfaceGetWidth(v18);
      int v265 = (__CFDictionary *)IOSurfaceGetHeight(v18);
      IOSurfaceID v262 = IOSurfaceGetID(v18);
      OSType v200 = IOSurfaceGetPixelFormat(v81);
      unsigned int v201 = HIBYTE(v200);
      if ((v200 & 0x80000000) != 0) {
        int v202 = __maskrune(v201, 0x40000uLL);
      }
      else {
        int v202 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v201 + 60) & 0x40000;
      }
      if (v202) {
        int v203 = (int)IOSurfaceGetPixelFormat(v81) >> 24;
      }
      else {
        int v203 = 32;
      }
      int v249 = v203;
      unsigned int v204 = (IOSurfaceGetPixelFormat(v81) >> 16);
      if (v204 <= 0x7F) {
        int v205 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v204 + 60) & 0x40000;
      }
      else {
        int v205 = __maskrune(v204, 0x40000uLL);
      }
      if (v205) {
        int v206 = (int)(IOSurfaceGetPixelFormat(v81) << 8) >> 24;
      }
      else {
        int v206 = 32;
      }
      int v248 = v206;
      unsigned int v207 = ((unsigned __int16)IOSurfaceGetPixelFormat(v81) >> 8);
      if (v207 <= 0x7F) {
        int v208 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v207 + 60) & 0x40000;
      }
      else {
        int v208 = __maskrune(v207, 0x40000uLL);
      }
      if (v208) {
        int v209 = (__int16)IOSurfaceGetPixelFormat(v81) >> 8;
      }
      else {
        int v209 = 32;
      }
      unsigned int v210 = IOSurfaceGetPixelFormat(v81);
      if (v210 <= 0x7F) {
        int v211 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v210 + 60) & 0x40000;
      }
      else {
        int v211 = __maskrune(v210, 0x40000uLL);
      }
      if (v211) {
        int v212 = (char)IOSurfaceGetPixelFormat(v81);
      }
      else {
        int v212 = 32;
      }
      IOSurfaceID v213 = IOSurfaceGetID(v81);
      double v214 = *v259;
      uint64_t v215 = *((void *)v259 + 1);
      uint64_t v216 = *((void *)v259 + 2);
      uint64_t v217 = *((void *)v259 + 3);
      CStringPtr = CFStringGetCStringPtr(theStringb, 0x8000100u);
      LODWORD(keys[0]) = 136320514;
      *(void *)((char *)keys + 4) = v271;
      WORD2(keys[1]) = 1024;
      *(_DWORD *)((char *)&keys[1] + 6) = v276;
      WORD1(keys[2]) = 1024;
      HIDWORD(keys[2]) = v256;
      LOWORD(keys[3]) = 1024;
      *(_DWORD *)((char *)&keys[3] + 2) = v253;
      HIWORD(keys[3]) = 1024;
      LODWORD(keys[4]) = v251;
      WORD2(keys[4]) = 1024;
      *(_DWORD *)((char *)&keys[4] + 6) = v250;
      WORD1(keys[5]) = 2048;
      *(void *)((char *)&keys[5] + 4) = v268;
      WORD2(keys[6]) = 2048;
      *(void *)((char *)&keys[6] + 6) = v265;
      HIWORD(keys[7]) = 1024;
      IOSurfaceID v290 = v262;
      __int16 v291 = 1024;
      int v292 = v249;
      __int16 v293 = 1024;
      int v294 = v248;
      __int16 v295 = 1024;
      int v296 = v209;
      __int16 v297 = 1024;
      int v298 = v212;
      __int16 v299 = 2048;
      double v300 = v67;
      __int16 v301 = 2048;
      double v302 = v68;
      __int16 v303 = 1024;
      IOSurfaceID v304 = v213;
      __int16 v305 = 2048;
      *(double *)uint64_t v306 = v214;
      *(_WORD *)&v306[8] = 2048;
      *(void *)&v306[10] = v215;
      __int16 v307 = 2048;
      uint64_t v308 = v216;
      __int16 v309 = 2048;
      uint64_t v310 = v217;
      __int16 v311 = 1024;
      int v312 = v273;
      __int16 v313 = 2080;
      uint64_t v314 = CStringPtr;
      int v219 = "%s 0x%x src: %c%c%c%c [%zu x %zu] 0x%x dst: %c%c%c%c [%f x %f] 0x%x, subrect: (%f, %f, %f, %f), copy_flags: 0x%x, dict %s";
      int v220 = theDicta;
      uint32_t v221 = 174;
    }
    else
    {
      if (v133)
      {
        OSType v147 = IOSurfaceGetPixelFormat(v18);
        unsigned int v148 = HIBYTE(v147);
        if ((v147 & 0x80000000) != 0) {
          int v149 = __maskrune(v148, 0x40000uLL);
        }
        else {
          int v149 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v148 + 60) & 0x40000;
        }
        if (v149) {
          IOSurfaceGetPixelFormat(v18);
        }
        unsigned int v175 = (IOSurfaceGetPixelFormat(v18) >> 16);
        if (v175 <= 0x7F) {
          int v176 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v175 + 60) & 0x40000;
        }
        else {
          int v176 = __maskrune(v175, 0x40000uLL);
        }
        if (v176) {
          IOSurfaceGetPixelFormat(v18);
        }
        unsigned int v177 = ((unsigned __int16)IOSurfaceGetPixelFormat(v18) >> 8);
        if (v177 <= 0x7F) {
          int v178 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v177 + 60) & 0x40000;
        }
        else {
          int v178 = __maskrune(v177, 0x40000uLL);
        }
        if (v178) {
          IOSurfaceGetPixelFormat(v18);
        }
        unsigned int v179 = IOSurfaceGetPixelFormat(v18);
        if (v179 <= 0x7F) {
          int v180 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v179 + 60) & 0x40000;
        }
        else {
          int v180 = __maskrune(v179, 0x40000uLL);
        }
        if (v180) {
          IOSurfaceGetPixelFormat(v18);
        }
        IOSurfaceGetWidth(v18);
        IOSurfaceGetHeight(v18);
        IOSurfaceGetID(v18);
        OSType v181 = IOSurfaceGetPixelFormat(v81);
        unsigned int v182 = HIBYTE(v181);
        if ((v181 & 0x80000000) != 0) {
          int v183 = __maskrune(v182, 0x40000uLL);
        }
        else {
          int v183 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v182 + 60) & 0x40000;
        }
        if (v183) {
          IOSurfaceGetPixelFormat(v81);
        }
        unsigned int v184 = (IOSurfaceGetPixelFormat(v81) >> 16);
        if (v184 <= 0x7F) {
          int v185 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v184 + 60) & 0x40000;
        }
        else {
          int v185 = __maskrune(v184, 0x40000uLL);
        }
        if (v185) {
          IOSurfaceGetPixelFormat(v81);
        }
        unsigned int v186 = ((unsigned __int16)IOSurfaceGetPixelFormat(v81) >> 8);
        if (v186 <= 0x7F) {
          int v187 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v186 + 60) & 0x40000;
        }
        else {
          int v187 = __maskrune(v186, 0x40000uLL);
        }
        if (v187) {
          IOSurfaceGetPixelFormat(v81);
        }
        unsigned int v188 = IOSurfaceGetPixelFormat(v81);
        if (v188 <= 0x7F) {
          int v189 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v188 + 60) & 0x40000;
        }
        else {
          int v189 = __maskrune(v188, 0x40000uLL);
        }
        if (!v189) {
          goto LABEL_282;
        }
LABEL_281:
        IOSurfaceGetPixelFormat(v81);
LABEL_282:
        IOSurfaceGetID(v81);
        CFStringGetCStringPtr(theStringb, 0x8000100u);
        x_log_();
        goto LABEL_378;
      }
      uint64_t v154 = x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_378;
      }
      uint64_t v155 = "failed with";
      if (v72) {
        uint64_t v155 = "copied";
      }
      theDictCGFloat b = (CFDictionaryRef)v155;
      OSType v156 = IOSurfaceGetPixelFormat(v18);
      unsigned int v157 = HIBYTE(v156);
      uint64_t v158 = MEMORY[0x1E4F14390];
      if ((v156 & 0x80000000) != 0) {
        int v159 = __maskrune(v157, 0x40000uLL);
      }
      else {
        int v159 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v157 + 60) & 0x40000;
      }
      if (v159) {
        int v222 = (int)IOSurfaceGetPixelFormat(v18) >> 24;
      }
      else {
        int v222 = 32;
      }
      int v266 = v222;
      unsigned int v223 = (IOSurfaceGetPixelFormat(v18) >> 16);
      if (v223 <= 0x7F) {
        int v224 = *(_DWORD *)(v158 + 4 * v223 + 60) & 0x40000;
      }
      else {
        int v224 = __maskrune(v223, 0x40000uLL);
      }
      if (v224) {
        int v225 = (int)(IOSurfaceGetPixelFormat(v18) << 8) >> 24;
      }
      else {
        int v225 = 32;
      }
      int v263 = v225;
      unsigned int v226 = ((unsigned __int16)IOSurfaceGetPixelFormat(v18) >> 8);
      if (v226 <= 0x7F) {
        int v227 = *(_DWORD *)(v158 + 4 * v226 + 60) & 0x40000;
      }
      else {
        int v227 = __maskrune(v226, 0x40000uLL);
      }
      if (v227) {
        int v228 = (__int16)IOSurfaceGetPixelFormat(v18) >> 8;
      }
      else {
        int v228 = 32;
      }
      int v260 = v228;
      unsigned int v229 = IOSurfaceGetPixelFormat(v18);
      if (v229 <= 0x7F) {
        int v230 = *(_DWORD *)(v158 + 4 * v229 + 60) & 0x40000;
      }
      else {
        int v230 = __maskrune(v229, 0x40000uLL);
      }
      if (v230) {
        int v231 = (char)IOSurfaceGetPixelFormat(v18);
      }
      else {
        int v231 = 32;
      }
      int v257 = v231;
      uint64_t v272 = (CA::WindowServer::SharedEvent *)IOSurfaceGetWidth(v18);
      size_t v269 = IOSurfaceGetHeight(v18);
      IOSurfaceID v232 = IOSurfaceGetID(v18);
      OSType v233 = IOSurfaceGetPixelFormat(v81);
      unsigned int v234 = HIBYTE(v233);
      if ((v233 & 0x80000000) != 0) {
        int v235 = __maskrune(v234, 0x40000uLL);
      }
      else {
        int v235 = *(_DWORD *)(v158 + 4 * v234 + 60) & 0x40000;
      }
      if (v235) {
        int v236 = (int)IOSurfaceGetPixelFormat(v81) >> 24;
      }
      else {
        int v236 = 32;
      }
      unsigned int v237 = (IOSurfaceGetPixelFormat(v81) >> 16);
      if (v237 <= 0x7F) {
        int v238 = *(_DWORD *)(v158 + 4 * v237 + 60) & 0x40000;
      }
      else {
        int v238 = __maskrune(v237, 0x40000uLL);
      }
      if (v238) {
        int v239 = (int)(IOSurfaceGetPixelFormat(v81) << 8) >> 24;
      }
      else {
        int v239 = 32;
      }
      unsigned int v240 = ((unsigned __int16)IOSurfaceGetPixelFormat(v81) >> 8);
      if (v240 <= 0x7F) {
        int v241 = *(_DWORD *)(v158 + 4 * v240 + 60) & 0x40000;
      }
      else {
        int v241 = __maskrune(v240, 0x40000uLL);
      }
      if (v241) {
        int v242 = (__int16)IOSurfaceGetPixelFormat(v81) >> 8;
      }
      else {
        int v242 = 32;
      }
      unsigned int v243 = IOSurfaceGetPixelFormat(v81);
      if (v243 <= 0x7F) {
        int v244 = *(_DWORD *)(v158 + 4 * v243 + 60) & 0x40000;
      }
      else {
        int v244 = __maskrune(v243, 0x40000uLL);
      }
      if (v244) {
        int v245 = (char)IOSurfaceGetPixelFormat(v81);
      }
      else {
        int v245 = 32;
      }
      IOSurfaceID v246 = IOSurfaceGetID(v81);
      uint64_t v247 = CFStringGetCStringPtr(theStringb, 0x8000100u);
      LODWORD(keys[0]) = 136319490;
      *(void *)((char *)keys + 4) = theDictb;
      WORD2(keys[1]) = 1024;
      *(_DWORD *)((char *)&keys[1] + 6) = v276;
      WORD1(keys[2]) = 1024;
      HIDWORD(keys[2]) = v266;
      LOWORD(keys[3]) = 1024;
      *(_DWORD *)((char *)&keys[3] + 2) = v263;
      HIWORD(keys[3]) = 1024;
      LODWORD(keys[4]) = v260;
      WORD2(keys[4]) = 1024;
      *(_DWORD *)((char *)&keys[4] + 6) = v257;
      WORD1(keys[5]) = 2048;
      *(void *)((char *)&keys[5] + 4) = v272;
      WORD2(keys[6]) = 2048;
      *(void *)((char *)&keys[6] + 6) = v269;
      HIWORD(keys[7]) = 1024;
      IOSurfaceID v290 = v232;
      __int16 v291 = 1024;
      int v292 = v236;
      __int16 v293 = 1024;
      int v294 = v239;
      __int16 v295 = 1024;
      int v296 = v242;
      __int16 v297 = 1024;
      int v298 = v245;
      __int16 v299 = 2048;
      double v300 = v67;
      __int16 v301 = 2048;
      double v302 = v68;
      __int16 v303 = 1024;
      IOSurfaceID v304 = v246;
      __int16 v305 = 1024;
      *(_DWORD *)uint64_t v306 = v273;
      *(_WORD *)&v306[4] = 2080;
      *(void *)&v306[6] = v247;
      int v219 = "%s 0x%x src: %c%c%c%c [%zu x %zu] 0x%x dst: %c%c%c%c [%f x %f] 0x%x, copy_flags: 0x%x, dict %s";
      int v220 = v154;
      uint32_t v221 = 134;
    }
    _os_log_impl(&dword_184668000, v220, OS_LOG_TYPE_DEFAULT, v219, (uint8_t *)keys, v221);
LABEL_378:
    long long v18 = v132;
    if (theStringb) {
      CFRelease(theStringb);
    }
  }
  if (v258)
  {
    int v123 = CAIOSurfaceWriteToFileWithSuffix(v18, "msr-src");
    free(v123);
    uint64_t v124 = CAIOSurfaceWriteToFileWithSuffix(v81, "msr-dst");
    if (v124)
    {
      if (*(float *)&dword_1EB2ACAB0 > 0.0) {
        *(float *)&dword_1EB2ACAB0 = *(float *)&dword_1EB2ACAB0 + -1.0;
      }
      free(v124);
    }
  }
  return v72;
}

void CA::WindowServer::dict_shared_event_set_value(CA::WindowServer *this, __CFDictionary *a2, CA::WindowServer::SharedEvent *a3, int a4)
{
  int v4 = (int)a3;
  uint64_t v7 = (const void **)MEMORY[0x1E4F6ECF0];
  if (a4)
  {
    int v8 = 4;
  }
  else
  {
    uint64_t v7 = (const void **)MEMORY[0x1E4F6ECD8];
    int v8 = 5;
  }
  if (a4) {
    int v9 = 1;
  }
  else {
    int v9 = 2;
  }
  if (a4) {
    uint64_t v10 = (const void **)MEMORY[0x1E4F6ED00];
  }
  else {
    uint64_t v10 = (const void **)MEMORY[0x1E4F6ECE8];
  }
  if (a4) {
    uint64_t v11 = (const void **)MEMORY[0x1E4F6ECF8];
  }
  else {
    uint64_t v11 = (const void **)MEMORY[0x1E4F6ECE0];
  }
  CA_CFDictionarySetLongLong(this, *v7, *((void *)a2 + 1));
  BOOL v12 = v4 == 0;
  BOOL v13 = *v10;
  if (v12) {
    int v8 = 3;
  }
  uint64_t wait_value = CA::WindowServer::SharedEvent::get_wait_value((uint64_t)a2, v8, v9);
  CA_CFDictionarySetLongLong(this, v13, wait_value);
  uint64_t v15 = *v11;
  uint64_t v16 = CA::WindowServer::SharedEvent::inc_signal_value((uint64_t)a2, v8, v9);

  CA_CFDictionarySetLongLong(this, v15, v16);
}

uint64_t CA::WindowServer::msr_transfer_complete(uint64_t this, void *a2, void **a3, void *a4)
{
  int v5 = (int)a2;
  if (this) {
    this = CA::IOSAManager::unref(this);
  }
  if (a3)
  {
    int64x2_t v6 = (atomic_uint *)a3[1];
    if (!v5) {
      (*(void (**)(void *, void, void **, void *))(*(void *)v6 + 24))(a3[1], *((void *)*a3 + 3), a3, a4);
    }
    if (*a3)
    {

      free(*a3);
    }
    this = MEMORY[0x185323DC0](a3, 0x20C40A4A59CD2, a3, a4);
    unsigned int add = atomic_fetch_add(v6 + 2, 0xFFFFFFFF);
    if (v6 && add == 1)
    {
      int v8 = *(uint64_t (**)(atomic_uint *))(*(void *)v6 + 8);
      return v8(v6);
    }
  }
  return this;
}

BOOL CA::WindowServer::IOSurface::clear_iosurface(CA::WindowServer::IOSurface *this, CA::WindowServer::Surface *a2, __int16 a3, CA::Rect *a4)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)a2 + 160))(a2);
  uint64_t v9 = *((void *)this + 1);
  if (v9) {
    BOOL v10 = v7 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10) {
    return 0;
  }
  uint64_t v11 = (__IOSurface *)v7;
  int v12 = a3 & 0x1000;
  BOOL v13 = (__CFDictionary *)*((void *)this + 2);
  if (BYTE6(xmmword_1EB2ACC70))
  {
    if (x_log_hook_p())
    {
      uint64_t v37 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(void *)this + 160))(this);
      IOSurfaceGetID(v37);
      x_log_();
    }
    else
    {
      int32x2_t v38 = x_log_category_sharedevent;
      if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v39 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(void *)this + 160))(this);
        IOSurfaceID ID = IOSurfaceGetID(v39);
        uint64_t v41 = *((void *)this + 2);
        LODWORD(keys) = 67109376;
        HIDWORD(keys) = ID;
        LOWORD(v51) = 2048;
        *(void *)((char *)&v51 + 2) = v41;
        _os_log_impl(&dword_184668000, v38, OS_LOG_TYPE_DEBUG, "IOSurfaceID: 0x%x  clear_iosurface (DST) SharedEvent: %p", (uint8_t *)&keys, 0x12u);
      }
    }
  }
  uint64_t v14 = 0;
  if (v13) {
    int v15 = 192;
  }
  else {
    int v15 = 128;
  }
  while (*(_DWORD *)(v9 + v14 + 336) != v15)
  {
    v14 += 16;
    if (v14 == 64) {
      goto LABEL_13;
    }
  }
  CFDictionaryRef v16 = *(const __CFDictionary **)(v9 + v14 + 328);
  if (v16) {
    goto LABEL_23;
  }
LABEL_13:
  uint64_t v49 = 0;
  int v43 = 0;
  int valuePtr = 255;
  uint64_t v42 = 0;
  int v17 = (void *)*MEMORY[0x1E4F6ED80];
  uint64_t v53 = 0;
  keys = v17;
  values = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *(void *)&long long v51 = *MEMORY[0x1E4F6ED98];
  CFTypeRef cf = CFNumberCreate(0, kCFNumberIntType, &v43);
  *((void *)&v51 + 1) = *MEMORY[0x1E4F6ED90];
  CFTypeRef v47 = CFNumberCreate(0, kCFNumberIntType, (char *)&v42 + 4);
  uint64_t v52 = *MEMORY[0x1E4F6ED88];
  CFTypeRef v48 = CFNumberCreate(0, kCFNumberIntType, &v42);
  if (v12)
  {
    CFIndex v18 = 4;
  }
  else
  {
    uint64_t v53 = *MEMORY[0x1E4F6ECC0];
    uint64_t v49 = *MEMORY[0x1E4F1CFD0];
    CFIndex v18 = 5;
  }
  CFDictionaryRef v19 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, v18, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryRef v16 = v19;
  if (v13)
  {
    CFIndex Count = CFDictionaryGetCount(v19);
    MutableCopCGFloat y = CFDictionaryCreateMutableCopy(0, Count + 3, v16);
    CFRelease(v16);
    CFDictionaryRef v16 = MutableCopy;
  }
  uint64_t v22 = *(const void **)(v9 + 376);
  if (v22) {
    CFRelease(v22);
  }
  unsigned int v23 = (_OWORD *)(v9 + 376);
  for (unint64_t i = 4; i > 1; --i)
  {
    _OWORD *v23 = *(v23 - 1);
    --v23;
  }
  *(void *)(v9 + 328) = v16;
  *(_DWORD *)(v9 + 336) = v15;
  *(_DWORD *)(v9 + 340) = 0;
  CFRelease(values);
  CFRelease(cf);
  CFRelease(v47);
  CFRelease(v48);
LABEL_23:
  uint64_t v25 = CA::WindowServer::Display::copy_iosa_manager((CA::WindowServer::Display *)v9, v8);
  uint64_t v26 = *(void *)(v25 + 16);
  unint64_t v27 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(void *)this + 160))(this);
  if (!v26)
  {
    CA::IOSAManager::unref(v25);
    return 0;
  }
  uint64_t v28 = v27;
  if (a4)
  {
    double v29 = *((double *)a4 + 3);
    unsigned int Width = *((double *)a4 + 2);
    unsigned int Height = v29;
  }
  else
  {
    unsigned int Width = IOSurfaceGetWidth(v27);
    unsigned int Height = IOSurfaceGetHeight(v28);
  }
  if (IOSurfaceGetWidth(v11) < Width) {
    IOSurfaceGetWidth(v11);
  }
  if (IOSurfaceGetHeight(v11) < Height) {
    IOSurfaceGetHeight(v11);
  }
  if (v13) {
    CA::WindowServer::dict_shared_event_set_value(v16, v13, 0, 0);
  }
  int v34 = IOSurfaceAcceleratorBlitSurface();
  BOOL v32 = v34 == 0;
  if (v34)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      double v35 = x_log_category_windowserver;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
      {
        LODWORD(keys) = 67109120;
        HIDWORD(keys) = v34;
        _os_log_impl(&dword_184668000, v35, OS_LOG_TYPE_ERROR, "IOSurfaceAcceleratorBlitSurface returned: 0x%x", (uint8_t *)&keys, 8u);
      }
    }
    if (v13)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        double v36 = x_log_category_sharedevent;
        if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(keys) = 0;
          _os_log_impl(&dword_184668000, v36, OS_LOG_TYPE_DEFAULT, "clear_iosurface error, ensure shared event signal is complete for destination", (uint8_t *)&keys, 2u);
        }
      }
      CA::WindowServer::SharedEvent::force_complete(v13, 0);
    }
  }
  if (v25 && v34 | v12) {
    CA::IOSAManager::unref(v25);
  }
  return v32;
}

uint64_t CA::WindowServer::IOSurface::unlock(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 256) - 1;
  *(_DWORD *)(this + 256) = v1;
  if (!v1)
  {
    uint64_t v2 = this;
    IOSurfaceUnlock(*(IOSurfaceRef *)(this + 240), 0, 0);
    uint64_t v3 = *(void *)(v2 + 240);
    return MEMORY[0x1F40E9340](v3);
  }
  return this;
}

uint64_t CA::WindowServer::IOSurface::lock(CA::WindowServer::IOSurface *this, unsigned __int8 **a2, unint64_t *a3)
{
  int v6 = *((_DWORD *)this + 64);
  *((_DWORD *)this + 64) = v6 + 1;
  if (v6 || !IOSurfaceLock(*((IOSurfaceRef *)this + 30), 0, 0))
  {
    *a2 = (unsigned __int8 *)IOSurfaceGetBaseAddress(*((IOSurfaceRef *)this + 30));
    *a3 = IOSurfaceGetBytesPerRow(*((IOSurfaceRef *)this + 30));
    return 1;
  }
  else
  {
    uint64_t result = 0;
    --*((_DWORD *)this + 64);
  }
  return result;
}

void CA::WindowServer::IOSurface::copy_avd_histogram_info(IOSurfaceRef *this, const CA::WindowServer::Surface *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a2 && this[30] && (*(uint64_t (**)(const CA::WindowServer::Surface *))(*(void *)a2 + 160))(a2))
  {
    int v4 = (__IOSurface *)(*(uint64_t (**)(const CA::WindowServer::Surface *))(*(void *)a2 + 160))(a2);
    CFTypeRef v5 = IOSurfaceCopyValue(v4, @"kIOSurfacePixelMetadata");
    if (v5)
    {
      int v6 = v5;
      IOSurfaceSetValue(this[30], @"kIOSurfacePixelMetadata", v5);
      CFRelease(v6);
      return;
    }
    if (!x_log_hook_p())
    {
      uint64_t v7 = x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR)) {
        return;
      }
      __int16 v10 = 0;
      int v8 = "Failed to copy avd histogram info, missing histogram";
      uint64_t v9 = (uint8_t *)&v10;
LABEL_14:
      _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_ERROR, v8, v9, 2u);
      return;
    }
  }
  else if (!x_log_hook_p())
  {
    uint64_t v7 = x_log_category_windowserver;
    if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)uint64_t buf = 0;
    int v8 = "Failed to copy avd histogram info, invalid buffer";
    uint64_t v9 = buf;
    goto LABEL_14;
  }

  x_log_();
}

uint64_t CA::WindowServer::IOSurface::copy_hdr_static_metadata(uint64_t this, const CA::WindowServer::Surface *a2)
{
  if (a2)
  {
    if (*(void *)(this + 240))
    {
      this = (*(uint64_t (**)(const CA::WindowServer::Surface *))(*(void *)a2 + 160))(a2);
      if (this)
      {
        this = (*(uint64_t (**)(const CA::WindowServer::Surface *))(*(void *)a2 + 40))(a2);
        if (this == 16)
        {
          (*(void (**)(const CA::WindowServer::Surface *))(*(void *)a2 + 160))(a2);
          this = IOSurfaceGetBulkAttachments();
          if (!this) {
            return IOSurfaceSetBulkAttachments2();
          }
        }
      }
    }
  }
  return this;
}

uint64_t CA::WindowServer::IOSurface::is_linear(CA::WindowServer::IOSurface *this)
{
  return *((unsigned __int8 *)this + 288);
}

uint64_t CA::WindowServer::IOSurface::set_transfer_function(uint64_t this, int a2)
{
  if (a2) {
    int v2 = a2;
  }
  else {
    int v2 = 13;
  }
  if (*(_DWORD *)(this + 268) != v2)
  {
    uint64_t v3 = this;
    this = IOSurfaceSetBulkAttachments2();
    *(_DWORD *)(v3 + 268) = v2;
  }
  return this;
}

uint64_t CA::WindowServer::IOSurface::transfer_function(CA::WindowServer::IOSurface *this)
{
  uint64_t result = *((unsigned int *)this + 67);
  if (result == -1)
  {
    if (IOSurfaceGetBulkAttachments()) {
      uint64_t result = 0;
    }
    else {
      uint64_t result = 0;
    }
    *((_DWORD *)this + 67) = 0;
  }
  return result;
}

uint64_t CA::WindowServer::IOSurface::set_ycbcr_matrix(uint64_t this, int a2)
{
  if (*(_DWORD *)(this + 264) != a2)
  {
    *(_DWORD *)(this + 264) = a2;
    return IOSurfaceSetYCbCrMatrix();
  }
  return this;
}

uint64_t CA::WindowServer::IOSurface::ycbcr_matrix(CA::WindowServer::IOSurface *this)
{
  uint64_t result = *((unsigned int *)this + 66);
  if (result == -1)
  {
    uint64_t v3 = (unsigned int *)((char *)this + 264);
    if (IOSurfaceGetYCbCrMatrix())
    {
      uint64_t result = 0;
      *uint64_t v3 = 0;
    }
    else
    {
      return *v3;
    }
  }
  return result;
}

float *CA::WindowServer::IOSurface::allocate_iosurface(CA::WindowServer::IOSurface *a1, unsigned int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, unsigned int a8, uint64_t a9, const void *a10)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  (*(void (**)(long long *__return_ptr))(*(void *)a1 + 184))(&v28);
  v26[0] = v28;
  v26[1] = v29;
  uint64_t v27 = v30;
  CFIndex v18 = CA::SurfaceUtil::CAIOSurfaceCreate(a2, a3, a4, a7, 0, a8, a9, v26, a10);
  if (!v18) {
    return 0;
  }
  CFDictionaryRef v19 = v18;
  if (!BYTE9(xmmword_1EB2ACC10))
  {
    if (!a5) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  IOSurfaceGetID(v18);
  IOSurfaceGetProtectionOptions();
  IOSurfaceGetAllocSize(v19);
  kdebug_trace();
  if (a5) {
LABEL_4:
  }
    IOSurfaceSetYCbCrMatrix();
LABEL_5:
  double v20 = CA::WindowServer::IOSurface::wrap_buffer(a1, v19, 0, 1);
  uint64_t v21 = v20;
  if (v20)
  {
    uint64_t v22 = v20 + 56;
    *((_DWORD *)v20 + 56) |= 0x2000000u;
    (*(void (**)(float *, uint64_t))(*(void *)v20 + 32))(v20, a5);
    (*(void (**)(float *, uint64_t, void))(*(void *)v21 + 72))(v21, a6, 0);
    uint64_t v23 = (a8 << 22) & 0x1000000 | (((a8 >> 1) & 1) << 29) | (((a8 >> 5) & 1) << 28);
    unint64_t v24 = v23 | ((unint64_t)(a8 & 1) << 34) | (*((unsigned int *)v21 + 56) | ((unint64_t)*((unsigned __int8 *)v21 + 228) << 32)) & 0xFBCEFFFFFFLL;
    *uint64_t v22 = v23 | *v22 & 0xCEFFFFFF;
    *((unsigned char *)v21 + 228) = BYTE4(v24);
    if (a8) {
      IOSurfaceSetValue(v19, @"CAWindowServerSurface", (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
    }
    if (a10)
    {
      CFRetain(a10);
      *((void *)v21 + 29) = a10;
    }
    if (CADeviceUseSharedEvents() && *((void *)v21 + 1))
    {
      if (!*((void *)v21 + 2)) {
        operator new();
      }
      __assert_rtn("create_shared_event", "windowserver-surface.cpp", 594, "!_shared_event");
    }
  }
  else
  {
    CFRelease(v19);
  }
  return v21;
}

atomic_uint *CA::CAPSEProcessor::process_surface(CA::CAPSEProcessor *this, atomic_uint *a2, double a3, float a4, float a5)
{
  int v8 = a2;
  void v40[3] = *MEMORY[0x1E4F143B8];
  if ([*(id *)this canProcessSurface:*((void *)a2 + 14)])
  {
    __int16 v10 = 0;
    for (uint64_t i = 8; i != 32; i += 8)
    {
      uint64_t v12 = *(void *)((char *)this + i);
      if (v12)
      {
        if (v8[4] == *(_DWORD *)(v12 + 16)
          && v8[5] == *(_DWORD *)(v12 + 20)
          && (uint64_t v13 = (*(uint64_t (**)(atomic_uint *))(*(void *)v8 + 240))(v8),
              uint64_t v14 = (*(uint64_t (**)(void))(**(void **)((char *)this + i) + 240))(*(void *)((char *)this + i)),
              uint64_t v12 = *(void *)((char *)this + i),
              v13 == v14))
        {
          if (*(_DWORD *)(v12 + 8) == 1 && !IOSurfaceIsInUse(*(IOSurfaceRef *)(v12 + 112))) {
            __int16 v10 = *(void **)((char *)this + i);
          }
        }
        else
        {
          if (atomic_fetch_add((atomic_uint *volatile)(v12 + 8), 0xFFFFFFFF) == 1) {
            (*(void (**)(uint64_t))(*(void *)v12 + 16))(v12);
          }
          *(void *)((char *)this + i) = 0;
        }
      }
    }
    if (!v10)
    {
      unsigned int v15 = (MEMORY[0xFFFFFC020] >> 9) & 4;
      unsigned int v16 = v8[4];
      int v17 = v8[5];
      uint64_t v18 = (*(uint64_t (**)(atomic_uint *))(*(void *)v8 + 240))(v8);
      iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format((CA::Render *)0x52476841, v16, v17, v15, v18, @"CA PSE Surface", v19);
      if (!iosurface_with_pixel_format) {
        return 0;
      }
      uint64_t v21 = iosurface_with_pixel_format;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      uint64_t v23 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x158uLL, 0x743898A5uLL);
      __int16 v10 = v23;
      if (v23) {
        CA::Render::Surface::Surface((uint64_t)v23, v21, -1, 63, 0, 0, 0);
      }
      *((_DWORD *)v10 + 3) |= v8[3] & 0xFFFFFF00;
      CFRelease(v21);
      for (uint64_t j = 0; j != 3; ++j)
      {
        if (!*((void *)this + j + 1))
        {
          uint64_t j = j;
          goto LABEL_28;
        }
      }
      uint64_t v25 = (atomic_uint *)*((void *)this + 1);
      if (atomic_fetch_add(v25 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v25 + 16))(v25);
      }
      uint64_t j = 0;
LABEL_28:
      *((void *)this + j + 1) = v10;
    }
    if (!IOSurfaceGetBulkAttachments()) {
      IOSurfaceSetBulkAttachments2();
    }
    CFDictionaryRef v27 = IOSurfaceCopyAllValues(*((IOSurfaceRef *)v8 + 14));
    if (v27)
    {
      CFDictionaryRef v28 = v27;
      IOSurfaceSetValues(*((IOSurfaceRef *)v10 + 14), v27);
      CFRelease(v28);
      IOSurfaceSetValue(*((IOSurfaceRef *)v10 + 14), (CFStringRef)*MEMORY[0x1E4F2F128], @"CA PSE Surface");
    }
    if (a5 <= 1.0) {
      float v29 = 1.0;
    }
    else {
      float v29 = 1.0 / a5;
    }
    uint64_t v30 = *(void **)this;
    uint64_t v31 = *((void *)v8 + 14);
    uint64_t v32 = *((void *)v10 + 14);
    v39[0] = @"sourceSurfaceEDR";
    unsigned int v33 = NSNumber;
    (*(void (**)(atomic_uint *))(*(void *)v8 + 152))(v8);
    v40[0] = objc_msgSend(v33, "numberWithFloat:");
    v39[1] = @"displayMaxNits";
    *(float *)&double v34 = a4;
    v40[1] = [NSNumber numberWithFloat:v34];
    _OWORD v39[2] = @"displayEDRFactor";
    *(float *)&double v35 = v29;
    v40[2] = [NSNumber numberWithFloat:v35];
    objc_msgSend(v30, "processSourceSurface:withTimestamp:toDestinationSurface:options:", v31, v32, objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v40, v39, 3), a3);
    CA::Render::Surface::reload_iosurface_color_attributes((CA::Render::Surface *)v10, v36);
    if ((*(unsigned int (**)(atomic_uint *))(*(void *)v8 + 160))(v8)) {
      __int16 v37 = 16;
    }
    else {
      __int16 v37 = 0;
    }
    *((_WORD *)v10 + 168) = *((_WORD *)v10 + 168) & 0xFFEF | v37;
    if (!atomic_fetch_add((atomic_uint *volatile)v10 + 2, 1u)) {
      atomic_fetch_add((atomic_uint *volatile)v10 + 2, 0xFFFFFFFF);
    }
    return (atomic_uint *)v10;
  }
  else
  {
    uint64_t v26 = v8 + 2;
    if (!atomic_fetch_add(v8 + 2, 1u))
    {
      int v8 = 0;
      atomic_fetch_add(v26, 0xFFFFFFFF);
    }
  }
  return v8;
}

IOSurfaceRef CA::Render::FlattenManager::flattened_cache_retain_iosurface(CA::Render::FlattenManager *this)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (!this) {
    return 0;
  }
  unsigned int v1 = this;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::flattened_lock);
  if (CA::Render::flattened_cache && *(void *)(CA::Render::flattened_cache + 24))
  {
    int v2 = (IOSurfaceRef *)x_hash_table_lookup(CA::Render::flattened_cache, v1, 0);
    if (v2)
    {
      uint64_t v3 = v2;
      if (*v2)
      {
        if ((_BYTE)xmmword_1EB2ACC70)
        {
          if (x_log_hook_p())
          {
            IOSurfaceGetID(*v3);
            IOSurfaceGetWidth(*v3);
            IOSurfaceGetHeight(*v3);
            x_log_();
          }
          else
          {
            uint64_t v7 = x_log_category_flatten;
            if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
            {
              IOSurfaceID ID = IOSurfaceGetID(*v3);
              size_t Width = IOSurfaceGetWidth(*v3);
              size_t Height = IOSurfaceGetHeight(*v3);
              *(_DWORD *)uint64_t buf = 67109888;
              unsigned int v12 = v1;
              __int16 v13 = 1024;
              IOSurfaceID v14 = ID;
              __int16 v15 = 2048;
              size_t v16 = Width;
              __int16 v17 = 2048;
              size_t v18 = Height;
              _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_DEFAULT, "[%d] found cached surface <%d> <%zu %zu>", buf, 0x22u);
            }
          }
        }
        CFRetain(*v3);
        IOSurfaceRef v4 = *v3;
        goto LABEL_9;
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
    if ((_BYTE)xmmword_1EB2ACC70)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int v6 = x_log_category_flatten;
        if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 67109120;
          unsigned int v12 = v1;
          _os_log_impl(&dword_184668000, v6, OS_LOG_TYPE_DEFAULT, "[%d] no cached surface", buf, 8u);
        }
      }
    }
    return 0;
  }
  IOSurfaceRef v4 = 0;
LABEL_9:
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
  return v4;
}

uint64_t X::HashTable<unsigned int,CA::Render::FlattenedCacheEntry *>::foreach(std::function<void ()(unsigned int,CA::Render::FlattenedCacheEntry *)>)::{lambda(void *,void *,void *)#1}::__invoke(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  int v6 = a1;
  uint64_t v5 = a2;
  uint64_t v3 = *(void *)(a3 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:nn180100]();
  }
  return (*(uint64_t (**)(uint64_t, int *, uint64_t *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void std::__function::__func<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0,std::allocator<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0>,void ()(unsigned int,CA::Render::FlattenedCacheEntry *)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a3;
  if (*a3 && *(void *)v3)
  {
    bzero(v8, 0x400uLL);
    if (getuid()) {
      confstr(65537, v8, 0x400uLL);
    }
    else {
      strcpy(v8, "/tmp/");
    }
    bzero(__str, 0x400uLL);
    uint64_t v5 = *(void *)(v3 + 56);
    if (v5) {
      int v6 = (const char *)(v5 + 28);
    }
    else {
      int v6 = "";
    }
    snprintf(__str, 0x400uLL, "%sctx-%x_%s(%d).png", v8, *(_DWORD *)(v3 + 48), v6, **(_DWORD **)(a1 + 8));
    save_iosurface_as_png(*(__IOSurface **)v3, (uint64_t)__str, 1);
  }
}

uint64_t std::__function::__func<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0,std::allocator<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0>,void ()(unsigned int,CA::Render::FlattenedCacheEntry *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED030EA8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0,std::allocator<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0>,void ()(unsigned int,CA::Render::FlattenedCacheEntry *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1ED030EA8;
  result[1] = v3;
  return result;
}

void std::__function::__func<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0,std::allocator<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0>,void ()(unsigned int,CA::Render::FlattenedCacheEntry *)>::~__func()
{
}

void CA::CG::FillEllipse::draw_shape(CA::CG::FillEllipse *this, CA::CG::Renderer *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  int v3 = *((_DWORD *)this + 25);
  if (v3)
  {
    double v7 = *((double *)this + 14);
    double v6 = *((double *)this + 15);
    double v17 = v7;
    double v18 = v6;
    double v9 = *((double *)this + 16);
    double v8 = *((double *)this + 17);
    double v19 = v9;
    double v20 = v8;
    if (v9 < 0.0)
    {
      double v7 = v9 + v7;
      double v9 = -v9;
      double v17 = v7;
      double v19 = v9;
    }
    if (v8 < 0.0)
    {
      double v6 = v8 + v6;
      double v8 = -v8;
      double v18 = v6;
      double v20 = v8;
    }
    __int16 v10 = (float64x2_t *)((char *)a2 + 32);
    BOOL v11 = (v3 & 4) == 0;
    uint64_t v12 = 88;
    if (v11) {
      uint64_t v12 = 32;
    }
    else {
      __int16 v10 = (float64x2_t *)((char *)a2 + 88);
    }
    float64x2_t v13 = *(float64x2_t *)((char *)a2 + v12);
    float64x2_t v14 = v10[1];
    float64x2_t v15 = v10[2];
    if (v9 != v8)
    {
      float64x2_t v16 = vmlaq_n_f64(vmlaq_n_f64(v15, v13, v7), v14, v6);
      float64x2_t v14 = vmulq_n_f64(v14, v8 / v9);
      float64x2_t v15 = vmlsq_lane_f64(vmlsq_lane_f64(v16, v13, v7, 0), v14, v6, 0);
      double v20 = v9;
    }
    long long v23 = 0u;
    long long v24 = 0u;
    long long v22 = 0u;
    memset(v21, 0, sizeof(v21));
    uint64_t v25 = 0;
    CA::Transform::set_affine((CA::Transform *)v21, v13.f64[0], v13.f64[1], v14.f64[0], v14.f64[1], v15.f64[0], v15.f64[1]);
    *((void *)&v22 + 1) = &v17;
    *(void *)&long long v23 = v21;
    *((void *)&v23 + 1) = 0xFF0020003FLL;
    uint64_t v25 = 0;
    long long v24 = 0uLL;
    CA::OGL::fill_round_rect(*((void *)a2 + 1), (float64x2_t **)&v22 + 1, (double *)0xF, 0, v9 * 0.5, v9 * 0.5);
  }
  else
  {
    CGPathRef v4 = CA::CG::Renderer::retain_simple_path(a2, (const CGRect *)((char *)this + 112), 0);
    if (v4)
    {
      uint64_t v5 = v4;
      CA::CG::fill_path((uint64_t)a2);
      CGPathRelease(v5);
    }
  }
}

void *CA::CG::FillEllipse::styled_op(uint64_t a1, const double *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t result = malloc_type_zone_malloc(malloc_zone, 0xA0uLL, 0x8BB15036uLL);
  if (result)
  {
    uint64_t result = (void *)CA::CG::DrawPathShadow::DrawPathShadow(result, a2, a1, a4, a5, a3, *(_DWORD *)(a1 + 100) & 4 | 0x80u);
    void *result = &unk_1ED028F40;
  }
  return result;
}

CGPathRef CA::CG::FillEllipseShadow::retain_path(uint64_t a1, CA::CG::Renderer *this, CGPoint *a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 144);
  float64x2_t v4 = *(float64x2_t *)(v3 + 128);
  v6.origiuint64_t n = *(CGPoint *)(v3 + 112);
  *a3 = v6.origin;
  v6.origiuint64_t n = 0uLL;
  v6.CGSize size = (CGSize)vmulq_f64(vrndaq_f64(vmulq_f64(v4, (float64x2_t)vdupq_n_s64(0x40F0000000000000uLL))), (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL));
  return CA::CG::Renderer::retain_simple_path(this, &v6, 0);
}

void CA::CG::FillEllipseShadow::~FillEllipseShadow(CA::CG::FillEllipseShadow *this)
{
  *(void *)this = &unk_1ED027588;
  uint64_t v2 = (atomic_uint *)*((void *)this + 19);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  CA::CG::DrawOp::~DrawOp(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v2;
  uint64_t vars8;

  *(void *)this = &unk_1ED027588;
  uint64_t v2 = (atomic_uint *)*((void *)this + 19);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }

  CA::CG::DrawOp::~DrawOp(this);
}

uint64_t CA::CG::FillEllipse::compute_dod_corners(uint64_t a1, float64x2_t *a2)
{
  float64x2_t v2 = *(float64x2_t *)(a1 + 128);
  float64x2_t v3 = vaddq_f64(*(float64x2_t *)(a1 + 112), vminnmq_f64(v2, (float64x2_t)vdupq_n_s64(0x8000000000000000)));
  float64x2_t v4 = vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v2), (int8x16_t)vnegq_f64(v2), (int8x16_t)v2), v3);
  v5.f64[0] = v4.f64[0];
  v5.f64[1] = v3.f64[1];
  *a2 = v3;
  a2[1] = v5;
  v3.f64[1] = v4.f64[1];
  a2[2] = v4;
  a2[3] = v3;
  if ((*(unsigned char *)(a1 + 100) & 4) == 0)
  {
    uint64_t v6 = 0;
    uint64_t v7 = (const double *)(a1 + 48);
    double v8 = (const double *)(a1 + 8);
    double v9 = (const double *)(a1 + 32);
    __int16 v10 = (const double *)(a1 + 16);
    BOOL v11 = (const double *)(a1 + 40);
    uint64_t v12 = (const double *)(a1 + 24);
    float64x2_t v13 = vld1q_dup_f64(v8);
    float64x2_t v14 = vld1q_dup_f64(v12);
    float64x2_t v15 = vld1q_dup_f64(v11);
    float64x2_t v16 = vld1q_dup_f64(v10);
    float64x2_t v17 = vld1q_dup_f64(v9);
    float64x2_t v18 = vld1q_dup_f64(v7);
    do
    {
      f64 = a2[v6].f64;
      float64x2x2_t v21 = vld2q_f64(f64);
      v22.val[0] = vmlaq_f64(vmlaq_f64(v15, v21.val[0], v13), v21.val[1], v14);
      v22.val[1] = vmlaq_f64(vmlaq_f64(v18, v21.val[0], v16), v21.val[1], v17);
      vst2q_f64(f64, v22);
      v6 += 2;
    }
    while (v6 != 4);
  }
  return 1;
}

void CA::CG::FillEllipse::compute_dod(CA::CG::FillEllipse *this, float64x2_t *a2)
{
  CA::Rect::operator=(a2->f64, (double *)this + 14);
  if ((*((unsigned char *)this + 100) & 4) == 0)
  {
    CA::Rect::apply_transform(a2, (const CGAffineTransform *)((char *)this + 8));
  }
}

void CA::CG::FillEllipse::~FillEllipse(CA::CG::FillEllipse *this)
{
  CA::CG::DrawOp::~DrawOp(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::CG::StrokeEllipse::draw_shape(CA::CG::StrokeEllipse *this, CA::CG::Renderer *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 20)) {
    goto LABEL_6;
  }
  double v4 = *((double *)this + 16);
  double v5 = *((double *)this + 17);
  double v6 = v4 - v5;
  if (v4 - v5 < 0.0) {
    double v6 = v5 - v4;
  }
  if (v6 > 0.001
    || (int v7 = *((_DWORD *)this + 25),
        CA::CG::DrawOp::shape_line_width((uint64_t)this, (const double *)a2, *((double *)this + 18)),
        v8 < 0.0))
  {
LABEL_6:
    CA::CG::StrokeEllipse::draw_shape_as_path(this, a2);
  }
  else
  {
    double v9 = v8;
    if (v8 >= 0.001)
    {
      __int16 v10 = (double *)((char *)a2 + 32);
      uint64_t v11 = 88;
      if ((v7 & 4) != 0) {
        __int16 v10 = (double *)((char *)a2 + 88);
      }
      else {
        uint64_t v11 = 32;
      }
      double v12 = *((double *)this + 14);
      double v13 = *((double *)this + 15);
      double v19 = v12;
      double v20 = v13;
      double v21 = v4;
      double v22 = v5;
      if (v4 >= 0.0)
      {
        double v14 = v4;
      }
      else
      {
        double v12 = v4 + v12;
        double v14 = -v4;
        double v19 = v12;
        double v21 = -v4;
      }
      if (v5 < 0.0)
      {
        double v13 = v5 + v13;
        double v5 = -v5;
        double v20 = v13;
        double v22 = v5;
      }
      double v15 = v9 * 0.5;
      if (v14 <= v5) {
        double v16 = v5;
      }
      else {
        double v16 = v14;
      }
      if (v16 < 1.79769313e308)
      {
        double v19 = v12 - v15;
        double v20 = v13 - v15;
        double v21 = v14 + v9;
        double v22 = v5 + v9;
        if (v14 + v9 <= 0.0 || v5 + v9 <= 0.0)
        {
          double v21 = 0.0;
          double v22 = 0.0;
        }
      }
      uint64_t v27 = 0;
      float64_t v17 = v15 + v4 * 0.5;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v24 = 0u;
      double v18 = *(double *)((char *)a2 + v11);
      memset(v23, 0, sizeof(v23));
      CA::Transform::set_affine((CA::Transform *)v23, v18, v10[1], v10[2], v10[3], v10[4], v10[5]);
      *((void *)&v24 + 1) = &v19;
      *(void *)&long long v25 = v23;
      DWORD2(v25) = 2097215;
      HIDWORD(v25) = (v7 << 31 >> 31);
      uint64_t v27 = 0;
      long long v26 = 0uLL;
      CA::OGL::stroke_round_rect(*((void **)a2 + 1), (float64x2_t **)&v24 + 1, (double *)0xF, 0, v17, v9);
    }
  }
}

void CA::CG::StrokeEllipse::draw_shape_as_path(CA::CG::StrokeEllipse *this, CA::CG::Renderer *a2)
{
  CGPathRef v4 = CA::CG::Renderer::retain_simple_path(a2, (const CGRect *)((char *)this + 112), 0);
  if (v4)
  {
    double v5 = v4;
    CA::CG::stroke_path((uint64_t)a2, (uint64_t)v4, 0, (uint64_t)this + 8, (uint64_t)this + 144);
    CGPathRelease(v5);
  }
}

void *CA::CG::StrokeEllipse::styled_op(uint64_t a1, const double *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t result = malloc_type_zone_malloc(malloc_zone, 0xA0uLL, 0x8BB15036uLL);
  if (result)
  {
    uint64_t result = (void *)CA::CG::DrawPathShadow::DrawPathShadow(result, a2, a1, a4, a5, a3, *(_DWORD *)(a1 + 100) & 4 | 0x80u);
    void *result = &unk_1ED029408;
  }
  return result;
}

uint64_t CA::CG::StrokeEllipseShadow::retain_path(uint64_t a1, CA::CG::Renderer *this, CGPoint *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 144);
  float64x2_t v4 = *(float64x2_t *)(v3 + 128);
  v9.origiuint64_t n = *(CGPoint *)(v3 + 112);
  *a3 = v9.origin;
  v9.origiuint64_t n = 0uLL;
  v9.CGSize size = (CGSize)vmulq_f64(vrndaq_f64(vmulq_f64(v4, (float64x2_t)vdupq_n_s64(0x40F0000000000000uLL))), (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL));
  double v5 = CA::CG::Renderer::retain_simple_path(this, &v9, 0);
  if (!v5) {
    return 0;
  }
  double v6 = v5;
  stroked_CGPathRef path = CA::CG::create_stroked_path(v5, (_OWORD *)(v3 + 8), v3 + 144, (*(_DWORD *)(v3 + 100) & 4) != 0);
  CGPathRelease(v6);
  return stroked_path;
}

void CA::CG::StrokeEllipseShadow::~StrokeEllipseShadow(CA::CG::StrokeEllipseShadow *this)
{
  *(void *)this = &unk_1ED027588;
  float64x2_t v2 = (atomic_uint *)*((void *)this + 19);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  CA::CG::DrawOp::~DrawOp(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v2;
  uint64_t vars8;

  *(void *)this = &unk_1ED027588;
  float64x2_t v2 = (atomic_uint *)*((void *)this + 19);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }

  CA::CG::DrawOp::~DrawOp(this);
}

double *CA::CG::StrokeEllipse::compute_dod(CA::CG::StrokeEllipse *this, float64x2_t *a2)
{
  CA::Rect::operator=(a2->f64, (double *)this + 14);
  if ((*((unsigned char *)this + 100) & 4) == 0) {
    CA::Rect::apply_transform(a2, (const CGAffineTransform *)((char *)this + 8));
  }
  double v4 = -CA::CG::stroke_radius((uint64_t)this + 144, *(float64x2_t *)((char *)this + 8), *(float64x2_t *)((char *)this + 24));
  double v6 = -v5;

  return CA::BoundsImpl::inset_point(a2->f64, v4, v6);
}

void CA::CG::StrokeEllipse::~StrokeEllipse(CA::CG::StrokeEllipse *this)
{
  *(void *)this = &unk_1ED028328;
  if (*((void *)this + 20)) {
    CGDashRelease();
  }
  CA::CG::DrawOp::~DrawOp(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1ED028328;
  if (*((void *)this + 20)) {
    CGDashRelease();
  }

  CA::CG::DrawOp::~DrawOp(this);
}

uint64_t CA::OGL::ImagingNode::allow_in_place(CA::OGL::ImagingNode *this)
{
  return 0;
}

CA::OGL::ImagingNode *CA::OGL::ImagingNode::remove_feature_passthrough_aware(CA::OGL::ImagingNode *this, unsigned int a2)
{
  if ((*((_WORD *)this + 106) & 0x100) != 0
    || (uint64_t result = (CA::OGL::ImagingNode *)(*(uint64_t (**)(CA::OGL::ImagingNode *))(*(void *)this + 112))(this),
        result))
  {
    uint64_t result = (CA::OGL::ImagingNode *)*((void *)this + 3);
    if (result) {
      uint64_t result = (CA::OGL::ImagingNode *)CA::OGL::ImagingNode::remove_feature_passthrough_aware(result, a2);
    }
  }
  *((_DWORD *)this + 54) &= ~0x800u;
  return result;
}

float CA::OGL::MaskCorners::corner_contents_texcoord(CA::OGL::MaskCorners *this, unsigned int a2, const float *a3, float *a4)
{
  float v4 = 0.0;
  float v5 = 0.0;
  if ((a2 & 0xFFFFFFFD) != 0) {
    float v5 = *((double *)this + 28) + *((double *)this + 26);
  }
  *a4 = v5;
  if (a2 >= 2) {
    float v4 = *((double *)this + 29) + *((double *)this + 27);
  }
  a4[1] = v4;
  float v6 = 1.0;
  float v7 = 1.0;
  if ((a2 & 0xFFFFFFFD) == 0) {
    float v7 = *((double *)this + 26);
  }
  a4[2] = v7;
  if (a2 <= 1) {
    float v6 = *((double *)this + 27);
  }
  a4[3] = v6;
  *a4 = *a3 + (float)((float)(a3[2] - *a3) * v5);
  a4[1] = a3[1] + (float)((float)(a3[3] - a3[1]) * v4);
  a4[2] = *a3 + (float)((float)(a3[2] - *a3) * v7);
  float result = a3[1] + (float)((float)(a3[3] - a3[1]) * v6);
  a4[3] = result;
  return result;
}

uint64_t CA::OGL::ImagingNode::mesh_node_p(CA::OGL::ImagingNode *this)
{
  return 0;
}

uint64_t CA::OGL::CacheNode::apply(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 104))();
}

void CA::OGL::CacheNode::~CacheNode(CA::OGL::CacheNode *this)
{
}

uint64_t CA::OGL::FlattenNode::apply(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 104))();
}

uint64_t CA::OGL::FlattenNode::retain_surface(CA::OGL::FlattenNode *this, float *a2, uint64_t a3, __n128 a4)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  float v7 = (CA::OGL::Context **)*((void *)this + 1);
  double v8 = *v7;
  unsigned int v9 = *((_DWORD *)this + 34);
  if ((v9 & 0x80000000) != 0)
  {
    (*(void (**)(CA::OGL::FlattenNode *, char *))(*(void *)this + 40))(this, (char *)this + 128);
    unsigned int v9 = *((_DWORD *)this + 34);
  }
  uint64_t v10 = *(void *)(*((void *)this + 2) + 24);
  uint64_t v11 = *(void *)(v10 + 144);
  if (v11)
  {
    uint64_t v85 = a2;
    a4.n128_u64[0] = *((void *)this + 16);
    int v12 = *((_DWORD *)this + 35);
    int v13 = BYTE1(xmmword_1EB2ACC70);
    int v14 = xmmword_1EB2ACC70;
    if ((*(unsigned char *)(v11 + 13) & 0x20) != 0 && (*(unsigned char *)(v10 + 42) & 0x10) == 0)
    {
      int v15 = BYTE1(xmmword_1EB2ACC70);
      __n128 v83 = a4;
      IOSurfaceRef v16 = CA::Render::FlattenManager::flattened_cache_retain_iosurface((CA::Render::FlattenManager *)*((unsigned int *)this + 56));
      if (v16)
      {
        float64_t v17 = v16;
        if (v15)
        {
          uint64_t v54 = *(void *)(*((void *)this + 2) + 104);
          if (v54) {
            *(_DWORD *)(v54 + 220) = *(_DWORD *)(v54 + 220) & 0xFFF1FFFF | 0x40000;
          }
        }
        unint64_t v18 = v83.n128_u64[0];
        if (!v14) {
          goto LABEL_9;
        }
        if (x_log_hook_p())
        {
          IOSurfaceGetID(v17);
          x_log_();
        }
        else
        {
          uint64_t v55 = x_log_category_flatten;
          BOOL v56 = os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_INFO);
          unint64_t v18 = v83.n128_u64[0];
          if (!v56)
          {
LABEL_9:
            *uint64_t v85 = 1.0;
            uint64_t v19 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t, void, void, __IOSurface *))(*(void *)v8 + 672))(v8, 1, v18, HIDWORD(v18), v17);
            double v20 = v17;
LABEL_64:
            CFRelease(v20);
            return v19;
          }
          int v57 = *((_DWORD *)this + 56);
          *(_DWORD *)uint64_t buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v57;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = IOSurfaceGetID(v17);
          _os_log_impl(&dword_184668000, v55, OS_LOG_TYPE_INFO, "[%d] using cached surf <%d>", buf, 0xEu);
        }
        unint64_t v18 = v83.n128_u64[0];
        goto LABEL_9;
      }
      if (x_log_hook_p())
      {
        x_log_();
        a4 = v83;
        int v13 = v15;
      }
      else
      {
        long long v23 = x_log_category_ogl;
        BOOL v24 = os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR);
        a4 = v83;
        int v13 = v15;
        if (v24)
        {
          int v25 = *((_DWORD *)this + 56);
          *(_DWORD *)uint64_t buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v25;
          _os_log_impl(&dword_184668000, v23, OS_LOG_TYPE_ERROR, "[%d] cachedFlatten but no cached surface", buf, 8u);
          int v13 = v15;
          a4 = v83;
        }
      }
    }
    if ((*((_DWORD *)v7[1] + 271) & 4) != 0) {
      return (*(uint64_t (**)(void, float *, uint64_t, __n128))(**((void **)this + 3) + 80))(*((void *)this + 3), v85, a3, a4);
    }
    uint64_t v26 = *((void *)v8 + 33);
    __n128 v84 = a4;
    int v81 = v13;
    int v82 = v14;
    BOOL v27 = v26 && (*(unsigned char *)(v26 + 68) & 0x30) != 0;
    uint64_t v28 = *((unsigned int *)this + 56);
    uint64_t v29 = (*(uint64_t (**)(CA::OGL::Context *))(*(void *)v8 + 96))(v8);
    if (!v28 || (v9 & 0x80000000) != 0 || v12 < 0) {
      return (*(uint64_t (**)(void, float *, uint64_t, __n128))(**((void **)this + 3) + 80))(*((void *)this + 3), v85, a3, a4);
    }
    if (v12 | v9)
    {
      uint64_t v30 = v29;
      int v78 = v12;
      BOOL v77 = v27;
      if (v27)
      {
        uint64_t v31 = 1380411457;
      }
      else
      {
        if (CADeviceUseCIF10::once != -1) {
          dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_12019);
        }
        if (CADeviceUseCIF10::enable_cif10) {
          uint64_t v31 = 1647534392;
        }
        else {
          uint64_t v31 = 1111970369;
        }
      }
      uint64_t v32 = CA::Render::FlattenManager::flattened_cache_retain_iosurface((CA::Render::FlattenManager *)v28);
      if (v32)
      {
        double v34 = v32;
        if (IOSurfaceGetWidth(v32) == v9
          && IOSurfaceGetHeight(v34) == v78
          && IOSurfaceGetProtectionOptions() == v30
          && IOSurfaceGetPixelFormat(v34) == v31)
        {
          if ((_BYTE)xmmword_1EB2ACC70)
          {
            if (x_log_hook_p())
            {
              IOSurfaceGetID(v34);
              x_log_();
            }
            else
            {
              unint64_t v69 = x_log_category_flatten;
              if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
              {
                IOSurfaceID ID = IOSurfaceGetID(v34);
                *(_DWORD *)uint64_t buf = 67109376;
                *(_DWORD *)&uint8_t buf[4] = v28;
                *(_WORD *)&uint8_t buf[8] = 1024;
                *(_DWORD *)&buf[10] = ID;
                _os_log_impl(&dword_184668000, v69, OS_LOG_TYPE_DEFAULT, "[%d] reusing surface <%d>", buf, 0xEu);
              }
            }
          }
          int v36 = 0x80000;
LABEL_58:
          float v49 = 1.0;
          if (!v77) {
            CA::Render::Update::render_edr_factor(v7[1], v35);
          }
          memset(v90, 0, sizeof(v90));
          int v91 = 0;
          long long v89 = 0u;
          long long v87 = 0u;
          memset(v88, 0, sizeof(v88));
          *(_OWORD *)uint64_t buf = 0u;
          *(int8x8_t *)((char *)v90 + 12) = vand_s8((int8x8_t)(vcvts_n_s32_f32(v49, 0x14uLL) | 0x10000000000000), (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v49 != 0.0), 0x1FuLL)));
          IOSurfaceSetBulkAttachments2();
          uint64_t v50 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t, void, void, __IOSurface *))(*(void *)v8 + 672))(v8, 1, v84.n128_u32[0], v84.n128_u32[1], v34);
          if (v50)
          {
            uint64_t v19 = v50;
            if (v81)
            {
              uint64_t v58 = *(void *)(*((void *)this + 2) + 104);
              if (v58) {
                *(_DWORD *)(v58 + 220) = *(_DWORD *)(v58 + 220) & 0xFFF1FFFF | v36;
              }
            }
            if (v82)
            {
              if (x_log_hook_p())
              {
                IOSurfaceGetID(v34);
                x_log_();
              }
              else
              {
                float64x2_t v63 = x_log_category_flatten;
                if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_INFO))
                {
                  int v64 = *((_DWORD *)this + 56);
                  IOSurfaceID v65 = IOSurfaceGetID(v34);
                  *(_DWORD *)uint64_t buf = 67109888;
                  *(_DWORD *)&uint8_t buf[4] = v64;
                  *(_WORD *)&uint8_t buf[8] = 1024;
                  *(_DWORD *)&buf[10] = v65;
                  *(_WORD *)&buf[14] = 1024;
                  LODWORD(v87) = v9;
                  WORD2(v87) = 1024;
                  *(_DWORD *)((char *)&v87 + 6) = v78;
                  _os_log_impl(&dword_184668000, v63, OS_LOG_TYPE_INFO, "[%d] rendered & cached new surf <%d> <%d %d>", buf, 0x1Au);
                }
              }
            }
            CA::OGL::Context::push_surface((uint64_t)v8, v19, 1u, 0, 0);
            CA::OGL::ImagingNode::render(*((void *)this + 3), 0, 0);
            CA::OGL::Context::pop_surface(v8);
            *(_DWORD *)(v11 + 12) |= 0x2000u;
            *uint64_t v85 = 1.0;
            double v20 = v34;
            goto LABEL_64;
          }
          CA::Render::FlattenManager::flattened_cache_remove_surface((CA::Render::FlattenManager *)*((unsigned int *)this + 56));
          *(_DWORD *)(v11 + 12) &= ~0x2000u;
          CFRelease(v34);
          if (x_log_hook_p()) {
            goto LABEL_66;
          }
          uint64_t v47 = x_log_category_ogl;
          if (!os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR)) {
            return (*(uint64_t (**)(void, float *, uint64_t, __n128))(**((void **)this + 3) + 80))(*((void *)this + 3), v85, a3, a4);
          }
          int v51 = *((_DWORD *)this + 56);
          *(_DWORD *)uint64_t buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v51;
          CFTypeRef v48 = "[%d] Failed to create flattened OGL::Surface";
          goto LABEL_69;
        }
      }
      iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v31, v9, v78, 0, v30, @"CA Flattened Surface", v33);
      if (iosurface_with_pixel_format)
      {
        double v34 = iosurface_with_pixel_format;
        os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::flattened_lock);
        int32x2_t v38 = (void *)CA::Render::flattened_cache;
        if (!CA::Render::flattened_cache)
        {
          int32x2_t v38 = x_hash_table_new_(0, 0, 0, 0, 0, 0);
          CA::Render::flattened_cache = (uint64_t)v38;
        }
        __n128 v39 = v84;
        v39.n128_u32[2] = v9;
        __n128 v79 = v39;
        uint64_t v40 = x_hash_table_lookup((uint64_t)v38, v28, 0);
        __n128 v41 = v79;
        if (!v40)
        {
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          int v43 = malloc_type_zone_malloc(malloc_zone, 0x40uLL, 0x8BB15036uLL);
          uint64_t v40 = (uint64_t)v43;
          if (v43)
          {
            v43[7] = 0;
            *(_OWORD *)int v43 = 0u;
            *((_OWORD *)v43 + 1) = 0u;
            *((_OWORD *)v43 + 2) = 0u;
            *((_DWORD *)v43 + 12) = 0;
            uint64_t v44 = (int *)CA::Render::flattened_cache;
            uint64_t v45 = v28;
            uint64_t v46 = v40;
          }
          else
          {
            uint64_t v44 = (int *)CA::Render::flattened_cache;
            uint64_t v45 = v28;
            uint64_t v46 = 0;
          }
          hash_table_modify(v44, v45, v46, 0);
          __n128 v41 = v79;
        }
        v41.n128_u32[3] = v78;
        if (*(void *)v40)
        {
          __n128 v80 = v41;
          if ((_BYTE)xmmword_1EB2ACC70)
          {
            int v76 = v28;
            if (x_log_hook_p())
            {
              IOSurfaceGetID(*(IOSurfaceRef *)v40);
              IOSurfaceGetID(v34);
              x_log_();
            }
            else
            {
              log = x_log_category_flatten;
              if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
              {
                IOSurfaceID v66 = IOSurfaceGetID(*(IOSurfaceRef *)v40);
                int v67 = *(_DWORD *)(v40 + 24);
                IOSurfaceID v71 = v66;
                int v72 = *(_DWORD *)(v40 + 28);
                int v73 = *(_DWORD *)(v40 + 32);
                int v74 = *(_DWORD *)(v40 + 36);
                IOSurfaceID v68 = IOSurfaceGetID(v34);
                *(_DWORD *)uint64_t buf = 67111680;
                *(_DWORD *)&uint8_t buf[4] = v76;
                *(_WORD *)&uint8_t buf[8] = 1024;
                *(_DWORD *)&buf[10] = v71;
                *(_WORD *)&buf[14] = 1024;
                LODWORD(v87) = v67;
                LODWORD(v28) = v76;
                WORD2(v87) = 1024;
                *(_DWORD *)((char *)&v87 + 6) = v72;
                WORD5(v87) = 1024;
                HIDWORD(v87) = v73;
                LOWORD(v88[0]) = 1024;
                *(_DWORD *)((char *)v88 + 2) = v74;
                WORD3(v88[0]) = 1024;
                DWORD2(v88[0]) = v68;
                WORD6(v88[0]) = 1024;
                *(_DWORD *)((char *)v88 + 14) = v84.n128_u32[0];
                WORD1(v88[1]) = 1024;
                DWORD1(v88[1]) = v84.n128_u32[1];
                WORD4(v88[1]) = 1024;
                *(_DWORD *)((char *)&v88[1] + 10) = v9;
                HIWORD(v88[1]) = 1024;
                LODWORD(v89) = v78;
                _os_log_impl(&dword_184668000, log, OS_LOG_TYPE_DEFAULT, "[%d] replacing surface <%d> <%d %d %d %d> with surface <%d> <%d %d %d %d>", buf, 0x44u);
              }
            }
          }
          CFRelease(*(CFTypeRef *)v40);
          __n128 v41 = v80;
        }
        *(void *)uint64_t v40 = v34;
        *(__n128 *)(v40 + 24) = v41;
        if ((_BYTE)xmmword_1EB2ACC70)
        {
          if (x_log_hook_p())
          {
            IOSurfaceGetID(v34);
            x_log_();
          }
          else
          {
            unint64_t v60 = x_log_category_flatten;
            if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
            {
              IOSurfaceID v61 = IOSurfaceGetID(v34);
              uint64_t v62 = *(void *)(CA::Render::flattened_cache + 24);
              *(_DWORD *)uint64_t buf = 67110656;
              *(_DWORD *)&uint8_t buf[4] = v28;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = v61;
              *(_WORD *)&buf[14] = 1024;
              LODWORD(v87) = v84.n128_u32[0];
              WORD2(v87) = 1024;
              *(_DWORD *)((char *)&v87 + 6) = v84.n128_u32[1];
              WORD5(v87) = 1024;
              HIDWORD(v87) = v9;
              LOWORD(v88[0]) = 1024;
              *(_DWORD *)((char *)v88 + 2) = v78;
              WORD3(v88[0]) = 2048;
              *((void *)&v88[0] + 1) = v62;
              _os_log_impl(&dword_184668000, v60, OS_LOG_TYPE_DEFAULT, "[%d] added surface <%d> <%d %d %d %d> to cache <size: %zu>", buf, 0x30u);
            }
          }
        }
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
        CFRetain(v34);
        int v36 = 393216;
        goto LABEL_58;
      }
      if (!x_log_hook_p())
      {
        uint64_t v47 = x_log_category_flatten;
        if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v28;
          CFTypeRef v48 = "[%d] Failed to create flattened iosurface";
LABEL_69:
          uint64_t v52 = v47;
          os_log_type_t v53 = OS_LOG_TYPE_ERROR;
LABEL_70:
          _os_log_impl(&dword_184668000, v52, v53, v48, buf, 8u);
        }
        return (*(uint64_t (**)(void, float *, uint64_t, __n128))(**((void **)this + 3) + 80))(*((void *)this + 3), v85, a3, a4);
      }
    }
    else
    {
      if (!(_BYTE)xmmword_1EB2ACC70) {
        return (*(uint64_t (**)(void, float *, uint64_t, __n128))(**((void **)this + 3) + 80))(*((void *)this + 3), v85, a3, a4);
      }
      if (!x_log_hook_p())
      {
        uint64_t v59 = x_log_category_flatten;
        if (!os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT)) {
          return (*(uint64_t (**)(void, float *, uint64_t, __n128))(**((void **)this + 3) + 80))(*((void *)this + 3), v85, a3, a4);
        }
        *(_DWORD *)uint64_t buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v28;
        CFTypeRef v48 = "[%d] trying to flatten an empty surface!";
        uint64_t v52 = v59;
        os_log_type_t v53 = OS_LOG_TYPE_DEFAULT;
        goto LABEL_70;
      }
    }
LABEL_66:
    x_log_();
    return (*(uint64_t (**)(void, float *, uint64_t, __n128))(**((void **)this + 3) + 80))(*((void *)this + 3), v85, a3, a4);
  }
  double v21 = *(uint64_t (**)(void))(**((void **)this + 3) + 80);

  return v21();
}

uint64_t CA::OGL::FlattenNode::propagate_roi(CA::OGL::FlattenNode *this, const CA::Bounds *a2)
{
  uint64_t result = (*(uint64_t (**)(void, const CA::Bounds *))(**((void **)this + 3) + 56))(*((void *)this + 3), a2);
  *(_DWORD *)(*((void *)this + 3) + 216) = *(_DWORD *)(*((void *)this + 3) + 216) & 0xFFC00000 | *((_DWORD *)this + 54) & 0x3FFFFF;
  *(_DWORD *)(*((void *)this + 3) + 216) |= 0x400u;
  *(_WORD *)(*((void *)this + 3) + 212) = *(_WORD *)(*((void *)this + 3) + 212) & 0xFDFF | *((_WORD *)this + 106) & 0x200;
  *(_WORD *)(*((void *)this + 3) + 212) = *(_WORD *)(*((void *)this + 3) + 212) & 0xC3FF | *((_WORD *)this + 106) & 0x3C00;
  *(_DWORD *)(*((void *)this + 3) + 216) |= 0x1000u;
  return result;
}

uint64_t CA::OGL::FlattenNode::grow_roi(int32x2_t *this, int32x2_t *a2)
{
  if (this[17].i32[0] < 0) {
    (*(void (**)(int32x2_t *, int32x2_t *))(*(void *)this + 40))(this, this + 16);
  }
  int32x2_t v4 = this[16];
  int32x2_t v5 = this[17];

  return CA::BoundsImpl::Union(a2, v4, v5);
}

void CA::OGL::FlattenNode::compute_dod(CA::OGL::FlattenNode *this, CA::Bounds *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(*(void *)(*((void *)this + 2) + 24) + 42) & 0x10) != 0) {
    goto LABEL_25;
  }
  uint64_t v4 = *((unsigned int *)this + 56);
  if (!v4) {
    goto LABEL_19;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::flattened_lock);
  long long v5 = 0uLL;
  if (!CA::Render::flattened_cache || !*(void *)(CA::Render::flattened_cache + 24)) {
    goto LABEL_8;
  }
  uint64_t v6 = x_hash_table_lookup(CA::Render::flattened_cache, v4, 0);
  if (v6)
  {
    if (!(_BYTE)xmmword_1EB2ACC70)
    {
LABEL_7:
      long long v5 = *(_OWORD *)(v6 + 24);
LABEL_8:
      long long v20 = v5;
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
      long long v7 = v20;
      goto LABEL_20;
    }
    double v8 = (_DWORD *)v6;
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      unsigned int v9 = x_log_category_flatten;
      BOOL v10 = os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT);
      uint64_t v6 = (uint64_t)v8;
      if (!v10) {
        goto LABEL_7;
      }
      int v11 = v8[6];
      int v12 = v8[7];
      int v13 = v8[8];
      int v14 = v8[9];
      *(_DWORD *)uint64_t buf = 67110144;
      int v22 = v4;
      __int16 v23 = 1024;
      int v24 = v11;
      __int16 v25 = 1024;
      int v26 = v12;
      __int16 v27 = 1024;
      int v28 = v13;
      __int16 v29 = 1024;
      int v30 = v14;
      _os_log_impl(&dword_184668000, v9, OS_LOG_TYPE_DEFAULT, "[%d] found cached dod <%d %d %d %d>", buf, 0x20u);
    }
    uint64_t v6 = (uint64_t)v8;
    goto LABEL_7;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
  long long v7 = 0uLL;
  if ((_BYTE)xmmword_1EB2ACC70)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      int v15 = x_log_category_flatten;
      if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 67109120;
        int v22 = v4;
        _os_log_impl(&dword_184668000, v15, OS_LOG_TYPE_DEFAULT, "[%d] no cached dod", buf, 8u);
      }
    }
LABEL_19:
    long long v7 = 0uLL;
  }
LABEL_20:
  int v16 = HIDWORD(v7);
  if (SDWORD2(v7) >= SHIDWORD(v7)) {
    int v17 = HIDWORD(v7);
  }
  else {
    int v17 = DWORD2(v7);
  }
  if (v17 >= 1)
  {
    *(void *)a2 = v7;
    *((_DWORD *)a2 + 2) = DWORD2(v7);
    goto LABEL_28;
  }
LABEL_25:
  uint64_t v18 = *((void *)this + 3);
  int v19 = *(_DWORD *)(v18 + 136);
  if (v19 < 0)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v18 + 40))(v18, v18 + 128);
    int v19 = *(_DWORD *)(v18 + 136);
  }
  *(void *)a2 = *(void *)(v18 + 128);
  *((_DWORD *)a2 + 2) = v19;
  int v16 = *(_DWORD *)(v18 + 140);
LABEL_28:
  *((_DWORD *)a2 + 3) = v16;
}

void CA::OGL::FlattenNode::~FlattenNode(CA::OGL::FlattenNode *this)
{
}

uint64_t CA::OGL::AsynchronousNode::apply(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 104))();
}

void CA::OGL::AsynchronousNode::~AsynchronousNode(CA::OGL::AsynchronousNode *this)
{
}

uint64_t CA::OGL::FilterNode::allow_in_place(CA::OGL::FilterNode *this)
{
  return *((unsigned char *)this + 224) & 1;
}

_DWORD *CA::OGL::BackdropNode::retain_surface(CA::OGL::BackdropNode *this, float *a2)
{
  *a2 = 1.0;
  uint64_t result = (_DWORD *)*((void *)this + 28);
  if (result) {
    ++*result;
  }
  return result;
}

double CA::OGL::BackdropNode::compute_dod(CA::OGL::BackdropNode *this, CA::Bounds *a2)
{
  double result = -2.68156638e154;
  *(_OWORD *)a2 = xmmword_184998040;
  return result;
}

void CA::OGL::BackdropNode::~BackdropNode(CA::OGL::BackdropNode *this)
{
}

void CA::OGL::QuadNode::~QuadNode(CA::OGL::QuadNode *this)
{
}

void CA::OGL::CombineNode::~CombineNode(CA::OGL::CombineNode *this)
{
}

void CA::OGL::BlendNode::apply(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **(void **)(a1 + 8);
  long long v5 = *(_DWORD **)a2;
  uint64_t v6 = *(CA::Shape **)(a1 + 64);
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  CA::OGL::emit_combine(v4, 1u, v5, 0, v6, (unsigned int *)&v20);
  if (*(unsigned char *)(a1 + 124) != 2)
  {
    uint64_t v8 = *(void *)(a1 + 88);
    if (v8 == 0x3C003C003C003C00)
    {
      unsigned int v9 = 1;
    }
    else
    {
      *(void *)(*(void *)(v4 + 16) + 8) = v8;
      unsigned int v9 = 3;
    }
    uint64_t v10 = *(void *)(v4 + 16);
    if (*(unsigned __int8 *)(v10 + 480) >= 2u) {
      *(unsigned char *)(v10 + 481) |= 1u;
    }
    int v11 = *(_DWORD **)(a2 + 8);
    int v12 = *(CA::Shape **)(a1 + 64);
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    CA::OGL::emit_combine(v4, v9, v11, 0, v12, (unsigned int *)&v20);
    *(unsigned char *)(*(void *)(v4 + 16) + 481) &= ~1u;
  }
  if ((*(unsigned char *)(a1 + 222) & 0xE) != 0)
  {
    uint64_t v13 = *(void *)(v4 + 16);
    *(unsigned char *)(v13 + 480) = 3;
    *(unsigned char *)(v13 + 481) |= 1u;
    unsigned int v14 = ((*(_DWORD *)(a1 + 220) >> 17) & 7) - 1;
    if (v14 > 6) {
      unsigned int v15 = 0;
    }
    else {
      unsigned int v15 = dword_1849A40A4[v14];
    }
    unsigned int v16 = bswap32(v15);
    v7.i32[0] = v16;
    v7.i32[1] = v16 >> 8;
    v7.i32[2] = HIWORD(v16);
    v17.i64[0] = 0xFF000000FFLL;
    v17.i64[1] = 0xFF000000FFLL;
    int32x4_t v18 = (int32x4_t)vandq_s8(v7, v17);
    v18.i32[3] = vshrq_n_u32((uint32x4_t)vdupq_n_s32(v16), 0x18uLL).i32[3];
    *(float16x4_t *)(*(void *)(v4 + 16) + 8) = vcvt_f16_f32(vmulq_f32(vcvtq_f32_s32(v18), (float32x4_t)vdupq_n_s32(0x3B808081u)));
    int v19 = *(CA::Shape **)(a1 + 64);
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    CA::OGL::emit_combine(v4, 0, 0, 0, v19, (unsigned int *)&v20);
    *(unsigned char *)(*(void *)(v4 + 16) + 481) &= ~1u;
    *(unsigned char *)(*(void *)(v4 + 16) + 480) = *(unsigned char *)(a1 + 124);
  }
}

uint64_t CA::OGL::BlendNode::propagate_roi(CA::OGL::BlendNode *this, const CA::Bounds *a2)
{
  (*(void (**)(void))(**((void **)this + 3) + 56))(*((void *)this + 3));
  uint64_t v3 = *(uint64_t (**)(void))(**((void **)this + 4) + 56);

  return v3();
}

uint64_t CA::OGL::BlendNode::compute_dod(CA::OGL::BlendNode *this, int32x2_t *a2)
{
  uint64_t v4 = (int32x2_t *)*((void *)this + 3);
  __int32 v5 = v4[17].i32[0];
  if (v5 < 0)
  {
    (*(void (**)(void, int32x2_t *))(*(void *)v4 + 40))(*((void *)this + 3), v4 + 16);
    __int32 v5 = v4[17].i32[0];
  }
  *a2 = v4[16];
  __int32 v6 = v4[17].i32[1];
  a2[1].i32[0] = v5;
  a2[1].i32[1] = v6;
  int8x16_t v7 = (int32x2_t *)*((void *)this + 4);
  if (v7[17].i32[0] < 0) {
    (*(void (**)(int32x2_t *, int32x2_t *))(*(void *)v7 + 40))(v7, v7 + 16);
  }
  int32x2_t v8 = v7[16];
  int32x2_t v9 = v7[17];

  return CA::BoundsImpl::Union(a2, v8, v9);
}

void CA::OGL::BlendNode::~BlendNode(CA::OGL::BlendNode *this)
{
}

uint64_t CA::OGL::CompositeNode::propagate_roi(CA::OGL::CompositeNode *this, const CA::Bounds *a2)
{
  vm_address_t v5[2] = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  v5[1] = 0;
  v4[0] = 0;
  v4[1] = 0;
  (*(void (**)(void, void *))(**((void **)this + 3) + 56))(*((void *)this + 3), v5);
  return (*(uint64_t (**)(void, void *))(**((void **)this + 4) + 56))(*((void *)this + 4), v4);
}

uint64_t CA::OGL::CompositeNode::compute_dod(CA::OGL::CompositeNode *this, int32x2_t *a2)
{
  uint64_t v4 = (int32x2_t *)*((void *)this + 3);
  __int32 v5 = v4[17].i32[0];
  if (v5 < 0)
  {
    (*(void (**)(void, int32x2_t *))(*(void *)v4 + 40))(*((void *)this + 3), v4 + 16);
    __int32 v5 = v4[17].i32[0];
  }
  *a2 = v4[16];
  __int32 v6 = v4[17].i32[1];
  a2[1].i32[0] = v5;
  a2[1].i32[1] = v6;
  int8x16_t v7 = (int32x2_t *)*((void *)this + 4);
  if (v7[17].i32[0] < 0) {
    (*(void (**)(int32x2_t *, int32x2_t *))(*(void *)v7 + 40))(v7, v7 + 16);
  }
  int32x2_t v8 = v7[16];
  int32x2_t v9 = v7[17];

  return CA::BoundsImpl::Union(a2, v8, v9);
}

uint64_t CA::OGL::CompositeNode::needs_surface(CA::OGL::CompositeNode *this, uint64_t a2)
{
  return a2;
}

void CA::OGL::CompositeNode::~CompositeNode(CA::OGL::CompositeNode *this)
{
}

uint64_t (***CA::OGL::TransitionNode::apply(uint64_t a1, void *a2, double *a3))(CA::Render::BuiltinTransition *__hidden this, const CA::Render::TransitionAnimation *, CA::Render::Layer *, unsigned int, float)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = **(void **)(a1 + 8);
  uint64_t v7 = *(void *)(v5 + 24);
  float64x2_t v8 = *(float64x2_t *)(v7 + 64);
  int8x16_t v9 = *(int8x16_t *)(v7 + 80);
  v14[0] = (int8x16_t)v8;
  v14[1] = v9;
  uint64_t v10 = *(void *)(v5 + 16);
  int v11 = *(float64x2_t **)(v10 + 56);
  if (v11) {
    CA::Mat4Impl::mat4_apply_to_rect(v11, v14, a3);
  }
  else {
    v14[0] = (int8x16_t)vaddq_f64(*(float64x2_t *)(v10 + 64), v8);
  }
  double result = CA::Render::Transition::subclass(*(CA::Render::Transition **)(a1 + 224), a2, (const CA::Render::TransitionSubclass *)a3);
  if (result)
  {
    uint64_t v13 = result;
    double result = (uint64_t (***)(CA::Render::BuiltinTransition *__hidden, const CA::Render::TransitionAnimation *, CA::Render::Layer *, unsigned int, float))((uint64_t (*)(uint64_t (***)(CA::Render::BuiltinTransition *__hidden, const CA::Render::TransitionAnimation *, CA::Render::Layer *, unsigned int, float)))(*result)[4])(result);
    if (result) {
      return (uint64_t (***)(CA::Render::BuiltinTransition *__hidden, const CA::Render::TransitionAnimation *, CA::Render::Layer *, unsigned int, float))((uint64_t (*)(uint64_t (***)(CA::Render::BuiltinTransition *__hidden, const CA::Render::TransitionAnimation *, CA::Render::Layer *, unsigned int, float), void, uint64_t, int8x16_t *, void, void, void))(*v13)[5])(v13, *(void *)(a1 + 224), v6, v14, *(void *)(a1 + 232), *a2, a2[1]);
    }
  }
  return result;
}

uint64_t CA::OGL::TransitionNode::propagate_roi(CA::OGL::TransitionNode *this, const CA::Bounds *a2, double *a3)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  float64x2_t v42 = 0u;
  float64x2_t v43 = 0u;
  float64x2_t v40 = 0u;
  float64x2_t v41 = 0u;
  uint64_t v5 = *((void *)this + 2);
  uint64_t v6 = *(void *)(v5 + 24);
  float64x2_t v7 = *(float64x2_t *)(v6 + 64);
  int8x16_t v8 = *(int8x16_t *)(v6 + 80);
  v38[0] = (int8x16_t)v7;
  v38[1] = v8;
  uint64_t v9 = *(void *)(v5 + 16);
  uint64_t v10 = *(float64x2_t **)(v9 + 56);
  if (v10) {
    CA::Mat4Impl::mat4_apply_to_rect(v10, v38, a3);
  }
  else {
    v38[0] = (int8x16_t)vaddq_f64(*(float64x2_t *)(v9 + 64), v7);
  }
  int v11 = CA::Render::Transition::subclass(*((CA::Render::Transition **)this + 28), a2, (const CA::Render::TransitionSubclass *)a3);
  if (v11)
  {
    int v14 = *((_DWORD *)a2 + 2);
    int v15 = *((_DWORD *)a2 + 3);
    if (v14 <= v15) {
      int v16 = *((_DWORD *)a2 + 3);
    }
    else {
      int v16 = *((_DWORD *)a2 + 2);
    }
    v12.i32[0] = 1073741822;
    v13.i32[0] = v16;
    uint64_t v17 = *((void *)this + 28);
    v18.i64[0] = (int)*(void *)a2;
    v18.i64[1] = (int)HIDWORD(*(void *)a2);
    int8x16_t v19 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v13, v12), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v18));
    double v20 = (double)v14;
    double v21 = (double)v15;
    uint64_t v22 = *((void *)this + 10);
    if (v16 > 1073741822)
    {
      double v20 = 1.79769313e308;
      double v21 = 1.79769313e308;
    }
    int32x4_t v35 = (int32x4_t)v19;
    double v36 = v20;
    double v37 = v21;
    ((void (*)(uint64_t (***)(CA::Render::BuiltinTransition *__hidden, const CA::Render::TransitionAnimation *, CA::Render::Layer *, unsigned int, float), uint64_t, int8x16_t *, uint64_t, int32x4_t *, float64x2_t *, float64x2_t *))(*v11)[3])(v11, v17, v38, v22, &v35, &v42, &v40);
    __int16 v23 = (const CA::Transform *)*((void *)this + 29);
    CA::Rect::unapply_transform((CA::Rect *)&v42, v23, v24);
    CA::Rect::unapply_transform((CA::Rect *)&v40, v23, v25);
    int8x16_t v26 = (int8x16_t)vceqzq_f64(v43);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v26, 1), v26).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v27 = vorrq_s8((int8x16_t)vcltzq_f64(v43), (int8x16_t)vcgezq_f64(v43)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v27), 1), v27).u64[0] & 0x8000000000000000) != 0))
    {
      int32x4_t v35 = 0uLL;
    }
    else
    {
      int32x4_t v28 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v42, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      int32x4_t v35 = vuzp1q_s32(v28, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v42, v43), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v28));
    }
    int8x16_t v29 = (int8x16_t)vceqzq_f64(v41);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v29, 1), v29).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v30 = vorrq_s8((int8x16_t)vcltzq_f64(v41), (int8x16_t)vcgezq_f64(v41)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v30), 1), v30).u64[0] & 0x8000000000000000) != 0))
    {
      int32x4_t v39 = 0uLL;
    }
    else
    {
      int32x4_t v31 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v40, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      int32x4_t v39 = vuzp1q_s32(v31, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v40, v41), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v31));
    }
  }
  else
  {
    __int32 v32 = *((_DWORD *)a2 + 1);
    v35.i32[0] = *(_DWORD *)a2;
    v35.i32[1] = v32;
    __int32 v33 = *((_DWORD *)a2 + 3);
    v35.i32[2] = *((_DWORD *)a2 + 2);
    v35.i32[3] = v33;
    v39.i32[0] = v35.i32[0];
    *(uint64_t *)((char *)v39.i64 + 4) = __PAIR64__(v35.u32[2], v32);
    v39.i32[3] = v33;
  }
  (*(void (**)(void, int32x4_t *))(**((void **)this + 3) + 56))(*((void *)this + 3), &v35);
  return (*(uint64_t (**)(void, int32x4_t *))(**((void **)this + 4) + 56))(*((void *)this + 4), &v39);
}

double CA::OGL::TransitionNode::compute_dod(CA::OGL::TransitionNode *this, CA::Bounds *a2)
{
  double result = -2.68156638e154;
  *(_OWORD *)a2 = xmmword_184998040;
  return result;
}

BOOL CA::OGL::TransitionNode::needs_surface(CA::Render::Transition **this, unsigned int a2, const CA::Render::TransitionSubclass *a3)
{
  return !CA::Render::Transition::subclass(this[28], a2, a3) && *((void *)this[28] + 4) != 0;
}

void CA::OGL::TransitionNode::~TransitionNode(CA::OGL::TransitionNode *this)
{
  *(void *)this = &unk_1ED02B660;
  unsigned int v1 = (void *)*((void *)this + 29);
  if (v1)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v1);
  }
  abort();
}

{
  void *v1;
  malloc_zone_t *malloc_zone;

  *(void *)this = &unk_1ED02B660;
  unsigned int v1 = (void *)*((void *)this + 29);
  if (v1)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v1);
  }
}

void CA::OGL::ShadowNode::~ShadowNode(CA::OGL::ShadowNode *this)
{
}

uint64_t CA::OGL::MeshNode::mesh_node_p(CA::OGL::MeshNode *this)
{
  return 1;
}

void CA::OGL::MeshNode::~MeshNode(CA::OGL::MeshNode *this)
{
}

uint64_t CA::CG::AccelDrawable::is_purged_(CA::CG::AccelDrawable *this)
{
  return 0;
}

uint64_t CA::CG::AccelDrawable::set_volatile_(CA::CG::AccelDrawable *this)
{
  return 0;
}

void *CA::CG::MetalDrawable::create_queue(CA::CG::MetalDrawable *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  double result = malloc_type_zone_malloc(malloc_zone, 0xD8uLL, 0x8BB15036uLL);
  if (result)
  {
    double result = (void *)CA::CG::AccelQueue::AccelQueue((uint64_t)result, (uint64_t)this);
    void *result = &unk_1ED027728;
  }
  return result;
}

void CA::CG::MetalDrawable::mark_texture(os_unfair_lock_s *this)
{
  float64x2_t v2 = this + 3;
  os_unfair_lock_lock(this + 3);
  uint64_t v3 = *(void *)&this[26]._os_unfair_lock_opaque;
  if (v3) {
    atomic_fetch_add((atomic_uint *volatile)(v3 + 36), 1u);
  }

  os_unfair_lock_unlock(v2);
}

void CA::CG::MetalDrawable::retain_shared_texture(CA::CG::MetalDrawable *this@<X0>, CA::Render::MetalTexture **a2@<X8>)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 12);
  os_unfair_lock_lock((os_unfair_lock_t)this + 3);
  if (*((unsigned char *)this + 68))
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = (CA::Render::MetalTexture *)*((void *)this + 13);
    if (v5) {
      goto LABEL_10;
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    float64x2_t v7 = (CA::Render::MetalTexture *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x70uLL, 0x743898A5uLL);
    uint64_t v5 = v7;
    if (v7) {
      float64x2_t v7 = CA::Render::MetalTexture::MetalTexture(v7, *((objc_object **)this + 12));
    }
    CA::Render::Texture::set_colorspace(v7, *((CGColorSpace **)this + 3));
    int8x16_t v8 = (atomic_uint *)*((void *)this + 13);
    *((void *)this + 13) = v5;
    if (v8)
    {
      if (atomic_fetch_add(v8 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v8 + 16))(v8);
      }
      uint64_t v5 = (CA::Render::MetalTexture *)*((void *)this + 13);
    }
    if (v5)
    {
LABEL_10:
      uint64_t v9 = (atomic_uint *)((char *)v5 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)v5 + 2, 1u))
      {
        uint64_t v5 = 0;
        atomic_fetch_add(v9, 0xFFFFFFFF);
      }
    }
  }
  *a2 = v5;

  os_unfair_lock_unlock(v4);
}

uint64_t CA::CG::MetalDrawable::set_as_destination(CA::CG::MetalDrawable *this, CA::OGL::Context *a2, uint64_t a3)
{
  v4[1] = *MEMORY[0x1E4F143B8];
  v4[0] = *((void *)this + 12);
  (*(void (**)(CA::OGL::Context *, void, void *, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 0, v4, 1, 1, a3);
  return 1;
}

uint64_t CA::CG::MetalDrawable::needs_gpu(CA::CG::MetalDrawable *this)
{
  return 1;
}

uint64_t CA::CG::MetalDrawable::texture(CA::CG::MetalDrawable *this)
{
  return *((void *)this + 12);
}

uint64_t CA::CG::AccelDrawable::surface(CA::CG::AccelDrawable *this)
{
  return 0;
}

void CA::CG::MetalDrawable::~MetalDrawable(CA::CG::MetalDrawable *this)
{
  *(void *)this = &unk_1ED0282B8;
  float64x2_t v2 = (atomic_uint *)*((void *)this + 13);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  *(void *)this = &unk_1ED028088;
  if (!*((unsigned char *)this + 70)) {
    __assert_rtn("~AccelDrawable", "cg-accel-drawable.cpp", 62, "_destroyed");
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v2;

  *(void *)this = &unk_1ED0282B8;
  float64x2_t v2 = (atomic_uint *)*((void *)this + 13);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  *(void *)this = &unk_1ED028088;
  if (!*((unsigned char *)this + 70)) {
    __assert_rtn("~AccelDrawable", "cg-accel-drawable.cpp", 62, "_destroyed");
  }
}

void CA::CG::MetalDrawable::destroy(CGColorSpaceRef *this)
{
  CA::CG::AccelDrawable::destroy(this);
  CGColorSpaceRef v2 = this[12];

  CFRelease(v2);
}

CGImageRef CA::CG::MetalDrawable::copy_cgimage(CA::CG::MetalDrawable *this)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 9);
  if (v2) {
    CA::CG::Queue::flush(v2, 3, 1);
  }
  uint64_t v3 = (os_unfair_lock_s *)((char *)this + 12);
  os_unfair_lock_lock((os_unfair_lock_t)this + 3);
  if (!*((unsigned char *)this + 68))
  {
    if (!*((void *)this + 10))
    {
      uint64_t v5 = *((unsigned int *)this + 4);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      float64x2_t v7 = malloc_type_zone_malloc(malloc_zone, 0x38uLL, 0x8BB15036uLL);
      if (v7)
      {
        uint64_t v8 = *((void *)this + 9);
        if (v8
          || (uint64_t v8 = (*(uint64_t (**)(CA::CG::MetalDrawable *))(*(void *)this + 72))(this),
              (*((void *)this + 9) = v8) != 0))
        {
          int v9 = *(_DWORD *)(v8 + 48);
        }
        else
        {
          int v9 = 0;
        }
        CA::CG::AccelDataProvider::AccelDataProvider((uint64_t)v7, (uint64_t)this, v9);
        void *v7 = &unk_1ED029148;
      }
      uint64_t v10 = (void *)*((void *)this + 12);
      uint64_t BytesPerRow = CAMetalTextureGetBytesPerRow(v10);
      DiCGRect rect = CGDataProviderCreateDirect(v7, [v10 height] * BytesPerRow, &CA::CG::AccelDataProvider::callbacks(void)::vtable);
      size_t v13 = *((unsigned int *)this + 13);
      size_t v14 = *((unsigned int *)this + 14);
      if (v5 == 9)
      {
        size_t v15 = CAMetalTextureGetBytesPerRow(*((void **)this + 12));
        *(_OWORD *)decode = xmmword_184997D50;
        CGImageRef v16 = CGImageMaskCreate(v13, v14, 8uLL, 8uLL, v15, Direct, decode, 1);
      }
      else
      {
        if (v5 > 0x23)
        {
          size_t v17 = 0;
          size_t v18 = 0;
        }
        else
        {
          size_t v17 = dword_184999500[v5];
          size_t v18 = dword_1849993D8[v5];
        }
        size_t v19 = CAMetalTextureGetBytesPerRow(*((void **)this + 12));
        CGImageRef v16 = CGImageCreate(v13, v14, v17, v18, v19, *((CGColorSpaceRef *)this + 3), *((_DWORD *)this + 8), Direct, 0, 1, kCGRenderingIntentDefault);
      }
      double v20 = v16;
      CGDataProviderRelease(Direct);
      if (v20)
      {
        CA::CG::AccelDataProvider::set_image((CA::CG::AccelDataProvider *)v7, v20);
        os_unfair_lock_lock((os_unfair_lock_t)this + 3);
        if (!*((void *)this + 10))
        {
          *((void *)this + 10) = v20;
          goto LABEL_22;
        }
        os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
        CGImageRelease(v20);
      }
      os_unfair_lock_lock((os_unfair_lock_t)this + 3);
    }
LABEL_22:
    CGImageRef v4 = CGImageRetain(*((CGImageRef *)this + 10));
    goto LABEL_23;
  }
  CGImageRef v4 = 0;
LABEL_23:
  os_unfair_lock_unlock(v3);
  return v4;
}

CGImageRef CA::CG::MetalDrawable::copy_cgimage_mtl(CA::CG::MetalDrawable *this)
{
  if (*((_DWORD *)this + 4) == 9)
  {
    return CA::CG::MetalDrawable::copy_cgimage(this);
  }
  else
  {
    uint64_t v3 = *((void *)this + 9);
    if (v3) {
      CA::CG::Queue::flush(v3, 3, 1);
    }
    CGImageRef v4 = (os_unfair_lock_s *)((char *)this + 12);
    os_unfair_lock_lock((os_unfair_lock_t)this + 3);
    if (*((unsigned char *)this + 68))
    {
      uint64_t v5 = 0;
    }
    else
    {
      uint64_t v5 = *((void *)this + 12);
      if (v5)
      {
        uint64_t v6 = *((void *)this + 3);
        CFRetain(*((CFTypeRef *)this + 12));
        CFDictionaryRef v7 = CFDictionaryCreate(0, MEMORY[0x1E4F1DD78], MEMORY[0x1E4F1CFD0], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (!v6) {
          CAGetColorSpace(0x1Du);
        }
        CGImageProviderCreate();
        CFRelease(v7);
        uint64_t v5 = CGImageCreateWithImageProvider();
        CGImageProviderRelease();
      }
      CGImageSetProperty();
    }
    os_unfair_lock_unlock(v4);
    return (CGImageRef)v5;
  }
}

void CA::Render::String::show(CA::Render::String *this)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    uint64_t v2 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 136315138;
      CGImageRef v4 = (char *)this + 28;
      _os_log_impl(&dword_184668000, v2, OS_LOG_TYPE_DEFAULT, "\"%s\"", buf, 0xCu);
    }
  }
}

uint64_t CA::Render::String::unsafe_cf_string(CA::Render::String *this)
{
  uint64_t result = *((void *)this + 2);
  if (!result)
  {
    CFStringRef v3 = CFStringCreateWithCStringNoCopy(0, (const char *)this + 28, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    uint64_t v4 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)this + 2, (unint64_t *)&v4, (unint64_t)v3);
    if (v4) {
      CFRelease(v3);
    }
    return *((void *)this + 2);
  }
  return result;
}

void ___ZL21layer_private_presentP20_CAMetalLayerPrivateP15CAMetalDrawableddj_block_invoke(uint64_t a1)
{
}

void release_sample(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (char *)pthread_getspecific(collect_slot);
  if (release_key && (uint64_t v5 = pthread_getspecific(release_key)) != 0)
  {
    char v6 = *(unsigned char *)(a3 + 113) & 0xCF;
    *(unsigned char *)(a3 + 113) = v6;
    if (v4 && *((_DWORD *)v5 + 14))
    {
      *((void *)v4 + 33) = v5[12];
      char v6 = *(unsigned char *)(a3 + 113) & 0xEF;
    }
    char v7 = v6 | (16 * *((unsigned char *)v5 + 74));
  }
  else
  {
    char v7 = *(unsigned char *)(a3 + 113) & 0xCF;
  }
  *(unsigned char *)(a3 + 113) = v7;
  if (atomic_fetch_add((atomic_uint *volatile)a3, 0xFFFFFFFF) == 1)
  {
    if (v4)
    {
      uint64_t v8 = *((void *)v4 + 25);
      uint64_t v9 = CAHostTimeWithTime(0.2) + v8;
      uint64_t v10 = mach_absolute_time();
      if (*((void *)v4 + 4) || (*((_WORD *)v4 + 144) & 0x10) != 0) {
        int v11 = (unsigned int *)(v4 + 136);
      }
      else {
        int v11 = (unsigned int *)(v4 + 132);
      }
      unint64_t v12 = *v11;
      if (v10 > v9) {
        ++v12;
      }
      if (v12 >= *((unsigned int *)v4 + 32))
      {
        uint64_t v15 = *((void *)v4 + 7);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        size_t v17 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
        void *v17 = a3;
        v17[1] = v15;
        *((void *)v4 + 7) = v17;
      }
      else
      {
        release_drawable((_CAMetalLayerPrivate *)v4, (_CAMetalDrawablePrivate *)a3);
      }
    }
    else
    {
      size_t v13 = *(const void **)(a3 + 64);
      if (v13) {
        CFRelease(v13);
      }

      *(void *)(a3 + 72) = 0;
      size_t v14 = *(CGColorSpace **)(a3 + 88);
      if (v14)
      {
        CGColorSpaceRelease(v14);
        *(void *)(a3 + 88) = 0;
      }

      free((void *)a3);
    }
  }
}

void layer_collectable_signal(uint64_t a1, _CAMetalLayerPrivate *a2)
{
  if (atomic_exchange((atomic_uint *volatile)a2 + 38, 2u) == 1) {
    dispatch_semaphore_signal(*((dispatch_semaphore_t *)a2 + 18));
  }
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 48);
    if (!v4 || !*(_DWORD *)(*(void *)(v4 + 24) + 32)) {
      layer_private_cleanup_callbacks(a2);
    }
  }
  if (*((void *)a2 + 4) && CAMetalLayerShouldDispatchLink(*((CAMetalLayer **)a2 + 3)))
  {
    uint64_t v5 = *((void *)a2 + 4);
    +[CADisplayLink dispatchDeferredDisplayLink:v5];
  }
}

BOOL CAMetalLayerShouldDispatchLink(CAMetalLayer *a1)
{
  v7[1] = *MEMORY[0x1E4F143B8];
  priv = (unsigned int *)a1->_priv;
  os_unfair_lock_lock((os_unfair_lock_t)priv + 2);
  if (*((void *)priv + 9))
  {
    v7[0] = 0;
    uint64_t v3 = priv[34];
    uint64_t v4 = priv[35];
    CAMetalLayerPrivateNextDrawableLocked(a1, 0, v7);
    if (v7[0] >= 5 - v3) {
      v7[0] -= 5 - v3;
    }
    os_unfair_lock_lock((os_unfair_lock_t)priv + 52);
    os_unfair_lock_lock((os_unfair_lock_t)priv + 46);
    [*((id *)priv + 27) count];
    [*((id *)priv + 24) count];
    os_unfair_lock_unlock((os_unfair_lock_t)priv + 46);
    os_unfair_lock_unlock((os_unfair_lock_t)priv + 52);
    unint64_t v5 = v7[0];
    kdebug_trace();
    os_unfair_lock_unlock((os_unfair_lock_t)priv + 2);
    if (v5 != v4)
    {
      if (!v4) {
        return 1;
      }
      if (v4 == 1) {
        return (~*((unsigned __int8 *)a1->_priv + 232) & 3) == 0;
      }
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)priv + 2);
  }
  return 0;
}

void sub_1848DB240(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void release_drawable(_CAMetalLayerPrivate *a1, _CAMetalDrawablePrivate *a2)
{
  if (a2)
  {
    uint64_t v4 = *((void *)a1 + 2);
    if (v4)
    {
      unint64_t var5 = a2->var5;
      if (var5) {
        CAImageQueueUnregisterBuffer(v4, var5);
      }
    }
    var10 = a2->var10;
    if (var10) {
      CFRelease(var10);
    }

    a2->var11 = 0;
    var13 = a2->var13;
    if (var13)
    {
      CGColorSpaceRelease(var13);
      a2->var13 = 0;
    }

    free(a2);
  }
  --*((_DWORD *)a1 + 32);
}

void ___ZL21warn_multiple_presentv_block_invoke()
{
}

void sub_1848DB4E4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1848DB5B8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void drawable_purgeable_callback(CA::Render::Object *a1, char *a2, void *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (os_unfair_lock_s *)(a2 + 8);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 2);
  pthread_setspecific(collect_slot, a2);
  CAImageQueueCollect_(*((void *)a2 + 2), 0, 0);
  pthread_setspecific(collect_slot, 0);
  for (uint64_t i = (void *)*((void *)a2 + 7); i; uint64_t i = (void *)i[1])
  {
    uint64_t v6 = *i;
    *(unsigned char *)(v6 + 113) = *(unsigned char *)(*i + 113) | 0x40;
    char v7 = *(__IOSurface **)(v6 + 64);
    uint32_t oldState = 0;
    IOSurfaceSetPurgeable(v7, 1u, &oldState);
  }

  os_unfair_lock_unlock(v4);
}

void sub_1848DBF44(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void layer_private_memory_warning(CA::Render::Object *a1, os_unfair_lock_s *a2, void *a3)
{
  if (a2) {
    layer_private_flush_backbuffers(a2);
  }
}

void layer_private_flush_backbuffers(os_unfair_lock_s *a1)
{
  uint64_t v2 = a1 + 2;
  os_unfair_lock_lock(a1 + 2);
  layer_private_flush_async((_CAMetalLayerPrivate *)a1);

  os_unfair_lock_unlock(v2);
}

void sub_1848DBFB0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1848DC294(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1848DC33C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1848DC5DC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CAMetalLayerSetMetalLinkToken(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = (os_unfair_lock_s *)(v3 + 8);
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 8));
  *(void *)(v3 + 32) = a2;
  if (a2)
  {
    uint64_t v6 = *(int **)(v3 + 16);
    uint64_t v5 = v3 + 16;
    CAImageQueueSetFlagsInternal(v6, 0x60000000050000, 0x20000000050000);
    char v7 = 5 - *(unsigned char *)(v5 + 120);
  }
  else
  {
    uint64_t v8 = *(int **)(v3 + 16);
    uint64_t v5 = v3 + 16;
    CAImageQueueSetFlagsInternal(v8, 0x60000000050000, (unint64_t)(*(_DWORD *)(v5 + 116) == 2) << 54);
    char v7 = 2;
  }
  uint64_t v9 = *(void *)(*(void *)v5 + 48);
  if (v9) {
    *(unsigned char *)(*(void *)(v9 + 24) + 95) = v7;
  }

  os_unfair_lock_unlock(v4);
}

void CA::Rect::unapply_inverse_transform(int8x16_t *this, float64x2_t *a2, double *a3)
{
  if ((LOBYTE(a2[9].f64[0]) & 0x10) != 0) {
    CA::Mat4Impl::mat4_unapply_inverse_to_rect(a2, this, a3);
  }
  else {
    CA::Rect::apply_transform(this, (const CA::Transform *)a2, a3);
  }
}

double *CA::BoundsImpl::inset_point(double *result, double a2, double a3)
{
  double v4 = result[2];
  double v3 = result[3];
  if (v4 <= v3) {
    double v5 = result[3];
  }
  else {
    double v5 = result[2];
  }
  if (v5 < 1.79769313e308)
  {
    double v6 = result[1] + a3;
    void *result = *result + a2;
    result[1] = v6;
    double v7 = v4 - a2 * 2.0;
    double v8 = v3 - a3 * 2.0;
    result[2] = v7;
    result[3] = v8;
    if (v7 <= 0.0 || v8 <= 0.0)
    {
      result[2] = 0.0;
      result[3] = 0.0;
    }
  }
  return result;
}

double *CA::BoundsImpl::set_points(double *this, double *a2, const double *a3)
{
  double v3 = *a2;
  double v4 = a2[1];
  if ((unint64_t)a3 >= 2)
  {
    double v5 = (char *)a3 - 1;
    double v6 = a2 + 3;
    double v7 = a2[1];
    double v8 = *a2;
    while (1)
    {
      double v9 = *(v6 - 1);
      double v10 = v9 > v3 ? *(v6 - 1) : v3;
      if (v9 >= v8) {
        double v3 = v10;
      }
      else {
        double v8 = *(v6 - 1);
      }
      double v11 = *v6;
      if (*v6 < v7) {
        break;
      }
      if (v11 <= v4) {
        goto LABEL_12;
      }
LABEL_13:
      v6 += 2;
      double v4 = v11;
      if (!--v5) {
        goto LABEL_16;
      }
    }
    double v7 = *v6;
LABEL_12:
    double v11 = v4;
    goto LABEL_13;
  }
  double v8 = *a2;
  double v7 = a2[1];
  double v11 = v7;
LABEL_16:
  double v12 = v3 - v8;
  double v13 = v11 - v7;
  if (COERCE_UNSIGNED_INT64(fabs(v11 - v7 + v12)) >= 0x7FF0000000000000)
  {
    double v12 = 1.79769313e308;
    double v8 = -8.98846567e307;
    double v7 = -8.98846567e307;
    double v13 = 1.79769313e308;
  }
  *this = v8;
  this[1] = v7;
  this[2] = v12;
  this[3] = v13;
  return this;
}

void CA::CG::ClipPath::draw(CA::CG::ClipPath *this, CA::CG::Renderer *a2)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  float64x2_t v3 = *((float64x2_t *)a2 + 2);
  float64x2_t v4 = *((float64x2_t *)a2 + 3);
  float64x2_t v5 = *((float64x2_t *)a2 + 4);
  double v6 = (CA::OGL::Context *)*((void *)a2 + 1);
  float64x2_t v42 = 0u;
  float64x2_t v43 = 0u;
  double v40 = 0.0;
  double v41 = 0.0;
  float64x2_t v63 = 0u;
  long long v64 = 0u;
  float64x2_t v61 = 0u;
  float64x2_t v62 = 0u;
  float64x2_t v37 = v3;
  float64x2_t v38 = v4;
  float64x2_t v39 = v5;
  if (CGPathIsRectWithTransform())
  {
    float64x2_t v35 = v42;
    float64x2_t v36 = v43;
    if (v43.f64[0] < 0.0)
    {
      v35.f64[0] = v43.f64[0] + v42.f64[0];
      v36.f64[0] = -v43.f64[0];
    }
    if (v43.f64[1] < 0.0)
    {
      v35.f64[1] = v43.f64[1] + v42.f64[1];
      v36.f64[1] = -v43.f64[1];
    }
    float64x2_t v32 = v37;
    float64x2_t v57 = v37;
    float64x2_t v58 = v38;
    float64x2_t v33 = v39;
    float64x2_t v34 = v38;
    float64x2_t v59 = v39;
    uint64_t v7 = CA::CG::mat2_filter_bits((uint64_t)&v57);
    unsigned int v13 = CA::CG::rect_filter_bits((uint64_t)&v35, v57.f64, v7, v8, v9, v10, v11, v12);
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    uint64_t v56 = 0;
    CA::Transform::set_affine((CA::Transform *)&v44, v32.f64[0], v32.f64[1], v34.f64[0], v34.f64[1], v33.f64[0], v33.f64[1]);
    *((void *)&v53 + 1) = &v35;
    *(void *)&long long v54 = &v44;
    *((void *)&v54 + 1) = v13 | 0xFF00000000;
    uint64_t v56 = 0;
    long long v55 = 0uLL;
    CA::OGL::fill_rect((uint64_t)v6, (uint64_t)&v53 + 8, v14, v15);
    return;
  }
  if (CGPathIsEllipseWithTransform())
  {
    float64x2_t v16 = v37;
    float64x2_t v17 = v38;
    float64x2_t v18 = v39;
    double v19 = v42.f64[1];
    double v20 = v42.f64[0];
    float64x2_t v57 = v42;
    float64x2_t v58 = v43;
    if (v43.f64[0] < 0.0)
    {
      double v20 = v43.f64[0] + v42.f64[0];
      v57.f64[0] = v43.f64[0] + v42.f64[0];
      v58.f64[0] = -v43.f64[0];
    }
    if (v43.f64[1] >= 0.0)
    {
      double v21 = v43.f64[1];
    }
    else
    {
      double v19 = v43.f64[1] + v42.f64[1];
      double v21 = -v43.f64[1];
      v57.f64[1] = v43.f64[1] + v42.f64[1];
      v58.f64[1] = -v43.f64[1];
    }
    double v23 = v43.f64[0] * 0.5;
    double v22 = v43.f64[1] * 0.5;
LABEL_20:
    double v24 = v23 - v22;
    if (v23 - v22 < 0.0) {
      double v24 = -(v23 - v22);
    }
    if (v24 > 0.001)
    {
      double v25 = v22 / v23;
      float64x2_t v26 = vmlaq_n_f64(vmlaq_n_f64(v18, v16, v20), v17, v19);
      float64x2_t v17 = vmulq_n_f64(v17, v25);
      float64x2_t v18 = vmlsq_lane_f64(vmlsq_lane_f64(v26, v16, v20, 0), v17, v19, 0);
      v58.f64[1] = v21 / v25;
    }
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    uint64_t v56 = 0;
    CA::Transform::set_affine((CA::Transform *)&v44, v16.f64[0], v16.f64[1], v17.f64[0], v17.f64[1], v18.f64[0], v18.f64[1]);
    *((void *)&v53 + 1) = &v57;
    *(void *)&long long v54 = &v44;
    *((void *)&v54 + 1) = 0xFF0020003FLL;
    uint64_t v56 = 0;
    long long v55 = 0uLL;
    CA::OGL::fill_round_rect((uint64_t)v6, (float64x2_t **)&v53 + 1, (double *)0xF, 0, v23, v23);
    return;
  }
  if (CGPathIsRoundedRectWithTransform())
  {
    float64x2_t v16 = v37;
    float64x2_t v17 = v38;
    float64x2_t v18 = v39;
    double v19 = v42.f64[1];
    double v20 = v42.f64[0];
    float64x2_t v57 = v42;
    double v21 = v43.f64[1];
    float64x2_t v58 = v43;
    if (v43.f64[0] < 0.0)
    {
      double v20 = v43.f64[0] + v42.f64[0];
      v57.f64[0] = v43.f64[0] + v42.f64[0];
      v58.f64[0] = -v43.f64[0];
    }
    if (v43.f64[1] < 0.0)
    {
      double v19 = v43.f64[1] + v42.f64[1];
      double v21 = -v43.f64[1];
      v57.f64[1] = v43.f64[1] + v42.f64[1];
      v58.f64[1] = -v43.f64[1];
    }
    double v23 = v40;
    double v22 = v41;
    goto LABEL_20;
  }
  if (CGPathIsUnevenCornersRoundedRectWithTransform()
    && (*(unsigned int (**)(CA::OGL::Context *, uint64_t))(*(void *)v6 + 184))(v6, 31))
  {
    float64x2_t v35 = v42;
    float64x2_t v36 = v43;
    if (v43.f64[0] < 0.0)
    {
      v35.f64[0] = v43.f64[0] + v42.f64[0];
      v36.f64[0] = -v43.f64[0];
    }
    if (v43.f64[1] < 0.0)
    {
      v35.f64[1] = v43.f64[1] + v42.f64[1];
      v36.f64[1] = -v43.f64[1];
    }
    float64x2_t v57 = v61;
    float64x2_t v58 = v62;
    float64x2_t v59 = v63;
    long long v60 = v64;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    uint64_t v56 = 0;
    CA::Transform::set_affine((CA::Transform *)&v44, v37.f64[0], v37.f64[1], v38.f64[0], v38.f64[1], v39.f64[0], v39.f64[1]);
    *((void *)&v53 + 1) = &v35;
    *(void *)&long long v54 = &v44;
    *((void *)&v54 + 1) = 0xFF0020003FLL;
    uint64_t v56 = 0;
    long long v55 = 0uLL;
    CA::OGL::fill_uneven_round_rect(v6, (uint64_t)&v53 + 8, v57.f64, 0, COERCE_DOUBLE(0xFF0020003FLL), v27, v28, v29, v30, v31);
  }
  else
  {
    CA::CG::fill_path((uint64_t)a2);
  }
}

uint64_t CA::CG::ClipPath::prepare(CA::CG::ClipPath *this, CA::CG::Renderer *a2, const CA::CG::DrawOp *a3, CA::CG::ClipOp *a4)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 17)) {
    int v8 = 8;
  }
  else {
    int v8 = 1;
  }
  if (*((unsigned char *)this + 16)) {
    unsigned int v9 = v8 | 0x10;
  }
  else {
    unsigned int v9 = v8;
  }
  int8x16_t v10 = CA::Shape::new_shape(*((void *)this + 1), (double *)a2 + 11, v9);
  if (v10)
  {
    int8x16_t v11 = v10;
    uint64_t v12 = *((void *)a4 + 2);
    if (v12) {
      uint64_t v13 = CA::Shape::intersect(v12, (uint64_t)v11);
    }
    else {
      uint64_t v13 = CA::Shape::intersect(v11, a4);
    }
    double v40 = (CA::Shape *)*((void *)a4 + 2);
    *((void *)a4 + 2) = v13;
    if (v13)
    {
      if (v13 != 1)
      {
        *(_DWORD *)a4 = v13 >> 48;
        *((_DWORD *)a4 + 1) = (int)((unint64_t)v13 >> 16) >> 16;
        *((_DWORD *)a4 + 2) = v13 >> 17;
        *((_DWORD *)a4 + 3) = (v13 >> 2) & 0x7FFF;
        if (!v13)
        {
LABEL_42:
          int v41 = *((_DWORD *)a4 + 2);
          if (v41 >= *((_DWORD *)a4 + 3)) {
            int v41 = *((_DWORD *)a4 + 3);
          }
          BOOL v42 = v41 < 1;
          if (v40) {
            CA::Shape::unref(v40);
          }
          CA::Shape::unref(v11);
          return v42;
        }
LABEL_40:
        CA::Shape::unref((CA::Shape *)v13);
        *((void *)a4 + 2) = 0;
        goto LABEL_42;
      }
    }
    else if (*(_DWORD *)(v13 + 4) == 12)
    {
      *(_DWORD *)a4 = *(_DWORD *)(v13 + 28);
      *((_DWORD *)a4 + 1) = *(_DWORD *)(v13 + 20);
      *((_DWORD *)a4 + 2) = *(_DWORD *)(v13 + 32) - *(_DWORD *)(v13 + 28);
      *((_DWORD *)a4 + 3) = *(_DWORD *)(v13 + 36) - *(_DWORD *)(v13 + 20);
      goto LABEL_40;
    }
    CA::Shape::get_bounds(v13, (int *)a4);
    goto LABEL_42;
  }
  int v14 = *((_DWORD *)a4 + 2);
  int v15 = *((_DWORD *)a4 + 3);
  if (v14 <= v15) {
    int v16 = *((_DWORD *)a4 + 3);
  }
  else {
    int v16 = *((_DWORD *)a4 + 2);
  }
  uint64_t v17 = *(void *)a4;
  if (v16 <= 1073741822) {
    v18.f64[0] = (double)v14;
  }
  else {
    v18.f64[0] = 1.79769313e308;
  }
  if (v16 <= 1073741822) {
    double v19 = (double)v15;
  }
  else {
    double v19 = 1.79769313e308;
  }
  double v94 = v18.f64[0];
  double v95 = v19;
  v18.f64[1] = v19;
  float64x2_t v96 = v18;
  BoundingBoCGFloat x = CGPathGetBoundingBox((CGPathRef)*((void *)this + 1));
  v20.i64[0] = *(void *)&BoundingBox.origin.x;
  v20.i64[1] = *(void *)&BoundingBox.origin.y;
  CGFloat v21 = BoundingBox.size.width + BoundingBox.origin.x;
  v22.f64[0] = 0.0;
  v23.i64[0] = *(void *)&BoundingBox.size.width;
  v23.i64[1] = *(void *)&BoundingBox.size.height;
  int8x16_t v24 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(v22, (float64x2_t)BoundingBox.size).i64[0], 0);
  v22.f64[1] = BoundingBox.size.height;
  v22.f64[0] = -BoundingBox.size.width;
  float64x2_t v25 = (float64x2_t)vbslq_s8(v24, (int8x16_t)v22, v23);
  v26.i64[1] = *(void *)&BoundingBox.origin.y;
  *(CGFloat *)v26.i64 = v21;
  float64x2_t v27 = (float64x2_t)vbslq_s8(v24, v26, v20);
  if (BoundingBox.size.height < 0.0)
  {
    v27.f64[1] = BoundingBox.size.height + BoundingBox.origin.y;
    v25.f64[1] = -BoundingBox.size.height;
  }
  int8x16_t v28 = (int8x16_t)vclezq_f64(v96);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v28, 1), v28).u64[0] & 0x8000000000000000) != 0) {
    return 1;
  }
  int8x16_t v29 = (int8x16_t)vclezq_f64(v25);
  int32x4_t v30 = (int32x4_t)vdupq_laneq_s64((int64x2_t)v29, 1);
  int32x4_t v31 = (int32x4_t)vorrq_s8((int8x16_t)v30, v29);
  if (v31.i64[0] < 0) {
    return 1;
  }
  v31.i32[0] = 1073741822;
  v30.i32[0] = v16;
  v32.i64[0] = (int)v17;
  v32.i64[1] = SHIDWORD(v17);
  float64x2_t v33 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v30, v31), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v32));
  int8x16_t v34 = (int8x16_t)vclezq_f64(vsubq_f64(vminnmq_f64(vaddq_f64(v33, v96), vaddq_f64(v27, v25)), vmaxnmq_f64(v33, v27)));
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v34, 1), v34).u64[0] & 0x8000000000000000) != 0) {
    return 1;
  }
  float64x2_t v97 = v33;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v101 = 0u;
  if (CGPathIsRectWithTransform())
  {
    long long v108 = 0u;
    long long v109 = 0u;
    float64x2_t v106 = 0u;
    long long v107 = 0u;
    if ((fabs(*((double *)&v101 + 1)) >= 0.000001 || fabs(*(double *)&v102) >= 0.000001)
      && (fabs(*(double *)&v101) >= 0.000001 || fabs(*((double *)&v102 + 1)) >= 0.000001)
      && (*(unsigned int (**)(const CA::CG::DrawOp *, float64x2_t *))(*(void *)a3 + 32))(a3, &v106))
    {
      double v36 = *((double *)a2 + 10);
      if (v36 != 1.0)
      {
        for (uint64_t i = 0; i != 64; i += 32)
        {
          float64x2_t v38 = (float64x2_t *)((char *)&v106 + i);
          float64x2_t v39 = vmulq_n_f64(*(float64x2_t *)((char *)&v106 + i + 16), v36);
          *float64x2_t v38 = vmulq_n_f64(*(float64x2_t *)((char *)&v106 + i), v36);
          v38[1] = v39;
        }
      }
    }
    else
    {
      float64x2_t v106 = v97;
      *((void *)&v107 + 1) = *(void *)&v97.f64[1];
      *(double *)&long long v107 = v94 + v97.f64[0];
      *(double *)&long long v108 = v94 + v97.f64[0];
      *((double *)&v108 + 1) = v95 + v97.f64[1];
      *(float64_t *)&long long v109 = v97.f64[0];
      *((double *)&v109 + 1) = v95 + v97.f64[1];
    }
    double v69 = *((double *)&v105 + 1);
    double v68 = *(double *)&v105;
    double v70 = *(double *)&v104 + fmin(*(double *)&v105, -0.0);
    if (*(double *)&v105 < 0.0) {
      double v68 = -*(double *)&v105;
    }
    double v71 = *((double *)&v104 + 1) + fmin(*((double *)&v105 + 1), -0.0);
    if (*((double *)&v105 + 1) < 0.0) {
      double v69 = -*((double *)&v105 + 1);
    }
    float64x2_t v72 = *(float64x2_t *)((char *)a2 + 88);
    float64x2_t v73 = *(float64x2_t *)((char *)a2 + 104);
    float64x2_t v74 = vmlaq_n_f64(vmulq_n_f64(v72, *(double *)&v101), v73, *((double *)&v101 + 1));
    float64x2_t v75 = vmlaq_n_f64(vmulq_n_f64(v72, *(double *)&v102), v73, *((double *)&v102 + 1));
    float64x2_t v76 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)((char *)a2 + 120), v72, *(double *)&v103), v73, *((double *)&v103 + 1)), v74, v70), v75, v71);
    float64x2_t v98 = vmulq_n_f64(v74, v68);
    float64x2_t v99 = vmulq_n_f64(v75, v69);
    float64x2_t v100 = v76;
    CA::Mat2Impl::mat2_invert((CA::Mat2Impl *)&v98, v98.f64, v35);
    BOOL v77 = (const double *)&v106;
    float64x2x2_t v111 = vld2q_f64(v77);
    v77 += 4;
    float64x2_t v78 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v100.f64[0], 0);
    float64x2x2_t v112 = vld2q_f64(v77);
    float64x2_t v79 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v100.f64[1], 0);
    float64x2_t v80 = vmlaq_n_f64(vmlaq_n_f64(v78, v111.val[0], v98.f64[0]), v111.val[1], v99.f64[0]);
    float64x2_t v81 = vmlaq_n_f64(vmlaq_n_f64(v78, v112.val[0], v98.f64[0]), v112.val[1], v99.f64[0]);
    float64x2_t v82 = vmlaq_n_f64(vmlaq_n_f64(v79, v111.val[0], v98.f64[1]), v111.val[1], v99.f64[1]);
    float64x2_t v83 = vmlaq_n_f64(vmlaq_n_f64(v79, v112.val[0], v98.f64[1]), v112.val[1], v99.f64[1]);
    float64x2_t v84 = (float64x2_t)vdupq_n_s64(0xBD3C25C268497682);
    v85.i64[0] = 0x200000002;
    v85.i64[1] = 0x200000002;
    int8x16_t v86 = vandq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_f64(v80, v84), (int32x4_t)vcgtq_f64(v81, v84)), v85);
    float64x2_t v87 = (float64x2_t)vdupq_n_s64(0x3FF00000000001C2uLL);
    *(void *)&v111.val[0].f64[0] = 0x800000008;
    *(void *)&v111.val[0].f64[1] = 0x800000008;
    int8x16_t v88 = vorrq_s8(v86, vandq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_f64(v87, v80), (int32x4_t)vcgtq_f64(v87, v81)), (int8x16_t)v111.val[0]));
    v86.i64[0] = 0x400000004;
    v86.i64[1] = 0x400000004;
    int8x16_t v89 = (int8x16_t)vsubq_s32((int32x4_t)vorrq_s8(v88, vandq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_f64(v82, v84), (int32x4_t)vcgtq_f64(v83, v84)), v86)), vuzp1q_s32((int32x4_t)vcgtq_f64(v87, v82), (int32x4_t)vcgtq_f64(v87, v83)));
    int8x16_t v90 = vmvnq_s8(v89);
    int8x8_t v91 = vand_s8(vand_s8(*(int8x8_t *)v90.i8, (int8x8_t)0xFFFFFFFF0000000FLL), (int8x8_t)*(_OWORD *)&vextq_s8(v90, v90, 8uLL));
    if ((v91.i32[0] & v91.i32[1]) != 0) {
      return 1;
    }
    int8x8_t v93 = vand_s8(*(int8x8_t *)v89.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v89, v89, 8uLL));
    if ((v93.i32[0] & v93.i32[1]) == 15) {
      return 0;
    }
    return 2;
  }
  if (!CGPathIsEllipseWithTransform()) {
    return 2;
  }
  float64x2_t v106 = v97;
  *((void *)&v107 + 1) = *(void *)&v97.f64[1];
  *(double *)&long long v107 = v94 + v97.f64[0];
  *(double *)&long long v108 = v94 + v97.f64[0];
  *((double *)&v108 + 1) = v95 + v97.f64[1];
  *(float64_t *)&long long v109 = v97.f64[0];
  *((double *)&v109 + 1) = v95 + v97.f64[1];
  double v45 = *((double *)&v105 + 1);
  double v44 = *(double *)&v105;
  double v46 = *(double *)&v104 + fmin(*(double *)&v105, -0.0);
  if (*(double *)&v105 < 0.0) {
    double v44 = -*(double *)&v105;
  }
  double v47 = *((double *)&v104 + 1) + fmin(*((double *)&v105 + 1), -0.0);
  if (*((double *)&v105 + 1) < 0.0) {
    double v45 = -*((double *)&v105 + 1);
  }
  float64x2_t v48 = *(float64x2_t *)((char *)a2 + 88);
  float64x2_t v49 = *(float64x2_t *)((char *)a2 + 104);
  float64x2_t v50 = vmlaq_n_f64(vmulq_n_f64(v48, *(double *)&v101), v49, *((double *)&v101 + 1));
  float64x2_t v51 = vmlaq_n_f64(vmulq_n_f64(v48, *(double *)&v102), v49, *((double *)&v102 + 1));
  float64x2_t v52 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)((char *)a2 + 120), v48, *(double *)&v103), v49, *((double *)&v103 + 1)), v50, v46), v51, v47);
  float64x2_t v98 = vmulq_n_f64(v50, v44);
  float64x2_t v99 = vmulq_n_f64(v51, v45);
  __asm { FMOV            V1.2D, #0.5 }
  float64x2_t v100 = vmlaq_f64(v52, _Q1, vaddq_f64(v99, v98));
  CA::Mat2Impl::mat2_invert((CA::Mat2Impl *)&v98, v98.f64, v43);
  uint64_t v58 = 0;
  float64x2_t v59 = v98;
  float64x2_t v60 = v99;
  LOBYTE(v61) = 15;
  char v62 = 1;
  float64x2_t v63 = v100;
  do
  {
    _Q6 = vmlaq_n_f64(vmlaq_n_f64(v63, v59, v106.f64[v58]), v60, v106.f64[v58 + 1]);
    *(float64x2_t *)((char *)&v106 + v58 * 8) = _Q6;
    _D7 = _Q6.f64[1];
    int v61 = (((8 * (_Q6.f64[0] > 0.5)) | (2 * (_Q6.f64[0] < -0.5)) | (4 * (_Q6.f64[1] < -0.5)) | (_Q6.f64[1] > 0.5)) & v61);
    __asm { FMLA            D16, D7, V6.D[1] }
    v62 &= _D16 < 0.25;
    v58 += 2;
  }
  while (v58 != 8);
  BOOL v42 = v61 != 0;
  char v67 = v61 ? 1 : v62;
  if ((v67 & 1) == 0) {
    return 2;
  }
  return v42;
}

uint64_t CA::CG::ClipPath::type(CA::CG::ClipPath *this)
{
  return 5;
}

void CA::CG::ClipPath::~ClipPath(CA::CG::Renderer **this, const void *a2)
{
  *this = (CA::CG::Renderer *)&unk_1ED029E50;
  CA::CG::Renderer::release_object(this[1], a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  *this = (CA::CG::Renderer *)&unk_1ED029E50;
  CA::CG::Renderer::release_object(this[1], a2);
}

__n128 CA::CG::ClipImage::draw(CA::CG::ClipImage *this, CA::CG::Renderer *a2, double a3, int64x2_t a4, int64x2_t a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  a4.i64[0] = (uint64_t)v13;
  a5.i64[0] = (uint64_t)a2 + 88;
  int8x16_t v5 = (int8x16_t)vdupq_lane_s64(vmvnq_s8((int8x16_t)vceqq_s64(a5, a4)).i64[0], 0);
  float64x2_t v6 = (float64x2_t)vandq_s8(*(int8x16_t *)((char *)a2 + 120), v5);
  float64x2_t v7 = (float64x2_t)vandq_s8(*(int8x16_t *)((char *)a2 + 104), v5);
  float64x2_t v8 = (float64x2_t)vandq_s8(*(int8x16_t *)((char *)a2 + 88), v5);
  double v9 = *((double *)this + 6);
  double v10 = *((double *)this + 7);
  float64x2_t v11 = vmlaq_n_f64(vmulq_n_f64(v8, *((double *)this + 4)), v7, *((double *)this + 5));
  v13[0] = vmlaq_n_f64(vmulq_n_f64(v8, *((double *)this + 2)), v7, *((double *)this + 3));
  v13[1] = v11;
  v13[2] = vmlaq_n_f64(vmlaq_n_f64(v6, v8, v9), v7, v10);
  CA::CG::fill_image((uint64_t)a2);
  return result;
}

uint64_t CA::CG::ClipItem::prepare()
{
  return 2;
}

uint64_t CA::CG::ClipImage::type(CA::CG::ClipImage *this)
{
  return 6;
}

void CA::CG::ClipImage::~ClipImage(CA::CG::Renderer **this, const void *a2)
{
  *this = (CA::CG::Renderer *)&unk_1ED02A0B8;
  CA::CG::Renderer::release_object(this[1], a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  *this = (CA::CG::Renderer *)&unk_1ED02A0B8;
  CA::CG::Renderer::release_object(this[1], a2);
}

uint64_t CA::CG::ClipRectFill::draw(CA::CG::ClipRectFill *this, CA::CG::Renderer *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)a2 + 1);
  float64x2_t v4 = (double *)((char *)a2 + 88);
  int8x16_t v5 = (char *)this + 8;
  uint64_t v6 = CA::CG::mat2_filter_bits((uint64_t)a2 + 88);
  LODWORD(v4) = CA::CG::rect_filter_bits((uint64_t)v5, v4, v6, v7, v8, v9, v10, v11);
  uint64_t v19 = 0;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v16 = 0u;
  memset(v15, 0, sizeof(v15));
  CA::Transform::set_affine((CA::Transform *)v15, *((double *)a2 + 11), *((double *)a2 + 12), *((double *)a2 + 13), *((double *)a2 + 14), *((double *)a2 + 15), *((double *)a2 + 16));
  *((void *)&v16 + 1) = v5;
  *(void *)&long long v17 = v15;
  *((void *)&v17 + 1) = v4 | 0xFF00000000;
  uint64_t v19 = 0;
  long long v18 = 0uLL;
  return CA::OGL::fill_rect(v3, (uint64_t)&v16 + 8, v12, v13);
}

uint64_t CA::CG::ClipRectFill::prepare(CA::CG::ClipRectFill *this, CA::CG::Renderer *a2, const CA::CG::DrawOp *a3, int32x2_t *a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  long long v34 = 0u;
  *(_OWORD *)float64x2_t v35 = 0u;
  double v5 = *((double *)a2 + 10);
  if (v5 == 1.0)
  {
    uint64_t v6 = (float64x2_t *)((char *)this + 8);
  }
  else
  {
    long long v7 = *(_OWORD *)((char *)this + 8);
    long long v8 = *(_OWORD *)((char *)this + 24);
    long long v34 = v7;
    *(_OWORD *)float64x2_t v35 = v8;
    if (*(double *)&v8 < 1.79769313e308)
    {
      *(double *)&long long v34 = v5 * *(double *)&v7;
      v35[0] = *(double *)&v8 * v5;
    }
    if (*((double *)&v8 + 1) < 1.79769313e308)
    {
      *((double *)&v34 + 1) = *((double *)&v7 + 1) * v5;
      v35[1] = *((double *)&v8 + 1) * v5;
    }
    uint64_t v6 = (float64x2_t *)&v34;
  }
  float64x2_t v9 = v6[1];
  if (*((unsigned char *)this + 40))
  {
    double v10 = v6[1].f64[1];
    if (v9.f64[0] > v9.f64[1]) {
      double v10 = v6[1].f64[0];
    }
    if (v10 < 1073741820.0)
    {
      v16.f64[0] = NAN;
      v16.f64[1] = NAN;
      int8x16_t v17 = (int8x16_t)vnegq_f64(v16);
      __asm { FMOV            V4.2D, #0.5 }
      int32x2_t v11 = vmovn_s64(vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8(v17, _Q4, *(int8x16_t *)v6), *v6)));
      int8x16_t v23 = (int8x16_t)vaddq_f64(*v6, v9);
      int32x2_t v12 = vsub_s32(vmovn_s64(vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8(v17, _Q4, v23), (float64x2_t)v23))), v11);
    }
    else
    {
      int32x2_t v11 = vdup_n_s32(0xE0000001);
      int32x2_t v12 = (int32x2_t)0xC0000000C0000000;
    }
    *(int32x2_t *)v33.i8 = v11;
    v33.u64[1] = (unint64_t)v12;
  }
  else
  {
    int8x16_t v13 = (int8x16_t)vceqzq_f64(v9);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v13, 1), v13).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v14 = vorrq_s8((int8x16_t)vcltzq_f64(v9), (int8x16_t)vcgezq_f64(v9)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v14), 1), v14).u64[0] & 0x8000000000000000) != 0))
    {
      int32x4_t v33 = 0uLL;
      int32x2_t v12 = 0;
    }
    else
    {
      int32x4_t v15 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(*v6, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      int32x4_t v33 = vuzp1q_s32(v15, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(*v6, v9), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v15));
      int32x2_t v12 = (int32x2_t)v33.u64[1];
    }
  }
  int32x2_t v32 = v12;
  if (CA::BoundsImpl::contains(&v33, a4)) {
    return 0;
  }
  int32x2_t v25 = a4[1];
  uint32x2_t v26 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v25);
  if ((vpmax_u32(v26, v26).u32[0] & 0x80000000) == 0)
  {
    uint32x2_t v27 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v32);
    if ((vpmax_u32(v27, v27).u32[0] & 0x80000000) == 0)
    {
      int32x2_t v28 = vadd_s32(*a4, v25);
      *(int32x2_t *)&long long v29 = vmax_s32(*a4, *(int32x2_t *)v33.i8);
      int32x2_t v30 = vsub_s32(vmin_s32(v28, vadd_s32(*(int32x2_t *)v33.i8, v32)), *(int32x2_t *)&v29);
      uint32x2_t v31 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v30);
      if ((vpmax_u32(v31, v31).u32[0] & 0x80000000) == 0)
      {
        *((int32x2_t *)&v29 + 1) = v30;
        *(_OWORD *)a4->i8 = v29;
        return 2 * ((*(void *)&a4[6] | *(void *)&a4[2]) != 0);
      }
    }
    a4[1] = 0;
  }
  return 1;
}

uint64_t CA::CG::ClipRectFill::type(CA::CG::ClipRectFill *this)
{
  return 1;
}

void CA::CG::ClipRectFill::~ClipRectFill(CA::CG::ClipRectFill *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::CG::ClipRectStroke::draw(CA::CG::ClipRectStroke *this, CA::CG::Renderer *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)a2 + 1);
  double v5 = (double *)((char *)a2 + 88);
  long long v6 = *(_OWORD *)((char *)this + 24);
  v19[0] = *(_OWORD *)((char *)this + 8);
  v19[1] = v6;
  double v7 = *((double *)this + 5);
  CA::BoundsImpl::inset((double *)v19, v7 * -0.5, v7 * -0.5);
  uint64_t v8 = CA::CG::mat2_filter_bits((uint64_t)v5);
  unsigned int v14 = CA::CG::rect_filter_bits((uint64_t)v19, v5, v8, v9, v10, v11, v12, v13);
  BOOL v15 = *((unsigned char *)this + 48) == 0;
  uint64_t v24 = 0;
  if (v15) {
    int v16 = 0;
  }
  else {
    int v16 = 255;
  }
  long long v22 = 0u;
  long long v23 = 0u;
  long long v21 = 0u;
  memset(v20, 0, sizeof(v20));
  CA::Transform::set_affine((CA::Transform *)v20, *((double *)a2 + 11), *((double *)a2 + 12), *((double *)a2 + 13), *((double *)a2 + 14), *((double *)a2 + 15), *((double *)a2 + 16));
  *((void *)&v21 + 1) = v19;
  *(void *)&long long v22 = v20;
  *((void *)&v22 + 1) = __PAIR64__(v16, v14);
  uint64_t v24 = 0;
  long long v23 = 0uLL;
  CA::OGL::stroke_rect(v4, (const CA::Transform **)&v21 + 1, v17, v18, v7);
}

uint64_t CA::CG::ClipRectStroke::type(CA::CG::ClipRectStroke *this)
{
  return 2;
}

void CA::CG::ClipRectStroke::~ClipRectStroke(CA::CG::ClipRectStroke *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::CG::ClipEllipseFill::draw(CA::CG::ClipEllipseFill *this, CA::CG::Renderer *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  double v4 = *((double *)this + 1);
  double v3 = *((double *)this + 2);
  *(double *)int8x16_t v12 = v4;
  *(double *)&v12[1] = v3;
  double v6 = *((double *)this + 3);
  double v5 = *((double *)this + 4);
  *(double *)&_DWORD v12[2] = v6;
  double v13 = v5;
  float64x2_t v7 = *(float64x2_t *)((char *)a2 + 88);
  float64x2_t v8 = *(float64x2_t *)((char *)a2 + 104);
  float64x2_t v9 = *(float64x2_t *)((char *)a2 + 120);
  if (v6 != v5)
  {
    float64x2_t v10 = vmlaq_n_f64(vmlaq_n_f64(v9, v7, v4), v8, v3);
    float64x2_t v8 = vmulq_n_f64(v8, v5 / v6);
    float64x2_t v9 = vmlsq_lane_f64(vmlsq_lane_f64(v10, v7, v4, 0), v8, v3, 0);
    double v13 = v6;
  }
  long long v16 = 0u;
  long long v17 = 0u;
  long long v15 = 0u;
  memset(v14, 0, sizeof(v14));
  uint64_t v18 = 0;
  CA::Transform::set_affine((CA::Transform *)v14, v7.f64[0], v7.f64[1], v8.f64[0], v8.f64[1], v9.f64[0], v9.f64[1]);
  *((void *)&v15 + 1) = v12;
  *(void *)&long long v16 = v14;
  *((void *)&v16 + 1) = 0xFF0020003FLL;
  uint64_t v18 = 0;
  long long v17 = 0uLL;
  return CA::OGL::fill_round_rect(*((void *)a2 + 1), (float64x2_t **)&v15 + 1, (double *)0xF, 0, v6 * 0.5, v6 * 0.5);
}

uint64_t CA::CG::ClipEllipseFill::prepare(CA::CG::ClipEllipseFill *this, CA::CG::Renderer *a2, const CA::CG::DrawOp *a3, CA::CG::ClipOp *a4, double a5, double a6, double a7, double a8, float64x2_t a9, int32x4_t a10)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  float64x2_t v10 = *(float64x2_t *)((char *)this + 8);
  float64x2_t v11 = *(float64x2_t *)((char *)this + 24);
  double v12 = *((double *)a2 + 10);
  if (v12 != 1.0)
  {
    a9.f64[0] = 1.79769313e308;
    int8x16_t v13 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a9, v11).i64[0], 0);
    v14.i64[1] = *((void *)this + 2);
    *(double *)v14.i64 = v12 * v10.f64[0];
    float64x2_t v10 = (float64x2_t)vbslq_s8(v13, v14, (int8x16_t)v10);
    *(double *)a10.i64 = v12 * v11.f64[0];
    v14.i64[1] = *((void *)this + 4);
    *(double *)v14.i64 = v12 * v11.f64[0];
    float64x2_t v11 = (float64x2_t)vbslq_s8(v13, v14, (int8x16_t)v11);
    if (v11.f64[1] < 1.79769313e308)
    {
      v10.f64[1] = vmuld_lane_f64(v12, v10, 1);
      v11.f64[1] = v11.f64[1] * v12;
    }
  }
  uint64_t v15 = *((void *)a4 + 1);
  v16.i64[0] = (int)v15;
  v16.i64[1] = SHIDWORD(v15);
  int64x2_t v17 = v16;
  int v18 = v15;
  if ((int)v15 <= SHIDWORD(v15)) {
    int v18 = HIDWORD(*((void *)a4 + 1));
  }
  int8x16_t v19 = (int8x16_t)vcvtq_f64_s64(v17);
  int32x2_t v20 = vdup_n_s32(v18 > 1073741822);
  v21.i64[0] = v20.u32[0];
  v21.i64[1] = v20.u32[1];
  float64x2_t v22 = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v21, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v19);
  int64x2_t v23 = vclezq_f64(v22);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v23, 1), (int8x16_t)v23).u64[0] & 0x8000000000000000) != 0) {
    return 1;
  }
  int64x2_t v24 = vclezq_f64(v11);
  int32x4_t v25 = (int32x4_t)vdupq_laneq_s64(v24, 1);
  if ((vorrq_s8((int8x16_t)v25, (int8x16_t)v24).u64[0] & 0x8000000000000000) != 0) {
    return 1;
  }
  v26.i64[0] = (int)*(void *)a4;
  v26.i64[1] = (int)HIDWORD(*(void *)a4);
  v25.i32[0] = v18;
  a10.i32[0] = 1073741822;
  float64x2_t v27 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v25, a10), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v26));
  int64x2_t v28 = vclezq_f64(vsubq_f64(vminnmq_f64(vaddq_f64(v27, v22), vaddq_f64(v10, v11)), vmaxnmq_f64(v27, v10)));
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v28, 1), (int8x16_t)v28).u64[0] & 0x8000000000000000) != 0) {
    return 1;
  }
  __asm { FMOV            V4.2D, #0.5 }
  int8x16_t v33 = (int8x16_t)vsubq_f64(v27, vmlaq_f64(v10, _Q4, v11));
  double v34 = 2.0 / v11.f64[0];
  double v35 = 2.0 / v11.f64[1];
  _ZF = v22.f64[0] >= 1.79769313e308 || v34 == 1.0;
  v37.i64[1] = v33.i64[1];
  *(double *)v37.i64 = v34 * *(double *)v33.i64;
  v38.i64[1] = *(void *)&v22.f64[1];
  *(double *)v38.i64 = v34 * v22.f64[0];
  if (_ZF) {
    unint64_t v39 = 0;
  }
  else {
    unint64_t v39 = -1;
  }
  int8x16_t v40 = (int8x16_t)vdupq_n_s64(v39);
  float64x2_t v41 = (float64x2_t)vbslq_s8(v40, v38, (int8x16_t)v22);
  float64x2_t v42 = (float64x2_t)vbslq_s8(v40, v37, v33);
  if (v35 != 1.0 && v41.f64[1] < 1.79769313e308)
  {
    v42.f64[1] = vmuld_lane_f64(v35, v42, 1);
    v41.f64[1] = v41.f64[1] * v35;
  }
  unint64_t v43 = 0;
  *(void *)&long long v44 = *(_OWORD *)&vaddq_f64(v41, v42);
  *((void *)&v44 + 1) = *(void *)&v42.f64[1];
  v50[0] = v42;
  v50[1] = v44;
  uint64_t v51 = v44;
  double v52 = v41.f64[1] + v42.f64[1];
  float64_t v53 = v42.f64[0];
  double v54 = v41.f64[1] + v42.f64[1];
  do
  {
    double v45 = vaddvq_f64(vmulq_f64((float64x2_t)v50[v43], (float64x2_t)v50[v43]));
    if (v43 > 2) {
      break;
    }
    ++v43;
  }
  while (v45 < 1.0);
  if (v45 < 1.0) {
    return 0;
  }
  v41.f64[0] = v41.f64[0] * 0.5;
  v42.f64[0] = fabs(v42.f64[0] + v41.f64[0]);
  double v47 = fabs(v42.f64[1] + v41.f64[1] * 0.5);
  if ((v42.f64[0] - v41.f64[0]) * (v42.f64[0] - v41.f64[0]) + (v47 - v41.f64[1] * 0.5) * (v47 - v41.f64[1] * 0.5) <= 1.0
    || v42.f64[0] <= v41.f64[0]
    || v47 <= v41.f64[1] * 0.5)
  {
    return 2;
  }
  else
  {
    return 1;
  }
}

uint64_t CA::CG::ClipEllipseFill::type(CA::CG::ClipEllipseFill *this)
{
  return 3;
}

void CA::CG::ClipEllipseFill::~ClipEllipseFill(CA::CG::ClipEllipseFill *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::CG::ClipRoundedRectFill::draw(CA::CG::ClipRoundedRectFill *this, CA::CG::Renderer *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  double v3 = *((double *)this + 1);
  double v15 = v3;
  long long v4 = *((_OWORD *)this + 1);
  long long v16 = v4;
  double v5 = *((double *)this + 4);
  double v6 = *((double *)this + 5);
  double v17 = v5;
  float64x2_t v7 = *(float64x2_t *)((char *)a2 + 88);
  float64x2_t v8 = *(float64x2_t *)((char *)a2 + 104);
  float64x2_t v9 = *(float64x2_t *)((char *)a2 + 120);
  double v10 = *((double *)this + 6);
  double v11 = v6 - v10;
  if (v6 - v10 < 0.0) {
    double v11 = -(v6 - v10);
  }
  if (v11 > 0.001)
  {
    double v12 = v10 / v6;
    float64x2_t v13 = vmlaq_n_f64(vmlaq_n_f64(v9, v7, v3), v8, *(double *)&v4);
    float64x2_t v8 = vmulq_n_f64(v8, v12);
    float64x2_t v9 = vmlsq_lane_f64(vmlsq_lane_f64(v13, v7, v3, 0), v8, *(double *)&v4, 0);
    double v17 = v5 / v12;
  }
  long long v20 = 0u;
  long long v21 = 0u;
  long long v19 = 0u;
  memset(v18, 0, sizeof(v18));
  uint64_t v22 = 0;
  CA::Transform::set_affine((CA::Transform *)v18, v7.f64[0], v7.f64[1], v8.f64[0], v8.f64[1], v9.f64[0], v9.f64[1]);
  *((void *)&v19 + 1) = &v15;
  *(void *)&long long v20 = v18;
  *((void *)&v20 + 1) = 0xFF0020003FLL;
  uint64_t v22 = 0;
  long long v21 = 0uLL;
  return CA::OGL::fill_round_rect(*((void *)a2 + 1), (float64x2_t **)&v19 + 1, (double *)0xF, 0, v6, v6);
}

uint64_t CA::CG::ClipRoundedRectFill::prepare(CA::CG::ClipRoundedRectFill *this, CA::CG::Renderer *a2, const CA::CG::DrawOp *a3, int32x2_t *a4, double a5, double a6, double a7, double a8, float64x2_t a9)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  int8x16_t v10 = *(int8x16_t *)((char *)this + 8);
  int8x16_t v11 = *(int8x16_t *)((char *)this + 24);
  double v12 = *((double *)this + 4);
  if (*(double *)v11.i64 <= v12) {
    double v13 = *((double *)this + 4);
  }
  else {
    double v13 = *((double *)this + 3);
  }
  BOOL v14 = v13 < 1.79769313e308;
  int8x16_t v15 = *(int8x16_t *)((char *)this + 8);
  int8x16_t v16 = *(int8x16_t *)((char *)this + 24);
  int8x16_t v17 = v16;
  int8x16_t v18 = v15;
  if (v14)
  {
    if (*(double *)v11.i64 >= v12) {
      double v19 = *((double *)this + 4);
    }
    else {
      double v19 = *((double *)this + 3);
    }
    BOOL v23 = v19 <= 0.0;
    int8x16_t v16 = *(int8x16_t *)((char *)this + 24);
    int8x16_t v15 = *(int8x16_t *)((char *)this + 8);
    if (!v23)
    {
      double v20 = *((double *)this + 5);
      v15.i64[1] = *((void *)this + 2);
      *(double *)v15.i64 = *(double *)v10.i64 + v20;
      double v21 = *(double *)v11.i64 - (v20 + v20);
      v22.i64[1] = *((void *)this + 4);
      *(double *)v22.i64 = v21;
      BOOL v23 = v12 > 0.0 && v21 > 0.0;
      if (v23) {
        unint64_t v24 = -1;
      }
      else {
        unint64_t v24 = 0;
      }
      int8x16_t v16 = vandq_s8(v22, (int8x16_t)vdupq_n_s64(v24));
    }
    if (*(double *)v11.i64 >= v12) {
      double v25 = *((double *)this + 4);
    }
    else {
      double v25 = *((double *)this + 3);
    }
    if (v25 > 0.0)
    {
      double v26 = *((double *)this + 6);
      v18.i64[0] = *((void *)this + 1);
      *(double *)&v18.i64[1] = *(double *)&v10.i64[1] + v26;
      double v27 = v12 - (v26 + v26);
      v28.i64[0] = *((void *)this + 3);
      *(double *)&v28.i64[1] = v27;
      if (v27 > 0.0 && *(double *)v11.i64 > 0.0) {
        unint64_t v30 = -1;
      }
      else {
        unint64_t v30 = 0;
      }
      int8x16_t v17 = vandq_s8(v28, (int8x16_t)vdupq_n_s64(v30));
    }
    else
    {
      int8x16_t v17 = *(int8x16_t *)((char *)this + 24);
      int8x16_t v18 = *(int8x16_t *)((char *)this + 8);
    }
  }
  double v31 = *((double *)a2 + 10);
  if (v31 != 1.0)
  {
    a9.f64[0] = 1.79769313e308;
    int8x16_t v32 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a9, (float64x2_t)v11).i64[0], 0);
    v33.i64[1] = *((void *)this + 2);
    *(double *)v33.i64 = v31 * *(double *)v10.i64;
    int8x16_t v10 = vbslq_s8(v32, v33, v10);
    v33.i64[1] = *((void *)this + 4);
    *(double *)v33.i64 = *(double *)v11.i64 * v31;
    int8x16_t v11 = vbslq_s8(v32, v33, v11);
    if (*(double *)&v11.i64[1] < 1.79769313e308)
    {
      v10.i64[1] = vmuld_lane_f64(v31, (float64x2_t)v10, 1);
      *(double *)&v11.i64[1] = *(double *)&v11.i64[1] * v31;
    }
    a9.f64[0] = 1.79769313e308;
    int8x16_t v34 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a9, (float64x2_t)v16).i64[0], 0);
    v35.i64[1] = v15.i64[1];
    *(double *)v35.i64 = v31 * *(double *)v15.i64;
    int8x16_t v15 = vbslq_s8(v34, v35, v15);
    v35.i64[1] = v16.i64[1];
    *(double *)v35.i64 = v31 * *(double *)v16.i64;
    int8x16_t v16 = vbslq_s8(v34, v35, v16);
    if (*(double *)&v16.i64[1] < 1.79769313e308)
    {
      v15.i64[1] = vmuld_lane_f64(v31, (float64x2_t)v15, 1);
      *(double *)&v16.i64[1] = *(double *)&v16.i64[1] * v31;
    }
    a9.f64[0] = 1.79769313e308;
    int8x16_t v36 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a9, (float64x2_t)v17).i64[0], 0);
    v37.i64[1] = v18.i64[1];
    *(double *)v37.i64 = v31 * *(double *)v18.i64;
    int8x16_t v18 = vbslq_s8(v36, v37, v18);
    v37.i64[1] = v17.i64[1];
    *(double *)v37.i64 = v31 * *(double *)v17.i64;
    int8x16_t v17 = vbslq_s8(v36, v37, v17);
    if (*(double *)&v17.i64[1] < 1.79769313e308)
    {
      v18.i64[1] = vmuld_lane_f64(v31, (float64x2_t)v18, 1);
      *(double *)&v17.i64[1] = *(double *)&v17.i64[1] * v31;
    }
  }
  int8x16_t v38 = (int8x16_t)vceqzq_f64((float64x2_t)v16);
  float64x2_t v58 = (float64x2_t)v10;
  float64x2_t v59 = (float64x2_t)v18;
  float64x2_t v60 = (float64x2_t)v11;
  float64x2_t v61 = (float64x2_t)v17;
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v38, 1), v38).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v39 = vorrq_s8((int8x16_t)vcltzq_f64((float64x2_t)v16), (int8x16_t)vcgezq_f64((float64x2_t)v16)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v39), 1), v39).u64[0] & 0x8000000000000000) != 0))
  {
    int32x4_t v62 = 0uLL;
  }
  else
  {
    float64x2_t v40 = vmaxnmq_f64((float64x2_t)v15, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000));
    float64x2_t v41 = vminnmq_f64(vaddq_f64((float64x2_t)v15, (float64x2_t)v16), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
    int32x4_t v42 = (int32x4_t)vcvtpq_s64_f64(v40);
    int32x4_t v62 = vuzp1q_s32(v42, (int32x4_t)vsubq_s64(vcvtmq_s64_f64(v41), (int64x2_t)v42));
  }
  if (CA::BoundsImpl::contains(&v62, a4)) {
    return 0;
  }
  int8x16_t v43 = (int8x16_t)vceqzq_f64(v61);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v43, 1), v43).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v44 = vorrq_s8((int8x16_t)vcltzq_f64(v61), (int8x16_t)vcgezq_f64(v61)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v44), 1), v44).u64[0] & 0x8000000000000000) != 0))
  {
    int32x4_t v62 = 0uLL;
  }
  else
  {
    int32x4_t v45 = (int32x4_t)vcvtpq_s64_f64(vmaxnmq_f64(v59, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    int32x4_t v62 = vuzp1q_s32(v45, (int32x4_t)vsubq_s64(vcvtmq_s64_f64(vminnmq_f64(vaddq_f64(v59, v61), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v45));
  }
  if (CA::BoundsImpl::contains(&v62, a4)) {
    return 0;
  }
  int8x16_t v47 = (int8x16_t)vceqzq_f64(v60);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v47, 1), v47).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v48 = vorrq_s8((int8x16_t)vcltzq_f64(v60), (int8x16_t)vcgezq_f64(v60)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v48), 1), v48).u64[0] & 0x8000000000000000) != 0))
  {
    v50.i64[0] = 0;
    int32x2_t v51 = 0;
  }
  else
  {
    int32x4_t v49 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v58, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    int32x4_t v50 = vuzp1q_s32(v49, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v58, v60), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v49));
    int32x2_t v51 = (int32x2_t)v50.u64[1];
  }
  int32x2_t v52 = a4[1];
  uint32x2_t v53 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v52);
  if ((vpmax_u32(v53, v53).u32[0] & 0x80000000) == 0)
  {
    uint32x2_t v54 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v51);
    if ((vpmax_u32(v54, v54).u32[0] & 0x80000000) == 0)
    {
      int32x2_t v55 = vadd_s32(*(int32x2_t *)v50.i8, v51);
      *(int32x2_t *)v50.i8 = vmax_s32(*a4, *(int32x2_t *)v50.i8);
      int32x2_t v56 = vsub_s32(vmin_s32(vadd_s32(*a4, v52), v55), *(int32x2_t *)v50.i8);
      uint32x2_t v57 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v56);
      if ((vpmax_u32(v57, v57).u32[0] & 0x80000000) == 0)
      {
        v50.u64[1] = (unint64_t)v56;
        *(int32x4_t *)a4->i8 = v50;
        return 2;
      }
    }
    a4[1] = 0;
  }
  return 1;
}

uint64_t CA::CG::ClipRoundedRectFill::type(CA::CG::ClipRoundedRectFill *this)
{
  return 4;
}

void CA::CG::ClipRoundedRectFill::~ClipRoundedRectFill(CA::CG::ClipRoundedRectFill *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::CG::ClipStack::destroy_clip_stack(void (***this)(char *))
{
  if (*((_DWORD *)this + 1))
  {
    unsigned int v2 = 0;
    do
    {
      (*this[13 * (int)v2 + 7])((char *)&this[13 * (int)v2 + 7]);
      ++v2;
    }
    while (v2 < *((_DWORD *)this + 1));
  }

  free(this);
}

uint64_t CA::CG::ClipOp::draw(CA::CG::ClipOp *this, CA::CG::Renderer *a2)
{
  uint64_t v4 = *((void *)a2 + 1);
  *(void *)(*(void *)(v4 + 16) + 8) = 0x3C003C003C003C00;
  uint64_t result = *((void *)this + 3);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, CA::CG::Renderer *))(*(void *)result + 32))(result, a2);
    *(unsigned char *)(*(void *)(v4 + 16) + 481) |= 1u;
  }
  unint64_t v6 = *((void *)this + 6);
  if (v6)
  {
    unint64_t v7 = 0;
    uint64_t v8 = -1;
    do
    {
      uint64_t v9 = *(void *)(*((void *)this + 5) + 8 * (v6 + v8));
      uint64_t result = (*(uint64_t (**)(uint64_t, CA::CG::Renderer *))(*(void *)v9 + 32))(v9, a2);
      *(unsigned char *)(*(void *)(v4 + 16) + 481) |= 1u;
      ++v7;
      unint64_t v6 = *((void *)this + 6);
      --v8;
    }
    while (v7 < v6);
  }
  return result;
}

uint64_t CA::Render::EmitterLayer::visit_subclass(uint64_t a1, uint64_t (***a2)(void, uint64_t))
{
  return (**a2)(a2, a1);
}

uint64_t CA::Render::EmitterLayer::get_volume(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3 || !*(_DWORD *)(v3 + 124)) {
    return 0;
  }
  long long v4 = *(_OWORD *)(v3 + 32);
  long long v5 = *(_OWORD *)(v3 + 64);
  a3[1] = *(_OWORD *)(v3 + 48);
  a3[2] = v5;
  *a3 = v4;
  return 1;
}

uint64_t CA::Render::EmitterLayer::get_bounds(CA::Render::EmitterLayer *this, const CA::Render::Layer *a2, int64x2_t *a3, CA::Rect *a4)
{
  uint64_t v4 = *((void *)this + 3);
  if (!v4 || !*(_DWORD *)(v4 + 124)) {
    return 0;
  }
  double v5 = *(double *)(v4 + 32);
  double v6 = *(double *)(v4 + 40);
  double v7 = *(double *)(v4 + 64);
  double v8 = *(double *)(v4 + 56) - v5;
  double v9 = v7 - v6;
  if (v8 >= v7 - v6) {
    double v10 = v7 - v6;
  }
  else {
    double v10 = *(double *)(v4 + 56) - v5;
  }
  if (v10 > 0.0)
  {
    if (v8 <= v9) {
      double v11 = v9;
    }
    else {
      double v11 = *(double *)(v4 + 56) - v5;
    }
    if (v11 >= 1.79769313e308)
    {
      *a3 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
      a3[1] = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      if (!a4) {
        return 1;
      }
    }
    else
    {
      *(double *)a3->i64 = v5;
      *(double *)&a3->i64[1] = v6;
      *(double *)a3[1].i64 = v8;
      *(double *)&a3[1].i64[1] = v9;
      if (!a4) {
        return 1;
      }
    }
    goto LABEL_15;
  }
  *a3 = 0u;
  a3[1] = 0u;
  if (a4)
  {
LABEL_15:
    *(_OWORD *)a4 = 0u;
    *((_OWORD *)a4 + 1) = 0u;
  }
  return 1;
}

uint64_t CA::Render::EmitterLayer::has_depth(CA::Render::EmitterLayer *this)
{
  return *((unsigned char *)this + 13) & 1;
}

void CA::Render::EmitterLayer::update(CA::Render::EmitterLayer *this@<X0>, CA::Render::Update *a2@<X1>, double a3@<D0>, double a4@<D1>, uint64_t a5@<X8>)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *((void *)this + 3);
  if (!v7 || (*((_DWORD *)a2 + 271) & 4) != 0)
  {
    double v18 = INFINITY;
  }
  else
  {
    double v19 = INFINITY;
    double v10 = *((double *)this + 20) + a4 * -0.00416666667;
    os_unfair_lock_lock((os_unfair_lock_t)(v7 + 24));
    double v11 = *(double *)(v7 + 88);
    if (vabdd_f64(a3, v11) <= v10)
    {
      double v18 = v11 + v10;
    }
    else
    {
      *(_DWORD *)(v7 + 80) = 0;
      *(_OWORD *)(v7 + 32) = CA::Volume::null;
      *(_OWORD *)(v7 + 48) = unk_1849A7DA0;
      *(_OWORD *)(v7 + 64) = xmmword_1849A7DB0;
      if (v11 != a3) {
        *(unsigned char *)(v7 + 129) = v11 < a3;
      }
      *(_DWORD *)(v7 + 168) = 0;
      *(void *)(v7 + 136) = this;
      long long v20 = 0u;
      long long v21 = 0u;
      int v12 = *((_DWORD *)this + 33);
      if ((*((_DWORD *)this + 32) & 0x7FFFFFFFu) >= 0x7F800000
        && (v12 & 0x7FFFFFFFu) >= 0x7F800000
        && (*((_DWORD *)this + 36) & 0x7FFFFFFFu) >= 0x7F800000
        && (*((_DWORD *)this + 37) & 0x7FFFFFFFu) >= 0x7F800000
        && (*((_DWORD *)this + 35) & 0x7FFFFFFFu) > 0x7F7FFFFF)
      {
        BOOL v14 = 0;
      }
      else
      {
        LODWORD(v20) = *((_DWORD *)this + 32);
        DWORD1(v20) = v12;
        int v13 = *((_DWORD *)this + 37);
        DWORD2(v20) = *((_DWORD *)this + 36);
        *(void *)&long long v21 = *((void *)this + 17);
        DWORD2(v21) = v13;
        BOOL v14 = &v20;
      }
      uint64_t v15 = *(void *)(v7 + 144);
      *(void *)(v7 + 176) = v14;
      if (*(void *)(v7 + 152) != v15) {
        *(void *)(v7 + 152) = v15;
      }
      *(unsigned char *)(v7 + 128) = CA::Render::EmitterState::update_cells((CA::Render::EmitterState *)v7, &v19, *((void *)this + 4), v7 + 112, 0, a3, *((float *)this + 19));
      if ((*((unsigned char *)this + 13) & 1) == 0)
      {
        *(void *)(v7 + 72) = 0;
        *(void *)(v7 + 48) = 0;
      }
      uint64_t v16 = *(void *)(v7 + 144);
      if (*(void *)(v7 + 152) != v16) {
        *(void *)(v7 + 152) = v16;
      }
      *(void *)(v7 + 136) = 0;
      *(void *)(v7 + 176) = 0;
      *(double *)(v7 + 88) = a3;
      double v17 = v10 + a3;
      if (v19 > v10 + a3) {
        double v17 = v19;
      }
      if (*((double *)this + 20) == 0.0) {
        double v18 = v19;
      }
      else {
        double v18 = v17;
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 24));
  }
  *(double *)a5 = v18;
  *(int64x2_t *)(a5 + 8) = vdupq_n_s64(0x400000000uLL);
}

void CA::Render::anonymous namespace'::push_behaviors(uint64_t a1, void **a2, _DWORD *a3)
{
  uint64_t v213 = *MEMORY[0x1E4F143B8];
  if (a1 && *(_DWORD *)(a1 + 16))
  {
    unint64_t v6 = 0;
    __asm { FMOV            V0.2D, #1.0 }
    float64x2_t v210 = _Q0;
    float v12 = 1.0;
    float v13 = 100000.0;
    *(float *)&int v14 = 0.001;
    do
    {
      uint64_t v15 = *(void *)(a1 + 8 * v6 + 24);
      if ((*(unsigned char *)(v15 + 13) & 1) == 0) {
        goto LABEL_109;
      }
      uint64_t v16 = *(_DWORD **)(v15 + 40);
      if (v16) {
        goto LABEL_91;
      }
      int v17 = *(_DWORD *)(v15 + 16);
      if (v17 > 348)
      {
        if (v17 <= 584)
        {
          if (v17 == 349)
          {
            malloc_zone = (malloc_zone_t *)get_malloc_zone();
            float64x2_t v73 = (char *)malloc_type_zone_malloc(malloc_zone, 0x50uLL, 0x8BB15036uLL);
            if (v73)
            {
              uint64_t v16 = v73;
              float64x2_t v74 = *(unsigned int **)(v15 + 32);
              *((_DWORD *)v73 + 2) = 1;
              *(void *)float64x2_t v73 = &unk_1ED02E508;
              if (!v74) {
                goto LABEL_75;
              }
              uint64_t v75 = v74[4];
              if (!v75) {
                goto LABEL_75;
              }
              uint64_t v76 = 0;
              while (1)
              {
                uint64_t v77 = *(void *)&v74[2 * v76 + 6];
                if (*(_DWORD *)(v77 + 16) == 92) {
                  break;
                }
                if (v75 == ++v76) {
                  goto LABEL_75;
                }
              }
              float64x2_t v78 = v210;
              float64x2_t v79 = v210;
              if ((v76 & 0x80000000) != 0) {
                goto LABEL_76;
              }
              uint64_t v130 = *(void *)(v77 + 24);
              if (v130)
              {
                float64x2_t v78 = v210;
                float64x2_t v79 = v210;
                if (*(unsigned char *)(v130 + 12) == 56)
                {
                  float64x2_t v78 = v210;
                  float64x2_t v79 = v210;
                  if (*(_DWORD *)(v130 + 16) >= 4u)
                  {
                    float64x2_t v78 = *(float64x2_t *)(v130 + 40);
                    float64x2_t v79 = *(float64x2_t *)(v130 + 24);
                  }
                }
              }
              else
              {
LABEL_75:
                float64x2_t v78 = v210;
                float64x2_t v79 = v210;
              }
LABEL_76:
              *(float32x4_t *)(v73 + 12) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v79), v78);
              float_keCGFloat y = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v74, 26, 0.0);
              *((float *)v16 + 7) = float_key;
              float v81 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v74, 174, 1.0);
              *((float *)v16 + 8) = v81;
              uint64_t v211 = 0;
              uint64_t v212 = 0;
              vec2_keCGFloat y = CA::Render::KeyValueArray::get_vec2_key((uint64_t)v74, 438, (uint64_t)&v211);
              *(float *)&double v83 = v83;
              *((float *)v16 + 9) = vec2_key;
              v16[10] = LODWORD(v83);
              v16[11] = 0;
              if (CA::Render::KeyValueArray::get_int_key((CA::Render::KeyValueArray *)v74, 35, 1)) {
                void v16[2] = 3;
              }
              float v84 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v74, 615, 0.0);
              *((float *)v16 + 11) = v84;
              float v85 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v74, 221, 0.0);
              float v86 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v74, 220, INFINITY);
              float v87 = 0.0;
              if (v85 >= 0.0) {
                float v88 = v85;
              }
              else {
                float v88 = 0.0;
              }
              if ((LODWORD(v86) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
              {
                float v87 = v12 / v86;
                if (v86 < 0.00001) {
                  float v87 = v13;
                }
              }
              *((float *)v16 + 12) = v88 * v88;
              *((float *)v16 + 13) = v87 * v87;
              int_keCGFloat y = CA::Render::KeyValueArray::get_int_key((CA::Render::KeyValueArray *)v74, 531, 0);
              *((unsigned char *)v16 + 56) = int_key != 0;
              if (int_key)
              {
                float v90 = *(float *)&v14;
                float v91 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v74, 176, 1.57079633);
                float v92 = v13;
                if (fabsf(v91) >= 0.00001)
                {
                  float v110 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v74, 177, -1.57079633);
                  __float2 v111 = __sincosf_stret(v110);
                  __float2 v112 = __sincosf_stret(v91);
                  float cosval = v112.__cosval;
                  float v94 = v112.__sinval * v111.__cosval;
                  float v95 = v112.__sinval * v111.__sinval;
                }
                else
                {
                  float cosval = 1.0;
                  float v94 = 0.0;
                  float v95 = 0.0;
                }
                *((float *)v16 + 15) = v94;
                *((float *)v16 + 16) = v95;
                *((float *)v16 + 17) = cosval;
                float v113 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v74, 115, 1.57079633);
                float v114 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v74, 116, 0.174532925);
                float v115 = v113 * 0.5;
                float v116 = cosf(v115);
                float v117 = cosf(v115 + v114);
                float v118 = v116 - v117;
                float v12 = 1.0;
                float v119 = 1.0 / v118;
                _NF = v118 < v90;
                float v120 = 1000.0;
                if (!_NF) {
                  float v120 = v119;
                }
                *((float *)v16 + 18) = v117;
                *((float *)v16 + 19) = v120;
                float v13 = v92;
                *(float *)&int v14 = v90;
              }
              goto LABEL_90;
            }
            goto LABEL_87;
          }
          if (v17 == 511)
          {
            int8x16_t v33 = (malloc_zone_t *)get_malloc_zone();
            int8x16_t v34 = malloc_type_zone_malloc(v33, 0x28uLL, 0x8BB15036uLL);
            if (v34)
            {
              uint64_t v16 = v34;
              int8x16_t v35 = *(CA::Render::KeyValueArray **)(v15 + 32);
              v34[2] = 0;
              *(void *)int8x16_t v34 = &unk_1ED02E448;
              uint64_t v211 = 0;
              uint64_t v212 = 0;
              float v36 = CA::Render::KeyValueArray::get_vec2_key((uint64_t)v35, 438, (uint64_t)&v211);
              *(float *)&double v37 = v37;
              *((float *)v16 + 3) = v36;
              v16[4] = LODWORD(v37);
              float v38 = CA::Render::KeyValueArray::get_float_key(v35, 538, 1.0);
              *((float *)v16 + 5) = v38;
              float v39 = CA::Render::KeyValueArray::get_float_key(v35, 454, 0.0);
              *((float *)v16 + 6) = v38 * v39;
              float v40 = CA::Render::KeyValueArray::get_float_key(v35, 220, INFINITY);
              float v41 = 0.0;
              if (v40 != 0.0 && (LODWORD(v40) & 0x7FFFFFFFu) <= 0x7F7FFFFF) {
                float v41 = v12 / v40;
              }
              *((float *)v16 + 7) = v40 * v40;
              *((float *)v16 + 8) = v41 * v41;
              goto LABEL_90;
            }
            goto LABEL_87;
          }
        }
        else
        {
          switch(v17)
          {
            case 585:
              uint32x2_t v54 = (malloc_zone_t *)get_malloc_zone();
              int32x2_t v55 = malloc_type_zone_malloc(v54, 0x60uLL, 0x8BB15036uLL);
              if (v55)
              {
                uint64_t v16 = v55;
                int32x2_t v56 = *(unsigned int **)(v15 + 32);
                v55[2] = 0;
                *(void *)int32x2_t v55 = &unk_1ED02E5F8;
                CA::Render::EmitterBehaviors::DistanceFunction::DistanceFunction((CA::Render::EmitterBehaviors::DistanceFunction *)(v55 + 3), (const CA::Render::KeyValueArray *)v56);
                *((void *)v16 + 10) = 0;
                CA::Render::EmitterBehaviors::ValueMutator::ValueMutator((CA::Render::EmitterBehaviors::ValueMutator *)(v16 + 22), (const CA::Render::KeyValueArray *)v56);
                if ((v16[22] & 0x80000000) != 0) {
                  goto LABEL_90;
                }
                if (!v56) {
                  goto LABEL_145;
                }
                uint64_t v57 = v56[4];
                if (!v57) {
                  goto LABEL_145;
                }
                uint64_t v58 = 0;
                while (1)
                {
                  uint64_t v59 = *(void *)&v56[2 * v58 + 6];
                  if (*(_DWORD *)(v59 + 16) == 245) {
                    break;
                  }
                  if (v57 == ++v58) {
                    goto LABEL_145;
                  }
                }
                if ((v58 & 0x80000000) == 0) {
                  CGRect v131 = *(atomic_uint **)(v59 + 24);
                }
                else {
LABEL_145:
                }
                  CGRect v131 = 0;
                CGRect v132 = (atomic_uint *)*((void *)v16 + 10);
                if (v132 != v131)
                {
                  if (v132 && atomic_fetch_add(v132 + 2, 0xFFFFFFFF) == 1) {
                    (*(void (**)(atomic_uint *))(*(void *)v132 + 16))(v132);
                  }
                  if (v131)
                  {
                    BOOL v133 = v131 + 2;
                    if (!atomic_fetch_add(v131 + 2, 1u))
                    {
                      CGRect v131 = 0;
                      atomic_fetch_add(v133, 0xFFFFFFFF);
                    }
                  }
                  *((void *)v16 + 10) = v131;
                }
                if (!v131)
                {
LABEL_165:
                  if (!v56) {
                    goto LABEL_90;
                  }
                  uint64_t v136 = v56[4];
                  if (!v136) {
                    goto LABEL_90;
                  }
                  uint64_t v137 = 0;
                  while (1)
                  {
                    uint64_t v138 = *(void *)&v56[2 * v137 + 6];
                    if (*(_DWORD *)(v138 + 16) == 587) {
                      break;
                    }
                    if (v136 == ++v137) {
                      goto LABEL_201;
                    }
                  }
                  if ((v137 & 0x80000000) == 0)
                  {
                    uint64_t v147 = *(void *)(v138 + 24);
                    goto LABEL_202;
                  }
LABEL_201:
                  uint64_t v147 = 0;
LABEL_202:
                  uint64_t v148 = 0;
                  while (1)
                  {
                    uint64_t v149 = *(void *)&v56[2 * v148 + 6];
                    if (*(_DWORD *)(v149 + 16) == 365) {
                      break;
                    }
                    if (v136 == ++v148) {
                      goto LABEL_215;
                    }
                  }
                  if ((v148 & 0x80000000) == 0)
                  {
                    uint64_t v153 = *(void *)(v149 + 24);
                    goto LABEL_216;
                  }
LABEL_215:
                  uint64_t v153 = 0;
LABEL_216:
                  if (!v147 || *(unsigned char *)(v147 + 12) != 56) {
                    goto LABEL_90;
                  }
                  if (v153 && (*(unsigned char *)(v153 + 12) != 56 || *(_DWORD *)(v153 + 16) != *(_DWORD *)(v147 + 16))) {
                    uint64_t v153 = 0;
                  }
                  unint64_t v206 = *(unsigned int *)(v147 + 16);
                  uint64_t v154 = (malloc_zone_t *)get_malloc_zone();
                  uint64_t v155 = (CA::Render::InterpolatedFunction *)malloc_type_zone_calloc(v154, 1uLL, 0x38uLL, 0x743898A5uLL);
                  uint64_t v156 = (uint64_t)v155;
                  if (v155)
                  {
                    CA::Render::InterpolatedFunction::InterpolatedFunction(v155, v206, 1, 2 * (v153 != 0));
                    unsigned int v157 = *(float **)(v156 + 32);
                    if (v157)
                    {
                      uint64_t v158 = *(void *)(v156 + 16) * *(unsigned int *)(v156 + 24);
                      if (v158)
                      {
                        int v159 = (double *)(v147 + 24);
                        uint64_t v160 = 8 * v158;
                        do
                        {
                          double v161 = *v159++;
                          float v162 = v161;
                          *v157++ = v162;
                          v160 -= 8;
                        }
                        while (v160);
                      }
                    }
                  }
                  else
                  {
                    unsigned int v194 = (float *)MEMORY[0x20];
                    if (MEMORY[0x20])
                    {
                      uint64_t v195 = MEMORY[0x10] * MEMORY[0x18];
                      if (v195)
                      {
                        int v196 = (double *)(v147 + 24);
                        uint64_t v197 = 8 * v195;
                        do
                        {
                          double v198 = *v196++;
                          float v199 = v198;
                          *v194++ = v199;
                          v197 -= 8;
                        }
                        while (v197);
                      }
                    }
                  }
                  if (v153) {
                    CA::Render::InterpolatedFunction::set_locations(v156, (const double *)(v153 + 24));
                  }
                  int v183 = (atomic_uint *)*((void *)v16 + 10);
                  *((void *)v16 + 10) = v156;
                  goto LABEL_327;
                }
                if (*((unsigned char *)v131 + 12) == 18)
                {
                  int v134 = (*(uint64_t (**)(atomic_uint *))(*(void *)v131 + 104))(v131);
                  CGRect v131 = (atomic_uint *)*((void *)v16 + 10);
                  if (v134 != 1
                    || (int v135 = (*(uint64_t (**)(void))(*(void *)v131 + 112))(*((void *)v16 + 10)),
                        CGRect v131 = (atomic_uint *)*((void *)v16 + 10),
                        v135 != 1))
                  {
                    *((void *)v16 + 10) = 0;
                    if (!v131) {
                      goto LABEL_165;
                    }
LABEL_161:
                    if (atomic_fetch_add(v131 + 2, 0xFFFFFFFF) == 1) {
                      (*(void (**)(atomic_uint *))(*(void *)v131 + 16))(v131);
                    }
                    CGRect v131 = (atomic_uint *)*((void *)v16 + 10);
                  }
                  if (v131) {
                    goto LABEL_90;
                  }
                  goto LABEL_165;
                }
                *((void *)v16 + 10) = 0;
                goto LABEL_161;
              }
              goto LABEL_87;
            case 586:
              float64x2_t v60 = (malloc_zone_t *)get_malloc_zone();
              float64x2_t v61 = malloc_type_zone_malloc(v60, 0x20uLL, 0x8BB15036uLL);
              if (v61)
              {
                uint64_t v16 = v61;
                int32x4_t v62 = *(unsigned int **)(v15 + 32);
                v61[2] = 0;
                *(void *)float64x2_t v61 = &unk_1ED02E5C8;
                *((void *)v61 + 2) = 0;
                CA::Render::EmitterBehaviors::ValueMutator::ValueMutator((CA::Render::EmitterBehaviors::ValueMutator *)(v61 + 6), (const CA::Render::KeyValueArray *)v62);
                if ((v16[6] & 0x80000000) == 0)
                {
                  if (!v62) {
                    goto LABEL_173;
                  }
                  uint64_t v63 = v62[4];
                  if (!v63) {
                    goto LABEL_173;
                  }
                  uint64_t v64 = 0;
                  while (1)
                  {
                    uint64_t v65 = *(void *)&v62[2 * v64 + 6];
                    if (*(_DWORD *)(v65 + 16) == 245) {
                      break;
                    }
                    if (v63 == ++v64) {
                      goto LABEL_173;
                    }
                  }
                  if ((v64 & 0x80000000) == 0) {
                    int v139 = *(atomic_uint **)(v65 + 24);
                  }
                  else {
LABEL_173:
                  }
                    int v139 = 0;
                  uint64_t v140 = (atomic_uint *)*((void *)v16 + 2);
                  if (v140 != v139)
                  {
                    if (v140 && atomic_fetch_add(v140 + 2, 0xFFFFFFFF) == 1) {
                      (*(void (**)(atomic_uint *))(*(void *)v140 + 16))(v140);
                    }
                    if (v139)
                    {
                      int v141 = v139 + 2;
                      if (!atomic_fetch_add(v139 + 2, 1u))
                      {
                        int v139 = 0;
                        atomic_fetch_add(v141, 0xFFFFFFFF);
                      }
                    }
                    *((void *)v16 + 2) = v139;
                  }
                  if (v139)
                  {
                    if (*((unsigned char *)v139 + 12) != 18)
                    {
                      *((void *)v16 + 2) = 0;
                      goto LABEL_189;
                    }
                    int v142 = (*(uint64_t (**)(atomic_uint *))(*(void *)v139 + 104))(v139);
                    int v139 = (atomic_uint *)*((void *)v16 + 2);
                    if (v142 != 1
                      || (int v143 = (*(uint64_t (**)(void))(*(void *)v139 + 112))(*((void *)v16 + 2)),
                          int v139 = (atomic_uint *)*((void *)v16 + 2),
                          v143 != 1))
                    {
                      *((void *)v16 + 2) = 0;
                      if (!v139) {
                        goto LABEL_193;
                      }
LABEL_189:
                      if (atomic_fetch_add(v139 + 2, 0xFFFFFFFF) == 1) {
                        (*(void (**)(atomic_uint *))(*(void *)v139 + 16))(v139);
                      }
                      int v139 = (atomic_uint *)*((void *)v16 + 2);
                    }
                    if (v139) {
                      goto LABEL_90;
                    }
                  }
LABEL_193:
                  if (!v62) {
                    goto LABEL_90;
                  }
                  uint64_t v144 = v62[4];
                  if (!v144) {
                    goto LABEL_90;
                  }
                  uint64_t v145 = 0;
                  while (1)
                  {
                    uint64_t v146 = *(void *)&v62[2 * v145 + 6];
                    if (*(_DWORD *)(v146 + 16) == 587) {
                      break;
                    }
                    if (v144 == ++v145) {
                      goto LABEL_208;
                    }
                  }
                  if ((v145 & 0x80000000) == 0)
                  {
                    uint64_t v150 = *(void *)(v146 + 24);
                    goto LABEL_209;
                  }
LABEL_208:
                  uint64_t v150 = 0;
LABEL_209:
                  uint64_t v151 = 0;
                  while (1)
                  {
                    uint64_t v152 = *(void *)&v62[2 * v151 + 6];
                    if (*(_DWORD *)(v152 + 16) == 365) {
                      break;
                    }
                    if (v144 == ++v151) {
                      goto LABEL_230;
                    }
                  }
                  if ((v151 & 0x80000000) == 0)
                  {
                    uint64_t v163 = *(void *)(v152 + 24);
                    goto LABEL_231;
                  }
LABEL_230:
                  uint64_t v163 = 0;
LABEL_231:
                  if (!v150 || *(unsigned char *)(v150 + 12) != 56) {
                    goto LABEL_90;
                  }
                  if (v163 && (*(unsigned char *)(v163 + 12) != 56 || *(_DWORD *)(v163 + 16) != *(_DWORD *)(v150 + 16))) {
                    uint64_t v163 = 0;
                  }
                  unint64_t v207 = *(unsigned int *)(v150 + 16);
                  unsigned int v164 = (malloc_zone_t *)get_malloc_zone();
                  int v165 = (CA::Render::InterpolatedFunction *)malloc_type_zone_calloc(v164, 1uLL, 0x38uLL, 0x743898A5uLL);
                  uint64_t v166 = (uint64_t)v165;
                  if (v165)
                  {
                    CA::Render::InterpolatedFunction::InterpolatedFunction(v165, v207, 1, 2 * (v163 != 0));
                    unsigned int v167 = *(float **)(v166 + 32);
                    if (v167)
                    {
                      uint64_t v168 = *(void *)(v166 + 16) * *(unsigned int *)(v166 + 24);
                      if (v168)
                      {
                        unsigned int v169 = (double *)(v150 + 24);
                        uint64_t v170 = 8 * v168;
                        do
                        {
                          double v171 = *v169++;
                          float v172 = v171;
                          *v167++ = v172;
                          v170 -= 8;
                        }
                        while (v170);
                      }
                    }
                  }
                  else
                  {
                    OSType v200 = (float *)MEMORY[0x20];
                    if (MEMORY[0x20])
                    {
                      uint64_t v201 = MEMORY[0x10] * MEMORY[0x18];
                      if (v201)
                      {
                        int v202 = (double *)(v150 + 24);
                        uint64_t v203 = 8 * v201;
                        do
                        {
                          double v204 = *v202++;
                          float v205 = v204;
                          *v200++ = v205;
                          v203 -= 8;
                        }
                        while (v203);
                      }
                    }
                  }
                  if (v163) {
                    CA::Render::InterpolatedFunction::set_locations(v166, (const double *)(v163 + 24));
                  }
                  int v183 = (atomic_uint *)*((void *)v16 + 2);
                  *((void *)v16 + 2) = v166;
LABEL_327:
                  if (!v183) {
                    goto LABEL_90;
                  }
LABEL_328:
                  if (atomic_fetch_add(v183 + 2, 0xFFFFFFFF) == 1) {
                    (*(void (**)(atomic_uint *))(*(void *)v183 + 16))(v183);
                  }
                }
LABEL_90:
                *(void *)(v15 + 40) = v16;
LABEL_91:
                if ((*(unsigned int (**)(_DWORD *))(*(void *)v16 + 16))(v16))
                {
                  float64x2_t v99 = a2[1];
                  unint64_t v98 = (unint64_t)a2[2];
                  if ((unint64_t)v99 >= v98)
                  {
                    uint64_t v101 = ((char *)v99 - (unsigned char *)*a2) >> 3;
                    if ((unint64_t)(v101 + 1) >> 61) {
                      abort();
                    }
                    uint64_t v102 = v98 - (void)*a2;
                    uint64_t v103 = v102 >> 2;
                    if (v102 >> 2 <= (unint64_t)(v101 + 1)) {
                      uint64_t v103 = v101 + 1;
                    }
                    if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v104 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v104 = v103;
                    }
                    if (v104) {
                      unint64_t v104 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v104);
                    }
                    else {
                      uint64_t v105 = 0;
                    }
                    float64x2_t v106 = (void *)(v104 + 8 * v101);
                    void *v106 = v16;
                    float64x2_t v100 = v106 + 1;
                    long long v108 = (char *)*a2;
                    long long v107 = (char *)a2[1];
                    if (v107 != *a2)
                    {
                      do
                      {
                        uint64_t v109 = *((void *)v107 - 1);
                        v107 -= 8;
                        *--float64x2_t v106 = v109;
                      }
                      while (v107 != v108);
                      long long v107 = (char *)*a2;
                    }
                    *a2 = v106;
                    a2[1] = v100;
                    a2[2] = (void *)(v104 + 8 * v105);
                    if (v107) {
                      operator delete(v107);
                    }
                  }
                  else
                  {
                    void *v99 = v16;
                    float64x2_t v100 = v99 + 1;
                  }
                  a2[1] = v100;
                  *a3 |= v16[2];
                }
                goto LABEL_109;
              }
              goto LABEL_87;
            case 603:
              uint64_t v22 = (malloc_zone_t *)get_malloc_zone();
              BOOL v23 = malloc_type_zone_malloc(v22, 0x20uLL, 0x8BB15036uLL);
              if (v23)
              {
                uint64_t v16 = v23;
                unint64_t v24 = *(unsigned int **)(v15 + 32);
                void v16[2] = 0;
                *(void *)uint64_t v16 = &unk_1ED02E4D8;
                float64x2_t v25 = (float64x2_t)xmmword_1849983D0;
                double v26 = 0.0;
                if (v24)
                {
                  uint64_t v27 = v24[4];
                  if (v27)
                  {
                    uint64_t v28 = 0;
                    while (1)
                    {
                      uint64_t v29 = *(void *)&v24[2 * v28 + 6];
                      if (*(_DWORD *)(v29 + 16) == 233) {
                        break;
                      }
                      if (v27 == ++v28) {
                        goto LABEL_121;
                      }
                    }
                    if ((v28 & 0x80000000) == 0)
                    {
                      uint64_t v121 = *(void *)(v29 + 24);
                      if (v121)
                      {
                        if (*(unsigned char *)(v121 + 12) == 56 && *(_DWORD *)(v121 + 16) >= 3u)
                        {
                          double v26 = *(double *)(v121 + 40);
                          float64x2_t v25 = *(float64x2_t *)(v121 + 24);
                        }
                      }
                    }
                  }
                }
LABEL_121:
                *(float32x2_t *)(v16 + 3) = vcvt_f32_f64(v25);
                float v122 = v26;
                *((float *)v16 + 5) = v122;
                float v123 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v24, 238, 1.0);
                *((float *)v16 + 6) = v123;
                goto LABEL_90;
              }
LABEL_87:
              *(void *)(v15 + 40) = 0;
              break;
          }
        }
      }
      else if (v17 <= 104)
      {
        if (v17 == 4)
        {
          IOSurfaceID v66 = (malloc_zone_t *)get_malloc_zone();
          char v67 = malloc_type_zone_malloc(v66, 0x20uLL, 0x8BB15036uLL);
          if (v67)
          {
            uint64_t v16 = v67;
            double v68 = *(CA::Render::KeyValueArray **)(v15 + 32);
            v67[2] = 0;
            *(void *)char v67 = &unk_1ED02E418;
            float v69 = CA::Render::KeyValueArray::get_float_key(v68, 481, 0.0);
            *((float *)v16 + 3) = v69;
            int v70 = CA::Render::KeyValueArray::get_int_key(v68, 447, 0);
            *((unsigned char *)v16 + 16) = v70 != 0;
            *(void *)(v16 + 5) = 0xBF80000000000000;
            v16[7] = 0;
            if (v70 && v69 != 0.0)
            {
              __float2 v71 = __sincosf_stret(v69);
              v16[5] = LODWORD(v71.__sinval);
              *((float *)v16 + 6) = -v71.__cosval;
            }
            goto LABEL_90;
          }
          goto LABEL_87;
        }
        if (v17 == 45)
        {
          unint64_t v30 = (malloc_zone_t *)get_malloc_zone();
          double v31 = malloc_type_zone_malloc(v30, 0x50uLL, 0x8BB15036uLL);
          if (v31)
          {
            uint64_t v16 = v31;
            int8x16_t v32 = *(const CA::Render::KeyValueArray **)(v15 + 32);
            v31[2] = 0;
            *(void *)double v31 = &unk_1ED02E538;
            CA::Render::EmitterBehaviors::DistanceFunction::DistanceFunction((CA::Render::EmitterBehaviors::DistanceFunction *)(v31 + 3), v32);
            goto LABEL_90;
          }
          goto LABEL_87;
        }
      }
      else
      {
        switch(v17)
        {
          case 105:
            int32x4_t v42 = (malloc_zone_t *)get_malloc_zone();
            int8x16_t v43 = malloc_type_zone_malloc(v42, 0x58uLL, 0x8BB15036uLL);
            if (v43)
            {
              uint64_t v16 = v43;
              int8x16_t v44 = *(unsigned int **)(v15 + 32);
              v43[2] = 0;
              *(void *)int8x16_t v43 = &unk_1ED02E598;
              CA::Render::EmitterBehaviors::DistanceFunction::DistanceFunction((CA::Render::EmitterBehaviors::DistanceFunction *)(v43 + 3), (const CA::Render::KeyValueArray *)v44);
              *((void *)v16 + 10) = 0;
              if (!v44) {
                goto LABEL_90;
              }
              uint64_t v45 = v44[4];
              if (!v45) {
                goto LABEL_90;
              }
              uint64_t v46 = 0;
              while (1)
              {
                uint64_t v47 = *(void *)&v44[2 * v46 + 6];
                if (*(_DWORD *)(v47 + 16) == 245) {
                  break;
                }
                if (v45 == ++v46) {
                  goto LABEL_249;
                }
              }
              if ((v46 & 0x80000000) != 0) {
                goto LABEL_249;
              }
              uint64_t v124 = *(atomic_uint **)(v47 + 24);
              if (!v124) {
                goto LABEL_249;
              }
              if (atomic_fetch_add(v124 + 2, 1u))
              {
                *((void *)v16 + 10) = v124;
                if (*((unsigned char *)v124 + 12) != 18)
                {
                  *((void *)v16 + 10) = 0;
                  goto LABEL_245;
                }
                int v125 = (*(uint64_t (**)(atomic_uint *))(*(void *)v124 + 104))(v124);
                uint64_t v124 = (atomic_uint *)*((void *)v16 + 10);
                if (v125 != 1
                  || (int v126 = (*(uint64_t (**)(atomic_uint *))(*(void *)v124 + 112))(v124),
                      uint64_t v124 = (atomic_uint *)*((void *)v16 + 10),
                      v126 != 4))
                {
                  *((void *)v16 + 10) = 0;
                  if (!v124) {
                    goto LABEL_249;
                  }
LABEL_245:
                  if (atomic_fetch_add(v124 + 2, 0xFFFFFFFF) == 1) {
                    (*(void (**)(atomic_uint *))(*(void *)v124 + 16))(v124);
                  }
                  uint64_t v124 = (atomic_uint *)*((void *)v16 + 10);
                }
                if (v124) {
                  goto LABEL_90;
                }
              }
              else
              {
                atomic_fetch_add(v124 + 2, 0xFFFFFFFF);
                *((void *)v16 + 10) = 0;
              }
LABEL_249:
              uint64_t v173 = v44[4];
              if (!v173) {
                goto LABEL_90;
              }
              uint64_t v174 = 0;
              while (1)
              {
                uint64_t v175 = *(void *)&v44[2 * v174 + 6];
                if (*(_DWORD *)(v175 + 16) == 110) {
                  break;
                }
                if (v173 == ++v174) {
                  goto LABEL_257;
                }
              }
              if ((v174 & 0x80000000) != 0)
              {
LABEL_257:
                if (!v44[4]) {
                  goto LABEL_90;
                }
                uint64_t v176 = 0;
                goto LABEL_259;
              }
              uint64_t v176 = *(void *)(v175 + 24);
              if (!v44[4]) {
                goto LABEL_265;
              }
LABEL_259:
              uint64_t v177 = 0;
              while (1)
              {
                uint64_t v178 = *(void *)&v44[2 * v177 + 6];
                if (*(_DWORD *)(v178 + 16) == 365) {
                  break;
                }
                if (v173 == ++v177) {
                  goto LABEL_265;
                }
              }
              if ((v177 & 0x80000000) == 0)
              {
                uint64_t v179 = *(void *)(v178 + 24);
                goto LABEL_266;
              }
LABEL_265:
              uint64_t v179 = 0;
LABEL_266:
              if (!v176 || *(unsigned char *)(v176 + 12) != 56) {
                goto LABEL_90;
              }
              if (v179 && (*(unsigned char *)(v179 + 12) != 56 || *(_DWORD *)(v179 + 16) != *(_DWORD *)(v176 + 16) >> 2)) {
                uint64_t v179 = 0;
              }
              unint64_t v208 = (unint64_t)*(unsigned int *)(v176 + 16) >> 2;
              int v180 = (malloc_zone_t *)get_malloc_zone();
              OSType v181 = (CA::Render::InterpolatedFunction *)malloc_type_zone_calloc(v180, 1uLL, 0x38uLL, 0x743898A5uLL);
              unsigned int v182 = v181;
              if (v181)
              {
                OSType v181 = CA::Render::InterpolatedFunction::InterpolatedFunction(v181, v208, 4, 2 * (v179 != 0));
                *(void *)unsigned int v182 = &unk_1ED02FF20;
              }
              CA::Render::Gradient::set_colors((uint64_t)v181, (const double *)(v176 + 24));
              if (v179) {
                CA::Render::InterpolatedFunction::set_locations((uint64_t)v182, (const double *)(v179 + 24));
              }
              int v183 = (atomic_uint *)*((void *)v16 + 10);
              *((void *)v16 + 10) = v182;
              if (!v183) {
                goto LABEL_90;
              }
              goto LABEL_328;
            }
            goto LABEL_87;
          case 106:
            int8x16_t v48 = (malloc_zone_t *)get_malloc_zone();
            int32x4_t v49 = malloc_type_zone_malloc(v48, 0x18uLL, 0x8BB15036uLL);
            if (v49)
            {
              uint64_t v16 = v49;
              uint64_t v50 = *(void *)(v15 + 32);
              v49[2] = 0;
              *(void *)int32x4_t v49 = &unk_1ED02E568;
              *((void *)v49 + 2) = 0;
              if (!v50) {
                goto LABEL_90;
              }
              uint64_t v51 = *(unsigned int *)(v50 + 16);
              if (!v51) {
                goto LABEL_90;
              }
              uint64_t v52 = 0;
              while (1)
              {
                uint64_t v53 = *(void *)(v50 + 24 + 8 * v52);
                if (*(_DWORD *)(v53 + 16) == 245) {
                  break;
                }
                if (v51 == ++v52) {
                  goto LABEL_283;
                }
              }
              if ((v52 & 0x80000000) != 0) {
                goto LABEL_283;
              }
              CGRect v127 = *(atomic_uint **)(v53 + 24);
              if (!v127) {
                goto LABEL_283;
              }
              if (atomic_fetch_add(v127 + 2, 1u))
              {
                *((void *)v16 + 2) = v127;
                if (*((unsigned char *)v127 + 12) != 18)
                {
                  *((void *)v16 + 2) = 0;
                  goto LABEL_279;
                }
                int v128 = (*(uint64_t (**)(atomic_uint *))(*(void *)v127 + 104))(v127);
                CGRect v127 = (atomic_uint *)*((void *)v16 + 2);
                if (v128 != 1
                  || (int v129 = (*(uint64_t (**)(atomic_uint *))(*(void *)v127 + 112))(v127),
                      CGRect v127 = (atomic_uint *)*((void *)v16 + 2),
                      v129 != 4))
                {
                  *((void *)v16 + 2) = 0;
                  if (!v127) {
                    goto LABEL_283;
                  }
LABEL_279:
                  if (atomic_fetch_add(v127 + 2, 0xFFFFFFFF) == 1) {
                    (*(void (**)(atomic_uint *))(*(void *)v127 + 16))(v127);
                  }
                  CGRect v127 = (atomic_uint *)*((void *)v16 + 2);
                }
                if (v127) {
                  goto LABEL_90;
                }
              }
              else
              {
                atomic_fetch_add(v127 + 2, 0xFFFFFFFF);
                *((void *)v16 + 2) = 0;
              }
LABEL_283:
              uint64_t v184 = *(unsigned int *)(v50 + 16);
              if (!v184) {
                goto LABEL_90;
              }
              uint64_t v185 = 0;
              while (1)
              {
                uint64_t v186 = *(void *)(v50 + 24 + 8 * v185);
                if (*(_DWORD *)(v186 + 16) == 110) {
                  break;
                }
                if (v184 == ++v185) {
                  goto LABEL_291;
                }
              }
              if ((v185 & 0x80000000) != 0)
              {
LABEL_291:
                if (!*(_DWORD *)(v50 + 16)) {
                  goto LABEL_90;
                }
                uint64_t v187 = 0;
                goto LABEL_293;
              }
              uint64_t v187 = *(void *)(v186 + 24);
              if (!*(_DWORD *)(v50 + 16)) {
                goto LABEL_299;
              }
LABEL_293:
              uint64_t v188 = 0;
              while (1)
              {
                uint64_t v189 = *(void *)(v50 + 24 + 8 * v188);
                if (*(_DWORD *)(v189 + 16) == 365) {
                  break;
                }
                if (v184 == ++v188) {
                  goto LABEL_299;
                }
              }
              if ((v188 & 0x80000000) == 0)
              {
                uint64_t v190 = *(void *)(v189 + 24);
                goto LABEL_300;
              }
LABEL_299:
              uint64_t v190 = 0;
LABEL_300:
              if (!v187 || *(unsigned char *)(v187 + 12) != 56) {
                goto LABEL_90;
              }
              if (v190 && (*(unsigned char *)(v190 + 12) != 56 || *(_DWORD *)(v190 + 16) != *(_DWORD *)(v187 + 16) >> 2)) {
                uint64_t v190 = 0;
              }
              unint64_t v209 = (unint64_t)*(unsigned int *)(v187 + 16) >> 2;
              unsigned int v191 = (malloc_zone_t *)get_malloc_zone();
              int v192 = (CA::Render::InterpolatedFunction *)malloc_type_zone_calloc(v191, 1uLL, 0x38uLL, 0x743898A5uLL);
              int v193 = v192;
              if (v192)
              {
                int v192 = CA::Render::InterpolatedFunction::InterpolatedFunction(v192, v209, 4, 2 * (v190 != 0));
                *(void *)int v193 = &unk_1ED02FF20;
              }
              CA::Render::Gradient::set_colors((uint64_t)v192, (const double *)(v187 + 24));
              if (v190) {
                CA::Render::InterpolatedFunction::set_locations((uint64_t)v193, (const double *)(v190 + 24));
              }
              int v183 = (atomic_uint *)*((void *)v16 + 2);
              *((void *)v16 + 2) = v193;
              if (!v183) {
                goto LABEL_90;
              }
              goto LABEL_328;
            }
            goto LABEL_87;
          case 187:
            double v18 = (malloc_zone_t *)get_malloc_zone();
            double v19 = malloc_type_zone_malloc(v18, 0x10uLL, 0x8BB15036uLL);
            if (v19)
            {
              uint64_t v16 = v19;
              long long v20 = *(CA::Render::KeyValueArray **)(v15 + 32);
              void v16[2] = 0;
              *(void *)uint64_t v16 = &unk_1ED02E478;
              float v21 = CA::Render::KeyValueArray::get_float_key(v20, 187, 1.0);
              *((float *)v16 + 3) = v21;
              goto LABEL_90;
            }
            goto LABEL_87;
        }
      }
      float64x2_t v96 = (malloc_zone_t *)get_malloc_zone();
      float64x2_t v97 = malloc_type_zone_malloc(v96, 0x10uLL, 0x8BB15036uLL);
      if (v97)
      {
        uint64_t v16 = v97;
        v97[2] = 0;
        *(void *)float64x2_t v97 = &unk_1ED02E4A8;
        goto LABEL_90;
      }
      *(void *)(v15 + 40) = 0;
LABEL_109:
      ++v6;
    }
    while (v6 < *(unsigned int *)(a1 + 16));
  }
}

uint64_t CA::Render::EmitterState::update_cells(CA::Render::EmitterState *a1, double *a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6, float a7)
{
  double v68 = a2;
  double v8 = a1;
  block[11] = *MEMORY[0x1E4F143B8];
  if (!a3 || (size_t v10 = *(unsigned int *)(a3 + 16), !v10))
  {
    CA::Render::EmitterState::free_cells_state(a1, a4);
    uint64_t result = 0;
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    return result;
  }
  size_t v13 = *(unsigned int *)(a4 + 8);
  size_t v14 = 8 * v10;
  size_t v67 = *(unsigned int *)(a3 + 16);
  uint64_t v66 = a5;
  if (v13 != v10)
  {
    uint64_t v15 = *(uint64_t **)a4;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    a1 = (CA::Render::EmitterState *)malloc_type_zone_malloc(malloc_zone, 8 * v10, 0x8BB15036uLL);
    int v17 = a1;
    if (v13 >= v10) {
      size_t v18 = v10;
    }
    else {
      size_t v18 = v13;
    }
    if (v18)
    {
      double v19 = v15;
      long long v20 = a1;
      size_t v21 = v18;
      do
      {
        uint64_t v22 = *v19++;
        *(void *)long long v20 = v22;
        long long v20 = (CA::Render::EmitterState *)((char *)v20 + 8);
        --v21;
      }
      while (v21);
    }
    if (v13 < v10)
    {
      size_t v23 = v10 - v18;
      unint64_t v24 = (CA::Render::EmitterState **)((char *)a1 + 8 * v18);
      do
      {
        float64x2_t v25 = (malloc_zone_t *)get_malloc_zone();
        a1 = (CA::Render::EmitterState *)malloc_type_zone_calloc(v25, 1uLL, 0x28uLL, 0x743898A5uLL);
        *v24++ = a1;
        *((_DWORD *)a1 + 6) = 1176256512;
        --v23;
      }
      while (v23);
      size_t v18 = v67;
    }
    size_t v26 = v13 - v18;
    if (v13 > v18)
    {
      uint64_t v27 = (Cell **)&v15[v18];
      do
      {
        uint64_t v28 = *v27++;
        CA::Render::EmitterState::free_cell_state(v8, v28);
        --v26;
      }
      while (v26);
    }
    if (v13)
    {
      uint64_t v29 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v29, v15);
    }
    size_t v10 = v67;
    *(_DWORD *)(a4 + 8) = v67;
    *(void *)a4 = v17;
  }
  uint64_t v30 = a3 + 24;
  MEMORY[0x1F4188790](a1);
  double v31 = (char *)&v66 - ((v14 + 15) & 0xFFFFFFFF0);
  bzero(v31, v14);
  MEMORY[0x1F4188790](v32);
  bzero(v31, v14);
  uint64_t v33 = 0;
  if (v10 <= 1) {
    size_t v10 = 1;
  }
  float v34 = 0.0;
  do
  {
    uint64_t v35 = *(void *)(v30 + 8 * v33);
    uint64_t v36 = *(void *)(*(void *)a4 + 8 * v33);
    float v37 = *(float *)(v35 + 72);
    float v38 = (double *)&v31[8 * v33];
    *float v38 = a6;
    float v39 = *(CA::Render::Timing **)(v35 + 56);
    if (v39 && (CA::Render::Timing::map_time(v39, (double *)&v31[8 * v33], 0) & 1) == 0)
    {
      *float v38 = -1.0;
      double v61 = *(double *)(*(void *)(v35 + 56) + 40);
      if (v61 > a6) {
        *double v68 = fmin(*v68, v61);
      }
LABEL_57:
      *(void *)&v31[8 * v33] = 0;
      *(void *)uint64_t v36 = 0;
      goto LABEL_58;
    }
    float v40 = v37 * a7;
    if ((float)(v37 * a7) <= 0.0) {
      goto LABEL_57;
    }
    if (v34 <= v40) {
      float v34 = v37 * a7;
    }
    double v41 = (float)(1.0 / v40);
    *(double *)&v31[8 * v33] = v41;
    int v42 = *((unsigned __int8 *)v8 + 129);
    if (!*((unsigned char *)v8 + 129))
    {
      double v41 = -v41;
      *(double *)&v31[8 * v33] = v41;
    }
    if (*(unsigned __int8 *)(v36 + 36) != v42 && *(_DWORD *)(v36 + 16))
    {
      double v43 = -INFINITY;
      if (!v42) {
        double v43 = INFINITY;
      }
      uint64_t v44 = *(unsigned int *)(v36 + 20);
      if (v44)
      {
        uint64_t v45 = (float *)(*(void *)(v36 + 8) + 24);
        do
        {
          if (*v45 != 0.0)
          {
            double v46 = *((double *)v45 - 1);
            if (v42) {
              double v43 = fmax(v43, v46);
            }
            else {
              double v43 = fmin(v43, v46 + *v45);
            }
          }
          v45 += 32;
          --v44;
        }
        while (v44);
      }
      uint64_t v47 = *(void *)(v35 + 56);
      if (v47) {
        double v43 = (v43 - *(double *)(v47 + 40)) * *(float *)(v47 + 16);
      }
      *(double *)uint64_t v36 = v41 + v43;
      *(unsigned char *)(v36 + 36) = v42;
    }
    float v48 = fmaxf(v40, 0.0);
    float v49 = (float)(fabsf(*(float *)(v35 + 80)) + *(float *)(v35 + 76)) * *(float *)(*((void *)v8 + 17) + 80);
    double v50 = *v38;
    double v51 = *(double *)v36 - *v38;
    float v52 = v51;
    float v53 = fabsf(v52);
    if (v53 > v49 && (float)(v53 * v48) > 32.0)
    {
      double v55 = v49;
      double v56 = v48;
      double v57 = floor((v50 + v55) * v56);
      double v58 = ceil((v50 - v55) * v56);
      if (!v42) {
        double v58 = v57;
      }
      double v59 = v58 / v56;
      *(double *)uint64_t v36 = v59;
      double v51 = v59 - v50;
    }
    float v60 = *(float *)(v36 + 24);
    if (fabs(v51) > fabs(v41) * v60)
    {
      *(double *)uint64_t v36 = v50 - v41 * v60;
      if (v60 > 100.0) {
        *(float *)(v36 + 24) = v60 * 0.5;
      }
LABEL_54:
      *(_DWORD *)(v36 + 28) = 15;
      goto LABEL_58;
    }
    int v62 = *(_DWORD *)(v36 + 28);
    BOOL v63 = __OFSUB__(v62, 1);
    int v64 = v62 - 1;
    if (v64 < 0 == v63)
    {
      *(_DWORD *)(v36 + 28) = v64;
      if (!v64)
      {
        *(float *)(v36 + 24) = v60 + v60;
        if ((float)(v60 + v60) < 10000.0) {
          goto LABEL_54;
        }
        *(void *)(v36 + 24) = 1176256512;
      }
    }
LABEL_58:
    ++v33;
  }
  while (v33 != v10);
  if (v34 == 0.0 && !*(_DWORD *)(a4 + 12)) {
    return 0;
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN2CA6Render12EmitterState12update_cellsEdRdPNS0_10TypedArrayINS0_11EmitterCellEEEPNS1_5CellsEPNS1_8ParticleEf_block_invoke;
  block[3] = &__block_descriptor_tmp_11174;
  block[4] = v8;
  void block[5] = v30;
  void block[6] = a4;
  block[7] = v31;
  block[8] = v31;
  *(double *)&block[9] = a6;
  block[10] = v66;
  dispatch_apply(v67, 0, block);
  *double v68 = a6;
  return 1;
}

void CA::Render::EmitterState::free_cells_state(CA::Render::EmitterState *a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 8))
  {
    unint64_t v4 = 0;
    do
      CA::Render::EmitterState::free_cell_state(a1, *(Cell **)(*(void *)a2 + 8 * v4++));
    while (v4 < *(unsigned int *)(a2 + 8));
    double v5 = *(void **)a2;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v5);
  }
}

void ___ZN2CA6Render12EmitterState12update_cellsEdRdPNS0_10TypedArrayINS0_11EmitterCellEEEPNS1_5CellsEPNS1_8ParticleEf_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v247 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8 * a2);
  uint64_t v6 = *(void *)(**(void **)(a1 + 48) + 8 * a2);
  double v7 = *(double *)(*(void *)(a1 + 56) + 8 * a2);
  __p = 0;
  int v241 = 0;
  int v242 = 0;
  double v9 = *(unsigned char **)(v4 + 144);
  double v8 = *(unsigned char **)(v4 + 152);
  int64_t v10 = v8 - v9;
  if (v8 != v9)
  {
    if (v8 - v9 < 0) {
      abort();
    }
    __p = std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v10 >> 3);
    int v242 = (char *)__p + 8 * v11;
    memmove(__p, v9, v10);
    int v241 = (char *)__p + v10;
    uint64_t v2 = a2;
  }
  int v239 = *(_DWORD *)(v4 + 168);
  if (v7 < 0.0 || *(double *)(*(void *)(a1 + 64) + 8 * v2) == 0.0)
  {
    if (*(unsigned char *)(v4 + 129)) {
      double v12 = INFINITY;
    }
    else {
      double v12 = -INFINITY;
    }
  }
  else
  {
    double v12 = *(double *)v6;
  }
  v13.i64[0] = 0x80000000800000;
  v13.i64[1] = 0x80000000800000;
  int32x4_t v245 = vdupq_n_s32(0x7F7FFFFFu);
  float32x4_t v246 = v13;
  uint64_t v14 = *(void *)(v6 + 8);
  uint64_t v15 = *(unsigned int *)(v6 + 16);
  unint64_t v16 = v14 + ((unint64_t)*(unsigned int *)(v6 + 20) << 7);
  float32x2_t v17 = (float32x2_t)1065353216;
  uint64_t v236 = v6;
  if (!*(_DWORD *)(v6 + 16)) {
    goto LABEL_11;
  }
  do
  {
LABEL_15:
    if (v14 == v16)
    {
      int v19 = *(_DWORD *)(v6 + 20);
      if (v19) {
        uint64_t v20 = (2 * v19);
      }
      else {
        uint64_t v20 = 16;
      }
      if (v20 > 0x20000) {
        goto LABEL_220;
      }
      unint64_t v21 = v20 + (*(_DWORD *)(v4 + 84) - v19);
      if (v21 > 0x80000) {
        goto LABEL_220;
      }
      uint64_t v22 = (char *)malloc_type_malloc(v20 << 7, 0x1080040F72ECE51uLL);
      if (!v22) {
        goto LABEL_220;
      }
      size_t v23 = v22;
      uint64_t v24 = *(unsigned int *)(v6 + 20);
      if (v24)
      {
        memcpy(v22, *(const void **)(v6 + 8), v24 << 7);
        free(*(void **)(v6 + 8));
        LODWORD(v24) = *(_DWORD *)(v6 + 20);
      }
      unint64_t v16 = (unint64_t)&v23[128 * v20];
      if (v24 < v20)
      {
        float64x2_t v25 = &v23[128 * (unint64_t)v24];
        do
        {
          *((_DWORD *)v25 + 6) = 0;
          v25 += 128;
        }
        while ((unint64_t)v25 < v16);
      }
      *(void *)(v6 + 8) = v23;
      *(_DWORD *)(v6 + 20) = v20;
      *(_DWORD *)(v4 + 84) = v21;
      uint64_t v14 = (uint64_t)&v23[128 * (unint64_t)*(unsigned int *)(v6 + 16)];
    }
    unint64_t v235 = v16;
    float v26 = *(float *)(v14 + 24);
    if (v26 != 0.0)
    {
      --v15;
      float v27 = *(double *)(a1 + 72) - *(double *)(v14 + 16);
      if (*(_DWORD *)(v14 + 12) || (v27 >= 0.0 ? (BOOL v28 = v26 <= v27) : (BOOL v28 = 1), !v28))
      {
        if (CA::Render::EmitterState::update_particle(v4, v5, v14, (float32x4_t *)&v245, &__p, v239, v27)) {
          goto LABEL_218;
        }
      }
      uint64_t v29 = *(void *)(a1 + 48);
      *(_DWORD *)(v14 + 24) = 0;
      --*(_DWORD *)(v6 + 16);
      --*(_DWORD *)(v29 + 12);
      if (*(_DWORD *)(v14 + 8)) {
        CA::Render::EmitterState::free_cells_state((CA::Render::EmitterState *)v4, v14);
      }
    }
    uint64_t v30 = a2;
    if (*(unsigned char *)(v4 + 129)) {
      BOOL v31 = v12 < v7;
    }
    else {
      BOOL v31 = v12 > v7;
    }
    if (!v31) {
      goto LABEL_218;
    }
    uint64_t v232 = v15;
    uint64_t v32 = (float32x2_t *)(v14 + 32);
    uint64_t v33 = (float32x4_t *)(v14 + 64);
    int v238 = (float *)(v14 + 112);
    while (1)
    {
      uint64_t v34 = *(void *)(a1 + 80);
      float v35 = *(float *)(v5 + 76);
      float v36 = *(float *)(v5 + 80);
      if (v36 != 0.0)
      {
        unsigned int v37 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
        *(_DWORD *)(v4 + 28) = v37;
        float v35 = v35 + (float)((float)((float)((float)HIWORD(v37) * 0.000015259) + -0.5) * v36);
      }
      *(float *)(v14 + 24) = v35;
      float v38 = *(float32x2_t **)(v4 + 136);
      *(float *)(v14 + 24) = v38[10].f32[0] * v35;
      if (v34)
      {
        float32x2_t v39 = *(float32x2_t *)(v34 + 32);
        *(_DWORD *)(v14 + 40) = *(_DWORD *)(v34 + 40);
        *uint64_t v32 = v39;
        *(void *)(v14 + 84) = *(void *)(v34 + 84);
        uint64_t v40 = *(void *)(v34 + 112);
        *(_DWORD *)(v14 + 120) = *(_DWORD *)(v34 + 120);
        *(void *)int v238 = v40;
        *uint64_t v33 = *(float32x4_t *)(v34 + 64);
        uint64_t v41 = *(void *)(v34 + 48);
        float v42 = *(float *)(v34 + 56);
        float v43 = 1.0
            / sqrtf((float)((float)(*(float *)&v41 * *(float *)&v41) + (float)(*((float *)&v41 + 1) * *((float *)&v41 + 1)))+ (float)(v42 * v42));
        *(float *)&unint64_t v243 = v43 * *(float *)&v41;
        *((float *)&v243 + 1) = v43 * *((float *)&v41 + 1);
        float v244 = v43 * v42;
        goto LABEL_151;
      }
      float32x2_t v44 = v38[11];
      *(_DWORD *)(v14 + 40) = v38[12].i32[0];
      *uint64_t v32 = v44;
      unint64_t v243 = (unint64_t)v17;
      float v244 = 0.0;
      uint64_t v45 = *(void *)(v4 + 136);
      int v46 = *(_DWORD *)(v45 + 68);
      long double v47 = 0.0;
      if (v46 == 499)
      {
        float32x2_t v48 = v17;
        float v49 = *(float *)(v45 + 84);
        long double v47 = fmod(v12, v49);
        if (v49 >= 0.0)
        {
          if (v47 < 0.0) {
            goto LABEL_51;
          }
        }
        else
        {
          if (v47 <= 0.0) {
            goto LABEL_52;
          }
LABEL_51:
          long double v47 = v47 + v49;
        }
LABEL_52:
        float v50 = v47;
        *(float *)&long double v47 = v50 / v49;
        float32x2_t v17 = v48;
      }
      int v51 = *(_DWORD *)(v45 + 64);
      if (v51 <= 422)
      {
        switch(v51)
        {
          case 89:
            if (v46 == 499) {
              goto LABEL_86;
            }
            if (v46 != 437)
            {
              if (v46 == 417)
              {
                unsigned int v60 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
                *(_DWORD *)(v4 + 28) = v60;
                *(float *)&long double v47 = (float)HIWORD(v60) * 0.000015259;
LABEL_86:
                CA::Render::EmitterState::point_on_circle((float *)(v14 + 32), (uint64_t)&v243, *(float *)&v47, *(float *)(v45 + 100) * 0.5);
                break;
              }
              float v92 = *(float *)(v45 + 100) * 0.5;
              unsigned int v93 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
              float v94 = (float)HIWORD(v93) * 0.000015259;
              unsigned int v95 = 214013 * v93 + 2531011;
              *(_DWORD *)(v4 + 28) = v95;
              CA::Render::EmitterState::point_on_circle((float *)(v14 + 32), (uint64_t)&v243, (float)HIWORD(v95) * 0.000015259, (float)(v94 * v92) / sqrtf(v94));
LABEL_122:
              unint64_t v243 = (unint64_t)v17;
LABEL_123:
              float v244 = 0.0;
            }
            break;
          case 155:
            if (v46 == 417)
            {
              float32x2_t v107 = *(float32x2_t *)(v45 + 100);
              float v108 = *(float *)(v45 + 108);
              unsigned int v109 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
              *(_DWORD *)(v4 + 28) = v109;
              float v110 = (float)HIWORD(v109) * 0.00018311;
              int v111 = vcvtms_s32_f32(v110);
              if (v111 >= 11) {
                int v111 = 11;
              }
              float v112 = v110 - (float)v111;
              uint64_t v113 = 9 * v111;
              float32x2_t v114 = vadd_f32(*(float32x2_t *)((char *)&CA::Render::EmitterState::point_on_cuboid_outline(CA::Vec3<float> &,CA::Vec3<float> &,float,float,float)::outlines+ 4 * v113), (float32x2_t)0xBF000000BF000000);
              float v115 = (char *)&CA::Render::EmitterState::point_on_cuboid_outline(CA::Vec3<float> &,CA::Vec3<float> &,float,float,float)::outlines
                   + 4 * (int)v113;
              *(float32x2_t *)(v14 + 32) = vmla_f32(*(float32x2_t *)(v14 + 32), v107, vmla_n_f32(v114, *(float32x2_t *)(v115 + 12), v112));
              *(float *)(v14 + 40) = *(float *)(v14 + 40)
                                   + (float)((float)((float)(*((float *)v115 + 2) + -0.5)
                                                   + (float)(*((float *)v115 + 5) * v112))
                                           * v108);
              unint64_t v243 = *((void *)v115 + 3);
              float v116 = *((float *)v115 + 8);
            }
            else
            {
              if (v46 != 554)
              {
                if (v46 == 437)
                {
                  float v62 = *(float *)(v14 + 36);
                  float v63 = *(float *)(v14 + 32) - (float)(*(float *)(v45 + 100) * 0.5);
                  *(float *)(v14 + 32) = v63;
                  float v64 = v62 - (float)(*(float *)(v45 + 104) * 0.5);
                  *(float *)(v14 + 36) = v64;
                  float v65 = *(float *)(v14 + 40) - (float)(*(float *)(v45 + 108) * 0.5);
                  *(float *)(v14 + 40) = v65;
                  unsigned int v66 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
                  if ((float)((float)HIWORD(v66) * 0.000015259) > 0.5) {
                    v32->f32[0] = *(float *)(v45 + 100) + v63;
                  }
                  unsigned int v67 = 214013 * v66 + 2531011;
                  if ((float)((float)HIWORD(v67) * 0.000015259) > 0.5) {
                    *(float *)(v14 + 36) = *(float *)(v45 + 104) + v64;
                  }
                  unsigned int v68 = 214013 * v67 + 2531011;
                  *(_DWORD *)(v4 + 28) = v68;
                  if ((float)((float)HIWORD(v68) * 0.000015259) <= 0.5) {
                    break;
                  }
                  float v69 = *(float *)(v45 + 108) + v65;
                }
                else
                {
                  float v128 = *(float *)(v45 + 100);
                  float v129 = 0.0;
                  float v130 = 0.0;
                  if (v128 != 0.0)
                  {
                    unsigned int v131 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
                    *(_DWORD *)(v4 + 28) = v131;
                    float v130 = (float)((float)((float)HIWORD(v131) * 0.000015259) + -0.5) * v128;
                  }
                  float v132 = *(float *)(v45 + 104);
                  if (v132 != 0.0)
                  {
                    unsigned int v133 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
                    *(_DWORD *)(v4 + 28) = v133;
                    float v129 = (float)((float)((float)HIWORD(v133) * 0.000015259) + -0.5) * v132;
                  }
                  float v134 = *(float *)(v45 + 108);
                  float v135 = 0.0;
                  if (v134 != 0.0)
                  {
                    unsigned int v136 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
                    *(_DWORD *)(v4 + 28) = v136;
                    float v135 = (float)((float)((float)HIWORD(v136) * 0.000015259) + -0.5) * v134;
                  }
                  float v137 = *(float *)(v14 + 36);
                  *(float *)(v14 + 32) = *(float *)(v14 + 32) + v130;
                  *(float *)(v14 + 36) = v137 + v129;
                  float v69 = *(float *)(v14 + 40) + v135;
                }
                *(float *)(v14 + 40) = v69;
                break;
              }
              float32x2_t v117 = *(float32x2_t *)(v45 + 100);
              float v118 = *(float *)(v45 + 108);
              unsigned int v119 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
              float v120 = (float)HIWORD(v119) * 0.000091554;
              int v121 = vcvtms_s32_f32(v120);
              if (v121 >= 5) {
                int v121 = 5;
              }
              float v122 = v120 - (float)v121;
              uint64_t v123 = 12 * v121;
              unsigned int v124 = 214013 * v119 + 2531011;
              *(_DWORD *)(v4 + 28) = v124;
              float v125 = (float)HIWORD(v124) * 0.000015259;
              uint64_t v126 = 4 * v123;
              CGRect v127 = (char *)&CA::Render::EmitterState::point_on_cuboid_surface(CA::Vec3<float> &,CA::Vec3<float> &,float,float,float)::surfaces
                   + 4 * (int)v123;
              *(float32x2_t *)(v14 + 32) = vmla_f32(*(float32x2_t *)(v14 + 32), v117, vmla_n_f32(vmla_n_f32(vadd_f32(*(float32x2_t *)((char *)&CA::Render::EmitterState::point_on_cuboid_surface(CA::Vec3<float> &,CA::Vec3<float> &,float,float,float)::surfaces+ v126), (float32x2_t)0xBF000000BF000000), *(float32x2_t *)(v127 + 24), v125), *(float32x2_t *)(v127 + 12), v122));
              *(float *)(v14 + 40) = *(float *)(v14 + 40)
                                   + (float)((float)((float)((float)(*((float *)v127 + 2) + -0.5)
                                                           + (float)(*((float *)v127 + 5) * v122))
                                                   + (float)(*((float *)v127 + 8) * v125))
                                           * v118);
              unint64_t v243 = *(void *)(v127 + 36);
              float v116 = *((float *)v127 + 11);
            }
            float v244 = v116;
            break;
          case 353:
            if (v46 == 499)
            {
              v32->f32[0] = v32->f32[0] + (float)(*(float *)(v45 + 100) * (float)(*(float *)&v47 + -0.5));
              unint64_t v243 = 0xBF80000000000000;
              break;
            }
            if (v46 == 437)
            {
              float v57 = v32->f32[0] - (float)(*(float *)(v45 + 100) * 0.5);
              v32->f32[0] = v57;
              unsigned int v58 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
              *(_DWORD *)(v4 + 28) = v58;
              if ((float)((float)HIWORD(v58) * 0.000015259) > 0.5) {
                v32->f32[0] = *(float *)(v45 + 100) + v57;
              }
              break;
            }
            float v70 = *(float *)(v45 + 100);
            float v71 = 0.0;
            if (v70 != 0.0)
            {
              unsigned int v72 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
              *(_DWORD *)(v4 + 28) = v72;
              float v71 = (float)((float)((float)HIWORD(v72) * 0.000015259) + -0.5) * v70;
            }
            v32->f32[0] = v32->f32[0] + v71;
            unint64_t v243 = 0xBF80000000000000;
            goto LABEL_123;
        }
      }
      else if (v51 > 459)
      {
        if (v51 == 460)
        {
          if (v46 == 499) {
            goto LABEL_91;
          }
          if (v46 != 437)
          {
            if (v46 == 417)
            {
              unsigned int v61 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
              *(_DWORD *)(v4 + 28) = v61;
              *(float *)&long double v47 = (float)HIWORD(v61) * 0.000015259;
LABEL_91:
              v13.i32[0] = *(_DWORD *)(v45 + 100);
              CA::Render::EmitterState::point_on_rectangles(*(void *)(v45 + 56), (float32x2_t *)(v14 + 32), (uint64_t)&v243, *(float32x2_t *)&v47, *(float32x2_t *)v13.f32, *(float32_t *)(v45 + 104));
              goto LABEL_150;
            }
            uint64_t v96 = *(void *)(v45 + 56);
            if (!v96) {
              goto LABEL_150;
            }
            uint64_t v97 = *(unsigned int *)(v96 + 16);
            unint64_t v98 = v97 / 5uLL;
            _ZF = v97 >= 5 && 5 * (v97 / 5uLL) == v97;
            if (!_ZF) {
              goto LABEL_150;
            }
            uint64_t v100 = 0;
            float32x2_t v101 = *(float32x2_t *)(v45 + 100);
            uint64_t v102 = v96 + 24;
            uint64_t v103 = v102 + 32 * v98;
            double v104 = *(double *)(v103 + 8 * v98 - 8);
            unsigned int v105 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
            *(_DWORD *)(v4 + 28) = v105;
            *(float *)&double v104 = v104 * (float)((float)HIWORD(v105) * 0.000015259);
            double v106 = *(float *)&v104;
            if (v98 <= 1) {
              unint64_t v98 = 1;
            }
            while (*(double *)(v103 + 8 * v100) <= v106)
            {
              if (v98 == ++v100) {
                goto LABEL_150;
              }
            }
            int v193 = (float64x2_t *)(v102 + 32 * v100);
            float64x2_t v190 = vcvtq_f64_f32(v101);
            int v194 = 214013 * v105 + 2531011;
            float64x2_t v195 = *v193;
            *(_DWORD *)(v4 + 28) = 214013 * v194 + 2531011;
            v196.i32[0] = v194;
            v196.i32[1] = 214013 * v194 + 2531011;
            __asm { FMOV            V4.2D, #-0.5 }
            float64x2_t v192 = vmlaq_f64(vaddq_f64(v195, _Q4), vcvtq_f64_f32(vmul_f32(vcvt_f32_u32(vshr_n_u32(v196, 0x10uLL)), (float32x2_t)vdup_n_s32(0x37800080u))), v193[1]);
LABEL_215:
            *uint64_t v32 = vcvt_f32_f64(vmlaq_f64(vcvtq_f64_f32(*v32), v190, v192));
          }
        }
        else if (v51 == 527)
        {
          if (v46 == 554) {
            goto LABEL_76;
          }
          if (v46 != 437)
          {
            if (v46 != 417)
            {
              float v81 = *(float *)(v45 + 100) * 0.5;
              unsigned int v82 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
              *(_DWORD *)(v4 + 28) = v82;
              float v83 = powf((float)HIWORD(v82) * 0.000015259, 0.33333);
              CA::Render::EmitterState::point_on_sphere(v4, v14 + 32, (uint64_t)&v243, v83 * v81);
              goto LABEL_122;
            }
LABEL_76:
            CA::Render::EmitterState::point_on_sphere(v4, v14 + 32, (uint64_t)&v243, *(float *)(v45 + 100) * 0.5);
          }
        }
      }
      else if (v51 == 423)
      {
        if (v46 == 499) {
          goto LABEL_81;
        }
        if (v46 != 437)
        {
          if (v46 != 417)
          {
            OSType v233 = *(CA::Render::Path **)(v45 + 48);
            if (!v233) {
              goto LABEL_150;
            }
            float32x2_t v84 = *(float32x2_t *)(v45 + 100);
            uint64_t v85 = CA::Render::Path::bounding_rect(v233);
            double v86 = *(double *)(v85 + 16);
            if (v86 >= *(double *)(v85 + 24)) {
              double v86 = *(double *)(v85 + 24);
            }
            if (v86 <= 0.0) {
              goto LABEL_150;
            }
            float v87 = (float64x2_t *)v85;
            int v88 = 1000;
            while (1)
            {
              int v89 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
              *(_DWORD *)(v4 + 28) = 214013 * v89 + 2531011;
              v90.i32[0] = v89;
              v90.i32[1] = 214013 * v89 + 2531011;
              CGPoint point = (CGPoint)vmlaq_f64(*v87, vcvtq_f64_f32(vmul_f32(vcvt_f32_u32(vshr_n_u32(v90, 0x10uLL)), (float32x2_t)vdup_n_s32(0x37800080u))), v87[1]);
              float v91 = (const CGPath *)CA::Render::Path::cg_path(v233);
              if (CGPathContainsPoint(v91, 0, point, 0)) {
                break;
              }
              if (!--v88) {
                goto LABEL_150;
              }
            }
            float64x2_t v190 = vcvtq_f64_f32(v84);
            __asm { FMOV            V1.2D, #-0.5 }
            float64x2_t v192 = vaddq_f64((float64x2_t)point, _Q1);
            goto LABEL_215;
          }
          unsigned int v59 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
          *(_DWORD *)(v4 + 28) = v59;
          *(float *)&long double v47 = (float)HIWORD(v59) * 0.000015259;
LABEL_81:
          CA::Render::EmitterState::point_on_path(*(CA::Render::Path **)(v45 + 48), (float32x2_t *)(v14 + 32), (uint64_t)&v243, *(float *)&v47, *(float *)(v45 + 100), *(float *)(v45 + 104));
        }
      }
      else if (v51 == 459)
      {
        if (v46 == 417)
        {
          unsigned int v73 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
          *(_DWORD *)(v4 + 28) = v73;
          *(float *)&long double v47 = (float)HIWORD(v73) * 0.000015259;
        }
        else if (v46 != 499)
        {
          if (v46 == 437)
          {
            float v52 = *(float *)(v14 + 36);
            float v53 = *(float *)(v14 + 32) - (float)(*(float *)(v45 + 100) * 0.5);
            *(float *)(v14 + 32) = v53;
            float v54 = v52 - (float)(*(float *)(v45 + 104) * 0.5);
            *(float *)(v14 + 36) = v54;
            unsigned int v55 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
            if ((float)((float)HIWORD(v55) * 0.000015259) > 0.5) {
              v32->f32[0] = *(float *)(v45 + 100) + v53;
            }
            unsigned int v56 = 214013 * v55 + 2531011;
            *(_DWORD *)(v4 + 28) = v56;
            if ((float)((float)HIWORD(v56) * 0.000015259) > 0.5) {
              *(float *)(v14 + 36) = *(float *)(v45 + 104) + v54;
            }
          }
          else
          {
            float v74 = *(float *)(v45 + 100);
            float v75 = 0.0;
            float v76 = 0.0;
            if (v74 != 0.0)
            {
              unsigned int v77 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
              *(_DWORD *)(v4 + 28) = v77;
              float v76 = (float)((float)((float)HIWORD(v77) * 0.000015259) + -0.5) * v74;
            }
            float v78 = *(float *)(v45 + 104);
            if (v78 != 0.0)
            {
              unsigned int v79 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
              *(_DWORD *)(v4 + 28) = v79;
              float v75 = (float)((float)((float)HIWORD(v79) * 0.000015259) + -0.5) * v78;
            }
            float v80 = *(float *)(v14 + 36) + v75;
            *(float *)(v14 + 32) = *(float *)(v14 + 32) + v76;
            *(float *)(v14 + 36) = v80;
          }
          goto LABEL_150;
        }
        CA::Render::EmitterState::point_on_rectangle((float *)(v14 + 32), (uint64_t)&v243, *(float *)&v47, *(float *)(v45 + 100), *(float *)(v45 + 104));
      }
LABEL_150:
      *(_DWORD *)(v14 + 88) = 0;
      *(void *)(v14 + 112) = 0;
      *(_DWORD *)(v14 + 120) = 1065353216;
      *(_DWORD *)(v14 + 84) = *(_DWORD *)(*(void *)(v4 + 136) + 116);
      __asm { FMOV            V0.4S, #1.0 }
      *(_OWORD *)(v14 + 64) = _Q0;
      uint64_t v6 = v236;
      uint64_t v30 = a2;
LABEL_151:
      CA::Render::EmitterState::adjust_vector(v4, (float *)&v243, *(float *)(v5 + 88), *(float *)(v5 + 84), *(float *)(v5 + 92));
      float v141 = *(float *)(v5 + 92);
      if (v141 != 0.0) {
        CA::Render::EmitterState::apply_random_deviation(v4, (float *)&v243, v141);
      }
      float v142 = *(float *)(v5 + 96);
      float v143 = *(float *)(v5 + 100);
      if (v143 != 0.0)
      {
        unsigned int v144 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
        *(_DWORD *)(v4 + 28) = v144;
        float v142 = v142 + (float)((float)((float)((float)HIWORD(v144) * 0.000015259) + -0.5) * v143);
      }
      float v145 = *(float *)(*(void *)(v4 + 136) + 112) * v142;
      float v146 = v244 * v145;
      *(float32x2_t *)(v14 + 48) = vmul_n_f32((float32x2_t)v243, v145);
      *(float *)(v14 + 56) = v146;
      if (*(_DWORD *)(v5 + 64) == 426)
      {
        CA::Render::EmitterState::adjust_vector(v4, v238, *(float *)(v5 + 140), *(float *)(v5 + 136), *(float *)(v5 + 144));
      }
      else
      {
        *(void *)(v14 + 112) = 0;
        *(_DWORD *)(v14 + 120) = 1065353216;
      }
      *(_DWORD *)(v14 + 44) = 1065353216;
      float v147 = *(float *)(v5 + 148);
      float v148 = *(float *)(v5 + 152);
      if (v148 != 0.0)
      {
        unsigned int v149 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
        *(_DWORD *)(v4 + 28) = v149;
        float v147 = v147 + (float)((float)((float)((float)HIWORD(v149) * 0.000015259) + -0.5) * v148);
      }
      *(float *)(v14 + 88) = *(float *)(v14 + 88) + v147;
      float v150 = *(float *)(v5 + 156);
      float v151 = *(float *)(v5 + 160);
      if (v151 != 0.0)
      {
        unsigned int v152 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
        *(_DWORD *)(v4 + 28) = v152;
        float v150 = v150 + (float)((float)((float)((float)HIWORD(v152) * 0.000015259) + -0.5) * v151);
      }
      *(float *)(v14 + 92) = v150;
      float v153 = *(float *)(v5 + 124);
      float v154 = *(float *)(v5 + 128);
      if (v154 != 0.0)
      {
        unsigned int v155 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
        *(_DWORD *)(v4 + 28) = v155;
        float v153 = v153 + (float)((float)((float)((float)HIWORD(v155) * 0.000015259) + -0.5) * v154);
      }
      *(float *)(v14 + 84) = *(float *)(v14 + 84) * v153;
      *(_DWORD *)(v14 + 124) = *(_DWORD *)(v5 + 132);
      int v156 = *(_DWORD *)(v5 + 68);
      if (v156 != 455)
      {
        if (v156 != 499)
        {
          *(_DWORD *)(v14 + 80) = 0;
          goto LABEL_183;
        }
        float v157 = fmaxf(*(float *)(v5 + 220), 1.0);
        float v158 = *(float *)(v6 + 32);
        if (v158 >= v157 || v158 < 0.0) {
          float v158 = 0.0;
        }
        *(float *)(v14 + 80) = v158;
        float v160 = fmodf(v158 + 1.0, v157);
        if (v157 >= 0.0)
        {
          if (v160 >= 0.0)
          {
LABEL_182:
            *(float *)(v6 + 32) = v160;
            goto LABEL_183;
          }
        }
        else if (v160 <= 0.0)
        {
          goto LABEL_182;
        }
        float v160 = v160 + v157;
        goto LABEL_182;
      }
      float v161 = *(float *)(v5 + 220);
      unsigned int v162 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
      *(_DWORD *)(v4 + 28) = v162;
      unsigned int v163 = HIWORD(v162);
      float v164 = v161 >= 1.0 ? v161 * 0.000015259 : 0.000015259;
      *(float *)(v14 + 80) = v164 * (float)v163;
LABEL_183:
      v165.i32[0] = *(_DWORD *)(v5 + 164);
      float v166 = *(float *)(v5 + 180);
      if (v166 != 0.0)
      {
        unsigned int v167 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
        *(_DWORD *)(v4 + 28) = v167;
        v165.f32[0] = v165.f32[0] + (float)((float)((float)((float)HIWORD(v167) * 0.000015259) + -0.5) * v166);
      }
      float v168 = *(float *)(v5 + 168);
      float v169 = *(float *)(v5 + 184);
      if (v169 != 0.0)
      {
        unsigned int v170 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
        *(_DWORD *)(v4 + 28) = v170;
        float v168 = v168 + (float)((float)((float)((float)HIWORD(v170) * 0.000015259) + -0.5) * v169);
      }
      float v171 = *(float *)(v5 + 172);
      float v172 = *(float *)(v5 + 188);
      if (v172 != 0.0)
      {
        unsigned int v173 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
        *(_DWORD *)(v4 + 28) = v173;
        float v171 = v171 + (float)((float)((float)((float)HIWORD(v173) * 0.000015259) + -0.5) * v172);
      }
      float v174 = *(float *)(v5 + 176);
      float v175 = *(float *)(v5 + 192);
      if (v175 != 0.0)
      {
        unsigned int v176 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
        *(_DWORD *)(v4 + 28) = v176;
        float v174 = v174 + (float)((float)((float)((float)HIWORD(v176) * 0.000015259) + -0.5) * v175);
      }
      v165.f32[1] = v168;
      float32x4_t v13 = *v33;
      v165.i64[1] = __PAIR64__(LODWORD(v174), LODWORD(v171));
      *uint64_t v33 = vmulq_f32(*v33, v165);
      *(float32x4_t *)(v14 + 96) = *v33;
      float v177 = *(float *)(v5 + 116);
      v13.i32[0] = *(_DWORD *)(v5 + 120);
      if (v13.f32[0] != 0.0)
      {
        unsigned int v178 = 214013 * *(_DWORD *)(v4 + 28) + 2531011;
        *(_DWORD *)(v4 + 28) = v178;
        float v177 = v177 + (float)((float)((float)((float)HIWORD(v178) * 0.000015259) + -0.5) * v13.f32[0]);
      }
      *(float *)(v14 + 28) = 1.0 / v177;
      *(void *)uint64_t v14 = 0;
      *(void *)(v14 + 8) = 0;
      int v179 = *(unsigned __int8 *)(v4 + 129);
      v13.i32[0] = *(_DWORD *)(v14 + 24);
      if (*(unsigned char *)(v4 + 129)) {
        double v180 = 0.0;
      }
      else {
        double v180 = v13.f32[0];
      }
      double v181 = v12 - v180;
      double v182 = -0.0;
      if (*(unsigned char *)(v4 + 129)) {
        double v182 = v13.f32[0];
      }
      double v183 = *(double *)(*(void *)(a1 + 64) + 8 * v30);
      uint64_t v184 = *(void *)(v5 + 56);
      if (v184)
      {
        double v185 = v12 + v182;
        float v186 = *(float *)(v184 + 16);
        if (v186 != 1.0)
        {
          double v187 = (float)(1.0 / v186);
          double v181 = v181 * v187;
          double v185 = v185 * v187;
        }
        *(double *)v13.i64 = v185 - v181;
        double v181 = *(double *)(v184 + 40) + v181;
        v13.f32[0] = *(double *)v13.i64;
        *(_DWORD *)(v14 + 24) = v13.i32[0];
      }
      double v12 = v183 + v12;
      *(double *)(v14 + 16) = v181;
      *(_DWORD *)(v14 + 60) = 0;
      if (v181 <= 0.0) {
        goto LABEL_208;
      }
      if (v13.f32[0] <= 0.0) {
        goto LABEL_208;
      }
      float v188 = *(double *)(a1 + 72) - v181;
      if (v188 < 0.0 || v13.f32[0] <= v188) {
        goto LABEL_208;
      }
      if (CA::Render::EmitterState::update_particle(v4, v5, v14, (float32x4_t *)&v245, &__p, v239, v188)) {
        break;
      }
      int v179 = *(unsigned __int8 *)(v4 + 129);
LABEL_208:
      *(_DWORD *)(v14 + 24) = 0;
      if (v179) {
        BOOL v189 = v12 < v7;
      }
      else {
        BOOL v189 = v12 > v7;
      }
      if (!v189) {
        goto LABEL_217;
      }
    }
    ++*(_DWORD *)(v6 + 16);
    ++*(_DWORD *)(*(void *)(a1 + 48) + 12);
LABEL_217:
    uint64_t v15 = v232;
LABEL_218:
    v14 += 128;
    unint64_t v16 = v235;
  }
  while (v15);
LABEL_11:
  if (*(unsigned char *)(v4 + 129)) {
    BOOL v18 = v12 < v7;
  }
  else {
    BOOL v18 = v12 > v7;
  }
  if (v18) {
    goto LABEL_15;
  }
LABEL_220:
  if (v7 >= 0.0 && *(double *)(*(void *)(a1 + 64) + 8 * a2) != 0.0) {
    *(double *)uint64_t v6 = v12;
  }
  if (*(_DWORD *)(v6 + 16))
  {
    uint64_t v198 = *(void *)(v5 + 24);
    int32x2_t v199 = 0;
    if (v198)
    {
      OSType v200 = (uint32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v198 + 80))(v198);
      int32x2_t v199 = 0;
      if (v200)
      {
        double v201 = COERCE_DOUBLE(vcvt_f32_u32(v200[2]));
        float v202 = *(float *)(v5 + 216);
        _ZF = v202 == 1.0;
        double v203 = COERCE_DOUBLE(vmul_n_f32(*(float32x2_t *)&v201, 1.0 / v202));
        if (!_ZF) {
          double v201 = v203;
        }
        uint64_t v204 = *(void *)(v5 + 32);
        if (v204)
        {
          float64x2_t v205 = 0uLL;
          if (*(_DWORD *)(v204 + 16) >= 4u) {
            float64x2_t v205 = vsubq_f64(*(float64x2_t *)(v204 + 40), *(float64x2_t *)(v204 + 24));
          }
          double v201 = COERCE_DOUBLE(vcvt_f32_f64(vmulq_f64(v205, vcvtq_f64_f32(*(float32x2_t *)&v201))));
        }
        if (*(float *)&v201 <= *((float *)&v201 + 1)) {
          *(float *)&double v201 = *((float *)&v201 + 1);
        }
        *(float *)v199.i32 = *(float *)&v201 * *(float *)(v4 + 80);
        float32x2_t v206 = (float32x2_t)vdup_lane_s32(v199, 0);
        *(float32x2_t *)v245.i8 = vsub_f32(*(float32x2_t *)v245.i8, v206);
        *(float32x2_t *)v246.f32 = vadd_f32(*(float32x2_t *)v246.f32, v206);
        *(float *)&v245.i32[2] = *(float *)&v245.i32[2] - *(float *)v199.i32;
      }
    }
    float v207 = v246.f32[2] + *(float *)v199.i32;
    if ((float)(*(float *)&v245.i32[2] - *(float *)v199.i32) <= (float)(v246.f32[2] + *(float *)v199.i32))
    {
      float32x2_t v208 = (float32x2_t)vdup_lane_s32(v199, 0);
      float64x2_t v209 = vcvtq_f64_f32(vsub_f32(*(float32x2_t *)v245.i8, v208));
      float64x2_t v210 = vcvtq_f64_f32(vadd_f32(*(float32x2_t *)v246.f32, v208));
      double v211 = (float)(*(float *)&v245.i32[2] - *(float *)v199.i32);
      double v212 = v207;
      double v213 = *(double *)(v4 + 72);
      double v214 = *(double *)(v4 + 48);
      if (v213 < v214)
      {
        *(float64x2_t *)(v4 + 32) = v209;
        *(double *)(v4 + 48) = v211;
        *(float64x2_t *)(v4 + 56) = v210;
        goto LABEL_249;
      }
      if (v209.f64[0] < *(double *)(v4 + 32)) {
        *(float64_t *)(v4 + 32) = v209.f64[0];
      }
      if (v209.f64[1] < *(double *)(v4 + 40)) {
        *(float64_t *)(v4 + 40) = v209.f64[1];
      }
      if (v214 > v211) {
        *(double *)(v4 + 48) = v211;
      }
      if (v210.f64[0] > *(double *)(v4 + 56)) {
        *(float64_t *)(v4 + 56) = v210.f64[0];
      }
      if (v210.f64[1] > *(double *)(v4 + 64)) {
        *(float64_t *)(v4 + 64) = v210.f64[1];
      }
      if (v213 < v212) {
LABEL_249:
      }
        *(double *)(v4 + 72) = v212;
    }
  }
  unsigned int v215 = *(_DWORD *)(v6 + 20);
  if (v215)
  {
    unsigned int v216 = *(_DWORD *)(v6 + 16);
    if (!v216)
    {
      *(_DWORD *)(v4 + 84) -= v215;
      free(*(void **)(v6 + 8));
      unsigned int v215 = 0;
      *(void *)(v6 + 8) = 0;
      *(_DWORD *)(v6 + 20) = 0;
      unsigned int v216 = *(_DWORD *)(v6 + 16);
    }
    unint64_t v217 = v215;
    do
    {
      unint64_t v218 = v217;
      v217 >>= 1;
    }
    while (v217 > v216);
    if (v218 != v215 && v218 >= 0x10)
    {
      unint64_t v219 = v218 + *(_DWORD *)(v4 + 84) - v215;
      if (v219 <= 0x80000)
      {
        int v220 = (char *)malloc_type_malloc(v218 << 7, 0x1080040F72ECE51uLL);
        if (v220)
        {
          uint32_t v221 = v220;
          uint64_t v222 = *(unsigned int *)(v6 + 20);
          unsigned int v223 = v220;
          if (v222)
          {
            int v224 = *(float **)(v6 + 8);
            unsigned int v223 = v220;
            do
            {
              if (v224[6] != 0.0)
              {
                long long v225 = *(_OWORD *)v224;
                long long v226 = *((_OWORD *)v224 + 1);
                long long v227 = *((_OWORD *)v224 + 3);
                *((_OWORD *)v223 + 2) = *((_OWORD *)v224 + 2);
                *((_OWORD *)v223 + 3) = v227;
                *(_OWORD *)unsigned int v223 = v225;
                *((_OWORD *)v223 + 1) = v226;
                long long v228 = *((_OWORD *)v224 + 4);
                long long v229 = *((_OWORD *)v224 + 5);
                long long v230 = *((_OWORD *)v224 + 7);
                *((_OWORD *)v223 + 6) = *((_OWORD *)v224 + 6);
                *((_OWORD *)v223 + 7) = v230;
                *((_OWORD *)v223 + 4) = v228;
                *((_OWORD *)v223 + 5) = v229;
                v223 += 128;
              }
              v224 += 32;
              --v222;
            }
            while (v222);
          }
          while (v223 < &v220[128 * v218])
          {
            *((_DWORD *)v223 + 6) = 0;
            v223 += 128;
          }
          free(*(void **)(v6 + 8));
          *(void *)(v6 + 8) = v221;
          *(_DWORD *)(v6 + 20) = v218;
          *(_DWORD *)(v4 + 84) = v219;
        }
      }
    }
  }
  int v231 = __p;
  if (__p)
  {
    operator delete(v231);
  }
}

uint64_t CA::Render::EmitterState::update_particle(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, void *a5, char a6, float a7)
{
  float v10 = a7;
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  float v12 = a7 - *(float *)(a3 + 60);
  *(float *)(a3 + 60) = a7;
  *(_DWORD *)(a3 + 44) = 1065353216;
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(a3 + 96);
  float v49 = 0.0;
  uint64_t v48 = 0;
  uint64_t v13 = a5[1] - *a5;
  if (v13)
  {
    float v44 = v12;
    float32x4_t v47 = 0uLL;
    if (v13 >= 1)
    {
      uint64_t v16 = ((unint64_t)v13 >> 3) - 1;
      do
      {
        (*(void (**)(void, uint64_t, uint64_t *, float32x4_t *))(**(void **)(*a5 + 8 * v16) + 24))(*(void *)(*a5 + 8 * v16), a3, &v48, &v47);
        unint64_t v17 = v16-- + 1;
      }
      while (v17 > 1);
    }
    if (a6)
    {
      __asm { FMOV            V1.4S, #1.0 }
      *(float32x4_t *)(a3 + 64) = vmulq_f32(*(float32x4_t *)(a3 + 64), vmaxq_f32(vminq_f32(v47, _Q1), (float32x4_t)0));
    }
    float32x2_t v23 = (float32x2_t)v48;
    float v24 = v49;
    float v12 = v44;
    float v10 = a7;
  }
  else
  {
    float32x2_t v23 = 0;
    float v24 = 0.0;
  }
  *(float32x2_t *)v25.f32 = vadd_f32(v23, *(float32x2_t *)(a2 + 104));
  uint64_t v48 = v25.i64[0];
  float v49 = v24 + *(float *)(a2 + 112);
  v25.i64[1] = LODWORD(v49);
  float32x4_t v26 = vmulq_n_f32(v25, *(float *)(a3 + 28));
  float32x4_t v27 = vmlaq_n_f32(*(float32x4_t *)(a3 + 48), v26, v12);
  float32x4_t v28 = vmlaq_n_f32(*(float32x4_t *)(a3 + 32), vmlaq_n_f32(*(float32x4_t *)(a3 + 48), v26, v12 * 0.5), v12);
  float32x4_t v29 = *(float32x4_t *)(a3 + 64);
  *(float32x4_t *)(a3 + 32) = v28;
  float32x4_t v30 = *(float32x4_t *)(a2 + 196);
  *(float32x4_t *)(a3 + 48) = v27;
  float32x4_t v31 = vmlaq_n_f32(v29, v30, v10);
  float32x4_t v32 = *a4;
  float32x4_t v33 = a4[1];
  *(float32x4_t *)(a3 + 64) = v31;
  uint64_t v34 = *(float32x4_t **)(a1 + 176);
  if (!v34
    || *(void *)(a2 + 40)
    || (uint64_t result = 0, v36 = vorrq_s8((int8x16_t)vcgtq_f32(v28, v34[1]), (int8x16_t)vcgtq_f32(*v34, v28)), !v36.i32[0])
    && (v36.i32[0] = vextq_s8(v36, v36, 8uLL).u32[0],
        *(int32x2_t *)v36.i8 = vceqz_s32(*(int32x2_t *)v36.i8),
        (v36.i8[4] & 1) != 0)
    && (v36.i8[0] & 1) != 0)
  {
    *a4 = vminq_f32(v32, v28);
    a4[1] = vmaxq_f32(v33, v28);
    v37.i32[0] = *(_DWORD *)(a3 + 124);
    v37.i32[1] = *(_DWORD *)(a3 + 92);
    float32x2_t v38 = vmla_n_f32(*(float32x2_t *)(a3 + 84), v37, v12);
    *(float32x2_t *)(a3 + 84) = v38;
    float v39 = *(float *)(a2 + 228);
    if (v39 == 0.0)
    {
LABEL_21:
      if (v38.f32[0] > *(float *)(a1 + 80)) {
        *(_DWORD *)(a1 + 80) = v38.i32[0];
      }
      if (*(void *)(a2 + 40))
      {
        float v42 = 0.0;
        if (v10 >= 0.0)
        {
          float v42 = 0.0;
          if (*(float *)(a3 + 24) > v10) {
            float v42 = 1.0;
          }
        }
        float v43 = *(float *)(a3 + 44) * v42;
        v47.i64[0] = 0;
        CA::Render::EmitterState::update_cells(a1, &v47, v10, v43);
      }
      return 1;
    }
    __int32 v45 = v38.i32[0];
    float v40 = fmaxf(*(float *)(a2 + 220), 1.0);
    float v41 = fmodf(*(float *)(a3 + 80) + (float)(v39 * v12), v40);
    if (v40 >= 0.0)
    {
      if (v41 >= 0.0)
      {
LABEL_20:
        *(float *)(a3 + 80) = v41;
        v38.i32[0] = v45;
        float v10 = a7;
        goto LABEL_21;
      }
    }
    else if (v41 <= 0.0)
    {
      goto LABEL_20;
    }
    float v41 = v41 + v40;
    goto LABEL_20;
  }
  return result;
}

float *CA::Render::EmitterState::point_on_rectangle(float *result, uint64_t a2, float a3, float a4, float a5)
{
  float v5 = *result - (float)(a4 * 0.5);
  float v6 = result[1] - (float)(a5 * 0.5);
  result[1] = v6;
  float v7 = a3 * (float)((float)(a5 + a4) + (float)(a5 + a4));
  if (v7 >= a4)
  {
    float v9 = v7 - a4;
    void *result = v5 + a4;
    if ((float)(v7 - a4) >= a5)
    {
      float v10 = v9 - a5;
      float v11 = v6 + a5;
      result[1] = v11;
      if (v10 >= a4)
      {
        void *result = v5;
        result[1] = (float)(a4 - v10) + v11;
        unint64_t v8 = 3212836864;
      }
      else
      {
        void *result = (float)(v5 + a4) - v10;
        unint64_t v8 = 0x3F80000000000000;
      }
    }
    else
    {
      result[1] = v6 + v9;
      unint64_t v8 = 1065353216;
    }
  }
  else
  {
    void *result = v5 + v7;
    unint64_t v8 = 0xBF80000000000000;
  }
  *(void *)a2 = v8;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

float CA::Render::EmitterState::point_on_circle(float *a1, uint64_t a2, float a3, float a4)
{
  if (a3 > 0.5) {
    a3 = a3 + -1.0;
  }
  float v4 = (float)(a3 + a3) * 3.14159265;
  float v5 = v4 * v4;
  float result = (float)((float)((float)((float)((float)(v4 * v4) * 0.0054654) + -0.15346) * (float)(v4 * v4)) + 0.98442) * v4;
  float v7 = (float)((float)((float)((float)((float)(v5 * -0.00096967) + 0.039228) * v5) + -0.49535) * v5) + 0.99861;
  float v8 = *a1 + (float)(v7 * a4);
  float v9 = a1[1] + (float)(result * a4);
  *a1 = v8;
  a1[1] = v9;
  *(float *)a2 = v7;
  *(float *)(a2 + 4) = result;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

float CA::Render::EmitterState::point_on_sphere(uint64_t a1, uint64_t a2, uint64_t a3, float32_t a4)
{
  unsigned int v6 = 214013 * *(_DWORD *)(a1 + 28) + 2531011;
  float v7 = (float)HIWORD(v6) * 0.000015259;
  unsigned int v8 = 214013 * v6 + 2531011;
  *(_DWORD *)(a1 + 28) = v8;
  float v9 = v7 * 6.28318531 + -3.14159265;
  float v10 = acosf((float)((float)HIWORD(v8) * 0.000030518) + -1.0);
  v11.i32[0] = 1065329841;
  float v12 = (float)((float)((float)((float)(0.039228 - (float)((float)(v9 * v9) * 0.00096967)) * (float)(v9 * v9)) + -0.49535)
              * (float)(v9 * v9))
      + 0.99861;
  v13.i32[0] = -1105386157;
  v14.f32[0] = (float)((float)((float)((float)((float)(v9 * v9) * 0.0054654) + -0.15346) * (float)(v9 * v9)) + 0.98442)
             * v9;
  *(float *)v15.i32 = v10 * v10;
  float32x2_t v16 = (float32x2_t)vdup_lane_s32(v15, 0);
  float32x2_t v17 = vmul_n_f32((float32x2_t)0x3A7E31513BB31712, v10 * v10);
  v13.i32[0] = vadd_f32(v17, v13).u32[0];
  v13.i32[1] = vsub_f32((float32x2_t)vdup_n_s32(0x3D20AD37u), v17).i32[1];
  float32x2_t v18 = vmla_n_f32((float32x2_t)0xBEFD9E7A3F7C02BDLL, v13, v10 * v10);
  v16.f32[0] = v10;
  float32x2_t v19 = (float32x2_t)vdup_lane_s32(v11, 0);
  float32x2_t v20 = vmul_f32(v18, v16);
  float32x2_t v21 = vadd_f32(v20, v19);
  v19.f32[0] = a4;
  v19.i32[0] = vmul_f32(v20, v19).u32[0];
  v19.i32[1] = v21.i32[1];
  *(float *)a2 = vmlas_n_f32(*(float *)a2, v12, v19.f32[0]);
  v14.f32[1] = a4;
  *(float32x2_t *)(a2 + 4) = vmla_f32(*(float32x2_t *)(a2 + 4), v14, v19);
  float result = v12 * v20.f32[0];
  *(float *)a3 = v12 * v20.f32[0];
  *(float *)(a3 + 4) = v14.f32[0] * v20.f32[0];
  *(_DWORD *)(a3 + 8) = v21.i32[1];
  return result;
}

CA::Render::Path *CA::Render::EmitterState::point_on_path(CA::Render::Path *result, float32x2_t *a2, uint64_t a3, float a4, float a5, float a6)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    float v9 = result;
    float64x2_t v27 = 0uLL;
    double v26 = 0.0;
    float result = (CA::Render::Path *)CA::Render::Path::keyframe_lengths(result);
    if (result)
    {
      float v10 = result;
      float v11 = 0.0;
      if (a4 >= 0.0) {
        float v11 = a4;
      }
      float v12 = v11 >= 1.0 ? 0.9999 : v11;
      if (!*((void *)v9 + 8)) {
        float result = (CA::Render::Path *)CA::Render::Path::keyframe_lengths(v9);
      }
      uint64_t v13 = *((unsigned int *)v9 + 4);
      if ((int)v13 >= 1)
      {
        uint64_t v14 = 0;
        double v15 = *((double *)v9 + 9) * v12;
        while (1)
        {
          double v16 = *((double *)v10 + v14);
          if (v15 < v16) {
            break;
          }
          double v15 = v15 - v16;
          if (v13 == ++v14) {
            return result;
          }
        }
        float v17 = v15 / v16;
        float result = (CA::Render::Path *)CA::Render::Path::interpolate(v9, v14, 1, &v27, 0, 0, &v26, 0, v17, 0.0);
        if (result)
        {
          __asm { FMOV            V2.2D, #-0.5 }
          float v23 = v26 + -1.57079633;
          *a2 = vcvt_f32_f64(vmlaq_f64(vcvtq_f64_f32(*a2), vcvtq_f64_f32((float32x2_t)__PAIR64__(LODWORD(a6), LODWORD(a5))), vaddq_f64(v27, _Q2)));
          *(float *)a3 = (float)((float)((float)((float)((float)((float)(v23 * v23) * -0.00096967) + 0.039228)
                                               * (float)(v23 * v23))
                                       + -0.49535)
                               * (float)(v23 * v23))
                       + 0.99861;
          *(float *)(a3 + 4) = (float)((float)((float)((float)((float)(v23 * v23) * 0.0054654) + -0.15346)
                                             * (float)(v23 * v23))
                                     + 0.98442)
                             * v23;
          *(_DWORD *)(a3 + 8) = 0;
        }
      }
    }
  }
  return result;
}

float32x2_t CA::Render::EmitterState::point_on_rectangles(uint64_t a1, float32x2_t *a2, uint64_t a3, float32x2_t result, float32x2_t a5, float32_t a6)
{
  if (a1)
  {
    uint64_t v6 = *(unsigned int *)(a1 + 16);
    if (v6 >= 5 && 5 * (v6 / 5uLL) == v6)
    {
      if (v6 / 5uLL <= 1) {
        unint64_t v9 = 1;
      }
      else {
        unint64_t v9 = v6 / 5uLL;
      }
      float v10 = (double *)(a1 + 48);
      double v11 = 0.0;
      unint64_t v12 = v9;
      do
      {
        double v11 = *(v10 - 1) + v11 + *v10;
        v10 += 4;
        --v12;
      }
      while (v12);
      uint64_t v13 = 0;
      float v14 = v11 * result.f32[0];
      *(double *)&float result = v14;
      double v15 = (float64x2_t *)(a1 + 40);
      uint64_t v16 = 4 * v9;
      double v17 = 0.0;
      while (1)
      {
        float64x2_t v18 = *v15;
        double v19 = vaddvq_f64(*v15);
        if (v19 + v17 > *(double *)&result) {
          break;
        }
        v13 += 4;
        v15 += 2;
        double v17 = v19 + v17;
        if (v16 == v13) {
          return result;
        }
      }
      float v20 = *(double *)&result - v17;
      float v21 = v20 / v19;
      float v22 = v18.f64[0];
      float v23 = v18.f64[1];
      __asm { FMOV            V5.2D, #0.5 }
      float64x2_t v31 = _Q5;
      a5.f32[1] = a6;
      float64x2_t v29 = *(float64x2_t *)(a1 + 24 + 8 * v13);
      float64x2_t v30 = vcvtq_f64_f32(a5);
      float64x2_t v28 = *v15;
      CA::Render::EmitterState::point_on_rectangle((float *)a2, a3, v21, v22, v23);
      float result = vcvt_f32_f64(vmulq_f64(vaddq_f64(vmlaq_f64(v29, v31, v28), vcvtq_f64_f32(*a2)), v30));
      *a2 = result;
    }
  }
  return result;
}

void CA::Render::EmitterState::adjust_vector(uint64_t a1, float *a2, float a3, float a4, float a5)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a3 != 0.0 || a4 != 0.0)
  {
    float v8 = a4 + 1.5708;
    if (fabsf(a4 + 1.5708) >= 0.00001)
    {
      __float2 v12 = __sincosf_stret(a3);
      __float2 v13 = __sincosf_stret(v8);
      float cosval = v13.__cosval;
      float v10 = v13.__sinval * v12.__cosval;
      float v11 = v13.__sinval * v12.__sinval;
    }
    else
    {
      float cosval = 1.0;
      float v10 = 0.0;
      float v11 = 0.0;
    }
    unint64_t v16 = __PAIR64__(LODWORD(v11), LODWORD(v10));
    float v17 = cosval;
    uint64_t v14 = 1065353216;
    int v15 = 0;
  }
  if (a5 != 0.0)
  {
    CA::Render::EmitterState::apply_random_deviation(a1, a2, a5);
  }
}

void CA::Render::EmitterState::apply_random_deviation(uint64_t a1, float *a2, float a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = 214013 * *(_DWORD *)(a1 + 28) + 2531011;
  unsigned int v5 = 214013 * v4 + 2531011;
  *(_DWORD *)(a1 + 28) = v5;
  float v6 = (float)HIWORD(v5);
  float v7 = cosf(a3 * 0.5);
  float cosval = 1.0;
  float v9 = acosf((float)((float)((float)(v7 * 0.000015259) + -0.000015259) * v6) + 1.0);
  float v10 = 0.0;
  float v11 = 0.0;
  if (fabsf(v9) >= 0.00001)
  {
    float v12 = (float)((float)((float)HIWORD(v4) * 0.000015259) + -0.5) * 6.28318531;
    __float2 v13 = __sincosf_stret(v12);
    __float2 v14 = __sincosf_stret(v9);
    float cosval = v14.__cosval;
    float v10 = v13.__cosval * v14.__sinval;
    float v11 = v13.__sinval * v14.__sinval;
  }
  unint64_t v17 = __PAIR64__(LODWORD(v11), LODWORD(v10));
  float v18 = cosval;
  uint64_t v15 = 0;
  int v16 = 1065353216;
}

void CA::Render::anonymous namespace'::rotate_vector(float *a1, float32x2_t *a2, float *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  float v5 = *a3;
  float v6 = a3[1];
  float v8 = *a1;
  float v7 = a1[1];
  float v9 = a3[2];
  float v10 = a1[2];
  float v11 = (float)((float)(*a1 * *a3) + (float)(v7 * v6)) + (float)(v10 * v9);
  if (v11 > 1.0) {
    float v11 = 1.0;
  }
  if (v11 < -1.0) {
    float v11 = -1.0;
  }
  if (fabsf(v11 + -1.0) <= 0.00001)
  {
    float32x2_t v22 = *a2;
    a1[2] = a2[1].f32[0];
    *(float32x2_t *)a1 = v22;
    return;
  }
  float v13 = acosf(v11);
  float v14 = -(float)((float)(v7 * v9) - (float)(v10 * v6));
  float v15 = -(float)((float)(v10 * v5) - (float)(v9 * v8));
  float v16 = -(float)((float)(v6 * v8) - (float)(v7 * v5));
  if (fabsf((float)((float)(v16 * v16) + (float)(v14 * v14)) + (float)(v15 * v15)) <= 0.00001)
  {
    if (fabsf(v13) <= 1.5708) {
      return;
    }
    float v21 = -a2[1].f32[0];
    *(float32x2_t *)a1 = vneg_f32(*a2);
  }
  else
  {
    float64x2_t v29 = 0u;
    *(_OWORD *)float64x2_t v30 = 0u;
    float64x2_t v27 = 0u;
    long long v28 = 0u;
    float64x2_t v25 = 0u;
    int64x2_t v26 = 0u;
    float64x2_t v23 = 0u;
    int64x2_t v24 = 0u;
    CA::Mat4Impl::mat4_set_rotation((CA::Mat4Impl *)&v23, v12, v13, v14, v15, v16);
    double v17 = a2[1].f32[0];
    float64x2_t v18 = vcvtq_f64_f32(*a2);
    int64x2_t v19 = v24;
    int64x2_t v20 = v26;
    *(float32x2_t *)a1 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmlaq_n_f64(v29, v23, v18.f64[0]), v25, v18, 1), v27, v17));
    float v21 = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(v19, v20), v18)) + *(double *)&v28 * v17 + v30[0];
  }
  a1[2] = v21;
}

void CA::Render::EmitterState::free_cell_state(CA::Render::EmitterState *this, Cell *a2)
{
  Cell v3 = a2[5];
  if (v3)
  {
    uint64_t v5 = *(void *)&a2[2].v;
    uint64_t v6 = a2[4];
    *((_DWORD *)this + 21) -= *(_DWORD *)&v3;
    if (v6)
    {
      do
      {
        if (*(float *)(v5 + 24) != 0.0)
        {
          --v6;
          if (*(_DWORD *)(v5 + 8)) {
            CA::Render::EmitterState::free_cells_state(this, v5);
          }
        }
        v5 += 128;
      }
      while (v6);
      uint64_t v5 = *(void *)&a2[2].v;
    }
    free((void *)v5);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, a2);
}

CA::Render::EmitterBehaviors::DistanceFunction *CA::Render::EmitterBehaviors::DistanceFunction::DistanceFunction(CA::Render::EmitterBehaviors::DistanceFunction *this, const CA::Render::KeyValueArray *a2)
{
  _OWORD v26[2] = *MEMORY[0x1E4F143B8];
  *(_DWORD *)this = 0;
  v26[0] = 0;
  v26[1] = 0;
  vec2_keCGFloat y = CA::Render::KeyValueArray::get_vec2_key((uint64_t)a2, 438, (uint64_t)v26);
  *(float *)&double v5 = v5;
  *((float *)this + 1) = vec2_key;
  *((_DWORD *)this + 2) = LODWORD(v5);
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  float_keCGFloat y = CA::Render::KeyValueArray::get_float_key(a2, 454, 0.0);
  *((float *)this + 8) = float_key;
  *((float *)this + 9) = float_key * float_key;
  float v7 = CA::Render::KeyValueArray::get_float_key(a2, 538, 1.0);
  *((float *)this + 10) = v7;
  *((float *)this + 11) = float_key * v7;
  float v8 = CA::Render::KeyValueArray::get_float_key(a2, 615, 0.0);
  *((float *)this + 3) = v8;
  if (a2)
  {
    uint64_t v9 = *((unsigned int *)a2 + 4);
    if (v9)
    {
      uint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *((void *)a2 + v10 + 3);
        if (*(_DWORD *)(v11 + 16) == 46) {
          break;
        }
        if (v9 == ++v10) {
          goto LABEL_21;
        }
      }
      if ((v10 & 0x80000000) == 0)
      {
        uint64_t v12 = *(void *)(v11 + 24);
        if (v12)
        {
          if (*(unsigned char *)(v12 + 12) == 49)
          {
            int v13 = CAInternAtomWithCString((const char *)(v12 + 28));
            if (v13 == 51)
            {
              int v14 = 1;
            }
            else
            {
              if (v13 != 425)
              {
                int v14 = *(_DWORD *)this;
                if ((*(_DWORD *)this - 1) >= 2) {
                  goto LABEL_21;
                }
                goto LABEL_15;
              }
              int v14 = 2;
            }
            *(_DWORD *)this = v14;
LABEL_15:
            float v15 = CA::Render::KeyValueArray::get_float_key(a2, 413, 1.57079633);
            if (fabsf(v15) >= 0.00001)
            {
              float v19 = CA::Render::KeyValueArray::get_float_key(a2, 414, -1.57079633);
              __float2 v20 = __sincosf_stret(v19);
              __float2 v21 = __sincosf_stret(v15);
              float cosval = v21.__cosval;
              float v17 = v21.__sinval * v20.__cosval;
              float v18 = v21.__sinval * v20.__sinval;
            }
            else
            {
              float cosval = 1.0;
              float v17 = 0.0;
              float v18 = 0.0;
            }
            *((float *)this + 4) = v17;
            *((float *)this + 5) = v18;
            *((float *)this + 6) = cosval;
            if (v14 == 2) {
              *((float *)this + 7) = -(float)((float)((float)(*((float *)this + 1) * v17)
            }
                                                    + (float)(*((float *)this + 2) * v18))
                                            + (float)(*((float *)this + 3) * cosval));
          }
        }
      }
    }
  }
LABEL_21:
  float v22 = CA::Render::KeyValueArray::get_float_key(a2, 221, 0.0);
  *((float *)this + 12) = v22;
  float v23 = CA::Render::KeyValueArray::get_float_key(a2, 220, INFINITY);
  float v24 = 0.0;
  if (v23 != 0.0 && (LODWORD(v23) & 0x7FFFFFFFu) <= 0x7F7FFFFF) {
    float v24 = 1.0 / v23;
  }
  *((float *)this + 13) = v24;
  *((float *)this + 14) = v22 * v22;
  *((float *)this + 15) = v24 * v24;
  return this;
}

uint64_t CA::Render::EmitterBehaviors::NoOp::prepare(CA::Render::EmitterBehaviors::NoOp *this)
{
  return 0;
}

void CA::Render::EmitterBehaviors::NoOp::~NoOp(CA::Render::EmitterBehaviors::NoOp *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

float32_t CA::Render::EmitterBehaviors::Wave::operator()(uint64_t a1, uint64_t a2, float32x2_t *a3)
{
  float v3 = *(float *)(a1 + 20);
  float v4 = *(float *)(a1 + 24) * *(float *)(a2 + 60);
  float v5 = v4 - floorf(v4);
  if (v5 > 0.5) {
    float v5 = 1.0 - v5;
  }
  float v6 = (float)((float)((float)(v5 + v5) * (float)(v5 + v5)) * (float)((float)(v5 * -8.0) + 6.0)) + -1.0;
  *a3 = vmla_n_f32(*a3, *(float32x2_t *)(a1 + 12), v6);
  float32_t result = a3[1].f32[0] + (float)(v6 * v3);
  a3[1].f32[0] = result;
  return result;
}

uint64_t CA::Render::EmitterBehavior::Eval::prepare(CA::Render::EmitterBehavior::Eval *this)
{
  return 1;
}

void CA::Render::EmitterBehaviors::Wave::~Wave(CA::Render::EmitterBehaviors::Wave *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

CA::Render::EmitterBehaviors::ValueMutator *CA::Render::EmitterBehaviors::ValueMutator::ValueMutator(CA::Render::EmitterBehaviors::ValueMutator *this, const CA::Render::KeyValueArray *a2)
{
  *(_DWORD *)this = -1;
  *((_WORD *)this + 2) = 0;
  *((unsigned char *)this + 6) = 0;
  if (!a2) {
    return this;
  }
  uint64_t v3 = *((unsigned int *)a2 + 4);
  if (!v3) {
    return this;
  }
  uint64_t v4 = 0;
  while (1)
  {
    uint64_t v5 = *((void *)a2 + v4 + 3);
    if (*(_DWORD *)(v5 + 16) == 339) {
      break;
    }
    if (v3 == ++v4) {
      return this;
    }
  }
  if ((v4 & 0x80000000) != 0) {
    return this;
  }
  uint64_t v6 = *(void *)(v5 + 24);
  if (!v6 || *(unsigned char *)(v6 + 12) != 49) {
    return this;
  }
  int_keCGFloat y = CA::Render::KeyValueArray::get_int_key(a2, 3, 0);
  BOOL v8 = int_key != 0;
  uint64_t v9 = (const char *)(v6 + 28);
  if (!strcmp(v9, "position.x"))
  {
    int v12 = 8;
LABEL_33:
    *(_DWORD *)this = v12;
    return this;
  }
  if (!strcmp(v9, "position.y"))
  {
    int v12 = 9;
    goto LABEL_33;
  }
  if (!strcmp(v9, "position.z"))
  {
    int v12 = 10;
    goto LABEL_33;
  }
  if (!strcmp(v9, "velocity.x"))
  {
    int v12 = 12;
    goto LABEL_33;
  }
  if (!strcmp(v9, "velocity.y"))
  {
    int v12 = 13;
    goto LABEL_33;
  }
  if (!strcmp(v9, "velocity.z"))
  {
    int v12 = 14;
    goto LABEL_33;
  }
  if (!strcmp(v9, "mass"))
  {
    *(_DWORD *)this = 7;
    *((unsigned char *)this + 4) = 1;
    return this;
  }
  if (!strcmp(v9, "rotation"))
  {
    int v14 = 22;
LABEL_40:
    *(_DWORD *)this = v14;
LABEL_41:
    *((unsigned char *)this + 6) = v8;
    return this;
  }
  if (!strcmp(v9, "spin"))
  {
    int v14 = 23;
    goto LABEL_40;
  }
  if (!strcmp(v9, "scale"))
  {
    int v15 = 21;
LABEL_43:
    *(_DWORD *)this = v15;
    *((unsigned char *)this + 5) = v8;
    return this;
  }
  if (!strcmp(v9, "scaleSpeed"))
  {
    int v14 = 31;
    goto LABEL_40;
  }
  if (!strcmp(v9, "birthRate"))
  {
    int v15 = 11;
    goto LABEL_43;
  }
  if (!strcmp(v9, "color.red"))
  {
    BOOL v10 = int_key == 0;
    int v11 = 16;
    goto LABEL_47;
  }
  if (!strcmp(v9, "color.green"))
  {
    BOOL v10 = int_key == 0;
    int v11 = 17;
    goto LABEL_47;
  }
  if (!strcmp(v9, "color.blue"))
  {
    BOOL v10 = int_key == 0;
    int v11 = 18;
    goto LABEL_47;
  }
  if (!strcmp(v9, "color.alpha"))
  {
    BOOL v10 = int_key == 0;
    int v11 = 19;
LABEL_47:
    *(_DWORD *)this = v11;
    char v16 = v10;
    *((unsigned char *)this + 5) = v16;
    goto LABEL_41;
  }
  return this;
}

uint64_t CA::Render::EmitterBehaviors::ValueOver<CA::Render::EmitterBehaviors::LifeFunction>::operator()(uint64_t a1, uint64_t a2)
{
  v8[1] = *(double *)MEMORY[0x1E4F143B8];
  v8[0] = (float)(*(float *)(a2 + 60) / *(float *)(a2 + 24));
  double v7 = 0.0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t, double *, void, double *, void, void, void))(**(void **)(a1 + 16) + 128))(*(void *)(a1 + 16), 1, v8, 0, &v7, 0, 0, 0);
  if (result)
  {
    float v5 = v7;
    if (*(unsigned char *)(a1 + 28)) {
      float v5 = 1.0 / v5;
    }
    uint64_t v6 = *(int *)(a1 + 24);
    if (*(unsigned char *)(a1 + 29)) {
      float v5 = *(float *)(a2 + 4 * v6) * v5;
    }
    if (*(unsigned char *)(a1 + 30)) {
      float v5 = *(float *)(a2 + 4 * v6) + v5;
    }
    *(float *)(a2 + 4 * v6) = v5;
  }
  return result;
}

BOOL CA::Render::EmitterBehaviors::ValueOver<CA::Render::EmitterBehaviors::LifeFunction>::prepare(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void CA::Render::EmitterBehaviors::ValueOver<CA::Render::EmitterBehaviors::LifeFunction>::~ValueOver(void *a1)
{
  *a1 = &unk_1ED02E5C8;
  uint64_t v2 = (atomic_uint *)a1[2];
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, a1);
}

void *CA::Render::EmitterBehaviors::ValueOver<CA::Render::EmitterBehaviors::LifeFunction>::~ValueOver(void *a1)
{
  *a1 = &unk_1ED02E5C8;
  uint64_t v2 = (atomic_uint *)a1[2];
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  return a1;
}

uint64_t CA::Render::EmitterBehaviors::ValueOver<CA::Render::EmitterBehaviors::DistanceFunction>::operator()(uint64_t a1, float *a2, double a3)
{
  v9[1] = *(double *)MEMORY[0x1E4F143B8];
  v9[0] = CA::Render::EmitterBehaviors::DistanceFunction::operator()(a1 + 12, a2, a3);
  double v8 = 0.0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t, double *, void, double *, void, void, void))(**(void **)(a1 + 80) + 128))(*(void *)(a1 + 80), 1, v9, 0, &v8, 0, 0, 0);
  if (result)
  {
    float v6 = v8;
    if (*(unsigned char *)(a1 + 92)) {
      float v6 = 1.0 / v6;
    }
    uint64_t v7 = *(int *)(a1 + 88);
    if (*(unsigned char *)(a1 + 93)) {
      float v6 = a2[v7] * v6;
    }
    if (*(unsigned char *)(a1 + 94)) {
      float v6 = a2[v7] + v6;
    }
    a2[v7] = v6;
  }
  return result;
}

float CA::Render::EmitterBehaviors::DistanceFunction::operator()(uint64_t a1, float *a2, double a3)
{
  *(float *)&a3 = a2[8] - *(float *)(a1 + 4);
  float v3 = a2[9] - *(float *)(a1 + 8);
  float v4 = a2[10] - *(float *)(a1 + 12);
  if (*(_DWORD *)a1 == 2)
  {
    *(float *)&a3 = fabsf((float)((float)(*(float *)(a1 + 28) + (float)(*(float *)(a1 + 16) * *(float *)&a3))+ (float)(*(float *)(a1 + 20) * v3))+ (float)(*(float *)(a1 + 24) * v4));
  }
  else
  {
    if (*(_DWORD *)a1 == 1)
    {
      float v5 = *(float *)(a1 + 16);
      float v6 = *(float *)(a1 + 20);
      float v7 = *(float *)(a1 + 24);
      float v8 = (float)((float)(v5 * *(float *)&a3) + (float)(v6 * v3)) + (float)(v7 * v4);
      *(float *)&a3 = *(float *)&a3 - (float)(v8 * v5);
      float v3 = v3 - (float)(v8 * v6);
      float v4 = v4 - (float)(v8 * v7);
    }
    *(float *)&a3 = fmaxf((float)((float)(v4 * v4) + (float)(v3 * v3)) + (float)(*(float *)&a3 * *(float *)&a3), 0.0001);
    LODWORD(a3) = vrecpe_f32((float32x2_t)vdup_lane_s32((int32x2_t)vrsqrte_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0)), 0)).u32[0];
  }
  return (float)(*(float *)&a3 - (float)(*(float *)(a1 + 32) + *(float *)(a1 + 48))) * *(float *)(a1 + 52);
}

BOOL CA::Render::EmitterBehaviors::ValueOver<CA::Render::EmitterBehaviors::DistanceFunction>::prepare(uint64_t a1)
{
  return *(void *)(a1 + 80) != 0;
}

void CA::Render::EmitterBehaviors::ValueOver<CA::Render::EmitterBehaviors::DistanceFunction>::~ValueOver(void *a1)
{
  *a1 = &unk_1ED02E5F8;
  uint64_t v2 = (atomic_uint *)a1[10];
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, a1);
}

void *CA::Render::EmitterBehaviors::ValueOver<CA::Render::EmitterBehaviors::DistanceFunction>::~ValueOver(void *a1)
{
  *a1 = &unk_1ED02E5F8;
  uint64_t v2 = (atomic_uint *)a1[10];
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  return a1;
}

float CA::Render::EmitterBehaviors::Light::operator()(uint64_t a1, float *a2, double a3, double a4, double a5, double a6, double a7, double a8, uint64_t a9, float32x4_t *a10)
{
  float v10 = a2[8] - *(float *)(a1 + 36);
  float v11 = a2[9] - *(float *)(a1 + 40);
  float v12 = a2[10] - *(float *)(a1 + 44);
  *(float *)&a8 = (float)((float)(v10 * v10) + (float)(v11 * v11)) + (float)(v12 * v12);
  float v13 = (float)(*(float *)&a8 - *(float *)(a1 + 48)) * *(float *)(a1 + 52);
  if (v13 > 1.0) {
    float v13 = 1.0;
  }
  if (v13 >= 0.0) {
    float v14 = 1.0 - v13;
  }
  else {
    float v14 = 1.0;
  }
  if (*(unsigned char *)(a1 + 56))
  {
    *(float *)&a8 = fmaxf(*(float *)&a8, 0.0001);
    float v15 = vmlas_n_f32(-*(float *)(a1 + 72), (float)((float)(*(float *)(a1 + 60) * v10) + (float)(*(float *)(a1 + 64) * v11))+ (float)(*(float *)(a1 + 68) * v12), vrsqrte_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a8, 0)).f32[0])* *(float *)(a1 + 76);
    if (v15 > 1.0) {
      float v15 = 1.0;
    }
    if (v15 < 0.0) {
      float v15 = 0.0;
    }
    float v14 = v15 * v14;
  }
  float result = *(float *)(a1 + 28) + (float)(*(float *)(a1 + 32) * v14);
  *a10 = vmlaq_n_f32(*a10, *(float32x4_t *)(a1 + 12), result);
  return result;
}

void CA::Render::EmitterBehaviors::Light::~Light(CA::Render::EmitterBehaviors::Light *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

float CA::Render::EmitterBehaviors::Drag::operator()(uint64_t a1, float32x2_t *a2, float32x2_t *a3, double a4)
{
  LODWORD(a4) = *(_DWORD *)(a1 + 12);
  float v4 = a2[7].f32[0];
  *a3 = vmls_lane_f32(*a3, a2[6], *(float32x2_t *)&a4, 0);
  *(float *)&a4 = a3[1].f32[0] - (float)(v4 * *(float *)&a4);
  a3[1].i32[0] = LODWORD(a4);
  return *(float *)&a4;
}

void CA::Render::EmitterBehaviors::Drag::~Drag(CA::Render::EmitterBehaviors::Drag *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

float32x4_t CA::Render::EmitterBehaviors::ColorOver<CA::Render::EmitterBehaviors::LifeFunction>::operator()(uint64_t a1, float32x4_t *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  double v4 = (float)(a2[3].f32[3] / a2[1].f32[2]);
  float64x2_t v5 = 0u;
  float64x2_t v6 = 0u;
  if ((*(unsigned int (**)(void, uint64_t, double *, void, float64x2_t *, void, void, void))(**(void **)(a1 + 16) + 128))(*(void *)(a1 + 16), 1, &v4, 0, &v5, 0, 0, 0))
  {
    float32x4_t result = vmulq_f32(a2[4], vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v5), v6));
    a2[4] = result;
  }
  return result;
}

BOOL CA::Render::EmitterBehaviors::ColorOver<CA::Render::EmitterBehaviors::LifeFunction>::prepare(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void CA::Render::EmitterBehaviors::ColorOver<CA::Render::EmitterBehaviors::LifeFunction>::~ColorOver(void *a1)
{
  *a1 = &unk_1ED02E568;
  uint64_t v2 = (atomic_uint *)a1[2];
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, a1);
}

void *CA::Render::EmitterBehaviors::ColorOver<CA::Render::EmitterBehaviors::LifeFunction>::~ColorOver(void *a1)
{
  *a1 = &unk_1ED02E568;
  uint64_t v2 = (atomic_uint *)a1[2];
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  return a1;
}

float32x4_t CA::Render::EmitterBehaviors::ColorOver<CA::Render::EmitterBehaviors::DistanceFunction>::operator()(uint64_t a1, float32x4_t *a2, double a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  double v6 = CA::Render::EmitterBehaviors::DistanceFunction::operator()(a1 + 12, a2->f32, a3);
  float64x2_t v7 = 0u;
  float64x2_t v8 = 0u;
  if ((*(unsigned int (**)(void, uint64_t, double *, void, float64x2_t *, void, void, void))(**(void **)(a1 + 80) + 128))(*(void *)(a1 + 80), 1, &v6, 0, &v7, 0, 0, 0))
  {
    float32x4_t result = vmulq_f32(a2[4], vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v7), v8));
    a2[4] = result;
  }
  return result;
}

BOOL CA::Render::EmitterBehaviors::ColorOver<CA::Render::EmitterBehaviors::DistanceFunction>::prepare(uint64_t a1)
{
  return *(void *)(a1 + 80) != 0;
}

void CA::Render::EmitterBehaviors::ColorOver<CA::Render::EmitterBehaviors::DistanceFunction>::~ColorOver(void *a1)
{
  *a1 = &unk_1ED02E598;
  uint64_t v2 = (atomic_uint *)a1[10];
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, a1);
}

void *CA::Render::EmitterBehaviors::ColorOver<CA::Render::EmitterBehaviors::DistanceFunction>::~ColorOver(void *a1)
{
  *a1 = &unk_1ED02E598;
  uint64_t v2 = (atomic_uint *)a1[10];
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  return a1;
}

void CA::Render::EmitterBehaviors::AlignToMotion::operator()(uint64_t a1, float *a2)
{
  float v3 = a2[12];
  float v4 = a2[13];
  if (!*(unsigned char *)(a1 + 16))
  {
    float v20 = *(float *)(a1 + 12) + atan2f(v3, -v4);
    float v6 = 1.0;
    float v15 = 0.0;
LABEL_12:
    float v22 = 0.0;
    goto LABEL_13;
  }
  float v5 = a2[14];
  float v6 = 1.0;
  float v7 = 1.0 / sqrtf((float)((float)(v3 * v3) + (float)(v4 * v4)) + (float)(v5 * v5));
  float v8 = v7 * v3;
  float v9 = v7 * v4;
  float v10 = v7 * v5;
  float v11 = *(float *)(a1 + 20);
  float v12 = *(float *)(a1 + 24);
  float v13 = *(float *)(a1 + 28);
  float v14 = (float)((float)(v8 * v11) + (float)(v9 * v12)) + (float)(v10 * v13);
  if (v14 > 1.0) {
    float v14 = 1.0;
  }
  if (v14 < -1.0) {
    float v14 = -1.0;
  }
  float v15 = 0.0;
  if (fabsf(v14 + -1.0) <= 0.00001)
  {
    float v20 = 0.0;
    goto LABEL_12;
  }
  float v16 = -(float)((float)(v9 * v13) - (float)(v10 * v12));
  float v17 = -(float)((float)(v10 * v11) - (float)(v8 * v13));
  float v18 = -(float)((float)(v8 * v12) - (float)(v9 * v11));
  float v19 = (float)((float)(v16 * v16) + (float)(v17 * v17)) + (float)(v18 * v18);
  if (fabsf(v19) <= 0.00001)
  {
    float v20 = 3.1416;
    goto LABEL_12;
  }
  float v20 = acosf(v14);
  float v21 = 1.0 / sqrtf(v19);
  float v15 = v21 * v16;
  float v22 = v21 * v17;
  float v6 = v21 * v18;
LABEL_13:
  a2[22] = v20;
  a2[28] = v15;
  a2[29] = v22;
  a2[30] = v6;
}

void CA::Render::EmitterBehaviors::AlignToMotion::~AlignToMotion(CA::Render::EmitterBehaviors::AlignToMotion *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

float32_t CA::Render::EmitterBehaviors::SimpleAttractor::operator()(uint64_t a1, float32x2_t *a2, float32x2_t *a3, double a4, double a5, double a6)
{
  float32x2_t v6 = vsub_f32(a2[4], *(float32x2_t *)(a1 + 12));
  float v7 = vaddv_f32(vmul_f32(v6, v6));
  if (v7 < *(float *)(a1 + 28))
  {
    *(float *)&a6 = fmaxf(v7, 0.0001);
    *a3 = vmla_n_f32(*a3, v6, -(float)((float)((float)(*(float *)(a1 + 32) * v7) + -1.0)* vmlas_n_f32(-*(float *)(a1 + 20), *(float *)(a1 + 24), vrsqrte_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a6, 0)).f32[0])));
  }
  return v6.f32[0];
}

void CA::Render::EmitterBehaviors::SimpleAttractor::~SimpleAttractor(CA::Render::EmitterBehaviors::SimpleAttractor *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

float32_t CA::Render::EmitterBehaviors::Attractor::operator()(uint64_t a1, float32x2_t *a2, float32x2_t *a3, double a4, double a5, double a6, double a7)
{
  float32x2_t v7 = a2[4];
  float32x2_t v8 = vsub_f32(v7, *(float32x2_t *)(a1 + 16));
  LODWORD(a7) = a2[5].i32[0];
  float v9 = *(float *)&a7 - *(float *)(a1 + 24);
  int v10 = *(_DWORD *)(a1 + 12);
  if (v10 == 2)
  {
    float v16 = *(float *)(a1 + 36);
    float32x2_t v17 = *(float32x2_t *)(a1 + 28);
    float v18 = (float)(vaddv_f32(vmul_f32(v17, v8)) + (float)(v16 * v9)) + *(float *)(a1 + 40);
    float v9 = *(float *)&a7 + (float)(v18 * v16);
    *(float *)&a7 = fabsf(v18);
    float v15 = v18 * v18;
    LODWORD(a7) = vrecpe_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a7, 0)).u32[0];
    float32x2_t v8 = vmla_n_f32(v7, v17, v18);
  }
  else
  {
    if (v10 == 1)
    {
      float v11 = *(float *)(a1 + 36);
      float32x2_t v12 = *(float32x2_t *)(a1 + 28);
      float32x2_t v13 = vmul_f32(v12, v8);
      v13.f32[0] = vaddv_f32(v13) + (float)(v11 * v9);
      float32x2_t v8 = vmls_lane_f32(v8, v12, v13, 0);
      float v9 = v9 - (float)(v13.f32[0] * v11);
    }
    int32x2_t v14 = (int32x2_t)vmul_f32(v8, v8);
    float v15 = (float)(*(float *)&v14.i32[1] + (float)(v9 * v9)) + *(float *)v14.i32;
    *(float *)v14.i32 = fmaxf(v15, 0.0001);
    LODWORD(a7) = vrsqrte_f32((float32x2_t)vdup_lane_s32(v14, 0)).u32[0];
  }
  float v19 = (float)(v15 - *(float *)(a1 + 68)) * *(float *)(a1 + 72);
  if (v19 > 1.0) {
    float v19 = 1.0;
  }
  if (v19 >= 0.0) {
    float v20 = 1.0 - v19;
  }
  else {
    float v20 = 1.0;
  }
  float v21 = v20 * vmlas_n_f32(-*(float *)(a1 + 52), *(float *)(a1 + 56), *(float *)&a7);
  *a3 = vmla_n_f32(*a3, v8, v21);
  float32_t result = a3[1].f32[0] + (float)(v21 * v9);
  a3[1].f32[0] = result;
  return result;
}

void CA::Render::EmitterBehaviors::Attractor::~Attractor(CA::Render::EmitterBehaviors::Attractor *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

float32x2_t CA::Render::EmitterLayer::set_property(CA::Render::EmitterLayer *this, unint64_t a2, unsigned int *a3, const unsigned int *a4, CA::Render::Vector *a5, double *a6, const double *a7, float32x2_t result)
{
  float v11 = a3;
  unint64_t i = a2;
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = *a3;
  unint64_t v15 = a2 - 2;
  if (a2 >= 2 && v14 == 201)
  {
    uint64_t cell = CA::Render::emitter_find_cell(*((void *)this + 4), a3[1]);
    if (cell)
    {
      uint64_t v17 = cell;
      v11 += 2;
      for (unint64_t i = v15; i; i -= 2)
      {
        uint64_t v14 = *v11;
        unsigned int v18 = CA::Render::cell_atom_param_index(v14);
        if (a5 && (v18 & 0x80000000) == 0)
        {
          if (a4)
          {
            uint64_t v24 = v18;
            *(double *)&float32_t result = *a6 + *(float *)(v17 + 4 * v18 + 72);
          }
          else
          {
            float32_t result = *(float32x2_t *)a6;
            uint64_t v24 = v18;
          }
          result.f32[0] = *(double *)&result;
          *(_DWORD *)(v17 + 4 * v24 + 72) = result.i32[0];
          return result;
        }
        if (i < 2 || v14 != 201)
        {
          if (v14 == 92) {
            unsigned int v25 = 23;
          }
          else {
            unsigned int v25 = v18;
          }
          if ((unint64_t)a5 >= 4 && (v25 & 0x80000000) == 0)
          {
            double v26 = a6[3];
            float v27 = v26 * *a6;
            *(float *)(v17 + 72 + 4 * v25) = v27;
            float v28 = a6[1] * v26;
            *(float *)(v17 + 72 + 4 * (v25 + 1)) = v28;
            *(double *)&float32_t result = a6[2] * v26;
            result.f32[0] = *(double *)&result;
            *(_DWORD *)(v17 + 72 + 4 * (v25 + 2)) = result.i32[0];
            result.f32[0] = v26;
            *(_DWORD *)(v17 + 72 + 4 * (v25 + 3)) = result.i32[0];
            return result;
          }
          goto LABEL_30;
        }
        uint64_t v17 = CA::Render::emitter_find_cell(*(void *)(v17 + 40), v11[1]);
        v11 += 2;
        if (!v17) {
          return result;
        }
      }
    }
    return result;
  }
  if (a2 < 2 || v14 != 200)
  {
LABEL_30:
    if (a5 && i == 1)
    {
      v56.f64[0] = 0.0;
      unsigned int v29 = CA::Render::emitter_atom_param_index((CA::Render *)v14, &v56, (unint64_t *)a3);
      if ((v29 & 0x80000000) == 0)
      {
        float64_t v30 = v56.f64[0];
        if (*(void *)&v56.f64[0] <= (unint64_t)a5)
        {
          if (*(void *)&v56.f64[0])
          {
            uint64_t v31 = 0;
            uint64_t v32 = v29;
            do
            {
              if (a4)
              {
                *(double *)&float32_t result = *a6 + *((float *)this + v32 + 19);
                uint64_t v33 = v32;
              }
              else
              {
                float32_t result = *(float32x2_t *)a6;
                uint64_t v33 = v31 + v29;
              }
              result.f32[0] = *(double *)&result;
              *((_DWORD *)this + v33 + 19) = result.i32[0];
              ++v31;
              ++a6;
              ++v32;
              --*(void *)&v30;
            }
            while (v30 != 0.0);
          }
        }
      }
      return result;
    }
    if (i < 2) {
      return result;
    }
    goto LABEL_42;
  }
  uint64_t behavior = CA::Render::emitter_find_behavior(*((void *)this + 5), a3[1]);
  if (!behavior)
  {
    LODWORD(v14) = *v11;
LABEL_42:
    switch(v14)
    {
      case 0x9E:
        float32x2_t v47 = *(float32x2_t *)((char *)this + 128);
        float64x2_t v48 = vcvtq_f64_f32(vsub_f32(*(float32x2_t *)((char *)this + 136), v47));
        float64x2_t v56 = vcvtq_f64_f32(v47);
        float64x2_t v57 = v48;
        CA::Render::set_rect_property(v56.f64, (Rect *)(i - 1), (int *)v11 + 1, a4, (unint64_t)a5, a6, a7);
        float32_t result = vcvt_f32_f64(vaddq_f64(v57, v56));
        *((float32x2_t *)this + 16) = vcvt_f32_f64(v56);
        *((double *)this + 17) = *(double *)&result;
        break;
      case 0xD1:
        float64x2_t v49 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 100));
        if (i == 2)
        {
          unsigned int v50 = v11[1];
          if (a5 && v50 == 604)
          {
            if (a4) {
              double v51 = *a6 + v49.f64[0];
            }
            else {
              double v51 = *a6;
            }
            v49.f64[0] = v51;
          }
          else if (a5 && v50 == 256)
          {
            if (a4) {
              double v55 = *a6 + v49.f64[1];
            }
            else {
              double v55 = *a6;
            }
            v49.f64[1] = v55;
          }
        }
        float32_t result = vcvt_f32_f64(v49);
        *(double *)((char *)this + 100) = *(double *)&result;
        break;
      case 0xCE:
        float64x2_t v34 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 88));
        if (i == 2)
        {
          unsigned int v35 = v11[1];
          if (a5 && v35 == 607)
          {
            if (a4) {
              double v36 = *a6 + v34.f64[0];
            }
            else {
              double v36 = *a6;
            }
            v34.f64[0] = v36;
          }
          else if (a5 && v35 == 611)
          {
            if (a4) {
              double v54 = *a6 + v34.f64[1];
            }
            else {
              double v54 = *a6;
            }
            v34.f64[1] = v54;
          }
        }
        float32_t result = vcvt_f32_f64(v34);
        *((double *)this + 11) = *(double *)&result;
        break;
    }
    return result;
  }
  uint64_t v21 = behavior;
  if (i == 4)
  {
    uint64_t v37 = v11[3];
    if ((v37 & 0x40000000) == 0) {
      return result;
    }
    if (a5 != (CA::Render::Vector *)1) {
      return result;
    }
    uint64_t v38 = *(void *)(behavior + 32);
    if (!v38) {
      return result;
    }
    unsigned int named_object = CA::Render::KeyValueArray::find_named_object_(*(void *)(behavior + 32), v11[2]);
    if ((named_object & 0x80000000) != 0) {
      return result;
    }
    uint64_t v41 = *(void *)(*(void *)(v38 + 8 * named_object + 24) + 24);
    if (!v41) {
      return result;
    }
    if (*(unsigned char *)(v41 + 12) != 56) {
      return result;
    }
    unint64_t v42 = v37 & 0xFFFFFFFFBFFFFFFFLL;
    float v43 = (CA::Render::Vector *)*(unsigned int *)(v41 + 16);
    if (v42 >= v43) {
      return result;
    }
    float v44 = CA::Render::Vector::new_vector(v43, (const void *)(v41 + 24), v40);
    *(double *)&v44[2 * v42 + 6] = *a6;
    CA::Render::KeyValueArray::set_key(*(CA::Render::KeyValueArray **)(v21 + 32), v11[2], v44);
    if (atomic_fetch_add(v44 + 2, 0xFFFFFFFF) != 1) {
      return result;
    }
    __int32 v45 = *(void (**)(atomic_uint *))(*(void *)v44 + 16);
    int v46 = v44;
    goto LABEL_73;
  }
  if (i != 3) {
    return result;
  }
  if (a5 == (CA::Render::Vector *)1 && v11[2] == 212)
  {
    float32_t result = *(float32x2_t *)a6;
    int v22 = *(_DWORD *)(behavior + 12);
    if (*a6 <= 0.5) {
      unsigned int v23 = v22 & 0xFFFFFEFF;
    }
    else {
      unsigned int v23 = v22 | 0x100;
    }
    *(_DWORD *)(behavior + 12) = v23;
    return result;
  }
  if (*(void *)(behavior + 32))
  {
    float v52 = CA::Render::Vector::new_vector(a5, a6, v20);
    CA::Render::KeyValueArray::set_key(*(CA::Render::KeyValueArray **)(v21 + 32), v11[2], v52);
    uint64_t v53 = *(void *)(v21 + 40);
    if (v53)
    {
      (*(void (**)(uint64_t))(*(void *)v53 + 8))(v53);
      *(void *)(v21 + 40) = 0;
    }
    if (v52 && atomic_fetch_add(v52 + 2, 0xFFFFFFFF) == 1)
    {
      __int32 v45 = *(void (**)(atomic_uint *))(*(void *)v52 + 16);
      int v46 = v52;
LABEL_73:
      v45(v46);
    }
  }
  return result;
}

uint64_t CA::Render::emitter_find_cell(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 16);
    if ((a2 & 0x40000000) != 0)
    {
      if ((a2 & 0xBFFFFFFF) < v4)
      {
        uint64_t i = a1 + 8 * (a2 & 0xBFFFFFFF) + 24;
        return *(void *)i;
      }
    }
    else if (v4)
    {
      for (uint64_t i = a1 + 24; ; i += 8)
      {
        float32x2_t v6 = *(CA::Render::String **)(*(void *)i + 16);
        if (v6)
        {
          if (CA::Render::String::equal(v6, a2)) {
            break;
          }
        }
        if (!--v4) {
          return 0;
        }
      }
      return *(void *)i;
    }
    return 0;
  }
  return v2;
}

uint64_t CA::Render::cell_atom_param_index(uint64_t this)
{
  if ((int)this > 389)
  {
    if ((int)this > 527)
    {
      if ((int)this <= 589)
      {
        switch(this)
        {
          case 0x210:
            return 21;
          case 0x212:
            return 22;
          case 0x24D:
            return 6;
        }
      }
      else if ((int)this > 611)
      {
        if (this == 612) {
          return 9;
        }
        if (this == 614) {
          return 10;
        }
      }
      else
      {
        if (this == 590) {
          return 7;
        }
        if (this == 608) {
          return 8;
        }
      }
      return 0xFFFFFFFFLL;
    }
    if ((int)this <= 460)
    {
      if ((int)this > 413)
      {
        if (this == 414) {
          return 17;
        }
        if (this == 415) {
          return 18;
        }
      }
      else
      {
        if (this == 390) {
          return 35;
        }
        if (this == 413) {
          return 16;
        }
      }
      return 0xFFFFFFFFLL;
    }
    switch((int)this)
    {
      case 481:
        return 19;
      case 482:
      case 484:
      case 485:
        return 0xFFFFFFFFLL;
      case 483:
        return 20;
      case 486:
        return 13;
      case 487:
        return 14;
      case 488:
        return 15;
      default:
        if (this == 461)
        {
          this = 27;
        }
        else
        {
          if (this != 462) {
            return 0xFFFFFFFFLL;
          }
          this = 31;
        }
        break;
    }
  }
  else if ((int)this > 196)
  {
    if ((int)this > 250)
    {
      if ((int)this <= 347)
      {
        if (this == 251) {
          return 32;
        }
        if (this == 347) {
          return 1;
        }
      }
      else
      {
        switch(this)
        {
          case 0x15C:
            return 2;
          case 0x17B:
            return 11;
          case 0x17C:
            return 12;
        }
      }
      return 0xFFFFFFFFLL;
    }
    if ((int)this > 198)
    {
      if (this == 199) {
        return 5;
      }
      if (this == 250) {
        return 28;
      }
      return 0xFFFFFFFFLL;
    }
    if (this == 197) {
      return 3;
    }
    else {
      return 4;
    }
  }
  else if ((int)this <= 38)
  {
    if ((int)this <= 36)
    {
      if (this == 22) {
        return 30;
      }
      if (this == 24) {
        return 34;
      }
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if ((int)this > 63)
    {
      switch(this)
      {
        case 0x40:
          return 29;
        case 0x41:
          return 33;
        case 0x88:
          return 36;
      }
      return 0xFFFFFFFFLL;
    }
    if (this != 39)
    {
      if (this == 61) {
        return 0;
      }
      return 0xFFFFFFFFLL;
    }
  }
  return this;
}

uint64_t CA::Render::emitter_find_behavior(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 16);
    if ((a2 & 0x40000000) != 0)
    {
      if ((a2 & 0xBFFFFFFF) < v4)
      {
        uint64_t i = a1 + 8 * (a2 & 0xBFFFFFFF) + 24;
        return *(void *)i;
      }
    }
    else if (v4)
    {
      for (uint64_t i = a1 + 24; ; i += 8)
      {
        float32x2_t v6 = *(CA::Render::String **)(*(void *)i + 24);
        if (v6)
        {
          if (CA::Render::String::equal(v6, a2)) {
            break;
          }
        }
        if (!--v4) {
          return 0;
        }
      }
      return *(void *)i;
    }
    return 0;
  }
  return v2;
}

uint64_t CA::Render::emitter_atom_param_index(CA::Render *this, void *a2, unint64_t *a3)
{
  *a2 = 1;
  if ((int)this > 346)
  {
    if ((int)this <= 527)
    {
      if (this == 347) {
        return 1;
      }
      if (this == 486) {
        return 10;
      }
    }
    else
    {
      switch(this)
      {
        case 0x210:
          return 11;
        case 0x211:
          return 12;
        case 0x24D:
          return 9;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((int)this <= 157)
  {
    switch(this)
    {
      case 0x3D:
        return 0;
      case 0x9C:
        return 18;
      case 0x9D:
        return 17;
    }
    return 0xFFFFFFFFLL;
  }
  switch((int)this)
  {
    case 202:
      uint64_t result = 8;
      break;
    case 203:
      uint64_t result = 2;
      break;
    case 204:
    case 205:
    case 207:
    case 208:
      return 0xFFFFFFFFLL;
    case 206:
      *a2 = 2;
      uint64_t result = 3;
      break;
    case 209:
      *a2 = 2;
      uint64_t result = 6;
      break;
    case 210:
      uint64_t result = 5;
      break;
    default:
      if (this != 158) {
        return 0xFFFFFFFFLL;
      }
      *a2 = 4;
      uint64_t result = 13;
      break;
  }
  return result;
}

uint64_t CA::Render::EmitterLayer::get_property(CA::Render::EmitterLayer *this, unint64_t a2, unsigned int *a3, unint64_t a4, double *a5, double **a6)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (a4 < 4) {
    return 0;
  }
  float32x2_t v8 = a5;
  int v10 = a3;
  unint64_t v6 = a2;
  if (a6) {
    *a6 = a5;
  }
  unsigned int v12 = *a3;
  if (a2 < 2 || v12 != 201)
  {
    if (a2 >= 2 && v12 == 200)
    {
      uint64_t behavior = CA::Render::emitter_find_behavior(*((void *)this + 5), a3[1]);
      if (behavior)
      {
        if (v6 == 4)
        {
          uint64_t v28 = v10[3];
          if ((v28 & 0x40000000) == 0) {
            return 0;
          }
          unint64_t v6 = *(void *)(behavior + 32);
          if (!v6) {
            return v6;
          }
          unsigned int named_object = CA::Render::KeyValueArray::find_named_object_(*(void *)(behavior + 32), v10[2]);
          if ((named_object & 0x80000000) != 0) {
            return 0;
          }
          uint64_t v30 = *(void *)(*(void *)(v6 + 8 * named_object + 24) + 24);
          if (!v30 || *(unsigned char *)(v30 + 12) != 56 || (v28 & 0xBFFFFFFF) >= *(_DWORD *)(v30 + 16)) {
            return 0;
          }
          double v19 = *(double *)(v30 + 8 * (v28 & 0xFFFFFFFFBFFFFFFFLL) + 24);
        }
        else
        {
          if (v6 != 3) {
            return 0;
          }
          int v18 = v10[2];
          if (v18 != 212)
          {
            unint64_t v6 = *(void *)(behavior + 32);
            if (!v6) {
              return v6;
            }
            unsigned int v34 = CA::Render::KeyValueArray::find_named_object_(*(void *)(behavior + 32), v18);
            if ((v34 & 0x80000000) == 0)
            {
              unint64_t v6 = *(void *)(*(void *)(v6 + 8 * v34 + 24) + 24);
              if (!v6) {
                return v6;
              }
              if (*(unsigned char *)(v6 + 12) == 56)
              {
                unint64_t v35 = *(unsigned int *)(v6 + 16);
                if (v35 <= a4)
                {
                  memcpy(v8, (const void *)(v6 + 24), 8 * v35);
                  return *(unsigned int *)(v6 + 16);
                }
              }
            }
            return 0;
          }
          double v19 = 1.0;
          if ((*(_DWORD *)(behavior + 12) & 0x100) == 0) {
            double v19 = 0.0;
          }
        }
LABEL_26:
        *float32x2_t v8 = v19;
        return 1;
      }
    }
LABEL_30:
    if (!v6) {
      return v6;
    }
    if (v6 == 1)
    {
      *(void *)&v36[0] = 0;
      unsigned int v21 = CA::Render::emitter_atom_param_index((CA::Render *)*v10, v36, (unint64_t *)a3);
      if ((v21 & 0x80000000) == 0)
      {
        unint64_t v22 = *(void *)&v36[0];
        if (*(void *)&v36[0] >= a4) {
          unint64_t v22 = a4;
        }
        if (v22)
        {
          unsigned int v23 = (float *)((char *)this + 4 * v21 + 76);
          do
          {
            float v24 = *v23++;
            *v8++ = v24;
            --v22;
          }
          while (v22);
        }
      }
      return 0;
    }
    unsigned int v25 = *v10;
    if (*v10 == 158)
    {
      float32x2_t v31 = *(float32x2_t *)((char *)this + 128);
      float64x2_t v32 = vcvtq_f64_f32(vsub_f32(*(float32x2_t *)((char *)this + 136), v31));
      v36[0] = vcvtq_f64_f32(v31);
      v36[1] = v32;
      return CA::Render::get_rect_property((CA::Render *)v36, (const CA::Rect *)(v6 - 1), (int *)v10 + 1, (unsigned int *)v8, a5);
    }
    if (v25 == 209)
    {
      if (v6 != 2) {
        return 0;
      }
      float64x2_t v26 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 100));
      unsigned int v33 = v10[1];
      if (v33 == 604) {
        goto LABEL_58;
      }
      if (v33 != 256) {
        return 0;
      }
    }
    else
    {
      if (v25 != 206 || v6 != 2) {
        return 0;
      }
      float64x2_t v26 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 88));
      unsigned int v27 = v10[1];
      if (v27 == 607) {
        goto LABEL_58;
      }
      if (v27 != 611) {
        return 0;
      }
    }
    v26.f64[0] = v26.f64[1];
LABEL_58:
    *float32x2_t v8 = v26.f64[0];
    return 1;
  }
  uint64_t cell = CA::Render::emitter_find_cell(*((void *)this + 4), a3[1]);
  if (!cell) {
    return 0;
  }
  uint64_t v14 = cell;
  v10 += 2;
  for (v6 -= 2; v6; v6 -= 2)
  {
    unsigned int v15 = *v10;
    unsigned int v16 = CA::Render::cell_atom_param_index(*v10);
    if ((v16 & 0x80000000) == 0)
    {
      double v19 = *(float *)(v14 + 4 * v16 + 72);
      goto LABEL_26;
    }
    if (v6 < 2 || v15 != 201)
    {
      if (v15 != 92) {
        goto LABEL_30;
      }
      float v20 = *(float *)(v14 + 176);
      *(float64x2_t *)float32x2_t v8 = vcvtq_f64_f32(vmul_n_f32(*(float32x2_t *)(v14 + 164), 1.0 / v20));
      double v8[2] = (float)(*(float *)(v14 + 172) * (float)(1.0 / v20));
      v8[3] = v20;
      return 4;
    }
    uint64_t v14 = CA::Render::emitter_find_cell(*(void *)(v14 + 40), v10[1]);
    v10 += 2;
    if (!v14) {
      return 0;
    }
  }
  return v6;
}

uint64_t CA::Render::EmitterLayer::set_keypath_object(uint64_t this, void *const *a2, CA::Render::Object *a3)
{
  unint64_t v3 = (unint64_t)*a2;
  if (*a2)
  {
    uint64_t v4 = a3;
    uint64_t v6 = this;
    if (v3)
    {
      unint64_t v7 = v3 >> 1;
    }
    else
    {
      if (!*(_DWORD *)v3) {
        return this;
      }
      LODWORD(v7) = *(_DWORD *)(v3 + 4);
    }
    if (v7 == 201)
    {
      uint64_t v9 = *(void *)(this + 32);
      if ((v3 & 1) != 0 || *(_DWORD *)v3 < 2u) {
        unsigned int v10 = 0;
      }
      else {
        unsigned int v10 = *(_DWORD *)(v3 + 8);
      }
      this = CA::Render::emitter_find_cell(v9, v10);
      if (this)
      {
        uint64_t v12 = this;
        for (uint64_t i = 0; ; i += 2)
        {
          unint64_t v14 = (unint64_t)*a2;
          if (!*a2) {
            return this;
          }
          if (v14)
          {
            if (i != -2) {
              return this;
            }
            v14 >>= 1;
            if (v14 != 201) {
              goto LABEL_51;
            }
            unsigned int v16 = 0;
            uint64_t v15 = *(void *)(v12 + 40);
          }
          else
          {
            if (i + 2 >= (unint64_t)*(unsigned int *)v14)
            {
              unint64_t v17 = i + 2;
              goto LABEL_49;
            }
            if (*(_DWORD *)(v14 + 4 * i + 12) != 201)
            {
              unint64_t v17 = i + 2;
              if (v14)
              {
                if (i != -2) {
                  return this;
                }
                v14 >>= 1;
              }
              else
              {
LABEL_49:
                if (v17 >= *(unsigned int *)v14) {
                  return this;
                }
                LODWORD(v14) = *(_DWORD *)(v14 + ((4 * v17) | 4));
              }
LABEL_51:
              if (v14 == 119)
              {
                if (v4)
                {
                  uint64_t v18 = 0;
                  int v19 = *((unsigned __int8 *)v4 + 12);
                  do
                    int v20 = CA::Render::texture_types[v18];
                  while (v20 != v19 && v18++ != 5);
                  if (v20 != v19) {
                    uint64_t v4 = 0;
                  }
                }
                this = *(void *)(v12 + 24);
                if ((CA::Render::Object *)this != v4)
                {
                  if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
                    this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
                  }
                  if (v4)
                  {
                    unint64_t v22 = (atomic_uint *)((char *)v4 + 8);
                    if (!atomic_fetch_add((atomic_uint *volatile)v4 + 2, 1u))
                    {
                      uint64_t v4 = 0;
                      atomic_fetch_add(v22, 0xFFFFFFFF);
                    }
                  }
                  *(void *)(v12 + 24) = v4;
                }
              }
              return this;
            }
            uint64_t v15 = *(void *)(v12 + 40);
            if (i + 3 >= (unint64_t)*(unsigned int *)v14) {
              unsigned int v16 = 0;
            }
            else {
              unsigned int v16 = *(_DWORD *)(v14 + 4 * i + 16);
            }
          }
          this = CA::Render::emitter_find_cell(v15, v16);
          if (!this) {
            return this;
          }
          uint64_t v12 = this;
        }
      }
    }
    else if (v7 == 207)
    {
      if (!a3 || *((unsigned char *)a3 + 12) == 56)
      {
        this = *(void *)(this + 56);
        if ((CA::Render::Object *)this != a3)
        {
          if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
            this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
          }
          if (v4)
          {
            float v11 = (atomic_uint *)((char *)v4 + 8);
            if (!atomic_fetch_add((atomic_uint *volatile)v4 + 2, 1u))
            {
              uint64_t v4 = 0;
              atomic_fetch_add(v11, 0xFFFFFFFF);
            }
          }
          *(void *)(v6 + 56) = v4;
        }
      }
    }
    else if (v7 == 205 && (!a3 || *((unsigned char *)a3 + 12) == 36))
    {
      this = *(void *)(this + 48);
      if ((CA::Render::Object *)this != a3)
      {
        if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
          this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
        }
        if (v4)
        {
          float32x2_t v8 = (atomic_uint *)((char *)v4 + 8);
          if (!atomic_fetch_add((atomic_uint *volatile)v4 + 2, 1u))
          {
            uint64_t v4 = 0;
            atomic_fetch_add(v8, 0xFFFFFFFF);
          }
        }
        *(void *)(v6 + 48) = v4;
      }
    }
  }
  return this;
}

uint64_t CA::Render::EmitterLayer::get_keypath_object(CA::Render::EmitterLayer *this, void *const *a2)
{
  unint64_t v2 = (unint64_t)*a2;
  if (!*a2) {
    return 0;
  }
  if ((v2 & 1) == 0)
  {
    if (*(_DWORD *)v2)
    {
      LODWORD(v4) = *(_DWORD *)(v2 + 4);
      goto LABEL_6;
    }
    return 0;
  }
  unint64_t v4 = v2 >> 1;
LABEL_6:
  if (v4 != 201)
  {
    if (v4 == 207)
    {
      float v5 = (char *)this + 56;
      return *(void *)v5;
    }
    if (v4 == 205)
    {
      float v5 = (char *)this + 48;
      return *(void *)v5;
    }
    return 0;
  }
  uint64_t v6 = *((void *)this + 4);
  if ((v2 & 1) != 0 || *(_DWORD *)v2 < 2u) {
    unsigned int v7 = 0;
  }
  else {
    unsigned int v7 = *(_DWORD *)(v2 + 8);
  }
  uint64_t result = CA::Render::emitter_find_cell(v6, v7);
  if (result)
  {
    for (uint64_t i = 0; ; i += 2)
    {
      unint64_t v10 = (unint64_t)*a2;
      if (!*a2) {
        return 0;
      }
      if (v10)
      {
        if (i != -2) {
          return 0;
        }
        v10 >>= 1;
        if (v10 != 201) {
          goto LABEL_36;
        }
        unsigned int v12 = 0;
        uint64_t v11 = *(void *)(result + 40);
      }
      else
      {
        if (i + 2 >= (unint64_t)*(unsigned int *)v10)
        {
          unint64_t v13 = i + 2;
          goto LABEL_32;
        }
        if (*(_DWORD *)(v10 + 4 * i + 12) != 201)
        {
          unint64_t v13 = i + 2;
          if (v10)
          {
            if (i != -2) {
              return 0;
            }
            v10 >>= 1;
          }
          else
          {
LABEL_32:
            if (v13 >= *(unsigned int *)v10) {
              return 0;
            }
            LODWORD(v10) = *(_DWORD *)(v10 + ((4 * v13) | 4));
          }
LABEL_36:
          if (v10 != 119) {
            return 0;
          }
          float v5 = (char *)(result + 24);
          return *(void *)v5;
        }
        uint64_t v11 = *(void *)(result + 40);
        if (i + 3 >= (unint64_t)*(unsigned int *)v10) {
          unsigned int v12 = 0;
        }
        else {
          unsigned int v12 = *(_DWORD *)(v10 + 4 * i + 16);
        }
      }
      uint64_t result = CA::Render::emitter_find_cell(v11, v12);
      if (!result) {
        return result;
      }
    }
  }
  return result;
}

BOOL CA::Render::EmitterLayer::keypath_is_object(CA::Render::EmitterLayer *this, void *const *a2)
{
  unint64_t v2 = (unint64_t)*a2;
  if (!*a2) {
    return 0;
  }
  if (v2)
  {
    unint64_t v4 = v2 >> 1;
  }
  else
  {
    if (!*(_DWORD *)v2) {
      return 0;
    }
    LODWORD(v4) = *(_DWORD *)(v2 + 4);
  }
  uint64_t v5 = 1;
  if (v4 == 207 || v4 == 205) {
    return v5;
  }
  if (v4 != 201) {
    return 0;
  }
  uint64_t v6 = *((void *)this + 4);
  if ((v2 & 1) != 0 || *(_DWORD *)v2 < 2u) {
    unsigned int v7 = 0;
  }
  else {
    unsigned int v7 = *(_DWORD *)(v2 + 8);
  }
  uint64_t cell = CA::Render::emitter_find_cell(v6, v7);
  if (!cell) {
    return 0;
  }
  for (uint64_t i = 0; ; i += 2)
  {
    unint64_t v10 = (unint64_t)*a2;
    if (!*a2) {
      return v10 == 119;
    }
    if (v10) {
      break;
    }
    if (i + 2 >= (unint64_t)*(unsigned int *)v10)
    {
      unint64_t v14 = i + 2;
      goto LABEL_31;
    }
    if (*(_DWORD *)(v10 + 4 * i + 12) != 201)
    {
      unint64_t v14 = i + 2;
      if (v10) {
        goto LABEL_34;
      }
LABEL_31:
      if (v14 >= *(unsigned int *)v10) {
        LODWORD(v10) = 0;
      }
      else {
        LODWORD(v10) = *(_DWORD *)(v10 + ((4 * v14) | 4));
      }
      return v10 == 119;
    }
    uint64_t v11 = *(void *)(cell + 40);
    if (i + 3 >= (unint64_t)*(unsigned int *)v10) {
      unsigned int v12 = 0;
    }
    else {
      unsigned int v12 = *(_DWORD *)(v10 + 4 * i + 16);
    }
LABEL_25:
    uint64_t cell = CA::Render::emitter_find_cell(v11, v12);
    if (!cell) {
      return 0;
    }
  }
  if (i == -2 && (v10 >> 1) == 201)
  {
    unsigned int v12 = 0;
    uint64_t v11 = *(void *)(cell + 40);
    goto LABEL_25;
  }
  unint64_t v14 = i + 2;
LABEL_34:
  v10 >>= 1;
  if (v14) {
    LODWORD(v10) = 0;
  }
  return v10 == 119;
}

uint64_t CA::Render::EmitterLayer::commit_layer(uint64_t this, CA::Render::Context *a2, CA::Render::Layer *a3, CA::Render::Handle *a4)
{
  if (!*(void *)(this + 24))
  {
    uint64_t v5 = this;
    uint64_t v6 = *(void *)(this + 16);
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::EmitterState::_list_lock);
    for (uint64_t i = CA::Render::EmitterState::_list; i; uint64_t i = *(void *)(i + 16))
    {
      if (*(CA::Render::Context **)(i + 104) == a2 && *(void *)(i + 96) == v6)
      {
        if (atomic_fetch_add((atomic_uint *volatile)(i + 8), 1u)) {
          goto LABEL_11;
        }
        atomic_fetch_add((atomic_uint *volatile)(i + 8), 0xFFFFFFFF);
      }
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v9 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xB8uLL, 0x743898A5uLL);
    uint64_t i = (uint64_t)v9;
    if (v9)
    {
      *(_OWORD *)(v9 + 168) = 0u;
      *(_OWORD *)(v9 + 152) = 0u;
      *(_OWORD *)(v9 + 136) = 0u;
      *(_OWORD *)(v9 + 120) = 0u;
      *(_OWORD *)(v9 + 104) = 0u;
      *(_OWORD *)(v9 + 88) = 0u;
      *(_OWORD *)(v9 + 72) = 0u;
      *(_OWORD *)(v9 + 56) = 0u;
      *(_OWORD *)(v9 + 40) = 0u;
      *(_OWORD *)(v9 + 24) = 0u;
      *((_DWORD *)v9 + 2) = 1;
      *((_DWORD *)v9 + 3) = 16;
      ++dword_1EB2ADE08;
      *(void *)uint64_t v9 = &unk_1ED02D378;
      *((_DWORD *)v9 + 6) = 0;
      *((void *)v9 + 19) = 0;
      *((void *)v9 + 20) = 0;
      *((void *)v9 + 18) = 0;
    }
    *((void *)v9 + 12) = v6;
    *((void *)v9 + 13) = a2;
    *((void *)v9 + 2) = CA::Render::EmitterState::_list;
    CA::Render::EmitterState::_list = (uint64_t)v9;
LABEL_11:
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::EmitterState::_list_lock);
    this = *(void *)(v5 + 24);
    *(void *)(v5 + 24) = i;
    if (this)
    {
      if (atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
      }
      uint64_t i = *(void *)(v5 + 24);
    }
    if (!*(_DWORD *)(i + 28)) {
      *(_DWORD *)(i + 28) = *(_DWORD *)(v5 + 152);
    }
  }
  return this;
}

void CA::Render::EmitterState::~EmitterState(CA::Render::EmitterState *this)
{
  CA::Render::EmitterState::~EmitterState(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  CA::Render::EmitterState *v2;
  CA::Render::EmitterState *v3;
  uint64_t *v4;
  const CA::Render::Object *v5;
  void *v6;

  *(void *)this = &unk_1ED02D378;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::EmitterState::_list_lock);
  unint64_t v2 = (CA::Render::EmitterState *)CA::Render::EmitterState::_list;
  if (CA::Render::EmitterState::_list)
  {
    if ((CA::Render::EmitterState *)CA::Render::EmitterState::_list == this)
    {
      unint64_t v4 = &CA::Render::EmitterState::_list;
LABEL_7:
      *unint64_t v4 = *((void *)this + 2);
    }
    else
    {
      while (1)
      {
        unint64_t v3 = v2;
        unint64_t v2 = (CA::Render::EmitterState *)*((void *)v2 + 2);
        if (!v2) {
          break;
        }
        if (v2 == this)
        {
          unint64_t v4 = (uint64_t *)((char *)v3 + 16);
          goto LABEL_7;
        }
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::EmitterState::_list_lock);
  CA::Render::EmitterState::free_cells_state(this, (uint64_t)this + 112);
  uint64_t v6 = (void *)*((void *)this + 18);
  if (v6)
  {
    *((void *)this + 19) = v6;
    operator delete(v6);
  }
  --dword_1EB2ADE08;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, v5);
  }
}

void CA::Render::EmitterLayer::copy(CA::Render::EmitterLayer *this@<X0>, void *a2@<X8>)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v5 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0xA8uLL, 0x743898A5uLL);
  uint64_t v6 = v5;
  if (v5)
  {
    vm_address_t v5[2] = 1;
    void v5[3] = 15;
    ++dword_1EB2ADE04;
    *(void *)uint64_t v5 = &unk_1ED02D270;
    uint64_t v7 = *((void *)this + 3);
    *((void *)v5 + 2) = *((void *)this + 2);
    if (v7)
    {
      float32x2_t v8 = (atomic_uint *)(v7 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v7 + 8), 1u))
      {
        uint64_t v7 = 0;
        atomic_fetch_add(v8, 0xFFFFFFFF);
      }
    }
    *((void *)v5 + 3) = v7;
    CA::Render::emitter_cells_copy((void *)v5 + 4, *((void *)this + 4));
    CA::Render::emitter_behaviors_copy((void *)v6 + 5, *((void *)this + 5));
    uint64_t v9 = *((void *)this + 6);
    if (v9)
    {
      unint64_t v10 = (atomic_uint *)(v9 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v9 + 8), 1u))
      {
        uint64_t v9 = 0;
        atomic_fetch_add(v10, 0xFFFFFFFF);
      }
    }
    *((void *)v6 + 6) = v9;
    uint64_t v11 = *((void *)this + 7);
    if (v11)
    {
      unsigned int v12 = (atomic_uint *)(v11 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v11 + 8), 1u))
      {
        uint64_t v11 = 0;
        atomic_fetch_add(v12, 0xFFFFFFFF);
      }
    }
    *((void *)v6 + 7) = v11;
    *((void *)v6 + 8) = *((void *)this + 8);
    v6[18] = *((_DWORD *)this + 18);
    v6[38] = *((_DWORD *)this + 38);
    *((void *)v6 + 20) = *((void *)this + 20);
    v6[3] |= *((_DWORD *)this + 3) & 0xFFFFFF00;
    *(_OWORD *)(v6 + 19) = *(_OWORD *)((char *)this + 76);
    long long v13 = *(_OWORD *)((char *)this + 92);
    long long v14 = *(_OWORD *)((char *)this + 108);
    long long v15 = *(_OWORD *)((char *)this + 124);
    *(_OWORD *)(v6 + 34) = *(_OWORD *)((char *)this + 136);
    *(_OWORD *)(v6 + 31) = v15;
    *(_OWORD *)(v6 + 27) = v14;
    *(_OWORD *)(v6 + 23) = v13;
  }
  *a2 = v6;
}

void CA::Render::emitter_cells_copy(void *a1, uint64_t a2)
{
  unint64_t v2 = a1;
  v29[1] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    goto LABEL_27;
  }
  uint64_t v4 = *(unsigned int *)(a2 + 16);
  if (v4 < 0x201)
  {
    MEMORY[0x1F4188790](a1);
    uint64_t v6 = (char *)v29 - ((v5 + 15) & 0xFFFFFFFF0);
    bzero(v6, v5);
    if (v4) {
      goto LABEL_4;
    }
LABEL_27:
    uint64_t v7 = 0;
    goto LABEL_28;
  }
  uint64_t v6 = (char *)malloc_type_malloc(8 * v4, 0x15FFAEDFuLL);
  if (!v6) {
    goto LABEL_27;
  }
LABEL_4:
  v29[0] = v2;
  uint64_t v7 = 0;
  float32x2_t v8 = (uint64_t *)(a2 + 24);
  uint64_t v9 = v4;
  do
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v11 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0xE8uLL, 0x743898A5uLL);
    unsigned int v12 = v11;
    if (v11)
    {
      uint64_t v13 = *v8;
      v11[2] = 1;
      v11[3] = 14;
      ++dword_1EB2ADE00;
      *(void *)uint64_t v11 = &unk_1ED02CF48;
      uint64_t v14 = *(void *)(v13 + 16);
      if (v14)
      {
        long long v15 = (atomic_uint *)(v14 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)(v14 + 8), 1u))
        {
          uint64_t v14 = 0;
          atomic_fetch_add(v15, 0xFFFFFFFF);
        }
      }
      *((void *)v11 + 2) = v14;
      uint64_t v16 = *(void *)(v13 + 24);
      if (v16)
      {
        unint64_t v17 = (atomic_uint *)(v16 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)(v16 + 8), 1u))
        {
          uint64_t v16 = 0;
          atomic_fetch_add(v17, 0xFFFFFFFF);
        }
      }
      *((void *)v11 + 3) = v16;
      uint64_t v18 = *(void *)(v13 + 32);
      if (v18)
      {
        int v19 = (atomic_uint *)(v18 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)(v18 + 8), 1u))
        {
          uint64_t v18 = 0;
          atomic_fetch_add(v19, 0xFFFFFFFF);
        }
      }
      *((void *)v11 + 4) = v18;
      CA::Render::emitter_cells_copy(v11 + 10, *(void *)(v13 + 40));
      CA::Render::emitter_behaviors_copy((void *)v12 + 6, *(void *)(v13 + 48));
      uint64_t v20 = *(void *)(v13 + 56);
      if (v20)
      {
        unsigned int v21 = (atomic_uint *)(v20 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)(v20 + 8), 1u))
        {
          uint64_t v20 = 0;
          atomic_fetch_add(v21, 0xFFFFFFFF);
        }
      }
      *((void *)v12 + 7) = v20;
      *((void *)v12 + 8) = *(void *)(v13 + 64);
      v12[3] |= *(_DWORD *)(v13 + 12) & 0xFFFFFF00;
      long long v22 = *(_OWORD *)(v13 + 72);
      *(_OWORD *)(v12 + 22) = *(_OWORD *)(v13 + 88);
      *(_OWORD *)(v12 + 18) = v22;
      long long v23 = *(_OWORD *)(v13 + 104);
      long long v24 = *(_OWORD *)(v13 + 120);
      long long v25 = *(_OWORD *)(v13 + 136);
      *(_OWORD *)(v12 + 38) = *(_OWORD *)(v13 + 152);
      *(_OWORD *)(v12 + 34) = v25;
      *(_OWORD *)(v12 + 30) = v24;
      *(_OWORD *)(v12 + 26) = v23;
      long long v26 = *(_OWORD *)(v13 + 168);
      long long v27 = *(_OWORD *)(v13 + 184);
      long long v28 = *(_OWORD *)(v13 + 200);
      *(_OWORD *)(v12 + 54) = *(_OWORD *)(v13 + 216);
      *(_OWORD *)(v12 + 50) = v28;
      *(_OWORD *)(v12 + 46) = v27;
      *(_OWORD *)(v12 + 42) = v26;
    }
    *(void *)&v6[8 * (void)v7] = v12;
    if (v12) {
      uint64_t v7 = (CA::Render::Array *)((char *)v7 + 1);
    }
    ++v8;
    --v9;
  }
  while (v9);
  if (v7) {
    uint64_t v7 = (CA::Render::Array *)CA::Render::Array::new_array(v7, v6, 0, 0);
  }
  unint64_t v2 = (void *)v29[0];
  if (v4 >= 0x201) {
    free(v6);
  }
LABEL_28:
  *unint64_t v2 = v7;
}

void CA::Render::emitter_behaviors_copy(void *a1, size_t size)
{
  unint64_t v2 = a1;
  v18[1] = *MEMORY[0x1E4F143B8];
  if (!size) {
    goto LABEL_21;
  }
  uint64_t v4 = *(unsigned int *)(size + 16);
  if (v4 < 0x201)
  {
    MEMORY[0x1F4188790](a1);
    uint64_t v6 = (char *)v18 - ((v5 + 15) & 0xFFFFFFFF0);
    bzero(v6, v5);
    if (v4) {
      goto LABEL_4;
    }
LABEL_21:
    uint64_t v7 = 0;
    goto LABEL_22;
  }
  uint64_t v6 = (char *)malloc_type_malloc(8 * v4, 0x7C8E9D7CuLL);
  if (!v6) {
    goto LABEL_21;
  }
LABEL_4:
  v18[0] = v2;
  uint64_t v7 = 0;
  float32x2_t v8 = (uint64_t *)(size + 24);
  uint64_t v9 = v4;
  do
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v11 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x30uLL, 0x743898A5uLL);
    unsigned int v12 = v11;
    if (v11)
    {
      uint64_t v13 = *v8;
      v11[2] = 1;
      v11[3] = 13;
      ++dword_1EB2ADDFC;
      *(void *)uint64_t v11 = &unk_1ED02E198;
      v11[4] = *(_DWORD *)(v13 + 16);
      uint64_t v14 = *(void *)(v13 + 24);
      if (v14)
      {
        long long v15 = (atomic_uint *)(v14 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)(v14 + 8), 1u))
        {
          uint64_t v14 = 0;
          atomic_fetch_add(v15, 0xFFFFFFFF);
        }
      }
      *((void *)v11 + 3) = v14;
      uint64_t v16 = *(_DWORD **)(v13 + 32);
      if (v16) {
        unint64_t v17 = CA::Render::Array::new_array((CA::Render::Array *)v16[4], v16 + 6, (CA::Render::Object *const *)1, v16[3] >> 8);
      }
      else {
        unint64_t v17 = 0;
      }
      *((void *)v12 + 4) = v17;
      *((void *)v12 + 5) = 0;
      v12[3] |= *(_DWORD *)(v13 + 12) & 0xFFFFFF00;
    }
    *(void *)&v6[8 * (void)v7] = v12;
    if (v12) {
      uint64_t v7 = (CA::Render::Array *)((char *)v7 + 1);
    }
    ++v8;
    --v9;
  }
  while (v9);
  if (v7) {
    uint64_t v7 = (CA::Render::Array *)CA::Render::Array::new_array(v7, v6, 0, 0);
  }
  unint64_t v2 = (void *)v18[0];
  if (v4 >= 0x201) {
    free(v6);
  }
LABEL_22:
  *unint64_t v2 = v7;
}

void CA::Render::EmitterBehavior::show(CA::Render::EmitterBehavior *this, int a2, char a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  BOOL v6 = x_log_hook_p();
  if (a3)
  {
    if (v6)
    {
      [(__CFString *)CAAtomGetString(*((_DWORD *)this + 4)) cStringUsingEncoding:4];
LABEL_21:
      x_log_();
      return;
    }
    uint64_t v17 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = [(__CFString *)CAAtomGetString(*((_DWORD *)this + 4)) cStringUsingEncoding:4];
      *(_DWORD *)uint64_t buf = 136315138;
      uint64_t v20 = v18;
      uint64_t v14 = "(emitter-behavior %s)";
      long long v15 = v17;
      uint32_t v16 = 12;
      goto LABEL_24;
    }
  }
  else
  {
    if (v6)
    {
      [(__CFString *)CAAtomGetString(*((_DWORD *)this + 4)) cStringUsingEncoding:4];
      x_log_();
    }
    else
    {
      uint64_t v7 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = [(__CFString *)CAAtomGetString(*((_DWORD *)this + 4)) cStringUsingEncoding:4];
        *(_DWORD *)uint64_t buf = 136315138;
        uint64_t v20 = v8;
        _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_DEFAULT, "(emitter-behavior %s", buf, 0xCu);
      }
    }
    if ((*((unsigned char *)this + 13) & 1) == 0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v9 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl(&dword_184668000, v9, OS_LOG_TYPE_DEFAULT, "(enabled false)", buf, 2u);
        }
      }
    }
    if (*((void *)this + 4))
    {
      unint64_t v10 = (CA::Render *)(a2 + 1);
      CA::Render::show_newline(v10);
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v11 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl(&dword_184668000, v11, OS_LOG_TYPE_DEFAULT, "(values ", buf, 2u);
        }
      }
      CA::Render::show_object(*((CA::Render **)this + 4), v10);
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unsigned int v12 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl(&dword_184668000, v12, OS_LOG_TYPE_DEFAULT, ")", buf, 2u);
        }
      }
    }
    if (x_log_hook_p()) {
      goto LABEL_21;
    }
    uint64_t v13 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      uint64_t v14 = ")";
      long long v15 = v13;
      uint32_t v16 = 2;
LABEL_24:
      _os_log_impl(&dword_184668000, v15, OS_LOG_TYPE_DEFAULT, v14, buf, v16);
    }
  }
}

void CA::Render::EmitterBehavior::encode(CA::Render::EmitterBehavior *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 4));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 3));
  uint64_t v4 = (const CA::Render::Object *)*((void *)this + 4);

  CA::Render::Encoder::encode_object(a2, v4);
}

void CA::Render::EmitterBehavior::~EmitterBehavior(CA::Render::EmitterBehavior *this, const CA::Render::Object *a2)
{
  CA::Render::EmitterBehavior::~EmitterBehavior(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  uint64_t v3;
  atomic_uint *v4;
  atomic_uint *v5;

  *(void *)this = &unk_1ED02E198;
  unint64_t v3 = *((void *)this + 5);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 4);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  size_t v5 = (atomic_uint *)*((void *)this + 3);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  --dword_1EB2ADDFC;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

__n128 CA::Render::EmitterCell::encode(CA::Render::EmitterCell *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 2));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 3));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 4));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 5));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 6));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 7));
  CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 16));
  CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 17));
  uint64_t v4 = *((void *)a2 + 4);
  if ((unint64_t)(v4 + 160) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 160);
    uint64_t v4 = *((void *)a2 + 4);
  }
  long long v5 = *(_OWORD *)((char *)this + 88);
  *(_OWORD *)uint64_t v4 = *(_OWORD *)((char *)this + 72);
  *(_OWORD *)(v4 + 16) = v5;
  long long v6 = *(_OWORD *)((char *)this + 104);
  long long v7 = *(_OWORD *)((char *)this + 120);
  long long v8 = *(_OWORD *)((char *)this + 152);
  *(_OWORD *)(v4 + 64) = *(_OWORD *)((char *)this + 136);
  *(_OWORD *)(v4 + 80) = v8;
  *(_OWORD *)(v4 + 32) = v6;
  *(_OWORD *)(v4 + 48) = v7;
  __n128 result = *(__n128 *)((char *)this + 168);
  long long v10 = *(_OWORD *)((char *)this + 184);
  long long v11 = *(_OWORD *)((char *)this + 216);
  *(_OWORD *)(v4 + 128) = *(_OWORD *)((char *)this + 200);
  *(_OWORD *)(v4 + 144) = v11;
  *(__n128 *)(v4 + 96) = result;
  *(_OWORD *)(v4 + 112) = v10;
  *((void *)a2 + 4) += 160;
  return result;
}

void CA::Render::EmitterCell::~EmitterCell(CA::Render::EmitterCell *this, const CA::Render::Object *a2)
{
  CA::Render::EmitterCell::~EmitterCell(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  atomic_uint *v4;
  atomic_uint *v5;
  atomic_uint *v6;
  atomic_uint *v7;
  atomic_uint *v8;

  *(void *)this = &unk_1ED02CF48;
  unint64_t v3 = (atomic_uint *)*((void *)this + 7);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 6);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  long long v5 = (atomic_uint *)*((void *)this + 5);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  long long v6 = (atomic_uint *)*((void *)this + 4);
  if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
  }
  long long v7 = (atomic_uint *)*((void *)this + 3);
  if (v7 && atomic_fetch_add(v7 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v7 + 16))(v7);
  }
  long long v8 = (atomic_uint *)*((void *)this + 2);
  if (v8 && atomic_fetch_add(v8 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v8 + 16))(v8);
  }
  --dword_1EB2ADE00;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

__n128 CA::Render::EmitterLayer::encode(CA::Render::EmitterLayer *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  uint64_t v4 = *((void *)this + 2);
  long long v5 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    long long v5 = (void *)*((void *)a2 + 4);
  }
  void *v5 = v4;
  *((void *)a2 + 4) += 8;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 4));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 5));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 6));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 7));
  CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 16));
  CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 17));
  CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 18));
  int v6 = *((_DWORD *)this + 38);
  long long v7 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v7 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    long long v7 = (_DWORD *)*((void *)a2 + 4);
  }
  _DWORD *v7 = v6;
  uint64_t v8 = *((void *)a2 + 4);
  unint64_t v9 = *((void *)a2 + 5);
  long long v10 = (void *)(v8 + 4);
  *((void *)a2 + 4) = v8 + 4;
  uint64_t v11 = *((void *)this + 20);
  if (v8 + 12 > v9)
  {
    CA::Render::Encoder::grow(a2, 8);
    long long v10 = (void *)*((void *)a2 + 4);
  }
  *long long v10 = v11;
  uint64_t v12 = *((void *)a2 + 4);
  unint64_t v13 = *((void *)a2 + 5);
  uint64_t v14 = v12 + 8;
  *((void *)a2 + 4) = v12 + 8;
  if (v12 + 84 > v13)
  {
    CA::Render::Encoder::grow(a2, 76);
    uint64_t v14 = *((void *)a2 + 4);
  }
  *(_OWORD *)uint64_t v14 = *(_OWORD *)((char *)this + 76);
  __n128 result = *(__n128 *)((char *)this + 92);
  long long v16 = *(_OWORD *)((char *)this + 108);
  long long v17 = *(_OWORD *)((char *)this + 124);
  *(_OWORD *)(v14 + 60) = *(_OWORD *)((char *)this + 136);
  *(_OWORD *)(v14 + 32) = v16;
  *(_OWORD *)(v14 + 48) = v17;
  *(__n128 *)(v14 + 16) = result;
  *((void *)a2 + 4) += 76;
  return result;
}

void CA::Render::EmitterLayer::~EmitterLayer(CA::Render::EmitterLayer *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02D270;
  unint64_t v3 = (atomic_uint *)*((void *)this + 7);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 6);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  long long v5 = (atomic_uint *)*((void *)this + 5);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  int v6 = (atomic_uint *)*((void *)this + 4);
  if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
  }
  long long v7 = (atomic_uint *)*((void *)this + 3);
  if (v7 && atomic_fetch_add(v7 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v7 + 16))(v7);
  }
  --dword_1EB2ADE04;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  atomic_uint *v4;
  atomic_uint *v5;
  atomic_uint *v6;
  atomic_uint *v7;

  *(void *)this = &unk_1ED02D270;
  unint64_t v3 = (atomic_uint *)*((void *)this + 7);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 6);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  long long v5 = (atomic_uint *)*((void *)this + 5);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  int v6 = (atomic_uint *)*((void *)this + 4);
  if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
  }
  long long v7 = (atomic_uint *)*((void *)this + 3);
  if (v7 && atomic_fetch_add(v7 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v7 + 16))(v7);
  }
  --dword_1EB2ADE04;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

CA::Render::EmitterLayer *CA::Render::EmitterLayer::EmitterLayer(CA::Render::EmitterLayer *this, CA::Render::Decoder *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0xF;
  ++dword_1EB2ADE04;
  *(void *)this = &unk_1ED02D270;
  *((void *)this + 2) = CA::Render::Decoder::decode_size_t(a2);
  *((void *)this + 3) = 0;
  int v5 = 14;
  *((void *)this + 4) = CA::Render::Decoder::decode_array_object(a2, 1, &v5, 0);
  int v5 = 13;
  *((void *)this + 5) = CA::Render::Decoder::decode_array_object(a2, 1, &v5, 0);
  *((void *)this + 6) = CA::Render::Decoder::decode_object(a2, 36);
  *((void *)this + 7) = CA::Render::Decoder::decode_object(a2, 56);
  *((_DWORD *)this + 16) = CA::Render::Decoder::decode_atom(a2);
  *((_DWORD *)this + 17) = CA::Render::Decoder::decode_atom(a2);
  *((_DWORD *)this + 18) = CA::Render::Decoder::decode_atom(a2);
  *((_DWORD *)this + 38) = CA::Render::Decoder::decode_int32(a2);
  *((double *)this + 20) = fmax(COERCE_DOUBLE(CA::Render::Decoder::decode_int64(a2)), 0.0);
  CA::Render::Decoder::decode_bytes(a2, (char *)this + 76, 0x4CuLL);
  return this;
}

CA::Render::EmitterCell *CA::Render::EmitterCell::EmitterCell(CA::Render::EmitterCell *this, CA::Render::Decoder *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0xE;
  ++dword_1EB2ADE00;
  *(void *)this = &unk_1ED02CF48;
  *((void *)this + 2) = CA::Render::Decoder::decode_object(a2, 49);
  *((void *)this + 3) = CA::Render::Decoder::decode_object(a2, 6, (uint64_t)&CA::Render::texture_types);
  *((void *)this + 4) = CA::Render::Decoder::decode_object(a2, 56);
  int v8 = 14;
  *((void *)this + 5) = CA::Render::Decoder::decode_array_object(a2, 1, &v8, 0);
  int v8 = 13;
  *((void *)this + 6) = CA::Render::Decoder::decode_array_object(a2, 1, &v8, 0);
  *((void *)this + 7) = CA::Render::Decoder::decode_object(a2, 52);
  *((_DWORD *)this + 16) = CA::Render::Decoder::decode_atom(a2);
  *((_DWORD *)this + 17) = CA::Render::Decoder::decode_atom(a2);
  CA::Render::Decoder::decode_bytes(a2, (char *)this + 72, 0xA0uLL);
  uint64_t v4 = *((void *)this + 4);
  if (v4)
  {
    unsigned int v5 = *(_DWORD *)(v4 + 16);
    if (v5 <= 3)
    {
      CA::Render::Decoder::set_fatal_error(a2, "%s - _contentsRect size %u", "EmitterCell", v5);
      uint64_t v6 = (atomic_uint *)*((void *)this + 4);
      if (v6)
      {
        if (atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
        }
        *((void *)this + 4) = 0;
      }
    }
  }
  return this;
}

CA::Render::EmitterBehavior *CA::Render::EmitterBehavior::EmitterBehavior(CA::Render::EmitterBehavior *this, CA::Render::Decoder *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0xD;
  ++dword_1EB2ADDFC;
  *(void *)this = &unk_1ED02E198;
  *((_DWORD *)this + 4) = CA::Render::Decoder::decode_atom(a2);
  *((void *)this + 3) = CA::Render::Decoder::decode_object(a2, 49);
  int v8 = 28;
  uint64_t v4 = CA::Render::Decoder::decode_array_object(a2, 1, &v8, 0);
  if (v4)
  {
    unsigned int v5 = v4 + 2;
    uint64_t v6 = v4;
    if (!atomic_fetch_add(v4 + 2, 1u))
    {
      uint64_t v6 = 0;
      atomic_fetch_add(v5, 0xFFFFFFFF);
    }
    *((void *)this + 4) = v6;
    if (atomic_fetch_add(v5, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
    }
  }
  else
  {
    *((void *)this + 4) = 0;
  }
  *((void *)this + 5) = 0;
  return this;
}

atomic_uint *CA::Render::MetalTexture::unref_image_data(atomic_uint *this)
{
  unsigned int add = atomic_fetch_add(this + 26, 0xFFFFFFFF);
  if (this)
  {
    if (add == 1) {
      return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)this + 8))();
    }
  }
  return this;
}

uint64_t CA::Render::MetalTexture::ref_image_data(uint64_t this)
{
  return this;
}

uint64_t CA::Render::MetalTexture::depth(id *this)
{
  return [this[12] depth];
}

void CA::Render::MetalTexture::show(id *this, unsigned int a2, char a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  BOOL v5 = x_log_hook_p();
  if (a3)
  {
    if (v5)
    {
      [this[12] pixelFormat];
      MTLPixelFormatGetName();
LABEL_20:
      x_log_();
      return;
    }
    uint64_t v17 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = *((_DWORD *)this + 4);
      int v19 = *((_DWORD *)this + 5);
      [this[12] pixelFormat];
      *(_DWORD *)uint64_t buf = 67109634;
      *(_DWORD *)&uint8_t buf[4] = v18;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v19;
      *(_WORD *)&buf[14] = 2080;
      *(void *)&long long v23 = MTLPixelFormatGetName();
      uint64_t v14 = "<metal-texture [%d %d] [%s]>";
      long long v15 = v17;
      uint32_t v16 = 24;
      goto LABEL_23;
    }
  }
  else
  {
    if (v5)
    {
      [this[12] pixelFormat];
      MTLPixelFormatGetName();
      x_log_();
    }
    else
    {
      uint64_t v6 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = *((_DWORD *)this + 4);
        int v8 = *((_DWORD *)this + 5);
        [this[12] pixelFormat];
        *(_DWORD *)uint64_t buf = 67109634;
        *(_DWORD *)&uint8_t buf[4] = v7;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v8;
        *(_WORD *)&buf[14] = 2080;
        *(void *)&long long v23 = MTLPixelFormatGetName();
        _os_log_impl(&dword_184668000, v6, OS_LOG_TYPE_DEFAULT, "(metal-texture [%d %d] %s", buf, 0x18u);
      }
    }
    if (this[6])
    {
      if ((*((unsigned char *)this + 14) & 8) != 0)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          uint64_t v9 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl(&dword_184668000, v9, OS_LOG_TYPE_DEFAULT, " colormatching-disabled", buf, 2u);
          }
        }
      }
      CFStringRef v10 = (const __CFString *)CGColorSpaceCopyICCProfileDescription();
      if (v10)
      {
        CFStringRef v11 = v10;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        *(_OWORD *)uint64_t buf = 0u;
        long long v23 = 0u;
        CFStringGetCString(v10, (char *)buf, 127, 0x8000100u);
        if (buf[0])
        {
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            uint64_t v12 = x_log_category_render;
            if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)uint64_t v20 = 136315138;
              uint64_t v21 = buf;
              _os_log_impl(&dword_184668000, v12, OS_LOG_TYPE_DEFAULT, " (colorspace \"%s\")", v20, 0xCu);
            }
          }
        }
        CFRelease(v11);
      }
    }
    if (x_log_hook_p()) {
      goto LABEL_20;
    }
    uint64_t v13 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      uint64_t v14 = ")";
      long long v15 = v13;
      uint32_t v16 = 2;
LABEL_23:
      _os_log_impl(&dword_184668000, v15, OS_LOG_TYPE_DEFAULT, v14, buf, v16);
    }
  }
}

uint64_t CA::Render::MetalTexture::caches_encoding(CA::Render::MetalTexture *this)
{
  return 0;
}

uint64_t CA::Render::MetalTexture::finalize(CA::Render::MetalTexture *this)
{
  CA::Render::post_notification(3u, (unint64_t)this, 0, 1);
  unint64_t v2 = *(uint64_t (**)(CA::Render::MetalTexture *))(*(void *)this + 184);

  return v2(this);
}

void CA::Render::MetalTexture::~MetalTexture(id *this)
{
  CA::Render::MetalTexture::~MetalTexture(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  uint64_t vars8;

  *this = &unk_1ED02D568;

  --dword_1EB2ADE50;

  CA::Render::Texture::~Texture((CGColorSpaceRef *)this);
}

void sub_1848E71B4(_Unwind_Exception *a1)
{
  --dword_1EB2ADE50;
  CA::Render::Texture::~Texture(v1);
  _Unwind_Resume(a1);
}

CA::Render::MetalTexture *CA::Render::MetalTexture::MetalTexture(CA::Render::MetalTexture *this, objc_object *a2)
{
  *((unsigned char *)this + 12) = 34;
  ++dword_1EB2ADE50;
  *(void *)this = &unk_1ED02D568;
  *((void *)this + 12) = a2;
  *((_DWORD *)this + 3) |= 0x40000u;
  *((_DWORD *)this + 26) = 1;
  return this;
}

void sub_1848E7280(_Unwind_Exception *a1)
{
  --*(_DWORD *)(v2 + 3664);
  CA::Render::Texture::~Texture(v1);
  _Unwind_Resume(a1);
}

CA::Render::MetalTexture *CA::Render::MetalTexture::decode()
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  __n128 result = (CA::Render::MetalTexture *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x70uLL, 0x743898A5uLL);
  if (result) {
    return CA::Render::MetalTexture::MetalTexture(result, 0);
  }
  return result;
}

uint64_t CA::OGL::PerformanceHUD::CounterInfo::set_display_mode(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 48) != a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void **)(result + 24);
    if (v4)
    {
      if (*v4) {
        MEMORY[0x185323DA0](*v4, 0x1000C80F7F8B94BLL);
      }
      __n128 result = MEMORY[0x185323DC0](v4, 0x20C40960023A9);
      *(void *)(v3 + 24) = 0;
    }
    if (a2 == 3) {
      operator new();
    }
    *(_DWORD *)(v3 + 48) = a2;
  }
  return result;
}

float CA::OGL::PerformanceHUD::initialize_timebase(CA::OGL::PerformanceHUD *this)
{
  v4[1] = *(mach_timebase_info *)MEMORY[0x1E4F143B8];
  v4[0] = 0;
  mach_timebase_info(v4);
  LODWORD(v2) = v4[0].denom;
  LODWORD(v1) = v4[0].numer;
  *(float *)&unint64_t v1 = (double)v1 * 0.000001 / (double)v2;
  CA::OGL::PerformanceHUD::_scale_ticks_to_ms = v1;
  float result = 1.0 / *(float *)&v1;
  CA::OGL::PerformanceHUD::_scale_ms_to_ticks = LODWORD(result);
  return result;
}

float CA::OGL::PerformanceHUD::register_counter(CA::OGL::PerformanceHUD *a1, int a2, unsigned int a3, uint64_t a4, int a5)
{
  if (a3 >= 0x30) {
    __assert_rtn("register_counter", "ogl-performance-hud.cpp", 569, "counter_index < _num_counters");
  }
  uint64_t v6 = (char *)a1 + 64 * (unint64_t)a3;
  if (!*((_DWORD *)v6 + 203))
  {
    *((void *)v6 + 100) = a4;
    *((_DWORD *)v6 + 202) = a2;
    *((_DWORD *)v6 + 203) = a5;
    *((void *)v6 + 98) = 1;
    CA::OGL::PerformanceHUD::CounterInfo::set_display_mode((uint64_t)(v6 + 768), 1);
    *((_DWORD *)v6 + 206) = 0;
    v6[828] = 0;
    return CA::OGL::PerformanceHUD::layout(a1);
  }
  return result;
}

float CA::OGL::PerformanceHUD::layout(CA::OGL::PerformanceHUD *this)
{
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  uint64_t v2 = 0;
  float v3 = (float)(*(float *)&dword_1EB2ACAF8 >> 16);
  float v4 = (float)(unsigned __int16)*(float *)&dword_1EB2ACAF8;
  float v5 = v3 + 360.0;
  *((float *)this + 1030) = v3 + 360.0;
  *((float *)this + 1031) = v4;
  float v6 = v4;
  do
  {
    if (*(_DWORD *)((char *)this + v2 + 812)
      && ((*((_DWORD *)this + 1034) >> *(_DWORD *)((char *)this + v2 + 808)) & 1) != 0)
    {
      unsigned int v7 = *(_DWORD *)((char *)this + v2 + 816) - 1;
      float v8 = 0.0;
      if (v7 <= 2) {
        float v8 = flt_1849A4398[v7];
      }
      float v6 = v6 + v8;
      *((float *)this + 1031) = v6;
    }
    v2 += 64;
  }
  while (v2 != 3072);
  if ((*((unsigned char *)this + 4136) & 0x10) != 0)
  {
    *((float *)this + 1028) = v3 + 50.0;
    *((float *)this + 1029) = v4 + 50.0;
    if (*(float *)&dword_1EB2ACAF0 < 0x100)
    {
      if (*(float *)&dword_1EB2ACAF0 >= 0x3F)
      {
        _S0 = (float)*(float *)&dword_1EB2ACAF0 * 0.0039216;
        __asm { FCVT            H0, S0 }
        __int16 v9 = LOWORD(_S0);
      }
      else
      {
        __int16 v9 = 13288;
      }
    }
    else
    {
      __int16 v9 = 15360;
    }
    v15.i16[1] = 15360;
    v15.i32[1] = 1006648320;
    v15.i16[0] = v9;
    int16x4_t v16 = vzip1_s16(v15, v15);
    v16.i16[2] = v9;
    *((int16x4_t *)this + 510) = v16;
    if (*(float *)&dword_1EB2ACAF4 <= 0x384)
    {
      if (*(float *)&dword_1EB2ACAF4 >= 0x40)
      {
        float v18 = truncf(*(float *)&dword_1EB2ACAF4);
        goto LABEL_22;
      }
      int v17 = 1115684864;
    }
    else
    {
      int v17 = 1147207680;
    }
    float v18 = *(float *)&v17;
LABEL_22:
    float v3 = *((float *)this + 1028);
    float v5 = v3 + v18;
    float v4 = *((float *)this + 1029);
    float v6 = v4 + v18;
  }
  float v19 = v3 + -2.0;
  *((float *)this + 1028) = v19;
  float v20 = v4 + -2.0;
  *((float *)this + 1029) = v20;
  float v21 = v5 + 2.0;
  *((float *)this + 1030) = v21;
  float v22 = v6 + 2.0;
  *((_DWORD *)this + 1024) = (int)v19;
  *((_DWORD *)this + 1025) = (int)v20;
  *((float *)this + 1031) = v22;
  *((_DWORD *)this + 1026) = (int)(float)(v21 - v19);
  float result = v22 - v20;
  *((_DWORD *)this + 1027) = (int)result;
  return result;
}

void *CA::OGL::PerformanceHUD::update(CA::OGL::PerformanceHUD *this)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  uint64_t v89 = mach_absolute_time();
  unsigned int v2 = *((_DWORD *)this + 1034);
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  float v3 = (float)(*(float *)&dword_1EB2ACAF8 >> 16);
  float v4 = (float)(unsigned __int16)*(float *)&dword_1EB2ACAF8;
  *((void *)this + 505) = *((void *)this + 503);
  long long v5 = *((_OWORD *)this + 256);
  *(_OWORD *)((char *)this + 3976) = v5;
  *((void *)this + 507) = *((void *)this + 516);
  *((void *)this + 499) = *((void *)this + 514);
  CA::OGL::DebugRenderer::draw_rectangle_with_fill((uint64_t)this + 3976, (float *)this + 1030, *(double *)&v5);
  uint64_t v6 = 0;
  *((void *)this + 507) = *((void *)this + 509);
  float v87 = v3 + 360.0;
  unsigned int v7 = &CA::OGL::PerformanceHUD::_global_values;
  unsigned int v88 = v2;
  float v85 = v3;
  do
  {
    float v8 = (char *)this + 64 * v6;
    int v9 = *((_DWORD *)v8 + 203);
    if (v9 && ((v2 >> *((_DWORD *)v8 + 202)) & 1) != 0)
    {
      CFStringRef v10 = (char *)this + 64 * v6;
      CFStringRef v11 = (char *)this + 8 * v6;
      uint64_t v12 = (double *)(v11 + 384);
      if (v10[828]) {
        uint64_t v13 = (double *)v7 + v6;
      }
      else {
        uint64_t v13 = (double *)(v11 + 384);
      }
      double v14 = *v13;
      if (BYTE4(xmmword_1EB2ACC50) && v9 == 2)
      {
        float v81 = (unsigned __int8 *)(v10 + 828);
        *(void *)&double v14 = (uint64_t)((double)*(uint64_t *)&v14
                                  + (double)(CA::OGL::PerformanceHUD::get_prev_counter_value(this, v6) - *(void *)&v14)
                                  * 0.995);
        int v82 = *v81;
        unsigned int v2 = v88;
        if (v82) {
          float v83 = (double *)v7 + v6;
        }
        else {
          float v83 = v12;
        }
        *float v83 = v14;
      }
      if (initialized != -1) {
        dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
      }
      int16x4_t v15 = (CA::OGL::PerformanceHUD::CounterInfo *)(v8 + 768);
      int16x4_t v16 = (char *)this + 64 * v6;
      int v17 = *((_DWORD *)v16 + 206);
      if (v17 == 2
        || (v17 == 1) != *(void *)v15 < *(void *)&v14
        || (float)(*(float *)&CA::OGL::PerformanceHUD::_scale_ticks_to_ms
                 * (float)(v89 - *((void *)this + 8 * v6 + 97))) > *(float *)&dword_1EB2ACB00)
      {
        *(double *)int16x4_t v15 = v14;
        *((void *)v16 + 97) = v89;
      }
      float v18 = v8 + 812;
      float v19 = (char *)this + 64 * v6;
      float v20 = (void *)*((void *)v19 + 99);
      if (v20)
      {
        float v21 = v14;
        if (*v18 != 7) {
          float v21 = (float)*(uint64_t *)&v14;
        }
        float v22 = fminf(v21 / (float)*((uint64_t *)v19 + 98), 1.0);
        int v23 = (int)(float)(v22 * 255.0);
        if (v17) {
          unsigned __int8 v24 = 0;
        }
        else {
          unsigned __int8 v24 = (int)(float)(v22 * 255.0);
        }
        if (v17) {
          char v25 = 0;
        }
        else {
          char v25 = ~(_BYTE)v23;
        }
        if (v17 == 1)
        {
          unsigned __int8 v24 = ~(_BYTE)v23;
          char v25 = (int)(float)(v22 * 255.0);
        }
        _ZF = v17 == 2;
        if (v17 == 2) {
          unsigned __int8 v27 = 0;
        }
        else {
          unsigned __int8 v27 = v24;
        }
        if (!_ZF) {
          LOBYTE(v23) = v25;
        }
        *(float *)&_S1 = (float)v27 * 0.0039216;
        __asm { FCVT            H1, S1 }
        *(float *)&_S2 = (float)v23 * 0.0039216;
        __asm { FCVT            H2, S2 }
        uint64_t v33 = v20[1];
        *(float *)uint64_t v33 = v22;
        *(void *)(v33 + 8) = _S1 | ((unint64_t)_S2 << 16) | 0x3A06000000000000;
        unint64_t v34 = v20[2];
        unint64_t v35 = v20[1] + 16;
        v20[1] = v35;
        if (v35 >= v34) {
          v20[1] = *v20;
        }
      }
      uint64_t v36 = *((void *)this + 509);
      int v37 = *((_DWORD *)v19 + 204);
      switch(v37)
      {
        case 3:
          *(void *)__s = 0;
          uint64_t v91 = 0;
          uint64_t v45 = CA::OGL::PerformanceHUD::CounterInfo::to_string(v15, __s);
          *((float *)this + 998) = v3;
          *((float *)this + 999) = v4;
          int v46 = (char *)this + 64 * v6;
          float32x2_t v47 = (const char *)*((void *)v46 + 100);
          if (!v47) {
            goto LABEL_92;
          }
          uint64_t v48 = v45;
          float64x2_t v49 = v19 + 792;
          size_t v50 = strlen(*((const char **)v46 + 100));
          CA::OGL::DebugRenderer::draw_string((uint64_t)this + 3976, v47, v50);
          *((float *)this + 998) = v87 - (float)(unint64_t)(14 * v48);
          *((float *)this + 999) = v4;
          size_t v51 = strlen(__s);
          CA::OGL::DebugRenderer::draw_string((uint64_t)this + 3976, __s, v51);
          uint64_t v53 = (unint64_t *)*((void *)v19 + 99);
          if (!v53) {
            __assert_rtn("draw_graph2d", "ogl-performance-hud.cpp", 481, "_history");
          }
          float v54 = v4 + 50.0;
          unint64_t v55 = v53[1];
          float v56 = v3;
          if (v55 < v53[2])
          {
            do
            {
              LODWORD(v52) = *(_DWORD *)v55;
              *((float *)this + 998) = v56;
              float v56 = v56 + 6.0;
              BOOL v57 = *(float *)&v52 > 1.0 || *(float *)&v52 < 0.0;
              if (*(float *)&v52 < 0.0 && *(float *)&v52 <= 1.0) {
                float v58 = 0.0;
              }
              else {
                float v58 = 1.0;
              }
              if (v57) {
                *(float *)&double v52 = v58;
              }
              *(float *)&double v52 = v54 + (float)(*(float *)&v52 * -32.0);
              *(float *)__s = v56;
              *(_DWORD *)&__s[4] = LODWORD(v52);
              *((float *)this + 999) = v54;
              *((void *)this + 507) = *(void *)(v55 + 8);
              double v52 = CA::OGL::DebugRenderer::draw_rectangle_with_fill((uint64_t)this + 3976, (float *)__s, v52);
              uint64_t v53 = *(unint64_t **)v49;
              v55 += 16;
            }
            while (v55 < *(void *)(*(void *)v49 + 16));
            unint64_t v55 = v53[1];
          }
          unint64_t v59 = *v53;
          unsigned int v2 = v88;
          if (*v53 < v55)
          {
            do
            {
              LODWORD(v52) = *(_DWORD *)v59;
              BOOL v60 = *(float *)v59 > 1.0 || *(float *)v59 < 0.0;
              if (*(float *)v59 < 0.0 && *(float *)v59 <= 1.0) {
                float v61 = 0.0;
              }
              else {
                float v61 = 1.0;
              }
              if (v60) {
                *(float *)&double v52 = v61;
              }
              *(float *)&double v52 = v54 + (float)(*(float *)&v52 * -32.0);
              *(float *)__s = v56 + 6.0;
              *(_DWORD *)&__s[4] = LODWORD(v52);
              *((float *)this + 998) = v56;
              *((float *)this + 999) = v54;
              *((void *)this + 507) = *(void *)(v59 + 8);
              double v52 = CA::OGL::DebugRenderer::draw_rectangle_with_fill((uint64_t)this + 3976, (float *)__s, v52);
              v59 += 16;
              float v56 = v56 + 6.0;
            }
            while (v59 < *(void *)(*(void *)v49 + 8));
          }
          float v4 = v4 + 18.0;
          *((void *)this + 507) = v36;
          float v44 = 34.0;
          float v3 = v85;
          break;
        case 2:
          uint64_t v86 = *((void *)this + 509);
          float v62 = v7;
          *(void *)__s = 0;
          uint64_t v91 = 0;
          uint64_t v63 = CA::OGL::PerformanceHUD::CounterInfo::to_string(v15, __s);
          *((float *)this + 998) = v3;
          *((float *)this + 999) = v4;
          float v64 = (char *)this + 64 * v6;
          float v65 = (const char *)*((void *)v64 + 100);
          if (!v65) {
LABEL_92:
          }
            __assert_rtn("draw_string", "ogl-debug-renderer.h", 136, "text");
          uint64_t v66 = v63;
          size_t v67 = strlen(*((const char **)v64 + 100));
          CA::OGL::DebugRenderer::draw_string((uint64_t)this + 3976, v65, v67);
          *((float *)this + 998) = v87 - (float)(unint64_t)(14 * v66);
          *((float *)this + 999) = v4;
          size_t v68 = strlen(__s);
          CA::OGL::DebugRenderer::draw_string((uint64_t)this + 3976, __s, v68);
          if (*v18 == 7) {
            float v69 = *((double *)v19 + 102);
          }
          else {
            float v69 = (float)*(uint64_t *)v15;
          }
          unsigned int v7 = v62;
          unsigned int v2 = v88;
          float v70 = v69 / (float)*((uint64_t *)this + 8 * v6 + 98);
          float v71 = 1.0;
          if (v70 <= 1.0)
          {
            float v71 = 0.0;
            if (v70 >= 0.0) {
              float v71 = v70;
            }
          }
          float v4 = v4 + 18.0;
          *((float *)this + 998) = v3;
          *((float *)this + 999) = v4;
          int v72 = (int)(float)(v71 * 255.0);
          int v73 = *((_DWORD *)v16 + 206);
          if (v73) {
            unsigned __int8 v74 = 0;
          }
          else {
            unsigned __int8 v74 = (int)(float)(v71 * 255.0);
          }
          if (v73) {
            char v75 = 0;
          }
          else {
            char v75 = ~(_BYTE)v72;
          }
          if (v73 == 1)
          {
            unsigned __int8 v74 = ~(_BYTE)v72;
            char v75 = (int)(float)(v71 * 255.0);
          }
          BOOL v76 = v73 == 2;
          if (v73 == 2) {
            unsigned __int8 v77 = 0;
          }
          else {
            unsigned __int8 v77 = v74;
          }
          if (!v76) {
            LOBYTE(v72) = v75;
          }
          _S1 = (float)v77 * 0.0039216;
          __asm { FCVT            H1, S1 }
          _S2 = (float)v72 * 0.0039216;
          __asm { FCVT            H2, S2 }
          *((_WORD *)this + 2028) = LOWORD(_S1);
          *((_WORD *)this + 2029) = LOWORD(_S2);
          *((_DWORD *)this + 1015) = 973471744;
          float v80 = v71 * 360.0;
          CA::OGL::DebugRenderer::draw_bar((CA::OGL::PerformanceHUD *)((char *)this + 3976), v71 * 360.0);
          *((void *)this + 507) = 0x3A06000000000000;
          CA::OGL::DebugRenderer::draw_bar((CA::OGL::PerformanceHUD *)((char *)this + 3976), 360.0 - v80);
          *((void *)this + 507) = v86;
          float v44 = 18.0;
          break;
        case 1:
          *(void *)__s = 0;
          uint64_t v91 = 0;
          uint64_t v38 = CA::OGL::PerformanceHUD::CounterInfo::to_string(v15, __s);
          *((float *)this + 998) = v3;
          *((float *)this + 999) = v4;
          float v39 = (char *)this + 64 * v6;
          float v40 = (const char *)*((void *)v39 + 100);
          if (!v40) {
            goto LABEL_92;
          }
          uint64_t v41 = v38;
          size_t v42 = strlen(*((const char **)v39 + 100));
          CA::OGL::DebugRenderer::draw_string((uint64_t)this + 3976, v40, v42);
          *((float *)this + 998) = v87 - (float)(unint64_t)(14 * v41);
          *((float *)this + 999) = v4;
          size_t v43 = strlen(__s);
          CA::OGL::DebugRenderer::draw_string((uint64_t)this + 3976, __s, v43);
          float v44 = 18.0;
          unsigned int v2 = v88;
          break;
        default:
          goto LABEL_85;
      }
      float v4 = v4 + v44;
    }
LABEL_85:
    ++v6;
  }
  while (v6 != 48);
  memcpy(this, (char *)this + 384, 0x180uLL);
  float result = memcpy(&CA::OGL::PerformanceHUD::_prev_global_values, v7, 0x180uLL);
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 30) = 0u;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_OWORD *)this + 34) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *((_OWORD *)this + 40) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  *((_OWORD *)this + 47) = 0u;
  v7[22] = 0u;
  v7[23] = 0u;
  v7[20] = 0u;
  v7[21] = 0u;
  v7[18] = 0u;
  v7[19] = 0u;
  v7[16] = 0u;
  v7[17] = 0u;
  v7[14] = 0u;
  v7[15] = 0u;
  v7[12] = 0u;
  v7[13] = 0u;
  v7[10] = 0u;
  v7[11] = 0u;
  v7[8] = 0u;
  v7[9] = 0u;
  v7[6] = 0u;
  v7[7] = 0u;
  v7[4] = 0u;
  v7[5] = 0u;
  unint64_t v7[2] = 0u;
  v7[3] = 0u;
  long long *v7 = 0u;
  v7[1] = 0u;
  return result;
}

uint64_t CA::OGL::PerformanceHUD::get_prev_counter_value(CA::OGL::PerformanceHUD *this, unsigned int a2)
{
  if (a2 >= 0x30) {
    __assert_rtn("get_prev_counter_value", "ogl-performance-hud.cpp", 695, "index < _num_counters");
  }
  if (*((unsigned char *)this + 64 * (unint64_t)a2 + 828)) {
    unsigned int v2 = (CA::OGL::PerformanceHUD *)&CA::OGL::PerformanceHUD::_prev_global_values;
  }
  else {
    unsigned int v2 = this;
  }
  return *((void *)v2 + a2);
}

uint64_t CA::OGL::PerformanceHUD::CounterInfo::to_string(CA::OGL::PerformanceHUD::CounterInfo *this, char *__str)
{
  if (!__str) {
    __assert_rtn("to_string", "ogl-performance-hud.cpp", 235, "buffer");
  }
  int v3 = *((_DWORD *)this + 11) - 1;
  uint64_t result = 0;
  switch(v3)
  {
    case 0:
      return result;
    case 1:
      LODWORD(result) = snprintf(__str, 0x10uLL, "%.2fms");
      return (int)result;
    case 2:
      LODWORD(result) = snprintf(__str, 0x10uLL, "%lld");
      return (int)result;
    case 3:
      LODWORD(result) = snprintf(__str, 0x10uLL, "0x%llx");
      return (int)result;
    case 4:
      uint64_t v5 = *(void *)this;
      uint64_t v6 = 100 * *(void *)this / *((void *)this + 2);
      if (v5 && !v6) {
        LODWORD(result) = snprintf(__str, 0x10uLL, "<1%%");
      }
      else {
        LODWORD(result) = snprintf(__str, 0x10uLL, "%lld%%");
      }
      return (int)result;
    case 5:
      uint64_t v7 = *(void *)this;
      if (v7 >= 10000)
      {
        LODWORD(result) = snprintf(__str, 0x10uLL, "%.2fW");
        return (int)result;
      }
      if (v7)
      {
        LODWORD(result) = snprintf(__str, 0x10uLL, "%lldmW");
        return (int)result;
      }
      *(_DWORD *)__str = 5729584;
      return 3;
    case 6:
      LODWORD(result) = snprintf(__str, 0x10uLL, "%.*f");
      return (int)result;
    default:
      __assert_rtn("to_string", "ogl-performance-hud.cpp", 285, "0 && \"unsupported counter type!\"");
  }
}

unsigned int CA::OGL::PerformanceHUD::calculate_fps(CA::OGL::PerformanceHUD *this, double a2)
{
  uint64_t v3 = *((void *)this + 518);
  unint64_t v4 = CAHostTimeWithTime(a2);
  if (v3)
  {
    uint64_t v5 = CAGetStatsStruct(0)[5];
    double v6 = (double)(v5 - *((_DWORD *)this + 1038));
    float v7 = v6 / CATimeWithHostTime(v4 - v3);
    unsigned int result = vcvtas_u32_f32(v7);
    *((void *)this + 519) = v5;
  }
  else
  {
    unsigned int result = 0;
  }
  *((void *)this + 518) = v4;
  return result;
}

void CA::CG::DrawColorMatrix::draw_shape_and_color(CA::CG::DrawColorMatrix *this, CA::CG::Renderer *a2)
{
  __dst[61] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (int32x2_t *)*((void *)a2 + 1);
  float v5 = *((double *)a2 + 10);
  long long v52 = 0uLL;
  CA::Shape::get_bounds(*(void *)(*(void *)&v4[31] + 8), (int *)&v52);
  float v7 = (int32x2_t *)v4[33];
  if (v7) {
    float v8 = v7 + 4;
  }
  else {
    float v8 = v4 + 25;
  }
  int32x2_t v9 = *(int32x2_t *)((char *)&v52 + 8);
  uint32x2_t v10 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v52 + 8));
  if ((vpmax_u32(v10, v10).u32[0] & 0x80000000) == 0)
  {
    int32x2_t v11 = v8[1];
    uint32x2_t v12 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v11);
    if ((vpmax_u32(v12, v12).u32[0] & 0x80000000) != 0
      || (int32x2_t v13 = vadd_s32(*v8, v11),
          *(int32x2_t *)&long long v14 = vmax_s32(*(int32x2_t *)&v52, *v8),
          v9 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)&v52, *(int32x2_t *)((char *)&v52 + 8)), v13), *(int32x2_t *)&v14), uint32x2_t v15 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v9), (vpmax_u32(v15, v15).u32[0] & 0x80000000) != 0))
    {
      int32x2_t v9 = 0;
    }
    else
    {
      *((int32x2_t *)&v14 + 1) = v9;
      long long v52 = v14;
    }
  }
  int v16 = v9.i32[0];
  if (v9.i32[0] <= v9.i32[1]) {
    int v16 = v9.i32[1];
  }
  v17.i64[0] = v9.i32[0];
  v17.i64[1] = v9.i32[1];
  int32x2_t v18 = vdup_n_s32(v16 > 1073741822);
  int8x16_t v19 = (int8x16_t)vcvtq_f64_s64(v17);
  v17.i64[0] = v18.u32[0];
  v17.i64[1] = v18.u32[1];
  float64x2_t v20 = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v17, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v19);
  int8x16_t v21 = *((int8x16_t *)this + 8);
  int8x16_t v22 = *((int8x16_t *)this + 9);
  if (v5 != 1.0)
  {
    double v23 = v5;
    v6.f64[0] = 1.79769313e308;
    int8x16_t v24 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(v6, (float64x2_t)v22).i64[0], 0);
    v25.i64[1] = *((void *)this + 17);
    *(double *)v25.i64 = v5 * *(double *)v21.i64;
    int8x16_t v21 = vbslq_s8(v24, v25, v21);
    v25.i64[1] = *((void *)this + 19);
    *(double *)v25.i64 = v5 * *(double *)v22.i64;
    int8x16_t v22 = vbslq_s8(v24, v25, v22);
    if (*(double *)&v22.i64[1] < 1.79769313e308)
    {
      v21.i64[1] = vmuld_lane_f64(v23, (float64x2_t)v21, 1);
      *(double *)&v22.i64[1] = *(double *)&v22.i64[1] * v23;
    }
  }
  int8x16_t v26 = (int8x16_t)vclezq_f64(v20);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v26, 1), v26).u64[0] & 0x8000000000000000) == 0)
  {
    int8x16_t v27 = (int8x16_t)vclezq_f64((float64x2_t)v22);
    int32x4_t v28 = (int32x4_t)vdupq_laneq_s64((int64x2_t)v27, 1);
    int32x4_t v29 = (int32x4_t)vorrq_s8((int8x16_t)v28, v27);
    if ((v29.i64[0] & 0x8000000000000000) == 0)
    {
      v29.i32[0] = v16;
      v28.i32[0] = 1073741822;
      v30.i64[0] = (int)v52;
      v30.i64[1] = SDWORD1(v52);
      float64x2_t v31 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v29, v28), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v30));
      float64x2_t v32 = vaddq_f64(v31, v20);
      float64x2_t v33 = vmaxnmq_f64(v31, (float64x2_t)v21);
      float64x2_t v34 = vminnmq_f64(v32, vaddq_f64((float64x2_t)v21, (float64x2_t)v22));
      float64x2_t v35 = vsubq_f64(v34, v33);
      int8x16_t v36 = (int8x16_t)vclezq_f64(v35);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v36, 1), v36).u64[0] & 0x8000000000000000) == 0)
      {
        int8x16_t v37 = (int8x16_t)vceqzq_f64(v35);
        if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v37, 1), v37).u64[0] & 0x8000000000000000) != 0
          || (int8x16_t v38 = vorrq_s8((int8x16_t)vcltzq_f64(v35), (int8x16_t)vcgezq_f64(v35)),
              (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v38), 1), v38).u64[0] & 0x8000000000000000) != 0))
        {
          int32x4_t v51 = 0uLL;
        }
        else
        {
          int32x4_t v39 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v33, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
          int32x4_t v51 = vuzp1q_s32(v39, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(v34, (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v39));
        }
        uint64_t v40 = (*(uint64_t (**)(int32x2_t *, uint64_t, int32x4_t *, uint64_t))(*(void *)v4 + 656))(v4, 1, &v51, 8207);
        if (v40)
        {
          uint64_t v41 = v40;
          uint64_t v42 = *((void *)a2 + 1);
          long long v53 = *(_OWORD *)(v40 + 32);
          unsigned int v43 = *(unsigned __int16 *)(v42 + 832);
          __int16 v44 = v43 & 0x7000;
          if ((v43 & 0x7000) == 0x3000)
          {
            unsigned int v43 = v43 & 0xFFFF8FFF | 0x2000;
            *(_WORD *)(v42 + 832) = v43;
          }
          unsigned int v45 = v43 >> 12;
          if ((v45 & 4) != 0) {
            char v46 = 0;
          }
          else {
            char v46 = 0x1E1F1400u >> (8 * (v45 & 7));
          }
          *(unsigned char *)(v40 + 73) = *(unsigned char *)(v40 + 73) & 0xC0 | v46;
          float32x2_t v47 = *(const void **)(v42 + 16);
          memcpy(__dst, v47, 0x1E8uLL);
          __dst[0] = v47;
          *(void *)(v42 + 16) = __dst;
          uint64_t v56 = 0;
          memset(&v55[2], 0, 32);
          memset(v55, 0, 32);
          uint64_t v48 = *(void *)(v42 + 248);
          *(_OWORD *)((char *)v55 + 8) = *(_OWORD *)(v48 + 8);
          uint64_t v49 = *(void *)(v48 + 32);
          *((void *)&v55[1] + 1) = *(void *)(v48 + 24);
          *(void *)&v55[2] = v49;
          *(_OWORD *)((char *)&v55[2] + 8) = *(_OWORD *)(v48 + 40);
          *((void *)&v55[3] + 1) = *(void *)(v48 + 56);
          __int16 v50 = *(_WORD *)(v48 + 68);
          LODWORD(v56) = *(_DWORD *)(v48 + 64);
          HIDWORD(v56) = v50 & 0x5FF;
          memset(v54, 0, sizeof(v54));
          CA::Shape::operator=((uint64_t)v54, &v53);
          *((void *)&v55[0] + 1) = v54;
          *(void *)&v55[0] = CA::OGL::Context::set_gstate(v42, (uint64_t)v55);
          CA::OGL::Context::push_surface(v42, v41, 1u, 64, 0);
          CA::CG::DrawOp::render(*((CA::CG::DrawOp **)this + 14), (float64x2_t *)a2);
          CA::OGL::Context::pop_surface((CA::OGL::Context *)v42);
          CA::OGL::Context::set_gstate(v42, **(void **)(v42 + 248));
          *(void *)(v42 + 16) = __dst[0];
          __dst[0] = 0;
          *(_WORD *)(v42 + 832) = *(_WORD *)(v42 + 832) & 0x8FFF | v44;
          CA::OGL::emit_color_matrix((CA::OGL *)v42, (float32x4_t *)(*((void *)this + 15) + 76), v41, 0, 1.0);
          if (__dst[0]) {
            __assert_rtn("~ContextState", "ogl-context.h", 551, "!next && \"Imbalanced ContextState push/pop\"");
          }
          CA::OGL::Context::release_surface((uint64_t)v4, v41);
        }
      }
    }
  }
}

uint64_t CA::CG::DrawColorMatrix::draw_shape(CA::CG::DrawColorMatrix *this, CA::CG::Renderer *a2)
{
  return (*(uint64_t (**)(CA::CG::DrawColorMatrix *, CA::CG::Renderer *))(*(void *)this + 176))(this, a2);
}

uint64_t CA::CG::DrawColorMatrix::color_type(CA::CG::DrawColorMatrix *this, CA::CG::Renderer *a2)
{
  return 0;
}

uint64_t CA::CG::DrawColorMatrix::set_op(uint64_t this, CA::CG::DrawOp *a2)
{
  uint64_t v2 = *(void *)(this + 112);
  if (v2) {
    *(void *)(v2 + 104) = 0;
  }
  *(void *)(this + 112) = a2;
  return this;
}

__n128 CA::CG::DrawColorMatrix::compute_dod(CA::CG::DrawColorMatrix *this, __n128 *a2)
{
  (*(void (**)(void, char *))(**((void **)this + 14) + 24))(*((void *)this + 14), (char *)this + 128);
  *a2 = *((__n128 *)this + 8);
  __n128 result = *((__n128 *)this + 9);
  a2[1] = result;
  return result;
}

void CA::CG::DrawColorMatrix::~DrawColorMatrix(CA::CG::DrawColorMatrix *this)
{
  *(void *)this = &unk_1ED028848;
  uint64_t v2 = (atomic_uint *)*((void *)this + 15);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  CA::CG::DrawOp::~DrawOp(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v2;
  uint64_t vars8;

  *(void *)this = &unk_1ED028848;
  uint64_t v2 = (atomic_uint *)*((void *)this + 15);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }

  CA::CG::DrawOp::~DrawOp(this);
}

void CA::CG::DrawColorMatrixTransparencyLayer::draw_shape_and_color(int8x16_t *this, CA::CG::Renderer *a2, double a3, double a4, double a5, double a6, double a7, float64x2_t a8)
{
  uint64_t v8 = *(void *)(this[10].i64[0] + 40);
  if (v8)
  {
    uint64_t v9 = *(void *)(v8 + 40);
    v10.i64[0] = (int)v9;
    v10.i64[1] = SHIDWORD(v9);
    int64x2_t v11 = v10;
    int v12 = v9;
    if ((int)v9 <= SHIDWORD(v9)) {
      int v12 = HIDWORD(*(void *)(v8 + 40));
    }
    int8x16_t v13 = (int8x16_t)vcvtq_f64_s64(v11);
    int32x2_t v14 = vdup_n_s32(v12 > 1073741822);
    v15.i64[0] = v14.u32[0];
    v15.i64[1] = v14.u32[1];
    float64x2_t v16 = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v15, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v13);
    float v17 = *((double *)a2 + 10);
    int8x16_t v18 = this[8];
    int8x16_t v19 = this[9];
    if (v17 != 1.0)
    {
      double v20 = v17;
      a8.f64[0] = 1.79769313e308;
      int8x16_t v21 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a8, (float64x2_t)v19).i64[0], 0);
      v22.i64[1] = this[8].i64[1];
      *(double *)v22.i64 = v20 * *(double *)v18.i64;
      int8x16_t v18 = vbslq_s8(v21, v22, v18);
      v22.i64[1] = this[9].i64[1];
      *(double *)v22.i64 = v20 * *(double *)v19.i64;
      int8x16_t v19 = vbslq_s8(v21, v22, v19);
      if (*(double *)&v19.i64[1] < 1.79769313e308)
      {
        a8.f64[0] = vmuld_lane_f64(v20, (float64x2_t)v18, 1);
        v18.i64[1] = *(void *)&a8.f64[0];
        *(double *)&v19.i64[1] = *(double *)&v19.i64[1] * v20;
      }
    }
    int8x16_t v23 = (int8x16_t)vclezq_f64(v16);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v23, 1), v23).u64[0] & 0x8000000000000000) == 0)
    {
      int8x16_t v24 = (int8x16_t)vclezq_f64((float64x2_t)v19);
      int32x4_t v25 = (int32x4_t)vdupq_laneq_s64((int64x2_t)v24, 1);
      if ((vorrq_s8((int8x16_t)v25, v24).u64[0] & 0x8000000000000000) == 0)
      {
        uint64_t v26 = *(void *)(v8 + 32);
        v25.i32[0] = v12;
        LODWORD(a8.f64[0]) = 1073741822;
        v27.i64[0] = (int)v26;
        v27.i64[1] = SHIDWORD(v26);
        float64x2_t v28 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v25, (int32x4_t)a8), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v27));
        int8x16_t v29 = (int8x16_t)vclezq_f64(vsubq_f64(vminnmq_f64(vaddq_f64(v28, v16), vaddq_f64((float64x2_t)v18, (float64x2_t)v19)), vmaxnmq_f64(v28, (float64x2_t)v18)));
        if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v29, 1), v29).u64[0] & 0x8000000000000000) == 0) {
          CA::OGL::emit_color_matrix(*((CA::OGL **)a2 + 1), (float32x4_t *)(this[7].i64[1] + 76), v8, 0, 1.0);
        }
      }
    }
  }
  else
  {
    CA::CG::DrawColorMatrix::draw_shape_and_color((CA::CG::DrawColorMatrix *)this, a2);
  }
}

void CA::CG::DrawColorMatrixTransparencyLayer::~DrawColorMatrixTransparencyLayer(CA::CG::DrawColorMatrixTransparencyLayer *this)
{
  *(void *)this = &unk_1ED029B60;
  uint64_t v2 = (atomic_uint *)*((void *)this + 20);
  if (v2) {
    CA::CG::TransparencyLayer::unref(v2);
  }
  *(void *)this = &unk_1ED028848;
  uint64_t v3 = (atomic_uint *)*((void *)this + 15);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 8))(v3);
  }
  CA::CG::DrawOp::~DrawOp(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v2;
  atomic_uint *v3;
  uint64_t vars8;

  *(void *)this = &unk_1ED029B60;
  uint64_t v2 = (atomic_uint *)*((void *)this + 20);
  if (v2) {
    CA::CG::TransparencyLayer::unref(v2);
  }
  *(void *)this = &unk_1ED028848;
  uint64_t v3 = (atomic_uint *)*((void *)this + 15);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 8))(v3);
  }

  CA::CG::DrawOp::~DrawOp(this);
}

uint64_t CA::OGL::ExtendedColor::word32(CA::OGL::ExtendedColor *this)
{
  _H0 = *(_WORD *)this;
  __asm { FCVT            S0, H0 }
  float v7 = (float)(_S0 * 255.0) + 0.5;
  BOOL v8 = v7 > 255.0 || v7 < 0.0;
  if (v7 < 0.0 && v7 <= 255.0) {
    int v9 = 0;
  }
  else {
    int v9 = 255;
  }
  if (!v8) {
    int v9 = (int)v7;
  }
  _H0 = *((_WORD *)this + 1);
  __asm { FCVT            S0, H0 }
  float v12 = (float)(_S0 * 255.0) + 0.5;
  BOOL v13 = v12 > 255.0 || v12 < 0.0;
  if (v12 < 0.0 && v12 <= 255.0) {
    int v14 = 0;
  }
  else {
    int v14 = 65280;
  }
  if (!v13) {
    int v14 = (int)v12 << 8;
  }
  _H0 = *((_WORD *)this + 2);
  __asm { FCVT            S0, H0 }
  float v17 = (float)(_S0 * 255.0) + 0.5;
  BOOL v18 = v17 > 255.0 || v17 < 0.0;
  if (v17 < 0.0 && v17 <= 255.0) {
    int v19 = 0;
  }
  else {
    int v19 = 16711680;
  }
  if (!v18) {
    int v19 = (int)v17 << 16;
  }
  _H0 = *((_WORD *)this + 3);
  __asm { FCVT            S0, H0 }
  float v22 = (float)(_S0 * 255.0) + 0.5;
  BOOL v23 = v22 > 255.0 || v22 < 0.0;
  if (v22 < 0.0 && v22 <= 255.0) {
    int v24 = 0;
  }
  else {
    int v24 = -16777216;
  }
  if (!v23) {
    int v24 = (int)v22 << 24;
  }
  return v14 | v9 | v19 | v24;
}

BOOL CA::Render::MatchAnimation::validate(CA::Render::MatchAnimation *this, CA::Render::Layer *a2)
{
  if (!*((void *)this + 13)) {
    return 0;
  }
  if (!*((_DWORD *)this + 28)) {
    return 0;
  }
  uint64_t v2 = (_DWORD *)*((void *)this + 15);
  if (!v2) {
    return 0;
  }
  if (v2) {
    return 1;
  }
  return *v2 != 0;
}

int8x16_t CA::Render::MatchPropertyAnimation::create_dependence(int8x16_t *this, CA::Render::Handle *a2)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  float v5 = (int8x16_t *)malloc_type_zone_malloc(malloc_zone, 0x38uLL, 0x8BB15036uLL);
  if (v5)
  {
    __int32 v7 = *(_DWORD *)(*((void *)a2 + 3) + 16);
    v5->i32[2] = this[7].i32[0];
    v5->i32[3] = v7;
    int8x16_t result = vextq_s8(this[6], this[6], 8uLL);
    v5[1] = result;
    v5[2].i64[0] = 0;
    v5[2].i64[1] = 0;
    v5[3].i64[0] = (uint64_t)this;
    v5->i64[0] = (uint64_t)&unk_1ED02F070;
  }
  return result;
}

void CA::Render::MatchPropertyDependence::~MatchPropertyDependence(CA::Render::MatchPropertyDependence *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::Render::MatchPropertyAnimation::show(CA::Render::MatchPropertyAnimation *this, int a2, int a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  BOOL v6 = x_log_hook_p();
  if (a3)
  {
    if (v6)
    {
      x_log_();
    }
    else
    {
      BOOL v8 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v13 = 0;
        int v9 = "match-property-animation;";
        int64x2_t v10 = (uint8_t *)&v13;
        goto LABEL_10;
      }
    }
  }
  else
  {
    if (v6)
    {
      x_log_();
    }
    else
    {
      __int32 v7 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_DEFAULT, "(match-property-animation", buf, 2u);
      }
    }
    CA::Render::MatchAnimation::show_match_animation(this, a2, a3);
    if (x_log_hook_p())
    {
      x_log_();
      return;
    }
    BOOL v8 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v11 = 0;
      int v9 = ")";
      int64x2_t v10 = (uint8_t *)&v11;
LABEL_10:
      _os_log_impl(&dword_184668000, v8, OS_LOG_TYPE_DEFAULT, v9, v10, 2u);
    }
  }
}