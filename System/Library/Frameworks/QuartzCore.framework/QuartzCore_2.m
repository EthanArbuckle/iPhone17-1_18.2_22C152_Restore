void sub_184752DB8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned int,CA::Render::Fence::Transaction::Info *>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Fence::Transaction::Info *>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,CA::Render::Fence::Transaction::Info *>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,CA::Render::Fence::Transaction::Info *>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(float *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *((void *)a1 + 1);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  v10 = operator new(0x20uLL);
  void *v10 = 0;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  v10[3] = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (v6 && (float)(v13 * (float)v6) >= v12)
  {
    unint64_t v5 = v8;
    goto LABEL_64;
  }
  BOOL v14 = 1;
  if (v6 >= 3) {
    BOOL v14 = (v6 & (v6 - 1)) != 0;
  }
  unint64_t v15 = v14 | (2 * v6);
  unint64_t v16 = vcvtps_u32_f32(v12 / v13);
  if (v15 <= v16) {
    int8x8_t prime = (int8x8_t)v16;
  }
  else {
    int8x8_t prime = (int8x8_t)v15;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v6 = *((void *)a1 + 1);
  }
  if (*(void *)&prime <= v6)
  {
    if (*(void *)&prime >= v6) {
      goto LABEL_60;
    }
    unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v6 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
    {
      unint64_t v24 = std::__next_prime(v24);
    }
    else
    {
      uint64_t v26 = 1 << -(char)__clz(v24 - 1);
      if (v24 >= 2) {
        unint64_t v24 = v26;
      }
    }
    if (*(void *)&prime <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    if (*(void *)&prime >= v6)
    {
      unint64_t v6 = *((void *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      v33 = *(void **)a1;
      *(void *)a1 = 0;
      if (v33) {
        operator delete(v33);
      }
      unint64_t v6 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  v18 = operator new(8 * *(void *)&prime);
  v19 = *(void **)a1;
  *(void *)a1 = v18;
  if (v19) {
    operator delete(v19);
  }
  uint64_t v20 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v20++) = 0;
  while (*(void *)&prime != v20);
  v21 = (void *)*((void *)a1 + 2);
  if (v21)
  {
    unint64_t v22 = v21[1];
    uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
    v23.i16[0] = vaddlv_u8(v23);
    if (v23.u32[0] > 1uLL)
    {
      if (v22 >= *(void *)&prime) {
        v22 %= *(void *)&prime;
      }
    }
    else
    {
      v22 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
    v27 = (void *)*v21;
    if (*v21)
    {
      do
      {
        unint64_t v28 = v27[1];
        if (v23.u32[0] > 1uLL)
        {
          if (v28 >= *(void *)&prime) {
            v28 %= *(void *)&prime;
          }
        }
        else
        {
          v28 &= *(void *)&prime - 1;
        }
        if (v28 != v22)
        {
          if (!*(void *)(*(void *)a1 + 8 * v28))
          {
            *(void *)(*(void *)a1 + 8 * v28) = v21;
            goto LABEL_56;
          }
          void *v21 = *v27;
          void *v27 = **(void **)(*(void *)a1 + 8 * v28);
          **(void **)(*(void *)a1 + 8 * v28) = v27;
          v27 = v21;
        }
        unint64_t v28 = v22;
LABEL_56:
        v21 = v27;
        v27 = (void *)*v27;
        unint64_t v22 = v28;
      }
      while (v27);
    }
  }
  unint64_t v6 = (unint64_t)prime;
LABEL_60:
  if ((v6 & (v6 - 1)) != 0)
  {
    if (v6 <= v5) {
      v5 %= v6;
    }
  }
  else
  {
    unint64_t v5 = (v6 - 1) & v5;
  }
LABEL_64:
  v29 = *(void **)a1;
  v30 = *(void **)(*(void *)a1 + 8 * v5);
  if (v30)
  {
    void *v10 = *v30;
LABEL_72:
    void *v30 = v10;
    goto LABEL_73;
  }
  void *v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v5] = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v31 >= v6) {
        v31 %= v6;
      }
    }
    else
    {
      v31 &= v6 - 1;
    }
    v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1847531B0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::work_around_59853502(CA *this)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  memset(v2, 0, sizeof(v2));
  return memset_s(v2, 0x100uLL, 0, 0x100uLL);
}

void CA::Display::DisplayLink::dispatch_deferred_display_links(CA::Display::DisplayLink *this)
{
  int v1 = (int)this;
  v15[1] = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Display::DisplayLink::_list_lock);
  uint64_t v3 = CA::Display::DisplayLink::_list;
  if (CA::Display::DisplayLink::_list)
  {
    uint64_t v4 = 0;
    uint64_t v5 = CA::Display::DisplayLink::_list;
    do
    {
      if (*(unsigned char *)(v5 + 200) && (v1 == -1 || *(_DWORD *)(*(void *)(v5 + 8) + 104) == v1)) {
        ++v4;
      }
      uint64_t v5 = *(void *)(v5 + 48);
    }
    while (v5);
    if (v4)
    {
      size_t v6 = 8 * v4;
      if ((unint64_t)(8 * v4) > 0x1000)
      {
        uint8x8_t v7 = (uint64_t *)malloc_type_malloc(8 * v4, 0xEBF604EDuLL);
        uint64_t v3 = CA::Display::DisplayLink::_list;
        if (CA::Display::DisplayLink::_list)
        {
LABEL_11:
          uint64_t v8 = 0;
          do
          {
            if (*(unsigned char *)(v3 + 200) && (v1 == -1 || *(_DWORD *)(*(void *)(v3 + 8) + 104) == v1))
            {
              while (1)
              {
                int v9 = *(_DWORD *)(v3 + 40);
                if (!v9) {
                  break;
                }
                int v10 = *(_DWORD *)(v3 + 40);
                atomic_compare_exchange_strong((atomic_uint *volatile)(v3 + 40), (unsigned int *)&v10, v9 + 1);
                if (v10 == v9)
                {
                  v7[v8++] = v3;
                  break;
                }
              }
            }
            uint64_t v3 = *(void *)(v3 + 48);
          }
          while (v3);
          os_unfair_lock_unlock((os_unfair_lock_t)&CA::Display::DisplayLink::_list_lock);
          if (v8)
          {
            unint64_t v11 = v7;
            uint64_t v12 = v8;
            do
            {
              uint64_t v13 = *v11++;
              CA::Display::DisplayLink::callback(*(void *)(v13 + 208), *(void *)(v13 + 216), *(void *)(v13 + 224), 0, v13);
              --v12;
            }
            while (v12);
            BOOL v14 = (atomic_uint **)v7;
            do
            {
              if (*v14) {
                CA::Display::DisplayLink::unref(*v14);
              }
              ++v14;
              --v8;
            }
            while (v8);
          }
          goto LABEL_32;
        }
      }
      else
      {
        MEMORY[0x1F4188790](v2);
        uint8x8_t v7 = (void *)((char *)v15 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
        bzero(v7, v6);
        if (v3) {
          goto LABEL_11;
        }
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Display::DisplayLink::_list_lock);
LABEL_32:
      if (v6 > 0x1000) {
        free(v7);
      }
      return;
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Display::DisplayLink::_list_lock);
}

void sub_1847537EC(_Unwind_Exception *a1)
{
}

void CA::Display::DisplayLink::dispatch_items(CA::Display::DisplayLink *this, unint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v61 = a3;
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint8x8_t v7 = (void *)MEMORY[0x185324A30]();
  double v64 = 1.79769313e308;
  while (1)
  {
    int v8 = *((_DWORD *)this + 10);
    if (!v8) {
      break;
    }
    int v9 = *((_DWORD *)this + 10);
    atomic_compare_exchange_strong((atomic_uint *volatile)this + 10, (unsigned int *)&v9, v8 + 1);
    if (v9 == v8)
    {
      int v10 = (atomic_uint *)this;
      goto LABEL_6;
    }
  }
  int v10 = 0;
LABEL_6:
  unint64_t v11 = (pthread_mutex_t *)((char *)this + 56);
  uint64_t v12 = pthread_mutex_lock((pthread_mutex_t *)((char *)this + 56));
  uint64_t v14 = *((void *)this + 15);
  uint64_t v13 = *((void *)this + 16);
  uint64_t v15 = v13 - v14;
  if (v13 == v14)
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 56));
  }
  else
  {
    v59 = v10;
    unint64_t v56 = 2 * v15;
    if ((unint64_t)(2 * v15) > 0x1000)
    {
      unint64_t v16 = (char *)malloc_type_malloc(2 * v15, 0xD720607uLL);
    }
    else
    {
      MEMORY[0x1F4188790](v12);
      unint64_t v16 = (char *)&v55 - ((2 * v15 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v16, 2 * v15);
    }
    uint64_t v17 = 0;
    if ((unint64_t)(v15 >> 3) <= 1) {
      uint64_t v18 = 1;
    }
    else {
      uint64_t v18 = v15 >> 3;
    }
    v19 = v16 + 8;
    do
    {
      uint64_t v20 = *(void *)(*((void *)this + 15) + 8 * v17);
      *((void *)v19 - 1) = v20;
      unsigned char *v19 = 0;
      CFRetain(*(CFTypeRef *)(v20 + 256));
      ++v17;
      v19 += 16;
    }
    while (v18 != v17);
    v57 = (pthread_mutex_t *)((char *)this + 56);
    v58 = v7;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 56));
    double v21 = v64;
    v60 = v16;
    unint64_t v22 = v16 + 8;
    uint64_t v23 = v18;
    do
    {
      uint64_t v24 = *((void *)v22 - 1);
      pthread_mutex_lock((pthread_mutex_t *)(v24 + 136));
      if (*(CA::Display::DisplayLink **)(v24 + 264) == this)
      {
        uint64_t v25 = *(void *)(v24 + 280);
        unint64_t v26 = *(int *)(v24 + 56);
        unint64_t v27 = *(int *)(v24 + 60);
        *(_DWORD *)(v24 + 60) = 0;
        if ((*(unsigned char *)(v24 + 316) & 1) == 0
          && (!(a2 % v26) || v27 && !(a2 % v27) || (double)(v26 * a4) * 1.485 <= (double)(v61 - v25)))
        {
          *(void *)(v24 + 248) = pthread_self();
          *(void *)(v24 + 296) = a4;
          *(void *)(v24 + 280) = v61;
          uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 24))(v24);
          unint64_t v29 = v28 + v61;
          *(void *)(v24 + 288) = v29;
          uint64_t v30 = *((void *)this + 1);
          if (*(unsigned char *)(v30 + 697)) {
            unsigned int v31 = 2;
          }
          else {
            unsigned int v31 = 1;
          }
          if (v31 <= *(_DWORD *)(v30 + 520)) {
            unsigned int v31 = *(_DWORD *)(v30 + 520);
          }
          LODWORD(v30) = *(_DWORD *)(v30 + 552);
          if (v31 <= v30) {
            uint64_t v30 = v30;
          }
          else {
            uint64_t v30 = v31;
          }
          *(void *)(v24 + 304) = v30 * a4;
          *unint64_t v22 = 1;
          double v32 = CATimeWithHostTime(v29);
          if (v21 >= v32) {
            double v21 = v32;
          }
        }
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v24 + 136));
      v22 += 16;
      --v23;
    }
    while (v23);
    double v64 = v21;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v33 = v60;
    do
    {
      if (v33[8])
      {
        uint64_t v34 = *(void *)v33;
        double v35 = CATimeWithHostTime(*(void *)(*(void *)v33 + 280));
        uint64_t v36 = mach_absolute_time();
        double v37 = CATimeWithHostTime(v36);
        double v38 = CATimeWithHostTime(*(void *)(v34 + 288));
        v39 = *(uint64_t **)(StatusReg + 576);
        if (v39) {
          int started = CA::Transaction::start_frame(v39[13], 4, v35, v37, v38);
        }
        else {
          int started = 0;
        }
        if (!*(_DWORD *)(v34 + 312))
        {
          uint64_t v66 = BYTE9(xmmword_1EB2ACC10);
          if (BYTE9(xmmword_1EB2ACC10)) {
            kdebug_trace();
          }
          memset(v65, 0, sizeof(v65));
          (*(void (**)(uint64_t, _OWORD *))(*(void *)v34 + 48))(v34, v65);
          if ((_BYTE)v66) {
            kdebug_trace();
          }
        }
        if (!started)
        {
          v39 = *(uint64_t **)(StatusReg + 576);
          if (v39 && (v41 = (_DWORD *)v39[13], *v41)) {
            int started = CA::Transaction::start_frame((uint64_t)v41, 4, v35, v37, v38);
          }
          else {
            int started = 0;
          }
        }
        pthread_mutex_lock((pthread_mutex_t *)(v34 + 136));
        *(void *)(v34 + 248) = 0;
        pthread_cond_broadcast((pthread_cond_t *)(v34 + 200));
        char v42 = *(unsigned char *)(v34 + 316);
        int v43 = (*(uint64_t (**)(uint64_t))(*(void *)v34 + 32))(v34);
        if (*(unsigned char *)(v34 + 129)) {
          CA::Display::DisplayLinkItem::run_deferred_unregister_frame_interval_range((CA::Display::DisplayLinkItem *)v34);
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v34 + 136));
        if (v43 | ((v42 & 2) >> 1))
        {
          Current = CFRunLoopGetCurrent();
          CA::Display::DisplayLinkItem::update_link((CA::Display::DisplayLinkItem *)v34, Current);
        }
        if (started) {
          CA::Transaction::finish_frame((CA::Transaction *)v39);
        }
      }
      CFRelease(*(CFTypeRef *)(*(void *)v33 + 256));
      v33 += 16;
      --v18;
    }
    while (v18);
    uint8x8_t v7 = v58;
    int v10 = v59;
    unint64_t v11 = v57;
    if (v60 && v56 > 0x1000) {
      free(v60);
    }
  }
  pthread_mutex_lock(v11);
  if (*((_DWORD *)this + 36) == (uint64_t)(*((void *)this + 16) - *((void *)this + 15)) >> 3)
  {
    int v45 = *((_DWORD *)this + 37);
    if (!v45 || (int v46 = v45 - 1, (*((_DWORD *)this + 37) = v46) == 0)) {
      CA::Display::DisplayLink::pause_timer_locked((uint64_t)this);
    }
  }
  pthread_mutex_unlock(v11);
  unint64_t v47 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v48 = *(void *)(v47 + 576);
  if (v48)
  {
    if (CADeviceUseVBL::once[0] != -1) {
      dispatch_once(CADeviceUseVBL::once, &__block_literal_global_17);
    }
    if (!CADeviceUseVBL::use_vbl)
    {
      double v49 = v64;
      if (**(_DWORD **)(v48 + 104) && v64 != 1.79769313e308)
      {
        *(void *)&v65[0] = 0;
        if ((CA::Transaction::get_value(*(void *)(v48 + 88), 193, (const CGAffineTransform *)0x12, (CA::Mat4Impl *)v65) & 1) == 0)
        {
          double v51 = CATimeWithHostTime(v61) + 0.001;
          *(double *)v65 = v51;
          uint64_t v52 = mach_absolute_time();
          if (v51 > CATimeWithHostTime(v52)) {
            CA::Transaction::set_value((CA::Transaction *)v48, (const void *)0xC1, 18, (unsigned __int8 *)v65);
          }
        }
        double v63 = 0.0;
        if (CA::Transaction::get_value(*(void *)(v48 + 88), 579, (const CGAffineTransform *)0x12, (CA::Mat4Impl *)&v63))
        {
          double v53 = v63;
          if (v49 < v63) {
            double v53 = v49;
          }
          double v64 = v53;
        }
        CA::Transaction::set_value((CA::Transaction *)v48, (const void *)0x243, 18, (unsigned __int8 *)&v64);
      }
    }
  }
  if (v10) {
    CA::Display::DisplayLink::unref(v10);
  }
  if ((CA::Transaction::_update_cycle_support_enabled & 1) == 0)
  {
    v54 = *(CA::Transaction **)(v47 + 576);
    if (v54)
    {
      if (**((_DWORD **)v54 + 13)) {
        CA::Transaction::flush(v54);
      }
    }
  }
}

void sub_184753EDC(_Unwind_Exception *a1)
{
  objc_end_catch();
  uint64_t v3 = *(void **)(v1 - 232);
  if (*(void *)(v1 - 224)) {
    CA::Display::DisplayLink::unref(*(atomic_uint **)(v1 - 224));
  }
  _Unwind_Resume(a1);
}

void sub_184753EE8()
{
}

void sub_184753EF4()
{
}

void sub_184753EFC()
{
  pthread_mutex_unlock(v0);
  JUMPOUT(0x184753F38);
}

void sub_184753F20(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  uint64_t v4 = *(void **)(v2 - 232);
  if (*(void *)(v2 - 224)) {
    CA::Display::DisplayLink::unref(*(atomic_uint **)(v2 - 224));
  }
  _Unwind_Resume(a1);
}

uint64_t CA::Transaction::start_frame(uint64_t a1, int a2, double a3, double a4, double a5)
{
  int v6 = *(_DWORD *)(a1 + 160);
  int v7 = *(_DWORD *)(a1 + 164) + 1;
  *(_DWORD *)(a1 + 160) = v6 + 1;
  *(_DWORD *)(a1 + 164) = v7;
  double v8 = *(double *)(a1 + 168);
  if (v6 && v8 == 0.0) {
    __assert_rtn("start_frame", "CATransactionInternal.mm", 2019, "!nested || s->_frame_commit_deadline != 0");
  }
  if (v8 == 0.0 || v8 > a5) {
    *(double *)(a1 + 168) = a5;
  }
  double v10 = *(double *)(a1 + 176);
  if (v6 && v10 == 0.0) {
    __assert_rtn("start_frame", "CATransactionInternal.mm", 2022, "!nested || s->_frame_begin_time != 0");
  }
  if (v10 == 0.0 || v10 > a3) {
    *(double *)(a1 + 176) = a3;
  }
  double v12 = *(double *)(a1 + 184);
  if (v6)
  {
    if (v12 == 0.0) {
      __assert_rtn("start_frame", "CATransactionInternal.mm", 2025, "!nested || s->_frame_start_time != 0");
    }
  }
  else if (v12 == 0.0)
  {
    *(double *)(a1 + 184) = a4;
  }
  uint64_t v13 = a2 | (v7 << 8);
  if ((*(unsigned char *)(a1 + 204) & 0x20) == 0)
  {
    CAHostTimeWithTime(a3);
    CAHostTimeWithTime(a5);
    kdebug_trace();
  }
  return v13;
}

double CA::Transaction::finish_frame(CA::Transaction *this)
{
  uint64_t v1 = *((void *)this + 13);
  int v2 = *(_DWORD *)(v1 + 160);
  if (!v2) {
    __assert_rtn("finish_frame", "CATransactionInternal.mm", 2042, "s->_frame_depth");
  }
  int v4 = v2 - 1;
  *(_DWORD *)(v1 + 160) = v2 - 1;
  if ((*(unsigned char *)(v1 + 204) & 0x20) == 0)
  {
    CAHostTimeWithTime(*(double *)(v1 + 176));
    CAHostTimeWithTime(*(double *)(v1 + 168));
    kdebug_trace();
  }
  if (!v4)
  {
    if (*(_DWORD *)(v1 + 160)) {
      __assert_rtn("finish_frame", "CATransactionInternal.mm", 2052, "!s->_frame_depth");
    }
    *(_DWORD *)(v1 + 164) = 0;
    if (!**((_DWORD **)this + 13))
    {
      double result = 0.0;
      *(_OWORD *)(v1 + 184) = 0u;
      *(_OWORD *)(v1 + 168) = 0u;
    }
  }
  return result;
}

void CA::Display::DisplayLinkItem::dispatch_(uint64_t a1, void *a2)
{
  int v4 = (void *)MEMORY[0x185324A30]();
  objc_msgSend(*(id *)(a1 + 24), *(SEL *)(a1 + 32), *(void *)(a1 + 256));
  *a2 = *(void *)(a1 + 288) - *(void *)(a1 + 280);
  a2[2] = *(void *)(a1 + 288);
}

uint64_t CA::Display::DisplayLinkItem::compute_target_timestamp_delta(CA::Display::DisplayLinkItem *this)
{
  return *((void *)this + 37) * *((int *)this + 14);
}

uint64_t CA::Display::DisplayLinkItem::needs_update_link(CA::Display::DisplayLinkItem *this)
{
  return 0;
}

CA::AttrList *CA::Transaction::set_value(CA::Transaction *this, const void *a2, int a3, unsigned __int8 *a4)
{
  if (!**((_DWORD **)this + 13)) {
    CA::Transaction::ensure_implicit(this, 1);
  }
  double v8 = (void *)*((void *)this + 11);
  if (!v8)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    double v8 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x20uLL, 0x743898A5uLL);
    *((void *)this + 11) = v8;
  }
  double v10 = (CA::AttrList *)*((void *)v8 + 2);
  if (!v10)
  {
    unint64_t v11 = (malloc_zone_t *)get_malloc_zone();
    double v10 = (CA::AttrList *)malloc_type_zone_calloc(v11, 1uLL, 0x10uLL, 0x743898A5uLL);
  }
  double result = CA::AttrList::set(v10, a2, a3, a4);
  *(void *)(*((void *)this + 11) + 16) = result;
  return result;
}

void CA::Display::DisplayLinkItem::~DisplayLinkItem(CA::Display::DisplayLinkItem *this)
{
  CA::Display::DisplayLinkItem::~DisplayLinkItem(this);

  JUMPOUT(0x185323DC0);
}

{
  const void *v2;
  const void *v3;
  atomic_uint *v4;

  *(void *)this = &unk_1ED030380;
  int v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 5);
  if (v3) {
    CFRelease(v3);
  }

  pthread_cond_destroy((pthread_cond_t *)((char *)this + 200));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 136));
  int v4 = (atomic_uint *)*((void *)this + 33);
  if (v4) {
    CA::Display::DisplayLink::unref(v4);
  }
}

void sub_1847544EC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(atomic_uint **)(v1 + 264);
  if (v3) {
    CA::Display::DisplayLink::unref(v3);
  }
  _Unwind_Resume(exception_object);
}

void CA::Display::DisplayLinkItem::run_deferred_unregister_frame_interval_range(CA::Display::DisplayLinkItem *this)
{
  *((unsigned char *)this + 129) = 0;
}

uint64_t CA::Display::DisplayLink::pause_timer_locked(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 152);
  if (v1)
  {
    uint64_t v2 = this;
    pthread_mutex_lock((pthread_mutex_t *)(v1 + 16));
    mk_timer_cancel();
    *(unsigned char *)(v1 + 20CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 1;
    uint64_t v3 = *(void (**)(uint64_t, uint64_t, void, void, void))(v1 + 192);
    if (v3) {
      v3(v1, 2, *(void *)(v1 + 224), *(void *)(v1 + 216), *(void *)(v1 + 184));
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 16));
    uint64_t v4 = *(void *)(v2 + 152);
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
    *(void *)(v4 + 24CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
    return pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
  }
  return this;
}

BOOL CAFrameRateRangeIsValid(float a1, float a2, float a3)
{
  if (!dyld_program_sdk_at_least() && a1 == a3 && a1 == a2) {
    return 1;
  }
  if (a1 == 0.0 && a2 == 0.0 && a3 == 0.0) {
    return 1;
  }
  if (a1 <= 0.0) {
    return 0;
  }
  if (a1 <= a3 && a3 <= a2) {
    return 1;
  }
  return a3 == 0.0 && a1 <= a2;
}

uint64_t CA::Render::GainMapLayer::visit_subclass(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 56))(a2, a1);
}

void ___ZN2CA7Context18commit_transactionEPNS_11TransactionEdPd_block_invoke_2_57(uint64_t a1, uint64_t a2)
{
  if (a2 == 8)
  {
    mach_port_mod_refs(*MEMORY[0x1E4F14960], *(_DWORD *)(a1 + 56), 1u, -1);
    double v8 = *(NSObject **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    dispatch_release(v8);
  }
  else if (a2 == 2)
  {
    msg = (mach_msg_header_t *)dispatch_mach_msg_get_msg();
    mach_msg_destroy(msg);
    uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
    int v6 = *(_DWORD *)(v5 + 24);
    if (!v6) {
      __assert_rtn("commit_transaction_block_invoke_2", "CAContextInternal.mm", 3923, "pending_count > 0");
    }
    int v7 = v6 - 1;
    *(_DWORD *)(v5 + 24) = v7;
    if (!v7)
    {
      (*(void (**)(void, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), v4);
      dispatch_mach_cancel();
    }
  }
}

uint64_t ___ZN2CA7Context18commit_transactionEPNS_11TransactionEdPd_block_invoke_54(uint64_t a1)
{
  kdebug_trace();
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    int v3 = 0;
    do
    {
      (*(void (**)(void))(*(void *)v2 + 16))();
      _Block_release(*(const void **)v2);
      uint64_t v2 = *(void *)(v2 + 8);
      ++v3;
    }
    while (v2);
    uint64_t v4 = *(void **)(a1 + 32);
    if (v4)
    {
      do
      {
        uint64_t v5 = (void *)v4[1];
        free(v4);
        uint64_t v4 = v5;
      }
      while (v5);
    }
  }

  return kdebug_trace();
}

void sub_184754D38(_Unwind_Exception *a1)
{
}

void delete_buffer(uint64_t a1, CAImageQueueBuffer *a2, void *a3)
{
  v6.n128_f64[0] = MEMORY[0x1F4188790](a1);
  v16[15] = *MEMORY[0x1E4F143B8];
  if (v4)
  {
    uint64_t v7 = v5;
    double v8 = v4;
    int v9 = *(_DWORD *)(v5 + 20);
    if (v9 == 1)
    {
      if (*(void *)(v5 + 80))
      {
        uint64_t v10 = v3;
        xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
        if (v11)
        {
          double v12 = v11;
          xpc_dictionary_set_uint64(v11, "command", 3uLL);
          xpc_dictionary_set_uint64(v12, "iosurfaceRenderId", v10);
          (*(void (**)(uint64_t, void *, void))(v7 + 80))(v7, v12, *(void *)(v7 + 88));
          xpc_release(v12);
        }
      }
      int v9 = *(_DWORD *)(v7 + 20);
    }
    if (!v9)
    {
      if (*(_DWORD *)(v7 + 212))
      {
        uint64_t v13 = CA::Context::retain_context_with_id((CA::Context *)*(unsigned int *)(v7 + 208));
        if (v13)
        {
          uint64_t v14 = (uint64_t)(v13 + 54);
          bzero(v15, 0x1090uLL);
          CAImageQueueCommit::CAImageQueueCommit((uint64_t)v15, v7, v14);
          if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
            dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
          }
          CA::Render::encode_delete_object((CA::Render::Encoder *)v16, (CA::Render::Encoder *)((char *)v8 + CA::Render::_render_id_slide), v8[4]);
          CAImageQueueCommit::~CAImageQueueCommit((CAImageQueueCommit *)v15);
        }
      }
    }
    if (atomic_fetch_add(v8 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *, __n128))(*(void *)v8 + 16))(v8, v6);
    }
  }
}

void CAImageQueueBuffer::finalize(CAImageQueueBuffer *this)
{
  uint64_t v1 = (char *)this - 8;
  (**(void (***)(CAImageQueueBuffer *))this)(this);

  free(v1);
}

void CAImageQueueBuffer::~CAImageQueueBuffer(CAImageQueueBuffer *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED0223E8;
  uint64_t v3 = (atomic_uint *)*((void *)this + 3);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  --CA::Render::Object::_instance_counts[0];
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

{
  malloc_zone_t *malloc_zone;
  uint64_t vars8;

  CAImageQueueBuffer::~CAImageQueueBuffer(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::Render::Surface::~Surface(CA::Render::Surface *this)
{
  CA::Render::Surface::~Surface(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  uint64_t v2;
  __IOSurface *v3;
  const void *v4;
  atomic_uint *v5;
  atomic_uint *v6;
  const void *v7;
  const void *v8;
  atomic_uint *v9;
  uint64_t vars8;

  *(void *)this = &unk_1ED02F9D0;
  uint64_t v2 = *((void *)this + 39);
  if (v2)
  {
    (*(void (**)(uint64_t, uint64_t))(v2 + 16))(v2, 1);
    _Block_release(*((const void **)this + 39));
    *((void *)this + 39) = 0;
  }
  uint64_t v3 = (__IOSurface *)*((void *)this + 14);
  if (v3)
  {
    if ((*((unsigned char *)this + 14) & 0x80) != 0)
    {
      IOSurfaceDecrementUseCount(v3);
      uint64_t v3 = (__IOSurface *)*((void *)this + 14);
    }
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 15);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (atomic_uint *)*((void *)this + 21);
  if (v5 && atomic_fetch_add(v5 + 4, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 8))(v5);
  }
  __n128 v6 = (atomic_uint *)*((void *)this + 20);
  if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
  }
  uint64_t v7 = (const void *)*((void *)this + 19);
  if (v7) {
    CFRelease(v7);
  }
  double v8 = (const void *)*((void *)this + 18);
  if (v8) {
    CFRelease(v8);
  }
  int v9 = (atomic_uint *)*((void *)this + 12);
  if (v9 && atomic_fetch_add(v9 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v9 + 16))(v9);
  }
  --dword_1EB2ADE94;

  CA::Render::Texture::~Texture((CGColorSpaceRef *)this);
}

void ___ZN2CA7Context18commit_transactionEPNS_11TransactionEdPd_block_invoke_49(uint64_t a1, uint64_t a2)
{
  if (a2 == 8)
  {
    mach_port_mod_refs(*MEMORY[0x1E4F14960], *(_DWORD *)(a1 + 48), 1u, -1);
    uint64_t v5 = *(NSObject **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
    dispatch_release(v5);
  }
  else if (a2 == 2)
  {
    msg = (mach_msg_header_t *)dispatch_mach_msg_get_msg();
    mach_msg_destroy(msg);
    uint64_t v4 = (pthread_mutex_t *)(*(void *)(a1 + 40) + 16);
    pthread_mutex_lock(v4);
    CA::Context::destroy(*(CA::Context **)(a1 + 40));
    pthread_mutex_unlock(v4);
    CA::Context::unref(*(CA::Context **)(a1 + 40), 1);
    dispatch_mach_cancel();
  }
}

void sub_184755318(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_184755A84(_Unwind_Exception *exception_object)
{
  if (atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
  }
  _Unwind_Resume(exception_object);
}

_DWORD *point_vector_from_array(NSArray *a1)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  NSUInteger v2 = [(NSArray *)a1 count];
  if (!v2) {
    return 0;
  }
  NSUInteger v3 = v2;
  size_t v4 = 16 * v2;
  if (16 * v2 <= 0x1000)
  {
    MEMORY[0x1F4188790](v2);
    uint64_t v5 = (char *)v16 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v5, v4);
    goto LABEL_5;
  }
  uint64_t v5 = (char *)malloc_type_malloc(16 * v2, 0xCB6FFBCEuLL);
  if (!v5) {
    return 0;
  }
LABEL_5:
  uint64_t v6 = 0;
  uint64_t v7 = v5 + 8;
  double v8 = (uint64_t *)MEMORY[0x1E4F28AD0];
  do
  {
    id v9 = [(NSArray *)a1 objectAtIndex:v6];
    uint64_t v10 = (const char *)[v9 objCType];
    if (v10 && !strcmp(v10, "{CGPoint=dd}"))
    {
      [v9 pointValue];
    }
    else
    {
      uint64_t v12 = *v8;
      uint64_t v13 = v8[1];
    }
    *(v7 - 1) = v12;
    *uint64_t v7 = v13;
    ++v6;
    v7 += 2;
  }
  while (v3 != v6);
  uint64_t v14 = CA::Render::Vector::new_vector((CA::Render::Vector *)(2 * v3), v5, v11);
  if (v4 > 0x1000) {
    free(v5);
  }
  return v14;
}

uint64_t register_drawable(uint64_t result, _CAImageQueue *a2)
{
  if (result && a2)
  {
    uint64_t v3 = result;
    if ((*(unsigned char *)(result + 113) & 2) != 0)
    {
      CAImageQueueUnregisterBuffer((uint64_t)a2, *(void *)(result + 24));
      *(unsigned char *)(v3 + 113) &= ~2u;
    }
    size_t v4 = *(__CFString **)(v3 + 104);
    if (*(void *)(v3 + 96)) {
      BOOL v5 = v4 == @"ifSupported";
    }
    else {
      BOOL v5 = 1;
    }
    if (v5 || v4 == @"never") {
      char v7 = 2;
    }
    else {
      char v7 = 1;
    }
    double result = CAImageQueueRegisterIOSurfaceBuffer((_anonymous_namespace_ *)a2, *(__IOSurface **)(v3 + 64), v7);
    if (result)
    {
      *(void *)(v3 + 24) = result;
      *(unsigned char *)(v3 + 113) |= 2u;
    }
  }
  return result;
}

uint64_t CAImageQueueRegisterIOSurfaceBuffer(_anonymous_namespace_ *a1, __IOSurface *a2, char a3)
{
  if (!a2) {
    return 0;
  }
  uint64_t v4 = *((void *)a1 + 6);
  if (!v4) {
    return 0;
  }
  __int16 v7 = atomic_load((unint64_t *)(*(void *)(v4 + 24) + 8));
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  id v9 = (_CAImageQueue *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x158uLL, 0x743898A5uLL);
  xpc_object_t v11 = v9;
  if (!v9) {
    goto LABEL_11;
  }
  if ((v7 & 0x2000) != 0) {
    char v12 = 61;
  }
  else {
    char v12 = 63;
  }
  CA::Render::Surface::Surface((uint64_t)v9, a2, -1, v12, 0, 0, 0);
  if ((a3 & 1) == 0)
  {
    if ((a3 & 2) == 0) {
      goto LABEL_9;
    }
LABEL_16:
    *((_WORD *)v11 + 168) &= 0xFBDFu;
    if ((a3 & 4) == 0) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  *((_WORD *)v11 + 168) |= 0x420u;
  if ((a3 & 2) != 0) {
    goto LABEL_16;
  }
LABEL_9:
  if ((a3 & 4) != 0) {
LABEL_10:
  }
    *((_WORD *)v11 + 168) |= 0x40u;
LABEL_11:
}

uint64_t anonymous namespace'::register_buffer(_anonymous_namespace_ *this, _CAImageQueue *a2, CA::Render::Texture *a3)
{
  MEMORY[0x1F4188790](this);
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  __int16 v7 = malloc_type_malloc(0x28uLL, 0xE6C23951uLL);
  double v8 = v7;
  uint64_t v9 = (uint64_t)(v7 + 1);
  v7[2] = 1;
  ++CA::Render::Object::_instance_counts[0];
  v7[1] = &unk_1ED0223E8;
  do
  {
    unsigned int add = atomic_fetch_add(CA::Render::next_sequence(void)::sequence, 1u);
    BOOL v11 = __CFADD__(add, 1);
    unsigned int v12 = add + 1;
  }
  while (v11);
  *((_DWORD *)v7 + 6) = v12;
  v7[4] = v4;
  if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
    dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
  }
  uint64_t v13 = CA::Render::_render_id_slide + v9;
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 16));
  uint64_t v14 = *(int **)(v6 + 200);
  if (!v14)
  {
    uint64_t v14 = (int *)x_hash_table_new_(0, 0, 0, 0, 0, 0);
    *(void *)(v6 + 20CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v14;
  }
  hash_table_modify(v14, v13, v9, 0);
  os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 16));
  int v15 = *(_DWORD *)(v6 + 20);
  if (v15 == 1)
  {
    if (*(unsigned char *)(v4 + 12) == 51)
    {
      if (*(void *)(v6 + 80))
      {
        unint64_t v16 = *(__IOSurface **)(v4 + 112);
        xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
        if (v17)
        {
          uint64_t v18 = v17;
          xpc_dictionary_set_uint64(v17, "command", 2uLL);
          mach_port_t MachPort = IOSurfaceCreateMachPort(v16);
          xpc_dictionary_set_mach_send();
          mach_port_deallocate(*MEMORY[0x1E4F14960], MachPort);
          xpc_dictionary_set_uint64(v18, "iosurfaceRenderId", v13);
          (*(void (**)(uint64_t, void *, void))(v6 + 80))(v6, v18, *(void *)(v6 + 88));
          xpc_release(v18);
        }
      }
    }
    int v15 = *(_DWORD *)(v6 + 20);
  }
  if (!v15)
  {
    if (*(_DWORD *)(v6 + 212))
    {
      double v21 = CA::Context::retain_context_with_id((CA::Context *)*(unsigned int *)(v6 + 208));
      if (v21)
      {
        uint64_t v22 = (uint64_t)(v21 + 54);
        bzero(v23, 0x1090uLL);
        CAImageQueueCommit::CAImageQueueCommit((uint64_t)v23, v6, v22);
        if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
          dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
        }
        CA::Render::encode_set_object((CA::Render *)v24, (CA::Render::Encoder *)(CA::Render::_render_id_slide + v9), *((_DWORD *)v8 + 6), (CA::Render::Object *)v8[4], 0);
        v24[104] = 1;
        CAImageQueueCommit::~CAImageQueueCommit((CAImageQueueCommit *)v23);
      }
    }
  }
  return v13;
}

uint64_t CABackingStoreSynchronize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a2) {
    return 1;
  }
  *(void *)(a1 + 48CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = pthread_self();
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 64))(a2, a3, a4, 1);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  *(void *)(a1 + 48CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
  return v8;
}

BOOL CA::Context::synchronize(CA::Context *this, mach_port_name_t a2, int a3, int a4)
{
  kern_return_t v12;
  os_unfair_lock_s *v13;
  mach_error_t v14;
  mach_error_t v16;
  uint64_t v17;
  int v18;
  char *v19;
  const char *v20;
  int v21;
  mach_error_t v22;
  mach_error_t v23;
  unsigned int *v24;
  int v25;
  BOOL v26;
  uint64_t v27;
  int v28;
  NSObject *v29;
  const char *v30;
  uint32_t v31;
  uint64_t v32;
  mach_error_t v33;
  int v34;
  int v35;
  char *v36;
  NSObject *v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  int v41;
  char *v42;
  NSObject *v43;
  BOOL v44;
  int v45;
  mach_error_t v46;
  const char *v47;
  BOOL v48;
  int v49;
  mach_error_t v50;
  BOOL v51;
  int v52;
  mach_error_t v53;
  NSObject *v54;
  int v55;
  mach_error_t v56;
  unsigned int v57;
  mach_port_name_t v58;
  mach_port_name_t name;
  uint8_t buf[4];
  int v61;
  __int16 v62;
  mach_error_t v63;
  __int16 v64;
  char *v65;
  uint64_t v66;

  uint64_t v66 = *MEMORY[0x1E4F143B8];
  name = 0;
  uint64_t v8 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  if (*((_DWORD *)this + 32) >= a2) {
    mach_port_name_t v9 = a2;
  }
  else {
    mach_port_name_t v9 = *((_DWORD *)this + 32);
  }
  if (a2) {
    mach_port_name_t v10 = v9;
  }
  else {
    mach_port_name_t v10 = *((_DWORD *)this + 32);
  }
  if (v10 <= *((_DWORD *)this + 34))
  {
    pthread_mutex_unlock(v8);
    return 1;
  }
  BOOL v11 = (ipc_space_t *)MEMORY[0x1E4F14960];
  unsigned int v12 = mach_port_allocate(*MEMORY[0x1E4F14960], 1u, &name);
  if (name - 1 > 0xFFFFFFFD)
  {
    unint64_t v16 = v12;
    if (x_log_hook_p())
    {
      mach_error_string(v16);
      goto LABEL_16;
    }
    xpc_object_t v17 = x_log_category_api;
    if (!os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR)) {
      goto LABEL_41;
    }
    uint64_t v18 = *((_DWORD *)this + 1);
    v19 = mach_error_string(v16);
    *(_DWORD *)buf = 67109634;
    unint64_t v61 = v18;
    v62 = 1024;
    double v63 = v16;
    double v64 = 2080;
    v65 = v19;
    uint64_t v20 = "Failed to make reply port for update sync (client=0x%x) [0x%x %s]";
    goto LABEL_39;
  }
  uint64_t v13 = (os_unfair_lock_s *)*((void *)this + 13);
  if (v13)
  {
    v57 = 0;
    v58 = 0;
    uint64_t v14 = MEMORY[0x1853246C0](*v11);
    if (v14)
    {
      if (x_log_hook_p())
      {
        mach_error_string(v14);
LABEL_16:
        x_log_();
LABEL_41:
        pthread_mutex_unlock(v8);
        v58 = 0;
        goto LABEL_42;
      }
      xpc_object_t v17 = x_log_category_api;
      if (!os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
      double v35 = *((_DWORD *)this + 1);
      uint64_t v36 = mach_error_string(v14);
      *(_DWORD *)buf = 67109634;
      unint64_t v61 = v35;
      v62 = 1024;
      double v63 = v14;
      double v64 = 2080;
      v65 = v36;
      uint64_t v20 = "Failed to make send-once for update sync (client=0x%x) [0x%x %s]";
LABEL_39:
      double v37 = v17;
      goto LABEL_40;
    }
    CA::Render::Context::request_synchronize(v13, v58, a3, 0, v10, 1);
  }
  else
  {
    double v21 = *((_DWORD *)this + 40);
    if (!v21 || (*((unsigned char *)this + 241) & 2) != 0) {
      goto LABEL_41;
    }
    uint64_t v22 = _CASSynchronize(v21, name, a3, 0, v10, 1, a4);
    if (v22)
    {
      uint64_t v23 = v22;
      if (v22 == 268435459)
      {
        *((unsigned char *)this + 241) |= 2u;
      }
      else if (v22 == -81182719)
      {
        x_log_crash("Unentitled call to server!");
        abort();
      }
      if (x_log_hook_p())
      {
        mach_error_string(v23);
        goto LABEL_16;
      }
      v40 = x_log_category_api;
      if (!os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
      v41 = *((_DWORD *)this + 1);
      char v42 = mach_error_string(v23);
      *(_DWORD *)buf = 67109634;
      unint64_t v61 = v41;
      v62 = 1024;
      double v63 = v23;
      double v64 = 2080;
      v65 = v42;
      uint64_t v20 = "Failed to register update sync (client=0x%x) [0x%x %s]";
      double v37 = v40;
LABEL_40:
      _os_log_impl(&dword_184668000, v37, OS_LOG_TYPE_ERROR, v20, buf, 0x18u);
      goto LABEL_41;
    }
  }
  pthread_mutex_unlock(v8);
  uint64_t v25 = 0;
  v58 = 0;
  while (2)
  {
    v57 = 0;
    switch(CA::Render::Context::wait_for_synchronize(name, 0, &v57, &v58, v24))
    {
      case 1u:
        pthread_mutex_lock(v8);
        double v38 = v57;
        v39 = *((_DWORD *)this + 33);
        if (v57 > v39)
        {
          *((_DWORD *)this + 33) = v57;
          v39 = v38;
        }
        if (v58 <= *((_DWORD *)this + 34)) {
          v58 = *((_DWORD *)this + 34);
        }
        else {
          *((_DWORD *)this + 34) = v58;
        }
        BOOL v11 = (ipc_space_t *)MEMORY[0x1E4F14960];
        if (v39 > *((_DWORD *)this + 32))
        {
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            v54 = x_log_category_api;
            if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
            {
              unint64_t v56 = *((_DWORD *)this + 32);
              uint64_t v55 = *((_DWORD *)this + 33);
              *(_DWORD *)buf = 67109376;
              unint64_t v61 = v55;
              v62 = 1024;
              double v63 = v56;
              _os_log_impl(&dword_184668000, v54, OS_LOG_TYPE_ERROR, "server/client commit_seed mismatch : sync server seed (%u) > client (%u)", buf, 0xEu);
            }
          }
          *((_DWORD *)this + 32) = *((_DWORD *)this + 33);
        }
        pthread_mutex_unlock(v8);
        goto LABEL_42;
      case 2u:
        if (x_log_hook_p()) {
          goto LABEL_54;
        }
        int v43 = x_log_category_api;
        uint64_t v48 = os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR);
        BOOL v11 = (ipc_space_t *)MEMORY[0x1E4F14960];
        if (v48)
        {
          double v49 = *((_DWORD *)this + 3);
          v50 = *((_DWORD *)this + 1);
          *(_DWORD *)buf = 67109376;
          unint64_t v61 = v49;
          v62 = 1024;
          double v63 = v50;
          unint64_t v47 = "dead reply from update sync on %u:%x";
          goto LABEL_69;
        }
        goto LABEL_42;
      case 3u:
        if (x_log_hook_p()) {
          goto LABEL_54;
        }
        int v43 = x_log_category_api;
        v44 = os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR);
        BOOL v11 = (ipc_space_t *)MEMORY[0x1E4F14960];
        if (v44)
        {
          int v45 = *((_DWORD *)this + 3);
          int v46 = *((_DWORD *)this + 1);
          *(_DWORD *)buf = 67109376;
          unint64_t v61 = v45;
          v62 = 1024;
          double v63 = v46;
          unint64_t v47 = "unrecognized reply from update sync on %u:%x";
          goto LABEL_69;
        }
        goto LABEL_42;
      case 4u:
        unint64_t v26 = x_log_hook_p();
        if (v25 <= 8)
        {
          ++v25;
          if (v26) {
            goto LABEL_30;
          }
          double v32 = x_log_category_api;
          if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
          {
            v33 = *((_DWORD *)this + 3);
            uint64_t v34 = *((_DWORD *)this + 1);
            *(_DWORD *)buf = 67109632;
            unint64_t v61 = v25;
            v62 = 1024;
            double v63 = v33;
            double v64 = 1024;
            LODWORD(v65) = v34;
            unint64_t v29 = v32;
            uint64_t v30 = "long update sync wait %i : %u:%x";
            unsigned int v31 = 20;
            goto LABEL_36;
          }
          continue;
        }
        if (v26)
        {
LABEL_54:
          x_log_();
          BOOL v11 = (ipc_space_t *)MEMORY[0x1E4F14960];
        }
        else
        {
          int v43 = x_log_category_api;
          double v51 = os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR);
          BOOL v11 = (ipc_space_t *)MEMORY[0x1E4F14960];
          if (v51)
          {
            uint64_t v52 = *((_DWORD *)this + 3);
            double v53 = *((_DWORD *)this + 1);
            *(_DWORD *)buf = 67109376;
            unint64_t v61 = v52;
            v62 = 1024;
            double v63 = v53;
            unint64_t v47 = "excessive update sync wait : %u:%x";
LABEL_69:
            _os_log_impl(&dword_184668000, v43, OS_LOG_TYPE_ERROR, v47, buf, 0xEu);
          }
        }
LABEL_42:
        if (name - 1 <= 0xFFFFFFFD) {
          mach_port_mod_refs(*v11, name, 1u, -1);
        }
        return v10 <= v58;
      default:
        if (x_log_hook_p())
        {
LABEL_30:
          x_log_();
        }
        else
        {
          unint64_t v27 = x_log_category_api;
          if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
          {
            uint64_t v28 = *((_DWORD *)this + 1);
            *(_DWORD *)buf = 67109120;
            unint64_t v61 = v28;
            unint64_t v29 = v27;
            uint64_t v30 = "error while waiting for update sync on %x";
            unsigned int v31 = 8;
LABEL_36:
            _os_log_impl(&dword_184668000, v29, OS_LOG_TYPE_ERROR, v30, buf, v31);
          }
        }
        continue;
    }
  }
}

void sub_1847570D0(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_184757A44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  pthread_mutex_unlock(v23);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&a23);
  _Unwind_Resume(a1);
}

uint64_t CA::Render::Context::wait_for_synchronize(mach_port_name_t rcv_name, _DWORD *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  mach_msg_return_t v8;
  mach_msg_return_t v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  unsigned char msg[32];
  long long v15;
  long long v16;
  long long v17;
  long long v18;
  uint64_t v19;
  uint8_t buf[4];
  mach_msg_return_t v21;
  uint64_t v22;

  uint64_t v22 = *MEMORY[0x1E4F143B8];
  memset(msg, 0, sizeof(msg));
  int v15 = 0u;
  unint64_t v16 = 0u;
  xpc_object_t v17 = 0u;
  uint64_t v18 = 0u;
  v19 = 0;
  uint64_t v8 = mach_msg((mach_msg_header_t *)msg, 258, 0, 0x68u, rcv_name, 0x3E8u, 0);
  if (v8 == 268451843) {
    return 4;
  }
  mach_port_name_t v9 = v8;
  if (v8)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      BOOL v11 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        double v21 = v9;
        _os_log_impl(&dword_184668000, v11, OS_LOG_TYPE_ERROR, "error (%i) waiting for sync reply", buf, 8u);
      }
    }
    return 5;
  }
  else
  {
    if (*(_DWORD *)&msg[20] == 1937337955 && *(_DWORD *)&msg[4] >= 0x24u)
    {
      if (a2) {
        *a2 = *(_DWORD *)&msg[24];
      }
      if (a3) {
        *a3 = *(_DWORD *)&msg[28];
      }
      if (a4) {
        *a4 = v15;
      }
      mach_port_name_t v10 = 1;
    }
    else if (*(_DWORD *)&msg[20] == 71)
    {
      mach_port_name_t v10 = 2;
    }
    else
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unsigned int v12 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          double v21 = *(_DWORD *)&msg[20];
          _os_log_impl(&dword_184668000, v12, OS_LOG_TYPE_ERROR, "unknown sync reply received : %i", buf, 8u);
        }
      }
      mach_port_name_t v10 = 3;
    }
    mach_msg_destroy((mach_msg_header_t *)msg);
  }
  return v10;
}

uint64_t _CASSynchronize(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)&msg[20] = 0u;
  *(_OWORD *)&msg[4] = 0u;
  *(_DWORD *)&msg[28] = a2;
  int v9 = 1376256;
  uint64_t v10 = *MEMORY[0x1E4F14068];
  int v11 = a3;
  int v12 = a4;
  int v13 = a5;
  int v14 = a6;
  int v15 = a7;
  *(_DWORD *)msg = -2147483629;
  *(_DWORD *)&msg[8] = a1;
  *(void *)&msg[20] = 0x100009D09;
  if (MEMORY[0x1E4F14B18]) {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
  }
  return mach_msg((mach_msg_header_t *)msg, 1, 0x44u, 0, 0, 0, 0);
}

BOOL CA::Context::Generic::synchronize(CA::Context **this, mach_port_name_t a2, int a3, int a4)
{
  return CA::Context::synchronize(this[1], a2, a3, a4);
}

void ___ZN2CA7Context14send_deferralsEjjRKNSt3__113unordered_setIyNS1_4hashIyEENS1_8equal_toIyEENS1_9allocatorIyEEEEdjy_block_invoke(uint64_t a1)
{
  CA::Context::delete_sent_deferrals(*(uint64_t **)(a1 + 32));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = *(void **)v2;
    if (*(void *)v2)
    {
      *(void *)(v2 + 8) = v3;
      operator delete(v3);
    }
    JUMPOUT(0x185323DC0);
  }
}

void CA::Context::delete_sent_deferrals(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)(v1 + 8);
    if (v3) {
      *uint64_t v3 = 0;
    }
    uint64_t v4 = *(CA::Context ***)v1;
    if (*(void *)v1)
    {
      do
      {
        uint64_t v5 = *v4;
        CA::Context::unref(v4[1], 1);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, v4);
        uint64_t v4 = (CA::Context **)v5;
      }
      while (v5);
    }
    v1 += 16;
  }
}

int *CA::Context::retain_context_with_client_id(CA::Context *this)
{
  int v1 = (int)this;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
  if (CA::all_contexts(void)::contexts_data_initialized)
  {
    for (i = (int **)CA::all_contexts(void)::contexts_data; ; ++i)
    {
      if (i == (int **)qword_1EB2AC6F8)
      {
        uint64_t v3 = 0;
        goto LABEL_9;
      }
      uint64_t v3 = *i;
      int v4 = **i;
      if (v4)
      {
        if (v3[1] == v1) {
          break;
        }
      }
    }
    *uint64_t v3 = v4 + 1;
  }
  else
  {
    uint64_t v3 = 0;
    CA::all_contexts(void)::contexts_data = 0;
    qword_1EB2AC6F8 = 0;
    qword_1EB2AC700 = 0;
    CA::all_contexts(void)::contexts_data_initialized = 1;
  }
LABEL_9:
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
  return v3;
}

id CALayerGetContext(uint64_t a1)
{
  int v1 = CA::Layer::retain_context(*(CA::Layer **)(a1 + 16));
  if (!v1) {
    return 0;
  }
  uint64_t v2 = v1;
  uint64_t v3 = (id *)(v1 + 20);
  if (*((unsigned char *)v2 + 88)) {
    id Weak = objc_loadWeak(v3);
  }
  else {
    id Weak = *v3;
  }
  CA::Context::unref((CA::Context *)v2, 0);
  return Weak;
}

void CA::Context::unref(CA::Context *this, int a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
  int v4 = *(_DWORD *)this;
  int v5 = *(_DWORD *)this - 1;
  *(_DWORD *)this = v5;
  char v6 = *((unsigned char *)this + 241);
  if (v4 != 1 || a2 == 0) {
    goto LABEL_16;
  }
  if ((*((unsigned char *)this + 241) & 4) == 0)
  {
    if (CA::all_contexts(void)::contexts_data_initialized)
    {
      if (qword_1EB2AC6F8 != CA::all_contexts(void)::contexts_data)
      {
        uint64_t v8 = 0;
        unint64_t v9 = (qword_1EB2AC6F8 - CA::all_contexts(void)::contexts_data) >> 3;
        if (v9 <= 1) {
          unint64_t v9 = 1;
        }
        while (*(CA::Context **)(CA::all_contexts(void)::contexts_data + 8 * v8) != this)
        {
          if (v9 == ++v8) {
            goto LABEL_15;
          }
        }
        uint64_t v10 = qword_1EB2AC6F8 - 8;
        *(void *)(CA::all_contexts(void)::contexts_data + 8 * v8) = *(void *)(qword_1EB2AC6F8 - 8);
        qword_1EB2AC6F8 = v10;
        char v6 = *((unsigned char *)this + 241);
      }
    }
    else
    {
      CA::all_contexts(void)::contexts_data = 0;
      qword_1EB2AC6F8 = 0;
      qword_1EB2AC700 = 0;
      CA::all_contexts(void)::contexts_data_initialized = 1;
    }
LABEL_15:
    v6 |= 4u;
    *((unsigned char *)this + 241) = v6;
    --CA::Context::_context_count;
LABEL_16:
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
    if (v5) {
      return;
    }
    goto LABEL_17;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
LABEL_17:
  if (a2)
  {
    CA::Context::destroy(this);
    int v11 = (const void *)*((void *)this + 15);
    if (v11) {
      CFRelease(v11);
    }
    CGColorSpaceRelease(*((CGColorSpaceRef *)this + 14));
    int v12 = (const void *)*((void *)this + 29);
    if (v12) {
      CFRelease(v12);
    }
    pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 16));
    int v13 = (const void *)*((void *)this + 19);
    if (v13) {
      CFRelease(v13);
    }
    int v14 = (id *)((char *)this + 80);
    if (*((void *)this + 10))
    {
      if (*((unsigned char *)this + 88)) {
        objc_storeWeakOrNil(v14, 0);
      }
      else {
        *int v14 = 0;
      }
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, this);
  }
  else if ((v6 & 8) == 0)
  {
    CA::Context::invalidate(this);
  }
}

void sub_184758254(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(const void **)(v1 + 152);
  if (v3) {
    CFRelease(v3);
  }
  int v4 = (id *)(v1 + 80);
  if (*(void *)(v1 + 80))
  {
    if (*(unsigned char *)(v1 + 88)) {
      objc_storeWeakOrNil(v4, 0);
    }
    else {
      *int v4 = 0;
    }
  }
  _Unwind_Resume(exception_object);
}

int *CA::Context::retain_context_with_id(CA::Context *this)
{
  int v1 = (int)this;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
  if (CA::all_contexts(void)::contexts_data_initialized)
  {
    for (i = (int **)CA::all_contexts(void)::contexts_data; ; ++i)
    {
      if (i == (int **)qword_1EB2AC6F8)
      {
        uint64_t v3 = 0;
        goto LABEL_9;
      }
      uint64_t v3 = *i;
      int v4 = **i;
      if (v4)
      {
        if (v3[2] == v1) {
          break;
        }
      }
    }
    *uint64_t v3 = v4 + 1;
  }
  else
  {
    uint64_t v3 = 0;
    CA::all_contexts(void)::contexts_data = 0;
    qword_1EB2AC6F8 = 0;
    qword_1EB2AC700 = 0;
    CA::all_contexts(void)::contexts_data_initialized = 1;
  }
LABEL_9:
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
  return v3;
}

int *CA::Layer::retain_context(CA::Layer *this)
{
  if ((*((unsigned char *)this + 54) & 0x10) == 0) {
    return 0;
  }
  uint64_t v2 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (!v2) {
    uint64_t v2 = (CA::Transaction *)CA::Transaction::create(this);
  }
  uint64_t v3 = (CA::Context *)CA::Layer::ancestor_context_id(this, v2);
  if (!v3) {
    return 0;
  }

  return CA::Context::retain_context_with_id(v3);
}

void sub_1847586C8(_Unwind_Exception *a1)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, v1);
  _Unwind_Resume(a1);
}

void sub_184758F1C(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::WindowServer::IOMFBDisplay::update_color_matrix(CA::WindowServer::IOMFBDisplay *this, double a2)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  if (!CA::WindowServer::IOMFBDisplay::needs_harmony_update(this)) {
    return;
  }
  double v5 = *((double *)this + 3341);
  double v6 = (a2 - *((double *)this + 3340)) / v5;
  v4.n128_u64[0] = 1.0;
  if (v6 > 1.0) {
    double v7 = 1.0;
  }
  else {
    double v7 = (a2 - *((double *)this + 3340)) / v5;
  }
  if (v7 >= 0.0) {
    double v8 = (a2 - *((double *)this + 3340)) / v5;
  }
  else {
    double v8 = 0.0;
  }
  if (v6 <= 1.0 || v7 < 0.0)
  {
    if (v5 != 0.0 && v8 != 1.0)
    {
      uint64_t v9 = 0;
      uint64_t v10 = (char *)this + 26736;
      int v11 = (char *)this + 26772;
      int v12 = (char *)this + 26808;
      v4.n128_u32[0] = 1.0;
      do
      {
        uint64_t v13 = 0;
        *(_DWORD *)&buf[8] = 0;
        *(void *)buf = 0;
        LODWORD(v7CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
        float v14 = 0.0;
        uint64_t v69 = 0;
        do
        {
          float v14 = v14 + (float)(*(float *)&v10[v13] * *(float *)&v10[v13]);
          v13 += 4;
        }
        while (v13 != 12);
        float v15 = sqrtf(v14);
        if (v15 <= 0.0)
        {
          *(_DWORD *)&buf[8] = 0;
          *(void *)buf = 0;
        }
        else
        {
          uint64_t v16 = 0;
          float v17 = 1.0 / v15;
          do
          {
            *(float *)&buf[v16] = *(float *)&v10[v16] * v17;
            v16 += 4;
          }
          while (v16 != 12);
        }
        uint64_t v18 = 0;
        float v19 = 0.0;
        do
        {
          float v19 = v19 + (float)(*(float *)&v11[v18] * *(float *)&v11[v18]);
          v18 += 4;
        }
        while (v18 != 12);
        float v20 = sqrtf(v19);
        if (v20 <= 0.0)
        {
          LODWORD(v7CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
          uint64_t v69 = 0;
        }
        else
        {
          uint64_t v21 = 0;
          float v22 = 1.0 / v20;
          do
          {
            *(float *)((char *)&v69 + v21) = *(float *)&v11[v21] * v22;
            v21 += 4;
          }
          while (v21 != 12);
        }
        uint64_t v23 = 0;
        LODWORD(v78) = 0;
        uint64_t v77 = 0;
        do
        {
          float v24 = *(float *)&buf[v23] + v8 * (float)(*(float *)((char *)&v69 + v23) - *(float *)&buf[v23]);
          *(float *)((char *)&v77 + v23) = v24;
          v23 += 4;
        }
        while (v23 != 12);
        uint64_t v25 = 0;
        float v26 = 0.0;
        do
        {
          float v26 = v26 + (float)(*(float *)((char *)&v77 + v25) * *(float *)((char *)&v77 + v25));
          v25 += 4;
        }
        while (v25 != 12);
        float v27 = sqrtf(v26);
        if (v27 <= 0.0)
        {
          uint64_t v30 = (char *)this + 12 * v9 + 26808;
          *((_DWORD *)v30 + 2) = 0;
          *(void *)uint64_t v30 = 0;
        }
        else
        {
          uint64_t v28 = 0;
          float v29 = 1.0 / v27;
          do
          {
            *(float *)&v12[v28] = *(float *)((char *)&v77 + v28) * v29;
            v28 += 4;
          }
          while (v28 != 12);
        }
        uint64_t v31 = 0;
        float v32 = 0.0;
        do
        {
          float v32 = v32 + (float)(*(float *)&v10[v31] * *(float *)&v10[v31]);
          v31 += 4;
        }
        while (v31 != 12);
        uint64_t v33 = 0;
        float v34 = 0.0;
        do
        {
          float v34 = v34 + (float)(*(float *)&v11[v33] * *(float *)&v11[v33]);
          v33 += 4;
        }
        while (v33 != 12);
        uint64_t v35 = 0;
        float v36 = sqrtf(v32);
        float v37 = v36 + v8 * (float)(sqrtf(v34) - v36);
        do
        {
          *(float *)&v12[v35] = *(float *)&v12[v35] * v37;
          v35 += 4;
        }
        while (v35 != 12);
        ++v9;
        v10 += 12;
        v11 += 12;
        v12 += 12;
      }
      while (v9 != 3);
      goto LABEL_46;
    }
    v4.n128_f64[0] = v8;
  }
  *((unsigned char *)this + 26856) = 1;
  long long v38 = *(_OWORD *)((char *)this + 26788);
  *(_OWORD *)((char *)this + 26808) = *(_OWORD *)((char *)this + 26772);
  *(_OWORD *)((char *)this + 26824) = v38;
  *((_DWORD *)this + 671CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = *((_DWORD *)this + 6701);
  *((_DWORD *)this + 6713) = *((_DWORD *)this + 6712);
  double v8 = v4.n128_f64[0];
LABEL_46:
  if ((*((_WORD *)this + 328) & 0x1C00) != 0x800)
  {
    if (!(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *, __n128))(*(void *)this + 1840))(this, v4))goto LABEL_52; {
    if (CADeviceUseHarmonyXYZD50::once != -1)
    }
      dispatch_once(&CADeviceUseHarmonyXYZD50::once, &__block_literal_global_258);
    if (CADeviceUseHarmonyXYZD50::use_d50_xyz)
    {
      memset(buf, 0, 60);
      long long v39 = *(_OWORD *)((char *)this + 26824);
      *(_OWORD *)&buf[12] = *(_OWORD *)((char *)this + 26808);
      *(_OWORD *)&buf[28] = v39;
      *(_DWORD *)&buf[44] = *((_DWORD *)this + 6710);
      CA::IOMobileFramebuffer::swap_set_icc_matrix((uint64_t)this + 25568, 6u, *((_DWORD *)this + 6), 0, (float *)buf);
    }
    else
    {
LABEL_52:
      uint64_t v40 = 0;
      memset(buf, 0, 72);
      v41 = (char *)this + 26808;
      char v42 = buf;
      do
      {
        for (uint64_t i = 0; i != 3; ++i)
        {
          float v44 = *(float *)&v41[4 * i];
          BOOL v45 = v44 < 0.0;
          if (v44 >= 0.0) {
            double v46 = v44;
          }
          else {
            double v46 = -v44;
          }
          unint64_t v47 = vcvtd_n_s64_f64(v46, 0x20uLL);
          if (v45) {
            unint64_t v47 = -(uint64_t)v47;
          }
          *(void *)&v42[8 * i] = v47;
        }
        ++v40;
        v42 += 24;
        v41 += 12;
      }
      while (v40 != 3);
      if (*((unsigned char *)this + 25576))
      {
        uint64_t v77 = 0;
        v78 = &v77;
        uint64_t v79 = 0x2000000000;
        int v80 = 0;
        uint64_t v69 = MEMORY[0x1E4F143A8];
        uint64_t v70 = 0x40000000;
        v71 = ___ZN2CA19IOMobileFramebuffer10set_matrixE20IOMFB_MatrixLocationPA3_A3_Ky_block_invoke;
        v72 = &unk_1E5280458;
        v73 = &v77;
        v74 = (char *)this + 25568;
        int v76 = 9;
        v75 = buf;
        BMMonitorBlockExecutionWithSignature();
        _Block_object_dispose(&v77, 8);
      }
      else
      {
        IOMobileFramebufferSetMatrix();
      }
    }
    IOMobileFramebufferSetBrightnessCorrection();
  }
  if (BYTE8(xmmword_1EB2ACBF0))
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v48 = x_log_category_windowserver;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT))
      {
        int v49 = *((_DWORD *)this + 6);
        double v50 = *((float *)this + 6702);
        double v51 = *((float *)this + 6703);
        double v52 = *((float *)this + 6704);
        double v53 = *((float *)this + 6705);
        double v54 = *((float *)this + 6706);
        double v55 = *((float *)this + 6707);
        double v56 = *((float *)this + 6708);
        double v57 = *((float *)this + 6709);
        double v58 = *((float *)this + 6710);
        double v59 = *((float *)this + 6713);
        *(_DWORD *)buf = 67111936;
        *(_DWORD *)&buf[4] = v49;
        *(_WORD *)&buf[8] = 2048;
        *(double *)&buf[10] = v50;
        *(_WORD *)&buf[18] = 2048;
        *(double *)&buf[20] = v51;
        *(_WORD *)&buf[28] = 2048;
        *(double *)&buf[30] = v52;
        *(_WORD *)&buf[38] = 2048;
        *(double *)&buf[40] = v53;
        *(_WORD *)&buf[48] = 2048;
        *(double *)&buf[50] = v54;
        *(_WORD *)&buf[58] = 2048;
        *(double *)&buf[60] = v55;
        *(_WORD *)&buf[68] = 2048;
        *(double *)&buf[70] = v56;
        __int16 v61 = 2048;
        double v62 = v57;
        __int16 v63 = 2048;
        double v64 = v58;
        __int16 v65 = 2048;
        double v66 = v59;
        __int16 v67 = 2048;
        double v68 = v8;
        _os_log_impl(&dword_184668000, v48, OS_LOG_TYPE_DEFAULT, "display %d harmony matrix [%g, %g, %g; %g, %g, %g; %g, %g, %g], scale %g, t: %g\n",
          buf,
          0x76u);
      }
    }
  }
}

unint64_t CA::WindowServer::IOMFBDisplay::needs_update(CA::WindowServer::IOMFBDisplay *this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (CA::WindowServer::IOMFBDisplay::needs_harmony_update(this)) {
    return 0x10000000;
  }
  if ((!*((unsigned char *)this + 28154)
     || (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1480))(this))
    && *(unsigned __int8 *)(*((void *)this + 91) + 2) | *(unsigned __int8 *)(*((void *)this + 91) + 3)
    && !*((unsigned char *)this + 26972)
    || *((unsigned char *)this + 28177))
  {
    return 0x4000000000000000;
  }
  if (CADeviceNeedsLumaBoost::once[0] != -1) {
    dispatch_once(CADeviceNeedsLumaBoost::once, &__block_literal_global_76);
  }
  if (CADeviceNeedsLumaBoost::needs_luma_bost
    && (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 216))(this)
    && (*((unsigned char *)this + 28194) || *((_DWORD *)this + 6662)))
  {
    return 0x800000000;
  }
  if (*((double *)this + 3316) != 0.0)
  {
    if (!byte_1EB2ACC84) {
      return 8;
    }
    if (x_log_hook_p())
    {
LABEL_44:
      x_log_();
      return 8;
    }
    double v7 = x_log_category_CADebug;
    if (!os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO)) {
      return 8;
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v9 = "brightness_deadline";
LABEL_49:
    _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_INFO, "kUpdateReasonDisplayBrightness %s", buf, 0xCu);
    return 8;
  }
  if ((*((unsigned char *)this + 28209)
     || CA::WindowServer::Display::Mode::is_hdr((CA::WindowServer::IOMFBDisplay *)((char *)this + 640)))
    && (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 960))(this))
  {
    if (!byte_1EB2ACC84) {
      return 8;
    }
    if (x_log_hook_p()) {
      goto LABEL_44;
    }
    double v7 = x_log_category_CADebug;
    if (!os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO)) {
      return 8;
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v9 = "needs_brightness_update";
    goto LABEL_49;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
  uint64_t v3 = *((void *)this + 6 * *((unsigned int *)this + 6427) + 3224);
  if (v3 && ((*(unsigned char *)(v3 + 132) & 0x10) != 0 || *(void *)(v3 + 24)))
  {
    unint64_t v2 = 0x2000000000;
  }
  else if (*((unsigned char *)this + 28134))
  {
    unint64_t v2 = 0x200000000;
  }
  else
  {
    __n128 v4 = (void *)*((void *)this + 5);
    if (v4)
    {
      unint64_t v2 = 0x80000;
      while (!(*(uint64_t (**)(void))(**(void **)(*v4 + 96) + 336))(*(void *)(*v4 + 96)))
      {
        __n128 v4 = (void *)v4[1];
        if (!v4) {
          goto LABEL_35;
        }
      }
    }
    else
    {
LABEL_35:
      if (*((unsigned char *)this + 28202) || *((unsigned char *)this + 28203) || *((unsigned char *)this + 28204) || *((unsigned char *)this + 28205))
      {
        unint64_t v2 = 16;
      }
      else
      {
        uint64_t v6 = mach_absolute_time();
        unint64_t v2 = (unint64_t)(CATimeWithHostTime(v6) < *((double *)this + 3317)) << 42;
      }
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 25720));
  return v2;
}

BOOL CA::WindowServer::IOMFBDisplay::needs_harmony_update(CA::WindowServer::IOMFBDisplay *this)
{
  unint64_t v2 = (char *)this + 26856;
  if (*((unsigned char *)this + 28138)) {
    return *(unsigned __int8 *)(*((void *)this + 91) + 2) | *(unsigned __int8 *)(*((void *)this + 91) + 3)
  }
        && *v2 == 0;
  BOOL result = 0;
  if (v2[1296])
  {
    if ((*((_WORD *)this + 328) & 0x1C00) != 0x1000) {
      return *(unsigned __int8 *)(*((void *)this + 91) + 2) | *(unsigned __int8 *)(*((void *)this + 91) + 3)
    }
          && *v2 == 0;
  }
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::needs_brightness_update(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28210);
}

int *CA::Render::aligned_release(size_t this, void *a2, const void *a3)
{
  munmap(a2, this);
  BOOL result = CAGetStatsStruct(0);
  size_t v5 = *((void *)result + 1);
  size_t v6 = *(void *)result - this;
  *(void *)BOOL result = v6;
  if (v6 > v5) {
    *((void *)result + 1) = v6;
  }
  return result;
}

uint64_t CAGetMaximumImageBytes()
{
  return *((void *)CAGetStatsStruct(0) + 1);
}

void CA::Render::GradientLayer::encode(CA::Render::GradientLayer *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  CA::Render::InterpolatedFunction::encode((CA::Render::GradientLayer *)((char *)this + 16), a2);
  __n128 v4 = (_OWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v4 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 16);
    __n128 v4 = (_OWORD *)*((void *)a2 + 4);
  }
  *__n128 v4 = *(_OWORD *)((char *)this + 72);
  uint64_t v5 = *((void *)a2 + 4);
  unint64_t v6 = *((void *)a2 + 5);
  double v7 = (_OWORD *)(v5 + 16);
  *((void *)a2 + 4) = v5 + 16;
  if (v5 + 32 > v6)
  {
    CA::Render::Encoder::grow(a2, 16);
    double v7 = (_OWORD *)*((void *)a2 + 4);
  }
  *double v7 = *(_OWORD *)((char *)this + 88);
  *((void *)a2 + 4) += 16;
  CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 26));
  int v8 = *((_DWORD *)this + 27);
  uint64_t v9 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v9 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v9 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v9 = v8;
  *((void *)a2 + 4) += 4;
  if ((*((unsigned char *)this + 13) & 8) != 0) {
    CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 14));
  }
  uint64_t v10 = (CGColorSpace *)*((void *)this + 16);

  CA::Render::Encoder::encode_colorspace(a2, v10);
}

void *CA::Render::InterpolatedFunction::encode(CA::Render::InterpolatedFunction *this, CA::Render::Encoder *a2)
{
  uint64_t v4 = *((void *)this + 2);
  uint64_t v5 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    uint64_t v5 = (void *)*((void *)a2 + 4);
  }
  *uint64_t v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = *((void *)a2 + 5);
  int v8 = (_DWORD *)(v6 + 8);
  *((void *)a2 + 4) = v6 + 8;
  int v9 = *((_DWORD *)this + 6);
  if (v6 + 12 > v7)
  {
    CA::Render::Encoder::grow(a2, 4);
    int v8 = (_DWORD *)*((void *)a2 + 4);
  }
  *int v8 = v9;
  uint64_t v10 = *((void *)a2 + 4);
  unint64_t v11 = *((void *)a2 + 5);
  int v12 = (_DWORD *)(v10 + 4);
  *((void *)a2 + 4) = v10 + 4;
  int v13 = *((_DWORD *)this + 3) >> 8;
  if (v10 + 8 > v11)
  {
    CA::Render::Encoder::grow(a2, 4);
    int v12 = (_DWORD *)*((void *)a2 + 4);
  }
  *int v12 = v13;
  BOOL result = (void *)(*((void *)a2 + 4) + 4);
  *((void *)a2 + 4) = result;
  uint64_t v15 = *((void *)this + 2);
  if (v15)
  {
    uint64_t v16 = (const void *)*((void *)this + 4);
    size_t v17 = 4 * v15 * *((unsigned int *)this + 6);
    if ((unint64_t)result + v17 > *((void *)a2 + 5))
    {
      CA::Render::Encoder::grow(a2, v17);
      BOOL result = (void *)*((void *)a2 + 4);
    }
    memcpy(result, v16, v17);
    BOOL result = (void *)(*((void *)a2 + 4) + v17);
    *((void *)a2 + 4) = result;
    uint64_t v18 = (const void *)*((void *)this + 5);
    if (v18)
    {
      size_t v19 = 4 * *((void *)this + 2);
      if ((unint64_t)result + v19 > *((void *)a2 + 5))
      {
        CA::Render::Encoder::grow(a2, 4 * *((void *)this + 2));
        BOOL result = (void *)*((void *)a2 + 4);
      }
      memcpy(result, v18, v19);
      BOOL result = (void *)(*((void *)a2 + 4) + v19);
      *((void *)a2 + 4) = result;
    }
    float v20 = (const void *)*((void *)this + 6);
    if (v20)
    {
      uint64_t v21 = 32 * *((void *)this + 2) - 32;
      if ((unint64_t)result + v21 > *((void *)a2 + 5))
      {
        CA::Render::Encoder::grow(a2, v21);
        BOOL result = (void *)*((void *)a2 + 4);
      }
      BOOL result = memcpy(result, v20, v21);
      *((void *)a2 + 4) += v21;
    }
  }
  return result;
}

void CA::Render::anonymous namespace'::cg_image_deleted(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::image_cache_lock);
  uint64_t v5 = x_hash_table_remove(CA::Render::image_cache, a4);
  if (v5)
  {
    uint64_t v6 = (void *)v5;
    if (*(double *)(v5 + 32) > 0.0)
    {
      uint64_t v8 = *(void *)v5;
      unint64_t v7 = *(void **)(v5 + 8);
      *(void *)(v8 + 8) = v7;
      *unint64_t v7 = v8;
      *(void *)uint64_t v5 = v5;
      *(void *)(v5 + 8) = v5;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::image_cache_lock);
    int v9 = (atomic_uint *)v6[3];
    if (v9 && atomic_fetch_add(v9 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v9 + 16))(v9);
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v6);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::image_cache_lock);
  }
}

void CA::Render::Image::finalize(CA::Render::Image *this)
{
  unint64_t v2 = (const void *)*((void *)this + 17);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 17) = 0;
  }
  if (*((void *)this + 16))
  {
    if (CA::Render::tiled_image_mutex_once[0] != -1) {
      dispatch_once_f(CA::Render::tiled_image_mutex_once, 0, (dispatch_function_t)CA::Render::Image::tiled_image_mutex_init);
    }
    pthread_mutex_lock(&CA::Render::Image::_tiled_image_lock);
    for (uint64_t i = *((void *)this + 16); i; uint64_t i = *((void *)this + 16))
    {
      *((void *)this + 16) = *(void *)(i + 128);
      if (atomic_fetch_add((atomic_uint *volatile)(i + 8), 0xFFFFFFFF) == 1) {
        (*(void (**)(uint64_t))(*(void *)i + 16))(i);
      }
    }
    *((void *)this + 16) = 0;
    pthread_mutex_unlock(&CA::Render::Image::_tiled_image_lock);
  }
  if (*((unsigned char *)this + 15))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Image::_subimage_table_lock);
    if (CA::Render::Image::_subimage_table) {
      x_hash_table_remove_if (CA::Render::Image::_subimage_table, (unsigned int (*)(void, void, uint64_t))CA::Render::Image::SubimageKey::delete_images, (uint64_t)this);
    }
    *((_DWORD *)this + 3) &= ~0x1000000u;
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Image::_subimage_table_lock);
  }
  CA::Render::post_notification(3u, (unint64_t)this, 0, 1);
  uint64_t v4 = (atomic_uint *)*((void *)this + 15);
  if (v4)
  {
    *((void *)this + 15) = 0;
    if (atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
    }
  }

  CA::Render::Image::release_data((atomic_uint *)this);
}

void CA::Render::Shmem::~Shmem(CA::Render::Shmem *this)
{
  CA::Render::Shmem::~Shmem(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  const CA::Render::Object *v2;
  void (*v3)(void, void);
  int v4;
  uint64_t v5;
  int *v6;
  unint64_t v7;
  unint64_t v8;

  *(void *)this = &unk_1ED02F520;
  CA::Render::post_notification(3u, (unint64_t)this, 0, 1);
  unint64_t v2 = (const CA::Render::Object *)*((unsigned int *)this + 8);
  if (v2) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], (mach_port_name_t)v2);
  }
  uint64_t v3 = (void (*)(void, void))*((void *)this + 5);
  if (v3) {
    v3(*((void *)this + 3), *((void *)this + 6));
  }
  uint64_t v4 = *((_DWORD *)this + 3);
  if ((v4 & 0x2400) == 0x2000)
  {
    uint64_t v5 = *((void *)this + 2);
    uint64_t v6 = CAGetStatsStruct(0);
    unint64_t v7 = *((void *)v6 + 1);
    uint64_t v8 = *(void *)v6 - v5;
    *(void *)uint64_t v6 = v8;
    if (v8 > v7) {
      *((void *)v6 + 1) = v8;
    }
    uint64_t v4 = *((_DWORD *)this + 3);
  }
  --dword_1EB2ADE84;
  *(void *)this = &unk_1ED02F670;
  if (v4 < 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, v2);
  }
}

uint64_t CA::Render::release_deallocate(CA::Render *this, void *a2, void *a3)
{
  return mach_vm_deallocate(*MEMORY[0x1E4F14960], a2[3] & -*MEMORY[0x1E4F14B00], ((*MEMORY[0x1E4F14B00] + a2[3] + a2[2] - 1) & -*MEMORY[0x1E4F14B00]) - (a2[3] & -*MEMORY[0x1E4F14B00]));
}

void CA::Render::KeyframeAnimation::encode(CA::Render::KeyframeAnimation *this, CA::Render::Encoder *a2)
{
  CA::Render::PropertyAnimation::encode((void **)this, a2);
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 14));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 15));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 16));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 17));
  char v4 = *((unsigned char *)this + 144);
  uint64_t v5 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    uint64_t v5 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v5 + 1;
  *uint64_t v5 = v4;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 19));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 20));
  uint64_t v6 = (const CA::Render::Object *)*((void *)this + 21);

  CA::Render::Encoder::encode_object(a2, v6);
}

void CA::Render::Array::encode(CA::Render::Array *this, CA::Render::Encoder *a2)
{
  int v4 = *((_DWORD *)this + 3) >> 8;
  uint64_t v5 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v5 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = *((void *)a2 + 5);
  uint64_t v8 = (_DWORD *)(v6 + 4);
  *((void *)a2 + 4) = v6 + 4;
  int v9 = *((_DWORD *)this + 4);
  if (v6 + 8 > v7)
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v8 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v8 = v9;
  uint64_t v10 = (void *)(*((void *)a2 + 4) + 4);
  *((void *)a2 + 4) = v10;
  int v11 = *((_DWORD *)this + 4);
  if (*((unsigned char *)this + 13))
  {
    if (v11)
    {
      unint64_t v13 = 0;
      do
      {
        uint64_t v14 = *((void *)this + v13 + 3);
        if ((unint64_t)(v10 + 1) > *((void *)a2 + 5))
        {
          CA::Render::Encoder::grow(a2, 8);
          uint64_t v10 = (void *)*((void *)a2 + 4);
        }
        void *v10 = v14;
        uint64_t v10 = (void *)(*((void *)a2 + 4) + 8);
        *((void *)a2 + 4) = v10;
        ++v13;
      }
      while (v13 < *((unsigned int *)this + 4));
    }
  }
  else if (v11)
  {
    unint64_t v12 = 0;
    do
      CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + v12++ + 3));
    while (v12 < *((unsigned int *)this + 4));
  }
}

void *CA::Render::Vector::encode(CA::Render::Vector *this, CA::Render::Encoder *a2)
{
  int v4 = *((_DWORD *)this + 4);
  uint64_t v5 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v5 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v5 = v4;
  unint64_t v6 = *((void *)a2 + 5);
  unint64_t v7 = (void *)(*((void *)a2 + 4) + 4);
  *((void *)a2 + 4) = v7;
  size_t v8 = 8 * *((unsigned int *)this + 4);
  if ((unint64_t)v7 + v8 > v6)
  {
    CA::Render::Encoder::grow(a2, 8 * *((unsigned int *)this + 4));
    unint64_t v7 = (void *)*((void *)a2 + 4);
  }
  BOOL result = memcpy(v7, (char *)this + 24, v8);
  *((void *)a2 + 4) += v8;
  return result;
}

void *CA::Render::PresentationModifier::encode(CA::Render::PresentationModifier *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 2));
  uint64_t v4 = *((void *)this + 3);
  uint64_t v5 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    uint64_t v5 = (void *)*((void *)a2 + 4);
  }
  *uint64_t v5 = v4;
  *((void *)a2 + 4) += 8;
  BOOL result = CA::Render::Encoder::encode_keypath(a2, (void *const *)this + 4);
  int v7 = *((_DWORD *)this + 10);
  size_t v8 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v8 + 1) > *((void *)a2 + 5))
  {
    BOOL result = CA::Render::Encoder::grow(a2, 4);
    size_t v8 = (_DWORD *)*((void *)a2 + 4);
  }
  *size_t v8 = v7;
  *((void *)a2 + 4) += 4;
  return result;
}

CA::Render::Encoder *CA::Render::Encoder::encode_keypath(CA::Render::Encoder *this, void *const *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = (unsigned int *)*a2;
  if (*a2)
  {
    if (v4) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = *v4;
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  unint64_t v6 = (_WORD *)*((void *)this + 4);
  if ((unint64_t)(v6 + 1) > *((void *)this + 5))
  {
    this = (CA::Render::Encoder *)CA::Render::Encoder::grow(this, 2);
    unint64_t v6 = (_WORD *)*((void *)v3 + 4);
  }
  *unint64_t v6 = v5;
  *((void *)v3 + 4) += 2;
  if (v5)
  {
    for (unint64_t i = 0; v5 != i; ++i)
    {
      unint64_t v8 = (unint64_t)*a2;
      if (!*a2) {
        goto LABEL_14;
      }
      if (v8)
      {
        unint64_t v10 = v8 >> 1;
        if (i) {
          unsigned int v9 = 0;
        }
        else {
          unsigned int v9 = v10;
        }
        goto LABEL_18;
      }
      if (i < *(unsigned int *)v8) {
        unsigned int v9 = *(_DWORD *)(v8 + 4 * i + 4);
      }
      else {
LABEL_14:
      }
        unsigned int v9 = 0;
LABEL_18:
      int v11 = (unsigned char *)*((void *)v3 + 4);
      if ((unint64_t)(v11 + 1) > *((void *)v3 + 5))
      {
        this = (CA::Render::Encoder *)CA::Render::Encoder::grow(v3, 1);
        int v11 = (unsigned char *)*((void *)v3 + 4);
      }
      *((void *)v3 + 4) = v11 + 1;
      *int v11 = (v9 & 0x40000000) >> 30;
      if ((v9 & 0x40000000) != 0)
      {
        unint64_t v12 = (unsigned int *)*((void *)v3 + 4);
        if ((unint64_t)(v12 + 1) > *((void *)v3 + 5))
        {
          this = (CA::Render::Encoder *)CA::Render::Encoder::grow(v3, 4);
          unint64_t v12 = (unsigned int *)*((void *)v3 + 4);
        }
        *unint64_t v12 = v9 & 0xBFFFFFFF;
        *((void *)v3 + 4) += 4;
      }
      else
      {
        this = CA::Render::Encoder::encode_atom(v3, v9);
      }
    }
  }
  return this;
}

CA::Render::Encoder *CA::Render::Encoder::encode_atom(CA::Render::Encoder *this, unsigned int a2)
{
  uint64_t v3 = this;
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a2 > 0x269)
  {
    uint64_t v5 = (unsigned char *)*((void *)this + 4);
    if ((unint64_t)(v5 + 1) > *((void *)this + 5))
    {
      CA::Render::Encoder::grow(this, 1);
      uint64_t v5 = (unsigned char *)*((void *)v3 + 4);
    }
    *((void *)v3 + 4) = v5 + 1;
    *uint64_t v5 = -1;
    String = CAAtomGetString(a2);
    CStringPtr = (char *)CFStringGetCStringPtr(String, 0x8000100u);
    if (CStringPtr
      || (MEMORY[0x1F4188790](0),
          CStringPtr = v11,
          memset(v11, 0, 256),
          CFStringGetCString(String, v11, 256, 0x8000100u)))
    {
      size_t v8 = strlen(CStringPtr);
    }
    else
    {
      CStringPtr = 0;
      size_t v8 = 0;
    }
    return (CA::Render::Encoder *)CA::Render::Encoder::encode_data(v3, CStringPtr, v8);
  }
  else if (a2 > 0xFD)
  {
    unsigned int v9 = (unsigned char *)*((void *)this + 4);
    if ((unint64_t)(v9 + 1) > *((void *)this + 5))
    {
      this = (CA::Render::Encoder *)CA::Render::Encoder::grow(this, 1);
      unsigned int v9 = (unsigned char *)*((void *)v3 + 4);
    }
    *((void *)v3 + 4) = v9 + 1;
    *unsigned int v9 = -2;
    unint64_t v10 = (_WORD *)*((void *)v3 + 4);
    if ((unint64_t)(v10 + 1) > *((void *)v3 + 5))
    {
      this = (CA::Render::Encoder *)CA::Render::Encoder::grow(v3, 2);
      unint64_t v10 = (_WORD *)*((void *)v3 + 4);
    }
    _WORD *v10 = a2;
    *((void *)v3 + 4) += 2;
  }
  else
  {
    uint64_t v4 = (unsigned char *)*((void *)this + 4);
    if ((unint64_t)(v4 + 1) > *((void *)this + 5))
    {
      this = (CA::Render::Encoder *)CA::Render::Encoder::grow(this, 1);
      uint64_t v4 = (unsigned char *)*((void *)v3 + 4);
    }
    *((void *)v3 + 4) = v4 + 1;
    *uint64_t v4 = a2;
  }
  return this;
}

void CA::Render::KeyValue::encode(CA::Render::KeyValue *this, CA::Render::Encoder *a2)
{
  CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 4));
  uint64_t v4 = (const CA::Render::Object *)*((void *)this + 3);

  CA::Render::Encoder::encode_object(a2, v4);
}

__n128 CA::Render::Texture::encode(CGColorSpaceRef *this, CA::Render::Encoder *a2)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  CA::Render::Encoder::encode_colorspace(a2, this[6]);
  int v5 = *((_DWORD *)this + 8);
  unint64_t v6 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v6 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    unint64_t v6 = (_DWORD *)*((void *)a2 + 4);
  }
  *unint64_t v6 = v5;
  uint64_t v7 = *((void *)a2 + 4);
  unint64_t v8 = *((void *)a2 + 5);
  unsigned int v9 = (_WORD *)(v7 + 4);
  *((void *)a2 + 4) = v7 + 4;
  __int16 v10 = *((_WORD *)this + 12);
  if (v7 + 6 > v8)
  {
    CA::Render::Encoder::grow(a2, 2);
    unsigned int v9 = (_WORD *)*((void *)a2 + 4);
  }
  *unsigned int v9 = v10;
  uint64_t v11 = *((void *)a2 + 4);
  unint64_t v12 = *((void *)a2 + 5);
  unint64_t v13 = (_WORD *)(v11 + 2);
  *((void *)a2 + 4) = v11 + 2;
  __int16 v14 = *((_WORD *)this + 13);
  if (v11 + 4 > v12)
  {
    CA::Render::Encoder::grow(a2, 2);
    unint64_t v13 = (_WORD *)*((void *)a2 + 4);
  }
  *unint64_t v13 = v14;
  uint64_t v15 = *((void *)a2 + 4);
  unint64_t v16 = *((void *)a2 + 5);
  size_t v17 = (_WORD *)(v15 + 2);
  *((void *)a2 + 4) = v15 + 2;
  __int16 v18 = *((_WORD *)this + 14);
  if (v15 + 4 > v16)
  {
    CA::Render::Encoder::grow(a2, 2);
    size_t v17 = (_WORD *)*((void *)a2 + 4);
  }
  *size_t v17 = v18;
  uint64_t v19 = *((void *)a2 + 4);
  unint64_t v20 = *((void *)a2 + 5);
  uint64_t v21 = (_WORD *)(v19 + 2);
  *((void *)a2 + 4) = v19 + 2;
  __int16 v22 = *((_WORD *)this + 15);
  if (v19 + 4 > v20)
  {
    CA::Render::Encoder::grow(a2, 2);
    uint64_t v21 = (_WORD *)*((void *)a2 + 4);
  }
  _WORD *v21 = v22;
  uint64_t v23 = *((void *)a2 + 4);
  float v24 = (_DWORD *)(v23 + 2);
  *((void *)a2 + 4) = v23 + 2;
  uint64_t v25 = (uint64_t)this[5];
  if (!v25)
  {
    if ((unint64_t)(v23 + 6) > *((void *)a2 + 5))
    {
      CA::Render::Encoder::grow(a2, 4);
      float v24 = (_DWORD *)*((void *)a2 + 4);
    }
    *float v24 = 0;
    goto LABEL_38;
  }
  if (v25)
  {
    if (v25 == 1) {
      goto LABEL_35;
    }
LABEL_24:
    if ((unint64_t)(v23 + 6) > *((void *)a2 + 5))
    {
      CA::Render::Encoder::grow(a2, 4);
      float v24 = (_DWORD *)*((void *)a2 + 4);
    }
    *float v24 = -2;
    *((void *)a2 + 4) += 4;
    uint64_t v50 = 0;
    uint64_t v51 = 0;
    CA::Shape::get_bounds(v25, (int *)&v50);
    int v32 = v50;
    uint64_t v33 = (_DWORD *)*((void *)a2 + 4);
    if ((unint64_t)(v33 + 1) > *((void *)a2 + 5))
    {
      CA::Render::Encoder::grow(a2, 4);
      uint64_t v33 = (_DWORD *)*((void *)a2 + 4);
    }
    _DWORD *v33 = v32;
    uint64_t v34 = *((void *)a2 + 4);
    unint64_t v35 = *((void *)a2 + 5);
    float v36 = (_DWORD *)(v34 + 4);
    *((void *)a2 + 4) = v34 + 4;
    int v37 = HIDWORD(v50);
    if (v34 + 8 > v35)
    {
      CA::Render::Encoder::grow(a2, 4);
      float v36 = (_DWORD *)*((void *)a2 + 4);
    }
    *float v36 = v37;
    uint64_t v38 = *((void *)a2 + 4);
    unint64_t v39 = *((void *)a2 + 5);
    uint64_t v40 = (_DWORD *)(v38 + 4);
    *((void *)a2 + 4) = v38 + 4;
    int v41 = v51;
    if (v38 + 8 > v39)
    {
      CA::Render::Encoder::grow(a2, 4);
      uint64_t v40 = (_DWORD *)*((void *)a2 + 4);
    }
    *uint64_t v40 = v41;
    uint64_t v42 = *((void *)a2 + 4);
    unint64_t v43 = *((void *)a2 + 5);
    float v44 = (_DWORD *)(v42 + 4);
    *((void *)a2 + 4) = v42 + 4;
    int v45 = HIDWORD(v51);
    if (v42 + 8 > v43)
    {
      CA::Render::Encoder::grow(a2, 4);
      float v44 = (_DWORD *)*((void *)a2 + 4);
    }
    *float v44 = v45;
    goto LABEL_38;
  }
  int v26 = *(_DWORD *)(v25 + 4);
  if (v26 == 12) {
    goto LABEL_24;
  }
  if (v26 == 6)
  {
LABEL_35:
    if ((unint64_t)(v23 + 6) > *((void *)a2 + 5))
    {
      CA::Render::Encoder::grow(a2, 4);
      float v24 = (_DWORD *)*((void *)a2 + 4);
    }
    *float v24 = -1;
LABEL_38:
    uint64_t v31 = (_DWORD *)(*((void *)a2 + 4) + 4);
    goto LABEL_39;
  }
  if ((unint64_t)(v23 + 6) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    float v24 = (_DWORD *)*((void *)a2 + 4);
  }
  *float v24 = v26;
  unint64_t v27 = *((void *)a2 + 5);
  uint64_t v28 = (void *)(*((void *)a2 + 4) + 4);
  *((void *)a2 + 4) = v28;
  float v29 = (const void *)(v25 + 12);
  uint64_t v30 = 4 * (v26 - 3);
  if ((unint64_t)v28 + v30 > v27)
  {
    CA::Render::Encoder::grow(a2, 4 * (v26 - 3));
    uint64_t v28 = (void *)*((void *)a2 + 4);
  }
  memcpy(v28, v29, 4 * (v26 - 3));
  uint64_t v31 = (_DWORD *)(*((void *)a2 + 4) + v30);
LABEL_39:
  *((void *)a2 + 4) = v31;
  int v46 = *((_DWORD *)this + 14);
  if ((unint64_t)(v31 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v31 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v31 = v46;
  uint64_t v47 = *((void *)a2 + 4);
  uint64_t v48 = (__n128 *)(v47 + 4);
  *((void *)a2 + 4) = v47 + 4;
  if ((*((unsigned char *)this + 14) & 0x10) != 0)
  {
    int v49 = (__n128 *)((char *)this + 60);
    if ((unint64_t)(v47 + 20) > *((void *)a2 + 5))
    {
      CA::Render::Encoder::grow(a2, 16);
      uint64_t v48 = (__n128 *)*((void *)a2 + 4);
    }
    __n128 result = *v49;
    *uint64_t v48 = *v49;
    *((void *)a2 + 4) += 16;
  }
  return result;
}

void CA::Render::Encoder::encode_colorspace(CA::Render::Encoder *this, CGColorSpaceRef space)
{
  if (space)
  {
    if (*((CGColorSpaceRef *)this + 10) == space)
    {
      unint64_t v6 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)(v6 + 1) > *((void *)this + 5))
      {
        CA::Render::Encoder::grow(this, 1);
        unint64_t v6 = (unsigned char *)*((void *)this + 4);
      }
      *((void *)this + 4) = v6 + 1;
      *unint64_t v6 = 3;
    }
    else
    {
      uint64_t v4 = 0;
      while ((CGColorSpaceRef)colorspaces[v4] != space)
      {
        if (++v4 == 32) {
          goto LABEL_19;
        }
      }
      if (!v4)
      {
LABEL_19:
        CFStringRef Name = CGColorSpaceGetName(space);
        if (Name)
        {
          CFStringRef v10 = Name;
          uint64_t v11 = (unsigned char *)*((void *)this + 4);
          if ((unint64_t)(v11 + 1) > *((void *)this + 5))
          {
            CA::Render::Encoder::grow(this, 1);
            uint64_t v11 = (unsigned char *)*((void *)this + 4);
          }
          *((void *)this + 4) = v11 + 1;
          *uint64_t v11 = 4;
          CA::Render::Encoder::encode_cfobject(this, v10);
        }
        else
        {
          CFPropertyListRef v12 = CGColorSpaceCopyPropertyList(space);
          unint64_t v13 = (unsigned char *)*((void *)this + 4);
          if ((unint64_t)(v13 + 1) > *((void *)this + 5))
          {
            CA::Render::Encoder::grow(this, 1);
            unint64_t v13 = (unsigned char *)*((void *)this + 4);
          }
          *((void *)this + 4) = v13 + 1;
          *unint64_t v13 = 2;
          CA::Render::Encoder::encode_cfobject(this, v12);
          if (v12)
          {
            CFRelease(v12);
          }
        }
        return;
      }
      uint64_t v7 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)(v7 + 1) > *((void *)this + 5))
      {
        CA::Render::Encoder::grow(this, 1);
        uint64_t v7 = (unsigned char *)*((void *)this + 4);
      }
      *((void *)this + 4) = v7 + 1;
      *uint64_t v7 = 1;
      unint64_t v8 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)(v8 + 1) > *((void *)this + 5))
      {
        CA::Render::Encoder::grow(this, 1);
        unint64_t v8 = (unsigned char *)*((void *)this + 4);
      }
      *((void *)this + 4) = v8 + 1;
      *unint64_t v8 = v4;
    }
  }
  else
  {
    int v5 = (unsigned char *)*((void *)this + 4);
    if ((unint64_t)(v5 + 1) > *((void *)this + 5))
    {
      CA::Render::Encoder::grow(this, 1);
      int v5 = (unsigned char *)*((void *)this + 4);
    }
    *((void *)this + 4) = v5 + 1;
    *int v5 = 0;
  }
}

double CA::Render::Image::encode(CA::Render::Image *this, CA::Render::Encoder *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  int v4 = *((_DWORD *)this + 3) >> 8;
  int v5 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    int v5 = (_DWORD *)*((void *)a2 + 4);
  }
  *int v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = *((void *)a2 + 5);
  unint64_t v8 = (unsigned char *)(v6 + 4);
  *((void *)a2 + 4) = v6 + 4;
  char v9 = *((unsigned char *)this + 152);
  if (v6 + 5 > v7)
  {
    CA::Render::Encoder::grow(a2, 1);
    unint64_t v8 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v8 + 1;
  *unint64_t v8 = v9;
  char v10 = *((unsigned char *)this + 153);
  uint64_t v11 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v11 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    uint64_t v11 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v11 + 1;
  *uint64_t v11 = v10;
  int v12 = *((_DWORD *)this + 4);
  unint64_t v13 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v13 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    unint64_t v13 = (_DWORD *)*((void *)a2 + 4);
  }
  *unint64_t v13 = v12;
  uint64_t v14 = *((void *)a2 + 4);
  unint64_t v15 = *((void *)a2 + 5);
  unint64_t v16 = (_DWORD *)(v14 + 4);
  *((void *)a2 + 4) = v14 + 4;
  int v17 = *((_DWORD *)this + 5);
  if (v14 + 8 > v15)
  {
    CA::Render::Encoder::grow(a2, 4);
    unint64_t v16 = (_DWORD *)*((void *)a2 + 4);
  }
  *unint64_t v16 = v17;
  __int16 v18 = (void *)(*((void *)a2 + 4) + 4);
  *((void *)a2 + 4) = v18;
  unint64_t v19 = *((unsigned __int8 *)this + 153);
  if (v19 <= 0x20)
  {
    memset(v34, 0, sizeof(v34));
    if (v19)
    {
      memcpy(v34, (char *)this + 160, 8 * v19);
      unint64_t v21 = *((unsigned int *)this + 5);
      if (!is_mul_ok(*(unint64_t *)&v34[0], v21)) {
        goto LABEL_12;
      }
      unint64_t v22 = *(void *)&v34[0] * v21;
      if (!(*(void *)&v34[0] * v21)) {
        goto LABEL_12;
      }
      uint64_t v23 = 1;
      while (v19 != v23)
      {
        unint64_t v24 = v23;
        if (v21 <= 1) {
          unint64_t v21 = 1;
        }
        else {
          unint64_t v21 = v21 >> 1;
        }
        unint64_t v25 = *((void *)v34 + v23);
        if (is_mul_ok(v25, v21))
        {
          unint64_t v26 = v25 * v21;
          if (v25 * v21)
          {
            uint64_t v23 = v24 + 1;
            BOOL v27 = __CFADD__(v22, v26);
            v22 += v26;
            if (!v27) {
              continue;
            }
          }
        }
        if (v24 < v19) {
          goto LABEL_12;
        }
        break;
      }
      unint64_t v28 = 0;
      do
      {
        uint64_t v29 = *((void *)this + v28 + 20);
        if ((unint64_t)(v18 + 1) > *((void *)a2 + 5))
        {
          CA::Render::Encoder::grow(a2, 8);
          __int16 v18 = (void *)*((void *)a2 + 4);
        }
        void *v18 = v29;
        __int16 v18 = (void *)(*((void *)a2 + 4) + 8);
        *((void *)a2 + 4) = v18;
        ++v28;
      }
      while (v28 < *((unsigned __int8 *)this + 153));
    }
    unint64_t v30 = *((void *)a2 + 5);
    if (*((void *)this + 15))
    {
      if ((unint64_t)v18 + 1 > v30)
      {
        CA::Render::Encoder::grow(a2, 1);
        __int16 v18 = (void *)*((void *)a2 + 4);
      }
      *((void *)a2 + 4) = (char *)v18 + 1;
      *(unsigned char *)__int16 v18 = 1;
      CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 15));
      uint64_t v31 = *((void *)this + 15);
      if ((*(unsigned char *)(v31 + 13) & 8) != 0) {
        atomic_fetch_add(*(atomic_uint *volatile *)(v31 + 24), 1u);
      }
    }
    else
    {
      if ((unint64_t)v18 + 1 > v30)
      {
        CA::Render::Encoder::grow(a2, 1);
        __int16 v18 = (void *)*((void *)a2 + 4);
      }
      *((void *)a2 + 4) = (char *)v18 + 1;
      *(unsigned char *)__int16 v18 = 0;
      atomic_fetch_add((atomic_uint *volatile)this + 37, 1u);
      int v32 = (const void *)*((void *)this + 12);
      size_t v33 = CA::Render::Image::data_size(this);
      CA::Render::Encoder::encode_data_async(a2, v32, v33, (uint64_t (*)(const void *, void *))CA::Render::release_image_data, this);
    }
  }
LABEL_12:

  *(void *)&double result = CA::Render::Texture::encode((CGColorSpaceRef *)this, a2).n128_u64[0];
  return result;
}

void *CA::Render::Shmem::encode(CA::Render::Shmem *this, CA::Render::Encoder *a2)
{
  uint64_t v3 = this;
  unsigned int v4 = *((_DWORD *)this + 3);
  int v5 = (unsigned int *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    int v5 = (unsigned int *)*((void *)a2 + 4);
  }
  *int v5 = v4 >> 8;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = (void *)(v6 + 4);
  *((void *)a2 + 4) = v6 + 4;
  if ((v4 & 0x300) != 0)
  {
    uint64_t v8 = *((void *)v3 + 2);
    if ((unint64_t)(v6 + 12) > *((void *)a2 + 5))
    {
      CA::Render::Encoder::grow(a2, 8);
      unint64_t v7 = (void *)*((void *)a2 + 4);
    }
    *unint64_t v7 = v8;
    uint64_t v9 = *((void *)a2 + 4);
    unint64_t v10 = *((void *)a2 + 5);
    uint64_t v11 = (uint64_t *)(v9 + 8);
    *((void *)a2 + 4) = v9 + 8;
    uint64_t v12 = (*MEMORY[0x1E4F14B00] - 1) & *((void *)v3 + 3);
    if (v9 + 16 > v10)
    {
      CA::Render::Encoder::grow(a2, 8);
      uint64_t v11 = (uint64_t *)*((void *)a2 + 4);
    }
    *uint64_t v11 = v12;
    *((void *)a2 + 4) += 8;
    mach_port_name_t v13 = CA::Render::Shmem::port((mach_port_t *)v3);
    CA::Render::Encoder::encode_port_send_right(a2, v13, 0);
    double result = (void *)x_heap_malloc_small_(*((uint64_t **)a2 + 1), 0x10uLL);
    unint64_t v15 = (atomic_uint *)((char *)v3 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)v3 + 2, 1u))
    {
      uint64_t v3 = 0;
      atomic_fetch_add(v15, 0xFFFFFFFF);
    }
    uint64_t v16 = *((void *)a2 + 14);
    *double result = v3;
    result[1] = v16;
    *((void *)a2 + 14) = result;
  }
  else
  {
    double result = CA::Render::Encoder::encode_data_async(a2, *((const void **)v3 + 3), *((void *)v3 + 2), (uint64_t (*)(const void *, void *))CA::Render::release_object, v3);
    if (!atomic_fetch_add((atomic_uint *volatile)v3 + 2, 1u)) {
      atomic_fetch_add((atomic_uint *volatile)v3 + 2, 0xFFFFFFFF);
    }
  }
  return result;
}

uint64_t CA::Render::Encoder::encode_port_send_right(CA::Render::Encoder *this, mach_port_name_t name, BOOL a3)
{
  kern_return_t v6;
  uint64_t result;
  uint64_t v8;

  BOOL v3 = a3;
  mach_port_name_t v4 = name;
  if ((*((unsigned char *)this + 64) & 2) != 0 && !a3)
  {
    uint64_t v6 = mach_port_mod_refs(*MEMORY[0x1E4F14960], name, 0, 1);
    BOOL v3 = v6 == 0;
    if (v6) {
      mach_port_name_t v4 = 0;
    }
  }
  double result = x_heap_malloc_small_(*((uint64_t **)this + 1), 0x30uLL);
  *(_DWORD *)(result + 8) = 2;
  *(_DWORD *)(result + 16) = v4;
  *(_DWORD *)(result + 2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 19;
  *(unsigned char *)(result + 24) = v3;
  uint64_t v8 = *((void *)this + 7);
  *(void *)double result = *((void *)this + 6);
  *((void *)this + 6) = result;
  *((void *)this + 7) = v8 + 1;
  return result;
}

uint64_t CA::Render::Shmem::port(mach_port_t *object_handle)
{
  kern_return_t memory_entry_64;
  NSObject *v7;
  mach_port_t v8;
  memory_object_size_t size;
  uint8_t buf[4];
  memory_object_size_t v11;
  __int16 v12;
  memory_object_offset_t v13;
  __int16 v14;
  vm_prot_t v15;
  __int16 v16;
  mach_port_t v17;
  __int16 v18;
  kern_return_t v19;
  uint64_t v20;

  unint64_t v20 = *MEMORY[0x1E4F143B8];
  BOOL v3 = object_handle + 8;
  uint64_t result = object_handle[8];
  if (!result)
  {
    vm_prot_t v4 = (object_handle[3] & 0x100) != 0 ? 5242883 : 5242881;
    memory_object_offset_t v5 = *((void *)object_handle + 3);
    size = *((void *)object_handle + 2);
    memory_entry_64 = mach_make_memory_entry_64(*MEMORY[0x1E4F14960], &size, v5, v4, v3, 0);
    uint64_t result = object_handle[8];
    if (!result)
    {
      if (CADeviceHasInternalBuild::once[0] != -1) {
        dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
      }
      if (CADeviceHasInternalBuild::internal)
      {
        x_log_crash("CoreAnimation: mach_make_memory_entry_64 (size %llu, addr 0x%llx, prot 0x%x, port %u) = 0x%x", size, v5, v4, *v3, memory_entry_64);
        abort();
      }
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unint64_t v7 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          uint64_t v8 = *v3;
          *(_DWORD *)buf = 134219008;
          uint64_t v11 = size;
          uint64_t v12 = 2048;
          mach_port_name_t v13 = v5;
          uint64_t v14 = 1024;
          unint64_t v15 = v4;
          uint64_t v16 = 1024;
          int v17 = v8;
          __int16 v18 = 1024;
          unint64_t v19 = memory_entry_64;
          _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_ERROR, "CoreAnimation: mach_make_memory_entry_64 (size %llu, addr 0x%llx, prot 0x%x, port %u) = 0x%x", buf, 0x28u);
        }
      }
      return *v3;
    }
  }
  return result;
}

void CA::Render::Filter::encode(CA::Render::Filter *this, CA::Render::Encoder *a2)
{
  int v4 = *((_DWORD *)this + 3) >> 8;
  memory_object_offset_t v5 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    memory_object_offset_t v5 = (_DWORD *)*((void *)a2 + 4);
  }
  *memory_object_offset_t v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = (unsigned char *)(v6 + 4);
  *((void *)a2 + 4) = v6 + 4;
  if (*((unsigned char *)this + 14))
  {
    unsigned int v9 = *((_DWORD *)this + 6);
    CA::Render::Encoder::encode_atom(a2, v9);
  }
  else
  {
    if ((unint64_t)(v6 + 5) > *((void *)a2 + 5))
    {
      CA::Render::Encoder::grow(a2, 1);
      unint64_t v7 = (unsigned char *)*((void *)a2 + 4);
    }
    *((void *)a2 + 4) = v7 + 1;
    *unint64_t v7 = 1;
    CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 6));
    CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 4));
    uint64_t v8 = (const CA::Render::Object *)*((void *)this + 5);
    CA::Render::Encoder::encode_object(a2, v8);
  }
}

void *CA::Render::String::encode(CA::Render::String *this, CA::Render::Encoder *a2)
{
  int v4 = *((_DWORD *)this + 6);
  memory_object_offset_t v5 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    memory_object_offset_t v5 = (_DWORD *)*((void *)a2 + 4);
  }
  *memory_object_offset_t v5 = v4;
  unint64_t v6 = *((void *)a2 + 5);
  unint64_t v7 = (void *)(*((void *)a2 + 4) + 4);
  *((void *)a2 + 4) = v7;
  size_t v8 = *((unsigned int *)this + 6);
  if ((unint64_t)v7 + v8 > v6)
  {
    CA::Render::Encoder::grow(a2, *((unsigned int *)this + 6));
    unint64_t v7 = (void *)*((void *)a2 + 4);
  }
  uint64_t result = memcpy(v7, (char *)this + 28, v8);
  *((void *)a2 + 4) += v8;
  return result;
}

void CA::Render::BasicAnimation0::encode(CA::Render::BasicAnimation0 *this, CA::Render::Encoder *a2)
{
  CA::Render::PropertyAnimation::encode((void **)this, a2);
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 14));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 15));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 16));
  uint64_t v4 = *((void *)this + 17);
  memory_object_offset_t v5 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    memory_object_offset_t v5 = (void *)*((void *)a2 + 4);
  }
  *memory_object_offset_t v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = *((void *)a2 + 5);
  size_t v8 = (void *)(v6 + 8);
  *((void *)a2 + 4) = v6 + 8;
  uint64_t v9 = *((void *)this + 18);
  if (v6 + 16 > v7)
  {
    CA::Render::Encoder::grow(a2, 8);
    size_t v8 = (void *)*((void *)a2 + 4);
  }
  *size_t v8 = v9;
  *((void *)a2 + 4) += 8;
}

void CA::Render::PropertyAnimation::encode(void **this, CA::Render::Encoder *a2)
{
  CA::Render::Animation::encode((CA::Render::Animation *)this, a2);
  CA::Render::Encoder::encode_keypath(a2, this + 12);
  uint64_t v4 = (const CA::Render::Object *)this[13];

  CA::Render::Encoder::encode_object(a2, v4);
}

void CA::Render::Animation::encode(CA::Render::Animation *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  if (*((void *)this + 5))
  {
    (*(void (**)(CA::Render::Encoder *, void))(*(void *)a2 + 32))(a2, *((void *)this + 2));
    uint64_t v4 = (const CA::Render::Object *)*((void *)this + 5);
  }
  else
  {
    uint64_t v4 = 0;
  }
  CA::Render::Encoder::encode_object(a2, v4);
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 6));
  CA::Render::Encoder::encode_cfobject(a2, *((const void **)this + 7));
  int v5 = *((_DWORD *)this + 18);
  uint64_t v6 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v6 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v6 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v6 = v5;
  uint64_t v7 = *((void *)a2 + 4);
  unint64_t v8 = *((void *)a2 + 5);
  uint64_t v9 = (unsigned int *)(v7 + 4);
  *((void *)a2 + 4) = v7 + 4;
  unsigned int v10 = *((float *)this + 6);
  if (v7 + 8 > v8)
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v9 = (unsigned int *)*((void *)a2 + 4);
  }
  *uint64_t v9 = v10;
  uint64_t v11 = *((void *)a2 + 4);
  unint64_t v12 = *((void *)a2 + 5);
  mach_port_name_t v13 = (unsigned int *)(v11 + 4);
  *((void *)a2 + 4) = v11 + 4;
  unsigned int v14 = *((float *)this + 7);
  if (v11 + 8 > v12)
  {
    CA::Render::Encoder::grow(a2, 4);
    mach_port_name_t v13 = (unsigned int *)*((void *)a2 + 4);
  }
  *mach_port_name_t v13 = v14;
  uint64_t v15 = *((void *)a2 + 4);
  unint64_t v16 = *((void *)a2 + 5);
  int v17 = (unsigned int *)(v15 + 4);
  *((void *)a2 + 4) = v15 + 4;
  unsigned int v18 = *((float *)this + 8);
  if (v15 + 8 > v16)
  {
    CA::Render::Encoder::grow(a2, 4);
    int v17 = (unsigned int *)*((void *)a2 + 4);
  }
  *int v17 = v18;
  uint64_t v19 = *((void *)a2 + 4);
  unint64_t v20 = *((void *)a2 + 5);
  unint64_t v21 = (_DWORD *)(v19 + 4);
  *((void *)a2 + 4) = v19 + 4;
  int v22 = *((_DWORD *)this + 22);
  if (v19 + 8 > v20)
  {
    CA::Render::Encoder::grow(a2, 4);
    unint64_t v21 = (_DWORD *)*((void *)a2 + 4);
  }
  _DWORD *v21 = v22;
  *((void *)a2 + 4) += 4;
}

void CA::Render::Encoder::encode_cfobject(CA::Render::Encoder *this, const void *a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](this);
  uint64_t v4 = v3;
  int v5 = (CA::Render::Encoder *)v2;
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (CA::Render::cacftype_from_cfobject(void const*)::once == -1)
  {
    if (v3) {
      goto LABEL_3;
    }
  }
  else
  {
    dispatch_once(&CA::Render::cacftype_from_cfobject(void const*)::once, &__block_literal_global_261);
    if (v4)
    {
LABEL_3:
      if ((__CFString *)*MEMORY[0x1E4F1D260] == v4)
      {
        LODWORD(v7) = 1;
      }
      else
      {
        CFTypeID v6 = CFGetTypeID(v4);
        uint64_t v7 = 0;
        while (CA::Render::cacftype_from_cfobject(void const*)::cfTypeIds[v7] != v6)
        {
          if (++v7 == 14)
          {
            if (v6 == CA::Render::cacftype_from_cfobject(void const*)::ns_object_type_id
              && (objc_opt_isKindOfClass() & 1) != 0)
            {
              LODWORD(v7) = 12;
              goto LABEL_13;
            }
            goto LABEL_12;
          }
        }
      }
      goto LABEL_13;
    }
  }
LABEL_12:
  LODWORD(v7) = 0;
LABEL_13:
  unint64_t v8 = (unsigned char *)*((void *)v5 + 4);
  if ((unint64_t)(v8 + 1) > *((void *)v5 + 5))
  {
    CA::Render::Encoder::grow(v5, 1);
    unint64_t v8 = (unsigned char *)*((void *)v5 + 4);
  }
  *((void *)v5 + 4) = v8 + 1;
  *unint64_t v8 = v7;
  switch((int)v7)
  {
    case 2:
      bzero(&valuePtr, 0x1000uLL);
      CString = CA_CFStringGetCString(v4, valuePtr.i8, 4096);
      unint64_t v12 = (BOOL *)*((void *)v5 + 4);
      if ((unint64_t)(v12 + 1) > *((void *)v5 + 5))
      {
        CA::Render::Encoder::grow(v5, 1);
        unint64_t v12 = (BOOL *)*((void *)v5 + 4);
      }
      *((void *)v5 + 4) = v12 + 1;
      *unint64_t v12 = CString != 0;
      if (CString)
      {
        size_t v13 = strlen(CString) + 1;
        unsigned int v14 = v5;
        p_int8x16_t valuePtr = (int32x4_t *)CString;
        goto LABEL_91;
      }
      return;
    case 3:
      CFNumberType Type = CFNumberGetType((CFNumberRef)v4);
      if ((unint64_t)Type <= kCFNumberCGFloatType && ((1 << Type) & 0x13060) != 0)
      {
        valuePtr.i64[0] = 0;
        if (!CFNumberGetValue((CFNumberRef)v4, kCFNumberDoubleType, &valuePtr)) {
          valuePtr.i64[0] = 0;
        }
        int v17 = (unsigned char *)*((void *)v5 + 4);
        if ((unint64_t)(v17 + 1) > *((void *)v5 + 5))
        {
          CA::Render::Encoder::grow(v5, 1);
          int v17 = (unsigned char *)*((void *)v5 + 4);
        }
        *((void *)v5 + 4) = v17 + 1;
        *int v17 = 0;
        uint64_t v18 = valuePtr.i64[0];
        uint64_t v19 = (uint64_t *)*((void *)v5 + 4);
        if ((unint64_t)(v19 + 1) > *((void *)v5 + 5))
        {
          CA::Render::Encoder::grow(v5, 8);
          uint64_t v19 = (uint64_t *)*((void *)v5 + 4);
        }
        uint64_t *v19 = v18;
      }
      else
      {
        valuePtr.i64[0] = 0;
        if (!CFNumberGetValue((CFNumberRef)v4, kCFNumberLongLongType, &valuePtr)) {
          valuePtr.i64[0] = 0;
        }
        uint64_t v48 = (unsigned char *)*((void *)v5 + 4);
        if ((unint64_t)(v48 + 1) > *((void *)v5 + 5))
        {
          CA::Render::Encoder::grow(v5, 1);
          uint64_t v48 = (unsigned char *)*((void *)v5 + 4);
        }
        *((void *)v5 + 4) = v48 + 1;
        *uint64_t v48 = 1;
        uint64_t v49 = valuePtr.i64[0];
        uint64_t v50 = (uint64_t *)*((void *)v5 + 4);
        if ((unint64_t)(v50 + 1) > *((void *)v5 + 5))
        {
          CA::Render::Encoder::grow(v5, 8);
          uint64_t v50 = (uint64_t *)*((void *)v5 + 4);
        }
        *uint64_t v50 = v49;
      }
      uint64_t v20 = *((void *)v5 + 4) + 8;
      goto LABEL_73;
    case 4:
      Boolean Value = CFBooleanGetValue((CFBooleanRef)v4);
      int v22 = (Boolean *)*((void *)v5 + 4);
      if ((unint64_t)(v22 + 1) > *((void *)v5 + 5))
      {
        CA::Render::Encoder::grow(v5, 1);
        int v22 = (Boolean *)*((void *)v5 + 4);
      }
      *((void *)v5 + 4) = v22 + 1;
      *int v22 = Value;
      return;
    case 5:
      BytePtr = CFDataGetBytePtr((CFDataRef)v4);
      size_t Length = CFDataGetLength((CFDataRef)v4);
      unint64_t v25 = (void *)CFRetain(v4);
      CA::Render::Encoder::encode_data_async(v5, BytePtr, Length, (uint64_t (*)(const void *, void *))CA::Render::release_cfdata, v25);
      return;
    case 6:
      CFIndex Count = CFArrayGetCount((CFArrayRef)v4);
      BOOL v27 = (CFIndex *)*((void *)v5 + 4);
      if ((unint64_t)(v27 + 1) > *((void *)v5 + 5))
      {
        CA::Render::Encoder::grow(v5, 8);
        BOOL v27 = (CFIndex *)*((void *)v5 + 4);
      }
      CFIndex *v27 = Count;
      *((void *)v5 + 4) += 8;
      if (Count)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v4, i);
          CA::Render::Encoder::encode_cfobject(v5, ValueAtIndex);
        }
      }
      return;
    case 7:
      CFIndex v30 = CFDictionaryGetCount((CFDictionaryRef)v4);
      uint64_t v31 = (CFIndex *)*((void *)v5 + 4);
      if ((unint64_t)(v31 + 1) > *((void *)v5 + 5))
      {
        CA::Render::Encoder::grow(v5, 8);
        uint64_t v31 = (CFIndex *)*((void *)v5 + 4);
      }
      *uint64_t v31 = v30;
      *((void *)v5 + 4) += 8;
      CFDictionaryApplyFunction((CFDictionaryRef)v4, (CFDictionaryApplierFunction)CA::Render::encode_dictionary_item, v5);
      return;
    case 8:
      CA::Render::Encoder::encode_colorspace(v5, (CGColorSpaceRef)v4);
      return;
    case 9:
      ColorSpace = CGImageGetColorSpace((CGImageRef)v4);
      size_t v33 = (atomic_uint *)CA::Render::copy_image((CA::Render *)v4, ColorSpace, 0, 0.0, 1.0);
      __int32 v34 = *((unsigned __int8 *)v33 + 12);
      uint64_t v35 = (unsigned char *)*((void *)v5 + 4);
      if ((unint64_t)(v35 + 1) > *((void *)v5 + 5))
      {
        CA::Render::Encoder::grow(v5, 1);
        uint64_t v35 = (unsigned char *)*((void *)v5 + 4);
      }
      *((void *)v5 + 4) = v35 + 1;
      *uint64_t v35 = v34;
      if (v34 == 51 || v34 == 23)
      {
        CA::Render::Encoder::encode_object(v5, (const CA::Render::Object *)v33);
      }
      else if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v51 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          valuePtr.i32[0] = 67109120;
          valuePtr.i32[1] = v34;
          _os_log_impl(&dword_184668000, v51, OS_LOG_TYPE_DEFAULT, "encode kCACFTypeImage got unsupported type %d", (uint8_t *)&valuePtr, 8u);
        }
      }
      if (atomic_fetch_add(v33 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v33 + 16))(v33);
      }
      return;
    case 10:
      int v37 = (CGColor *)CAGetColorSpace(0x1Cu);
      int8x16_t valuePtr = 0uLL;
      CA::Render::convert_cgcolor_to_float((CGColor *)v4, v37, (CGColorSpace *)&valuePtr, 0, v38);
      int32x4_t v39 = (int32x4_t)valuePtr;
      if (*(float *)&valuePtr.i32[3] != 0.0 && *(float *)&valuePtr.i32[3] != 1.0)
      {
        *(float32x2_t *)v41.i8 = vdiv_f32(*(float32x2_t *)valuePtr.i8, (float32x2_t)vdup_laneq_s32((int32x4_t)valuePtr, 3));
        v41.i64[1] = __PAIR64__(vextq_s8(valuePtr, valuePtr, 8uLL).u32[1], *(float *)&valuePtr.i32[2] / *(float *)&valuePtr.i32[3]);
        int32x4_t v39 = v41;
      }
      uint64_t v42 = (int32x4_t *)*((void *)v5 + 4);
      if ((unint64_t)&v42[1] > *((void *)v5 + 5))
      {
        int32x4_t v52 = v39;
        CA::Render::Encoder::grow(v5, 16);
        int32x4_t v39 = v52;
        uint64_t v42 = (int32x4_t *)*((void *)v5 + 4);
      }
      *uint64_t v42 = v39;
      uint64_t v20 = *((void *)v5 + 4) + 16;
LABEL_73:
      *((void *)v5 + 4) = v20;
      return;
    case 11:
    case 13:
      uint64_t v9 = (atomic_uint *)[(__CFString *)v4 CA_copyRenderValue];
      CA::Render::Encoder::encode_object(v5, (const CA::Render::Object *)v9);
      if (v9 && atomic_fetch_add(v9 + 2, 0xFFFFFFFF) == 1)
      {
        unsigned int v10 = *(void (**)(atomic_uint *))(*(void *)v9 + 16);
        v10(v9);
      }
      return;
    case 12:
      unint64_t v43 = (const char *)[(__CFString *)v4 objCType];
      if (!strcmp(v43, "{CGPoint=dd}"))
      {
        char v44 = 0;
LABEL_87:
        uint64_t v45 = 16;
        goto LABEL_88;
      }
      if (!strcmp(v43, "{CGSize=dd}"))
      {
        char v44 = 1;
        goto LABEL_87;
      }
      if (!strcmp(v43, "{CGRect={CGPoint=dd}{CGSize=dd}}"))
      {
        char v44 = 2;
        uint64_t v45 = 32;
      }
      else if (!strcmp(v43, "{CATransform3D=dddddddddddddddd}"))
      {
        char v44 = 3;
        uint64_t v45 = 128;
      }
      else if (!strcmp(v43, "{CGAffineTransform=dddddd}"))
      {
        char v44 = 4;
        uint64_t v45 = 48;
      }
      else if (!strcmp(v43, "{CAPoint3D=ddd}"))
      {
        char v44 = 5;
        uint64_t v45 = 24;
      }
      else if (!strcmp(v43, "{CACornerRadii={CGSize=dd}{CGSize=dd}{CGSize=dd}{CGSize=dd}}"))
      {
        char v44 = 6;
        uint64_t v45 = 64;
      }
      else
      {
        if (strcmp(v43, "{CAColorMatrix=ffffffffffffffffffff}")) {
          return;
        }
        char v44 = 7;
        uint64_t v45 = 80;
      }
LABEL_88:
      [(__CFString *)v4 getValue:&valuePtr size:v45];
      uint64_t v47 = (char *)*((void *)v5 + 4);
      if ((unint64_t)(v47 + 1) > *((void *)v5 + 5))
      {
        CA::Render::Encoder::grow(v5, 1);
        uint64_t v47 = (char *)*((void *)v5 + 4);
      }
      *((void *)v5 + 4) = v47 + 1;
      *uint64_t v47 = v44;
      p_int8x16_t valuePtr = (int32x4_t *)&valuePtr;
      unsigned int v14 = v5;
      size_t v13 = v45;
LABEL_91:
      CA::Render::Encoder::encode_data(v14, p_valuePtr, v13);
      return;
    default:
      return;
  }
}

void *CA::Render::Encoder::encode_data(CA::Render::Encoder *this, const void *__src, size_t a3)
{
  CFTypeID v6 = (size_t *)*((void *)this + 4);
  if ((unint64_t)(v6 + 1) > *((void *)this + 5))
  {
    CA::Render::Encoder::grow(this, 8);
    CFTypeID v6 = (size_t *)*((void *)this + 4);
  }
  *CFTypeID v6 = a3;
  uint64_t result = (void *)(*((void *)this + 4) + 8);
  *((void *)this + 4) = result;
  if (a3)
  {
    if ((unint64_t)result + a3 > *((void *)this + 5))
    {
      CA::Render::Encoder::grow(this, a3);
      uint64_t result = (void *)*((void *)this + 4);
    }
    uint64_t result = memcpy(result, __src, a3);
    *((void *)this + 4) += a3;
  }
  return result;
}

void *CA::Render::Timing::encode(CA::Render::Timing *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  int v4 = *((_DWORD *)this + 4);
  int v5 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    int v5 = (_DWORD *)*((void *)a2 + 4);
  }
  *int v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = *((void *)a2 + 5);
  unint64_t v8 = (void *)(v6 + 4);
  *((void *)a2 + 4) = v6 + 4;
  uint64_t v9 = *((void *)this + 3);
  if (v6 + 12 > v7)
  {
    CA::Render::Encoder::grow(a2, 8);
    unint64_t v8 = (void *)*((void *)a2 + 4);
  }
  *unint64_t v8 = v9;
  uint64_t v10 = *((void *)a2 + 4);
  unint64_t v11 = *((void *)a2 + 5);
  unint64_t v12 = (void *)(v10 + 8);
  *((void *)a2 + 4) = v10 + 8;
  uint64_t v13 = *((void *)this + 4);
  if (v10 + 16 > v11)
  {
    CA::Render::Encoder::grow(a2, 8);
    unint64_t v12 = (void *)*((void *)a2 + 4);
  }
  *unint64_t v12 = v13;
  *((void *)a2 + 4) += 8;
  uint64_t result = (void *)(*(uint64_t (**)(CA::Render::Encoder *))(*(void *)a2 + 40))(a2);
  uint64_t v15 = *((void *)this + 5);
  unint64_t v16 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v16 + 1) > *((void *)a2 + 5))
  {
    uint64_t result = CA::Render::Encoder::grow(a2, 8);
    unint64_t v16 = (void *)*((void *)a2 + 4);
  }
  *unint64_t v16 = v15;
  uint64_t v17 = *((void *)a2 + 4);
  unint64_t v18 = *((void *)a2 + 5);
  uint64_t v19 = (void *)(v17 + 8);
  *((void *)a2 + 4) = v17 + 8;
  uint64_t v20 = *((void *)this + 6);
  if (v17 + 16 > v18)
  {
    uint64_t result = CA::Render::Encoder::grow(a2, 8);
    uint64_t v19 = (void *)*((void *)a2 + 4);
  }
  void *v19 = v20;
  uint64_t v21 = *((void *)a2 + 4);
  unint64_t v22 = *((void *)a2 + 5);
  uint64_t v23 = (void *)(v21 + 8);
  *((void *)a2 + 4) = v21 + 8;
  uint64_t v24 = *((void *)this + 7);
  if (v21 + 16 > v22)
  {
    uint64_t result = CA::Render::Encoder::grow(a2, 8);
    uint64_t v23 = (void *)*((void *)a2 + 4);
  }
  *uint64_t v23 = v24;
  *((void *)a2 + 4) += 8;
  return result;
}

void CA::Render::release_image_data(CA::Render *this, atomic_uint *a2, void *a3)
{
}

_DWORD *CA::Render::Encoder::encode_data_async(CA::Render::Encoder *this, const void *__src, size_t a3, uint64_t (*a4)(const void *, void *), void *a5)
{
  if (HIDWORD(a3))
  {
    if (CADeviceHasInternalBuild::once[0] != -1) {
      dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
    }
    if (CADeviceHasInternalBuild::internal)
    {
      x_log_crash("Cannot send %zu bytes to the server. This exceeds mach ool capabilities!", a3);
      abort();
    }
  }
  uint64_t v9 = (size_t *)*((void *)this + 4);
  unint64_t v10 = *((void *)this + 5);
  unint64_t v11 = v9 + 1;
  if (*MEMORY[0x1E4F14B00] <= a3)
  {
    if ((unint64_t)v11 > v10)
    {
      CA::Render::Encoder::grow(this, 8);
      uint64_t v9 = (size_t *)*((void *)this + 4);
    }
    *uint64_t v9 = -1;
    *((void *)this + 4) += 8;
    uint64_t result = (_DWORD *)x_heap_malloc_small_(*((uint64_t **)this + 1), 0x30uLL);
    result[2] = 1;
    *((void *)result + 2) = __src;
    *((void *)result + 3) = a3;
    *((void *)result + 4) = a4;
    *((void *)result + 5) = a5;
    uint64_t v13 = *((void *)this + 7);
    *(void *)uint64_t result = *((void *)this + 6);
    *((void *)this + 6) = result;
    *((void *)this + 7) = v13 + 1;
  }
  else
  {
    if ((unint64_t)v11 > v10)
    {
      CA::Render::Encoder::grow(this, 8);
      uint64_t v9 = (size_t *)*((void *)this + 4);
    }
    *uint64_t v9 = a3;
    uint64_t result = (_DWORD *)(*((void *)this + 4) + 8);
    *((void *)this + 4) = result;
    if (a3)
    {
      if ((unint64_t)result + a3 > *((void *)this + 5))
      {
        CA::Render::Encoder::grow(this, a3);
        uint64_t result = (_DWORD *)*((void *)this + 4);
      }
      uint64_t result = memcpy(result, __src, a3);
      *((void *)this + 4) += a3;
    }
    if (a4)
    {
      return (_DWORD *)a4(__src, a5);
    }
  }
  return result;
}

void *CA::Render::Encoder::grow(CA::Render::Encoder *this, uint64_t a2)
{
  uint64_t v3 = *((void *)this + 3);
  int64_t v4 = *((void *)this + 5) - v3;
  size_t v5 = *((void *)this + 4) - v3;
  BOOL v6 = v4 < 0;
  size_t v7 = v5 + a2;
  if (__CFADD__(v5, a2)) {
    BOOL v6 = 1;
  }
  uint64_t v8 = *MEMORY[0x1E4F14B00] - 1;
  BOOL v9 = __CFADD__(v8, 2 * v4);
  uint64_t v10 = v8 + 2 * v4;
  if (v9) {
    BOOL v6 = 1;
  }
  size_t v11 = v10 & -*MEMORY[0x1E4F14B00];
  if (v11 >= v7)
  {
    size_t v12 = v10 & -*MEMORY[0x1E4F14B00];
  }
  else
  {
    do
    {
      BOOL v6 = (v6 | (v11 >> 63)) != 0;
      v11 *= 2;
      size_t v12 = v11;
    }
    while (v11 < v7);
  }
  if (v6)
  {
    x_log_crash("Encoder size overflow, old size = %zu, extra = %zu\n");
    goto LABEL_18;
  }
  uint64_t v13 = (char *)mmap(0, v12, 3, 4098, 855638016, 0);
  if (v13 == (char *)-1)
  {
    x_log_crash("Failed to allocate %zu bytes, requested = %zu, old size = %zu\n");
LABEL_18:
    abort();
  }
  unsigned int v14 = v13;
  uint64_t result = memcpy(v13, *((const void **)this + 3), v5);
  int v16 = *((_DWORD *)this + 4);
  if ((v16 & 0x100) != 0) {
    uint64_t result = (void *)munmap(*((void **)this + 3), v4);
  }
  else {
    *((_DWORD *)this + 4) = v16 & 0xFFFF00FF | 0x100;
  }
  *((void *)this + 3) = v14;
  *((void *)this + 4) = &v14[v5];
  *((void *)this + 5) = &v14[v12];
  return result;
}

atomic_uint *CA::Render::Surface::unref_image_data(atomic_uint *this)
{
  unsigned int add = atomic_fetch_add(this + 81, 0xFFFFFFFF);
  if (this)
  {
    if (add == 1) {
      return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)this + 8))();
    }
  }
  return this;
}

void CA::Render::release_cfdata(CA::Render *this, CFTypeRef cf, void *a3)
{
}

uint64_t CA::Render::Surface::finalize(CA::Render::Surface *this)
{
  CA::Render::post_notification(3u, (unint64_t)this, 0, 1);
  uint64_t v2 = (atomic_uint *)*((void *)this + 12);
  if (v2)
  {
    *((void *)this + 12) = 0;
    if (atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
    }
  }
  uint64_t v3 = (atomic_uint *)*((void *)this + 20);
  if (v3)
  {
    *((void *)this + 2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
    if (atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
    }
  }
  int64_t v4 = *(uint64_t (**)(CA::Render::Surface *))(*(void *)this + 184);

  return v4(this);
}

uint64_t CAGetCurrentImageBytes()
{
  return *(void *)CAGetStatsStruct(0);
}

int *CA::Render::aligned_free(CA::Render *this, size_t a2, void *a3)
{
  munmap(this, a2);
  uint64_t result = CAGetStatsStruct(0);
  size_t v5 = *((void *)result + 1);
  size_t v6 = *(void *)result - a2;
  *(void *)uint64_t result = v6;
  if (v6 > v5) {
    *((void *)result + 1) = v6;
  }
  return result;
}

unsigned __int16 *CA::Render::anonymous namespace'::create_image_by_copying(CA::Render::_anonymous_namespace_ *a1, unsigned int a2, CGColorSpace *a3, uint64_t a4, CA::Render *a5, unint64_t a6, CA::Render *a7, __int16 a8)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if ((a8 & 0x200) != 0) {
    return 0;
  }
  char v8 = a8;
  unsigned int v14 = a1;
  kdebug_trace();
  memset(v43, 0, sizeof(v43));
  int32x4_t v41 = 0;
  uint64_t v42 = 0;
  if (v16)
  {
    unsigned int v17 = v16;
    int32x4_t v39 = a3;
    unint64_t v18 = (unsigned __int16 *)CA::Render::aligned_malloc(v42, (unint64_t *)&v41, 0);
    if (v18)
    {
      if (a7 > 0x25) {
        unsigned int v19 = 0;
      }
      else {
        unsigned int v19 = dword_184999468[a7];
      }
      if (a5)
      {
        CGBlt_copyBytes();
      }
      else
      {
        CGAccessSessionCreate();
        unint64_t v21 = a6 - v19 * (unint64_t)v14;
        unint64_t v22 = *(void *)&v43[0] - v19 * (unint64_t)v14;
        if (v21 <= v22) {
          unint64_t v23 = a6;
        }
        else {
          unint64_t v23 = v19 * (unint64_t)v14;
        }
        if (v21 <= v22) {
          unint64_t v24 = 0;
        }
        else {
          unint64_t v24 = a6 - v19 * (unint64_t)v14;
        }
        unint64_t v36 = v23;
        unint64_t v37 = v24;
        if (v21 <= v22) {
          unint64_t v25 = a6 - v19 * (unint64_t)v14;
        }
        else {
          unint64_t v25 = 0;
        }
        if (a2)
        {
          unint64_t v35 = v22 - v25;
          unsigned int v38 = a2;
          unint64_t v26 = v18;
          while (1)
          {
            unint64_t v27 = v36;
            if (v36) {
              break;
            }
LABEL_25:
            unsigned int v29 = v38 - 1;
            if (v37 && v38 != 1) {
              CGAccessSessionSkipForward();
            }
            unint64_t v26 = (unsigned __int16 *)((char *)v26 + v35);
            --v38;
            if (!v29) {
              goto LABEL_29;
            }
          }
          while (1)
          {
            uint64_t Bytes = CGAccessSessionGetBytes();
            if (Bytes - 1 >= v27) {
              break;
            }
            unint64_t v26 = (unsigned __int16 *)((char *)v26 + Bytes);
            v27 -= Bytes;
            if (!v27) {
              goto LABEL_25;
            }
          }
        }
LABEL_29:
        CGAccessSessionRelease();
      }
      if (v17 >= 2) {
      CFIndex v30 = v41;
      }
      MEMORY[0x185325430](*MEMORY[0x1E4F14960], v18, v41, 1, 1);
      uint64_t v31 = CA::Render::Image::new_image(a7, a1, a2, v17, v39, (CGColorSpace *)v18, (unint64_t *)v43, (const unint64_t *)CA::Render::aligned_free, v30, v34);
      unint64_t v18 = (unsigned __int16 *)v31;
      if (v31) {
        *((_DWORD *)v31 + 3) |= 0x800000u;
      }
      else {
        CA::Render::aligned_free(a5, (size_t)v30, v32);
      }
    }
  }
  else
  {
    unint64_t v18 = 0;
  }
  kdebug_trace();
  return v18;
}

void *CA::Render::aligned_malloc(CA::Render *this, unint64_t *a2, void **a3)
{
  if (!this) {
    return 0;
  }
  uint64_t v3 = *MEMORY[0x1E4F14B00];
  if (*MEMORY[0x1E4F14B00] < (unint64_t)a3) {
    __assert_rtn("aligned_malloc", "render-image.cpp", 753, "align <= PAGE_SIZE");
  }
  unint64_t v4 = (unint64_t)this + v3 - 1;
  uint64_t v5 = -v3;
  unint64_t v6 = v4 & v5;
  if ((v4 & v5) == 0) {
    return 0;
  }
  char v8 = mmap(0, v4 & v5, 3, 4098, 855638016, 0);
  if (v8 == (void *)-1) {
    return 0;
  }
  BOOL v9 = v8;
  *a2 = v6;
  uint64_t v10 = CAGetStatsStruct(0);
  unint64_t v11 = *((void *)v10 + 1);
  unint64_t v12 = *(void *)v10 + v6;
  *(void *)uint64_t v10 = v12;
  if (v12 > v11) {
    *((void *)v10 + 1) = v12;
  }
  return v9;
}

_DWORD *CA::Render::Shmem::new_bitmap(CA::Render::Shmem *this, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  {
    unsigned int v40 = a2;
    a2 = v40;
  }
  {
    if (this <= 0x25
    {
      unint64_t v11 = dword_184999468[this];
    }
    unint64_t v12 = v11 + 35;
    if ((v11 & (v11 - 1)) != 0) {
      uint64_t v13 = v12 / v11 * v11;
    }
    else {
      uint64_t v13 = v12 & -(uint64_t)v11;
    }
  }
  else
  {
    uint64_t v13 = 36;
  }
  unsigned int v42 = a2;
  if (!a6)
  {
    uint64_t v17 = 0;
LABEL_26:
    if (__CFADD__(v13, v17) || (unint64_t)(v13 + v17) >= 0xFFFFFFFF)
    {
      if (x_log_hook_p())
      {
LABEL_40:
        x_log_();
      }
      else
      {
        unsigned int v33 = a6;
        uint64_t v34 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218752;
          *(void *)uint64_t v44 = v13 + v17;
          *(_WORD *)&v44[8] = 1024;
          *(_DWORD *)uint64_t v45 = v42;
          *(_WORD *)&v45[4] = 1024;
          unsigned int v46 = a3;
          __int16 v47 = 1024;
          unsigned int v48 = v33;
          unint64_t v35 = "Layer backing store allocation too large size:%ld width:%d height:%d levels:%d";
          unint64_t v36 = v34;
          uint32_t v37 = 30;
LABEL_45:
          _os_log_impl(&dword_184668000, v36, OS_LOG_TYPE_ERROR, v35, buf, v37);
        }
      }
    }
    else
    {
      unint64_t v23 = CA::Render::Shmem::new_shmem((CA::Render::Shmem *)(v13 + v17));
      unint64_t v21 = v23;
      if (!v23) {
        return v21;
      }
      unsigned int v24 = a6;
      unint64_t v25 = (_DWORD *)*((void *)v23 + 3);
      if (v25)
      {
        unsigned int v26 = a3;
        v23[3] |= 0x2800u;
        uint64_t v27 = *((void *)v23 + 2);
        unint64_t v28 = CAGetStatsStruct(0);
        unint64_t v29 = *((void *)v28 + 1);
        unint64_t v30 = *(void *)v28 + v27;
        *(void *)unint64_t v28 = v30;
        if (v30 > v29) {
          *((void *)v28 + 1) = v30;
        }
        if (a4) {
          unsigned int v31 = a4;
        }
        else {
          unsigned int v31 = v42;
        }
        v25[2] = v13;
        v25[3] = this;
        if (a5) {
          unsigned int v32 = a5;
        }
        else {
          unsigned int v32 = v26;
        }
        v25[4] = v42;
        v25[5] = v26;
        v25[6] = v31;
        v25[7] = v32;
        v25[8] = v24;
        return v21;
      }
      if (atomic_fetch_add(v23 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(_DWORD *))(*(void *)v23 + 16))(v23);
      }
    }
    return 0;
  }
  uint64_t v14 = v13;
  unsigned int v15 = a4;
  unsigned int v16 = a5;
  uint64_t v17 = 0;
  unsigned int v41 = a6;
  unsigned int v18 = a3;
  unsigned int v19 = a2;
  while (1)
  {
    unint64_t v20 = CA::Render::format_rowbytes(this, v19);
    unint64_t v21 = 0;
    if (!is_mul_ok(v20, a3)) {
      return v21;
    }
    unint64_t v22 = v20 * a3;
    if (!v22) {
      return v21;
    }
    v17 += v22;
    if (v19 <= 1) {
      unsigned int v19 = 1;
    }
    else {
      v19 >>= 1;
    }
    if (a3 <= 1) {
      a3 = 1;
    }
    else {
      a3 >>= 1;
    }
    if (!--a6)
    {
      a6 = v41;
      a5 = v16;
      a3 = v18;
      a4 = v15;
      uint64_t v13 = v14;
      if (v41 < 0x21) {
        goto LABEL_26;
      }
      if (x_log_hook_p()) {
        goto LABEL_40;
      }
      uint64_t v38 = x_log_category_render;
      if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)uint64_t v44 = v42;
      *(_WORD *)&v44[4] = 1024;
      *(_DWORD *)&v44[6] = a3;
      *(_WORD *)uint64_t v45 = 1024;
      *(_DWORD *)&v45[2] = v41;
      unint64_t v35 = "Invalid bitmap: [%u x %u], %u levels";
      unint64_t v36 = v38;
      uint32_t v37 = 20;
      goto LABEL_45;
    }
  }
}

void CARecordFrame(int a1, int a2, int a3, char a4, double a5, double a6, double a7)
{
  uint64_t v13 = CAGetStatsStruct(a4);
  int v14 = v13[8];
  int v15 = v13[7] + a1;
  int v16 = v13[6] + a2;
  int v17 = v13[5] + 1;
  double v18 = *((double *)v13 + 6) + a7;
  *((double *)v13 + 5) = *((double *)v13 + 5) + a6;
  *((double *)v13 + 6) = v18;
  v13[5] = v17;
  v13[6] = v16;
  v13[7] = v15;
  v13[8] = v14 + a3;
  double v19 = *((double *)v13 + 8);
  double v20 = *((double *)v13 + 9);
  if (v19 <= 0.0) {
    double v19 = a5;
  }
  double v21 = a5 - v19;
  *((double *)v13 + 8) = a5;
  if (v21 > v20) {
    *((double *)v13 + 9) = v21;
  }

  CAMarkStatistic((uint64_t)v13, a5);
}

int *CAGetStatsStruct(char a1)
{
  unsigned int v2 = CARecordCurrentDisplayGet();
  if (a1) {
    return (int *)&CAGetStatsStruct(BOOL)::iosurface_renderer_stats;
  }
  int v4 = v2;
  if (!v2) {
    return (int *)&CAGetStatsStruct(BOOL)::ogl_renderer_stats_unknown;
  }
  if (v2 == 1) {
    return (int *)&CAGetStatsStruct(BOOL)::ogl_renderer_stats_main;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CAGetStatsStruct(BOOL)::_ogl_renderer_stats_list_lock);
  unint64_t v6 = CAGetStatsStruct(BOOL)::_ogl_renderer_stats_list[0];
  uint64_t v5 = off_1E8F84A08[0];
  if (CAGetStatsStruct(BOOL)::_ogl_renderer_stats_list[0] == off_1E8F84A08[0])
  {
LABEL_11:
    uint64_t v8 = 0x4EC4EC4EC4EC4EC5
       * (((char *)off_1E8F84A08[0] - (char *)CAGetStatsStruct(BOOL)::_ogl_renderer_stats_list[0]) >> 3);
    if (qword_1E8F84A18 < (unint64_t)(v8 + 1))
    {
      BOOL v9 = off_1E8F84A10;
      unint64_t v10 = (qword_1E8F84A18 + 1) | ((unint64_t)(qword_1E8F84A18 + 1) >> 1) | (((qword_1E8F84A18 + 1) | ((unint64_t)(qword_1E8F84A18 + 1) >> 1)) >> 2);
      unint64_t v11 = v10 | (v10 >> 4) | ((v10 | (v10 >> 4)) >> 8);
      unint64_t v12 = v11 | (v11 >> 16) | ((v11 | (v11 >> 16)) >> 32);
      if (v12 + 1 > v8 + 1) {
        uint64_t v13 = v12 + 1;
      }
      else {
        uint64_t v13 = v8 + 1;
      }
      int v14 = (int *)malloc_type_malloc(104 * v13, 0x10000409D46D3AFuLL);
      int v15 = v14;
      int v16 = CAGetStatsStruct(BOOL)::_ogl_renderer_stats_list[0];
      int v17 = off_1E8F84A08[0];
      if (CAGetStatsStruct(BOOL)::_ogl_renderer_stats_list[0] != off_1E8F84A08[0])
      {
        double v18 = v14;
        do
        {
          long long v19 = *(_OWORD *)v16;
          long long v20 = *((_OWORD *)v16 + 2);
          *((_OWORD *)v18 + 1) = *((_OWORD *)v16 + 1);
          *((_OWORD *)v18 + 2) = v20;
          *(_OWORD *)double v18 = v19;
          long long v21 = *((_OWORD *)v16 + 3);
          long long v22 = *((_OWORD *)v16 + 4);
          long long v23 = *((_OWORD *)v16 + 5);
          *((void *)v18 + 12) = *((void *)v16 + 12);
          *((_OWORD *)v18 + 4) = v22;
          *((_OWORD *)v18 + 5) = v23;
          *((_OWORD *)v18 + 3) = v21;
          v18 += 26;
          v16 += 26;
        }
        while (v16 != v17);
      }
      if (v6 != v9) {
        free(CAGetStatsStruct(BOOL)::_ogl_renderer_stats_list[0]);
      }
      uint64_t v5 = &v15[26 * v8];
      CAGetStatsStruct(BOOL)::_ogl_renderer_stats_list[0] = v15;
      off_1E8F84A08[0] = v5;
      qword_1E8F84A18 = v13;
    }
    *((void *)v5 + 12) = 0;
    *((_OWORD *)v5 + 4) = 0u;
    *((_OWORD *)v5 + 5) = 0u;
    *((_OWORD *)v5 + 2) = 0u;
    *((_OWORD *)v5 + 3) = 0u;
    *(_OWORD *)uint64_t v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    size_t v7 = off_1E8F84A08[0];
    unsigned int v24 = off_1E8F84A08[0];
    *off_1E8F84A08[0] = v4;
    off_1E8F84A08[0] = v24 + 26;
  }
  else
  {
    size_t v7 = CAGetStatsStruct(BOOL)::_ogl_renderer_stats_list[0];
    while (*v7 != v4)
    {
      v7 += 26;
      if (v7 == off_1E8F84A08[0]) {
        goto LABEL_11;
      }
    }
  }
  uint64_t v3 = v7 + 2;
  os_unfair_lock_unlock((os_unfair_lock_t)&CAGetStatsStruct(BOOL)::_ogl_renderer_stats_list_lock);
  return v3;
}

_DWORD *CARecordCurrentDisplayGet()
{
  uint64_t result = (_DWORD *)current_display_slot;
  if (current_display_slot)
  {
    uint64_t result = pthread_getspecific(current_display_slot);
    if (result)
    {
      if (*result)
      {
        unsigned int v1 = *result - 1;
        if (v1 >= 3) {
          unsigned int v1 = 3;
        }
        return (_DWORD *)result[v1 + 1];
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

_DWORD *CA::Render::Shmem::new_shmem(CA::Render::Shmem *this)
{
  kern_return_t v2;
  vm_address_t v3;
  BOOL v4;
  malloc_zone_t *malloc_zone;
  _DWORD *result;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int (*v10)(uint8_t *, uint64_t, uint64_t);
  vm_address_t address;
  uint8_t buf[16];
  long long v13;
  long long v14;
  long long v15;
  long long v16;
  long long v17;
  long long v18;
  long long v19;
  long long v20;
  long long v21;
  long long v22;
  long long v23;
  long long v24;
  long long v25;
  long long v26;
  long long v27;
  uint64_t v28;

  unint64_t v28 = *MEMORY[0x1E4F143B8];
  address = 0;
  unsigned int v2 = vm_allocate(*MEMORY[0x1E4F14960], &address, ((unint64_t)this + *MEMORY[0x1E4F14B00] - 1) & -*MEMORY[0x1E4F14B00], 855638019);
  uint64_t v3 = address;
  if (v2) {
    int v4 = 1;
  }
  else {
    int v4 = address == 0;
  }
  if (v4)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      size_t v7 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = this;
        _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_ERROR, "CoreAnimation: failed to allocate %ld bytes\n", buf, 0xCu);
      }
    }
    return 0;
  }
  else
  {
    if (*MEMORY[0x1E4F1CBC0])
    {
      uint64_t v8 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 592);
      if (v8)
      {
        unint64_t v10 = *(unsigned int (**)(uint8_t *, uint64_t, uint64_t))v8;
        BOOL v9 = *(void *)(v8 + 8);
        unsigned int v26 = 0u;
        uint64_t v27 = 0u;
        unsigned int v24 = 0u;
        unint64_t v25 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        long long v20 = 0u;
        long long v21 = 0u;
        double v18 = 0u;
        long long v19 = 0u;
        int v16 = 0u;
        int v17 = 0u;
        int v14 = 0u;
        int v15 = 0u;
        *(_OWORD *)buf = 0u;
        uint64_t v13 = 0u;
        if (v10(buf, 256, v9)) {
          __CFSetLastAllocationEventName();
        }
      }
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t result = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x38uLL, 0x743898A5uLL);
    if (result)
    {
      result[2] = 1;
      result[3] = 4399;
      ++dword_1EB2ADE84;
      *(void *)uint64_t result = &unk_1ED02F520;
      *((void *)result + 2) = this;
      *((void *)result + 3) = v3;
      result[8] = 0;
      *((void *)result + 5) = CA::Render::release_deallocate;
      *((void *)result + 6) = result;
      result[9] = 0;
    }
  }
  return result;
}

unint64_t CA::Render::anonymous namespace'::compute_image_levels(CA::Render::_anonymous_namespace_ *this, unsigned int a2, CA::Render *a3, char a4, unint64_t *a5, unint64_t *a6, unint64_t *a7)
{
  unsigned int v10 = this;
  unint64_t v11 = a2;
  if ((a4 & 1) != 0 && (a3 > 0x13 || ((1 << (char)a3) & 0xC00C0) == 0))
  {
    uint64_t v14 = 0;
    unint64_t v12 = 0;
    while (1)
    {
      unint64_t result = CA::Render::format_rowbytes(a3, v10);
      a5[v14] = result;
      if (!result) {
        break;
      }
      v12 += result * v11;
      if (v10 < 9 || v11 < 9)
      {
        unint64_t result = v14 + 1;
        if (v14 != -1) {
          goto LABEL_7;
        }
        goto LABEL_5;
      }
      v10 >>= 1;
      v11 >>= 1;
      ++v14;
    }
  }
  else
  {
    unint64_t v12 = 0;
LABEL_5:
    unint64_t result = CA::Render::format_rowbytes(a3, v10);
    *a5 = result;
    if (result)
    {
      v12 += result * v11;
      unint64_t result = 1;
LABEL_7:
      *a6 = v12;
    }
  }
  return result;
}

void CA::Render::DeferredEncoder::mark_begin_time(CA::Render::DeferredEncoder *this)
{
  unint64_t v2 = *((void *)this + 23);
  if (v2)
  {
    unint64_t v3 = *((void *)this + 19);
    if (v3)
    {
      uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v3);
      v4.i16[0] = vaddlv_u8(v4);
      if (v4.u32[0] > 1uLL)
      {
        unint64_t v5 = *((void *)this + 23);
        if (v2 >= v3) {
          unint64_t v5 = v2 % v3;
        }
      }
      else
      {
        unint64_t v5 = (v3 - 1) & v2;
      }
      unint64_t v6 = *(void **)(*((void *)this + 18) + 8 * v5);
      if (v6)
      {
        for (CFIndex i = (void *)*v6; i; CFIndex i = (void *)*i)
        {
          unint64_t v8 = i[1];
          if (v8 == v2)
          {
            if (i[2] == v2) {
              goto LABEL_75;
            }
          }
          else
          {
            if (v4.u32[0] > 1uLL)
            {
              if (v8 >= v3) {
                v8 %= v3;
              }
            }
            else
            {
              v8 &= v3 - 1;
            }
            if (v8 != v5) {
              break;
            }
          }
        }
      }
    }
    else
    {
      unint64_t v5 = 0;
    }
    uint64_t v9 = *((void *)this + 4) - *((void *)this + 3);
    unsigned int v10 = operator new(0x20uLL);
    void *v10 = 0;
    v10[1] = v2;
    v10[2] = v2;
    v10[3] = v9;
    float v11 = (float)(unint64_t)(*((void *)this + 21) + 1);
    float v12 = *((float *)this + 44);
    if (v3 && (float)(v12 * (float)v3) >= v11)
    {
LABEL_65:
      uint64_t v29 = *((void *)this + 18);
      unint64_t v30 = *(void **)(v29 + 8 * v5);
      if (v30)
      {
        void *v10 = *v30;
      }
      else
      {
        uint64_t v31 = *((void *)this + 20);
        void *v10 = v31;
        *((void *)this + 2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v10;
        *(void *)(v29 + 8 * v5) = (char *)this + 160;
        if (!v31)
        {
LABEL_74:
          ++*((void *)this + 21);
          goto LABEL_75;
        }
        unint64_t v32 = *(void *)(v31 + 8);
        if ((v3 & (v3 - 1)) != 0)
        {
          if (v32 >= v3) {
            v32 %= v3;
          }
        }
        else
        {
          v32 &= v3 - 1;
        }
        unint64_t v30 = (void *)(*((void *)this + 18) + 8 * v32);
      }
      void *v30 = v10;
      goto LABEL_74;
    }
    BOOL v13 = 1;
    if (v3 >= 3) {
      BOOL v13 = (v3 & (v3 - 1)) != 0;
    }
    unint64_t v14 = v13 | (2 * v3);
    unint64_t v15 = vcvtps_u32_f32(v11 / v12);
    if (v14 <= v15) {
      int8x8_t prime = (int8x8_t)v15;
    }
    else {
      int8x8_t prime = (int8x8_t)v14;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v3 = *((void *)this + 19);
    }
    if (*(void *)&prime > v3) {
      goto LABEL_31;
    }
    if (*(void *)&prime < v3)
    {
      unint64_t v23 = vcvtps_u32_f32((float)*((unint64_t *)this + 21) / *((float *)this + 44));
      if (v3 < 3 || (uint8x8_t v24 = (uint8x8_t)vcnt_s8((int8x8_t)v3), v24.i16[0] = vaddlv_u8(v24), v24.u32[0] > 1uLL))
      {
        unint64_t v23 = std::__next_prime(v23);
      }
      else
      {
        uint64_t v25 = 1 << -(char)__clz(v23 - 1);
        if (v23 >= 2) {
          unint64_t v23 = v25;
        }
      }
      if (*(void *)&prime <= v23) {
        int8x8_t prime = (int8x8_t)v23;
      }
      if (*(void *)&prime >= v3)
      {
        unint64_t v3 = *((void *)this + 19);
      }
      else
      {
        if (prime)
        {
LABEL_31:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          int v17 = operator new(8 * *(void *)&prime);
          double v18 = (void *)*((void *)this + 18);
          *((void *)this + 18) = v17;
          if (v18) {
            operator delete(v18);
          }
          uint64_t v19 = 0;
          *((int8x8_t *)this + 19) = prime;
          do
            *(void *)(*((void *)this + 18) + 8 * v19++) = 0;
          while (*(void *)&prime != v19);
          long long v20 = (void *)*((void *)this + 20);
          if (v20)
          {
            unint64_t v21 = v20[1];
            uint8x8_t v22 = (uint8x8_t)vcnt_s8(prime);
            v22.i16[0] = vaddlv_u8(v22);
            if (v22.u32[0] > 1uLL)
            {
              if (v21 >= *(void *)&prime) {
                v21 %= *(void *)&prime;
              }
            }
            else
            {
              v21 &= *(void *)&prime - 1;
            }
            *(void *)(*((void *)this + 18) + 8 * v21) = (char *)this + 160;
            unsigned int v26 = (void *)*v20;
            if (*v20)
            {
              do
              {
                unint64_t v27 = v26[1];
                if (v22.u32[0] > 1uLL)
                {
                  if (v27 >= *(void *)&prime) {
                    v27 %= *(void *)&prime;
                  }
                }
                else
                {
                  v27 &= *(void *)&prime - 1;
                }
                if (v27 != v21)
                {
                  uint64_t v28 = *((void *)this + 18);
                  if (!*(void *)(v28 + 8 * v27))
                  {
                    *(void *)(v28 + 8 * v27) = v20;
                    goto LABEL_56;
                  }
                  *long long v20 = *v26;
                  *unsigned int v26 = **(void **)(*((void *)this + 18) + 8 * v27);
                  **(void **)(*((void *)this + 18) + 8 * v27) = v26;
                  unsigned int v26 = v20;
                }
                unint64_t v27 = v21;
LABEL_56:
                long long v20 = v26;
                unsigned int v26 = (void *)*v26;
                unint64_t v21 = v27;
              }
              while (v26);
            }
          }
          unint64_t v3 = (unint64_t)prime;
          goto LABEL_60;
        }
        unsigned int v33 = (void *)*((void *)this + 18);
        *((void *)this + 18) = 0;
        if (v33) {
          operator delete(v33);
        }
        unint64_t v3 = 0;
        *((void *)this + 19) = 0;
      }
    }
LABEL_60:
    if ((v3 & (v3 - 1)) != 0)
    {
      if (v2 >= v3) {
        unint64_t v5 = v2 % v3;
      }
      else {
        unint64_t v5 = v2;
      }
    }
    else
    {
      unint64_t v5 = (v3 - 1) & v2;
    }
    goto LABEL_65;
  }
LABEL_75:
  *((void *)this + 23) = 0;
}

uint64_t CA::Render::DeferredEncoder::mark_timing(uint64_t this, uint64_t a2)
{
  *(void *)(this + 184) = a2;
  return this;
}

double CA::Transform::invert(int8x16_t *this, uint64_t a2, const double *a3)
{
  __int8 v3 = this[9].i8[0];
  if ((v3 & 0x10) != 0)
  {
    CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)this, (CA::Mat4Impl *)this, a3);
    return result;
  }
  double v4 = *(double *)this[6].i64;
  double v5 = -*(double *)&this[6].i64[1];
  if (this[9].i8[0]) {
    double v5 = *(double *)&this[6].i64[1];
  }
  if ((this[9].i8[0] & 2) == 0) {
    double v4 = -v4;
  }
  if ((this[9].i8[0] & 4) != 0) {
    double v6 = v5;
  }
  else {
    double v6 = v4;
  }
  if ((this[9].i8[0] & 4) != 0) {
    double result = -v4;
  }
  else {
    double result = v5;
  }
  if ((this[9].i8[0] & 8) != 0)
  {
    double v9 = *(double *)&this[8].i64[1];
    *(double *)this[6].i64 = v9 * v6;
    *(double *)&this[6].i64[1] = v9 * result;
    this[8] = vextq_s8(this[8], this[8], 8uLL);
    int v8 = image_queue_rotation_from_logical_rotation(CAMetalLayerRotation,BOOL)::invert_table[v3 & 7];
    if ((v3 & 7) == v8) {
      return CA::Transform::set_2x2((CA::Transform *)this);
    }
LABEL_17:
    this[9].i8[0] = v3 & 0xF8 | v8 & 7;
    return CA::Transform::set_2x2((CA::Transform *)this);
  }
  *(double *)this[6].i64 = v6;
  *(double *)&this[6].i64[1] = result;
  int v8 = image_queue_rotation_from_logical_rotation(CAMetalLayerRotation,BOOL)::invert_table[v3 & 7];
  if ((v3 & 7) != v8) {
    goto LABEL_17;
  }
  return result;
}

uint64_t CA::OGL::MetalContext::encode_asg77_weights(CA::OGL::MetalContext *this, const CA::OGL::MetalContext::FragmentShader::Spec *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  char v2 = *((unsigned char *)this + 3408);
  if ((v2 & 8) == 0)
  {
    uint64_t v4 = *((void *)this + 507);
    if (!v4)
    {
      double v5 = (void *)[*((id *)this + 369) newBufferWithLength:6144 options:0];
      *((void *)this + 507) = v5;
      [v5 setLabel:@"com.apple.coreanimation.asg77-weights"];
      uint64_t result = *((void *)this + 507);
      if (!result) {
        return result;
      }
      size_t v7 = (_WORD *)[(id)result contents];
      unint64_t v8 = 0;
      double v9 = &word_18499C90C;
      do
      {
        unint64_t v10 = 0;
        float v11 = &word_18499C90C;
        do
        {
          uint64_t v12 = 0;
          long long v35 = 0uLL;
          long long v36 = 0uLL;
          BOOL v13 = (float *)&v34;
          float v14 = 0.0;
          unint64_t v15 = v11;
          long long v34 = 0uLL;
          do
          {
            uint64_t v16 = 0;
            int v17 = v9;
            do
            {
              if (v12 && v12 != 3 || v16 && v16 != 3)
              {
                float v18 = 0.0;
                char v19 = 1;
                long long v20 = v17;
                unint64_t v21 = v15;
                float v22 = 0.0;
                do
                {
                  char v23 = v19;
                  int v24 = *v20;
                  v20 -= 4;
                  float v22 = v22 + (float)v24;
                  int v25 = *v21;
                  v21 -= 4;
                  float v18 = v18 + (float)v25;
                  char v19 = 0;
                }
                while ((v23 & 1) != 0);
                float v26 = (float)(v22 * 0.25) * v18;
                *v13++ = v26;
                float v14 = v26 + v14;
              }
              ++v16;
              ++v17;
            }
            while (v16 != 4);
            ++v12;
            ++v15;
          }
          while (v12 != 4);
          uint64_t v27 = 0;
          float v28 = 1.0 / v14;
          do
          {
            _S4 = *(float *)((char *)&v34 + v27) * v28;
            __asm { FCVT            H4, S4 }
            *v7++ = LOWORD(_S4);
            v27 += 4;
          }
          while (v27 != 48);
          v11 -= 8;
          _CF = v10 >= 0x1E;
          v10 += 2;
        }
        while (!_CF);
        v9 -= 8;
        _CF = v8 >= 0x1E;
        v8 += 2;
      }
      while (!_CF);
      char v2 = *((unsigned char *)this + 3408);
      uint64_t v4 = *((void *)this + 507);
    }
    *((unsigned char *)this + 3408) = v2 | 8;
    objc_msgSend(*((id *)this + 373), "setFragmentBuffer:offset:atIndex:", v4, 0, 8, v34, v35, v36);
  }
  return 1;
}

void sub_18475DEB0(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_18475DF54(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void ___ZL18shared_server_initPv_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = (void *)[a4 state];
  int v5 = [v4 taskState];
  if (v5 == 4)
  {
    if (objc_msgSend((id)objc_msgSend(v4, "endowmentNamespaces"), "containsObject:", @"com.apple.frontboard.visibility"))CA::Render::post_notification(0x2Bu, 0, 0, 0); {
  }
    }
  else if ((v5 - 3) > 1)
  {
    return;
  }
  CA::Render::post_notification(0x2Cu, 0, 0, 0);

  CA::Render::post_notification(0x2Eu, 0, 0, 0);
}

void ___ZN2CA12WindowServer12IOMFBDisplay15process_monitorEv_block_invoke(uint64_t a1, uint64_t pid, int a3, int a4)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a1 + 32);
  if (byte_1EB2ACC45)
  {
    memset(buffer, 0, sizeof(buffer));
    proc_name(pid, buffer, 0x20u);
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      int v25 = x_log_category_frame_rate;
      if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109890;
        int v27 = pid;
        __int16 v28 = 2080;
        uint64_t v29 = buffer;
        __int16 v30 = 1024;
        int v31 = a3;
        __int16 v32 = 1024;
        int v33 = a4;
        _os_log_impl(&dword_184668000, v25, OS_LOG_TYPE_DEFAULT, "CAFrameRateServer: monitored process %u[%s] running: %d, suspended: %d", buf, 0x1Eu);
      }
    }
  }
  unint64_t v8 = (os_unfair_lock_s *)(v7 + 27396);
  os_unfair_lock_lock((os_unfair_lock_t)(v7 + 27396));
  uint64_t v16 = *(unsigned char **)(v7 + 27400);
  int v17 = *(unsigned char **)(v7 + 27408);
  if (v16 != v17)
  {
    while (*(_DWORD *)v16 != pid)
    {
      v16 += 24;
      if (v16 == v17) {
        goto LABEL_10;
      }
    }
  }
  if (v16 != v17)
  {
    char v18 = v16[20];
    if ((a3 & 1) == 0)
    {
      unint64_t v21 = v16 + 24;
      uint64_t v22 = v17 - (v16 + 24);
      if (v17 != v16 + 24) {
        memmove(v16, v21, v17 - (v16 + 24));
      }
      *(void *)(v7 + 27408) = &v16[v22];
      if ((v18 & 1) == 0) {
        CA::WindowServer::IOMFBDisplay::recompute_server_frame_interval_locked((CA::WindowServer::IOMFBDisplay *)v7, (uint64_t)v21, v10, v11, v12, v13, v14, v15);
      }
      goto LABEL_26;
    }
    if (((((v18 & 1) == 0) ^ a4) & 1) == 0)
    {
      v16[20] = v18 & 0xFE | a4;
      CA::WindowServer::IOMFBDisplay::recompute_server_frame_interval_locked((CA::WindowServer::IOMFBDisplay *)v7, v9, v10, v11, v12, v13, v14, v15);
    }
  }
LABEL_10:
  os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 27396));
  unint64_t v8 = (os_unfair_lock_s *)(v7 + 27448);
  os_unfair_lock_lock((os_unfair_lock_t)(v7 + 27448));
  uint64_t v19 = *(void *)(v7 + 27456);
  uint64_t v20 = *(void *)(v7 + 27464);
  if (v19 != v20)
  {
    while (*(_DWORD *)v19 != pid)
    {
      v19 += 28;
      if (v19 == v20) {
        goto LABEL_17;
      }
    }
  }
  if (v19 == v20)
  {
LABEL_17:
    os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 27448));
    if (a3) {
      return;
    }
    goto LABEL_27;
  }
  if (a3)
  {
    *(unsigned char *)(v19 + 24) = a4;
    os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 27448));
    return;
  }
  uint64_t v23 = v20 - (v19 + 28);
  if (v20 != v19 + 28) {
    memmove((void *)v19, (const void *)(v19 + 28), v20 - (v19 + 28));
  }
  *(void *)(v7 + 27464) = v19 + v23;
LABEL_26:
  os_unfair_lock_unlock(v8);
LABEL_27:
  int v24 = *(void **)(v7 + 27440);

  [v24 removeMonitoringProcess:pid];
}

void sub_18475EAF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18475ECD8(_Unwind_Exception *a1)
{
}

uint64_t class_substitutions(void)
{
  id v0 = objc_alloc(MEMORY[0x1E4F1C9E8]);
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  return objc_msgSend(v0, "initWithObjectsAndKeys:", v1, @"LKState", v2, @"LKStateAddAnimation", v3, @"LKStateAddElement", v4, @"LKStateElement", v5, @"LKStateRemoveAnimation", v6, @"LKStateRemoveElement", v7, @"LKStateSetValue", v8, @"LKStateSetProperty", v9,
           @"LKStateTransition",
           objc_opt_class(),
           @"LKStateTransitionElement",
           0);
}

void *find_state(NSArray *a1, NSString *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  uint64_t v4 = [(NSArray *)a1 countByEnumeratingWithState:&v11 objects:v10 count:16];
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)v12;
LABEL_4:
  uint64_t v7 = 0;
  while (1)
  {
    if (*(void *)v12 != v6) {
      objc_enumerationMutation(a1);
    }
    uint64_t v8 = *(void **)(*((void *)&v11 + 1) + 8 * v7);
    if (objc_msgSend((id)objc_msgSend(v8, "name"), "isEqualToString:", a2)) {
      return v8;
    }
    if (v5 == ++v7)
    {
      uint64_t v5 = [(NSArray *)a1 countByEnumeratingWithState:&v11 objects:v10 count:16];
      uint64_t v8 = 0;
      if (v5) {
        goto LABEL_4;
      }
      return v8;
    }
  }
}

id ___ZL34cons_CALayer_kCAValueCopiedPointerjb_block_invoke(uint64_t a1, uint64_t a2)
{
  v4[1] = *(id *)MEMORY[0x1E4F143B8];
  unsigned int v2 = *(_DWORD *)(a1 + 32);
  v4[0] = 0;
  CA::Layer::getter(*(CA::Transaction **)(a2 + 16), v2, (const CGAffineTransform *)3, v4);
  return v4[0];
}

void sub_18475FEE4(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x18475FE40);
  }
  _Unwind_Resume(a1);
}

double begin_time(_CAStateControllerData *a1)
{
  if (a1) {
    return *(double *)&a1[1].var0;
  }
  +[CATransaction commitTime];
  if (result == 0.0)
  {
    uint64_t v2 = mach_absolute_time();
    return CATimeWithHostTime(v2);
  }
  return result;
}

void ___ZL36cons_CAAnimation_kCAValueWeakPointerjb_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (const void *)*(unsigned int *)(a1 + 32);
  v5[0] = a3;
  CAAnimation_setter(a2, v4, 4, (unsigned __int8 *)v5);
}

void *find_transition(NSArray *a1, __CFString *a2, __CFString *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a2) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = &stru_1ED039300;
  }
  long long v13 = 0u;
  long long v14 = 0u;
  if (a3) {
    uint64_t v5 = a3;
  }
  else {
    uint64_t v5 = &stru_1ED039300;
  }
  long long v15 = 0uLL;
  long long v16 = 0uLL;
  uint64_t v6 = [(NSArray *)a1 countByEnumeratingWithState:&v13 objects:v12 count:16];
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)v14;
LABEL_9:
  uint64_t v9 = 0;
  while (1)
  {
    if (*(void *)v14 != v8) {
      objc_enumerationMutation(a1);
    }
    uint64_t v10 = *(void **)(*((void *)&v13 + 1) + 8 * v9);
    if (objc_msgSend((id)objc_msgSend(v10, "fromState"), "isEqualToString:", v4))
    {
      if (objc_msgSend((id)objc_msgSend(v10, "toState"), "isEqualToString:", v5)) {
        return v10;
      }
    }
    if (v7 == ++v9)
    {
      uint64_t v7 = [(NSArray *)a1 countByEnumeratingWithState:&v13 objects:v12 count:16];
      if (v7) {
        goto LABEL_9;
      }
      return 0;
    }
  }
}

_DWORD *CA::Context::copy_timings(CA::Transaction **this, CA::Layer *a2, void *a3)
{
  v33[1] = *MEMORY[0x1E4F143B8];
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v6 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x138uLL, 0x743898A5uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    v6[2] = 1;
    v6[3] = 53;
    ++dword_1EB2ADE9C;
    *(void *)uint64_t v6 = &unk_1ED02CE58;
    *((void *)v6 + 2) = v6 + 12;
    *((void *)v6 + 3) = v6 + 12;
    *((void *)v6 + 4) = v6 + 12;
    *((void *)v6 + 5) = 32;
    v6[76] = 1065353216;
  }
  int v8 = *((_DWORD *)a2 + 25);
  *((_DWORD *)a2 + 25) = v8 + 1;
  if (!v8) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  while (this)
  {
    v33[0] = 0;
    CA::Layer::render_timing((uint64_t)v33, this[2], a2);
    uint64_t v9 = v33[0];
    if (v33[0])
    {
      if (!atomic_fetch_add((atomic_uint *volatile)(v33[0] + 8), 1u)) {
        atomic_fetch_add((atomic_uint *volatile)(v9 + 8), 0xFFFFFFFF);
      }
      *((float *)v7 + 76) = *((float *)v7 + 76) * *(float *)(v9 + 16);
      uint64_t v11 = *((void *)v7 + 2);
      uint64_t v10 = (void *)*((void *)v7 + 3);
      uint64_t v12 = ((uint64_t)v10 - v11) >> 3;
      unint64_t v13 = *((void *)v7 + 5);
      if (v13 < v12 + 1)
      {
        uint64_t v14 = *((void *)v7 + 4);
        unint64_t v15 = (v13 + 1) | ((v13 + 1) >> 1) | (((v13 + 1) | ((v13 + 1) >> 1)) >> 2);
        unint64_t v16 = v15 | (v15 >> 4) | ((v15 | (v15 >> 4)) >> 8);
        unint64_t v17 = v16 | (v16 >> 16) | ((v16 | (v16 >> 16)) >> 32);
        if (v17 + 1 > v12 + 1) {
          uint64_t v18 = v17 + 1;
        }
        else {
          uint64_t v18 = v12 + 1;
        }
        uint64_t v19 = malloc_type_malloc(8 * v18, 0x2004093837F09uLL);
        uint64_t v20 = v19;
        unint64_t v21 = (uint64_t *)*((void *)v7 + 2);
        uint64_t v22 = (uint64_t *)*((void *)v7 + 3);
        if (v21 != v22)
        {
          uint64_t v23 = v19;
          do
          {
            uint64_t v24 = *v21++;
            *v23++ = v24;
          }
          while (v21 != v22);
        }
        if (v11 != v14) {
          free(*((void **)v7 + 2));
        }
        uint64_t v10 = &v20[v12];
        *((void *)v7 + 2) = v20;
        *((void *)v7 + 3) = v10;
        *((void *)v7 + 5) = v18;
      }
      void *v10 = v9;
      *((void *)v7 + 3) += 8;
      if (atomic_fetch_add((atomic_uint *volatile)(v9 + 8), 0xFFFFFFFF) == 1) {
        (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
      }
    }
    this = (CA::Transaction **)CA::Layer::superlayer(this[2], a2);
  }
  unint64_t v25 = *((void *)v7 + 2);
  uint64_t v26 = *((void *)v7 + 3);
  int v27 = (void *)(v26 - 8);
  if (v25 != v26 && (unint64_t)v27 > v25)
  {
    unint64_t v29 = v25 + 8;
    do
    {
      uint64_t v30 = *(void *)(v29 - 8);
      *(void *)(v29 - 8) = *v27;
      *v27-- = v30;
      BOOL v31 = v29 >= (unint64_t)v27;
      v29 += 8;
    }
    while (!v31);
  }
  CA::Transaction::unlock(a2);
  return v7;
}

void sub_1847609D8(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::Layer::convert_time(CA::Layer *this, CA::Transaction *a2, CALayer *a3, CALayer *a4, CALayer *a5)
{
  v19[1] = *(CA::Render::Timing **)MEMORY[0x1E4F143B8];
  if (a3 == a4) {
    return 1;
  }
  p_isa = &a4->super.isa;
  uint64_t v6 = &a3->super.isa;
  int v9 = *((_DWORD *)this + 25);
  *((_DWORD *)this + 25) = v9 + 1;
  if (!v9) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  uint64_t v10 = (CALayer *)[v6 ancestorSharedWithLayer:p_isa];
  uint64_t v11 = v10;
  while (v6 != (CA::Transaction **)v11)
  {
    v19[0] = 0;
    CA::Layer::render_timing((uint64_t)v19, v6[2], this);
    uint64_t v12 = (atomic_uint *)v19[0];
    if (v19[0])
    {
      CA::Render::Timing::inverse_map_time((uint64_t)v19[0], (double *)a2, 0.0);
      if (atomic_fetch_add(v12 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v12 + 16))(v12);
      }
    }
    uint64_t v10 = CA::Layer::superlayer(v6[2], this);
    uint64_t v6 = &v10->super.isa;
  }
  if (v11 == (CALayer *)p_isa)
  {
LABEL_19:
    uint64_t v17 = 1;
  }
  else
  {
    do
    {
      uint64_t v10 = (CALayer *)MEMORY[0x1F4188790](v10);
      unint64_t v13 = &v19[-2];
      v19[-2] = (CA::Render::Timing *)p_isa;
      v19[-1] = v14;
      if (p_isa)
      {
        uint64_t v10 = CA::Layer::superlayer(p_isa[2], this);
        p_isa = &v10->super.isa;
      }
    }
    while (p_isa != (CA::Layer **)v11);
    while (1)
    {
      v19[0] = 0;
      CA::Layer::render_timing((uint64_t)v19, *((CA::Transaction **)*v13 + 2), this);
      unint64_t v15 = (atomic_uint *)v19[0];
      if (v19[0])
      {
        int v16 = CA::Render::Timing::map_time(v19[0], (double *)a2, 0);
        if (atomic_fetch_add(v15 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v15 + 16))(v15);
        }
        if (!v16) {
          break;
        }
      }
      unint64_t v13 = (CA::Render::Timing **)v13[1];
      if (!v13) {
        goto LABEL_19;
      }
    }
    uint64_t v17 = 0;
  }
  CA::Transaction::unlock(this);
  return v17;
}

void sub_184760C0C(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::Layer::render_timing(uint64_t this, CA::Transaction *a2, CA::Transaction *a3)
{
  uint64_t v3 = (void *)this;
  if ((*((unsigned char *)a2 + 56) & 0x80) != 0)
  {
    *(void *)this = 0;
    this = CAMediaTimingCopyRenderTiming(*((void *)a2 + 2));
    *uint64_t v3 = this;
    if (!this)
    {
      this = (uint64_t)CA::Layer::writable_state(a2, a3);
      *(_DWORD *)(this + 16) &= ~0x80u;
    }
  }
  else
  {
    *(void *)this = 0;
  }
  return this;
}

void sub_184760F74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_184761208(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_184761334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id create_mode(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(os_unfair_lock_s **)(a1 + 8);
  uint64_t v7 = [MEMORY[0x1E4F1CA48] array];
  if (a3)
  {
    uint64_t v14 = 0;
    unint64_t v15 = 0;
    CA::WindowServer::Display::ModeSet::get_per_mode_info(a3, a2, (PerModeInfo *)&v14);
    HIDWORD(v15) = *(_DWORD *)(a3 + 88);
    uint64_t v8 = v14;
    unint64_t v9 = v15;
  }
  else
  {
    os_unfair_lock_lock(v6 + 18);
    uint64_t v14 = 0;
    unint64_t v15 = 0;
    CA::WindowServer::Display::ModeSet::get_per_mode_info((uint64_t)&v6[38], a2, (PerModeInfo *)&v14);
    HIDWORD(v15) = v6[60];
    uint64_t v8 = v14;
    unint64_t v9 = v15;
    os_unfair_lock_unlock(v6 + 18);
  }
  id v10 = +[CADisplayMode _displayModeWithMode:display:rates:perMode:maxSourceBandwidthPerPipe:](CADisplayMode, "_displayModeWithMode:display:rates:perMode:maxSourceBandwidthPerPipe:", a2, a1, v7, v8, v9, HIDWORD(v9));
  if (a2 == -1)
  {
    os_unfair_lock_lock(v6 + 18);
    uint64_t os_unfair_lock_opaque = (int)v6[68]._os_unfair_lock_opaque;
    uint64_t v12 = (int)v6[69]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v6 + 18);
    [v10 _setWidth:os_unfair_lock_opaque height:v12];
  }
  [v10 _setPreferredUIScale:v6[111]._os_unfair_lock_opaque];
  return v10;
}

uint64_t CA::WindowServer::Display::ModeSet::get_per_mode_info(uint64_t this, unint64_t a2, PerModeInfo *a3)
{
  unint64_t v3 = *(void *)(this + 56);
  if (v3)
  {
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v3);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
    {
      unint64_t v5 = a2;
      if (v3 <= a2) {
        unint64_t v5 = a2 % v3;
      }
    }
    else
    {
      unint64_t v5 = (v3 - 1) & a2;
    }
    uint64_t v6 = *(uint64_t ***)(*(void *)(this + 48) + 8 * v5);
    if (v6)
    {
      for (CFIndex i = *v6; i; CFIndex i = (uint64_t *)*i)
      {
        unint64_t v8 = i[1];
        if (v8 == a2)
        {
          if (i[2] == a2)
          {
            uint64_t v9 = i[3];
            *(_DWORD *)&a3->var2 = *((_DWORD *)i + 8);
            *(void *)&a3->var0 = v9;
            return this;
          }
        }
        else
        {
          if (v4.u32[0] > 1uLL)
          {
            if (v8 >= v3) {
              v8 %= v3;
            }
          }
          else
          {
            v8 &= v3 - 1;
          }
          if (v8 != v5) {
            break;
          }
        }
      }
    }
  }
  *(_WORD *)&a3->var2 = 0;
  *(void *)&a3->var0 = 0;
  return this;
}

void CA::Display::Display::available_modes(CA::Display::Display *this, os_unfair_lock_s *a2)
{
  uint8x8_t v4 = a2 + 18;
  os_unfair_lock_lock(a2 + 18);
  CA::WindowServer::Display::ModeSet::ModeSet(this, (const CA::WindowServer::Display::ModeSet *)&a2[38]);

  os_unfair_lock_unlock(v4);
}

void sub_18476172C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZL36cons_CAAnimation_kCAValueWeakPointerjb_block_invoke(uint64_t a1, CA::Transaction *a2)
{
  v5[1] = *MEMORY[0x1E4F143B8];
  int v3 = *(_DWORD *)(a1 + 32);
  v5[0] = 0;
  CAAnimation_getter(a2, v3, (const CGAffineTransform *)4, (CA::Mat4Impl *)v5);
  return v5[0];
}

double CA::Render::SpringAnimation::State::eval(CA::Render::SpringAnimation::State *this, double a2)
{
  double v4 = *((double *)this + 1);
  if (v4 < 1.0)
  {
    double v5 = exp(-(a2 * v4) * *(double *)this);
    double v6 = *((double *)this + 3);
    __double2 v7 = __sincos_stret(*((double *)this + 2) * a2);
    double v8 = v7.__sinval * *((double *)this + 4) + v7.__cosval * v6;
LABEL_7:
    double v14 = v8 * v5;
    return 1.0 - v14;
  }
  if (v4 <= 1.0 || !*((unsigned char *)this + 40))
  {
    double v5 = *((double *)this + 3) + *((double *)this + 4) * a2;
    double v8 = exp(-(a2 * *(double *)this));
    goto LABEL_7;
  }
  double v10 = *((double *)this + 2);
  double v9 = *((double *)this + 3);
  double v11 = *(double *)this * v4;
  double v12 = exp(-(a2 * (v11 + v10)));
  double v13 = *((double *)this + 4);
  double v14 = exp((v10 - v11) * a2) * v13 + v12 * v9;
  return 1.0 - v14;
}

uint64_t CA::Render::SpringAnimation::State::update(uint64_t this, double a2, double a3, double a4, double a5, int a6)
{
  double v6 = sqrt(a3 / a2);
  double v7 = sqrt(a3 * a2);
  double v8 = a4 / (v7 + v7);
  *(double *)this = v6;
  *(double *)(this + 8) = v8;
  *(unsigned char *)(this + 4CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = a6;
  if (v8 >= 1.0)
  {
    if (v8 <= 1.0 || a6 == 0)
    {
      *(void *)(this + 24) = 0x3FF0000000000000;
      double v10 = v6 - a5;
    }
    else
    {
      double v12 = sqrt(v8 * v8 + -1.0) * v6;
      double v13 = a5 + v8 * v6;
      *(double *)(this + 16) = v12;
      *(double *)(this + 24) = (v13 + v12) / (v12 + v12);
      double v10 = (v12 - v13) / (v12 + v12);
    }
  }
  else
  {
    double v9 = sqrt(-(v8 * v8 + -1.0)) * v6;
    *(double *)(this + 16) = v9;
    *(void *)(this + 24) = 0x3FF0000000000000;
    double v10 = -(a5 - v8 * v6) / v9;
  }
  *(double *)(this + 32) = v10;
  return this;
}

uint64_t CARenderServerGetFrameCounter(mach_port_name_t a1)
{
  return CARenderServerGetFrameCounterByIndex(a1, 0);
}

uint64_t CA::OGL::filter_node(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v12 = *(void *)(a1 + 72);
  if (v12) {
    *(void *)(a1 + 72) = *(void *)v12;
  }
  else {
    uint64_t v12 = x_heap_malloc_small_(*(uint64_t **)(a1 + 56), 0xF8uLL);
  }
  *(void *)(v12 + 8) = a1;
  *(void *)(v12 + 16) = a2;
  *(void *)(v12 + 48) = 0;
  *(void *)(v12 + 192) = 0;
  *(void *)(v12 + 20CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
  *(_DWORD *)(v12 + 208) = 0;
  *(_WORD *)(v12 + 212) = *(_WORD *)(v12 + 212) & 0xC000 | 1;
  unsigned int v13 = *(_DWORD *)(v12 + 220) & 0xFC000000;
  *(_DWORD *)(v12 + 216) = *(_DWORD *)(v12 + 216) & 0xFFC00000 | 0xF;
  *(_DWORD *)(v12 + 22CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v13;
  *(void *)(v12 + 24) = a6;
  *(void *)(v12 + 32) = 0;
  *(_DWORD *)(v12 + 136) = -1;
  *(void *)uint64_t v12 = &unk_1ED02A350;
  *(unsigned char *)(v12 + 224) = *(unsigned char *)(v12 + 224) & 0xFE | a5;
  *(void *)(v12 + 232) = a3;
  CA::OGL::init_gstate(v12 + 56, a4);
  *(_DWORD *)(v12 + 22CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = *(_DWORD *)(v12 + 220) & 0xFFEE0000 | 0x100040;
  return v12;
}

uint64_t CA::OGL::combine_node(uint64_t **a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, CA::OGL::ImagingNode *this, float a7, float a8, float a9, float a10)
{
  double v10 = this;
  if (a3 == 6)
  {
    int v19 = *((_DWORD *)this + 34);
    if (v19 < 0)
    {
      (*(void (**)(CA::OGL::ImagingNode *, char *))(*(void *)this + 40))(this, (char *)this + 128);
      int v19 = *((_DWORD *)v10 + 34);
    }
    if (v19 >= *((_DWORD *)v10 + 35)) {
      int v19 = *((_DWORD *)v10 + 35);
    }
    if (v19 <= 0)
    {
      __int16 v21 = *((_WORD *)v10 + 106) - 1;
      *((unsigned char *)v10 + 212) = *((_WORD *)v10 + 106) - 1;
      if (!(_BYTE)v21) {
        CA::OGL::ImagingNode::finalize(v10, (CA::OGL::Renderer *)a1);
      }
      double v10 = 0;
      char v20 = 3;
    }
    else
    {
      char v20 = 6;
    }
  }
  else
  {
    char v20 = a3;
  }
  uint64_t v22 = (uint64_t)a1[9];
  if (v22) {
    a1[9] = *(uint64_t **)v22;
  }
  else {
    uint64_t v22 = x_heap_malloc_small_(a1[7], 0xF8uLL);
  }
  *(void *)(v22 + 8) = a1;
  *(void *)(v22 + 16) = a2;
  *(void *)(v22 + 48) = 0;
  *(void *)(v22 + 192) = 0;
  *(void *)(v22 + 20CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
  *(_DWORD *)(v22 + 208) = 0;
  *(_WORD *)(v22 + 212) = *(_WORD *)(v22 + 212) & 0xC000 | 1;
  unsigned int v23 = *(_DWORD *)(v22 + 220) & 0xFC000000;
  *(_DWORD *)(v22 + 216) = *(_DWORD *)(v22 + 216) & 0xFFC00000 | 0xF;
  *(_DWORD *)(v22 + 22CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v23;
  *(void *)(v22 + 24) = a5;
  *(void *)(v22 + 32) = v10;
  *(_DWORD *)(v22 + 136) = -1;
  *(void *)uint64_t v22 = &unk_1ED02A468;
  *(unsigned char *)(v22 + 224) = v20;
  *(float *)(v22 + 228) = a7;
  *(float *)(v22 + 232) = a8;
  *(float *)(v22 + 236) = a9;
  *(float *)(v22 + 24CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = a10;
  CA::OGL::init_gstate(v22 + 56, a4);
  *(_DWORD *)(v22 + 220) |= 0x100000u;
  return v22;
}

uint64_t CA::OGL::init_gstate(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = 0x3C003C003C003C00;
  *(void *)(result + 48) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 4CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
  __int16 v2 = (*(unsigned __int8 *)(result + 69) << 8) | 1;
  *(_WORD *)(result + 68) = (*(unsigned __int8 *)(result + 69) << 8) & 0xFDFE | 1;
  *(void *)double result = 0;
  if (a2)
  {
    *(_OWORD *)(result + 8) = *(_OWORD *)(a2 + 8);
    *(void *)(result + 24) = *(void *)(a2 + 24);
    *(_DWORD *)(result + 64) = *(_DWORD *)(a2 + 64);
    __int16 v3 = *(_WORD *)(a2 + 68) & 0x100 | v2 & 0xFC01;
    *(_WORD *)(result + 68) = v3;
    __int16 v4 = v3 & 0xFBFF | *(_WORD *)(a2 + 68) & 0x400;
  }
  else
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(_DWORD *)(result + 64) = 1065353216;
    __int16 v4 = v2 & 0xF801 | 0x400;
  }
  *(_WORD *)(result + 68) = v4;
  return result;
}

void CA::OGL::MaskNode::compute_dod(CA::OGL::MaskNode *this, int32x2_t *a2, double *a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)this + 2);
  *(_OWORD *)a2->i8 = xmmword_184998040;
  if ((*(unsigned char *)(v5 + 32) & 2) != 0)
  {
    if (*((unsigned char *)this + 224))
    {
      uint64_t v6 = *((void *)this + 29);
      if (!v6) {
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v6 = CA::OGL::prepare_layer(*((void *)this + 1), *(void *)(*(void *)(v5 + 16) + 128), (const CA::Render::TransitionSubclass *)v5, (uint64_t)this + 56, 0x4000000, (*((_DWORD *)this + 55) >> 22) & 1);
      *((void *)this + 29) = v6;
      *((unsigned char *)this + 224) |= 1u;
      if (!v6) {
        goto LABEL_10;
      }
    }
    if ((*(void *)(*(void *)(v5 + 24) + 40) & 0x80) == 0)
    {
      double v7 = *(int32x2_t **)(v6 + 104);
      __int32 v8 = v7[17].i32[0];
      if (v8 < 0)
      {
        (*(void (**)(void, int32x2_t *))(*(void *)v7 + 40))(*(void *)(v6 + 104), v7 + 16);
        __int32 v8 = v7[17].i32[0];
      }
      *a2 = v7[16];
      a2[1].i32[0] = v8;
      a2[1].i32[1] = v7[17].i32[1];
    }
  }
LABEL_10:
  if (*(unsigned char *)(v5 + 32))
  {
    double v9 = *(float64x2_t **)(v5 + 24);
    float64x2_t v10 = v9[5];
    float64x2_t v26 = v9[4];
    float64x2_t v27 = v10;
    CA::Rect::apply_transform((int8x16_t *)&v26, *((const CA::Transform **)this + 10), a3);
    int64x2_t v11 = vceqzq_f64(v27);
    unint64_t v12 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v11, 1), (int8x16_t)v11).u64[0];
    int8x16_t v13 = 0uLL;
    if ((v12 & 0x8000000000000000) == 0)
    {
      int8x16_t v14 = vorrq_s8((int8x16_t)vcltzq_f64(v27), (int8x16_t)vcgezq_f64(v27));
      if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v14), 1), v14).u64[0] & 0x8000000000000000) == 0)
      {
        int32x4_t v15 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v26, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        int8x16_t v13 = (int8x16_t)vuzp1q_s32(v15, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v26, v27), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v15));
      }
    }
    int32x2_t v16 = a2[1];
    uint32x2_t v17 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v16);
    if ((vpmax_u32(v17, v17).u32[0] & 0x80000000) == 0)
    {
      int32x2_t v18 = (int32x2_t)vextq_s8(v13, v13, 8uLL).u64[0];
      uint32x2_t v19 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v18);
      if ((vpmax_u32(v19, v19).u32[0] & 0x80000000) != 0
        || (int32x2_t v20 = vadd_s32(*(int32x2_t *)v13.i8, v18),
            *(int32x2_t *)v13.i8 = vmax_s32(*a2, *(int32x2_t *)v13.i8),
            int32x2_t v21 = vsub_s32(vmin_s32(vadd_s32(*a2, v16), v20), *(int32x2_t *)v13.i8),
            uint32x2_t v22 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v21),
            (vpmax_u32(v22, v22).u32[0] & 0x80000000) != 0))
      {
        a2[1] = 0;
      }
      else
      {
        v13.u64[1] = (unint64_t)v21;
        *(int8x16_t *)a2->i8 = v13;
      }
    }
  }
  unsigned int v23 = (int32x2_t *)*((void *)this + 3);
  if (v23)
  {
    if (v23[17].i32[0] < 0) {
      (*(void (**)(int32x2_t *, int32x2_t *))(*(void *)v23 + 40))(v23, v23 + 16);
    }
    int32x2_t v24 = v23[16];
    int32x2_t v25 = v23[17];
    CA::BoundsImpl::intersect(a2, v24, v25);
  }
}

uint64_t CA::OGL::CombineNode::compute_dod(uint64_t this, int32x2_t *a2)
{
  uint64_t v2 = *(unsigned __int8 *)(this + 224);
  if (v2 <= 0x38)
  {
    uint64_t v4 = this;
    if (((1 << v2) & 0x100000000004B4ALL) != 0)
    {
      uint64_t v5 = *(int32x2_t **)(this + 24);
      __int32 v6 = v5[17].i32[0];
      if (v6 < 0)
      {
        this = (*(uint64_t (**)(int32x2_t *, int32x2_t *))(*(void *)v5 + 40))(v5, v5 + 16);
        __int32 v6 = v5[17].i32[0];
      }
      *a2 = v5[16];
      __int32 v7 = v5[17].i32[1];
      a2[1].i32[0] = v6;
      a2[1].i32[1] = v7;
    }
    else if (((1 << v2) & 0x480) != 0)
    {
      __int32 v8 = *(int32x2_t **)(this + 24);
      __int32 v9 = v8[17].i32[0];
      if (v9 < 0)
      {
        (*(void (**)(void, int32x2_t *))(*(void *)v8 + 40))(*(void *)(this + 24), v8 + 16);
        __int32 v9 = v8[17].i32[0];
      }
      *a2 = v8[16];
      __int32 v10 = v8[17].i32[1];
      a2[1].i32[0] = v9;
      a2[1].i32[1] = v10;
      int64x2_t v11 = *(int32x2_t **)(v4 + 32);
      if (v11[17].i32[0] < 0) {
        (*(void (**)(int32x2_t *, int32x2_t *))(*(void *)v11 + 40))(v11, v11 + 16);
      }
      int32x2_t v12 = v11[16];
      int32x2_t v13 = v11[17];
      return CA::BoundsImpl::Union(a2, v12, v13);
    }
    else if (v2 == 5)
    {
      int8x16_t v14 = *(int32x2_t **)(this + 24);
      __int32 v15 = v14[17].i32[0];
      if (v15 < 0)
      {
        (*(void (**)(void, int32x2_t *))(*(void *)v14 + 40))(*(void *)(this + 24), v14 + 16);
        __int32 v15 = v14[17].i32[0];
      }
      *a2 = v14[16];
      __int32 v16 = v14[17].i32[1];
      a2[1].i32[0] = v15;
      a2[1].i32[1] = v16;
      uint32x2_t v17 = *(int32x2_t **)(v4 + 32);
      if (v17[17].i32[0] < 0) {
        (*(void (**)(int32x2_t *, int32x2_t *))(*(void *)v17 + 40))(v17, v17 + 16);
      }
      int32x2_t v18 = v17[16];
      int32x2_t v19 = v17[17];
      return CA::BoundsImpl::intersect(a2, v18, v19);
    }
  }
  return this;
}

void CA::OGL::QuadNode::compute_dod(CA::OGL::QuadNode *this, CA::Bounds *a2, double *a3, int32x4_t a4, int32x4_t a5)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *((void *)this + 3);
  int v8 = *(_DWORD *)(v7 + 136);
  if (v8 < 0)
  {
    (*(void (**)(void, uint64_t))(*(void *)v7 + 40))(*((void *)this + 3), v7 + 128);
    int v8 = *(_DWORD *)(v7 + 136);
  }
  int v9 = *(_DWORD *)(v7 + 140);
  if (v8 <= v9) {
    int v10 = *(_DWORD *)(v7 + 140);
  }
  else {
    int v10 = v8;
  }
  a4.i32[0] = 1073741822;
  a5.i32[0] = v10;
  int8x16_t v11 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a5, a4), 0);
  uint64_t v12 = *(void *)(v7 + 128);
  v13.i64[0] = (int)v12;
  v13.i64[1] = SHIDWORD(v12);
  int8x16_t v14 = vbslq_s8(v11, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v13));
  double v15 = (double)v8;
  double v16 = (double)v9;
  if (v10 > 1073741822)
  {
    double v15 = 1.79769313e308;
    double v16 = 1.79769313e308;
  }
  float64x2_t v20 = (float64x2_t)v14;
  v21.f64[0] = v15;
  v21.f64[1] = v16;
  CA::Rect::apply_transform((int8x16_t *)&v20, *((const CA::Transform **)this + 10), a3);
  int64x2_t v17 = vceqzq_f64(v21);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v17, 1), (int8x16_t)v17).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v18 = vorrq_s8((int8x16_t)vcltzq_f64(v21), (int8x16_t)vcgezq_f64(v21)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v18), 1), v18).u64[0] & 0x8000000000000000) != 0))
  {
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
  }
  else
  {
    int32x4_t v19 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v20, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    *(int32x4_t *)a2 = vuzp1q_s32(v19, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v20, v21), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v19));
  }
}

_DWORD *CA::OGL::CacheNode::compute_dod(CA::OGL::CacheNode *this, CA::Bounds *a2)
{
  double result = (_DWORD *)CA::OGL::Context::cache_fetch(**((void **)this + 1), (_DWORD *)this + 57);
  if (result)
  {
    uint64_t v5 = result;
    int v6 = result[9];
    int v7 = result[10];
    if (v6 <= v7) {
      int v8 = result[10];
    }
    else {
      int v8 = result[9];
    }
    if (v8 > 1073741822
      || (v6 >= v7 ? (int v9 = result[10]) : (int v9 = result[9]), (*((unsigned char *)this + 224) & 1) != 0 && v9 < 1))
    {
      int v10 = (_DWORD *)*((void *)this + 3);
      int v6 = v10[34];
      if (v6 < 0)
      {
        double result = (_DWORD *)(*(uint64_t (**)(_DWORD *, _DWORD *))(*(void *)v10 + 40))(v10, v10 + 32);
        int v6 = v10[34];
      }
      int v11 = v10[32];
      int v12 = v10[33];
      v5[7] = v11;
      v5[8] = v12;
      int v7 = v10[35];
      v5[9] = v6;
      v5[10] = v7;
    }
    else
    {
      int v11 = result[7];
      int v12 = result[8];
    }
    *(_DWORD *)a2 = v11;
    *((_DWORD *)a2 + 1) = v12;
    *((_DWORD *)a2 + 2) = v6;
  }
  else
  {
    uint64_t v13 = *((void *)this + 3);
    int v14 = *(_DWORD *)(v13 + 136);
    if (v14 < 0)
    {
      double result = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(*(void *)v13 + 40))(*((void *)this + 3), v13 + 128);
      int v14 = *(_DWORD *)(v13 + 136);
    }
    *(void *)a2 = *(void *)(v13 + 128);
    *((_DWORD *)a2 + 2) = v14;
    int v7 = *(_DWORD *)(v13 + 140);
  }
  *((_DWORD *)a2 + 3) = v7;
  return result;
}

uint64_t CA::OGL::AsynchronousNode::compute_dod(uint64_t this, int32x2_t *a2, double *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  __int16 v3 = *(float64x2_t **)(*(void *)(this + 16) + 24);
  float64x2_t v4 = v3[5];
  float64x2_t v12 = v3[4];
  float64x2_t v13 = v4;
  if (v4.f64[0] != 0.0)
  {
    CA::Rect::apply_transform((int8x16_t *)&v12, *(const CA::Transform **)(this + 80), a3);
    int64x2_t v6 = vceqzq_f64(v13);
    unint64_t v7 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), (int8x16_t)v6).u64[0];
    int8x16_t v8 = 0uLL;
    if ((v7 & 0x8000000000000000) == 0)
    {
      int8x16_t v9 = vorrq_s8((int8x16_t)vcltzq_f64(v13), (int8x16_t)vcgezq_f64(v13));
      if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v9), 1), v9).u64[0] & 0x8000000000000000) == 0)
      {
        int32x4_t v10 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v12, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        int8x16_t v8 = (int8x16_t)vuzp1q_s32(v10, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v12, v13), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v10));
      }
    }
    int32x2_t v11 = (int32x2_t)vextq_s8(v8, v8, 8uLL).u64[0];
    return CA::BoundsImpl::Union(a2, *(int32x2_t *)v8.i8, v11);
  }
  return this;
}

uint64_t CA::OGL::ShadowNode::compute_dod(uint64_t this, int32x2_t *a2, int32x4_t a3, int64x2_t a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(*(void *)(this + 16) + 24);
  if ((*(unsigned char *)(v5 + 44) & 2) != 0)
  {
    *(_OWORD *)a2->i8 = xmmword_184998040;
    return this;
  }
  uint64_t v6 = this;
  unint64_t v7 = *(_DWORD **)(this + 24);
  __int32 v8 = v7[34];
  if (v8 < 0)
  {
    (*(void (**)(void, _DWORD *))(*(void *)v7 + 40))(*(void *)(this + 24), v7 + 32);
    __int32 v8 = v7[34];
  }
  __int32 v9 = v7[32];
  a2->i32[0] = v9;
  __int32 v10 = v7[33];
  a2->i32[1] = v10;
  a2[1].i32[0] = v8;
  __int32 v11 = v7[35];
  a2[1].i32[1] = v11;
  int32x2_t v24 = (int32x2_t)__PAIR64__(v10, v9);
  int32x2_t v25 = (int32x2_t)__PAIR64__(v11, v8);
  if ((*(unsigned char *)(v5 + 44) & 4) != 0)
  {
    a3 = *(int32x4_t *)(v5 + 80);
    int64x2_t v19 = vceqzq_f64((float64x2_t)a3);
    a4 = (int64x2_t)vorrq_s8((int8x16_t)vdupq_laneq_s64(v19, 1), (int8x16_t)v19);
    if ((a4.i64[0] & 0x8000000000000000) == 0)
    {
      int8x16_t v20 = vorrq_s8((int8x16_t)vcltzq_f64((float64x2_t)a3), (int8x16_t)vcgezq_f64((float64x2_t)a3));
      a4 = (int64x2_t)vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v20), 1), v20);
      if ((a4.i64[0] & 0x8000000000000000) == 0)
      {
        float64x2_t v17 = (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000);
        float64x2_t v18 = *(float64x2_t *)(v5 + 64);
        goto LABEL_14;
      }
    }
LABEL_15:
    int32x4_t v26 = 0uLL;
    goto LABEL_17;
  }
  uint64_t v12 = *(void *)(v5 + 128);
  if (!v12 || (float64x2_t v13 = *(CA::Render::Path **)(v12 + 120)) == 0)
  {
    v26.i64[0] = __PAIR64__(v10, v9);
    v26.i64[1] = __PAIR64__(v11, v8);
    goto LABEL_17;
  }
  uint64_t v14 = CA::Render::Path::bounding_rect(v13);
  a3 = *(int32x4_t *)(v14 + 16);
  int64x2_t v15 = vceqzq_f64((float64x2_t)a3);
  a4 = (int64x2_t)vorrq_s8((int8x16_t)vdupq_laneq_s64(v15, 1), (int8x16_t)v15);
  if (a4.i64[0] < 0) {
    goto LABEL_15;
  }
  int8x16_t v16 = vorrq_s8((int8x16_t)vcltzq_f64((float64x2_t)a3), (int8x16_t)vcgezq_f64((float64x2_t)a3));
  a4 = (int64x2_t)vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v16), 1), v16);
  if (a4.i64[0] < 0) {
    goto LABEL_15;
  }
  float64x2_t v17 = (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000);
  float64x2_t v18 = *(float64x2_t *)v14;
LABEL_14:
  a4 = vcvtmq_s64_f64(vmaxnmq_f64(v18, v17));
  a3 = vuzp1q_s32((int32x4_t)a4, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v18, (float64x2_t)a3), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), a4));
  int32x4_t v26 = a3;
LABEL_17:
  CA::OGL::ShadowNode::map_bounds(*(CA::OGL::ShadowNode **)(*(void *)(v6 + 16) + 24), *(CA::Bounds **)(v6 + 80), (uint64_t)&v26, 1, a3, (int32x4_t)a4);
  CA::BoundsImpl::Union(a2, *(int32x2_t *)v26.i8, (int32x2_t)v26.u64[1]);
  CA::OGL::ShadowNode::map_bounds_rim((CA::OGL::ShadowNode *)v6, (CA::Bounds *)&v24, v21, v22, v23);
  return CA::BoundsImpl::Union(a2, v24, v25);
}

void CA::OGL::ShadowNode::map_bounds_rim(CA::OGL::ShadowNode *this, CA::Bounds *a2, const double *a3, int32x4_t a4, int32x4_t a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v7 = *((_DWORD *)a2 + 2);
  int v8 = *((_DWORD *)a2 + 3);
  if (v7 <= v8) {
    int v9 = *((_DWORD *)a2 + 3);
  }
  else {
    int v9 = *((_DWORD *)a2 + 2);
  }
  a4.i32[0] = 1073741822;
  a5.i32[0] = v9;
  v10.i64[0] = (int)*(void *)a2;
  v10.i64[1] = (int)HIDWORD(*(void *)a2);
  int8x16_t v11 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a5, a4), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v10));
  double v12 = (double)v7;
  double v13 = (double)v8;
  if (v9 > 1073741822)
  {
    double v12 = 1.79769313e308;
    double v13 = 1.79769313e308;
  }
  float64x2_t v21 = (float64x2_t)v11;
  v22.f64[0] = v12;
  v22.f64[1] = v13;
  uint64_t v14 = (const CA::Transform *)*((void *)this + 10);
  CA::Rect::unapply_transform((CA::Rect *)&v21, v14, a3);
  uint64_t v15 = *(void *)(*(void *)(*((void *)this + 2) + 24) + 128);
  if (v15) {
    double v16 = *(float *)(v15 + 300);
  }
  else {
    double v16 = 0.0;
  }
  CA::BoundsImpl::inset(v21.f64, -v16, -v16);
  CA::Rect::apply_transform((int8x16_t *)&v21, v14, v17);
  int64x2_t v18 = vceqzq_f64(v22);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v18, 1), (int8x16_t)v18).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v19 = vorrq_s8((int8x16_t)vcltzq_f64(v22), (int8x16_t)vcgezq_f64(v22)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v19), 1), v19).u64[0] & 0x8000000000000000) != 0))
  {
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
  }
  else
  {
    int32x4_t v20 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v21, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    *(int32x4_t *)a2 = vuzp1q_s32(v20, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v21, v22), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v20));
  }
}

uint64_t CA::OGL::ShadowNode::propagate_roi(CA::OGL::ShadowNode *this, int32x2_t *a2, double a3, int32x4_t a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(*((void *)this + 2) + 24);
  if ((*(unsigned char *)(v6 + 44) & 4) != 0 || (uint64_t v7 = *(void *)(v6 + 128)) != 0 && *(void *)(v7 + 120))
  {
    uint64_t result = (*(uint64_t (**)(void, int32x2_t *))(**((void **)this + 3) + 56))(*((void *)this + 3), a2);
    goto LABEL_21;
  }
  int32x4_t v30 = *(int32x4_t *)a2->i8;
  int32x4_t v33 = v30;
  CA::OGL::ShadowNode::map_bounds((CA::OGL::ShadowNode *)v6, *((CA::Bounds **)this + 10), (uint64_t)&v33, 0, v30, a4);
  v12.i32[1] = v30.i32[3];
  __int32 v11 = v30.i32[2];
  uint32x2_t v13 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v33.u64[1]);
  uint32x2_t v14 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v30.u64[1]);
  unsigned __int32 v15 = vpmax_u32(v14, v14).u32[0];
  if ((vpmax_u32(v13, v13).u32[0] & 0x80000000) != 0)
  {
    if ((v15 & 0x80000000) != 0) {
      goto LABEL_11;
    }
    v33.i64[0] = v30.i64[0];
  }
  else
  {
    if ((v15 & 0x80000000) != 0) {
      goto LABEL_11;
    }
    int32x2_t v16 = vmin_s32(*(int32x2_t *)v33.i8, *(int32x2_t *)v30.i8);
    int32x2_t v12 = vsub_s32(vmax_s32(vadd_s32(*(int32x2_t *)v33.i8, (int32x2_t)v33.u64[1]), vadd_s32(*(int32x2_t *)v30.i8, (int32x2_t)v30.u64[1])), v16);
    *(int32x2_t *)v33.i8 = v16;
    __int32 v11 = v12.i32[0];
  }
  v33.i32[2] = v11;
  *(_DWORD *)((unint64_t)&v33 | 0xC) = v12.i32[1];
LABEL_11:
  (*(void (**)(void, int32x4_t *))(**((void **)this + 3) + 56))(*((void *)this + 3), &v33);
  *(_WORD *)(*((void *)this + 3) + 212) |= 0x200u;
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(***((void ***)this + 1) + 184))(**((void **)this + 1), 34);
  if (result)
  {
    double v31 = 0.0;
    double v32 = 0.0;
    uint64_t v18 = *((void *)this + 10);
    if ((*(unsigned char *)(v18 + 144) & 0x10) != 0)
    {
      CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v18, &v32, &v31, v17);
      double v19 = v31;
      double v20 = v32;
    }
    else
    {
      double v19 = *(double *)(v18 + 128);
      double v20 = v19;
    }
    if (v20 < v19) {
      double v19 = v20;
    }
    uint64_t v21 = *(void *)(*(void *)(*((void *)this + 2) + 24) + 128);
    if (v21) {
      double v22 = *(float *)(v21 + 224);
    }
    else {
      double v22 = 3.0;
    }
    uint64_t v23 = *((void *)this + 3);
    uint64_t result = CA::OGL::blur_downsample_alignment(0, v22 * v19 * (v22 * v19));
    *(_WORD *)(v23 + 212) = *(_WORD *)(v23 + 212) & 0xC3FF | ((_WORD)result << 10);
  }
LABEL_21:
  uint64_t v24 = *(void *)(*(void *)(*((void *)this + 2) + 24) + 128);
  if (v24 && *(float *)(v24 + 300) != 0.0)
  {
    int32x4_t v33 = *(int32x4_t *)a2->i8;
    CA::OGL::ShadowNode::map_bounds_rim(this, (CA::Bounds *)&v33, v9, v33, v10);
    int32x2_t v25 = a2[1];
    uint32x2_t v26 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v33.u64[1]);
    uint32x2_t v27 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v25);
    unsigned __int32 v28 = vpmax_u32(v27, v27).u32[0];
    if ((vpmax_u32(v26, v26).u32[0] & 0x80000000) != 0)
    {
      if ((v28 & 0x80000000) == 0)
      {
        int32x2_t v29 = *a2;
        goto LABEL_28;
      }
    }
    else if ((v28 & 0x80000000) == 0)
    {
      int32x2_t v29 = vmin_s32(*(int32x2_t *)v33.i8, *a2);
      int32x2_t v25 = vsub_s32(vmax_s32(vadd_s32(*(int32x2_t *)v33.i8, (int32x2_t)v33.u64[1]), vadd_s32(*a2, v25)), v29);
LABEL_28:
      *(int32x2_t *)v33.i8 = v29;
      v33.u64[1] = (unint64_t)v25;
    }
    uint64_t result = (*(uint64_t (**)(void, int32x4_t *))(**((void **)this + 3) + 56))(*((void *)this + 3), &v33);
    *(_WORD *)(*((void *)this + 3) + 212) |= 0x200u;
  }
  return result;
}

void CA::OGL::MeshNode::unmap_bounds(CA::OGL::MeshNode *this, const CA::Transform **a2, uint64_t a3, int32x4_t a4, int32x4_t a5)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int v7 = *(_DWORD *)(a3 + 8);
  int v8 = *(_DWORD *)(a3 + 12);
  if (v7 <= v8) {
    int v9 = *(_DWORD *)(a3 + 12);
  }
  else {
    int v9 = *(_DWORD *)(a3 + 8);
  }
  a4.i32[0] = 1073741822;
  a5.i32[0] = v9;
  v10.i64[0] = (int)*(void *)a3;
  v10.i64[1] = (int)HIDWORD(*(void *)a3);
  int8x16_t v11 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a5, a4), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v10));
  double v12 = (double)v7;
  double v13 = (double)v8;
  if (v9 > 1073741822)
  {
    double v12 = 1.79769313e308;
    double v13 = 1.79769313e308;
  }
  float64x2_t v23 = (float64x2_t)v11;
  v24.f64[0] = v12;
  v24.f64[1] = v13;
  CA::Rect::unapply_transform((CA::Rect *)&v23, a2[10], (const double *)a3);
  CA::Render::MeshTransform::unapply_rect((CA::Render::MeshTransform *)v22, a2[29], v14, *(float64x2_t *)(*((void *)a2[2] + 3) + 64), *(float64x2_t *)(*((void *)a2[2] + 3) + 80), v23, v24);
  double v15 = *((float *)a2 + 60);
  float64x2_t v16 = vmulq_n_f64(v22[1], v15);
  int64x2_t v17 = vceqzq_f64(v16);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v17, 1), (int8x16_t)v17).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v18 = vorrq_s8((int8x16_t)vcltzq_f64(v16), (int8x16_t)vcgezq_f64(v16)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v18), 1), v18).u64[0] & 0x8000000000000000) != 0))
  {
    *(void *)this = 0;
    *((void *)this + 1) = 0;
  }
  else
  {
    float64x2_t v19 = vmulq_n_f64(v22[0], v15);
    float64x2_t v20 = vminnmq_f64(vaddq_f64(v19, v16), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
    int32x4_t v21 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v19, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    *(int32x4_t *)this = vuzp1q_s32(v21, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v20), (int64x2_t)v21));
  }
}

void CA::OGL::ShadowNode::map_bounds(CA::OGL::ShadowNode *this, CA::Bounds *a2, uint64_t a3, int a4, int32x4_t a5, int32x4_t a6)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int v10 = *(_DWORD *)(a3 + 8);
  int v11 = *(_DWORD *)(a3 + 12);
  if (v10 <= v11) {
    int v12 = *(_DWORD *)(a3 + 12);
  }
  else {
    int v12 = *(_DWORD *)(a3 + 8);
  }
  a5.i32[0] = 1073741822;
  a6.i32[0] = v12;
  v13.i64[0] = (int)*(void *)a3;
  v13.i64[1] = (int)HIDWORD(*(void *)a3);
  int8x16_t v14 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a6, a5), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v13));
  double v15 = (double)v10;
  if (v12 > 1073741822) {
    double v15 = 1.79769313e308;
  }
  float64x2_t v25 = (float64x2_t)v14;
  if (v12 <= 1073741822) {
    double v16 = (double)v11;
  }
  else {
    double v16 = 1.79769313e308;
  }
  v26.f64[0] = v15;
  v26.f64[1] = v16;
  CA::Rect::unapply_transform((CA::Rect *)&v25, a2, (const double *)a3);
  int64x2_t v17 = (float *)*((void *)this + 16);
  if (v17)
  {
    CA::BoundsImpl::inset(v25.f64, v17[56] * -2.8, v17[56] * -2.8);
    float v19 = 1.0;
    if (!a4) {
      float v19 = -1.0;
    }
    float v20 = v17[55];
    v21.f32[0] = v17[54] * v19;
  }
  else
  {
    CA::BoundsImpl::inset(v25.f64, -8.4, -8.4);
    float v19 = 1.0;
    if (!a4) {
      float v19 = -1.0;
    }
    v21.f32[0] = v19 * 0.0;
    float v20 = -3.0;
  }
  v21.f32[1] = v20 * v19;
  float64x2_t v25 = vaddq_f64(v25, vcvtq_f64_f32(v21));
  CA::Rect::apply_transform((int8x16_t *)&v25, a2, v18);
  int64x2_t v22 = vceqzq_f64(v26);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v22, 1), (int8x16_t)v22).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v23 = vorrq_s8((int8x16_t)vcltzq_f64(v26), (int8x16_t)vcgezq_f64(v26)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v23), 1), v23).u64[0] & 0x8000000000000000) != 0))
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
  else
  {
    int32x4_t v24 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v25, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    *(int32x4_t *)a3 = vuzp1q_s32(v24, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v25, v26), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v24));
  }
}

double CA::OGL::FilterNode::compute_dod(CA::OGL::FilterNode *this, CA::Bounds *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 3);
  int v5 = *(_DWORD *)(v4 + 136);
  if (v5 < 0)
  {
    (*(void (**)(void, uint64_t))(*(void *)v4 + 40))(*((void *)this + 3), v4 + 128);
    int v5 = *(_DWORD *)(v4 + 136);
  }
  v6.i64[0] = *(void *)(v4 + 128);
  *(void *)a2 = v6.i64[0];
  *((_DWORD *)a2 + 2) = v5;
  *((_DWORD *)a2 + 3) = *(_DWORD *)(v4 + 140);
  uint64_t v7 = *(void *)(*((void *)this + 29) + 16);
  if (v7)
  {
    uint64_t v8 = *(void *)(v7 + 48);
    if (v8)
    {
      uint64_t v9 = *((void *)this + 2);
      int v10 = (const Rect *)**((void **)this + 1);
      if (((*(uint64_t (**)(void, uint64_t, void))(*(void *)v8 + 8))(*(void *)(v7 + 48), v7, *(void *)(v9 + 24)) & 1) == 0)
      {
        int v13 = *((_DWORD *)a2 + 2);
        int v14 = *((_DWORD *)a2 + 3);
        if (v13 <= v14) {
          int v15 = *((_DWORD *)a2 + 3);
        }
        else {
          int v15 = *((_DWORD *)a2 + 2);
        }
        v6.i32[0] = 1073741822;
        v12.i32[0] = v15;
        v16.i64[0] = (int)*(void *)a2;
        v16.i64[1] = (int)HIDWORD(*(void *)a2);
        int8x16_t v17 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v12, v6), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v16));
        double v18 = (double)v13;
        double v19 = (double)v14;
        if (v15 > 1073741822)
        {
          double v18 = 1.79769313e308;
          double v19 = 1.79769313e308;
        }
        int8x16_t v24 = v17;
        double v25 = v18;
        double v26 = v19;
        double v20 = CA::Rect::unapply_transform((CA::Rect *)&v24, *((const CA::Transform **)this + 10), v11);
        (*(void (**)(uint64_t, uint64_t, void, int8x16_t *, double))(*(void *)v8 + 48))(v8, v7, *(void *)(v9 + 24), &v24, v20);
        CA::Rect::apply_transform(&v24, *((const CA::Transform **)this + 10), v21);
        CA::OGL::Context::raster_round_rect((CA::OGL::Context *)&v23, v10, (double *)v24.i64);
        v6.i64[0] = v23;
        *(_OWORD *)a2 = v23;
      }
    }
  }
  return *(double *)v6.i64;
}

uint64_t CA::OGL::FilterNode::propagate_roi(CA::OGL::FilterNode *this, int32x4_t *a2, double a3, int64x2_t a4)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *((void *)this + 1);
  int8x16_t v53 = 0uLL;
  uint64_t v7 = *((void *)this + 29);
  uint64_t v8 = *(void *)(v7 + 16);
  if (!v8)
  {
    if (!*(void *)(v7 + 48)) {
      goto LABEL_28;
    }
    int32x4_t v18 = *a2;
LABEL_26:
    int8x16_t v53 = (int8x16_t)v18;
    goto LABEL_28;
  }
  uint64_t v9 = *(void *)(v8 + 48);
  if (v9)
  {
    uint64_t v10 = *((void *)this + 2);
    if (!(*(unsigned int (**)(void, uint64_t, void))(*(void *)v9 + 16))(*(void *)(v8 + 48), v8, *(void *)(v10 + 24)))
    {
      int v19 = a2->i32[2];
      int v20 = a2->i32[3];
      if (v19 <= v20) {
        int v21 = a2->i32[3];
      }
      else {
        int v21 = a2->i32[2];
      }
      v12.i32[0] = 1073741822;
      a4.i32[0] = v21;
      v22.i64[0] = (int)a2->i64[0];
      v22.i64[1] = (int)HIDWORD(a2->i64[0]);
      int8x16_t v23 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32((int32x4_t)a4, v12), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v22));
      double v24 = (double)v19;
      double v25 = (double)v20;
      if (v21 > 1073741822)
      {
        double v24 = 1.79769313e308;
        double v25 = 1.79769313e308;
      }
      float64x2_t v54 = (float64x2_t)v23;
      v55.f64[0] = v24;
      v55.f64[1] = v25;
      double v26 = CA::Rect::unapply_transform((CA::Rect *)&v54, *((const CA::Transform **)this + 10), v11);
      (*(void (**)(uint64_t, uint64_t, void, float64x2_t *, double))(*(void *)v9 + 64))(v9, v8, *(void *)(v10 + 24), &v54, v26);
      CA::Rect::apply_transform((int8x16_t *)&v54, *((const CA::Transform **)this + 10), v27);
      int64x2_t v28 = vceqzq_f64(v55);
      a4 = (int64x2_t)vorrq_s8((int8x16_t)vdupq_laneq_s64(v28, 1), (int8x16_t)v28);
      if (a4.i64[0] < 0
        || (int8x16_t v29 = vorrq_s8((int8x16_t)vcltzq_f64(v55), (int8x16_t)vcgezq_f64(v55)),
            a4 = (int64x2_t)vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v29), 1), v29),
            a4.i64[0] < 0))
      {
        int8x16_t v53 = 0uLL;
        goto LABEL_28;
      }
      a4 = vcvtmq_s64_f64(vmaxnmq_f64(v54, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      int32x4_t v18 = vuzp1q_s32((int32x4_t)a4, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v54, v55), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), a4));
      goto LABEL_26;
    }
  }
  int32x4_t v13 = *a2;
  int8x16_t v53 = *(int8x16_t *)a2;
  if (*(_DWORD *)(v8 + 24) == 25)
  {
    int v14 = v13.i32[2];
    if (v13.i32[2] <= v13.i32[3]) {
      int v15 = v13.i32[3];
    }
    else {
      int v15 = v13.i32[2];
    }
    if (v13.i32[2] >= v13.i32[3]) {
      int v14 = v13.i32[3];
    }
    if (v15 <= 1073741822 && v14 >= 1)
    {
      a4.i64[1] = 0x200000002;
      int8x16_t v53 = (int8x16_t)vaddq_s32(v13, (int32x4_t)xmmword_184997F10);
      int32x2_t v17 = vcgt_s32((int32x2_t)0x100000001, vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8(v53, v53, 8uLL)));
      if ((v17.i32[1] | v17.i32[0])) {
        v53.i64[1] = 0;
      }
    }
  }
LABEL_28:
  int32x4_t v30 = *(int8x16_t **)(*((void *)this + 1) + 8);
  if (v30 && (*((_WORD *)this + 62) & 0x100) != 0)
  {
    int8x16_t v31 = v30[12];
    int v32 = v30[12].i64[1];
    if (v31.i32[2] <= v31.i32[3]) {
      int v33 = v31.i32[3];
    }
    else {
      int v33 = v32;
    }
    if (v31.i32[2] >= v31.i32[3]) {
      int v32 = v31.i32[3];
    }
    if (v33 <= 1073741822 && v32 >= 1)
    {
      *(int32x2_t *)a4.i8 = vadd_s32(*(int32x2_t *)v31.i8, (int32x2_t)0x100000001);
      v35.i64[0] = a4.i64[0];
      v35.u64[1] = (unint64_t)vadd_s32((int32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL), (int32x2_t)0x40000000400);
      if (v35.i32[3] < 1 || v35.i32[2] < 1) {
        unsigned int v37 = -1;
      }
      else {
        unsigned int v37 = 0;
      }
      int8x16_t v31 = vbslq_s8((int8x16_t)vdupq_n_s32(v37), (int8x16_t)a4, v35);
    }
    uint32x2_t v38 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v53.u64[1]);
    if ((vpmax_u32(v38, v38).u32[0] & 0x80000000) == 0)
    {
      int32x2_t v39 = (int32x2_t)vextq_s8(v31, v31, 8uLL).u64[0];
      uint32x2_t v40 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v39);
      if ((vpmax_u32(v40, v40).u32[0] & 0x80000000) != 0
        || (int32x2_t v41 = vadd_s32(*(int32x2_t *)v31.i8, v39),
            *(int32x2_t *)v31.i8 = vmax_s32(*(int32x2_t *)v53.i8, *(int32x2_t *)v31.i8),
            int32x2_t v42 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)v53.i8, (int32x2_t)v53.u64[1]), v41), *(int32x2_t *)v31.i8),
            uint32x2_t v43 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v42),
            (vpmax_u32(v43, v43).u32[0] & 0x80000000) != 0))
      {
        v53.i64[1] = 0;
      }
      else
      {
        v31.u64[1] = (unint64_t)v42;
        int8x16_t v53 = v31;
      }
    }
  }
  (*(void (**)(void, int8x16_t *))(**((void **)this + 3) + 56))(*((void *)this + 3), &v53);
  char v44 = CA::OGL::filter_flags(*((void *)this + 29), *((void *)this + 2));
  char v45 = v44;
  if ((v44 & 1) == 0)
  {
    if ((v44 & 2) == 0) {
      goto LABEL_53;
    }
LABEL_71:
    *(_DWORD *)(*((void *)this + 3) + 220) |= 0x1000000u;
    if ((v44 & 0x20) == 0) {
      goto LABEL_55;
    }
    goto LABEL_54;
  }
  *(_WORD *)(*((void *)this + 3) + 212) |= 0x200u;
  if ((v44 & 2) != 0) {
    goto LABEL_71;
  }
LABEL_53:
  if ((v44 & 0x20) != 0) {
LABEL_54:
  }
    *(_DWORD *)(*((void *)this + 3) + 216) |= 0x40040u;
LABEL_55:
  uint64_t v46 = *((void *)this + 3);
  uint64_t v47 = *(void *)(*((void *)this + 29) + 16);
  if (v47
    && (uint64_t v48 = *(void *)(v47 + 48)) != 0
    && (uint64_t v49 = *((void *)this + 2),
        (*(unsigned int (**)(void))(*(void *)v48 + 72))(*(void *)(v47 + 48))))
  {
    __int16 v50 = ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v48 + 120))(v48, v6, v47, v49) & 0xF) << 10;
  }
  else
  {
    __int16 v50 = 0;
  }
  *(_WORD *)(v46 + 212) = v50 | *(_WORD *)(v46 + 212) & 0xC3FF;
  uint64_t result = *((void *)this + 29);
  if (*(void *)(result + 8)) {
    *((_DWORD *)this + 54) |= 0x4000u;
  }
  if ((v45 & 4) != 0) {
    *((_DWORD *)this + 55) |= 0x2000000u;
  }
  uint64_t v52 = *((void *)this + 3);
  if ((*(unsigned char *)(v52 + 222) & 0x10) == 0)
  {
    uint64_t result = CA::OGL::can_filter_in_place((void *)result);
    if (result) {
      *(_DWORD *)(v52 + 216) |= 0x800u;
    }
  }
  if (*((unsigned char *)this + 224)) {
    *((_DWORD *)this + 55) |= 0x400000u;
  }
  return result;
}

uint64_t CA::OGL::QuadNode::propagate_roi(const CA::Transform **this, const CA::Bounds *a2, const double *a3, int32x4_t a4, int32x4_t a5)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v6 = *((_DWORD *)a2 + 2);
  int v7 = *((_DWORD *)a2 + 3);
  if (v6 <= v7) {
    int v8 = *((_DWORD *)a2 + 3);
  }
  else {
    int v8 = *((_DWORD *)a2 + 2);
  }
  a4.i32[0] = 1073741822;
  a5.i32[0] = v8;
  v9.i64[0] = (int)*(void *)a2;
  v9.i64[1] = (int)HIDWORD(*(void *)a2);
  int8x16_t v10 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a5, a4), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v9));
  double v11 = (double)v6;
  double v12 = (double)v7;
  if (v8 > 1073741822)
  {
    double v11 = 1.79769313e308;
    double v12 = 1.79769313e308;
  }
  float64x2_t v18 = (float64x2_t)v10;
  v19.f64[0] = v11;
  v19.f64[1] = v12;
  CA::Rect::unapply_transform((CA::Rect *)&v18, this[10], a3);
  int64x2_t v13 = vceqzq_f64(v19);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v13, 1), (int8x16_t)v13).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v14 = vorrq_s8((int8x16_t)vcltzq_f64(v19), (int8x16_t)vcgezq_f64(v19)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v14), 1), v14).u64[0] & 0x8000000000000000) != 0))
  {
    int32x4_t v17 = 0uLL;
  }
  else
  {
    int32x4_t v15 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v18, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    int32x4_t v17 = vuzp1q_s32(v15, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v18, v19), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v15));
  }
  uint64_t result = (*(uint64_t (**)(const CA::Transform *, int32x4_t *))(*(void *)this[3] + 56))(this[3], &v17);
  *((_WORD *)this[3] + 106) |= 0x200u;
  if (((_WORD)this[28] & 0xF) == 2) {
    *((_DWORD *)this[3] + 54) |= 0x40u;
  }
  return result;
}

uint64_t CA::OGL::QuadNode::propagate_soft_roi(const CA::Transform **this, const CA::Bounds *a2, const double *a3, int32x4_t a4, int32x4_t a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v6 = *((_DWORD *)a2 + 2);
  int v7 = *((_DWORD *)a2 + 3);
  if (v6 <= v7) {
    int v8 = *((_DWORD *)a2 + 3);
  }
  else {
    int v8 = *((_DWORD *)a2 + 2);
  }
  a4.i32[0] = 1073741822;
  a5.i32[0] = v8;
  v9.i64[0] = (int)*(void *)a2;
  v9.i64[1] = (int)HIDWORD(*(void *)a2);
  int8x16_t v10 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a5, a4), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v9));
  double v11 = (double)v6;
  double v12 = (double)v7;
  if (v8 > 1073741822)
  {
    double v11 = 1.79769313e308;
    double v12 = 1.79769313e308;
  }
  float64x2_t v21 = (float64x2_t)v10;
  v22.f64[0] = v11;
  v22.f64[1] = v12;
  CA::Rect::unapply_transform((CA::Rect *)&v21, this[10], a3);
  int64x2_t v13 = vceqzq_f64(v22);
  unint64_t v14 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v13, 1), (int8x16_t)v13).u64[0];
  int8x16_t v15 = 0uLL;
  if ((v14 & 0x8000000000000000) == 0)
  {
    int8x16_t v16 = vorrq_s8((int8x16_t)vcltzq_f64(v22), (int8x16_t)vcgezq_f64(v22));
    if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v16), 1), v16).u64[0] & 0x8000000000000000) == 0)
    {
      int32x4_t v17 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v21, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      int8x16_t v15 = (int8x16_t)vuzp1q_s32(v17, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v21, v22), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v17));
    }
  }
  float64x2_t v18 = (int32x2_t *)((char *)this[3] + 192);
  int32x2_t v19 = (int32x2_t)vextq_s8(v15, v15, 8uLL).u64[0];

  return CA::BoundsImpl::Union(v18, *(int32x2_t *)v15.i8, v19);
}

void CA::OGL::MaskCorners::begin(float32x2_t *this, CA::OGL::ImagingNode *a2, double *a3)
{
  uint64_t v147 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = **((void **)a2 + 1);
  this[24] = 0;
  uint64_t v6 = *(void *)(v5 + 264);
  if (v6) {
    LOBYTE(v6) = 4 * ((*(_WORD *)(v6 + 75) & 0x60) != 0);
  }
  this[30].i8[4] = this[30].i8[4] & 0xFB | v6;
  uint64_t v7 = *((void *)a2 + 2);
  uint64_t v8 = *(void *)(v7 + 24);
  int v9 = *(_WORD *)(v8 + 38) & 0xF;
  this[25] = 0;
  this[30].i32[0] = 54;
  int8x16_t v10 = *(void **)(v8 + 128);
  if (!v10) {
    goto LABEL_17;
  }
  uint64_t v11 = v10[7];
  if (!v11) {
    goto LABEL_14;
  }
  this[25] = (float32x2_t)(*(uint64_t (**)(uint64_t))(*(void *)v11 + 80))(v11);
  int8x16_t v10 = *(void **)(*(void *)(v7 + 24) + 128);
  __asm { FMOV            V1.2D, #0.5 }
  float64x2_t v16 = 0uLL;
  if (v10)
  {
    uint64_t v17 = v10[8];
    if (v17)
    {
      _Q1 = 0uLL;
      if (*(_DWORD *)(v17 + 16) >= 4u)
      {
        _Q1 = *(float64x2_t *)(v17 + 24);
        float64x2_t v16 = vsubq_f64(*(float64x2_t *)(v17 + 40), _Q1);
      }
    }
  }
  *(float64x2_t *)this[26].f32 = _Q1;
  *(float64x2_t *)this[28].f32 = v16;
  if ((*(unsigned char *)(v5 + 432) & 2) != 0) {
    this[30].i32[0] ^= 0x800u;
  }
  if (*(unsigned char *)(*(void *)(v7 + 16) + 24)) {
    this[30].i32[0] ^= 0x800u;
  }
  if (v10)
  {
LABEL_14:
    uint64_t v18 = v10[9];
    this[30].i8[4] = this[30].i8[4] & 0xF7 | (8 * (v18 != 0));
    if (v18)
    {
      uint64_t v19 = *(void *)(*(void *)(v7 + 24) + 128);
      CA::Render::Layer::max_corner_radii(v19);
      if (v19) {
        uint64_t v21 = *(void *)(v19 + 72);
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v22 = 0;
      int v9 = 0;
      uint64_t v23 = v21 + 24;
      float64x2_t v24 = (float64x2_t)vdupq_lane_s64(v20, 0);
      do
      {
        float64x2_t v25 = *(float64x2_t *)(v23 + 16 * dword_1849987F0[v22]);
        this[v22 + 9] = vcvt_f32_f64(vdivq_f64(v24, v25));
        int v26 = v25.f64[0] != 0.0;
        if (v25.f64[1] == 0.0) {
          int v26 = 0;
        }
        v9 |= v26 << v22++;
      }
      while (v22 != 4);
    }
  }
  else
  {
LABEL_17:
    this[30].i8[4] &= ~8u;
  }
  if (v9)
  {
    this[30].i8[4] = this[30].i8[4] & 0xFC | *(unsigned char *)(*(void *)(v7 + 24) + 40) & 3;
    uint64_t v27 = *(int8x16_t **)(v7 + 24);
    int8x16_t v28 = v27[5];
    v140[0] = v27[4];
    v140[1] = v28;
    CA::Rect::apply_transform(v140, *((const CA::Transform **)a2 + 10), a3);
    int32x2_t v138 = 0;
    int32x2_t v139 = 0;
    CA::Shape::get_bounds(*(void *)(*(void *)(v5 + 248) + 8), (int *)&v138);
    uint64_t v30 = *(void *)(v5 + 264);
    int8x16_t v31 = (int32x2_t *)(v30 ? v30 + 32 : v5 + 200);
    uint32x2_t v32 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v139);
    if ((vpmax_u32(v32, v32).u32[0] & 0x80000000) == 0)
    {
      int32x2_t v33 = v31[1];
      uint32x2_t v34 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v33);
      if ((vpmax_u32(v34, v34).u32[0] & 0x80000000) == 0)
      {
        int32x2_t v35 = vmax_s32(v138, *v31);
        int32x2_t v36 = vsub_s32(vmin_s32(vadd_s32(v138, v139), vadd_s32(*v31, v33)), v35);
        uint32x2_t v37 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v36);
        if ((vpmax_u32(v37, v37).u32[0] & 0x80000000) == 0)
        {
          uint32x2_t v38 = (float64x2_t *)*((void *)a2 + 10);
          uint64_t v39 = *(void *)(v7 + 24);
          uint64_t v40 = *(void *)(v39 + 128);
          float v41 = 0.0;
          if (v40) {
            float v41 = *(float *)(v40 + 228);
          }
          int32x2_t v42 = v36;
          __int8 v43 = this[30].i8[4];
          if ((v43 & 8) != 0)
          {
            __int32 v136 = v36.i32[1];
            CA::Render::Layer::max_corner_radii(v40);
            v36.i32[1] = v136;
          }
          else
          {
            double v44 = v41;
          }
          unint64_t v45 = 0;
          int v46 = v36.i32[1];
          if ((v43 & 3) != 0) {
            double v47 = v44 * 1.528665;
          }
          else {
            double v47 = v44;
          }
          int8x16_t v48 = (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v47, 0);
          __asm { FMOV            V2.2D, #1.0 }
          int32x4_t v62 = (int32x4_t)vdivq_f64((float64x2_t)_Q2, (float64x2_t)v48);
          int8x16_t v50 = (int8x16_t)vmlaq_f64((float64x2_t)vdupq_n_s64(0x400721E8A7A4B61BuLL), (float64x2_t)v62, vmulq_f64(*(float64x2_t *)(v39 + 80), (float64x2_t)vdupq_n_s64(0xBFF721E8A7A4B61BLL)));
          int8x16_t v51 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v50, (float64x2_t)_Q2), _Q2, v50);
          this[21] = vcvt_f32_f64((float64x2_t)vbicq_s8(v51, (int8x16_t)vcltzq_f64((float64x2_t)v51)));
          float64x2_t v52 = *(float64x2_t *)(v39 + 80);
          __asm { FMOV            V0.2D, #0.5 }
          int8x16_t v54 = (int8x16_t)vmlaq_f64(_Q0, _Q0, v52);
          float64x2_t v55 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v54, (float64x2_t)v48), v48, v54);
          this[22] = vcvt_f32_f64(vmulq_f64(v55, (float64x2_t)v62));
          *(float *)v54.i32 = 1.0 / v38[7].f64[1];
          *(float *)v50.i32 = v55.f64[0];
          double v56 = *(float *)v50.i32;
          *(float *)v50.i32 = v55.f64[1];
          double v57 = *(float *)v50.i32;
          *(double *)&uint64_t v58 = *(float *)v54.i32;
          float64x2_t v59 = *v38;
          float64x2_t v60 = v38[2];
          int32x4_t v61 = (int32x4_t)vdupq_lane_s64(v58, 0);
          *(int32x2_t *)v62.i8 = vdup_n_s32(0x7F800000u);
          float32x2_t v63 = (float32x2_t)0x7F0000007FLL;
          do
          {
            if (v45 == 3 || v45 == 0) {
              double v65 = 0.0;
            }
            else {
              double v65 = v56;
            }
            if (v45 >= 2) {
              double v66 = v57;
            }
            else {
              double v66 = 0.0;
            }
            float32x2_t v67 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(v59, v65), v60, v66), *(double *)&v58));
            this[v45 + 1] = v67;
            *(int8x8_t *)v62.i8 = vbsl_s8((int8x8_t)vcgt_f32(v67, *(float32x2_t *)v62.i8), *(int8x8_t *)v62.i8, (int8x8_t)v67);
            float32x2_t v63 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v63, v67), (int8x8_t)v63, (int8x8_t)v67);
            ++v45;
          }
          while (v45 != 4);
          uint64_t v68 = 0;
          int v69 = 0;
          int32x2_t v70 = vsub_s32(vcvt_s32_f32(vrndp_f32(v63)), vcvt_s32_f32(vrndm_f32(*(float32x2_t *)v62.i8)));
          *this = (float32x2_t)v70;
          float64x2_t v71 = *(float64x2_t *)(v39 + 64);
          float64x2_t v72 = vsubq_f64(v71, v55);
          v55.f64[0] = *(float64_t *)(v39 + 72);
          float64x2_t v73 = v38[6];
          uint32x2_t v74 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v70);
          unsigned __int32 v75 = vpmax_u32(v74, v74).u32[0];
          uint32x2_t v76 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v42);
          int32x2_t v77 = vadd_s32(v35, v42);
          *(void *)&double v78 = *(_OWORD *)&vaddq_f64(v72, v52);
          uint64_t v79 = (int32x2_t *)&this[14];
          float64x2_t v80 = vnegq_f64(vcvtq_f64_f32(this[1]));
          unsigned __int32 v81 = vpmax_u32(v76, v76).u32[0];
          do
          {
            if (v68) {
              double v82 = v78;
            }
            else {
              double v82 = v71.f64[0];
            }
            float v83 = v82;
            if ((v68 & 2) != 0) {
              double v84 = v55.f64[0] - v55.f64[1] + v52.f64[1];
            }
            else {
              double v84 = v55.f64[0];
            }
            float v85 = v84;
            float32x2_t v86 = vcvt_f32_f64(vmlaq_f64(v80, (float64x2_t)v61, vmlaq_n_f64(vmlaq_n_f64(v73, v59, v83), v60, v85)));
            this[v68 + 5] = v86;
            int32x2_t v87 = vcvt_s32_f32(vrndm_f32(vadd_f32(*(float32x2_t *)v62.i8, v86)));
            v79[-1] = v87;
            *uint64_t v79 = v70;
            if ((v75 & 0x80000000) != 0 || (v81 & 0x80000000) != 0)
            {
              BOOL v89 = 0;
            }
            else
            {
              uint32x2_t v88 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(vadd_s32(v70, v87), v77), vmax_s32(v87, v35)));
              BOOL v89 = vpmax_u32(v88, v88).i32[0] >= 0;
            }
            unsigned int v90 = (~v9 >> v68) & 1 | !v89;
            this[23].i8[v68] = v90;
            v69 += v90;
            ++v68;
            v79 += 2;
          }
          while (v68 != 4);
          if (v69 != 4)
          {
            if (this[25]) {
              goto LABEL_88;
            }
            if (v42.i32[0] <= v46) {
              int v91 = v46;
            }
            else {
              int v91 = v42.i32[0];
            }
            v61.i32[0] = 1073741822;
            v62.i32[0] = v91;
            double v92 = v47 * v47 * 0.9;
            v93.i64[0] = v35.i32[0];
            v93.i64[1] = v35.i32[1];
            int8x16_t v94 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v62, v61), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v93));
            double v95 = (double)v42.i32[0];
            if (v91 > 1073741822) {
              double v95 = 1.79769313e308;
            }
            float64x2_t v145 = (float64x2_t)v94;
            double v96 = v91 <= 1073741822 ? (double)v46 : 1.79769313e308;
            *(double *)v146.i64 = v95;
            *(double *)&v146.i64[1] = v96;
            float64x2_t v134 = (float64x2_t)v48;
            double v135 = v47;
            float64x2_t v132 = v52;
            int8x16_t v133 = (int8x16_t)v71;
            CA::Rect::unapply_transform((CA::Rect *)&v145, (const CA::Transform *)v38, v29);
            uint64_t v98 = 0;
            int8x16_t v99 = (int8x16_t)v145;
            int8x16_t v100 = v146;
            int64x2_t v101 = vclezq_f64((float64x2_t)v146);
            int64x2_t v102 = (int64x2_t)vorrq_s8((int8x16_t)vdupq_laneq_s64(v101, 1), (int8x16_t)v101);
            float64x2_t v103 = vaddq_f64(v145, (float64x2_t)v146);
            int8x16_t v104 = (int8x16_t)vaddq_f64(vsubq_f64((float64x2_t)v133, v134), v132);
            int64x2_t v105 = vclezq_f64(v134);
            unint64_t v106 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v105, 1), (int8x16_t)v105).u64[0];
            v107.i64[0] = -1;
            do
            {
              if (!this[23].i8[v98])
              {
                v97.f64[0] = 0.0;
                float64x2_t v108 = (float64x2_t)vandq_s8(v100, (int8x16_t)vdupq_lane_s64(vcgtq_s64((int64x2_t)v97, v102).i64[0], 0));
                int32x2_t v109 = vceqz_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v98), (int8x8_t)0x200000001));
                v110.i64[0] = v109.i32[0];
                v110.i64[1] = v109.i32[1];
                int8x16_t v111 = v110;
                if (v109.i8[4]) {
                  double v112 = v135;
                }
                else {
                  double v112 = 0.0;
                }
                float64x2_t v113 = vcvtq_f64_f32(vcvt_f32_f64((float64x2_t)vbslq_s8(v111, v133, v104)));
                float64x2_t v114 = (float64x2_t)v99;
                if ((v102.i64[0] & 0x8000000000000000) == 0 && (v106 & 0x8000000000000000) == 0)
                {
                  int8x16_t v115 = (int8x16_t)vmaxnmq_f64((float64x2_t)v99, v113);
                  int8x16_t v116 = (int8x16_t)vsubq_f64(vminnmq_f64(v103, vaddq_f64(v134, v113)), (float64x2_t)v115);
                  int64x2_t v117 = vclezq_f64((float64x2_t)v116);
                  int8x16_t v118 = (int8x16_t)vdupq_lane_s64(vcgtq_s64((int64x2_t)vorrq_s8((int8x16_t)vdupq_laneq_s64(v117, 1), (int8x16_t)v117), v107).i64[0], 0);
                  float64x2_t v114 = (float64x2_t)vbslq_s8(v118, v115, v99);
                  float64x2_t v108 = (float64x2_t)vandq_s8(v116, v118);
                }
                uint64_t v119 = 0;
                float64x2_t v120 = vaddq_f64(v108, v114);
                *(float64_t *)&long long v121 = v120.f64[0];
                *((void *)&v121 + 1) = *(void *)&v114.f64[1];
                float64x2_t v141 = v114;
                long long v142 = v121;
                v114.f64[1] = v120.f64[1];
                float64x2_t v143 = v120;
                float64x2_t v144 = v114;
                if (v109.i8[0]) {
                  v122.f64[0] = v135;
                }
                else {
                  v122.f64[0] = 0.0;
                }
                v122.f64[1] = v112;
                float64x2_t v97 = vaddq_f64(v122, v113);
                LOBYTE(v123) = 1;
                do
                {
                  float64x2_t v124 = vsubq_f64(*(float64x2_t *)((char *)&v141 + v119), v97);
                  int v123 = v123 & (vaddvq_f64(vmulq_f64(v124, v124)) < v92);
                  v119 += 16;
                }
                while (v119 != 64);
                this[23].i8[v98] = v123;
                v69 += v123;
              }
              ++v98;
            }
            while (v98 != 4);
            if (v69 != 4)
            {
LABEL_88:
              v137[0] = 0;
              v137[1] = vadd_s32(vadd_s32(v70, v70), (int32x2_t)0x400000004);
              if ((this[30].i8[4] & 4) != 0
                || ((*((unsigned char *)a2 + 222) & 0x10) != 0
                  ? ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 184))(v5, 36)
                   ? (uint64_t v125 = 20495)
                   : (uint64_t v125 = 4111))
                  : (uint64_t v125 = 6159),
                    uint64_t v126 = (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 656))(v5, 1, v137, v125), (this[24] = (float32x2_t)v126) != 0))
              {
                unint64_t v127 = 0;
                int v128 = 0;
                float64x2_t v143 = 0u;
                float64x2_t v144 = 0u;
                float64x2_t v141 = 0u;
                long long v142 = 0u;
                float64x2_t v145 = 0u;
                int8x16_t v146 = 0u;
                do
                {
                  if (!this[23].i8[v127])
                  {
                    v129 = &v141 + v128;
                    float64x2_t *v129 = *(float64x2_t *)this[2 * v127 + 13].f32;
                    CA::BoundsImpl::inset(v129, -1, -1);
                    float32x2_t v130 = this[24];
                    if (*(void *)&v130 && (*(unsigned char *)(*(void *)&v130 + 69) & 8) != 0)
                    {
                      v145.f64[v128] = v129->f64[0];
                    }
                    else
                    {
                      v131 = (void *)&v145.f64[v128];
                      void *v131 = 0;
                      if (v127) {
                        *(_DWORD *)v131 = this->i32[0] + 2;
                      }
                      if (v127 >= 2) {
                        *((_DWORD *)v145.f64 + ((2 * v128) | 1)) = this->i32[1] + 2;
                      }
                    }
                    ++v128;
                  }
                  ++v127;
                }
                while (v127 != 4);
                if (v128)
                {
                  if ((this[30].i8[4] & 4) == 0) {
                    (*(void (**)(uint64_t, void, void, void, float64x2_t *, float64x2_t *, char *))(*(void *)v5 + 712))(v5, 0, *(void *)&this[24], v128, &v141, &v145, (char *)&this[30] + 5);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

_DWORD *CA::BoundsImpl::inset(_DWORD *result, int a2, int a3)
{
  int v4 = result[2];
  int v3 = result[3];
  if (v4 <= v3) {
    int v5 = result[3];
  }
  else {
    int v5 = result[2];
  }
  if (v4 >= v3) {
    int v6 = result[3];
  }
  else {
    int v6 = result[2];
  }
  if (v5 <= 1073741822 && v6 >= 1)
  {
    int v8 = result[1] + a3;
    *result += a2;
    result[1] = v8;
    int v9 = v4 - 2 * a2;
    int v10 = v3 - 2 * a3;
    result[2] = v9;
    result[3] = v10;
    if (v9 < 1 || v10 <= 0) {
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

double CA::Rect::unapply_transform(CA::Rect *this, const CA::Transform *a2, const double *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  double v4 = *((double *)this + 2);
  double result = *((double *)this + 3);
  if (v4 <= result) {
    double v5 = *((double *)this + 3);
  }
  else {
    double v5 = *((double *)this + 2);
  }
  if (v5 < 1.79769313e308)
  {
    if ((*((unsigned char *)a2 + 144) & 0x10) != 0)
    {
      CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)v14, a2, a3);
      CA::Mat4Impl::mat4_unapply_inverse_to_rect(v14, (int8x16_t *)this, v13);
      return result;
    }
    double v7 = *((double *)this + 1);
    double v8 = *(double *)this - *((double *)a2 + 12);
    *(double *)this = v8;
    double v9 = v7 - *((double *)a2 + 13);
    *((double *)this + 1) = v9;
    char v10 = *((unsigned char *)a2 + 144);
    if (v10)
    {
      double v9 = -(v9 + result);
      *((double *)this + 1) = v9;
      char v10 = *((unsigned char *)a2 + 144);
      if ((v10 & 2) == 0)
      {
LABEL_8:
        if ((v10 & 4) == 0) {
          goto LABEL_9;
        }
        goto LABEL_14;
      }
    }
    else if ((*((unsigned char *)a2 + 144) & 2) == 0)
    {
      goto LABEL_8;
    }
    double v8 = -(v8 + v4);
    *(double *)this = v8;
    char v10 = *((unsigned char *)a2 + 144);
    if ((v10 & 4) == 0)
    {
LABEL_9:
      double v11 = result;
      double result = v4;
      double v12 = v9;
      double v9 = v8;
      if ((v10 & 8) == 0) {
        return result;
      }
LABEL_15:
      *(double *)this = v9 * *((double *)a2 + 17);
      *((double *)this + 1) = v12 * *((double *)a2 + 17);
      *((double *)this + 2) = result * *((double *)a2 + 17);
      double result = v11 * *((double *)a2 + 17);
      *((double *)this + 3) = result;
      return result;
    }
LABEL_14:
    double v12 = -(v8 + v4);
    *(double *)this = v9;
    *((double *)this + 1) = v12;
    *((double *)this + 2) = result;
    *((double *)this + 3) = v4;
    double v11 = v4;
    if ((*((unsigned char *)a2 + 144) & 8) == 0) {
      return result;
    }
    goto LABEL_15;
  }
  return result;
}

void CA::OGL::Context::copy_destination(CA::OGL::Context *this, uint64_t a2, uint64_t a3, uint64_t a4, int32x2_t *a5, int32x2_t *a6, unsigned char *a7)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = *((void *)this + 34);
  if (v13 != *((void *)this + 33)) {
    goto LABEL_2;
  }
  if (v13) {
    LODWORD(v13) = (*(unsigned __int8 *)(v13 + 72) >> 1) & 0x1F;
  }
  if (*((_DWORD *)this + 65) != v13) {
LABEL_2:
  }
    CA::OGL::Context::prepare_destination_(this);
  if ((*((_WORD *)this + 416) & 0x200) != 0) {
    CA::OGL::Context::flatten_detached_layers_((uint64_t)this);
  }
  uint64_t v14 = *((void *)this + 33);
  if (v14)
  {
    if ((*(_DWORD *)(a3 + 68) & 0x4800) == 0x4000
      && (*(unsigned int (**)(CA::OGL::Context *, uint64_t))(*(void *)this + 184))(this, 36))
    {
      long long v34 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      uint64_t v15 = *((void *)this + 31);
      *((void *)&v34 + 1) = 0x3C003C003C003C00;
      long long v35 = 0uLL;
      *(void *)&long long v36 = 0;
      v33[0] = 0;
      if (v15)
      {
        *(void *)&long long v34 = *(void *)(v15 + 24);
        float v16 = *(float *)(v15 + 64);
        __int16 v17 = *(_WORD *)(v15 + 68) & 0x500 | 1;
      }
      else
      {
        __int16 v17 = 1025;
        float v16 = 1.0;
      }
      *((float *)&v36 + 2) = v16;
      WORD6(v36) = v17;
      memset(v32, 0, sizeof(v32));
      CA::Shape::operator=((uint64_t)v32, (_DWORD *)(a3 + 32));
      v33[1] = v32;
      void v33[2] = 0;
      v33[0] = CA::OGL::Context::set_gstate((uint64_t)this, (uint64_t)v33);
      *(unsigned char *)(*((void *)this + 2) + 16) = 99;
      *(_WORD *)(a3 + 75) = *(_WORD *)(a3 + 75) & 0xFF3F | 0x80;
      CA::OGL::Context::bind_surface((uint64_t)this, a3, 0, 0, 0, 0.0);
      uint64_t v18 = *((void *)this + 2);
      *(_OWORD *)(v18 + 96) = xmmword_184997ED0;
      char v19 = *(unsigned char *)(v18 + 481);
      if (v19) {
        *(unsigned char *)(v18 + 481) = v19 & 0xFE;
      }
      char v31 = v19;
      *((void *)this + 16) = 0;
      *((void *)this + 12) = (char *)this + 834;
      *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
      if (a4)
      {
        uint64_t v20 = 0;
        uint64_t v21 = a5 + 1;
        do
        {
          int32x2_t v22 = *a6;
          int32x2_t v23 = *(int32x2_t *)(a3 + 32);
          if (*((_DWORD *)this + 23)) {
            uint64_t v24 = 6;
          }
          else {
            uint64_t v24 = 4;
          }
          if ((unint64_t)(v20 + 4) > *((void *)this + 17)
            || (unint64_t v25 = *((void *)this + 14)) != 0 && *((void *)this + 13) + v24 > v25)
          {
            *((_WORD *)this + 416) |= 0x20u;
            CA::OGL::Context::array_flush((uint64_t)this);
            *((void *)this + 16) = 0;
            *((void *)this + 12) = (char *)this + 834;
            *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
          }
          int32x2_t v26 = vsub_s32(v22, v23);
          CA::OGL::Context::array_rect(this, (float)v21[-1].i32[0], (float)v21[-1].i32[1], (float)(v21->i32[0] + v21[-1].i32[0]), (float)(v21->i32[1] + v21[-1].i32[1]));
          uint64_t v20 = *((void *)this + 16);
          uint64_t v27 = *((void *)this + 15) + 48 * v20;
          float32x2_t v28 = vcvt_f32_s32(v26);
          *(float32x2_t *)(v27 - 176) = v28;
          int32x2_t v29 = *v21;
          v21 += 2;
          float32x2_t v30 = vcvt_f32_s32(vadd_s32(v29, v26));
          *(void *)(v27 - 128) = __PAIR64__(v28.u32[1], v30.u32[0]);
          *(float32x2_t *)(v27 - 8CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v30;
          v28.i32[1] = v30.i32[1];
          *(float32x2_t *)(v27 - 32) = v28;
          ++a6;
          --a4;
        }
        while (a4);
      }
      CA::OGL::Context::array_flush((uint64_t)this);
      if (v31) {
        *(unsigned char *)(*((void *)this + 2) + 481) |= 1u;
      }
      CA::OGL::Context::unbind_surface(this, a3, 0);
      *(unsigned char *)(*((void *)this + 2) + 16) = 0;
      CA::OGL::Context::set_gstate((uint64_t)this, **((void **)this + 31));
      *(_DWORD *)(a3 + 64) = *(_DWORD *)(*((void *)this + 33) + 64);
    }
    else
    {
      CA::OGL::Context::push_surface((uint64_t)this, a3, 0, 0x8000, 0);
      CA::OGL::emit_copy_surface((uint64_t)this, v14, a4, a5, (uint64_t)a6);
      CA::OGL::Context::pop_surface(this);
    }
    *a7 = 0;
  }
}

uint64_t CA::OGL::emit_copy_surface(uint64_t a1, uint64_t a2, uint64_t a3, int32x2_t *a4, uint64_t a5)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  uint64_t v10 = *(void *)(a1 + 248);
  *((void *)&v30 + 1) = 0x3C003C003C003C00;
  long long v31 = 0uLL;
  *(void *)&long long v32 = 0;
  v29[0] = 0;
  if (v10)
  {
    *(void *)&long long v30 = *(void *)(v10 + 24);
    float v11 = *(float *)(v10 + 64);
    __int16 v12 = *(_WORD *)(v10 + 68) & 0x500 | 1;
  }
  else
  {
    __int16 v12 = 1025;
    float v11 = 1.0;
  }
  *((float *)&v32 + 2) = v11;
  WORD6(v32) = v12;
  uint64_t v13 = (int32x2_t *)(a2 + 32);
  memset(v28, 0, sizeof(v28));
  CA::Shape::operator=((uint64_t)v28, (_DWORD *)(a2 + 32));
  v29[1] = v28;
  v29[2] = 0;
  v29[0] = CA::OGL::Context::set_gstate(a1, (uint64_t)v29);
  *(unsigned char *)(*(void *)(a1 + 16) + 16) = 1;
  uint64_t v27 = a2;
  CA::OGL::Context::bind_surface(a1, a2, 0, 0, 0, 0.0);
  uint64_t v14 = *(void *)(a1 + 16);
  char v15 = *(unsigned char *)(v14 + 481);
  if (v15) {
    *(unsigned char *)(v14 + 481) = v15 & 0xFE;
  }
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 96) = a1 + 834;
  *(_OWORD *)(a1 + 104) = xmmword_184997E70;
  if (a3)
  {
    uint64_t v16 = 0;
    __int16 v17 = a4 + 1;
    uint64_t v18 = (int *)(a5 + 4);
    do
    {
      if (*(_DWORD *)(a1 + 92)) {
        uint64_t v19 = 6;
      }
      else {
        uint64_t v19 = 4;
      }
      if ((unint64_t)(v16 + 4) > *(void *)(a1 + 136)
        || (unint64_t v20 = *(void *)(a1 + 112)) != 0 && *(void *)(a1 + 104) + v19 > v20)
      {
        *(_WORD *)(a1 + 832) |= 0x20u;
        CA::OGL::Context::array_flush(a1);
        *(void *)(a1 + 128) = 0;
        *(void *)(a1 + 96) = a1 + 834;
        *(_OWORD *)(a1 + 104) = xmmword_184997E70;
      }
      int32x2_t v21 = vsub_s32(v17[-1], *v13);
      CA::OGL::Context::array_rect((void *)a1, (float)*(v18 - 1), (float)*v18, (float)(v17->i32[0] + *(v18 - 1)), (float)(v17->i32[1] + *v18));
      int32x2_t v22 = *v17;
      v17 += 2;
      float32x2_t v23 = vcvt_f32_s32(vadd_s32(v22, v21));
      uint64_t v16 = *(void *)(a1 + 128);
      uint64_t v24 = *(void *)(a1 + 120) + 48 * v16;
      float32x2_t v25 = vcvt_f32_s32(v21);
      *(float32x2_t *)(v24 - 176) = v25;
      *(void *)(v24 - 128) = __PAIR64__(v25.u32[1], v23.u32[0]);
      *(float32x2_t *)(v24 - 8CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v23;
      v25.i32[1] = v23.i32[1];
      *(float32x2_t *)(v24 - 32) = v25;
      v18 += 2;
      --a3;
    }
    while (a3);
  }
  CA::OGL::Context::array_flush(a1);
  if (v15) {
    *(unsigned char *)(*(void *)(a1 + 16) + 481) |= 1u;
  }
  CA::OGL::Context::unbind_surface((void *)a1, v27, 0);
  *(unsigned char *)(*(void *)(a1 + 16) + 16) = 0;
  return CA::OGL::Context::set_gstate(a1, **(void **)(a1 + 248));
}

uint64_t CA::Render::Layer::max_corner_radii(uint64_t this)
{
  if (this)
  {
    uint64_t v1 = *(void *)(this + 72);
    if (v1)
    {
      if (*(_DWORD *)(v1 + 16) == 8)
      {
        uint64_t v2 = 0;
        double v3 = *(double *)(v1 + 24);
        uint64_t v4 = v1 + 32;
        do
        {
          if (v3 <= *(double *)(v4 + v2)) {
            double v3 = *(double *)(v4 + v2);
          }
          v2 += 8;
        }
        while (v2 != 56);
      }
    }
  }
  return this;
}

void CA::Render::LayerNode::MapRects::unapply(uint64_t a1, float64x2_t *this, double *a3)
{
  if (*(void *)(a1 + 8))
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      CA::Mat4Impl::mat4_unapply_inverse_to_rect(this, (int8x16_t *)(*(void *)(a1 + 16) + v5), a3);
      ++v6;
      v5 += 32;
    }
    while (v6 < *(void *)(a1 + 8));
  }
}

void CA::Mat4Impl::mat4_unapply_inverse_to_rect(float64x2_t *this, int8x16_t *a2, double *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  double v4 = *(double *)a2[1].i64;
  double v3 = *(double *)&a2[1].i64[1];
  if (v4 <= v3) {
    double v5 = *(double *)&a2[1].i64[1];
  }
  else {
    double v5 = *(double *)a2[1].i64;
  }
  if (v5 < 1.79769313e308)
  {
    uint64_t v8 = 0;
    double v9 = *(double *)&a2->i64[1];
    *(void *)&v22.f64[0] = a2->i64[0];
    v22.f64[1] = v9;
    v23.f64[0] = v4 + v22.f64[0];
    v23.f64[1] = v9;
    v24.f64[0] = v4 + v22.f64[0];
    v24.f64[1] = v3 + v9;
    v25.f64[0] = v22.f64[0];
    v25.f64[1] = v3 + v9;
    do
    {
      CA::Mat4Impl::mat4_unapply_inverse_to_point2(this, &v22.f64[v8], a3);
      v8 += 2;
    }
    while (v8 != 8);
    int8x16_t v10 = vbslq_s8((int8x16_t)vcgtq_f64(v23, v22), (int8x16_t)v22, (int8x16_t)v23);
    int8x16_t v11 = vbslq_s8((int8x16_t)vcgtq_f64(v22, v23), (int8x16_t)v22, (int8x16_t)v23);
    int8x16_t v12 = vbslq_s8((int8x16_t)vcgtq_f64(v25, v24), (int8x16_t)v24, (int8x16_t)v25);
    int64x2_t v13 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v24, v25), (int8x16_t)v24, (int8x16_t)v25);
    int8x16_t v14 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v12, (float64x2_t)v10), v10, v12);
    int64x2_t v15 = vcgtq_f64((float64x2_t)v11, (float64x2_t)v13);
    int8x16_t v16 = (int8x16_t)vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)v15, v11, (int8x16_t)v13), (float64x2_t)v14);
    *(double *)v13.i64 = vaddvq_f64((float64x2_t)v16);
    BOOL v17 = (v13.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
    v13.i64[0] &= ~0x8000000000000000;
    v15.i64[0] = 0x7FF0000000000000;
    int8x16_t v18 = vbslq_s8((int8x16_t)vdupq_lane_s64(vcgtq_s64(v15, v13).i64[0], 0), v16, (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL));
    unsigned int v19 = v17;
    int32x2_t v20 = vdup_n_s32(v19);
    v21.i64[0] = v20.u32[0];
    v21.i64[1] = v20.u32[1];
    *a2 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v21, 0x3FuLL)), v14, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL));
    a2[1] = v18;
  }
}

uint64_t CA::Render::FilterSubclass::identity_ROI(CA::Render::FilterSubclass *this, const CA::Render::Filter *a2, const CA::Render::Layer *a3)
{
  return 0;
}

uint64_t CA::OGL::GaussianBlurFilter::filter_alignment(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v20[1] = *(double *)MEMORY[0x1E4F143B8];
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(*(void *)*a2 + 184))(*a2, 34);
  if (result)
  {
    uint64_t v8 = *(unsigned int **)(a3 + 40);
    if (!v8) {
      goto LABEL_14;
    }
    uint64_t v9 = v8[4];
    if (!v9) {
      goto LABEL_14;
    }
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *(void *)&v8[2 * v10 + 6];
      if (*(_DWORD *)(v11 + 16) == 309) {
        break;
      }
      if (v9 == ++v10) {
        goto LABEL_14;
      }
    }
    if ((v10 & 0x80000000) == 0 && (uint64_t v12 = *(void *)(v11 + 24)) != 0 && *(unsigned char *)(v12 + 12) == 49)
    {
      int64x2_t v13 = (const char *)(v12 + 28);
      if (!strcmp((const char *)(v12 + 28), "low"))
      {
        uint64_t v14 = 1;
      }
      else
      {
        uint64_t result = strcmp(v13, "high");
        uint64_t v14 = 0;
        if (!result) {
          return result;
        }
      }
    }
    else
    {
LABEL_14:
      uint64_t v14 = 0;
    }
    double v19 = 0.0;
    v20[0] = 0.0;
    if ((*(unsigned char *)(a4 + 288) & 0x10) != 0)
    {
      CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)(a4 + 144), v20, &v19, v7);
      double v15 = v19;
      double v16 = v20[0];
    }
    else
    {
      double v15 = *(double *)(a4 + 272);
      double v19 = v15;
      v20[0] = v15;
      double v16 = v15;
    }
    if (v16 >= v15) {
      double v17 = v15;
    }
    else {
      double v17 = v16;
    }
    float v18 = v17 * CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v8, 310, 0.0);
    return CA::OGL::blur_downsample_alignment((CA::OGL *)v14, (float)(v18 * v18));
  }
  return result;
}

double *CA::OGL::BlurFilter::ROI(CA::OGL::BlurFilter *this, CA::Render::KeyValueArray **a2, const CA::Render::Layer *a3, float64x2_t *a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  float64x2_t v17 = 0u;
  float64x2_t v18 = 0u;
  if ((*(unsigned int (**)(CA::OGL::BlurFilter *, CA::Render::KeyValueArray **, const CA::Render::Layer *, float64x2_t *))(*(void *)this + 144))(this, a2, a3, &v17))
  {
    float64x2_t v7 = a4[1];
    int64x2_t v8 = vclezq_f64(v7);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0] & 0x8000000000000000) == 0)
    {
      int64x2_t v9 = vclezq_f64(v18);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v9, 1), (int8x16_t)v9).u64[0] & 0x8000000000000000) != 0
        || (float64x2_t v10 = vaddq_f64(*a4, v7),
            float64x2_t v11 = vmaxnmq_f64(*a4, v17),
            float64x2_t v12 = vsubq_f64(vminnmq_f64(v10, vaddq_f64(v17, v18)), v11),
            int64x2_t v13 = vclezq_f64(v12),
            (vorrq_s8((int8x16_t)vdupq_laneq_s64(v13, 1), (int8x16_t)v13).u64[0] & 0x8000000000000000) != 0))
      {
        a4[1].f64[0] = 0.0;
        a4[1].f64[1] = 0.0;
      }
      else
      {
        *a4 = v11;
        a4[1] = v12;
      }
    }
  }
  double float_key = CA::Render::KeyValueArray::get_float_key(a2[5], 310, 0.0);
  float v15 = (*(float (**)(CA::OGL::BlurFilter *))(*(void *)this + 152))(this);
  return CA::BoundsImpl::inset(a4->f64, -(float_key * v15), -(float_key * v15));
}

uint64_t CA::OGL::blur_downsample_alignment(CA::OGL *this, double a2)
{
  if (this)
  {
    double v2 = 20.0;
    double v3 = 5.5;
    double v4 = 3.5;
  }
  else
  {
    double v4 = 3.5;
    double v3 = 5.5;
    if (a2 > 100.0)
    {
      double v4 = 5.5;
      double v3 = 9.5;
    }
    if (a2 > 3600.0)
    {
      double v4 = v4 + 1.0;
      double v3 = v3 + 1.0;
    }
    double v2 = 20.0;
    if (a2 > 3600.0) {
      double v2 = 21.0;
    }
    if (a2 > 10000.0)
    {
      double v4 = v4 + 1.0;
      double v3 = v3 + 1.0;
      double v2 = v2 + 1.0;
    }
  }
  if (v2 * v2 < a2) {
    return 8;
  }
  if (v3 * v3 >= a2) {
    return 2 * (v4 * v4 < a2);
  }
  return 4;
}

float64_t CA::Render::MeshTransform::unapply_rect(CA::Render::MeshTransform *this, const CA::Rect *a2, const CA::Rect *a3, float64x2_t a4, float64x2_t a5, float64x2_t a6, float64x2_t a7)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  CA::Render::MeshTransform::frame((CA::Render::MeshTransform *)v26, (const Rect *)a2, a4, a5);
  float64x2_t v9 = vsubq_f64(*(float64x2_t *)((char *)&v26[1] + 8), v26[0]);
  if (v9.f64[0] >= v9.f64[1]) {
    double v10 = v9.f64[1];
  }
  else {
    double v10 = v9.f64[0];
  }
  float64x2_t v11 = 0uLL;
  BOOL v12 = v10 <= 0.0;
  float64x2_t v13 = 0uLL;
  if (!v12)
  {
    if (v9.f64[0] <= v9.f64[1]) {
      double v14 = v9.f64[1];
    }
    else {
      double v14 = v9.f64[0];
    }
    if (v14 >= 1.79769313e308)
    {
      float64x2_t v13 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
      float64x2_t v11 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    }
    else
    {
      float64x2_t v11 = v9;
      float64x2_t v13 = v26[0];
    }
  }
  int64x2_t v15 = vclezq_f64(a7);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v15, 1), (int8x16_t)v15).u64[0] & 0x8000000000000000) != 0
    || (int64x2_t v16 = vclezq_f64(v11),
        (vorrq_s8((int8x16_t)vdupq_laneq_s64(v16, 1), (int8x16_t)v16).u64[0] & 0x8000000000000000) != 0)
    || (int64x2_t v17 = vclezq_f64(vsubq_f64(vminnmq_f64(vaddq_f64(a6, a7), vaddq_f64(v13, v11)), vmaxnmq_f64(a6, v13))),
        (vorrq_s8((int8x16_t)vdupq_laneq_s64(v17, 1), (int8x16_t)v17).u64[0] & 0x8000000000000000) != 0))
  {
    v18.f64[0] = 0.0;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
  }
  else
  {
    float64x2_t v18 = *(float64x2_t *)((char *)a2 + 120);
    float64x2_t v19 = *(float64x2_t *)((char *)a2 + 136);
    *(float64x2_t *)this = v18;
    *((float64x2_t *)this + 1) = v19;
    if (*((_DWORD *)a2 + 24))
    {
      float64x2_t v20 = vmlaq_f64(a4, a5, v18);
      float64x2_t v18 = vmulq_f64(v19, a5);
      *(float64x2_t *)this = v20;
      *((float64x2_t *)this + 1) = v18;
    }
  }
  return v18.f64[0];
}

void CA::OGL::MeshNode::compute_dod(CA::OGL::MeshNode *this, CA::Bounds *a2, const CA::Rect *a3, int32x4_t a4, int32x4_t a5, double a6, double a7, double a8, double a9, int32x4_t a10)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *((void *)this + 3);
  int v13 = *(_DWORD *)(v12 + 136);
  if (v13 < 0)
  {
    (*(void (**)(void, uint64_t))(*(void *)v12 + 40))(*((void *)this + 3), v12 + 128);
    int v13 = *(_DWORD *)(v12 + 136);
  }
  int v14 = *(_DWORD *)(v12 + 140);
  if (v13 <= v14) {
    int v15 = *(_DWORD *)(v12 + 140);
  }
  else {
    int v15 = v13;
  }
  a4.i32[0] = 1073741822;
  a5.i32[0] = v15;
  int8x16_t v16 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a5, a4), 0);
  uint64_t v17 = *(void *)(v12 + 128);
  v18.i64[0] = (int)v17;
  v18.i64[1] = SHIDWORD(v17);
  int8x16_t v33 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
  float64x2_t v19 = (float64x2_t)vbslq_s8(v16, v33, (int8x16_t)vcvtq_f64_s64(v18));
  double v20 = (double)v14;
  if (v15 <= 1073741822) {
    v21.f64[0] = (double)v13;
  }
  else {
    v21.f64[0] = 1.79769313e308;
  }
  if (v15 > 1073741822) {
    double v20 = 1.79769313e308;
  }
  v21.f64[1] = v20;
  double v22 = (float)(1.0 / *((float *)this + 60));
  memset(v34, 0, sizeof(v34));
  CA::Render::MeshTransform::apply_volume((CA::Render::MeshTransform *)v34, *((const CA::Rect **)this + 29), a3, *(float64x2_t *)(*(void *)(*((void *)this + 2) + 24) + 64), *(int8x16_t *)(*(void *)(*((void *)this + 2) + 24) + 80), vmulq_n_f64(v19, v22), vmulq_n_f64(v21, v22), v21.f64[0], a9, a10);
  CA::Volume::apply_transform((CA::Volume *)v34, *((float64x2_t **)this + 10), v23);
  float64x2_t v24 = 0uLL;
  float64x2_t v25 = vsubq_f64(*(float64x2_t *)((char *)&v34[1] + 8), v34[0]);
  if (v25.f64[0] >= v25.f64[1]) {
    double v26 = v25.f64[1];
  }
  else {
    double v26 = v25.f64[0];
  }
  BOOL v27 = v26 <= 0.0;
  float64x2_t v28 = 0uLL;
  if (!v27)
  {
    if (v25.f64[0] <= v25.f64[1]) {
      double v29 = v25.f64[1];
    }
    else {
      double v29 = v25.f64[0];
    }
    if (v29 >= 1.79769313e308)
    {
      float64x2_t v24 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      float64x2_t v28 = (float64x2_t)v33;
    }
    else
    {
      float64x2_t v24 = v25;
      float64x2_t v28 = v34[0];
    }
  }
  int64x2_t v30 = vceqzq_f64(v24);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v30, 1), (int8x16_t)v30).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v31 = vorrq_s8((int8x16_t)vcltzq_f64(v24), (int8x16_t)vcgezq_f64(v24)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v31), 1), v31).u64[0] & 0x8000000000000000) != 0))
  {
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
  }
  else
  {
    int32x4_t v32 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v28, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    *(int32x4_t *)a2 = vuzp1q_s32(v32, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v28, v24), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v32));
  }
}

void CA::Render::Updater::MeshOp::map_bounds(CA::Render::Updater::MeshOp *this, CA::Render::Updater::LayerShapes *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  memset(v22, 0, sizeof(v22));
  CA::Rect::unapply_transform((double *)a2, *((void *)this + 3));
  CA::Render::MeshTransform::apply_volume((CA::Render::MeshTransform *)v22, *((const CA::Rect **)this + 4), v4, *(float64x2_t *)((char *)this + 40), *(int8x16_t *)((char *)this + 56), *(float64x2_t *)a2, *((float64x2_t *)a2 + 1), v5, v6, v7);
  uint64_t v8 = *((void *)this + 3);
  *(float64x2_t *)float64x2_t v23 = v22[0];
  float64x2_t v24 = vsubq_f64(*(float64x2_t *)((char *)&v22[1] + 8), v22[0]);
  CA::Rect::apply_transform((double *)v23, v8);
  float64x2_t v10 = v24;
  double v11 = v24.f64[1];
  if (v24.f64[0] >= v24.f64[1]) {
    double v12 = v24.f64[1];
  }
  else {
    double v12 = v24.f64[0];
  }
  if (v12 <= 0.0)
  {
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
  }
  else
  {
    if (v24.f64[0] > v24.f64[1]) {
      double v11 = v24.f64[0];
    }
    if (v11 >= 1.79769313e308)
    {
      *(int64x2_t *)a2 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
      *((int64x2_t *)a2 + 1) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    }
    else
    {
      *(_OWORD *)a2 = *(_OWORD *)v23;
      *((float64x2_t *)a2 + 1) = v10;
    }
  }
  uint64_t v13 = *((void *)a2 + 8);
  float64_t v14 = v22[2].f64[1];
  *((void *)a2 + 4) = *(void *)&v22[1].f64[0];
  *((float64_t *)a2 + 5) = v14;
  if (v13)
  {
    float64x2_t v15 = *((float64x2_t *)a2 + 1);
    int64x2_t v16 = vceqzq_f64(v15);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v16, 1), (int8x16_t)v16).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v17 = vorrq_s8((int8x16_t)vcltzq_f64(v15), (int8x16_t)vcgezq_f64(v15)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v17), 1), v17).u64[0] & 0x8000000000000000) != 0))
    {
      v23[0] = 0;
      v23[1] = 0;
    }
    else
    {
      int32x4_t v18 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(*(float64x2_t *)a2, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      *(int32x4_t *)float64x2_t v23 = vuzp1q_s32(v18, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(*(float64x2_t *)a2, v15), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v18));
    }
    CA::shape_union((CA::Shape **)a2 + 8, v23, v9);
  }
  float64x2_t v19 = (CA::Shape *)*((void *)a2 + 7);
  if (v19)
  {
    if (v19)
    {
      if (v19 == (CA::Shape *)1) {
        goto LABEL_23;
      }
    }
    else if (*((_DWORD *)v19 + 1) == 6)
    {
      goto LABEL_23;
    }
    CA::Shape::unref(v19);
    *((void *)a2 + 7) = 1;
  }
LABEL_23:
  uint64_t v20 = *((void *)a2 + 6);
  if (v20)
  {
    *(unsigned char *)(v20 + 16) = 1;
    float64x2_t v21 = *(void **)(v20 + 8);
    if (v21)
    {
      CA::GenericRectTree<CA::Rect>::Pool::delete_node(*(void *)v20, v21);
      *(void *)(v20 + 8) = 0;
    }
  }
}

float64_t CA::Render::MeshTransform::apply_volume(CA::Render::MeshTransform *this, const CA::Rect *a2, const CA::Rect *a3, float64x2_t a4, int8x16_t a5, float64x2_t a6, float64x2_t a7, double a8, double a9, int32x4_t a10)
{
  int64x2_t v10 = vclezq_f64(a7);
  int32x4_t v11 = (int32x4_t)vorrq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10);
  if ((v11.i64[0] & 0x8000000000000000) == 0)
  {
    v11.i32[0] = 0;
    a10.i32[0] = *((_DWORD *)a2 + 24);
    int8x16_t v12 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(a10, v11), 0);
    __asm { FMOV            V6.2D, #1.0 }
    float64x2_t v18 = vmulq_f64(*(float64x2_t *)((char *)a2 + 136), (float64x2_t)vbslq_s8(v12, _Q6, a5));
    int64x2_t v19 = vclezq_f64(v18);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v19, 1), (int8x16_t)v19).u64[0] & 0x8000000000000000) == 0)
    {
      float64x2_t v20 = (float64x2_t)vbslq_s8(v12, *(int8x16_t *)((char *)a2 + 120), (int8x16_t)vmlaq_f64(a4, (float64x2_t)a5, *(float64x2_t *)((char *)a2 + 120)));
      int64x2_t v21 = vclezq_f64(vsubq_f64(vminnmq_f64(vaddq_f64(a6, a7), vaddq_f64(v20, v18)), vmaxnmq_f64(a6, v20)));
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v21, 1), (int8x16_t)v21).u64[0] & 0x8000000000000000) == 0) {
        return CA::Render::MeshTransform::frame(this, (const Rect *)a2, a4, (float64x2_t)a5);
      }
    }
  }
  *(_OWORD *)this = CA::Volume::null;
  *((_OWORD *)this + 1) = unk_1849A7DA0;
  float64_t result = -1.0;
  *((_OWORD *)this + 2) = xmmword_1849A7DB0;
  return result;
}

float64_t CA::Render::MeshTransform::frame(CA::Render::MeshTransform *this, const Rect *a2, float64x2_t a3, float64x2_t a4)
{
  long long v4 = *(_OWORD *)&a2[21].top;
  *(_OWORD *)this = *(_OWORD *)&a2[19].top;
  *((_OWORD *)this + 1) = v4;
  *((_OWORD *)this + 2) = *(_OWORD *)&a2[23].top;
  int v5 = *(_DWORD *)&a2[12].top;
  if (v5)
  {
    *(float64x2_t *)this = vmlaq_f64(a3, a4, *(float64x2_t *)this);
    *(float64x2_t *)((char *)this + 24) = vmlaq_f64(a3, a4, *(float64x2_t *)((char *)this + 24));
    switch(v5)
    {
      case 2:
        double v6 = 0.5 * a4.f64[0];
        break;
      case 3:
        double v6 = vmuld_lane_f64(0.5, a4, 1);
        break;
      case 4:
        double v7 = a4.f64[1];
        if (a4.f64[0] < a4.f64[1]) {
          double v7 = a4.f64[0];
        }
        goto LABEL_11;
      case 5:
        double v7 = a4.f64[1];
        if (a4.f64[0] > a4.f64[1]) {
          double v7 = a4.f64[0];
        }
LABEL_11:
        double v8 = 0.5;
        goto LABEL_13;
      case 6:
        double v7 = vaddvq_f64(a4);
        double v8 = 0.25;
LABEL_13:
        double v6 = v7 * v8;
        break;
      default:
        double v6 = 0.5;
        break;
    }
    *((double *)this + 2) = *((double *)this + 2) * v6;
    a3.f64[0] = *((double *)this + 5) * v6;
    *((void *)this + 5) = *(void *)&a3.f64[0];
  }
  return a3.f64[0];
}

void CA::Volume::apply_transform(CA::Volume *this, float64x2_t *a2, double *a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if ((LOBYTE(a2[9].f64[0]) & 0x10) == 0)
  {
    float64x2_t v4 = vsubq_f64(*(float64x2_t *)((char *)this + 24), *(float64x2_t *)this);
    v47[0] = *(int8x16_t *)this;
    v47[1] = (int8x16_t)v4;
    CA::Rect::apply_transform(v47, (const CA::Transform *)a2, a3);
    float64x2_t v5 = (float64x2_t)v47[0];
    float64x2_t v6 = (float64x2_t)v47[1];
    *(int8x16_t *)this = v47[0];
    *(float64x2_t *)((char *)this + 24) = vaddq_f64(v6, v5);
    return;
  }
  uint64_t v7 = 0;
  char v8 = 1;
  memset(v47, 0, sizeof(v47));
  do
  {
    uint64_t v9 = 0;
    char v10 = v8;
    if (v8) {
      uint64_t v11 = 0;
    }
    else {
      uint64_t v11 = 24;
    }
    uint64_t v12 = *(void *)((char *)this + v11);
    char v13 = 1;
    do
    {
      uint64_t v14 = 0;
      char v15 = v13;
      uint64_t v16 = v9 | v7;
      if (v13) {
        uint64_t v17 = 8;
      }
      else {
        uint64_t v17 = 32;
      }
      uint64_t v18 = *(void *)((char *)this + v17);
      char v19 = 1;
      do
      {
        float64x2_t v20 = &v47[2 * (v16 | v14)];
        v20->i64[0] = v12;
        v20->i64[1] = v18;
        int v21 = v19 & 1;
        if (v19) {
          uint64_t v22 = 16;
        }
        else {
          uint64_t v22 = 40;
        }
        v20[1].i64[0] = *(void *)((char *)this + v22);
        v20[1].i64[1] = 0x3FF0000000000000;
        uint64_t v14 = 1;
        char v19 = 0;
      }
      while (v21);
      char v13 = 0;
      uint64_t v9 = 2;
    }
    while ((v15 & 1) != 0);
    char v8 = 0;
    uint64_t v7 = 4;
  }
  while ((v10 & 1) != 0);
  uint64_t v23 = 0;
  float64x2_t v24 = *a2;
  float64x2_t v25 = a2[1];
  float64x2_t v26 = a2[2];
  float64x2_t v27 = a2[3];
  float64x2_t v28 = a2[4];
  float64x2_t v29 = a2[5];
  float64x2_t v30 = a2[6];
  float64x2_t v31 = a2[7];
  do
  {
    int32x4_t v32 = (float64x2_t *)&v47[v23];
    float64x2_t v33 = (float64x2_t)v47[v23];
    float64x2_t v34 = (float64x2_t)v47[v23 + 1];
    *int32x4_t v32 = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v24, v33.f64[0]), v26, v33, 1), v28, v34.f64[0]), v30, v34, 1);
    v32[1] = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v25, v33.f64[0]), v27, v33, 1), v29, v34.f64[0]), v31, v34, 1);
    v23 += 2;
  }
  while (v23 != 16);
  uint64_t v35 = 0;
  int8x16_t v36 = (int8x16_t)vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  int8x16_t v37 = (int8x16_t)xmmword_184998550;
  int8x16_t v38 = (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  while (1)
  {
    int8x16_t v39 = v47[v35];
    double v40 = *(double *)v47[v35 + 1].i64;
    double v41 = *(double *)&v47[v35 + 1].i64[1];
    if (v41 != 1.0) {
      break;
    }
LABEL_24:
    *(void *)&v43.f64[1] = v37.i64[1];
    v43.f64[0] = v40;
    int8x16_t v44 = vextq_s8(v39, v39, 8uLL);
    *(void *)&v45.f64[1] = v44.i64[1];
    *(void *)&v45.f64[0] = v37.i64[0];
    int8x16_t v38 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v38, (float64x2_t)v39), v39, v38);
    v46.i64[1] = v44.i64[1];
    *(double *)v46.i64 = v40;
    int8x16_t v37 = vbslq_s8((int8x16_t)vcgtq_f64(v45, v43), v46, v37);
    *(double *)&v44.i64[1] = v40;
    int8x16_t v36 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v44, (float64x2_t)v36), v44, v36);
    v35 += 2;
    if (v35 == 16)
    {
      *(int8x16_t *)this = v38;
      *((int8x16_t *)this + 1) = v37;
      goto LABEL_27;
    }
  }
  if (v41 > 0.0)
  {
    double v42 = 1.0 / v41;
    int8x16_t v39 = (int8x16_t)vmulq_n_f64((float64x2_t)v39, v42);
    double v40 = v42 * v40;
    goto LABEL_24;
  }
  *(_OWORD *)this = CA::Volume::infinity;
  *((_OWORD *)this + 1) = unk_1849A7DD0;
  int8x16_t v36 = (int8x16_t)xmmword_1849A7DE0;
LABEL_27:
  *((int8x16_t *)this + 2) = v36;
}

void CA::OGL::Shape::FillRenderer::render_mask(CA::OGL::Shape::FillRenderer *this, unsigned __int8 *a2, uint64_t a3, const CA::Bounds *a4)
{
}

void CA::ScanConverter::render_mask(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  int v11 = v10;
  int v13 = v12;
  int v15 = v14;
  int v17 = v16;
  int v19 = v18;
  uint64_t v20 = v9;
  v225[1020] = *MEMORY[0x1E4F143B8];
  uint64_t v215 = v22;
  uint64_t v218 = v21 - v16 - v14 * v22;
  uint64_t v23 = *(void *)(v9 + 24);
  uint64_t v24 = 32 * v23;
  if (a9)
  {
    if ((unint64_t)(32 * v23) > 0x1000)
    {
      float64x2_t v25 = (char *)malloc_type_malloc(32 * v23, 0x145CA901uLL);
      if (!v25) {
        return;
      }
    }
    else
    {
      MEMORY[0x1F4188790](v9);
      float64x2_t v25 = (char *)&v211 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v25, 32 * v23);
    }
    unint64_t v213 = 32 * v23;
    float64x2_t v27 = *(void **)(v20 + 8);
    if (v27)
    {
      uint64_t v28 = 0;
      do
      {
        uint64_t v29 = v27[1];
        if (v29)
        {
          float64x2_t v30 = (int *)(v27 + 3);
          float64x2_t v31 = &v25[16 * v28 + 8];
          v28 += v29;
          int32x4_t v32 = (int *)(v27 + 3);
          do
          {
            int v33 = *v32;
            v32 += 6;
            *((_DWORD *)v31 - 2) = ((v33 >> 31) | 0x80000000) ^ v33;
            *(void *)float64x2_t v31 = v30;
            v31 += 16;
            float64x2_t v30 = v32;
            --v29;
          }
          while (v29);
        }
        float64x2_t v27 = (void *)*v27;
      }
      while (v27);
    }
    float64x2_t v34 = &v25[16 * v23];
    v212 = v25;
    CA::radix_sort(v23);
    if (v17 <= -16777216) {
      int v37 = -16777216;
    }
    else {
      int v37 = v17;
    }
    int v216 = v37;
    if (v13 >= 0x1000000) {
      int v13 = 0x1000000;
    }
    if (v15 <= -16777216) {
      int v38 = -16777216;
    }
    else {
      int v38 = v15;
    }
    uint64_t v222 = 0;
    v223 = v225;
    if (v11 >= 0x1000000) {
      int v39 = 0x1000000;
    }
    else {
      int v39 = v11;
    }
    long long v224 = xmmword_184998000;
    v220 = 0;
    v221 = &v222;
    int v217 = v39;
    if (v38 < v39)
    {
      uint64_t v40 = 0;
      double v41 = v212;
      uint64_t v214 = v218 + v216;
      while (1)
      {
        double v42 = v220;
        if (v220)
        {
          float v43 = (float)v38;
          int v44 = v38 + 1;
          float v45 = (float)(v38 + 1);
          int8x16_t v46 = (float *)&v220;
          do
          {
            double v47 = (float *)*((void *)v42 + 2);
            float v48 = v47[1];
            if (v48 <= v43)
            {
              *(void *)int8x16_t v46 = *(void *)v42;
              *(void *)double v42 = v40;
              uint64_t v40 = (uint64_t)v42;
              double v42 = v46;
            }
            else
            {
              float v49 = *v47;
              if (*v47 >= v43) {
                float v50 = *v47;
              }
              else {
                float v50 = (float)v38;
              }
              if (v48 > v45) {
                float v48 = (float)v44;
              }
              float v51 = v47[2];
              float v52 = v47[3];
              float v53 = v47[4];
              float v54 = v53 + (float)((float)(v52 + (float)((float)(v50 - v49) * v51)) * (float)(v50 - v49));
              float v55 = v53 + (float)((float)(v52 + (float)((float)(v48 - v49) * v51)) * (float)(v48 - v49));
              if (v54 >= v55) {
                float v56 = v55;
              }
              else {
                float v56 = v54;
              }
              if (v54 > v55) {
                float v55 = v54;
              }
              *(float *)v36.i32 = fmaxf(v55 - v56, 0.000001);
              int32x2_t v36 = (int32x2_t)vrecpe_f32((float32x2_t)vdup_lane_s32(v36, 0));
              v42[7] = v56;
              v42[8] = v55;
              v42[6] = v47[5] * (float)(v48 - v50);
              v42[9] = *(float *)v36.i32;
              int8x16_t v46 = v42;
            }
            double v42 = *(float **)v42;
          }
          while (v42);
          double v57 = v220;
          if (v220)
          {
            char v58 = 0;
            float64x2_t v59 = &v220;
            do
            {
              while (1)
              {
                float64x2_t v60 = v59;
                float64x2_t v59 = (float **)v57;
                double v57 = *(float **)v57;
                if (!v57) {
                  break;
                }
                if (*((float *)v59 + 7) > v57[7])
                {
                  unsigned char *v60 = v57;
                  atomic_uint *v59 = *(float **)v57;
                  *(void *)double v57 = v59;
                  char v58 = 1;
                }
              }
              double v57 = v220;
              char v61 = v58 & (v220 != 0);
              float64x2_t v59 = &v220;
              char v58 = 0;
            }
            while ((v61 & 1) != 0);
          }
        }
        else
        {
          int v44 = v38 + 1;
          float v45 = (float)(v38 + 1);
        }
        LODWORD(v218) = v44;
        if (v41 >= v34) {
          goto LABEL_81;
        }
        unint64_t v62 = 0;
        uint64_t v63 = 0;
        float v64 = (float)v38;
        do
        {
          double v65 = (float *)*((void *)v41 + 1);
          float v66 = *v65;
          if (*v65 >= v45) {
            break;
          }
          float v67 = v65[1];
          if (v67 > v64)
          {
            if (v40)
            {
              uint64_t v68 = *(void *)v40;
            }
            else
            {
              uint64_t v40 = x_heap_malloc_small_(v221, 0x28uLL);
              uint64_t v68 = 0;
              double v65 = (float *)*((void *)v41 + 1);
              float v66 = *v65;
              float v67 = v65[1];
            }
            *(void *)(v40 + 16) = v65;
            if (v66 >= v64) {
              float v69 = v66;
            }
            else {
              float v69 = (float)v38;
            }
            if (v67 > v45) {
              float v67 = v45;
            }
            float v70 = v65[2];
            float v71 = v65[3];
            float v72 = v65[4];
            float v73 = v72 + (float)((float)(v71 + (float)((float)(v69 - v66) * v70)) * (float)(v69 - v66));
            float v74 = v72 + (float)((float)(v71 + (float)((float)(v67 - v66) * v70)) * (float)(v67 - v66));
            if (v73 >= v74) {
              float v75 = v74;
            }
            else {
              float v75 = v73;
            }
            if (v73 > v74) {
              float v74 = v73;
            }
            v35.f32[0] = fmaxf(v74 - v75, 0.000001);
            float32x2_t v35 = (float32x2_t)vdup_lane_s32((int32x2_t)v35, 0);
            *(float *)(v40 + 28) = v75;
            *(float *)(v40 + 32) = v74;
            *(float *)(v40 + 24) = v65[5] * (float)(v67 - v69);
            *(_DWORD *)(v40 + 36) = vrecpe_f32(v35).u32[0];
            *(void *)uint64_t v40 = v63;
            ++v62;
            uint64_t v63 = v40;
            uint64_t v40 = v68;
          }
          v41 += 16;
        }
        while (v41 < v34);
        if (!v62) {
          goto LABEL_81;
        }
        if (v62 != 1) {
          uint64_t v63 = CA::ScanConverter::RendererImpl::Edge::sort_xmin((uint64_t *)v63, v62);
        }
        uint32x2_t v76 = (uint64_t *)&v220;
        if (v63) {
          break;
        }
LABEL_78:
        if (!*v76)
        {
          uint64_t v63 = 0;
LABEL_80:
          *uint32x2_t v76 = v63;
        }
LABEL_81:
        uint64_t v79 = v220;
        if (v220)
        {
          if (v216 < v13)
          {
            uint64_t v80 = 0;
            unsigned __int32 v81 = (unsigned char *)(v214 + v38 * v215);
            float v82 = 0.0;
            for (int i = v216; ; int i = v92)
            {
              for (j = (float)i; v80; uint64_t v80 = *(void *)(v80 + 8))
              {
                if (*(float *)(v80 + 32) > j) {
                  break;
                }
                float v82 = *(float *)(v80 + 24) + v82;
              }
              float v85 = j + 1.0;
              uint64_t v219 = v80;
              if (v79) {
                break;
              }
LABEL_105:
              uint64_t v79 = 0;
              int v92 = v13;
              if (!v80) {
                goto LABEL_139;
              }
LABEL_108:
              float v93 = 1.0;
              float v94 = v82;
              do
              {
                uint64_t v95 = v80;
                float v96 = *(float *)(v80 + 28);
                if (v96 >= j) {
                  float v97 = *(float *)(v80 + 28);
                }
                else {
                  float v97 = (float)i;
                }
                float v98 = *(float *)(v80 + 32);
                if (v98 > v85) {
                  float v98 = j + 1.0;
                }
                float v94 = v94
                    + (float)((float)(*(float *)(v80 + 24) * v93)
                            * (float)((float)(v85 - v98)
                                    + (float)((float)((float)(v97 - v98) * *(float *)(v80 + 36))
                                            * (float)(v96 + (float)((float)(v98 + v97) * -0.5)))));
                uint64_t v80 = *(void *)(v80 + 8);
                if (v19 == 1)
                {
                  if (!v80)
                  {
                    float v101 = fabsf(v94);
                    goto LABEL_124;
                  }
                  int8x16_t v99 = *(float **)(v95 + 16);
                  int8x16_t v100 = *(float **)(v80 + 16);
                  if (v99[5] == v100[5] && *v99 != v100[1] && v99[1] != *v100) {
                    float v93 = -v93;
                  }
                }
              }
              while (v80);
              float v101 = fabsf(v94);
              if (!v19)
              {
                float v102 = fminf(v101, 1.0);
                goto LABEL_126;
              }
LABEL_124:
              int v103 = (int)v101;
              float v102 = v101 - truncf(v101);
              if (v103) {
                float v102 = 1.0 - v102;
              }
LABEL_126:
              int v92 = i + 1;
              *v81++ = (int)(float)(v102 * 255.99);
LABEL_166:
              if (v92 >= v13) {
                goto LABEL_168;
              }
              uint64_t v80 = v219;
            }
            while (1)
            {
LABEL_88:
              float32x2_t v86 = v79;
              float v87 = v79[7];
              if (v85 <= v87)
              {
                uint64_t v80 = v219;
                if (v219) {
                  goto LABEL_108;
                }
                float v104 = floorf(v87);
                if (v104 < -16777000.0) {
                  float v104 = -16777000.0;
                }
                float v105 = 16777000.0;
                if (v87 <= 16777000.0) {
                  float v105 = v79[7];
                }
                if (v87 >= 0.0) {
                  float v104 = v105;
                }
                if (v13 >= (int)v104 && (LODWORD(v87) & 0x7FFFFFFFu) <= 0x7F7FFFFF) {
                  int v92 = (int)v104;
                }
                else {
                  int v92 = v13;
                }
LABEL_139:
                float v107 = fabsf(v82);
                if (v19)
                {
                  int v108 = (int)v107;
                  float v107 = v107 - truncf(v107);
                  if (v108) {
                    float v107 = 1.0 - v107;
                  }
LABEL_144:
                  signed int v109 = v92 - i;
                  if (v107 == 0.0)
                  {
LABEL_165:
                    v81 += v109;
                    goto LABEL_166;
                  }
                }
                else
                {
                  if (v107 < 1.0) {
                    goto LABEL_144;
                  }
                  signed int v109 = v92 - i;
                  float v107 = 1.0;
                }
                uint64_t v110 = (int)(float)(v107 * 255.99);
                unint64_t v111 = v109;
                if (v109 <= 8)
                {
                  if (v109) {
                    memset(v81, v110, v109);
                  }
                  goto LABEL_165;
                }
                double v112 = v81;
                if (v81)
                {
                  *unsigned __int32 v81 = v110;
                  double v112 = v81 + 1;
                  unint64_t v111 = v109 - 1;
                }
                uint64_t v113 = v110 | (v110 << 8);
                if ((v112 & 2) != 0)
                {
                  *v112++ = v113;
                  v111 -= 2;
                }
                uint64_t v114 = v113 | (v113 << 16);
                if ((v112 & 4) != 0)
                {
                  *(_DWORD *)double v112 = v114;
                  v112 += 2;
                  v111 -= 4;
                }
                if (v111 >= 8)
                {
                  do
                  {
                    *(void *)double v112 = v114 | (v114 << 32);
                    v112 += 4;
                    v111 -= 8;
                  }
                  while (v111 > 7);
                }
                char v115 = v111 - 4;
                if (v111 >= 4)
                {
                  *(_DWORD *)double v112 = v114;
                  v112 += 2;
                  LODWORD(v111) = v111 - 4;
                  if ((v115 & 2) == 0) {
                    goto LABEL_158;
                  }
                }
                else if ((v111 & 2) == 0)
                {
LABEL_158:
                  if ((v111 & 1) == 0) {
                    goto LABEL_165;
                  }
LABEL_164:
                  *(unsigned char *)double v112 = v110;
                  goto LABEL_165;
                }
                *v112++ = v113;
                if (((v111 - 2) & 1) == 0) {
                  goto LABEL_165;
                }
                goto LABEL_164;
              }
              uint64_t v79 = *(float **)v79;
              float v88 = v86[8];
              if (v88 <= j)
              {
                float v82 = v86[6] + v82;
                if (v79) {
                  continue;
                }
LABEL_104:
                uint64_t v80 = v219;
                goto LABEL_105;
              }
              uint64_t v89 = v219;
              if (v219) {
                break;
              }
              unsigned int v90 = &v219;
LABEL_101:
              *unsigned int v90 = (uint64_t)v86;
              *((void *)v86 + 1) = 0;
              if (!v79) {
                goto LABEL_104;
              }
            }
            unsigned int v90 = &v219;
            while (1)
            {
              float v91 = *(float *)(v89 + 32);
              if (SLODWORD(v88) == SLODWORD(v91))
              {
                if (v87 < *(float *)(v89 + 28)) {
                  goto LABEL_103;
                }
              }
              else if (v88 < v91)
              {
LABEL_103:
                *((void *)v86 + 1) = v89;
                *unsigned int v90 = (uint64_t)v86;
                if (!v79) {
                  goto LABEL_104;
                }
                goto LABEL_88;
              }
              unsigned int v90 = (uint64_t *)(v89 + 8);
              uint64_t v89 = *(void *)(v89 + 8);
              if (!v89) {
                goto LABEL_101;
              }
            }
          }
LABEL_168:
          signed int v116 = v218;
        }
        else
        {
          if (v41 == v34) {
            goto LABEL_343;
          }
          signed int v117 = vcvtms_s32_f32(**((float **)v41 + 1));
          if (v38 <= v117) {
            signed int v116 = v117;
          }
          else {
            signed int v116 = v38;
          }
        }
        int v38 = v116;
        if (v116 >= v217) {
          goto LABEL_343;
        }
      }
      while (1)
      {
        int32x2_t v77 = (uint64_t *)*v76;
        if (!*v76) {
          goto LABEL_80;
        }
        if (*(float *)(v63 + 28) >= *((float *)v77 + 7))
        {
          uint32x2_t v76 = (uint64_t *)*v76;
          if (!v63) {
            goto LABEL_78;
          }
        }
        else
        {
          uint64_t v78 = *(void *)v63;
          *uint32x2_t v76 = v63;
          *(void *)uint64_t v63 = v77;
          uint64_t v63 = v78;
          if (!v78) {
            goto LABEL_78;
          }
        }
      }
    }
    goto LABEL_343;
  }
  if ((unint64_t)(32 * v23) > 0x1000)
  {
    float64x2_t v26 = (char *)malloc_type_malloc(32 * v23, 0x145CA901uLL);
    if (!v26) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](v9);
    float64x2_t v26 = (char *)&v211 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v26, 32 * v23);
  }
  unint64_t v213 = 32 * v23;
  int8x16_t v118 = *(void **)(v20 + 8);
  if (v118)
  {
    uint64_t v119 = 0;
    do
    {
      uint64_t v120 = v118[1];
      if (v120)
      {
        long long v121 = (int *)(v118 + 3);
        float64x2_t v122 = &v26[16 * v119 + 8];
        v119 += v120;
        int v123 = (int *)(v118 + 3);
        do
        {
          int v124 = *v123;
          v123 += 6;
          *((_DWORD *)v122 - 2) = ((v124 >> 31) | 0x80000000) ^ v124;
          *(void *)float64x2_t v122 = v121;
          v122 += 16;
          long long v121 = v123;
          --v120;
        }
        while (v120);
      }
      int8x16_t v118 = (void *)*v118;
    }
    while (v118);
  }
  uint64_t v125 = &v26[16 * v23];
  v212 = v26;
  CA::radix_sort(v23);
  if (v17 <= -16777216) {
    int v128 = -16777216;
  }
  else {
    int v128 = v17;
  }
  int v216 = v128;
  if (v13 >= 0x1000000) {
    int v13 = 0x1000000;
  }
  if (v15 <= -16777216) {
    int v129 = -16777216;
  }
  else {
    int v129 = v15;
  }
  uint64_t v222 = 0;
  v223 = v225;
  if (v11 >= 0x1000000) {
    int v130 = 0x1000000;
  }
  else {
    int v130 = v11;
  }
  long long v224 = xmmword_184998000;
  v220 = 0;
  v221 = &v222;
  int v217 = v130;
  if (v129 < v130)
  {
    uint64_t v131 = 0;
    float64x2_t v132 = &xmmword_184998000;
    int8x16_t v133 = v212;
    uint64_t v214 = v218 + v216;
    while (1)
    {
      float64x2_t v134 = v220;
      if (v220)
      {
        float v135 = (float)v129;
        int v136 = v129 + 1;
        float v137 = (float)(v129 + 1);
        int32x2_t v138 = (float *)&v220;
        do
        {
          int32x2_t v139 = (float *)*((void *)v134 + 2);
          float v140 = v139[1];
          if (v140 <= v135)
          {
            *(void *)int32x2_t v138 = *(void *)v134;
            *(void *)float64x2_t v134 = v131;
            uint64_t v131 = (uint64_t)v134;
            float64x2_t v134 = v138;
          }
          else
          {
            float v141 = *v139;
            if (*v139 >= v135) {
              float v142 = *v139;
            }
            else {
              float v142 = (float)v129;
            }
            if (v140 > v137) {
              float v140 = (float)v136;
            }
            float v143 = v139[2];
            float v144 = v139[3];
            float v145 = v139[4];
            float v146 = v145 + (float)((float)(v144 + (float)((float)(v142 - v141) * v143)) * (float)(v142 - v141));
            float v147 = v145 + (float)((float)(v144 + (float)((float)(v140 - v141) * v143)) * (float)(v140 - v141));
            if (v146 >= v147) {
              float v148 = v147;
            }
            else {
              float v148 = v146;
            }
            if (v146 > v147) {
              float v147 = v146;
            }
            *(float *)v127.i32 = fmaxf(v147 - v148, 0.000001);
            int32x2_t v127 = (int32x2_t)vrecpe_f32((float32x2_t)vdup_lane_s32(v127, 0));
            v134[7] = v148;
            v134[8] = v147;
            v134[6] = v139[5] * (float)(v140 - v142);
            v134[9] = *(float *)v127.i32;
            int32x2_t v138 = v134;
          }
          float64x2_t v134 = *(float **)v134;
        }
        while (v134);
        v149 = v220;
        if (v220)
        {
          char v150 = 0;
          v151 = &v220;
          do
          {
            while (1)
            {
              v152 = v151;
              v151 = (float **)v149;
              v149 = *(float **)v149;
              if (!v149) {
                break;
              }
              if (*((float *)v151 + 7) > v149[7])
              {
                *v152 = v149;
                *v151 = *(float **)v149;
                *(void *)v149 = v151;
                char v150 = 1;
              }
            }
            v149 = v220;
            char v153 = v150 & (v220 != 0);
            v151 = &v220;
            char v150 = 0;
          }
          while ((v153 & 1) != 0);
        }
      }
      else
      {
        int v136 = v129 + 1;
        float v137 = (float)(v129 + 1);
      }
      LODWORD(v218) = v136;
      if (v133 >= v125) {
        goto LABEL_250;
      }
      unint64_t v154 = 0;
      uint64_t v155 = 0;
      float v156 = (float)v129;
      do
      {
        v157 = (float *)*((void *)v133 + 1);
        float v158 = *v157;
        if (*v157 >= v137) {
          break;
        }
        float v159 = v157[1];
        if (v159 > v156)
        {
          if (v131)
          {
            uint64_t v160 = *(void *)v131;
          }
          else
          {
            uint64_t v161 = x_heap_malloc_small_(v221, 0x28uLL);
            float64x2_t v132 = &xmmword_184998000;
            uint64_t v131 = v161;
            uint64_t v160 = 0;
            v157 = (float *)*((void *)v133 + 1);
            float v158 = *v157;
            float v159 = v157[1];
          }
          *(void *)(v131 + 16) = v157;
          if (v158 >= v156) {
            float v162 = v158;
          }
          else {
            float v162 = (float)v129;
          }
          if (v159 > v137) {
            float v159 = v137;
          }
          float v163 = v157[2];
          float v164 = v157[3];
          float v165 = v157[4];
          float v166 = v165 + (float)((float)(v164 + (float)((float)(v162 - v158) * v163)) * (float)(v162 - v158));
          float v167 = v165 + (float)((float)(v164 + (float)((float)(v159 - v158) * v163)) * (float)(v159 - v158));
          if (v166 >= v167) {
            float v168 = v167;
          }
          else {
            float v168 = v166;
          }
          if (v166 > v167) {
            float v167 = v166;
          }
          v126.f32[0] = fmaxf(v167 - v168, 0.000001);
          float32x2_t v126 = (float32x2_t)vdup_lane_s32((int32x2_t)v126, 0);
          *(float *)(v131 + 28) = v168;
          *(float *)(v131 + 32) = v167;
          *(float *)(v131 + 24) = v157[5] * (float)(v159 - v162);
          *(_DWORD *)(v131 + 36) = vrecpe_f32(v126).u32[0];
          *(void *)uint64_t v131 = v155;
          ++v154;
          uint64_t v155 = v131;
          uint64_t v131 = v160;
        }
        v133 += 16;
      }
      while (v133 < v125);
      if (!v154) {
        goto LABEL_250;
      }
      if (v154 != 1)
      {
        uint64_t v169 = CA::ScanConverter::RendererImpl::Edge::sort_xmin((uint64_t *)v155, v154);
        float64x2_t v132 = &xmmword_184998000;
        uint64_t v155 = v169;
      }
      v170 = (float *)&v220;
      if (v155) {
        break;
      }
LABEL_247:
      if (!*(void *)v170)
      {
        uint64_t v155 = 0;
LABEL_249:
        *(void *)v170 = v155;
      }
LABEL_250:
      v173 = v220;
      if (v220)
      {
        if (v216 < v13)
        {
          uint64_t v174 = 0;
          v175 = (unsigned char *)(v214 + v129 * v215);
          float v176 = 0.0;
          for (int k = v216; ; int k = v186)
          {
            for (m = (float)k; v174; uint64_t v174 = *(void *)(v174 + 8))
            {
              if (*(float *)(v174 + 32) > m) {
                break;
              }
              float v176 = *(float *)(v174 + 24) + v176;
            }
            float v179 = m + 1.0;
            uint64_t v219 = v174;
            if (!v173)
            {
LABEL_274:
              v173 = 0;
              int v186 = v13;
              if (v174)
              {
LABEL_281:
                float v192 = 1.0;
                float v193 = v176;
                do
                {
                  uint64_t v194 = v174;
                  float v195 = *(float *)(v174 + 28);
                  if (v195 >= m) {
                    float v196 = *(float *)(v174 + 28);
                  }
                  else {
                    float v196 = (float)k;
                  }
                  float v197 = *(float *)(v174 + 32);
                  if (v197 > v179) {
                    float v197 = m + 1.0;
                  }
                  float v193 = v193
                       + (float)((float)(*(float *)(v174 + 24) * v192)
                               * (float)((float)(v179 - v197)
                                       + (float)((float)((float)(v196 - v197) * *(float *)(v174 + 36))
                                               * (float)(v195 + (float)((float)(v197 + v196) * -0.5)))));
                  uint64_t v174 = *(void *)(v174 + 8);
                  if (v19 == 1)
                  {
                    if (!v174) {
                      goto LABEL_295;
                    }
                    v198 = *(float **)(v194 + 16);
                    v199 = *(float **)(v174 + 16);
                    if (v198[5] == v199[5] && *v198 != v199[1] && v198[1] != *v199) {
                      float v192 = -v192;
                    }
                  }
                }
                while (v174);
                if (v19)
                {
LABEL_295:
                  float v200 = fabsf(v193);
                  int v201 = (int)v200;
                  float v202 = v200 - truncf(v200);
                  if (v201) {
                    float v202 = 1.0 - v202;
                  }
                  BOOL v203 = v202 > 0.0;
                  goto LABEL_300;
                }
                BOOL v203 = v193 < 0.0;
                if (v193 > 0.0) {
                  BOOL v203 = 1;
                }
LABEL_300:
                int v186 = k + 1;
                *v175++ = (int)(float)((float)v203 * *((float *)v132 + 569));
                goto LABEL_335;
              }
              if (!v19) {
                goto LABEL_314;
              }
LABEL_276:
              float v187 = fabsf(v176);
              int v188 = (int)v187;
              float v189 = v187 - truncf(v187);
              if (v188) {
                float v189 = 1.0 - v189;
              }
              LODWORD(v19CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v186 - k;
              if (v189 <= 0.0) {
                goto LABEL_279;
              }
LABEL_315:
              uint64_t v191 = (int)v190;
              if (v190 <= 8)
              {
                if (v186 != k)
                {
                  memset(v175, 255, (int)v190);
                  float64x2_t v132 = &xmmword_184998000;
                }
                goto LABEL_334;
              }
              v207 = v175;
              unint64_t v190 = (int)v190;
              if ((v175 & 1) == 0)
              {
                if ((v175 & 2) == 0) {
                  goto LABEL_318;
                }
LABEL_329:
                *v207++ = -1;
                v190 -= 2;
                if ((v207 & 4) == 0) {
                  goto LABEL_320;
                }
LABEL_319:
                *(_DWORD *)v207 = -1;
                v207 += 2;
                v190 -= 4;
                goto LABEL_320;
              }
              unsigned char *v175 = -1;
              v207 = v175 + 1;
              unint64_t v190 = (int)v190 - 1;
              if (((v175 + 1) & 2) != 0) {
                goto LABEL_329;
              }
LABEL_318:
              if ((v207 & 4) != 0) {
                goto LABEL_319;
              }
LABEL_320:
              if (v190 >= 8)
              {
                do
                {
                  *(void *)v207 = -1;
                  v207 += 4;
                  v190 -= 8;
                }
                while (v190 > 7);
              }
              char v208 = v190 - 4;
              if (v190 >= 4)
              {
                *(_DWORD *)v207 = -1;
                v207 += 2;
                LODWORD(v19CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v190 - 4;
                if ((v208 & 2) == 0) {
                  goto LABEL_324;
                }
              }
              else if ((v190 & 2) == 0)
              {
LABEL_324:
                if ((v190 & 1) == 0) {
                  goto LABEL_334;
                }
LABEL_333:
                *(unsigned char *)v207 = -1;
                goto LABEL_334;
              }
              *v207++ = -1;
              if (((v190 - 2) & 1) == 0) {
                goto LABEL_334;
              }
              goto LABEL_333;
            }
LABEL_257:
            while (1)
            {
              v180 = v173;
              float v181 = v173[7];
              if (v179 <= v181) {
                break;
              }
              v173 = *(float **)v173;
              float v182 = v180[8];
              if (v182 <= m)
              {
                float v176 = v180[6] + v176;
                if (v173) {
                  continue;
                }
LABEL_273:
                uint64_t v174 = v219;
                goto LABEL_274;
              }
              uint64_t v183 = v219;
              if (v219)
              {
                v184 = &v219;
                while (1)
                {
                  float v185 = *(float *)(v183 + 32);
                  if (SLODWORD(v182) == SLODWORD(v185))
                  {
                    if (v181 < *(float *)(v183 + 28)) {
                      goto LABEL_272;
                    }
                  }
                  else if (v182 < v185)
                  {
LABEL_272:
                    *((void *)v180 + 1) = v183;
                    uint64_t *v184 = (uint64_t)v180;
                    if (!v173) {
                      goto LABEL_273;
                    }
                    goto LABEL_257;
                  }
                  v184 = (uint64_t *)(v183 + 8);
                  uint64_t v183 = *(void *)(v183 + 8);
                  if (!v183) {
                    goto LABEL_270;
                  }
                }
              }
              v184 = &v219;
LABEL_270:
              uint64_t *v184 = (uint64_t)v180;
              *((void *)v180 + 1) = 0;
              if (!v173) {
                goto LABEL_273;
              }
            }
            uint64_t v174 = v219;
            if (v219) {
              goto LABEL_281;
            }
            float v204 = floorf(v181);
            if (v204 < -16777000.0) {
              float v204 = -16777000.0;
            }
            float v205 = 16777000.0;
            if (v181 <= 16777000.0) {
              float v205 = v173[7];
            }
            if (v181 >= 0.0) {
              float v204 = v205;
            }
            if (v13 >= (int)v204 && (LODWORD(v181) & 0x7FFFFFFFu) <= 0x7F7FFFFF) {
              int v186 = (int)v204;
            }
            else {
              int v186 = v13;
            }
            if (v19) {
              goto LABEL_276;
            }
LABEL_314:
            LODWORD(v19CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v186 - k;
            if (v176 != 0.0) {
              goto LABEL_315;
            }
LABEL_279:
            uint64_t v191 = (int)v190;
LABEL_334:
            v175 += v191;
LABEL_335:
            if (v186 >= v13) {
              break;
            }
            uint64_t v174 = v219;
          }
        }
        signed int v209 = v218;
      }
      else
      {
        if (v133 == v125) {
          goto LABEL_343;
        }
        signed int v210 = vcvtms_s32_f32(**((float **)v133 + 1));
        if (v129 <= v210) {
          signed int v209 = v210;
        }
        else {
          signed int v209 = v129;
        }
      }
      int v129 = v209;
      if (v209 >= v217) {
        goto LABEL_343;
      }
    }
    while (1)
    {
      v171 = *(float **)v170;
      if (!*(void *)v170) {
        goto LABEL_249;
      }
      if (*(float *)(v155 + 28) >= v171[7])
      {
        v170 = *(float **)v170;
        if (!v155) {
          goto LABEL_247;
        }
      }
      else
      {
        uint64_t v172 = *(void *)v155;
        *(void *)v170 = v155;
        *(void *)uint64_t v155 = v171;
        uint64_t v155 = v172;
        if (!v172) {
          goto LABEL_247;
        }
      }
    }
  }
LABEL_343:
  if (v213 > 0x1000) {
    free(v212);
  }
  x_heap_free((void ***)v221);
}

void CA::OGL::Shape::render_path(uint64_t a1)
{
  double v2 = MEMORY[0x1F4188790](a1);
  int v4 = v3;
  uint64_t v6 = v5;
  char v8 = v7;
  uint64_t v9 = v1;
  v80[1537] = *MEMORY[0x1E4F143B8];
  if (!*(void *)(v1[31] + 16)
    && (*(unsigned int (**)(void *, uint64_t, double))(*v1 + 184))(v1, 10, v2))
  {
    *(unsigned char *)(v9[2] + 16) = 13;
    int64x2_t v68 = 0u;
    long long v67 = 0u;
    long long v66 = 0u;
    v65.i64[0] = (uint64_t)v9;
    uint64_t v69 = v4;
    uint64_t v35 = v9[2];
    _H1 = *(_WORD *)(v35 + 8);
    v37.i64[0] = *(unsigned int *)(v35 + 10);
    __int16 v38 = *(_WORD *)(v35 + 14);
    __asm { FCMP            H8, #0 }
    _ZF = _ZF || _H8 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
    if (!_ZF)
    {
      __asm { FCVT            S2, H8 }
      float v45 = 1.0 / _S2;
      __asm { FCVT            S1, H1 }
      _S1 = v45 * _S1;
      float32x4_t v37 = vcvtq_f32_f16(*(float16x4_t *)v37.f32);
      *(float32x2_t *)v37.f32 = vmul_n_f32(*(float32x2_t *)v37.f32, v45);
      __asm { FCVT            H1, S1 }
      v37.i32[0] = vcvt_f16_f32(v37).u32[0];
    }
    v65.i16[4] = _H1;
    *(__int32 *)((char *)&v65.i32[2] + 2) = v37.i32[0];
    v65.i16[7] = v38;
    if (!(*(unsigned int (**)(void *, uint64_t))(*v9 + 184))(v9, 26)) {
      goto LABEL_29;
    }
    uint64_t v48 = v9[2];
    if ((*(unsigned char *)(v48 + 481) & 1) == 0)
    {
      BYTE1(v69) = 1;
LABEL_28:
      int64x2_t v68 = vdupq_n_s64(0x300uLL);
      *(void *)&long long v66 = &v70;
      *((void *)&v66 + 1) = v80;
LABEL_31:
      long long v67 = 0u;
      long long v64 = 0u;
      uint64_t v49 = *(void *)(v9[31] + 8);
      float64x2_t v60 = v9;
      uint64_t v61 = v49;
      long long v63 = 0u;
      uint64_t v62 = 0;
      BYTE8(v63) = 1;
      CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)&v60);
      for (long long i = 0uLL; ; *((void *)&i + 1) = 0)
      {
        do
        {
          while (1)
          {
            if (!CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)&v60, (int32x2_t *)&i))
            {
              if ((void)v67)
              {
                (*(void (**)(uint64_t, void, void, void))(*(void *)v65.i64[0] + 296))(v65.i64[0], 0, v67, v66);
                *(void *)&long long v67 = 0;
              }
              CA::OGL::Shape::Lines::flush(&v65, 1u);
              *(unsigned char *)(v9[2] + 16) = 0;
              return;
            }
            if (!(_BYTE)v69) {
              break;
            }
LABEL_34:
            (**(void (***)(uint64_t, float32x4_t *, long long *))v6)(v6, &v65, &i);
          }
          uint32x2_t v50 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&i + 8));
        }
        while ((vpmax_u32(v50, v50).u32[0] & 0x80000000) != 0);
        int32x2_t v51 = v8[1];
        uint32x2_t v52 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v51);
        if ((vpmax_u32(v52, v52).u32[0] & 0x80000000) == 0)
        {
          *(int32x2_t *)&long long v53 = vmax_s32(*(int32x2_t *)&i, *v8);
          int32x2_t v54 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)&i, *(int32x2_t *)((char *)&i + 8)), vadd_s32(*v8, v51)), *(int32x2_t *)&v53);
          uint32x2_t v55 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v54);
          if ((vpmax_u32(v55, v55).u32[0] & 0x80000000) == 0)
          {
            *((int32x2_t *)&v53 + 1) = v54;
            long long i = v53;
            goto LABEL_34;
          }
        }
      }
    }
    if (*(unsigned char *)(v48 + 480) == 3)
    {
      BYTE1(v69) = _H8 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
      if (_H8 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
        goto LABEL_28;
      }
    }
    else
    {
LABEL_29:
      BYTE1(v69) = 0;
    }
    v68.i64[0] = 1536;
    *(void *)&long long v66 = &v70;
    goto LABEL_31;
  }
  signed int v10 = v8[1].i32[0];
  if (v10 <= 3072 && v8[1].i32[1] <= 3072)
  {
    unint64_t v11 = CA::Render::format_rowbytes((CA::Render *)9, v10);
    unint64_t v12 = v11;
    *(void *)&long long i = v11;
    int v13 = is_mul_ok(v11, v8[1].u32[1]) ? (CA::Render *)(v11 * v8[1].u32[1]) : 0;
    if ((unint64_t)v13 <= 0x900000)
    {
      char v58 = 0;
      int v14 = (CGColorSpace *)CA::Render::aligned_malloc(v13, (unint64_t *)&v58, 0);
      if (v14)
      {
        int v15 = v14;
        (*(void (**)(uint64_t, CGColorSpace *, unint64_t, int32x2_t *))(*(void *)v6 + 8))(v6, v14, v12, v8);
        int v16 = v58;
        int v17 = CA::Render::Image::new_image((CA::Render::Image *)9, v8[1].u32[0], v8[1].u32[1], 1u, 0, v15, (unint64_t *)&i, (const unint64_t *)CA::Render::aligned_free, v58, v56);
        if (v17)
        {
          int v19 = (atomic_uint *)v17;
          uint64_t v20 = v9[2];
          unint64_t v21 = *(void *)(v20 + 16) & 0xFFFFFF00FF00FF00;
          if (*(void *)(v20 + 8) == 0x3C003C003C003C00) {
            int v22 = 1;
          }
          else {
            int v22 = 3;
          }
          *(_DWORD *)(v20 + 16) = v22 | v21;
          *(_DWORD *)(v20 + 2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = HIDWORD(v21);
          float32x4_t v65 = 0uLL;
          uint64_t v23 = CA::OGL::Context::bind_image((uint64_t)v9, 0, (uint32x2_t *)v17, 0, 0, 0, 0, 0, 0.0, &v65, 0);
          if (v23)
          {
            uint64_t v24 = v23;
            int v25 = v8->i32[0];
            int v26 = v8->i32[1];
            __int32 v27 = v8[1].i32[1];
            int v28 = v8[1].i32[0] + v8->i32[0];
            int v29 = v27 + v26;
            *(_OWORD *)float v73 = 0u;
            double v30 = *(double *)(v9[31] + 8);
            double v70 = *(double *)&v9;
            double v71 = v30;
            memset(v72, 0, sizeof(v72));
            *(_WORD *)&v72[16] = 256;
            CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)&v70);
            float64x2_t v60 = 0;
            uint64_t v61 = 0;
            while (CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)&v70, (int32x2_t *)&v60))
            {
              CA::OGL::Context::array_rect(v9, (float)v25, (float)v26, (float)v28, (float)v29);
              uint64_t v31 = v65.i64[1];
              uint64_t v32 = v65.i64[0];
              uint64_t v33 = v9[15] + 48 * v9[16];
              *(_DWORD *)(v33 - 176) = v65.i32[0];
              *(_DWORD *)(v33 - 172) = HIDWORD(v31);
              *(void *)(v33 - 128) = v31;
              *(_DWORD *)(v33 - 8CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v31;
              *(_DWORD *)(v33 - 76) = HIDWORD(v32);
              *(void *)(v33 - 32) = v32;
              uint64_t v34 = *(void *)(v9[2] + 8);
              *(void *)(v33 - 16CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v34;
              *(void *)(v33 - 112) = v34;
              *(void *)(v33 - 64) = v34;
              *(void *)(v33 - 16) = v34;
            }
            if (v4)
            {
              double v70 = (double)v25;
              double v71 = (double)v26;
              *(double *)&v72[16] = (double)v28;
              *(double *)float v73 = (double)v26;
              double v74 = (double)v28;
              double v75 = (double)v29;
              double v77 = (double)v25;
              double v78 = (double)v29;
              long long v79 = xmmword_184997D60;
              long long v76 = xmmword_184997D60;
              *(_OWORD *)&v73[8] = xmmword_184997D60;
              *(_OWORD *)float v72 = xmmword_184997D60;
              uint64_t v57 = 0;
              CA::OGL::emit_quad_surround((uint64_t)v9, &v70, &v57);
            }
            (*(void (**)(void *, _OWORD *, void))(*v9 + 520))(v9, v24, 0);
          }
          *(unsigned char *)(v9[2] + 16) = 0;
          if (atomic_fetch_add(v19 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v19 + 16))(v19);
          }
        }
        else
        {
          CA::Render::aligned_free(v15, (size_t)v16, v18);
        }
      }
    }
  }
}

void **CA::OGL::Shape::Lines::flush(void **result, unsigned int a2)
{
  double v2 = &result[a2];
  uint64_t v5 = v2[4];
  int v4 = v2 + 4;
  int v3 = v5;
  if (v5)
  {
    uint64_t v6 = result;
    uint64_t v7 = *result;
    uint64_t v8 = v7[2];
    unsigned __int8 v9 = *(unsigned char *)(v8 + 481);
    int v10 = (a2 == 1) & v9;
    if (v10 == 1)
    {
      *(unsigned char *)(v8 + 481) = v9 & 0xFE;
      uint64_t v7 = *v6;
      int v3 = (void *)*v4;
    }
    float64_t result = (void **)(*(uint64_t (**)(void *, void, void *, void *))(*v7 + 296))(v7, 0, v3, v6[a2 + 2]);
    *int v4 = 0;
    if (v10) {
      *(unsigned char *)((*v6)[2] + 481) |= 1u;
    }
  }
  return result;
}

void CA::OGL::Shape::FillRenderer::render_lines(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  v269[1020] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(v1 + 8);
  int v5 = *(_DWORD *)(v1 + 16);
  int v8 = *v6;
  int v7 = v6[1];
  int v9 = v6[2] + *v6;
  LODWORD(v1CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v6[3] + v7;
  uint64_t v11 = *(void *)(v4 + 24);
  uint64_t v12 = 32 * v11;
  if (!*(unsigned char *)(v1 + 20))
  {
    if ((unint64_t)(32 * v11) > 0x1000)
    {
      v254 = (char *)malloc_type_malloc(32 * v11, 0x145CA901uLL);
      if (!v254) {
        return;
      }
    }
    else
    {
      MEMORY[0x1F4188790](v1);
      v254 = (char *)&v253 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v254, 32 * v11);
    }
    unint64_t v253 = 32 * v11;
    uint64_t v131 = *(void **)(v4 + 8);
    if (v131)
    {
      uint64_t v132 = 0;
      int8x16_t v133 = v254 + 8;
      do
      {
        uint64_t v134 = v131[1];
        if (v134)
        {
          float v135 = (int *)(v131 + 3);
          int v136 = &v133[16 * v132];
          v132 += v134;
          float v137 = (int *)(v131 + 3);
          do
          {
            int v138 = *v137;
            v137 += 6;
            *((_DWORD *)v136 - 2) = ((v138 >> 31) | 0x80000000) ^ v138;
            *(void *)int v136 = v135;
            v136 += 16;
            float v135 = v137;
            --v134;
          }
          while (v134);
        }
        uint64_t v131 = (void *)*v131;
      }
      while (v131);
    }
    v258 = &v254[16 * v11];
    CA::radix_sort(v11);
    if (v8 <= -16777216) {
      int v141 = -16777216;
    }
    else {
      int v141 = v8;
    }
    int v257 = v141;
    if (v9 >= 0x1000000) {
      int v142 = 0x1000000;
    }
    else {
      int v142 = v9;
    }
    if (v7 <= -16777216) {
      int v143 = -16777216;
    }
    else {
      int v143 = v7;
    }
    uint64_t v266 = 0;
    v267 = v269;
    if (SLODWORD(v10) >= 0x1000000) {
      float v10 = 2.351e-38;
    }
    long long v268 = xmmword_184998000;
    v264 = 0;
    v265 = (void ***)&v266;
    if (v143 >= SLODWORD(v10))
    {
LABEL_375:
      if (v253 > 0x1000) {
        free(v254);
      }
      x_heap_free(v265);
      return;
    }
    float v144 = 0;
    uint64_t v145 = 0;
    float v255 = (float)v257 + 0.5;
    float v146 = (float)v142 + 0.5;
    float v147 = v254;
    unsigned int v260 = v142;
    float v256 = v10;
    while (1)
    {
      if (v144)
      {
        float v148 = (float)v143;
        signed int v262 = v143 + 1;
        float v149 = (float)(v143 + 1);
        char v150 = (float *)&v264;
        do
        {
          v151 = (float *)*((void *)v144 + 2);
          float v152 = v151[1];
          if (v152 <= v148)
          {
            *(void *)char v150 = *(void *)v144;
            *(void *)float v144 = v145;
            uint64_t v145 = (uint64_t)v144;
            float v144 = v150;
          }
          else
          {
            float v153 = *v151;
            if (*v151 >= v148) {
              float v154 = *v151;
            }
            else {
              float v154 = (float)v143;
            }
            if (v152 > v149) {
              float v152 = (float)(v143 + 1);
            }
            float v155 = v151[2];
            float v156 = v151[3];
            float v157 = v151[4];
            float v158 = v157 + (float)((float)(v156 + (float)((float)(v154 - v153) * v155)) * (float)(v154 - v153));
            float v159 = v157 + (float)((float)(v156 + (float)((float)(v152 - v153) * v155)) * (float)(v152 - v153));
            if (v158 >= v159) {
              float v160 = v159;
            }
            else {
              float v160 = v158;
            }
            if (v158 > v159) {
              float v159 = v158;
            }
            *(float *)v140.i32 = fmaxf(v159 - v160, 0.000001);
            int32x2_t v140 = (int32x2_t)vrecpe_f32((float32x2_t)vdup_lane_s32(v140, 0));
            v144[7] = v160;
            v144[8] = v159;
            v144[6] = v151[5] * (float)(v152 - v154);
            v144[9] = *(float *)v140.i32;
            char v150 = v144;
          }
          float v144 = *(float **)v144;
        }
        while (v144);
        uint64_t v161 = v264;
        float v162 = v258;
        if (v264)
        {
          char v163 = 0;
          float v164 = &v264;
          do
          {
            while (1)
            {
              float v165 = v164;
              float v164 = (float **)v161;
              uint64_t v161 = *(float **)v161;
              if (!v161) {
                break;
              }
              if (*((float *)v164 + 7) > v161[7])
              {
                *float v165 = v161;
                *float v164 = *(float **)v161;
                *(void *)uint64_t v161 = v164;
                char v163 = 1;
              }
            }
            uint64_t v161 = v264;
            char v166 = v163 & (v264 != 0);
            float v164 = &v264;
            char v163 = 0;
          }
          while ((v166 & 1) != 0);
        }
      }
      else
      {
        signed int v262 = v143 + 1;
        float v149 = (float)(v143 + 1);
        float v162 = v258;
      }
      if (v147 < v162)
      {
        unint64_t v167 = 0;
        uint64_t v168 = 0;
        float v169 = (float)v143;
        do
        {
          v170 = (float *)*((void *)v147 + 1);
          float v171 = *v170;
          if (*v170 >= v149) {
            break;
          }
          float v172 = v170[1];
          if (v172 > v169)
          {
            if (v145)
            {
              uint64_t v173 = *(void *)v145;
            }
            else
            {
              uint64_t v145 = x_heap_malloc_small_((uint64_t *)v265, 0x28uLL);
              uint64_t v173 = 0;
              v170 = (float *)*((void *)v147 + 1);
              float v171 = *v170;
              float v172 = v170[1];
            }
            *(void *)(v145 + 16) = v170;
            if (v171 >= v169) {
              float v174 = v171;
            }
            else {
              float v174 = (float)v143;
            }
            if (v172 > v149) {
              float v172 = v149;
            }
            float v175 = v170[2];
            float v176 = v170[3];
            float v177 = v170[4];
            float v178 = v177 + (float)((float)(v176 + (float)((float)(v174 - v171) * v175)) * (float)(v174 - v171));
            float v179 = v177 + (float)((float)(v176 + (float)((float)(v172 - v171) * v175)) * (float)(v172 - v171));
            if (v178 >= v179) {
              float v180 = v179;
            }
            else {
              float v180 = v178;
            }
            if (v178 > v179) {
              float v179 = v178;
            }
            v139.f32[0] = fmaxf(v179 - v180, 0.000001);
            float32x2_t v139 = (float32x2_t)vdup_lane_s32((int32x2_t)v139, 0);
            *(float *)(v145 + 28) = v180;
            *(float *)(v145 + 32) = v179;
            *(float *)(v145 + 24) = v170[5] * (float)(v172 - v174);
            *(_DWORD *)(v145 + 36) = vrecpe_f32(v139).u32[0];
            *(void *)uint64_t v145 = v168;
            ++v167;
            uint64_t v168 = v145;
            uint64_t v145 = v173;
          }
          v147 += 16;
        }
        while (v147 < v162);
        if (v167)
        {
          if (v167 != 1)
          {
            uint64_t v181 = v145;
            uint64_t v168 = CA::ScanConverter::RendererImpl::Edge::sort_xmin((uint64_t *)v168, v167);
            uint64_t v145 = v181;
            float v10 = v256;
          }
          float v182 = (uint64_t *)&v264;
          if (v168)
          {
            while (1)
            {
              uint64_t v183 = (uint64_t *)*v182;
              if (!*v182) {
                break;
              }
              if (*(float *)(v168 + 28) >= *((float *)v183 + 7))
              {
                float v182 = (uint64_t *)*v182;
                if (!v168) {
                  goto LABEL_260;
                }
              }
              else
              {
                uint64_t v184 = *(void *)v168;
                *float v182 = v168;
                *(void *)uint64_t v168 = v183;
                uint64_t v168 = v184;
                if (!v184) {
                  goto LABEL_260;
                }
              }
            }
          }
          else
          {
LABEL_260:
            if (*v182) {
              goto LABEL_263;
            }
            uint64_t v168 = 0;
          }
          *float v182 = v168;
        }
      }
LABEL_263:
      float v144 = v264;
      uint64_t v261 = v145;
      if (v264)
      {
        v259 = v147;
        if (v257 < v142)
        {
          uint64_t v185 = 0;
          float v186 = (float)v143 + 0.5;
          float v187 = 0.0;
          int v188 = v257;
          float v189 = v264;
          while (1)
          {
            for (float i = (float)v188; v185; v185 = *(void *)(v185 + 8))
            {
              if (*(float *)(v185 + 32) > i) {
                break;
              }
              float v187 = *(float *)(v185 + 24) + v187;
            }
            float v191 = i + 1.0;
            uint64_t v263 = v185;
            if (v189) {
              break;
            }
LABEL_287:
            float v192 = 0;
            int v198 = v142;
            if (!v185)
            {
              if (!v5) {
                goto LABEL_335;
              }
              goto LABEL_289;
            }
LABEL_294:
            float v203 = 1.0;
            uint64_t v204 = v185;
            float v205 = v187;
            do
            {
              uint64_t v206 = v204;
              float v207 = *(float *)(v204 + 28);
              if (v207 >= i) {
                float v208 = *(float *)(v204 + 28);
              }
              else {
                float v208 = (float)v188;
              }
              float v209 = *(float *)(v204 + 32);
              if (v209 > v191) {
                float v209 = i + 1.0;
              }
              float v205 = v205
                   + (float)((float)(*(float *)(v204 + 24) * v203)
                           * (float)((float)(v191 - v209)
                                   + (float)((float)((float)(v208 - v209) * *(float *)(v204 + 36))
                                           * (float)(v207 + (float)((float)(v209 + v208) * -0.5)))));
              uint64_t v204 = *(void *)(v204 + 8);
              if (v5 == 1)
              {
                if (!v204) {
                  goto LABEL_308;
                }
                signed int v210 = *(float **)(v206 + 16);
                uint64_t v211 = *(float **)(v204 + 16);
                if (v210[5] == v211[5] && *v210 != v211[1] && v210[1] != *v211) {
                  float v203 = -v203;
                }
              }
            }
            while (v204);
            if (!v5)
            {
              BOOL v215 = v205 > 0.0 || v205 < 0.0;
              goto LABEL_314;
            }
LABEL_308:
            float v212 = fabsf(v205);
            int v213 = (int)v212;
            float v214 = v212 - truncf(v212);
            if (v213) {
              float v214 = 1.0 - v214;
            }
            BOOL v215 = v214 > 0.0;
LABEL_314:
            int v198 = v188 + 1;
            if (v215 || *(unsigned char *)(v3 + 64))
            {
              if (*(unsigned char *)(v3 + 65)) {
                BOOL v216 = v215;
              }
              else {
                BOOL v216 = 0;
              }
              uint64_t v217 = v3 + 8 * v216;
              uint64_t v220 = *(void *)(v217 + 32);
              uint64_t v219 = (uint64_t *)(v217 + 32);
              uint64_t v218 = v220;
              if (v220 + 2 > (unint64_t)v219[2])
              {
                CA::OGL::Shape::Lines::flush((void **)v3, v216);
                uint64_t v145 = v261;
                uint64_t v218 = *v219;
              }
              uint64_t v221 = *(void *)(v3 + 8 * v216 + 16) + 16 * v218;
              __int16 v222 = *(_WORD *)(v3 + 12);
              _H1 = *(_WORD *)(v3 + 14);
              __asm { FCVT            S1, H1 }
              _S0 = _S1 * (float)v215;
              __asm { FCVT            H0, S0 }
              *(_DWORD *)(v221 + 24) = *(_DWORD *)(v3 + 8);
              goto LABEL_347;
            }
LABEL_348:
            int v188 = v198;
            float v189 = v192;
            if (v198 >= v142) {
              goto LABEL_349;
            }
          }
          while (1)
          {
LABEL_270:
            float v192 = v189;
            float v193 = v189[7];
            if (v191 <= v193)
            {
              uint64_t v185 = v263;
              if (v263) {
                goto LABEL_294;
              }
              float v227 = floorf(v193);
              if (v227 < -16777000.0) {
                float v227 = -16777000.0;
              }
              float v228 = 16777000.0;
              if (v193 <= 16777000.0) {
                float v228 = v189[7];
              }
              if (v193 >= 0.0) {
                float v227 = v228;
              }
              if (v142 >= (int)v227 && (LODWORD(v193) & 0x7FFFFFFFu) <= 0x7F7FFFFF) {
                int v198 = (int)v227;
              }
              else {
                int v198 = v142;
              }
              if (!v5)
              {
LABEL_335:
                BOOL v202 = v187 > 0.0 || v187 < 0.0;
                if (!v202) {
                  goto LABEL_339;
                }
LABEL_341:
                if (*(unsigned char *)(v3 + 65)) {
                  BOOL v230 = v202;
                }
                else {
                  BOOL v230 = 0;
                }
                uint64_t v231 = v3 + 8 * v230;
                uint64_t v233 = *(void *)(v231 + 32);
                uint64_t v219 = (uint64_t *)(v231 + 32);
                uint64_t v232 = v233;
                if (v233 + 2 > (unint64_t)v219[2])
                {
                  CA::OGL::Shape::Lines::flush((void **)v3, v230);
                  uint64_t v145 = v261;
                  uint64_t v232 = *v219;
                }
                uint64_t v185 = 0;
                uint64_t v221 = *(void *)(v3 + 8 * v230 + 16) + 16 * v232;
                __int16 v222 = *(_WORD *)(v3 + 12);
                _H1 = *(_WORD *)(v3 + 14);
                *(_DWORD *)(v221 + 24) = *(_DWORD *)(v3 + 8);
                __asm { FCVT            S1, H1 }
                _S0 = _S1 * (float)v202;
                __asm { FCVT            H0, S0 }
LABEL_347:
                *(_WORD *)(v221 + 28) = v222;
                *(_WORD *)(v221 + 3CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = _H0;
                *(void *)(v221 + 8) = *(void *)(v221 + 24);
                *(float *)uint64_t v221 = i + 0.5;
                *(float *)(v221 + 16) = (float)v198 + 0.5;
                *(float *)(v221 + 2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v186;
                *(float *)(v221 + 4) = v186;
                *v219 += 2;
                int v142 = v260;
                goto LABEL_348;
              }
LABEL_289:
              float v199 = fabsf(v187);
              int v200 = (int)v199;
              float v201 = v199 - truncf(v199);
              if (v200) {
                float v201 = 1.0 - v201;
              }
              BOOL v202 = v201 > 0.0;
              if (v201 > 0.0) {
                goto LABEL_341;
              }
LABEL_339:
              if (*(unsigned char *)(v3 + 64)) {
                goto LABEL_341;
              }
              uint64_t v185 = 0;
              goto LABEL_348;
            }
            float v189 = *(float **)v189;
            float v194 = v192[8];
            if (v194 <= i)
            {
              float v187 = v192[6] + v187;
              if (v189) {
                continue;
              }
LABEL_286:
              uint64_t v185 = v263;
              goto LABEL_287;
            }
            uint64_t v195 = v263;
            if (v263) {
              break;
            }
            float v196 = &v263;
LABEL_283:
            *float v196 = (uint64_t)v192;
            *((void *)v192 + 1) = 0;
            if (!v189) {
              goto LABEL_286;
            }
          }
          float v196 = &v263;
          while (1)
          {
            float v197 = *(float *)(v195 + 32);
            if (SLODWORD(v194) == SLODWORD(v197))
            {
              if (v193 < *(float *)(v195 + 28)) {
                goto LABEL_285;
              }
            }
            else if (v194 < v197)
            {
LABEL_285:
              *((void *)v192 + 1) = v195;
              *float v196 = (uint64_t)v192;
              if (!v189) {
                goto LABEL_286;
              }
              goto LABEL_270;
            }
            float v196 = (uint64_t *)(v195 + 8);
            uint64_t v195 = *(void *)(v195 + 8);
            if (!v195) {
              goto LABEL_283;
            }
          }
        }
LABEL_349:
        float v10 = v256;
        float v147 = v259;
      }
      else
      {
        if (v147 == v162)
        {
          if (v143 < SLODWORD(v10))
          {
            do
            {
              if (*(unsigned char *)(v3 + 64))
              {
                uint64_t v248 = *(void *)(v3 + 32);
                if ((unint64_t)(v248 + 2) > *(void *)(v3 + 48))
                {
                  CA::OGL::Shape::Lines::flush((void **)v3, 0);
                  uint64_t v248 = *(void *)(v3 + 32);
                }
                uint64_t v249 = *(void *)(v3 + 16) + 16 * v248;
                __int16 v250 = *(_WORD *)(v3 + 12);
                short float v251 = *(short float *)(v3 + 14) * COERCE_SHORT_FLOAT(0);
                *(_DWORD *)(v249 + 24) = *(_DWORD *)(v3 + 8);
                *(_WORD *)(v249 + 28) = v250;
                *(short float *)(v249 + 3CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v251;
                *(void *)(v249 + 8) = *(void *)(v249 + 24);
                float v252 = (float)v143 + 0.5;
                *(float *)(v249 + 16) = v146;
                *(float *)(v249 + 2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v252;
                *(float *)uint64_t v249 = v255;
                *(float *)(v249 + 4) = v252;
                *(void *)(v3 + 32) += 2;
              }
              ++v143;
            }
            while (LODWORD(v10) != v143);
          }
          goto LABEL_375;
        }
        signed int v262 = vcvtms_s32_f32(**((float **)v147 + 1));
        if (v143 >= v262)
        {
          signed int v262 = v143;
        }
        else
        {
          float v237 = v255;
          do
          {
            if (*(unsigned char *)(v3 + 64))
            {
              uint64_t v238 = *(void *)(v3 + 32);
              if ((unint64_t)(v238 + 2) > *(void *)(v3 + 48))
              {
                CA::OGL::Shape::Lines::flush((void **)v3, 0);
                uint64_t v145 = v261;
                uint64_t v238 = *(void *)(v3 + 32);
              }
              uint64_t v239 = *(void *)(v3 + 16) + 16 * v238;
              __int16 v240 = *(_WORD *)(v3 + 12);
              short float v241 = *(short float *)(v3 + 14) * COERCE_SHORT_FLOAT(0);
              *(_DWORD *)(v239 + 24) = *(_DWORD *)(v3 + 8);
              *(_WORD *)(v239 + 28) = v240;
              *(short float *)(v239 + 3CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v241;
              *(void *)(v239 + 8) = *(void *)(v239 + 24);
              float v242 = (float)v143 + 0.5;
              *(float *)(v239 + 16) = v146;
              *(float *)(v239 + 2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v242;
              *(float *)uint64_t v239 = v237;
              *(float *)(v239 + 4) = v242;
              *(void *)(v3 + 32) += 2;
            }
            ++v143;
          }
          while (v262 != v143);
        }
      }
      int v143 = v262;
      if (v262 >= SLODWORD(v10)) {
        goto LABEL_375;
      }
    }
  }
  if ((unint64_t)(32 * v11) <= 0x1000)
  {
    MEMORY[0x1F4188790](v1);
    v254 = (char *)&v253 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v254, 32 * v11);
LABEL_7:
    unint64_t v253 = 32 * v11;
    int v13 = *(void **)(v4 + 8);
    if (v13)
    {
      uint64_t v14 = 0;
      int v15 = v254 + 8;
      do
      {
        uint64_t v16 = v13[1];
        if (v16)
        {
          int v17 = (int *)(v13 + 3);
          int v18 = &v15[16 * v14];
          v14 += v16;
          int v19 = (int *)(v13 + 3);
          do
          {
            int v20 = *v19;
            v19 += 6;
            *((_DWORD *)v18 - 2) = ((v20 >> 31) | 0x80000000) ^ v20;
            *(void *)int v18 = v17;
            v18 += 16;
            int v17 = v19;
            --v16;
          }
          while (v16);
        }
        int v13 = (void *)*v13;
      }
      while (v13);
    }
    v259 = &v254[16 * v11];
    CA::radix_sort(v11);
    if (v8 <= -16777216) {
      int v23 = -16777216;
    }
    else {
      int v23 = v8;
    }
    LODWORD(v258) = v23;
    if (v9 >= 0x1000000) {
      int v24 = 0x1000000;
    }
    else {
      int v24 = v9;
    }
    if (v7 <= -16777216) {
      uint64_t v25 = 4278190080;
    }
    else {
      uint64_t v25 = v7;
    }
    uint64_t v266 = 0;
    v267 = v269;
    if (SLODWORD(v10) >= 0x1000000) {
      int v26 = 0x1000000;
    }
    else {
      int v26 = LODWORD(v10);
    }
    long long v268 = xmmword_184998000;
    v264 = 0;
    v265 = (void ***)&v266;
    if ((int)v25 >= v26) {
      goto LABEL_375;
    }
    __int32 v27 = 0;
    uint64_t v28 = 0;
    float v255 = (float)v24 + 0.5;
    float v256 = (float)(int)v258 + 0.5;
    int v29 = v254;
    signed int v262 = v24;
    int v257 = v26;
    while (1)
    {
      if (v27)
      {
        float v30 = (float)(int)v25;
        float v31 = (float)(v25 + 1);
        uint64_t v32 = (float *)&v264;
        do
        {
          uint64_t v33 = (float *)*((void *)v27 + 2);
          float v34 = v33[1];
          if (v34 <= v30)
          {
            *(void *)uint64_t v32 = *(void *)v27;
            *(void *)__int32 v27 = v28;
            uint64_t v28 = (uint64_t)v27;
            __int32 v27 = v32;
          }
          else
          {
            float v35 = *v33;
            if (*v33 >= v30) {
              float v36 = *v33;
            }
            else {
              float v36 = (float)(int)v25;
            }
            if (v34 > v31) {
              float v34 = (float)(v25 + 1);
            }
            float v37 = v33[2];
            float v38 = v33[3];
            float v39 = v33[4];
            float v40 = v39 + (float)((float)(v38 + (float)((float)(v36 - v35) * v37)) * (float)(v36 - v35));
            float v41 = v39 + (float)((float)(v38 + (float)((float)(v34 - v35) * v37)) * (float)(v34 - v35));
            if (v40 >= v41) {
              float v42 = v41;
            }
            else {
              float v42 = v40;
            }
            if (v40 > v41) {
              float v41 = v40;
            }
            *(float *)v22.i32 = fmaxf(v41 - v42, 0.000001);
            int32x2_t v22 = (int32x2_t)vrecpe_f32((float32x2_t)vdup_lane_s32(v22, 0));
            v27[7] = v42;
            v27[8] = v41;
            v27[6] = v33[5] * (float)(v34 - v36);
            v27[9] = *(float *)v22.i32;
            uint64_t v32 = v27;
          }
          __int32 v27 = *(float **)v27;
        }
        while (v27);
        unsigned int v260 = v25 + 1;
        float v43 = v264;
        unint64_t v44 = (unint64_t)v259;
        if (v264)
        {
          char v45 = 0;
          int8x16_t v46 = &v264;
          do
          {
            while (1)
            {
              double v47 = v46;
              int8x16_t v46 = (float **)v43;
              float v43 = *(float **)v43;
              if (!v43) {
                break;
              }
              if (*((float *)v46 + 7) > v43[7])
              {
                *double v47 = v43;
                *int8x16_t v46 = *(float **)v43;
                *(void *)float v43 = v46;
                char v45 = 1;
              }
            }
            float v43 = v264;
            char v48 = v45 & (v264 != 0);
            int8x16_t v46 = &v264;
            char v45 = 0;
          }
          while ((v48 & 1) != 0);
        }
      }
      else
      {
        unsigned int v260 = v25 + 1;
        float v31 = (float)(v25 + 1);
        unint64_t v44 = (unint64_t)v259;
      }
      if ((unint64_t)v29 < v44)
      {
        unint64_t v49 = 0;
        uint64_t v50 = 0;
        float v51 = (float)(int)v25;
        do
        {
          uint32x2_t v52 = (float *)*((void *)v29 + 1);
          float v53 = *v52;
          if (*v52 >= v31) {
            break;
          }
          float v54 = v52[1];
          if (v54 > v51)
          {
            if (v28)
            {
              uint64_t v55 = *(void *)v28;
            }
            else
            {
              uint64_t v28 = x_heap_malloc_small_((uint64_t *)v265, 0x28uLL);
              int v24 = v262;
              uint64_t v55 = 0;
              uint32x2_t v52 = (float *)*((void *)v29 + 1);
              float v53 = *v52;
              float v54 = v52[1];
            }
            *(void *)(v28 + 16) = v52;
            if (v53 >= v51) {
              float v56 = v53;
            }
            else {
              float v56 = (float)(int)v25;
            }
            if (v54 > v31) {
              float v54 = v31;
            }
            float v57 = v52[2];
            float v58 = v52[3];
            float v59 = v52[4];
            float v60 = v59 + (float)((float)(v58 + (float)((float)(v56 - v53) * v57)) * (float)(v56 - v53));
            float v61 = v59 + (float)((float)(v58 + (float)((float)(v54 - v53) * v57)) * (float)(v54 - v53));
            if (v60 >= v61) {
              float v62 = v61;
            }
            else {
              float v62 = v60;
            }
            if (v60 > v61) {
              float v61 = v60;
            }
            v21.f32[0] = fmaxf(v61 - v62, 0.000001);
            float32x2_t v21 = (float32x2_t)vdup_lane_s32((int32x2_t)v21, 0);
            *(float *)(v28 + 28) = v62;
            *(float *)(v28 + 32) = v61;
            *(float *)(v28 + 24) = v52[5] * (float)(v54 - v56);
            *(_DWORD *)(v28 + 36) = vrecpe_f32(v21).u32[0];
            *(void *)uint64_t v28 = v50;
            ++v49;
            uint64_t v50 = v28;
            uint64_t v28 = v55;
          }
          v29 += 16;
        }
        while ((unint64_t)v29 < v44);
        if (v49)
        {
          if (v49 != 1)
          {
            uint64_t v63 = v28;
            uint64_t v64 = CA::ScanConverter::RendererImpl::Edge::sort_xmin((uint64_t *)v50, v49);
            int v24 = v262;
            uint64_t v50 = v64;
            uint64_t v28 = v63;
          }
          float32x4_t v65 = (float *)&v264;
          if (v50)
          {
            while (1)
            {
              long long v66 = *(float **)v65;
              if (!*(void *)v65) {
                break;
              }
              if (*(float *)(v50 + 28) >= v66[7])
              {
                float32x4_t v65 = *(float **)v65;
                if (!v50) {
                  goto LABEL_79;
                }
              }
              else
              {
                uint64_t v67 = *(void *)v50;
                *(void *)float32x4_t v65 = v50;
                *(void *)uint64_t v50 = v66;
                uint64_t v50 = v67;
                if (!v67) {
                  goto LABEL_79;
                }
              }
            }
          }
          else
          {
LABEL_79:
            if (*(void *)v65) {
              goto LABEL_82;
            }
            uint64_t v50 = 0;
          }
          *(void *)float32x4_t v65 = v50;
        }
      }
LABEL_82:
      __int32 v27 = v264;
      uint64_t v261 = v28;
      if (v264)
      {
        if ((int)v258 >= v24) {
          goto LABEL_175;
        }
        uint64_t v68 = 0;
        float v69 = (float)(int)v25 + 0.5;
        float v70 = 0.0;
        int v71 = (int)v258;
        float v72 = v264;
LABEL_85:
        for (j = (float)v71; v68; uint64_t v68 = *(void *)(v68 + 8))
        {
          if (*(float *)(v68 + 32) > j) {
            break;
          }
          float v70 = *(float *)(v68 + 24) + v70;
        }
        float v74 = j + 1.0;
        uint64_t v263 = v68;
        if (!v72) {
          goto LABEL_106;
        }
LABEL_89:
        while (1)
        {
          double v75 = v72;
          float v76 = v72[7];
          if (v74 <= v76) {
            break;
          }
          float v72 = *(float **)v72;
          float v77 = v75[8];
          if (v77 <= j)
          {
            float v70 = v75[6] + v70;
            if (v72) {
              continue;
            }
LABEL_105:
            uint64_t v68 = v263;
LABEL_106:
            double v75 = 0;
            int v81 = v24;
            if (!v68)
            {
LABEL_154:
              float v112 = fabsf(v70);
              if (v5)
              {
                int v113 = (int)v112;
                float v112 = v112 - truncf(v112);
                if (v113) {
                  float v112 = 1.0 - v112;
                }
                goto LABEL_159;
              }
              float v114 = 1.0;
              if (v112 < 1.0)
              {
LABEL_159:
                BOOL v115 = v112 == 0.0 && *(unsigned char *)(v3 + 64) == 0;
                float v114 = v112;
                if (v115)
                {
                  uint64_t v68 = 0;
                  goto LABEL_174;
                }
              }
              BOOL v117 = v114 == 1.0 && *(unsigned char *)(v3 + 65) != 0;
              uint64_t v118 = v3 + 8 * v117;
              uint64_t v120 = *(void *)(v118 + 32);
              float v98 = (uint64_t *)(v118 + 32);
              uint64_t v119 = v120;
              if (v120 + 2 > (unint64_t)v98[2])
              {
                CA::OGL::Shape::Lines::flush((void **)v3, v117);
                uint64_t v28 = v261;
                int v24 = v262;
                uint64_t v119 = *v98;
              }
              uint64_t v68 = 0;
              uint64_t v100 = *(void *)(v3 + 8 * v117 + 16) + 16 * v119;
              __int16 v101 = *(_WORD *)(v3 + 12);
              _H0 = *(_WORD *)(v3 + 14);
              *(_DWORD *)(v100 + 24) = *(_DWORD *)(v3 + 8);
              __asm { FCVT            S0, H0 }
              _S0 = v114 * _S0;
              __asm { FCVT            H0, S0 }
              goto LABEL_172;
            }
LABEL_109:
            float v82 = 1.0;
            uint64_t v83 = v68;
            float v84 = v70;
            while (1)
            {
              uint64_t v85 = v83;
              float v86 = *(float *)(v83 + 28);
              if (v86 >= j) {
                float v87 = *(float *)(v83 + 28);
              }
              else {
                float v87 = (float)v71;
              }
              float v88 = *(float *)(v83 + 32);
              if (v88 > v74) {
                float v88 = j + 1.0;
              }
              float v84 = v84
                  + (float)((float)(*(float *)(v83 + 24) * v82)
                          * (float)((float)(v74 - v88)
                                  + (float)((float)((float)(v87 - v88) * *(float *)(v83 + 36))
                                          * (float)(v86 + (float)((float)(v88 + v87) * -0.5)))));
              uint64_t v83 = *(void *)(v83 + 8);
              if (v5 == 1)
              {
                if (!v83)
                {
                  float v91 = fabsf(v84);
                  goto LABEL_126;
                }
                uint64_t v89 = *(float **)(v85 + 16);
                unsigned int v90 = *(float **)(v83 + 16);
                if (v89[5] == v90[5] && *v89 != v90[1] && v89[1] != *v90) {
                  float v82 = -v82;
                }
              }
              if (!v83)
              {
                float v91 = fabsf(v84);
                if (!v5)
                {
                  if (v91 >= 1.0)
                  {
                    int v81 = v71 + 1;
                    float v91 = 1.0;
                    goto LABEL_133;
                  }
LABEL_129:
                  int v81 = v71 + 1;
                  if (v91 == 0.0 && *(unsigned char *)(v3 + 64) == 0) {
                    goto LABEL_174;
                  }
LABEL_133:
                  BOOL v95 = v91 == 1.0 && *(unsigned char *)(v3 + 65) != 0;
                  uint64_t v96 = v3 + 8 * v95;
                  uint64_t v99 = *(void *)(v96 + 32);
                  float v98 = (uint64_t *)(v96 + 32);
                  uint64_t v97 = v99;
                  if (v99 + 2 > (unint64_t)v98[2])
                  {
                    CA::OGL::Shape::Lines::flush((void **)v3, v95);
                    uint64_t v28 = v261;
                    int v24 = v262;
                    uint64_t v97 = *v98;
                  }
                  uint64_t v100 = *(void *)(v3 + 8 * v95 + 16) + 16 * v97;
                  __int16 v101 = *(_WORD *)(v3 + 12);
                  _H0 = *(_WORD *)(v3 + 14);
                  __asm { FCVT            S0, H0 }
                  _S0 = v91 * _S0;
                  __asm { FCVT            H0, S0 }
                  *(_DWORD *)(v100 + 24) = *(_DWORD *)(v3 + 8);
LABEL_172:
                  *(_WORD *)(v100 + 28) = v101;
                  *(_WORD *)(v100 + 3CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = _H0;
                  *(void *)(v100 + 8) = *(void *)(v100 + 24);
                  *(float *)uint64_t v100 = j + 0.5;
                  *(float *)(v100 + 16) = (float)v81 + 0.5;
                  *(float *)(v100 + 2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v69;
                  *(float *)(v100 + 4) = v69;
                  *v98 += 2;
LABEL_174:
                  int v71 = v81;
                  float v72 = v75;
                  if (v81 >= v24)
                  {
LABEL_175:
                    int v26 = v257;
                    unint64_t v44 = v260;
                    goto LABEL_186;
                  }
                  goto LABEL_85;
                }
LABEL_126:
                float v92 = v91 - truncf(v91);
                if ((int)v91) {
                  float v91 = 1.0 - v92;
                }
                else {
                  float v91 = v92;
                }
                goto LABEL_129;
              }
            }
          }
          uint64_t v78 = v263;
          if (v263)
          {
            long long v79 = &v263;
            while (1)
            {
              float v80 = *(float *)(v78 + 32);
              if (SLODWORD(v77) == SLODWORD(v80))
              {
                if (v76 < *(float *)(v78 + 28)) {
                  goto LABEL_104;
                }
              }
              else if (v77 < v80)
              {
LABEL_104:
                *((void *)v75 + 1) = v78;
                *long long v79 = (uint64_t)v75;
                if (!v72) {
                  goto LABEL_105;
                }
                goto LABEL_89;
              }
              long long v79 = (uint64_t *)(v78 + 8);
              uint64_t v78 = *(void *)(v78 + 8);
              if (!v78) {
                goto LABEL_102;
              }
            }
          }
          long long v79 = &v263;
LABEL_102:
          *long long v79 = (uint64_t)v75;
          *((void *)v75 + 1) = 0;
          if (!v72) {
            goto LABEL_105;
          }
        }
        uint64_t v68 = v263;
        if (!v263)
        {
          float v109 = floorf(v76);
          if (v109 < -16777000.0) {
            float v109 = -16777000.0;
          }
          float v110 = 16777000.0;
          if (v76 <= 16777000.0) {
            float v110 = v72[7];
          }
          if (v76 >= 0.0) {
            float v109 = v110;
          }
          if (v24 >= (int)v109 && (LODWORD(v76) & 0x7FFFFFFFu) <= 0x7F7FFFFF) {
            int v81 = (int)v109;
          }
          else {
            int v81 = v24;
          }
          goto LABEL_154;
        }
        goto LABEL_109;
      }
      if (v29 == (char *)v44)
      {
        if ((int)v25 < v26)
        {
          do
          {
            if (*(unsigned char *)(v3 + 64))
            {
              uint64_t v243 = *(void *)(v3 + 32);
              if ((unint64_t)(v243 + 2) > *(void *)(v3 + 48))
              {
                CA::OGL::Shape::Lines::flush((void **)v3, 0);
                uint64_t v243 = *(void *)(v3 + 32);
              }
              uint64_t v244 = *(void *)(v3 + 16) + 16 * v243;
              __int16 v245 = *(_WORD *)(v3 + 12);
              short float v246 = *(short float *)(v3 + 14) * COERCE_SHORT_FLOAT(0);
              *(_DWORD *)(v244 + 24) = *(_DWORD *)(v3 + 8);
              *(_WORD *)(v244 + 28) = v245;
              *(short float *)(v244 + 3CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v246;
              *(void *)(v244 + 8) = *(void *)(v244 + 24);
              float v247 = (float)(int)v25 + 0.5;
              *(float *)(v244 + 16) = v255;
              *(float *)(v244 + 2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v247;
              *(float *)uint64_t v244 = v256;
              *(float *)(v244 + 4) = v247;
              *(void *)(v3 + 32) += 2;
            }
            LODWORD(v25) = v25 + 1;
          }
          while (v26 != v25);
        }
        goto LABEL_375;
      }
      LODWORD(v44) = vcvtms_s32_f32(**((float **)v29 + 1));
      if ((int)v25 >= (int)v44)
      {
        unint64_t v44 = v25;
      }
      else
      {
        float v125 = v255;
        float v124 = v256;
        do
        {
          if (*(unsigned char *)(v3 + 64))
          {
            uint64_t v126 = *(void *)(v3 + 32);
            if ((unint64_t)(v126 + 2) > *(void *)(v3 + 48))
            {
              CA::OGL::Shape::Lines::flush((void **)v3, 0);
              uint64_t v28 = v261;
              int v24 = v262;
              uint64_t v126 = *(void *)(v3 + 32);
            }
            uint64_t v127 = *(void *)(v3 + 16) + 16 * v126;
            __int16 v128 = *(_WORD *)(v3 + 12);
            short float v129 = *(short float *)(v3 + 14) * COERCE_SHORT_FLOAT(0);
            *(_DWORD *)(v127 + 24) = *(_DWORD *)(v3 + 8);
            *(_WORD *)(v127 + 28) = v128;
            *(short float *)(v127 + 3CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v129;
            *(void *)(v127 + 8) = *(void *)(v127 + 24);
            float v130 = (float)(int)v25 + 0.5;
            *(float *)(v127 + 16) = v125;
            *(float *)(v127 + 2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v130;
            *(float *)uint64_t v127 = v124;
            *(float *)(v127 + 4) = v130;
            *(void *)(v3 + 32) += 2;
          }
          LODWORD(v25) = v25 + 1;
        }
        while (v44 != v25);
      }
LABEL_186:
      uint64_t v25 = v44;
      if ((int)v44 >= v26) {
        goto LABEL_375;
      }
    }
  }
  v254 = (char *)malloc_type_malloc(32 * v11, 0x145CA901uLL);
  if (v254) {
    goto LABEL_7;
  }
}

uint64_t CA::ScanConverter::RendererImpl::Edge::sort_xmin(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = (uint64_t)a1;
  unint64_t v4 = a2 >> 1;
  int v5 = a1;
  uint64_t v6 = (a2 >> 1) - 1;
  if (a2 >> 1 != 1)
  {
    int v5 = a1;
    do
    {
      int v5 = (uint64_t *)*v5;
      --v6;
    }
    while (v6);
  }
  uint64_t v7 = *v5;
  *int v5 = 0;
  if (a2 > 3) {
    uint64_t v3 = CA::ScanConverter::RendererImpl::Edge::sort_xmin(a1, a2 >> 1);
  }
  if (a2 - v4 >= 2) {
    uint64_t v7 = CA::ScanConverter::RendererImpl::Edge::sort_xmin(v7, a2 - v4);
  }
  if (*(float *)(v7 + 28) >= *(float *)(v3 + 28))
  {
    uint64_t v9 = *(void *)v3;
    uint64_t v8 = v7;
    uint64_t v7 = v3;
  }
  else
  {
    uint64_t v8 = *(void *)v7;
    uint64_t v9 = v3;
  }
  BOOL v10 = v9 != 0;
  if (v9 && v8)
  {
    uint64_t v11 = (void *)v7;
    do
    {
      if (*(float *)(v8 + 28) >= *(float *)(v9 + 28))
      {
        *uint64_t v11 = v9;
        uint64_t v13 = *(void *)v9;
        uint64_t v12 = v8;
        uint64_t v11 = (void *)v9;
        uint64_t v9 = *(void *)v9;
      }
      else
      {
        *uint64_t v11 = v8;
        uint64_t v12 = *(void *)v8;
        uint64_t v13 = v9;
        uint64_t v11 = (void *)v8;
        uint64_t v8 = *(void *)v8;
      }
      BOOL v10 = v13 != 0;
      if (v13) {
        BOOL v14 = v12 == 0;
      }
      else {
        BOOL v14 = 1;
      }
    }
    while (!v14);
  }
  else
  {
    uint64_t v13 = v9;
    uint64_t v12 = v8;
    uint64_t v11 = (void *)v7;
  }
  if (v10) {
    uint64_t v15 = v13;
  }
  else {
    uint64_t v15 = v12;
  }
  *uint64_t v11 = v15;
  return v7;
}

void CA::radix_sort(uint64_t a1)
{
  unint64_t v1 = MEMORY[0x1F4188790](a1);
  unint64_t v4 = v2;
  unint64_t v5 = v1;
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (v1 > 0x3F)
  {
    BOOL v14 = v3;
    unint64_t v15 = 16 * v1;
    uint64_t v16 = v3;
    if (!v3)
    {
      if (v15 > 0x1000)
      {
        uint64_t v16 = malloc_type_malloc(16 * v1, 0x10800407411B482uLL);
        if (!v16) {
          return;
        }
      }
      else
      {
        MEMORY[0x1F4188790](v1);
        uint64_t v16 = &v55[-((v15 + 15) & 0xFFFFFFFFFFFFFFF0)];
        bzero(v16, 16 * v5);
      }
    }
    bzero(v55, 0x1000uLL);
    int v17 = (unsigned int *)v4;
    unint64_t v18 = v5;
    do
    {
      unsigned int v19 = *v17;
      v17 += 4;
      ++*(_DWORD *)&v55[16 * v19];
      ++*(_DWORD *)&v55[16 * BYTE1(v19) + 4];
      ++*(_DWORD *)&v55[16 * BYTE2(v19) + 8];
      ++*(_DWORD *)&v55[(((unint64_t)v19 >> 20) & 0xFF0) + 12];
      --v18;
    }
    while (v18);
    unint64_t v20 = 0;
    int32x4_t v21 = 0uLL;
    do
    {
      int32x2_t v22 = (int32x4_t *)&v55[16 * v20];
      int32x4_t v23 = vaddq_s32(*v22, v21);
      int32x4_t v24 = vaddq_s32(v23, v22[1]);
      int32x4_t v25 = vaddq_s32(v24, v22[2]);
      int32x4_t v26 = vaddq_s32(v25, v22[3]);
      *int32x2_t v22 = v21;
      v22[1] = v23;
      float64x2_t v22[2] = v24;
      float64x2_t v22[3] = v25;
      int32x4_t v21 = v26;
      BOOL v27 = v20 >= 0xFC;
      v20 += 4;
    }
    while (!v27);
    uint64_t v28 = (void *)v4 + 1;
    unint64_t v29 = v5;
    do
    {
      int v30 = *((_DWORD *)v28 - 2);
      uint64_t v31 = 16 * v30;
      uint64_t v32 = *(unsigned int *)&v55[v31];
      *(_DWORD *)&v55[v31] = v32 + 1;
      uint64_t v33 = *v28;
      v28 += 2;
      float v34 = &v16[16 * v32];
      *(_DWORD *)float v34 = v30;
      *((void *)v34 + 1) = v33;
      --v29;
    }
    while (v29);
    float v35 = v16 + 8;
    unint64_t v36 = v5;
    do
    {
      int v37 = *((_DWORD *)v35 - 2);
      uint64_t v38 = *v35;
      v35 += 2;
      float v39 = &v55[16 * BYTE1(v37)];
      uint64_t v40 = *((unsigned int *)v39 + 1);
      *((_DWORD *)v39 + 1) = v40 + 1;
      float v41 = &v4[v40];
      *(_DWORD *)float v41 = v37;
      *((void *)v41 + 1) = v38;
      --v36;
    }
    while (v36);
    float v42 = (void *)v4 + 1;
    unint64_t v43 = v5;
    do
    {
      int v44 = *((_DWORD *)v42 - 2);
      uint64_t v45 = *v42;
      v42 += 2;
      int8x16_t v46 = &v55[16 * BYTE2(v44)];
      uint64_t v47 = *((unsigned int *)v46 + 2);
      *((_DWORD *)v46 + 2) = v47 + 1;
      char v48 = &v16[16 * v47];
      *(_DWORD *)char v48 = v44;
      *((void *)v48 + 1) = v45;
      --v43;
    }
    while (v43);
    unint64_t v49 = (uint64_t *)(v16 + 8);
    do
    {
      unint64_t v50 = *((unsigned int *)v49 - 2);
      uint64_t v51 = *v49;
      v49 += 2;
      uint32x2_t v52 = &v55[(v50 >> 20) & 0xFF0];
      uint64_t v53 = *((unsigned int *)v52 + 3);
      *((_DWORD *)v52 + 3) = v53 + 1;
      float v54 = &v4[v53];
      *(_DWORD *)float v54 = v50;
      *((void *)v54 + 1) = v51;
      --v5;
    }
    while (v5);
    if (v15 > 0x1000 && !v14) {
      free(v16);
    }
  }
  else if (v1 >= 2)
  {
    uint64_t v6 = 1;
    uint64_t v7 = v2;
    do
    {
      uint64_t v8 = (unsigned int *)&v2[v6];
      unsigned int v9 = *v8;
      uint64_t v10 = *((void *)v8 + 1);
      uint64_t v11 = v7;
      uint64_t v12 = v6;
      while (*(_DWORD *)v11 > v9)
      {
        --v12;
        v11[1] = *v11;
        --v11;
        if (v12 + 1 <= 1)
        {
          uint64_t v12 = 0;
          break;
        }
      }
      uint64_t v13 = &v2[v12];
      *(_DWORD *)uint64_t v13 = v9;
      *((void *)v13 + 1) = v10;
      ++v6;
      ++v7;
    }
    while (v6 != v1);
  }
}

void CA::WindowServer::Server::render_for_time(uint64_t a1)
{
  double v1 = MEMORY[0x1F4188790](a1);
  char v3 = v2;
  v591.i64[0] = v4;
  uint64_t v6 = v5;
  v592 = v7;
  double v8 = v1;
  uint64_t v10 = v9;
  v704[32] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = (void *)MEMORY[0x185324A30]();
  int v605 = 0;
  CARecordCurrentDisplay::CARecordCurrentDisplay((CARecordCurrentDisplay *)&v605, *(_DWORD *)(*(void *)(v10 + 96) + 24));
  uint64_t v597 = mach_absolute_time();
  uint64_t v12 = *(void *)(v10 + 96);
  if (*(void *)(v12 + 48)) {
    int v13 = (*(unsigned __int8 *)(v12 + 56) >> 5) & 1;
  }
  else {
    LOBYTE(v13) = 0;
  }
  if (*(unsigned char *)(v10 + 512) || (v13 & 1) != 0) {
    goto LABEL_759;
  }
  uint64_t v14 = mach_absolute_time();
  v692[0] = 0uLL;
  mach_get_times();
  float64_t v15 = v692[0].f64[1];
  *(double *)&unint64_t v16 = CATimeWithHostTime(*(unint64_t *)&v692[0].f64[0]);
  unsigned int add = atomic_fetch_add(&CA::Render::Update::_update_counter, 1u);
  pthread_mutex_lock((pthread_mutex_t *)(v10 + 24));
  if (*(unsigned char *)(v10 + 513))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 24));
    goto LABEL_758;
  }
  uint64_t v588 = add + 1;
  v558 = (pthread_mutex_t *)(v10 + 24);
  uint64_t v559 = v14;
  float64_t v569 = v15;
  v560 = v11;
  if (BYTE13(xmmword_1EB2ACC50))
  {
    if (CA::WindowServer::server_perf_log(void)::once_token[0] != -1) {
      dispatch_once(CA::WindowServer::server_perf_log(void)::once_token, &__block_literal_global_216);
    }
    os_log_t v550 = (os_log_t)CA::WindowServer::server_perf_log(void)::log;
    os_signpost_id_t v561 = os_signpost_id_generate((os_log_t)CA::WindowServer::server_perf_log(void)::log);
    if (v561 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v550))
    {
      int v525 = *(_DWORD *)(*(void *)(v10 + 96) + 24);
      v526 = _MXSignpostMetricsSnapshot();
      LODWORD(v692[0].f64[0]) = 67240706;
      HIDWORD(v692[0].f64[0]) = v525;
      LOWORD(v692[0].f64[1]) = 1026;
      *(_DWORD *)((char *)&v692[0].f64[1] + 2) = v588;
      HIWORD(v692[0].f64[1]) = 2114;
      *(void *)&v692[1].f64[0] = v526;
      _os_signpost_emit_with_name_impl(&dword_184668000, v550, OS_SIGNPOST_INTERVAL_BEGIN, v561, "Rendering", "display=%{public,name=display}u update=0x%{public,name=update}x\n%{public, signpost:metrics}@", (uint8_t *)v692, 0x18u);
    }
  }
  else
  {
    os_signpost_id_t v561 = 0;
    os_log_t v550 = 0;
  }
  kdebug_trace();
  double v18 = (*(double (**)(void))(**(void **)(v10 + 96) + 744))();
  int v552 = *(_DWORD *)(*(void *)(v10 + 96) + 24);
  unint64_t v562 = CAHostTimeWithTime(v18);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 152));
  unsigned int v19 = *(void **)(v10 + 160);
  *(void *)(v10 + 16CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 152));
  if (v19)
  {
    unint64_t v20 = 0;
    do
    {
      int32x4_t v21 = v20;
      unint64_t v20 = v19;
      unsigned int v19 = (void *)v19[1];
      v20[1] = v21;
    }
    while (v19);
    do
    {
      int32x2_t v22 = (void *)v20[1];
      (*(void (**)(void *, uint64_t))(*v20 + 16))(v20, v10);
      (*(void (**)(void *))(*v20 + 8))(v20);
      unint64_t v20 = v22;
    }
    while (v22);
  }
  v568 = v6;
  v589 = (os_unfair_lock_s *)(v10 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 16));
  uint64_t v24 = *(void *)(v10 + 128);
  uint64_t v25 = *(void *)(v10 + 96);
  BOOL v26 = *(unsigned char *)(*(void *)(v25 + 728) + 1) != 1 || *(void *)(v25 + 640) == 0;
  if (!*(void *)(v25 + 48))
  {
    int v27 = 0;
    if (!v26) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  int v27 = *(unsigned char *)(v25 + 56) & 1;
  if (v26) {
LABEL_19:
  }
    atomic_store(v16, &CA::Render::Context::_begin_time_threshold);
LABEL_20:
  if (v24)
  {
    unint64_t v554 = 8 * v24;
    if ((unint64_t)(8 * v24) > 0x1000)
    {
      unint64_t v29 = (char *)malloc_type_malloc(8 * v24, 0x2109396CuLL);
    }
    else
    {
      MEMORY[0x1F4188790](v23);
      unint64_t v29 = (char *)&v548 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v29, v28);
    }
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    uint64_t v30 = 0;
    uint64_t v34 = *(void *)(v10 + 112);
    double v31 = 0.0;
    do
    {
      uint64_t v35 = *(void *)(v34 + v32);
      atomic_fetch_add((atomic_uint *volatile)(v35 + 8), 1u);
      *(void *)&v29[8 * v33] = v35;
      double v36 = *(double *)(v35 + 624);
      if (v31 >= v36) {
        double v37 = *(double *)(v35 + 624);
      }
      else {
        double v37 = v31;
      }
      if (v31 == 0.0) {
        double v37 = *(double *)(v35 + 624);
      }
      if (v36 != 0.0) {
        double v31 = v37;
      }
      uint64_t v34 = *(void *)(v10 + 112);
      v30 += ((unint64_t)*(unsigned int *)(*(void *)(v34 + v32) + 12) >> 17) & 1;
      ++v33;
      v32 += 16;
    }
    while (v24 != v33);
  }
  else
  {
    unint64_t v554 = 0;
    uint64_t v30 = 0;
    unint64_t v29 = 0;
    double v31 = 0.0;
  }
  v564 = *(CA::Shape ***)(v10 + 176);
  *(void *)(v10 + 176) = 0;
  os_unfair_lock_unlock(v589);
  if (CADeviceNeedsISPWorkaround::once[0] != -1) {
    dispatch_once(CADeviceNeedsISPWorkaround::once, &__block_literal_global_104);
  }
  if (CADeviceNeedsISPWorkaround::isp_workaround)
  {
    int v38 = *(unsigned __int8 *)(v10 + 522);
    uint64_t v39 = *(void *)(v10 + 96);
    if (*(unsigned char *)(v10 + 522)) {
      int v38 = (*(_WORD *)(v39 + 656) & 0x1C00) == 1024;
    }
  }
  else
  {
    int v38 = 0;
    uint64_t v39 = *(void *)(v10 + 96);
  }
  unsigned int v40 = *(_DWORD *)(v39 + 745);
  if ((v40 & 0x2000) != 0)
  {
    unsigned int v527 = v40;
    if (x_log_hook_p())
    {
      x_log_();
      LODWORD(v595.f64[0]) = 0;
      unsigned int v40 = v527;
    }
    else
    {
      v542 = x_log_category_flipbook;
      BOOL v543 = os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT);
      LODWORD(v595.f64[0]) = 0;
      unsigned int v40 = v527;
      if (v543)
      {
        LOWORD(v692[0].f64[0]) = 0;
        _os_log_impl(&dword_184668000, v542, OS_LOG_TYPE_DEFAULT, "entering flipbook, disallowing detaching", (uint8_t *)v692, 2u);
        unsigned int v40 = v527;
        LODWORD(v595.f64[0]) = 0;
      }
    }
  }
  else
  {
    LODWORD(v595.f64[0]) = v38 ^ 1;
  }
  unsigned int v551 = v40;
  int v567 = (v40 >> 13) & 1;
  int v41 = *(unsigned __int8 *)(v10 + 520);
  v599.i32[0] = *(unsigned char *)(v10 + 520) != 0;
  if (v41) {
    *(unsigned char *)(v10 + 52CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
  }
  v566 = 0;
  uint64_t v594 = 0;
  uint64_t v586 = 0;
  uint64_t v582 = 0;
  LODWORD(v593) = 0;
  uint64_t v556 = v30;
  BOOL v42 = v24 == v30;
  int v43 = *(unsigned __int8 *)(v10 + 521);
  *(unsigned char *)(v10 + 521) = 0;
  int v44 = v24 == v30 || v26;
  int v565 = (v44 | v27) ^ 1;
  if (!v29) {
    BOOL v42 = 1;
  }
  int v557 = v27;
  int v583 = v42 | v27;
  unsigned int v596 = v3 & 1;
  v581.i64[0] = v596 << 10;
  BOOL v555 = v26;
  uint64_t v45 = 0x80000;
  if (!(((unint64_t)v568 >> 26) & 1 | v26)) {
    uint64_t v45 = 0;
  }
  v580 = (float64x2_t *)v45;
  *(void *)&v578.f64[0] = v628;
  v579 = (CA::OGL::Renderer *)((char *)&v628[1] + 4);
  v577 = (uint64_t *)((char *)&v630 + 12);
  *(void *)&long long v572 = v10 + 336;
  v590 = &v633;
  v570 = v646;
  v553 = (os_unfair_lock_s *)(v10 + 324);
  uint64_t v549 = v10 + 404;
  v563 = v29;
  int8x16_t v46 = v29 - 8;
  v598.i32[0] = 3;
  v47.i64[0] = -1;
  v47.i64[1] = -1;
  int32x4_t v571 = v47;
  double v585 = INFINITY;
  long long v576 = xmmword_184997E20;
  long long v575 = xmmword_184997E30;
  double v574 = -0.8;
  double v573 = 0.4;
  char v48 = v564;
  uint64_t v584 = v24;
  while (1)
  {
    if (v583)
    {
      v566 = 0;
      uint64_t v158 = 0;
      uint64_t v582 = 0;
      uint64_t v594 = 248;
      v161.i64[0] = -1;
      v161.i64[1] = -1;
      int32x4_t v571 = v161;
      double v156 = INFINITY;
      float v162 = (const CA::Shape *)v564;
      goto LABEL_276;
    }
    uint64_t v49 = *(void *)(v10 + 96);
    unint64_t v50 = v589;
    os_unfair_lock_lock(v589);
    double v51 = *(double *)(v10 + 280);
    os_unfair_lock_unlock(v50);
    uint64_t v52 = (*(uint64_t (**)(uint64_t, void, double, double))(*(void *)v49 + 352))(v49, v596, v8, v51);
    if (v52) {
      break;
    }
    uint64_t v53 = mach_absolute_time();
    double v54 = CATimeWithHostTime(v53);
    uint64_t v55 = *(void *)(v10 + 96);
    bzero(v632, 0x448uLL);
    uint64_t v56 = (const CA::Bounds *)(v55 + 200);
    LODWORD(v55) = (*(uint64_t (**)(uint64_t))(*(void *)v55 + 360))(v55);
    int v57 = (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 368))();
    unsigned int v546 = *(_DWORD *)(v10 + 184);
    *(void *)&long long v587 = v56;
    CA::Render::Update::Update((CA::Render::Update *)v632, v670, 0x2000uLL, v8, v592, v588, v55, v57, v56, v546);
    *(void *)&long long v600 = v48;
    if (!v632[0])
    {
      uint64_t v594 = 245;
      uint64_t v158 = v586;
      double v156 = v585;
LABEL_616:
      v461 = *(double ***)(v10 + 200);
      if (v461)
      {
        v462 = *v461;
        int v463 = v648;
        *((_DWORD *)v462 + 57) = v647;
        *((_DWORD *)v462 + 58) = v463;
        CA::Render::Update::release_objects(v632);
        v464 = *v461;
        v464[30] = v8;
        (*(void (**)(double *, void))(*(void *)v464 + 216))(v464, 0);
      }
      uint64_t v465 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 392))(v10);
      if (v465)
      {
        uint64_t v467 = v465;
        v599.i64[0] = *(void *)(*(void *)v465 + 716);
        if ((CA::WindowServer::Server::check_performance(CA::OGL::Renderer *,CA::Render::Update *)::initialized & 1) == 0)
        {
          CA::WindowServer::Server::check_performance(CA::OGL::Renderer *,CA::Render::Update *)::initialized = 1;
          LOBYTE(v692[0].f64[0]) = 0;
          CFStringRef v468 = (const __CFString *)*MEMORY[0x1E4F1D3D8];
          CFPreferencesGetAppBooleanValue(@"PerfWarnings", (CFStringRef)*MEMORY[0x1E4F1D3D8], (Boolean *)v692);
          if (LOBYTE(v692[0].f64[0])) {
            CA::WindowServer::Server::check_performance(CA::OGL::Renderer *,CA::Render::Update *)::enable_warnings = 1;
          }
          AppIntegerBoolean Value = CFPreferencesGetAppIntegerValue(@"PerfTimeThreshold", v468, (Boolean *)v692);
          if (LOBYTE(v692[0].f64[0])) {
            *(double *)&CA::WindowServer::Server::check_performance(CA::OGL::Renderer *,CA::Render::Update *)::time_threshold = (float)((float)AppIntegerValue * 0.001);
          }
          int v470 = CFPreferencesGetAppIntegerValue(@"PerfInputDelayThreshold", v468, (Boolean *)v692);
          uint64_t v24 = v584;
          if (LOBYTE(v692[0].f64[0])) {
            *(double *)&CA::WindowServer::Server::check_performance(CA::OGL::Renderer *,CA::Render::Update *)::input_delay_threshold = (float)((float)v470 * 0.001);
          }
          int v471 = CFPreferencesGetAppIntegerValue(@"PerfOffscreenThreshold", v468, (Boolean *)v692);
          if (LOBYTE(v692[0].f64[0])) {
            CA::WindowServer::Server::check_performance(CA::OGL::Renderer *,CA::Render::Update *)::passes_threshold = v471;
          }
        }
        if ((CA::WindowServer::Server::check_performance(CA::OGL::Renderer *,CA::Render::Update *)::enable_warnings & 1) != 0
          || BYTE9(xmmword_1EB2ACBF0))
        {
          uint64_t v472 = mach_absolute_time();
          double v473 = CATimeWithHostTime(v472);
          if (v473 >= *(double *)(v10 + 304) + 5.0)
          {
            double v474 = v656;
            double v475 = v655;
            if (v659 == 0.0) {
              double v476 = v659;
            }
            else {
              double v476 = v634 - v659;
            }
            int v477 = *(_DWORD *)(*(void *)v467 + 712);
            int v478 = *(_DWORD *)(*(void *)v467 + 720);
            if (initialized != -1) {
              dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
            }
            if (*(float *)&dword_1EB2ACAD8) {
              *(double *)&CA::WindowServer::Server::check_performance(CA::OGL::Renderer *,CA::Render::Update *)::time_threshold = (float)((float)*(float *)&dword_1EB2ACAD8 * 0.001);
            }
            if (*(float *)&dword_1EB2ACADC) {
              *(double *)&CA::WindowServer::Server::check_performance(CA::OGL::Renderer *,CA::Render::Update *)::input_delay_threshold = (float)((float)*(float *)&dword_1EB2ACADC * 0.001);
            }
            signed int v479 = *(float *)&dword_1EB2ACAE0;
            if (*(float *)&dword_1EB2ACAE0) {
              CA::WindowServer::Server::check_performance(CA::OGL::Renderer *,CA::Render::Update *)::passes_threshold = *(float *)&dword_1EB2ACAE0;
            }
            else {
              signed int v479 = CA::WindowServer::Server::check_performance(CA::OGL::Renderer *,CA::Render::Update *)::passes_threshold;
            }
            if (v474 + v475 > *(double *)&CA::WindowServer::Server::check_performance(CA::OGL::Renderer *,CA::Render::Update *)::time_threshold
              || v476 > *(double *)&CA::WindowServer::Server::check_performance(CA::OGL::Renderer *,CA::Render::Update *)::input_delay_threshold
              || v477 > v479)
            {
              memset(v692, 0, 24);
              x_stream_push((uint64_t)v692);
              CA::WindowServer::print_layer_trees((uint64_t)v570, 0, v634);
              if (*(void *)&v692[0].f64[0]) {
                CFStringRef v521 = CFStringCreateWithCString(0, *(const char **)&v692[0].f64[0], 0x8000100u);
              }
              else {
                CFStringRef v521 = 0;
              }
              x_stream_pop_((uint64_t)v692);
              if (*(void *)&v692[0].f64[0])
              {
                free(*(void **)&v692[0].f64[0]);
                memset(v692, 0, 24);
              }
              Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              CA_CFDictionarySetDouble(Mutable, @"WarningTime", v473);
              CA_CFDictionarySetDouble(Mutable, @"UpdateTime", v634);
              CA_CFDictionarySetDouble(Mutable, @"UpdateInputTime", v659);
              CA_CFDictionarySetDouble(Mutable, @"UpdateInputDelay", v476);
              CA_CFDictionarySetDouble(Mutable, @"UpdateCreationTime", v655);
              CA_CFDictionarySetDouble(Mutable, @"UpdateRenderTime", v656);
              CA_CFDictionarySetInt(Mutable, @"UpdatePrepareLayerCount", v657);
              CA_CFDictionarySetInt(Mutable, @"UpdatePrepareLayer0Count", v658);
              CA_CFDictionarySetInt(Mutable, @"RenderOffscreenPasses", v477);
              CA_CFDictionarySetInt(Mutable, @"RenderShaderCompiles", v478);
              if (v521)
              {
                CFDictionarySetValue(Mutable, @"LayerTree", v521);
                CFRelease(v521);
              }
              *(double *)(v10 + 304) = v473;
              *(void *)(v10 + 312) = Mutable;
              notify_post("com.apple.CoreAnimation.CAWindowServer.Performance");
              uint64_t v24 = v584;
            }
          }
        }
      }
      else
      {
        v599.i64[0] = 0;
      }
      CA::Render::Update::~Update((CA::Render::Update *)v632, v466);
      int v164 = 0;
      goto LABEL_644;
    }
    float v58 = *(_DWORD **)(v10 + 96);
    if (v58[178] != v654)
    {
      v650 |= 4u;
      v58[178] = v654;
    }
    (*(void (**)(_DWORD *, uint64_t, void, void, double, double))(*(void *)v58 + 376))(v58, v597, v596, *(unsigned int *)(v10 + 288), v8, *(double *)&v16);
    uint64_t v643 = v591.i64[0];
    float v59 = *(_DWORD **)(v10 + 96);
    if ((v59[156] & 0x100) != 0)
    {
      unsigned int v60 = (*(uint64_t (**)(_DWORD *))(*(void *)v59 + 136))(v59);
      if (!v60) {
        unsigned int v60 = (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 784))(*(void *)(v10 + 96));
      }
      unsigned int v651 = vcvtad_u64_f64(1.0/ ((*(double (**)(void))(**(void **)(v10 + 96) + 760))(*(void *)(v10 + 96))* (double)v60));
      float v59 = *(_DWORD **)(v10 + 96);
    }
    unint64_t v61 = v668 & 0xFFFFFB7F | ((unint64_t)v669 << 32) | v581.i64[0] | ((unint64_t)*(unsigned __int8 *)(v10 + 514) << 7);
    unsigned __int32 v668 = v668 & 0xFFFFFB7F | v581.i32[0] | (*(unsigned __int8 *)(v10 + 514) << 7);
    if (*(unsigned char *)(v10 + 515))
    {
      unsigned __int8 v62 = (*(uint64_t (**)(_DWORD *))(*(void *)v59 + 1608))(v59);
      unint64_t v61 = v668 | ((unint64_t)v669 << 32);
      int v63 = 0x100000;
      if (((v62 ^ 1) & LOBYTE(v595.f64[0]) & 1) == 0) {
        int v63 = 0;
      }
      float v59 = *(_DWORD **)(v10 + 96);
    }
    else
    {
      int v63 = 0;
    }
    unsigned __int16 v669 = WORD2(v61);
    unsigned __int32 v668 = v61 & 0xFFEFFFFF | v63;
    (*(void (**)(void))(*(void *)v59 + 752))();
    double v65 = v660;
    if (v660 >= *(double *)&v16) {
      double v65 = *(double *)&v16;
    }
    double v660 = v65;
    uint64_t v638 = v64;
    unint64_t v639 = v16;
    unint64_t v66 = v668 & 0xFFF7FFFF | ((unint64_t)v669 << 32);
    unsigned __int32 v668 = v668 & 0xFFF7FFFF | v580;
    unsigned __int16 v669 = WORD2(v66);
    double v640 = (*(double (**)(uint64_t))(*(void *)v10 + 472))(v10);
    if (byte_1EB2ACC87) {
      _ZF = 1;
    }
    else {
      _ZF = *(unsigned char *)(v10 + 525) == 0;
    }
    int v68 = 4096;
    if (_ZF) {
      int v68 = 0;
    }
    unsigned __int32 v668 = v68 | v668 & 0xFFFFE7FF | (*(unsigned __int8 *)(v10 + 524) << 11);
    uint64_t v652 = (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 1400))();
    float v70 = *(_DWORD **)(v10 + 96);
    if (!BYTE14(xmmword_1EB2ACBF0))
    {
      unint64_t v71 = v668 & 0xFFDFFFFF | ((unint64_t)v669 << 32);
      unsigned __int32 v668 = v668 & 0xFFDFFFFF | (v70[156] << 17) & 0x200000;
      unsigned __int16 v669 = WORD2(v71);
    }
    if ((v70[156] & 0x100) != 0)
    {
      uint64_t v72 = (*(uint64_t (**)(_DWORD *))(*(void *)v70 + 120))(v70);
      if (v72)
      {
        unsigned __int8 v73 = atomic_load((unsigned __int8 *)(*(void *)(v72 + 24) + 32));
        uint64_t v74 = v73 & 1;
      }
      else
      {
        uint64_t v74 = 0;
      }
      double v75 = (*(double (**)(void))(**(void **)(v10 + 96) + 760))(*(void *)(v10 + 96));
      unsigned __int8 v76 = (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 768))();
      if (v645) {
        __assert_rtn("initialize_frame_rate_range_group", "render-updater.cpp", 11243, "_frame_rate_range_group == nullptr");
      }
      v645 = [[CAFrameRateRangeGroup alloc] initWithHeartbeatRate:v76 minimumFrameDuration:1 supportsVRR:0 compatQuantaMode:v74 serverCompatQuantaMode:v75];
      int v77 = (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 792))();
      uint64_t v78 = 0x1000000000;
      if (!v77) {
        uint64_t v78 = 0;
      }
      unint64_t v79 = (v668 | ((unint64_t)v669 << 32)) & 0xFFFFFFEFFFFFFFFFLL | v78;
      unsigned __int16 v669 = WORD2(v79);
      float v70 = *(_DWORD **)(v10 + 96);
      if ((v70[156] & 0x100) != 0)
      {
        unsigned __int32 v668 = v79;
        unsigned __int16 v669 = (v79 | 0x800000000) >> 32;
      }
    }
    __int16 v604 = 0;
    v603[1] = 0;
    v603[0] = 0;
    v599.i32[0] |= LODWORD(v595.f64[0]) ^ 1;
    if (v599.i8[0]) {
      v668 |= 0x20000u;
    }
    if (v48)
    {
      CA::shape_union(v590, v48, v69);
      float v70 = *(_DWORD **)(v10 + 96);
    }
    int v80 = (*(uint64_t (**)(_DWORD *))(*(void *)v70 + 552))(v70);
    int v81 = 0x400000;
    if ((v80 & (v593 ^ 1)) == 0) {
      int v81 = 0;
    }
    unsigned int v82 = v668 & 0xFF3FFFFF | v81;
    int v83 = 0x800000;
    if ((v80 & (v593 ^ 1)) == 0) {
      int v83 = 0;
    }
    unsigned __int32 v668 = v82 | v83;
    if (CADeviceNeedsP3ShapeTracking::once != -1) {
      dispatch_once(&CADeviceNeedsP3ShapeTracking::once, &__block_literal_global_59);
    }
    unint64_t v84 = v668 & 0xFEFFFFFF | ((unint64_t)v669 << 32);
    unsigned __int32 v668 = v668 & 0xFEFFFFFF | (CADeviceNeedsP3ShapeTracking::p3_tracking << 24);
    unsigned __int16 v669 = WORD2(v84);
    int v85 = (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 560))();
    unint64_t v86 = v668 & 0xF9FFFFFF | ((unint64_t)v669 << 32);
    int v87 = 0x4000000;
    if (v85) {
      int v87 = 100663296;
    }
    unsigned __int32 v668 = v87 | v668 & 0xF9FFFFFF;
    unsigned __int16 v669 = WORD2(v86);
    v626[0] = 0u;
    *(void *)&long long v630 = 0;
    long long v629 = 0u;
    memset(v628, 0, sizeof(v628));
    *(_OWORD *)((char *)v626 + 12) = v576;
    HIDWORD(v626[1]) = 1065353216;
    long long v627 = v575;
    float64_t v88 = v578.f64[0];
    **(void **)&v578.f64[0] = 0;
    *(_WORD *)(*(void *)&v88 + 8) = 0;
    *(void *)((char *)v628 + 12) = 0x100000001;
    uint64_t v89 = v579;
    *(_OWORD *)v579 = 0u;
    *((_OWORD *)v89 + 1) = 0u;
    *((unsigned char *)v89 + 32) = 0;
    uint64_t v90 = (uint64_t)v577;
    uint64_t *v577 = 0;
    *(void *)(v90 + 8) = 0;
    DWORD2(v63CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 1065353216;
    HIDWORD(v631) = -1;
    (*(void (**)(void))(**(void **)(v10 + 96) + 1072))();
    CA::WindowServer::Display::reconciled_display_attributes((CA::WindowServer::Display *)v626, *(void *)(v10 + 96));
    CA::Render::Update::set_display_attributes((uint64_t)v632, (float *)v626);
    if (*(float *)(v10 + 336) != *(float *)v626
      || *(float *)(v10 + 340) != *((float *)v626 + 1)
      || *(float *)(v10 + 348) != *((float *)v626 + 3)
      || *(float *)(v10 + 352) != *(float *)&v626[1]
      || *(float *)(v10 + 356) != *((float *)&v626[1] + 1)
      || *(float *)(v10 + 360) != *((float *)&v626[1] + 2)
      || *(float *)(v10 + 364) != *((float *)&v626[1] + 3)
      || *(double *)(v10 + 368) != *(double *)&v627
      || *(double *)(v10 + 376) != *((double *)&v627 + 1)
      || *(unsigned __int8 *)(v10 + 384) != LOBYTE(v628[0])
      || *(unsigned __int8 *)(v10 + 385) != BYTE1(v628[0])
      || *(unsigned __int8 *)(v10 + 386) != BYTE2(v628[0])
      || *(unsigned __int8 *)(v10 + 387) != BYTE3(v628[0])
      || *(unsigned __int8 *)(v10 + 388) != BYTE4(v628[0])
      || *(unsigned __int8 *)(v10 + 389) != BYTE5(v628[0])
      || *(unsigned __int8 *)(v10 + 390) != BYTE6(v628[0])
      || *(void *)(v10 + 396) != *(void *)((char *)v628 + 12)
      || !CA::Render::Chromaticity::operator==(v549, (uint64_t)v579)
      || *(float *)(v10 + 440) != *((float *)&v630 + 2)
      || *(float *)(v10 + 444) != *((float *)&v630 + 3)
      || *(float *)(v10 + 448) != *(float *)&v631
      || *(float *)(v10 + 452) != *((float *)&v631 + 1)
      || *(float *)(v10 + 456) != *((float *)&v631 + 2)
      || *(_DWORD *)(v10 + 460) != HIDWORD(v631))
    {
      v669 |= 0x400u;
      long long v91 = v629;
      float v92 = (_OWORD *)v572;
      *(_OWORD *)(v572 + 64) = v628[1];
      v92[5] = v91;
      long long v93 = v631;
      v92[6] = v630;
      v92[7] = v93;
      long long v94 = v626[1];
      *float v92 = v626[0];
      v92[1] = v94;
      long long v95 = v628[0];
      v92[2] = v627;
      v92[3] = v95;
    }
    double v663 = v31;
    v611[1] = 0;
    v611[0] = 0;
    CA::Render::Fence::BatchWaitLock::BatchWaitLock((CA::Render::Fence::BatchWaitLock *)v611);
    int v96 = 0;
    if (v24)
    {
      double v97 = INFINITY;
      double v98 = INFINITY;
      do
      {
        uint64_t v99 = *(void *)&v46[8 * v24];
        pthread_mutex_lock((pthread_mutex_t *)(v99 + 72));
        if (v43) {
          *(_DWORD *)(v99 + 12) |= 0x2000u;
        }
        CA::Render::Update::add_context((CA::Render::Update *)v632, (CA::Render::Context *)v99);
        if (!HIBYTE(v604)) {
          CA::WindowServer::get_context_logical_bounds((CA::WindowServer *)v99, (CA::Render::Context *)((char *)&v604 + 1), v603, (CA::Bounds *)&v604, v100);
        }
        --v24;
        if (*(double *)(v99 + 456) < v98) {
          double v98 = *(double *)(v99 + 456);
        }
        *(void *)(v99 + 456) = 0x7FF0000000000000;
        if (*(double *)(v99 + 512) < v97) {
          double v97 = *(double *)(v99 + 512);
        }
        *(void *)(v99 + 512) = 0x7FF0000000000000;
        __int16 v101 = *(_WORD *)(v99 + 552);
        v96 |= (v101 & 0x80) >> 7;
        *(_WORD *)(v99 + 552) = v101 & 0xFF7F;
        pthread_mutex_unlock((pthread_mutex_t *)(v99 + 72));
      }
      while (v24);
    }
    else
    {
      double v98 = INFINITY;
      double v97 = INFINITY;
    }
    CA::Render::Fence::BatchWaitLock::invalidate((uint64_t)v611);
    int v103 = (CA::Render::LayerNode *)v600;
    if ((void)v600) {
      CA::Render::Update::invalidate_backdrops((uint64_t)v632, (CA::Shape *)v600, 0, 1);
    }
    CA::Render::Update::added_all_contexts(v632, v103, v102);
    unsigned int v105 = *(_DWORD *)(v10 + 288);
    if (v105 <= 1) {
      unsigned int v105 = 1;
    }
    float v106 = (float)v658 / (double)v105;
    *(_DWORD *)(v10 + 288) = v658;
    v104.n128_f64[0] = v106 + v574;
    if (v104.n128_f64[0] < 0.0) {
      v104.n128_f64[0] = -v104.n128_f64[0];
    }
    if (v104.n128_f64[0] >= v573) {
      (*(void (**)(void))(**(void **)(v10 + 96) + 384))(*(void *)(v10 + 96));
    }
    float v107 = v645;
    if (v645)
    {
      unsigned int v108 = v669 >> 5;
      if (v669 >> 5 && v108 != 5)
      {
        if (initialize_velocity_thresholds(void)::once[0] != -1) {
          dispatch_once(initialize_velocity_thresholds(void)::once, &__block_literal_global_19);
        }
        unint64_t v109 = 4 - v108;
        double v110 = 0.0;
        if (v109 > 3)
        {
          double v111 = 0.0;
          double v112 = 0.0;
        }
        else
        {
          double v111 = 0.0;
          double v112 = 0.0;
          if (has_velocity_thresholds)
          {
            int v113 = (_DWORD *)((char *)&velocity_threshold_frame_rate_ranges + 12 * (int)v109);
            LODWORD(v111) = *v113;
            LODWORD(v11CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v113[1];
            LODWORD(v112) = v113[2];
          }
        }
        if ((((unint64_t)v669 << 32) & 0xE000000000) == 0x2000000000) {
          *(float *)&double v112 = 0.0;
        }
        -[CAFrameRateRangeGroup addFrameRateRange:](v107, "addFrameRateRange:", v111, v110, v112);
      }
      v692[0] = (float64x2_t)xmmword_184997FD0;
      CA::Render::post_notification(0x3Cu, 0, (uint64_t)v692, 0);
      LODWORD(v682.f64[1]) = 0;
      v682.f64[0] = 0.0;
      *(void *)&v682.f64[0] = [(CAFrameRateRangeGroup *)v107 arbitratedIntervalRange];
      LODWORD(v682.f64[1]) = v114;
      if ((!*(void *)&v692[0].f64[0] || LOBYTE(v692[0].f64[1]))
        && ![(CAFrameRateRangeGroup *)v107 hasCompatQuantaIntent])
      {
        (*(void (**)(void))(**(void **)(v10 + 96) + 288))(*(void *)(v10 + 96));
      }
      (*(void (**)(void))(**(void **)(v10 + 96) + 2080))(*(void *)(v10 + 96));
      (*(void (**)(void))(**(void **)(v10 + 96) + 1928))();
    }
    atomic_store(v639, &CA::Render::Context::_begin_time_threshold);
    if (initialized != -1) {
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    }
    float v115 = *(float *)&dword_1EB2ACAEC;
    if (*(float *)&dword_1EB2ACAEC == 0.0)
    {
      uint64_t v116 = *(void *)(v10 + 96);
      if (v667 > 1.0 && (*(unsigned char *)(v116 + 746) & 0x40) == 0) {
        float v115 = v667;
      }
    }
    else
    {
      uint64_t v116 = *(void *)(v10 + 96);
    }
    v104.n128_u32[0] = 1.0;
    if (v115 > 1.0 || (*(unsigned char *)(v116 + 746) & 0x40) != 0) {
      BOOL v117 = (*(_DWORD *)(v116 + 624) & 4) == 0
    }
          || (*(unsigned char *)(v116 + 746) & 0x40 | byte_1EB2ACC62) != 0;
    else {
      BOOL v117 = 0;
    }
    int v118 = v650 & 0x18000;
    if (byte_1EB2ACC8F)
    {
      BOOL v120 = 0;
      double v119 = 0.0;
    }
    else
    {
      if (v118)
      {
        *(double *)(v116 + 696) = v8;
        double v119 = v8;
      }
      else
      {
        double v119 = *(double *)(v116 + 696);
      }
      v104.n128_f64[0] = v119 + 15.0;
      BOOL v120 = v119 + 15.0 >= v8;
    }
    if (v118) {
      int v121 = 1;
    }
    else {
      int v121 = v117 || v120;
    }
    if ((*(unsigned int (**)(uint64_t, __n128))(*(void *)v10 + 136))(v10, v104) && v121)
    {
      uint64_t v123 = v10;
      uint64_t v124 = 1;
      v122.n128_f32[0] = v115;
    }
    else
    {
      v122.n128_u64[0] = 0;
      uint64_t v123 = v10;
      uint64_t v124 = 0;
    }
    (*(void (**)(uint64_t, uint64_t, __n128))(*(void *)v10 + 464))(v123, v124, v122);
    uint64_t v125 = v653;
    uint64_t v24 = v584;
    if (v653)
    {
      uint64_t v126 = *(_DWORD **)(v10 + 96);
      if ((v126[156] & 4) == 0)
      {
        uint64_t v127 = (*(uint64_t (**)(_DWORD *))(*(void *)v126 + 1400))(v126);
        uint64_t v125 = v653;
        if (v127)
        {
          uint64_t v125 = v653 | v127;
          v653 |= v127;
        }
      }
    }
    if (*(void *)(v10 + 296) != v125)
    {
      __int16 v128 = (_DWORD *)(*(void *)(v10 + 96) + 168);
      memset(v692, 0, sizeof(v692));
      CA::Shape::operator=((uint64_t)v692, v128);
      CA::shape_union(v590, (CA::Shape **)v692, v129);
      *(void *)(v10 + 296) = v653;
    }
    if (((v668 | ((unint64_t)v669 << 32)) & 0x10000000000) != 0
      && (*(unsigned int (**)(void))(**(void **)(v10 + 96) + 616))(*(void *)(v10 + 96)))
    {
      float v130 = (_DWORD *)(*(void *)(v10 + 96) + 168);
      memset(v692, 0, sizeof(v692));
      CA::Shape::operator=((uint64_t)v692, v130);
      CA::shape_union(v590, (CA::Shape **)v692, v131);
    }
    uint64_t v132 = mach_absolute_time();
    double v655 = CATimeWithHostTime(v132) - v54;
    uint64_t v133 = *(void *)(v10 + 96);
    if (HIBYTE(v604))
    {
      if ((CA::WindowServer::Display::set_logical_bounds((CA::WindowServer::Display *)v133, (const CA::Bounds *)v603, v604) & 1) == 0)goto LABEL_204; {
    }
      }
    else
    {
      int v134 = *(_DWORD *)(v133 + 745);
      if ((v134 & 2) == 0
        || (*(void *)(v133 + 184) = 0,
            *(void *)(v133 + 192) = 0,
            *(_DWORD *)(v133 + 745) = v134 & 0xFFFFFFED,
            !CA::WindowServer::Display::update_actual_bounds((CA::WindowServer::Display *)v133)))
      {
LABEL_204:
        if (v649 == CA::Render::LayerHost::_seed[0]) {
          goto LABEL_210;
        }
        goto LABEL_205;
      }
    }
    memset(v692, 0, sizeof(v692));
    CA::Shape::operator=((uint64_t)v692, (_DWORD *)v587);
    CA::shape_union(v590, (CA::Shape **)v692, v135);
    v599.i32[0] = 1;
LABEL_205:
    _VF = __OFSUB__(v598.i32[0]--, 1);
    if (v598.i32[0] < 0 == _VF)
    {
      if ((void)v600) {
        CA::Shape::unref((CA::Shape *)v600);
      }
      if (v633) {
        char v48 = (CA::Shape **)CA::Shape::ref((unint64_t)v633);
      }
      else {
        char v48 = 0;
      }
      LODWORD(v593) = ((v650 & 2) == 0) | v593;
      goto LABEL_255;
    }
LABEL_210:
    uint64_t v137 = 0;
    double v585 = INFINITY;
    uint64_t v586 = 0;
    if (!v118 && v120)
    {
      double v585 = v119 + 15.0;
      if (v119 + 15.0 <= INFINITY)
      {
        uint64_t v586 = 0x80000000000;
        uint64_t v137 = 0x80000000000;
      }
      else
      {
        uint64_t v586 = 0;
        uint64_t v137 = 0x80000000000;
        double v585 = INFINITY;
      }
    }
    uint64_t v582 = v137;
    int v138 = v650;
    *(unsigned char *)(v10 + 519) = (v650 & 0x800) != 0;
    if ((v138 & 0x1000104) != 0
      || v633 && CA::Shape::area(v633)
      || (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 336))(*(void *)(v10 + 96))
      || (CA::WindowServer::Display::benchmark_mode(0, v153) & 1) != 0
      || (float v154 = *(unsigned char **)(v10 + 96), (v154[746] & 4) != 0))
    {
      *(_DWORD *)(*(void *)(v10 + 96) + 745) &= ~0x400u;
      int v139 = 1;
    }
    else
    {
      int v155 = (*(uint64_t (**)(unsigned char *, void))(*(void *)v154 + 512))(v154, v647);
      int v139 = v155 ^ 1;
      if (v650 & 0x40000) == 0 && (v155)
      {
        uint64_t v524 = 246;
LABEL_281:
        uint64_t v594 = v524;
        uint64_t v158 = v586;
        double v156 = v585;
        float v165 = v553;
        (*(void (**)(void, void))(**(void **)(v10 + 96) + 392))(*(void *)(v10 + 96), 0);
LABEL_601:
        v457 = CA::Render::Update::build_hit_test_tree((CA::Render::Update *)v632, 0, v160, 1.0);
        os_unfair_lock_lock(v165);
        v458 = *(CA::Render::HitTestTree **)(v10 + 328);
        *(void *)(v10 + 328) = v457;
        os_unfair_lock_unlock(v165);
        if (v458) {
          CA::Render::HitTestTree::unref(v458);
        }
        if (BYTE5(ca_debug_options)) {
          CA::WindowServer::print_layer_trees((uint64_t)v570, 1, v634);
        }
        if (v156 >= v635)
        {
          if (v156 <= v635 || v635 == 0.0) {
            uint64_t v460 = v158;
          }
          else {
            uint64_t v460 = 0;
          }
          uint64_t v158 = v636 | v460;
          double v156 = v635;
        }
        v582 |= v637;
        if ((unint64_t)(v644 + 1) >= 2) {
          (*(void (**)(uint64_t))(*(void *)v10 + 360))(v10);
        }
        (*(void (**)(void, double, double))(**(void **)(v10 + 96) + 1960))(*(void *)(v10 + 96), v641, v642);
        CA::Render::Fence::BatchWaitLock::invalidate((uint64_t)v611);
        goto LABEL_616;
      }
    }
    if (!(*(unsigned int (**)(void))(**(void **)(v10 + 96) + 208))(*(void *)(v10 + 96))
      || ((*(uint64_t (**)(void, uint64_t **))(**(void **)(v10 + 96) + 344))(*(void *)(v10 + 96), v632) & 1) != 0)
    {
      if (!(*(unsigned int (**)(void))(**(void **)(v10 + 96) + 216))(*(void *)(v10 + 96)))
      {
        uint64_t v524 = 255;
        goto LABEL_281;
      }
      double v156 = v585;
      BOOL v157 = v585 <= v8 || v8 == 0.0;
      uint64_t v158 = v586;
      uint64_t v159 = v586 | 0x40000;
      if (!v157) {
        uint64_t v159 = 0x40000;
      }
      v582 |= 0x40000uLL;
      if (v585 >= v8)
      {
        double v156 = v8;
        uint64_t v158 = v159;
      }
      CA::WindowServer::Server::invalidate((os_unfair_lock_s *)v10, v633);
      (*(void (**)(void, void))(**(void **)(v10 + 96) + 392))(*(void *)(v10 + 96), 0);
      uint64_t v594 = 247;
LABEL_600:
      float v165 = v553;
      goto LABEL_601;
    }
    uint64_t v140 = mach_absolute_time();
    double v141 = CATimeWithHostTime(v140);
    if (v139) {
      int v142 = 0;
    }
    else {
      int v142 = 8;
    }
    unsigned int v602 = v142;
    (*(void (**)(void))(**(void **)(v10 + 96) + 408))();
    int v143 = 32;
    if ((v96 & 1) == 0) {
      int v143 = 0;
    }
    unint64_t v144 = v668 & 0xFFFFFFDF | ((unint64_t)v669 << 32);
    unsigned __int32 v668 = v668 & 0xFFFFFFDF | v143;
    unsigned __int16 v669 = WORD2(v144);
    if ((*(void *)&v98 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      double v659 = v98;
      CAHostTimeWithTime(v98);
      kdebug_trace();
    }
    uint64_t v145 = (CA::Shape *)v600;
    if ((*(void *)&v97 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL) {
      double v661 = v97;
    }
    if ((void *)v646[1] == v570)
    {
      uint64_t v594 = 2;
      goto LABEL_291;
    }
    float v146 = v589;
    os_unfair_lock_lock(v589);
    double v147 = *(double *)(v10 + 280);
    *(double *)(v10 + 28CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v8;
    os_unfair_lock_unlock(v146);
    if (v147 != 0.0)
    {
      if (v645)
      {
        LODWORD(v692[0].f64[0]) = 0;
        uint64_t v148 = [(CAFrameRateRangeGroup *)v645 reasonsWithCount:v692];
        if (v148) {
          (*(void (**)(void, uint64_t, void, double, double))(**(void **)(v10 + 96) + 1936))(*(void *)(v10 + 96), v148, LODWORD(v692[0].f64[0]), v8, v147);
        }
      }
    }
    if (HIBYTE(ca_debug_options))
    {
      CARecordFrame(0, 0, 0, 0, v8, 0.0, 0.0);
LABEL_291:
      uint64_t v158 = v586;
      double v156 = v585;
      if (*(unsigned char *)(v10 + 525) && !byte_1EB2ACC87
        || (*(unsigned int (**)(void))(**(void **)(v10 + 96) + 2040))(*(void *)(v10 + 96)))
      {
        uint64_t v586 = v158;
        uint64_t v167 = (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 2040))(*(void *)(v10 + 96));
        uint64_t v168 = v167;
        int v169 = *(unsigned __int8 *)(v10 + 525);
        int v170 = byte_1EB2ACC87;
        uint64_t v171 = v665;
        uint64_t v172 = v666;
        if (v665 == v666 && v167)
        {
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            uint64_t v173 = x_log_category_secure_indicators;
            if (os_log_type_enabled((os_log_t)x_log_category_secure_indicators, OS_LOG_TYPE_INFO))
            {
              LOWORD(v692[0].f64[0]) = 0;
              _os_log_impl(&dword_184668000, v173, OS_LOG_TYPE_INFO, "CASecureIndicator : No indicator in update, hiding sil", (uint8_t *)v692, 2u);
            }
          }
        }
        (*(void (**)(void, void))(**(void **)(v10 + 96) + 2128))(*(void *)(v10 + 96), BYTE6(qword_1EB2ACC90));
        if (v169) {
          BOOL v174 = v171 == v172;
        }
        else {
          BOOL v174 = 1;
        }
        if (!v174 && v170 == 0) {
          int v176 = 0;
        }
        else {
          int v176 = v168;
        }
        if (v176 == 1)
        {
          char v177 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v10 + 96) + 2056))(*(void *)(v10 + 96), 15);
          uint64_t v158 = v586;
          if (v177)
          {
            (*(void (**)(void))(**(void **)(v10 + 96) + 2064))(*(void *)(v10 + 96));
            if (((*(uint64_t (**)(void))(**(void **)(v10 + 96) + 2032))() & 1) == 0) {
              __assert_rtn("update_secure_indicators", "windowserver-server.cpp", 3059, "success");
            }
            (*(void (**)(void))(**(void **)(v10 + 96) + 2112))(*(void *)(v10 + 96));
            (*(void (**)(void))(**(void **)(v10 + 96) + 2096))();
            goto LABEL_339;
          }
LABEL_333:
          v692[0].f64[0] = 0.0;
          *(int64x2_t *)((char *)v692 + 8) = vdupq_n_s64(0x40000000000uLL);
          (*(void (**)(uint64_t, float64x2_t *, double))(*(void *)v10 + 184))(v10, v692, 0.0);
          goto LABEL_339;
        }
        uint64_t v158 = v586;
        if (v665 == v666) {
          goto LABEL_339;
        }
        if (((*(uint64_t (**)(void, uint64_t, void))(**(void **)(v10 + 96) + 2032))(*(void *)(v10 + 96), 1, 0) & 1) == 0)goto LABEL_333; {
        if (v168)
        }
          float v178 = 1.0;
        else {
          float v178 = 0.0;
        }
        unint64_t v179 = 0xAAAAAAAAAAAAAAABLL * ((v666 - v665) >> 4);
        uint64_t v180 = 4;
        if (v179 >= 4) {
          int v181 = 4;
        }
        else {
          int v181 = -1431655765 * ((v666 - v665) >> 4);
        }
        if ((v179 & 0xFFFFFFFC) == 0) {
          uint64_t v180 = -1431655765 * ((v666 - v665) >> 4);
        }
        unsigned int v182 = v180 - v181;
        uint64_t v183 = v180 + 1;
        uint64_t v184 = (unsigned __int8 *)(v665 + 48 * v180 - 6);
        while (--v183)
        {
          int v185 = *v184;
          v184 -= 48;
          if (!v185)
          {
            unsigned int v182 = v183;
            break;
          }
        }
        (*(void (**)(void, void))(**(void **)(v10 + 96) + 2056))(*(void *)(v10 + 96), (-1 << v182));
        if (v182)
        {
          uint64_t v186 = 0;
          unsigned __int8 v187 = 0;
          BOOL v188 = 0;
          BOOL v189 = 0;
          uint64_t v190 = 48 * v182;
          do
          {
            float v191 = (float32x2_t *)(v665 + v186);
            if (!*(unsigned char *)(v665 + v186 + 42))
            {
              LOBYTE(v692[0].f64[0]) = 0;
              LOBYTE(v682.f64[0]) = 0;
              double v192 = *(double *)&v191[2];
              double v193 = COERCE_DOUBLE(vmla_f32(v191[1], (float32x2_t)0x3F0000003F000000, *(float32x2_t *)&v192));
              (*(void (**)(void, void, void, void, float64x2_t *, float64x2_t *, double, float, double, float, float32_t, float, float32_t))(**(void **)(v10 + 96) + 2048))(*(void *)(v10 + 96), v187, v191[4].u32[1], v191[5].u16[0], v692, &v682, v193, *((float *)&v193 + 1), v192, *((float *)&v192 + 1), v191[3].f32[0], v191[3].f32[1] * v178, v191[4].f32[0]);
              BOOL v189 = (LOBYTE(v682.f64[0]) | v189) != 0;
              uint64_t v24 = v584;
              BOOL v188 = (LOBYTE(v692[0].f64[0]) | v188) != 0;
            }
            ++v187;
            v186 += 48;
          }
          while (v190 != v186);
        }
        else
        {
          BOOL v189 = 0;
          BOOL v188 = 0;
        }
        uint64_t v194 = *(void *)(v10 + 96);
        uint64_t v195 = mach_absolute_time();
        double v196 = CATimeWithHostTime(v195);
        (*(void (**)(uint64_t, BOOL, double))(*(void *)v194 + 2088))(v194, v188, v196);
        if (v188 || v189)
        {
          v692[0].f64[0] = 0.0;
          *(int64x2_t *)((char *)v692 + 8) = vdupq_n_s64(0x40000000000uLL);
          (*(void (**)(uint64_t, float64x2_t *, double))(*(void *)v10 + 184))(v10, v692, 0.0);
        }
        (*(void (**)(void, uint64_t **, uint64_t))(**(void **)(v10 + 96) + 1952))(*(void *)(v10 + 96), v632, v168);
        (*(void (**)(void))(**(void **)(v10 + 96) + 2064))();
        uint64_t v158 = v586;
      }
LABEL_339:
      if ((*(unsigned int (**)(void, uint64_t **, void, void))(**(void **)(v10 + 96) + 416))(*(void *)(v10 + 96), v632, v602, 0))
      {
        BOOL v197 = v156 <= v8 || v8 == 0.0;
        uint64_t v198 = v158 | 0x2000000;
        if (!v197) {
          uint64_t v198 = 0x2000000;
        }
        v582 |= 0x2000000uLL;
        if (v156 >= v8)
        {
          double v156 = v8;
          uint64_t v158 = v198;
        }
        *(_DWORD *)(*(void *)(v10 + 96) + 745) |= 0x400u;
        uint64_t v594 = 249;
      }
      else
      {
        int v567 = 0;
        if ((v551 & 0x2000) != 0) {
          *(_DWORD *)(*(void *)(v10 + 96) + 745) &= ~0x2000u;
        }
      }
      uint64_t v199 = *(void *)(v10 + 480);
      uint64_t v200 = *(void *)(v10 + 488);
      uint64_t v586 = v158;
      if (v199 != v200)
      {
        v579 = (CA::OGL::Renderer *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 392))(v10);
        if (v579)
        {
          double v201 = v634;
          v590 = (CA::Shape **)CAHostTimeWithTime(v634);
          float v203 = *(const CVTimeStamp **)(v10 + 480);
          BOOL v202 = *(const CVTimeStamp **)(v10 + 488);
          if (v203 != v202)
          {
            double v585 = *(double *)v579;
            v593 = (CA::Render::Context **)v704;
            *(void *)&long long v576 = &v691;
            v577 = &v614;
            v564 = (CA::Shape **)&v610;
            v568 = (CA::Shape **)v683;
            v580 = &v692[1];
            double v573 = COERCE_DOUBLE(&v619);
            __asm { FMOV            V0.2D, #1.0 }
            float64x2_t v578 = _Q0;
            double v207 = 1.0;
            float v208 = 1.0;
            long long v572 = xmmword_184997D50;
            long long v575 = xmmword_184997D60;
            double v209 = 0.5;
            _Q0.f64[0] = NAN;
            _Q0.f64[1] = NAN;
            int8x16_t v591 = (int8x16_t)vnegq_f64(_Q0);
            v592 = v202;
            while (1)
            {
              stream_and_locint k = (double *)CA::Render::ContentStream::get_or_create_stream_and_lock((CA::Render::ContentStream *)v203->version, 0, 0);
              if (stream_and_lock) {
                break;
              }
LABEL_567:
              float v203 = (const CVTimeStamp *)((char *)v203 + 200);
              if (v203 == v202) {
                goto LABEL_572;
              }
            }
            uint64_t v212 = (uint64_t)stream_and_lock;
            if (!*((unsigned char *)stream_and_lock + 400)) {
              goto LABEL_566;
            }
            float v213 = *(float *)&v203->smpteTime.seconds;
            if (v213 > 0.0 && v201 - stream_and_lock[48] < v213) {
              goto LABEL_566;
            }
            float v214 = v593;
            *((_OWORD *)v593 + 14) = 0u;
            *((_OWORD *)v214 + 15) = 0u;
            *((_OWORD *)v214 + 12) = 0u;
            *((_OWORD *)v214 + 13) = 0u;
            *((_OWORD *)v214 + 1CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0u;
            *((_OWORD *)v214 + 11) = 0u;
            *((_OWORD *)v214 + 8) = 0u;
            *((_OWORD *)v214 + 9) = 0u;
            *((_OWORD *)v214 + 6) = 0u;
            *((_OWORD *)v214 + 7) = 0u;
            *((_OWORD *)v214 + 4) = 0u;
            *((_OWORD *)v214 + 5) = 0u;
            *((_OWORD *)v214 + 2) = 0u;
            *((_OWORD *)v214 + 3) = 0u;
            *(_OWORD *)float v214 = 0u;
            *((_OWORD *)v214 + 1) = 0u;
            v700 = v214;
            v701 = v214;
            reserved = (unsigned int *)v203->reserved;
            BOOL v216 = *(unsigned int **)&v203[1].version;
            v702 = (atomic_uint **)v214;
            unint64_t v703 = 32;
            if ((unint64_t)((char *)v216 - (char *)reserved) >= 0x81)
            {
              X::small_vector_base<X::Ref<CA::Render::Context>>::grow((uint64_t)&v700, v216 - reserved);
              reserved = (unsigned int *)v203->reserved;
              BOOL v216 = *(unsigned int **)&v203[1].version;
            }
            while (reserved != v216)
            {
              uint64_t v217 = CA::Render::Context::context_by_id((CA::Render::Context *)*reserved);
              if (v217)
              {
                uint64_t v218 = v217;
                uint64_t v219 = (uint64_t *)v701;
                unint64_t v220 = v701 - v700 + 1;
                if (v703 < v220)
                {
                  X::small_vector_base<X::Ref<CA::Render::Context>>::grow((uint64_t)&v700, v220);
                  uint64_t v219 = (uint64_t *)v701;
                }
                *uint64_t v219 = v218;
                v701 = (CA::Render::Context **)(v219 + 1);
              }
              ++reserved;
            }
            if (*(_DWORD *)(v212 + 392))
            {
              uint64_t v221 = v700;
              __int16 v222 = v701;
              while (v221 != v222)
              {
                v223 = (pthread_mutex_t *)((char *)*v221 + 72);
                pthread_mutex_lock(v223);
                uint64_t v224 = CA::Render::Context::root_layer_handle(*v221);
                if (v224 && *(_DWORD *)(v224 + 80) >= v647)
                {
                  pthread_mutex_unlock(v223);
                  goto LABEL_374;
                }
                pthread_mutex_unlock(v223);
                ++v221;
              }
              v225 = v580;
              float64x2_t *v580 = 0u;
              v225[1] = 0u;
              *(void *)&v692[0].f64[0] = v590;
              LODWORD(v225) = *(_DWORD *)(v212 + 396);
              LODWORD(v692[0].f64[1]) = 2;
              HIDWORD(v692[0].f64[1]) = v225;
              v226 = v692;
              uint64_t v227 = v212;
              int v228 = 0;
              int v229 = 0;
LABEL_556:
              CA::Render::ContentStream::produce_surface(v227, v228, (uint64_t)v226, v229);
LABEL_557:
              v421 = (atomic_uint **)v700;
              v422 = (atomic_uint **)v701;
              if (v700 != v701)
              {
                do
                {
                  v423 = *v421;
                  if (*v421 && atomic_fetch_add(v423 + 2, 0xFFFFFFFF) == 1) {
                    (*(void (**)(atomic_uint *))(*(void *)v423 + 16))(v423);
                  }
                  ++v421;
                }
                while (v421 != v422);
                v421 = (atomic_uint **)v700;
              }
              if (v421 != v702) {
                free(v421);
              }
              BOOL v202 = v592;
LABEL_566:
              pthread_mutex_unlock((pthread_mutex_t *)v212);
              goto LABEL_567;
            }
LABEL_374:
            uint64_t v230 = *(void *)(v212 + 320);
            if (*(void *)(v212 + 312) == v230)
            {
              int v235 = 0;
              int v241 = 0;
              v589 = 0;
            }
            else
            {
              uint64_t v233 = *(__IOSurface **)(v230 - 24);
              uint64_t v231 = v230 - 24;
              uint64_t v232 = v233;
              int v234 = *(_DWORD *)(v231 + 8);
              int v235 = *(_DWORD *)(v231 + 12);
              uint64_t v236 = *(void *)(v231 + 16);
              *(void *)(v212 + 32CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v231;
              if (*(void *)(v212 + 360) == *(void *)(v212 + 368))
              {
                if (!v232) {
                  goto LABEL_814;
                }
              }
              else
              {
                int v425 = v234;
                v426 = v232;
                CA::Render::free_pending_names(*(uint64_t *)&v585, (void *)(v212 + 360));
                uint64_t v232 = v426;
                int v234 = v425;
                if (!v232) {
LABEL_814:
                }
                  __assert_rtn("get_next_surface", "render-content-stream.cpp", 425, "surf.iosurface");
              }
              if (!v236)
              {
                float v237 = v232;
                uint64_t v238 = (*(uint64_t (**)(double, __IOSurface *))(**(void **)&v585 + 48))(COERCE_DOUBLE(*(void *)&v585), v232);
                uint64_t v232 = v237;
                uint64_t v236 = v238;
              }
              unint64_t v240 = *(void *)(v212 + 344);
              unint64_t v239 = *(void *)(v212 + 352);
              v589 = (os_unfair_lock_s *)v232;
              if (v240 >= v239)
              {
                int v241 = v234;
                uint64_t v243 = *(void *)(v212 + 336);
                unint64_t v244 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v240 - v243) >> 3);
                unint64_t v245 = v244 + 1;
                if (v244 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  abort();
                }
                unint64_t v246 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v239 - v243) >> 3);
                if (2 * v246 > v245) {
                  unint64_t v245 = 2 * v246;
                }
                if (v246 >= 0x555555555555555) {
                  unint64_t v247 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v247 = v245;
                }
                if (v247) {
                  unint64_t v247 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v247);
                }
                else {
                  uint64_t v248 = 0;
                }
                unint64_t v249 = v247 + 24 * v244;
                *(void *)unint64_t v249 = v589;
                *(_DWORD *)(v249 + 8) = v241;
                *(_DWORD *)(v249 + 12) = v235;
                *(void *)(v249 + 16) = v236;
                short float v251 = *(char **)(v212 + 336);
                __int16 v250 = *(char **)(v212 + 344);
                unint64_t v252 = v249;
                if (v250 != v251)
                {
                  do
                  {
                    long long v253 = *(_OWORD *)(v250 - 24);
                    *(void *)(v252 - 8) = *((void *)v250 - 1);
                    *(_OWORD *)(v252 - 24) = v253;
                    v252 -= 24;
                    v250 -= 24;
                  }
                  while (v250 != v251);
                  __int16 v250 = *(char **)(v212 + 336);
                }
                unint64_t v242 = v249 + 24;
                *(void *)(v212 + 336) = v252;
                *(void *)(v212 + 344) = v249 + 24;
                *(void *)(v212 + 352) = v247 + 24 * v248;
                if (v250) {
                  operator delete(v250);
                }
              }
              else
              {
                *(void *)unint64_t v240 = v232;
                int v241 = v234;
                *(_DWORD *)(v240 + 8) = v234;
                *(_DWORD *)(v240 + 12) = v235;
                unint64_t v242 = v240 + 24;
                *(void *)(v240 + 16) = v236;
              }
              *(void *)(v212 + 344) = v242;
            }
            long long v609 = 0uLL;
            uint64_t v610 = 0;
            if (!*(void *)(v212 + 288)) {
              __assert_rtn("get_intermediate_surface", "render-content-stream.cpp", 438, "_intermediate_surf.iosurface");
            }
            if (!*(void *)(v212 + 304)) {
              *(void *)(v212 + 304) = (*(uint64_t (**)(double))(**(void **)&v585 + 48))(COERCE_DOUBLE(*(void *)&v585));
            }
            long long v254 = *(_OWORD *)(v212 + 288);
            long long v609 = v254;
            uint64_t v610 = *(void *)(v212 + 304);
            if (!v241 || !DWORD2(v609))
            {
              ++*(_DWORD *)(v212 + 396);
              goto LABEL_557;
            }
            LODWORD(v574) = v241;
            *(void *)&long long v254 = v203->hostTime;
            long long v587 = v254;
            float v255 = v700;
            float v256 = v701;
            if ((v650 & 0x84002) != 0)
            {
LABEL_403:
              uint64_t v625 = 0;
              int64x2_t v257 = 0uLL;
              float64x2_t v624 = 0u;
              long long v623 = 0u;
              long long v622 = 0u;
              long long v621 = 0u;
              long long v620 = 0u;
              long long v619 = 0u;
              float64x2_t v617 = 0u;
              float64x2_t v618 = 0u;
              long long v616 = 0u;
              goto LABEL_404;
            }
            if (v700 != v701)
            {
              v271 = v700;
              while (*((_DWORD *)*v271 + 153) == *(_DWORD *)(*(void *)(v10 + 96) + 24)
                   && (*((unsigned char *)*v271 + 13) & 2) != 0)
              {
                if (++v271 == v701) {
                  goto LABEL_426;
                }
              }
              goto LABEL_403;
            }
LABEL_426:
            uint64_t v273 = *(void *)&v203[1].smpteTime.hours;
            uint64_t flags = v203[1].flags;
            uint64_t v625 = 0;
            int64x2_t v257 = 0uLL;
            float64x2_t v624 = 0u;
            long long v623 = 0u;
            long long v622 = 0u;
            long long v621 = 0u;
            long long v620 = 0u;
            long long v619 = 0u;
            float64x2_t v617 = 0u;
            float64x2_t v618 = 0u;
            long long v616 = 0u;
            if (flags == v273)
            {
              int v269 = 1;
              v270.i64[0] = *(void *)((*(uint64_t (**)(void, uint64_t))(**(void **)(v10 + 96) + 480))(*(void *)(v10 + 96), 1)+ 56);
              int64x2_t v598 = 0u;
              goto LABEL_429;
            }
LABEL_404:
            if (v700 != v701)
            {
              int64x2_t v598 = v257;
              int64x2_t v599 = v257;
              while (1)
              {
                uint64_t v258 = CA::Render::Context::root_layer_handle(*v255);
                if (!v258) {
                  goto LABEL_418;
                }
                v259 = *(CA::Render::Layer **)(v258 + 16);
                if (!v259) {
                  goto LABEL_418;
                }
                CA::Render::Layer::frame((CA::Render::Layer *)v692, v259);
                v260.i64[0] = *(void *)&v692[1].f64[1];
                if (v692[1].f64[0] > v692[1].f64[1]) {
                  *(double *)v260.i64 = v692[1].f64[0];
                }
                if (*(double *)v260.i64 < 1073741820.0)
                {
                  __asm { FMOV            V3.2D, #0.5 }
                  int64x2_t v260 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8(v591, _Q3, (int8x16_t)v692[0]), v692[0]));
                  *(int32x2_t *)v260.i8 = vmovn_s64(v260);
                  int8x16_t v263 = (int8x16_t)vaddq_f64(v692[0], v692[1]);
                  int32x2_t v261 = vsub_s32(vmovn_s64(vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8(v591, _Q3, v263), (float64x2_t)v263))), *(int32x2_t *)v260.i8);
                }
                else
                {
                  *(int32x2_t *)v260.i8 = vdup_n_s32(0xE0000001);
                  int32x2_t v261 = (int32x2_t)0xC0000000C0000000;
                }
                uint32x2_t v264 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v599.i8);
                unsigned __int32 v265 = vpmax_u32(v264, v264).u32[0];
                uint32x2_t v266 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v261);
                unsigned __int32 v267 = vpmax_u32(v266, v266).u32[0];
                if ((v265 & 0x80000000) != 0)
                {
                  if ((v267 & 0x80000000) == 0) {
                    goto LABEL_417;
                  }
                }
                else if ((v267 & 0x80000000) == 0)
                {
                  int32x2_t v268 = vadd_s32(*(int32x2_t *)v260.i8, v261);
                  *(int32x2_t *)v260.i8 = vmin_s32(*(int32x2_t *)v598.i8, *(int32x2_t *)v260.i8);
                  int32x2_t v261 = vsub_s32(vmax_s32(vadd_s32(*(int32x2_t *)v598.i8, *(int32x2_t *)v599.i8), v268), *(int32x2_t *)v260.i8);
LABEL_417:
                  int64x2_t v598 = v260;
                  *(int32x2_t *)v260.i8 = v261;
                  int64x2_t v599 = v260;
                }
LABEL_418:
                if (++v255 == v256)
                {
                  int v269 = 0;
                  int64x2_t v270 = v599;
                  goto LABEL_429;
                }
              }
            }
            int v269 = 0;
            int64x2_t v598 = v257;
            int64x2_t v270 = 0uLL;
LABEL_429:
            char v274 = v203->flags;
            int v275 = BYTE1(v203->flags);
            v276.i64[0] = v270.i32[0];
            v276.i64[1] = v270.i32[1];
            int64x2_t v581 = v276;
            float64x2_t v277 = v578;
            int v278 = v274 & 1 | v275;
            LODWORD(v597) = v278 != 0;
            if (v278)
            {
              int64x2_t v599 = v270;
              float32x2_t v279 = vdiv_f32(vcvt_f32_s32(*(int32x2_t *)&v587), vcvt_f32_s32(*(int32x2_t *)v270.i8));
              if (v279.f32[1] < v279.f32[0]) {
                v279.f32[0] = v279.f32[1];
              }
              if (v279.f32[0] > v208) {
                v279.f32[0] = v208;
              }
              *(double *)&uint64_t v280 = v279.f32[0];
              if (!v275) {
                *(double *)&uint64_t v280 = v207;
              }
              float64x2_t v281 = (float64x2_t)vdupq_lane_s64(v280, 0);
              if (v274)
              {
                float32x2_t v282 = vcvt_f32_f64(vmulq_n_f64(vcvtq_f64_s64(v581), *(double *)&v280));
                if (v282.f32[0] != 0.0)
                {
                  v283.f32[0] = (float)(int)v587;
                  BOOL v284 = v282.f32[1] == 0.0 || v282.f32[0] == v283.f32[0];
                  if (!v284 && v282.f32[1] != (float)SDWORD1(v587))
                  {
                    v283.f32[1] = (float)SDWORD1(v587);
                    float64x2_t v281 = vmulq_n_f64(vcvtq_f64_f32(vdiv_f32(v283, v282)), *(double *)&v280);
                  }
                }
                if (v275)
                {
                  uint64_t v286 = *(uint64_t *)&v281.f64[1];
                  if (v281.f64[1] >= v281.f64[0]) {
                    uint64_t v286 = *(uint64_t *)&v281.f64[0];
                  }
                  float64x2_t v281 = (float64x2_t)vdupq_lane_s64(v286, 0);
                }
              }
              uint64_t v287 = *((void *)&v572 + 1);
              double v288 = v281.f64[1];
              long long v616 = v572;
              float64x2_t v617 = 0uLL;
              float64x2_t v618 = (float64x2_t)v575;
              double v289 = v573;
              **(_OWORD **)&double v573 = 0u;
              *(_OWORD *)(*(void *)&v289 + 16) = 0u;
              if (v281.f64[0] == v281.f64[1])
              {
                v624.f64[0] = v281.f64[0];
                v624.f64[1] = v207 / v281.f64[0];
                char v290 = 8 * (v281.f64[0] != v207);
                float64_t v291 = v281.f64[0];
              }
              else
              {
                float64x2_t v624 = v578;
                char v290 = 16;
                float64_t v291 = v281.f64[1];
              }
              *((void *)&v621 + 1) = v287;
              long long v623 = v575;
              *(float64_t *)&long long v616 = v281.f64[0];
              v618.f64[1] = v291;
              long long v622 = 0uLL;
              *(void *)&long long v621 = 0x3FF0000000000000;
              LOBYTE(v625) = v290;
              float64x2_t v595 = v281;
              CA::Transform::translate((CA::Transform *)&v616, (double)-v598.i32[0], (double)-v598.i32[1], 0.0);
              if (v275) {
                CA::Transform::translate((CA::Transform *)&v616, trunc(((double)(int)v587 - v595.f64[0] * (double)v599.i32[0]) * v209 / v595.f64[0]), trunc(((double)SDWORD1(v587) - v288 * (double)v599.i32[1]) * v209 / v288), 0.0);
              }
              float64x2_t v277 = v595;
            }
            float64x2_t v595 = v277;
            *(void *)&long long v608 = 0;
            *((void *)&v608 + 1) = v587;
            if (LODWORD(v203->videoRefreshPeriod)
              && HIDWORD(v203->videoRefreshPeriod)
              && (*(float32x2_t *)&v692[0].f64[0] = vcvt_f32_u32(*(uint32x2_t *)&v203->rateScalar),
                  CA::Transform::apply_to_point2((float64x2_t *)&v616, v692[0].f64, v211),
                  uint32x2_t v292 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v608 + 8)),
                  (vpmax_u32(v292, v292).u32[0] & 0x80000000) == 0))
            {
              int64_t videoRefreshPeriod = v203->videoRefreshPeriod;
              v294.i64[0] = videoRefreshPeriod;
              v294.i64[1] = HIDWORD(videoRefreshPeriod);
              int32x2_t v295 = vmovn_s64(vcvtq_s64_f64(vmulq_f64(v595, vcvtq_f64_u64(v294))));
              uint32x2_t v296 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v295);
              if ((vpmax_u32(v296, v296).u32[0] & 0x80000000) != 0
                || (int32x2_t v297 = vcvt_s32_f32(*(float32x2_t *)&v692[0].f64[0]),
                    int32x2_t v298 = vadd_s32(v295, v297),
                    *(int32x2_t *)&long long v299 = vmax_s32(v297, 0),
                    int32x2_t v300 = vsub_s32(vmin_s32(*(int32x2_t *)((char *)&v608 + 8), v298), *(int32x2_t *)&v299),
                    uint32x2_t v301 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v300),
                    (vpmax_u32(v301, v301).u32[0] & 0x80000000) != 0))
              {
                *(void *)&long long v299 = 0;
                *((void *)&v608 + 1) = 0;
              }
              else
              {
                *((int32x2_t *)&v299 + 1) = v300;
                long long v608 = v299;
              }
            }
            else
            {
              *(void *)&long long v299 = 0;
            }
            unsigned int type = v203->smpteTime.type;
            if (type)
            {
              unsigned int v303 = v203->smpteTime.flags;
              if (v303)
              {
                uint32x2_t v304 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v608 + 8));
                if ((vpmax_u32(v304, v304).u32[0] & 0x80000000) == 0)
                {
                  uint32x2_t v305 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)__PAIR64__(v303, type));
                  if ((vpmax_u32(v305, v305).u32[0] & 0x80000000) != 0
                    || (int32x2_t v306 = *(int32x2_t *)&v203->smpteTime.subframes,
                        int32x2_t v307 = vadd_s32(*(int32x2_t *)&v299, *(int32x2_t *)((char *)&v608 + 8)),
                        *(int32x2_t *)&long long v299 = vmax_s32(*(int32x2_t *)&v299, v306),
                        int32x2_t v308 = vsub_s32(vmin_s32(v307, vadd_s32(v306, (int32x2_t)__PAIR64__(v303, type))), *(int32x2_t *)&v299), v309 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v308), (vpmax_u32(v309, v309).u32[0] & 0x80000000) != 0))
                  {
                    *((void *)&v608 + 1) = 0;
                  }
                  else
                  {
                    *((int32x2_t *)&v299 + 1) = v308;
                    long long v608 = v299;
                  }
                }
              }
            }
            int v583 = v235;
            if (v269)
            {
              v310 = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v10 + 96) + 480))(*(void *)(v10 + 96), 1);
              v313 = (unsigned int *)CA::WindowServer::IOSurface::wrap_buffer(*(CA::WindowServer::IOSurface **)(v10 + 96), (IOSurfaceRef)v589, 0, 0);
              unsigned int v316 = v203->videoRefreshPeriod;
              unsigned int videoRefreshPeriod_high = HIDWORD(v203->videoRefreshPeriod);
              if (v316) {
                BOOL v318 = videoRefreshPeriod_high == 0;
              }
              else {
                BOOL v318 = 1;
              }
              int v319 = !v318;
              LODWORD(v314) = v310[14];
              LODWORD(v315) = v310[15];
              v320.f64[0] = (double)v314;
              double v321 = (double)v315;
              float64x2_t v682 = 0uLL;
              *(float64_t *)v683 = v320.f64[0];
              *(double *)&v683[8] = v321;
              double v322 = 0.0;
              double v323 = 0.0;
              if (!v318)
              {
                LODWORD(v320.f64[0]) = LODWORD(v203->rateScalar);
                LODWORD(v321) = HIDWORD(v203->rateScalar);
                double v323 = (double)*(unint64_t *)&v320.f64[0];
                double v322 = (double)*(unint64_t *)&v321;
                v320.f64[0] = (double)v316;
                double v321 = (double)videoRefreshPeriod_high;
                v682.f64[0] = v323;
                v682.f64[1] = v322;
                *(double *)v683 = (double)v316;
                *(double *)&v683[8] = (double)videoRefreshPeriod_high;
              }
              unsigned int v324 = v203->smpteTime.type;
              unsigned int v325 = v203->smpteTime.flags;
              if (v324) {
                BOOL v326 = v325 == 0;
              }
              else {
                BOOL v326 = 1;
              }
              int v327 = !v326;
              if (v326) {
                goto LABEL_534;
              }
              *(double *)v599.i64 = v201;
              unsigned int v328 = *(_DWORD *)&v203->smpteTime.subframes;
              unsigned int counter = v203->smpteTime.counter;
              double v330 = (double)v324;
              double v331 = (double)v325;
              v692[0] = (float64x2_t)v616;
              v692[1] = v617;
              v692[2] = v618;
              long long v693 = v619;
              long long v694 = v620;
              long long v695 = v621;
              long long v696 = v622;
              long long v697 = v623;
              float64x2_t v698 = v624;
              uint64_t v699 = v625 & 0x1F;
              CA::Transform::invert((int8x16_t *)v692, v311, v312);
              *(float *)v671.f64 = (float)v328;
              *((float *)v671.f64 + 1) = (float)counter;
              *(float *)&unsigned int v332 = (double)v328 + v330;
              *(float *)&unsigned int v333 = (double)counter + v331;
              *(void *)&v612[0].f64[0] = __PAIR64__(v333, v332);
              CA::Transform::apply_to_point2(v692, v671.f64, v334);
              CA::Transform::apply_to_point2(v692, v612[0].f64, v335);
              float64x2_t v320 = *(float64x2_t *)v683;
              int64x2_t v336 = vclezq_f64(*(float64x2_t *)v683);
              if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v336, 1), (int8x16_t)v336).u64[0] & 0x8000000000000000) != 0)
              {
                uint64_t v24 = v584;
              }
              else
              {
                int32x2_t v337 = vceqz_f32(vsub_f32(*(float32x2_t *)&v671.f64[0], *(float32x2_t *)&v612[0].f64[0]));
                v338.i64[0] = v337.i32[0];
                v338.i64[1] = v337.i32[1];
                uint64_t v24 = v584;
                if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v338, 1), (int8x16_t)v338).u64[0] & 0x8000000000000000) == 0)
                {
                  float64x2_t v339 = vcvtq_f64_f32(*(float32x2_t *)&v671.f64[0]);
                  float64x2_t v340 = vmaxnmq_f64(v682, v339);
                  float64x2_t v320 = vsubq_f64(vminnmq_f64(vaddq_f64(v682, *(float64x2_t *)v683), vaddq_f64(v339, vcvtq_f64_f32(vabd_f32(*(float32x2_t *)&v671.f64[0], *(float32x2_t *)&v612[0].f64[0])))), v340);
                  int64x2_t v341 = vclezq_f64(v320);
                  double v201 = *(double *)v599.i64;
                  double v207 = 1.0;
                  float v208 = 1.0;
                  double v209 = 0.5;
                  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v341, 1), (int8x16_t)v341).u64[0] & 0x8000000000000000) != 0)
                  {
                    double v322 = v682.f64[1];
                    v424 = v568;
                    *v568 = 0;
                    v424[1] = 0;
                    float64x2_t v320 = 0uLL;
                  }
                  else
                  {
                    float64x2_t v682 = v340;
                    *(float64x2_t *)v683 = v320;
                    double v322 = v340.f64[1];
                  }
LABEL_533:
                  double v323 = v682.f64[0];
                  double v321 = v320.f64[1];
LABEL_534:
                  v692[0].f64[0] = v323;
                  v692[0].f64[1] = v322;
                  v692[1].f64[0] = v320.f64[0];
                  v692[1].f64[1] = v321;
                  if (v597)
                  {
                    *(float *)&unsigned int v390 = v323;
                    *(float *)&unsigned int v391 = v322;
                    *(void *)&v671.f64[0] = __PAIR64__(v391, v390);
                    *(float *)&unsigned int v392 = v320.f64[0] + v323;
                    *(float *)&unsigned int v393 = v321 + v322;
                    *(void *)&v612[0].f64[0] = __PAIR64__(v393, v392);
                    CA::Transform::apply_to_point2((float64x2_t *)&v616, v671.f64, (float *)v312);
                    CA::Transform::apply_to_point2((float64x2_t *)&v616, v612[0].f64, v394);
                    v692[0] = vcvtq_f64_f32(*(float32x2_t *)&v671.f64[0]);
                    v692[1] = vcvtq_f64_f32(vabd_f32(*(float32x2_t *)&v671.f64[0], *(float32x2_t *)&v612[0].f64[0]));
                    int v395 = 1;
                  }
                  else
                  {
                    int v395 = v319 | v327;
                  }
                  uint64_t v396 = (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 1800))(*(void *)(v10 + 96));
                  if (!v396) {
                    uint64_t v396 = CAGetColorSpace(0x1Du);
                  }
                  if ((*(unsigned int (**)(double, void))(**(void **)&v585 + 616))(COERCE_DOUBLE(*(void *)&v585), v313[16]))
                  {
                    if (v396 == *(void *)(v212 + 264)) {
                      goto LABEL_544;
                    }
                    char v397 = CGColorSpaceEqualToColorSpaceIgnoringRange();
                    if (!v395 || (v397 & 1) != 0)
                    {
                      if (v397)
                      {
LABEL_544:
                        double v398 = v585;
                        uint64_t v399 = (*(uint64_t (**)(double, _DWORD *, void))(**(void **)&v585 + 928))(COERCE_DOUBLE(*(void *)&v585), v310, 0);
                        uint64_t v400 = (*(uint64_t (**)(double, unsigned int *, uint64_t))(**(void **)&v398 + 928))(COERCE_DOUBLE(*(void *)&v398), v313, 1);
                        (*(void (**)(double, uint64_t, uint64_t, uint64_t, void, float64x2_t *, float64x2_t *))(**(void **)&v398 + 720))(COERCE_DOUBLE(*(void *)&v398), v400, v399, 1, 0, v692, &v682);
                        (*(void (**)(double, void))(**(void **)&v398 + 408))(COERCE_DOUBLE(*(void *)&v398), 0);
                        goto LABEL_548;
                      }
LABEL_547:
                      v407 = (__IOSurface *)(*(uint64_t (**)(_DWORD *))(*(void *)v310 + 160))(v310);
                      v408 = (__IOSurface *)(*(uint64_t (**)(unsigned int *))(*(void *)v313 + 160))(v313);
                      CA::VideoToolbox::copy_surface(*(OpaqueVTPixelTransferSession ***)(v212 + 272), v407, v408);
LABEL_548:
                      CA::WindowServer::Surface::unref((CA::WindowServer::Surface *)v313);
                      int v371 = 1;
LABEL_549:
                      uint64_t v684 = 0;
                      *(void *)&v682.f64[0] = v590;
                      int v409 = *(_DWORD *)(v212 + 396);
                      LODWORD(v682.f64[1]) = v371 ^ 1;
                      HIDWORD(v682.f64[1]) = v409;
                      LOBYTE(v684) = 1;
                      float v410 = v595.f64[0];
                      float v411 = v595.f64[1];
                      *(float *)v683 = v410;
                      *(float *)&v683[4] = v411;
                      *(float32x2_t *)&v671.f64[0] = vcvt_f32_s32(*(int32x2_t *)v598.i8);
                      CA::Transform::apply_to_point2((float64x2_t *)&v616, v671.f64, v388);
                      *(int32x2_t *)v412.i8 = vcvt_s32_f32(*(float32x2_t *)&v671.f64[0]);
                      int64x2_t v413 = vcvtq_s64_f64(vmulq_f64(v595, vcvtq_f64_s64(v581)));
                      int32x2_t v414 = vmovn_s64(v413);
                      uint32x2_t v415 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v414);
                      if ((vpmax_u32(v415, v415).u32[0] & 0x80000000) != 0)
                      {
                        int32x4_t v412 = vmovn_hight_s64(*(int32x2_t *)v412.i8, v413);
                        int v228 = v583;
                      }
                      else
                      {
                        uint32x2_t v416 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v608 + 8));
                        int v228 = v583;
                        if ((vpmax_u32(v416, v416).u32[0] & 0x80000000) != 0
                          || (int32x2_t v417 = vadd_s32(v414, *(int32x2_t *)v412.i8),
                              *(int32x2_t *)v418.i8 = vmax_s32(*(int32x2_t *)v412.i8, *(int32x2_t *)&v608),
                              int32x2_t v419 = vsub_s32(vmin_s32(v417, vadd_s32(*(int32x2_t *)&v608, *(int32x2_t *)((char *)&v608 + 8))), *(int32x2_t *)v418.i8), v420 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v419), (vpmax_u32(v420, v420).u32[0] & 0x80000000) != 0))
                        {
                          v412.i64[1] = 0;
                        }
                        else
                        {
                          v418.u64[1] = (unint64_t)v419;
                          int32x4_t v412 = v418;
                        }
                      }
                      *(float32x4_t *)&v683[8] = vcvtq_f32_s32(v412);
                      int v229 = v647;
                      v226 = &v682;
                      uint64_t v227 = v212;
                      goto LABEL_556;
                    }
                  }
                  else if (!v395)
                  {
                    goto LABEL_547;
                  }
                  v401 = CA::WindowServer::IOSurface::wrap_buffer(*(CA::WindowServer::IOSurface **)(v10 + 96), (IOSurfaceRef)v609, 0, 0);
                  double v402 = v585;
                  uint64_t v403 = (*(uint64_t (**)(double, _DWORD *, void))(**(void **)&v585 + 928))(COERCE_DOUBLE(*(void *)&v585), v310, 0);
                  uint64_t v404 = (*(uint64_t (**)(double, float *, uint64_t))(**(void **)&v402 + 928))(COERCE_DOUBLE(*(void *)&v402), v401, 1);
                  (*(void (**)(double, uint64_t, uint64_t, uint64_t, void, float64x2_t *, float64x2_t *))(**(void **)&v402 + 720))(COERCE_DOUBLE(*(void *)&v402), v404, v403, 1, 0, v692, &v682);
                  (*(void (**)(double, void))(**(void **)&v402 + 408))(COERCE_DOUBLE(*(void *)&v402), 0);
                  v405 = (__IOSurface *)(*(uint64_t (**)(float *))(*(void *)v401 + 160))(v401);
                  v406 = (__IOSurface *)(*(uint64_t (**)(unsigned int *))(*(void *)v313 + 160))(v313);
                  CA::VideoToolbox::copy_surface(*(OpaqueVTPixelTransferSession ***)(v212 + 272), v405, v406);
                  CA::WindowServer::Surface::unref((CA::WindowServer::Surface *)v401);
                  goto LABEL_548;
                }
                v389 = v568;
                *v568 = 0;
                v389[1] = 0;
                float64x2_t v320 = 0uLL;
              }
              double v201 = *(double *)v599.i64;
              double v207 = 1.0;
              float v208 = 1.0;
              double v209 = 0.5;
              goto LABEL_533;
            }
            bzero(&v682, 0x448uLL);
            CA::Render::Update::Update((CA::Render::Update *)&v682, v692, 0x2000uLL, v201, 0, 0, 0, 0, (const CA::Bounds *)&v608, 0);
            v342 = (unsigned int *)v576;
            unint64_t v343 = (*v342 | ((unint64_t)*((unsigned __int16 *)v342 + 2) << 32)) & 0xFFFDFFEF7F7BLL | 0x200008004;
            *(_DWORD *)long long v576 = *(_DWORD *)v576 & 0xFFEF7F7B | 0x8004;
            *((_WORD *)v342 + 2) = WORD2(v343);
            uint64_t v688 = (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 1400))();
            int v344 = (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 1584))();
            int v345 = 512;
            if (!v344) {
              int v345 = 0;
            }
            unint64_t v346 = *v342 & 0xFFFFFDFF | ((unint64_t)*((unsigned __int16 *)v342 + 2) << 32);
            unsigned int *v342 = *v342 & 0xFFFFFDFF | v345;
            *((_WORD *)v342 + 2) = WORD2(v346);
            if (CADeviceNeedsP3ShapeTracking::once != -1) {
              dispatch_once(&CADeviceNeedsP3ShapeTracking::once, &__block_literal_global_59);
            }
            v347 = v577;
            uint64_t v348 = v576;
            uint64_t v349 = *(unsigned int *)v576;
            unint64_t v350 = v349 & 0xFFFFFFFFFEFFFFFFLL | ((unint64_t)*(unsigned __int16 *)(v576 + 4) << 32);
            *(_DWORD *)long long v576 = v349 & 0xFEFFFFFF | (CADeviceNeedsP3ShapeTracking::p3_tracking << 24);
            *(_WORD *)(v348 + 4) = WORD2(v350);
            memset(v681, 0, sizeof(v681));
            CA::WindowServer::Display::reconciled_display_attributes((CA::WindowServer::Display *)v681, *(void *)(v10 + 96));
            CA::Render::Update::set_display_attributes((uint64_t)&v682, v681);
            int v690 = v654;
            uint64_t v615 = 0;
            v354 = *(unsigned int **)&v203[1].smpteTime.hours;
            v353 = (unsigned int *)v203[1].flags;
            *(_OWORD *)v347 = 0u;
            *((_OWORD *)v347 + 1) = 0u;
            LODWORD(v615) = 1065353216;
            v613 = &unk_1ED023CF8;
            uint64_t v355 = ((char *)v353 - (char *)v354) & 0x3FFFFFFFCLL;
            if (v355)
            {
              do
              {
                unsigned int v356 = *v354++;
                std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)v347, v356, v356);
                v355 -= 4;
              }
              while (v355);
              v354 = *(unsigned int **)&v203[1].smpteTime.hours;
              v353 = (unsigned int *)v203[1].flags;
            }
            if (v353 != v354) {
              v689 = &v613;
            }
            v357 = (unsigned int *)v203->reserved;
            v358 = *(unsigned int **)&v203[1].version;
            if (v357 == v358)
            {
              int v359 = 0;
            }
            else
            {
              int v359 = 0;
              do
              {
                uint64_t v360 = CA::Render::Context::context_by_id((CA::Render::Context *)*v357);
                if (v360)
                {
                  v361 = (atomic_uint *)v360;
                  v362 = (pthread_mutex_t *)(v360 + 72);
                  pthread_mutex_lock((pthread_mutex_t *)(v360 + 72));
                  v363 = 0;
                  uint64_t v680 = 0;
                  float64x2_t v679 = 0u;
                  long long v678 = 0u;
                  long long v677 = 0u;
                  long long v676 = 0u;
                  long long v675 = 0u;
                  long long v674 = 0u;
                  float64x2_t v673 = 0u;
                  float64x2_t v672 = 0u;
                  float64x2_t v671 = 0u;
                  if (v597)
                  {
                    uint64_t v364 = CA::Render::Context::root_layer_handle((CA::Render::Context *)v361);
                    if (v364 && *(void *)(v364 + 16))
                    {
                      memset(v607, 0, sizeof(v607));
                      uint64_t v365 = CA::Render::Context::root_layer_handle((CA::Render::Context *)v361);
                      if (v365) {
                        uint64_t v365 = *(void *)(v365 + 16);
                      }
                      CA::Render::Layer::compute_frame_transform(v365, 0, (CA::Mat4Impl *)v607, 0);
                      float64x2_t v671 = (float64x2_t)v616;
                      float64x2_t v672 = v617;
                      float64x2_t v673 = v618;
                      long long v674 = v619;
                      long long v675 = v620;
                      long long v676 = v621;
                      long long v677 = v622;
                      long long v678 = v623;
                      float64x2_t v679 = v624;
                      LOBYTE(v68CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v680 & 0xE0 | v625 & 0x1F;
                      CA::Transform::set((uint64_t)v612, (CA::Mat4Impl *)v607, 1);
                      v363 = (const CA::Transform *)&v671;
                      CA::Transform::concat_left((CA::Transform *)&v671, v612, v366, v367);
                    }
                    else
                    {
                      v363 = (const CA::Transform *)&v671;
                    }
                  }
                  uint64_t v368 = CA::Render::Context::root_layer_handle((CA::Render::Context *)v361);
                  if (v368) {
                    v369 = *(CA::Render::Layer **)(v368 + 16);
                  }
                  else {
                    v369 = 0;
                  }
                  CA::Render::Update::add_context((CA::Render::Update *)&v682, (CA::Render::Context *)v361, v369, v363);
                  pthread_mutex_unlock(v362);
                  ++v359;
                  if (atomic_fetch_add(v361 + 2, 0xFFFFFFFF) == 1) {
                    (*(void (**)(atomic_uint *))(*(void *)v361 + 16))(v361);
                  }
                }
                ++v357;
              }
              while (v357 != v358);
            }
            CA::Render::Update::added_all_contexts((uint64_t **)&v682, v351, v352);
            if (v359) {
              BOOL v370 = v610 == 0;
            }
            else {
              BOOL v370 = 1;
            }
            int v371 = !v370;
            if (v370)
            {
              CA::Render::ContentStream::reuse_surface((CA::Render::ContentStream *)v212, SLODWORD(v574));
              int v583 = 0;
              uint64_t v24 = v584;
            }
            else
            {
              int v372 = v587;
              int v373 = DWORD1(v587);
              v374 = (void *)MEMORY[0x185324A30]();
              double v375 = v585;
              *(void *)(*(void *)&v585 + 20CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
              *(_DWORD *)(*(void *)&v375 + 208) = v372;
              *(_DWORD *)(*(void *)&v375 + 212) = v373;
              *(_WORD *)(*(void *)&v375 + 832) |= 2u;
              v376 = CGColorSpaceRetain(*(CGColorSpaceRef *)(*(void *)&v375 + 144));
              v377 = (CGColorSpace *)CAGetColorSpace(0x1Cu);
              CA::OGL::Context::set_colorspace(*(CA::OGL::Context **)&v375, v377);
              CGColorSpaceRelease(v377);
              float64x2_t v673 = 0u;
              float64x2_t v672 = 0u;
              float64x2_t v671 = 0u;
              CA::Shape::operator=((uint64_t)&v671, &v608);
              CA::shape_union(v568, (CA::Shape **)&v671, v378);
              v379 = v579;
              CA::OGL::Renderer::prepare_clip_shape(v579, *(const CA::Render::Update **)v683);
              __n128 v380 = ((__n128 (*)(void, void, CA::Shape **, uint64_t, void, void))*(void *)(**(void **)&v375 + 24))(*(void *)&v375, 0, v564, 1, 0, 0);
              v380.n128_u32[0] = *(_DWORD *)&v203->smpteTime.hours;
              float16x4_t v606 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8((uint8x8_t)v380.n128_u64[0]))), (float32x4_t)vdupq_n_s32(0x3B808081u)));
              (*(void (**)(double, void *, float16x4_t *))(**(void **)&v375 + 912))(COERCE_DOUBLE(*(void *)&v375), &CA::Shape::_infinite_shape, &v606);
              CA::OGL::Renderer::render(v379, (const CA::Render::Update *)&v682, 0, v381);
              (*(void (**)(double, uint64_t))(**(void **)&v375 + 408))(COERCE_DOUBLE(*(void *)&v375), 1);
              CA::OGL::Context::set_colorspace(*(CA::OGL::Context **)&v375, v376);
              CGColorSpaceRelease(v376);
              (*(void (**)(double, void, void, void, void, void))(**(void **)&v375 + 24))(COERCE_DOUBLE(*(void *)&v375), 0, 0, 0, 0, 0);
              *(_WORD *)(*(void *)&v375 + 832) &= ~2u;
              v382 = (CA::Shape *)*((void *)v379 + 2);
              uint64_t v24 = v584;
              if (v382)
              {
                CA::Shape::unref(v382);
                v379 = v579;
                *((void *)v579 + 2) = 0;
              }
              uint64_t v383 = v685;
              v384 = *(void **)v379;
              int v385 = v687;
              *((_DWORD *)v384 + 57) = v686;
              *((_DWORD *)v384 + 58) = v385;
              CA::Render::Update::release_objects(&v682);
              v386 = *(void **)v379;
              v386[30] = v383;
              (*(void (**)(void *, void))(*v386 + 216))(v386, 0);
              CA::VideoToolbox::copy_surface(*(OpaqueVTPixelTransferSession ***)(v212 + 272), (__IOSurface *)v609, (__IOSurface *)v589);
            }
            v613 = &unk_1ED023D78;
            std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v577);
            CA::Render::Update::~Update((CA::Render::Update *)&v682, v387);
            goto LABEL_549;
          }
        }
LABEL_572:
        uint64_t v158 = v586;
      }
      if (v596)
      {
        uint64_t v427 = mach_absolute_time();
        uint64_t v428 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 48))(v10) + v427;
        goto LABEL_579;
      }
      int v429 = (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 1040))(*(void *)(v10 + 96));
      v430 = *(_DWORD **)(v10 + 96);
      if (v429)
      {
        double v431 = (*(double (**)(_DWORD *))(*(void *)v430 + 760))(v430);
        unint64_t v432 = CAHostTimeWithTime(v431);
        uint64_t v428 = CAHostTimeWithTime(v8) - (v432 >> 3);
        goto LABEL_579;
      }
      if ((v430[156] & 0x100) != 0)
      {
        double v433 = (*(double (**)(_DWORD *))(*(void *)v430 + 760))(v430);
        unint64_t v434 = CAHostTimeWithTime(v433);
        unint64_t v435 = v434 * (*(unsigned int (**)(void))(**(void **)(v10 + 96) + 768))();
        unint64_t v436 = CAHostTimeWithTime(v8);
        uint64_t v428 = v436 - (v435 + (v434 >> 1)) + (*(uint64_t (**)(uint64_t))(*(void *)v10 + 48))(v10);
LABEL_579:
        (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 488))(v10, v428);
      }
      uint64_t v437 = mach_absolute_time();
      double v656 = CATimeWithHostTime(v437) - v141;
      if (*(unsigned char *)(v10 + 524))
      {
        v438 = v664;
        if (v664)
        {
          v439 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          v440 = v439;
          v441 = *(const void **)(v10 + 104);
          if (v441) {
            CFDictionarySetValue(v439, @"display_name", v441);
          }
          long long v693 = 0u;
          memset(v692, 0, sizeof(v692));
          if ((*(unsigned int (**)(void))(**(void **)(v10 + 96) + 800))())
          {
            CFStringRef v442 = CFStringCreateWithCString(0, (const char *)v692, 0x8000100u);
            if (v442)
            {
              CFStringRef v443 = v442;
              CFDictionarySetValue(v440, @"display_uuid", v442);
              CFRelease(v443);
            }
          }
          unint64_t v444 = CAHostTimeWithTime(v662);
          CA_CFDictionarySetLongLong(v440, @"presentation_host_time", v444);
          if (*(double *)&time_scale == 0.0 && time_scale_once[0] != -1) {
            dispatch_once_f(time_scale_once, 0, (dispatch_function_t)initialize_time_scale);
          }
          v599.i64[0] = (uint64_t)v440;
          CA_CFDictionarySetLongLong(v440, @"presentation_ntp_time", (((unint64_t)(v444% (1000000000* (unint64_t)timebase/ timebase)) << 32)/ (1000000000* (unint64_t)timebase/ timebase)) | ((v444/ (1000000000* (unint64_t)timebase/ timebase)) << 32));
          v445 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
          v446 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
          v447 = (const void *)*MEMORY[0x1E4F1CFD0];
          v448 = (const void *)*MEMORY[0x1E4F1CFC8];
          do
          {
            v449 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            v450 = v449;
            v451 = (const void *)*((void *)v438 + 1);
            if (v451) {
              CFDictionarySetValue(v449, @"identifier", v451);
            }
            v452 = CFArrayCreateMutable(0, 0, v445);
            CA_CFArrayAppendDouble(v452, v438[2]);
            CA_CFArrayAppendDouble(v452, v438[3]);
            CA_CFArrayAppendDouble(v452, v438[4]);
            CA_CFArrayAppendDouble(v452, v438[5]);
            CFDictionarySetValue(v450, @"bounds", v452);
            CFRelease(v452);
            v453 = CFArrayCreateMutable(0, 0, v445);
            for (uint64_t i = 6; i != 22; ++i)
              CA_CFArrayAppendDouble(v453, v438[i]);
            CFDictionarySetValue(v450, @"transform", v453);
            CFRelease(v453);
            CA_CFDictionarySetDouble(v450, @"corner_radius", v438[22]);
            if (*((unsigned char *)v438 + 192)) {
              v455 = v447;
            }
            else {
              v455 = v448;
            }
            CFDictionarySetValue(v450, @"continuous_corners", v455);
            CA_CFDictionarySetDouble(v450, @"opacity", *((float *)v438 + 47));
            CA_CFDictionarySetDouble(v450, @"cumulative_opacity", *((float *)v438 + 46));
            CFArrayAppendValue(v446, v450);
            CFRelease(v450);
            v438 = *(double **)v438;
          }
          while (v438);
          v456 = (const void *)v599.i64[0];
          CFDictionarySetValue((CFMutableDictionaryRef)v599.i64[0], @"regions", v446);
          CFRelease(v446);
          [*(id *)(v10 + 472) sendLayerProperties:v456];
          CFRelease(v456);
          uint64_t v24 = v584;
          uint64_t v158 = v586;
        }
      }
      if ((*(unsigned int (**)(void))(**(void **)(v10 + 96) + 1616))(*(void *)(v10 + 96))) {
        dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v10 + 88));
      }
      goto LABEL_600;
    }
    float v149 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 392))(v10);
    if (v149) {
      (*(void (**)(void, float64_t))(*(void *)*v149 + 160))(*v149, COERCE_FLOAT64_T(*(void *)&v569));
    }
    if ((*(_DWORD *)(*(void *)(v10 + 96) + 624) & 0x100) != 0)
    {
      if (CADeviceSupportsNextSwapAnnouncement::once[0] != -1) {
        dispatch_once(CADeviceSupportsNextSwapAnnouncement::once, &__block_literal_global_372);
      }
      if (CADeviceSupportsNextSwapAnnouncement::b) {
        (*(void (**)(void, uint64_t **, double))(**(void **)(v10 + 96) + 2160))(*(void *)(v10 + 96), v632, v147);
      }
    }
    (*(void (**)(uint64_t, uint64_t **, unsigned int *))(*(void *)v10 + 424))(v10, v632, &v602);
    uint64_t v150 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 392))(v10);
    if (v150)
    {
      float64x2_t v595 = *(float64x2_t *)(*(void *)v150 + 712);
      int32x4_t v571 = vuzp1q_s32((int32x4_t)v595, vrev64q_s32((int32x4_t)v595));
      (*(void (**)(void))(**(void **)(v10 + 96) + 1944))(*(void *)(v10 + 96));
      if (LODWORD(v595.f64[0])) {
        (*(void (**)(void, void))(**(void **)(v10 + 96) + 384))(*(void *)(v10 + 96), 0);
      }
      v566 = v568;
    }
    if ((v602 & 3) != 0) {
      uint64_t v151 = v594;
    }
    else {
      uint64_t v151 = 1;
    }
    uint64_t v594 = v151;
    if (((*(uint64_t (**)(void, uint64_t **))(**(void **)(v10 + 96) + 592))(*(void *)(v10 + 96), v632) & 1) != 0
      || v598.i32[0] < 1)
    {
      goto LABEL_291;
    }
    --v598.i32[0];
    if (v145) {
      CA::Shape::unref(v145);
    }
    char v48 = (CA::Shape **)CA::Shape::new_shape((unsigned int *)(*(void *)(v10 + 96) + 168));
    LODWORD(v595.f64[0]) = 0;
LABEL_255:
    v668 |= 0x40u;
    CA::Render::Fence::BatchWaitLock::invalidate((uint64_t)v611);
    CA::Render::Update::~Update((CA::Render::Update *)v632, v152);
    (*(void (**)(void, void))(**(void **)(v10 + 96) + 392))(*(void *)(v10 + 96), 0);
    uint64_t v597 = mach_absolute_time();
  }
  float v162 = (const CA::Shape *)v48;
  uint64_t v594 = v52;
  uint64_t v158 = v586;
  double v156 = v585;
LABEL_276:
  CA::WindowServer::Server::invalidate((os_unfair_lock_s *)v10, v162);
  int v163 = (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 216))(*(void *)(v10 + 96));
  if ((v163 | v565) == 1 && (v582 |= 0x1000000uLL, v156 >= v8))
  {
    v599.i64[0] = 0;
    if (v156 <= v8 || v8 == 0.0) {
      v158 |= 0x1000000uLL;
    }
    else {
      uint64_t v158 = 0x1000000;
    }
    int v164 = v594;
    double v156 = v8;
  }
  else
  {
    v599.i64[0] = 0;
    int v164 = v594;
  }
  *(void *)&long long v600 = v162;
LABEL_644:
  if (v567 && v594 >= 4u)
  {
    if (x_log_hook_p())
    {
      uint64_t v547 = v594;
      x_log_();
    }
    else
    {
      v480 = x_log_category_flipbook;
      if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v692[0].f64[0]) = 67109376;
        HIDWORD(v692[0].f64[0]) = v164;
        LOWORD(v692[0].f64[1]) = 1024;
        *(_DWORD *)((char *)&v692[0].f64[1] + 2) = v594;
        _os_log_impl(&dword_184668000, v480, OS_LOG_TYPE_DEFAULT, "non-detached render failed with can_update_status 0x%x, render_status 0x%x", (uint8_t *)v692, 0xEu);
      }
    }
  }
  if (v24)
  {
    v481 = v563;
    uint64_t v482 = v24;
    do
    {
      uint64_t v483 = *(void *)v481;
      if (atomic_fetch_add((atomic_uint *volatile)(*(void *)v481 + 8), 0xFFFFFFFF) == 1) {
        (*(void (**)(uint64_t))(*(void *)v483 + 16))(v483);
      }
      v481 += 8;
      --v482;
    }
    while (v482);
  }
  if (v554 > 0x1000) {
    free(v563);
  }
  (*(void (**)(uint64_t, void))(*(void *)v10 + 192))(v10, v567 | v565);
  if ((void)v600) {
    CA::Shape::unref((CA::Shape *)v600);
  }
  if (((*(uint64_t (**)(void))(**(void **)(v10 + 96) + 216))(*(void *)(v10 + 96)) & 1) == 0)
  {
    uint64_t v484 = *(void *)(v10 + 96);
    if ((*(_DWORD *)(v484 + 624) & 0x80) == 0 && (**(unsigned char **)(v484 + 728) & 0xFE) != 2) {
      (*(void (**)(uint64_t))(*(void *)v10 + 448))(v10);
    }
  }
  if (byte_1EB2ACBE0)
  {
    v582 |= 0x2000000000000000uLL;
    if (v156 >= v8)
    {
      if (v156 <= v8 || v8 == 0.0) {
        v158 |= 0x2000000000000000uLL;
      }
      else {
        uint64_t v158 = 0x2000000000000000;
      }
      double v156 = v8;
    }
  }
  if (v555)
  {
    double v485 = v8 + 0.1;
    uint64_t v486 = v582 | 0x40000;
    BOOL v487 = v156 >= v8 + 0.1 || v485 == 0.0;
    uint64_t v488 = v158 | 0x40000;
    if (!v487) {
      uint64_t v488 = 0x40000;
    }
    uint64_t v594 = 247;
    if (v156 <= v485) {
      double v489 = v8 + 0.1;
    }
    else {
      double v489 = v156;
    }
    if (v156 <= v485) {
      uint64_t v490 = v488;
    }
    else {
      uint64_t v490 = v158;
    }
  }
  else
  {
    uint64_t v491 = (*(uint64_t (**)(void))(**(void **)(v10 + 96) + 336))(*(void *)(v10 + 96));
    if (v156 <= v8 || v8 == 0.0) {
      uint64_t v493 = v158;
    }
    else {
      uint64_t v493 = 0;
    }
    uint64_t v494 = v491 | v493;
    if (v156 >= v8) {
      double v495 = v8;
    }
    else {
      double v495 = v156;
    }
    if (v156 < v8) {
      uint64_t v494 = v158;
    }
    if (v491) {
      double v489 = v495;
    }
    else {
      double v489 = v156;
    }
    if (v491) {
      uint64_t v490 = v494;
    }
    else {
      uint64_t v490 = v158;
    }
    if (v491) {
      uint64_t v486 = v491 | v582;
    }
    else {
      uint64_t v486 = v582;
    }
  }
  uint64_t v496 = *(void *)(*(void *)(v10 + 96) + 48);
  pthread_mutex_unlock(v558);
  *(double *)v601 = v489;
  v601[1] = v490;
  v601[2] = v486;
  (*(void (**)(uint64_t, void *, double))(*(void *)v10 + 184))(v10, v601, v8);
  BOOL v497 = v24 != v556 || v496 == 0;
  int v498 = v557;
  if (!v497) {
    int v498 = 1;
  }
  if (v498 == 1)
  {
    v692[0].f64[0] = 0.0;
    *(int64x2_t *)((char *)v692 + 8) = vdupq_n_s64(0x80000uLL);
    (*(void (**)(uint64_t, float64x2_t *, double))(*(void *)v496 + 184))(v496, v692, 0.0);
  }
  unint64_t v499 = v562;
  if (!BYTE6(ca_debug_options)) {
    goto LABEL_704;
  }
  v529 = (CA::Render *)x_log_begin();
  CA::Render::show_statistics(v529);
  v530 = (void **)x_stream_pop_(0);
  v531 = x_stream_get(v530);
  int v532 = 0;
  *(void *)&long long v533 = 136315650;
  long long v600 = v533;
  while (2)
  {
    uint64_t v534 = 0;
    v535 = &v531[v532];
    int v536 = -1;
    while (1)
    {
      if (v535[v534] == 10)
      {
        int v536 = v534;
        goto LABEL_792;
      }
      if (!v535[v534]) {
        break;
      }
LABEL_792:
      ++v534;
      unsigned int v537 = 32512;
      if (v534 == 32512) {
        goto LABEL_793;
      }
    }
    unsigned int v537 = v534;
LABEL_793:
    if (v536 <= -1 || v535[v537] == 0) {
      int v539 = v537;
    }
    else {
      int v539 = v536 + 1;
    }
    if (v539 > 0)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v540 = x_log_category_windowserver;
        if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v692[0].f64[0]) = v600;
          v541 = "continued...\n";
          if (!v532) {
            v541 = "";
          }
          *(void *)((char *)v692[0].f64 + 4) = v541;
          WORD2(v692[0].f64[1]) = 1040;
          *(_DWORD *)((char *)&v692[0].f64[1] + 6) = v539;
          WORD1(v692[1].f64[0]) = 2080;
          *(void *)((char *)v692[1].f64 + 4) = &v531[v532];
          _os_log_impl(&dword_184668000, v540, OS_LOG_TYPE_DEFAULT, "%s%.*s", (uint8_t *)v692, 0x1Cu);
        }
      }
      v532 += v539;
      continue;
    }
    break;
  }
  x_log_end_free_(v530);
  unint64_t v499 = v562;
LABEL_704:
  CA::Render::collect(0, v8);
  if (v561 + 1 >= 2 && os_signpost_enabled(v550))
  {
    if ((v594 + 22) > 0x19u) {
      int v544 = -1;
    }
    else {
      int v544 = dword_1849A7850[(v594 + 22)];
    }
    v545 = _MXSignpostMetricsSnapshot();
    LODWORD(v692[0].f64[0]) = 67240450;
    HIDWORD(v692[0].f64[0]) = v544;
    LOWORD(v692[0].f64[1]) = 2114;
    *(void *)((char *)&v692[0].f64[1] + 2) = v545;
    _os_signpost_emit_with_name_impl(&dword_184668000, v550, OS_SIGNPOST_INTERVAL_END, v561, "Rendering", "reason=%{public,name=reason}d\n%{public, signpost:metrics}@", (uint8_t *)v692, 0x12u);
    unint64_t v499 = v562;
  }
  uint64_t v500 = mach_continuous_time();
  v501 = &x_log_category_windowserver;
  if (v499 && v500 - *(void *)&v569 > v499)
  {
    if (CA::WindowServer::Server::server_stall_handle(void)::once_token != -1) {
      dispatch_once(&CA::WindowServer::Server::server_stall_handle(void)::once_token, &__block_literal_global_206_16481);
    }
    v501 = &CA::WindowServer::Server::server_stall_handle(void)::handle;
  }
  v502 = *v501;
  int v503 = v571.i32[0];
  if (v571.i32[0] == -1)
  {
    if ((_BYTE)v594)
    {
      if (v588 && os_signpost_enabled(v502))
      {
        if ((v594 + 22) > 0x19u) {
          v513 = "Unknown status";
        }
        else {
          v513 = off_1E527EDF8[(char)(v594 + 22)];
        }
        LODWORD(v692[0].f64[0]) = 134350082;
        *(void *)((char *)v692[0].f64 + 4) = v499;
        WORD2(v692[0].f64[1]) = 1026;
        *(_DWORD *)((char *)&v692[0].f64[1] + 6) = v552;
        WORD1(v692[1].f64[0]) = 2050;
        *(float64_t *)((char *)v692[1].f64 + 4) = v569;
        WORD2(v692[1].f64[1]) = 2082;
        *(void *)((char *)&v692[1].f64[1] + 6) = v513;
        HIWORD(v692[2].f64[0]) = 1026;
        LODWORD(v692[2].f64[1]) = v594;
        goto LABEL_756;
      }
    }
    else if (v588 && os_signpost_enabled(v502))
    {
      LODWORD(v692[0].f64[0]) = 134349568;
      *(void *)((char *)v692[0].f64 + 4) = v499;
      WORD2(v692[0].f64[1]) = 1026;
      *(_DWORD *)((char *)&v692[0].f64[1] + 6) = v552;
      WORD1(v692[1].f64[0]) = 2050;
      *(float64_t *)((char *)v692[1].f64 + 4) = v569;
      goto LABEL_756;
    }
  }
  else if ((_BYTE)v594)
  {
    if (v588 && os_signpost_enabled(v502))
    {
      if (v503 >= 0xFFFF) {
        int v504 = 0xFFFF;
      }
      else {
        int v504 = v503;
      }
      int v505 = v504 & ~(v504 >> 31);
      int v506 = v571.i32[1];
      if (v571.i32[1] >= 0xFFFF) {
        int v506 = 0xFFFF;
      }
      int v507 = v571.i32[2];
      int v508 = v506 & ~(v506 >> 31);
      if (v571.i32[2] >= 0xFFFF) {
        int v507 = 0xFFFF;
      }
      int v509 = v507 & ~(v507 >> 31);
      if (v571.i32[3] >= 0xFFFF) {
        int v510 = 0xFFFF;
      }
      else {
        int v510 = v571.i32[3];
      }
      int v511 = v510 & ~(v510 >> 31);
      if ((v594 + 22) > 0x19u) {
        v512 = "Unknown status";
      }
      else {
        v512 = off_1E527EDF8[(char)(v594 + 22)];
      }
      LODWORD(v692[0].f64[0]) = 134351362;
      *(void *)((char *)v692[0].f64 + 4) = v499;
      WORD2(v692[0].f64[1]) = 1026;
      *(_DWORD *)((char *)&v692[0].f64[1] + 6) = v552;
      WORD1(v692[1].f64[0]) = 2050;
      *(float64_t *)((char *)v692[1].f64 + 4) = v569;
      WORD2(v692[1].f64[1]) = 1026;
      *(_DWORD *)((char *)&v692[1].f64[1] + 6) = v505;
      WORD1(v692[2].f64[0]) = 1026;
      LOWORD(v692[2].f64[1]) = 1026;
      *(_DWORD *)((char *)&v692[2].f64[1] + 2) = v509;
      HIWORD(v692[2].f64[1]) = 1026;
      HIDWORD(v692[2].f64[0]) = v508;
      LODWORD(v693) = v511;
      WORD2(v693) = 2050;
      *(void *)((char *)&v693 + 6) = v566;
      HIWORD(v693) = 2082;
      *(void *)&long long v694 = v512;
      WORD4(v694) = 1026;
      *(_DWORD *)((char *)&v694 + 1CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v594;
      goto LABEL_756;
    }
  }
  else if (v588 && os_signpost_enabled(v502))
  {
    int v514 = v571.i32[1];
    int v515 = v571.i32[2];
    int v516 = v571.i32[3];
    if (v503 >= 0xFFFF) {
      int v517 = 0xFFFF;
    }
    else {
      int v517 = v503;
    }
    int v518 = v517 & ~(v517 >> 31);
    LODWORD(v692[0].f64[0]) = 134350848;
    if (v571.i32[1] >= 0xFFFF) {
      int v514 = 0xFFFF;
    }
    *(void *)((char *)v692[0].f64 + 4) = v499;
    WORD2(v692[0].f64[1]) = 1026;
    int v519 = v514 & ~(v514 >> 31);
    *(_DWORD *)((char *)&v692[0].f64[1] + 6) = v552;
    if (v571.i32[2] >= 0xFFFF) {
      int v515 = 0xFFFF;
    }
    WORD1(v692[1].f64[0]) = 2050;
    int v520 = v515 & ~(v515 >> 31);
    *(float64_t *)((char *)v692[1].f64 + 4) = v569;
    if (v571.i32[3] >= 0xFFFF) {
      int v516 = 0xFFFF;
    }
    WORD2(v692[1].f64[1]) = 1026;
    *(_DWORD *)((char *)&v692[1].f64[1] + 6) = v518;
    WORD1(v692[2].f64[0]) = 1026;
    LOWORD(v692[2].f64[1]) = 1026;
    *(_DWORD *)((char *)&v692[2].f64[1] + 2) = v520;
    HIWORD(v692[2].f64[1]) = 1026;
    HIDWORD(v692[2].f64[0]) = v519;
    LODWORD(v693) = v516 & ~(v516 >> 31);
    WORD2(v693) = 2050;
    *(void *)((char *)&v693 + 6) = v566;
LABEL_756:
    _os_signpost_emit_unreliably_with_name_impl();
  }
  kdebug_trace();
  uint64_t v14 = v559;
  uint64_t v11 = v560;
LABEL_758:
  qword_1E8F86538 += mach_absolute_time() - v14;
LABEL_759:
  v522 = pthread_getspecific(current_display_slot);
  if (v522 && *v522) {
    --*v522;
  }
}

void CA::WindowServer::get_context_logical_bounds(CA::WindowServer *this, CA::Render::Context *a2, int32x2_t *a3, CA::Bounds *a4, BOOL *a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!BYTE13(xmmword_1EB2ACBF0) && (*((unsigned char *)this + 13) & 0x80) != 0)
  {
    uint64_t v9 = CA::Render::Context::root_layer_handle(this);
    if (v9)
    {
      uint64_t v10 = *(void *)(v9 + 40);
      if (v10)
      {
        CA::Render::Layer::frame((CA::Render::Layer *)&v22, *(CA::Render::Layer **)(v10 + 32));
        double v11 = v23.f64[1];
        if (v23.f64[0] > v23.f64[1]) {
          double v11 = v23.f64[0];
        }
        if (v11 < 1073741820.0)
        {
          v14.f64[0] = NAN;
          v14.f64[1] = NAN;
          int8x16_t v15 = (int8x16_t)vnegq_f64(v14);
          __asm { FMOV            V4.2D, #0.5 }
          int32x2_t v12 = vmovn_s64(vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8(v15, _Q4, v22), (float64x2_t)v22)));
          int8x16_t v21 = (int8x16_t)vaddq_f64((float64x2_t)v22, v23);
          int32x2_t v13 = vsub_s32(vmovn_s64(vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8(v15, _Q4, v21), (float64x2_t)v21))), v12);
        }
        else
        {
          int32x2_t v12 = vdup_n_s32(0xE0000001);
          int32x2_t v13 = (int32x2_t)0xC0000000C0000000;
        }
        *a3 = v12;
        a3[1] = v13;
        *(unsigned char *)a2 = 1;
        if (*((unsigned char *)this + 14)) {
          *(unsigned char *)a4 = 1;
        }
      }
    }
  }
}

uint64_t CA::Render::Fence::BatchWaitLock::invalidate(uint64_t this)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  __swp(this + 8, (unsigned int *)(this + 8));
  if (((this + 8) & 1) == 0)
  {
    double v1 = (unint64_t *)this;
    pthread_mutex_lock(&CA::Render::Fence::_bwait_mutex);
    char v2 = pthread_self();
    v18[0] = 0;
    if (pthread_threadid_np(v2, v18)) {
      __assert_rtn("invalidate", "render-fence.cpp", 1947, "r == noErr");
    }
    unint64_t v3 = *v1;
    if (*v1 != v18[0]) {
      __assert_rtn("invalidate", "render-fence.cpp", 1948, "_tid == tid");
    }
    uint64_t v4 = CA::Render::Fence::_bwait_readers_by_tid;
    if (!CA::Render::Fence::_bwait_readers_by_tid) {
      __assert_rtn("invalidate", "render-fence.cpp", 1950, "_bwait_readers_by_tid != nullptr");
    }
    unint64_t v5 = std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>((void *)CA::Render::Fence::_bwait_readers_by_tid, *v1);
    if (!v5) {
      __assert_rtn("invalidate", "render-fence.cpp", 1952, "ri != _bwait_readers_by_tid->end ()");
    }
    int v6 = *((_DWORD *)v5 + 6);
    if (v6 == 1)
    {
      int8x8_t v7 = *(int8x8_t *)(v4 + 8);
      unint64_t v8 = v5[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v7) {
          v8 %= *(void *)&v7;
        }
      }
      else
      {
        v8 &= *(void *)&v7 - 1;
      }
      uint64_t v10 = *(void **)(*(void *)v4 + 8 * v8);
      do
      {
        double v11 = v10;
        uint64_t v10 = (void *)*v10;
      }
      while (v10 != v5);
      if (v11 == (void *)(v4 + 16)) {
        goto LABEL_26;
      }
      unint64_t v12 = v11[1];
      if (v9.u32[0] > 1uLL)
      {
        if (v12 >= *(void *)&v7) {
          v12 %= *(void *)&v7;
        }
      }
      else
      {
        v12 &= *(void *)&v7 - 1;
      }
      if (v12 != v8)
      {
LABEL_26:
        if (!*v5) {
          goto LABEL_27;
        }
        unint64_t v13 = *(void *)(*v5 + 8);
        if (v9.u32[0] > 1uLL)
        {
          if (v13 >= *(void *)&v7) {
            v13 %= *(void *)&v7;
          }
        }
        else
        {
          v13 &= *(void *)&v7 - 1;
        }
        if (v13 != v8) {
LABEL_27:
        }
          *(void *)(*(void *)v4 + 8 * v8) = 0;
      }
      uint64_t v14 = *v5;
      if (*v5)
      {
        unint64_t v15 = *(void *)(v14 + 8);
        if (v9.u32[0] > 1uLL)
        {
          if (v15 >= *(void *)&v7) {
            v15 %= *(void *)&v7;
          }
        }
        else
        {
          v15 &= *(void *)&v7 - 1;
        }
        if (v15 != v8)
        {
          *(void *)(*(void *)v4 + 8 * v15) = v11;
          uint64_t v14 = *v5;
        }
      }
      *double v11 = v14;
      *unint64_t v5 = 0;
      --*(void *)(v4 + 24);
      operator delete(v5);
      uint64_t v16 = CA::Render::Fence::_bwait_readers_by_tid;
      if (*(void *)(CA::Render::Fence::_bwait_readers_by_tid + 16)) {
        return pthread_mutex_unlock(&CA::Render::Fence::_bwait_mutex);
      }
      int v17 = *(void **)CA::Render::Fence::_bwait_readers_by_tid;
      *(void *)CA::Render::Fence::_bwait_readers_by_tid = 0;
      if (v17) {
        operator delete(v17);
      }
      MEMORY[0x185323DC0](v16, 0x10A0C408EF24B1CLL);
      CA::Render::Fence::_bwait_readers_by_tid = 0;
    }
    else
    {
      *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((float *)v4, v3, v1)+ 6) = v6 - 1;
      if (CA::Render::Fence::_bwait_readers_by_tid) {
        return pthread_mutex_unlock(&CA::Render::Fence::_bwait_mutex);
      }
    }
    if (CA::Render::Fence::_bwait_writer_pending) {
      pthread_cond_signal(&CA::Render::Fence::_bwait_cond_writer);
    }
    return pthread_mutex_unlock(&CA::Render::Fence::_bwait_mutex);
  }
  return this;
}

uint64_t CA::WindowServer::IOMFBDisplay::update_interval_complexity(uint64_t this, int a2, int a3, int a4, char a5)
{
  unint64_t v5 = *(unint64_t **)(this + 25536);
  if (v5)
  {
    unint64_t v6 = *v5;
    if (a2 >= 4095) {
      int v7 = 4095;
    }
    else {
      int v7 = a2;
    }
    unint64_t v8 = v6 & 0xFFFFFFFFFFFFF000 | v7 & ~(v7 >> 31);
    if ((a5 & 1) == 0) {
      unint64_t v8 = *v5;
    }
    if (a3 >= 4095) {
      int v9 = 4095;
    }
    else {
      int v9 = a3;
    }
    unint64_t v10 = v8 & 0xFFFFFFFFFF000FFFLL | ((unint64_t)(v9 & ~(v9 >> 31)) << 12);
    if ((a5 & 2) != 0) {
      unint64_t v8 = v10;
    }
    if (a4 >= 4095) {
      int v11 = 4095;
    }
    else {
      int v11 = a4;
    }
    unint64_t v12 = v8 & 0xFFFFFFF000FFFFFFLL | ((unint64_t)(v11 & ~(v11 >> 31)) << 24);
    if ((a5 & 4) != 0) {
      unint64_t v13 = v12;
    }
    else {
      unint64_t v13 = v8;
    }
    if (v13 != v6)
    {
      *unint64_t v5 = v13;
      this = v5[5];
      if (this)
      {
        work_interval_instance_set_complexity();
        unint64_t v14 = v5[5];
        return MEMORY[0x1F40CE920](v14);
      }
    }
  }
  return this;
}

void CARecordCurrentDisplay::CARecordCurrentDisplay(CARecordCurrentDisplay *this, int a2)
{
  *(_DWORD *)this = a2;
  if (CARecordCurrentDisplayPush::once != -1) {
    dispatch_once(&CARecordCurrentDisplayPush::once, &__block_literal_global_17891);
  }
  unint64_t v3 = pthread_getspecific(current_display_slot);
  if (!v3) {
    operator new();
  }
  uint64_t v4 = *v3;
  if (v4 <= 2) {
    v3[v4 + 1] = a2;
  }
  *unint64_t v3 = v4 + 1;
}

uint64_t CA::WindowServer::Display::needs_display_roi_shape_tracking(CA::WindowServer::Display *this)
{
  return 0;
}

uint64_t CA::WindowServer::AppleInternalDisplay::tracks_velocity(CA::WindowServer::AppleInternalDisplay *this)
{
  if (byte_1EB2ACC4F) {
    return 0;
  }
  else {
    return (*((_DWORD *)this + 156) >> 8) & 1;
  }
}

BOOL CA::WindowServer::IOMFBDisplay::needs_visible_shape_tracking(CA::WindowServer::IOMFBDisplay *this)
{
  char v2 = (pthread_mutex_t *)((char *)this + 25720);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
  unsigned int v3 = *((_DWORD *)this + 6427);
  if (!*((void *)this + 6 * v3 + 3225)) {
    goto LABEL_8;
  }
  if (CADeviceNeedsDisplayWorkarounds::once[0] != -1) {
    dispatch_once(CADeviceNeedsDisplayWorkarounds::once, &__block_literal_global_73);
  }
  if (!CADeviceNeedsDisplayWorkarounds::needs_workarounds)
  {
    uint64_t v5 = *((void *)this + 6 * v3 + 3224);
    if (v5)
    {
      BOOL v4 = (*(unsigned char *)(v5 + 132) & 4) == 0;
      goto LABEL_9;
    }
LABEL_8:
    BOOL v4 = 0;
    goto LABEL_9;
  }
  BOOL v4 = 1;
LABEL_9:
  pthread_mutex_unlock(v2);
  return v4;
}

uint64_t CA::WindowServer::IOMFBDisplay::composited_update(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned int *)this + 6483);
}

uint64_t CA::WindowServer::IOMFBDisplay::finished_update(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned int *)this + 6482);
}

double CA::WindowServer::IOMFBServer::low_latency_threshold(CA::WindowServer::IOMFBServer *this)
{
  return *((double *)this + 111);
}

double CA::WindowServer::IOMFBDisplay::dynamic_refresh_rate(CA::WindowServer::IOMFBDisplay *this)
{
  uint64_t v2 = *(void *)this;
  if ((*((_DWORD *)this + 156) & 0x100) != 0)
  {
    unsigned int v5 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(v2 + 136))(this);
    if (!v5) {
      unsigned int v5 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 784))(this);
    }
    return (*(double (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 760))(this) * (double)v5;
  }
  else
  {
    unsigned int v3 = *(void (**)(void))(v2 + 744);
    v3();
  }
  return result;
}

void *CA::WindowServer::IOMFBDisplay::begin_work_interval(void *this, double a2, double a3, uint64_t a4, int a5, int a6)
{
  if (this[3192])
  {
    int v11 = (unsigned int *)this;
    unint64_t v12 = (unsigned __int8 *)this + 28185;
    (*(void (**)(void *))(*this + 760))(this);
    int v14 = *v12;
    if ((v11[156] & 0x100) != 0) {
      int v14 = v12[3];
    }
    double v15 = a2 + v13 * -0.125;
    if (v14 && (a5 & 1) == 0)
    {
      double v16 = (*(double (**)(unsigned int *))(*(void *)v11 + 760))(v11);
      double v15 = v15 + v16 * (double)(*(unsigned int (**)(unsigned int *))(*(void *)v11 + 768))(v11);
    }
    double v17 = 0.001;
    if (a5) {
      double v17 = 0.0014;
    }
    double v18 = v15 - v17;
    if (v18 <= a3 + 0.0001) {
      double v18 = a3 + 0.0001;
    }
    unsigned int v19 = (uint64_t *)*((void *)v11 + 3192);
    v19[1] = a4;
    this = (void *)CAHostTimeWithTime(v18);
    v19[2] = (uint64_t)this;
    unsigned int v20 = v11[6];
    if (v20 >= 9) {
      LOBYTE(v2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 9;
    }
    uint64_t *v19 = (((1 << (v20 - 1)) & 0x1FFLL) << 49) | a6;
    if (v19[5])
    {
      mach_absolute_time();
      work_interval_instance_clear();
      work_interval_instance_set_start();
      work_interval_instance_set_deadline();
      work_interval_instance_set_complexity();
      work_interval_instance_start();
      return (void *)kdebug_trace();
    }
  }
  return this;
}

double CA::WindowServer::IOMFBDisplay::secure_indicator_animating_deadline(CA::WindowServer::IOMFBDisplay *this)
{
  return *((double *)this + 3317);
}

uint64_t CA::WindowServer::IOMFBServer::allows_edr(CA::WindowServer::IOMFBServer *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 12) + 872))();
}

void CA::WindowServer::IOMFBDisplay::update_server_source_frame_interval_range(os_unfair_lock_s *this, const CAFrameIntervalRange *a2, int a3, int a4)
{
  unint64_t v6 = this + 6856;
  int v7 = this[6856]._os_unfair_lock_opaque != a2->var0
    || this[6857]._os_unfair_lock_opaque != a2->var1
    || this[6858]._os_unfair_lock_opaque != a2->var2;
  int v8 = BYTE2(this[7053]._os_unfair_lock_opaque);
  int os_unfair_lock_opaque_high = HIBYTE(this[7053]._os_unfair_lock_opaque);
  if ((v7 & 1) != 0 || (v8 == a3 ? (BOOL v10 = os_unfair_lock_opaque_high == a4) : (BOOL v10 = 0), !v10))
  {
    if (((os_unfair_lock_opaque_high == a4) & ~v7) == 0)
    {
      uint64_t v11 = *(void *)&a2->var0;
      this[6858]._uint64_t os_unfair_lock_opaque = a2->var2;
      *(void *)&v6->_uint64_t os_unfair_lock_opaque = v11;
      HIBYTE(this[7053]._os_unfair_lock_opaque) = a4;
      BOOL v12 = a4 == 0;
      if (a4) {
        unsigned int var0 = 2;
      }
      else {
        unsigned int var0 = a2->var0;
      }
      if (a4) {
        unsigned int var1 = 2;
      }
      else {
        unsigned int var1 = a2->var1;
      }
      if (v12) {
        unsigned int var2 = a2->var2;
      }
      else {
        unsigned int var2 = 2;
      }
      CA::WindowServer::IOMFBDisplay::register_frame_interval_range(this, 0, var0, var1, var2, a3);
    }
    if (v8 != a3)
    {
      BYTE2(v6[197]._os_unfair_lock_opaque) = a3;
      os_unfair_lock_lock(this + 6849);
      CA::WindowServer::IOMFBDisplay::recompute_server_frame_interval_locked((CA::WindowServer::IOMFBDisplay *)this, v16, v17, v18, v19, v20, v21, v22);
      os_unfair_lock_unlock(this + 6849);
    }
  }
}

BOOL CA::Render::Chromaticity::operator==(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32)
      && *(float *)(a1 + 16) == *(float *)(a2 + 16)
      && *(float *)(a1 + 20) == *(float *)(a2 + 20)
      && *(float *)(a1 + 8) == *(float *)(a2 + 8)
      && *(float *)(a1 + 12) == *(float *)(a2 + 12)
      && *(float *)a1 == *(float *)a2
      && *(float *)(a1 + 4) == *(float *)(a2 + 4)
      && *(float *)(a1 + 24) == *(float *)(a2 + 24)
      && *(float *)(a1 + 28) == *(float *)(a2 + 28);
}

BOOL CA::WindowServer::IOMFBDisplay::ignore_update_p(CA::WindowServer::IOMFBDisplay *this, const CA::Render::Update *a2)
{
  if ((*((unsigned char *)this + 643) & 0x10) == 0) {
    return 0;
  }
  BOOL v3 = (*((_DWORD *)a2 + 67) & 0xA) != 0;
  int v4 = *((unsigned __int8 *)this + 28166);
  BOOL v5 = (v4 | *((_DWORD *)a2 + 67) & 0xA) != 0;
  *((unsigned char *)this + 28166) = v4 | v3;
  uint64_t v6 = *((void *)this + 91);
  if (*(unsigned char *)(v6 + 3) == 1 && *(unsigned char *)(v6 + 2) == 0) {
    BOOL v5 = v3;
  }
  return !v5;
}

BOOL CA::WindowServer::IOMFBDisplay::detached_edr_layers_valid_p(CA::WindowServer::IOMFBDisplay *this, const CA::Render::Update *a2)
{
  uint64_t v2 = *((void *)this + 3255);
  if (!v2
    || !*(void *)(v2 + 16)
    || ((*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, const CA::Render::Update *))(*(void *)this
                                                                                                + 1536))(this, a2) & 1) != 0)
  {
    return 1;
  }
  float v5 = (*(float (**)(void))(**(void **)(*((void *)this + 3255) + 16) + 192))(*(void *)(*((void *)this + 3255) + 16));
  float v6 = 1.0 / CA::WindowServer::Display::edr_headroom(this);
  if (v5 == 0.0) {
    float v7 = 1.0;
  }
  else {
    float v7 = v5;
  }
  if (v6 == 0.0) {
    float v6 = 1.0;
  }
  return (float)(vabds_f32(v7, v6) / v7) <= 0.05;
}

BOOL CA::WindowServer::IOMFBDisplay::secure_indicator_active(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned char *)this + 25640) == 3;
}

void CA::WindowServer::IOMFBDisplay::update_render_statistics(os_unfair_lock_s *this, const CA::OGL::Context *a2, unsigned int a3)
{
  unsigned int v3 = *((_DWORD *)a2 + 178);
  if (((v3 | a3) & 0x80000000) == 0)
  {
    int v6 = (int)fmin((double)(v3 / 0xA), 9.0);
    int v7 = (int)fmin((double)(a3 / 0xC8), 9.0);
    int v8 = this + 6886;
    os_unfair_lock_lock(this + 6886);
    uint64_t v9 = 0;
    ++this[v6 + 6888]._os_unfair_lock_opaque;
    ++this[v7 + 6898]._os_unfair_lock_opaque;
    do
    {
      this[CA::WindowServer::IOMFBDisplay::offscreen_reason[v9] + 6908]._os_unfair_lock_opaque += *(_DWORD *)((char *)a2 + v9 * 4 + 744);
      ++v9;
    }
    while (v9 != 17);
    LOBYTE(this[6887]._os_unfair_lock_opaque) = 1;
    os_unfair_lock_unlock(v8);
  }
}

uint64_t CA::WindowServer::IOMFBDisplay::is_frozen(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28162);
}

uint64_t CA::WindowServer::IOMFBDisplay::needs_low_latency(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28187);
}

uint64_t CA::WindowServer::IOMFBServer::update_vbl_threshold(uint64_t this, unint64_t a2)
{
  if (*(void *)(this + 912) < a2) {
    *(void *)(this + 912) = a2;
  }
  return this;
}

uint64_t CA::WindowServer::IOMFBDisplay::set_client_preferred_latency(uint64_t this, CATimingFramePacingLatency a2)
{
  if (!BYTE10(xmmword_1EB2ACC70)) {
    *(CATimingFramePacingLatency *)(this + 27768) = a2;
  }
  return this;
}

void CA::WindowServer::Server::invalidate(os_unfair_lock_s *this, const CA::Shape *a2)
{
  if (a2)
  {
    if (a2)
    {
      if (a2 == (const CA::Shape *)1) {
        return;
      }
    }
    else if (*((_DWORD *)a2 + 1) == 6)
    {
      return;
    }
    int v4 = this + 4;
    os_unfair_lock_lock(this + 4);
    uint64_t v7 = *(void *)&this[44]._os_unfair_lock_opaque;
    int v6 = (CA::Shape **)&this[44];
    if (v7) {
      CA::shape_union(v6, (CA::Shape **)a2, v5);
    }
    else {
      *int v6 = (CA::Shape *)CA::Shape::ref((unint64_t)a2);
    }
    os_unfair_lock_unlock(v4);
  }
}

BOOL CA::WindowServer::IOMFBDisplay::change_update_seed(CA::WindowServer::IOMFBDisplay *this, int a2)
{
  int v4 = (pthread_mutex_t *)((char *)this + 25720);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
  unsigned int v5 = *((_DWORD *)this + 6427);
  int v6 = (int *)((char *)this + 48 * v5 + 25784);
  int v7 = *v6;
  if (*v6)
  {
    if (BYTE9(xmmword_1EB2ACC10)) {
      kdebug_trace();
    }
    *int v6 = a2;
    *((unsigned char *)this + 48 * v5 + 25824) |= 4u;
  }
  pthread_mutex_unlock(v4);
  return v7 != 0;
}

void CA::OGL::MetalContext::finish(id *this)
{
  this[371] = 0;
}

void ___ZN2CA6Render5Fence11Transaction8Observer8activateENSt3__113unordered_setIyNS4_4hashIyEENS4_8equal_toIyEENS4_9allocatorIyEEEEPFvPS3_RKSC_djyEPFvSD_SF_jjEPFvSD_SF_E_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a2 == 8)
  {
    mach_port_mod_refs(*MEMORY[0x1E4F14960], *(_DWORD *)(a1 + 96), 1u, -1);
    uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
    if (*(void *)(v9 + 24)) {
      *(void *)(v9 + 24) = 0;
    }
    BOOL v10 = *(NSObject **)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
    if (v10)
    {
      dispatch_source_cancel(v10);
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
    }
  }
  else if (a2 == 2)
  {
    uint64_t v3 = *(void *)(a1 + 64);
    *(void *)uint64_t v18 = 0;
    msg = (mach_msg_header_t *)dispatch_mach_msg_get_msg();
    long long v19 = 0u;
    long long v20 = 0u;
    uint64_t v21 = 1065353216;
    double v17 = 0.0;
    unsigned int v16 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    if (CA::Render::Fence::extract_msg((uint64_t)msg, 0, (uint64_t)&v19, &v17, &v16, &v15, (_DWORD *)&v14 + 1, &v14))
    {
      mach_msg_id_t msgh_id = msg->msgh_id;
      if (msgh_id == 1919772259)
      {
        if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
        {
          double v13 = *(void (**)(uint64_t, long long *, void, void))(a1 + 88);
          if (v13) {
            v13(v3, &v19, HIDWORD(v14), v14);
          }
        }
      }
      else if (msgh_id == 1919706727 && !*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
      {
        for (uint64_t i = (void *)v20; i; uint64_t i = (void *)*i)
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__erase_unique<unsigned long long>((void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), i[2]);
        int v7 = *(void (**)(uint64_t, long long *, void, uint64_t, double))(a1 + 72);
        if (v7) {
          v7(v3, &v19, v16, v15, v17);
        }
        if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 64))
        {
          *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
          (*(void (**)(uint64_t, uint64_t))(a1 + 80))(v3, *(void *)(*(void *)(a1 + 40) + 8) + 40);
          if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24))
          {
            dispatch_mach_cancel();
            *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
          }
          int v8 = *(NSObject **)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
          if (v8)
          {
            dispatch_source_cancel(v8);
            *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
          }
        }
      }
    }
    else if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v11 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        mach_msg_id_t v12 = msg->msgh_id;
        *(_DWORD *)buf = 67109120;
        mach_msg_id_t v23 = v12;
        _os_log_impl(&dword_184668000, v11, OS_LOG_TYPE_DEFAULT, "unknown fence tx observer message %i\n", buf, 8u);
      }
    }
    mach_msg_destroy(msg);
    std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v19);
  }
}

uint64_t CA::Render::Fence::extract_msg(uint64_t a1, unint64_t a2, uint64_t a3, void *a4, _DWORD *a5, void *a6, _DWORD *a7, _DWORD *a8)
{
  int v9 = *(_DWORD *)(a1 + 20);
  if (v9 == 1919772259)
  {
    if (a2 < 0x34) {
      return 0;
    }
    if (*(_DWORD *)(a1 + 4) < 0x34u) {
      return 0;
    }
    if ((*(_DWORD *)a1 & 0x80000000) == 0) {
      return 0;
    }
    if (*(_DWORD *)(a1 + 24) != 1) {
      return 0;
    }
    if (*(unsigned char *)(a1 + 39) != 1) {
      return 0;
    }
    double v13 = *(unint64_t **)(a1 + 28);
    if (!v13) {
      return 0;
    }
    unsigned int v14 = *(_DWORD *)(a1 + 40);
    if (v14 < 8) {
      return 0;
    }
    if (a7) {
      *a7 = *(_DWORD *)(a1 + 44);
    }
    if (a8) {
      *a8 = *(_DWORD *)(a1 + 48);
    }
  }
  else
  {
    if (v9 != 1919706727 || a2 < 0x48 || *(_DWORD *)(a1 + 4) < 0x48u || (*(_DWORD *)a1 & 0x80000000) == 0) {
      return 0;
    }
    int v10 = *(_DWORD *)(a1 + 24);
    if (v10 == 1) {
      goto LABEL_21;
    }
    uint64_t v11 = 0;
    if (v10 != 2) {
      return v11;
    }
    if (*(unsigned char *)(a1 + 55)) {
LABEL_21:
    }
      int v12 = 0;
    else {
      int v12 = *(_DWORD *)(a1 + 44);
    }
    if (*(unsigned char *)(a1 + 39) != 1) {
      return 0;
    }
    double v13 = *(unint64_t **)(a1 + 28);
    if (!v13) {
      return 0;
    }
    unsigned int v14 = *(_DWORD *)(a1 + 40);
    if (v14 < 8) {
      return 0;
    }
    *a6 = *(void *)(a1 + 56);
    *a4 = *(void *)(a1 + 64);
    *a5 = v12;
  }
  uint64_t v16 = v14 >> 3;
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>(a3, vcvtps_u32_f32((float)v16 / *(float *)(a3 + 32)));
  do
  {
    unint64_t v17 = *v13++;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(a3, v17, v17);
    uint64_t v11 = 1;
    --v16;
  }
  while (v16);
  return v11;
}

uint64_t CA::fo_completed(CA::Render::Fence::Transaction::Observer *a1, uint64_t a2)
{
  uint64_t v4 = mach_absolute_time();
  double v5 = CATimeWithHostTime(v4);
  uint64_t result = CA::fo_fences_released(a1, a2, 0, 0, v5);
  if (a1)
  {
    CA::Render::Fence::Transaction::Observer::~Observer(a1);
    JUMPOUT(0x185323DC0);
  }
  return result;
}

uint64_t CA::fo_fences_released(void *a1, uint64_t a2, unsigned int a3, unint64_t a4, double a5)
{
  if (a1 && a1[4])
  {
    if (a3 - 1 >= 0xFFFFFFFE)
    {
      CA::Render::Fence::Transaction::Observer::notify_batch_handlers(a1);
    }
    else
    {
      int v9 = +[CABatchInfo _newInfoWithUnownedPort:name:]((uint64_t)CABatchInfo, a3, a4);
      CA::Render::Fence::Transaction::Observer::notify_batch_handlers(a1);
      if (v9)
      {
        os_unfair_lock_lock((os_unfair_lock_t)&v9->_lock);
        v9->_invalidated = 1;
        os_unfair_lock_unlock((os_unfair_lock_t)&v9->_lock);
      }
    }
  }

  return CA::Context::send_deferrals(0, 0, a2, a3, a5);
}

void CA::Render::Fence::Transaction::Observer::~Observer(CA::Render::Fence::Transaction::Observer *this)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 2));
    *((void *)this + 2) = 0;
  }
  if (*((void *)this + 1))
  {
    dispatch_mach_cancel();
    dispatch_release(*((dispatch_object_t *)this + 1));
    *((void *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  }
  mach_port_name_t v3 = *((_DWORD *)this + 6);
  if (v3 && *((unsigned char *)this + 28)) {
    mach_port_mod_refs(*MEMORY[0x1E4F14960], v3, 1u, -1);
  }
  *((unsigned char *)this + 28) = 0;
  *((_DWORD *)this + 6) = 0;
  if (*((void *)this + 4)) {
    CA::Render::Fence::Transaction::Observer::free_batch_handlers(this);
  }
}

BOOL CA::Render::Fence::resolve_fences(CA::Render::Fence *this)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  long long v85 = 0u;
  long long v86 = 0u;
  uint64_t v87 = 1065353216;
  memset(v83, 0, sizeof(v83));
  uint64_t v84 = 1065353216;
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>((uint64_t)&v85, (unint64_t)(float)*(unint64_t *)(CA::Render::Fence::cleared_f_names + 24));
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>((uint64_t)v83, (unint64_t)(float)*(unint64_t *)(CA::Render::Fence::fences_by_name + 24));
  for (uint64_t i = *(void **)(CA::Render::Fence::cleared_f_names + 16); i; uint64_t i = (void *)*i)
  {
    unint64_t v2 = i[2];
    if (!std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(&v85, v2)&& !std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(v83, v2))
    {
      long long v80 = 0u;
      long long v81 = 0u;
      uint64_t v82 = 1065353216;
      if (CA::Render::Fence::is_fence_resolved(v2, &v80, (uint64_t)&v85, v83))
      {
        for (float j = (void *)v81; j; float j = (void *)*j)
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)&v85, j[2], j[2]);
      }
      std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v80);
    }
  }
  uint64_t v4 = *((void *)&v86 + 1);
  if (*((void *)&v86 + 1))
  {
    uint64_t v77 = *((void *)&v86 + 1);
    uint64_t batch = CA::Render::Fence::create_batch((CA::Render::Fence *)1);
    for (int k = *(uint64_t **)(CA::Render::Fence::fcontexts_by_id + 16);
          k;
          int k = (uint64_t *)std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase((void *)CA::Render::Fence::fcontexts_by_id, k))
    {
      while (1)
      {
        int v7 = (uint64_t *)k[3];
        uint64_t v8 = *v7;
        uint64_t v9 = v7[1];
        int v10 = *(void **)v9;
        if (*(void *)v9 == *(void *)(v9 + 8)) {
          break;
        }
        uint64_t v78 = (uint64_t *)k[3];
        unint64_t v79 = (uint64_t **)k;
        do
        {
          for (float m = (void *)v86; m; float m = (void *)*m)
          {
            unint64_t v12 = m[2];
            if (std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(v10, v12))
            {
              if (batch)
              {
                if ((*(unsigned char *)(v8 + 13) & 4) == 0)
                {
                  LODWORD(v8CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = *(_DWORD *)(v8 + 16);
                  unsigned int v13 = v80;
                  unsigned int v14 = *(void **)(batch + 24);
                  if (!std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v14, v80))
                  {
                    std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)v14, v13, v13);
                    kdebug_trace();
                    CA::Render::Context::add_fence_batch_port((os_unfair_lock_s *)v8, *(_DWORD *)(batch + 40));
                    uint64_t v15 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::bcontexts_by_id, v13);
                    if (!v15)
                    {
                      if (!atomic_fetch_add((atomic_uint *volatile)(v8 + 8), 1u)) {
                        atomic_fetch_add((atomic_uint *volatile)(v8 + 8), 0xFFFFFFFF);
                      }
                      malloc_zone = (malloc_zone_t *)get_malloc_zone();
                      *(void *)malloc_type_zone_malloc(malloc_zone, 0x18uLL, 0x8BB15036uLL) = v8;
                      operator new();
                    }
                    std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(*(void *)(v15[3] + 16), *(_DWORD *)(batch + 40), *(_DWORD *)(batch + 40));
                  }
                }
              }
              std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__erase_unique<unsigned long long>(v10, v12);
            }
          }
          if (v10[3])
          {
            v10 += 5;
            unint64_t v17 = *(void **)(v9 + 8);
          }
          else
          {
            uint64_t v18 = (uint64_t)(v10 + 5);
            long long v19 = *(void **)(v9 + 8);
            if (v10 + 5 == v19)
            {
              unint64_t v17 = v10;
            }
            else
            {
              long long v20 = v10;
              do
              {
                std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::clear(v20);
                uint64_t v21 = v20[5];
                v20[5] = 0;
                uint64_t v22 = (void *)*v20;
                *long long v20 = v21;
                if (v22) {
                  operator delete(v22);
                }
                uint64_t v23 = v20[7];
                double v20[2] = v23;
                unint64_t v24 = v20[6];
                v20[1] = v24;
                v20[6] = 0;
                uint64_t v25 = v20[8];
                v20[3] = v25;
                *((_DWORD *)v20 + 8) = *((_DWORD *)v20 + 18);
                if (v25)
                {
                  unint64_t v26 = *(void *)(v23 + 8);
                  if ((v24 & (v24 - 1)) != 0)
                  {
                    if (v26 >= v24) {
                      v26 %= v24;
                    }
                  }
                  else
                  {
                    v26 &= v24 - 1;
                  }
                  *(void *)(*v20 + 8 * v26) = v20 + 2;
                  v20[7] = 0;
                  v20[8] = 0;
                }
                unint64_t v17 = v20 + 5;
                int v27 = v20 + 10;
                v20 += 5;
              }
              while (v27 != v19);
              uint64_t v18 = *(void *)(v9 + 8);
            }
            while ((void *)v18 != v17)
              uint64_t v18 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v18 - 40);
            *(void *)(v9 + 8) = v17;
          }
        }
        while (v10 != v17);
        int v7 = v78;
        int k = (uint64_t *)v79;
        if (*(void **)v9 == v17) {
          break;
        }
        int k = *v79;
        if (!*v79) {
          goto LABEL_51;
        }
      }
      *(void *)&long long v80 = v9;
      std::vector<std::unordered_set<unsigned long long>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v80);
      MEMORY[0x185323DC0](v9, 0x20C40960023A9);
      if (v8 && atomic_fetch_add((atomic_uint *volatile)(v8 + 8), 0xFFFFFFFF) == 1) {
        (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
      }
      size_t v28 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v28, v7);
    }
LABEL_51:
    unint64_t v29 = (void *)v86;
    if ((void)v86)
    {
      uint64_t v30 = (ipc_space_t *)MEMORY[0x1E4F14960];
      do
      {
        unint64_t v31 = v29[2];
        uint64_t v32 = std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>((void *)CA::Render::Fence::fences_by_name, v31);
        if (!v32) {
          abort();
        }
        uint64_t v33 = v32[3];
        kdebug_trace();
        uint64_t v34 = (void *)CA::Render::Fence::fences_by_name;
        uint64_t v35 = std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>((void *)CA::Render::Fence::fences_by_name, v31);
        if (v35)
        {
          int8x8_t v36 = (int8x8_t)v34[1];
          unint64_t v37 = v35[1];
          uint8x8_t v38 = (uint8x8_t)vcnt_s8(v36);
          v38.i16[0] = vaddlv_u8(v38);
          if (v38.u32[0] > 1uLL)
          {
            if (v37 >= *(void *)&v36) {
              v37 %= *(void *)&v36;
            }
          }
          else
          {
            v37 &= *(void *)&v36 - 1;
          }
          uint64_t v39 = *(void **)(*v34 + 8 * v37);
          do
          {
            unsigned int v40 = v39;
            uint64_t v39 = (void *)*v39;
          }
          while (v39 != v35);
          if (v40 == v34 + 2) {
            goto LABEL_72;
          }
          unint64_t v41 = v40[1];
          if (v38.u32[0] > 1uLL)
          {
            if (v41 >= *(void *)&v36) {
              v41 %= *(void *)&v36;
            }
          }
          else
          {
            v41 &= *(void *)&v36 - 1;
          }
          if (v41 != v37)
          {
LABEL_72:
            if (!*v35) {
              goto LABEL_73;
            }
            unint64_t v42 = *(void *)(*v35 + 8);
            if (v38.u32[0] > 1uLL)
            {
              if (v42 >= *(void *)&v36) {
                v42 %= *(void *)&v36;
              }
            }
            else
            {
              v42 &= *(void *)&v36 - 1;
            }
            if (v42 != v37) {
LABEL_73:
            }
              *(void *)(*v34 + 8 * v37) = 0;
          }
          uint64_t v43 = *v35;
          if (*v35)
          {
            unint64_t v44 = *(void *)(v43 + 8);
            if (v38.u32[0] > 1uLL)
            {
              if (v44 >= *(void *)&v36) {
                v44 %= *(void *)&v36;
              }
            }
            else
            {
              v44 &= *(void *)&v36 - 1;
            }
            if (v44 != v37)
            {
              *(void *)(*v34 + 8 * v44) = v40;
              uint64_t v43 = *v35;
            }
          }
          *unsigned int v40 = v43;
          *uint64_t v35 = 0;
          --v34[3];
          operator delete(v35);
        }
        uint64_t v45 = (void *)CA::Render::Fence::fences_by_port;
        int8x16_t v46 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::fences_by_port, *(_DWORD *)(v33 + 16));
        if (v46)
        {
          int8x8_t v47 = (int8x8_t)v45[1];
          unint64_t v48 = v46[1];
          uint8x8_t v49 = (uint8x8_t)vcnt_s8(v47);
          v49.i16[0] = vaddlv_u8(v49);
          if (v49.u32[0] > 1uLL)
          {
            if (v48 >= *(void *)&v47) {
              v48 %= *(void *)&v47;
            }
          }
          else
          {
            v48 &= *(void *)&v47 - 1;
          }
          unint64_t v50 = *(uint64_t **)(*v45 + 8 * v48);
          do
          {
            double v51 = v50;
            unint64_t v50 = (uint64_t *)*v50;
          }
          while (v50 != v46);
          if (v51 == v45 + 2) {
            goto LABEL_100;
          }
          unint64_t v52 = v51[1];
          if (v49.u32[0] > 1uLL)
          {
            if (v52 >= *(void *)&v47) {
              v52 %= *(void *)&v47;
            }
          }
          else
          {
            v52 &= *(void *)&v47 - 1;
          }
          if (v52 != v48)
          {
LABEL_100:
            if (!*v46) {
              goto LABEL_101;
            }
            unint64_t v53 = *(void *)(*v46 + 8);
            if (v49.u32[0] > 1uLL)
            {
              if (v53 >= *(void *)&v47) {
                v53 %= *(void *)&v47;
              }
            }
            else
            {
              v53 &= *(void *)&v47 - 1;
            }
            if (v53 != v48) {
LABEL_101:
            }
              *(void *)(*v45 + 8 * v48) = 0;
          }
          uint64_t v54 = *v46;
          if (*v46)
          {
            unint64_t v55 = *(void *)(v54 + 8);
            if (v49.u32[0] > 1uLL)
            {
              if (v55 >= *(void *)&v47) {
                v55 %= *(void *)&v47;
              }
            }
            else
            {
              v55 &= *(void *)&v47 - 1;
            }
            if (v55 != v48)
            {
              *(void *)(*v45 + 8 * v55) = v51;
              uint64_t v54 = *v46;
            }
          }
          *double v51 = v54;
          *int8x16_t v46 = 0;
          --v45[3];
          operator delete(v46);
        }
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__erase_unique<unsigned long long>((void *)CA::Render::Fence::cleared_f_names, v31);
        mach_port_destruct(*v30, *(_DWORD *)(v33 + 16), 0, *(void *)v33);
        uint64_t v56 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v56, (void *)v33);
        unint64_t v29 = (void *)*v29;
      }
      while (v29);
    }
    uint64_t v57 = mach_absolute_time();
    double v58 = CATimeWithHostTime(v57);
    float v59 = *(char **)CA::Render::Fence::transactions;
    if (*(void *)CA::Render::Fence::transactions != *(void *)(CA::Render::Fence::transactions + 8))
    {
      double v60 = v58;
      unint64_t v61 = (ipc_space_t *)MEMORY[0x1E4F14960];
      do
      {
        uint64_t v62 = *(void *)v59;
        int v63 = (void *)v86;
        if ((void)v86)
        {
          char v64 = 0;
LABEL_115:
          double v65 = *(void **)v62;
          do
          {
            unint64_t v66 = std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(v65, v63[2]);
            if (v66)
            {
              std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(v65, v66);
              int v63 = (void *)*v63;
              char v64 = 1;
              if (v63) {
                goto LABEL_115;
              }
              goto LABEL_122;
            }
            int v63 = (void *)*v63;
          }
          while (v63);
          if ((v64 & 1) == 0) {
            goto LABEL_123;
          }
LABEL_122:
          CA::Render::Fence::send_rlfg_msg(*(unsigned int *)(v62 + 16), *(unsigned int *)(batch + 40), *(void *)batch, (uint64_t)&v85, v60);
        }
LABEL_123:
        if (*(void *)(*(void *)v62 + 24))
        {
          v59 += 8;
          uint64_t v67 = *(char **)(CA::Render::Fence::transactions + 8);
        }
        else
        {
          mach_port_deallocate(*v61, *(_DWORD *)(v62 + 16));
          if (*(void *)v62)
          {
            uint64_t v68 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(*(void *)v62);
            MEMORY[0x185323DC0](v68, 0x10A0C408EF24B1CLL);
          }
          uint64_t v69 = *(void *)(v62 + 8);
          if (v69)
          {
            uint64_t v70 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v69);
            MEMORY[0x185323DC0](v70, 0x10A0C408EF24B1CLL);
          }
          unint64_t v71 = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(v71, (void *)v62);
          uint64_t v72 = CA::Render::Fence::transactions;
          unsigned __int8 v73 = *(char **)(CA::Render::Fence::transactions + 8);
          int64_t v74 = v73 - (v59 + 8);
          if (v73 != v59 + 8) {
            memmove(v59, v59 + 8, v73 - (v59 + 8));
          }
          uint64_t v67 = &v59[v74];
          *(void *)(v72 + 8) = &v59[v74];
        }
      }
      while (v59 != v67);
    }
    mach_port_name_t v75 = *(_DWORD *)(batch + 40);
    uint64_t v4 = v77;
    if (v75 + 1 >= 2) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v75);
    }
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v83);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v85);
  return v4 != 0;
}

uint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(void *a1, uint64_t *__p)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  uint64_t v4 = *__p;
  unint64_t v3 = __p[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v3 >= *(void *)&v2) {
      v3 %= *(void *)&v2;
    }
  }
  else
  {
    v3 &= *(void *)&v2 - 1;
  }
  int v6 = *(uint64_t **)(*a1 + 8 * v3);
  do
  {
    int v7 = v6;
    int v6 = (uint64_t *)*v6;
  }
  while (v6 != __p);
  if (v7 != a1 + 2)
  {
    unint64_t v8 = v7[1];
    if (v5.u32[0] > 1uLL)
    {
      if (v8 >= *(void *)&v2) {
        v8 %= *(void *)&v2;
      }
    }
    else
    {
      v8 &= *(void *)&v2 - 1;
    }
    uint64_t v9 = *__p;
    if (v8 == v3)
    {
LABEL_20:
      if (!v9) {
        goto LABEL_27;
      }
      goto LABEL_21;
    }
  }
  if (!v4) {
    goto LABEL_19;
  }
  unint64_t v10 = *(void *)(v4 + 8);
  if (v5.u32[0] > 1uLL)
  {
    if (v10 >= *(void *)&v2) {
      v10 %= *(void *)&v2;
    }
  }
  else
  {
    v10 &= *(void *)&v2 - 1;
  }
  uint64_t v9 = *__p;
  if (v10 != v3)
  {
LABEL_19:
    *(void *)(*a1 + 8 * v3) = 0;
    uint64_t v9 = *__p;
    goto LABEL_20;
  }
LABEL_21:
  unint64_t v11 = *(void *)(v9 + 8);
  if (v5.u32[0] > 1uLL)
  {
    if (v11 >= *(void *)&v2) {
      v11 %= *(void *)&v2;
    }
  }
  else
  {
    v11 &= *(void *)&v2 - 1;
  }
  if (v11 != v3)
  {
    *(void *)(*a1 + 8 * v1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v7;
    uint64_t v9 = *__p;
  }
LABEL_27:
  *int v7 = v9;
  *__p = 0;
  --a1[3];
  operator delete(__p);
  return v4;
}

uint64_t *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__erase_unique<unsigned long long>(void *a1, unint64_t a2)
{
  uint64_t result = std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(a1, a2);
  if (result)
  {
    return (uint64_t *)std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(a1, result);
  }
  return result;
}

uint64_t CA::Render::Fence::is_fence_resolved(unint64_t a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)a2, a1, a1);
  if (!std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>((void *)CA::Render::Fence::cleared_f_names, a1))
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)a4, a1, a1);
    return 0;
  }
  unint64_t v8 = *(void **)(CA::Render::Fence::fcontexts_by_id + 16);
  if (!v8) {
    return 1;
  }
  while (1)
  {
    uint64_t v9 = *(void **)(v8[3] + 8);
    uint64_t v10 = v9[1];
    if (v10 != *v9) {
      break;
    }
LABEL_16:
    unint64_t v8 = (void *)*v8;
    uint64_t result = 1;
    if (!v8) {
      return result;
    }
  }
  char v11 = 0;
  while (1)
  {
    uint64_t v17 = 0;
    v10 -= 40;
    long long v15 = 0u;
    long long v16 = 0u;
    std::unordered_set<unsigned long long>::unordered_set((uint64_t)&v15, v10);
    if ((v11 & 1) == 0
      && !std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(&v15, a1))
    {
      char v11 = 0;
      goto LABEL_15;
    }
    unint64_t v12 = (void *)v16;
    if ((void)v16) {
      break;
    }
LABEL_13:
    char v11 = 1;
LABEL_15:
    std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v15);
    if (v10 == *v9) {
      goto LABEL_16;
    }
  }
  while (1)
  {
    unint64_t v13 = v12[2];
    if (!std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(a2, v13)&& !std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(*(void *)a3, *(void *)(a3 + 8), v13)&& (std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(a4, v13)|| !CA::Render::Fence::is_fence_resolved(v13, a2, a3, a4)))
    {
      break;
    }
    unint64_t v12 = (void *)*v12;
    if (!v12) {
      goto LABEL_13;
    }
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)a4, a1, a1);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v15);
  return 0;
}

void *CA::OGL::MetalContext::test_fence(CA::OGL::MetalContext *this, unint64_t a2)
{
  uint64_t result = std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>((void *)this + 343, a2);
  if (result)
  {
    unint64_t v4 = atomic_load((unint64_t *)this + 504);
    return (void *)(v4 >= result[3]);
  }
  return result;
}

void CA::OGL::MetalContext::delete_fence(int8x8_t *this, unint64_t a2)
{
  unint64_t v3 = this + 343;
  unint64_t v4 = (int8x8_t *)std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(&this[343], a2);
  if (v4)
  {
    int8x8_t v5 = this[344];
    unint64_t v6 = (unint64_t)v4[1];
    uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v5) {
        v6 %= *(void *)&v5;
      }
    }
    else
    {
      v6 &= *(void *)&v5 - 1;
    }
    unint64_t v8 = *(int8x8_t **)(*(void *)v3 + 8 * v6);
    do
    {
      uint64_t v9 = v8;
      unint64_t v8 = (int8x8_t *)*v8;
    }
    while (v8 != v4);
    if (v9 == &this[345]) {
      goto LABEL_20;
    }
    unint64_t v10 = (unint64_t)v9[1];
    if (v7.u32[0] > 1uLL)
    {
      if (v10 >= *(void *)&v5) {
        v10 %= *(void *)&v5;
      }
    }
    else
    {
      v10 &= *(void *)&v5 - 1;
    }
    if (v10 != v6)
    {
LABEL_20:
      if (!*(void *)v4) {
        goto LABEL_21;
      }
      unint64_t v11 = *(void *)(*(void *)v4 + 8);
      if (v7.u32[0] > 1uLL)
      {
        if (v11 >= *(void *)&v5) {
          v11 %= *(void *)&v5;
        }
      }
      else
      {
        v11 &= *(void *)&v5 - 1;
      }
      if (v11 != v6) {
LABEL_21:
      }
        *(void *)(*(void *)v3 + 8 * v6) = 0;
    }
    int8x8_t v12 = *v4;
    if (*v4)
    {
      unint64_t v13 = *(void *)(*(void *)&v12 + 8);
      if (v7.u32[0] > 1uLL)
      {
        if (v13 >= *(void *)&v5) {
          v13 %= *(void *)&v5;
        }
      }
      else
      {
        v13 &= *(void *)&v5 - 1;
      }
      if (v13 != v6)
      {
        *(void *)(*(void *)v3 + 8 * v13) = v9;
        int8x8_t v12 = *v4;
      }
    }
    *uint64_t v9 = v12;
    *unint64_t v4 = 0;
    --*(void *)&this[346];
    operator delete(v4);
  }
}

CA::Render::Fence::BatchWaitLock *CA::Render::Fence::BatchWaitLock::BatchWaitLock(CA::Render::Fence::BatchWaitLock *this)
{
  *(void *)this = 0;
  *((unsigned char *)this + 8) = 0;
  pthread_mutex_lock(&CA::Render::Fence::_bwait_mutex);
  int8x8_t v2 = pthread_self();
  if (pthread_threadid_np(v2, (__uint64_t *)this)) {
    __assert_rtn("BatchWaitLock", "render-fence.cpp", 1910, "r == noErr");
  }
  unint64_t v3 = *(void *)this;
  if (!*(void *)this) {
    __assert_rtn("BatchWaitLock", "render-fence.cpp", 1911, "_tid != 0");
  }
  while (1)
  {
    if (CA::Render::Fence::_bwait_writer_active) {
      goto LABEL_7;
    }
    unint64_t v4 = (float *)CA::Render::Fence::_bwait_readers_by_tid;
    if (CA::Render::Fence::_bwait_writer_pending != 1) {
      break;
    }
    if (CA::Render::Fence::_bwait_readers_by_tid
      && std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>((void *)CA::Render::Fence::_bwait_readers_by_tid, v3))
    {
      goto LABEL_10;
    }
LABEL_7:
    pthread_cond_wait(&CA::Render::Fence::_bwait_cond_reader, &CA::Render::Fence::_bwait_mutex);
    unint64_t v3 = *(void *)this;
  }
  if (!CA::Render::Fence::_bwait_readers_by_tid) {
    operator new();
  }
LABEL_10:
  int8x8_t v5 = std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(v4, v3);
  if (v5)
  {
    int v6 = *((_DWORD *)v5 + 6);
    if (v6 == -1) {
      __assert_rtn("BatchWaitLock", "render-fence.cpp", 1923, "ri->second < UINT32_MAX");
    }
    int v7 = v6 + 1;
  }
  else
  {
    int v7 = 1;
  }
  *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v4, v3, this)+ 6) = v7;
  pthread_mutex_unlock(&CA::Render::Fence::_bwait_mutex);
  return this;
}

void *std::__hash_table<std::__hash_value_type<unsigned long,unsigned long long>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,unsigned long long>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,unsigned long long>>>::find<unsigned long>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  int8x8_t v5 = *(void **)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  uint64_t result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == a2)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= *(void *)&v2) {
            v7 %= *(void *)&v2;
          }
        }
        else
        {
          v7 &= *(void *)&v2 - 1;
        }
        if (v7 != v4) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(float *a1, unint64_t a2, void *a3)
{
  unint64_t v6 = *((void *)a1 + 1);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  unint64_t v10 = operator new(0x20uLL);
  void *v10 = 0;
  v10[1] = a2;
  v10[2] = *a3;
  *((_DWORD *)v10 + 6) = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    BOOL v14 = 1;
    if (v6 >= 3) {
      BOOL v14 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v6);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      int8x8_t prime = (int8x8_t)v16;
    }
    else {
      int8x8_t prime = (int8x8_t)v15;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v6 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v6) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v6)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v6 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (*(void *)&prime <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      if (*(void *)&prime >= v6)
      {
        unint64_t v6 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * *(void *)&prime);
          long long v19 = *(void **)a1;
          *(void *)a1 = v18;
          if (v19) {
            operator delete(v19);
          }
          uint64_t v20 = 0;
          *((int8x8_t *)a1 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v20++) = 0;
          while (*(void *)&prime != v20);
          uint64_t v21 = (void *)*((void *)a1 + 2);
          if (v21)
          {
            unint64_t v22 = v21[1];
            uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
            v23.i16[0] = vaddlv_u8(v23);
            if (v23.u32[0] > 1uLL)
            {
              if (v22 >= *(void *)&prime) {
                v22 %= *(void *)&prime;
              }
            }
            else
            {
              v22 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
            int v27 = (void *)*v21;
            if (*v21)
            {
              do
              {
                unint64_t v28 = v27[1];
                if (v23.u32[0] > 1uLL)
                {
                  if (v28 >= *(void *)&prime) {
                    v28 %= *(void *)&prime;
                  }
                }
                else
                {
                  v28 &= *(void *)&prime - 1;
                }
                if (v28 != v22)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v28))
                  {
                    *(void *)(*(void *)a1 + 8 * v28) = v21;
                    goto LABEL_55;
                  }
                  void *v21 = *v27;
                  void *v27 = **(void **)(*(void *)a1 + 8 * v28);
                  **(void **)(*(void *)a1 + 8 * v28) = v27;
                  int v27 = v21;
                }
                unint64_t v28 = v22;
LABEL_55:
                uint64_t v21 = v27;
                int v27 = (void *)*v27;
                unint64_t v22 = v28;
              }
              while (v27);
            }
          }
          unint64_t v6 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v33 = *(void **)a1;
        *(void *)a1 = 0;
        if (v33) {
          operator delete(v33);
        }
        unint64_t v6 = 0;
        *((void *)a1 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
      }
    }
LABEL_59:
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
      else {
        unint64_t v8 = a2;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
  }
  unint64_t v29 = *(void **)a1;
  uint64_t v30 = *(void **)(*(void *)a1 + 8 * v8);
  if (v30)
  {
    void *v10 = *v30;
LABEL_72:
    void *v30 = v10;
    goto LABEL_73;
  }
  void *v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v8] = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v31 >= v6) {
        v31 %= v6;
      }
    }
    else
    {
      v31 &= v6 - 1;
    }
    uint64_t v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

uint64_t std::unordered_set<unsigned long long>::unordered_set(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(void **)(a2 + 16); i; uint64_t i = (void *)*i)
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(a1, i[2], i[2]);
  return a1;
}

void CA::Render::Fence::send_rlfg_msg(uint64_t a1, size_t size, uint64_t a3, uint64_t a4, double a5)
{
  mach_msg_return_t v16;
  mach_msg_return_t v17;
  NSObject *v18;
  unsigned char msg[28];
  unsigned char *v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  double v27;
  uint8_t buf[4];
  mach_msg_return_t v29;
  uint64_t v30;

  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a4 + 24);
  if (!v5) {
    __assert_rtn("send_rlfg_msg", "render-fence.cpp", 107, "!f_names.empty ()");
  }
  int v6 = size;
  if ((size + 1) <= 1) {
    __assert_rtn("send_rlfg_msg", "render-fence.cpp", 108, "MACH_PORT_VALID (batch_port)");
  }
  int v10 = a1;
  if ((unint64_t)(8 * v5) > 0x1000)
  {
    float v12 = malloc_type_malloc(8 * v5, 0x65CF298AuLL);
  }
  else
  {
    MEMORY[0x1F4188790](a1);
    float v12 = &msg[-((v11 + 15) & 0xFFFFFFFFFFFFFFF0) - 8];
    bzero(v12, v11);
  }
  float v13 = *(void **)(a4 + 16);
  if (v13)
  {
    BOOL v14 = v12;
    do
    {
      *v14++ = v13[2];
      float v13 = (void *)*v13;
    }
    while (v13);
  }
  *(void *)msg = 0x4880000013;
  *(_DWORD *)&msg[8] = v10;
  *(_OWORD *)&msg[12] = xmmword_184998660;
  uint64_t v21 = v12;
  int v15 = 8 * *(_DWORD *)(a4 + 24);
  unint64_t v22 = 16777472;
  uint8x8_t v23 = v15;
  unint64_t v24 = v6;
  uint8x8_t v25 = 0x13000000000000;
  uint64_t v26 = a3;
  int v27 = a5;
  unint64_t v16 = mach_msg((mach_msg_header_t *)msg, 17, 0x48u, 0, 0, 0x64u, 0);
  if (v16)
  {
    uint64_t v17 = v16;
    if ((v16 - 268435459) <= 1) {
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v18 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        unint64_t v29 = v17;
        _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_DEFAULT, "failed to send rlfg reply: %x\n", buf, 8u);
      }
    }
  }
}

CA::Render::SecureIndicatorLayer *CA::Render::SecureIndicatorLayer::SecureIndicatorLayer(CA::Render::SecureIndicatorLayer *this, CA::Render::Decoder *a2)
{
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0x2D;
  ++dword_1EB2ADE7C;
  *(void *)this = &unk_1ED02EDA0;
  *((_DWORD *)this + 4) = CA::Render::Decoder::decode_int32(a2);
  *((_WORD *)this + 1CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = CA::Render::Decoder::decode_int16(a2);
  return this;
}

uint64_t CA::Render::ShmemBitmap::fill_pixels(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = (int32x2_t *)result;
  if (!a3 || (uint64_t result = CGSRegionIsEmpty(), (result & 1) == 0))
  {
    __int32 v5 = v4[4].i32[0];
    if (v5)
    {
      for (int i = 0; i != v5; ++i)
      {
        uint8x8_t v7 = (CA::Render *)v4[1].u32[1];
        uint64_t v8 = 0;
        if (i)
        {
          int32x2_t v9 = v4[2];
          int v10 = i;
          do
          {
            uint32x2_t v13 = (uint32x2_t)v9;
            v8 += CA::Render::format_rowbytes(v7, v9.u32[0]) * v9.u32[1];
            int8x8_t v11 = (int8x8_t)vcgt_u32(v13, (uint32x2_t)0x100000001);
            int32x2_t v9 = vsub_s32((int32x2_t)vand_s8((int8x8_t)vshr_n_u32(v13, 1uLL), v11), (int32x2_t)vmvn_s8(v11));
            --v10;
          }
          while (v10);
          uint8x8_t v7 = (CA::Render *)v4[1].u32[1];
        }
        if ((unsigned __int32)v4[2].i32[0] >> i <= 1) {
          unsigned int v12 = 1;
        }
        else {
          unsigned int v12 = (unsigned __int32)v4[2].i32[0] >> i;
        }
        CA::Render::format_rowbytes(v7, v12);
        if (a3)
        {
          CGSRegionEnumerator();
          while (CGSNextRect())
            CGBlt_fillBytes();
          uint64_t result = CGSReleaseRegionEnumerator();
        }
        else
        {
          uint64_t result = CGBlt_fillBytes();
        }
      }
    }
  }
  return result;
}

uint64_t backingStoreFinalize(char *a1)
{
  v13[7] = *MEMORY[0x1E4F143B8];
  pthread_mutex_lock(&buffer_list_mutex);
  uint64_t v2 = *((void *)a1 + 22);
  if (v2) {
    *(void *)(v2 + 168) = *((void *)a1 + 21);
  }
  uint64_t v3 = *((void *)a1 + 21);
  if (v3) {
    *(void *)(v3 + 176) = v2;
  }
  if ((char *)buffer_list == a1) {
    buffer_list = v3;
  }
  pthread_mutex_unlock(&buffer_list_mutex);
  CGColorSpaceRelease(*((CGColorSpaceRef *)a1 + 20));
  if (pthread_main_np())
  {
    for (uint64_t i = 0; i != 216; i += 72)
    {
      __int32 v5 = *(atomic_uint **)&a1[i + 208];
      if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1)
      {
        (**(void (***)(atomic_uint *))v5)(v5);
        (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
      }
    }
  }
  else
  {
    uint64_t v6 = *((void *)a1 + 26);
    uint64_t v7 = *((void *)a1 + 35);
    uint64_t v8 = *((void *)a1 + 44);
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 0x40000000;
    v13[2] = ___ZL20backingStoreFinalizePKv_block_invoke;
    v13[3] = &__block_descriptor_tmp_14_929;
    v13[4] = v6;
    v13[5] = v7;
    v13[6] = v8;
    dispatch_async(MEMORY[0x1E4F14428], v13);
  }
  for (uint64_t j = 192; j != 408; j += 72)
  {
    int v10 = (CGColorSpaceRef *)&a1[j];
    int8x8_t v11 = *(atomic_uint **)&a1[j + 8];
    if (v11 && atomic_fetch_add(v11 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v11 + 16))(v11);
    }
    CGColorSpaceRelease(*v10);
    CGSReleaseRegion();
    CGColorRelease(v10[3]);
  }
  if (*((void *)a1 + 55)) {
    CGSBoundingShapeRelease();
  }
  CGSReleaseRegion();
  CABackingStoreReleaseImages((CABackingStore *)a1);
  pthread_cond_destroy((pthread_cond_t *)(a1 + 80));
  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
}

uint64_t ___ZN2CA5Layer8display_Ev_block_invoke(uint64_t a1)
{
  return CABackingStoreUpdate_(*(void *)(a1 + 48), *(int *)(a1 + 72), *(int *)(a1 + 76), *(unsigned int *)(a1 + 80), *(_DWORD *)(a1 + 84), *(_DWORD *)(a1 + 88), *(void *)(a1 + 56), (void (*)(void, uint64_t))backing_callback, *(void *)(a1 + 40), *(void *)(a1 + 64), [*(id *)(a1 + 32) wantsExtendedDynamicRangeContent]);
}

uint64_t CABackingStoreUpdate_(unint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, unsigned int a5, int a6, uint64_t a7, void (*a8)(void, uint64_t), uint64_t a9, uint64_t a10, unsigned __int8 a11)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v18 = *(_opaque_pthread_t **)(a1 + 480);
  if (v18)
  {
    if (v18 == pthread_self()) {
      return pthread_mutex_unlock(v17);
    }
    while (*(void *)(a1 + 480))
      pthread_cond_wait((pthread_cond_t *)(a1 + 80), v17);
  }
  uint64_t v19 = a9;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  CGColorRef color = 0;
  if (a4 != 36)
  {
    CFTypeRef v21 = 0;
    goto LABEL_9;
  }
  uint64_t v48 = 0;
  long long v46 = 0u;
  long long v47 = 0u;
  *(_OWORD *)cf = 0u;
  memset(v44, 0, sizeof(v44));
  CACGContextEvaluator::CACGContextEvaluator((CACGContextEvaluator *)v44, a2, a3, *(CGColorSpace **)(a1 + 160));
  *(void *)(a1 + 48CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = pthread_self();
  pthread_mutex_unlock(v17);
  a8(*((void *)&v46 + 1), a9);
  pthread_mutex_lock(v17);
  *(void *)(a1 + 48CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
  uint64_t v20 = CACGContextEvaluator::suggested_format((CACGContextEvaluator *)v44, a5 & 1, &color, a11);
  if (v20 != -1)
  {
    a4 = v20;
    CFTypeRef v21 = CFRetain(cf[0]);
    CGContextGetEDRTargetHeadroom();
    CACGContextEvaluator::~CACGContextEvaluator((CGColorSpaceRef *)v44);
LABEL_9:
    uint64_t v22 = a10;
    *(void *)(a1 + 128) = a2;
    *(void *)(a1 + 136) = a3;
    if (a11 && a4 <= 0x1C && ((0x17826000u >> a4) & 1) != 0)
    {
      uint8x8_t v23 = *(CGColorSpace **)(a1 + 160);
      CGColorSpaceRef Extended = CAColorSpaceCreateExtended(v23);
      CGColorSpaceRelease(v23);
      uint64_t v22 = a10;
      uint64_t v19 = a9;
      *(void *)(a1 + 16CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = Extended;
    }
    uint64_t v24 = a4;
    uint64_t v25 = a7;
    uint64_t v40 = v22;
    if (!CABackingStorePrepareUpdates_(a1, a2, a3, v24, a5, a6, a7, v22, (uint64_t)&v50)) {
      goto LABEL_48;
    }
    uint64_t v26 = *(void *)(a1 + 408);
    uint64_t v27 = *(void *)(v26 + 16);
    if (v27)
    {
      int v28 = *(_DWORD *)(*(void *)(v27 + 24) + 32);
      if (!v28)
      {
LABEL_40:
        CGColorRelease(*(CGColorRef *)(v26 + 32));
        uint64_t v36 = *(void *)(a1 + 408);
        *(void *)(v36 + 32) = color;
        CGColorRef color = 0;
        if (*(void *)(a1 + 448))
        {
          CGSReleaseRegion();
          *(void *)(a1 + 448) = 0;
        }
        if (*(void *)(a1 + 456)) {
          CGSReleaseRegion();
        }
        CABackingStoreReleaseImages((CABackingStore *)a1);
        if (v40) {
          int v37 = (*(uint64_t (**)(uint64_t))(*(void *)v40 + 72))(v40) + 1;
        }
        else {
          int v37 = 0;
        }
        *(_DWORD *)(v36 + 56) = v37;
        *(void *)(v36 + 48) = 0;
        *(void *)(a1 + 472) = 0;
        *(unsigned char *)(a1 + 492) = 6;
        *(void *)(a1 + 408) = 0;
LABEL_48:
        pthread_cond_broadcast((pthread_cond_t *)(a1 + 80));
        CGDisplayListRelease();
        CGColorRelease(color);
        return pthread_mutex_unlock(v17);
      }
    }
    else
    {
      int v28 = 1;
    }
    uint64_t v41 = v19;
    for (unsigned __int32 i = 0; i != v28; ++i)
    {
      CABackingStoreBeginUpdate_(a1, a2, a3, (CA *)v51, SHIDWORD(v51), a6, v25, i, &v50);
      if (*(void *)(a1 + 416))
      {
        if (v21)
        {
          CGContextSetEDRTargetHeadroom();
          CGDisplayListDrawInContext();
        }
        else
        {
          *(void *)(a1 + 48CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = pthread_self();
          pthread_mutex_unlock(v17);
          a8(*(void *)(a1 + 416), v41);
          pthread_mutex_lock(v17);
          *(void *)(a1 + 48CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
        }
        if (*(void *)(a1 + 416))
        {
          uint64_t v30 = *(void *)(a1 + 408);
          uint64_t v31 = *(void *)(v30 + 16);
          uint64_t v32 = *(void *)(v30 + 24);
          if (*(void *)(a1 + 400))
          {
            CGContextGetEDRTargetHeadroom();
            *(_DWORD *)(*(void *)(a1 + 400) + 6CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v33;
          }
          if (v31)
          {
            uint64_t v34 = *(void *)(v31 + 24);
            uint64_t v35 = *(CGContext **)(a1 + 416);
            if ((*(_WORD *)(a1 + 492) & 0x1000) != 0)
            {
              if (v35) {
                MEMORY[0x185323DC0](v35, 0x10A0C40A7187C27);
              }
            }
            else
            {
              CAReleaseCachedCGContext(v35);
            }
            *(void *)(a1 + 416) = 0;
            atomic_fetch_add((atomic_uint *volatile)(v34 + 4), 1u);
            uint64_t v25 = a7;
          }
          else
          {
            uint64_t v25 = a7;
            if (v32)
            {
              CAReleaseCachedCGContext(*(CGContext **)(a1 + 416));
              *(void *)(a1 + 416) = 0;
              *(_WORD *)(a1 + 492) |= 0x800u;
            }
          }
        }
      }
    }
    uint64_t v26 = *(void *)(a1 + 408);
    goto LABEL_40;
  }
  if ((a5 & 2) != 0 || BYTE9(v47))
  {
    CABackingStoreReleaseImages((CABackingStore *)a1);
    CABackingStoreDeleteBuffer(*(void **)(a1 + 400));
    *(unsigned char *)(*(void *)(a1 + 400) + 65) = 1;
  }
  CACGContextEvaluator::~CACGContextEvaluator((CGColorSpaceRef *)v44);
  return pthread_mutex_unlock(v17);
}

void CABackingStoreReleaseImages(CABackingStore *a1)
{
  uint64_t v2 = (atomic_uint *)*((void *)a1 + 53);
  if (v2)
  {
    if (atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
    }
    *((void *)a1 + 53) = 0;
  }
  uint64_t v3 = (CGImage *)*((void *)a1 + 54);
  if (v3)
  {
    CGImageRelease(v3);
    *((void *)a1 + 54) = 0;
  }
}

void CACGContextEvaluator::~CACGContextEvaluator(CGColorSpaceRef *this)
{
  CGColorSpaceRelease(this[3]);
  CGDisplayListRelease();
  CGContextRelease(this[5]);
  CGColorRelease(this[8]);
  CGContextGetDelegate();
  for (uint64_t i = 0; i != 384; i += 16)
    CGContextDelegateSetCallback();
  CGContextRelease(this[7]);
}

uint64_t CACGContextEvaluator::suggested_format(CACGContextEvaluator *this, int a2, CGColor **a3, int a4)
{
  if (!*((unsigned char *)this + 72)) {
    return 0xFFFFFFFFLL;
  }
  if (a3 && !*((unsigned char *)this + 77) && *((void *)this + 8) && (a2 & 1) == 0)
  {
    *a3 = CGColorCreateCopyWithAlpha(*((CGColorRef *)this + 8), 1.0);
    return 9;
  }
  if (*((unsigned char *)this + 76))
  {
    BOOL v5 = *((unsigned char *)this + 79) == 0;
    LODWORD(v4) = 13;
    unsigned int v6 = 21;
    goto LABEL_15;
  }
  if (a4 && *((unsigned char *)this + 81) || *((unsigned char *)this + 80))
  {
    BOOL v5 = *((unsigned char *)this + 75) == 0;
    LODWORD(v4) = 13;
LABEL_14:
    unsigned int v6 = 18;
LABEL_15:
    if (v5) {
      return v6;
    }
    else {
      return v4;
    }
  }
  if (*((_DWORD *)this + 21) >= 0x10u)
  {
    BOOL v5 = *((unsigned char *)this + 75) == 0;
    LODWORD(v4) = 21;
    goto LABEL_14;
  }
  if (*((unsigned char *)this + 79))
  {
    if (a2) {
      return 33;
    }
    else {
      return 35;
    }
  }
  else if (*((unsigned char *)this + 75))
  {
    if (a2) {
      return 3;
    }
    else {
      return 1;
    }
  }
  else
  {
    if (*((unsigned char *)this + 74)) {
      uint64_t v4 = 10;
    }
    else {
      uint64_t v4 = 0xFFFFFFFFLL;
    }
    if (*((unsigned char *)this + 74) && (a2 & 1) == 0)
    {
      if (*((unsigned char *)this + 78)) {
        return 1;
      }
      else {
        return 18;
      }
    }
  }
  return v4;
}

void CAReleaseCachedCGContext(CGContext *a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&context_lock);
  uint64_t v2 = &context_list;
  while (1)
  {
    uint64_t v2 = (uint64_t *)*v2;
    if (!v2) {
      break;
    }
    if ((CGContext *)v2[2] == a1)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&context_lock);
      uint64_t v3 = v2[7];
      if (v3)
      {
        uint64_t v4 = *(atomic_uint **)(v3 + 336);
        if (v4)
        {
          if (atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1)
          {
            (**(void (***)(atomic_uint *))v4)(v4);
            (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
          }
          *(void *)(v3 + 336) = 0;
        }
      }
      BOOL v5 = (__IOSurface *)v2[6];
      if (v5)
      {
        IOSurfaceUnlock(v5, 0, 0);
        CFRelease((CFTypeRef)v2[6]);
        v2[6] = 0;
      }
      uint64_t v6 = v2[5];
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 + 72);
        if (v7) {
          CA::CG::Queue::flush(v7, 3, 0);
        }
        if (atomic_fetch_add((atomic_uint *volatile)(v6 + 8), 0xFFFFFFFF) == 1)
        {
          (**(void (***)(uint64_t))v6)(v6);
          (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
        }
        v2[5] = 0;
      }
      CGContextResetState();
      os_unfair_lock_lock((os_unfair_lock_t)&context_lock);
      *((unsigned char *)v2 + 64) = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)&context_lock);
      return;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&context_lock);

  CGContextRelease(a1);
}

void CABackingStoreBeginUpdate_(uint64_t a1, unsigned int a2, unsigned int a3, CA *a4, int a5, int a6, uint64_t a7, unsigned __int32 a8, unsigned char *a9)
{
  int32x2_t v9 = a9;
  if (*(void *)(a1 + 416)) {
    __assert_rtn("CABackingStoreBeginUpdate_", "CABackingStore.cpp", 1032, "!b->update_ctx");
  }
  int v10 = a5;
  uint64_t v14 = *(void *)(a1 + 408);
  uint64_t v15 = *(void *)(v14 + 16);
  uint64_t v16 = *(void *)(a1 + 448);
  if (!v15)
  {
    uint64_t v28 = *(void *)(v14 + 24);
    if (!v28) {
      goto LABEL_74;
    }
    *(unsigned char *)(v28 + 69) = (a5 & 0x400) != 0;
    unint64_t v29 = (CGContext *)CAGetCachedCGIOSurfaceContext(v28, a6, a7);
    if (!v29) {
      goto LABEL_74;
    }
    uint64_t v30 = v29;
    if (a9[16]) {
      CGContextClearRect(v29, *MEMORY[0x1E4F1DB10]);
    }
    if (!*(void *)(a1 + 456)) {
      goto LABEL_67;
    }
    unsigned int v31 = a3;
    uint64_t v32 = *(void *)a9;
    int v33 = *(CA::CG::IOSurfaceDrawable **)(*(void *)a9 + 24);
    if (v33)
    {
      CGImageRef v34 = CA::CG::IOSurfaceDrawable::copy_cgimage_iosurface(v33);
    }
    else
    {
      uint64_t v53 = *(CA::Render::Shmem **)(v32 + 16);
      if (!v53) {
        goto LABEL_58;
      }
      CGImageRef v34 = CA::Render::Shmem::copy_cgimage(v53, *(CGColorSpace **)(v32 + 8), 0, 0);
    }
    uint64_t v54 = v34;
    if (v34)
    {
      CGContextSaveGState(v30);
      CGContextReplacePathWithShapePath();
      CGContextClip(v30);
      if (CGImageIsMask(v54))
      {
        CGContextSetCompositeOperation();
        v64.origin.x = 0.0;
        v64.origin.y = 0.0;
        v64.size.width = (double)a2;
        v64.size.height = (double)v31;
        CGContextFillRect(v30, v64);
      }
      CGContextSetCompositeOperation();
      v65.origin.x = 0.0;
      v65.origin.y = 0.0;
      v65.size.width = (double)a2;
      v65.size.height = (double)v31;
      CGContextDrawImage(v30, v65, v54);
      CGContextRestoreGState(v30);
      CGImageRelease(v54);
LABEL_67:
      if (v16)
      {
        CGContextReplacePathWithShapePath();
        CGContextClip(v30);
      }
LABEL_69:
      if ((v10 & 2) != 0)
      {
        if (!a9[16]) {
          CGContextClearRect(v30, *MEMORY[0x1E4F1DB10]);
        }
        v10 &= ~2u;
      }
      *(void *)(a1 + 416) = v30;
      goto LABEL_74;
    }
LABEL_58:
    if (*(void *)(a1 + 448))
    {
      CGSReleaseRegion();
      *(void *)(a1 + 448) = 0;
    }
    goto LABEL_69;
  }
  uint64_t v18 = *(int32x2_t **)(v15 + 24);
  if (v18[4].i32[0] <= a8)
  {
LABEL_65:
    atomic_fetch_add((atomic_uint *volatile)v18 + 1, 1u);
LABEL_74:
    *((_DWORD *)v9 + 3) = v10;
    return;
  }
  uint64_t v19 = a4;
  unsigned __int32 v20 = v18[3].u32[1];
  if ((unsigned __int32)v18[3].i32[0] >> a8 <= 1) {
    int v21 = 1;
  }
  else {
    int v21 = (unsigned __int32)v18[3].i32[0] >> a8;
  }
  int v22 = v20 >> a8;
  if (v20 >> a8 <= 1) {
    int v22 = 1;
  }
  unsigned int v59 = v22;
  unsigned int v60 = v21;
  uint8x8_t v23 = (CA::Render *)v18[1].u32[1];
  if (a8)
  {
    unsigned int v57 = a4;
    uint64_t v24 = 0;
    int32x2_t v25 = v18[2];
    unsigned __int32 v26 = a8;
    do
    {
      uint32x2_t v61 = (uint32x2_t)v25;
      v24 += CA::Render::format_rowbytes(v23, v25.u32[0]) * v25.u32[1];
      int8x8_t v27 = (int8x8_t)vcgt_u32(v61, (uint32x2_t)0x100000001);
      int32x2_t v25 = vsub_s32((int32x2_t)vand_s8((int8x8_t)vshr_n_u32(v61, 1uLL), v27), (int32x2_t)vmvn_s8(v27));
      --v26;
    }
    while (v26);
    uint8x8_t v23 = (CA::Render *)v18[1].u32[1];
    int32x2_t v9 = a9;
    uint64_t v19 = (CA *)v57;
  }
  else
  {
    uint64_t v24 = 0;
  }
  double v58 = (char *)v18 + v18[1].i32[0] + v24;
  if ((unsigned __int32)v18[2].i32[0] >> a8 <= 1) {
    unsigned int v35 = 1;
  }
  else {
    unsigned int v35 = (unsigned __int32)v18[2].i32[0] >> a8;
  }
  size_t v36 = CA::Render::format_rowbytes(v23, v35);
  if (!a8) {
    goto LABEL_29;
  }
  unsigned int v37 = v60;
  if (v60 <= v59) {
    unsigned int v37 = v59;
  }
  if ((v10 & 0x208) == 0 && v37 >= 8)
  {
LABEL_29:
    if ((v10 & 0x200) != 0) {
      abort();
    }
    uint8x8_t v38 = CAGetCachedCGBitmapContext_(v58, v60, v59, v19, v36, *(CGColorSpaceRef *)(v14 + 8));
    if (v38)
    {
      uint64_t v39 = (CGContext *)*((void *)v38 + 2);
      if (v39)
      {
        if (a8)
        {
          if (v16)
          {
            CGSTransformRegion();
            CGContextReplacePathWithShapePath();
            CGSReleaseRegion();
            CGContextClip(v39);
          }
          CGContextScaleCTM(v39, (double)v60 / (double)a2, (double)v59 / (double)a3);
        }
        else if (v16)
        {
          CGContextReplacePathWithShapePath();
          CGContextClip(v39);
        }
        if ((v10 & 2) != 0)
        {
          CGContextClearRect(v39, *MEMORY[0x1E4F1DB10]);
          v10 &= ~2u;
        }
      }
    }
    else
    {
      uint64_t v39 = 0;
    }
    *(void *)(a1 + 416) = v39;
    *(_WORD *)(a1 + 492) &= ~0x1000u;
    goto LABEL_65;
  }
  unsigned __int32 v40 = v18[3].u32[1];
  uint64_t v41 = (CA::Render *)v18[1].u32[1];
  char v42 = a8 - 1;
  unsigned int v43 = (unsigned __int32)v18[3].i32[0] >> (a8 - 1);
  if (v43 <= 1) {
    vImagePixelCount v44 = 1;
  }
  else {
    vImagePixelCount v44 = v43;
  }
  if (v40 >> v42 <= 1) {
    vImagePixelCount v45 = 1;
  }
  else {
    vImagePixelCount v45 = v40 >> v42;
  }
  uint64_t v46 = 0;
  if (a8 != 1)
  {
    int32x2_t v47 = v18[2];
    unsigned __int32 v48 = a8 - 1;
    do
    {
      uint32x2_t v62 = (uint32x2_t)v47;
      v46 += CA::Render::format_rowbytes(v41, v47.u32[0]) * v47.u32[1];
      int8x8_t v49 = (int8x8_t)vcgt_u32(v62, (uint32x2_t)0x100000001);
      int32x2_t v47 = vsub_s32((int32x2_t)vand_s8((int8x8_t)vshr_n_u32(v62, 1uLL), v49), (int32x2_t)vmvn_s8(v49));
      --v48;
    }
    while (v48);
    uint64_t v41 = (CA::Render *)v18[1].u32[1];
  }
  uint64_t v50 = v18[1].i32[0];
  if ((unsigned __int32)v18[2].i32[0] >> v42 <= 1) {
    unsigned int v51 = 1;
  }
  else {
    unsigned int v51 = (unsigned __int32)v18[2].i32[0] >> v42;
  }
  size_t v52 = CA::Render::format_rowbytes(v41, v51);

  CA::downsample_image(v19, (char *)v18 + v50 + v46, v52, v44, v45, (unsigned __int16 *)v58, v36, 0, 0.0, 0.0, (double)v60, (double)v59, a9);
}

unsigned char *CAGetCachedCGBitmapContext_(void *a1, unsigned int a2, unsigned int a3, unsigned int a4, size_t a5, CGColorSpaceRef space)
{
  uint64_t v6 = space;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a4 <= 0x23 && ((0x1FFFFFF2FuLL >> a4) & 1) == 0) {
    return 0;
  }
  if (a4 > 0x23)
  {
    uint64_t v14 = 0;
    uint32_t v12 = 0;
    size_t v13 = 0;
  }
  else
  {
    uint32_t v12 = dword_184999348[a4];
    size_t v13 = dword_184999500[a4];
    uint64_t v14 = dword_1849993D8[a4];
    if (((0x7FFD9FFFuLL >> a4) & 1) == 0) {
      goto LABEL_9;
    }
  }
  if (CGColorSpaceUsesExtendedRange(space)) {
    uint64_t v6 = (CGColorSpace *)CAGetColorSpace(0x1Du);
  }
LABEL_9:
  if (a4 == 9) {
    uint64_t v6 = 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&context_lock);
  uint64_t v15 = (unsigned char *)context_list;
  if (context_list)
  {
    while (v15[64]
         || *((_DWORD *)v15 + 2)
         || *((_DWORD *)v15 + 8) != v12
         || *((CGColorSpace **)v15 + 3) != v6 && !CGColorSpaceEqualToColorSpace())
    {
      uint64_t v15 = *(unsigned char **)v15;
      if (!v15) {
        goto LABEL_18;
      }
    }
    if (CGBitmapContextSetData())
    {
      v15[64] = 1;
    }
    else
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unsigned __int32 v20 = x_log_category_utilities;
        if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218496;
          size_t v22 = v13;
          __int16 v23 = 2048;
          uint64_t v24 = v14;
          __int16 v25 = 1024;
          uint32_t v26 = v12;
          _os_log_impl(&dword_184668000, v20, OS_LOG_TYPE_ERROR, "CGBitmapContextSetData failed, bpc %zu, bpp %zu, info %u\n", buf, 0x1Cu);
        }
      }
      uint64_t v15 = 0;
    }
    goto LABEL_20;
  }
LABEL_18:
  os_unfair_lock_unlock((os_unfair_lock_t)&context_lock);
  CGContextRef v16 = CGBitmapContextCreate(a1, a2, a3, v13, a5, v6, v12);
  if (!v16) {
    return 0;
  }
  CGContextRef v17 = v16;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v15 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x48uLL, 0x743898A5uLL);
  *((_DWORD *)v15 + 2) = 0;
  *((void *)v15 + 2) = v17;
  *((void *)v15 + 3) = CGColorSpaceRetain(v6);
  *((_DWORD *)v15 + 8) = v12;
  v15[64] = 1;
  os_unfair_lock_lock((os_unfair_lock_t)&context_lock);
  *(void *)uint64_t v15 = context_list;
  context_list = (uint64_t)v15;
LABEL_20:
  os_unfair_lock_unlock((os_unfair_lock_t)&context_lock);
  return v15;
}

uint64_t CABackingStorePrepareUpdates_(unint64_t a1, unint64_t a2, unint64_t a3, uint64_t this, unsigned int a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v122 = *MEMORY[0x1E4F143B8];
  __int16 v14 = *(_WORD *)(a1 + 492);
  uint64_t v16 = *(void *)(a1 + 144);
  uint64_t v15 = *(void *)(a1 + 152);
  BOOL v17 = v16 == a2 && v15 == a3;
  unint64_t v116 = a2;
  if (v17)
  {
    uint64_t v23 = 1;
    if ((a5 & 0x10) == 0 && (*(_WORD *)(a1 + 492) & 0x400) == 0)
    {
      if ((*(_WORD *)(a1 + 492) & 0x200) != 0 || !*(void *)(a1 + 440)) {
        return 0;
      }
      CGSBoundingShapeGetRegion();
      if ((a5 & 0x80) != 0)
      {
        double v119 = 0.0;
        long long buf = 0x3FF0000000000000uLL;
        long long v120 = xmmword_184997E00;
        double v24 = (double)a3;
        double v121 = (double)a3;
        CGSTransformRegion();
        CGSReleaseRegion();
      }
      else
      {
        double v24 = (double)a3;
      }
      long long buf = 0uLL;
      double v119 = (double)v116;
      *(double *)&long long v120 = v24;
      uint64_t v23 = CGSRectInRegion();
      if ((v23 & 1) == 0)
      {
        CGSIntersectRegionWithRect();
        if (CGSRegionIsEmpty()) {
          CGSReleaseRegion();
        }
      }
      CGSReleaseRegion();
      a2 = v116;
      if ((v23 & 1) == 0) {
        return 0;
      }
    }
  }
  else
  {
    BOOL v18 = v16 == a2 || v16 == 0;
    __int16 v19 = v14 & 0x2000;
    if (!v18) {
      __int16 v19 = 0x2000;
    }
    __int16 v20 = v19 | v14 & 0x9FFF;
    BOOL v21 = v15 == a3 || v15 == 0;
    __int16 v22 = v14 & 0x4000;
    if (!v21) {
      __int16 v22 = 0x4000;
    }
    *(_WORD *)(a1 + 492) = v22 | v20;
    *(void *)(a1 + 144) = a2;
    *(void *)(a1 + 152) = a3;
    uint64_t v23 = 1;
  }
  if ((a5 & 0x100) != 0)
  {
    if (a6) {
      BOOL v26 = 0;
    }
    else {
      BOOL v26 = a7 == 0;
    }
    int v25 = !v26;
  }
  else
  {
    int v25 = 0;
  }
  if ((a5 & 0x204) != 0) {
    int v27 = 0;
  }
  else {
    int v27 = v25;
  }
  BOOL v29 = a2 >> 6 < 0x7F && a3 >> 6 < 0x7F;
  {
    LODWORD(a2) = v116;
  }
    && CA::Render::format_rowbytes((CA::Render *)this, a2) > v30)
  {
    BOOL v29 = 0;
  }
  unint64_t v111 = v30;
  __int16 v31 = *(_WORD *)(a1 + 492);
  char v32 = !v29;
  if (v32)
  {
    unint64_t v33 = v116;
  }
  else
  {
    unint64_t v33 = v116;
    if ((*(_WORD *)(a1 + 492) & 0x2000) != 0)
    {
      if (this > 0x25) {
        unsigned int v34 = 0;
      }
      else {
        unsigned int v34 = dword_184999468[this];
      }
      unint64_t v35 = v34;
      unint64_t v36 = CA::Render::format_rowbytes((CA::Render *)this, (v116 + ((a1 >> 4) & 0x1F) + 31) & 0xFFFFFFE0);
      if (v36 / v35 >= v116 + 0x7FFF) {
        unint64_t v33 = v116 + 0x7FFF;
      }
      else {
        unint64_t v33 = v36 / v35;
      }
      __int16 v31 = *(_WORD *)(a1 + 492);
    }
  }
  if ((v31 & 0x4000) != 0) {
    char v37 = v32;
  }
  else {
    char v37 = 1;
  }
  unint64_t v114 = a3;
  if ((v37 & 1) == 0) {
    unint64_t v114 = (a3 + ((a1 >> 4) & 0x1F) + 31) & 0xFFFFFFFFFFFFFFE0;
  }
  int v113 = (CA::Render *)v33;
  if (v27 && CAIOSurfaceIsAcceleratable(a7, v33, v114, this))
  {
    int v38 = 1;
  }
  else
  {
    int v38 = 0;
    if (this <= 0x23 && ((0x1FFFFFF2FuLL >> this) & 1) == 0)
    {
      int v38 = 0;
      if ((0xC99B4EB03uLL >> this)) {
        this = 13;
      }
      else {
        this = 17;
      }
    }
  }
  uint64_t v39 = *(void *)(a1 + 160);
  if ((this - 8) > 0x16) {
    unsigned int v40 = 3;
  }
  else {
    unsigned int v40 = dword_184999590[(this - 8)];
  }
  if (CGColorSpaceGetNumberOfComponents(*(CGColorSpaceRef *)(a1 + 160)) != v40) {
    uint64_t v39 = CA::Render::format_default_colorspace((CA::Render *)this);
  }
  uint64_t v115 = this;
  if (((this < 0x1D) & (0x17826000u >> this)) != 0 || (this - 33) <= 2)
  {
    uint64_t v42 = CAGetColorSpace(0x1Du);
    unint64_t v41 = v116;
    if (v39 == v42)
    {
      uint64_t v43 = CAGetColorSpace(0x1Cu);
      unint64_t v41 = v116;
      uint64_t v39 = v43;
    }
  }
  else
  {
    unint64_t v41 = v116;
  }
  float v107 = (CGColorSpace *)v39;
  char v108 = 0;
  unsigned int v109 = a5;
  uint64_t v44 = a1 + 400;
  uint64_t v110 = a1;
  uint64_t v45 = *(void *)(a1 + 400);
  int v46 = (v38 ^ 1) & (a5 >> 2);
  double v47 = (double)v41;
  unsigned int v48 = a3;
  double v49 = (double)a3 * (double)v41;
  uint64_t v112 = v45;
  uint64_t v50 = v45;
  float v106 = (void *)v44;
  do
  {
    while (1)
    {
      unsigned int v51 = (void *)v44;
      uint64_t v44 = v50;
      size_t v52 = *(CA::Render::Shmem **)(v50 + 16);
      if (v52)
      {
        if ((CA::Render::Shmem::set_volatile(v52, 0, 0) & 1) == 0)
        {
          LOBYTE(v23) = (v44 == v112) | v23;
          goto LABEL_151;
        }
      }
      else
      {
        uint64_t v53 = *(os_unfair_lock_s **)(v50 + 24);
        if (!v53) {
          goto LABEL_152;
        }
        if ((CA::CG::AccelDrawable::set_volatile(v53, 0) & 1) == 0)
        {
          if (*(void *)(v44 + 40))
          {
            CGSReleaseRegion();
            *(void *)(v44 + 4CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
          }
          uint64_t v23 = (v44 == v112) | v23;
          char v108 = 1;
        }
      }
      uint64_t v54 = *(void *)(v44 + 16);
      if (v54)
      {
        uint64_t v55 = v23;
        uint64_t v56 = *(_DWORD **)(v54 + 24);
        int v57 = v56[3];
        unsigned int v58 = v56[4];
        unsigned int v59 = v56[5];
        if (v58 <= 1) {
          unsigned int v60 = 1;
        }
        else {
          unsigned int v60 = v56[4];
        }
        unint64_t v61 = CA::Render::format_rowbytes((CA::Render *)v56[3], v60);
        int v62 = *(_DWORD *)(*(void *)(v54 + 24) + 32) > 1u;
      }
      else
      {
        int v63 = *(_DWORD **)(v44 + 24);
        if (!v63) {
          goto LABEL_152;
        }
        uint64_t v55 = v23;
        unint64_t v61 = 0;
        int v62 = 0;
        int v57 = v63[4];
        unsigned int v58 = v63[11];
        unsigned int v59 = v63[12];
      }
      BOOL v17 = v57 == v115;
      unsigned int v48 = a3;
      BOOL v66 = v17 && v58 >= v116 && v59 >= a3 && v62 == v46;
      if (!v66 || (!((v58 - v116) >> 15) ? (BOOL v67 = (v59 - a3) >> 15 == 0) : (BOOL v67 = 0), !v67))
      {
LABEL_150:
        LOBYTE(v23) = (v44 == v112) | v55;
LABEL_151:
        CABackingStoreDeleteBuffer((void *)v44);
        goto LABEL_152;
      }
      BOOL v68 = v113 == (CA::Render *)v58 && v114 == v59;
      BOOL v69 = v68;
      char v70 = v68 ? 1 : v32;
      if (v70)
      {
        if (!v69) {
          goto LABEL_150;
        }
      }
      else
      {
        if (v111 && v61 > v111) {
          goto LABEL_150;
        }
        if (initialized != -1) {
          dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
        }
        if ((double)*(float *)&dword_1EB2ACB30 * -0.01 + 1.0 > 1.0
          || (double v71 = 0.0, (double)*(float *)&dword_1EB2ACB30 * -0.01 + 1.0 >= 0.0))
        {
          double v71 = 1.0;
          if ((double)*(float *)&dword_1EB2ACB30 * -0.01 + 1.0 <= 1.0) {
            double v71 = (double)*(float *)&dword_1EB2ACB30 * -0.01 + 1.0;
          }
        }
        if (v49 < (double)v59 * (double)v58 * v71) {
          goto LABEL_150;
        }
      }
      char v72 = *(void *)(v44 + 16) ? v38 : 0;
      uint64_t v23 = v55;
      if ((v72 & 1) != 0 || ((*(void *)(v44 + 24) != 0) & ~v38) != 0) {
        break;
      }
      {
        if (v44 == v112)
        {
          uint64_t v73 = v112;
          goto LABEL_153;
        }
        if (!*(void *)v44 || (CABackingStoreSynchronize(v110, a8, *(unsigned int *)(v44 + 56), 0) & 1) != 0) {
          goto LABEL_152;
        }
        break;
      }
      uint64_t v50 = *(void *)v44;
      if (!*(void *)v44)
      {
        CABackingStoreSynchronize(v110, a8, (*(_DWORD *)(v44 + 56) + 1), 30);
          goto LABEL_152;
        break;
      }
    }
    uint64_t v50 = *(void *)v44;
  }
  while (*(void *)v44);
  LOBYTE(v23) = (v44 == v112) | v55;
  CABackingStoreDeleteBuffer((void *)v44);
  if (!BYTE13(ca_debug_options))
  {
LABEL_152:
    uint64_t v73 = v44;
LABEL_153:
    uint64_t v74 = v110;
    unsigned int v75 = v109;
    goto LABEL_154;
  }
  if (x_log_hook_p())
  {
    uint64_t v74 = v110;
    x_log_();
    goto LABEL_240;
  }
  __n128 v104 = x_log_category_utilities;
  if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    uint64_t v74 = v110;
    *(void *)((char *)&buf + 4) = v110;
    _os_log_impl(&dword_184668000, v104, OS_LOG_TYPE_DEFAULT, "CoreAnimation: triple buffered backing store %p\n", (uint8_t *)&buf, 0xCu);
LABEL_240:
    uint64_t v73 = v44;
  }
  else
  {
    uint64_t v73 = v44;
    uint64_t v74 = v110;
  }
  unsigned int v75 = v109;
  unsigned int v48 = a3;
LABEL_154:
  if (v73 != *v106)
  {
    *unsigned int v51 = *(void *)v73;
    *(void *)uint64_t v73 = *v106;
    *float v106 = v73;
  }
  if (!v38)
  {
    if (!*(void *)(v73 + 24)) {
      goto LABEL_161;
    }
    goto LABEL_160;
  }
  if (*(void *)(v44 + 16))
  {
LABEL_160:
    LOBYTE(v23) = (v73 == v112) | v23;
    CABackingStoreDeleteBuffer((void *)v73);
  }
LABEL_161:
  unint64_t v76 = *(void *)(v44 + 16);
  uint64_t v77 = *(void *)(v73 + 24);
  *(unsigned char *)(v73 + 64) = (v75 & 0x80) != 0;
  *(unsigned char *)(v73 + 65) = 0;
  if (v76 | v77)
  {
    uint64_t v78 = v107;
    goto LABEL_193;
  }
  CABackingStoreDeleteBuffer((void *)v73);
  if ((v75 & 4) != 0 && ((unsigned int v81 = v114, v113 > 8) || v114 >= 9))
  {
    unsigned int v82 = 1;
    unsigned int v83 = v113;
    do
    {
      do
      {
        unsigned int v84 = v83;
        unsigned int v85 = v81;
        ++v82;
        v83 >>= 1;
        v81 >>= 1;
      }
      while (v84 > 0x11);
    }
    while (v85 > 0x11);
  }
  else
  {
    unsigned int v82 = 1;
  }
  LOBYTE(v23) = (v73 == v112) | v23;
  if (!v38)
  {
    unsigned int v86 = v113;
    unsigned int v92 = v114;
LABEL_188:
    unint64_t v76 = (unint64_t)CA::Render::Shmem::new_bitmap((CA::Render::Shmem *)v115, v86, v92, v116, v48, v82);
    uint64_t v77 = 0;
    *(void *)(v44 + 16) = v76;
    v75 &= ~2u;
    uint64_t v78 = v107;
    goto LABEL_192;
  }
  unsigned int v86 = v113;
  iosurface = CA::Render::create_iosurface((CA::Render *)v115, v113, v114, @"CA Whippet Drawable", v79, v80);
  if (!iosurface)
  {
    if ((0xC99B4EB03uLL >> v115)) {
      unsigned int v93 = 13;
    }
    else {
      unsigned int v93 = 17;
    }
    if ((0x1FFFFFF2FuLL >> v115)) {
      unsigned int v93 = v115;
    }
    if (v115 <= 0x23) {
      uint64_t v94 = v93;
    }
    else {
      uint64_t v94 = v115;
    }
    uint64_t v115 = v94;
    unsigned int v48 = a3;
    unsigned int v92 = v114;
    goto LABEL_188;
  }
  uint64_t v88 = iosurface;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v90 = (CA::CG::IOSurfaceDrawable *)malloc_type_zone_malloc(malloc_zone, 0x70uLL, 0x8BB15036uLL);
  uint64_t v78 = v107;
  if (v90)
  {
    if (v115 > 0x23) {
      int v91 = 0;
    }
    else {
      int v91 = dword_184999348[v115];
    }
    uint64_t v90 = CA::CG::IOSurfaceDrawable::IOSurfaceDrawable(v90, v88, v115, v91, v107, 0, 0, v116, a3);
  }
  *(void *)(v73 + 24) = v90;
  CFRelease(v88);
  unint64_t v76 = 0;
  uint64_t v77 = *(void *)(v73 + 24);
  char v108 = 1;
  unsigned int v48 = a3;
LABEL_192:
  if (!(v76 | v77)) {
    return 0;
  }
LABEL_193:
  long long v95 = *(CGColorSpace **)(v73 + 8);
  if (v95 != v78)
  {
    CGColorSpaceRelease(v95);
    CGColorSpaceRef v96 = CGColorSpaceRetain(v78);
    *(void *)(v73 + 8) = v96;
    uint64_t v97 = *(void *)(v73 + 24);
    if (v97)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v97 + 12));
      double v98 = *(CGColorSpace **)(v97 + 24);
      if (v98 != v78)
      {
        CGColorSpaceRelease(v98);
        *(void *)(v97 + 24) = CGColorSpaceRetain(v78);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v97 + 12));
      CGColorSpaceRef v96 = *(CGColorSpaceRef *)(v73 + 8);
      unsigned int v48 = a3;
    }
    if (v96 != *(CGColorSpaceRef *)(v112 + 8) && *(void *)(v73 + 40))
    {
      CGSReleaseRegion();
      *(void *)(v73 + 4CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
    }
  }
  if (*(void *)(v74 + 440)) {
    CGSBoundingShapeReset();
  }
  *(_WORD *)(v74 + 492) = *(_WORD *)(v74 + 492) & 0xF8FF | 0x200;
  uint64_t v99 = *(void *)(v73 + 40);
  for (uint64_t i = *(void **)(v74 + 400); i; uint64_t i = (void *)*i)
  {
    if (i == (void *)v73)
    {
      CGSNewEmptyRegion();
    }
    else if (i[5])
    {
      if (v23)
      {
        CGSReleaseRegion();
        i[5] = 0;
      }
      else
      {
        *(void *)&long long buf = 0;
        CGSUnionRegion();
        CGSReleaseRegion();
        i[5] = buf;
      }
    }
  }
  if ((v75 & 0x10) != 0)
  {
    long long buf = 0uLL;
    double v119 = v47;
    *(double *)&long long v120 = (double)a3;
    CGSNewRegionWithRect();
    __int16 v101 = (void *)v110;
  }
  else
  {
    __int16 v101 = (void *)v110;
    if (!(v23 & 1 | (v73 == v112)))
    {
      if (v99)
      {
        CGSDiffRegion();
      }
      else
      {
        long long buf = 0uLL;
        double v119 = v47;
        *(double *)&long long v120 = (double)a3;
        CGSNewRegionWithRect();
        CGSDiffRegion();
        CGSReleaseRegion();
      }
      if (CGSRegionIsEmpty()) {
        CGSReleaseRegion();
      }
    }
  }
  if (v99) {
    CGSReleaseRegion();
  }
  if (v76)
  {
    uint64_t v103 = *(void *)(v76 + 24);
    *(_DWORD *)(v103 + 24) = v116;
    *(_DWORD *)(v103 + 28) = v48;
    if ((v75 & 2) == 0) {
      goto LABEL_227;
    }
    CA::Render::ShmemBitmap::fill_pixels(v103, 0, 0);
    v75 &= ~2u;
    if ((v23 & 1) == 0) {
      goto LABEL_230;
    }
LABEL_228:
    v101[56] = 0;
    CGSReleaseRegion();
    v101[58] = 0;
  }
  else
  {
    if (v77)
    {
      *(_DWORD *)(v77 + 52) = v116;
      *(_DWORD *)(v77 + 56) = v48;
    }
LABEL_227:
    if (v23) {
      goto LABEL_228;
    }
LABEL_230:
    v101[56] = 0;
    if (!v101[58]) {
      CGSNewEmptyRegion();
    }
    if ((v75 & 0x80) != 0)
    {
      double v119 = 0.0;
      long long buf = 0x3FF0000000000000uLL;
      long long v120 = xmmword_184997E00;
      double v121 = (double)a3;
      CGSTransformRegion();
      CGSUnionRegion();
      CGSReleaseRegion();
    }
    else
    {
      CGSUnionRegion();
    }
    CGSReleaseRegion();
    v101[58] = 0;
  }
  *(void *)a9 = v112;
  *(_DWORD *)(a9 + 8) = v115;
  *(_DWORD *)(a9 + 12) = v75;
  *(unsigned char *)(a9 + 16) = v108 & 1;
  v101[57] = 0;
  v101[51] = v73;
  return 1;
}

atomic_uint *CA::Render::Image::decode(CA::Render::Image *this, CA::Render::Decoder *a2)
{
  v45[33] = *MEMORY[0x1E4F143B8];
  int v3 = CA::Render::Decoder::decode_int32(this);
  uint64_t v4 = (CA::Render::Image *)CA::Render::Decoder::decode_int8(this);
  unsigned int v5 = CA::Render::Decoder::decode_int8(this);
  unsigned int v6 = CA::Render::Decoder::decode_int32(this);
  unsigned int v7 = CA::Render::Decoder::decode_int32(this);
  unint64_t v34 = 0;
  memset(v45, 0, 256);
  if (v5 > 0x20) {
    goto LABEL_2;
  }
  unsigned int v11 = v7;
  if (v5)
  {
    for (uint64_t i = 0; i != v5; ++i)
      v45[i] = CA::Render::Decoder::decode_size_t(this);
    unint64_t v13 = v45[0];
    if (!is_mul_ok(v45[0], v11) || (unint64_t v14 = v45[0] * v11) == 0)
    {
LABEL_21:
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v28 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 134218496;
          *(void *)&uint8_t buf[4] = v13;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v5;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v11;
          _os_log_impl(&dword_184668000, v28, OS_LOG_TYPE_ERROR, "Failed to validate rowbytes: %zu, levels: %u height: %u", buf, 0x18u);
        }
      }
      goto LABEL_2;
    }
    uint64_t v15 = 1;
    LODWORD(v16) = v11;
    while (v5 != v15)
    {
      unint64_t v17 = v15;
      if (v16 <= 1) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = v16 >> 1;
      }
      unint64_t v18 = v45[v15];
      if (is_mul_ok(v18, v16))
      {
        unint64_t v19 = v18 * v16;
        if (v18 * v16)
        {
          uint64_t v15 = v17 + 1;
          BOOL v20 = __CFADD__(v14, v19);
          v14 += v19;
          if (!v20) {
            continue;
          }
        }
      }
      if (v17 >= v5) {
        break;
      }
      goto LABEL_21;
    }
  }
  if (!CA::Render::Decoder::decode_int8(this))
  {
    char v32 = 0;
    unint64_t v33 = 0;
    double v24 = (CGColorSpace *)CA::Render::Decoder::decode_data_async(this, &v34, (void (__cdecl **)(void *))&v32, &v33);
    if (v24)
    {
      int v25 = v24;
      BOOL v26 = v32;
      int v27 = v33;
      int32x2_t v9 = (atomic_uint *)CA::Render::Image::new_image(v4, v6, v11, v5, 0, v24, v45, (const unint64_t *)v32, (void (*)(const void *, void *))v33, v31);
      if (v9 || !v26) {
        goto LABEL_42;
      }
      v26(v25, v27);
    }
    else if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      BOOL v29 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v34;
        _os_log_impl(&dword_184668000, v29, OS_LOG_TYPE_ERROR, "Failed to decode_data_async, size: %zu", buf, 0xCu);
      }
    }
    int32x2_t v9 = 0;
    goto LABEL_42;
  }
  uint64_t v21 = CA::Render::Decoder::decode_object(this, 47);
  if (!v21)
  {
    CA::Render::Decoder::set_fatal_error(this, "Failed to decode shmem.");
    goto LABEL_2;
  }
  uint64_t v23 = v21;
  unint64_t v34 = *(void *)(v21 + 16);
  int32x2_t v9 = (atomic_uint *)CA::Render::Image::new_image(v4, v6, v11, v5, 0, (CGColorSpace **)v21, (CA::Render::Shmem *)v45, v22);
  if ((*(unsigned char *)(v23 + 13) & 8) != 0 && *(void *)(v23 + 16) >= 0x24uLL) {
    atomic_fetch_add(*(atomic_uint *volatile *)(v23 + 24), 0xFFFFFFFF);
  }
  if (atomic_fetch_add((atomic_uint *volatile)(v23 + 8), 0xFFFFFFFF) == 1) {
    (*(void (**)(uint64_t))(*(void *)v23 + 16))(v23);
  }
LABEL_42:
  if (v9)
  {
    unint64_t v30 = CA::Render::Image::data_size((CA::Render::Image *)v9);
    if (v30 <= v34)
    {
      v9[3] |= (v3 << 8) & 0xFEFFFFFF;
      CA::Render::Texture::decode((CA::Render::Texture *)v9, this);
      return v9;
    }
    CA::Render::Decoder::set_fatal_error(this, "Failed to re-create data_size, encoded: %zu,calculated: %zu", v34, v30);
    if (atomic_fetch_add(v9 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v9 + 16))(v9);
    }
  }
LABEL_2:
  uint64_t v44 = 0;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v41 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  *(_OWORD *)space = 0u;
  long long v38 = 0u;
  long long v36 = 0u;
  memset(buf, 0, sizeof(buf));
  CA::Render::Texture::Texture((CA::Render::Texture *)buf, 0, 0);
  buf[12] = 23;
  ++dword_1EB2ADE24;
  *(void *)long long buf = &unk_1ED02F328;
  DWORD1(v43) = 0;
  WORD4(v43) = 0;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  if (space[0])
  {
    CGColorSpaceRelease(space[0]);
    space[0] = CGColorSpaceRetain(0);
  }
  DWORD1(v43) = 1;
  double v8 = CA::Render::Texture::decode((CA::Render::Texture *)buf, this);
  CA::Render::Decoder::set_fatal_error(this, "Image failed to decode!", v8);
  CA::Render::Image::~Image((CA::Render::Image *)buf);
  return 0;
}

double CA::Render::Texture::decode(CA::Render::Texture *this, CA::Render::Decoder *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 6));
  *((void *)this + 6) = CA::Render::Decoder::decode_colorspace(a2);
  *((_DWORD *)this + 8) = CA::Render::Decoder::decode_int32(a2);
  *((_WORD *)this + 12) = CA::Render::Decoder::decode_int16(a2);
  *((_WORD *)this + 13) = CA::Render::Decoder::decode_int16(a2);
  *((_WORD *)this + 14) = CA::Render::Decoder::decode_int16(a2);
  *((_WORD *)this + 15) = CA::Render::Decoder::decode_int16(a2);
  if (*((unsigned char *)a2 + 18)) {
    goto LABEL_9;
  }
  int v4 = CA::Render::Decoder::decode_int32(a2);
  if (v4 == -2)
  {
    LODWORD(__dst) = CA::Render::Decoder::decode_int32(a2);
    DWORD1(__dst) = CA::Render::Decoder::decode_int32(a2);
    DWORD2(__dst) = CA::Render::Decoder::decode_int32(a2);
    HIDWORD(__dst) = CA::Render::Decoder::decode_int32(a2);
    unint64_t v6 = CA::Shape::new_shape((unsigned int *)&__dst);
    goto LABEL_10;
  }
  unsigned int v5 = v4;
  if (!v4) {
    goto LABEL_9;
  }
  if (v4 == -1)
  {
    unint64_t v6 = 1;
    goto LABEL_10;
  }
  if ((v4 - 131073) <= 0xFFFE000B)
  {
    CA::Render::Decoder::set_fatal_error(a2, "%s - size = %d", "decode_shape", v4);
LABEL_9:
    unint64_t v6 = 0;
    goto LABEL_10;
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  int v10 = malloc_type_zone_malloc(malloc_zone, 4 * v5, 0x8BB15036uLL);
  unint64_t v6 = (unint64_t)v10;
  if (v10)
  {
    _DWORD *v10 = 1;
    v10[1] = v5;
    v10[2] = v5;
    CA::Render::Decoder::decode_bytes(a2, v10 + 3, 4 * (v5 - 3));
  }
  else
  {
    CA::Render::Decoder::set_fatal_error(a2, "%s - failed shape allocation for size %d", "decode_shape", v5);
  }
LABEL_10:
  unsigned int v7 = (CA::Shape *)*((void *)this + 5);
  *((void *)this + 5) = v6;
  if (v7) {
    CA::Shape::unref(v7);
  }
  *((_DWORD *)this + 14) = CA::Render::Decoder::decode_int32(a2);
  if ((*((unsigned char *)this + 14) & 0x10) != 0)
  {
    long long __dst = 0uLL;
    CA::Render::Decoder::decode_bytes(a2, &__dst, 0x10uLL);
    double result = *(double *)&__dst;
    *(_OWORD *)((char *)this + 6CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = __dst;
  }
  return result;
}

uint64_t CA::Render::Decoder::decode_int16(CA::Render::Decoder *this)
{
  double v1 = (unsigned __int16 *)*((void *)this + 4);
  uint64_t v2 = (unsigned __int16 *)*((void *)this + 5);
  int v3 = v1 + 1;
  if (v1 + 1 <= v2)
  {
    uint64_t v4 = *v1;
    *((void *)this + 4) = v3;
  }
  else
  {
    CA::Render::Decoder::set_fatal_error(this, "%s - _buffer_point = %p, _buffer_end = %p", "decode_int16", *((const void **)this + 4), v2);
    return 0;
  }
  return v4;
}

CGColorSpaceRef CA::Render::Decoder::decode_colorspace(CA::Render::Decoder *this)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 18)) {
    return 0;
  }
  if (CA::Render::Decoder::decode_colorspace(void)::once != -1) {
    dispatch_once(&CA::Render::Decoder::decode_colorspace(void)::once, &__block_literal_global_46_13743);
  }
  char v2 = CA::Render::Decoder::decode_int8(this);
  CGColorSpaceRef v3 = 0;
  switch(v2)
  {
    case 0:
      return v3;
    case 1:
      unsigned int v4 = CA::Render::Decoder::decode_int8(this);
      if (v4 >= 0x20)
      {
        CA::Render::Decoder::set_fatal_error(this, "%s - enum %u out of range of %u", "decode_int8_enum", v4, 32);
        unsigned int v4 = 0;
      }
      unsigned int v5 = (CGColorSpace *)CAGetColorSpace(v4);
      CGColorSpaceRef v3 = v5;
      if (v5) {
        CFRetain(v5);
      }
      return v3;
    case 2:
      unint64_t v6 = (const void *)CA::Render::Decoder::decode_cfobject(this, 0);
      if (!v6) {
        goto LABEL_26;
      }
      unsigned int v7 = v6;
      CFTypeID v8 = CFGetTypeID(v6);
      CFTypeID v9 = v8;
      uint64_t v10 = 0;
      break;
    case 3:
      unsigned int v11 = *(CGColorSpace **)(*((void *)this + 9) + 448);
      return CGColorSpaceRetain(v11);
    case 4:
      CFTypeID TypeID = CFStringGetTypeID();
      CFStringRef v14 = (const __CFString *)CA::Render::Decoder::decode_cfobject(this, TypeID);
      CGColorSpaceRef v3 = (CGColorSpaceRef)v14;
      if (!v14) {
        return v3;
      }
      CGColorSpaceRef v15 = CGColorSpaceCreateWithName(v14);
      CFRelease(v3);
      return v15;
    default:
      CA::Render::Decoder::set_fatal_error(this, "%s - code = %d", "decode_colorspace", v2);
      return 0;
  }
  while (v8 != CA::Render::Decoder::decode_colorspace(void)::types[v10])
  {
    if (++v10 == 3)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unint64_t v16 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 134217984;
          CFTypeID v18 = v9;
          _os_log_impl(&dword_184668000, v16, OS_LOG_TYPE_ERROR, "decoded cfobject of unexpected type: %lu", buf, 0xCu);
        }
      }
      CFRelease(v7);
LABEL_26:
      unsigned int v7 = (const void *)*MEMORY[0x1E4F1D260];
      break;
    }
  }
  if (!v7) {
    return 0;
  }
  CGColorSpaceRef v3 = CGColorSpaceCreateWithPropertyList(v7);
  CFRelease(v7);
  return v3;
}

CA::Render::Texture *CA::Render::Shmem::copy_image(CA::Render::Shmem *this, CGColorSpace *a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *((void *)this + 2);
  if (v2 < 0x24 || (*((unsigned char *)this + 13) & 4) != 0) {
    return 0;
  }
  unsigned int v4 = (atomic_uint *)*((void *)this + 3);
  uint64_t v5 = v4[8];
  uint64_t v35 = v4[4];
  uint64_t v36 = v4[5];
  if (v5 >= 0x21)
  {
    if (x_log_hook_p())
    {
LABEL_5:
      x_log_();
      return 0;
    }
    uint64_t v21 = x_log_category_render;
    if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)long long buf = 67109632;
    *(_DWORD *)long long v38 = v35;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v36;
    *(_WORD *)long long v39 = 1024;
    *(_DWORD *)&v39[2] = v5;
    __int16 v22 = "Bogus ShmemBitmap : [%u x %u], %u levels";
    uint64_t v23 = v21;
    uint32_t v24 = 20;
LABEL_42:
    _os_log_impl(&dword_184668000, v23, OS_LOG_TYPE_ERROR, v22, buf, v24);
    return 0;
  }
  uint64_t v6 = v4[2];
  unsigned int v7 = (char *)v4 + v6;
  if ((v6 & 0x80000000) != 0 || (CFTypeID v8 = (char *)v4 + v2, v8 < v7))
  {
    if (x_log_hook_p()) {
      goto LABEL_5;
    }
    uint64_t v25 = x_log_category_render;
    if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)long long buf = 134218240;
    *(void *)long long v38 = v7;
    *(_WORD *)&v38[8] = 2048;
    *(void *)long long v39 = v4;
    __int16 v22 = "Bogus ShmemBitmap data pointer: %p, Shmem data pointer: %zu";
    uint64_t v23 = v25;
    goto LABEL_41;
  }
  unint64_t v33 = v8;
  unint64_t v34 = (CGColorSpace *)((char *)v4 + v6);
  uint64_t v10 = (CA::Render *)v4[3];
  MEMORY[0x1F4188790](this);
  uint64_t v12 = (char *)&v33 - ((v11 + 15) & 0xFFFFFFFF0);
  bzero(v12, v11);
  if (v5)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    while (1)
    {
      unsigned int v15 = v35 >> v13 <= 1 ? 1 : v35 >> v13;
      unint64_t v16 = v36 >> v13 <= 1 ? 1 : v36 >> v13;
      unint64_t v17 = CA::Render::format_rowbytes(v10, v15);
      unint64_t v18 = v17;
      *(void *)&v12[8 * v13] = v17;
      if (!is_mul_ok(v17, v16)) {
        break;
      }
      unint64_t v19 = v17 * v16;
      if (!(v17 * v16)) {
        break;
      }
      BOOL v20 = __CFADD__(v14, v19);
      v14 += v19;
      if (v20) {
        break;
      }
      if (v5 == ++v13) {
        goto LABEL_29;
      }
    }
    if (x_log_hook_p()) {
      goto LABEL_5;
    }
    uint64_t v29 = x_log_category_render;
    if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)long long buf = 134218752;
    *(void *)long long v38 = v18;
    *(_WORD *)&v38[8] = 1024;
    *(_DWORD *)long long v39 = v35;
    *(_WORD *)&v39[4] = 1024;
    *(_DWORD *)&v39[6] = v36;
    __int16 v40 = 1024;
    int v41 = v13;
    __int16 v22 = "Bogus ShmemBitmap rowbytes: %zu, width: %u, height: %u, level: %u";
    uint64_t v23 = v29;
    uint32_t v24 = 30;
    goto LABEL_42;
  }
  uint64_t v14 = 0;
LABEL_29:
  BOOL v26 = v34;
  if (__CFADD__(v34, v14) || (char *)v34 + v14 > v33)
  {
    if (x_log_hook_p()) {
      goto LABEL_5;
    }
    uint64_t v30 = x_log_category_render;
    if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)long long buf = 134218240;
    *(void *)long long v38 = v26;
    *(_WORD *)&v38[8] = 2048;
    *(void *)long long v39 = v14;
    __int16 v22 = "Bogus ShmemBitmap data pointer: %p, total size: %zu";
    uint64_t v23 = v30;
LABEL_41:
    uint32_t v24 = 22;
    goto LABEL_42;
  }
  int v27 = CA::Render::Image::new_image(v10, v35, v36, v5, a2, v34, (unint64_t *)v12, (const unint64_t *)CA::Render::release_shmem_bitmap, (void (*)(const void *, void *))this, v32);
  uint64_t v28 = v27;
  if (v27)
  {
    atomic_fetch_add(v4, 1u);
    if (!atomic_fetch_add((atomic_uint *volatile)this + 2, 1u)) {
      atomic_fetch_add((atomic_uint *volatile)this + 2, 0xFFFFFFFF);
    }
    CA::Render::Image::set_shmem(v27, this);
    *((_DWORD *)v28 + 9) = v4[1];
  }
  return v28;
}

unint64_t CA::Render::format_rowbytes(CA::Render *this, unsigned int a2)
{
  if (this > 0x25) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = dword_184999468[this];
  }
  unint64_t result = v3 * (unint64_t)a2;
  {
                                                                       + 1)
                                                                     - 1)) != 0)
      return v5
    else {
  }
    }
  return result;
}

CA::Render::Texture *CA::Render::Image::new_image(CA::Render::Image *this, unsigned int a2, unsigned int a3, unsigned int a4, CGColorSpace *a5, CGColorSpace *a6, unint64_t *a7, const unint64_t *a8, void (*a9)(const void *, void *), void *a10)
{
  uint64_t v10 = 0;
  if (a4 && a3 && a2 && a7)
  {
    unsigned int v18 = this;
    uint64_t v19 = a4;
    if (a6)
    {
      uint64_t v10 = 0;
      unint64_t v20 = *a7;
      if (!is_mul_ok(*a7, a3)) {
        return v10;
      }
      unint64_t v21 = v20 * a3;
      if (!v21) {
        return v10;
      }
      uint64_t v22 = 1;
      LODWORD(v23) = a3;
      do
      {
        if (a4 == v22) {
          goto LABEL_18;
        }
        unint64_t v24 = v22;
        if (v23 <= 1) {
          unint64_t v23 = 1;
        }
        else {
          unint64_t v23 = v23 >> 1;
        }
        unint64_t v25 = a7[v22];
        if (!is_mul_ok(v25, v23)) {
          break;
        }
        unint64_t v26 = v25 * v23;
        if (!(v25 * v23)) {
          break;
        }
        uint64_t v22 = v24 + 1;
        BOOL v27 = __CFADD__(v21, v26);
        v21 += v26;
      }
      while (!v27);
      if (v24 < a4) {
        return 0;
      }
LABEL_18:
      if (this > 0x25) {
        unsigned int v28 = 0;
      }
      else {
        unsigned int v28 = dword_184999468[this];
      }
      if (v28 * (unint64_t)a2 > v20) {
        return 0;
      }
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v10 = (CA::Render::Texture *)malloc_type_zone_malloc(malloc_zone, 8 * v19 + 160, 0x8BB15036uLL);
    if (v10)
    {
      if (a5 && CGColorSpaceIsUncalibrated()) {
        a5 = 0;
      }
      uint64_t v30 = CA::Render::Texture::Texture(v10, a2, a3);
      *((unsigned char *)v10 + 12) = 23;
      ++dword_1EB2ADE24;
      *(void *)uint64_t v10 = &unk_1ED02F328;
      *((void *)v10 + 12) = a6;
      *((void *)v10 + 13) = a8;
      *((_DWORD *)v10 + 37) = 0;
      *((void *)v10 + 14) = a9;
      *((void *)v10 + 15) = 0;
      *((void *)v10 + 16) = 0;
      *((void *)v10 + 17) = 0;
      *((unsigned char *)v10 + 152) = v18;
      *((unsigned char *)v10 + 153) = a4;
      CA::Render::Texture::set_colorspace(v30, a5);
      if (((v18 < 0x24) & (0xC99B4EB03uLL >> v18)) != 0) {
        int v31 = 0;
      }
      else {
        int v31 = 16;
      }
      if (a3 <= 0x1000 && a2 <= 0x1000 && a4 == 1)
      {
        if (*a7 > 0x8000) {
          int v32 = v31 << 8;
        }
        else {
          int v32 = ((v31 & 0x1F) << 8) | 0x40000;
        }
        int v33 = v32 | *((_DWORD *)v10 + 3);
      }
      else
      {
        int v33 = *((_DWORD *)v10 + 3) | (v31 << 8);
      }
      uint64_t v34 = 0;
      *((_DWORD *)v10 + 37) = 1;
      *((_DWORD *)v10 + 3) = v33;
      do
      {
        *((void *)v10 + v34 + 2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = a7[v34];
        ++v34;
      }
      while (v19 != v34);
    }
  }
  return v10;
}

CA::Render::Texture *CA::Render::Texture::Texture(CA::Render::Texture *this, int a2, int a3)
{
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = *((unsigned __int8 *)this + 12);
  *((_DWORD *)this + 4) = a2;
  *(void *)this = &unk_1ED02FB10;
  *((_DWORD *)this + 5) = a3;
  *((_DWORD *)this + 8) = 1065353216;
  *((void *)this + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 9) = 1;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)((char *)this + 6CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = _Q0;
  if (CADeviceSupportsASTC::once != -1) {
    dispatch_once(&CADeviceSupportsASTC::once, &__block_literal_global_169_12170);
  }
  if (!CADeviceSupportsASTC::supports_astc) {
    *((_DWORD *)this + 3) |= 0x80000u;
  }
  return this;
}

CGColorSpace *CA::Render::Texture::set_colorspace(CA::Render::Texture *this, CGColorSpace *a2)
{
  unint64_t result = (CGColorSpace *)*((void *)this + 6);
  if (result != a2)
  {
    CGColorSpaceRelease(result);
    unint64_t result = CGColorSpaceRetain(a2);
    *((void *)this + 6) = result;
  }
  return result;
}

atomic_uint *CA::Render::Image::set_shmem(CA::Render::Image *this, CA::Render::Shmem *a2)
{
  unint64_t result = (atomic_uint *)*((void *)this + 15);
  if (result != (atomic_uint *)a2)
  {
    unsigned int v4 = a2;
    if (result && atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      unint64_t result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
    }
    if (v4)
    {
      unint64_t v5 = (atomic_uint *)((char *)v4 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)v4 + 2, 1u))
      {
        unsigned int v4 = 0;
        atomic_fetch_add(v5, 0xFFFFFFFF);
      }
    }
    *((void *)this + 15) = v4;
  }
  return result;
}

CA::Render::Texture *CA::Render::Image::new_image(CA::Render::Image *this, unsigned int a2, unsigned int a3, unsigned int a4, CGColorSpace *a5, CGColorSpace **a6, CA::Render::Shmem *a7, const unint64_t *a8)
{
  if ((*((unsigned char *)a6 + 13) & 8) != 0)
  {
    return CA::Render::Shmem::copy_image((CA::Render::Shmem *)a6, a5);
  }
  else
  {
    CFTypeID v9 = CA::Render::Image::new_image(this, a2, a3, a4, a5, a6[3], (unint64_t *)a7, 0, 0, v12);
    uint64_t v10 = v9;
    if (v9) {
      CA::Render::Image::set_shmem(v9, (CA::Render::Shmem *)a6);
    }
    return v10;
  }
}

uint64_t CA::Context::Generic::commit_seed(CA::Context::Generic *this)
{
  return *(unsigned int *)(*((void *)this + 1) + 128);
}

void CABackingStoreDeleteBuffer(void *a1)
{
  unint64_t v2 = (CGColorSpace *)a1[1];
  if (v2)
  {
    CGColorSpaceRelease(v2);
    a1[1] = 0;
  }
  unsigned int v3 = (atomic_uint *)a1[2];
  if (v3)
  {
    if (atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
    }
    a1[2] = 0;
  }
  unsigned int v4 = (atomic_uint *)a1[3];
  if (v4)
  {
    if (atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1)
    {
      (**(void (***)(atomic_uint *))v4)(v4);
      (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
    }
    a1[3] = 0;
  }
  a1[7] = 0;
  if (a1[5])
  {
    CGSReleaseRegion();
    a1[5] = 0;
  }
  unint64_t v5 = (CGColor *)a1[4];
  if (v5)
  {
    CGColorRelease(v5);
    a1[4] = 0;
  }
}

uint64_t CA::Render::format_default_colorspace(CA::Render *this)
{
  unsigned int v1 = this;
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  switch((int)this)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 21:
    case 22:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
      unsigned int v2 = 29;
      goto LABEL_5;
    case 9:
      goto LABEL_15;
    case 10:
    case 18:
    case 19:
    case 25:
    case 26:
    case 27:
    case 28:
      unsigned int v2 = 3;
      goto LABEL_5;
    case 29:
    case 30:
      unsigned int v2 = 4;
LABEL_5:
      uint64_t result = CAGetColorSpace(v2);
      break;
    default:
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unsigned int v4 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          if (v1 > 0x23) {
            unint64_t v5 = "UNKNOWN";
          }
          else {
            unint64_t v5 = off_1E5272E18[v1];
          }
          *(_DWORD *)long long buf = 136315138;
          unsigned int v7 = v5;
          _os_log_impl(&dword_184668000, v4, OS_LOG_TYPE_DEFAULT, "Unsupported image format '%s' for default colorspace\n", buf, 0xCu);
        }
      }
LABEL_15:
      uint64_t result = 0;
      break;
  }
  return result;
}

void *CA::Render::Decoder::decode_data_async(CA::Render::Decoder *this, unint64_t *a2, void (__cdecl **a3)(void *), void **a4)
{
  if (*((unsigned char *)this + 18)) {
    return 0;
  }
  size_t v8 = CA::Render::Decoder::decode_size_t(this);
  if (!v8) {
    return 0;
  }
  CFTypeID v9 = (void *)v8;
  if (*((unsigned char *)this + 64))
  {
    if (v8 == -1)
    {
LABEL_5:
      uint64_t v10 = *((void *)this + 6);
      if (v10 && *(_DWORD *)(v10 + 8) == 1)
      {
        uint64_t v11 = *((void *)this + 7) - 1;
        *((void *)this + 6) = *(void *)v10;
        *((void *)this + 7) = v11;
        *a2 = *(void *)(v10 + 24);
        *a3 = *(void (__cdecl **)(void *))(v10 + 32);
        *a4 = *(void **)(v10 + 40);
        return *(void **)(v10 + 16);
      }
      CA::Render::Decoder::set_fatal_error(this, "%s - _attach_list = %p, unsigned int type = %u");
      return 0;
    }
  }
  else if (v8 == 0xFFFFFFFF)
  {
    goto LABEL_5;
  }
  if (v8 >= 0x2000001)
  {
    CA::Render::Decoder::set_fatal_error(this, "%s - buf size = %zu");
    return 0;
  }
  uint64_t v12 = malloc_type_valloc(v8, 0x89C27083uLL);
  if (v12)
  {
    CA::Render::Decoder::decode_bytes(this, v12, (size_t)v9);
    *a2 = (unint64_t)v9;
    *a3 = CA::Render::release_free;
    *a4 = v9;
  }
  else
  {
    CA::Render::Decoder::set_fatal_error(this, "%s - long long buf = NULL", "decode_data_async");
  }
  return v12;
}

BOOL anonymous namespace'::buffer_is_unused(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1)
  {
    return **(_DWORD **)(v1 + 24) == 0;
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (!v3) {
      return 1;
    }
    unsigned int v4 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 24))(v3);
    return IOSurfaceIsInUse(v4) == 0;
  }
}

uint64_t CA::Render::Shmem::set_volatile(CA::Render::Shmem *this, unsigned int a2, int a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a2) {
    int v3 = 4;
  }
  else {
    int v3 = 0;
  }
  unsigned int v4 = *((_DWORD *)this + 3);
  if (((v4 >> 8) & 4) == v3) {
    return 1;
  }
  if ((v4 & 0x1000) == 0) {
    return a2 ^ 1;
  }
  unsigned int v13 = a3 & 0xFFFFFFFC | a2;
  if (MEMORY[0x185325440](*MEMORY[0x1E4F14960], *((void *)this + 3) & -*MEMORY[0x1E4F14B00], 0, &v13))return a2 ^ 1; {
  int v8 = *((_DWORD *)this + 3);
  }
  *((_DWORD *)this + 3) = v8 ^ 0x400;
  if ((v8 & 0x2000) != 0)
  {
    if (a2) {
      uint64_t v9 = -*((void *)this + 2);
    }
    else {
      uint64_t v9 = *((void *)this + 2);
    }
    uint64_t v10 = CAGetStatsStruct(0);
    unint64_t v11 = *((void *)v10 + 1);
    unint64_t v12 = *(void *)v10 + v9;
    *(void *)uint64_t v10 = v12;
    if (v12 > v11) {
      *((void *)v10 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v12;
    }
  }
  if (v13 == 2) {
    return a2;
  }
  else {
    return 1;
  }
}

void CA::Render::Context::add_begin_time(os_unfair_lock_s *this, double a2)
{
  unsigned int v4 = this + 120;
  os_unfair_lock_lock(this + 120);
  uint64_t v5 = *(void *)&this[122]._os_unfair_lock_opaque;
  uint64_t v6 = *(void *)&this[124]._os_unfair_lock_opaque;
  if ((unint64_t)(v6 - v5) <= 0x200)
  {
    if (v5 != v6)
    {
      do
      {
        double v7 = *(double *)(v5 + 8);
        double v8 = COERCE_DOUBLE(atomic_load(&CA::Render::Context::_begin_time_threshold));
        if (v7 <= v8)
        {
          uint64_t v10 = (void *)(v5 + 16);
          unint64_t v11 = *(void **)&this[124]._os_unfair_lock_opaque;
          uint64_t v9 = (void *)v5;
          if ((void *)(v5 + 16) != v11)
          {
            do
            {
              uint64_t v12 = v10[1];
              *(v10 - 2) = *v10;
              *(v10 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v12;
              v10 += 2;
            }
            while (v10 != v11);
            uint64_t v9 = v10 - 2;
          }
          *(void *)&this[124]._uint64_t os_unfair_lock_opaque = v9;
        }
        else
        {
          v5 += 16;
          uint64_t v9 = *(void **)&this[124]._os_unfair_lock_opaque;
        }
      }
      while ((void *)v5 != v9);
    }
  }
  else
  {
    *(void *)&this[124]._uint64_t os_unfair_lock_opaque = v5;
  }
  uint64_t v13 = mach_absolute_time();
  double v14 = CATimeWithHostTime(v13);
  double v15 = v14;
  unint64_t v17 = *(double **)&this[124]._os_unfair_lock_opaque;
  unint64_t v16 = *(void *)&this[126]._os_unfair_lock_opaque;
  if ((unint64_t)v17 >= v16)
  {
    uint64_t v19 = *(double **)&this[122]._os_unfair_lock_opaque;
    uint64_t v20 = ((char *)v17 - (char *)v19) >> 4;
    unint64_t v21 = v20 + 1;
    if ((unint64_t)(v20 + 1) >> 60) {
      abort();
    }
    uint64_t v22 = v16 - (void)v19;
    if (v22 >> 3 > v21) {
      unint64_t v21 = v22 >> 3;
    }
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v23 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v23 = v21;
    }
    if (v23 >> 60) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v24 = (char *)operator new(16 * v23);
    unint64_t v25 = (double *)&v24[16 * v20];
    *unint64_t v25 = a2;
    v25[1] = v15;
    unsigned int v18 = v25 + 2;
    if (v17 != v19)
    {
      do
      {
        *((_OWORD *)v25 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *((_OWORD *)v17 - 1);
        v25 -= 2;
        v17 -= 2;
      }
      while (v17 != v19);
      unint64_t v17 = v19;
    }
    *(void *)&this[122]._uint64_t os_unfair_lock_opaque = v25;
    *(void *)&this[124]._uint64_t os_unfair_lock_opaque = v18;
    *(void *)&this[126]._uint64_t os_unfair_lock_opaque = &v24[16 * v23];
    if (v17) {
      operator delete(v17);
    }
  }
  else
  {
    *unint64_t v17 = a2;
    v17[1] = v14;
    unsigned int v18 = v17 + 2;
  }
  *(void *)&this[124]._uint64_t os_unfair_lock_opaque = v18;

  os_unfair_lock_unlock(v4);
}

void CA::timer_callback(CA *this, __CFRunLoopTimer *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = mach_absolute_time();
  double v5 = CATimeWithHostTime(v4);
  uint64_t v13 = this;
  uint64_t v14 = CA::active_timers;
  CA::active_timers = (uint64_t)&v13;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::callback_lock);
  double v7 = (double *)CA::callbacks;
  uint64_t v12 = CA::callbacks;
  CA::callbacks = 0;
  if (v7)
  {
    if (v7[3] <= v5)
    {
      uint64_t v9 = (uint64_t)v7;
      while (1)
      {
        double v8 = (uint64_t *)v9;
        uint64_t v9 = *(void *)v9;
        if (!v9) {
          break;
        }
        if (*(double *)(v9 + 24) > v5) {
          goto LABEL_8;
        }
      }
    }
    else
    {
      double v8 = &v12;
      uint64_t v9 = (uint64_t)v7;
LABEL_8:
      *double v8 = 0;
      CA::callbacks = v9;
      CA::update_timer(v6);
      double v7 = (double *)v12;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::callback_lock);
    if (v7)
    {
      do
      {
        (*((void (**)(void, double))v7 + 1))(*((void *)v7 + 2), v5);
        uint64_t v10 = *(double **)v7;
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, v7);
        double v7 = v10;
      }
      while (v10);
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::callback_lock);
  }
  CA::active_timers = v14;
}

void sub_1847757E8(_Unwind_Exception *a1)
{
}

CA::Transaction *CA::Layer::animation_heart_beat(CA::Layer *this, double a2, void *a3)
{
  uint64_t result = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (!result) {
    uint64_t result = (CA::Transaction *)CA::Transaction::create(0);
  }
  if (!**((_DWORD **)result + 13))
  {
    return (CA::Transaction *)CA::Transaction::ensure_implicit(result, 1);
  }
  return result;
}

CA::Transaction *backing_store_callback(double a1, void *a2)
{
  next_collect_time = 0;
  uint64_t result = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (!result) {
    uint64_t result = (CA::Transaction *)CA::Transaction::create(0);
  }
  if (!**((_DWORD **)result + 13))
  {
    return (CA::Transaction *)CA::Transaction::ensure_implicit(result, 1);
  }
  return result;
}

void async_collect_callback(void *a1)
{
  uint64_t v1 = mach_absolute_time();
  double v2 = CATimeWithHostTime(v1);
  marked_volatile = 0;
  CABackingStoreCollect(v2);
  if (marked_volatile == 1 && (*(double *)&next_collect_time == 0.0 || v2 < *(double *)&next_collect_time))
  {
    next_collect_time = *(void *)&v2;
    CA::call_at_time((CA *)backing_store_callback, 0, v2, v3);
  }
  pending_async_collect = 0;
}

void CABackingStoreCollect(double a1)
{
  if (buffer_list)
  {
    double v3 = CABackingStoreCollect_(a1, 0);
    if (v3 < INFINITY)
    {
      if (v3 <= a1 + 0.5) {
        double v3 = a1 + 0.5;
      }
      if (*(double *)&next_collect_time == 0.0 || v3 < *(double *)&next_collect_time)
      {
        next_collect_time = *(void *)&v3;
        CA::call_at_time((CA *)backing_store_callback, 0, v3, v2);
      }
    }
  }
}

double CABackingStoreCollect_(double a1, int a2)
{
  double v4 = a1 + -5.0;
  if (CA::Render::memory_once[0] != -1) {
    dispatch_once_f(CA::Render::memory_once, 0, (dispatch_function_t)CA::Render::init_memory_warnings_);
  }
  double v5 = *(double *)&CA::Render::last_memory_warning;
  pthread_mutex_lock(&buffer_list_mutex);
  BOOL v6 = v5 <= v4;
  double v7 = 0.0;
  if (v5 <= v4) {
    double v8 = 0.35;
  }
  else {
    double v8 = 0.0;
  }
  if (v6) {
    double v9 = 10.0;
  }
  else {
    double v9 = 1.0;
  }
  if (a2) {
    double v10 = 0.0;
  }
  else {
    double v10 = v8;
  }
  if (!a2) {
    double v7 = v9;
  }
  uint64_t v11 = buffer_list;
  if (!buffer_list)
  {
    double v15 = INFINITY;
    goto LABEL_61;
  }
  double v12 = a1 - v10;
  double v13 = a1 - v7;
  double v14 = a1 + 0.5;
  double v15 = INFINITY;
  do
  {
    if ((a2 & 1) == 0)
    {
      double v16 = *(double *)(v11 + 472);
      if (v16 > a1)
      {
        if (v15 >= v16) {
          double v15 = *(double *)(v11 + 472);
        }
        goto LABEL_58;
      }
    }
    if (pthread_mutex_trylock((pthread_mutex_t *)(v11 + 16))) {
      goto LABEL_58;
    }
    *(void *)(v11 + 472) = 0x7FF0000000000000;
    uint64_t v17 = *(void *)(v11 + 400);
    if (!v17)
    {
      double v22 = INFINITY;
      goto LABEL_55;
    }
    char v18 = 0;
    do
    {
      double v19 = *(double *)(v17 + 48);
      if (v19 == 0.0)
      {
        *(double *)(v17 + 48) = a1;
        double v19 = a1;
      }
      if (*(void *)(v17 + 16) || *(void *)(v17 + 24))
      {
        if (v17 == *(void *)(v11 + 400))
        {
          if ((*(_WORD *)(v11 + 492) & 0x100) == 0) {
            goto LABEL_46;
          }
          CABackingStoreReleaseImages((CABackingStore *)v11);
          double v19 = *(double *)(v17 + 48);
          if (v19 <= v12)
          {
              char v18 = 1;
            else {
            goto LABEL_46;
            }
          }
        }
        else
        {
          if (v19 <= v13)
          {
            CABackingStoreDeleteBuffer((void *)v17);
            goto LABEL_46;
          }
          if (v19 <= v12)
          {
              char v18 = 1;
            else {
            double v20 = *(double *)(v17 + 48) + v9;
            }
LABEL_40:
            if (v20 < *(double *)(v11 + 472)) {
              *(double *)(v11 + 472) = v20;
            }
            goto LABEL_46;
          }
        }
        double v20 = v19 + v8;
        goto LABEL_40;
      }
LABEL_46:
      uint64_t v17 = *(void *)v17;
    }
    while (v17);
    if (v18)
    {
      __int16 v21 = *(_WORD *)(v11 + 492);
      double v22 = *(double *)(v11 + 472);
      if ((_BYTE)v21)
      {
        if (v14 < v22)
        {
          *(double *)(v11 + 472) = v14;
          double v22 = a1 + 0.5;
        }
        if ((a2 & 1) == 0) {
          *(_WORD *)(v11 + 492) = v21 & 0xFF00 | (v21 - 1);
        }
      }
    }
    else
    {
      double v22 = *(double *)(v11 + 472);
    }
LABEL_55:
    if (v22 < v15) {
      double v15 = v22;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v11 + 16));
LABEL_58:
    uint64_t v11 = *(void *)(v11 + 168);
  }
  while (v11);
LABEL_61:
  pthread_mutex_unlock(&buffer_list_mutex);
  return v15;
}

void CA::call_at_time(CA *this, void (*a2)(double, void *), double a3, void *a4)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::callback_lock);
  uint64_t v7 = CA::callbacks;
  if (CA::callbacks)
  {
    double v8 = &CA::callbacks;
    while (1)
    {
      double v9 = (uint64_t *)v7;
      if (*(CA **)(v7 + 8) == this && *(void (**)(double, void *))(v7 + 16) == a2) {
        break;
      }
      uint64_t v7 = *(void *)v7;
      double v8 = v9;
      if (!*v9) {
        goto LABEL_6;
      }
    }
    *double v8 = *(void *)v7;
  }
  else
  {
LABEL_6:
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    double v9 = (uint64_t *)malloc_type_zone_malloc(malloc_zone, 0x20uLL, 0x8BB15036uLL);
    v9[1] = (uint64_t)this;
    v9[2] = (uint64_t)a2;
  }
  *((double *)v9 + 3) = a3;
  uint64_t v11 = &CA::callbacks;
  do
  {
    double v12 = v11;
    uint64_t v11 = (uint64_t *)*v11;
  }
  while (v11 && *((double *)v11 + 3) <= a3);
  *double v9 = (uint64_t)v11;
  *double v12 = (uint64_t)v9;
  if (v12 == &CA::callbacks) {
    CA::update_timer((CA *)v9);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&CA::callback_lock);
}

void sub_184775D48(_Unwind_Exception *a1)
{
}

void CA::update_timer(CA *this)
{
  if (CA::callbacks)
  {
    double v1 = *(double *)(CA::callbacks + 24);
    double v2 = 0.0;
    if (v1 > 0.0)
    {
      uint64_t v3 = mach_absolute_time();
      double v2 = v1 - CATimeWithHostTime(v3);
    }
    double v4 = CFAbsoluteTimeGetCurrent() + v2;
    double v5 = (__CFRunLoopTimer *)CA::callback_timer;
    if (CA::callback_timer)
    {
      CFRunLoopTimerSetNextFireDate(v5, v4);
    }
    else
    {
      CA::callback_timer = (uint64_t)CFRunLoopTimerCreate(0, v4, 3153600000.0, 0, 0, (CFRunLoopTimerCallBack)CA::timer_callback, 0);
      int v6 = pthread_main_np();
      uint64_t v7 = (__CFRunLoopTimer *)CA::callback_timer;
      if (v6)
      {
        Current = CFRunLoopGetCurrent();
        CFStringRef v9 = (const __CFString *)*MEMORY[0x1E4F1D410];
        CFRunLoopAddTimer(Current, v7, v9);
      }
      else
      {
        double v10 = MEMORY[0x1E4F14428];
        uint64_t v11 = (void *)CA::callback_timer;
        dispatch_async_f(v10, v11, (dispatch_function_t)CA::add_timer);
      }
    }
  }
}

void anonymous namespace'::make_buffer_volatile(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a2 + 16);
  if (v2)
  {
    if ((*(unsigned char *)(v2 + 13) & 4) == 0
      && CA::Render::Shmem::set_volatile(*(CA::Render::Shmem **)(a2 + 16), 1u, *(_DWORD *)(a1 + 488)))
    {
      if ((*(_DWORD *)(v2 + 12) & 0x80000000) != 0)
      {
        os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Encoder::ObjectCache::_lock);
        uint64_t v3 = (void *)CA::Render::Encoder::ObjectCache::_cache_list;
        if (CA::Render::Encoder::ObjectCache::_cache_list)
        {
          do
          {
            uint64_t v4 = *v3;
            uint64_t v5 = x_hash_table_remove(*(void *)(*v3 + 8), v2);
            if (v5)
            {
              int v6 = *(int **)(v4 + 24);
              if (!v6)
              {
                int v6 = (int *)x_hash_table_new_(0, 0, 0, 0, 0, 0);
                *(void *)(v4 + 24) = v6;
              }
              hash_table_modify(v6, v2, v5, 0);
              uint64_t v7 = *(int **)(v4 + 32);
              if (!v7)
              {
                uint64_t v7 = (int *)x_hash_table_new_(0, 0, 0, 0, 0, 0);
                *(void *)(v4 + 32) = v7;
              }
              hash_table_modify(v7, v2, v5, 0);
            }
            uint64_t v3 = (void *)v3[1];
          }
          while (v3);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Encoder::ObjectCache::_lock);
        marked_volatile = 1;
      }
      CA::Render::post_notification(0xBu, v2, 0, 0);
    }
  }
  else
  {
    uint64_t v8 = *(void *)(a2 + 24);
    if (v8 && !*(unsigned char *)(v8 + 68))
    {
      CA::CG::AccelDrawable::set_volatile((os_unfair_lock_s *)v8, 1);
    }
  }
}

CA::Render::Texture *CA::Render::anonymous namespace'::create_image_from_iosurface(CA::Render::_anonymous_namespace_ *this, CGImage *a2, IOSurfaceRef buffer, unsigned int a4, __IOSurface *a5)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (((unsigned __int16)a2 & 0x800) != 0) {
    return 0;
  }
  char v6 = (char)a2;
  Width = (CA::Render *)IOSurfaceGetWidth(buffer);
  unsigned int Height = IOSurfaceGetHeight(buffer);
  if (!CA::Render::iosurface_size_supported(Width, Height)) {
    return 0;
  }
  if (!CA::Render::is_iosurface_aligned(buffer, v10))
  {
    if (BYTE9(ca_debug_options))
    {
      if (x_log_hook_p())
      {
        IOSurfaceGetID(buffer);
        x_log_();
      }
      else
      {
        unint64_t v23 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 134218240;
          unint64_t v25 = this;
          __int16 v26 = 1024;
          IOSurfaceID ID = IOSurfaceGetID(buffer);
          _os_log_impl(&dword_184668000, v23, OS_LOG_TYPE_DEFAULT, "CoreAnimation: copied CGImageRef %p - bad alignment for IOSurface 0x%x\n", buf, 0x12u);
        }
      }
    }
    return 0;
  }
  if (CGImageGetDecode(this)) {
    return 0;
  }
  if (CGImageGetMask()) {
    return 0;
  }
  if (CGImageGetMatte()) {
    return 0;
  }
  if (CGImageGetMaskingColors()) {
    return 0;
  }
  ColorSpace = CGImageGetColorSpace(this);
  double v12 = ColorSpace;
  if (ColorSpace)
  {
    if (CGColorSpaceGetModel(ColorSpace) > kCGColorSpaceModelRGB) {
      return 0;
    }
  }
  signed int PixelFormat = IOSurfaceGetPixelFormat(buffer);
  int HasAlpha = CGImageHasAlpha();
  if (PixelFormat > 1279342647)
  {
    if (PixelFormat <= 1647534391)
    {
      if (PixelFormat > 1380410944)
      {
        if (PixelFormat != 1380410945)
        {
          if (PixelFormat == 1380411457)
          {
            if (HasAlpha) {
              int v17 = 13;
            }
            else {
              int v17 = 17;
            }
            goto LABEL_55;
          }
          goto LABEL_72;
        }
        int v17 = 14;
        goto LABEL_55;
      }
      if (PixelFormat == 1279342648)
      {
LABEL_50:
        BOOL v18 = HasAlpha == 0;
        int v19 = 18;
        goto LABEL_52;
      }
      if (PixelFormat == 1380401729)
      {
        BOOL v18 = HasAlpha == 0;
        int v19 = 11;
        goto LABEL_52;
      }
    }
    else if (PixelFormat <= 1999843441)
    {
      if (PixelFormat == 1647534392)
      {
        int v17 = 35;
        goto LABEL_55;
      }
      if (PixelFormat == 1815491698)
      {
        BOOL v18 = HasAlpha == 0;
        int v19 = 21;
        goto LABEL_52;
      }
    }
    else
    {
      switch(PixelFormat)
      {
        case 1999843442:
          int v17 = 33;
          goto LABEL_55;
        case 1999908961:
          int v17 = 34;
          goto LABEL_55;
        case 2037741171:
          int v17 = 7;
          goto LABEL_55;
      }
    }
LABEL_72:
    int v17 = -1;
    goto LABEL_55;
  }
  if (PixelFormat <= 1093677111)
  {
    if (PixelFormat <= 843264309)
    {
      if (PixelFormat == 32)
      {
        if (HasAlpha) {
          int v17 = 0;
        }
        else {
          int v17 = 2;
        }
        goto LABEL_55;
      }
      if (PixelFormat != 843264104) {
        goto LABEL_72;
      }
      int v17 = 28;
      goto LABEL_55;
    }
    if (PixelFormat == 843264310)
    {
      int v17 = 27;
      goto LABEL_55;
    }
    if (PixelFormat == 846624121)
    {
      int v17 = 6;
      goto LABEL_55;
    }
    goto LABEL_72;
  }
  if (PixelFormat <= 1278226487)
  {
    if (PixelFormat != 1093677112)
    {
      if (PixelFormat == 1111970369)
      {
        if (HasAlpha) {
          int v17 = 1;
        }
        else {
          int v17 = 3;
        }
        goto LABEL_55;
      }
      goto LABEL_72;
    }
    goto LABEL_51;
  }
  if (PixelFormat == 1278226488)
  {
LABEL_51:
    BOOL v18 = (v6 & 2) == 0;
    int v19 = 9;
LABEL_52:
    if (v18) {
      int v17 = v19 + 1;
    }
    else {
      int v17 = v19;
    }
    goto LABEL_55;
  }
  if (PixelFormat != 1278555445)
  {
    if (PixelFormat != 1279340600) {
      goto LABEL_72;
    }
    goto LABEL_50;
  }
  int v17 = 5;
LABEL_55:
  BOOL IsPQBased = CGColorSpaceIsPQBased(v12);
  __int16 v21 = (CA::Render::Texture *)x_mem_alloc0(0x158uLL);
  double v15 = v21;
  if (v21)
  {
    if (IsPQBased) {
      char v22 = 3;
    }
    else {
      char v22 = 1;
    }
    CA::Render::Surface::Surface((uint64_t)v21, buffer, v17, v22, 0x8000, 0, 0);
  }
  if (!*((void *)v15 + 6) || (CGColorSpaceContainsFlexGTCInfo() & 1) == 0) {
    CA::Render::Texture::set_colorspace(v15, v12);
  }
  return v15;
}

BOOL CA::Render::iosurface_size_supported(CA::Render *this, unsigned int a2)
{
  unsigned int v3 = this;
  if (this <= 0x800 && a2 < 0x801) {
    return 1;
  }
  if (CA::Render::iosurface_max_once != -1) {
    dispatch_once_f(&CA::Render::iosurface_max_once, 0, (dispatch_function_t)CA::Render::iosurface_max_init);
  }
  return CA::Render::iosurface_max_width >= (unint64_t)v3
      && CA::Render::iosurface_max_height >= (unint64_t)a2;
}

void *CA::Render::Surface::encode(CA::Render::Surface *this, CA::Render::Encoder *a2)
{
  unsigned int v3 = this;
  uint64_t v4 = (unsigned char *)*((void *)a2 + 4);
  unint64_t v5 = *((void *)a2 + 5);
  if (!*((void *)this + 12))
  {
    if ((unint64_t)(v4 + 1) > v5)
    {
      CA::Render::Encoder::grow(a2, 1);
      uint64_t v4 = (unsigned char *)*((void *)a2 + 4);
    }
    *((void *)a2 + 4) = v4 + 1;
    *uint64_t v4 = 0;
    int v12 = *((_DWORD *)v3 + 3) >> 8;
    double v13 = (_DWORD *)*((void *)a2 + 4);
    if ((unint64_t)(v13 + 1) > *((void *)a2 + 5))
    {
      CA::Render::Encoder::grow(a2, 4);
      double v13 = (_DWORD *)*((void *)a2 + 4);
    }
    *double v13 = v12;
    uint64_t v14 = *((void *)a2 + 4);
    unint64_t v15 = *((void *)a2 + 5);
    double v16 = (_DWORD *)(v14 + 4);
    *((void *)a2 + 4) = v14 + 4;
    int v17 = *((_DWORD *)v3 + 27);
    if (v14 + 8 > v15)
    {
      CA::Render::Encoder::grow(a2, 4);
      double v16 = (_DWORD *)*((void *)a2 + 4);
    }
    *double v16 = v17;
    uint64_t v18 = *((void *)a2 + 4);
    uint64_t v11 = (unsigned char *)(v18 + 4);
    *((void *)a2 + 4) = v18 + 4;
    uint64_t v19 = *((void *)v3 + 15);
    if (!v19)
    {
      uint64_t v44 = (__IOSurface *)*((void *)v3 + 14);
      if (v44)
      {
        mach_port_t MachPort = IOSurfaceCreateMachPort(v44);
        uint64_t v11 = (unsigned char *)*((void *)a2 + 4);
        if (MachPort)
        {
          mach_port_name_t v10 = MachPort;
          if ((unint64_t)(v11 + 1) <= *((void *)a2 + 5)) {
            goto LABEL_11;
          }
          goto LABEL_10;
        }
      }
      if ((unint64_t)(v11 + 1) <= *((void *)a2 + 5)) {
        goto LABEL_28;
      }
LABEL_27:
      CA::Render::Encoder::grow(a2, 1);
      uint64_t v11 = (unsigned char *)*((void *)a2 + 4);
LABEL_28:
      *((void *)a2 + 4) = v11 + 1;
      *uint64_t v11 = 0;
      goto LABEL_29;
    }
    mach_port_name_t v10 = *(_DWORD *)(v19 + 16);
    unint64_t v20 = v18 + 5;
    unint64_t v21 = *((void *)a2 + 5);
    BOOL v22 = v20 > v21;
    if (v10)
    {
      if (v20 > v21)
      {
        CA::Render::Encoder::grow(a2, 1);
        uint64_t v11 = (unsigned char *)*((void *)a2 + 4);
      }
      *((void *)a2 + 4) = v11 + 1;
      *uint64_t v11 = 3;
      mach_port_mod_refs(*MEMORY[0x1E4F14960], v10, 0, 1);
      goto LABEL_23;
    }
LABEL_25:
    if (!v22) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  if ((unint64_t)(v4 + 1) > v5)
  {
    CA::Render::Encoder::grow(a2, 1);
    uint64_t v4 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v4 + 1;
  *uint64_t v4 = 1;
  int v6 = *((_DWORD *)v3 + 3) >> 8;
  uint64_t v7 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v7 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v7 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v7 = v6;
  *((void *)a2 + 4) += 4;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)v3 + 12));
  if ((*((unsigned char *)v3 + 15) & 0x10) != 0)
  {
    uint64_t v8 = (__IOSurface *)*((void *)v3 + 14);
    if (v8)
    {
      mach_port_t v9 = IOSurfaceCreateMachPort(v8);
      if (v9)
      {
        mach_port_name_t v10 = v9;
        uint64_t v11 = (unsigned char *)*((void *)a2 + 4);
        if ((unint64_t)(v11 + 1) <= *((void *)a2 + 5))
        {
LABEL_11:
          *((void *)a2 + 4) = v11 + 1;
          *uint64_t v11 = 1;
LABEL_23:
          uint64_t v23 = x_heap_malloc_small_(*((uint64_t **)a2 + 1), 0x30uLL);
          *(_DWORD *)(v23 + 8) = 2;
          *(_DWORD *)(v23 + 16) = v10;
          *(_DWORD *)(v23 + 2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 19;
          *(unsigned char *)(v23 + 24) = 1;
          uint64_t v24 = *((void *)a2 + 7);
          *(void *)uint64_t v23 = *((void *)a2 + 6);
          *((void *)a2 + 6) = v23;
          *((void *)a2 + 7) = v24 + 1;
          goto LABEL_29;
        }
LABEL_10:
        CA::Render::Encoder::grow(a2, 1);
        uint64_t v11 = (unsigned char *)*((void *)a2 + 4);
        goto LABEL_11;
      }
    }
    uint64_t v11 = (unsigned char *)*((void *)a2 + 4);
    BOOL v22 = (unint64_t)(v11 + 1) > *((void *)a2 + 5);
    goto LABEL_25;
  }
LABEL_29:
  int v25 = (*((unsigned __int8 *)v3 + 336) >> 5) & 1;
  __int16 v26 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v26 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    __int16 v26 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v26 + 1;
  *__int16 v26 = v25;
  int v27 = (*((unsigned __int8 *)v3 + 336) >> 6) & 1;
  uint64_t v28 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v28 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    uint64_t v28 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v28 + 1;
  *uint64_t v28 = v27;
  char v29 = *((unsigned char *)v3 + 328);
  uint64_t v30 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v30 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    uint64_t v30 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v30 + 1;
  unsigned char *v30 = v29;
  char v31 = (*(uint64_t (**)(CA::Render::Surface *))(*(void *)v3 + 264))(v3);
  int v32 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v32 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    int v32 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v32 + 1;
  *int v32 = v31;
  char v33 = (*(uint64_t (**)(CA::Render::Surface *))(*(void *)v3 + 272))(v3);
  uint64_t v34 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v34 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    uint64_t v34 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v34 + 1;
  *uint64_t v34 = v33;
  char v35 = (*(uint64_t (**)(CA::Render::Surface *))(*(void *)v3 + 280))(v3);
  uint64_t v36 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v36 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    uint64_t v36 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v36 + 1;
  *uint64_t v36 = v35;
  char v37 = (*(uint64_t (**)(CA::Render::Surface *))(*(void *)v3 + 256))(v3);
  long long v38 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v38 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    long long v38 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v38 + 1;
  *long long v38 = v37;
  char v39 = (*(uint64_t (**)(CA::Render::Surface *))(*(void *)v3 + 128))(v3);
  __int16 v40 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v40 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    __int16 v40 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v40 + 1;
  *__int16 v40 = v39;
  CA::Render::Texture::encode((CGColorSpaceRef *)v3, a2);
  uint64_t result = (void *)x_heap_malloc_small_(*((uint64_t **)a2 + 1), 0x10uLL);
  uint64_t v42 = (atomic_uint *)((char *)v3 + 8);
  if (!atomic_fetch_add((atomic_uint *volatile)v3 + 2, 1u))
  {
    unsigned int v3 = 0;
    atomic_fetch_add(v42, 0xFFFFFFFF);
  }
  uint64_t v43 = *((void *)a2 + 14);
  *uint64_t result = v3;
  result[1] = v43;
  *((void *)a2 + 14) = result;
  return result;
}

uint64_t CA::Render::Surface::Surface(uint64_t a1, IOSurfaceRef buffer, int a3, char a4, int a5, char a6, char a7)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  int Width = IOSurfaceGetWidth(buffer);
  int Height = IOSurfaceGetHeight(buffer);
  CA::Render::Texture::Texture((CA::Render::Texture *)a1, Width, Height);
  *(unsigned char *)(a1 + 12) = 51;
  ++dword_1EB2ADE94;
  *(void *)a1 = &unk_1ED02F9D0;
  *(void *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 104) = IOSurfaceGetID(buffer);
  *(_DWORD *)(a1 + 108) = a3;
  *(void *)(a1 + 112) = buffer;
  *(void *)(a1 + 12CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
  *(_DWORD *)(a1 + 128) = IOSurfaceGetPixelFormat(buffer);
  *(float *)(a1 + 132) = CA::Render::iosurface_get_edr_factor(buffer, v16);
  *(void *)(a1 + 136) = IOSurfaceGetProtectionOptions();
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 16CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0u;
  *(_OWORD *)(a1 + 172) = 0u;
  *(_OWORD *)(a1 + 188) = xmmword_184997E20;
  *(_DWORD *)(a1 + 204) = 1065353216;
  *(_OWORD *)(a1 + 208) = xmmword_184997E30;
  *(void *)(a1 + 224) = 0;
  *(_WORD *)(a1 + 232) = 0;
  *(void *)(a1 + 236) = 0x100000001;
  *(_OWORD *)(a1 + 244) = 0u;
  *(_OWORD *)(a1 + 26CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0u;
  *(unsigned char *)(a1 + 276) = 0;
  *(_DWORD *)(a1 + 28CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 1065353216;
  *(void *)(a1 + 292) = 0;
  *(void *)(a1 + 284) = 0;
  *(_DWORD *)(a1 + 30CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = -1;
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 32CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
  *(unsigned char *)(a1 + 328) = 0;
  *(unsigned char *)(a1 + 329) = a6 & 0xF | (16 * (a7 & 7)) | *(unsigned char *)(a1 + 329) & 0x80;
  *(_DWORD *)(a1 + 332) = -1;
  *(_WORD *)(a1 + 336) &= 0xF840u;
  if (!CA::Render::is_iosurface_aligned(buffer, v17))
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v18 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        IOSurfaceID v19 = *(_DWORD *)(a1 + 104);
        int v21 = *(_DWORD *)(a1 + 16);
        int v20 = *(_DWORD *)(a1 + 20);
        *(_DWORD *)long long buf = 67110144;
        IOSurfaceID v57 = v19;
        __int16 v58 = 1024;
        int v59 = v21;
        __int16 v60 = 1024;
        int v61 = v20;
        __int16 v62 = 2048;
        *(void *)int v63 = qword_1EB2A87C0;
        *(_WORD *)&v63[8] = 2048;
        *(void *)CGRect v64 = qword_1EB2A87C8;
        _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_DEFAULT, "CoreAnimation: IOSurface 0x%x [%u x %u] doesn't have the proper data alignment! Expected %zu base address and %zu row byte alignment\n", buf, 0x28u);
      }
    }
  }
  if (a4) {
    CFRetain(buffer);
  }
  unsigned int v22 = *(_DWORD *)(a1 + 108);
  if (v22 != -1
    || (uint64_t v30 = (CA::Render *)*(unsigned int *)(a1 + 128), v30)
    && (unsigned int v22 = CA::Render::fourcc_to_format(v30), *(_DWORD *)(a1 + 108) = v22, v22 != -1))
  {
    if (IOSurfaceGetPlaneCount(buffer) < 2)
    {
      if (IOSurfaceGetPlaneCount(buffer) == 1)
      {
        size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(buffer, 0);
        if (v22 > 0x25) {
          unsigned int v29 = 0;
        }
        else {
          unsigned int v29 = dword_184999468[v22];
        }
        uint64_t v32 = v29;
        size_t WidthOfPlane = IOSurfaceGetWidthOfPlane(buffer, 0);
      }
      else
      {
        size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRow(buffer);
        if (v22 > 0x25) {
          unsigned int v31 = 0;
        }
        else {
          unsigned int v31 = dword_184999468[v22];
        }
        uint64_t v32 = v31;
        size_t WidthOfPlane = IOSurfaceGetWidth(buffer);
      }
      if (BytesPerRowOfPlane >= WidthOfPlane * v32)
      {
LABEL_17:
        unsigned int v27 = *(_DWORD *)(a1 + 108);
        if (v27 != -1 && (v27 > 0x23 || ((0xC99B4EB03uLL >> v27) & 1) == 0)) {
          goto LABEL_76;
        }
        goto LABEL_74;
      }
    }
    else
    {
      size_t v23 = IOSurfaceGetBytesPerRowOfPlane(buffer, 0);
      size_t v24 = IOSurfaceGetBytesPerRowOfPlane(buffer, 1uLL);
      size_t v25 = IOSurfaceGetWidthOfPlane(buffer, 0);
      size_t v26 = IOSurfaceGetWidthOfPlane(buffer, 1uLL);
      if (v22 == 35 && v23 >= 4 * v25 && v24 >= v26) {
        goto LABEL_17;
      }
    }
    OSType PixelFormat = IOSurfaceGetPixelFormat(buffer);
    if (x_log_hook_p())
    {
      IOSurfaceGetID(buffer);
      if ((PixelFormat & 0x80000000) != 0) {
        __maskrune(HIBYTE(PixelFormat), 0x40000uLL);
      }
      if (BYTE2(PixelFormat) > 0x7Fu) {
        __maskrune(BYTE2(PixelFormat), 0x40000uLL);
      }
      if (BYTE1(PixelFormat) > 0x7Fu) {
        __maskrune(BYTE1(PixelFormat), 0x40000uLL);
      }
      if (PixelFormat > 0x7Fu) {
        __maskrune(PixelFormat, 0x40000uLL);
      }
      IOSurfaceGetBytesPerRow(buffer);
      IOSurfaceGetWidth(buffer);
      IOSurfaceGetWidth(buffer);
      x_log_();
    }
    else
    {
      char v35 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        IOSurfaceID ID = IOSurfaceGetID(buffer);
        unsigned int v36 = HIBYTE(PixelFormat);
        uint64_t v37 = MEMORY[0x1E4F14390];
        if ((PixelFormat & 0x80000000) != 0) {
          int v38 = __maskrune(v36, 0x40000uLL);
        }
        else {
          int v38 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v36 + 60) & 0x40000;
        }
        int v39 = (int)PixelFormat >> 24;
        if (!v38) {
          int v39 = 32;
        }
        int v54 = v39;
        if (BYTE2(PixelFormat) <= 0x7Fu) {
          int v40 = *(_DWORD *)(v37 + 4 * BYTE2(PixelFormat) + 60) & 0x40000;
        }
        else {
          int v40 = __maskrune(BYTE2(PixelFormat), 0x40000uLL);
        }
        if (v40) {
          int v41 = SBYTE2(PixelFormat);
        }
        else {
          int v41 = 32;
        }
        if (BYTE1(PixelFormat) <= 0x7Fu) {
          int v42 = *(_DWORD *)(v37 + 4 * BYTE1(PixelFormat) + 60) & 0x40000;
        }
        else {
          int v42 = __maskrune(BYTE1(PixelFormat), 0x40000uLL);
        }
        if (v42) {
          int v43 = SBYTE1(PixelFormat);
        }
        else {
          int v43 = 32;
        }
        if (PixelFormat <= 0x7Fu) {
          int v44 = *(_DWORD *)(v37 + 4 * PixelFormat + 60) & 0x40000;
        }
        else {
          int v44 = __maskrune(PixelFormat, 0x40000uLL);
        }
        if (v44) {
          int v45 = (char)PixelFormat;
        }
        else {
          int v45 = 32;
        }
        size_t BytesPerRow = IOSurfaceGetBytesPerRow(buffer);
        if (v22 > 0x25) {
          uint64_t v47 = 0;
        }
        else {
          uint64_t v47 = dword_184999468[v22];
        }
        size_t v48 = IOSurfaceGetWidth(buffer) * v47;
        size_t v49 = IOSurfaceGetWidth(buffer);
        *(_DWORD *)long long buf = 67110912;
        IOSurfaceID v57 = ID;
        __int16 v58 = 1024;
        int v59 = v54;
        __int16 v60 = 1024;
        int v61 = v41;
        __int16 v62 = 1024;
        *(_DWORD *)int v63 = v43;
        *(_WORD *)&v63[4] = 1024;
        *(_DWORD *)&v63[6] = v45;
        *(_WORD *)CGRect v64 = 2048;
        *(void *)&v64[2] = BytesPerRow;
        __int16 v65 = 2048;
        size_t v66 = v48;
        __int16 v67 = 2048;
        size_t v68 = v49;
        _os_log_impl(&dword_184668000, v35, OS_LOG_TYPE_DEFAULT, "CoreAnimation: IOSurface 0x%x ('%c%c%c%c') has unexpected bytes-per-row value of %zu, expected at least %zu for the width of %zu.", buf, 0x3Eu);
      }
    }
    *(_DWORD *)(a1 + 108) = -1;
  }
LABEL_74:
  if (CA::Render::fourcc_has_alpha((CA::Render *)*(unsigned int *)(a1 + 128)))
  {
    int v50 = a5 | 0x400;
    goto LABEL_77;
  }
LABEL_76:
  int v50 = a5 | 0x410;
LABEL_77:
  *(_DWORD *)(a1 + 12) |= v50 << 8;
  *(_DWORD *)(a1 + 324) = 1;
  if ((v50 & 0x8000) != 0) {
    IOSurfaceIncrementUseCount(buffer);
  }
  CA::Render::iosurface_load_attachments((CA::Render *)a1, (CA::Render::Surface *)(a4 & 0x3E));
  if (*(float *)(a1 + 132) != 1.0) {
    *(_WORD *)(a1 + 336) |= 4u;
  }
  if (CA::Render::fourcc_is_rgb((CA::Render *)*(unsigned int *)(a1 + 128)))
  {
    char v51 = *(unsigned char *)(a1 + 329);
    int v52 = v51 & 0x70;
    if ((v51 & 0x70) == 0) {
      char v51 = v51 & 0x8F | 0x20;
    }
    if (!v52 || (v51 & 0xF) == 0)
    {
      if ((v51 & 0xF) == 0) {
        char v51 = v51 & 0xF0 | 1;
      }
      *(unsigned char *)(a1 + 329) = v51;
    }
  }
  return a1;
}

BOOL CA::Render::is_iosurface_aligned(IOSurfaceRef buffer, __IOSurface *a2)
{
  unint64_t v3 = qword_1EB2A87C0;
  unint64_t v4 = qword_1EB2A87C8;
  PlaneCFIndex Count = IOSurfaceGetPlaneCount(buffer);
  if (PlaneCount)
  {
    size_t v6 = PlaneCount;
    size_t v7 = 0;
    while (1)
    {
      unint64_t BaseAddressOfPlane = (unint64_t)IOSurfaceGetBaseAddressOfPlane(buffer, v7);
      size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(buffer, v7);
      if (BaseAddressOfPlane % v3 || BytesPerRowOfPlane % v4) {
        break;
      }
      if (v6 == ++v7) {
        return 1;
      }
    }
    return 0;
  }
  unint64_t BaseAddress = (unint64_t)IOSurfaceGetBaseAddress(buffer);
  size_t BytesPerRow = IOSurfaceGetBytesPerRow(buffer);
  return !(BaseAddress % v3) && !(BytesPerRow % v4);
}

uint64_t CA::Render::iosurface_load_attachments(CA::Render *this, CA::Render::Surface *a2)
{
  unsigned int v2 = a2;
  long long v42 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v39 = 0u;
  unint64_t v4 = (__IOSurface *)*((void *)this + 14);
  if ((a2 & 2) == 0)
  {
    int has_alpha = CA::Render::fourcc_has_alpha((CA::Render *)*((unsigned int *)this + 32));
    int v7 = has_alpha;
    if (((v2 & 0x3C) != 0 || has_alpha)
      && (long long v42 = 0u, v40 = 0u, v41 = 0u, v39 = 0u, !IOSurfaceGetBulkAttachments()))
    {
      BOOL v8 = 1;
      if ((v2 & 4) == 0) {
        goto LABEL_31;
      }
    }
    else
    {
      BOOL v8 = 0;
      if ((v2 & 4) == 0) {
        goto LABEL_31;
      }
    }
    goto LABEL_23;
  }
  *((void *)&v42 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  long long v40 = 0uLL;
  long long v41 = 0uLL;
  long long v39 = 0uLL;
  BOOL v8 = IOSurfaceGetBulkAttachments() == 0;
  CFTypeRef v9 = IOSurfaceCopyValue(v4, (CFStringRef)*MEMORY[0x1E4F2F068]);
  if (v9)
  {
    mach_port_name_t v10 = v9;
    CGColorSpaceRef v11 = CGColorSpaceCreateWithPropertyList(v9);
    goto LABEL_9;
  }
  CFTypeRef v14 = IOSurfaceCopyValue(v4, (CFStringRef)*MEMORY[0x1E4F2F0F0]);
  if (v14)
  {
    mach_port_name_t v10 = v14;
    CFTypeID v15 = CFGetTypeID(v14);
    if (v15 != CFDataGetTypeID())
    {
      colorspace_from_bulk_attachments = 0;
      goto LABEL_10;
    }
    CGColorSpaceRef v11 = (CGColorSpaceRef)MEMORY[0x1853211C0](v10);
LABEL_9:
    colorspace_from_bulk_attachments = v11;
LABEL_10:
    CFRelease(v10);
    goto LABEL_11;
  }
  colorspace_from_bulk_attachments = 0;
LABEL_11:
  if (colorspace_from_bulk_attachments) {
    BOOL v13 = 0;
  }
  else {
    BOOL v13 = v8;
  }
  if (v13) {
    colorspace_from_bulk_attachments = CA::Render::load_colorspace_from_bulk_attachments(0, 0);
  }
  if (colorspace_from_bulk_attachments)
  {
    CA::Render::Texture::set_colorspace(this, colorspace_from_bulk_attachments);
    CGColorSpaceRelease(colorspace_from_bulk_attachments);
  }
  else
  {
    IOSurfaceRemoveValue(v4, (CFStringRef)*MEMORY[0x1E4F2F048]);
  }
  int v7 = CA::Render::fourcc_has_alpha((CA::Render *)*((unsigned int *)this + 32));
  if ((v2 & 4) != 0)
  {
LABEL_23:
    if (DWORD1(v41)) {
      BOOL v16 = v8;
    }
    else {
      BOOL v16 = 0;
    }
    if (v16 && HIDWORD(v41) != 0)
    {
      float v18 = (double)(int)v41 * (double)SHIDWORD(v41) / ((double)SDWORD2(v41) * (double)SDWORD1(v41));
      *((float *)this + 8) = v18;
    }
  }
LABEL_31:
  if ((v2 & 8) != 0)
  {
    BOOL v19 = DWORD1(v39) && v8;
    if (v19 && HIDWORD(v39) && DWORD1(v40) && HIDWORD(v40))
    {
      v20.i64[0] = SDWORD1(v39);
      v20.i64[1] = SHIDWORD(v39);
      float64x2_t v21 = vcvtq_f64_s64(v20);
      int32x2_t v22 = *(int32x2_t *)((char *)this + 16);
      v20.i64[0] = (int)v39;
      v20.i64[1] = SDWORD2(v39);
      int8x16_t v23 = (int8x16_t)vdivq_f64(vcvtq_f64_s64(v20), v21);
      v20.i64[0] = v22.u32[0];
      v20.i64[1] = v22.u32[1];
      int8x16_t v24 = (int8x16_t)vcvtq_f64_u64((uint64x2_t)v20);
      float64x2_t v25 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v24, (float64x2_t)v23), v23, v24);
      int64x2_t v26 = vceqzq_f64(v25);
      unint64_t v27 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v26, 1), (int8x16_t)v26).u64[0];
      int8x16_t v28 = 0uLL;
      if ((v27 & 0x8000000000000000) == 0)
      {
        int8x16_t v29 = vorrq_s8((int8x16_t)vcltzq_f64(v25), (int8x16_t)vcgezq_f64(v25));
        float64x2_t v30 = (float64x2_t)vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v29), 1), v29);
        if ((*(void *)&v30.f64[0] & 0x8000000000000000) == 0)
        {
          v30.f64[0] = (double)SDWORD1(v40);
          *(void *)&v31.f64[1] = v24.i64[1];
          v31.f64[0] = (double)(int)v40;
          *(void *)&v32.f64[0] = *(_OWORD *)&vdivq_f64(v31, v30);
          v30.f64[1] = (double)SDWORD2(v40) / (double)SHIDWORD(v40) + v25.f64[1];
          v32.f64[1] = vsubq_f64(*(float64x2_t *)&v24, v30).f64[1];
          float64x2_t v33 = vmlaq_f64(v32, (float64x2_t)xmmword_184998460, vsubq_f64((float64x2_t)v24, v25));
          int32x4_t v34 = (int32x4_t)vcvtpq_s64_f64(vmaxnmq_f64(v33, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
          int8x16_t v28 = (int8x16_t)vuzp1q_s32(v34, (int32x4_t)vsubq_s64(vcvtmq_s64_f64(vminnmq_f64(vaddq_f64(v33, v25), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v34));
        }
      }
      *((_WORD *)this + 12) = v28.i16[0];
      *((_WORD *)this + 13) = v28.i16[2];
      int32x2_t v35 = vsub_s32(v22, vadd_s32(*(int32x2_t *)v28.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL)));
      *((_WORD *)this + 15) = v35.i16[2];
      *((_WORD *)this + 14) = v35.i16[0];
    }
  }
  if ((v8 & (v2 >> 4)) == 1)
  {
    if ((BYTE12(v42) | 2) == 0x12) {
      *((_WORD *)this + 168) |= 0x400u;
    }
    __int16 v36 = 2;
    if (BYTE10(v42) != 14 && BYTE10(v42) != 248) {
      __int16 v36 = 1;
    }
    *((_WORD *)this + 168) = *((_WORD *)this + 168) & 0xFFFC | v36;
  }
  if ((v8 & (v2 >> 5)) == 1)
  {
    CA::Render::iosurface_get_edr_headroom(v4, v6);
    *((_DWORD *)this + 14) = v37;
  }
  if ((v7 & v8) == 1) {
    *((_WORD *)this + 168) &= ~8u;
  }
  return CA::Render::Surface::reload_iosurface_needs_film_grain(this);
}

unint64_t CA::Render::ImageQueue::forward_dm(os_unfair_lock_s *this, CA::Render::Context *a2, CA::Render::Update *a3, float a4, int a5, int a6, unsigned char *a7, BOOL *a8)
{
  unint64_t v8 = (unint64_t)a2;
  uint64_t v208 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return v8;
  }
  CGColorSpaceRef v11 = this;
  locint k = this + 14;
  os_unfair_lock_lock(this + 14);
  uint64_t v13 = *(void *)&v11[6]._os_unfair_lock_opaque;
  if (!v13 || *(unsigned char *)(v13 + 12) != 51) {
    goto LABEL_279;
  }
  uint64_t v191 = *(void *)(*(void *)&v11[4]._os_unfair_lock_opaque + 24);
  if (CADeviceSupportsHDRProcessing::once[0] != -1) {
    dispatch_once(CADeviceSupportsHDRProcessing::once, &__block_literal_global_175);
  }
  if (!CADeviceSupportsHDRProcessing::supports_hdr) {
    goto LABEL_279;
  }
  uint64_t v183 = (CA::Render::Context *)v8;
  CFTypeRef v14 = *(unsigned int **)&v11[6]._os_unfair_lock_opaque;
  CFTypeID v15 = *(unsigned int **)&v11[20]._os_unfair_lock_opaque;
  uint32_t os_unfair_lock_opaque = *((_DWORD *)a3 + 120);
  if (!os_unfair_lock_opaque)
  {
    uint32_t os_unfair_lock_opaque = v11[36]._os_unfair_lock_opaque;
    *((_DWORD *)a3 + 12CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = os_unfair_lock_opaque;
  }
  uint32_t v176 = os_unfair_lock_opaque;
  int v17 = v14;
  float v18 = (_DWORD *)((char *)a3 + 1084);
  float v175 = (CA::Shape **)((char *)a3 + 16);
  float v19 = 1.0;
  __asm { FMOV            V14.2S, #1.0 }
  uint64_t v180 = (CA::Render::Surface *)v14;
  char v177 = (_DWORD *)((char *)a3 + 1084);
  float v178 = (atomic_uint *)v14;
  unsigned __int8 v187 = a3;
  unsigned int v182 = (CA::Render::ImageQueue *)v11;
  while (1)
  {
    uint64_t v22 = CA::Render::ImageQueue::hdr_processor((CA::Render::ImageQueue *)v11, v12);
    int v24 = a5;
    if (!(*(unsigned int (**)(uint64_t, unsigned int *, CA::Render::Update *))(*(void *)v22 + 40))(v22, v17, a3))int v24 = -1; {
    uint64_t v25 = CA::Render::ImageQueue::hdr_processor((CA::Render::ImageQueue *)v11, v23);
    }
    if (!(*(unsigned int (**)(uint64_t, unsigned int *, CA::Render::Update *))(*(void *)v25 + 48))(v25, v17, a3))a4 = v19; {
    a5 = v24;
    }
    if (v24 == -1) {
      int v26 = 0;
    }
    else {
      int v26 = v24;
    }
    unsigned int v184 = v26;
    if ((*v18 & 4) != 0) {
      unint64_t v27 = 0;
    }
    else {
      unint64_t v27 = v15;
    }
    double v28 = a4;
    if (*(float *)&v11[24]._os_unfair_lock_opaque + 0.01 >= a4) {
      int8x16_t v29 = v27;
    }
    else {
      int8x16_t v29 = 0;
    }
    double v30 = *(double *)&v11[32]._os_unfair_lock_opaque;
    float v31 = *(float *)&v11[34]._os_unfair_lock_opaque;
    if (v29) {
      float64x2_t v32 = v29;
    }
    else {
      float64x2_t v32 = v14;
    }
    __int16 v33 = *((_WORD *)v32 + 168);
    if (a6) {
      goto LABEL_75;
    }
    if (BYTE3(xmmword_1EB2ACC10)) {
      goto LABEL_286;
    }
    int v34 = *((_DWORD *)a3 + 120);
    uint64_t v35 = CA::Render::ImageQueue::resolved_display_attributes(v182, a3);
    uint64_t v36 = v35;
    if (*(unsigned char *)(v35 + 54) || *(_DWORD *)(v35 + 60) == 2)
    {
      if ((*(unsigned int (**)(unsigned int *))(*(void *)v17 + 264))(v17))
      {
        int v37 = (__IOSurface *)*((void *)v17 + 14);
        memset(v206, 0, 116);
        *(void *)double v207 = 116;
        if (!IOSurfaceGetBulkAttachments() && *(void *)v207 == 116 && v206[60] != 18)
        {
          if (v206[60] == 16 && v206[59] <= 0xCu && ((1 << v206[59]) & 0x1202) != 0)
          {
            CFTypeRef v38 = IOSurfaceCopyValue(v37, (CFStringRef)_kHDRProcessingDolbyVisionRPUDataKey);
            if (!v38) {
              goto LABEL_283;
            }
            goto LABEL_42;
          }
          CFDictionaryRef v39 = IOSurfaceCopyAllValues(v37);
          if (!CFDictionaryGetValue(v39, (const void *)_kHDRProcessingDolbyVisionRPUDataKey))
          {
            BOOL Bool = CA_CFDictionaryGetBool(v39, @"isHLG");
            if (v39) {
              CFRelease(v39);
            }
            if (!Bool)
            {
LABEL_283:
              float v158 = *(float *)(v36 + 28);
              if (v158 == 0.0) {
                float v158 = 1.0;
              }
              CA::Render::Surface::set_edr_factor((uint64_t)v17, v158);
              *((_WORD *)v17 + 168) |= 0x10u;
LABEL_286:
              if ((*(unsigned int (**)(unsigned int *))(*(void *)v17 + 280))(v17)
                && a4 != *((float *)v182 + 37))
              {
                if (a7) {
                  *a7 = 1;
                }
                *((float *)v182 + 37) = a4;
              }
              unint64_t v8 = (*((unsigned __int16 *)v17 + 168) >> 5) & 1;
              goto LABEL_280;
            }
            goto LABEL_46;
          }
          if (v39)
          {
            CFTypeRef v38 = v39;
LABEL_42:
            CFRelease(v38);
          }
        }
      }
    }
LABEL_46:
    long long v41 = (CA::ScalerStatistics *)v17[4];
    uint64_t v42 = v17[5];
    if (!v34 && (v33 & 0x20) != 0 || v34 == 3 && (v17[84] & 0x20) != 0)
    {
      if (*(unsigned char *)(v36 + 56))
      {
        int v43 = (CA::CAPSEProcessor *)(*(uint64_t (**)(unsigned int *))(*(void *)v17 + 264))(v17);
        if (v43)
        {
          if (BYTE12(xmmword_1EB2ACC50) || (CA::CAPSEProcessor::needs_processing(v43) & 1) == 0)
          {
            int v44 = v184 & 7;
            _ZF = v44 == 4 || v44 == 7;
            if (!_ZF && v17[4] >> 10 <= 4 && v17[5] <= 0xFFF)
            {
              if (CADeviceSupportsDCP::once[0] != -1) {
                dispatch_once(CADeviceSupportsDCP::once, &__block_literal_global_295);
              }
              if (!CADeviceSupportsDCP::has_dcp) {
                goto LABEL_317;
              }
              unsigned int CacheMode = v17[83];
              if (CacheMode == -1)
              {
                unsigned int CacheMode = IOSurfaceGetCacheMode();
                v17[83] = CacheMode;
              }
              if ((CacheMode & 0xF00) == 0x700)
              {
LABEL_317:
                if (CA::Render::display_tonemap_supports_pixel_format((CA::Render *)v17[32])
                  && !*((unsigned char *)v182 + 176)
                  && *(double *)(v36 + 32) * 1.01 < v28
                  && *(double *)(v36 + 40) * 0.99 > v28
                  && (CA::ScalerStatistics::should_enhance(v41, v42, (unint64_t)(float)(a4 * (float)v41), (unint64_t)(float)(a4 * (float)v42)) & 1) == 0&& CA::CAHDRProcessor::can_display_tonemap(*((CA::CAHDRProcessor **)v17 + 14), v47))
                {
                  CA::Render::Surface::reload_iosurface_color_attributes((CA::Render::Surface *)v17, v48);
                  if (((*(uint64_t (**)(unsigned int *))(*(void *)v17 + 256))(v17) & 1) == 0)
                  {
                    uint64_t v159 = (atomic_uint *)*((void *)v182 + 10);
                    if (v159)
                    {
                      if (atomic_fetch_add(v159 + 2, 0xFFFFFFFF) == 1) {
                        (*(void (**)(atomic_uint *))(*(void *)v159 + 16))(v159);
                      }
                      *((void *)v182 + 1CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
                    }
                    *((_WORD *)v180 + 168) |= 0x200u;
                    *(_DWORD *)&v206[64] = 0;
                    *(_OWORD *)&v206[128] = 0u;
                    memset(v206, 0, 20);
                    *(_OWORD *)&v206[20] = xmmword_184997E20;
                    *(_DWORD *)&v206[36] = 1065353216;
                    *(_OWORD *)&v206[40] = xmmword_184997E30;
                    *(void *)&v206[56] = 0;
                    *(void *)&v206[68] = 0x100000001;
                    memset(&v206[76], 0, 36);
                    *(_DWORD *)&v206[112] = 1065353216;
                    *(_OWORD *)&v206[116] = 0uLL;
                    *(_DWORD *)&v206[132] = -1;
                    float v160 = (atomic_uint *)CA::Render::ImageQueue::hdr_processor(v182, v49);
                    X::Ref<CA::CAHDRProcessor>::operator=((atomic_uint **)v206, v160);
                    v206[136] = (*(uint64_t (**)(CA::Render::Surface *))(*(void *)v180 + 264))(v180) ^ 1;
                    long long v161 = *(_OWORD *)(v36 + 32);
                    long long v162 = *(_OWORD *)(v36 + 48);
                    long long v163 = *(_OWORD *)(v36 + 16);
                    *(_OWORD *)&v206[8] = *(_OWORD *)v36;
                    *(_OWORD *)&v206[56] = v162;
                    *(_OWORD *)&v206[40] = v161;
                    *(_OWORD *)&v206[24] = v163;
                    long long v164 = *(_OWORD *)(v36 + 96);
                    long long v165 = *(_OWORD *)(v36 + 112);
                    long long v166 = *(_OWORD *)(v36 + 80);
                    *(_OWORD *)&v206[72] = *(_OWORD *)(v36 + 64);
                    *(_OWORD *)&v206[120] = v165;
                    *(_OWORD *)&v206[104] = v164;
                    *(_OWORD *)&v206[88] = v166;
                    uint64_t v167 = *(atomic_uint **)v206;
                    if (*(void *)v206) {
                      atomic_fetch_add((atomic_uint *volatile)(*(void *)v206 + 16), 1u);
                    }
                    long long v202 = *(_OWORD *)&v206[88];
                    long long v203 = *(_OWORD *)&v206[104];
                    long long v204 = *(_OWORD *)&v206[120];
                    long long v198 = *(_OWORD *)&v206[24];
                    long long v199 = *(_OWORD *)&v206[40];
                    long long v200 = *(_OWORD *)&v206[56];
                    long long v201 = *(_OWORD *)&v206[72];
                    *(void *)long long buf = v167;
                    char v205 = v206[136];
                    long long v197 = *(_OWORD *)&v206[8];
                    __n128 v168 = CA::Render::Surface::set_tonemap_cfg((uint64_t)v180, (uint64_t)buf);
                    if (v167 && atomic_fetch_add(v167 + 4, 0xFFFFFFFF) == 1) {
                      (*(void (**)(atomic_uint *, __n128))(*(void *)v167 + 8))(v167, v168);
                    }
                    if (*(_DWORD *)(v36 + 60) == 2)
                    {
                      float v169 = *(float *)(v36 + 28);
                      if (v169 == 0.0) {
                        float v169 = 1.0;
                      }
                      CA::Render::Surface::set_edr_factor((uint64_t)v180, v169);
                    }
                    if (BYTE12(xmmword_1EB2ACC30))
                    {
                      if (x_log_hook_p())
                      {
                        x_log_();
                      }
                      else
                      {
                        uint64_t v171 = x_log_category_render;
                        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEBUG))
                        {
                          int v172 = *((_DWORD *)v180 + 26);
                          *(_DWORD *)double v207 = 67109120;
                          *(_DWORD *)&v207[4] = v172;
                          _os_log_impl(&dword_184668000, v171, OS_LOG_TYPE_DEBUG, "Try Display TM, and Skip MSR/GPU TM on surface (0x%x)", v207, 8u);
                        }
                      }
                    }
                    uint64_t v170 = *(void *)v206;
                    if (*(void *)v206
                      && atomic_fetch_add((atomic_uint *volatile)(*(void *)v206 + 16), 0xFFFFFFFF) == 1)
                    {
                      (*(void (**)(uint64_t))(*(void *)v170 + 8))(v170);
                    }
                    int v17 = (unsigned int *)v180;
                    goto LABEL_286;
                  }
                }
              }
            }
          }
        }
      }
    }
    a3 = v187;
LABEL_75:
    BOOL v50 = 0;
    if ((v33 & 0x20) != 0 && v31 != 0.0) {
      BOOL v50 = (*v18 & 4) == 0 && BYTE13(xmmword_1EB2ACC10) == 0;
    }
    uint64_t v179 = (uint64_t)v29;
    char v51 = *((unsigned char *)v17 + 328);
    uint64_t v52 = *((void *)v182 + 15);
    if (!v52) {
      operator new[]();
    }
    IOSurfaceID ID = IOSurfaceGetID(*((IOSurfaceRef *)v17 + 14));
    unsigned int v192 = v17[8];
    float v55 = *((float *)v182 + 22);
    float v54 = *((float *)v182 + 23);
    BOOL v193 = v50;
    if (v50)
    {
      for (uint64_t i = 0; i != 144; i += 48)
      {
        if (*(void *)(v52 + i))
        {
          uint64_t v57 = (*(uint64_t (**)(unsigned int *))(*(void *)v17 + 240))(v17);
          uint64_t v58 = (*(uint64_t (**)(void))(**(void **)(v52 + i) + 240))(*(void *)(v52 + i));
          int v59 = *(atomic_uint **)(v52 + i);
          if (v57 != v58)
          {
            if (v59)
            {
LABEL_92:
              if (atomic_fetch_add(v59 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v59 + 16))(v59);
              }
              *(void *)(v52 + i) = 0;
            }
            uint64_t v60 = v52 + i;
            int v61 = *(atomic_uint **)(v52 + i + 8);
            if (v61)
            {
              if (atomic_fetch_add(v61 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v61 + 16))(v61);
              }
              *(void *)(v60 + 8) = 0;
            }
            *(void *)(v60 + 16) = 0xFFF0000000000000;
            *(void *)(v60 + 24) = 0;
            *(void *)(v60 + 32) = _D14;
            *(_DWORD *)(v60 + 4CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
            *(unsigned char *)(v60 + 44) = 0;
            continue;
          }
          if (v17[4] != v59[4]
            || v17[5] != v59[5]
            || a4 != *(float *)(v52 + i + 32)
            || *(unsigned __int8 *)(v52 + i + 44) != a6)
          {
            goto LABEL_92;
          }
        }
      }
    }
    uint64_t v189 = CA::Render::ImageQueue::resolved_display_attributes(v182, a3);
    if ((v33 & 0x20) == 0)
    {
      char v186 = 0;
      CGColorSpaceRef v11 = (os_unfair_lock_s *)v182;
      uint64_t v88 = v183;
      BOOL v86 = v193;
      goto LABEL_169;
    }
    uint64_t v63 = 0;
    unint64_t v64 = 0;
    char v65 = 1;
    CGColorSpaceRef v11 = (os_unfair_lock_s *)v182;
    do
    {
      if (*(_DWORD *)(v52 + v63 + 28) == ID && *(double *)(v52 + v63 + 16) == *((double *)v182 + 5))
      {
        uint64_t v66 = v52 + v63;
        if (*(_DWORD *)(v52 + v63 + 24) == *((_DWORD *)v182 + 47) && *(float *)(v66 + 32) == a4)
        {
          uint64_t v67 = v52 + v63;
          if (*(unsigned __int8 *)(v52 + v63 + 44) == a6)
          {
            char v186 = v65;
            size_t v68 = (CA::CAHDRProcessor *)CA::Render::ImageQueue::hdr_processor(v182, v62);
            if ((CA::CAHDRProcessor::should_invalidate_tonemapping(v68, *(float *)(v67 + 36), *(float *)(v189 + 20), *(float *)(v67 + 40), *(float *)(v189 + 12)) & 1) == 0)
            {
              uint64_t v148 = *(atomic_uint **)(v52 + 48 * v64 + 8);
              float v149 = (atomic_uint *)*((void *)v182 + 10);
              if (v149 == v148)
              {
                uint64_t v88 = v183;
                char v74 = v51;
              }
              else
              {
                uint64_t v88 = v183;
                char v74 = v51;
                if (v149 && atomic_fetch_add(v149 + 2, 0xFFFFFFFF) == 1) {
                  (*(void (**)(atomic_uint *))(*(void *)v149 + 16))(v149);
                }
                if (v148)
                {
                  uint64_t v150 = v148 + 2;
                  if (!atomic_fetch_add(v148 + 2, 1u))
                  {
                    uint64_t v148 = 0;
                    atomic_fetch_add(v150, 0xFFFFFFFF);
                  }
                }
                *((void *)v182 + 1CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v148;
              }
              *((void *)v182 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(void *)(v67 + 36);
              *((_DWORD *)v182 + 24) = *(_DWORD *)(v66 + 32);
              CA::Render::Surface::ensure_scheduled_block((CA::Render::Surface *)v148);
              if (BYTE12(xmmword_1EB2ACC30))
              {
                if (x_log_hook_p())
                {
                  CGColorSpaceRef v11 = (os_unfair_lock_s *)v182;
                  uint64_t v173 = *((unsigned int *)v180 + 26);
                  uint64_t v174 = *(unsigned int *)(*((void *)v182 + 10) + 104);
                  x_log_();
                }
                else
                {
                  float v153 = x_log_category_render;
                  if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEBUG))
                  {
                    int v154 = *((_DWORD *)v180 + 26);
                    CGColorSpaceRef v11 = (os_unfair_lock_s *)v182;
                    int v155 = *(_DWORD *)(*((void *)v182 + 10) + 104);
                    *(_DWORD *)uint64_t v206 = 67109376;
                    *(_DWORD *)&v206[4] = v154;
                    *(_WORD *)&v206[8] = 1024;
                    *(_DWORD *)&v206[10] = v155;
                    _os_log_impl(&dword_184668000, v153, OS_LOG_TYPE_DEBUG, "No Display TM, using previously MSR/GPU tonemapped ForwardDMCache src (0x%x), tm_cache_surf (0x%x)", v206, 0xEu);
                  }
                  else
                  {
                    CGColorSpaceRef v11 = (os_unfair_lock_s *)v182;
                  }
                }
                a3 = v187;
                uint64_t v88 = v183;
                BOOL v86 = v193;
                char v74 = v51;
              }
              else
              {
LABEL_161:
                BOOL v86 = v193;
              }
              goto LABEL_163;
            }
          }
        }
      }
      _CF = v64++ >= 2;
      char v65 = !_CF;
      v63 += 48;
    }
    while (v63 != 144);
    if (BYTE9(xmmword_1EB2ACC10)) {
      kdebug_trace();
    }
    *((_DWORD *)v182 + 22) = *(_DWORD *)(v189 + 20);
    *((_DWORD *)v182 + 23) = *(_DWORD *)(v189 + 12);
    uint64_t v69 = CA::Render::ImageQueue::hdr_processor(v182, v62);
    uint64_t v72 = (*(uint64_t (**)(uint64_t, CA::Render::Update *))(*(void *)v69 + 56))(v69, a3);
    uint64_t v73 = (CGColorSpace *)*((void *)v17 + 6);
    char v74 = v51;
    if (v73) {
      CA::Render::iosurface_set_bulk_from_colorspace(*((CA::Render **)v17 + 14), v73, v70, v71);
    }
    if (BYTE12(xmmword_1EB2ACC30))
    {
      if (x_log_hook_p())
      {
        int v17 = (unsigned int *)v180;
        uint64_t v173 = *((unsigned int *)v180 + 26);
        x_log_();
        CGColorSpaceRef v11 = (os_unfair_lock_s *)v182;
        float v19 = 1.0;
        char v74 = v51;
      }
      else
      {
        uint64_t v151 = x_log_category_render;
        CGColorSpaceRef v11 = (os_unfair_lock_s *)v182;
        int v17 = (unsigned int *)v180;
        float v19 = 1.0;
        char v74 = v51;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEBUG))
        {
          int v152 = *((_DWORD *)v180 + 26);
          *(_DWORD *)uint64_t v206 = 67109120;
          *(_DWORD *)&v206[4] = v152;
          _os_log_impl(&dword_184668000, v151, OS_LOG_TYPE_DEBUG, "No Display TM, using MSR/GPU TM on surface (0x%x)", v206, 8u);
        }
      }
    }
    uint64_t v75 = CA::Render::ImageQueue::hdr_processor((CA::Render::ImageQueue *)v11, v73);
    unint64_t v76 = v11;
    uint64_t v77 = (*(unsigned int (**)(unsigned int *))(*(void *)v17 + 264))(v17) ^ 1 | a6;
    uint64_t v78 = (*(uint64_t (**)(unsigned int *))(*(void *)v17 + 256))(v17);
    unsigned int v79 = *(uint64_t (**)(uint64_t, unsigned int *, CA::Render::Update *, uint64_t, uint64_t, void, uint64_t, uint64_t, float, uint64_t))(*(void *)v75 + 24);
    LOWORD(v173) = 0;
    uint64_t v80 = v75;
    a3 = v187;
    uint64_t v81 = v79(v80, v17, v187, v189, v72, v184, v77, v78, a4, v173);
    if (v81) {
      break;
    }
    CFTypeRef v14 = (unsigned int *)v178;
    if (CADeviceSupportsToneMapAcceleratorSwitching::once[0] != -1) {
      dispatch_once(CADeviceSupportsToneMapAcceleratorSwitching::once, &__block_literal_global_248);
    }
    CGColorSpaceRef v11 = (os_unfair_lock_s *)v182;
    float v18 = v177;
    if (!CADeviceSupportsToneMapAcceleratorSwitching::accelerator_switching || v176 == *((_DWORD *)v187 + 120))
    {
      unint64_t v8 = 0;
      *((unsigned char *)v182 + 14CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
      goto LABEL_280;
    }
    memset(v206, 0, 48);
    CA::Shape::operator=((uint64_t)v206, CA::RectTraits<int>::infinity);
    CA::shape_union(v175, (CA::Shape **)v206, v89);
    CFTypeID v15 = 0;
LABEL_252:
    uint32_t v176 = *((_DWORD *)a3 + 120);
  }
  uint64_t v82 = v81;
  v76[36]._uint32_t os_unfair_lock_opaque = *(_DWORD *)((uint32_t)v187 + 480);
  unsigned int v83 = *(atomic_uint **)&v76[20]._os_unfair_lock_opaque;
  uint64_t v179 = v82;
  *(void *)&v76[20]._uint32_t os_unfair_lock_opaque = v82;
  CGColorSpaceRef v11 = v76;
  if (v83 && atomic_fetch_add(v83 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v83 + 16))(v83);
  }
  *(float *)&v76[24]._uint32_t os_unfair_lock_opaque = a4;
  unint64_t v84 = v17[3];
  unsigned int v85 = v84 >> 8;
  BOOL v86 = v193;
  if (a5 == -1)
  {
    unsigned int v87 = *(_DWORD *)(v179 + 12);
  }
  else
  {
    unsigned int v87 = *(_DWORD *)(v179 + 12) & 0xFFFFF8FF | (image_queue_rotation_from_logical_rotation(CAMetalLayerRotation,BOOL)::invert_table[concat_table[(8 * a5) | (unint64_t)image_queue_rotation_from_logical_rotation(CAMetalLayerRotation,BOOL)::invert_table[(v84 >> 8) & 7]]] << 8);
    v85 &= 0xFFFFF8u;
  }
  *(_DWORD *)(v179 + 12) = v87 | (v85 << 8);
  *(_WORD *)(v179 + 336) = *(_WORD *)(v179 + 336) & 0xFFBF | v17[84] & 0x40;
  if ((*v177 & 4) == 0)
  {
    char v90 = 0;
    uint64_t v91 = 0;
    uint64_t v92 = 1;
    do
    {
      char v93 = v90;
      if (v31 > 0.0
        && ((double v94 = *(double *)(v52 + 48 * v92 + 16), v95 = *(double *)(v52 + 48 * v91 + 16), v94 < v95)
         && *(_DWORD *)(v52 + 48 * v92 + 24) == *(_DWORD *)(v52 + 48 * v91 + 24)
         || v94 == v95 && *(_DWORD *)(v52 + 48 * v92 + 24) < *(_DWORD *)(v52 + 48 * v91 + 24))
        || v31 < 0.0
        && ((double v96 = *(double *)(v52 + 48 * v92 + 16), v97 = *(double *)(v52 + 48 * v91 + 16), v96 > v97)
         && *(_DWORD *)(v52 + 48 * v92 + 24) == *(_DWORD *)(v52 + 48 * v91 + 24)
         || v96 == v97 && *(_DWORD *)(v52 + 48 * v92 + 24) < *(_DWORD *)(v52 + 48 * v91 + 24)))
      {
        uint64_t v91 = v92;
      }
      char v90 = 1;
      uint64_t v92 = 2;
    }
    while ((v93 & 1) == 0);
    double v98 = (atomic_uint **)(v52 + 48 * v91);
    uint64_t v99 = *v98;
    if (*v98 != v178)
    {
      if (v99 && atomic_fetch_add(v99 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v99 + 16))(v99);
      }
      if (v17 && !atomic_fetch_add(v178 + 2, 1u))
      {
        int v17 = 0;
        atomic_fetch_add(v178 + 2, 0xFFFFFFFF);
      }
      *double v98 = (atomic_uint *)v17;
    }
    uint64_t v100 = v52 + 48 * v91;
    uint64_t v103 = *(atomic_uint **)(v100 + 8);
    float v102 = (uint64_t *)(v100 + 8);
    __int16 v101 = v103;
    uint64_t v88 = v183;
    if (v103 != (atomic_uint *)v179)
    {
      if (v101 && atomic_fetch_add(v101 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v101 + 16))(v101);
      }
      uint64_t v104 = v179;
      if (!atomic_fetch_add((atomic_uint *volatile)(v179 + 8), 1u))
      {
        uint64_t v104 = 0;
        atomic_fetch_add((atomic_uint *volatile)(v179 + 8), 0xFFFFFFFF);
      }
      *float v102 = v104;
    }
    char v186 = 0;
    uint64_t v105 = v52 + 48 * v91;
    *(_DWORD *)(v105 + 28) = ID;
    *(void *)(v105 + 16) = *(void *)&v11[10]._os_unfair_lock_opaque;
    *(os_unfair_lock_s *)(v105 + 24) = v11[47];
    *(float *)(v105 + 32) = a4;
    *(_DWORD *)(v105 + 36) = *(_DWORD *)(v189 + 20);
    *(unsigned char *)(v105 + 44) = a6;
    goto LABEL_161;
  }
  char v186 = 0;
  uint64_t v88 = v183;
LABEL_163:
  uint64_t v106 = *(void *)&v11[20]._os_unfair_lock_opaque;
  if (v106)
  {
    if (a4 != *(float *)&v11[37]._os_unfair_lock_opaque)
    {
      if (a7) {
        *a7 = 1;
      }
      *(float *)&v11[37]._uint32_t os_unfair_lock_opaque = a4;
    }
    *(_DWORD *)(v106 + 32) = v192;
    atomic_fetch_add((atomic_uint *volatile)(v106 + 36), 1u);
    LOBYTE(v11[35]._os_unfair_lock_opaque) = 1;
    *(unsigned char *)(*(void *)&v11[20]._os_unfair_lock_opaque + 328) = v74;
  }
LABEL_169:
  if (!v86) {
    goto LABEL_279;
  }
  if (*(float *)&v11[22]._os_unfair_lock_opaque >= 1.0 && v55 >= 1.0)
  {
    char v108 = (CA::CAHDRProcessor *)CA::Render::ImageQueue::hdr_processor((CA::Render::ImageQueue *)v11, v62);
    if (CA::CAHDRProcessor::should_invalidate_tonemapping(v108, v55, *(float *)&v11[22]._os_unfair_lock_opaque, v54, *(float *)&v11[23]._os_unfair_lock_opaque))goto LABEL_279; {
  }
    }
  uint64_t v109 = 0;
  int v110 = 0;
  double v111 = *((double *)a3 + 14);
  double v112 = v111;
  while (2)
  {
    uint64_t v113 = v52 + 48 * v109;
    unint64_t v114 = (void *)(v113 + 16);
    double v115 = *(double *)(v113 + 16) - *(double *)&v11[10]._os_unfair_lock_opaque;
    if (v31 < 0.0) {
      double v115 = -v115;
    }
    _CF = *(uint64_t *)&v115 <= -1 || ((*(void *)&v115 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 >= 0x3FF;
    BOOL v118 = !_CF
        || (unint64_t)(*(void *)&v115 - 1) < 0xFFFFFFFFFFFFFLL
        || (*(void *)&v115 & 0x7FFFFFFFFFFFFFFFLL) == 0;
    if (v118 && v115 < 0.208333333 && *(_DWORD *)(v52 + 48 * v109 + 24) >= v11[47]._os_unfair_lock_opaque) {
      goto LABEL_238;
    }
    double v119 = *(atomic_uint **)v113;
    if (*(void *)v113)
    {
      if (atomic_fetch_add(v119 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v119 + 16))(v119);
      }
      *(void *)uint64_t v113 = 0;
    }
    uint64_t v194 = v52 + 48 * v109;
    double v121 = (atomic_uint **)(v194 + 8);
    long long v120 = *(atomic_uint **)(v194 + 8);
    if (v120)
    {
      if (atomic_fetch_add(v120 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v120 + 16))(v120);
      }
      *double v121 = 0;
    }
    uint64_t v122 = v52 + 48 * v109;
    *(void *)(v122 + 32) = _D14;
    uint64_t v123 = v122 + 32;
    *(_DWORD *)(v123 - 4) = 0;
    *(_DWORD *)(v123 - 8) = 0;
    *(_DWORD *)(v123 + 8) = 0;
    *unint64_t v114 = 0xFFF0000000000000;
    *(unsigned char *)(v123 + 12) = 0;
    if (v110 > 1 || !(v186 & 1 | (v110 != 1)))
    {
LABEL_238:
      if (++v109 == 3) {
        goto LABEL_279;
      }
      continue;
    }
    break;
  }
  memset(v206, 0, 136);
  if (v112 > 0.200000003) {
    goto LABEL_279;
  }
  int v188 = v110;
LABEL_203:
  if (!CAShmemImageQueueCopyImageInfo((uint64_t *)v11, v11[45]._os_unfair_lock_opaque, v191, (uint64_t)a3, (uint64_t)v206, 0, 0, 0, v30 + v112 * v31, v31)|| (uint64_t v124 = CA::Render::Context::lookup_object(*((void *)v88 + 17), *((_DWORD *)v88 + 37), *(uint64_t *)&v206[48], 0, 0, 0)) == 0)
  {
LABEL_236:
    if (!*v121)
    {
      double v156 = *(atomic_uint **)v194;
      if (*(void *)v194)
      {
        if (atomic_fetch_add(v156 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v156 + 16))(v156);
        }
        *(void *)uint64_t v194 = 0;
      }
      *(_OWORD *)(v194 + 16) = 0u;
      *(_OWORD *)(v194 + 32) = 0u;
      *(_OWORD *)uint64_t v194 = 0u;
      goto LABEL_279;
    }
    double v112 = v112 + v111;
    goto LABEL_238;
  }
  uint64_t v125 = (CA::Render::Surface *)(*(uint64_t (**)(uint64_t))(*(void *)v124 + 80))(v124);
  if (!v125 || (uint64_t v126 = (uint64_t)v125, *((unsigned char *)v125 + 12) != 51))
  {
    int v110 = v188;
    goto LABEL_236;
  }
  CA::Render::Surface::reload_iosurface_needs_film_grain(v125);
  if (!*(void *)(v126 + 112) || (*(_WORD *)(v126 + 336) & 0x20) == 0)
  {
    int v110 = v188;
    goto LABEL_238;
  }
  CA::Render::update_texture_flags(v126, v191, *(unsigned int *)&v206[8], *(unsigned int *)&v206[20]);
  IOSurfaceID v127 = IOSurfaceGetID(*(IOSurfaceRef *)(v126 + 112));
  IOSurfaceID v131 = v127;
  for (uint64_t j = 0; j != 144; j += 48)
  {
    if (*(double *)(v52 + j + 16) == *(double *)&v206[56]
      && *(_DWORD *)(v52 + j + 24) == *(_DWORD *)&v206[4]
      && *(_DWORD *)(v52 + j + 28) == v127)
    {
      double v112 = v112 + v111;
      int v110 = v188;
      if (v112 <= 0.200000003) {
        goto LABEL_203;
      }
      goto LABEL_279;
    }
  }
  if (*(void *)(v126 + 48)) {
    CA::Render::iosurface_set_bulk_from_colorspace(*((CA::Render **)v180 + 14), *((CGColorSpaceRef *)v180 + 6), v129, v130);
  }
  if (BYTE12(xmmword_1EB2ACC30))
  {
    if (x_log_hook_p())
    {
      uint64_t v173 = *(unsigned int *)(v126 + 104);
      x_log_();
    }
    else
    {
      float v146 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEBUG))
      {
        int v147 = *(_DWORD *)(v126 + 104);
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v147;
        _os_log_impl(&dword_184668000, v146, OS_LOG_TYPE_DEBUG, "Pre-warming using MSR/GPU tonemapping on surface (0x%x)", buf, 8u);
      }
    }
  }
  uint64_t v133 = v11;
  uint64_t v134 = CA::Render::ImageQueue::hdr_processor((CA::Render::ImageQueue *)v11, v128);
  uint64_t v135 = (*(unsigned int (**)(uint64_t))(*(void *)v126 + 264))(v126) ^ 1 | a6;
  uint64_t v136 = (*(uint64_t (**)(uint64_t))(*(void *)v126 + 256))(v126);
  LOWORD(v173) = 256;
  uint64_t v137 = (*(uint64_t (**)(uint64_t, uint64_t, CA::Render::Update *, uint64_t, uint64_t, void, uint64_t, uint64_t, float, uint64_t, uint64_t))(*(void *)v134 + 24))(v134, v126, v187, v189, 1, v184, v135, v136, a4, v173, v174);
  if (v137)
  {
    uint64_t v138 = v137;
    v133[36]._uint32_t os_unfair_lock_opaque = *(_DWORD *)((uint32_t)v187 + 480);
    unint64_t v139 = *(unsigned int *)(v126 + 12);
    unsigned int v140 = v139 >> 8;
    CGColorSpaceRef v11 = v133;
    if (a5 == -1)
    {
      unsigned int v141 = *(_DWORD *)(v137 + 12);
    }
    else
    {
      unsigned int v141 = *(_DWORD *)(v137 + 12) & 0xFFFFF8FF | (image_queue_rotation_from_logical_rotation(CAMetalLayerRotation,BOOL)::invert_table[concat_table[(8 * a5) | (unint64_t)image_queue_rotation_from_logical_rotation(CAMetalLayerRotation,BOOL)::invert_table[(v139 >> 8) & 7]]] << 8);
      v140 &= 0xFFFFF8u;
    }
    uint64_t v88 = v183;
    int v142 = (unsigned char *)(v123 + 12);
    *(_DWORD *)(v137 + 12) = v141 | (v140 << 8);
    *(_WORD *)(v137 + 336) = *(_WORD *)(v137 + 336) & 0xFFBF | *(_WORD *)(v126 + 336) & 0x40;
    *(_DWORD *)(v123 - 4) = v131;
    int v143 = *(atomic_uint **)v194;
    if (*(void *)v194 != v126)
    {
      if (v143 && atomic_fetch_add(v143 + 2, 0xFFFFFFFF) == 1)
      {
        (*(void (**)(atomic_uint *))(*(void *)v143 + 16))(v143);
        int v142 = (unsigned char *)(v123 + 12);
      }
      unint64_t v144 = (atomic_uint *)(v126 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v126 + 8), 1u))
      {
        uint64_t v126 = 0;
        atomic_fetch_add(v144, 0xFFFFFFFF);
      }
      *(void *)uint64_t v194 = v126;
    }
    uint64_t v145 = *v121;
    *double v121 = (atomic_uint *)v138;
    if (v145 && atomic_fetch_add(v145 + 2, 0xFFFFFFFF) == 1)
    {
      (*(void (**)(atomic_uint *))(*(void *)v145 + 16))(v145);
      int v142 = (unsigned char *)(v123 + 12);
    }
    *unint64_t v114 = *(void *)&v206[56];
    *(_DWORD *)(v123 - 8) = *(_DWORD *)&v206[4];
    *(float *)uint64_t v123 = a4;
    *(_DWORD *)(v123 + 4) = *(_DWORD *)(v189 + 20);
    *(_DWORD *)(v123 + 8) = *(_DWORD *)(v189 + 12);
    *int v142 = a6;
    int v110 = v188 + 1;
    a3 = v187;
    goto LABEL_236;
  }
  if (CADeviceSupportsToneMapAcceleratorSwitching::once[0] != -1) {
    dispatch_once(CADeviceSupportsToneMapAcceleratorSwitching::once, &__block_literal_global_248);
  }
  CGColorSpaceRef v11 = (os_unfair_lock_s *)v182;
  int v17 = (unsigned int *)v180;
  float v18 = v177;
  CFTypeRef v14 = (unsigned int *)v178;
  a3 = v187;
  float v19 = 1.0;
  CFTypeID v15 = (unsigned int *)v179;
  if (CADeviceSupportsToneMapAcceleratorSwitching::accelerator_switching && v176 != *((_DWORD *)v187 + 120))
  {
    CA::Render::Update::invalidate((CA::Shape **)v187, (const CA::Bounds *)CA::RectTraits<int>::infinity);
    goto LABEL_252;
  }
LABEL_279:
  unint64_t v8 = LOBYTE(v11[35]._os_unfair_lock_opaque) != 0;
LABEL_280:
  os_unfair_lock_unlock(lock);
  return v8;
}

void sub_1847792CC(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CA::Render::ImageQueue::resolved_display_attributes(CA::Render::ImageQueue *this, const CA::Render::Update *a2)
{
  float v2 = *((float *)this + 38);
  if (v2 >= 1.0) {
    return (uint64_t)a2 + 352;
  }
  unint64_t v4 = (_OWORD *)*((void *)this + 20);
  if (!v4) {
    operator new();
  }
  long long v5 = *((_OWORD *)a2 + 22);
  long long v6 = *((_OWORD *)a2 + 23);
  long long v7 = *((_OWORD *)a2 + 25);
  id v4[2] = *((_OWORD *)a2 + 24);
  v4[3] = v7;
  *unint64_t v4 = v5;
  v4[1] = v6;
  long long v8 = *((_OWORD *)a2 + 26);
  long long v9 = *((_OWORD *)a2 + 27);
  long long v10 = *((_OWORD *)a2 + 29);
  v4[6] = *((_OWORD *)a2 + 28);
  v4[7] = v10;
  v4[4] = v8;
  v4[5] = v9;
  uint64_t v11 = *((void *)this + 20);
  float v12 = *(float *)(v11 + 12);
  if (v12 != 0.0)
  {
    float v13 = *(float *)(v11 + 20);
    if (v13 != 0.0)
    {
      float v14 = log2f(*(float *)(v11 + 20));
      float v15 = exp2f(v14 * v2);
      *(float *)(v11 + 2CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v15;
      *(float *)(v11 + 12) = (float)(v15 * v12) / v13;
    }
  }
  return v11;
}

uint64_t CA::Render::ImageQueue::hdr_processor(CA::Render::ImageQueue *this, CA::Render::Context *a2)
{
  uint64_t result = *((void *)this + 14);
  if (!result) {
    CA::CAHDRProcessor::new_hdr_processor(0);
  }
  return result;
}

BOOL CA::HDRProcessorInternal::supports_scaling_transforms(CA::HDRProcessorInternal *this, CA::Render::Surface *a2, const CA::Render::Update *a3)
{
  unsigned int v4 = *((_DWORD *)a3 + 120);
  if (CADeviceHasHardwareAcceleratedHDR::once[0] != -1) {
    dispatch_once(CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_132);
  }
  if (!CADeviceHasHardwareAcceleratedHDR::has_capability) {
    return 0;
  }
  if (v4 > 3 || v4 == 2) {
    return 0;
  }
  if (!(*(unsigned int (**)(CA::Render::Surface *))(*(void *)a2 + 256))(a2)) {
    return 1;
  }
  if (CADeviceSupportsFilmGrainScaling::once != -1) {
    dispatch_once(&CADeviceSupportsFilmGrainScaling::once, &__block_literal_global_187);
  }
  return CADeviceSupportsFilmGrainScaling::supports_film_grain_scaling != 0;
}

uint64_t CA::Render::Surface::should_add_film_grain(CA::Render::Surface *this)
{
  return (*((unsigned __int16 *)this + 168) >> 7) & 1;
}

BOOL CA::HDRProcessorInternal::supports_rotation_transforms(CA::HDRProcessorInternal *this, CA::Render::Surface *a2, const CA::Render::Update *a3)
{
  unsigned int v3 = *((_DWORD *)a3 + 120);
  if (CADeviceHasHardwareAcceleratedHDR::once[0] != -1) {
    dispatch_once(CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_132);
  }
  BOOL v5 = v3 < 2 || v3 == 3;
  return CADeviceHasHardwareAcceleratedHDR::has_capability && v5;
}

uint64_t CA::Render::Surface::implicitly_opaque(CA::Render::Surface *this)
{
  unsigned int v1 = *((_DWORD *)this + 27);
  if (v1 != -1 && (v1 > 0x23 || ((0xC99B4EB03uLL >> v1) & 1) == 0)) {
    return 1;
  }
  if (*((void *)this + 14)) {
    return CA::Render::fourcc_has_alpha((CA::Render *)*((unsigned int *)this + 32)) ^ 1;
  }
  return 0;
}

uint64_t CA::Render::fourcc_has_alpha(CA::Render *this)
{
  int v1 = (int)this;
  uint64_t result = 1;
  if (v1 > 1380401728)
  {
    if (v1 <= 1949327730)
    {
      if (v1 <= 1815162993)
      {
        if (v1 > 1395864161)
        {
          if (v1 > 1647534391)
          {
            if (v1 == 1647534392) {
              return result;
            }
            int v3 = 1647719521;
          }
          else
          {
            if (v1 == 1395864162) {
              return result;
            }
            int v3 = 1647522401;
          }
          goto LABEL_86;
        }
        if (v1 != 1380401729 && v1 != 1380410945)
        {
          int v3 = 1380411457;
          goto LABEL_86;
        }
        return result;
      }
      if (v1 > 1932550514)
      {
        if (v1 > 1932812658)
        {
          if (v1 == 1932812659) {
            return result;
          }
          int v3 = 1932866865;
        }
        else
        {
          if (v1 == 1932550515) {
            return result;
          }
          int v3 = 1932681587;
        }
        goto LABEL_86;
      }
      if (v1 == 1815162994 || v1 == 1815491698) {
        return result;
      }
      int v3 = 1916022840;
    }
    else
    {
      if (v1 > 1999908960)
      {
        if (v1 > 2016567666)
        {
          if (v1 > 2016698738)
          {
            if (v1 == 2016698739) {
              return result;
            }
            int v3 = 2033463606;
          }
          else
          {
            if (v1 == 2016567667) {
              return result;
            }
            int v3 = 2016698680;
          }
        }
        else if (v1 > 2016436594)
        {
          if (v1 == 2016436595) {
            return result;
          }
          int v3 = 2016567608;
        }
        else
        {
          if (v1 == 1999908961) {
            return result;
          }
          int v3 = 2016436536;
        }
        goto LABEL_86;
      }
      if (v1 > 1982882103)
      {
        if (v1 > 1983131703)
        {
          if (v1 == 1983131704) {
            return result;
          }
          int v3 = 1983144248;
        }
        else
        {
          if (v1 == 1982882104) {
            return result;
          }
          int v3 = 1983013176;
        }
        goto LABEL_86;
      }
      if (v1 == 1949327731 || v1 == 1949458803) {
        return result;
      }
      int v3 = 1949589875;
    }
LABEL_86:
    if (v1 != v3) {
      return 0;
    }
    return result;
  }
  if (v1 <= 645410871)
  {
    if (v1 <= 645148786)
    {
      if (v1 > 643969847)
      {
        if (v1 > 645083762)
        {
          if (v1 == 645083763) {
            return result;
          }
          unsigned __int16 v4 = 13427;
        }
        else
        {
          if (v1 == 643969848) {
            return result;
          }
          unsigned __int16 v4 = 12403;
        }
        int v3 = v4 | 0x26730000;
        goto LABEL_86;
      }
      if (v1 != 32 && v1 != 641877825)
      {
        int v3 = 642934849;
        goto LABEL_86;
      }
      return result;
    }
    if (v1 > 645279799)
    {
      if (v1 > 645280823)
      {
        if (v1 == 645280824) {
          return result;
        }
        int v3 = 645346401;
      }
      else
      {
        if (v1 == 645279800) {
          return result;
        }
        int v3 = 645280312;
      }
      goto LABEL_86;
    }
    if (v1 == 645148787 || v1 == 645149299) {
      return result;
    }
    int v3 = 645149811;
    goto LABEL_86;
  }
  if (v1 > 843264309)
  {
    if (v1 > 1094862673)
    {
      if (v1 > 1279340599)
      {
        if (v1 == 1279340600) {
          return result;
        }
        int v3 = 1279342648;
      }
      else
      {
        if (v1 == 1094862674) {
          return result;
        }
        int v3 = 1111970369;
      }
    }
    else if (v1 > 892679472)
    {
      if (v1 == 892679473) {
        return result;
      }
      int v3 = 1093677112;
    }
    else
    {
      if (v1 == 843264310) {
        return result;
      }
      int v3 = 875836468;
    }
    goto LABEL_86;
  }
  if (v1 > 645411442)
  {
    if (v1 > 645411954)
    {
      if (v1 == 645411955) {
        return result;
      }
      int v3 = 843264104;
      goto LABEL_86;
    }
    if (v1 == 645411443) {
      return result;
    }
    unsigned __int16 v5 = 13368;
    goto LABEL_55;
  }
  if (v1 != 645410872 && v1 != 645410931)
  {
    unsigned __int16 v5 = 12856;
LABEL_55:
    int v3 = v5 | 0x26780000;
    goto LABEL_86;
  }
  return result;
}

uint64_t CA::Render::Surface::should_hdr_tonemap(CA::Render::Surface *this)
{
  return (*((unsigned __int16 *)this + 168) >> 10) & 1;
}

uint64_t CA::Render::fourcc_is_rgb(CA::Render *this)
{
  int v1 = (int)this;
  uint64_t result = 1;
  if (v1 > 1111970368)
  {
    if (v1 <= 1380410944)
    {
      if (v1 <= 1279340599)
      {
        if (v1 == 1111970369 || v1 == 1278226488) {
          return result;
        }
        int v3 = 1278555445;
LABEL_45:
        if (v1 != v3) {
          return 0;
        }
        return result;
      }
      if (v1 <= 1378955370)
      {
        if (v1 == 1279340600) {
          return result;
        }
        int v3 = 1279342648;
        goto LABEL_45;
      }
      if (v1 == 1378955371) {
        return result;
      }
      unsigned __int16 v4 = 16961;
    }
    else
    {
      if (v1 > 1815491697)
      {
        if (v1 > 1999908960)
        {
          if (v1 == 1999908961) {
            return result;
          }
          int v3 = 2084718401;
        }
        else
        {
          if (v1 == 1815491698) {
            return result;
          }
          int v3 = 1999843442;
        }
        goto LABEL_45;
      }
      if (v1 > 1647534391)
      {
        if (v1 == 1647534392) {
          return result;
        }
        int v3 = 1815162994;
        goto LABEL_45;
      }
      if (v1 == 1380410945) {
        return result;
      }
      unsigned __int16 v4 = 26689;
    }
    int v3 = v4 | 0x52470000;
    goto LABEL_45;
  }
  if (v1 > 645346400)
  {
    if (v1 > 843264309)
    {
      if (v1 > 1093677111)
      {
        if (v1 == 1093677112) {
          return result;
        }
        int v3 = 1094862674;
      }
      else
      {
        if (v1 == 843264310) {
          return result;
        }
        int v3 = 892679473;
      }
    }
    else if (v1 > 792872768)
    {
      if (v1 == 792872769) {
        return result;
      }
      int v3 = 843264104;
    }
    else
    {
      if (v1 == 645346401) {
        return result;
      }
      int v3 = 759318337;
    }
    goto LABEL_45;
  }
  if (v1 > 642934848)
  {
    if (v1 > 644624753)
    {
      if (v1 == 644624754) {
        return result;
      }
      int v3 = 645346162;
    }
    else
    {
      if (v1 == 642934849) {
        return result;
      }
      int v3 = 643969848;
    }
    goto LABEL_45;
  }
  if (v1 != 16 && v1 != 32)
  {
    int v3 = 641877825;
    goto LABEL_45;
  }
  return result;
}

void CA::Render::iosurface_get_edr_headroom(CA::Render *this, __IOSurface *a2)
{
  if (this)
  {
    CFTypeRef v2 = IOSurfaceCopyValue(this, (CFStringRef)*MEMORY[0x1E4F2F078]);
    if (v2)
    {
      int v3 = v2;
      CA_CFFloatValue(v2);
      CFRelease(v3);
    }
  }
}

CGColorSpaceRef CA::Render::load_colorspace_from_bulk_attachments(unsigned __int8 a1, unsigned __int8 a2)
{
  int v3 = a1 - 1;
  unsigned int v4 = 22;
  switch(v3)
  {
    case 0:
      if (a2 > 0xCu)
      {
        if (a2 == 16)
        {
          unsigned int v4 = 18;
        }
        else
        {
          if (a2 != 13) {
            return 0;
          }
          unsigned int v4 = 29;
        }
      }
      else if (a2 == 1)
      {
        unsigned int v4 = 17;
      }
      else
      {
        if (a2 != 8) {
          return 0;
        }
        unsigned int v4 = 26;
      }
      goto LABEL_22;
    case 4:
      unsigned int v4 = 23;
      goto LABEL_22;
    case 5:
      goto LABEL_22;
    case 8:
      if (a2 > 0xFu)
      {
        if (a2 == 16)
        {
          unsigned int v4 = 13;
          goto LABEL_22;
        }
        if (a2 == 18)
        {
          unsigned int v4 = 12;
          goto LABEL_22;
        }
      }
      else
      {
        if (a2 == 8)
        {
          unsigned int v4 = 10;
          goto LABEL_22;
        }
        if (a2 == 13)
        {
          unsigned int v4 = 14;
          goto LABEL_22;
        }
      }
      unsigned int v4 = 9;
LABEL_22:
      long long v7 = (CGColorSpace *)CAGetColorSpace(v4);
      return CGColorSpaceRetain(v7);
    case 10:
      if (a2 != 17) {
        return 0;
      }
      unsigned int v4 = 8;
      goto LABEL_22;
    case 11:
      if (a2 == 18) {
        int v5 = 6;
      }
      else {
        int v5 = 5;
      }
      if (a2 == 16) {
        int v6 = 7;
      }
      else {
        int v6 = v5;
      }
      if (a2 == 8) {
        unsigned int v4 = 15;
      }
      else {
        unsigned int v4 = v6;
      }
      goto LABEL_22;
    default:
      return 0;
  }
}

void CA::CAHDRProcessor::new_hdr_processor(CA::CAHDRProcessor *this)
{
}

float64_t CA::Render::Updater::TransformOp::map_transform(CA::Render::Updater::TransformOp *this, CA::Transform *a2, uint64_t a3, const double *a4)
{
  return CA::Transform::concat(a2, (float64x2_t *)((char *)this + 24), a3, a4);
}

uint64_t mark_drawable_finish(CAMetalDrawable *a1, _CAMetalLayerPrivate *a2, int a3, double a4)
{
  [(CAMetalDrawable *)a1 setDidFinish:1];
  uint64_t result = [(CAMetalDrawable *)a1 targetPresentationTimestamp];
  if (v9 != 0.0)
  {
    long long v10 = NSNumber;
    [(CAMetalDrawable *)a1 targetTimestamp];
    objc_msgSend(v10, "numberWithDouble:");
    uint64_t v11 = NSNumber;
    [(CAMetalDrawable *)a1 targetSamplingTimestamp];
    objc_msgSend(v11, "numberWithDouble:");
    [(CAMetalDrawable *)a1 minimumPresentationDuration];
    double v13 = v12;
    float v14 = NSNumber;
    [(CAMetalDrawable *)a1 targetPresentationTimestamp];
    double v16 = v15;
    if (v13 != 0.0)
    {
      double v17 = *((double *)a2 + 37);
      [(CAMetalDrawable *)a1 minimumPresentationDuration];
      if (v16 <= v18 + v17)
      {
        double v20 = *((double *)a2 + 37);
        [(CAMetalDrawable *)a1 minimumPresentationDuration];
        double v16 = v21 + v20;
      }
      else
      {
        [(CAMetalDrawable *)a1 targetPresentationTimestamp];
        double v16 = v19;
      }
    }
    uint64_t result = [v14 numberWithDouble:v16];
  }
  if (MEMORY[0x1E4F62328])
  {
    [(CAMetalDrawable *)a1 layer];
    [(CAMetalDrawable *)a1 drawableID];
    [(CAMetalDrawable *)a1 hasExplicitDeadlines];
    uint64_t result = FPDrawableLifetimeMarkFinished();
  }
  if (a3) {
    *((double *)a2 + 37) = a4;
  }
  return result;
}

void layer_private_present(_CAMetalLayerPrivate *a1, CAMetalDrawable *a2, double a3, double a4, unsigned int a5)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  double v9 = [(CAMetalDrawable *)a2 priv];
  if (!v9 || (long long v10 = v9, (*((unsigned char *)v9 + 113) & 0x20) != 0))
  {
    if (warn_multiple_present(void)::once[0] != -1)
    {
      dispatch_once(warn_multiple_present(void)::once, &__block_literal_global_495);
    }
  }
  else
  {
    if (MEMORY[0x1E4F62320])
    {
      [(CAMetalDrawable *)a2 layer];
      [(CAMetalDrawable *)a2 drawableID];
      FPDrawableLifetimeMarkClientDidPresent();
    }
    [(CAMetalDrawable *)a2 targetSamplingTimestamp];
    if (v11 == 0.0)
    {
      double v12 = a3;
    }
    else
    {
      double v12 = v11;
      a5 &= ~2u;
      uint64_t v13 = *(void *)(*((void *)a1 + 2) + 48);
      if (v13)
      {
        uint64_t v14 = *(void *)(v13 + 24);
        *(void *)(v14 + 304) = 0;
        *(double *)(v14 + 312) = v11;
        __dmb(0xBu);
      }
    }
    *((unsigned char *)v10 + 113) |= 0x20u;
    double v15 = [(CAMetalDrawable *)a2 sharedEvent];
    double v16 = v15;
    if (((*((_WORD *)a1 + 144) & 0x20) == 0 || *((void *)a1 + 4))
      && (uint64_t v17 = *(void *)(*((void *)a1 + 2) + 48)) != 0
      && (unint64_t v18 = atomic_load((unint64_t *)(*(void *)(v17 + 24) + 8)), (v18 & 0x8000000000000000) != 0)
      && v15)
    {
      unint64_t v19 = [(CAMetalDrawable *)a2 drawableID];
      int v20 = IOSurfaceSignalEvent();
      if (v20)
      {
        int v22 = v20;
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          int8x16_t v23 = x_log_category_api;
          if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 67109120;
            int v27 = v22;
            _os_log_impl(&dword_184668000, v23, OS_LOG_TYPE_ERROR, "IOSurfaceSignalEvent err=0x%x", buf, 8u);
          }
        }
        layer_private_present_impl(a1, a2, v12, a5);
      }
      else
      {
        uint64_t v21 = *((void *)a1 + 20);
        v24[0] = MEMORY[0x1E4F143A8];
        v24[1] = 3221225472;
        v24[2] = ___ZL21layer_private_presentP20_CAMetalLayerPrivateP15CAMetalDrawableddj_block_invoke;
        v24[3] = &unk_1E527C860;
        v24[4] = a2;
        v24[5] = a1;
        *(double *)&v24[6] = v12;
        unsigned int v25 = a5;
        [(IOSurfaceSharedEvent *)v16 notifyListener:v21 atValue:v19 block:v24];
      }
    }
    else
    {
      layer_private_present_impl(a1, a2, v12, a5);
    }
  }
}

void layer_private_present_impl(_CAMetalLayerPrivate *a1, CAMetalDrawable *a2, double a3, unsigned int a4)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  long long v8 = [(CAMetalDrawable *)a2 priv];
  unsigned int v87 = (os_unfair_lock_s *)((char *)a1 + 8);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 2);
  if (*((void *)a1 + 9))
  {
    if (a3 <= 0.0005)
    {
      int v12 = 1073741826;
      __int16 v11 = *((_WORD *)a1 + 144);
      double v10 = 0.0;
      if ((v11 & 0x20) != 0)
      {
        uint64_t v13 = *((void *)a1 + 4);
        BOOL v24 = v13 == 0;
        BOOL v14 = v13 != 0;
        if (v24) {
          int v12 = 1073741828;
        }
        else {
          int v12 = 1073741826;
        }
        int v9 = v14 & a4;
      }
      else
      {
        int v9 = a4 & 1;
      }
    }
    else
    {
      int v9 = 0;
      double v10 = a3 + -0.0005;
      __int16 v11 = *((_WORD *)a1 + 144);
      int v12 = 0x40000000;
    }
    int v15 = v12 | 1;
    if ((v11 & 4) != 0) {
      int v16 = v12 | 1;
    }
    else {
      int v16 = v12;
    }
    if ((v16 & 1) == 0 && !CA::Render::fourcc_has_alpha((CA::Render *)v8->var3)) {
      int v16 = v15;
    }
    int v80 = v9;
    if ((v9 & 1) != 0 || [(CAMetalDrawable *)a2 needsLowLatency]) {
      v16 |= 0x20u;
    }
    if ((*((_WORD *)a1 + 144) & 0x2000) != 0) {
      int v17 = v16 | (a4 << 19) & 0x800000;
    }
    else {
      int v17 = v16 | (a4 << 19) & 0x800000 | 0x2000000;
    }
    char v18 = *((unsigned char *)v8 + 113);
    OSType PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(v8->var10);
    int v20 = (int)PixelFormat;
    BOOL v86 = a2;
    int v21 = CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0);
    int var16 = v8->var16;
    switch(var16)
    {
      case 3:
        uint64_t v23 = 7u;
        break;
      case 2:
        if (CADeviceSupportsUniversalCompression::once != -1) {
          dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
        }
        if (CADeviceSupportsUniversalCompression::universal) {
          BOOL v24 = v21 == v20;
        }
        else {
          BOOL v24 = 1;
        }
        uint64_t v23 = 3;
        if (!v24) {
          uint64_t v23 = 0;
        }
        break;
      case 1:
        uint64_t v23 = 4u;
        break;
      default:
        uint64_t v23 = 0;
        break;
    }
    char v25 = image_queue_rotation_from_logical_rotation(CAMetalLayerRotation,BOOL)::invert_table[v23];
    if (CADeviceSupportsUniversalCompression::once != -1) {
      dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
    }
    if (CADeviceSupportsUniversalCompression::universal) {
      BOOL v26 = (var16 & 0xFFFFFFFD) == 1;
    }
    else {
      BOOL v26 = 0;
    }
    if (!v26 || v21 == v20) {
      char v28 = v25;
    }
    else {
      char v28 = v25 | 8;
    }
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 46);
    int8x16_t v29 = v86;
    if (([*((id *)a1 + 24) containsObject:v86] & 1) == 0) {
      [*((id *)a1 + 24) addObject:v86];
    }
    int v30 = a4 & 2;
    unsigned int v31 = (v30 << 30) | (((a4 >> 3) & 1) << 26) | v17 | ((v18 & 0x10) << 24);
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 46);
    if (!*((void *)a1 + 4))
    {
      int v32 = objc_msgSend(+[CADisplay mainDisplay](CADisplay, "mainDisplay"), "hasNativeFrameRateRequest");
      BOOL v33 = v10 <= 0.00933333333 || v30 == 0;
      int v34 = v33 ? v32 : 0;
      if (v34 == 1 && (*((_WORD *)a1 + 144) & 0x100) == 0) {
        v31 |= 0x8000000u;
      }
    }
    [(CAMetalDrawable *)v86 dirtyRect];
    uint64_t v83 = v35;
    locint k = v36;
    float64x2_t v81 = v38;
    double v82 = v37;
    if (CGRectEqualToRect(*(CGRect *)(&v35 - 1), *MEMORY[0x1E4F1DB10]))
    {
      int32x4_t v40 = (int32x4_t)xmmword_184998040;
    }
    else
    {
      *(double *)v41.i64 = v82;
      v41.i64[1] = v83;
      v39.f64[0] = 0.0;
      v42.i64[0] = *(void *)&v81.f64[0];
      v42.i64[1] = lock;
      int8x16_t v43 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(v39, v81).i64[0], 0);
      v44.i64[1] = lock;
      *(double *)v44.i64 = -v81.f64[0];
      float64x2_t v45 = (float64x2_t)vbslq_s8(v43, v44, v42);
      v44.i64[1] = v83;
      *(double *)v44.i64 = v81.f64[0] + v82;
      float64x2_t v46 = (float64x2_t)vbslq_s8(v43, v44, v41);
      if (*(double *)&lock < 0.0)
      {
        v46.f64[1] = *(double *)&lock + *(double *)&v83;
        v45.f64[1] = -*(double *)&lock;
      }
      int64x2_t v47 = vceqzq_f64(v45);
      int32x4_t v40 = 0uLL;
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v47, 1), (int8x16_t)v47).u64[0] & 0x8000000000000000) == 0)
      {
        int8x16_t v48 = vorrq_s8((int8x16_t)vcltzq_f64(v45), (int8x16_t)vcgezq_f64(v45));
        if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v48), 1), v48).u64[0] & 0x8000000000000000) == 0)
        {
          float64x2_t v49 = vminnmq_f64(vaddq_f64(v46, v45), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
          int32x4_t v50 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v46, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
          int32x4_t v40 = vuzp1q_s32(v50, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v49), (int64x2_t)v50));
        }
      }
    }
    *(int32x4_t *)locka = v40;
    uint64_t v51 = *((void *)a1 + 2);
    uint64_t var5 = v8->var5;
    double v53 = *((double *)a1 + 5);
    double var8 = v8->var8;
    [(CAMetalDrawable *)v86 preferredLatency];
    long long v88 = *(_OWORD *)locka;
    if (!CAImageQueueInsertImage_(v51, 3, var5, v31, v28, &v88, (uint64_t)release_sample, (uint64_t)v8, v10, v53, var8, v55, v56))
    {
      *((unsigned char *)v8 + 113) &= ~8u;
      os_unfair_lock_lock((os_unfair_lock_t)a1 + 46);
      [(CAMetalDrawable *)v86 didScheduledPresent];
      [(CAMetalDrawable *)v86 setPresentScheduledInsertSeedValid:1];
      os_unfair_lock_unlock((os_unfair_lock_t)a1 + 46);
      uint64_t v68 = pthread_setspecific(collect_slot, a1);
      release_sample(v68, v69, (uint64_t)v8);
      pthread_setspecific(collect_slot, 0);
      os_unfair_lock_unlock(v87);
      goto LABEL_111;
    }
    uint64_t v57 = *(unsigned int *)(*(void *)(*(void *)(*((void *)a1 + 2) + 48) + 24) + 36);
    [(CAMetalDrawable *)v86 setInsertSeed:v57];
    [(CAMetalDrawable *)v86 setStatus:1];
    uint64_t v58 = mach_absolute_time();
    uint64_t v59 = *((void *)a1 + 28);
    if (v58 <= CAHostTimeWithTime(1.0) + v59)
    {
      os_unfair_lock_lock((os_unfair_lock_t)a1 + 52);
      [*((id *)a1 + 27) addObject:v86];
      os_unfair_lock_unlock((os_unfair_lock_t)a1 + 52);
    }
    else
    {
      uint64_t v60 = mach_absolute_time();
      double v61 = CATimeWithHostTime(v60);
      os_unfair_lock_lock((os_unfair_lock_t)a1 + 52);
      long long v92 = 0u;
      long long v93 = 0u;
      long long v90 = 0u;
      long long v91 = 0u;
      __int16 v62 = (void *)*((void *)a1 + 27);
      uint64_t v63 = [v62 countByEnumeratingWithState:&v90 objects:v89 count:16];
      if (v63)
      {
        uint64_t v64 = *(void *)v91;
        do
        {
          for (uint64_t i = 0; i != v63; ++i)
          {
            if (*(void *)v91 != v64) {
              objc_enumerationMutation(v62);
            }
            uint64_t v66 = *(CAMetalDrawable **)(*((void *)&v90 + 1) + 8 * i);
            [(CAMetalDrawable *)v66 setStatus:3];
            [(CAMetalDrawable *)v66 didPresentAtTime:0.0];
            mark_drawable_finish(v66, a1, 0, v61);
          }
          uint64_t v63 = [v62 countByEnumeratingWithState:&v90 objects:v89 count:16];
        }
        while (v63);
      }
      uint64_t v67 = (void *)[*((id *)a1 + 27) copy];
      [*((id *)a1 + 27) removeAllObjects];
      os_unfair_lock_unlock((os_unfair_lock_t)a1 + 52);
      int8x16_t v29 = v86;
      mark_drawable_finish(v86, a1, 0, v61);
    }
    if ((*((_WORD *)a1 + 144) & 8) != 0 && (uint64_t v70 = *(void *)(*((void *)a1 + 2) + 48)) != 0)
    {
      int v71 = *(_DWORD *)(*(void *)(v70 + 24) + 32);
      char v72 = *((unsigned char *)v8 + 113);
      if (v71) {
        BOOL v73 = v57 >= 3;
      }
      else {
        BOOL v73 = 0;
      }
      if (v73 && (*((unsigned char *)v8 + 113) & 8) == 0 && v8->var12 == (id)*((void *)a1 + 9))
      {
        os_unfair_lock_lock((os_unfair_lock_t)a1 + 46);
        [(CAMetalDrawable *)v29 setPresentScheduledInsertSeed:v57];
        [(CAMetalDrawable *)v29 setPresentScheduledInsertSeedValid:1];
LABEL_93:
        os_unfair_lock_unlock((os_unfair_lock_t)a1 + 46);
        if ((v31 & 2) != 0)
        {
          int v75 = 0;
          atomic_fetch_and((atomic_uint *volatile)a1 + 1, 0xFFFFFFFD);
          int v74 = v80;
        }
        else
        {
          int v74 = v80;
          if ((v31 & 4) != 0)
          {
            atomic_fetch_or((atomic_uint *volatile)a1 + 1, 2u);
            int v75 = 1;
          }
          else
          {
            int v75 = 0;
          }
        }
        __int16 v76 = *((_WORD *)a1 + 144);
        os_unfair_lock_unlock(v87);
        if ((v76 & 0x10) == 0)
        {
          if (!v75) {
            goto LABEL_111;
          }
LABEL_102:
          uint64_t v77 = (CA::Transaction *)+[CATransaction lock];
          if (v74) {
            uint64_t v77 = (CA::Transaction *)+[CATransaction setLowLatency:1];
          }
          if (*((double *)a1 + 5) != 0.0) {
            uint64_t v77 = (CA::Transaction *)+[CATransaction setInputTime:](CATransaction, "setInputTime:");
          }
          uint64_t v78 = *((void *)a1 + 3);
          if (v78)
          {
            unsigned int v79 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
            if (!v79) {
              unsigned int v79 = (CA::Transaction *)CA::Transaction::create(v77);
            }
            CA::Layer::set_commit_needed(*(CA::Layer **)(v78 + 16), v79, 0);
          }
          +[CATransaction unlock];
          goto LABEL_111;
        }
        layer_collectable_signal(*((void *)a1 + 2), a1);
        if (v75) {
          goto LABEL_102;
        }
LABEL_111:
        *((void *)a1 + 5) = 0;
        [(CAMetalDrawable *)v29 releasePrivateReferences:a1];
        return;
      }
    }
    else
    {
      char v72 = *((unsigned char *)v8 + 113);
    }
    *((unsigned char *)v8 + 113) = v72 & 0xF7;
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 46);
    [(CAMetalDrawable *)v29 didScheduledPresent];
    [(CAMetalDrawable *)v29 setPresentScheduledInsertSeedValid:1];
    goto LABEL_93;
  }
  NSLog(&cfstr_CannotPresentC.isa);

  os_unfair_lock_unlock(v87);
}

void sub_18477AD0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, os_unfair_lock_t lock)
{
  os_unfair_lock_unlock(v20);
  os_unfair_lock_unlock(lock);
  _Unwind_Resume(a1);
}

void ___Z23CABackdropDidChangeLumayf_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  float v2 = *(float *)(a1 + 40);
  if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
    dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
  }
  if (v1) {
    int v3 = (void *)(v1 - CA::Render::_render_id_slide);
  }
  else {
    int v3 = 0;
  }
  id v11 = v3;
  os_unfair_lock_lock(&_all_backdrops_lock);
  unsigned int v4 = *(void **)(_all_backdrops + 8);
  if (!v4) {
    goto LABEL_17;
  }
  uint64_t v5 = _all_backdrops + 8;
  do
  {
    unint64_t v6 = v4[4];
    BOOL v7 = v6 >= (unint64_t)v11;
    if (v6 >= (unint64_t)v11) {
      long long v8 = v4;
    }
    else {
      long long v8 = v4 + 1;
    }
    if (v7) {
      uint64_t v5 = (uint64_t)v4;
    }
    unsigned int v4 = (void *)*v8;
  }
  while (*v8);
  if (v5 != _all_backdrops + 8 && *(void *)(v5 + 32) <= (unint64_t)v11)
  {
    id v9 = v11;
    os_unfair_lock_unlock(&_all_backdrops_lock);
    +[CATransaction lock];
    id v10 = (id)[v11 delegate];
    +[CATransaction unlock];
    if (objc_opt_respondsToSelector()) {
      [v10 backdropLayer:v11 didChangeLuma:v2];
    }
  }
  else
  {
LABEL_17:
    os_unfair_lock_unlock(&_all_backdrops_lock);
  }
}

void sub_18477AEE0(_Unwind_Exception *a1)
{
}

void run_animation_callbacks(void *a1)
{
  while (1)
  {
    float v2 = (void *)a1[2];
    if (!v2) {
      break;
    }
    a1[2] = *v2;
    free_non_deferred_animation(v2, 1);
  }
  for (uint64_t i = (void *)a1[1]; i; uint64_t i = (void *)i[1])
  {
    id v4 = (id)*i;
    objc_msgSend((id)objc_msgSend((id)*i, "delegate"), "animationDidStart:", *i);
    CFRelease(v4);
  }
  uint64_t v5 = (void *)*a1;
  if (*a1)
  {
    do
    {
      id v6 = (id)*v5;
      objc_msgSend((id)objc_msgSend((id)*v5, "delegate"), "animationDidStop:finished:", *v5, (*(_DWORD *)(*v5 + 16) >> 1) & 1);
      CFRelease(v6);
      uint64_t v5 = (void *)v5[1];
    }
    while (v5);
  }
  BOOL v7 = (void *)a1[1];
  if (v7)
  {
    do
    {
      long long v8 = (void *)v7[1];
      free(v7);
      BOOL v7 = v8;
    }
    while (v8);
  }
  id v9 = (void *)*a1;
  if (*a1)
  {
    do
    {
      id v10 = (void *)v9[1];
      free(v9);
      id v9 = v10;
    }
    while (v10);
  }

  JUMPOUT(0x185323DC0);
}

void sub_18477B07C(_Unwind_Exception *a1)
{
  MEMORY[0x185323DC0](v1, 0x20C40960023A9);
  _Unwind_Resume(a1);
}

void free_non_deferred_animation(void *a1, int a2)
{
  __int16 v4 = *((_WORD *)a1 + 28);
  if ((v4 & 8) != 0)
  {
    __int16 v11 = *((_WORD *)a1 + 28) & 0x10;
    if (a2) {
      __int16 v11 = 16;
    }
    *((_WORD *)a1 + 28) = v11 | v4 & 0xFFEF;
  }
  else
  {
    if (*((_DWORD *)a1 + 15) != -892679478) {
      __assert_rtn("free_non_deferred_animation", "CALayer.mm", 7170, "la->canary == LayerAnimation::CANARY_VALUE");
    }
    uint64_t v5 = (const void *)*((void *)a1 + 1);
    if (v5)
    {
      id v6 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
      if (!v6)
      {
        id v6 = (CA::Transaction *)CA::Transaction::create(0);
        uint64_t v5 = (const void *)*((void *)a1 + 1);
      }
      CA::Transaction::release_object(v6, v5);
    }
    BOOL v7 = (atomic_uint *)*((void *)a1 + 4);
    if (v7 && atomic_fetch_add(v7 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v7 + 16))(v7);
    }
    long long v8 = (const void *)*((void *)a1 + 2);
    if (v8) {
      CFRelease(v8);
    }
    if (a2)
    {
      *(void *)&long long v9 = 0x3333333333333333;
      *((void *)&v9 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0x3333333333333333;
      *((_OWORD *)a1 + 2) = v9;
      *((_OWORD *)a1 + 3) = v9;
      *(_OWORD *)a1 = v9;
      *((_OWORD *)a1 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v9;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, a1);
    }
  }
}

BOOL CAImageQueueInsertImage_(uint64_t a1, int a2, uint64_t a3, unsigned int a4, char a5, _OWORD *a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 48)) {
    return 0;
  }
  char v25 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  uint64_t v26 = *(void *)(*(void *)(a1 + 48) + 24);
  unint64_t v27 = *(unsigned int *)(a1 + 40);
  if ((a4 & 0x84000000) == 0x80000000)
  {
    uint64_t v28 = 0;
    if (v27)
    {
      int8x16_t v29 = (int *)(v26 + 532);
      uint64_t v30 = *(unsigned int *)(a1 + 40);
      do
      {
        int v31 = *v29;
        v29 += 40;
        if (!v31) {
          ++v28;
        }
        --v30;
      }
      while (v30);
    }
    if (v28 == v27)
    {
      a4 &= ~0x80000000;
      a9 = 0.0;
    }
  }
  if (!v27)
  {
LABEL_16:
    BOOL v35 = 0;
    LODWORD(v36) = 0;
    goto LABEL_17;
  }
  char v60 = a5;
  uint64_t v59 = a6;
  unsigned int v32 = 0;
  uint64_t v33 = 0;
  int v34 = (_DWORD *)(v26 + 532);
  BOOL v35 = 1;
  while (*v34)
  {
LABEL_15:
    BOOL v35 = ++v33 < v27;
    v34 += 40;
    if (v27 == v33) {
      goto LABEL_16;
    }
  }
  if (v32 < *(unsigned __int8 *)(v26 + 95))
  {
    ++v32;
    goto LABEL_15;
  }
  *(void *)(*(void *)(a1 + 184) + 8 * v33) = a7;
  *(void *)(*(void *)(a1 + 192) + 8 * v33) = a8;
  do
  {
    int v49 = *(_DWORD *)(v26 + 36);
    int v50 = v49;
    atomic_compare_exchange_strong((atomic_uint *volatile)(v26 + 36), (unsigned int *)&v50, v49 + 1);
  }
  while (v50 != v49);
  uint64_t v51 = v26 + 160 * v33;
  *(_DWORD *)(v51 + 564) = v49 + 1;
  *(_DWORD *)(v51 + 52CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0;
  *(_DWORD *)(v51 + 524) = 0;
  *(_DWORD *)(v51 + 528) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(v51 + 536) = a4;
  *(unsigned char *)(v51 + 584) = v60;
  *(void *)(v51 + 472) = a3;
  *(double *)(v51 + 464) = a9;
  *(_DWORD *)(v51 + 548) = 0;
  *(_WORD *)(v51 + 585) = 0;
  *(void *)(v51 + 512) = 0;
  *(_OWORD *)(v51 + 48CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = 0u;
  *(_OWORD *)(v51 + 496) = 0u;
  *(unsigned char *)(v51 + 587) = (a4 & 0x10000000) != 0;
  *(double *)(v51 + 592) = a11;
  *(double *)(v51 + 60CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = a12;
  *(double *)(v51 + 608) = a13;
  *(_DWORD *)(v51 + 556) = 0;
  *(_DWORD *)(v51 + 616) = 0;
  if (a2 == 2 || a2 == 4)
  {
    uint64_t v36 = IOSurfaceLookup(a3);
    if (v36)
    {
LABEL_50:
      unint64_t v54 = atomic_load((unint64_t *)(v26 + 8));
      if ((v54 & 0x400000000000000) == 0) {
        IOSurfaceIncrementUseCount(v36);
      }
      *(void *)(*(void *)(a1 + 64) + 8 * v33) = v36;
      LODWORD(v36) = IOSurfaceGetID(v36);
      *(_DWORD *)(v51 + 52CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v36;
    }
  }
  else
  {
    LODWORD(v36) = 0;
    if (a2 == 3)
    {
      uint64_t v52 = x_hash_table_lookup(*(void *)(a1 + 200), a3, 0);
      if (v52 && (uint64_t v53 = *(void *)(v52 + 24), *(unsigned char *)(v53 + 12) == 51))
      {
        uint64_t v36 = *(__IOSurface **)(v53 + 112);
        if (v36)
        {
          CFRetain(*(CFTypeRef *)(v53 + 112));
          goto LABEL_50;
        }
      }
      else
      {
        LODWORD(v36) = 0;
      }
    }
  }
  if ((a4 & 6) != 0) {
    ++*(_DWORD *)(v51 + 528);
  }
  int v55 = *(_DWORD *)(a1 + 32);
  uint64_t v56 = v26 + 160 * v33;
  *(_DWORD *)(v56 + 54CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v55;
  int v57 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v56 + 544) = v57;
  if ((v60 & 4) != 0)
  {
    *(_DWORD *)(v56 + 54CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0) = v57;
    *(_DWORD *)(v56 + 544) = v55;
  }
  __dmb(0xBu);
  *int v34 = a2;
  *(_OWORD *)(v26 + 160 * v33 + 568) = *v59;
  if ((a4 & 0x80000000) != 0) {
    CAImageQueueSetFlagsInternal((int *)a1, 0x1000000000000000, 0x1000000000000000);
  }
  if ((a4 & 2) != 0)
  {
    int v58 = *(_DWORD *)(a1 + 24) + 1;
    *(_DWORD *)(a1 + 24) = v58;
    *(_DWORD *)(v26 + 16) = v58;
  }
LABEL_17:
  os_unfair_lock_unlock(v25);
  uint64_t v37 = mach_absolute_time();
  double v38 = CATimeWithHostTime(v37);
  BOOL v39 = (*(_DWORD *)(a1 + 20) | a4 & 0x80) != 0;
  if ((a4 & 0x20) != 0)
  {
    unint64_t v40 = atomic_load((unint64_t *)(v26 + 8));
    if ((v40 & 0x20000) != 0 && v38 <= *(double *)(v26 + 320)) {
      BOOL v39 = 1;
    }
  }
  if (BYTE9(xmmword_1EB2ACC10)) {
    kdebug_trace();
  }
  if (!(!v35 | ((a4 & 4) >> 2) & 1))
  {
    unint64_t v41 = atomic_load((unint64_t *)(v26 + 8));
    char v42 = (v41 & 0x200000000000001) == 1 || v39;
    if ((v42 & 1) == 0)
    {
      unint64_t v43 = atomic_load((unint64_t *)(v26 + 8));
      double v44 = 0.0;
      if ((v43 & 0x20000000000000) != 0) {
        double v44 = a9;
      }
      CAImageQueuePing_(a1, (a4 >> 5) & 1, (a4 >> 23) & 1, v44, a10);
    }
  }
  if (BYTE9(xmmword_1EB2ACC10)) {
    kdebug_trace();
  }
  if (CAImageQueueLog(void)::onceToken != -1) {
    dispatch_once(&CAImageQueueLog(void)::onceToken, &__block_literal_global_89);
  }
  os_signpost_id_t v45 = *(unsigned int *)(v26 + 88);
  if (v45)
  {
    float64x2_t v46 = CAImageQueueLog(void)::log;
    if (os_signpost_enabled((os_log_t)CAImageQueueLog(void)::log))
    {
      int v47 = *(_DWORD *)(v26 + 16);
      *(_DWORD *)long long buf = 67240960;
      int v63 = (int)v36;
      __int16 v64 = 2050;
      double v65 = a9;
      __int16 v66 = 1026;
      int v67 = v47;
      __int16 v68 = 1026;
      unsigned int v69 = a4;
      _os_signpost_emit_with_name_impl(&dword_184668000, v46, OS_SIGNPOST_EVENT, v45, "ImageQueueInsert", "ID is queue ID. surfaceID=%{public, name=surfaceID}#x time=%{public, name=time}f sampleGeneration=%{public, name=sampleGeneration}u flags=%{public, name=flags}#x", buf, 0x1Eu);
    }
  }
  return v35;
}

void CA::Context::Generic::release(CA::Context **this)
{
}

void sub_18477B808(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18477B8CC(_Unwind_Exception *a1)
{
}

void CAML::anonymous namespace'::sax_start_element(CAML::_anonymous_namespace_ *this, char *__s1, const unsigned __int8 *a3, char *a4, const unsigned __int8 *a5, int a6, const unsigned __int8 **a7, int a8, uint64_t a9, const unsigned __int8 **a10)
{
  LODWORD(v1CA::Context::unref(this[1], 0) = a7;
  int v12 = this;
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = *((void *)this + 6);
  if (a4)
  {
    this = (CAML::_anonymous_namespace_ *)strcmp(a4, "http://www.apple.com/CoreAnimation/1.0");
    if (this)
    {
      CAML::Context::error(v12, "Unknown namespace URI: %s", __s1);
      return;
    }
  }
  uint64_t v69 = a9;
  if (v10)
  {
    int v14 = (2 * v10) | 1;
    unint64_t v70 = 8 * v14;
    uint64_t v67 = v13;
    if (v70 > 0x1000)
    {
      int v16 = (char *)malloc_type_malloc(8 * v14, 0x118D7746uLL);
      __int16 v68 = (char **)v16;
    }
    else
    {
      MEMORY[0x1F4188790](this);
      __int16 v68 = (char **)&v65[-((v15 + 15) & 0xFFFFFFFFFFFFFFF0)];
      bzero(v68, v15);
    }
    int v66 = 2 * v10;
    int v19 = v10;
    if ((int)v10 >= 1)
    {
      uint64_t v20 = v10;
      int v21 = v68 + 1;
      uint64_t v22 = v69 + 24;
      do
      {
        uint64_t v23 = *(const void **)v22;
        size_t v24 = *(void *)(v22 + 8) - *(void *)v22;
        if (v24 + 1 > 0x1000)
        {
          int v16 = (char *)malloc_type_malloc(v24 + 1, 0x9A19A767uLL);
          uint64_t v26 = v16;
          if (!v16)
          {
            unint64_t v27 = "";
            goto LABEL_17;
          }
          uint64_t v23 = *(const void **)v22;
        }
        else
        {
          MEMORY[0x1F4188790](v16);
          uint64_t v26 = &v65[-((v25 + 15) & 0xFFFFFFFFFFFFFFF0)];
          bzero(v26, v25);
        }
        int v16 = (char *)memcpy(v26, v23, v24);
        v26[v24] = 0;
        unint64_t v27 = *(const char **)(v22 - 24);
LABEL_17:
        *(v21 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = (char *)v27;
        CA::Render::Texture *v21 = v26;
        v21 += 2;
        v22 += 40;
        --v20;
      }
      while (v20);
    }
    int v17 = (char *)v68;
    v68[v66] = 0;
    unint64_t v18 = v70;
    LODWORD(v1CA::Context::unref(this[1], 0) = v19;
    uint64_t v13 = v67;
    if (!__s1)
    {
LABEL_23:
      switch(*(_DWORD *)(v13 + 16))
      {
        case 0:
        case 7:
          goto LABEL_29;
        case 1:
          if (!strcmp(__s1, "caml"))
          {
            uint64_t v29 = (uint64_t)v12;
            int v30 = 5;
            int v31 = 0;
            goto LABEL_30;
          }
          CAML::Context::push_state((uint64_t)v12, 0, 0, 0, 0);
          if (v17) {
            goto LABEL_68;
          }
          return;
        case 2:
          if (*__s1 != 112 || __s1[1]) {
            goto LABEL_39;
          }
          uint64_t v33 = (char *)CAML::memq_(v17, (const char **)"key", (const char *)1);
          if (!v33)
          {
LABEL_39:
            uint64_t v33 = __s1;
          }
          int v34 = (const char *)CAInternAtomWithCString(v33);
          if (*(void *)(v13 + 64) && (uint64_t v35 = *(void *)(v13 + 48)) != 0) {
            uint64_t v36 = (*(uint64_t (**)(uint64_t, void))(*(void *)v35 + 40))(v35, *(void *)(v13 + 8));
          }
          else {
            uint64_t v36 = 0;
          }
          uint64_t v37 = CAML::memq_(v17, (const char **)"type", (const char *)1);
          if (!v37) {
            goto LABEL_53;
          }
          uint64_t v38 = (*(uint64_t (**)(CAML::_anonymous_namespace_ *, const char *))(*(void *)v12 + 32))(v12, v37);
          if (!v38)
          {
            goto LABEL_53;
          }
          BOOL v39 = (CAML::Context *)v38;
          if (v36
            && ((*(uint64_t (**)(CAML::_anonymous_namespace_ *, uint64_t, uint64_t))(*(void *)v12 + 40))(v12, v36, v38) & 1) == 0)
          {
LABEL_53:
            BOOL v39 = (CAML::Context *)v36;
          }
          unint64_t v41 = CAML::memq_(v17, (const char **)"object", (const char *)1);
          if (v41)
          {
            if (v17) {
              goto LABEL_68;
            }
          }
          else if (v39)
          {
            uint64_t v44 = (uint64_t)v12;
            int v45 = (int)v34;
            uint64_t v46 = (uint64_t)v39;
LABEL_91:
            __int16 v64 = (CAML::State *)CAML::Context::push_state(v44, 6, v45, v46, (uint64_t)v43);
            CAML::State::start(v64, (const char **)v17);
            if (v17) {
              goto LABEL_68;
            }
          }
          else
          {
            uint64_t v29 = (uint64_t)v12;
            int v30 = 5;
            int v31 = (int)v34;
LABEL_30:
            CAML::Context::push_state(v29, v30, v31, 0, (uint64_t)v32);
            if (v17) {
              goto LABEL_68;
            }
          }
          break;
        case 3:
        case 4:
        case 5:
          if (*__s1 == 111 && !__s1[1])
          {
            unint64_t v40 = CAML::memq_(v17, (const char **)"type", (const char *)1);
            if (v40) {
              uint64_t v28 = (CAML::Context *)(*(uint64_t (**)(CAML::_anonymous_namespace_ *, const char *))(*(void *)v12 + 32))(v12, v40);
            }
            else {
              uint64_t v28 = 0;
            }
          }
          else
          {
            uint64_t v28 = (CAML::Context *)(*(uint64_t (**)(CAML::_anonymous_namespace_ *, char *, const unsigned __int8 *))(*(void *)v12 + 32))(v12, __s1, a3);
            if (!v28) {
          }
            }
          int v47 = *(_DWORD *)(v13 + 16);
          if (v47 == 4) {
          if (v47 == 3)
          }
          else {
            int v49 = v48;
          }
          int v50 = CAML::memq_(v17, (const char **)"object", (const char *)1);
          if (!v50)
          {
            if (v28)
            {
              uint64_t v44 = (uint64_t)v12;
              int v45 = 0;
              uint64_t v46 = (uint64_t)v28;
              unint64_t v43 = (uint64_t (*)(CAML::_anonymous_namespace_ *, CAML::Context *, CAML::State *))v49;
              goto LABEL_91;
            }
LABEL_29:
            uint64_t v29 = (uint64_t)v12;
            int v30 = 0;
            int v31 = 0;
            unsigned int v32 = 0;
            goto LABEL_30;
          }
LABEL_67:
          if (!v17) {
            return;
          }
          goto LABEL_68;
        case 6:
          goto LABEL_29;
        default:
          goto LABEL_67;
      }
      return;
    }
  }
  else
  {
    int v17 = 0;
    unint64_t v18 = 0;
    if (!__s1) {
      goto LABEL_23;
    }
  }
  if (*__s1 != 115 || strcmp(__s1, "script")) {
    goto LABEL_23;
  }
  (*(void (**)(CAML::_anonymous_namespace_ *, char *))(*(void *)v12 + 48))(v12, v17);
  if (v17)
  {
LABEL_68:
    if (*(_DWORD *)(*((void *)v12 + 6) + 16) == 2)
    {
      unint64_t v70 = v18;
      int v71 = 0;
      uint64_t v72 = 0;
      uint64_t v73 = 0;
      uint64_t v52 = v17;
      uint64_t v53 = *(const char **)v17;
      if (*(void *)v17)
      {
        unint64_t v54 = (const char **)(v17 + 16);
        do
        {
          if (*v53)
          {
            int v55 = CAInternAtomWithCString(v53);
            uint64_t v56 = (void *)*((void *)v12 + 6);
            if (v56[8]
              && (int v57 = v55, (v58 = v56[6]) != 0)
              && (uint64_t v59 = (*(uint64_t (**)(uint64_t, void))(*(void *)v58 + 40))(v58, v56[1])) != 0)
            {
              int v71 = "value";
              uint64_t v72 = (uint64_t)*(v54 - 1);
              uint64_t v73 = 0;
              CAML::State::start(v60, (const char **)&v71);
              CAML::Context::pop_state(v12);
              *(v54 - 2) = "";
            }
            else if (strcmp(v53, "final") && strcmp(v53, "mica_expanded"))
            {
            }
          }
          double v61 = *v54;
          v54 += 2;
          uint64_t v53 = v61;
        }
        while (v61);
      }
      unint64_t v18 = v70;
      int v17 = v52;
    }
    if ((int)v10 >= 1)
    {
      __int16 v62 = (void **)(v17 + 8);
      int v63 = (void *)(v69 + 32);
      uint64_t v10 = v10;
      do
      {
        if ((unint64_t)(*v63 - *(v63 - 1) - 4096) <= 0xFFFFFFFFFFFFEFFELL) {
          free(*v62);
        }
        v62 += 2;
        v63 += 5;
        --v10;
      }
      while (v10);
    }
    if (v18 > 0x1000) {
      free(v17);
    }
  }
}

uint64_t CAML::ObjCContext::lookup_type(CAML::ObjCContext *this, const char *a2)
{
  uint64_t v4 = x_hash_table_lookup(*((void *)this + 13), (uint64_t)a2, 0);
  if (v4) {
    return v4;
  }
  uint64_t v5 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF98], a2, 0x8000100u);
  Class v6 = NSClassFromString(&v5->isa);
  if (!v6)
  {
    if ((*((unsigned char *)this + 112) & 8) != 0)
    {
      int v17 = (void *)MEMORY[0x185324A30]();
      Class v7 = (Class)[*((id *)this + 12) CAMLParser:*((void *)this + 10) didFailToFindClassWithName:v5];
      CFRelease(v5);
      if (v7) {
        goto LABEL_4;
      }
    }
    else
    {
      CFRelease(v5);
    }
    return 0;
  }
  Class v7 = v6;
  CFRelease(v5);
LABEL_4:
  long long v8 = strdup(a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v10 = malloc_type_zone_malloc(malloc_zone, 0x28uLL, 0x8BB15036uLL);
  uint64_t v4 = (uint64_t)v10;
  if (v10)
  {
    v10[1] = v8;
    v10[2] = 0;
    v10[3] = v7;
    void *v10 = &unk_1ED030848;
    *((unsigned char *)v10 + 32) = v10[4] & 0xFE | objc_opt_respondsToSelector() & 1;
    if (objc_opt_respondsToSelector()) {
      char v11 = 2;
    }
    else {
      char v11 = 0;
    }
    *(unsigned char *)(v4 + 32) = *(unsigned char *)(v4 + 32) & 0xFD | v11;
    if (objc_opt_respondsToSelector()) {
      char v12 = 4;
    }
    else {
      char v12 = 0;
    }
    *(unsigned char *)(v4 + 32) = *(unsigned char *)(v4 + 32) & 0xFB | v12;
    if ([(objc_class *)v7 instancesRespondToSelector:sel_CAMLParser_setValue_forKey_])char v13 = 8; {
    else
    }
      char v13 = 0;
    *(unsigned char *)(v4 + 32) = *(unsigned char *)(v4 + 32) & 0xF7 | v13;
    int v14 = (int *)*((void *)this + 13);
    uint64_t v15 = (uint64_t)v8;
    uint64_t v16 = v4;
  }
  else
  {
    int v14 = (int *)*((void *)this + 13);
    uint64_t v15 = (uint64_t)v8;
    uint64_t v16 = 0;
  }
  hash_table_modify(v14, v15, v16, 0);
  return v4;
}

void sub_18477C300(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *CAML::Context::push_state(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t result = malloc_type_zone_malloc(malloc_zone, 0xE8uLL, 0x8BB15036uLL);
  if (result)
  {
    result[1] = a1;
    *((_DWORD *)result + 4) = a2;
    result[4] = 0;
    *((_DWORD *)result + 1CA::Context::unref(this[1], 0) = a3;
    result[6] = a4;
    result[7] = a5;
    result[8] = 0;
    result[26] = 0;
    result[27] = 0;
    result[25] = 0;
    *((unsigned char *)result + 224) &= ~1u;
  }
  result[3] = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = result;
  return result;
}

void CAML::Context::pop_state(CAML::Context *this)
{
  uint64_t v1 = (CAML::State *)*((void *)this + 6);
  *((void *)this + 6) = *((void *)v1 + 3);
  CAML::State::finish(v1);
  float v2 = (void *)*((void *)v1 + 26);
  if (v2)
  {
    do
    {
      int v3 = (void *)*v2;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v2);
      float v2 = v3;
    }
    while (v3);
  }
  uint64_t v5 = (const void *)*((void *)v1 + 4);
  if (v5) {
    CFRelease(v5);
  }
  Class v6 = (const void *)*((void *)v1 + 8);
  if (v6) {
    CFRelease(v6);
  }
  Class v7 = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(v7, v1);
}

void CAML::State::finish(CAML::State *this)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  float v2 = (void *)*((void *)this + 26);
  if (!v2)
  {
    long long v9 = (char *)this + 72;
    *((unsigned char *)this + *((void *)this + 25) + 72) = 0;
    size_t v5 = *((void *)this + 25);
    goto LABEL_16;
  }
  int v3 = 0;
  size_t v4 = *((void *)this + 25);
  size_t v5 = v4;
  do
  {
    Class v6 = v3;
    int v3 = v2;
    float v2 = (void *)*v2;
    uint64_t v7 = v3[1];
    *int v3 = v6;
    v5 += v7;
  }
  while (v2);
  *((void *)this + 26) = v3;
  if (v5)
  {
    if (v5 + 1 <= 0x1000)
    {
      MEMORY[0x1F4188790](this);
      long long v9 = (char *)v20 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v9, v8);
LABEL_10:
      memcpy(v9, (char *)this + 72, v4);
      char v11 = (void *)*((void *)this + 26);
      char v12 = &v9[*((void *)this + 25)];
      if (v11)
      {
        do
        {
          char v13 = (void *)*v11;
          memcpy(v12, v11 + 2, v11[1]);
          v12 += v11[1];
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(malloc_zone, v11);
          char v11 = v13;
        }
        while (v13);
      }
      *char v12 = 0;
      goto LABEL_15;
    }
    uint64_t v10 = (char *)malloc_type_malloc(v5 + 1, 0x5A1C9370uLL);
    if (v10)
    {
      long long v9 = v10;
      size_t v4 = *((void *)this + 25);
      goto LABEL_10;
    }
    size_t v5 = 0;
  }
  long long v9 = "";
LABEL_15:
  *((void *)this + 26) = 0;
LABEL_16:
  int v15 = *((_DWORD *)this + 4);
  if ((v15 - 2) < 3)
  {
LABEL_19:
    (*(void (**)(void, void, CAML::State *, char *, size_t))(**((void **)this + 6) + 24))(*((void *)this + 6), *((void *)this + 1), this, v9, v5);
    goto LABEL_20;
  }
  if (v15 != 7)
  {
    if (v15 != 6) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  (*(void (**)(void, char *, size_t))(**((void **)this + 1) + 56))(*((void *)this + 1), v9, v5);
LABEL_20:
  if (v5 - 4096 <= 0xFFFFFFFFFFFFEFFELL && v9 != (char *)this + 72) {
    free(v9);
  }
  CFStringRef v17 = (const __CFString *)*((void *)this + 4);
  if (v17)
  {
    unint64_t v18 = (const void *)*((void *)this + 8);
    if (v18) {
      CAML::Context::set_object(*((CAML::Context **)this + 1), v17, *((const CAML::Type **)this + 6), v18);
    }
  }
  int v19 = (void (*)(void, CAML::State *))*((void *)this + 7);
  if (v19) {
    v19(*((void *)this + 1), this);
  }
}

void CAML::State::start(CAML::State *this, const char **a2)
{
  *((void *)this + 27) = a2;
  (*(void (**)(void, void, CAML::State *, const char **))(**((void **)this + 6) + 16))(*((void *)this + 6), *((void *)this + 1), this, a2);
  *((void *)this + 27) = 0;
  size_t v4 = CAML::memq_((const char *)a2, (const char **)"value", (const char *)1);
  if (v4)
  {
    size_t v5 = v4;
    int v6 = strlen(v4);
    CAML::State::characters((char *)this, v5, v6);
    *((unsigned char *)this + 224) |= 1u;
  }
  uint64_t v7 = CAML::memq_((const char *)a2, (const char **)"id", (const char *)1);
  if (v7)
  {
    CFStringRef v8 = CFStringCreateWithCString(0, v7, 0x8000100u);
    *((void *)this + 4) = v8;
    if (!v8) {
      return;
    }
  }
  else
  {
    CFStringRef v8 = (const __CFString *)*((void *)this + 4);
    if (!v8) {
      return;
    }
  }
  long long v9 = (const void *)*((void *)this + 8);
  if (v9)
  {
    uint64_t v10 = (CAML::Context *)*((void *)this + 1);
    char v11 = (const CAML::Type *)*((void *)this + 6);
    CAML::Context::set_object(v10, v8, v11, v9);
  }
}

const char *CAML::memq_(const char *this, const char **__s2, const char *a3)
{
  if (this)
  {
    int v3 = (char *)this;
    this = *(const char **)this;
    if (this)
    {
      int v4 = (int)a3;
      int v6 = *(unsigned __int8 *)__s2;
      while (*(unsigned __int8 *)this != v6 || strcmp(this, (const char *)__s2))
      {
        uint64_t v7 = (const char *)*((void *)v3 + 2);
        v3 += 16;
        this = v7;
        if (!v7) {
          return this;
        }
      }
      if (v4) {
        *(void *)int v3 = "";
      }
      return (const char *)*((void *)v3 + 1);
    }
  }
  return this;
}

char *CAML::State::characters(char *this, const char *__src, int a3)
{
  if ((this[224] & 1) == 0)
  {
    int v3 = this;
    if (*((_DWORD *)this + 4) >= 6u)
    {
      unsigned int v4 = a3;
      size_t v5 = __src;
      uint64_t v6 = *((void *)this + 25);
      if (127 - (int)v6 >= a3) {
        size_t v7 = a3;
      }
      else {
        size_t v7 = (127 - v6);
      }
      if ((int)v7 >= 1)
      {
        this = (char *)memcpy(&this[v6 + 72], __src, v7);
        uint64_t v8 = v3[25] + v7;
        v3[25] = v8;
        *((unsigned char *)v3 + v8 + 72) = 0;
        v5 += v7;
        v4 -= v7;
      }
      if ((int)v4 >= 1)
      {
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        this = (char *)malloc_type_zone_malloc(malloc_zone, v4 + 16, 0x81ECB6CuLL);
        if (this)
        {
          uint64_t v10 = v3[26];
          v3[26] = this;
          *(void *)this = v10;
          *((void *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v4;
          char v11 = this + 16;
          return (char *)memcpy(v11, v5, v4);
        }
      }
    }
  }
  return this;
}

void *CAML::ObjCNSObject::property_type(CAML::ObjCNSObject *this, CAML::Context *a2, void *a3, unsigned int a4)
{
  uint64_t result = (void *)[a3 CAMLTypeForKey:CAAtomGetString(a4)];
  if (result)
  {
    uint64_t v6 = [result UTF8String];
    size_t v7 = *(uint64_t (**)(CAML::Context *, uint64_t))(*(void *)a2 + 32);
    return (void *)v7(a2, v6);
  }
  return result;
}

uint64_t CAML::anonymous namespace'::set_property(CAML::_anonymous_namespace_ *this, CAML::Context *a2, CAML::State *a3)
{
  if (*((void *)a2 + 8))
  {
    size_t v5 = *(uint64_t (**)(void))(**(void **)(*((void *)this + 6) + 48) + 48);
    return v5();
  }
  else
  {
    uint64_t result = *((unsigned int *)a2 + 10);
    {
      uint64_t v8 = (const char *)[(__CFString *)CAAtomGetString(result) cStringUsingEncoding:4];
    }
  }
  return result;
}

uint64_t CAML::ObjCNSObject::set_property(uint64_t this, CAML::Context *a2, void *a3, unsigned int a4, const void *a5)
{
  if ((*(unsigned char *)(this + 32) & 8) != 0)
  {
    uint64_t v7 = *((void *)a2 + 10);
    String = CAAtomGetString(a4);
    this = [a3 CAMLTypeSupportedForKey:String];
    if (this)
    {
      return [a3 CAMLParser:v7 setValue:a5 forKey:String];
    }
  }
  return this;
}

__CFString *CAObject_CAMLTypeForKey(uint64_t a1, const __CFString *a2)
{
  v5[1] = *(CFStringRef *)MEMORY[0x1E4F143B8];
  v5[0] = 0;
  unsigned int v2 = CAInternAtom(a2, 1);
  int v3 = (objc_class *)objc_opt_class();
  switch((unsigned __int16)CAObject_typeForAtom(v3, v2, v5))
  {
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 5u:
      uint64_t result = (__CFString *)v5[0];
      break;
    case 6u:
    case 7u:
    case 8u:
      uint64_t result = @"BOOL";
      break;
    case 9u:
    case 0xAu:
    case 0xBu:
    case 0xCu:
    case 0xDu:
    case 0xEu:
    case 0xFu:
    case 0x10u:
      uint64_t result = @"integer";
      break;
    case 0x11u:
    case 0x12u:
      uint64_t result = @"real";
      break;
    case 0x13u:
      uint64_t result = @"CGPoint";
      break;
    case 0x14u:
      uint64_t result = @"CGSize";
      break;
    case 0x15u:
      uint64_t result = @"CGRect";
      break;
    case 0x16u:
      uint64_t result = @"CATransform3D";
      break;
    case 0x17u:
      uint64_t result = @"CGAffineTransform";
      break;
    case 0x18u:
      uint64_t result = @"CAPoint3D";
      break;
    case 0x19u:
      uint64_t result = @"CACornerRadii";
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

unsigned int *CAObject_typeForAtom(objc_class *a1, unsigned int a2, CFStringRef *a3)
{
  size_t v5 = (uint64_t *)classDescription(a1);
  uint64_t result = propertyInfoForAtom(v5, a2, 0);
  if (result)
  {
    uint64_t v7 = result;
    if (a3)
    {
      CFStringRef v8 = (CFStringRef)*((void *)result + 4);
      if (!v8)
      {
        long long v9 = (const char *)*((void *)v7 + 3);
        if (v9)
        {
          CFStringRef v8 = CFStringCreateWithCString(0, v9, 0x8000100u);
          *((void *)v7 + 4) = v8;
        }
        else
        {
          CFStringRef v8 = 0;
        }
      }
      *a3 = v8;
    }
    return (unsigned int *)*((unsigned __int16 *)v7 + 2);
  }
  return result;
}

uint64_t CA::Layer::State::fetch_defaults(uint64_t a1, CA::Transaction *a2, void (*a3)(uint64_t, uint64_t, uint64_t, CFTypeRef *), uint64_t a4)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v64 = 0;
  memset(v63, 0, sizeof(v63));
  float64x2_t v61 = 0u;
  memset(&v62, 0, sizeof(v62));
  float64x2_t v60 = 0u;
  double v58 = 0.0;
  double v59 = 0.0;
  double v57 = 0.0;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  CFTypeRef cf1 = 0;
  uint64_t v52 = 0;
  a3(a4, 545, 1, &cf1);
  if (cf1)
  {
    *(_DWORD *)(a1 + 16) |= 0x100u;
    uint64_t v8 = 0x1FFFFFLL;
  }
  else
  {
    uint64_t v8 = 0;
  }
  a3(a4, 409, 17, (CFTypeRef *)((char *)&v52 + 4));
  v9.n128_u32[0] = HIDWORD(v52);
  if (*((float *)&v52 + 1) != 1.0)
  {
    *(_DWORD *)(a1 + 12) |= 0x8000000u;
    uint64_t v8 = v8 | 8;
  }
  ((void (*)(uint64_t, uint64_t, uint64_t, double *, __n128))a3)(a4, 568, 22, v63, v9);
  v10.n128_f64[0] = v63[0];
  if (v63[0] == 1.0)
  {
    uint64_t v41 = 1;
    while (v41 != 16)
    {
      uint64_t v42 = v41;
      v10.n128_f64[0] = v63[v41];
      double v43 = *(&CATransform3DIdentity.m11 + v41++);
      if (v10.n128_f64[0] != v43)
      {
        if ((unint64_t)(v42 - 1) <= 0xE) {
          goto LABEL_7;
        }
        break;
      }
    }
  }
  else
  {
LABEL_7:
    *(_DWORD *)(a1 + 12) |= 0x10000000u;
    uint64_t v8 = v8 | 0x20;
  }
  ((void (*)(uint64_t, uint64_t, uint64_t, double *, __n128))a3)(a4, 546, 22, v63, v10);
  v11.n128_f64[0] = v63[0];
  if (v63[0] == 1.0)
  {
    uint64_t v44 = 1;
    while (v44 != 16)
    {
      uint64_t v45 = v44;
      v11.n128_f64[0] = v63[v44];
      double v46 = *(&CATransform3DIdentity.m11 + v44++);
      if (v11.n128_f64[0] != v46)
      {
        if ((unint64_t)(v45 - 1) <= 0xE) {
          goto LABEL_9;
        }
        break;
      }
    }
  }
  else
  {
LABEL_9:
    *(_DWORD *)(a1 + 12) |= 0x20000000u;
    uint64_t v8 = v8 | 0x40;
  }
  ((void (*)(uint64_t, uint64_t, uint64_t, CGAffineTransform *, __n128))a3)(a4, 139, 23, &v62, v11);
  CGAffineTransform v50 = v62;
  if (!CGAffineTransformIsIdentity(&v50))
  {
    *(_DWORD *)(a1 + 16) |= 2u;
    uint64_t v8 = v8 | 0x80;
  }
  a3(a4, 135, 21, (CFTypeRef *)&v60);
  __asm { FMOV            V2.2D, #1.0 }
  float64x2_t v47 = _Q2;
  if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(v60), (int32x4_t)vceqq_f64(v61, _Q2))))))
  {
    *(_DWORD *)(a1 + 12) |= 0x80000000;
    uint64_t v8 = v8 | 0x100;
  }
  a3(a4, 121, 21, (CFTypeRef *)&v60);
  if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(v60), (int32x4_t)vceqq_f64(v61, v47))))))
  {
    *(_DWORD *)(a1 + 12) |= 0x40000000u;
    uint64_t v8 = v8 | 0x20000;
  }
  a3(a4, 136, 18, (CFTypeRef *)&v57);
  v16.n128_f64[0] = v57;
  if (v57 != 1.0)
  {
    *(_DWORD *)(a1 + 16) |= 1u;
    uint64_t v8 = v8 | 0x10;
    if (v16.n128_f64[0] == 2.0 || v16.n128_f64[0] == 3.0) {
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 4) & 0xF3FFFFFF | ((v16.n128_f64[0] & 3) << 26);
    }
  }
  ((void (*)(uint64_t, uint64_t, uint64_t, float64x2_t *, __n128))a3)(a4, 144, 21, &v60, v16);
  __asm { FMOV            V2.2D, #0.5 }
  if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v60, _Q2), (int32x4_t)vceqzq_f64(v61))))))
  {
    *(_DWORD *)(a1 + 16) |= 4u;
    uint64_t v8 = v8 | 0x80000;
  }
  a3(a4, 27, 19, (CFTypeRef *)&v58);
  v18.n128_f64[0] = v58;
  if (v58 != 0.5 || v59 != 0.5)
  {
    if (v59 == 0.0 && v58 == 0.0) {
      int v20 = 24;
    }
    else {
      int v20 = 8;
    }
    *(_DWORD *)(a1 + 16) |= v20;
    uint64_t v8 = v8 | 0x10;
  }
  ((void (*)(uint64_t, uint64_t, uint64_t, double *, __n128))a3)(a4, 28, 18, &v57, v18);
  v21.n128_f64[0] = v57;
  if (v57 != 0.0)
  {
    *(_DWORD *)(a1 + 16) |= 0x20u;
    uint64_t v8 = v8 | 0x10;
  }
  ((void (*)(uint64_t, uint64_t, uint64_t, double *, __n128))a3)(a4, 615, 18, &v57, v21);
  v22.n128_f64[0] = v57;
  if (v57 != 0.0)
  {
    *(_DWORD *)(a1 + 16) |= 0x40u;
    uint64_t v8 = v8 | 8;
  }
  ((void (*)(uint64_t, uint64_t, uint64_t, long long *, __n128))a3)(a4, 147, 25, &v53, v22);
  v49[0] = v53;
  v49[1] = v54;
  v49[2] = v55;
  v49[3] = v56;
  BOOL v23 = CACornerRadiiEqualToRadii((double *)v49, CACornerRadiiZero);
  int v24 = *(_DWORD *)(a1 + 16);
  if (v23)
  {
    if ((v24 & 0x100000) != 0) {
      goto LABEL_37;
    }
  }
  else
  {
    v24 |= 0x1000000u;
    *(_DWORD *)(a1 + 16) = v24;
    uint64_t v8 = v8 | 0x8000;
    if ((v24 & 0x100000) != 0)
    {
LABEL_37:
      if ((v24 & 0x200000) != 0) {
        goto LABEL_45;
      }
      goto LABEL_41;
    }
  }
  int8x16_t v48 = 0;
  a3(a4, 165, 4, (CFTypeRef *)&v48);
  CA::Layer::State::set_delegate((CA::Layer::State *)a1, a2, v48, 1);
  if ((*(_DWORD *)(a1 + 16) & 0x200000) != 0) {
    goto LABEL_45;
  }
LABEL_41:
  uint64_t v26 = (CFTypeRef *)(a1 + 104);
  size_t v25 = *(const void **)(a1 + 104);
  if (v25) {
    CA::Transaction::release_object(a2, v25);
  }
  a3(a4, 119, 1, (CFTypeRef *)(a1 + 104));
  if (*v26)
  {
    CFRetain(*v26);
    uint64_t v8 = v8 | 1;
  }
LABEL_45:
  int v27 = *(_DWORD *)(a1 + 16);
  if ((v27 & 0x400000) != 0)
  {
    if ((v27 & 0x800000) != 0) {
      goto LABEL_47;
    }
  }
  else
  {
    a3(a4, 126, 1, &cf1);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 4) & 0xFFFFFFF8 | CA::Render::Layer::contents_format_from_string((__CFString *)cf1, v39);
    int v27 = *(_DWORD *)(a1 + 16);
    if ((v27 & 0x800000) != 0)
    {
LABEL_47:
      if ((v27 & 0x2000000) != 0) {
        goto LABEL_49;
      }
      goto LABEL_48;
    }
  }
  a3(a4, 131, 1, &cf1);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 4) & 0xFFFFFF87 | (8
                                                          * CA::Render::Layer::gravity_from_string((const __CFString *)cf1, v40));
  uint64_t v8 = v8 | 0x8000;
  if ((*(_DWORD *)(a1 + 16) & 0x2000000) == 0)
  {
LABEL_48:
    a3(a4, 194, 12, (CFTypeRef *)&v52);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 4) & 0xFFFFF87F | ((v52 & 0xF) << 7);
    uint64_t v8 = v8 | 0x8000;
  }
LABEL_49:
  int v28 = *(_DWORD *)(a1 + 24);
  if ((v28 & 0x100) != 0)
  {
    if ((v28 & 0x200) != 0) {
      goto LABEL_51;
    }
  }
  else
  {
    a3(a4, 377, 12, (CFTypeRef *)&v52);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 4) & 0xFFFF87FF | ((v52 & 0xF) << 11);
    uint64_t v8 = v8 | 0x8000;
    int v28 = *(_DWORD *)(a1 + 24);
    if ((v28 & 0x200) != 0)
    {
LABEL_51:
      if ((v28 & 0x400) != 0) {
        goto LABEL_52;
      }
LABEL_73:
      a3(a4, 493, 12, (CFTypeRef *)&v52);
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 4) & 0x3FFFFFFF | (v52 << 30);
      uint64_t v8 = v8 | 0x8000;
      if (*(_DWORD *)(a1 + 24)) {
        goto LABEL_57;
      }
      goto LABEL_53;
    }
  }
  a3(a4, 180, 12, (CFTypeRef *)&v52);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 4) & 0xFC007FFF | ((v52 & 0x7FF) << 15);
  uint64_t v8 = v8 | 0x8000;
  int v28 = *(_DWORD *)(a1 + 24);
  if ((v28 & 0x400) == 0) {
    goto LABEL_73;
  }
LABEL_52:
  if (v28) {
    goto LABEL_57;
  }
LABEL_53:
  a3(a4, 137, 1, &cf1);
  if ([(id)cf1 isEqualToString:@"repeat"]) {
    int v29 = 1024;
  }
  else {
    int v29 = 0;
  }
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 12) & 0xFFFFFBFF | v29;
  uint64_t v8 = v8 | 0x8000;
LABEL_57:
  if ((*(unsigned char *)(a1 + 20) & 8) == 0)
  {
    a3(a4, 562, 12, (CFTypeRef *)&v52);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 8) & 0xFFFFFFE7 | (8 * (v52 & 3));
    uint64_t v8 = v8 | 0x8000;
  }
  uint64_t v30 = 0;
  int v31 = &dword_1E527D534;
  do
  {
    if (((*(_DWORD *)(a1 + 4 * (*(v31 - 4) >> 5) + 4) >> *(v31 - 4)) & 1) == 0)
    {
      a3(a4, *(v31 - 1), 7, (CFTypeRef *)&v64);
      int v32 = *(v31 - 5);
      int v33 = v64;
      unsigned int v34 = v32 >> 5;
      int v35 = 1 << v32;
      uint64_t v36 = a1 + 4 * v34;
      if (v64) {
        int v37 = *(_DWORD *)(v36 + 4) | v35;
      }
      else {
        int v37 = *(_DWORD *)(v36 + 4) & ~v35;
      }
      *(_DWORD *)(v36 + 4) = v37;
      if (((0x810842018A8uLL >> v30) & 1) != v33) {
        uint64_t v8 = *v31 | v8;
      }
    }
    ++v30;
    v31 += 8;
  }
  while (v30 != 46);
  return v8;
}

uint64_t CA::Render::Layer::gravity_from_string(const __CFString *this, const __CFString *a2)
{
  if (this == @"resize") {
    return 9;
  }
  int v2 = CAInternAtom(this, 0);
  int v3 = v2;
  if (v2 <= 470)
  {
    if (v2 == 344) {
      int v5 = 3;
    }
    else {
      int v5 = 0;
    }
    if (v2 == 73) {
      unsigned int v6 = 8;
    }
    else {
      unsigned int v6 = v5;
    }
    if (v2 == 72) {
      int v7 = 7;
    }
    else {
      int v7 = 0;
    }
    if (v2 == 71) {
      unsigned int v8 = 2;
    }
    else {
      unsigned int v8 = v7;
    }
    if (v2 <= 72) {
      return v8;
    }
    else {
      return v6;
    }
  }
  else if (v2 > 563)
  {
    if (v2 == 565) {
      unsigned int v9 = 5;
    }
    else {
      unsigned int v9 = v2 == 564;
    }
    if (v2 == 566) {
      return 6;
    }
    else {
      return v9;
    }
  }
  else
  {
    uint64_t result = 0;
    switch(v3)
    {
      case 471:
        return 9;
      case 472:
        uint64_t result = 10;
        break;
      case 473:
        uint64_t result = 11;
        break;
      case 476:
        uint64_t result = 4;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t CA::Render::Layer::contents_format_from_string(__CFString *cf1, const __CFString *a2)
{
  uint64_t result = 0;
  if (cf1 && cf1 != @"RGBA8")
  {
    if (CFEqual(cf1, @"RGBA8"))
    {
      return 0;
    }
    else if (CFEqual(cf1, @"Automatic"))
    {
      return 5;
    }
    else if (CFEqual(cf1, @"RGBAh"))
    {
      return 1;
    }
    else if (CFEqual(cf1, @"RGBA10XR"))
    {
      return 2;
    }
    else if (CFEqual(cf1, @"A8"))
    {
      return 3;
    }
    else
    {
      return 4 * (CFEqual(cf1, @"Gray8") != 0);
    }
  }
  return result;
}

BOOL CACornerRadiiEqualToRadii(double *a1, double *a2)
{
  if (a1[6] != a2[6] || a1[7] != a2[7]) {
    return 0;
  }
  if (a1[4] != a2[4] || a1[5] != a2[5]) {
    return 0;
  }
  if (*a1 != *a2 || a1[1] != a2[1]) {
    return 0;
  }
  if (a1[3] == a2[3]) {
    return a1[2] == a2[2];
  }
  return 0;
}

void sub_18477D868(_Unwind_Exception *a1)
{
}

void CAML::ObjCString::end(CAML::ObjCString *this, CAML::Context *a2, CAML::State *a3, UInt8 *bytes, CFIndex numBytes)
{
  CFStringRef v6 = CFStringCreateWithBytes(0, bytes, numBytes, 0x8000100u, 0);
  CAML::State::set_value(a3, v6);

  CFRelease(v6);
}

void CAML::State::set_value(CAML::State *this, CFTypeRef cf)
{
  unsigned int v4 = (const void *)*((void *)this + 8);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 8) = 0;
  }
  if (cf) {
    *((void *)this + 8) = CFRetain(cf);
  }
}

uint64_t CAML::ObjCReal::end(CAML::ObjCReal *this, CAML::Context *a2, CAML::State *a3, CAML *a4, uint64_t a5)
{
  v12[1] = *(CAML::Context **)MEMORY[0x1E4F143B8];
  v12[0] = a4;
  int v7 = (CAML *)((char *)a4 + a5);
  double valuePtr = CAML::parse_real(a4, (char *)v12, (char **)((char *)a4 + a5), (const char *)a4);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
  CAML::State::set_value(a3, v8);
  CFRelease(v8);
  return CAML::check_trailer((uint64_t)a2, v12[0], v7, v9);
}

uint64_t CAML::check_trailer(uint64_t this, CAML::Context *a2, CAML::Context *a3, const char *a4)
{
  if (a2 < a3)
  {
    unsigned int v4 = (const char *)a2;
    int v5 = (CAML::Context *)this;
    uint64_t v6 = a3 - a2;
    uint64_t v7 = MEMORY[0x1E4F14390];
    do
    {
      this = *v4;
      if (!*v4) {
        break;
      }
      if ((this & 0x80000000) != 0)
      {
        this = __maskrune(this, 0x4000uLL);
        if (!this)
        {
LABEL_10:
          if (*v4) {
            return CAML::Context::warning(v5, "Ignoring trailing characters: %s", v4);
          }
          return this;
        }
      }
      else
      {
        this = *(_DWORD *)(v7 + 4 * this + 60) & 0x4000;
        if (!this) {
          goto LABEL_10;
        }
      }
      ++v4;
      --v6;
    }
    while (v6);
  }
  return this;
}

uint64_t CAML::ObjCNSObject::start(uint64_t this, CAML::Context *a2, CAML::State *a3, const char **a4)
{
  uint64_t v6 = *((void *)a2 + 10);
  char v7 = *(unsigned char *)(this + 32);
  if ((v7 & 8) != 0)
  {
    *((_DWORD *)a3 + 4) = 2;
    char v7 = *(unsigned char *)(this + 32);
  }
  if (v7)
  {
    *((void *)a2 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = a3;
    this = objc_msgSend(*(id *)(this + 24), "CAMLParserStartElement:", v6, a4);
    *((void *)a2 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  }
  return this;
}

void CAML::ObjCNSObject::end(id *this, CAML::Context *a2, CAML::State *a3, char *a4, uint64_t a5)
{
  uint64_t v8 = *((void *)a2 + 10);
  if (((_BYTE)this[4] & 4) != 0)
  {
    id v9 = (id)[[NSString alloc] initWithBytes:a4 length:a5 encoding:4];
    *((void *)a2 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = a3;
    [this[3] CAMLParserEndElement:v8 content:v9];
    *((void *)a2 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  }
  else if (((_BYTE)this[4] & 2) != 0)
  {
    *((void *)a2 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = a3;
    objc_msgSend(this[3], "CAMLParserEndElement:", v8, a4);
    *((void *)a2 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  }
}

void layer_private_release(_CAMetalLayerPrivate *a1, void *a2)
{
  if (atomic_fetch_add((atomic_uint *volatile)a1, 0xFFFFFFFF) == 1)
  {
    CA::Render::remove_every_observer(a1, a2);
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 2);
    if (*((void *)a1 + 2))
    {
      pthread_setspecific(collect_slot, a1);
      CAImageQueueInvalidate(*((void *)a1 + 2));
      pthread_setspecific(collect_slot, 0);
    }
    int v3 = (uint64_t *)*((void *)a1 + 7);
    if (v3)
    {
      do
      {
        uint64_t v4 = *v3;
        if (*v3)
        {
          uint64_t v5 = *((void *)a1 + 2);
          if (v5)
          {
            uint64_t v6 = *(void *)(v4 + 24);
            if (v6) {
              CAImageQueueUnregisterBuffer(v5, v6);
            }
          }
          char v7 = *(const void **)(v4 + 64);
          if (v7) {
            CFRelease(v7);
          }

          *(void *)(v4 + 72) = 0;
          uint64_t v8 = *(CGColorSpace **)(v4 + 88);
          if (v8)
          {
            CGColorSpaceRelease(v8);
            *(void *)(v4 + 88) = 0;
          }

          free((void *)v4);
        }
        --*((_DWORD *)a1 + 32);
        int v3 = (uint64_t *)v3[1];
      }
      while (v3);
      id v9 = (void *)*((void *)a1 + 7);
      if (v9)
      {
        do
        {
          __n128 v10 = (void *)v9[1];
          free(v9);
          id v9 = v10;
        }
        while (v10);
      }
    }

    *((void *)a1 + 9) = 0;
    *((void *)a1 + 1CA::Context::unref(this[1], 0) = 0;
    __n128 v11 = *((void *)a1 + 18);
    if (v11) {
      dispatch_release(v11);
    }
    char v12 = (CGColorSpace *)*((void *)a1 + 31);
    if (v12) {
      CGColorSpaceRelease(v12);
    }
    *((void *)a1 + 3CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;

    *((void *)a1 + 32) = 0;
    char v13 = (const void *)*((void *)a1 + 2);
    if (v13) {
      CFRelease(v13);
    }

    dispatch_release(*((dispatch_object_t *)a1 + 21));
    dispatch_release(*((dispatch_object_t *)a1 + 22));
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 2);
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 52);

    *((void *)a1 + 27) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 52);
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 46);

    *((void *)a1 + 24) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 46);
    free(a1);
  }
}

void sub_18477E030(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CAML::anonymous namespace'::set_array(CAML::_anonymous_namespace_ *this, CAML::Context *a2, CAML::State *a3)
{
  int v3 = (const void *)*((void *)a2 + 8);
  if (v3) {
    CFArrayAppendValue(*(CFMutableArrayRef *)(*((void *)this + 6) + 64), v3);
  }
}

uint64_t CAML::Context::warning(CAML::Context *this, const char *a2, ...)
{
  va_start(va, a2);
  return (*(uint64_t (**)(CAML::Context *, const char *, uint64_t *))(*(void *)this + 16))(this, a2, (uint64_t *)va);
}

BOOL CAObject_CAMLTypeSupportedForKey(uint64_t a1, const __CFString *a2)
{
  unsigned int v2 = CAInternAtom(a2, 1);
  int v3 = (objc_class *)objc_opt_class();
  return CAObject_typeForAtom(v3, v2, 0) != 0;
}

void CAML::ObjCNSArray::start(CAML::ObjCNSArray *this, CAML::Context *a2, CAML::State *a3, const char **a4)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CAML::State::set_value(a3, Mutable);
  CFRelease(Mutable);
  *((_DWORD *)a3 + 4) = 3;
}

void CAML::ObjCCGRect::end(CAML::ObjCCGRect *this, CAML::Context *a2, CAML::State *a3, CAML *a4, uint64_t a5)
{
  v18[1] = *(CAML::Context **)MEMORY[0x1E4F143B8];
  char v7 = (char **)((char *)a4 + a5);
  v18[0] = a4;
  double v8 = CAML::parse_length(a4, (char *)v18, (char **)((char *)a4 + a5), (const char *)a4);
  double v10 = CAML::parse_length(v18[0], (char *)v18, v7, v9);
  double v12 = CAML::parse_length(v18[0], (char *)v18, v7, v11);
  double v14 = CAML::parse_length(v18[0], (char *)v18, v7, v13);
  uint64_t v16 = CAML::check_trailer((uint64_t)a2, v18[0], (CAML::Context *)v7, v15);
  CFStringRef v17 = (void *)MEMORY[0x185324A30](v16);
  CAML::State::set_value(a3, (CFTypeRef)objc_msgSend(MEMORY[0x1E4F29238], "valueWithRect:", v8, v10, v12, v14));
}

void sub_18477E608(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CAML::ObjCCGPoint::end(CAML::ObjCCGPoint *this, CAML::Context *a2, CAML::State *a3, CAML *a4, uint64_t a5)
{
  v14[1] = *(CAML::Context **)MEMORY[0x1E4F143B8];
  char v7 = (char **)((char *)a4 + a5);
  v14[0] = a4;
  double v8 = CAML::parse_length(a4, (char *)v14, (char **)((char *)a4 + a5), (const char *)a4);
  double v10 = CAML::parse_length(v14[0], (char *)v14, v7, v9);
  uint64_t v12 = CAML::check_trailer((uint64_t)a2, v14[0], (CAML::Context *)v7, v11);
  char v13 = (void *)MEMORY[0x185324A30](v12);
  CAML::State::set_value(a3, (CFTypeRef)objc_msgSend(MEMORY[0x1E4F29238], "valueWithPoint:", v8, v10));
}

void sub_18477E74C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CAML::Context::set_object(CAML::Context *this, const __CFString *key, const CAML::Type *a3, const void *a4)
{
  CFDictionaryRef Mutable = (const __CFDictionary *)*((void *)this + 8);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF98], 0, MEMORY[0x1E4F1D530], 0);
    *((void *)this + 8) = Mutable;
  }
  Boolean Value = CFDictionaryGetValue(Mutable, key);
  if (Value)
  {
    double v10 = Value;
    *Boolean Value = a3;
    __n128 v11 = (const void *)Value[1];
    if (v11 != a4)
    {
      CFRelease(v11);
      v10[1] = CFRetain(a4);
    }
  }
  else
  {
    uint64_t v12 = (__CFDictionary *)*((void *)this + 8);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    double v14 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    int v15 = v14;
    if (v14)
    {
      *double v14 = a3;
      v14[1] = CFRetain(a4);
    }
    CFDictionarySetValue(v12, key, v15);
  }
}

uint64_t CAML::ObjCInteger::end(CAML::ObjCInteger *this, CAML::Context *a2, CAML::State *a3, char *__str, uint64_t a5)
{
  __endptr[1] = *(char **)MEMORY[0x1E4F143B8];
  __endptr[0] = __str;
  char v7 = (CAML::Context *)&__str[a5];
  uint64_t valuePtr = strtol(__str, __endptr, 10);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  CAML::State::set_value(a3, v8);
  CFRelease(v8);
  return CAML::check_trailer((uint64_t)a2, (CAML::Context *)__endptr[0], v7, v9);
}

void CAML::ObjCCGColor::start(CAML::ObjCCGColor *this, CAML::Context *a2, CAML::State *a3, const char **a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  char v7 = CAML::Context::parse_src_attribute(a2, a4);
  if (v7)
  {
    CFURLRef v8 = (const __CFURL *)v7;
    id v9 = (CGImage *)(*(uint64_t (**)(CAML::Context *, const char *))(*(void *)a2 + 72))(a2, v7);
    if (v9 && (v10 = v9, CFTypeID v11 = CFGetTypeID(v9), v11 == CGImageGetTypeID()))
    {
      int v12 = 0;
    }
    else
    {
      image_from_url = CAML::create_image_from_url(v8, 0);
      uint64_t v14 = *(void *)a2;
      if (image_from_url)
      {
        double v10 = image_from_url;
        (*(void (**)(CAML::Context *, const __CFURL *, CGImageSource *))(v14 + 80))(a2, v8, image_from_url);
      }
      else
      {
        uint64_t v26 = (CGImage *)(*(uint64_t (**)(CAML::Context *, const __CFURL *))(v14 + 88))(a2, v8);
        if (!v26 || (double v10 = v26, v27 = CFGetTypeID(v26), v27 != CGImageGetTypeID()))
        {
          CAML::Context::error(a2, "Failed to open image");
LABEL_22:
          CFRelease(v8);
          return;
        }
      }
      int v12 = 1;
    }
    long long v36 = 0u;
    long long v37 = 0u;
    *(_OWORD *)int v35 = 0u;
    int v15 = CAML::memq_((const char *)a4, (const char **)"matrix", (const char *)1);
    if (v15)
    {
      uint64_t v16 = (CAML::Context *)v15;
      size_t v17 = strlen(v15);
      CAML::parse_affine_matrix((CGAffineTransform *)a2, v16, v35, (CAML::Context *)((char *)v16 + v17), v18);
    }
    else
    {
      long long v23 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
      *(_OWORD *)int v35 = *MEMORY[0x1E4F1DAB8];
      long long v36 = v23;
      long long v37 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
    }
    int v24 = (CGPattern *)CGPatternCreateWithImage2();
    if (v12) {
      CGImageRelease(v10);
    }
    if (v24)
    {
      CGColorRef v25 = CA_CGPatternColorCreate(v24);
      CAML::State::set_value(a3, v25);
      CGColorRelease(v25);
      CGPatternRelease(v24);
    }
    else
    {
      CAML::Context::error(a2, "Failed to create pattern from image");
    }
    goto LABEL_22;
  }
  int v19 = CAML::memq_((const char *)a4, (const char **)"colorspace", (const char *)1);
  int v20 = v19;
  if (!v19)
  {
    int v28 = (CGColorSpace *)CAGetColorSpace(0x1Du);
    CGColorSpaceRef v22 = CGColorSpaceRetain(v28);
    if (v22) {
      goto LABEL_12;
    }
LABEL_24:
    int v29 = "sRGB";
    if (v20) {
      int v29 = v20;
    }
    CAML::Context::error(a2, "Unable to create colorspace: %s", v29);
    goto LABEL_27;
  }
  CFStringRef v21 = CFStringCreateWithFormat(0, 0, @"kCGColorSpace%s", v19);
  CGColorSpaceRef v22 = CGColorSpaceCreateWithName(v21);
  CFRelease(v21);
  if (!v22) {
    goto LABEL_24;
  }
LABEL_12:
  CAML::State::set_value(a3, v22);
  CGColorSpaceRelease(v22);
LABEL_27:
  uint64_t v30 = CAML::memq_((const char *)a4, (const char **)"opacity", (const char *)1);
  if (v30)
  {
    int v31 = (CAML *)v30;
    size_t v32 = strlen(v30);
    float v34 = CAML::parse_real(v31, 0, (char **)((char *)v31 + v32), v33);
  }
  else
  {
    float v34 = 1.0;
  }
  *(float *)a3 = v34;
}

uint64_t CAML::ObjCCGColor::end(CAML::ObjCCGColor *this, CAML::Context *a2, CAML::State *a3, CAML::State *a4, char *a5)
{
  return CAML::cgcolor_end(a2, a3, a4, a5);
}

const char *CAML::Context::parse_src_attribute(CAML::Context *this, const char **a2)
{
  uint64_t result = CAML::memq_((const char *)a2, (const char **)"src", (const char *)1);
  if (result)
  {
    uint64_t v4 = (const UInt8 *)result;
    size_t v5 = strlen(result);
    CFURLRef v6 = (const __CFURL *)*((void *)this + 2);
    return (const char *)CFURLCreateWithBytes(0, v4, v5, 0x8000100u, v6);
  }
  return result;
}

void CAML::ObjCCATransform3D::end(CAML::ObjCCATransform3D *this, CAML::Context *a2, CAML::State *a3, char *a4, uint64_t a5)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  __src = a4;
  float64x2_t v54 = (float64x2_t)xmmword_184997D50;
  float64x2_t v55 = 0u;
  float64x2_t v56 = (float64x2_t)xmmword_184997D60;
  float64x2_t v57 = 0u;
  float64x2_t v58 = 0u;
  float64x2_t v59 = (float64x2_t)xmmword_184997D50;
  float64x2_t v60 = 0u;
  float64x2_t v61 = (float64x2_t)xmmword_184997D60;
  if (a5 >= 1)
  {
    size_t v5 = a4;
    CFURLRef v6 = (CAML *)&a4[a5];
    memset(__dst, 0, sizeof(__dst));
    float64x2_t __x = 0uLL;
    float64x2_t v75 = 0uLL;
    float64x2_t v76 = 0uLL;
    float64x2_t v77 = 0uLL;
    float64x2_t v78 = 0uLL;
    float64x2_t v79 = 0uLL;
    float64x2_t v80 = 0uLL;
    float64x2_t v81 = 0uLL;
    float64x2_t v70 = 0uLL;
    float64x2_t v71 = 0uLL;
    float64x2_t v72 = 0uLL;
    long long v62 = 0uLL;
    long long v63 = 0uLL;
    long long v64 = 0uLL;
    long long v65 = 0uLL;
    long long v66 = 0uLL;
    long long v67 = 0uLL;
    v7.f64[0] = NAN;
    v7.f64[1] = NAN;
    int8x16_t v49 = (int8x16_t)vnegq_f64(v7);
    long long v68 = 0uLL;
    long long v69 = 0uLL;
    uint64_t v8 = MEMORY[0x1E4F14390];
    while (1)
    {
      if (!*v5) {
        goto LABEL_118;
      }
      id v9 = CAML::skip_whitespace((CAML *)v5, v6, (const char *)a3);
      size_t v10 = 0;
      __src = v9;
      do
      {
        if (__src < v6)
        {
          unsigned int v11 = *((char *)__src + v10);
          if (!*((unsigned char *)__src + v10)) {
            break;
          }
          if ((v11 & 0x80000000) != 0)
          {
            if (!__maskrune(v11, 0x100uLL)) {
              break;
            }
          }
          else if ((*(_DWORD *)(v8 + 4 * v11 + 60) & 0x100) == 0)
          {
            break;
          }
        }
        ++v10;
      }
      while (v10 != 31);
      int v12 = (char *)__src;
      memcpy(__dst, __src, v10);
      *((unsigned char *)__dst + v1CA::Context::unref(this[1], 0) = 0;
      __src = &v12[v10];
      this = CAML::skip_whitespace((CAML *)&v12[v10], v6, v13);
      size_t v5 = (char *)this;
      __src = this;
      if (this < v6 && *(unsigned char *)this == 40)
      {
        this = CAML::skip_whitespace((CAML::ObjCCATransform3D *)((char *)this + 1), v6, (const char *)a3);
        size_t v5 = (char *)this;
        __src = this;
      }
      if (v5 >= (char *)v6)
      {
        unint64_t v16 = 0;
      }
      else
      {
        unint64_t v16 = 0;
        do
        {
          int v17 = *v5;
          if (!*v5) {
            break;
          }
          if (v17 == 41 || v16 > 0xF)
          {
            if (v17 == 41)
            {
              this = CAML::skip_whitespace((CAML *)(v5 + 1), v6, (const char *)a3);
              size_t v5 = (char *)this;
              __src = this;
            }
            break;
          }
          __x.f64[v16] = CAML::parse_real((CAML *)v5, (char *)&__src, (char **)v6, v15);
          this = CAML::skip_whitespace((CAML *)__src, v6, v19);
          size_t v5 = (char *)this;
          __src = this;
          if (this < v6)
          {
            int v20 = *(unsigned __int8 *)this;
            if (v20 == 59 || v20 == 44)
            {
              this = CAML::skip_whitespace((CAML::ObjCCATransform3D *)((char *)this + 1), v6, (const char *)a3);
              size_t v5 = (char *)this;
              __src = this;
            }
          }
          ++v16;
        }
        while (v5 < (char *)v6);
      }
      if (v5 < (char *)v6)
      {
        int v21 = *v5;
        if (v21 == 59 || v21 == 44)
        {
          this = CAML::skip_whitespace((CAML *)(v5 + 1), v6, (const char *)a3);
          size_t v5 = (char *)this;
          __src = this;
        }
      }
      if (LODWORD(__dst[0]) != 1920229741 || *(_DWORD *)((char *)__dst + 3) != 7891314) {
        break;
      }
      if (v16 == 6)
      {
        float64x2_t v70 = __x;
        float64x2_t v71 = v75;
        float64x2_t v72 = v76;
        float64x2_t v33 = vmlaq_n_f64(vmlaq_n_f64(v60, v54, v76.f64[0]), v56, v76.f64[1]);
        float64x2_t v37 = vmlaq_n_f64(vmulq_n_f64(v54, v75.f64[0]), v56, v75.f64[1]);
        float64x2_t v35 = vmlaq_n_f64(vmlaq_n_f64(v61, v55, v76.f64[0]), v57, v76.f64[1]);
        float64x2_t v38 = vmlaq_n_f64(vmulq_n_f64(v55, v75.f64[0]), v57, v75.f64[1]);
        float64x2_t v54 = vmlaq_n_f64(vmulq_n_f64(v54, __x.f64[0]), v56, __x.f64[1]);
        float64x2_t v55 = vmlaq_n_f64(vmulq_n_f64(v55, __x.f64[0]), v57, __x.f64[1]);
        float64x2_t v56 = v37;
        float64x2_t v57 = v38;
LABEL_78:
        float64x2_t v60 = v33;
        float64x2_t v61 = v35;
        goto LABEL_117;
      }
      if (v16 != 16) {
        goto LABEL_119;
      }
      float64x2_t v58 = v78;
      float64x2_t v59 = v79;
      float64x2_t v60 = v80;
      float64x2_t v61 = v81;
      float64x2_t v54 = __x;
      float64x2_t v55 = v75;
      float64x2_t v56 = v76;
      float64x2_t v57 = v77;
LABEL_117:
      if (v5 >= (char *)v6) {
        goto LABEL_118;
      }
    }
    if (*(void *)&__dst[0] == 0x74616C736E617274 && WORD4(__dst[0]) == 101 && v16 != 0 && v16 <= 3)
    {
      if (v16 <= 1)
      {
        __x.f64[1] = 0.0;
        goto LABEL_82;
      }
      if (v16 == 2)
      {
LABEL_82:
        v75.f64[0] = 0.0;
        double v39 = 0.0;
      }
      else
      {
        double v39 = v75.f64[0];
      }
      float64x2_t v60 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v60, v54, __x.f64[0]), v56, __x.f64[1]), v58, v39);
      float64x2_t v61 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v61, v55, __x.f64[0]), v57, __x.f64[1]), v59, v39);
      goto LABEL_117;
    }
    if (LODWORD(__dst[0]) == 1818321779 && WORD2(__dst[0]) == 101)
    {
      if (v16 == 1)
      {
        double v42 = __x.f64[0];
        __x.f64[1] = __x.f64[0];
        v75.f64[0] = __x.f64[0];
        double v40 = __x.f64[0];
        double v41 = __x.f64[0];
        goto LABEL_106;
      }
      if (v16 == 3)
      {
        double v40 = __x.f64[1];
        double v41 = __x.f64[0];
        double v42 = v75.f64[0];
LABEL_106:
        float64x2_t v54 = vmulq_n_f64(v54, v41);
        float64x2_t v55 = vmulq_n_f64(v55, v41);
        float64x2_t v56 = vmulq_n_f64(v56, v40);
        float64x2_t v57 = vmulq_n_f64(v57, v40);
        float64x2_t v58 = vmulq_n_f64(v58, v42);
        float64x2_t v59 = vmulq_n_f64(v59, v42);
        goto LABEL_117;
      }
    }
    if (LODWORD(__dst[0]) == 1635020658 && *(_DWORD *)((char *)__dst + 3) == 6648929)
    {
      if (v16 == 4)
      {
        CA::Mat4Impl::mat4_set_rotation((CA::Mat4Impl *)v83, v14, __x.f64[0], __x.f64[1], v75.f64[0], v75.f64[1]);
LABEL_113:
        float64x2_t v47 = (double *)v83;
LABEL_116:
        CA::Mat4Impl::mat4_concat(&v54, v47, v54.f64, (const double *)v15);
        goto LABEL_117;
      }
      if (v16 == 1)
      {
        long long v87 = 0u;
        long long v88 = 0u;
        long long v84 = 0u;
        long long v89 = xmmword_184997D50;
        long long v90 = 0u;
        long long v91 = xmmword_184997D60;
        __double2 v45 = __sincos_stret(__x.f64[0]);
        *(double *)v44.i64 = v45.__cosval;
        *(double *)v43.i64 = v45.__sinval;
        if (fabs(v45.__sinval) >= 0.0000001)
        {
          if (fabs(v45.__cosval) < 0.0000001)
          {
            v44.i64[0] = 1.0;
            v43.i64[0] = vbslq_s8(v49, v44, v43).u64[0];
            v44.i64[0] = 0;
          }
        }
        else
        {
          v43.i64[0] = 1.0;
          v44.i64[0] = vbslq_s8(v49, v43, v44).u64[0];
          v43.i64[0] = 0;
        }
        v83[0] = v44.i64[0];
        v83[1] = v43.i64[0];
        double v85 = -*(double *)v43.i64;
        uint64_t v86 = v44.i64[0];
        goto LABEL_113;
      }
    }
    BOOL v29 = LODWORD(__dst[0]) == 2003135347 && WORD2(__dst[0]) == 88;
    if (!v29 && (LODWORD(__dst[0]) == 2003135347 ? (BOOL v30 = WORD2(__dst[0]) == 89) : (BOOL v30 = 0), !v30) || v16 != 1)
    {
      if ((*(void *)&__dst[0] == 0x59587261656873
         || *(void *)&__dst[0] == 0x5A597261656873
         || *(void *)&__dst[0] == 0x5A587261656873)
        && v16 == 1)
      {
        long long v62 = xmmword_184997D50;
        long long v63 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v64 = xmmword_184997D60;
        long long v67 = xmmword_184997D50;
        long long v68 = 0u;
        long long v69 = xmmword_184997D60;
        if (BYTE5(__dst[0]) == 89)
        {
          *((void *)&v66 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(void *)&__x.f64[0];
        }
        else if (BYTE6(__dst[0]) == 89)
        {
          *(float64_t *)&long long v64 = __x.f64[0];
        }
        else
        {
          *(float64_t *)&long long v66 = __x.f64[0];
        }
      }
      else
      {
        BOOL v46 = *(void *)&__dst[0] == 0x7463657073726570 && DWORD2(__dst[0]) == 6649449;
        if (!v46 || v16 != 1)
        {
LABEL_119:
          this = (CAML::ObjCCATransform3D *)CAML::Context::error(a2, "Invalid transform: %s (position %ld)", a4, v5 - a4);
          goto LABEL_118;
        }
        long long v62 = xmmword_184997D50;
        long long v63 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v64 = xmmword_184997D60;
        *(void *)&long long v67 = 0x3FF0000000000000;
        long long v68 = 0u;
        long long v69 = xmmword_184997D60;
        *((double *)&v67 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = -1.0 / __x.f64[0];
      }
      float64x2_t v47 = (double *)&v62;
      goto LABEL_116;
    }
    float64x2_t v31 = *(float64x2_t *)(MEMORY[0x1E4F1DAB8] + 16);
    float64x2_t v70 = *(float64x2_t *)MEMORY[0x1E4F1DAB8];
    float64x2_t v71 = v31;
    float64x2_t v72 = *(float64x2_t *)(MEMORY[0x1E4F1DAB8] + 32);
    double v32 = tan(__x.f64[0]);
    v71.f64[0] = v32;
    if (BYTE4(__dst[0]) == 89)
    {
      v70.f64[1] = v32;
      v71.f64[0] = 0.0;
    }
    float64x2_t v33 = vmlaq_n_f64(vmlaq_n_f64(v60, v54, v72.f64[0]), v56, v72.f64[1]);
    float64x2_t v34 = vmlaq_n_f64(vmulq_n_f64(v54, v71.f64[0]), v56, v71.f64[1]);
    float64x2_t v35 = vmlaq_n_f64(vmlaq_n_f64(v61, v55, v72.f64[0]), v57, v72.f64[1]);
    float64x2_t v36 = vmlaq_n_f64(vmulq_n_f64(v55, v71.f64[0]), v57, v71.f64[1]);
    float64x2_t v54 = vmlaq_n_f64(vmulq_n_f64(v54, v70.f64[0]), v56, v70.f64[1]);
    float64x2_t v55 = vmlaq_n_f64(vmulq_n_f64(v55, v70.f64[0]), v57, v70.f64[1]);
    float64x2_t v56 = v34;
    float64x2_t v57 = v36;
    goto LABEL_78;
  }
LABEL_118:
  int8x16_t v48 = (void *)MEMORY[0x185324A30](this);
  v53[4] = v58;
  v53[5] = v59;
  v53[6] = v60;
  v53[7] = v61;
  v53[0] = v54;
  v53[1] = v55;
  v53[2] = v56;
  v53[3] = v57;
  CAML::State::set_value(a3, (CFTypeRef)[MEMORY[0x1E4F29238] valueWithCATransform3D:v53]);
}

void sub_18477F60C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CAML::anonymous namespace'::set_value(CAML::State **this, CFTypeRef *a2, CAML::State *a3)
{
}

void CAML::anonymous namespace'::set_document(CAML::_anonymous_namespace_ *this, CAML::Context *a2, CAML::State *a3)
{
  uint64_t v4 = (const void *)*((void *)a2 + 8);
  size_t v5 = (const void *)*((void *)this + 5);
  if (v5)
  {
    CFRelease(v5);
    *((void *)this + 5) = 0;
  }
  if (v4) {
    *((void *)this + 5) = CFRetain(v4);
  }
}

uint64_t CA::OGL::MetalContext::tile_downsample_surface(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4, int8x8_t a5)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 2984)) {
    return 0;
  }
  uint64_t v6 = 0;
  if ((*(unsigned char *)(a2 + 69) & 0x40) != 0)
  {
    a5.i32[0] = a3;
    uint8x8_t v7 = (uint8x8_t)vcnt_s8(a5);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.i32[0] <= 1u)
    {
      unsigned int v8 = __clz(__rbit32(a3));
      if (v8 >= 4) {
        __assert_rtn("tile_downsample_surface", "ogl-metal.mm", 14422, "index < 4");
      }
      uint64_t v10 = *(void *)(a1 + 272);
      if ((*(unsigned char *)(v10 + 68) & 8) != 0)
      {
        uint64_t v12 = byte_184998AC4[v8];
        uint64_t tile_pipeline = CA::OGL::MetalContext::get_tile_pipeline(a1, byte_184998AC4[v8], *(void *)(v10 + 120));
        int v14 = a4[1];
        v27[0] = *a4;
        v27[1] = v14;
        unint64_t v15 = *((unsigned __int8 *)&CA::OGL::MetalContext::tile_shader_type_info + 16 * v12 + 8);
        unint64_t v16 = [*(id *)(a1 + 2984) tileWidth] / v15;
        unint64_t v17 = [*(id *)(a1 + 2984) tileHeight] / v15;
        _S0 = powf(*(float *)(a2 + 64) / *(float *)(v10 + 64), 1.0 / *(float *)(a1 + 152));
        __asm { FCVT            H0, S0 }
        __int16 v26 = LOWORD(_S0);
        [*(id *)(a1 + 2984) setRenderPipelineState:tile_pipeline];
        [*(id *)(a1 + 2984) setTileTexture:*(void *)(a2 + 96) atIndex:0];
        [*(id *)(a1 + 2984) setTileBytes:v27 length:4 atIndex:9];
        [*(id *)(a1 + 2984) setTileBytes:&v26 length:2 atIndex:6];
        long long v23 = *(void **)(a1 + 2984);
        v25[0] = v16;
        v25[1] = v17;
        uint64_t v6 = 1;
        v25[2] = 1;
        [v23 dispatchThreadsPerTile:v25];
        *(void *)(a1 + 336CA::Context::unref(this[1], 0) = tile_pipeline;
        *(_WORD *)(a2 + 75) = *(_WORD *)(a2 + 75) & 0xFF5F | 0x80;
        return v6;
      }
      return 0;
    }
  }
  return v6;
}

uint64_t CA::WindowServer::IOMFBServer::post_frame_rate_power_log(CA::WindowServer::IOMFBServer *this, CA::Render::Object *a2, void *a3, void *a4)
{
  size_t v5 = (pthread_mutex_t *)((char *)a2 + 544);
  pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 544));
  uint64_t v6 = *((void *)a2 + 12);
  if ((*(_DWORD *)(v6 + 624) & 0x100) != 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v6 + 27480));
    if (*(void *)(v6 + 27512)
      && (uint64_t v7 = mach_absolute_time(), v8 = CATimeWithHostTime(v7), v8 - *(double *)(v6 + 27528) >= 1.0))
    {
      *(double *)(v6 + 27528) = v8;
      CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      uint64_t v10 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
      unsigned int v11 = *(uint64_t **)(v6 + 27504);
      if (v11)
      {
        uint64_t v12 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
        do
        {
          char v13 = CFArrayCreateMutable(0, 0, v12);
          CA_CFArrayAppendInt(v13, *((_DWORD *)v11 + 4));
          CA_CFArrayAppendInt(v13, *((_DWORD *)v11 + 8));
          CA_CFArrayAppendInt(v13, *((_DWORD *)v11 + 7));
          CA_CFArrayAppendInt(v13, *((_DWORD *)v11 + 6));
          CA_CFArrayAppendInt(v13, *((_DWORD *)v11 + 5));
          CA_CFArrayAppendInt(v13, *((_DWORD *)v11 + 9));
          CFArrayAppendValue(v10, v13);
          if (v13) {
            CFRelease(v13);
          }
          unsigned int v11 = (uint64_t *)*v11;
        }
        while (v11);
      }
      CFDictionarySetValue(Mutable, @"data", v10);
      if (*(void *)(v6 + 27512))
      {
        int v14 = *(void **)(v6 + 27504);
        if (v14)
        {
          do
          {
            unint64_t v15 = (void *)*v14;
            operator delete(v14);
            int v14 = v15;
          }
          while (v15);
        }
        *(void *)(v6 + 27504) = 0;
        uint64_t v16 = *(void *)(v6 + 27496);
        if (v16)
        {
          for (uint64_t i = 0; i != v16; ++i)
            *(void *)(*(void *)(v6 + 27488) + 8 * i) = 0;
        }
        *(void *)(v6 + 27512) = 0;
      }
      if (v10) {
        CFRelease(v10);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 27480));
      if (CA::WindowServer::IOMFBDisplay::post_frame_rate_power_log(void)::once[0] != -1) {
        dispatch_once(CA::WindowServer::IOMFBDisplay::post_frame_rate_power_log(void)::once, &__block_literal_global_446);
      }
      if (CA::WindowServer::IOMFBDisplay::post_frame_rate_power_log(void)::frame_count_id) {
        pps_send_telemetry();
      }
      PLLogTimeSensitiveRegisteredEvent();
      if (Mutable) {
        CFRelease(Mutable);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 27480));
    }
  }

  return pthread_mutex_unlock(v5);
}

void CA_CFArrayAppendInt(__CFArray *a1, int a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  int valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFArrayAppendValue(a1, v3);
  CFRelease(v3);
}

void CA::CG::Queue::Flush::callback(CA::CG::Queue::Flush *this, void *a2)
{
  v3[6] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)this;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = ___ZN2CA2CG5Queue5Flush8callbackEPv_block_invoke;
  v3[3] = &__block_descriptor_tmp_3;
  v3[4] = v2;
  v3[5] = this;
  ___ZN2CA2CG5Queue5Flush8callbackEPv_block_invoke((uint64_t)v3);
}

void ___ZN2CA2CG5Queue5Flush8callbackEPv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (CA::CG::Queue *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 32) + 56))(*(void *)(a1 + 32), *(unsigned int *)(*(void *)(a1 + 40) + 8));
  CA::CG::Queue::reclaim_slabs(v2);
  CA::CG::Queue::mark_serial(*(CA::CG::Queue **)(a1 + 32));
  CFNumberRef v3 = *(void **)(a1 + 40);
  if (v3)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v3);
  }
}

void CA::CG::Queue::reclaim_slabs(CA::CG::Queue *this)
{
  if (CA::CG::Queue::_free_slabs)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::CG::Queue::_free_lock);
    uint64_t v1 = (void *)CA::CG::Queue::_free_slabs;
    if (CA::CG::Queue::_free_slabs && *(void *)CA::CG::Queue::_free_slabs)
    {
      CA::CG::Queue::_free_slabs = *(void *)CA::CG::Queue::_free_slabs;
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::CG::Queue::_free_lock);
      size_t v2 = v1[1];
      munmap(v1, v2);
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::CG::Queue::_free_lock);
    }
  }
}

void CA::CG::AccelQueue::flush_all_renderers(uint64_t a1, int a2)
{
  if (a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::CG::AccelRenderer::_list_lock);
    uint64_t v5 = CA::CG::AccelRenderer::_list;
    if (CA::CG::AccelRenderer::_list)
    {
      do
      {
        uint64_t v4 = (CA::CG::Renderer *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 48))(a1, 1, v5);
        uint64_t v5 = *(void *)(v5 + 4272);
      }
      while (v5);
      if (a2 == 3)
      {
        for (uint64_t i = CA::CG::AccelRenderer::_list; i; uint64_t i = *(void *)(i + 4272))
          uint64_t v4 = (CA::CG::Renderer *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 48))(a1, 3, i);
      }
    }
    CA::CG::Renderer::flush_released_objects(v4);
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::CG::AccelRenderer::_list_lock);
  }
}

uint64_t CA::CG::Queue::did_flush_renderer(uint64_t this)
{
  *(_DWORD *)(this + 168) = 0;
  return this;
}

uint64_t CA::CG::AccelQueue::flush_renderer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const __CFString *a7)
{
  int v8 = a2;
  if (*(unsigned char *)(a1 + 209)) {
    uint64_t v10 = *(CA::CG::AccelRenderer ***)(a1 + 200);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = a3;
  if (a3
    || (uint64_t v11 = CA::CG::AccelRenderer::acquire(*(CA::CG::AccelRenderer **)(a1 + 176), (CA::CG::AccelDrawable *)(a1 + 184), v10, *(unsigned int *)(a1 + 24), 1, *(__CFString **)(a1 + 192), a7)) != 0)
  {
    *(unsigned char *)(a1 + 208) = 0;
    (*(void (**)(void, uint64_t, CA::CG::AccelRenderer **))(**(void **)(a1 + 176) + 64))(*(void *)(a1 + 176), a2, v10);
    CA::CG::AccelRenderer::unlock_surface((CA::CG::AccelRenderer *)v11);
    CA::CG::Renderer::end_rendering((CA::CG::Renderer *)v11);
    CA::CG::Renderer::end_rendering((CA::CG::Renderer *)v11);
    uint64_t v12 = *(void *)(v11 + 8);
    if (!v12)
    {
      uint64_t v14 = 0;
      if (a3) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
    (*(void (**)(uint64_t, BOOL))(*(void *)v12 + 408))(v12, v8 == 3);
    (*(void (**)(uint64_t))(*(void *)v11 + 16))(v11);
    uint64_t v13 = *(unsigned int *)(v11 + 288);
    uint64_t v14 = *(void *)(v11 + 8);
    double v15 = *(double *)(v14 + 240);
    if (*(double *)(v11 + 16 * v13 + 160) + 0.03125 >= v15)
    {
      int v18 = *(_DWORD *)(v11 + 152);
    }
    else
    {
      if (v13 == 7) {
        unsigned int v16 = 0;
      }
      else {
        unsigned int v16 = v13 + 1;
      }
      *(_DWORD *)(v11 + 288) = v16;
      uint64_t v17 = v11 + 16 * v16;
      *(double *)(v17 + 16CA::Context::unref(this[1], 0) = v15;
      int v18 = *(_DWORD *)(v11 + 152);
      *(_DWORD *)(v17 + 168) = v18;
    }
    *(void *)(v11 + 296) = 0;
    *(_DWORD *)(v11 + 152) = v18 + 1;
    if (!a3)
    {
LABEL_16:
      *(unsigned char *)(v11 + 4228) = 0;
      *(_DWORD *)(v14 + 352) = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)(v11 + 4224));
    }
  }
LABEL_17:
  int v19 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 16);

  return v19(a1);
}

void CA::CG::Renderer::end_rendering(CA::CG::Renderer *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 4176))
  {
    *((unsigned char *)this + 4176) &= ~1u;
    uint64_t v2 = *((void *)this + 1);
    if (v2)
    {
      (*(void (**)(uint64_t, char *))(*(void *)v2 + 1016))(v2, (char *)this + 1296);
      if (BYTE13(xmmword_1EB2ACC50))
      {
        if (CA::CG::cg_perf_log(void)::once_token[0] != -1) {
          dispatch_once(CA::CG::cg_perf_log(void)::once_token, &__block_literal_global_11);
        }
        os_signpost_id_t v7 = *((void *)this + 521);
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          int v8 = CA::CG::cg_perf_log(void)::log;
          if (os_signpost_enabled((os_log_t)CA::CG::cg_perf_log(void)::log))
          {
            *(_DWORD *)long long buf = 138543362;
            uint64_t v10 = (uint64_t)_MXSignpostMetricsSnapshot();
            _os_signpost_emit_with_name_impl(&dword_184668000, v8, OS_SIGNPOST_INTERVAL_END, v7, "Rendering", "\n%{public, signpost:metrics}@", buf, 0xCu);
          }
        }
      }
      uint64_t v3 = (*(uint64_t (**)(void, void))(**((void **)this + 1) + 184))(*((void *)this + 1), 0);
      if (v3)
      {
        uint64_t v4 = v3;
        if (x_log_hook_p())
        {
          (*(void (**)(void, uint64_t))(**((void **)this + 1) + 192))(*((void *)this + 1), v4);
          x_log_();
        }
        else
        {
          uint64_t v5 = x_log_category_cg;
          if (os_log_type_enabled((os_log_t)x_log_category_cg, OS_LOG_TYPE_ERROR))
          {
            uint64_t v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 1) + 192))(*((void *)this + 1), v4);
            *(_DWORD *)long long buf = 136315138;
            uint64_t v10 = v6;
            _os_log_impl(&dword_184668000, v5, OS_LOG_TYPE_ERROR, "CoreAnimation: rendering error %s\n", buf, 0xCu);
          }
        }
      }
    }
  }
}

void CA::OGL::MetalContext::end_rendering(uint64_t a1)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  *(_WORD *)(a1 + 3328) |= 0x80u;
  *(float *)&double v2 = CA::OGL::Context::end_rendering((CA::OGL::Context *)a1);
  uint64_t v3 = *(void **)(a1 + 3056);
  if (!v3) {
    goto LABEL_8;
  }
  if (*(_DWORD *)(a1 + 616) != 1)
  {
LABEL_7:
    [v3 endScope];
    goto LABEL_8;
  }
  if ((objc_msgSend(*(id *)(a1 + 3048), "isCapturing", v2) & 1) == 0)
  {
    uint64_t v3 = *(void **)(a1 + 3056);
    goto LABEL_7;
  }
  CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)a1, 0);
  [*(id *)(a1 + 3056) endScope];
  [*(id *)(a1 + 3048) stopCapture];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    int v18 = x_log_category_ogl_metal;
    if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v43) = 0;
      _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_DEFAULT, "Finished capturing GPU frames\n", (uint8_t *)&v43, 2u);
    }
  }
LABEL_8:
  os_signpost_id_t v4 = *(void *)(a1 + 4104);
  if (v4)
  {
    if (v4 != -1)
    {
      double v41 = CA::OGL::MetalContext::_perf_log;
      if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::_perf_log))
      {
        double v42 = _MXSignpostMetricsSnapshot();
        int v43 = 138543362;
        int8x16_t v44 = v42;
        _os_signpost_emit_with_name_impl(&dword_184668000, v41, OS_SIGNPOST_INTERVAL_END, v4, "Rendering", "\n%{public, signpost:metrics}@", (uint8_t *)&v43, 0xCu);
      }
    }
    *(void *)(a1 + 4104) = 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1904));
  unint64_t v5 = *(void *)(a1 + 1888);
  uint64_t v6 = *(void **)(a1 + 1880);
  if (v5 >= 0x385 && v6 != 0)
  {
    uint64_t v8 = 0;
    id v9 = 0;
    do
    {
      if (!v8 || *(void *)(v6[5] + 8) < *(void *)(v8 + 8))
      {
        id v9 = v6;
        uint64_t v8 = v6[5];
      }
      uint64_t v6 = (void *)*v6;
    }
    while (v6);
    if (v8)
    {
      int8x8_t v10 = *(int8x8_t *)(a1 + 1872);
      unint64_t v11 = v9[1];
      uint8x8_t v12 = (uint8x8_t)vcnt_s8(v10);
      v12.i16[0] = vaddlv_u8(v12);
      if (v12.u32[0] > 1uLL)
      {
        if (v11 >= *(void *)&v10) {
          v11 %= *(void *)&v10;
        }
      }
      else
      {
        v11 &= *(void *)&v10 - 1;
      }
      uint64_t v13 = *(void *)(a1 + 1864);
      uint64_t v14 = *(void **)(v13 + 8 * v11);
      do
      {
        double v15 = v14;
        uint64_t v14 = (void *)*v14;
      }
      while (v14 != v9);
      if (v15 == (void *)(a1 + 1880)) {
        goto LABEL_38;
      }
      unint64_t v16 = v15[1];
      if (v12.u32[0] > 1uLL)
      {
        if (v16 >= *(void *)&v10) {
          v16 %= *(void *)&v10;
        }
      }
      else
      {
        v16 &= *(void *)&v10 - 1;
      }
      if (v16 != v11)
      {
LABEL_38:
        if (!*v9) {
          goto LABEL_39;
        }
        unint64_t v17 = *(void *)(*v9 + 8);
        if (v12.u32[0] > 1uLL)
        {
          if (v17 >= *(void *)&v10) {
            v17 %= *(void *)&v10;
          }
        }
        else
        {
          v17 &= *(void *)&v10 - 1;
        }
        if (v17 != v11) {
LABEL_39:
        }
          *(void *)(v13 + 8 * v1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
      }
      uint64_t v19 = *v9;
      if (*v9)
      {
        unint64_t v20 = *(void *)(v19 + 8);
        if (v12.u32[0] > 1uLL)
        {
          if (v20 >= *(void *)&v10) {
            v20 %= *(void *)&v10;
          }
        }
        else
        {
          v20 &= *(void *)&v10 - 1;
        }
        if (v20 != v11)
        {
          *(void *)(*(void *)(a1 + 1864) + 8 * v2CA::Context::unref(this[1], 0) = v15;
          uint64_t v19 = *v9;
        }
      }
      *double v15 = v19;
      *(void *)(a1 + 1888) = v5 - 1;
      operator delete(v9);
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1904));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 2016));
  unint64_t v21 = *(void *)(a1 + 2000);
  if (v21 >= 0x65)
  {
    CGColorSpaceRef v22 = *(void **)(a1 + 1992);
    if (v22)
    {
      uint64_t v23 = 0;
      int v24 = 0;
      do
      {
        if (!v23 || *(void *)(v22[3] + 8) < *(void *)(v23 + 8))
        {
          int v24 = v22;
          uint64_t v23 = v22[3];
        }
        CGColorSpaceRef v22 = (void *)*v22;
      }
      while (v22);
      if (v23)
      {
        int8x8_t v25 = *(int8x8_t *)(a1 + 1984);
        unint64_t v26 = v24[1];
        uint8x8_t v27 = (uint8x8_t)vcnt_s8(v25);
        v27.i16[0] = vaddlv_u8(v27);
        if (v27.u32[0] > 1uLL)
        {
          if (v26 >= *(void *)&v25) {
            v26 %= *(void *)&v25;
          }
        }
        else
        {
          v26 &= *(void *)&v25 - 1;
        }
        uint64_t v28 = *(void *)(a1 + 1976);
        BOOL v29 = *(void **)(v28 + 8 * v26);
        do
        {
          BOOL v30 = v29;
          BOOL v29 = (void *)*v29;
        }
        while (v29 != v24);
        if (v30 == (void *)(a1 + 1992)) {
          goto LABEL_73;
        }
        unint64_t v31 = v30[1];
        if (v27.u32[0] > 1uLL)
        {
          if (v31 >= *(void *)&v25) {
            v31 %= *(void *)&v25;
          }
        }
        else
        {
          v31 &= *(void *)&v25 - 1;
        }
        if (v31 != v26)
        {
LABEL_73:
          if (!*v24) {
            goto LABEL_74;
          }
          unint64_t v32 = *(void *)(*v24 + 8);
          if (v27.u32[0] > 1uLL)
          {
            if (v32 >= *(void *)&v25) {
              v32 %= *(void *)&v25;
            }
          }
          else
          {
            v32 &= *(void *)&v25 - 1;
          }
          if (v32 != v26) {
LABEL_74:
          }
            *(void *)(v28 + 8 * v26) = 0;
        }
        uint64_t v33 = *v24;
        if (*v24)
        {
          unint64_t v34 = *(void *)(v33 + 8);
          if (v27.u32[0] > 1uLL)
          {
            if (v34 >= *(void *)&v25) {
              v34 %= *(void *)&v25;
            }
          }
          else
          {
            v34 &= *(void *)&v25 - 1;
          }
          if (v34 != v26)
          {
            *(void *)(*(void *)(a1 + 1976) + 8 * v34) = v30;
            uint64_t v33 = *v24;
          }
        }
        void *v30 = v33;
        *(void *)(a1 + 200CA::Context::unref(this[1], 0) = v21 - 1;
        operator delete(v24);
      }
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 2016));
  if (*(_DWORD *)(a1 + 2128) >= 0x3E9u)
  {
    float64x2_t v35 = *(void **)(a1 + 2104);
    if (v35)
    {
      uint64_t v36 = 0;
      do
      {
        uint64_t v37 = v35[6];
        if (*(unsigned char *)(v37 + 25))
        {
          if (atomic_load((unint64_t *)v37))
          {
            if (!v36 || *(void *)(v37 + 16) < *(void *)(v36 + 16)) {
              uint64_t v36 = v35[6];
            }
          }
        }
        float64x2_t v35 = (void *)*v35;
      }
      while (v35);
      if (v36)
      {
        if (!*(unsigned char *)(v36 + 25) || (unint64_t v39 = atomic_load((unint64_t *)v36)) == 0) {
          __assert_rtn("purge_pipeline_state", "ogl-metal.mm", 6688, "can_purge ()");
        }
        CA::OGL::MetalContext::Pipeline::wait_for_completion((CA::OGL::MetalContext::Pipeline *)v36);
        double v40 = (void *)atomic_load((unint64_t *)v36);

        atomic_store(0, (unint64_t *)v36);
        *(unsigned char *)(v36 + 24) = 0;
        --*(_DWORD *)(a1 + 2128);
      }
    }
  }
}

float CA::OGL::Context::end_rendering(CA::OGL::Context *this)
{
  uint64_t v2 = *((void *)this + 34);
  if (v2 != *((void *)this + 33)) {
    goto LABEL_2;
  }
  if (v2) {
    LODWORD(v2) = (*(unsigned __int8 *)(v2 + 72) >> 1) & 0x1F;
  }
  if (*((_DWORD *)this + 65) != v2) {
LABEL_2:
  }
    CA::OGL::Context::prepare_destination_(this);
  (*(void (**)(CA::OGL::Context *))(*(void *)this + 240))(this);
  *((void *)this + 3CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  if (*(float *)&dword_1EB2ACAA8 > 0.0) {
    *(float *)&dword_1EB2ACAA8 = *(float *)&dword_1EB2ACAA8 + -1.0;
  }
  float result = *(float *)&dword_1EB2ACB44;
  if (*(float *)&dword_1EB2ACB44 > 0.0)
  {
    float result = *(float *)&dword_1EB2ACB44 + -1.0;
    *(float *)&dword_1EB2ACB44 = *(float *)&dword_1EB2ACB44 + -1.0;
  }
  return result;
}

double CA::OGL::MetalContext::restore_state(CA::OGL::MetalContext *this)
{
  uint64_t v1 = 0;
  uint64_t v2 = *((void *)this + 3);
  do
  {
    *(_OWORD *)(v2 + 96 + vCA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = xmmword_184997ED0;
    v1 += 16;
  }
  while (v1 != 48);
  *(unsigned char *)(v2 + 48CA::Context::unref(this[1], 0) = 1;
  *(unsigned char *)(v2 + 481) &= ~1u;
  *((unsigned char *)this + 65) &= ~1u;
  double result = NAN;
  *((void *)this + 7) = -1;
  return result;
}

uint64_t CA::CG::Renderer::collect_(CA::CG::Renderer *this)
{
  uint64_t v1 = this;
  CA::Render::collect(0, *(double *)(*((void *)this + 1) + 240));
  uint64_t v2 = 0;
  int v24 = v1;
  do
  {
    uint64_t v3 = (char *)v1 + 192 * v2;
    if (*((_DWORD *)v3 + 370))
    {
      os_signpost_id_t v4 = (void **)((char *)v1 + 192 * v2 + 1488);
      unint64_t v5 = *v4;
      if (*v4 != v4)
      {
        uint64_t v6 = (uint64_t)(v3 + 1392);
        os_signpost_id_t v7 = v3 + 1480;
        unsigned int v8 = *(_DWORD *)(*((void *)v1 + 1) + 232);
        uint64_t v25 = v2;
        id v9 = (char *)v1 + 192 * v2;
        int8x8_t v10 = v9 + 1440;
        unint64_t v11 = (uint64_t *)(v9 + 1448);
        unsigned int v12 = 256;
        do
        {
          uint64_t v13 = (void *)*v5;
          if (*((_DWORD *)v5 + 14) + v12 < v8)
          {
            uint64_t v14 = (void *)v5[1];
            v13[1] = v14;
            *uint64_t v14 = v13;
            *unint64_t v5 = v5;
            v5[1] = v5;
            uint64_t v15 = *v11;
LABEL_7:
            while ((char *)v15 != v10)
            {
              unint64_t v16 = (_DWORD *)v15;
              uint64_t v15 = *(void *)(v15 + 8);
              unint64_t v17 = v16 + 10;
              while (1)
              {
                unint64_t v17 = (void *)*v17;
                if (!v17) {
                  break;
                }
                if ((void *)v17[1] == v5)
                {
                  CA::OGL::Mosaic::delete_image(v6, v16);
                  goto LABEL_7;
                }
              }
            }
            --*v7;
            int v18 = (atomic_uint *)v5[2];
            if (v18 && atomic_fetch_add(v18 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v18 + 16))(v18);
            }
            uint64_t v19 = v5[3];
            if (v19) {
              MEMORY[0x185323DA0](v19, 0x1020C8062D53EE8);
            }
            malloc_zone = (malloc_zone_t *)get_malloc_zone();
            malloc_zone_free(malloc_zone, v5);
          }
          v12 >>= 1;
          unint64_t v5 = v13;
        }
        while (v13 != v4);
        uint64_t v1 = v24;
        uint64_t v2 = v25;
        if (!*v7 && !*((void *)v24 + 24 * v25 + 184))
        {
          uint64_t v21 = *((void *)v24 + 24 * v25 + 183);
          if (v21) {
            MEMORY[0x185323DA0](v21, 0x20C8093837F09);
          }
          CGColorSpaceRef v22 = (char *)v24 + 192 * v25;
          *((void *)v22 + 183) = 0;
          *((void *)v22 + 182) = 0;
        }
      }
    }
    ++v2;
  }
  while (v2 != 6);
  uint64_t result = (*(uint64_t (**)(void, void))(**((void **)v1 + 1) + 216))(*((void *)v1 + 1), 0);
  *((unsigned char *)v1 + 4176) &= ~2u;
  return result;
}

void CA::CG::IOSurfaceDrawable::mark_texture(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 3;
  os_unfair_lock_lock(this + 3);
  uint64_t v3 = *(void *)&this[26]._os_unfair_lock_opaque;
  if (v3) {
    atomic_fetch_add((atomic_uint *volatile)(v3 + 36), 1u);
  }

  os_unfair_lock_unlock(v2);
}

void CA::CG::AccelRenderer::unlock_surface(CA::CG::AccelRenderer *this)
{
  uint64_t v2 = (__IOSurface *)*((void *)this + 532);
  if (v2)
  {
    uint64_t v3 = (char *)this + 4256;
    IOSurfaceUnlock(v2, 0, 0);
    CFRelease(*(CFTypeRef *)v3);
    *(void *)uint64_t v3 = 0;
    *((void *)v3 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  }
}

void CA::CG::Renderer::flush_released_objects(CA::CG::Renderer *this)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)&CA::CG::_released_objects_lock);
  uint64_t v1 = CA::CG::_released_objects;
  int v2 = CA::CG::_released_objects_count;
  CA::CG::_released_objects = 0;
  CA::CG::_released_objects_count = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::CG::_released_objects_lock);
  if (v1)
  {
    if (CA::CG::release_queue(void)::once != -1) {
      dispatch_once(&CA::CG::release_queue(void)::once, &__block_literal_global_16);
    }
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZN2CA2CG8Renderer22flush_released_objectsEv_block_invoke;
    block[3] = &__block_descriptor_tmp_4;
    int v4 = v2;
    block[4] = v1;
    dispatch_async((dispatch_queue_t)CA::CG::release_queue(void)::queue, block);
  }
}

uint64_t CA::WindowServer::IOMFBServer::post_max_rate_power_log(CA::WindowServer::IOMFBServer *this, CA::Render::Object *a2, void *a3, void *a4)
{
  uint64_t v5 = (pthread_mutex_t *)((char *)a2 + 544);
  pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 544));
  uint64_t v6 = *((void *)a2 + 12);
  uint64_t v7 = mach_absolute_time();
  uint64_t v8 = 0;
  while (!*(_DWORD *)(v6 + 25492 + v8))
  {
    v8 += 4;
    if (v8 == 40) {
      goto LABEL_9;
    }
  }
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CA_CFDictionarySetLongLong(Mutable, @"mach_absolute_time", v7);
  uint64_t v10 = 0;
  uint64_t v11 = v6 + 25492;
  do
  {
    CA_CFDictionarySetInt(Mutable, CA::WindowServer::power_log_dr_keys[v10], *(_DWORD *)(v11 + 4 * v10));
    *(_DWORD *)(v11 + 4 * v10++) = 0;
  }
  while (v10 != 10);
  PLLogTimeSensitiveRegisteredEvent();
  if (Mutable) {
    CFRelease(Mutable);
  }
LABEL_9:

  return pthread_mutex_unlock(v5);
}

void CA_CFDictionarySetInt(__CFDictionary *a1, const void *a2, int a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

uint64_t CAImageQueueSetReducedPollingTimeRange(uint64_t result, double a2, double a3)
{
  uint64_t v3 = *(void *)(result + 48);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 24);
    *(double *)(v4 + 304) = a2;
    *(double *)(v4 + 312) = a3;
    __dmb(0xBu);
  }
  return result;
}

BOOL CA::OGL::iosurface_textures_compare(CA::OGL *this, __IOSurface *a2, __IOSurface *a3)
{
  return this != a2;
}

uint64_t draw_linear_gradient(double a1, double a2, double a3, double a4, uint64_t a5, uint64_t a6, uint64_t a7, CGGradient *a8, uint64_t a9)
{
  Info = (CACGContextEvaluator *)CGContextDelegateGetInfo();
  CGGStateGetStyle();
  Color = (CGColor *)CGStyleGetColor();
  unsigned int CompositeOperation = CGGStateGetCompositeOperation();
  CACGContextEvaluator::update_with_color((uint64_t)Info, Color, CompositeOperation);
  CACGContextEvaluator::update_with_gradient(Info, a8);
  *((unsigned char *)Info + 78) |= CGGStateGetStyle() != 0;
  uint64_t v20 = *(void *)(CGContextDelegateGetInfo() + 48);
  v21.n128_f64[0] = a1;
  v22.n128_f64[0] = a2;
  v23.n128_f64[0] = a3;
  v24.n128_f64[0] = a4;

  return MEMORY[0x1F40D9DF8](v20, a6, a7, a8, a9, v21, v22, v23, v24);
}

uint64_t CACGContextEvaluator::update_with_gradient(CACGContextEvaluator *this, CGGradient *a2)
{
  *((unsigned char *)this + 72) = 1;
  *((unsigned char *)this + 77) = 1;
  ColorSpace = (CGColorSpace *)CGGradientGetColorSpace();
  CACGContextEvaluator::update_with_color_space((uint64_t)this, ColorSpace, 0);
  return CGGradientApplyWithBlock();
}

uint64_t end_layer(uint64_t a1)
{
  CGContextDelegateGetInfo();
  CGContextDelegateEndLayer();
  uint64_t Info = CGContextDelegateGetInfo();
  CGGStateGetStyle();
  Color = (CGColor *)CGStyleGetColor();
  unsigned int CompositeOperation = CGGStateGetCompositeOperation();
  CACGContextEvaluator::update_with_color(Info, Color, CompositeOperation);
  *(unsigned char *)(Info + 78) |= CGGStateGetStyle() != 0;
  *(unsigned char *)(Info + 77) = 1;
  return a1;
}

uint64_t draw_image(uint64_t a1, uint64_t a2, uint64_t a3, CGImage *a4)
{
  uint64_t Info = (CACGContextEvaluator *)CGContextDelegateGetInfo();
  CGGStateGetStyle();
  Color = (CGColor *)CGStyleGetColor();
  unsigned int CompositeOperation = CGGStateGetCompositeOperation();
  CACGContextEvaluator::update_with_color((uint64_t)Info, Color, CompositeOperation);
  if (CGImageIsMask(a4))
  {
    FillColor = (CGColor *)CGGStateGetFillColor();
    unsigned int v10 = CGGStateGetCompositeOperation();
    CACGContextEvaluator::update_with_color((uint64_t)Info, FillColor, v10);
  }
  else
  {
    CACGContextEvaluator::update_with_image(Info, a4);
  }
  *((unsigned char *)Info + 78) |= CGGStateGetStyle() != 0;
  CGContextDelegateGetInfo();

  return CGContextDelegateDrawImage();
}

uint64_t CACGContextEvaluator::update_with_image(CACGContextEvaluator *this, CGImageRef image)
{
  *((unsigned char *)this + 72) = 1;
  *((unsigned char *)this + 77) = 1;
  size_t v4 = *((unsigned int *)this + 21);
  if (CGImageGetBitsPerComponent(image) >= v4) {
    int BitsPerComponent = CGImageGetBitsPerComponent(image);
  }
  else {
    int BitsPerComponent = *((_DWORD *)this + 21);
  }
  *((_DWORD *)this + 2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = BitsPerComponent;
  if ((CGImageGetBitmapInfo(image) & 0x100) != 0) {
    *((unsigned char *)this + 8CA::Context::unref(this[1], 0) = 1;
  }
  ColorSpace = CGImageGetColorSpace(image);
  if (CGColorSpaceUsesITUR_2100TF(ColorSpace)) {
    *((unsigned char *)this + 8CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 1;
  }

  return CACGContextEvaluator::update_with_color_space((uint64_t)this, ColorSpace, 1);
}

uint64_t draw_path(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t Info = CGContextDelegateGetInfo();
  CGGStateGetStyle();
  Color = (CGColor *)CGStyleGetColor();
  unsigned int CompositeOperation = CGGStateGetCompositeOperation();
  CACGContextEvaluator::update_with_color(Info, Color, CompositeOperation);
  if (a4 <= 4)
  {
    if (a4 == 2
      || (FillColor = (CGColor *)CGGStateGetFillColor(),
          unsigned int v13 = CGGStateGetCompositeOperation(),
          CACGContextEvaluator::update_with_color(Info, FillColor, v13),
          (a4 - 2) <= 2))
    {
      StrokeColor = (CGColor *)CGGStateGetStrokeColor();
      unsigned int v15 = CGGStateGetCompositeOperation();
      CACGContextEvaluator::update_with_color(Info, StrokeColor, v15);
    }
  }
  *(unsigned char *)(Info + 78) |= CGGStateGetStyle() != 0;
  uint64_t v16 = *(void *)(CGContextDelegateGetInfo() + 48);

  return MEMORY[0x1F40D9E08](v16, a2, a3, a4, a5);
}

uint64_t draw_rects(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t Info = CGContextDelegateGetInfo();
  CGGStateGetStyle();
  Color = (CGColor *)CGStyleGetColor();
  unsigned int CompositeOperation = CGGStateGetCompositeOperation();
  CACGContextEvaluator::update_with_color(Info, Color, CompositeOperation);
  if (a4 <= 4)
  {
    if (a4 == 2
      || (FillColor = (CGColor *)CGGStateGetFillColor(),
          unsigned int v15 = CGGStateGetCompositeOperation(),
          CACGContextEvaluator::update_with_color(Info, FillColor, v15),
          (a4 - 2) <= 2))
    {
      StrokeColor = (CGColor *)CGGStateGetStrokeColor();
      unsigned int v17 = CGGStateGetCompositeOperation();
      CACGContextEvaluator::update_with_color(Info, StrokeColor, v17);
    }
  }
  *(unsigned char *)(Info + 78) |= CGGStateGetStyle() != 0;
  uint64_t v18 = *(void *)(CGContextDelegateGetInfo() + 48);

  return MEMORY[0x1F40D9E20](v18, a2, a3, a4, a5, a6);
}

uint64_t draw_path_direct(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t Info = CGContextDelegateGetInfo();
  CGGStateGetStyle();
  Color = (CGColor *)CGStyleGetColor();
  unsigned int CompositeOperation = CGGStateGetCompositeOperation();
  CACGContextEvaluator::update_with_color(Info, Color, CompositeOperation);
  if (a4 <= 4)
  {
    if (a4 == 2
      || (FillColor = (CGColor *)CGGStateGetFillColor(),
          unsigned int v15 = CGGStateGetCompositeOperation(),
          CACGContextEvaluator::update_with_color(Info, FillColor, v15),
          (a4 - 2) <= 2))
    {
      StrokeColor = (CGColor *)CGGStateGetStrokeColor();
      unsigned int v17 = CGGStateGetCompositeOperation();
      CACGContextEvaluator::update_with_color(Info, StrokeColor, v17);
    }
  }
  *(unsigned char *)(Info + 78) |= CGGStateGetStyle() != 0;
  uint64_t v18 = *(void *)(CGContextDelegateGetInfo() + 48);

  return MEMORY[0x1F40D9E10](v18, a2, a3, a4, a5, a6);
}

uint64_t draw_glyphs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int TextDrawingMode = CGGStateGetTextDrawingMode();
  uint64_t Info = (unsigned char *)CGContextDelegateGetInfo();
  CGGStateGetStyle();
  Color = (CGColor *)CGStyleGetColor();
  unsigned int CompositeOperation = CGGStateGetCompositeOperation();
  CACGContextEvaluator::update_with_color((uint64_t)Info, Color, CompositeOperation);
  if ((TextDrawingMode & 0xFFFFFFF9) == 0)
  {
    FillColor = (CGColor *)CGGStateGetFillColor();
    unsigned int v18 = CGGStateGetCompositeOperation();
    CACGContextEvaluator::update_with_color((uint64_t)Info, FillColor, v18);
  }
  if (((TextDrawingMode - 1) & 0xFFFFFFFA) == 0)
  {
    StrokeColor = (CGColor *)CGGStateGetStrokeColor();
    unsigned int v20 = CGGStateGetCompositeOperation();
    CACGContextEvaluator::update_with_color((uint64_t)Info, StrokeColor, v20);
  }
  FontSmoothingBackgroundColor = (CGColor *)CGGStateGetFontSmoothingBackgroundColor();
  unsigned int v22 = CGGStateGetCompositeOperation();
  CACGContextEvaluator::update_with_color((uint64_t)Info, FontSmoothingBackgroundColor, v22);
  LODWORD(FontSmoothingBackgroundColor) = CGGStateGetFontRenderingStyle();
  if ((FontSmoothingBackgroundColor & MEMORY[0x1853227C0](a2) & 2) != 0)
  {
    Info[77] = 1;
    Info[75] = 1;
  }
  Info[78] |= CGGStateGetStyle() != 0;
  uint64_t v23 = *(void *)(CGContextDelegateGetInfo() + 48);

  return MEMORY[0x1F40D9DD0](v23, a2, a3, a4, a5, a6, a7);
}

void CACGContextEvaluator::update_with_color(uint64_t a1, CGColorRef color, unsigned int a3)
{
  if (!color) {
    return;
  }
  CGPatternRef Pattern = CGColorGetPattern(color);
  double Alpha = CGColorGetAlpha(color);
  if (a3 == 2 && Alpha == 0.0 && Pattern == 0) {
    return;
  }
  *(unsigned char *)(a1 + 72) = 1;
  if (a3 >= 0xB)
  {
LABEL_15:
    *(unsigned char *)(a1 + 77) = 1;
    goto LABEL_16;
  }
  if (!*(unsigned char *)(a1 + 77))
  {
    id v9 = *(CGColor **)(a1 + 64);
    if (v9)
    {
      if (CGColorEqualToColor(v9, color)) {
        goto LABEL_16;
      }
    }
    else if (!Pattern)
    {
      *(void *)(a1 + 64) = CGColorRetain(color);
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_16:
  ColorSpace = CGColorGetColorSpace(color);
  Image = (CGImage *)CGPatternGetImage();
  if (Image)
  {
    CACGContextEvaluator::update_with_image((CACGContextEvaluator *)a1, Image);
  }
  else if (CGPatternGetShading())
  {
    *(unsigned char *)(a1 + 72) = 1;
    *(unsigned char *)(a1 + 77) = 1;
    unsigned int v12 = (CGColorSpace *)CGShadingGetColorSpace();
    CACGContextEvaluator::update_with_color_space(a1, v12, 1);
  }
  else if (Pattern)
  {
    *(unsigned char *)(a1 + 72) = 1;
    *(_WORD *)(a1 + 79) = 257;
    *(unsigned char *)(a1 + 8CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 1;
    *(_DWORD *)(a1 + 74) = 16843009;
  }
  Components = CGColorGetComponents(color);
  if (CGColorSpaceGetNumberOfComponents(ColorSpace) == 3)
  {
    double v14 = Components[1];
    if (*Components == v14
      && v14 == Components[2]
      && (ColorSpace == (CGColorSpace *)CAGetColorSpace(0x1Du)
       || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
       || ColorSpace == (CGColorSpace *)CAGetColorSpace(0x1Cu)
       || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
       || ColorSpace == (CGColorSpace *)CAGetColorSpace(5u)
       || CGColorSpaceEqualToColorSpaceIgnoringRange()))
    {
      ColorSpace = (CGColorSpace *)CAGetColorSpace(3u);
    }
  }
  CACGContextEvaluator::update_with_color_space(a1, ColorSpace, 0);

  CACGContextEvaluator::update_with_color_components((CACGContextEvaluator *)a1, ColorSpace, Components);
}

uint64_t CACGContextEvaluator::update_with_color_space(uint64_t this, CGColorSpace *a2, int a3)
{
  if (a2)
  {
    size_t v4 = a2;
    CFNumberRef v5 = (unsigned char *)this;
    while (1)
    {
      this = CGColorSpaceGetProcessColorModel();
      if (this == 1) {
        break;
      }
      if (!this)
      {
        v5[74] = 1;
        return this;
      }
      if (CGColorSpaceGetModel(v4) != kCGColorSpaceModelPattern)
      {
        this = CGColorSpaceGetModel(v4);
        if (this != 5)
        {
          v5[76] = 1;
          return this;
        }
      }
      this = (uint64_t)CGColorSpaceGetBaseColorSpace(v4);
      size_t v4 = (CGColorSpace *)this;
      if (!this) {
        return this;
      }
    }
    v5[75] = 1;
    if (a3)
    {
      this = CGColorSpaceIsWideGamutRGB(v4);
      if (this)
      {
        CAGetColorSpace(5u);
        this = CGColorSpaceEqualToColorSpace();
        if (this) {
          v5[79] = 1;
        }
        else {
          v5[80] = 1;
        }
      }
    }
  }
  return this;
}

uint64_t CACGContextEvaluator::update_with_color_components(CACGContextEvaluator *this, CGColorSpaceRef space, const double *a3)
{
  size_t v4 = space;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (CGColorSpaceGetModel(space) == kCGColorSpaceModelPattern
    || (uint64_t result = CGColorSpaceGetModel(v4), result == 5))
  {
    uint64_t result = (uint64_t)CGColorSpaceGetBaseColorSpace(v4);
    size_t v4 = (CGColorSpace *)result;
  }
  if (v4)
  {
    uint64_t v7 = (CGColorSpace *)*((void *)this + 3);
    memset(v14, 0, sizeof(v14));
    if (CARequiresColorMatching(v4, v7, 0))
    {
      uint64_t result = CARetainColorTransform(v7);
      if (!result)
      {
LABEL_18:
        *(_WORD *)((char *)this + 79) = 257;
        return result;
      }
      if (CGColorTransformConvertColorComponents()) {
        a3 = (const double *)v14;
      }
      uint64_t result = CGColorTransformRelease();
    }
    else
    {
      uint64_t result = CGColorSpaceGetModel(v4);
      if (!result) {
        return result;
      }
    }
    uint64_t v8 = 0;
    char v9 = 0;
    char v10 = 0;
    do
    {
      float v11 = a3[v8];
      BOOL v12 = v11 < -0.7549;
      if (v11 > 1.2549) {
        BOOL v12 = 1;
      }
      v10 |= v12;
      BOOL v13 = v11 < -0.0039216;
      if (v11 > 1.0039) {
        BOOL v13 = 1;
      }
      v9 |= v13;
      ++v8;
    }
    while (v8 != 3);
    if (v10) {
      goto LABEL_18;
    }
    if (v9) {
      *((unsigned char *)this + 79) = 1;
    }
  }
  return result;
}

uint64_t CARetainColorTransform(CGColorSpace *a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&transform_lock);
  uint64_t v2 = transform_list;
  if (transform_list)
  {
    while (!CGColorSpaceEqualToColorSpace())
    {
      uint64_t v2 = *(void *)(v2 + 8);
      if (!v2)
      {
        uint64_t v3 = (CGColorSpaceRef **)transform_list;
        if (transform_list)
        {
          int v4 = 0;
          uint64_t v5 = transform_list;
          do
          {
            ++v4;
            uint64_t v5 = *(void *)(v5 + 8);
          }
          while (v5);
          if (v4 >= 3)
          {
            unsigned int v6 = v4 + 1;
            do
            {
              uint64_t v7 = *v3;
              CGColorSpaceRelease(**v3);
              CGColorTransformRelease();
              malloc_zone = (malloc_zone_t *)get_malloc_zone();
              malloc_zone_free(malloc_zone, v7);
              uint64_t v3 = (CGColorSpaceRef **)x_list_remove_head((void *)transform_list);
              transform_list = (uint64_t)v3;
              --v6;
            }
            while (v6 > 3);
          }
        }
        goto LABEL_10;
      }
    }
  }
  else
  {
LABEL_10:
    uint64_t v9 = MEMORY[0x185321380](a1, 0);
    if (v9)
    {
      char v10 = (void *)transform_list;
      CGColorSpaceRef v11 = CGColorSpaceRetain(a1);
      BOOL v12 = (malloc_zone_t *)get_malloc_zone();
      BOOL v13 = malloc_type_zone_malloc(v12, 0x10uLL, 0x8BB15036uLL);
      *BOOL v13 = v11;
      v13[1] = v9;
      if (v10)
      {
        double v14 = v10;
        do
        {
          uint64_t v15 = v14;
          double v14 = (void *)v14[1];
        }
        while (v14);
        uint64_t v16 = (malloc_zone_t *)get_malloc_zone();
        unsigned int v17 = malloc_type_zone_malloc(v16, 0x10uLL, 0x8BB15036uLL);
        *unsigned int v17 = v13;
        v17[1] = 0;
        v15[1] = v17;
      }
      else
      {
        unsigned int v18 = (malloc_zone_t *)get_malloc_zone();
        char v10 = malloc_type_zone_malloc(v18, 0x10uLL, 0x8BB15036uLL);
        void *v10 = v13;
        v10[1] = 0;
      }
      transform_list = (uint64_t)v10;
    }
  }
  uint64_t v19 = CGColorTransformRetain();
  os_unfair_lock_unlock((os_unfair_lock_t)&transform_lock);
  return v19;
}

BOOL CA::Transform::operator==(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a1 + 144) & 0x10) == 0 && (*(unsigned char *)(a2 + 144) & 0x10) == 0)
  {
    if (((*(unsigned char *)(a2 + 144) ^ *(unsigned char *)(a1 + 144)) & 7) == 0
      && *(double *)(a1 + 128) == *(double *)(a2 + 128)
      && *(double *)(a1 + 96) == *(double *)(a2 + 96))
    {
      return *(double *)(a1 + 104) == *(double *)(a2 + 104);
    }
    return 0;
  }
  if (*(double *)a1 != *(double *)a2) {
    return 0;
  }
  uint64_t v3 = 1;
  unint64_t v4 = 15;
  while (v3 != 16)
  {
    double v5 = *(double *)(a1 + 8 * v3);
    double v6 = *(double *)(a2 + 8 * v3++);
    if (v5 != v6)
    {
      unint64_t v4 = v3 - 2;
      return v4 > 0xE;
    }
  }
  return v4 > 0xE;
}

uint64_t default_anim_init(void)
{
  basicAnifloat m = objc_alloc_init(CABasicAnimation);
  transition = objc_alloc_init(CATransition);
  id v0 = +[CAMediaTimingFunction functionWithName:@"default"];
  [(id)basicAnim setTimingFunction:v0];
  [(id)basicAnim setFillMode:@"backwards"];
  [(id)basicAnim setKeyPath:@"contents"];
  [(id)transition setTimingFunction:v0];
  uint64_t result = [(id)transition setFillMode:@"backwards"];
  *(_DWORD *)(basicAnim + 16) |= 1u;
  *(_DWORD *)(transition + 16) |= 1u;
  return result;
}

CAMediaTimingFunctionBuiltin *builtin_function(unsigned int a1)
{
  if (a1 > 4) {
    return 0;
  }
  uint64_t result = (CAMediaTimingFunctionBuiltin *)functions[a1];
  if (!result)
  {
    uint64_t result = objc_alloc_init(CAMediaTimingFunctionBuiltin);
    result->_index = a1;
    functions[a1] = result;
  }
  return result;
}

uint64_t CA::Render::GainMapLayer::get_bounds(CA::Render::GainMapLayer *this, const CA::Render::Layer *a2, Rect *a3, Rect *a4)
{
  uint64_t v7 = (*(uint64_t (**)(CA::Render::GainMapLayer *))(*(void *)this + 200))(this);
  if (v7)
  {
    *(_OWORD *)&a3->top = *((_OWORD *)a2 + 4);
    *(_OWORD *)&a3[2].top = *((_OWORD *)a2 + 5);
    CA::BoundsImpl::inset((double *)a3, -2.0, -2.0);
    if (a4)
    {
      *(_OWORD *)&a4->top = 0u;
      *(_OWORD *)&a4[2].top = 0u;
    }
  }
  return v7;
}

BOOL CA::Render::GainMapLayer::bounds_are_visible(CA::Render::GainMapLayer *this)
{
  if (*((unsigned char *)this + 16) == 3 || BYTE10(xmmword_1EB2ACC50) != 0) {
    return 1;
  }
  if (CADeviceSupportsHWGainMap::once[0] != -1) {
    dispatch_once(CADeviceSupportsHWGainMap::once, &__block_literal_global_80);
  }
  return CADeviceSupportsHWGainMap::supports_gain_map == 0;
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*>(long long *a1, long long *a2, long long *a3, uint64_t (**a4)(long long *, long long *))
{
  char v8 = (*a4)(a2, a1);
  uint64_t result = (*a4)(a3, a2);
  if (v8)
  {
    if (result)
    {
      uint64_t v10 = *((void *)a1 + 2);
      long long v11 = *a1;
      uint64_t v12 = *((void *)a3 + 2);
      *a1 = *a3;
      *((void *)a1 + 2) = v12;
    }
    else
    {
      uint64_t v19 = *((void *)a1 + 2);
      long long v20 = *a1;
      uint64_t v21 = *((void *)a2 + 2);
      *a1 = *a2;
      *((void *)a1 + 2) = v21;
      *a2 = v20;
      *((void *)a2 + 2) = v19;
      uint64_t result = (*a4)(a3, a2);
      if (!result) {
        return result;
      }
      uint64_t v10 = *((void *)a2 + 2);
      long long v11 = *a2;
      uint64_t v22 = *((void *)a3 + 2);
      *a2 = *a3;
      *((void *)a2 + 2) = v22;
    }
    *a3 = v11;
    *((void *)a3 + 2) = v10;
  }
  else if (result)
  {
    uint64_t v13 = *((void *)a2 + 2);
    long long v14 = *a2;
    uint64_t v15 = *((void *)a3 + 2);
    *a2 = *a3;
    *((void *)a2 + 2) = v15;
    *a3 = v14;
    *((void *)a3 + 2) = v13;
    uint64_t result = (*a4)(a2, a1);
    if (result)
    {
      uint64_t v16 = *((void *)a1 + 2);
      long long v17 = *a1;
      uint64_t v18 = *((void *)a2 + 2);
      *a1 = *a2;
      *((void *)a1 + 2) = v18;
      *a2 = v17;
      *((void *)a2 + 2) = v16;
    }
  }
  return result;
}

void CA::WindowServer::Server::get_display_info(CA::WindowServer::Server *this, CA::Render::Object *a2, char *a3, void *a4)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (float64x2_t *)*((void *)a2 + 12);
  if (*((_DWORD *)a3 + 1) == LODWORD(v4[1].f64[1]))
  {
    uint64_t v7 = (pthread_mutex_t *)&v4[35];
    pthread_mutex_lock((pthread_mutex_t *)&v4[35]);
    *a3 = 1;
    uint64_t v8 = *((void *)a2 + 12);
    *((void *)a3 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(void *)(v8 + 28);
    if (((*(uint64_t (**)(void))(*(void *)v8 + 800))() & 1) == 0) {
      a3[16] = 0;
    }
    if (((*(uint64_t (**)(void, uint64_t, char *, uint64_t, void))(**((void **)a2 + 12) + 800))(*((void *)a2 + 12), 1, a3 + 80, 64, 0) & 1) == 0)a3[80] = 0; {
    if (((*(uint64_t (**)(void, uint64_t, char *, uint64_t, void))(**((void **)a2 + 12) + 800))(*((void *)a2 + 12), 2, a3 + 144, 256, 0) & 1) == 0)a3[144] = 0;
    }
    uint64_t v9 = *((void *)a2 + 12);
    if (*(void *)(v9 + 48) && (*(unsigned char *)(v9 + 56) & 1) != 0)
    {
      *((_DWORD *)a3 + 2238) = 0;
      *((void *)a3 + 1074) = 0;
      *((void *)a3 + 1076) = 0;
      *((void *)a3 + 1075) = 0;
    }
    else
    {
      long long v53 = 0u;
      memset(__p, 0, 24);
      *(_OWORD *)&__p[32] = 0u;
      memset(v52, 0, sizeof(v52));
      *(void *)&__p[24] = &__p[32];
      LODWORD(v53) = 1065353216;
      os_unfair_lock_lock((os_unfair_lock_t)&v4[24].f64[1]);
      CA::WindowServer::Display::ModeSet::operator=((char **)__p, (char **)&v4[25]);
      float64_t v48 = v4[40].f64[1];
      float64_t v49 = v4[40].f64[0];
      os_unfair_lock_unlock((os_unfair_lock_t)&v4[24].f64[1]);
      unint64_t v10 = (uint64_t)(*(void *)&__p[8] - *(void *)__p) >> 3;
      if (v10 >= 0x400) {
        unint64_t v10 = 1024;
      }
      *((void *)a3 + 1074) = v10;
      *((void *)a3 + 1092) = *((void *)a3 + 1091);
      *((_DWORD *)a3 + 2238) = DWORD2(v53);
      if (v10)
      {
        unint64_t v11 = 0;
        for (i = 0; i < v10; unint64_t v11 = ++i)
        {
          uint64_t v13 = *(void *)__p;
          if (v11 >= (uint64_t)(*(void *)&__p[8] - *(void *)__p) >> 3) {
            abort();
          }
          *(void *)&a3[8 * v11 + 400] = *(void *)(*(void *)__p + 8 * v11);
          if (*((_DWORD *)a3 + 2238))
          {
            *(_DWORD *)&v50[0].unsigned int var2 = 0;
            *(void *)&v50[0].unsigned int var0 = 0;
            CA::WindowServer::Display::ModeSet::get_per_mode_info((uint64_t)__p, *(void *)(v13 + 8 * v11), v50);
            long long v14 = (PerModeInfo *)*((void *)a3 + 1092);
            uint64_t v15 = *((void *)a3 + 1091);
            unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v14 - v15) >> 2);
            unint64_t v17 = *((void *)a3 + 1094);
            if (v17 < v16 + 1)
            {
              uint64_t v18 = *((void *)a3 + 1093);
              unint64_t v19 = (v17 + 1) | ((v17 + 1) >> 1) | (((v17 + 1) | ((v17 + 1) >> 1)) >> 2);
              unint64_t v20 = v19 | (v19 >> 4) | ((v19 | (v19 >> 4)) >> 8);
              unint64_t v21 = v20 | (v20 >> 16) | ((v20 | (v20 >> 16)) >> 32);
              if (v21 + 1 > v16 + 1) {
                unint64_t v22 = v21 + 1;
              }
              else {
                unint64_t v22 = v16 + 1;
              }
              uint64_t v23 = (char *)malloc_type_malloc(12 * v22, 0x1000040CBA68D63uLL);
              __n128 v24 = v23;
              uint64_t v25 = (uint64_t *)*((void *)a3 + 1091);
              unint64_t v26 = (uint64_t *)*((void *)a3 + 1092);
              if (v25 != v26)
              {
                uint8x8_t v27 = v23;
                do
                {
                  uint64_t v28 = *v25;
                  *((_DWORD *)v27 + 2) = *((_DWORD *)v25 + 2);
                  *(void *)uint8x8_t v27 = v28;
                  v27 += 12;
                  uint64_t v25 = (uint64_t *)((char *)v25 + 12);
                }
                while (v25 != v26);
              }
              if (v15 != v18) {
                free(*((void **)a3 + 1091));
              }
              *((void *)a3 + 109CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v24;
              long long v14 = (PerModeInfo *)&v24[12 * v16];
              *((void *)a3 + 1092) = v14;
              *((void *)a3 + 1094) = v22;
            }
            *long long v14 = v50[0];
            *((void *)a3 + 1092) += 12;
            unint64_t v10 = *((void *)a3 + 1074);
          }
        }
      }
      *((float64_t *)a3 + 1075) = v49;
      *((float64_t *)a3 + 1076) = v48;
      std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v52);
      std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(*(void **)&__p[32]);
      if (*(void *)__p)
      {
        *(void *)&__p[8] = *(void *)__p;
        operator delete(*(void **)__p);
      }
      uint64_t v7 = (pthread_mutex_t *)&v4[35];
      if (*((_DWORD *)a3 + 2238)
        && 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a3 + 1092) - *((void *)a3 + 1091)) >> 2) != *((void *)a3 + 1074))
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          BOOL v29 = x_log_category_windowserver;
          if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a3 + 1092) - *((void *)a3 + 1091)) >> 2);
            uint64_t v31 = *((void *)a3 + 1074);
            *(_DWORD *)__p = 134218240;
            *(void *)&__p[4] = v30;
            *(_WORD *)&__p[12] = 2048;
            *(void *)&__p[14] = v31;
            _os_log_impl(&dword_184668000, v29, OS_LOG_TYPE_DEFAULT, "Per Mode Size: %zu != Available Modes Count: %zu", __p, 0x16u);
          }
        }
        *((_DWORD *)a3 + 2238) = 0;
        *((void *)a3 + 1092) = *((void *)a3 + 1091);
      }
    }
    *((_DWORD *)a3 + 2154) = (*(uint64_t (**)(void))(**((void **)a2 + 12) + 1392))(*((void *)a2 + 12));
    *((double *)a3 + 1078) = (*(double (**)(CA::Render::Object *))(*(void *)a2 + 168))(a2);
    uint64_t v32 = *((void *)a2 + 12);
    *(_OWORD *)(a3 + 8632) = *(_OWORD *)(v32 + 168);
    *(_OWORD *)(a3 + 8648) = *(_OWORD *)(v32 + 152);
    *((_DWORD *)a3 + 2166) = *(_DWORD *)(v32 + 624);
    *((_DWORD *)a3 + 2167) = *(_DWORD *)(v32 + 628);
    *((_DWORD *)a3 + 2168) = *(_DWORD *)(v32 + 632);
    *(void *)(a3 + 8676) = *(void *)(v32 + 60);
    uint64_t v33 = (unsigned char *)*((void *)a2 + 12);
    *((_DWORD *)a3 + 217CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v33[657] & 3;
    float v34 = (*(double (**)(unsigned char *))(*(void *)v33 + 16))(v33);
    *((float *)a3 + 2177) = v34;
    float v36 = v35;
    *((float *)a3 + 2178) = v36;
    if (((LOWORD(v4[41].f64[0]) >> 10) & 3 | 4) == 4)
    {
      f64 = (void *)&v4[5].f64[1];
    }
    else
    {
      f64 = (void *)v4[5].f64;
      if (!LODWORD(v4[5].f64[0]) || !HIDWORD(v4[5].f64[0])) {
        f64 = (void *)&v4[4].f64[1];
      }
    }
    *(void *)(a3 + 8716) = *f64;
    *((double *)a3 + 112CA::Context::unref(this[1], 0) = (*(double (**)(float64x2_t *))(*(void *)&v4->f64[0] + 744))(v4);
    *((double *)a3 + 112CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = (*(double (**)(float64x2_t *))(*(void *)&v4->f64[0] + 736))(v4);
    *((double *)a3 + 1122) = (*(double (**)(float64x2_t *))(*(void *)&v4->f64[0] + 760))(v4);
    *((_DWORD *)a3 + 2246) = (*(uint64_t (**)(float64x2_t *))(*(void *)&v4->f64[0] + 768))(v4);
    *((_DWORD *)a3 + 2247) = (*(uint64_t (**)(float64x2_t *))(*(void *)&v4->f64[0] + 784))(v4);
    a3[8992] = (*(uint64_t (**)(float64x2_t *))(*(void *)&v4->f64[0] + 272))(v4);
    *((_DWORD *)a3 + 2249) = (*(uint64_t (**)(float64x2_t *))(*(void *)&v4->f64[0] + 840))(v4);
    *((_DWORD *)a3 + 225CA::Context::unref(this[1], 0) = LOBYTE(v4[41].f64[0]);
    *((void *)a3 + 1126) = (*(uint64_t (**)(float64x2_t *))(*(void *)&v4->f64[0] + 120))(v4);
    *((_DWORD *)a3 + 2254) = (*(uint64_t (**)(float64x2_t *))(*(void *)&v4->f64[0] + 1512))(v4);
    *((float32x2_t *)a3 + 1086) = vcvt_f32_f64(v4[8]);
    float v38 = 1.0 / (*(double (**)(float64x2_t *))(*(void *)&v4->f64[0] + 32))(v4);
    *((float *)a3 + 2174) = v38;
    float v39 = 1.0 / (*(double (**)(float64x2_t *))(*(void *)&v4->f64[0] + 24))(v4);
    *((float *)a3 + 2175) = v39;
    if ((BYTE2(v4[46].f64[1]) & 0x10) != 0)
    {
      float v40 = (float)(unint64_t)(*(uint64_t (**)(float64x2_t *))(*(void *)&v4->f64[0] + 64))(v4);
      if (((LOWORD(v4[41].f64[0]) >> 10) & 3 | 4) == 4)
      {
        double v41 = (int *)&v4[5].f64[1];
      }
      else
      {
        double v41 = (int *)&v4[5];
        if (!LODWORD(v4[5].f64[0]) || !HIDWORD(v4[5].f64[0])) {
          double v41 = (int *)&v4[4].f64[1];
        }
      }
      float v42 = v40 / (float)*v41;
      unint64_t v43 = (*(uint64_t (**)(float64x2_t *))(*(void *)&v4->f64[0] + 72))(v4);
      unint64_t v44 = (*(uint64_t (**)(float64x2_t *))(*(void *)&v4->f64[0] + 64))(v4);
      if (((LOWORD(v4[41].f64[0]) >> 10) & 3 | 4) == 4)
      {
        uint64_t v45 = (float64x2_t *)((char *)v4 + 88);
      }
      else
      {
        uint64_t v45 = v4 + 5;
        if (!LODWORD(v4[5].f64[0]) || !HIDWORD(v4[5].f64[0])) {
          uint64_t v45 = (float64x2_t *)((char *)v4 + 72);
        }
      }
      float v46 = (float)(v43 / v44) / (float)SHIDWORD(v45->f64[0]);
      if (v46 >= v42) {
        float v46 = v42;
      }
      if (v46 >= *((float *)a3 + 2175)) {
        float v46 = *((float *)a3 + 2175);
      }
      *((float *)a3 + 2175) = v46;
    }
    *((_DWORD *)a3 + 2176) = HIDWORD(v4[9].f64[0]);
    memset(__p, 0, 44);
    (*(void (**)(unsigned char *__return_ptr, float64x2_t *))(*(void *)&v4->f64[0] + 1368))(__p, v4);
    *(_OWORD *)(a3 + 902CA::Context::unref(this[1], 0) = *(_OWORD *)__p;
    *((_DWORD *)a3 + 2259) = *(_DWORD *)&__p[16];
    *((_DWORD *)a3 + 226CA::Context::unref(this[1], 0) = __p[20];
    *((_DWORD *)a3 + 226CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(_DWORD *)((unsigned char *)&v4[46].f64[1] + 1) & 1;
    *((_DWORD *)a3 + 2262) = LOWORD(v4[41].f64[0]) >> 13;
    *((_DWORD *)a3 + 2263) = (*(uint64_t (**)(float64x2_t *))(*(void *)&v4->f64[0] + 816))(v4);
    *((_DWORD *)a3 + 2264) = (LOWORD(v4[41].f64[0]) >> 10) & 7;
    *(void *)&long long v47 = vrev64q_s32(*(int32x4_t *)&__p[24]).u64[0];
    *((void *)&v47 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(void *)&__p[32];
    *(_OWORD *)(a3 + 906CA::Context::unref(this[1], 0) = v47;
    *((_DWORD *)a3 + 2269) = *(_DWORD *)&__p[40];
    a3[9080] = (*(uint64_t (**)(float64x2_t *))(*(void *)&v4->f64[0] + 128))(v4);
    memset(v50, 0, 40);
    (*(void (**)(PerModeInfo *__return_ptr, float64x2_t *))(*(void *)&v4->f64[0] + 1376))(v50, v4);
    *(_WORD *)(a3 + 908CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v50[0].var0;
    *((_OWORD *)a3 + 568) = *(_OWORD *)&v50[0].var2;
    *((_OWORD *)a3 + 569) = *(_OWORD *)&v50[2].var0;
    a3[9120] = (*(uint64_t (**)(float64x2_t *))(*(void *)&v4->f64[0] + 288))(v4);
    pthread_mutex_unlock(v7);
  }
}

uint64_t CA::WindowServer::IOMFBDisplay::display_timings_shmem(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 6512;
  os_unfair_lock_lock(this + 6512);
  CA::WindowServer::IOMFBDisplay::initialize_timings((CA::WindowServer::IOMFBDisplay *)this);
  uint64_t v3 = *(void *)&this[6514]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v2);
  return v3;
}

BOOL CA::WindowServer::IOMFBDisplay::force_fixed_display_links(CA::WindowServer::IOMFBDisplay *this)
{
  return *((_DWORD *)this + 6799) != 0;
}

void CA::WindowServer::IOMFBServer::register_frame_interval_range(CA::WindowServer::IOMFBServer *this, CA::Render::Object *a2, unsigned int *a3, void *a4)
{
  uint64_t v4 = *((void *)a2 + 12);
  if ((*(_DWORD *)(v4 + 624) & 0x100) != 0)
  {
    unsigned int v6 = a3[1];
    if ((!v6 || *(_DWORD *)(v4 + 24) == v6) && (*(_WORD *)(v4 + 656) & 0x1C00) == 0)
    {
      CA::WindowServer::IOMFBDisplay::register_frame_interval_range((os_unfair_lock_s *)v4, a3[2], a3[3], a3[4], a3[5], *((unsigned __int8 *)a3 + 24));
      *(unsigned char *)a3 = 1;
    }
  }
}

void CA::WindowServer::IOMFBDisplay::register_frame_interval_range(os_unfair_lock_s *this, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, int a6)
{
  uint64_t v100 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = this + 6849;
  os_unfair_lock_lock(this + 6849);
  if (byte_1EB2ACC45)
  {
    memset(v93, 0, sizeof(v93));
    x_stream_printf((uint64_t)v93, "  Existing clients: %ld\n", v14, v15, v16, v17, v18, v19, 0xAAAAAAAAAAAAAAABLL* ((uint64_t)(*(void *)&this[6852]._os_unfair_lock_opaque - *(void *)&this[6850]._os_unfair_lock_opaque) >> 3));
    uint64_t v88 = *(void *)&this[6850]._os_unfair_lock_opaque;
    for (uint64_t i = *(void *)&this[6852]._os_unfair_lock_opaque; v88 != i; v88 += 24)
      x_stream_printf((uint64_t)v93, "    %s[%d]: %u %u %u%s%s\n", v82, v83, v84, v85, v86, v87, (uint64_t)"");
    long long v90 = x_stream_finish((uint64_t)v93);
    if (v90)
    {
      long long v91 = v90;
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v92 = x_log_category_frame_rate;
        if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67110402;
          *(_DWORD *)&uint8_t buf[4] = a3;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = a4;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)double v95 = a5;
          *(_WORD *)&v95[4] = 1024;
          *(_DWORD *)&v95[6] = a6;
          __int16 v96 = 1024;
          int v97 = a2;
          __int16 v98 = 2080;
          uint64_t v99 = v91;
          _os_log_impl(&dword_184668000, v92, OS_LOG_TYPE_DEFAULT, "CAFrameRateServer: register_frame_interval_range %u %u %u (%d) from %d\n%s", buf, 0x2Au);
        }
      }
      free(v91);
    }
  }
  unint64_t v20 = *(uint8_t **)&this[6852]._os_unfair_lock_opaque;
  unint64_t v21 = *(uint8_t **)&this[6850]._os_unfair_lock_opaque;
  unint64_t v22 = (v20 - v21) / 24;
  if (v20 == v21)
  {
LABEL_9:
    if (v22 >= 0x40)
    {
      if (x_log_hook_p()) {
        goto LABEL_59;
      }
      uint64_t v54 = x_log_category_frame_rate;
      if (!os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_95;
      }
      *(_WORD *)long long buf = 0;
      float64x2_t v55 = "CAFrameRateServer: too many requests!";
      float64x2_t v56 = v54;
      os_log_type_t v57 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_73;
    }
    if (!a3)
    {
      if (x_log_hook_p())
      {
LABEL_59:
        x_log_();
        goto LABEL_95;
      }
      uint64_t v64 = x_log_category_frame_rate;
      if (!os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_ERROR)) {
        goto LABEL_95;
      }
      *(_WORD *)long long buf = 0;
      float64x2_t v55 = "CAFrameRateServer: invalid interval";
      float64x2_t v56 = v64;
      os_log_type_t v57 = OS_LOG_TYPE_ERROR;
LABEL_73:
      _os_log_impl(&dword_184668000, v56, v57, v55, buf, 2u);
      goto LABEL_95;
    }
    *(_DWORD *)long long buf = a2;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_DWORD *)&uint8_t buf[8] = a3;
    *(_DWORD *)&buf[12] = a4;
    *(void *)double v95 = a5;
    if (a6) {
      char v26 = 2;
    }
    else {
      char v26 = 0;
    }
    v95[4] = v26;
    if (a2)
    {
      [(CAProcessMonitor *)CA::WindowServer::IOMFBDisplay::process_monitor((CA::WindowServer::IOMFBDisplay *)this) addMonitoringProcess:a2];
      unint64_t v21 = *(uint8_t **)&this[6850]._os_unfair_lock_opaque;
      unint64_t v20 = *(uint8_t **)&this[6852]._os_unfair_lock_opaque;
    }
    unint64_t v27 = (unint64_t)v20;
    uint64_t v28 = v20 - v21;
    if (v20 == v21)
    {
LABEL_29:
      unint64_t v36 = *(void *)&this[6854]._os_unfair_lock_opaque;
      if (v27 >= v36)
      {
        unint64_t v59 = 0xAAAAAAAAAAAAAAABLL * (v28 >> 3) + 1;
        if (v59 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        int64_t v60 = 0xAAAAAAAAAAAAAAABLL * ((v20 - v21) >> 3);
        unint64_t v61 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v36 - (void)v21) >> 3);
        if (2 * v61 > v59) {
          unint64_t v59 = 2 * v61;
        }
        if (v61 >= 0x555555555555555) {
          unint64_t v62 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v62 = v59;
        }
        if (v62)
        {
          long long v63 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v62);
        }
        else
        {
          long long v63 = 0;
          uint64_t v13 = 0;
        }
        long long v66 = &v63[8 * ((v20 - v21) >> 3)];
        long long v67 = &v63[24 * v13];
        if (v60 == v13)
        {
          if (v20 - v21 < 1)
          {
            if (v20 == v21) {
              unint64_t v69 = 1;
            }
            else {
              unint64_t v69 = 0x5555555555555556 * ((v20 - v21) >> 3);
            }
            unint64_t v70 = v69 >> 2;
            float64x2_t v71 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v69);
            long long v66 = &v71[24 * v70];
            long long v67 = &v71[24 * v13];
            if (v63) {
              operator delete(v63);
            }
          }
          else
          {
            uint64_t v68 = v60 + 2;
            if (v60 >= -1) {
              uint64_t v68 = v60 + 1;
            }
            v66 -= 24 * (v68 >> 1);
          }
        }
        long long v72 = *(_OWORD *)buf;
        *((void *)v66 + 2) = *(void *)v95;
        *(_OWORD *)long long v66 = v72;
        uint64_t v73 = *(uint8_t **)&this[6850]._os_unfair_lock_opaque;
        uint64_t v74 = v66;
        if (v73 != v20)
        {
          float64x2_t v75 = v20;
          float64x2_t v76 = v66;
          do
          {
            long long v77 = *(_OWORD *)(v75 - 24);
            uint64_t v74 = v76 - 24;
            *((void *)v76 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *((void *)v75 - 1);
            *(_OWORD *)(v76 - 24) = v77;
            v75 -= 24;
            v76 -= 24;
          }
          while (v75 != v73);
        }
        float64x2_t v78 = v66 + 24;
        float64x2_t v79 = *(char **)&this[6852]._os_unfair_lock_opaque;
        int64_t v80 = v79 - (char *)v20;
        if (v79 != (char *)v20) {
          memmove(v78, v20, v79 - (char *)v20);
        }
        float64x2_t v81 = *(void **)&this[6850]._os_unfair_lock_opaque;
        *(void *)&this[6850]._uint32_t os_unfair_lock_opaque = v74;
        *(void *)&this[6852]._uint32_t os_unfair_lock_opaque = &v78[v80];
        *(void *)&this[6854]._uint32_t os_unfair_lock_opaque = v67;
        if (v81) {
          operator delete(v81);
        }
        goto LABEL_94;
      }
      if (v20 != (uint8_t *)v27)
      {
        uint64_t v37 = v20 + 24;
        unint64_t v38 = v27 - 24;
        unint64_t v39 = v27;
        if (v27 >= 0x18)
        {
          unint64_t v39 = v27;
          do
          {
            long long v40 = *(_OWORD *)v38;
            *(void *)(v39 + 16) = *(void *)(v38 + 16);
            *(_OWORD *)unint64_t v39 = v40;
            v39 += 24;
            v38 += 24;
          }
          while (v38 < v27);
        }
        *(void *)&this[6852]._uint32_t os_unfair_lock_opaque = v39;
        if ((void *)v27 != v37) {
          memmove(v20 + 24, v20, v27 - (void)v37);
        }
        double v41 = buf;
        if (v20 <= buf) {
          double v41 = &buf[24 * (*(void *)&this[6852]._os_unfair_lock_opaque > (unint64_t)buf)];
        }
        long long v42 = *(_OWORD *)v41;
        *((void *)v20 + 2) = *((void *)v41 + 2);
        *(_OWORD *)unint64_t v20 = v42;
        goto LABEL_94;
      }
      long long v65 = *(_OWORD *)buf;
      *(void *)(v27 + 16) = *(void *)v95;
      *(_OWORD *)unint64_t v27 = v65;
      float64x2_t v58 = (uint8_t *)(v27 + 24);
      goto LABEL_75;
    }
    unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((v20 - v21) >> 3);
    unint64_t v20 = v21;
    while (1)
    {
      unint64_t v30 = v29 >> 1;
      uint64_t v31 = &v20[24 * (v29 >> 1)];
      unsigned int v32 = *((_DWORD *)v31 + 2);
      if (v32 <= a3)
      {
        if (v32 != a3) {
          goto LABEL_27;
        }
        unsigned int v33 = *(_DWORD *)&v20[24 * v30 + 12];
        if (v33 <= a4) {
          break;
        }
      }
LABEL_28:
      unint64_t v29 = v30;
      if (!v30) {
        goto LABEL_29;
      }
    }
    if (v33 == a4)
    {
      unint64_t v34 = v29 + ~v30;
      double v35 = v31 + 24;
      if (*(_DWORD *)&v20[24 * v30 + 16] <= a5)
      {
        unint64_t v20 = v35;
        unint64_t v30 = v34;
      }
      goto LABEL_28;
    }
LABEL_27:
    unint64_t v20 = v31 + 24;
    unint64_t v30 = v29 + ~v30;
    goto LABEL_28;
  }
  uint64_t v23 = 0;
  if (v22 <= 1) {
    uint64_t v24 = 1;
  }
  else {
    uint64_t v24 = (v20 - v21) / 24;
  }
  uint64_t v25 = *(char **)&this[6850]._os_unfair_lock_opaque;
  while (*(_DWORD *)v25 != a2)
  {
    ++v23;
    v25 += 24;
    if (v24 == v23) {
      goto LABEL_9;
    }
  }
  if (!a3)
  {
    uint64_t v13 = (uint64_t)(v25 + 24);
    if (v20 != (uint8_t *)(v25 + 24)) {
      memmove(v25, (const void *)v13, v20 - (uint8_t *)(v25 + 24));
    }
    float64x2_t v58 = v20 - 24;
LABEL_75:
    *(void *)&this[6852]._uint32_t os_unfair_lock_opaque = v58;
LABEL_94:
    CA::WindowServer::IOMFBDisplay::recompute_server_frame_interval_locked((CA::WindowServer::IOMFBDisplay *)this, v13, v14, v15, v16, v17, v18, v19);
    goto LABEL_95;
  }
  unint64_t v43 = &v21[24 * v23];
  int v45 = *((_DWORD *)v43 + 2);
  unint64_t v44 = v43 + 8;
  char v46 = *((unsigned char *)v44 + 12);
  BOOL v48 = v45 == a3 && *((_DWORD *)v44 + 1) == a4 && *((_DWORD *)v44 + 2) == a5;
  if (!v48 || ((((v46 & 2) == 0) ^ a6) & 1) == 0)
  {
    if (a6) {
      char v49 = 2;
    }
    else {
      char v49 = 0;
    }
    *((unsigned char *)v44 + 12) = v46 & 0xFD | v49;
    unint64_t v50 = *(void *)&this[6850]._os_unfair_lock_opaque;
    unint64_t v51 = *(void *)&this[6852]._os_unfair_lock_opaque;
    unint64_t v52 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v51 - v50) >> 3));
    *(_DWORD *)unint64_t v44 = a3;
    *((_DWORD *)v44 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = a4;
    *((_DWORD *)v44 + 2) = a5;
    *(void *)long long buf = CA::FrameRateArbitrator::RangeSorter<CAFrameIntervalRequest>;
    if (v51 == v50) {
      uint64_t v53 = 0;
    }
    else {
      uint64_t v53 = v52;
    }
    std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*,false>(v50, v51, (uint64_t (**)(long long *, long long *))buf, v53, 1);
    goto LABEL_94;
  }
LABEL_95:
  os_unfair_lock_unlock(v12);
}

void CA::WindowServer::IOMFBDisplay::recompute_server_frame_interval_locked(CA::WindowServer::IOMFBDisplay *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v137 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *((void *)this + 3425);
  uint64_t v10 = *((void *)this + 3426);
  if (v9 == v10)
  {
LABEL_5:
    unsigned int v14 = 0;
    goto LABEL_6;
  }
  uint64_t v11 = v10 - v9;
  if (v11 == 24)
  {
    if ((*(unsigned char *)(v9 + 20) & 1) == 0)
    {
      unsigned int v13 = *(_DWORD *)(v9 + 8);
      LODWORD(v12) = *(_DWORD *)(v9 + 12);
      unsigned int v14 = *(_DWORD *)(v9 + 16);
      goto LABEL_92;
    }
    goto LABEL_5;
  }
  uint64_t v18 = (unsigned __int128)(v11 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
  unint64_t v126 = 0;
  unint64_t v127 = 0;
  uint64_t v128 = 0;
  if (initialized != -1)
  {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  unint64_t v20 = (v18 >> 2) + ((unint64_t)v18 >> 63);
  unint64_t v21 = &CA::callback_timer;
  if (byte_1EB2ACC45)
  {
    unint64_t v126 = 0;
    unint64_t v127 = 0;
    uint64_t v128 = 0;
  }
  uint64_t v22 = 0;
  unsigned int v13 = 0;
  LODWORD(v23) = 0;
  BOOL v24 = 0;
  if (v20 <= 1) {
    uint64_t v25 = 1;
  }
  else {
    uint64_t v25 = (v18 >> 2) + ((unint64_t)v18 >> 63);
  }
  uint64_t v12 = 0xFFFFFFFFLL;
  char v26 = "    update result: %u %u\n";
  unint64_t v27 = &initialized;
  uint64_t v28 = v25;
  LODWORD(v29) = -1;
  unint64_t v30 = "  candidate: %u %u %u\n";
  while (1)
  {
    uint64_t v31 = *((void *)this + 3425) + v22;
    if ((*(unsigned char *)(v31 + 20) & 1) == 0) {
      break;
    }
LABEL_60:
    v22 += 24;
    if (!--v28) {
      goto LABEL_61;
    }
  }
  unsigned int v33 = *(_DWORD *)(v31 + 8);
  unsigned int v32 = *(_DWORD *)(v31 + 12);
  BOOL v24 = v33 == 4 && v32 == 5;
  if (v33 > 3)
  {
    if (v33 == 4)
    {
      if (v32 < 6) {
        unsigned int v33 = 4;
      }
      else {
        unsigned int v33 = 3;
      }
    }
  }
  else if (v32 > 3)
  {
    unsigned int v33 = 2;
  }
  if (v32 > 3 && *(_DWORD *)(v31 + 16) == 2) {
    unsigned int v36 = 3;
  }
  else {
    unsigned int v36 = *(_DWORD *)(v31 + 12);
  }
  if (v19[186] != -1)
  {
    uint64_t v115 = v12;
    unint64_t v122 = v20;
    BOOL v118 = v24;
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    unint64_t v30 = "  candidate: %u %u %u\n";
    unint64_t v27 = &initialized;
    char v26 = "    update result: %u %u\n";
    BOOL v24 = v118;
    unint64_t v21 = &CA::callback_timer;
    unint64_t v20 = v122;
    uint64_t v12 = v115;
  }
  if (*((unsigned char *)v21 + 3141))
  {
    uint64_t v116 = v12;
    uint64_t v114 = *(unsigned int *)(v31 + 8);
    uint64_t v37 = v30;
    unint64_t v123 = v20;
    BOOL v119 = v24;
    x_stream_printf((uint64_t)&v126, v30, a3, a4, a5, a6, a7, a8, v114);
    unint64_t v30 = v37;
    unint64_t v27 = &initialized;
    char v26 = "    update result: %u %u\n";
    BOOL v24 = v119;
    unint64_t v21 = &CA::callback_timer;
    unint64_t v20 = v123;
    uint64_t v12 = v116;
  }
  if (v23 <= v33) {
    uint64_t v23 = v33;
  }
  else {
    uint64_t v23 = v23;
  }
  if (v29 >= v36) {
    uint64_t v29 = v36;
  }
  else {
    uint64_t v29 = v29;
  }
  if (v23 <= v29)
  {
    if (v19[186] != -1)
    {
      unint64_t v38 = v27;
      unint64_t v124 = v20;
      unint64_t v39 = v19;
      long long v40 = v21;
      BOOL v41 = v24;
      dispatch_once_f(v27, 0, (dispatch_function_t)init_debug);
      unint64_t v30 = "  candidate: %u %u %u\n";
      unint64_t v27 = v38;
      char v26 = "    update result: %u %u\n";
      BOOL v24 = v41;
      unint64_t v21 = v40;
      uint64_t v19 = v39;
      unint64_t v20 = v124;
    }
    if (*((unsigned char *)v21 + 3141))
    {
      long long v42 = v26;
      unint64_t v125 = v20;
      unint64_t v43 = v19;
      unint64_t v44 = v21;
      BOOL v45 = v24;
      x_stream_printf((uint64_t)&v126, v26, a3, a4, a5, a6, a7, a8, v23);
      unint64_t v30 = "  candidate: %u %u %u\n";
      unint64_t v27 = &initialized;
      char v26 = v42;
      BOOL v24 = v45;
      unint64_t v21 = v44;
      uint64_t v19 = v43;
      unint64_t v20 = v125;
    }
    unsigned int v13 = v23;
    uint64_t v12 = v29;
    goto LABEL_60;
  }
LABEL_61:
  if (!v13 && v12 == -1)
  {
    unsigned int v13 = 0;
    LODWORD(v12) = 0;
    unsigned int v14 = 0;
  }
  else
  {
    uint64_t v46 = 0;
    unsigned int v14 = 0;
    long long v47 = "  explicit preference for %u\n";
    do
    {
      uint64_t v48 = *((void *)this + 3425) + v46;
      if ((*(unsigned char *)(v48 + 20) & 1) == 0)
      {
        uint64_t v49 = *(unsigned int *)(v48 + 16);
        BOOL v50 = v49 < v13 || v49 > v12;
        if (!v50 && v14 - 1 >= v49)
        {
          if (v19[186] != -1)
          {
            uint64_t v52 = v12;
            unint64_t v53 = v20;
            uint64_t v54 = v19;
            float64x2_t v55 = v21;
            BOOL v120 = v24;
            dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
            long long v47 = "  explicit preference for %u\n";
            BOOL v24 = v120;
            unint64_t v21 = v55;
            uint64_t v19 = v54;
            unint64_t v20 = v53;
            uint64_t v12 = v52;
          }
          if (*((unsigned char *)v21 + 3141))
          {
            float64x2_t v56 = v47;
            uint64_t v117 = v12;
            unint64_t v57 = v20;
            float64x2_t v58 = v19;
            unint64_t v59 = v21;
            BOOL v121 = v24;
            x_stream_printf((uint64_t)&v126, v47, a3, a4, a5, a6, a7, a8, v49);
            long long v47 = v56;
            BOOL v24 = v121;
            unint64_t v21 = v59;
            uint64_t v19 = v58;
            unint64_t v20 = v57;
            uint64_t v12 = v117;
          }
          unsigned int v14 = v49;
        }
      }
      v46 += 24;
      --v25;
    }
    while (v25);
    if (v24)
    {
      BOOL v60 = v13 == 3 && v14 == 0;
      BOOL v61 = v60;
      if (v14 == 3 || v61)
      {
        unsigned int v13 = 2;
        LODWORD(v12) = 2;
        unsigned int v14 = 2;
      }
    }
    if (v19[186] != -1)
    {
      int v105 = v12;
      unint64_t v106 = v20;
      float v107 = v21;
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
      unint64_t v21 = v107;
      unint64_t v20 = v106;
      LODWORD(v12) = v105;
    }
    if (*((unsigned char *)v21 + 3141))
    {
      unint64_t v108 = v20;
      int v109 = v12;
      int v110 = x_stream_finish((uint64_t)&v126);
      if (v110)
      {
        double v111 = v110;
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          uint64_t v113 = x_log_category_frame_rate;
          if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 136316418;
            *(void *)&uint8_t buf[4] = "CAFrameRateServer: ";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v108;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = v13;
            __int16 v131 = 1024;
            int v132 = v109;
            __int16 v133 = 1024;
            unsigned int v134 = v14;
            __int16 v135 = 2080;
            uint64_t v136 = v111;
            _os_log_impl(&dword_184668000, v113, OS_LOG_TYPE_DEFAULT, "%sarbitration among %ld clients yields min:%u max:%u preferred:%u\n%s", buf, 0x32u);
          }
        }
        free(v111);
      }
      LODWORD(v12) = v109;
    }
  }
LABEL_92:
  if (v13 && !v14)
  {
    if ((*((_DWORD *)this + 156) & 0x10) != 0)
    {
      unsigned int v103 = v12;
      int v104 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 768))(this);
      unsigned int v14 = v13;
      if (v104 != (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 784))(this))
      {
        unsigned int v14 = v103;
        if ((*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 784))(this) <= v103) {
          unsigned int v14 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 784))(this);
        }
      }
    }
    else
    {
      unsigned int v14 = v13;
    }
  }
LABEL_6:
  os_unfair_lock_lock((os_unfair_lock_t)this + 6512);
  double v15 = CA::WindowServer::IOMFBDisplay::initialize_timings(this);
  if (*((void *)this + 3258))
  {
    if (v14)
    {
      if (v14 <= (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *, double))(*(void *)this + 768))(this, v15))unsigned int v14 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 768))(this); {
      if (v14 == 10)
      }
        int v16 = 5;
      else {
        int v16 = 4;
      }
      if (v14 >= 6) {
        unsigned int v17 = v16;
      }
      else {
        unsigned int v17 = v14;
      }
    }
    else
    {
      unsigned int v17 = 0;
    }
    if ((*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 768))(this) == 1)
    {
      BOOL v62 = 0;
    }
    else
    {
      uint64_t v63 = *((void *)this + 3425);
      uint64_t v64 = *((void *)this + 3426);
      if (v63 != v64)
      {
        while ((*(unsigned char *)(v63 + 20) & 3) != 2)
        {
          v63 += 24;
          if (v63 == v64) {
            goto LABEL_105;
          }
        }
      }
      if (v63 == v64) {
LABEL_105:
      }
        BOOL v62 = *((unsigned char *)this + 28214) != 0;
      else {
        BOOL v62 = 1;
      }
    }
    uint64_t v65 = mach_absolute_time();
    unint64_t v129 = 0;
    unint64_t v66 = atomic_load((unint64_t *)(*((void *)this + 3258) + 24));
    unint64_t v129 = v66;
    CA::WindowServer::IOMFBDisplay::flush_timings_locked(this, v65, &v129);
    uint64_t v67 = *((void *)this + 3258);
    if (v129)
    {
      unsigned int v68 = atomic_load((unsigned int *)(v67 + 40));
      if (v68 == v17)
      {
        unint64_t v69 = (unsigned __int8 *)(*((void *)this + 3258) + 33);
        goto LABEL_111;
      }
      goto LABEL_112;
    }
    unsigned int v70 = atomic_load((unsigned int *)(v67 + 36));
    if (v70 != v17) {
      goto LABEL_112;
    }
    unint64_t v69 = (unsigned __int8 *)(*((void *)this + 3258) + 32);
LABEL_111:
    unsigned __int8 v71 = atomic_load(v69);
    if (((((v71 & 1) == 0) ^ v62) & 1) == 0)
    {
LABEL_112:
      uint64_t v72 = *((void *)this + 3258);
      if (v129)
      {
        uint64_t v73 = (unint64_t *)(v72 + 56);
      }
      else
      {
        unsigned int v74 = atomic_load((unsigned int *)(v72 + 36));
        if (!v74) {
          unsigned int v74 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 784))(this);
        }
        unsigned int v75 = v74;
        if (v74 == 2 && v17 == 4) {
          unsigned int v75 = 4;
        }
        unsigned int v77 = atomic_load((unsigned int *)(*((void *)this + 3258) + 4));
        unint64_t v78 = v75 * (unint64_t)v77;
        unint64_t v79 = atomic_load((unint64_t *)(*((void *)this + 3258) + 48));
        unint64_t v80 = atomic_load((unint64_t *)(*((void *)this + 3258) + 64));
        uint64_t v81 = atomic_load((unsigned int *)(*((void *)this + 3258) + 4));
        unint64_t v126 = v79;
        unint64_t v127 = v80;
        uint64_t v128 = v81;
        unint64_t v82 = atomic_load((unsigned int *)(*((void *)this + 3258) + 4));
        unint64_t v83 = v65 + (v82 >> 1);
        *(void *)long long buf = v78;
        unint64_t phase = get_phase(&v126, v83, (unint64_t *)buf);
        unint64_t v85 = v83 - phase + *(void *)buf;
        if (!phase) {
          unint64_t v85 = v83;
        }
        unint64_t v129 = v85;
        unint64_t v86 = atomic_load((unsigned int *)(*((void *)this + 3258) + 4));
        v129 -= v86 >> 3;
        uint64_t v73 = (unint64_t *)(*((void *)this + 3258) + 48);
      }
      unint64_t v87 = atomic_load(v73);
      unsigned int v88 = atomic_load((unsigned int *)(*((void *)this + 3258) + 36));
      unsigned int v89 = atomic_load((unsigned int *)(*((void *)this + 3258) + 40));
      unsigned __int8 v90 = atomic_load((unsigned __int8 *)(*((void *)this + 3258) + 32));
      unsigned __int8 v91 = atomic_load((unsigned __int8 *)(*((void *)this + 3258) + 33));
      int v92 = ((v90 & 1) == 0) ^ v62;
      if (v88 != v17 || v92 == 0)
      {
        BOOL v94 = (v91 & 1) == 0;
        if (v89 != v17 || ((v94 ^ v62) & 1) == 0)
        {
          unsigned int v95 = v17;
          if (!v17) {
            unsigned int v95 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 784))(this);
          }
          unint64_t v96 = v129;
          unint64_t v97 = atomic_load((unint64_t *)(*((void *)this + 3258) + 64));
          double v98 = (double)(v96 - v97);
          LODWORD(v96) = atomic_load((unsigned int *)(*((void *)this + 3258) + 4));
          unint64_t v99 = (v87 + vcvtad_u64_f64(v98 / (double)v96)) % v95;
          if (v99) {
            unint64_t v100 = v95 - v99;
          }
          else {
            unint64_t v100 = 0;
          }
          v87 += v100;
        }
      }
      else
      {
        unint64_t v129 = 0;
      }
      if (byte_1EB2ACC45)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          double v112 = x_log_category_frame_rate;
          if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109632;
            *(_DWORD *)&uint8_t buf[4] = v17;
            *(_WORD *)&uint8_t buf[8] = 2048;
            *(void *)&buf[10] = v129;
            *(_WORD *)&buf[18] = 2048;
            *(void *)&buf[20] = v65;
            _os_log_impl(&dword_184668000, v112, OS_LOG_TYPE_DEFAULT, "CAFrameRateServer: enqueing server frame interval %u for %llu. Now is %llu", buf, 0x1Cu);
          }
        }
      }
      uint64_t v101 = *((void *)this + 3258);
      unsigned int add = atomic_fetch_add((atomic_uint *volatile)(v101 + 16), 1u);
      atomic_store(v129, (unint64_t *)(v101 + 24));
      atomic_store(v62, (unsigned __int8 *)(v101 + 33));
      atomic_store(v17, (unsigned int *)(v101 + 40));
      atomic_store(v87, (unint64_t *)(v101 + 56));
      atomic_store(add + 2, (unsigned int *)(v101 + 16));
      atomic_load((unsigned __int8 *)(*((void *)this + 3258) + 32));
      atomic_load((unsigned __int8 *)(*((void *)this + 3258) + 33));
      atomic_load((unint64_t *)(*((void *)this + 3258) + 24));
      atomic_load((unsigned int *)(*((void *)this + 3258) + 36));
      atomic_load((unsigned int *)(*((void *)this + 3258) + 40));
      kdebug_trace();
      atomic_load((unint64_t *)(*((void *)this + 3258) + 48));
      atomic_load((unint64_t *)(*((void *)this + 3258) + 64));
      atomic_load((unint64_t *)(*((void *)this + 3258) + 56));
      kdebug_trace();
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)this + 6512);
}

uint64_t CA::WindowServer::AppleInternalDisplay::preferred_frame_duration(CA::WindowServer::AppleInternalDisplay *this)
{
  if ((*((_DWORD *)this + 156) & 0x100) != 0) {
    return 4;
  }
  else {
    return (*(uint64_t (**)(void))(*(void *)this + 768))();
  }
}

void *CA::WindowServer::IOMFBDisplay::flush_timings_locked(void *this, unint64_t a2, unint64_t *a3)
{
  if (*a3) {
    BOOL v3 = *a3 >= a2;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    unint64_t v4 = atomic_load((unint64_t *)(this[3258] + 56));
    unsigned __int8 v5 = atomic_load((unsigned __int8 *)(this[3258] + 33));
    unsigned int v6 = atomic_load((unsigned int *)(this[3258] + 40));
    *a3 = 0;
    uint64_t v7 = this[3258];
    unsigned int add = atomic_fetch_add((atomic_uint *volatile)(v7 + 16), 1u);
    atomic_store(*a3, (unint64_t *)(v7 + 24));
    atomic_store(v5 & 1, (unsigned __int8 *)(v7 + 32));
    atomic_store(v6, (unsigned int *)(v7 + 36));
    atomic_store(v4, (unint64_t *)(v7 + 48));
    atomic_store(add + 2, (unsigned int *)(v7 + 16));
    unint64_t v9 = atomic_load((unint64_t *)(this[3258] + 56));
    this[3262] = v9;
    unint64_t v10 = atomic_load((unint64_t *)(this[3258] + 64));
    this[3263] = v10;
  }
  return this;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*,false>(unint64_t a1, unint64_t a2, uint64_t (**a3)(long long *, long long *), uint64_t a4, char a5)
{
  uint64_t v102 = *MEMORY[0x1E4F143B8];
  while (2)
  {
    uint64_t v94 = a2;
    uint64_t v96 = a2 - 24;
    int v92 = (long long *)(a2 - 72);
    long long v93 = (long long *)(a2 - 48);
    unint64_t v12 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v12;
          uint64_t v13 = a2 - v12;
          unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * (v13 >> 3);
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if ((*a3)((long long *)v96, (long long *)a1))
                {
                  long long v41 = *(_OWORD *)a1;
                  uint64_t v101 = *(void *)(a1 + 16);
                  long long v100 = v41;
                  long long v42 = *(_OWORD *)v96;
                  *(void *)(a1 + 16) = *(void *)(v96 + 16);
                  *(_OWORD *)a1 = v42;
                  long long v43 = v100;
                  *(void *)(v96 + 16) = v101;
                  *(_OWORD *)uint64_t v96 = v43;
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*>((long long *)a1, (long long *)(a1 + 24), (long long *)v96, a3);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*>(a1, a1 + 24, a1 + 48, v96, a3);
                break;
              case 5uLL:
                std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*>((__n128 *)a1, a1 + 24, a1 + 48, a1 + 72, v96, a3);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v13 <= 575)
          {
            unint64_t v44 = (long long *)(a1 + 24);
            BOOL v46 = a1 == a2 || v44 == (long long *)a2;
            if (a5)
            {
              if (!v46)
              {
                uint64_t v47 = 0;
                unint64_t v48 = a1;
                do
                {
                  uint64_t v49 = (long long *)v48;
                  unint64_t v48 = (unint64_t)v44;
                  if ((*a3)(v44, v49))
                  {
                    long long v50 = *(_OWORD *)v48;
                    uint64_t v101 = *(void *)(v48 + 16);
                    long long v100 = v50;
                    uint64_t v51 = v47;
                    while (1)
                    {
                      uint64_t v52 = a1 + v51;
                      *(_OWORD *)(v52 + 24) = *(_OWORD *)(a1 + v51);
                      *(void *)(v52 + 4CA::Context::unref(this[1], 0) = *(void *)(a1 + v51 + 16);
                      if (!v51) {
                        break;
                      }
                      v51 -= 24;
                      if (((*a3)(&v100, (long long *)(v51 + a1)) & 1) == 0)
                      {
                        uint64_t v53 = a1 + v51 + 24;
                        goto LABEL_79;
                      }
                    }
                    uint64_t v53 = a1;
LABEL_79:
                    long long v54 = v100;
                    *(void *)(v53 + 16) = v101;
                    *(_OWORD *)uint64_t v53 = v54;
                  }
                  unint64_t v44 = (long long *)(v48 + 24);
                  v47 += 24;
                }
                while (v48 + 24 != a2);
              }
            }
            else if (!v46)
            {
              do
              {
                unint64_t v86 = (long long *)a1;
                a1 = (unint64_t)v44;
                if ((*a3)(v44, v86))
                {
                  long long v87 = *(_OWORD *)a1;
                  uint64_t v101 = *(void *)(a1 + 16);
                  long long v100 = v87;
                  unint64_t v88 = a1;
                  do
                  {
                    unint64_t v89 = v88 - 24;
                    *(_OWORD *)unint64_t v88 = *(_OWORD *)(v88 - 24);
                    *(void *)(v88 + 16) = *(void *)(v88 - 8);
                    char v90 = (*a3)(&v100, (long long *)(v88 - 48));
                    unint64_t v88 = v89;
                  }
                  while ((v90 & 1) != 0);
                  long long v91 = v100;
                  *(void *)(v89 + 16) = v101;
                  *(_OWORD *)unint64_t v89 = v91;
                }
                unint64_t v44 = (long long *)(a1 + 24);
              }
              while (a1 + 24 != a2);
            }
            return;
          }
          if (!a4)
          {
            if (a1 != a2)
            {
              int64_t v55 = (v14 - 2) >> 1;
              int64_t v97 = v55;
              do
              {
                int64_t v56 = v55;
                if (v97 >= v55)
                {
                  uint64_t v57 = (2 * v55) | 1;
                  unint64_t v58 = a1 + 24 * v57;
                  if (2 * v55 + 2 < (uint64_t)v14
                    && (*a3)((long long *)(a1 + 24 * v57), (long long *)(v58 + 24)))
                  {
                    v58 += 24;
                    uint64_t v57 = 2 * v56 + 2;
                  }
                  unint64_t v59 = a1 + 24 * v56;
                  if (((*a3)((long long *)v58, (long long *)v59) & 1) == 0)
                  {
                    long long v60 = *(_OWORD *)v59;
                    uint64_t v101 = *(void *)(v59 + 16);
                    long long v100 = v60;
                    do
                    {
                      unint64_t v61 = v58;
                      long long v62 = *(_OWORD *)v58;
                      *(void *)(v59 + 16) = *(void *)(v58 + 16);
                      *(_OWORD *)unint64_t v59 = v62;
                      if (v97 < v57) {
                        break;
                      }
                      uint64_t v63 = (2 * v57) | 1;
                      unint64_t v58 = a1 + 24 * v63;
                      uint64_t v64 = 2 * v57 + 2;
                      if (v64 < (uint64_t)v14
                        && (*a3)((long long *)(a1 + 24 * v63), (long long *)(v58 + 24)))
                      {
                        v58 += 24;
                        uint64_t v63 = v64;
                      }
                      unint64_t v59 = v61;
                      uint64_t v57 = v63;
                    }
                    while (!(*a3)((long long *)v58, &v100));
                    long long v65 = v100;
                    *(void *)(v61 + 16) = v101;
                    *(_OWORD *)unint64_t v61 = v65;
                  }
                }
                int64_t v55 = v56 - 1;
              }
              while (v56);
              int64_t v66 = v13 / 0x18uLL;
              uint64_t v67 = (_OWORD *)v94;
              do
              {
                unsigned int v95 = v67;
                uint64_t v68 = 0;
                long long v69 = *(_OWORD *)a1;
                uint64_t v99 = *(void *)(a1 + 16);
                long long v98 = v69;
                unint64_t v70 = a1;
                do
                {
                  uint64_t v71 = v70 + 24 * v68 + 24;
                  uint64_t v72 = (2 * v68) | 1;
                  uint64_t v73 = 2 * v68 + 2;
                  if (v73 < v66
                    && (*a3)((long long *)(v70 + 24 * v68 + 24), (long long *)(v70 + 24 * v68 + 48)))
                  {
                    v71 += 24;
                    uint64_t v72 = v73;
                  }
                  long long v74 = *(_OWORD *)v71;
                  *(void *)(v70 + 16) = *(void *)(v71 + 16);
                  *(_OWORD *)unint64_t v70 = v74;
                  unint64_t v70 = v71;
                  uint64_t v68 = v72;
                }
                while (v72 <= (uint64_t)((unint64_t)(v66 - 2) >> 1));
                uint64_t v67 = (_OWORD *)((char *)v95 - 24);
                if ((_OWORD *)v71 == (_OWORD *)((char *)v95 - 24))
                {
                  long long v84 = v98;
                  *(void *)(v71 + 16) = v99;
                  *(_OWORD *)uint64_t v71 = v84;
                }
                else
                {
                  long long v75 = *v67;
                  *(void *)(v71 + 16) = *((void *)v95 - 1);
                  *(_OWORD *)uint64_t v71 = v75;
                  long long v76 = v98;
                  *((void *)v95 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v99;
                  *uint64_t v67 = v76;
                  uint64_t v77 = v71 - a1 + 24;
                  if (v77 >= 25)
                  {
                    unint64_t v78 = (unint64_t)(-2 - 0x5555555555555555 * (v77 >> 3)) >> 1;
                    unint64_t v79 = a1 + 24 * v78;
                    if ((*a3)((long long *)v79, (long long *)v71))
                    {
                      long long v80 = *(_OWORD *)v71;
                      uint64_t v101 = *(void *)(v71 + 16);
                      long long v100 = v80;
                      do
                      {
                        uint64_t v81 = v79;
                        long long v82 = *(_OWORD *)v79;
                        *(void *)(v71 + 16) = *(void *)(v79 + 16);
                        *(_OWORD *)uint64_t v71 = v82;
                        if (!v78) {
                          break;
                        }
                        unint64_t v78 = (v78 - 1) >> 1;
                        unint64_t v79 = a1 + 24 * v78;
                        uint64_t v71 = v81;
                      }
                      while (((*a3)((long long *)v79, &v100) & 1) != 0);
                      long long v83 = v100;
                      *(void *)(v81 + 16) = v101;
                      *(_OWORD *)uint64_t v81 = v83;
                    }
                  }
                }
              }
              while (v66-- > 2);
            }
            return;
          }
          unint64_t v15 = a1 + 24 * (v14 >> 1);
          if ((unint64_t)v13 >= 0xC01)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*>((long long *)a1, (long long *)(a1 + 24 * (v14 >> 1)), (long long *)v96, a3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*>((long long *)(a1 + 24), (long long *)(a1 + 24 * (v14 >> 1) - 24), v93, a3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*>((long long *)(a1 + 48), (long long *)(a1 + 24 + 24 * (v14 >> 1)), v92, a3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*>((long long *)(a1 + 24 * (v14 >> 1) - 24), (long long *)(a1 + 24 * (v14 >> 1)), (long long *)(a1 + 24 + 24 * (v14 >> 1)), a3);
            long long v16 = *(_OWORD *)a1;
            uint64_t v101 = *(void *)(a1 + 16);
            long long v100 = v16;
            uint64_t v17 = *(void *)(v15 + 16);
            *(_OWORD *)a1 = *(_OWORD *)v15;
            *(void *)(a1 + 16) = v17;
            long long v18 = v100;
            *(void *)(v15 + 16) = v101;
            *(_OWORD *)unint64_t v15 = v18;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*>((long long *)(a1 + 24 * (v14 >> 1)), (long long *)a1, (long long *)v96, a3);
          }
          --a4;
          if (a5 & 1) != 0 || ((*a3)((long long *)(a1 - 24), (long long *)a1)) {
            break;
          }
          long long v31 = *(_OWORD *)a1;
          uint64_t v99 = *(void *)(a1 + 16);
          long long v98 = v31;
          if ((*a3)(&v98, (long long *)v96))
          {
            unint64_t v12 = a1;
            do
              v12 += 24;
            while (((*a3)(&v98, (long long *)v12) & 1) == 0);
          }
          else
          {
            unsigned int v32 = (long long *)(a1 + 24);
            do
            {
              unint64_t v12 = (unint64_t)v32;
              if ((unint64_t)v32 >= a2) {
                break;
              }
              int v33 = (*a3)(&v98, v32);
              unsigned int v32 = (long long *)(v12 + 24);
            }
            while (!v33);
          }
          unint64_t v34 = a2;
          if (v12 < a2)
          {
            unint64_t v34 = a2;
            do
              v34 -= 24;
            while (((*a3)(&v98, (long long *)v34) & 1) != 0);
          }
          while (v12 < v34)
          {
            long long v35 = *(_OWORD *)v12;
            uint64_t v101 = *(void *)(v12 + 16);
            long long v100 = v35;
            long long v36 = *(_OWORD *)v34;
            *(void *)(v12 + 16) = *(void *)(v34 + 16);
            *(_OWORD *)unint64_t v12 = v36;
            long long v37 = v100;
            *(void *)(v34 + 16) = v101;
            *(_OWORD *)unint64_t v34 = v37;
            do
              v12 += 24;
            while (!(*a3)(&v98, (long long *)v12));
            do
              v34 -= 24;
            while (((*a3)(&v98, (long long *)v34) & 1) != 0);
          }
          unint64_t v38 = (long long *)(v12 - 24);
          BOOL v5 = v12 - 24 >= a1;
          BOOL v6 = v12 - 24 == a1;
          if (v12 - 24 != a1)
          {
            long long v39 = *v38;
            *(void *)(a1 + 16) = *(void *)(v12 - 8);
            *(_OWORD *)a1 = v39;
          }
          a5 = 0;
          long long v40 = v98;
          *(void *)(v12 - 8) = v99;
          *unint64_t v38 = v40;
        }
        long long v19 = *(_OWORD *)a1;
        uint64_t v99 = *(void *)(a1 + 16);
        long long v98 = v19;
        unint64_t v20 = (long long *)a1;
        do
        {
          uint64_t v21 = (uint64_t)v20;
          unint64_t v20 = (long long *)((char *)v20 + 24);
        }
        while (((*a3)(v20, &v98) & 1) != 0);
        uint64_t v22 = (long long *)a2;
        if (v21 == a1)
        {
          uint64_t v22 = (long long *)a2;
          do
          {
            if (v20 >= v22) {
              break;
            }
            uint64_t v22 = (long long *)((char *)v22 - 24);
          }
          while (((*a3)(v22, &v98) & 1) == 0);
        }
        else
        {
          do
            uint64_t v22 = (long long *)((char *)v22 - 24);
          while (!(*a3)(v22, &v98));
        }
        if (v20 < v22)
        {
          uint64_t v23 = v22;
          unint64_t v24 = (unint64_t)v20;
          do
          {
            long long v100 = *(_OWORD *)v24;
            long long v25 = v100;
            uint64_t v101 = *(void *)(v24 + 16);
            uint64_t v26 = v101;
            uint64_t v27 = *((void *)v23 + 2);
            *(_OWORD *)unint64_t v24 = *v23;
            *(void *)(v24 + 16) = v27;
            *((void *)v23 + 2) = v26;
            *uint64_t v23 = v25;
            do
            {
              uint64_t v21 = v24;
              v24 += 24;
            }
            while (((*a3)((long long *)v24, &v98) & 1) != 0);
            do
              uint64_t v23 = (long long *)((char *)v23 - 24);
            while (!(*a3)(v23, &v98));
          }
          while (v24 < (unint64_t)v23);
        }
        if (v21 != a1)
        {
          long long v28 = *(_OWORD *)v21;
          *(void *)(a1 + 16) = *(void *)(v21 + 16);
          *(_OWORD *)a1 = v28;
        }
        long long v29 = v98;
        *(void *)(v21 + 16) = v99;
        *(_OWORD *)uint64_t v21 = v29;
        a2 = v94;
        if (v20 >= v22) {
          break;
        }
LABEL_31:
        std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*,false>(a1, v21, a3, a4, a5 & 1);
        a5 = 0;
        unint64_t v12 = v21 + 24;
      }
      BOOL v30 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*>(a1, v21, a3);
      unint64_t v12 = v21 + 24;
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(CAFrameIntervalRequest const&,CAFrameIntervalRequest const&),CAFrameIntervalRequest*>(v21 + 24, v94, a3))
      {
        break;
      }
      if (!v30) {
        goto LABEL_31;
      }
    }
    a2 = v21;
    if (!v30) {
      continue;
    }
    break;
  }
}

BOOL CA::FrameRateArbitrator::RangeSorter<CAFrameIntervalRequest>(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2 = a1[2];
  unsigned int v3 = a2[2];
  if (v2 < v3) {
    return 1;
  }
  if (v2 != v3) {
    return 0;
  }
  unsigned int v5 = a1[3];
  unsigned int v6 = a2[3];
  if (v5 < v6) {
    return 1;
  }
  return v5 == v6 && a1[4] < a2[4];
}

uint64_t CA::WindowServer::AppleDisplay::max_src_rect_width_by_pipes(CA::WindowServer::AppleDisplay *this, int a2)
{
  if (!a2) {
    a2 = *((unsigned __int8 *)this + 27049);
  }
  unsigned int v2 = a2 - 1;
  if (!a2) {
    unsigned int v2 = 0;
  }
  if (v2 >= 4) {
    abort();
  }
  return *((void *)this + v2 + 3535);
}

uint64_t CA::WindowServer::IOMFBDisplay::copy_string(uint64_t a1, int a2, char *a3, size_t a4)
{
  uint64_t v8 = (os_unfair_lock_s *)(a1 + 27052);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 27052));
  if (a2 == 2)
  {
    unint64_t v9 = *(const char **)(a1 + 27088);
    if (!v9) {
      goto LABEL_10;
    }
  }
  else if (a2 == 1)
  {
    unint64_t v9 = *(const char **)(a1 + 27072);
    if (!v9) {
      goto LABEL_10;
    }
  }
  else
  {
    if (a2) {
      goto LABEL_10;
    }
    unint64_t v9 = *(const char **)(a1 + 27056);
    if (!v9) {
      goto LABEL_10;
    }
  }
  if (strlen(v9) + 1 <= a4)
  {
    strcpy(a3, v9);
    uint64_t v10 = 1;
    goto LABEL_12;
  }
LABEL_10:
  uint64_t v10 = 0;
LABEL_12:
  os_unfair_lock_unlock(v8);
  return v10;
}

uint64_t CA::WindowServer::AppleDisplay::max_src_rect_width(CA::WindowServer::AppleDisplay *this)
{
  return (*(uint64_t (**)(CA::WindowServer::AppleDisplay *, void))(*(void *)this + 2288))(this, 0);
}

uint64_t CA::WindowServer::Display::minimum_frame_duration(CA::WindowServer::Display *this)
{
  return 1;
}

uint64_t CA::WindowServer::Display::heartbeat_rate(CA::WindowServer::Display *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 744))();
}

__n128 CA::WindowServer::IOMFBDisplay::edid_attributes@<Q0>(CA::WindowServer::IOMFBDisplay *this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = *(_OWORD *)((char *)this + 26324);
  *(_DWORD *)(a2 + 16) = *((_DWORD *)this + 6585);
  *(unsigned char *)(a2 + 2CA::Context::unref(this[1], 0) = *((unsigned char *)this + 26344);
  __n128 result = *(__n128 *)((char *)this + 26348);
  *(__n128 *)(a2 + 24) = result;
  *(_DWORD *)(a2 + 4CA::Context::unref(this[1], 0) = *((_DWORD *)this + 6591);
  return result;
}

double CA::WindowServer::IOMFBDisplay::panel_physical_size(CA::WindowServer::IOMFBDisplay *this)
{
  return *((double *)this + 3268);
}

__n128 CA::WindowServer::IOMFBDisplay::preset_properties@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = this[1648];
  __n128 v3 = this[1649];
  *a2 = result;
  a2[1] = v3;
  a2[2].n128_u64[0] = this[1650].n128_u64[0];
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::transport_type(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned int *)this + 6602);
}

uint64_t CA::WindowServer::IOMFBDisplay::od_lut_version(CA::WindowServer::IOMFBDisplay *this)
{
  if (*((unsigned char *)this + 28138) || (*((_WORD *)this + 328) & 0x1C00) == 0x1000) {
    return 0;
  }
  if (CADeviceNeedsDisplayWorkarounds::once[0] != -1)
  {
    unsigned int v2 = this;
    dispatch_once(CADeviceNeedsDisplayWorkarounds::once, &__block_literal_global_73);
    this = v2;
  }
  if (!CADeviceNeedsDisplayWorkarounds::needs_workarounds) {
    return 0;
  }
  else {
    return CA::WindowServer::IOMFBDisplay::od_lut_version(void)const::radar_numbers[(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1064))(this)];
  }
}

uint64_t CA::WindowServer::IOMFBDisplay::dmrr_enabled(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28216);
}

uint64_t CA::WindowServer::AppleDisplay::max_src_rect_pixels(CA::WindowServer::AppleDisplay *this)
{
  uint64_t v2 = (*(uint64_t (**)(CA::WindowServer::AppleDisplay *, void))(*(void *)this + 2288))(this, 0);
  return (*(uint64_t (**)(CA::WindowServer::AppleDisplay *, void))(*(void *)this + 2296))(this, 0)
       * v2;
}

uint64_t CA::WindowServer::AppleDisplay::max_src_rect_height_by_pipes(CA::WindowServer::AppleDisplay *this, int a2)
{
  if (!a2) {
    a2 = *((unsigned __int8 *)this + 27050);
  }
  unsigned int v2 = a2 - 1;
  if (!a2) {
    unsigned int v2 = 0;
  }
  if (v2 >= 4) {
    abort();
  }
  return *((void *)this + v2 + 3539);
}

uint64_t CA::WindowServer::IOMFBDisplay::preferred_ui_scale(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned int *)this + 6620);
}

double CA::WindowServer::IOMFBServer::latency(CA::WindowServer::IOMFBServer *this)
{
  return *(double *)(*((void *)this + 12) + 27136);
}

uint64_t CA::WindowServer::Display::preferred_frame_duration(CA::WindowServer::Display *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 768))();
}

uint64_t CA::WindowServer::Display::native_orientation(CA::WindowServer::Display *this)
{
  return 0;
}

uint64_t CA::WindowServer::Display::uses_extended_display_timings(CA::WindowServer::Display *this)
{
  return 0;
}

CAProcessMonitor *CA::WindowServer::IOMFBDisplay::process_monitor(CA::WindowServer::IOMFBDisplay *this)
{
  v3[5] = *MEMORY[0x1E4F143B8];
  __n128 result = (CAProcessMonitor *)*((void *)this + 3430);
  if (!result)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 0x40000000;
    v3[2] = ___ZN2CA12WindowServer12IOMFBDisplay15process_monitorEv_block_invoke;
    v3[3] = &__block_descriptor_tmp_542;
    v3[4] = this;
    __n128 result = [[CAProcessMonitor alloc] initWithCallback:v3];
    *((void *)this + 343CA::Context::unref(this[1], 0) = result;
  }
  return result;
}

uint64_t CA::WindowServer::AppleInternalDisplay::native_orientation(CA::WindowServer::AppleInternalDisplay *this)
{
  return *((unsigned int *)this + 7135);
}

CATransform3D *__cdecl CATransform3DScale(CATransform3D *__return_ptr retstr, CATransform3D *t, CGFloat sx, CGFloat sy, CGFloat sz)
{
  float64x2_t v5 = vmulq_n_f64(*(float64x2_t *)&t->m11, sx);
  float64x2_t v6 = vmulq_n_f64(*(float64x2_t *)&t->m13, sx);
  float64x2_t v7 = vmulq_n_f64(*(float64x2_t *)&t->m21, sy);
  float64x2_t v8 = vmulq_n_f64(*(float64x2_t *)&t->m23, sy);
  float64x2_t v9 = vmulq_n_f64(*(float64x2_t *)&t->m31, sz);
  float64x2_t v10 = vmulq_n_f64(*(float64x2_t *)&t->m33, sz);
  *(float64x2_t *)&t->m11 = v5;
  *(float64x2_t *)&t->m13 = v6;
  *(float64x2_t *)&t->m21 = v7;
  *(float64x2_t *)&t->m23 = v8;
  *(float64x2_t *)&t->m31 = v9;
  *(float64x2_t *)&t->m33 = v10;
  long long v11 = *(_OWORD *)&t->m43;
  *(_OWORD *)&retstr->m41 = *(_OWORD *)&t->m41;
  *(_OWORD *)&retstr->m43 = v11;
  long long v12 = *(_OWORD *)&t->m33;
  *(_OWORD *)&retstr->m31 = *(_OWORD *)&t->m31;
  *(_OWORD *)&retstr->m33 = v12;
  long long v13 = *(_OWORD *)&t->m13;
  *(_OWORD *)&retstr->m11 = *(_OWORD *)&t->m11;
  *(_OWORD *)&retstr->m13 = v13;
  long long v14 = *(_OWORD *)&t->m23;
  *(_OWORD *)&retstr->m21 = *(_OWORD *)&t->m21;
  *(_OWORD *)&retstr->m23 = v14;
  return t;
}

uint64_t CA::WindowServer::AppleDisplay::detachable_layer_impl(uint64_t a1, int *a2, double *a3, uint64_t a4, float64x2_t *a5, float64x2_t *a6, _DWORD *a7)
{
  uint64_t v202 = *MEMORY[0x1E4F143B8];
  CA::ScalerUtil::ScalerLimits::limits((CA::ScalerUtil::ScalerLimits *)a1);
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1544))(a1)) {
    return 28;
  }
  uint64_t v194 = a3;
  uint64_t v195 = a6;
  int v15 = *(_DWORD *)(a4 + 64);
  int v16 = CA::Render::fourcc_compressed_of_type((CA::Render *)v15, 0, 0);
  int v17 = *(_DWORD *)(a1 + 28224);
  int v18 = 1;
  uint64_t result = 9;
  if (v15 <= 1530426927)
  {
    if (v15 > 758674993)
    {
      if (v15 > 796423727)
      {
        if (v15 > 875836533)
        {
          if (v15 > 1380411456)
          {
            if ((v15 - 1530422832) <= 4 && ((1 << (v15 - 48)) & 0x15) != 0) {
              goto LABEL_148;
            }
            if (v15 != 1380411457) {
              return result;
            }
            if (*(unsigned char *)(a1 + 28158)
              && ((*(unsigned int (**)(uint64_t))(*(void *)a4 + 40))(a4) == 13
               || (*(unsigned int (**)(uint64_t))(*(void *)a4 + 40))(a4) == 8
               || ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1840))(a1) & 1) != 0))
            {
              goto LABEL_216;
            }
            return 7;
          }
          if (v15 != 875836534)
          {
            if (v15 == 1111970369) {
              goto LABEL_216;
            }
            if (v15 != 1278555701) {
              return result;
            }
            if (CADeviceSupportsUniversalCompression::once != -1) {
              dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
            }
            if (!CADeviceSupportsUniversalCompression::universal) {
              goto LABEL_216;
            }
            return 9;
          }
          goto LABEL_196;
        }
        if (v15 <= 875704437)
        {
          if (v15 == 796423728 || v15 == 796423730) {
            goto LABEL_192;
          }
          unsigned __int16 v22 = 12390;
        }
        else
        {
          if (v15 > 875704949)
          {
            if (v15 == 875704950) {
              goto LABEL_196;
            }
            int v21 = 875836518;
LABEL_184:
            if (v15 != v21) {
              return result;
            }
            goto LABEL_196;
          }
          if (v15 == 875704438) {
            goto LABEL_196;
          }
          unsigned __int16 v22 = 12902;
        }
        int v21 = v22 | 0x34320000;
        goto LABEL_184;
      }
      if (v15 <= 792225327)
      {
        if (v15 > 762865201)
        {
          if (v15 == 762865202 || v15 == 762869296) {
            goto LABEL_192;
          }
          unsigned __int16 v32 = 30258;
        }
        else
        {
          if (v15 == 758674994) {
            goto LABEL_192;
          }
          if (v15 == 759318337)
          {
LABEL_130:
            if (CADeviceSupportsLossyUniversalCompression::once != -1) {
              dispatch_once(&CADeviceSupportsLossyUniversalCompression::once, &__block_literal_global_46);
            }
            if (!CADeviceSupportsLossyUniversalCompression::lossy) {
              return 29;
            }
            goto LABEL_216;
          }
          unsigned __int16 v32 = 26160;
        }
        int v35 = v32 | 0x2D780000;
        goto LABEL_191;
      }
      if (v15 <= 792229425)
      {
        if (v15 != 792225328 && v15 != 792225330)
        {
          int v35 = 792229424;
          goto LABEL_191;
        }
        goto LABEL_192;
      }
      if (v15 > 796419631)
      {
        if (v15 == 796419632) {
          goto LABEL_192;
        }
        int v35 = 796419634;
        goto LABEL_191;
      }
      if (v15 == 792229426) {
        goto LABEL_192;
      }
      int v25 = 792872769;
LABEL_129:
      if (v15 != v25) {
        return result;
      }
      goto LABEL_130;
    }
    if (v15 <= 645166639)
    {
      if (v15 > 641877824)
      {
        if (v15 <= 644624753)
        {
          if (v15 != 641877825 && v15 != 642934849)
          {
            if (v15 != 643969848) {
              return result;
            }
            if (CADeviceSupportsUniversalCompression::once != -1) {
              dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
            }
            if (!CADeviceSupportsUniversalCompression::universal) {
              return 29;
            }
            goto LABEL_216;
          }
LABEL_116:
          if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 696))(a1) & 1) != 0 || !*(unsigned char *)(a1 + 28158)) {
            return 29;
          }
          goto LABEL_216;
        }
        if ((v15 - 645162544) > 4 || ((1 << (v15 - 48)) & 0x15) == 0)
        {
          if (v15 != 644624754) {
            return result;
          }
          if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 696))(a1) & 1) != 0 || !*(unsigned char *)(a1 + 28159)) {
            return 29;
          }
          goto LABEL_216;
        }
        goto LABEL_157;
      }
      if ((v15 - 641230384) <= 4 && ((1 << (v15 - 48)) & 0x15) != 0) {
        goto LABEL_157;
      }
      int v29 = -641234480;
    }
    else
    {
      if (v15 <= 645428783)
      {
        if (v15 > 645346400)
        {
          if ((v15 - 645424688) > 4 || ((1 << (v15 - 48)) & 0x15) == 0)
          {
            unsigned __int16 v20 = 13409;
LABEL_92:
            if (v15 != (v20 | 0x26770000)) {
              return result;
            }
            goto LABEL_116;
          }
        }
        else if ((v15 - 645166640) > 4 || ((1 << (v15 - 48)) & 0x15) == 0)
        {
          unsigned __int16 v20 = 13170;
          goto LABEL_92;
        }
LABEL_157:
        if (CADeviceSupportsUniversalCompression::once != -1) {
          dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
        }
        if (CADeviceSupportsUniversalCompression::universal) {
          goto LABEL_196;
        }
        return 29;
      }
      if (v15 > 758670895)
      {
        if (v15 != 758670896 && v15 != 758670898)
        {
          int v35 = 758674992;
          goto LABEL_191;
        }
        goto LABEL_192;
      }
      int v29 = -645428784;
    }
    unsigned int v30 = v15 + v29;
    if (v30 > 4 || ((1 << v30) & 0x15) == 0) {
      return result;
    }
    goto LABEL_157;
  }
  if (v15 > 1952854575)
  {
    if (v15 > 2019963441)
    {
      if (v15 <= 2084075055)
      {
        if (v15 > 2037741157)
        {
          if (v15 <= 2084070959)
          {
            if (v15 != 2037741158)
            {
              int v21 = 2037741171;
              goto LABEL_184;
            }
LABEL_196:
            *a7 = 2;
LABEL_197:
            if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1504))(a1))
            {
              *a2 |= 0x4000000u;
              if ((v18 & 1) == 0) {
                goto LABEL_217;
              }
            }
            else if ((*(_WORD *)(a1 + 28544) & 2) != 0)
            {
              if (!*(unsigned char *)(a1 + 28178)) {
                v17 &= ~2u;
              }
              if ((v18 & 1) == 0) {
                goto LABEL_217;
              }
            }
            else if (!v18)
            {
              goto LABEL_217;
            }
LABEL_207:
            uint64_t v36 = 28432;
            goto LABEL_218;
          }
          if (v15 != 2084070960)
          {
            int v35 = 2084070962;
            goto LABEL_191;
          }
LABEL_192:
          if (CADeviceSupportsLossyUniversalCompression::once != -1) {
            dispatch_once(&CADeviceSupportsLossyUniversalCompression::once, &__block_literal_global_46);
          }
          if (!CADeviceSupportsLossyUniversalCompression::lossy) {
            return 29;
          }
          int v18 = 0;
          goto LABEL_196;
        }
        if (v15 == 2019963442 || v15 == 2019963956) {
          goto LABEL_196;
        }
        unsigned __int16 v33 = 13424;
        goto LABEL_183;
      }
      if (v15 > 2088265263)
      {
        if (v15 > 2088269359)
        {
          if (v15 == 2088269360) {
            goto LABEL_192;
          }
          unsigned __int16 v26 = 30258;
        }
        else
        {
          if (v15 == 2088265264) {
            goto LABEL_192;
          }
          unsigned __int16 v26 = 26162;
        }
        int v35 = v26 | 0x7C780000;
LABEL_191:
        if (v15 != v35) {
          return result;
        }
        goto LABEL_192;
      }
      if (v15 == 2084075056 || v15 == 2084075058) {
        goto LABEL_192;
      }
      int v25 = 2084718401;
      goto LABEL_129;
    }
    if (v15 > 1999843441)
    {
      if (v15 <= 2016686641)
      {
        if (v15 == 1999843442 || v15 == 1999908961)
        {
          if ((*(float (**)(uint64_t))(*(void *)a4 + 192))(a4) != 1.0
            && *(unsigned char *)(a1 + 28170)
            && (v17 & 4) != 0)
          {
            *a7 = 2;
            *a2 |= 0x2000000u;
            if (*a7 != 2) {
              goto LABEL_207;
            }
            goto LABEL_197;
          }
          goto LABEL_216;
        }
        unsigned __int16 v24 = 12848;
      }
      else
      {
        if (v15 > 2016687215)
        {
          if (v15 == 2016687216) {
            goto LABEL_196;
          }
          unsigned __int16 v33 = 12848;
LABEL_183:
          int v21 = v33 | 0x78660000;
          goto LABEL_184;
        }
        if (v15 == 2016686642) {
          goto LABEL_196;
        }
        unsigned __int16 v24 = 13364;
      }
      int v21 = v24 | 0x78340000;
      goto LABEL_184;
    }
    if (v15 > 1953903151)
    {
      if (v15 != 1953903152 && v15 != 1953903154)
      {
        int v31 = 1953903668;
LABEL_164:
        if (v15 != v31) {
          return result;
        }
      }
    }
    else if (v15 != 1952854576 && v15 != 1952854578)
    {
      int v31 = 1952855092;
      goto LABEL_164;
    }
    if (!*(unsigned char *)(a1 + 28157)) {
      return 5;
    }
    goto LABEL_196;
  }
  if (v15 <= 1647534391)
  {
    if (v15 <= 1534359087)
    {
      if ((v15 - 1530426928) <= 4 && ((1 << (v15 - 48)) & 0x15) != 0) {
        goto LABEL_148;
      }
      int v19 = -1534354992;
    }
    else
    {
      if ((v15 - 1534359088) <= 4 && ((1 << (v15 - 48)) & 0x15) != 0
        || (v15 - 1534617136) <= 4 && ((1 << (v15 - 48)) & 0x15) != 0)
      {
        goto LABEL_148;
      }
      int v19 = -1534621232;
    }
    unsigned int v28 = v15 + v19;
    if (v28 > 4 || ((1 << v28) & 0x15) == 0) {
      return result;
    }
LABEL_148:
    if (*(unsigned char *)(a1 + 28158))
    {
      if (CADeviceSupportsUniversalCompression::once != -1) {
        dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
      }
      if (!CADeviceSupportsUniversalCompression::universal) {
        goto LABEL_196;
      }
    }
    return 29;
  }
  if (v15 > 1885746227)
  {
    if (((v15 - 1886676528) > 4 || ((1 << (v15 - 48)) & 0x15) == 0)
      && ((v15 - 1886680624) > 4 || ((1 << (v15 - 48)) & 0x15) == 0))
    {
      unsigned __int16 v27 = 13364;
      goto LABEL_177;
    }
    if (!*(unsigned char *)(a1 + 28157)) {
      return result;
    }
    if (CADeviceSupportsUniversalCompression::once != -1) {
      dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
    }
    if (!CADeviceSupportsUniversalCompression::universal) {
      goto LABEL_196;
    }
    return 9;
  }
  if (v15 > 1882468913)
  {
    if (v15 <= 1885745711)
    {
      if (v15 != 1882468914)
      {
        unsigned __int16 v23 = 13364;
LABEL_108:
        int v34 = v23 | 0x70340000;
        goto LABEL_178;
      }
LABEL_179:
      if (!*(unsigned char *)(a1 + 28156)) {
        return 4;
      }
      goto LABEL_196;
    }
    if (v15 == 1885745712) {
      goto LABEL_179;
    }
    unsigned __int16 v27 = 12850;
LABEL_177:
    int v34 = v27 | 0x70660000;
LABEL_178:
    if (v15 != v34) {
      return result;
    }
    goto LABEL_179;
  }
  if (v15 == 1647534392)
  {
    if (!*(unsigned char *)(a1 + 28156)) {
      return 6;
    }
    goto LABEL_216;
  }
  if (v15 != 1815162994)
  {
    unsigned __int16 v23 = 12848;
    goto LABEL_108;
  }
  if (!*(unsigned char *)(a1 + 28159)) {
    return 7;
  }
LABEL_216:
  *a7 = 0;
LABEL_217:
  uint64_t v36 = 28472;
LABEL_218:
  uint64_t v37 = a1 + v36;
  if (!(*(unsigned int (**)(uint64_t, void, void))(*(void *)a4 + 152))(a4, *(void *)(a1 + 28232), *(void *)(a1 + 28240)))return 10; {
  unint64_t v38 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 160))(a4);
  }
  if (v38 && *(void *)(a1 + 28264) && v16 != v15 && IOSurfaceGetAllocSize(v38) > *(void *)(a1 + 28264)) {
    return 30;
  }
  LODWORD(v39) = *(_DWORD *)(a4 + 56);
  unsigned int v40 = *(_DWORD *)(a4 + 60);
  if (v39 >= v40) {
    unint64_t v39 = v40;
  }
  else {
    unint64_t v39 = v39;
  }
  if (*(void *)(v37 + 8) > v39) {
    return 11;
  }
  if (!(*(_DWORD *)(a1 + 745) & 0x40 | *a2 & 0x1000)) {
    return 34;
  }
  BOOL v41 = (*a2 & 0x1000) == 0;
  unint64_t v193 = (*(uint64_t (**)(uint64_t, BOOL))(*(void *)a1 + 2288))(a1, v41);
  uint64_t v191 = (*(uint64_t (**)(uint64_t, BOOL))(*(void *)a1 + 2288))(a1, v41);
  uint64_t v42 = (*(uint64_t (**)(uint64_t, BOOL))(*(void *)a1 + 2296))(a1, v41);
  if (!CA::WindowServer::Display::clones_support_detaching(*(CA::WindowServer::Display **)(a1 + 40))) {
    return 12;
  }
  if (((*(unsigned int (**)(uint64_t))(*(void *)a4 + 56))(a4) & v17) == 0 && !BYTE13(xmmword_1EB2ACC30))
  {
    if (!BYTE1(dword_1E8F852AC) || (*(unsigned int (**)(uint64_t))(*(void *)a4 + 56))(a4) == 1) {
      return 13;
    }
    if ((v17 & 4) != 0)
    {
      int v43 = 0x1000000;
    }
    else
    {
      if ((v17 & 2) == 0) {
        return 13;
      }
      int v43 = 0x800000;
    }
    *a2 |= v43;
  }
  uint64_t v190 = v37;
  uint64_t v44 = (*(uint64_t (**)(uint64_t))(*(void *)a4 + 88))(a4);
  if (v44)
  {
    uint64_t v47 = (CGColorSpace *)v44;
    uint64_t v48 = *(unsigned __int8 *)(a4 + 228);
    uint64_t v49 = *(unsigned int *)(a4 + 224);
    if ((!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 176))(a1)
       || !CA::WindowServer::Display::all_clones_support_hlg(*(CA::WindowServer::Display **)(a1 + 40))
       || ((v49 | (v48 << 32)) & 0x2000000000) == 0)
      && CGColorSpaceIsHLGBased(v47))
    {
      return 36;
    }
    if ((!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 168))(a1)
       || (CA::WindowServer::Display::all_clones_support_pq(*(CA::WindowServer::Display **)(a1 + 40)) & 1) == 0)
      && CGColorSpaceIsPQBased(v47))
    {
      return 36;
    }
  }
  int v50 = *a2;
  if ((*a2 & 0x40) != 0) {
    goto LABEL_549;
  }
  Rect v200 = 0;
  uint64_t v201 = 0;
  unint64_t v51 = v42 * v191;
  int32x4_t v199 = 0uLL;
  Rect v197 = 0;
  uint64_t v198 = 0;
  int32x4_t v196 = 0uLL;
  CA::Bounds::set_both(&v199, &v200, v45, v46, *a5, a5[1]);
  CA::Bounds::set_both(&v196, &v197, v52, v53, *v195, v195[1]);
  if ((v50 & 4) != 0) {
    int v54 = v196.i32[3];
  }
  else {
    int v54 = v196.i32[2];
  }
  double v55 = (double)v54;
  if ((v50 & 4) != 0) {
    int v56 = v196.i32[2];
  }
  else {
    int v56 = v196.i32[3];
  }
  int v187 = HIDWORD(v201);
  int v188 = v201;
  double v57 = (double)(int)v201;
  double v58 = v55 / (double)(int)v201;
  double v59 = (double)SHIDWORD(v201);
  double v60 = (double)v56 / (double)SHIDWORD(v201);
  int v61 = v198;
  if ((v50 & 4) != 0) {
    int v62 = HIDWORD(v198);
  }
  else {
    int v62 = v198;
  }
  int v185 = HIDWORD(v198);
  int v186 = v198;
  if ((v50 & 4) == 0) {
    int v61 = HIDWORD(v198);
  }
  __int32 v63 = v199.i32[2];
  __int32 v64 = v199.i32[3];
  double v65 = (double)v62 / (double)v199.i32[2];
  double v66 = (double)v61 / (double)v199.i32[3];
  if ((v50 & 4) != 0) {
    __int32 v67 = v199.i32[3];
  }
  else {
    __int32 v67 = v199.i32[2];
  }
  int v189 = v67;
  if (v58 <= v65) {
    double v68 = v65;
  }
  else {
    double v68 = v58;
  }
  if (v58 <= v65) {
    double v69 = v58;
  }
  else {
    double v69 = v65;
  }
  if (v60 <= v66) {
    double v70 = (double)v61 / (double)v199.i32[3];
  }
  else {
    double v70 = v60;
  }
  if (v60 <= v66) {
    double v71 = v60;
  }
  else {
    double v71 = (double)v61 / (double)v199.i32[3];
  }
  int v72 = *(_DWORD *)(a1 + 176);
  int v73 = *(_DWORD *)(a1 + 180);
  unint64_t v192 = v51;
  if (v51)
  {
    uint64_t result = 14;
    if (v193 < v196.i32[2] || v196.i32[3] * (uint64_t)v196.i32[2] > v51) {
      return result;
    }
  }
  if ((v50 & 0x10000) != 0) {
    return 35;
  }
  __int32 v183 = v199.i32[3];
  __int32 v184 = v199.i32[2];
  unint64_t v182 = v196.i32[3];
  unint64_t v74 = v196.i32[2];
  if (CADeviceSupportsDCP::once[0] != -1)
  {
    dispatch_once(CADeviceSupportsDCP::once, &__block_literal_global_295);
    __int32 v64 = v183;
    __int32 v63 = v184;
  }
  unint64_t v75 = v73 * (uint64_t)v72;
  if (CADeviceSupportsDCP::has_dcp)
  {
    __int16 v76 = (*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
    __int32 v64 = v183;
    __int32 v63 = v184;
    if ((v76 & 0xF00) != 0x700) {
      goto LABEL_337;
    }
  }
  int v77 = *a2;
  if ((*a2 & 8) != 0 || v193 < v189 || v192 && v64 * (uint64_t)v63 > v192) {
    goto LABEL_338;
  }
  unint64_t v78 = *(void *)(v190 + 16);
  if (v78)
  {
    _NF = v71 < 1.0 || v69 < 1.0;
    if (_NF && v78 < v189) {
      goto LABEL_338;
    }
  }
  if (HIBYTE(xmmword_1EB2ACC70) || !*(unsigned char *)(a1 + 28153))
  {
    if (v69 < 1.0 || v71 < 1.0 || v68 > 1.0 || v70 > 1.0) {
      goto LABEL_338;
    }
  }
  else
  {
    if ((v77 & 7) != 0)
    {
      if (((*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 2312))(a1, v77 & 7, a4) & 1) != 0
        || (*(_DWORD *)(a4 + 60) * *(_DWORD *)(a4 + 56)) <= v75)
      {
        goto LABEL_339;
      }
      goto LABEL_337;
    }
    _ZF = (v71 < 1.0 || v69 < 1.0) && *a7 == 2;
    if (_ZF && *(unsigned char *)(a1 + 28156))
    {
      if (CADeviceSupportsUniversalCompression::once != -1) {
        dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
      }
      if (!CADeviceSupportsUniversalCompression::universal) {
        goto LABEL_337;
      }
    }
    unint64_t v86 = *(void *)(a1 + 28368);
    if (v86)
    {
      double v87 = a5[1].f64[0];
      if (v87 > (double)v86 && v87 != v195[1].f64[0])
      {
LABEL_337:
        int v77 = *a2;
LABEL_338:
        *a2 = v77 | 0x80;
      }
    }
  }
LABEL_339:
  int is_420 = CA::Render::fourcc_is_420((CA::Render *)*(unsigned int *)(a4 + 64));
  char v89 = (v69 >= 1.0) & ~(_BYTE)is_420;
  if (v71 < 1.0) {
    char v89 = 0;
  }
  if (v68 > 1.0) {
    char v89 = 0;
  }
  if (v70 > 1.0) {
    char v89 = 0;
  }
  uint64_t v90 = *(void *)(a1 + 28376);
  if (v90)
  {
    if (v189 > (int)v90 && (v89 & 1) == 0)
    {
      int v91 = *a2;
      *a2 |= 0x80u;
      if (is_420) {
        *a2 = v91 | 0x20000080;
      }
    }
  }
  unsigned int v92 = *(_DWORD *)(a4 + 64);
  if (CA::Render::fourcc_compressed_of_type((CA::Render *)v92, 0, 0) == v92) {
    *a2 |= 0x40000000u;
  }
  if ((_BYTE)xmmword_1EB2ACC10)
  {
    BOOL v99 = 0;
    char v103 = 0;
    int should_enhance = 1;
  }
  else
  {
    long long v93 = (CA::ScalerStatistics *)*(unsigned int *)(a4 + 56);
    uint64_t v94 = *(unsigned int *)(a4 + 60);
    double v95 = v70 * (double)v94;
    int v96 = *a2;
    if ((*a2 & 4) != 0) {
      unint64_t v97 = (unint64_t)v95;
    }
    else {
      unint64_t v97 = (unint64_t)(v68 * (double)v93);
    }
    if ((v96 & 4) != 0) {
      uint64_t v98 = (unint64_t)(v68 * (double)v93);
    }
    else {
      uint64_t v98 = (unint64_t)v95;
    }
    BOOL v99 = (v96 & 0x40000000) == 0 && (double)v75 * 1.5 < (double)(v97 * v98);
    if (v94 < 0x2D1)
    {
      BOOL v101 = 0;
    }
    else
    {
      int v100 = *(_DWORD *)(a1 + 176);
      if (v100 >= *(_DWORD *)(a1 + 180)) {
        int v100 = *(_DWORD *)(a1 + 180);
      }
      BOOL v101 = v100 < 1640;
    }
    char v102 = v97 > v193 || v101;
    if (v193) {
      char v103 = v102;
    }
    else {
      char v103 = v101;
    }
    int should_enhance = CA::ScalerStatistics::should_enhance(v93, v94, v97, v98);
  }
  if (*(unsigned char *)(a4 + 229) && BYTE2(dword_1E8F852AC))
  {
    if (v69 > 1.0) {
      int v105 = should_enhance;
    }
    else {
      int v105 = 0;
    }
    int v106 = dword_1E8F85288;
    if (v105 == 1 && v71 > 1.0)
    {
      double v108 = *(double *)(v190 + 32);
      if (v68 <= v108 * *(float *)&dword_1E8F85288)
      {
        char v109 = v70 > v108 * *(float *)&dword_1E8F8528C ? 1 : v103;
        if ((v109 & 1) == 0)
        {
          char v110 = byte_1EB2ACC0F || v99;
          if ((v110 & 1) == 0) {
            *a2 |= 0x10000000u;
          }
        }
      }
    }
  }
  else
  {
    int v106 = dword_1E8F85288;
  }
  uint64_t v111 = v190;
  int v112 = *a2;
  uint64_t v113 = (float *)&dword_1E8F85280;
  if ((*a2 & 0x10000000) == 0) {
    uint64_t v113 = (float *)&xmmword_1E8F85270;
  }
  float v114 = *v113;
  uint64_t v115 = (float *)&xmmword_1E8F85270 + 1;
  if ((v112 & 0x10000000) != 0) {
    uint64_t v115 = (float *)algn_1E8F85284;
  }
  float v116 = *v115;
  if ((v112 & 0x10000000) != 0) {
    float v117 = *(float *)&v106;
  }
  else {
    float v117 = *((float *)&xmmword_1E8F85270 + 2);
  }
  BOOL v118 = (float *)&dword_1E8F8528C;
  if ((v112 & 0x10000000) == 0) {
    BOOL v118 = (float *)&xmmword_1E8F85270 + 3;
  }
  float v119 = *v118;
  double v120 = v117;
  double v121 = *v118;
  unint64_t v122 = v194;
  if ((v112 & 0x10000000) != 0 && v68 <= v120 && v70 <= v121)
  {
    v112 |= 0x80u;
    *a2 = v112;
  }
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)uint64_t v194 = _Q0;
  double v125 = v114;
  double v126 = v116;
  double v127 = 1.0;
  if ((v112 & 0x80) == 0 || v69 < v125 || v71 < v126 || v68 > v120 || v70 > v121)
  {
    unsigned int v134 = v112 & 0xFFFFFF7F;
    *a2 = v112 & 0xFFFFFF7F;
    double v135 = *(double *)(v190 + 24);
    if (v69 >= v135)
    {
      double v138 = *(double *)(v190 + 32);
      if (v68 <= v138)
      {
        double v128 = 1.0;
        if ((v112 & 0x10000000) == 0 || v68 <= v120)
        {
LABEL_449:
          if (v71 >= v135)
          {
            double v154 = *(double *)(v111 + 32);
            if (v70 <= v154 && ((v134 & 0x10000000) == 0 || v70 <= v121))
            {
              int v112 = v134;
              goto LABEL_519;
            }
            if (v154 * v121 < v70) {
              return 15;
            }
            int v160 = 2;
            if ((int)v119 >= 3)
            {
              do
              {
                if (v154 * (double)v160 >= v70) {
                  break;
                }
                v160 *= 2;
              }
              while (v160 < (int)v119);
              if (v160 < 2) {
                return 15;
              }
            }
            int v112 = v134 | 0x8000000;
            *a2 = v134 | 0x8000000;
            double v127 = (double)v160;
          }
          else
          {
            if (v135 * v126 > v71) {
              return 15;
            }
            double v127 = 0.5;
            if (v116 < 0.5 && v135 * 0.5 > v71)
            {
              do
                double v127 = v127 * 0.5;
              while (v127 > v126 && v127 * v135 > v71);
            }
            if (v127 <= 0.0 || v127 >= 1.0) {
              return 15;
            }
            int v112 = v134 | 0x8000000;
            *a2 = v134 | 0x8000000;
          }
          v194[1] = v127;
LABEL_519:
          uint64_t v111 = v190;
          goto LABEL_414;
        }
      }
      if (v138 * v120 < v68) {
        return 15;
      }
      int v139 = 2;
      if ((int)v117 >= 3)
      {
        do
        {
          if (v138 * (double)v139 >= v68) {
            break;
          }
          v139 *= 2;
        }
        while (v139 < (int)v117);
        if (v139 < 2) {
          return 15;
        }
      }
      v134 |= 0x8000000u;
      *a2 = v134;
      double v128 = (double)v139;
      unint64_t v122 = v194;
      uint64_t v111 = v190;
    }
    else
    {
      if (v135 * v125 > v69) {
        return 15;
      }
      double v128 = 0.5;
      if (v114 < 0.5 && v135 * 0.5 > v69)
      {
        do
          double v128 = v128 * 0.5;
        while (v128 > v125 && v128 * v135 > v69);
      }
      if (v128 <= 0.0 || v128 >= 1.0) {
        return 15;
      }
      unsigned int v134 = v112 & 0xF7FFFF7F | 0x8000000;
      *a2 = v134;
    }
    *unint64_t v122 = v128;
    goto LABEL_449;
  }
  double v128 = 1.0;
LABEL_414:
  unint64_t v129 = *(void *)v111;
  if (*(void *)v111)
  {
    int v130 = v186;
    if ((v112 & 0x80) == 0) {
      int v130 = v188;
    }
    LODWORD(v13CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v187;
    if ((v112 & 0x80) != 0) {
      LODWORD(v13CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v185;
    }
    unint64_t v131 = (int)v131;
    unint64_t v132 = v130;
    int v133 = v112 & 0x8000000;
    if ((v112 & 0x8000000) != 0)
    {
      unint64_t v132 = (unint64_t)(v128 * (double)v132);
      unint64_t v131 = (unint64_t)(v127 * (double)(unint64_t)(int)v131);
    }
    if (v132 < v131) {
      unint64_t v131 = v132;
    }
    if (v131 < v129) {
      return 16;
    }
  }
  else
  {
    int v133 = v112 & 0x8000000;
  }
  unint64_t v143 = *(unsigned int *)(a4 + 56);
  unint64_t v144 = *(unsigned int *)(a4 + 60);
  if (v133)
  {
    unint64_t v143 = (unint64_t)(v128 * (double)v143);
    double v127 = v127 * (double)v144;
    unint64_t v144 = (unint64_t)v127;
    v112 &= ~0x40000000u;
    *a2 = v112;
  }
  unint64_t v145 = *(void *)(a1 + 28272);
  if (v145)
  {
    if ((v112 & 0x80) != 0)
    {
      uint64_t v146 = v196.i32[0];
      uint64_t v147 = v196.i32[1];
      unint64_t v148 = v74;
      unint64_t v149 = v182;
    }
    else
    {
      uint64_t v146 = 0;
      uint64_t v147 = 0;
      unint64_t v148 = v143;
      unint64_t v149 = v144;
    }
    unint64_t v150 = v148 + v146;
    unint64_t v151 = v149 + v147;
    if (v150 <= v151) {
      unint64_t v150 = v151;
    }
    if (v150 > v145) {
      return 17;
    }
  }
  uint64_t result = 18;
  if (v143 <= v145 && v144 <= v145)
  {
    if ((v112 & 0x8000080) != 0)
    {
      if ((v112 & 0x80) != 0)
      {
        LODWORD(v127) = *(_DWORD *)(a4 + 56);
        double v157 = v68 * (double)*(unint64_t *)&v127;
        unint64_t v158 = (unint64_t)v157;
        if ((v112 & 0x40000000) != 0)
        {
          double v161 = v195[1].f64[0];
          if ((unint64_t)v161 >= v158) {
            unint64_t v152 = v158;
          }
          else {
            unint64_t v152 = (unint64_t)v161;
          }
        }
        else
        {
          LODWORD(v157) = *(_DWORD *)(a4 + 60);
          double v159 = v70 * (double)*(unint64_t *)&v157;
          if ((v112 & 4) != 0) {
            unint64_t v152 = (unint64_t)v159;
          }
          else {
            unint64_t v152 = v158;
          }
        }
      }
      else
      {
        if ((v112 & 4) != 0) {
          unint64_t v152 = v144;
        }
        else {
          unint64_t v152 = v143;
        }
        if (v193 && v152 > v193) {
          return 19;
        }
        unint64_t v153 = (v112 & 4) != 0 ? v143 : v144;
        if (v192 && v152 * v153 > v192) {
          return 19;
        }
      }
    }
    else
    {
      if (v193 < v189 || v192 && v183 * (uint64_t)v184 > v192) {
        return 20;
      }
      unint64_t v152 = v189;
      unint64_t v155 = *(void *)(v190 + 16);
      if (v155)
      {
        BOOL v156 = v71 < 1.0 || v69 < 1.0;
        if (v156 && v155 < v189) {
          return 20;
        }
      }
    }
    if (CADeviceUseCompression::once[0] != -1) {
      dispatch_once(CADeviceUseCompression::once, &__block_literal_global_21);
    }
    if (CADeviceUseCompression::enable_compression)
    {
      long long v162 = (CA::Render *)*(unsigned int *)(a4 + 64);
      if ((*a2 & 0xBF800080) != 0) {
        long long v162 = (CA::Render *)(*(uint64_t (**)(uint64_t, void, unint64_t))(*(void *)a1 + 2320))(a1, *(unsigned int *)(a4 + 64), v152);
      }
      if (v162 && CA::Render::fourcc_compressed_of_type(v162, 0, 0) != v162)
      {
        unint64_t v180 = *(void *)(a1 + 28344);
        if (CA::Render::fourcc_is_420(v162) && *(void *)(a1 + 28352)) {
          unint64_t v180 = *(void *)(a1 + 28352);
        }
        if (v180 && v152 > v180) {
          return 31;
        }
        int v181 = (CA::Render *)(*(uint64_t (**)(uint64_t, CA::Render *, unint64_t))(*(void *)a1 + 2320))(a1, v162, v152);
        if (CA::Render::fourcc_compressed_of_type(v181, 0, 0) == v181
          && !BYTE1(xmmword_1EB2ACC10))
        {
          return 31;
        }
      }
    }
    if ((*a2 & 0xBF800080) == 0 || (uint64_t result = 21, v184 <= dword_1E8F85258) && v183 <= dword_1E8F8525C)
    {
      double v163 = CA::WindowServer::Display::minmax_clone_scale((CA::WindowServer::Display *)a1);
      double v165 = v164;
      double v167 = v166 * v68;
      double v169 = v168 * v70;
      CA::ScalerUtil::ScalerLimits::limits(v170);
      unint64_t v171 = 1.0;
      if (v167 > 1.0 || v169 > 1.0)
      {
        LODWORD(v17CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(_DWORD *)(a4 + 56);
        double v179 = v167 * (double)v171;
        if (v179 > (double)dword_1E8F85268 * 0.75) {
          return 22;
        }
        LODWORD(v179) = *(_DWORD *)(a4 + 60);
        if (v169 * (double)*(unint64_t *)&v179 > (double)dword_1E8F8526C * 0.75) {
          return 22;
        }
      }
      double v172 = v163 * v69;
      double v173 = v165 * v71;
      BOOL v174 = v163 * v69 < 1.0;
      if (v165 * v71 < 1.0) {
        BOOL v174 = 1;
      }
      if (!v174 || (v175 = (double)*(unint64_t *)v190, uint64_t result = 38, v172 * v57 >= v175) && v173 * v59 >= v175)
      {
        if (v167 == 0.0
          || v169 == 0.0
          || v172 >= *(float *)&xmmword_1E8F85270
          && v173 >= *((float *)&xmmword_1E8F85270 + 1)
          && v167 <= *((float *)&xmmword_1E8F85270 + 2)
          && v169 <= *((float *)&xmmword_1E8F85270 + 3))
        {
          if (v174)
          {
            double v176 = v172 * v57;
            double v177 = (double)*(unint64_t *)v190;
            uint64_t result = 38;
            if (v176 < v177 || v173 * v59 < v177) {
              return result;
            }
          }
LABEL_549:
          float v178 = *(void **)(a1 + 40);
          if (v178)
          {
            while (!(*(unsigned int (**)(void))(**(void **)(*v178 + 96) + 696))(*(void *)(*v178 + 96))
                 || (*(unsigned int (**)(void, void))(**(void **)(*v178 + 96) + 568))(*(void *)(*v178 + 96), *a2)&& !*(unsigned char *)(*v178 + 522))
            {
              float v178 = (void *)v178[1];
              if (!v178) {
                goto LABEL_554;
              }
            }
            return 23;
          }
          else
          {
LABEL_554:
            if ((*(float (**)(uint64_t))(*(void *)a1 + 976))(a1) == 0.0)
            {
              return 0;
            }
            else
            {
              *(unsigned char *)(a1 + 28196) = 1;
              return 32;
            }
          }
        }
        return 15;
      }
    }
  }
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::needs_overdrive(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28175);
}

float CA::WindowServer::IOMFBDisplay::luma_boost_scale(CA::WindowServer::IOMFBDisplay *this)
{
  return *((float *)this + 6660);
}

uint64_t CA::WindowServer::Display::update_clones(CA::WindowServer::Display *this, CA::Render::Update *a2, unsigned int *a3)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  BOOL v70 = 0;
  __n128 v3 = (uint64_t *)*((void *)this + 5);
  if (!v3)
  {
    BOOL v59 = 0;
    char v5 = 0;
    goto LABEL_91;
  }
  char v5 = 0;
  do
  {
    uint64_t v6 = *v3;
    int v71 = 0;
    CARecordCurrentDisplay::CARecordCurrentDisplay((CARecordCurrentDisplay *)&v71, *(_DWORD *)(*(void *)(v6 + 96) + 24));
    float64x2_t v7 = (pthread_mutex_t *)(*(void *)(v6 + 96) + 496);
    if (pthread_mutex_trylock(v7))
    {
      LOBYTE(v8) = -17;
      goto LABEL_33;
    }
    float64x2_t v9 = (pthread_mutex_t *)(v6 + 24);
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 24));
    float64x2_t v10 = *(unsigned char **)(v6 + 96);
    if ((v10[56] & 0x20) != 0)
    {
      uint64_t v18 = mach_absolute_time();
      double v19 = CATimeWithHostTime(v18);
      if (CA::WindowServer::Server::replay_render((CA::WindowServer::Server *)v6, v19, this, &v70)) {
        LOBYTE(v8) = -18;
      }
      else {
        LOBYTE(v8) = 0;
      }
      goto LABEL_32;
    }
    unsigned int v8 = (*(uint64_t (**)(unsigned char *, uint64_t, CA::WindowServer::Display *, CA::Render::Update *, unsigned int *, BOOL *))(*(void *)v10 + 672))(v10, v6, this, a2, a3, &v70);
    if (CADeviceHasInternalBuild::once[0] != -1) {
      dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
    }
    if (!CADeviceHasInternalBuild::internal || !v8 || v8 == 234 || v8 == 243) {
      goto LABEL_32;
    }
    uint64_t v11 = mach_absolute_time();
    double v12 = CATimeWithHostTime(v11);
    double v13 = v12 - *(double *)(v6 + 504);
    if (v13 > 1.0)
    {
      *(double *)(v6 + 504) = v12;
      double v13 = v12 - v12;
    }
    BOOL v14 = v8 == 235 || v8 == 237;
    BOOL v15 = v14 || v8 >= 0xFE;
    BOOL v16 = v15 || v8 == 244;
    BOOL v17 = !v16;
    if (v13 >= 0.05) {
      goto LABEL_32;
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      if (v17) {
        os_log_type_t v23 = OS_LOG_TYPE_ERROR;
      }
      else {
        os_log_type_t v23 = OS_LOG_TYPE_DEFAULT;
      }
      log = x_log_category_windowserver;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, v23))
      {
        uint64_t v24 = *(void *)(v6 + 96);
        int v25 = *(_DWORD *)(v24 + 24);
        LODWORD(v24) = *(_DWORD *)(v24 + 25380);
        *(_DWORD *)long long buf = 67109632;
        *(_DWORD *)int v73 = v25;
        *(_WORD *)&v73[4] = 1024;
        *(_DWORD *)&v73[6] = v8;
        LOWORD(v74) = 1024;
        *(_DWORD *)((char *)&v74 + 2) = v24;
        _os_log_impl(&dword_184668000, log, v23, "display %u clone_update failed with status 0x%x, skipped_cloned_frame_count=%u", buf, 0x14u);
      }
    }
    if (v8 != 255) {
      goto LABEL_32;
    }
    loga = (os_unfair_lock_s *)(v6 + 16);
    os_unfair_lock_lock((os_unfair_lock_t)(v6 + 16));
    uint64_t v26 = *(void *)(v6 + 128);
    if (v26)
    {
      int v27 = 0;
      unsigned int v28 = 0;
      int v29 = *(void **)(v6 + 112);
      unsigned int v30 = v29;
      do
      {
        uint64_t v31 = *v30;
        v30 += 2;
        int v32 = *(_DWORD *)(v31 + 12);
        if (v28) {
          BOOL v33 = 0;
        }
        else {
          BOOL v33 = (v32 & 0x20000) == 0;
        }
        if (v33) {
          unsigned int v28 = v29;
        }
        v27 += (v32 & 0x20000) == 0;
        int v29 = v30;
        --v26;
      }
      while (v26);
      int v34 = *(unsigned __int8 **)(*(void *)(v6 + 96) + 728);
      uint64_t v6 = *v34;
      uint64_t v35 = v34[1];
      if (v28)
      {
        uint64_t v64 = v35;
        if (x_log_hook_p())
        {
          uint64_t v36 = *v28;
          if (!atomic_load((unsigned int *)(*v28 + 228)))
          {
            if (*(_DWORD *)(v36 + 252)) {
              pid_t v38 = 0;
            }
            else {
              pid_t v38 = getpid();
            }
            int v54 = 0;
            atomic_compare_exchange_strong((atomic_uint *volatile)(v36 + 228), (unsigned int *)&v54, v38);
          }
          CA::Render::Context::process_path((CA::Render::Context *)*v28);
LABEL_82:
          x_log_();
          goto LABEL_89;
        }
        uint64_t v63 = x_log_category_windowserver;
        if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v47 = "unknown";
          if (v6 <= 0xB) {
            uint64_t v47 = off_1E5273AC0[v6];
          }
          int v62 = v47;
          uint64_t v48 = "unknown";
          if (v64 <= 0xB) {
            uint64_t v48 = off_1E5273AC0[v64];
          }
          double v65 = v48;
          uint64_t v49 = (CA::Render::Context *)*v28;
          int v50 = *(_DWORD *)(*v28 + 16);
          float v51 = *((float *)v28 + 2);
          unsigned int v52 = atomic_load((unsigned int *)(*v28 + 228));
          if (!v52)
          {
            int v61 = *(_DWORD *)(*v28 + 16);
            if (*((_DWORD *)v49 + 63)) {
              pid_t v53 = 0;
            }
            else {
              pid_t v53 = getpid();
            }
            unsigned int v52 = 0;
            atomic_compare_exchange_strong((atomic_uint *volatile)v49 + 57, &v52, v53);
            if (!v52) {
              unsigned int v52 = v53;
            }
            int v50 = v61;
          }
          double v55 = (CA::Render::Context *)*v28;
          unsigned int v56 = v52;
          int v57 = v50;
          double v58 = CA::Render::Context::process_path(v55);
          *(_DWORD *)long long buf = 136316674;
          *(void *)int v73 = v62;
          *(_WORD *)&v73[8] = 2080;
          uint64_t v44 = v63;
          unint64_t v74 = v65;
          __int16 v75 = 1024;
          int v76 = v27;
          __int16 v77 = 1024;
          int v78 = v57;
          __int16 v79 = 2048;
          double v80 = v51;
          __int16 v81 = 1024;
          unsigned int v82 = v56;
          __int16 v83 = 2080;
          long long v84 = v58 + 7;
          BOOL v45 = "display_state: %s %s, context 1/%d: %x: level %g; pid %d [%s]";
          uint32_t v46 = 60;
LABEL_88:
          _os_log_impl(&dword_184668000, v44, OS_LOG_TYPE_DEFAULT, v45, buf, v46);
          goto LABEL_89;
        }
        goto LABEL_89;
      }
      unsigned int v40 = v35;
    }
    else
    {
      unint64_t v39 = *(unsigned __int8 **)(*(void *)(v6 + 96) + 728);
      LODWORD(v6) = *v39;
      unsigned int v40 = v39[1];
    }
    if (x_log_hook_p()) {
      goto LABEL_82;
    }
    uint64_t v41 = x_log_category_windowserver;
    if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v42 = "unknown";
      if (v6 <= 0xB) {
        uint64_t v42 = off_1E5273AC0[v6];
      }
      int v43 = "unknown";
      if (v40 <= 0xB) {
        int v43 = off_1E5273AC0[v40];
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)int v73 = v42;
      *(_WORD *)&v73[8] = 2080;
      unint64_t v74 = v43;
      uint64_t v44 = v41;
      BOOL v45 = "display_state: %s %s, no contexts";
      uint32_t v46 = 22;
      goto LABEL_88;
    }
LABEL_89:
    os_unfair_lock_unlock(loga);
    LOBYTE(v8) = -1;
LABEL_32:
    pthread_mutex_unlock(v9);
    pthread_mutex_unlock(v7);
LABEL_33:
    unsigned __int16 v20 = pthread_getspecific(current_display_slot);
    if (v20 && *v20) {
      --*v20;
    }
    uint64_t v21 = 0;
    while (CA::WindowServer::Display::update_clones(CA::Render::Update *,unsigned int &)::no_retry_statuses[v21] != v8)
    {
      if (++v21 == 7)
      {
        unsigned __int16 v22 = (char *)&unk_18499AEE7;
        goto LABEL_41;
      }
    }
    unsigned __int16 v22 = &CA::WindowServer::Display::update_clones(CA::Render::Update *,unsigned int &)::no_retry_statuses[v21];
LABEL_41:
    v5 |= v22 - CA::WindowServer::Display::update_clones(CA::Render::Update *,unsigned int &)::no_retry_statuses == 7;
    __n128 v3 = (uint64_t *)v3[1];
  }
  while (v3);
  BOOL v59 = v70;
LABEL_91:
  CA::WindowServer::Display::update_clone_flags(this, v59);
  return v5 & 1;
}

uint64_t CA::WindowServer::Display::update_clone_flags(CA::WindowServer::Display *this, int a2)
{
  int v3 = *((_DWORD *)this + 156);
  if (!a2)
  {
    if ((v3 & 4) != 0)
    {
      atomic_fetch_and((atomic_uint *volatile)this + 156, 0xFFFFFFFB);
      goto LABEL_7;
    }
LABEL_5:
    int v4 = 0;
    goto LABEL_8;
  }
  if ((v3 & 4) != 0) {
    goto LABEL_5;
  }
  atomic_fetch_or((atomic_uint *volatile)this + 156, 4u);
LABEL_7:
  int v4 = 1;
LABEL_8:
  uint64_t result = (*(uint64_t (**)(CA::WindowServer::Display *))(*(void *)this + 696))(this);
  int v6 = *((_DWORD *)this + 156);
  if (!result)
  {
    if ((v6 & 0x80) != 0)
    {
      atomic_fetch_and((atomic_uint *volatile)this + 156, 0xFFFFFF7F);
      goto LABEL_15;
    }
LABEL_12:
    if (!v4) {
      return result;
    }
    goto LABEL_15;
  }
  if ((v6 & 0x80) != 0) {
    goto LABEL_12;
  }
  atomic_fetch_or((atomic_uint *volatile)this + 156, 0x80u);
LABEL_15:

  return CA::WindowServer::Display::post_display_changed((uint64_t)this);
}

BOOL CA::WindowServer::IOMFBDisplay::cloning_active(CA::WindowServer::IOMFBDisplay *this)
{
  return *((void *)this + 80)
      && (uint64_t v1 = *((void *)this + 6)) != 0
      && (*(unsigned char *)(*(void *)(v1 + 96) + 747) & 1) == 0
      && !*((unsigned char *)this + 28132)
      && *((unsigned char *)this + 28134) == 0;
}

void CA::ScalerUtil::ScalerLimits::limits(CA::ScalerUtil::ScalerLimits *this)
{
  {
  }
  if (CA::ScalerUtil::ScalerLimits::limits(void)::onceToken[0] != -1)
  {
    dispatch_once(CA::ScalerUtil::ScalerLimits::limits(void)::onceToken, &__block_literal_global_467);
  }
}

int32x4_t *CA::Bounds::set_both(int32x4_t *this, const Rect *a2, CA::Bounds *a3, CA::Bounds *a4, float64x2_t a5, float64x2_t a6)
{
  int64x2_t v6 = vceqzq_f64(a6);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), (int8x16_t)v6).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v7 = vorrq_s8((int8x16_t)vcltzq_f64(a6), (int8x16_t)vcgezq_f64(a6)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v7), 1), v7).u64[0] & 0x8000000000000000) != 0))
  {
    this->i64[0] = 0;
    this->i64[1] = 0;
    *a2 = 0;
    a2[1] = 0;
  }
  else
  {
    float64x2_t v8 = vmaxnmq_f64(a5, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000));
    float64x2_t v9 = vminnmq_f64(vaddq_f64(a5, a6), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
    int32x4_t v10 = (int32x4_t)vcvtmq_s64_f64(v8);
    *this = vuzp1q_s32(v10, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v9), (int64x2_t)v10));
    int32x4_t v11 = (int32x4_t)vcvtpq_s64_f64(v8);
    *(int32x4_t *)&a2->top = vuzp1q_s32(v11, (int32x4_t)vsubq_s64(vcvtmq_s64_f64(v9), (int64x2_t)v11));
  }
  return this;
}

uint64_t CA::WindowServer::IOSurface::color_primaries(IOSurfaceRef *this)
{
  uint64_t result = *((unsigned int *)this + 68);
  if (!result)
  {
    CFTypeRef v3 = IOSurfaceCopyValue(this[30], (CFStringRef)*MEMORY[0x1E4F2F048]);
    if (v3)
    {
      int v4 = v3;
      if (CFEqual(v3, (CFTypeRef)*MEMORY[0x1E4F2F058]))
      {
        int v5 = 2;
      }
      else if (CFEqual(v4, (CFTypeRef)*MEMORY[0x1E4F2F060]))
      {
        int v5 = 4;
      }
      else
      {
        if (!CFEqual(v4, (CFTypeRef)*MEMORY[0x1E4F2F050]))
        {
LABEL_13:
          CFRelease(v4);
          return *((unsigned int *)this + 68);
        }
        int v5 = 8;
      }
      *((_DWORD *)this + 68) = v5;
      goto LABEL_13;
    }
    int BulkAttachments = IOSurfaceGetBulkAttachments();
    uint64_t result = 2;
    if (!BulkAttachments) {
      uint64_t result = 2;
    }
    *((_DWORD *)this + 68) = 2;
  }
  return result;
}

BOOL CA::WindowServer::IOSurface::check_alignment(CA::WindowServer::IOSurface *this, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = *((unsigned int *)this + 73);
  unint64_t v4 = v3 % a2;
  unint64_t v5 = (a2 - 1) & v3;
  if ((a2 & (a2 - 1)) != 0) {
    unint64_t v5 = v4;
  }
  if (v5) {
    return 0;
  }
  unint64_t v7 = *((unsigned int *)this + 74);
  if ((a3 & (a3 - 1)) != 0) {
    unint64_t v8 = v7 % a3;
  }
  else {
    unint64_t v8 = (a3 - 1) & v7;
  }
  return v8 == 0;
}

uint64_t CA::WindowServer::IOSurface::colorspace(CA::WindowServer::IOSurface *this)
{
  return *((void *)this + 35);
}

uint64_t CA::WindowServer::Display::all_clones_support_pq(CA::WindowServer::Display *this)
{
  if (!this) {
    return 1;
  }
  uint64_t v1 = this;
  do
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(*(void *)v1 + 96) + 168))(*(void *)(*(void *)v1 + 96));
    if ((result & 1) == 0) {
      break;
    }
    uint64_t v1 = (CA::WindowServer::Display *)*((void *)v1 + 1);
  }
  while (v1);
  return result;
}

uint64_t CA::WindowServer::AppleDisplay::supports_hlg(CA::WindowServer::AppleDisplay *this)
{
  return (*((unsigned __int16 *)this + 14272) >> 6) & 1;
}

BOOL CA::WindowServer::AppleDisplay::supports_pq(CA::WindowServer::AppleDisplay *this)
{
  if ((*((_WORD *)this + 328) & 0x1C00) == 0x800) {
    return ((*((void *)this + 80) >> 55) & 0x1E) - 16 < 0xA;
  }
  else {
    return (*((unsigned __int16 *)this + 14272) >> 7) & 1;
  }
}

uint64_t CA::WindowServer::Display::clones_support_detaching(CA::WindowServer::Display *this)
{
  if (!this) {
    return 1;
  }
  uint64_t v1 = this;
  while (1)
  {
    if ((*(unsigned int (**)(void))(**(void **)(*(void *)v1 + 96) + 696))(*(void *)(*(void *)v1 + 96)))
    {
      uint64_t v2 = *(void *)(*(void *)v1 + 96);
      if ((*(unsigned char *)(v2 + 745) & 0x40) == 0 && (*(_DWORD *)(v2 + 624) & 2) != 0) {
        break;
      }
    }
    uint64_t v1 = (CA::WindowServer::Display *)*((void *)v1 + 1);
    if (!v1) {
      return 1;
    }
  }
  return 0;
}

uint64_t CA::WindowServer::IOSurface::cache_mode(CA::WindowServer::IOSurface *this)
{
  uint64_t result = *((unsigned int *)this + 65);
  if (result == -1)
  {
    uint64_t result = IOSurfaceGetCacheMode();
    *((_DWORD *)this + 65) = result;
  }
  return result;
}

uint64_t CA::ScalerStatistics::should_enhance(CA::ScalerStatistics *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = NSSelectorFromString(&cfstr_Shouldenhancew.isa);
  uint64_t v10 = MEMORY[0x1E4F143A8];
  uint64_t v11 = 3221225472;
  double v12 = ___ZN2CA16ScalerStatistics14should_enhanceEmmmm_block_invoke;
  double v13 = &__block_descriptor_40_e5_v8__0l;
  BOOL v14 = v8;
  if (CA::ScalerStatistics::should_enhance(unsigned long,unsigned long,unsigned long,unsigned long)::once != -1) {
    dispatch_once(&CA::ScalerStatistics::should_enhance(unsigned long,unsigned long,unsigned long,unsigned long)::once, &v10);
  }
  if (CA::ScalerStatistics::should_enhance(unsigned long,unsigned long,unsigned long,unsigned long)::exists) {
    return (uint64_t)objc_msgSend((id)objc_opt_class(), v8, this, a2, a3, a4, v10, v11, v12, v13, v14, v15);
  }
  else {
    return 1;
  }
}

double CA::WindowServer::Display::minmax_clone_scale(CA::WindowServer::Display *this)
{
  uint64_t v1 = (void *)*((void *)this + 5);
  if (!v1) {
    return 1.79769313e308;
  }
  double v3 = 0.0;
  double v4 = 1.79769313e308;
  double v5 = 0.0;
  double v6 = 1.79769313e308;
  do
  {
    uint64_t v7 = *v1;
    double v8 = 0.0;
    double v9 = 0.0;
    if ((*(_DWORD *)(*(void *)(*v1 + 96) + 624) & 2) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v7 + 24));
      double v8 = (*(double (**)(void, CA::WindowServer::Display *))(**(void **)(v7 + 96) + 688))(*(void *)(v7 + 96), this);
      double v9 = v10;
      pthread_mutex_unlock((pthread_mutex_t *)(v7 + 24));
    }
    if (v8 > v5) {
      double v5 = v8;
    }
    if (v9 > v3) {
      double v3 = v9;
    }
    if (v8 < v6) {
      double v6 = v8;
    }
    if (v9 < v4) {
      double v4 = v9;
    }
    uint64_t v1 = (void *)v1[1];
  }
  while (v1);
  return v6;
}

CA::Render::GroupAnimation *CA::Render::GroupAnimation::GroupAnimation(CA::Render::GroupAnimation *this, CA::Render::Decoder *a2)
{
  double v4 = CA::Render::Animation::Animation(this, a2);
  *((unsigned char *)v4 + 12) = 21;
  ++dword_1EB2ADE1C;
  *(void *)double v4 = &unk_1ED02DDF0;
  *((void *)this + 12) = CA::Render::Decoder::decode_array_object(a2, 6, CA::Render::animation_types, 0);
  return this;
}

CA::Render::MatchAnimation *CA::Render::MatchAnimation::MatchAnimation(CA::Render::MatchAnimation *this, CA::Render::Decoder *a2)
{
  *(void *)CA::Render::Animation::Animation(this, a2) = &unk_1ED02DEA8;
  *((void *)this + 12) = CA::Render::Decoder::decode_size_t(a2);
  *((void *)this + 13) = CA::Render::Decoder::decode_size_t(a2);
  *((_DWORD *)this + 28) = CA::Render::Decoder::decode_int32(a2);
  *((void *)this + 15) = CA::Render::Decoder::decode_keypath(a2);
  *((void *)this + 16) = 0;
  return this;
}

CA::Render::TransitionAnimation *CA::Render::TransitionAnimation::TransitionAnimation(CA::Render::TransitionAnimation *this, CA::Render::Decoder *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  double v4 = CA::Render::Animation::Animation(this, a2);
  *((unsigned char *)v4 + 12) = 55;
  ++dword_1EB2ADEA4;
  *(void *)double v4 = &unk_1ED02EBE0;
  *((_DWORD *)this + 23) = CA::Render::Decoder::decode_atom(a2);
  *((_DWORD *)this + 24) = CA::Render::Decoder::decode_atom(a2);
  *((_DWORD *)this + 25) = CA::Render::Decoder::decode_int32(a2);
  *((_DWORD *)this + 26) = CA::Render::Decoder::decode_int32(a2);
  *((void *)this + 14) = CA::Render::Decoder::decode_object(a2, 17);
  int v9 = 28;
  double v5 = CA::Render::Decoder::decode_array_object(a2, 1, &v9, 0);
  if (v5)
  {
    double v6 = v5 + 2;
    uint64_t v7 = v5;
    if (!atomic_fetch_add(v5 + 2, 1u))
    {
      uint64_t v7 = 0;
      atomic_fetch_add(v6, 0xFFFFFFFF);
    }
    *((void *)this + 15) = v7;
    if (atomic_fetch_add(v6, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
    }
  }
  else
  {
    *((void *)this + 15) = 0;
  }
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  return this;
}

CA::Render::KeyframeAnimation *CA::Render::KeyframeAnimation::KeyframeAnimation(CA::Render::KeyframeAnimation *this, CA::Render::Decoder *a2)
{
  double v4 = CA::Render::PropertyAnimation::PropertyAnimation(this, a2);
  *((unsigned char *)v4 + 12) = 27;
  ++dword_1EB2ADE34;
  *(void *)double v4 = &unk_1ED02E758;
  *((void *)this + 14) = CA::Render::Decoder::decode_object(a2, 1);
  *((void *)this + 15) = CA::Render::Decoder::decode_object(a2, 56);
  *((void *)this + 16) = CA::Render::Decoder::decode_object(a2, 56);
  *((void *)this + 17) = CA::Render::Decoder::decode_object(a2, 36);
  unsigned int v5 = CA::Render::Decoder::decode_int8(a2);
  if (v5 >= 5)
  {
    CA::Render::Decoder::set_fatal_error(a2, "%s - enum %u out of range of %u", "decode_int8_enum", v5, 5);
    LOBYTE(v5) = 0;
  }
  *((unsigned char *)this + 144) = v5;
  *((void *)this + 19) = CA::Render::Decoder::decode_object(a2, 56);
  *((void *)this + 2CA::Context::unref(this[1], 0) = CA::Render::Decoder::decode_object(a2, 56);
  *((void *)this + 2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = CA::Render::Decoder::decode_object(a2, 56);
  return this;
}

CA::Render::SpringAnimation *CA::Render::SpringAnimation::SpringAnimation(CA::Render::SpringAnimation *this, CA::Render::Decoder *a2)
{
  double v4 = CA::Render::BasicAnimation0::BasicAnimation0(this, a2);
  *((unsigned char *)v4 + 12) = 48;
  ++dword_1EB2ADE88;
  *(void *)double v4 = &unk_1ED02E310;
  *((void *)this + 19) = CA::Render::Decoder::decode_int64(a2);
  *((void *)this + 2CA::Context::unref(this[1], 0) = CA::Render::Decoder::decode_int64(a2);
  *((void *)this + 2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = CA::Render::Decoder::decode_int64(a2);
  *((void *)this + 22) = CA::Render::Decoder::decode_int64(a2);
  return this;
}

CA::Render::BasicAnimation0 *CA::Render::BasicAnimation::BasicAnimation(CA::Render::BasicAnimation *this, CA::Render::Decoder *a2)
{
  uint64_t result = CA::Render::BasicAnimation0::BasicAnimation0(this, a2);
  *((unsigned char *)result + 12) = 5;
  ++dword_1EB2ADDDC;
  *(void *)uint64_t result = &unk_1ED02DD28;
  return result;
}

CA::Render::BasicAnimation0 *CA::Render::BasicAnimation0::BasicAnimation0(CA::Render::BasicAnimation0 *this, CA::Render::Decoder *a2)
{
  *(void *)CA::Render::PropertyAnimation::PropertyAnimation(this, a2) = &unk_1ED02DF68;
  *((void *)this + 14) = CA::Render::Decoder::decode_object(a2, 0);
  *((void *)this + 15) = CA::Render::Decoder::decode_object(a2, 0);
  *((void *)this + 16) = CA::Render::Decoder::decode_object(a2, 0);
  *((void *)this + 17) = CA::Render::Decoder::decode_int64(a2);
  *((void *)this + 18) = CA::Render::Decoder::decode_int64(a2);
  return this;
}

CA::Render::PropertyAnimation *CA::Render::PropertyAnimation::PropertyAnimation(CA::Render::PropertyAnimation *this, CA::Render::Decoder *a2)
{
  *(void *)CA::Render::Animation::Animation(this, a2) = &unk_1ED02E820;
  *((void *)this + 12) = CA::Render::Decoder::decode_keypath(a2);
  *((void *)this + 13) = CA::Render::Decoder::decode_object(a2, 18);
  return this;
}

CA::Render::Animation *CA::Render::Animation::Animation(CA::Render::Animation *this, CA::Render::Decoder *a2)
{
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = *((unsigned __int8 *)this + 12) | (CA::Render::Decoder::decode_int32(a2) << 8);
  *(void *)this = &unk_1ED030030;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 5) = CA::Render::Decoder::decode_object(a2, 52);
  *((void *)this + 6) = CA::Render::Decoder::decode_object(a2, 56);
  CFStringGetTypeID();
  *((void *)this + 7) = CA::Render::Decoder::decode_cfobject(a2);
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = CA::Render::Decoder::decode_int32(a2);
  *(void *)((char *)this + 84) = 0;
  *(void *)((char *)this + 76) = 0;
  *((float *)this + 6) = (float)CA::Render::Decoder::decode_int32(a2);
  *((float *)this + 7) = (float)CA::Render::Decoder::decode_int32(a2);
  *((float *)this + 8) = (float)CA::Render::Decoder::decode_int32(a2);
  *((_DWORD *)this + 22) = CA::Render::Decoder::decode_int32(a2);
  double v4 = (const void *)*((void *)this + 7);
  if (v4) {
    *((void *)this + 8) = CFHash(v4);
  }
  return this;
}

__CFArray *CA::Render::Decoder::decode_cfobject(CA::Render::Decoder *this)
{
  MEMORY[0x1F4188790](this);
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)v1 + 18)) {
    return 0;
  }
  uint64_t v3 = v2;
  double v4 = v1;
  switch(CA::Render::Decoder::decode_int8(v1))
  {
    case 1u:
      goto LABEL_3;
    case 2u:
      if (!CA::Render::Decoder::decode_int8(v4)) {
        return 0;
      }
      bzero(&context, 0x1000uLL);
      CFIndex length = 0;
      double v6 = (const char *)CA::Render::Decoder::decode_data(v4, &context, 0x1000uLL, (unint64_t *)&length, 0);
      if (!v6) {
        goto LABEL_73;
      }
      uint64_t v7 = (CFAllocatorContext *)v6;
      CFIndex v8 = length - 1;
      if ((unint64_t)(length - 1) >= 0xFFF) {
        CFIndex v8 = 4095;
      }
      if (length) {
        CFIndex v9 = v8;
      }
      else {
        CFIndex v9 = 0;
      }
      v6[v9] = 0;
      CFDictionaryRef Mutable = (__CFArray *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF98], v6, 0x8000100u);
      if (v7 == &context) {
        goto LABEL_81;
      }
      uint64_t v11 = v7;
      goto LABEL_40;
    case 3u:
      int v12 = CA::Render::Decoder::decode_int8(v4);
      if (v12 == 1)
      {
        context.version = CA::Render::Decoder::decode_int64(v4);
        CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF98];
        CFNumberType v14 = kCFNumberLongLongType;
      }
      else
      {
        if (v12)
        {
          CA::Render::Decoder::set_fatal_error(v4, "%s - wrong unsigned int type = %u");
          return 0;
        }
        context.version = CA::Render::Decoder::decode_int64(v4);
        CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF98];
        CFNumberType v14 = kCFNumberDoubleType;
      }
      CFNumberRef v25 = CFNumberCreate(v13, v14, &context);
      goto LABEL_80;
    case 4u:
      int v15 = CA::Render::Decoder::decode_int8(v4);
      unsigned int v5 = (__CFArray **)MEMORY[0x1E4F1CFD0];
      if (!v15) {
        unsigned int v5 = (__CFArray **)MEMORY[0x1E4F1CFC8];
      }
      goto LABEL_18;
    case 5u:
      uint64_t v48 = 0;
      CFIndex length = 0;
      uint64_t v47 = 0;
      BOOL v16 = (const UInt8 *)CA::Render::Decoder::decode_data_async(v4, (unint64_t *)&length, (void (__cdecl **)(void *))&v48, &v47);
      CFIndex v17 = length;
      if (length)
      {
        uint64_t v18 = v16;
        if (!v16)
        {
          CA::Render::Decoder::set_fatal_error(v4, "%s - data = NULL, data_len = %zu");
          goto LABEL_73;
        }
        if (v48)
        {
          context.version = 0;
          memset(&context.retain, 0, 40);
          context.info = v47;
          context.deallocate = (CFAllocatorDeallocateCallBack)v48;
          context.preferredSize = 0;
          CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFAllocatorRef v20 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &context);
          CFDictionaryRef Mutable = CFDataCreateWithBytesNoCopy(v19, v18, v17, v20);
          CFRelease(v20);
          goto LABEL_81;
        }
        CFAllocatorRef v37 = (const __CFAllocator *)*MEMORY[0x1E4F1CF98];
        pid_t v38 = v18;
        CFIndex v39 = length;
      }
      else
      {
        CFAllocatorRef v37 = (const __CFAllocator *)*MEMORY[0x1E4F1CF98];
        pid_t v38 = 0;
        CFIndex v39 = 0;
      }
      CFNumberRef v25 = CFDataCreate(v37, v38, v39);
      goto LABEL_80;
    case 6u:
      unint64_t v21 = CA::Render::Decoder::decode_size_t(v4);
      if (!v21)
      {
        CFNumberRef v25 = CFArrayCreate(0, 0, 0, 0);
        goto LABEL_80;
      }
      unint64_t v22 = v21;
      if (v21 > 0x8000)
      {
        CA::Render::Decoder::set_fatal_error(v4, "%s - array entries = %zu");
        return 0;
      }
      CFDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
      do
      {
        unsigned int v40 = (const void *)CA::Render::Decoder::decode_cfobject(v4, 0);
        if (v40)
        {
          uint64_t v41 = v40;
          CFArrayAppendValue(Mutable, v40);
          CFRelease(v41);
        }
        else
        {
          CA::Render::Decoder::set_fatal_error(v4, "%s - value = NULL", "decode_cfobject");
        }
        --v22;
      }
      while (v22);
      goto LABEL_81;
    case 7u:
      unint64_t v23 = CA::Render::Decoder::decode_size_t(v4);
      if (!v23)
      {
        CFNumberRef v25 = CFDictionaryCreate(0, 0, 0, 0, 0, 0);
LABEL_80:
        CFDictionaryRef Mutable = v25;
        goto LABEL_81;
      }
      unint64_t v24 = v23;
      if (v23 > 0x8000)
      {
        CA::Render::Decoder::set_fatal_error(v4, "%s - dicitionary entries = %zu");
        return 0;
      }
      CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      do
      {
        uint64_t v42 = (const void *)CA::Render::Decoder::decode_cfobject(v4, 0);
        int v43 = (const void *)CA::Render::Decoder::decode_cfobject(v4, 0);
        uint64_t v44 = v43;
        if (v42)
        {
          int v43 = v42;
          if (v44)
          {
            CFDictionarySetValue(Mutable, v42, v44);
            CFRelease(v42);
            CFRelease(v44);
            goto LABEL_68;
          }
LABEL_66:
          CFRelease(v43);
          CA::Render::Decoder::set_fatal_error(v4, "%s - key = %p, value = %p", "decode_cfobject", v42, v44);
          goto LABEL_68;
        }
        if (v43) {
          goto LABEL_66;
        }
        CA::Render::Decoder::set_fatal_error(v4, "%s - key = %p, value = %p", "decode_cfobject", 0, 0);
LABEL_68:
        --v24;
      }
      while (v24);
      if ((*((unsigned char *)v4 + 18) & 1) == 0) {
        goto LABEL_81;
      }
LABEL_84:
      CFRelease(Mutable);
      return 0;
    case 8u:
      CFNumberRef v25 = CA::Render::Decoder::decode_colorspace(v4);
      goto LABEL_80;
    case 9u:
      int v26 = CA::Render::Decoder::decode_int8(v4);
      if (v26 == 23)
      {
        int v29 = (atomic_uint *)CA::Render::Decoder::decode_object(v4, 23);
        CFDictionaryRef Mutable = CA::Render::Image::copy_cgimage((CA::Render::Image *)v29);
        if (!v29) {
          goto LABEL_81;
        }
        goto LABEL_51;
      }
      int v27 = v26;
      if (v26 == 51)
      {
LABEL_32:
        uint64_t v28 = CA::Render::Decoder::decode_object(v4, 51);
        int v29 = (atomic_uint *)v28;
        CFDictionaryRef Mutable = *(__CFArray **)(v28 + 112);
        if (Mutable) {
          CFRetain(*(CFTypeRef *)(v28 + 112));
        }
LABEL_51:
        if (atomic_fetch_add(v29 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v29 + 16))(v29);
        }
        goto LABEL_81;
      }
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        BOOL v45 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(context.version) = 67109120;
          HIDWORD(context.version) = v27;
          _os_log_impl(&dword_184668000, v45, OS_LOG_TYPE_DEFAULT, "decode kCACFTypeImage got unsupported type %d", (uint8_t *)&context, 8u);
        }
      }
LABEL_3:
      unsigned int v5 = (__CFArray **)MEMORY[0x1E4F1D260];
LABEL_18:
      CFDictionaryRef Mutable = *v5;
      goto LABEL_81;
    case 0xAu:
      context.version = 0;
      context.info = 0;
      CA::Render::Decoder::decode_bytes(v4, &context, 0x10uLL);
      float64x2_t v30 = vcvtq_f64_f32((float32x2_t)context.info);
      *(float64x2_t *)&context.version = vcvtq_f64_f32((float32x2_t)context.version);
      *(float64x2_t *)&context.retain = v30;
      uint64_t v31 = (CGColorSpace *)CAGetColorSpace(0x1Cu);
      CFNumberRef v25 = CGColorCreate(v31, (const CGFloat *)&context.version);
      goto LABEL_80;
    case 0xBu:
      goto LABEL_32;
    case 0xCu:
      unsigned int v32 = CA::Render::Decoder::decode_int8(v4);
      if (v32 >= 8)
      {
        CA::Render::Decoder::set_fatal_error(v4, "%s - incorrect type %d");
        return 0;
      }
      uint64_t v33 = qword_184998D98[v32];
      int v34 = off_1E5272518[v32];
      CFIndex length = 0;
      uint64_t v35 = (CFAllocatorContext *)CA::Render::Decoder::decode_data(v4, &context, 0xA0uLL, (unint64_t *)&length, 0xA0uLL);
      if (v35)
      {
        uint64_t v36 = v35;
        if (v33 == length)
        {
          CFDictionaryRef Mutable = (__CFArray *)[objc_alloc(MEMORY[0x1E4F29238]) initWithBytes:v35 objCType:v34];
          if (v36 != &context)
          {
            uint64_t v11 = v36;
LABEL_40:
            free(v11);
          }
LABEL_81:
          if (v3 && Mutable && CFGetTypeID(Mutable) != v3) {
            goto LABEL_84;
          }
          return Mutable;
        }
        CA::Render::Decoder::set_fatal_error(v4, "%s - size mismatch %zu - %zu", "decode_ns_value", v33, length);
        if (v36 != &context) {
          free(v36);
        }
      }
      else
      {
        CA::Render::Decoder::set_fatal_error(v4, "%s - data ptr = NULL");
      }
LABEL_73:
      CFDictionaryRef Mutable = 0;
      goto LABEL_81;
    case 0xDu:
      int v29 = (atomic_uint *)CA::Render::Decoder::decode_object(v4, 36);
      CFDictionaryRef Mutable = (__CFArray *)CA::Render::Path::cg_path((CA::Render::Path *)v29);
      CGPathRetain(Mutable);
      if (!v29) {
        goto LABEL_81;
      }
      goto LABEL_51;
    default:
      return 0;
  }
}

void *CA::Render::Decoder::decode_data(CA::Render::Decoder *this, void *a2, size_t a3, unint64_t *a4, size_t a5)
{
  if (*((unsigned char *)this + 18)) {
    return 0;
  }
  uint64_t v9 = a3 <= a5 ? a5 : a3;
  size_t v10 = a5 ? v9 : -1;
  size_t v11 = CA::Render::Decoder::decode_size_t(this);
  if (!v11) {
    return 0;
  }
  size_t v12 = v11;
  if (*((unsigned char *)this + 64))
  {
    if (v11 == -1)
    {
LABEL_11:
      uint64_t v13 = *((void *)this + 6);
      if (!v13 || *(_DWORD *)(v13 + 8) != 1)
      {
        CA::Render::Decoder::set_fatal_error(this, "%s - _attach_list = %p, unsigned int type = %u");
        return 0;
      }
      if (*(void *)(v13 + 24) > v10)
      {
        CA::Render::Decoder::set_fatal_error(this, "%s - max_size = %zu, size = %zu");
        return 0;
      }
      uint64_t v15 = *((void *)this + 7) - 1;
      *((void *)this + 6) = *(void *)v13;
      *((void *)this + 7) = v15;
      *a4 = *(void *)(v13 + 24);
      BOOL v16 = *(void (__cdecl **)(void *))(v13 + 32);
      if (!v16 || v16 == CA::Render::release_free) {
        return *(void **)(v13 + 16);
      }
      size_t v17 = *(void *)(v13 + 24);
      if (v17 > a3) {
        a2 = malloc_type_malloc(v17, 0xE43D2620uLL);
      }
      if (a2) {
        memcpy(a2, *(const void **)(v13 + 16), *(void *)(v13 + 24));
      }
      else {
        CA::Render::Decoder::set_fatal_error(this, "%s - long long buf = NULL", "decode_data");
      }
      (*(void (**)(void, void))(v13 + 32))(*(void *)(v13 + 16), *(void *)(v13 + 40));
      return a2;
    }
  }
  else if (v11 == 0xFFFFFFFF)
  {
    goto LABEL_11;
  }
  if (v11 > v10)
  {
    CA::Render::Decoder::set_fatal_error(this, "%s - max_size = %zu, tag = %zu");
    return 0;
  }
  if (v11 > 0x10000000) {
    goto LABEL_23;
  }
  if (v11 > a3) {
    a2 = malloc_type_malloc(v11, 0xF1A80491uLL);
  }
  if (a2)
  {
    CA::Render::Decoder::decode_bytes(this, a2, v12);
  }
  else
  {
LABEL_23:
    CA::Render::Decoder::set_fatal_error(this, "%s - long long buf = NULL, size = %zu", "decode_data", v12);
    a2 = 0;
  }
  *a4 = v12;
  return a2;
}

void CA::OGL::Renderer::render(CA::OGL::Renderer *this, const CA::Render::Update *a2, unint64_t a3, CA::WindowServer::SharedEvent *a4)
{
  MEMORY[0x1F4188790](this);
  uint64_t v614 = *MEMORY[0x1E4F143B8];
  if (v4[1]) {
    return;
  }
  uint64_t v7 = v6;
  uint64_t v8 = v5;
  uint64_t v9 = v4;
  v4[1] = v5;
  *((unsigned char *)v4 + 10CA::Context::unref(this[1], 0) = 0;
  v4[11] = 0;
  uint64_t v10 = *v4;
  *(void *)(v10 + 216) = v5;
  int v11 = *(_DWORD *)(v5 + 256);
  *(_DWORD *)(v10 + 228) = *(_DWORD *)(v5 + 248);
  *(_DWORD *)(v10 + 232) = v11;
  uint64_t v12 = mach_absolute_time();
  *(double *)(v10 + 24CA::Context::unref(this[1], 0) = CATimeWithHostTime(v12);
  uint64_t v13 = (_WORD *)*v9;
  *((_DWORD *)v13 + 177) = 0;
  x_hash_table_remove_all(*((void **)v13 + 36));
  *((void *)v13 + 37) = 0;
  *((_DWORD *)v13 + 178) = *((void *)v13 + 33) == *((void *)v13 + 34);
  *(_OWORD *)(v13 + 358) = 0u;
  *((_DWORD *)v13 + 183) = 0;
  v13[416] &= 0xFC7Fu;
  *(_OWORD *)(v13 + 372) = 0u;
  *(_OWORD *)(v13 + 38CA::Context::unref(this[1], 0) = 0u;
  *(_OWORD *)(v13 + 388) = 0u;
  *(_OWORD *)(v13 + 396) = 0u;
  *((_DWORD *)v13 + 202) = 0;
  CFNumberType v14 = (_WORD *)*v9;
  uint64_t v15 = *(void *)(*v9 + 192);
  if (v15 && (v14[416] & 2) == 0)
  {
    (*(void (**)(void, void (*)(CA::OGL::Renderer *, CA::Render::Handle *, CA::Render::Texture *, CA::OGL::Context **, void *), void *))(*(void *)v15 + 80))(*(void *)(*v9 + 192), CA::OGL::Renderer::update_detached_layer, v9);
    CFNumberType v14 = (_WORD *)*v9;
  }
  (*(void (**)(_WORD *, void))(*(void *)v14 + 184))(v14, 0);
  unint64_t v17 = v9[2];
  uint64_t v18 = *(void *)(*v9 + 192);
  if (v18)
  {
    uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
    if (v17)
    {
LABEL_7:
      uint64_t v20 = *v9;
LABEL_10:
      double v21 = (double)CA::Shape::area((CA::Shape *)v17);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v19 = 0;
    if (v17) {
      goto LABEL_7;
    }
  }
  unint64_t v17 = *(void *)(v8 + 16);
  uint64_t v20 = *v9;
  if (v17) {
    goto LABEL_10;
  }
  int v41 = *(_DWORD *)(v20 + 208);
  int v42 = *(_DWORD *)(v20 + 212);
  if (v41 <= v42) {
    int v43 = *(_DWORD *)(v20 + 212);
  }
  else {
    int v43 = *(_DWORD *)(v20 + 208);
  }
  *(double *)v16.i64 = (double)v42 * (double)v41;
  if (v43 <= 1073741822) {
    double v21 = (double)v42 * (double)v41;
  }
  else {
    double v21 = INFINITY;
  }
LABEL_11:
  if (v17)
  {
    if (v17 == 1) {
      goto LABEL_13;
    }
  }
  else if (*(_DWORD *)(v17 + 4) == 6)
  {
LABEL_13:
    LODWORD(v22) = 0;
    goto LABEL_21;
  }
  uint64_t v22 = *(void *)(v20 + 424);
  *(void *)(v20 + 424) = 0;
  if (v22)
  {
    unint64_t v23 = CA::Shape::Union(v17, v22);
    unint64_t v17 = v23;
    if ((*(unsigned char *)(*v9 + 432) & 0x10) != 0)
    {
      if (v23)
      {
        if (v23 != 1) {
          goto LABEL_20;
        }
        goto LABEL_19;
      }
      if (*(_DWORD *)(v23 + 4) != 12)
      {
LABEL_19:
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        CA::Shape::get_bounds(v23, (int *)buf);
        CA::Shape::unref((CA::Shape *)v17);
        unint64_t v17 = CA::Shape::new_shape((unsigned int *)buf);
      }
    }
LABEL_20:
    CA::Shape::unref((CA::Shape *)v22);
    uint64_t v20 = *v9;
    LODWORD(v22) = 1;
  }
LABEL_21:
  if ((*(unsigned char *)(v20 + 434) & 2) != 0)
  {
    *(void *)long long buf = CA::Shape::map((CA::Shape *)v17, 0, (void (*)(CA::Rect *, void *))CA::OGL::Renderer::render(CA::Render::Update const*,unsigned long,CA::WindowServer::SharedEvent *)::$_0::__invoke, v16);
    CA::shape_intersect((CA::Shape **)buf, (CA::Shape **)(*v9 + 200), v24);
    if (v22) {
      CA::Shape::unref((CA::Shape *)v17);
    }
    unint64_t v17 = *(void *)buf;
    LODWORD(v22) = 1;
  }
  v9[3] = v17;
  uint64_t j = v9 + 3;
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  CA::Shape::get_bounds(v17, (int *)buf);
  *((_OWORD *)v9 + 2) = *(_OWORD *)buf;
  if (v17)
  {
    if (v17 == 1) {
      goto LABEL_433;
    }
  }
  else if (*(_DWORD *)(v17 + 4) == 6)
  {
    goto LABEL_433;
  }
  if ((*(unsigned int (**)(void))(*(void *)*v9 + 208))())
  {
    int v528 = v22;
    uint64_t v26 = v9[6];
    *(void *)uint64_t v26 = 0;
    *(void *)(v26 + 8) = v26 + 32;
    *(_OWORD *)(v26 + 16) = xmmword_184997E60;
    v9[7] = v26;
    bzero(v580, 0x3D0uLL);
    CA::OGL::Context::prepare_context(*v9, (uint64_t)v580);
    int v27 = (void *)*v9;
    v27[15] = buf;
    v27[17] = 128;
    v9[9] = 0;
    v9[10] = 0;
    v9[8] = 0;
    uint64_t v574 = 0x3C003C003C003C00;
    uint64_t v575 = 0;
    uint64_t v576 = 0;
    uint64_t v577 = 0;
    uint64_t v578 = 0x5033F800000;
    uint64_t v570 = 0;
    uint64_t v572 = 0;
    double v573 = (float64x2_t *)&CA::identity_transform;
    int32x4_t v571 = (CA::Shape *)v17;
    (*(void (**)(void))(*v27 + 1008))();
    uint64_t bounds = (*(uint64_t (**)(void))(*(void *)*v9 + 952))();
    uint64_t v33 = *v9;
    if ((*(unsigned char *)(*v9 + 433) & 4) == 0) {
      goto LABEL_38;
    }
    uint64_t v34 = *(void *)(v33 + 264);
    if (v34 && (*(unsigned char *)(v34 + 68) & 0x30) != 0)
    {
      uint64_t v35 = (CA::Shape *)&CA::Shape::_infinite_shape;
      int v36 = 1;
      if (&CA::Shape::_infinite_shape) {
        goto LABEL_34;
      }
    }
    else
    {
      int v36 = 0;
      if (*(void *)(v8 + 8)) {
        uint64_t v35 = *(CA::Shape **)(v8 + 8);
      }
      else {
        uint64_t v35 = (CA::Shape *)&CA::Shape::_infinite_shape;
      }
      if (v35)
      {
LABEL_34:
        if (v35 == (CA::Shape *)1) {
          goto LABEL_36;
        }
        goto LABEL_35;
      }
    }
    if (*((_DWORD *)v35 + 1) == 6)
    {
LABEL_36:
      if (v36) {
        CA::Shape::unref(v35);
      }
LABEL_38:
      uint64_t v529 = v7;
      if (*(void *)(v8 + 224) == v8 + 216) {
        goto LABEL_341;
      }
      uint64_t v594 = 0;
      long long v592 = 0u;
      long long v593 = 0u;
      long long v590 = 0u;
      long long v591 = 0u;
      long long v588 = 0u;
      long long v589 = 0u;
      long long v586 = 0u;
      long long v587 = 0u;
      long long v585 = 0u;
      memset(v584, 0, sizeof(v584));
      memset(v582, 0, sizeof(v582));
      memset(v581, 0, sizeof(v581));
      WORD5(v582[0]) = 771;
      float64x2_t v583 = 0uLL;
      uint64_t v595 = 0;
      __int16 v562 = 0;
      uint64_t bounds = (uint64_t)CA::OGL::prepare_layers((uint64_t)v9, (const CA::Render::TransitionSubclass *)v581, (void **)(v8 + 216), (uint64_t)&v570, 0, &v562, (unsigned char *)&v562 + 1);
      if (!bounds)
      {
LABEL_340:
        uint64_t v7 = v529;
LABEL_341:
        if (BYTE10(xmmword_1EB2ACBF0))
        {
          if (v19
            && (unint64_t v343 = *(CA::Shape **)(v8 + 32), (*(unsigned int (**)(uint64_t))(*(void *)v19 + 1544))(v19)))
          {
            memset(v582, 0, sizeof(v582));
            memset(v581, 0, sizeof(v581));
            if (CA::Shape::rect_count(v343) >= 32) {
              unint64_t v344 = 1;
            }
            else {
              unint64_t v344 = 4;
            }
            uint64_t bounds = CA::Shape::coalesce(v343, v581, v344);
            v31.i64[0] = *(void *)(*v9 + 208);
            int v347 = v31.i32[0];
            if (v31.i32[0] <= v31.i32[1]) {
              int v347 = HIDWORD(*(void *)(*v9 + 208));
            }
            if (bounds)
            {
              uint64_t v348 = bounds;
              uint64_t v349 = *(void *)(*v9 + 200);
              v350.i64[0] = (int)v349;
              v350.i64[1] = SHIDWORD(v349);
              v345.i32[0] = v347;
              v346.i32[0] = 1073741822;
              int8x16_t v351 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v345, v346), 0);
              int8x16_t v352 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
              float64x2_t v547 = (float64x2_t)vbslq_s8(v351, v352, (int8x16_t)vcvtq_f64_s64(v350));
              int8x16_t v559 = v352;
              v350.i64[0] = v31.i32[0];
              v350.i64[1] = v31.i32[1];
              int8x16_t v353 = (int8x16_t)vcvtq_f64_s64(v350);
              int32x2_t v354 = vdup_n_s32(v347 > 1073741822);
              v350.i64[0] = v354.u32[0];
              v350.i64[1] = v354.u32[1];
              float32x4_t v31 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v350, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v353);
              *(float32x4_t *)v538 = v31;
              uint64_t v355 = (int *)((unint64_t)v581 | 0xC);
              v31.i32[0] = 1073741822;
              int32x4_t v531 = (int32x4_t)v31;
              do
              {
                int v356 = *(v355 - 1);
                int v357 = *v355;
                if (v356 <= *v355) {
                  int v358 = *v355;
                }
                else {
                  int v358 = *(v355 - 1);
                }
                v31.i32[0] = v358;
                uint64_t v359 = *(void *)(v355 - 3);
                v360.i64[0] = (int)v359;
                v360.i64[1] = SHIDWORD(v359);
                int8x16_t v361 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32((int32x4_t)v31, v531), 0), v559, (int8x16_t)vcvtq_f64_s64(v360));
                double v362 = (double)v356;
                if (v358 > 1073741822) {
                  double v362 = 1.79769313e308;
                }
                int8x16_t v609 = v361;
                if (v358 <= 1073741822) {
                  double v363 = (double)v357;
                }
                else {
                  double v363 = 1.79769313e308;
                }
                *(double *)v610.i64 = v362;
                *(double *)&v610.i64[1] = v363;
                CA::BoundsImpl::intersect((uint64_t)&v609, v547, *(float64x2_t *)v538);
                v566[0] = (CA::Shape *)&v609;
                v566[1] = (CA::Shape *)&CA::identity_transform;
                float64x2_t v567 = 0u;
                long long v568 = 0u;
                uint64_t bounds = CA::OGL::fill_color_rect(*v9, (uint64_t)v566, (double *)0x80408080, v364, 0.0, v365);
                v355 += 4;
                --v348;
              }
              while (v348);
            }
            uint64_t v7 = v529;
            uint64_t j = v9 + 3;
          }
          else
          {
            uint64_t v389 = *v9;
            int v390 = *(_DWORD *)(*v9 + 208);
            int v391 = *(_DWORD *)(*v9 + 212);
            if (v390 <= v391) {
              int v392 = *(_DWORD *)(*v9 + 212);
            }
            else {
              int v392 = *(_DWORD *)(*v9 + 208);
            }
            v31.i32[0] = 1073741822;
            v32.i32[0] = v392;
            int8x16_t v393 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v32, (int32x4_t)v31), 0);
            uint64_t v394 = *(void *)(v389 + 200);
            v395.i64[0] = (int)v394;
            v395.i64[1] = SHIDWORD(v394);
            int8x16_t v396 = (int8x16_t)vcvtq_f64_s64(v395);
            *(int8x16_t *)v566 = vbslq_s8(v393, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v396);
            if (v392 <= 1073741822) {
              double v397 = (double)v390;
            }
            else {
              double v397 = 1.79769313e308;
            }
            if (v392 <= 1073741822) {
              *(double *)v396.i64 = (double)v391;
            }
            else {
              *(double *)v396.i64 = 1.79769313e308;
            }
            v567.f64[0] = v397;
            *(void *)&v567.f64[1] = v396.i64[0];
            v581[0].i64[0] = (uint64_t)v566;
            v581[0].i64[1] = (uint64_t)&CA::identity_transform;
            v581[1] = 0u;
            v582[0] = 0u;
            uint64_t bounds = CA::OGL::fill_color_rect(v389, (uint64_t)v581, (double *)0x80408080, v30, 0.0, v396);
            uint64_t v7 = v529;
            uint64_t j = v9 + 3;
          }
        }
        uint64_t v22 = *v9;
        if ((*(_WORD *)(*v9 + 832) & 2) != 0 && byte_1EB2ACC03)
        {
          int v398 = *(_DWORD *)(v22 + 208);
          int v399 = *(_DWORD *)(v22 + 212);
          if (v398 <= v399) {
            int v400 = *(_DWORD *)(v22 + 212);
          }
          else {
            int v400 = *(_DWORD *)(v22 + 208);
          }
          v31.i32[0] = 1073741822;
          v32.i32[0] = v400;
          int8x16_t v401 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v32, (int32x4_t)v31), 0);
          uint64_t v402 = *(void *)(v22 + 200);
          v403.i64[0] = (int)v402;
          v403.i64[1] = SHIDWORD(v402);
          int8x16_t v404 = (int8x16_t)vcvtq_f64_s64(v403);
          *(int8x16_t *)v566 = vbslq_s8(v401, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v404);
          double v405 = 1.79769313e308;
          if (v400 <= 1073741822) {
            double v406 = (double)v398;
          }
          else {
            double v406 = 1.79769313e308;
          }
          if (v400 <= 1073741822) {
            double v405 = (double)v399;
          }
          v567.f64[0] = v406;
          v567.f64[1] = v405;
          v581[0].i64[0] = (uint64_t)v566;
          v581[0].i64[1] = (uint64_t)&CA::identity_transform;
          v581[1] = 0u;
          v582[0] = 0u;
          *(double *)v404.i64 = (double)v399;
          uint64_t bounds = CA::OGL::fill_color_rect(v22, (uint64_t)v581, (double *)0x80008080, v30, 0.0, v404);
          uint64_t v22 = *v9;
        }
        if (BYTE14(xmmword_1EB2ACC70))
        {
          if ((*(_WORD *)(v22 + 832) & 2) == 0)
          {
            uint64_t v366 = *(void *)(v22 + 264);
            if (v366)
            {
              int v367 = *(_DWORD *)(v366 + 68);
              int v368 = *(_DWORD *)(v22 + 208);
              int v369 = *(_DWORD *)(v22 + 212);
              if (v368 <= v369) {
                int v370 = *(_DWORD *)(v22 + 212);
              }
              else {
                int v370 = *(_DWORD *)(v22 + 208);
              }
              v31.i32[0] = 1073741822;
              v32.i32[0] = v370;
              int8x16_t v371 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v32, (int32x4_t)v31), 0);
              uint64_t v372 = *(void *)(v22 + 200);
              v373.i64[0] = (int)v372;
              v373.i64[1] = SHIDWORD(v372);
              int8x16_t v374 = (int8x16_t)vcvtq_f64_s64(v373);
              *(int8x16_t *)v566 = vbslq_s8(v371, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v374);
              if (v370 <= 1073741822) {
                double v375 = (double)v368;
              }
              else {
                double v375 = 1.79769313e308;
              }
              if (v370 <= 1073741822) {
                *(double *)v374.i64 = (double)v369;
              }
              else {
                *(double *)v374.i64 = 1.79769313e308;
              }
              v567.f64[0] = v375;
              *(void *)&v567.f64[1] = v374.i64[0];
              v581[0].i64[0] = (uint64_t)v566;
              v581[0].i64[1] = (uint64_t)&CA::identity_transform;
              v581[1] = 0u;
              v582[0] = 0u;
              if ((v367 & 8) != 0) {
                uint64_t v376 = 2147483776;
              }
              else {
                uint64_t v376 = 8388736;
              }
              uint64_t bounds = CA::OGL::fill_color_rect(v22, (uint64_t)v581, (double *)v376, v30, 0.0, v374);
              uint64_t v22 = *v9;
            }
          }
          uint64_t j = v9 + 3;
        }
        if (((*(unsigned int *)(v8 + 1084) | ((unint64_t)*(unsigned __int16 *)(v8 + 1088) << 32)) & 0x200000000) != 0
          && BYTE2(xmmword_1EB2ACC50))
        {
          int v407 = *(_DWORD *)(v22 + 208);
          int v408 = *(_DWORD *)(v22 + 212);
          if (v407 <= v408) {
            int v409 = *(_DWORD *)(v22 + 212);
          }
          else {
            int v409 = *(_DWORD *)(v22 + 208);
          }
          v31.i32[0] = 1073741822;
          v32.i32[0] = v409;
          int8x16_t v410 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v32, (int32x4_t)v31), 0);
          uint64_t v411 = *(void *)(v22 + 200);
          v412.i64[0] = (int)v411;
          v412.i64[1] = SHIDWORD(v411);
          int8x16_t v413 = (int8x16_t)vcvtq_f64_s64(v412);
          *(int8x16_t *)v566 = vbslq_s8(v410, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v413);
          double v414 = 1.79769313e308;
          if (v409 <= 1073741822) {
            double v415 = (double)v407;
          }
          else {
            double v415 = 1.79769313e308;
          }
          if (v409 <= 1073741822) {
            double v414 = (double)v408;
          }
          v567.f64[0] = v415;
          v567.f64[1] = v414;
          v581[0].i64[0] = (uint64_t)v566;
          v581[0].i64[1] = (uint64_t)&CA::identity_transform;
          v581[1] = 0u;
          v582[0] = 0u;
          *(double *)v413.i64 = (double)v408;
          uint64_t bounds = CA::OGL::fill_color_rect(v22, (uint64_t)v581, (double *)0x80800080, v30, 0.0, v413);
          uint64_t v22 = *v9;
        }
        if (v19)
        {
          if ((*(_WORD *)(v22 + 832) & 2) == 0)
          {
            uint64_t bounds = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v19 + 528))(v19, v8);
            uint64_t v22 = *v9;
            if (bounds)
            {
              v583.f64[0] = 0.0;
              memset(v582, 0, sizeof(v582));
              memset(v581, 0, sizeof(v581));
              uint64_t v265 = *(void *)(v22 + 248);
              *(int8x16_t *)((char *)v581 + 8) = *(int8x16_t *)(v265 + 8);
              uint64_t v266 = *(void *)(v265 + 32);
              v581[1].i64[1] = *(void *)(v265 + 24);
              *(void *)&v582[0] = v266;
              *(_OWORD *)((char *)v582 + 8) = *(_OWORD *)(v265 + 40);
              *((void *)&v582[1] + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(void *)(v265 + 56);
              __int16 v267 = *(unsigned __int8 *)(v265 + 68);
              WORD2(v583.f64[0]) = v267;
              LODWORD(v583.f64[0]) = *(_DWORD *)(v265 + 64);
              WORD2(v583.f64[0]) = *(_WORD *)(v265 + 68) & 0x100 | v267;
              WORD2(v583.f64[0]) |= *(_WORD *)(v265 + 68) & 0x400;
              v581[0].i64[1] = bounds;
              uint64_t v268 = CA::OGL::Context::set_gstate(v22, (uint64_t)v581);
              uint64_t v271 = *v9;
              int v272 = *(_DWORD *)(*v9 + 208);
              int v273 = *(_DWORD *)(*v9 + 212);
              if (v272 <= v273) {
                int v274 = *(_DWORD *)(*v9 + 212);
              }
              else {
                int v274 = *(_DWORD *)(*v9 + 208);
              }
              v269.i32[0] = 1073741822;
              v270.i32[0] = v274;
              int8x16_t v275 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v270, v269), 0);
              v581[0].i64[0] = v268;
              uint64_t v276 = *(void *)(v271 + 200);
              v277.i64[0] = (int)v276;
              v277.i64[1] = SHIDWORD(v276);
              int8x16_t v278 = vbslq_s8(v275, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v277));
              double v279 = (double)v272;
              double v280 = (double)v273;
              if (v274 > 1073741822)
              {
                double v279 = 1.79769313e308;
                double v280 = 1.79769313e308;
              }
              int8x16_t v609 = v278;
              *(double *)v610.i64 = v279;
              *(double *)&v610.i64[1] = v280;
              v566[0] = (CA::Shape *)&v609;
              v566[1] = (CA::Shape *)&CA::identity_transform;
              float64x2_t v567 = 0u;
              long long v568 = 0u;
              float64x2_t v281 = (double *)(*(uint64_t (**)(uint64_t))(*(void *)v19 + 536))(v19);
              CA::OGL::fill_color_rect(v271, (uint64_t)v566, v281, v282, v283, v284);
              uint64_t bounds = CA::OGL::Context::set_gstate(*v9, **(void **)(*v9 + 248));
              if (!BYTE3(ca_debug_options)) {
                uint64_t bounds = usleep(0x186A0u);
              }
              uint64_t v22 = *v9;
            }
          }
        }
        unint64_t v285 = *(unsigned int *)(v8 + 1084) | ((unint64_t)*(unsigned __int16 *)(v8 + 1088) << 32);
        if ((*(_WORD *)(v22 + 832) & 1) != 0
          || (v285 & 0x200000004) == 4
          || (*(_DWORD *)(v8 + 1084) & 0x80000000) != 0)
        {
          goto LABEL_395;
        }
        *(void *)&long long v585 = 0;
        float64x2_t v287 = *v573;
        float64x2_t v286 = v573[1];
        float64x2_t v288 = v573[2];
        float64x2_t v289 = v573[3];
        v581[0] = *(int8x16_t *)v573;
        v581[1] = (int8x16_t)v286;
        v582[0] = v288;
        v582[1] = v289;
        float64x2_t v290 = v573[4];
        float64x2_t v291 = v573[5];
        float64x2_t v292 = v573[6];
        float64x2_t v293 = v573[7];
        float64x2_t v583 = v290;
        v584[0] = v291;
        v584[1] = v292;
        v584[2] = v293;
        float64x2_t v294 = v573[8];
        v584[3] = v294;
        char v295 = LOBYTE(v573[9].f64[0]);
        *(void *)&long long v585 = v295 & 0x1F;
        if (initialized != -1)
        {
          float64x2_t v548 = v287;
          float64x2_t v560 = v288;
          float64x2_t v532 = v286;
          *(float64x2_t *)int v539 = v289;
          float64x2_t v525 = v291;
          float64x2_t v527 = v290;
          *(float64x2_t *)v523 = v294;
          dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
          float64x2_t v294 = *(float64x2_t *)v523;
          float64x2_t v291 = v525;
          float64x2_t v290 = v527;
          float64x2_t v286 = v532;
          float64x2_t v289 = *(float64x2_t *)v539;
          float64x2_t v287 = v548;
          float64x2_t v288 = v560;
        }
        if (*(float *)&dword_1EB2ACAFC > 0.0 && *(float *)&dword_1EB2ACAFC != 1.0)
        {
          *(double *)&uint64_t v296 = *(float *)&dword_1EB2ACAFC;
          if ((v295 & 0x10) != 0)
          {
            v581[0] = (int8x16_t)vmulq_n_f64(v287, *(double *)&v296);
            v581[1] = (int8x16_t)vmulq_n_f64(v286, *(double *)&v296);
            v582[0] = vmulq_n_f64(v288, *(double *)&v296);
            v582[1] = vmulq_n_f64(v289, *(double *)&v296);
            float64x2_t v583 = v290;
            v584[0] = v291;
          }
          else
          {
            *(double *)&long long v297 = vmulq_n_f64(v294, *(double *)&v296).f64[0];
            *((void *)&v297 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(void *)&vdivq_f64(v294, (float64x2_t)vdupq_lane_s64(v296, 0)).f64[1];
            v584[3] = v297;
            LOBYTE(v585) = v295 & 0x17 | (8 * (*(double *)&v297 != 1.0));
            v581[0] = (int8x16_t)vmulq_n_f64(v287, *(double *)&v296);
            v582[0] = vmulq_n_f64(v288, *(double *)&v296);
          }
        }
        if (BYTE5(xmmword_1EB2ACBF0))
        {
          uint64_t v427 = (const CA::Transform **)*v9;
          uint64_t v428 = *(unsigned int *)(v8 + 248);
          unsigned int v429 = *(_DWORD *)(*v9 + 448);
          if (v429 >= 0xB) {
            unsigned int v429 = 11;
          }
          unsigned int v430 = CA::OGL::kDetailGroups[v429];
          BOOL v432 = v429 == 6 || *(_DWORD *)(*v9 + 452) != 0;
          uint64_t PerfHud = CA::OGL::GetPerfHud((CA::OGL *)bounds);
          CA::OGL::update_perf_hud_pstate(PerfHud, v430);
          if (*(_DWORD *)(PerfHud + 1132)) {
            *(void *)(PerfHud + 1104) = *((int *)v427 + 53) * (uint64_t)*((int *)v427 + 52);
          }
          float v435 = 1.0 / *(float *)(v8 + 372);
          CA::Render::Update::render_edr_factor((CA::Render::Update *)v8, v434);
          float v436 = 1.0 / *(float *)(v8 + 1076);
          *(double *)(PerfHud + 488) = v435;
          *(double *)(PerfHud + 496) = v437;
          *(double *)(PerfHud + 504) = v436;
          v438 = v427[24];
          if (v438)
          {
            v439 = (CA::WindowServer::Display *)(*(uint64_t (**)(const CA::Transform *))(*(void *)v438 + 16))(v438);
            if (CADeviceNeedsDisplayWorkarounds::once[0] != -1) {
              dispatch_once(CADeviceNeedsDisplayWorkarounds::once, &__block_literal_global_73);
            }
            BOOL v549 = v439 != 0;
            if (CADeviceNeedsDisplayWorkarounds::needs_workarounds && v439) {
              *(double *)(PerfHud + 52CA::Context::unref(this[1], 0) = (double)(*(unsigned int (**)(CA::WindowServer::Display *))(*(void *)v439 + 1504))(v439);
            }
            if (CADeviceNeedsLumaBoost::once[0] != -1) {
              dispatch_once(CADeviceNeedsLumaBoost::once, &__block_literal_global_76);
            }
            if (CADeviceNeedsLumaBoost::needs_luma_bost && v439)
            {
              *(double *)(PerfHud + 528) = (*(float (**)(CA::WindowServer::Display *))(*(void *)v439 + 976))(v439);
              BOOL v549 = 1;
            }
          }
          else
          {
            if (CADeviceNeedsDisplayWorkarounds::once[0] != -1) {
              dispatch_once(CADeviceNeedsDisplayWorkarounds::once, &__block_literal_global_73);
            }
            if (CADeviceNeedsLumaBoost::once[0] != -1) {
              dispatch_once(CADeviceNeedsLumaBoost::once, &__block_literal_global_76);
            }
            v439 = 0;
            BOOL v549 = 0;
          }
          if (CADeviceSupportsTwilight::once != -1) {
            dispatch_once(&CADeviceSupportsTwilight::once, &__block_literal_global_304_12248);
          }
          BOOL v471 = v549;
          if (!CADeviceSupportsTwilight::twilight) {
            BOOL v471 = 0;
          }
          if (v471 && !byte_1EB2ACC63)
          {
            if ((*(float (**)(CA::WindowServer::Display *))(*(void *)v439 + 1272))(v439) > 1.0
              || (float v472 = (*(float (**)(CA::WindowServer::Display *))(*(void *)v439 + 1272))(v439),
                  double v473 = 0.0,
                  v472 >= 0.0))
            {
              float v474 = (*(float (**)(CA::WindowServer::Display *))(*(void *)v439 + 1272))(v439);
              double v473 = 1.0;
              if (v474 <= 1.0) {
                double v473 = (*(float (**)(CA::WindowServer::Display *))(*(void *)v439 + 1272))(v439);
              }
            }
            *(double *)(PerfHud + 536) = v473;
            if ((*(float (**)(CA::WindowServer::Display *))(*(void *)v439 + 1288))(v439) > 1.0
              || (float v475 = (*(float (**)(CA::WindowServer::Display *))(*(void *)v439 + 1288))(v439),
                  double v476 = 0.0,
                  v475 >= 0.0))
            {
              float v477 = (*(float (**)(CA::WindowServer::Display *))(*(void *)v439 + 1288))(v439);
              double v476 = 1.0;
              if (v477 <= 1.0) {
                double v476 = (*(float (**)(CA::WindowServer::Display *))(*(void *)v439 + 1288))(v439);
              }
            }
            *(double *)(PerfHud + 544) = v476;
          }
          if (CADeviceSupportsBandwidthStatistics::once[0] != -1) {
            dispatch_once(CADeviceSupportsBandwidthStatistics::once, &__block_literal_global_328);
          }
          int v478 = v430 | 1;
          BOOL v479 = v549;
          if (!CADeviceSupportsBandwidthStatistics::bw_stats) {
            BOOL v479 = 0;
          }
          if (v479)
          {
            double v480 = (*(double (**)(CA::WindowServer::Display *))(*(void *)v439 + 1968))(v439);
            double v481 = (*(double (**)(CA::WindowServer::Display *))(*(void *)v439 + 1976))(v439);
            double v482 = (*(double (**)(CA::WindowServer::Display *))(*(void *)v439 + 1984))(v439);
            (*(void (**)(CA::WindowServer::Display *))(*(void *)v439 + 1992))(v439);
            double v484 = v480 / v481;
            if (v481 == 0.0) {
              double v484 = v481;
            }
            *(double *)(PerfHud + 672) = v480 * 0.000001;
            *(double *)(PerfHud + 68CA::Context::unref(this[1], 0) = v481 * 0.000001;
            *(double *)(PerfHud + 696) = v482 * 0.000001;
            *(double *)(PerfHud + 704) = v483 * 0.000001;
            if (v483 != 0.0) {
              double v483 = v482 / v483;
            }
            *(double *)(PerfHud + 688) = v484;
            *(double *)(PerfHud + 712) = v483;
          }
          if (v549)
          {
            float v485 = (*(float (**)(CA::WindowServer::Display *))(*(void *)v439 + 920))(v439);
            *(double *)(PerfHud + 512) = (float)(CA::WindowServer::Display::edr_headroom(v439) * v485);
            if (CADeviceSupportsRTPLC::once[0] != -1) {
              dispatch_once(CADeviceSupportsRTPLC::once, &__block_literal_global_301);
            }
            if (CADeviceSupportsRTPLC::rtplc)
            {
              *(double *)(PerfHud + 72CA::Context::unref(this[1], 0) = (*(double (**)(CA::WindowServer::Display *))(*(void *)v439
                                                                                                 + 2000))(v439);
              *(void *)(PerfHud + 728) = (*(unsigned int (**)(CA::WindowServer::Display *))(*(void *)v439 + 2008))(v439);
              *(void *)(PerfHud + 736) = (*(unsigned int (**)(CA::WindowServer::Display *))(*(void *)v439 + 2016))(v439);
            }
          }
          else if (CADeviceSupportsRTPLC::once[0] != -1)
          {
            dispatch_once(CADeviceSupportsRTPLC::once, &__block_literal_global_301);
          }
          float v486 = (*((double (**)(const CA::Transform **))*v427 + 136))(v427) * 1000.0;
          *(void *)(PerfHud + 664) = (unint64_t)(float)(*(float *)&CA::OGL::PerformanceHUD::_scale_ms_to_ticks
                                                               * v486);
          *(_DWORD *)(PerfHud + 4136) = v478;
          CA::OGL::PerformanceHUD::layout((CA::OGL::PerformanceHUD *)PerfHud);
          uint64_t v487 = 4088;
          if (v432) {
            uint64_t v487 = 4080;
          }
          *(void *)(PerfHud + 4128) = *(void *)(PerfHud + v487);
          unsigned int v488 = CA::OGL::PerformanceHUD::calculate_fps((CA::OGL::PerformanceHUD *)PerfHud, *(double *)(v8 + 72));
          uint64_t v489 = *(void *)(PerfHud + 392);
          *(void *)(PerfHud + 384) += v488;
          *(void *)(PerfHud + 392) = v489 + *(unsigned int *)(v8 + 276);
          uint64_t v490 = *(void *)(PerfHud + 424) + (uint64_t)v21;
          *(void *)(PerfHud + 416) += *((int *)v427 + 178);
          *(void *)(PerfHud + 424) = v490;
          *(void *)(PerfHud + 432) = v428;
          *(void *)(PerfHud + 60CA::Context::unref(this[1], 0) = CA::OGL::thermal_level;
          *(void *)(PerfHud + 744) = *(int *)(v8 + 492);
          *(void *)(PerfHud + 752) = *(int *)(v8 + 488);
          *(void *)(PerfHud + 76CA::Context::unref(this[1], 0) = *(int *)(v8 + 496);
          CA::OGL::PerformanceHUD::update((CA::OGL::PerformanceHUD *)PerfHud);
          uint64_t v491 = (CA::OGL::Context *)(PerfHud + 3976);
          CA::OGL::DebugRenderer::render((uint64_t)v491, (CA::OGL::Context *)v427, (const CA::Transform *)v581, 0);
          v566[0] = 0;
          v566[1] = 0;
          CA::OGL::DebugRenderer::visible_bounds((CA::OGL::DebugRenderer *)v566, v491, v427[24], (uint64_t)v581);
          if (v427[53]) {
            CA::shape_union(v427 + 53, v566, v492);
          }
          else {
            v427[53] = (const CA::Transform *)CA::Shape::new_shape((unsigned int *)v566);
          }
        }
        else
        {
          os_unfair_lock_lock(&CA::OGL::_perf_hud_list_lock);
          int32x2_t v298 = CA::OGL::_perf_hud_list[0];
          long long v299 = off_1E8F83CF0[0];
          if (CA::OGL::_perf_hud_list[0] != off_1E8F83CF0[0])
          {
            do
            {
              uint64_t v300 = *((void *)v298 + 1);
              if (v300)
              {
                CA::OGL::DebugRenderer::~DebugRenderer((CA::OGL::DebugRenderer *)(v300 + 3976));
                for (uint64_t i = 3800; i != 728; i -= 64)
                {
                  v302 = *(void **)(v300 + i);
                  if (v302)
                  {
                    if (*v302) {
                      MEMORY[0x185323DA0](*v302, 0x1000C80F7F8B94BLL);
                    }
                    MEMORY[0x185323DC0](v302, 0x20C40960023A9);
                  }
                }
                MEMORY[0x185323DC0](v300, 0x1070C40BA178129);
              }
              v298 += 4;
            }
            while (v298 != v299);
            off_1E8F83CF0[0] = CA::OGL::_perf_hud_list[0];
            notify_cancel(CA::OGL::thermal_level_register_token);
            if (CA::OGL::update_perf_hud_pstate(CA::OGL::PerformanceHUD *,unsigned int)::pstate) {
              BOOL v303 = CA::OGL::update_perf_hud_pstate(CA::OGL::PerformanceHUD *,unsigned int)::pstate_destroy == 0;
            }
            else {
              BOOL v303 = 1;
            }
            if (!v303)
            {
              CA::OGL::update_perf_hud_pstate(CA::OGL::PerformanceHUD *,unsigned int)::pstate_current_options = 0;
              CA::OGL::update_perf_hud_pstate(CA::OGL::PerformanceHUD *,unsigned int)::pstate_destroy();
              CA::OGL::update_perf_hud_pstate(CA::OGL::PerformanceHUD *,unsigned int)::pstate = 0;
            }
          }
          os_unfair_lock_unlock(&CA::OGL::_perf_hud_list_lock);
        }
        uint64_t v304 = *v9;
        uint32x2_t v305 = CAGetDebugMessage();
        uint64_t v7 = v529;
        if (initialized != -1) {
          dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
        }
        int32x2_t v307 = (_DWORD *)(v8 + 1084);
        unsigned int v308 = debug_message_color;
        if (CA::OGL::Context::update_debug_message(CA::Transform const*)::once != -1)
        {
          dispatch_once(&CA::OGL::Context::update_debug_message(CA::Transform const*)::once, &__block_literal_global_3289);
          int32x2_t v307 = (_DWORD *)(v8 + 1084);
        }
        if (CA::OGL::Context::update_debug_message(CA::Transform const*)::show_message && v305)
        {
          uint64_t v440 = *(void *)(v304 + 192);
          if (v440) {
            uint64_t v441 = (*(uint64_t (**)(uint64_t))(*(void *)v440 + 16))(v440);
          }
          else {
            uint64_t v441 = 0;
          }
          if ((*(_WORD *)(v441 + 656) & 0x1C00) != 0)
          {
            uint64_t v551 = 0;
            int v493 = 0;
            int v494 = *(_DWORD *)(v304 + 208);
            float v495 = 0.0;
            float v496 = 3.0;
          }
          else
          {
            if (CADeviceIsPhone::once[0] != -1) {
              dispatch_once(CADeviceIsPhone::once, &__block_literal_global_193);
            }
            if (CADeviceIsPhone::phone)
            {
              if (CADeviceHasNotch::once != -1) {
                dispatch_once(&CADeviceHasNotch::once, &__block_literal_global_289);
              }
              if (CADeviceHasNotch::has_notch) {
                float v496 = 3.5;
              }
              else {
                float v496 = 2.0;
              }
            }
            else
            {
              float v496 = 3.0;
            }
            if ((*(unsigned __int8 *)(v441 + 656) | 2) == 3)
            {
              int v494 = *(_DWORD *)(v304 + 212);
              if (CADeviceIsPhone::once[0] != -1) {
                dispatch_once(CADeviceIsPhone::once, &__block_literal_global_193);
              }
              if (CADeviceIsPhone::phone) {
                float v495 = 20.0;
              }
              else {
                float v495 = 60.0;
              }
              if (CADeviceIsPhone::phone) {
                int v493 = 1123024896;
              }
              else {
                int v493 = 1101004800;
              }
            }
            else
            {
              int v494 = *(_DWORD *)(v304 + 208);
              if (CADeviceHasNotch::once != -1) {
                dispatch_once(&CADeviceHasNotch::once, &__block_literal_global_289);
              }
              if (CADeviceHasNotch::has_notch) {
                float v495 = 60.0;
              }
              else {
                float v495 = 50.0;
              }
              int v493 = 1101004800;
            }
            uint64_t v551 = 0x3885000000000000;
          }
          float v497 = v496 * 7.0;
          float v498 = v496 * 8.0;
          _S11 = (float)HIBYTE(v308) * 0.0039216;
          *(float32x2_t *)&long long v306 = vmul_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v308), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL)), (float32x2_t)vdup_n_s32(0x3B808081u));
          *(_OWORD *)v541 = v306;
          _S13 = (float)v308 * 0.0039216;
          size_t v501 = strlen(v305);
          if (v501)
          {
            int v502 = 1;
            int v503 = v305;
            size_t v504 = v501;
            do
            {
              int v505 = *v503++;
              if (v505 == 10) {
                ++v502;
              }
              --v504;
            }
            while (v504);
            float v506 = (float)(v502 + 1);
          }
          else
          {
            float v506 = 2.0;
          }
          __asm { FCVT            H11, S11 }
          uint16x4_t v507 = (uint16x4_t)vcvt_f16_f32(*(float32x4_t *)v541);
          __asm { FCVT            H13, S13 }
          float v508 = v498 * v506;
          float v509 = v497 * (float)v501;
          if (v494) {
            float v509 = (float)v494;
          }
          *(float *)v609.i32 = v509;
          *(float *)&v609.i32[1] = v495 + truncf(v508);
          int v510 = (int)*(float *)&v609.i32[1];
          uint64_t v511 = *(void *)(v304 + 416);
          if (!v511) {
            operator new();
          }
          *(float *)(v511 + 24) = v497;
          *(float *)(v511 + 28) = v498;
          *(void *)(v511 + 64) = *(void *)(v511 + 48);
          *(void *)(*(void *)(v304 + 416) + 8CA::Context::unref(this[1], 0) = v551;
          uint64_t v512 = *(void *)(v304 + 416);
          *(void *)uint64_t v512 = 0;
          *(_DWORD *)(v512 + 8) = (int)v509;
          *(_DWORD *)(v512 + 12) = v510;
          *(void *)(v512 + 16) = 0;
          CA::OGL::DebugRenderer::draw_rectangle_with_fill(v512, (float *)v609.i32, 0.0);
          unint64_t v513 = vmovl_u16(v507).u64[0];
          v514.i64[0] = v513;
          v514.i64[1] = HIDWORD(v513);
          v515.i64[0] = 0xFFFFLL;
          v515.i64[1] = 0xFFFFLL;
          uint64x2_t v516 = vshlq_u64((uint64x2_t)vandq_s8(v514, v515), (uint64x2_t)xmmword_184997EB0);
          *(void *)(*(void *)(v304 + 416) + 8CA::Context::unref(this[1], 0) = v516.i64[0] | ((unint64_t)LODWORD(_S13) << 48) | LODWORD(_S11) | v516.i64[1];
          uint64_t v517 = *(void *)(v304 + 416);
          *(_DWORD *)(v517 + 16) = v493;
          *(float *)(v517 + 2CA::Context::unref(this[1], 0) = v495;
          size_t v518 = strlen(v305);
          CA::OGL::DebugRenderer::draw_string(v517, v305, v518);
          CA::OGL::DebugRenderer::render(*(void *)(v304 + 416), (CA::OGL::Context *)v304, (const CA::Transform *)v581, 0);
          v566[0] = 0;
          v566[1] = 0;
          CA::OGL::DebugRenderer::visible_bounds((CA::OGL::DebugRenderer *)v566, *(CA::OGL::Context **)(v304 + 416), *(const CA::Transform **)(v304 + 192), (uint64_t)v581);
          if (*(void *)(v304 + 424)) {
            CA::shape_union((CA::Shape **)(v304 + 424), v566, v519);
          }
          else {
            *(void *)(v304 + 424) = CA::Shape::new_shape((unsigned int *)v566);
          }
          uint64_t v7 = v529;
        }
        else
        {
          if (!*(void *)(v304 + 416))
          {
LABEL_394:
            LODWORD(v285) = *v307;
            uint64_t v22 = *v9;
            uint64_t j = v9 + 3;
LABEL_395:
            if ((v285 & 0x4000000) != 0 && (*(unsigned char *)(v22 + 433) & 0x20) == 0)
            {
              uint32x2_t v309 = *(void **)(v9[1] + 504);
              if (v309)
              {
                uint64_t v558 = v9[1];
                do
                {
                  uint64_t v310 = v309[1];
                  uint64_t v311 = *(uint64_t **)(*(void *)(v310 + 32) + 128);
                  if (v311)
                  {
                    uint64_t v312 = *v311;
                    if (*v311)
                    {
                      if ((*(_DWORD *)(v312 + 12) & 0x4FF) == 0x403)
                      {
                        uint64_t v313 = *(void *)(v310 + 256);
                        if (v313)
                        {
                          unint64_t v314 = (os_unfair_lock_s *)(v313 + 36);
                          os_unfair_lock_lock((os_unfair_lock_t)(v313 + 36));
                          uint64_t v315 = *(void *)(v313 + 40);
                          if (v315)
                          {
                            unsigned int v316 = (os_unfair_lock_s *)(v315 + 40);
                            os_unfair_lock_lock((os_unfair_lock_t)(v315 + 40));
                            uint64_t v317 = *(void *)(v315 + 48);
                            if (v317)
                            {
                              if (*(void *)(v317 + 8) == v22)
                              {
                                int v318 = *(_DWORD *)(v317 + 60);
                                int v319 = *(_DWORD *)(v313 + 72);
                                *(unsigned char *)(v313 + 96) = v318 != v319;
                                if (v318 != v319)
                                {
                                  double v320 = *(double *)(v313 + 64);
                                  double v321 = *(double *)(v558 + 72);
                                  if (v320 - v321 <= 0.035)
                                  {
                                    uint64_t v325 = *(void *)(v317 + 32);
                                    if (v325)
                                    {
                                      if (!*(void *)(v325 + 48))
                                      {
                                        *(_DWORD *)(v313 + 72) = v318;
                                        *(double *)(v313 + 64) = v321 + 0.25;
                                        uint64_t v326 = *(void *)(v312 + 16);
                                        uint64_t v327 = CA::Render::Context::context_by_id((CA::Render::Context *)*(unsigned int *)(*(void *)(v313 + 16) + 16));
                                        if (v327)
                                        {
                                          unsigned int v328 = (atomic_uint *)v327;
                                          v581[0].i64[0] = MEMORY[0x1E4F143A8];
                                          v581[0].i64[1] = 0x40000000;
                                          v581[1].i64[0] = (uint64_t)___ZN2CA3OGL20update_backdrop_lumaERNS0_8RendererE_block_invoke;
                                          v581[1].i64[1] = (uint64_t)&__block_descriptor_tmp_19100;
                                          *(void *)&v582[0] = v327;
                                          *((void *)&v582[0] + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v326;
                                          if (((*(uint64_t (**)(uint64_t, uint64_t, int8x16_t *))(*(void *)v22 + 744))(v22, v325, v581) & 1) == 0&& atomic_fetch_add(v328 + 2, 0xFFFFFFFF) == 1)
                                          {
                                            (*(void (**)(atomic_uint *))(*(void *)v328 + 16))(v328);
                                          }
                                        }
                                      }
                                    }
                                  }
                                  else
                                  {
                                    double v322 = *(double *)(v558 + 80);
                                    if (v322 >= v320) {
                                      double v323 = *(double *)(v313 + 64);
                                    }
                                    else {
                                      double v323 = *(double *)(v558 + 80);
                                    }
                                    *(void *)(v558 + 96) |= 0x20000uLL;
                                    if (v322 >= v323)
                                    {
                                      if (v323 == 0.0 || v322 <= v323)
                                      {
                                        uint64_t v330 = v558;
                                        uint64_t v329 = *(void *)(v558 + 88) | 0x20000;
                                      }
                                      else
                                      {
                                        uint64_t v329 = 0x20000;
                                        uint64_t v330 = v558;
                                      }
                                      *(void *)(v330 + 88) = v329;
                                      *(double *)(v330 + 8CA::Context::unref(this[1], 0) = v323;
                                    }
                                  }
                                }
                              }
                            }
                            os_unfair_lock_unlock(v316);
                          }
                          os_unfair_lock_unlock(v314);
                          uint64_t j = v9 + 3;
                        }
                      }
                    }
                  }
                  uint32x2_t v309 = (void *)*v309;
                }
                while (v309);
                uint64_t v22 = *v9;
              }
              uint64_t v7 = v529;
            }
            (*(void (**)(uint64_t, uint64_t))(*(void *)v22 + 960))(v22, v7);
            (*(void (**)(void))(*(void *)*v9 + 1016))();
            double v331 = (void *)*v9;
            v331[15] = 0;
            v331[17] = 0;
            v331[2] = 0;
            v331[3] = 0;
            x_heap_free((void ***)v9[7]);
            v9[7] = 0;
            uint64_t v332 = 488;
            LODWORD(v22) = v528;
            do
            {
              if (*(void *)&v580[v332]) {
                __assert_rtn("~ContextState", "ogl-context.h", 551, "!next && \"Imbalanced ContextState push/pop\"");
              }
              v332 -= 488;
            }
            while (v332 != -488);
            goto LABEL_433;
          }
          std::unique_ptr<CA::OGL::DebugRenderer>::reset[abi:nn180100]((CA::OGL::DebugRenderer **)(v304 + 416), 0);
        }
        int32x2_t v307 = (_DWORD *)(v8 + 1084);
        goto LABEL_394;
      }
      uint64_t v37 = CA::OGL::prepare_layers_roi((const Rect **)v9, (void *)bounds, (uint64_t)&v570);
      uint64_t v39 = *v9;
      uint64_t v38 = v9[1];
      if (*(void *)(v38 + 504)) {
        int v40 = *(void *)(v39 + 264) == 0;
      }
      else {
        int v40 = 0;
      }
      if ((*(_WORD *)(v39 + 832) & 2) != 0)
      {
        uint64_t v44 = *(void *)(v39 + 264);
        if (v44)
        {
          if ((*(unsigned char *)(v44 + 68) & 8) == 0) {
            v40 |= (*(unsigned char *)(v38 + 269) & 0x20) >> 5;
          }
        }
      }
      uint64_t v45 = *(void *)(v39 + 192);
      if (v45)
      {
        uint64_t v46 = (*(uint64_t (**)(uint64_t))(*(void *)v45 + 16))(v45);
        uint64_t v47 = (CA::WindowServer::Display *)v46;
        uint64_t v522 = *(void *)(v9[1] + 24);
        if (!v46)
        {
          int v530 = 0;
          v526 = 0;
          goto LABEL_71;
        }
        if ((*(_WORD *)(v39 + 832) & 2) != 0
          || !(*(unsigned int (**)(uint64_t))(*(void *)v46 + 1504))(v46))
        {
          goto LABEL_67;
        }
        uint64_t v48 = v522;
        if ((v522 & 1) == 0)
        {
          if (*(_DWORD *)(v522 + 4) == 6)
          {
LABEL_67:
            v526 = 0;
            int v530 = 1;
            goto LABEL_71;
          }
          goto LABEL_191;
        }
        if (v522 != 1)
        {
LABEL_191:
          float v152 = (*(float (**)(CA::WindowServer::Display *))(*(void *)v47 + 920))(v47);
          float v153 = CA::WindowServer::Display::edr_headroom(v47) * v152;
          float v154 = v153 * (*(float (**)(CA::WindowServer::Display *))(*(void *)v47 + 1528))(v47);
          float v155 = (*(float (**)(CA::WindowServer::Display *))(*(void *)v47 + 1048))(v47);
          uint64_t v156 = (*(uint64_t (**)(CA::WindowServer::Display *))(*(void *)v47 + 1064))(v47);
          unsigned int v158 = *(_DWORD *)(v39 + 572);
          if (v158) {
            v157.n128_f32[0] = (float)v158;
          }
          else {
            v157.n128_u32[0] = (*(float (**)(CA::WindowServer::Display *))(*(void *)v47 + 984))(v47);
          }
          *(unsigned char *)(*(void *)(v39 + 16) + 16) = 75;
          v609.i32[2] = 0;
          v609.i64[0] = 0;
          v597.i32[0] = 0;
          v604.i32[0] = 0;
          (*(void (**)(uint64_t, void, uint64_t, uint64_t, int8x16_t *, int8x16_t *, int32x4_t *, float, __n128, float))(*(void *)v39 + 504))(v39, 0, 1, v156, &v609, &v597, &v604, v154, v157, v155);
          v566[0] = 0;
          v566[1] = (CA::Shape *)v609.i64[0];
          v526 = (int32x2_t *)(*(uint64_t (**)(uint64_t, uint64_t, CA::Shape **, uint64_t))(*(void *)v39 + 656))(v39, 1, v566, 143);
          if (v526)
          {
            (*(void (**)(uint64_t, int32x2_t *, void, void))(*(void *)v39 + 704))(v39, v526, v609.u32[0], v609.u32[1]);
            CA::OGL::Context::push_surface(v39, (uint64_t)v526, 0, 0, 0);
            (*(void (**)(uint64_t, void, uint64_t, uint64_t, int8x16_t *))(*(void *)v39 + 1000))(v39, 0, 1, 1, &v597);
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, int32x4_t *))(*(void *)v39 + 1000))(v39, 1, 1, 1, &v604);
            *(void *)(v39 + 128) = 0;
            *(void *)(v39 + 96) = v39 + 834;
            *(_OWORD *)(v39 + 104) = xmmword_184997E70;
            if (*(void *)(v39 + 136) <= 3uLL)
            {
              *(_WORD *)(v39 + 832) |= 0x20u;
              CA::OGL::Context::array_flush(v39);
              *(void *)(v39 + 128) = 0;
              *(void *)(v39 + 96) = v39 + 834;
              *(_OWORD *)(v39 + 104) = xmmword_184997E70;
            }
            CA::OGL::Context::array_rect((void *)v39, 0.0, 0.0, (float)(2 * LODWORD(v566[1])), (float)(2 * HIDWORD(v566[1])));
            uint64_t v238 = *(void *)(v39 + 120) + 48 * *(void *)(v39 + 128);
            *(void *)(v238 - 176) = 0;
            *(void *)(v238 - 128) = 0x40000000;
            *(void *)(v238 - 8CA::Context::unref(this[1], 0) = 0x4000000040000000;
            *(void *)(v238 - 32) = 0x4000000000000000;
            CA::OGL::Context::array_flush(v39);
            CA::OGL::Context::pop_surface((CA::OGL::Context *)v39);
          }
          (*(void (**)(uint64_t, void, void))(*(void *)v39 + 520))(v39, 0, 0);
          int v530 = 1;
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)v39 + 520))(v39, 0, 1);
          *(unsigned char *)(*(void *)(v39 + 16) + 16) = 0;
LABEL_71:
          *(void *)(v39 + 824) = v581;
          *(_WORD *)(v39 + 832) &= ~0x800u;
          if (v40)
          {
            uint64_t v49 = v19;
            v566[0] = 0;
            v566[1] = 0;
            CA::Shape::get_bounds((uint64_t)v571, (int *)v566);
            if (v37)
            {
              int v50 = (void *)v37;
              do
              {
                uint64_t v51 = v50[14];
                if (v51)
                {
                  int8x16_t v609 = 0uLL;
                  CA::Shape::get_bounds(v51 + 144, v609.i32);
                  unsigned int v52 = (CA::Shape *)v609.i64[1];
                  uint32x2_t v53 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v566[1]);
                  unsigned __int32 v54 = vpmax_u32(v53, v53).u32[0];
                  uint32x2_t v55 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v609.u64[1]);
                  unsigned __int32 v56 = vpmax_u32(v55, v55).u32[0];
                  if ((v54 & 0x80000000) != 0)
                  {
                    if ((v56 & 0x80000000) == 0)
                    {
                      int v57 = (CA::Shape *)v609.i64[0];
                      goto LABEL_80;
                    }
                  }
                  else if ((v56 & 0x80000000) == 0)
                  {
                    int v57 = (CA::Shape *)vmin_s32((int32x2_t)v566[0], *(int32x2_t *)v609.i8);
                    unsigned int v52 = (CA::Shape *)vsub_s32(vmax_s32(vadd_s32((int32x2_t)v566[0], (int32x2_t)v566[1]), vadd_s32(*(int32x2_t *)v609.i8, (int32x2_t)v609.u64[1])), (int32x2_t)v57);
LABEL_80:
                    v566[0] = v57;
                    v566[1] = v52;
                  }
                }
                int v50 = (void *)*v50;
              }
              while (v50);
            }
            uint32x2_t v58 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v566[1]);
            if ((vpmax_u32(v58, v58).u32[0] & 0x80000000) == 0)
            {
              int32x2_t v59 = *(int32x2_t *)(v39 + 208);
              uint32x2_t v60 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v59);
              if ((vpmax_u32(v60, v60).u32[0] & 0x80000000) != 0
                || (int32x2_t v61 = *(int32x2_t *)(v39 + 200),
                    *(int32x2_t *)&long long v62 = vmax_s32((int32x2_t)v566[0], v61),
                    int32x2_t v63 = vsub_s32(vmin_s32(vadd_s32((int32x2_t)v566[0], (int32x2_t)v566[1]), vadd_s32(v61, v59)), *(int32x2_t *)&v62), v64 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v63), (vpmax_u32(v64, v64).u32[0] & 0x80000000) != 0))
              {
                v566[1] = 0;
              }
              else
              {
                *((int32x2_t *)&v62 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v63;
                *(_OWORD *)v566 = v62;
              }
            }
            uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t, CA::Shape **, uint64_t))(*(void *)v39 + 656))(v39, 1, v566, 15);
            if (v65)
            {
              uint64_t v66 = v65;
              CA::OGL::Context::push_surface(v39, v65, 1u, 512, 0);
              CA::OGL::render_layers(v9, v37);
              if (byte_1EB2ACBE1)
              {
                int v451 = *(_DWORD *)(v66 + 40);
                int v452 = *(_DWORD *)(v66 + 44);
                if (v451 <= v452) {
                  int v453 = *(_DWORD *)(v66 + 44);
                }
                else {
                  int v453 = *(_DWORD *)(v66 + 40);
                }
                v68.i32[0] = 1073741822;
                v69.i32[0] = v453;
                int8x16_t v454 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v69, v68), 0);
                uint64_t v455 = *(void *)(v66 + 32);
                v456.i64[0] = (int)v455;
                v456.i64[1] = SHIDWORD(v455);
                int8x16_t v457 = (int8x16_t)vcvtq_f64_s64(v456);
                int8x16_t v609 = vbslq_s8(v454, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v457);
                double v458 = 1.79769313e308;
                if (v453 <= 1073741822) {
                  double v459 = (double)v451;
                }
                else {
                  double v459 = 1.79769313e308;
                }
                if (v453 <= 1073741822) {
                  double v458 = (double)v452;
                }
                *(double *)v610.i64 = v459;
                *(double *)&v610.i64[1] = v458;
                v566[0] = (CA::Shape *)&v609;
                v566[1] = (CA::Shape *)&CA::identity_transform;
                float64x2_t v567 = 0u;
                long long v568 = 0u;
                *(double *)v457.i64 = (double)v452;
                CA::OGL::fill_color_rect(v39, (uint64_t)v566, (double *)0x80800080, v67, 0.0, v457);
              }
              CA::OGL::Context::pop_surface((CA::OGL::Context *)v39);
              v566[0] = 0;
              v566[1] = 0;
              CA::OGL::emit_combine(v39, 1u, (_DWORD *)v66, 0, v571, (unsigned int *)v566);
              CA::OGL::Context::release_surface(v39, v66);
            }
            else
            {
              CA::OGL::render_layers(v9, v37);
            }
            uint64_t v19 = v49;
          }
          else
          {
            CA::OGL::render_layers(v9, v37);
          }
          uint64_t v70 = v9[1];
          if ((*(_DWORD *)(v70 + 1084) & 0x400) != 0 && BYTE11(xmmword_1EB2ACBF0))
          {
            int v442 = *(_DWORD *)(v70 + 200);
            int v443 = *(_DWORD *)(v70 + 204);
            if (v442 <= v443) {
              int v444 = *(_DWORD *)(v70 + 204);
            }
            else {
              int v444 = *(_DWORD *)(v70 + 200);
            }
            v31.i32[0] = 1073741822;
            v32.i32[0] = v444;
            int8x16_t v445 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v32, (int32x4_t)v31), 0);
            uint64_t v446 = *(void *)(v70 + 192);
            v447.i64[0] = (int)v446;
            v447.i64[1] = SHIDWORD(v446);
            int8x16_t v449 = (int8x16_t)vcvtq_f64_s64(v447);
            int8x16_t v448 = vbslq_s8(v445, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v449);
            *(double *)v449.i64 = (double)v442;
            int8x16_t v609 = v448;
            double v450 = 1.79769313e308;
            if (v444 <= 1073741822) {
              double v450 = (double)v443;
            }
            else {
              *(double *)v449.i64 = 1.79769313e308;
            }
            v610.i64[0] = v449.i64[0];
            *(double *)&v610.i64[1] = v450;
            v566[0] = (CA::Shape *)&v609;
            v566[1] = (CA::Shape *)&CA::identity_transform;
            float64x2_t v567 = 0u;
            long long v568 = 0u;
            uint64_t bounds = CA::OGL::fill_color_rect(v39, (uint64_t)v566, (double *)0x800040, v30, 0.0, v449);
          }
          *(void *)(v39 + 824) = 0;
          *(_WORD *)(v39 + 832) &= ~0x800u;
          if (!((v530 ^ 1) & 1 | (*(_DWORD *)(v9[1] + 1084) >> 2) & 1))
          {
            uint64_t bounds = (*(uint64_t (**)(CA::WindowServer::Display *))(*(void *)v47 + 584))(v47);
            if ((bounds & 1) == 0)
            {
              uint64_t bounds = *(void *)(v39 + 192);
              if (bounds) {
                uint64_t bounds = (*(uint64_t (**)(uint64_t, uint64_t (*)(uint64_t, uint64_t, _DWORD *, double *, double *, char, uint64_t), uint64_t))(*(void *)bounds + 88))(bounds, CA::OGL::composite_detached, v39);
              }
            }
          }
          if (v530)
          {
            uint64_t bounds = (*(uint64_t (**)(CA::WindowServer::Display *))(*(void *)v47 + 1520))(v47);
            uint64_t v71 = v9[1];
            if (bounds) {
              goto LABEL_105;
            }
          }
          else
          {
            uint64_t v71 = v9[1];
          }
          uint64_t v72 = *(unsigned int *)(v71 + 1084);
          if ((v72 & 0x8000000) == 0)
          {
            unint64_t v73 = ((v72 | ((unint64_t)*(unsigned __int16 *)(v71 + 1088) << 32)) >> 2) & 1;
LABEL_106:
            unint64_t v74 = *(void *)(v71 + 48);
            if (v74) {
              _ZF = v74 == 1;
            }
            else {
              _ZF = *(_DWORD *)(v74 + 4) == 6;
            }
            char v76 = _ZF;
            if ((v76 & 1) == 0 && ((v73 ^ 1) & 1) == 0)
            {
              *(unsigned char *)(*(void *)(v39 + 16) + 16) = 70;
              uint64_t bounds = (*(uint64_t (**)(uint64_t))(*(void *)v39 + 984))(v39);
              if (bounds)
              {
                int32x4_t v563 = 0uLL;
                *(void *)&long long v598 = 0;
                v31.i32[0] = 1073741822;
                int32x4_t v552 = (int32x4_t)v31;
                int8x16_t v533 = (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
                int8x16_t v542 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
                int8x16_t v597 = (int8x16_t)v74;
                while (1)
                {
                  uint64_t bounds = CA::ShapeIterator::iterate(v597.i64, v563.i32);
                  if (!bounds) {
                    break;
                  }
                  int32x2_t v77 = (int32x2_t)v563.u64[1];
                  uint32x2_t v78 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v563.u64[1]);
                  *(uint32x2_t *)v32.i8 = vpmax_u32(v78, v78);
                  if ((v32.i32[0] & 0x80000000) == 0)
                  {
                    v32.i64[0] = *(void *)(v39 + 208);
                    uint32x2_t v79 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v32.i8);
                    if ((vpmax_u32(v79, v79).u32[0] & 0x80000000) != 0
                      || (int32x2_t v80 = *(int32x2_t *)(v39 + 200),
                          int32x2_t v81 = vadd_s32(v80, *(int32x2_t *)v32.i8),
                          *(int32x2_t *)v32.i8 = vmax_s32(*(int32x2_t *)v563.i8, v80),
                          int32x2_t v77 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)v563.i8, (int32x2_t)v563.u64[1]), v81), *(int32x2_t *)v32.i8), v82 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v77), (vpmax_u32(v82, v82).u32[0] & 0x80000000) != 0))
                    {
                      int32x2_t v77 = 0;
                      v563.i64[1] = 0;
                    }
                    else
                    {
                      v32.u64[1] = (unint64_t)v77;
                      int32x4_t v563 = v32;
                    }
                  }
                  int v83 = v77.i32[0];
                  if (v77.i32[0] <= v77.i32[1]) {
                    int v83 = v77.i32[1];
                  }
                  v32.i32[0] = v83;
                  v84.i64[0] = v563.i32[0];
                  v84.i64[1] = v563.i32[1];
                  int8x16_t v85 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v32, v552), 0), v542, (int8x16_t)vcvtq_f64_s64(v84));
                  v84.i64[0] = v77.i32[0];
                  v84.i64[1] = v77.i32[1];
                  int8x16_t v86 = (int8x16_t)vcvtq_f64_s64(v84);
                  int32x2_t v87 = vdup_n_s32(v83 > 1073741822);
                  v84.i64[0] = v87.u32[0];
                  v84.i64[1] = v87.u32[1];
                  int8x16_t v609 = v85;
                  int8x16_t v610 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v84, 0x3FuLL)), v533, v86);
                  v566[0] = (CA::Shape *)&v609;
                  v566[1] = (CA::Shape *)&CA::identity_transform;
                  float64x2_t v567 = 0u;
                  long long v568 = 0u;
                  CA::OGL::emit_one_part_rect((CA::OGL::Context *)v39, (uint64_t)v566, 0, 0, 0);
                }
                if (HIBYTE(xmmword_1EB2ACBF0))
                {
                  unint64_t v605 = 0;
                  int32x4_t v604 = (int32x4_t)v74;
                  v31.i32[0] = 1073741822;
                  int32x4_t v550 = (int32x4_t)v31;
                  int8x16_t v561 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
                  int8x16_t v540 = (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
                  while (1)
                  {
                    uint64_t bounds = CA::ShapeIterator::iterate(v604.i64, v563.i32);
                    if (!bounds) {
                      break;
                    }
                    int32x2_t v460 = (int32x2_t)v563.u64[1];
                    uint32x2_t v461 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v563.u64[1]);
                    *(uint32x2_t *)v32.i8 = vpmax_u32(v461, v461);
                    if ((v32.i32[0] & 0x80000000) == 0)
                    {
                      v32.i64[0] = *(void *)(v39 + 208);
                      uint32x2_t v462 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v32.i8);
                      if ((vpmax_u32(v462, v462).u32[0] & 0x80000000) != 0
                        || (int32x2_t v463 = *(int32x2_t *)(v39 + 200),
                            int32x2_t v464 = vadd_s32(v463, *(int32x2_t *)v32.i8),
                            *(int32x2_t *)v32.i8 = vmax_s32(*(int32x2_t *)v563.i8, v463),
                            int32x2_t v460 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)v563.i8, (int32x2_t)v563.u64[1]), v464), *(int32x2_t *)v32.i8), v465 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v460), (vpmax_u32(v465, v465).u32[0] & 0x80000000) != 0))
                      {
                        int32x2_t v460 = 0;
                        v563.i64[1] = 0;
                      }
                      else
                      {
                        v32.u64[1] = (unint64_t)v460;
                        int32x4_t v563 = v32;
                      }
                    }
                    int v466 = v460.i32[0];
                    if (v460.i32[0] <= v460.i32[1]) {
                      int v466 = v460.i32[1];
                    }
                    v32.i32[0] = v466;
                    v467.i64[0] = v563.i32[0];
                    v467.i64[1] = v563.i32[1];
                    int8x16_t v468 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v32, v550), 0), v561, (int8x16_t)vcvtq_f64_s64(v467));
                    v467.i64[0] = v460.i32[0];
                    v467.i64[1] = v460.i32[1];
                    int8x16_t v469 = (int8x16_t)vcvtq_f64_s64(v467);
                    int32x2_t v470 = vdup_n_s32(v466 > 1073741822);
                    v467.i64[0] = v470.u32[0];
                    v467.i64[1] = v470.u32[1];
                    int8x16_t v609 = v468;
                    int8x16_t v610 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v467, 0x3FuLL)), v540, v469);
                    v566[0] = (CA::Shape *)&v609;
                    v566[1] = (CA::Shape *)&CA::identity_transform;
                    float64x2_t v567 = 0u;
                    long long v568 = 0u;
                    CA::OGL::fill_color_rect(v39, (uint64_t)v566, (double *)0x800040, v30, 0.0, v468);
                  }
                }
              }
            }
            if (byte_1EB2ACC01 | byte_1EB2ACC02)
            {
              uint64_t bounds = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v39 + 184))(v39, 18);
              if (bounds)
              {
                *(unsigned char *)(*(void *)(v39 + 16) + 481) &= ~1u;
                *(unsigned char *)(*(void *)(v39 + 16) + 16) = 71;
                uint64_t bounds = (*(uint64_t (**)(uint64_t))(*(void *)v39 + 984))(v39);
                if (bounds)
                {
                  float v377 = (*(float (**)(uint64_t))(*(void *)v39 + 1040))(v39);
                  float v378 = 1.0 / *(float *)(v39 + 152);
                  v597.i32[0] = powf(1.0 / v377, v378);
                  v597.i32[1] = powf(v377, v378);
                  (*(void (**)(uint64_t, void, uint64_t, uint64_t, int8x16_t *))(*(void *)v39 + 1000))(v39, 0, 2, 1, &v597);
                  float v379 = 0.0;
                  if (byte_1EB2ACC02) {
                    float v379 = 1.0;
                  }
                  *(float *)v604.i32 = v379;
                  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, int32x4_t *))(*(void *)v39 + 1000))(v39, 1, 1, 1, &v604);
                  v563.i32[0] = 0;
                  if (initialized != -1) {
                    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
                  }
                  float v380 = *(float *)&dword_1EB2ACB9C;
                  if (*(float *)&dword_1EB2ACB9C == 0.0) {
                    float v380 = 1.0;
                  }
                  *(float *)v563.i32 = v380;
                  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, int32x4_t *))(*(void *)v39 + 1000))(v39, 2, 1, 1, &v563);
                  v563.i32[0] = powf(*(float *)v563.i32, 1.0 / *(float *)(v39 + 152));
                  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, int32x4_t *))(*(void *)v39 + 1000))(v39, 3, 1, 1, &v563);
                  long long v383 = *(_OWORD *)(v39 + 200);
                  int v384 = *(void *)(v39 + 208);
                  if (SDWORD2(v383) <= SHIDWORD(v383)) {
                    int v384 = HIDWORD(*(_OWORD *)(v39 + 200));
                  }
                  v381.i32[0] = 1073741822;
                  v382.i32[0] = v384;
                  v385.i64[0] = (int)v383;
                  v385.i64[1] = SDWORD1(v383);
                  int8x16_t v386 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v382, v381), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v385));
                  v385.i64[0] = SDWORD2(v383);
                  v385.i64[1] = SHIDWORD(v383);
                  int8x16_t v387 = (int8x16_t)vcvtq_f64_s64(v385);
                  int32x2_t v388 = vdup_n_s32(v384 > 1073741822);
                  v385.i64[0] = v388.u32[0];
                  v385.i64[1] = v388.u32[1];
                  int8x16_t v609 = v386;
                  int8x16_t v610 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v385, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v387);
                  v566[0] = (CA::Shape *)&v609;
                  v566[1] = (CA::Shape *)&CA::identity_transform;
                  float64x2_t v567 = 0u;
                  long long v568 = 0u;
                  uint64_t bounds = (uint64_t)CA::OGL::emit_one_part_rect((CA::OGL::Context *)v39, (uint64_t)v566, 0, 0, 0);
                }
                *(unsigned char *)(*(void *)(v39 + 16) + 16) = 0;
              }
            }
            uint64_t j = v9 + 3;
            if (byte_1EB2ACC00)
            {
              uint64_t bounds = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v39 + 184))(v39, 18);
              if (bounds)
              {
                *(unsigned char *)(*(void *)(v39 + 16) + 481) &= ~1u;
                *(unsigned char *)(*(void *)(v39 + 16) + 16) = 72;
                uint64_t bounds = (*(uint64_t (**)(uint64_t))(*(void *)v39 + 984))(v39);
                if (bounds)
                {
                  float v416 = (*(float (**)(uint64_t))(*(void *)v39 + 1040))(v39);
                  float v417 = 1.0 / *(float *)(v39 + 152);
                  v597.i32[0] = powf(1.0 / v416, v417);
                  v597.i32[1] = powf(v416, v417);
                  (*(void (**)(uint64_t, void, uint64_t, uint64_t, int8x16_t *))(*(void *)v39 + 1000))(v39, 0, 2, 1, &v597);
                  v604.i32[0] = 0;
                  if (initialized != -1) {
                    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
                  }
                  float v418 = *(float *)&dword_1EB2ACB9C;
                  if (*(float *)&dword_1EB2ACB9C == 0.0) {
                    float v418 = 1.0;
                  }
                  *(float *)v604.i32 = v418;
                  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, int32x4_t *))(*(void *)v39 + 1000))(v39, 1, 1, 1, &v604);
                  v604.i32[0] = powf(*(float *)v604.i32, 1.0 / *(float *)(v39 + 152));
                  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, int32x4_t *))(*(void *)v39 + 1000))(v39, 2, 1, 1, &v604);
                  long long v421 = *(_OWORD *)(v39 + 200);
                  int v422 = *(void *)(v39 + 208);
                  if (SDWORD2(v421) <= SHIDWORD(v421)) {
                    int v422 = HIDWORD(*(_OWORD *)(v39 + 200));
                  }
                  v419.i32[0] = 1073741822;
                  v420.i32[0] = v422;
                  v423.i64[0] = (int)v421;
                  v423.i64[1] = SDWORD1(v421);
                  int8x16_t v424 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v420, v419), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v423));
                  v423.i64[0] = SDWORD2(v421);
                  v423.i64[1] = SHIDWORD(v421);
                  int8x16_t v425 = (int8x16_t)vcvtq_f64_s64(v423);
                  int32x2_t v426 = vdup_n_s32(v422 > 1073741822);
                  v423.i64[0] = v426.u32[0];
                  v423.i64[1] = v426.u32[1];
                  int8x16_t v609 = v424;
                  int8x16_t v610 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v423, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v425);
                  v566[0] = (CA::Shape *)&v609;
                  v566[1] = (CA::Shape *)&CA::identity_transform;
                  float64x2_t v567 = 0u;
                  long long v568 = 0u;
                  uint64_t bounds = (uint64_t)CA::OGL::emit_one_part_rect((CA::OGL::Context *)v39, (uint64_t)v566, 0, 0, 0);
                }
                *(unsigned char *)(*(void *)(v39 + 16) + 16) = 0;
                uint64_t j = v9 + 3;
              }
            }
            if (v530)
            {
              if ((*(_WORD *)(v39 + 832) & 2) == 0)
              {
                float v88 = (*(float (**)(CA::WindowServer::Display *))(*(void *)v47 + 976))(v47);
                if (v88 != 0.0)
                {
                  float v89 = v88;
                  if (initialized != -1) {
                    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
                  }
                  *(float *)v597.i32 = *(float *)&dword_1EB2ACB34 * v89;
                  __asm { FMOV            V0.2S, #1.0 }
                  *(uint64_t *)((char *)v597.i64 + 4) = _D0;
                  float v94 = (*(float (**)(uint64_t))(*(void *)v39 + 1040))(v39);
                  if (v94 != 0.0 && v94 != 1.0)
                  {
                    float v96 = v94;
                    float v97 = 1.0 / *(float *)(v39 + 152);
                    v597.i32[1] = powf(1.0 / v94, v97);
                    v597.i32[2] = powf(v96, v97);
                  }
                  *(unsigned char *)(*(void *)(v39 + 16) + 481) &= ~1u;
                  *(unsigned char *)(*(void *)(v39 + 16) + 16) = 78;
                  (*(void (**)(uint64_t, void))(*(void *)v39 + 512))(v39, 0);
                  (*(void (**)(uint64_t, void, uint64_t, uint64_t, int8x16_t *))(*(void *)v39 + 1000))(v39, 0, 3, 1, &v597);
                  int v100 = *(_DWORD *)(v39 + 208);
                  int v101 = *(_DWORD *)(v39 + 212);
                  if (v100 <= v101) {
                    int v102 = *(_DWORD *)(v39 + 212);
                  }
                  else {
                    int v102 = *(_DWORD *)(v39 + 208);
                  }
                  v98.i32[0] = 1073741822;
                  v99.i32[0] = v102;
                  int8x16_t v103 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v99, v98), 0);
                  uint64_t v104 = *(void *)(v39 + 200);
                  v105.i64[0] = (int)v104;
                  v105.i64[1] = SHIDWORD(v104);
                  double v106 = (double)v100;
                  int8x16_t v609 = vbslq_s8(v103, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v105));
                  double v107 = 1.79769313e308;
                  if (v102 <= 1073741822) {
                    double v107 = (double)v101;
                  }
                  else {
                    double v106 = 1.79769313e308;
                  }
                  *(double *)v610.i64 = v106;
                  *(double *)&v610.i64[1] = v107;
                  v566[0] = (CA::Shape *)&v609;
                  v566[1] = (CA::Shape *)&CA::identity_transform;
                  float64x2_t v567 = 0u;
                  long long v568 = 0u;
                  CA::OGL::emit_one_part_rect((CA::OGL::Context *)v39, (uint64_t)v566, 0, 0, 0);
                  (*(void (**)(uint64_t, void, void))(*(void *)v39 + 520))(v39, 0, 0);
                  *(unsigned char *)(*(void *)(v39 + 16) + 16) = 0;
                }
              }
            }
            else if ((*(unsigned char *)(v39 + 433) & 1) == 0)
            {
LABEL_212:
              if (v526) {
                CA::OGL::Context::release_surface(v39, (uint64_t)v526);
              }
              if (((v530 ^ 1 | ((*(_WORD *)(v39 + 832) & 2) >> 1)) & 1) == 0)
              {
                uint64_t bounds = (*(uint64_t (**)(CA::WindowServer::Display *))(*(void *)v47 + 1552))(v47);
                if (bounds)
                {
                  (*(void (**)(CA::Shape **__return_ptr, CA::WindowServer::Display *))(*(void *)v47 + 656))(v566, v47);
                  int64x2_t v178 = vceqzq_f64(v567);
                  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v178, 1), (int8x16_t)v178).u64[0] & 0x8000000000000000) != 0
                    || (int8x16_t v179 = vorrq_s8((int8x16_t)vcltzq_f64(v567), (int8x16_t)vcgezq_f64(v567)),
                        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v179), 1), v179).u64[0] & 0x8000000000000000) != 0))
                  {
                    int32x4_t v604 = 0uLL;
                  }
                  else
                  {
                    int32x4_t v180 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(*(float64x2_t *)v566, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
                    int32x4_t v604 = vuzp1q_s32(v180, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(*(float64x2_t *)v566, v567), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v180));
                  }
                  uint64_t v181 = CA::Shape::intersect(*(CA::Shape **)(v9[1] + 32), (const CA::Bounds *)&v604);
                  int32x4_t v563 = 0uLL;
                  *(void *)&long long v598 = 0;
                  int v536 = (CA::Shape *)v181;
                  int8x16_t v597 = (int8x16_t)(unint64_t)v181;
                  uint64_t v183 = *(void *)(v39 + 16);
                  char v184 = *(unsigned char *)(v183 + 481);
                  if (byte_1EB2ACC44)
                  {
                    *(unsigned char *)(v183 + 48CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v184 | 1;
                    *(unsigned char *)(*(void *)(v39 + 16) + 16) = 0;
                    v182.i32[1] = 966393856;
                    *(void *)(*(void *)(v39 + 16) + 8) = 0x399A00000000399ALL;
                  }
                  else
                  {
                    *(unsigned char *)(v183 + 48CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v184 & 0xFE;
                    *(unsigned char *)(*(void *)(v39 + 16) + 16) = 79;
                  }
                  v182.i32[0] = 1073741822;
                  int32x4_t v555 = v182;
                  int8x16_t v545 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
                  while (CA::ShapeIterator::iterate(v597.i64, v563.i32))
                  {
                    if (v563.i32[2] <= v563.i32[3]) {
                      int v186 = v563.i32[3];
                    }
                    else {
                      int v186 = v563.i32[2];
                    }
                    v185.i32[0] = v186;
                    v187.i64[0] = v563.i32[0];
                    v187.i64[1] = v563.i32[1];
                    int8x16_t v188 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v185, v555), 0), v545, (int8x16_t)vcvtq_f64_s64(v187));
                    double v189 = (double)v563.i32[2];
                    if (v186 > 1073741822) {
                      double v189 = 1.79769313e308;
                    }
                    int8x16_t v609 = v188;
                    if (v186 <= 1073741822) {
                      double v190 = (double)v563.i32[3];
                    }
                    else {
                      double v190 = 1.79769313e308;
                    }
                    *(double *)v610.i64 = v189;
                    *(double *)&v610.i64[1] = v190;
                    v566[0] = (CA::Shape *)&v609;
                    v566[1] = (CA::Shape *)&CA::identity_transform;
                    float64x2_t v567 = 0u;
                    long long v568 = 0u;
                    CA::OGL::emit_one_part_rect((CA::OGL::Context *)v39, (uint64_t)v566, 0, 0, 0);
                  }
                  CA::Shape::unref(v536);
                  *(unsigned char *)(*(void *)(v39 + 16) + 16) = 0;
                  uint64_t j = v9 + 3;
                }
              }
              if (((v530 ^ 1 | ((*(_WORD *)(v39 + 832) & 2) >> 1)) & 1) == 0
                && (*((_WORD *)v47 + 328) & 0x1C00) == 0x800)
              {
                uint64_t bounds = (*(uint64_t (**)(CA::WindowServer::Display *))(*(void *)v47 + 1480))(v47);
                if (bounds)
                {
                  uint64_t bounds = (*(uint64_t (**)(CA::WindowServer::Display *))(*(void *)v47 + 1464))(v47);
                  v31.i32[0] = *(_DWORD *)bounds;
                  if (*(float *)bounds == 1.0)
                  {
                    uint64_t v228 = 1;
                    while (v228 != 16)
                    {
                      uint64_t v229 = v228;
                      v31.i32[0] = *(_DWORD *)(bounds + 4 * v228);
                      float v230 = CA::Mat4Impl::mat4_identity_float[v228++];
                      if (v31.f32[0] != v230)
                      {
                        if ((unint64_t)(v229 - 1) <= 0xE) {
                          goto LABEL_238;
                        }
                        break;
                      }
                    }
                  }
                  else
                  {
LABEL_238:
                    *(unsigned char *)(*(void *)(v39 + 16) + 481) &= ~1u;
                    *(unsigned char *)(*(void *)(v39 + 16) + 17) = 38;
                    *(unsigned char *)(*(void *)(v39 + 16) + 16) = 18;
                    uint64_t v191 = (*(uint64_t (**)(CA::WindowServer::Display *, float32x4_t))(*(void *)v47 + 1464))(v47, v31);
                    int8x16_t v192 = *(int8x16_t *)v191;
                    int8x16_t v193 = *(int8x16_t *)(v191 + 16);
                    long long v194 = *(_OWORD *)(v191 + 32);
                    int32x2_t v195 = vzip1_s32(*(int32x2_t *)v191, *(int32x2_t *)v193.i8);
                    int32x2_t v196 = vzip2_s32(*(int32x2_t *)v193.i8, *(int32x2_t *)&v194);
                    LODWORD(v61CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(void *)(v191 + 40);
                    DWORD1(v194) = v192.i32[1];
                    *(int32x2_t *)v609.i8 = v195;
                    v609.i64[1] = v194;
                    *(int32x2_t *)v610.i8 = v196;
                    v610.u64[1] = (unint64_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v192, v192, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v193, v193, 8uLL));
                    (*(void (**)(uint64_t, void, uint64_t, uint64_t, int8x16_t *))(*(void *)v39 + 1000))(v39, 0, 3, 3, &v609);
                    int v199 = *(_DWORD *)(v39 + 208);
                    int v200 = *(_DWORD *)(v39 + 212);
                    if (v199 <= v200) {
                      int v201 = *(_DWORD *)(v39 + 212);
                    }
                    else {
                      int v201 = *(_DWORD *)(v39 + 208);
                    }
                    v197.i32[0] = 1073741822;
                    v198.i32[0] = v201;
                    int8x16_t v202 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v198, v197), 0);
                    uint64_t v203 = *(void *)(v39 + 200);
                    v204.i64[0] = (int)v203;
                    v204.i64[1] = SHIDWORD(v203);
                    double v205 = (double)v199;
                    int8x16_t v597 = vbslq_s8(v202, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v204));
                    double v206 = 1.79769313e308;
                    if (v201 <= 1073741822) {
                      double v206 = (double)v200;
                    }
                    else {
                      double v205 = 1.79769313e308;
                    }
                    *(double *)&long long v598 = v205;
                    *((double *)&v598 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v206;
                    v566[0] = (CA::Shape *)&v597;
                    v566[1] = (CA::Shape *)&CA::identity_transform;
                    float64x2_t v567 = 0u;
                    long long v568 = 0u;
                    CA::OGL::emit_one_part_rect((CA::OGL::Context *)v39, (uint64_t)v566, 0, 0, 0);
                    *(unsigned char *)(*(void *)(v39 + 16) + 16) = 0;
                    uint64_t bounds = (*(uint64_t (**)(CA::WindowServer::Display *, uint64_t))(*(void *)v47 + 1472))(v47, 1);
                  }
                }
              }
              if (v530)
              {
                uint64_t v207 = v9[1];
                if (*(void *)(v207 + 1048))
                {
                  uint64_t bounds = *(void *)(v39 + 192);
                  if (bounds && (uint64_t bounds = (*(uint64_t (**)(uint64_t))(*(void *)bounds + 16))(bounds)) != 0)
                  {
                    uint64_t bounds = (*(uint64_t (**)(uint64_t))(*(void *)bounds + 80))(bounds);
                    char v208 = bounds;
                  }
                  else
                  {
                    char v208 = 0;
                  }
                  if (BYTE10(xmmword_1EB2ACC50)) {
                    goto LABEL_259;
                  }
                  if (CADeviceSupportsHWGainMap::once[0] != -1) {
                    dispatch_once(CADeviceSupportsHWGainMap::once, &__block_literal_global_80);
                  }
                  char v209 = CADeviceSupportsHWGainMap::supports_gain_map ? v208 : 1;
                  if ((v209 & 1) != 0 || (*(_DWORD *)(v207 + 1084) & 4) != 0)
                  {
LABEL_259:
                    int8x16_t v597 = 0uLL;
                    uint64_t bounds = CA::Shape::get_bounds(*(void *)(*(void *)(v39 + 248) + 8), v597.i32);
                    uint64_t v211 = *(int32x2_t **)(v39 + 264);
                    if (v211) {
                      uint64_t v212 = v211 + 4;
                    }
                    else {
                      uint64_t v212 = (int32x2_t *)(v39 + 200);
                    }
                    v31.i32[1] = v597.i32[3];
                    uint32x2_t v213 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v597.u64[1]);
                    *(uint32x2_t *)v32.i8 = vpmax_u32(v213, v213);
                    if ((v32.i32[0] & 0x80000000) == 0)
                    {
                      *(int32x2_t *)v32.i8 = v212[1];
                      uint32x2_t v214 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v32.i8);
                      if ((vpmax_u32(v214, v214).u32[0] & 0x80000000) == 0)
                      {
                        *(int32x2_t *)v215.i8 = vmax_s32(*(int32x2_t *)v597.i8, *v212);
                        *(int32x2_t *)v31.f32 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)v597.i8, (int32x2_t)v597.u64[1]), vadd_s32(*v212, *(int32x2_t *)v32.i8)), *(int32x2_t *)v215.i8);
                        uint32x2_t v216 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v31.f32);
                        *(uint32x2_t *)v32.i8 = vpmax_u32(v216, v216);
                        if ((v32.i32[0] & 0x80000000) == 0)
                        {
                          uint64_t v217 = v19;
                          v215.i64[1] = v31.i64[0];
                          int8x16_t v597 = v215;
                          uint64_t v218 = *(void **)(v207 + 1048);
                          *(int8x16_t *)unsigned int v537 = v215;
                          if (v218)
                          {
                            int8x16_t v546 = 0uLL;
                            int8x16_t v556 = 0uLL;
                            do
                            {
                              uint64_t v219 = v218[1];
                              float64x2_t v220 = *(float64x2_t *)(v219 + 80);
                              *(_OWORD *)v566 = *(_OWORD *)(v219 + 64);
                              float64x2_t v567 = v220;
                              CA::Rect::apply_transform((int8x16_t *)v566, (const CA::Transform *)(v218 + 2), v210);
                              int64x2_t v221 = vclezq_f64((float64x2_t)v556);
                              int64x2_t v222 = vclezq_f64(v567);
                              int32x2_t v223 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v222, v221), (int8x16_t)vzip2q_s64(v222, v221))));
                              if (v223.i8[4])
                              {
                                if (v223.i8[0]) {
                                  unint64_t v224 = -1;
                                }
                                else {
                                  unint64_t v224 = 0;
                                }
                                int8x16_t v225 = (int8x16_t)vdupq_n_s64(v224);
                                int8x16_t v546 = vbslq_s8(v225, v546, *(int8x16_t *)v566);
                                int8x16_t v556 = vbslq_s8(v225, v556, (int8x16_t)v567);
                              }
                              else if ((v223.i8[0] & 1) == 0)
                              {
                                float64x2_t v226 = vminnmq_f64((float64x2_t)v546, *(float64x2_t *)v566);
                                float64x2_t v227 = vsubq_f64(vmaxnmq_f64(vaddq_f64((float64x2_t)v546, (float64x2_t)v556), vaddq_f64(*(float64x2_t *)v566, v567)), v226);
                                int8x16_t v546 = (int8x16_t)v226;
                                int8x16_t v556 = (int8x16_t)v227;
                              }
                              uint64_t v218 = (void *)*v218;
                            }
                            while (v218);
                          }
                          else
                          {
                            int8x16_t v546 = 0uLL;
                            int8x16_t v556 = 0uLL;
                          }
                          int64x2_t v231 = vceqzq_f64((float64x2_t)v556);
                          if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v231, 1), (int8x16_t)v231).u64[0] & 0x8000000000000000) != 0
                            || (int8x16_t v232 = vorrq_s8((int8x16_t)vcltzq_f64((float64x2_t)v556), (int8x16_t)vcgezq_f64((float64x2_t)v556)), (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v232), 1), v232).u64[0] & 0x8000000000000000) != 0))
                          {
                            int v235 = 0;
                            int v234 = 0;
                            int32x4_t v604 = 0uLL;
                            float32x4_t v31 = 0uLL;
                            int32x4_t v32 = 0uLL;
                          }
                          else
                          {
                            int32x4_t v233 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64((float64x2_t)v546, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
                            float32x4_t v31 = (float32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64((float64x2_t)v546, (float64x2_t)v556), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v233);
                            int32x4_t v32 = vuzp1q_s32(v233, (int32x4_t)v31);
                            int32x4_t v604 = v32;
                            int v234 = v32.i32[2];
                            int v235 = v31.i32[2];
                            v31.i64[0] = v32.i64[1];
                            *(int32x2_t *)v32.i8 = vmovn_s64((int64x2_t)v233);
                            v32.i32[0] = v233.i32[0];
                          }
                          uint64_t v19 = v217;
                          if (v234 <= v235) {
                            int v236 = v235;
                          }
                          else {
                            int v236 = v234;
                          }
                          if (v234 >= v235) {
                            int v237 = v235;
                          }
                          else {
                            int v237 = v234;
                          }
                          if (v236 <= 1073741822 && v237 >= 1)
                          {
                            *(int32x2_t *)v604.i8 = vadd_s32(*(int32x2_t *)v32.i8, (int32x2_t)0x100000001);
                            v604.i32[2] = v234 + 4;
                            v604.i32[3] = v235 + 4;
                            if (v234 + 4 < 1 || v235 + 4 < 1)
                            {
                              int v235 = 0;
                              int v234 = 0;
                              float32x4_t v31 = 0uLL;
                              v604.i64[1] = 0;
                            }
                            else
                            {
                              v31.i64[0] = v604.i64[1];
                              int v234 = v604.i32[2];
                              int v235 = v604.i32[3];
                            }
                          }
                          v32.i32[1] = 1;
                          uint32x2_t v239 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v31.f32);
                          if ((vpmax_u32(v239, v239).u32[0] & 0x80000000) == 0)
                          {
                            uint32x2_t v240 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v537[1]);
                            *(uint32x2_t *)v32.i8 = vpmax_u32(v240, v240);
                            if (v32.i32[0] < 0
                              || (int32x2_t v241 = vadd_s32(*(int32x2_t *)v604.i8, *(int32x2_t *)v31.f32),
                                  *(int32x2_t *)v31.f32 = vmax_s32(*(int32x2_t *)v604.i8, (int32x2_t)v537[0]),
                                  *(int32x2_t *)v32.i8 = vsub_s32(vmin_s32(v241, vadd_s32((int32x2_t)v537[0], (int32x2_t)v537[1])), *(int32x2_t *)v31.f32), uint32x2_t v242 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v32.i8), (vpmax_u32(v242, v242).u32[0] & 0x80000000) != 0))
                            {
                              int v235 = 0;
                              int v234 = 0;
                              v604.i64[1] = 0;
                            }
                            else
                            {
                              v31.i64[1] = v32.i64[0];
                              int32x4_t v604 = (int32x4_t)v31;
                              int v234 = v32.i32[0];
                              int v235 = v32.i32[1];
                            }
                          }
                          if (v234 >= v235) {
                            int v234 = v235;
                          }
                          if (v234 >= 1)
                          {
                            uint64_t bounds = (*(uint64_t (**)(uint64_t, uint64_t, int32x4_t *, uint64_t))(*(void *)v39 + 656))(v39, 1, &v604, 2063);
                            if (bounds)
                            {
                              int v557 = (_DWORD *)bounds;
                              CA::OGL::Context::push_surface(v39, bounds, 1u, 256, 0);
                              uint64_t v244 = *(void *)(v39 + 16);
                              *(unsigned char *)(v244 + 48CA::Context::unref(this[1], 0) = 18;
                              *(unsigned char *)(v244 + 481) |= 1u;
                              *(void *)(*(void *)(v39 + 16) + 8) = 0x3C00000000000000;
                              uint64_t v245 = *(void *)(v39 + 192);
                              if (v245)
                              {
                                uint64_t v246 = (*(uint64_t (**)(uint64_t))(*(void *)v245 + 16))(v245);
                                if (v246)
                                {
                                  if ((*(unsigned int (**)(uint64_t))(*(void *)v246 + 864))(v246)) {
                                    *(void *)(*(void *)(v39 + 16) + 8) = 0x3C003C003C003C00;
                                  }
                                }
                              }
                              unint64_t v247 = *(double **)(v207 + 1048);
                              if (v247)
                              {
                                do
                                {
                                  if (((_BYTE)v247[20] & 0x10) != 0) {
                                    double scale = CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)(v247 + 2), 0, 0, v243);
                                  }
                                  else {
                                    double scale = v247[18];
                                  }
                                  int8x16_t v609 = 0u;
                                  int8x16_t v610 = 0u;
                                  unint64_t v249 = (int8x16_t *)*((void *)v247 + 1);
                                  int8x16_t v250 = v249[5];
                                  int8x16_t v609 = v249[4];
                                  int8x16_t v610 = v250;
                                  uint64_t v251 = v249[8].i64[0];
                                  float v252 = 0.0;
                                  if (v251) {
                                    float v252 = *(float *)(v251 + 228);
                                  }
                                  double v253 = 0.25 / scale;
                                  double v254 = v252;
                                  CA::BoundsImpl::inset((double *)v609.i64, -(0.25 / scale), -(0.25 / scale));
                                  v566[0] = (CA::Shape *)&v609;
                                  v566[1] = (CA::Shape *)(v247 + 2);
                                  float64x2_t v567 = (float64x2_t)0xFF0000003FuLL;
                                  long long v568 = 0uLL;
                                  CA::OGL::fill_round_rect(v39, (float64x2_t **)v566, (double *)0xF, (double *)(*(_DWORD *)(*((void *)v247 + 1) + 40) & 3), v253 + v254, v253 + v254);
                                  unint64_t v247 = *(double **)v247;
                                }
                                while (v247);
                                float v255 = *(double **)(v207 + 1048);
                                *(unsigned char *)(*(void *)(v39 + 16) + 48CA::Context::unref(this[1], 0) = 9;
                                for (uint64_t j = v9 + 3; v255; v255 = *(double **)v255)
                                {
                                  if (!*((unsigned char *)v255 + 168))
                                  {
                                    int8x16_t v609 = 0u;
                                    int8x16_t v610 = 0u;
                                    float v256 = (int8x16_t *)*((void *)v255 + 1);
                                    int8x16_t v257 = v256[5];
                                    int8x16_t v609 = v256[4];
                                    int8x16_t v610 = v257;
                                    uint64_t v258 = v256[8].i64[0];
                                    if (v258) {
                                      float v259 = *(float *)(v258 + 228);
                                    }
                                    else {
                                      float v259 = 0.0;
                                    }
                                    if (((_BYTE)v255[20] & 0x10) != 0) {
                                      double v260 = CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)(v255 + 2), 0, 0, v243);
                                    }
                                    else {
                                      double v260 = v255[18];
                                    }
                                    double v261 = v259;
                                    double v262 = 4.0 / v260;
                                    CA::BoundsImpl::inset((double *)v609.i64, v262, v262);
                                    double v263 = v261 - v262;
                                    if (v261 - v262 < 0.0) {
                                      double v263 = 0.0;
                                    }
                                    v566[0] = (CA::Shape *)&v609;
                                    v566[1] = (CA::Shape *)(v255 + 2);
                                    float64x2_t v567 = (float64x2_t)0xFF0000003FuLL;
                                    long long v568 = 0uLL;
                                    CA::OGL::fill_round_rect(v39, (float64x2_t **)v566, (double *)0xF, (double *)(*(_DWORD *)(*((void *)v255 + 1) + 40) & 3), v263, v263);
                                    uint64_t j = v9 + 3;
                                  }
                                }
                              }
                              else
                              {
                                *(unsigned char *)(*(void *)(v39 + 16) + 48CA::Context::unref(this[1], 0) = 9;
                              }
                              CA::OGL::Context::pop_surface((CA::OGL::Context *)v39);
                              *(unsigned char *)(*(void *)(v39 + 16) + 48CA::Context::unref(this[1], 0) = 3;
                              uint32x2_t v264 = *(CA::Shape **)(*(void *)(v39 + 248) + 8);
                              v566[0] = 0;
                              v566[1] = 0;
                              CA::OGL::emit_combine(v39, 1u, v557, 0, v264, (unsigned int *)v566);
                              *(unsigned char *)(*(void *)(v39 + 16) + 481) &= ~1u;
                              CA::OGL::Context::release_surface(v39, (uint64_t)v557);
                              uint64_t v19 = v217;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              goto LABEL_340;
            }
            uint64_t bounds = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v39 + 184))(v39, 18);
            if (bounds && *(float *)(v39 + 152) != 1.0)
            {
              v31.f32[0] = (*(float (**)(uint64_t))(*(void *)v39 + 1040))(v39);
              float v108 = v31.f32[0];
              if (v530)
              {
                float v109 = 1.0 / *(float *)(v9[1] + 372);
                uint64_t bounds = (*(uint64_t (**)(CA::WindowServer::Display *))(*(void *)v47 + 1536))(v47);
                int v110 = bounds;
              }
              else
              {
                int v110 = 0;
                float v109 = v31.f32[0];
              }
              char v111 = v109 == 1.0 ? 1 : v110;
              if (v108 != 1.0 || (v111 & 1) == 0)
              {
                *(unsigned char *)(*(void *)(v39 + 16) + 481) &= ~1u;
                *(unsigned char *)(*(void *)(v39 + 16) + 481) |= 2u;
                uint64_t v112 = v19;
                uint64_t v113 = *(void *)(v39 + 16);
                *(_DWORD *)(v113 + 352) = 1065353216;
                float v114 = powf(v108, -1.0 / *(float *)(v39 + 152));
                if (v110) {
                  float v115 = v108;
                }
                else {
                  float v115 = v109;
                }
                v597.i64[0] = __PAIR64__(LODWORD(v115), LODWORD(v114));
                *(unsigned char *)(v113 + 16) = 73;
                uint64_t v19 = v112;
                (*(void (**)(uint64_t, void, uint64_t, uint64_t, int8x16_t *))(*(void *)v39 + 1000))(v39, 0, 2, 1, &v597);
                int v118 = *(_DWORD *)(v39 + 208);
                int v119 = *(_DWORD *)(v39 + 212);
                if (v118 <= v119) {
                  int v120 = *(_DWORD *)(v39 + 212);
                }
                else {
                  int v120 = *(_DWORD *)(v39 + 208);
                }
                v116.i32[0] = 1073741822;
                v117.i32[0] = v120;
                int8x16_t v121 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v117, v116), 0);
                uint64_t v122 = *(void *)(v39 + 200);
                v123.i64[0] = (int)v122;
                v123.i64[1] = SHIDWORD(v122);
                double v124 = (double)v118;
                int8x16_t v609 = vbslq_s8(v121, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v123));
                double v125 = 1.79769313e308;
                if (v120 <= 1073741822) {
                  double v125 = (double)v119;
                }
                else {
                  double v124 = 1.79769313e308;
                }
                *(double *)v610.i64 = v124;
                *(double *)&v610.i64[1] = v125;
                v566[0] = (CA::Shape *)&v609;
                v566[1] = (CA::Shape *)&CA::identity_transform;
                float64x2_t v567 = 0u;
                long long v568 = 0u;
                uint64_t bounds = (uint64_t)CA::OGL::emit_one_part_rect((CA::OGL::Context *)v39, (uint64_t)v566, 0, 0, 0);
                *(unsigned char *)(*(void *)(v39 + 16) + 481) &= ~2u;
                *(unsigned char *)(*(void *)(v39 + 16) + 16) = 0;
              }
            }
            if (v530)
            {
              uint64_t v521 = v19;
              uint64_t v126 = (*(uint64_t (**)(CA::WindowServer::Display *, uint64_t))(*(void *)v47 + 480))(v47, 1);
              long long v568 = 0u;
              long long v569 = 0u;
              *(_OWORD *)v566 = 0u;
              float64x2_t v567 = 0u;
              uint64_t v524 = v47;
              (*(void (**)(CA::Shape **__return_ptr, CA::WindowServer::Display *))(*(void *)v47 + 1496))(v566, v47);
              int8x16_t v609 = (int8x16_t)xmmword_184997E80;
              int8x16_t v610 = (int8x16_t)xmmword_184997E90;
              long long v611 = xmmword_184997EA0;
              uint64_t v612 = 0;
              uint64_t v613 = 0;
              float32x4_t v31 = CA::Mat4Impl::mat4_concat((float32x4_t *)&v609, (float *)v609.i32, (const float *)v566, v127);
              int v128 = 0;
              v604.i64[0] = __PAIR64__(v610.u32[0], v609.u32[0]);
              v604.i64[1] = __PAIR64__(v609.u32[1], v611);
              unint64_t v605 = __PAIR64__(DWORD1(v611), v610.u32[1]);
              __int32 v606 = v609.i32[2];
              __int32 v607 = v610.i32[2];
              int v608 = DWORD2(v611);
              if (v526 && v126)
              {
                uint64_t bounds = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v39 + 928))(v39, v126, 1);
                if (bounds)
                {
                  uint64_t v129 = bounds;
                  uint64_t v130 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v39 + 680))(v39, bounds, 1);
                  if (v130) {
                    char v131 = 76;
                  }
                  else {
                    char v131 = 77;
                  }
                  uint64_t v520 = v130;
                  if (v130) {
                    uint64_t v132 = v130;
                  }
                  else {
                    uint64_t v132 = v129;
                  }
                  *(unsigned char *)(*(void *)(v39 + 16) + 16) = v131;
                  CA::OGL::Context::bind_surface(v39, v132, 0, 0, 0, 0.0);
                  CA::OGL::Context::bind_surface(v39, (uint64_t)v526, 1u, 1u, 1, 0.0);
                  __asm { FMOV            V1.2S, #-1.0 }
                  *(float32x2_t *)v134.i8 = vadd_f32(vcvt_f32_s32(v526[5]), _D1);
                  *(float32x2_t *)v135.i8 = vcvt_f32_s32(v526[3]);
                  v136.i64[0] = 0x3F0000003F000000;
                  v136.i64[1] = 0x3F0000003F000000;
                  float32x4_t v603 = vdivq_f32((float32x4_t)vtrn2q_s32(vrev64q_s32(vzip1q_s32(v134, v134)), v136), (float32x4_t)vzip1q_s32(v135, v135));
                  (*(void (**)(uint64_t, void, uint64_t, uint64_t, float32x4_t *))(*(void *)v39 + 1000))(v39, 0, 4, 1, &v603);
                  int32x4_t v137 = (int32x4_t)((__n128 (*)(uint64_t, uint64_t, uint64_t, uint64_t, int32x4_t *))*(void *)(*(void *)v39 + 1000))(v39, 1, 9, 1, &v604);
                  long long v565 = 0uLL;
                  uint64_t v601 = 0;
                  uint64_t v602 = 0;
                  v137.i32[0] = 1073741822;
                  int32x4_t v553 = v137;
                  int8x16_t v534 = (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
                  int8x16_t v543 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
                  unint64_t v600 = v522;
                  while (CA::ShapeIterator::iterate((uint64_t *)&v600, (int *)&v565))
                  {
                    int32x2_t v139 = *(int32x2_t *)((char *)&v565 + 8);
                    uint32x2_t v140 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v565 + 8));
                    if ((vpmax_u32(v140, v140).u32[0] & 0x80000000) != 0)
                    {
                      int32x2_t v145 = *(int32x2_t *)((char *)&v565 + 8);
                    }
                    else
                    {
                      int32x2_t v141 = *(int32x2_t *)(v39 + 208);
                      uint32x2_t v142 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v141);
                      *(uint32x2_t *)v138.i8 = vpmax_u32(v142, v142);
                      if (v138.i32[0] < 0
                        || (int32x2_t v143 = *(int32x2_t *)(v39 + 200),
                            *(int32x2_t *)&long long v144 = vmax_s32(*(int32x2_t *)&v565, v143),
                            int32x2_t v145 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)&v565, *(int32x2_t *)((char *)&v565 + 8)), vadd_s32(v143, v141)), *(int32x2_t *)&v144), v146 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v145), *(uint32x2_t *)v138.i8 = vpmax_u32(v146, v146), v138.i32[0] < 0))
                      {
                        int32x2_t v139 = 0;
                        *((void *)&v565 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
                        int32x2_t v145 = 0;
                      }
                      else
                      {
                        *((int32x2_t *)&v144 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v145;
                        long long v565 = v144;
                        int32x2_t v139 = v145;
                      }
                    }
                    int v147 = v145.i32[0];
                    if (v145.i32[0] <= v145.i32[1]) {
                      int v147 = v145.i32[1];
                    }
                    v138.i32[0] = v147;
                    v148.i64[0] = (int)v565;
                    v148.i64[1] = SDWORD1(v565);
                    int8x16_t v149 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v138, v553), 0), v543, (int8x16_t)vcvtq_f64_s64(v148));
                    v148.i64[0] = v145.i32[0];
                    v148.i64[1] = v145.i32[1];
                    int8x16_t v150 = (int8x16_t)vcvtq_f64_s64(v148);
                    int32x2_t v151 = vdup_n_s32(v147 > 1073741822);
                    v148.i64[0] = v151.u32[0];
                    v148.i64[1] = v151.u32[1];
                    int32x4_t v563 = (int32x4_t)v149;
                    int8x16_t v564 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v148, 0x3FuLL)), v534, v150);
                    v597.i64[0] = (uint64_t)&v563;
                    v597.i64[1] = (uint64_t)&CA::identity_transform;
                    long long v598 = 0u;
                    long long v599 = 0u;
                    v596[0] = vcvt_f32_s32(*(int32x2_t *)&v565);
                    v596[1] = vcvt_f32_s32(vadd_s32(v139, *(int32x2_t *)&v565));
                    CA::OGL::emit_one_part_rect((CA::OGL::Context *)v39, (uint64_t)&v597, (const CA::Transform *)v596, 0, 0);
                  }
                  CA::OGL::Context::unbind_surface((void *)v39, (uint64_t)v526, 1);
                  if (v520)
                  {
                    CA::OGL::Context::unbind_surface((void *)v39, v520, 0);
                    CA::OGL::Context::release_surface(v39, v520);
                  }
                  else
                  {
                    uint64_t bounds = CA::OGL::Context::unbind_surface((void *)v39, v129, 0);
                  }
                  uint64_t j = v9 + 3;
                  int v128 = 1;
                }
                else
                {
                  int v128 = 0;
                }
              }
              if ((*(_WORD *)(v39 + 832) & 2) == 0)
              {
                uint64_t bounds = (*(uint64_t (**)(CA::WindowServer::Display *))(*(void *)v524 + 1504))(v524);
                if (bounds)
                {
                  v604.i64[0] = __PAIR64__(LODWORD(v567.f64[0]), v566[0]);
                  v604.i64[1] = __PAIR64__(HIDWORD(v566[0]), v568);
                  unint64_t v605 = __PAIR64__(DWORD1(v568), HIDWORD(v567.f64[0]));
                  __int32 v606 = (__int32)v566[1];
                  __int32 v607 = LODWORD(v567.f64[1]);
                  int v608 = DWORD2(v568);
                  *(unsigned char *)(*(void *)(v39 + 16) + 16) = 74;
                  (*(void (**)(uint64_t, void, uint64_t, uint64_t, int32x4_t *))(*(void *)v39 + 1000))(v39, 0, 9, 1, &v604);
                  double v159 = (CA::Shape *)CA::Shape::new_shape((unsigned int *)(v9[1] + 192));
                  long long v162 = v159;
                  if (v128) {
                    unint64_t v163 = CA::Shape::subtract(v159, (const CA::Shape *)v522, v160, v161);
                  }
                  else {
                    unint64_t v163 = CA::Shape::ref((unint64_t)v159);
                  }
                  double v165 = (CA::Shape *)v163;
                  float32x4_t v603 = 0uLL;
                  uint64_t v601 = 0;
                  uint64_t v602 = 0;
                  v164.i32[0] = 1073741822;
                  int32x4_t v554 = v164;
                  int8x16_t v535 = (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
                  int8x16_t v544 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
                  unint64_t v600 = v163;
                  while (CA::ShapeIterator::iterate((uint64_t *)&v600, (int *)&v603))
                  {
                    int32x2_t v167 = *(int32x2_t *)&v603.u32[2];
                    uint32x2_t v168 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)&v603.u32[2]);
                    *(uint32x2_t *)v166.i8 = vpmax_u32(v168, v168);
                    if ((v166.i32[0] & 0x80000000) == 0)
                    {
                      v166.i64[0] = *(void *)(v39 + 208);
                      uint32x2_t v169 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v166.i8);
                      if ((vpmax_u32(v169, v169).u32[0] & 0x80000000) != 0
                        || (int32x2_t v170 = *(int32x2_t *)(v39 + 200),
                            int32x2_t v171 = vadd_s32(v170, *(int32x2_t *)v166.i8),
                            *(int32x2_t *)v166.i8 = vmax_s32(*(int32x2_t *)v603.f32, v170),
                            int32x2_t v167 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)v603.f32, *(int32x2_t *)&v603.u32[2]), v171), *(int32x2_t *)v166.i8), v172 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v167), (vpmax_u32(v172, v172).u32[0] & 0x80000000) != 0))
                      {
                        int32x2_t v167 = 0;
                        v603.i64[1] = 0;
                      }
                      else
                      {
                        v166.u64[1] = (unint64_t)v167;
                        float32x4_t v603 = (float32x4_t)v166;
                      }
                    }
                    int v173 = v167.i32[0];
                    if (v167.i32[0] <= v167.i32[1]) {
                      int v173 = v167.i32[1];
                    }
                    v166.i32[0] = v173;
                    v174.i64[0] = v603.i32[0];
                    v174.i64[1] = v603.i32[1];
                    int8x16_t v175 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v166, v554), 0), v544, (int8x16_t)vcvtq_f64_s64(v174));
                    v174.i64[0] = v167.i32[0];
                    v174.i64[1] = v167.i32[1];
                    int8x16_t v176 = (int8x16_t)vcvtq_f64_s64(v174);
                    int32x2_t v177 = vdup_n_s32(v173 > 1073741822);
                    v174.i64[0] = v177.u32[0];
                    v174.i64[1] = v177.u32[1];
                    int32x4_t v563 = (int32x4_t)v175;
                    int8x16_t v564 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v174, 0x3FuLL)), v535, v176);
                    v597.i64[0] = (uint64_t)&v563;
                    v597.i64[1] = (uint64_t)&CA::identity_transform;
                    long long v598 = 0u;
                    long long v599 = 0u;
                    CA::OGL::emit_one_part_rect((CA::OGL::Context *)v39, (uint64_t)&v597, 0, 0, 0);
                  }
                  CA::Shape::unref(v165);
                  CA::Shape::unref(v162);
                  uint64_t j = v9 + 3;
                }
              }
              *(unsigned char *)(*(void *)(v39 + 16) + 16) = 0;
              uint64_t v19 = v521;
              uint64_t v47 = v524;
            }
            goto LABEL_212;
          }
LABEL_105:
          LODWORD(v73) = 1;
          goto LABEL_106;
        }
        v526 = 0;
        int v530 = 1;
      }
      else
      {
        int v530 = 0;
        uint64_t v47 = 0;
        v526 = 0;
        uint64_t v48 = *(void *)(v38 + 24);
      }
      uint64_t v522 = v48;
      goto LABEL_71;
    }
LABEL_35:
    *(void *)(*(void *)(v33 + 16) + 8) = 0;
    *(unsigned char *)(*(void *)(*v9 + 16) + 481) &= ~1u;
    WORD2(v578) &= ~0x400u;
    uint64_t bounds = CA::OGL::emit_shape((CA::OGL *)*v9, v35, v29);
    WORD2(v578) |= 0x400u;
    goto LABEL_36;
  }
LABEL_433:
  uint64_t v333 = *v9;
  BOOL v334 = (*(_WORD *)(*v9 + 832) & 0x180) != 0 && (*(_WORD *)(*v9 + 832) & 1) == 0;
  if (v334
    && *(_DWORD *)(v8 + 248) != CA::OGL::Renderer::render(CA::Render::Update const*,unsigned long,CA::WindowServer::SharedEvent *)::last_seed_recorded)
  {
    if (v17)
    {
      double v335 = (double)CA::Shape::area((CA::Shape *)v17);
    }
    else
    {
      int v336 = *(_DWORD *)(v333 + 208);
      int v337 = *(_DWORD *)(v333 + 212);
      if (v336 <= v337) {
        int v338 = *(_DWORD *)(v333 + 212);
      }
      else {
        int v338 = *(_DWORD *)(v333 + 208);
      }
      double v335 = INFINITY;
      if (v338 <= 1073741822) {
        double v335 = (double)v337 * (double)v336;
      }
    }
    CARecordFrame(*(_DWORD *)(v333 + 708), *(_DWORD *)(v333 + 712), *(_DWORD *)(v333 + 716), 0, *(double *)(v333 + 240), v335, (double)*(unint64_t *)(v333 + 728));
    CA::OGL::Renderer::render(CA::Render::Update const*,unsigned long,CA::WindowServer::SharedEvent *)::last_seed_recorded = *(_DWORD *)(v8 + 248);
    uint64_t v333 = *v9;
  }
  *((unsigned char *)v9 + 10CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  uint64_t v339 = (*(uint64_t (**)(uint64_t, void))(*(void *)v333 + 184))(v333, 0);
  if (v339)
  {
    uint64_t v340 = v339;
    if (x_log_hook_p())
    {
      (*(void (**)(void, uint64_t))(*(void *)*v9 + 192))(*v9, v340);
      x_log_();
    }
    else
    {
      int64x2_t v341 = x_log_category_ogl;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR))
      {
        uint64_t v342 = (*(uint64_t (**)(void, uint64_t))(*(void *)*v9 + 192))(*v9, v340);
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v342;
        _os_log_impl(&dword_184668000, v341, OS_LOG_TYPE_ERROR, "CoreAnimation: rendering error %s\n", buf, 0xCu);
      }
    }
  }
  *(void *)(*v9 + 216) = 0;
  CA::Render::Update::mark_composited((CA::Render::Update *)v8);
  v9[1] = 0;
  j[1] = 0;
  j[2] = 0;
  *uint64_t j = 0;
  if (v22) {
    CA::Shape::unref((CA::Shape *)v17);
  }
}

void CA::OGL::MetalContext::shared_event_submit(CA::OGL::MetalContext *this, uint64_t a2, const char *a3, int a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return;
  }
  int v5 = (int)a3;
  if (*((void *)this + 372)) {
    CA::OGL::MetalContext::stop_encoders(this);
  }
  else {
    CA::OGL::MetalContext::start_command_buffer(this, *((void *)this + 386), a3);
  }
  if (!*((void *)this + 372))
  {
    if (x_log_hook_p()) {
      goto LABEL_14;
    }
    uint64_t v13 = x_log_category_sharedevent;
    if (!os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR)) {
      return;
    }
    __int16 v17 = 0;
    CFNumberType v14 = "Invalid command buffer";
    uint64_t v15 = (uint8_t *)&v17;
LABEL_24:
    _os_log_impl(&dword_184668000, v13, OS_LOG_TYPE_ERROR, v14, v15, 2u);
    return;
  }
  uint64_t v8 = *(void *)(a2 + 8);
  if (v8)
  {
    if (v5)
    {
      uint64_t wait_value = CA::WindowServer::SharedEvent::get_wait_value(a2, 14, a4);
      uint64_t v10 = (void *)*((void *)this + 372);
      [v10 encodeWaitForEvent:v8 value:wait_value];
    }
    else
    {
      uint64_t v11 = CA::WindowServer::SharedEvent::inc_signal_value(a2, 14, a4);
      uint64_t v12 = (void *)*((void *)this + 372);
      [v12 encodeSignalEvent:v8 value:v11];
    }
    return;
  }
  if (!x_log_hook_p())
  {
    uint64_t v13 = x_log_category_sharedevent;
    if (!os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR)) {
      return;
    }
    __int16 v16 = 0;
    CFNumberType v14 = "Invalid metal shared event";
    uint64_t v15 = (uint8_t *)&v16;
    goto LABEL_24;
  }
LABEL_14:

  x_log_();
}

void CA::OGL::MetalContext::shared_event_wait_write(CA::OGL::MetalContext *this, CA::WindowServer::SharedEvent *a2)
{
}

void CA::OGL::MetalContext::shared_event_signal_write(CA::OGL::MetalContext *this, CA::WindowServer::SharedEvent *a2)
{
}

void CA::WindowServer::IOMFBDisplay::foreach_detached_layer(CA::WindowServer::IOMFBDisplay *this, void (*a2)(CA::Render::Handle *, uint64_t, CA::Render::Texture *, void *), void *a3)
{
  uint64_t v3 = *((void *)this + 3255);
  if (v3 && (*(unsigned char *)(v3 + 292) & 1) == 0)
  {
    if (*(void *)v3) {
      a2(*(CA::Render::Handle **)v3, *(int *)(v3 + 288), *(CA::Render::Texture **)(v3 + 8), a3);
    }
    else {
      CA::WindowServer::IOMFBDisplay::delete_detached_layer(this);
    }
  }
}

uint64_t CA::WindowServer::anonymous namespace'::OGLDisplay::foreach_detached_layer(CA::WindowServer::_anonymous_namespace_::OGLDisplay *this, void (*a2)(CA::Render::Handle *, uint64_t, CA::Render::Texture *, void *), void *a3)
{
  return (*(uint64_t (**)(void, void (*)(CA::Render::Handle *, uint64_t, CA::Render::Texture *, void *), void *))(**((void **)this + 1) + 600))(*((void *)this + 1), a2, a3);
}

char *CAGetDebugMessage()
{
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (debug_message) {
    return &debug_message;
  }
  else {
    return 0;
  }
}

uint64_t CA::WindowServer::IOMFBDisplay::color_flush_shape(CA::WindowServer::IOMFBDisplay *this, const CA::Render::Update *a2)
{
  uint64_t v3 = (pthread_mutex_t *)((char *)this + 25720);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
  uint64_t v4 = *((void *)this + 6 * *((unsigned int *)this + 6426) + 3224);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 24);
  }
  else {
    uint64_t v5 = 0;
  }
  pthread_mutex_unlock(v3);
  return v5;
}

float32x4_t CA::Mat4Impl::mat4_concat(float32x4_t *this, float *a2, const float *a3, const float *a4)
{
  float32x4_t v4 = *(float32x4_t *)(a2 + 4);
  float64x2_t v5 = vcvt_hight_f64_f32(*(float32x4_t *)a2);
  float64x2_t v6 = vcvtq_f64_f32(*(float32x2_t *)a2);
  float64x2_t v7 = vcvt_hight_f64_f32(v4);
  float64x2_t v8 = vcvtq_f64_f32(*(float32x2_t *)v4.f32);
  float32x4_t v9 = *(float32x4_t *)(a2 + 8);
  float32x4_t v10 = *(float32x4_t *)(a2 + 12);
  float64x2_t v11 = vcvt_hight_f64_f32(v9);
  float64x2_t v12 = vcvtq_f64_f32(*(float32x2_t *)v9.f32);
  float64x2_t v13 = vcvt_hight_f64_f32(v10);
  float64x2_t v14 = vcvtq_f64_f32(*(float32x2_t *)v10.f32);
  float32x4_t v15 = *(float32x4_t *)(a3 + 4);
  float64x2_t v16 = vcvt_hight_f64_f32(*(float32x4_t *)a3);
  float64x2_t v17 = vcvtq_f64_f32(*(float32x2_t *)a3);
  float64x2_t v18 = vmulq_n_f64(v17, v6.f64[0]);
  float64x2_t v19 = vmulq_n_f64(v16, v6.f64[0]);
  float64x2_t v20 = vmulq_n_f64(v17, v8.f64[0]);
  float64x2_t v21 = vmulq_n_f64(v16, v8.f64[0]);
  float64x2_t v22 = vmulq_n_f64(v17, v12.f64[0]);
  float64x2_t v23 = vmulq_n_f64(v16, v12.f64[0]);
  float64x2_t v24 = vmulq_n_f64(v17, v14.f64[0]);
  float64x2_t v25 = vmulq_n_f64(v16, v14.f64[0]);
  float64x2_t v26 = vcvt_hight_f64_f32(v15);
  float64x2_t v27 = vcvtq_f64_f32(*(float32x2_t *)v15.f32);
  float64x2_t v28 = vmlaq_laneq_f64(v18, v27, v6, 1);
  float64x2_t v29 = vmlaq_laneq_f64(v19, v26, v6, 1);
  float64x2_t v30 = vmlaq_laneq_f64(v20, v27, v8, 1);
  float64x2_t v31 = vmlaq_laneq_f64(v21, v26, v8, 1);
  float64x2_t v32 = vmlaq_laneq_f64(v22, v27, v12, 1);
  float64x2_t v33 = vmlaq_laneq_f64(v23, v26, v12, 1);
  float32x4_t v34 = *(float32x4_t *)(a3 + 8);
  float32x4_t v35 = *(float32x4_t *)(a3 + 12);
  float64x2_t v36 = vcvt_hight_f64_f32(v34);
  float64x2_t v37 = vcvtq_f64_f32(*(float32x2_t *)v34.f32);
  float64x2_t v38 = vmlaq_n_f64(v28, v37, v5.f64[0]);
  float64x2_t v39 = vmlaq_n_f64(v30, v37, v7.f64[0]);
  float64x2_t v40 = vmlaq_n_f64(v32, v37, v11.f64[0]);
  float64x2_t v41 = vmlaq_n_f64(vmlaq_laneq_f64(v24, v27, v14, 1), v37, v13.f64[0]);
  float64x2_t v42 = vcvt_hight_f64_f32(v35);
  float64x2_t v43 = vcvtq_f64_f32(*(float32x2_t *)v35.f32);
  *this = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_laneq_f64(v38, v43, v5, 1)), vmlaq_laneq_f64(vmlaq_n_f64(v29, v36, v5.f64[0]), v42, v5, 1));
  this[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_laneq_f64(v39, v43, v7, 1)), vmlaq_laneq_f64(vmlaq_n_f64(v31, v36, v7.f64[0]), v42, v7, 1));
  float32x4_t result = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_laneq_f64(v40, v43, v11, 1)), vmlaq_laneq_f64(vmlaq_n_f64(v33, v36, v11.f64[0]), v42, v11, 1));
  this[2] = result;
  this[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_laneq_f64(v41, v43, v13, 1)), vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(v25, v26, v14, 1), v36, v13.f64[0]), v42, v13, 1));
  return result;
}

float CA::OGL::MetalContext::hdr_scale(CA::OGL::MetalContext *this)
{
  return *((float *)this + 734);
}

uint64_t CA::WindowServer::IOMFBDisplay::needs_p3_clamp(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28174);
}

uint64_t CA::WindowServer::IOMFBDisplay::displayed_surface(CA::WindowServer::IOMFBDisplay *this, char a2)
{
  float32x4_t v4 = (pthread_mutex_t *)((char *)this + 25720);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
  uint64_t v5 = *((void *)this + 6 * *((unsigned int *)this + 6427) + 3224);
  if (v5)
  {
    if ((a2 & 1) == 0) {
      *(unsigned char *)(v5 + 132) |= 8u;
    }
    uint64_t v6 = *(void *)(v5 + 32);
  }
  else
  {
    uint64_t v6 = 0;
  }
  pthread_mutex_unlock(v4);
  return v6;
}

uint64_t CA::WindowServer::IOMFBDisplay::detached_layers_valid_p(CA::WindowServer::IOMFBDisplay *this, const CA::Render::Update *a2)
{
  v58[1] = *MEMORY[0x1E4F143B8];
  if ((*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1544))(this)) {
    return 1;
  }
  uint64_t v4 = *((void *)this + 3255);
  if (!v4 || !*(void *)(v4 + 24) || (*(unsigned char *)(v4 + 292) & 1) != 0) {
    return 1;
  }
  uint64_t v5 = (unsigned int *)((char *)this + 25704);
  int v6 = *((_DWORD *)this + 6801);
  switch(v6)
  {
    case 3:
      uint64_t v31 = 216;
      if ((*(_DWORD *)(v4 + 40) & 8) == 0) {
        uint64_t v31 = 208;
      }
      if (!(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *, unint64_t))(*(void *)this + 2272))(this, (unint64_t)*(double *)(v4 + v31)))return 0; {
      float64x2_t v7 = (pthread_mutex_t *)((char *)this + 25720);
      }
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
      uint64_t v32 = *((void *)this + 6 * *v5 + 3224);
      if (!v32
        || (uint64_t v33 = *(void *)(v32 + 32)) == 0
        || (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *, void))(*(void *)this + 2272))(this, *(unsigned int *)(v33 + 56)))
      {
        uint64_t v29 = 1;
LABEL_49:
        pthread_mutex_unlock(v7);
        return v29;
      }
      goto LABEL_51;
    case 2:
      float64x2_t v7 = (pthread_mutex_t *)((char *)this + 25720);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
      uint64_t v37 = *((void *)this + 3255);
      uint64_t v38 = *((void *)this + 6 * *v5 + 3224);
      v58[0] = 0;
      float v39 = (float)*((int *)this + 52);
      double v41 = *(double *)(v37 + 208);
      double v40 = *(double *)(v37 + 216);
      int v42 = *(_DWORD *)(v37 + 40);
      if ((v42 & 8) != 0) {
        double v43 = *(double *)(v37 + 216);
      }
      else {
        double v43 = *(double *)(v37 + 208);
      }
      if ((v42 & 8) != 0) {
        double v40 = *(double *)(v37 + 208);
      }
      v44.n128_f32[0] = CA::WindowServer::layer_bandwidth_v2((CA::WindowServer *)*(unsigned int *)(*(void *)(v37 + 24) + 64), (CA::WindowServer::Surface *)((char *)v58 + 4), (const CA::Rect *)v58, v34, v43, v35, v36, v40, *(double *)(v37 + 248), v39);
      uint64_t v29 = 0;
      if (!(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *, unint64_t, __n128))(*(void *)this + 2272))(this, (unint64_t)v41, v44))goto LABEL_49; {
      if (!v38)
      }
        goto LABEL_47;
      uint64_t v50 = *(void *)(v38 + 32);
      if (!v50 || (*(unsigned char *)(v38 + 132) & 4) != 0 || (*((unsigned char *)a2 + 268) & 8) == 0) {
        goto LABEL_47;
      }
      uint64_t v51 = *(void *)(v50 + 56);
      unsigned int v57 = v51;
      v52.i64[0] = v51;
      v52.i64[1] = HIDWORD(v51);
      float64x2_t v53 = vcvtq_f64_u64(v52);
      int v54 = *((_DWORD *)this + 40);
      int v55 = *((_DWORD *)this + 41);
      if (v54 <= v55) {
        int v54 = *((_DWORD *)this + 41);
      }
      double v56 = 1.79769313e308;
      if (v54 <= 1073741822) {
        double v56 = (double)v55;
      }
      CA::WindowServer::layer_bandwidth_v2((CA::WindowServer *)*(unsigned int *)(v50 + 64), (CA::WindowServer::Surface *)((char *)v58 + 4), (const CA::Rect *)v58, v45, v53.f64[0], v46, v47, v53.f64[1], v56, v39);
      if ((*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *, void))(*(void *)this + 2272))(this, v57))
      {
LABEL_47:
        v48.n128_u32[0] = HIDWORD(v58[0]);
        v49.n128_u32[0] = v58[0];
        uint64_t v28 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, __n128, __n128))(*(void *)this + 2280))(this, v48, v49);
LABEL_48:
        uint64_t v29 = v28;
        goto LABEL_49;
      }
LABEL_51:
      uint64_t v29 = 0;
      goto LABEL_49;
    case 1:
      float64x2_t v7 = (pthread_mutex_t *)((char *)this + 25720);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
      uint64_t v8 = *((void *)this + 3255);
      double v9 = *(double *)(v8 + 208);
      int v10 = *(_DWORD *)(v8 + 40);
      if ((v10 & 8) != 0) {
        double v11 = *(double *)(v8 + 216);
      }
      else {
        double v11 = *(double *)(v8 + 208);
      }
      if ((v10 & 8) == 0) {
        double v9 = *(double *)(v8 + 216);
      }
      uint64_t v12 = *((void *)this + 6 * *v5 + 3224);
      float v13 = *(double *)(v8 + 240) / v11;
      float v14 = *(double *)(v8 + 248) / v9;
      unint64_t v15 = CA::WindowServer::Surface::bits_per_pixel((CA::WindowServer::Surface *)*(unsigned int *)(*(void *)(v8 + 24) + 64));
      v17.n128_f32[0] = v13 * 8.0;
      float v18 = (float)v15 / (float)((float)(v13 * 8.0) * v14);
      float v19 = (float)(ceilf(1.0 / v14) * (float)v15) / v17.n128_f32[0];
      if (v12)
      {
        float64x2_t v20 = *(_DWORD **)(v12 + 32);
        if (v20)
        {
          if ((*(unsigned char *)(v12 + 132) & 4) == 0 && (*((unsigned char *)a2 + 268) & 8) != 0)
          {
            v16.n128_u32[0] = v20[14];
            v17.n128_u32[0] = v20[15];
            v16.n128_f64[0] = (double)v16.n128_u64[0];
            v17.n128_f64[0] = (double)v17.n128_u64[0];
            int v21 = *((_DWORD *)this + 40);
            int v22 = *((_DWORD *)this + 41);
            double v23 = (double)v21;
            double v24 = (double)v22;
            if (v21 <= v22) {
              int v21 = *((_DWORD *)this + 41);
            }
            if (v21 > 1073741822)
            {
              double v23 = 1.79769313e308;
              double v24 = 1.79769313e308;
            }
            float v25 = v23 / v16.n128_f64[0];
            float v26 = v24 / v17.n128_f64[0];
            unint64_t v27 = CA::WindowServer::Surface::bits_per_pixel((CA::WindowServer::Surface *)v20[16]);
            float v18 = (float)((float)v27 / (float)((float)(v25 * 8.0) * v26)) + v18;
            float v19 = (float)((float)(ceilf(1.0 / v26) * (float)v27) / (float)(v25 * 8.0)) + v19;
          }
        }
      }
      v16.n128_f32[0] = v18;
      v17.n128_f32[0] = v19;
      uint64_t v28 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, __n128, __n128))(*(void *)this + 2280))(this, v16, v17);
      goto LABEL_48;
  }
  return 1;
}

BOOL CA::WindowServer::AppleDisplay::valid_clocking_p(CA::WindowServer::AppleDisplay *this, uint64_t a2)
{
  return *((_OWORD *)this + 1774) == 0
      || *((void *)this + 3549) * a2 <= (unint64_t)(2 * *((void *)this + 3548) * *((int *)this + 52));
}

uint64_t CA::OGL::emit_shape(CA::OGL *this, CA::OGL::Context *a2, const CA::Shape *a3)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(*((void *)this + 2) + 16) = 0;
  uint64_t v5 = *(CA::OGL::Context **)(*((void *)this + 31) + 8);
  int v6 = (int32x2_t *)*((void *)this + 33);
  if (v6) {
    float64x2_t v7 = v6 + 4;
  }
  else {
    float64x2_t v7 = (int32x2_t *)((char *)this + 200);
  }
  BOOL v8 = CA::OGL::Context::need_transparent_source(this);
  BOOL v11 = v8;
  int v12 = *((unsigned __int8 *)this + 64);
  if (*((unsigned char *)this + 64)) {
    *((unsigned char *)this + 64) = 0;
  }
  *((void *)this + 16) = 0;
  float v13 = (char *)this + 834;
  *((void *)this + 12) = (char *)this + 834;
  *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
  if ((a2 & 1) == 0)
  {
    if (*((_DWORD *)a2 + 1) == 6) {
      goto LABEL_8;
    }
LABEL_11:
    if (v5 == a2) {
      uint64_t v14 = CA::Shape::ref((unint64_t)a2);
    }
    else {
      uint64_t v14 = CA::Shape::intersect((uint64_t)v5, (uint64_t)a2);
    }
    unint64_t v15 = (CA::Shape *)v14;
    if (v14)
    {
      if (v14 == 1) {
        goto LABEL_32;
      }
    }
    else if (*(_DWORD *)(v14 + 4) == 6)
    {
      goto LABEL_32;
    }
    uint64_t v16 = *(void *)(*((void *)this + 2) + 8);
    long long v46 = 0uLL;
    uint64_t v48 = 0;
    uint64_t v49 = 0;
    unint64_t v47 = v14;
    while (CA::ShapeIterator::iterate((uint64_t *)&v47, (int *)&v46))
    {
      uint32x2_t v17 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v46 + 8));
      if ((vpmax_u32(v17, v17).u32[0] & 0x80000000) == 0)
      {
        int32x2_t v18 = v7[1];
        uint32x2_t v19 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v18);
        if ((vpmax_u32(v19, v19).u32[0] & 0x80000000) != 0
          || (int32x2_t v20 = vmax_s32(*(int32x2_t *)&v46, *v7),
              int32x2_t v21 = vmin_s32(vadd_s32(*(int32x2_t *)&v46, *(int32x2_t *)((char *)&v46 + 8)), vadd_s32(*v7, v18)),
              int32x2_t v22 = vsub_s32(v21, v20),
              uint32x2_t v23 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v22),
              (vpmax_u32(v23, v23).u32[0] & 0x80000000) != 0))
        {
          *((void *)&v46 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
        }
        else
        {
          *(int32x2_t *)&long long v24 = v20;
          *((int32x2_t *)&v24 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v22;
          long long v46 = v24;
          if (*((_DWORD *)this + 23)) {
            uint64_t v25 = 6;
          }
          else {
            uint64_t v25 = 4;
          }
          if ((unint64_t)(*((void *)this + 16) + 4) > *((void *)this + 17)
            || (unint64_t v26 = *((void *)this + 14)) != 0 && *((void *)this + 13) + v25 > v26)
          {
            *((_WORD *)this + 416) |= 0x20u;
            int32x2_t v42 = v20;
            int32x2_t v44 = v21;
            CA::OGL::Context::array_flush((uint64_t)this);
            int32x2_t v20 = v42;
            int32x2_t v21 = v44;
            *((void *)this + 16) = 0;
            *((void *)this + 12) = v13;
            *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
          }
          CA::OGL::Context::array_rect(this, (float)v20.i32[0], (float)v20.i32[1], (float)v21.i32[0], (float)v21.i32[1]);
          uint64_t v27 = *((void *)this + 15) + 48 * *((void *)this + 16);
          *(void *)(v27 - 16CA::Context::unref(this[1], 0) = v16;
          *(void *)(v27 - 112) = v16;
          *(void *)(v27 - 64) = v16;
          *(void *)(v27 - 16) = v16;
        }
      }
    }
LABEL_32:
    CA::Shape::unref(v15);
    if (!v11) {
      goto LABEL_52;
    }
LABEL_33:
    unint64_t v28 = CA::Shape::subtract(v5, a2, v9, v10);
    uint64_t v29 = (CA::Shape *)v28;
    if (v28)
    {
      if (v28 == 1)
      {
LABEL_51:
        CA::Shape::unref(v29);
        goto LABEL_52;
      }
    }
    else if (*(_DWORD *)(v28 + 4) == 6)
    {
      goto LABEL_51;
    }
    long long v46 = 0uLL;
    uint64_t v48 = 0;
    uint64_t v49 = 0;
    unint64_t v47 = v28;
    while (CA::ShapeIterator::iterate((uint64_t *)&v47, (int *)&v46))
    {
      uint32x2_t v30 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v46 + 8));
      if ((vpmax_u32(v30, v30).u32[0] & 0x80000000) == 0)
      {
        int32x2_t v31 = v7[1];
        uint32x2_t v32 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v31);
        if ((vpmax_u32(v32, v32).u32[0] & 0x80000000) != 0
          || (int32x2_t v33 = vmax_s32(*(int32x2_t *)&v46, *v7),
              int32x2_t v34 = vmin_s32(vadd_s32(*(int32x2_t *)&v46, *(int32x2_t *)((char *)&v46 + 8)), vadd_s32(*v7, v31)),
              int32x2_t v35 = vsub_s32(v34, v33),
              uint32x2_t v36 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v35),
              (vpmax_u32(v36, v36).u32[0] & 0x80000000) != 0))
        {
          *((void *)&v46 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
        }
        else
        {
          *(int32x2_t *)&long long v37 = v33;
          *((int32x2_t *)&v37 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v35;
          long long v46 = v37;
          if (*((_DWORD *)this + 23)) {
            uint64_t v38 = 6;
          }
          else {
            uint64_t v38 = 4;
          }
          if ((unint64_t)(*((void *)this + 16) + 4) > *((void *)this + 17)
            || (unint64_t v39 = *((void *)this + 14)) != 0 && *((void *)this + 13) + v38 > v39)
          {
            *((_WORD *)this + 416) |= 0x20u;
            int32x2_t v43 = v33;
            int32x2_t v45 = v34;
            CA::OGL::Context::array_flush((uint64_t)this);
            int32x2_t v33 = v43;
            int32x2_t v34 = v45;
            *((void *)this + 16) = 0;
            *((void *)this + 12) = v13;
            *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
          }
          CA::OGL::Context::array_rect(this, (float)v33.i32[0], (float)v33.i32[1], (float)v34.i32[0], (float)v34.i32[1]);
          uint64_t v40 = *((void *)this + 15) + 48 * *((void *)this + 16);
          *(void *)(v40 - 16CA::Context::unref(this[1], 0) = 0;
          *(void *)(v40 - 112) = 0;
          *(void *)(v40 - 64) = 0;
          *(void *)(v40 - 16) = 0;
        }
      }
    }
    goto LABEL_51;
  }
  if (a2 != (CA::OGL::Context *)1) {
    goto LABEL_11;
  }
LABEL_8:
  if (v8) {
    goto LABEL_33;
  }
LABEL_52:
  uint64_t result = CA::OGL::Context::array_flush((uint64_t)this);
  if (v12) {
    *((unsigned char *)this + 64) = 1;
  }
  *(unsigned char *)(*((void *)this + 2) + 16) = 0;
  return result;
}

_DWORD *CA::OGL::LayerNode::retain_surface(CA::OGL::LayerNode *this, float *a2, unsigned int a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 2);
  uint64_t v5 = *(void *)(v4 + 32);
  if ((v5 & 8) != 0)
  {
    uint64_t v9 = *((void *)this + 1);
    int v10 = *(void **)v9;
    BOOL v11 = *(_DWORD **)(*(void *)v9 + 280);
    if (v11
      || (BOOL v11 = (_DWORD *)(*(uint64_t (**)(void *, float *))(*v10 + 728))(v10, a2), (v10[35] = v11) != 0))
    {
      ++*v11;
    }
    return v11;
  }
  if ((*(_WORD *)(v4 + 40) & 8) == 0) {
    goto LABEL_4;
  }
  if ((v5 & 0x2000013C0) != 0) {
    goto LABEL_4;
  }
  int v12 = (CA::OGL::Context **)*((void *)this + 1);
  if ((v5 & 0x20) != 0)
  {
    uint64_t v13 = *(void *)(*(void *)(v4 + 24) + 128);
    if (v13)
    {
      if (*(void *)(v13 + 80)) {
        goto LABEL_4;
      }
    }
  }
  uint64_t v14 = *(void *)(v4 + 16);
  if (v14)
  {
    if (*(void *)(v14 + 144)) {
      goto LABEL_4;
    }
  }
  uint64_t v15 = *(void *)(*(void *)(v4 + 24) + 128);
  if (v15)
  {
    if (*(float *)(v15 + 228) != 0.0) {
      goto LABEL_4;
    }
  }
  uint64_t v16 = *(void *)(v14 + 256);
  if (!v16) {
    goto LABEL_4;
  }
  uint32x2_t v17 = (os_unfair_lock_s *)(v16 + 36);
  os_unfair_lock_lock((os_unfair_lock_t)(v16 + 36));
  uint64_t v18 = *(void *)(v16 + 40);
  if (!v18)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(v16 + 36));
    goto LABEL_4;
  }
  uint32x2_t v19 = (os_unfair_lock_s *)(v18 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(v18 + 40));
  int32x2_t v21 = *v12;
  uint64_t v22 = *(void *)(v18 + 48);
  if (v22)
  {
    if (*(CA::OGL::Context **)(v22 + 8) == v21)
    {
      if ((*(unsigned char *)(v22 + 216) & 2) == 0) {
        goto LABEL_45;
      }
      char v23 = 0;
      goto LABEL_24;
    }
    uint64_t v22 = 0;
  }
  char v23 = 1;
LABEL_24:
  uint64_t v24 = *(void *)(v18 + 64);
  uint64_t v25 = *(void *)(v18 + 72);
  float v26 = 0.0;
  if (v24 == v25) {
    goto LABEL_49;
  }
  while (*(void *)v24 != *(void *)(v16 + 24))
  {
    v24 += 168;
    if (v24 == v25) {
      goto LABEL_49;
    }
  }
  if (*(unsigned char *)(v24 + 160)) {
    goto LABEL_49;
  }
  uint64_t v27 = *(void *)(v4 + 24);
  uint64_t v28 = *(void *)(v27 + 128);
  if (v28)
  {
    uint64_t v28 = *(void *)v28;
    if (v28)
    {
      if (*(unsigned char *)(v28 + 12) != 3) {
        uint64_t v28 = 0;
      }
    }
  }
  if ((v23 & 1) != 0 || !*(void *)(v22 + 32) || (*(unsigned char *)(v28 + 13) & 0x10) != 0)
  {
    if ((*(unsigned char *)(v4 + 32) & 0x20) == 0)
    {
      BOOL v11 = CA::OGL::Context::retain_null_surface(v21);
      float v26 = 1.0;
      goto LABEL_50;
    }
    goto LABEL_49;
  }
  if ((*((_WORD *)this + 62) & 0x100) == 0
    || (uint64_t v29 = v4,
        uint32x2_t v30 = (float64x2_t *)v24,
        uint64_t v33 = v22,
        uint64_t v34 = v28,
        uint64_t v31 = *((void *)this + 10),
        (*(unsigned char *)(v31 + 144) & 0x10) != 0)
    && !CA::Mat4Impl::mat4_is_rectilinear(*((CA::Mat4Impl **)this + 10), v20))
  {
LABEL_49:
    BOOL v11 = 0;
    goto LABEL_50;
  }
  float64x2_t v35 = 0u;
  float64x2_t v36 = 0u;
  CA::Render::BackdropLayer::get_backdrop_bounds(v34, v27, (uint64_t)&v35);
  CA::BoundsImpl::intersect((uint64_t)&v35, v30[1], v30[2]);
  if ((CA::OGL::rect_transform_filter_bits((float64x2_t *)v31, v32, v35, v36, 1.0, 1.0) & 9) != 0)
  {
    BOOL v11 = 0;
    float v26 = 0.0;
    if ((*(_WORD *)(v29 + 40) & 0x3C0) != 0 || *((void *)this + 11) != 0x3C003C003C003C00) {
      goto LABEL_50;
    }
    goto LABEL_56;
  }
  if (*((void *)this + 11) != 0x3C003C003C003C00)
  {
LABEL_45:
    BOOL v11 = 0;
    float v26 = 0.0;
    goto LABEL_50;
  }
LABEL_56:
  float v26 = *(float *)(v33 + 28);
  BOOL v11 = *(_DWORD **)(v33 + 40);
  if (v11) {
    ++*v11;
  }
LABEL_50:
  os_unfair_lock_unlock(v19);
  os_unfair_lock_unlock(v17);
  if (v11)
  {
    if (v26 != 1.0 && (*((unsigned char *)this + 223) & 1) == 0)
    {
      CA::OGL::Context::release_surface(**((void **)this + 1), (uint64_t)v11);
      goto LABEL_4;
    }
    *a2 = v26;
    return v11;
  }
LABEL_4:

  return CA::OGL::ImagingNode::retain_surface(this, a2, a3);
}

void add_non_visible_animating_layer(void *value)
{
  CFDictionaryRef Mutable = (__CFSet *)non_visible_animating_layers;
  if (!non_visible_animating_layers)
  {
    CFDictionaryRef Mutable = CFSetCreateMutable(0, 0, 0);
    non_visible_animating_layers = (uint64_t)Mutable;
  }

  CFSetAddValue(Mutable, value);
}

uint64_t CA::OGL::render_subclass(CA::OGL::Renderer &,CA::OGL::Layer const*)::visitor::visit_subclass(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  if (BYTE5(qword_1EB2ACC90))
  {
    uint64_t v7 = *(void *)(*(void *)v2 + 192);
    if (v7)
    {
      uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
      if (v9) {
        (*(void (**)(uint64_t, void))(*(void *)v9 + 2120))(v9, *(unsigned int *)(a2 + 16));
      }
    }
  }
  uint64_t result = CA::OGL::should_render_secure_indicators_with_gpu(*(void *)v2, *(void *)(v2 + 8), *(void *)(v3 + 16));
  *(unsigned char *)(v2 + 10CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = result ^ 1;
  if (byte_1EB2ACC88)
  {
    uint64_t v10 = *(void *)v2;
    uint64_t v11 = *(void *)(*(void *)(*(void *)v2 + 248) + 24);
    v12[0] = *(void *)(v3 + 24) + 64;
    v12[1] = v11;
    long long v14 = 0u;
    long long v13 = 0u;
    return CA::OGL::fill_color_rect(v10, (uint64_t)v12, (double *)0x80408080, v5, 0.0, v6);
  }
  return result;
}

BOOL CA::OGL::prepare_layer_image(CA::OGL::Renderer &,CA::OGL::Layer *,CA::OGL::Gstate const&)::visitor::visit_subclass(uint64_t a1)
{
  BOOL result = CA::OGL::should_render_secure_indicators_with_gpu(**(void **)(a1 + 8), *(void *)(*(void *)(a1 + 8) + 8), *(void *)(*(void *)(a1 + 16) + 16));
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(v3 + 32);
  *(void *)(v3 + 32) = v4 | 0x4000;
  if (!result && !BYTE5(qword_1EB2ACC90)) {
    *(void *)(v3 + 32) = v4 | 0x4008;
  }
  return result;
}

BOOL CA::OGL::should_render_secure_indicators_with_gpu(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && (*(unsigned char *)(a3 + 28) & 1) != 0) {
    return 1;
  }
  if ((*(_DWORD *)(a2 + 1084) & 0x10001000) != 0x1000) {
    return 1;
  }
  uint64_t v3 = *(void *)(a1 + 192);
  return v3
      && (uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3)) != 0
      && (*(_DWORD *)(v4 + 624) & 4) != 0
      || byte_1EB2ACC88 != 0;
}

CATransform3D *__cdecl CATransform3DRotate_(CATransform3D *__return_ptr retstr, CATransform3D *t, CGFloat angle, CGFloat x, CGFloat y, CGFloat z)
{
  v10[16] = *(double *)MEMORY[0x1E4F143B8];
  CA::Mat4Impl::mat4_set_rotation((CA::Mat4Impl *)v10, v6, angle, x, y, z);
  CA::Mat4Impl::mat4_concat((float64x2_t *)t, v10, &t->m11, v8);
  return result;
}

CATransform3D *__cdecl CATransform3DRotate(CATransform3D *__return_ptr retstr, CATransform3D *t, CGFloat angle, CGFloat x, CGFloat y, CGFloat z)
{
  v15[16] = *(double *)MEMORY[0x1E4F143B8];
  CA::Mat4Impl::mat4_set_rotation((CA::Mat4Impl *)v15, v6, angle, x, y, z);
  CA::Mat4Impl::mat4_concat((float64x2_t *)t, v15, &t->m11, v9);
  long long v11 = *(_OWORD *)&t->m33;
  *(_OWORD *)&retstr->m31 = *(_OWORD *)&t->m31;
  *(_OWORD *)&retstr->m33 = v11;
  long long v12 = *(_OWORD *)&t->m43;
  *(_OWORD *)&retstr->m41 = *(_OWORD *)&t->m41;
  *(_OWORD *)&retstr->m43 = v12;
  long long v13 = *(_OWORD *)&t->m13;
  *(_OWORD *)&retstr->m11 = *(_OWORD *)&t->m11;
  *(_OWORD *)&retstr->m13 = v13;
  long long v14 = *(_OWORD *)&t->m23;
  *(_OWORD *)&retstr->m21 = *(_OWORD *)&t->m21;
  *(_OWORD *)&retstr->m23 = v14;
  return result;
}

void CA::Mat4Impl::mat4_set_rotation(CA::Mat4Impl *this, double *a2, double a3, double a4, double a5, double a6)
{
  *(_OWORD *)this = xmmword_184997D50;
  *((_OWORD *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0u;
  *((_OWORD *)this + 2) = xmmword_184997D60;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = xmmword_184997D50;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = xmmword_184997D60;
  __double2 v12 = __sincos_stret(a3);
  *(double *)v11.i64 = v12.__cosval;
  *(double *)v10.i64 = v12.__sinval;
  if (fabs(v12.__sinval) >= 0.0000001)
  {
    if (fabs(v12.__cosval) < 0.0000001)
    {
      v11.i64[0] = 1.0;
      v14.f64[0] = NAN;
      v14.f64[1] = NAN;
      v10.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v14), v11, v10).u64[0];
      v11.i64[0] = 0;
    }
  }
  else
  {
    v10.i64[0] = 1.0;
    v13.f64[0] = NAN;
    v13.f64[1] = NAN;
    v11.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v13), v10, v11).u64[0];
    v10.i64[0] = 0;
  }
  if (a4 == 0.0 && a5 == 0.0 && a6 == 1.0)
  {
    *(void *)this = v11.i64[0];
    *((void *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v10.i64[0];
    *((double *)this + 4) = -*(double *)v10.i64;
    *((void *)this + 5) = v11.i64[0];
  }
  else if (a4 == 0.0 && a5 == 1.0 && a6 == 0.0)
  {
    *(void *)this = v11.i64[0];
    *((double *)this + 2) = -*(double *)v10.i64;
    *((void *)this + 8) = v10.i64[0];
    *((void *)this + 1CA::Context::unref(this[1], 0) = v11.i64[0];
  }
  else if (a4 == 1.0 && a5 == 0.0 && a6 == 0.0)
  {
    *((void *)this + 5) = v11.i64[0];
    *((void *)this + 6) = v10.i64[0];
    *((double *)this + 9) = -*(double *)v10.i64;
    *((void *)this + 1CA::Context::unref(this[1], 0) = v11.i64[0];
  }
  else
  {
    double v15 = a4 * a4;
    double v16 = a5 * a5;
    double v17 = a6 * a6;
    double v18 = sqrt(a5 * a5 + a4 * a4 + a6 * a6);
    if (fabs(v18) >= 0.000001)
    {
      if (v18 != 1.0)
      {
        a4 = 1.0 / v18 * a4;
        a5 = 1.0 / v18 * a5;
        a6 = 1.0 / v18 * a6;
        double v15 = a4 * a4;
        double v16 = a5 * a5;
        double v17 = a6 * a6;
      }
      double v19 = a5 * (1.0 - *(double *)v11.i64);
      double v20 = v19 * a4;
      double v21 = v19 * a6;
      double v22 = a6 * a4 * (1.0 - *(double *)v11.i64);
      double v23 = a4 * *(double *)v10.i64;
      double v24 = a5 * *(double *)v10.i64;
      double v25 = a6 * *(double *)v10.i64;
      *(double *)this = v15 + (1.0 - v15) * *(double *)v11.i64;
      *((double *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v20 + v25;
      *((double *)this + 2) = v22 - v24;
      *((double *)this + 4) = v20 - v25;
      *((double *)this + 5) = v16 + (1.0 - v16) * *(double *)v11.i64;
      *((double *)this + 6) = v21 + v23;
      *((double *)this + 8) = v22 + v24;
      *((double *)this + 9) = v21 - v23;
      *((double *)this + 1CA::Context::unref(this[1], 0) = v17 + (1.0 - v17) * *(double *)v11.i64;
    }
  }
}

uint64_t CA::WindowServer::Server::set_sdr_nits(CA::WindowServer::Server *this, float a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = (void *)*((void *)this + 12);
  if (v5[5]
    && (v6 = (*(uint64_t (**)(void *))(*v5 + 304))(v5), uint64_t v5 = (void *)*((void *)this + 12), v6))
  {
    (*(void (**)(void *, float))(*v5 + 928))(v5, a2);
    CA::WindowServer::Server::invalidate((os_unfair_lock_s *)this, *(const CA::Shape **)(*((void *)this + 12) + 216));
    if (byte_1EB2ACC84)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int8x16_t v10 = x_log_category_CADebug;
        if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "set_sdr_nits_1";
          _os_log_impl(&dword_184668000, v10, OS_LOG_TYPE_INFO, "kUpdateReasonDisplayBrightness %s", buf, 0xCu);
        }
      }
    }
    *(void *)long long buf = 0;
    *(int64x2_t *)&uint8_t buf[8] = vdupq_n_s64(8uLL);
    (*(void (**)(CA::WindowServer::Server *, unsigned char *, double))(*(void *)this + 184))(this, buf, 0.0);
  }
  else if ((*(uint64_t (**)(void *, float))(*v5 + 928))(v5, a2))
  {
    if (byte_1EB2ACC84)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v9 = x_log_category_CADebug;
        if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "set_sdr_nits_2";
          _os_log_impl(&dword_184668000, v9, OS_LOG_TYPE_INFO, "kUpdateReasonDisplayBrightness %s", buf, 0xCu);
        }
      }
    }
    *(void *)long long buf = 0;
    *(int64x2_t *)&uint8_t buf[8] = vdupq_n_s64(8uLL);
    (*(void (**)(CA::WindowServer::Server *, unsigned char *, double))(*(void *)this + 184))(this, buf, 0.0);
    uint64_t v7 = (CA::OGL::Performance *)(*(uint64_t (**)(void))(**((void **)this + 12) + 968))(*((void *)this + 12));
    if (CA::OGL::Performance::invalidates_screen_on_edr_change(v7)) {
      CA::WindowServer::Server::invalidate((os_unfair_lock_s *)this, *(const CA::Shape **)(*((void *)this + 12) + 216));
    }
  }
  if (!(*(uint64_t (**)(CA::WindowServer::Server *))(*(void *)this + 304))(this)) {
    *(_DWORD *)(*((void *)this + 12) + 745) |= 0x200u;
  }
  return pthread_mutex_unlock(v4);
}

uint64_t CA::WindowServer::IOMFBDisplay::swap_brightness(CA::WindowServer::IOMFBDisplay *this)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 27248);
  os_unfair_lock_lock((os_unfair_lock_t)this + 6812);
  uint64_t v3 = *((void *)this + 3407);
  os_unfair_lock_unlock(v2);
  if (!v3) {
    return (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, void))(*(void *)this + 968))(this, 0);
  }
  uint64_t v4 = (char *)this + 25336;
  if (!*((unsigned char *)this + 28209) || BYTE14(xmmword_1EB2ACC30) != 0) {
    return (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, void))(*(void *)this + 968))(this, 0);
  }
  double v6 = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 920))(this);
  if (!CA::WindowServer::Display::Mode::is_hdr((CA::WindowServer::IOMFBDisplay *)((char *)this + 640))) {
    double v6 = CA::WindowServer::Display::edr_headroom(this) * v6;
  }
  if (*((unsigned char *)this + 28212))
  {
    *((unsigned char *)this + 28212) = 0;
    *((int64x2_t *)this + 1702) = vdupq_n_s64(0x7FF8000000000000uLL);
    *((_DWORD *)this + 655CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 2143289344;
    *((_DWORD *)this + 6555) = 2143289344;
    *((_DWORD *)this + 6557) = 2143289344;
    *((_DWORD *)this + 6553) = 2143289344;
    *((_DWORD *)this + 6559) = 2143289344;
    *((_DWORD *)this + 656CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 2143289344;
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      double v56 = x_log_category_brightness;
      if (os_log_type_enabled((os_log_t)x_log_category_brightness, OS_LOG_TYPE_DEFAULT))
      {
        int v57 = *((_DWORD *)this + 6);
        *(_DWORD *)long long buf = 67109120;
        int v61 = v57;
        _os_log_impl(&dword_184668000, v56, OS_LOG_TYPE_DEFAULT, "Display %u forcing swap brightness values\n", buf, 8u);
      }
    }
  }
  double v7 = *((double *)this + 3404);
  BOOL v8 = v6 != v7;
  if (v6 == v7)
  {
    float v11 = NAN;
  }
  else
  {
    int v9 = IOMobileFramebufferSwapSetBrightness();
    if (v9)
    {
      int v10 = v9;
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v12 = x_log_category_brightness;
        if (os_log_type_enabled((os_log_t)x_log_category_brightness, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = *((_DWORD *)this + 6);
          *(_DWORD *)long long buf = 67109376;
          int v61 = v13;
          __int16 v62 = 1024;
          LODWORD(v63) = v10;
          _os_log_impl(&dword_184668000, v12, OS_LOG_TYPE_DEFAULT, "Display %u swap brightness failed: 0x%x", buf, 0xEu);
        }
      }
    }
    float v11 = v6;
    *((double *)this + 3404) = v6;
  }
  float v14 = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 936))(this);
  if (*((double *)this + 3405) == v14)
  {
    float v14 = NAN;
  }
  else
  {
    int v15 = IOMobileFramebufferSwapSetBrightnessLimit();
    if (v15)
    {
      int v16 = v15;
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        double v17 = x_log_category_brightness;
        if (os_log_type_enabled((os_log_t)x_log_category_brightness, OS_LOG_TYPE_DEFAULT))
        {
          int v18 = *((_DWORD *)this + 6);
          *(_DWORD *)long long buf = 67109376;
          int v61 = v18;
          __int16 v62 = 1024;
          LODWORD(v63) = v16;
          _os_log_impl(&dword_184668000, v17, OS_LOG_TYPE_DEFAULT, "Display %u swap brightness limit failed: 0x%x\n", buf, 0xEu);
        }
      }
    }
    *((double *)this + 3405) = v14;
    BOOL v8 = 1;
  }
  if (CADeviceSupportsRTPLC::once[0] != -1) {
    dispatch_once(CADeviceSupportsRTPLC::once, &__block_literal_global_301);
  }
  if (!CADeviceSupportsRTPLC::rtplc
    || (float v19 = *((float *)this + 6567) * 3.14159265, (LODWORD(v19) & 0x7FFFFFFFu) > 0x7F7FFFFF)
    || *((float *)this + 6551) == v19)
  {
    float v19 = NAN;
  }
  else
  {
    IOMobileFramebufferSwapSetAmbientLux();
    *((float *)this + 655CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v19;
  }
  if (CADeviceSupportsTwilight::once != -1) {
    dispatch_once(&CADeviceSupportsTwilight::once, &__block_literal_global_304_12248);
  }
  float v20 = NAN;
  if (CADeviceSupportsTwilight::twilight && !byte_1EB2ACC63)
  {
    float v20 = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1272))(this);
    if ((LODWORD(v20) & 0x7FFFFFFFu) > 0x7F7FFFFF || v20 == *((float *)this + 6555))
    {
      float v20 = NAN;
    }
    else
    {
      int v21 = IOMobileFramebufferSetTwilightStrength();
      if (v21)
      {
        int v22 = v21;
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          double v23 = x_log_category_brightness;
          if (os_log_type_enabled((os_log_t)x_log_category_brightness, OS_LOG_TYPE_DEFAULT))
          {
            int v24 = *((_DWORD *)this + 6);
            *(_DWORD *)long long buf = 67109632;
            int v61 = v24;
            __int16 v62 = 2048;
            double v63 = v20;
            __int16 v64 = 1024;
            LODWORD(v65) = v22;
            _os_log_impl(&dword_184668000, v23, OS_LOG_TYPE_DEFAULT, "Display %u swap_set_twilight_strength %g failed: 0x%x\n", buf, 0x18u);
          }
        }
      }
      *((float *)this + 6555) = v20;
    }
  }
  float v58 = v14;
  float v59 = v11;
  if (!byte_1EB2ACC65)
  {
    float v25 = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1288))(this);
    if ((LODWORD(v25) & 0x7FFFFFFFu) <= 0x7F7FFFFF && v25 != *((float *)this + 6557))
    {
      uint64_t v26 = *((void *)this + 3196);
      if (init_iomfb(void)::once != -1) {
        dispatch_once(&init_iomfb(void)::once, &__block_literal_global_13500);
      }
      if (iomfb_swap_set_aml_strength_f)
      {
        int v27 = iomfb_swap_set_aml_strength_f(v26, v25);
        if (!v27)
        {
LABEL_60:
          *((float *)this + 6557) = v25;
          goto LABEL_61;
        }
      }
      else
      {
        int v27 = -536870212;
      }
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v28 = x_log_category_brightness;
        if (os_log_type_enabled((os_log_t)x_log_category_brightness, OS_LOG_TYPE_DEFAULT))
        {
          int v29 = *((_DWORD *)this + 6);
          *(_DWORD *)long long buf = 67109632;
          int v61 = v29;
          __int16 v62 = 2048;
          double v63 = v25;
          __int16 v64 = 1024;
          LODWORD(v65) = v27;
          _os_log_impl(&dword_184668000, v28, OS_LOG_TYPE_DEFAULT, "Display %u swap_set_aml_strength %g failed: 0x%x\n", buf, 0x18u);
        }
      }
      goto LABEL_60;
    }
  }
  float v25 = NAN;
LABEL_61:
  float v31 = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1304))(this);
  if ((LODWORD(v31) & 0x7FFFFFFFu) >= 0x7F800000 && *((unsigned char *)this + 25640) == 3)
  {
    float v31 = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 920))(this);
    int v32 = 1;
  }
  else
  {
    int v32 = 0;
  }
  if ((LODWORD(v31) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
  {
    if (v31 != *((float *)this + 6559))
    {
      if (v32)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          unint64_t v39 = x_log_category_brightness;
          if (os_log_type_enabled((os_log_t)x_log_category_brightness, OS_LOG_TYPE_DEFAULT))
          {
            int v40 = *((_DWORD *)this + 6);
            *(_DWORD *)long long buf = 67109376;
            int v61 = v40;
            __int16 v62 = 2048;
            double v63 = v31;
            _os_log_impl(&dword_184668000, v39, OS_LOG_TYPE_DEFAULT, "Display %u forcing indicator brightness to current sdr value %f", buf, 0x12u);
          }
        }
      }
      v30.n128_f32[0] = v31;
      int v41 = iomfb_swap_set_indicator_brightness(*((void *)this + 3196), 1, v30);
      if (v41)
      {
        int v42 = v41;
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          int32x2_t v43 = x_log_category_brightness;
          if (os_log_type_enabled((os_log_t)x_log_category_brightness, OS_LOG_TYPE_DEFAULT))
          {
            int v44 = *((_DWORD *)this + 6);
            *(_DWORD *)long long buf = 67109632;
            int v61 = v44;
            __int16 v62 = 2048;
            double v63 = v31;
            __int16 v64 = 1024;
            LODWORD(v65) = v42;
            _os_log_impl(&dword_184668000, v43, OS_LOG_TYPE_DEFAULT, "Display %u swap_set_indicator_brightness %g failed: 0x%x\n", buf, 0x18u);
          }
        }
      }
      *((float *)this + 6559) = v31;
      goto LABEL_89;
    }
LABEL_74:
    float v31 = NAN;
    goto LABEL_89;
  }
  uint64_t v33 = (void *)*((void *)this + 3204);
  if (!v33) {
    goto LABEL_74;
  }
  if (!*v33)
  {
    sil_mgr_instance(0, 0xFFFFFFFFLL);
    void *v33 = v34;
    if (!v34) {
      goto LABEL_74;
    }
  }
  unsigned int v35 = *((unsigned __int8 *)this + 25640);
  if ((v35 & 0xFFFFFFFB) != 0) {
    goto LABEL_74;
  }
  uint64_t v36 = *((void *)this + 3204);
  if (v35 <= 1)
  {
    if (!CA::WindowServer::SILMgr::set_power(*((CA::WindowServer::SILMgr **)this + 3204), 1, 0)) {
      goto LABEL_74;
    }
    uint64_t v36 = *((void *)this + 3204);
  }
  CA::WindowServer::SILMgr::turn_off_all_regions((CA::WindowServer::SILMgr *)buf, v36, 0);
  *((unsigned char *)this + 2564CA::Context::unref(this[1], 0) = 2;
  v37.n128_u64[0] = 0;
  int v38 = iomfb_swap_set_indicator_brightness(*((void *)this + 3196), 0, v37);
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    int32x2_t v45 = x_log_category_brightness;
    if (os_log_type_enabled((os_log_t)x_log_category_brightness, OS_LOG_TYPE_DEFAULT))
    {
      int v46 = *((_DWORD *)this + 6);
      *(_DWORD *)long long buf = 67109376;
      int v61 = v46;
      __int16 v62 = 1024;
      LODWORD(v63) = v38;
      _os_log_impl(&dword_184668000, v45, OS_LOG_TYPE_DEFAULT, "Display %u disabling indicator brightness return: 0x%x", buf, 0xEu);
    }
  }
  *((_DWORD *)this + 6559) = 2143289344;
  float v31 = 0.0;
LABEL_89:
  if ((*((_DWORD *)this + 6560) & 0x7FFFFFFFu) > 0x7F7FFFFF || *((float *)this + 6560) == *((float *)this + 6561)) {
    goto LABEL_100;
  }
  if (!MEMORY[0x1E4F6EC38])
  {
    int v47 = -536870212;
LABEL_95:
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v48 = x_log_category_brightness;
      if (os_log_type_enabled((os_log_t)x_log_category_brightness, OS_LOG_TYPE_DEFAULT))
      {
        int v49 = *((_DWORD *)this + 6);
        double v50 = *((float *)this + 6560);
        *(_DWORD *)long long buf = 67109632;
        int v61 = v49;
        __int16 v62 = 2048;
        double v63 = v50;
        __int16 v64 = 1024;
        LODWORD(v65) = v47;
        _os_log_impl(&dword_184668000, v48, OS_LOG_TYPE_DEFAULT, "Display %u swap_set_indicator_brightness_limit %g failed: 0x%x\n", buf, 0x18u);
      }
    }
    goto LABEL_99;
  }
  int v47 = IOMobileFramebufferSwapSetIndicatorBrightnessLimit();
  if (v47) {
    goto LABEL_95;
  }
LABEL_99:
  *((_DWORD *)this + 656CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *((_DWORD *)this + 6560);
LABEL_100:
  float v51 = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1328))(this);
  if ((LODWORD(v51) & 0x7FFFFFFFu) > 0x7F7FFFFF || v51 == *((float *)this + 6553))
  {
    double v52 = NAN;
  }
  else
  {
    double v52 = v51;
    IOMobileFrameBufferSwapSetContrastEnhancerStrength();
    *((float *)this + 6553) = v51;
  }
  if (*v4)
  {
    *v4 &= ~1u;
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      float64x2_t v53 = x_log_category_brightness;
      if (os_log_type_enabled((os_log_t)x_log_category_brightness, OS_LOG_TYPE_DEFAULT))
      {
        int v54 = *((_DWORD *)this + 6);
        *(_DWORD *)long long buf = 67110912;
        int v61 = v54;
        __int16 v62 = 2048;
        double v63 = v59;
        __int16 v64 = 2048;
        double v65 = v58;
        __int16 v66 = 2048;
        double v67 = v31;
        __int16 v68 = 2048;
        double v69 = v19;
        __int16 v70 = 2048;
        double v71 = v20;
        __int16 v72 = 2048;
        double v73 = v25;
        __int16 v74 = 2048;
        double v75 = v52;
        _os_log_impl(&dword_184668000, v53, OS_LOG_TYPE_DEFAULT, "Display %u swap brightness: %g, limit: %g, indicator brightness: %g, ambient lux: %g, low ambient strength: %g, high ambient strength: %g, contrast enhancer: %g\n", buf, 0x4Eu);
      }
    }
  }
  if (v8) {
    kdebug_trace();
  }
  return (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, void))(*(void *)this + 968))(this, 0);
}

uint64_t CA::WindowServer::IOMFBDisplay::set_needs_brightness_update(uint64_t this, char a2)
{
  *(unsigned char *)(this + 2821CA::Context::unref(this[1], 0) = a2;
  return this;
}

float CA::WindowServer::IOMFBDisplay::brightness_limit(CA::WindowServer::IOMFBDisplay *this)
{
  return *((float *)this + 6549);
}

float CA::WindowServer::IOMFBDisplay::contrast_enhancer_strength(CA::WindowServer::IOMFBDisplay *this)
{
  return *((float *)this + 6552);
}

float CA::WindowServer::IOMFBDisplay::indicator_brightness(CA::WindowServer::IOMFBDisplay *this)
{
  return *((float *)this + 6558);
}

float CA::WindowServer::IOMFBDisplay::high_ambient_adaptation_strength(CA::WindowServer::IOMFBDisplay *this)
{
  return *((float *)this + 6556);
}

_DWORD *CA::WindowServer::Display::initialize_edr_state(_DWORD *this)
{
  if (!*((void *)this + 85))
  {
    uint64_t v1 = this;
    this = CA::Render::Shmem::new_shmem((CA::Render::Shmem *)0xC);
    *((void *)v1 + 85) = this;
    uint64_t v2 = (unsigned int *)*((void *)this + 3);
    v2[2] = 0;
    *(void *)uint64_t v2 = 0;
    *((void *)v1 + 86) = v2;
    atomic_store(0x3F800000u, v2);
    atomic_store(0x3F800000u, (unsigned int *)(*((void *)v1 + 86) + 4));
    atomic_store(0x3F800000u, (unsigned int *)(*((void *)v1 + 86) + 8));
  }
  return this;
}

void CA::WindowServer::IOMFBServer::set_edr_properties(CA::WindowServer::Display **this, int a2, float a3, float a4, float a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v10 = (pthread_mutex_t *)(this + 68);
  pthread_mutex_lock((pthread_mutex_t *)(this + 68));
  float v11 = CA::WindowServer::Display::edr_headroom(this[12]);
  memset(buf, 0, sizeof(buf));
  (*(void (**)(uint8_t *__return_ptr))(*(void *)this[12] + 1216))(buf);
  if (v11 != a3 && fabs(a3 + -1.0) < 0.001) {
    goto LABEL_20;
  }
  if ((*(uint64_t (**)(CA::WindowServer::Display *))(*(void *)this[12] + 1240))(this[12]))
  {
    BOOL v12 = vabds_f32(v11, a3) < 0.000001;
    if (!a2) {
      goto LABEL_19;
    }
  }
  else
  {
    float v13 = powf(v11, 0.45455);
    BOOL v12 = vabds_f32(v13, powf(a3, 0.45455)) <= 0.0019531;
    if (!a2) {
      goto LABEL_19;
    }
  }
  if (v12)
  {
    if ((a4 != 0.0 || *(float *)&buf[8] != 0.0)
      && (a4 != 0.0 && *(float *)&buf[8] == 0.0 || (float)(vabds_f32(*(float *)&buf[8], a4) / *(float *)&buf[8]) > 0.01)
      || (a5 != 0.0 || *(float *)&buf[12] != 0.0)
      && (a5 != 0.0 && *(float *)&buf[12] == 0.0
       || (float)(vabds_f32(*(float *)&buf[12], a5) / *(float *)&buf[12]) > 0.01))
    {
      goto LABEL_20;
    }
LABEL_18:
    int v14 = 0;
    goto LABEL_23;
  }
LABEL_19:
  if (v12) {
    goto LABEL_18;
  }
LABEL_20:
  int v15 = this[12];
  CA::WindowServer::Display::initialize_edr_state(v15);
  int v16 = (unsigned int *)*((void *)v15 + 86);
  if (v16) {
    atomic_store(LODWORD(a3), v16);
  }
  *(float *)&uint8_t buf[8] = a4;
  *(float *)&buf[12] = a5;
  (*(void (**)(void))(*(void *)this[12] + 1224))();
  int v14 = 1;
LABEL_23:
  if (BYTE9(xmmword_1EB2ACC10)) {
    kdebug_trace();
  }
  double v17 = (CA::OGL::Performance *)pthread_mutex_unlock(v10);
  if (v14)
  {
    if (CA::OGL::Performance::invalidates_screen_on_edr_change(v17)) {
      CA::WindowServer::Server::invalidate((os_unfair_lock_s *)this, *((const CA::Shape **)this[12] + 27));
    }
    *(_DWORD *)((char *)this[12] + 745) |= 0x400u;
    if (byte_1EB2ACC84)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int v21 = x_log_category_CADebug;
        if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "set_edr_properties";
          _os_log_impl(&dword_184668000, v21, OS_LOG_TYPE_INFO, "kUpdateReasonDisplayBrightness %s", buf, 0xCu);
        }
      }
    }
    *(void *)long long buf = 0;
    *(int64x2_t *)&uint8_t buf[8] = vdupq_n_s64(8uLL);
    (*((void (**)(CA::WindowServer::Display **, uint8_t *, double))*this + 23))(this, buf, 0.0);
    (*(void (**)(CA::WindowServer::Display *))(*(void *)this[12] + 968))(this[12]);
    if (CA::OGL::AsynchronousDispatcher::dispatcher(void)::once != -1) {
      dispatch_once(&CA::OGL::AsynchronousDispatcher::dispatcher(void)::once, &__block_literal_global_1810);
    }
    uint64_t v18 = CA::OGL::AsynchronousDispatcher::dispatcher(void)::dispatcher;
    float v19 = (os_unfair_lock_s *)(CA::OGL::AsynchronousDispatcher::dispatcher(void)::dispatcher + 4);
    os_unfair_lock_lock((os_unfair_lock_t)(CA::OGL::AsynchronousDispatcher::dispatcher(void)::dispatcher + 4));
    for (uint64_t i = *(void **)(v18 + 8); i; uint64_t i = (void *)i[24])
      (*(void (**)(void *))(*i + 32))(i);
    os_unfair_lock_unlock(v19);
  }
}

uint64_t CA::WindowServer::IOMFBDisplay::brightness_control_disabled(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28211);
}

__n128 CA::WindowServer::IOMFBDisplay::set_luminance(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1642].n128_u64[0] = a2[1].n128_u64[0];
  a1[1641] = result;
  return result;
}

void sub_184793D30(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL CA::OGL::Performance::invalidates_screen_on_edr_change(CA::OGL::Performance *this)
{
  if (!BYTE5(xmmword_1EB2ACBF0)) {
    return 0;
  }
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  unsigned int v2 = *(float *)&dword_1EB2ACA9C;
  if (*(float *)&dword_1EB2ACA9C >= 0xB) {
    unsigned int v2 = 11;
  }
  return v2 == 7;
}

uint64_t CA::WindowServer::IOMFBDisplay::set_high_ambient_adaptation_strength(CA::WindowServer::IOMFBDisplay *this, float a2)
{
  unsigned int v2 = (float *)((char *)this + 26224);
  if (!*((unsigned char *)this + 28209) || *v2 == a2) {
    return 0;
  }
  *unsigned int v2 = a2;
  return 1;
}

uint64_t CA::WindowServer::IOMFBDisplay::has_deferred_brightness_tx_callbacks(CA::WindowServer::IOMFBDisplay *this)
{
  return 1;
}

uint64_t CA::WindowServer::IOMFBDisplay::set_low_ambient_adaptation_strength(CA::WindowServer::IOMFBDisplay *this, float a2)
{
  unsigned int v2 = (float *)((char *)this + 26216);
  if (!*((unsigned char *)this + 28209) || *v2 == a2) {
    return 0;
  }
  *unsigned int v2 = a2;
  return 1;
}

uint64_t CA::WindowServer::IOMFBDisplay::set_indicator_brightness_limit(CA::WindowServer::IOMFBDisplay *this, float a2)
{
  unsigned int v2 = (float *)((char *)this + 26240);
  if (!*((unsigned char *)this + 28209) || *v2 == a2) {
    return 0;
  }
  *unsigned int v2 = a2;
  return 1;
}

uint64_t CA::WindowServer::IOMFBDisplay::set_contrast_enhancer_strength(CA::WindowServer::IOMFBDisplay *this, float a2)
{
  unsigned int v2 = (float *)((char *)this + 26208);
  if (!*((unsigned char *)this + 28209) || *v2 == a2) {
    return 0;
  }
  *unsigned int v2 = a2;
  return 1;
}

void CA::WindowServer::IOMFBDisplay::append_brightness_tx_callback(uint64_t a1, void *aBlock)
{
  uint64_t v3 = _Block_copy(aBlock);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 25940));
  uint64_t v4 = *(void **)(a1 + 25976);
  uint64_t v5 = *(void *)(a1 + 25968);
  uint64_t v6 = ((uint64_t)v4 - v5) >> 3;
  unint64_t v7 = *(void *)(a1 + 25992);
  if (v7 < v6 + 1)
  {
    uint64_t v8 = *(void *)(a1 + 25984);
    unint64_t v9 = (v7 + 1) | ((v7 + 1) >> 1) | (((v7 + 1) | ((v7 + 1) >> 1)) >> 2);
    unint64_t v10 = v9 | (v9 >> 4) | ((v9 | (v9 >> 4)) >> 8);
    unint64_t v11 = v10 | (v10 >> 16) | ((v10 | (v10 >> 16)) >> 32);
    if (v11 + 1 > v6 + 1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v6 + 1;
    }
    float v13 = malloc_type_malloc(8 * v12, 0x80040B8603338uLL);
    int v14 = v13;
    int v15 = *(uint64_t **)(a1 + 25968);
    int v16 = *(uint64_t **)(a1 + 25976);
    if (v15 != v16)
    {
      double v17 = v13;
      do
      {
        uint64_t v18 = *v15++;
        *v17++ = v18;
      }
      while (v15 != v16);
    }
    if (v5 != v8) {
      free(*(void **)(a1 + 25968));
    }
    *(void *)(a1 + 25968) = v14;
    uint64_t v4 = &v14[v6];
    *(void *)(a1 + 25976) = v4;
    *(void *)(a1 + 25992) = v12;
  }
  *uint64_t v4 = v3;
  *(void *)(a1 + 25976) += 8;

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 25940));
}

uint64_t CA::WindowServer::IOMFBDisplay::set_indicator_brightness(CA::WindowServer::IOMFBDisplay *this, float a2)
{
  unsigned int v2 = (float *)((char *)this + 26232);
  if (!*((unsigned char *)this + 28209) || *v2 == a2) {
    return 0;
  }
  *unsigned int v2 = a2;
  return 1;
}

BOOL CA::WindowServer::IOMFBDisplay::set_brightness_limit(CA::WindowServer::IOMFBDisplay *this, float a2)
{
  int v2 = *((unsigned __int8 *)this + 28209);
  if (*((unsigned char *)this + 28209))
  {
    *((float *)this + 6549) = a2;
    int v4 = a2 < 1000.0 && *((unsigned char *)this + 26368) != 0 && *((float *)this + 6547) == 100.0;
    if (*((unsigned __int8 *)this + 26369) != v4)
    {
      *((unsigned char *)this + 26369) = v4;
      CA::WindowServer::Display::post_display_changed((uint64_t)this);
    }
  }
  return v2 != 0;
}

uint64_t CA::WindowServer::IOMFBDisplay::set_sdr_nits(CA::WindowServer::IOMFBDisplay *this, float a2)
{
  int v4 = (float *)((char *)this + 26188);
  if (*((unsigned char *)this + 28209)) {
    BOOL is_hdr = 1;
  }
  else {
    BOOL is_hdr = CA::WindowServer::Display::Mode::is_hdr((CA::WindowServer::IOMFBDisplay *)((char *)this + 640));
  }
  if (*((unsigned char *)v4 + 2010))
  {
    CA::WindowServer::IOMFBDisplay::save_brightness_preferences(this, 1);
    *((unsigned char *)v4 + 201CA::Context::unref(this[1], 0) = 0;
  }
  *((void *)this + 3316) = 0;
  float v6 = (*(float (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 920))(this);
  float v7 = CA::WindowServer::Display::edr_headroom(this) * v6;
  float v8 = CA::WindowServer::Display::edr_headroom(this) * a2;
  if (v7 >= v4[93] != v8 < v4[93] && v7 < v4[94] == v8 < v4[94])
  {
    int v9 = 0;
  }
  else
  {
    int v9 = 1;
    *((unsigned char *)v4 + 1989) = 1;
  }
  if (v7 != v8)
  {
    float v10 = v4[112];
    if (v7 < v10 || v8 < v10)
    {
      BOOL is_hdr = 1;
      *((unsigned char *)v4 + 2006) = 1;
    }
  }
  *int v4 = a2;
  (*(void (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1104))(this);
  return v9 | is_hdr;
}

uint64_t CA::WindowServer::IOMFBServer::brightness_capabilities(CA::WindowServer::IOMFBServer *this)
{
  uint64_t v1 = *((void *)this + 12);
  int v2 = (os_unfair_lock_s *)(v1 + 27248);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 27248));
  uint64_t v3 = *(void *)(v1 + 27256);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t CAImageQueueGetUnconsumedImageCount(uint64_t a1, double *a2, double *a3)
{
  uint64_t v3 = *(void *)(a1 + 48);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(unsigned int *)(a1 + 40);
  if (!v4) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v6 = *(void *)(v3 + 24);
  float v7 = (_DWORD *)(v6 + 548);
  double v8 = -1.0;
  double v9 = -1.0;
  do
  {
    if (!*(v7 - 4)) {
      goto LABEL_28;
    }
    int v10 = *(v7 - 6);
    if (v10 > 572662305)
    {
      if (v10 == 572662306 || v10 == 858993459) {
        goto LABEL_28;
      }
    }
    else
    {
      if (v10) {
        BOOL v11 = v10 == 286331153;
      }
      else {
        BOOL v11 = 1;
      }
      if (v11 && (*v7 || *(v7 - 5) - *(_DWORD *)(v6 + 16) < 0)) {
        goto LABEL_28;
      }
    }
    double v12 = *(double *)(v7 - 21);
    BOOL v13 = result == 0;
    if (v12 > v9 || result == 0) {
      double v9 = *(double *)(v7 - 21);
    }
    if (v12 < v8) {
      BOOL v13 = 1;
    }
    if (v13) {
      double v8 = *(double *)(v7 - 21);
    }
    ++result;
LABEL_28:
    v7 += 40;
    --v4;
  }
  while (v4);
  if (a2 && result) {
    *a2 = v8;
  }
  if (a3)
  {
    if (result) {
      *a3 = v9;
    }
  }
  return result;
}

void ___ZN2CA12MachPortUtil9ClientIPC6createEPKc_block_invoke(uint64_t a1)
{
  mach_msg_return_t v3;
  uint64_t (*v4)();
  mach_error_t v5;
  NSObject *v6;
  char *v7;
  uint8_t buf[4];
  char *v9;
  uint64_t v10;
  unsigned char v11[12];
  int v12;
  unsigned char msg[32];
  long long v14;
  long long v15;
  long long v16;
  long long v17;
  long long v18;
  long long v19;
  long long v20;
  long long v21;
  int v22;
  uint64_t v23;

  uint64_t v23 = *MEMORY[0x1E4F143B8];
  mach_port_name_t v1 = *(_DWORD *)(a1 + 32);
  int v2 = (void *)MEMORY[0x1E4F14068];
  while (1)
  {
    int v22 = 0;
    float v20 = 0u;
    int v21 = 0u;
    uint64_t v18 = 0u;
    float v19 = 0u;
    int v16 = 0u;
    double v17 = 0u;
    int v14 = 0u;
    int v15 = 0u;
    memset(msg, 0, sizeof(msg));
    uint64_t v3 = mach_msg((mach_msg_header_t *)msg, 258, 0, 0xA4u, v1, 0, 0);
    if (v3) {
      break;
    }
    double v12 = 0;
    *(_DWORD *)&v11[8] = 0;
    *(_DWORD *)long long buf = msg[0] & 0x1F;
    LODWORD(v9) = 36;
    *(void *)BOOL v11 = (*(_DWORD *)&msg[20] + 100);
    HIDWORD(v9) = *(_DWORD *)&msg[8];
    int v10 = 0;
    if ((*(_DWORD *)&msg[20] - 40414) >= 0xFFFFFFF2
      && (uint64_t v4 = CACCARenderClient_subsystem[5 * (*(_DWORD *)&msg[20] - 40400) + 5]) != 0)
    {
      ((void (*)(unsigned char *, uint8_t *))v4)(msg, buf);
    }
    else
    {
      *(void *)&v11[4] = *v2;
      double v12 = -303;
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
  }
  uint64_t v5 = v3;
  if (v3 != 268451843)
  {
    if (x_log_hook_p())
    {
      mach_error_string(v5);
      x_log_();
    }
    else
    {
      uint64_t v6 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        float v7 = mach_error_string(v5);
        *(_DWORD *)long long buf = 136315394;
        double v9 = v7;
        LOWORD(v1CA::Context::unref(this[1], 0) = 1024;
        *(_DWORD *)((char *)&v10 + 2) = v5;
        _os_log_impl(&dword_184668000, v6, OS_LOG_TYPE_ERROR, "CARenderServerProcessClientMessage mach_msg failed with %s [0x%x]", buf, 0x12u);
      }
    }
  }
}

void _XBackdropDidChangeLuma(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)a1 & 0x80000000) != 0 || *(_DWORD *)(a1 + 4) != 44)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = *(_DWORD *)(a1 + 40);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___Z23CABackdropDidChangeLumayf_block_invoke;
    block[3] = &__block_descriptor_44_e5_v8__0l;
    block[4] = v3;
    int v6 = v4;
    dispatch_async(MEMORY[0x1E4F14428], block);
    *(_DWORD *)(a2 + 32) = 0;
  }
}

void _XImageQueueCollectable(_DWORD *a1, uint64_t a2)
{
  if ((*a1 & 0x80000000) != 0 || a1[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  }
  else
  {
    CAImageQueueCollectable(a1[8]);
    *(_DWORD *)(a2 + 32) = 0;
  }
}

void invoke_collectable_callback(unsigned char *a1)
{
  pthread_mutex_lock(&collectable_mutex);
  while (a1[112])
    pthread_cond_wait(&collectable_cond, &collectable_mutex);
  if (*((void *)a1 + 12))
  {
    a1[112] = 1;
    pthread_mutex_unlock(&collectable_mutex);
    (*((void (**)(unsigned char *, void))a1 + 12))(a1, *((void *)a1 + 13));
    pthread_mutex_lock(&collectable_mutex);
    a1[112] = 0;
    pthread_cond_broadcast(&collectable_cond);
  }
  pthread_mutex_unlock(&collectable_mutex);

  CFRelease(a1);
}

void CAImageQueueCollectable(int a1)
{
  pthread_mutex_lock(&collectable_mutex);
  int v2 = (CFTypeRef *)collectable_list;
  if (collectable_list)
  {
    while (1)
    {
      uint64_t v3 = *v2;
      if (*((_DWORD *)*v2 + 7) == a1) {
        break;
      }
      int v2 = (CFTypeRef *)v2[1];
      if (!v2) {
        goto LABEL_4;
      }
    }
    CFRetain(*v2);
    pthread_mutex_unlock(&collectable_mutex);
    int v4 = v3[9];
    if (v4)
    {
      dispatch_async_f(v4, v3, (dispatch_function_t)invoke_collectable_callback);
    }
    else
    {
      invoke_collectable_callback(v3);
    }
  }
  else
  {
LABEL_4:
    pthread_mutex_unlock(&collectable_mutex);
  }
}

void _XSetContextDisplayId(_DWORD *a1, uint64_t a2)
{
  if ((*a1 & 0x80000000) != 0 || a1[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  }
  else
  {
    int v3 = a1[8];
    int v4 = CA::Context::retain_context_with_client_port((CA::Context *)a1[3]);
    if (v4)
    {
      uint64_t v5 = v4;
      int v6 = (pthread_mutex_t *)(v4 + 4);
      pthread_mutex_lock((pthread_mutex_t *)(v4 + 4));
      if (v5[37] != v3)
      {
        v5[37] = v3;
        uint64_t v7 = (CA::Render::Context *)*((void *)v5 + 13);
        if (v7) {
          CA::Render::Context::set_display_id(v7, v3);
        }
      }
      pthread_mutex_unlock(v6);
      CA::Context::unref((CA::Context *)v5, 0);
    }
    *(_DWORD *)(a2 + 32) = 0;
  }
}

int *CA::Context::retain_context_with_client_port(CA::Context *this)
{
  int v1 = (int)this;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
  if (CA::all_contexts(void)::contexts_data_initialized)
  {
    for (uint64_t i = (int **)CA::all_contexts(void)::contexts_data; ; ++i)
    {
      if (i == (int **)qword_1EB2AC6F8)
      {
        int v3 = 0;
        goto LABEL_9;
      }
      int v3 = *i;
      int v4 = **i;
      if (v4)
      {
        if (v3[44] == v1) {
          break;
        }
      }
    }
    *int v3 = v4 + 1;
  }
  else
  {
    int v3 = 0;
    CA::all_contexts(void)::contexts_data = 0;
    qword_1EB2AC6F8 = 0;
    qword_1EB2AC700 = 0;
    CA::all_contexts(void)::contexts_data_initialized = 1;
  }
LABEL_9:
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
  return v3;
}

void _XImageQueueDidComposite(_DWORD *a1, uint64_t a2)
{
  if ((*a1 & 0x80000000) != 0 || a1[1] != 44)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  }
  else
  {
    CAImageQueueDidComposite(a1[8], a1[9], a1[10]);
    *(_DWORD *)(a2 + 32) = 0;
  }
}

void sub_184794BA8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_184794F58(_Unwind_Exception *a1)
{
}

void CAMetalLayerPrivateNextDrawableLocked(CAMetalLayer *a1, CAMetalDrawable **a2, unint64_t *a3)
{
  priv = (char *)a1->_priv;
  uint64_t v5 = mach_absolute_time();
  double v6 = CATimeWithHostTime(v5);
  uint64_t v7 = *(void *)(*((void *)priv + 2) + 48);
  if (v7) {
    unint64_t v8 = atomic_load((unint64_t *)(*(void *)(v7 + 24) + 8));
  }
  else {
    unint64_t v8 = 0;
  }
  int v9 = (v8 >> 37) & 0x4000 | *((_WORD *)priv + 144) & 0xBFFF;
  *((_WORD *)priv + 144) = (v8 >> 37) & 0x4000 | *((_WORD *)priv + 144) & 0xBFFF;
  if ((*((_DWORD *)priv + 1) & 1) == 0)
  {
    [(CALayer *)a1 size];
    double v11 = v10;
    double v13 = v12;
    [(CALayer *)a1 contentsScale];
    layer_private_set_drawable_size_internal((_CAMetalLayerPrivate *)priv, (v11 * v14), (v13 * v14));
    LOWORD(v9) = *((_WORD *)priv + 144);
  }
  unsigned int v72 = 0;
  if ((v9 & 0x40) != 0 && (v8 & 0x800000000000000) != 0)
  {
    if (CADeviceUseCompression::once[0] != -1) {
      dispatch_once(CADeviceUseCompression::once, &__block_literal_global_21);
    }
    if (CADeviceUseCompression::enable_compression)
    {
      if (CADeviceSupportsUniversalCompression::once != -1) {
        dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
      }
      if (!CADeviceSupportsUniversalCompression::universal) {
        goto LABEL_21;
      }
    }
    int v15 = *(unsigned char *)(*(void *)(*(void *)(*((void *)priv + 2) + 48) + 24) + 92) & 3;
    if (v15 == 3 || v15 == 0)
    {
      if ((*(unsigned char *)(*(void *)(*(void *)(*((void *)priv + 2) + 48) + 24) + 92) & 4) != 0)
      {
        if ((*(unsigned char *)(*(void *)(*(void *)(*((void *)priv + 2) + 48) + 24) + 92) & 3) != 0) {
          int v17 = 3;
        }
        else {
          int v17 = 1;
        }
      }
      else
      {
        int v17 = 2 * (v15 != 0);
      }
      unsigned int v72 = v17;
    }
    else
    {
LABEL_21:
      unsigned int v72 = 0;
    }
  }
  double v69 = v6;
  BOOL v19 = (*((_WORD *)priv + 144) & 8) != 0
     && (uint64_t v18 = *(void *)(*((void *)priv + 2) + 48)) != 0
     && *(_DWORD *)(*(void *)(v18 + 24) + 32) != 0;
  if (!*((void *)priv + 9))
  {
LABEL_102:
    NSLog(&cfstr_CametallayerNe_0.isa);
    return;
  }
  char v20 = 0;
  char v70 = 0;
  int v21 = (int *)(priv + 132);
  double v22 = 0.0;
  while (1)
  {
    if (*((void *)priv + 4)) {
      goto LABEL_38;
    }
    if (!byte_1EB2ACC48)
    {
      int v23 = *v21;
      if (!v19) {
        break;
      }
      goto LABEL_35;
    }
    int v23 = 2;
    if (!v19) {
      break;
    }
LABEL_35:
    *((_WORD *)priv + 144) &= ~0x10u;
    int v24 = a1->_priv;
    v24[34] = v23;
    uint64_t v25 = *(void *)(*((void *)v24 + 2) + 48);
    if (v25) {
      *(unsigned char *)(*(void *)(v25 + 24) + 95) = 5 - v23;
    }
    BOOL v19 = 1;
LABEL_38:
    if (v20) {
      goto LABEL_103;
    }
LABEL_39:
    uint64_t v26 = *((void *)priv + 25);
    uint64_t v27 = CAHostTimeWithTime(0.2) + v26;
    if (mach_absolute_time() > v27) {
      goto LABEL_103;
    }
    unsigned int v28 = *((unsigned __int16 *)priv + 144);
    *((_WORD *)priv + 144) = (*((_WORD *)priv + 144) >> 1) & 0x100 | *((_WORD *)priv + 144) & 0xFEFF;
    CAImageQueueSetFlagsInternal(*((int **)priv + 2), 0x4000000000000000, (unint64_t)((v28 >> 1) & 0x100) << 54);
    __int16 v29 = *((_WORD *)priv + 144);
    if ((v29 & 0x100) != 0)
    {
      float v31 = priv + 136;
      if ((v29 & 0x10) != 0) {
        goto LABEL_47;
      }
      float v31 = priv + 136;
      if (*((void *)priv + 4)) {
        goto LABEL_47;
      }
LABEL_46:
      float v31 = priv + 132;
      goto LABEL_47;
    }
    if ((v29 & 0x20) == 0 || *((void *)priv + 4))
    {
      BOOL v30 = 0;
      goto LABEL_48;
    }
    float v31 = priv + 136;
    if ((v29 & 0x10) == 0) {
      goto LABEL_46;
    }
LABEL_47:
    BOOL v30 = *v31 > 2u;
LABEL_48:
    pthread_setspecific(collect_slot, priv);
    unint64_t v32 = CAImageQueueCollect_(*((void *)priv + 2), 0, v30);
    pthread_setspecific(collect_slot, 0);
    if (a3) {
      *a3 = v32;
    }
    if (!a2) {
      return;
    }
    if (v32)
    {
      uint64_t v33 = *((void *)priv + 4) || (*((_WORD *)priv + 144) & 0x10) != 0
          ? *((unsigned int *)priv + 34)
          : *v21;
      if (v33 >= 5) {
        goto LABEL_60;
      }
      unint64_t v34 = 5 - v33;
      unint64_t v35 = v32;
      if (v34 < v32) {
        unint64_t v35 = v34;
      }
      if (v32 != v35)
      {
LABEL_60:
        unused_drawable = get_unused_drawable((uint64_t)priv, v72, (v8 & 0x800000000000000) != 0, 1);
        if (unused_drawable)
        {
          double v67 = unused_drawable;
          atomic_fetch_add(&unused_drawable->var0.var0.var0, 1u);
          unused_drawable->var9 = (_CAMetalLayerPrivate *)priv;
          uint64_t v68 = mach_absolute_time();
          v67->double var8 = CATimeWithHostTime(v68);
          IOSurfaceGetID(v67->var10);
          kdebug_trace();
          double v65 = [CAMetalDrawable alloc];
          __int16 v66 = v67;
          goto LABEL_109;
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)priv + 2);
    uint64_t v37 = mach_absolute_time();
    double v38 = CATimeWithHostTime(v37);
    double v39 = v38;
    if (v22 == 0.0)
    {
      double v22 = v38;
    }
    else if (v70 & 1 | (v38 <= v22 + 0.05) || (dyld_program_sdk_at_least() & 1) != 0)
    {
      if ((*((_WORD *)priv + 144) & 0x80) != 0)
      {
        double v45 = 0.064;
        if ((*((_WORD *)priv + 144) & 0x4000) == 0) {
          double v45 = *((double *)priv + 6);
        }
        if (v39 > v45 + v22)
        {
          NSLog(&cfstr_CametallayerNe_2.isa);
          os_unfair_lock_lock((os_unfair_lock_t)priv + 2);
          return;
        }
      }
    }
    else
    {
      int v47 = (void *)MEMORY[0x185324A30]();
      +[CATransaction flush];
      char v70 = 1;
    }
    kdebug_trace();
    char v20 = 0;
    int v40 = 2;
    atomic_compare_exchange_strong((atomic_uint *volatile)priv + 38, (unsigned int *)&v40, 0);
    if (v40 != 2)
    {
      while (1)
      {
        int v41 = 0;
        atomic_compare_exchange_strong((atomic_uint *volatile)priv + 38, (unsigned int *)&v41, 1u);
        if (!v41)
        {
          double v42 = 0.064;
          if ((*((_WORD *)priv + 144) & 0x4000) == 0) {
            double v42 = *((double *)priv + 6);
          }
          dispatch_time_t v43 = dispatch_time(0, (uint64_t)(v42 * 1000000000.0));
          if (dispatch_semaphore_wait(*((dispatch_semaphore_t *)priv + 18), v43)) {
            break;
          }
        }
        int v44 = 2;
        atomic_compare_exchange_strong((atomic_uint *volatile)priv + 38, (unsigned int *)&v44, 0);
        if (v44 == 2)
        {
          char v20 = 0;
          goto LABEL_79;
        }
      }
      char v20 = 1;
      int v46 = 1;
      atomic_compare_exchange_strong((atomic_uint *volatile)priv + 38, (unsigned int *)&v46, 0);
      if (v46 != 1) {
        dispatch_semaphore_wait(*((dispatch_semaphore_t *)priv + 18), 0xFFFFFFFFFFFFFFFFLL);
      }
    }
LABEL_79:
    kdebug_trace();
    os_unfair_lock_lock((os_unfair_lock_t)priv + 2);
    if (!*((void *)priv + 9)) {
      goto LABEL_102;
    }
  }
  int v48 = v23 + 1;
  int v49 = a1->_priv;
  v49[34] = v48;
  uint64_t v50 = *(void *)(*((void *)v49 + 2) + 48);
  if (v50) {
    *(unsigned char *)(*(void *)(v50 + 24) + 95) = 5 - v48;
  }
  *((_WORD *)priv + 144) |= 0x10u;
  uint64_t v51 = mach_absolute_time();
  double v52 = CATimeWithHostTime(v51);
  double v53 = *((double *)priv + 30) - v52 + 0.00833333333;
  if (v53 > 0.00833333333) {
    double v53 = 0.00833333333;
  }
  if (v53 >= 0.0) {
    double v54 = v53;
  }
  else {
    double v54 = 0.0;
  }
  uint64_t v55 = mach_absolute_time();
  double v56 = CATimeWithHostTime(v55);
  for (double i = v56 - v56; ; double i = v59 - v56)
  {
    if (i >= v54)
    {
      BOOL v19 = 0;
      goto LABEL_99;
    }
    usleep(0x3E8u);
    uint64_t v58 = mach_absolute_time();
    double v59 = CATimeWithHostTime(v58);
    if ((*((_WORD *)priv + 144) & 8) != 0)
    {
      uint64_t v60 = *(void *)(*((void *)priv + 2) + 48);
      if (v60)
      {
        if (*(_DWORD *)(*(void *)(v60 + 24) + 32)) {
          break;
        }
      }
    }
  }
  BOOL v19 = 1;
LABEL_99:
  *((double *)priv + 3CA::Context::unref(this[1], 0) = v54 + v52;
  CAImageQueueConsumeUnconsumed_(*((void *)priv + 2), 0);
  if ((v20 & 1) == 0) {
    goto LABEL_39;
  }
LABEL_103:
  os_unfair_lock_unlock((os_unfair_lock_t)priv + 2);
  layer_private_cleanup_callbacks((_CAMetalLayerPrivate *)priv);
  os_unfair_lock_lock((os_unfair_lock_t)priv + 2);
  pthread_setspecific(collect_slot, priv);
  uint64_t v61 = CAImageQueueCollect_(*((void *)priv + 2), 0, 0);
  pthread_setspecific(collect_slot, 0);
  if (a3) {
    *a3 = v61;
  }
  if (a2)
  {
    __int16 v62 = get_unused_drawable((uint64_t)priv, v72, (v8 & 0x800000000000000) != 0, 0);
    if (v62)
    {
      double v63 = v62;
      *((unsigned char *)v62 + 113) |= 8u;
      atomic_fetch_add(&v62->var0.var0.var0, 1u);
      v62->var9 = (_CAMetalLayerPrivate *)priv;
      uint64_t v64 = mach_absolute_time();
      v63->double var8 = CATimeWithHostTime(v64);
      IOSurfaceGetID(v63->var10);
      kdebug_trace();
      double v65 = [CAMetalDrawable alloc];
      __int16 v66 = v63;
LABEL_109:
      *a2 = [(CAMetalDrawable *)v65 initWithDrawablePrivate:v66 layer:a1 waitStart:v69];
      return;
    }
    NSLog(&cfstr_CametallayerNe_1.isa);
  }
}

void sub_184795794(_Unwind_Exception *a1)
{
  objc_end_catch();
  os_unfair_lock_lock(v1);
  _Unwind_Resume(a1);
}

void sub_1847957A0()
{
}

uint64_t CAImageQueueCollect_(uint64_t a1, int a2, int a3)
{
  mach_msg_return_t v48;
  mach_port_t msgh_remote_port;
  void *v50;
  unint64_t v51;
  _DWORD *v52;
  unint64_t v53;
  _DWORD *v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  double *v59;
  _DWORD *v60;
  _DWORD *v61;
  unint64_t v62;
  int v63;
  unsigned int v64;
  _DWORD *v65;
  void *v66;
  BOOL v67;
  unint64_t v68;
  void *v69;
  uint64_t v70;
  int v71;
  BOOL v72;
  void *v73;
  _DWORD *v74;
  BOOL v75;
  unsigned int v76;
  os_unfair_lock_s *lock;
  mach_msg_header_t msg[2];
  uint64_t v79;

  uint32x2_t v79 = *MEMORY[0x1E4F143B8];
  if (a3) {
    BOOL v5 = *(_DWORD *)(a1 + 40) > 2u;
  }
  else {
    BOOL v5 = 0;
  }
  if (!*(void *)(a1 + 48)) {
    return 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 24);
  unint64_t v7 = *(unsigned int *)(a1 + 40);
  double v8 = 0.0;
  locint k = (os_unfair_lock_s *)(a1 + 16);
  double v75 = v5;
  if (a2)
  {
    if (!*(_DWORD *)(a1 + 40)) {
      goto LABEL_54;
    }
    int v9 = (double *)(v6 + 536);
    uint64_t v10 = *(unsigned int *)(a1 + 40);
    do
    {
      if (*((_DWORD *)v9 - 1) && (*(_DWORD *)v9 & 0x80000000) == 0 && *((_DWORD *)v9 - 2) == *(_DWORD *)(v6 + 16))
      {
        double v11 = *(v9 - 9);
        if (v11 > v8 && v11 <= *(double *)(v6 + 136)) {
          double v8 = *(v9 - 9);
        }
      }
      v9 += 20;
      --v10;
    }
    while (v10);
  }
  if (*(_DWORD *)(a1 + 40))
  {
    unint64_t v13 = 0;
    double v14 = 0;
    int v15 = 0;
    unsigned int v16 = 0;
    int v17 = (int *)(v6 + 536);
    while (!*(v17 - 1))
    {
      ++v16;
LABEL_51:
      ++v13;
      v17 += 40;
      if (v13 >= v7) {
        goto LABEL_55;
      }
    }
    int v18 = *(v17 - 3);
    if (v18 > 572662305)
    {
      if (v18 != 572662306 && v18 != 858993459) {
        goto LABEL_50;
      }
      char v27 = 0;
    }
    else
    {
      if (v18) {
        BOOL v19 = v18 == 286331153;
      }
      else {
        BOOL v19 = 1;
      }
      if (!v19 || a2 == 0) {
        goto LABEL_50;
      }
      BOOL v21 = 0;
      int v22 = *(v17 - 2);
      int v23 = *(_DWORD *)(v6 + 16);
      double v24 = *((double *)v17 - 9);
      if (v24 != 0.0 && v8 != 0.0) {
        BOOL v21 = v24 < v8 && *v17 >= 0 && v22 == v23;
      }
      char v27 = 1;
      if (((v22 - v23) & 0x80000000) == 0 && !v21) {
        goto LABEL_50;
      }
    }
    double v14 = release_image((void *)a1, v13, v14, v27);
    ++v16;
    unint64_t v7 = *(unsigned int *)(a1 + 40);
LABEL_50:
    v15 |= (*v17 & 4u) >> 2;
    goto LABEL_51;
  }
LABEL_54:
  unsigned int v16 = 0;
  int v15 = 0;
  double v14 = 0;
LABEL_55:
  BOOL v30 = v14;
  os_unfair_lock_unlock(lock);
  unsigned int v31 = *(unsigned __int8 *)(v6 + 95);
  if (v75 && v16 <= v31)
  {
    os_unfair_lock_lock(lock);
    unint64_t v32 = *(unsigned int *)(a1 + 40);
    if (v32)
    {
      uint64_t v33 = 0;
      unsigned int v34 = 0;
      unsigned int v35 = 0;
      unsigned int v36 = 0;
      uint64_t v37 = v6 + 524;
      do
      {
        if (*(_DWORD *)(v37 + 8) && *(_DWORD *)v37 == 286331153)
        {
          *(unsigned char *)(v37 + 63) = 0;
          if (v35) {
            BOOL v38 = *(_DWORD *)(v37 + 40) >= v36;
          }
          else {
            BOOL v38 = 0;
          }
          if (!v38)
          {
            unsigned int v36 = *(_DWORD *)(v37 + 40);
            unsigned int v34 = v33;
          }
          ++v35;
        }
        ++v33;
        v37 += 160;
      }
      while (v32 != v33);
    }
    else
    {
      unint64_t v32 = 0;
      unsigned int v36 = 0;
      unsigned int v35 = 0;
      unsigned int v34 = 0;
    }
    unint64_t v41 = *(unsigned __int8 *)(v6 + 95) + 1;
    BOOL v38 = v32 >= v41;
    unint64_t v42 = v32 - v41;
    if (!v38) {
      unint64_t v42 = 0;
    }
    BOOL v43 = v42 > v35 || v36 == 0;
    if (v43 || !*(_DWORD *)(a1 + 212)) {
      goto LABEL_86;
    }
    uint64_t v44 = v34;
    IOSurfaceID ID = IOSurfaceGetID(*(IOSurfaceRef *)(*(void *)(a1 + 64) + 8 * v34));
    mach_port_t v46 = *(_DWORD *)(a1 + 212);
    memset(&msg[0].msgh_id, 0, 28);
    *(_OWORD *)&msg[0].msgh_size = 0u;
    *(void *)&msg[1].msgh_bits = *MEMORY[0x1E4F14068];
    msg[1].msgh_remote_port = ID;
    mach_port_t reply_port = mig_get_reply_port();
    msg[0].msgh_remote_port = v46;
    msg[0].msgh_local_port = reply_port;
    msg[0].msgh_bits = 5395;
    *(void *)&msg[0].msgh_voucher_port = 0x9D5500000000;
    if (MEMORY[0x1E4F14B18])
    {
      voucher_mach_msg_set(msg);
      mach_port_t reply_port = msg[0].msgh_local_port;
    }
    int v48 = mach_msg(msg, 3, 0x24u, 0x30u, reply_port, 0, 0);
    msgh_remote_port = v48;
    if ((v48 - 268435458) <= 0xE && ((1 << (v48 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(msg[0].msgh_local_port);
      goto LABEL_86;
    }
    if (v48)
    {
      mig_dealloc_reply_port(msg[0].msgh_local_port);
      goto LABEL_135;
    }
    if (msg[0].msgh_id == 71)
    {
      msgh_remote_port = -308;
    }
    else if (msg[0].msgh_id == 40377)
    {
      if ((msg[0].msgh_bits & 0x80000000) == 0)
      {
        if (msg[0].msgh_size == 40)
        {
          if (!msg[0].msgh_remote_port)
          {
            msgh_remote_port = msg[1].msgh_remote_port;
            if (!msg[1].msgh_remote_port)
            {
              if (msg[1].msgh_local_port)
              {
                *(unsigned char *)(v6 + 160 * v44 + 587) = 1;
                BOOL v30 = release_image((void *)a1, v44, v30, 0);
                unsigned int v40 = v16 + 1;
                goto LABEL_87;
              }
LABEL_86:
              unsigned int v40 = v16;
LABEL_87:
              os_unfair_lock_unlock(lock);
              goto LABEL_88;
            }
            goto LABEL_134;
          }
        }
        else if (msg[0].msgh_size == 36)
        {
          if (msg[0].msgh_remote_port) {
            double v67 = 1;
          }
          else {
            double v67 = msg[1].msgh_remote_port == 0;
          }
          if (v67) {
            msgh_remote_port = -300;
          }
          else {
            msgh_remote_port = msg[1].msgh_remote_port;
          }
          goto LABEL_134;
        }
      }
      msgh_remote_port = -300;
    }
    else
    {
      msgh_remote_port = -301;
    }
LABEL_134:
    mach_msg_destroy(msg);
LABEL_135:
    unsigned int v40 = v16;
    if (msgh_remote_port == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_87;
  }
  unsigned int v40 = v16;
LABEL_88:
  uint64_t v50 = v30;
  if (v16 <= v31 && ((v15 ^ 1) & 1) == 0)
  {
    uint64_t v76 = v40;
    os_unfair_lock_lock(lock);
    LODWORD(v5CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(_DWORD *)(a1 + 40);
    if (v51 == 1)
    {
      double v52 = v30;
    }
    else
    {
      double v53 = 0;
      double v54 = (_DWORD *)(v6 + 724);
      uint64_t v55 = 1;
      double v52 = v30;
      do
      {
        double v56 = v6 + 160 * v53;
        if (*(_DWORD *)(v56 + 532))
        {
          int v57 = *(_DWORD *)(v56 + 528);
          if (!*(_DWORD *)(v6 + 160 * v53 + 524) && v57 > *(_DWORD *)(v6 + 16) && v53 + 1 < v51)
          {
            double v59 = (double *)(v56 + 464);
            uint64_t v60 = (_DWORD *)(v6 + 160 * v53 + 564);
            uint64_t v61 = v54;
            __int16 v62 = v55;
            do
            {
              if (*(v61 - 8) && !*(v61 - 10) && v57 == *(v61 - 9) && *v59 == 0.0 && *(double *)(v61 - 25) == 0.0)
              {
                double v63 = 0;
                uint64_t v64 = *v60 >= *v61 ? v62 : v53;
                atomic_compare_exchange_strong((atomic_uint *volatile)(v6 + 160 * v64 + 524), (unsigned int *)&v63, 0x22222222u);
                if (!v63)
                {
                  __int16 v74 = v60;
                  double v65 = release_image((void *)a1, v64, v52, 0);
                  uint64_t v60 = v74;
                  double v52 = v65;
                  ++v76;
                }
              }
              ++v62;
              uint64_t v51 = *(unsigned int *)(a1 + 40);
              v61 += 40;
            }
            while (v62 < v51);
          }
        }
        ++v53;
        ++v55;
        v54 += 40;
      }
      while (v53 < (v51 - 1));
    }
    __int16 v66 = v52;
    os_unfair_lock_unlock(lock);
    uint64_t v50 = v66;
    unsigned int v40 = v76;
  }
  if (BYTE9(xmmword_1EB2ACC10))
  {
    memset(msg, 0, 24);
    if (v50)
    {
      uint64_t v68 = 0;
      double v69 = v50;
      do
      {
        LODWORD(v7CA::Context::unref(this[1], 0) = *((_DWORD *)v69 + 4);
        if (!v70) {
          char v70 = v69[3];
        }
        *(&msg[0].msgh_bits + v68) = v70;
        double v69 = (void *)*v69;
        double v71 = v68 + 1;
        if (v69) {
          unsigned int v72 = v68 >= 5;
        }
        else {
          unsigned int v72 = 1;
        }
        ++v68;
      }
      while (!v72);
      for (; v69; double v69 = (void *)*v69)
        ++v71;
    }
    double v73 = v50;
    kdebug_trace();
    uint64_t v50 = v73;
    if (!v73) {
      return v40;
    }
    goto LABEL_115;
  }
  if (v50) {
LABEL_115:
  }
    release_images(a1, v50);
  return v40;
}

int *CAImageQueueSetFlagsInternal(int *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *((void *)result + 6);
  if (v3)
  {
    int v4 = (unint64_t *)(*(void *)(v3 + 24) + 8);
    do
    {
      unint64_t v5 = atomic_load(v4);
      unint64_t v6 = (v5 | a3 & a2) & (a3 | ~a2);
      unint64_t v7 = v5;
      atomic_compare_exchange_strong((atomic_ullong *volatile)v4, &v7, v6);
    }
    while (v7 != v5);
    if (v5 & 1) == 0 && (v6) {
      return CAImageQueuePing_((uint64_t)result, 0, 0, 0.0, 0.0);
    }
  }
  return result;
}

_DWORD *release_image(void *a1, uint64_t a2, _DWORD *a3, char a4)
{
  uint64_t v8 = *(void *)(a1[6] + 24);
  int v9 = *(const void **)(a1[8] + 8 * a2);
  if (v9)
  {
    unint64_t v10 = atomic_load((unint64_t *)(v8 + 8));
    if ((v10 & 0x400000000000000) == 0) {
      IOSurfaceDecrementUseCount(*(IOSurfaceRef *)(a1[8] + 8 * a2));
    }
    uint64_t v11 = IOSurfaceGetDetachModeCode() & 0xFFFFFFFFFFFFLL;
    CFRelease(v9);
    *(void *)(a1[8] + 8 * a2) = 0;
    uint64_t v12 = v8 + 160 * a2;
    int v13 = *(_DWORD *)(v12 + 520);
    *(_DWORD *)(v12 + 52CA::Context::unref(this[1], 0) = 0;
  }
  else
  {
    int v13 = 0;
    uint64_t v11 = 0xFFFFFFFFFFFFLL;
  }
  if (*(void *)(a1[23] + 8 * a2))
  {
    uint64_t v14 = v8 + 160 * a2;
    int v15 = *(_DWORD *)(v14 + 532);
    uint64_t v28 = v11;
    char v16 = a4;
    uint64_t v17 = *(void *)(v14 + 472);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    BOOL v19 = malloc_type_zone_malloc(malloc_zone, 0x78uLL, 0x8BB15036uLL);
    int v20 = *(_DWORD *)(v14 + 564);
    v19[2] = v15;
    v19[3] = v20;
    int v21 = *(_DWORD *)(v14 + 556);
    *((void *)v19 + 3) = v17;
    a4 = v16;
    v19[4] = v13;
    v19[5] = v21;
    *((void *)v19 + 4) = *(void *)(v14 + 464);
    uint64_t v22 = a1[23];
    uint64_t v23 = a1[24];
    *((void *)v19 + 5) = *(void *)(v22 + 8 * a2);
    *((void *)v19 + 6) = *(void *)(v23 + 8 * a2);
    LODWORD(v23) = *(_DWORD *)(v14 + 548);
    v19[14] = v23;
    *((void *)v19 + 8) = *(void *)(v14 + 480);
    *((void *)v19 + 1CA::Context::unref(this[1], 0) = *(void *)(v14 + 488);
    double v24 = *(double *)(v14 + 496);
    *((double *)v19 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v24;
    uint64_t v25 = *(void *)(v14 + 504);
    *((void *)v19 + 12) = v28;
    *((void *)v19 + 13) = v25;
    double v26 = v24 * (double)v23;
    if (*(double *)(v14 + 512) != 0.0) {
      double v26 = *(double *)(v14 + 512);
    }
    *((double *)v19 + 14) = v26;
    *((unsigned char *)v19 + 73) = *(unsigned char *)(v14 + 585) != 0;
    *((unsigned char *)v19 + 74) = *(unsigned char *)(v14 + 587) != 0;
    *((unsigned char *)v19 + 72) = *(_DWORD *)(v14 + 524) == 858993459;
    *(void *)BOOL v19 = a3;
    *(void *)(v22 + 8 * a2) = 0;
    *(void *)(a1[24] + 8 * a2) = 0;
    a3 = v19;
  }
  if ((a4 & 1) == 0)
  {
    __dmb(0xBu);
    *(_DWORD *)(v8 + 160 * a2 + 532) = 0;
  }
  return a3;
}

void release_images(uint64_t a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  pthread_key_t v4 = release_key;
  if (!release_key)
  {
    *(void *)uint64_t v17 = 0;
    pthread_key_create((pthread_key_t *)v17, 0);
    pthread_key_t v4 = *(void *)v17;
    release_key = *(void *)v17;
  }
  char v16 = pthread_getspecific(v4);
  unint64_t v5 = a2;
  do
  {
    if (release_images(_CAImageQueue *,CAImageQueueReleased *)::initialized)
    {
      if (!release_images(_CAImageQueue *,CAImageQueueReleased *)::log_frames) {
        goto LABEL_15;
      }
    }
    else
    {
      unint64_t v6 = getenv("CA_LOG_IMAGE_QUEUE_FRAMES");
      if (v6) {
        BOOL v7 = atoi(v6) != 0;
      }
      else {
        BOOL v7 = 0;
      }
      release_images(_CAImageQueue *,CAImageQueueReleased *)::log_frames = v7;
      release_images(_CAImageQueue *,CAImageQueueReleased *)::initialized = 1;
      if (!v7) {
        goto LABEL_15;
      }
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v8 = x_log_category_utilities;
      if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = v5[3];
        uint64_t v9 = v5[4];
        int v11 = *((_DWORD *)v5 + 14);
        uint64_t v12 = v5[8];
        uint64_t v13 = v5[10];
        uint64_t v14 = v5[12];
        *(_DWORD *)uint64_t v17 = 134219520;
        *(void *)&v17[4] = a1;
        __int16 v18 = 2048;
        uint64_t v19 = v9;
        __int16 v20 = 2048;
        uint64_t v21 = v10;
        __int16 v22 = 1024;
        int v23 = v11;
        __int16 v24 = 2048;
        uint64_t v25 = v12;
        __int16 v26 = 2048;
        uint64_t v27 = v13;
        __int16 v28 = 2048;
        uint64_t v29 = v14;
        _os_log_impl(&dword_184668000, v8, OS_LOG_TYPE_DEFAULT, "CAImageQueue %p: frame %f (%llx) used %d: %f (%llx) detach: 0x%llx\n", v17, 0x44u);
      }
    }
LABEL_15:
    pthread_setspecific(release_key, v5);
    ((void (*)(void, void, void))v5[5])(*((unsigned int *)v5 + 2), v5[3], v5[6]);
    CAImageQueueDidComposite(*(_DWORD *)(a1 + 28), *((_DWORD *)v5 + 3), *((_DWORD *)v5 + 5));
    unint64_t v5 = (void *)*v5;
  }
  while (v5);
  pthread_setspecific(release_key, v16);
  if (a2)
  {
    do
    {
      int v15 = (void *)*a2;
      free(a2);
      a2 = v15;
    }
    while (v15);
  }
}

void CAImageQueueDidComposite(int a1, unsigned int a2, unsigned int a3)
{
  pthread_mutex_lock(&composited_mutex);
  unint64_t v6 = (CFTypeRef *)composited_list;
  if (composited_list)
  {
    while (1)
    {
      BOOL v7 = *v6;
      if (*((_DWORD *)*v6 + 7) == a1) {
        break;
      }
      unint64_t v6 = (CFTypeRef *)v6[1];
      if (!v6) {
        goto LABEL_4;
      }
    }
    CFRetain(*v6);
    pthread_mutex_unlock(&composited_mutex);
    uint64_t v8 = (unsigned int *)malloc_type_malloc(0x10uLL, 0x1020040EDED9539uLL);
    *(void *)uint64_t v8 = v7;
    v8[2] = a2;
    v8[3] = a3;
    pthread_mutex_lock(&composited_mutex);
    while (v7[160])
      pthread_cond_wait(&composited_cond, &composited_mutex);
    if (*((void *)v7 + 18))
    {
      v7[160] = 1;
      pthread_mutex_unlock(&composited_mutex);
      (*((void (**)(unsigned char *, void, void, void))v7 + 18))(v7, *((void *)v7 + 19), v8[2], v8[3]);
      pthread_mutex_lock(&composited_mutex);
      v7[160] = 0;
      pthread_cond_broadcast(&composited_cond);
    }
    pthread_mutex_unlock(&composited_mutex);
    CFRelease(v7);
    free(v8);
  }
  else
  {
LABEL_4:
    pthread_mutex_unlock(&composited_mutex);
  }
}

void layer_composited(_CAImageQueue *a1, void *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  *((void *)a2 + 25) = mach_absolute_time();
  id v13 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 46);
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  BOOL v7 = (void *)*((void *)a2 + 24);
  uint64_t v8 = [v7 countByEnumeratingWithState:&v15 objects:v14 count:16];
  if (v8)
  {
    uint64_t v9 = *(void *)v16;
    do
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v16 != v9) {
          objc_enumerationMutation(v7);
        }
        int v11 = *(void **)(*((void *)&v15 + 1) + 8 * i);
        if ([v11 presentScheduledInsertSeedValid])
        {
          unsigned int v12 = [v11 presentScheduledInsertSeed];
          if (!a3 || v12 <= a3)
          {
            [v11 setUpdateSeed:a4];
            [v11 setDidComposite:1];
            [v11 didScheduledPresent];
            [v13 addObject:v11];
            IOSurfaceGetID((IOSurfaceRef)objc_msgSend((id)objc_msgSend(v11, "cachedTexture"), "iosurface"));
            [v11 presentScheduledInsertSeed];
            objc_msgSend((id)objc_msgSend(v11, "cachedTexture"), "iosurface");
            IOSurfaceGetDetachModeCode();
            kdebug_trace();
          }
        }
      }
      uint64_t v8 = [v7 countByEnumeratingWithState:&v15 objects:v14 count:16];
    }
    while (v8);
  }
  if ([v13 count]) {
    [*((id *)a2 + 24) removeObjectsInArray:v13];
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 46);
}

void sub_184796638(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_unfair_lock_t lock)
{
}

_CAMetalDrawablePrivate *get_unused_drawable(uint64_t a1, unsigned int a2, int a3, int a4)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  BOOL v7 = *(_CAMetalDrawablePrivate ***)(a1 + 56);
  if (!v7)
  {
LABEL_14:
    if (a4)
    {
      unsigned int v12 = (_DWORD *)(*(void *)(a1 + 32) || (*(_WORD *)(a1 + 288) & 0x10) != 0 ? a1 + 136 : a1 + 132);
      if (*v12 <= *(_DWORD *)(a1 + 128)) {
        return 0;
      }
    }
    layer_private_check_pixel_format(*(_CAMetalLayerPrivate **)(a1 + 72), (CA::Render *)*(unsigned int *)(a1 + 64));
    unsigned int v13 = *(_DWORD *)(a1 + 120);
    unsigned int v14 = *(_DWORD *)(a1 + 124);
    double v39 = *(void **)(a1 + 72);
    uint64_t v40 = *(void *)(a1 + 96);
    __int16 v15 = *(_WORD *)(a1 + 288);
    long long v16 = (CA::Render *)*(unsigned int *)(a1 + 64);
    space = *(CGColorSpace **)(a1 + 248);
    BOOL v38 = *(CAEDRMetadata **)(a1 + 256);
    uint64_t v37 = [*(id *)(a1 + 24) toneMapMode];
    unsigned int v18 = (a2 & 0xFFFFFFFD) == 1 ? v14 : v13;
    int v19 = (a2 & 0xFFFFFFFD) == 1 ? v13 : v14;
    unsigned int v20 = v15 & 0x40;
    unint64_t v22 = *(void *)(a1 + 272);
    uint64_t v21 = *(void *)(a1 + 280);
    int v23 = *(_CAImageQueue **)(a1 + 16);
    int v24 = v20 ? 6 : 0;
    iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format(v16, v18, v19, (MEMORY[0xFFFFFC020] >> 9) & 4 | v24, *(void *)(a1 + 272), @"CAMetalLayer Display Drawable", v17);
    if (!iosurface_with_pixel_format) {
      return 0;
    }
    __int16 v26 = iosurface_with_pixel_format;
    unsigned int v35 = v23;
    uint64_t v9 = (_CAMetalDrawablePrivate *)malloc_type_calloc(1uLL, 0x78uLL, 0x10A0040E43F16B8uLL);
    v9->unsigned int var1 = v13;
    v9->unsigned int var2 = v14;
    v9->var3 = v16;
    v9->var4 = v40;
    v9->var6 = v22;
    v9->var7 = v21;
    v9->var10 = v26;
    v9->var12 = v39;
    v9->int var16 = a2;
    *((unsigned char *)v9 + 113) = *((unsigned char *)v9 + 113) & 0x88 | (v20 >> 6) | 4;
    drawable_set_colorspace(v9, space);
    drawable_set_edr_metadata(v9, v38);
    v9->id var15 = (id)v37;
    v9->var11 = allocate_drawable_texture(v39, v26, v13, v14, v40, 0, a2, v20 != 0, @"CAMetalLayer Display Drawable", v21);
    register_drawable((uint64_t)v9, v35);
    ++*(_DWORD *)(a1 + 128);
    return v9;
  }
  while (1)
  {
    uint64_t v9 = *v7;
    uint64_t v10 = v7[1];
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v7);
    *(void *)(a1 + 56) = v10;
    if (v9->var1 == *(_DWORD *)(a1 + 120)
      && v9->var2 == *(_DWORD *)(a1 + 124)
      && v9->var3 == *(_DWORD *)(a1 + 64)
      && v9->var4 == *(void *)(a1 + 96)
      && ((*(unsigned __int16 *)(a1 + 288) >> 6) & 1) == (*((unsigned char *)v9 + 113) & 1)
      && v9->var12 == *(id *)(a1 + 72)
      && v9->var16 == a2
      && v9->var6 == *(void *)(a1 + 272)
      && v9->var7 == *(void *)(a1 + 280)
      && ((*((unsigned char *)v9 + 113) & 4) != 0 || !a3))
    {
      break;
    }
    release_drawable((_CAMetalLayerPrivate *)a1, v9);
    BOOL v7 = *(_CAMetalDrawablePrivate ***)(a1 + 56);
    if (!v7) {
      goto LABEL_14;
    }
  }
  __int16 v28 = *(CGColorSpace **)(a1 + 248);
  var13 = v9->var13;
  if (!v28 || !var13)
  {
    if (var13 != v28) {
      goto LABEL_38;
    }
LABEL_39:
    int v30 = 0;
    goto LABEL_40;
  }
  if (CFEqual(var13, v28)) {
    goto LABEL_39;
  }
  __int16 v28 = *(CGColorSpace **)(a1 + 248);
LABEL_38:
  drawable_set_colorspace(v9, v28);
  int v30 = 1;
LABEL_40:
  unsigned int v31 = *(CAEDRMetadata **)(a1 + 256);
  var14 = (CAEDRMetadata *)v9->var14;
  if (v31 && var14)
  {
    if (![(CAEDRMetadata *)var14 isEqual:*(void *)(a1 + 256)])
    {
      unsigned int v31 = *(CAEDRMetadata **)(a1 + 256);
LABEL_45:
      drawable_set_edr_metadata(v9, v31);
      int v30 = 1;
    }
  }
  else if (var14 != v31)
  {
    goto LABEL_45;
  }
  id var15 = v9->var15;
  if (var15 != (id)[*(id *)(a1 + 24) toneMapMode])
  {
    v9->id var15 = (id)[*(id *)(a1 + 24) toneMapMode];
    int v30 = 1;
  }
  if ((*((unsigned char *)v9 + 113) & 0x40) != 0)
  {
    var10 = v9->var10;
    uint32_t oldState = 0;
    IOSurfaceSetPurgeable(var10, 0, &oldState);
    *((unsigned char *)v9 + 113) &= ~0x40u;
  }
  if (v30) {
    register_drawable((uint64_t)v9, *(_CAImageQueue **)(a1 + 16));
  }
  return v9;
}

uint64_t CA::Display::DisplayTimingsControl::server_triple_buffered(os_unfair_lock_s *this)
{
  int v2 = this + 3;
  os_unfair_lock_lock(this + 3);
  uint64_t v3 = *(void *)&this[6]._os_unfair_lock_opaque;
  if (v3)
  {
    unsigned __int8 v4 = atomic_load((unsigned __int8 *)(v3 + 2));
    uint64_t v5 = v4 & 1;
  }
  else if ((this[58]._os_unfair_lock_opaque & 0x200) != 0)
  {
    if (CAPrefers60HzAPT(void)::once[0] != -1) {
      dispatch_once(CAPrefers60HzAPT(void)::once, &__block_literal_global_3);
    }
    uint64_t v5 = CAPrefers60HzAPT(void)::enabled != 0;
  }
  else
  {
    uint64_t v5 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v5;
}

void layer_presented(_CAImageQueue *a1, unsigned int a2, double a3, double a4, double a5, char *a6)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  *((void *)a6 + 28) = mach_absolute_time();
  obuint64_t j = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  locint k = (os_unfair_lock_s *)(a6 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)a6 + 52);
  long long v86 = 0u;
  long long v87 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  double v63 = (_CAMetalLayerPrivate *)a6;
  uint64_t v10 = (void *)*((void *)a6 + 27);
  uint64_t v11 = [v10 countByEnumeratingWithState:&v84 objects:v83 count:16];
  if (v11)
  {
    uint64_t v12 = *(void *)v85;
    do
    {
      for (uint64_t i = 0; i != v11; ++i)
      {
        if (*(void *)v85 != v12) {
          objc_enumerationMutation(v10);
        }
        unsigned int v14 = *(void **)(*((void *)&v84 + 1) + 8 * i);
        if (![v14 didComposite])
        {
          if (a2) {
            continue;
          }
LABEL_11:
          [obj addObject:v14];
          continue;
        }
        unsigned int v15 = [v14 updateSeed];
        if (!a2 || v15 <= a2) {
          goto LABEL_11;
        }
      }
      uint64_t v11 = [v10 countByEnumeratingWithState:&v84 objects:v83 count:16];
    }
    while (v11);
  }
  if ([obj count]) {
    [*((id *)v63 + 27) removeObjectsInArray:obj];
  }
  unsigned int v61 = a2;
  long long v81 = 0u;
  long long v82 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  uint64_t v16 = [obj countByEnumeratingWithState:&v79 objects:v78 count:16];
  if (v16)
  {
    uint64_t v60 = *(void *)v80;
    double v17 = a5 + 0.001;
    do
    {
      uint64_t v18 = 0;
      uint64_t v62 = v16;
      do
      {
        if (*(void *)v80 != v60) {
          objc_enumerationMutation(obj);
        }
        int v19 = *(CAMetalDrawable **)(*((void *)&v79 + 1) + 8 * v18);
        os_signpost_id_t v20 = *(unsigned int *)(*(void *)(*(void *)(*((void *)v63 + 2) + 48) + 24) + 88);
        unsigned int v21 = [(CAMetalDrawable *)v19 updateSeed];
        if (a3 <= 0.0 || v21 != v61)
        {
          [(CAMetalDrawable *)v19 setStatus:3];
          mark_drawable_finish(v19, v63, 0, a3);
          goto LABEL_45;
        }
        [(CAMetalDrawable *)v19 setStatus:2];
        [(CAMetalDrawable *)v19 setPresentedTime:a3];
        *(void *)long long buf = 0;
        *(void *)double v65 = 0;
        mach_get_times();
        uint64_t v23 = *(void *)buf;
        uint64_t v24 = *(void *)v65;
        [(CAMetalDrawable *)v19 timeAcquired];
        unint64_t v26 = CAHostTimeWithTime(v25);
        unint64_t v27 = CAHostTimeWithTime(a3);
        [(CAMetalDrawable *)v19 timePresentCalled];
        unint64_t v29 = CAHostTimeWithTime(v28);
        [(CAMetalDrawable *)v19 targetTimestamp];
        uint64_t v30 = v24 - v23;
        uint64_t v31 = v26 + v30;
        uint64_t v32 = v27 + v30;
        uint64_t v33 = v29 + v30;
        if (v34 != 0.0)
        {
          [(CAMetalDrawable *)v19 timePresentCalled];
          double v36 = v35;
          [(CAMetalDrawable *)v19 presentDeadline];
          double v38 = v37;
          [(CAMetalDrawable *)v19 targetPresentationTimestamp];
          if (v36 > v38 || v17 + v39 < a3)
          {
            if (CAMetalLayerStallLog(void)::onceToken[0] != -1) {
              dispatch_once(CAMetalLayerStallLog(void)::onceToken, &__block_literal_global_504);
            }
            uint64_t v40 = &CAMetalLayerStallLog(void)::log;
          }
          else
          {
            if (CAMetalLayerLog(void)::onceToken != -1) {
              dispatch_once(&CAMetalLayerLog(void)::onceToken, &__block_literal_global_500);
            }
            uint64_t v40 = &CAMetalLayerLog(void)::log;
          }
          double v45 = *v40;
          [(CAMetalDrawable *)v19 targetTimestamp];
          uint64_t v46 = v32;
          uint64_t v47 = v26 + v30;
          unint64_t v49 = CAHostTimeWithTime(v48);
          [(CAMetalDrawable *)v19 targetSamplingTimestamp];
          unint64_t v51 = CAHostTimeWithTime(v50);
          [(CAMetalDrawable *)v19 targetPresentationTimestamp];
          uint64_t v58 = v46;
          unint64_t v57 = CAHostTimeWithTime(v52);
          if (v20 && os_signpost_enabled(v45))
          {
            unsigned int v53 = [(CAMetalDrawable *)v19 surfaceID];
            [(CAMetalDrawable *)v19 clientPreferredLatency];
            *(_DWORD *)long long buf = 67241984;
            *(_DWORD *)&uint8_t buf[4] = v53;
            *(_WORD *)double v65 = 2050;
            *(void *)&_OWORD v65[2] = v33;
            __int16 v66 = 2050;
            uint64_t v67 = v49 + v30;
            __int16 v68 = 2050;
            uint64_t v69 = v51 + v30;
            __int16 v70 = 2050;
            uint64_t v71 = v57 + v30;
            __int16 v72 = 2050;
            double v73 = v54;
            __int16 v74 = 2050;
            uint64_t v75 = v47;
            __int16 v76 = 2050;
            uint64_t v77 = v58;
            _os_signpost_emit_with_name_impl(&dword_184668000, v45, OS_SIGNPOST_EVENT, v20, "DrawableLifetime", "ID is queue ID.\n\tsurfaceID=%{public, name=surfaceID}#x\n\ttimePresentCalled=%{public, name=timePresentCalled}llu\n\ttargetTimestamp=%{public, name=targetTimestamp}llu\n\ttargetSamplingTimestamp=%{public, name=targetSamplingTimestamp}llu\n\ttargetPresentationTimestamp=%{public, name=targetPresentationTimestamp}llu\n\tpreferredLatency=%{public, name=preferredLatency}g\n\tbeginTime=%{public, signpost.description:begin_time}llu\n\tendTime=%{public, signpost.description:end_time}llu\n", buf, 0x4Eu);
          }
          BOOL v43 = v63;
          char v44 = (v36 <= v38) | (2 * *((unsigned char *)v63 + 232));
          goto LABEL_44;
        }
        if (CAMetalLayerLog(void)::onceToken == -1)
        {
          if (v20) {
            goto LABEL_34;
          }
        }
        else
        {
          dispatch_once(&CAMetalLayerLog(void)::onceToken, &__block_literal_global_500);
          if (v20)
          {
LABEL_34:
            unint64_t v41 = CAMetalLayerLog(void)::log;
            if (os_signpost_enabled((os_log_t)CAMetalLayerLog(void)::log))
            {
              unsigned int v42 = [(CAMetalDrawable *)v19 surfaceID];
              *(_DWORD *)long long buf = 67240960;
              *(_DWORD *)&uint8_t buf[4] = v42;
              *(_WORD *)double v65 = 2050;
              *(void *)&_OWORD v65[2] = v29 + v30;
              __int16 v66 = 2050;
              uint64_t v67 = v31;
              __int16 v68 = 2050;
              uint64_t v69 = v32;
              _os_signpost_emit_with_name_impl(&dword_184668000, v41, OS_SIGNPOST_EVENT, v20, "DrawableLifetime", "ID is queue ID.\n\tsurfaceID=%{public, name=surfaceID}#x\n\ttimePresentCalled=%{public, name=timePresentCalled}llu\n\tbeginTime=%{public, signpost.description:begin_time}llu\n\tendTime=%{public, signpost.description:end_time}llu\n", buf, 0x26u);
            }
          }
        }
        BOOL v43 = v63;
        char v44 = (2 * *((unsigned char *)v63 + 232)) | 1;
LABEL_44:
        *((unsigned char *)v43 + 232) = v44;
        mark_drawable_finish(v19, v43, 1, a3);
LABEL_45:
        [(CAMetalDrawable *)v19 drawableID];
        [(CAMetalDrawable *)v19 status];
        kdebug_trace();
        [(CAMetalDrawable *)v19 didPresentAtTime:a3];
        kdebug_trace();
        ++v18;
      }
      while (v62 != v18);
      uint64_t v55 = [obj countByEnumeratingWithState:&v79 objects:v78 count:16];
      uint64_t v16 = v55;
    }
    while (v55);
  }
  os_unfair_lock_unlock(lock);

  if (*((void *)v63 + 4))
  {
    if (CAMetalLayerShouldDispatchLink(*((CAMetalLayer **)v63 + 3))) {
      +[CADisplayLink dispatchDeferredDisplayLink:*((void *)v63 + 4)];
    }
  }
}

void sub_18479724C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock)
{
}

void *CA::Context::retain_all_contexts(CA::Context *this, void *a2, size_t *a3, unint64_t *a4, const __CFArray *a5)
{
  int v8 = (int)this;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
  if (a4)
  {
    unint64_t v9 = [a4 count];
    if (CA::all_contexts(void)::contexts_data_initialized)
    {
      uint64_t v10 = (int **)CA::all_contexts(void)::contexts_data;
      uint64_t v11 = qword_1EB2AC6F8;
      while (1)
      {
        if (v10 == (int **)v11) {
          goto LABEL_23;
        }
        uint64_t v12 = *v10;
        int v13 = **v10;
        if (!v13 && (v8 & 1) != 0) {
          break;
        }
        if (v13)
        {
          unsigned int v14 = (id *)(v12 + 20);
          if (*((unsigned char *)v12 + 88))
          {
            if (!objc_loadWeak(v14)) {
              break;
            }
          }
          else if (!*v14)
          {
            break;
          }
        }
LABEL_13:
        ++v10;
      }
      ++v9;
      goto LABEL_13;
    }
    CA::all_contexts(void)::contexts_data = 0;
    qword_1EB2AC6F8 = 0;
    qword_1EB2AC700 = 0;
    CA::all_contexts(void)::contexts_data_initialized = 1;
    goto LABEL_23;
  }
  if (v8)
  {
    if (CA::all_contexts(void)::contexts_data_initialized)
    {
      unint64_t v9 = (qword_1EB2AC6F8 - CA::all_contexts(void)::contexts_data) >> 3;
      goto LABEL_23;
    }
LABEL_66:
    CA::all_contexts(void)::contexts_data = 0;
    qword_1EB2AC6F8 = 0;
    qword_1EB2AC700 = 0;
    CA::all_contexts(void)::contexts_data_initialized = 1;
    if (a2) {
      goto LABEL_27;
    }
LABEL_67:
    size_t v19 = 0;
    goto LABEL_68;
  }
  if (!CA::all_contexts(void)::contexts_data_initialized) {
    goto LABEL_66;
  }
  unsigned int v15 = (_DWORD **)CA::all_contexts(void)::contexts_data;
  if (CA::all_contexts(void)::contexts_data == qword_1EB2AC6F8) {
    goto LABEL_26;
  }
  unint64_t v9 = 0;
  do
  {
    uint64_t v16 = *v15++;
    if (*v16) {
      ++v9;
    }
  }
  while (v15 != (_DWORD **)qword_1EB2AC6F8);
LABEL_23:
  if (v9 > *a3)
  {
    if (v9 >> 61)
    {
      size_t v19 = 0;
      a2 = 0;
      goto LABEL_68;
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    a2 = malloc_type_zone_malloc(malloc_zone, 8 * v9, 0x8BB15036uLL);
  }
LABEL_26:
  if (!a2) {
    goto LABEL_67;
  }
LABEL_27:
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  uint64_t v18 = [a4 countByEnumeratingWithState:&v31 objects:v30 count:16];
  if (v18)
  {
    size_t v19 = 0;
    BOOL v20 = 0;
    uint64_t v21 = *(void *)v32;
    do
    {
      for (uint64_t i = 0; i != v18; ++i)
      {
        if (*(void *)v32 != v21) {
          objc_enumerationMutation(a4);
        }
        uint64_t v23 = (_DWORD *)[*(id *)(*((void *)&v31 + 1) + 8 * i) contextImpl];
        a2[v19 + i] = v23;
        ++*v23;
        BOOL v20 = v20 || v23[35] != 0;
      }
      uint64_t v18 = [a4 countByEnumeratingWithState:&v31 objects:v30 count:16];
      v19 += i;
    }
    while (v18);
  }
  else
  {
    size_t v19 = 0;
    BOOL v20 = 0;
  }
  if (CA::all_contexts(void)::contexts_data_initialized)
  {
    uint64_t v24 = (int **)CA::all_contexts(void)::contexts_data;
    uint64_t v25 = qword_1EB2AC6F8;
    while (1)
    {
      if (v24 == (int **)v25) {
        goto LABEL_63;
      }
      unint64_t v26 = *v24;
      int v27 = **v24;
      if (a4)
      {
        if (v27 || (v8 & 1) == 0)
        {
          if (!v27) {
            goto LABEL_60;
          }
          double v28 = (id *)(v26 + 20);
          if (*((unsigned char *)v26 + 88))
          {
            if (objc_loadWeak(v28)) {
              goto LABEL_60;
            }
          }
          else if (*v28)
          {
            goto LABEL_60;
          }
          int v27 = *v26;
        }
        else
        {
          int v27 = 0;
        }
      }
      else if ((v8 & 1) == 0 && !v27)
      {
        goto LABEL_60;
      }
      a2[v19] = v26;
      *unint64_t v26 = v27 + 1;
      BOOL v20 = v20 || v26[35] != 0;
      ++v19;
LABEL_60:
      ++v24;
    }
  }
  CA::all_contexts(void)::contexts_data = 0;
  qword_1EB2AC6F8 = 0;
  qword_1EB2AC700 = 0;
  CA::all_contexts(void)::contexts_data_initialized = 1;
LABEL_63:
  if (v19 >= 2 && v20) {
    qsort(a2, v19, 8uLL, (int (__cdecl *)(const void *, const void *))CA::compare_contexts);
  }
LABEL_68:
  *a3 = v19;
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
  return a2;
}

void sub_18479763C(_Unwind_Exception *a1)
{
}

BOOL present_on_finish_enabled(_CAImageQueue *a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a1) {
    uint64_t v1 = atomic_load((unint64_t *)(*((void *)a1 + 3) + 8));
  }
  else {
    uint64_t v1 = 0;
  }
  if (wants_compositing_dependencies(void)::once != -1) {
    dispatch_once(&wants_compositing_dependencies(void)::once, &__block_literal_global_515);
  }
  if (wants_compositing_dependencies(void)::wants_compositing_dependencies) {
    BOOL v2 = 0;
  }
  else {
    BOOL v2 = (v1 & 0x802000000000000) == 0;
  }
  BOOL v3 = !v2 || byte_1EB2ACC4B != 0;
  if (byte_1EB2ACC4C)
  {
    char v5 = v1 >= 0 || v3;
    uint64_t v6 = x_log_category_api;
    BOOL v7 = os_signpost_enabled((os_log_t)x_log_category_api);
    if (v5)
    {
      if (!v7) {
        return v1 < 0 && !v3;
      }
      v11[0] = 67241728;
      v11[1] = (unint64_t)v1 >> 63;
      __int16 v12 = 1026;
      BOOL v13 = v3;
      __int16 v14 = 1026;
      int v15 = wants_compositing_dependencies(void)::wants_compositing_dependencies;
      __int16 v16 = 1026;
      BOOL v17 = (v1 & 0x800000000000000) != 0;
      __int16 v18 = 1026;
      int v19 = ((unint64_t)v1 >> 49) & 1;
      __int16 v20 = 1026;
      int v21 = 0;
      __int16 v22 = 1026;
      int v23 = byte_1EB2ACC4B;
      int v8 = "Disabled requested=%{public,name=requested}d disabled=%{public,name=disabled}d wants_compositing_dependencies"
           "=%{public,name=wants_compositing_dependencies}d detached=%{public,name=detached}d game_mode=%{public,name=gam"
           "e_mode}d vsync_disabled=%{public,name=vsync_disabled}d CADebugDisablePresentOnFinish=%{public,name=CADebugDis"
           "ablePresentOnFinish}d";
      unint64_t v9 = v6;
      uint32_t v10 = 44;
    }
    else
    {
      if (!v7) {
        return v1 < 0 && !v3;
      }
      LOWORD(v11[0]) = 0;
      int v8 = "Enabled";
      unint64_t v9 = v6;
      uint32_t v10 = 2;
    }
    _os_signpost_emit_with_name_impl(&dword_184668000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "PresentOnFinish", v8, (uint8_t *)v11, v10);
  }
  return v1 < 0 && !v3;
}

void sub_184797AE0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void _XImageQueueDidPresent(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)a1 & 0x80000000) != 0 || *(_DWORD *)(a1 + 4) != 64)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 32);
    int v3 = *(_DWORD *)(a1 + 36);
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = *(void *)(a1 + 56);
    pthread_mutex_lock(&presented_mutex);
    int v8 = (CFTypeRef *)presented_list;
    if (presented_list)
    {
      while (1)
      {
        CFTypeRef v9 = *v8;
        if (*((_DWORD *)*v8 + 7) == v4) {
          break;
        }
        int v8 = (CFTypeRef *)v8[1];
        if (!v8) {
          goto LABEL_6;
        }
      }
      CFRetain(*v8);
      pthread_mutex_unlock(&presented_mutex);
      uint32_t v10 = malloc_type_malloc(0x28uLL, 0x102004012755DA7uLL);
      *(void *)uint32_t v10 = v9;
      v10[2] = v3;
      *((void *)v10 + 2) = v5;
      *((void *)v10 + 3) = v6;
      *((void *)v10 + 4) = v7;
      if (CA::MachPortUtil::reply_queue(void)::once != -1)
      {
        uint64_t v11 = v10;
        dispatch_once(&CA::MachPortUtil::reply_queue(void)::once, &__block_literal_global_9866);
        uint32_t v10 = v11;
      }
      dispatch_async_f((dispatch_queue_t)CA::MachPortUtil::reply_queue(void)::queue, v10, (dispatch_function_t)invoke_presented_callback);
    }
    else
    {
LABEL_6:
      pthread_mutex_unlock(&presented_mutex);
    }
    *(_DWORD *)(a2 + 32) = 0;
  }
}

void _XSetContextDisplayMask(_DWORD *a1, uint64_t a2)
{
  if ((*a1 & 0x80000000) != 0 || a1[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  }
  else
  {
    int v3 = a1[8];
    int v4 = CA::Context::retain_context_with_client_port((CA::Context *)a1[3]);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = (pthread_mutex_t *)(v4 + 4);
      pthread_mutex_lock((pthread_mutex_t *)(v4 + 4));
      if (v5[36] != v3)
      {
        v5[36] = v3;
        uint64_t v7 = (CA::Render::Context *)*((void *)v5 + 13);
        if (v7) {
          CA::Render::Context::set_display_mask(v7, v3);
        }
      }
      pthread_mutex_unlock(v6);
      CA::Context::unref((CA::Context *)v5, 0);
    }
    *(_DWORD *)(a2 + 32) = 0;
  }
}

void layer_private_cleanup_callbacks(_CAMetalLayerPrivate *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  BOOL v2 = (os_unfair_lock_s *)((char *)a1 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 52);
  int v3 = (void *)[*((id *)a1 + 27) copy];
  [*((id *)a1 + 27) removeAllObjects];
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t v4 = [v3 countByEnumeratingWithState:&v19 objects:v18 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v20;
    do
    {
      for (uint64_t i = 0; i != v4; ++i)
      {
        if (*(void *)v20 != v5) {
          objc_enumerationMutation(v3);
        }
        uint64_t v7 = *(void **)(*((void *)&v19 + 1) + 8 * i);
        [v7 setStatus:3];
        [v7 didPresentAtTime:0.0];
      }
      uint64_t v4 = [v3 countByEnumeratingWithState:&v19 objects:v18 count:16];
    }
    while (v4);
  }
  os_unfair_lock_unlock(v2);

  int v8 = (os_unfair_lock_s *)((char *)a1 + 184);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 46);
  CFTypeRef v9 = (void *)[*((id *)a1 + 24) copy];
  [*((id *)a1 + 24) removeAllObjects];
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v10 = [v9 countByEnumeratingWithState:&v14 objects:v13 count:16];
  if (v10)
  {
    uint64_t v11 = *(void *)v15;
    do
    {
      for (uint64_t j = 0; j != v10; ++j)
      {
        if (*(void *)v15 != v11) {
          objc_enumerationMutation(v9);
        }
        [*(id *)(*((void *)&v14 + 1) + 8 * j) didScheduledPresent];
      }
      uint64_t v10 = [v9 countByEnumeratingWithState:&v14 objects:v13 count:16];
    }
    while (v10);
  }
  os_unfair_lock_unlock(v8);
}

void sub_184798008(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t layer_private_check_pixel_format(_CAMetalLayerPrivate *a1, CA::Render *this)
{
  uint64_t result = CA::Render::fourcc_to_format(this);
  if (a1)
  {
    if ((result - 33) <= 2)
    {
      uint64_t result = [(_CAMetalLayerPrivate *)a1 supportsExtendedXR10Formats];
      if ((result & 1) == 0)
      {
        uint64_t v4 = (void *)MEMORY[0x1E4F1CA00];
        return [v4 raise:@"CAMetalLayerInvalid" format:@"unsupported extended range format"];
      }
    }
  }
  return result;
}

void drawable_set_edr_metadata(_CAMetalDrawablePrivate *a1, CAEDRMetadata *a2)
{
  if (a1)
  {
    if (a1->var14 != a2)
    {
      uint64_t v4 = a2;

      a1->var14 = a2;
      if (a1->var10)
      {
        +[CAEDRMetadata setMetadata:onSurface:](CAEDRMetadata, "setMetadata:onSurface:", a2);
      }
    }
  }
}

void drawable_set_colorspace(_CAMetalDrawablePrivate *a1, CGColorSpaceRef space)
{
  if (a1)
  {
    if (!space && a1->var10) {
      IOSurfaceSetBulkAttachments2();
    }
    if (a1->var13 != space)
    {
      CGColorSpaceRetain(space);
      CGColorSpaceRelease(a1->var13);
      a1->var13 = space;
      var10 = a1->var10;
      if (var10)
      {
        CA::Render::iosurface_set_colorspace(var10, space, v4);
      }
    }
  }
}

CA::Render::ShapeLayer *CA::Render::ShapeLayer::ShapeLayer(CA::Render::ShapeLayer *this, CA::Render::Decoder *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0x2E;
  ++dword_1EB2ADE80;
  *(void *)this = &unk_1ED02CCD8;
  *((void *)this + 2) = CA::Render::Decoder::decode_object(a2, 36);
  long long __dst = 0uLL;
  CA::Render::Decoder::decode_bytes(a2, &__dst, 0x10uLL);
  *(_OWORD *)((char *)this + 24) = __dst;
  *((void *)this + 5) = CA::Render::Decoder::decode_object(a2, 37);
  long long __dst = 0uLL;
  CA::Render::Decoder::decode_bytes(a2, &__dst, 0x10uLL);
  *((_OWORD *)this + 3) = __dst;
  *((void *)this + 8) = CA::Render::Decoder::decode_object(a2, 37);
  *((double *)this + 9) = CA::Render::Decoder::decode_cgfloat(a2);
  *((double *)this + 1CA::Context::unref(this[1], 0) = CA::Render::Decoder::decode_cgfloat(a2);
  *((double *)this + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = CA::Render::Decoder::decode_cgfloat(a2);
  *((double *)this + 12) = CA::Render::Decoder::decode_cgfloat(a2);
  *((double *)this + 13) = CA::Render::Decoder::decode_cgfloat(a2);
  *((void *)this + 14) = CA::Render::Decoder::decode_object(a2, 56);
  unsigned int v4 = CA::Render::Decoder::decode_int8(a2);
  if (v4 >= 2)
  {
    CA::Render::Decoder::set_fatal_error(a2, "%s - enum %u out of range of %u", "decode_int8_enum", v4, 2);
    LOBYTE(v4) = 0;
  }
  *((unsigned char *)this + 12CA::Context::unref(this[1], 0) = v4;
  unsigned int v5 = CA::Render::Decoder::decode_int8(a2);
  if (v5 >= 3)
  {
    CA::Render::Decoder::set_fatal_error(a2, "%s - enum %u out of range of %u", "decode_int8_enum", v5, 3);
    LOBYTE(v5) = 0;
  }
  *((unsigned char *)this + 12CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v5;
  unsigned int v6 = CA::Render::Decoder::decode_int8(a2);
  if (v6 >= 3)
  {
    CA::Render::Decoder::set_fatal_error(a2, "%s - enum %u out of range of %u", "decode_int8_enum", v6, 3);
    LOBYTE(v6) = 0;
  }
  *((unsigned char *)this + 122) = v6;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 0x3FF0000000000000;
  return this;
}

double CA::Render::Decoder::decode_cgfloat(CA::Render::Decoder *this)
{
  if (*((unsigned char *)this + 64)) {
    return COERCE_DOUBLE(CA::Render::Decoder::decode_int64(this));
  }
  else {
    return COERCE_FLOAT(CA::Render::Decoder::decode_int32(this));
  }
}

uint64_t CAImageQueueGetDisplayedPixelCount(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  if (v1) {
    return *(unsigned int *)(*(void *)(v1 + 24) + 68);
  }
  else {
    return 0;
  }
}

void ___ZN2CA3OGL12MetalContext23dispatch_async_pipelineERKNS1_8Pipeline4SpecEPS2_bb_block_invoke(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 2152));
  if ((v2 & 1) == 0)
  {
    unsigned int v4 = (CA::OGL::MetalContext::FragmentShader::Spec *)(a1 + 40);
    unsigned int v5 = NSString;
    uint64_t v6 = CA::OGL::MetalContext::Pipeline::Spec::encode_segment((CA::OGL::MetalContext::Pipeline::Spec *)(a1 + 40));
    uint64_t v7 = (CA::OGL::MetalContext *)[v5 stringWithFormat:@"%@_%@", v6, CA::OGL::MetalContext::FragmentShader::Spec::name(v4)];
    unsigned int v13 = *(unsigned __int8 *)(a1 + 80) << 7;
    if (*(unsigned char *)(a1 + 81)) {
      os_signpost_id_t v8 = 0;
    }
    else {
      os_signpost_id_t v8 = CA::OGL::MetalContext::begin_new_render_pipeline(v7, 0, 0);
    }
    unint64_t v9 = CA::OGL::MetalContext::create_pipeline_state(v1, v4, &v13, (unsigned __int8 *)(v1 + 2152));
    if (v9)
    {
      uint64_t v10 = *(unint64_t **)(a1 + 72);
      if (atomic_load(v10)) {
        __assert_rtn("set_pipeline_state", "ogl-metal.mm", 1455, "!is_complete ()");
      }
      atomic_store(v9, v10);
      ++*(_DWORD *)(v1 + 2128);
      __int16 v12 = (char *)v13;
    }
    else
    {
      __int16 v12 = (char *)(v13 | 0x40);
      *(unsigned char *)(*(void *)(a1 + 72) + 26) = 0;
    }
    CA::OGL::MetalContext::end_new_render_pipeline((CA::OGL::MetalContext *)v1, v8, v12, 0);
  }
}

id CA::OGL::MetalContext::get_pipeline_descriptor(uint64_t a1, uint64_t a2, int a3, unsigned __int8 *a4)
{
  id v8 = (id)objc_opt_new();
  unint64_t v9 = NSString;
  uint64_t v10 = CA::OGL::MetalContext::Pipeline::Spec::encode_segment((CA::OGL::MetalContext::Pipeline::Spec *)a2);
  [v8 setLabel:objc_msgSend(@"com.apple.coreanimation.", "stringByAppendingString:", objc_msgSend(v9, "stringWithFormat:", @"%@_%@", v10, CA::OGL::MetalContext::FragmentShader::Spec::name((CA::OGL::MetalContext::FragmentShader::Spec *)a2)))];
  if (!a3)
  {
    unsigned int v13 = (pthread_mutex_t *)(a1 + 1904);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1904));
    unint64_t v14 = CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::FragmentShader::Spec>::operator()((unsigned __int8 *)a2);
    int8x8_t v15 = *(int8x8_t *)(a1 + 1872);
    if (v15)
    {
      uint8x8_t v16 = (uint8x8_t)vcnt_s8(v15);
      v16.i16[0] = vaddlv_u8(v16);
      if (v16.u32[0] > 1uLL)
      {
        unint64_t v17 = v14;
        if (v14 >= *(void *)&v15) {
          unint64_t v17 = v14 % *(void *)&v15;
        }
      }
      else
      {
        unint64_t v17 = (*(void *)&v15 - 1) & v14;
      }
      __int16 v18 = *(void **)(*(void *)(a1 + 1864) + 8 * v17);
      if (v18)
      {
        for (uint64_t i = (void *)*v18; i; uint64_t i = (void *)*i)
        {
          unint64_t v20 = i[1];
          if (v20 == v14)
          {
            if (i[2] == *(void *)a2
              && i[3] == *(void *)(a2 + 8)
              && *(void *)((char *)i + 27) == *(void *)(a2 + 11))
            {
              fragment_shader = (void *)i[5];
              goto LABEL_114;
            }
          }
          else
          {
            if (v16.u32[0] > 1uLL)
            {
              if (v20 >= *(void *)&v15) {
                v20 %= *(void *)&v15;
              }
            }
            else
            {
              v20 &= *(void *)&v15 - 1;
            }
            if (v20 != v17) {
              break;
            }
          }
        }
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1904));
    fragment_shader = CA::OGL::MetalContext::create_fragment_shader((void **)a1, (const CA::OGL::MetalContext::FragmentShader::Spec *)a2, 0);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1904));
    unint64_t v23 = CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::FragmentShader::Spec>::operator()((unsigned __int8 *)a2);
    unint64_t v24 = v23;
    unint64_t v25 = *(void *)(a1 + 1872);
    if (v25)
    {
      uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v25);
      v26.i16[0] = vaddlv_u8(v26);
      if (v26.u32[0] > 1uLL)
      {
        unint64_t v27 = v23;
        if (v23 >= v25) {
          unint64_t v27 = v23 % v25;
        }
      }
      else
      {
        unint64_t v27 = (v25 - 1) & v23;
      }
      double v28 = *(void ***)(*(void *)(a1 + 1864) + 8 * v27);
      if (v28)
      {
        unint64_t v29 = (char *)*v28;
        if (*v28)
        {
          do
          {
            unint64_t v30 = *((void *)v29 + 1);
            if (v30 == v23)
            {
              if (*((void *)v29 + 2) == *(void *)a2
                && *((void *)v29 + 3) == *(void *)(a2 + 8)
                && *(void *)(v29 + 27) == *(void *)(a2 + 11))
              {
                unsigned int v13 = (pthread_mutex_t *)(a1 + 1904);
                goto LABEL_107;
              }
            }
            else
            {
              if (v26.u32[0] > 1uLL)
              {
                if (v30 >= v25) {
                  v30 %= v25;
                }
              }
              else
              {
                v30 &= v25 - 1;
              }
              if (v30 != v27) {
                break;
              }
            }
            unint64_t v29 = *(char **)v29;
          }
          while (v29);
        }
      }
    }
    else
    {
      unint64_t v27 = 0;
    }
    unint64_t v29 = (char *)operator new(0x30uLL);
    *(void *)unint64_t v29 = 0;
    *((void *)v29 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v24;
    *((_OWORD *)v29 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(_OWORD *)a2;
    *(_DWORD *)(v29 + 3CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(_DWORD *)(a2 + 15);
    *((void *)v29 + 5) = 0;
    float v33 = (float)(unint64_t)(*(void *)(a1 + 1888) + 1);
    float v34 = *(float *)(a1 + 1896);
    if (v25 && (float)(v34 * (float)v25) >= v33)
    {
LABEL_97:
      uint64_t v51 = *(void *)(a1 + 1864);
      double v52 = *(void **)(v51 + 8 * v27);
      if (v52)
      {
        *(void *)unint64_t v29 = *v52;
        unsigned int v13 = (pthread_mutex_t *)(a1 + 1904);
      }
      else
      {
        *(void *)unint64_t v29 = *(void *)(a1 + 1880);
        *(void *)(a1 + 188CA::Context::unref(this[1], 0) = v29;
        *(void *)(v51 + 8 * v27) = a1 + 1880;
        unsigned int v13 = (pthread_mutex_t *)(a1 + 1904);
        if (!*(void *)v29) {
          goto LABEL_106;
        }
        unint64_t v53 = *(void *)(*(void *)v29 + 8);
        if ((v25 & (v25 - 1)) != 0)
        {
          if (v53 >= v25) {
            v53 %= v25;
          }
        }
        else
        {
          v53 &= v25 - 1;
        }
        double v52 = (void *)(*(void *)(a1 + 1864) + 8 * v53);
      }
      *double v52 = v29;
LABEL_106:
      ++*(void *)(a1 + 1888);
LABEL_107:
      if (*((void *)v29 + 5))
      {
        if (fragment_shader)
        {

          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(malloc_zone, fragment_shader);
        }
        fragment_shader = (void *)*((void *)v29 + 5);
      }
      else
      {
        *((void *)v29 + 5) = fragment_shader;
      }
      uint64_t v55 = *(void *)(a1 + 1968);
      *(void *)(a1 + 1968) = v55 + 1;
      fragment_shader[1] = v55;
LABEL_114:
      pthread_mutex_unlock(v13);
      [v8 setFragmentFunction:*fragment_shader];
      if (!a4) {
        goto LABEL_116;
      }
      goto LABEL_115;
    }
    BOOL v35 = 1;
    if (v25 >= 3) {
      BOOL v35 = (v25 & (v25 - 1)) != 0;
    }
    unint64_t v36 = v35 | (2 * v25);
    unint64_t v37 = vcvtps_u32_f32(v33 / v34);
    if (v36 <= v37) {
      int8x8_t prime = (int8x8_t)v37;
    }
    else {
      int8x8_t prime = (int8x8_t)v36;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v25 = *(void *)(a1 + 1872);
    }
    if (*(void *)&prime > v25) {
      goto LABEL_63;
    }
    if (*(void *)&prime < v25)
    {
      unint64_t v45 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 1888) / *(float *)(a1 + 1896));
      if (v25 < 3 || (uint8x8_t v46 = (uint8x8_t)vcnt_s8((int8x8_t)v25), v46.i16[0] = vaddlv_u8(v46), v46.u32[0] > 1uLL))
      {
        unint64_t v45 = std::__next_prime(v45);
      }
      else
      {
        uint64_t v47 = 1 << -(char)__clz(v45 - 1);
        if (v45 >= 2) {
          unint64_t v45 = v47;
        }
      }
      if (*(void *)&prime <= v45) {
        int8x8_t prime = (int8x8_t)v45;
      }
      if (*(void *)&prime >= v25)
      {
        unint64_t v25 = *(void *)(a1 + 1872);
      }
      else
      {
        if (prime)
        {
LABEL_63:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          double v39 = operator new(8 * *(void *)&prime);
          uint64_t v40 = *(void **)(a1 + 1864);
          *(void *)(a1 + 1864) = v39;
          if (v40) {
            operator delete(v40);
          }
          uint64_t v41 = 0;
          *(int8x8_t *)(a1 + 1872) = prime;
          do
            *(void *)(*(void *)(a1 + 1864) + 8 * v41++) = 0;
          while (*(void *)&prime != v41);
          unsigned int v42 = *(void **)(a1 + 1880);
          if (v42)
          {
            unint64_t v43 = v42[1];
            uint8x8_t v44 = (uint8x8_t)vcnt_s8(prime);
            v44.i16[0] = vaddlv_u8(v44);
            if (v44.u32[0] > 1uLL)
            {
              if (v43 >= *(void *)&prime) {
                v43 %= *(void *)&prime;
              }
            }
            else
            {
              v43 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)(a1 + 1864) + 8 * v43) = a1 + 1880;
            double v48 = (void *)*v42;
            if (*v42)
            {
              do
              {
                unint64_t v49 = v48[1];
                if (v44.u32[0] > 1uLL)
                {
                  if (v49 >= *(void *)&prime) {
                    v49 %= *(void *)&prime;
                  }
                }
                else
                {
                  v49 &= *(void *)&prime - 1;
                }
                if (v49 != v43)
                {
                  uint64_t v50 = *(void *)(a1 + 1864);
                  if (!*(void *)(v50 + 8 * v49))
                  {
                    *(void *)(v50 + 8 * v49) = v42;
                    goto LABEL_88;
                  }
                  *unsigned int v42 = *v48;
                  *double v48 = **(void **)(*(void *)(a1 + 1864) + 8 * v49);
                  **(void **)(*(void *)(a1 + 1864) + 8 * v49) = v48;
                  double v48 = v42;
                }
                unint64_t v49 = v43;
LABEL_88:
                unsigned int v42 = v48;
                double v48 = (void *)*v48;
                unint64_t v43 = v49;
              }
              while (v48);
            }
          }
          unint64_t v25 = (unint64_t)prime;
          goto LABEL_92;
        }
        int v91 = *(void **)(a1 + 1864);
        *(void *)(a1 + 1864) = 0;
        if (v91) {
          operator delete(v91);
        }
        unint64_t v25 = 0;
        *(void *)(a1 + 1872) = 0;
      }
    }
LABEL_92:
    if ((v25 & (v25 - 1)) != 0)
    {
      if (v24 >= v25) {
        unint64_t v27 = v24 % v25;
      }
      else {
        unint64_t v27 = v24;
      }
    }
    else
    {
      unint64_t v27 = (v25 - 1) & v24;
    }
    goto LABEL_97;
  }
  uint64_t v11 = (id *)CA::OGL::MetalContext::create_fragment_shader((void **)a1, (const CA::OGL::MetalContext::FragmentShader::Spec *)a2, 1);
  [v8 setFragmentFunction:*v11];

  __int16 v12 = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(v12, v11);
  if (!a4) {
    goto LABEL_116;
  }
LABEL_115:
  unsigned __int8 v56 = atomic_load(a4);
  if (v56) {
    return 0;
  }
LABEL_116:
  unint64_t v57 = (_DWORD *)(a2 + 19);
  if (a3)
  {
    vertex_shader = (id *)CA::OGL::MetalContext::create_vertex_shader((void **)a1, (const CA::OGL::MetalContext::VertexShader::Spec *)(a2 + 19), 1);
    [v8 setVertexFunction:*vertex_shader];

    double v59 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v59, vertex_shader);
    goto LABEL_225;
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 2016));
  unint64_t v60 = CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::VertexShader::Spec>::operator()((unsigned int *)(a2 + 19));
  int8x8_t v61 = *(int8x8_t *)(a1 + 1984);
  if (v61)
  {
    uint8x8_t v62 = (uint8x8_t)vcnt_s8(v61);
    v62.i16[0] = vaddlv_u8(v62);
    if (v62.u32[0] > 1uLL)
    {
      unint64_t v63 = v60;
      if (v60 >= *(void *)&v61) {
        unint64_t v63 = v60 % *(void *)&v61;
      }
    }
    else
    {
      unint64_t v63 = (*(void *)&v61 - 1) & v60;
    }
    uint64_t v64 = *(uint64_t ***)(*(void *)(a1 + 1976) + 8 * v63);
    if (v64)
    {
      for (uint64_t j = *v64; j; uint64_t j = (uint64_t *)*j)
      {
        unint64_t v66 = j[1];
        if (v66 == v60)
        {
          if (*((_DWORD *)j + 4) == *v57)
          {
            int32x2_t v141 = (void *)j[3];
            goto LABEL_224;
          }
        }
        else
        {
          if (v62.u32[0] > 1uLL)
          {
            if (v66 >= *(void *)&v61) {
              v66 %= *(void *)&v61;
            }
          }
          else
          {
            v66 &= *(void *)&v61 - 1;
          }
          if (v66 != v63) {
            break;
          }
        }
      }
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 2016));
  int32x2_t v141 = CA::OGL::MetalContext::create_vertex_shader((void **)a1, (const CA::OGL::MetalContext::VertexShader::Spec *)(a2 + 19), 0);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 2016));
  unint64_t v67 = CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::VertexShader::Spec>::operator()((unsigned int *)(a2 + 19));
  unint64_t v68 = v67;
  unint64_t v69 = *(void *)(a1 + 1984);
  if (v69)
  {
    uint8x8_t v70 = (uint8x8_t)vcnt_s8((int8x8_t)v69);
    v70.i16[0] = vaddlv_u8(v70);
    if (v70.u32[0] > 1uLL)
    {
      unint64_t v71 = v67;
      if (v67 >= v69) {
        unint64_t v71 = v67 % v69;
      }
    }
    else
    {
      unint64_t v71 = (v69 - 1) & v67;
    }
    __int16 v72 = *(void ***)(*(void *)(a1 + 1976) + 8 * v71);
    if (v72)
    {
      double v73 = *v72;
      if (*v72)
      {
        do
        {
          unint64_t v74 = v73[1];
          if (v74 == v67)
          {
            if (*((_DWORD *)v73 + 4) == *v57) {
              goto LABEL_217;
            }
          }
          else
          {
            if (v70.u32[0] > 1uLL)
            {
              if (v74 >= v69) {
                v74 %= v69;
              }
            }
            else
            {
              v74 &= v69 - 1;
            }
            if (v74 != v71) {
              break;
            }
          }
          double v73 = (void *)*v73;
        }
        while (v73);
      }
    }
  }
  else
  {
    unint64_t v71 = 0;
  }
  double v73 = operator new(0x20uLL);
  void *v73 = 0;
  v73[1] = v68;
  *((_DWORD *)v73 + 4) = *v57;
  v73[3] = 0;
  float v75 = (float)(unint64_t)(*(void *)(a1 + 2000) + 1);
  float v76 = *(float *)(a1 + 2008);
  if (!v69 || (float)(v76 * (float)v69) < v75)
  {
    BOOL v77 = 1;
    if (v69 >= 3) {
      BOOL v77 = (v69 & (v69 - 1)) != 0;
    }
    unint64_t v78 = v77 | (2 * v69);
    unint64_t v79 = vcvtps_u32_f32(v75 / v76);
    if (v78 <= v79) {
      int8x8_t v80 = (int8x8_t)v79;
    }
    else {
      int8x8_t v80 = (int8x8_t)v78;
    }
    if (*(void *)&v80 == 1)
    {
      int8x8_t v80 = (int8x8_t)2;
    }
    else if ((*(void *)&v80 & (*(void *)&v80 - 1)) != 0)
    {
      int8x8_t v80 = (int8x8_t)std::__next_prime(*(void *)&v80);
      unint64_t v69 = *(void *)(a1 + 1984);
    }
    if (*(void *)&v80 > v69) {
      goto LABEL_164;
    }
    if (*(void *)&v80 < v69)
    {
      unint64_t v87 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 2000) / *(float *)(a1 + 2008));
      if (v69 < 3 || (uint8x8_t v88 = (uint8x8_t)vcnt_s8((int8x8_t)v69), v88.i16[0] = vaddlv_u8(v88), v88.u32[0] > 1uLL))
      {
        unint64_t v87 = std::__next_prime(v87);
      }
      else
      {
        uint64_t v89 = 1 << -(char)__clz(v87 - 1);
        if (v87 >= 2) {
          unint64_t v87 = v89;
        }
      }
      if (*(void *)&v80 <= v87) {
        int8x8_t v80 = (int8x8_t)v87;
      }
      if (*(void *)&v80 >= v69)
      {
        unint64_t v69 = *(void *)(a1 + 1984);
      }
      else
      {
        if (v80)
        {
LABEL_164:
          if (*(void *)&v80 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          long long v81 = operator new(8 * *(void *)&v80);
          long long v82 = *(void **)(a1 + 1976);
          *(void *)(a1 + 1976) = v81;
          if (v82) {
            operator delete(v82);
          }
          uint64_t v83 = 0;
          *(int8x8_t *)(a1 + 1984) = v80;
          do
            *(void *)(*(void *)(a1 + 1976) + 8 * v83++) = 0;
          while (*(void *)&v80 != v83);
          long long v84 = *(void **)(a1 + 1992);
          if (v84)
          {
            unint64_t v85 = v84[1];
            uint8x8_t v86 = (uint8x8_t)vcnt_s8(v80);
            v86.i16[0] = vaddlv_u8(v86);
            if (v86.u32[0] > 1uLL)
            {
              if (v85 >= *(void *)&v80) {
                v85 %= *(void *)&v80;
              }
            }
            else
            {
              v85 &= *(void *)&v80 - 1;
            }
            *(void *)(*(void *)(a1 + 1976) + 8 * v85) = a1 + 1992;
            unsigned int v92 = (void *)*v84;
            if (*v84)
            {
              do
              {
                unint64_t v93 = v92[1];
                if (v86.u32[0] > 1uLL)
                {
                  if (v93 >= *(void *)&v80) {
                    v93 %= *(void *)&v80;
                  }
                }
                else
                {
                  v93 &= *(void *)&v80 - 1;
                }
                if (v93 != v85)
                {
                  uint64_t v94 = *(void *)(a1 + 1976);
                  if (!*(void *)(v94 + 8 * v93))
                  {
                    *(void *)(v94 + 8 * v93) = v84;
                    goto LABEL_198;
                  }
                  *long long v84 = *v92;
                  *unsigned int v92 = **(void **)(*(void *)(a1 + 1976) + 8 * v93);
                  **(void **)(*(void *)(a1 + 1976) + 8 * v93) = v92;
                  unsigned int v92 = v84;
                }
                unint64_t v93 = v85;
LABEL_198:
                long long v84 = v92;
                unsigned int v92 = (void *)*v92;
                unint64_t v85 = v93;
              }
              while (v92);
            }
          }
          unint64_t v69 = (unint64_t)v80;
          goto LABEL_202;
        }
        uint32x2_t v142 = *(void **)(a1 + 1976);
        *(void *)(a1 + 1976) = 0;
        if (v142) {
          operator delete(v142);
        }
        unint64_t v69 = 0;
        *(void *)(a1 + 1984) = 0;
      }
    }
LABEL_202:
    if ((v69 & (v69 - 1)) != 0)
    {
      if (v68 >= v69) {
        unint64_t v71 = v68 % v69;
      }
      else {
        unint64_t v71 = v68;
      }
    }
    else
    {
      unint64_t v71 = (v69 - 1) & v68;
    }
  }
  uint64_t v95 = *(void *)(a1 + 1976);
  float v96 = *(void **)(v95 + 8 * v71);
  if (v96)
  {
    void *v73 = *v96;
LABEL_215:
    *float v96 = v73;
    goto LABEL_216;
  }
  void *v73 = *(void *)(a1 + 1992);
  *(void *)(a1 + 1992) = v73;
  *(void *)(v95 + 8 * v7CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = a1 + 1992;
  if (*v73)
  {
    unint64_t v97 = *(void *)(*v73 + 8);
    if ((v69 & (v69 - 1)) != 0)
    {
      if (v97 >= v69) {
        v97 %= v69;
      }
    }
    else
    {
      v97 &= v69 - 1;
    }
    float v96 = (void *)(*(void *)(a1 + 1976) + 8 * v97);
    goto LABEL_215;
  }
LABEL_216:
  ++*(void *)(a1 + 2000);
LABEL_217:
  if (v73[3])
  {
    if (v141)
    {

      int32x4_t v98 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v98, v141);
    }
    int32x2_t v141 = (void *)v73[3];
  }
  else
  {
    v73[3] = v141;
  }
  uint64_t v99 = *(void *)(a1 + 2080);
  *(void *)(a1 + 208CA::Context::unref(this[1], 0) = v99 + 1;
  v141[1] = v99;
LABEL_224:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 2016));
  [v8 setVertexFunction:*v141];
LABEL_225:
  unint64_t v100 = *(unsigned __int16 *)(a2 + 21);
  if ((v100 & 0x80) == 0)
  {
    uint64_t v101 = (v100 >> 5) & 3;
    uint64_t v102 = a1 + 8 * v101;
    int8x16_t v103 = *(void **)(v102 + 2160);
    if (!v103)
    {
      uint64_t v104 = (void *)(v102 + 2160);
      int8x16_t v103 = objc_opt_new();
      int64x2_t v105 = (void *)[v103 attributes];
      double v106 = objc_msgSend((id)objc_msgSend(v103, "layouts"), "objectAtIndexedSubscript:", 1);
      unint64_t v107 = CA::OGL::MetalContext::vertex_layout_info[20 * v101];
      [v106 setStride:v107 & 0x3F];
      [v106 setStepFunction:1];
      uint64_t v108 = (v107 >> 6) & 7;
      if (v108)
      {
        float v109 = &CA::OGL::MetalContext::vertex_layout_info[20 * v101 + 4];
        do
        {
          unsigned int v110 = *v109;
          v109 += 4;
          char v111 = (void *)[v105 objectAtIndexedSubscript:v110 & 7];
          [v111 setFormat:v110 >> 3];
          [v111 setOffset:((unint64_t)v110 >> 8) & 0x3F];
          [v111 setBufferIndex:1];
          --v108;
        }
        while (v108);
      }
      *uint64_t v104 = v103;
    }
    [v8 setVertexDescriptor:v103];
  }
  uint64_t v112 = (void *)[v8 colorAttachments];
  if ((*(unsigned char *)(a2 + 16) & 0x60) != 0)
  {
    uint64_t v113 = 0;
    while (1)
    {
      float v115 = (void *)[v112 objectAtIndexedSubscript:v113];
      if (!v113)
      {
        uint64_t v116 = *(_WORD *)(a2 + 24) & 0x3FF;
        goto LABEL_256;
      }
      if (v113 == 2 && ((*(unsigned __int16 *)(a2 + 24) | (*(unsigned __int8 *)(a2 + 26) << 16)) & 0x20000) != 0)
      {
        uint64_t v116 = 55;
        goto LABEL_256;
      }
      unint64_t v117 = *(_WORD *)(a2 + 24) & 0x3FF;
      if (v117 > 0x59) {
        break;
      }
      switch(v117)
      {
        case 0xAuLL:
          uint64_t v118 = 30;
          break;
        case 0x2BuLL:
          uint64_t v118 = 80;
          break;
        case 0x3FuLL:
          uint64_t v118 = 113;
          break;
        default:
          goto LABEL_253;
      }
LABEL_255:
      uint64_t v116 = CA::OGL::non_srgb_pixel_format(v118, v114);
LABEL_256:
      [v115 setPixelFormat:v116];
      __int16 v119 = *(_WORD *)(a2 + 17);
      if ((v119 & 4) == 0 && v113 != (v119 & 3)) {
        [v115 setWriteMask:0];
      }
      if (++v113 >= (((unint64_t)*(unsigned __int8 *)(a2 + 16) >> 5) & 3)) {
        goto LABEL_260;
      }
    }
    uint64_t v118 = 110;
    if (v117 == 90 || v117 == 94) {
      goto LABEL_255;
    }
    if (v117 == 554)
    {
      if (CADeviceIsVirtualized::once != -1) {
        dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
      }
      if (CADeviceIsVirtualized::is_virtualized) {
        uint64_t v118 = 115;
      }
      else {
        uint64_t v118 = 550;
      }
      goto LABEL_255;
    }
LABEL_253:
    uint64_t v118 = *(_WORD *)(a2 + 24) & 0x3FF;
    goto LABEL_255;
  }
LABEL_260:
  if ((*(_WORD *)(a2 + 24) & 0xFC00) != 0xE800)
  {
    int v120 = (void *)[v112 objectAtIndexedSubscript:*(_WORD *)(a2 + 17) & 3];
    int v121 = *(unsigned __int16 *)(a2 + 24) >> 10;
    [v120 setBlendingEnabled:1];
    unint64_t v122 = (unsigned __int16)CA::OGL::MetalContext::blend_function_info[v121];
    [v120 setAlphaBlendOperation:v122 >> 5];
    unsigned int v123 = *(unsigned __int16 *)(a2 + 24) >> 10;
    if (v123 < 0x18)
    {
      [v120 setRgbBlendOperation:v122 >> 5];
      [v120 setSourceRGBBlendFactor:(v122 >> 8) & 0xF];
      uint64_t v125 = 5;
      if (v123 >= 0x16) {
        uint64_t v125 = 1;
      }
      if (v123 <= 0x12) {
        uint64_t v126 = (v122 >> 8) & 0xF;
      }
      else {
        uint64_t v126 = v123 < 0x16;
      }
      unsigned int v127 = v122 >> 12;
      uint64_t v128 = v122 >> 12;
      if (v123 <= 0x12) {
        uint64_t v124 = v127;
      }
      else {
        uint64_t v124 = v125;
      }
      [v120 setSourceAlphaBlendFactor:v126];
      [v120 setDestinationRGBBlendFactor:v128];
    }
    else
    {
      [v120 setWriteMask:1];
      [v120 setSourceAlphaBlendFactor:(v122 >> 8) & 0xF];
      uint64_t v124 = v122 >> 12;
    }
    [v120 setDestinationAlphaBlendFactor:v124];
  }
  if ((*(_WORD *)&CA::OGL::MetalContext::texture_function_info[8 * (*(unsigned char *)(a2 + 14) & 0x7F)
                                                              - (*(unsigned char *)(a2 + 14) & 0x7F)
                                                              + 5] & 0x10) != 0)
  {
    uint64_t v129 = (void *)[v8 colorAttachments];
    uint64_t v130 = v129;
    int v131 = *(unsigned char *)(a2 + 14) & 0x7F;
    if ((v131 - 83) < 7)
    {
      uint64_t v132 = (void *)[v129 objectAtIndexedSubscript:0];
      [v132 setWriteMask:0];
      [v132 setBlendingEnabled:0];
      int v133 = (void *)[v130 objectAtIndexedSubscript:1];
      [v133 setWriteMask:0];
      [v133 setBlendingEnabled:0];
      int32x4_t v134 = objc_msgSend((id)objc_msgSend(v8, "colorAttachments"), "objectAtIndexedSubscript:", 2);
      [v134 setWriteMask:8];
      [v134 setBlendingEnabled:1];
      [v134 setSourceRGBBlendFactor:1];
      [v134 setDestinationRGBBlendFactor:1];
      [v134 setRgbBlendOperation:4 * ((*(unsigned char *)(a2 + 14) & 0x7Fu) - 83 > 4)];
LABEL_278:
      [v8 setVertexDescriptor:0];
      return v8;
    }
    if ((v131 - 91) < 2)
    {
      int32x4_t v135 = (void *)[v129 objectAtIndexedSubscript:2];
      [v135 setBlendingEnabled:0];
      [v135 setWriteMask:8];
      int32x4_t v136 = (void *)[v130 objectAtIndexedSubscript:(*(_WORD *)(a2 + 17) & 3) == 0];
      [v136 setBlendingEnabled:0];
      [v136 setWriteMask:0];
      goto LABEL_278;
    }
    if (v131 == 90)
    {
      int32x4_t v138 = (void *)[v129 objectAtIndexedSubscript:0];
      [v138 setBlendingEnabled:0];
      [v138 setWriteMask:0];
      int32x2_t v139 = (void *)[v130 objectAtIndexedSubscript:1];
      [v139 setBlendingEnabled:0];
      [v139 setWriteMask:0];
      uint32x2_t v140 = (void *)[v130 objectAtIndexedSubscript:2];
      [v140 setBlendingEnabled:0];
      [v140 setWriteMask:8];
    }
  }
  return v8;
}

void sub_184799820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, pthread_mutex_t *a12)
{
  operator delete(v12);
  pthread_mutex_unlock(v13);
  _Unwind_Resume(a1);
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::name(CA::OGL::MetalContext::Pipeline::Spec *this)
{
  unsigned __int8 v2 = NSString;
  uint64_t v3 = CA::OGL::MetalContext::Pipeline::Spec::encode_segment(this);
  return [v2 stringWithFormat:@"%@_%@", v3, CA::OGL::MetalContext::FragmentShader::Spec::name(this)];
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::encode_segment(CA::OGL::MetalContext::Pipeline::Spec *this)
{
  *(void *)&v14[13] = *MEMORY[0x1E4F143B8];
  *(void *)&v14[5] = 0;
  *(void *)unint64_t v14 = 0;
  char v13 = 80;
  unsigned __int16 v2 = *((_WORD *)this + 12);
  unsigned int v3 = v2 & 0x3FF;
  if (v3 <= 0x22C && (unsigned int v4 = (_DWORD *)CA::OGL::MetalContext::MTLPixelFormat_codes[v2 & 0x3FF]) != 0)
  {
    *(_DWORD *)unint64_t v14 = *v4;
  }
  else
  {
    snprintf(v14, 5uLL, "%04d", v3);
    unsigned __int16 v2 = *((_WORD *)this + 12);
  }
  if ((v2 & 0xFC00) == 0xE800)
  {
    unsigned int v5 = &v14[4];
  }
  else
  {
    v14[4] = 66;
    unsigned int v6 = v2 >> 10;
    if (v6 > 0x3A)
    {
      snprintf(&v14[5], 4uLL, "%03d", v6);
    }
    else
    {
      uint64_t v7 = CA::OGL::MetalContext::BlendFunction_codes[v6];
      __int16 v8 = *(_WORD *)v7;
      v14[7] = v7[2];
      *(_WORD *)&v14[5] = v8;
    }
    unsigned int v5 = &v14[8];
  }
  *unsigned int v5 = 0;
  unint64_t v9 = v5 + 1;
  if (*((unsigned char *)this + 23))
  {
    *(_WORD *)unsigned int v5 = 25176;
    unint64_t v9 = v5 + 2;
    int v10 = 88;
  }
  else
  {
    int v10 = 0;
  }
  int v11 = *((unsigned __int16 *)this + 12) | (*((unsigned __int8 *)this + 26) << 16);
  if ((v11 & 0x10000) != 0)
  {
    int v10 = 88;
    *unsigned int v5 = 88;
    *v9++ = 109;
  }
  if ((v11 & 0x20000) != 0)
  {
    *unsigned int v5 = 88;
    *v9++ = 119;
    int v10 = *v5;
  }
  if (v10) {
    unsigned int v5 = v9;
  }
  *unsigned int v5 = 0;
  return [NSString stringWithUTF8String:&v13];
}

uint64_t calcModeFromString(const __CFString *a1)
{
  int v2 = CAInternAtom(a1, 0);
  if (v2 <= 180)
  {
    if (v2 == 153) {
      return 3;
    }
    if (v2 == 154) {
      return 4;
    }
    goto LABEL_11;
  }
  if (v2 != 181)
  {
    if (v2 == 420) {
      return 2;
    }
    if (v2 == 359) {
      return 1;
    }
LABEL_11:
    NSLog(&cfstr_UnknownAnimati.isa, a1);
  }
  return 0;
}

int8x16_t *CA::Render::copy_render_value(int8x16_t *cf, CGImage *a2, CGColorSpace *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!cf) {
    return cf;
  }
  unsigned int v4 = (__CFString *)cf;
  if (CA::Render::initialize_types(void)::once[0] != -1) {
    dispatch_once(CA::Render::initialize_types(void)::once, &__block_literal_global_5);
  }
  CFTypeID v5 = CFGetTypeID(v4);
  if (v5 == CA::Render::image_type)
  {
    return (int8x16_t *)CA::Render::copy_image((CA::Render *)v4, a2, 0, 0.0, 1.0);
  }
  if (v5 == CA::Render::backing_type)
  {
    return (int8x16_t *)CABackingStoreRetainFrontTexture((uint64_t)v4, a2);
  }
  if (v5 == CA::Render::color_type)
  {
    if (CGColorGetPattern((CGColorRef)v4)) {
      return 0;
    }
    float64x2_t valuePtr = 0u;
    *(_OWORD *)unint64_t v20 = 0u;
    CA_CGColorGetRGBComponents((CGColor *)v4, a2, valuePtr.f64);
    float64x2_t v16 = vmulq_n_f64(valuePtr, v20[1]);
    double v17 = v20[0] * v20[1];
    double v18 = v20[1];
    p_float64x2_t valuePtr = &v16;
    uint64_t v12 = 4;
    return (int8x16_t *)CA::Render::Vector::new_vector((CA::Render::Vector *)v12, p_valuePtr, v7);
  }
  if (v5 == CA::Render::surface_type)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    cf = (int8x16_t *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x158uLL, 0x743898A5uLL);
    if (!cf) {
      return cf;
    }
    unint64_t v9 = (__IOSurface *)v4;
    char v10 = 35;
    return (int8x16_t *)CA::Render::Surface::Surface((uint64_t)cf, v9, -1, v10, 0x8000, 0, 0);
  }
  if (v5 == CA::Render::machport_type)
  {
    cf = (int8x16_t *)x_mem_alloc0(0x158uLL);
    if (cf) {
      return (int8x16_t *)CA::Render::Surface::Surface((CA::Render::Texture *)cf, v4);
    }
    return cf;
  }
  if (v5 == CA::Render::caiosurface_type)
  {
    return (int8x16_t *)CAIOSurfaceRetainFrontTexture((CA::Render::Surface *)v4);
  }
  if (v5 == CA::Render::cvpixelbuffer_type)
  {
    cf = (int8x16_t *)CVPixelBufferGetIOSurface((CVPixelBufferRef)v4);
    if (!cf) {
      return cf;
    }
    char v13 = cf;
    cf = (int8x16_t *)x_mem_alloc0(0x158uLL);
    if (!cf) {
      return cf;
    }
    unint64_t v9 = (__IOSurface *)v13;
    char v10 = 3;
    return (int8x16_t *)CA::Render::Surface::Surface((uint64_t)cf, v9, -1, v10, 0x8000, 0, 0);
  }
  if (v5 == CA::Render::queue_type)
  {
    return (int8x16_t *)CAImageQueueCopyRenderValue((uint64_t)v4);
  }
  if (v5 == CA::Render::provider_type)
  {
    return (int8x16_t *)CAImageProviderCopyRenderValue((uint64_t)v4, (uint64_t)v6);
  }
  if (v5 == CA::Render::path_type)
  {
    return CA::Render::Path::new_path((CGPathRef)v4, v6);
  }
  if (v5 == CA::Render::number_type)
  {
    valuePtr.f64[0] = 0.0;
    CFNumberGetValue((CFNumberRef)v4, kCFNumberDoubleType, &valuePtr);
    double v14 = valuePtr.f64[0];
LABEL_50:
    valuePtr.f64[0] = v14;
    p_float64x2_t valuePtr = &valuePtr;
    uint64_t v12 = 1;
    return (int8x16_t *)CA::Render::Vector::new_vector((CA::Render::Vector *)v12, p_valuePtr, v7);
  }
  if (v5 == CA::Render::BOOL_type)
  {
    double v14 = 0.0;
    if ((__CFString *)*MEMORY[0x1E4F1CFC8] != v4) {
      double v14 = 1.0;
    }
    goto LABEL_50;
  }
  if (v5 == CA::Render::string_type)
  {
    return (int8x16_t *)CA::Render::String::new_string(v4, (const __CFString *)v6);
  }
  else if (v5 == CA::Render::array_type)
  {
    return (int8x16_t *)CA::Render::copy_render_array((CA::Render *)v4, a2, (CGColorSpace *)v7);
  }
  else if (v5 == CA::Render::render_object_type)
  {
    cf = (int8x16_t *)v4->data;
    if (cf)
    {
      int8x8_t v15 = &cf->i32[2];
      if (!atomic_fetch_add(&cf->i32[2], 1u))
      {
        cf = 0;
        atomic_fetch_add(v15, 0xFFFFFFFF);
      }
    }
  }
  else
  {
    if (![(__CFString *)v4 conformsToProtocol:&unk_1ED071770]) {
      return 0;
    }
    cf = (int8x16_t *)x_mem_alloc0(0x70uLL);
    if (cf) {
      return (int8x16_t *)CA::Render::MetalTexture::MetalTexture((CA::Render::MetalTexture *)cf, (objc_object *)v4);
    }
  }
  return cf;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::name(CA::OGL::MetalContext::FragmentShader::Spec *this)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  int v2 = NSString;
  memset(v29, 0, sizeof(v29));
  unsigned int v3 = (CA::OGL::MetalContext::FragmentShader::Spec *)((char *)this + 14);
  unsigned int v4 = (char *)v29;
  uint64_t v5 = *((unsigned char *)this + 14) & 0x7F;
  if ((*((unsigned char *)this + 14) & 0x7F) != 0)
  {
    LOBYTE(v29[0]) = 84;
    if (v5 > 0x66)
    {
      snprintf((char *)v29 + 1, 4uLL, "%03d", v5);
    }
    else
    {
      unsigned int v6 = CA::OGL::MetalContext::TextureFunction_codes[v5];
      __int16 v7 = *(_WORD *)v6;
      BYTE3(v29[0]) = v6[2];
      *(_WORD *)((char *)v29 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v7;
    }
    unsigned int v4 = (char *)v29 + 4;
  }
  uint64_t v8 = *((unsigned char *)this + 15) & 0x3F;
  if (v8 != 58)
  {
    *unsigned int v4 = 66;
    unint64_t v9 = v4 + 1;
    if (v8 > 0x3A)
    {
      snprintf(v9, 4uLL, "%03d", v8);
    }
    else
    {
      char v10 = CA::OGL::MetalContext::BlendFunction_codes[v8];
      __int16 v11 = *(_WORD *)v10;
      v4[3] = v10[2];
      *(_WORD *)unint64_t v9 = v11;
    }
    v4 += 4;
  }
  char v12 = *((unsigned char *)this + 16);
  if ((v12 & 7) != 0)
  {
    *unsigned int v4 = 68;
    char v13 = v4 + 1;
    uint64_t v14 = *((unsigned char *)this + 16) & 7;
    if (v14 > 4) {
      snprintf(v13, 3uLL, "%02d", *((unsigned char *)this + 16) & 7);
    }
    else {
      *(_WORD *)char v13 = *(_WORD *)CA::OGL::MetalContext::DestinationFunction_codes[v14];
    }
    v4 += 3;
    char v12 = *((unsigned char *)this + 16);
  }
  if ((v12 & 0x60) != 0x20)
  {
    *unsigned int v4 = 65;
    v4[1] = *CA::OGL::MetalContext::int_codes[((unint64_t)*((unsigned __int8 *)this + 16) >> 5) & 3];
    v4 += 2;
  }
  if ((*(_WORD *)((unsigned char *)this + 17) & 3) != 0)
  {
    *unsigned int v4 = 83;
    v4[1] = *CA::OGL::MetalContext::int_codes[*(_WORD *)((unsigned char *)this + 17) & 3];
    v4 += 2;
  }
  if ((*((unsigned char *)this + 16) & 0x18) != 0)
  {
    *unsigned int v4 = 76;
    int8x8_t v15 = v4 + 1;
    unint64_t v16 = ((unint64_t)*((unsigned __int8 *)this + 16) >> 3) & 3;
    if (v16 == 3) {
      snprintf(v15, 3uLL, "%02d", 3);
    }
    else {
      *(_WORD *)int8x8_t v15 = *(_WORD *)CA::OGL::MetalContext::VertexLayout_codes[v16];
    }
    v4 += 3;
  }
  *unsigned int v4 = 0;
  double v17 = v4 + 1;
  __int16 v18 = *(_WORD *)((char *)this + 17);
  if ((v18 & 4) != 0)
  {
    *(_WORD *)unsigned int v4 = 26456;
    double v17 = v4 + 2;
    __int16 v18 = *(_WORD *)((char *)this + 17);
    if ((v18 & 0x10) == 0)
    {
LABEL_27:
      if ((v18 & 0x20) == 0) {
        goto LABEL_28;
      }
      goto LABEL_46;
    }
  }
  else if ((v18 & 0x10) == 0)
  {
    goto LABEL_27;
  }
  *unsigned int v4 = 88;
  *v17++ = 104;
  __int16 v18 = *(_WORD *)((char *)this + 17);
  if ((v18 & 0x20) == 0)
  {
LABEL_28:
    if ((v18 & 0x800) == 0) {
      goto LABEL_29;
    }
    goto LABEL_47;
  }
LABEL_46:
  *unsigned int v4 = 88;
  *v17++ = 102;
  __int16 v18 = *(_WORD *)((char *)this + 17);
  if ((v18 & 0x800) == 0)
  {
LABEL_29:
    if ((v18 & 0x40) == 0) {
      goto LABEL_30;
    }
    goto LABEL_48;
  }
LABEL_47:
  *unsigned int v4 = 88;
  *v17++ = 99;
  __int16 v18 = *(_WORD *)((char *)this + 17);
  if ((v18 & 0x40) == 0)
  {
LABEL_30:
    if ((v18 & 0x80) == 0) {
      goto LABEL_31;
    }
    goto LABEL_49;
  }
LABEL_48:
  *unsigned int v4 = 88;
  *v17++ = 120;
  __int16 v18 = *(_WORD *)((char *)this + 17);
  if ((v18 & 0x80) == 0)
  {
LABEL_31:
    if ((v18 & 0x100) == 0) {
      goto LABEL_32;
    }
    goto LABEL_50;
  }
LABEL_49:
  *unsigned int v4 = 88;
  *v17++ = 117;
  __int16 v18 = *(_WORD *)((char *)this + 17);
  if ((v18 & 0x100) == 0)
  {
LABEL_32:
    if ((v18 & 0x200) == 0) {
      goto LABEL_33;
    }
    goto LABEL_51;
  }
LABEL_50:
  *unsigned int v4 = 88;
  *v17++ = 112;
  __int16 v18 = *(_WORD *)((char *)this + 17);
  if ((v18 & 0x200) == 0)
  {
LABEL_33:
    if ((v18 & 0x400) == 0) {
      goto LABEL_34;
    }
    goto LABEL_52;
  }
LABEL_51:
  *unsigned int v4 = 88;
  *v17++ = 101;
  __int16 v18 = *(_WORD *)((char *)this + 17);
  if ((v18 & 0x400) == 0)
  {
LABEL_34:
    if ((v18 & 8) == 0) {
      goto LABEL_35;
    }
    goto LABEL_53;
  }
LABEL_52:
  *unsigned int v4 = 88;
  *v17++ = 115;
  __int16 v18 = *(_WORD *)((char *)this + 17);
  if ((v18 & 8) == 0)
  {
LABEL_35:
    if ((v18 & 0x1000) == 0) {
      goto LABEL_36;
    }
    goto LABEL_54;
  }
LABEL_53:
  *unsigned int v4 = 88;
  *v17++ = 110;
  __int16 v18 = *(_WORD *)((char *)this + 17);
  if ((v18 & 0x1000) == 0)
  {
LABEL_36:
    if ((v18 & 0x2000) == 0) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }
LABEL_54:
  *unsigned int v4 = 88;
  *v17++ = 108;
  if ((*(_WORD *)((unsigned char *)this + 17) & 0x2000) != 0)
  {
LABEL_37:
    *unsigned int v4 = 88;
    *v17++ = 114;
  }
LABEL_38:
  if (!*v4) {
    double v17 = v4;
  }
  *double v17 = 0;
  uint64_t v19 = [NSString stringWithUTF8String:v29];
  uint64_t v20 = *(unsigned char *)v3 & 0x7F;
  int v21 = CA::OGL::tex_image_count[v20];
  if (!CA::OGL::tex_image_count[v20])
  {
    unint64_t v24 = &stru_1ED039300;
    unint64_t v25 = "";
    long long v22 = &stru_1ED039300;
    unint64_t v23 = &stru_1ED039300;
    uint8x8_t v26 = "";
    goto LABEL_60;
  }
  long long v22 = (__CFString *)CA::OGL::MetalContext::FragmentShader::Spec::Image::encode_segment(this);
  if (CA::OGL::tex_image_count[*((unsigned char *)this + 14) & 0x7F] < 2u)
  {
    unint64_t v25 = "";
    unint64_t v24 = &stru_1ED039300;
    unint64_t v23 = &stru_1ED039300;
    goto LABEL_58;
  }
  unint64_t v23 = (__CFString *)CA::OGL::MetalContext::FragmentShader::Spec::Image::encode_segment((CA::OGL::MetalContext::FragmentShader::Spec *)((char *)this + 7));
  if (CA::OGL::tex_image_count[*((unsigned char *)this + 14) & 0x7F] >= 3u)
  {
    unint64_t v24 = (__CFString *)CA::OGL::MetalContext::FragmentShader::Spec::Image::encode_segment(v3);
    unint64_t v25 = "_";
LABEL_58:
    uint8x8_t v26 = v25;
    goto LABEL_60;
  }
  uint8x8_t v26 = "_";
  unint64_t v25 = "";
  unint64_t v24 = &stru_1ED039300;
LABEL_60:
  if (v21) {
    unint64_t v27 = "_";
  }
  else {
    unint64_t v27 = "";
  }
  return [v2 stringWithFormat:@"%@%s%@%s%@%s%@", v19, v27, v22, v26, v23, v25, v24];
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::encode_segment(CA::OGL::MetalContext::FragmentShader::Spec::Image *this)
{
  *(void *)&v28[29] = *MEMORY[0x1E4F143B8];
  memset(v28, 0, 29);
  char v27 = 73;
  unint64_t v2 = *(unsigned int *)this | ((unint64_t)(*((unsigned __int16 *)this + 2) | (*((unsigned __int8 *)this + 6) << 16)) << 32);
  unsigned int v3 = *(_DWORD *)this & 0x3F;
  if (v3 > 0x29)
  {
    snprintf(v28, 4uLL, "%03d", *(_DWORD *)this & 0x3F);
    unint64_t v2 = *(unsigned int *)this | ((unint64_t)(*((unsigned __int16 *)this + 2) | (*((unsigned __int8 *)this + 6) << 16)) << 32);
  }
  else
  {
    unsigned int v4 = CA::OGL::MetalContext::ImageFunction_codes[v3];
    __int16 v5 = *(_WORD *)v4;
    v28[2] = v4[2];
    *(_WORD *)double v28 = v5;
  }
  if ((v2 & 0x1C0) != 0)
  {
    _OWORD v28[3] = 67;
    unsigned int v6 = (v2 >> 6) & 7;
    if (v6 > 5)
    {
      snprintf(&v28[4], 3uLL, "%02d", (v2 >> 6) & 7);
      unint64_t v2 = *(unsigned int *)this | ((unint64_t)(*((unsigned __int16 *)this + 2) | (*((unsigned __int8 *)this + 6) << 16)) << 32);
    }
    else
    {
      *(_WORD *)&v28[4] = *(_WORD *)CA::OGL::MetalContext::CoordFunction_codes[v6];
    }
    __int16 v7 = &v28[6];
  }
  else
  {
    __int16 v7 = &v28[3];
  }
  if ((v2 & 0x1E00) != 0)
  {
    *__int16 v7 = 70;
    uint64_t v8 = v7 + 1;
    unsigned int v9 = (v2 >> 9) & 0xF;
    if (v9 > 0xB)
    {
      snprintf(v8, 3uLL, "%02d", (v2 >> 9) & 0xF);
      unint64_t v2 = *(unsigned int *)this | ((unint64_t)(*((unsigned __int16 *)this + 2) | (*((unsigned __int8 *)this + 6) << 16)) << 32);
    }
    else
    {
      *(_WORD *)uint64_t v8 = *(_WORD *)CA::OGL::MetalContext::TextureFilter_codes[v9];
    }
    v7 += 3;
  }
  if (((uint64_t)(__int16)v2 >> 13) != -1)
  {
    *__int16 v7 = 77;
    v7[1] = **(char **)((char *)CA::OGL::MetalContext::int_codes
                      + (((8 * ((uint64_t)((unint64_t)*(unsigned int *)this << 48) >> 8)) >> 53) & 0xFFFFFFFFFFFFFFF8));
    v7 += 2;
    unint64_t v2 = *(unsigned int *)this | ((unint64_t)(*((unsigned __int16 *)this + 2) | (*((unsigned __int8 *)this + 6) << 16)) << 32);
  }
  if ((v2 & 0x70000) != 0)
  {
    *__int16 v7 = 78;
    char v10 = v7 + 1;
    unsigned int v11 = HIWORD(*(_DWORD *)this) & 7;
    if (v11 > 3) {
      snprintf(v10, 2uLL, "%01d", HIWORD(*(_DWORD *)this) & 7);
    }
    else {
      char *v10 = *CA::OGL::MetalContext::int_codes[v11];
    }
    v7 += 2;
    unint64_t v2 = *(unsigned int *)this | ((unint64_t)(*((unsigned __int16 *)this + 2) | (*((unsigned __int8 *)this + 6) << 16)) << 32);
  }
  if ((v2 & 0x1FFFFFFF80000) != 0)
  {
    *__int16 v7 = 79;
    char v12 = v7 + 1;
    unsigned int v13 = (*(_DWORD *)this >> 19) & 0x1F;
    if (v13 > 0x14) {
      snprintf(v12, 3uLL, "%02d", (*(_DWORD *)this >> 19) & 0x1F);
    }
    else {
      *(_WORD *)char v12 = *(_WORD *)CA::OGL::MetalContext::Opcode_codes[v13];
    }
    uint64_t v14 = v7 + 3;
    unsigned int v15 = HIBYTE(*(_DWORD *)this) & 0x1F;
    if (v15 > 0x14) {
      snprintf(v14, 3uLL, "%02d", HIBYTE(*(_DWORD *)this) & 0x1F);
    }
    else {
      *(_WORD *)uint64_t v14 = *(_WORD *)CA::OGL::MetalContext::Opcode_codes[v15];
    }
    unint64_t v16 = v7 + 5;
    if ((((*(unsigned int *)this | ((unint64_t)(*((unsigned __int16 *)this + 2) | (*((unsigned __int8 *)this + 6) << 16)) << 32)) >> 29) & 0x1F) > 0x14) {
      snprintf(v16, 3uLL, "%02d", ((*(unsigned int *)this | ((unint64_t)(*((unsigned __int16 *)this + 2) | (*((unsigned __int8 *)this + 6) << 16)) << 32)) >> 29) & 0x1F);
    }
    else {
      *(_WORD *)unint64_t v16 = *(_WORD *)CA::OGL::MetalContext::Opcode_codes[((*(unsigned int *)this | ((unint64_t)(*((unsigned __int16 *)this + 2) | (*((unsigned __int8 *)this + 6) << 16)) << 32)) >> 29) & 0x1F];
    }
    double v17 = v7 + 7;
    unsigned int v18 = *((unsigned __int16 *)this + 2);
    unsigned int v19 = (v18 >> 2) & 0x1F;
    if (v19 > 0x14) {
      snprintf(v17, 3uLL, "%02d", ((*(unsigned int *)this | ((unint64_t)(v18 | (*((unsigned __int8 *)this + 6) << 16)) << 32)) >> 34) & 0x1F);
    }
    else {
      *(_WORD *)double v17 = *(_WORD *)CA::OGL::MetalContext::Opcode_codes[v19];
    }
    uint64_t v20 = v7 + 9;
    unsigned int v21 = *((unsigned __int16 *)this + 2);
    unsigned int v22 = (v21 >> 7) & 0x1F;
    if (v22 > 0x14) {
      snprintf(v20, 3uLL, "%02d", ((*(unsigned int *)this | ((unint64_t)(v21 | (*((unsigned __int8 *)this + 6) << 16)) << 32)) >> 39) & 0x1F);
    }
    else {
      *(_WORD *)uint64_t v20 = *(_WORD *)CA::OGL::MetalContext::Opcode_codes[v22];
    }
    unint64_t v23 = v7 + 11;
    uint64_t v24 = *((unsigned __int16 *)this + 2) | (*((unsigned __int8 *)this + 6) << 16);
    unsigned int v25 = (v24 >> 12) & 0x1F;
    if (v25 > 0x14) {
      snprintf(v23, 3uLL, "%02d", ((*(unsigned int *)this | (unint64_t)(v24 << 32)) >> 44) & 0x1F);
    }
    else {
      *(_WORD *)unint64_t v23 = *(_WORD *)CA::OGL::MetalContext::Opcode_codes[v25];
    }
    v7 += 13;
  }
  *__int16 v7 = 0;
  if (((*(unsigned int *)this | ((unint64_t)(*((unsigned __int16 *)this + 2) | (*((unsigned __int8 *)this + 6) << 16)) << 32)) & 0x2000000000000) != 0)
  {
    *(_WORD *)__int16 v7 = 29016;
    v7 += 2;
  }
  *__int16 v7 = 0;
  return [NSString stringWithUTF8String:&v27];
}

unint64_t CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::FragmentShader::Spec>::operator()(unsigned __int8 *a1)
{
  uint64_t v1 = 0xB492B66FBE98F273;
  unint64_t v2 = 19;
  unsigned int v3 = a1;
  do
  {
    uint64_t v4 = *(void *)v3;
    v3 += 8;
    uint64_t v1 = 5 * __ROR8__((461845907 * ((0xCBE41013C0000000 * v4) | ((0x9AE16A3B2F90404FLL * v4) >> 34))) ^ v1, 38)
       + 3864292196;
    v2 -= 8;
  }
  while (v2 > 7);
  unint64_t v5 = ((unint64_t)a1[18] << 16) | ((unint64_t)a1[17] << 8) | a1[16];
  uint64_t v6 = __ROR8__((461845907 * ((0xCBE41013C0000000 * v5) | ((0x9AE16A3B2F90404FLL * v5) >> 34))) ^ v1, 38);
  unint64_t v7 = 0xBF58476D1CE4E5B9 * ((5 * v6 + 3864292196) ^ ((unint64_t)(5 * v6 + 3864292196) >> 30) ^ 0x18);
  return (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
}

os_signpost_id_t CA::OGL::MetalContext::begin_new_render_pipeline(CA::OGL::MetalContext *this, NSString *a2, uint64_t a3)
{
  int v4 = (int)a2;
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t add = atomic_fetch_add(CA::OGL::MetalContext::_next_pipeline_id, 1u);
  if (CA::OGL::MetalContext::get_pipeline_log(void)::pipeline_once != -1) {
    dispatch_once(&CA::OGL::MetalContext::get_pipeline_log(void)::pipeline_once, &__block_literal_global_307);
  }
  unint64_t v7 = CA::OGL::MetalContext::get_pipeline_log(void)::pipeline_log;
  if (a3)
  {
    if (add && os_signpost_enabled((os_log_t)CA::OGL::MetalContext::get_pipeline_log(void)::pipeline_log))
    {
      int v15 = 138543874;
      unint64_t v16 = this;
      __int16 v17 = 1026;
      int v18 = add;
      __int16 v19 = 2050;
      uint64_t v20 = a3;
      _os_signpost_emit_unreliably_with_name_impl();
    }
  }
  else if (add && os_signpost_enabled((os_log_t)CA::OGL::MetalContext::get_pipeline_log(void)::pipeline_log))
  {
    int v15 = 138543618;
    unint64_t v16 = this;
    __int16 v17 = 1026;
    int v18 = add;
    _os_signpost_emit_with_name_impl(&dword_184668000, v7, OS_SIGNPOST_INTERVAL_BEGIN, add, "NewRenderPipeline", "pipeline=%{public, name=pipeline, signpost.telemetry:string1}@ order=%{public, name=order, signpost.telemetry:number1}u enableTelemetry=YES ", (uint8_t *)&v15, 0x12u);
  }
  if (v4)
  {
    if (a3)
    {
      if (CA::OGL::MetalContext::get_pipeline_stall_log(void)::pipeline_stall_once[0] == -1)
      {
        if (!add) {
          return add;
        }
      }
      else
      {
        dispatch_once(CA::OGL::MetalContext::get_pipeline_stall_log(void)::pipeline_stall_once, &__block_literal_global_310);
        if (!add) {
          return add;
        }
      }
      uint64_t v8 = CA::OGL::MetalContext::get_pipeline_stall_log(void)::pipeline_stall_log;
      if (!os_signpost_enabled((os_log_t)CA::OGL::MetalContext::get_pipeline_stall_log(void)::pipeline_stall_log)) {
        return add;
      }
      int v15 = 138543874;
      unint64_t v16 = this;
      __int16 v17 = 1026;
      int v18 = add;
      __int16 v19 = 2050;
      uint64_t v20 = a3;
      unsigned int v9 = "pipeline=%{public, name=pipeline}@ order=%{public, name=order}u %{public, signpost.description:begin_time}llu";
      char v10 = v8;
      os_signpost_id_t v11 = add;
      uint32_t v12 = 28;
LABEL_22:
      _os_signpost_emit_with_name_impl(&dword_184668000, v10, OS_SIGNPOST_INTERVAL_BEGIN, v11, "NewRenderPipeline", v9, (uint8_t *)&v15, v12);
      return add;
    }
    if (CA::OGL::MetalContext::get_pipeline_stall_log(void)::pipeline_stall_once[0] == -1)
    {
      if (!add) {
        return add;
      }
    }
    else
    {
      dispatch_once(CA::OGL::MetalContext::get_pipeline_stall_log(void)::pipeline_stall_once, &__block_literal_global_310);
      if (!add) {
        return add;
      }
    }
    uint64_t v13 = CA::OGL::MetalContext::get_pipeline_stall_log(void)::pipeline_stall_log;
    if (!os_signpost_enabled((os_log_t)CA::OGL::MetalContext::get_pipeline_stall_log(void)::pipeline_stall_log)) {
      return add;
    }
    int v15 = 138543618;
    unint64_t v16 = this;
    __int16 v17 = 1026;
    int v18 = add;
    unsigned int v9 = "pipeline=%{public, name=pipeline}@ order=%{public, name=order}u";
    char v10 = v13;
    os_signpost_id_t v11 = add;
    uint32_t v12 = 18;
    goto LABEL_22;
  }
  return add;
}

_DWORD *copyFloatVector(NSArray *a1, BOOL *a2)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  NSUInteger v4 = [(NSArray *)a1 count];
  if (v4)
  {
    unint64_t v5 = (CA::Render::Vector *)v4;
    size_t v6 = 8 * v4;
    if (8 * v4 > 0x1000)
    {
      unint64_t v7 = malloc_type_malloc(8 * v4, 0xBCACFBC6uLL);
    }
    else
    {
      MEMORY[0x1F4188790](v4);
      unint64_t v7 = (void *)((char *)v16 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
      bzero(v7, v6);
    }
    objc_msgSend(-[NSArray objectAtIndex:](a1, "objectAtIndex:", 0), "doubleValue");
    *unint64_t v7 = v10;
    if ((unint64_t)v5 < 2)
    {
      char v12 = 1;
      if (a2) {
LABEL_11:
      }
        *a2 = v12;
    }
    else
    {
      os_signpost_id_t v11 = 0;
      char v12 = 1;
      do
      {
        objc_msgSend(-[NSArray objectAtIndex:](a1, "objectAtIndex:", (char *)v11 + 1), "doubleValue");
        uint64_t v13 = (double *)&v7[(void)v11];
        v13[1] = v14;
        v12 &= v14 >= *v13;
        os_signpost_id_t v11 = (CA::Render::Vector *)((char *)v11 + 1);
      }
      while ((CA::Render::Vector *)((char *)v5 - 1) != v11);
      if (a2) {
        goto LABEL_11;
      }
    }
    uint64_t v8 = CA::Render::Vector::new_vector(v5, v7, v9);
    if (v6 > 0x1000) {
      free(v7);
    }
    return v8;
  }
  uint64_t v8 = 0;
  if (a2) {
    *a2 = 1;
  }
  return v8;
}

unint64_t CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::VertexShader::Spec>::operator()(unsigned int *a1)
{
  uint64_t v1 = __ROR8__((461845907 * ((0xCBE41013C0000000 * *a1) | ((0x9AE16A3B2F90404FLL * *a1) >> 34))) ^ 0xB492B66FBE98F273, 38);
  unint64_t v2 = 0xBF58476D1CE4E5B9 * ((5 * v1 + 3864292196) ^ ((unint64_t)(5 * v1 + 3864292196) >> 30) ^ 8);
  return (0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31);
}

void CA::Render::ShapeLayer::~ShapeLayer(CA::Render::ShapeLayer *this, const CA::Render::Object *a2)
{
  CA::Render::ShapeLayer::~ShapeLayer(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  atomic_uint *v4;
  atomic_uint *v5;
  atomic_uint *v6;
  atomic_uint *v7;
  atomic_uint *v8;

  *(void *)this = &unk_1ED02CCD8;
  unsigned int v3 = (atomic_uint *)*((void *)this + 17);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  NSUInteger v4 = (atomic_uint *)*((void *)this + 16);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  unint64_t v5 = (atomic_uint *)*((void *)this + 14);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  size_t v6 = (atomic_uint *)*((void *)this + 8);
  if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
  }
  unint64_t v7 = (atomic_uint *)*((void *)this + 5);
  if (v7 && atomic_fetch_add(v7 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v7 + 16))(v7);
  }
  uint64_t v8 = (atomic_uint *)*((void *)this + 2);
  if (v8 && atomic_fetch_add(v8 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v8 + 16))(v8);
  }
  --dword_1EB2ADE80;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

void CA::Render::Path::finalize(CA::Render::Path *this)
{
  CA::Render::post_notification(0xAu, (unint64_t)this, 0, 1);
  if (*((void *)this + 6)) {
    BOOL v2 = CA::Render::Path::_path_table == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Path::_path_lock);
    x_hash_table_remove(CA::Render::Path::_path_table, *((void *)this + 6));
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Path::_path_lock);
  }
  (**(void (***)(CA::Render::Path *))this)(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::Render::Path::~Path(CA::Render::Path *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02F0E0;
  unsigned int v3 = (void *)*((void *)this + 8);
  if (v3)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v3);
  }
  unint64_t v5 = (const CGPath *)*((void *)this + 7);
  if (v5) {
    CGPathRelease(v5);
  }
  --dword_1EB2ADE58;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

{
  malloc_zone_t *malloc_zone;
  uint64_t vars8;

  CA::Render::Path::~Path(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

uint64_t ___ZN2CA3OGL12MetalContext27tile_calculate_average_lumaEPNS0_7SurfaceEU13block_pointerFvfE_block_invoke(uint64_t a1)
{
  unint64_t v2 = *(unsigned int *)(a1 + 48);
  uint64_t v3 = [*(id *)(a1 + 32) contents];
  if ((int)v2 < 8)
  {
    int32x4_t v6 = 0uLL;
    int32x4_t v7 = 0uLL;
    int32x4_t v8 = 0uLL;
    int32x4_t v9 = 0uLL;
  }
  else
  {
    NSUInteger v4 = (float32x4_t *)(v3 + *(unsigned int *)(a1 + 52));
    unint64_t v5 = v2 >> 3;
    int32x4_t v6 = 0uLL;
    int32x4_t v7 = 0uLL;
    int32x4_t v8 = 0uLL;
    int32x4_t v9 = 0uLL;
    do
    {
      float32x4_t v11 = v4[2];
      float32x4_t v10 = v4[3];
      float32x4_t v12 = *v4;
      float32x4_t v13 = v4[1];
      v4 += 4;
      int32x4_t v7 = (int32x4_t)vaddq_f32(v13, (float32x4_t)v7);
      int32x4_t v6 = (int32x4_t)vaddq_f32(v12, (float32x4_t)v6);
      int32x4_t v8 = (int32x4_t)vaddq_f32(v11, (float32x4_t)v8);
      int32x4_t v9 = (int32x4_t)vaddq_f32(v10, (float32x4_t)v9);
      --v5;
    }
    while (v5);
  }
  float32x4_t v14 = vaddq_f32((float32x4_t)vrev64q_s32(vuzp2q_s32(v8, v9)), (float32x4_t)vrev64q_s32(vuzp2q_s32(v6, v7)));
  __n128 v16 = (__n128)vpaddq_f32(v14, v14);
  float v15 = vaddv_f32((float32x2_t)v16.n128_u64[0]);
  v16.n128_u32[0] = -1.0;
  if (v15 > 0.0) {
    v16.n128_f32[0] = (float)(*(float *)(a1 + 56)
  }
                            * (float)((float)((float)((float)(*(float *)v6.i32 + *(float *)&v6.i32[2])
                                                    + (float)(*(float *)&v7.i32[2] + *(float *)v7.i32))
                                            + (float)((float)(*(float *)&v8.i32[2] + *(float *)v8.i32)
                                                    + *(float *)&v9.i32[2]))
                                    + *(float *)v9.i32))
                    / v15;
  __int16 v17 = *(uint64_t (**)(__n128))(*(void *)(a1 + 40) + 16);

  return v17(v16);
}

uint64_t ___ZN2CA19IOMobileFramebuffer10set_matrixE20IOMFB_MatrixLocationPA3_A3_Ky_block_invoke(uint64_t a1)
{
  uint64_t result = IOMobileFramebufferSetMatrix();
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t CASSynchronize(CA::Render::Context *a1, mach_port_name_t a2, int a3, int a4, uint32_t a5, int a6, int a7)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  if (a2 - 1 > 0xFFFFFFFD)
  {
    if (!a2) {
      return 0;
    }
LABEL_13:
    mach_port_deallocate(*MEMORY[0x1E4F14960], a2);
    return 0;
  }
  uint64_t v13 = CA::Render::Context::context_by_server_port(a1);
  if (!v13) {
    goto LABEL_13;
  }
  float32x4_t v14 = (os_unfair_lock_s *)v13;
  if (CADeviceSupportsAndromeda::once != -1) {
    dispatch_once(&CADeviceSupportsAndromeda::once, &__block_literal_global_86);
  }
  if (CADeviceSupportsAndromeda::supports_andromeda)
  {
    if (a7)
    {
      uint32_t os_unfair_lock_opaque = v14[153]._os_unfair_lock_opaque;
      if (os_unfair_lock_opaque)
      {
        v17[0] = os_unfair_lock_opaque;
        CA::Render::post_notification(0x3Eu, 0, (uint64_t)v17, 0);
        if (BYTE4(v17[0])) {
          a3 = 0;
        }
      }
    }
  }
  CA::Render::Context::request_synchronize(v14, a2, a3, a4, a5, a6);
  if (atomic_fetch_add((atomic_uint *volatile)&v14[2], 0xFFFFFFFF) == 1) {
    (*(void (**)(os_unfair_lock_s *))(*(void *)&v14->_os_unfair_lock_opaque + 16))(v14);
  }
  return 0;
}

void CA::Render::Context::request_synchronize(os_unfair_lock_s *this, mach_port_name_t name, int a3, int a4, uint32_t a5, int a6)
{
  block[6] = *MEMORY[0x1E4F143B8];
  if (name + 1 <= 1) {
    __assert_rtn("request_synchronize", "render-context.cpp", 1634, "MACH_PORT_VALID (port)");
  }
  if ((this[3]._os_unfair_lock_opaque & 0x400) == 0)
  {
    os_unfair_lock_lock(this + 13);
    unsigned int os_unfair_lock_opaque = this[16]._os_unfair_lock_opaque;
    if (a3)
    {
      if (os_unfair_lock_opaque >= a5 && a6)
      {
        if (this[17]._os_unfair_lock_opaque < a5 && this[88]._os_unfair_lock_opaque) {
          goto LABEL_8;
        }
      }
      else if (os_unfair_lock_opaque < a5)
      {
LABEL_8:
        if (CA::Render::sync_hang_report_level(void)::onceToken[0] != -1) {
          dispatch_once(CA::Render::sync_hang_report_level(void)::onceToken, &__block_literal_global_4151);
        }
        if (a3 > 0 || CA::Render::sync_hang_report_level(void)::level)
        {
          uint64_t v16 = mach_absolute_time();
          double v17 = CATimeWithHostTime(v16);
          if (a3 < 1)
          {
            double v20 = v17 + 5.0;
            int64_t v19 = 5000000000;
            double v13 = INFINITY;
            double v14 = v17 + 5.0;
          }
          else
          {
            if (a3 >= 5000) {
              int v18 = 5000;
            }
            else {
              int v18 = a3;
            }
            double v13 = v17 + (double)v18 * 0.001;
            int64_t v19 = 1000000 * v18;
            double v14 = INFINITY;
            double v20 = v13;
          }
          uint64_t v21 = (CA::Render::Context *)this;
          if (!atomic_fetch_add((atomic_uint *volatile)&this[2], 1u))
          {
            uint64_t v21 = 0;
            atomic_fetch_add((atomic_uint *volatile)&this[2], 0xFFFFFFFF);
          }
          if (!CA::Render::Server::_thread
            || (CA::Render::Server::add_callback(0, (uint64_t)CA::Render::sync_req_timeout, (uint64_t)v21, v20) & 1) == 0)
          {
            global_queue = dispatch_get_global_queue(33, 0);
            dispatch_time_t v23 = dispatch_time(0, v19);
            block[0] = MEMORY[0x1E4F143A8];
            block[1] = 0x40000000;
            block[2] = ___ZN2CA6Render7Context19request_synchronizeEjijjb_block_invoke;
            block[3] = &__block_descriptor_tmp_4168;
            *(double *)&block[4] = v20;
            void block[5] = v21;
            dispatch_after(v23, global_queue, block);
          }
        }
        else
        {
          double v13 = INFINITY;
          double v14 = INFINITY;
        }
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        unsigned int v25 = (double *)malloc_type_zone_malloc(malloc_zone, 0x30uLL, 0x8BB15036uLL);
        *unsigned int v25 = *(double *)&this[14]._os_unfair_lock_opaque;
        *((_DWORD *)v25 + 2) = name;
        v25[2] = v14;
        void v25[3] = v13;
        *((_DWORD *)v25 + 8) = a4;
        *((_DWORD *)v25 + 9) = a5;
        *((unsigned char *)v25 + 4CA::Context::unref(this[1], 0) = a6;
        *(void *)&this[14]._unsigned int os_unfair_lock_opaque = v25;
        goto LABEL_30;
      }
    }
    CA::Render::send_synchronize_reply((CA::Render *)this[4]._os_unfair_lock_opaque, name, a4, os_unfair_lock_opaque, this[17]._os_unfair_lock_opaque);
LABEL_30:
    os_unfair_lock_unlock(this + 13);
    return;
  }
  ipc_space_t v15 = *MEMORY[0x1E4F14960];

  mach_port_deallocate(v15, name);
}

void CA::Render::send_synchronize_reply(CA::Render *this, mach_port_t a2, int a3, int a4, int a5)
{
  mach_msg_return_t v6;
  mach_msg_return_t v7;
  NSObject *v8;
  mach_msg_header_t msg;
  int v10;
  int v11;
  int v12;
  uint8_t buf[4];
  mach_msg_return_t v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  int v5 = (int)this;
  double v17 = *MEMORY[0x1E4F143B8];
  *(void *)&msg.msgh_bits = 0x2400000012;
  msg.msgh_remote_port = a2;
  msg.msgh_local_port = 0;
  msg.msgh_voucher_port = 0;
  msg.mach_msg_id_t msgh_id = 1937337955;
  float32x4_t v10 = a3;
  float32x4_t v11 = a4;
  float32x4_t v12 = a5;
  int32x4_t v6 = mach_msg(&msg, 1, 0x24u, 0, 0, 0, 0);
  if (v6)
  {
    int32x4_t v7 = v6;
    if (v6 == 268435459)
    {
      mach_msg_destroy(&msg);
    }
    else
    {
      if (CA::Render::sync_hang_report_level(void)::onceToken[0] != -1) {
        dispatch_once(CA::Render::sync_hang_report_level(void)::onceToken, &__block_literal_global_4151);
      }
      if (CA::Render::sync_hang_report_level(void)::level == 3)
      {
        x_log_crash("unexpected error %i sending sync reply from %x", v7, v5);
        abort();
      }
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int32x4_t v8 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)long long buf = 67109376;
          double v14 = v7;
          ipc_space_t v15 = 1024;
          uint64_t v16 = v5;
          _os_log_impl(&dword_184668000, v8, OS_LOG_TYPE_FAULT, "unexpected error %i sending sync reply from %x", buf, 0xEu);
        }
      }
    }
  }
}

uint64_t CA::OGL::Renderer::collect(CA::OGL::Renderer *this, const CA::Render::Update *a2, double a3)
{
  uint64_t v5 = *(void *)this;
  if (a2)
  {
    int v6 = *((_DWORD *)a2 + 64);
    *(_DWORD *)(v5 + 228) = *((_DWORD *)a2 + 62);
    *(_DWORD *)(v5 + 232) = v6;
    CA::Render::Update::release_objects(a2);
    uint64_t v5 = *(void *)this;
  }
  else
  {
    *(void *)(v5 + 228) = -1;
  }
  *(double *)(v5 + 24CA::Context::unref(this[1], 0) = a3;
  int32x4_t v7 = *(uint64_t (**)(void))(*(void *)v5 + 216);

  return v7();
}

float CADisplayGetPotentialHeadroom(uint32_t a1)
{
  pthread_mutex_lock(&_edr_states_lock);
  unint64_t v2 = edr_state_for_display(a1);
  uint64_t v3 = v2;
  if (v2)
  {
    os_unfair_lock_lock(v2 + 1);
    uint64_t v4 = *(void *)&v3[4]._os_unfair_lock_opaque;
    if (v4)
    {
      unsigned int v5 = atomic_load((unsigned int *)(v4 + 4));
      float v6 = *(float *)&v5;
    }
    else
    {
      float v6 = 1.0;
    }
    os_unfair_lock_unlock(v3 + 1);
  }
  else
  {
    float v6 = 1.0;
  }
  pthread_mutex_unlock(&_edr_states_lock);
  return v6;
}

void sub_18479D7B0(_Unwind_Exception *a1)
{
}

os_unfair_lock_s *edr_state_for_display(uint32_t a1)
{
  mach_msg_return_t v7;
  mach_port_name_t v9;
  atomic_uint *v10;
  malloc_zone_t *malloc_zone;
  os_unfair_lock_s *v12;
  os_unfair_lock_s *v13;
  atomic_uint *v14;
  atomic_uint *v15;
  atomic_uint *v16;
  uint64_t v17;
  unint64_t v18;
  os_unfair_lock_s **v19;
  void *v20;
  os_unfair_lock_s **v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  int msg;
  unsigned char msg_4[60];
  uint64_t v31;

  long long v31 = *MEMORY[0x1E4F143B8];
  if (!_edr_states) {
    operator new();
  }
  for (uint64_t i = *(os_unfair_lock_s ***)_edr_states; i != *(os_unfair_lock_s ***)(_edr_states + 8); ++i)
  {
    uint64_t v3 = *i;
    if ((*i)->_os_unfair_lock_opaque == a1) {
      return v3;
    }
  }
  mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
  if (!ServerPort) {
    return 0;
  }
  mach_port_name_t v5 = ServerPort;
  if (!a1)
  {
LABEL_19:
    mach_port_deallocate(*MEMORY[0x1E4F14960], v5);
    return 0;
  }
  memset(&msg_4[16], 0, 44);
  *(_OWORD *)msg_4 = 0u;
  *(void *)&msg_4[20] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&msg_4[28] = a1;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = v5;
  *(_DWORD *)&msg_4[8] = reply_port;
  msg = 5395;
  *(void *)&msg_4[12] = 0x9D2900000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    mach_port_t reply_port = *(_DWORD *)&msg_4[8];
  }
  int32x4_t v7 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x40u, reply_port, 0, 0);
  if ((v7 - 268435458) <= 0xE && ((1 << (v7 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
    goto LABEL_19;
  }
  if (v7)
  {
    mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
    goto LABEL_19;
  }
  if (*(_DWORD *)&msg_4[16] != 40333
    || (msg & 0x80000000) == 0
    || *(_DWORD *)&msg_4[20] != 1
    || *(_DWORD *)msg_4 != 56
    || *(_DWORD *)&msg_4[4]
    || *(unsigned __int16 *)&msg_4[34] << 16 != 1114112)
  {
    mach_msg_destroy((mach_msg_header_t *)&msg);
    goto LABEL_19;
  }
  int32x4_t v9 = *(_DWORD *)&msg_4[24];
  if (!*(_DWORD *)&msg_4[24] || !*(void *)&msg_4[44]) {
    goto LABEL_19;
  }
  float32x4_t v10 = CA::Render::Shmem::new_shmem(*(mem_entry_name_port_t *)&msg_4[24], *(mach_vm_size_t *)&msg_4[44], 0, 3);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  float32x4_t v12 = (os_unfair_lock_s *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x18uLL, 0x743898A5uLL);
  if (!v12
    || (uint64_t v3 = v12,
        v12->_unsigned int os_unfair_lock_opaque = a1,
        v12[1]._unsigned int os_unfair_lock_opaque = 0,
        double v13 = v12 + 1,
        *(void *)&v12[2]._unsigned int os_unfair_lock_opaque = 0,
        !v10))
  {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v9);
    goto LABEL_19;
  }
  os_unfair_lock_lock(v12 + 1);
  double v14 = *(atomic_uint **)&v3[2]._os_unfair_lock_opaque;
  if (v14)
  {
    *(void *)&v3[2]._unsigned int os_unfair_lock_opaque = 0;
    if (atomic_fetch_add(v14 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v14 + 16))(v14);
    }
    *(void *)&v3[4]._unsigned int os_unfair_lock_opaque = 0;
    ipc_space_t v15 = *(atomic_uint **)&v3[2]._os_unfair_lock_opaque;
    if (v15 == v10) {
      goto LABEL_40;
    }
    if (v15 && atomic_fetch_add(v15 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v15 + 16))(v15);
    }
  }
  uint64_t v16 = v10 + 2;
  if (!atomic_fetch_add(v10 + 2, 1u))
  {
    float32x4_t v10 = 0;
    atomic_fetch_add(v16, 0xFFFFFFFF);
  }
  *(void *)&v3[2]._unsigned int os_unfair_lock_opaque = v10;
LABEL_40:
  *(void *)&v3[4]._unsigned int os_unfair_lock_opaque = *((void *)v10 + 3);
  os_unfair_lock_unlock(v13);
  mach_port_deallocate(*MEMORY[0x1E4F14960], v5);
  double v17 = _edr_states;
  int64_t v19 = *(os_unfair_lock_s ***)(_edr_states + 8);
  int v18 = *(void *)(_edr_states + 16);
  if ((unint64_t)v19 >= v18)
  {
    uint64_t v21 = *(os_unfair_lock_s ***)_edr_states;
    unsigned int v22 = ((uint64_t)v19 - *(void *)_edr_states) >> 3;
    dispatch_time_t v23 = v22 + 1;
    if ((unint64_t)(v22 + 1) >> 61) {
      abort();
    }
    uint64_t v24 = v18 - (void)v21;
    if (v24 >> 2 > v23) {
      dispatch_time_t v23 = v24 >> 2;
    }
    if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
      unsigned int v25 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unsigned int v25 = v23;
    }
    if (v25)
    {
      if (v25 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint8x8_t v26 = (char *)operator new(8 * v25);
    }
    else
    {
      uint8x8_t v26 = 0;
    }
    char v27 = &v26[8 * v22];
    *(void *)char v27 = v3;
    double v20 = v27 + 8;
    if (v19 != v21)
    {
      do
      {
        double v28 = (uint64_t)*--v19;
        *((void *)v27 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v28;
        v27 -= 8;
      }
      while (v19 != v21);
      int64_t v19 = *(os_unfair_lock_s ***)v17;
    }
    *(void *)double v17 = v27;
    *(void *)(v17 + 8) = v20;
    *(void *)(v17 + 16) = &v26[8 * v25];
    if (v19) {
      operator delete(v19);
    }
  }
  else
  {
    CAMetalDrawable *v19 = v3;
    double v20 = v19 + 1;
  }
  *(void *)(v17 + 8) = v20;
  return v3;
}

void sub_18479DBE0(_Unwind_Exception *a1)
{
  mach_port_deallocate(*v2, v1);
  _Unwind_Resume(a1);
}

CA::Render::CompressedImage *CA::Render::CompressedImage::decode(CA::Render::CompressedImage *this, CA::Render::Decoder *a2)
{
  kern_return_t v25;
  const void *v26;
  BOOL v27;
  malloc_zone_t *malloc_zone;
  CA::Render::CompressedImage *v29;
  CA::Render::CompressedImage *v30;
  CA::Render::Texture *v31;
  ipc_space_t *v32;
  NSObject *v33;
  CA::Render::Texture *v34;
  unsigned char v36[12];
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  mach_vm_address_t address;
  BOOL v43;
  _OWORD buf[6];
  long long v45;
  long long v46;
  long long v47;
  long long v48;
  long long v49;
  uint64_t v50;
  uint64_t v51;

  uint64_t v51 = *MEMORY[0x1E4F143B8];
  int v3 = CA::Render::Decoder::decode_int32(this);
  int v4 = CA::Render::Decoder::decode_int32(this);
  int v5 = CA::Render::Decoder::decode_int32(this);
  uint64_t v6 = CA::Render::Decoder::decode_int32(this);
  unsigned int v7 = v6;
  if (v6 >= 0x41)
  {
    CA::Render::Decoder::set_fatal_error(this, "Incorrect CompressedImage levels: %u", v6);
    return 0;
  }
  double v39 = v5;
  uint64_t v40 = v4;
  uint64_t v41 = v3;
  uint64_t v8 = 8 * v6;
  MEMORY[0x1F4188790](v6);
  uint64_t v9 = (v8 + 15) & 0xFFFFFFFF0;
  float32x4_t v10 = (unint64_t *)&v36[-v9];
  bzero(&v36[-v9], 8 * v7);
  MEMORY[0x1F4188790](v11);
  float32x4_t v12 = (unint64_t *)&v36[-v9];
  bzero(&v36[-v9], 8 * v7);
  MEMORY[0x1F4188790](v13);
  double v14 = (unint64_t *)&v36[-v9];
  bzero(&v36[-v9], 8 * v7);
  if (v7)
  {
    ipc_space_t v15 = &v36[-v9];
    uint64_t v16 = &v36[-v9];
    double v17 = v14;
    uint64_t v18 = v7;
    do
    {
      *v15++ = CA::Render::Decoder::decode_size_t(this);
      *v16++ = CA::Render::Decoder::decode_size_t(this);
      *v17++ = CA::Render::Decoder::decode_size_t(this);
      --v18;
    }
    while (v18);
  }
  int v19 = CA::Render::Decoder::decode_int32(this);
  int v20 = CA::Render::Decoder::decode_int32(this);
  int v21 = CA::Render::Decoder::decode_int8(this);
  uint64_t v22 = CA::Render::Decoder::decode_size_t(this);
  unint64_t v43 = 0;
  mem_entry_name_port_t v23 = CA::Render::Decoder::decode_port(this, 17, &v43);
  if (!v23)
  {
    CA::Render::Decoder::set_fatal_error(this, "CompressedImage port is MACH_PORT_NULL!");
    return 0;
  }
  mach_port_name_t v24 = v23;
  unint64_t v37 = v19;
  double v38 = v20;
  address = 0;
  unsigned int v25 = mach_vm_map(*MEMORY[0x1E4F14960], &address, v22, *MEMORY[0x1E4F14AF0], 856686593, v23, 0, 0, 1, 1, 2u);
  uint8x8_t v26 = (const void *)address;
  if (v25) {
    char v27 = 1;
  }
  else {
    char v27 = address == 0;
  }
  if (v27)
  {
    if (CADeviceHasInternalBuild::once[0] != -1) {
      dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
    }
    if (CADeviceHasInternalBuild::internal)
    {
      x_log_crash("Failed to map %ld bytes with port = %u, protection = %u, err = 0x%x\n", v22, v24, 1, v25);
      abort();
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      float v33 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf[0]) = 134218752;
        *(void *)((char *)buf + 4) = v22;
        WORD6(buf[0]) = 1024;
        *(_DWORD *)((char *)buf + 14) = v24;
        WORD1(buf[1]) = 1024;
        DWORD1(buf[1]) = 1;
        WORD4(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 1CA::Context::unref(this[1], 0) = v25;
        _os_log_impl(&dword_184668000, v33, OS_LOG_TYPE_ERROR, "Failed to map %ld bytes with port = %u, protection = %u, err = 0x%x\n", (uint8_t *)buf, 0x1Eu);
      }
    }
    uint64_t v50 = 0;
    double v48 = 0u;
    unint64_t v49 = 0u;
    uint8x8_t v46 = 0u;
    uint64_t v47 = 0u;
    unint64_t v45 = 0u;
    memset(buf, 0, sizeof(buf));
    float v34 = CA::Render::Texture::Texture((CA::Render::Texture *)buf, 0, 0);
    BYTE12(buf[0]) = 9;
    ++dword_1EB2ADDEC;
    *(void *)&buf[0] = &unk_1ED02E030;
    unint64_t v45 = 0u;
    uint8x8_t v46 = 0u;
    uint64_t v47 = 0u;
    double v48 = 0u;
    *(void *)&unint64_t v49 = 0;
    *((void *)&v49 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 2;
    CA::Render::Texture::decode(v34, this);
    CA::Render::Decoder::set_fatal_error(this, "%s - data = NULL", "decode");
    CA::Render::CompressedImage::~CompressedImage((CA::Render::CompressedImage *)buf);
    return 0;
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  unint64_t v29 = (CA::Render::CompressedImage *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xB8uLL, 0x743898A5uLL);
  uint64_t v30 = v29;
  if (v29)
  {
    long long v31 = CA::Render::CompressedImage::CompressedImage(v29, v40, v39, v37, v26, v22, v10, v12, v14, v7, (unint64_t)CA::Render::release_deallocate);
    *((_DWORD *)v30 + 42) = v38;
    *((unsigned char *)v30 + 176) = *((unsigned char *)v30 + 176) & 0xFE | (v21 != 0);
    *((_DWORD *)v30 + 3) |= v41 << 8;
    CA::Render::Texture::decode(v31, this);
    long long v32 = (ipc_space_t *)MEMORY[0x1E4F14960];
  }
  else
  {
    CA::Render::Decoder::set_fatal_error(this, "Failed to decode CompressedImage from data ptr: %p, len: %ld", v26, v22);
    long long v32 = (ipc_space_t *)MEMORY[0x1E4F14960];
    mach_vm_deallocate(*MEMORY[0x1E4F14960], address, v22);
  }
  if (v43) {
    mach_port_deallocate(*v32, v24);
  }
  return v30;
}

CA::Render::Texture *CA::Render::CompressedImage::new_image_with_texture_data(uint64_t a1)
{
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  ColorSpace = (CGColorSpace *)CGImageTextureDataGetColorSpace();
  CGImageTextureDataGetSize();
  double v4 = v3;
  double v6 = v5;
  unint64_t NumberOfMipmaps = CGImageTextureDataGetNumberOfMipmaps();
  uint64_t PixelFormat = CGImageTextureDataGetPixelFormat();
  unsigned int v9 = 0;
  if ((PixelFormat - 186) <= 0x20) {
    unsigned int v9 = dword_1849A66F8[(PixelFormat - 186)];
  }
  if (CADeviceIsVirtualized::once != -1) {
    dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
  }
  if (CADeviceIsVirtualized::is_virtualized) {
    return 0;
  }
  if (CADeviceSupportsASTC::once != -1) {
    dispatch_once(&CADeviceSupportsASTC::once, &__block_literal_global_169_12170);
  }
  BOOL v13 = v9 > 4 && CADeviceSupportsASTC::supports_astc != 0;
  unsigned int v14 = v9 - 1;
  if (v9 - 1 >= 4 && !v13)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v22 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEBUG))
      {
        if (v14 > 0x1B) {
          mem_entry_name_port_t v23 = "UNKNOWN";
        }
        else {
          mem_entry_name_port_t v23 = off_1E527D2C8[v14];
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v23;
        _os_log_impl(&dword_184668000, v22, OS_LOG_TYPE_DEBUG, "%s compressed texture not supported on this device, falling back to software\n", (uint8_t *)&buf, 0xCu);
      }
    }
    return 0;
  }
  uint64_t v15 = CGImageTextureDataSupportsTiledLayout();
  if (v15) {
    int v16 = 2;
  }
  else {
    int v16 = 0;
  }
  LODWORD(v6CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v16;
  if (NumberOfMipmaps >> 61) {
    return 0;
  }
  uint64_t v55 = PixelFormat;
  unint64_t v58 = (unint64_t)v4;
  unint64_t v59 = (unint64_t)v6;
  unint64_t v17 = 8 * NumberOfMipmaps;
  int v57 = v15;
  LODWORD(v54) = v9;
  if (8 * NumberOfMipmaps > 0x1000)
  {
    unint64_t v63 = malloc_type_malloc(8 * NumberOfMipmaps, 0xE5CAE7DCuLL);
    unint64_t v60 = (unint64_t *)malloc_type_malloc(8 * NumberOfMipmaps, 0xC2F1836AuLL);
    OffsetWithBlocint k = malloc_type_malloc(8 * NumberOfMipmaps, 0xB8A38E5BuLL);
    uint8x8_t v62 = OffsetWithBlock;
  }
  else
  {
    MEMORY[0x1F4188790](v15);
    unint64_t v18 = (v17 + 15) & 0xFFFFFFFFFFFFFFF0;
    unint64_t v63 = (uint64_t *)((char *)&v52 - v18);
    bzero((char *)&v52 - v18, 8 * NumberOfMipmaps);
    MEMORY[0x1F4188790](v19);
    unint64_t v60 = (unint64_t *)((char *)&v52 - v18);
    bzero((char *)&v52 - v18, 8 * NumberOfMipmaps);
    MEMORY[0x1F4188790](v20);
    uint8x8_t v62 = (uint64_t *)((char *)&v52 - v18);
    bzero((char *)&v52 - v18, 8 * NumberOfMipmaps);
  }
  *(void *)&long long buf = 0;
  *((void *)&buf + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = &buf;
  uint64_t v96 = 0x2020000000;
  uint64_t v97 = 0;
  uint64_t v88 = 0;
  uint64_t v89 = &v88;
  uint64_t v90 = 0x2020000000;
  uint64_t v91 = 0;
  uint64_t v84 = 0;
  unint64_t v85 = &v84;
  uint64_t v86 = 0x2020000000;
  uint64_t v87 = 0;
  v82[0] = 0;
  v82[1] = v82;
  v82[2] = 0x2020000000;
  char v83 = 0;
  if (NumberOfMipmaps)
  {
    unint64_t v24 = NumberOfMipmaps;
    uint64_t v56 = 8 * NumberOfMipmaps;
    unint64_t v53 = ColorSpace;
    uint64_t v25 = 0;
    uint64_t v26 = MEMORY[0x1E4F143A8];
    do
    {
      uint64_t v68 = v26;
      uint64_t v69 = 3221225472;
      uint8x8_t v70 = ___ZN2CA6Render15CompressedImage27new_image_with_texture_dataEP18CGImageTextureData_block_invoke;
      unint64_t v71 = &unk_1E527D2A8;
      unint64_t v76 = v58;
      unint64_t v77 = v59;
      __int16 v72 = v82;
      p_long long buf = &buf;
      uint64_t v78 = v25;
      unint64_t v79 = v63;
      int8x8_t v80 = v60;
      long long v81 = v62;
      unint64_t v74 = &v88;
      float v75 = &v84;
      OffsetWithBlocint k = (void *)CGImageTextureDataGetOffsetWithBlock();
      ++v25;
    }
    while (v24 != v25);
    uint64_t v27 = v85[3];
    ColorSpace = v53;
    unint64_t v17 = v56;
    unint64_t NumberOfMipmaps = v24;
  }
  else
  {
    uint64_t v27 = 0;
  }
  LOBYTE(v28) = v57;
  if (v27 != NumberOfMipmaps)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      double v48 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v49 = v85[3];
        *(_DWORD *)unsigned int v92 = 134218240;
        *(void *)&v92[4] = v49;
        __int16 v93 = 2048;
        unint64_t v94 = NumberOfMipmaps;
        _os_log_impl(&dword_184668000, v48, OS_LOG_TYPE_DEBUG, "Compressed image acquired %zu levels, but expected %zu!\n", v92, 0x16u);
      }
    }
    float32x4_t v10 = 0;
    goto LABEL_66;
  }
  if (v54 < 5) {
    char v29 = 1;
  }
  else {
    char v29 = v57;
  }
  if ((v29 & 1) == 0)
  {
    *(void *)unsigned int v92 = 0;
    long long v32 = (void *)MEMORY[0x185324A30](OffsetWithBlock);
    unint64_t v61 = NumberOfMipmaps;
    uint64_t v33 = *((unsigned int *)v85 + 6);
    id v34 = MTLCreateSystemDefaultDevice();
    BOOL v35 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:v55 width:v58 height:v59 mipmapped:(v33 & 0xFFFFFFFE) != 0];
    [v35 setMipmapLevelCount:v33];
    unint64_t v36 = (void *)[v34 newTextureLayoutWithDescriptor:v35 isHeapOrBufferBacked:0];

    unint64_t v37 = (CA::Render *)[v36 size];
    double v38 = CA::Render::aligned_malloc(v37, (unint64_t *)v92, (void **)[v36 alignment]);
    BOOL v28 = v38 != 0;
    if (v38)
    {
      double v39 = v38;
      [v36 initializeTextureMemory:v38];
      unint64_t v53 = v37;
      float v54 = v32;
      uint64_t v56 = v17;
      int v57 = v28;
      if (v85[3])
      {
        unint64_t v40 = 0;
        unint64_t v42 = v58;
        unint64_t v41 = v59;
        do
        {
          uint64_t v43 = *(void *)(*((void *)&buf + 1) + 24);
          uint64_t v44 = v63[v40];
          uint64_t v45 = v62[v40];
          memset(v64, 0, sizeof(v64));
          unint64_t v65 = v42;
          unint64_t v66 = v41;
          uint64_t v67 = 1;
          [v36 copyFromLinearBytes:v43 linearOffset:v44 linearBytesPerRow:v45 linearBytesPerImage:0 toTextureMemory:v39 textureSlice:0 textureLevel:v40 textureRegion:v64];
          [v36 finalizeTextureMemory:v39];
          if (v42 <= 1) {
            unint64_t v42 = 1;
          }
          else {
            v42 >>= 1;
          }
          if (v41 <= 1) {
            unint64_t v41 = 1;
          }
          else {
            v41 >>= 1;
          }
          ++v40;
        }
        while (v40 < v85[3]);
      }
      uint8x8_t v46 = (CA::Render::CompressedImage *)x_mem_alloc0(0xB8uLL);
      float32x4_t v10 = v46;
      if (v46)
      {
        *(void *)&long long v51 = CA::Render::aligned_free;
        *((void *)&v51 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(void *)v92;
        CA::Render::CompressedImage::CompressedImage(v46, v58, v59, v55, v39, (uint64_t)v53, v63, v60, v62, v61, v51);
      }
      else
      {
        CA::Render::aligned_free((CA::Render *)v39, *(size_t *)v92, v47);
      }
      LOBYTE(v28) = v57;
      long long v32 = v54;
      unint64_t v17 = v56;
    }
    else
    {
      float32x4_t v10 = 0;
    }

    if (!v10) {
      goto LABEL_66;
    }
    goto LABEL_65;
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  long long v31 = (CA::Render::CompressedImage *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xB8uLL, 0x743898A5uLL);
  float32x4_t v10 = v31;
  if (v31)
  {
    *(void *)&long long v50 = CA::Render::release_cgtexturedata;
    *((void *)&v50 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = a1;
    CA::Render::CompressedImage::CompressedImage(v31, v58, v59, v55, *(const void **)(*((void *)&buf + 1) + 24), v89[3], v63, v60, v62, NumberOfMipmaps, v50);
    CGImageTextureDataRetain();
    *((unsigned char *)v10 + 176) &= ~2u;
LABEL_65:
    CA::Render::Texture::set_colorspace(v10, ColorSpace);
    *((unsigned char *)v10 + 176) = *((unsigned char *)v10 + 176) & 0xFE | !v28;
  }
LABEL_66:
  if (v17 > 0x1000)
  {
    free(v63);
    free(v60);
    free(v62);
  }
  _Block_object_dispose(v82, 8);
  _Block_object_dispose(&v84, 8);
  _Block_object_dispose(&v88, 8);
  _Block_object_dispose(&buf, 8);
  return v10;
}

void sub_18479E948(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 + 256), 8);
  _Block_object_dispose((const void *)(v2 - 256), 8);
  _Block_object_dispose((const void *)(v2 - 224), 8);
  _Block_object_dispose((const void *)(v2 - 160), 8);
  _Unwind_Resume(a1);
}

CA::Render::CompressedImage *CA::Render::CompressedImage::CompressedImage(CA::Render::CompressedImage *this, int a2, int a3, int a4, const void *a5, uint64_t a6, unint64_t *a7, unint64_t *a8, unint64_t *a9, int a10, long long a11)
{
  unint64_t v17 = CA::Render::Texture::Texture(this, a2, a3);
  int v18 = *((_DWORD *)v17 + 3);
  *((unsigned char *)v17 + 12) = 9;
  ++dword_1EB2ADDEC;
  *(void *)unint64_t v17 = &unk_1ED02E030;
  *((void *)v17 + 12) = a5;
  *((void *)v17 + 13) = a6;
  *((_OWORD *)v17 + 7) = a11;
  *((void *)v17 + 17) = 0;
  *((void *)v17 + 18) = 0;
  *((void *)v17 + 16) = 0;
  *((_DWORD *)v17 + 38) = a10;
  *((_DWORD *)v17 + 4CA::Context::unref(this[1], 0) = a4;
  *(void *)((char *)v17 + 164) = 0x200000000;
  *((_DWORD *)v17 + 43) = 0;
  *((unsigned char *)v17 + 176) |= 3u;
  if (a3 <= 4096 && a2 <= 4096 && a10 == 1)
  {
    if (*a9 <= 0x8000) {
      *((_DWORD *)this + 3) = v18 & 0xFFFBFF00 | 0x40009;
    }
    uint64_t v19 = a8;
    if ((a4 - 186) > 0x20) {
      int v20 = 0;
    }
    else {
      int v20 = dword_1849A66F8[a4 - 186];
    }
    *((_DWORD *)this + 39) = v20;
    uint64_t v22 = 1;
    goto LABEL_14;
  }
  if ((a4 - 186) > 0x20) {
    int v21 = 0;
  }
  else {
    int v21 = dword_1849A66F8[a4 - 186];
  }
  uint64_t v19 = a8;
  *((_DWORD *)this + 39) = v21;
  uint64_t v22 = a10;
  if ((a10 & 0x80000000) == 0)
  {
LABEL_14:
    size_t v23 = 8 * v22;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v25 = malloc_type_zone_malloc(malloc_zone, v23, 0x8BB15036uLL);
    *((void *)this + 16) = v25;
    memcpy(v25, a7, v23);
    uint64_t v26 = (malloc_zone_t *)get_malloc_zone();
    uint64_t v27 = malloc_type_zone_malloc(v26, v23, 0x8BB15036uLL);
    *((void *)this + 17) = v27;
    memcpy(v27, v19, v23);
    BOOL v28 = (malloc_zone_t *)get_malloc_zone();
    char v29 = malloc_type_zone_malloc(v28, v23, 0x8BB15036uLL);
    goto LABEL_16;
  }
  size_t v23 = 8 * a10;
  memcpy(0, a8, v23);
  char v29 = 0;
LABEL_16:
  *((void *)this + 18) = v29;
  memcpy(v29, a9, v23);
  *((_DWORD *)this + 4CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 1;
  if (a11 == (unint64_t)CA::Render::release_deallocate) {
    *((void *)this + 15) = this;
  }
  return this;
}

CA::Render::Surface *CA::Render::Surface::decode(CA::Render::Surface *this, CA::Render::Decoder *a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  int v3 = CA::Render::Decoder::decode_int8(this);
  int v4 = CA::Render::Decoder::decode_int32(this);
  if (v3)
  {
    uint64_t v5 = CA::Render::Decoder::decode_object(this, 51);
    if (v5)
    {
      double v6 = (atomic_uint *)v5;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      uint64_t v8 = (CA::Render::Surface *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x158uLL, 0x743898A5uLL);
      unsigned int v9 = v8;
      if (v8) {
        CA::Render::Surface::Surface(v8, (CA::Render::Surface *)v6, v4);
      }
      if (atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
      }
      if ((v4 & 0x100000) == 0) {
        goto LABEL_19;
      }
    }
    else
    {
      unsigned int v9 = 0;
      if ((v4 & 0x100000) == 0)
      {
LABEL_19:
        BOOL v20 = 0;
        goto LABEL_25;
      }
    }
    if (CA::Render::Decoder::decode_int8(this))
    {
      BOOL v36 = 0;
      mach_port_name_t v19 = CA::Render::Decoder::decode_port(this, 17, &v36);
      if (v19)
      {
        if (v36) {
          mach_port_deallocate(*MEMORY[0x1E4F14960], v19);
        }
      }
    }
    goto LABEL_19;
  }
  int v10 = CA::Render::Decoder::decode_int32(this);
  int v11 = CA::Render::Decoder::decode_int8(this);
  if ((v11 | 2) == 3 && (int v12 = v11, v37 = 0, (v13 = CA::Render::Decoder::decode_port(this, 17, &v37)) != 0))
  {
    mach_port_name_t v14 = v13;
    IOSurfaceRef v15 = IOSurfaceLookupFromMachPort(v13);
    if (v15)
    {
      int v16 = v15;
      unint64_t v17 = (malloc_zone_t *)get_malloc_zone();
      int v18 = (CA::Render::Surface *)malloc_type_zone_calloc(v17, 1uLL, 0x158uLL, 0x743898A5uLL);
      unsigned int v9 = v18;
      if (v18) {
        CA::Render::Surface::Surface((uint64_t)v18, v16, v10, 0, v4, 0, 0);
      }
    }
    else
    {
      unsigned int v9 = 0;
    }
    if (v37) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v14);
    }
    BOOL v20 = v12 == 3;
  }
  else
  {
    BOOL v20 = 0;
    unsigned int v9 = 0;
  }
LABEL_25:
  int v21 = CA::Render::Decoder::decode_int8(this);
  int v22 = CA::Render::Decoder::decode_int8(this);
  char v23 = CA::Render::Decoder::decode_int8(this);
  int v24 = CA::Render::Decoder::decode_int8(this);
  int v25 = CA::Render::Decoder::decode_int8(this);
  int v26 = CA::Render::Decoder::decode_int8(this);
  int v27 = CA::Render::Decoder::decode_int8(this);
  int v28 = CA::Render::Decoder::decode_int8(this);
  if (v9)
  {
    BOOL v35 = v20;
    __int16 v29 = v28 != 0;
    CA::Render::Texture::decode(v9, this);
    __int16 v31 = (32 * (v21 != 0)) | ((v22 != 0) << 6) | *((_WORD *)v9 + 168) & 0xF817;
    *((unsigned char *)v9 + 328) = v23;
    *((_WORD *)v9 + 168) = ((v24 != 0) << 10) | ((v25 != 0) << 8) | ((v26 != 0) << 9) | ((v27 != 0) << 7) | (8 * v29) | v31;
    if (v35) {
      CA::Render::Surface::reload_iosurface_color_attributes(v9, v30);
    }
  }
  else
  {
    long long v32 = (malloc_zone_t *)get_malloc_zone();
    uint64_t v33 = (CA::Render::Texture *)malloc_type_zone_calloc(v32, 1uLL, 0x158uLL, 0x743898A5uLL);
    unsigned int v9 = v33;
    if (v33) {
      uint64_t v33 = (CA::Render::Texture *)CA::Render::Surface::Surface((uint64_t)v33, 0, 0, 0, 0x8000, 0, 0);
    }
    CA::Render::Texture::decode(v33, this);
  }
  return v9;
}

_DWORD *CA::Render::Shmem::decode(CA::Render::Shmem *this, CA::Render::Decoder *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  int v3 = CA::Render::Decoder::decode_int32(this);
  if ((v3 & 3) != 0)
  {
    mach_vm_size_t v4 = CA::Render::Decoder::decode_size_t(this);
    CA::Render::Decoder::decode_size_t(this);
    v17[0] = 0;
    mem_entry_name_port_t v5 = CA::Render::Decoder::decode_port(this, 17, v17);
    if (v5)
    {
      mach_port_name_t v6 = v5;
      BOOL v7 = v17[0];
      uint64_t result = CA::Render::Shmem::new_shmem(v5, v4, v17[0], v3);
      if (result) {
        return result;
      }
      if (v7) {
        mach_port_deallocate(*MEMORY[0x1E4F14960], v6);
      }
    }
    else
    {
      CA::Render::Decoder::set_fatal_error(this, "Shmem port is MACH_PORT_NULL!");
    }
  }
  else
  {
    int v16 = 0;
    *(void *)unint64_t v17 = 0;
    IOSurfaceRef v15 = 0;
    unsigned int v9 = CA::Render::Decoder::decode_data_async(this, (unint64_t *)v17, (void (__cdecl **)(void *))&v16, (void **)&v15);
    if (v9)
    {
      int v11 = v9;
      int v12 = v16;
      mach_port_t v13 = *(char **)v17;
      mach_port_name_t v14 = v15;
      uint64_t result = CA::Render::Shmem::new_shmem((unint64_t)v9, *(char **)v17, v3, (uint64_t (*)(CA::Render *, void *, void *))v16, v15, v10);
      if (result) {
        return result;
      }
      CA::Render::Decoder::set_fatal_error(this, "Failed to decode shmem from data ptr: %p, len: %zu", v11, (size_t)v13);
      if (v12) {
        v12(v11, v14);
      }
    }
    else
    {
      CA::Render::Decoder::set_fatal_error(this, "Failed to decode shmem data");
    }
  }
  return 0;
}

uint64_t CA::Render::Decoder::decode_port(CA::Render::Decoder *this, int a2, BOOL *a3)
{
  if ((*((unsigned char *)this + 18) & 1) == 0)
  {
    uint64_t v3 = *((void *)this + 6);
    if (v3 && *(_DWORD *)(v3 + 8) == 2)
    {
      uint64_t v4 = *((void *)this + 7) - 1;
      *((void *)this + 6) = *(void *)v3;
      *((void *)this + 7) = v4;
      if (*(_DWORD *)(v3 + 20) == a2)
      {
        *a3 = *(unsigned char *)(v3 + 24);
        return *(unsigned int *)(v3 + 16);
      }
      CA::Render::Decoder::set_fatal_error(this, "%s - expected disposition = %u, received = %u", a3);
    }
    else
    {
      CA::Render::Decoder::set_fatal_error(this, "%s - _attach_list = %p, unsigned int type = %u", a3);
    }
  }
  return 0;
}

_DWORD *CA::Render::Shmem::new_shmem(mem_entry_name_port_t object, mach_vm_size_t size, int a3, int a4)
{
  kern_return_t v11;
  BOOL v12;
  kern_return_t v13;
  malloc_zone_t *malloc_zone;
  _DWORD *result;
  mach_vm_address_t v16;
  NSObject *v17;
  mach_vm_address_t address;
  uint8_t buf[4];
  mach_vm_size_t v20;
  __int16 v21;
  mem_entry_name_port_t v22;
  __int16 v23;
  vm_prot_t v24;
  __int16 v25;
  kern_return_t v26;
  uint64_t v27;

  int v27 = *MEMORY[0x1E4F143B8];
  if (a4) {
    int v8 = 3;
  }
  else {
    int v8 = 1;
  }
  if ((a4 & 2) != 0) {
    vm_prot_t cur_protection = 1;
  }
  else {
    vm_prot_t cur_protection = v8;
  }
  BOOLean_t v10 = (a4 & 2) == 0 && !(a4 & 1);
  address = 0;
  int v11 = mach_vm_map(*MEMORY[0x1E4F14960], &address, size, *MEMORY[0x1E4F14AF0], 856686593, object, 0, v10, cur_protection, cur_protection, 2u);
  if (v11) {
    int v12 = 1;
  }
  else {
    int v12 = address == 0;
  }
  if (v12)
  {
    mach_port_t v13 = v11;
    if (CADeviceHasInternalBuild::once[0] != -1) {
      dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
    }
    if (CADeviceHasInternalBuild::internal)
    {
      x_log_crash("Failed to map %ld bytes with port = %u, protection = %u, err = 0x%x\n", size, object, cur_protection, v13);
      abort();
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      unint64_t v17 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 134218752;
        BOOL v20 = size;
        int v21 = 1024;
        int v22 = object;
        char v23 = 1024;
        int v24 = cur_protection;
        int v25 = 1024;
        int v26 = v13;
        _os_log_impl(&dword_184668000, v17, OS_LOG_TYPE_ERROR, "Failed to map %ld bytes with port = %u, protection = %u, err = 0x%x\n", buf, 0x1Eu);
      }
    }
    return 0;
  }
  else
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t result = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x38uLL, 0x743898A5uLL);
    if (result)
    {
      int v16 = address;
      result[2] = 1;
      result[3] = (a4 << 8) & 0x4B00 | 0x102F;
      ++dword_1EB2ADE84;
      *(void *)uint64_t result = &unk_1ED02F520;
      *((void *)result + 2) = size;
      *((void *)result + 3) = v16;
      result[8] = 0;
      *((void *)result + 5) = CA::Render::release_deallocate;
      *((void *)result + 6) = result;
      result[9] = 0;
    }
    if (a3) {
      result[8] = object;
    }
  }
  return result;
}

_DWORD *CA::Render::Shmem::new_shmem(unint64_t this, char *a2, int a3, uint64_t (*a4)(CA::Render *this, void *a2, void *a3), void (*a5)(const void *, void *), void *a6)
{
  kern_return_t v15;
  int v16;
  NSObject *v18;
  const char *v19;
  mach_port_t object_name;
  mach_msg_type_number_t infoCnt;
  mach_vm_size_t size;
  mach_vm_address_t address;
  int info[4];
  long long v25;
  int v26;
  uint8_t buf[4];
  unint64_t v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  uint64_t result = 0;
  __int16 v31 = *MEMORY[0x1E4F143B8];
  if (this && a2)
  {
    unsigned int v11 = a3 & 0xFFFFFFCB;
    if ((a3 & 3) != 0)
    {
LABEL_4:
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      uint64_t result = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x38uLL, 0x743898A5uLL);
      if (result)
      {
        result[2] = 1;
        result[3] = (v11 << 8) | 0x2F;
        ++dword_1EB2ADE84;
        *(void *)uint64_t result = &unk_1ED02F520;
        *((void *)result + 2) = a2;
        *((void *)result + 3) = this;
        result[8] = 0;
        *((void *)result + 5) = a4;
        *((void *)result + 6) = a5;
        result[9] = 0;
        if (a4 == CA::Render::release_deallocate && !a5) {
          *((void *)result + 6) = result;
        }
      }
    }
    else
    {
      int v26 = 0;
      *(_OWORD *)info = 0u;
      int v25 = 0u;
      size = 0;
      mach_port_t v13 = &a2[this];
      if (__CFADD__(this, a2))
      {
        if (x_log_hook_p())
        {
LABEL_23:
          x_log_();
        }
        else
        {
          uint64_t v18 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 134218240;
            int v28 = this;
            __int16 v29 = 2048;
            uint64_t v30 = a2;
            mach_port_name_t v19 = "Data %p with size %zu underflow";
LABEL_28:
            _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_ERROR, v19, buf, 0x16u);
          }
        }
      }
      else
      {
        address = ~*MEMORY[0x1E4F14AF0] & this;
        object_name = 0;
        infoCnt = 9;
        mach_port_name_t v14 = (vm_map_read_t *)MEMORY[0x1E4F14960];
        while (1)
        {
          IOSurfaceRef v15 = mach_vm_region(*v14, &address, &size, 9, info, &infoCnt, &object_name);
          if (object_name)
          {
            mach_port_deallocate(*v14, object_name);
            object_name = 0;
          }
          if (v15) {
            break;
          }
          int v16 = info[1] & 3;
          address += size;
          if ((unint64_t)v13 <= address || v16 != 1)
          {
            if (v16 == 1) {
              v11 |= 2u;
            }
            goto LABEL_4;
          }
        }
        if (x_log_hook_p()) {
          goto LABEL_23;
        }
        uint64_t v18 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 134218240;
          int v28 = this;
          __int16 v29 = 2048;
          uint64_t v30 = a2;
          mach_port_name_t v19 = "CoreAnimation: failed to query region %p (%zu bytes)\n";
          goto LABEL_28;
        }
      }
      return 0;
    }
  }
  return result;
}

CA::Render::Surface *CA::Render::Surface::Surface(CA::Render::Surface *this, CA::Render::Surface *a2, int a3)
{
  mach_port_name_t v6 = CA::Render::Texture::Texture(this, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5));
  *((unsigned char *)v6 + 12) = 51;
  ++dword_1EB2ADE94;
  *(void *)mach_port_name_t v6 = &unk_1ED02F9D0;
  BOOL v7 = a2;
  if (!atomic_fetch_add((atomic_uint *volatile)a2 + 2, 1u))
  {
    BOOL v7 = 0;
    atomic_fetch_add((atomic_uint *volatile)a2 + 2, 0xFFFFFFFF);
  }
  *((void *)this + 12) = v7;
  *((void *)this + 13) = *((void *)a2 + 13);
  int v8 = (void *)*((void *)a2 + 14);
  if (v8) {
    int v8 = (void *)CFRetain(v8);
  }
  *((void *)this + 14) = v8;
  *((void *)this + 15) = 0;
  *((_DWORD *)this + 32) = IOSurfaceGetPixelFormat((IOSurfaceRef)v8);
  *((_DWORD *)this + 33) = *((_DWORD *)a2 + 33);
  *((void *)this + 17) = *((void *)a2 + 17);
  *(_OWORD *)((char *)this + 172) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 1CA::Context::unref(this[1], 0) = 0u;
  *(_OWORD *)((char *)this + 188) = xmmword_184997E20;
  *((_DWORD *)this + 5CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 1065353216;
  *((_OWORD *)this + 13) = xmmword_184997E30;
  *((void *)this + 28) = 0;
  *((_WORD *)this + 116) = 0;
  *(void *)((char *)this + 236) = 0x100000001;
  *(_OWORD *)((char *)this + 244) = 0u;
  *(_OWORD *)((char *)this + 26CA::Context::unref(this[1], 0) = 0u;
  *((unsigned char *)this + 276) = 0;
  *((_DWORD *)this + 7CA::Context::unref(this[1], 0) = 1065353216;
  *(void *)((char *)this + 292) = 0;
  *(void *)((char *)this + 284) = 0;
  *((_DWORD *)this + 75) = -1;
  *((void *)this + 39) = 0;
  *((void *)this + 4CA::Context::unref(this[1], 0) = 0;
  *((unsigned char *)this + 328) = *((unsigned char *)a2 + 328);
  char v9 = *((unsigned char *)this + 329) & 0xF0 | *((unsigned char *)a2 + 329) & 0xF;
  *((unsigned char *)this + 329) = v9;
  *((unsigned char *)this + 329) = v9 & 0x8F | *((unsigned char *)a2 + 329) & 0x70;
  *((_DWORD *)this + 83) = -1;
  int v10 = *((_WORD *)this + 168) & 0xFFFC | *((_WORD *)a2 + 168) & 3;
  *((_WORD *)this + 168) = *((_WORD *)this + 168) & 0xFFFC | *((_WORD *)a2 + 168) & 3;
  unsigned int v11 = v10 & 0xFFFFFFFB | (4 * ((*((unsigned __int16 *)a2 + 168) >> 2) & 1));
  *((_WORD *)this + 168) = v11;
  unsigned int v12 = v11 & 0xFFFFFFF7 | (8 * ((*((unsigned __int16 *)a2 + 168) >> 3) & 1));
  *((_WORD *)this + 168) = v12;
  unsigned int v13 = v12 & 0xFFFFFFEF | (16 * ((*((unsigned __int16 *)a2 + 168) >> 4) & 1));
  *((_WORD *)this + 168) = v13;
  unsigned int v14 = v13 & 0xFFFFFFDF | (32 * ((*((unsigned __int16 *)a2 + 168) >> 5) & 1));
  *((_WORD *)this + 168) = v14;
  unsigned int v15 = v14 & 0xFFFFFF7F | (((*((unsigned __int16 *)a2 + 168) >> 7) & 1) << 7);
  *((_WORD *)this + 168) = v15;
  unsigned int v16 = v15 & 0xFFFFFEFF | ((HIBYTE(*((unsigned __int16 *)a2 + 168)) & 1) << 8);
  *((_WORD *)this + 168) = v16;
  unsigned int v17 = v16 & 0xFFFFFDFF | (((*((unsigned __int16 *)a2 + 168) >> 9) & 1) << 9);
  *((_WORD *)this + 168) = v17;
  *((_WORD *)this + 168) = v17 & 0xFBFF | *((_WORD *)a2 + 168) & 0x400;
  int v18 = a3 | (*((_DWORD *)a2 + 3) >> 8);
  *((_DWORD *)this + 3) |= v18 << 8;
  *((_DWORD *)this + 8CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 1;
  CA::Render::Texture::set_colorspace(this, *((CGColorSpace **)a2 + 6));
  int v19 = *((unsigned __int16 *)a2 + 12);
  int v20 = *((unsigned __int16 *)a2 + 13);
  int v21 = *((_DWORD *)a2 + 4) - (v19 + *((unsigned __int16 *)a2 + 14));
  int v22 = *((_DWORD *)a2 + 5) - (v20 + *((unsigned __int16 *)a2 + 15));
  *((_WORD *)this + 12) = v19;
  int v23 = *((_DWORD *)this + 4);
  int v24 = *((_DWORD *)this + 5);
  *((_WORD *)this + 13) = v20;
  *((_WORD *)this + 14) = v23 - v19 - v21;
  *((_WORD *)this + 15) = v24 - v20 - v22;
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  *((_DWORD *)this + 14) = *((_DWORD *)a2 + 14);
  if ((v18 & 0x8000) != 0) {
    IOSurfaceIncrementUseCount(*((IOSurfaceRef *)this + 14));
  }
  return this;
}

int8x16_t *CA::OGL::emit_shadow_round_rect(CA::OGL::Context *this, float64x2_t *a2, float32x2_t *a3, float16x4_t *a4, int a5, int a6, int a7, uint64_t a8, double a9, double a10, int a11, uint64_t a12)
{
  uint64_t v118 = *MEMORY[0x1E4F143B8];
  if (a11) {
    double v21 = a9;
  }
  else {
    double v21 = 0.0;
  }
  double v22 = a2[1].f64[0];
  double v23 = 1.0;
  if (a11) {
    _NF = v21 < 1.0;
  }
  else {
    _NF = 1;
  }
  if (!_NF || (v22 >= a10 * 5.6 ? (BOOL v25 = a2[1].f64[1] < a10 * 5.6) : (BOOL v25 = 1), v25))
  {
    double v26 = a10 * 2.8;
    if (a8) {
      double v23 = 1.528665;
    }
    double v85 = v21;
    double v27 = v26 + v21 * v23;
    double v28 = v27 + v27;
    if (v27 + v27 < v22
      && a11 == 15
      && v28 < a2[1].f64[1]
      && (*(unsigned int (**)(CA::OGL::Context *, uint64_t))(*(void *)this + 184))(this, 37))
    {
      if (byte_1EB2ACC6F) {
        *a4 = (float16x4_t)0x3C003A0000003400;
      }
      float64x2_t v31 = *a2;
      float64x2_t v32 = a2[1];
      _Q0 = vaddq_f64(*a2, vcvtq_f64_f32(*a3));
      *a2 = _Q0;
      float16x4_t v34 = *a4;
      if (a5 >= 255) {
        int v35 = 255;
      }
      else {
        int v35 = a5;
      }
      int v36 = v35 & ~(v35 >> 31);
      float64x2_t v83 = v31;
      float64x2_t v84 = v32;
      if (*(void *)&v34 == 0x3C003C003C003C00)
      {
        *(float *)_Q0.f64 = (float)v36 * 0.0039216;
        __asm { FCVT            H0, S0 }
        *(int16x4_t *)&_Q0.f64[0] = vdup_lane_s16(*(int16x4_t *)&_Q0.f64[0], 0);
      }
      else
      {
        *(float16x4_t *)&_Q0.f64[0] = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v34), (float)v36 * 0.0039216));
      }
      double v46 = COERCE_DOUBLE(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(*(float16x4_t *)(*((void *)this + 31) + 32)), vcvtq_f32_f16(*(float16x4_t *)&_Q0.f64[0]))));
      if (*(void *)(*((void *)this + 31) + 32) != 0x3C003C003C003C00) {
        _Q0.f64[0] = v46;
      }
      *(float64_t *)(*((void *)this + 2) + 8) = _Q0.f64[0];
      if (a6) {
        char v47 = 12;
      }
      else {
        char v47 = 3;
      }
      *(unsigned char *)(*((void *)this + 2) + 16) = v47;
      float32x2_t v114 = 0;
      uint64_t v113 = 0;
      float v115 = 0.0;
      float v48 = v85 / a10;
      if (v48 <= 20.0)
      {
        uint64_t v54 = 0;
        uint64_t v55 = &CA::OGL::emit_shadow_round_rect(CA::OGL::Context &,CA::Rect &,CA::Vec2<float> const&,double,double,CA::OGL::ExtendedColor,int,BOOL,BOOL,unsigned int,unsigned int,CA::Transform const&,float)::w[55 * (a8 != 0)];
        do
        {
          float v56 = CA::OGL::emit_shadow_round_rect(CA::OGL::Context &,CA::Rect &,CA::Vec2<float> const&,double,double,CA::OGL::ExtendedColor,int,BOOL,BOOL,unsigned int,unsigned int,CA::Transform const&,float)::w[55 * (a8 != 0) + 10 + 11 * v54];
          for (uint64_t i = 9; i != -1; --i)
            float v56 = v55[i] + (float)(v56 * v48);
          *((float *)&v113 + v54++) = v56;
          v55 += 11;
        }
        while (v54 != 5);
      }
      else
      {
        uint64_t v49 = 0;
        float v50 = -v48;
        long long v51 = (float *)((char *)&CA::OGL::emit_shadow_round_rect(CA::OGL::Context &,CA::Rect &,CA::Vec2<float> const&,double,double,CA::OGL::ExtendedColor,int,BOOL,BOOL,unsigned int,unsigned int,CA::Transform const&,float)::w
                      + 60 * (a8 != 0)
                      + 4);
        do
        {
          float v52 = *(v51 - 1);
          float v53 = *v51;
          *(float *)((char *)&v113 + v49) = v52 + (float)(exp2f(v50 / v51[1]) * v53);
          v49 += 4;
          v51 += 3;
        }
        while (v49 != 20);
      }
      v30.f32[0] = (float)(*((float *)&v113 + 1) * 60.0) + (float)(*(float *)&v113 * -60.0);
      v58.i32[1] = v114.i32[1];
      float32x2_t v59 = vmul_f32(v114, (float32x2_t)0xC0A00000C1F00000);
      int8x8_t v60 = (int8x8_t)vadd_f32(v59, v30);
      v30.f32[1] = *((float *)&v113 + 1) * 20.0;
      float v61 = vmlas_n_f32(-(float)((float)(*((float *)&v113 + 1) * 60.0) + (float)(*(float *)&v113 * -90.0)), 15.0, v114.f32[0]);
      v58.f32[0] = v114.f32[0] + *(float *)&v113;
      float32x2_t v62 = vmla_f32((float32x2_t)vext_s8((int8x8_t)vsub_f32(v59, v30), v60, 4uLL), (float32x2_t)0x40C0000041700000, v58);
      float32_t v63 = (float)(*((float *)&v113 + 1) * 20.0) + (float)(*(float *)&v113 * -60.0);
      float32_t v64 = *(float *)&v113 * 15.0;
      float32_t v65 = v27 / fmax(a10 * 1.41421356, 0.5);
      v58.f32[0] = v115 * v65;
      uint64_t v66 = *((void *)this + 2);
      *(_OWORD *)(v66 + 96) = xmmword_184997ED0;
      *(unsigned char *)(v66 + 17) = 14;
      uint64_t v67 = (float32x2_t *)*((void *)this + 2);
      v67[48] = v62;
      v67[49].f32[0] = v61;
      v67[49].f32[1] = v63;
      v67[50].f32[0] = v64;
      v67[50].f32[1] = v65;
      v67[51].i32[0] = v58.i32[0];
      double v68 = a2->f64[0];
      double v69 = a2->f64[1];
      float64_t v70 = a2->f64[0] + v27;
      v112[0] = a2->f64[0] - v26;
      v112[1] = v70;
      double v71 = a2[1].f64[1];
      float64_t v72 = a2[1].f64[0] + v68;
      v112[2] = v72 - v27;
      v112[3] = v72 + v26;
      v111[0] = v69 - v26;
      v111[1] = v69 + v27;
      v111[2] = v71 + v69 - v27;
      v111[3] = v71 + v69 + v26;
      *(void *)&v109[4] = 0x80000000800000;
      *(float *)&float64_t v72 = (v27 + v26 + v27 + v26) / v28;
      *(_DWORD *)float v109 = LODWORD(v72);
      int v110 = LODWORD(v72);
      *(void *)&v107[4] = 0x80000000800000;
      *(_DWORD *)unint64_t v107 = LODWORD(v72);
      int v108 = LODWORD(v72);
      if (a7)
      {
        *(unsigned char *)(*((void *)this + 2) + 16) = 14;
        long long v105 = 0u;
        long long v106 = 0u;
        long long v103 = 0u;
        long long v104 = 0u;
        uint64_t v101 = 0;
        uint64_t v102 = 0;
        uint64_t v99 = 0;
        uint64_t v100 = 0;
        uint64_t v98 = 0;
        long long v117 = 0u;
        memset(v116, 0, sizeof(v116));
        memset(v97, 0, sizeof(v97));
        memset(v96, 0, sizeof(v96));
        memset(v95, 0, sizeof(v95));
        memset(v94, 0, sizeof(v94));
        memset(v93, 0, sizeof(v93));
        if (a8)
        {
          int8x16_t v73 = (int8x16_t)vaddq_f64(vdivq_f64(vmulq_f64(v84, (float64x2_t)vdupq_n_s64(0xBFF721E8A7A4B61BLL)), (float64x2_t)vdupq_lane_s64(COERCE__INT64(v85 * 1.528665), 0)), (float64x2_t)vdupq_n_s64(0x400721E8A7A4B61BuLL));
          __asm { FMOV            V1.2D, #1.0 }
          int8x16_t v75 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v73, (float64x2_t)_Q1), _Q1, v73);
          v87[0] = vcvt_f32_f64((float64x2_t)vbicq_s8(v75, (int8x16_t)vcltzq_f64((float64x2_t)v75)));
          double v85 = v85 * 1.528665;
          LODWORD(v29) = vcvtpd_s64_f64(v85);
          (*(void (**)(CA::OGL::Context *, uint64_t, uint64_t, void, void, uint64_t *, uint64_t, void *))(*(void *)this + 464))(this, 1, v29, 0, 0, &v102, a8, v87);
        }
        else
        {
          LODWORD(v29) = vcvtpd_s64_f64(v85);
          (*(void (**)(CA::OGL::Context *, uint64_t, uint64_t, void, void, uint64_t *))(*(void *)this
                                                                                                  + 456))(this, 1, v29, 0, 0, &v102);
        }
        *(float64_t *)&long long v105 = v83.f64[0];
        *((double *)&v105 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v85 + v83.f64[0];
        float64x2_t v77 = vaddq_f64(v84, v83);
        *(double *)&long long v106 = v77.f64[0] - v85;
        *((void *)&v106 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(void *)&v77.f64[0];
        *(float64_t *)&long long v103 = v83.f64[1];
        *((void *)&v104 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(void *)&v77.f64[1];
        *((double *)&v103 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v85 + v83.f64[1];
        *(double *)&long long v104 = v77.f64[1] - v85;
        float v78 = *(float *)&v102;
        LODWORD(v10CA::Context::unref(this[1], 0) = v102;
        *((float *)&v100 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(float *)&v102 + (float)((float)(*((float *)&v102 + 1) - *(float *)&v102) * 0.5);
        *(float *)&uint64_t v101 = *((float *)&v100 + 1);
        HIDWORD(v10CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = HIDWORD(v102);
        LODWORD(v98) = v102;
        *((float *)&v98 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *((float *)&v100 + 1);
        *(float *)&uint64_t v99 = *((float *)&v100 + 1);
        HIDWORD(v99) = HIDWORD(v102);
        int v79 = CA::OGL::merge_compressed_geometry((CA::OGL *)v112, (const double *)&v105, (const double *)v109, (const float *)&v100, (const float *)3, 0.0, (uint64_t)v116, 1.1755e-38, *(float *)&v102, (double *)v96, (float *)v95, v81);
        int v80 = CA::OGL::merge_compressed_geometry((CA::OGL *)v111, (const double *)&v103, (const double *)v107, (const float *)&v98, (const float *)3, 0.0, (uint64_t)v97, 2.0, v78, (double *)v94, (float *)v93, v82);
        v87[0] = a2;
        v87[1] = a12;
        int v88 = 63;
        uint64_t v89 = 0;
        uint64_t v91 = 0;
        uint64_t v90 = 0;
        int v92 = 0;
        CA::OGL::emit_n_part_rect((uint64_t)this, (uint64_t)v87, v79 - 1, v80 - 1, (float64_t *)v116, (uint64_t)v97, v96, (uint64_t)v94, v95, (uint64_t)v93, 0);
      }
      else
      {
        *(void *)&v116[0] = a2;
        *((void *)&v116[0] + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = a12;
        if (a6) {
          unsigned int v76 = 278528;
        }
        else {
          unsigned int v76 = 0x20000;
        }
        memset((char *)&v116[1] + 4, 0, 28);
        LODWORD(v116[1]) = 63;
        CA::OGL::emit_nine_part_rect((uint64_t)this, (uint64_t)v116, (uint64_t)v112, (uint64_t)v111, (uint64_t)v109, (uint64_t)v107, 0, 0, v76);
      }
      uint64_t result = (int8x16_t *)(*(uint64_t (**)(CA::OGL::Context *, void, void))(*(void *)this + 520))(this, 0, 0);
      *(unsigned char *)(*((void *)this + 2) + 16) = 0;
    }
    else
    {
      uint64_t result = (int8x16_t *)CA::OGL::Context::shadow_cache(this);
      if (result)
      {
        double v41 = 0.0;
        if ((a11 & 4) != 0) {
          double v42 = v85;
        }
        else {
          double v42 = 0.0;
        }
        *(double *)uint64_t v116 = v42;
        *((double *)v116 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v42;
        if ((a11 & 8) != 0) {
          double v43 = v85;
        }
        else {
          double v43 = 0.0;
        }
        *(double *)&v116[1] = v43;
        *((double *)&v116[1] + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v43;
        if ((a11 & 2) != 0) {
          double v44 = v85;
        }
        else {
          double v44 = 0.0;
        }
        *(double *)&v116[2] = v44;
        *((double *)&v116[2] + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v44;
        if (a11) {
          double v41 = v85;
        }
        *(double *)&long long v117 = v41;
        *((double *)&v117 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v41;
        uint64_t result = CA::Render::ShadowCache::lookup_rounded_rect_path((uint64_t)result, a2->f64, (double *)v116, a8 != 0);
        if (result) {
          return (int8x16_t *)CA::OGL::emit_shadow_path((uint64_t)this);
        }
      }
    }
  }
  else
  {
    if (byte_1EB2ACC6F)
    {
      *a4 = (float16x4_t)0x3C0038CD00003400;
      float16x4_t v45 = (float16x4_t)0x3C0038CD00003400;
    }
    else
    {
      float16x4_t v45 = *a4;
    }
    float16x4_t v86 = v45;
    return (int8x16_t *)CA::OGL::emit_shadow_rect(this, a2, a3, &v86, a5, a6, a7, a12, a10);
  }
  return result;
}

unint64_t CA::OGL::emit_shadow_path(uint64_t a1)
{
  uint64_t v1 = (CA::OGL::Context *)MEMORY[0x1F4188790](a1);
  float v9 = v8;
  uint64_t v10 = v7;
  float64_t v11 = *(double *)&v6;
  int v12 = v5;
  int v13 = v4;
  int v14 = v3;
  unsigned int v15 = v2;
  int8x16_t v353 = v16;
  double v18 = v17;
  int v19 = v1;
  uint64_t v382 = *MEMORY[0x1E4F143B8];
  if (byte_1EB2ACC6F) {
    *uint64_t v2 = (float16x4_t)0x3C0000003C003C00;
  }
  if (*(_DWORD *)(v7 + 24) == 4 && *(_DWORD *)(v7 + 20) == 5)
  {
    int v20 = *(unsigned char **)(v7 + 40);
    if (*v20 == 1 && v20[1] == 2 && v20[2] == 2 && v20[3] == 2 && !v20[4])
    {
      long long v297 = *(double **)(v7 + 32);
      double v299 = v297[2];
      double v298 = v297[3];
      double v300 = v297[1];
      if (v300 == v298)
      {
        v301.f64[0] = v297[4];
        if (v299 == v301.f64[0])
        {
          double v302 = v297[5];
          if (v302 == v297[7])
          {
            double v303 = *v297;
            if (v297[6] == *v297) {
              goto LABEL_267;
            }
          }
        }
      }
      double v303 = *v297;
      if (*v297 == v299)
      {
        double v302 = v297[5];
        if (v298 == v302)
        {
          v301.f64[0] = v297[4];
          if (v301.f64[0] == v297[6] && v297[7] == v300)
          {
LABEL_267:
            double v304 = v302 - v300;
            double v305 = -(v301.f64[0] - v303);
            if (v301.f64[0] - v303 >= 0.0) {
              double v305 = v301.f64[0] - v303;
            }
            double v306 = -v304;
            if (v304 >= 0.0) {
              double v306 = v302 - v300;
            }
            if (v305 >= v18 * 5.6 && v306 >= v18 * 5.6)
            {
              if (v301.f64[0] - v303 >= 0.0) {
                v301.f64[0] = v303;
              }
              if (v304 < 0.0) {
                double v300 = v302;
              }
              v301.f64[1] = v300;
              float64x2_t v370 = v301;
              *(double *)int8x16_t v371 = v305;
              *(double *)&v371[1] = v306;
              float16x4_t v354 = *v2;
              return CA::OGL::emit_shadow_rect(v1, &v370, v353, &v354, v3, v4, v5, v6, v18);
            }
          }
        }
      }
    }
  }
  unint64_t result = CA::OGL::Context::shadow_cache(v1);
  if (!result || (*(void *)&v18 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return result;
  }
  double v22 = (uint64_t *)result;
  *(void *)&long long v351 = v15;
  LODWORD(v349) = v14;
  double v23 = (os_unfair_lock_s *)(result + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(result + 24));
  uint64_t v24 = x_hash_table_lookup(*v22, v10, 0);
  int8x16_t v352 = v19;
  LODWORD(v35CA::Context::unref(this[1], 0) = v12;
  if (v24)
  {
    BOOL v25 = (void **)v24;
    double v26 = v11;
    int v27 = v13;
    unint64_t v28 = 1;
    uint64_t v29 = v24;
    do
    {
      float32x2_t v30 = (void *)v29;
      if (*(double *)(v29 + 8) == v18 && *(double *)(v29 + 16) == v9)
      {
        uint64_t v33 = (char *)v29;
        goto LABEL_23;
      }
      uint64_t v29 = *(void *)v29;
      ++v28;
    }
    while (*v30);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    float64x2_t v32 = (char *)malloc_type_zone_malloc(malloc_zone, 0x88uLL, 0x8BB15036uLL);
    uint64_t v33 = v32;
    if (v32)
    {
      *(void *)float64x2_t v32 = 0;
      *(int64x2_t *)(v32 + 8) = vdupq_n_s64(0x7FF8000000000000uLL);
      *((void *)v32 + 3) = 0;
      *((void *)v32 + 4) = 0;
      *(_OWORD *)(v32 + 88) = 0u;
      *(_OWORD *)(v32 + 104) = 0u;
      *(_OWORD *)(v32 + 12CA::Context::unref(this[1], 0) = 0u;
    }
    void *v30 = v32;
LABEL_23:
    int v13 = v27;
    if (v28 >= 9)
    {
      double v39 = *v25;
      *BOOL v25 = (void *)**v25;
      void *v39 = v22[2];
      float64x2_t v22[2] = (uint64_t)v39;
    }
    float64_t v11 = v26;
    int v19 = v352;
  }
  else
  {
    float16x4_t v34 = (malloc_zone_t *)get_malloc_zone();
    int v35 = (char *)malloc_type_zone_malloc(v34, 0x88uLL, 0x8BB15036uLL);
    uint64_t v33 = v35;
    if (v35)
    {
      *(void *)int v35 = 0;
      *(int64x2_t *)(v35 + 8) = vdupq_n_s64(0x7FF8000000000000uLL);
      *((void *)v35 + 3) = 0;
      *((void *)v35 + 4) = 0;
      *(_OWORD *)(v35 + 88) = 0u;
      *(_OWORD *)(v35 + 104) = 0u;
      *(_OWORD *)(v35 + 12CA::Context::unref(this[1], 0) = 0u;
      int v36 = (int *)*v22;
      uint64_t v37 = v10;
      uint64_t v38 = (uint64_t)v33;
    }
    else
    {
      int v36 = (int *)*v22;
      uint64_t v37 = v10;
      uint64_t v38 = 0;
    }
    hash_table_modify(v36, v37, v38, 0);
  }
  unint64_t v40 = (float16x4_t *)v351;
  *((double *)v33 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v18;
  os_unfair_lock_unlock(v23);
  float16x4_t v45 = (CA::Render::Texture *)*((void *)v33 + 3);
  if (v45)
  {
    *(void *)&long long v42 = *((void *)v33 + 5);
    *(void *)&long long v41 = *((void *)v33 + 6);
    *(void *)&long long v44 = *((void *)v33 + 7);
    *(void *)&long long v43 = *((void *)v33 + 8);
    double v47 = *((double *)v33 + 9);
    double v46 = *((double *)v33 + 10);
    int v48 = v349;
    goto LABEL_30;
  }
  double v62 = v9;
  double v63 = 1.0 / v9;
  double v64 = v9 * v18;
  double v65 = 8.0;
  if (v64 <= 8.0) {
    double v65 = 4.0;
  }
  double v66 = 2.0;
  if (v64 > 4.0) {
    double v66 = v65;
  }
  LODWORD(v344) = v13;
  *(double *)&unint64_t v343 = v11;
  *(double *)&long long v345 = v9;
  if (v64 > v66 && (v350 & 1) == 0)
  {
    do
    {
      double v63 = v63 + v63;
      double v62 = v62 * 0.5;
      double v64 = v64 * 0.5;
    }
    while (v64 > v66);
  }
  *(double *)&size_t v342 = v66;
  float v67 = v64;
  unsigned int v68 = vcvtps_s32_f32((float)(v67 * 2.82) + 0.5);
  *(float *)&size_t v341 = v67;
  if (v67 <= 0.6) {
    int v69 = 0;
  }
  else {
    int v69 = v68;
  }
  *((void *)v33 + 12) = *((void *)v33 + 11);
  *((void *)v33 + 15) = *((void *)v33 + 14);
  long long v377 = 0u;
  long long v378 = 0u;
  float v70 = v63 * (double)v69;
  v370.f64[0] = (float)(ceilf(v70) + 1.0);
  *(void *)&v370.f64[1] = v33 + 88;
  v371[0] = (uint64_t)(v33 + 112);
  memset(&v371[1], 0, 32);
  long long v372 = 0u;
  long long v373 = 0u;
  long long v374 = 0u;
  long long v375 = 0u;
  uint64_t v379 = 0;
  uint64_t v376 = 0;
  uint64_t v71 = *(unsigned int *)(v10 + 20);
  if (v71)
  {
    int8x16_t v73 = *(long long **)(v10 + 32);
    float64_t v72 = *(unsigned __int8 **)(v10 + 40);
    unint64_t v74 = &v72[v71];
    do
    {
      int v75 = *v72++;
      switch(v75)
      {
        case 0:
          break;
        case 1:
          long long v377 = *v73;
          long long v76 = *v73++;
          long long v378 = v76;
          break;
        case 2:
          long long v77 = *v73++;
          long long v377 = v77;
          LOBYTE(v379) = 1;
          break;
        case 3:
          uint64_t v78 = 0;
          char v79 = 1;
          double v80 = *((double *)&v377 + 1);
          double v81 = *((double *)&v377 + 1);
          double v82 = *(double *)&v377;
          double v83 = *(double *)&v377;
          do
          {
            char v84 = v79;
            double v85 = (double *)&v73[v78];
            double v86 = v85[1];
            if (v83 >= *v85) {
              double v83 = *v85;
            }
            if (v82 <= *v85) {
              double v82 = *v85;
            }
            if (v81 >= v86) {
              double v81 = v85[1];
            }
            if (v80 <= v86) {
              double v80 = v85[1];
            }
            uint64_t v78 = 1;
            char v79 = 0;
          }
          while ((v84 & 1) != 0);
          long long v377 = v73[1];
          LOBYTE(v379) = 1;
          v73 += 2;
          break;
        case 4:
          uint64_t v87 = 0;
          double v88 = *((double *)&v377 + 1);
          double v89 = *((double *)&v377 + 1);
          double v90 = *(double *)&v377;
          double v91 = *(double *)&v377;
          do
          {
            double v92 = *(double *)&v73[v87];
            double v93 = *((double *)&v73[v87] + 1);
            if (v91 >= v92) {
              double v91 = *(double *)&v73[v87];
            }
            if (v90 <= v92) {
              double v90 = *(double *)&v73[v87];
            }
            if (v89 >= v93) {
              double v89 = *((double *)&v73[v87] + 1);
            }
            if (v88 <= v93) {
              double v88 = *((double *)&v73[v87] + 1);
            }
            ++v87;
          }
          while (v87 != 3);
          long long v377 = v73[2];
          LOBYTE(v379) = 1;
          v73 += 3;
          break;
        default:
          break;
      }
    }
    while (v72 < v74);
  }
  if (v371[1] <= 1uLL)
  {
    if (v371[3] != v371[2])
    {
      float64x2_t v355 = 0uLL;
      v356.f64[0] = 0.0;
      float32x4_t v380 = 0uLL;
      uint64_t v381 = 0;
      if (v380.i64[0]) {
        operator delete((void *)v380.i64[0]);
      }
      if (*(void *)&v355.f64[0]) {
        operator delete(*(void **)&v355.f64[0]);
      }
    }
    if ((void)v374 != *((void *)&v373 + 1))
    {
      float64x2_t v355 = 0uLL;
      v356.f64[0] = 0.0;
      float32x4_t v380 = 0uLL;
      uint64_t v381 = 0;
      if (v380.i64[0]) {
        operator delete((void *)v380.i64[0]);
      }
      if (*(void *)&v355.f64[0]) {
        operator delete(*(void **)&v355.f64[0]);
      }
    }
  }
  if ((void)v375) {
    operator delete((void *)v375);
  }
  if (*((void *)&v373 + 1)) {
    operator delete(*((void **)&v373 + 1));
  }
  int v19 = v352;
  if ((void)v372) {
    operator delete((void *)v372);
  }
  if (v371[2]) {
    operator delete((void *)v371[2]);
  }
  double v340 = v18;
  unint64_t v94 = (double *)CA::Render::Path::bounding_rect((CA::Render::Path *)v10);
  double v96 = *v94;
  double v95 = v94[1];
  double v97 = v94[3];
  double v98 = v94[2] + *v94;
  uint64_t v99 = (double *)*((void *)v33 + 11);
  double v100 = v98;
  do
  {
    double v101 = v100;
    if (v99 == *((double **)v33 + 12)) {
      break;
    }
    double v103 = *v99;
    double v102 = v99[1];
    v99 += 2;
    if (v102 >= v98) {
      double v102 = v94[2] + *v94;
    }
    double v100 = v103 + v101 - v102;
  }
  while (v103 < v98);
  double v339 = v94[2] + *v94;
  double v104 = v97 + v95;
  long long v105 = (double *)*((void *)v33 + 14);
  double v106 = v97 + v95;
  do
  {
    double v107 = v106;
    if (v105 == *((double **)v33 + 15)) {
      break;
    }
    double v109 = *v105;
    double v108 = v105[1];
    v105 += 2;
    if (v108 >= v104) {
      double v108 = v104;
    }
    double v106 = v109 + v107 - v108;
  }
  while (v109 < v104);
  unsigned int v110 = vcvtmd_s64_f64(v96 * v62);
  unsigned int v111 = vcvtpd_s64_f64(v101 * v62);
  LODWORD(v347) = v110 - v69;
  unsigned int v112 = vcvtpd_s64_f64(v107 * v62);
  LODWORD(i) = vcvtmd_s64_f64(v95 * v62) - v69;
  unint64_t v113 = v112 - i + 2 * v69;
  *(void *)&long long v346 = v111 - (v110 - v69) + 2 * v69;
  uint64_t v114 = CA::Render::format_rowbytes((CA::Render *)9, v346);
  uint64_t v115 = v114;
  v380.i64[0] = v114;
  if (is_mul_ok(v114, v113)) {
    unint64_t result = v114 * v113;
  }
  else {
    unint64_t result = 0;
  }
  if (result < 0x1000001)
  {
    v369.i64[0] = 0;
    unint64_t result = (unint64_t)CA::Render::aligned_malloc((CA::Render *)result, (unint64_t *)&v369, 0);
    int v338 = (CGColorSpace *)result;
    if (result)
    {
      v370.f64[1] = 0.0;
      v371[0] = (uint64_t)&v371[3];
      *(_OWORD *)&v371[1] = xmmword_184998000;
      *(void *)&v370.f64[0] = &v370.f64[1];
      uint64_t v361 = 0;
      *(void *)&v355.f64[0] = &v370.f64[1];
      v355.f64[1] = 0.0;
      float64x2_t v356 = 0uLL;
      uint64_t v357 = 0x3FC0000000000000;
      long long v358 = 0u;
      long long v359 = 0u;
      memset(v360, 0, sizeof(v360));
      int64x2_t v362 = vdupq_n_s64(0x7FF0000000000000uLL);
      int64x2_t v363 = vdupq_n_s64(0xFFF0000000000000);
      int v336 = 2 * v69 + v112;
      int v337 = 2 * v69 + v111;
      double v334 = (double)(int)i;
      double v335 = (double)(int)v347;
      double v364 = (double)(int)v347;
      double v365 = (double)(int)i;
      double v366 = (double)v337;
      double v367 = (double)v336;
      uint64_t v123 = *(unsigned int *)(v10 + 20);
      uint64_t v124 = v338;
      if (v123)
      {
        uint64_t v127 = v10 + 32;
        uint64_t v126 = *(double **)(v10 + 32);
        uint64_t v125 = *(unsigned __int8 **)(v127 + 8);
        uint64_t v128 = &v125[v123];
        do
        {
          int v129 = *v125++;
          switch(v129)
          {
            case 0:
              CA::ScanConverter::Path::closepath(v355.f64);
              break;
            case 1:
              double v130 = *v126;
              int v131 = (double *)*((void *)v33 + 11);
              double v132 = *v126;
              do
              {
                double v133 = v132;
                if (v131 == *((double **)v33 + 12)) {
                  break;
                }
                double v135 = *v131;
                double v134 = v131[1];
                v131 += 2;
                if (v134 >= v130) {
                  double v134 = *v126;
                }
                double v132 = v135 + v133 - v134;
              }
              while (v135 < v130);
              double v136 = v126[1];
              int32x4_t v137 = (double *)*((void *)v33 + 14);
              double v138 = v136;
              do
              {
                double v139 = v138;
                if (v137 == *((double **)v33 + 15)) {
                  break;
                }
                double v141 = *v137;
                double v140 = v137[1];
                v137 += 2;
                if (v140 >= v136) {
                  double v140 = v126[1];
                }
                double v138 = v141 + v139 - v140;
              }
              while (v141 < v136);
              double v142 = v133 * v62;
              double v143 = v139 * v62;
              CA::ScanConverter::Path::closepath(v355.f64);
              *(double *)&long long v358 = v142;
              *((double *)&v358 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v143;
              *((double *)&v359 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v142;
              *(double *)int64x2_t v360 = v143;
              *(void *)&long long v359 = 0x3FF0000000000000;
              v126 += 2;
              *((void *)&v360[0] + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0x3FF0000000000000;
              break;
            case 2:
              double v144 = *v126;
              int32x2_t v145 = (double *)*((void *)v33 + 11);
              double v146 = *v126;
              do
              {
                double v147 = v146;
                if (v145 == *((double **)v33 + 12)) {
                  break;
                }
                double v149 = *v145;
                double v148 = v145[1];
                v145 += 2;
                if (v148 >= v144) {
                  double v148 = *v126;
                }
                double v146 = v149 + v147 - v148;
              }
              while (v149 < v144);
              double v150 = v126[1];
              int32x2_t v151 = (double *)*((void *)v33 + 14);
              double v152 = v150;
              do
              {
                double v153 = v152;
                if (v151 == *((double **)v33 + 15)) {
                  break;
                }
                double v155 = *v151;
                double v154 = v151[1];
                v151 += 2;
                if (v154 >= v150) {
                  double v154 = v126[1];
                }
                double v152 = v155 + v153 - v154;
              }
              while (v155 < v150);
              CA::ScanConverter::Path::lineto(v355.f64, v147 * v62, v153 * v62);
              v126 += 2;
              break;
            case 3:
              double v156 = *v126;
              __n128 v157 = (double *)*((void *)v33 + 11);
              unsigned int v158 = (double *)*((void *)v33 + 12);
              double v159 = v157;
              double v160 = *v126;
              do
              {
                double v161 = v160;
                if (v159 == v158) {
                  break;
                }
                double v163 = *v159;
                double v162 = v159[1];
                v159 += 2;
                if (v162 >= v156) {
                  double v162 = *v126;
                }
                double v160 = v163 + v161 - v162;
              }
              while (v163 < v156);
              double v164 = v126[1];
              double v165 = (double *)*((void *)v33 + 14);
              int32x4_t v166 = (double *)*((void *)v33 + 15);
              int32x2_t v167 = v165;
              double v168 = v164;
              do
              {
                double v169 = v168;
                if (v167 == v166) {
                  break;
                }
                double v171 = *v167;
                double v170 = v167[1];
                v167 += 2;
                if (v170 >= v164) {
                  double v170 = v126[1];
                }
                double v168 = v171 + v169 - v170;
              }
              while (v171 < v164);
              double v172 = v126[2];
              double v173 = v172;
              do
              {
                double v174 = v173;
                if (v157 == v158) {
                  break;
                }
                double v176 = *v157;
                double v175 = v157[1];
                v157 += 2;
                if (v175 >= v172) {
                  double v175 = v126[2];
                }
                double v173 = v176 + v174 - v175;
              }
              while (v176 < v172);
              double v177 = v126[3];
              double v178 = v177;
              do
              {
                double v179 = v178;
                if (v165 == v166) {
                  break;
                }
                double v181 = *v165;
                double v180 = v165[1];
                v165 += 2;
                if (v180 >= v177) {
                  double v180 = v126[3];
                }
                double v178 = v181 + v179 - v180;
              }
              while (v181 < v177);
              CA::ScanConverter::Path::quadto((CA::ScanConverter::Path *)&v355, v161 * v62, v169 * v62, v174 * v62, v179 * v62, v116, v117, v118, v119, v120, v121, v122);
              v126 += 4;
              break;
            case 4:
              double v182 = *v126;
              uint64_t v183 = (double *)*((void *)v33 + 11);
              char v184 = (double *)*((void *)v33 + 12);
              int32x4_t v185 = v183;
              double v186 = *v126;
              do
              {
                double v187 = v186;
                if (v185 == v184) {
                  break;
                }
                double v189 = *v185;
                double v188 = v185[1];
                v185 += 2;
                if (v188 >= v182) {
                  double v188 = *v126;
                }
                double v186 = v189 + v187 - v188;
              }
              while (v189 < v182);
              double v190 = v126[1];
              uint64_t v191 = (double *)*((void *)v33 + 14);
              int8x16_t v192 = (double *)*((void *)v33 + 15);
              int8x16_t v193 = v191;
              double v194 = v190;
              do
              {
                double v195 = v194;
                if (v193 == v192) {
                  break;
                }
                double v197 = *v193;
                double v196 = v193[1];
                v193 += 2;
                if (v196 >= v190) {
                  double v196 = v126[1];
                }
                double v194 = v197 + v195 - v196;
              }
              while (v197 < v190);
              double v198 = v126[2];
              int v199 = (double *)*((void *)v33 + 11);
              double v200 = v198;
              do
              {
                double v201 = v200;
                if (v199 == v184) {
                  break;
                }
                double v203 = *v199;
                double v202 = v199[1];
                v199 += 2;
                if (v202 >= v198) {
                  double v202 = v126[2];
                }
                double v200 = v203 + v201 - v202;
              }
              while (v203 < v198);
              double v204 = v126[3];
              double v205 = (double *)*((void *)v33 + 14);
              double v206 = v204;
              do
              {
                double v207 = v206;
                if (v205 == v192) {
                  break;
                }
                double v209 = *v205;
                double v208 = v205[1];
                v205 += 2;
                if (v208 >= v204) {
                  double v208 = v126[3];
                }
                double v206 = v209 + v207 - v208;
              }
              while (v209 < v204);
              double v210 = v126[4];
              double v211 = v210;
              do
              {
                double v212 = v211;
                if (v183 == v184) {
                  break;
                }
                double v214 = *v183;
                double v213 = v183[1];
                v183 += 2;
                if (v213 >= v210) {
                  double v213 = v126[4];
                }
                double v211 = v214 + v212 - v213;
              }
              while (v214 < v210);
              double v215 = v126[5];
              double v216 = v215;
              do
              {
                double v217 = v216;
                if (v191 == v192) {
                  break;
                }
                double v219 = *v191;
                double v218 = v191[1];
                v191 += 2;
                if (v218 >= v215) {
                  double v218 = v126[5];
                }
                double v216 = v219 + v217 - v218;
              }
              while (v219 < v215);
              CA::ScanConverter::Path::cubeto((CA::ScanConverter::Path *)&v355, v187 * v62, v195 * v62, v201 * v62, v207 * v62, v212 * v62, v217 * v62, v116, v117, v118, v119, v120, v121, v122);
              v126 += 6;
              break;
            default:
              break;
          }
        }
        while (v125 < v128);
      }
      int v220 = v346;
      double v221 = (double)(int)v346;
      double v222 = (double)(int)v113;
      CA::ScanConverter::Path::closepath(v355.f64);
      CA::ScanConverter::render_mask((uint64_t)&v355, 0, (uint64_t)v338 + v115 * ((int)v113 - 1), -v115, v347, i, v337, v336, 1);
      x_heap_free(*(void ****)&v370.f64[0]);
      if (!v350)
      {
        float16x4_t v45 = CA::Render::Image::new_image((CA::Render::Image *)9, v346, v113, 1u, 0, v338, (unint64_t *)&v380, (const unint64_t *)CA::Render::aligned_free, (void (*)(const void *, void *))v369.i64[0], v332);
        float64x2_t v291 = (atomic_uint *)*((void *)v33 + 3);
        *((void *)v33 + 3) = v45;
        if (!v291)
        {
LABEL_254:
          int v13 = (int)v344;
          float64_t v11 = *(double *)&v343;
          int v48 = v349;
          unint64_t v40 = (float16x4_t *)v351;
          if (!v45) {
            return (unint64_t)CA::Render::aligned_free(v338, v369.u64[0], 0);
          }
          double v47 = v63 * v221;
          double v46 = v63 * v222;
          *(double *)&long long v42 = v63 * v335;
          *(double *)&long long v41 = v63 * v334;
          *(double *)&long long v44 = v339 - v101 + v63 * v221;
          uint64_t v292 = v345;
          *((double *)v33 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v340;
          *((void *)v33 + 2) = v292;
          *((void *)v33 + 5) = v42;
          *((void *)v33 + 6) = v41;
          *(double *)&long long v43 = v104 - v107 + v63 * v222;
          *((void *)v33 + 7) = v44;
          *((void *)v33 + 8) = v43;
          *((double *)v33 + 9) = v63 * v221;
          *((double *)v33 + 1CA::Context::unref(this[1], 0) = v63 * v222;
LABEL_30:
          uint64_t v49 = (uint32x2_t *)*((void *)v33 + 4);
          long long v349 = v42;
          *(void *)&v50.f64[0] = v42;
          long long v351 = v41;
          *(void *)&v50.f64[1] = v41;
          float64x2_t v51 = vaddq_f64(v50, vcvtq_f64_f32(*v353));
          long long v345 = v44;
          long long v346 = v43;
          *(void *)&v52.f64[0] = v44;
          *(void *)&v52.f64[1] = v43;
          float64x2_t v355 = v51;
          float64x2_t v356 = v52;
          float32x4_t v380 = 0uLL;
          float32x4_t v369 = 0uLL;
          float32x4_t v368 = 0uLL;
          unint64_t result = (unint64_t)CA::OGL::Context::bind_image((uint64_t)v19, 0, (uint32x2_t *)v45, (double *)0x3F, 1u, 1, 0, 0, 0.0, &v380, 0);
          if (!result) {
            return result;
          }
          float16x4_t v54 = *v40;
          if (v48 >= 255) {
            int v55 = 255;
          }
          else {
            int v55 = v48;
          }
          int v56 = v55 & ~(v55 >> 31);
          if (*(void *)&v54 == 0x3C003C003C003C00)
          {
            *(float *)_D0.i32 = (float)v56 * 0.0039216;
            __asm { FCVT            H0, S0 }
            double v61 = COERCE_DOUBLE(vdup_lane_s16(_D0, 0));
          }
          else
          {
            double v61 = COERCE_DOUBLE(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v54), (float)v56 * 0.0039216)));
          }
          double v237 = COERCE_DOUBLE(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(*(float16x4_t *)(*((void *)v19 + 31) + 32)), vcvtq_f32_f16(*(float16x4_t *)&v61))));
          if (*(void *)(*((void *)v19 + 31) + 32) != 0x3C003C003C003C00) {
            double v61 = v237;
          }
          *(double *)(*((void *)v19 + 2) + 8) = v61;
          uint64_t v238 = *((void *)v19 + 2);
          int v347 = v49;
          uint64_t i = (atomic_uint *)result;
          if (v13)
          {
            *(unsigned char *)(v238 + 16) = 12;
          }
          else
          {
            unint64_t v239 = *(void *)(v238 + 16) & 0xFFFFFF00FF00FF00;
            if (*(void *)(v238 + 8) == 0x3C003C003C003C00) {
              int v240 = 1;
            }
            else {
              int v240 = 3;
            }
            *(_DWORD *)(v238 + 16) = v240 | v239;
            *(_DWORD *)(v238 + 2CA::Context::unref(this[1], 0) = HIDWORD(v239);
          }
          *(void *)&v370.f64[0] = &v355;
          v370.f64[1] = v11;
          *(uint64_t *)((char *)v371 + 4) = 0;
          *(uint64_t *)((char *)&v371[2] + 4) = 0;
          *(uint64_t *)((char *)&v371[1] + 4) = 0;
          LODWORD(v371[0]) = 63;
          HIDWORD(v371[3]) = 0;
          uint64_t v241 = (uint64_t)(*((void *)v33 + 12) - *((void *)v33 + 11)) >> 3;
          uint64_t v242 = (uint64_t)(*((void *)v33 + 15) - *((void *)v33 + 14)) >> 3;
          if (!(v241 | v242))
          {
            if (v350 && v347)
            {
              uint64_t v243 = CA::OGL::Context::bind_image((uint64_t)v19, 1u, v347, (double *)0x3F, 1u, 1, 0, 0, 0.0, &v369, 0);
              *(unsigned char *)(*((void *)v19 + 2) + 16) = 14;
              float64x2_t v244 = vcvtq_f64_f32(*v353);
              float64x2_t v245 = vcvtq_f64_f32(*(float32x2_t *)v369.f32);
              float64x2_t v246 = vcvtq_f64_f32(vsub_f32(*(float32x2_t *)&v369.u32[2], *(float32x2_t *)v369.f32));
              float32x4_t v368 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vdivq_f64(vmulq_f64(v244, v246), v356), v245)), vaddq_f64(vdivq_f64(vmulq_f64(vaddq_f64(v356, v244), v246), v356), v245));
              CA::OGL::emit_one_part_rect(v19, (uint64_t)&v370, (const CA::Transform *)&v380, (uint64_t)&v368, 0);
              (*(void (**)(CA::OGL::Context *, _OWORD *, uint64_t))(*(void *)v19 + 520))(v19, v243, 1);
            }
            else
            {
              if (v13) {
                int v251 = 0x40000;
              }
              else {
                int v251 = 0;
              }
              CA::OGL::emit_one_part_rect(v19, (uint64_t)&v370, (const CA::Transform *)&v380, 0, v251);
            }
            float v252 = i;
LABEL_310:
            *(unsigned char *)(*((void *)v19 + 2) + 16) = 0;
            return (*(uint64_t (**)(CA::OGL::Context *, atomic_uint *, void))(*(void *)v19 + 520))(v19, v252, 0);
          }
          unint64_t v247 = (v241 + 2);
          size_t v341 = 8 * v247;
          if (v247 > 0x200)
          {
            int8x16_t v250 = (double *)malloc_type_malloc(8 * (v241 + 2), 0x100004000313F17uLL);
            unint64_t v249 = (unint64_t)v250;
          }
          else
          {
            MEMORY[0x1F4188790](result);
            unint64_t v249 = (unint64_t)&v334 - ((v248 + 15) & 0xFFFFFFFF0);
            bzero((void *)v249, v248);
          }
          LODWORD(v344) = v13;
          unint64_t v253 = (v242 + 2);
          if (v253 > 0x200)
          {
            float v255 = malloc_type_malloc(8 * (v242 + 2), 0x100004000313F17uLL);
            uint64_t v254 = (uint64_t)v255;
          }
          else
          {
            MEMORY[0x1F4188790](v250);
            uint64_t v254 = (uint64_t)&v334 - ((8 * v253 + 15) & 0xFFFFFFFF0);
            bzero((void *)v254, 8 * (v242 + 2));
          }
          size_t v342 = 8 * (v242 + 2);
          if (v247 > 0x400)
          {
            uint64_t v258 = (float *)malloc_type_malloc(4 * v247, 0x100004052888210uLL);
            unint64_t v257 = (unint64_t)v258;
          }
          else
          {
            MEMORY[0x1F4188790](v255);
            unint64_t v257 = (unint64_t)&v334 - ((v256 + 15) & 0x7FFFFFFF0);
            bzero((void *)v257, v256);
          }
          unint64_t v343 = (v241 + 2);
          if (v253 > 0x400)
          {
            uint64_t v260 = (uint64_t)malloc_type_malloc(4 * v253, 0x100004052888210uLL);
          }
          else
          {
            MEMORY[0x1F4188790](v258);
            uint64_t v260 = (uint64_t)&v334 - ((v259 + 15) & 0x7FFFFFFF0);
            bzero((void *)v260, v259);
          }
          double v261 = *(double *)&v351;
          double v262 = *(double *)&v349;
          if ((v254 & v249 & v257 & v260) == 0) {
            goto LABEL_302;
          }
          double v263 = (const float *)(v241 + 1);
          uint32x2_t v264 = (const float *)(v242 + 1);
          *(float64_t *)unint64_t v249 = v355.f64[0];
          *(double *)(v249 + 8 * v263) = v356.f64[0] + v355.f64[0];
          *(float64_t *)uint64_t v254 = v355.f64[1];
          *(double *)(v254 + 8 * v264) = v356.f64[1] + v355.f64[1];
          *(_DWORD *)unint64_t v257 = v380.i32[0];
          *(_DWORD *)(v257 + 4 * v263) = v380.i32[2];
          *(_DWORD *)uint64_t v260 = v380.i32[1];
          *(_DWORD *)(v260 + 4 * v264) = v380.i32[3];
          uint64_t v265 = (double *)*((void *)v33 + 11);
          uint64_t v266 = (double *)*((void *)v33 + 12);
          if (v265 != v266)
          {
            uint64_t v267 = 0;
            double v268 = 1.0 / *(double *)&v345;
            double v269 = 0.0;
            do
            {
              int32x4_t v270 = &v265[v267];
              double v271 = *v270;
              double v272 = v270[1];
              double v273 = *(double *)v249;
              unsigned int v274 = v267 + 1;
              *(double *)(v249 + 8 * v274) = *(double *)v249
                                             + (*(double *)(v249 + 8 * (void)v263) - *(double *)v249)
                                             * (*v270 - v262)
                                             * v268;
              v267 += 2;
              *(double *)(v249 + 8 * v267) = v273
                                                           + (*(double *)(v249 + 8 * (void)v263) - v273)
                                                           * (v272 - v262)
                                                           * v268;
              *(float *)&double v273 = *(float *)v257
                              + (v271 - (v269 + v262))
                              * (float)(*(float *)(v257 + 4 * (void)v263) - *(float *)v257)
                              * (1.0
                               / v47);
              *(_DWORD *)(v257 + 4 * v274) = LODWORD(v273);
              *(_DWORD *)(v257 + 4 * v267) = LODWORD(v273);
              double v269 = v269 - v271 + v272;
            }
            while (v270 + 2 != v266);
          }
          int8x16_t v275 = (double *)*((void *)v33 + 14);
          uint64_t v276 = (double *)*((void *)v33 + 15);
          if (v275 != v276)
          {
            uint64_t v277 = 0;
            double v278 = 1.0 / *(double *)&v346;
            double v279 = 0.0;
            do
            {
              double v280 = &v275[v277];
              double v281 = *v280;
              double v282 = v280[1];
              double v283 = *(double *)v254;
              unsigned int v284 = v277 + 1;
              *(double *)(v254 + 8 * v284) = *(double *)v254
                                             + (*(double *)(v254 + 8 * (void)v264) - *(double *)v254)
                                             * (*v280 - v261)
                                             * v278;
              v277 += 2;
              *(double *)(v254 + 8 * v277) = v283
                                                           + (*(double *)(v254 + 8 * (void)v264) - v283)
                                                           * (v282 - v261)
                                                           * v278;
              *(float *)&double v283 = *(float *)v260
                              + (v281 - (v279 + v261))
                              * (float)(*(float *)(v260 + 4 * (void)v264) - *(float *)v260)
                              * (1.0
                               / v46);
              *(_DWORD *)(v260 + 4 * v284) = LODWORD(v283);
              *(_DWORD *)(v260 + 4 * v277) = LODWORD(v283);
              double v279 = v279 - v281 + v282;
            }
            while (v280 + 2 != v276);
          }
          if (!v350 || !v347)
          {
            if (v344) {
              int v290 = 0x40000;
            }
            else {
              int v290 = 0;
            }
            int v19 = v352;
            CA::OGL::emit_n_part_rect((uint64_t)v352, (uint64_t)&v370, v241 + 1, (int)v264, (float64_t *)v249, v254, (_DWORD *)v257, v260, 0, 0, v290);
            goto LABEL_302;
          }
          uint64_t v285 = (uint64_t)v352;
          float64x2_t v286 = CA::OGL::Context::bind_image((uint64_t)v352, 1u, v347, (double *)0x3F, 1u, 1, 0, 0, 0.0, &v369, 0);
          *(unsigned char *)(*(void *)(v285 + 16) + 16) = 14;
          unint64_t v287 = v343;
          *(void *)&long long v345 = v286;
          if (v343 > 0x100)
          {
            float64x2_t v289 = malloc_type_malloc(16 * v343, 0xD1AC008CuLL);
            *(void *)&long long v351 = v289;
            if (v287 > 0x200)
            {
              size_t v308 = v341;
              int64x2_t v350 = (double *)malloc_type_malloc(v341, 0x19A5BA30uLL);
              uint64_t v296 = (uint32x2_t *)malloc_type_malloc(v308, 0x68DE4CDBuLL);
              int v347 = v296;
LABEL_281:
              if (v253 > 0x100)
              {
                uint64_t v310 = (char *)malloc_type_malloc(16 * v253, 0xAA33EC0DuLL);
                uint64_t v311 = v310;
                if (v253 > 0x200)
                {
                  size_t v316 = v342;
                  *(void *)&long long v349 = malloc_type_malloc(v342, 0xB9FCC5FFuLL);
                  *(void *)&long long v346 = malloc_type_malloc(v316, 0x4F710C9EuLL);
                  uint64_t v315 = (void *)v351;
                  goto LABEL_287;
                }
                unint64_t v344 = v310;
              }
              else
              {
                MEMORY[0x1F4188790](v296);
                unint64_t v344 = (char *)&v334 - ((v309 + 15) & 0x1FFFFFFFF0);
                bzero(v344, v309);
              }
              size_t v312 = v342;
              MEMORY[0x1F4188790](v310);
              uint64_t v313 = (v312 + 15) & 0xFFFFFFFF0;
              *(void *)&long long v349 = (char *)&v334 - v313;
              bzero((char *)&v334 - v313, v312);
              MEMORY[0x1F4188790](v314);
              *(void *)&long long v346 = (char *)&v334 - v313;
              bzero((char *)&v334 - v313, v312);
              uint64_t v315 = (void *)v351;
              uint64_t v311 = v344;
LABEL_287:
              if (v315 && v311 && v350 && (void)v349 && v347 && (void)v346)
              {
                *(void *)&long long v351 = v315;
                uint64_t v317 = v353;
                int v318 = v263;
                uint64_t v319 = (uint64_t)v311;
                double v320 = v347;
                LODWORD(v344) = CA::OGL::merge_compressed_geometry((CA::OGL *)v249, (const double *)v249, (const double *)v257, (const float *)v257, v318, v353->f32[0], v351, v380.f32[0], v369.f32[0], v350, (float *)v347, *(float **)&v334);
                float v321 = v317->f32[1];
                double v322 = v264;
                uint64_t v323 = v349;
                uint64_t v324 = v346;
                int v325 = CA::OGL::merge_compressed_geometry((CA::OGL *)v254, (const double *)v254, (const double *)v260, (const float *)v260, v322, v321, v319, v380.f32[1], v369.f32[1], (double *)v349, (float *)v346, *(float **)&v334);
                uint64_t v330 = v320;
                uint64_t v331 = v324;
                uint64_t v311 = (void *)v319;
                uint64_t v326 = v352;
                CA::OGL::emit_n_part_rect((uint64_t)v352, (uint64_t)&v370, v344 - 1, v325 - 1, (float64_t *)v351, v319, v350, v323, v330, v331, 0);
                uint64_t v327 = *(void *)v326;
                unsigned int v328 = v326;
                uint64_t v315 = (void *)v351;
                (*(void (**)(CA::OGL::Context *, void, uint64_t))(v327 + 520))(v328, v345, 1);
              }
              if (v253 < 0x201)
              {
                int v19 = v352;
                if (v253 < 0x101)
                {
LABEL_298:
                  if (v343 >= 0x201)
                  {
                    free(v347);
                    free(v350);
LABEL_301:
                    free(v315);
                    goto LABEL_302;
                  }
                  if (v343 >= 0x101) {
                    goto LABEL_301;
                  }
LABEL_302:
                  if (v253 >= 0x401) {
                    free((void *)v260);
                  }
                  unint64_t v329 = v343;
                  float v252 = i;
                  if (v343 >= 0x401) {
                    free((void *)v257);
                  }
                  if (v253 >= 0x201) {
                    free((void *)v254);
                  }
                  if (v329 >= 0x201) {
                    free((void *)v249);
                  }
                  goto LABEL_310;
                }
              }
              else
              {
                free((void *)v346);
                free((void *)v349);
                int v19 = v352;
              }
              free(v311);
              goto LABEL_298;
            }
          }
          else
          {
            MEMORY[0x1F4188790](v286);
            *(void *)&long long v351 = (char *)&v334 - ((v288 + 15) & 0x1FFFFFFFF0);
            bzero((void *)v351, v288);
          }
          size_t v293 = v341;
          MEMORY[0x1F4188790](v289);
          uint64_t v294 = (v293 + 15) & 0xFFFFFFFF0;
          int64x2_t v350 = (double *)((char *)&v334 - v294);
          bzero((char *)&v334 - v294, v293);
          MEMORY[0x1F4188790](v295);
          int v347 = (uint32x2_t *)((char *)&v334 - v294);
          bzero((char *)&v334 - v294, v293);
          goto LABEL_281;
        }
        if (atomic_fetch_add(v291 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v291 + 16))(v291);
        }
LABEL_253:
        float16x4_t v45 = (CA::Render::Texture *)*((void *)v33 + 3);
        goto LABEL_254;
      }
      int32x2_t v223 = CA::Render::Image::new_image((CA::Render::Image *)9, v346, v113, 1u, 0, v338, (unint64_t *)&v380, (const unint64_t *)CA::Render::aligned_free, (void (*)(const void *, void *))v369.i64[0], v332);
      unint64_t v224 = (atomic_uint *)*((void *)v33 + 4);
      *((void *)v33 + 4) = v223;
      for (i = v224; v64 > *(double *)&v342; double v64 = v64 * 0.5)
        double v62 = v62 * 0.5;
      int8x16_t v225 = (const unsigned __int8 *)(int)(v62 / *(double *)&v345 * v221);
      unint64_t v226 = (int)(v62 / *(double *)&v345 * v222);
      unint64_t v227 = CA::Render::format_rowbytes((CA::Render *)9, (int)(v62 / *(double *)&v345 * v221));
      uint64_t v228 = (unsigned __int8 *)v227;
      *(void *)&v370.f64[0] = v227;
      if (is_mul_ok(v227, v226)) {
        unint64_t v229 = v227 * v226;
      }
      else {
        unint64_t v229 = 0;
      }
      if (v229 <= 0x1000000
        && (v355.f64[0] = 0.0,
            (float v230 = (unsigned __int16 *)CA::Render::aligned_malloc((CA::Render *)v229, (unint64_t *)&v355, 0)) != 0))
      {
        int64x2_t v231 = v124;
        int8x16_t v232 = (CA::_anonymous_namespace_ *)v230;
        CA::downsample_image((CA *)9, v231, v380.u64[0], v220, (int)v113, v230, (size_t)v228, 4, 0.0, 0.0, (double)(int)v225, (double)(int)v226, LODWORD(v334));
        float v233 = v64;
        int v234 = CA::Render::Image::new_image((CA::Render::Image *)9, v225, v226, 1u, 0, v232, (unint64_t *)&v370, (const unint64_t *)CA::Render::aligned_free, *(void (**)(const void *, void *))&v355.f64[0], v333);
        int v235 = (atomic_uint *)*((void *)v33 + 3);
        *((void *)v33 + 3) = v234;
        if (v235 && atomic_fetch_add(v235 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v235 + 16))(v235);
        }
        int v236 = 0;
      }
      else
      {
        int v236 = 1;
      }
      unint64_t result = (unint64_t)i;
      if (i && atomic_fetch_add(i + 2, 0xFFFFFFFF) == 1) {
        unint64_t result = (*(uint64_t (**)(atomic_uint *))(*(void *)i + 16))(i);
      }
      if (!v236) {
        goto LABEL_253;
      }
    }
  }
  return result;
}

void CA::OGL::render_subclass(CA::OGL::Renderer &,CA::OGL::Layer const*)::visitor::visit_subclass(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(int32x2_t ***)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  float32x4_t v7 = *(float32x4_t *)(a2 + 24);
  if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(v7)))))
  {
    float v8 = *(double **)(a2 + 16);
    uint64_t v9 = *(unsigned __int8 *)(a2 + 120);
    if (v8)
    {
      uint64_t v10 = (long long *)CA::Render::Path::bounding_rect(*(CA::Render::Path **)(a2 + 16));
      long long v11 = v10[1];
      long long v17 = *v10;
      long long v18 = v11;
      float32x4_t v7 = *(float32x4_t *)(a2 + 24);
    }
    else
    {
      long long v17 = 0u;
      long long v18 = 0u;
    }
    CA::OGL::render_shape(*v6, v5, v8, v7, v7.f32[1], v7.f32[2], v7.f32[3], v9, (uint64_t)&v17, *(void *)(a2 + 40), 0);
  }
  if (*(double *)(a2 + 88) != 0.0
    && (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(*(float32x4_t *)(a2 + 48))))) & 1) != 0)
  {
    uint64_t v12 = *(void *)(*(void *)&(*v6)[31] + 24);
    if ((*(unsigned char *)(v12 + 144) & 0x10) != 0) {
      double scale = CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v12, 0, 0, a4);
    }
    else {
      double scale = *(double *)(v12 + 128);
    }
    CA::Render::ShapeLayer::stroke_path((CA::Render::ShapeLayer *)&v16, scale, a2);
    uint64_t v14 = v16;
    *(double *)v15.i64 = CA::Render::ShapeLayer::stroke_bounds((CA::Render::ShapeLayer *)&v17, a2);
    v15.i32[0] = *(_DWORD *)(a2 + 48);
    CA::OGL::render_shape(*v6, v5, (double *)v14, v15, *(float32_t *)(a2 + 52), *(float *)(a2 + 56), *(float *)(a2 + 60), 0, (uint64_t)&v17, *(void *)(a2 + 64), *(double *)(a2 + 88) < 0.0);
    if (v14)
    {
      if (atomic_fetch_add((atomic_uint *volatile)(v14 + 8), 0xFFFFFFFF) == 1) {
        (*(void (**)(uint64_t))(*(void *)v14 + 16))(v14);
      }
    }
  }
}

uint64_t CA::Render::ShapeLayer::get_bounds(CA::Render::ShapeLayer *this, const CA::Render::Layer *a2, CA::Rect *a3, CA::Rect *a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  float32x4_t v7 = (CA::Render::Path *)*((void *)this + 2);
  long long v8 = 0uLL;
  if (v7)
  {
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(*(float32x4_t *)((char *)this + 24))))) & 1) != 0
      || (long long v9 = 0uLL, *((void *)this + 5)))
    {
      uint64_t v10 = (long long *)CA::Render::Path::bounding_rect(v7);
      long long v9 = *v10;
      long long v8 = v10[1];
    }
  }
  else
  {
    long long v9 = 0uLL;
  }
  *(_OWORD *)a3 = v9;
  *((_OWORD *)a3 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v8;
  CA::Render::ShapeLayer::stroke_bounds((CA::Render::ShapeLayer *)&v19, (uint64_t)this);
  float64x2_t v11 = *((float64x2_t *)a3 + 1);
  float64x2_t v12 = v20;
  int64x2_t v13 = vclezq_f64(v11);
  int64x2_t v14 = vclezq_f64(v20);
  int32x2_t v15 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v14, v13), (int8x16_t)vzip2q_s64(v14, v13))));
  if (v15.i8[4])
  {
    if (v15.i8[0]) {
      goto LABEL_12;
    }
    float64x2_t v16 = v19;
  }
  else
  {
    if (v15.i8[0]) {
      goto LABEL_12;
    }
    float64x2_t v17 = vaddq_f64(*(float64x2_t *)a3, v11);
    float64x2_t v16 = vminnmq_f64(*(float64x2_t *)a3, v19);
    float64x2_t v12 = vsubq_f64(vmaxnmq_f64(v17, vaddq_f64(v19, v20)), v16);
  }
  *(float64x2_t *)a3 = v16;
  *((float64x2_t *)a3 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v12;
LABEL_12:
  if (a4)
  {
    *(_OWORD *)a4 = 0u;
    *((_OWORD *)a4 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0u;
  }
  return 1;
}

uint64_t CA::Render::Path::bounding_rect(CA::Render::Path *this)
{
  int v1 = *((_DWORD *)this + 3);
  if ((v1 & 0x100) == 0)
  {
    uint64_t v2 = *((unsigned int *)this + 5);
    float64x2_t v3 = 0uLL;
    if (v2)
    {
      uint64_t v5 = (float64x2_t *)*((void *)this + 4);
      int v4 = (unsigned __int8 *)*((void *)this + 5);
      uint64_t v6 = &v4[v2];
      float64x2_t v7 = (float64x2_t)vdupq_n_s64(0x7FF0000000000000uLL);
      float64x2_t v8 = (float64x2_t)vdupq_n_s64(0xFFF0000000000000);
      do
      {
        int v9 = *v4++;
        switch(v9)
        {
          case 1:
          case 2:
            float64x2_t v7 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(*v5, v7), (int8x16_t)v7, *(int8x16_t *)v5);
            float64x2_t v8 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v8, *v5), (int8x16_t)v8, *(int8x16_t *)v5);
            uint64_t v10 = 1;
            goto LABEL_8;
          case 3:
            float64x2_t v11 = v5[1];
            float64x2_t v12 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(*v5, v7), (int8x16_t)v7, *(int8x16_t *)v5);
            float64x2_t v13 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v8, *v5), (int8x16_t)v8, *(int8x16_t *)v5);
            float64x2_t v7 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v11, v12), (int8x16_t)v12, (int8x16_t)v11);
            float64x2_t v8 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v13, v11), (int8x16_t)v13, (int8x16_t)v11);
            uint64_t v10 = 2;
            goto LABEL_8;
          case 4:
            float64x2_t v14 = v5[1];
            float64x2_t v15 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(*v5, v7), (int8x16_t)v7, *(int8x16_t *)v5);
            float64x2_t v16 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v8, *v5), (int8x16_t)v8, *(int8x16_t *)v5);
            float64x2_t v17 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v14, v15), (int8x16_t)v15, (int8x16_t)v14);
            float64x2_t v18 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v16, v14), (int8x16_t)v16, (int8x16_t)v14);
            float64x2_t v19 = v5[2];
            float64x2_t v7 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v19, v17), (int8x16_t)v17, (int8x16_t)v19);
            float64x2_t v8 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v18, v19), (int8x16_t)v18, (int8x16_t)v19);
            uint64_t v10 = 3;
LABEL_8:
            v5 += v10;
            break;
          default:
            break;
        }
      }
      while (v4 < v6);
      int32x2_t v20 = vmovn_s64(vcgtq_f64(v8, v7));
      char v21 = v20.i8[4] & v20.i8[0];
      float64x2_t v22 = 0uLL;
      if (v21)
      {
        float64x2_t v23 = vrndmq_f64(v7);
        __asm { FMOV            V2.2D, #-1.0 }
        float64x2_t v3 = vaddq_f64(v23, _Q2);
        __asm { FMOV            V2.2D, #1.0 }
        float64x2_t v22 = vsubq_f64(vaddq_f64(vrndpq_f64(v8), _Q2), v3);
      }
    }
    else
    {
      float64x2_t v22 = 0uLL;
    }
    *((float64x2_t *)this + 5) = v3;
    *((float64x2_t *)this + 6) = v22;
    *((_DWORD *)this + 3) = v1 | 0x100;
  }
  return (uint64_t)this + 80;
}

double CA::Render::ShapeLayer::stroke_bounds(CA::Render::ShapeLayer *this, uint64_t a2)
{
  v9[1] = *(CA::Render::Path **)MEMORY[0x1E4F143B8];
  if (*(void *)(a2 + 16)
    && *(double *)(a2 + 88) != 0.0
    && *(double *)(a2 + 80) > *(double *)(a2 + 72)
    && ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(*(float32x4_t *)(a2 + 48))))) & 1) != 0
     || *(void *)(a2 + 64))
    && (v9[0] = 0,
        CA::Render::ShapeLayer::stroke_path((CA::Render::ShapeLayer *)v9, *(double *)(a2 + 144), a2),
        (float64x2_t v3 = (atomic_uint *)v9[0]) != 0))
  {
    int v4 = (long long *)CA::Render::Path::bounding_rect(v9[0]);
    long long v5 = *v4;
    long long v6 = v4[1];
    *(_OWORD *)this = *v4;
    *((_OWORD *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v6;
    if (atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1)
    {
      float64x2_t v7 = *(void (**)(atomic_uint *))(*(void *)v3 + 16);
      v7(v3);
    }
  }
  else
  {
    *(void *)&long long v5 = 0;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0u;
  }
  return *(double *)&v5;
}

void CA::OGL::render_shape(int32x2_t *a1, uint64_t a2, double *a3, float32x4_t a4, float32_t a5, float a6, float a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  if (a3 && (a4.f32[0] != 0.0 || a5 != 0.0 || a6 != 0.0 || a7 != 0.0))
  {
    double v17 = *(double *)(a9 + 16);
    if (v17 >= *(double *)(a9 + 24)) {
      double v17 = *(double *)(a9 + 24);
    }
    if (v17 > 0.0)
    {
      a4.f32[1] = a5;
      int32x2_t v18 = a1[31];
      a4.i64[1] = __PAIR64__(LODWORD(a7), LODWORD(a6));
      float16x4_t v19 = vcvt_f16_f32(a4);
      int32x2_t v20 = *(const CA::Transform **)(*(void *)&v18 + 24);
      float16x4_t v21 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(*(float16x4_t *)(*(void *)&v18 + 32)), vcvtq_f32_f16(v19)));
      if (*(void *)&v19 == 0x3C003C003C003C00) {
        float16x4_t v21 = *(float16x4_t *)(*(void *)&v18 + 32);
      }
      float64x2_t v22 = *(float64x2_t *)(a9 + 16);
      if (*(void *)(*(void *)&v18 + 32) == 0x3C003C003C003C00) {
        float16x4_t v23 = v19;
      }
      else {
        float16x4_t v23 = v21;
      }
      float64x2_t v68 = *(float64x2_t *)a9;
      float64x2_t v69 = v22;
      CA::Rect::apply_transform((int8x16_t *)&v68, v20, a3);
      int32x2_t v66 = 0;
      int32x2_t v67 = 0;
      CA::Shape::get_bounds(*(void *)(*(void *)&v18 + 8), (int *)&v66);
      uint64_t v24 = (int32x2_t *)a1[33];
      if (v24) {
        BOOL v25 = v24 + 4;
      }
      else {
        BOOL v25 = a1 + 25;
      }
      uint32x2_t v26 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v67);
      if ((vpmax_u32(v26, v26).u32[0] & 0x80000000) == 0)
      {
        int32x2_t v27 = v25[1];
        uint32x2_t v28 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v27);
        if ((vpmax_u32(v28, v28).u32[0] & 0x80000000) == 0)
        {
          int32x2_t v29 = vmax_s32(v66, *v25);
          int32x2_t v30 = vsub_s32(vmin_s32(vadd_s32(v66, v67), vadd_s32(*v25, v27)), v29);
          uint32x2_t v31 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v30);
          if ((vpmax_u32(v31, v31).u32[0] & 0x80000000) == 0)
          {
            int64x2_t v32 = vceqzq_f64(v69);
            if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v32, 1), (int8x16_t)v32).u64[0] & 0x8000000000000000) != 0
              || (int8x16_t v33 = vorrq_s8((int8x16_t)vcltzq_f64(v69), (int8x16_t)vcgezq_f64(v69)),
                  (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v33), 1), v33).u64[0] & 0x8000000000000000) != 0))
            {
              v35.i64[0] = 0;
              int32x2_t v36 = 0;
            }
            else
            {
              int32x4_t v34 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v68, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
              int32x4_t v35 = vuzp1q_s32(v34, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v68, v69), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v34));
              int32x2_t v36 = (int32x2_t)v35.u64[1];
            }
            uint32x2_t v37 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v36);
            if ((vpmax_u32(v37, v37).u32[0] & 0x80000000) == 0)
            {
              uint32x2_t v38 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v30);
              if ((vpmax_u32(v38, v38).u32[0] & 0x80000000) == 0)
              {
                int32x2_t v39 = vadd_s32(v29, v30);
                *(int32x2_t *)&long long v40 = vmax_s32(*(int32x2_t *)v35.i8, v29);
                int32x2_t v41 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)v35.i8, v36), v39), *(int32x2_t *)&v40);
                uint32x2_t v42 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v41);
                if ((vpmax_u32(v42, v42).u32[0] & 0x80000000) == 0)
                {
                  *((int32x2_t *)&v40 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v41;
                  long long v65 = v40;
                  if (a10)
                  {
                    uint64_t v43 = *(void *)(a2 + 24);
                    int v44 = *(_DWORD *)(v43 + 36);
                    if ((v44 & 0xFu) > 0xA) {
                      int v45 = 1;
                    }
                    else {
                      int v45 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v44 & 0xF];
                    }
                    uint64_t v48 = v44 >> 4;
                    if (v48 > 0xA) {
                      int v49 = 1;
                    }
                    else {
                      int v49 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v48];
                    }
                    uint64_t v50 = *(void *)(v43 + 128);
                    int v62 = v49;
                    if (v50) {
                      float v51 = *(float *)(v50 + 292);
                    }
                    else {
                      float v51 = 0.0;
                    }
                    uint64_t v61 = *(void *)(*(void *)(a2 + 16) + 24);
                    uint64_t v52 = (*(uint64_t (**)(int32x2_t *, uint64_t, long long *, uint64_t))(*(void *)a1 + 656))(a1, 1, &v65, 15);
                    if (v52)
                    {
                      float v53 = (_DWORD *)v52;
                      uint64_t v74 = 0x3C003C003C003C00;
                      uint64_t v75 = 0;
                      uint64_t v76 = 0;
                      uint64_t v77 = 0;
                      uint64_t v78 = 0;
                      uint64_t v71 = 0;
                      long long v72 = *(_OWORD *)(*(void *)&v18 + 8);
                      uint64_t v73 = *(void *)(*(void *)&v18 + 24);
                      LODWORD(v78) = *(_DWORD *)(*(void *)&v18 + 64);
                      WORD2(v78) = *(_WORD *)(*(void *)&v18 + 68) & 0x500 | 4;
                      memset(v70, 0, sizeof(v70));
                      CA::Shape::operator=((uint64_t)v70, &v65);
                      *(void *)&long long v72 = v70;
                      uint64_t v71 = (void *)CA::OGL::Context::set_gstate((uint64_t)a1, (uint64_t)&v71);
                      CA::OGL::Context::push_surface((uint64_t)a1, (uint64_t)v53, 1u, 2, 0);
                      *(float16x4_t *)(*(void *)&a1[2] + 8) = v23;
                      uint64_t v54 = v73;
                      v64[0] = a3;
                      if (v73)
                      {
                        unsigned int v55 = v45;
                        if ((*(unsigned char *)(v73 + 144) & 0x1F) == 0
                          && *(double *)(v73 + 96) == 0.0
                          && *(double *)(v73 + 104) == 0.0)
                        {
                          uint64_t v54 = 0;
                        }
                      }
                      else
                      {
                        unsigned int v55 = v45;
                      }
                      v64[1] = v54;
                      if (a11)
                      {
                        *(void *)&v63[0].f64[0] = &unk_1ED02BAC0;
                        *(void *)&v63[0].f64[1] = v64;
                        CA::OGL::Shape::render_path((uint64_t)a1);
                      }
                      else
                      {
                        CA::OGL::Shape::fill_path<CA::OGL::RenderPathIterator>((uint64_t)a1);
                      }
                      *(unsigned char *)(*(void *)&a1[2] + 481) |= 1u;
                      v63[0] = 0uLL;
                      CA::OGL::fill_pattern_rect((uint64_t)a1, a10, a9, v63, v73, &v68, v55, v62, v51, v61 & 1, 0);
                      *(unsigned char *)(*(void *)&a1[2] + 481) &= ~1u;
                      CA::OGL::Context::pop_surface((CA::OGL::Context *)a1);
                      CA::OGL::Context::set_gstate((uint64_t)a1, **(void **)&a1[31]);
                      int32x2_t v56 = a1[2];
                      if (*(unsigned __int8 *)(*(void *)&v56 + 480) >= 2u) {
                        *(unsigned char *)(*(void *)&v56 + 481) |= 1u;
                      }
                      int v57 = *(CA::Shape **)(*(void *)&v18 + 8);
                      v63[0] = 0uLL;
                      CA::OGL::emit_combine((uint64_t)a1, 1u, v53, 0, v57, (unsigned int *)v63);
                      *(unsigned char *)(*(void *)&a1[2] + 481) &= ~1u;
                      CA::OGL::Context::release_surface((uint64_t)a1, (uint64_t)v53);
                      if (byte_1EB2ACBE1)
                      {
                        float64_t v60 = *(double *)(*(void *)&v18 + 24);
                        *(void *)&v63[0].f64[0] = a9;
                        v63[0].f64[1] = v60;
                        memset(&v63[1], 0, 32);
                        CA::OGL::fill_color_rect((uint64_t)a1, (uint64_t)v63, (double *)0x80800080, v58, 0.0, v59);
                      }
                    }
                  }
                  else
                  {
                    *(float16x4_t *)(*(void *)&a1[2] + 8) = v23;
                    int32x2_t v46 = a1[2];
                    if (*(unsigned __int8 *)(*(void *)&v46 + 480) >= 2u) {
                      *(unsigned char *)(*(void *)&v46 + 481) |= 1u;
                    }
                    uint64_t v47 = *(void *)(*(void *)&a1[31] + 24);
                    *(void *)&v70[0] = a3;
                    if (v47
                      && (*(unsigned char *)(v47 + 144) & 0x1F) == 0
                      && *(double *)(v47 + 96) == 0.0
                      && *(double *)(v47 + 104) == 0.0)
                    {
                      uint64_t v47 = 0;
                    }
                    *((void *)&v70[0] + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v47;
                    if (a11)
                    {
                      uint64_t v71 = &unk_1ED02BAC0;
                      *(void *)&long long v72 = v70;
                      CA::OGL::Shape::render_path((uint64_t)a1);
                    }
                    else
                    {
                      CA::OGL::Shape::fill_path<CA::OGL::RenderPathIterator>((uint64_t)a1);
                    }
                    *(unsigned char *)(*(void *)&a1[2] + 481) &= ~1u;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void CA::OGL::emit_n_part_rect(uint64_t a1, uint64_t a2, int a3, int a4, float64_t *a5, uint64_t a6, _DWORD *a7, uint64_t a8, _DWORD *a9, uint64_t a10, int a11)
{
  float64x2_t v16 = (CA::OGL::Context *)a1;
  uint64_t v102 = *MEMORY[0x1E4F143B8];
  if (a3 == 3 && a4 == 3)
  {
    CA::OGL::emit_nine_part_rect(a1, a2, (uint64_t)a5, a6, (uint64_t)a7, a8, (uint64_t)a9, a10, a11);
    return;
  }
  if (!(a4 * a3)) {
    return;
  }
  int v17 = a3 + 1;
  int v18 = a4 + 1;
  unsigned int v19 = (a4 + 1) * (a3 + 1);
  if (v19 >= 0x401)
  {
    CA::OGL::emit_n_part_rect_large(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    return;
  }
  uint64_t v95 = (a4 + 1);
  uint64_t v99 = a2;
  int v97 = a4;
  int v94 = a11;
  double v96 = *(char **)(a1 + 120);
  uint64_t v92 = *(void *)(a1 + 136);
  double v98 = (const double *)(v18 * (a3 + 1));
  if (v19 <= v92)
  {
    MEMORY[0x1F4188790](a1);
    double v91 = v16;
    uint32x2_t v28 = (char *)&v89 - v27;
    bzero((char *)&v89 - v27, v29);
    unint64_t v30 = (unint64_t)(v28 + 15);
    float64x2_t v16 = v91;
    unint64_t v90 = v30 & 0xFFFFFFFFFFFFFFF0;
    MEMORY[0x1F4188790](v31);
    double v93 = (const unsigned __int16 *)((char *)&v89 - v32);
    bzero((char *)&v89 - v32, v33);
    uint64_t v24 = (float64x2_t *)v90;
    uint32x2_t v26 = v98;
    uint64_t v23 = v99;
    BOOL v25 = v96;
    int v22 = v97;
  }
  else
  {
    int32x2_t v20 = (const double *)(v18 * (a3 + 1));
    float16x4_t v21 = (char *)malloc_type_malloc(80 * v19 + 8 * (a4 * a3), 0xD074EADDuLL);
    int v22 = v97;
    uint64_t v23 = v99;
    if (!v21) {
      return;
    }
    uint64_t v24 = (float64x2_t *)&v21[48 * v20];
    double v93 = (const unsigned __int16 *)&v24[2 * (void)v20];
    BOOL v25 = v21;
    *((void *)v16 + 15) = v21;
    *((void *)v16 + 17) = v20;
    uint32x2_t v26 = v20;
  }
  uint64_t v34 = v95;
  if ((v22 & 0x80000000) == 0)
  {
    uint64_t v35 = 0;
    int32x2_t v36 = &v24->f64[1];
    uint32x2_t v37 = v25 + 28;
    do
    {
      uint32x2_t v38 = v37;
      int32x2_t v39 = v36;
      long long v40 = a5;
      int32x2_t v41 = a7;
      uint32x2_t v42 = a9;
      uint64_t v43 = (a3 + 1);
      if ((a3 & 0x80000000) == 0)
      {
        do
        {
          *(v39 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *v40;
          float64_t *v39 = *(float64_t *)(a6 + 8 * v35);
          *(_OWORD *)(v39 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = xmmword_184997D60;
          if (a7)
          {
            *(v38 - 3) = *v41;
            *(v38 - 2) = *(_DWORD *)(a8 + 4 * v35);
          }
          if (a9)
          {
            *(v38 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *v42;
            *uint32x2_t v38 = *(_DWORD *)(a10 + 4 * v35);
          }
          ++v42;
          ++v41;
          ++v40;
          v39 += 4;
          v38 += 12;
          --v43;
        }
        while (v43);
      }
      ++v35;
      v36 += 4 * v17;
      v37 += 12 * v17;
    }
    while (v35 != v34);
  }
  int v44 = v16;
  if (a3 <= 0)
  {
    int v46 = v22 - 1;
    uint64_t v48 = v93;
    int v49 = (char *)v93;
    uint64_t v50 = (uint64_t)v25;
  }
  else
  {
    int v45 = 0;
    int v46 = v22 - 1;
    __int16 v47 = (v22 - 1) * v17;
    uint64_t v48 = v93;
    int v49 = (char *)v93;
    uint64_t v50 = (uint64_t)v25;
    do
    {
      *(_WORD *)int v49 = v45;
      int v51 = v45 + 1;
      *((_WORD *)v49 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v45 + 1;
      *((_WORD *)v49 + 2) = a3 + v45 + 2;
      *((_WORD *)v49 + 3) = a3 + v45 + 1;
      if (v22 < 2)
      {
        v49 += 8;
      }
      else
      {
        *((_WORD *)v49 + 4) = v47 + v45;
        *((_WORD *)v49 + 5) = v47 + v45 + 1;
        __int16 v52 = v17 * v22 + v45;
        *((_WORD *)v49 + 6) = v52 + 1;
        *((_WORD *)v49 + 7) = v52;
        v49 += 16;
      }
      int v45 = v51;
    }
    while (a3 != v51);
  }
  if (v22 < 3)
  {
    int8x16_t v59 = v49;
    if (!v26) {
      goto LABEL_50;
    }
    goto LABEL_48;
  }
  __int16 v53 = 0;
  __int16 v54 = 2 * a3;
  int v55 = 1;
  __int16 v56 = 3 * a3;
  do
  {
    *(_WORD *)int v49 = v17 + v53;
    *((_WORD *)v49 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v17 + v53 + 1;
    __int16 v57 = v54 + v53;
    *((_WORD *)v49 + 2) = v54 + v53 + 3;
    *((_WORD *)v49 + 3) = v54 + v53 + 2;
    if (a3 < 2)
    {
      v49 += 8;
    }
    else
    {
      *((_WORD *)v49 + 4) = v57;
      *((_WORD *)v49 + 5) = v57 + 1;
      *((_WORD *)v49 + 6) = v56 + v53 + 2;
      *((_WORD *)v49 + 7) = v56 + v53 + 1;
      v49 += 16;
    }
    ++v55;
    v53 += v17;
  }
  while (v46 != v55);
  int v58 = 1;
  int8x16_t v59 = v49;
  do
  {
    if (a3 <= 2)
    {
      int v60 = v58 + 1;
    }
    else
    {
      int v60 = v58 + 1;
      int v61 = (v58 + 1) * v17 + 1;
      int v62 = v58 * v17 + 2;
      int v63 = a3 - 2;
      do
      {
        *(_WORD *)int8x16_t v59 = v62 - 1;
        *((_WORD *)v59 + 3) = v61++;
        double v64 = v59 + 8;
        *((_WORD *)v59 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v62;
        *((_WORD *)v59 + 2) = v61;
        ++v62;
        v59 += 8;
        --v63;
      }
      while (v63);
      int8x16_t v59 = v64;
    }
    int v58 = v60;
  }
  while (v60 != v46);
  if (v26)
  {
LABEL_48:
    uint64_t v65 = *(void *)(*((void *)v44 + 2) + 8);
    int32x2_t v66 = (void *)(v50 + 32);
    int32x2_t v67 = v26;
    do
    {
      *int32x2_t v66 = v65;
      v66 += 6;
      int32x2_t v67 = (const double *)((char *)v67 - 1);
    }
    while (v67);
  }
LABEL_50:
  float64x2_t v68 = *(void (**)(void))(v23 + 24);
  if (v68)
  {
    float64x2_t v69 = v24;
    v68();
    uint64_t v24 = v69;
    uint32x2_t v26 = v98;
    uint64_t v23 = v99;
  }
  float v70 = v26;
  CA::OGL::transform_vertices(v24, (float32x4_t *)v50, v26, *(float64x2_t **)(v23 + 8));
  uint64_t v71 = v99;
  long long v72 = *(void (**)(uint64_t, uint64_t, const double *))(v99 + 32);
  if (v72)
  {
    v72(v99, v50, v70);
    uint64_t v71 = v99;
  }
  int v73 = *(_DWORD *)(v71 + 20);
  if ((v73 & 0xF) == 0 || (*(unsigned char *)(v71 + 16) & 9) == 0) {
    goto LABEL_61;
  }
  if ((v73 & 4) != 0)
  {
    CA::OGL::aa_adjust_vertices(v50, v50 + 48 * v17, 48, v17);
    uint64_t v71 = v99;
    int v73 = *(_DWORD *)(v99 + 20);
    if ((v73 & 8) == 0)
    {
LABEL_58:
      if ((v73 & 1) == 0) {
        goto LABEL_59;
      }
      goto LABEL_72;
    }
  }
  else if ((v73 & 8) == 0)
  {
    goto LABEL_58;
  }
  CA::OGL::aa_adjust_vertices(v50 + 48 * v17 * v97, v50 + 48 * v46 * v17, 48, v17);
  uint64_t v71 = v99;
  int v73 = *(_DWORD *)(v99 + 20);
  if ((v73 & 1) == 0)
  {
LABEL_59:
    if ((v73 & 2) == 0) {
      goto LABEL_61;
    }
    goto LABEL_60;
  }
LABEL_72:
  CA::OGL::aa_adjust_vertices(v50, v50 + 48, 48 * v17, (int)v95);
  uint64_t v71 = v99;
  if ((*(_DWORD *)(v99 + 20) & 2) != 0)
  {
LABEL_60:
    CA::OGL::aa_adjust_vertices(v50 + 48 * a3, v50 + 48 * a3 - 48, 48 * v17, (int)v95);
    uint64_t v71 = v99;
  }
LABEL_61:
  uint64_t v74 = v71;
  BOOL v75 = CA::OGL::Context::need_transparent_source(v44);
  uint64_t v76 = v59 - v49;
  uint64_t v77 = v44;
  uint64_t v78 = (uint64_t)v44;
  int v79 = v94;
  CA::OGL::emit_mesh_with_center(v78, v74, v48, (v59 - (char *)v48) >> 1, v76 >> 1, v98, v94);
  if ((v79 & 0x40000) != 0 || v75)
  {
    float64x2_t v80 = vcvtq_f64_f32(*(float32x2_t *)(v50 + 8));
    v101[0] = vcvtq_f64_f32(*(float32x2_t *)v50);
    v101[1] = v80;
    double v81 = (float32x2_t *)(v50 + 48 * a3);
    float64x2_t v82 = vcvtq_f64_f32(v81[1]);
    v101[2] = vcvtq_f64_f32(*v81);
    v101[3] = v82;
    double v83 = (float32x2_t *)(v50 + 48 * (v17 * v97 + a3));
    float64x2_t v84 = vcvtq_f64_f32(v83[1]);
    v101[4] = vcvtq_f64_f32(*v83);
    v101[5] = v84;
    double v85 = (float32x2_t *)(v50 + 48 * v17 * v97);
    float64x2_t v86 = vcvtq_f64_f32(v85[1]);
    v101[6] = vcvtq_f64_f32(*v85);
    v101[7] = v86;
    if ((v79 & 0x40000) != 0) {
      uint64_t v87 = *(void *)(*((void *)v77 + 2) + 8);
    }
    else {
      uint64_t v87 = 0;
    }
    uint64_t v100 = v87;
    CA::OGL::emit_quad_surround((uint64_t)v77, (const double *)v101, &v100);
  }
  if ((char *)v50 != v96)
  {
    uint64_t v88 = v92;
    *((void *)v77 + 15) = v96;
    *((void *)v77 + 17) = v88;
    free((void *)v50);
  }
}

void CA::Render::ShapeLayer::stroke_path(CA::Render::ShapeLayer *this, double a2, uint64_t a3)
{
  v26[1] = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ShapeLayer::_stroke_lock);
  if (*(void *)(a3 + 136) && vabdd_f64(*(double *)(a3 + 144), a2) <= 0.1) {
    goto LABEL_42;
  }
  long long v6 = *(atomic_uint **)(a3 + 16);
  if (!v6) {
    goto LABEL_42;
  }
  uint64_t v7 = *(void *)(a3 + 112);
  if (v7 && (unint64_t v8 = *(unsigned int *)(v7 + 16), v8))
  {
    if (v8 > 0x200)
    {
      uint64_t v10 = (char *)malloc_type_malloc(8 * v8, 0x314C5196uLL);
      uint64_t v7 = *(void *)(a3 + 112);
    }
    else
    {
      MEMORY[0x1F4188790](v6);
      uint64_t v10 = (char *)v26 - ((v9 + 15) & 0xFFFFFFFF0);
      bzero(v10, v9);
    }
    uint64_t v11 = 0;
    if (v8 <= 1) {
      uint64_t v12 = 1;
    }
    else {
      uint64_t v12 = v8;
    }
    uint64_t v13 = 8 * v12;
    do
    {
      *(void *)&v10[v11] = *(void *)(v7 + 24 + v11);
      v11 += 8;
    }
    while (v13 != v11);
    long long v6 = *(atomic_uint **)(a3 + 16);
  }
  else
  {
    unint64_t v8 = 0;
    uint64_t v10 = 0;
  }
  double v14 = fmax(*(double *)(a3 + 72), 0.0);
  double v15 = fmin(*(double *)(a3 + 80), 1.0);
  if (v14 >= v15)
  {
    float16x4_t v21 = 0;
LABEL_29:
    int32x2_t v20 = 0;
    goto LABEL_30;
  }
  double v16 = *(double *)(a3 + 88);
  int v17 = *(_DWORD *)(a3 + 120);
  if (v14 == 0.0 && v15 == 1.0)
  {
    float16x4_t v21 = CA::Render::Path::stroke(v6, *(double *)(a3 + 88), BYTE2(v17), BYTE1(v17), v8);
  }
  else
  {
    unsigned int v19 = CA::Render::Path::copy_subpath((CA::Render::Path *)v6, v14, v15);
    int32x2_t v20 = (atomic_uint *)v19;
    if (!v19)
    {
      float16x4_t v21 = 0;
      goto LABEL_30;
    }
    float16x4_t v21 = CA::Render::Path::stroke((atomic_uint *)v19, v16, BYTE2(v17), BYTE1(v17), v8);
    if (atomic_fetch_add(v20 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v20 + 16))(v20);
    }
  }
  if (!v21) {
    goto LABEL_29;
  }
  if (atomic_fetch_add(v21 + 2, 1u))
  {
    int32x2_t v20 = v21;
  }
  else
  {
    int32x2_t v20 = 0;
    atomic_fetch_add(v21 + 2, 0xFFFFFFFF);
  }
LABEL_30:
  if (v8 >= 0x201 && v10) {
    free(v10);
  }
  uint64_t v22 = *(void *)(a3 + 128);
  if (v22 && !*(void *)(v22 + 136))
  {
    *(void *)(v22 + 136) = v20;
    *(double *)(v22 + 144) = a2;
    uint64_t v23 = *(atomic_uint **)(a3 + 136);
    *(void *)(a3 + 136) = v21;
    *(double *)(a3 + 144) = a2;
    if (!v23) {
      goto LABEL_42;
    }
    goto LABEL_39;
  }
  uint64_t v23 = *(atomic_uint **)(a3 + 136);
  *(void *)(a3 + 136) = v21;
  *(double *)(a3 + 144) = a2;
  if (v20 && atomic_fetch_add(v20 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v20 + 16))(v20);
  }
  if (v23)
  {
LABEL_39:
    if (atomic_fetch_add(v23 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v23 + 16))(v23);
    }
  }
LABEL_42:
  uint64_t v24 = *(void *)(a3 + 136);
  if (v24)
  {
    BOOL v25 = (atomic_uint *)(v24 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v24 + 8), 1u))
    {
      uint64_t v24 = 0;
      atomic_fetch_add(v25, 0xFFFFFFFF);
    }
  }
  *(void *)this = v24;
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ShapeLayer::_stroke_lock);
}

void CA::Render::anonymous namespace'::Compressor::add_rect(CA::Render::_anonymous_namespace_::Compressor *this, double a2, double a3, double a4, double a5)
{
  if (a2 <= a4) {
    double v6 = a4;
  }
  else {
    double v6 = a2;
  }
  if (a2 <= a4) {
    double v7 = a2;
  }
  else {
    double v7 = a4;
  }
  if (a3 <= a5) {
    double v8 = a5;
  }
  else {
    double v8 = a3;
  }
  if (a3 <= a5) {
    double v9 = a3;
  }
  else {
    double v9 = a5;
  }
  double v10 = vabdd_f64(v9, v8);
  if (vabdd_f64(v7, v6) >= 0.000001)
  {
    if (v10 >= 0.000001)
    {
      double v17 = *(double *)this;
      double v18 = v7 - *(double *)this;
      double v19 = *(double *)this + v6;
      float16x4_t v21 = (double *)*((void *)this + 8);
      unint64_t v20 = *((void *)this + 9);
      if ((unint64_t)v21 >= v20)
      {
        int32x2_t v39 = (double *)*((void *)this + 7);
        uint64_t v40 = ((char *)v21 - (char *)v39) >> 4;
        unint64_t v41 = v40 + 1;
        if ((unint64_t)(v40 + 1) >> 60) {
          goto LABEL_130;
        }
        uint64_t v42 = v20 - (void)v39;
        if (v42 >> 3 > v41) {
          unint64_t v41 = v42 >> 3;
        }
        if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v43 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v43 = v41;
        }
        if (v43 >> 60) {
          goto LABEL_131;
        }
        int v44 = (char *)operator new(16 * v43);
        int v45 = (double *)&v44[16 * v40];
        *int v45 = v18;
        v45[1] = v19;
        uint64_t v22 = v45 + 2;
        while (v21 != v39)
        {
          long long v46 = *((_OWORD *)v21 - 1);
          v21 -= 2;
          *((_OWORD *)v45 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v46;
          v45 -= 2;
        }
        *((void *)this + 7) = v45;
        *((void *)this + 8) = v22;
        *((void *)this + 9) = &v44[16 * v43];
        if (v39)
        {
          operator delete(v39);
          double v17 = *(double *)this;
        }
      }
      else
      {
        double *v21 = v18;
        v21[1] = v19;
        uint64_t v22 = v21 + 2;
      }
      *((void *)this + 8) = v22;
      double v75 = v9 - v17;
      double v76 = v17 + v8;
      __int16 v52 = (double *)*((void *)this + 14);
      unint64_t v77 = *((void *)this + 15);
      if ((unint64_t)v52 < v77)
      {
        *__int16 v52 = v75;
LABEL_98:
        v52[1] = v76;
        float64x2_t v86 = v52 + 2;
LABEL_111:
        *((void *)this + 14) = v86;
        return;
      }
      uint64_t v78 = (double *)*((void *)this + 13);
      uint64_t v79 = ((char *)v52 - (char *)v78) >> 4;
      unint64_t v80 = v79 + 1;
      if (!((unint64_t)(v79 + 1) >> 60))
      {
        uint64_t v81 = v77 - (void)v78;
        if (v81 >> 3 > v80) {
          unint64_t v80 = v81 >> 3;
        }
        if ((unint64_t)v81 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v82 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v82 = v80;
        }
        if (!(v82 >> 60))
        {
          double v83 = (char *)operator new(16 * v82);
          float64x2_t v84 = (double *)&v83[16 * v79];
          double v85 = &v83[16 * v82];
          *float64x2_t v84 = v75;
          v84[1] = v76;
          float64x2_t v86 = v84 + 2;
          while (v52 != v78)
          {
            long long v87 = *((_OWORD *)v52 - 1);
            v52 -= 2;
            *((_OWORD *)v84 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v87;
            v84 -= 2;
          }
          goto LABEL_109;
        }
LABEL_131:
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      goto LABEL_130;
    }
    double v15 = (double *)*((void *)this + 5);
    unint64_t v14 = *((void *)this + 6);
    if ((unint64_t)v15 >= v14)
    {
      uint64_t v31 = (double *)*((void *)this + 4);
      uint64_t v32 = ((char *)v15 - (char *)v31) >> 4;
      unint64_t v33 = v32 + 1;
      if ((unint64_t)(v32 + 1) >> 60) {
        goto LABEL_130;
      }
      uint64_t v34 = v14 - (void)v31;
      if (v34 >> 3 > v33) {
        unint64_t v33 = v34 >> 3;
      }
      if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v35 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v35 = v33;
      }
      if (v35 >> 60) {
        goto LABEL_131;
      }
      int32x2_t v36 = (char *)operator new(16 * v35);
      uint32x2_t v37 = (double *)&v36[16 * v32];
      *uint32x2_t v37 = v7;
      v37[1] = v6;
      double v16 = v37 + 2;
      while (v15 != v31)
      {
        long long v38 = *((_OWORD *)v15 - 1);
        v15 -= 2;
        *((_OWORD *)v37 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v38;
        v37 -= 2;
      }
      *((void *)this + 4) = v37;
      *((void *)this + 5) = v16;
      *((void *)this + 6) = &v36[16 * v35];
      if (v31) {
        operator delete(v31);
      }
    }
    else
    {
      *double v15 = v7;
      v15[1] = v6;
      double v16 = v15 + 2;
    }
    *((void *)this + 5) = v16;
    double v61 = *(double *)this;
    double v62 = v7 - *(double *)this;
    double v63 = *(double *)this + v7;
    uint64_t v65 = (double *)*((void *)this + 8);
    double v64 = (double *)*((void *)this + 9);
    if (v65 >= v64)
    {
      int32x2_t v67 = (double *)*((void *)this + 7);
      uint64_t v68 = ((char *)v65 - (char *)v67) >> 4;
      unint64_t v69 = v68 + 1;
      if ((unint64_t)(v68 + 1) >> 60) {
        goto LABEL_130;
      }
      uint64_t v70 = (char *)v64 - (char *)v67;
      if (v70 >> 3 > v69) {
        unint64_t v69 = v70 >> 3;
      }
      if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v71 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v71 = v69;
      }
      if (v71 >> 60) {
        goto LABEL_131;
      }
      long long v72 = (char *)operator new(16 * v71);
      int v73 = (double *)&v72[16 * v68];
      double v64 = (double *)&v72[16 * v71];
      double *v73 = v62;
      v73[1] = v63;
      int32x2_t v66 = v73 + 2;
      while (v65 != v67)
      {
        long long v74 = *((_OWORD *)v65 - 1);
        v65 -= 2;
        *((_OWORD *)v73 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v74;
        v73 -= 2;
      }
      *((void *)this + 7) = v73;
      *((void *)this + 8) = v66;
      *((void *)this + 9) = v64;
      if (v67)
      {
        operator delete(v67);
        double v61 = *(double *)this;
        double v64 = (double *)*((void *)this + 9);
      }
    }
    else
    {
      *uint64_t v65 = v62;
      v65[1] = v63;
      int32x2_t v66 = v65 + 2;
    }
    *((void *)this + 8) = v66;
    double v95 = v6 - v61;
    double v96 = v61 + v6;
    if (v66 >= v64)
    {
      double v98 = (double *)*((void *)this + 7);
      uint64_t v99 = ((char *)v66 - (char *)v98) >> 4;
      unint64_t v100 = v99 + 1;
      if ((unint64_t)(v99 + 1) >> 60) {
        goto LABEL_130;
      }
      uint64_t v101 = (char *)v64 - (char *)v98;
      if (v101 >> 3 > v100) {
        unint64_t v100 = v101 >> 3;
      }
      if ((unint64_t)v101 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v102 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v102 = v100;
      }
      if (v102 >> 60) {
        goto LABEL_131;
      }
      double v103 = (char *)operator new(16 * v102);
      double v104 = (double *)&v103[16 * v99];
      *double v104 = v95;
      v104[1] = v96;
      int v97 = v104 + 2;
      while (v66 != v98)
      {
        long long v105 = *((_OWORD *)v66 - 1);
        v66 -= 2;
        *((_OWORD *)v104 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v105;
        v104 -= 2;
      }
      *((void *)this + 7) = v104;
      *((void *)this + 8) = v97;
      *((void *)this + 9) = &v103[16 * v102];
      if (v98) {
        operator delete(v98);
      }
    }
    else
    {
      *int32x2_t v66 = v95;
      v66[1] = v96;
      int v97 = v66 + 2;
    }
    *((void *)this + 8) = v97;
  }
  else if (v10 >= 0.000001)
  {
    uint64_t v12 = (double *)*((void *)this + 11);
    unint64_t v11 = *((void *)this + 12);
    if ((unint64_t)v12 >= v11)
    {
      uint64_t v23 = (double *)*((void *)this + 10);
      uint64_t v24 = ((char *)v12 - (char *)v23) >> 4;
      unint64_t v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) >> 60) {
        goto LABEL_130;
      }
      uint64_t v26 = v11 - (void)v23;
      if (v26 >> 3 > v25) {
        unint64_t v25 = v26 >> 3;
      }
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v27 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v27 = v25;
      }
      if (v27 >> 60) {
        goto LABEL_131;
      }
      uint32x2_t v28 = (char *)operator new(16 * v27);
      size_t v29 = (double *)&v28[16 * v24];
      double *v29 = v9;
      v29[1] = v8;
      uint64_t v13 = v29 + 2;
      while (v12 != v23)
      {
        long long v30 = *((_OWORD *)v12 - 1);
        v12 -= 2;
        *((_OWORD *)v29 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v30;
        v29 -= 2;
      }
      *((void *)this + 1CA::Context::unref(this[1], 0) = v29;
      *((void *)this + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v13;
      *((void *)this + 12) = &v28[16 * v27];
      if (v23) {
        operator delete(v23);
      }
    }
    else
    {
      *uint64_t v12 = v9;
      v12[1] = v8;
      uint64_t v13 = v12 + 2;
    }
    *((void *)this + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v13;
    double v47 = *(double *)this;
    double v48 = v9 - *(double *)this;
    double v49 = *(double *)this + v9;
    int v51 = (double *)*((void *)this + 14);
    uint64_t v50 = (double *)*((void *)this + 15);
    if (v51 >= v50)
    {
      __int16 v53 = (double *)*((void *)this + 13);
      uint64_t v54 = ((char *)v51 - (char *)v53) >> 4;
      unint64_t v55 = v54 + 1;
      if ((unint64_t)(v54 + 1) >> 60) {
        goto LABEL_130;
      }
      uint64_t v56 = (char *)v50 - (char *)v53;
      if (v56 >> 3 > v55) {
        unint64_t v55 = v56 >> 3;
      }
      if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v57 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v57 = v55;
      }
      if (v57 >> 60) {
        goto LABEL_131;
      }
      int v58 = (char *)operator new(16 * v57);
      int8x16_t v59 = (double *)&v58[16 * v54];
      uint64_t v50 = (double *)&v58[16 * v57];
      double *v59 = v48;
      v59[1] = v49;
      __int16 v52 = v59 + 2;
      while (v51 != v53)
      {
        long long v60 = *((_OWORD *)v51 - 1);
        v51 -= 2;
        *((_OWORD *)v59 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v60;
        v59 -= 2;
      }
      *((void *)this + 13) = v59;
      *((void *)this + 14) = v52;
      *((void *)this + 15) = v50;
      if (v53)
      {
        operator delete(v53);
        double v47 = *(double *)this;
        uint64_t v50 = (double *)*((void *)this + 15);
      }
    }
    else
    {
      *int v51 = v48;
      v51[1] = v49;
      __int16 v52 = v51 + 2;
    }
    *((void *)this + 14) = v52;
    double v88 = v8 - v47;
    double v76 = v47 + v8;
    if (v52 < v50)
    {
      *__int16 v52 = v88;
      goto LABEL_98;
    }
    uint64_t v78 = (double *)*((void *)this + 13);
    uint64_t v89 = ((char *)v52 - (char *)v78) >> 4;
    unint64_t v90 = v89 + 1;
    if (!((unint64_t)(v89 + 1) >> 60))
    {
      uint64_t v91 = (char *)v50 - (char *)v78;
      if (v91 >> 3 > v90) {
        unint64_t v90 = v91 >> 3;
      }
      if ((unint64_t)v91 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v92 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v92 = v90;
      }
      if (!(v92 >> 60))
      {
        double v93 = (char *)operator new(16 * v92);
        float64x2_t v84 = (double *)&v93[16 * v89];
        double v85 = &v93[16 * v92];
        *float64x2_t v84 = v88;
        v84[1] = v76;
        float64x2_t v86 = v84 + 2;
        while (v52 != v78)
        {
          long long v94 = *((_OWORD *)v52 - 1);
          v52 -= 2;
          *((_OWORD *)v84 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v94;
          v84 -= 2;
        }
LABEL_109:
        *((void *)this + 13) = v84;
        *((void *)this + 14) = v86;
        *((void *)this + 15) = v85;
        if (v78) {
          operator delete(v78);
        }
        goto LABEL_111;
      }
      goto LABEL_131;
    }
LABEL_130:
    abort();
  }
}

uint64_t CA::OGL::Context::shadow_cache(CA::OGL::Context *this)
{
  uint64_t v1 = *((void *)this + 51);
  if (!v1)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    int v4 = malloc_type_zone_malloc(malloc_zone, 0x20uLL, 0x8BB15036uLL);
    uint64_t v1 = (uint64_t)v4;
    if (v4)
    {
      id v4[2] = 0;
      *((_DWORD *)v4 + 6) = 0;
      *int v4 = x_hash_table_new_(0, 0, 0, 0, 0, 0);
      *(void *)(v1 + 8) = 0;
      CA::Render::add_observer(0xAu, 0, (uint64_t)CA::Render::ShadowCache::path_deleted, v1, 0);
    }
    *((void *)this + 5CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v1;
  }
  return v1;
}

uint64_t CA::ScanConverter::Path::quadto(CA::ScanConverter::Path *this, double a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (*((double *)this + 10) != 1.0) {
    return CA::ScanConverter::Path::quadto(this, a2, a3, 1.0, a4, a5, 1.0, a6, a7, a8, a9, a10, a11, a12);
  }
  double v12 = *((double *)this + 8);
  double v13 = *((double *)this + 9);
  *((double *)this + 8) = a4;
  *((double *)this + 9) = a5;
  return CA::ScanConverter::Path::add_cube((uint64_t)this, v12, v13, (v12 + a2 + a2) * 0.333333333, (v13 + a3 + a3) * 0.333333333, (a2 + a2 + a4) * 0.333333333, (a3 + a3 + a5) * 0.333333333, a4, a5);
}

int8x16_t *CA::Render::ShadowCache::lookup_rounded_rect_path(uint64_t a1, double *a2, double *a3, int a4)
{
  uint64_t v125 = *MEMORY[0x1E4F143B8];
  double v8 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  double v9 = *(void **)(a1 + 8);
  if (v9)
  {
    double v10 = *(uint64_t **)(a1 + 8);
    while (1)
    {
      unint64_t v11 = (double *)*v10;
      if (*(double *)*v10 == *a2
        && v11[1] == a2[1]
        && v11[2] == a2[2]
        && v11[3] == a2[3]
        && *((unsigned __int8 *)v11 + 112) == a4
        && v11[4] == *a3
        && v11[5] == a3[1]
        && v11[6] == a3[2]
        && v11[7] == a3[3]
        && v11[8] == a3[4]
        && v11[9] == a3[5]
        && v11[10] == a3[6]
        && v11[11] == a3[7])
      {
        break;
      }
      double v10 = (uint64_t *)v10[1];
      if (!v10) {
        goto LABEL_17;
      }
    }
    uint64_t v99 = x_list_remove(v9, *v10);
    *(void *)(a1 + 8) = v99;
    *(void *)(a1 + 8) = x_list_prepend((uint64_t)v99, (uint64_t)v11);
    uint64_t v100 = mach_absolute_time();
    v11[12] = CATimeWithHostTime(v100);
    float64x2_t v86 = (int8x16_t *)*((void *)v11 + 13);
    int v97 = v8;
    goto LABEL_62;
  }
LABEL_17:
  os_unfair_lock_unlock(v8);
  long long v12 = *((_OWORD *)a3 + 1);
  long long v13 = *((_OWORD *)a3 + 2);
  v110[0] = *(_OWORD *)a3;
  v110[1] = v12;
  long long v14 = *((_OWORD *)a3 + 3);
  v110[2] = v13;
  v110[3] = v14;
  CFDictionaryRef Mutable = CGPathCreateMutable();
  double v17 = Mutable;
  float64x2_t v18 = *(float64x2_t *)(a2 + 2);
  int32x2_t v19 = vmovn_s64(vclezq_f64(v18));
  if (((v19.i32[0] | v19.i32[1]) & 1) == 0)
  {
    uint64_t v20 = 0;
    double v21 = *a2;
    double v22 = a2[1];
    long long v123 = 0u;
    long long v124 = 0u;
    long long v121 = 0u;
    long long v122 = 0u;
    int8x16_t v23 = (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v18.f64[0], 0);
    int8x16_t v24 = (int8x16_t)vdupq_laneq_s64((int64x2_t)v18, 1);
    do
    {
      unint64_t v25 = (const double *)&v110[v20];
      float64x2x2_t v126 = vld2q_f64(v25);
      int8x16_t v26 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v23, v126.val[0]), (int8x16_t)v126.val[0], v23);
      v127.val[0] = (float64x2_t)vbicq_s8(v26, (int8x16_t)vcltzq_f64((float64x2_t)v26));
      v126.val[0] = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v24, v126.val[1]), (int8x16_t)v126.val[1], v24);
      v127.val[1] = (float64x2_t)vbicq_s8((int8x16_t)v126.val[0], (int8x16_t)vcltzq_f64(v126.val[0]));
      unint64_t v27 = (double *)((char *)&v121 + v20 * 16);
      vst2q_f64(v27, v127);
      v20 += 2;
    }
    while (v20 != 4);
    double v28 = *(double *)&v121;
    double v29 = *(double *)&v122;
    if (*(double *)&v122 + *(double *)&v121 > v18.f64[0])
    {
      float64_t v30 = v18.f64[0] / (*(double *)&v122 + *(double *)&v121);
      double v29 = v30 * *(double *)&v122;
      double v28 = v30 * *(double *)&v121;
    }
    double v31 = *(double *)&v123;
    double v32 = *(double *)&v124;
    double v109 = v28;
    if (*(double *)&v124 + *(double *)&v123 > v18.f64[0])
    {
      float64_t v33 = v18.f64[0] / (*(double *)&v124 + *(double *)&v123);
      double v31 = v33 * *(double *)&v123;
      double v32 = v33 * *(double *)&v124;
    }
    double v34 = *((double *)&v122 + 1);
    double v35 = *((double *)&v123 + 1);
    if (*((double *)&v123 + 1) + *((double *)&v122 + 1) > v18.f64[1])
    {
      float64_t v36 = v18.f64[1] / (*((double *)&v123 + 1) + *((double *)&v122 + 1));
      double v34 = v36 * *((double *)&v122 + 1);
      double v35 = v36 * *((double *)&v123 + 1);
    }
    double v37 = *((double *)&v121 + 1);
    double v38 = *((double *)&v124 + 1);
    if (*((double *)&v124 + 1) + *((double *)&v121 + 1) > v18.f64[1])
    {
      float64_t v39 = v18.f64[1] / (*((double *)&v124 + 1) + *((double *)&v121 + 1));
      double v38 = v39 * *((double *)&v124 + 1);
      double v37 = v39 * *((double *)&v121 + 1);
    }
    long long v119 = 0u;
    long long v120 = 0u;
    long long v117 = 0u;
    long long v118 = 0u;
    long long v115 = 0u;
    long long v116 = 0u;
    long long v113 = 0u;
    long long v114 = 0u;
    long long v111 = 0u;
    long long v112 = 0u;
    double v107 = v29;
    double v108 = v37;
    double v105 = v31;
    double v106 = v34;
    double v104 = v35;
    if (a4)
    {
      v40.f64[0] = v32;
      v40.f64[1] = v38;
      int8x16_t v41 = (int8x16_t)vaddq_f64(vdivq_f64(vmulq_f64(v18, (float64x2_t)vdupq_n_s64(0xBFEE43E411A05F26)), v40), (float64x2_t)vdupq_n_s64(0x400721F208D02F93uLL));
      __asm { FMOV            V2.2D, #1.0 }
      int8x16_t v47 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v41, (float64x2_t)_Q2), _Q2, v41);
      _Q1 = (int64x2_t)vbicq_s8(v47, (int8x16_t)vcltzq_f64((float64x2_t)v47));
    }
    else
    {
      __asm { FMOV            V1.2D, #1.0 }
    }
    uint64_t v49 = 0;
    float64x2_t v101 = v18;
    double v50 = v21 + v18.f64[0];
    double v51 = v22 + v18.f64[1];
    float64x2_t v52 = (float64x2_t)vdupq_lane_s64(_Q1.i64[0], 0);
    float64x2_t v53 = (float64x2_t)vdupq_laneq_s64(_Q1, 1);
    do
    {
      float64x2_t v54 = (float64x2_t)continuous_p[v49];
      float64x2_t v55 = vsubq_f64((float64x2_t)circular_p[v49], v54);
      *(long long *)((char *)&v116 + v49 * 16) = (__int128)vmlaq_f64(v54, v52, v55);
      *(long long *)((char *)&v111 + v49 * 16) = (__int128)vmlaq_f64(v54, v53, v55);
      ++v49;
    }
    while (v49 != 5);
    double v102 = v38;
    double v103 = v32;
    CGPathMoveToPoint(Mutable, 0, v21 + *((double *)&v115 + 1) * v32, v22 + *(double *)&v111 * v38);
    CGPathAddCurveToPoint(v17, 0, v21 + *(double *)&v115 * v103, v22 + *((double *)&v111 + 1) * v102, v21 + *((double *)&v114 + 1) * v103, v22 + *(double *)&v112 * v102, v21 + *(double *)&v114 * v103, v22 + *((double *)&v112 + 1) * v102);
    CGPathAddCurveToPoint(v17, 0, v21 + *((double *)&v113 + 1) * v103, v22 + *(double *)&v113 * v102, v21 + *(double *)&v118 * v103, v22 + *((double *)&v113 + 1) * v102, v21 + *((double *)&v117 + 1) * v103, v22 + *(double *)&v119 * v102);
    CGPathAddCurveToPoint(v17, 0, v21 + *(double *)&v117 * v103, v22 + *((double *)&v119 + 1) * v102, v21 + *((double *)&v116 + 1) * v103, v22 + *(double *)&v120 * v102, v21 + *(double *)&v116 * v103, v22 + *((double *)&v120 + 1) * v102);
    if (a4)
    {
      v56.f64[0] = v105;
      v56.f64[1] = v104;
      int8x16_t v57 = (int8x16_t)vaddq_f64(vdivq_f64(vmulq_f64(v101, (float64x2_t)vdupq_n_s64(0xBFEE43E411A05F26)), v56), (float64x2_t)vdupq_n_s64(0x400721F208D02F93uLL));
      __asm { FMOV            V1.2D, #1.0 }
      int8x16_t v59 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v57, (float64x2_t)_Q1), _Q1, v57);
      _Q1 = (int64x2_t)vbicq_s8(v59, (int8x16_t)vcltzq_f64((float64x2_t)v59));
    }
    else
    {
      __asm { FMOV            V1.2D, #1.0 }
    }
    uint64_t v61 = 0;
    float64x2_t v62 = (float64x2_t)vdupq_lane_s64(_Q1.i64[0], 0);
    float64x2_t v63 = (float64x2_t)vdupq_laneq_s64(_Q1, 1);
    do
    {
      float64x2_t v64 = (float64x2_t)continuous_p[v61];
      float64x2_t v65 = vsubq_f64((float64x2_t)circular_p[v61], v64);
      *(long long *)((char *)&v116 + v61 * 16) = (__int128)vmlaq_f64(v64, v62, v65);
      *(long long *)((char *)&v111 + v61 * 16) = (__int128)vmlaq_f64(v64, v63, v65);
      ++v61;
    }
    while (v61 != 5);
    CGPathAddLineToPoint(v17, 0, v50 - *(double *)&v116 * v105, v22 + *((double *)&v120 + 1) * v104);
    CGPathAddCurveToPoint(v17, 0, v50 - *((double *)&v116 + 1) * v105, v22 + *(double *)&v120 * v104, v50 - *(double *)&v117 * v105, v22 + *((double *)&v119 + 1) * v104, v50 - *((double *)&v117 + 1) * v105, v22 + *(double *)&v119 * v104);
    CGPathAddCurveToPoint(v17, 0, v50 - *(double *)&v118 * v105, v22 + *((double *)&v118 + 1) * v104, v50 - *((double *)&v118 + 1) * v105, v22 + *(double *)&v113 * v104, v50 - *(double *)&v114 * v105, v22 + *((double *)&v112 + 1) * v104);
    CGPathAddCurveToPoint(v17, 0, v50 - *((double *)&v114 + 1) * v105, v22 + *(double *)&v112 * v104, v50 - *(double *)&v115 * v105, v22 + *((double *)&v111 + 1) * v104, v50 - *((double *)&v115 + 1) * v105, v22 + *(double *)&v111 * v104);
    if (a4)
    {
      v66.f64[0] = v107;
      v66.f64[1] = v106;
      int8x16_t v67 = (int8x16_t)vaddq_f64(vdivq_f64(vmulq_f64(v101, (float64x2_t)vdupq_n_s64(0xBFEE43E411A05F26)), v66), (float64x2_t)vdupq_n_s64(0x400721F208D02F93uLL));
      __asm { FMOV            V1.2D, #1.0 }
      int8x16_t v69 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v67, (float64x2_t)_Q1), _Q1, v67);
      _Q1 = (int64x2_t)vbicq_s8(v69, (int8x16_t)vcltzq_f64((float64x2_t)v69));
    }
    else
    {
      __asm { FMOV            V1.2D, #1.0 }
    }
    uint64_t v71 = 0;
    float64x2_t v72 = (float64x2_t)vdupq_lane_s64(_Q1.i64[0], 0);
    float64x2_t v73 = (float64x2_t)vdupq_laneq_s64(_Q1, 1);
    do
    {
      float64x2_t v74 = (float64x2_t)continuous_p[v71];
      float64x2_t v75 = vsubq_f64((float64x2_t)circular_p[v71], v74);
      *(long long *)((char *)&v116 + v71 * 16) = (__int128)vmlaq_f64(v74, v72, v75);
      *(long long *)((char *)&v111 + v71 * 16) = (__int128)vmlaq_f64(v74, v73, v75);
      ++v71;
    }
    while (v71 != 5);
    CGPathAddLineToPoint(v17, 0, v50 - *((double *)&v115 + 1) * v107, v51 - *(double *)&v111 * v106);
    CGPathAddCurveToPoint(v17, 0, v50 - *(double *)&v115 * v107, v51 - *((double *)&v111 + 1) * v106, v50 - *((double *)&v114 + 1) * v107, v51 - *(double *)&v112 * v106, v50 - *(double *)&v114 * v107, v51 - *((double *)&v112 + 1) * v106);
    CGPathAddCurveToPoint(v17, 0, v50 - *((double *)&v113 + 1) * v107, v51 - *(double *)&v113 * v106, v50 - *(double *)&v118 * v107, v51 - *((double *)&v113 + 1) * v106, v50 - *((double *)&v117 + 1) * v107, v51 - *(double *)&v119 * v106);
    CGPathAddCurveToPoint(v17, 0, v50 - *(double *)&v117 * v107, v51 - *((double *)&v119 + 1) * v106, v50 - *((double *)&v116 + 1) * v107, v51 - *(double *)&v120 * v106, v50 - *(double *)&v116 * v107, v51 - *((double *)&v120 + 1) * v106);
    if (a4)
    {
      v76.f64[0] = v109;
      v76.f64[1] = v108;
      int8x16_t v77 = (int8x16_t)vaddq_f64(vdivq_f64(vmulq_f64(v101, (float64x2_t)vdupq_n_s64(0xBFEE43E411A05F26)), v76), (float64x2_t)vdupq_n_s64(0x400721F208D02F93uLL));
      __asm { FMOV            V1.2D, #1.0 }
      int8x16_t v79 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v77, (float64x2_t)_Q1), _Q1, v77);
      _Q1 = (int64x2_t)vbicq_s8(v79, (int8x16_t)vcltzq_f64((float64x2_t)v79));
    }
    else
    {
      __asm { FMOV            V1.2D, #1.0 }
    }
    uint64_t v81 = 0;
    float64x2_t v82 = (float64x2_t)vdupq_lane_s64(_Q1.i64[0], 0);
    float64x2_t v83 = (float64x2_t)vdupq_laneq_s64(_Q1, 1);
    do
    {
      float64x2_t v84 = (float64x2_t)continuous_p[v81];
      float64x2_t v85 = vsubq_f64((float64x2_t)circular_p[v81], v84);
      *(long long *)((char *)&v116 + v81 * 16) = (__int128)vmlaq_f64(v84, v82, v85);
      *(long long *)((char *)&v111 + v81 * 16) = (__int128)vmlaq_f64(v84, v83, v85);
      ++v81;
    }
    while (v81 != 5);
    CGPathAddLineToPoint(v17, 0, v21 + *(double *)&v116 * v109, v51 - *((double *)&v120 + 1) * v108);
    CGPathAddCurveToPoint(v17, 0, v21 + *((double *)&v116 + 1) * v109, v51 - *(double *)&v120 * v108, v21 + *(double *)&v117 * v109, v51 - *((double *)&v119 + 1) * v108, v21 + *((double *)&v117 + 1) * v109, v51 - *(double *)&v119 * v108);
    CGPathAddCurveToPoint(v17, 0, v21 + *(double *)&v118 * v109, v51 - *((double *)&v118 + 1) * v108, v21 + *((double *)&v118 + 1) * v109, v51 - *(double *)&v113 * v108, v21 + *(double *)&v114 * v109, v51 - *((double *)&v112 + 1) * v108);
    CGPathAddCurveToPoint(v17, 0, v21 + *((double *)&v114 + 1) * v109, v51 - *(double *)&v112 * v108, v21 + *(double *)&v115 * v109, v51 - *((double *)&v111 + 1) * v108, v21 + *((double *)&v115 + 1) * v109, v51 - *(double *)&v111 * v108);
    CGPathCloseSubpath(v17);
  }
  float64x2_t v86 = CA::Render::Path::new_path(v17, v16);
  CGPathRelease(v17);
  if (v86)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    double v88 = (double *)malloc_type_zone_malloc(malloc_zone, 0x78uLL, 0x8BB15036uLL);
    uint64_t v89 = v88;
    if (v88) {
      v88[13] = 0.0;
    }
    *(_OWORD *)double v88 = *(_OWORD *)a2;
    *((_OWORD *)v88 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *((_OWORD *)a2 + 1);
    *((_OWORD *)v88 + 2) = *(_OWORD *)a3;
    *((_OWORD *)v88 + 3) = *((_OWORD *)a3 + 1);
    *((_OWORD *)v88 + 4) = *((_OWORD *)a3 + 2);
    *((_OWORD *)v88 + 5) = *((_OWORD *)a3 + 3);
    *((unsigned char *)v88 + 112) = a4;
    uint64_t v90 = mach_absolute_time();
    v89[12] = CATimeWithHostTime(v90);
    uint64_t v91 = (atomic_uint *)*((void *)v89 + 13);
    if (v91 != (atomic_uint *)v86)
    {
      if (v91 && atomic_fetch_add(v91 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v91 + 16))(v91);
      }
      unint64_t v92 = v86;
      if (!atomic_fetch_add(&v86->i32[2], 1u))
      {
        unint64_t v92 = 0;
        atomic_fetch_add(&v86->i32[2], 0xFFFFFFFF);
      }
      *((void *)v89 + 13) = v92;
    }
    if (atomic_fetch_add(&v86->i32[2], 0xFFFFFFFF) == 1) {
      (*(void (**)(int8x16_t *))(v86->i64[0] + 16))(v86);
    }
    os_unfair_lock_lock(v8);
    double v93 = v8;
    uint64_t v94 = *(void *)(a1 + 8);
    double v95 = (malloc_zone_t *)get_malloc_zone();
    double v96 = malloc_type_zone_malloc(v95, 0x10uLL, 0x8BB15036uLL);
    *double v96 = v89;
    v96[1] = v94;
    *(void *)(a1 + 8) = v96;
    int v97 = v93;
LABEL_62:
    os_unfair_lock_unlock(v97);
  }
  return v86;
}

void *x_list_prepend(uint64_t a1, uint64_t a2)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  unint64_t result = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
  *unint64_t result = a2;
  result[1] = a1;
  return result;
}

uint64_t CA::ScanConverter::Path::cubeto(CA::ScanConverter::Path *this, double a2, double a3, double a4, double a5, double a6, double a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (*((double *)this + 10) != 1.0) {
    return CA::ScanConverter::Path::cubeto(this, a2, a3, 1.0, a4, a5, 1.0, a6, a7, a8, a9, a10, a11, a12, a13, a14, 1.0);
  }
  double v17 = *((double *)this + 8);
  double v18 = *((double *)this + 9);
  *((double *)this + 8) = a6;
  *((double *)this + 9) = a7;

  return CA::ScanConverter::Path::add_cube((uint64_t)this, v17, v18, a2, a3, a4, a5, a6, a7);
}

void CA::Render::anonymous namespace'::Compressor::closepath(CA::Render::_anonymous_namespace_::Compressor *this)
{
  uint64_t v2 = (_OWORD *)((char *)this + 128);
  double v3 = *((double *)this + 16);
  int v4 = (_OWORD *)((char *)this + 144);
  double v5 = *((double *)this + 18);
  double v6 = *((double *)this + 17);
  double v7 = *((double *)this + 19);
  if (v3 == v5 && v6 == v7)
  {
    if (!*((unsigned char *)this + 160)) {
      return;
    }
  }
  else
  {
    *uint64_t v2 = *v4;
  }
  ++*((void *)this + 3);
  *((unsigned char *)this + 16CA::Context::unref(this[1], 0) = 0;
}

void CA::anonymous namespace'::gaussian_vimage_8(CA::_anonymous_namespace_ *this, unsigned __int8 *a2, int a3, uint64_t a4, int a5, double a6)
{
  int v58 = this;
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = (a5 + 1);
  unint64_t v57 = 8 * (int)v11;
  if (v57 <= 0x1000)
  {
    MEMORY[0x1F4188790](this);
    long long v13 = (double *)((char *)&v55 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
    bzero(v13, v12);
    if ((a5 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_14:
    double v26 = *v13;
    char v30 = 1;
    double v28 = *v13;
    goto LABEL_16;
  }
  long long v14 = (double *)malloc_type_malloc(8 * (int)v11, 0x8948E546uLL);
  long long v13 = v14;
  if (a5 < 0) {
    goto LABEL_14;
  }
LABEL_3:
  uint64_t v16 = 0;
  uint64x2_t v17 = (uint64x2_t)xmmword_184997FD0;
  int64x2_t v61 = vdupq_n_s64(2uLL);
  uint64_t v18 = v11 - 1;
  uint64x2_t v60 = (uint64x2_t)vdupq_n_s64(v11 - 1);
  *(double *)&long long v15 = -0.5 / (a6 * a6);
  long long v59 = v15;
  double v19 = 1.0 / a6;
  do
  {
    int64x2_t v65 = (int64x2_t)v17;
    int64x2_t v20 = (int64x2_t)vcgeq_u64(v60, v17);
    v21.i32[0] = v16;
    v21.i32[1] = v16 + 1;
    *(int32x2_t *)v20.i8 = vmovn_s64(v20);
    int64x2_t v64 = v20;
    *(int32x2_t *)v20.i8 = vmul_s32(v21, v21);
    v22.i64[0] = v20.i32[0];
    v22.i64[1] = v20.i32[1];
    float64x2_t v62 = vmulq_n_f64(vcvtq_f64_s64(v22), *(double *)&v59);
    *(double *)&long long v23 = exp(v62.f64[1]);
    long long v63 = v23;
    v25.f64[0] = exp(v62.f64[0]);
    __int8 v24 = v64.i8[4];
    *(void *)&v25.f64[1] = v63;
    if (v64.i8[0]) {
      v13[v16] = 0.39894228 * v19 * v25.f64[0];
    }
    if (v24) {
      v13[v16 + 1] = vmuld_lane_f64(0.39894228, v25, 1) * v19;
    }
    v16 += 2;
    uint64x2_t v17 = (uint64x2_t)vaddq_s64(v65, v61);
  }
  while (((v11 + 1) & 0x1FFFFFFFELL) != v16);
  double v26 = *v13;
  if (a5 < 1)
  {
    char v30 = 1;
    double v28 = *v13;
  }
  else
  {
    unint64_t v27 = v13 + 1;
    double v28 = *v13;
    do
    {
      double v29 = *v27++;
      double v28 = v28 + v29 * 2.0;
      --v18;
    }
    while (v18);
    char v30 = 0;
  }
LABEL_16:
  signed int v31 = (2 * a5) | 1;
  double v32 = 16384.0 / v28;
  *(void *)&long long v63 = 2 * v31;
  if ((unint64_t)v63 > 0x1000)
  {
    double v35 = (char *)malloc_type_malloc(2 * v31, 0x55B2CBDEuLL);
    double v34 = v35;
    double v26 = *v13;
  }
  else
  {
    MEMORY[0x1F4188790](v14);
    double v34 = (char *)&v55 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v34, v33);
  }
  *(_WORD *)&v34[2 * a5] = (int)(v26 * v32);
  if ((v30 & 1) == 0)
  {
    uint64_t v36 = v11 - 1;
    double v37 = &v34[2 * a5];
    double v38 = v37 - 2;
    float64_t v39 = v37 + 2;
    float64x2_t v40 = v13 + 1;
    do
    {
      double v41 = *v40++;
      int v42 = (int)(v41 * v32);
      *v39++ = v42;
      *(_WORD *)double v38 = v42;
      v38 -= 2;
      --v36;
    }
    while (v36);
  }
  int v43 = a3;
  size_t v44 = (2 * a5 + a3 + 15) & 0xFFFFFFFFFFFFFFF0;
  float64x2_t v56 = v13;
  int v45 = a2;
  if (v44 > 0x1000)
  {
    long long v46 = (char *)malloc_type_malloc(v44, 0xB91FB5F5uLL);
  }
  else
  {
    MEMORY[0x1F4188790](v35);
    long long v46 = (char *)&v55 - ((v44 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v46, v44);
  }
  int8x16_t v47 = malloc_type_malloc(((int)a4 * v43 + 15) & 0xFFFFFFFFFFFFFFF0, 0x80DF8B17uLL);
  src.data = v46;
  src.height = 1;
  src.width = v44;
  src.rowuint64_t Bytes = v44;
  *(void *)&v62.f64[0] = v44;
  v61.i64[0] = (uint64_t)v47;
  dest.data = v47;
  dest.height = 1;
  vImagePixelCount v48 = v43;
  dest.width = v43;
  dest.rowuint64_t Bytes = v43;
  bzero(v46, a5);
  v64.i64[0] = (uint64_t)v46;
  bzero(&v46[v43 + a5], a5);
  v65.i64[0] = a4;
  size_t v49 = (size_t)v45;
  if ((int)a4 >= 1)
  {
    double v50 = (void *)(v64.i64[0] + a5);
    double v51 = v58;
    uint64_t v52 = v65.u32[0];
    do
    {
      memcpy(v50, v51, v43);
      vImageConvolve_Planar8(&src, &dest, 0, a5, 0, (const int16_t *)v34, 1u, v31, 0x4000, 0, 0x14u);
      dest.data = (char *)dest.data + v43;
      double v51 = (CA::_anonymous_namespace_ *)((char *)v51 + v49);
      --v52;
    }
    while (v52);
  }
  float64x2_t v53 = (void *)v61.i64[0];
  src.data = (void *)v61.i64[0];
  src.height = v65.i32[0];
  src.width = v48;
  src.rowuint64_t Bytes = v48;
  dest.data = v58;
  dest.height = v65.i32[0];
  dest.width = v48;
  dest.rowuint64_t Bytes = v49;
  vImageConvolve_Planar8(&src, &dest, 0, 0, 0, (const int16_t *)v34, v31, 1u, 0x4000, 0, 0x14u);
  free(v53);
  if (*(void *)&v62.f64[0] > 0x1000uLL) {
    free((void *)v64.i64[0]);
  }
  float64x2_t v54 = v56;
  if ((unint64_t)v63 > 0x1000) {
    free(v34);
  }
  if (v57 > 0x1000) {
    free(v54);
  }
}

void CA::anonymous namespace'::gaussian_blur(CA::_anonymous_namespace_ *this, unsigned __int8 *a2, const unsigned __int8 *a3, const unsigned __int8 *a4, unsigned __int8 *a5, float a6)
{
  float64x2_t v62 = a4;
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  double v8 = a6;
  if (v8 > 0.6)
  {
    int v10 = (int)a3;
    if (a5 == 1)
    {
      if (a6 <= 8.0)
      {
        int v28 = vcvtps_s32_f32(a6 * 2.5);
      }
      else
      {
        LODWORD(v6) = vcvtms_u32_f32((float)(a6 * 0.93999) + -0.5);
        int v58 = this;
        vImagePixelCount v61 = (v62 + 2 * v6);
        size_t v13 = (a3 + 2 * v6);
        long long v14 = (char *)malloc_type_calloc(v13, v61, 0xDF3B78D3uLL);
        vImagePixelCount v15 = v10;
        uint64_t v16 = &v14[v13 * (unint64_t)v6 + v6];
        uint64x2_t v17 = v14;
        CGBlt_copyBytes();
        v65[0].data = v17;
        v65[0].height = v61;
        v65[0].width = v13;
        v65[0].rowuint64_t Bytes = v13;
        v64.data = v58;
        v64.height = (int)v62;
        v64.width = v15;
        v64.rowuint64_t Bytes = (size_t)a2;
        v63.data = v16;
        v63.height = (int)v62;
        v63.width = v15;
        v63.rowuint64_t Bytes = v13;
        unint64_t v18 = vImageBoxConvolve_Planar8(v65, &v64, 0, v6, v6, (2 * v6) | 1, (2 * v6) | 1, 0, 0x84u);
        vImage_Error v19 = vImageBoxConvolve_Planar8(&v64, &v63, 0, 0, 0, (2 * v6) | 1, (2 * v6) | 1, 0, 0x84u);
        if ((v18 & 0x8000000000000000) == 0 && (v19 & 0x8000000000000000) == 0)
        {
          if ((uint64_t)v18 <= v19) {
            unint64_t v18 = v19;
          }
          if (v18 > 0x1000)
          {
            int64x2_t v20 = (char *)malloc_type_malloc(v18, 0xC3EDC26uLL);
          }
          else
          {
            MEMORY[0x1F4188790](v19);
            int64x2_t v20 = (char *)&v57 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
            bzero(v20, v18);
          }
          vImageBoxConvolve_Planar8(v65, &v64, v20, v6, v6, (2 * v6) | 1, (2 * v6) | 1, 0, 0x14u);
          vImageBoxConvolve_Planar8(&v64, &v63, v20, 0, 0, (2 * v6) | 1, (2 * v6) | 1, 0, 0x14u);
          vImageBoxConvolve_Planar8(v65, &v64, v20, v6, v6, (2 * v6) | 1, (2 * v6) | 1, 0, 0x14u);
          free(v17);
          if (v18 > 0x1000)
          {
            float64x2_t v56 = v20;
            goto LABEL_55;
          }
        }
      }
    }
    else
    {
      int32x2_t v21 = a2;
      int v22 = (int)v62;
      vImagePixelCount v61 = (vImagePixelCount)a3;
      if ((int)a3 > (int)v62) {
        int v22 = (int)a3;
      }
      size_t v23 = (v22 * a5);
      if (v23 > 0x1000)
      {
        __int8 v24 = (char *)malloc_type_malloc((v22 * a5), 0x6E8ADC97uLL);
        double v26 = (unsigned __int8 *)malloc_type_malloc(v23, 0x516DEA5EuLL);
      }
      else
      {
        MEMORY[0x1F4188790](this);
        __int8 v24 = (char *)&v57 - ((v23 + 15) & 0x1FFFFFFF0);
        bzero(v24, v23);
        MEMORY[0x1F4188790](v25);
        double v26 = (unsigned __int8 *)v24;
        bzero(v24, v23);
      }
      if (v24) {
        BOOL v29 = v26 == 0;
      }
      else {
        BOOL v29 = 1;
      }
      if (!v29)
      {
        int v58 = this;
        uint64_t v30 = 0;
        *(float *)v27.i32 = (float)(a6 * 0.93999) + -0.5;
        uint64_t v31 = ((int)*(float *)v27.i32 + 1);
        *(float *)v27.i32 = *(float *)v27.i32 - truncf(*(float *)v27.i32);
        float32x4_t v32 = (float32x4_t)vdupq_lane_s32(v27, 0);
        int32x4_t v33 = (int32x4_t)xmmword_184997F90;
        int32x4_t v34 = (int32x4_t)xmmword_184997FA0;
        int32x4_t v35 = (int32x4_t)xmmword_184997FB0;
        int32x4_t v36 = (int32x4_t)xmmword_184997FC0;
        v37.i64[0] = 0x1000000010;
        v37.i64[1] = 0x1000000010;
        do
        {
          v38.i64[0] = 0x3F0000003F000000;
          v38.i64[1] = 0x3F0000003F000000;
          v39.i64[0] = 0x3F0000003F000000;
          v39.i64[1] = 0x3F0000003F000000;
          v40.i64[0] = 0x3F0000003F000000;
          v40.i64[1] = 0x3F0000003F000000;
          v41.i64[0] = 0x3F0000003F000000;
          v41.i64[1] = 0x3F0000003F000000;
          *(int16x4_t *)v42.i8 = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v41, vcvtq_f32_s32(v36), v32)));
          v42.u64[1] = (unint64_t)vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v40, vcvtq_f32_s32(v35), v32)));
          *(int16x4_t *)v41.f32 = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v39, vcvtq_f32_s32(v34), v32)));
          *(int16x4_t *)&v41.u32[2] = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v38, vcvtq_f32_s32(v33), v32)));
          *(int8x16_t *)((char *)&v65[0].data + v3CA::Context::unref(this[1], 0) = vuzp1q_s8(v42, (int8x16_t)v41);
          v30 += 16;
          int32x4_t v36 = vaddq_s32(v36, v37);
          int32x4_t v35 = vaddq_s32(v35, v37);
          int32x4_t v34 = vaddq_s32(v34, v37);
          int32x4_t v33 = vaddq_s32(v33, v37);
        }
        while (v30 != 256);
        size_t v57 = v23;
        int v43 = (float)((float)(8924200.0 / a6) + 0.5);
        if ((int)v62 >= 1)
        {
          int v44 = (int)v62;
          int v45 = (unsigned __int8 *)v58;
          long long v59 = v21;
          do
          {
            int v60 = v44;
            long long v46 = (const unsigned __int8 *)v61;
            for (uint64_t i = 1; a5 != i; ++i)
            for (uint64_t j = 1; a5 != j; ++j)
            for (uint64_t k = 1; a5 != k; ++k)
            int32x2_t v21 = v59;
            int v45 = &v59[(void)v45];
            int v44 = v60 - 1;
          }
          while (v60 > 1);
        }
        double v50 = (unsigned __int8 *)v58;
        if ((int)v61 >= 1)
        {
          do
          {
            double v51 = v50;
            for (uint64_t m = 1; a5 != m; ++m)
            for (uint64_t n = 1; a5 != n; ++n)
            for (iuint64_t i = 1; a5 != ii; ++ii)
            double v50 = &v51[a5];
            BOOL v55 = __OFSUB__(v61, 1);
            vImagePixelCount v61 = (v61 - 1);
          }
          while (!(((v61 & 0x80000000) != 0) ^ v55 | (v61 == 0)));
        }
        LODWORD(v23) = v57;
      }
      if (v23 > 0x1000 && v26) {
        free(v26);
      }
      if (v23 > 0x1000 && v24)
      {
        float64x2_t v56 = v24;
LABEL_55:
        free(v56);
      }
    }
  }
}

unint64_t CA::OGL::AsynchronousDispatcher::start_timer(unint64_t this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(this + 40))
  {
    uint64_t v1 = this;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    long long v6 = this;
    uint64_t v2 = mach_absolute_time();
    double v3 = CATimeWithHostTime(v2);
    double v4 = CATimeWithHostTime(*(void *)(v1 + 48));
    uint64_t v5 = CADisplayTimerCreate((uint64_t)CA::OGL::AsynchronousDispatcher::timer_callback, &v6, 0, v3, v4);
    *(void *)(v1 + 4CA::Context::unref(this[1], 0) = v5;
    long long v9 = *(_OWORD *)(v1 + 72);
    uint64_t v10 = *(void *)(v1 + 88);
    CADisplayTimerAlignPhase(v5, &v9);
    return CADisplayTimerAddToRunLoop(*(void *)(v1 + 40), *(__CFRunLoop **)(v1 + 32), (const __CFString *)*MEMORY[0x1E4F1D418]);
  }
  return this;
}

uint64_t CA::WindowServer::IOMFBServer::set_vsync_disabled(CA::WindowServer::IOMFBServer *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 608);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 608));
  if (*((unsigned char *)this + 1013))
  {
    *((unsigned char *)this + 1013) = 0;
    if (BYTE9(xmmword_1EB2ACC10)) {
      kdebug_trace();
    }
    if ((*((unsigned char *)this + 1014) & 2) != 0)
    {
      IOMobileFramebufferDisableVSyncNotifications();
    }
    else
    {
      uint64_t v3 = *((void *)this + 100);
      if (v3)
      {
        double v4 = (__CFRunLoop *)(*(uint64_t (**)(CA::WindowServer::IOMFBServer *))(*(void *)this + 384))(this);
        CADisplayTimerRemoveFromRunLoop(v3, v4, (const __CFString *)*MEMORY[0x1E4F1D418]);
      }
      CA::WindowServer::IOMFBDisplay::set_timings_enabled(*((CA::WindowServer::IOMFBDisplay **)this + 12), 0);
    }
  }

  return pthread_mutex_unlock(v2);
}

uint64_t CA::WindowServer::IOMFBServer::set_vsync_enabled(CA::WindowServer::IOMFBServer *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 608);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 608));
  if (!*((unsigned char *)this + 1013))
  {
    *((unsigned char *)this + 1013) = 1;
    if (BYTE9(xmmword_1EB2ACC10)) {
      kdebug_trace();
    }
    if ((*((unsigned char *)this + 1014) & 2) != 0)
    {
      IOMobileFramebufferEnableVSyncNotifications();
    }
    else
    {
      CA::WindowServer::IOMFBDisplay::set_timings_enabled(*((CA::WindowServer::IOMFBDisplay **)this + 12), 1);
      uint64_t v3 = *((void *)this + 100);
      if (v3)
      {
        double v4 = (__CFRunLoop *)(*(uint64_t (**)(CA::WindowServer::IOMFBServer *))(*(void *)this + 384))(this);
        CADisplayTimerAddToRunLoop(v3, v4, (const __CFString *)*MEMORY[0x1E4F1D418]);
      }
    }
  }

  return pthread_mutex_unlock(v2);
}

void CA::WindowServer::IOMFBDisplay::set_timings_enabled(CA::WindowServer::IOMFBDisplay *this, int a2)
{
  double v4 = (os_unfair_lock_s *)((char *)this + 26048);
  os_unfair_lock_lock((os_unfair_lock_t)this + 6512);
  CA::WindowServer::IOMFBDisplay::initialize_timings(this);
  uint64_t v5 = (unsigned __int8 *)*((void *)this + 3258);
  if (v5)
  {
    unsigned __int8 v6 = atomic_load(v5);
    if ((v6 & 1) != a2)
    {
      if ((a2 & 1) == 0)
      {
        *((_DWORD *)this + 6518) = 0;
        *((void *)this + 326CA::Context::unref(this[1], 0) = 0;
      }
      atomic_store(a2, *((unsigned __int8 **)this + 3258));
      __dmb(0xBu);
    }
  }

  os_unfair_lock_unlock(v4);
}

CA::Display::DisplayLink *CA::Display::DisplayLinkItem::set_paused(CA::Display::DisplayLinkItem *this, int a2)
{
  if (BYTE9(xmmword_1EB2ACC10)) {
    kdebug_trace();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  char v4 = *((unsigned char *)this + 316);
  if ((((v4 & 1) == 0) ^ a2))
  {
    return (CA::Display::DisplayLink *)pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 136));
  }
  else
  {
    *((unsigned char *)this + 316) = v4 & 0xFE | a2;
    if (a2) {
      CA::Display::DisplayLinkItem::unregister_frame_interval_range(this);
    }
    else {
      CA::Display::DisplayLinkItem::set_preferred_fps_range_locked(this, *(CAFrameRateRange *)((char *)this + 76), 1);
    }
    if ((*((unsigned char *)this + 316) & 0x10) != 0)
    {
      [*((id *)this + 32) willChangeValueForKey:@"active"];
      *((unsigned char *)this + 316) = ((8 * (*((unsigned char *)this + 316) & 1)) | *((unsigned char *)this + 316) & 0xF7) ^ 8;
      [*((id *)this + 32) didChangeValueForKey:@"active"];
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 136));
    unint64_t result = (CA::Display::DisplayLink *)*((void *)this + 33);
    if (result)
    {
      return (CA::Display::DisplayLink *)CA::Display::DisplayLink::item_properties_changed(result);
    }
  }
  return result;
}

uint64_t CA::Display::DisplayLink::item_properties_changed(CA::Display::DisplayLink *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 56);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 56));
  CA::Display::DisplayLink::compute_firing_rate_multiplier_locked((uint64_t)this);
  CA::Display::DisplayLink::update_paused_locked((uint64_t)this);

  return pthread_mutex_unlock(v2);
}

void sub_1847A56DC(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Display::DisplayLinkItem::update_link(CA::Display::DisplayLinkItem *this, __CFRunLoop *a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  char v4 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  *((unsigned char *)this + 316) |= 2u;
  while (1)
  {
    uint64_t v5 = (_opaque_pthread_t *)*((void *)this + 31);
    if (!v5) {
      break;
    }
    if (v5 == pthread_self())
    {
      pthread_mutex_unlock(v4);
      return;
    }
    pthread_cond_wait((pthread_cond_t *)((char *)this + 200), v4);
  }
  (*(void (**)(uint8_t *__return_ptr, CA::Display::DisplayLinkItem *, __CFRunLoop *, void))(*(void *)this + 40))(buf, this, a2, *((void *)this + 34));
  uint64_t v6 = *(void *)buf;
  uint64_t v7 = *((void *)this + 33);
  if (v7 == *(void *)buf)
  {
    int v11 = 0;
    size_t v12 = *(atomic_uint **)buf;
  }
  else
  {
    if (v7)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v7 + 56));
      if ((*((unsigned char *)this + 316) & 1) == 0) {
        CA::Display::DisplayLinkItem::unregister_frame_interval_range(this);
      }
      long long v9 = *(CA::Display::DisplayLinkItem ***)(v7 + 120);
      uint64_t v8 = *(CA::Display::DisplayLinkItem ***)(v7 + 128);
      if (v9 == v8)
      {
        uint64_t v8 = *(CA::Display::DisplayLinkItem ***)(v7 + 120);
      }
      else
      {
        uint64_t v10 = *(CA::Display::DisplayLinkItem ***)(v7 + 120);
        while (*v10 != this)
        {
          if (++v10 == v8) {
            goto LABEL_23;
          }
        }
        size_t v13 = (char *)v8 - (char *)(v10 + 1);
        if (v13)
        {
          memmove(v10, v10 + 1, v13);
          long long v9 = *(CA::Display::DisplayLinkItem ***)(v7 + 120);
        }
        uint64_t v8 = (CA::Display::DisplayLinkItem **)((char *)v10 + v13);
        *(void *)(v7 + 128) = v8;
      }
LABEL_23:
      CA::Display::DisplayLink::compute_firing_rate_multiplier_locked(v7);
      CA::Display::DisplayLink::update_paused_locked(v7);
      pthread_mutex_unlock((pthread_mutex_t *)(v7 + 56));
      if (v8 == v9)
      {
        for (uint64_t i = *(void *)(v7 + 24); i; uint64_t i = *(void *)(i + 8))
        {
          CFStringRef v15 = *(const __CFString **)i;
          pthread_mutex_lock((pthread_mutex_t *)(v7 + 56));
          uint64_t v16 = *(void *)(v7 + 152);
          if (v16) {
            CADisplayTimerRemoveFromRunLoop(v16, *(__CFRunLoop **)(v7 + 16), v15);
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v7 + 56));
        }
      }
    }
    else
    {
      CFRetain(*((CFTypeRef *)this + 32));
    }
    size_t v12 = (atomic_uint *)*((void *)this + 33);
    *((void *)this + 33) = v6;
    if (v6)
    {
      uint64_t v30 = this;
      pthread_mutex_lock((pthread_mutex_t *)(v6 + 56));
      uint64x2_t v17 = *(char **)(v6 + 120);
      unint64_t v18 = *(char **)(v6 + 128);
      if (v18 == v17)
      {
LABEL_33:
        vImage_Error v19 = *(char **)(v6 + 128);
      }
      else
      {
        vImage_Error v19 = *(char **)(v6 + 120);
        while (*(void *)(*(void *)v19 + 48) >= *((void *)this + 6))
        {
          v19 += 8;
          if (v19 == v18) {
            goto LABEL_33;
          }
        }
      }
      std::vector<CA::Display::DisplayLinkItem *>::insert(v6 + 120, v19, (char *)&v30);
      int64x2_t v20 = v30;
      if ((*((unsigned char *)v30 + 316) & 1) == 0)
      {
        if ((*(unsigned char *)(*((void *)v30 + 2) + 697) & 2) != 0
          && (*((unsigned char *)v30 + 316) & 4) == 0
          && *((void *)v30 + 33))
        {
          if (byte_1EB2ACC45)
          {
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              double v26 = x_log_category_frame_rate;
              if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT))
              {
                int v27 = *((_DWORD *)v20 + 16);
                int v28 = *((_DWORD *)v20 + 17);
                int v29 = *((_DWORD *)v20 + 18);
                *(_DWORD *)long long buf = 67109632;
                *(_DWORD *)&uint8_t buf[4] = v27;
                __int16 v32 = 1024;
                int v33 = v28;
                __int16 v34 = 1024;
                int v35 = v29;
                _os_log_impl(&dword_184668000, v26, OS_LOG_TYPE_DEFAULT, "CAFrameRateClient: register %u %u %u", buf, 0x14u);
              }
            }
          }
          if (*((unsigned char *)v20 + 129)) {
            CA::Display::DisplayLinkItem::run_deferred_unregister_frame_interval_range(v20);
          }
          CA::Display::DisplayTimingsControl::register_frame_interval_range((os_unfair_lock_s *)(*((void *)v20 + 2) + 464), *(CAFrameIntervalRange *)((char *)v20 + 64));
          CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)v20 + 2) + 464), (uint64_t)v20, (const unsigned int *)v20 + 22, 4u);
          *((unsigned char *)v20 + 316) |= 4u;
          int64x2_t v20 = v30;
        }
        CA::Display::DisplayLinkItem::set_preferred_fps_range_locked(v20, *(CAFrameRateRange *)((char *)v20 + 76), 0);
        CA::Display::DisplayLink::compute_firing_rate_multiplier_locked(v6);
        CA::Display::DisplayLinkItem::set_display_active((uint64_t)v30, *(unsigned __int8 *)(v6 + 172));
      }
      CA::Display::DisplayLink::update_paused_locked(v6);
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
      if (v18 == v17)
      {
        for (uint64_t j = *(void *)(v6 + 24); j; uint64_t j = *(void *)(j + 8))
        {
          CFStringRef v22 = *(const __CFString **)j;
          pthread_mutex_lock((pthread_mutex_t *)(v6 + 56));
          uint64_t v23 = *(void *)(v6 + 152);
          if (v23) {
            CADisplayTimerAddToRunLoop(v23, *(__CFRunLoop **)(v6 + 16), v22);
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
        }
      }
      int v11 = 0;
    }
    else
    {
      int v11 = 1;
    }
  }
  if (*((_DWORD *)this + 78))
  {
    __int8 v24 = (const void *)*((void *)this + 3);
    *((void *)this + 3) = 0;
    uint64_t v25 = (const void *)*((void *)this + 5);
    *((void *)this + 5) = 0;
  }
  else
  {
    __int8 v24 = 0;
    uint64_t v25 = 0;
  }
  *((unsigned char *)this + 316) &= ~2u;
  pthread_mutex_unlock(v4);
  if (v24) {
    CFRelease(v24);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (v11) {
    CFRelease(*((CFTypeRef *)this + 32));
  }
  if (v12) {
    CA::Display::DisplayLink::unref(v12);
  }
}

void sub_1847A5B7C(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  if (v2) {
    CA::Display::DisplayLink::unref(v2);
  }
  _Unwind_Resume(a1);
}

uint64_t CA::Display::DisplayLink::compute_firing_rate_multiplier_locked(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 120);
  uint64_t v2 = *(void *)(this + 128);
  if (v1 != v2)
  {
    int v3 = 0;
    do
    {
      if ((*(unsigned char *)(*(void *)v1 + 316) & 1) == 0)
      {
        int v4 = *(_DWORD *)(*(void *)v1 + 56);
        if (v3)
        {
          if (v4)
          {
            int v5 = v3;
            do
            {
              int v3 = v4;
              int v4 = v5 % v4;
              int v5 = v3;
            }
            while (v4);
          }
        }
        else
        {
          int v3 = *(_DWORD *)(*(void *)v1 + 56);
        }
      }
      v1 += 8;
    }
    while (v1 != v2);
    if (v3) {
      *(_DWORD *)(this + 168) = v3;
    }
  }
  return this;
}

uint64_t CA::Display::DisplayLink::update_paused_locked(uint64_t this)
{
  uint64_t v1 = this;
  *(_DWORD *)(this + 144) = 0;
  uint64_t v2 = *(void *)(this + 120);
  uint64_t v3 = *(void *)(this + 128);
  if (v2 == v3)
  {
    unsigned int v4 = 0;
  }
  else
  {
    unsigned int v4 = 0;
    uint64_t v5 = *(void *)(this + 120);
    do
    {
      if (*(unsigned char *)(*(void *)v5 + 316)) {
        *(_DWORD *)(this + 144) = ++v4;
      }
      v5 += 8;
    }
    while (v5 != v3);
  }
  if (v4 < (unint64_t)((v3 - v2) >> 3))
  {
    if (*(void *)(this + 152))
    {
      int v6 = *(_DWORD *)(this + 148);
      this = CA::Display::DisplayLink::update_timer_locked((CA::Display::DisplayLink *)this, 0);
      if (!v6)
      {
        if (this) {
          this = (uint64_t)CA::Display::DisplayLink::start_timer_locked((void *)v1);
        }
        else {
          *(unsigned char *)(v1 + 192) = 1;
        }
      }
    }
    else
    {
      this = CA::Display::DisplayLink::update_timer_locked((CA::Display::DisplayLink *)this, 0);
    }
    *(_DWORD *)(v1 + 148) = 5;
  }
  return this;
}

void CA::Display::DisplayLinkItem::get_link(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
}

void CA::Display::DisplayLink::get_link(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a4)
  {
    int v11 = dyld_program_sdk_at_least();
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Display::DisplayLink::_list_lock);
    if (a6 || !v11 || (uint64_t v12 = CA::Display::DisplayLink::_list) == 0) {
LABEL_24:
    }
      operator new();
    while (1)
    {
      if (!*(void *)(v12 + 240) && *(void *)(v12 + 8) == a2 && *(void *)(v12 + 16) == a3)
      {
        uint64_t v13 = *(void *)(v12 + 24);
        if (v13)
        {
          uint64_t v14 = 0;
          uint64_t v15 = *(void *)(v12 + 24);
          do
          {
            ++v14;
            uint64_t v15 = *(void *)(v15 + 8);
          }
          while (v15);
        }
        else
        {
          uint64_t v14 = 0;
        }
        uint64_t v16 = 0;
        uint64_t v17 = a4;
        do
        {
          ++v16;
          uint64_t v17 = *(void *)(v17 + 8);
        }
        while (v17);
        if (v14 == v16) {
          break;
        }
      }
LABEL_23:
      uint64_t v12 = *(void *)(v12 + 48);
      if (!v12) {
        goto LABEL_24;
      }
    }
    for (; v13; uint64_t v13 = *(void *)(v13 + 8))
    {
      uint64_t v18 = a4;
      while (!CFEqual(*(CFTypeRef *)v13, *(CFTypeRef *)v18))
      {
        uint64_t v18 = *(void *)(v18 + 8);
        if (!v18) {
          goto LABEL_23;
        }
      }
    }
    do
    {
      int v20 = *(_DWORD *)(v12 + 40);
      if (!v20) {
        break;
      }
      int v19 = *(_DWORD *)(v12 + 40);
      atomic_compare_exchange_strong((atomic_uint *volatile)(v12 + 40), (unsigned int *)&v19, v20 + 1);
    }
    while (v19 != v20);
    *a1 = v12;
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Display::DisplayLink::_list_lock);
  }
  else
  {
    *a1 = 0;
  }
}

void sub_1847A5FCC(_Unwind_Exception *a1)
{
}

void CA::Display::DisplayLinkItem::unregister_frame_interval_range(CA::Display::DisplayLinkItem *this)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 316) & 4) != 0 && *((void *)this + 33))
  {
    if (*((unsigned char *)this + 129)) {
      __assert_rtn("unregister_frame_interval_range", "CADisplay.mm", 6433, "!_has_deferred_unregister_frame_interval_range");
    }
    if (byte_1EB2ACC45)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v2 = x_log_category_frame_rate;
        if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT))
        {
          int v3 = *((_DWORD *)this + 16);
          int v4 = *((_DWORD *)this + 17);
          int v5 = *((_DWORD *)this + 18);
          *(_DWORD *)long long buf = 67109632;
          int v7 = v3;
          __int16 v8 = 1024;
          int v9 = v4;
          __int16 v10 = 1024;
          int v11 = v5;
          _os_log_impl(&dword_184668000, v2, OS_LOG_TYPE_DEFAULT, "CAFrameRateClient: unregister %u %u %u", buf, 0x14u);
        }
      }
    }
    if (*((void *)this + 31))
    {
      *((unsigned char *)this + 129) = 1;
      *(void *)((char *)this + 116) = *((void *)this + 8);
      *((_DWORD *)this + 3CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *((_DWORD *)this + 18);
    }
    else
    {
      CA::Display::DisplayTimingsControl::unregister_frame_interval_range((os_unfair_lock_s *)(*((void *)this + 2) + 464), *(CAFrameIntervalRange *)((char *)this + 64));
      CA::Display::DisplayTimingsControl::register_frame_interval_reasons((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), (uint64_t)this, 0, 0);
    }
    *((unsigned char *)this + 316) &= ~4u;
  }
}

uint64_t CADisplayTimerAddToRunLoop(uint64_t result, __CFRunLoop *a2, const __CFString *a3)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  if (a2 && a3)
  {
    uint64_t v5 = result;
    int v6 = (pthread_mutex_t *)(result + 16);
    pthread_mutex_lock((pthread_mutex_t *)(result + 16));
    CFRunLoopAddSource(a2, *(CFRunLoopSourceRef *)(v5 + 136), a3);
    uint64_t v7 = mach_absolute_time();
    unint64_t v8 = *(void *)(v5 + 240);
    unint64_t v9 = *(void *)(v5 + 216);
    v13[0] = 0;
    v13[1] = v8;
    v13[2] = v9;
    v14[0] = 0;
    unint64_t phase = get_phase(v13, v7, v14);
    unint64_t v11 = v7 - phase + v14[0];
    if (!phase) {
      unint64_t v11 = v7;
    }
    *(void *)(v5 + 224) = v11;
    mk_timer_cancel();
    *(unsigned char *)(v5 + 20CA::Context::unref(this[1], 0) = 1;
    mk_timer_arm_leeway();
    *(unsigned char *)(v5 + 20CA::Context::unref(this[1], 0) = 0;
    uint64_t v12 = *(void (**)(uint64_t, uint64_t, void, void, void))(v5 + 192);
    if (v12) {
      v12(v5, 1, *(void *)(v5 + 224), *(void *)(v5 + 216), *(void *)(v5 + 184));
    }
    return pthread_mutex_unlock(v6);
  }
  return result;
}

uint64_t CADisplayTimerSetInterval(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v31[1] = *MEMORY[0x1E4F143B8];
  int v6 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  unint64_t v7 = *(void *)(a1 + 232);
  uint64_t v8 = a2 - v7;
  if (v7 <= a2) {
    unint64_t v7 = a2;
  }
  if (v8 < 0) {
    uint64_t v8 = -v8;
  }
  if (v8 > v7 >> 5) {
    *(void *)(a1 + 232) = a2;
  }
  uint64_t v9 = mach_absolute_time();
  uint64_t v10 = *(void *)(a1 + 240);
  uint64_t v11 = *(void *)(a1 + 232) * a3;
  unint64_t v28 = 0;
  uint64_t v29 = v10;
  uint64_t v30 = v11;
  v31[0] = 0;
  unint64_t phase = get_phase(&v28, v9, v31);
  unint64_t v13 = v31[0];
  *(void *)(a1 + 208) = a3 * a2;
  *(void *)(a1 + 216) = v11;
  if (!*(unsigned char *)(a1 + 200))
  {
    uint64_t v14 = v9 - phase + v13;
    if (!phase) {
      uint64_t v14 = v9;
    }
    uint64_t v15 = *(void *)(a1 + 224);
    if (v14 == v15 || v15 <= v9 || v15 - v9 <= CAHostTimeWithTime(0.0005))
    {
      int32x2_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 192);
      if (!v21) {
        goto LABEL_23;
      }
      uint64_t v22 = *(void *)(a1 + 184);
      uint64_t v25 = a1;
      uint64_t v26 = 1;
      uint64_t v23 = v15;
      uint64_t v24 = v11;
      goto LABEL_22;
    }
    mk_timer_cancel();
    *(unsigned char *)(a1 + 20CA::Context::unref(this[1], 0) = 1;
    uint64_t v16 = *(void (**)(uint64_t, uint64_t, void, void, void))(a1 + 192);
    if (v16) {
      v16(a1, 2, *(void *)(a1 + 224), *(void *)(a1 + 216), *(void *)(a1 + 184));
    }
    uint64_t v17 = *(void *)(a1 + 240);
    uint64_t v18 = *(void *)(a1 + 216);
    unint64_t v28 = 0;
    uint64_t v29 = v17;
    uint64_t v30 = v18;
    v31[0] = 0;
    unint64_t v19 = get_phase(&v28, v9, v31);
    if (v19) {
      unint64_t v20 = v9 - v19 + v31[0];
    }
    else {
      unint64_t v20 = v9;
    }
    *(void *)(a1 + 224) = v20;
    mk_timer_arm_leeway();
    *(unsigned char *)(a1 + 20CA::Context::unref(this[1], 0) = 0;
    int32x2_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 192);
    if (v21)
    {
      uint64_t v22 = *(void *)(a1 + 184);
      uint64_t v24 = *(void *)(a1 + 216);
      uint64_t v23 = *(void *)(a1 + 224);
      uint64_t v25 = a1;
      uint64_t v26 = 0;
LABEL_22:
      v21(v25, v26, v23, v24, v22);
    }
  }
LABEL_23:

  return pthread_mutex_unlock(v6);
}

void CA::Display::DisplayLink::timer_status_callback(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  if (CA::Transaction::_update_cycle_support_enabled != 1) {
    return;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Display::DisplayLink::_next_wakeup_info_lock);
  unsigned int v9 = CA::Display::DisplayLink::_next_wakeup_info_count;
  if (CA::Display::DisplayLink::_next_wakeup_info_count == 4)
  {
    uint64_t v18 = mach_absolute_time();
    unsigned int v9 = CA::Display::DisplayLink::_next_wakeup_info_count;
    if (!CA::Display::DisplayLink::_next_wakeup_info_count)
    {
      uint64_t v10 = &CA::Display::DisplayLink::_next_wakeup_info_list;
      goto LABEL_35;
    }
    uint64_t v19 = v18;
    unsigned int v20 = 0;
    uint64_t v56 = v18;
    do
    {
      int32x2_t v21 = (char *)&CA::Display::DisplayLink::_next_wakeup_info_list + 40 * v20;
      if (*((void *)v21 + 1) >= v19)
      {
        ++v20;
      }
      else
      {
        uint64_t v22 = (char *)&CA::Display::DisplayLink::_next_wakeup_info_list + 40 * v20;
        uint64_t v25 = *((void *)v22 + 3);
        uint64_t v24 = (unint64_t *)(v22 + 24);
        uint64_t v23 = v25;
        if (v25)
        {
          if (v23 == 1)
          {
            CFRelease(*((CFTypeRef *)&CA::Display::DisplayLink::_next_wakeup_info_list + 5 * v20 + 4));
          }
          else
          {
            unint64_t v26 = 0;
            int v27 = (void **)&CA::Display::DisplayLink::_next_wakeup_info_list + 5 * v20 + 4;
            do
              CFRelease(*((CFTypeRef *)*v27 + v26++));
            while (v26 < *v24);
            free(*v27);
            uint64_t v19 = v56;
          }
        }
        *uint64_t v24 = 0;
        unsigned int v9 = CA::Display::DisplayLink::_next_wakeup_info_count - 1;
        CA::Display::DisplayLink::_next_wakeup_info_count = v9;
        unint64_t v28 = (char *)&CA::Display::DisplayLink::_next_wakeup_info_list + 40 * v9;
        long long v29 = *(_OWORD *)v21;
        long long v30 = *((_OWORD *)v21 + 1);
        uint64_t v31 = *((void *)v21 + 4);
        uint64_t v32 = *((void *)v28 + 4);
        long long v33 = *((_OWORD *)v28 + 1);
        *(_OWORD *)int32x2_t v21 = *(_OWORD *)v28;
        *((_OWORD *)v21 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v33;
        *((void *)v21 + 4) = v32;
        *((void *)v28 + 4) = v31;
        *(_OWORD *)unint64_t v28 = v29;
        *((_OWORD *)v28 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v30;
      }
    }
    while (v20 < v9);
    if (!a2 && v9 == 4) {
      goto LABEL_59;
    }
  }
  uint64_t v10 = (long long *)((char *)&CA::Display::DisplayLink::_next_wakeup_info_list + 40 * v9);
  if (v9)
  {
    uint64_t v11 = 40 * v9;
    uint64_t v12 = &CA::Display::DisplayLink::_next_wakeup_info_list;
    while (*(void *)v12 != a5)
    {
      uint64_t v12 = (long long *)((char *)v12 + 40);
      v11 -= 40;
      if (!v11) {
        goto LABEL_35;
      }
    }
  }
  else
  {
    uint64_t v12 = &CA::Display::DisplayLink::_next_wakeup_info_list;
  }
  if (v12 != v10)
  {
    if (a2 == 2)
    {
      uint64_t v13 = *((void *)v12 + 3);
      if (v13)
      {
        if (v13 == 1)
        {
          CFRelease(*((CFTypeRef *)v12 + 4));
        }
        else
        {
          unint64_t v14 = 0;
          do
            CFRelease(*(CFTypeRef *)(*((void *)v12 + 4) + 8 * v14++));
          while (v14 < *((void *)v12 + 3));
          free(*((void **)v12 + 4));
        }
      }
      *((void *)v12 + 3) = 0;
      uint64_t v15 = (char *)&CA::Display::DisplayLink::_next_wakeup_info_list
          + 40 * --CA::Display::DisplayLink::_next_wakeup_info_count;
      uint64_t v59 = *((void *)v12 + 4);
      long long v57 = *v12;
      long long v58 = v12[1];
      long long v16 = *(_OWORD *)v15;
      long long v17 = *((_OWORD *)v15 + 1);
      *((void *)v12 + 4) = *((void *)v15 + 4);
      *uint64_t v12 = v16;
      v12[1] = v17;
      *(_OWORD *)uint64_t v15 = v57;
      *((_OWORD *)v15 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v58;
      *((void *)v15 + 4) = v59;
      goto LABEL_59;
    }
    uint64_t v10 = v12;
    goto LABEL_37;
  }
LABEL_35:
  if (a2 != 2)
  {
    CA::Display::DisplayLink::_next_wakeup_info_count = v9 + 1;
    long long *v10 = 0u;
    v10[1] = 0u;
    *((void *)v10 + 4) = 0;
LABEL_37:
    *(void *)uint64_t v10 = a5;
    *((void *)v10 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = a3;
    double v34 = (double)a4;
    uint64_t v35 = *(void *)(a5 + 8);
    uint64_t v36 = (CA::Display::DisplayTimingsControl *)(v35 + 464);
    uint64_t v37 = 528;
    if ((*(unsigned char *)(v35 + 697) & 8) == 0) {
      uint64_t v37 = 512;
    }
    unint64_t v38 = CAHostTimeWithTime(*(double *)(v35 + v37));
    *((void *)v10 + 2) = vcvtad_u64_f64(v34 / (double)CA::Display::DisplayTimingsControl::granularity(v36, v38));
    uint64_t v39 = *(void *)(a5 + 24);
    if (v39)
    {
      uint64_t v40 = 0;
      uint64_t v41 = v39;
      do
      {
        uint64_t v42 = v40++;
        uint64_t v41 = *(void *)(v41 + 8);
      }
      while (v41);
      uint64_t v43 = *((void *)v10 + 3);
      if (v40 == v43)
      {
        long long v46 = (long long *)*((void *)v10 + 4);
        int v45 = v10 + 2;
        int v44 = v46;
        if (v42) {
          int8x16_t v47 = v44;
        }
        else {
          int8x16_t v47 = v45;
        }
        if (v40)
        {
          for (uint64_t i = 0; i != v40; ++i)
          {
            if (!CFEqual(*((CFTypeRef *)v47 + i), *(CFTypeRef *)v39))
            {
              CFRelease(*((CFTypeRef *)v47 + i));
              *((void *)v47 + i) = CFRetain(*(CFTypeRef *)v39);
            }
            uint64_t v39 = *(void *)(v39 + 8);
          }
        }
      }
      else
      {
        if (v43)
        {
          if (v43 == 1)
          {
            CFRelease(*((CFTypeRef *)v10 + 4));
          }
          else
          {
            unint64_t v51 = 0;
            do
              CFRelease(*(CFTypeRef *)(*((void *)v10 + 4) + 8 * v51++));
            while (v51 < *((void *)v10 + 3));
            free(*((void **)v10 + 4));
          }
        }
        uint64_t v52 = 0;
        *((void *)v10 + 3) = 0;
        uint64_t v53 = v39;
        do
        {
          uint64_t v54 = v52++;
          uint64_t v53 = *(void *)(v53 + 8);
        }
        while (v53);
        if (v52)
        {
          *((void *)v10 + 3) = v52;
          if (v54)
          {
            uint64_t v55 = 0;
            *((void *)v10 + 4) = malloc_type_malloc(8 * v52, 0x6004044C4A2DFuLL);
            do
            {
              *(void *)(*((void *)v10 + 4) + 8 * v55) = CFRetain(*(CFTypeRef *)v39);
              uint64_t v39 = *(void *)(v39 + 8);
              ++v55;
            }
            while (v52 != v55);
          }
          else
          {
            *((void *)v10 + 4) = CFRetain(*(CFTypeRef *)v39);
          }
        }
      }
    }
    else
    {
      uint64_t v49 = *((void *)v10 + 3);
      if (v49)
      {
        if (v49 == 1)
        {
          CFRelease(*((CFTypeRef *)v10 + 4));
        }
        else
        {
          unint64_t v50 = 0;
          do
            CFRelease(*(CFTypeRef *)(*((void *)v10 + 4) + 8 * v50++));
          while (v50 < *((void *)v10 + 3));
          free(*((void **)v10 + 4));
        }
      }
      *((void *)v10 + 3) = 0;
    }
  }
LABEL_59:
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Display::DisplayLink::_next_wakeup_info_lock);
  if (a2 == 2)
  {
    if (CA::Display::DisplayLink::_will_fire_handler_external) {
      (*(void (**)(void))(CA::Display::DisplayLink::_will_fire_handler_external + 16))();
    }
  }
}

void sub_1847A6998(_Unwind_Exception *a1)
{
}

void std::vector<CA::Display::DisplayLinkItem *>::insert(uint64_t a1, char *__src, char *a3)
{
  int v3 = a3;
  int v6 = *(char **)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v12 = *(char **)a1;
    unint64_t v13 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v13 >> 61) {
      abort();
    }
    uint64_t v14 = __src - v12;
    uint64_t v15 = (__src - v12) >> 3;
    uint64_t v16 = v7 - (void)v12;
    if (v16 >> 2 > v13) {
      unint64_t v13 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v13;
    }
    if (v17)
    {
      uint64_t v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v17);
    }
    else
    {
      uint64_t v19 = 0;
      uint64_t v18 = 0;
    }
    unsigned int v20 = &v19[8 * v15];
    int32x2_t v21 = &v19[8 * v18];
    if (v15 == v18)
    {
      if (v14 < 1)
      {
        if (v12 == __src) {
          unint64_t v23 = 1;
        }
        else {
          unint64_t v23 = v14 >> 2;
        }
        uint64_t v24 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v23);
        unsigned int v20 = &v24[8 * (v23 >> 2)];
        int32x2_t v21 = &v24[8 * v25];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v22 = v15 + 2;
        if (v15 >= -1) {
          unint64_t v22 = v15 + 1;
        }
        v20 -= 8 * (v22 >> 1);
      }
    }
    *(void *)unsigned int v20 = *(void *)v3;
    unint64_t v26 = v20 + 8;
    int v27 = *(char **)a1;
    if (*(char **)a1 != __src)
    {
      unint64_t v28 = __src;
      do
      {
        uint64_t v29 = *((void *)v28 - 1);
        v28 -= 8;
        *((void *)v20 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v29;
        v20 -= 8;
      }
      while (v28 != v27);
    }
    long long v30 = *(unsigned char **)(a1 + 8);
    uint64_t v31 = v30 - __src;
    if (v30 != __src) {
      memmove(v26, __src, v30 - __src);
    }
    uint64_t v32 = *(char **)a1;
    *(void *)a1 = v20;
    *(void *)(a1 + 8) = &v26[v31];
    *(void *)(a1 + 16) = v21;
    if (v32)
    {
      operator delete(v32);
    }
  }
  else if (__src == v6)
  {
    *(void *)__vImage_Buffer src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    uint64_t v8 = __src + 8;
    unsigned int v9 = v6 - 8;
    uint64_t v10 = *(void **)(a1 + 8);
    while (v9 < v6)
    {
      uint64_t v11 = *(void *)v9;
      v9 += 8;
      *v10++ = v11;
    }
    *(void *)(a1 + 8) = v10;
    if (v6 != v8) {
      memmove(&v6[-8 * ((v6 - v8) >> 3)], __src, v6 - v8);
    }
    if (__src <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)__vImage_Buffer src = *(void *)v3;
  }
}

void sub_1847A6BE8(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CA::Display::DisplayLinkItem::set_display_active(uint64_t this, int a2)
{
  char v2 = *(unsigned char *)(this + 316);
  if (((((v2 & 0x10) == 0) ^ a2) & 1) == 0)
  {
    uint64_t v4 = this;
    char v5 = a2 ? 16 : 0;
    *(unsigned char *)(this + 316) = v2 & 0xEF | v5;
    if ((v2 & 1) == 0)
    {
      [*(id *)(this + 256) willChangeValueForKey:@"active"];
      if (a2) {
        char v6 = 8;
      }
      else {
        char v6 = 0;
      }
      *(unsigned char *)(v4 + 316) = *(unsigned char *)(v4 + 316) & 0xF7 | v6;
      unint64_t v7 = *(void **)(v4 + 256);
      return [v7 didChangeValueForKey:@"active"];
    }
  }
  return this;
}

CA::Display::DisplayLinkItem *CA::Display::DisplayLinkItem::DisplayLinkItem(CA::Display::DisplayLinkItem *this, id *a2, const void *a3, objc_selector *a4)
{
  *(void *)this = &unk_1ED030380;
  *((_DWORD *)this + 2) = 0;
  id v8 = a2[10];
  *((void *)this + 2) = a2;
  if (a3) {
    CFTypeRef v9 = CFRetain(a3);
  }
  else {
    CFTypeRef v9 = 0;
  }
  *(_OWORD *)((char *)this + 248) = 0u;
  *((void *)this + 3) = v9;
  *((void *)this + 4) = a4;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 28CA::Context::unref(this[1], 0) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 4CA::Context::unref(this[1], 0) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 114) = 0u;
  *((unsigned char *)this + 316) &= 0xE8u;
  *((_DWORD *)this + 78) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 136), 0);
  pthread_cond_init((pthread_cond_t *)((char *)this + 200), 0);
  *((unsigned char *)this + 316) &= ~8u;
  BOOL v10 = CADeviceDisableMinimumFrameDuration();
  float v11 = 60.0;
  if (v10) {
    float v11 = 0.0;
  }
  float v12 = v11;
  float v13 = v11;
  CA::Display::DisplayLinkItem::set_preferred_fps_range((CA::Display::DisplayLink **)this, *(CAFrameRateRange *)&v11, 1, 0);
  return this;
}

void sub_1847A6FBC(_Unwind_Exception *exception_object)
{
  int v3 = *(atomic_uint **)(v1 + 264);
  if (v3) {
    CA::Display::DisplayLink::unref(v3);
  }
  _Unwind_Resume(exception_object);
}

void CA::Display::DisplayLink::refresh_item_properties_locked(CA::Display::DisplayLink *this)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)this + 15);
  uint64_t v2 = *((void *)this + 16);
  int64_t v4 = v2 - v3;
  if (v2 == v3)
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 56));
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 56));
  }
  else
  {
    if ((unint64_t)v4 > 0x1000)
    {
      char v5 = (char *)malloc_type_malloc(v2 - v3, 0x4E47E45FuLL);
    }
    else
    {
      MEMORY[0x1F4188790](this);
      char v5 = (char *)v12 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v5, v4);
    }
    uint64_t v6 = 0;
    if ((unint64_t)(v4 >> 3) <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v4 >> 3;
    }
    do
    {
      uint64_t v8 = *(void *)(*((void *)this + 15) + 8 * v6);
      *(void *)&v5[8 * v6] = v8;
      CFRetain(*(CFTypeRef *)(v8 + 256));
      ++v6;
    }
    while (v7 != v6);
    CFTypeRef v9 = (pthread_mutex_t *)((char *)this + 56);
    pthread_mutex_unlock(v9);
    uint64_t v10 = 0;
    do
    {
      uint64_t v11 = *(void *)&v5[8 * v10];
      CA::Display::DisplayLinkItem::set_preferred_fps_range((CA::Display::DisplayLink **)v11, *(CAFrameRateRange *)(v11 + 76), 0, 0);
      CFRelease(*(CFTypeRef *)(v11 + 256));
      ++v10;
    }
    while (v7 != v10);
    pthread_mutex_lock(v9);
    if ((unint64_t)v4 > 0x1000) {
      free(v5);
    }
  }
}

void sub_1847A7170(_Unwind_Exception *a1)
{
  pthread_mutex_lock(v1);
  _Unwind_Resume(a1);
}

CA::Display::DisplayLink *CA::Display::DisplayLinkItem::set_preferred_fps_range(CA::Display::DisplayLink **this, CAFrameRateRange a2, int a3, int a4)
{
  float preferred = a2.preferred;
  maximuuint64_t m = a2.maximum;
  minimuuint64_t m = a2.minimum;
  uint64_t v10 = (pthread_mutex_t *)(this + 17);
  pthread_mutex_lock((pthread_mutex_t *)(this + 17));
  v15.minimuuint64_t m = minimum;
  v15.maximuuint64_t m = maximum;
  v15.float preferred = preferred;
  BOOL v11 = CA::Display::DisplayLinkItem::set_preferred_fps_range_locked((CA::Display::DisplayLinkItem *)this, v15, a4);
  pthread_mutex_unlock(v10);
  unint64_t result = this[33];
  if (result) {
    BOOL v13 = (v11 & a3) == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13)
  {
    return (CA::Display::DisplayLink *)CA::Display::DisplayLink::item_properties_changed(result);
  }
  return result;
}

void sub_1847A723C(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL CA::Display::DisplayLinkItem::set_preferred_fps_range_locked(CA::Display::DisplayLinkItem *this, CAFrameRateRange a2, int a3)
{
  float preferred = a2.preferred;
  maximuuint64_t m = a2.maximum;
  minimuuint64_t m = a2.minimum;
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  int v8 = CA::Display::DisplayTimingsControl::server_compat_quanta_mode((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), 0);
  *((unsigned char *)this + 128) = v8;
  v48.minimuuint64_t m = minimum;
  v48.maximuuint64_t m = maximum;
  v48.float preferred = preferred;
  unint64_t v9 = CA::Display::DisplayTimingsControl::fps_range_to_frame_interval_range((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), v48, v8);
  unsigned int v11 = v10;
  unint64_t v12 = HIDWORD(v9);
  if ((*(unsigned char *)(*((void *)this + 2) + 697) & 2) != 0)
  {
    if (CAHighFrameRateRestrictionEnabled(void)::once != -1) {
      dispatch_once(&CAHighFrameRateRestrictionEnabled(void)::once, &__block_literal_global_6);
    }
    if (CAHighFrameRateRestrictionEnabled(void)::enabled && !*((_DWORD *)this + 22))
    {
      if (CADeviceDisableMinimumFrameDurationOnPhone::once != -1) {
        dispatch_once(&CADeviceDisableMinimumFrameDurationOnPhone::once, &__block_literal_global_147);
      }
      if (v9 <= 3) {
        int v13 = 3;
      }
      else {
        int v13 = v9;
      }
      if (HIDWORD(v9) <= 4) {
        unsigned int v14 = 4;
      }
      else {
        unsigned int v14 = HIDWORD(v9);
      }
      if (v11 <= 4) {
        int v15 = 4;
      }
      else {
        int v15 = v11;
      }
      if (!v11) {
        int v15 = 0;
      }
      if (CADeviceDisableMinimumFrameDurationOnPhone::disabled)
      {
        unint64_t v12 = HIDWORD(v9);
      }
      else
      {
        unsigned int v11 = v15;
        unint64_t v12 = v14;
      }
      if (!CADeviceDisableMinimumFrameDurationOnPhone::disabled) {
        LODWORD(v9) = v13;
      }
    }
  }
  if (byte_1EB2ACC47)
  {
    uint64_t v16 = 0x200000002;
    unsigned int v17 = 2;
    LODWORD(v9) = 2;
    LODWORD(v12) = 2;
    unsigned int v11 = 2;
  }
  else
  {
    uint64_t v16 = v9 | (v12 << 32);
    unsigned int v17 = v11;
    if (!v9)
    {
LABEL_65:
      *(void *)&v45.unsigned int var0 = v16;
      v45.unsigned int var2 = v17;
      v49.minimuuint64_t m = minimum;
      v49.maximuuint64_t m = maximum;
      v49.float preferred = preferred;
      CAFrameIntervalRangeLogInvalidRange(v45, v49);
      return 0;
    }
  }
  if ((v9 > v11 || v11 > v12) && (v9 > v12 || v11)) {
    goto LABEL_65;
  }
  if (!*((void *)this + 33) || (*((unsigned char *)this + 316) & 1) != 0) {
    goto LABEL_48;
  }
  if ((*((unsigned char *)this + 316) & 4) != 0)
  {
    if (*((_DWORD *)this + 16) != v9 || *((_DWORD *)this + 17) != v12 || *((_DWORD *)this + 18) != v11)
    {
      if ((*(unsigned char *)(*((void *)this + 2) + 697) & 2) == 0) {
        goto LABEL_49;
      }
      if ((*((unsigned char *)this + 316) & 4) != 0 && *((unsigned char *)this + 129)) {
        __assert_rtn("update_frame_interval_range", "CADisplay.mm", 6470, "!_registered || !_has_deferred_unregister_frame_interval_range");
      }
      goto LABEL_41;
    }
LABEL_48:
    *((void *)this + 8) = v16;
    *((_DWORD *)this + 18) = v11;
    goto LABEL_49;
  }
  if ((*(unsigned char *)(*((void *)this + 2) + 697) & 2) != 0)
  {
LABEL_41:
    if (byte_1EB2ACC45)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int v27 = x_log_category_frame_rate;
        if (os_log_type_enabled((os_log_t)x_log_category_frame_rate, OS_LOG_TYPE_DEFAULT))
        {
          int v28 = *((_DWORD *)this + 16);
          int v29 = *((_DWORD *)this + 17);
          int v30 = *((_DWORD *)this + 18);
          *(_DWORD *)long long buf = 67110400;
          int v32 = v28;
          __int16 v33 = 1024;
          int v34 = v29;
          __int16 v35 = 1024;
          int v36 = v30;
          __int16 v37 = 1024;
          int v38 = v9;
          __int16 v39 = 1024;
          int v40 = v12;
          __int16 v41 = 1024;
          unsigned int v42 = v11;
          _os_log_impl(&dword_184668000, v27, OS_LOG_TYPE_DEFAULT, "CAFrameRateClient: update %u %u %u to %u %u %u", buf, 0x26u);
        }
      }
    }
    if (*((unsigned char *)this + 129)) {
      CA::Display::DisplayLinkItem::run_deferred_unregister_frame_interval_range(this);
    }
    uint64_t v18 = (os_unfair_lock_s *)(*((void *)this + 2) + 464);
    if ((*((unsigned char *)this + 316) & 4) != 0)
    {
      *(void *)&v47.unsigned int var0 = v16;
      v47.unsigned int var2 = v17;
      CA::Display::DisplayTimingsControl::update_frame_interval_range(v18, *(CAFrameIntervalRange *)((char *)this + 64), v47);
    }
    else
    {
      *(void *)&v46.unsigned int var0 = v16;
      v46.unsigned int var2 = v17;
      CA::Display::DisplayTimingsControl::register_frame_interval_range(v18, v46);
    }
    *((unsigned char *)this + 316) |= 4u;
    goto LABEL_48;
  }
LABEL_49:
  int v19 = *((_DWORD *)this + 14);
  uint64_t v20 = CA::Display::DisplayTimingsControl::server_frame_interval((CA::Display::DisplayTimingsControl *)(*((void *)this + 2) + 464), 0);
  *(void *)&v44.unsigned int var0 = v16;
  v44.unsigned int var2 = v17;
  int v21 = CAFrameIntervalRangeAdaptToFrameInterval(v44, v20, (*(unsigned __int8 *)(*((void *)this + 2) + 697) >> 1) & 1);
  *((_DWORD *)this + 28) = v20;
  uint64_t v22 = mach_absolute_time();
  if (!a3 || v19 == v21) {
    goto LABEL_56;
  }
  unint64_t v23 = CA::Display::DisplayTimingsControl::server_timing_expiry((os_unfair_lock_s *)(*((void *)this + 2) + 464));
  if (v23 > v22)
  {
    unint64_t v24 = v23;
    BOOL result = 0;
    *((void *)this + 13) = v24;
    *((float *)this + 19) = minimum;
    *((float *)this + 2CA::Context::unref(this[1], 0) = maximum;
    *((float *)this + 2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = preferred;
    return result;
  }
  if ((*((unsigned char *)this + 316) & 1) != 0 || v19 >= v21)
  {
LABEL_56:
    if (*((void *)this + 13) - 1 < v22) {
      *((void *)this + 13) = 0;
    }
    *((_DWORD *)this + 14) = v21;
    *((float *)this + 19) = minimum;
    *((float *)this + 2CA::Context::unref(this[1], 0) = maximum;
    *((float *)this + 2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = preferred;
    return (*((unsigned char *)this + 316) & 1) == 0 && v19 != v21;
  }
  else
  {
    BOOL result = 0;
    *((void *)this + 13) = 1;
    *((float *)this + 19) = minimum;
    *((float *)this + 2CA::Context::unref(this[1], 0) = maximum;
    *((float *)this + 2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = preferred;
    *((_DWORD *)this + 15) = *((_DWORD *)this + 14);
  }
  return result;
}

void CA::DynamicFrameRateSource::set_preferred_fps_range(CA::DynamicFrameRateSource *this, CAFrameRateRange a2, int a3)
{
  float preferred = a2.preferred;
  maximuuint64_t m = a2.maximum;
  minimuuint64_t m = a2.minimum;
  if ((*(unsigned char *)(*((void *)this + 1) + 233) & 2) != 0)
  {
    if (CAPrefers60HzAPT(void)::once[0] != -1) {
      dispatch_once(CAPrefers60HzAPT(void)::once, &__block_literal_global_3);
    }
    float v8 = 0.0;
    float v9 = 80.0;
    float v10 = 48.0;
    if (preferred != 0.0)
    {
      float v10 = minimum;
      float v9 = maximum;
      float v8 = preferred;
    }
    if (maximum != 0.0)
    {
      float v10 = minimum;
      float v9 = maximum;
      float v8 = preferred;
    }
    if (minimum != 0.0)
    {
      float v10 = minimum;
      float v9 = maximum;
      float v8 = preferred;
    }
    if (CAPrefers60HzAPT(void)::enabled)
    {
      minimuuint64_t m = v10;
      maximuuint64_t m = v9;
      float preferred = v8;
    }
  }
  int v11 = CA::Display::DisplayTimingsControl::server_compat_quanta_mode(*((CA::Display::DisplayTimingsControl **)this + 1), 0);
  v33.minimuuint64_t m = minimum;
  v33.maximuuint64_t m = maximum;
  v33.float preferred = preferred;
  unint64_t v12 = CA::Display::DisplayTimingsControl::fps_range_to_frame_interval_range(*((CA::Display::DisplayTimingsControl **)this + 1), v33, v11);
  unsigned int v14 = v13;
  uint64_t v15 = HIDWORD(v12);
  if ((*(unsigned char *)(*((void *)this + 1) + 233) & 2) == 0) {
    goto LABEL_20;
  }
  if (CAHighFrameRateRestrictionEnabled(void)::once != -1) {
    dispatch_once(&CAHighFrameRateRestrictionEnabled(void)::once, &__block_literal_global_6);
  }
  if (!CAHighFrameRateRestrictionEnabled(void)::enabled || *((_DWORD *)this + 18)) {
    goto LABEL_20;
  }
  if (CADeviceDisableMinimumFrameDurationOnPhone::once != -1) {
    dispatch_once(&CADeviceDisableMinimumFrameDurationOnPhone::once, &__block_literal_global_147);
  }
  if (!CADeviceDisableMinimumFrameDurationOnPhone::disabled)
  {
    if (v12 <= 3) {
      unint64_t v12 = 3;
    }
    else {
      unint64_t v12 = v12;
    }
    if (v15 <= 4) {
      uint64_t v15 = 4;
    }
    else {
      uint64_t v15 = v15;
    }
    if (v14 <= 4) {
      int v24 = 4;
    }
    else {
      int v24 = v14;
    }
    if (v14) {
      unsigned int v16 = v24;
    }
    else {
      unsigned int v16 = 0;
    }
    unint64_t v17 = v12 | (v15 << 32);
    unsigned int v14 = v16;
  }
  else
  {
LABEL_20:
    unsigned int v16 = v14;
    unint64_t v17 = v12;
    if (!v12) {
      goto LABEL_65;
    }
  }
  if (v12 <= v14 && v14 <= v15)
  {
LABEL_32:
    if (*((unsigned char *)this + 104))
    {
LABEL_44:
      *(void *)((char *)this + 28) = v17;
      *((_DWORD *)this + 9) = v14;
      goto LABEL_45;
    }
    if (*((unsigned char *)this + 88))
    {
      if (*((_DWORD *)this + 7) == v12 && *((_DWORD *)this + 8) == v15 && *((_DWORD *)this + 9) == v14) {
        goto LABEL_44;
      }
      uint64_t v20 = *((void *)this + 1);
      if ((*(unsigned char *)(v20 + 233) & 2) == 0) {
        goto LABEL_45;
      }
      if (*((unsigned char *)this + 88))
      {
        *(void *)&v32.unsigned int var0 = v17;
        v32.unsigned int var2 = v16;
        CA::Display::DisplayTimingsControl::update_frame_interval_range((os_unfair_lock_s *)v20, *(CAFrameIntervalRange *)((char *)this + 28), v32);
        goto LABEL_43;
      }
    }
    else
    {
      uint64_t v20 = *((void *)this + 1);
      if ((*(unsigned char *)(v20 + 233) & 2) == 0)
      {
LABEL_45:
        *(void *)&v31.unsigned int var0 = v17;
        v31.unsigned int var2 = v16;
        int v21 = CA::DynamicFrameRateSource::frame_interval_range_adapt_to_server_interval((CA::Display::DisplayTimingsControl **)this, v31, 0);
        *((void *)this + 8) = CA::Display::DisplayTimingsControl::server_frame_interval(*((CA::Display::DisplayTimingsControl **)this + 1), 0);
        uint64_t v22 = mach_absolute_time();
        if (a3
          && (unint64_t v23 = CA::Display::DisplayTimingsControl::server_timing_expiry(*((os_unfair_lock_s **)this + 1)), v23 > v22))
        {
          *((void *)this + 7) = v23;
        }
        else
        {
          if (*((void *)this + 7) - 1 < v22) {
            *((void *)this + 7) = 0;
          }
          *((_DWORD *)this + 12) = v21;
        }
        *((float *)this + 4) = minimum;
        *((float *)this + 5) = maximum;
        *((float *)this + 6) = preferred;
        return;
      }
    }
    *(void *)&v30.unsigned int var0 = v17;
    v30.unsigned int var2 = v16;
    CA::Display::DisplayTimingsControl::register_frame_interval_range((os_unfair_lock_s *)v20, v30);
LABEL_43:
    *((unsigned char *)this + 88) |= 1u;
    goto LABEL_44;
  }
  if (v12 <= v15 && v14 == 0)
  {
    unsigned int v14 = 0;
    goto LABEL_32;
  }
LABEL_65:
  *(void *)&v25.unsigned int var0 = v17;
  v25.unsigned int var2 = v16;
  float v26 = minimum;
  float v27 = maximum;
  float v28 = preferred;

  CAFrameIntervalRangeLogInvalidRange(v25, *(CAFrameRateRange *)&v26);
}

uint64_t CAFrameIntervalRangeAdaptToFrameInterval(CAFrameIntervalRange a1, uint64_t a2, int a3)
{
  int v3 = a2;
  unsigned int var2 = a1.var2;
  unsigned int var0 = a1.var0;
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  unsigned int var1 = a1.var1;
  if (!(a1.var1 | a1.var0 | a1.var2)) {
    return a2;
  }
  if (a2 && a3 && (!a1.var2 || a1.var2 != a2))
  {
    if (!a1.var2 && a1.var0 <= a2 && a1.var1 >= a2) {
      return a2;
    }
    if (!a1.var0
      || (!a1.var2 ? (BOOL v7 = a1.var0 > a1.var1) : (BOOL v7 = 1),
          v7 ? (char v8 = 0) : (char v8 = 1),
          a1.var2 <= a1.var1 ? (BOOL v9 = a1.var0 > a1.var2) : (BOOL v9 = 1),
          v9 && (v8 & 1) == 0))
    {
      __assert_rtn("CAFrameIntervalRangeAdaptToFrameInterval", "CATimingReference.cpp", 269, "CAFrameIntervalRangeIsValid (range)");
    }
    if (a2 > 5) {
      __assert_rtn("CAFrameIntervalRangeAdaptToFrameInterval", "CATimingReference.cpp", 270, "target_interval <= CAFrameIntervalServerIntervalMax");
    }
    uint64_t v10 = 0;
    while (1)
    {
      unsigned int v11 = frame_interval_table[v10];
      if (v11 >= a1.var0) {
        break;
      }
      if (++v10 == 21)
      {
        LODWORD(v1CA::Context::unref(this[1], 0) = -1;
        goto LABEL_27;
      }
    }
    if (v11 != a1.var0) {
      LODWORD(v1CA::Context::unref(this[1], 0) = -1;
    }
LABEL_27:
    uint64_t v12 = 0;
    while (1)
    {
      unsigned int v13 = frame_interval_table[v12];
      if (v13 >= a1.var1) {
        break;
      }
      if (++v12 == 21)
      {
        LODWORD(v12) = -1;
        goto LABEL_33;
      }
    }
    if (v13 != a1.var1) {
      LODWORD(v12) = -1;
    }
LABEL_33:
    uint64_t v14 = 0;
    while (1)
    {
      unsigned int v15 = frame_interval_table[v14];
      if (v15 >= a1.var2) {
        break;
      }
      if (++v14 == 21)
      {
        LODWORD(v14) = -1;
        goto LABEL_39;
      }
    }
    if (v15 != a1.var2) {
      LODWORD(v14) = -1;
    }
LABEL_39:
    uint64_t v16 = 0;
    while (1)
    {
      unsigned int v17 = frame_interval_table[v16];
      if (v17 >= a2) {
        break;
      }
      if (++v16 == 21)
      {
        LODWORD(v16) = -1;
        goto LABEL_45;
      }
    }
    if (v17 != a2) {
      LODWORD(v16) = -1;
    }
LABEL_45:
    if (v10 == -1
      || v12 == -1
      || (v14 == -1 ? (BOOL v18 = a1.var2 == 0) : (BOOL v18 = 1), !v18 || v16 == -1))
    {
      if (x_log_hook_p())
      {
LABEL_90:
        x_log_();
        goto LABEL_95;
      }
      uint64_t v21 = x_log_category_utilities;
      if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR)) {
        goto LABEL_95;
      }
      *(_DWORD *)long long buf = 67109888;
      unsigned int v33 = var0;
      __int16 v34 = 1024;
      unsigned int v35 = var1;
      __int16 v36 = 1024;
      unsigned int v37 = var2;
      __int16 v38 = 1024;
      int v39 = v3;
      uint64_t v22 = "Invalid frame interval range (%d %d %d) or target interval (%d)";
      unint64_t v23 = v21;
      os_log_type_t v24 = OS_LOG_TYPE_ERROR;
      goto LABEL_94;
    }
    if (a1.var2)
    {
      if ((int)v14 - (int)v10 <= (int)v12 - (int)v14) {
        int v19 = v12 - v14;
      }
      else {
        int v19 = v14 - v10;
      }
    }
    else if (a1.var1 <= a2)
    {
      int v19 = v12 - v10;
      LODWORD(v14) = v12;
    }
    else if (a1.var0 >= a2)
    {
      int v19 = v12 - v10;
      LODWORD(v14) = v10;
    }
    else
    {
      if ((int)v16 - (int)v10 <= (int)v12 - (int)v16) {
        int v19 = v12 - v16;
      }
      else {
        int v19 = v16 - v10;
      }
      LODWORD(v14) = v16;
    }
    int v25 = 0;
    int v26 = 0;
    uint64_t result = 0;
    if (v19 <= 3) {
      int v19 = 3;
    }
    do
    {
      if (v25) {
        int v27 = v26;
      }
      else {
        int v27 = -v26;
      }
      int v28 = v27 + v14;
      if ((v27 + v14) <= 0x13)
      {
        unsigned int v29 = frame_interval_table[v28];
        unsigned int v30 = a2 % v29;
        if (v29 > a2) {
          unsigned int v30 = v29 % a2;
        }
        if (!v30)
        {
          if ((int)v10 <= v28 && v28 <= (int)v12) {
            return frame_interval_table[v28];
          }
          if (!result)
          {
            if (v29 >= var0) {
              uint64_t result = v29;
            }
            else {
              uint64_t result = 0;
            }
          }
        }
      }
      v25 ^= 1u;
      v26 += v25;
    }
    while (v26 <= v19);
    if (result) {
      return result;
    }
    if (x_log_hook_p()) {
      goto LABEL_90;
    }
    uint64_t v31 = x_log_category_utilities;
    if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109888;
      unsigned int v33 = var0;
      __int16 v34 = 1024;
      unsigned int v35 = var1;
      __int16 v36 = 1024;
      unsigned int v37 = var2;
      __int16 v38 = 1024;
      int v39 = v3;
      uint64_t v22 = "Unable to adapt interval range (%u %u %u) to %u.";
      unint64_t v23 = v31;
      os_log_type_t v24 = OS_LOG_TYPE_DEFAULT;
LABEL_94:
      _os_log_impl(&dword_184668000, v23, v24, v22, buf, 0x1Au);
    }
  }
LABEL_95:
  if (var2) {
    return var2;
  }
  else {
    return var0;
  }
}

unint64_t CA::Display::DisplayTimingsControl::fps_range_to_frame_interval_range(CA::Display::DisplayTimingsControl *this, CAFrameRateRange a2, int a3)
{
  float preferred = a2.preferred;
  maximuuint64_t m = a2.maximum;
  minimuuint64_t m = a2.minimum;
  int v8 = CA::Display::DisplayTimingsControl::compat_quanta_mode(this);
  uint64_t v9 = 64;
  if ((*((unsigned char *)this + 233) & 8) == 0) {
    uint64_t v9 = 48;
  }
  if (*((unsigned char *)this + 233)) {
    unsigned int v10 = 2;
  }
  else {
    unsigned int v10 = 1;
  }
  if (v10 <= *((_DWORD *)this + 14)) {
    unsigned int v10 = *((_DWORD *)this + 14);
  }
  if (v10 <= *((_DWORD *)this + 22)) {
    LOBYTE(v1CA::Context::unref(this[1], 0) = *((_DWORD *)this + 22);
  }
  v12.minimuuint64_t m = minimum;
  v12.maximuuint64_t m = maximum;
  v12.float preferred = preferred;
  return CAFrameRateRangeToFrameIntervalRange(v12, *(double *)((char *)this + v9), v10, *((unsigned char *)this + 233) & 1, v8, a3);
}

uint64_t CA::DynamicFrameRateSource::frame_interval_range_adapt_to_server_interval(CA::Display::DisplayTimingsControl **this, CAFrameIntervalRange a2, uint64_t a3)
{
  unsigned int var2 = a2.var2;
  uint64_t v4 = *(void *)&a2.var0;
  uint64_t v6 = CA::Display::DisplayTimingsControl::server_frame_interval(this[1], a3);
  int v7 = (*((unsigned __int8 *)this[1] + 233) >> 1) & 1;
  v8.unsigned int var2 = var2;
  *(void *)&v8.unsigned int var0 = v4;

  return CAFrameIntervalRangeAdaptToFrameInterval(v8, v6, v7);
}

void CA::Display::DisplayTimingsControl::update_frame_interval_range(os_unfair_lock_s *this, CAFrameIntervalRange a2, CAFrameIntervalRange a3)
{
  if ((this[58]._os_unfair_lock_opaque & 0x200) != 0)
  {
    unsigned int var2 = a3.var2;
    uint64_t v4 = *(void *)&a3.var0;
    unsigned int v5 = a2.var2;
    uint64_t v6 = *(void *)&a2.var0;
    CAFrameIntervalRange v8 = this + 23;
    os_unfair_lock_lock(this + 23);
    v17.unsigned int var2 = v5;
    *(void *)&v17.unsigned int var0 = v6;
    CA::Display::DisplayTimingsControl::_unregister_frame_interval_range((CA::Display::DisplayTimingsControl *)this, v17);
    v18.unsigned int var2 = var2;
    *(void *)&v18.unsigned int var0 = v4;
    CA::Display::DisplayTimingsControl::_register_frame_interval_range((CA::Display::DisplayTimingsControl *)this, v18);
    CA::Display::DisplayTimingsControl::update_frame_interval_request((CA::Display::DisplayTimingsControl *)this, v9, v10, v11, v12, v13, v14, v15);
    os_unfair_lock_unlock(v8);
  }
}

void sub_1847A7F60(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL CADeviceDisableMinimumFrameDuration()
{
  if (dyld_program_sdk_at_least()) {
    return 1;
  }
  if (CADeviceDisableMinimumFrameDuration::once != -1) {
    dispatch_once(&CADeviceDisableMinimumFrameDuration::once, &__block_literal_global_141);
  }
  return CADeviceDisableMinimumFrameDuration::disabled != 0;
}

void *x_list_copy(uint64_t *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = a1;
  uint64_t v2 = 0;
  do
  {
    int v3 = v2;
    uint64_t v4 = *v1;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v2 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    *uint64_t v2 = v4;
    v2[1] = v3;
    uint64_t v1 = (uint64_t *)v1[1];
  }
  while (v1);
  uint64_t v6 = 0;
  do
  {
    int v7 = v2;
    uint64_t v2 = (void *)v2[1];
    v7[1] = v6;
    uint64_t v6 = v7;
  }
  while (v2);
  return v7;
}

uint64_t CA::Display::DisplayLink::set_display_active(CA::Display::DisplayLink *this, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 56);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 56));
  CA::Display::DisplayLink::set_display_active_locked(this, a2);

  return pthread_mutex_unlock(v4);
}

void sub_1847A8164(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Display::DisplayLink::set_display_active_locked(CA::Display::DisplayLink *this, int a2)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  if (*((unsigned __int8 *)this + 172) != a2)
  {
    *((unsigned char *)this + 172) = a2;
    uint64_t v5 = *((void *)this + 15);
    uint64_t v4 = *((void *)this + 16);
    int64_t v6 = v4 - v5;
    if (v4 == v5)
    {
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 56));
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 56));
    }
    else
    {
      if ((unint64_t)v6 > 0x1000)
      {
        int v7 = (char *)malloc_type_malloc(v4 - v5, 0x69565E93uLL);
      }
      else
      {
        MEMORY[0x1F4188790](this);
        int v7 = (char *)v14 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
        bzero(v7, v6);
      }
      uint64_t v8 = 0;
      if ((unint64_t)(v6 >> 3) <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v6 >> 3;
      }
      do
      {
        uint64_t v10 = *(void *)(*((void *)this + 15) + 8 * v8);
        *(void *)&v7[8 * v8] = v10;
        CFRetain(*(CFTypeRef *)(v10 + 256));
        ++v8;
      }
      while (v9 != v8);
      uint64_t v11 = (pthread_mutex_t *)((char *)this + 56);
      pthread_mutex_unlock(v11);
      uint64_t v12 = 0;
      do
      {
        uint64_t v13 = *(void *)&v7[8 * v12];
        pthread_mutex_lock((pthread_mutex_t *)(v13 + 136));
        CA::Display::DisplayLinkItem::set_display_active(v13, a2);
        CFRelease(*(CFTypeRef *)(v13 + 256));
        pthread_mutex_unlock((pthread_mutex_t *)(v13 + 136));
        ++v12;
      }
      while (v9 != v12);
      pthread_mutex_lock(v11);
      if ((unint64_t)v6 > 0x1000) {
        free(v7);
      }
    }
  }
}

void sub_1847A833C(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v2);
  pthread_mutex_lock(v1);
  _Unwind_Resume(a1);
}

uint64_t CADisplayTimerRemoveFromRunLoop(uint64_t a1, __CFRunLoop *a2, const __CFString *a3)
{
  int64_t v6 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  mk_timer_cancel();
  *(unsigned char *)(a1 + 20CA::Context::unref(this[1], 0) = 1;
  int v7 = *(void (**)(uint64_t, uint64_t, void, void, void))(a1 + 192);
  if (v7) {
    v7(a1, 2, *(void *)(a1 + 224), *(void *)(a1 + 216), *(void *)(a1 + 184));
  }
  CFRunLoopRemoveSource(a2, *(CFRunLoopSourceRef *)(a1 + 136), a3);

  return pthread_mutex_unlock(v6);
}

void *CA::Display::DisplayLink::start_timer_locked(void *this)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  if (this[19])
  {
    uint64_t v1 = this;
    CA::Display::DisplayLink::align_phase_locked((CA::Display::DisplayLink *)this);
    uint64_t v2 = mach_absolute_time();
    uint64_t v3 = v1[19];
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 16));
    unint64_t v4 = *(void *)(v3 + 240);
    unint64_t v5 = *(void *)(v3 + 216);
    v9[0] = 0;
    v9[1] = v4;
    v9[2] = v5;
    v10[0] = 0;
    unint64_t phase = get_phase(v9, v2, v10);
    if (phase) {
      unint64_t v7 = v2 - phase + v10[0];
    }
    else {
      unint64_t v7 = v2;
    }
    *(void *)(v3 + 224) = v7;
    mk_timer_arm_leeway();
    *(unsigned char *)(v3 + 20CA::Context::unref(this[1], 0) = 0;
    uint64_t v8 = *(void (**)(uint64_t, void, void, void, void))(v3 + 192);
    if (v8) {
      v8(v3, 0, *(void *)(v3 + 224), *(void *)(v3 + 216), *(void *)(v3 + 184));
    }
    return (void *)pthread_mutex_unlock((pthread_mutex_t *)(v3 + 16));
  }
  return this;
}

CATransform3D *__cdecl CATransform3DMakeRotation(CATransform3D *__return_ptr retstr, CGFloat angle, CGFloat x, CGFloat y, CGFloat z)
{
  *(_OWORD *)&retstr->m41 = 0u;
  *(_OWORD *)&retstr->m43 = 0u;
  *(_OWORD *)&retstr->m31 = 0u;
  *(_OWORD *)&retstr->m33 = 0u;
  *(_OWORD *)&retstr->m21 = 0u;
  *(_OWORD *)&retstr->m23 = 0u;
  *(_OWORD *)&retstr->m11 = 0u;
  *(_OWORD *)&retstr->m13 = 0u;
  CA::Mat4Impl::mat4_set_rotation((CA::Mat4Impl *)retstr, v5, angle, x, y, z);
  return result;
}

atomic_uint *___ZN2CA3OGL20update_backdrop_lumaERNS0_8RendererE_block_invoke(uint64_t a1, float a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a2 >= 0.0)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    mach_port_t v4 = *(_DWORD *)(*(void *)(a1 + 32) + 256);
    uint64_t v8 = *MEMORY[0x1E4F14068];
    uint64_t v9 = v3;
    float v10 = a2;
    *(void *)&msg.msgh_bits = 19;
    msg.msgh_voucher_port = 0;
    msg.mach_msg_id_t msgh_id = 40409;
    msg.msgh_remote_port = v4;
    msg.msgh_local_port = 0;
    if (MEMORY[0x1E4F14B18]) {
      voucher_mach_msg_set(&msg);
    }
    if ((mach_msg(&msg, 17, 0x2Cu, 0, 0, 0, 0) - 268435459) <= 1)
    {
      if ((msg.msgh_bits & 0x1F00) == 0x1100) {
        mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
      }
      mach_msg_destroy(&msg);
    }
  }
  uint64_t result = *(atomic_uint **)(a1 + 32);
  if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1)
  {
    int64_t v6 = *(uint64_t (**)(void))(*(void *)result + 16);
    return (atomic_uint *)v6();
  }
  return result;
}

uint64_t getValues(NSValue *a1, double *a2, unint64_t *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t result = [(NSValue *)a1 objCType];
  if (!result) {
    goto LABEL_7;
  }
  unint64_t v7 = (const char *)result;
  if (!strcmp((const char *)result, "{CGRect={CGPoint=dd}{CGSize=dd}}"))
  {
    long long v14 = 0u;
    long long v15 = 0u;
    uint64_t result = [(NSValue *)a1 getValue:&v14 size:32];
    long long v11 = v15;
    *(_OWORD *)a2 = v14;
    *((_OWORD *)a2 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v11;
    *((float64x2_t *)a2 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = vaddq_f64(*(float64x2_t *)(a2 + 2), *(float64x2_t *)a2);
    unint64_t v8 = *a3;
    BOOL v9 = *a3 >= 4;
    uint64_t v10 = 4;
  }
  else if (!strcmp(v7, "{CGPoint=dd}") || !strcmp(v7, "{CGSize=dd}"))
  {
    long long v14 = 0uLL;
    uint64_t result = [(NSValue *)a1 getValue:&v14 size:16];
    *(_OWORD *)a2 = v14;
    unint64_t v8 = *a3;
    BOOL v9 = *a3 >= 2;
    uint64_t v10 = 2;
  }
  else if (!strcmp(v7, "{CAPoint3D=ddd}"))
  {
    long long v14 = 0uLL;
    *(void *)&long long v15 = 0;
    uint64_t result = [(NSValue *)a1 getValue:&v14 size:24];
    *(_OWORD *)a2 = v14;
    *((void *)a2 + 2) = v15;
    unint64_t v8 = *a3;
    BOOL v9 = *a3 >= 3;
    uint64_t v10 = 3;
  }
  else
  {
    uint64_t result = strcmp(v7, "{CACornerRadii={CGSize=dd}{CGSize=dd}{CGSize=dd}{CGSize=dd}}");
    if (result)
    {
LABEL_7:
      *a3 = 0;
      return result;
    }
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    uint64_t result = [(NSValue *)a1 getValue:&v14 size:64];
    long long v12 = v15;
    *(_OWORD *)a2 = v14;
    *((_OWORD *)a2 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v12;
    long long v13 = v17;
    *((_OWORD *)a2 + 2) = v16;
    *((_OWORD *)a2 + 3) = v13;
    unint64_t v8 = *a3;
    BOOL v9 = *a3 >= 8;
    uint64_t v10 = 8;
  }
  if (v9) {
    unint64_t v8 = v10;
  }
  *a3 = v8;
  return result;
}

uint64_t makeValue(float64x2_t *a1, unint64_t a2, objc_object *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = (const char *)[(objc_object *)a3 objCType];
  uint64_t result = 0;
  switch(a2)
  {
    case 2uLL:
      if (!v5) {
        return 0;
      }
      if (!strcmp(v5, "{CGPoint=dd}")) {
        goto LABEL_8;
      }
      unint64_t v7 = "{CGSize=dd}";
      goto LABEL_7;
    case 3uLL:
      if (!v5) {
        return 0;
      }
      unint64_t v7 = "{CAPoint3D=ddd}";
LABEL_7:
      if (strcmp(v5, v7)) {
        return 0;
      }
LABEL_8:
      if (a2 <= 2) {
        size_t v8 = 24 - 8 * a2;
      }
      else {
        size_t v8 = 0;
      }
      bzero(&v12.f64[a2], v8);
      memcpy(&v12, a1, 8 * a2);
      return [MEMORY[0x1E4F29238] valueWithBytes:&v12 objCType:v5];
    case 4uLL:
      if (!v5 || strcmp(v5, "{CGRect={CGPoint=dd}{CGSize=dd}}")) {
        return 0;
      }
      float64x2_t v9 = a1[1];
      float64x2_t v12 = *a1;
      float64x2_t v13 = vsubq_f64(v9, v12);
      return [MEMORY[0x1E4F29238] valueWithBytes:&v12 objCType:v5];
    case 8uLL:
      if (!v5 || strcmp(v5, "{CACornerRadii={CGSize=dd}{CGSize=dd}{CGSize=dd}{CGSize=dd}}")) {
        return 0;
      }
      float64x2_t v10 = a1[1];
      float64x2_t v12 = *a1;
      float64x2_t v13 = v10;
      float64x2_t v11 = a1[3];
      float64x2_t v14 = a1[2];
      float64x2_t v15 = v11;
      return [MEMORY[0x1E4F29238] valueWithBytes:&v12 objCType:v5];
    default:
      return result;
  }
}

double CA::Mat4Impl::mat4_pow(CA::Mat4Impl *this, double *a2, const double *a3, const double *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    unsigned int v5 = a2;
    if ((a2 & 0x80000000) != 0)
    {
      CA::Mat4Impl::mat4_invert(this, this, a3);
      unsigned int v5 = -v5;
    }
    if (v5 != 1)
    {
      float64x2_t v14 = (float64x2_t)xmmword_184997D50;
      long long v15 = 0u;
      long long v16 = xmmword_184997D60;
      long long v17 = 0u;
      long long v18 = 0u;
      long long v19 = xmmword_184997D50;
      long long v20 = 0u;
      long long v21 = xmmword_184997D60;
      do
      {
        if (v5) {
          CA::Mat4Impl::mat4_concat(&v14, (double *)this, v14.f64, a4);
        }
        CA::Mat4Impl::mat4_concat((float64x2_t *)this, (double *)this, (const double *)this, a4);
        BOOL v7 = v5 >= 2;
        v5 >>= 1;
      }
      while (v7);
      long long v8 = v15;
      long long v9 = v16;
      long long v10 = v17;
      *(float64x2_t *)this = v14;
      *((_OWORD *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v8;
      *((_OWORD *)this + 2) = v9;
      *((_OWORD *)this + 3) = v10;
      double result = *(double *)&v18;
      long long v11 = v19;
      long long v12 = v20;
      long long v13 = v21;
      *((_OWORD *)this + 4) = v18;
      *((_OWORD *)this + 5) = v11;
      *((_OWORD *)this + 6) = v12;
      *((_OWORD *)this + 7) = v13;
    }
  }
  else
  {
    double result = 1.0;
    *(_OWORD *)this = xmmword_184997D50;
    *((_OWORD *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0u;
    *((_OWORD *)this + 2) = xmmword_184997D60;
    *((_OWORD *)this + 3) = 0u;
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + 5) = xmmword_184997D50;
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = xmmword_184997D60;
  }
  return result;
}

void CA::Mat4Impl::mat4_mix(CA::Mat4Impl *this, float64x2_t *a2, double *a3, const double *a4, double a5)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (CA::Mat4Impl::mat4_is_affine((CA::Mat4Impl *)a2, a2->f64) && CA::Mat4Impl::mat4_is_affine((CA::Mat4Impl *)a3, v9))
  {
    float64x2_t v11 = a2[2];
    v18[0] = *a2;
    v18[1] = v11;
    int v18[2] = a2[6];
    float64x2_t v12 = *(float64x2_t *)(a3 + 4);
    v17[0] = *(float64x2_t *)a3;
    v17[1] = v12;
    void v17[2] = *(float64x2_t *)(a3 + 12);
    CA::Mat2Impl::mat2_mix((CA::Mat2Impl *)v16, v18[0].f64, v17[0].f64, v10, a5);
    *((void *)this + 2) = 0;
    *((void *)this + 3) = 0;
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + 5) = xmmword_184997D50;
    long long v13 = v16[1];
    *(_OWORD *)this = v16[0];
    *((_OWORD *)this + 2) = v13;
    *((_OWORD *)this + 3) = 0u;
    *((_OWORD *)this + 6) = v16[2];
    *((_OWORD *)this + 7) = xmmword_184997D60;
  }
  else
  {
    CA::Mat4Impl::mat4_get_unmatrix(a2->f64, (uint64_t)v18, (const double *)1);
    CA::Mat4Impl::mat4_get_unmatrix(a3, (uint64_t)v17, (const double *)1);
    CA::mix((uint64_t)v16, v18, v17, a5);
    CA::Mat4Impl::mat4_set_unmatrix(this, (uint64_t)v16, v14, v15);
  }
}

float64x2_t CA::Mat2Impl::mat2_mix(CA::Mat2Impl *this, double *a2, const double *a3, const double *a4, double a5)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  CA::Mat2Impl::mat2_get_unmatrix((uint64_t)a2, (uint64_t)&v24);
  CA::Mat2Impl::mat2_get_unmatrix((uint64_t)a3, (uint64_t)v20);
  if ((v24.f64[0] >= 0.0 || v20[0].f64[1] >= 0.0) && (v24.f64[1] >= 0.0 || v20[0].f64[0] >= 0.0))
  {
    double v8 = v26.f64[0];
  }
  else
  {
    v24.f64[0] = -v24.f64[0];
    v24.f64[1] = -v24.f64[1];
    double v8 = dbl_184998050[v26.f64[0] < 0.0] + v26.f64[0];
    v26.f64[0] = v8;
  }
  if (v8 == 0.0)
  {
    v26.f64[0] = 6.28318531;
    double v8 = 6.28318531;
  }
  double v9 = v21.f64[0];
  if (v21.f64[0] == 0.0)
  {
    v21.f64[0] = 6.28318531;
    double v9 = 6.28318531;
  }
  if (vabdd_f64(v8, v9) > 3.14159265)
  {
    BOOL v10 = v8 <= v9;
    if (v8 <= v9) {
      double v8 = v9;
    }
    float64x2_t v11 = v20;
    if (!v10) {
      float64x2_t v11 = &v24;
    }
    v11[2].f64[0] = v8 + -6.28318531;
  }
  float64x2_t v12 = vmlaq_n_f64(v24, vsubq_f64(v20[0], v24), a5);
  float64x2_t v13 = vmlaq_n_f64(v25, vsubq_f64(v20[1], v25), a5);
  float64x2_t result = vmlaq_n_f64(v26, vsubq_f64(v21, v26), a5);
  *(float64_t *)uint64_t v19 = result.f64[1];
  *(float64x2_t *)&v19[8] = vmlaq_n_f64(v27, vsubq_f64(v22, v27), a5);
  *(double *)&v19[24] = v28 + (v23 - v28) * a5;
  *(_OWORD *)this = *(_OWORD *)v19;
  *((_OWORD *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(_OWORD *)&v19[16];
  *((float64x2_t *)this + 2) = v13;
  if (result.f64[0] != 0.0)
  {
    float64x2_t v18 = v12;
    CA::Mat2Impl::mat2_rotate((float64x2_t *)this, v7, result.f64[0]);
    float64x2_t v12 = v18;
  }
  result.f64[0] = v12.f64[1];
  if (v12.f64[0] != 1.0 || v12.f64[1] != 1.0)
  {
    float64x2_t result = vmulq_n_f64(*(float64x2_t *)this, v12.f64[0]);
    float64x2_t v16 = vmulq_laneq_f64(*((float64x2_t *)this + 1), v12, 1);
    *(float64x2_t *)this = result;
    *((float64x2_t *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v16;
  }
  return result;
}

float64x2_t CA::Mat2Impl::mat2_mix_with_deriv(float64x2_t *a1, uint64_t a2, uint64_t a3, float64x2_t *a4, float64x2_t *a5, double a6, double a7)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  CA::Mat2Impl::mat2_get_unmatrix(a2, (uint64_t)&v36);
  CA::Mat2Impl::mat2_get_unmatrix(a3, (uint64_t)v32);
  if ((v36.f64[0] >= 0.0 || v32[0].f64[1] >= 0.0) && (v36.f64[1] >= 0.0 || v32[0].f64[0] >= 0.0))
  {
    double v12 = v38.f64[0];
  }
  else
  {
    v36.f64[0] = -v36.f64[0];
    v36.f64[1] = -v36.f64[1];
    double v12 = dbl_184998050[v38.f64[0] < 0.0] + v38.f64[0];
    v38.f64[0] = v12;
  }
  if (v12 == 0.0)
  {
    v38.f64[0] = 6.28318531;
    double v12 = 6.28318531;
  }
  double v13 = v33.f64[0];
  if (v33.f64[0] == 0.0)
  {
    v33.f64[0] = 6.28318531;
    double v13 = 6.28318531;
  }
  if (vabdd_f64(v12, v13) > 3.14159265)
  {
    BOOL v14 = v12 <= v13;
    if (v12 <= v13) {
      double v12 = v13;
    }
    long long v15 = v32;
    if (!v14) {
      long long v15 = &v36;
    }
    v15[2].f64[0] = v12 + -6.28318531;
  }
  float64x2_t v17 = v36;
  float64x2_t v16 = v37;
  float64x2_t v18 = vsubq_f64(v32[0], v36);
  float64x2_t v19 = vsubq_f64(v32[1], v37);
  float64x2_t v20 = vsubq_f64(v33, v38);
  float64x2_t result = vmlaq_n_f64(v38, v20, a6);
  float64x2_t v22 = vsubq_f64(v34, v39);
  *(float64_t *)uint64_t v31 = result.f64[1];
  *(float64x2_t *)&v31[8] = vmlaq_n_f64(v39, v22, a6);
  double v23 = v35 - v40;
  *(double *)&v31[24] = v40 + (v35 - v40) * a6;
  if (a4)
  {
    *a4 = vmulq_n_f64(v18, a7);
    a4[1] = vmulq_n_f64(v19, a7);
    a4[2] = vmulq_n_f64(v20, a7);
    a4[3] = vmulq_n_f64(v22, a7);
    a4[4].f64[0] = v23 * a7;
  }
  float64x2_t v24 = vmlaq_n_f64(v17, v18, a6);
  float64x2_t v25 = vmlaq_n_f64(v16, v19, a6);
  if (a5) {
    *a5 = v24;
  }
  *a1 = *(float64x2_t *)v31;
  a1[1] = *(float64x2_t *)&v31[16];
  a1[2] = v25;
  if (result.f64[0] != 0.0)
  {
    float64x2_t v30 = v24;
    CA::Mat2Impl::mat2_rotate(a1, v11, result.f64[0]);
    float64x2_t v24 = v30;
  }
  result.f64[0] = v24.f64[1];
  if (v24.f64[0] != 1.0 || v24.f64[1] != 1.0)
  {
    float64x2_t result = vmulq_n_f64(*a1, v24.f64[0]);
    float64x2_t v27 = vmulq_laneq_f64(a1[1], v24, 1);
    *a1 = result;
    a1[1] = v27;
  }
  return result;
}

void CA::Mat2Impl::mat2_get_unmatrix(uint64_t a1, uint64_t a2)
{
  double v4 = *(double *)a1;
  double v3 = *(double *)(a1 + 8);
  double v5 = *(double *)(a1 + 16);
  double v6 = *(double *)(a1 + 24);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 32);
  double v7 = sqrt(v4 * v4 + v3 * v3);
  double v8 = sqrt(v5 * v5 + v6 * v6);
  *(double *)a2 = v7;
  *(double *)(a2 + 8) = v8;
  if (-(v5 * v3 - v6 * v4) < 0.0)
  {
    if (v4 >= v6)
    {
      double v8 = -v8;
      *(double *)(a2 + 8) = v8;
    }
    else
    {
      double v7 = -v7;
      *(double *)a2 = v7;
    }
  }
  if (v7 != 0.0)
  {
    double v9 = 1.0 / v7;
    double v4 = v9 * v4;
    double v3 = v9 * v3;
  }
  if (v8 != 0.0)
  {
    double v10 = 1.0 / v8;
    double v5 = v10 * v5;
    double v6 = v10 * v6;
  }
  double v11 = atan2(v3, v4);
  *(double *)(a2 + 32) = v11;
  if (v11 != 0.0)
  {
    __double2 v12 = __sincos_stret(v11);
    double v13 = v12.__sinval * v5;
    double v5 = v12.__cosval * v5 + v12.__sinval * v4;
    double v4 = -(v13 - v12.__cosval * v4);
    double v14 = v12.__sinval * v6;
    double v6 = v12.__cosval * v6 + v12.__sinval * v3;
    double v3 = -(v14 - v12.__cosval * v3);
  }
  *(double *)(a2 + 4CA::Context::unref(this[1], 0) = v4;
  *(double *)(a2 + 48) = v3;
  *(double *)(a2 + 56) = v5;
  *(double *)(a2 + 64) = v6;
}

float64x2_t CA::Mat2Impl::mat2_rotate(float64x2_t *this, double *a2, double a3)
{
  __double2 v6 = __sincos_stret(a3);
  *(double *)v5.i64 = v6.__cosval;
  *(double *)v4.i64 = v6.__sinval;
  if (fabs(v6.__sinval) >= 0.0000001)
  {
    if (fabs(v6.__cosval) < 0.0000001)
    {
      v5.i64[0] = 1.0;
      v8.f64[0] = NAN;
      v8.f64[1] = NAN;
      v4.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v8), v5, v4).u64[0];
      v5.i64[0] = 0;
    }
  }
  else
  {
    v4.i64[0] = 1.0;
    v7.f64[0] = NAN;
    v7.f64[1] = NAN;
    v5.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v7), v4, v5).u64[0];
    v4.i64[0] = 0;
  }
  float64x2_t v9 = *this;
  float64x2_t v10 = this[1];
  float64x2_t v11 = this[2];
  float64x2_t v12 = vmlaq_n_f64(vmulq_n_f64(*this, *(double *)v5.i64), v10, *(double *)v4.i64);
  float64x2_t v13 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(*this, *(double *)v4.i64)), v10, *(double *)v5.i64);
  *this = v12;
  this[1] = v13;
  float64x2_t result = vaddq_f64(v10, v9);
  this[2] = vmlaq_f64(v11, (float64x2_t)0, result);
  return result;
}

uint64_t CA::WindowServer::anonymous namespace'::OGLDisplay::update_detached_layer(CA::WindowServer::_anonymous_namespace_::OGLDisplay *this, CA::Render::Handle *a2, uint64_t a3, CA::Render::Texture *a4, void *a5)
{
  if (a5)
  {
    uint64_t v6 = a5[1];
    uint64_t v7 = *((void *)this + 1);
    if (v6 != v7)
    {
      a5[1] = v7;
      uint64_t v6 = v7;
    }
  }
  else
  {
    uint64_t v6 = *((void *)this + 1);
  }
  return (*(uint64_t (**)(uint64_t, CA::Render::Handle *, uint64_t, CA::Render::Texture *))(*(void *)v6 + 576))(v6, a2, a3, a4);
}

uint64_t CA::WindowServer::anonymous namespace'::OGLDisplay::remove_detached_layer(CA::WindowServer::_anonymous_namespace_::OGLDisplay *this, CA::Render::Handle *a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, CA::Render::Handle *, uint64_t, void, void, void, void, void, void))(**((void **)this + 1) + 576))(*((void *)this + 1), a2, a3, 0, 0, 0, 0, 0, 0);
}

BOOL CA::WindowServer::IOMFBDisplay::detach_layer(CA::WindowServer::IOMFBDisplay *this, CA::Render::Handle *a2, int a3, CA::Render::Texture *a4, CA::WindowServer::Surface *a5, float64x2_t *a6, float64x2_t *a7, Rect *a8, unsigned int *a9)
{
  uint64_t v211 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    if (CADeviceIsVirtualized::once != -1) {
      dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
    }
    LODWORD(v198) = 0;
    if (CADeviceIsVirtualized::is_virtualized) {
      unsigned int v17 = 11;
    }
    else {
      unsigned int v17 = 1;
    }
    goto LABEL_11;
  }
  long long v15 = a8;
  unint64_t v16 = *((void *)a2 + 12);
  unsigned int v208 = a8;
  if (CADeviceIsVirtualized::once != -1) {
    dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
  }
  uint64_t v198 = (v16 >> 15) & 1;
  if (CADeviceIsVirtualized::is_virtualized)
  {
    unsigned int v17 = 11;
    goto LABEL_11;
  }
  if (!*((void *)this + 3312))
  {
    unsigned int v17 = 1;
    goto LABEL_11;
  }
  if (a5
    && ((*((unsigned int *)a5 + 56) | ((unint64_t)*((unsigned __int8 *)a5 + 228) << 32)) & 0x1000000000) != 0)
  {
    unsigned int v17 = 16;
    goto LABEL_11;
  }
  double v23 = (char *)*((void *)this + 3255);
  memset(buf, 0, 32);
  if (!v23 || (v23[292] & 1) != 0)
  {
    if (((unsigned __int16)v15 & 0x400) != 0)
    {
      unsigned int v17 = 8;
      goto LABEL_11;
    }
    int v191 = 0;
  }
  else
  {
    if (*(CA::Render::Handle **)v23 != a2)
    {
      unsigned int v17 = 2;
      goto LABEL_11;
    }
    if ((v15 & 0x40) != 0)
    {
      long long v15 = (Rect *)(*((_DWORD *)v23 + 9) & 0xD800008F | v15);
      unsigned int v208 = v15;
      long long v24 = *((_OWORD *)v23 + 17);
      *(_OWORD *)long long buf = *((_OWORD *)v23 + 16);
      *(_OWORD *)&uint8_t buf[16] = v24;
    }
    int v191 = *((_DWORD *)v23 + 10);
  }
  float64x2_t v206 = 0u;
  float64x2_t v207 = 0u;
  if (a7)
  {
    float64x2_t v25 = a7;
    if ((*((unsigned char *)this + 745) & 4) != 0)
    {
      float64x2_t v26 = *a7;
      float64x2_t v27 = a7[1];
      float64x2_t v206 = *a7;
      float64x2_t v207 = v27;
      uint64_t v29 = *((void *)this + 19);
      uint64_t v28 = *((void *)this + 20);
      v30.i64[0] = (int)v28;
      v30.i64[1] = SHIDWORD(v28);
      float64x2_t v31 = vcvtq_f64_s64(v30);
      uint64_t v33 = *((void *)this + 25);
      uint64_t v32 = *((void *)this + 26);
      v30.i64[0] = (int)v32;
      v30.i64[1] = SHIDWORD(v32);
      float64x2_t v34 = vdivq_f64(v31, vcvtq_f64_s64(v30));
      v30.i64[0] = (int)v29;
      v30.i64[1] = SHIDWORD(v29);
      float64x2_t v35 = vcvtq_f64_s64(v30);
      v30.i64[0] = (int)v33;
      v30.i64[1] = SHIDWORD(v33);
      float64x2_t v36 = vcvtq_f64_s64(v30);
      if (v34.f64[0] != 1.0 && v27.f64[0] < 1.79769313e308)
      {
        *(void *)&v206.f64[0] = *(_OWORD *)&vmulq_f64(v26, v34);
        *(void *)&v207.f64[0] = *(_OWORD *)&vmulq_f64(v27, v34);
      }
      float64x2_t v38 = vmlsq_f64(v35, v36, v34);
      if (v34.f64[1] != 1.0 && v27.f64[1] < 1.79769313e308)
      {
        v206.f64[1] = vmulq_f64(v26, v34).f64[1];
        v207.f64[1] = v27.f64[1] * v34.f64[1];
      }
      float64x2_t v206 = vaddq_f64(v38, v206);
      float64x2_t v25 = &v206;
    }
  }
  else
  {
    float64x2_t v25 = 0;
  }
  double v40 = v15;
  if ((v15 & 0x48) == 8)
  {
    double v40 = v15;
    if (a6[1].f64[0] == v25[1].f64[0])
    {
      double v40 = v15;
      if (a6[1].f64[1] == v25[1].f64[1])
      {
        double v40 = (Rect *)(v15 & 0xFFFFFFF7);
        unsigned int v208 = v15 & 0xFFFFFFF7;
      }
    }
  }
  uint64_t v41 = (char *)this + 25704;
  float64x2_t v204 = 0u;
  float64x2_t v205 = 0u;
  *(_OWORD *)&v202[0].top = 0u;
  float64x2_t v203 = 0u;
  if (a6 && v25)
  {
    unsigned int v42 = (int32x4_t *)v25;
    uint64_t v43 = v40;
    *(float64x2_t *)double v195 = *a6;
    *(float64x2_t *)double v189 = a6[1];
    float64x2_t v204 = *a6;
    float64x2_t v205 = *(float64x2_t *)v189;
    int32x4_t v44 = *v42;
    int32x4_t v45 = v42[1];
    *(int32x4_t *)&v202[0].top = *v42;
    float64x2_t v203 = (float64x2_t)v45;
    int v46 = *((_DWORD *)this + 40);
    int v47 = *((_DWORD *)this + 41);
    if (v46 <= v47) {
      int v48 = *((_DWORD *)this + 41);
    }
    else {
      int v48 = *((_DWORD *)this + 40);
    }
    v44.i32[0] = 1073741822;
    v45.i32[0] = v48;
    int8x16_t v49 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v45, v44), 0);
    uint64_t v50 = *((void *)this + 19);
    v51.i64[0] = (int)v50;
    v51.i64[1] = SHIDWORD(v50);
    int8x16_t v52 = vbslq_s8(v49, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v51));
    double v53 = (double)v46;
    double v54 = (double)v47;
    if (v48 > 1073741822)
    {
      double v53 = 1.79769313e308;
      double v54 = 1.79769313e308;
    }
    float64x2_t v187 = (float64x2_t)v52;
    *(int8x16_t *)double v209 = v52;
    *(double *)&v209[16] = v53;
    *(double *)&v209[24] = v54;
    BOOL v55 = CA::BoundsImpl::contains((double *)v209, (double *)v202);
    float64x2_t v61 = *(float64x2_t *)v189;
    float64x2_t v62 = *(float64x2_t *)v195;
    if (!v55)
    {
      CA::OGL::clip_detached_rects(&v204, v202, v43, v56, v187, *(float64x2_t *)&v209[16], v57, *(double *)v189, v58, v59, *(double *)v195, v60);
      float64x2_t v62 = v204;
      float64x2_t v61 = v205;
    }
    float64x2_t v63 = vrndaq_f64(v62);
    if (vaddvq_f64(vabdq_f64(v62, v63))
       + vabdd_f64(v61.f64[0], round(v61.f64[0]))
       + vabdd_f64(v61.f64[1], round(v61.f64[1])) < 0.004)
    {
      double v64 = v205.f64[1];
      double v65 = v205.f64[0] <= v205.f64[1] ? v205.f64[1] : v205.f64[0];
      if (v65 < 1.79769313e308)
      {
        if (v205.f64[0] < v205.f64[1]) {
          double v64 = v205.f64[0];
        }
        if (v64 > 0.0)
        {
          float64x2_t v204 = v63;
          float64x2_t v205 = vsubq_f64(vrndaq_f64(vaddq_f64(v62, v205)), v63);
        }
      }
    }
    float64x2_t v66 = vrndaq_f64(*(float64x2_t *)&v202[0].top);
    uint64_t v41 = (char *)this + 25704;
    LODWORD(v4CA::Context::unref(this[1], 0) = v43;
    if (vaddvq_f64(vabdq_f64(*(float64x2_t *)&v202[0].top, v66))
       + vabdd_f64(v203.f64[0], round(v203.f64[0]))
       + vabdd_f64(v203.f64[1], round(v203.f64[1])) < 0.004)
    {
      double v67 = v203.f64[1];
      double v68 = v203.f64[0] <= v203.f64[1] ? v203.f64[1] : v203.f64[0];
      if (v68 < 1.79769313e308)
      {
        if (v203.f64[0] < v203.f64[1]) {
          double v67 = v203.f64[0];
        }
        if (v67 > 0.0)
        {
          float64x2_t v69 = vsubq_f64(vrndaq_f64(vaddq_f64(*(float64x2_t *)&v202[0].top, v203)), v66);
          *(float64x2_t *)&v202[0].top = v66;
          float64x2_t v203 = v69;
        }
      }
    }
    double v196 = &v204;
    float64x2_t v25 = (float64x2_t *)v202;
  }
  else
  {
    double v196 = a6;
  }
  if (v23 && (v23[292] & 1) == 0)
  {
    unsigned int v70 = v40 ^ *((_DWORD *)v23 + 9);
    uint64_t v71 = (CA::Render::Texture *)*((void *)v23 + 1);
    if ((v70 & 0x10F) != 0 || v71 != a4)
    {
      if (v71 != a4) {
        goto LABEL_134;
      }
      float64x2_t v72 = (CA::WindowServer::Surface *)*((void *)v23 + 2);
    }
    else
    {
      float64x2_t v72 = (CA::WindowServer::Surface *)*((void *)v23 + 2);
      if (v72 == a5)
      {
        if ((v40 & 0x40) != 0) {
          goto LABEL_113;
        }
        float64x2_t v72 = a5;
        if (*((double *)v23 + 20) == v25->f64[0])
        {
          float64x2_t v72 = a5;
          if (*((double *)v23 + 21) == v25->f64[1])
          {
            float64x2_t v72 = a5;
            if (*((double *)v23 + 22) == v25[1].f64[0])
            {
              float64x2_t v72 = a5;
              if (*((double *)v23 + 23) == v25[1].f64[1])
              {
                float64x2_t v72 = a5;
                if (*((double *)v23 + 16) == v196->f64[0])
                {
                  float64x2_t v72 = a5;
                  if (*((double *)v23 + 17) == v196->f64[1])
                  {
                    float64x2_t v72 = a5;
                    if (*((double *)v23 + 18) == v196[1].f64[0])
                    {
                      float64x2_t v72 = a5;
                      if (*((double *)v23 + 19) == v196[1].f64[1])
                      {
                        float64x2_t v72 = a5;
                        if (*((double *)v23 + 12) == a7->f64[0])
                        {
                          float64x2_t v72 = a5;
                          if (*((double *)v23 + 13) == a7->f64[1])
                          {
                            float64x2_t v72 = a5;
                            if (*((double *)v23 + 14) == a7[1].f64[0])
                            {
                              float64x2_t v72 = a5;
                              if (*((double *)v23 + 15) == a7[1].f64[1])
                              {
LABEL_113:
                                if (a9)
                                {
                                  float64x2_t v73 = v23;
                                  unsigned int v17 = 0;
                                  *a9 = *((_DWORD *)v73 + 11);
                                  goto LABEL_11;
                                }
LABEL_311:
                                unsigned int v17 = 0;
                                goto LABEL_11;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (v72 == a5
      && v70 <= 7
      && (!v25
       || *((double *)v23 + 20) == v25->f64[0]
       && *((double *)v23 + 21) == v25->f64[1]
       && *((double *)v23 + 22) == v25[1].f64[0]
       && *((double *)v23 + 23) == v25[1].f64[1])
      && (!v196
       || *((double *)v23 + 16) == v196->f64[0]
       && *((double *)v23 + 17) == v196->f64[1]
       && *((double *)v23 + 18) == v196[1].f64[0]
       && *((double *)v23 + 19) == v196[1].f64[1]))
    {
      double v74 = 1.0;
      if (!a7
        || *((double *)v23 + 12) == a7->f64[0]
        && *((double *)v23 + 13) == a7->f64[1]
        && *((double *)v23 + 14) == a7[1].f64[0]
        && *((double *)v23 + 15) == a7[1].f64[1])
      {
        char v184 = v23;
        BOOL v128 = 0;
        double v94 = 1.0;
        if ((v40 & 0x40) != 0) {
          goto LABEL_300;
        }
        goto LABEL_277;
      }
    }
  }
LABEL_134:
  v41[2433] = 1;
  if (!a5)
  {
    unsigned int v17 = 3;
    goto LABEL_11;
  }
  (*(void (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 1840))(this);
  if (a4 && *((void *)a4 + 6) && (((unint64_t)*((unsigned __int8 *)a5 + 228) << 32) & 0x2000000000) == 0) {
    (*(void (**)(CA::WindowServer::Surface *))(*(void *)a5 + 96))(a5);
  }
  int v201 = 0;
  __asm { FMOV            V0.2D, #1.0 }
  long long v200 = _Q0;
  if (v23 && (v208 & 0x40) != 0) {
    long long v200 = *((_OWORD *)v23 + 3);
  }
  double v190 = (double *)v25;
  unsigned int v78 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, unsigned int *, long long *, CA::WindowServer::Surface *, float64x2_t *, float64x2_t *, int *))(*(void *)this + 2328))(this, &v208, &v200, a5, v196, v25, &v201);
  uint64_t v79 = (*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)a5 + 160))(a5);
  if (v79)
  {
    unint64_t v80 = (__IOSurface *)v79;
    IOSurfaceSetDetachModeCode();
    if (!byte_1EB2ACBEE) {
      goto LABEL_147;
    }
    IOSurfaceID ID = IOSurfaceGetID(v80);
  }
  else
  {
    if (!byte_1EB2ACBEE) {
      goto LABEL_147;
    }
    IOSurfaceID ID = 0;
  }
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    double v175 = x_log_category_CADebug;
    if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO))
    {
      if (v78 > 0x26) {
        double v176 = "UNKNOWN";
      }
      else {
        double v176 = CA::detach_string_display(CA::DisplayDetachReasonCode)::names[v78];
      }
      *(_DWORD *)double v209 = 67109378;
      *(_DWORD *)&v209[4] = ID;
      *(_WORD *)&v209[8] = 2080;
      *(void *)&v209[10] = v176;
      _os_log_impl(&dword_184668000, v175, OS_LOG_TYPE_INFO, "[Display] Surface ID:0x%x detach result: %s", v209, 0x12u);
    }
  }
LABEL_147:
  if (v78)
  {
    unsigned int v17 = 7;
    goto LABEL_11;
  }
  uint64_t v81 = v208;
  unsigned int v82 = v208 & 0xBF800080;
  if ((v208 & 0xBF800080) == 0x80000000)
  {
    unsigned int v83 = *((_DWORD *)a5 + 16);
    unsigned int v193 = v208;
    int v84 = CA::Render::fourcc_compressed_of_type((CA::Render *)v83, 0, 0);
    uint64_t v81 = v193;
    BOOL v85 = v84 == v83;
    unsigned int v82 = 0x80000000;
  }
  else
  {
    BOOL v85 = 0;
  }
  float64x2_t v25 = (float64x2_t *)v190;
  unsigned int v194 = v81 & 7;
  if (!v82 || v85)
  {
    if ((*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 2312))(this))
    {
      uint64_t v86 = *((void *)a2 + 2);
      if (v86)
      {
        uint64_t v87 = *(void *)(v86 + 96);
        if (v87)
        {
          if (*(unsigned char *)(v87 + 12) == 25) {
            *(unsigned char *)(v87 + 176) = 0;
          }
        }
      }
      if ((CA::WindowServer::IOMFBDisplay::exceeds_disp_bandwidth_limits_p(this, a5, v208, v196, (const CA::Rect *)v190) & 1) == 0)
      {
        *((_DWORD *)a5 + 56) = *((_DWORD *)a5 + 56) & 0xFFFF0000 | (unsigned __int16)(*((_DWORD *)a5 + 56) + 1);
        double v74 = 1.0;
        unsigned int v89 = v194;
        if (v194)
        {
          if (byte_1EB2ACC2D)
          {
            CA::WindowServer::rotate_surface_log(a5, (CA::WindowServer::Surface *)v194, v88);
            unsigned int v89 = v194;
          }
          int v185 = 0;
          unsigned int v182 = 0;
          int v191 = 2 * v89;
        }
        else
        {
          int v191 = 0;
          int v185 = 0;
          unsigned int v182 = 0;
        }
        double v94 = 1.0;
        double v178 = a5;
        if (!v23) {
          goto LABEL_267;
        }
        goto LABEL_268;
      }
LABEL_230:
      unsigned int v17 = 15;
      goto LABEL_11;
    }
    uint64_t v81 = v208;
  }
  LODWORD(v9CA::Context::unref(this[1], 0) = *((_DWORD *)a5 + 14);
  unsigned int v91 = *((_DWORD *)a5 + 15);
  if ((v81 & 0x80) != 0)
  {
    if ((v81 & 0x40000000) != 0)
    {
      int v97 = (double *)(v23 + 128);
      if ((v81 & 0x40) == 0) {
        int v97 = (double *)v196;
      }
      double v98 = *v97 + 0.5;
      uint64_t v99 = (double *)(v23 + 136);
      if ((v81 & 0x40) == 0) {
        uint64_t v99 = &v196->f64[1];
      }
      double v100 = floor(*v99 + 0.5);
      *(void *)long long buf = floor(v98);
      *(double *)&uint8_t buf[8] = v100;
      f64 = (double *)(v23 + 144);
      if ((v81 & 0x40) == 0) {
        f64 = v196[1].f64;
      }
      double v102 = round(*f64);
      double v103 = (double *)(v23 + 152);
      if ((v81 & 0x40) == 0) {
        double v103 = &v196[1].f64[1];
      }
      double v104 = round(*v103);
      *(double *)&uint8_t buf[16] = v102;
      *(double *)&uint8_t buf[24] = v104;
    }
    double v105 = (double *)(v23 + 176);
    if ((v81 & 0x40) == 0) {
      double v105 = v190 + 2;
    }
    double v106 = *v105;
    double v107 = (double *)(v23 + 184);
    if ((v81 & 0x40) == 0) {
      double v107 = v190 + 3;
    }
    double v108 = *v107;
    double v109 = (double *)(v23 + 144);
    if ((v81 & 0x40) == 0) {
      double v109 = v196[1].f64;
    }
    unsigned int v110 = (double *)(v23 + 152);
    if ((v81 & 0x40) == 0) {
      unsigned int v110 = &v196[1].f64[1];
    }
    if ((v81 & 4) != 0) {
      double v111 = v108;
    }
    else {
      double v111 = v106;
    }
    double v92 = v111 / *v109;
    if ((v81 & 4) == 0) {
      double v106 = v108;
    }
    double v93 = v106 / *v110;
    double v74 = v93;
    double v94 = v92;
  }
  else
  {
    if ((v81 & 0x8000000) == 0) {
      goto LABEL_169;
    }
    double v93 = *((double *)&v200 + 1);
    double v92 = *(double *)&v200;
    double v74 = 1.0;
    if (*(double *)&v200 == 1.0)
    {
      double v94 = 1.0;
      if (*((double *)&v200 + 1) == 1.0)
      {
LABEL_169:
        uint64_t v95 = *((void *)a2 + 2);
        double v94 = 1.0;
        if (v95)
        {
          uint64_t v96 = *(void *)(v95 + 96);
          if (v96)
          {
            if (*(unsigned char *)(v96 + 12) == 25) {
              *(unsigned char *)(v96 + 176) = 0;
            }
          }
        }
        double v74 = 1.0;
        goto LABEL_204;
      }
    }
    else
    {
      double v94 = 1.0;
    }
  }
  uint64_t v112 = *((void *)a2 + 2);
  if (v112)
  {
    uint64_t v113 = *(void *)(v112 + 96);
    if (v113)
    {
      if (*(unsigned char *)(v113 + 12) == 25) {
        *(unsigned char *)(v113 + 176) = 1;
      }
    }
  }
  if (((*((unsigned int *)a5 + 56) | ((unint64_t)*((unsigned __int8 *)a5 + 228) << 32)) & 0x2000000000) != 0)
  {
    unsigned int v17 = 17;
    goto LABEL_11;
  }
  LODWORD(v9CA::Context::unref(this[1], 0) = vcvtad_u64_f64(v92 * (double)v90);
  unsigned int v91 = vcvtad_u64_f64(v93 * (double)v91);
LABEL_204:
  if ((v81 & 4) != 0) {
    unsigned int v114 = v90;
  }
  else {
    unsigned int v114 = v91;
  }
  if ((v81 & 4) != 0) {
    LODWORD(v9CA::Context::unref(this[1], 0) = v91;
  }
  if ((~v81 & 0x40000080) != 0) {
    goto LABEL_216;
  }
  long long v115 = (double *)(v23 + 176);
  if ((v81 & 0x40) == 0) {
    long long v115 = v190 + 2;
  }
  unsigned int v116 = *v115;
  long long v117 = (double *)(v23 + 184);
  if ((v81 & 0x40) == 0) {
    long long v117 = v190 + 3;
  }
  unsigned int v118 = *v117;
  if (v90 <= v116 && v114 <= v118)
  {
LABEL_216:
    int v185 = 0;
    int v179 = 1;
  }
  else
  {
    int v179 = 0;
    if (v114 >= v118) {
      unsigned int v114 = v118;
    }
    if (v90 >= v116) {
      LODWORD(v9CA::Context::unref(this[1], 0) = v116;
    }
    int v185 = 1;
  }
  int v180 = *((_DWORD *)a5 + 16);
  if (v201 == 2) {
    uint64_t v119 = (v114 + 1) & 0xFFFFFFFE;
  }
  else {
    uint64_t v119 = v114;
  }
  if (v201 == 2) {
    uint64_t v90 = (v90 + 1) & 0xFFFFFFFE;
  }
  else {
    uint64_t v90 = v90;
  }
  uint64_t v186 = v119;
  uint64_t v188 = v90;
  *(void *)double v209 = 0;
  *(void *)&v209[8] = 0;
  *(double *)&v209[16] = (double)v90;
  *(double *)&v209[24] = (double)v119;
  if (CA::WindowServer::IOMFBDisplay::exceeds_disp_bandwidth_limits_p(this, a5, v81, (float64x2_t *)v209, (const CA::Rect *)v190))goto LABEL_230; {
  if ((v208 & 8) != 0)
  }
    int v120 = 768;
  else {
    int v120 = 256;
  }
  int v121 = v120 | v194;
  _ZF = v201 == 2 && (v208 & 0x12000000) == 0x10000000;
  int v123 = v121 | 0x2000;
  if (!_ZF) {
    int v123 = v121;
  }
  unsigned int v182 = v123;
  if (v23)
  {
    double v178 = (CA::WindowServer::Surface *)*((void *)v23 + 3);
    if (v178)
    {
      if (*((CA::WindowServer::Surface **)v23 + 2) == a5
        && *((_DWORD *)v23 + 11) == v123
        && *((_DWORD *)v178 + 14) == v188
        && *((_DWORD *)v178 + 15) == v186
        && *((double *)v23 + 6) == *(double *)&v200
        && *((double *)v23 + 7) == *((double *)&v200 + 1)
        && *((double *)v23 + 32) == *(double *)buf
        && *((double *)v23 + 33) == *(double *)&buf[8]
        && *((double *)v23 + 34) == *(double *)&buf[16]
        && *((double *)v23 + 35) == *(double *)&buf[24]
        && (v23[292] & 2) == 0)
      {
        uint64_t v183 = v23;
        *((_DWORD *)v178 + 56) = *((_DWORD *)v178 + 56) & 0xFFFF0000 | (unsigned __int16)(*((_DWORD *)v178 + 56) + 1);
        goto LABEL_412;
      }
    }
  }
  if (!(*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *, void, void, uint64_t, uint64_t))(*(void *)this + 144))(this, *((unsigned int *)a5 + 14), *((unsigned int *)a5 + 15), v188, v186))
  {
    unsigned int v17 = 4;
    goto LABEL_11;
  }
  uint64_t v183 = v23;
  if (v201 == 2)
  {
    if (v190)
    {
      if (v188 == v190[2] && v186 == v190[3])
      {
        int v124 = *((_DWORD *)this + 6800);
        if (v124 == 1)
        {
          if (v180 == 875704438)
          {
            int v148 = 875704950;
          }
          else
          {
            if (v180 != 875704422) {
              goto LABEL_336;
            }
            int v148 = 875704934;
          }
          goto LABEL_335;
        }
        if (v124 == 2)
        {
          if (v180 > 875704933)
          {
            if (v180 == 875704950)
            {
LABEL_333:
              int v148 = 875836534;
              goto LABEL_335;
            }
            if (v180 != 875704934) {
              goto LABEL_336;
            }
          }
          else if (v180 != 875704422)
          {
            if (v180 != 875704438) {
              goto LABEL_336;
            }
            goto LABEL_333;
          }
          int v148 = 875836518;
LABEL_335:
          int v180 = v148;
          goto LABEL_336;
        }
        if (*((unsigned char *)this + 28157))
        {
          if (CADeviceUseCompression::once[0] != -1) {
            dispatch_once(CADeviceUseCompression::once, &__block_literal_global_21);
          }
          if (!CADeviceUseCompression::enable_compression)
          {
            if (v180 > 2016686639)
            {
              if (v180 > 2019963439)
              {
                if (v180 == 2019963440 || v180 == 2019963956) {
                  goto LABEL_432;
                }
                int v151 = 2019963442;
              }
              else
              {
                if (v180 == 2016686640 || v180 == 2016686642) {
                  goto LABEL_432;
                }
                int v151 = 2016687156;
              }
            }
            else
            {
              if (v180 <= 1953903151)
              {
                if (v180 != 1952854576 && v180 != 1952854578)
                {
                  int v151 = 1952855092;
                  goto LABEL_431;
                }
LABEL_432:
                int v180 = CA::Render::fourcc_packed_from_unpacked((CA::Render *)v180);
                goto LABEL_336;
              }
              if (v180 == 1953903152 || v180 == 1953903154) {
                goto LABEL_432;
              }
              int v151 = 1953903668;
            }
LABEL_431:
            if (v180 != v151) {
              goto LABEL_336;
            }
            goto LABEL_432;
          }
        }
      }
    }
    else if (v23)
    {
      uint64_t v147 = *((void *)v23 + 3);
      if (v147)
      {
        if (*(_DWORD *)(*((void *)v23 + 2) + 64) == v180)
        {
          int v148 = *(_DWORD *)(v147 + 64);
          goto LABEL_335;
        }
      }
    }
  }
LABEL_336:
  int v152 = (*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)a5 + 56))(a5);
  if ((v208 & 0x800000) != 0)
  {
    if ((*((_DWORD *)this + 156) & 8) != 0) {
      uint64_t v155 = 1999843442;
    }
    else {
      uint64_t v155 = 1111970369;
    }
    int v153 = 2;
    double v154 = (char *)this + 25704;
  }
  else
  {
    int v153 = v152;
    double v154 = (char *)this + 25704;
    uint64_t v155 = v180;
    if ((v208 & 0x1000000) != 0)
    {
      if (v201 == 2)
      {
        if ((*((_DWORD *)this + 156) & 8) != 0) {
          uint64_t v155 = 1885745712;
        }
        else {
          uint64_t v155 = 875704422;
        }
      }
      else
      {
        uint64_t v155 = 1111970369;
      }
      int v153 = 4;
    }
  }
  if (!v154[2453]) {
    goto LABEL_352;
  }
  if (CADeviceUseCompression::once[0] != -1)
  {
    unsigned int v181 = v155;
    int v177 = v153;
    dispatch_once(CADeviceUseCompression::once, &__block_literal_global_21);
    int v153 = v177;
    uint64_t v155 = v181;
  }
  if (CADeviceUseCompression::enable_compression)
  {
LABEL_352:
    if ((int)v155 > 1885746227)
    {
      if (((v155 - 1886676528) > 4 || ((1 << (v155 - 48)) & 0x15) == 0)
        && ((v155 - 1886680624) > 4 || ((1 << (v155 - 48)) & 0x15) == 0))
      {
        unsigned __int16 v156 = 13364;
        goto LABEL_361;
      }
    }
    else if ((int)v155 <= 1882469427)
    {
      if (v155 != 1882468912)
      {
        int v157 = 1882468914;
LABEL_366:
        if (v155 != v157) {
          goto LABEL_368;
        }
      }
    }
    else if (v155 != 1882469428 && v155 != 1885745712)
    {
      unsigned __int16 v156 = 12850;
LABEL_361:
      int v157 = v156 | 0x70660000;
      goto LABEL_366;
    }
    int v158 = v153;
    LODWORD(v155) = CA::Render::fourcc_unpacked_from_packed((CA::Render *)v155);
    int v153 = v158;
  }
LABEL_368:
  if ((v208 & 0x4000000) != 0)
  {
    int v201 = 0;
    int v153 = 2;
    LODWORD(v155) = 1999843442;
  }
  if (((v155 == 1999843442) & (v208 >> 25)) != 0) {
    uint64_t v159 = 2019964016;
  }
  else {
    uint64_t v159 = v155;
  }
  if (((v155 == 1999843442) & (v208 >> 25)) != 0) {
    unsigned int v160 = 4;
  }
  else {
    unsigned int v160 = v153;
  }
  if ((v208 & 0x20000000) != 0) {
    uint64_t v159 = CA::Render::fourcc_422_from_420((CA::Render *)v159);
  }
  if (CA::Render::fourcc_is_420((CA::Render *)v159)
    && (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *, uint64_t))(*(void *)this + 2200))(this, v188))
  {
    uint64_t v159 = CA::Render::fourcc_422_from_420((CA::Render *)v159);
  }
  if ((v208 & 0x80000000) != 0) {
    uint64_t v161 = CA::Render::fourcc_compressed_of_type((CA::Render *)v159, 0, 0);
  }
  else {
    uint64_t v161 = (*(uint64_t (**)(CA::WindowServer::IOMFBDisplay *, uint64_t, uint64_t))(*(void *)this + 2320))(this, v159, v188);
  }
  double v162 = (CA::Render *)v161;
  if ((v161 == 1380411457 || v161 == 642934849) && CA::WindowServer::Display::edr_headroom(this) > 1.0)
  {
    CA::ScalerUtil::ScalerLimits::limits(v163);
    if (!HIBYTE(dword_1E8F852AC))
    {
      unsigned int v17 = 12;
      goto LABEL_11;
    }
  }
  if (a4 && (*((unsigned char *)a4 + 15) & 8) != 0)
  {
    unsigned int v17 = 13;
    goto LABEL_11;
  }
  uint64_t v164 = (*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)a5 + 24))(a5);
  uint64_t v165 = (*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)a5 + 216))(a5);
  uint64_t surface = CA::WindowServer::Display::allocate_surface((uint64_t)this, v188, v186, v162, v164, v160, 0, v165, @"CA MSR Intermediate", 0);
  if (!surface)
  {
    unsigned int v17 = 5;
    goto LABEL_11;
  }
  int32x2_t v167 = (CA::WindowServer::Surface *)surface;
  unsigned int v182 = v182 & 0xFFFFBFFF | (((*((unsigned __int8 *)a5 + 228) >> 5) & 1) << 14);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 25720));
  double v169 = (unsigned int *)((char *)this + 48 * *((unsigned int *)this + 6426) + 25808);
  if (!*v169) {
    CA::IOMobileFramebuffer::swap_begin((CA::WindowServer::IOMFBDisplay *)((char *)this + 25568), v169);
  }
  if ((v208 & 0x10000000) != 0
    && (uint64_t v170 = *((void *)a2 + 2)) != 0
    && (uint64_t v171 = *(void *)(v170 + 96)) != 0
    && *(unsigned char *)(v171 + 12) == 25)
  {
    CA::Render::ImageQueue::retain_scaler_stats((CA::Render::ImageQueue *)&v199, v171);
    double v172 = (atomic_uint *)v199;
    if (v199) {
      *((unsigned char *)v199 + 12) = *((unsigned char *)a5 + 229);
    }
  }
  else
  {
    double v172 = 0;
  }
  if (v179) {
    double v173 = 0;
  }
  else {
    double v173 = buf;
  }
  char v174 = CA::WindowServer::IOMFBDisplay::copy_surface(this, v167, a5, v182, 0, 0, (CA::Rect *)v173, (CA::ScalerStatistics *)v172, v168);
  double v178 = v167;
  if (v174)
  {
    unsigned int v17 = 12;
  }
  else
  {
    CA::WindowServer::Surface::unref(v167);
    unsigned int v17 = 6;
  }
  if (v172 && atomic_fetch_add(v172 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v172 + 8))(v172);
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 25720));
  if (v174)
  {
LABEL_412:
    int v191 = 0;
    double v23 = v183;
    float64x2_t v25 = (float64x2_t *)v190;
    if (!v183) {
LABEL_267:
    }
      double v23 = (char *)x_mem_alloc0(0x128uLL);
LABEL_268:
    if (!*(void *)v23)
    {
      uint64_t v125 = a2;
      if (!atomic_fetch_add((atomic_uint *volatile)a2 + 2, 1u))
      {
        uint64_t v125 = 0;
        atomic_fetch_add((atomic_uint *volatile)a2 + 2, 0xFFFFFFFF);
      }
      *(void *)double v23 = v125;
    }
    float64x2x2_t v126 = (CA::WindowServer::Surface *)*((void *)v23 + 2);
    if (v126) {
      CA::WindowServer::Surface::unref(v126);
    }
    *((_DWORD *)a5 + 56) = *((_DWORD *)a5 + 56) & 0xFFFF0000 | (unsigned __int16)(*((_DWORD *)a5 + 56) + 1);
    *((void *)v23 + 2) = a5;
    float64x2x2_t v127 = (CA::WindowServer::Surface *)*((void *)v23 + 3);
    if (v127) {
      CA::WindowServer::Surface::unref(v127);
    }
    *((void *)v23 + 3) = v178;
    *((_DWORD *)v23 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v182;
    *((_OWORD *)v23 + 3) = v200;
    LODWORD(v4CA::Context::unref(this[1], 0) = v208;
    char v184 = v23;
    v23[292] = (v208 >> 3) & 4 | v23[292] & 0xF8;
    uint64_t v41 = (char *)this + 25704;
    *((unsigned char *)this + 26425) = v201;
    BOOL v128 = v185 != 0;
    if ((v40 & 0x40) != 0)
    {
LABEL_300:
      *((_DWORD *)v184 + 9) = v40 & 0xFFFFFFBF;
      *((_DWORD *)v184 + 1CA::Context::unref(this[1], 0) = v191;
      double v144 = (atomic_uint *)*((void *)v184 + 1);
      if (v144 != (atomic_uint *)a4)
      {
        if (v144 && atomic_fetch_add(v144 + 2, 0xFFFFFFFF) == 1)
        {
          int32x2_t v145 = v41;
          (*(void (**)(atomic_uint *))(*(void *)v144 + 16))(v144);
          uint64_t v41 = v145;
        }
        if (a4)
        {
          double v146 = a4;
          if (!atomic_fetch_add((atomic_uint *volatile)a4 + 2, 1u))
          {
            double v146 = 0;
            atomic_fetch_add((atomic_uint *volatile)a4 + 2, 0xFFFFFFFF);
          }
        }
        else
        {
          double v146 = 0;
        }
        *((void *)v184 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v146;
      }
      *((void *)this + 3255) = v184;
      v41[720] = 1;
      if (a9)
      {
        unsigned int v17 = 0;
        *a9 = *((_DWORD *)v184 + 11);
        goto LABEL_11;
      }
      goto LABEL_311;
    }
LABEL_277:
    *((float64x2_t *)v184 + 8) = *v196;
    *((float64x2_t *)v184 + 9) = v196[1];
    *((float64x2_t *)v184 + 1CA::Context::unref(this[1], 0) = *v25;
    *((float64x2_t *)v184 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v25[1];
    double v129 = v196->f64[0];
    *((void *)v184 + 24) = *(void *)&v196->f64[0];
    double v130 = (float64x2_t *)(v184 + 192);
    double v131 = v196->f64[1];
    *((double *)v184 + 25) = v131;
    double v132 = v196[1].f64[0];
    *((double *)v184 + 26) = v132;
    double v133 = v196[1].f64[1];
    *((double *)v184 + 27) = v133;
    *((float64x2_t *)v184 + 14) = *v25;
    *((float64x2_t *)v184 + 15) = v25[1];
    *((float64x2_t *)v184 + 4) = *a6;
    *((float64x2_t *)v184 + 5) = a6[1];
    *((float64x2_t *)v184 + 6) = *a7;
    *((float64x2_t *)v184 + 7) = a7[1];
    HIDWORD(v134) = *(_DWORD *)&buf[4];
    long long v135 = *(_OWORD *)&buf[16];
    *((_OWORD *)v184 + 16) = *(_OWORD *)buf;
    *((_OWORD *)v184 + 17) = v135;
    *((_DWORD *)v184 + 8) = v15;
    if (*((CA::WindowServer::Surface **)v184 + 3) == a5)
    {
LABEL_297:
      CA::Rect::round_center(v130);
      CA::Rect::round_center((float64x2_t *)v184 + 14);
      if (v128)
      {
        *((void *)v184 + 24) = 0;
        *((void *)v184 + 25) = 0;
        uint64_t v142 = *(void *)(*((void *)v184 + 3) + 56);
        v143.i64[0] = v142;
        v143.i64[1] = HIDWORD(v142);
        *((float64x2_t *)v184 + 13) = vcvtq_f64_u64(v143);
      }
      uint64_t v41 = (char *)this + 25704;
      *((unsigned char *)this + 28137) = 1;
      LODWORD(v4CA::Context::unref(this[1], 0) = v208;
      goto LABEL_300;
    }
    LODWORD(v134) = *((_DWORD *)a5 + 14);
    LODWORD(v135) = *((_DWORD *)a5 + 15);
    double v136 = (double)v134;
    *(double *)&long long v135 = (double)(unint64_t)v135;
    if ((v40 & 0x8000000) != 0)
    {
      int32x4_t v137 = (double *)v184;
      double v94 = *((double *)v184 + 6);
      double v74 = *((double *)v184 + 7);
      double v129 = v94 * v129;
    }
    else
    {
      if (v94 == 1.0 && v74 == 1.0)
      {
LABEL_290:
        if ((v40 & 4) != 0)
        {
          double v140 = v131 + v133;
          double v131 = v129;
          double v141 = *(double *)&v135 - v140;
          *((double *)v184 + 24) = *(double *)&v135 - v140;
          *((double *)v184 + 25) = v129;
          *((double *)v184 + 26) = v133;
          *((double *)v184 + 27) = v132;
          double v138 = v132;
          double v129 = v141;
          double v139 = *(double *)&v135;
        }
        else
        {
          double v138 = v133;
          double v133 = v132;
          double v139 = v136;
          double v136 = *(double *)&v135;
        }
        if ((v40 & 2) != 0) {
          v130->f64[0] = v139 - (v129 + v133);
        }
        if (v40) {
          *((double *)v184 + 25) = v136 - (v131 + v138);
        }
        goto LABEL_297;
      }
      double v129 = v129 * v94;
      int32x4_t v137 = (double *)v184;
    }
    double v131 = v131 * v74;
    v137[24] = v129;
    v137[25] = v131;
    double v132 = v132 * v94;
    *(double *)&long long v135 = v74 * *(double *)&v135;
    double v136 = v94 * v136;
    double v133 = v133 * v74;
    v137[26] = v132;
    v137[27] = v133;
    goto LABEL_290;
  }
LABEL_11:
  if (a5 && (uint64_t v18 = (*(uint64_t (**)(CA::WindowServer::Surface *))(*(void *)a5 + 160))(a5)) != 0)
  {
    float64x2_t v19 = (__IOSurface *)v18;
    IOSurfaceSetDetachModeCode();
    if (!byte_1EB2ACBEE) {
      goto LABEL_16;
    }
    IOSurfaceID v20 = IOSurfaceGetID(v19);
  }
  else
  {
    if (!byte_1EB2ACBEE) {
      goto LABEL_16;
    }
    IOSurfaceID v20 = 0;
  }
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    double v149 = x_log_category_CADebug;
    if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO))
    {
      double v150 = CA::detach_string_server(CA::ServerDetachReasonCode)::names[v17];
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v20;
      *(_WORD *)&uint8_t buf[8] = 2080;
      *(void *)&buf[10] = v150;
      _os_log_impl(&dword_184668000, v149, OS_LOG_TYPE_INFO, "[Server] Surface ID:0x%x detach result: %s", buf, 0x12u);
    }
  }
LABEL_16:
  if (v17 >= 3) {
    CA::WindowServer::IOMFBDisplay::delete_detached_layer(this);
  }
  if (a2 && !a7 && !a5 && !a4 && !a6)
  {
    if (a3) {
      int v21 = 0;
    }
    else {
      int v21 = v198;
    }
    if (*((void *)a2 + 5)
      && v21
      && (*(unsigned int (**)(CA::WindowServer::IOMFBDisplay *))(*(void *)this + 552))(this))
    {
      *((void *)a2 + 12) |= 8uLL;
    }
  }
  return v17 == 0;
}

void CA::WindowServer::Surface::unref(CA::WindowServer::Surface *this)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int v1 = *((_DWORD *)this + 56);
  *((_DWORD *)this + 56) = v1 & 0xFFFF0000 | (unsigned __int16)(v1 - 1);
  if ((_WORD)v1 == 1)
  {
    double v3 = (void (*)(CA::WindowServer::Surface *, void))*((void *)this + 10);
    if (v3)
    {
      v3(this, *((void *)this + 9));
      *((void *)this + 1CA::Context::unref(this[1], 0) = 0;
    }
    uint64_t v4 = *((void *)this + 1);
    if (v4
      && (uint64_t v5 = *((unsigned int *)this + 56),
          unint64_t v6 = v5 | ((unint64_t)*((unsigned __int8 *)this + 228) << 32),
          (v5 & 0x6000000) != 0))
    {
      *((unsigned char *)this + 228) = BYTE4(v6);
      *((_DWORD *)this + 56) = v6 & 0xFF000000 | 0x50001;
      *(_OWORD *)((char *)this + 24) = 0u;
      *(_OWORD *)((char *)this + 4CA::Context::unref(this[1], 0) = 0u;
      os_unfair_lock_lock((os_unfair_lock_t)(v4 + 224));
      float64x2_t v8 = *(CA::WindowServer::Surface ***)(v4 + 232);
      uint64_t v7 = *(CA::WindowServer::Surface ***)(v4 + 240);
      if (v8 != v7)
      {
        while (*v8 != this)
        {
          if (++v8 == v7)
          {
            float64x2_t v8 = *(CA::WindowServer::Surface ***)(v4 + 240);
            break;
          }
        }
      }
      if (v8 == v7)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          float64x2_t v25 = x_log_category_windowserver;
          if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
          {
            __int16 v26 = 0;
            _os_log_impl(&dword_184668000, v25, OS_LOG_TYPE_ERROR, "Failed to find Surface in _inuse_surfaces", (uint8_t *)&v26, 2u);
          }
        }
      }
      else
      {
        int64_t v9 = (char *)v7 - (char *)(v8 + 1);
        if (v7 != v8 + 1) {
          memmove(v8, v8 + 1, (char *)v7 - (char *)(v8 + 1));
        }
        *(void *)(v4 + 24CA::Context::unref(this[1], 0) = (char *)v8 + v9;
      }
      float64x2_t v11 = *(void **)(v4 + 264);
      unint64_t v10 = *(void *)(v4 + 272);
      if ((unint64_t)v11 >= v10)
      {
        uint64_t v14 = *(void *)(v4 + 256);
        uint64_t v15 = ((uint64_t)v11 - v14) >> 3;
        if ((unint64_t)(v15 + 1) >> 61) {
          abort();
        }
        uint64_t v16 = v10 - v14;
        uint64_t v17 = v16 >> 2;
        if (v16 >> 2 <= (unint64_t)(v15 + 1)) {
          uint64_t v17 = v15 + 1;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v18 = v17;
        }
        if (v18) {
          unint64_t v18 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v18);
        }
        else {
          uint64_t v19 = 0;
        }
        IOSurfaceID v20 = (void *)(v18 + 8 * v15);
        unint64_t v21 = v18 + 8 * v19;
        *IOSurfaceID v20 = this;
        float64x2_t v12 = v20 + 1;
        double v23 = *(char **)(v4 + 256);
        float64x2_t v22 = *(char **)(v4 + 264);
        if (v22 != v23)
        {
          do
          {
            uint64_t v24 = *((void *)v22 - 1);
            v22 -= 8;
            *--IOSurfaceID v20 = v24;
          }
          while (v22 != v23);
          float64x2_t v22 = *(char **)(v4 + 256);
        }
        *(void *)(v4 + 256) = v20;
        *(void *)(v4 + 264) = v12;
        *(void *)(v4 + 272) = v21;
        if (v22) {
          operator delete(v22);
        }
      }
      else
      {
        *float64x2_t v11 = this;
        float64x2_t v12 = v11 + 1;
      }
      *(void *)(v4 + 264) = v12;
      os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 224));
    }
    else
    {
      float64x2_t v13 = *(void (**)(CA::WindowServer::Surface *))(*(void *)this + 8);
      v13(this);
    }
  }
}

void CA::WindowServer::IOMFBDisplay::delete_detached_layer(CA::WindowServer::IOMFBDisplay *this)
{
  int v1 = (void *)*((void *)this + 3255);
  if (v1)
  {
    CA::WindowServer::IOMFBDisplay::release_detached_handle(*((void *)this + 3255));
    double v3 = (atomic_uint *)v1[1];
    if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
    }
    uint64_t v4 = (CA::WindowServer::Surface *)v1[2];
    if (v4) {
      CA::WindowServer::Surface::unref(v4);
    }
    uint64_t v5 = (CA::WindowServer::Surface *)v1[3];
    if (v5) {
      CA::WindowServer::Surface::unref(v5);
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v1);
    *((void *)this + 3255) = 0;
    *((unsigned char *)this + 28137) = 1;
    *((unsigned char *)this + 26424) = *((unsigned char *)this + 26426);
  }
}

float64x2_t CA::Rect::round_center(float64x2_t *this)
{
  float64x2_t result = this[1];
  double v2 = this[1].f64[1];
  if (result.f64[0] <= v2) {
    double v3 = this[1].f64[1];
  }
  else {
    double v3 = this[1].f64[0];
  }
  if (v3 < 1.79769313e308)
  {
    if (result.f64[0] < v2) {
      double v2 = this[1].f64[0];
    }
    if (v2 > 0.0)
    {
      float64x2_t v4 = vrndaq_f64(*this);
      float64x2_t result = vsubq_f64(vrndaq_f64(vaddq_f64(*this, result)), v4);
      *this = v4;
      this[1] = result;
    }
  }
  return result;
}

BOOL CA::WindowServer::AppleInternalDisplay::display_supports_rotation_p(CA::WindowServer::AppleInternalDisplay *this, int a2, CA::WindowServer::Surface *a3)
{
  if (a3 && (a2 & 4) != 0)
  {
    if ((*((_WORD *)this + 14272) & 0x800) != 0)
    {
      uint64_t v10 = *((void *)this + 3550);
      int v12 = *((_DWORD *)a3 + 14);
      unint64_t v11 = *((unsigned int *)a3 + 15);
      if ((*(uint64_t (**)(CA::WindowServer::AppleInternalDisplay *))(*(void *)this + 64))(this) < v11) {
        return 0;
      }
      float64x2_t v13 = (CA::Render *)*((unsigned int *)a3 + 16);
      int v14 = CA::Render::fourcc_compressed_of_type(v13, 0, 0);
      BOOL result = 0;
      if (v14 == v13) {
        return result;
      }
      if (v10 - 1 < (unint64_t)((((v11 + 31) & 0xFFFFFFE0) * ((v12 + 31) & 0xFFFFFFE0)) & 0xFFFFFC00)) {
        return 0;
      }
      return byte_1EB2ACC80 == 0;
    }
    else
    {
      unint64_t v6 = *((void *)this + 3543);
      if (!v6) {
        return (a2 & 4) == 0 || *((unsigned char *)this + 28151) != 0;
      }
      unsigned int v7 = *((_DWORD *)a3 + 16);
      if (CA::Render::fourcc_compressed_of_type((CA::Render *)v7, 0, 0) == v7) {
        return (a2 & 4) == 0 || *((unsigned char *)this + 28151) != 0;
      }
      if (CADeviceSupportsUniversalCompression::once != -1) {
        dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
      }
      if (CADeviceSupportsUniversalCompression::universal) {
        return (a2 & 4) == 0 || *((unsigned char *)this + 28151) != 0;
      }
      BOOL result = 0;
      HIDWORD(v17) = a2;
      LODWORD(v17) = a2 - 2;
      unsigned int v16 = v17 >> 1;
      if (v16 > 6 || ((1 << v16) & 0x4E) == 0) {
        return result;
      }
      return v6 >= *((unsigned int *)a3 + 15) && byte_1EB2ACC80 == 0;
    }
  }
  return (a2 & 4) == 0 || *((unsigned char *)this + 28151) != 0;
}

uint64_t CA::WindowServer::IOMFBDisplay::exceeds_disp_bandwidth_limits_p(CA::WindowServer::IOMFBDisplay *this, CA::WindowServer::Surface *a2, uint64_t a3, float64x2_t *a4, const CA::Rect *a5)
{
  if (!byte_1EB2ACC86 && *((unsigned char *)this + 27024))
  {
    if (CA::WindowServer::IOMFBDisplay::detach_exceeds_display_bandwidth_limits_p(this, a2, a4, a5, a5)) {
      return 1;
    }
    unint64_t v11 = (void *)*((void *)this + 5);
    if (v11)
    {
      while (!(*(unsigned int (**)(void))(**(void **)(*v11 + 96) + 696))(*(void *)(*v11 + 96))
           || ((*(uint64_t (**)(void, CA::WindowServer::IOMFBDisplay *, CA::WindowServer::Surface *, uint64_t, float64x2_t *, const CA::Rect *))(**(void **)(*v11 + 96) + 712))(*(void *)(*v11 + 96), this, a2, a3, a4, a5) & 1) == 0)
      {
        unint64_t v11 = (void *)v11[1];
        if (!v11) {
          return 0;
        }
      }
      return 1;
    }
  }
  return 0;
}

void sub_1847AC170(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::WindowServer::IOSurface::set_colorspace(CA::WindowServer::IOSurface *this, void *cf, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (cf)
  {
    if (*((void **)this + 35) != cf || a3 != 0)
    {
      X::CFRef<__CFDictionary const*>::operator=((const void **)this + 35, cf);
      uint64_t v7 = *((void *)this + 1);
      if ((void *)CAGetColorSpace(5u) == cf
        || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
        || (void *)CAGetColorSpace(6u) == cf
        || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
        || (void *)CAGetColorSpace(7u) == cf
        || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
        || (void *)CAGetColorSpace(0xFu) == cf
        || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
        || (void *)CAGetColorSpace(0x10u) == cf
        || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0)
      {
        uint64_t v8 = 4;
      }
      else if ((void *)CAGetColorSpace(9u) == cf {
             || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
      }
             || (void *)CAGetColorSpace(0xAu) == cf
             || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
             || (void *)CAGetColorSpace(0xBu) == cf
             || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
             || (void *)CAGetColorSpace(0xDu) == cf
             || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
             || (void *)CAGetColorSpace(0xCu) == cf
             || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
             || (void *)CAGetColorSpace(0xEu) == cf
             || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0)
      {
        uint64_t v8 = 8;
      }
      else if ((void *)CAGetColorSpace(0x1Du) == cf {
             || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
      }
             || (void *)CAGetColorSpace(0x11u) == cf
             || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
             || (void *)CAGetColorSpace(0x12u) == cf
             || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
             || (void *)CAGetColorSpace(0x1Au) == cf
             || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
             || (void *)CAGetColorSpace(0x1Bu) == cf
             || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0)
      {
        uint64_t v8 = 2;
      }
      else if (v7 && ((*(uint64_t (**)(uint64_t))(*(void *)v7 + 1840))(v7) & 1) != 0)
      {
        uint64_t v8 = 16;
      }
      else
      {
        uint64_t v8 = 1;
      }
      (*(void (**)(CA::WindowServer::IOSurface *, uint64_t, uint64_t))(*(void *)this + 72))(this, v8, a3);
      if ((void *)CAGetColorSpace(0xFu) == cf
        || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
        || (void *)CAGetColorSpace(0x10u) == cf
        || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
        || (void *)CAGetColorSpace(0x1Au) == cf
        || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
        || (void *)CAGetColorSpace(0x1Bu) == cf
        || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
        || (void *)CAGetColorSpace(0xAu) == cf
        || (CGColorSpaceEqualToColorSpaceIgnoringRange() & 1) != 0
        || (void *)CAGetColorSpace(0xBu) == cf)
      {
        uint64_t v9 = 1;
      }
      else
      {
        uint64_t v9 = CGColorSpaceEqualToColorSpaceIgnoringRange();
      }
      (*(void (**)(CA::WindowServer::IOSurface *, uint64_t))(*(void *)this + 80))(this, v9);
      if (CADeviceIsVirtualized::once != -1) {
        dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
      }
      if (CADeviceIsVirtualized::is_virtualized)
      {
        CFDataRef v10 = CGColorSpaceCopyICCData((CGColorSpaceRef)cf);
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          unint64_t v11 = x_log_category_utilities;
          if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 67109120;
            int v14 = 2;
            _os_log_impl(&dword_184668000, v11, OS_LOG_TYPE_DEBUG, "primaries of value %d received, no matching case", buf, 8u);
          }
        }
        if (v10) {
          CFRelease(v10);
        }
        CFDataRef v12 = CGColorSpaceCopyICCData((CGColorSpaceRef)cf);
        IOSurfaceSetValue(*((IOSurfaceRef *)this + 30), (CFStringRef)*MEMORY[0x1E4F2F0F0], v12);
        if (v12)
        {
          CFRelease(v12);
        }
      }
    }
  }
}

void sub_1847ACDD8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

const void **X::CFRef<__CFDictionary const*>::operator=(const void **a1, CFTypeRef cf)
{
  CFTypeRef v3 = *a1;
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *a1 = cf;
    if (cf) {
      CFRetain(cf);
    }
  }
  return a1;
}

CA::Render::InterpolatedFunction *CA::Render::InterpolatedFunction::InterpolatedFunction(CA::Render::InterpolatedFunction *this, unint64_t a2, int a3, int a4)
{
  *((_DWORD *)this + 2) = 1;
  ++dword_1EB2ADE10;
  *(void *)this = &unk_1ED02EC98;
  *((void *)this + 2) = a2;
  *((_DWORD *)this + 6) = a3;
  *((float *)this + 7) = (float)a2 + -1.0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 3) = (a4 << 8) | 0x12;
  CA::Render::InterpolatedFunction::allocate_storage(this);
  return this;
}

char *CA::Render::GradientLayer::copy@<X0>(CA::Render::GradientLayer *this@<X0>, void *a2@<X8>)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  BOOL result = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x90uLL, 0x743898A5uLL);
  unint64_t v6 = (unsigned int *)result;
  if (result)
  {
    *((_DWORD *)result + 2) = 1;
    *((_DWORD *)result + 3) = 20;
    ++dword_1EB2ADE18;
    *(void *)BOOL result = &unk_1ED02D9A0;
    *((_DWORD *)result + 6) = 1;
    *((_DWORD *)result + 7) = 18;
    ++dword_1EB2ADE10;
    *((void *)result + 2) = &unk_1ED02EC98;
    *((void *)result + 4) = *((void *)this + 4);
    *((_DWORD *)result + 1CA::Context::unref(this[1], 0) = *((_DWORD *)this + 10);
    *((_DWORD *)result + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *((_DWORD *)this + 11);
    *((void *)result + 7) = 0;
    *((void *)result + 8) = 0;
    *((void *)result + 6) = 0;
    *((_DWORD *)result + 7) = *((_DWORD *)this + 7) & 0xFFFFFF00 | 0x12;
    CA::Render::InterpolatedFunction::allocate_storage((CA::Render::InterpolatedFunction *)(result + 16));
    uint64_t v7 = (void *)*((void *)v6 + 6);
    if (v7)
    {
      memcpy(v7, *((const void **)this + 6), 4 * *((void *)v6 + 4) * v6[10]);
      uint64_t v8 = (void *)*((void *)v6 + 7);
      if (v8)
      {
        uint64_t v9 = (const void *)*((void *)this + 7);
        if (v9) {
          memcpy(v8, v9, 4 * *((void *)v6 + 4));
        }
      }
    }
    CFDataRef v10 = (void *)*((void *)v6 + 8);
    if (v10)
    {
      unint64_t v11 = (const void *)*((void *)this + 8);
      if (v11)
      {
        uint64_t v12 = *((void *)v6 + 4);
        if (v12) {
          memcpy(v10, v11, 32 * v12 - 32);
        }
      }
    }
    *((void *)v6 + 2) = &unk_1ED02FF20;
    *(_OWORD *)(v6 + 18) = *(_OWORD *)((char *)this + 72);
    *(_OWORD *)(v6 + 22) = *(_OWORD *)((char *)this + 88);
    v6[26] = *((_DWORD *)this + 26);
    v6[27] = *((_DWORD *)this + 27);
    uint64_t v13 = *((void *)this + 14);
    if (v13)
    {
      int v14 = (atomic_uint *)(v13 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v13 + 8), 1u))
      {
        uint64_t v13 = 0;
        atomic_fetch_add(v14, 0xFFFFFFFF);
      }
    }
    *((void *)v6 + 14) = v13;
    uint64_t v15 = *((void *)this + 15);
    if (v15)
    {
      unsigned int v16 = (atomic_uint *)(v15 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v15 + 8), 1u))
      {
        uint64_t v15 = 0;
        atomic_fetch_add(v16, 0xFFFFFFFF);
      }
    }
    unint64_t v17 = (const void *)*((void *)this + 16);
    *((void *)v6 + 15) = v15;
    *((void *)v6 + 16) = v17;
    if (v17) {
      CFRetain(v17);
    }
    BOOL result = (char *)*((void *)this + 17);
    *((void *)v6 + 17) = result;
    if (result) {
      BOOL result = (char *)CFRetain(result);
    }
  }
  *a2 = v6;
  return result;
}

void CA::Render::InterpolatedFunction::allocate_storage(CA::Render::InterpolatedFunction *this)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  unint64_t v1 = *((void *)this + 2);
  if (!v1) {
    return;
  }
  if (*((void *)this + 4)) {
    goto LABEL_3;
  }
  if (!is_mul_ok(v1, *((unsigned int *)this + 6))) {
    return;
  }
  unint64_t v5 = v1 * *((unsigned int *)this + 6);
  int v6 = *((_DWORD *)this + 3);
  if ((v6 & 0x200) == 0) {
    unint64_t v1 = 0;
  }
  BOOL v7 = __CFADD__(v5, v1);
  unint64_t v8 = v5 + v1;
  if (v7 || v8 >> 62) {
    return;
  }
  uint64_t v9 = 4 * v8;
  if (4 * v8 <= 0x20000)
  {
    CFDataRef v10 = (char *)malloc_type_malloc(4 * v8, 0x2DDEEEAEuLL);
    *((void *)this + 4) = v10;
    if ((v6 & 0x200) != 0 && v10) {
      *((void *)this + 5) = &v10[4 * v5];
    }
LABEL_3:
    if (!*((void *)this + 6) && (*((unsigned char *)this + 13) & 4) != 0)
    {
      unint64_t v3 = *((void *)this + 2) - 1;
      if (!(v3 >> 59))
      {
        uint64_t v4 = 32 * v3;
        if (32 * v3 <= 0x10000)
        {
          *((void *)this + 6) = malloc_type_malloc(32 * v3, 0xC5A17290uLL);
          return;
        }
        if (x_log_hook_p()) {
          goto LABEL_16;
        }
        unint64_t v11 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          uint64_t v12 = *((void *)this + 2);
          *(_DWORD *)long long buf = 134218240;
          uint64_t v16 = v4;
          __int16 v17 = 2048;
          uint64_t v18 = v12;
          uint64_t v13 = "suspiciously large interpolations: %zu count: %zu";
LABEL_25:
          _os_log_impl(&dword_184668000, v11, OS_LOG_TYPE_ERROR, v13, buf, 0x16u);
          return;
        }
      }
    }
    return;
  }
  if (x_log_hook_p())
  {
LABEL_16:
    x_log_();
    return;
  }
  unint64_t v11 = x_log_category_render;
  if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
  {
    uint64_t v14 = *((void *)this + 2);
    *(_DWORD *)long long buf = 134218240;
    uint64_t v16 = v9;
    __int16 v17 = 2048;
    uint64_t v18 = v14;
    uint64_t v13 = "suspiciously large function size: %zu count: %zu";
    goto LABEL_25;
  }
}

uint64_t CA::WindowServer::IOSurface::set_color_primaries(uint64_t result, int a2, int a3)
{
  if (*(_DWORD *)(result + 272) != a2 || a3 != 0)
  {
    *(_DWORD *)(result + 272) = a2;
    IOSurfaceRemoveValue(*(IOSurfaceRef *)(result + 240), (CFStringRef)*MEMORY[0x1E4F2F048]);
    return IOSurfaceSetBulkAttachments2();
  }
  return result;
}

uint64_t CA::WindowServer::IOSurface::set_linear(uint64_t this, char a2)
{
  *(unsigned char *)(this + 288) = a2;
  return this;
}

uint64_t CA::Render::Context::context_by_client_port(CA::Render::Context *this)
{
  uint64_t v1 = 0;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (this && CA::Render::Context::_context_table)
  {
    uint64_t v10 = 0;
    uint64_t v9 = this;
    os_unfair_lock_lock(&CA::Render::Context::_context_lock);
    uint64_t v3 = 0;
    uint64_t v4 = CA::Render::Context::_context_table;
    uint64_t v5 = 1 << *(_DWORD *)CA::Render::Context::_context_table;
    do
    {
      for (uint64_t i = *(uint64_t ***)(*(void *)(v4 + 16) + 8 * v3); i; uint64_t i = (uint64_t **)*i)
        CA::Render::find_port((CA::Render *)i[2], (uint64_t)i[3], (CA::Render::Context *)&v9, v2);
      ++v3;
    }
    while (v3 != v5);
    uint64_t v1 = v10;
    if (v10)
    {
      BOOL v7 = (atomic_uint *)(v10 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v10 + 8), 1u))
      {
        uint64_t v1 = 0;
        atomic_fetch_add(v7, 0xFFFFFFFF);
      }
    }
    os_unfair_lock_unlock(&CA::Render::Context::_context_lock);
  }
  return v1;
}

void CA::Render::find_port(CA::Render *this, uint64_t a2, CA::Render::Context *a3, void *a4)
{
  if (*(_DWORD *)(a2 + 256) == *(_DWORD *)a3 || *(_DWORD *)(a2 + 260) == *(_DWORD *)a3) {
    *((void *)a3 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = a2;
  }
}

uint64_t _CASCreateFencePort(int a1, _DWORD *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  memset(&msg_16[4], 0, 44);
  int msg_4 = 0;
  mach_port_t reply_port = mig_get_reply_port();
  int msg_8 = a1;
  mach_port_t msg_12 = reply_port;
  int msg = 5395;
  *(void *)msg_16 = 0x9D1000000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    mach_port_t reply_port = msg_12;
  }
  uint64_t v7 = mach_msg((mach_msg_header_t *)&msg, 3, 0x18u, 0x40u, reply_port, 0, 0);
  uint64_t v8 = v7;
  if ((v7 - 268435458) <= 0xE && ((1 << (v7 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg_12);
  }
  else
  {
    if (!v7)
    {
      if (*(_DWORD *)&msg_16[4] == 71)
      {
        uint64_t v8 = 4294966988;
      }
      else if (*(_DWORD *)&msg_16[4] == 40308)
      {
        if (msg < 0)
        {
          uint64_t v8 = 4294966996;
          if (*(_DWORD *)&msg_16[8] == 1 && msg_4 == 56 && !msg_8 && *(unsigned __int16 *)&msg_16[22] << 16 == 1114112)
          {
            uint64_t v8 = 0;
            *a2 = *(_DWORD *)&msg_16[12];
            *a3 = *(void *)&msg_16[32];
            return v8;
          }
        }
        else if (msg_4 == 36)
        {
          uint64_t v8 = 4294966996;
          if (*(_DWORD *)&msg_16[16])
          {
            if (msg_8) {
              uint64_t v8 = 4294966996;
            }
            else {
              uint64_t v8 = *(unsigned int *)&msg_16[16];
            }
          }
        }
        else
        {
          uint64_t v8 = 4294966996;
        }
      }
      else
      {
        uint64_t v8 = 4294966995;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
      return v8;
    }
    mig_dealloc_reply_port(msg_12);
  }
  return v8;
}

BOOL CA::Transaction::add_fence(CA::Transaction *this, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 116) & 2) != 0) {
    return 0;
  }
  if (!**((_DWORD **)this + 13)) {
    CA::Transaction::ensure_implicit(this, 1);
  }
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000;
  char v15 = 0;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  unint64_t v10[2] = ___ZN2CA11Transaction9add_fenceEjP13CAFenceHandleU13block_pointerFvvE_block_invoke;
  v10[3] = &unk_1E52740F8;
  int v11 = a2;
  v10[4] = a3;
  v10[5] = a4;
  v10[6] = &v12;
  v10[7] = this;
  -[CAFenceHandle _accessMachPort:](a3, (uint64_t)v10);
  BOOL v8 = *((unsigned char *)v13 + 24) != 0;
  _Block_object_dispose(&v12, 8);
  return v8;
}

void sub_1847AE348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1847AE400(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

void ___ZN2CA11Transaction9add_fenceEjP13CAFenceHandleU13block_pointerFvvE_block_invoke(uint64_t a1, int a2, char a3)
{
  v25[5] = *MEMORY[0x1E4F143B8];
  if ((a2 + 1) >= 2 && (a3 & 1) == 0)
  {
    uint64_t v5 = *(void *)(a1 + 56);
    kdebug_trace();
    uint64_t v6 = *(void *)(v5 + 104);
    int v7 = *(_DWORD *)(v5 + 100);
    *(_DWORD *)(v5 + 10CA::Context::unref(this[1], 0) = v7 + 1;
    if (!v7) {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    }
    BOOL v8 = (void *)(v6 + 32);
    uint64_t v9 = (char *)(v6 + 32);
    while (1)
    {
      uint64_t v9 = *(char **)v9;
      if (!v9) {
        break;
      }
      if (*((_DWORD *)v9 + 6) == a2) {
        goto LABEL_12;
      }
    }
    uint64_t v10 = *(void *)(a1 + 32);
    if (!v10
      || (int v11 = -[CAFenceHandle _copyUntrackedPort](*(os_unfair_lock_s **)(a1 + 32)),
          (v11 - 1) > 0xFFFFFFFD))
    {
      CA::Transaction::unlock((CA::Transaction *)v5);
      return;
    }
    uint64_t v12 = -[CAFenceHandle _initWithPort:name:tracing:]([CAFenceHandle alloc], v11, *(void *)(v10 + 16), 1);
    kdebug_trace();
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v9 = (char *)malloc_type_zone_malloc(malloc_zone, 0x20uLL, 0x8BB15036uLL);
    *((void *)v9 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v12;
    *((void *)v9 + 2) = 0;
    *(void *)uint64_t v9 = 0;
    v25[0] = MEMORY[0x1E4F143A8];
    v25[1] = 3221225472;
    v25[2] = ___ZN2CA11Transaction5FenceC2EP13CAFenceHandle_block_invoke;
    void v25[3] = &__block_descriptor_40_e11_v16__0I8B12l;
    v25[4] = v9;
    -[CAFenceHandle _accessMachPort:]((uint64_t)v12, (uint64_t)v25);
    *(void *)uint64_t v9 = *v8;
    *BOOL v8 = v9;
LABEL_12:
    uint64_t v14 = v9 + 16;
    char v15 = v9 + 16;
    while (1)
    {
      char v15 = *(_DWORD **)v15;
      if (!v15) {
        break;
      }
      if (v15[2] == *(_DWORD *)(a1 + 64)) {
        goto LABEL_17;
      }
    }
    uint64_t v16 = (malloc_zone_t *)get_malloc_zone();
    char v15 = malloc_type_zone_malloc(v16, 0x18uLL, 0x8BB15036uLL);
    int v17 = *(_DWORD *)(a1 + 64);
    *((void *)v15 + 2) = 0;
    void v15[2] = v17;
    *(void *)char v15 = *v14;
    *uint64_t v14 = v15;
LABEL_17:
    uint64_t v18 = *(const void **)(a1 + 40);
    if (v18)
    {
      uint64_t v19 = *((void *)v15 + 2);
      IOSurfaceID v20 = _Block_copy(v18);
      unint64_t v21 = (malloc_zone_t *)get_malloc_zone();
      float64x2_t v22 = malloc_type_zone_malloc(v21, 0x10uLL, 0x8BB15036uLL);
      *float64x2_t v22 = v20;
      v22[1] = v19;
      *((void *)v15 + 2) = v22;
    }
    CA::Transaction::unlock((CA::Transaction *)v5);
    uint64_t v23 = *(void *)(v5 + 104);
    if (!*(_DWORD *)(v23 + 40))
    {
      unsigned int add = atomic_fetch_add(CA::Transaction::capture_ftx_seed(void)::next_ftx_seed, 1u);
      *(_DWORD *)(v23 + 4CA::Context::unref(this[1], 0) = add + 1;
      if (add == -1) {
        *(_DWORD *)(v23 + 4CA::Context::unref(this[1], 0) = atomic_fetch_add(CA::Transaction::capture_ftx_seed(void)::next_ftx_seed, 1u) + 1;
      }
    }
    kdebug_trace();
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  }
}

void sub_1847AE714(_Unwind_Exception *a1)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, v1);
  _Unwind_Resume(a1);
}

void sub_1847AE980(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2CA11Transaction5FenceC2EP13CAFenceHandle_block_invoke(uint64_t result, int a2)
{
  if ((a2 + 1) <= 1) {
    __assert_rtn("Fence_block_invoke", "CATransactionInternal.mm", 1421, "MACH_PORT_VALID (port)");
  }
  *(_DWORD *)(*(void *)(result + 32) + 24) = a2;
  return result;
}

void sub_1847AEC58(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::OGL::anonymous namespace'::tile_rect_tex9_(uint64_t a1, uint64_t *a2, uint64_t a3, double *a4, float *a5, double *a6)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (double *)*a2;
  double v7 = *(double *)(*a2 + 16);
  if (v7 > 0.0)
  {
    double v8 = v6[3];
    if (v8 > 0.0)
    {
      double v16 = *v6;
      double v15 = v6[1];
      double v24 = 0.0;
      double v25 = 0.0;
      CA::Transform::get_scale_recip(a2[1], &v25, &v24);
      memset(v29, 0, sizeof(v29));
      memset(v28, 0, sizeof(v28));
      v27[0] = 0.0;
      v27[1] = 0.0;
      v26[0] = 0.0;
      v26[1] = 0.0;
      uint64_t v18 = *(void *)(a1 + 16);
      unint64_t v19 = *(void *)(v18 + 16) & 0xFFFFFF00FF00FF00;
      if (*(void *)(v18 + 8) == 0x3C003C003C003C00) {
        int v20 = 1;
      }
      else {
        int v20 = 3;
      }
      *(_DWORD *)(v18 + 16) = v20 | v19;
      *(_DWORD *)(v18 + 2CA::Context::unref(this[1], 0) = HIDWORD(v19);
      *(unsigned char *)(*(void *)(a1 + 16) + 16) = 0;
    }
  }
}

uint64_t CA::OGL::anonymous namespace'::prepare_9_slice(CA::OGL::_anonymous_namespace_ *this, double a2, double a3, double a4, double a5, const float *a6, double *a7, double *a8, float *a9)
{
  *a7 = a2;
  if (a4 > a2 || a5 < a3)
  {
    if (a3 < a4) {
      a4 = a3;
    }
    if (a4 < a2) {
      a4 = a2;
    }
    if (a3 < a5) {
      a5 = a3;
    }
    if (a5 >= a2) {
      a2 = a5;
    }
    a7[1] = a4;
    a7[2] = a2;
    a7[3] = a3;
    *(_DWORD *)a8 = *(_DWORD *)this;
    *((float *)a8 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(float *)this + (float)((float)(*((float *)this + 2) - *(float *)this) * *a6);
    *((float *)a8 + 2) = *(float *)this + (float)((float)(*((float *)this + 2) - *(float *)this) * a6[2]);
    *((_DWORD *)a8 + 3) = *((_DWORD *)this + 2);
    if (a4 > a2)
    {
      double v10 = (a2 + a4) * 0.5;
      a7[1] = v10;
      a7[2] = v10;
    }
    return 3;
  }
  else
  {
    a7[1] = a3;
    *(_DWORD *)a8 = *(_DWORD *)this;
    *((_DWORD *)a8 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *((_DWORD *)this + 2);
    return 1;
  }
}

void CA::OGL::anonymous namespace'::tile_n_part_rect(uint64_t a1, uint64_t a2, float *a3, double *a4, unsigned int a5, unsigned int a6, float64_t *a7, uint64_t a8, _DWORD *a9, uint64_t a10)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  double v10 = *(double *)(*(void *)a2 + 16) * (float)(a3[2] - *a3);
  double v11 = -v10;
  if (v10 >= 0.0) {
    double v11 = *(double *)(*(void *)a2 + 16) * (float)(a3[2] - *a3);
  }
  if (v11 > 0.0)
  {
    double v12 = (float)(a3[3] - a3[1]);
    double v13 = *(double *)(*(void *)a2 + 24) * v12;
    double v14 = -v13;
    if (v13 >= 0.0) {
      double v14 = *(double *)(*(void *)a2 + 24) * v12;
    }
    if (v14 > 0.0)
    {
      uint64_t v17 = 0;
      uint64_t v18 = a5 >> 1;
      uint64_t v82 = (v18 + 1);
      uint64_t v79 = &a7[v82];
      unint64_t v80 = a7;
      double v19 = *v79;
      uint64_t v75 = (a6 >> 1) + 1;
      float64x2_t v76 = &a7[v18];
      double v20 = a4[1];
      float v21 = (v19 - *v76) * *a4 / v11;
      int v84 = (double *)(a8 + 8 * v75);
      uint64_t v85 = a8;
      double v22 = *v84;
      uint64_t v23 = a6 >> 1;
      unsigned int v83 = (double *)(a8 + 8 * v23);
      float v24 = (v22 - *v83) * v20 / v14;
      v87[0] = 0;
      *(float *)&v87[1] = v21;
      v86[0] = 0;
      *(float *)&v86[1] = v24;
      unsigned int v77 = a6;
      unsigned int v78 = a5;
      uint64_t v25 = a5 + 1;
      float v26 = 1.1755e-38;
      float v27 = 3.4028e38;
      uint64_t v28 = a6 + 1;
      do
      {
        float v29 = *(float *)&a9[v17];
        if (v27 >= v29) {
          float v27 = *(float *)&a9[v17];
        }
        if (v26 <= v29) {
          float v26 = *(float *)&a9[v17];
        }
        ++v17;
      }
      while (v25 != v17);
      uint64_t v30 = 0;
      float v31 = 1.1755e-38;
      float v32 = 3.4028e38;
      do
      {
        float v33 = *(float *)(a10 + 4 * v30);
        if (v32 >= v33) {
          float v32 = *(float *)(a10 + 4 * v30);
        }
        if (v31 <= v33) {
          float v31 = *(float *)(a10 + 4 * v30);
        }
        ++v30;
      }
      while (v28 != v30);
      float v34 = 0.0;
      float v35 = 1.0;
      if (v27 >= 0.0 && v26 <= 1.0)
      {
        float64x2_t v38 = 0;
        float v40 = 1.0;
        float v27 = 0.0;
      }
      else
      {
        MEMORY[0x1F4188790](a1);
        float64x2_t v38 = (char *)&v73 - ((v37 + 15) & 0x7FFFFFFF0);
        bzero(v38, v37);
        uint64_t v39 = 0;
        float v40 = v26 - v27;
        do
        {
          *(float *)&v38[4 * v39] = (float)(*(float *)&a9[v39] - v27) * (float)(1.0 / v40);
          ++v39;
        }
        while (v25 != v39);
      }
      if (v32 >= 0.0 && v31 <= 1.0)
      {
        uint64_t v43 = 0;
      }
      else
      {
        MEMORY[0x1F4188790](a1);
        uint64_t v43 = (char *)&v73 - ((v42 + 15) & 0x7FFFFFFF0);
        bzero(v43, v42);
        uint64_t v44 = 0;
        float v35 = v31 - v32;
        do
        {
          *(float *)&v43[4 * v44] = (float)(*(float *)(a10 + 4 * v44) - v32) * (float)(1.0 / (float)(v31 - v32));
          ++v44;
        }
        while (v28 != v44);
        float v34 = v32;
      }
      *(unsigned char *)(*(void *)(a1 + 16) + 19) = 3;
      int32x4_t v45 = &a9[v82];
      float v46 = *(float *)&a9[v18];
      float v47 = *(float *)v45;
      double v74 = v45;
      uint64_t v73 = v18;
      uint64_t v48 = v75;
      uint64_t v81 = (float *)(a10 + 4 * v75);
      uint64_t v49 = v23;
      float v50 = *(float *)(a10 + 4 * v23);
      float v51 = *v81 - v50;
      int8x16_t v52 = *(float **)(a1 + 16);
      v52[92] = v47 - v46;
      v52[93] = v51;
      v52[94] = v46;
      v52[95] = v50;
      double v53 = v76;
      CA::OGL::emit_n_part_rect(a1, a2, 1, 1, v76, (uint64_t)v83, v87, (uint64_t)v86, 0, 0, 0);
      float v54 = *(float *)v45;
      int v55 = v73;
      float v56 = *(float *)&a9[v73];
      double v57 = *(float **)(a1 + 16);
      v57[92] = v54 - v56;
      v57[93] = v35;
      v57[94] = v56;
      v57[95] = v34;
      if (!v43) {
        uint64_t v43 = (char *)a10;
      }
      CA::OGL::emit_n_part_rect(a1, a2, 1, v49, v53, v85, v87, (uint64_t)v43, 0, 0, 0);
      CA::OGL::emit_n_part_rect(a1, a2, 1, v77 - v48, v53, (uint64_t)v84, v87, (uint64_t)&v43[4 * v48], 0, 0, 0);
      float v58 = *(float *)(a10 + 4 * v49);
      float v59 = *v81 - v58;
      int32x4_t v60 = *(float **)(a1 + 16);
      v60[92] = v40;
      v60[93] = v59;
      v60[94] = v27;
      v60[95] = v58;
      if (v38) {
        float64x2_t v61 = v38;
      }
      else {
        float64x2_t v61 = a9;
      }
      int v62 = v55;
      int v63 = v55;
      double v64 = v80;
      double v65 = v83;
      CA::OGL::emit_n_part_rect(a1, a2, v63, 1, v80, (uint64_t)v83, v61, (uint64_t)v86, 0, 0, 0);
      float64x2_t v66 = &v61[v82];
      double v67 = v79;
      CA::OGL::emit_n_part_rect(a1, a2, v78 - v82, 1, v79, (uint64_t)v65, v66, (uint64_t)v86, 0, 0, 0);
      *(unsigned char *)(*(void *)(a1 + 16) + 19) = 0;
      uint64_t v68 = v85;
      CA::OGL::emit_n_part_rect(a1, a2, v62, v49, v64, v85, a9, a10, 0, 0, 0);
      float64x2_t v69 = v74;
      CA::OGL::emit_n_part_rect(a1, a2, v62, v49, v67, v68, v74, a10, 0, 0, 0);
      unsigned int v70 = v64;
      uint64_t v71 = v84;
      float64x2_t v72 = v81;
      CA::OGL::emit_n_part_rect(a1, a2, v62, v49, v70, (uint64_t)v84, a9, (uint64_t)v81, 0, 0, 0);
      CA::OGL::emit_n_part_rect(a1, a2, v62, v49, v67, (uint64_t)v71, v69, (uint64_t)v72, 0, 0, 0);
    }
  }
}

CATransform3D *__cdecl CATransform3DTranslate_(CATransform3D *__return_ptr retstr, CATransform3D *t, CGFloat tx, CGFloat ty, CGFloat tz)
{
  float64x2_t v5 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)&t->m43, *(float64x2_t *)&t->m13, tx), *(float64x2_t *)&t->m23, ty), *(float64x2_t *)&t->m33, tz);
  *(float64x2_t *)&t->m41 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)&t->m41, *(float64x2_t *)&t->m11, tx), *(float64x2_t *)&t->m21, ty), *(float64x2_t *)&t->m31, tz);
  *(float64x2_t *)&t->m43 = v5;
  return t;
}

uint64_t CA::OGL::MaskNode::propagate_roi(uint64_t this, const CA::Bounds *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  double v2 = *(unsigned char **)(this + 24);
  if (v2)
  {
    uint64_t v4 = this;
    float64x2_t v5 = *(const CA::Transform **)(this + 80);
    if ((*((unsigned char *)v5 + 144) & 0x10) == 0 && (*(unsigned char *)(this + 222) & 0x20) == 0 && (v2[222] & 0x10) == 0)
    {
      uint64_t v6 = *(void *)(*(void *)(this + 16) + 24);
      int8x16_t v8 = *(int8x16_t *)(v6 + 64);
      long long v7 = *(_OWORD *)(v6 + 80);
      int8x16_t v32 = v8;
      long long v33 = v7;
      uint64_t v9 = *(void *)(v6 + 128);
      double v10 = *((double *)&v7 + 1);
      if (v9)
      {
        if (*(void *)(v9 + 72))
        {
          uint64_t v27 = v6;
          uint64_t v28 = v5;
          double v26 = *((double *)&v7 + 1);
          uint64_t v24 = v8.i64[1];
          uint64_t v25 = v7;
          CA::Render::Layer::max_corner_radii(v9);
          v8.i64[1] = v24;
          *(void *)&long long v7 = v25;
          uint64_t v6 = v27;
          float64x2_t v5 = v28;
          double v10 = v26;
        }
        else
        {
          double v11 = *(float *)(v9 + 228);
        }
      }
      else
      {
        double v11 = 0.0;
      }
      if (v11 > 0.0)
      {
        if ((*(unsigned char *)(v6 + 40) & 3) != 0) {
          double v11 = v11 * 1.528665;
        }
        if (*(double *)&v7 <= v10) {
          double v12 = v10;
        }
        else {
          double v12 = *(double *)&v7;
        }
        if (v12 < 1.79769313e308)
        {
          double v13 = *(double *)&v7 >= v10 ? v10 : *(double *)&v7;
          if (v13 > 0.0)
          {
            *(double *)&v32.i64[1] = *(double *)&v8.i64[1] + v11;
            *(void *)&long long v33 = v7;
            double v14 = v10 - (v11 + v11);
            *((double *)&v33 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v14;
            if (*(double *)&v7 <= 0.0 || v14 <= 0.0) {
              long long v33 = 0uLL;
            }
          }
        }
      }
      *(double *)v15.i64 = CA::Rect::apply_transform_interior(&v32, v5);
      int v17 = *((_DWORD *)a2 + 2);
      int v18 = *((_DWORD *)a2 + 3);
      if (v17 <= v18) {
        int v19 = *((_DWORD *)a2 + 3);
      }
      else {
        int v19 = *((_DWORD *)a2 + 2);
      }
      v15.i32[0] = 1073741822;
      v16.i32[0] = v19;
      v20.i64[0] = (int)*(void *)a2;
      v20.i64[1] = (int)HIDWORD(*(void *)a2);
      int8x16_t v21 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v16, v15), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v20));
      double v22 = (double)v17;
      if (v19 > 1073741822) {
        double v22 = 1.79769313e308;
      }
      int8x16_t v29 = v21;
      if (v19 <= 1073741822) {
        double v23 = (double)v18;
      }
      else {
        double v23 = 1.79769313e308;
      }
      double v30 = v22;
      double v31 = v23;
      if (CA::BoundsImpl::contains((double *)v32.i64, (double *)v29.i64))
      {
        *(_WORD *)(v4 + 212) |= 0x100u;
        v2[124] = *(unsigned char *)(v4 + 124);
        double v2 = *(unsigned char **)(v4 + 24);
      }
    }
    this = (*(uint64_t (**)(unsigned char *, const CA::Bounds *))(*(void *)v2 + 56))(v2, a2);
    *(_WORD *)(*(void *)(v4 + 24) + 212) |= 0x200u;
  }
  return this;
}

double CA::Rect::apply_transform_interior(int8x16_t *this, const CA::Transform *a2)
{
  BOOL v17[8] = *(double *)MEMORY[0x1E4F143B8];
  char v4 = *((unsigned char *)a2 + 144);
  if ((v4 & 0x10) != 0)
  {
    if (CA::Mat4Impl::mat4_is_rectilinear(a2, (const double *)a2))
    {
      CA::Mat4Impl::mat4_apply_to_rect((float64x2_t *)a2, this, v10);
    }
    else
    {
      double v11 = *(double *)this[1].i64;
      double result = *(double *)&this[1].i64[1];
      if (v11 <= result) {
        double v12 = *(double *)&this[1].i64[1];
      }
      else {
        double v12 = *(double *)this[1].i64;
      }
      if (v12 < 1.79769313e308)
      {
        uint64_t v13 = 0;
        double v14 = *(double *)&this->i64[1];
        v17[0] = *(double *)this->i64;
        v17[1] = v14;
        void v17[2] = v11 + v17[0];
        v17[3] = v14;
        v17[4] = v11 + v17[0];
        v17[5] = result + v14;
        v17[6] = v17[0];
        v17[7] = result + v14;
        do
        {
          CA::Mat4Impl::mat4_apply_to_point2((float64x2_t *)a2, &v17[v13], v10);
          v13 += 2;
        }
        while (v13 != 8);
        CA::Rect::set_corners_interior((uint64_t)this, v17);
      }
    }
  }
  else
  {
    double v6 = *(double *)this[1].i64;
    double result = *(double *)&this[1].i64[1];
    if (v6 <= result) {
      double v7 = *(double *)&this[1].i64[1];
    }
    else {
      double v7 = *(double *)this[1].i64;
    }
    if (v7 < 1.79769313e308)
    {
      if ((*((unsigned char *)a2 + 144) & 8) != 0)
      {
        double v8 = *(double *)&this->i64[1];
        *(double *)this->i64 = *(double *)this->i64 * *((double *)a2 + 16);
        *(double *)&this->i64[1] = v8 * *((double *)a2 + 16);
        double v6 = *((double *)a2 + 16) * v6;
        *(double *)this[1].i64 = v6;
        double result = *((double *)a2 + 16) * result;
        *(double *)&this[1].i64[1] = result;
        char v4 = *((unsigned char *)a2 + 144);
      }
      if ((v4 & 4) != 0)
      {
        uint64_t v15 = this->i64[0];
        *(double *)this->i64 = -(result + *(double *)&this->i64[1]);
        this->i64[1] = v15;
        *(double *)this[1].i64 = result;
        *(double *)&this[1].i64[1] = v6;
        char v4 = *((unsigned char *)a2 + 144);
        double v9 = v6;
        if ((v4 & 2) == 0)
        {
LABEL_24:
          double v16 = *(double *)&this->i64[1];
          if (v4)
          {
            double v16 = -(v9 + v16);
            *(double *)&this->i64[1] = v16;
          }
          *(double *)this->i64 = *(double *)this->i64 + *((double *)a2 + 12);
          double result = v16 + *((double *)a2 + 13);
          *(double *)&this->i64[1] = result;
          return result;
        }
      }
      else
      {
        double v9 = result;
        double result = v6;
        if ((v4 & 2) == 0) {
          goto LABEL_24;
        }
      }
      *(double *)this->i64 = -(result + *(double *)this->i64);
      char v4 = *((unsigned char *)a2 + 144);
      goto LABEL_24;
    }
  }
  return result;
}

uint64_t CA::Rect::set_corners_interior(uint64_t result, double *a2)
{
  uint64_t v3 = (double *)result;
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  double v5 = *a2;
  double v4 = a2[1];
  double v7 = a2[2];
  double v6 = a2[3];
  double v37 = v5;
  double v38 = v7;
  double v9 = a2[4];
  double v8 = a2[5];
  double v11 = a2[6];
  double v10 = a2[7];
  double v39 = v9;
  double v40 = v11;
  double v33 = v4;
  double v34 = v6;
  double v35 = v8;
  double v36 = v10;
  if (v5 <= v7)
  {
    double v7 = v5;
  }
  else
  {
    double v37 = v7;
    double v38 = v5;
  }
  if (v9 <= v11)
  {
    double v11 = v9;
  }
  else
  {
    double v39 = v11;
    double v40 = v9;
  }
  if (v4 <= v6)
  {
    double v6 = v4;
  }
  else
  {
    double v33 = v6;
    double v34 = v4;
  }
  if (v8 <= v10)
  {
    double v10 = v8;
  }
  else
  {
    double v35 = v10;
    double v36 = v8;
  }
  BOOL v12 = v7 < v11;
  uint64_t v13 = 2;
  if (v7 >= v11) {
    unsigned int v14 = 3;
  }
  else {
    unsigned int v14 = 2;
  }
  double v15 = *(&v37 + (v7 < v11));
  double v16 = *(&v37 + v14);
  if (v15 < v16)
  {
    double v17 = *(&v37 + (v7 < v11));
  }
  else
  {
    ++v14;
    double v17 = v16;
  }
  if (v6 >= v10) {
    unsigned int v18 = 3;
  }
  else {
    unsigned int v18 = 2;
  }
  double v19 = *(&v33 + (v6 < v10));
  double v20 = *(&v33 + v18);
  if (v6 >= v10) {
    uint64_t v13 = 1;
  }
  if (v19 < v20)
  {
    double v21 = *(&v33 + (v6 < v10));
  }
  else
  {
    uint64_t v13 = v6 < v10;
    ++v18;
    double v21 = v20;
  }
  if (v7 >= v11 || v15 >= v16)
  {
    uint64_t v23 = 2;
    if (v7 >= v11) {
      uint64_t v23 = 1;
    }
    if (v15 < v16) {
      BOOL v12 = v23;
    }
    double v22 = *(&v37 + v12);
    if (v14 <= 3 && v22 >= *(&v37 + v14)) {
      double v22 = *(&v37 + v14);
    }
  }
  else
  {
    double v22 = *(&v37 + v14);
  }
  if (v6 >= v10 || v19 >= v20)
  {
    double v24 = *(&v33 + v13);
    if (v18 <= 3 && v24 >= *(&v33 + v18)) {
      double v24 = *(&v33 + v18);
    }
  }
  else
  {
    double v24 = *(&v33 + v18);
  }
  uint64_t v25 = 0;
  double v26 = a2 + 1;
  double v27 = 0.0;
  uint64_t v28 = 3;
  do
  {
    double v27 = v27 + *v26 * a2[2 * v28] - a2[2 * v28 + 1] * *(v26 - 1);
    uint64_t v28 = v25++;
    v26 += 2;
  }
  while (v25 != 4);
  double v29 = (v24 - v21) * (v22 - v17);
  if (v27 < 0.0) {
    double v27 = -v27;
  }
  if (COERCE__INT64(fabs((v24 - v21) * (v22 - v17))) <= 0x7FEFFFFFFFFFFFFFLL
    && ((v30 = v27 * 0.5, double v31 = v27 * 0.25, v29 <= v30) ? (v32 = v29 <= v31) : (v32 = 1),
        !v32
     && (double result = CA::point_inside_quad(a2, v17, v21), result)
     && (double result = CA::point_inside_quad(a2, v22, v21), result)
     && (double result = CA::point_inside_quad(a2, v22, v24), result)
     && (double result = CA::point_inside_quad(a2, v17, v24), result)))
  {
    *uint64_t v3 = v17;
    v3[1] = v21;
    v3[2] = v22 - v17;
    v3[3] = v24 - v21;
  }
  else
  {
    *(_OWORD *)uint64_t v3 = 0u;
    *((_OWORD *)v3 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0u;
  }
  return result;
}

uint64_t CA::point_inside_quad(double *a1, double a2, double a3)
{
  double v3 = a1[1];
  double v4 = a1[2];
  double v5 = a1[3];
  double v6 = (v3 - v5) * (a2 - *a1) + (v4 - *a1) * (a3 - v3);
  double v7 = a1[4];
  double v8 = a1[5];
  double v9 = (v5 - v8) * (a2 - v4) + (v7 - v4) * (a3 - v5);
  double v10 = a1[6];
  double v11 = a1[7];
  double v12 = (v8 - v11) * (a2 - v7) + (v10 - v7) * (a3 - v8);
  double v13 = (v11 - v3) * (a2 - v10) + (a3 - v11) * (*a1 - v10);
  if (v6 <= 0.0 && v9 <= 0.0 && v12 <= 0.0 && v13 <= 0.0) {
    return 1;
  }
  BOOL v15 = v6 >= 0.0;
  if (v9 < 0.0) {
    BOOL v15 = 0;
  }
  if (v12 < 0.0) {
    BOOL v15 = 0;
  }
  return v13 >= 0.0 && v15;
}

CGAffineTransform *__cdecl CATransform3DGetAffineTransform(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t)
{
  long long v2 = *(_OWORD *)&t->tx;
  *(_OWORD *)&retstr->a = *(_OWORD *)&t->a;
  *(_OWORD *)&retstr->c = v2;
  *(_OWORD *)&retstr->tx = *(_OWORD *)&t[2].a;
  return t;
}

void ___ZN2CA6Render7Encoder26initialize_render_id_slideEv_block_invoke()
{
}

uint64_t CA::Transaction::set_frame_input_time(uint64_t this, double a2)
{
  double v2 = *(double *)(this + 192);
  if (v2 == 0.0 || v2 > a2)
  {
    *(double *)(this + 192) = a2;
    if ((*(unsigned char *)(this + 204) & 0x20) == 0)
    {
      CAHostTimeWithTime(a2);
      return kdebug_trace();
    }
  }
  return this;
}

uint64_t CAImageQueueGetReleasedImageInfo()
{
  uint64_t result = release_key;
  if (release_key)
  {
    uint64_t v1 = pthread_getspecific(release_key);
    if (v1) {
      return (uint64_t)v1 + 56;
    }
    else {
      return 0;
    }
  }
  return result;
}

void sub_1847B0BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *context)
{
}

void ___ZN2CA3OGL12MetalContext26prepare_new_command_bufferEv_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1 + 32) + 4032), 1uLL);
  uint64_t v3 = [a2 protectionOptions];
  if ([a2 error])
  {
    if (x_log_hook_p())
    {
      objc_msgSend((id)objc_msgSend(a2, "label"), "UTF8String");
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "error"), "localizedDescription"), "UTF8String");
      x_log_();
    }
    else
    {
      double v4 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 134218754;
        double v6 = a2;
        __int16 v7 = 2048;
        uint64_t v8 = v3;
        __int16 v9 = 2080;
        uint64_t v10 = objc_msgSend((id)objc_msgSend(a2, "label"), "UTF8String");
        __int16 v11 = 2080;
        uint64_t v12 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "error"), "localizedDescription"), "UTF8String");
        _os_log_impl(&dword_184668000, v4, OS_LOG_TYPE_ERROR, "MTLCommandBuffer %p, protection 0x%llx, label %s, error = %s\n", buf, 0x2Au);
      }
    }
  }
}

uint64_t CAML::Context::result(CAML::Context *this)
{
  double v2 = (xmlParserCtxt *)*((void *)this + 1);
  if (v2)
  {
    xmlParseChunk(v2, "", 0, 1);
    xmlFreeParserCtxt(*((xmlParserCtxtPtr *)this + 1));
    *((void *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
    uint64_t v3 = (const void *)*((void *)this + 9);
    if (v3)
    {
      CFRelease(v3);
      *((void *)this + 9) = 0;
    }
    CAML::Context::pop_state(this);
    (*(void (**)(CAML::Context *))(*(void *)this + 64))(this);
  }
  return *((void *)this + 5);
}

void CAML::Context::set_base_url(CAML::Context *this, CFTypeRef cf)
{
  double v4 = (const void *)*((void *)this + 2);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 2) = 0;
  }
  if (cf) {
    *((void *)this + 2) = CFRetain(cf);
  }
}

void CAML::Context::set_current_url(CAML::Context *this, CFTypeRef cf)
{
  double v4 = (const void *)*((void *)this + 3);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 3) = 0;
  }
  if (cf) {
    *((void *)this + 3) = CFRetain(cf);
  }
}

void sub_1847B14A0(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&parser_mutex);
  _Unwind_Resume(a1);
}

uint64_t CA::OGL::MetalContext::create_pipeline_state(uint64_t a1, CA::OGL::MetalContext::Pipeline::Spec *this, _DWORD *a3, unsigned __int8 *a4)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = NSString;
  uint64_t v9 = CA::OGL::MetalContext::Pipeline::Spec::encode_segment(this);
  uint64_t v10 = (NSString *)[v8 stringWithFormat:@"%@_%@", v9, CA::OGL::MetalContext::FragmentShader::Spec::name(this)];
  if ((*(unsigned char *)(a1 + 434) & 0x10) == 0)
  {
    uint64_t pipeline_state = CA::OGL::MetalContext::load_pipeline_state((CA::OGL::MetalContext *)a1, v10);
    if (pipeline_state)
    {
      uint64_t v12 = pipeline_state;
      *a3 |= 4u;
      return v12;
    }
    if ((*(_WORD *)((unsigned char *)this + 17) & 4) != 0) {
      return 0;
    }
  }
  id pipeline_descriptor = CA::OGL::MetalContext::get_pipeline_descriptor(a1, (uint64_t)this, 0, a4);
  char v14 = 1;
  if (a4)
  {
LABEL_6:
    unsigned __int8 v15 = atomic_load(a4);
    if ((v15 & 1) == 0) {
      goto LABEL_7;
    }
    return 0;
  }
  while (1)
  {
LABEL_7:
    id v30 = 0;
    if (byte_1EB2ACBEC || (*(unsigned char *)(a1 + 434) & 0x10) != 0)
    {
      if (x_log_hook_p())
      {
        uint64_t v28 = [(NSString *)v10 UTF8String];
        double v29 = (uint8_t *)objc_msgSend((id)objc_msgSend(pipeline_descriptor, "description"), "UTF8String");
        x_log_();
      }
      else
      {
        double v16 = x_log_category_ogl_metal;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = [(NSString *)v10 UTF8String];
          uint64_t v18 = objc_msgSend((id)objc_msgSend(pipeline_descriptor, "description"), "UTF8String");
          *(_DWORD *)long long buf = 136315394;
          uint64_t v36 = v17;
          __int16 v37 = 2080;
          uint64_t v38 = v18;
          _os_log_impl(&dword_184668000, v16, OS_LOG_TYPE_DEFAULT, "Building render pipeline %s with descriptor %s\n", buf, 0x16u);
        }
      }
    }
    os_signpost_id_t v19 = os_signpost_id_generate((os_log_t)x_log_category_ogl_metal);
    if (v19 - 1 > 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v12 = [*(id *)(a1 + 2952) newRenderPipelineStateWithDescriptor:pipeline_descriptor error:&v30];
    }
    else
    {
      os_signpost_id_t v20 = v19;
      double v21 = x_log_category_ogl_metal;
      if (os_signpost_enabled((os_log_t)x_log_category_ogl_metal))
      {
        *(_DWORD *)long long buf = 138543618;
        uint64_t v36 = (uint64_t)v10;
        __int16 v37 = 1026;
        LODWORD(v38) = 0;
        _os_signpost_emit_with_name_impl(&dword_184668000, v21, OS_SIGNPOST_INTERVAL_BEGIN, v20, "CompileShader", "pipeline=%{public, name=pipeline}@ precompiled=%{public, name=precompiled}u", buf, 0x12u);
      }
      uint64_t v12 = objc_msgSend(*(id *)(a1 + 2952), "newRenderPipelineStateWithDescriptor:error:", pipeline_descriptor, &v30, v28, v29);
      double v22 = x_log_category_ogl_metal;
      if (os_signpost_enabled((os_log_t)x_log_category_ogl_metal))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl(&dword_184668000, v22, OS_SIGNPOST_INTERVAL_END, v20, "CompileShader", (const char *)&unk_1849E4FC6, buf, 2u);
      }
    }
    *a3 |= 0x10u;
    if (v12) {
      return v12;
    }
    bzero(buf, 0x800uLL);
    uint64_t v23 = [(NSString *)v10 UTF8String];
    snprintf((char *)buf, 0x800uLL, "spec=%s\n%s", v23, (const char *)objc_msgSend((id)objc_msgSend(v30, "localizedDescription"), "UTF8String"));
    char v39 = 0;
    BOOL v24 = x_log_hook_p();
    if ((v14 & 1) == 0)
    {
      if (v24)
      {
        x_log_();
      }
      else
      {
        double v27 = x_log_category_ogl_metal;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)double v31 = 136315394;
          BOOL v32 = "Metal failed to build render pipeline";
          __int16 v33 = 2080;
          double v34 = buf;
          _os_log_impl(&dword_184668000, v27, OS_LOG_TYPE_ERROR, "%s: %s\n", v31, 0x16u);
        }
      }
      strlen((const char *)buf);
      abort_with_payload();
    }
    if (v24)
    {
      double v29 = buf;
      uint64_t v28 = "Metal failed to build render pipeline";
      x_log_();
    }
    else
    {
      uint64_t v25 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)double v31 = 136315394;
        BOOL v32 = "Metal failed to build render pipeline";
        __int16 v33 = 2080;
        double v34 = buf;
        _os_log_impl(&dword_184668000, v25, OS_LOG_TYPE_FAULT, "%s: %s\n", v31, 0x16u);
      }
    }
    char v14 = 0;
    *a3 |= 0x40u;
    if (a4) {
      goto LABEL_6;
    }
  }
}

uint64_t CA::OGL::MetalContext::load_pipeline_state(CA::OGL::MetalContext *this, NSString *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (byte_1EB2ACC28 || (*((unsigned char *)this + 434) & 0x20) != 0 || !*((void *)this + 418)) {
    return 0;
  }
  if (CA::OGL::MetalContext::get_offline_compilation_index(void)::index_once[0] != -1) {
    dispatch_once(CA::OGL::MetalContext::get_offline_compilation_index(void)::index_once, &__block_literal_global_2946);
  }
  double v4 = (void *)[(id)CA::OGL::MetalContext::get_offline_compilation_index(void)::index objectForKey:a2];
  if (!v4) {
    return 0;
  }
  int v5 = [v4 intValue];
  if (LOBYTE((&CA::OGL::MetalContext::offline_compilation_manifest)[5 * v5 + 1]))
  {
    if (![*((id *)this + 369) supportsFamily:(&CA::OGL::MetalContext::offline_compilation_manifest)[5 * v5 + 2]])return 0; {
  }
    }
  if (LOBYTE((&CA::OGL::MetalContext::offline_compilation_manifest)[5 * v5 + 3])
    && ([*((id *)this + 369) supportsFamily:(&CA::OGL::MetalContext::offline_compilation_manifest)[5 * v5 + 4]] & 1) != 0)
  {
    return 0;
  }
  uint64_t v6 = mach_continuous_time();
  long long v27 = 0u;
  long long v28 = 0u;
  CA::OGL::MetalContext::Pipeline::Spec::decode_name((CA::OGL::MetalContext::Pipeline::Spec *)&v27, (char *)[(NSString *)a2 UTF8String]);
  if (BYTE7(v28)) {
    return 0;
  }
  id v14 = 0;
  id pipeline_descriptor = CA::OGL::MetalContext::get_pipeline_descriptor((uint64_t)this, (uint64_t)&v27, 1, 0);
  uint64_t v26 = *((void *)this + 418);
  objc_msgSend(pipeline_descriptor, "setBinaryArchives:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", &v26, 1));
  uint64_t v8 = [*((id *)this + 369) newRenderPipelineStateWithDescriptor:pipeline_descriptor options:4 reflection:0 error:&v14];
  if (!v8)
  {
    bzero(__str, 0x7FFuLL);
    uint64_t v10 = [(NSString *)a2 UTF8String];
    __int16 v11 = (const char *)[@"22C138" UTF8String];
    snprintf(__str, 0x800uLL, "pipeline=%s sdk=%s\n%s", v10, v11, (const char *)objc_msgSend((id)objc_msgSend(v14, "localizedDescription"), "UTF8String"));
    char v25 = 0;
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v12 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315394;
        double v16 = "Metal failed to load render pipeline";
        __int16 v17 = 2080;
        uint64_t v18 = __str;
        _os_log_impl(&dword_184668000, v12, OS_LOG_TYPE_FAULT, "%s: %s\n", buf, 0x16u);
      }
    }
    return 0;
  }
  uint64_t v9 = v8;
  if (os_signpost_enabled((os_log_t)x_log_category_ogl_metal))
  {
    *(_DWORD *)__str = 138543874;
    os_signpost_id_t v20 = a2;
    __int16 v21 = 1026;
    int v22 = 1;
    __int16 v23 = 2050;
    uint64_t v24 = v6;
    _os_signpost_emit_unreliably_with_name_impl();
  }
  return v9;
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::decode_name(CA::OGL::MetalContext::Pipeline::Spec *this, char *a2)
{
  double v2 = this;
  v10[1] = *(char **)MEMORY[0x1E4F143B8];
  v10[0] = a2;
  CA::OGL::MetalContext::decode_segment(v10, (uint64_t)this, byte_1ED033CC0, 6u);
  uint64_t result = CA::OGL::MetalContext::FragmentShader::Spec::decode_name(v2, v10[0]);
  *(_DWORD *)((char *)v2 + 19) = 0;
  double v4 = (char *)v2 + 19;
  unsigned int v5 = *(unsigned __int16 *)((char *)v2 + 17);
  int v6 = (16 * v5) & 0x100 | (((v5 >> 2) & 1) << 7);
  if ((v5 & 4) != 0)
  {
    *(_WORD *)((char *)v2 + 2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v6;
  }
  else
  {
    uint64_t v7 = *((unsigned char *)v2 + 14) & 0x7F;
    *(_WORD *)((char *)v2 + 2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v6 | (uint64_t)CA::OGL::MetalContext::fragment_shader_type_info[2
                                                                                               * (CA::OGL::MetalContext::texture_function_info[8 * v7 - v7] & 0x3F)
                                                                                               + 1] & 0x1F | (32 * ((*((unsigned char *)v2 + 16) >> 3) & 3));
    uint64_t v8 = CA::OGL::tex_image_count[v7];
    if (CA::OGL::tex_image_count[v7])
    {
      do
      {
        int v9 = *(_DWORD *)v2;
        double v2 = (CA::OGL::MetalContext::Pipeline::Spec *)((char *)v2 + 7);
        *double v4 = *v4 & 0xFC | byte_18499EBD8[v9 & 0x3F] & 3;
        ++v4;
        --v8;
      }
      while (v8);
    }
  }
  return result;
}

void *CA::OGL::MetalContext::create_vertex_shader(void **this, const CA::OGL::MetalContext::VertexShader::Spec *a2, int a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = (void *)CA::OGL::MetalContext::VertexShader::Spec::encode_segment(a2);
  uint64_t v6 = [CA::OGL::MetalContext::vertex_shader_type_info[3 * (*((_WORD *)a2 + 1) & 0x1F) + 1] stringByAppendingString:@"_lph"];
  if (v6)
  {
    uint64_t v7 = (__CFString *)v6;
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v7 = off_1E527BDF8[((unint64_t)*((unsigned __int16 *)a2 + 1) >> 7) & 1];
    uint64_t v8 = objc_opt_new();
    __str[0] = (*((_WORD *)a2 + 1) & 0x80) != 0;
    [@"fc_generic" UTF8String];
    [v8 setConstantValue:__str type:53 withName:@"fc_generic"];
    __str[0] = (*((unsigned char *)a2 + 2) >> 5) & 3;
    [@"fc_vertex_layout" UTF8String];
    [v8 setConstantValue:__str type:49 withName:@"fc_vertex_layout"];
    __int16 v9 = *((_WORD *)a2 + 1);
    if ((v9 & 0x80) != 0)
    {
      __str[0] = (v9 & 0x200) != 0;
      [@"fc_base_color" UTF8String];
      [v8 setConstantValue:__str type:53 withName:@"fc_base_color"];
    }
    else
    {
      uint64_t v10 = 0;
      char v11 = 1;
      do
      {
        char v12 = v11;
        uint64_t v13 = objc_msgSend(NSString, "stringWithFormat:", @"fc_texcoord_count%d", v10);
        __str[0] = *((unsigned char *)a2 + v10) & 3;
        [v13 UTF8String];
        [v8 setConstantValue:__str type:49 withName:v13];
        char v11 = 0;
        uint64_t v10 = 1;
      }
      while ((v12 & 1) != 0);
    }
  }
  if (v8) {
    uint64_t v14 = 6;
  }
  else {
    uint64_t v14 = 1;
  }
  for (char i = 1; ; char i = 0)
  {
    id v26 = 0;
    shader_functiouint64_t n = CA::OGL::MetalContext::load_shader_function((uint64_t)this, this[417], v7, v5, v8, a3, (uint64_t)&v26);
    if (shader_function) {
      break;
    }
    uint64_t v17 = reason_messages[v14];
    bzero(__str, 0x800uLL);
    uint64_t v18 = (const char *)[(__CFString *)v7 UTF8String];
    os_signpost_id_t v19 = (const char *)[v5 UTF8String];
    snprintf(__str, 0x800uLL, "function=%s spec=%s\n%s", v18, v19, (const char *)objc_msgSend((id)objc_msgSend(v26, "localizedDescription"), "UTF8String"));
    __str[2047] = 0;
    BOOL v20 = x_log_hook_p();
    if ((i & 1) == 0)
    {
      if (v20)
      {
        x_log_();
      }
      else
      {
        uint64_t v24 = x_log_category_ogl_metal;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136315394;
          uint64_t v28 = v17;
          __int16 v29 = 2080;
          id v30 = __str;
          _os_log_impl(&dword_184668000, v24, OS_LOG_TYPE_ERROR, "%s: %s\n", buf, 0x16u);
        }
      }
      strlen(__str);
      abort_with_payload();
      __break(1u);
    }
    if (v20)
    {
      x_log_();
    }
    else
    {
      __int16 v21 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315394;
        uint64_t v28 = v17;
        __int16 v29 = 2080;
        id v30 = __str;
        _os_log_impl(&dword_184668000, v21, OS_LOG_TYPE_FAULT, "%s: %s\n", buf, 0x16u);
      }
    }
  }
  [shader_function setLabel:objc_msgSend(@"com.apple.coreanimation.vert.", "stringByAppendingString:", v5)];

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t result = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
  if (result)
  {
    *uint64_t result = shader_function;
    result[1] = 0;
  }
  return result;
}

void *CA::OGL::MetalContext::create_fragment_shader(void **this, const CA::OGL::MetalContext::FragmentShader::Spec *a2, int a3)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  float64x2_t v101 = (void *)CA::OGL::MetalContext::FragmentShader::Spec::name(a2);
  double v100 = (__CFString *)[CA::OGL::MetalContext::fragment_shader_type_info[2* (CA::OGL::MetalContext::texture_function_info[8 * (*((unsigned char *)a2 + 14) & 0x7F) - (*((unsigned char *)a2 + 14) & 0x7F)] & 0x3F)] stringByAppendingString:@"_lph"];
  if (v100)
  {
    double v4 = 0;
    goto LABEL_3;
  }
  double v100 = off_1E527BC10[((unint64_t)*(unsigned __int16 *)((char *)a2 + 17) >> 11) & 1];
  if (!v100) {
    __assert_rtn("create_fragment_shader", "ogl-metal.mm", 7170, "function_name != nil");
  }
  double v4 = objc_opt_new();
  int v110 = 0;
  long long v108 = 0u;
  long long v109 = 0u;
  *(_OWORD *)__str = 0u;
  CA::OGL::MetalContext::FragmentShader::Spec::get_config((uint64_t)__str, (int *)a2);
  buf[0] = (*((unsigned char *)a2 + 17) & 4) != 0;
  [@"fc_generic" UTF8String];
  [v4 setConstantValue:buf type:53 withName:@"fc_generic"];
  buf[0] = (*((unsigned char *)a2 + 16) >> 3) & 3;
  [@"fc_vertex_layout" UTF8String];
  [v4 setConstantValue:buf type:49 withName:@"fc_vertex_layout"];
  buf[0] = (*((unsigned char *)a2 + 17) & 0x20) != 0;
  [@"fc_framebuffer_fetch" UTF8String];
  [v4 setConstantValue:buf type:53 withName:@"fc_framebuffer_fetch"];
  buf[0] = (*((unsigned char *)a2 + 16) >> 5) & 3;
  [@"fc_attachment_count" UTF8String];
  [v4 setConstantValue:buf type:49 withName:@"fc_attachment_count"];
  if ((*(_WORD *)((unsigned char *)a2 + 17) & 4) != 0)
  {
    LOBYTE(v16) = 1;
  }
  else
  {
    uint64_t v15 = *((unsigned char *)a2 + 14) & 0x7F;
    if ((*(_WORD *)&CA::OGL::MetalContext::texture_function_info[8 * v15 - v15 + 5] & 0x20) != 0)
    {
      LOBYTE(v16) = 0;
    }
    else
    {
      uint64_t v16 = CA::OGL::tex_image_count[v15];
      if (v16)
      {
        uint64_t v17 = v16 - 1;
        uint64_t v18 = a2;
        do
        {
          uint64_t v19 = v17;
          int v20 = *(_DWORD *)v18;
          uint64_t v18 = (const CA::OGL::MetalContext::FragmentShader::Spec *)((char *)v18 + 7);
          LOBYTE(v16) = ((0x42000FFE00uLL >> v20) & 1) == 0;
          if (((0x42000FFE00uLL >> v20) & 1) == 0) {
            break;
          }
          --v17;
        }
        while (v19);
      }
    }
  }
  buf[0] = v16;
  [@"fc_has_lod_bias" UTF8String];
  [v4 setConstantValue:buf type:53 withName:@"fc_has_lod_bias"];
  buf[0] = (*(_WORD *)((unsigned char *)a2 + 17) & 0xC) != 0;
  [@"fc_has_noise_scale" UTF8String];
  [v4 setConstantValue:buf type:53 withName:@"fc_has_noise_scale"];
  if ((*(_WORD *)((unsigned char *)a2 + 17) & 4) != 0) {
    goto LABEL_34;
  }
  unint64_t v21 = CA::OGL::tex_image_count[*((unsigned char *)a2 + 14) & 0x7F];
  if (!CA::OGL::tex_image_count[*((unsigned char *)a2 + 14) & 0x7F]) {
    goto LABEL_35;
  }
  if ((CA::OGL::MetalContext::image_function_info[*(_DWORD *)a2 & 0x3F] & 2) != 0)
  {
LABEL_34:
    LOBYTE(v2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 1;
    goto LABEL_35;
  }
  unint64_t v22 = 0;
  __int16 v23 = (int *)((char *)a2 + 7);
  while (v21 - 1 != v22)
  {
    int v24 = *v23;
    __int16 v23 = (int *)((char *)v23 + 7);
    ++v22;
    if ((CA::OGL::MetalContext::image_function_info[v24 & 0x3F] & 2) != 0) {
      goto LABEL_97;
    }
  }
  unint64_t v22 = CA::OGL::tex_image_count[*((unsigned char *)a2 + 14) & 0x7F];
LABEL_97:
  LOBYTE(v2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v22 < v21;
LABEL_35:
  buf[0] = v21;
  [@"fc_has_ycbcr_matrix" UTF8String];
  [v4 setConstantValue:buf type:53 withName:@"fc_has_ycbcr_matrix"];
  if ((*(_WORD *)((unsigned char *)a2 + 17) & 0x204) == 0)
  {
    uint64_t v25 = *((unsigned char *)a2 + 14) & 0x7F;
    if ((*(_WORD *)&CA::OGL::MetalContext::texture_function_info[8 * v25 - v25 + 5] & 0x80) == 0)
    {
      unint64_t v26 = CA::OGL::tex_image_count[v25];
      if (!v26)
      {
        BOOL v30 = 0;
        goto LABEL_41;
      }
      uint64_t v27 = *(unsigned int *)a2;
      unsigned int v28 = (v27 >> 19) & 0x1F;
      if (v28 != 11)
      {
        unsigned int v29 = BYTE3(v27) & 0x1F;
        if (v29 != 11)
        {
          unint64_t v74 = v27 | ((unint64_t)(*((unsigned __int16 *)a2 + 2) | (*((unsigned __int8 *)a2 + 6) << 16)) << 32);
          uint64_t v75 = (v74 >> 29) & 0x7FFFFFF;
          uint64_t v76 = (v74 >> 34) & 0x3FFFFF;
          uint64_t v77 = (v74 >> 39) & 0x1FFFF;
          uint64_t v78 = (v74 >> 44) & 0xFFF;
          uint64_t v79 = (unsigned int *)((char *)a2 + 7);
          unint64_t v80 = 1;
          BOOL v30 = 1;
          do
          {
            int v81 = v75 & 0x1F;
            int v82 = v76 & 0x1F;
            BOOL v83 = v81 == 11 || v82 == 11;
            int v84 = v77 & 0x1F;
            BOOL v85 = v83 || v84 == 11;
            int v86 = v78 & 0x1F;
            if (v85 || v86 == 12 || v84 == 12 || v82 == 12 || v81 == 12 || v29 == 12 || v86 == 11 || v28 == 12) {
              break;
            }
            BOOL v30 = v80 < v26;
            if (v26 == v80) {
              break;
            }
            uint64_t v94 = *v79;
            unsigned int v28 = (v94 >> 19) & 0x1F;
            if (v28 == 11) {
              break;
            }
            unint64_t v95 = v94 | ((unint64_t)(*((unsigned __int16 *)v79 + 2) | (*((unsigned __int8 *)v79 + 6) << 16)) << 32);
            uint64_t v78 = (v95 >> 44) & 0xFFF;
            uint64_t v77 = (v95 >> 39) & 0x1FFFF;
            uint64_t v76 = (v95 >> 34) & 0x3FFFFF;
            uint64_t v75 = (v95 >> 29) & 0x7FFFFFF;
            unsigned int v29 = BYTE3(v94) & 0x1F;
            uint64_t v79 = (unsigned int *)((char *)v79 + 7);
            ++v80;
          }
          while (v29 != 11);
          goto LABEL_41;
        }
      }
    }
  }
  BOOL v30 = 1;
LABEL_41:
  buf[0] = v30;
  [@"fc_has_gamma_luts" UTF8String];
  [v4 setConstantValue:buf type:53 withName:@"fc_has_gamma_luts"];
  if ((*(_WORD *)((unsigned char *)a2 + 17) & 4) != 0) {
    goto LABEL_48;
  }
  unint64_t v31 = CA::OGL::tex_image_count[*((unsigned char *)a2 + 14) & 0x7F];
  if (!CA::OGL::tex_image_count[*((unsigned char *)a2 + 14) & 0x7F]) {
    goto LABEL_49;
  }
  if ((CA::OGL::MetalContext::texture_filter_info[((unint64_t)*(unsigned int *)a2 >> 9) & 0xF] & 2) != 0)
  {
LABEL_48:
    LOBYTE(v3CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 1;
  }
  else
  {
    unint64_t v32 = 0;
    __int16 v33 = (unsigned int *)((char *)a2 + 7);
    while (v31 - 1 != v32)
    {
      unsigned int v34 = *v33;
      __int16 v33 = (unsigned int *)((char *)v33 + 7);
      ++v32;
      if ((CA::OGL::MetalContext::texture_filter_info[((unint64_t)v34 >> 9) & 0xF] & 2) != 0) {
        goto LABEL_99;
      }
    }
    unint64_t v32 = CA::OGL::tex_image_count[*((unsigned char *)a2 + 14) & 0x7F];
LABEL_99:
    LOBYTE(v3CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v32 < v31;
  }
LABEL_49:
  buf[0] = v31;
  [@"fc_has_asg_77_weights" UTF8String];
  [v4 setConstantValue:buf type:53 withName:@"fc_has_asg_77_weights"];
  buf[0] = (*(_WORD *)((unsigned char *)a2 + 17) & 0xC) != 0;
  [@"fc_has_noise_tex" UTF8String];
  [v4 setConstantValue:buf type:53 withName:@"fc_has_noise_tex"];
  if ((*(_WORD *)((unsigned char *)a2 + 17) & 4) != 0)
  {
LABEL_52:
    LOBYTE(v35) = 1;
    goto LABEL_53;
  }
  unint64_t v35 = CA::OGL::tex_image_count[*((unsigned char *)a2 + 14) & 0x7F];
  if (CA::OGL::tex_image_count[*((unsigned char *)a2 + 14) & 0x7F])
  {
    if (((*(unsigned int *)a2 | ((unint64_t)(*((unsigned __int16 *)a2 + 2) | (*((unsigned __int8 *)a2 + 6) << 16)) << 32)) & 0x1FFFFFFF80000) == 0)
    {
      unint64_t v70 = 0;
      uint64_t v71 = (char *)a2 + 7;
      while (v35 - 1 != v70)
      {
        uint64_t v72 = *((unsigned __int16 *)v71 + 2) | (v71[6] << 16);
        unsigned int v73 = *(_DWORD *)v71;
        v71 += 7;
        ++v70;
        if (((v73 | (unint64_t)(v72 << 32)) & 0x1FFFFFFF80000) != 0) {
          goto LABEL_102;
        }
      }
      unint64_t v70 = CA::OGL::tex_image_count[*((unsigned char *)a2 + 14) & 0x7F];
LABEL_102:
      LOBYTE(v35) = v70 < v35;
      goto LABEL_53;
    }
    goto LABEL_52;
  }
LABEL_53:
  buf[0] = v35;
  [@"fc_has_color_params" UTF8String];
  [v4 setConstantValue:buf type:53 withName:@"fc_has_color_params"];
  if ((*(_WORD *)((unsigned char *)a2 + 17) & 4) != 0) {
    LOBYTE(v36) = 1;
  }
  else {
    int v36 = (*(unsigned __int16 *)&CA::OGL::MetalContext::texture_function_info[8 * (*((unsigned char *)a2 + 14) & 0x7F)
  }
                                                                            - (*((unsigned char *)a2 + 14) & 0x7F)
                                                                            + 5] >> 9) & 1;
  buf[0] = v36;
  [@"fc_has_lut_tex" UTF8String];
  [v4 setConstantValue:buf type:53 withName:@"fc_has_lut_tex"];
  uint64_t v37 = 0;
  do
  {
    uint64_t v38 = objc_msgSend(NSString, "stringWithFormat:", @"fc_has_attachment_%d", v37);
    buf[0] = 0;
    [v38 UTF8String];
    [v4 setConstantValue:buf type:53 withName:v38];
    uint64_t v37 = (v37 + 1);
  }
  while (v37 != 3);
  if ((*(_WORD *)((unsigned char *)a2 + 17) & 4) == 0)
  {
    buf[0] = BYTE1(v109);
    [@"fc_texture_function" UTF8String];
    [v4 setConstantValue:buf type:49 withName:@"fc_texture_function"];
    buf[0] = BYTE2(v109);
    [@"fc_blend_function" UTF8String];
    [v4 setConstantValue:buf type:49 withName:@"fc_blend_function"];
    buf[0] = BYTE3(v109);
    [@"fc_destination_function" UTF8String];
    [v4 setConstantValue:buf type:49 withName:@"fc_destination_function"];
    buf[0] = BYTE4(v109);
    [@"fc_image_count" UTF8String];
    [v4 setConstantValue:buf type:49 withName:@"fc_image_count"];
    buf[0] = BYTE5(v109);
    [@"fc_dest_index" UTF8String];
    [v4 setConstantValue:buf type:49 withName:@"fc_dest_index"];
    buf[0] = BYTE6(v109);
    [@"fc_dest_count" UTF8String];
    [v4 setConstantValue:buf type:49 withName:@"fc_dest_count"];
    buf[0] = BYTE7(v109);
    [@"fc_noise_width" UTF8String];
    [v4 setConstantValue:buf type:49 withName:@"fc_noise_width"];
    buf[0] = BYTE9(v109);
    [@"fc_clamp_color" UTF8String];
    [v4 setConstantValue:buf type:53 withName:@"fc_clamp_color"];
    buf[0] = BYTE10(v109);
    [@"fc_extended_range" UTF8String];
    [v4 setConstantValue:buf type:53 withName:@"fc_extended_range"];
    buf[0] = BYTE11(v109);
    [@"fc_unbounded_range" UTF8String];
    [v4 setConstantValue:buf type:53 withName:@"fc_unbounded_range"];
    buf[0] = BYTE12(v109);
    [@"fc_debug_xr" UTF8String];
    [v4 setConstantValue:buf type:53 withName:@"fc_debug_xr"];
    buf[0] = BYTE13(v109);
    [@"fc_has_premultiply" UTF8String];
    [v4 setConstantValue:buf type:53 withName:@"fc_has_premultiply"];
    buf[0] = BYTE14(v109);
    [@"fc_has_hdr_scale" UTF8String];
    [v4 setConstantValue:buf type:53 withName:@"fc_has_hdr_scale"];
    buf[0] = HIBYTE(v109);
    [@"fc_has_edr_factor" UTF8String];
    [v4 setConstantValue:buf type:53 withName:@"fc_has_edr_factor"];
  }
  unint64_t v39 = 0;
  char v40 = 1;
  do
  {
    char v97 = v40;
    if ((*(_WORD *)((unsigned char *)a2 + 17) & 4) == 0)
    {
      uint64_t v41 = objc_msgSend(NSString, "stringWithFormat:", @"fc_image_function%d", v39);
      buf[0] = __str[16 * v39];
      [v41 UTF8String];
      [v4 setConstantValue:buf type:49 withName:v41];
      size_t v42 = objc_msgSend(NSString, "stringWithFormat:", @"fc_coord_function%d", v39);
      buf[0] = __str[16 * v39 + 1];
      [v42 UTF8String];
      [v4 setConstantValue:buf type:49 withName:v42];
      uint64_t v43 = objc_msgSend(NSString, "stringWithFormat:", @"fc_plane_count%d", v39);
      buf[0] = __str[16 * v39 + 12];
      [v43 UTF8String];
      [v4 setConstantValue:buf type:49 withName:v43];
      uint64_t v44 = objc_msgSend(NSString, "stringWithFormat:", @"fc_texcoord_count%d", v39);
      buf[0] = __str[16 * v39 + 13];
      [v44 UTF8String];
      [v4 setConstantValue:buf type:49 withName:v44];
      int32x4_t v45 = objc_msgSend(NSString, "stringWithFormat:", @"fc_memoryless_index%d", v39);
      buf[0] = __str[16 * v39 + 14] + 1;
      [v45 UTF8String];
      [v4 setConstantValue:buf type:49 withName:v45];
      float v46 = objc_msgSend(NSString, "stringWithFormat:", @"fc_filter%d", v39);
      buf[0] = __str[16 * v39 + 2];
      [v46 UTF8String];
      [v4 setConstantValue:buf type:49 withName:v46];
      float v47 = objc_msgSend(NSString, "stringWithFormat:", @"fc_color_inputs%d", v39);
      buf[0] = __str[16 * v39 + 10];
      [v47 UTF8String];
      [v4 setConstantValue:buf type:49 withName:v47];
      uint64_t v48 = objc_msgSend(NSString, "stringWithFormat:", @"fc_color_opcodes%d", v39);
      *(_DWORD *)long long buf = *(_DWORD *)&__str[16 * v39 + 4];
      [v48 UTF8String];
      [v4 setConstantValue:buf type:52 withName:v48];
      uint64_t v49 = objc_msgSend(NSString, "stringWithFormat:", @"fc_color_opcodes_ext%d", v39);
      *(_WORD *)long long buf = *(_WORD *)&__str[16 * v39 + 8];
      [v49 UTF8String];
      [v4 setConstantValue:buf type:50 withName:v49];
      float v50 = objc_msgSend(NSString, "stringWithFormat:", @"fc_color_opaque%d", v39);
      buf[0] = __str[16 * v39 + 11];
      [v50 UTF8String];
      [v4 setConstantValue:buf type:53 withName:v50];
    }
    float v51 = objc_msgSend(NSString, "stringWithFormat:", @"fc_has_color_trc%d", v39);
    int8x16_t v52 = v51;
    if ((*(_WORD *)((unsigned char *)a2 + 17) & 4) != 0)
    {
      BOOL v57 = 1;
    }
    else
    {
      unint64_t v53 = *(unsigned int *)((char *)a2 + 8 * v39 - v39) | ((unint64_t)(*(unsigned __int16 *)((char *)a2 + 8 * v39 - v39 + 4) | (*((unsigned __int8 *)a2 + 8 * v39 - v39 + 6) << 16)) << 32);
      int8x16_t v54 = (int8x16_t)vdupq_n_s64(v53);
      uint64_t v55 = v53 & 0xF8000000000;
      char v56 = vmaxv_u16((uint16x4_t)vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_s64((int64x2_t)vandq_s8(v54, (int8x16_t)xmmword_1849982C0), (int64x2_t)xmmword_1849982E0), (int32x4_t)vceqq_s64((int64x2_t)vandq_s8(v54, (int8x16_t)xmmword_1849982D0), (int64x2_t)xmmword_1849982F0))));
      BOOL v57 = (v53 & 0x1F00000000000) == 0x700000000000;
      if (v55 == 0x38000000000) {
        BOOL v57 = 1;
      }
      if (v56) {
        BOOL v57 = 1;
      }
    }
    buf[0] = v57;
    [v51 UTF8String];
    [v4 setConstantValue:buf type:53 withName:v52];
    float v58 = objc_msgSend(NSString, "stringWithFormat:", @"fc_has_color_cube%d", v39);
    float v59 = v58;
    if ((*(_WORD *)((unsigned char *)a2 + 17) & 4) != 0
      || (v60 = (unsigned int *)((char *)a2 + 8 * v39 - v39), uint64_t v61 = *v60, ((v61 >> 19) & 0x1F) - 8 < 3)
      || (BYTE3(v61) & 0x1F) - 8 < 3u
      || (unint64_t v62 = v61 | ((unint64_t)(*((unsigned __int16 *)v60 + 2) | (*((unsigned __int8 *)v60 + 6) << 16)) << 32),
          ((v62 >> 29) & 0x1F) - 8 < 3)
      || ((v62 >> 34) & 0x1F) - 8 < 3
      || ((v62 >> 39) & 0x1F) - 8 < 3
      || ((v62 >> 44) & 0x1F) - 8 < 3)
    {
      BOOL v63 = 1;
    }
    else
    {
      int8x16_t v69 = (int8x16_t)vdupq_n_s64(v62);
      BOOL v63 = 1;
      if ((vmaxv_u16((uint16x4_t)vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_s64((int64x2_t)vandq_s8(v69, (int8x16_t)xmmword_1849982C0), (int64x2_t)xmmword_184998300), (int32x4_t)vceqq_s64((int64x2_t)vandq_s8(v69, (int8x16_t)xmmword_1849982D0), (int64x2_t)xmmword_184998310)))) & 1) == 0&& (v62 & 0xF8000000000) != 0x98000000000)
      {
        BOOL v63 = (v62 & 0x1F00000000000) == 0x1300000000000;
      }
    }
    buf[0] = v63;
    [v58 UTF8String];
    [v4 setConstantValue:buf type:53 withName:v59];
    unsigned int v64 = 0;
    double v65 = (_DWORD *)((char *)a2 + 8 * v39 - v39);
    do
    {
      float64x2_t v66 = objc_msgSend(NSString, "stringWithFormat:", @"fc_has_image_%d%c", v39, v64 + 65);
      double v67 = v66;
      if ((*(_WORD *)((unsigned char *)a2 + 17) & 4) != 0)
      {
        LOBYTE(v68) = 1;
      }
      else if (v39 >= CA::OGL::tex_image_count[*((unsigned char *)a2 + 14) & 0x7F])
      {
        LOBYTE(v68) = 0;
      }
      else
      {
        unint64_t v68 = ((unint64_t)(*v65 << 16) >> 31) & 1;
        if (v64 >= CA::OGL::image_plane_count[*v65 & 0x3FLL]) {
          LOBYTE(v68) = 0;
        }
      }
      buf[0] = v68;
      [v66 UTF8String];
      [v4 setConstantValue:buf type:53 withName:v67];
      ++v64;
    }
    while (v64 != 3);
    char v40 = 0;
    unint64_t v39 = 1;
  }
  while ((v97 & 1) != 0);
LABEL_3:
  if (v4) {
    uint64_t v5 = 7;
  }
  else {
    uint64_t v5 = 2;
  }
  for (char i = 1; ; char i = 0)
  {
    id v102 = 0;
    shader_functiouint64_t n = CA::OGL::MetalContext::load_shader_function((uint64_t)this, this[417], v100, v101, v4, a3, (uint64_t)&v102);
    if (shader_function) {
      break;
    }
    uint64_t v8 = reason_messages[v5];
    bzero(__str, 0x800uLL);
    __int16 v9 = (const char *)[(__CFString *)v100 UTF8String];
    uint64_t v10 = (const char *)[v101 UTF8String];
    snprintf(__str, 0x800uLL, "function=%s spec=%s\n%s", v9, v10, (const char *)objc_msgSend((id)objc_msgSend(v102, "localizedDescription"), "UTF8String"));
    char v111 = 0;
    BOOL v11 = x_log_hook_p();
    if ((i & 1) == 0)
    {
      if (v11)
      {
        x_log_();
      }
      else
      {
        uint64_t v96 = x_log_category_ogl_metal;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136315394;
          uint64_t v104 = v8;
          __int16 v105 = 2080;
          double v106 = __str;
          _os_log_impl(&dword_184668000, v96, OS_LOG_TYPE_ERROR, "%s: %s\n", buf, 0x16u);
        }
      }
      strlen(__str);
      abort_with_payload();
      __break(1u);
    }
    if (v11)
    {
      x_log_();
    }
    else
    {
      char v12 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315394;
        uint64_t v104 = v8;
        __int16 v105 = 2080;
        double v106 = __str;
        _os_log_impl(&dword_184668000, v12, OS_LOG_TYPE_FAULT, "%s: %s\n", buf, 0x16u);
      }
    }
  }
  [shader_function setLabel:objc_msgSend(@"com.apple.coreanimation.frag.", "stringByAppendingString:", v101)];

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t result = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
  if (result)
  {
    *uint64_t result = shader_function;
    result[1] = 0;
  }
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::get_config(uint64_t this, int *a2)
{
  uint64_t v2 = 0;
  *(_DWORD *)(this + 48) = 0;
  v3.i64[1] = 0;
  *(_OWORD *)(this + 16) = 0u;
  *(_OWORD *)(this + 32) = 0u;
  *(_OWORD *)this = 0u;
  do
  {
    uint64_t v4 = this + v2;
    *(_WORD *)uint64_t v4 = 0;
    *(unsigned char *)(v4 + 2) = 0;
    *(void *)(v4 + 4) = 0;
    *(_WORD *)(v4 + 12) = 0;
    v2 += 16;
    *(unsigned char *)(v4 + 14) = -1;
  }
  while (v2 != 32);
  unsigned __int8 v5 = *((unsigned char *)a2 + 16);
  *(unsigned char *)(this + 32) = (v5 >> 3) & 3;
  uint64_t v6 = *((unsigned char *)a2 + 14) & 0x7F;
  *(unsigned char *)(this + 33) = v6;
  int v7 = *((unsigned char *)a2 + 15) & 0x3F;
  *(unsigned char *)(this + 34) = v7;
  char v8 = v5 & 7;
  unint64_t v9 = CA::OGL::tex_image_count[v6];
  *(unsigned char *)(this + 35) = v8;
  *(unsigned char *)(this + 36) = v9;
  unsigned int v10 = *(unsigned __int16 *)((char *)a2 + 17);
  *(unsigned char *)(this + 37) = v10 & 3;
  if (v7 != 58 || (*(_WORD *)&CA::OGL::MetalContext::texture_function_info[8 * v6 - v6 + 5] & 2) != 0) {
    goto LABEL_11;
  }
  if (!v9)
  {
    BOOL v14 = 0;
    goto LABEL_12;
  }
  if ((CA::OGL::MetalContext::image_function_info[*a2 & 0x3F] & 8) != 0)
  {
LABEL_11:
    BOOL v14 = 1;
    goto LABEL_12;
  }
  unint64_t v11 = 0;
  char v12 = (int *)((char *)a2 + 7);
  while (v9 - 1 != v11)
  {
    int v13 = *v12;
    char v12 = (int *)((char *)v12 + 7);
    ++v11;
    if ((CA::OGL::MetalContext::image_function_info[v13 & 0x3F] & 8) != 0) {
      goto LABEL_18;
    }
  }
  unint64_t v11 = v9;
LABEL_18:
  BOOL v14 = v11 < v9;
LABEL_12:
  *(unsigned char *)(this + 38) = v14;
  *(unsigned char *)(this + 39) = (4 * v10) & 0x20;
  *(unsigned char *)(this + 4CA::Context::unref(this[1], 0) = byte_18499CCAF[v6];
  *(unsigned char *)(this + 4CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = (v10 & 0x1000) != 0;
  *(unsigned char *)(this + 42) = (v10 & 0x40) != 0;
  *(unsigned char *)(this + 43) = (v10 & 0x80) != 0;
  v3.i64[0] = *(void *)&vshl_u16((uint16x4_t)vdup_n_s16(v10), (uint16x4_t)0xFFF7FFF6FFF8FFF3) & 0xFF01FF01FF01FF01;
  *(_DWORD *)(this + 44) = vmovn_s16(v3).u32[0];
  *(unsigned char *)(this + 48) = 0;
  if (v9)
  {
    unint64_t v15 = 0;
    uint64_t v16 = (unsigned char *)(this + 14);
    do
    {
      int v17 = *((unsigned __int8 *)a2 + 6);
      uint64_t v18 = *((unsigned __int16 *)a2 + 2) | (v17 << 16);
      unsigned int v19 = *a2;
      a2 = (int *)((char *)a2 + 7);
      unint64_t v20 = v19 | (unint64_t)(v18 << 32);
      uint64x2_t v21 = (uint64x2_t)vdupq_n_s64(v20);
      int16x8_t v22 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v21, (uint64x2_t)xmmword_184998330), (int32x4_t)vshlq_u64(v21, (uint64x2_t)xmmword_184998320));
      *(int8x8_t *)v22.i8 = vand_s8((int8x8_t)vmovn_s32((int32x4_t)v22), (int8x8_t)0x1F001F001F001FLL);
      *(int8x8_t *)v21.i8 = vand_s8((int8x8_t)vmovn_s64((int64x2_t)vshlq_u64(v21, (uint64x2_t)xmmword_184998340)), (int8x8_t)0x1F0000001FLL);
      unsigned __int8 v23 = CA::OGL::image_plane_count[v20 & 0x3F];
      char v24 = byte_18499EBD8[v20 & 0x3F];
      *(v16 - 14) = v20 & 0x3F;
      *(v16 - 13) = (v19 >> 6) & 7;
      *(v16 - 12) = (v19 >> 9) & 0xF;
      *(_DWORD *)(v16 - 1CA::Context::unref(this[1], 0) = vmovn_s16(v22).u32[0];
      *(v16 - 6) = v21.i8[0];
      *(v16 - 5) = v21.i8[4];
      *(v16 - 4) = BYTE2(v19) & 7;
      *(v16 - 3) = (v17 & 2) != 0;
      *(v16 - 2) = v23;
      *(v16 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v24;
      *uint64_t v16 = (unint64_t)((uint64_t)((unint64_t)v19 << 48) >> 8) >> 53;
      v16 += 16;
      ++v15;
    }
    while (v15 < *(unsigned __int8 *)(this + 36));
  }
  return this;
}

void *CA::OGL::MetalContext::load_shader_function(uint64_t a1, void *a2, void *a3, void *a4, void *a5, int a6, uint64_t a7)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (byte_1EB2ACBEC || (*(unsigned char *)(a1 + 434) & 0x10) != 0)
  {
    BOOL v14 = x_log_hook_p();
    if (a5)
    {
      if (v14)
      {
        uint64_t v15 = [a3 UTF8String];
        uint64_t v29 = [a4 UTF8String];
        uint64_t v30 = objc_msgSend((id)objc_msgSend(a5, "description"), "UTF8String");
        uint64_t v28 = v15;
LABEL_8:
        x_log_();
        goto LABEL_14;
      }
      uint64_t v16 = x_log_category_ogl_metal;
      if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
      *(_DWORD *)long long buf = 136315650;
      uint64_t v33 = [a3 UTF8String];
      __int16 v34 = 2080;
      uint64_t v35 = [a4 UTF8String];
      __int16 v36 = 2080;
      uint64_t v37 = objc_msgSend((id)objc_msgSend(a5, "description"), "UTF8String");
      int v17 = "Specializing shader function %s for %s with constant values %s\n";
      uint64_t v18 = v16;
      uint32_t v19 = 32;
    }
    else
    {
      if (v14)
      {
        uint64_t v28 = [a3 UTF8String];
        uint64_t v29 = [a4 UTF8String];
        goto LABEL_8;
      }
      uint64_t v20 = x_log_category_ogl_metal;
      if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v33 = [a3 UTF8String];
      __int16 v34 = 2080;
      uint64_t v35 = [a4 UTF8String];
      int v17 = "Loading shader function %s for %s\n";
      uint64_t v18 = v20;
      uint32_t v19 = 22;
    }
    _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_DEFAULT, v17, buf, v19);
  }
LABEL_14:
  os_signpost_id_t v21 = os_signpost_id_generate((os_log_t)x_log_category_ogl_metal);
  if (v21 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    int16x8_t v22 = x_log_category_ogl_metal;
    if (os_signpost_enabled((os_log_t)x_log_category_ogl_metal))
    {
      *(_DWORD *)long long buf = 138543874;
      uint64_t v33 = (uint64_t)a3;
      __int16 v34 = 2114;
      uint64_t v35 = (uint64_t)a4;
      __int16 v36 = 1026;
      LODWORD(v37) = a5 != 0;
      _os_signpost_emit_with_name_impl(&dword_184668000, v22, OS_SIGNPOST_INTERVAL_BEGIN, v21, "CompileShader", "function=%{public, name=function}@ spec=%{public, name=spec}@ specialized=%{public, name=specialized}u", buf, 0x1Cu);
    }
  }
  unsigned __int8 v23 = objc_msgSend(MEMORY[0x1E4F35238], "functionDescriptor", v28, v29, v30);
  [v23 setName:a3];
  if (a5)
  {
    [v23 setSpecializedName:a4];
    [v23 setConstantValues:a5];
  }
  if (a6 && !byte_1EB2ACC28 && (*(unsigned char *)(a1 + 434) & 0x30) == 0 && *(void *)(a1 + 3344))
  {
    uint64_t v31 = *(void *)(a1 + 3344);
    objc_msgSend(v23, "setBinaryArchives:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", &v31, 1));
  }
  char v24 = (void *)[a2 newFunctionWithDescriptor:v23 error:a7];
  if (a5) {
    uint64_t v25 = a4;
  }
  else {
    uint64_t v25 = a3;
  }
  [v24 setLabel:objc_msgSend(@"com.apple.coreanimation.", "stringByAppendingString:", v25)];
  if (v21 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    unint64_t v26 = x_log_category_ogl_metal;
    if (os_signpost_enabled((os_log_t)x_log_category_ogl_metal))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl(&dword_184668000, v26, OS_SIGNPOST_INTERVAL_END, v21, "CompileShader", (const char *)&unk_1849E4FC6, buf, 2u);
    }
  }
  return v24;
}

uint64_t CA::OGL::MetalContext::VertexShader::Spec::encode_segment(CA::OGL::MetalContext::VertexShader::Spec *this)
{
  *(void *)&v14[13] = *MEMORY[0x1E4F143B8];
  *(void *)&v14[5] = 0;
  *(void *)BOOL v14 = 0;
  char v13 = 86;
  unsigned int v2 = *((_WORD *)this + 1) & 0x1F;
  if (v2 > 0x12) {
    snprintf(v14, 3uLL, "%02d", v2);
  }
  else {
    *(_WORD *)BOOL v14 = *(_WORD *)CA::OGL::MetalContext::VertexShaderType_codes[*((_WORD *)this + 1) & 0x1F];
  }
  uint64_t v3 = *(unsigned char *)this & 3;
  uint64_t v4 = *((unsigned char *)this + 1) & 3;
  if (v3 | v4)
  {
    void v14[2] = 85;
    v14[3] = *CA::OGL::MetalContext::int_codes[v3];
    v14[4] = *CA::OGL::MetalContext::int_codes[v4];
    unsigned __int8 v5 = &v14[5];
  }
  else
  {
    unsigned __int8 v5 = &v14[2];
  }
  unsigned int v6 = *((unsigned __int16 *)this + 1);
  if ((v6 & 0x60) != 0)
  {
    *unsigned __int8 v5 = 76;
    int v7 = v5 + 1;
    int v8 = (v6 >> 5) & 3;
    if (v8 == 3) {
      snprintf(v7, 3uLL, "%02d", 3);
    }
    else {
      *(_WORD *)int v7 = *(_WORD *)CA::OGL::MetalContext::VertexLayout_codes[v8];
    }
    v5 += 3;
  }
  *unsigned __int8 v5 = 0;
  unint64_t v9 = v5 + 1;
  __int16 v10 = *((_WORD *)this + 1);
  if ((v10 & 0x80) != 0)
  {
    *(_WORD *)unsigned __int8 v5 = 26456;
    unint64_t v9 = v5 + 2;
    __int16 v10 = *((_WORD *)this + 1);
    int v11 = 88;
    if ((v10 & 0x100) == 0) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  int v11 = 0;
  if ((*((_WORD *)this + 1) & 0x100) != 0)
  {
LABEL_16:
    int v11 = 88;
    *unsigned __int8 v5 = 88;
    *v9++ = 104;
    __int16 v10 = *((_WORD *)this + 1);
  }
LABEL_17:
  if ((v10 & 0x200) != 0)
  {
    *unsigned __int8 v5 = 88;
    *v9++ = 98;
    int v11 = *v5;
  }
  if (!v11) {
    unint64_t v9 = v5;
  }
  *unint64_t v9 = 0;
  return [NSString stringWithUTF8String:&v13];
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_name(CA::OGL::MetalContext::FragmentShader::Spec *this, const char *a2)
{
  v6[1] = *(unsigned char **)MEMORY[0x1E4F143B8];
  v6[0] = a2;
  uint64_t result = CA::OGL::MetalContext::decode_segment(v6, (uint64_t)this, byte_1ED033318, 0x13u);
  if (CA::OGL::tex_image_count[*((unsigned char *)this + 14) & 0x7F])
  {
    unint64_t v4 = 0;
    unsigned __int8 v5 = this;
    do
    {
      uint64_t result = CA::OGL::MetalContext::decode_segment(v6, (uint64_t)v5, byte_1ED033878, 8u);
      ++v4;
      unsigned __int8 v5 = (CA::OGL::MetalContext::FragmentShader::Spec *)((char *)v5 + 7);
    }
    while (v4 < CA::OGL::tex_image_count[*((unsigned char *)this + 14) & 0x7F]);
  }
  return result;
}

void CA::Render::BackdropState::~BackdropState(CA::Render::BackdropState *this, const CA::Render::Object *a2)
{
  CA::Render::BackdropState::~BackdropState(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  CA::Render::BackdropState **v3;
  void *v4;
  void *v5;
  atomic_uint *v6;
  atomic_uint *v7;

  *(void *)this = &unk_1ED02D930;
  if (*((unsigned char *)this + 13))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::BackdropState::_list_lock);
    uint64_t v3 = (CA::Render::BackdropState **)CA::Render::BackdropState::_list;
    if (CA::Render::BackdropState::_list != (_UNKNOWN *)qword_1E8F83DD0)
    {
      while (*v3 != this)
      {
        if (++v3 == (CA::Render::BackdropState **)qword_1E8F83DD0)
        {
          uint64_t v3 = (CA::Render::BackdropState **)qword_1E8F83DD0;
          break;
        }
      }
    }
    *uint64_t v3 = *(CA::Render::BackdropState **)(qword_1E8F83DD0 - 8);
    if (qword_1E8F83DD0 <= (unint64_t)CA::Render::BackdropState::_list) {
      __assert_rtn("pop_back", "x-small-vector.h", 410, "_end > _begin && \"pop_back on empty container\"");
    }
    qword_1E8F83DD0 -= 8;
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::BackdropState::_list_lock);
  }
  unint64_t v4 = (void *)*((void *)this + 11);
  if (v4)
  {
    do
    {
      unsigned __int8 v5 = (void *)*v4;
      unsigned int v6 = (atomic_uint *)v4[4];
      if (atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
      }
      free(v4);
      unint64_t v4 = v5;
    }
    while (v5);
  }
  int v7 = (atomic_uint *)*((void *)this + 5);
  if (v7 && atomic_fetch_add(v7 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v7 + 16))(v7);
  }
  --dword_1EB2ADDD8;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

void CA::Render::BackdropGroup::~BackdropGroup(CA::Render::BackdropGroup *this, const CA::Render::Object *a2)
{
  CA::Render::BackdropGroup::~BackdropGroup(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  CA::Render::BackdropGroup **v3;
  uint64_t v4;
  CA::Shape *v5;
  CA::Shape *v6;
  CA::Shape *v7;
  CA::Shape *v8;
  CA::Shape *v9;
  atomic_uint *v10;
  void *v11;
  atomic_uint *v12;
  atomic_uint *v13;

  *(void *)this = &unk_1ED02D7B0;
  if (*((unsigned char *)this + 13))
  {
    os_unfair_lock_lock(&CA::Render::BackdropGroup::_list_lock);
    uint64_t v3 = (CA::Render::BackdropGroup **)CA::Render::BackdropGroup::_list;
    if (CA::Render::BackdropGroup::_list != (_UNKNOWN *)qword_1E8F83D90)
    {
      while (*v3 != this)
      {
        if (++v3 == (CA::Render::BackdropGroup **)qword_1E8F83D90)
        {
          uint64_t v3 = (CA::Render::BackdropGroup **)qword_1E8F83D90;
          break;
        }
      }
    }
    *uint64_t v3 = *(CA::Render::BackdropGroup **)(qword_1E8F83D90 - 8);
    if (qword_1E8F83D90 <= (unint64_t)CA::Render::BackdropGroup::_list) {
      __assert_rtn("pop_back", "x-small-vector.h", 410, "_end > _begin && \"pop_back on empty container\"");
    }
    qword_1E8F83D90 -= 8;
    os_unfair_lock_unlock(&CA::Render::BackdropGroup::_list_lock);
  }
  unint64_t v4 = *((void *)this + 6);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  unsigned __int8 v5 = (CA::Shape *)*((void *)this + 60);
  if (v5) {
    CA::Shape::unref(v5);
  }
  unsigned int v6 = (CA::Shape *)*((void *)this + 65);
  if (v6) {
    CA::Shape::unref(v6);
  }
  int v7 = (CA::Shape *)*((void *)this + 66);
  if (v7) {
    CA::Shape::unref(v7);
  }
  int v8 = (CA::Shape *)*((void *)this + 67);
  if (v8) {
    CA::Shape::unref(v8);
  }
  unint64_t v9 = (CA::Shape *)*((void *)this + 68);
  if (v9) {
    CA::Shape::unref(v9);
  }
  __int16 v10 = (atomic_uint *)*((void *)this + 70);
  if (v10)
  {
    if (atomic_fetch_add(v10 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v10 + 16))(v10);
    }
    *((void *)this + 7CA::Context::unref(this[1], 0) = 0;
  }
  int v11 = (void *)*((void *)this + 8);
  if (v11 != *((void **)this + 10)) {
    free(v11);
  }
  char v12 = (atomic_uint *)*((void *)this + 4);
  if (v12 && atomic_fetch_add(v12 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v12 + 16))(v12);
  }
  char v13 = (atomic_uint *)*((void *)this + 2);
  if (v13 && atomic_fetch_add(v13 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v13 + 16))(v13);
  }
  --dword_1EB2ADDD0;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

void CA::OGL::BackdropBuffer::~BackdropBuffer(CA::OGL::BackdropBuffer *this)
{
  CA::OGL::BackdropBuffer::~BackdropBuffer(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)this = &unk_1ED02B630;
  unsigned int v2 = *((void *)this + 4);
  if (v2) {
    CA::OGL::Context::release_surface_async(*((void *)this + 1), v2);
  }
  uint64_t v3 = *((void *)this + 5);
  if (v3) {
    CA::OGL::Context::release_surface_async(*((void *)this + 1), v3);
  }
}

void CA::OGL::Context::release_surface_async(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (os_unfair_lock_s *)(a1 + 304);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 304));
  uint64_t v5 = *(void *)(a1 + 344);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  int v7 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
  *int v7 = a2;
  v7[1] = v5;
  *(void *)(a1 + 344) = v7;

  os_unfair_lock_unlock(v4);
}

double get_transform@<D0>(uint64_t a1@<X8>)
{
  double result = (double)*(unint64_t *)(CGContextDelegateGetInfo() + 8);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0x3FF0000000000000;
  *(_OWORD *)(a1 + 24) = xmmword_184997E00;
  *(double *)(a1 + 4CA::Context::unref(this[1], 0) = result;
  return result;
}

uint64_t CA::Render::Handle::retain_context(CA::Render::Handle *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Handle::_handle_lock);
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    uint64_t v3 = (atomic_uint *)(v2 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
    {
      uint64_t v2 = 0;
      atomic_fetch_add(v3, 0xFFFFFFFF);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Handle::_handle_lock);
  return v2;
}

uint64_t CA::Render::TransitionAnimation::validate(CA::Render::TransitionAnimation *this, CA::Render::Layer *a2, const CA::Render::TransitionSubclass *a3)
{
  if (a2)
  {
    unint64_t v4 = a2;
    int v5 = *((_DWORD *)a2 + 3);
    if ((v5 & 0x100) != 0) {
      return 0;
    }
    if (!*((void *)this + 16))
    {
      *((_DWORD *)a2 + 3) = v5 & 0xFFFFE7FF | 0x1000;
      unsigned int v6 = (atomic_uint *)*((void *)this + 16);
      if (v6 != (atomic_uint *)a2)
      {
        if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
        }
        int v7 = (atomic_uint *)((char *)v4 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v4 + 2, 1u))
        {
          unint64_t v4 = 0;
          atomic_fetch_add(v7, 0xFFFFFFFF);
        }
        *((void *)this + 16) = v4;
      }
    }
  }
  int v8 = *((_DWORD *)this + 3);
  if ((v8 & 0x1000000) != 0)
  {
    *((_DWORD *)this + 34) = atomic_fetch_add(CA::Render::next_cache_id(void)::cache_id, 1u) + 1;
    int v8 = *((_DWORD *)this + 3);
  }
  if ((v8 & 0x2000000) != 0) {
    *((_DWORD *)this + 35) = atomic_fetch_add(CA::Render::next_cache_id(void)::cache_id, 1u) + 1;
  }
  unint64_t v9 = (CA::Render::Transition *)*((unsigned int *)this + 23);
  if (v9 == 225)
  {
    uint64_t v10 = *((void *)this + 14);
    if (v10) {
      unint64_t v9 = (CA::Render::Transition *)*(unsigned int *)(v10 + 24);
    }
    else {
      unint64_t v9 = 0;
    }
  }
  char v12 = CA::Render::Transition::lookup_transition(v9, a2, a3);
  if (v12)
  {
    if (((unsigned int (*)(uint64_t (***)(CA::Render::BuiltinTransition *__hidden, const CA::Render::TransitionAnimation *, CA::Render::Layer *, unsigned int, float)))(*v12)[1])(v12)) {
      *((_DWORD *)this + 3) |= 0x1000u;
    }
  }
  return 1;
}

uint64_t (***CA::Render::Transition::subclass(CA::Render::Transition *this, unsigned int a2, const CA::Render::TransitionSubclass *a3))(CA::Render::BuiltinTransition *__hidden this, const CA::Render::TransitionAnimation *, CA::Render::Layer *, unsigned int, float)
{
  double result = (uint64_t (***)(CA::Render::BuiltinTransition *__hidden, const CA::Render::TransitionAnimation *, CA::Render::Layer *, unsigned int, float))*((void *)this + 7);
  if (!result)
  {
    int v5 = (CA::Render::Transition *)*((unsigned int *)this + 4);
    if (v5 == 225)
    {
      uint64_t v6 = *((void *)this + 4);
      if (v6) {
        int v5 = (CA::Render::Transition *)*(unsigned int *)(v6 + 24);
      }
      else {
        int v5 = 0;
      }
    }
    double result = CA::Render::Transition::lookup_transition(v5, a2, a3);
    *((void *)this + 7) = result;
  }
  return result;
}

uint64_t (***CA::Render::Transition::lookup_transition(CA::Render::Transition *this, unsigned int a2, const CA::Render::TransitionSubclass *a3))(CA::Render::BuiltinTransition *__hidden this, const CA::Render::TransitionAnimation *, CA::Render::Layer *, unsigned int, float)
{
  unsigned int v3 = this;
  double result = &CA::Render::Transition::lookup_transition::builtin_transition;
  if (v3 != 393 && v3 != 452 && v3 != 475)
  {
    if (!CA::Render::transition_table)
    {
      {
        CA::OGL::cube_transition_init(void)::aligned_cube = (uint64_t)&unk_1ED02B3A0;
        byte_1E8F86700 = 1;
      }
      {
        CA::OGL::cube_transition_init(void)::unaligned_cube = (uint64_t)&unk_1ED02B3A0;
        byte_1E8F86718 = 0;
      }
      CA::Render::add_transition((CA::Render *)0x98, (uint64_t)&CA::OGL::cube_transition_init(void)::unaligned_cube, a3);
      CA::Render::add_transition((CA::Render *)6, (uint64_t)&CA::OGL::cube_transition_init(void)::aligned_cube, v5);
      {
        CA::OGL::flip_transition_init(void)::aligned_flip = (uint64_t)&unk_1ED02B3E8;
        byte_1E8F86728 = 1;
      }
      {
        {
          CA::OGL::flip_transition_init(void)::unaligned_flip = (uint64_t)&unk_1ED02B3E8;
          byte_1E8F86740 = 0;
        }
      }
      CA::Render::add_transition((CA::Render *)0xE3, (uint64_t)&CA::OGL::flip_transition_init(void)::unaligned_flip, v6);
      CA::Render::add_transition((CA::Render *)7, (uint64_t)&CA::OGL::flip_transition_init(void)::aligned_flip, v7);
      int v8 = (CA::Render *)CAInternAtomWithCString("oglFlip");
      CA::Render::add_transition(v8, (uint64_t)&CA::OGL::flip_transition_init(void)::aligned_flip, v9);
      operator new();
    }
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::transition_lock);
    uint64_t v10 = x_hash_table_lookup(CA::Render::transition_table, v3, 0);
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::transition_lock);
    return (uint64_t (***)(CA::Render::BuiltinTransition *__hidden, const CA::Render::TransitionAnimation *, CA::Render::Layer *, unsigned int, float))v10;
  }
  return result;
}

void CA::Render::add_transition(CA::Render *this, uint64_t a2, const CA::Render::TransitionSubclass *a3)
{
  unsigned int v4 = this;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::transition_lock);
  int v5 = (int *)CA::Render::transition_table;
  if (!CA::Render::transition_table)
  {
    int v5 = (int *)x_hash_table_new_(0, 0, 0, 0, 0, 0);
    CA::Render::transition_table = (uint64_t)v5;
  }
  hash_table_modify(v5, v4, a2, 0);

  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::transition_lock);
}

void ___ZN2CA6Render16AsynchronousItemD2Ev_block_invoke_2(uint64_t a1)
{
}

void ___ZN2CA3OGL22AsynchronousDispatcher15unschedule_itemEPNS0_16AsynchronousItemE_block_invoke(uint64_t a1)
{
}

unint64_t ___ZN2CA3OGL22AsynchronousDispatcher13schedule_itemEPNS0_16AsynchronousItemE_block_invoke(uint64_t a1)
{
  return CA::OGL::AsynchronousDispatcher::start_timer(*(void *)(a1 + 32));
}

uint64_t CAObject_resolveInstanceMethod(objc_class *a1, const void *a2)
{
  uint64_t result = classDescription(a1);
  if (result)
  {
    unsigned int v4 = (void *)result;
    while (1)
    {
      CFDictionaryRef v5 = (const __CFDictionary *)v4[14];
      if (v5)
      {
        Boolean Value = CFDictionaryGetValue(v5, a2);
        if (Value) {
          break;
        }
      }
      unsigned int v4 = (void *)*v4;
      if (!v4) {
        return 0;
      }
    }
    int v7 = Value;
    int v8 = (void *)v4[1];
    unint64_t v9 = (const void *)Value[1];
    if (v9 == a2) {
      uint64_t v10 = (void (*)(void))objc_msgSend(v8, "CA_setterForProperty:", Value);
    }
    else {
      uint64_t v10 = (void (*)(void))objc_msgSend(v8, "CA_getterForProperty:", Value);
    }
    if (!v10) {
      return 0;
    }
    class_addMethod((Class)v8, (SEL)a2, v10, (&method_encodings[2 * *((unsigned __int16 *)v7 + 2)])[v9 != a2]);
    return 1;
  }
  return result;
}

IMP cons_CALayer_kCAValueBool(int a1, int a2)
{
  void block[5] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v2 = block;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    unsigned int v3 = &__block_descriptor_36_e8_B16__0_8l;
    unsigned int v4 = ___ZL25cons_CALayer_kCAValueBooljb_block_invoke;
  }
  else
  {
    uint64_t v2 = v6;
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    unsigned int v3 = &__block_descriptor_36_e11_v20__0_8B16l;
    unsigned int v4 = ___ZL25cons_CALayer_kCAValueBooljb_block_invoke_2;
  }
  v2[2] = v4;
  v2[3] = v3;
  *((_DWORD *)v2 + 8) = a1;
  return imp_implementationWithBlock(v2);
}

IMP cons_CALayer_kCAValueCopiedPointer(int a1, int a2)
{
  void block[5] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v2 = block;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    unsigned int v3 = &__block_descriptor_36_e10_r_v16__0_8l;
    unsigned int v4 = ___ZL34cons_CALayer_kCAValueCopiedPointerjb_block_invoke;
  }
  else
  {
    uint64_t v2 = v6;
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    unsigned int v3 = &__block_descriptor_36_e13_v24__0_8r_v16l;
    unsigned int v4 = ___ZL34cons_CALayer_kCAValueCopiedPointerjb_block_invoke_2;
  }
  v2[2] = v4;
  v2[3] = v3;
  *((_DWORD *)v2 + 8) = a1;
  return imp_implementationWithBlock(v2);
}

IMP cons_CAAnimation_kCAValueWeakPointer(int a1, int a2)
{
  void block[5] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v2 = block;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    unsigned int v3 = &__block_descriptor_36_e10_r_v16__0_8l;
    unsigned int v4 = ___ZL36cons_CAAnimation_kCAValueWeakPointerjb_block_invoke;
  }
  else
  {
    uint64_t v2 = v6;
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    unsigned int v3 = &__block_descriptor_36_e13_v24__0_8r_v16l;
    unsigned int v4 = ___ZL36cons_CAAnimation_kCAValueWeakPointerjb_block_invoke_2;
  }
  v2[2] = v4;
  v2[3] = v3;
  *((_DWORD *)v2 + 8) = a1;
  return imp_implementationWithBlock(v2);
}

void CA::Render::KeyframeAnimation::apply(CA::Render::KeyframeAnimation *this, CA::Render::AnimationEvaluator *a2, double a3, int a4, char a5)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  long long v82 = 0u;
  long long v83 = 0u;
  signed int v10 = CA::Render::KeyframeAnimation::keyframe_for_time(this, a3, (double *)&v82);
  uint64_t v11 = CA::Render::PropertyAnimation::apply_velocity_state(this, (uint64_t)a2);
  char v13 = (CA::Render::VelocityState *)v11;
  double v14 = 0.0;
  double v15 = 0.0;
  if ((a5 & 1) == 0 && v11) {
    double v15 = (*(double (**)(CA::Render::KeyframeAnimation *, double))(*(void *)this + 128))(this, a3)
  }
        * *((float *)a2 + 2);
  int v16 = *((unsigned __int8 *)this + 144);
  if (*((unsigned char *)this + 144))
  {
    if (v16 == 2 || v16 == 4)
    {
      uint64_t v19 = 0;
      int v18 = 1;
    }
    else
    {
      int v18 = 0;
      uint64_t v19 = *((void *)this + 16);
    }
    double v20 = *(double *)&v83 - *((double *)&v82 + 1);
    double v21 = (a3 - *((double *)&v82 + 1)) / (*(double *)&v83 - *((double *)&v82 + 1));
    if (v21 > 1.0) {
      double v21 = 1.0;
    }
    if (v21 >= 0.0) {
      double v14 = v21;
    }
    else {
      double v14 = 0.0;
    }
    double v22 = v15 / v20;
    if (v13) {
      double v23 = v15 / v20;
    }
    else {
      double v23 = v15;
    }
    if (!v19 || v10 < 0 || v10 >= *(_DWORD *)(v19 + 16) >> 2)
    {
      double v15 = v23;
    }
    else
    {
      uint64_t v24 = *((void *)this + 5);
      if (v24) {
        double v25 = *(double *)(v24 + 32);
      }
      else {
        double v25 = INFINITY;
      }
      unint64_t v26 = (CA::Render::TimingFunction *)(v19 + 32 * v10 + 24);
      double v27 = 0.001 / v25;
      double v29 = CA::Render::TimingFunction::evaluate(v26, v12, v14, 0.001 / v25);
      double v14 = v29;
      if (v13) {
        double v15 = CA::Render::TimingFunction::evaluate_derivative_inverse(v26, v28, v29, v27) * v22;
      }
    }
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v30 = (CA::Render::Path *)*((void *)this + 17);
  if (v30)
  {
    float64x2_t v80 = 0uLL;
    v79[0] = 0;
    v79[1] = 0;
    float64x2_t v78 = 0uLL;
    float64x2_t v77 = 0uLL;
    double v76 = 0.0;
    int v31 = *((_DWORD *)this + 3);
    if ((v31 & 0x3000000) != 0) {
      uint64_t v33 = &v76;
    }
    else {
      uint64_t v33 = 0;
    }
    if (v13) {
      uint64_t v35 = v79;
    }
    else {
      uint64_t v35 = 0;
    }
    float v32 = v14;
    float v34 = v15;
    if (CA::Render::Path::interpolate(v30, v10, v18, &v80, &v78, &v77, v33, (unint64_t)v35, v32, v34))
    {
      LODWORD(v74) = a4;
      CA::Render::PropertyAnimation::set(this, *((CA::Render::Layer **)a2 + 5), 0, (CA::Render::Vector *)2, 0, v80.f64, 0, 0, v78.f64, v77.f64, 0, v74);
      if (v13) {
        CA::Render::VelocityState::set_keypath_velocity((uint64_t)v13, *((void *const **)this + 12), *((CA::Render::Function **)this + 13), (*((_DWORD *)this + 3) >> 9) & 1, 2uLL, (CA::Mat4Impl *)v79, v80.f64, 0, v36);
      }
      if ((v31 & 0x3000000) != 0)
      {
        double v37 = v76;
        if ((v31 & 0x2000000) != 0)
        {
          double v37 = v76 + 3.14159265;
          double v76 = v76 + 3.14159265;
        }
        *(_OWORD *)&v81[16] = 0u;
        memset(&v81[48], 0, 32);
        *(_OWORD *)&v81[80] = xmmword_184997D50;
        *(_OWORD *)&v81[96] = 0u;
        *(_OWORD *)&v81[112] = xmmword_184997D60;
        __double2 v40 = __sincos_stret(v37);
        *(double *)v39.i64 = v40.__cosval;
        *(double *)v38.i64 = v40.__sinval;
        if (fabs(v40.__sinval) >= 0.0000001)
        {
          if (fabs(v40.__cosval) < 0.0000001)
          {
            v39.i64[0] = 1.0;
            v55.f64[0] = NAN;
            v55.f64[1] = NAN;
            v38.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v55), v39, v38).u64[0];
            v39.i64[0] = 0;
          }
        }
        else
        {
          v38.i64[0] = 1.0;
          v41.f64[0] = NAN;
          v41.f64[1] = NAN;
          v39.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v41), v38, v39).u64[0];
          v38.i64[0] = 0;
        }
        *(void *)int v81 = v39.i64[0];
        *(void *)&v81[8] = v38.i64[0];
        *(double *)&v81[32] = -*(double *)v38.i64;
        *(void *)&v81[40] = v39.i64[0];
        unint64_t v75 = 1137;
        CA::Render::Layer::set_keypath_value(*((CA::Render::Layer **)a2 + 5), &v75, (const unsigned int *)1, (CA::Render::Vector *)0x10, (double *)v81);
        CA::Render::key_path_free((CA::Render *)0x471, v56);
      }
    }
    return;
  }
  uint64_t v42 = *((void *)this + 14);
  if (!v42) {
    return;
  }
  if (v16 == 3)
  {
    memset(&v81[16], 0, 104);
    *(double *)int v81 = v14;
    *(double *)&v81[8] = v15;
  }
  else
  {
    memset(&v81[16], 0, 104);
    *(double *)int v81 = v14;
    *(double *)&v81[8] = v15;
    if (v16 != 4)
    {
      int v57 = 0;
      goto LABEL_69;
    }
  }
  uint64_t v43 = *((void *)this + 19);
  double v44 = 0.0;
  double v45 = 0.0;
  double v46 = 0.0;
  if (v43)
  {
    unint64_t v47 = *(unsigned int *)(v43 + 16);
    if (v10 < v47) {
      double v45 = *(double *)(v43 + 8 * v10 + 24);
    }
    if (v10 + 1 < v47) {
      double v46 = *(double *)(v43 + 8 * (v10 + 1) + 24);
    }
  }
  uint64_t v48 = *((void *)this + 20);
  double v49 = 0.0;
  if (v48)
  {
    unint64_t v50 = *(unsigned int *)(v48 + 16);
    if (v10 < v50) {
      double v44 = *(double *)(v48 + 8 * v10 + 24);
    }
    if (v10 + 1 < v50) {
      double v49 = *(double *)(v48 + 8 * (v10 + 1) + 24);
    }
  }
  uint64_t v51 = *((void *)this + 21);
  if (v51)
  {
    unint64_t v52 = *(unsigned int *)(v51 + 16);
    double v53 = 0.0;
    double v54 = 0.0;
    if (v10 < v52) {
      double v54 = *(double *)(v51 + 8 * v10 + 24);
    }
    if (v10 + 1 < v52) {
      double v53 = *(double *)(v51 + 8 * (v10 + 1) + 24);
    }
  }
  else
  {
    double v54 = 0.0;
    double v53 = 0.0;
  }
  CA::Render::ValueInterpolator::set_hermite((CA::Render::ValueInterpolator *)v81, *((double *)&v82 + 1) - *(double *)&v82, *(double *)&v83 - *((double *)&v82 + 1), *((double *)&v83 + 1) - *(double *)&v83, v45, v44, v54, v46, v49, v53);
  int v57 = 1;
LABEL_69:
  int v58 = *(_DWORD *)(v42 + 16);
  signed int v59 = v58 - 1;
  if (v58 < 1) {
    return;
  }
  unsigned int v60 = v10 >= v59 ? v58 - 1 : v10;
  uint64_t v61 = *(void *)(v42 + 24 + 8 * v60);
  unsigned int v62 = v10 + 1 < v59 ? v10 + 1 : v58 - 1;
  uint64_t v63 = *(void *)(v42 + 24 + 8 * v62);
  if (!v61 || v63 == 0) {
    return;
  }
  unint64_t v65 = 0;
  if (v57)
  {
    if (v10 >= 1 && v10 <= v58) {
      unint64_t v65 = *(void *)(v42 + 8 * (v10 - 1) + 24);
    }
    unint64_t v66 = 0;
    if (v10 >= -2 && v10 + 2 < v58) {
      unint64_t v66 = *(void *)(v42 + 8 * (v10 + 2) + 24);
    }
  }
  else
  {
    unint64_t v66 = 0;
  }
  if (*(unsigned char *)(v61 + 12) == 56 && *(unsigned char *)(v63 + 12) == 56)
  {
    unsigned int v67 = *(_DWORD *)(v61 + 16);
    unsigned int v68 = *(_DWORD *)(v63 + 16);
    if (v67 >= v68) {
      unint64_t v69 = v68;
    }
    else {
      unint64_t v69 = v67;
    }
    if (v57)
    {
      if (v65)
      {
        unint64_t v70 = v65 + 24;
        unsigned int v71 = *(_DWORD *)(v65 + 16);
        if (v69 >= v71) {
          unint64_t v69 = v71;
        }
        else {
          unint64_t v69 = v69;
        }
      }
      else
      {
        unint64_t v70 = 0;
      }
      if (v66)
      {
        unint64_t v73 = v66 + 24;
        if (v69 >= *(unsigned int *)(v66 + 16)) {
          unint64_t v69 = *(unsigned int *)(v66 + 16);
        }
        goto LABEL_111;
      }
    }
    else
    {
      unint64_t v70 = 0;
    }
    unint64_t v73 = 0;
LABEL_111:
    if (v69)
    {
      LODWORD(v74) = a4;
      CA::Render::PropertyAnimation::set(this, *((CA::Render::Layer **)a2 + 5), v13, (CA::Render::Vector *)v69, v70, (const double *)(v61 + 24), (const double *)(v63 + 24), v73, (const double *)(*(void *)(v42 + 24) + 24), (const double *)(*(void *)(v42 + 24 + 8 * v59) + 24), (const CA::Render::ValueInterpolator *)v81, v74);
    }
    return;
  }
  v80.f64[0] = 0.0;
  if (v57) {
    CA::Render::mix_objects((atomic_uint **)&v80, v65, (atomic_uint *)v61, (atomic_uint *)v63, v66, (const CA::Render::ValueInterpolator *)v81);
  }
  else {
    CA::Render::mix_objects((uint64_t)&v80, (atomic_uint *)v61, (atomic_uint *)v63, (const ValueInterpolator *)v81);
  }
  CA::Render::Layer::set_keypath_object(*((CA::Render::Layer **)a2 + 5), (const CA::Render::Layer **)this + 12, *(void *const **)&v80.f64[0]);
  float64_t v72 = v80.f64[0];
  if (*(void *)&v80.f64[0]
    && atomic_fetch_add((atomic_uint *volatile)(*(void *)&v80.f64[0] + 8), 0xFFFFFFFF) == 1)
  {
    (*(void (**)(float64_t))(**(void **)&v72 + 16))(COERCE_FLOAT64_T(*(void *)&v72));
  }
}

void CA::Render::KeyframeAnimation::next_time(uint64_t a1, void *a2, int a3, uint64_t a4, int a5, double *a6, CA::Render::Layer *a7, float64x2_t *a8, int8x16_t a9, double a10, int8x16_t a11, _DWORD *a12)
{
  float v16 = *(float *)&a10;
  double v17 = *(double *)a9.i64;
  v68[5] = *(double *)MEMORY[0x1E4F143B8];
  int v19 = *(unsigned __int8 *)(a1 + 144);
  if ((v19 - 2) < 3)
  {
    uint64_t v20 = *(void *)(a1 + 136);
    if (v20 && *(_DWORD *)(v20 + 16) && !*(void *)(v20 + 64)) {
      CA::Render::Path::keyframe_lengths((CA::Render::Path *)v20);
    }
LABEL_16:
    *(double *)a9.i64 = v17;
    *(float *)&a10 = v16;
    CA::Render::Animation::next_time(a1, a2, a3, a9, a10, a11, a4, a5, a6);
    return;
  }
  int v23 = a4;
  if (*(unsigned char *)(a1 + 144))
  {
    if (v19 != 1) {
      goto LABEL_16;
    }
    uint64_t v24 = *(void *)(a1 + 136);
    if (v24 && *(_DWORD *)(v24 + 16))
    {
      if (!*(void *)(v24 + 64)) {
        CA::Render::Path::keyframe_lengths(*(CA::Render::Path **)(a1 + 136));
      }
      if (*(double *)(v24 + 72) != 0.0) {
        goto LABEL_16;
      }
    }
  }
  uint64_t v25 = *(void *)(a1 + 40);
  if (v25)
  {
    if (*(float *)(v25 + 16) == 0.0) {
      return;
    }
    double v26 = *(double *)(v25 + 40);
    double v27 = CA::Render::Timing::end_time((CA::Render::Timing *)v25);
  }
  else
  {
    double v26 = 0.0;
    double v27 = INFINITY;
  }
  if (v16 >= 0.0) {
    double v28 = v26;
  }
  else {
    double v28 = v27;
  }
  BOOL v29 = v28 > v17;
  if (v16 <= 0.0) {
    BOOL v29 = v28 < v17;
  }
  if (v29)
  {
    BOOL v30 = v28 < *a6;
    if (v16 <= 0.0) {
      BOOL v30 = v28 > *a6;
    }
    if (v30) {
      *a6 = v28;
    }
  }
  else
  {
    if (v16 < 0.0) {
      double v27 = v26;
    }
    BOOL v31 = v27 > v17;
    if (v16 <= 0.0) {
      BOOL v31 = v27 < v17;
    }
    if (v31)
    {
      double v67 = v17;
      BOOL v66 = 0;
      if (CA::Render::Animation::map_time((CA::Render::Animation *)a1, &v67, 0, &v66, 0))
      {
        memset(v68, 0, 32);
        signed int v32 = CA::Render::KeyframeAnimation::keyframe_for_time((CA::Render::KeyframeAnimation *)a1, v67, v68);
        if (*(unsigned char *)(a1 + 144) != 1) {
          goto LABEL_38;
        }
        if (*(void *)(a1 + 136)) {
          goto LABEL_38;
        }
        uint64_t v39 = *(void *)(a1 + 112);
        if (!v39) {
          goto LABEL_38;
        }
        unsigned int v40 = *(_DWORD *)(v39 + 16);
        if (v40 < 2) {
          goto LABEL_38;
        }
        signed int v41 = v32;
        signed int v42 = v40 - 1;
        if (v32 >= v42) {
          unsigned int v43 = v42;
        }
        else {
          unsigned int v43 = v32;
        }
        uint64_t v44 = v39 + 24;
        uint64_t v45 = *(void *)(v44 + 8 * v43);
        if (v32 + 1 < v42) {
          signed int v42 = v32 + 1;
        }
        uint64_t v46 = *(void *)(v44 + 8 * v42);
        BOOL v47 = !v45 || v46 == 0;
        if (v47
          || (v60 = *(void *)(v44 + 8 * v42), uint64_t v61 = v45, *(unsigned char *)(v45 + 12) == 56)
          && *(unsigned char *)(v46 + 12) == 56
          && (uint64_t v48 = *(unsigned int *)(v46 + 16), v48 == *(_DWORD *)(v45 + 16))
          && (v59 = v32, int v49 = memcmp((const void *)(v45 + 24), (const void *)(v46 + 24), 8 * v48), v41 = v59, !v49))
        {
LABEL_38:
          if (v66) {
            *(int8x16_t *)&v68[1] = vextq_s8(*(int8x16_t *)&v68[1], *(int8x16_t *)&v68[1], 8uLL);
          }
          uint64_t v37 = *(void *)(a1 + 40);
          if (v37 && *(float *)(v37 + 16) < 0.0) {
            v68[2] = v68[1];
          }
          double v67 = v68[2];
          CA::Render::Animation::inverse_map_time(a1, &v67, v17);
          BOOL v38 = v67 < *a6;
          if (v16 <= 0.0) {
            BOOL v38 = v67 > *a6;
          }
          if (v38) {
            *a6 = v67;
          }
        }
        else
        {
          unsigned int v50 = v41;
          double v51 = *a6;
          *(double *)v34.i64 = v17;
          *(float *)&double v35 = v16;
          CA::Render::Animation::next_time(a1, a2, a3, v34, v35, v36, v33, a5, a6);
          uint64_t v52 = 0;
          char v53 = 0;
          uint64_t v54 = *(void *)(a1 + 128);
          if (v54 && (v50 & 0x80000000) == 0)
          {
            if (v50 >= *(_DWORD *)(v54 + 16) >> 2)
            {
              char v53 = 0;
              uint64_t v52 = 0;
            }
            else
            {
              uint64_t v52 = v54 + 8 * (int)(4 * v50) + 24;
              char v53 = 1;
            }
          }
          uint64_t v55 = *(void *)(a1 + 40);
          if (v55) {
            uint64_t v56 = *(void *)(v55 + 32);
          }
          else {
            uint64_t v56 = 0x7FF0000000000000;
          }
          if (!v52
            || (double v57 = *(double *)(v52 + 8), v57 >= 0.0)
            && v57 <= 1.0
            && (double v58 = *(double *)(v52 + 24), v58 >= 0.0)
            && v58 <= 1.0)
          {
            v64[0] = MEMORY[0x1E4F143A8];
            v64[1] = 0x40000000;
            void v64[2] = ___ZNK2CA6Render17KeyframeAnimation9next_timeEdfPKvNS0_26AnimationFrameRateOverrideEjbRdPKNS0_5LayerEPKNS_4Vec2IdEERj_block_invoke;
            v64[3] = &__block_descriptor_tmp_19689;
            *(double *)&v64[4] = v68[1];
            *(double *)&v64[5] = v68[2];
            char v65 = v53;
            v64[6] = v52;
            v64[7] = v56;
            v62[0] = MEMORY[0x1E4F143A8];
            v62[1] = 0x40000000;
            v62[2] = ___ZNK2CA6Render17KeyframeAnimation9next_timeEdfPKvNS0_26AnimationFrameRateOverrideEjbRdPKNS0_5LayerEPKNS_4Vec2IdEERj_block_invoke_2;
            v62[3] = &__block_descriptor_tmp_1_19690;
            char v63 = v53;
            v62[4] = v52;
            v62[5] = v56;
            *(double *)&v62[6] = v68[2];
            *(double *)&v62[7] = v68[1];
            CA::Render::PropertyAnimation::significant_change_next_time((CA::Render::Animation *)a1, (uint64_t)v64, (uint64_t)v62, v23, a6, a7, a8, a12, v17, v16, v51, v61, v60, 0);
          }
        }
      }
    }
  }
}

unsigned int CA::Render::KeyframeAnimation::keyframe_for_time(CA::Render::KeyframeAnimation *this, double a2, double *a3)
{
  if ((*(void *)&a2 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 15);
  if (v3)
  {
    int v4 = *(_DWORD *)(v3 + 16);
    int v5 = v4 - 2;
    if (v4 >= 2)
    {
      int v6 = 1;
      if ((*((unsigned char *)this + 15) & 4) != 0 && v4 >= 6)
      {
        unsigned int v7 = v4 - 3;
        do
        {
          unsigned int v8 = v6 + (v7 >> 1);
          if (*(double *)(v3 + 8 * v8 + 24) > a2) {
            int v5 = v8;
          }
          else {
            int v6 = v8;
          }
          unsigned int v7 = v5 - v6;
        }
        while (v5 - v6 > 2);
      }
      if (v6 < v4 - 1)
      {
        while (*(double *)(v3 + 8 * v6 + 24) <= a2)
        {
          if (v4 - 1 == ++v6)
          {
            int v6 = v4 - 1;
            break;
          }
        }
      }
      unsigned int result = v6 - 1;
      double v10 = *(double *)(v3 + 24 + 8 * (v6 - 1));
      a3[1] = v10;
      double v11 = *(double *)(v3 + 24 + 8 * v6);
      a3[2] = v11;
      if (v6 < 2) {
        double v12 = -(v11 + v10 * -2.0);
      }
      else {
        double v12 = *(double *)(v3 + 8 * (v6 - 2) + 24);
      }
      *a3 = v12;
      int v15 = v6 + 1;
      if (v15 >= v4) {
        double v16 = -(v10 + v11 * -2.0);
      }
      else {
        double v16 = *(double *)(v3 + 8 * v15 + 24);
      }
      goto LABEL_32;
    }
LABEL_33:
    unsigned int result = 0;
    *a3 = 0.0;
    a3[1] = 0.0;
    a3[3] = 1.0;
    double v16 = 1.0;
    uint64_t v22 = 2;
    goto LABEL_34;
  }
  uint64_t v13 = *((void *)this + 17);
  if (v13)
  {
    int v14 = *(_DWORD *)(v13 + 16);
  }
  else
  {
    uint64_t v17 = *((void *)this + 14);
    if (!v17) {
      goto LABEL_33;
    }
    int v14 = *(_DWORD *)(v17 + 16) - (*((unsigned char *)this + 144) != 0);
  }
  if (v14 <= 0) {
    goto LABEL_33;
  }
  double v18 = 1.0 / (double)v14;
  if (a2 > 1.0) {
    a2 = 1.0;
  }
  if (a2 < 0.0) {
    a2 = 0.0;
  }
  double v19 = a2 * (double)v14;
  double v20 = floor(v19);
  unsigned int result = vcvtmd_s64_f64(v19);
  *a3 = v18 * v20 - v18;
  a3[1] = v18 * v20;
  double v21 = v18 * v20 + v18;
  a3[2] = v21;
  double v16 = v21 + v18;
LABEL_32:
  uint64_t v22 = 3;
LABEL_34:
  a3[v22] = v16;
  return result;
}

uint64_t CA::Render::Layer::set_keypath_object(CA::Render::Layer *this, const CA::Render::Layer **a2, void *const *a3)
{
  uint64_t v3 = (CA::Render::Object *)a3;
  v48[1] = *(CA::Render::Layer **)MEMORY[0x1E4F143B8];
  v48[0] = this;
  uint64_t result = CA::Render::skip_sublayers((CA::Render *)v48, a2, a3);
  if (result) {
    return result;
  }
  unint64_t v8 = (unint64_t)*a2;
  if (!*a2) {
    return result;
  }
  unint64_t v9 = v48[0];
  if (v8)
  {
    int v47 = 17;
    v8 >>= 1;
    goto LABEL_9;
  }
  unsigned int v10 = *(_DWORD *)v8;
  if (*(_DWORD *)v8 != 1)
  {
    if ((int)v10 > 3 || v10 == 0) {
      return result;
    }
    int v14 = *(_DWORD *)(v8 + 4);
    switch(v14)
    {
      case 56:
        uint64_t v38 = *((void *)v48[0] + 16);
        if (!v38) {
          return result;
        }
        uint64_t result = *(void *)(v38 + 104);
        if (!result) {
          return result;
        }
        unsigned int v39 = v10 < 2 ? 0 : *(_DWORD *)(v8 + 8);
        uint64_t result = CA::Render::TypedArray<CA::Render::Filter>::find_named_object(result, v39);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        int v42 = 0;
        uint64_t v43 = *(void *)(*((void *)v9 + 16) + 104);
        break;
      case 113:
        uint64_t v40 = *((void *)v48[0] + 16);
        if (!v40) {
          return result;
        }
        uint64_t v41 = *(void *)(v40 + 88);
        if (!v41) {
          return result;
        }
        if (v10 < 2) {
          int v42 = 0;
        }
        else {
          int v42 = *(_DWORD *)(v8 + 8);
        }
        uint64_t v46 = *(CA::Render::KeyValueArray **)(v41 + 40);
        goto LABEL_126;
      case 226:
        uint64_t v15 = *((void *)v48[0] + 16);
        if (!v15) {
          return result;
        }
        uint64_t result = *(void *)(v15 + 96);
        if (!result) {
          return result;
        }
        unsigned int v16 = v10 < 2 ? 0 : *(_DWORD *)(v8 + 8);
        uint64_t result = CA::Render::TypedArray<CA::Render::Filter>::find_named_object(result, v16);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        int v42 = 0;
        uint64_t v43 = *(void *)(*((void *)v9 + 16) + 96);
        break;
      default:
        return result;
    }
    uint64_t v44 = *(void *)(v43 + 8 * result + 24);
    uint64_t v45 = *a2;
    if (*a2 && (v45 & 1) == 0)
    {
      if (*(_DWORD *)v45 < 3u) {
        int v42 = 0;
      }
      else {
        int v42 = *((_DWORD *)v45 + 3);
      }
    }
    uint64_t v46 = *(CA::Render::KeyValueArray **)(v44 + 40);
LABEL_126:
    return CA::Render::KeyValueArray::set_key(v46, v42, (atomic_uint *)v3);
  }
  int v47 = 17;
  if (!*(_DWORD *)v8)
  {
LABEL_65:
    uint64_t v33 = (void *)*((void *)this + 16);
    if (v33 && *v33)
    {
      uint64_t result = *CA::Render::Layer::ensure_ext(this);
      if (result) {
        return (*(uint64_t (**)(uint64_t, const CA::Render::Layer **, CA::Render::Object *))(*(void *)result + 128))(result, a2, v3);
      }
    }
    return result;
  }
  LODWORD(v8) = *(_DWORD *)(v8 + 4);
LABEL_9:
  if ((int)v8 > 225)
  {
    if ((int)v8 > 545)
    {
      switch(v8)
      {
        case 0x222:
          if (v3)
          {
            if (*((unsigned char *)v3 + 12) != 56) {
              return result;
            }
            BOOL v29 = v48[0];
            BOOL v30 = v3;
          }
          else
          {
            BOOL v29 = v48[0];
            BOOL v30 = 0;
          }
          return CA::Render::Layer::set_sublayer_transform((uint64_t)v29, v30);
        case 0x223:
          return result;
        case 0x238:
          if (v3)
          {
            if (*((unsigned char *)v3 + 12) != 56) {
              return result;
            }
            double v19 = v48[0];
            double v20 = v3;
          }
          else
          {
            double v19 = v48[0];
            double v20 = 0;
          }
          return CA::Render::Layer::set_transform((uint64_t)v19, v20);
      }
      goto LABEL_65;
    }
    if (v8 == 226)
    {
      if (v3)
      {
        if (*((unsigned char *)v3 + 12) != 1) {
          return result;
        }
        uint64_t result = CA::Render::Array::check_types((uint64_t)v3, 1, &v47);
        if (!result) {
          return result;
        }
        uint64_t v25 = v9;
        uint64_t v26 = (uint64_t)v3;
      }
      else
      {
        uint64_t v25 = v48[0];
        uint64_t v26 = 0;
      }
      return CA::Render::Layer::set_filters((uint64_t)v25, v26);
    }
    if (v8 != 386)
    {
      if (v8 == 504)
      {
        if (v3)
        {
          if (*((unsigned char *)v3 + 12) != 36) {
            return result;
          }
          double v11 = v48[0];
          double v12 = v3;
        }
        else
        {
          double v11 = v48[0];
          double v12 = 0;
        }
        return CA::Render::Layer::set_shadow_path((uint64_t)v11, v12);
      }
      goto LABEL_65;
    }
    if (!v3) {
      return result;
    }
    int v27 = *((unsigned __int8 *)v3 + 12);
    if (v27 == 26)
    {
      uint64_t result = (uint64_t)CA::Render::MeshTransform::eval_interpolator(v3, (float64x2_t *)v48[0] + 4, v7);
      uint64_t v3 = (CA::Render::Object *)result;
      if (!result)
      {
        double v28 = 0;
LABEL_120:
        uint64_t result = CA::Render::Layer::set_mesh_transform((uint64_t)v9, (os_unfair_lock_s *)v3);
LABEL_121:
        if (v28 && atomic_fetch_add(v28 + 2, 0xFFFFFFFF) == 1) {
          return (*(uint64_t (**)(atomic_uint *))(*(void *)v28 + 16))(v28);
        }
        return result;
      }
      int v27 = *(unsigned __int8 *)(result + 12);
      double v28 = (atomic_uint *)result;
    }
    else
    {
      double v28 = 0;
    }
    if (v27 != 33) {
      goto LABEL_121;
    }
    goto LABEL_120;
  }
  if ((int)v8 <= 120)
  {
    switch(v8)
    {
      case '8':
        if (v3)
        {
          if (*((unsigned char *)v3 + 12) != 1) {
            return result;
          }
          uint64_t result = CA::Render::Array::check_types((uint64_t)v3, 1, &v47);
          if (!result) {
            return result;
          }
          double v21 = v9;
          uint64_t v22 = (uint64_t)v3;
        }
        else
        {
          double v21 = v48[0];
          uint64_t v22 = 0;
        }
        return CA::Render::Layer::set_background_filters((uint64_t)v21, v22);
      case 'q':
        if (v3)
        {
          if (*((unsigned char *)v3 + 12) != 17) {
            return result;
          }
          int v23 = v48[0];
          uint64_t v24 = v3;
        }
        else
        {
          int v23 = v48[0];
          uint64_t v24 = 0;
        }
        return CA::Render::Layer::set_compositing_filter((uint64_t)v23, v24);
      case 'w':
        return (uint64_t)CA::Render::Layer::set_contents(v48[0], v3);
    }
    goto LABEL_65;
  }
  switch((int)v8)
  {
    case 135:
      if (v3)
      {
        if (*((unsigned char *)v3 + 12) != 56) {
          return result;
        }
        uint64_t v17 = v48[0];
        double v18 = v3;
      }
      else
      {
        uint64_t v17 = v48[0];
        double v18 = 0;
      }
      return CA::Render::Layer::set_contents_rect((uint64_t)v17, v18);
    case 136:
    case 137:
    case 138:
    case 140:
    case 141:
    case 142:
      goto LABEL_65;
    case 139:
      if (v3)
      {
        if (*((unsigned char *)v3 + 12) != 56) {
          return result;
        }
        int8x16_t v34 = v48[0];
        double v35 = v3;
      }
      else
      {
        int8x16_t v34 = v48[0];
        double v35 = 0;
      }
      return CA::Render::Layer::set_contents_transform((uint64_t)v34, v35);
    case 143:
      return CA::Render::Layer::set_corner_contents((uint64_t)v48[0], v3);
    case 144:
      if (v3)
      {
        if (*((unsigned char *)v3 + 12) != 56) {
          return result;
        }
        int8x16_t v36 = v48[0];
        uint64_t v37 = v3;
      }
      else
      {
        int8x16_t v36 = v48[0];
        uint64_t v37 = 0;
      }
      return CA::Render::Layer::set_corner_contents_center((uint64_t)v36, v37);
    default:
      if (v8 != 121) {
        goto LABEL_65;
      }
      if (v3)
      {
        if (*((unsigned char *)v3 + 12) != 56) {
          return result;
        }
        BOOL v31 = v48[0];
        signed int v32 = v3;
      }
      else
      {
        BOOL v31 = v48[0];
        signed int v32 = 0;
      }
      uint64_t result = CA::Render::Layer::set_contents_center((uint64_t)v31, v32);
      break;
  }
  return result;
}

uint64_t CA::Render::mix_objects(uint64_t this, atomic_uint *a2, atomic_uint *a3, const ValueInterpolator *a4)
{
  int v4 = (void *)this;
  if (!a2) {
    goto LABEL_22;
  }
  int v5 = a3;
  if (!a3) {
    goto LABEL_22;
  }
  unsigned int v7 = (unsigned __int8 *)a2;
  if (fabs(a4->var0) < 0.00001)
  {
    if (!atomic_fetch_add(a2 + 2, 1u))
    {
      unsigned int v7 = 0;
      atomic_fetch_add(a2 + 2, 0xFFFFFFFF);
    }
    *(void *)this = v7;
    return this;
  }
  if (fabs(a4->var0 + -1.0) < 0.00001)
  {
    if (!atomic_fetch_add(a3 + 2, 1u))
    {
      int v5 = 0;
      atomic_fetch_add(a3 + 2, 0xFFFFFFFF);
    }
    *(void *)this = v5;
    return this;
  }
  int v8 = *((unsigned __int8 *)a2 + 12);
  int v9 = *((unsigned __int8 *)a3 + 12);
  if (v8 == 26)
  {
    unsigned int v7 = (unsigned __int8 *)*((void *)a2 + 4);
    if (!v7) {
      goto LABEL_22;
    }
    int v8 = v7[12];
  }
  if (v9 == 26)
  {
    int v5 = (atomic_uint *)*((void *)a3 + 4);
    if (v5)
    {
      int v9 = *((unsigned __int8 *)v5 + 12);
      goto LABEL_17;
    }
LABEL_22:
    *int v4 = 0;
    return this;
  }
LABEL_17:
  if (v8 != v9)
  {
    this = (*(uint64_t (**)(unsigned __int8 *, atomic_uint *))(*(void *)v7 + 48))(v7, v5);
    if ((this & 1) == 0) {
      goto LABEL_22;
    }
  }
  unsigned int v10 = *(uint64_t (**)(unsigned __int8 *, atomic_uint *, const ValueInterpolator *))(*(void *)v7 + 56);

  return v10(v7, v5, a4);
}

atomic_uint *CA::Render::ShapeLayer::set_path(CA::Render::ShapeLayer *this, CA::Render::Path *a2)
{
  uint64_t v3 = (atomic_uint *)*((void *)this + 2);
  if (v3 != (atomic_uint *)a2)
  {
    int v4 = a2;
    if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
    }
    if (v4)
    {
      int v5 = (atomic_uint *)((char *)v4 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)v4 + 2, 1u))
      {
        int v4 = 0;
        atomic_fetch_add(v5, 0xFFFFFFFF);
      }
    }
    *((void *)this + 2) = v4;
  }

  return CA::Render::ShapeLayer::invalidate_stroke_path(this);
}

atomic_uint *CA::Render::ShapeLayer::set_keypath_object(atomic_uint *this, void *const *a2, CA::Render::Object *a3)
{
  unint64_t v3 = (unint64_t)*a2;
  if (*a2)
  {
    int v4 = this;
    if (v3)
    {
      v3 >>= 1;
    }
    else
    {
      if (*(_DWORD *)v3 != 1) {
        return this;
      }
      LODWORD(v3) = *(_DWORD *)(v3 + 4);
    }
    if (v3 == 355)
    {
      if (a3)
      {
        if (*((unsigned char *)a3 + 12) == 56)
        {
          return CA::Render::ShapeLayer::set_dash_pattern((CA::Render::ShapeLayer *)this, a3);
        }
      }
      else
      {
        this = (atomic_uint *)*((void *)this + 14);
        if (this)
        {
          if (atomic_fetch_add(this + 2, 0xFFFFFFFF) == 1) {
            this = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)this + 16))(this);
          }
          *((void *)v4 + 14) = 0;
        }
      }
    }
    else
    {
      if (v3 != 423) {
        return this;
      }
      if (a3)
      {
        if (*((unsigned char *)a3 + 12) != 36) {
          return this;
        }
        int v5 = a3;
      }
      else
      {
        int v5 = 0;
      }
      return CA::Render::ShapeLayer::set_path((CA::Render::ShapeLayer *)this, v5);
    }
  }
  return this;
}

void CA::Render::Transition::~Transition(CA::Render::Transition *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02CED0;
  unint64_t v3 = (atomic_uint *)*((void *)this + 5);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  int v4 = (atomic_uint *)*((void *)this + 4);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  int v5 = (atomic_uint *)*((void *)this + 3);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  --dword_1EB2ADEA0;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  atomic_uint *v4;
  atomic_uint *v5;

  *(void *)this = &unk_1ED02CED0;
  unint64_t v3 = (atomic_uint *)*((void *)this + 5);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  int v4 = (atomic_uint *)*((void *)this + 4);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  int v5 = (atomic_uint *)*((void *)this + 3);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  --dword_1EB2ADEA0;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

BOOL CAImageQueueInsertImageWithRotation(uint64_t a1, int a2, uint64_t a3, unsigned int a4, char a5, uint64_t a6, uint64_t a7, double a8)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  long long v9 = xmmword_184998040;
  return CAImageQueueInsertImage_(a1, a2, a3, a4, a5, &v9, a6, a7, a8, 0.0, 0.0, 0.0, 0.0);
}

void sub_1847B6E28(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::WindowServer::Server::hit_test(uint64_t a1, uint64_t a2, double *a3, int *a4, uint64_t a5, char a6, int64x2_t *a7)
{
  uint64_t v9 = a5;
  uint64_t v10 = a4;
  uint64_t v330 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 448) = 0;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 40CA::Context::unref(this[1], 0) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 32CA::Context::unref(this[1], 0) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 24CA::Context::unref(this[1], 0) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 16CA::Context::unref(this[1], 0) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8CA::Context::unref(this[1], 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(CATransform3D *)(a1 + 4CA::Context::unref(this[1], 0) = CATransform3DIdentity;
  *(CATransform3D *)(a1 + 168) = CATransform3DIdentity;
  int v311 = 0;
  if (a6)
  {
    uint64_t v14 = *(void *)(a2 + 168);
    if (v14)
    {
      int v15 = *(_DWORD *)(v14 + 16);
      if (a5)
      {
        a4[a5] = v15;
        uint64_t v9 = a5 + 1;
      }
      else
      {
        int v311 = v15;
        uint64_t v10 = &v311;
        uint64_t v9 = 1;
      }
    }
  }
  unsigned int v16 = (os_unfair_lock_s *)(a2 + 324);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 324));
  uint64_t v17 = *(atomic_uint **)(a2 + 328);
  if (!v17)
  {
    os_unfair_lock_unlock(v16);
    return;
  }
  uint64_t v296 = a7;
  atomic_fetch_add(v17, 1u);
  os_unfair_lock_unlock(v16);
  CGFloat v18 = *a3;
  CGFloat v19 = a3[1];
  char v310 = 0;
  uint64_t v20 = CA::Render::HitTestTree::hit_test((uint64_t)v17, v10, (const char *)v9, &v310, v18, v19);
  if (!v20) {
    goto LABEL_139;
  }
  uint64_t v22 = (unsigned int *)v20;
  uint64_t v295 = (uint64_t)v17;
  int v23 = (unsigned int *)v20;
  do
  {
    LODWORD(v24) = v23[6];
    if (v24) {
      break;
    }
    uint64_t v24 = *v23;
    int v23 = (unsigned int *)((char *)v23 - v24);
  }
  while (v24);
  *(_DWORD *)a1 = v24;
  int v25 = *(_DWORD *)(v20 + 28);
  *(_DWORD *)(a1 + 4) = v25;
  if ((a6 & 2) != 0)
  {
    float v26 = 1.0;
    int v27 = (unsigned int *)v20;
    do
    {
      float v26 = (float)(v26 * 0.0039216) * (float)*((unsigned __int8 *)v27 + 11);
      uint64_t v28 = *v27;
      int v27 = (unsigned int *)((char *)v27 - v28);
    }
    while (v28);
    *(float *)(a1 + 32) = v26;
    if ((a6 & 0x10) == 0)
    {
LABEL_13:
      if (!v25) {
        goto LABEL_124;
      }
LABEL_28:
      if ((a6 & 0x10) != 0 && !*(unsigned char *)(a1 + 28))
      {
        uint64_t v33 = (CA::Render::Layer *)*((void *)v22 + 2);
        if (v33) {
          LOBYTE(v33) = CA::Render::Layer::has_hit_test_insecure_properties(v33, 1);
        }
        *(unsigned char *)(a1 + 28) = (_BYTE)v33;
      }
      int v35 = *((void *)v22 + 5);
      v323[0] = *((float64x2_t *)v22 + 2);
      int v34 = LODWORD(v323[0].f64[0]);
      int v36 = HIDWORD(v323[0].f64[1]);
      int v37 = HIDWORD(v323[0].f64[0]);
      if (!v296
        || (v35 <= SHIDWORD(v323[0].f64[1]) ? (int v38 = HIDWORD(v323[0].f64[1])) : (int v38 = v35),
            v35 >= SHIDWORD(v323[0].f64[1]) ? (int v39 = HIDWORD(v323[0].f64[1])) : (int v39 = v35),
            v38 <= 1073741822 ? (BOOL v40 = v39 < 1) : (BOOL v40 = 1),
            v40))
      {
        int v292 = LODWORD(v323[0].f64[0]);
      }
      else
      {
        __int32 v47 = v296[1].i32[0];
        __int32 v48 = v296[1].i32[2];
        __int32 v49 = v296->i32[0];
        __int32 v50 = v296->i32[2];
        int v37 = HIDWORD(v323[0].f64[0]) + v296->i32[0];
        LODWORD(v323[0].f64[0]) += v50;
        HIDWORD(v323[0].f64[0]) = v37;
        v35 -= v48 + v50;
        int v36 = HIDWORD(v323[0].f64[1]) - (v47 + v49);
        *(void *)&v323[0].f64[1] = __PAIR64__(v36, v35);
        BOOL v51 = v35 < 1 || v36 <= 0;
        int v292 = v34 + v50;
        if (v51)
        {
          int v36 = 0;
          int v35 = 0;
          v323[0].f64[1] = 0.0;
        }
      }
      uint64_t v41 = *v22;
      if (v41) {
        int v42 = (int32x2_t *)((char *)v22 - v41);
      }
      else {
        int v42 = 0;
      }
      int v43 = byte_1EB2ACC2F;
      if (byte_1EB2ACC2F)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          uint64_t v52 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_INFO))
          {
            unsigned int v53 = v22[7];
            uint64_t v54 = *((void *)v22 + 2);
            uint64_t v55 = "No Name";
            if (v54)
            {
              uint64_t v56 = *(void *)(v54 + 120);
              if (v56) {
                uint64_t v55 = (const char *)(v56 + 28);
              }
            }
            *(_DWORD *)long long buf = 67110402;
            *(_DWORD *)&uint8_t buf[4] = v53;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = v292;
            *(_WORD *)&buf[14] = 1024;
            *(_DWORD *)&uint8_t buf[16] = v37;
            *(_WORD *)&buf[20] = 1024;
            *(_DWORD *)&buf[22] = v35;
            *(_WORD *)&buf[26] = 1024;
            *(_DWORD *)&unsigned char buf[28] = v36;
            *(_WORD *)&uint8_t buf[32] = 2080;
            *(void *)&buf[34] = v55;
            _os_log_impl(&dword_184668000, v52, OS_LOG_TYPE_INFO, "Slot <%d> [%d %d %d %d] (%s) detected", buf, 0x2Au);
          }
        }
        uint64_t v57 = *((void *)v22 + 1);
        if ((v57 & 0x40000000000) == 0)
        {
          if ((v57 & 0x20000000000000) != 0)
          {
            if (x_log_hook_p())
            {
LABEL_101:
              x_log_();
            }
            else
            {
              uint64_t v71 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_INFO))
              {
                unsigned int v72 = v22[7];
                *(_DWORD *)long long buf = 67110144;
                *(_DWORD *)&uint8_t buf[4] = v72;
                *(_WORD *)&uint8_t buf[8] = 1024;
                *(_DWORD *)&buf[10] = v292;
                *(_WORD *)&buf[14] = 1024;
                *(_DWORD *)&uint8_t buf[16] = v37;
                *(_WORD *)&buf[20] = 1024;
                *(_DWORD *)&buf[22] = v35;
                *(_WORD *)&buf[26] = 1024;
                *(_DWORD *)&unsigned char buf[28] = v36;
                unint64_t v73 = "Slot <%d> [%d %d %d %d] occluded by self border";
                unint64_t v74 = v71;
                uint32_t v75 = 32;
LABEL_107:
                _os_log_impl(&dword_184668000, v74, OS_LOG_TYPE_INFO, v73, buf, v75);
              }
            }
            goto LABEL_108;
          }
          int v290 = v37;
          uint64_t v46 = (int32x2_t *)v22;
          if (v41) {
            goto LABEL_73;
          }
          int v45 = 0;
LABEL_110:
          *(_DWORD *)(a1 + 24) = v45;
          if ((a6 & 4) == 0) {
            goto LABEL_122;
          }
          CA::Render::HitTestTree::Node::relative_transform_product((CA::Mat4Impl *)buf, v22, 0, v21);
          long long v76 = *(_OWORD *)&buf[16];
          long long v77 = *(_OWORD *)&buf[32];
          long long v78 = v315;
          *(_OWORD *)(a1 + 4CA::Context::unref(this[1], 0) = *(_OWORD *)buf;
          *(_OWORD *)(a1 + 56) = v76;
          *(_OWORD *)(a1 + 72) = v77;
          *(_OWORD *)(a1 + 88) = v78;
          long long v79 = v317;
          long long v80 = v318;
          long long v81 = v319;
          *(float64x2_t *)(a1 + 104) = v316;
          *(_OWORD *)(a1 + 12CA::Context::unref(this[1], 0) = v79;
          *(_OWORD *)(a1 + 136) = v80;
          *(_OWORD *)(a1 + 152) = v81;
          long long v82 = xmmword_184997D50;
          long long v83 = 0uLL;
          *(_OWORD *)long long buf = xmmword_184997D50;
          *(_OWORD *)&uint8_t buf[16] = 0u;
          long long v84 = xmmword_184997D60;
          *(_OWORD *)&uint8_t buf[32] = xmmword_184997D60;
          long long v315 = 0u;
          float64x2_t v316 = 0u;
          long long v317 = xmmword_184997D50;
          long long v318 = 0u;
          __asm { FMOV            V0.2D, #1.0 }
          long long v319 = xmmword_184997D60;
          long long v320 = _Q0;
          v321 &= 0xE0u;
          uint64_t v88 = *((void *)v22 + 2);
          if (!v88) {
            goto LABEL_120;
          }
          uint64_t v89 = *(void *)(v88 + 96);
          if (!v89) {
            goto LABEL_120;
          }
          uint64_t v90 = (*(uint64_t (**)(uint64_t))(*(void *)v89 + 80))(v89);
          long long v84 = xmmword_184997D60;
          long long v82 = xmmword_184997D50;
          long long v83 = 0uLL;
          double v92 = (CA::Render::Texture *)v90;
          if (v90)
          {
LABEL_114:
            double v93 = (CA::Render::Layer *)*((void *)v22 + 2);
            if ((*((unsigned char *)v93 + 41) & 0x20) != 0)
            {
              v91.f64[0] = -1.0;
              CA::Transform::scale((float64x2_t *)buf, v91, 1.0, 1.0);
              double v93 = (CA::Render::Layer *)*((void *)v22 + 2);
            }
            CA::Render::Layer::append_texture_transform(v93, (CA::Transform *)buf, v92, (CA::Render::Object *)v89);
            long long v95 = *(_OWORD *)buf;
            long long v94 = *(_OWORD *)&buf[16];
            long long v97 = *(_OWORD *)&buf[32];
            long long v96 = v315;
            float64x2_t v91 = v316;
            long long v82 = v317;
            long long v83 = v318;
            long long v84 = v319;
            goto LABEL_121;
          }
          if (*(unsigned char *)(v89 + 12) == 26)
          {
            uint64_t v98 = (*(uint64_t (**)(void))(**(void **)(v89 + 32) + 80))(*(void *)(v89 + 32));
            long long v84 = xmmword_184997D60;
            long long v82 = xmmword_184997D50;
            long long v83 = 0uLL;
            double v92 = (CA::Render::Texture *)v98;
            float64x2_t v91 = 0uLL;
            long long v96 = 0uLL;
            long long v97 = xmmword_184997D60;
            long long v94 = 0uLL;
            long long v95 = xmmword_184997D50;
            if (v98) {
              goto LABEL_114;
            }
          }
          else
          {
LABEL_120:
            float64x2_t v91 = 0uLL;
            long long v96 = 0uLL;
            long long v97 = v84;
            long long v94 = 0uLL;
            long long v95 = v82;
          }
LABEL_121:
          *(_OWORD *)(a1 + 168) = v95;
          *(_OWORD *)(a1 + 184) = v94;
          *(_OWORD *)(a1 + 20CA::Context::unref(this[1], 0) = v97;
          *(_OWORD *)(a1 + 216) = v96;
          *(float64x2_t *)(a1 + 232) = v91;
          *(_OWORD *)(a1 + 248) = v82;
          *(_OWORD *)(a1 + 264) = v83;
          *(_OWORD *)(a1 + 28CA::Context::unref(this[1], 0) = v84;
LABEL_122:
          if ((a6 & 8) != 0) {
            *(_OWORD *)(a1 + 8) = *((_OWORD *)v22 + 2);
          }
          goto LABEL_124;
        }
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          unint64_t v69 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_INFO))
          {
            unsigned int v70 = v22[7];
            *(_DWORD *)long long buf = 67110144;
            *(_DWORD *)&uint8_t buf[4] = v70;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = v292;
            *(_WORD *)&buf[14] = 1024;
            *(_DWORD *)&uint8_t buf[16] = v37;
            *(_WORD *)&buf[20] = 1024;
            *(_DWORD *)&buf[22] = v35;
            *(_WORD *)&buf[26] = 1024;
            *(_DWORD *)&unsigned char buf[28] = v36;
            _os_log_impl(&dword_184668000, v69, OS_LOG_TYPE_INFO, "Slot <%d> [%d %d %d %d] occluded by clipping", buf, 0x20u);
          }
        }
      }
      else
      {
        uint64_t v44 = *((void *)v22 + 1);
        if ((v44 & 0x40000000000) == 0)
        {
          if ((v44 & 0x20000000000000) != 0) {
            int v45 = 3;
          }
          else {
            int v45 = 0;
          }
          if ((v44 & 0x20000000000000) != 0) {
            goto LABEL_110;
          }
          int v290 = v37;
          uint64_t v46 = (int32x2_t *)v22;
          if (!v41) {
            goto LABEL_110;
          }
          while (1)
          {
LABEL_73:
            double v58 = v42;
            int32x2_t v59 = v42[1];
            if ((*(void *)&v59 & 0x20000000000000) != 0)
            {
              int32x2_t v60 = v42[2];
              if (v60)
              {
                uint64_t v61 = *(void *)(*(void *)&v60 + 128);
                if (v61)
                {
                  float v62 = *(float *)(v61 + 236);
                  if (v43 && v62 > 2.0)
                  {
                    if (x_log_hook_p()) {
                      goto LABEL_101;
                    }
                    uint64_t v287 = x_log_category_render;
                    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_INFO))
                    {
                      __int32 v288 = v46[3].i32[1];
                      *(_DWORD *)long long buf = 67110400;
                      *(_DWORD *)&uint8_t buf[4] = v288;
                      *(_WORD *)&uint8_t buf[8] = 1024;
                      *(_DWORD *)&buf[10] = v292;
                      *(_WORD *)&buf[14] = 1024;
                      *(_DWORD *)&uint8_t buf[16] = v290;
                      *(_WORD *)&buf[20] = 1024;
                      *(_DWORD *)&buf[22] = v35;
                      *(_WORD *)&buf[26] = 1024;
                      *(_DWORD *)&unsigned char buf[28] = v36;
                      *(_WORD *)&uint8_t buf[32] = 2048;
                      *(int32x2_t *)&buf[34] = v60;
                      unint64_t v73 = "Slot <%d> [%d %d %d %d] occluded by border of parent layer <%p>";
                      unint64_t v74 = v287;
                      uint32_t v75 = 42;
                      goto LABEL_107;
                    }
LABEL_108:
                    int v45 = 3;
                    goto LABEL_110;
                  }
                  if (v62 > 2.0) {
                    goto LABEL_108;
                  }
                }
              }
            }
            char v63 = (int32x2_t *)((char *)v58 + v59.u8[4]);
            if ((*(void *)&v59 & 0x800000000000) != 0) {
              char v63 = (int32x2_t *)((char *)v63 + v63->i32[1]);
            }
            _ZF = (*(void *)&v59 & 0xFFFFFFLL) == 0 || v63 == v46;
            if (!_ZF)
            {
              unsigned int v65 = 1;
              while ((CA::Render::HitTestTree::Node::subtree_occludes_slot(v63, v46[3].u32[1], (int32x2_t *)v323) & 1) == 0)
              {
                char v63 = (int32x2_t *)((char *)v63 + v63->i32[1]);
                _CF = v65++ >= (v58[1].i32[0] & 0xFFFFFFu);
                if (_CF || v63 == v46) {
                  goto LABEL_92;
                }
              }
              int v45 = 1;
              goto LABEL_110;
            }
LABEL_92:
            int v45 = 0;
            uint64_t v68 = v58->u32[0];
            if (v68) {
              int v42 = (int32x2_t *)((char *)v58 - v68);
            }
            else {
              int v42 = 0;
            }
            uint64_t v46 = v58;
            if (!v68) {
              goto LABEL_110;
            }
          }
        }
      }
      int v45 = 2;
      goto LABEL_110;
    }
  }
  else if ((a6 & 0x10) == 0)
  {
    goto LABEL_13;
  }
  BOOL v29 = (unsigned int *)v20;
  while (1)
  {
    uint64_t v30 = *((void *)v29 + 1);
    if ((v30 & 0x400000000000) != 0) {
      break;
    }
    uint64_t v31 = *v29;
    BOOL v29 = (unsigned int *)((char *)v29 - v31);
    if (!v31)
    {
      unint64_t v32 = 0;
      goto LABEL_27;
    }
  }
  unint64_t v32 = v30 & 0x400000000000;
  if (byte_1EB2ACC2F) {
    CA::Render::print_hit_test(*((CA::Render **)v29 + 2), (const CA::Render::Layer *)"detected", "filters", (const char *)v21);
  }
LABEL_27:
  *(unsigned char *)(a1 + 28) = v32 >> 46;
  if (v25) {
    goto LABEL_28;
  }
LABEL_124:
  uint64_t v17 = (atomic_uint *)v295;
  if ((a6 & 0x20) == 0) {
    goto LABEL_139;
  }
  int v99 = byte_1EB2ACC82;
  if (!*(_DWORD *)(v295 + 48))
  {
    if (!byte_1EB2ACC82) {
      goto LABEL_139;
    }
    if (x_log_hook_p()) {
      goto LABEL_132;
    }
    uint64_t v101 = x_log_category_security_analysis;
    if (!os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO)) {
      goto LABEL_139;
    }
    *(_WORD *)long long buf = 0;
    id v102 = "Security Analysis requested but no context labeled as needing secure superlayers";
    goto LABEL_142;
  }
  if (v310)
  {
    if (byte_1EB2ACC82)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        double v100 = x_log_category_security_analysis;
        if (os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_184668000, v100, OS_LOG_TYPE_INFO, "Hit Asynchronous Layer Host", buf, 2u);
        }
      }
    }
    *(unsigned char *)(a1 + 442) = 8;
    *(_DWORD *)(a1 + 444) = 1065353216;
    *(_DWORD *)(a1 + 308) = 1065353216;
    *(CATransform3D *)(a1 + 312) = CATransform3DIdentity;
    *(_WORD *)(a1 + 44CA::Context::unref(this[1], 0) = 0;
    *(unsigned char *)(a1 + 448) = 1;
    goto LABEL_139;
  }
  if (!byte_1EB2ACC82)
  {
    secure_superlayers_validation_start_node = CA::Render::HitTestTree::get_secure_superlayers_validation_start_node(v295, v22);
    if (!secure_superlayers_validation_start_node) {
      goto LABEL_139;
    }
    long long v108 = (int8x16_t *)secure_superlayers_validation_start_node;
    uint64_t v109 = *secure_superlayers_validation_start_node;
    if (!v109) {
      goto LABEL_139;
    }
    int v298 = 0;
    int v110 = (unsigned int *)((char *)secure_superlayers_validation_start_node - v109);
LABEL_180:
    BOOL v128 = 1;
    double v129 = (int32x2_t *)v108;
    do
    {
      if (v128)
      {
        int32x2_t v130 = v129[2];
        if (v130)
        {
          double v131 = *(uint64_t **)(*(void *)&v130 + 128);
          if (v131)
          {
            uint64_t v132 = *v131;
            if (*v131)
            {
              int v133 = *(_DWORD *)(v132 + 12);
              if (v133 == 40)
              {
                uint64_t v135 = *(void *)(v132 + 56);
                if (v135 && (*(unsigned char *)(v135 + 13) & 0x10) != 0) {
                  goto LABEL_196;
                }
              }
              else if (v133 == 30)
              {
                uint64_t v134 = *(void *)(v132 + 80);
                if (v134)
                {
                  if (*(_WORD *)(v134 + 552) & 0x20 | v133 & 0x10000) {
                    goto LABEL_196;
                  }
                }
                else if ((v133 & 0x10000) != 0)
                {
                  goto LABEL_196;
                }
              }
            }
          }
        }
      }
      BOOL v128 = v129[3].i32[0] != 0;
      uint64_t v136 = v129->u32[0];
      double v129 = (int32x2_t *)((char *)v129 - v136);
    }
    while (v136);
    double v129 = 0;
LABEL_196:
    int v137 = byte_1EB2ACC82;
    long long v138 = xmmword_184997D50;
    long long v139 = 0uLL;
    *(_OWORD *)long long buf = xmmword_184997D50;
    *(_OWORD *)&uint8_t buf[16] = 0u;
    long long v140 = xmmword_184997D60;
    *(_OWORD *)&uint8_t buf[32] = xmmword_184997D60;
    long long v315 = 0u;
    float64x2_t v316 = 0u;
    long long v317 = xmmword_184997D50;
    long long v318 = 0u;
    long long v319 = xmmword_184997D60;
    if (v110 != (unsigned int *)v129)
    {
      double v141 = v110;
      BOOL v142 = 0;
      char v143 = 0;
      char v308 = 0;
      int v301 = 0;
      double v299 = v17 + 6;
      float v144 = 1.0;
      float v145 = 0.0039216;
      double v146 = 1.0;
      uint64_t v147 = v110;
      float v148 = 1.0;
      while (1)
      {
        if (v142)
        {
          BOOL v142 = v141[6] == 0;
          if ((v143 & 1) == 0) {
            goto LABEL_200;
          }
        }
        else
        {
          double v150 = v141;
          while (1)
          {
            unsigned int v151 = v150[6];
            if (v151) {
              break;
            }
            uint64_t v152 = *v150;
            double v150 = (unsigned int *)((char *)v150 - v152);
            if (!v152)
            {
              unsigned int v151 = 0;
              break;
            }
          }
          int v153 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v299, v151);
          BOOL v142 = v141[6] == 0;
          if (!v153)
          {
LABEL_200:
            float v149 = (float)*((unsigned __int8 *)v141 + 11) * v145;
            if (v137 && v149 < v144)
            {
              if (x_log_hook_p())
              {
                x_log_();
              }
              else
              {
                double v154 = x_log_category_security_analysis;
                if (os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO))
                {
                  uint64_t v155 = *((void *)v141 + 2);
                  if (v155)
                  {
                    uint64_t v156 = *(void *)(v155 + 120);
                    int v157 = (const char *)(v156 + 28);
                    _ZF = v156 == 0;
                    int v158 = "No Name";
                    if (!_ZF) {
                      int v158 = v157;
                    }
                  }
                  else
                  {
                    int v158 = "No Name";
                  }
                  LODWORD(v323[0].f64[0]) = 134218498;
                  *(void *)((char *)v323[0].f64 + 4) = v155;
                  WORD2(v323[0].f64[1]) = 2080;
                  *(void *)((char *)&v323[0].f64[1] + 6) = v158;
                  HIWORD(v323[1].f64[0]) = 2048;
                  v323[1].f64[1] = v149;
                  _os_log_impl(&dword_184668000, v154, OS_LOG_TYPE_INFO, "Insecure Layer <%p> <%s> (opacity %f)", (uint8_t *)v323, 0x20u);
                }
              }
            }
            v159.f64[1] = 0.0;
            v323[0] = (float64x2_t)xmmword_184997D50;
            v323[1] = 0u;
            long long v324 = xmmword_184997D60;
            long long v325 = 0u;
            long long v326 = 0u;
            long long v327 = xmmword_184997D50;
            float64x2_t v328 = 0u;
            float64x2_t v329 = (float64x2_t)xmmword_184997D60;
            if (v141 == v147)
            {
              uint64_t v192 = *((void *)v147 + 2);
              if (v192)
              {
                uint64_t v193 = *(void *)(v192 + 128);
                if (v193)
                {
                  uint64_t v194 = *(void *)(v193 + 24);
                  if (v194)
                  {
                    float v306 = v148;
                    float v195 = v145;
                    double v196 = *(double *)(v193 + 184);
                    double v197 = *(double *)(v192 + 64) + *(double *)(v193 + 168) * *(double *)(v192 + 80);
                    double v198 = *(double *)(v192 + 72) + *(double *)(v193 + 176) * *(double *)(v192 + 88);
                    v159.f64[0] = -v197;
                    CA::Mat4Impl::mat4_translate_right((float64x2_t *)buf, v106, v159, -v198, -v196);
                    if (*(_DWORD *)(v194 + 16) <= 0xFu) {
                      long long v200 = (const double *)&CA::Mat4Impl::mat4_identity_double;
                    }
                    else {
                      long long v200 = (const double *)(v194 + 24);
                    }
                    float64x2_t v201 = CA::Mat4Impl::mat4_concat((float64x2_t *)buf, (double *)buf, v200, v199);
                    v201.f64[0] = v197;
                    float64_t v202 = v198;
                    double v203 = v196;
                    double v146 = 1.0;
                    float v145 = v195;
                    float v144 = 1.0;
                    float v148 = v306;
                    CA::Mat4Impl::mat4_translate_right((float64x2_t *)buf, v204, v201, v202, v203);
                  }
                }
              }
            }
            uint64_t v160 = *((void *)v141 + 1);
            if ((v160 & 0x8000000000000) != 0)
            {
              float64x2_t v161 = *((float64x2_t *)v141 + 6);
              long long v162 = *((_OWORD *)v141 + 7);
              long long v163 = *((_OWORD *)v141 + 8);
              float64x2_t v305 = *((float64x2_t *)v141 + 5);
              v323[0] = v305;
              v323[1] = v161;
              long long v324 = v162;
              long long v325 = v163;
              long long v164 = *((_OWORD *)v141 + 10);
              float64x2_t v165 = *((float64x2_t *)v141 + 11);
              float64x2_t v166 = *((float64x2_t *)v141 + 12);
              long long v326 = *((_OWORD *)v141 + 9);
              long long v327 = v164;
              float64x2_t v328 = v165;
              float64x2_t v329 = v166;
            }
            else
            {
              v305.f64[0] = 1.0;
              if ((v160 & 0x10000000000000) != 0)
              {
                double v167 = *((double *)v141 + 10);
                double v168 = *((double *)v141 + 11);
                float64x2_t v328 = vmlaq_n_f64(vmulq_n_f64((float64x2_t)xmmword_184997D60, v168), (float64x2_t)xmmword_184997D50, v167);
                float64x2_t v329 = vmlaq_n_f64(vmlaq_n_f64((float64x2_t)xmmword_184997D60, (float64x2_t)0, v167), (float64x2_t)0, v168);
              }
            }
            CA::Mat4Impl::mat4_concat((float64x2_t *)buf, (double *)buf, v323[0].f64, v107);
            if (v137)
            {
              if (v305.f64[0] == v146)
              {
                uint64_t v169 = 1;
                while (v169 != 16)
                {
                  uint64_t v170 = v169;
                  double v171 = v323[0].f64[v169];
                  double v172 = *((double *)&CA::Mat4Impl::mat4_identity_double + v169++);
                  if (v171 != v172)
                  {
                    if ((unint64_t)(v170 - 1) <= 0xE) {
                      goto LABEL_225;
                    }
                    break;
                  }
                }
              }
              else
              {
LABEL_225:
                if (x_log_hook_p())
                {
                  x_log_();
                }
                else
                {
                  double v173 = x_log_category_security_analysis;
                  if (os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO))
                  {
                    uint64_t v174 = *((void *)v141 + 2);
                    if (v174)
                    {
                      uint64_t v175 = *(void *)(v174 + 120);
                      double v176 = (const char *)(v175 + 28);
                      _ZF = v175 == 0;
                      int v177 = "No Name";
                      if (!_ZF) {
                        int v177 = v176;
                      }
                    }
                    else
                    {
                      int v177 = "No Name";
                    }
                    *(_DWORD *)double v322 = 134218242;
                    *(void *)&v322[4] = v174;
                    *(_WORD *)&v322[12] = 2080;
                    *(void *)&v322[14] = v177;
                    _os_log_impl(&dword_184668000, v173, OS_LOG_TYPE_INFO, "Insecure Layer <%p> <%s> (non identity transform)", v322, 0x16u);
                  }
                }
              }
              if ((*((unsigned char *)v141 + 13) & 0x40) != 0)
              {
                if (x_log_hook_p())
                {
                  x_log_();
                  int v301 = 1;
                }
                else
                {
                  double v178 = x_log_category_security_analysis;
                  int v301 = 1;
                  if (os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO))
                  {
                    uint64_t v179 = *((void *)v141 + 2);
                    if (v179)
                    {
                      uint64_t v180 = *(void *)(v179 + 120);
                      unsigned int v181 = (const char *)(v180 + 28);
                      _ZF = v180 == 0;
                      unsigned int v182 = "No Name";
                      if (!_ZF) {
                        unsigned int v182 = v181;
                      }
                    }
                    else
                    {
                      unsigned int v182 = "No Name";
                    }
                    *(_DWORD *)double v322 = 134218242;
                    *(void *)&v322[4] = v179;
                    *(_WORD *)&v322[12] = 2080;
                    *(void *)&v322[14] = v182;
                    int v301 = 1;
                    _os_log_impl(&dword_184668000, v178, OS_LOG_TYPE_INFO, "Insecure Layer <%p> <%s> (insecure filters)", v322, 0x16u);
                  }
                }
              }
            }
            else
            {
              v301 |= (*((unsigned char *)v141 + 13) & 0x40) >> 6;
            }
            uint64_t v183 = (CA::Render::Layer *)*((void *)v141 + 2);
            if (v183)
            {
              BOOL has_hit_test_insecure_properties = CA::Render::Layer::has_hit_test_insecure_properties(v183, 0);
              v308 |= has_hit_test_insecure_properties;
              if (v137)
              {
                if (has_hit_test_insecure_properties)
                {
                  if (x_log_hook_p())
                  {
                    x_log_();
                    char v308 = 1;
                  }
                  else
                  {
                    int v185 = x_log_category_security_analysis;
                    char v308 = 1;
                    if (os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO))
                    {
                      uint64_t v186 = *((void *)v141 + 2);
                      if (v186)
                      {
                        uint64_t v187 = *(void *)(v186 + 120);
                        uint64_t v188 = (const char *)(v187 + 28);
                        _ZF = v187 == 0;
                        double v189 = "No Name";
                        if (!_ZF) {
                          double v189 = v188;
                        }
                      }
                      else
                      {
                        double v189 = "No Name";
                      }
                      *(_DWORD *)double v322 = 134218242;
                      *(void *)&v322[4] = v186;
                      *(_WORD *)&v322[12] = 2080;
                      *(void *)&v322[14] = v189;
                      char v308 = 1;
                      _os_log_impl(&dword_184668000, v185, OS_LOG_TYPE_INFO, "Insecure Layer <%p> <%s> (insecure properties)", v322, 0x16u);
                    }
                  }
                }
              }
            }
            char v143 = 0;
            float v148 = v149 * v148;
            goto LABEL_263;
          }
        }
        char v143 = 1;
LABEL_263:
        uint64_t v190 = *v141;
        if (v190) {
          double v141 = (unsigned int *)((char *)v141 - v190);
        }
        else {
          double v141 = 0;
        }
        if (v190) {
          BOOL v191 = v141 == (unsigned int *)v129;
        }
        else {
          BOOL v191 = 1;
        }
        if (v191)
        {
          long long v206 = *(_OWORD *)buf;
          long long v205 = *(_OWORD *)&buf[16];
          long long v208 = *(_OWORD *)&buf[32];
          long long v207 = v315;
          float64x2_t v209 = v316;
          long long v138 = v317;
          long long v139 = v318;
          long long v140 = v319;
          char v210 = v308;
          char v211 = v301;
          goto LABEL_286;
        }
      }
    }
    char v211 = 0;
    char v210 = 0;
    float v148 = 1.0;
    float64x2_t v209 = 0uLL;
    long long v207 = 0uLL;
    long long v208 = xmmword_184997D60;
    long long v205 = 0uLL;
    long long v206 = xmmword_184997D50;
LABEL_286:
    *(float *)(a1 + 308) = v148;
    *(_OWORD *)(a1 + 312) = v206;
    *(_OWORD *)(a1 + 328) = v205;
    *(_OWORD *)(a1 + 344) = v208;
    *(_OWORD *)(a1 + 36CA::Context::unref(this[1], 0) = v207;
    *(float64x2_t *)(a1 + 376) = v209;
    *(_OWORD *)(a1 + 392) = v138;
    *(_OWORD *)(a1 + 408) = v139;
    *(_OWORD *)(a1 + 424) = v140;
    *(unsigned char *)(a1 + 44CA::Context::unref(this[1], 0) = v211 & 1;
    *(unsigned char *)(a1 + 44CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v210 & 1;
    int8x16_t v213 = v108[2];
    int8x16_t v313 = v213;
    __int32 v214 = v213.i32[3];
    if (v296)
    {
      int v215 = v213.i32[2];
      if (v213.i32[2] <= v213.i32[3]) {
        int v216 = v213.i32[3];
      }
      else {
        int v216 = v213.i32[2];
      }
      if (v213.i32[2] >= v213.i32[3]) {
        int v215 = v213.i32[3];
      }
      if (v216 <= 1073741822 && v215 >= 1)
      {
        int32x2_t v217 = vmovn_s64(*v296);
        int32x2_t v218 = vadd_s32(vmovn_s64(v296[1]), v217);
        int32x2_t v219 = vadd_s32(*(int32x2_t *)v213.i8, vrev64_s32(v217));
        int32x2_t v220 = vsub_s32(vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8(v213, v213, 8uLL)), v218);
        int8x8_t v221 = (int8x8_t)vrev64_s32(v220);
        BOOL v223 = v220.i32[1] < 1 || v220.i32[0] < 1;
        BOOL v224 = !v223;
        if (v223) {
          unsigned int v225 = -1;
        }
        else {
          unsigned int v225 = 0;
        }
        *(int32x2_t *)v313.i8 = v219;
        v313.u64[1] = (unint64_t)vbic_s8(v221, (int8x8_t)vdup_n_s32(v225));
        if (v224) {
          __int32 v214 = v220.i32[0];
        }
        else {
          __int32 v214 = 0;
        }
      }
    }
    uint64_t v226 = v108->u32[0];
    if (v226) {
      unint64_t v227 = (int32x2_t *)((char *)v108 - v226);
    }
    else {
      unint64_t v227 = 0;
    }
    unint64_t v228 = v108->u64[1];
    if ((v228 & 0x40000000000) != 0)
    {
      float v230 = *(double *)((char *)v108[5].i64 + ((uint64_t)(((v228 >> 3) & 0x1F00000000) - 0xB00000000) >> 29));
      int v229 = 4;
    }
    else
    {
      int v229 = 0;
      float v230 = 0.0;
    }
    unint64_t v232 = CA::Shape::new_shape((unsigned int *)&v313);
    size_t v312 = (CA::Shape *)v232;
    if (!v226 || v227 == v129)
    {
LABEL_396:
      if ((v232 & 1) == 0 && *(int *)(v232 + 4) > 256) {
        LOBYTE(v229) = v229 | 0x10;
      }
      float v273 = (float)CA::Shape::area((CA::Shape *)v232);
      float v274 = (float)(v214 * v313.i32[2]);
      if ((v108->i8[13] & 4) != 0 && v230 < 1.0) {
        float v274 = v274 / (float)(1.0 - v230);
      }
      if ((float)(v273 - v274) > 0.01)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          float64x2_t v289 = x_log_category_security_analysis;
          if (os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 134218240;
            *(double *)&uint8_t buf[4] = v273;
            *(_WORD *)&buf[12] = 2048;
            *(double *)&buf[14] = v274;
            _os_log_impl(&dword_184668000, v289, OS_LOG_TYPE_ERROR, "Error: Unoccluded area (%f) is larger than original area (%f)", buf, 0x16u);
          }
        }
      }
      float v275 = 1.0 - (float)(v273 / v274);
      BOOL v276 = v275 > 1.0 || v275 < 0.0;
      if (v275 < 0.0 && v275 <= 1.0) {
        *(float *)&int v277 = 0.0;
      }
      else {
        *(float *)&int v277 = 1.0;
      }
      if (v276) {
        float v278 = *(float *)&v277;
      }
      else {
        float v278 = 1.0 - (float)(v273 / v274);
      }
      CA::Shape::unref((CA::Shape *)v232);
      *(unsigned char *)(a1 + 442) = v229;
      *(float *)(a1 + 444) = v278;
      *(unsigned char *)(a1 + 448) = 1;
      uint64_t v17 = (atomic_uint *)v295;
      if (!v298) {
        goto LABEL_139;
      }
      if (x_log_hook_p()) {
        goto LABEL_132;
      }
      uint64_t v279 = x_log_category_security_analysis;
      if (!os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO)) {
        goto LABEL_139;
      }
      double v280 = *(float *)(a1 + 308);
      int v281 = *(unsigned __int8 *)(a1 + 440);
      int v282 = *(unsigned __int8 *)(a1 + 441);
      int v283 = *(unsigned __int8 *)(a1 + 442);
      double v284 = (float)(*(float *)(a1 + 444) * 100.0);
      *(_DWORD *)long long buf = 134219008;
      *(double *)&uint8_t buf[4] = v280;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v281;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v282;
      *(_WORD *)&uint8_t buf[24] = 1024;
      *(_DWORD *)&buf[26] = v283;
      *(_WORD *)&buf[30] = 2048;
      *(double *)&uint8_t buf[32] = v284;
      id v102 = "Security Results [opacity: %f] [insecure filtered: %d] [insecure properties: %d] [occlusion: %d (%.2f%% occluded)]";
      double v103 = v279;
      uint32_t v104 = 40;
      goto LABEL_143;
    }
    float64x2_t v303 = (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL);
    float64x2_t v307 = (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000);
    size_t v309 = v108;
    while (1)
    {
      float v233 = v227;
      int32x2_t v234 = v227[1];
      if ((*(void *)&v234 & 0x20000000000000) == 0) {
        goto LABEL_343;
      }
      if ((v312 & 1) != 0 || *((int *)v312 + 1) < 257)
      {
        int32x2_t v235 = v227[2];
        if (!*(void *)&v235) {
          goto LABEL_342;
        }
        uint64_t v236 = *(void *)(*(void *)&v235 + 128);
        if (!v236) {
          goto LABEL_342;
        }
        float v237 = *(float *)(v236 + 236);
        if (v237 < 2.0) {
          goto LABEL_342;
        }
        int32x2_t v238 = v227[7];
        uint32x2_t v239 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v238);
        __int32 v214 = v313.i32[3];
        if ((vpmax_u32(v239, v239).u32[0] & 0x80000000) != 0) {
          goto LABEL_342;
        }
        uint32x2_t v240 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v313.u64[1]);
        if ((vpmax_u32(v240, v240).u32[0] & 0x80000000) != 0) {
          goto LABEL_342;
        }
        uint32x2_t v241 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(vadd_s32(v227[6], v238), vadd_s32(*(int32x2_t *)v313.i8, (int32x2_t)v313.u64[1])), vmax_s32(v227[6], *(int32x2_t *)v313.i8)));
        if ((vpmax_u32(v241, v241).u32[0] & 0x80000000) != 0) {
          goto LABEL_342;
        }
        uint64_t v300 = v313.i64[0];
        __int32 v302 = v313.i32[2];
        int v243 = (int)v227[7];
        v323[0] = *(float64x2_t *)v227[6].i8;
        int v242 = HIDWORD(v323[0].f64[1]);
        if (SLODWORD(v323[0].f64[1]) <= SHIDWORD(v323[0].f64[1])) {
          int v244 = HIDWORD(v323[0].f64[1]);
        }
        else {
          int v244 = v243;
        }
        if (SLODWORD(v323[0].f64[1]) >= SHIDWORD(v323[0].f64[1])) {
          int v245 = HIDWORD(v323[0].f64[1]);
        }
        else {
          int v245 = v243;
        }
        if (v244 <= 1073741822 && v245 >= 1)
        {
          *(int32x2_t *)&v323[0].f64[0] = vadd_s32(*(int32x2_t *)&v323[0].f64[0], vdup_n_s32((int)v237));
          LODWORD(v323[0].f64[1]) = v243 - 2 * (int)v237;
          HIDWORD(v323[0].f64[1]) -= 2 * (int)v237;
          if (SLODWORD(v323[0].f64[1]) < 1 || v242 - 2 * (int)v237 <= 0) {
            v323[0].f64[1] = 0.0;
          }
        }
        if (CA::BoundsImpl::contains(v323, &v313)) {
          goto LABEL_342;
        }
        *(void *)double v322 = CA::Shape::new_shape((unsigned int *)&v227[6]);
        CA::shape_subtract((CA::Shape **)v322, (CA::Shape **)v323, v254);
        float v255 = *(CA::Shape **)v322;
        CA::shape_subtract(&v312, *(CA::Shape ***)v322, v256, v257);
        CA::Shape::unref(v255);
        if (byte_1EB2ACC82)
        {
          if (x_log_hook_p())
          {
            CA::Shape::area(v312);
            x_log_();
          }
          else
          {
            uint64_t v266 = x_log_category_security_analysis;
            if (os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO))
            {
              int32x2_t v267 = v227[2];
              if (v267)
              {
                uint64_t v268 = *(void *)(*(void *)&v267 + 120);
                double v269 = (const char *)(v268 + 28);
                _ZF = v268 == 0;
                int32x4_t v270 = "No Name";
                if (!_ZF) {
                  int32x4_t v270 = v269;
                }
              }
              else
              {
                int32x4_t v270 = "No Name";
              }
              float64x2_t v291 = v270;
              __int32 v271 = v227[6].i32[0];
              unsigned int v293 = v233[6].u32[1];
              unsigned int v294 = v233[7].u32[0];
              unsigned int v297 = v233[7].u32[1];
              uint64_t v272 = CA::Shape::area(v312);
              *(_DWORD *)long long buf = 136317954;
              *(void *)&uint8_t buf[4] = v291;
              *(_WORD *)&buf[12] = 2048;
              *(int32x2_t *)&buf[14] = v267;
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&uint8_t buf[24] = v271;
              *(_WORD *)&unsigned char buf[28] = 1024;
              *(_DWORD *)&buf[30] = v293;
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = v294;
              *(_WORD *)&uint8_t buf[40] = 1024;
              *(_DWORD *)&buf[42] = v297;
              *(_WORD *)&buf[46] = 2048;
              *(double *)&long long v315 = v237;
              WORD4(v315) = 1024;
              *(_DWORD *)((char *)&v315 + 1CA::Context::unref(this[1], 0) = v300;
              HIWORD(v315) = 1024;
              LODWORD(v316.f64[0]) = HIDWORD(v300);
              WORD2(v316.f64[0]) = 1024;
              *(_DWORD *)((char *)v316.f64 + 6) = v302;
              WORD1(v316.f64[1]) = 1024;
              HIDWORD(v316.f64[1]) = v214;
              LOWORD(v317) = 2048;
              *(void *)((char *)&v317 + 2) = v272;
              _os_log_impl(&dword_184668000, v266, OS_LOG_TYPE_INFO, "Layer (%s) <%p> [%d %d %d %d] has border width %f that occludes view [%d %d %d %d] unoccluded area is now %ld", buf, 0x5Au);
            }
          }
        }
      }
      v229 |= 8u;
LABEL_342:
      int32x2_t v234 = v233[1];
LABEL_343:
      size_t v248 = (int32x2_t *)((char *)v233 + v234.u8[4]);
      CA::Render::Update::subtract_corner_radii_clipping_from_shape(*(void *)&v233[2], &v312, v231);
      int32x2_t v249 = v233[1];
      if ((*(void *)&v249 & 0x800000000000) != 0)
      {
        uint64_t v250 = (uint64_t)v248[2];
        if (!v250) {
          goto LABEL_367;
        }
        uint64_t v251 = *(void *)(v250 + 128);
        if (!v251) {
          goto LABEL_365;
        }
        if (*(void *)(v251 + 96) || *(void *)(v251 + 112))
        {
LABEL_348:
          *(void *)long long buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          float v252 = (CA::Shape **)buf;
          goto LABEL_349;
        }
        uint64_t v253 = *(void *)v251;
        if (*(void *)v251)
        {
          if (*(unsigned char *)(v253 + 12) == 46)
          {
            if (!*(void *)(v253 + 16)
              || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(*(float32x4_t *)(v253 + 24))))) & 1) == 0
              && !*(void *)(v253 + 40))
            {
              goto LABEL_348;
            }
            goto LABEL_364;
          }
          memset(buf, 0, 32);
          memset(v323, 0, sizeof(v323));
          if ((*(unsigned int (**)(uint64_t, uint64_t, unsigned char *, float64x2_t *))(*(void *)v253 + 184))(v253, v250, buf, v323))
          {
            int64x2_t v258 = vceqzq_f64(v323[1]);
            if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v258, 1), (int8x16_t)v258).u64[0] & 0x8000000000000000) != 0
              || (int8x16_t v259 = vorrq_s8((int8x16_t)vcltzq_f64(v323[1]), (int8x16_t)vcgezq_f64(v323[1])),
                  (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v259), 1), v259).u64[0] & 0x8000000000000000) != 0))
            {
              *(void *)double v322 = 0;
              *(void *)&v322[8] = 0;
            }
            else
            {
              int32x4_t v260 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v323[0], v307));
              *(int32x4_t *)double v322 = vuzp1q_s32(v260, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v323[0], v323[1]), v303)), (int64x2_t)v260));
            }
            float v252 = (CA::Shape **)v322;
LABEL_349:
            CA::shape_intersect(&v312, v252, (const CA::Bounds *)v231);
LABEL_367:
            size_t v248 = (int32x2_t *)((char *)v248 + v248->i32[1]);
            int32x2_t v249 = v233[1];
            goto LABEL_368;
          }
          uint64_t v251 = *(void *)(v250 + 128);
          if (v251) {
            goto LABEL_364;
          }
LABEL_365:
          CA::Render::Layer::max_corner_radii(v251);
          if (v261 <= 0.0) {
            goto LABEL_367;
          }
        }
        else
        {
LABEL_364:
          if (*(float *)(v251 + 228) <= 0.0) {
            goto LABEL_365;
          }
        }
        CA::Render::Update::subtract_corner_radii_clipping_from_shape(v250, &v312, v231);
        goto LABEL_367;
      }
LABEL_368:
      if ((*(void *)&v249 & 0xFFFFFFLL) != 0 && v248 != (int32x2_t *)v108)
      {
        unsigned int v263 = 1;
        do
        {
          if (CA::Render::HitTestTree::Node::subtract_subtree_occlusion_from_shape(v248, (int32x2_t *)&v313, &v312))v229 |= 2u; {
          size_t v248 = (int32x2_t *)((char *)v248 + v248->i32[1]);
          }
          _CF = v263++ >= (v233[1].i32[0] & 0xFFFFFFu);
        }
        while (!_CF && v248 != (int32x2_t *)v108);
      }
      uint64_t v265 = v233->u32[0];
      if (v265) {
        unint64_t v227 = (int32x2_t *)((char *)v233 - v265);
      }
      else {
        unint64_t v227 = 0;
      }
      if (v265)
      {
        long long v108 = (int8x16_t *)v233;
        if (v227 != v129) {
          continue;
        }
      }
      unint64_t v232 = (unint64_t)v312;
      long long v108 = v309;
      goto LABEL_396;
    }
  }
  x_log_begin();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    char v111 = x_log_category_security_analysis;
    if (os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO))
    {
      uint64_t v112 = *(void *)(v295 + 48);
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v112;
      _os_log_impl(&dword_184668000, v111, OS_LOG_TYPE_INFO, "%zu start ctxs [", buf, 0xCu);
    }
  }
  for (char i = *(uint64_t **)(v295 + 40); i; char i = (uint64_t *)*i)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      unsigned int v114 = x_log_category_security_analysis;
      if (os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO))
      {
        int v115 = *((_DWORD *)i + 4);
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v115;
        _os_log_impl(&dword_184668000, v114, OS_LOG_TYPE_INFO, " %x;", buf, 8u);
      }
    }
  }
  int v298 = v99;
  double v304 = (void **)x_stream_pop_(0);
  unsigned int v116 = x_stream_get(v304);
  int v117 = 0;
  while (2)
  {
    uint64_t v118 = 0;
    uint64_t v119 = &v116[v117];
    int v120 = -1;
    while (1)
    {
      if (v119[v118] == 10)
      {
        int v120 = v118;
        goto LABEL_161;
      }
      if (!v119[v118]) {
        break;
      }
LABEL_161:
      ++v118;
      unsigned int v121 = 32512;
      if (v118 == 32512) {
        goto LABEL_162;
      }
    }
    unsigned int v121 = v118;
LABEL_162:
    if (v120 <= -1 || v119[v121] == 0) {
      int v123 = v121;
    }
    else {
      int v123 = v120 + 1;
    }
    if (v123 >= 1)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        int v124 = x_log_category_security_analysis;
        if (os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 136315650;
          if (v117) {
            uint64_t v125 = "continued...\n";
          }
          else {
            uint64_t v125 = "";
          }
          *(void *)&uint8_t buf[4] = v125;
          *(_WORD *)&buf[12] = 1040;
          *(_DWORD *)&buf[14] = v123;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = &v116[v117];
          _os_log_impl(&dword_184668000, v124, OS_LOG_TYPE_INFO, "%s%.*s", buf, 0x1Cu);
        }
      }
      v117 += v123;
      continue;
    }
    break;
  }
  x_log_end_free_(v304);
  uint64_t v17 = (atomic_uint *)v295;
  float64x2x2_t v126 = CA::Render::HitTestTree::get_secure_superlayers_validation_start_node(v295, v22);
  if (v126)
  {
    long long v108 = (int8x16_t *)v126;
    uint64_t v127 = *v126;
    if (v127)
    {
      int v110 = (unsigned int *)((char *)v126 - v127);
      goto LABEL_180;
    }
    if (x_log_hook_p())
    {
      do
      {
        if (v108[1].i32[2]) {
          break;
        }
        uint64_t v212 = v108->u32[0];
        long long v108 = (int8x16_t *)((char *)v108 - v212);
      }
      while (v212);
LABEL_132:
      x_log_();
      goto LABEL_139;
    }
    uint64_t v285 = x_log_category_security_analysis;
    if (!os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO)) {
      goto LABEL_139;
    }
    do
    {
      LODWORD(v286) = v108[1].i32[2];
      if (v286) {
        break;
      }
      uint64_t v286 = v108->u32[0];
      long long v108 = (int8x16_t *)((char *)v108 - v286);
    }
    while (v286);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v286;
    id v102 = "Nothing above start ctx [%x] to test";
    double v103 = v285;
    uint32_t v104 = 8;
LABEL_143:
    _os_log_impl(&dword_184668000, v103, OS_LOG_TYPE_INFO, v102, buf, v104);
    goto LABEL_139;
  }
  if (x_log_hook_p()) {
    goto LABEL_132;
  }
  uint64_t v101 = x_log_category_security_analysis;
  if (os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    id v102 = "no secure ctxs were hit";
LABEL_142:
    double v103 = v101;
    uint32_t v104 = 2;
    goto LABEL_143;
  }
LABEL_139:
  CA::Render::HitTestTree::unref((CA::Render::HitTestTree *)v17);
}

void CA::Render::HitTestTree::unref(CA::Render::HitTestTree *this)
{
  unsigned int add = atomic_fetch_add((atomic_uint *volatile)this, 0xFFFFFFFF);
  if (this && add == 1)
  {
    uint64_t v3 = *((unsigned int *)this + 1);
    if (v3)
    {
      unint64_t v4 = *((void *)this + 2);
      unint64_t v5 = v4 + v3;
      do
      {
        int v6 = *(atomic_uint **)(v4 + 16);
        if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
        }
        v4 += *(unsigned __int8 *)(v4 + 12);
      }
      while (v4 < v5);
    }
    if (*((_DWORD *)this + 2) == 4 * *MEMORY[0x1E4F14B00])
    {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::HitTestTree::storage_cache_lock);
      uint64_t v7 = 0;
      while (CA::Render::HitTestTree::storage_cache[v7])
      {
        if (++v7 == 2) {
          goto LABEL_16;
        }
      }
      CA::Render::HitTestTree::storage_cache[v7] = *((void *)this + 2);
      *((void *)this + 2) = 0;
LABEL_16:
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::HitTestTree::storage_cache_lock);
    }
    free(*((void **)this + 2));
    std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)this + 24);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, this);
  }
}

double CA::WindowServer::Server::context_transform(CA::WindowServer::Server *this, uint64_t a2, uint64_t a3)
{
  int v6 = (os_unfair_lock_s *)(a2 + 324);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 324));
  uint64_t v7 = *(atomic_uint **)(a2 + 328);
  if (v7)
  {
    atomic_fetch_add(v7, 1u);
    os_unfair_lock_unlock(v6);
    *(_OWORD *)this = xmmword_184997D50;
    *((_OWORD *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0u;
    *((_OWORD *)this + 2) = xmmword_184997D60;
    *((_OWORD *)this + 3) = 0u;
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + 5) = xmmword_184997D50;
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = xmmword_184997D60;
    CA::Render::HitTestTree::context_transform((uint64_t)v7, a3, (uint64_t)this, v8);
    CA::Render::HitTestTree::unref((CA::Render::HitTestTree *)v7);
  }
  else
  {
    os_unfair_lock_unlock(v6);
    double result = 1.0;
    *(_OWORD *)this = xmmword_184997D50;
    *((_OWORD *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0u;
    *((_OWORD *)this + 2) = xmmword_184997D60;
    *((_OWORD *)this + 3) = 0u;
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + 5) = xmmword_184997D50;
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = xmmword_184997D60;
  }
  return result;
}

uint64_t CA::Render::HitTestTree::context_transform(uint64_t a1, uint64_t a2, uint64_t a3, const double *a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 4);
  if (v4)
  {
    uint64_t v7 = *(unsigned int **)(a1 + 16);
    int v8 = (unsigned int *)((char *)v7 + v4);
    do
    {
      uint64_t v9 = *((void *)v7 + 1);
      if (v7[6] == a2)
      {
        uint64_t v10 = *v7;
        double v11 = (char *)v7 - v10;
        if ((v9 & 0x800000000000000) != 0)
        {
          if (v10)
          {
            uint64_t v19 = *((void *)v11 + 2);
            if (v19)
            {
              uint64_t v20 = *(uint64_t **)(v19 + 128);
              if (v20)
              {
                uint64_t v21 = *v20;
                if (v21)
                {
                  if ((*(_DWORD *)(v21 + 12) & 0x80FF) == 0x8028)
                  {
LABEL_26:
                    uint64_t v22 = 1;
                    CA::Render::HitTestTree::Node::relative_transform_product((CA::Mat4Impl *)v31, (unsigned int *)v11, 1, a4);
                    long long v24 = v31[1];
                    long long v25 = v31[2];
                    long long v26 = v31[3];
                    *(_OWORD *)a3 = v31[0];
                    *(_OWORD *)(a3 + 16) = v24;
                    *(_OWORD *)(a3 + 32) = v25;
                    *(_OWORD *)(a3 + 48) = v26;
                    long long v27 = v31[5];
                    long long v28 = v31[6];
                    long long v29 = v31[7];
                    *(_OWORD *)(a3 + 64) = v31[4];
                    *(_OWORD *)(a3 + 8CA::Context::unref(this[1], 0) = v27;
                    *(_OWORD *)(a3 + 96) = v28;
                    *(_OWORD *)(a3 + 112) = v29;
                    return v22;
                  }
                }
              }
            }
          }
        }
        else if (v10)
        {
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v12 = *((void *)v7 + 2);
        if (v12) {
          BOOL v13 = (v9 & 0x800000000000000) == 0;
        }
        else {
          BOOL v13 = 0;
        }
        if (v13)
        {
          uint64_t v14 = *(CA::Render::LayerHost ***)(v12 + 128);
          if (v14)
          {
            int v15 = *v14;
            if (*v14)
            {
              if (*((unsigned char *)v15 + 12) == 30)
              {
                uint64_t v16 = CA::Render::LayerHost::retain_async_hit_test_tree(v15);
                if (v16)
                {
                  uint64_t v17 = (CA::Render::HitTestTree *)v16;
                  if (CA::Render::HitTestTree::context_transform(v16, a2, a3))
                  {
                    uint64_t v22 = 1;
                    CA::Render::HitTestTree::Node::relative_transform_product((CA::Mat4Impl *)v31, v7, 1, v18);
                    CA::Mat4Impl::mat4_concat((float64x2_t *)a3, (double *)a3, (const double *)v31, v30);
                    CA::Render::HitTestTree::unref(v17);
                    return v22;
                  }
                  CA::Render::HitTestTree::unref(v17);
                }
              }
            }
          }
        }
      }
      uint64_t v7 = (unsigned int *)((char *)v7 + BYTE4(v9));
    }
    while (v7 < v8);
  }
  return 0;
}

uint64_t CA::Render::LayerHost::retain_async_hit_test_tree(CA::Render::LayerHost *this)
{
  if (!*((void *)this + 4)) {
    return 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3)
    {
      uint64_t v4 = (os_unfair_lock_s *)(v3 + 180);
      os_unfair_lock_lock((os_unfair_lock_t)(v3 + 180));
      uint64_t v3 = *(void *)(v3 + 184);
      if (v3) {
        atomic_fetch_add((atomic_uint *volatile)v3, 1u);
      }
      os_unfair_lock_unlock(v4);
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
  return v3;
}

void CA::Render::HitTestTree::Node::relative_transform_product(CA::Mat4Impl *this, unsigned int *a2, char a3, const double *a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)this = xmmword_184997D50;
  *((_OWORD *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0u;
  *((_OWORD *)this + 2) = xmmword_184997D60;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = xmmword_184997D50;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = xmmword_184997D60;
  if (a2)
  {
    unint64_t v5 = a2;
    while (1)
    {
      uint64_t v7 = *((void *)v5 + 2);
      if (v7)
      {
        if ((a3 & 1) == 0)
        {
          int v8 = *(uint64_t **)(v7 + 128);
          if (v8)
          {
            uint64_t v9 = *v8;
            if (v9)
            {
              if ((*(_DWORD *)(v9 + 12) & 0x20FF) == 0x201E) {
                return;
              }
            }
          }
        }
      }
      long long v20 = xmmword_184997D50;
      long long v21 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v22 = xmmword_184997D60;
      long long v25 = xmmword_184997D50;
      float64x2_t v26 = 0u;
      long long v27 = xmmword_184997D60;
      uint64_t v10 = *((void *)v5 + 1);
      if ((v10 & 0x8000000000000) != 0) {
        break;
      }
      if ((v10 & 0x10000000000000) != 0)
      {
        double v11 = *((double *)v5 + 10);
        double v12 = *((double *)v5 + 11);
        float64x2_t v13 = vmlaq_n_f64(vmulq_n_f64((float64x2_t)xmmword_184997D60, v12), (float64x2_t)xmmword_184997D50, v11);
        float64x2_t v14 = vmlaq_n_f64(vmlaq_n_f64((float64x2_t)xmmword_184997D60, (float64x2_t)0, v11), (float64x2_t)0, v12);
LABEL_12:
        float64x2_t v26 = v13;
        long long v27 = (__int128)v14;
      }
      CA::Mat4Impl::mat4_concat((float64x2_t *)this, (double *)this, (const double *)&v20, a4);
      uint64_t v19 = *v5;
      if (v19) {
        unint64_t v5 = (unsigned int *)((char *)v5 - v19);
      }
      else {
        unint64_t v5 = 0;
      }
      if (!v19) {
        return;
      }
    }
    long long v15 = *((_OWORD *)v5 + 6);
    long long v16 = *((_OWORD *)v5 + 7);
    long long v17 = *((_OWORD *)v5 + 8);
    long long v20 = *((_OWORD *)v5 + 5);
    long long v21 = v15;
    long long v22 = v16;
    long long v23 = v17;
    long long v18 = *((_OWORD *)v5 + 10);
    float64x2_t v13 = *((float64x2_t *)v5 + 11);
    float64x2_t v14 = *((float64x2_t *)v5 + 12);
    long long v24 = *((_OWORD *)v5 + 9);
    long long v25 = v18;
    goto LABEL_12;
  }
}

void sub_1847BA104(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::WindowServer::Server::set_color_matrix(CA::WindowServer::Server *this, const float *a2, float a3, double a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v8 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  (*(void (**)(void, const float *, float, double))(**((void **)this + 12) + 1416))(*((void *)this + 12), a2, a3, a4);
  if (byte_1EB2ACC84)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      uint64_t v10 = x_log_category_CADebug;
      if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "set_color_matrix";
        _os_log_impl(&dword_184668000, v10, OS_LOG_TYPE_INFO, "kUpdateReasonDisplayBrightness %s", buf, 0xCu);
      }
    }
  }
  *(void *)long long buf = 0;
  *(int64x2_t *)&uint8_t buf[8] = vdupq_n_s64(8uLL);
  (*(void (**)(CA::WindowServer::Server *, unsigned char *, double))(*(void *)this + 184))(this, buf, 0.0);
  return pthread_mutex_unlock(v8);
}

void CA::WindowServer::IOMFBDisplay::set_color_matrix(CA::WindowServer::IOMFBDisplay *this, const float *a2, float a3, double a4)
{
  long long v6 = *(_OWORD *)((char *)this + 26824);
  *((_OWORD *)this + 167CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(_OWORD *)((char *)this + 26808);
  uint64_t v7 = (char *)this + 26772;
  *((_OWORD *)this + 1672) = v6;
  *((_DWORD *)this + 6692) = *((_DWORD *)this + 6710);
  *((_DWORD *)this + 671CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *((_DWORD *)this + 6713);
  if (a2)
  {
    long long v8 = *(_OWORD *)a2;
    long long v9 = *((_OWORD *)a2 + 1);
    *((float *)this + 670CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = a2[8];
    *(_OWORD *)uint64_t v7 = v8;
    *(_OWORD *)((char *)this + 26788) = v9;
    *((float *)this + 6712) = a3;
  }
  else
  {
    *(_OWORD *)uint64_t v7 = xmmword_184997DC0;
    *(_OWORD *)((char *)this + 26788) = xmmword_184997DC0;
    *((_DWORD *)this + 670CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 1065353216;
  }
  uint64_t v10 = mach_absolute_time();
  *((double *)this + 334CA::Context::unref(this[1], 0) = CATimeWithHostTime(v10);
  *((double *)this + 334CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = a4;
  v7[84] = 0;
}

uint64_t CARenderRetain(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (atomic_uint *)(result + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(result + 8), 1u))
    {
      double result = 0;
      atomic_fetch_add(v1, 0xFFFFFFFF);
    }
  }
  return result;
}

uint64_t init_suspended(void *a1)
{
  {
    init_suspended(void *)::notificatiouint64_t n = objc_alloc_init(CASuspendNotification);
  }
  uint64_t v1 = (void *)[MEMORY[0x1E4F28EB8] defaultCenter];
  [v1 addObserver:init_suspended(void *)::notification selector:sel_willSuspend_ name:@"UIApplicationDidEnterBackgroundNotification" object:0];
  [v1 addObserver:init_suspended(void *)::notification selector:sel_willUnsuspend_ name:@"UIApplicationWillEnterForegroundNotification" object:0];
  uint64_t v2 = init_suspended(void *)::notification;

  return [v1 addObserver:v2 selector:sel_willUnsuspend_ name:@"UIApplicationDidFinishLaunchingNotification" object:0];
}

void sub_1847BA5FC(_Unwind_Exception *a1)
{
}

CA::Render::LayerHost *CA::Render::LayerHost::LayerHost(CA::Render::LayerHost *this, CA::Render::Decoder *a2)
{
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0x1E;
  ++dword_1EB2ADE40;
  *(void *)this = &unk_1ED0300E8;
  int v4 = CA::Render::Decoder::decode_int32(a2);
  *(_OWORD *)((char *)this + 4CA::Context::unref(this[1], 0) = 0u;
  *((_DWORD *)this + 4) = v4;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 8) = CA::Render::Decoder::decode_int64(a2);
  int v5 = CA::Render::Decoder::decode_int32(a2);
  std::vector<unsigned long long>::resize((char **)this + 5, v5);
  CA::Render::Decoder::decode_bytes(a2, *((void **)this + 5), 8 * v5);
  int v6 = *((_DWORD *)this + 3);
  if (byte_1EB2ACC0B)
  {
    v6 &= ~0x400u;
    *((_DWORD *)this + 3) = v6;
    if ((v6 & 0x2000) == 0) {
      goto LABEL_5;
    }
  }
  else if ((v6 & 0x2000) == 0)
  {
    goto LABEL_5;
  }
  if ((*(_WORD *)(*((void *)a2 + 9) + 552) & 0x200) == 0)
  {
    CA::Render::Decoder::set_fatal_error(a2, "Missing entitlement for system layer!");
    int v6 = *((_DWORD *)this + 3);
  }
LABEL_5:
  if ((v6 & 0x10000) != 0 && (*(_WORD *)(*((void *)a2 + 9) + 552) & 0x400) == 0) {
    CA::Render::Decoder::set_fatal_error(a2, "Missing entitlement for secure layer!");
  }
  return this;
}

void std::vector<unsigned long long>::resize(char **a1, unint64_t a2)
{
  uint64_t v3 = *a1;
  int v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 3;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    long long v16 = &v3[8 * a2];
    goto LABEL_16;
  }
  unint64_t v6 = a2 - v5;
  uint64_t v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 3)
  {
    bzero(a1[1], 8 * v6);
    long long v16 = &v4[8 * v6];
LABEL_16:
    a1[1] = v16;
    return;
  }
  if (a2 >> 61) {
    abort();
  }
  uint64_t v8 = v7 - v3;
  uint64_t v9 = v8 >> 2;
  if (v8 >> 2 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  if (v10 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  double v11 = (char *)operator new(8 * v10);
  uint64_t v12 = &v11[8 * v5];
  float64x2_t v13 = &v11[8 * v10];
  bzero(v12, 8 * v6);
  float64x2_t v14 = &v12[8 * v6];
  while (v4 != v3)
  {
    uint64_t v15 = *((void *)v4 - 1);
    v4 -= 8;
    *((void *)v12 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v15;
    v12 -= 8;
  }
  *a1 = v12;
  a1[1] = v14;
  a1[2] = v13;
  if (v3)
  {
    operator delete(v3);
  }
}

void ___ZN2CA3OGLL17release_iosurfaceEP11__IOSurface_block_invoke_2(uint64_t a1)
{
}

CATransform3D *__cdecl CATransform3DMakeTranslation(CATransform3D *__return_ptr retstr, CGFloat tx, CGFloat ty, CGFloat tz)
{
  *(_OWORD *)&retstr->m11 = xmmword_184997D50;
  retstr->m13 = 0.0;
  retstr->m14 = 0.0;
  *(_OWORD *)&retstr->m21 = xmmword_184997D60;
  *(_OWORD *)&retstr->m23 = 0u;
  *(_OWORD *)&retstr->m31 = 0u;
  *(_OWORD *)&retstr->m33 = xmmword_184997D50;
  *(_OWORD *)&retstr->m43 = xmmword_184997D60;
  retstr->m41 = tx;
  retstr->m42 = ty;
  retstr->m43 = tz;
  return result;
}

char *CA::Render::BackdropState::copy_isolated(CA::Render::BackdropState *this, CA::Render::Update *a2, int a3)
{
  v30[1] = *MEMORY[0x1E4F143B8];
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v7 = (char *)malloc_type_zone_malloc(malloc_zone, 0x68uLL, 0x8BB15036uLL);
  uint64_t v8 = v7;
  if (v7)
  {
    *((_DWORD *)v7 + 2) = 1;
    *((_DWORD *)v7 + 3) = 4;
    ++dword_1EB2ADDD8;
    *(void *)uint64_t v7 = &unk_1ED02D930;
    *((void *)v7 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
    *((_WORD *)v7 + 48) = 0;
    *((_OWORD *)v7 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0u;
    *((_OWORD *)v7 + 2) = 0u;
    *((_OWORD *)v7 + 3) = 0u;
    *((_OWORD *)v7 + 4) = 0u;
    *(void *)(v7 + 77) = 0;
  }
  *((void *)v7 + 2) = *((void *)this + 2);
  *((void *)v7 + 3) = *((void *)this + 3);
  *((_DWORD *)v7 + 8) = *((_DWORD *)this + 8);
  uint64_t v9 = (void *)*((void *)a2 + 63);
  if (v9)
  {
    while (1)
    {
      uint64_t v10 = v9[1];
      double v11 = *(uint64_t **)(*(void *)(v10 + 32) + 128);
      if (v11)
      {
        uint64_t v12 = *v11;
        if (v12)
        {
          if (*(unsigned char *)(v12 + 12) == 3)
          {
            uint64_t v13 = *(void *)(v12 + 88);
            if (v13)
            {
              if (*(void *)(v13 + 40) == *((void *)this + 5)
                && (*(unsigned char *)(v10 + 27) & 8) == 0
                && (*((_DWORD *)a2 + 271) & 0x8000000) == 0)
              {
                break;
              }
            }
          }
        }
      }
      uint64_t v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_12;
      }
    }
    float64x2_t v26 = *(atomic_uint **)(*(void *)(v10 + 256) + 40);
    long long v27 = (atomic_uint *)*((void *)v7 + 5);
    if (v27 != v26)
    {
      if (v27 && atomic_fetch_add(v27 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v27 + 16))(v27);
      }
      if (v26)
      {
        uint64_t v28 = v26 + 2;
        if (!atomic_fetch_add(v26 + 2, 1u))
        {
          float64x2_t v26 = 0;
          atomic_fetch_add(v28, 0xFFFFFFFF);
        }
      }
      *((void *)v8 + 5) = v26;
    }
  }
LABEL_12:
  if (!*((void *)v8 + 5))
  {
    if (a3)
    {
      CA::Render::BackdropGroup::retain_group(v30, *((void *)this + 2), *(void *)(*((void *)this + 5) + 32), *((unsigned __int8 *)this + 84), *((float *)this + 8));
      uint64_t v15 = v30[0];
    }
    else
    {
      uint64_t v16 = *((void *)this + 2);
      uint64_t v17 = *(void *)(*((void *)this + 5) + 32);
      int v18 = *((unsigned __int8 *)this + 84);
      float v19 = *((float *)this + 8);
      uint64_t v29 = 0;
      CA::Render::BackdropGroup::retain_group_common(&v29, v16, v17, v18, (uint64_t)a2 + 552, 2, 1, v19);
      if ((*((_DWORD *)a2 + 271) & 0x2000) != 0)
      {
        v30[0] = 0;
        CA::Render::BackdropGroup::retain_group(v30, v16, v17, v18, v19);
        long long v20 = (atomic_uint *)v30[0];
        if (v30[0])
        {
          uint64_t v21 = *(void *)(v30[0] + 48);
          if (v21)
          {
            uint64_t v22 = v29;
            uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 16))(v21);
            uint64_t v24 = *(void *)(v22 + 48);
            if (v24 != v23)
            {
              if (v24) {
                (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
              }
              *(void *)(v22 + 48) = v23;
            }
          }
          if (atomic_fetch_add(v20 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v20 + 16))(v20);
          }
        }
      }
      uint64_t v15 = v29;
    }
    long long v25 = (atomic_uint *)*((void *)v8 + 5);
    *((void *)v8 + 5) = v15;
    if (v25 && atomic_fetch_add(v25 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v25 + 16))(v25);
    }
  }
  return v8;
}

void CA::Render::BackdropGroup::retain_group(void *a1, uint64_t a2, uint64_t a3, int a4, float a5)
{
  os_unfair_lock_lock(&CA::Render::BackdropGroup::_list_lock);
  CA::Render::BackdropGroup::retain_group_common(a1, a2, a3, a4, (uint64_t)&CA::Render::BackdropGroup::_list, 1, 0, a5);

  os_unfair_lock_unlock(&CA::Render::BackdropGroup::_list_lock);
}

void CA::Render::BackdropGroup::retain_group_common(void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6, int a7, float a8)
{
  uint64_t v12 = a3;
  if (a3)
  {
    uint64_t v16 = *(uint64_t **)a5;
    uint64_t v15 = *(uint64_t **)(a5 + 8);
    if (*(uint64_t **)a5 != v15)
    {
      do
      {
        uint64_t v17 = (_DWORD *)*v16;
        if (*(unsigned __int8 *)(*v16 + 568) == a4)
        {
          if (a4)
          {
            if (a4 != 2)
            {
              if (a4 != 1) {
                goto LABEL_6;
              }
              uint64_t v20 = *(void *)(a2 + 544);
              if (!v20) {
                uint64_t v20 = a2;
              }
              if (*((void *)v17 + 3) != v20) {
                goto LABEL_6;
              }
            }
          }
          else if (*((void *)v17 + 2) != a2)
          {
            goto LABEL_6;
          }
          uint64_t v18 = *((void *)v17 + 4);
          if (v18)
          {
            size_t v19 = *(unsigned int *)(v12 + 24);
            if (v19 == *(_DWORD *)(v18 + 24)
              && !memcmp((const void *)(v12 + 28), (const void *)(v18 + 28), v19)
              && *((float *)v17 + 15) == a8)
            {
              if (atomic_fetch_add(v17 + 2, 1u)) {
                goto LABEL_44;
              }
              atomic_fetch_add(v17 + 2, 0xFFFFFFFF);
            }
          }
        }
LABEL_6:
        ++v16;
      }
      while (v16 != v15);
    }
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v22 = malloc_type_zone_malloc(malloc_zone, 0x240uLL, 0x8BB15036uLL);
  uint64_t v17 = v22;
  if (v22)
  {
    float64x2_t v22[2] = 1;
    float64x2_t v22[3] = 2;
    ++dword_1EB2ADDD0;
    *(void *)uint64_t v22 = &unk_1ED02D7B0;
    if (a2)
    {
      uint64_t v23 = a2;
      if (!atomic_fetch_add((atomic_uint *volatile)(a2 + 8), 1u))
      {
        uint64_t v23 = 0;
        atomic_fetch_add((atomic_uint *volatile)(a2 + 8), 0xFFFFFFFF);
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    uint64_t v24 = *(void *)(a2 + 544);
    if (!v24) {
      uint64_t v24 = a2;
    }
    *((void *)v22 + 2) = v23;
    *((void *)v22 + 3) = v24;
    if (v12)
    {
      long long v25 = (atomic_uint *)(v12 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v12 + 8), 1u))
      {
        uint64_t v12 = 0;
        atomic_fetch_add(v25, 0xFFFFFFFF);
      }
    }
    *((void *)v22 + 4) = v12;
    v22[10] = 0;
    *((void *)v22 + 6) = 0;
    v22[14] = 0;
    *((float *)v22 + 15) = a8;
    *((void *)v22 + 8) = v22 + 24;
    *((void *)v22 + 9) = v22 + 24;
    *((void *)v22 + 1CA::Context::unref(this[1], 0) = v22 + 24;
    *((void *)v22 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 2;
    *((void *)v22 + 54) = 0;
    v22[110] = 0;
    v22[139] = 0;
    *((void *)v22 + 7CA::Context::unref(this[1], 0) = 0;
    *((_OWORD *)v22 + 28) = 0u;
    *((_OWORD *)v22 + 29) = 0u;
    *((_OWORD *)v22 + 3CA::Context::unref(this[1], 0) = 0u;
    *((_OWORD *)v22 + 3CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0u;
    *((_OWORD *)v22 + 32) = 0u;
    *((_OWORD *)v22 + 33) = 0u;
    *((void *)v22 + 68) = 0;
    *((unsigned char *)v22 + 568) = a4;
    *((unsigned char *)v22 + 569) = 0;
  }
  v22[3] |= a6 << 8;
  long long v27 = *(uint64_t **)a5;
  float64x2_t v26 = *(void **)(a5 + 8);
  uint64_t v28 = ((uint64_t)v26 - *(void *)a5) >> 3;
  unint64_t v29 = *(void *)(a5 + 24);
  if (v29 < v28 + 1)
  {
    uint64_t v30 = *(uint64_t **)(a5 + 16);
    unint64_t v31 = (v29 + 1) | ((v29 + 1) >> 1) | (((v29 + 1) | ((v29 + 1) >> 1)) >> 2);
    unint64_t v32 = v31 | (v31 >> 4) | ((v31 | (v31 >> 4)) >> 8);
    unint64_t v33 = v32 | (v32 >> 16) | ((v32 | (v32 >> 16)) >> 32);
    if (v33 + 1 > v28 + 1) {
      uint64_t v34 = v33 + 1;
    }
    else {
      uint64_t v34 = v28 + 1;
    }
    int v35 = malloc_type_malloc(8 * v34, 0x2004093837F09uLL);
    int v36 = v35;
    int v37 = *(uint64_t **)a5;
    int v38 = *(uint64_t **)(a5 + 8);
    if (*(uint64_t **)a5 != v38)
    {
      int v39 = v35;
      do
      {
        uint64_t v40 = *v37++;
        *v39++ = v40;
      }
      while (v37 != v38);
    }
    if (v27 != v30) {
      free(*(void **)a5);
    }
    float64x2_t v26 = &v36[v28];
    *(void *)a5 = v36;
    *(void *)(a5 + 8) = v26;
    *(void *)(a5 + 24) = v34;
  }
  *float64x2_t v26 = v17;
  *(void *)(a5 + 8) += 8;
  if (a7 && !atomic_fetch_add(v17 + 2, 1u)) {
    atomic_fetch_add(v17 + 2, 0xFFFFFFFF);
  }
LABEL_44:
  *a1 = v17;
}

void ___ZN2CA6Render5Fence11Transaction8Observer8activateENSt3__113unordered_setIyNS4_4hashIyEENS4_8equal_toIyEENS4_9allocatorIyEEEEPFvPS3_RKSC_djyEPFvSD_SF_jjEPFvSD_SF_E_block_invoke_11(uint64_t a1)
{
  dispatch_mach_connect();
  uint64_t v2 = *(NSObject **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);

  dispatch_resume(v2);
}

void invoke_presented_callback(double *a1)
{
  double v2 = *a1;
  pthread_mutex_lock(&presented_mutex);
  while (*(unsigned char *)(*(void *)&v2 + 136))
    pthread_cond_wait(&presented_cond, &presented_mutex);
  if (*(void *)(*(void *)&v2 + 120))
  {
    *(unsigned char *)(*(void *)&v2 + 136) = 1;
    pthread_mutex_unlock(&presented_mutex);
    (*(void (**)(double, void, void, double, double, double))(*(void *)&v2 + 120))(COERCE_DOUBLE(*(void *)&v2), *((unsigned int *)a1 + 2), *(void *)(*(void *)&v2 + 128), a1[2], a1[3], a1[4]);
    pthread_mutex_lock(&presented_mutex);
    *(unsigned char *)(*(void *)&v2 + 136) = 0;
    pthread_cond_broadcast(&presented_cond);
  }
  pthread_mutex_unlock(&presented_mutex);
  CFRelease(*(CFTypeRef *)&v2);

  free(a1);
}

CA::Render::Filter *CA::Render::Filter::shared_filter(CA::Render::Filter *this)
{
  int v1 = (int)this;
  double v2 = 0;
  if ((int)this > 360)
  {
    if ((int)this <= 432)
    {
      if ((int)this <= 393)
      {
        if ((int)this <= 370)
        {
          if (this == 361)
          {
            uint64_t v3 = 35;
          }
          else
          {
            if (this != 362) {
              return v2;
            }
            uint64_t v3 = 36;
          }
        }
        else
        {
          switch(this)
          {
            case 0x173:
              uint64_t v3 = 43;
              break;
            case 0x180:
              uint64_t v3 = 19;
              break;
            case 0x187:
              uint64_t v3 = 18;
              break;
            default:
              return v2;
          }
        }
      }
      else if ((int)this > 417)
      {
        switch(this)
        {
          case 0x1A2:
            uint64_t v3 = 23;
            break;
          case 0x1A8:
            uint64_t v3 = 37;
            break;
          case 0x1AF:
            uint64_t v3 = 14;
            break;
          default:
            return v2;
        }
      }
      else
      {
        switch(this)
        {
          case 0x18A:
            uint64_t v3 = 17;
            break;
          case 0x18B:
            uint64_t v3 = 21;
            break;
          case 0x193:
            uint64_t v3 = 20;
            break;
          default:
            return v2;
        }
      }
    }
    else if ((int)this > 547)
    {
      if ((int)this > 549)
      {
        if (this == 550)
        {
          uint64_t v3 = 15;
        }
        else
        {
          if (this != 609) {
            return v2;
          }
          uint64_t v3 = 12;
        }
      }
      else if (this == 548)
      {
        uint64_t v3 = 32;
      }
      else
      {
        uint64_t v3 = 16;
      }
    }
    else
    {
      if ((int)this > 514)
      {
        switch((int)this)
        {
          case 515:
            uint64_t v3 = 28;
            goto LABEL_84;
          case 518:
            uint64_t v3 = 6;
            goto LABEL_84;
          case 520:
            uint64_t v3 = 4;
            goto LABEL_84;
          case 523:
            uint64_t v3 = 5;
            goto LABEL_84;
          case 524:
            uint64_t v3 = 3;
            goto LABEL_84;
          default:
            return v2;
        }
        return v2;
      }
      switch(this)
      {
        case 0x1B1:
          uint64_t v3 = 13;
          break;
        case 0x1E5:
          uint64_t v3 = 41;
          break;
        case 0x1EA:
          uint64_t v3 = 22;
          break;
        default:
          return v2;
      }
    }
LABEL_84:
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Filter::shared_filter::lock);
    double v2 = (CA::Render::Filter *)CA::Render::Filter::shared_filter::filters[v3];
    if (!v2)
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      unint64_t v5 = (CA::Render::Filter *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x38uLL, 0x743898A5uLL);
      double v2 = v5;
      if (v5)
      {
        CA::Render::Filter::Filter(v5, v1, 0, 0);
        CA::Render::Filter::shared_filter::filters[v3] = v2;
        *((_DWORD *)v2 + 3) |= 0x10100u;
      }
      else
      {
        CA::Render::Filter::shared_filter::filters[v3] = 0;
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Filter::shared_filter::lock);
    return v2;
  }
  if ((int)this > 217)
  {
    if ((int)this <= 266)
    {
      switch(this)
      {
        case 0xDA:
          uint64_t v3 = 31;
          break;
        case 0xFE:
          uint64_t v3 = 29;
          break;
        case 0x108:
          uint64_t v3 = 40;
          break;
        default:
          return v2;
      }
    }
    else if ((int)this > 350)
    {
      if (this == 351)
      {
        uint64_t v3 = 39;
      }
      else
      {
        if (this != 360) {
          return v2;
        }
        uint64_t v3 = 34;
      }
    }
    else if (this == 267)
    {
      uint64_t v3 = 44;
    }
    else
    {
      if (this != 350) {
        return v2;
      }
      uint64_t v3 = 25;
    }
    goto LABEL_84;
  }
  switch((int)this)
  {
    case 162:
      uint64_t v3 = 24;
      goto LABEL_84;
    case 163:
      uint64_t v3 = 38;
      goto LABEL_84;
    case 164:
    case 165:
    case 166:
    case 174:
    case 175:
    case 176:
    case 177:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
      return v2;
    case 167:
      uint64_t v3 = 2;
      goto LABEL_84;
    case 168:
      uint64_t v3 = 11;
      goto LABEL_84;
    case 169:
      uint64_t v3 = 8;
      goto LABEL_84;
    case 170:
      uint64_t v3 = 9;
      goto LABEL_84;
    case 171:
      uint64_t v3 = 10;
      goto LABEL_84;
    case 172:
      uint64_t v3 = 7;
      goto LABEL_84;
    case 173:
      uint64_t v3 = 30;
      goto LABEL_84;
    case 185:
      uint64_t v3 = 33;
      goto LABEL_84;
    default:
      uint64_t v3 = 0;
      switch((int)this)
      {
        case 'Z':
          goto LABEL_84;
        case '[':
        case '\\':
        case ']':
        case '_':
        case 'a':
          return v2;
        case '^':
          uint64_t v3 = 42;
          goto LABEL_84;
          uint64_t v3 = 27;
          goto LABEL_84;
        case 'b':
          uint64_t v3 = 26;
          goto LABEL_84;
        default:
          if (this != 142) {
            return v2;
          }
          uint64_t v3 = 1;
          break;
      }
      goto LABEL_84;
  }
  return v2;
}

void CALayerMapGeometry(CA::Transaction *a1, CALayer *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v5[3] = *MEMORY[0x1E4F143B8];
  v5[0] = a5;
  v5[1] = a3;
  CFStringRef v5[2] = a4;
  CA::Layer::map_geometry(a1, a2, (void (*)(uint64_t, long long *))map_fun, (void (*)(void, void))map_unfun, (uint64_t)v5);
}

void ___ZL34cons_CALayer_kCAValueCopiedPointerjb_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[1] = *(double *)MEMORY[0x1E4F143B8];
  uint64_t v3 = (const void *)*(unsigned int *)(a1 + 32);
  *(void *)&v4[0] = a3;
  CA::Layer::setter(*(CA::Transaction **)(a2 + 16), v3, (const CGAffineTransform *)3, v4);
}

atomic_uint *CARenderRelease(atomic_uint *result)
{
  if (result)
  {
    if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 16))();
    }
  }
  return result;
}

void sub_1847BBA1C(_Unwind_Exception *a1)
{
}

void sub_1847BBB5C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

uint64_t __CADeviceHasInternalBuild_block_invoke()
{
  uint64_t result = os_variant_has_internal_ui();
  CADeviceHasInternalBuild::internal = result;
  return result;
}

void register_memory_handler(void)
{
}

void CA::WindowServer::IOSurface::~IOSurface(CA::WindowServer::IOSurface *this)
{
  CA::WindowServer::IOSurface::~IOSurface(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  const void *v2;
  const void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1ED0272D8;
  double v2 = (const void *)*((void *)this + 30);
  if (v2 && *((unsigned char *)this + 290)) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 35);
  if (v3) {
    CFRelease(v3);
  }

  CA::WindowServer::Surface::~Surface(this);
}

void CA::WindowServer::Surface::~Surface(CA::WindowServer::Surface *this)
{
  *(void *)this = &unk_1ED027128;
  double v2 = (const void *)*((void *)this + 29);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (CA::WindowServer::SharedEvent *)*((void *)this + 2);
  if (v3)
  {
    CA::WindowServer::SharedEvent::~SharedEvent(v3);
    MEMORY[0x185323DC0]();
  }
  int v4 = (atomic_uint *)*((void *)this + 11);
  if (v4)
  {
    if (atomic_fetch_add(v4 + 4, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v4 + 8))(v4);
    }
  }
}

void CA::Render::ShapeLayer::encode(CA::Render::ShapeLayer *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 2));
  int v4 = (_OWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v4 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 16);
    int v4 = (_OWORD *)*((void *)a2 + 4);
  }
  *int v4 = *(_OWORD *)((char *)this + 24);
  *((void *)a2 + 4) += 16;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 5));
  unint64_t v5 = (_OWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 16);
    unint64_t v5 = (_OWORD *)*((void *)a2 + 4);
  }
  *unint64_t v5 = *((_OWORD *)this + 3);
  *((void *)a2 + 4) += 16;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 8));
  uint64_t v6 = *((void *)this + 9);
  uint64_t v7 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v7 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    uint64_t v7 = (void *)*((void *)a2 + 4);
  }
  *uint64_t v7 = v6;
  uint64_t v8 = *((void *)a2 + 4);
  unint64_t v9 = *((void *)a2 + 5);
  uint64_t v10 = (void *)(v8 + 8);
  *((void *)a2 + 4) = v8 + 8;
  uint64_t v11 = *((void *)this + 10);
  if (v8 + 16 > v9)
  {
    CA::Render::Encoder::grow(a2, 8);
    uint64_t v10 = (void *)*((void *)a2 + 4);
  }
  void *v10 = v11;
  uint64_t v12 = *((void *)a2 + 4);
  unint64_t v13 = *((void *)a2 + 5);
  float64x2_t v14 = (void *)(v12 + 8);
  *((void *)a2 + 4) = v12 + 8;
  uint64_t v15 = *((void *)this + 11);
  if (v12 + 16 > v13)
  {
    CA::Render::Encoder::grow(a2, 8);
    float64x2_t v14 = (void *)*((void *)a2 + 4);
  }
  *float64x2_t v14 = v15;
  uint64_t v16 = *((void *)a2 + 4);
  unint64_t v17 = *((void *)a2 + 5);
  uint64_t v18 = (void *)(v16 + 8);
  *((void *)a2 + 4) = v16 + 8;
  uint64_t v19 = *((void *)this + 12);
  if (v16 + 16 > v17)
  {
    CA::Render::Encoder::grow(a2, 8);
    uint64_t v18 = (void *)*((void *)a2 + 4);
  }
  void *v18 = v19;
  uint64_t v20 = *((void *)a2 + 4);
  unint64_t v21 = *((void *)a2 + 5);
  uint64_t v22 = (void *)(v20 + 8);
  *((void *)a2 + 4) = v20 + 8;
  uint64_t v23 = *((void *)this + 13);
  if (v20 + 16 > v21)
  {
    CA::Render::Encoder::grow(a2, 8);
    uint64_t v22 = (void *)*((void *)a2 + 4);
  }
  *uint64_t v22 = v23;
  *((void *)a2 + 4) += 8;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 14));
  int v24 = *((_DWORD *)this + 30);
  long long v25 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v25 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    long long v25 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v25 + 1;
  *long long v25 = v24;
  int v26 = *((_DWORD *)this + 30);
  long long v27 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v27 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    long long v27 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v27 + 1;
  unsigned char *v27 = BYTE1(v26);
  int v28 = *((_DWORD *)this + 30);
  unint64_t v29 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v29 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    unint64_t v29 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v29 + 1;
  unsigned char *v29 = BYTE2(v28);
}

void *CA::Render::Path::encode(CA::Render::Path *this, CA::Render::Encoder *a2)
{
  uint64_t v4 = *((void *)this + 6) | 1;
  unint64_t v5 = (uint64_t *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    unint64_t v5 = (uint64_t *)*((void *)a2 + 4);
  }
  *unint64_t v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = *((void *)a2 + 5);
  uint64_t v8 = (_DWORD *)(v6 + 8);
  *((void *)a2 + 4) = v6 + 8;
  int v9 = *((_DWORD *)this + 5);
  if (v6 + 12 > v7)
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v8 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v8 = v9;
  uint64_t v10 = *((void *)a2 + 4);
  unint64_t v11 = *((void *)a2 + 5);
  uint64_t v12 = (_DWORD *)(v10 + 4);
  *((void *)a2 + 4) = v10 + 4;
  int v13 = *((_DWORD *)this + 6);
  if (v10 + 8 > v11)
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v12 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v12 = v13;
  uint64_t v14 = *((void *)a2 + 4);
  unint64_t v15 = *((void *)a2 + 5);
  uint64_t v16 = (_DWORD *)(v14 + 4);
  *((void *)a2 + 4) = v14 + 4;
  int v17 = *((_DWORD *)this + 4);
  if (v14 + 8 > v15)
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v16 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v16 = v17;
  unint64_t v18 = *((void *)a2 + 5);
  uint64_t v19 = (void *)(*((void *)a2 + 4) + 4);
  *((void *)a2 + 4) = v19;
  uint64_t v20 = (const void *)*((void *)this + 5);
  size_t v21 = *((unsigned int *)this + 5);
  if ((unint64_t)v19 + v21 > v18)
  {
    CA::Render::Encoder::grow(a2, *((unsigned int *)this + 5));
    uint64_t v19 = (void *)*((void *)a2 + 4);
  }
  memcpy(v19, v20, v21);
  unint64_t v22 = *((void *)a2 + 5);
  uint64_t v23 = (void *)(*((void *)a2 + 4) + v21);
  *((void *)a2 + 4) = v23;
  int v24 = (const void *)*((void *)this + 4);
  unsigned int v25 = 2 * *((_DWORD *)this + 6);
  uint64_t v26 = 8 * v25;
  if ((unint64_t)v23 + v26 > v22)
  {
    CA::Render::Encoder::grow(a2, v26);
    uint64_t v23 = (void *)*((void *)a2 + 4);
  }
  uint64_t result = memcpy(v23, v24, v26);
  *((void *)a2 + 4) += v26;
  return result;
}

uint64_t ___ZN20CACGContextEvaluator20update_with_gradientEP10CGGradient_block_invoke(uint64_t a1, const double *a2)
{
  return CACGContextEvaluator::update_with_color_components(*(CACGContextEvaluator **)(a1 + 32), *(CGColorSpaceRef *)(a1 + 40), a2);
}

uint64_t __CARequiresColorMatching_block_invoke()
{
  uint64_t result = dyld_program_sdk_at_least();
  CARequiresColorMatching::compat_mode = result ^ 1;
  return result;
}

void CA::Context::commit_command(CA::Context *this, CA::Render::Object *a2, __CFString *a3, const void *a4, void *a5)
{
  uint64_t v240 = *MEMORY[0x1E4F143B8];
  switch((int)this)
  {
    case 2:
      uint64_t v14 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v14)
      {
        unint64_t v15 = (unsigned char *)*((void *)v14 + 4);
        if ((unint64_t)(v15 + 1) > *((void *)v14 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          unint64_t v15 = (unsigned char *)*((void *)v14 + 4);
        }
        *((void *)v14 + 4) = v15 + 1;
        *unint64_t v15 = 3;
        uint64_t v16 = (CA::Render::Object **)*((void *)v14 + 4);
        if ((unint64_t)(v16 + 1) > *((void *)v14 + 5))
        {
          CA::Render::Encoder::grow(v14, 8);
          uint64_t v16 = (CA::Render::Object **)*((void *)v14 + 4);
        }
        *uint64_t v16 = a2;
        *((void *)v14 + 4) += 8;
      }
      int v17 = (CA::Render::Context *)*((void *)a4 + 5);
      if (v17) {
        CA::Render::Context::update_layer(v17, a2);
      }
      goto LABEL_223;
    case 4:
      unint64_t v18 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v18)
      {
        uint64_t v19 = (unsigned char *)*((void *)v18 + 4);
        if ((unint64_t)(v19 + 1) > *((void *)v18 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          uint64_t v19 = (unsigned char *)*((void *)v18 + 4);
        }
        *((void *)v18 + 4) = v19 + 1;
        unsigned char *v19 = 5;
        uint64_t v20 = (CA::Render::Object **)*((void *)v18 + 4);
        if ((unint64_t)(v20 + 1) > *((void *)v18 + 5))
        {
          CA::Render::Encoder::grow(v18, 8);
          uint64_t v20 = (CA::Render::Object **)*((void *)v18 + 4);
        }
        *uint64_t v20 = a2;
        *((void *)v18 + 4) += 8;
      }
      size_t v21 = (CA::Render::Context *)*((void *)a4 + 5);
      if (v21) {
        CA::Render::Context::remove_all_animations(v21, a2);
      }
      goto LABEL_223;
    case 5:
      unint64_t v22 = (CA::Render *)*((void *)a4 + 4);
      if (v22) {
        CA::Render::encode_remove_animation(v22, a2, a3, (const __CFString *)a4);
      }
      uint64_t v23 = (CA::Render::Context *)*((void *)a4 + 5);
      if (v23) {
        CA::Render::Context::remove_animation(v23, a2, a3);
      }
      goto LABEL_223;
    case 6:
      int v24 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v24)
      {
        unsigned int v25 = (unsigned char *)*((void *)v24 + 4);
        if ((unint64_t)(v25 + 1) > *((void *)v24 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          unsigned int v25 = (unsigned char *)*((void *)v24 + 4);
        }
        *((void *)v24 + 4) = v25 + 1;
        *unsigned int v25 = 7;
        uint64_t v26 = (CA::Render::Object **)*((void *)v24 + 4);
        if ((unint64_t)(v26 + 1) > *((void *)v24 + 5))
        {
          CA::Render::Encoder::grow(v24, 8);
          uint64_t v26 = (CA::Render::Object **)*((void *)v24 + 4);
        }
        *uint64_t v26 = a2;
        *((void *)v24 + 4) += 8;
      }
      uint64_t v27 = *((void *)a4 + 5);
      if (v27) {
        CA::Render::Context::set_layer_id(v27, (uint64_t)a2);
      }
      goto LABEL_223;
    case 7:
      int v28 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v28)
      {
        unint64_t v29 = (unsigned char *)*((void *)v28 + 4);
        if ((unint64_t)(v29 + 1) > *((void *)v28 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          unint64_t v29 = (unsigned char *)*((void *)v28 + 4);
        }
        *((void *)v28 + 4) = v29 + 1;
        unsigned char *v29 = 8;
        CA::Render::Encoder::encode_cfobject(v28, a3);
      }
      uint64_t v30 = *((void *)a4 + 5);
      if (v30)
      {
        X::CFRef<__CFDictionary const*>::operator=((const void **)(v30 + 528), a3);
        ++*(_DWORD *)(v30 + 48);
      }
      goto LABEL_223;
    case 8:
    case 9:
      int v8 = (int)this;
      int v9 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v9)
      {
        if (this == 8) {
          char v10 = 11;
        }
        else {
          char v10 = 12;
        }
        unint64_t v11 = (char *)*((void *)v9 + 4);
        if ((unint64_t)(v11 + 1) > *((void *)v9 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          unint64_t v11 = (char *)*((void *)v9 + 4);
        }
        *((void *)v9 + 4) = v11 + 1;
        *unint64_t v11 = v10;
        uint64_t v12 = (void *)*((void *)v9 + 4);
        if ((unint64_t)(v12 + 1) > *((void *)v9 + 5))
        {
          CA::Render::Encoder::grow(v9, 8);
          uint64_t v12 = (void *)*((void *)v9 + 4);
        }
        *uint64_t v12 = a2;
        *((void *)v9 + 4) += 8;
      }
      int v13 = (CA::Render::Context *)*((void *)a4 + 5);
      if (v13) {
        CA::Render::Context::order_relative(v13, v8 == 8, (int)a2);
      }
      goto LABEL_223;
    case 10:
      float v31 = CA_CFFloatValue(a3);
      unint64_t v32 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v32)
      {
        unint64_t v33 = (unsigned char *)*((void *)v32 + 4);
        if ((unint64_t)(v33 + 1) > *((void *)v32 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          unint64_t v33 = (unsigned char *)*((void *)v32 + 4);
        }
        *((void *)v32 + 4) = v33 + 1;
        unsigned char *v33 = 13;
        uint64_t v34 = (float *)*((void *)v32 + 4);
        if ((unint64_t)(v34 + 1) > *((void *)v32 + 5))
        {
          CA::Render::Encoder::grow(v32, 4);
          uint64_t v34 = (float *)*((void *)v32 + 4);
        }
        *uint64_t v34 = v31;
        *((void *)v32 + 4) += 4;
      }
      unint64_t v35 = *((void *)a4 + 5);
      if (v35 && *(float *)(v35 + 192) != v31)
      {
        *(float *)(v35 + 192) = v31;
        CA::Render::post_notification(8u, v35, 0, 0);
      }
      goto LABEL_223;
    case 11:
      int v36 = (atomic_uint *)[(__CFString *)a3 CA_copyRenderValue];
      int v37 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v37)
      {
        int v38 = (unsigned char *)*((void *)v37 + 4);
        if ((unint64_t)(v38 + 1) > *((void *)v37 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          int v38 = (unsigned char *)*((void *)v37 + 4);
        }
        *((void *)v37 + 4) = v38 + 1;
        *int v38 = 14;
        int v39 = (_DWORD *)*((void *)v37 + 4);
        if ((unint64_t)(v39 + 1) > *((void *)v37 + 5))
        {
          CA::Render::Encoder::grow(v37, 4);
          int v39 = (_DWORD *)*((void *)v37 + 4);
        }
        _DWORD *v39 = a2;
        *((void *)v37 + 4) += 4;
        CA::Render::Encoder::encode_object(v37, (const CA::Render::Object *)v36);
      }
      uint64_t v40 = (CA::Render::Context *)*((void *)a4 + 5);
      if (v40) {
        CA::Render::Context::set_slot(v40, a2, v36);
      }
      if (v36 && atomic_fetch_add(v36 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v36 + 16))(v36);
      }
      goto LABEL_223;
    case 12:
      uint64_t v41 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v41)
      {
        int v42 = (unsigned char *)*((void *)v41 + 4);
        if ((unint64_t)(v42 + 1) > *((void *)v41 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          int v42 = (unsigned char *)*((void *)v41 + 4);
        }
        *((void *)v41 + 4) = v42 + 1;
        *int v42 = 15;
        int v43 = (_DWORD *)*((void *)v41 + 4);
        if ((unint64_t)(v43 + 1) > *((void *)v41 + 5))
        {
          CA::Render::Encoder::grow(v41, 4);
          int v43 = (_DWORD *)*((void *)v41 + 4);
        }
        *int v43 = a2;
        *((void *)v41 + 4) += 4;
      }
      uint64_t v44 = (CA::Render::Context *)*((void *)a4 + 5);
      if (v44) {
        CA::Render::Context::delete_slot(v44, a2);
      }
      goto LABEL_223;
    case 13:
      int v45 = (CA::Render::Context *)CA_CFIntValue(a3);
      uint64_t v46 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v46)
      {
        __int32 v47 = (unsigned char *)*((void *)v46 + 4);
        if ((unint64_t)(v47 + 1) > *((void *)v46 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          __int32 v47 = (unsigned char *)*((void *)v46 + 4);
        }
        *((void *)v46 + 4) = v47 + 1;
        *__int32 v47 = 16;
        __int32 v48 = (_DWORD *)*((void *)v46 + 4);
        if ((unint64_t)(v48 + 1) > *((void *)v46 + 5))
        {
          CA::Render::Encoder::grow(v46, 4);
          __int32 v48 = (_DWORD *)*((void *)v46 + 4);
        }
        *__int32 v48 = a2;
        uint64_t v49 = *((void *)v46 + 4);
        unint64_t v50 = *((void *)v46 + 5);
        BOOL v51 = (_DWORD *)(v49 + 4);
        *((void *)v46 + 4) = v49 + 4;
        if (v49 + 8 > v50)
        {
          CA::Render::Encoder::grow(v46, 4);
          BOOL v51 = (_DWORD *)*((void *)v46 + 4);
        }
        *BOOL v51 = v45;
        *((void *)v46 + 4) += 4;
      }
      uint64_t v52 = (CA::Render::Context *)*((void *)a4 + 5);
      if (v52) {
        CA::Render::Context::transfer_slot(v52, (int)a2, v45);
      }
      goto LABEL_223;
    case 14:
      unsigned int v53 = CA_CFIntValue(a3);
      uint64_t v54 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v54)
      {
        uint64_t v55 = (unsigned char *)*((void *)v54 + 4);
        if ((unint64_t)(v55 + 1) > *((void *)v54 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          uint64_t v55 = (unsigned char *)*((void *)v54 + 4);
        }
        *((void *)v54 + 4) = v55 + 1;
        *uint64_t v55 = 18;
        uint64_t v56 = (_DWORD *)*((void *)v54 + 4);
        if ((unint64_t)(v56 + 1) > *((void *)v54 + 5))
        {
          CA::Render::Encoder::grow(v54, 4);
          uint64_t v56 = (_DWORD *)*((void *)v54 + 4);
        }
        *uint64_t v56 = a2;
        uint64_t v57 = *((void *)v54 + 4);
        unint64_t v58 = *((void *)v54 + 5);
        int32x2_t v59 = (unsigned int *)(v57 + 4);
        *((void *)v54 + 4) = v57 + 4;
        if (v57 + 8 > v58)
        {
          CA::Render::Encoder::grow(v54, 4);
          int32x2_t v59 = (unsigned int *)*((void *)v54 + 4);
        }
        unsigned int *v59 = v53;
        *((void *)v54 + 4) += 4;
        (*(void (**)(CA::Render::Encoder *))(*(void *)v54 + 16))(v54);
      }
      int32x2_t v60 = (CA::Render::Context *)*((void *)a4 + 5);
      if (v60) {
        CA::Render::Context::flush_image_queue(v60, (int)a2, v53);
      }
      goto LABEL_223;
    case 15:
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a3, 0);
      unsigned int v237 = CA_CFIntValue(ValueAtIndex);
      float v62 = CFArrayGetValueAtIndex((CFArrayRef)a3, 1);
      unsigned int v236 = CA_CFIntValue(v62);
      char v63 = CFArrayGetValueAtIndex((CFArrayRef)a3, 2);
      unsigned int v235 = CA_CFIntValue(v63);
      unsigned int v64 = CFArrayGetValueAtIndex((CFArrayRef)a3, 3);
      int v65 = CA_CFIntValue(v64);
      BOOL v66 = CFArrayGetValueAtIndex((CFArrayRef)a3, 4);
      int v67 = CA_CFIntValue(v66);
      uint64_t v68 = CFArrayGetValueAtIndex((CFArrayRef)a3, 5);
      int v69 = CA_CFIntValue(v68);
      unsigned int v70 = CFArrayGetValueAtIndex((CFArrayRef)a3, 6);
      int v71 = CA_CFIntValue(v70);
      unsigned int v72 = CFArrayGetValueAtIndex((CFArrayRef)a3, 7);
      int v73 = CA_CFIntValue(v72);
      unint64_t v74 = CFArrayGetValueAtIndex((CFArrayRef)a3, 8);
      float v75 = (double)(int)CA_CFIntValue(v74) * 0.0000152587891;
      long long v76 = CFArrayGetValueAtIndex((CFArrayRef)a3, 9);
      int v77 = CA_CFIntValue(v76);
      long long v78 = (CA::Render *)CFArrayGetValueAtIndex((CFArrayRef)a3, 10);
      if (v78 == (CA::Render *)*MEMORY[0x1E4F1D260]) {
        long long v80 = 0;
      }
      else {
        long long v80 = v78;
      }
      long long v81 = (CGColor *)CA::Context::current_colorspace(*(CA::Context **)a4, v79);
      unsigned int v239 = 0;
      int32x2_t v238 = 0;
      CA::Render::convert_cgcolor(v80, v81, (CGColorSpace *)&v239, (float *)&v238, v82);
      long long v83 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v83)
      {
        unsigned int v233 = v239;
        int32x2_t v234 = (CA::Render::Object *)v238;
        long long v84 = (unsigned char *)*((void *)v83 + 4);
        if ((unint64_t)(v84 + 1) > *((void *)v83 + 5))
        {
          CA::Render::Encoder::grow(v83, 1);
          long long v84 = (unsigned char *)*((void *)v83 + 4);
        }
        *((void *)v83 + 4) = v84 + 1;
        *long long v84 = 19;
        BOOL v85 = (CA::Render::Object **)*((void *)v83 + 4);
        if ((unint64_t)(v85 + 1) > *((void *)v83 + 5))
        {
          CA::Render::Encoder::grow(v83, 8);
          BOOL v85 = (CA::Render::Object **)*((void *)v83 + 4);
        }
        *BOOL v85 = a2;
        uint64_t v86 = *((void *)v83 + 4);
        unint64_t v87 = *((void *)v83 + 5);
        uint64_t v88 = (unsigned int *)(v86 + 8);
        *((void *)v83 + 4) = v86 + 8;
        if (v86 + 12 > v87)
        {
          CA::Render::Encoder::grow(v83, 4);
          uint64_t v88 = (unsigned int *)*((void *)v83 + 4);
        }
        *uint64_t v88 = v237;
        uint64_t v89 = *((void *)v83 + 4);
        unint64_t v90 = *((void *)v83 + 5);
        float64x2_t v91 = (unsigned int *)(v89 + 4);
        *((void *)v83 + 4) = v89 + 4;
        if (v89 + 8 > v90)
        {
          CA::Render::Encoder::grow(v83, 4);
          float64x2_t v91 = (unsigned int *)*((void *)v83 + 4);
        }
        *float64x2_t v91 = v236;
        uint64_t v92 = *((void *)v83 + 4);
        unint64_t v93 = *((void *)v83 + 5);
        long long v94 = (unsigned int *)(v92 + 4);
        *((void *)v83 + 4) = v92 + 4;
        if (v92 + 8 > v93)
        {
          CA::Render::Encoder::grow(v83, 4);
          long long v94 = (unsigned int *)*((void *)v83 + 4);
        }
        *long long v94 = v235;
        uint64_t v95 = *((void *)v83 + 4);
        unint64_t v96 = *((void *)v83 + 5);
        long long v97 = (int *)(v95 + 4);
        *((void *)v83 + 4) = v95 + 4;
        if (v95 + 8 > v96)
        {
          CA::Render::Encoder::grow(v83, 4);
          long long v97 = (int *)*((void *)v83 + 4);
        }
        *long long v97 = v65;
        uint64_t v98 = *((void *)v83 + 4);
        unint64_t v99 = *((void *)v83 + 5);
        double v100 = (int *)(v98 + 4);
        *((void *)v83 + 4) = v98 + 4;
        if (v98 + 8 > v99)
        {
          CA::Render::Encoder::grow(v83, 4);
          double v100 = (int *)*((void *)v83 + 4);
        }
        *double v100 = v67;
        uint64_t v101 = *((void *)v83 + 4);
        unint64_t v102 = *((void *)v83 + 5);
        double v103 = (int *)(v101 + 4);
        *((void *)v83 + 4) = v101 + 4;
        if (v101 + 8 > v102)
        {
          CA::Render::Encoder::grow(v83, 4);
          double v103 = (int *)*((void *)v83 + 4);
        }
        *double v103 = v69;
        uint64_t v104 = *((void *)v83 + 4);
        unint64_t v105 = *((void *)v83 + 5);
        double v106 = (int *)(v104 + 4);
        *((void *)v83 + 4) = v104 + 4;
        if (v104 + 8 > v105)
        {
          CA::Render::Encoder::grow(v83, 4);
          double v106 = (int *)*((void *)v83 + 4);
        }
        *double v106 = v71;
        uint64_t v107 = *((void *)v83 + 4);
        unint64_t v108 = *((void *)v83 + 5);
        uint64_t v109 = (BOOL *)(v107 + 4);
        *((void *)v83 + 4) = v107 + 4;
        if (v107 + 5 > v108)
        {
          CA::Render::Encoder::grow(v83, 1);
          uint64_t v109 = (BOOL *)*((void *)v83 + 4);
        }
        *((void *)v83 + 4) = v109 + 1;
        *uint64_t v109 = v73 != 0;
        int v110 = (float *)*((void *)v83 + 4);
        if ((unint64_t)(v110 + 1) > *((void *)v83 + 5))
        {
          CA::Render::Encoder::grow(v83, 4);
          int v110 = (float *)*((void *)v83 + 4);
        }
        *int v110 = v75;
        uint64_t v111 = *((void *)v83 + 4);
        unint64_t v112 = *((void *)v83 + 5);
        uint64_t v113 = (int *)(v111 + 4);
        *((void *)v83 + 4) = v111 + 4;
        if (v111 + 8 > v112)
        {
          CA::Render::Encoder::grow(v83, 4);
          uint64_t v113 = (int *)*((void *)v83 + 4);
        }
        *uint64_t v113 = v77;
        uint64_t v114 = *((void *)v83 + 4);
        unint64_t v115 = *((void *)v83 + 5);
        unsigned int v116 = (unsigned int *)(v114 + 4);
        *((void *)v83 + 4) = v114 + 4;
        if (v114 + 8 > v115)
        {
          CA::Render::Encoder::grow(v83, 4);
          unsigned int v116 = (unsigned int *)*((void *)v83 + 4);
        }
        *unsigned int v116 = v233;
        *((void *)v83 + 4) += 4;
        CA::Render::Encoder::encode_object(v83, v234);
      }
      int v117 = (CA::Render::ImageProvider *)*((void *)a4 + 5);
      if (v117) {
        CA::Render::ImageProvider::create(v117, a2, v237, v236, v235, v65, v67, v69, v75, v71, v73 != 0, v232, v77, v239, (CA::Render::Pattern *)v238);
      }
      goto LABEL_223;
    case 16:
      uint64_t v118 = CFArrayGetValueAtIndex((CFArrayRef)a3, 0);
      unsigned int v119 = CA_CFIntValue(v118);
      int v120 = CFArrayGetValueAtIndex((CFArrayRef)a3, 1);
      unsigned int v121 = CA_CFIntValue(v120);
      long long v122 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v122)
      {
        int v123 = (unsigned char *)*((void *)v122 + 4);
        if ((unint64_t)(v123 + 1) > *((void *)v122 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          int v123 = (unsigned char *)*((void *)v122 + 4);
        }
        *((void *)v122 + 4) = v123 + 1;
        *int v123 = 20;
        int v124 = (CA::Render::Object **)*((void *)v122 + 4);
        if ((unint64_t)(v124 + 1) > *((void *)v122 + 5))
        {
          CA::Render::Encoder::grow(v122, 8);
          int v124 = (CA::Render::Object **)*((void *)v122 + 4);
        }
        *int v124 = a2;
        uint64_t v125 = *((void *)v122 + 4);
        unint64_t v126 = *((void *)v122 + 5);
        uint64_t v127 = (unsigned int *)(v125 + 8);
        *((void *)v122 + 4) = v125 + 8;
        if (v125 + 12 > v126)
        {
          CA::Render::Encoder::grow(v122, 4);
          uint64_t v127 = (unsigned int *)*((void *)v122 + 4);
        }
        *uint64_t v127 = v119;
        uint64_t v128 = *((void *)v122 + 4);
        unint64_t v129 = *((void *)v122 + 5);
        int32x2_t v130 = (unsigned int *)(v128 + 4);
        *((void *)v122 + 4) = v128 + 4;
        if (v128 + 8 > v129)
        {
          CA::Render::Encoder::grow(v122, 4);
          int32x2_t v130 = (unsigned int *)*((void *)v122 + 4);
        }
        *int32x2_t v130 = v121;
        *((void *)v122 + 4) += 4;
      }
      uint64_t v131 = *((void *)a4 + 5);
      if (v131) {
        CA::Render::ImageProvider::set_image_size(*(CA::Render::ImageProvider **)(v131 + 136), (CA::Render::Context *)*(unsigned int *)(v131 + 148), (uint64_t)a2, v119, v121);
      }
      goto LABEL_223;
    case 17:
      uint64_t v132 = (CA::Render *)CFArrayGetValueAtIndex((CFArrayRef)a3, 0);
      if (v132 == (CA::Render *)*MEMORY[0x1E4F1D260]) {
        uint64_t v134 = 0;
      }
      else {
        uint64_t v134 = v132;
      }
      uint64_t v135 = (CGColor *)CA::Context::current_colorspace(*(CA::Context **)a4, v133);
      unsigned int v239 = 0;
      int32x2_t v238 = 0;
      CA::Render::convert_cgcolor(v134, v135, (CGColorSpace *)&v239, (float *)&v238, v136);
      int v137 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v137)
      {
        unsigned int v138 = v239;
        long long v139 = v238;
        long long v140 = (unsigned char *)*((void *)v137 + 4);
        if ((unint64_t)(v140 + 1) > *((void *)v137 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          long long v140 = (unsigned char *)*((void *)v137 + 4);
        }
        *((void *)v137 + 4) = v140 + 1;
        *long long v140 = 21;
        double v141 = (CA::Render::Object **)*((void *)v137 + 4);
        if ((unint64_t)(v141 + 1) > *((void *)v137 + 5))
        {
          CA::Render::Encoder::grow(v137, 8);
          double v141 = (CA::Render::Object **)*((void *)v137 + 4);
        }
        *double v141 = a2;
        uint64_t v142 = *((void *)v137 + 4);
        unint64_t v143 = *((void *)v137 + 5);
        float v144 = (unsigned int *)(v142 + 8);
        *((void *)v137 + 4) = v142 + 8;
        if (v142 + 12 > v143)
        {
          CA::Render::Encoder::grow(v137, 4);
          float v144 = (unsigned int *)*((void *)v137 + 4);
        }
        *float v144 = v138;
        *((void *)v137 + 4) += 4;
        CA::Render::Encoder::encode_object(v137, (const CA::Render::Object *)v139);
      }
      uint64_t v145 = *((void *)a4 + 5);
      if (v145) {
        CA::Render::ImageProvider::set_fill_color(*(CA::Render::ImageProvider **)(v145 + 136), (CA::Render::Context *)*(unsigned int *)(v145 + 148), (uint64_t)a2, v239, v238);
      }
      goto LABEL_223;
    case 18:
      double v146 = CFArrayGetValueAtIndex((CFArrayRef)a3, 0);
      int v147 = CA_CFIntValue(v146);
      float v148 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v148)
      {
        float v149 = (unsigned char *)*((void *)v148 + 4);
        if ((unint64_t)(v149 + 1) > *((void *)v148 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          float v149 = (unsigned char *)*((void *)v148 + 4);
        }
        *((void *)v148 + 4) = v149 + 1;
        unsigned char *v149 = 22;
        double v150 = (CA::Render::Object **)*((void *)v148 + 4);
        if ((unint64_t)(v150 + 1) > *((void *)v148 + 5))
        {
          CA::Render::Encoder::grow(v148, 8);
          double v150 = (CA::Render::Object **)*((void *)v148 + 4);
        }
        *double v150 = a2;
        uint64_t v151 = *((void *)v148 + 4);
        unint64_t v152 = *((void *)v148 + 5);
        int v153 = (_DWORD *)(v151 + 8);
        *((void *)v148 + 4) = v151 + 8;
        if (v151 + 12 > v152)
        {
          CA::Render::Encoder::grow(v148, 4);
          int v153 = (_DWORD *)*((void *)v148 + 4);
        }
        *int v153 = v147;
        *((void *)v148 + 4) += 4;
      }
      uint64_t v154 = *((void *)a4 + 5);
      if (v154)
      {
        uint64_t v155 = CA::Render::Context::lookup_object(*(void *)(v154 + 136), *(_DWORD *)(v154 + 148), (uint64_t)a2, 0, 24, 0);
        if (v155) {
          *(_DWORD *)(v155 + 136) = v147;
        }
      }
      goto LABEL_223;
    case 19:
      uint64_t v156 = CFArrayGetValueAtIndex((CFArrayRef)a3, 0);
      int v157 = CA_CFIntValue(v156);
      int v158 = CFArrayGetValueAtIndex((CFArrayRef)a3, 1);
      int v159 = CA_CFIntValue(v158);
      uint64_t v160 = CFArrayGetValueAtIndex((CFArrayRef)a3, 2);
      int v161 = CA_CFIntValue(v160);
      long long v162 = (void *)CFArrayGetValueAtIndex((CFArrayRef)a3, 3);
      if (v162 == (void *)*MEMORY[0x1E4F1D260]) {
        long long v163 = 0;
      }
      else {
        long long v163 = v162;
      }
      long long v164 = CFArrayGetValueAtIndex((CFArrayRef)a3, 4);
      int v165 = CA_CFIntValue(v164);
      float64x2_t v166 = CFArrayGetValueAtIndex((CFArrayRef)a3, 5);
      unsigned int v167 = CA_CFIntValue(v166);
      double v168 = (atomic_uint *)objc_msgSend(v163, "CA_copyRenderValue");
      uint64_t v169 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v169)
      {
        uint64_t v170 = (unsigned char *)*((void *)v169 + 4);
        if ((unint64_t)(v170 + 1) > *((void *)v169 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          uint64_t v170 = (unsigned char *)*((void *)v169 + 4);
        }
        *((void *)v169 + 4) = v170 + 1;
        unsigned char *v170 = 23;
        double v171 = (CA::Render::Object **)*((void *)v169 + 4);
        if ((unint64_t)(v171 + 1) > *((void *)v169 + 5))
        {
          CA::Render::Encoder::grow(v169, 8);
          double v171 = (CA::Render::Object **)*((void *)v169 + 4);
        }
        NSObject *v171 = a2;
        uint64_t v172 = *((void *)v169 + 4);
        unint64_t v173 = *((void *)v169 + 5);
        uint64_t v174 = (int *)(v172 + 8);
        *((void *)v169 + 4) = v172 + 8;
        if (v172 + 12 > v173)
        {
          CA::Render::Encoder::grow(v169, 4);
          uint64_t v174 = (int *)*((void *)v169 + 4);
        }
        *uint64_t v174 = v157;
        uint64_t v175 = *((void *)v169 + 4);
        unint64_t v176 = *((void *)v169 + 5);
        int v177 = (int *)(v175 + 4);
        *((void *)v169 + 4) = v175 + 4;
        if (v175 + 8 > v176)
        {
          CA::Render::Encoder::grow(v169, 4);
          int v177 = (int *)*((void *)v169 + 4);
        }
        *int v177 = v159;
        uint64_t v178 = *((void *)v169 + 4);
        unint64_t v179 = *((void *)v169 + 5);
        uint64_t v180 = (int *)(v178 + 4);
        *((void *)v169 + 4) = v178 + 4;
        if (v178 + 8 > v179)
        {
          CA::Render::Encoder::grow(v169, 4);
          uint64_t v180 = (int *)*((void *)v169 + 4);
        }
        int *v180 = v161;
        *((void *)v169 + 4) += 4;
        CA::Render::Encoder::encode_object(v169, (const CA::Render::Object *)v168);
        unsigned int v181 = (int *)*((void *)v169 + 4);
        if ((unint64_t)(v181 + 1) > *((void *)v169 + 5))
        {
          CA::Render::Encoder::grow(v169, 4);
          unsigned int v181 = (int *)*((void *)v169 + 4);
        }
        *unsigned int v181 = v165;
        uint64_t v182 = *((void *)v169 + 4);
        unint64_t v183 = *((void *)v169 + 5);
        char v184 = (unsigned int *)(v182 + 4);
        *((void *)v169 + 4) = v182 + 4;
        if (v182 + 8 > v183)
        {
          CA::Render::Encoder::grow(v169, 4);
          char v184 = (unsigned int *)*((void *)v169 + 4);
        }
        unsigned int *v184 = v167;
        *((void *)v169 + 4) += 4;
        CA::Render::Encoder::retain_object((uint64_t)v169, (const CA::Render::Object *)v168);
      }
      uint64_t v185 = *((void *)a4 + 5);
      if (v185) {
        CA::Render::ImageProvider::set_subimage(*(CA::Render::ImageProvider **)(v185 + 136), (CA::Render::Context *)*(unsigned int *)(v185 + 148), (uint64_t)a2, v157, v159, v161, (CA::Render::Texture *)v168, v165, v167);
      }
      if (v168 && atomic_fetch_add(v168 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v168 + 16))(v168);
      }
      goto LABEL_223;
    case 20:
      uint64_t v186 = CFArrayGetValueAtIndex((CFArrayRef)a3, 0);
      int v187 = CA_CFIntValue(v186);
      uint64_t v188 = CFArrayGetValueAtIndex((CFArrayRef)a3, 1);
      int v189 = CA_CFIntValue(v188);
      uint64_t v190 = CFArrayGetValueAtIndex((CFArrayRef)a3, 2);
      int v191 = CA_CFIntValue(v190);
      uint64_t v192 = CFArrayGetValueAtIndex((CFArrayRef)a3, 3);
      int v193 = CA_CFIntValue(v192);
      uint64_t v194 = CFArrayGetValueAtIndex((CFArrayRef)a3, 4);
      int v195 = CA_CFIntValue(v194);
      double v196 = CFArrayGetValueAtIndex((CFArrayRef)a3, 5);
      unsigned int v197 = CA_CFIntValue(v196);
      double v198 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v198)
      {
        int v199 = (unsigned char *)*((void *)v198 + 4);
        if ((unint64_t)(v199 + 1) > *((void *)v198 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          int v199 = (unsigned char *)*((void *)v198 + 4);
        }
        *((void *)v198 + 4) = v199 + 1;
        unsigned char *v199 = 24;
        long long v200 = (CA::Render::Object **)*((void *)v198 + 4);
        if ((unint64_t)(v200 + 1) > *((void *)v198 + 5))
        {
          CA::Render::Encoder::grow(v198, 8);
          long long v200 = (CA::Render::Object **)*((void *)v198 + 4);
        }
        *long long v200 = a2;
        uint64_t v201 = *((void *)v198 + 4);
        unint64_t v202 = *((void *)v198 + 5);
        double v203 = (int *)(v201 + 8);
        *((void *)v198 + 4) = v201 + 8;
        if (v201 + 12 > v202)
        {
          CA::Render::Encoder::grow(v198, 4);
          double v203 = (int *)*((void *)v198 + 4);
        }
        *double v203 = v187;
        uint64_t v204 = *((void *)v198 + 4);
        unint64_t v205 = *((void *)v198 + 5);
        long long v206 = (int *)(v204 + 4);
        *((void *)v198 + 4) = v204 + 4;
        if (v204 + 8 > v205)
        {
          CA::Render::Encoder::grow(v198, 4);
          long long v206 = (int *)*((void *)v198 + 4);
        }
        *long long v206 = v189;
        uint64_t v207 = *((void *)v198 + 4);
        unint64_t v208 = *((void *)v198 + 5);
        float64x2_t v209 = (int *)(v207 + 4);
        *((void *)v198 + 4) = v207 + 4;
        if (v207 + 8 > v208)
        {
          CA::Render::Encoder::grow(v198, 4);
          float64x2_t v209 = (int *)*((void *)v198 + 4);
        }
        *float64x2_t v209 = v191;
        uint64_t v210 = *((void *)v198 + 4);
        unint64_t v211 = *((void *)v198 + 5);
        uint64_t v212 = (int *)(v210 + 4);
        *((void *)v198 + 4) = v210 + 4;
        if (v210 + 8 > v211)
        {
          CA::Render::Encoder::grow(v198, 4);
          uint64_t v212 = (int *)*((void *)v198 + 4);
        }
        int *v212 = v193;
        uint64_t v213 = *((void *)v198 + 4);
        unint64_t v214 = *((void *)v198 + 5);
        int v215 = (int *)(v213 + 4);
        *((void *)v198 + 4) = v213 + 4;
        if (v213 + 8 > v214)
        {
          CA::Render::Encoder::grow(v198, 4);
          int v215 = (int *)*((void *)v198 + 4);
        }
        *int v215 = v195;
        uint64_t v216 = *((void *)v198 + 4);
        unint64_t v217 = *((void *)v198 + 5);
        int32x2_t v218 = (unsigned int *)(v216 + 4);
        *((void *)v198 + 4) = v216 + 4;
        if (v216 + 8 > v217)
        {
          CA::Render::Encoder::grow(v198, 4);
          int32x2_t v218 = (unsigned int *)*((void *)v198 + 4);
        }
        *int32x2_t v218 = v197;
        *((void *)v198 + 4) += 4;
      }
      uint64_t v219 = *((void *)a4 + 5);
      if (v219) {
        CA::Render::ImageProvider::invalidate(*(CA::Render::ImageProvider **)(v219 + 136), (CA::Render::Context *)*(unsigned int *)(v219 + 148), (uint64_t)a2, v187, v189, v191, v193, v195, v197);
      }
      goto LABEL_223;
    case 21:
    case 22:
    case 23:
    case 24:
      goto LABEL_223;
    case 25:
      int32x2_t v220 = (const CA::Render::Object *)[(__CFString *)a3 _renderShmem];
      int8x8_t v221 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v221)
      {
        double v222 = (unsigned char *)*((void *)v221 + 4);
        if ((unint64_t)(v222 + 1) > *((void *)v221 + 5))
        {
          CA::Render::Encoder::grow(*((CA::Render::Encoder **)a4 + 4), 1);
          double v222 = (unsigned char *)*((void *)v221 + 4);
        }
        *((void *)v221 + 4) = v222 + 1;
        *double v222 = 35;
        CA::Render::Encoder::encode_object(v221, v220);
        (*(void (**)(CA::Render::Encoder *))(*(void *)v221 + 16))(v221);
      }
      if (*((void *)a4 + 5)) {
        CA::Render::Context::flush_presentation_modifier_shmem((uint64_t)v220);
      }
      goto LABEL_223;
    case 26:
      double v225 = CA_CFDoubleValue(a3);
      if (v225 != 0.0) {
        CA::Render::CA_IS_FULFILLING_SERVER_GLITCH_REQUEST(v223, v225);
      }
      uint64_t v226 = (CA::Render::Encoder *)*((void *)a4 + 4);
      if (v226) {
        CA::Render::encode_request_server_glitch(v226, v224, 0.0);
      }
      goto LABEL_223;
    case 27:
      double v228 = CA_CFDoubleValue(a3);
      if (v228 != 0.0)
      {
        double v229 = v228;
        float v230 = (CA::Render::Encoder *)*((void *)a4 + 4);
        if (v230) {
          CA::Render::encode_request_server_glitch(v230, v227, v228);
        }
        int64x2_t v231 = (CA::Render::Context *)*((void *)a4 + 5);
        if (v231) {
          CA::Render::Context::set_glitch_request(v231, v229);
        }
      }
LABEL_223:
      *((unsigned char *)a4 + 56) = 1;
      break;
    default:
      return;
  }
}

uint64_t CA::Render::Encoder::set_synchronous(uint64_t this)
{
  *(unsigned char *)(this + 104) = 1;
  return this;
}

void *CA::Render::ImageQueue::encode(CA::Render::ImageQueue *this, CA::Render::Encoder *a2)
{
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 2));
  int v4 = *((_DWORD *)this + 45);
  unint64_t v5 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    unint64_t v5 = (_DWORD *)*((void *)a2 + 4);
  }
  *unint64_t v5 = v4;
  *((void *)a2 + 4) += 4;
  uint64_t result = (void *)CA::Render::Encoder::encode_port_send_right(a2, *((_DWORD *)this + 49), 0);
  int v7 = *((_DWORD *)this + 50);
  int v8 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v8 + 1) > *((void *)a2 + 5))
  {
    uint64_t result = CA::Render::Encoder::grow(a2, 4);
    int v8 = (_DWORD *)*((void *)a2 + 4);
  }
  *int v8 = v7;
  uint64_t v9 = *((void *)a2 + 4);
  unint64_t v10 = *((void *)a2 + 5);
  unint64_t v11 = (_DWORD *)(v9 + 4);
  *((void *)a2 + 4) = v9 + 4;
  int v12 = *((_DWORD *)this + 46);
  if (v9 + 8 > v10)
  {
    uint64_t result = CA::Render::Encoder::grow(a2, 4);
    unint64_t v11 = (_DWORD *)*((void *)a2 + 4);
  }
  *unint64_t v11 = v12;
  *((void *)a2 + 4) += 4;
  return result;
}

float CA_CFFloatValue(const void *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFBooleanGetTypeID())
  {
    float result = 0.0;
    if ((const void *)*MEMORY[0x1E4F1CFC8] != a1) {
      return 1.0;
    }
  }
  else
  {
    CFTypeID TypeID = CFNumberGetTypeID();
    float result = 0.0;
    if (v2 == TypeID)
    {
      float valuePtr = 0.0;
      CFNumberGetValue((CFNumberRef)a1, kCFNumberFloatType, &valuePtr);
      return valuePtr;
    }
  }
  return result;
}

void CA::Transaction::pop(CA::Transaction *this, const void *a2)
{
  uint64_t v2 = *((void *)this + 13);
  if (*(_DWORD *)v2)
  {
    if (atomic_fetch_add((atomic_uint *volatile)v2, 0xFFFFFFFF) == 1)
    {
      *(_DWORD *)uint64_t v2 = 1;
    }
    else
    {
      int v4 = (CA::Transaction::Level *)*((void *)this + 11);
      *((void *)this + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(void *)v4;
      CA::Transaction::Level::~Level(v4, a2);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v4);
      if (*(_DWORD *)v2 != 1
        || (*(unsigned char *)(v2 + 204) & 2) == 0
        || *((CA::Transaction **)this + 13) != (CA::Transaction *)((char *)this + 120))
      {
        return;
      }
    }
    CA::Transaction::commit(this);
  }
}

uint64_t CAImageQueueCopyRenderValue(uint64_t a1)
{
  double v2 = MEMORY[0x1F4188790](a1);
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v4 = *(void *)(StatusReg + 576);
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 + 40);
    if (v5)
    {
      if (*(void *)(v5 + 208))
      {
        uint64_t v6 = v1;
        uint64_t v7 = v5 + 216;
        int v8 = (*(uint64_t (**)(uint64_t, double))(*(void *)(v5 + 216) + 16))(v5 + 216, v2);
        if (*(_DWORD *)(v6 + 208) != v8)
        {
          int v9 = v8;
          if (*(void *)(v6 + 200) && *(_DWORD *)(v6 + 212))
          {
            os_unfair_lock_lock((os_unfair_lock_t)(v6 + 16));
            unint64_t v10 = x_hash_table_values(*(void *)(v6 + 200));
            if (v10)
            {
              unint64_t v11 = v10;
              int v12 = v10;
              do
              {
                int v13 = (atomic_uint *)(*v12 + 8);
                if (!atomic_fetch_add(v13, 1u)) {
                  atomic_fetch_add(v13, 0xFFFFFFFF);
                }
                int v12 = (void *)v12[1];
              }
              while (v12);
              os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 16));
              uint64_t v15 = *(void *)(StatusReg + 576);
              if (v15)
              {
                uint64_t v16 = v11;
                do
                {
                  uint64_t v17 = *v16;
                  if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
                    dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
                  }
                  if (v17) {
                    uint64_t v18 = CA::Render::_render_id_slide + v17;
                  }
                  else {
                    uint64_t v18 = 0;
                  }
                  CA::Transaction::add_deleted_id(*(CA::Transaction **)(v15 + 104), v18, *(_DWORD *)(*v16 + 16), *(_DWORD *)(v6 + 208));
                  uint64_t v16 = (void *)v16[1];
                }
                while (v16);
              }
              uint64_t v19 = v11;
              do
              {
                uint64_t v20 = *v19;
                if (atomic_fetch_add((atomic_uint *volatile)(*v19 + 8), 0xFFFFFFFF) == 1) {
                  (*(void (**)(uint64_t))(*(void *)v20 + 16))(v20);
                }
                uint64_t v19 = (void *)v19[1];
              }
              while (v19);
              do
              {
                size_t v21 = (void *)v11[1];
                free(v11);
                unint64_t v11 = v21;
              }
              while (v21);
            }
            else
            {
              os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 16));
            }
          }
          *(_DWORD *)(v6 + 208) = v9;
          mach_port_name_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
          mach_port_name_t v23 = *(_DWORD *)(v6 + 212);
          if (v23 != v22)
          {
            mach_port_name_t v24 = v22;
            unsigned int v25 = (ipc_space_t *)MEMORY[0x1E4F14960];
            if (v23) {
              mach_port_deallocate(*MEMORY[0x1E4F14960], v23);
            }
            *(_DWORD *)(v6 + 212) = 0;
            if (v24 - 1 <= 0xFFFFFFFD && !mach_port_mod_refs(*v25, v24, 0, 1)) {
              *(_DWORD *)(v6 + 212) = v24;
            }
          }
          *(_DWORD *)(v6 + 216) = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 24))(v7);
          if (*(void *)(v6 + 200) && *(_DWORD *)(v6 + 212))
          {
            os_unfair_lock_lock((os_unfair_lock_t)(v6 + 16));
            uint64_t v26 = x_hash_table_values(*(void *)(v6 + 200));
            if (v26)
            {
              uint64_t v27 = v26;
              int v28 = v26;
              do
              {
                unint64_t v29 = (atomic_uint *)(*v28 + 8);
                if (!atomic_fetch_add(v29, 1u)) {
                  atomic_fetch_add(v29, 0xFFFFFFFF);
                }
                int v28 = (uint64_t *)v28[1];
              }
              while (v28);
              os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 16));
              uint64_t v30 = CA::Context::retain_context_with_id((CA::Context *)*(unsigned int *)(v6 + 208));
              if (v30)
              {
                uint64_t v31 = (uint64_t)(v30 + 54);
                bzero(v58, 0x1090uLL);
                CAImageQueueCommit::CAImageQueueCommit((uint64_t)v58, v6, v31);
                unint64_t v32 = v27;
                do
                {
                  uint64_t v33 = *v32;
                  if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
                    dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
                  }
                  if (v33) {
                    uint64_t v34 = (CA::Render::Encoder *)(CA::Render::_render_id_slide + v33);
                  }
                  else {
                    uint64_t v34 = 0;
                  }
                  CA::Render::encode_set_object((CA::Render *)v59, v34, *(_DWORD *)(v33 + 16), *(CA::Render::Object **)(v33 + 24), 0);
                  v59[104] = 1;
                  unint64_t v32 = (uint64_t *)v32[1];
                }
                while (v32);
                CAImageQueueCommit::~CAImageQueueCommit((CAImageQueueCommit *)v58);
              }
              unint64_t v35 = v27;
              do
              {
                uint64_t v36 = *v35;
                if (atomic_fetch_add((atomic_uint *volatile)(*v35 + 8), 0xFFFFFFFF) == 1) {
                  (*(void (**)(uint64_t))(*(void *)v36 + 16))(v36);
                }
                unint64_t v35 = (uint64_t *)v35[1];
              }
              while (v35);
              do
              {
                int v37 = (uint64_t *)v27[1];
                free(v27);
                uint64_t v27 = v37;
              }
              while (v37);
            }
            else
            {
              os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 16));
            }
          }
        }
        os_unfair_lock_lock((os_unfair_lock_t)(v6 + 16));
        uint64_t v38 = *(void *)(v6 + 48);
        if (v38)
        {
          if (*(_DWORD *)(v6 + 24) != *(_DWORD *)(*(void *)(v38 + 24) + 16))
          {
            int v39 = CA::Context::retain_context_with_id((CA::Context *)*(unsigned int *)(v6 + 208));
            if (v39)
            {
              uint64_t v40 = v39;
              v58[0] = *(_DWORD *)(v6 + 24);
              CFNumberRef v41 = CFNumberCreate(0, kCFNumberIntType, v58);
              uint64_t v42 = *((void *)v40 + 27);
              v40 += 54;
              int v43 = (*(uint64_t (**)(int *))(v42 + 16))(v40);
              CA::Transaction::add_command((CA::Transaction *)0xE, v43, *(unsigned int *)(v6 + 28), v41, v44);
              CFRelease(v41);
              (**(void (***)(int *))v40)(v40);
            }
          }
        }
        uint64_t v45 = *(void *)(v6 + 56);
        if (v45) {
          goto LABEL_63;
        }
        uint64_t v47 = *(void *)(v6 + 48);
        if (v47
          && ((uint64_t v48 = *(unsigned int *)(v6 + 40), (unint64_t)(v48 - 1) >> 16)
           || 160 * (unint64_t)v48 + 464 <= *(void *)(v47 + 16)))
        {
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          uint64_t v56 = (CA::Render::ImageQueue *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x118uLL, 0x743898A5uLL);
          if (v56)
          {
            CA::Render::ImageQueue::ImageQueue(v56, *(atomic_uint **)(v6 + 48), *(_DWORD *)(v6 + 40));
            *(void *)(v6 + 56) = v57;
            X::WeakDetails::Ptr::set((id *)(v57 + 208), (id)v6, 1);
            uint64_t v45 = *(void *)(v6 + 56);
            *(_DWORD *)(v45 + 184) = *(_DWORD *)(v6 + 28);
LABEL_63:
            if (*(_DWORD *)(v6 + 212))
            {
              mach_port_name_t v46 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 40))(v7);
              uint64_t v45 = *(void *)(v6 + 56);
            }
            else
            {
              mach_port_name_t v46 = 0;
            }
            CA::Render::ImageQueue::set_client_port(v45, v46);
            uint64_t v49 = *(CA::Render::Context **)(v6 + 56);
            *((_DWORD *)v49 + 5CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *(_DWORD *)(v6 + 216);
            CA::Render::Context::remove_image_queue(v49, v50);
            BOOL v51 = (CA::Render::Context *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 8))(v7);
            if (v51)
            {
              uint64_t v52 = (atomic_uint *)v51;
              CA::Render::Context::add_image_queue(v51, *(CA::Render::Object **)(v6 + 56));
              if (atomic_fetch_add(v52 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v52 + 16))(v52);
              }
            }
            uint64_t v14 = *(void *)(v6 + 56);
            if (v14)
            {
              unsigned int v53 = (atomic_uint *)(v14 + 8);
              if (!atomic_fetch_add((atomic_uint *volatile)(v14 + 8), 1u))
              {
                uint64_t v14 = 0;
                atomic_fetch_add(v53, 0xFFFFFFFF);
              }
            }
            goto LABEL_76;
          }
          uint64_t v14 = 0;
          *(void *)(v6 + 56) = 0;
        }
        else
        {
          uint64_t v14 = 0;
        }
LABEL_76:
        os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 16));
        return v14;
      }
    }
  }
  return 0;
}

BOOL CA::Context::connect_remote(CA::Context *this)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 15);
  if (!v2) {
    goto LABEL_12;
  }
  Boolean Value = CFDictionaryGetValue(v2, @"port_number");
  if (!Value)
  {
    CFDictionaryRef v6 = (const __CFDictionary *)*((void *)this + 15);
    if (v6)
    {
      CFStringRef v7 = (const __CFString *)CFDictionaryGetValue(v6, @"port_name");
      if (v7)
      {
        CFStringRef v8 = v7;
        CStringPtr = (char *)CFStringGetCStringPtr(v7, 0x8000100u);
        if (!CStringPtr)
        {
          MEMORY[0x1F4188790](0);
          CStringPtr = v13;
          bzero(v13, 0x400uLL);
          if (!CFStringGetCString(v8, v13, 1024, 0x8000100u))
          {
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              int v12 = x_log_category_api;
              if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl(&dword_184668000, v12, OS_LOG_TYPE_ERROR, "Failed to get Context port name!", buf, 2u);
              }
            }
            return 0;
          }
        }
LABEL_13:
        mach_port_t ServerPort = CARenderServerGetServerPort(CStringPtr);
        BOOL v11 = CA::Context::connect_remote(this, ServerPort);
        mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
        return v11;
      }
    }
LABEL_12:
    CStringPtr = 0;
    goto LABEL_13;
  }
  mach_port_t v4 = CA_CFIntValue(Value);

  return CA::Context::connect_remote(this, v4);
}

BOOL CA::Context::connect_remote(CA::Context *this, mach_port_t a2)
{
  mach_msg_return_t v16;
  mach_error_t v17;
  mach_port_name_t v18;
  pid_t v19;
  kern_return_t v20;
  mach_error_t v21;
  uint64_t v22;
  BOOL result;
  const char *v24;
  NSObject *v25;
  uint32_t v26;
  int v27;
  unsigned int NeededAlignment;
  uint64_t v29;
  int v30;
  char *v31;
  NSObject *log;
  uint64_t v33;
  unsigned char msg[36];
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  task_id_token_t v40;
  uint64_t v41;
  const UInt8 *v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;

  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    if (x_log_hook_p()) {
      goto LABEL_65;
    }
    mach_port_name_t v22 = x_log_category_api;
    float result = os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)int msg = 0;
    mach_port_name_t v24 = "Null Context server port!";
    unsigned int v25 = v22;
    uint64_t v26 = 2;
    goto LABEL_68;
  }
  if (CARenderServerGetServerPort(0) == a2) {
    *((unsigned char *)this + 241) |= 0x80u;
  }
  if (dyld_program_sdk_at_least()) {
    int v4 = 0;
  }
  else {
    int v4 = 8;
  }
  uint64_t v5 = (const void *)*((void *)this + 15);
  if (v5)
  {
    CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF98], v5, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    CFDictionaryRef v7 = (const __CFDictionary *)*((void *)this + 15);
    if (v7)
    {
      Boolean Value = CFDictionaryGetValue(v7, @"client_port_number");
      if (Value)
      {
        unsigned int v9 = CA_CFIntValue(Value);
        goto LABEL_15;
      }
    }
  }
  else
  {
    CFDataRef Data = 0;
  }
  unsigned int v9 = CA::Context::_user_client_port;
LABEL_15:
  task_id_token_t v10 = CA::MachPortUtil::task_identity_port(void)::task[0];
  if (!CA::MachPortUtil::task_identity_port(void)::task[0])
  {
    task_create_identity_token(*MEMORY[0x1E4F14960], CA::MachPortUtil::task_identity_port(void)::task);
    task_id_token_t v10 = CA::MachPortUtil::task_identity_port(void)::task[0];
    if (Data) {
      goto LABEL_17;
    }
LABEL_19:
    BytePtr = 0;
    int Length = 0;
    goto LABEL_20;
  }
  if (!Data) {
    goto LABEL_19;
  }
LABEL_17:
  BytePtr = CFDataGetBytePtr(Data);
  int Length = CFDataGetLength(Data);
LABEL_20:
  {
    uint64_t v18 = *MEMORY[0x1E4F14960];
    uint64_t v19 = getpid();
    if (v20)
    {
      size_t v21 = v20;
      if (x_log_hook_p())
      {
        mach_error_string(v21);
        x_log_();
      }
      else
      {
        log = x_log_category_api;
        if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int msg = 67109378;
          *(_DWORD *)&msg[4] = v21;
          *(_WORD *)&msg[8] = 2080;
          *(void *)&msg[10] = mach_error_string(v21);
          _os_log_impl(&dword_184668000, log, OS_LOG_TYPE_ERROR, "task_name_for_pid failed [0x%x %s]", msg, 0x12u);
        }
      }
    }
  }
  unsigned int v14 = CA::Context::client_port((mach_port_context_t)this);
  memset(&msg[4], 0, 32);
  CFNumberRef v41 = 0x13000000000000;
  *(_DWORD *)&msg[24] = 5;
  *(_DWORD *)&msg[28] = v13;
  unint64_t v35 = 1245184;
  uint64_t v36 = v14;
  int v37 = 1245184;
  uint64_t v38 = v9;
  int v39 = 1245184;
  uint64_t v40 = v10;
  uint64_t v42 = BytePtr;
  int v43 = 16777472;
  uint64_t v44 = Length;
  uint64_t v45 = *MEMORY[0x1E4F14068];
  mach_port_name_t v46 = v4;
  uint64_t v47 = Length;
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = a2;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)int msg = -2147478253;
  *(void *)&msg[16] = 0x9D0A00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_t reply_port = *(_DWORD *)&msg[12];
  }
  uint64_t v16 = mach_msg((mach_msg_header_t *)msg, 3, 0x6Cu, 0x40u, reply_port, 0, 0);
  uint64_t v17 = v16;
  if ((v16 - 268435458) <= 0xE && ((1 << (v16 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_52;
  }
  if (v16)
  {
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    goto LABEL_52;
  }
  if (*(_DWORD *)&msg[20] == 71)
  {
    uint64_t v17 = -308;
  }
  else if (*(_DWORD *)&msg[20] == 40302)
  {
    if ((*(_DWORD *)msg & 0x80000000) != 0)
    {
      uint64_t v17 = -300;
      if (*(_DWORD *)&msg[24] != 1 || *(_DWORD *)&msg[4] != 56 || *(_DWORD *)&msg[8]) {
        goto LABEL_51;
      }
      if (HIWORD(v35) << 16 == 1114112)
      {
        uint64_t v17 = 0;
        uint64_t v27 = v37;
        *((_DWORD *)this + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *(_DWORD *)&msg[28];
        *((_DWORD *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v27;
        *((_DWORD *)this + 3) = v38;
        goto LABEL_52;
      }
    }
    else if (*(_DWORD *)&msg[4] == 36)
    {
      uint64_t v17 = -300;
      if (*(_DWORD *)&msg[32])
      {
        if (*(_DWORD *)&msg[8]) {
          uint64_t v17 = -300;
        }
        else {
          uint64_t v17 = *(_DWORD *)&msg[32];
        }
      }
      goto LABEL_51;
    }
    uint64_t v17 = -300;
  }
  else
  {
    uint64_t v17 = -301;
  }
LABEL_51:
  mach_msg_destroy((mach_msg_header_t *)msg);
LABEL_52:
  if (Data) {
    CFRelease(Data);
  }
  if (v17)
  {
    if (v17 == 268435459)
    {
      *((unsigned char *)this + 241) |= 2u;
    }
    else if (v17 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    if (x_log_hook_p())
    {
      mach_error_string(v17);
LABEL_65:
      x_log_();
      return 0;
    }
    unint64_t v29 = x_log_category_api;
    float result = os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    uint64_t v30 = *((_DWORD *)this + 1);
    uint64_t v31 = mach_error_string(v17);
    *(_DWORD *)int msg = 67109634;
    *(_DWORD *)&msg[4] = v30;
    *(_WORD *)&msg[8] = 1024;
    *(_DWORD *)&msg[10] = v17;
    *(_WORD *)&msg[14] = 2080;
    *(void *)&msg[16] = v31;
    mach_port_name_t v24 = "Unable to register with server (client=0x%x) [0x%x %s]";
    unsigned int v25 = v29;
    uint64_t v26 = 24;
LABEL_68:
    _os_log_impl(&dword_184668000, v25, OS_LOG_TYPE_ERROR, v24, msg, v26);
    return 0;
  }
  float result = 1;
  if ((CA::Context::connect_remote::image_requirements_set & 1) == 0)
  {
    CA::Context::connect_remote::image_requirements_set = 1;
    NeededAlignment = CARenderServerGetNeededAlignment(a2);
    CADeviceSetMinimumAlignment(NeededAlignment);
    *(_DWORD *)int msg = 0;
    uint64_t v33 = 0;
    if (CARenderServerGetMaxRenderableIOSurfaceSize(a2, msg, (_DWORD *)&v33 + 1, &v33)) {
      CADeviceSetMaxRenderableIOSurfaceSize(*(unsigned int *)msg, HIDWORD(v33), v33);
    }
    return 1;
  }
  return result;
}

uint64_t CA::Context::client_port(mach_port_context_t context)
{
  uint64_t v3 = (int *)(context + 176);
  uint64_t result = *(unsigned int *)(context + 176);
  if (!result)
  {
    if (*(unsigned char *)(context + 241))
    {
      return 0;
    }
    else
    {
      uint64_t v4 = CA::MachPortUtil::ClientIPC::create((mach_port_context_t)v3, "CA::Context");
      CA_CLIENT_MACH_PORT_ALLOCATE_FAILED(v4, *v3);
      return *v3;
    }
  }
  return result;
}

uint64_t CA_CLIENT_MACH_PORT_ALLOCATE_FAILED(uint64_t result, int a2)
{
  if ((a2 - 1) >= 0xFFFFFFFE)
  {
    int v2 = result;
    uint64_t v3 = mach_error_string(result);
    x_log_crash("Client mach port creation failed 0x%x : %s", v2, v3);
    abort();
  }
  return result;
}

void CA::Context::did_connect(CA::Context *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
  if (CA::all_contexts(void)::contexts_data_initialized)
  {
    uint64_t v3 = qword_1EB2AC6F8;
    uint64_t v2 = qword_1EB2AC700;
    if (qword_1EB2AC6F8 < (unint64_t)qword_1EB2AC700)
    {
      *(void *)qword_1EB2AC6F8 = this;
      uint64_t v4 = v3 + 8;
      goto LABEL_20;
    }
    uint64_t v5 = (void *)CA::all_contexts(void)::contexts_data;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v3 = 0;
    uint64_t v2 = 0;
    CA::all_contexts(void)::contexts_data = 0;
    qword_1EB2AC6F8 = 0;
    qword_1EB2AC700 = 0;
    CA::all_contexts(void)::contexts_data_initialized = 1;
  }
  uint64_t v6 = (v3 - (uint64_t)v5) >> 3;
  unint64_t v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) >> 61) {
    abort();
  }
  uint64_t v8 = v2 - (void)v5;
  if (v8 >> 2 > v7) {
    unint64_t v7 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v7;
  }
  if (v9)
  {
    if (v9 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    task_id_token_t v10 = (char *)operator new(8 * v9);
  }
  else
  {
    task_id_token_t v10 = 0;
  }
  BOOL v11 = &v10[8 * v6];
  *(void *)BOOL v11 = this;
  uint64_t v4 = (uint64_t)(v11 + 8);
  if ((void *)v3 != v5)
  {
    do
    {
      uint64_t v12 = *(void *)(v3 - 8);
      v3 -= 8;
      *((void *)v11 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v12;
      v11 -= 8;
    }
    while ((void *)v3 != v5);
    uint64_t v5 = (void *)CA::all_contexts(void)::contexts_data;
  }
  CA::all_contexts(void)::contexts_data = (uint64_t)v11;
  qword_1EB2AC6F8 = v4;
  qword_1EB2AC700 = (uint64_t)&v10[8 * v9];
  if (v5) {
    operator delete(v5);
  }
LABEL_20:
  qword_1EB2AC6F8 = v4;
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
  int v13 = *((void *)this + 24);
  if (v13)
  {
    dispatch_activate(v13);
  }
}

void sub_1847BECB0(_Unwind_Exception *a1)
{
}

uint64_t CA::MachPortUtil::ClientIPC::create(mach_port_context_t context, const char *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)context || *(void *)(context + 8) || *(void *)(context + 16)) {
    __assert_rtn("create", "CAMachPortUtil.cpp", 67, "_port == MACH_PORT_NULL && !_queue && !_source");
  }
  mach_port_name_t name = 0;
  *(_OWORD *)&options.uint64_t flags = xmmword_1849A8140;
  options.reserved[1] = 0;
  uint64_t v4 = mach_port_construct(*MEMORY[0x1E4F14960], &options, context, &name);
  if (!v4 && name + 1 >= 2)
  {
    uint64_t v5 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
    uint64_t v6 = dispatch_queue_create(a2, v5);
    *(void *)(context + 8) = v6;
    unint64_t v7 = dispatch_source_create(MEMORY[0x1E4F14458], name, 0, v6);
    *(void *)(context + 16) = v7;
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 0x40000000;
    handler[2] = ___ZN2CA12MachPortUtil9ClientIPC6createEPKc_block_invoke;
    handler[3] = &__block_descriptor_tmp_4_9877;
    mach_port_name_t v13 = name;
    dispatch_source_set_event_handler(v7, handler);
    uint64_t v8 = *(NSObject **)(context + 16);
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 0x40000000;
    unint64_t v10[2] = ___ZN2CA12MachPortUtil9ClientIPC6createEPKc_block_invoke_2;
    v10[3] = &__block_descriptor_tmp_5_9878;
    mach_port_name_t v11 = name;
    v10[4] = context;
    dispatch_source_set_cancel_handler(v8, v10);
    *(_DWORD *)CFAllocatorContext context = name;
  }
  return v4;
}

void sub_1847BF244(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
  if (*v3) {
    CFRelease(*v3);
  }
  if (*v2)
  {
    if (v1[88]) {
      objc_storeWeakOrNil(v2, 0);
    }
    else {
      *uint64_t v2 = 0;
    }
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, v1);
  _Unwind_Resume(a1);
}

void CA::Context::set_objc_context(id *this, void *a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
  X::WeakDetails::Ptr::set(this + 10, a2, 1);

  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
}

double CA::Render::ImageQueue::ImageQueue(CA::Render::ImageQueue *this, atomic_uint *a2, int a3)
{
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = 25;
  ++dword_1EB2ADE2C;
  *(void *)this = &unk_1ED02CC60;
  if (a2)
  {
    uint64_t v3 = a2;
    if (!atomic_fetch_add(a2 + 2, 1u))
    {
      uint64_t v3 = 0;
      atomic_fetch_add(a2 + 2, 0xFFFFFFFF);
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  *((void *)this + 2) = v3;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0x7FF0000000000000;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 1CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  *((void *)this + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  *((void *)this + 12) = 1065353216;
  *((_DWORD *)this + 26) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0x7FF0000000000000;
  *((_DWORD *)this + 34) = 0;
  *((unsigned char *)this + 14CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  *((_DWORD *)this + 36) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)((char *)this + 148) = result;
  *((void *)this + 2CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  *((void *)this + 2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  *((unsigned char *)this + 176) = 0;
  *((_DWORD *)this + 45) = a3;
  *((void *)this + 26) = 0;
  *((unsigned char *)this + 216) = 0;
  *(void *)((char *)this + 188) = 0;
  *(void *)((char *)this + 196) = 0;
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  uint64_t v9 = *((void *)a2 + 3);
  *(_DWORD *)(v9 + 88) = atomic_fetch_add(CA::Render::ImageQueue::ImageQueue(CA::Render::Shmem *,unsigned long)::_next_image_queue_id, 1u)+ 1;
  return result;
}

uint64_t CA::Render::ImageQueue::set_client_port(uint64_t this, mach_port_name_t name)
{
  mach_port_name_t v3 = *(_DWORD *)(this + 196);
  if (v3 != name)
  {
    uint64_t v4 = this;
    uint64_t v5 = (ipc_space_t *)MEMORY[0x1E4F14960];
    if (v3) {
      this = mach_port_deallocate(*MEMORY[0x1E4F14960], v3);
    }
    *(_DWORD *)(v4 + 196) = 0;
    if (name - 1 <= 0xFFFFFFFD)
    {
      this = mach_port_mod_refs(*v5, name, 0, 1);
      if (!this) {
        *(_DWORD *)(v4 + 196) = name;
      }
    }
  }
  return this;
}

uint64_t CADeviceSetMinimumAlignment(unint64_t a1)
{
  uint64_t v2 = 0;
  int8x16_t v3 = (int8x16_t)vdupq_n_s64(a1);
  do
  {
    ++v2;
  }
  while (v2 != 2);
}

void CADeviceSetMaxRenderableIOSurfaceSize(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v9[3] = *MEMORY[0x1E4F143B8];
  v9[0] = a1;
  v9[1] = a2;
  v9[2] = a3;
    uint64_t v6 = a1;
    uint64_t v7 = a2;
    uint64_t v8 = a3;
}

uint64_t CARenderServerGetNeededAlignment(mach_port_t a1)
{
  mach_msg_return_t v4;
  mach_port_t msgh_remote_port;
  BOOL v6;
  uint64_t msgh_local_port;
  mach_msg_header_t msg[2];
  uint64_t v10;

  task_id_token_t v10 = *MEMORY[0x1E4F143B8];
  mach_port_t ServerPort = a1;
  if (!a1)
  {
    mach_port_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0;
    }
  }
  *(_OWORD *)&msg[1].msgh_remote_port = 0u;
  *(_OWORD *)&msg[0].mach_msg_id_t msgh_id = 0u;
  msg[0].msgh_size = 0;
  mach_port_t reply_port = mig_get_reply_port();
  msg[0].msgh_remote_port = ServerPort;
  msg[0].msgh_local_port = reply_port;
  msg[0].msgh_bits = 5395;
  *(void *)&msg[0].msgh_voucher_port = 0x9D4100000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(msg);
    mach_port_t reply_port = msg[0].msgh_local_port;
  }
  uint64_t v4 = mach_msg(msg, 3, 0x18u, 0x30u, reply_port, 0, 0);
  msgh_remote_port = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg[0].msgh_local_port);
    goto LABEL_28;
  }
  if (v4)
  {
    mig_dealloc_reply_port(msg[0].msgh_local_port);
    goto LABEL_27;
  }
  if (msg[0].msgh_id == 71)
  {
    msgh_remote_port = -308;
  }
  else if (msg[0].msgh_id == 40357)
  {
    if ((msg[0].msgh_bits & 0x80000000) == 0)
    {
      if (msg[0].msgh_size == 40)
      {
        if (!msg[0].msgh_remote_port)
        {
          msgh_remote_port = msg[1].msgh_remote_port;
          if (!msg[1].msgh_remote_port)
          {
            msgh_local_port = msg[1].msgh_local_port;
            if (a1) {
              return msgh_local_port;
            }
            goto LABEL_29;
          }
          goto LABEL_26;
        }
      }
      else if (msg[0].msgh_size == 36)
      {
        if (msg[0].msgh_remote_port) {
          uint64_t v6 = 1;
        }
        else {
          uint64_t v6 = msg[1].msgh_remote_port == 0;
        }
        if (v6) {
          msgh_remote_port = -300;
        }
        else {
          msgh_remote_port = msg[1].msgh_remote_port;
        }
        goto LABEL_26;
      }
    }
    msgh_remote_port = -300;
  }
  else
  {
    msgh_remote_port = -301;
  }
LABEL_26:
  mach_msg_destroy(msg);
LABEL_27:
  if (msgh_remote_port == -81182719)
  {
    x_log_crash("Unentitled call to server!");
    abort();
  }
LABEL_28:
  msgh_local_port = 16;
  if (!a1) {
LABEL_29:
  }
    mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
  return msgh_local_port;
}

uint64_t CARenderServerGetMaxRenderableIOSurfaceSize(mach_port_name_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  mach_msg_return_t v11;
  int v12;
  BOOL v13;
  int v14;
  int v15;
  int rcv_name;
  mach_port_name_t rcv_name_4;
  mach_port_t rcv_name_8;
  unsigned char rcv_name_12[20];
  long long v20;
  int v21;
  uint64_t v22;

  mach_port_name_t v22 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  mach_port_name_t v8 = a1;
  if (a1 || (result = CARenderServerGetServerPort(0), (mach_port_name_t v8 = result) != 0))
  {
    size_t v21 = 0;
    uint64_t v20 = 0u;
    *(_OWORD *)&rcv_name_12[4] = 0u;
    rcv_mach_port_name_t name = 0;
    mach_port_t reply_port = mig_get_reply_port();
    rcv_name_4 = v8;
    rcv_name_8 = reply_port;
    uint64_t v15 = 5395;
    *(void *)rcv_name_12 = 0x9D5600000000;
    if (MEMORY[0x1E4F14B18])
    {
      voucher_mach_msg_set((mach_msg_header_t *)&v15);
      mach_port_t reply_port = rcv_name_8;
    }
    mach_port_name_t v11 = mach_msg((mach_msg_header_t *)&v15, 3, 0x18u, 0x38u, reply_port, 0, 0);
    uint64_t v12 = v11;
    if ((v11 - 268435458) <= 0xE && ((1 << (v11 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(rcv_name_8);
      if (a1) {
        return 1;
      }
LABEL_29:
      mach_port_deallocate(*MEMORY[0x1E4F14960], v8);
      return 1;
    }
    if (v11)
    {
      mig_dealloc_reply_port(rcv_name_8);
      goto LABEL_27;
    }
    if (*(_DWORD *)&rcv_name_12[4] == 71)
    {
      uint64_t v12 = -308;
    }
    else if (*(_DWORD *)&rcv_name_12[4] == 40378)
    {
      if ((v15 & 0x80000000) == 0)
      {
        if (rcv_name == 48)
        {
          if (!rcv_name_4)
          {
            uint64_t v12 = *(_DWORD *)&rcv_name_12[16];
            if (!*(_DWORD *)&rcv_name_12[16])
            {
              unsigned int v14 = DWORD1(v20);
              *a2 = v20;
              *a3 = v14;
              *a4 = DWORD2(v20);
              if (a1) {
                return 1;
              }
              goto LABEL_29;
            }
            goto LABEL_26;
          }
        }
        else if (rcv_name == 36)
        {
          if (rcv_name_4) {
            mach_port_name_t v13 = 1;
          }
          else {
            mach_port_name_t v13 = *(_DWORD *)&rcv_name_12[16] == 0;
          }
          if (v13) {
            uint64_t v12 = -300;
          }
          else {
            uint64_t v12 = *(_DWORD *)&rcv_name_12[16];
          }
          goto LABEL_26;
        }
      }
      uint64_t v12 = -300;
    }
    else
    {
      uint64_t v12 = -301;
    }
LABEL_26:
    mach_msg_destroy((mach_msg_header_t *)&v15);
LABEL_27:
    if (v12 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    if (a1) {
      return 1;
    }
    goto LABEL_29;
  }
  return result;
}

uint64_t CA::Context::Generic::client_port(CA::Context::Generic *this)
{
  return CA::Context::client_port(*((void *)this + 1));
}

void CA::Render::Context::remove_image_queue(CA::Render::Context *this, CA::Render::Object *a2)
{
  if (*((unsigned char *)this + 12) == 25)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Context::_image_queues_lock);
    uint64_t v3 = *((void *)this + 29);
    if (v3)
    {
      *((void *)this + 29) = 0;
      uint64_t v5 = *(CA::Render::Context ***)(v3 + 360);
      uint64_t v4 = *(CA::Render::Context ***)(v3 + 368);
      if (v5 != v4)
      {
        while (*v5 != this)
        {
          if (++v5 == v4)
          {
            uint64_t v5 = *(CA::Render::Context ***)(v3 + 368);
            break;
          }
        }
      }
      if (v5 != v4)
      {
        int64_t v6 = (char *)v4 - (char *)(v5 + 1);
        if (v4 != v5 + 1) {
          memmove(v5, v5 + 1, (char *)v4 - (char *)(v5 + 1));
        }
        *(void *)(v3 + 368) = (char *)v5 + v6;
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Context::_image_queues_lock);
  }
}

void CA::Context::invalidate(CA::Context *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 16);
  uint64_t v3 = (CA::Transaction *)pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v5 = *(CA::Transaction **)(StatusReg + 576);
  if (!v5)
  {
    uint64_t v3 = (CA::Transaction *)CA::Transaction::create(v3);
    uint64_t v5 = v3;
  }
  int v6 = **((_DWORD **)v5 + 13);
  if (!v6)
  {
    CA::Transaction::begin_transaction(v3);
    *((unsigned char *)v5 + 116) = *((unsigned char *)v5 + 116) & 0xFB | (4 * (pthread_main_np() == 0));
  }
  uint64_t v7 = *((void *)this + 12);
  if (v7)
  {
    CA::Layer::set_visible(*(CA::Layer **)(v7 + 16), 0);
    CFRelease(*((CFTypeRef *)this + 12));
    *((void *)this + 12) = 0;
  }
  *((unsigned char *)this + 241) |= 8u;
  pthread_mutex_unlock(v2);
  if (!v6)
  {
    uint64_t v9 = *(CA::Transaction **)(StatusReg + 576);
    if (v9)
    {
      if (**((_DWORD **)v9 + 13))
      {
        CA::Transaction::pop(v9, v8);
      }
    }
  }
}

void sub_1847BFBAC(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

CA::Transaction *CA::Transaction::begin_transaction(CA::Transaction *this)
{
  uint64_t result = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (result || (uint64_t result = (CA::Transaction *)CA::Transaction::create(0)) != 0)
  {
    return (CA::Transaction *)CA::Transaction::push(result, 0, 0);
  }
  return result;
}

_OWORD *CA::Transaction::create(CA::Transaction *this)
{
  if (CA::Render::memory_once[0] != -1) {
    dispatch_once_f(CA::Render::memory_once, 0, (dispatch_function_t)CA::Render::init_memory_warnings_);
  }
  uint64_t v1 = malloc_type_malloc(0x2000uLL, 0xEC1F78CDuLL);
  uint64_t v2 = v1;
  if (v1)
  {
    v1[21] = 0u;
    v1[22] = 0u;
    v1[19] = 0u;
    v1[20] = 0u;
    v1[17] = 0u;
    v1[18] = 0u;
    v1[15] = 0u;
    v1[16] = 0u;
    v1[13] = 0u;
    v1[14] = 0u;
    v1[11] = 0u;
    v1[12] = 0u;
    v1[9] = 0u;
    v1[10] = 0u;
    v1[7] = 0u;
    v1[8] = 0u;
    v1[5] = 0u;
    v1[6] = 0u;
    v1[3] = 0u;
    v1[4] = 0u;
    v1[1] = 0u;
    v1[2] = 0u;
    _OWORD *v1 = 0u;
    if (CA::Transaction::create(void)::once[0] != -1) {
      dispatch_once_f(CA::Transaction::create(void)::once, 0, (dispatch_function_t)CA::Transaction::init);
    }
    *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576) = v2;
    *((unsigned char *)v2 + 116) = *((unsigned char *)v2 + 116) & 0xFE | (pthread_main_np() != 0);
    *((void *)v2 + 13) = (char *)v2 + 120;
    if (dyld_program_sdk_at_least()) {
      char v3 = 0;
    }
    else {
      char v3 = 16;
    }
    *((unsigned char *)v2 + 116) = *((unsigned char *)v2 + 116) & 0xEF | v3;
    if (dyld_program_sdk_at_least()) {
      char v4 = 0;
    }
    else {
      char v4 = 32;
    }
    *((unsigned char *)v2 + 116) = *((unsigned char *)v2 + 116) & 0xDF | v4;
    *(_DWORD *)(*((void *)v2 + 13) + 4) = -1;
    unsigned int add = atomic_fetch_add(&CA::Transaction::next_transaction_seed, 1u);
    uint64_t v6 = *((void *)v2 + 13);
    *(_DWORD *)(v6 + 20CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = add + 1;
    *((_DWORD *)v2 + 24) = -1;
    *(_DWORD *)(v6 + 56) = -1;
  }
  return v2;
}

void *x_hash_table_values(uint64_t a1)
{
  uint64_t result = 0;
  uint64_t v3 = 0;
  uint64_t v4 = 1 << *(_DWORD *)a1;
  do
  {
    uint64_t v5 = *(void **)(*(void *)(a1 + 16) + 8 * v3);
    if (v5)
    {
      uint64_t v6 = result;
      do
      {
        uint64_t v7 = v5[3];
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        uint64_t result = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
        *uint64_t result = v7;
        result[1] = v6;
        uint64_t v5 = (void *)*v5;
        uint64_t v6 = result;
      }
      while (v5);
    }
    ++v3;
  }
  while (v3 != v4);
  return result;
}

void query_displays(void)
{
  v52[1] = *(const UInt8 **)MEMORY[0x1E4F143B8];
  int ServerPort = CARenderServerGetServerPort(0);
  if (ServerPort)
  {
    mach_port_name_t v1 = ServerPort;
    v52[0] = 0;
    unsigned int v51 = 0;
    int v2 = _CASGetDisplays(ServerPort, v52, &v51);
    if (v2 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    int v3 = v2;
    uint64_t v4 = (vm_map_t *)MEMORY[0x1E4F14960];
    mach_port_deallocate(*MEMORY[0x1E4F14960], v1);
    if (v3)
    {
      x_log_crash("Unable to query displays from server (%d)", v3);
      abort();
    }
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF98];
    uint64_t v6 = v52[0];
    mach_vm_size_t v7 = v51;
    CFDataRef v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF98], v52[0], v51);
    mach_vm_deallocate(*v4, (mach_vm_address_t)v6, v7);
    if (v8)
    {
      CFArrayRef v9 = (const __CFArray *)CFPropertyListCreateWithData(v5, v8, 0, 0, 0);
      CFRelease(v8);
      if (v9)
      {
        CFIndex Count = CFArrayGetCount(v9);
        CFIndex v11 = Count;
        unint64_t v47 = 8 * Count;
        if ((unint64_t)(8 * Count) > 0x1000)
        {
          mach_port_name_t v13 = (char *)malloc_type_malloc(8 * Count, 0xD16C463uLL);
        }
        else
        {
          MEMORY[0x1F4188790](Count);
          mach_port_name_t v13 = (char *)&v46 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
          bzero(v13, v12);
        }
        CFArrayRef v48 = v9;
        v53.locatiouint64_t n = 0;
        v53.CFIndex length = v11;
        CFArrayGetValues(v9, v53, (const void **)v13);
        id v14 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
        uint64_t v49 = v13;
        if (v11)
        {
          uint64_t v15 = 0;
          uint64_t v16 = 0;
          do
          {
            CFDictionaryRef v17 = *(const __CFDictionary **)&v13[8 * v15];
            Boolean Value = CFDictionaryGetValue(v17, @"kCADisplayName");
            CFStringRef v19 = (const __CFString *)CFDictionaryGetValue(v17, @"kCADisplayDeviceName");
            if (Value) {
              BOOL v20 = v19 == 0;
            }
            else {
              BOOL v20 = 1;
            }
            if (!v20)
            {
              CFStringRef v21 = v19;
              uint64_t v50 = v16;
              int Int = CA_CFDictionaryGetInt(v17, @"kCADisplayId");
              uint64_t v23 = [(id)_displays count];
              if (v23)
              {
                uint64_t v24 = v23;
                uint64_t v25 = 0;
                while (1)
                {
                  uint64_t v26 = (void *)[(id)_displays objectAtIndexedSubscript:v25];
                  if ([v26 displayId] == Int) {
                    break;
                  }
                  if (v24 == ++v25) {
                    goto LABEL_19;
                  }
                }
                [v14 addObject:v26];
                mach_port_name_t v13 = v49;
                uint64_t v16 = v50;
              }
              else
              {
LABEL_19:
                malloc_zone = (malloc_zone_t *)get_malloc_zone();
                uint64_t v16 = 1;
                int v28 = (CA::Display::Display *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x300uLL, 0x743898A5uLL);
                if (v28)
                {
                  unint64_t v29 = v28;
                  *(void *)CA::Display::Display::Display(v28, Value, v21, Int) = &unk_1ED0302E0;
                  id v30 = [[CADisplay alloc] _initWithDisplay:v29];
                  [v14 addObject:v30];
                  if (!_mainDisplay
                    && objc_msgSend((id)objc_msgSend(v30, "name"), "isEqualToString:", @"LCD"))
                  {
                    id v31 = v30;

                    _mainDisplay = (uint64_t)v30;
                  }
                  mach_port_name_t v13 = v49;
                  if (!_tvoutDisplay
                    && ((objc_msgSend((id)objc_msgSend(v30, "name"), "isEqualToString:", @"TVOut") & 1) != 0
                     || objc_msgSend((id)objc_msgSend(v30, "name"), "isEqualToString:", @"External")))
                  {
                    id v32 = v30;

                    _tvoutDisplay = (uint64_t)v30;
                  }

                  uint64_t v16 = 1;
                }
                else
                {
                  mach_port_name_t v13 = v49;
                }
              }
            }
            ++v15;
          }
          while (v15 != v11);
        }
        else
        {
          LOBYTE(v16) = 0;
        }
        if (_tvoutDisplay) {
          BOOL v33 = _mainDisplay == 0;
        }
        else {
          BOOL v33 = 0;
        }
        if (v33) {
          _mainDisplay = (uint64_t)(id)_tvoutDisplay;
        }
        char v34 = v16;
        uint64_t v35 = [(id)_displays count];
        if (v35)
        {
          uint64_t v36 = v35;
          for (uint64_t i = 0; i != v36; ++i)
          {
            uint64_t v38 = (void *)[(id)_displays objectAtIndexedSubscript:i];
            uint64_t v39 = [v14 count];
            if (v39)
            {
              uint64_t v40 = v39;
              uint64_t v41 = 0;
              while (1)
              {
                uint64_t v42 = (void *)[v14 objectAtIndexedSubscript:v41];
                int v43 = [v38 displayId];
                if (v43 == [v42 displayId]) {
                  break;
                }
                if (v40 == ++v41) {
                  goto LABEL_45;
                }
              }
            }
            else
            {
LABEL_45:
              [v38 _finalize];
              char v34 = 1;
            }
          }
        }
        if (v47 > 0x1000) {
          free(v49);
        }
        CFRelease(v48);
        if (v34)
        {
          uint64_t v44 = (void *)_displays;
          _displays = (uint64_t)v14;
          id v45 = v44;
        }
        else
        {
        }
      }
    }
  }
}

uint64_t CA_CFIntValue(const void *a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFBooleanGetTypeID()) {
    return *MEMORY[0x1E4F1CFC8] != (void)a1;
  }
  if (v2 != CFNumberGetTypeID()) {
    return 0;
  }
  unsigned int valuePtr = 0;
  CFNumberGetValue((CFNumberRef)a1, kCFNumberIntType, &valuePtr);
  return valuePtr;
}

CA::Display::Display *CA::Display::Display::Display(CA::Display::Display *this, CFTypeRef cf, const __CFString *a3, int a4)
{
  *(void *)this = &unk_1ED0303F0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = CFRetain(cf);
  CFTypeRef v7 = CFRetain(a3);
  *(_OWORD *)((char *)this + 248) = 0u;
  *((void *)this + 23) = 0;
  *((void *)this + 12) = v7;
  *((_DWORD *)this + 26) = a4;
  *((void *)this + 24) = 0;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 1CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0u;
  *((void *)this + 22) = (char *)this + 184;
  *(_OWORD *)((char *)this + 20CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((_DWORD *)this + 58) = 1065353216;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 28CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0u;
  __asm { FMOV            V0.2S, #1.0 }
  *((void *)this + 37) = _D0;
  *((void *)this + 43) = 0;
  *((void *)this + 44) = 0;
  *((_DWORD *)this + 9CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  *((_WORD *)this + 184) = 0;
  *((void *)this + 47) = 0;
  *((void *)this + 48) = 0;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 2CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0u;
  *(void *)((char *)this + 333) = 0;
  *((void *)this + 49) = 0x3FF0000000000000;
  *((void *)this + 5CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  *((void *)this + 5CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  *((_DWORD *)this + 104) = 1;
  *(_OWORD *)((char *)this + 42CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0u;
  *(_OWORD *)((char *)this + 436) = 0u;
  *(void *)((char *)this + 452) = 0;
  *((void *)this + 58) = &unk_1ED0303D0;
  *((_DWORD *)this + 118) = a4;
  *(_OWORD *)((char *)this + 476) = 0u;
  *(_OWORD *)((char *)this + 492) = 0u;
  *(_OWORD *)((char *)this + 508) = 0u;
  *(_OWORD *)((char *)this + 524) = 0u;
  *(_OWORD *)((char *)this + 54CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0u;
  *(_OWORD *)((char *)this + 556) = 0u;
  *(_OWORD *)((char *)this + 604) = 0u;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 4CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0u;
  *((_OWORD *)this + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *((void *)this + 86) = CAHostTimeWithTime(0.0166666667);
  *((unsigned char *)this + 696) = 10;
  *((unsigned char *)this + 697) &= 0xE2u;
  mach_port_name_t v13 = (char *)operator new(0x180uLL);
  *((void *)this + 72) = v13;
  *((void *)this + 73) = v13;
  *((void *)this + 74) = v13 + 384;
  __asm { FMOV            V0.4S, #1.0 }
  *((_OWORD *)this + 44) = _Q0;
  *((_DWORD *)this + 18CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 1;
  *(_OWORD *)((char *)this + 744) = 0u;
  *(_OWORD *)((char *)this + 724) = 0u;
  *((_WORD *)this + 38CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *((_WORD *)this + 380) & 0xF180 | 0x400;
  x_thread_init_mutex((pthread_mutex_t *)((char *)this + 8), 1);
  return this;
}

void sub_1847C0678(_Unwind_Exception *a1)
{
  CA::WindowServer::Display::ModeSet::~ModeSet((CA::WindowServer::Display::ModeSet *)(v1 + 152));
  _Unwind_Resume(a1);
}

uint64_t x_thread_init_mutex(pthread_mutex_t *a1, char a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    v4.__sig = 0;
    *(void *)v4.__opaque = 0;
    pthread_mutexattr_init(&v4);
    pthread_mutexattr_settype(&v4, 2);
    pthread_mutex_init(a1, &v4);
    return pthread_mutexattr_destroy(&v4);
  }
  else
  {
    return pthread_mutex_init(a1, 0);
  }
}

uint64_t CA::Display::Display::update(CA::Display::Display *this)
{
  mach_msg_return_t v27;
  mach_port_t msgh_remote_port;
  PerModeInfo *v29;
  unint64_t v30;
  unsigned int v31;
  unsigned int *v32;
  unsigned int v33;
  uint64_t v34;
  const char *v35;
  char *v36;
  NSObject *v37;
  uint32_t v38;
  CFStringRef v39;
  BOOL v40;
  BOOL v41;
  BOOL v42;
  BOOL v43;
  unsigned int v44;
  BOOL v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  double v54;
  int v55;
  double v56;
  int v57;
  double v58;
  double v59;
  int v60;
  int v61;
  char v62;
  int v63;
  mem_entry_name_port_t v64;
  uint64_t v65;
  char v66;
  atomic_uint *v67;
  atomic_uint *v68;
  const void *v69;
  const void *v70;
  const void *v71;
  long long v72;
  long long v73;
  double v74;
  double v75;
  unsigned int v77;
  char *v78;
  mach_msg_size_t v79;
  unsigned int v80;
  unsigned int v81;
  char *v82;
  uint64_t v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  vm_map_t *v92;
  unsigned int v93;
  int v94;
  mach_vm_size_t v95;
  int v96;
  int v97;
  BOOL v98;
  BOOL v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  unsigned int v106;
  int v107;
  unsigned int v108;
  int v109;
  unsigned int v110;
  int v111;
  unsigned int v112;
  int v113;
  int v114;
  BOOL v115;
  BOOL v116;
  int v117;
  int v118;
  BOOL v119;
  int v120;
  BOOL v121;
  CFStringRef v122;
  double v123;
  char v124;
  char v125;
  uint64_t v126;
  CFStringRef v127;
  char v128;
  int v129;
  int v130;
  mach_msg_id_t msgh_id;
  uint64_t v132;
  uint64_t v133;
  unsigned int v134;
  uint64_t v135;
  mach_vm_size_t v136;
  BOOL v137;
  BOOL v138;
  mach_vm_address_t address;
  BOOL addressa;
  pthread_mutex_t *v141;
  mach_port_name_t v142;
  uint64_t v143;
  unsigned int v144;
  uint64_t v145;
  uint64_t v146;
  unsigned int v147;
  mach_vm_address_t v148;
  unsigned int v149;
  mach_vm_size_t size;
  int sizea;
  BOOL size_4;
  unint64_t *v153;
  BOOL v154;
  int v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  double v160;
  unint64_t v161;
  long long v162;
  uint64_t v163;
  unsigned int v164;
  uint64_t v165;
  long long v166;
  unsigned int v167;
  uint64_t v168;
  uint64_t v169;
  int v170;
  uint64_t v171;
  uint64_t v172;
  double v173;
  int v174;
  double v175;
  int v176;
  void *__p[2];
  uint64_t v178;
  long long *v179;
  long long v180;
  long long v181;
  long long v182;
  long long v183;
  char v184[16];
  long long v185;
  long long v186;
  long long v187;
  long long v188;
  long long v189;
  long long v190;
  long long v191;
  long long v192;
  long long v193;
  long long v194;
  long long v195;
  long long v196;
  long long v197;
  long long v198;
  long long v199;
  char cStr[16];
  long long v201;
  long long v202;
  long long v203;
  char dest[16];
  long long v205;
  long long v206;
  long long v207;
  mach_msg_header_t msg[4];
  long long v209;
  uint64_t v210;
  mach_msg_size_t v211;
  char v212[744];
  uint64_t v213;

  uint64_t v213 = *MEMORY[0x1E4F143B8];
  if ((*((_WORD *)this + 380) & 0x800) != 0)
  {
    unint64_t v93 = this;
    [MEMORY[0x1E4F1CA00] raise:@"CADisplay" format:@"%p: cannot update immutable CADisplay"];
  }
  CFTypeID v2 = (pthread_mutex_t *)((char *)this + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  mach_port_t v3 = *((_DWORD *)this + 26);
  mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
  uint64_t v5 = *((void *)this + 14);
  if (v5)
  {
    uint64_t v182 = 0u;
    unint64_t v183 = 0u;
    *(_OWORD *)__p = 0u;
    uint64_t v178 = 0;
    uint64_t v180 = 0u;
    unsigned int v181 = 0u;
    unint64_t v179 = &v180;
    LODWORD(v183) = 1065353216;
    uint64_t v210 = 0;
    float64x2_t v209 = 0u;
    memset(msg, 0, sizeof(msg));
    msg[0].msgh_bits = 2;
    if ((*(uint64_t (**)(uint64_t, mach_msg_header_t *))(v5 + 16))(v5, msg))
    {
      int v161 = __PAIR64__(msg[0].msgh_size, msg[0].msgh_remote_port);
      uint64_t v127 = *(CFStringRef *)&msg[1].msgh_bits;
      CFStringRef v8 = *(CFStringRef *)&msg[0].msgh_voucher_port;
      CFStringRef v9 = *(CFStringRef *)&msg[1].msgh_remote_port;
      CA::WindowServer::Display::ModeSet::set_mig_representation((CA::WindowServer::Display::ModeSet *)__p, *(unint64_t **)&msg[1].msgh_voucher_port, *(unsigned int **)&msg[2].msgh_bits, 0, 0, 0, v6, v7, v93);
      uint64_t v172 = *(void *)&msg[2].msgh_remote_port;
      double v168 = *(void *)&msg[2].msgh_voucher_port;
      if (*(void *)&msg[3].msgh_bits) {
        (*(void (**)(void))&msg[3].msgh_bits)(*(void *)&msg[1].msgh_voucher_port);
      }
      uint64_t v142 = ServerPort;
      double v141 = (pthread_mutex_t *)((char *)this + 8);
      int v157 = 0;
      int v158 = 0;
      uint64_t v145 = 0;
      unsigned int v167 = 0;
      unint64_t v176 = 0;
      uint64_t v156 = 0;
      mach_msg_id_t msgh_id = 0;
      uint64_t v95 = 0;
      uint64_t v132 = 0;
      long long v164 = 0;
      float v144 = 0;
      uint64_t v135 = 0;
      int v10 = 0;
      uint64_t v170 = 0;
      int v11 = 0;
      uint64_t v134 = 0;
      long long v94 = 0;
      uint64_t v155 = 0;
      uint64_t v174 = 0;
      unsigned int v12 = 0;
      v13.i32[0] = v172;
      v13.i32[1] = v172 >> 14;
      *(void *)&long long v14 = 0;
      double v146 = 0;
      *((int8x8_t *)&v14 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = vand_s8(v13, (int8x8_t)0x3F0000003FLL);
      uint64_t v15 = *(void *)&msg[3].msgh_voucher_port;
      uint64_t v175 = *(double *)&msg[3].msgh_remote_port;
      uint64_t v169 = *((void *)&v209 + 1);
      unint64_t v173 = *(double *)&v209;
      double v16 = 1.0;
      int v165 = 0;
      float64x2_t v166 = v14;
      uint64_t v160 = 0.0;
      long long v162 = v14;
      long long v163 = 0;
      double v171 = 0;
      int v17 = (_BYTE)v210 != 0;
      int v159 = 1;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      int v133 = 0;
      unint64_t v143 = 0;
LABEL_8:
      *((_WORD *)this + 380) &= ~0x400u;
      uint64_t v22 = (v11 - 1);
      if (v22 < 4) {
        uint64_t v23 = v22 + 1;
      }
      else {
        uint64_t v23 = 0;
      }
      unint64_t v129 = *((_DWORD *)this + 31);
      int32x2_t v130 = *((_DWORD *)this + 30);
      os_unfair_lock_lock((os_unfair_lock_t)this + 18);
      CFStringRef v24 = (CFStringRef)*((void *)this + 16);
      if (v24 == v8)
      {
        BOOL v25 = 1;
      }
      else
      {
        unsigned int v138 = 0;
        if (!v8 || !v24)
        {
LABEL_28:
          uint64_t v39 = (CFStringRef)*((void *)this + 18);
          if (v39 == v9)
          {
            uint64_t v40 = 1;
          }
          else
          {
            int v137 = 0;
            if (!v9 || !v39) {
              goto LABEL_34;
            }
            uint64_t v40 = CFEqual(v39, v9) != 0;
          }
          int v137 = v40;
LABEL_34:
          long long v122 = v9;
          uint64_t v128 = CA::WindowServer::Display::ModeSet::operator==((uint64_t)this + 152, (uint64_t)__p);
          uint64_t v125 = CA::WindowServer::Display::Mode::operator==(*((void *)this + 31), v172);
          int v124 = CA::WindowServer::Display::Mode::operator==(*((void *)this + 32), v168);
          uint64_t v154 = *((_DWORD *)this + 66) == v166
              && *(void *)((char *)this + 268) == *(void *)((char *)&v166 + 4)
              && *((_DWORD *)this + 69) == HIDWORD(v166);
          unsigned int v121 = *((_DWORD *)this + 70) == v162
              && *(void *)((char *)this + 284) == *(void *)((char *)&v162 + 4)
              && *((_DWORD *)this + 73) == HIDWORD(v162);
          uint64_t v41 = *((float *)this + 74) != *(float *)&v165 || *((float *)this + 75) != *((float *)&v165 + 1);
          size_4 = v41;
          uint64_t v42 = *((float *)this + 76) != *(float *)&v163 || *((float *)this + 77) != *((float *)&v163 + 1);
          unsigned int v116 = v42;
          int v43 = *((_DWORD *)this + 78) != v167 || *((_DWORD *)this + 79) != v145;
          unint64_t v115 = v43;
          unint64_t v99 = v164 == *((_DWORD *)this + 80)
             && v144 == *((_DWORD *)this + 81)
             && v143 == *((void *)this + 41)
             && __PAIR64__(*((unsigned __int8 *)this + 340), *((_DWORD *)this + 84)) == __PAIR64__(v10 != 0, HIDWORD(v135))&& v135 == *((_DWORD *)this + 86)&& v134 == *((_DWORD *)this + 87)&& v133 == *((void *)this + 44)&& HIDWORD(v132) == *((_DWORD *)this + 90);
          unsigned int v119 = v10 != 0;
          unint64_t v126 = v23;
          unint64_t v96 = *((unsigned __int8 *)this + 369);
          long long v97 = *((unsigned __int8 *)this + 368);
          os_unfair_lock_unlock((os_unfair_lock_t)this + 18);
          uint64_t v44 = *((unsigned __int16 *)this + 380);
          id v45 = 1;
          addressa = 1;
          if (*((float *)this + 176) == *(float *)&v171) {
            addressa = *((float *)this + 177) != *((float *)&v171 + 1);
          }
          uint64_t v46 = v12 & 4;
          unint64_t v47 = v12 & 0x80;
          CFArrayRef v48 = v12 & 2;
          uint64_t v49 = v12 & 8;
          uint64_t v50 = v12 & 1;
          unsigned int v51 = 528;
          uint64_t v52 = 496;
          if ((*((unsigned char *)this + 697) & 8) != 0) {
            uint64_t v52 = 528;
          }
          else {
            unsigned int v51 = 512;
          }
          if (*((unsigned char *)this + 697)) {
            CFRange v53 = 2;
          }
          else {
            CFRange v53 = 1;
          }
          if (v53 <= *((_DWORD *)this + 130)) {
            CFRange v53 = *((_DWORD *)this + 130);
          }
          if (v53 <= *((_DWORD *)this + 138)) {
            CFRange v53 = *((_DWORD *)this + 138);
          }
          float v149 = v53;
          if (v170 == ((v44 >> 6) & 1)) {
            id v45 = *((_DWORD *)this + 110) != v146;
          }
          uint64_t v98 = v45;
          int v123 = *((double *)this + 51);
          uint64_t v113 = (v44 >> 1) & 1;
          int v117 = *((_DWORD *)this + 180);
          unint64_t v112 = v46 >> 2;
          uint64_t v111 = (v44 >> 2) & 1;
          int v110 = v47 >> 7;
          uint64_t v109 = (v44 >> 3) & 1;
          unint64_t v105 = *((_DWORD *)this + 105);
          uint64_t v104 = *((_DWORD *)this + 106);
          uint64_t v114 = *((_DWORD *)this + 114);
          unint64_t v102 = *((_DWORD *)this + 107);
          unint64_t v108 = v48 >> 1;
          uint64_t v101 = *((_DWORD *)this + 108);
          uint64_t v107 = (v44 >> 4) & 1;
          int v120 = v44 & 1;
          double v106 = v49 >> 3;
          uint64_t v54 = *(double *)((char *)this + v52);
          uint64_t v55 = v50 != v120 || !v154;
          uint64_t v118 = *((_DWORD *)this + 104);
          uint64_t v56 = *(double *)((char *)this + v51);
          double v103 = (v44 >> 7) & 1;
          uint64_t v57 = v55 | size_4;
          if (v118 != v176) {
            uint64_t v57 = 1;
          }
          double v100 = v57;
          sizea = (v44 >> 8) & 1;
          if ((v44 & 0x200) != 0)
          {
            if (v130 != HIDWORD(v161)) {
              [*((id *)this + 10) willChangeValueForKey:@"seed"];
            }
            if (v129 != v161) {
              [*((id *)this + 10) willChangeValueForKey:@"connectionSeed"];
            }
            if (!v138) {
              [*((id *)this + 10) willChangeValueForKey:@"uniqueId"];
            }
            if (!v137) {
              [*((id *)this + 10) willChangeValueForKey:@"productName"];
            }
            if ((v128 & 1) == 0)
            {
              [*((id *)this + 10) willChangeValueForKey:@"availableModes"];
              [*((id *)this + 10) willChangeValueForKey:@"supportedHDRModes"];
              [*((id *)this + 10) willChangeValueForKey:@"preferredHDRModes"];
            }
            if ((v125 & 1) == 0) {
              [*((id *)this + 10) willChangeValueForKey:@"currentMode"];
            }
            if ((v124 & 1) == 0) {
              [*((id *)this + 10) willChangeValueForKey:@"preferredMode"];
            }
            unint64_t v58 = v160;
            int32x2_t v59 = v123;
            if (v123 != v160) {
              objc_msgSend(*((id *)this + 10), "willChangeValueForKey:", @"latency", v160, v123);
            }
            if (!v154) {
              objc_msgSend(*((id *)this + 10), "willChangeValueForKey:", @"bounds", v58, v59);
            }
            if (!v121) {
              objc_msgSend(*((id *)this + 10), "willChangeValueForKey:", @"frame", v58, v59);
            }
            if (v50 != v120) {
              objc_msgSend(*((id *)this + 10), "willChangeValueForKey:", @"overscanned", v58, v59);
            }
            if (size_4)
            {
              [*((id *)this + 10) willChangeValueForKey:@"overscanAmounts"];
              [*((id *)this + 10) willChangeValueForKey:@"overscanAmount"];
            }
            if (v118 != v176) {
              [*((id *)this + 10) willChangeValueForKey:@"overscanAdjustment"];
            }
            if (addressa) {
              [*((id *)this + 10) willChangeValueForKey:@"logicalScale"];
            }
            if (v117 != HIDWORD(v159)) {
              [*((id *)this + 10) willChangeValueForKey:@"pointScale"];
            }
            if (v116) {
              [*((id *)this + 10) willChangeValueForKey:@"physicalSize"];
            }
            if (v115) {
              [*((id *)this + 10) willChangeValueForKey:@"nativeSize"];
            }
            if (v114 != v159) {
              [*((id *)this + 10) willChangeValueForKey:@"transportType"];
            }
            if (v112 != v113) {
              [*((id *)this + 10) willChangeValueForKey:@"cloned"];
            }
            if (v110 != v111) {
              [*((id *)this + 10) willChangeValueForKey:@"cloning"];
            }
            if (v108 != v109) {
              [*((id *)this + 10) willChangeValueForKey:@"cloningSupported"];
            }
            if (v106 != v107) {
              [*((id *)this + 10) willChangeValueForKey:@"supportsExtendedColors"];
            }
            if (v105 != HIDWORD(v158)) {
              [*((id *)this + 10) willChangeValueForKey:@"tag"];
            }
            if (v104 != v158) {
              [*((id *)this + 10) willChangeValueForKey:@"processId"];
            }
            if (v54 != v175) {
              [*((id *)this + 10) willChangeValueForKey:@"refreshRate"];
            }
            if (v56 != v173) {
              [*((id *)this + 10) willChangeValueForKey:@"heartbeatRate"];
            }
            if (v149 != v169) {
              [*((id *)this + 10) willChangeValueForKey:@"minimumFrameDuration"];
            }
            if (HIDWORD(v157) != v103) {
              [*((id *)this + 10) willChangeValueForKey:@"dmrrEnabled"];
            }
            if (v174 != sizea) {
              [*((id *)this + 10) willChangeValueForKey:@"forceFixedRateLinksEnabled"];
            }
            if (v102 != v157) {
              [*((id *)this + 10) willChangeValueForKey:@"nativeOrientation"];
            }
            if (v101 != HIDWORD(v156)) {
              [*((id *)this + 10) willChangeValueForKey:@"currentOrientation"];
            }
            if (v100) {
              [*((id *)this + 10) willChangeValueForKey:@"safeBounds"];
            }
            if (!v99) {
              [*((id *)this + 10) willChangeValueForKey:@"externalDisplayAttributes"];
            }
            if (v98)
            {
              [*((id *)this + 10) willChangeValueForKey:@"preferences"];
              [*((id *)this + 10) willChangeValueForKey:@"allowedHDRModes"];
            }
            if (v97 != v156)
            {
              [*((id *)this + 10) willChangeValueForKey:@"currentPreset"];
              [*((id *)this + 10) willChangeValueForKey:@"isReference"];
            }
            if (v96 != v155) {
              [*((id *)this + 10) willChangeValueForKey:@"isReferenceLimited"];
            }
          }
          *((_DWORD *)this + 3CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = HIDWORD(v161);
          *((_DWORD *)this + 3CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v161;
          *((double *)this + 5CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v160;
          uint64_t v60 = *((_WORD *)this + 380) & 0xFFE0 | v50;
          *((_DWORD *)this + 104) = v176;
          uint64_t v61 = (v47 >> 5) | (v46 >> 1) | (4 * v48) | (2 * v49) | v60;
          *((_WORD *)this + 38CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v61;
          float v62 = *((unsigned char *)this + 697) & 0xFE | v17;
          *((unsigned char *)this + 697) = v62;
          if (v17)
          {
            unsigned int v64 = msgh_id;
            char v63 = v132;
            if (CAFrameRateArbitrationEnabled(void)::once != -1) {
              dispatch_once(&CAFrameRateArbitrationEnabled(void)::once, &__block_literal_global_18059);
            }
            int v65 = v126;
            BOOL v66 = 2 * CAFrameRateArbitrationEnabled(void)::enabled;
            float v62 = *((unsigned char *)this + 697);
            LOWORD(v6CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *((_WORD *)this + 380);
          }
          else
          {
            BOOL v66 = 0;
            unsigned int v64 = msgh_id;
            char v63 = v132;
            int v65 = v126;
          }
          *((unsigned char *)this + 697) = v62 & 0xFD | v66;
          *((_DWORD *)this + 105) = HIDWORD(v158);
          *((_DWORD *)this + 106) = v158;
          *((double *)this + 62) = v175;
          *((void *)this + 63) = v15;
          *((double *)this + 64) = v173;
          *((void *)this + 65) = v169;
          *((_DWORD *)this + 107) = v157;
          *((_DWORD *)this + 108) = HIDWORD(v156);
          *((_DWORD *)this + 109) = v63;
          *((_WORD *)this + 38CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v61 & 0xFE1F | (v12 >> 1) & 0x20 | ((HIDWORD(v157) != 0) << 7) | ((v174 != 0) << 8) | ((v170 != 0) << 6);
          *((void *)this + 55) = v146;
          *((void *)this + 56) = v65;
          *((_DWORD *)this + 114) = v159;
          *((void *)this + 88) = v171;
          *((void *)this + 89) = v21;
          *((_DWORD *)this + 18CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = HIDWORD(v159);
          if (v64)
          {
            int v67 = CA::Render::Shmem::new_shmem(v64, v95, 0, 3);
            if (v67)
            {
              uint64_t v68 = v67;
              *((unsigned char *)this + 697) = *((unsigned char *)this + 697) & 0xFB | (4 * (v94 != 0));
              CA::Display::DisplayTimingsControl::set_timings_shmem((os_unfair_lock_s *)this + 116, v67);
              if (atomic_fetch_add(v68 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v68 + 16))(v68);
              }
            }
            else
            {
              mach_port_deallocate(*MEMORY[0x1E4F14960], v64);
            }
          }
          os_unfair_lock_lock((os_unfair_lock_t)this + 18);
          int v69 = (const void *)*((void *)this + 16);
          if (v69) {
            CFRelease(v69);
          }
          *((void *)this + 16) = v8;
          unsigned int v70 = (const void *)*((void *)this + 17);
          if (v70) {
            CFRelease(v70);
          }
          *((void *)this + 17) = v127;
          int v71 = (const void *)*((void *)this + 18);
          if (v71) {
            CFRelease(v71);
          }
          *((void *)this + 18) = v122;
          CA::WindowServer::Display::ModeSet::operator=((char **)this + 19, (char **)__p);
          *(void *)&unsigned int v72 = __PAIR64__(v144, v164);
          *(void *)&int v73 = __PAIR64__(v134, v135);
          *((void *)&v72 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v143;
          *((void *)&v73 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v133;
          *((void *)this + 3CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v172;
          *((void *)this + 32) = v168;
          *(_OWORD *)((char *)this + 264) = v166;
          *(_OWORD *)((char *)this + 28CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v162;
          *((void *)this + 37) = v165;
          *((void *)this + 38) = v163;
          *((void *)this + 39) = v167 | (unint64_t)(v145 << 32);
          *((_OWORD *)this + 2CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v72;
          *((_DWORD *)this + 84) = HIDWORD(v135);
          *((unsigned char *)this + 34CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v119;
          *(_OWORD *)((char *)this + 344) = v73;
          *((_DWORD *)this + 9CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = HIDWORD(v132);
          *((unsigned char *)this + 368) = v156 != 0;
          *((unsigned char *)this + 369) = v155 != 0;
          *((void *)this + 47) = v18;
          *((void *)this + 48) = v19;
          *((double *)this + 49) = v16;
          *((void *)this + 5CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v20;
          os_unfair_lock_unlock((os_unfair_lock_t)this + 18);
          if (v174 != sizea && (*((_WORD *)this + 380) & 0x100) != 0)
          {
            *(void *)&msg[0].msgh_bits = MEMORY[0x1E4F143A8];
            *(void *)&msg[0].msgh_remote_port = 3221225472;
            *(void *)&msg[0].msgh_voucher_port = ___ZN2CA7Display11DisplayLink22display_force_power_onEPNS0_7DisplayE_block_invoke;
            *(void *)&msg[1].msgh_bits = &__block_descriptor_40_e9_v16__0_v8l;
            *(void *)&msg[1].msgh_remote_port = this;
            CA::Display::DisplayLink::foreach_display_link((uint64_t)msg);
          }
          if (v54 != v175 || v56 != v173 || v149 != v169)
          {
            *(void *)&msg[0].msgh_bits = MEMORY[0x1E4F143A8];
            *(void *)&msg[0].msgh_remote_port = 3221225472;
            *(void *)&msg[0].msgh_voucher_port = ___ZN2CA7Display11DisplayLink28display_refresh_rate_changedEPNS0_7DisplayE_block_invoke;
            *(void *)&msg[1].msgh_bits = &__block_descriptor_40_e9_v16__0_v8l;
            *(void *)&msg[1].msgh_remote_port = this;
            CA::Display::DisplayLink::foreach_display_link((uint64_t)msg);
            CAFrameRateRangeGroupShouldUpdate(*((_DWORD *)this + 26));
            CADynamicFrameRateSourceRecomputeFrameInterval(*((_DWORD *)this + 26));
          }
          if ((*((_WORD *)this + 380) & 0x200) != 0)
          {
            if (v130 != HIDWORD(v161)) {
              [*((id *)this + 10) didChangeValueForKey:@"seed"];
            }
            if (v129 != v161) {
              [*((id *)this + 10) didChangeValueForKey:@"connectionSeed"];
            }
            if (!v138) {
              [*((id *)this + 10) didChangeValueForKey:@"uniqueId"];
            }
            if (!v137) {
              [*((id *)this + 10) didChangeValueForKey:@"productName"];
            }
            if ((v128 & 1) == 0)
            {
              [*((id *)this + 10) didChangeValueForKey:@"availableModes"];
              [*((id *)this + 10) didChangeValueForKey:@"supportedHDRModes"];
              [*((id *)this + 10) didChangeValueForKey:@"preferredHDRModes"];
            }
            if ((v125 & 1) == 0) {
              [*((id *)this + 10) didChangeValueForKey:@"currentMode"];
            }
            if ((v124 & 1) == 0) {
              [*((id *)this + 10) didChangeValueForKey:@"preferredMode"];
            }
            unint64_t v74 = v160;
            float v75 = v123;
            if (v123 != v160) {
              objc_msgSend(*((id *)this + 10), "didChangeValueForKey:", @"latency", v160, v123);
            }
            if (!v154) {
              objc_msgSend(*((id *)this + 10), "didChangeValueForKey:", @"bounds", v74, v75);
            }
            if (!v121) {
              objc_msgSend(*((id *)this + 10), "didChangeValueForKey:", @"frame", v74, v75);
            }
            if (v50 != v120) {
              objc_msgSend(*((id *)this + 10), "didChangeValueForKey:", @"overscanned", v74, v75);
            }
            if (size_4)
            {
              [*((id *)this + 10) didChangeValueForKey:@"overscanAmounts"];
              [*((id *)this + 10) didChangeValueForKey:@"overscanAmount"];
            }
            if (v118 != v176) {
              [*((id *)this + 10) didChangeValueForKey:@"overscanAdjustment"];
            }
            if (addressa) {
              [*((id *)this + 10) didChangeValueForKey:@"logicalScale"];
            }
            if (v117 != HIDWORD(v159)) {
              [*((id *)this + 10) didChangeValueForKey:@"pointScale"];
            }
            if (v116) {
              [*((id *)this + 10) didChangeValueForKey:@"physicalSize"];
            }
            if (v115) {
              [*((id *)this + 10) didChangeValueForKey:@"nativeSize"];
            }
            if (v114 != v159) {
              [*((id *)this + 10) didChangeValueForKey:@"transportType"];
            }
            if (v112 != v113) {
              [*((id *)this + 10) didChangeValueForKey:@"cloned"];
            }
            if (v110 != v111) {
              [*((id *)this + 10) didChangeValueForKey:@"cloning"];
            }
            if (v108 != v109) {
              [*((id *)this + 10) didChangeValueForKey:@"cloningSupported"];
            }
            if (v106 != v107) {
              [*((id *)this + 10) didChangeValueForKey:@"supportsExtendedColors"];
            }
            if (v105 != HIDWORD(v158)) {
              [*((id *)this + 10) didChangeValueForKey:@"tag"];
            }
            if (v104 != v158) {
              [*((id *)this + 10) didChangeValueForKey:@"processId"];
            }
            if (v54 != v175) {
              [*((id *)this + 10) didChangeValueForKey:@"refreshRate"];
            }
            if (v56 != v173) {
              [*((id *)this + 10) didChangeValueForKey:@"heartbeatRate"];
            }
            if (v149 != v169) {
              [*((id *)this + 10) didChangeValueForKey:@"minimumFrameDuration"];
            }
            if (HIDWORD(v157) != v103) {
              [*((id *)this + 10) didChangeValueForKey:@"dmrrEnabled"];
            }
            if (v174 != sizea) {
              [*((id *)this + 10) didChangeValueForKey:@"forceFixedRateLinksEnabled"];
            }
            if (v102 != v157) {
              [*((id *)this + 10) didChangeValueForKey:@"nativeOrientation"];
            }
            if (v101 != HIDWORD(v156)) {
              [*((id *)this + 10) didChangeValueForKey:@"currentOrientation"];
            }
            if (v100) {
              [*((id *)this + 10) didChangeValueForKey:@"safeBounds"];
            }
            if (!v99) {
              [*((id *)this + 10) didChangeValueForKey:@"externalDisplayAttributes"];
            }
            if (v98)
            {
              [*((id *)this + 10) didChangeValueForKey:@"preferences"];
              [*((id *)this + 10) didChangeValueForKey:@"allowedHDRModes"];
            }
            if (v97 != v156)
            {
              [*((id *)this + 10) didChangeValueForKey:@"currentPreset"];
              [*((id *)this + 10) didChangeValueForKey:@"isReference"];
            }
            if (v96 != v155) {
              [*((id *)this + 10) didChangeValueForKey:@"isReferenceLimited"];
            }
          }
          *((_WORD *)this + 380) |= 0x200u;
          goto LABEL_249;
        }
        BOOL v25 = CFEqual(v24, v8) != 0;
      }
      unsigned int v138 = v25;
      goto LABEL_28;
    }
    if (x_log_hook_p())
    {
      x_log_();
      goto LABEL_250;
    }
    char v34 = x_log_category_windowserver;
    if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v184 = 0;
      uint64_t v35 = "CoreAnimation: CALocalDisplayUpdateBlock returned NO\n";
      uint64_t v36 = v184;
      int v37 = v34;
      uint64_t v38 = 2;
LABEL_301:
      _os_log_impl(&dword_184668000, v37, OS_LOG_TYPE_ERROR, v35, (uint8_t *)v36, v38);
      goto LABEL_250;
    }
    goto LABEL_250;
  }
  if (!ServerPort) {
    return pthread_mutex_unlock(v2);
  }
  if (!v3)
  {
LABEL_253:
    mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
    return pthread_mutex_unlock(v2);
  }
  uint64_t v182 = 0u;
  unint64_t v183 = 0u;
  *(_OWORD *)__p = 0u;
  uint64_t v178 = 0;
  uint64_t v180 = 0u;
  unsigned int v181 = 0u;
  unint64_t v179 = &v180;
  LODWORD(v183) = 1065353216;
  uint64_t v207 = 0u;
  long long v206 = 0u;
  unint64_t v205 = 0u;
  *(_OWORD *)vImage_Buffer dest = 0u;
  double v203 = 0u;
  uint64_t v201 = 0u;
  unint64_t v202 = 0u;
  int v199 = 0u;
  *(_OWORD *)cStr = 0u;
  unsigned int v197 = 0u;
  double v198 = 0u;
  int v195 = 0u;
  double v196 = 0u;
  int v193 = 0u;
  uint64_t v194 = 0u;
  int v191 = 0u;
  uint64_t v192 = 0u;
  int v189 = 0u;
  uint64_t v190 = 0u;
  int v187 = 0u;
  uint64_t v188 = 0u;
  uint64_t v185 = 0u;
  uint64_t v186 = 0u;
  *(_OWORD *)char v184 = 0u;
  bzero(&msg[0].msgh_size, 0x358uLL);
  *(void *)&msg[1].msgh_bits = *MEMORY[0x1E4F14068];
  msg[1].msgh_remote_port = v3;
  mach_port_t reply_port = mig_get_reply_port();
  msg[0].msgh_bits = 5395;
  *(void *)&msg[0].msgh_remote_port = __PAIR64__(reply_port, ServerPort);
  *(void *)&msg[0].msgh_voucher_port = 0x9D2800000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(msg);
    mach_port_t reply_port = msg[0].msgh_local_port;
  }
  uint64_t v27 = mach_msg(msg, 3, 0x28u, 0x35Cu, reply_port, 0, 0);
  msgh_remote_port = v27;
  double v141 = (pthread_mutex_t *)((char *)this + 8);
  uint64_t v142 = ServerPort;
  if ((v27 - 268435458) > 0xE || ((1 << (v27 - 2)) & 0x4003) == 0)
  {
    if (v27)
    {
      mig_dealloc_reply_port(msg[0].msgh_local_port);
LABEL_291:
      if (msgh_remote_port == -81182719)
      {
        x_log_crash("Unentitled call to server!");
        abort();
      }
      int v161 = 0;
      uint64_t v172 = 0;
      double v168 = 0;
      unsigned int v12 = 0;
      int v158 = 0;
      int v159 = 0;
      uint64_t v145 = 0;
      unsigned int v167 = 0;
      unint64_t v176 = 0;
      uint64_t v156 = 0;
      int v157 = 0;
      mach_msg_id_t msgh_id = 0;
      uint64_t v95 = 0;
      uint64_t v132 = 0;
      long long v164 = 0;
      float v144 = 0;
      uint64_t v135 = 0;
      uint64_t v136 = 0;
      int v10 = 0;
      uint64_t v170 = 0;
      int v11 = 0;
      uint64_t v134 = 0;
      long long v94 = 0;
      uint64_t v155 = 0;
      uint64_t v174 = 0;
      size = 0;
      int v153 = 0;
      float v148 = 0;
      int v147 = 0;
      address = 0;
      id v31 = 0;
      id v32 = 0;
      BOOL v33 = 0;
      double v16 = 1.0;
      int v165 = 0;
      float64x2_t v166 = 0u;
      uint64_t v160 = 0.0;
      long long v163 = 0;
      double v171 = 0;
      long long v162 = 0u;
      uint64_t v175 = 0.0;
      uint64_t v15 = 0;
      unint64_t v173 = 0.0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      double v146 = 0;
      goto LABEL_293;
    }
    if (msg[0].msgh_id == 71)
    {
      msgh_remote_port = -308;
    }
    else if (msg[0].msgh_id == 40332)
    {
      if ((msg[0].msgh_bits & 0x80000000) != 0)
      {
        msgh_remote_port = -300;
        if (msg[1].msgh_bits != 5 || msg[0].msgh_size < 0x1D4 || msg[0].msgh_size > 0x354 || msg[0].msgh_remote_port) {
          goto LABEL_290;
        }
        if (HIBYTE(msg[1].msgh_local_port) == 1
          && HIBYTE(msg[2].msgh_size) == 1
          && HIBYTE(msg[2].msgh_id) == 1
          && HIBYTE(msg[3].msgh_local_port) == 1
          && WORD3(v209) << 16 == 1114112
          && v211 <= 0x40)
        {
          msgh_remote_port = -300;
          if (msg[0].msgh_size - 468 < v211) {
            goto LABEL_290;
          }
          int v77 = (v211 + 3) & 0xFFFFFFFC;
          if (msg[0].msgh_size < v77 + 468) {
            goto LABEL_290;
          }
          long long v78 = (char *)msg + v77;
          long long v79 = *((_DWORD *)v78 + 33);
          if (v79 <= 0x40)
          {
            long long v80 = msg[0].msgh_size - v77;
            msgh_remote_port = -300;
            if (msg[0].msgh_size - v77 - 468 < v79) {
              goto LABEL_290;
            }
            long long v81 = (v79 + 3) & 0xFFFFFFFC;
            if (v80 < v81 + 468) {
              goto LABEL_290;
            }
            long long v82 = v78 - 64;
            long long v83 = (uint64_t)&v78[v81 - 64];
            long long v84 = *(_DWORD *)(v83 + 204);
            if (v84 <= 0x100)
            {
              BOOL v85 = v80 - v81;
              msgh_remote_port = -300;
              if (v85 - 468 < v84) {
                goto LABEL_290;
              }
              uint64_t v86 = (v84 + 3) & 0xFFFFFFFC;
              if (v85 != v86 + 468) {
                goto LABEL_290;
              }
              unint64_t v87 = v83 - 64;
              uint64_t v88 = v83 - 64 + v86;
              if (msg[1].msgh_voucher_port == *(_DWORD *)(v88 + 272))
              {
                uint64_t v89 = v88 - 256;
                if (__PAIR64__(msg[3].msgh_bits, msg[2].msgh_remote_port) == *(void *)(v88 + 276)
                  && msg[3].msgh_voucher_port == *(_DWORD *)(v88 + 412))
                {
                  int v161 = __PAIR64__(v210, HIDWORD(v210));
                  mig_strncpy(dest, v212, 64);
                  mig_strncpy(cStr, v82 + 200, 64);
                  mig_strncpy(v184, (const char *)(v87 + 272), 256);
                  msgh_remote_port = 0;
                  int v153 = *(unint64_t **)&msg[1].msgh_size;
                  unint64_t v90 = v89;
                  HIDWORD(size) = *(_DWORD *)(v89 + 528);
                  float v148 = *(void *)&msg[1].msgh_id;
                  int v147 = *(_DWORD *)(v89 + 532);
                  address = *(void *)&msg[2].msgh_local_port;
                  HIDWORD(v136) = *(_DWORD *)(v89 + 536);
                  id v31 = *(_DWORD *)(v89 + 540);
                  uint64_t v172 = *(void *)(v89 + 548);
                  double v168 = *(void *)(v89 + 556);
                  LODWORD(v159) = *(_DWORD *)(v89 + 564);
                  uint64_t v160 = *(double *)(v89 + 568);
                  unsigned int v12 = *(_DWORD *)(v89 + 608);
                  HIDWORD(v158) = *(_DWORD *)(v89 + 612);
                  LODWORD(v158) = *(_DWORD *)(v89 + 616);
                  int v165 = *(void *)(v89 + 620);
                  float64x2_t v166 = *(_OWORD *)(v89 + 576);
                  unint64_t v176 = *(_DWORD *)(v89 + 628);
                  double v171 = *(void *)(v89 + 632);
                  uint64_t v21 = *(void *)(v89 + 640);
                  HIDWORD(v159) = *(_DWORD *)(v89 + 648);
                  long long v162 = *(_OWORD *)(v89 + 592);
                  long long v163 = *(void *)(v89 + 652);
                  unsigned int v167 = *(_DWORD *)(v89 + 660);
                  uint64_t v145 = *(unsigned int *)(v89 + 664);
                  id v32 = *(unsigned int **)&msg[3].msgh_size;
                  LODWORD(v136) = *(_DWORD *)(v89 + 668);
                  BOOL v33 = *(_DWORD *)(v89 + 672);
                  LODWORD(size) = *(_DWORD *)(v89 + 676);
                  uint64_t v175 = *(double *)(v89 + 680);
                  uint64_t v15 = *(void *)(v89 + 688);
                  unint64_t v173 = *(double *)(v89 + 696);
                  uint64_t v169 = *(void *)(v89 + 704);
                  HIDWORD(v157) = *(unsigned __int8 *)(v89 + 712);
                  LODWORD(v157) = *(_DWORD *)(v89 + 720);
                  HIDWORD(v156) = *(_DWORD *)(v89 + 724);
                  uint64_t v95 = *(void *)(v89 + 728);
                  LODWORD(v132) = *(_DWORD *)(v89 + 736);
                  long long v164 = *(_DWORD *)(v89 + 740);
                  float v144 = *(_DWORD *)(v89 + 744);
                  unint64_t v143 = *(void *)(v89 + 748);
                  double v146 = *(void *)(v89 + 772);
                  HIDWORD(v135) = *(_DWORD *)(v89 + 760);
                  int v133 = *(void *)(v89 + 792);
                  uint64_t v18 = *(void *)(v89 + 816);
                  uint64_t v19 = *(void *)(v89 + 824);
                  double v16 = *(double *)(v89 + 832);
                  uint64_t v20 = *(void *)(v89 + 840);
                  int v10 = *(_DWORD *)(v89 + 764);
                  uint64_t v170 = *(_DWORD *)(v89 + 768);
                  int v11 = *(_DWORD *)(v89 + 780);
                  uint64_t v134 = *(_DWORD *)(v90 + 784);
                  LODWORD(v135) = *(_DWORD *)(v90 + 788);
                  HIDWORD(v132) = *(_DWORD *)(v90 + 800);
                  long long v94 = *(unsigned __int8 *)(v90 + 804);
                  LODWORD(v156) = *(unsigned __int8 *)(v90 + 808);
                  uint64_t v155 = *(unsigned __int8 *)(v90 + 812);
                  uint64_t v174 = *(unsigned __int8 *)(v90 + 848);
                  mach_msg_id_t msgh_id = msg[3].msgh_id;
                  goto LABEL_294;
                }
              }
            }
          }
        }
      }
      else if (msg[0].msgh_size == 36)
      {
        msgh_remote_port = -300;
        if (msg[1].msgh_remote_port)
        {
          if (msg[0].msgh_remote_port) {
            msgh_remote_port = -300;
          }
          else {
            msgh_remote_port = msg[1].msgh_remote_port;
          }
        }
        goto LABEL_290;
      }
      msgh_remote_port = -300;
    }
    else
    {
      msgh_remote_port = -301;
    }
LABEL_290:
    mach_msg_destroy(msg);
    goto LABEL_291;
  }
  mig_put_reply_port(msg[0].msgh_local_port);
  int v161 = 0;
  uint64_t v172 = 0;
  double v168 = 0;
  unsigned int v12 = 0;
  int v158 = 0;
  int v159 = 0;
  uint64_t v145 = 0;
  unsigned int v167 = 0;
  unint64_t v176 = 0;
  uint64_t v156 = 0;
  int v157 = 0;
  mach_msg_id_t msgh_id = 0;
  uint64_t v95 = 0;
  uint64_t v132 = 0;
  long long v164 = 0;
  float v144 = 0;
  uint64_t v135 = 0;
  uint64_t v136 = 0;
  int v10 = 0;
  uint64_t v170 = 0;
  int v11 = 0;
  uint64_t v134 = 0;
  long long v94 = 0;
  uint64_t v155 = 0;
  uint64_t v174 = 0;
  size = 0;
  int v153 = 0;
  float v148 = 0;
  int v147 = 0;
  address = 0;
  id v31 = 0;
  id v32 = 0;
  BOOL v33 = 0;
  double v146 = 0;
  double v16 = 1.0;
  int v165 = 0;
  float64x2_t v166 = 0u;
  uint64_t v160 = 0.0;
  long long v163 = 0;
  double v171 = 0;
  long long v162 = 0u;
  uint64_t v175 = 0.0;
  uint64_t v15 = 0;
  unint64_t v173 = 0.0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
LABEL_293:
  uint64_t v169 = 0;
  int v133 = 0;
  unint64_t v143 = 0;
LABEL_294:
  if (!msgh_remote_port)
  {
    if (dest[0]) {
      CFStringRef v8 = CFStringCreateWithCString(0, dest, 0x8000100u);
    }
    else {
      CFStringRef v8 = 0;
    }
    if (cStr[0]) {
      uint64_t v127 = CFStringCreateWithCString(0, cStr, 0x8000100u);
    }
    else {
      uint64_t v127 = 0;
    }
    if (v184[0]) {
      CFStringRef v9 = CFStringCreateWithCString(0, v184, 0x8000100u);
    }
    else {
      CFStringRef v9 = 0;
    }
    CA::WindowServer::Display::ModeSet::set_mig_representation((CA::WindowServer::Display::ModeSet *)__p, v153, (unsigned int *)v31, v32, (unsigned int *)v33, size, v29, v30, v93);
    uint64_t v92 = (vm_map_t *)MEMORY[0x1E4F14960];
    mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)v153, HIDWORD(size));
    mach_vm_deallocate(*v92, v148, v147);
    mach_vm_deallocate(*v92, address, HIDWORD(v136));
    mach_vm_deallocate(*v92, (mach_vm_address_t)v32, v136);
    int v17 = (v12 >> 4) & 1;
    goto LABEL_8;
  }
  if (x_log_hook_p())
  {
    x_log_();
LABEL_249:
    CFTypeID v2 = v141;
    mach_port_name_t ServerPort = v142;
    goto LABEL_250;
  }
  float64x2_t v91 = x_log_category_windowserver;
  CFTypeID v2 = v141;
  mach_port_name_t ServerPort = v142;
  if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
  {
    msg[0].msgh_bits = 67109120;
    msg[0].msgh_size = msgh_remote_port;
    uint64_t v35 = "CoreAnimation: GetDisplayInfo returned 0x%x\n";
    uint64_t v36 = (char *)msg;
    int v37 = v91;
    uint64_t v38 = 8;
    goto LABEL_301;
  }
LABEL_250:
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)&v181);
  std::__tree<std::tuple<unsigned short,unsigned short>>::destroy((void *)v180);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (ServerPort) {
    goto LABEL_253;
  }
  return pthread_mutex_unlock(v2);
}

void sub_1847C23A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,pthread_mutex_t *a45,int a46,mach_port_name_t name)
{
  if (name) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], name);
  }
  pthread_mutex_unlock(a45);
  _Unwind_Resume(a1);
}

uint64_t CA::WindowServer::Display::Mode::operator==(uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
  {
    unsigned __int8 v2 = 1;
  }
  else
  {
    v3.i64[0] = a1;
    v3.i64[1] = a2;
    int8x16_t v4 = vandq_s8(v3, (int8x16_t)vdupq_n_s64(0xFFC000001FFFFFFFLL));
    *(int32x2_t *)v3.i8 = vshrn_n_s64((int64x2_t)v3, 0x1DuLL);
    v5.i64[0] = v3.i32[0] & 0x1FFFFFF;
    v5.i64[1] = v3.i32[1] & 0x1FFFFFF;
    int64x2_t v6 = (int64x2_t)vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)(*(void *)&vshl_n_s32(vmovn_s64((int64x2_t)vcvtq_u64_f64(vrndaq_f64(vmulq_f64(vcvtq_f64_s64(v5), (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL))))), 0x10uLL) & 0x1FFFFFF01FFFFFFLL), 0x1DuLL), v4);
    unsigned __int8 v2 = vmovn_s64(vceqq_s64(v6, vdupq_laneq_s64(v6, 1))).u8[0];
  }
  return v2 & 1;
}

char **CA::WindowServer::Display::ModeSet::operator=(char **a1, char **a2)
{
  v51[1] = *MEMORY[0x1E4F143B8];
  if (a1 == a2) {
    goto LABEL_59;
  }
  int8x16_t v4 = *a2;
  int64x2_t v5 = a2[1];
  int64_t v6 = v5 - *a2;
  unint64_t v7 = v6 >> 3;
  uint64_t v8 = (uint64_t)a1[2];
  CFStringRef v9 = *a1;
  if (v6 >> 3 > (unint64_t)((v8 - (uint64_t)*a1) >> 3))
  {
    if (v9)
    {
      a1[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (v6 < 0) {
      abort();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= v7) {
      uint64_t v10 = v6 >> 3;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<CA::WindowServer::Display::Mode>::__vallocate[abi:nn180100](a1, v11);
    CFStringRef v9 = a1[1];
    goto LABEL_17;
  }
  unsigned int v12 = a1[1];
  unint64_t v13 = (v12 - v9) >> 3;
  if (v13 >= v7)
  {
LABEL_17:
    if (v5 == v4) {
      goto LABEL_20;
    }
    uint64_t v15 = v9;
    double v16 = v4;
    goto LABEL_19;
  }
  long long v14 = &v4[8 * v13];
  if (v12 != v9)
  {
    memmove(*a1, *a2, v12 - v9);
    CFStringRef v9 = a1[1];
  }
  int64_t v6 = v5 - v14;
  if (v5 != v14)
  {
    uint64_t v15 = v9;
    double v16 = v14;
LABEL_19:
    memmove(v15, v16, v6);
  }
LABEL_20:
  a1[1] = &v9[v6];
  int v17 = a2[3];
  uint64_t v18 = (char *)(a2 + 4);
  if (!a1[5]) {
    goto LABEL_42;
  }
  uint64_t v19 = a1[4];
  uint64_t v20 = a1[3];
  a1[3] = (char *)(a1 + 4);
  *((void *)v19 + 2) = 0;
  a1[4] = 0;
  a1[5] = 0;
  if (*((void *)v20 + 1)) {
    uint64_t v21 = (char *)*((void *)v20 + 1);
  }
  else {
    uint64_t v21 = v20;
  }
  if (!v21)
  {
    id v31 = 0;
LABEL_41:
    std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(v31);
    goto LABEL_42;
  }
  uint64_t v22 = (char *)std::__tree<std::tuple<unsigned short,unsigned short>>::_DetachedTreeCache::__detach_next((uint64_t)v21);
  if (v17 != v18)
  {
    uint64_t v23 = v17;
    do
    {
      CFStringRef v24 = v21;
      uint64_t v21 = v22;
      unsigned __int16 v25 = *((_WORD *)v23 + 13);
      *((_WORD *)v24 + 13) = v25;
      unsigned __int16 v26 = *((_WORD *)v23 + 14);
      *((_WORD *)v24 + 14) = v26;
      v51[0] = 0;
      leaf_high = (uint64_t **)std::__tree<std::tuple<unsigned short,unsigned short>>::__find_leaf_high((uint64_t)(a1 + 3), v51, v25, v26);
      std::__tree<std::tuple<unsigned short,unsigned short>>::__insert_node_at((uint64_t **)a1 + 3, v51[0], leaf_high, (uint64_t *)v24);
      if (v22) {
        uint64_t v22 = (char *)std::__tree<std::tuple<unsigned short,unsigned short>>::_DetachedTreeCache::__detach_next((uint64_t)v22);
      }
      int v28 = (char *)*((void *)v23 + 1);
      if (v28)
      {
        do
        {
          int v17 = v28;
          int v28 = *(char **)v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          int v17 = (char *)*((void *)v23 + 2);
          BOOL v29 = *(void *)v17 == (void)v23;
          uint64_t v23 = v17;
        }
        while (!v29);
      }
      if (!v21) {
        break;
      }
      uint64_t v23 = v17;
    }
    while (v17 != v18);
  }
  std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(v21);
  if (v22)
  {
    for (uint64_t i = (char *)*((void *)v22 + 2); i; uint64_t i = (char *)*((void *)i + 2))
      uint64_t v22 = i;
    id v31 = v22;
    goto LABEL_41;
  }
LABEL_42:
  if (v17 != v18)
  {
    do
    {
      id v32 = (char *)operator new(0x20uLL);
      int v33 = *(_DWORD *)(v17 + 26);
      *(_DWORD *)(v32 + 26) = v33;
      v51[0] = 0;
      char v34 = (uint64_t **)std::__tree<std::tuple<unsigned short,unsigned short>>::__find_leaf_high((uint64_t)(a1 + 3), v51, v33, HIWORD(v33));
      std::__tree<std::tuple<unsigned short,unsigned short>>::__insert_node_at((uint64_t **)a1 + 3, v51[0], v34, (uint64_t *)v32);
      uint64_t v35 = (char *)*((void *)v17 + 1);
      if (v35)
      {
        do
        {
          uint64_t v36 = v35;
          uint64_t v35 = *(char **)v35;
        }
        while (v35);
      }
      else
      {
        do
        {
          uint64_t v36 = (char *)*((void *)v17 + 2);
          BOOL v29 = *(void *)v36 == (void)v17;
          int v17 = v36;
        }
        while (!v29);
      }
      int v17 = v36;
    }
    while (v36 != v18);
  }
  *((_DWORD *)a1 + 2CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *((_DWORD *)a2 + 20);
  int v37 = a2[8];
  uint64_t v38 = a1[7];
  if (!v38) {
    goto LABEL_55;
  }
  for (uint64_t j = 0; j != v38; ++j)
    *(void *)&a1[6][8 * (void)j] = 0;
  uint64_t v40 = a1[8];
  a1[8] = 0;
  a1[9] = 0;
  if (v40)
  {
    while (v37)
    {
      unint64_t v41 = *((void *)v37 + 2);
      *((void *)v40 + 2) = v41;
      uint64_t v42 = *((void *)v37 + 3);
      *((_DWORD *)v40 + 8) = *((_DWORD *)v37 + 8);
      *((void *)v40 + 3) = v42;
      int v43 = *(char **)v40;
      *((void *)v40 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v41;
      inserted = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__node_insert_multi_prepare((uint64_t)(a1 + 6), v41, (void *)v40 + 2);
      std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__node_insert_multi_perform(a1 + 6, v40, inserted);
      int v37 = *(char **)v37;
      uint64_t v40 = v43;
      if (!v43) {
        goto LABEL_55;
      }
    }
    do
    {
      uint64_t v49 = *(char **)v40;
      operator delete(v40);
      uint64_t v40 = v49;
    }
    while (v49);
  }
  else
  {
LABEL_55:
    while (v37)
    {
      id v45 = operator new(0x28uLL);
      *id v45 = 0;
      uint64_t v46 = *((void *)v37 + 4);
      *((_OWORD *)v45 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *((_OWORD *)v37 + 1);
      v45[4] = v46;
      unint64_t v47 = v45[2];
      v45[1] = v47;
      CFArrayRef v48 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__node_insert_multi_prepare((uint64_t)(a1 + 6), v47, v45 + 2);
      std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__node_insert_multi_perform(a1 + 6, v45, v48);
      int v37 = *(char **)v37;
    }
  }
LABEL_59:
  *((_DWORD *)a1 + 22) = *((_DWORD *)a2 + 22);
  return a1;
}

void sub_1847C285C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::WindowServer::Display::ModeSet::operator==(uint64_t a1, uint64_t a2)
{
  int8x16_t v3 = *(uint64_t **)a1;
  unsigned __int8 v2 = *(uint64_t **)(a1 + 8);
  int8x16_t v4 = *(uint64_t **)a2;
  if ((uint64_t *)((char *)v2 - *(void *)a1) != (uint64_t *)(*(void *)(a2 + 8) - *(void *)a2)) {
    return 0;
  }
  while (v3 != v2)
  {
    uint64_t result = CA::WindowServer::Display::Mode::operator==(*v3, *v4);
    if (!result) {
      return result;
    }
    ++v3;
    ++v4;
  }
  if (*(void *)(a1 + 40) != *(void *)(a2 + 40)) {
    return 0;
  }
  uint64_t v8 = *(void **)(a1 + 24);
  if (v8 == (void *)(a1 + 32)) {
    return 1;
  }
  CFStringRef v9 = *(void **)(a2 + 24);
  while (1)
  {
    BOOL v10 = *((unsigned __int16 *)v8 + 13) == *((unsigned __int16 *)v9 + 13)
       && *((unsigned __int16 *)v8 + 14) == *((unsigned __int16 *)v9 + 14);
    uint64_t result = v10;
    if (!v10) {
      break;
    }
    unint64_t v11 = (void *)v8[1];
    unsigned int v12 = v8;
    if (v11)
    {
      do
      {
        uint64_t v8 = v11;
        unint64_t v11 = (void *)*v11;
      }
      while (v11);
    }
    else
    {
      do
      {
        uint64_t v8 = (void *)v12[2];
        BOOL v10 = *v8 == (void)v12;
        unsigned int v12 = v8;
      }
      while (!v10);
    }
    unint64_t v13 = (void *)v9[1];
    if (v13)
    {
      do
      {
        long long v14 = v13;
        unint64_t v13 = (void *)*v13;
      }
      while (v13);
    }
    else
    {
      do
      {
        long long v14 = (void *)v9[2];
        BOOL v10 = *v14 == (void)v9;
        CFStringRef v9 = v14;
      }
      while (!v10);
    }
    CFStringRef v9 = v14;
    if (v8 == (void *)(a1 + 32)) {
      return 1;
    }
  }
  return result;
}

void CA::WindowServer::Display::ModeSet::set_mig_representation(CA::WindowServer::Display::ModeSet *this, unint64_t *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5, int a6, PerModeInfo *a7, unint64_t a8, unsigned int a9)
{
  v26[1] = *MEMORY[0x1E4F143B8];
  *((void *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(void *)this;
  long long v14 = (void *)((char *)this + 48);
  if (*((void *)this + 9))
  {
    uint64_t v15 = (void *)*((void *)this + 8);
    if (v15)
    {
      do
      {
        double v16 = (void *)*v15;
        operator delete(v15);
        uint64_t v15 = v16;
      }
      while (v16);
    }
    *((void *)this + 8) = 0;
    uint64_t v17 = *((void *)this + 7);
    if (v17)
    {
      for (uint64_t i = 0; i != v17; ++i)
        *(void *)(*v14 + 8 * i) = 0;
    }
    *((void *)this + 9) = 0;
  }
  if (a3)
  {
    unint64_t v19 = 0;
    unsigned int v20 = 1;
    do
    {
      unint64_t v21 = a2[v19];
      v26[0] = v21;
      CA::WindowServer::Display::ModeSet::add_mode(this, (const CA::WindowServer::Display::Mode *)v26);
      if (a5 == a3)
      {
        uint64_t v22 = &a4[3 * v19];
        v26[0] = v21;
        uint64_t v23 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)v14, v21, v26);
        unsigned int v24 = v22[2];
        v23[3] = *(void *)v22;
        *((_DWORD *)v23 + 8) = v24;
      }
      unint64_t v19 = v20++;
    }
    while (v19 < (unint64_t)a3);
  }
  *((_DWORD *)this + 22) = a6;
}

uint64_t CA_CFDictionaryGetInt(const __CFDictionary *a1, const void *a2)
{
  if (!a1) {
    return 0;
  }
  Boolean Value = CFDictionaryGetValue(a1, a2);
  if (!Value) {
    return 0;
  }

  return CA_CFIntValue(Value);
}

void CA::Display::DisplayTimingsControl::set_timings_shmem(os_unfair_lock_s *this, atomic_uint *a2)
{
  int8x16_t v4 = this + 3;
  os_unfair_lock_lock(this + 3);
  int64x2_t v5 = *(atomic_uint **)&this[4]._os_unfair_lock_opaque;
  if (v5)
  {
    *(void *)&this[4]._unsigned int os_unfair_lock_opaque = 0;
    if (atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
    }
    *(void *)&this[6]._unsigned int os_unfair_lock_opaque = 0;
  }
  if (a2)
  {
    int64_t v6 = *(atomic_uint **)&this[4]._os_unfair_lock_opaque;
    if (v6 != a2)
    {
      if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
      }
      unint64_t v7 = a2 + 2;
      if (!atomic_fetch_add(a2 + 2, 1u))
      {
        a2 = 0;
        atomic_fetch_add(v7, 0xFFFFFFFF);
      }
      *(void *)&this[4]._unsigned int os_unfair_lock_opaque = a2;
    }
    *(void *)&this[6]._unsigned int os_unfair_lock_opaque = *((void *)a2 + 3);
  }

  os_unfair_lock_unlock(v4);
}

CA::WindowServer::Display::ModeSet *CA::WindowServer::Display::ModeSet::ModeSet(CA::WindowServer::Display::ModeSet *this, const CA::WindowServer::Display::ModeSet *a2)
{
  v47[1] = *MEMORY[0x1E4F143B8];
  *(void *)this = 0;
  *((void *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  *((void *)this + 2) = 0;
  int64x2_t v5 = *(const void **)a2;
  uint64_t v4 = *((void *)a2 + 1);
  int64_t v6 = v4 - *(void *)a2;
  if (v4 != *(void *)a2)
  {
    std::vector<CA::WindowServer::Display::Mode>::__vallocate[abi:nn180100](this, v6 >> 3);
    unint64_t v7 = (char *)*((void *)this + 1);
    memmove(v7, v5, v6);
    *((void *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = &v7[v6];
  }
  *((void *)this + 4) = 0;
  uint64_t v8 = (char **)((char *)this + 32);
  *((void *)this + 3) = (char *)this + 32;
  *((void *)this + 5) = 0;
  CFStringRef v9 = (const CA::WindowServer::Display::ModeSet *)*((void *)a2 + 3);
  if (v9 != (const CA::WindowServer::Display::ModeSet *)((char *)a2 + 32))
  {
    do
    {
      v47[0] = 0;
      BOOL v10 = *v8;
      unint64_t v11 = (char *)this + 32;
      if (*((char ***)this + 3) == v8) {
        goto LABEL_21;
      }
      unsigned int v12 = *v8;
      unint64_t v13 = (char *)this + 32;
      if (v10)
      {
        do
        {
          unint64_t v11 = v12;
          unsigned int v12 = (char *)*((void *)v12 + 1);
        }
        while (v12);
      }
      else
      {
        do
        {
          unint64_t v11 = (char *)*((void *)v13 + 2);
          BOOL v16 = *(void *)v11 == (void)v13;
          unint64_t v13 = v11;
        }
        while (v16);
      }
      unsigned int v14 = *((unsigned __int16 *)v11 + 13);
      unsigned int v15 = *((unsigned __int16 *)v9 + 13);
      BOOL v16 = v14 == v15;
      if (v14 >= v15) {
        char v17 = 1;
      }
      else {
        char v17 = -1;
      }
      if (v16)
      {
        unsigned int v18 = *((unsigned __int16 *)v11 + 14);
        unsigned int v19 = *((unsigned __int16 *)v9 + 14);
        BOOL v20 = v18 == v19;
        char v17 = v18 >= v19 ? 1 : -1;
        if (v20) {
          char v17 = 0;
        }
      }
      if (v17 < 0)
      {
LABEL_21:
        if (v10)
        {
          v47[0] = (uint64_t)v11;
          unint64_t v21 = (uint64_t *)(v11 + 8);
        }
        else
        {
          v47[0] = (uint64_t)this + 32;
          unint64_t v21 = (uint64_t *)((char *)this + 32);
        }
      }
      else
      {
        unint64_t v21 = std::__tree<std::tuple<unsigned short,unsigned short>>::__find_equal<std::tuple<unsigned short,unsigned short>>((uint64_t)this + 24, v47, v15, *((_WORD *)v9 + 14));
      }
      if (!*v21)
      {
        uint64_t v22 = (char *)operator new(0x20uLL);
        *(_DWORD *)(v22 + 26) = *(_DWORD *)((char *)v9 + 26);
        std::__tree<std::tuple<unsigned short,unsigned short>>::__insert_node_at((uint64_t **)this + 3, v47[0], (uint64_t **)v21, (uint64_t *)v22);
      }
      uint64_t v23 = (const CA::WindowServer::Display::ModeSet *)*((void *)v9 + 1);
      if (v23)
      {
        do
        {
          unsigned int v24 = v23;
          uint64_t v23 = *(const CA::WindowServer::Display::ModeSet **)v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          unsigned int v24 = (const CA::WindowServer::Display::ModeSet *)*((void *)v9 + 2);
          BOOL v16 = *(void *)v24 == (void)v9;
          CFStringRef v9 = v24;
        }
        while (!v16);
      }
      CFStringRef v9 = v24;
    }
    while (v24 != (const CA::WindowServer::Display::ModeSet *)((char *)a2 + 32));
  }
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  unsigned __int16 v25 = (uint64_t *)((char *)this + 48);
  *((_DWORD *)this + 2CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *((_DWORD *)a2 + 20);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>((uint64_t)this + 48, *((void *)a2 + 7));
  unsigned __int16 v26 = (void *)*((void *)a2 + 8);
  if (v26)
  {
    uint64_t v27 = (void *)((char *)this + 64);
    unint64_t v28 = *((void *)this + 7);
    do
    {
      unint64_t v29 = v26[2];
      if (v28)
      {
        uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v28);
        v30.i16[0] = vaddlv_u8(v30);
        if (v30.u32[0] > 1uLL)
        {
          unint64_t v31 = v26[2];
          if (v29 >= v28) {
            unint64_t v31 = v29 % v28;
          }
        }
        else
        {
          unint64_t v31 = (v28 - 1) & v29;
        }
        id v32 = *(void **)(*v25 + 8 * v31);
        if (v32)
        {
          for (uint64_t i = (void *)*v32; i; uint64_t i = (void *)*i)
          {
            unint64_t v34 = i[1];
            if (v34 == v29)
            {
              if (i[2] == v29) {
                goto LABEL_73;
              }
            }
            else
            {
              if (v30.u32[0] > 1uLL)
              {
                if (v34 >= v28) {
                  v34 %= v28;
                }
              }
              else
              {
                v34 &= v28 - 1;
              }
              if (v34 != v31) {
                break;
              }
            }
          }
        }
      }
      else
      {
        unint64_t v31 = 0;
      }
      uint64_t v35 = operator new(0x28uLL);
      *uint64_t v35 = 0;
      v35[1] = v29;
      long long v36 = *((_OWORD *)v26 + 1);
      v35[4] = v26[4];
      *((_OWORD *)v35 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v36;
      float v37 = (float)(unint64_t)(*((void *)this + 9) + 1);
      float v38 = *((float *)this + 20);
      if (!v28 || (float)(v38 * (float)v28) < v37)
      {
        BOOL v39 = (v28 & (v28 - 1)) != 0;
        if (v28 < 3) {
          BOOL v39 = 1;
        }
        unint64_t v40 = v39 | (2 * v28);
        unint64_t v41 = vcvtps_u32_f32(v37 / v38);
        if (v40 <= v41) {
          size_t v42 = v41;
        }
        else {
          size_t v42 = v40;
        }
        std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::__rehash<true>((uint64_t)this + 48, v42);
        unint64_t v28 = *((void *)this + 7);
        if ((v28 & (v28 - 1)) != 0)
        {
          if (v29 >= v28) {
            unint64_t v31 = v29 % v28;
          }
          else {
            unint64_t v31 = v29;
          }
        }
        else
        {
          unint64_t v31 = (v28 - 1) & v29;
        }
      }
      uint64_t v43 = *v25;
      uint64_t v44 = *(void **)(*v25 + 8 * v31);
      if (v44)
      {
        *uint64_t v35 = *v44;
      }
      else
      {
        *uint64_t v35 = *v27;
        void *v27 = v35;
        *(void *)(v43 + 8 * v3CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v27;
        if (!*v35) {
          goto LABEL_72;
        }
        unint64_t v45 = *(void *)(*v35 + 8);
        if ((v28 & (v28 - 1)) != 0)
        {
          if (v45 >= v28) {
            v45 %= v28;
          }
        }
        else
        {
          v45 &= v28 - 1;
        }
        uint64_t v44 = (void *)(*v25 + 8 * v45);
      }
      *uint64_t v44 = v35;
LABEL_72:
      ++*((void *)this + 9);
LABEL_73:
      unsigned __int16 v26 = (void *)*v26;
    }
    while (v26);
  }
  *((_DWORD *)this + 22) = *((_DWORD *)a2 + 22);
  return this;
}

void sub_1847C3018(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v2);
  std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(*(void **)(v1 + 32));
  uint64_t v4 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

void CA::Render::anonymous namespace'::flatten_intervals(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  int64x2_t v5 = (double *)a2[1];
  unint64_t v6 = 126 - 2 * __clz(((uint64_t)v5 - v4) >> 4);
  if (v5 == (double *)v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v6;
  }
  CFStringRef v9 = (double *)*a2;
  uint64_t v8 = (double *)a2[1];
  if ((double *)*a2 == v8) {
    return;
  }
  double v10 = 0.0;
  char v11 = 1;
  do
  {
    if (v11)
    {
      unsigned int v12 = *(double **)(a1 + 8);
    }
    else
    {
      if (*v9 <= v10)
      {
        if (v10 <= v9[1]) {
          double v10 = v9[1];
        }
        goto LABEL_45;
      }
      unsigned int v14 = *(double **)(a1 + 8);
      unint64_t v13 = *(void *)(a1 + 16);
      if ((unint64_t)v14 >= v13)
      {
        unsigned int v15 = *(double **)a1;
        uint64_t v16 = ((uint64_t)v14 - *(void *)a1) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          goto LABEL_63;
        }
        uint64_t v18 = v13 - (void)v15;
        if (v18 >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v19 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v19);
          unsigned int v15 = *(double **)a1;
          unsigned int v14 = *(double **)(a1 + 8);
        }
        else
        {
          uint64_t v20 = 0;
        }
        unint64_t v21 = (double *)(v19 + 8 * v16);
        double *v21 = v10;
        unsigned int v12 = v21 + 1;
        while (v14 != v15)
        {
          uint64_t v22 = *((void *)v14-- - 1);
          *((void *)v21-- - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v22;
        }
        *(void *)a1 = v21;
        *(void *)(a1 + 8) = v12;
        *(void *)(a1 + 16) = v19 + 8 * v20;
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *unsigned int v14 = v10;
        unsigned int v12 = v14 + 1;
      }
      *(void *)(a1 + 8) = v12;
    }
    unint64_t v23 = *(void *)(a1 + 16);
    if ((unint64_t)v12 >= v23)
    {
      unsigned __int16 v25 = *(double **)a1;
      uint64_t v26 = ((uint64_t)v12 - *(void *)a1) >> 3;
      unint64_t v27 = v26 + 1;
      if ((unint64_t)(v26 + 1) >> 61) {
        goto LABEL_63;
      }
      uint64_t v28 = v23 - (void)v25;
      if (v28 >> 2 > v27) {
        unint64_t v27 = v28 >> 2;
      }
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v29 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v29 = v27;
      }
      if (v29)
      {
        unint64_t v29 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v29);
        unsigned __int16 v25 = *(double **)a1;
        unsigned int v12 = *(double **)(a1 + 8);
      }
      else
      {
        uint64_t v30 = 0;
      }
      unint64_t v31 = (void *)(v29 + 8 * v26);
      *unint64_t v31 = *(void *)v9;
      unsigned int v24 = v31 + 1;
      while (v12 != v25)
      {
        uint64_t v32 = *((void *)v12-- - 1);
        *--unint64_t v31 = v32;
      }
      *(void *)a1 = v31;
      *(void *)(a1 + 8) = v24;
      *(void *)(a1 + 16) = v29 + 8 * v30;
      if (v25) {
        operator delete(v25);
      }
    }
    else
    {
      *unsigned int v12 = *v9;
      unsigned int v24 = v12 + 1;
    }
    *(void *)(a1 + 8) = v24;
    double v10 = v9[1];
    uint64_t v8 = (double *)a2[1];
LABEL_45:
    char v11 = 0;
    v9 += 2;
  }
  while (v9 != v8);
  unint64_t v34 = *(double **)(a1 + 8);
  unint64_t v33 = *(void *)(a1 + 16);
  if ((unint64_t)v34 >= v33)
  {
    long long v36 = *(double **)a1;
    uint64_t v37 = ((uint64_t)v34 - *(void *)a1) >> 3;
    unint64_t v38 = v37 + 1;
    if ((unint64_t)(v37 + 1) >> 61) {
LABEL_63:
    }
      abort();
    uint64_t v39 = v33 - (void)v36;
    if (v39 >> 2 > v38) {
      unint64_t v38 = v39 >> 2;
    }
    BOOL v40 = (unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v41 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v40) {
      unint64_t v41 = v38;
    }
    if (v41)
    {
      unint64_t v41 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v41);
      long long v36 = *(double **)a1;
      unint64_t v34 = *(double **)(a1 + 8);
    }
    else
    {
      uint64_t v42 = 0;
    }
    uint64_t v43 = (double *)(v41 + 8 * v37);
    unint64_t v44 = v41 + 8 * v42;
    *uint64_t v43 = v10;
    uint64_t v35 = v43 + 1;
    while (v34 != v36)
    {
      uint64_t v45 = *((void *)v34-- - 1);
      *((void *)v43-- - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v45;
    }
    *(void *)a1 = v43;
    *(void *)(a1 + 8) = v35;
    *(void *)(a1 + 16) = v44;
    if (v36) {
      operator delete(v36);
    }
  }
  else
  {
    *unint64_t v34 = v10;
    uint64_t v35 = v34 + 1;
  }
  *(void *)(a1 + 8) = v35;
}

char *std::vector<CA::WindowServer::Display::Mode>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(unint64_t a1)
{
  if (a1 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a1);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,CA::Render::anonymous namespace'::Interval *,false>(uint64_t result, double *a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
LABEL_2:
  double v10 = a2 - 2;
  unint64_t v11 = v9;
  while (1)
  {
    unint64_t v9 = v11;
    uint64_t v12 = (uint64_t)a2 - v11;
    unint64_t v13 = (uint64_t)((uint64_t)a2 - v11) >> 4;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          double v40 = *(double *)v11;
          if (*v10 < *(double *)v11)
          {
            uint64_t v41 = *(void *)(v11 + 8);
            *(_OWORD *)unint64_t v11 = *(_OWORD *)v10;
            *(a2 - 2) = v40;
            *((void *)a2 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v41;
          }
          break;
        case 3uLL:
          break;
        case 4uLL:
          break;
        case 5uLL:
          uint64_t v42 = (_OWORD *)(v11 + 16);
          uint64_t v43 = (_OWORD *)(v11 + 32);
          unint64_t v44 = (_OWORD *)(v11 + 48);
          double v45 = *(double *)(v11 + 48);
          if (*v10 < v45)
          {
            uint64_t v46 = *(void *)(v11 + 56);
            *unint64_t v44 = *(_OWORD *)v10;
            *(a2 - 2) = v45;
            *((void *)a2 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v46;
            double v47 = *(double *)(v11 + 32);
            if (*(double *)(v11 + 48) < v47)
            {
              uint64_t v48 = *(void *)(v11 + 40);
              *uint64_t v43 = *v44;
              *(double *)(v11 + 48) = v47;
              *(void *)(v11 + 56) = v48;
              double v49 = *(double *)(v11 + 16);
              if (*(double *)(v11 + 32) < v49)
              {
                uint64_t v50 = *(void *)(v11 + 24);
                *uint64_t v42 = *v43;
                *(double *)(v11 + 32) = v49;
                *(void *)(v11 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v50;
                double v51 = *(double *)v11;
                if (*(double *)(v11 + 16) < *(double *)v11)
                {
                  uint64_t v52 = *(void *)(v11 + 8);
                  *(_OWORD *)unint64_t v11 = *v42;
                  *(double *)(v11 + 16) = v51;
                  *(void *)(v11 + 24) = v52;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 383) {
      break;
    }
    if (!a3)
    {
      if ((double *)v11 == a2) {
        return result;
      }
      int64_t v64 = (v13 - 2) >> 1;
      int64_t v65 = v64;
      do
      {
        int64_t v66 = v65;
        if (v64 >= v65)
        {
          uint64_t v67 = (2 * v65) | 1;
          uint64_t v68 = (double *)(v11 + 16 * v67);
          if (2 * v66 + 2 < (uint64_t)v13 && *v68 < v68[2])
          {
            v68 += 2;
            uint64_t v67 = 2 * v66 + 2;
          }
          int v69 = (double *)(v11 + 16 * v66);
          double v70 = *v69;
          if (*v68 >= *v69)
          {
            uint64_t v71 = *(void *)(v11 + 16 * v66 + 8);
            do
            {
              unsigned int v72 = v68;
              *(_OWORD *)int v69 = *(_OWORD *)v68;
              if (v64 < v67) {
                break;
              }
              uint64_t v73 = 2 * v67;
              uint64_t v67 = (2 * v67) | 1;
              uint64_t v68 = (double *)(v11 + 16 * v67);
              uint64_t v74 = v73 + 2;
              if (v74 < (uint64_t)v13 && *v68 < v68[2])
              {
                v68 += 2;
                uint64_t v67 = v74;
              }
              int v69 = v72;
            }
            while (*v68 >= v70);
            double *v72 = v70;
            *((void *)v72 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v71;
          }
        }
        int64_t v65 = v66 - 1;
      }
      while (v66);
      uint64_t v75 = (unint64_t)v12 >> 4;
      while (2)
      {
        uint64_t v76 = 0;
        int v77 = a2;
        double v79 = *(double *)v11;
        uint64_t v78 = *(void *)(v11 + 8);
        long long v80 = (double *)v11;
        do
        {
          long long v81 = v80;
          v80 += 2 * v76 + 2;
          uint64_t v82 = 2 * v76;
          uint64_t v76 = (2 * v76) | 1;
          uint64_t v83 = v82 + 2;
          if (v83 < v75 && *v80 < v80[2])
          {
            v80 += 2;
            uint64_t v76 = v83;
          }
          *(_OWORD *)long long v81 = *(_OWORD *)v80;
        }
        while (v76 <= (uint64_t)((unint64_t)(v75 - 2) >> 1));
        a2 -= 2;
        if (v80 == v77 - 2)
        {
LABEL_114:
          *long long v80 = v79;
          *((void *)v80 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v78;
        }
        else
        {
          *(_OWORD *)long long v80 = *(_OWORD *)a2;
          *(v77 - 2) = v79;
          *((void *)v77 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v78;
          uint64_t v84 = (uint64_t)v80 - v11 + 16;
          if (v84 >= 17)
          {
            unint64_t v85 = (((unint64_t)v84 >> 4) - 2) >> 1;
            uint64_t v86 = (double *)(v11 + 16 * v85);
            double v79 = *v80;
            if (*v86 < *v80)
            {
              uint64_t v78 = *((void *)v80 + 1);
              unint64_t v87 = v80;
              do
              {
                long long v80 = v86;
                *(_OWORD *)unint64_t v87 = *(_OWORD *)v86;
                if (!v85) {
                  break;
                }
                unint64_t v85 = (v85 - 1) >> 1;
                uint64_t v86 = (double *)(v11 + 16 * v85);
                unint64_t v87 = v80;
              }
              while (*v86 < v79);
              goto LABEL_114;
            }
          }
        }
        if (v75-- <= 2) {
          return result;
        }
        continue;
      }
    }
    unint64_t v14 = v13 >> 1;
    unsigned int v15 = (_OWORD *)(v11 + 16 * (v13 >> 1));
    if ((unint64_t)v12 >= 0x801)
    {
      long long v16 = *(_OWORD *)v9;
      *(_OWORD *)unint64_t v9 = *v15;
      *unsigned int v15 = v16;
    }
    else
    {
    }
    --a3;
    double v17 = *(double *)v9;
    if ((a4 & 1) != 0 || *(double *)(v9 - 16) < v17)
    {
      uint64_t v18 = *(void *)(v9 + 8);
      unint64_t v19 = v9;
      do
      {
        unint64_t v20 = v19;
        double v21 = *(double *)(v19 + 16);
        v19 += 16;
        double v22 = v21;
      }
      while (v21 < v17);
      unint64_t v23 = a2;
      if (v20 == v9)
      {
        unint64_t v23 = a2;
        do
        {
          if (v19 >= (unint64_t)v23) {
            break;
          }
          double v25 = *(v23 - 2);
          v23 -= 2;
        }
        while (v25 >= v17);
      }
      else
      {
        do
        {
          double v24 = *(v23 - 2);
          v23 -= 2;
        }
        while (v24 >= v17);
      }
      if (v19 >= (unint64_t)v23)
      {
        unint64_t v11 = v19;
      }
      else
      {
        unint64_t v26 = (unint64_t)v23;
        unint64_t v11 = v19;
        do
        {
          uint64_t v27 = *(void *)(v11 + 8);
          *(_OWORD *)unint64_t v11 = *(_OWORD *)v26;
          *(double *)unint64_t v26 = v22;
          *(void *)(v26 + 8) = v27;
          do
          {
            double v28 = *(double *)(v11 + 16);
            v11 += 16;
            double v22 = v28;
          }
          while (v28 < v17);
          do
          {
            double v29 = *(double *)(v26 - 16);
            v26 -= 16;
          }
          while (v29 >= v17);
        }
        while (v11 < v26);
      }
      if (v11 - 16 != v9) {
        *(_OWORD *)unint64_t v9 = *(_OWORD *)(v11 - 16);
      }
      *(double *)(v11 - 16) = v17;
      *(void *)(v11 - 8) = v18;
      if (v19 < (unint64_t)v23) {
        goto LABEL_33;
      }
      if (result)
      {
        a2 = (double *)(v11 - 16);
        if (v30) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v30)
      {
LABEL_33:
        a4 = 0;
      }
    }
    else
    {
      if (v17 >= *v10)
      {
        unint64_t v32 = v9 + 16;
        do
        {
          unint64_t v11 = v32;
          if (v32 >= (unint64_t)a2) {
            break;
          }
          v32 += 16;
        }
        while (v17 >= *(double *)v11);
      }
      else
      {
        unint64_t v11 = v9;
        do
        {
          double v31 = *(double *)(v11 + 16);
          v11 += 16;
        }
        while (v17 >= v31);
      }
      unint64_t v33 = a2;
      if (v11 < (unint64_t)a2)
      {
        unint64_t v33 = a2;
        do
        {
          double v34 = *(v33 - 2);
          v33 -= 2;
        }
        while (v17 < v34);
      }
      uint64_t v35 = *(void *)(v9 + 8);
      if (v11 < (unint64_t)v33)
      {
        double v36 = *(double *)v11;
        do
        {
          uint64_t v37 = *(void *)(v11 + 8);
          *(_OWORD *)unint64_t v11 = *(_OWORD *)v33;
          double *v33 = v36;
          *((void *)v33 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v37;
          do
          {
            double v38 = *(double *)(v11 + 16);
            v11 += 16;
            double v36 = v38;
          }
          while (v17 >= v38);
          do
          {
            double v39 = *(v33 - 2);
            v33 -= 2;
          }
          while (v17 < v39);
        }
        while (v11 < (unint64_t)v33);
      }
      BOOL v4 = v11 - 16 >= v9;
      BOOL v5 = v11 - 16 == v9;
      if (v11 - 16 != v9) {
        *(_OWORD *)unint64_t v9 = *(_OWORD *)(v11 - 16);
      }
      a4 = 0;
      *(double *)(v11 - 16) = v17;
      *(void *)(v11 - 8) = v35;
    }
  }
  CFRange v53 = (double *)(v11 + 16);
  BOOL v55 = (double *)v11 == a2 || v53 == a2;
  if (a4)
  {
    if (!v55)
    {
      uint64_t v56 = 0;
      unint64_t v57 = v11;
      do
      {
        unint64_t v58 = v53;
        double v59 = *(double *)(v57 + 16);
        if (v59 < *(double *)v57)
        {
          uint64_t v60 = *(void *)(v57 + 24);
          uint64_t v61 = v56;
          while (1)
          {
            *(_OWORD *)(v11 + v61 + 16) = *(_OWORD *)(v11 + v61);
            if (!v61) {
              break;
            }
            double v62 = *(double *)(v11 + v61 - 16);
            v61 -= 16;
            if (v59 >= v62)
            {
              uint64_t v63 = v11 + v61 + 16;
              goto LABEL_84;
            }
          }
          uint64_t v63 = v11;
LABEL_84:
          *(double *)uint64_t v63 = v59;
          *(void *)(v63 + 8) = v60;
        }
        CFRange v53 = v58 + 2;
        v56 += 16;
        unint64_t v57 = (unint64_t)v58;
      }
      while (v58 + 2 != a2);
    }
  }
  else if (!v55)
  {
    do
    {
      unint64_t v89 = (unint64_t)v53;
      double v90 = *(double *)(v9 + 16);
      if (v90 < *(double *)v9)
      {
        uint64_t v91 = *(void *)(v9 + 24);
        uint64_t v92 = v53;
        do
        {
          *(_OWORD *)uint64_t v92 = *((_OWORD *)v92 - 1);
          double v93 = *(v92 - 4);
          v92 -= 2;
        }
        while (v90 < v93);
        *uint64_t v92 = v90;
        *((void *)v92 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v91;
      }
      v53 += 2;
      unint64_t v9 = v89;
    }
    while ((double *)(v89 + 16) != a2);
  }
  return result;
}

uint64_t CARenderServerGetFrameCounterByIndex(mach_port_name_t a1, unsigned int a2)
{
  CFDictionaryRef v2 = (const __CFDictionary *)CARenderServerCopyDictionaryByIndex(a1, a2);
  if (!v2) {
    return 0;
  }
  CFDictionaryRef v3 = v2;
  Boolean Value = CFDictionaryGetValue(v2, @"kCADisplayFrameCount");
  if (Value) {
    uint64_t v5 = CA_CFIntValue(Value);
  }
  else {
    uint64_t v5 = 0;
  }
  CFRelease(v3);
  return v5;
}

uint64_t CARenderServerGetDirtyFrameCountByIndex(mach_port_name_t a1, unsigned int a2)
{
  CFDictionaryRef v2 = (const __CFDictionary *)CARenderServerCopyDictionaryByIndex(a1, a2);
  if (!v2) {
    return 0;
  }
  CFDictionaryRef v3 = v2;
  Boolean Value = CFDictionaryGetValue(v2, @"kCADisplayDirtyFrameCount");
  if (Value) {
    uint64_t v5 = CA_CFIntValue(Value);
  }
  else {
    uint64_t v5 = 0;
  }
  CFRelease(v3);
  return v5;
}

CFTypeRef CARenderServerCopyDictionaryByIndex(mach_port_name_t a1, unsigned int a2)
{
  CFArrayRef v3 = (const __CFArray *)CARenderServerCopyDictionaries(a1);
  if (!v3) {
    return 0;
  }
  CFArrayRef v4 = v3;
  if (CFArrayGetCount(v3) <= a2)
  {
    CFTypeRef v6 = 0;
  }
  else
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v4, a2);
    CFTypeRef v6 = CFRetain(ValueAtIndex);
  }
  CFRelease(v4);
  return v6;
}

CFPropertyListRef CARenderServerCopyDictionaries(mach_port_name_t a1)
{
  length_4[1] = *(const UInt8 **)MEMORY[0x1E4F143B8];
  mach_port_name_t ServerPort = a1;
  if (!a1)
  {
    mach_port_name_t ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort) {
      return 0;
    }
  }
  length_4[0] = 0;
  unsigned int length = 0;
  int v3 = _CASGetDisplays(ServerPort, length_4, &length);
  if (v3 == -81182719)
  {
    x_log_crash("Unentitled call to server!");
    abort();
  }
  int v4 = v3;
  if (!a1)
  {
    mach_port_deallocate(*MEMORY[0x1E4F14960], ServerPort);
    if (!v4) {
      goto LABEL_8;
    }
    return 0;
  }
  if (v3) {
    return 0;
  }
LABEL_8:
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF98];
  CFTypeRef v6 = length_4[0];
  mach_vm_size_t v7 = length;
  CFDataRef v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF98], length_4[0], length);
  mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)v6, v7);
  if (!v8) {
    return 0;
  }
  CFPropertyListRef v9 = CFPropertyListCreateWithData(v5, v8, 0, 0, 0);
  CFRelease(v8);
  return v9;
}

uint64_t _CASGetDisplays(int a1, void *a2, _DWORD *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  memset(&msg_4[16], 0, 44);
  *(_OWORD *)int msg_4 = 0u;
  *(void *)&msg_4[20] = *MEMORY[0x1E4F14068];
  mach_port_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = a1;
  *(_DWORD *)&msg_4[8] = reply_port;
  int msg = 5395;
  *(void *)&msg_4[12] = 0x9D2700000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    mach_port_t reply_port = *(_DWORD *)&msg_4[8];
  }
  uint64_t v7 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x40u, reply_port, 0, 0);
  uint64_t v8 = v7;
  if ((v7 - 268435458) <= 0xE && ((1 << (v7 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
  }
  else
  {
    if (!v7)
    {
      if (*(_DWORD *)&msg_4[16] == 71)
      {
        uint64_t v8 = 4294966988;
      }
      else if (*(_DWORD *)&msg_4[16] == 40331)
      {
        if (msg < 0)
        {
          uint64_t v8 = 4294966996;
          if (*(_DWORD *)&msg_4[20] == 1 && *(_DWORD *)msg_4 == 56 && !*(_DWORD *)&msg_4[4] && msg_4[35] == 1)
          {
            int v9 = *(_DWORD *)&msg_4[36];
            if (*(_DWORD *)&msg_4[36] == *(_DWORD *)&msg_4[48])
            {
              uint64_t v8 = 0;
              *a2 = *(void *)&msg_4[24];
              *a3 = v9;
              return v8;
            }
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          uint64_t v8 = 4294966996;
          if (*(_DWORD *)&msg_4[28])
          {
            if (*(_DWORD *)&msg_4[4]) {
              uint64_t v8 = 4294966996;
            }
            else {
              uint64_t v8 = *(unsigned int *)&msg_4[28];
            }
          }
        }
        else
        {
          uint64_t v8 = 4294966996;
        }
      }
      else
      {
        uint64_t v8 = 4294966995;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
      return v8;
    }
    mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
  }
  return v8;
}

void CA::WindowServer::Display::ModeSet::add_mode(CA::WindowServer::Display::ModeSet *this, const CA::WindowServer::Display::Mode *a2)
{
  v24[1] = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v5 = (void *)*((void *)this + 1);
  unint64_t v4 = *((void *)this + 2);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = ((uint64_t)v5 - *(void *)this) >> 3;
    if ((unint64_t)(v7 + 1) >> 61) {
      abort();
    }
    uint64_t v8 = v4 - *(void *)this;
    uint64_t v9 = v8 >> 2;
    if (v8 >> 2 <= (unint64_t)(v7 + 1)) {
      uint64_t v9 = v7 + 1;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10) {
      unint64_t v10 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v10);
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v12 = (void *)(v10 + 8 * v7);
    unint64_t v13 = v10 + 8 * v11;
    *uint64_t v12 = *(void *)a2;
    CFTypeRef v6 = v12 + 1;
    unsigned int v15 = *(char **)this;
    unint64_t v14 = (char *)*((void *)this + 1);
    if (v14 != *(char **)this)
    {
      do
      {
        uint64_t v16 = *((void *)v14 - 1);
        v14 -= 8;
        *--uint64_t v12 = v16;
      }
      while (v14 != v15);
      unint64_t v14 = *(char **)this;
    }
    *(void *)this = v12;
    *((void *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v6;
    *((void *)this + 2) = v13;
    if (v14) {
      operator delete(v14);
    }
  }
  else
  {
    *CFAllocatorRef v5 = *(void *)a2;
    CFTypeRef v6 = v5 + 1;
  }
  *((void *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v6;
  uint64_t v17 = *(void *)a2;
  if ((*(void *)a2 & 0x40000000000000) == 0)
  {
    uint64_t v18 = (uint64_t **)((char *)this + 24);
    uint64_t v19 = *(void *)a2 & 0x3FFFLL;
    unsigned int v20 = (v17 >> 14) & 0x3FFF;
    v24[0] = 0;
    double v21 = std::__tree<std::tuple<unsigned short,unsigned short>>::__find_equal<std::tuple<unsigned short,unsigned short>>((uint64_t)v18, v24, v17 & 0x3FFF, (v17 >> 14) & 0x3FFF);
    if (!*v21)
    {
      double v22 = (uint64_t **)v21;
      unint64_t v23 = (char *)operator new(0x20uLL);
      *(_DWORD *)(v23 + 26) = v19 | (v20 << 16);
      std::__tree<std::tuple<unsigned short,unsigned short>>::__insert_node_at(v18, v24[0], v22, (uint64_t *)v23);
    }
  }
}

void CAFrameRateRangeGroupShouldUpdate(int a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::FrameRateRangeGroup::_list_lock);
  for (uint64_t i = CA::FrameRateRangeGroup::_list; i; uint64_t i = *(void *)(i + 24))
  {
    if (*(_DWORD *)(i + 4) == a1)
    {
      os_unfair_lock_lock((os_unfair_lock_t)i);
      *(void *)(i + 104) = *(void *)(i + 96);
      for (uint64_t j = *(uint64_t **)(i + 72); j; uint64_t j = (uint64_t *)*j)
      {
        CA::FrameRateRangeGroup::add((CA::FrameRateRangeGroup *)i, *(CAFrameRateRange *)(j + 2));
        --j[6];
      }
      os_unfair_lock_unlock((os_unfair_lock_t)i);
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&CA::FrameRateRangeGroup::_list_lock);
}

void sub_1847C40DC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::FrameRateRangeGroup::_list_lock);
  _Unwind_Resume(a1);
}

void CADynamicFrameRateSourceRecomputeFrameInterval(int a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::DynamicFrameRateSource::_list_lock);
  for (uint64_t i = CA::DynamicFrameRateSource::_list; i; uint64_t i = *(void *)(i + 96))
  {
    if (*(_DWORD *)i == a1) {
      CA::DynamicFrameRateSource::set_preferred_fps_range((CA::DynamicFrameRateSource *)i, *(CAFrameRateRange *)(i + 16), 0);
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&CA::DynamicFrameRateSource::_list_lock);
}

void sub_1847C4174(_Unwind_Exception *a1)
{
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CA::Render::anonymous namespace'::Interval *>(uint64_t result, uint64_t a2, uint64_t a3)
{
  double v3 = *(double *)a2;
  double v4 = *(double *)result;
  double v5 = *(double *)a3;
  if (*(double *)a2 >= *(double *)result)
  {
    if (v5 < v3)
    {
      uint64_t v7 = *(void *)(a2 + 8);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(double *)a3 = v3;
      *(void *)(a3 + 8) = v7;
      double v8 = *(double *)result;
      if (*(double *)a2 < *(double *)result)
      {
        uint64_t v9 = *(void *)(result + 8);
        *(_OWORD *)uint64_t result = *(_OWORD *)a2;
        *(double *)a2 = v8;
        *(void *)(a2 + 8) = v9;
      }
    }
  }
  else
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v5 >= v3)
    {
      *(_OWORD *)uint64_t result = *(_OWORD *)a2;
      *(double *)a2 = v4;
      *(void *)(a2 + 8) = v6;
      if (*(double *)a3 >= v4) {
        return result;
      }
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      *(_OWORD *)uint64_t result = *(_OWORD *)a3;
    }
    *(double *)a3 = v4;
    *(void *)(a3 + 8) = v6;
  }
  return result;
}

uint64_t __CADeviceSupportsASTC_block_invoke()
{
  uint64_t result = MGGetBoolAnswer();
  CADeviceSupportsASTC::supports_astc = result;
  return result;
}

CA::Render::Pattern *CA::Render::Pattern::Pattern(CA::Render::Pattern *this, CA::Render::Decoder *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0x25;
  ++dword_1EB2ADE5C;
  *(void *)this = &unk_1ED02F960;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0u;
  CA::Render::Decoder::decode_cgfloat(a2, (double *)this + 2, 6);
  long long v6 = 0u;
  long long v7 = 0u;
  CA::Render::Decoder::decode_cgfloat(a2, (double *)&v6, 4);
  long long v4 = v7;
  *((_OWORD *)this + 4) = v6;
  *((_OWORD *)this + 5) = v4;
  long long v6 = 0uLL;
  CA::Render::Decoder::decode_cgfloat(a2, (double *)&v6, 2);
  *((_OWORD *)this + 6) = v6;
  long long v6 = 0uLL;
  CA::Render::Decoder::decode_cgfloat(a2, (double *)&v6, 2);
  *((_OWORD *)this + 7) = v6;
  *((void *)this + 16) = CA::Render::Decoder::decode_object(a2, 6, (uint64_t)&CA::Render::texture_types);
  return this;
}

CA::Render::GradientLayer *CA::Render::GradientLayer::GradientLayer(CA::Render::GradientLayer *this, CA::Render::Decoder *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0x14;
  ++dword_1EB2ADE18;
  *(void *)this = &unk_1ED02D9A0;
  CA::Render::Gradient::Gradient((CA::Render::GradientLayer *)((char *)this + 16), a2);
  *(_OWORD *)uint64_t v11 = 0uLL;
  CA::Render::Decoder::decode_cgfloat(a2, v11, 2);
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)v11;
  *(_OWORD *)uint64_t v11 = 0uLL;
  CA::Render::Decoder::decode_cgfloat(a2, v11, 2);
  *(_OWORD *)((char *)this + 88) = *(_OWORD *)v11;
  *((_DWORD *)this + 26) = CA::Render::Decoder::decode_atom(a2);
  int v4 = CA::Render::Decoder::decode_int32(a2);
  *((_OWORD *)this + 7) = 0u;
  double v5 = (atomic_uint **)((char *)this + 112);
  *((_DWORD *)this + 27) = v4;
  *((_OWORD *)this + 8) = 0u;
  if ((*((unsigned char *)this + 13) & 8) != 0)
  {
    long long v6 = CA::Render::Decoder::decode_object(a2, 6, (uint64_t)&CA::Render::texture_types);
    long long v7 = *v5;
    *double v5 = v6;
    if (v7)
    {
      if (atomic_fetch_add(v7 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v7 + 16))(v7);
      }
    }
  }
  CGColorSpaceRef v8 = CA::Render::Decoder::decode_colorspace(a2);
  uint64_t v9 = (const void *)*((void *)this + 16);
  if (v9) {
    CFRelease(v9);
  }
  *((void *)this + 16) = v8;
  return this;
}

uint64_t CA::Render::Path::decode(CA::Render::Path *this, CA::Render::Decoder *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = CA::Render::Decoder::decode_size_t(this);
  unsigned int v4 = CA::Render::Decoder::decode_int32(this);
  unsigned int v5 = CA::Render::Decoder::decode_int32(this);
  uint64_t v6 = CA::Render::Decoder::decode_int32(this);
  uint64_t v7 = 0;
  if (HIBYTE(v4)) {
    return v7;
  }
  if (HIBYTE(v5)) {
    return v7;
  }
  int v8 = v6;
  if (BYTE3(v6)) {
    return v7;
  }
  uint64_t v9 = v4;
  if (v4 > 0x1000)
  {
    uint64_t v11 = (unsigned __int8 *)malloc_type_malloc(v4, 0x100004077774924uLL);
    unint64_t v10 = v11;
  }
  else
  {
    MEMORY[0x1F4188790](v6);
    unint64_t v10 = &v17[-((v4 + 15) & 0x1FFFFFFF0)];
    bzero(v10, v4);
  }
  if (v5 > 0x100)
  {
    unint64_t v13 = malloc_type_malloc(16 * v5, 0x1000040451B5BE8uLL);
  }
  else
  {
    MEMORY[0x1F4188790](v11);
    unint64_t v13 = &v17[-((v12 + 15) & 0x1FFFFFFFF0)];
    bzero(v13, v12);
  }
  uint64_t v7 = 0;
  if (!v10 || !v13)
  {
LABEL_18:
    if (v10) {
      goto LABEL_19;
    }
    goto LABEL_21;
  }
  int v18 = v8;
  uint64_t v19 = v3;
  CA::Render::Decoder::decode_bytes(this, v10, v4);
  CA::Render::Decoder::decode_cgfloat(this, (double *)v13, 2 * v5);
  unsigned int v20 = v10;
  int v14 = 0;
  if (v4)
  {
    do
    {
      unsigned int v15 = *v10;
      if (v15 >= 5)
      {
        CA::Render::Decoder::set_fatal_error(this, "%s - unexpected path type %u", "decode", v15);
        unsigned int v15 = 0u;
        unsigned __int8 *v10 = 0;
      }
      v14 += CA::Render::path_counts[v15];
      ++v10;
      --v9;
    }
    while (v9);
  }
  if (v14 == v5)
  {
    unint64_t v10 = v20;
    uint64_t v7 = CA::Render::Path::new_path(v19, v4, v20, v5, (double *)v13, v18);
    goto LABEL_18;
  }
  CA::Render::Decoder::set_fatal_error(this, "%s - expected %u points, but decoded %u points", "decode", v14, v5);
  uint64_t v7 = 0;
  unint64_t v10 = v20;
  if (v20)
  {
LABEL_19:
    if (v4 > 0x1000) {
      free(v10);
    }
  }
LABEL_21:
  if (v13 && v5 >= 0x101) {
    free(v13);
  }
  return v7;
}

void CA::Render::Decoder::decode_cgfloat(CA::Render::Decoder *this, double *__dst, uint64_t a3)
{
  uint64_t v3 = a3;
  unsigned int v4 = __dst;
  if (*((unsigned char *)this + 64))
  {
    size_t v6 = 8 * a3;
    CA::Render::Decoder::decode_bytes(this, __dst, v6);
  }
  else if (a3)
  {
    do
    {
      *v4++ = COERCE_FLOAT(CA::Render::Decoder::decode_int32(this));
      --v3;
    }
    while (v3);
  }
}

uint64_t CA::Render::Path::new_path(uint64_t a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4, double *a5, int a6)
{
  if (!a1 || !CA::Render::Path::_path_table) {
    goto LABEL_24;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Path::_path_lock);
  uint64_t v12 = x_hash_table_lookup(CA::Render::Path::_path_table, a1, 0);
  if (!v12) {
    goto LABEL_23;
  }
  uint64_t v13 = v12;
  if (!atomic_fetch_add((atomic_uint *volatile)(v12 + 8), 1u))
  {
    atomic_fetch_add((atomic_uint *volatile)(v12 + 8), 0xFFFFFFFF);
LABEL_23:
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Path::_path_lock);
    goto LABEL_24;
  }
  if (*(_DWORD *)(v12 + 20) == a2 && *(_DWORD *)(v12 + 24) == a4 && *(_DWORD *)(v12 + 16) == a6)
  {
    uint64_t v14 = 0;
    if (a2)
    {
      while (*(unsigned __int8 *)(*(void *)(v12 + 40) + v14) == a3[v14])
      {
        if (a2 == ++v14) {
          goto LABEL_13;
        }
      }
    }
    if (v14 == a2)
    {
LABEL_13:
      uint64_t v15 = 0;
      if (a4)
      {
        uint64_t v16 = a5 + 1;
        uint64_t v17 = (double *)(*(void *)(v12 + 32) + 8);
        while (*(v17 - 1) == *(v16 - 1) && *v17 == *v16)
        {
          ++v15;
          v16 += 2;
          v17 += 2;
          if (a4 == v15) {
            goto LABEL_33;
          }
        }
      }
      if (v15 == a4) {
        goto LABEL_33;
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Path::_path_lock);
  if (atomic_fetch_add((atomic_uint *volatile)(v13 + 8), 0xFFFFFFFF) == 1) {
    (*(void (**)(uint64_t))(*(void *)v13 + 16))(v13);
  }
LABEL_24:
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v19 = malloc_type_zone_malloc(malloc_zone, a2 + 16 * a4 + 113, 0x8BB15036uLL);
  uint64_t v13 = (uint64_t)v19;
  if (v19)
  {
    v19[2] = 1;
    v19[3] = 36;
    ++dword_1EB2ADE58;
    *(void *)uint64_t v19 = &unk_1ED02F0E0;
    v19[4] = a6;
    v19[5] = a2;
    v19[6] = a4;
    unsigned int v20 = (char *)&v19[4 * a4 + 28];
    *(void *)(v13 + 32) = v13 + 112;
    *(void *)(v13 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v20;
    *(void *)(v13 + 56) = 0;
    *(void *)(v13 + 64) = 0;
    *(void *)(v13 + 48) = a1;
    if (a3)
    {
      memcpy(v20, a3, a2);
      *(unsigned char *)(*(void *)(v13 + 40) + a2) = 5;
    }
    if (a5) {
      memcpy(*(void **)(v13 + 32), a5, 16 * a4);
    }
    if (a1)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Path::_path_lock);
      uint64_t v21 = (int *)CA::Render::Path::_path_table;
      if (!CA::Render::Path::_path_table)
      {
        uint64_t v21 = (int *)x_hash_table_new_(0, 0, 0, 0, 0, 0);
        CA::Render::Path::_path_table = (uint64_t)v21;
      }
      hash_table_modify(v21, *(void *)(v13 + 48), v13, 0);
LABEL_33:
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Path::_path_lock);
    }
  }
  return v13;
}

CA::Render::Gradient *CA::Render::Gradient::Gradient(CA::Render::Gradient *this, CA::Render::Decoder *a2)
{
  unsigned int v4 = CA::Render::InterpolatedFunction::InterpolatedFunction(this, a2);
  *(void *)unsigned int v4 = &unk_1ED02FF20;
  int v5 = *((_DWORD *)v4 + 6);
  if (v5 != 4) {
    CA::Render::Decoder::set_fatal_error(a2, "%s - width = %u", "Gradient", v5);
  }
  return this;
}

CA::Render::InterpolatedFunction *CA::Render::InterpolatedFunction::InterpolatedFunction(CA::Render::InterpolatedFunction *this, CA::Render::Decoder *a2)
{
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = 18;
  ++dword_1EB2ADE10;
  *(void *)this = &unk_1ED02EC98;
  *((void *)this + 2) = CA::Render::Decoder::decode_size_t(a2);
  *((_DWORD *)this + 6) = CA::Render::Decoder::decode_int32(a2);
  *((float *)this + 7) = (float)*((unint64_t *)this + 2) + -1.0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 3) |= CA::Render::Decoder::decode_int32(a2) << 8;
  if (*((void *)this + 2))
  {
    CA::Render::InterpolatedFunction::allocate_storage(this);
    unsigned int v4 = (void *)*((void *)this + 4);
    if (v4)
    {
      CA::Render::Decoder::decode_bytes(a2, v4, 4 * *((void *)this + 2) * *((unsigned int *)this + 6));
      if ((*((unsigned char *)this + 13) & 2) != 0)
      {
        int v5 = (void *)*((void *)this + 5);
        if (v5) {
          CA::Render::Decoder::decode_bytes(a2, v5, 4 * *((void *)this + 2));
        }
        else {
          CA::Render::Decoder::set_fatal_error(a2, "%s - _locations = NULL", "InterpolatedFunction");
        }
      }
      if ((*((unsigned char *)this + 13) & 4) != 0)
      {
        size_t v6 = (void *)*((void *)this + 6);
        if (v6) {
          CA::Render::Decoder::decode_bytes(a2, v6, 32 * *((void *)this + 2) - 32);
        }
        else {
          CA::Render::Decoder::set_fatal_error(a2, "%s - _interpolations = NULL");
        }
      }
    }
    else
    {
      CA::Render::Decoder::set_fatal_error(a2, "%s - _values = NULL");
    }
  }
  return this;
}

void ___ZL27cons_CALayer_kCAValueDoublejb_block_invoke_2(uint64_t a1, uint64_t a2, double a3)
{
  v4[1] = *(double *)MEMORY[0x1E4F143B8];
  uint64_t v3 = (const void *)*(unsigned int *)(a1 + 32);
  v4[0] = a3;
  CA::Layer::setter(*(CA::Transaction **)(a2 + 16), v3, (const CGAffineTransform *)0x12, v4);
}

char *___ZL18force_local_serverv_block_invoke()
{
  uint64_t result = getenv("CA_FORCE_LOCAL_SERVER");
  force_local_server(void)::_force_local_server = result != 0;
  return result;
}

uint64_t __CADeviceSupportsHDRExternalDisplayBrightnessControl_block_invoke()
{
  uint64_t result = _os_feature_enabled_impl();
  CADeviceSupportsHDRExternalDisplayBrightnessControl::enabled = result;
  return result;
}

uint64_t ___ZN2CA3OGL12MetalContext5flushEb_block_invoke_2(uint64_t a1)
{
  uint64_t result = [*(id *)(a1 + 32) commitAndWaitUntilSubmitted];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

uint64_t CAImageQueueConsumeUnconsumedInRange(uint64_t a1, char a2, double a3, double a4)
{
  uint64_t v4 = *(void *)(a1 + 48);
  if (!v4) {
    return 0;
  }
  uint64_t v9 = *(void *)(v4 + 24);
  unint64_t v10 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (!*(_DWORD *)(a1 + 40))
  {
    uint64_t v12 = 0;
    goto LABEL_32;
  }
  unint64_t v11 = 0;
  uint64_t v12 = 0;
  int v13 = *(_DWORD *)(a1 + 24);
  double v14 = INFINITY;
  if ((a2 & 2) == 0) {
    double v14 = -INFINITY;
  }
  uint64_t v15 = (unsigned char *)(v9 + 585);
  uint64_t v16 = -1;
  do
  {
    if (!*(_DWORD *)(v15 - 53)) {
      goto LABEL_25;
    }
    int v17 = *(_DWORD *)(v15 - 57);
    if (v17 - v13 < 0)
    {
      int v21 = 0;
      atomic_compare_exchange_strong((atomic_uint *volatile)(v15 - 61), (unsigned int *)&v21, 0x33333333u);
LABEL_19:
      if (v21) {
        goto LABEL_25;
      }
LABEL_20:
      *uint64_t v15 = 1;
      ++v12;
      goto LABEL_25;
    }
    double v18 = *(double *)(v15 - 121);
    if (v17 != v13 || v18 < a3 || v18 > a4) {
      goto LABEL_25;
    }
    if ((a2 & 2) == 0)
    {
      if (v18 <= v14) {
        goto LABEL_17;
      }
      goto LABEL_22;
    }
    if (v18 >= v14)
    {
LABEL_17:
      int v21 = 0;
      atomic_compare_exchange_strong((atomic_uint *volatile)(v15 - 61), (unsigned int *)&v21, 0x22222222u);
      goto LABEL_19;
    }
LABEL_22:
    if (v16 != -1)
    {
      int v22 = 0;
      atomic_compare_exchange_strong((atomic_uint *volatile)(v9 + 160 * v16 + 524), (unsigned int *)&v22, 0x22222222u);
      uint64_t v16 = v11;
      double v14 = v18;
      if (!v22) {
        goto LABEL_20;
      }
    }
    uint64_t v16 = v11;
    double v14 = v18;
LABEL_25:
    ++v11;
    v15 += 160;
  }
  while (v11 < *(unsigned int *)(a1 + 40));
  if ((a2 & 1) == 0 && v16 != -1)
  {
    int v23 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(v9 + 160 * v16 + 524), (unsigned int *)&v23, 0x22222222u);
    if (!v23)
    {
      *(unsigned char *)(v9 + 160 * v16 + 585) = 1;
      ++v12;
    }
  }
LABEL_32:
  os_unfair_lock_unlock(v10);
  return v12;
}

double std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, a2, a3, a4);
  if (*(_DWORD *)(*(void *)(a5 + 8) + 112) < *(_DWORD *)(*(void *)(a4 + 8) + 112))
  {
    *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)a4, (long long *)a5).n128_u64[0];
    if (*(_DWORD *)(*(void *)(a4 + 8) + 112) < *(_DWORD *)(*(void *)(a3 + 8) + 112))
    {
      *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)a3, (long long *)a4).n128_u64[0];
      if (*(_DWORD *)(*(void *)(a3 + 8) + 112) < *(_DWORD *)(*(void *)(a2 + 8) + 112))
      {
        *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)a2, (long long *)a3).n128_u64[0];
        if (*(_DWORD *)(*(void *)(a2 + 8) + 112) < *(_DWORD *)(*(void *)(a1 + 8) + 112))
        {
          *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)a1, (long long *)a2).n128_u64[0];
        }
      }
    }
  }
  return result;
}

double std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, a2, a3);
  if (*(_DWORD *)(*(void *)(a4 + 8) + 112) < *(_DWORD *)(*(void *)(a3 + 8) + 112))
  {
    *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)a3, (long long *)a4).n128_u64[0];
    if (*(_DWORD *)(*(void *)(a3 + 8) + 112) < *(_DWORD *)(*(void *)(a2 + 8) + 112))
    {
      *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)a2, (long long *)a3).n128_u64[0];
      if (*(_DWORD *)(*(void *)(a2 + 8) + 112) < *(_DWORD *)(*(void *)(a1 + 8) + 112))
      {
        *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)a1, (long long *)a2).n128_u64[0];
      }
    }
  }
  return result;
}

double std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1;
  unsigned int v6 = *(_DWORD *)(*(void *)(a2 + 8) + 112);
  unsigned int v7 = *(_DWORD *)(*(void *)(a3 + 8) + 112);
  if (v6 >= *(_DWORD *)(*(void *)(a1 + 8) + 112))
  {
    if (v7 >= v6) {
      return result;
    }
    *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)a2, (long long *)a3).n128_u64[0];
    if (*(_DWORD *)(*(void *)(a2 + 8) + 112) >= *(_DWORD *)(*(void *)(v5 + 8) + 112)) {
      return result;
    }
    a1 = v5;
    uint64_t v9 = (long long *)a2;
  }
  else
  {
    if (v7 >= v6)
    {
      *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)a1, (long long *)a2).n128_u64[0];
      if (*(_DWORD *)(*(void *)(a3 + 8) + 112) >= *(_DWORD *)(*(void *)(a2 + 8) + 112)) {
        return result;
      }
      a1 = a2;
    }
    uint64_t v9 = (long long *)a3;
  }

  *(void *)&double result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)a1, v9).n128_u64[0];
  return result;
}

uint64_t CAImageQueueGetWidth(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

os_log_t ___ZN2CA11Transaction25in_memory_signpost_handleEv_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreanimation", "Transaction");
  CA::Transaction::in_memory_signpost_handle(void)::handle = (uint64_t)result;
  return result;
}

void ___ZN2CA6Render15CompressedImage27new_image_with_texture_dataEP18CGImageTextureData_block_invoke(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a1[8] || !a1[9])
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      double v14 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v15 = a1[8];
        uint64_t v16 = a1[9];
        *(_DWORD *)long long buf = 134218240;
        uint64_t v21 = v15;
        __int16 v22 = 2048;
        uint64_t v23 = v16;
        _os_log_impl(&dword_184668000, v14, OS_LOG_TYPE_DEBUG, "Compressed texture has bogus dimensions %zu x %zu!\n", buf, 0x16u);
      }
    }
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
  }
  if (!*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
  {
    uint64_t v17 = a1[10];
    uint64_t v18 = *(void *)(a1[5] + 8);
    if (v17)
    {
      if (*(void *)(v18 + 24) != a5)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          uint64_t v19 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl(&dword_184668000, v19, OS_LOG_TYPE_DEBUG, "Compressed texture data base address is not consistent, bailing.", buf, 2u);
          }
        }
        *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
        return;
      }
    }
    else
    {
      *(void *)(v18 + 24) = a5;
      *(void *)(*(void *)(a1[6] + 8) + 24) = a6;
      uint64_t v17 = a1[10];
    }
    *(void *)(a1[11] + 8 * v17) = a7;
    *(void *)(a1[12] + 8 * a1[10]) = a8;
    *(void *)(a1[13] + 8 * a1[10]) = a4;
    ++*(void *)(*(void *)(a1[7] + 8) + 24);
  }
}

os_log_t ___ZN2CA11Transaction24bad_perf_signpost_handleEv_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreanimation", "Transaction.Stalls");
  CA::Transaction::bad_perf_signpost_handle(void)::handle = (uint64_t)result;
  return result;
}

uint64_t CA::Render::Layer::set_mask(CA::Render::Layer *this, atomic_uint *a2)
{
  uint64_t result = *((void *)this + 14);
  if ((atomic_uint *)result == a2) {
    return result;
  }
  if ((*((unsigned char *)this + 13) & 2) != 0)
  {
    *((void *)this + 14) = a2;
    return result;
  }
  if (result && atomic_fetch_add((atomic_uint *volatile)(result + 8), 0xFFFFFFFF) == 1) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
  }
  if (!a2)
  {
LABEL_15:
    *((void *)this + 14) = 0;
    return result;
  }
  if (!atomic_fetch_add(a2 + 2, 1u))
  {
    atomic_fetch_add(a2 + 2, 0xFFFFFFFF);
    goto LABEL_15;
  }
  *((void *)this + 14) = a2;
  a2[3] |= 0x1000u;
  uint64_t v5 = (CA::Render::Layer *)*((void *)this + 14);
  int v6 = *((_DWORD *)v5 + 3);
  if ((v6 & 0x1000) != 0 || (uint64_t result = CA::Render::Layer::is_containerable(v5, (const double *)a2), !result)) {
    unsigned int v7 = v6 & 0xFFFFF7FF;
  }
  else {
    unsigned int v7 = v6 | 0x800;
  }
  *((_DWORD *)v5 + 3) = v7;
  return result;
}

uint64_t CAML::ObjCContext::check_type(CAML::ObjCContext *this, const CAML::Type *a2, const CAML::Type *a3)
{
  if (a2 == a3) {
    return 1;
  }
  uint64_t v3 = (void *)*((void *)a2 + 3);
  if (!v3) {
    return 0;
  }
  uint64_t v5 = (void *)*((void *)a3 + 3);
  if (!v5 || v3 == v5) {
    return 1;
  }
  if ((*(unsigned int (**)(const CAML::Type *))(*(void *)a2 + 32))(a2))
  {
    int v8 = *(uint64_t (**)(const CAML::Type *))(*(void *)a3 + 32);
    return v8(a3);
  }
  else
  {
    return [v5 isSubclassOfClass:v3];
  }
}

uint64_t CAML::Type::is_numeric(CAML::Type *this)
{
  return 0;
}

uint64_t __CADeviceIsPhone_block_invoke()
{
  uint64_t result = MGGetSInt32Answer();
  CADeviceIsPhone::phone = result == 1;
  return result;
}

void malloc_zone_init(void)
{
  zone = malloc_create_zone(0, 0);
  malloc_zone = (uint64_t)zone;

  malloc_set_zone_name(zone, "QuartzCore");
}

dispatch_queue_t ___ZN2CA7DisplayL13display_queueEv_block_invoke()
{
  id v0 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
  dispatch_queue_t result = dispatch_queue_create("CA::Display::display_queue", v0);
  CA::Display::display_queue(void)::queue = (uint64_t)result;
  return result;
}

const char *__CADeviceIsSystemSessionClient_block_invoke()
{
  dispatch_queue_t result = getenv("CA_SYSTEM_SESSION_CLIENT");
  if (result)
  {
    dispatch_queue_t result = (const char *)atoi(result);
    if (result)
    {
      dispatch_queue_t result = (const char *)getuid();
      BOOL v1 = result == 0;
    }
    else
    {
      BOOL v1 = 0;
    }
    CADeviceIsSystemSessionClient::enabled = v1;
  }
  return result;
}

int *CAImageQueueSetEDRDeadline(int *result, double a2)
{
  uint64_t v2 = *((void *)result + 6);
  if (v2)
  {
    *(double *)(*(void *)(v2 + 24) + 128) = a2;
    __dmb(0xBu);
    return CAImageQueuePing_((uint64_t)result, 0, 0, 0.0, 0.0);
  }
  return result;
}

uint64_t CAML::cgcolor_end(CAML *this, CAML::Context *a2, CAML::State *a3, char *a4)
{
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  unint64_t v96 = a4;
  long long v97 = (char *)a3;
  *(_OWORD *)components = 0u;
  long long v100 = 0u;
  int v6 = (CAML *)&a4[(void)a3];
  CAML::trim_whitespace((const char **)&v97, &v96, (unint64_t *)a3);
  int v8 = (CGColorSpace *)*((void *)a2 + 8);
  if (v8)
  {
    CFTypeID v9 = CFGetTypeID(*((CFTypeRef *)a2 + 8));
    CFTypeID TypeID = CGColorSpaceGetTypeID();
    unint64_t v11 = v97;
    if (v9 == TypeID)
    {
      if (v96)
      {
        uint64_t v12 = *v97;
        if (*v97 < 0 || (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x400) == 0)
        {
          if (!strncmp(v97, "rgb(", 4uLL))
          {
            BOOL v30 = CAML::skip_whitespace((CAML *)(v11 + 4), v6, v13);
            if (v30 >= v6)
            {
              unsigned int v39 = 0;
LABEL_48:
              int v32 = *(unsigned __int8 *)v30;
            }
            else
            {
              unint64_t v31 = 0;
              while (1)
              {
                int v32 = *(unsigned __int8 *)v30;
                if (!*(unsigned char *)v30 || v32 == 41) {
                  break;
                }
                uint64_t v98 = v30;
                double v34 = x_strtod((const char *)v30, &v98, (const char *)v6);
                uint64_t v35 = v98;
                double v36 = (CAML *)((char *)v98 + 1);
                int v37 = *(unsigned __int8 *)v98;
                components[v31] = dbl_1849981F0[v37 == 37] * v34;
                if (v37 == 44) {
                  double v38 = v36;
                }
                else {
                  double v38 = v35;
                }
                BOOL v30 = CAML::skip_whitespace(v38, v6, v33);
                unsigned int v39 = v31 + 1;
                if (v31 <= 1)
                {
                  ++v31;
                  if (v30 < v6) {
                    continue;
                  }
                }
                goto LABEL_48;
              }
              unsigned int v39 = v31;
            }
            if (v32 == 41)
            {
              unint64_t v11 = (char *)v30 + 1;
              if (v39 <= 2) {
                memset_pattern16(&components[v39], &unk_184998850, 8 * (2 - v39) + 8);
              }
              goto LABEL_123;
            }
          }
          else
          {
            if (v12 != 35)
            {
              uint64_t v40 = 0;
              uint64_t v41 = "aqua";
              while (strcmp(v41, v11))
              {
                ++v40;
                v41 += 40;
                if (v40 == 16) {
                  goto LABEL_54;
                }
              }
              uint64_t v42 = &CAParseCSSColorDescription::colors[40 * v40];
              *(_OWORD *)components = *((_OWORD *)v42 + 1);
              *(void *)&long long v100 = *((void *)v42 + 4);
              v11 += strlen(&CAParseCSSColorDescription::colors[40 * v40]);
              goto LABEL_123;
            }
            size_t v14 = strlen(v11);
            if (v14 == 7)
            {
              int v60 = v11[1];
              unsigned int v61 = v60 - 48;
              unsigned int v62 = v60 - 97;
              if ((v60 - 65) >= 6) {
                unsigned int v63 = 0;
              }
              else {
                unsigned int v63 = v60 - 55;
              }
              unsigned int v64 = v60 - 87;
              if (v62 > 5) {
                unsigned int v64 = v63;
              }
              if (v61 < 0xA) {
                unsigned int v64 = v61;
              }
              int v65 = 16 * v64;
              int v66 = v11[2];
              unsigned int v67 = v66 - 48;
              unsigned int v68 = v66 - 97;
              if ((v66 - 65) >= 6) {
                unsigned int v69 = 0;
              }
              else {
                unsigned int v69 = v66 - 55;
              }
              unsigned int v70 = v66 - 87;
              if (v68 > 5) {
                unsigned int v70 = v69;
              }
              if (v67 < 0xA) {
                unsigned int v70 = v67;
              }
              components[0] = (double)(int)(v70 | v65) * 0.00392156863;
              int v71 = v11[3];
              unsigned int v72 = v71 - 48;
              unsigned int v73 = v71 - 97;
              if ((v71 - 65) >= 6) {
                unsigned int v74 = 0;
              }
              else {
                unsigned int v74 = v71 - 55;
              }
              unsigned int v75 = v71 - 87;
              if (v73 > 5) {
                unsigned int v75 = v74;
              }
              if (v72 < 0xA) {
                unsigned int v75 = v72;
              }
              int v76 = 16 * v75;
              int v77 = v11[4];
              unsigned int v78 = v77 - 48;
              unsigned int v79 = v77 - 97;
              if ((v77 - 65) >= 6) {
                unsigned int v80 = 0;
              }
              else {
                unsigned int v80 = v77 - 55;
              }
              unsigned int v81 = v77 - 87;
              if (v79 > 5) {
                unsigned int v81 = v80;
              }
              if (v78 < 0xA) {
                unsigned int v81 = v78;
              }
              components[1] = (double)(int)(v81 | v76) * 0.00392156863;
              int v82 = v11[5];
              unsigned int v83 = v82 - 48;
              unsigned int v84 = v82 - 97;
              if ((v82 - 65) >= 6) {
                unsigned int v85 = 0;
              }
              else {
                unsigned int v85 = v82 - 55;
              }
              unsigned int v86 = v82 - 87;
              if (v84 > 5) {
                unsigned int v86 = v85;
              }
              if (v83 < 0xA) {
                unsigned int v86 = v83;
              }
              int v87 = 16 * v86;
              int v88 = v11[6];
              unsigned int v89 = v88 - 48;
              unsigned int v90 = v88 - 97;
              if ((v88 - 65) >= 6) {
                unsigned int v91 = 0;
              }
              else {
                unsigned int v91 = v88 - 55;
              }
              unsigned int v92 = v88 - 87;
              if (v90 > 5) {
                unsigned int v92 = v91;
              }
              if (v89 < 0xA) {
                unsigned int v92 = v89;
              }
              *(double *)&long long v100 = (double)(int)(v92 | v87) * 0.00392156863;
              v11 += 7;
              goto LABEL_123;
            }
            if (v14 == 4)
            {
              int v15 = v11[1];
              unsigned int v16 = v15 - 48;
              unsigned int v17 = v15 - 97;
              if ((v15 - 65) >= 6) {
                int v18 = 0;
              }
              else {
                int v18 = v15 - 55;
              }
              int v19 = v15 - 87;
              if (v17 > 5) {
                int v19 = v18;
              }
              if (v16 < 0xA) {
                int v19 = v16;
              }
              components[0] = (double)v19 * 0.0666666667;
              int v20 = v11[2];
              unsigned int v21 = v20 - 48;
              unsigned int v22 = v20 - 97;
              if ((v20 - 65) >= 6) {
                int v23 = 0;
              }
              else {
                int v23 = v20 - 55;
              }
              int v24 = v20 - 87;
              if (v22 > 5) {
                int v24 = v23;
              }
              if (v21 < 0xA) {
                int v24 = v21;
              }
              components[1] = (double)v24 * 0.0666666667;
              int v25 = v11[3];
              unsigned int v26 = v25 - 48;
              unsigned int v27 = v25 - 97;
              if ((v25 - 65) >= 6) {
                int v28 = 0;
              }
              else {
                int v28 = v25 - 55;
              }
              int v29 = v25 - 87;
              if (v27 > 5) {
                int v29 = v28;
              }
              if (v26 < 0xA) {
                int v29 = v26;
              }
              *(double *)&long long v100 = (double)v29 * 0.0666666667;
              v11 += 4;
LABEL_123:
              long long v97 = v11;
              *((double *)&v100 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(float *)a2;
              double v59 = components;
              unint64_t v58 = v8;
LABEL_124:
              CGColorRef v93 = CGColorCreate(v58, v59);
              CAML::State::set_value(a2, v93);
              CGColorRelease(v93);
              return CAML::check_trailer((uint64_t)this, (CAML::Context *)v11, v6, v7);
            }
          }
        }
      }
LABEL_54:
      size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(v8);
      uint64_t v44 = NumberOfComponents << 32;
      MEMORY[0x1F4188790](NumberOfComponents);
      uint64_t v46 = (CGFloat *)((char *)&v95 - v45);
      bzero((char *)&v95 - v45, v47);
      LODWORD(v48) = 0;
      if (!*v11 || (NumberOfComponents & 0x80000000) != 0)
      {
        unsigned __int8 v49 = 0;
      }
      else
      {
        uint64_t v48 = 0;
        unsigned __int8 v49 = 0;
        uint64_t v95 = NumberOfComponents << 32;
        do
        {
          uint64_t v50 = v48;
          uint64_t v98 = (CAML *)v11;
          double v51 = x_strtod(v11, &v98, (const char *)v6);
          CFRange v53 = (const char *)CAML::skip_whitespace(v98, v6, v52);
          unint64_t v11 = (char *)v53;
          v46[v50] = v51;
          BOOL v54 = v51 < 0.0;
          if (v51 > 1.0) {
            BOOL v54 = 1;
          }
          v49 |= v54;
          uint64_t v48 = v50 + 1;
          if (*v53) {
            BOOL v55 = v50 < (int)NumberOfComponents;
          }
          else {
            BOOL v55 = 0;
          }
        }
        while (v55);
        long long v97 = (char *)v53;
        uint64_t v44 = v95;
      }
      if (v48 == NumberOfComponents)
      {
        v46[NumberOfComponents] = 1.0;
      }
      else if ((int)v48 <= (int)NumberOfComponents)
      {
        CAML::Context::error(this, "Incorrect number of color components (need %d)", NumberOfComponents);
      }
      if ((v49 & (CAML::cgcolor_end(CAML::Context *,CAML::State *,char *,unsigned long)::xr_srgb == 0)) == 1) {
        CAML::cgcolor_end(CAML::Context *,CAML::State *,char *,unsigned long)::xr_srgb = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBE8]);
      }
      CGColorSpaceRef v56 = (CGColorSpaceRef)CAML::cgcolor_end(CAML::Context *,CAML::State *,char *,unsigned long)::srgb;
      if (CAML::cgcolor_end(CAML::Context *,CAML::State *,char *,unsigned long)::srgb)
      {
        if (v49)
        {
LABEL_73:
          BOOL v57 = CFEqual(v8, v56) != 0;
LABEL_76:
          *(CGFloat *)((char *)v46 + (v44 >> 29)) = *(CGFloat *)((char *)v46 + (v44 >> 29)) * *(float *)a2;
          if (v57) {
            unint64_t v58 = (CGColorSpace *)CAML::cgcolor_end(CAML::Context *,CAML::State *,char *,unsigned long)::xr_srgb;
          }
          else {
            unint64_t v58 = v8;
          }
          double v59 = v46;
          goto LABEL_124;
        }
      }
      else
      {
        CGColorSpaceRef v56 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
        CAML::cgcolor_end(CAML::Context *,CAML::State *,char *,unsigned long)::srgb = (uint64_t)v56;
        if (v49) {
          goto LABEL_73;
        }
      }
      BOOL v57 = 0;
      goto LABEL_76;
    }
  }
  else
  {
    unint64_t v11 = v97;
  }
  return CAML::check_trailer((uint64_t)this, (CAML::Context *)v11, v6, v7);
}

void CAML::ObjCBool::end(CAML::ObjCBool *this, CAML::Context *a2, CAML::State *a3, char *a4, char *a5)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  unint64_t v11 = a5;
  __s1 = a4;
  CAML::trim_whitespace((const char **)&__s1, &v11, (unint64_t *)a3);
  int v6 = __s1;
  if (!strcmp(__s1, "true"))
  {
    CFTypeID v9 = (const void **)MEMORY[0x1E4F1CFD0];
  }
  else
  {
    if (strcmp(v6, "false"))
    {
      v13[0] = v6;
      double v7 = x_strtod(v6, v13, &v11[(void)v6]);
      int v8 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
      if (v7 != 0.0) {
        int v8 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      }
      CAML::State::set_value(a3, *v8);
      return;
    }
    CFTypeID v9 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  unint64_t v10 = *v9;

  CAML::State::set_value(a3, v10);
}

uint64_t CAML::trim_whitespace(const char **this, char **a2, unint64_t *a3)
{
  uint64_t v5 = *this;
  int v6 = *a2;
  for (uint64_t i = MEMORY[0x1E4F14390]; v6; --v6)
  {
    unsigned int v8 = *v5;
    if (!*v5) {
      break;
    }
    if ((v8 & 0x80000000) != 0)
    {
      if (!__maskrune(v8, 0x4000uLL)) {
        break;
      }
    }
    else if ((*(_DWORD *)(i + 4 * v8 + 60) & 0x4000) == 0)
    {
      break;
    }
    ++v5;
  }
  uint64_t result = strlen(v5);
  if (v6 && result >= 1)
  {
    unint64_t v10 = &v5[result - 1];
    do
    {
      unsigned int v11 = *v10;
      if ((v11 & 0x80000000) != 0)
      {
        uint64_t result = __maskrune(v11, 0x4000uLL);
        if (!result) {
          break;
        }
      }
      else
      {
        uint64_t result = *(_DWORD *)(i + 4 * v11 + 60) & 0x4000;
        if (!result) {
          break;
        }
      }
      const char *v10 = 0;
      if (!--v6) {
        break;
      }
    }
    while (v10-- > v5);
  }
  *this = v5;
  *a2 = v6;
  return result;
}

void CAML::ObjCCGPath::end(CAML::ObjCCGPath *this, CAML::Context *a2, CAML::State *a3, char *a4, uint64_t a5)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)unsigned int v27 = 0u;
  memset(&v26, 0, sizeof(v26));
  int v25 = a4;
  CFDictionaryRef Mutable = CGPathCreateMutable();
  if (a5 < 1) {
    goto LABEL_49;
  }
  int v10 = 0;
  unsigned int v11 = &a4[a5];
  double width = 0.0;
  int v13 = "Invalid number of numeric values in path: %s";
  size_t v14 = a4;
  double height = 0.0;
  double x = 0.0;
  double y = 0.0;
  while (1)
  {
    int v18 = *v14;
    if (v18 > 47)
    {
      if (v18 > 72)
      {
        switch(*v14)
        {
          case 'h':
            if (v10)
            {
              CAML::Context::error(a2, "Invalid number of arguments to 'h' path operator: %s");
              goto LABEL_49;
            }
            CGPathCloseSubpath(Mutable);
LABEL_41:
            ++v25;
            break;
          case 'i':
          case 'j':
          case 'k':
          case 'n':
          case 'o':
          case 'p':
          case 's':
          case 'u':
          case 'w':
          case 'x':
            goto LABEL_47;
          case 'l':
            if (v10 != 2)
            {
              CAML::Context::error(a2, "Invalid number of arguments to 'l' path operator: %s");
              goto LABEL_49;
            }
            double y = v26.origin.y;
            double x = v26.origin.x;
            CGPathAddLineToPoint(Mutable, 0, v26.origin.x, v26.origin.y);
            goto LABEL_26;
          case 'm':
            if (v10 != 2)
            {
              CAML::Context::error(a2, "Invalid number of arguments to 'm' path operator: %s");
              goto LABEL_49;
            }
            double y = v26.origin.y;
            double x = v26.origin.x;
            CGPathMoveToPoint(Mutable, 0, v26.origin.x, v26.origin.y);
LABEL_26:
            int v10 = 0;
            ++v25;
            double height = y;
            double width = x;
            break;
          case 'q':
            if (v10 != 4)
            {
              CAML::Context::error(a2, "Invalid number of arguments to 'q' path operator: %s");
              goto LABEL_49;
            }
            double y = v26.origin.y;
            double x = v26.origin.x;
            goto LABEL_34;
          case 'r':
            if (v14[1] != 101) {
              goto LABEL_47;
            }
            if (v10 != 4)
            {
              CAML::Context::error(a2, "Invalid number of arguments to 're' path operator: %s");
              goto LABEL_49;
            }
            double height = v26.size.height;
            double width = v26.size.width;
            CGPathAddRect(Mutable, 0, v26);
            int v10 = 0;
            break;
          case 't':
            if (v10 != 2)
            {
              CAML::Context::error(a2, "Invalid number of arguments to 't' path operator: %s");
              goto LABEL_49;
            }
            double x = -(x - width * 2.0);
            double y = -(y - height * 2.0);
LABEL_34:
            double height = v26.size.height;
            double width = v26.size.width;
            CGPathAddQuadCurveToPoint(Mutable, 0, x, y, v26.size.width, v26.size.height);
            goto LABEL_40;
          case 'v':
            if (v10 != 4)
            {
              CAML::Context::error(a2, "Invalid number of arguments to 'v' path operator: %s");
              goto LABEL_49;
            }
            double y = v26.origin.y;
            double x = v26.origin.x;
            CGSize size = v26.size;
            CGPathAddCurveToPoint(Mutable, 0, width, height, v26.origin.x, v26.origin.y, v26.size.width, v26.size.height);
            int v10 = 0;
            ++v25;
            double height = size.height;
            double width = size.width;
            break;
          case 'y':
            if (v10 != 4)
            {
              CAML::Context::error(a2, "Invalid number of arguments to 'y' path operator: %s");
              goto LABEL_49;
            }
            CGFloat v20 = v26.origin.y;
            CGFloat v19 = v26.origin.x;
            double height = v26.size.height;
            double width = v26.size.width;
            unsigned int v21 = Mutable;
            CGFloat v23 = v26.size.height;
            CGFloat v22 = v26.size.width;
            goto LABEL_39;
          default:
            if (v18 != 73)
            {
              if (v18 != 99) {
                goto LABEL_47;
              }
              if (v10 != 6)
              {
                CAML::Context::error(a2, "Invalid number of arguments to 'c' path operator: %s");
                goto LABEL_49;
              }
              CGFloat v20 = v26.origin.y;
              CGFloat v19 = v26.origin.x;
              double y = v26.size.height;
              double x = v26.size.width;
              double height = v27[1];
              double width = v27[0];
              unsigned int v21 = Mutable;
              CGFloat v23 = v26.size.height;
              CGFloat v22 = v26.size.width;
LABEL_39:
              CGPathAddCurveToPoint(v21, 0, v19, v20, v22, v23, width, height);
LABEL_40:
              int v10 = 0;
              goto LABEL_41;
            }
            if (v14[1] == 110 && v14[2] == 102) {
              goto LABEL_16;
            }
            break;
        }
      }
      else
      {
        if ((v18 - 48) >= 0xA) {
          goto LABEL_47;
        }
LABEL_16:
        if (v10 == 6) {
          goto LABEL_48;
        }
        *(&v26.origin.x + v10++) = x_strtod(v14, &v25, v11);
      }
      size_t v14 = v25;
      goto LABEL_7;
    }
    if (v18 > 0x2E) {
      goto LABEL_47;
    }
    if (((1 << v18) & 0x100003600) == 0) {
      break;
    }
    int v25 = ++v14;
LABEL_7:
    if (v14 >= v11) {
      goto LABEL_49;
    }
  }
  if (((1 << v18) & 0x680000000000) != 0) {
    goto LABEL_16;
  }
  if (*v14)
  {
LABEL_47:
    int v13 = "Invalid path operator: %s";
LABEL_48:
    CAML::Context::error(a2, v13, a4);
  }
LABEL_49:
  CAML::State::set_value(a3, Mutable);

  CGPathRelease(Mutable);
}

double CAML::parse_length(CAML *this, char *a2, char **a3, const char *a4)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  v17[0] = this;
  double v7 = x_strtod((const char *)this, v17, (const char *)a3);
  double v8 = v7;
  CFTypeID v9 = (CAML *)(v17[0] + 2);
  if (v17[0] + 2 >= (unint64_t)a3) {
    goto LABEL_11;
  }
  int v10 = *(char *)v17[0];
  if (v10 <= 108)
  {
    if (v10 != 99)
    {
      if (v10 == 105)
      {
        double v11 = v7 * 72.0;
        BOOL v12 = *(unsigned char *)(v17[0] + 1) == 110;
        goto LABEL_16;
      }
LABEL_11:
      CFTypeID v9 = (CAML *)v17[0];
      if (!a2) {
        return v8;
      }
      goto LABEL_20;
    }
    int v14 = *(unsigned __int8 *)(v17[0] + 1);
    double v15 = 28.346456;
LABEL_15:
    double v11 = v8 * v15;
    BOOL v12 = v14 == 109;
LABEL_16:
    if (v12) {
      double v8 = v11;
    }
    else {
      CFTypeID v9 = (CAML *)v17[0];
    }
    goto LABEL_19;
  }
  if (v10 == 109)
  {
    int v14 = *(unsigned __int8 *)(v17[0] + 1);
    double v15 = 2.8346456;
    goto LABEL_15;
  }
  if (v10 != 112) {
    goto LABEL_11;
  }
  int v13 = *(char *)(v17[0] + 1);
  if (v13 == 99)
  {
    double v8 = v7 * 12.0;
    if (!a2) {
      return v8;
    }
    goto LABEL_20;
  }
  if (v13 != 120 && v13 != 116) {
    goto LABEL_11;
  }
LABEL_19:
  if (a2) {
LABEL_20:
  }
    *(void *)a2 = CAML::skip_whitespace(v9, (CAML *)a3, v6);
  return v8;
}

double CAML::parse_real(CAML *this, char *a2, char **a3, const char *a4)
{
  __s1[1] = *(char **)MEMORY[0x1E4F143B8];
  __s1[0] = (char *)this;
  double v7 = x_strtod((const char *)this, __s1, (const char *)a3);
  double v8 = __s1[0];
  int v18 = (CAML *)__s1[0];
  switch(*__s1[0])
  {
    case 'c':
      if (__s1[0][1] == 109)
      {
        double v9 = 28.346456;
        goto LABEL_39;
      }
      goto LABEL_42;
    case 'd':
      if (!strncmp(__s1[0], "deg", 3uLL))
      {
        int v18 = (CAML *)(v8 + 3);
        double v13 = 0.0174532925;
        goto LABEL_16;
      }
      goto LABEL_42;
    case 'e':
    case 'f':
    case 'h':
    case 'j':
    case 'k':
    case 'l':
    case 'n':
    case 'o':
    case 'q':
      goto LABEL_6;
    case 'g':
      if (!strncmp(__s1[0], "grad", 4uLL))
      {
        int v18 = (CAML *)(v8 + 4);
        double v13 = 0.0157079633;
LABEL_16:
        double v7 = v7 * v13;
      }
      goto LABEL_42;
    case 'i':
      if (__s1[0][1] != 110) {
        goto LABEL_42;
      }
      double v9 = 72.0;
      goto LABEL_39;
    case 'm':
      if (__s1[0][1] != 109) {
        goto LABEL_42;
      }
      double v9 = 2.8346456;
      goto LABEL_39;
    case 'p':
      int v14 = __s1[0][1];
      if (v14 == 99)
      {
        double v9 = 12.0;
        goto LABEL_39;
      }
      if (v14 != 120 && v14 != 116) {
        goto LABEL_42;
      }
      goto LABEL_40;
    case 'r':
      if (!strncmp(__s1[0], "rad", 3uLL)) {
        goto LABEL_26;
      }
      goto LABEL_42;
    default:
      if (*__s1[0] == 37)
      {
        double v10 = 0.01;
LABEL_10:
        double v7 = v7 * v10;
LABEL_11:
        BOOL v12 = __s1[0] + 1;
LABEL_41:
        int v18 = (CAML *)v12;
        goto LABEL_42;
      }
LABEL_6:
      unsigned int v11 = *__s1[0];
      if (v11 > 0x6C)
      {
        if (v11 != 109)
        {
          if (v11 != 115) {
            goto LABEL_42;
          }
          goto LABEL_11;
        }
        int v16 = *((unsigned __int8 *)__s1[0] + 1);
        if (v16 == 115)
        {
          double v9 = 0.001;
LABEL_39:
          double v7 = v7 * v9;
LABEL_40:
          BOOL v12 = __s1[0] + 2;
          goto LABEL_41;
        }
        if (v16 == 105 && __s1[0][2] == 110)
        {
          double v7 = v7 * 60.0;
LABEL_26:
          BOOL v12 = v8 + 3;
          goto LABEL_41;
        }
      }
      else
      {
        if (v11 != 58)
        {
          if (v11 != 104) {
            goto LABEL_42;
          }
          double v10 = 3600.0;
          goto LABEL_10;
        }
        double v15 = x_strtod(__s1[0] + 1, &v18, (const char *)a3);
        if (*((unsigned char *)v18 + 1) == 58) {
          double v7 = x_strtod((const char *)v18 + 1, &v18, (const char *)a3) + (v15 + v7 * 60.0) * 60.0;
        }
        else {
          double v7 = v15 + v7 * 60.0;
        }
      }
LABEL_42:
      if (a2) {
        *(void *)a2 = CAML::skip_whitespace(v18, (CAML *)a3, v6);
      }
      return v7;
  }
}

double x_strtod(const char *a1, void *a2, const char *a3)
{
  v27[1] = *(const char **)MEMORY[0x1E4F143B8];
  v27[0] = a1;
  double v4 = 0.0;
  if (a1 >= a3) {
    goto LABEL_77;
  }
  int v5 = *(unsigned __int8 *)a1;
  if (v5 == 45)
  {
    v27[0] = ++a1;
    int v6 = 1;
  }
  else
  {
    int v6 = 0;
    if (v5 == 43) {
      v27[0] = ++a1;
    }
  }
  if (a1 >= a3) {
    goto LABEL_75;
  }
  int v7 = *(unsigned __int8 *)a1;
  if (a3 - a1 >= 3)
  {
    if (*(unsigned __int8 *)a1 <= 0x68u)
    {
      if (v7 != 73)
      {
        if (v7 != 78) {
          goto LABEL_27;
        }
LABEL_22:
        if ((*((unsigned __int8 *)a1 + 1) | 0x20) == 0x61 && (*((unsigned __int8 *)a1 + 2) | 0x20) == 0x6E)
        {
          if (a2) {
            *a2 = a1 + 3;
          }
          return NAN;
        }
        goto LABEL_27;
      }
      goto LABEL_14;
    }
    if (v7 == 110) {
      goto LABEL_22;
    }
    if (v7 == 105)
    {
LABEL_14:
      if ((*((unsigned __int8 *)a1 + 1) | 0x20) == 0x6E && (*((unsigned __int8 *)a1 + 2) | 0x20) == 0x66)
      {
        if (a2) {
          *a2 = a1 + 3;
        }
        if (v6) {
          return -INFINITY;
        }
        else {
          return INFINITY;
        }
      }
      if ((v7 | 0x20) != 0x6E) {
        goto LABEL_27;
      }
      goto LABEL_22;
    }
  }
LABEL_27:
  if (*a1) {
    BOOL v8 = v7 == 46;
  }
  else {
    BOOL v8 = 1;
  }
  int v10 = !v8 && (v7 & 0xFFFFFFDF) != 69;
  if (((v7 - 46) > 0x37 || ((1 << (v7 - 46)) & 0x80000000800001) == 0) && *a1)
  {
    uint64_t v20 = 0;
    unsigned int v11 = a3;
    while (a1[v20] - 48 <= 9)
    {
      if (a3 - a1 == ++v20) {
        goto LABEL_63;
      }
    }
    unsigned int v11 = &a1[v20];
LABEL_63:
    v27[0] = v11;
    unsigned int v21 = v11 - 1;
    double v4 = 0.0;
    if (v11 - 1 >= a1)
    {
      double v22 = 1.0;
      do
      {
        int v23 = *v21--;
        double v4 = v4 + v22 * (double)(v23 - 48);
        double v22 = v22 * 10.0;
      }
      while (v21 >= a1);
    }
    if (v11 >= a3) {
      goto LABEL_75;
    }
    int v7 = *(unsigned __int8 *)v11;
  }
  else
  {
    unsigned int v11 = a1;
  }
  if (v7 != 46) {
    goto LABEL_52;
  }
  unint64_t v12 = (unint64_t)(v11 + 1);
  if (v11 + 1 >= a3)
  {
    ++v11;
  }
  else
  {
    double v13 = &a3[-v12];
    ++v11;
    while (*(unsigned __int8 *)v11 - 48 <= 9)
    {
      ++v11;
      if (!--v13)
      {
        unsigned int v11 = a3;
        break;
      }
    }
  }
  v27[0] = v11;
  int v14 = v11 - 1;
  double v15 = 0.0;
  if ((unint64_t)(v11 - 1) >= v12)
  {
    do
    {
      int v16 = *v14--;
      double v15 = (double)(v16 - 48) + v15 * 0.1;
    }
    while ((unint64_t)v14 >= v12);
    double v15 = v15 * 0.1;
  }
  double v4 = v15 + v4;
  if (v11 < a3)
  {
    int v7 = *(unsigned __int8 *)v11;
    int v10 = 1;
LABEL_52:
    if (v10)
    {
      if ((v7 & 0xFFFFFFDF) == 0x45)
      {
        unsigned int v17 = v11 + 1;
        v27[0] = v11 + 1;
        if (v11 + 1 < a3)
        {
          int v18 = *(unsigned __int8 *)v17;
          if (v18 == 45)
          {
            unsigned int v17 = v11 + 2;
            v27[0] = v11 + 2;
            int v19 = 1;
          }
          else
          {
            int v19 = 0;
            if (v18 == 43)
            {
              unsigned int v17 = v11 + 2;
              v27[0] = v11 + 2;
            }
          }
          if (v17 < a3)
          {
            double v24 = parse_digit_sequence_integer(v17, v27, a3);
            if (v19) {
              double v24 = -v24;
            }
            double v25 = pow_10((int)v24);
            if (v6)
            {
              double v4 = -(v25 * v4);
              if (!a2) {
                return v4;
              }
            }
            else
            {
              double v4 = v25 * v4;
              if (!a2) {
                return v4;
              }
            }
            goto LABEL_78;
          }
        }
      }
    }
  }
LABEL_75:
  if (v6) {
    double v4 = -v4;
  }
LABEL_77:
  if (a2) {
LABEL_78:
  }
    *a2 = v27[0];
  return v4;
}

CAML *CAML::skip_whitespace(CAML *this, CAML *a2, const char *a3)
{
  uint64_t v3 = this;
  if (this < a2)
  {
    uint64_t v5 = a2 - this;
    uint64_t v6 = MEMORY[0x1E4F14390];
    while (1)
    {
      unsigned int v7 = *(char *)v3;
      if (!*(unsigned char *)v3) {
        break;
      }
      if ((v7 & 0x80000000) != 0)
      {
        if (!__maskrune(v7, 0x4000uLL)) {
          return v3;
        }
      }
      else if ((*(_DWORD *)(v6 + 4 * v7 + 60) & 0x4000) == 0)
      {
        return v3;
      }
      uint64_t v3 = (CAML *)((char *)v3 + 1);
      if (!--v5) {
        return a2;
      }
    }
  }
  return v3;
}

double pow_10(unsigned int a1)
{
  double result = 1.0;
  if ((int)a1 >= 1)
  {
    if (a1 < 0x21)
    {
      unsigned int v2 = a1;
    }
    else
    {
      do
      {
        double result = result * 1.0e32;
        unsigned int v2 = a1 - 32;
        BOOL v3 = a1 > 0x40;
        a1 -= 32;
      }
      while (v3);
    }
    unsigned int v4 = v2 - 1;
    uint64_t v5 = (double *)&pow_10(int)::up;
    return v5[v4] * result;
  }
  if ((a1 & 0x80000000) != 0)
  {
    if (a1 > 0xFFFFFFDF)
    {
      unsigned int v6 = a1;
    }
    else
    {
      do
      {
        double result = result * 1.0e-32;
        unsigned int v6 = a1 + 32;
        BOOL v7 = __CFADD__(a1, 64);
        a1 += 32;
      }
      while (!v7);
    }
    unsigned int v4 = ~v6;
    uint64_t v5 = (double *)&pow_10(int)::down;
    return v5[v4] * result;
  }
  return result;
}

double parse_digit_sequence_integer(const char *a1, const char **a2, const char *a3)
{
  BOOL v3 = a1;
  if (a1 < a3)
  {
    uint64_t v4 = a3 - a1;
    BOOL v3 = a1;
    while (*(unsigned __int8 *)v3 - 48 <= 9)
    {
      ++v3;
      if (!--v4)
      {
        BOOL v3 = a3;
        break;
      }
    }
  }
  if (a2) {
    *a2 = v3;
  }
  uint64_t v5 = v3 - 1;
  double result = 0.0;
  if (v5 >= a1)
  {
    double v7 = 1.0;
    do
    {
      int v8 = *v5--;
      double result = result + v7 * (double)(v8 - 48);
      double v7 = v7 * 10.0;
    }
    while (v5 >= a1);
  }
  return result;
}

void CA::Display::DisplayLinkItem::schedule(CA::Display::DisplayLinkItem *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6 = *((void *)this + 33);
  if (v6)
  {
    double v7 = *(__CFRunLoop **)(v6 + 16);
    if (v7 != a2) {
      [MEMORY[0x1E4F1CA00] raise:@"CADisplayLink", @"%@: already added to runloop %p, cannot also be added to %p", *((void *)this + 32), v7, a2 format];
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v8 = *((void *)this + 34);
  if (v8)
  {
    while (!CFEqual(*(CFTypeRef *)v8, a3))
    {
      uint64_t v8 = *(void *)(v8 + 8);
      if (!v8) {
        goto LABEL_7;
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 136));
  }
  else
  {
LABEL_7:
    Copdouble y = CFStringCreateCopy(0, a3);
    uint64_t v10 = *((void *)this + 34);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    unint64_t v12 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    *unint64_t v12 = Copy;
    v12[1] = v10;
    *((void *)this + 34) = v12;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 136));
    CA::Display::DisplayLinkItem::update_link(this, a2);
  }
}

uint64_t CAImageQueueGetLastUpdateHostTime(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  if (!v1) {
    return 0;
  }
  unsigned int v2 = *(int **)(v1 + 24);
  int v3 = -15;
  do
  {
    int v4 = *v2;
    __dmb(0xBu);
    uint64_t result = *((void *)v2 + 14);
    __dmb(0xBu);
  }
  while (v4 != v2[1] && v3++ != 0);
  return result;
}

float CAColorMatrixMakeColorSourceOver@<S0>(uint64_t a1@<X8>, float a2@<S0>, float a3@<S1>, float a4@<S2>, float a5@<S3>)
{
  *(float *)a1 = 1.0 - a5;
  *(void *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(float *)(a1 + 16) = a5 * a2;
  float result = a5 * a3;
  *(_DWORD *)(a1 + 2CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  *(float *)(a1 + 24) = 1.0 - a5;
  *(void *)(a1 + 28) = 0;
  *(float *)(a1 + 36) = a5 * a3;
  *(void *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  *(float *)(a1 + 48) = 1.0 - a5;
  *(_DWORD *)(a1 + 52) = 0;
  *(float *)(a1 + 56) = a5 * a4;
  *(void *)(a1 + 6CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(float *)(a1 + 72) = 1.0 - a5;
  *(float *)(a1 + 76) = a5;
  return result;
}

void CA::Display::Display::~Display(CFTypeRef *this)
{
  CA::Display::Display::~Display(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  CFTypeRef v2;
  CFTypeRef v3;
  CFTypeRef v4;
  void *v5;

  *this = &unk_1ED0303F0;
  CFRelease(this[11]);
  CFRelease(this[12]);
  unsigned int v2 = this[16];
  if (v2) {
    CFRelease(v2);
  }
  int v3 = this[17];
  if (v3) {
    CFRelease(v3);
  }
  int v4 = this[18];
  if (v4) {
    CFRelease(v4);
  }
  _Block_release(this[14]);
  _Block_release(this[91]);
  CA::MachPortUtil::ClientIPC::destroy((CA::MachPortUtil::ClientIPC *)(this + 92));
  CA::Display::DisplayTimingsControl::~DisplayTimingsControl((CA::Display::DisplayTimingsControl *)(this + 58));
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)(this + 25));
  std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(this[23]);
  uint64_t v5 = (void *)this[19];
  if (v5)
  {
    this[20] = v5;
    operator delete(v5);
  }
}

void sub_1847C7774(_Unwind_Exception *a1)
{
  CA::Display::DisplayTimingsControl::~DisplayTimingsControl((CA::Display::DisplayTimingsControl *)(v1 + 464));
  CA::WindowServer::Display::ModeSet::~ModeSet((CA::WindowServer::Display::ModeSet *)(v1 + 152));
  _Unwind_Resume(a1);
}

void CA::Display::DisplayTimingsControl::~DisplayTimingsControl(CA::Display::DisplayTimingsControl *this)
{
  *(void *)this = &unk_1ED0303D0;
  unsigned int v2 = (atomic_uint *)*((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
  }
  *((void *)this + 3) = 0;
  _Block_release(*((const void **)this + 23));
  int v3 = (void *)*((void *)this + 20);
  if (v3)
  {
    *((void *)this + 2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v3;
    operator delete(v3);
  }
  int v4 = (void *)*((void *)this + 14);
  if (v4)
  {
    *((void *)this + 15) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (atomic_uint *)*((void *)this + 2);
  if (v5)
  {
    if (atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
    }
  }
}

{
  uint64_t vars8;

  CA::Display::DisplayTimingsControl::~DisplayTimingsControl(this);

  JUMPOUT(0x185323DC0);
}

void sub_1847C7880(_Unwind_Exception *exception_object)
{
  int v3 = (void *)v1[20];
  if (v3)
  {
    v1[21] = v3;
    operator delete(v3);
  }
  int v4 = (void *)v1[14];
  if (v4)
  {
    v1[15] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (atomic_uint *)v1[2];
  if (v5)
  {
    if (atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t CA::Context::destroy(CA::Context *this)
{
  mach_msg_return_t v8;
  mach_error_t v9;
  NSObject *v10;
  mach_msg_size_t v11;
  char *v12;
  mach_port_name_t v13;
  CA::Render::Encoder::ObjectCache *v14;
  atomic_uint *v15;
  mach_msg_header_t msg;
  uint64_t v18;

  int v18 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  uint64_t v3 = *((void *)this + 12);
  if (v3)
  {
    CA::Layer::set_visible(*(CA::Layer **)(v3 + 16), 0);
    CFRelease(*((CFTypeRef *)this + 12));
    *((void *)this + 12) = 0;
  }
  if (!*(_DWORD *)this && (*((unsigned char *)this + 241) & 4) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
    if (CA::all_contexts(void)::contexts_data_initialized)
    {
      uint64_t v4 = qword_1EB2AC6F8;
      if (qword_1EB2AC6F8 != CA::all_contexts(void)::contexts_data)
      {
        uint64_t v5 = 0;
        unint64_t v6 = (qword_1EB2AC6F8 - CA::all_contexts(void)::contexts_data) >> 3;
        if (v6 <= 1) {
          unint64_t v6 = 1;
        }
        while (*(CA::Context **)(CA::all_contexts(void)::contexts_data + 8 * v5) != this)
        {
          if (v6 == ++v5) {
            goto LABEL_13;
          }
        }
        *(void *)(CA::all_contexts(void)::contexts_data + 8 * v5) = *(void *)(qword_1EB2AC6F8 - 8);
        qword_1EB2AC6F8 = v4 - 8;
      }
    }
    else
    {
      CA::all_contexts(void)::contexts_data = 0;
      qword_1EB2AC6F8 = 0;
      qword_1EB2AC700 = 0;
      CA::all_contexts(void)::contexts_data_initialized = 1;
    }
LABEL_13:
    *((unsigned char *)this + 241) |= 4u;
    --CA::Context::_context_count;
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
  }
  if (*((_DWORD *)this + 1))
  {
    mach_port_t v7 = *((_DWORD *)this + 40);
    if (v7)
    {
      msg.msgh_CGSize size = 0;
      msg.msgh_bits = 19;
      msg.msgh_remote_port = v7;
      msg.msgh_local_port = 0;
      *(void *)&msg.msgh_voucher_port = 0x9D0B00000000;
      if (MEMORY[0x1E4F14B18]) {
        voucher_mach_msg_set(&msg);
      }
      uint64_t v8 = mach_msg(&msg, 1, 0x18u, 0, 0, 0, 0);
      if (v8)
      {
        double v9 = v8;
        if (v8 == 268435459)
        {
          *((unsigned char *)this + 241) |= 2u;
        }
        else if (v8 == -81182719)
        {
          x_log_crash("Unentitled call to server!");
          abort();
        }
        if (x_log_hook_p())
        {
          mach_error_string(v9);
          x_log_();
        }
        else
        {
          uint64_t v10 = x_log_category_api;
          if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
          {
            unsigned int v11 = *((_DWORD *)this + 1);
            unint64_t v12 = mach_error_string(v9);
            msg.msgh_bits = 67109634;
            msg.msgh_CGSize size = v11;
            LOWORD(msg.msgh_remote_port) = 1024;
            *(mach_port_t *)((char *)&msg.msgh_remote_port + 2) = v9;
            HIWORD(msg.msgh_local_port) = 2080;
            *(void *)&msg.msgh_voucher_port = v12;
            _os_log_impl(&dword_184668000, v10, OS_LOG_TYPE_ERROR, "Failed to unregister client (client=0x%x) [0x%x %s]", (uint8_t *)&msg, 0x18u);
          }
        }
      }
      *((_DWORD *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
    }
  }
  double v13 = *((_DWORD *)this + 40);
  if (v13)
  {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v13);
    *((_DWORD *)this + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 41);
  int v14 = (CA::Render::Encoder::ObjectCache *)*((void *)this + 21);
  *((void *)this + 2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 41);
  if (v14) {
    CA::Render::Encoder::ObjectCache::unref(v14);
  }
  CA::MachPortUtil::ClientIPC::destroy((CA::Context *)((char *)this + 176));
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
  double v15 = (atomic_uint *)*((void *)this + 13);
  *((void *)this + 13) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
  if (v15)
  {
    if (CA::Render::Server::_thread)
    {
      if (!atomic_fetch_add(v15 + 2, 1u)) {
        atomic_fetch_add(v15 + 2, 0xFFFFFFFF);
      }
      CA::Render::Server::add_callback(0, (uint64_t)CA::Render::Context::schedule_destroy(void)::$_0::__invoke, (uint64_t)v15, 0.0);
    }
    else
    {
      CA::Render::Context::destroy((CA::Render::Context *)v15);
    }
    if (atomic_fetch_add(v15 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v15 + 16))(v15);
    }
  }
  *((unsigned char *)this + 241) |= 1u;
  return pthread_mutex_unlock(v2);
}

void sub_1847C7C8C(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::MachPortUtil::ClientIPC::destroy(CA::MachPortUtil::ClientIPC *this)
{
  unsigned int v2 = *((void *)this + 2);
  if (v2)
  {
    dispatch_activate(v2);
    dispatch_source_cancel(*((dispatch_source_t *)this + 2));
    dispatch_release(*((dispatch_object_t *)this + 2));
    *((void *)this + 2) = 0;
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    dispatch_release(v3);
    *((void *)this + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  }
  *(_DWORD *)this = 0;
}

__n128 __copy_helper_block_e8_40c41_ZTSN2CA3OGL12MetalContext8Pipeline4SpecE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 55) = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = result;
  return result;
}

void CA::Render::anonymous namespace'::Compressor::compress_(double **a1, double **a2, uint64_t a3)
{
  unint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  uint64_t v8 = *a2;
  mach_port_t v7 = a2[1];
  if (*a1 != v5 && v8 != v7)
  {
    int v11 = 0;
    do
    {
      double v12 = *v6;
      double v13 = *v8;
      if (*v6 - *v8 <= 0.0)
      {
        ++v6;
        int v14 = 1;
      }
      else
      {
        ++v8;
        int v14 = 2;
        double v12 = v13;
      }
      int v15 = v11 ^ v14;
      if (v11 == 1 || v15 == 1)
      {
        uint64_t v5 = a1[1];
        mach_port_t v7 = a2[1];
      }
      if (v6 == v5) {
        break;
      }
      int v11 = v15;
    }
    while (v8 != v7);
  }
  while (v6 != v5)
  {
    double v16 = *v6++;
    uint64_t v5 = a1[1];
  }
}

void CA::Render::anonymous namespace'::add_point_to_slices(uint64_t a1, double a2)
{
  uint64_t v3 = *(double **)a1;
  uint64_t v4 = *(double **)(a1 + 8);
  uint64_t v6 = (char *)v4 - (char *)v3;
  if (((v4 - v3) & 8) != 0)
  {
    double v7 = floor(a2);
    uint64_t v8 = v4 - 1;
    if (v7 <= *(v4 - 1)) {
      goto LABEL_19;
    }
  }
  else
  {
    double v7 = ceil(a2);
  }
  unint64_t v9 = *(void *)(a1 + 16);
  if ((unint64_t)v4 >= v9)
  {
    uint64_t v10 = v6 >> 3;
    unint64_t v11 = (v6 >> 3) + 1;
    if (v11 >> 61) {
      abort();
    }
    uint64_t v12 = v9 - (void)v3;
    if (v12 >> 2 > v11) {
      unint64_t v11 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v11)
    {
      unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v11);
      uint64_t v3 = *(double **)a1;
      uint64_t v4 = *(double **)(a1 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    int v14 = (double *)(v11 + 8 * v10);
    unint64_t v15 = v11 + 8 * v13;
    *int v14 = v7;
    uint64_t v8 = v14 + 1;
    while (v4 != v3)
    {
      uint64_t v16 = *((void *)v4-- - 1);
      *((void *)v14-- - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v16;
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v8;
    *(void *)(a1 + 16) = v15;
    if (v3) {
      operator delete(v3);
    }
  }
  else
  {
    *uint64_t v4 = v7;
    uint64_t v8 = v4 + 1;
  }
LABEL_19:
  *(void *)(a1 + 8) = v8;
}

const char *__CADeviceSupportsAPT_block_invoke()
{
  CADeviceSupportsAPT::supports_apt = MGGetBoolAnswer();
  __n128 result = getenv("CA_DISABLE_APT");
  if (result)
  {
    __n128 result = (const char *)atoi(result);
    if (result) {
      CADeviceSupportsAPT::supports_apt = 0;
    }
  }
  return result;
}

double **std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **>(double **a1, double **a2, double **a3, double **a4)
{
  __n128 result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **>(a1, a2, a3);
  unint64_t v9 = *a3;
  if (**a4 < **a3)
  {
    *a3 = *a4;
    *a4 = v9;
    uint64_t v10 = *a2;
    if (**a3 < **a2)
    {
      *a2 = *a3;
      *a3 = v10;
      unint64_t v11 = *a1;
      if (**a2 < **a1)
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

double **std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **>(double **result, double **a2, double **a3)
{
  uint64_t v3 = *a2;
  double v4 = **a2;
  uint64_t v5 = *result;
  double v6 = **result;
  double v7 = *a3;
  double v8 = **a3;
  if (v4 >= v6)
  {
    if (v8 < v4)
    {
      *a2 = v7;
      *a3 = v3;
      unint64_t v9 = *result;
      if (**a2 < **result)
      {
        *__n128 result = *a2;
        *a2 = v9;
      }
    }
  }
  else
  {
    if (v8 >= v4)
    {
      *__n128 result = v3;
      *a2 = v5;
      if (**a3 >= v6) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *__n128 result = v7;
    }
    *a3 = v5;
  }
  return result;
}

uint64_t ___ZN2CA12MachPortUtil9ClientIPC6createEPKc_block_invoke_2(uint64_t a1)
{
  return mach_port_destruct(*MEMORY[0x1E4F14960], *(_DWORD *)(a1 + 40), -1, *(void *)(a1 + 32));
}

uint64_t begin_layer(uint64_t a1)
{
  return a1;
}

void *std::__function::__value_func<BOOL ()(CA::OGL::Vertex *,unsigned int)>::~__value_func[abi:nn180100](void *a1)
{
  unsigned int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

dispatch_queue_t CA::DispatchGroup::init(CA::DispatchGroup *this)
{
  pthread_mutex_init(&CA::DispatchGroup::_mutex, 0);
  pthread_cond_init(&CA::DispatchGroup::_cond, 0);
  uint64_t v1 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  dispatch_queue_t result = dispatch_queue_create("CA DispatchGroup", v1);
  CA::DispatchGroup::_queue = (uint64_t)result;
  return result;
}

void CA::Display::DisplayLinkItem::unschedule(CA::Display::DisplayLinkItem *this, __CFRunLoop *a2, const __CFString *a3)
{
  if (*(__CFRunLoop **)(*((void *)this + 33) + 16) == a2)
  {
    double v6 = (pthread_mutex_t *)((char *)this + 136);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
    double v7 = (CFTypeRef *)*((void *)this + 34);
    if (v7)
    {
      double v8 = (uint64_t *)((char *)this + 272);
      while (1)
      {
        int v9 = CFEqual(*v7, a3);
        uint64_t v10 = *v8;
        if (v9) {
          break;
        }
        double v7 = *(CFTypeRef **)(v10 + 8);
        double v8 = (uint64_t *)(v10 + 8);
        if (!v7) {
          goto LABEL_6;
        }
      }
      CFRelease(*(CFTypeRef *)v10);
      *double v8 = x_list_remove_head((void *)*v8);
      pthread_mutex_unlock(v6);
      CA::Display::DisplayLinkItem::update_link(this, a2);
    }
    else
    {
LABEL_6:
      pthread_mutex_unlock(v6);
    }
  }
}

uint64_t x_list_remove_head(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = a1[1];
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, a1);
  return v2;
}

void CA::Render::ImageQueue::did_display(CA::Render::ImageQueue *this, int a2, double a3, double a4, double a5)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(*((void *)this + 2) + 24);
  if (!v5) {
    return;
  }
  uint64_t v7 = *((unsigned int *)this + 45);
  mach_port_name_t v8 = *((_DWORD *)this + 49);
  int v9 = *(_DWORD *)(v5 + 48);
  if (v8) {
    BOOL v10 = v9 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    mach_error_t v13 = _CACImageQueueDidPresent(*((_DWORD *)this + 49), 0, *(_DWORD *)(v5 + 48), a2, a3, a4, a5);
    if (v13)
    {
      mach_error_t v33 = v13;
      if (v13 == 268435460)
      {
        if (v8 != -1 && !mach_port_mod_refs(*MEMORY[0x1E4F14960], v8, 0, 1))
        {
          if (CA::MachPortUtil::reply_queue(void)::once != -1) {
            dispatch_once(&CA::MachPortUtil::reply_queue(void)::once, &__block_literal_global_9866);
          }
          *(void *)long long buf = MEMORY[0x1E4F143A8];
          *(void *)&uint8_t buf[8] = 0x40000000;
          *(void *)&uint8_t buf[16] = ___ZN2CA12MachPortUtil17call_with_timeoutIPFijjjjdddEJjjdddEEEijjbPKcT_DpT0__block_invoke;
          *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_120;
          uint64_t v43 = _CACImageQueueDidPresent;
          mach_port_name_t v48 = v8;
          int v49 = 2;
          int v50 = v9;
          int v51 = a2;
          double v44 = a3;
          double v45 = a4;
          double v46 = a5;
          char v52 = 0;
          size_t v47 = "IQDidPresent";
          dispatch_async((dispatch_queue_t)CA::MachPortUtil::reply_queue(void)::queue, buf);
          goto LABEL_7;
        }
        if (x_log_hook_p()) {
          goto LABEL_48;
        }
        uint64_t v38 = x_log_category_utilities;
        if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "IQDidPresent";
        uint64_t v35 = "%s failed to retain right";
        double v36 = v38;
        uint32_t v37 = 12;
      }
      else
      {
        if (x_log_hook_p())
        {
          mach_error_string(v33);
LABEL_48:
          x_log_();
          goto LABEL_7;
        }
        uint64_t v34 = x_log_category_utilities;
        if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "IQDidPresent";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v33;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = mach_error_string(v33);
        uint64_t v35 = "%s client message err=0x%x : %s";
        double v36 = v34;
        uint32_t v37 = 28;
      }
      _os_log_impl(&dword_184668000, v36, OS_LOG_TYPE_ERROR, v35, buf, v37);
    }
  }
LABEL_7:
  if (v7)
  {
    mach_port_name_t v39 = v8;
    char v40 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 160 * v7;
    do
    {
      uint64_t v16 = v5 + v14;
      if (*(_DWORD *)(v5 + v14 + 532))
      {
        unsigned int v17 = *(_DWORD *)(v5 + 40);
        unsigned int v18 = *(_DWORD *)(v16 + 564);
        unint64_t v19 = *(void *)(v16 + 504);
        if (v18 <= v17 && v19 == 0)
        {
          *(void *)(v16 + 504) = CAHostTimeWithTime(a3);
        }
        else
        {
          int v21 = *(_DWORD *)(v5 + v14 + 528);
          int v22 = *(_DWORD *)(v5 + 16);
          BOOL v23 = v19 >= CAHostTimeWithTime(a3) || v18 >= v17;
          if (v23 || *(double *)(v16 + 464) == 0.0)
          {
            unint64_t v25 = atomic_load((unint64_t *)(v5 + 8));
            uint64_t v24 = (v25 >> 53) & 1;
          }
          else
          {
            LODWORD(v24) = 1;
          }
          unint64_t v26 = atomic_load((unint64_t *)(v5 + 8));
          if (*(_DWORD *)(v5 + 32))
          {
            LODWORD(v27) = 0;
          }
          else
          {
            uint64_t v27 = (v26 >> 58) & 1;
            if (*(_DWORD *)(v16 + 564) >= v17) {
              LODWORD(v27) = 0;
            }
          }
          uint64_t v28 = v5 + v14;
          if (*(_DWORD *)(v5 + v14 + 524) == 286331153)
          {
            if (v21 - v22 < 0) {
              LODWORD(v24) = 1;
            }
            if (*(_DWORD *)(v28 + 552) - a2 < 0)
            {
              if (v24 | v27)
              {
                if ((~v26 & 0xC00000000000000) != 0
                  || (int v29 = IOSurfaceLookup(*(_DWORD *)(v5 + v14 + 520))) == 0
                  || (v30 = v29, int v31 = IOSurfaceIsInUse(v29), CFRelease(v30), !v31))
                {
                  int v32 = 286331153;
                  atomic_compare_exchange_strong((atomic_uint *volatile)(v28 + 524), (unsigned int *)&v32, 0x33333333u);
                  v40 |= v32 == 286331153;
                }
              }
            }
          }
        }
      }
      v14 += 160;
    }
    while (v15 != v14);
    if (v40)
    {
      CAShmemImageQueueCollectable(v5, v39, a2, 1);
    }
  }
}

uint64_t _CACImageQueueDidPresent(mach_port_t a1, mach_msg_timeout_t timeout, int a3, int a4, double a5, double a6, double a7)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = *MEMORY[0x1E4F14068];
  int v12 = a3;
  int v13 = a4;
  double v14 = a5;
  double v15 = a6;
  double v16 = a7;
  *(void *)&msg.msgh_bits = 19;
  msg.msgh_voucher_port = 0;
  msg.mach_msg_id_t msgh_id = 40405;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = 0;
  if (MEMORY[0x1E4F14B18]) {
    voucher_mach_msg_set(&msg);
  }
  uint64_t v8 = mach_msg(&msg, 17, 0x40u, 0, 0, timeout, 0);
  if ((v8 - 268435459) <= 1)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
    mach_msg_destroy(&msg);
  }
  return v8;
}

uint64_t CALayerGetRenderId(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 16);
    if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
      dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
    }
    if (v1) {
      return CA::Render::_render_id_slide + v1;
    }
    else {
      return 0;
    }
  }
  return result;
}

atomic_uint *CA::Render::Path::stroke(atomic_uint *result, double a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5)
  {
    CA::Render::Path::cg_path((CA::Render::Path *)result);
    dispatch_queue_t result = (atomic_uint *)CGPathCreateDashedPath();
    if (!result) {
      return result;
    }
    uint64_t v7 = (const CGPath *)result;
    if (a2 <= 0.0) {
      goto LABEL_5;
    }
    uint64_t StrokedPath = CGPathCreateStrokedPath();
    CGPathRelease(v7);
    uint64_t v7 = (const CGPath *)StrokedPath;
    if (StrokedPath) {
      goto LABEL_5;
    }
    return 0;
  }
  if (a2 > 0.0)
  {
    CA::Render::Path::cg_path((CA::Render::Path *)result);
    uint64_t v7 = (const CGPath *)CGPathCreateStrokedPath();
    if (v7)
    {
LABEL_5:
      int v9 = CA::Render::Path::new_path(v7, v6);
      CGPathRelease(v7);
      return (atomic_uint *)v9;
    }
    return 0;
  }
  if (result)
  {
    BOOL v10 = result + 2;
    if (!atomic_fetch_add(result + 2, 1u))
    {
      dispatch_queue_t result = 0;
      atomic_fetch_add(v10, 0xFFFFFFFF);
    }
  }
  return result;
}

uint64_t CA::Render::Path::cg_path(CA::Render::Path *this)
{
  if (!*((void *)this + 7))
  {
    CFDictionaryRef Mutable = CGPathCreateMutable();
    double v4 = (CGFloat *)*((void *)this + 4);
    uint64_t v3 = (unsigned char *)*((void *)this + 5);
    while (1)
    {
      switch(*v3)
      {
        case 0:
          CGPathCloseSubpath(Mutable);
          goto LABEL_9;
        case 1:
          CGPathMoveToPoint(Mutable, 0, *v4, v4[1]);
          goto LABEL_9;
        case 2:
          CGPathAddLineToPoint(Mutable, 0, *v4, v4[1]);
          goto LABEL_9;
        case 3:
          CGPathAddQuadCurveToPoint(Mutable, 0, *v4, v4[1], v4[2], v4[3]);
          goto LABEL_9;
        case 4:
          CGPathAddCurveToPoint(Mutable, 0, *v4, v4[1], v4[2], v4[3], v4[4], v4[5]);
          goto LABEL_9;
        case 5:
          uint64_t v6 = 0;
          atomic_compare_exchange_strong((atomic_ullong *volatile)this + 7, (unint64_t *)&v6, (unint64_t)Mutable);
          if (v6) {
            CGPathRelease(Mutable);
          }
          return *((void *)this + 7);
        default:
LABEL_9:
          int v5 = *v3++;
          v4 += 2 * CA::Render::path_counts[v5];
          break;
      }
    }
  }
  return *((void *)this + 7);
}

void CA::Render::init_memory_warnings_(CA::Render *this, void *a2)
{
  CA::Render::last_memory_warning = 0;
  global_queue = dispatch_get_global_queue(25, 0);
  CA::Render::memory_source = (uint64_t)dispatch_source_create(MEMORY[0x1E4F14468], 0, 2uLL, global_queue);
  dispatch_source_set_event_handler_f((dispatch_source_t)CA::Render::memory_source, (dispatch_function_t)CA::Render::memory_warning);
  uint64_t v3 = CA::Render::memory_source;

  dispatch_resume(v3);
}

uint64_t init_max_renderable_iosurface(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v1 = a1[1];
    uint64_t result = a1[2];
  }
  else
  {
    uint64_t result = MEMORY[0x185323680](*MEMORY[0x1E4F2EFE0]);
  }
  return result;
}

const char *CA::Transaction::init(CA::Transaction *this)
{
  pthread_key_init_np();
  uint64_t v1 = getenv("CA_DEBUG_TRANSACTIONS");
  if (v1) {
    CA::Transaction::_debug_transactions = atoi(v1) != 0;
  }
  uint64_t result = getenv("CA_ASSERT_MAIN_THREAD_TRANSACTIONS");
  if (result)
  {
    uint64_t result = (const char *)atoi(result);
    CA::Transaction::_assert_transactions = result != 0;
  }
  return result;
}

void CA::Render::Updater::ShadowOp::map_bounds(CA::Render::Updater::ShadowOp *this, CA::Render::Updater::LayerShapes *a2)
{
  *(double *)v5.i64 = CA::Render::Updater::ShadowOp::apply_shadow(this, (float64x2_t *)a2);
  if (*((void *)a2 + 8)) {
    CA::shape_map((CA::Shape **)a2 + 8, (CA::Shape **)this, (void (*)(CA::Rect *, void *))CA::Render::Updater::ShadowOp::map_bounds(CA::Render::Updater::LayerShapes &,BOOL)::$_0::__invoke, v4, v5);
  }
  uint64_t v6 = *((void *)a2 + 6);
  if (v6)
  {
    *(unsigned char *)(v6 + 16) = 1;
    uint64_t v7 = *(void **)(v6 + 8);
    if (v7)
    {
      CA::GenericRectTree<CA::Rect>::Pool::delete_node(*(void *)v6, v7);
      *(void *)(v6 + 8) = 0;
    }
  }
}

float64_t CA::Render::Updater::ShadowOp::apply_shadow(CA::Render::Updater::ShadowOp *this, float64x2_t *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  float64_t result = a2[1].f64[0];
  double v3 = a2[1].f64[1];
  if (result >= v3) {
    double v4 = a2[1].f64[1];
  }
  else {
    double v4 = a2[1].f64[0];
  }
  if (v4 > 0.0)
  {
    if (result <= v3) {
      float64_t result = a2[1].f64[1];
    }
    if (result < 1.79769313e308)
    {
      CA::Rect::unapply_transform(a2->f64, *((void *)this + 3));
      float64_t v7 = a2->f64[1];
      v24.f64[0] = a2->f64[0];
      v24.f64[1] = v7;
      float64_t v8 = a2[1].f64[1];
      v25.f64[0] = a2[1].f64[0];
      v25.f64[1] = v8;
      v22.f64[0] = v24.f64[0];
      v22.f64[1] = v7;
      v23.f64[0] = v25.f64[0];
      v23.f64[1] = v8;
      CA::BoundsImpl::inset(v24.f64, (float)-*((float *)this + 8), (float)-*((float *)this + 8));
      float64x2_t v9 = v25;
      float64x2_t v10 = vaddq_f64(v24, vcvtq_f64_f32(*(float32x2_t *)((char *)this + 36)));
      float64x2_t v11 = a2[1];
      int64x2_t v12 = vclezq_f64(v11);
      int64x2_t v13 = vclezq_f64(v25);
      int32x2_t v14 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v13, v12), (int8x16_t)vzip2q_s64(v13, v12))));
      if (v14.i8[4])
      {
        if (v14.i8[0])
        {
LABEL_14:
          float64x2_t v21 = v11;
          CA::BoundsImpl::inset(v22.f64, (float)-*((float *)this + 11), (float)-*((float *)this + 11));
          float64x2_t v16 = v23;
          int64x2_t v17 = vclezq_f64(v21);
          int64x2_t v18 = vclezq_f64(v23);
          int32x2_t v19 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v18, v17), (int8x16_t)vzip2q_s64(v18, v17))));
          if (v19.i8[4])
          {
            if ((v19.i8[0] & 1) == 0)
            {
              float64x2_t v20 = v22;
LABEL_19:
              *a2 = v20;
              a2[1] = v16;
            }
          }
          else if ((v19.i8[0] & 1) == 0)
          {
            float64x2_t v20 = vminnmq_f64(*a2, v22);
            float64x2_t v16 = vsubq_f64(vmaxnmq_f64(vaddq_f64(*a2, v21), vaddq_f64(v22, v23)), v20);
            goto LABEL_19;
          }
          return CA::Rect::apply_transform(a2->f64, *((void *)this + 3));
        }
      }
      else
      {
        if (v14.i8[0]) {
          goto LABEL_14;
        }
        float64x2_t v15 = vaddq_f64(v10, v25);
        float64x2_t v10 = vminnmq_f64(*a2, v10);
        float64x2_t v9 = vsubq_f64(vmaxnmq_f64(vaddq_f64(*a2, v11), v15), v10);
      }
      *a2 = v10;
      a2[1] = v9;
      float64x2_t v11 = v9;
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t __CADeviceUseCIF10_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  uint64_t result = MGGetBoolAnswer();
  CADeviceUseCIF10::enable_cif10 = result;
  if (result)
  {
    Boolean keyExistsAndHasValidFormat = 0;
    uint64_t result = CFPreferencesGetAppBooleanValue(@"CAEnableDeepFramebuffer", (CFStringRef)*MEMORY[0x1E4F1D3D8], &keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat) {
      CADeviceUseCIF10::enable_cif10 = result != 0;
    }
  }
  return result;
}

BOOL CAObject_automaticallyNotifiesObserversForKey(objc_class *a1, const __CFString *a2)
{
  v5[1] = *(uint64_t **)MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t *)classDescription(a1);
  double v3 = propertyInfoForKey(v5[0], a2, v5);
  if (!v3) {
    return 1;
  }
  if ((*((unsigned char *)v3 + 7) & 0x40) != 0) {
    return 0;
  }
  return *((unsigned char *)v5[0] + 136) != 0;
}

double initialize_time_scale(void)
{
  v2[1] = *(mach_timebase_info *)MEMORY[0x1E4F143B8];
  v2[0] = 0;
  if (mach_timebase_info(v2))
  {
    double v0 = *(double *)&time_scale;
  }
  else
  {
    double v0 = (double)v2[0].numer * 0.000000001 / (double)v2[0].denom;
    *(double *)&time_double scale = v0;
    timebase = v2[0].denom;
    timebase = v2[0].numer;
  }
  double result = 1.0 / v0;
  recip_time_double scale = *(void *)&result;
  return result;
}

uint64_t CAImageQueueGetTypeID()
{
  if (CAImageQueueGetTypeID::once != -1) {
    dispatch_once(&CAImageQueueGetTypeID::once, &__block_literal_global_14584);
  }
  return CAImageQueueGetTypeID::type;
}

void ___ZL36cons_CALayer_kCAValueRetainedPointerjb_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[1] = *(double *)MEMORY[0x1E4F143B8];
  double v3 = (const void *)*(unsigned int *)(a1 + 32);
  *(void *)&v4[0] = a3;
  CA::Layer::setter(*(CA::Transaction **)(a2 + 16), v3, (const CGAffineTransform *)2, v4);
}

void *CALayerGetDelegate(void *result)
{
  if (result)
  {
    uint64_t v1 = result[2];
    uint64_t v2 = (id *)(v1 + 128);
    if (*(unsigned char *)(v1 + 136)) {
      return objc_loadWeak(v2);
    }
    else {
      return *v2;
    }
  }
  return result;
}

unint64_t CAImageQueueGetFlags(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  if (v1) {
    return atomic_load((unint64_t *)(*(void *)(v1 + 24) + 8));
  }
  else {
    return 0;
  }
}

atomic_uint *__CASDeleteClient_block_invoke(uint64_t a1)
{
  double result = *(atomic_uint **)(a1 + 32);
  if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

void ___Z33CAHighFrameRateRestrictionEnabledv_block_invoke()
{
  if (CAPrefers60HzAPT(void)::once[0] != -1) {
    dispatch_once(CAPrefers60HzAPT(void)::once, &__block_literal_global_3);
  }
  int v0 = CAPrefers60HzAPT(void)::enabled;
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  unsigned int v1 = *(float *)&dword_1EB2ACB60;
  if (v0) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = v1 == 1;
  }
  char v4 = v2 && v1 != 2;
  CAHighFrameRateRestrictionEnabled(void)::enabled = v4;
}

void ___Z29CAFrameRateArbitrationEnabledv_block_invoke()
{
  if (enable_frame_rate_features(void)::once != -1) {
    dispatch_once(&enable_frame_rate_features(void)::once, &__block_literal_global_9);
  }
  int v0 = enable_frame_rate_features(void)::enabled;
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  unsigned int v1 = *(float *)&dword_1EB2ACB5C;
  if (v0) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = v1 == 1;
  }
  char v4 = v2 && v1 != 2;
  CAFrameRateArbitrationEnabled(void)::enabled = v4;
}

void CAImageQueueConsumeUnconsumed_(uint64_t a1, char a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2)
  {
    uint64_t v5 = *(void *)(v2 + 24);
    uint64_t v6 = (os_unfair_lock_s *)(a1 + 16);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
    if (*(_DWORD *)(a1 + 40))
    {
      unint64_t v7 = 0;
      uint64_t v8 = v5 + 524;
      do
      {
        if (*(_DWORD *)(v8 + 8) && ((a2 & 1) != 0 || *(_DWORD *)(v8 + 40) != *(_DWORD *)(v5 + 36)))
        {
          int v9 = 0;
          atomic_compare_exchange_strong((atomic_uint *volatile)v8, (unsigned int *)&v9, 0x22222222u);
          if (!v9) {
            *(unsigned char *)(v8 + 6CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 1;
          }
        }
        ++v7;
        v8 += 160;
      }
      while (v7 < *(unsigned int *)(a1 + 40));
    }
    os_unfair_lock_unlock(v6);
  }
}

uint64_t CAImageQueueGetHeight(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t CAImageQueueSetInterpolationCurve(uint64_t result, double a2, double a3, double a4, double a5)
{
  uint64_t v5 = *(double **)(*(void *)(result + 48) + 24);
  __dmb(0xBu);
  v5[53] = a2;
  v5[54] = a3;
  v5[55] = a4;
  v5[56] = a5;
  __dmb(0xBu);
  return result;
}

void sub_1847CA8F0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1847CAB14(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1847CAD74(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1847CAE64(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void layer_private_flush_async(_CAMetalLayerPrivate *a1)
{
  pthread_setspecific(collect_slot, a1);
  CAImageQueueCollect_(*((void *)a1 + 2), 1, 0);
  pthread_setspecific(collect_slot, 0);
  uint64_t v2 = (_CAMetalDrawablePrivate **)*((void *)a1 + 7);
  if (v2)
  {
    *((void *)a1 + 7) = 0;
    double v3 = v2;
    do
    {
      release_drawable(a1, *v3);
      double v3 = (_CAMetalDrawablePrivate **)v3[1];
    }
    while (v3);
    do
    {
      char v4 = (_CAMetalDrawablePrivate **)v2[1];
      free(v2);
      uint64_t v2 = v4;
    }
    while (v4);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1 + 2);
  layer_private_cleanup_callbacks(a1);

  os_unfair_lock_lock((os_unfair_lock_t)a1 + 2);
}

void sub_1847CAF2C(_Unwind_Exception *a1)
{
  os_unfair_lock_lock(v1);
  _Unwind_Resume(a1);
}

void layer_private_set_drawable_size_internal(_CAMetalLayerPrivate *a1, int a2, int a3)
{
  *((_DWORD *)a1 + 3CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = a2;
  *((_DWORD *)a1 + 3CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = a3;
  atomic_fetch_or((atomic_uint *volatile)a1 + 1, 1u);
  CAImageQueueSetSize(*((os_unfair_lock_s **)a1 + 2), *((_DWORD *)a1 + 30), *((_DWORD *)a1 + 31));
  if (MEMORY[0x1E4F62350]) {
    FPMetalLayerMarkSetSize();
  }
}

void CAImageQueueSetSize(os_unfair_lock_s *a1, uint32_t a2, uint32_t a3)
{
  if (a1[8]._os_unfair_lock_opaque != a2 || a1[9]._os_unfair_lock_opaque != a3)
  {
    os_unfair_lock_lock(a1 + 4);
    a1[8]._unsigned int os_unfair_lock_opaque = a2;
    a1[9]._unsigned int os_unfair_lock_opaque = a3;
    os_unfair_lock_unlock(a1 + 4);
  }
}

uint64_t ___ZN2CA6Render22cacftype_from_cfobjectEPKv_block_invoke()
{
  CA::Render::cacftype_from_cfobject(void const*)::cfTypeIds[0] = 0;
  *(void *)algn_1EB2ABBB8 = 0;
  qword_1EB2ABBC0 = CFStringGetTypeID();
  qword_1EB2ABBC8 = CFNumberGetTypeID();
  qword_1EB2ABBD0 = CFBooleanGetTypeID();
  qword_1EB2ABBD8 = CFDataGetTypeID();
  qword_1EB2ABBE0 = CFArrayGetTypeID();
  qword_1EB2ABBE8 = CFDictionaryGetTypeID();
  qword_1EB2ABBF0 = CGColorSpaceGetTypeID();
  qword_1EB2ABBF8 = CGImageGetTypeID();
  qword_1EB2ABC00 = CGColorGetTypeID();
  qword_1EB2ABC08 = IOSurfaceGetTypeID();
  qword_1EB2ABC18 = CGPathGetTypeID();
  id v0 = (id)objc_opt_new();
  CA::Render::cacftype_from_cfobject(void const*)::ns_object_type_id = CFGetTypeID(v0);
  uint64_t result = objc_opt_class();
  CA::Render::cacftype_from_cfobject(void const*)::ns_value_class = result;
  return result;
}

dispatch_queue_t ___ZN2CA12MachPortUtil11reply_queueEv_block_invoke()
{
  id v0 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
  dispatch_queue_t result = dispatch_queue_create("com.apple.coreanimation.CAMachPortUtilReplyQueue", v0);
  CA::MachPortUtil::reply_queue(void)::queue = (uint64_t)result;
  return result;
}

uint64_t __CADeviceSupportsOddQuantaFrameRates_block_invoke()
{
  uint64_t result = MGIsDeviceOneOfType();
  if (result)
  {
    uint64_t result = _os_feature_enabled_impl();
    CADeviceSupportsOddQuantaFrameRates::enabled = result;
  }
  return result;
}

os_log_t ___ZL20CAMetalLayerStallLogv_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreanimation", "CAMetalLayer.Stalls");
  CAMetalLayerStallLog(void)::log = (uint64_t)result;
  return result;
}

os_log_t ___ZL15CAMetalLayerLogv_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreanimation", "CAMetalLayer");
  CAMetalLayerLog(void)::log = (uint64_t)result;
  return result;
}

os_log_t ___ZL15CAImageQueueLogv_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreanimation", "CAImageQueue");
  CAImageQueueLog(void)::log = (uint64_t)result;
  return result;
}

uint64_t __CADeviceIsVirtualized_block_invoke()
{
  uint64_t result = MGGetSInt64Answer();
  CADeviceIsVirtualized::is_virtualized = result == 65024;
  return result;
}

void CAImageQueueUnregisterBuffer(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 200))
  {
    char v4 = (os_unfair_lock_s *)(a1 + 16);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
    uint64_t v5 = (CAImageQueueBuffer *)x_hash_table_remove(*(void *)(a1 + 200), a2);
    os_unfair_lock_unlock(v4);
    delete_buffer(a2, v5, (void *)a1);
  }
}

uint64_t ___ZN2CA10ScalerUtil14get_io_serviceEv_block_invoke()
{
  mach_port_t v0 = *MEMORY[0x1E4F2EEF0];
  CFDictionaryRef v1 = IOServiceMatching("AppleM2ScalerCSCDriver");
  uint64_t result = IOServiceGetMatchingService(v0, v1);
  CA::ScalerUtil::get_io_service(void)::scaler_service = result;
  if (!result)
  {
    CFDictionaryRef v3 = IOServiceMatching("AppleM2ScalerParavirtDriver");
    uint64_t result = IOServiceGetMatchingService(v0, v3);
    CA::ScalerUtil::get_io_service(void)::scaler_service = result;
  }
  return result;
}

void accel_init(void)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  mach_port_t v0 = getenv("CA_ACCEL_BACKING");
  if (v0)
  {
    accel_defined = 1;
    accel_enabled = atoi(v0) != 0;
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      CFDictionaryRef v1 = x_log_category_utilities;
      if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT))
      {
        if (accel_enabled) {
          uint64_t v2 = "";
        }
        else {
          uint64_t v2 = "non-";
        }
        *(_DWORD *)long long buf = 136315138;
        char v4 = v2;
        _os_log_impl(&dword_184668000, v1, OS_LOG_TYPE_DEFAULT, "CoreAnimation: forcing %saccelerated backing\n", buf, 0xCu);
      }
    }
  }
}

uint64_t anonymous namespace'::init_alignment(_anonymous_namespace_ *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  mach_port_t v1 = *MEMORY[0x1E4F2EEF0];
  CFDictionaryRef v2 = IOServiceMatching("AGXAccelerator");
  io_service_t MatchingService = IOServiceGetMatchingService(v1, v2);
  if (MatchingService)
  {
    io_object_t v4 = MatchingService;
    CFPropertdouble y = (const __CFNumber *)IORegistryEntryCreateCFProperty(MatchingService, @"BaseAddressAlignmentRequirement", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (CFProperty)
    {
      CFNumberRef v6 = CFProperty;
      unsigned int valuePtr = 0;
      CFNumberGetValue(CFProperty, kCFNumberSInt32Type, &valuePtr);
      CFRelease(v6);
    }
    IOObjectRelease(v4);
  }
    __assert_rtn("init_alignment", "CADeviceInfo.cpp", 112, "alignment_values[kCAAlignmentPropertyImageBytes] >= alignment_values[kCAAlignmentPropertyNeededImageBytes]");
    __assert_rtn("init_alignment", "CADeviceInfo.cpp", 114, "alignment_values[kCAAlignmentPropertyRowBytes] >= alignment_values[kCAAlignmentPropertyNeededRowBytes]");
}

__CFBundle *___ZL30wants_compositing_dependenciesv_block_invoke()
{
  uint64_t result = CFBundleGetMainBundle();
  if (result)
  {
    uint64_t result = CFBundleGetInfoDictionary(result);
    if (result)
    {
      uint64_t result = (__CFBundle *)CFDictionaryGetValue(result, @"CAMetalLayerWantsCompositingDependencies");
      if (result)
      {
        uint64_t result = (__CFBundle *)CA_CFBoolValue(result);
        wants_compositing_dependencies(void)::wants_compositing_dependencies = (char)result;
      }
    }
  }
  return result;
}

uint64_t __CADeviceUseVBL_block_invoke()
{
  mach_port_t v0 = getenv("CA_FORCE_TIMER");
  if (v0 && (uint64_t result = atoi(v0), result))
  {
    BOOL v2 = 1;
  }
  else
  {
    uint64_t result = MGGetSInt64Answer();
    BOOL v2 = result == 28672 || result == 32784;
  }
  CADeviceUseVBL::use_vbl = v2;
  return result;
}

_DWORD *_XCreateFencePort(_DWORD *result, uint64_t a2, unint64_t *a3)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    int v4 = -304;
    goto LABEL_7;
  }
  if (result[6] || result[7] <= 0x1Fu)
  {
    int v4 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v4;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return result;
  }
  *(_DWORD *)(a2 + 28) = 0;
  *(void *)(a2 + 32) = 0x11000000000000;
  *(void *)(a2 + 48) = 0;
  uint64_t result = (_DWORD *)CA::Render::Fence::create_fence_port((CA::Render::Fence *)(a2 + 28), (unsigned int *)(a2 + 48), a3);
  if ((result & 1) == 0)
  {
    int v4 = 5;
    goto LABEL_7;
  }
  *(void *)(a2 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *MEMORY[0x1E4F14068];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

BOOL CA::Render::Fence::create_fence_port(CA::Render::Fence *this, unsigned int *a2, unint64_t *a3)
{
  if (this) {
    *(_DWORD *)this = 0;
  }
  if (a2) {
    *(void *)a2 = 0;
  }
  if (!this) {
    return 0;
  }
  if (!CA::Render::Server::_thread || BYTE7(xmmword_1EB2ACC70) != 0) {
    return 0;
  }
  if (CA::Render::Fence::fence_info_once[0] != -1) {
    dispatch_once_f(CA::Render::Fence::fence_info_once, 0, (dispatch_function_t)CA::Render::Fence::fence_info_init);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Fence::_lock);
  fence = CA::Render::Fence::_create_fence(v7);
  BOOL v6 = fence != 0;
  if (fence)
  {
    *(_DWORD *)this = *((_DWORD *)fence + 4);
    if (a2) {
      *(void *)a2 = *fence;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Fence::_lock);
  return v6;
}

void *CA::Render::Fence::_create_fence(CA::Render::Fence *this)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  if (CA::Render::Fence::fence_info_once[0] != -1) {
    dispatch_once_f(CA::Render::Fence::fence_info_once, 0, (dispatch_function_t)CA::Render::Fence::fence_info_init);
  }
  if ((CA::Render::Fence::_name_counter + 1) > 1) {
    unsigned int v1 = CA::Render::Fence::_name_counter + 1;
  }
  else {
    unsigned int v1 = 1;
  }
  CA::Render::Fence::_name_unsigned int counter = v1;
  mach_port_context_t v2 = v1 | (unint64_t)((uint64_t)getpid() << 32);
  mach_port_name_t name = 0;
  *(_OWORD *)&options.uint64_t flags = xmmword_1849A8140;
  options.reserved[1] = 0;
  CFDictionaryRef v3 = (ipc_space_t *)MEMORY[0x1E4F14960];
  int v4 = 0;
  if (mach_port_construct(*MEMORY[0x1E4F14960], &options, v2, &name)) {
    return v4;
  }
  uint64_t v5 = mach_absolute_time();
  double v6 = CATimeWithHostTime(v5) + 10.0;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  int8x8_t prime = malloc_type_zone_malloc(malloc_zone, 0x18uLL, 0x8BB15036uLL);
  int v4 = prime;
  unint64_t v9 = name;
  *((_DWORD *)prime + 4) = name;
  *int8x8_t prime = v2;
  *((double *)prime + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v6;
  *((unsigned char *)prime + 2CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  uint64_t v10 = CA::Render::Fence::fences_by_port;
  unint64_t v11 = *(void *)(CA::Render::Fence::fences_by_port + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v13 = v9;
      if (v11 <= v9) {
        unint64_t v13 = v9 % v11;
      }
    }
    else
    {
      unint64_t v13 = (v11 - 1) & v9;
    }
    int32x2_t v14 = *(void **)(*(void *)CA::Render::Fence::fences_by_port + 8 * v13);
    if (v14)
    {
      float64x2_t v15 = (void *)*v14;
      if (*v14)
      {
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == v9)
          {
            if (*((_DWORD *)v15 + 4) == v9) {
              goto LABEL_80;
            }
          }
          else
          {
            if (v12.u32[0] > 1uLL)
            {
              if (v16 >= v11) {
                v16 %= v11;
              }
            }
            else
            {
              v16 &= v11 - 1;
            }
            if (v16 != v13) {
              break;
            }
          }
          float64x2_t v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
  else
  {
    unint64_t v13 = 0;
  }
  int8x8_t prime = operator new(0x20uLL);
  float64x2_t v15 = prime;
  *int8x8_t prime = 0;
  prime[1] = v9;
  *((_DWORD *)prime + 4) = v9;
  prime[3] = 0;
  float v17 = (float)(unint64_t)(*(void *)(v10 + 24) + 1);
  float v18 = *(float *)(v10 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    if (v22 == 1)
    {
      size_t v22 = 2;
    }
    else if ((v22 & (v22 - 1)) != 0)
    {
      int8x8_t prime = (void *)std::__next_prime(v22);
      size_t v22 = (size_t)prime;
    }
    unint64_t v11 = *(void *)(v10 + 8);
    if (v22 > v11) {
      goto LABEL_36;
    }
    if (v22 < v11)
    {
      int8x8_t prime = (void *)vcvtps_u32_f32((float)*(unint64_t *)(v10 + 24) / *(float *)(v10 + 32));
      if (v11 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        int8x8_t prime = (void *)std::__next_prime((size_t)prime);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz((unint64_t)prime - 1);
        if ((unint64_t)prime >= 2) {
          int8x8_t prime = (void *)v29;
        }
      }
      if (v22 <= (unint64_t)prime) {
        size_t v22 = (size_t)prime;
      }
      if (v22 >= v11)
      {
        unint64_t v11 = *(void *)(v10 + 8);
      }
      else
      {
        if (v22)
        {
LABEL_36:
          if (v22 >> 61) {
            goto LABEL_173;
          }
          float64x2_t v23 = operator new(8 * v22);
          int8x8_t prime = *(void **)v10;
          *(void *)uint64_t v10 = v23;
          if (prime) {
            operator delete(prime);
          }
          uint64_t v24 = 0;
          *(void *)(v10 + 8) = v22;
          do
            *(void *)(*(void *)v10 + 8 * v24++) = 0;
          while (v22 != v24);
          float64x2_t v25 = *(void **)(v10 + 16);
          if (v25)
          {
            size_t v26 = v25[1];
            uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v22);
            v27.i16[0] = vaddlv_u8(v27);
            if (v27.u32[0] > 1uLL)
            {
              if (v26 >= v22) {
                v26 %= v22;
              }
            }
            else
            {
              v26 &= v22 - 1;
            }
            *(void *)(*(void *)v10 + 8 * v26) = v10 + 16;
            BOOL v30 = (void *)*v25;
            if (*v25)
            {
              do
              {
                size_t v31 = v30[1];
                if (v27.u32[0] > 1uLL)
                {
                  if (v31 >= v22) {
                    v31 %= v22;
                  }
                }
                else
                {
                  v31 &= v22 - 1;
                }
                if (v31 != v26)
                {
                  if (!*(void *)(*(void *)v10 + 8 * v31))
                  {
                    *(void *)(*(void *)v10 + 8 * v3CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v25;
                    goto LABEL_61;
                  }
                  *float64x2_t v25 = *v30;
                  void *v30 = **(void **)(*(void *)v10 + 8 * v31);
                  **(void **)(*(void *)v10 + 8 * v3CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v30;
                  BOOL v30 = v25;
                }
                size_t v31 = v26;
LABEL_61:
                float64x2_t v25 = v30;
                BOOL v30 = (void *)*v30;
                size_t v26 = v31;
              }
              while (v30);
            }
          }
          unint64_t v11 = v22;
          goto LABEL_65;
        }
        int8x8_t prime = *(void **)v10;
        *(void *)uint64_t v10 = 0;
        if (prime) {
          operator delete(prime);
        }
        unint64_t v11 = 0;
        *(void *)(v10 + 8) = 0;
      }
    }
LABEL_65:
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v11 <= v9) {
        unint64_t v13 = v9 % v11;
      }
      else {
        unint64_t v13 = v9;
      }
    }
    else
    {
      unint64_t v13 = (v11 - 1) & v9;
    }
  }
  int v32 = *(void **)v10;
  mach_error_t v33 = *(void **)(*(void *)v10 + 8 * v13);
  if (v33)
  {
    *float64x2_t v15 = *v33;
LABEL_78:
    void *v33 = v15;
    goto LABEL_79;
  }
  *float64x2_t v15 = *(void *)(v10 + 16);
  *(void *)(v10 + 16) = v15;
  v32[v13] = v10 + 16;
  if (*v15)
  {
    unint64_t v34 = *(void *)(*v15 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v34 >= v11) {
        v34 %= v11;
      }
    }
    else
    {
      v34 &= v11 - 1;
    }
    mach_error_t v33 = (void *)(*(void *)v10 + 8 * v34);
    goto LABEL_78;
  }
LABEL_79:
  ++*(void *)(v10 + 24);
LABEL_80:
  v15[3] = v4;
  uint64_t v35 = CA::Render::Fence::fences_by_name;
  unint64_t v36 = *(void *)(CA::Render::Fence::fences_by_name + 8);
  if (v36)
  {
    uint8x8_t v37 = (uint8x8_t)vcnt_s8((int8x8_t)v36);
    v37.i16[0] = vaddlv_u8(v37);
    if (v37.u32[0] > 1uLL)
    {
      mach_port_context_t v38 = v2;
      if (v2 >= v36) {
        mach_port_context_t v38 = v2 % v36;
      }
    }
    else
    {
      mach_port_context_t v38 = (v36 - 1) & v2;
    }
    mach_port_name_t v39 = *(void **)(*(void *)CA::Render::Fence::fences_by_name + 8 * v38);
    if (v39)
    {
      char v40 = (void *)*v39;
      if (*v39)
      {
        do
        {
          unint64_t v41 = v40[1];
          if (v41 == v2)
          {
            if (v40[2] == v2) {
              goto LABEL_153;
            }
          }
          else
          {
            if (v37.u32[0] > 1uLL)
            {
              if (v41 >= v36) {
                v41 %= v36;
              }
            }
            else
            {
              v41 &= v36 - 1;
            }
            if (v41 != v38) {
              break;
            }
          }
          char v40 = (void *)*v40;
        }
        while (v40);
      }
    }
  }
  else
  {
    mach_port_context_t v38 = 0;
  }
  int8x8_t prime = operator new(0x20uLL);
  char v40 = prime;
  *int8x8_t prime = 0;
  prime[1] = v2;
  prime[2] = v2;
  prime[3] = 0;
  float v42 = (float)(unint64_t)(*(void *)(v35 + 24) + 1);
  float v43 = *(float *)(v35 + 32);
  if (!v36 || (float)(v43 * (float)v36) < v42)
  {
    BOOL v44 = 1;
    if (v36 >= 3) {
      BOOL v44 = (v36 & (v36 - 1)) != 0;
    }
    unint64_t v45 = v44 | (2 * v36);
    unint64_t v46 = vcvtps_u32_f32(v42 / v43);
    if (v45 <= v46) {
      size_t v47 = v46;
    }
    else {
      size_t v47 = v45;
    }
    if (v47 == 1)
    {
      size_t v47 = 2;
    }
    else if ((v47 & (v47 - 1)) != 0)
    {
      int8x8_t prime = (void *)std::__next_prime(v47);
      size_t v47 = (size_t)prime;
      unint64_t v36 = *(void *)(v35 + 8);
    }
    if (v47 > v36)
    {
LABEL_109:
      if (!(v47 >> 61))
      {
        mach_port_name_t v48 = operator new(8 * v47);
        int8x8_t prime = *(void **)v35;
        *(void *)uint64_t v35 = v48;
        if (prime) {
          operator delete(prime);
        }
        uint64_t v49 = 0;
        *(void *)(v35 + 8) = v47;
        do
          *(void *)(*(void *)v35 + 8 * v49++) = 0;
        while (v47 != v49);
        int v50 = *(void **)(v35 + 16);
        if (v50)
        {
          size_t v51 = v50[1];
          uint8x8_t v52 = (uint8x8_t)vcnt_s8((int8x8_t)v47);
          v52.i16[0] = vaddlv_u8(v52);
          if (v52.u32[0] > 1uLL)
          {
            if (v51 >= v47) {
              v51 %= v47;
            }
          }
          else
          {
            v51 &= v47 - 1;
          }
          *(void *)(*(void *)v35 + 8 * v5CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v35 + 16;
          BOOL v55 = (void *)*v50;
          if (*v50)
          {
            do
            {
              size_t v56 = v55[1];
              if (v52.u32[0] > 1uLL)
              {
                if (v56 >= v47) {
                  v56 %= v47;
                }
              }
              else
              {
                v56 &= v47 - 1;
              }
              if (v56 != v51)
              {
                if (!*(void *)(*(void *)v35 + 8 * v56))
                {
                  *(void *)(*(void *)v35 + 8 * v56) = v50;
                  goto LABEL_134;
                }
                *int v50 = *v55;
                *BOOL v55 = **(void **)(*(void *)v35 + 8 * v56);
                **(void **)(*(void *)v35 + 8 * v56) = v55;
                BOOL v55 = v50;
              }
              size_t v56 = v51;
LABEL_134:
              int v50 = v55;
              BOOL v55 = (void *)*v55;
              size_t v51 = v56;
            }
            while (v55);
          }
        }
        unint64_t v36 = v47;
        goto LABEL_138;
      }
LABEL_173:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    if (v47 < v36)
    {
      int8x8_t prime = (void *)vcvtps_u32_f32((float)*(unint64_t *)(v35 + 24) / *(float *)(v35 + 32));
      if (v36 < 3 || (uint8x8_t v53 = (uint8x8_t)vcnt_s8((int8x8_t)v36), v53.i16[0] = vaddlv_u8(v53), v53.u32[0] > 1uLL))
      {
        int8x8_t prime = (void *)std::__next_prime((size_t)prime);
      }
      else
      {
        uint64_t v54 = 1 << -(char)__clz((unint64_t)prime - 1);
        if ((unint64_t)prime >= 2) {
          int8x8_t prime = (void *)v54;
        }
      }
      if (v47 <= (unint64_t)prime) {
        size_t v47 = (size_t)prime;
      }
      if (v47 >= v36)
      {
        unint64_t v36 = *(void *)(v35 + 8);
      }
      else
      {
        if (v47) {
          goto LABEL_109;
        }
        int8x8_t prime = *(void **)v35;
        *(void *)uint64_t v35 = 0;
        if (prime) {
          operator delete(prime);
        }
        unint64_t v36 = 0;
        *(void *)(v35 + 8) = 0;
      }
    }
LABEL_138:
    if ((v36 & (v36 - 1)) != 0)
    {
      if (v2 >= v36) {
        mach_port_context_t v38 = v2 % v36;
      }
      else {
        mach_port_context_t v38 = v2;
      }
    }
    else
    {
      mach_port_context_t v38 = (v36 - 1) & v2;
    }
  }
  BOOL v57 = *(void **)v35;
  unint64_t v58 = *(void **)(*(void *)v35 + 8 * v38);
  if (v58)
  {
    *char v40 = *v58;
  }
  else
  {
    uint64_t v59 = *(void *)(v35 + 16);
    *char v40 = v59;
    *(void *)(v35 + 16) = v40;
    v57[v38] = v35 + 16;
    if (!v59) {
      goto LABEL_152;
    }
    unint64_t v60 = *(void *)(v59 + 8);
    if ((v36 & (v36 - 1)) != 0)
    {
      if (v60 >= v36) {
        v60 %= v36;
      }
    }
    else
    {
      v60 &= v36 - 1;
    }
    unint64_t v58 = (void *)(*(void *)v35 + 8 * v60);
  }
  void *v58 = v40;
LABEL_152:
  ++*(void *)(v35 + 24);
LABEL_153:
  v40[3] = v4;
  mach_port_t previous = 0;
  ipc_space_t v61 = *v3;
  mach_port_name_t v62 = name;
  mach_port_t v63 = CA::Render::Server::notify_port((CA::Render::Server *)prime);
  mach_port_request_notification(v61, v62, 70, 0, v63, 0x15u, &previous);
  kdebug_trace();
  ht_fence_start();
  CA::Render::Server::add_callback(3, (uint64_t)CA::Render::Fence::ftimeout_callback, 0, v6);
  return v4;
}

BOOL __CADeviceSupportsFilmGrain_block_invoke(uint64_t a1, const __CFString *a2)
{
  BOOL result = CA::ScalerUtil::has_capability((CA::ScalerUtil *)@"IOSurfaceAcceleratorCapabilitiesFilmGrain", a2);
  CADeviceSupportsFilmGrain::has_capabilitdouble y = result;
  return result;
}

BOOL CA::ScalerUtil::has_capability(CA::ScalerUtil *this, const __CFString *a2)
{
  if (CA::ScalerUtil::get_io_service(void)::once != -1) {
    dispatch_once(&CA::ScalerUtil::get_io_service(void)::once, &__block_literal_global_77);
  }
  if (!CA::ScalerUtil::get_io_service(void)::scaler_service) {
    return 0;
  }
  CFDictionaryRef v3 = (const __CFDictionary *)IORegistryEntrySearchCFProperty(CA::ScalerUtil::get_io_service(void)::scaler_service, "IOService", @"IOSurfaceAcceleratorCapabilitiesDict", 0, 0);
  if (!v3) {
    return 0;
  }
  CFDictionaryRef v4 = v3;
  CFTypeID v5 = CFGetTypeID(v3);
  BOOL v7 = v5 == CFDictionaryGetTypeID() && (Value = CFDictionaryGetValue(v4, this)) != 0 && CA_CFBoolValue(Value);
  CFRelease(v4);
  return v7;
}

uint64_t CA::OGL::new_metal_context(void *a1, void *a2, int a3, int a4, int a5, __CFString *a6)
{
  uint64_t v142 = *MEMORY[0x1E4F143B8];
  uint8x8_t v12 = (void *)MEMORY[0x185324A30]();
  unint64_t v13 = (void *)MEMORY[0x185324A30]();
  if (CA::_root_queue_once[0] != -1) {
    dispatch_once(CA::_root_queue_once, &__block_literal_global_23119);
  }
  int32x2_t v14 = CA::_root_queue;
  if (a2)
  {
    id v15 = a2;
  }
  else
  {
    unint64_t v16 = (void *)[a1 newCommandQueue];
    id v15 = v16;
    if (a6) {
      float v17 = a6;
    }
    else {
      float v17 = @"com.apple.coreanimation.command-queue";
    }
    [v16 setLabel:v17];
    if (v14)
    {
      int v18 = a5;
      BOOL v19 = v13;
      unint64_t v20 = dispatch_queue_create_with_target_V2("com.apple.coreanimation.mtl_submission", 0, v14);
      unint64_t v21 = dispatch_queue_create_with_target_V2("com.apple.coreanimation.mtl_completion", 0, v14);
      [v15 setSubmissionQueue:v20];
      [v15 setCompletionQueue:v21];
      dispatch_release(v20);
      dispatch_release(v21);
      unint64_t v13 = v19;
      a5 = v18;
    }
  }
  if (!v15)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      int v32 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_184668000, v32, OS_LOG_TYPE_ERROR, "Failed to create MTLCommandQueue\n", buf, 2u);
      }
    }
    goto LABEL_28;
  }
  if ((void *)[v15 device] != a1)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      BOOL v30 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_184668000, v30, OS_LOG_TYPE_ERROR, "Mismatched MTLCommandQueue and MTLDevice\n", buf, 2u);
      }
    }

LABEL_28:
    uint64_t v24 = 0;
    goto LABEL_29;
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  float64x2_t v23 = (CA::OGL::Context *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x1010uLL, 0x743898A5uLL);
  uint64_t v24 = (uint64_t)v23;
  if (!v23)
  {
LABEL_29:
    if (a5)
    {
      if (v24)
      {
        [*(id *)(v24 + 2960) setGPUPriority:qword_18499CF80[a5 - 1]];
        *(_DWORD *)(v24 + 3096) = a5;
      }
    }
    return v24;
  }
  int v132 = a5;
  uint64_t v134 = v12;
  CA::OGL::Context::Context(v23);
  *(void *)uint64_t v24 = &unk_1ED02AF38;
  *(_OWORD *)(v24 + 1864) = 0u;
  *(_OWORD *)(v24 + 188CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0u;
  *(_DWORD *)(v24 + 1896) = 1065353216;
  pthread_mutex_init((pthread_mutex_t *)(v24 + 1904), 0);
  *(_OWORD *)(v24 + 1976) = 0u;
  *(_OWORD *)(v24 + 1992) = 0u;
  *(_DWORD *)(v24 + 2008) = 1065353216;
  uint64_t v25 = pthread_mutex_init((pthread_mutex_t *)(v24 + 2016), 0);
  *(_OWORD *)(v24 + 2088) = 0u;
  *(_OWORD *)(v24 + 2104) = 0u;
  *(_DWORD *)(v24 + 212CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 1065353216;
  *(void *)(v24 + 2144) = 0;
  *(unsigned char *)(v24 + 2152) = 0;
  *(_OWORD *)(v24 + 2608) = 0u;
  *(_OWORD *)(v24 + 2624) = 0u;
  *(_DWORD *)(v24 + 264CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 1065353216;
  *(_DWORD *)(v24 + 268CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  *(_OWORD *)(v24 + 2744) = 0u;
  *(_OWORD *)(v24 + 276CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0u;
  *(_DWORD *)(v24 + 2776) = 1065353216;
  *(_DWORD *)(v24 + 2792) = 0;
  *(_DWORD *)(v24 + 2808) = 0;
  *(void *)(v24 + 2832) = 0;
  *(void *)(v24 + 2912) = 0;
  *(_OWORD *)(v24 + 292CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0u;
  *(_DWORD *)(v24 + 2936) = 1065353216;
  *(_DWORD *)(v24 + 294CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = a3 | 8;
  *(void *)(v24 + 308CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  *(_OWORD *)(v24 + 3064) = 0u;
  *(_OWORD *)(v24 + 3168) = xmmword_184998350;
  *(_OWORD *)(v24 + 3184) = xmmword_184998280;
  *(_OWORD *)(v24 + 320CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = xmmword_184997E30;
  *(void *)(v24 + 3216) = 0;
  *(_WORD *)(v24 + 3224) = 0;
  *(void *)(v24 + 3228) = 0x100000001;
  *(_OWORD *)(v24 + 3236) = 0u;
  *(_OWORD *)(v24 + 3252) = 0u;
  *(unsigned char *)(v24 + 3268) = 0;
  *(_DWORD *)(v24 + 3272) = 1065353216;
  *(_OWORD *)(v24 + 3276) = 0u;
  *(_DWORD *)(v24 + 3292) = -1;
  *(_OWORD *)(v24 + 4024) = 0u;
  CFAllocatorContext context = (void *)MEMORY[0x185324A30](v25);
  atomic_fetch_add(CA::OGL::MetalContext::_context_count, 1u);
  int v26 = *(_DWORD *)(v24 + 224);
  *(_DWORD *)(v24 + 224) = a4;
  *(_DWORD *)(v24 + 432) = global_feature_flags | a4;
  if (((v26 ^ a4) & 0x2000200) != 0) {
    CA::OGL::Context::update_color_program_cache(v24);
  }
  if (CA::OGL::MetalContext::MetalContext(objc_object  {objcproto9MTLDevice}*,objc_object  {objcproto15MTLCommandQueue}*,NSObject  {objcproto17OS_dispatch_queue}*,unsigned int,unsigned int)::once != -1) {
    dispatch_once(&CA::OGL::MetalContext::MetalContext(objc_object  {objcproto9MTLDevice}*,objc_object  {objcproto15MTLCommandQueue}*,NSObject  {objcproto17OS_dispatch_queue}*,unsigned int,unsigned int)::once, &__block_literal_global_8284);
  }
  *(void *)(v24 + 2952) = a1;
  uint64_t v27 = 0;
  *(void *)(v24 + 3952) = (id)[MEMORY[0x1E4F352E0] renderPassDescriptor];
  do
  {
    uint8x8_t v28 = objc_msgSend((id)objc_msgSend(*(id *)(v24 + 3952), "colorAttachments"), "objectAtIndexedSubscript:", v27);
    *(void *)(v24 + 8 * v27 + 396CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v28;
    objc_msgSend(v28, "setClearColor:", 0.0, 0.0, 0.0, 0.0);
    ++v27;
  }
  while (v27 != 3);
  *(void *)(v24 + 3984) = [a1 newDepthStencilStateWithDescriptor:(id)objc_opt_new()];
  if (v14)
  {
    dispatch_queue_t v29 = dispatch_queue_create_with_target_V2("com.apple.coreanimation.mtl_dealloc", 0, v14);
  }
  else
  {
    mach_error_t v33 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    dispatch_queue_t v29 = dispatch_queue_create("com.apple.coreanimation.mtl_dealloc", v33);
  }
  *(void *)(v24 + 400CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v29;
  *(void *)(v24 + 296CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v15;
  if (a3) {
    [v15 setBackgroundGPUPriority:2];
  }
  if ((a3 & 2) == 0 && [*(id *)(v24 + 2952) supportsMemorylessRenderTargets])
  {
    unint64_t v34 = getenv("CA_ENABLE_MEMORYLESS");
    if (v34)
    {
      int v35 = atoi(v34);
      unint64_t v36 = (_WORD *)(v24 + 3328);
      __int16 v37 = *(_WORD *)(v24 + 3328);
      if (!v35)
      {
        __int16 v38 = 0;
LABEL_45:
        *unint64_t v36 = v38 | v37 & 0xFFF7;
        goto LABEL_46;
      }
    }
    else
    {
      unint64_t v36 = (_WORD *)(v24 + 3328);
      __int16 v37 = *(_WORD *)(v24 + 3328);
    }
    __int16 v38 = 8;
    goto LABEL_45;
  }
LABEL_46:
  int v39 = [*(id *)(v24 + 2952) supportsMemorylessRenderTargets];
  __int16 v40 = *(_WORD *)(v24 + 3328);
  __int16 v41 = (2 * v40) & 0x10;
  if (!v39) {
    __int16 v41 = 0;
  }
  *(_WORD *)(v24 + 3328) = v40 & 0xFFEF | v41;
  *(void *)(v24 + 3048) = (id)[MEMORY[0x1E4F351E0] sharedCaptureManager];
  if (CADeviceHasInternalBuild::once[0] != -1) {
    dispatch_once(CADeviceHasInternalBuild::once, &__block_literal_global_153);
  }
  if (CADeviceHasInternalBuild::internal)
  {
    float v42 = (void *)[*(id *)(v24 + 3048) newCaptureScopeWithCommandQueue:*(void *)(v24 + 2960)];
    *(void *)(v24 + 3056) = v42;
    [v42 setLabel:@"CoreAnimation Renderer"];
    *(_WORD *)(v24 + 3328) &= ~4u;
  }
  int v43 = [a1 minConstantBufferAlignmentBytes];
  BOOL v44 = (malloc_zone_t *)get_malloc_zone();
  unint64_t v45 = (char *)malloc_type_zone_calloc(v44, 1uLL, 0x168uLL, 0x743898A5uLL);
  if (v45)
  {
    *(void *)unint64_t v45 = a1;
    *(_OWORD *)(v45 + 8) = 0u;
    *(_OWORD *)(v45 + 24) = 0u;
    *((_DWORD *)v45 + 1CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
    *((_DWORD *)v45 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v43;
    *((_DWORD *)v45 + 14) = 0;
    *((void *)v45 + 43) = 0;
    *((void *)v45 + 44) = 0;
    *((_OWORD *)v45 + 12) = 0u;
    *((_OWORD *)v45 + 13) = 0u;
    *((_OWORD *)v45 + 14) = 0u;
    *((_OWORD *)v45 + 15) = 0u;
    *((_OWORD *)v45 + 16) = 0u;
    *((_OWORD *)v45 + 17) = 0u;
    *((_OWORD *)v45 + 18) = 0u;
    *((_OWORD *)v45 + 19) = 0u;
    *((_OWORD *)v45 + 2CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0u;
    *((void *)v45 + 42) = v45 + 344;
  }
  *(void *)(v24 + 404CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v45;
  unint64_t v46 = (void *)[MEMORY[0x1E4F28B50] bundleForClass:objc_opt_class()];
  if (!v46) {
    __assert_rtn("MetalContext", "ogl-metal.mm", 3493, "quartzcore_bundle != nil");
  }
  uint64_t v47 = [v46 URLForResource:@"default" withExtension:@"metallib"];
  if (!v47) {
    __assert_rtn("MetalContext", "ogl-metal.mm", 3496, "metallib_url != nil");
  }
  pthread_mutex_lock(&CA::OGL::MetalContext::_library_lock);
  mach_port_name_t v48 = (id *)CA::OGL::MetalContext::_libraries;
  uint64_t v49 = qword_1E8F83E10;
  if (CA::OGL::MetalContext::_libraries == (_UNKNOWN *)qword_1E8F83E10)
  {
    size_t v51 = *(void **)(v24 + 2952);
  }
  else
  {
    while (1)
    {
      uint64_t v50 = [*v48 device];
      size_t v51 = *(void **)(v24 + 2952);
      if ((void *)v50 == v51) {
        break;
      }
      if (++v48 == (id *)v49)
      {
        mach_port_name_t v48 = (id *)v49;
        break;
      }
    }
    if (v48 != (id *)qword_1E8F83E10)
    {
      id v52 = *v48;
      uint8x8_t v12 = v134;
      goto LABEL_75;
    }
  }
  id v135 = 0;
  int32x2_t v130 = v13;
  uint8x8_t v53 = (void *)[v51 newLibraryWithURL:v47 error:&v135];
  id v52 = v53;
  if (v53)
  {
    [v53 setLabel:@"com.apple.coreanimation.metal-library"];
    id v54 = v52;
    size_t v56 = CA::OGL::MetalContext::_libraries;
    BOOL v55 = (char *)qword_1E8F83E10;
    uint64_t v57 = (qword_1E8F83E10 - (uint64_t)CA::OGL::MetalContext::_libraries) >> 3;
    if (qword_1E8F83E20 < (unint64_t)(v57 + 1))
    {
      uint64_t v128 = qword_1E8F83E18;
      unint64_t v58 = (qword_1E8F83E20 + 1) | ((unint64_t)(qword_1E8F83E20 + 1) >> 1) | (((qword_1E8F83E20 + 1) | ((unint64_t)(qword_1E8F83E20 + 1) >> 1)) >> 2);
      unint64_t v59 = v58 | (v58 >> 4) | ((v58 | (v58 >> 4)) >> 8);
      unint64_t v60 = v59 | (v59 >> 16) | ((v59 | (v59 >> 16)) >> 32);
      if (v60 + 1 > v57 + 1) {
        uint64_t v61 = v60 + 1;
      }
      else {
        uint64_t v61 = v57 + 1;
      }
      mach_port_name_t v62 = (char *)malloc_type_malloc(8 * v61, 0x80040B8603338uLL);
      mach_port_t v63 = v62;
      unsigned int v64 = (uint64_t *)CA::OGL::MetalContext::_libraries;
      uint64_t v65 = qword_1E8F83E10;
      if (CA::OGL::MetalContext::_libraries != (_UNKNOWN *)qword_1E8F83E10)
      {
        int v66 = v62;
        do
        {
          uint64_t v67 = *v64++;
          *(void *)int v66 = v67;
          v66 += 8;
        }
        while (v64 != (uint64_t *)v65);
      }
      if (v56 != (void *)v128) {
        free(CA::OGL::MetalContext::_libraries);
      }
      BOOL v55 = &v63[8 * v57];
      CA::OGL::MetalContext::_libraries = v63;
      qword_1E8F83E10 = (uint64_t)v55;
      qword_1E8F83E20 = v61;
    }
    *(void *)BOOL v55 = v54;
    qword_1E8F83E10 += 8;
    uint8x8_t v12 = v134;
    unint64_t v13 = v130;
LABEL_75:
    pthread_mutex_unlock(&CA::OGL::MetalContext::_library_lock);
    *(void *)(v24 + 3336) = v52;
    if (byte_1EB2ACC28)
    {
      if (!x_log_hook_p())
      {
        uint64_t v68 = x_log_category_ogl_metal;
        if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_116;
        }
        *(_WORD *)long long buf = 0;
        unsigned int v69 = "Precompiled pipelines disabled via debug option.";
        goto LABEL_98;
      }
    }
    else
    {
      if ((*(unsigned char *)(v24 + 434) & 0x20) == 0)
      {
        if ([*(id *)(v24 + 3048) supportsDestination:2])
        {
          if (x_log_hook_p()) {
            goto LABEL_87;
          }
          uint64_t v68 = x_log_category_ogl_metal;
          if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_116;
          }
          *(_WORD *)long long buf = 0;
          unsigned int v69 = "Precompiled pipelines disabled for GPU frame capture.";
        }
        else
        {
          if (CADeviceIsVirtualized::once != -1) {
            dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
          }
          if (!CADeviceIsVirtualized::is_virtualized)
          {
            pthread_mutex_lock(&CA::OGL::MetalContext::_library_lock);
            unsigned int v70 = (id *)CA::OGL::MetalContext::_binary_archives;
            uint64_t v71 = qword_1E8F83E40;
            if (CA::OGL::MetalContext::_binary_archives == (_UNKNOWN *)qword_1E8F83E40) {
              goto LABEL_99;
            }
            while ([*v70 device] != *(void *)(v24 + 2952))
            {
              if (++v70 == (id *)v71)
              {
                unsigned int v70 = (id *)v71;
                break;
              }
            }
            if (v70 == (id *)qword_1E8F83E40)
            {
LABEL_99:
              id v135 = 0;
              unsigned int v73 = objc_opt_new();
              [v73 setUrl:v47];
              objc_msgSend(v73, "setOptions:", objc_msgSend(v73, "options") | 0x20);
              uint8x8_t v12 = v134;
              id v72 = (id)[*(id *)(v24 + 2952) newBinaryArchiveWithDescriptor:v73 error:&v135];

              if (v72)
              {
                [v72 setLabel:@"com.apple.coreanimation.binary-archive"];
                uint64_t v131 = v13;
                id v74 = v72;
                int v76 = CA::OGL::MetalContext::_binary_archives;
                unsigned int v75 = (char *)qword_1E8F83E40;
                uint64_t v77 = (qword_1E8F83E40 - (uint64_t)CA::OGL::MetalContext::_binary_archives) >> 3;
                if (qword_1E8F83E50 < (unint64_t)(v77 + 1))
                {
                  uint64_t v129 = qword_1E8F83E48;
                  unint64_t v78 = (qword_1E8F83E50 + 1) | ((unint64_t)(qword_1E8F83E50 + 1) >> 1) | (((qword_1E8F83E50 + 1) | ((unint64_t)(qword_1E8F83E50 + 1) >> 1)) >> 2);
                  unint64_t v79 = v78 | (v78 >> 4) | ((v78 | (v78 >> 4)) >> 8);
                  unint64_t v80 = v79 | (v79 >> 16) | ((v79 | (v79 >> 16)) >> 32);
                  if (v80 + 1 > v77 + 1) {
                    uint64_t v81 = v80 + 1;
                  }
                  else {
                    uint64_t v81 = v77 + 1;
                  }
                  int v82 = (char *)malloc_type_malloc(8 * v81, 0x80040B8603338uLL);
                  unsigned int v83 = v82;
                  unsigned int v84 = (uint64_t *)CA::OGL::MetalContext::_binary_archives;
                  uint64_t v85 = qword_1E8F83E40;
                  if (CA::OGL::MetalContext::_binary_archives != (_UNKNOWN *)qword_1E8F83E40)
                  {
                    unsigned int v86 = v82;
                    do
                    {
                      uint64_t v87 = *v84++;
                      *(void *)unsigned int v86 = v87;
                      v86 += 8;
                    }
                    while (v84 != (uint64_t *)v85);
                  }
                  if (v76 != (void *)v129) {
                    free(CA::OGL::MetalContext::_binary_archives);
                  }
                  unsigned int v75 = &v83[8 * v77];
                  CA::OGL::MetalContext::_binary_archives = v83;
                  qword_1E8F83E40 = (uint64_t)v75;
                  qword_1E8F83E50 = v81;
                }
                *(void *)unsigned int v75 = v74;
                qword_1E8F83E40 += 8;
                uint8x8_t v12 = v134;
                unint64_t v13 = v131;
              }
              else
              {
                bzero(buf, 0x7FFuLL);
                snprintf((char *)buf, 0x800uLL, "%s", (const char *)objc_msgSend((id)objc_msgSend(v135, "localizedDescription"), "UTF8String"));
                char v141 = 0;
                if (x_log_hook_p())
                {
                  unint64_t v126 = "Metal failed to load binary archive";
                  uint64_t v127 = buf;
                  x_log_();
                }
                else
                {
                  int v88 = x_log_category_ogl_metal;
                  if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)uint64_t v136 = 136315394;
                    int v137 = "Metal failed to load binary archive";
                    __int16 v138 = 2080;
                    long long v139 = buf;
                    _os_log_impl(&dword_184668000, v88, OS_LOG_TYPE_FAULT, "%s: %s\n", v136, 0x16u);
                  }
                }
              }
            }
            else
            {
              id v72 = *v70;
              uint8x8_t v12 = v134;
            }
            pthread_mutex_unlock(&CA::OGL::MetalContext::_library_lock);
            *(void *)(v24 + 3344) = v72;
            goto LABEL_116;
          }
          if (x_log_hook_p()) {
            goto LABEL_87;
          }
          uint64_t v68 = x_log_category_ogl_metal;
          if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_116;
          }
          *(_WORD *)long long buf = 0;
          unsigned int v69 = "Precompiled pipelines disabled on unsupported hardware.";
        }
LABEL_98:
        _os_log_impl(&dword_184668000, v68, OS_LOG_TYPE_DEFAULT, v69, buf, 2u);
        goto LABEL_116;
      }
      if (!x_log_hook_p())
      {
        uint64_t v68 = x_log_category_ogl_metal;
        if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
        {
LABEL_116:
          uint64_t v89 = *(void *)(v24 + 2952);
          if (*(void *)(v24 + 184) != v89)
          {
            (*(void (**)(uint64_t))(*(void *)v24 + 1096))(v24);
            *(void *)(v24 + 184) = v89;
          }
          *(void *)(v24 + 72) = 0x4110000000000000;
          unint64_t v90 = *(void *)(v24 + 2096);
          if (v90) {
            float v91 = (float)*(unint64_t *)(v24 + 2112) / (float)v90;
          }
          else {
            float v91 = 0.0;
          }
          *(float *)(v24 + 212CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = fmaxf(v91, 0.5);
          *(void *)(v24 + 3144) = objc_alloc_init(MEMORY[0x1E4F1CA60]);
          int v92 = [*(id *)(v24 + 2952) supportsFamily:1001];
          CGColorRef v93 = objc_msgSend((id)objc_msgSend(*(id *)(v24 + 2952), "vendorName"), "lowercaseString");
          unint64_t v94 = [*(id *)(v24 + 2952) maxFragmentTextures];
          unint64_t v95 = [*(id *)(v24 + 2952) maxFragmentSamplers];
          unint64_t v96 = *(void **)(v24 + 2952);
          if (v94 >= v95) {
            uint64_t v97 = [v96 maxFragmentSamplers];
          }
          else {
            uint64_t v97 = [v96 maxFragmentTextures];
          }
          *(void *)(v24 + 2688) = v97;
          *(void *)(v24 + 2704) = objc_msgSend(*(id *)(v24 + 2952), "maxTextureWidth2D", v126, v127);
          *(void *)(v24 + 2696) = [*(id *)(v24 + 2952) maxTextureWidth2D];
          if ((unint64_t)[*(id *)(v24 + 2952) maxColorAttachments] > 2) {
            int v98 = 3;
          }
          else {
            int v98 = [*(id *)(v24 + 2952) maxColorAttachments];
          }
          *(_DWORD *)(v24 + 272CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v98;
          unint64_t v99 = *(void *)(v24 + 2696);
          if (v99 >= 0x2000) {
            unint64_t v99 = 0x2000;
          }
          *(void *)(v24 + 2696) = v99;
          int v100 = *(_DWORD *)(v24 + 2724) | 0x1000;
          *(_DWORD *)(v24 + 2724) = v100;
          if (v92)
          {
            if ([*(id *)(v24 + 2952) supportsRasterOrderGroups]) {
              int v101 = 0x2000;
            }
            else {
              int v101 = 0;
            }
            int v100 = *(_DWORD *)(v24 + 2724);
            int v102 = 4;
            int v103 = 8;
          }
          else
          {
            int v103 = 0;
            int v102 = 0;
            int v101 = 0;
          }
          *(_DWORD *)(v24 + 2724) = v103 | v102 | v101 | v92 | v100 & 0xFFFFDFF2;
          if ([*(id *)(v24 + 2952) supportsFamily:1002]) {
            int v104 = 2;
          }
          else {
            int v104 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFFFFFFFD | v104;
          if ([*(id *)(v24 + 2952) supportsFamily:1002]) {
            int v105 = 2048;
          }
          else {
            int v105 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFFFFF7FF | v105;
          if ([*(id *)(v24 + 2952) supportsFamily:1002]) {
            int v106 = 16;
          }
          else {
            int v106 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFFFFFFEF | v106;
          if ([*(id *)(v24 + 2952) supportsFamily:1002]) {
            int v107 = 512;
          }
          else {
            int v107 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFFFFFDFF | v107;
          if ([*(id *)(v24 + 2952) supportsFamily:1002]) {
            int v108 = 1024;
          }
          else {
            int v108 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFFFFFBFF | v108;
          if ([*(id *)(v24 + 2952) supportsFamily:1003]) {
            int v109 = 256;
          }
          else {
            int v109 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFFFFFEFF | v109;
          if ([*(id *)(v24 + 2952) supportsFamily:1005]) {
            int v110 = 128;
          }
          else {
            int v110 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFFFFFF7F | v110;
          if ([*(id *)(v24 + 2952) supportsYCBCRFormats12]) {
            int v111 = 32;
          }
          else {
            int v111 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFFFFFFDF | v111;
          if ([*(id *)(v24 + 2952) supportsYCBCRPackedFormats12]) {
            int v112 = 64;
          }
          else {
            int v112 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFFFFFFBF | v112;
          unint64_t v113 = MEMORY[0x185323680](*MEMORY[0x1E4F2EFE0]);
          unint64_t v114 = 16 * [*(id *)(v24 + 2952) maxTextureWidth2D];
          if (v113 > v114) {
            unint64_t v114 = v113;
          }
          *(void *)(v24 + 2712) = v114;
          *(_DWORD *)(v24 + 2724) &= ~0x8000u;
          if (CADeviceVertexCoordinateSubpixelBits::once[0] != -1) {
            dispatch_once(CADeviceVertexCoordinateSubpixelBits::once, &__block_literal_global_129);
          }
          float v115 = 0.5;
          if ((CADeviceVertexCoordinateSubpixelBits::bits - 1) <= 0x1D) {
            float v115 = 0.5 - (float)(0.5 / (float)(1 << CADeviceVertexCoordinateSubpixelBits::bits));
          }
          *(float *)(v24 + 812) = v115;
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFFFFBFFF | (BYTE10(xmmword_1EB2ACC10) << 14);
          if ([*(id *)(v24 + 2952) supportsFamily:1005]) {
            int v116 = 327680;
          }
          else {
            int v116 = 0x40000;
          }
          *(_DWORD *)(v24 + 2724) = v116 | *(_DWORD *)(v24 + 2724) & 0xFFF8FFFF;
          if (([*(id *)(v24 + 2952) supportsNativeHardwareFP16] | v92))
          {
            int v117 = 0x80000;
          }
          else if ([v93 containsString:@"intel"])
          {
            if ([*(id *)(v24 + 2952) supportsFamily:2002]) {
              int v117 = 0x80000;
            }
            else {
              int v117 = 0;
            }
          }
          else
          {
            int v117 = 0;
          }
          if (v92) {
            int v118 = 3145728;
          }
          else {
            int v118 = 0;
          }
          *(_DWORD *)(v24 + 2724) = v118 | v117 | *(_DWORD *)(v24 + 2724) & 0xFFC7FFFF;
          if ([*(id *)(v24 + 2952) supportsTileShaders]) {
            int v119 = 0x400000;
          }
          else {
            int v119 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFFBFFFFF | v119;
          if ([*(id *)(v24 + 2952) supportsSIMDGroup]) {
            int v120 = 0x800000;
          }
          else {
            int v120 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFF7FFFFF | v120;
          if ([*(id *)(v24 + 2952) supportsFamily:1007]) {
            int v121 = 0x4000000;
          }
          else {
            int v121 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFBFFFFFF | v121;
          if ([*(id *)(v24 + 2952) supportsSIMDShuffleAndFill]) {
            int v122 = 0x1000000;
          }
          else {
            int v122 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFEFFFFFF | v122;
          if ([*(id *)(v24 + 2952) supportsSIMDReduction]) {
            int v123 = 0x2000000;
          }
          else {
            int v123 = 0;
          }
          *(_DWORD *)(v24 + 2724) = *(_DWORD *)(v24 + 2724) & 0xFDFFFFFF | v123;
          if (*(int *)(v24 + 3096) <= 3 && ([*(id *)(v24 + 2952) supportsFamily:1003] & 1) == 0) {
            *(_DWORD *)(v24 + 2728) = 128;
          }
          CADeviceSetMinimumAlignment([a1 iosurfaceReadOnlyTextureAlignmentBytes]);
          CADeviceSetMaxRenderableIOSurfaceSize([a1 maxTextureWidth2D], objc_msgSend(a1, "maxTextureHeight2D"), *(void *)(v24 + 2712));
          if (CA::OGL::MetalContext::get_pipeline_queue(void)::once[0] != -1) {
            dispatch_once(CA::OGL::MetalContext::get_pipeline_queue(void)::once, &__block_literal_global_304);
          }
          int v124 = CA::OGL::MetalContext::get_pipeline_queue(void)::queue;
          *(void *)(v24 + 2144) = CA::OGL::MetalContext::get_pipeline_queue(void)::queue;
          dispatch_retain(v124);
          *(_WORD *)(v24 + 3328) &= ~0x200u;
          a5 = v132;
          if (objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "mainBundle"), "bundleIdentifier"), "isEqualToString:", @"com.apple.backboardd"))
          {
            BMEnrollIntoBlockMonitoring();
            *(_WORD *)(v24 + 3328) |= 0x200u;
          }
          goto LABEL_29;
        }
        *(_WORD *)long long buf = 0;
        unsigned int v69 = "Precompiled pipelines disabled via renderer feature flag.";
        goto LABEL_98;
      }
    }
LABEL_87:
    x_log_();
    goto LABEL_116;
  }
  bzero(buf, 0x7FFuLL);
  snprintf((char *)buf, 0x800uLL, "%s", (const char *)objc_msgSend((id)objc_msgSend(v135, "localizedDescription"), "UTF8String"));
  char v141 = 0;
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    uint64_t v125 = x_log_category_ogl_metal;
    if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v136 = 136315394;
      int v137 = "Metal failed to load library";
      __int16 v138 = 2080;
      long long v139 = buf;
      _os_log_impl(&dword_184668000, v125, OS_LOG_TYPE_ERROR, "%s: %s\n", v136, 0x16u);
    }
  }
  strlen((const char *)buf);
  uint64_t result = abort_with_payload();
  __break(1u);
  return result;
}

void sub_1847CDE18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, pthread_mutex_t *a14, uint64_t a15, pthread_mutex_t *a16, uint64_t a17, void **a18, uint64_t a19, uint64_t a20,uint64_t a21,void *context,void *a23)
{
  pthread_mutex_unlock(&CA::OGL::MetalContext::_library_lock);
  int v26 = *a18;
  if (*a18)
  {
    *((void *)v23 + 384) = v26;
    operator delete(v26);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(a19);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v23 + 2608);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(a13);
  pthread_mutex_destroy(a14);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(a15);
  pthread_mutex_destroy(a16);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(a17);
  CA::OGL::Context::~Context(v23);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, v23);
  _Unwind_Resume(a1);
}

void ___ZN2CA2CG13AccelRenderer20add_suspend_observerEv_block_invoke()
{
  CA::Render::add_observer(0x32u, 0, (uint64_t)CA::CG::AccelRenderer::will_suspend, 0, 0);
  CA::Render::add_observer(0x33u, 0, (uint64_t)CA::CG::AccelRenderer::will_suspend, 0, 0);

  CA::Render::add_observer(0x31u, 0, (uint64_t)CA::CG::AccelRenderer::will_suspend, 0, 0);
}

CA::OGL::Context *CA::OGL::Context::Context(CA::OGL::Context *this)
{
  *(void *)this = &unk_1ED02BAE0;
  *((_DWORD *)this + 2) = atomic_fetch_add(&CA::OGL::Context::_next_context_id, 1u) + 1;
  *((_DWORD *)this + 38) = 1074664571;
  *((_WORD *)this + 84) = 0;
  *((unsigned char *)this + 17CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  *((_DWORD *)this + 43) = 0;
  *((_DWORD *)this + 44) = 0;
  *(_OWORD *)((char *)this + 20CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = xmmword_184998040;
  *((_DWORD *)this + 76) = 0;
  *((void *)this + 52) = 0;
  *((_DWORD *)this + 11CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 64;
  *((_DWORD *)this + 203) = 1056964608;
  *((_WORD *)this + 416) |= 4u;
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (CA::OGL::Context::Context(void)::once != -1) {
    dispatch_once(&CA::OGL::Context::Context(void)::once, &__block_literal_global_3491);
  }
  *((void *)this + 46) = (char *)this + 368;
  *((void *)this + 47) = (char *)this + 368;
  *((void *)this + 49) = 0x800000;
  *((void *)this + 36) = x_hash_table_new_(0, 0, 0, 0, 0, 0);
  *((void *)this + 39) = x_hash_table_new_(0, 0, 0, 0, 0, 0);
  *((_DWORD *)this + 108) = global_feature_flags;
  CA::Render::add_observer(3u, 0, (uint64_t)CA::OGL::Context::image_deleted, (uint64_t)this, 0);
  CA::Render::add_observer(0xBu, 0, (uint64_t)CA::OGL::Context::image_volatile, (uint64_t)this, 0);
  mach_port_context_t v2 = (CGColorSpace *)CAGetColorSpace(0x1Du);
  CA::OGL::Context::set_colorspace(this, v2);
  return this;
}

uint64_t CAImageQueueCreate(int a1, int a2, unsigned int a3)
{
  uint64_t result = CAImageQueueCreate_(0, a3);
  if (result)
  {
    *(_DWORD *)(result + 32) = a1;
    *(_DWORD *)(result + 36) = a2;
  }
  return result;
}

void CA::Render::add_observer(unsigned int a1, unint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  if (a1 > 0x49) {
    return;
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  unint64_t v11 = malloc_type_zone_malloc(malloc_zone, 0x50uLL, 0x8BB15036uLL);
  v11[5] = a3;
  v11[6] = a2;
  v11[7] = a4;
  *((unsigned char *)v11 + 76) = a5;
  *((unsigned char *)v11 + 77) = 0;
  v11[8] = dispatch_semaphore_create(1);
  *((_DWORD *)v11 + 18) = 0;
  *unint64_t v11 = v11;
  v11[1] = v11;
  uint8x8_t v12 = (char *)(v11 + 2);
  _DWORD v11[2] = v11 + 2;
  double v11[3] = v11 + 2;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::notification_lock);
  if ((CA::Render::initialize_notifications(void)::initialized & 1) == 0)
  {
    uint64_t v49 = 0;
    uint64_t v50 = (int64x2_t *)CA::Render::notifications;
    do
    {
      size_t v51 = (char *)&CA::Render::notifications_map_data + v49;
      *(_OWORD *)size_t v51 = 0uLL;
      *((_OWORD *)v51 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0uLL;
      *((_DWORD *)v51 + 8) = 1065353216;
      *uint64_t v50 = vdupq_n_s64((unint64_t)v50);
      ++v50;
      v49 += 40;
    }
    while (v49 != 2960);
    CA::Render::initialize_notifications(void)::initialized = 1;
  }
  uint64_t v13 = CA::Render::add_observer(CA::Render::NotificationName,CA::Render::Object *,void (*)(CA::Render::Object *,void *,void *),void *,BOOL)::order++;
  v11[4] = v13;
  int32x2_t v14 = &CA::Render::notifications[a1];
  id v15 = (void *)*((void *)v14 + 1);
  *((void *)v14 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v11;
  *unint64_t v11 = v14;
  *id v15 = v11;
  v11[1] = v15;
  unint64_t v16 = (char *)&CA::Render::notifications_map_data + 40 * a1;
  unint64_t v17 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v18 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v17 >> 47) ^ v17);
  unint64_t v19 = 0x9DDFEA08EB382D69 * (v18 ^ (v18 >> 47));
  unint64_t v20 = *((void *)v16 + 1);
  if (v20)
  {
    uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v20);
    v21.i16[0] = vaddlv_u8(v21);
    if (v21.u32[0] > 1uLL)
    {
      unint64_t v22 = 0x9DDFEA08EB382D69 * (v18 ^ (v18 >> 47));
      if (v19 >= v20) {
        unint64_t v22 = v19 % v20;
      }
    }
    else
    {
      unint64_t v22 = v19 & (v20 - 1);
    }
    float64x2_t v23 = *(void ***)(*(void *)v16 + 8 * v22);
    if (v23)
    {
      for (uint64_t i = *v23; i; uint64_t i = (void *)*i)
      {
        unint64_t v25 = i[1];
        if (v25 == v19)
        {
          if (i[2] == a2) {
            goto LABEL_76;
          }
        }
        else
        {
          if (v21.u32[0] > 1uLL)
          {
            if (v25 >= v20) {
              v25 %= v20;
            }
          }
          else
          {
            v25 &= v20 - 1;
          }
          if (v25 != v22) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v22 = 0;
  }
  uint64_t i = operator new(0x28uLL);
  *uint64_t i = 0;
  i[1] = v19;
  i[3] = 0;
  i[4] = 0;
  i[2] = a2;
  float v26 = (float)(unint64_t)(*((void *)v16 + 3) + 1);
  float v27 = *((float *)v16 + 8);
  if (!v20 || (float)(v27 * (float)v20) < v26)
  {
    BOOL v28 = 1;
    if (v20 >= 3) {
      BOOL v28 = (v20 & (v20 - 1)) != 0;
    }
    unint64_t v29 = v28 | (2 * v20);
    unint64_t v30 = vcvtps_u32_f32(v26 / v27);
    if (v29 <= v30) {
      int8x8_t prime = (int8x8_t)v30;
    }
    else {
      int8x8_t prime = (int8x8_t)v29;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v20 = *((void *)v16 + 1);
    }
    if (*(void *)&prime > v20) {
      goto LABEL_32;
    }
    if (*(void *)&prime < v20)
    {
      unint64_t v38 = vcvtps_u32_f32((float)*((unint64_t *)v16 + 3) / *((float *)v16 + 8));
      if (v20 < 3 || (uint8x8_t v39 = (uint8x8_t)vcnt_s8((int8x8_t)v20), v39.i16[0] = vaddlv_u8(v39), v39.u32[0] > 1uLL))
      {
        unint64_t v38 = std::__next_prime(v38);
      }
      else
      {
        uint64_t v40 = 1 << -(char)__clz(v38 - 1);
        if (v38 >= 2) {
          unint64_t v38 = v40;
        }
      }
      if (*(void *)&prime <= v38) {
        int8x8_t prime = (int8x8_t)v38;
      }
      if (*(void *)&prime >= v20)
      {
        unint64_t v20 = *((void *)v16 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_32:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          int v32 = operator new(8 * *(void *)&prime);
          mach_error_t v33 = *(void **)v16;
          *(void *)unint64_t v16 = v32;
          if (v33) {
            operator delete(v33);
          }
          uint64_t v34 = 0;
          *((int8x8_t *)v16 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = prime;
          do
            *(void *)(*(void *)v16 + 8 * v34++) = 0;
          while (*(void *)&prime != v34);
          int v35 = (void *)*((void *)v16 + 2);
          if (v35)
          {
            unint64_t v36 = v35[1];
            uint8x8_t v37 = (uint8x8_t)vcnt_s8(prime);
            v37.i16[0] = vaddlv_u8(v37);
            if (v37.u32[0] > 1uLL)
            {
              if (v36 >= *(void *)&prime) {
                v36 %= *(void *)&prime;
              }
            }
            else
            {
              v36 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)v16 + 8 * v36) = v16 + 16;
            __int16 v41 = (void *)*v35;
            if (*v35)
            {
              do
              {
                unint64_t v42 = v41[1];
                if (v37.u32[0] > 1uLL)
                {
                  if (v42 >= *(void *)&prime) {
                    v42 %= *(void *)&prime;
                  }
                }
                else
                {
                  v42 &= *(void *)&prime - 1;
                }
                if (v42 != v36)
                {
                  if (!*(void *)(*(void *)v16 + 8 * v42))
                  {
                    *(void *)(*(void *)v16 + 8 * v42) = v35;
                    goto LABEL_57;
                  }
                  *int v35 = *v41;
                  void *v41 = **(void **)(*(void *)v16 + 8 * v42);
                  **(void **)(*(void *)v16 + 8 * v42) = v41;
                  __int16 v41 = v35;
                }
                unint64_t v42 = v36;
LABEL_57:
                int v35 = v41;
                __int16 v41 = (void *)*v41;
                unint64_t v36 = v42;
              }
              while (v41);
            }
          }
          unint64_t v20 = (unint64_t)prime;
          goto LABEL_61;
        }
        mach_port_name_t v48 = *(void **)v16;
        *(void *)unint64_t v16 = 0;
        if (v48) {
          operator delete(v48);
        }
        unint64_t v20 = 0;
        *((void *)v16 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
      }
    }
LABEL_61:
    if ((v20 & (v20 - 1)) != 0)
    {
      if (v19 >= v20) {
        unint64_t v22 = v19 % v20;
      }
      else {
        unint64_t v22 = v19;
      }
    }
    else
    {
      unint64_t v22 = (v20 - 1) & v19;
    }
  }
  uint64_t v43 = *(void *)v16;
  BOOL v44 = *(void **)(*(void *)v16 + 8 * v22);
  if (v44)
  {
    *uint64_t i = *v44;
  }
  else
  {
    *uint64_t i = *((void *)v16 + 2);
    *((void *)v16 + 2) = i;
    *(void *)(v43 + 8 * v22) = v16 + 16;
    if (!*i) {
      goto LABEL_75;
    }
    unint64_t v45 = *(void *)(*i + 8);
    if ((v20 & (v20 - 1)) != 0)
    {
      if (v45 >= v20) {
        v45 %= v20;
      }
    }
    else
    {
      v45 &= v20 - 1;
    }
    BOOL v44 = (void *)(*(void *)v16 + 8 * v45);
  }
  *BOOL v44 = i;
LABEL_75:
  ++*((void *)v16 + 3);
LABEL_76:
  unint64_t v46 = i + 3;
  uint64_t v47 = (void *)i[4];
  if (!v47)
  {
    *unint64_t v46 = v46;
    uint64_t v47 = i + 3;
  }
  i[4] = v12;
  _DWORD v11[2] = v46;
  *uint64_t v47 = v12;
  double v11[3] = v47;
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::notification_lock);
  if (CA::Render::memory_once[0] != -1)
  {
    dispatch_once_f(CA::Render::memory_once, 0, (dispatch_function_t)CA::Render::init_memory_warnings_);
  }
}

uint64_t CAImageQueueCreate_(int a1, unsigned int a2)
{
  if (a2) {
    size_t v2 = a2;
  }
  else {
    size_t v2 = 16;
  }
  if (v2 - 65537 < 0xFFFFFFFFFFFF0000) {
    return 0;
  }
  if (CAImageQueueGetTypeID::once != -1) {
    dispatch_once(&CAImageQueueGetTypeID::once, &__block_literal_global_14584);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v3 = Instance;
  if (Instance)
  {
    bzero((void *)(Instance + 16), 16 * v2 + 224);
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 2CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = a1;
    do
    {
      unsigned int add = atomic_fetch_add(CA::Render::next_sequence(void)::sequence, 1u);
      BOOL v7 = __CFADD__(add, 1);
      unsigned int v8 = add + 1;
    }
    while (v7);
    *(_DWORD *)(v3 + 28) = v8;
    *(_DWORD *)(v3 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v2;
    *(void *)(v3 + 184) = v3 + 240;
    *(void *)(v3 + 192) = v3 + 240 + 8 * v2;
    *(void *)(v3 + 48) = CA::Render::Shmem::new_shmem((CA::Render::Shmem *)(160 * v2 + 464));
    *(void *)(v3 + 64) = malloc_type_calloc(8uLL, v2, 0x85FAC87uLL);
    uint64_t v9 = *(void *)(v3 + 48);
    if (v9)
    {
      uint64_t v10 = *(void *)(v9 + 24);
      *(_DWORD *)(v10 + 292) = -1;
      *(void *)(v10 + 216) = 0x3FF0000000000000;
      *(void *)(v10 + 168) = 0x3FF0000000000000;
      *(_OWORD *)(v10 + 232) = xmmword_1849983F0;
      *(_OWORD *)(v10 + 184) = xmmword_1849983F0;
      *(void *)(v10 + 248) = 0x7FF0000000000000;
      *(void *)(v10 + 20CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0x7FF0000000000000;
      *(_DWORD *)(v10 + 456) = a1;
      return v3;
    }
    CFRelease((CFTypeRef)v3);
    return 0;
  }
  return v3;
}

uint64_t CAImageQueueSetCollectableCallback(uint64_t result, NSObject *a2, uint64_t a3, uint64_t a4)
{
  if (!*(void *)(result + 48)) {
    return result;
  }
  uint64_t v7 = result;
  pthread_mutex_lock(&collectable_mutex);
  if (*(NSObject **)(v7 + 72) != a2 || *(void *)(v7 + 96) != a3 || *(void *)(v7 + 104) != a4)
  {
    while (*(unsigned char *)(v7 + 112))
      pthread_cond_wait(&collectable_cond, &collectable_mutex);
    uint64_t v8 = *(void *)(v7 + 96);
    if (a3 || !v8)
    {
      if (!a3 || v8) {
        goto LABEL_15;
      }
      uint64_t v10 = collectable_list;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      uint64_t v9 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
      *uint64_t v9 = v7;
      v9[1] = v10;
    }
    else
    {
      uint64_t v9 = x_list_remove((void *)collectable_list, v7);
    }
    collectable_list = (uint64_t)v9;
LABEL_15:
    uint8x8_t v12 = *(NSObject **)(v7 + 72);
    if (v12) {
      dispatch_release(v12);
    }
    *(void *)(v7 + 72) = a2;
    *(void *)(v7 + 96) = a3;
    *(void *)(v7 + 104) = a4;
    if (a2) {
      dispatch_retain(a2);
    }
    if (a3) {
      int v13 = *(_DWORD *)(v7 + 28);
    }
    else {
      int v13 = 0;
    }
    *(_DWORD *)(*(void *)(*(void *)(v7 + 48) + 24) + 28) = v13;
  }

  return pthread_mutex_unlock(&collectable_mutex);
}

CGColorSpace *CA::OGL::Context::set_colorspace(CA::OGL::Context *this, CGColorSpace *a2)
{
  uint64_t result = (CGColorSpace *)*((void *)this + 18);
  if (result != a2)
  {
    CGColorSpaceRelease(result);
    *((void *)this + 18) = CGColorSpaceRetain(a2);
    uint64_t result = (CGColorSpace *)*((void *)this + 20);
    if (result)
    {
      return (CGColorSpace *)CA::ColorProgram::Cache::set_colorspace((CGColorSpace **)result, a2);
    }
  }
  return result;
}

uint64_t __CADeviceSupportsCIF10_block_invoke()
{
  uint64_t result = MGGetSInt64Answer();
  if (result) {
    CADeviceSupportsCIF10::supports_cif10 = result != 28672;
  }
  return result;
}

void sub_1847CFCE8(_Unwind_Exception *a1)
{
  MEMORY[0x185323DC0](v1, 0x10A0C405234EED1);
  _Unwind_Resume(a1);
}

void ___ZN2CA6RenderL16initialize_typesEv_block_invoke()
{
  CA::Render::string_unsigned int type = CFStringGetTypeID();
  CA::Render::array_unsigned int type = CFArrayGetTypeID();
  CFDictionaryGetTypeID();
  CA::Render::number_unsigned int type = CFNumberGetTypeID();
  CA::Render::BOOL_unsigned int type = CFBooleanGetTypeID();
  CFDataGetTypeID();
  CA::Render::color_unsigned int type = CGColorGetTypeID();
  CA::Render::image_unsigned int type = CGImageGetTypeID();
  CA::Render::path_unsigned int type = CGPathGetTypeID();
  if (CABackingStoreGetTypeID::once[0] != -1) {
    dispatch_once(CABackingStoreGetTypeID::once, &__block_literal_global_907);
  }
  CA::Render::backing_unsigned int type = CABackingStoreGetTypeID::type;
  if (CAImageQueueGetTypeID::once != -1) {
    dispatch_once(&CAImageQueueGetTypeID::once, &__block_literal_global_14584);
  }
  CA::Render::queue_unsigned int type = CAImageQueueGetTypeID::type;
  if (CAImageProviderGetTypeID::once != -1) {
    dispatch_once(&CAImageProviderGetTypeID::once, &__block_literal_global_5_8974);
  }
  CA::Render::provider_unsigned int type = CAImageProviderGetTypeID::type;
  if (CARenderObjectGetTypeID::once != -1) {
    dispatch_once(&CARenderObjectGetTypeID::once, &__block_literal_global_5787);
  }
  CA::Render::render_object_unsigned int type = CARenderObjectGetTypeID::type;
  CA::Render::surface_unsigned int type = IOSurfaceGetTypeID();
  if (CAMachPortGetTypeID::once[0] != -1) {
    dispatch_once(CAMachPortGetTypeID::once, &__block_literal_global_5766);
  }
  CA::Render::machport_unsigned int type = CAMachPortGetTypeID::type;
  CA::Render::cvpixelbuffer_unsigned int type = CVPixelBufferGetTypeID();
  if (CAIOSurfaceGetTypeID::once[0] != -1) {
    dispatch_once(CAIOSurfaceGetTypeID::once, &__block_literal_global_2614);
  }
  CA::Render::caiosurface_unsigned int type = CAIOSurfaceGetTypeID::type;
}

void CA::add_timer(CA *this, void *a2)
{
  Current = CFRunLoopGetCurrent();
  CFStringRef v4 = (const __CFString *)*MEMORY[0x1E4F1D410];

  CFRunLoopAddTimer(Current, this, v4);
}

int *CAImageQueueSetMediaTimingClamped(int *result, double a2, float a3, double a4, double a5, double a6, double a7)
{
  if (*((void *)result + 6))
  {
    uint64_t v13 = (uint64_t)result;
    int32x2_t v14 = (os_unfair_lock_s *)(result + 4);
    os_unfair_lock_lock((os_unfair_lock_t)result + 4);
    int v15 = *(unsigned char *)(v13 + 232) & 1;
    unsigned int v16 = (*(unsigned char *)(v13 + 232) & 1) == 0;
    uint64_t v17 = *(void *)(*(void *)(v13 + 48) + 24);
    unint64_t v18 = (double *)(v17 + 48 * ((*(unsigned char *)(v13 + 232) & 1) == 0));
    v18[20] = a2;
    v18[21] = a3;
    v18[22] = a4;
    v18[23] = a5;
    v18[24] = a6;
    v18[25] = a7;
    __dmb(0xBu);
    unint64_t v19 = (atomic_uint *)(v17 + 256);
    do
    {
      int v20 = v15;
      atomic_compare_exchange_strong(v19, (unsigned int *)&v20, v16);
    }
    while (v20 != v15);
    *(unsigned char *)(v13 + 232) = (*(unsigned char *)(v13 + 232) & 0xFE | v15) ^ 1;
    os_unfair_lock_unlock(v14);
    return CAImageQueuePing_(v13, 0, 0, 0.0, 0.0);
  }
  return result;
}

void CA::Render::iosurface_set_colorspace(CA::Render *this, CGColorSpaceRef space, CGColorSpace *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  CFPropertyListRef v5 = CGColorSpaceCopyPropertyList(space);
  CFStringRef v6 = (const __CFString *)*MEMORY[0x1E4F2F068];
  if (v5) {
    IOSurfaceSetValue(this, v6, v5);
  }
  else {
    IOSurfaceRemoveValue(this, v6);
  }
  *(_WORD *)uint64_t v8 = 0;
  CA::Render::iosurface_color_tags_for_colorspace(space, (CGColorSpace *)&v8[1], v8, v7);
  IOSurfaceSetBulkAttachments2();
  if (v5) {
    CFRelease(v5);
  }
}

CFStringRef CA::Render::iosurface_color_tags_for_colorspace(CGColorSpaceRef space, CGColorSpace *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  CFStringRef result = 0;
  if (space)
  {
    if (a2)
    {
      if (a3)
      {
        CFStringRef result = CGColorSpaceGetName(space);
        if (result)
        {
          CFStringRef v8 = result;
          if (CFEqual(result, (CFTypeRef)*MEMORY[0x1E4F1DC58]))
          {
            char v9 = 1;
            unsigned __int8 v10 = 1;
LABEL_13:
            *(unsigned char *)a2 = v9;
            *a3 = v10;
            return (CFStringRef)1;
          }
          if (CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DC28]))
          {
            unsigned __int8 v10 = 1;
LABEL_9:
            char v9 = 9;
            goto LABEL_13;
          }
          if (CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DC68]))
          {
            unsigned __int8 v10 = 16;
LABEL_12:
            char v9 = 1;
            goto LABEL_13;
          }
          if (CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DC50]))
          {
            unsigned __int8 v10 = 16;
            goto LABEL_9;
          }
          if (CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DC98]) || CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DBE8]))
          {
            unsigned __int8 v10 = 13;
            goto LABEL_12;
          }
          if (CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DC88]) || CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DBE0]))
          {
            unsigned __int8 v10 = 8;
            goto LABEL_12;
          }
          if (CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DB90]))
          {
            unsigned __int8 v10 = 13;
LABEL_31:
            char v9 = 12;
            goto LABEL_13;
          }
          if (CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DBC8]))
          {
            unsigned __int8 v10 = 8;
            goto LABEL_31;
          }
          if (CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DBA0]))
          {
            unsigned __int8 v10 = 16;
            goto LABEL_31;
          }
          if (CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DB98]))
          {
            unsigned __int8 v10 = 18;
            goto LABEL_31;
          }
          if (CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DBD8]))
          {
            unsigned __int8 v10 = 8;
            goto LABEL_9;
          }
          if (CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DC48]))
          {
            unsigned __int8 v10 = 18;
            goto LABEL_9;
          }
          CFStringRef result = (CFStringRef)CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1DC40]);
          if (result)
          {
            unsigned __int8 v10 = 13;
            goto LABEL_9;
          }
        }
      }
    }
  }
  return result;
}

uint64_t ___ZL23CALayerDecodeAnimationsP7CALayerP7NSCoder_block_invoke()
{
  id v0 = objc_alloc(MEMORY[0x1E4F1CAD0]);
  uint64_t v1 = objc_opt_class();
  uint64_t result = objc_msgSend(v0, "initWithObjects:", v1, objc_opt_class(), 0);
  CALayerDecodeAnimations(CALayer *,NSCoder *)::keys_classes = result;
  return result;
}

void CA::OGL::MetalContext::end_new_render_pipeline(CA::OGL::MetalContext *this, os_signpost_id_t a2, char *a3, int a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return;
  }
  char v5 = (char)a3;
  uint64_t v7 = (CA::OGL::MetalContext *)(*((_WORD *)this + 416) & 1 | a3);
  *(void *)__str = 0;
  CA::OGL::MetalContext::format_new_pipeline_flags_string(v7, __str, a3);
  if (CA::OGL::MetalContext::get_pipeline_log(void)::pipeline_once != -1) {
    dispatch_once(&CA::OGL::MetalContext::get_pipeline_log(void)::pipeline_once, &__block_literal_global_307);
  }
  CFStringRef v8 = CA::OGL::MetalContext::get_pipeline_log(void)::pipeline_log;
  if ((v5 & 0x20) == 0) {
    goto LABEL_10;
  }
  if (CA::OGL::MetalContext::get_pipeline_stall_log(void)::pipeline_stall_once[0] != -1) {
    dispatch_once(CA::OGL::MetalContext::get_pipeline_stall_log(void)::pipeline_stall_once, &__block_literal_global_310);
  }
  if (a2 != -1)
  {
    char v9 = CA::OGL::MetalContext::get_pipeline_stall_log(void)::pipeline_stall_log;
    if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::get_pipeline_stall_log(void)::pipeline_stall_log))
    {
      int v10 = 136446210;
      unint64_t v11 = __str;
      _os_signpost_emit_with_name_impl(&dword_184668000, v9, OS_SIGNPOST_INTERVAL_END, a2, "NewRenderPipeline", "flags=%{public, name=flags}s", (uint8_t *)&v10, 0xCu);
    }
LABEL_10:
    if (a4)
    {
      if (a2 != -1 && os_signpost_enabled(v8))
      {
        int v10 = 136446210;
        unint64_t v11 = __str;
        _os_signpost_emit_unreliably_with_name_impl();
      }
    }
    else if (a2 != -1 && os_signpost_enabled(v8))
    {
      int v10 = 136446210;
      unint64_t v11 = __str;
      _os_signpost_emit_with_name_impl(&dword_184668000, v8, OS_SIGNPOST_INTERVAL_END, a2, "NewRenderPipeline", "flags=%{public, name=flags, signpost.telemetry:string2}s enableTelemetry=YES ", (uint8_t *)&v10, 0xCu);
    }
  }
}

uint64_t CA::OGL::MetalContext::format_new_pipeline_flags_string(CA::OGL::MetalContext *this, char *__str, char *a3)
{
  uint64_t v3 = "a";
  CFStringRef v4 = "";
  if ((this & 1) == 0) {
    uint64_t v3 = "";
  }
  char v5 = "p";
  if ((this & 2) == 0) {
    char v5 = "";
  }
  CFStringRef v6 = "l";
  if ((this & 4) == 0) {
    CFStringRef v6 = "";
  }
  uint64_t v7 = "r";
  if ((this & 0x80) == 0) {
    uint64_t v7 = "";
  }
  CFStringRef v8 = "w";
  if ((this & 8) == 0) {
    CFStringRef v8 = "";
  }
  char v9 = "c";
  if ((this & 0x10) == 0) {
    char v9 = "";
  }
  int v10 = "s";
  if ((this & 0x20) == 0) {
    int v10 = "";
  }
  if ((this & 0x40) != 0) {
    CFStringRef v4 = "e";
  }
  return snprintf(__str, 8uLL, "%s%s%s%s%s%s%s%s", v3, v5, v6, v7, v8, v9, v10, v4);
}

uint64_t CA::WindowServer::IOMFBDisplay::surface_is_replaceable(CA::WindowServer::IOMFBDisplay *this, int a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::WindowServer::IOMFBDisplay::_displays_lock);
  size_t v2 = *(void **)CA::WindowServer::IOMFBDisplay::_displays;
  uint64_t v3 = *(void **)(CA::WindowServer::IOMFBDisplay::_displays + 8);
  if (*(void **)CA::WindowServer::IOMFBDisplay::_displays == v3)
  {
LABEL_18:
    uint64_t v15 = 1;
    goto LABEL_19;
  }
  unsigned int v16 = *(void **)(CA::WindowServer::IOMFBDisplay::_displays + 8);
  while (1)
  {
    uint64_t v4 = *v2;
    if ((*(unsigned int (**)(void))(*(void *)*v2 + 216))(*v2)) {
      break;
    }
LABEL_17:
    if (++v2 == v3) {
      goto LABEL_18;
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 25720));
  uint64_t v5 = *(unsigned int *)(v4 + 25712);
  if (!v5)
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 25720));
    goto LABEL_17;
  }
  int v6 = 0;
  uint64_t v7 = *(unsigned int *)(v4 + 25704);
  char v8 = 1;
  uint64_t v9 = *(unsigned int *)(v4 + 25712);
  do
  {
    if (v7 == v5) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = v7;
    }
    if (*(_DWORD *)(v4 + 48 * v10 + 25784))
    {
      if (*(_DWORD *)(v4 + 48 * v10 + 25808))
      {
        uint64_t v11 = *(void *)(v4 + 48 * v10 + 25800);
        if (v11)
        {
          int v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 184))(v11);
          char v13 = v6 | v8;
          v6 |= v12 == a2;
          char v8 = (v12 != a2) & v13;
        }
      }
    }
    uint64_t v7 = v10 + 1;
    --v9;
  }
  while (v9);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 25720));
  uint64_t v3 = v16;
  if (v8) {
    goto LABEL_17;
  }
  uint64_t v15 = 0;
LABEL_19:
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::WindowServer::IOMFBDisplay::_displays_lock);
  return v15;
}

void *CA::WindowServer::IOMFBDisplay::activate_replay_(void *this)
{
  uint64_t v1 = this;
  size_t v2 = this + 3242;
  uint64_t v3 = this[3304];
  if (v3)
  {
    uint64_t v4 = (uint64_t *)(v3 + 32);
    this = *(void **)(v3 + 32);
    if (!this)
    {
      *((unsigned char *)v2 + 2228) = 0;
LABEL_20:
      --*(_DWORD *)(v3 + 8);
      v1[3304] = 0;
      return this;
    }
  }
  else
  {
    uint64_t v7 = (uint64_t *)this[3254];
    if (!v7)
    {
LABEL_12:
      *((unsigned char *)v2 + 2228) = 0;
      return this;
    }
    while (1)
    {
      this = (void *)v7[4];
      if (this)
      {
        if (!*((_DWORD *)v7 + 2)) {
          break;
        }
      }
      uint64_t v7 = (uint64_t *)*v7;
      if (!v7) {
        goto LABEL_12;
      }
    }
    *((_DWORD *)v7 + 2) = 1;
    v1[3304] = v7;
    uint64_t v4 = v7 + 4;
  }
  uint64_t v5 = (uint64_t *)this[2];
  if (v5 && v5[1])
  {
    (*(void (**)(void *))(*this + 160))(this);
    int v6 = (_DWORD *)v5[8];
    if (v6) {
      CA::WindowServer::SharedEvent::History::add(v6, *v5, 13, 1, 2, v5[2]);
    }
    CA::WindowServer::SharedEvent::inc_signal_value((uint64_t)v5, 13, 2);
    this = (void *)IOMobileFramebufferSetIdleBufferEvent();
  }
  else
  {
    (*(void (**)(void *))(*this + 160))(this);
    this = (void *)IOMobileFramebufferSetIdleBuffer();
  }
  int v8 = (int)this;
  uint64_t v9 = (unsigned int *)(*v4 + 224);
  uint64_t v10 = *v9;
  unint64_t v11 = v10 | ((unint64_t)*(unsigned __int8 *)(*v4 + 228) << 32) | 0x200000000;
  *uint64_t v9 = v10;
  *((unsigned char *)v9 + 4) = BYTE4(v11);
  if (BYTE9(xmmword_1EB2ACC10))
  {
    (*(void (**)(void))(*(void *)*v4 + 184))();
    this = (void *)kdebug_trace();
    if (v8) {
      goto LABEL_16;
    }
LABEL_23:
    *((unsigned char *)v2 + 2228) = 1;
    *(_DWORD *)size_t v2 = 0;
    return this;
  }
  if (!this) {
    goto LABEL_23;
  }
LABEL_16:
  if (!*((unsigned char *)v2 + 2228))
  {
    uint64_t v3 = v1[3304];
    if (v3) {
      goto LABEL_20;
    }
  }
  return this;
}

uint64_t CA::WindowServer::IOSurface::id(CA::WindowServer::IOSurface *this)
{
  return *((unsigned int *)this + 62);
}

_DWORD *CA::Render::MatchAnimation::was_added(_DWORD *this, CA::Render::Handle *a2)
{
  size_t v2 = this;
  v5[1] = *MEMORY[0x1E4F143B8];
  int v3 = this[3];
  if ((v3 & 0x1000) != 0)
  {
    *((void *)a2 + 12) |= 8uLL;
    int v3 = this[3];
  }
  if ((v3 & 0x2000) != 0) {
    *((void *)a2 + 12) |= 0x10uLL;
  }
  if (!*((void *)this + 16))
  {
    if (this[28])
    {
      if (*((void *)this + 13))
      {
        uint64_t v4 = (*(uint64_t (**)(_DWORD *, CA::Render::Handle *))(*(void *)this + 160))(this, a2);
        *((void *)v2 + 16) = v4;
        CA::Render::Handle::add_dependence(v4);
        v5[0] = 0;
        CA::Render::Handle::Dependence::retain_source_handle((CA::Render::Handle::Dependence *)v5, *((void *)v2 + 16));
        this = (_DWORD *)v5[0];
        if (v5[0])
        {
          *(void *)(v5[0] + 96) |= 8uLL;
          if (atomic_fetch_add(this + 2, 0xFFFFFFFF) == 1) {
            return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)this + 16))(this);
          }
        }
      }
    }
  }
  return this;
}

uint64_t CA::Render::Handle::add_dependence(uint64_t a1)
{
  uint64_t v2 = CA::Render::Context::context_by_id((CA::Render::Context *)*(unsigned int *)(a1 + 8));
  uint64_t result = *(unsigned int *)(a1 + 12);
  if (*(_DWORD *)(a1 + 8) == result)
  {
    if (!v2) {
      return result;
    }
    uint64_t v4 = v2;
    if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
    {
      uint64_t v4 = 0;
      atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 0xFFFFFFFF);
    }
  }
  else
  {
    uint64_t result = CA::Render::Context::context_by_id((CA::Render::Context *)result);
    uint64_t v4 = result;
    if (!v2)
    {
      if (!result) {
        return result;
      }
      char v7 = 1;
      goto LABEL_12;
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 72));
  uint64_t v5 = CA::Render::Context::lookup_handle((CA::Render::Context *)v2, *(CA::Render::Object **)(a1 + 16), 0, 1, 0);
  if (v5)
  {
    *(void *)(a1 + 32) = *((void *)v5 + 7);
    *((void *)v5 + 7) = a1;
    CA::Render::Handle::update_container_state((uint64_t)v5, v6);
  }
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v2 + 72));
  if (!v4) {
    goto LABEL_17;
  }
  char v7 = 0;
LABEL_12:
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 72));
  int v8 = CA::Render::Context::lookup_handle((CA::Render::Context *)v4, *(CA::Render::Object **)(a1 + 24), 0, 1, 0);
  if (v8)
  {
    *(void *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *((void *)v8 + 8);
    *((void *)v8 + 8) = a1;
    CA::Render::Handle::update_container_state((uint64_t)v8, v9);
  }
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v4 + 72));
  if (atomic_fetch_add((atomic_uint *volatile)(v4 + 8), 0xFFFFFFFF) == 1) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  }
  if ((v7 & 1) == 0)
  {
LABEL_17:
    if (atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 0xFFFFFFFF) == 1)
    {
      uint64_t v10 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 16);
      return v10(v2);
    }
  }
  return result;
}

uint64_t CA::Render::Handle::Dependence::retain_source_handle(CA::Render::Handle::Dependence *this, uint64_t a2)
{
  uint64_t result = CA::Render::Context::context_by_id((CA::Render::Context *)*(unsigned int *)(a2 + 8));
  *(void *)this = 0;
  if (result)
  {
    uint64_t v5 = (atomic_uint *)result;
    int v6 = (pthread_mutex_t *)(result + 72);
    pthread_mutex_lock((pthread_mutex_t *)(result + 72));
    char v7 = CA::Render::Context::lookup_handle((CA::Render::Context *)v5, *(CA::Render::Object **)(a2 + 16), 0, 0, 0);
    if (v7)
    {
      int v8 = (atomic_uint *)((char *)v7 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)v7 + 2, 1u))
      {
        char v7 = 0;
        atomic_fetch_add(v8, 0xFFFFFFFF);
      }
      *(void *)this = v7;
    }
    uint64_t result = pthread_mutex_unlock(v6);
    if (atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1)
    {
      uint64_t v9 = *(uint64_t (**)(atomic_uint *))(*(void *)v5 + 16);
      return v9(v5);
    }
  }
  return result;
}

int8x16_t CA::Render::MatchMoveAnimation::create_dependence(int8x16_t *this, CA::Render::Handle *a2)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v5 = (int8x16_t *)malloc_type_zone_malloc(malloc_zone, 0x38uLL, 0x8BB15036uLL);
  if (v5)
  {
    __int32 v7 = *(_DWORD *)(*((void *)a2 + 3) + 16);
    v5->i32[2] = this[7].i32[0];
    v5->i32[3] = v7;
    int8x16_t result = vextq_s8(this[6], this[6], 8uLL);
    v5[1] = result;
    v5[2].i64[0] = 0;
    v5[2].i64[1] = 0;
    v5[3].i64[0] = (uint64_t)this;
    v5->i64[0] = (uint64_t)&unk_1ED02EBB8;
  }
  return result;
}

id image_properties_dictionary(int a1)
{
  v7[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *MEMORY[0x1E4F2FF30];
  v6[0] = *MEMORY[0x1E4F2FF08];
  v6[1] = v2;
  v7[0] = MEMORY[0x1E4F1CC38];
  v7[1] = MEMORY[0x1E4F1CC38];
  int v3 = (void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v7 forKeys:v6 count:2];
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v4 = (void *)[v3 mutableCopy];
    [v4 setObject:*MEMORY[0x1E4F2FE68] forKeyedSubscript:*MEMORY[0x1E4F2FE58]];
    [v4 setObject:&unk_1ED057350 forKeyedSubscript:*MEMORY[0x1E4F2FE60]];
  }
  return v4;
}

__IOSurface *CAIOSurfaceCreateDefault(unsigned int a1, int a2, CA::Render *this)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (CADeviceUseCompression::once[0] != -1) {
    dispatch_once(CADeviceUseCompression::once, &__block_literal_global_21);
  }
  if (CADeviceUseCompression::enable_compression)
  {
    if (CADeviceSupportsUniversalCompression::once != -1) {
      dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
    }
    if (CADeviceSupportsUniversalCompression::universal) {
      int v6 = 3;
    }
    else {
      int v6 = 2;
    }
    this = (CA::Render *)CA::Render::fourcc_compressed_of_type(this, v6, 0);
  }
  uint64_t v7 = *MEMORY[0x1E4F14B00];
  long long v9 = xmmword_184997CD0;
  uint64_t v10 = 1;
  uint64_t v11 = v7;
  uint64_t v12 = 0;
  return CA::SurfaceUtil::CAIOSurfaceCreate(a1, a2, (uint64_t)this, 0, 0, 0, 0, &v9, 0);
}

void __CADeviceSupportsUniversalCompression_block_invoke()
{
  CFDictionaryRef v0 = (const __CFDictionary *)MGCopyAnswer();
  if (v0)
  {
    CFDictionaryRef v1 = v0;
    Boolean Value = CFDictionaryGetValue(v0, @"universal-buffer-compression");
    if (Value) {
      LOBYTE(Value) = CA_CFBoolValue(Value);
    }
    CADeviceSupportsUniversalCompression::universal = (char)Value;
    CFRelease(v1);
  }
}

void sub_1847D1C98(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

dispatch_queue_t ___ZN2CA6Render5FenceL24_observer_callback_queueEv_block_invoke()
{
  CFDictionaryRef v0 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
  dispatch_queue_t result = dispatch_queue_create("CA::Fence::Observer", v0);
  CA::Render::Fence::_observer_callback_queue(void)::q = (uint64_t)result;
  return result;
}

void _XDeleteClient(_DWORD *a1, uint64_t a2)
{
  void v6[5] = *MEMORY[0x1E4F143B8];
  if ((*a1 & 0x80000000) != 0 || a1[1] != 24)
  {
    int v3 = -304;
    goto LABEL_7;
  }
  if (a1[6] || a1[7] <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return;
  }
  uint64_t v4 = (CA::Render::Context *)CA::Render::Context::context_by_server_port((CA::Render::Context *)a1[3]);
  if (v4)
  {
    uint64_t v5 = v4;
    CA::Render::Context::destroy(v4);
    if (dealloc_queue(void)::once != -1) {
      dispatch_once(&dealloc_queue(void)::once, &__block_literal_global_7507);
    }
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    void v6[2] = __CASDeleteClient_block_invoke;
    v6[3] = &__block_descriptor_tmp_83;
    v6[4] = v5;
    dispatch_async((dispatch_queue_t)dealloc_queue(void)::queue, v6);
  }
  *(_DWORD *)(a2 + 32) = 0;
}

void CA::Render::Context::destroy(CA::Render::Context *this)
{
  v63[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 72);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 72));
  int v3 = *((_DWORD *)this + 3);
  if ((v3 & 0x400) == 0)
  {
    *((_DWORD *)this + 3) = v3 | 0x400;
    CA::Render::Context::set_layer_id((uint64_t)this, 0);
    pthread_mutex_unlock(v2);
    CA::Render::Fence::remove_context(this, (CA::Render::Context *)1);
    if (!*((void *)this + 52) && !*((void *)this + 53)) {
      goto LABEL_49;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
    CA::Render::Context::update_backdrop_namespaces_locked((uint64_t)this, 0);
    uint64_t v4 = (void *)*((void *)this + 52);
    if (v4 && (CA::Render::Context *)v4[9] == this)
    {
      CA::Render::Context::set_visible_locked(this, 0);
      v4[9] = 0;
      int v6 = (atomic_uint *)v4[4];
      if (v6)
      {
        if (atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
        }
        v4[4] = 0;
      }
      *((void *)this + 52) = 0;
      unint64_t v5 = v4[10];
      if (v5)
      {
        uint64_t v7 = (atomic_uint *)(v5 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)(v5 + 8), 1u))
        {
          unint64_t v5 = 0;
          atomic_fetch_add(v7, 0xFFFFFFFF);
        }
        *(void *)(v4[10] + 424) = x_list_remove(*(void **)(v4[10] + 424), (uint64_t)v4);
        v4[10] = 0;
      }
      atomic_fetch_add(CA::Render::LayerHost::_seed, 1u);
    }
    else
    {
      unint64_t v5 = 0;
    }
    int v8 = (uint64_t *)*((void *)this + 53);
    if (v8)
    {
      v63[0] = v2;
      long long v9 = 0;
      do
      {
        uint64_t v10 = *v8;
        *(void *)(v10 + 8CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
        uint64_t v11 = *(void *)(v10 + 72);
        if (v11)
        {
          CA::Render::Context::set_visible_locked(*(CA::Render::Context **)(v10 + 72), 0);
          *(void *)(v11 + 416) = 0;
          uint64_t v12 = (atomic_uint *)(v11 + 8);
          if (!atomic_fetch_add((atomic_uint *volatile)(v11 + 8), 1u))
          {
            uint64_t v11 = 0;
            atomic_fetch_add(v12, 0xFFFFFFFF);
          }
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          int32x2_t v14 = (CA::Render **)malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
          *int32x2_t v14 = (CA::Render *)v11;
          v14[1] = (CA::Render *)v9;
          *(void *)(v10 + 72) = 0;
          uint64_t v15 = *(atomic_uint **)(v10 + 32);
          if (v15)
          {
            if (atomic_fetch_add(v15 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v15 + 16))(v15);
            }
            *(void *)(v10 + 32) = 0;
          }
          atomic_fetch_add(CA::Render::LayerHost::_seed, 1u);
          long long v9 = v14;
        }
        int v8 = (uint64_t *)v8[1];
      }
      while (v8);
      unsigned int v16 = (void *)*((void *)this + 53);
      uint64_t v2 = (pthread_mutex_t *)v63[0];
      if (v16)
      {
        do
        {
          uint64_t v17 = (void *)v16[1];
          free(v16);
          unsigned int v16 = v17;
        }
        while (v17);
      }
      *((void *)this + 53) = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
      if (v9)
      {
        unint64_t v19 = v9;
        do
        {
          CA::Render::invalidate_context(*v19, v18);
          int v20 = *v19;
          if (atomic_fetch_add((atomic_uint *volatile)*v19 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(CA::Render *))(*(void *)v20 + 16))(v20);
          }
          unint64_t v19 = (CA::Render **)v19[1];
        }
        while (v19);
        do
        {
          uint8x8_t v21 = (CA::Render **)v9[1];
          free(v9);
          long long v9 = v21;
        }
        while (v21);
      }
      if (!v5)
      {
LABEL_49:
        CA::Render::post_notification(2u, (unint64_t)this, 0, 1);
        CA::Render::remove_every_observer(this, v28);
        os_unfair_lock_lock(&CA::Render::Context::_context_lock);
        uint64_t v29 = x_hash_table_remove(CA::Render::Context::_context_table, *((unsigned int *)this + 4));
        uint64_t v30 = *((void *)this + 21);
        size_t v31 = (unsigned int *)*((void *)this + 22);
        unint64_t v32 = (unint64_t)v31 - v30;
        if (v31 == (unsigned int *)v30)
        {
          mach_error_t v33 = 0;
        }
        else
        {
          if (v32 > 0x1000)
          {
            mach_error_t v33 = (char *)malloc_type_malloc((size_t)v31 - v30, 0x761F9D16uLL);
            uint64_t v30 = *((void *)this + 21);
            size_t v31 = (unsigned int *)*((void *)this + 22);
          }
          else
          {
            MEMORY[0x1F4188790](v29);
            mach_error_t v33 = (char *)v63 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0);
            bzero(v33, (size_t)v31 - v30);
          }
          if ((unsigned int *)v30 != v31)
          {
            uint64_t v34 = 0;
            int v35 = (unsigned int *)v30;
            do
            {
              uint64_t v36 = v34;
              unsigned int v37 = *v35;
              v35 += 2;
              ++v34;
              *(void *)&v33[8 * v36] = x_hash_table_remove(CA::Render::Context::_slot_table, v37);
              CA::Render::post_notification(0x3Au, 0, v30, 0);
              uint64_t v30 = (uint64_t)v35;
            }
            while (v35 != v31);
            goto LABEL_59;
          }
        }
        uint64_t v34 = 0;
LABEL_59:
        mach_port_name_t v38 = *((_DWORD *)this + 62);
        uint8x8_t v39 = (ipc_space_t *)MEMORY[0x1E4F14960];
        if (v38)
        {
          mach_port_mod_refs(*MEMORY[0x1E4F14960], v38, 1u, -1);
          mach_port_deallocate(*v39, *((_DWORD *)this + 62));
          x_hash_table_remove(CA::Render::Context::_port_table, *((unsigned int *)this + 62));
          *((_DWORD *)this + 62) = 0;
        }
        os_unfair_lock_unlock(&CA::Render::Context::_context_lock);
        os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Context::_image_queues_lock);
        uint64_t v40 = (uint64_t *)*((void *)this + 45);
        __int16 v41 = (uint64_t *)*((void *)this + 46);
        if (v40 != v41)
        {
          unint64_t v42 = (uint64_t *)*((void *)this + 45);
          do
          {
            uint64_t v43 = *v42++;
            *(void *)(v43 + 232) = 0;
          }
          while (v42 != v41);
        }
        *((void *)this + 46) = v40;
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Context::_image_queues_lock);
        pthread_mutex_lock(v2);
        if (v34)
        {
          unint64_t v45 = (atomic_uint **)v33;
          do
          {
            unint64_t v46 = *v45;
            if (*v45 && atomic_fetch_add(v46 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v46 + 16))(v46);
            }
            ++v45;
            --v34;
          }
          while (v34);
        }
        CA::Render::Context::ResourceTable::remove_all((CA::Render::Context *)((char *)this + 136), v44);
        os_unfair_lock_lock((os_unfair_lock_t)this + 13);
        while (1)
        {
          uint64_t v47 = (_DWORD *)*((void *)this + 7);
          if (!v47) {
            break;
          }
          *((void *)this + 7) = *(void *)v47;
          mach_port_deallocate(*v39, v47[2]);
          mach_port_name_t v48 = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(v48, v47);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)this + 13);
        os_unfair_lock_lock((os_unfair_lock_t)this + 170);
        if (*((void *)this + 90))
        {
          uint64_t v49 = (void *)*((void *)this + 89);
          if (v49)
          {
            do
            {
              uint64_t v50 = (void *)*v49;
              operator delete(v49);
              uint64_t v49 = v50;
            }
            while (v50);
          }
          *((void *)this + 89) = 0;
          uint64_t v51 = *((void *)this + 88);
          if (v51)
          {
            for (uint64_t i = 0; i != v51; ++i)
              *(void *)(*((void *)this + 87) + 8 * i) = 0;
          }
          *((void *)this + 9CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
        }
        while (1)
        {
          uint64_t v57 = (void *)*((void *)this + 86);
          if (!v57) {
            break;
          }
          *((void *)this + 86) = *v57;
          uint64_t v53 = v57[3];
          if (v53) {
            (*(void (**)(uint64_t))(*(void *)v53 + 8))(v53);
          }
          uint64_t v54 = v57[1];
          if (v54)
          {
            uint64_t v55 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v54);
            MEMORY[0x185323DC0](v55, 0x10A0C408EF24B1CLL);
          }
          size_t v56 = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(v56, v57);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)this + 170);
        mach_port_name_t v58 = *((_DWORD *)this + 63);
        if (v58)
        {
          mach_port_deallocate(*v39, v58);
          *((_DWORD *)this + 63) = 0;
        }
        mach_port_name_t v59 = *((_DWORD *)this + 64);
        if (v59)
        {
          mach_port_deallocate(*v39, v59);
          *((_DWORD *)this + 64) = 0;
        }
        mach_port_name_t v60 = *((_DWORD *)this + 65);
        if (v60)
        {
          mach_port_deallocate(*v39, v60);
          *((_DWORD *)this + 65) = 0;
        }
        mach_port_name_t v61 = *((_DWORD *)this + 66);
        if (v61)
        {
          mach_port_deallocate(*v39, v61);
          *((_DWORD *)this + 66) = 0;
        }
        pthread_mutex_unlock(v2);
        if (v32 > 0x1000) {
          free(v33);
        }
        if (atomic_fetch_add((atomic_uint *volatile)this + 2, 0xFFFFFFFF) == 1)
        {
          mach_port_name_t v62 = *(void (**)(CA::Render::Context *))(*(void *)this + 16);
          v62(this);
        }
        return;
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerHost::_lock);
      if (!v5) {
        goto LABEL_49;
      }
    }
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 72));
    unint64_t v22 = (int32x2_t *)CA::Render::Context::root_layer_handle((CA::Render::Context *)v5);
    if (v22)
    {
      *(void *)&v22[12] |= 8uLL;
      CA::Render::Context::invalidate((CA::Render::Context *)v5, v22 + 14, v23);
    }
    uint64_t v24 = (CA::Shape **)CA::Render::Context::copy_dirty_shape(this);
    if (v24)
    {
      float v26 = (CA::Shape *)v24;
      CA::Render::Context::invalidate((CA::Render::Context *)v5, v24, v25);
      CA::Shape::unref(v26);
      pthread_mutex_lock(v2);
      float v27 = (CA::Shape *)*((void *)this + 72);
      if (v27) {
        CA::Shape::unref(v27);
      }
      *((void *)this + 72) = 1;
      pthread_mutex_unlock(v2);
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 72));
    CA::Render::Context::mark_changed(v5, 0, 0, 0, 0);
    if (atomic_fetch_add((atomic_uint *volatile)(v5 + 8), 0xFFFFFFFF) == 1) {
      (*(void (**)(unint64_t))(*(void *)v5 + 16))(v5);
    }
    goto LABEL_49;
  }

  pthread_mutex_unlock(v2);
}

void CA::Render::Fence::remove_context(CA::Render::Fence *this, CA::Render::Context *a2)
{
  int v2 = (int)a2;
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (CA::Render::Fence::fence_info_once[0] != -1) {
    dispatch_once_f(CA::Render::Fence::fence_info_once, 0, (dispatch_function_t)CA::Render::Fence::fence_info_init);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Fence::_lock);
  size_t v4 = *((unsigned int *)this + 4);
  unint64_t v5 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::fcontexts_by_id, v4);
  if (v5)
  {
    int v6 = v5;
    memset(v38, 0, sizeof(v38));
    uint64_t v39 = 1065353216;
    uint64_t v7 = *(atomic_uint **)(v5[3] + 8);
    int v8 = *(void **)v7;
    long long v9 = (void *)*((void *)v7 + 1);
    if (*(void **)v7 == v9) {
      goto LABEL_9;
    }
    do
    {
      for (uint64_t i = (void *)v8[2]; i; uint64_t i = (void *)*i)
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)v38, i[2], i[2]);
      v8 += 5;
    }
    while (v8 != v9);
    uint64_t v11 = (atomic_uint **)v6[3];
    uint64_t v7 = v11[1];
    if (v7)
    {
LABEL_9:
      unsigned int v37 = v7;
      std::vector<std::unordered_set<unsigned long long>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v37);
      MEMORY[0x185323DC0](v7, 0x20C40960023A9);
      uint64_t v11 = (atomic_uint **)v6[3];
    }
    uint64_t v12 = *v11;
    if (*v11)
    {
      if (atomic_fetch_add(v12 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v12 + 16))(v12);
      }
      uint64_t v11 = (atomic_uint **)v6[3];
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v11);
    int32x2_t v14 = (uint64_t *)std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase((void *)CA::Render::Fence::fcontexts_by_id, v6);
    uint64_t v15 = *(uint64_t **)CA::Render::Fence::transactions;
    unsigned int v16 = *(uint64_t **)(CA::Render::Fence::transactions + 8);
    while (v15 != v16)
    {
      uint64_t v17 = *v15;
      unint64_t v18 = *(void **)(*v15 + 8);
      int32x2_t v14 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v18, v4);
      if (v14)
      {
        int32x2_t v14 = (uint64_t *)std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::erase(v18, v14);
        if ((v2 & 1) == 0) {
          CA::Render::Fence::send_rmfc_msg(*(unsigned int *)(v17 + 16), v4, (uint64_t)v38);
        }
      }
      ++v15;
    }
    CA::Render::Fence::resolve_fences((CA::Render::Fence *)v14);
    std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v38);
  }
  if (v2)
  {
    for (uint64_t j = *(void **)(CA::Render::Fence::batches_by_port + 16); j; uint64_t j = (void *)*j)
    {
      uint64_t v20 = j[3];
      uint8x8_t v21 = *(void **)(v20 + 32);
      unint64_t v22 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v21, v4);
      if (v22)
      {
        std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::erase(v21, v22);
        uint64_t v20 = j[3];
      }
      float64x2_t v23 = *(void **)(v20 + 24);
      uint64_t v24 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v23, v4);
      if (v24)
      {
        unint64_t v25 = v24;
        if (*(unsigned char *)(v20 + 44))
        {
          kdebug_trace();
          float64x2_t v23 = *(void **)(j[3] + 24);
        }
        std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::erase(v23, v25);
      }
    }
    float v26 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)CA::Render::Fence::bcontexts_by_id, v4);
    if (v26)
    {
      float v27 = v26;
      BOOL v28 = (atomic_uint **)v26[3];
      uint64_t v29 = v28[1];
      if (v29)
      {
        *(void *)&v38[0] = v28[1];
        std::vector<std::unordered_set<unsigned long long>>::__destroy_vector::operator()[abi:nn180100]((void ***)v38);
        MEMORY[0x185323DC0](v29, 0x20C40960023A9);
        BOOL v28 = (atomic_uint **)v27[3];
      }
      uint64_t v30 = (uint64_t)v28[2];
      if (v30)
      {
        uint64_t v31 = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v30);
        MEMORY[0x185323DC0](v31, 0x10A0C408EF24B1CLL);
        BOOL v28 = (atomic_uint **)v27[3];
      }
      unint64_t v32 = *v28;
      if (*v28)
      {
        if (atomic_fetch_add(v32 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v32 + 16))(v32);
        }
        BOOL v28 = (atomic_uint **)v27[3];
      }
      mach_error_t v33 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v33, v28);
      std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::erase((void *)CA::Render::Fence::bcontexts_by_id, v27);
      uint64_t v34 = mach_absolute_time();
      double v35 = CATimeWithHostTime(v34);
      CA::Render::Fence::resolve_batches(v36, v35);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Fence::_lock);
}

void CA::Render::remove_every_observer(CA::Render *this, void *a2)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::notification_lock);
  if ((CA::Render::initialize_notifications(void)::initialized & 1) == 0)
  {
    uint64_t v15 = 0;
    unsigned int v16 = (int64x2_t *)CA::Render::notifications;
    do
    {
      uint64_t v17 = (char *)&CA::Render::notifications_map_data[v15];
      *(_OWORD *)uint64_t v17 = 0uLL;
      *((_OWORD *)v17 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0uLL;
      *((_DWORD *)v17 + 8) = 1065353216;
      *unsigned int v16 = vdupq_n_s64((unint64_t)v16);
      ++v16;
      v15 += 5;
    }
    while (v15 != 370);
    CA::Render::initialize_notifications(void)::initialized = 1;
  }
  size_t v4 = 0;
  for (uint64_t i = 0; i != 74; ++i)
  {
    int v6 = &CA::Render::notifications[i];
    uint64_t v7 = (long long *)*((void *)v6 + 1);
    if (v7 != v6)
    {
      do
      {
        int v8 = (long long *)*((void *)v7 + 1);
        if (*((CA::Render **)v7 + 7) == this)
        {
          uint64_t v9 = *(void *)v7;
          *(void *)(v9 + 8) = v8;
          *(void *)int v8 = v9;
          *(void *)uint64_t v7 = v7;
          *((void *)v7 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v7;
          uint64_t v10 = *((void *)v7 + 2);
          uint64_t v11 = (void *)*((void *)v7 + 3);
          *(void *)(v10 + 8) = v11;
          *uint64_t v11 = v10;
          *((void *)v7 + 2) = v7 + 1;
          *((void *)v7 + 3) = v7 + 1;
          unint64_t v12 = *((void *)v7 + 6);
          if (v12)
          {
            int v3 = std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::find<CA::Render::Object *>(&CA::Render::notifications_map_data[5 * (int)i], v12);
            if (v3)
            {
              if ((void *)v3[4] == v3 + 3) {
                std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::erase(&CA::Render::notifications_map_data[5 * (int)i], v3);
              }
            }
          }
          int v3 = (void *)MEMORY[0x1F4188790](v3);
          v18[-2] = v7;
          v18[-1] = v4;
          size_t v4 = (dispatch_semaphore_t **)&v18[-2];
        }
        uint64_t v7 = v8;
      }
      while (v8 != v6);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::notification_lock);
  for (; v4; size_t v4 = (dispatch_semaphore_t **)v4[1])
  {
    uint64_t v13 = *v4;
    dispatch_semaphore_wait((*v4)[8], 0xFFFFFFFFFFFFFFFFLL);
    dispatch_semaphore_signal(v13[8]);
    dispatch_release(v13[8]);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v13);
  }
}

void CA::Render::Context::~Context(CA::Render::Context *this, CA::Render::Object *a2)
{
  CA::Render::Context::~Context(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  CA::Render::Context::ResourceTable *v3;
  CA::Shape *v4;
  CA::Shape *v5;
  const void *v6;
  const void *v7;
  void *i;
  atomic_uint *v9;
  void *v10;
  void *v11;
  void *v12;
  CA::Render::LayerNode *v13;
  const void *v14;
  void *v15;
  void *v16;
  atomic_uint *v17;
  void *v18;
  CA::Render::Object *v19;
  atomic_uint *v20;
  atomic_uint *v21;
  atomic_uint *v22;
  void *v23;
  void *v24;
  malloc_zone_t *malloc_zone;
  const CA::Render::Object *v26;

  *(void *)this = &unk_1ED02F880;
  int v3 = (CA::Render::Context *)((char *)this + 136);
  CA::Render::Context::ResourceTable::remove_all((CA::Render::Context *)((char *)this + 136), a2);
  size_t v4 = (CA::Shape *)*((void *)this + 72);
  if (v4) {
    CA::Shape::unref(v4);
  }
  unint64_t v5 = (CA::Shape *)*((void *)this + 71);
  if (v5) {
    CA::Shape::unref(v5);
  }
  int v6 = (const void *)*((void *)this + 4);
  if (v6) {
    CFRelease(v6);
  }
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 56));
  uint64_t v7 = (const void *)*((void *)this + 65);
  if (v7) {
    CFRelease(v7);
  }
  for (uint64_t i = (void *)*((void *)this + 41); i; uint64_t i = (void *)*i)
  {
    uint64_t v9 = (atomic_uint *)i[2];
    if (atomic_fetch_add(v9 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v9 + 16))(v9);
    }
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 72));
  uint64_t v10 = (void *)*((void *)this + 89);
  if (v10)
  {
    do
    {
      uint64_t v11 = (void *)*v10;
      operator delete(v10);
      uint64_t v10 = v11;
    }
    while (v11);
  }
  unint64_t v12 = (void *)*((void *)this + 87);
  *((void *)this + 87) = 0;
  if (v12) {
    operator delete(v12);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)this + 640);
  int32x2_t v14 = (const void *)*((void *)this + 66);
  if (v14) {
    CFRelease(v14);
  }
  uint64_t v15 = (void *)*((void *)this + 61);
  if (v15)
  {
    *((void *)this + 62) = v15;
    operator delete(v15);
  }
  unsigned int v16 = (void *)*((void *)this + 49);
  if (v16)
  {
    *((void *)this + 5CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v16;
    operator delete(v16);
  }
  uint64_t v17 = (atomic_uint *)*((void *)this + 48);
  if (v17 && atomic_fetch_add(v17 + 4, 0xFFFFFFFF) == 1) {
    CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v17, v13);
  }
  unint64_t v18 = (void *)*((void *)this + 45);
  if (v18)
  {
    *((void *)this + 46) = v18;
    operator delete(v18);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)this + 312);
  uint64_t v20 = (atomic_uint *)*((void *)this + 35);
  if (v20 && atomic_fetch_add(v20 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v20 + 16))(v20);
  }
  uint8x8_t v21 = (atomic_uint *)*((void *)this + 30);
  if (v21 && atomic_fetch_add(v21 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v21 + 16))(v21);
  }
  unint64_t v22 = (atomic_uint *)*((void *)this + 29);
  if (v22 && atomic_fetch_add(v22 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v22 + 16))(v22);
  }
  float64x2_t v23 = (void *)*((void *)this + 21);
  if (v23)
  {
    *((void *)this + 22) = v23;
    operator delete(v23);
  }
  CA::Render::Context::ResourceTable::remove_all(v3, v19);
  uint64_t v24 = (void *)*((void *)this + 17);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, v24);
  --dword_1EB2ADDF0;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, v26);
  }
}

void CA::Render::Context::ResourceTable::remove_all(CA::Render::Context::ResourceTable *this, CA::Render::Object *a2)
{
  unint64_t v3 = *((unsigned int *)this + 2);
  if (v3)
  {
    for (unint64_t i = 0; i < v3; ++i)
    {
      unint64_t v5 = *(void **)(*(void *)this + 8 * i);
      int v6 = v5;
      if (v5)
      {
        do
        {
          CA::Render::Context::ResourceTable::release_value((CA::Render::Context::ResourceTable *)v6[2], a2);
          int v6 = (void *)*v6;
        }
        while (v6);
        do
        {
          uint64_t v7 = (void *)*v5;
          free(v5);
          unint64_t v5 = v7;
        }
        while (v7);
        *(void *)(*(void *)this + 8 * i) = 0;
        unint64_t v3 = *((unsigned int *)this + 2);
      }
    }
  }
  *((void *)this + 3) = 0;
}

uint64_t _XCreateSlot(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 || *(_DWORD *)(result + 4) != 24)
  {
    int v3 = -304;
    goto LABEL_7;
  }
  if (*(_DWORD *)(result + 24) || *(_DWORD *)(result + 28) <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    uint64_t v4 = *MEMORY[0x1E4F14068];
LABEL_8:
    *(void *)(a2 + 24) = v4;
    return result;
  }
  unint64_t v5 = (CA::Render::Context *)*(unsigned int *)(result + 12);
  *(_DWORD *)(a2 + 36) = 0;
  dispatch_queue_t result = CA::Render::Context::context_by_server_port(v5);
  if (!result)
  {
    int v3 = 56;
    goto LABEL_7;
  }
  int v6 = (atomic_uint *)result;
  uint64_t v7 = (pthread_mutex_t *)(result + 72);
  pthread_mutex_lock((pthread_mutex_t *)(result + 72));
  *(_DWORD *)(a2 + 36) = CA::Render::Context::new_slot((CA::Render::Context *)v6);
  dispatch_queue_t result = pthread_mutex_unlock(v7);
  int v8 = *(_DWORD *)(a2 + 36);
  if (v8) {
    int v9 = 0;
  }
  else {
    int v9 = 5;
  }
  if (atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    dispatch_queue_t result = (*(uint64_t (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
  }
  *(_DWORD *)(a2 + 32) = v9;
  uint64_t v4 = *MEMORY[0x1E4F14068];
  if (!v8) {
    goto LABEL_8;
  }
  *(void *)(a2 + 24) = v4;
  *(_DWORD *)(a2 + 4) = 40;
  return result;
}

uint64_t CA::Render::Context::new_slot(CA::Render::Context *this)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock(&CA::Render::Context::_context_lock);
  if (!CA::Render::Context::_slot_table) {
    CA::Render::Context::_slot_table = (uint64_t)x_hash_table_new_(0, 0, 0, 0, 0, 0);
  }
  do
  {
    do
      uint64_t v2 = arc4random();
    while (!v2);
    uint64_t v3 = v2;
    v20[0] = 0;
    x_hash_table_lookup(CA::Render::Context::_slot_table, v2, v20);
  }
  while (LODWORD(v20[0]));
  hash_table_modify((int *)CA::Render::Context::_slot_table, v3, 0, 0);
  unint64_t v5 = (void *)*((void *)this + 22);
  unint64_t v4 = *((void *)this + 23);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = *((void *)this + 21);
    uint64_t v8 = ((uint64_t)v5 - v7) >> 3;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v9 = v4 - v7;
    uint64_t v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
      uint64_t v10 = v8 + 1;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11) {
      unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v11);
    }
    else {
      uint64_t v12 = 0;
    }
    unint64_t v13 = v11 + 8 * v8;
    unint64_t v14 = v11 + 8 * v12;
    *(void *)unint64_t v13 = v3;
    int v6 = (void *)(v13 + 8);
    unsigned int v16 = (unsigned char *)*((void *)this + 21);
    uint64_t v15 = (unsigned char *)*((void *)this + 22);
    if (v15 != v16)
    {
      do
      {
        int v17 = *((_DWORD *)v15 - 2);
        v15 -= 8;
        char v18 = v15[4];
        *(_DWORD *)(v13 - 8) = v17;
        v13 -= 8;
        *(unsigned char *)(v13 + 4) = v18;
      }
      while (v15 != v16);
      uint64_t v15 = (unsigned char *)*((void *)this + 21);
    }
    *((void *)this + 2CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v13;
    *((void *)this + 22) = v6;
    *((void *)this + 23) = v14;
    if (v15) {
      operator delete(v15);
    }
  }
  else
  {
    *unint64_t v5 = v3;
    int v6 = v5 + 1;
  }
  *((void *)this + 22) = v6;
  os_unfair_lock_unlock(&CA::Render::Context::_context_lock);
  return v3;
}

void CA::Render::PortalState::~PortalState(CA::Render::PortalState *this)
{
  CA::Render::PortalState::~PortalState(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  CA::Render::PortalState *v2;
  CA::Render::PortalState *v3;
  uint64_t *v4;
  const CA::Render::Object *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  char *v9;
  uint64_t v10;
  atomic_uint *v11;
  long long v12;
  long long v13;
  long long v14;
  long long v15;
  long long v16;
  long long v17;

  *(void *)this = &unk_1ED02D200;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::PortalState::_list_lock);
  uint64_t v2 = (CA::Render::PortalState *)CA::Render::PortalState::_list;
  if (CA::Render::PortalState::_list)
  {
    if ((CA::Render::PortalState *)CA::Render::PortalState::_list == this)
    {
      unint64_t v4 = &CA::Render::PortalState::_list;
LABEL_7:
      *unint64_t v4 = *((void *)this + 2);
    }
    else
    {
      while (1)
      {
        uint64_t v3 = v2;
        uint64_t v2 = (CA::Render::PortalState *)*((void *)v2 + 2);
        if (!v2) {
          break;
        }
        if (v2 == this)
        {
          unint64_t v4 = (uint64_t *)((char *)v3 + 16);
          goto LABEL_7;
        }
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::PortalState::_list_lock);
  int v6 = *((void *)this + 6);
  if (v6)
  {
    CA::Render::Handle::remove_dependence(v6);
    uint64_t v7 = *((void *)this + 6);
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
    }
  }
  uint64_t v8 = *((_DWORD *)this + 3);
  if ((v8 & 0x200) != 0)
  {
    os_unfair_lock_lock(&CA::Render::_cross_display_sources_lock);
    uint64_t v9 = (char *)CA::Render::_cross_display_sources;
    uint64_t v10 = qword_1E8F84BC8;
    if (CA::Render::_cross_display_sources != (_UNKNOWN *)qword_1E8F84BC8)
    {
      while (*(CA::Render::PortalState **)v9 != this)
      {
        v9 += 160;
        if (v9 == (char *)qword_1E8F84BC8) {
          goto LABEL_21;
        }
      }
    }
    if (v9 == (char *)qword_1E8F84BC8)
    {
LABEL_21:
      os_unfair_lock_unlock(&CA::Render::_cross_display_sources_lock);
    }
    else
    {
      unint64_t v11 = (atomic_uint *)*((void *)v9 + 1);
      *(_OWORD *)uint64_t v9 = *(_OWORD *)(qword_1E8F84BC8 - 160);
      uint64_t v12 = *(_OWORD *)(v10 - 128);
      unint64_t v13 = *(_OWORD *)(v10 - 112);
      unint64_t v14 = *(_OWORD *)(v10 - 96);
      *((_OWORD *)v9 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *(_OWORD *)(v10 - 144);
      *((_OWORD *)v9 + 2) = v12;
      *((_OWORD *)v9 + 3) = v13;
      *((_OWORD *)v9 + 4) = v14;
      uint64_t v15 = *(_OWORD *)(v10 - 64);
      unsigned int v16 = *(_OWORD *)(v10 - 48);
      int v17 = *(_OWORD *)(v10 - 32);
      *((_OWORD *)v9 + 5) = *(_OWORD *)(v10 - 80);
      *((_OWORD *)v9 + 6) = v15;
      *((_OWORD *)v9 + 7) = v16;
      *((_OWORD *)v9 + 8) = v17;
      *((_OWORD *)v9 + 9) = *(_OWORD *)(v10 - 16);
      if (qword_1E8F84BC8 <= (unint64_t)CA::Render::_cross_display_sources) {
        __assert_rtn("pop_back", "x-small-vector.h", 410, "_end > _begin && \"pop_back on empty container\"");
      }
      qword_1E8F84BC8 -= 160;
      os_unfair_lock_unlock(&CA::Render::_cross_display_sources_lock);
      if (v11 && atomic_fetch_add(v11 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v11 + 16))(v11);
      }
    }
    uint64_t v8 = *((_DWORD *)this + 3);
  }
  --dword_1EB2ADE6C;
  *(void *)this = &unk_1ED02F670;
  if (v8 < 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, v5);
  }
}

void CA::Render::PortalState::Dependence::~Dependence(CA::Render::PortalState::Dependence *this)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::OGL::clip_primitives(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int *a5, void *a6, float64x2_t *a7, unsigned char *a8, unsigned int a9, uint64_t a10, unsigned __int8 a11)
{
  unint64_t v11 = a8;
  uint64_t v86 = a4;
  unsigned int v84 = a2;
  int v16 = a1;
  int v17 = a11;
  unsigned int v88 = a9;
  v94[5] = *MEMORY[0x1E4F143B8];
  if (!a8 && a11)
  {
    MEMORY[0x1F4188790](a1);
    bzero(v70, 0x300FuLL);
    unint64_t v11 = v70;
    unsigned int v88 = 256;
  }
  memset(v94, 0, 32);
  memset(v93, 0, sizeof(v93));
  memset(v92, 0, sizeof(v92));
  memset(v91, 0, sizeof(v91));
  memset(v90, 0, sizeof(v90));
  if (a5)
  {
    int v18 = a5[1];
    float v19 = (float)*a5;
    float v20 = (float)(a5[2] + *a5);
    float v21 = (float)(a5[3] + v18);
    *(_OWORD *)((char *)v90 + 12) = xmmword_184997DF0;
    if (a6) {
      int v22 = *((_DWORD *)a6 + 2);
    }
    else {
      int v22 = 0;
    }
    DWORD2(v90[0]) = v22 + 1;
    *(void *)&v90[0] = a6;
    *(void *)((char *)v91 + 12) = 1065353216;
    *((float *)&v91[1] + 2) = -v19;
    DWORD2(v91[0]) = v22 + 2;
    *(void *)&v91[0] = v90;
    *(void *)((char *)v92 + 12) = 3212836864;
    *((float *)&v92[1] + 2) = v20;
    DWORD2(v92[0]) = v22 + 3;
    *(void *)&v92[0] = v91;
    *(void *)((char *)v93 + 12) = 0x3F80000000000000;
    *((float *)&v93[1] + 2) = -(float)v18;
    DWORD2(v93[0]) = v22 + 4;
    *(void *)&v93[0] = v92;
    a6 = v94;
    *(void *)((char *)&v94[1] + 4) = 0xBF80000000000000;
    *(float *)&v94[3] = v21;
    LODWORD(v94[1]) = v22 + 5;
    v94[0] = v93;
  }
  if (v16)
  {
    if (v16 == 2)
    {
      int v82 = 0;
      int v81 = 1;
      unsigned int v23 = 3;
      goto LABEL_16;
    }
    if (v16 != 1) {
      return 0;
    }
    int v82 = 0;
    unsigned int v23 = 3;
    int v24 = 3;
  }
  else
  {
    unsigned int v23 = 4;
    int v82 = 1;
    int v24 = 4;
  }
  int v81 = v24;
LABEL_16:
  uint64_t v87 = a10;
  unsigned int v25 = *((_DWORD *)a6 + 2) + v23;
  size_t v26 = 48 * v25 + 16;
  unsigned int v85 = v25;
  unsigned int v83 = v23;
  if (v25 > 0x55)
  {
    float v27 = malloc_type_malloc(48 * v25 + 16, 0xFF0C942FuLL);
    uint64_t v29 = malloc_type_malloc(v26, 0x83AF315CuLL);
  }
  else
  {
    MEMORY[0x1F4188790](a1);
    float v27 = &v70[-((v26 + 15) & 0xFFFFFFFFF0)];
    bzero(v27, v26);
    MEMORY[0x1F4188790](v28);
    uint64_t v29 = v27;
    unsigned int v23 = v83;
    bzero(v27, v26);
  }
  if (v23 > v84)
  {
    unsigned int v30 = 0;
    char v31 = 0;
    goto LABEL_45;
  }
  unint64_t v80 = a6;
  int v75 = a11;
  unsigned int v32 = 0;
  unsigned int v30 = 0;
  id v72 = v27;
  mach_error_t v33 = (float32x2_t *)((unint64_t)(v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v71 = v29;
  unint64_t v79 = (float32x2_t *)(((unint64_t)v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v78 = v33 + 6;
  uint64_t v77 = v33 + 12;
  unsigned int v73 = v33 + 18;
  uint64_t v74 = v23;
  uint64_t v76 = a3;
  while (1)
  {
    unsigned int v34 = v32;
    if (a3)
    {
      uint64_t v35 = v86;
      uint64_t v36 = v86 + 48 * *(unsigned __int16 *)(a3 + 2 * v32);
      long long v37 = *(_OWORD *)(v36 + 16);
      *(_OWORD *)v33->f32 = *(_OWORD *)v36;
      *(_OWORD *)(((unint64_t)(v27 + 15) & 0xFFFFFFFFFFFFFFF0) + 0x1CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v37;
      *(void *)(((unint64_t)(v27 + 15) & 0xFFFFFFFFFFFFFFF0) + 0x2CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *(void *)(v36 + 32);
      uint64_t v38 = v35 + 48 * *(unsigned __int16 *)(a3 + 2 * (v34 + 1));
      long long v39 = *(_OWORD *)(v38 + 16);
      uint64_t v40 = v78;
      *(_OWORD *)v78->f32 = *(_OWORD *)v38;
      *(_OWORD *)v40[2].f32 = v39;
      *(void *)(((unint64_t)(v27 + 15) & 0xFFFFFFFFFFFFFFF0) + 0x5CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *(void *)(v38 + 32);
      uint64_t v41 = v35 + 48 * *(unsigned __int16 *)(a3 + 2 * (v34 + 2));
      long long v42 = *(_OWORD *)(v41 + 16);
      uint64_t v43 = v77;
      *(_OWORD *)v77->f32 = *(_OWORD *)v41;
      *(_OWORD *)v43[2].f32 = v42;
      *(void *)(((unint64_t)(v27 + 15) & 0xFFFFFFFFFFFFFFF0) + 0x8CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *(void *)(v41 + 32);
      if (v82)
      {
        unsigned int v44 = *(unsigned __int16 *)(a3 + 2 * (v34 + 3));
LABEL_27:
        uint64_t v54 = v86 + 48 * v44;
        long long v55 = *(_OWORD *)(v54 + 16);
        size_t v56 = v73;
        *(_OWORD *)v73->f32 = *(_OWORD *)v54;
        *(_OWORD *)v56[2].f32 = v55;
        *(void *)(((unint64_t)(v27 + 15) & 0xFFFFFFFFFFFFFFF0) + 0xBCA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *(void *)(v54 + 32);
      }
    }
    else
    {
      uint64_t v45 = v86;
      uint64_t v46 = v86 + 48 * v32;
      long long v47 = *(_OWORD *)(v46 + 16);
      *(_OWORD *)v33->f32 = *(_OWORD *)v46;
      *(_OWORD *)(((unint64_t)(v27 + 15) & 0xFFFFFFFFFFFFFFF0) + 0x1CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v47;
      *(void *)(((unint64_t)(v27 + 15) & 0xFFFFFFFFFFFFFFF0) + 0x2CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *(void *)(v46 + 32);
      uint64_t v48 = v45 + 48 * (v34 + 1);
      long long v49 = *(_OWORD *)(v48 + 16);
      uint64_t v50 = v78;
      *(_OWORD *)v78->f32 = *(_OWORD *)v48;
      *(_OWORD *)v50[2].f32 = v49;
      *(void *)(((unint64_t)(v27 + 15) & 0xFFFFFFFFFFFFFFF0) + 0x5CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *(void *)(v48 + 32);
      uint64_t v51 = v45 + 48 * (v34 + 2);
      long long v52 = *(_OWORD *)(v51 + 16);
      uint64_t v53 = v77;
      *(_OWORD *)v77->f32 = *(_OWORD *)v51;
      *(_OWORD *)v53[2].f32 = v52;
      *(void *)(((unint64_t)(v27 + 15) & 0xFFFFFFFFFFFFFFF0) + 0x8CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *(void *)(v51 + 32);
      if (v82)
      {
        unsigned int v44 = v34 + 3;
        goto LABEL_27;
      }
    }
    if (a7)
    {
      uint64_t v57 = v74;
      mach_port_name_t v58 = (float32x2_t *)((unint64_t)(v27 + 15) & 0xFFFFFFFFFFFFFFF0);
      do
      {
        *(float32x4_t *)v58->f32 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*a7), a7[1]), COERCE_FLOAT(*(_OWORD *)v58->f32)), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(a7[2]), a7[3]), *v58, 1), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(a7[4]), a7[5]), *(float32x4_t *)v58->f32, 2), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(a7[6]), a7[7]), *(float32x4_t *)v58->f32, 3);
        v58 += 6;
        --v57;
      }
      while (v57);
    }
    int v89 = 0;
    mach_port_name_t v59 = CA::OGL::clip_vertices(v80, v23, v33, v79, v85, (unsigned int *)&v89);
    if (v89)
    {
      if (v75)
      {
        if ((v89 - 1) >= 2)
        {
          mach_port_name_t v60 = &v59[6 * (v89 - 1)];
          uint64_t v61 = (v89 - 2);
          mach_port_name_t v62 = v59 + 6;
          do
          {
            if (v30 + 3 > v88)
            {
              if ((std::function<BOOL ()(CA::OGL::Vertex *,unsigned int)>::operator()(*(void *)(v87 + 24), (uint64_t)v11, v30) & 1) == 0)goto LABEL_43; {
              unsigned int v30 = 0;
              }
            }
            mach_port_t v63 = &v11[48 * v30];
            long long v64 = *(_OWORD *)v62[-4].f32;
            *(_OWORD *)mach_port_t v63 = *(_OWORD *)v62[-6].f32;
            *((_OWORD *)v63 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v64;
            *((float32x2_t *)v63 + 4) = v62[-2];
            LODWORD(v63) = v30 + 2;
            uint64_t v65 = &v11[48 * v30 + 48];
            long long v66 = *(_OWORD *)v62[2].f32;
            *(_OWORD *)uint64_t v65 = *(_OWORD *)v62->f32;
            *((_OWORD *)v65 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v66;
            *((float32x2_t *)v65 + 4) = v62[4];
            v30 += 3;
            uint64_t v67 = &v11[48 * v63];
            long long v68 = *(_OWORD *)v60[2].f32;
            *(_OWORD *)uint64_t v67 = *(_OWORD *)v60->f32;
            *((_OWORD *)v67 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v68;
            *((float32x2_t *)v67 + 4) = v60[4];
            v62 += 6;
            --v61;
          }
          while (v61);
        }
        goto LABEL_41;
      }
      if ((std::function<BOOL ()(CA::OGL::Vertex *,unsigned int)>::operator()(*(void *)(v87 + 24), (uint64_t)v59, v89) & 1) == 0) {
        break;
      }
    }
LABEL_41:
    unsigned int v32 = v34 + v81;
    unsigned int v23 = v83;
    a3 = v76;
    if (v34 + v81 + v83 > v84)
    {
      char v31 = 0;
      goto LABEL_44;
    }
  }
LABEL_43:
  char v31 = 1;
LABEL_44:
  int v17 = v75;
  float v27 = v72;
  uint64_t v29 = v71;
LABEL_45:
  if (v85 >= 0x56)
  {
    free(v27);
    free(v29);
  }
  if (v31) {
    return 0;
  }
  uint64_t result = 1;
  if (v17)
  {
    if (v30) {
      return std::function<BOOL ()(CA::OGL::Vertex *,unsigned int)>::operator()(*(void *)(v87 + 24), (uint64_t)v11, v30);
    }
  }
  return result;
}

float32x2_t *CA::OGL::clip_vertices(uint64_t *a1, unsigned int a2, float32x2_t *a3, float32x2_t *a4, unsigned int a5, unsigned int *a6)
{
  unint64_t v11 = a1;
  v66[1] = *MEMORY[0x1E4F143B8];
  size_t v12 = 8 * a5;
  MEMORY[0x1F4188790](a1);
  unint64_t v13 = (char *)v66 - ((v12 + 15) & 0xFFFFFFFF0);
  bzero(v13, v12);
  MEMORY[0x1F4188790](v14);
  uint64_t v15 = v13;
  bzero(v13, v12);
  if (!v11) {
    goto LABEL_32;
  }
  do
  {
    uint64_t v16 = 0;
    int v17 = 0;
    float64x2_t v18 = vcvtq_f64_f32(*(float32x2_t *)((char *)v11 + 12));
    double v19 = *((float *)v11 + 6);
    uint64_t v20 = a2;
    float v21 = a3;
    do
    {
      double v22 = vaddvq_f64(vmulq_f64(v18, vcvtq_f64_f32(*v21))) + v19 * v21[1].f32[1];
      *(double *)&v13[8 * v16] = v22;
      if (v22 < 0.0) {
        ++v17;
      }
      ++v16;
      v21 += 6;
    }
    while (a2 != v16);
    if (v17)
    {
      if (v17 != a2)
      {
        uint64_t v23 = 0;
        int v24 = (float32x4_t *)&a3[6 * a2 - 6];
        double v25 = *(double *)&v13[8 * a2 - 8];
        a2 = 0;
        while (1)
        {
          size_t v26 = &a3[6 * v23];
          double v27 = *(double *)&v13[8 * v23];
          if (v25 >= 0.0) {
            break;
          }
          if (v27 >= 0.0)
          {
            if (a2 >= a5 - 1) {
              goto LABEL_30;
            }
            uint64_t v28 = 0;
            double v29 = v25 / (v25 - v27);
            float64x2_t v30 = vcvt_hight_f64_f32(*v24);
            float64x2_t v31 = vcvtq_f64_f32(*(float32x2_t *)v24->f32);
            float32x4_t v32 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_n_f64(v31, vsubq_f64(vcvtq_f64_f32(*v26), v31), v29)), vmlaq_n_f64(v30, vsubq_f64(vcvt_hight_f64_f32(*(float32x4_t *)v26->f32), v30), v29));
            *(float32x4_t *)a4[6 * a2].f32 = v32;
            char v33 = 1;
            do
            {
              uint64_t v34 = (uint64_t)&a3[6 * v23 + 2];
              double v35 = v24[1].f32[v28];
              *(float *)&double v35 = v35 + (*(float *)(v34 + 4 * v28) - v35) * v29;
              uint64_t v36 = (uint64_t)&a4[6 * a2 + 2];
              *(_DWORD *)(v36 + 4 * v28) = LODWORD(v35);
              uint64_t v37 = (4 * v28) | 4;
              char v38 = v33;
              *(float *)&double v35 = *(float *)((char *)v24[1].f32 + v37)
                             + (*(float *)(v34 + v37) - *(float *)((char *)v24[1].f32 + v37)) * v29;
              *(_DWORD *)(v36 + v37) = LODWORD(v35);
              uint64_t v28 = 2;
              char v33 = 0;
            }
            while ((v38 & 1) != 0);
            long long v39 = &a4[6 * a2];
            uint64_t v40 = (float16x4_t *)&a3[6 * v23];
            float v41 = v29;
            float16x4_t v42 = *(float16x4_t *)v24[2].f32;
            v39[4] = (float32x2_t)v42;
            v39[4] = (float32x2_t)vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(v42), 1.0 - v41), vcvtq_f32_f16(v40[4]), v41));
            *(double *)&v15[8 * a2] = vaddvq_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)((char *)v11 + 12)), vcvtq_f64_f32(*(float32x2_t *)v32.f32)))+ *((float *)v11 + 6) * v39[1].f32[1];
            uint64_t v43 = a2 + 1;
            unsigned int v44 = &a4[6 * v43];
            long long v45 = *(_OWORD *)v26[2].f32;
            *(_OWORD *)v44->f32 = *(_OWORD *)v26->f32;
            *(_OWORD *)v44[2].f32 = v45;
            v44[4] = (float32x2_t)v40[4];
            int v46 = 2;
            goto LABEL_22;
          }
LABEL_24:
          ++v23;
          double v25 = v27;
          int v24 = (float32x4_t *)v26;
          if (v23 == v20)
          {
            uint64_t result = a4;
            a4 = a3;
            uint64_t v65 = v15;
            uint64_t v15 = v13;
            goto LABEL_27;
          }
        }
        if (v27 >= 0.0)
        {
          if (a2 == a5)
          {
LABEL_30:
            a2 = 0;
            uint64_t result = a4;
            break;
          }
          uint64_t v43 = a2;
          mach_port_name_t v62 = &a4[6 * a2];
          long long v63 = *(_OWORD *)v26[2].f32;
          *(_OWORD *)v62->f32 = *(_OWORD *)v26->f32;
          *(_OWORD *)v62[2].f32 = v63;
          v62[4] = a3[6 * v23 + 4];
          int v46 = 1;
LABEL_22:
          double v61 = v27;
        }
        else
        {
          if (a2 == a5) {
            goto LABEL_30;
          }
          uint64_t v47 = 0;
          double v48 = v25 / (v25 - v27);
          uint64_t v43 = a2;
          float64x2_t v49 = vcvt_hight_f64_f32(*v24);
          float64x2_t v50 = vcvtq_f64_f32(*(float32x2_t *)v24->f32);
          float32x4_t v51 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_n_f64(v50, vsubq_f64(vcvtq_f64_f32(*v26), v50), v48)), vmlaq_n_f64(v49, vsubq_f64(vcvt_hight_f64_f32(*(float32x4_t *)v26->f32), v49), v48));
          *(float32x4_t *)a4[6 * a2].f32 = v51;
          char v52 = 1;
          do
          {
            uint64_t v53 = (uint64_t)&a3[6 * v23 + 2];
            double v54 = v24[1].f32[v47];
            *(float *)&double v54 = v54 + (*(float *)(v53 + 4 * v47) - v54) * v48;
            uint64_t v55 = (uint64_t)&a4[6 * a2 + 2];
            *(_DWORD *)(v55 + 4 * v47) = LODWORD(v54);
            uint64_t v56 = (4 * v47) | 4;
            char v57 = v52;
            *(float *)&double v54 = *(float *)((char *)v24[1].f32 + v56)
                           + (*(float *)(v53 + v56) - *(float *)((char *)v24[1].f32 + v56)) * v48;
            *(_DWORD *)(v55 + v56) = LODWORD(v54);
            uint64_t v47 = 2;
            char v52 = 0;
          }
          while ((v57 & 1) != 0);
          mach_port_name_t v58 = &a4[6 * a2];
          float v59 = v48;
          float16x4_t v60 = *(float16x4_t *)v24[2].f32;
          v58[4] = (float32x2_t)v60;
          v58[4] = (float32x2_t)vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(v60), 1.0 - v59), vcvtq_f32_f16((float16x4_t)a3[6 * v23 + 4]), v59));
          double v61 = vaddvq_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)((char *)v11 + 12)), vcvtq_f64_f32(*(float32x2_t *)v51.f32)))
              + *((float *)v11 + 6) * v58[1].f32[1];
          int v46 = 1;
        }
        *(double *)&v15[8 * v43] = v61;
        a2 += v46;
        goto LABEL_24;
      }
      a2 = 0;
LABEL_32:
      uint64_t result = a3;
      break;
    }
    uint64_t result = a3;
    uint64_t v65 = v13;
LABEL_27:
    if (a2 < 3) {
      break;
    }
    unint64_t v11 = (uint64_t *)*v11;
    unint64_t v13 = v65;
    a3 = result;
  }
  while (v11);
  *a6 = a2;
  return result;
}

uint64_t std::function<BOOL ()(CA::OGL::Vertex *,unsigned int)>::operator()(uint64_t a1, uint64_t a2, int a3)
{
  v5[1] = *MEMORY[0x1E4F143B8];
  v5[0] = a2;
  int v4 = a3;
  if (!a1) {
    std::__throw_bad_function_call[abi:nn180100]();
  }
  return (*(uint64_t (**)(uint64_t, void *, int *))(*(void *)a1 + 48))(a1, v5, &v4);
}

uint64_t std::__function::__func<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0,std::allocator<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0>,BOOL ()(CA::OGL::Vertex *,unsigned int)>::operator()(uint64_t a1, const void **a2, unsigned int *a3)
{
  uint64_t v3 = *a3;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = CA::OGL::MetalBufferPool::encode_vertex_arg(*(CA::OGL::MetalBufferPool **)(v4 + 4040), 1, *a2, 48 * (int)v3, 0x10u);
  if (v5) {
    (*(void (**)(void, char *, uint64_t, void, uint64_t, uint64_t))(v4 + 3040))(*(void *)(v4 + 2984), sel_drawPrimitives_vertexStart_vertexCount_instanceCount_, 3, 0, v3, 1);
  }
  return v5;
}

void set_attr(CA::Transaction *a1, const void *a2, void *a3)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  v10[0] = a2;
  uint64_t v5 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (!v5) {
    uint64_t v5 = (CA::Transaction *)CA::Transaction::create(a1);
  }
  int v6 = (const void *)CAInternAtom((const __CFString *)a1, 1);
  int v7 = *((_DWORD *)v5 + 25);
  *((_DWORD *)v5 + 25) = v7 + 1;
  if (!v7) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  uint64_t v8 = (CA::AttrList *)a3[4];
  if (!v8)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v8 = (CA::AttrList *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x10uLL, 0x743898A5uLL);
  }
  a3[4] = CA::AttrList::set(v8, v6, 2, (unsigned __int8 *)v10);

  CA::Transaction::unlock(v5);
}

CA::Render::MeshTransform *CA::Render::MeshTransform::decode(CA::Render::MeshTransform *this, CA::Render::Decoder *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  int v3 = CA::Render::Decoder::decode_int32(this);
  unint64_t v4 = CA::Render::Decoder::decode_size_t(this);
  unint64_t v5 = CA::Render::Decoder::decode_size_t(this);
  unsigned int v6 = CA::Render::Decoder::decode_int8(this);
  unsigned int v7 = v6;
  if (v6 >= 7)
  {
    CA::Render::Decoder::set_fatal_error(this, "%s - enum %u out of range of %u", "decode_int8_enum", v6, 7);
    unsigned int v7 = 0;
  }
  int v8 = CA::Render::Decoder::decode_int32(this);
  int v9 = CA::Render::Decoder::decode_int32(this);
  int v10 = CA::Render::Decoder::decode_int8(this);
  int v11 = CA::Render::Decoder::decode_int32(this);
  if (v4 > 0x100000)
  {
    CA::Render::Decoder::set_fatal_error(this, "%s - suspiciously large vertex count: %zu");
    return 0;
  }
  if (v5 > 0x100000)
  {
    CA::Render::Decoder::set_fatal_error(this, "%s - suspiciously large face count: %zu");
    return 0;
  }
  int v13 = v11;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v15 = (CA::Render::MeshTransform *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xD0uLL, 0x743898A5uLL);
  size_t v12 = v15;
  if (v15) {
    CA::Render::MeshTransform::MeshTransform(v15, v4, v5, v8);
  }
  *((_DWORD *)v12 + 3) |= (v3 << 8) & 0xFFFFCFFF | 0x300;
  std::vector<CA::Render::MeshVertex>::resize((char **)v12 + 3, v4);
  uint64_t v16 = (uint64_t *)((char *)v12 + 48);
  std::vector<CA::Render::MeshFace>::resize((char **)v12 + 6, v5);
  std::vector<CA::Render::MeshFace>::resize((char **)v12 + 9, 4 * v5);
  *((_DWORD *)v12 + 24) = v7;
  *((_DWORD *)v12 + 25) = v8;
  *((_DWORD *)v12 + 26) = v9;
  *((unsigned char *)v12 + 108) = v10 != 0;
  *((_DWORD *)v12 + 28) = v13;
  if (*((void *)v12 + 4) != *((void *)v12 + 3))
  {
    uint64_t v17 = 0;
    unint64_t v18 = 0;
    do
    {
      *(void *)&long long __dst = 0;
      CA::Render::Decoder::decode_bytes(this, &__dst, 8uLL);
      *(void *)(*((void *)v12 + 3) + v17) = __dst;
      DWORD2(__dst) = 0;
      *(void *)&long long __dst = 0;
      CA::Render::Decoder::decode_bytes(this, &__dst, 0xCuLL);
      int v19 = DWORD2(__dst);
      uint64_t v20 = *((void *)v12 + 3);
      uint64_t v21 = v20 + v17;
      *(void *)(v21 + 16) = __dst;
      *(_DWORD *)(v21 + 24) = v19;
      *(_DWORD *)(v21 + 28) = 1065353216;
      ++v18;
      v17 += 32;
    }
    while (v18 < (*((void *)v12 + 4) - v20) >> 5);
  }
  if (*((void *)v12 + 7) != *((void *)v12 + 6))
  {
    uint64_t v22 = 0;
    unint64_t v23 = 0;
    do
    {
      for (uint64_t i = 0; i != 16; i += 4)
      {
        int v25 = CA::Render::Decoder::decode_int32(this);
        uint64_t v26 = *v16;
        *(_DWORD *)(*v16 + v22 + i) = v25;
      }
      ++v23;
      v22 += 16;
    }
    while (v23 < (*((void *)v12 + 7) - v26) >> 4);
  }
  if (*((void *)v12 + 10) != *((void *)v12 + 9))
  {
    uint64_t v27 = 0;
    unint64_t v28 = 0;
    do
    {
      *(_DWORD *)(*((void *)v12 + 9) + v27 + 8) = CA::Render::Decoder::decode_int32(this);
      int v29 = CA::Render::Decoder::decode_int32(this);
      uint64_t v30 = *((void *)v12 + 9);
      *(_DWORD *)(v30 + v27 + 4) = v29;
      ++v28;
      v27 += 16;
    }
    while (v28 < (*((void *)v12 + 10) - v30) >> 4);
  }
  long long __dst = 0u;
  long long v35 = 0u;
  CA::Render::Decoder::decode_bytes(this, &__dst, 0x20uLL);
  long long v31 = v35;
  *(_OWORD *)((char *)v12 + 12CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = __dst;
  *(_OWORD *)((char *)v12 + 136) = v31;
  long long v35 = 0u;
  long long v36 = 0u;
  long long __dst = 0u;
  CA::Render::Decoder::decode_bytes(this, &__dst, 0x30uLL);
  long long v32 = v35;
  *(_OWORD *)((char *)v12 + 152) = __dst;
  *(_OWORD *)((char *)v12 + 168) = v32;
  *(_OWORD *)((char *)v12 + 184) = v36;
  return v12;
}

void std::vector<CA::Render::MeshFace>::resize(char **a1, unint64_t a2)
{
  int v3 = *a1;
  unint64_t v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 4;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    unint64_t v18 = &v3[16 * a2];
    goto LABEL_19;
  }
  unint64_t v6 = a2 - v5;
  unsigned int v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 4)
  {
    bzero(a1[1], 16 * v6);
    unint64_t v18 = &v4[16 * v6];
LABEL_19:
    a1[1] = v18;
    return;
  }
  if (a2 >> 60) {
    abort();
  }
  uint64_t v8 = v7 - v3;
  uint64_t v9 = v8 >> 3;
  if (v8 >> 3 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  int v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshFace>>(v10);
  size_t v12 = &v11[16 * v5];
  uint64_t v14 = &v11[16 * v13];
  bzero(v12, 16 * v6);
  uint64_t v15 = &v12[16 * v6];
  uint64_t v17 = *a1;
  uint64_t v16 = a1[1];
  if (v16 != *a1)
  {
    do
    {
      *((_OWORD *)v12 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *((_OWORD *)v16 - 1);
      v12 -= 16;
      v16 -= 16;
    }
    while (v16 != v17);
    uint64_t v16 = *a1;
  }
  *a1 = v12;
  a1[1] = v15;
  a1[2] = v14;
  if (v16)
  {
    operator delete(v16);
  }
}

void std::vector<CA::Render::MeshVertex>::resize(char **a1, unint64_t a2)
{
  int v3 = *a1;
  unint64_t v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 5;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    int v19 = &v3[32 * a2];
    goto LABEL_19;
  }
  unint64_t v6 = a2 - v5;
  unsigned int v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 5)
  {
    bzero(a1[1], 32 * v6);
    int v19 = &v4[32 * v6];
LABEL_19:
    a1[1] = v19;
    return;
  }
  if (a2 >> 59) {
    abort();
  }
  uint64_t v8 = v7 - v3;
  uint64_t v9 = v8 >> 4;
  if (v8 >> 4 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v10 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  int v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshVertex>>(v10);
  size_t v12 = &v11[32 * v5];
  uint64_t v14 = &v11[32 * v13];
  bzero(v12, 32 * v6);
  uint64_t v15 = &v12[32 * v6];
  uint64_t v17 = *a1;
  uint64_t v16 = a1[1];
  if (v16 != *a1)
  {
    do
    {
      long long v18 = *((_OWORD *)v16 - 1);
      *((_OWORD *)v12 - 2) = *((_OWORD *)v16 - 2);
      *((_OWORD *)v12 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v18;
      v12 -= 32;
      v16 -= 32;
    }
    while (v16 != v17);
    uint64_t v16 = *a1;
  }
  *a1 = v12;
  a1[1] = v15;
  a1[2] = v14;
  if (v16)
  {
    operator delete(v16);
  }
}

double *CA::Render::Path::copy_subpath(CA::Render::Path *this, double a2, double a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = CA::Render::Path::keyframe_lengths(this);
  if (!v6) {
    return v6;
  }
  if (!*((void *)this + 8)) {
    CA::Render::Path::keyframe_lengths(this);
  }
  double v7 = *((double *)this + 9);
  uint64_t v8 = (float64x2_t *)*((void *)this + 4);
  uint64_t v9 = (unsigned __int8 *)*((void *)this + 5);
  uint64_t v10 = *((unsigned int *)this + 5);
  long long v32 = 0u;
  memset(v33, 0, sizeof(v33));
  *(_OWORD *)__p = 0u;
  long long v31 = 0u;
  *(_OWORD *)((char *)&v33[1] + 8) = *MEMORY[0x1E4F1DB10];
  *(_OWORD *)((char *)&v33[2] + 8) = *(_OWORD *)((char *)&v33[1] + 8);
  uint64_t v11 = 1;
  if (v10)
  {
    uint64_t v12 = 0;
    double v13 = v7 * a2;
    double v14 = v7 * a3;
    uint64_t v15 = &v9[v10];
    double v16 = 0.0;
    do
    {
      int v17 = *v9;
      if (v17 == 1)
      {
        *(float64x2_t *)((char *)v33 + 8) = *v8;
        long long v18 = (__int128)*v8++;
        *(_OWORD *)((char *)&v33[1] + 8) = v18;
        BYTE8(v33[3]) = 1;
      }
      else
      {
        double v19 = v6[v12];
        double v20 = 0.0;
        if (v13 > v16) {
          double v20 = (v13 - v16) / v19;
        }
        if (v14 >= v19 + v16)
        {
        }
        else
        {
          double v21 = (v14 - v16) / v19;
          if (v21 < 1.0) {
            break;
          }
        }
        v8 += CA::Render::path_counts[*v9];
        double v22 = v6[v12++];
        double v16 = v22 + v16;
      }
      ++v9;
    }
    while (v9 < v15);
    int v23 = v33[0];
    uint64_t v11 = (LODWORD(__p[1]) - LODWORD(__p[0]) + 1);
    uint64_t v24 = ((void)v32 - *((void *)&v31 + 1)) >> 4;
  }
  else
  {
    int v23 = 0;
    LODWORD(v24) = 0;
  }
  int v25 = CA::Render::Path::new_path((CA::Render::Path *)v11, v24, v23);
  unint64_t v6 = (double *)v25;
  if (v25)
  {
    uint64_t v26 = __p[0];
    if (__p[1] == __p[0])
    {
      uint64_t v27 = __p[0];
    }
    else
    {
      memmove(*((void **)v25 + 5), __p[0], (char *)__p[1] - (char *)__p[0]);
      uint64_t v26 = __p[0];
      uint64_t v27 = __p[1];
    }
    *(unsigned char *)(*((void *)v6 + 5) + v27 - v26) = 5;
    unint64_t v28 = (void *)*((void *)&v31 + 1);
    if ((void)v32 == *((void *)&v31 + 1)) {
      goto LABEL_25;
    }
    memmove(*((void **)v6 + 4), *((const void **)&v31 + 1), v32 - *((void *)&v31 + 1));
  }
  unint64_t v28 = (void *)*((void *)&v31 + 1);
LABEL_25:
  if (v28)
  {
    *(void *)&long long v32 = v28;
    operator delete(v28);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v6;
}

void CA::Render::anonymous namespace'::PathAccumulator::add_segment(uint64_t a1, int a2, float64x2_t *a3, double a4, double a5)
{
  uint64_t v182 = *MEMORY[0x1E4F143B8];
  double v9 = fmax(a4, 0.0);
  double v10 = fmin(a5, 1.0);
  if (*(unsigned char *)(a1 + 104))
  {
    *(unsigned char *)(a1 + 105) = a4 > 0.0;
    *(unsigned char *)(a1 + 104) = 0;
  }
  if (v9 < v10)
  {
    switch(a2)
    {
      case 0:
      case 2:
        double v179 = v10;
        uint64_t v11 = (long long *)(a1 + 72);
        double v12 = *(double *)(a1 + 72);
        double v13 = (long long *)(a1 + 56);
        if (a2) {
          double v14 = (double *)a3;
        }
        else {
          double v14 = (double *)(a1 + 56);
        }
        double v15 = *v14 - v12;
        double v16 = *(double *)(a1 + 80);
        double v17 = v14[1] - v16;
        double v18 = v12 + v15 * v9;
        double v19 = v16 + v17 * v9;
        *(double *)unsigned int v181 = v18;
        *((double *)v181 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v19;
        double v20 = (long long *)(a1 + 88);
        if (*(double *)(a1 + 88) != v18 || *(double *)(a1 + 96) != v19) {
        double v22 = *(unsigned char **)(a1 + 8);
        }
        unint64_t v21 = *(void *)(a1 + 16);
        if ((unint64_t)v22 >= v21)
        {
          unint64_t v62 = *(void *)a1;
          long long v63 = &v22[-*(void *)a1];
          unint64_t v64 = (unint64_t)(v63 + 1);
          if ((uint64_t)(v63 + 1) < 0) {
            goto LABEL_205;
          }
          unint64_t v65 = v21 - v62;
          if (2 * v65 > v64) {
            unint64_t v64 = 2 * v65;
          }
          if (v65 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v66 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v66 = v64;
          }
          if (v66) {
            uint64_t v67 = operator new(v66);
          }
          else {
            uint64_t v67 = 0;
          }
          uint64_t v71 = &v67[v66];
          v63[(void)v67] = 2;
          uint64_t v23 = (uint64_t)&v63[(void)v67 + 1];
          if (v22 == (unsigned char *)v62)
          {
            uint64_t v67 = &v63[(void)v67];
          }
          else
          {
            id v72 = &v22[~v62];
            do
            {
              char v73 = *--v22;
              (v72--)[(void)v67] = v73;
            }
            while (v22 != (unsigned char *)v62);
            double v22 = *(unsigned char **)a1;
          }
          *(void *)a1 = v67;
          *(void *)(a1 + 8) = v23;
          *(void *)(a1 + 16) = v71;
          if (v22) {
            operator delete(v22);
          }
        }
        else
        {
          *double v22 = 2;
          uint64_t v23 = (uint64_t)(v22 + 1);
        }
        double v74 = v179;
        double v75 = v12 + v15 * v179;
        double v76 = v16 + v17 * v179;
        *(void *)(a1 + 8) = v23;
        unint64_t v78 = *(double **)(a1 + 32);
        unint64_t v77 = *(void *)(a1 + 40);
        if ((unint64_t)v78 < v77)
        {
          double *v78 = v75;
          v78[1] = v76;
          unint64_t v79 = v78 + 2;
LABEL_69:
          *(void *)(a1 + 32) = v79;
          *(double *)(a1 + 72) = v75;
          *(double *)(a1 + 8CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v76;
          *double v20 = *v11;
          if (!a2 && v74 == 1.0 && !*(unsigned char *)(a1 + 105))
          {
            uint64_t v88 = *(void *)(a1 + 8);
            if (v88 != *(void *)a1)
            {
              if (*(unsigned char *)(*(void *)a1 + ~*(void *)a1 + v88))
              {
                std::vector<unsigned char>::push_back[abi:nn180100]((unint64_t *)a1, 0);
                long long v89 = *v13;
                *uint64_t v11 = *v13;
                *double v20 = v89;
              }
            }
          }
          return;
        }
        unint64_t v80 = *(double **)(a1 + 24);
        uint64_t v81 = ((char *)v78 - (char *)v80) >> 4;
        unint64_t v82 = v81 + 1;
        if (!((unint64_t)(v81 + 1) >> 60))
        {
          uint64_t v83 = v77 - (void)v80;
          if (v83 >> 3 > v82) {
            unint64_t v82 = v83 >> 3;
          }
          _CF = (unint64_t)v83 >= 0x7FFFFFFFFFFFFFF0;
          unint64_t v84 = 0xFFFFFFFFFFFFFFFLL;
          if (!_CF) {
            unint64_t v84 = v82;
          }
          if (v84)
          {
            unint64_t v84 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshFace>>(v84);
            unint64_t v80 = *(double **)(a1 + 24);
            unint64_t v78 = *(double **)(a1 + 32);
          }
          else
          {
            uint64_t v85 = 0;
          }
          uint64_t v86 = (double *)(v84 + 16 * v81);
          unint64_t v87 = v84 + 16 * v85;
          *uint64_t v86 = v75;
          v86[1] = v76;
          unint64_t v79 = v86 + 2;
          if (v78 != v80)
          {
            do
            {
              *((_OWORD *)v86 - CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = *((_OWORD *)v78 - 1);
              v86 -= 2;
              v78 -= 2;
            }
            while (v78 != v80);
            unint64_t v80 = *(double **)(a1 + 24);
          }
          *(void *)(a1 + 24) = v86;
          *(void *)(a1 + 32) = v79;
          *(void *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v87;
          if (v80) {
            operator delete(v80);
          }
          double v74 = v179;
          goto LABEL_69;
        }
        goto LABEL_205;
      case 3:
        float64x2_t v25 = vaddq_f64(*a3, *a3);
        float64x2_t v26 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
        float64x2_t v27 = vmulq_f64(vaddq_f64(a3[1], v25), v26);
        v181[0] = vmulq_f64(vaddq_f64(*(float64x2_t *)(a1 + 72), v25), v26);
        v181[1] = v27;
        v181[2] = a3[1];
        return;
      case 4:
        unint64_t v28 = (_OWORD *)(a1 + 72);
        if (v9 != 0.0 || v10 != 1.0)
        {
          v181[0] = *v28;
          float64x2_t v30 = *a3;
          float64x2_t v31 = a3[1];
          float64x2_t v32 = a3[2];
          v33.f64[0] = *(float64_t *)v181;
          if (fabs(v9) > 0.001)
          {
            float64x2_t v34 = vsubq_f64(v31, v30);
            float64x2_t v35 = vsubq_f64(v32, v31);
            v33.f64[1] = *((float64_t *)v181 + 1);
            __asm { FMOV            V6.2D, #-2.0 }
            float64x2_t v40 = vsubq_f64(v30, v33);
            float64x2_t v41 = vaddq_f64(v30, v30);
            float64x2_t v30 = vmlsq_lane_f64(v32, vmlaq_n_f64(vaddq_f64(v35, v35), vsubq_f64(vnegq_f64(vmlaq_f64(v30, _Q6, v31)), v32), 1.0 - v9), 1.0 - v9, 0);
            float64x2_t v42 = vsubq_f64(v31, v41);
            float64x2_t v43 = vmlsq_lane_f64(v32, v35, 1.0 - v9, 0);
            __asm { FMOV            V4.2D, #3.0 }
            float64x2_t v45 = vmulq_f64(v40, _Q4);
            float64x2_t v46 = vmulq_f64(vaddq_f64(v42, v33), _Q4);
            __asm { FMOV            V6.2D, #-3.0 }
            float64x2_t v33 = vmlaq_n_f64(v33, vmlaq_n_f64(v45, vmlaq_n_f64(v46, vsubq_f64(vmlaq_f64(v32, _Q6, v34), v33), v9), v9), v9);
            v181[0] = v33;
            double v10 = (v10 - v9) / (1.0 - v9);
            float64x2_t v31 = v43;
          }
          if (fabs(v10 + -1.0) > 0.001)
          {
            float64x2_t v48 = vsubq_f64(v31, v30);
            __asm { FMOV            V2.2D, #-2.0 }
            v50.f64[0] = v33.f64[0];
            v50.f64[1] = *((float64_t *)v181 + 1);
            float64x2_t v51 = vsubq_f64(v30, v50);
            float64x2_t v52 = vmlaq_f64(v50, _Q2, v30);
            float64x2_t v53 = vmlaq_n_f64(v50, v51, v10);
            float64x2_t v54 = vaddq_f64(v52, v31);
            float64x2_t v31 = vmlaq_n_f64(v50, vmlaq_n_f64(vaddq_f64(v51, v51), v54, v10), v10);
            __asm { FMOV            V6.2D, #3.0 }
            float64x2_t v56 = vmulq_f64(v51, _Q6);
            float64x2_t v57 = vmulq_f64(v54, _Q6);
            __asm { FMOV            V6.2D, #-3.0 }
            float64x2_t v32 = vmlaq_n_f64(v50, vmlaq_n_f64(v56, vmlaq_n_f64(v57, vsubq_f64(vmlaq_f64(v32, _Q6, v48), v50), v10), v10), v10);
            float64x2_t v30 = v53;
          }
          float64x2_t v178 = v31;
          float64x2_t v180 = v32;
          float64x2_t v177 = v30;
          if (*(double *)(a1 + 88) != v33.f64[0] || *(double *)(a1 + 96) != *((double *)v181 + 1))
          {
            float64x2_t v30 = v177;
            float64x2_t v31 = v178;
            float64x2_t v32 = v180;
          }
          float16x4_t v60 = *(unsigned char **)(a1 + 8);
          unint64_t v59 = *(void *)(a1 + 16);
          if ((unint64_t)v60 >= v59)
          {
            unint64_t v90 = *(void *)a1;
            float v91 = &v60[-*(void *)a1];
            unint64_t v92 = (unint64_t)(v91 + 1);
            if ((uint64_t)(v91 + 1) < 0) {
              goto LABEL_205;
            }
            unint64_t v93 = v59 - v90;
            if (2 * v93 > v92) {
              unint64_t v92 = 2 * v93;
            }
            if (v93 >= 0x3FFFFFFFFFFFFFFFLL) {
              size_t v94 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              size_t v94 = v92;
            }
            if (v94) {
              unint64_t v95 = operator new(v94);
            }
            else {
              unint64_t v95 = 0;
            }
            int v102 = &v95[v94];
            v91[(void)v95] = 4;
            uint64_t v61 = (uint64_t)&v91[(void)v95 + 1];
            if (v60 == (unsigned char *)v90)
            {
              unint64_t v95 = &v91[(void)v95];
            }
            else
            {
              int v103 = &v60[~v90];
              do
              {
                char v104 = *--v60;
                (v103--)[(void)v95] = v104;
              }
              while (v60 != (unsigned char *)v90);
              float16x4_t v60 = *(unsigned char **)a1;
            }
            *(void *)a1 = v95;
            *(void *)(a1 + 8) = v61;
            *(void *)(a1 + 16) = v102;
            if (v60) {
              operator delete(v60);
            }
            float64x2_t v31 = v178;
            float64x2_t v32 = v180;
            float64x2_t v30 = v177;
          }
          else
          {
            unsigned char *v60 = 4;
            uint64_t v61 = (uint64_t)(v60 + 1);
          }
          *(void *)(a1 + 8) = v61;
          int v109 = *(float64x2_t **)(a1 + 32);
          unint64_t v108 = *(void *)(a1 + 40);
          if ((unint64_t)v109 >= v108)
          {
            int v111 = *(float64x2_t **)(a1 + 24);
            uint64_t v112 = v109 - v111;
            unint64_t v113 = v112 + 1;
            if ((unint64_t)(v112 + 1) >> 60) {
              goto LABEL_205;
            }
            uint64_t v114 = v108 - (void)v111;
            if (v114 >> 3 > v113) {
              unint64_t v113 = v114 >> 3;
            }
            _CF = (unint64_t)v114 >= 0x7FFFFFFFFFFFFFF0;
            unint64_t v115 = 0xFFFFFFFFFFFFFFFLL;
            if (!_CF) {
              unint64_t v115 = v113;
            }
            if (v115)
            {
              int v116 = std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshFace>>(v115);
              float64x2_t v30 = v177;
              unint64_t v115 = (unint64_t)v116;
              int v111 = *(float64x2_t **)(a1 + 24);
              int v109 = *(float64x2_t **)(a1 + 32);
            }
            else
            {
              uint64_t v117 = 0;
            }
            uint64_t v127 = (float64x2_t *)(v115 + 16 * v112);
            unint64_t v108 = v115 + 16 * v117;
            *uint64_t v127 = v30;
            int v110 = v127 + 1;
            if (v109 != v111)
            {
              do
              {
                v127[-1] = v109[-1];
                --v127;
                --v109;
              }
              while (v109 != v111);
              int v111 = *(float64x2_t **)(a1 + 24);
            }
            *(void *)(a1 + 24) = v127;
            *(void *)(a1 + 32) = v110;
            *(void *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v108;
            if (v111)
            {
              operator delete(v111);
              unint64_t v108 = *(void *)(a1 + 40);
            }
            float64x2_t v31 = v178;
            float64x2_t v32 = v180;
          }
          else
          {
            *int v109 = v30;
            int v110 = v109 + 1;
          }
          *(void *)(a1 + 32) = v110;
          if ((unint64_t)v110 >= v108)
          {
            uint64_t v129 = *(float64x2_t **)(a1 + 24);
            uint64_t v130 = v110 - v129;
            unint64_t v131 = v130 + 1;
            if ((unint64_t)(v130 + 1) >> 60) {
              goto LABEL_205;
            }
            uint64_t v132 = v108 - (void)v129;
            if (v132 >> 3 > v131) {
              unint64_t v131 = v132 >> 3;
            }
            _CF = (unint64_t)v132 >= 0x7FFFFFFFFFFFFFF0;
            unint64_t v133 = 0xFFFFFFFFFFFFFFFLL;
            if (!_CF) {
              unint64_t v133 = v131;
            }
            if (v133)
            {
              uint64_t v134 = std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshFace>>(v133);
              float64x2_t v31 = v178;
              unint64_t v133 = (unint64_t)v134;
              uint64_t v129 = *(float64x2_t **)(a1 + 24);
              int v110 = *(float64x2_t **)(a1 + 32);
            }
            else
            {
              uint64_t v135 = 0;
            }
            float v149 = (float64x2_t *)(v133 + 16 * v130);
            unint64_t v108 = v133 + 16 * v135;
            float64x2_t *v149 = v31;
            uint64_t v128 = (char *)&v149[1];
            if (v110 != v129)
            {
              do
              {
                v149[-1] = v110[-1];
                --v149;
                --v110;
              }
              while (v110 != v129);
              uint64_t v129 = *(float64x2_t **)(a1 + 24);
            }
            *(void *)(a1 + 24) = v149;
            *(void *)(a1 + 32) = v128;
            *(void *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v108;
            if (v129)
            {
              operator delete(v129);
              unint64_t v108 = *(void *)(a1 + 40);
            }
            float64x2_t v32 = v180;
          }
          else
          {
            *int v110 = v31;
            uint64_t v128 = (char *)&v110[1];
          }
          *(void *)(a1 + 32) = v128;
          if ((unint64_t)v128 < v108)
          {
            *(float64x2_t *)uint64_t v128 = v32;
            f64 = v128 + 16;
LABEL_197:
            *(void *)(a1 + 32) = f64;
            *(float64x2_t *)(a1 + 72) = v32;
            *(_OWORD *)(a1 + 88) = *v28;
            return;
          }
          uint64_t v151 = *(unsigned char **)(a1 + 24);
          uint64_t v152 = (v128 - v151) >> 4;
          unint64_t v153 = v152 + 1;
          if (!((unint64_t)(v152 + 1) >> 60))
          {
            uint64_t v154 = v108 - (void)v151;
            if (v154 >> 3 > v153) {
              unint64_t v153 = v154 >> 3;
            }
            _CF = (unint64_t)v154 >= 0x7FFFFFFFFFFFFFF0;
            unint64_t v155 = 0xFFFFFFFFFFFFFFFLL;
            if (!_CF) {
              unint64_t v155 = v153;
            }
            if (v155)
            {
              uint64_t v156 = std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshFace>>(v155);
              float64x2_t v32 = v180;
              unint64_t v155 = (unint64_t)v156;
              uint64_t v151 = *(unsigned char **)(a1 + 24);
              uint64_t v128 = *(char **)(a1 + 32);
            }
            else
            {
              uint64_t v157 = 0;
            }
            double v171 = (float64x2_t *)(v155 + 16 * v152);
            unint64_t v172 = v155 + 16 * v157;
            float64x2_t *v171 = v32;
            f64 = (_OWORD *)v171[1].f64;
            if (v128 != v151)
            {
              do
              {
                v171[-1] = *((float64x2_t *)v128 - 1);
                --v171;
                v128 -= 16;
              }
              while (v128 != v151);
              uint64_t v151 = *(unsigned char **)(a1 + 24);
            }
            *(void *)(a1 + 24) = v171;
            *(void *)(a1 + 32) = f64;
            *(void *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v172;
            if (v151)
            {
              operator delete(v151);
              float64x2_t v32 = v180;
            }
            goto LABEL_197;
          }
LABEL_205:
          abort();
        }
        if (*(double *)(a1 + 88) != *(double *)(a1 + 72) || *(double *)(a1 + 96) != *(double *)(a1 + 80)) {
        unsigned int v69 = *(unsigned char **)(a1 + 8);
        }
        unint64_t v68 = *(void *)(a1 + 16);
        if ((unint64_t)v69 >= v68)
        {
          unint64_t v96 = *(void *)a1;
          uint64_t v97 = &v69[-*(void *)a1];
          unint64_t v98 = (unint64_t)(v97 + 1);
          if ((uint64_t)(v97 + 1) < 0) {
            goto LABEL_205;
          }
          unint64_t v99 = v68 - v96;
          if (2 * v99 > v98) {
            unint64_t v98 = 2 * v99;
          }
          if (v99 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v100 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v100 = v98;
          }
          if (v100) {
            int v101 = operator new(v100);
          }
          else {
            int v101 = 0;
          }
          int v105 = &v101[v100];
          v97[(void)v101] = 4;
          uint64_t v70 = (uint64_t)&v97[(void)v101 + 1];
          if (v69 == (unsigned char *)v96)
          {
            int v101 = &v97[(void)v101];
          }
          else
          {
            int v106 = &v69[~v96];
            do
            {
              char v107 = *--v69;
              (v106--)[(void)v101] = v107;
            }
            while (v69 != (unsigned char *)v96);
            unsigned int v69 = *(unsigned char **)a1;
          }
          *(void *)a1 = v101;
          *(void *)(a1 + 8) = v70;
          *(void *)(a1 + 16) = v105;
          if (v69) {
            operator delete(v69);
          }
        }
        else
        {
          *unsigned int v69 = 4;
          uint64_t v70 = (uint64_t)(v69 + 1);
        }
        *(void *)(a1 + 8) = v70;
        int v119 = *(float64x2_t **)(a1 + 32);
        unint64_t v118 = *(void *)(a1 + 40);
        if ((unint64_t)v119 >= v118)
        {
          uint64_t v121 = *(void *)(a1 + 24);
          uint64_t v122 = ((uint64_t)v119 - v121) >> 4;
          unint64_t v123 = v122 + 1;
          if ((unint64_t)(v122 + 1) >> 60) {
            goto LABEL_205;
          }
          uint64_t v124 = v118 - v121;
          if (v124 >> 3 > v123) {
            unint64_t v123 = v124 >> 3;
          }
          if ((unint64_t)v124 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v125 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v125 = v123;
          }
          if (v125) {
            unint64_t v125 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshFace>>(v125);
          }
          else {
            uint64_t v126 = 0;
          }
          uint64_t v136 = (float64x2_t *)(v125 + 16 * v122);
          unint64_t v137 = v125 + 16 * v126;
          *uint64_t v136 = *a3;
          int v120 = (_OWORD *)v136[1].f64;
          long long v139 = *(float64x2_t **)(a1 + 24);
          __int16 v138 = *(float64x2_t **)(a1 + 32);
          if (v138 != v139)
          {
            do
            {
              v136[-1] = v138[-1];
              --v136;
              --v138;
            }
            while (v138 != v139);
            __int16 v138 = *(float64x2_t **)(a1 + 24);
          }
          *(void *)(a1 + 24) = v136;
          *(void *)(a1 + 32) = v120;
          *(void *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v137;
          if (v138) {
            operator delete(v138);
          }
        }
        else
        {
          *int v119 = *a3;
          int v120 = (_OWORD *)v119[1].f64;
        }
        *(void *)(a1 + 32) = v120;
        long long v140 = (_OWORD *)a3[1].f64;
        unint64_t v141 = *(void *)(a1 + 40);
        if ((unint64_t)v120 >= v141)
        {
          uint64_t v143 = *(void *)(a1 + 24);
          uint64_t v144 = ((uint64_t)v120 - v143) >> 4;
          if ((unint64_t)(v144 + 1) >> 60) {
            goto LABEL_205;
          }
          uint64_t v145 = v141 - v143;
          uint64_t v146 = v145 >> 3;
          if (v145 >> 3 <= (unint64_t)(v144 + 1)) {
            uint64_t v146 = v144 + 1;
          }
          if ((unint64_t)v145 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v147 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v147 = v146;
          }
          if (v147) {
            unint64_t v147 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshFace>>(v147);
          }
          else {
            uint64_t v148 = 0;
          }
          int v158 = (_OWORD *)(v147 + 16 * v144);
          unint64_t v159 = v147 + 16 * v148;
          *int v158 = *v140;
          uint64_t v142 = v158 + 1;
          int v161 = *(char **)(a1 + 24);
          uint64_t v160 = *(char **)(a1 + 32);
          if (v160 != v161)
          {
            do
            {
              *--int v158 = *((_OWORD *)v160 - 1);
              v160 -= 16;
            }
            while (v160 != v161);
            uint64_t v160 = *(char **)(a1 + 24);
          }
          *(void *)(a1 + 24) = v158;
          *(void *)(a1 + 32) = v142;
          *(void *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v159;
          if (v160) {
            operator delete(v160);
          }
        }
        else
        {
          *int v120 = *v140;
          uint64_t v142 = v120 + 1;
        }
        *(void *)(a1 + 32) = v142;
        long long v162 = (_OWORD *)a3[2].f64;
        unint64_t v163 = *(void *)(a1 + 40);
        if ((unint64_t)v142 >= v163)
        {
          uint64_t v165 = *(void *)(a1 + 24);
          uint64_t v166 = ((uint64_t)v142 - v165) >> 4;
          if ((unint64_t)(v166 + 1) >> 60) {
            goto LABEL_205;
          }
          uint64_t v167 = v163 - v165;
          uint64_t v168 = v167 >> 3;
          if (v167 >> 3 <= (unint64_t)(v166 + 1)) {
            uint64_t v168 = v166 + 1;
          }
          if ((unint64_t)v167 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v169 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v169 = v168;
          }
          if (v169) {
            unint64_t v169 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshFace>>(v169);
          }
          else {
            uint64_t v170 = 0;
          }
          unint64_t v173 = (_OWORD *)(v169 + 16 * v166);
          unint64_t v174 = v169 + 16 * v170;
          _OWORD *v173 = *v162;
          long long v164 = v173 + 1;
          unint64_t v176 = *(char **)(a1 + 24);
          uint64_t v175 = *(char **)(a1 + 32);
          if (v175 != v176)
          {
            do
            {
              *--unint64_t v173 = *((_OWORD *)v175 - 1);
              v175 -= 16;
            }
            while (v175 != v176);
            uint64_t v175 = *(char **)(a1 + 24);
          }
          *(void *)(a1 + 24) = v173;
          *(void *)(a1 + 32) = v164;
          *(void *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v174;
          if (v175) {
            operator delete(v175);
          }
        }
        else
        {
          *uint64_t v142 = *v162;
          long long v164 = v142 + 1;
        }
        *(void *)(a1 + 32) = v164;
        *unint64_t v28 = *v162;
        *(_OWORD *)(a1 + 88) = *v162;
        return;
      default:
        return;
    }
  }
  if ((a2 - 2) > 2) {
    float64x2_t v24 = *(float64x2_t *)(a1 + 56);
  }
  else {
    float64x2_t v24 = a3[CA::Render::path_counts[a2] - 1];
  }
  *(float64x2_t *)(a1 + 72) = v24;
}

CA::Render **CA::Render::morph_paths(CA::Render **this, CA::Render **a2, CA::Render::Path *a3, float a4)
{
  unint64_t v5 = this;
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  if (fabsf(a4) >= 0.00001)
  {
    if (fabsf(a4 + -1.0) < 0.00001)
    {
      if (!a2) {
        return 0;
      }
      unint64_t v6 = (atomic_uint *)(a2 + 1);
      unint64_t v5 = a2;
      if (!atomic_fetch_add((atomic_uint *volatile)a2 + 2, 1u)) {
        goto LABEL_8;
      }
      return v5;
    }
    unint64_t v8 = CA::Render::spline_count(this[4], this[5]);
    unint64_t v9 = CA::Render::spline_count(a2[4], a2[5]);
    uint64_t v10 = 9 * v8;
    unint64_t v109 = v8;
    unint64_t v110 = v9;
    if (v8 <= v9) {
      unint64_t v8 = v9;
    }
    size_t v11 = 8 * v10;
    size_t v12 = 72 * v9;
    if ((unint64_t)(8 * v10) > 0x1000)
    {
      double v14 = (char *)malloc_type_malloc(v11, 0x9864B051uLL);
      double v13 = v14;
    }
    else
    {
      MEMORY[0x1F4188790](v9);
      double v13 = (char *)&v105 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v13, v11);
    }
    unint64_t v15 = 72 * v8;
    if (v12 > 0x1000)
    {
      double v17 = (char *)malloc_type_malloc(v12, 0x38F53A9AuLL);
      double v16 = v17;
    }
    else
    {
      MEMORY[0x1F4188790](v14);
      double v16 = (char *)&v105 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v16, v12);
    }
    if (v15 > 0x1000)
    {
      double v18 = (char *)malloc_type_malloc(72 * v8, 0x5F44305FuLL);
    }
    else
    {
      MEMORY[0x1F4188790](v17);
      double v18 = (char *)&v105 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v18, 72 * v8);
    }
    double v19 = 0;
    if (!v13 || !v16 || !v18) {
      goto LABEL_127;
    }
    CA::Render::make_splines((long long *)v5[4], (unsigned __int8 *)v5[5], (unint64_t)v13);
    CA::Render::make_splines((long long *)a2[4], (unsigned __int8 *)a2[5], (unint64_t)v16);
    unint64_t v22 = v109;
    unint64_t v21 = v110;
    if (v109 >= v110) {
      unint64_t v23 = v110;
    }
    else {
      unint64_t v23 = v109;
    }
    size_t v107 = v12;
    size_t v108 = v11;
    uint64_t v106 = 72 * v8;
    if (!v23)
    {
LABEL_72:
      if (v23 < v22)
      {
        if (v21)
        {
          uint64_t v47 = (float64x2_t *)&v16[72 * v23 - 56];
          float64x2_t v48 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(a4), 0);
          do
          {
            uint64_t v49 = 0;
            float64x2_t v50 = &v13[72 * v23];
            float64x2_t v51 = &v18[72 * v23];
            char v52 = 1;
            do
            {
              char v53 = v52;
              *(float64x2_t *)&v51[16 * v49] = vmlaq_f64(*(float64x2_t *)&v50[16 * v49], v48, vsubq_f64(*v47, *(float64x2_t *)&v50[16 * v49]));
              float64x2_t v54 = &v50[8 * v49];
              double v55 = *((double *)v54 + 4);
              if ((*(void *)&v55 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
                double v55 = 0.0;
              }
              float64x2_t v56 = &v51[8 * v49];
              *((double *)v56 + 4) = v55;
              *((double *)v56 + 6) = *((double *)v54 + 6) - *((double *)v54 + 6) * a4;
              uint64_t v49 = 1;
              char v52 = 0;
            }
            while ((v53 & 1) != 0);
            *(_WORD *)&v18[72 * v23 + 64] = *(_WORD *)&v13[72 * v23 + 64];
            ++v23;
          }
          while (v23 != v22);
        }
        else
        {
          float64x2_t v57 = &v18[72 * v23];
          mach_port_name_t v58 = &v13[72 * v23];
          do
          {
            *(_OWORD *)float64x2_t v57 = *(_OWORD *)v58;
            long long v59 = *((_OWORD *)v58 + 1);
            long long v60 = *((_OWORD *)v58 + 2);
            long long v61 = *((_OWORD *)v58 + 3);
            *((_WORD *)v57 + 32) = *((_WORD *)v58 + 32);
            *((_OWORD *)v57 + 2) = v60;
            *((_OWORD *)v57 + 3) = v61;
            *((_OWORD *)v57 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v59;
            ++v23;
            v57 += 72;
            v58 += 72;
          }
          while (v22 != v23);
        }
        unint64_t v23 = v22;
      }
      unint64_t v62 = v21 - v23;
      if (v21 > v23)
      {
        if (v22)
        {
          long long v63 = (float64x2_t *)&v13[72 * v23 - 56];
          float64x2_t v64 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(a4), 0);
          do
          {
            uint64_t v65 = 0;
            size_t v66 = &v16[72 * v23];
            uint64_t v67 = &v18[72 * v23];
            char v68 = 1;
            do
            {
              char v69 = v68;
              *(float64x2_t *)&v67[16 * v65] = vmlaq_f64(*v63, v64, vsubq_f64(*(float64x2_t *)&v66[16 * v65], *v63));
              uint64_t v70 = &v66[8 * v65];
              double v71 = *((double *)v70 + 4);
              if ((*(void *)&v71 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
                double v71 = 0.0;
              }
              id v72 = &v67[8 * v65];
              *((double *)v72 + 4) = v71;
              *((double *)v72 + 6) = *((double *)v70 + 6) * a4;
              uint64_t v65 = 1;
              char v68 = 0;
            }
            while ((v69 & 1) != 0);
            *(_WORD *)&v18[72 * v23 + 64] = *(_WORD *)&v16[72 * v23 + 64];
            ++v23;
          }
          while (v23 != v21);
        }
        else
        {
          char v73 = &v18[72 * v23];
          double v74 = &v16[72 * v23];
          do
          {
            *(_OWORD *)char v73 = *(_OWORD *)v74;
            long long v75 = *((_OWORD *)v74 + 1);
            long long v76 = *((_OWORD *)v74 + 2);
            long long v77 = *((_OWORD *)v74 + 3);
            *((_WORD *)v73 + 32) = *((_WORD *)v74 + 32);
            *((_OWORD *)v73 + 2) = v76;
            *((_OWORD *)v73 + 3) = v77;
            *((_OWORD *)v73 + CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = v75;
            v73 += 72;
            v74 += 72;
            --v62;
          }
          while (v62);
        }
      }
      if (v8)
      {
        int v78 = 0;
        unsigned int v79 = 0;
        LODWORD(v8CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
        uint64_t v81 = v18 + 65;
        unint64_t v82 = v8;
        BOOL v83 = 1;
        do
        {
          if (*(double *)(v81 - 17) == 0.0 && *(double *)(v81 - 9) == 0.0) {
            int v84 = 1;
          }
          else {
            int v84 = 3;
          }
          int v85 = v83;
          int v86 = v80 + v85;
          v79 += v85 + v84;
          if (*v81) {
            int v87 = 2;
          }
          else {
            int v87 = 1;
          }
          unint64_t v80 = (CA::Render::Path *)(v86 + v87);
          v78 += v87;
          BOOL v83 = *(v81 - 1) != 0;
          v81 += 72;
          --v82;
        }
        while (v82);
        uint64_t v88 = CA::Render::Path::new_path(v80, v79, v78);
        double v19 = v88;
        if (!v88)
        {
LABEL_127:
          if (v18 && v15 > 0x1000) {
            free(v18);
          }
          goto LABEL_130;
        }
        long long v89 = v18 + 32;
        uint64_t v91 = *((void *)v88 + 4);
        unint64_t v90 = (unsigned char *)*((void *)v88 + 5);
        BOOL v92 = 1;
        do
        {
          unint64_t v93 = v89 - 32;
          if (v92)
          {
            *v90++ = 1;
            *(_OWORD *)uint64_t v91 = *(_OWORD *)v93;
            v91 += 16;
          }
          if (*((double *)v89 + 2) == 0.0 && *((double *)v89 + 3) == 0.0)
          {
            *unint64_t v90 = 2;
            *(_OWORD *)uint64_t v91 = *((_OWORD *)v89 - 1);
            v91 += 16;
          }
          else
          {
            *unint64_t v90 = 4;
            double v94 = *((double *)v89 + 2);
            if (v94 == 0.0)
            {
              *(_OWORD *)uint64_t v91 = *(_OWORD *)v93;
            }
            else
            {
              double v95 = *((double *)v89 - 4);
              *(long double *)uint64_t v91 = v95 + cos(*(long double *)v89) * v94;
              double v96 = *((double *)v89 - 3);
              double v97 = *((double *)v89 + 2);
              *(long double *)(v91 + 8) = v96 + sin(*(long double *)v89) * v97;
            }
            double v98 = *((double *)v89 + 3);
            unint64_t v99 = v89 - 16;
            if (v98 == 0.0)
            {
              *(_OWORD *)(v91 + 16) = *(_OWORD *)v99;
            }
            else
            {
              double v100 = *((double *)v89 - 2);
              *(long double *)(v91 + 16) = v100 + cos(*((long double *)v89 + 1)) * v98;
              double v101 = *((double *)v89 - 1);
              double v102 = *((double *)v89 + 3);
              *(long double *)(v91 + 24) = v101 + sin(*((long double *)v89 + 1)) * v102;
            }
            *(_OWORD *)(v91 + 32) = *(_OWORD *)v99;
            v91 += 48;
          }
          if (v89[33])
          {
            v90[1] = 0;
            v90 += 2;
          }
          else
          {
            ++v90;
          }
          BOOL v92 = v89[32] != 0;
          v89 += 72;
          --v8;
        }
        while (v8);
        size_t v12 = v107;
        size_t v11 = v108;
        unint64_t v15 = v106;
      }
      else
      {
        int v103 = CA::Render::Path::new_path(0, 0, 0);
        double v19 = v103;
        if (!v103)
        {
LABEL_130:
          if (v16 && v12 > 0x1000) {
            free(v16);
          }
          if (v11 > 0x1000 && v13) {
            free(v13);
          }
          return (CA::Render **)v19;
        }
        unint64_t v90 = (unsigned char *)*((void *)v103 + 5);
      }
      *unint64_t v90 = 5;
      goto LABEL_127;
    }
    unint64_t v24 = 0;
    unint64_t v25 = 0;
    *(double *)&long long v20 = a4;
    float64x2_t v26 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(a4), 0);
    char v27 = 1;
    float64x2_t v111 = v26;
    long long v112 = v20;
    do
    {
      if (v13[72 * v25 + 64] || v16[72 * v25 + 64])
      {
        if ((v27 & 1) != 0 && v13[72 * v25 + 65] && v16[72 * v25 + 65])
        {
          CA::Render::mix_splines((uint64_t)v18, (uint64_t)v13, (uint64_t)v16, v25, v24, a4);
          float64x2_t v26 = v111;
          *(void *)&long long v20 = v112;
          ++v25;
          char v27 = 1;
        }
        else
        {
          unint64_t v28 = (float64x2_t *)&v13[72 * (int)v25];
          int v29 = (float64x2_t *)&v16[72 * (int)v25];
          *(float64x2_t *)&v18[72 * (int)v25 + 16] = vmlaq_f64(v28[1], v26, vsubq_f64(v29[1], v28[1]));
          double v30 = v28[2].f64[1];
          double v31 = v29[2].f64[1];
          if ((*(void *)&v30 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
          {
            if ((*(void *)&v31 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
              double v30 = 0.0;
            }
            else {
              double v30 = v29[2].f64[1];
            }
          }
          else if ((*(void *)&v31 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
          {
            if (vabdd_f64(v30, v31) > 3.14159265)
            {
              if (v30 <= v31) {
                double v31 = v31 + -6.28318531;
              }
              else {
                double v30 = v30 + -6.28318531;
              }
            }
            double v30 = v30 + (v31 - v30) * *(double *)&v20;
          }
          float64x2_t v32 = &v18[72 * (int)v25];
          *((double *)v32 + 5) = v30;
          double v33 = *(double *)&v13[72 * (int)v25 + 56];
          float64x2_t v34 = &v16[72 * (int)v25];
          *((double *)v32 + 7) = v33 + (*((double *)v34 + 7) - v33) * *(double *)&v20;
          *((_WORD *)v32 + 32) = *((_WORD *)v34 + 32);
          float64x2_t v35 = (float64x2_t *)&v13[72 * (int)v24];
          long long v36 = (float64x2_t *)&v16[72 * (int)v24];
          *(float64x2_t *)&v18[72 * (int)v24] = vmlaq_f64(*v35, v26, vsubq_f64(*v36, *v35));
          double v37 = v35[2].f64[0];
          double v38 = v36[2].f64[0];
          if ((*(void *)&v37 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
          {
            if ((*(void *)&v38 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
              double v37 = 0.0;
            }
            else {
              double v37 = v38;
            }
          }
          else if ((*(void *)&v38 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
          {
            if (vabdd_f64(v37, v38) > 3.14159265)
            {
              if (v37 <= v38) {
                double v38 = v38 + -6.28318531;
              }
              else {
                double v37 = v37 + -6.28318531;
              }
            }
            double v37 = v37 + (v38 - v37) * *(double *)&v20;
          }
          char v27 = 0;
          long long v39 = &v18[72 * (int)v24];
          *((double *)v39 + 4) = v37;
          double v40 = *(double *)&v13[72 * (int)v24 + 48];
          *((double *)v39 + 6) = v40 + (*(double *)&v16[72 * (int)v24 + 48] - v40) * *(double *)&v20;
          ++v25;
        }
        unint64_t v24 = v25;
      }
      else
      {
        CA::Render::mix_splines((uint64_t)v18, (uint64_t)v13, (uint64_t)v16, v25, v25 + 1, a4);
        float64x2_t v26 = v111;
        *(void *)&long long v20 = v112;
        ++v25;
      }
    }
    while (v25 != v23);
    if (v24 >= v23)
    {
      size_t v12 = v107;
      size_t v11 = v108;
      unint64_t v15 = v106;
      unint64_t v22 = v109;
      unint64_t v21 = v110;
      goto LABEL_72;
    }
    float64x2_t v41 = (float64x2_t *)&v13[72 * (int)v24];
    float64x2_t v42 = (float64x2_t *)&v16[72 * (int)v24];
    *(float64x2_t *)&v18[72 * (int)v24] = vmlaq_f64(*v41, v26, vsubq_f64(*v42, *v41));
    double v43 = v41[2].f64[0];
    double v44 = v42[2].f64[0];
    size_t v12 = v107;
    size_t v11 = v108;
    unint64_t v15 = v106;
    if ((*(void *)&v43 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
    {
      double v43 = 0.0;
      if ((*(void *)&v44 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000) {
        double v43 = v44;
      }
    }
    else if ((*(void *)&v44 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
    {
      unint64_t v22 = v109;
      unint64_t v21 = v110;
      if (vabdd_f64(v43, v44) > 3.14159265)
      {
        if (v43 <= v44) {
          double v44 = v44 + -6.28318531;
        }
        else {
          double v43 = v43 + -6.28318531;
        }
      }
      double v43 = v43 + (v44 - v43) * *(double *)&v20;
      goto LABEL_71;
    }
    unint64_t v22 = v109;
    unint64_t v21 = v110;
LABEL_71:
    float64x2_t v45 = &v18[72 * (int)v24];
    *((double *)v45 + 4) = v43;
    double v46 = *(double *)&v13[72 * (int)v24 + 48];
    *((double *)v45 + 6) = v46 + (*(double *)&v16[72 * (int)v24 + 48] - v46) * *(double *)&v20;
    goto LABEL_72;
  }
  if (this)
  {
    unint64_t v6 = (atomic_uint *)(this + 1);
    if (!atomic_fetch_add((atomic_uint *volatile)this + 2, 1u))
    {
LABEL_8:
      unint64_t v5 = 0;
      atomic_fetch_add(v6, 0xFFFFFFFF);
    }
  }
  return v5;
}

uint64_t CA::Render::mix_splines(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, float a6)
{
  unint64_t v6 = (float64x2_t *)(a2 + 72 * a4);
  double v7 = a6;
  unint64_t v8 = (float64x2_t *)(a3 + 72 * a4);
  unint64_t v9 = (float64x2_t *)(result + 72 * a5);
  uint64_t v10 = (float64x2_t *)(result + 72 * a4);
  float64x2_t v11 = vmlaq_n_f64(v6[1], vsubq_f64(v8[1], v6[1]), v7);
  *unint64_t v9 = v11;
  v10[1] = v11;
  float64_t v13 = v6[3].f64[1];
  size_t v12 = &v6[3].f64[1];
  v11.f64[0] = v13;
  double v15 = v8[3].f64[1];
  double v14 = &v8[3].f64[1];
  v10[3].f64[1] = v11.f64[0] + (v15 - v11.f64[0]) * v7;
  uint64_t v16 = a2 + 72 * a5;
  float64_t v18 = *(double *)(v16 + 48);
  double v17 = (double *)(v16 + 48);
  v11.f64[0] = v18;
  uint64_t v19 = a3 + 72 * a5;
  double v21 = *(double *)(v19 + 48);
  long long v20 = (double *)(v19 + 48);
  v9[3].f64[0] = v11.f64[0] + (v21 - v11.f64[0]) * v7;
  double v22 = *(v12 - 2);
  if ((*(void *)&v22 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || *v12 == 0.0)
  {
    double v22 = *(double *)(a3 + 72 * a4 + 40);
    if ((*(void *)&v22 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
      double v22 = 0.0;
    }
  }
  else
  {
    double v25 = *(double *)(a3 + 72 * a4 + 40);
    if ((*(void *)&v25 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && *v14 != 0.0)
    {
      if (vabdd_f64(v22, v25) > 3.14159265)
      {
        if (v22 <= v25) {
          double v25 = v25 + -6.28318531;
        }
        else {
          double v22 = v22 + -6.28318531;
        }
      }
      double v22 = v22 + (v25 - v22) * v7;
    }
  }
  *(double *)(result + 72 * a4 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = v22;
  if ((*(void *)v17 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || *v17 == 0.0)
  {
    double v23 = 0.0;
    if ((*(void *)(a3 + 72 * a5 + 32) & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000) {
      double v23 = *(double *)(a3 + 72 * a5 + 32);
    }
  }
  else
  {
    double v23 = *(double *)(a2 + 72 * a5 + 32);
    if ((*(void *)v20 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && *v20 != 0.0)
    {
      double v24 = *(double *)(a3 + 72 * a5 + 32);
      if ((*(void *)&v23 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
      {
        if ((*(void *)(a3 + 72 * a5 + 32) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
          double v23 = 0.0;
        }
        else {
          double v23 = *(double *)(a3 + 72 * a5 + 32);
        }
      }
      else if ((*(void *)(a3 + 72 * a5 + 32) & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
      {
        if (vabdd_f64(v23, v24) > 3.14159265)
        {
          if (v23 <= v24) {
            double v24 = v24 + -6.28318531;
          }
          else {
            double v23 = v23 + -6.28318531;
          }
        }
        double v23 = v23 + (v24 - v23) * v7;
      }
    }
  }
  *(double *)(result + 72 * a5 + 32) = v23;
  *(_WORD *)(result + 72 * a4 + 64) = *(_WORD *)(a3 + 72 * a4 + 64);
  return result;
}

uint64_t CA::Render::spline_count(CA::Render *this, CA::Render::Path *a2)
{
  int v3 = 0;
  unint64_t v4 = 0;
  uint64_t result = 0;
  while (1)
  {
    int v6 = *(unsigned __int8 *)a2;
    a2 = (CA::Render::Path *)((char *)a2 + 1);
    double v7 = v3;
    unint64_t v8 = this;
    switch(v6)
    {
      case 0:
        int v3 = 0;
        if (v7)
        {
          if (*v4 != *v7 || (int v3 = 0, v4[1] != v7[1]))
          {
            int v3 = 0;
            ++result;
          }
        }
        continue;
      case 1:
        this = (CA::Render *)((char *)this + 16);
        int v3 = (double *)v8;
        unint64_t v4 = (double *)v8;
        continue;
      case 2:
        this = (CA::Render *)((char *)this + 16);
        ++result;
        unint64_t v4 = (double *)v8;
        continue;
      case 3:
        unint64_t v4 = (double *)((char *)this + 16);
        this = (CA::Render *)((char *)this + 32);
        goto LABEL_11;
      case 4:
        unint64_t v4 = (double *)((char *)this + 32);
        this = (CA::Render *)((char *)this + 48);
LABEL_11:
        ++result;
        break;
      case 5:
        return result;
      default:
        continue;
    }
  }
}

long long *CA::Render::make_splines(long long *result, unsigned __int8 *a2, unint64_t a3)
{
  unint64_t v5 = 0;
  int v6 = 0;
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  float64x2_t v16 = (float64x2_t)vdupq_n_s64(0x3FE5555555555555uLL);
  float64x2_t v17 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
  unint64_t v7 = a3;
  while (1)
  {
    int v8 = *a2++;
    unint64_t v9 = v5;
    uint64_t v10 = result;
    switch(v8)
    {
      case 0:
        unint64_t v5 = 0;
        if (v9)
        {
          if (*v6 == *v9 && v6[1] == v9[1])
          {
            unint64_t v5 = 0;
            if (v7 > a3)
            {
              unint64_t v5 = 0;
              *(_WORD *)(v7 - 8) = 257;
            }
          }
          else
          {
            unint64_t v5 = 0;
            *(_OWORD *)unint64_t v7 = *(_OWORD *)v6;
            long long v11 = *(_OWORD *)v9;
            *(_OWORD *)(v7 + 32) = 0u;
            *(_OWORD *)(v7 + 48) = 0u;
            *(_OWORD *)(v7 + 16) = v11;
            *(_WORD *)(v7 + 64) = 257;
            v7 += 72;
          }
        }
        break;
      case 1:
        if (v5 && v7 > a3) {
          *(unsigned char *)(v7 - 8) = 1;
        }
        ++result;
        unint64_t v5 = (double *)v10;
        int v6 = (double *)v10;
        break;
      case 2:
        *(_OWORD *)unint64_t v7 = *(_OWORD *)v6;
        *(_OWORD *)(v7 + 16) = *result;
        float64x2_t v19 = 0uLL;
        float64x2_t v12 = *(float64x2_t *)v7;
        float64x2_t v13 = vsubq_f64(*(float64x2_t *)(v7 + 16), *(float64x2_t *)v7);
        float64x2_t v19 = vmlaq_f64(*(float64x2_t *)v7, v17, v13);
        float64x2_t v18 = vmlaq_f64(v12, v16, v13);
        CA::Render::compute_angles(v7, v19.f64, v18.f64);
        *(_WORD *)(v7 + 64) = 0;
        v7 += 72;
        uint64_t result = v10 + 1;
        unint64_t v5 = v9;
        int v6 = (double *)v10;
        break;
      case 3:
        *(_OWORD *)unint64_t v7 = *(_OWORD *)v6;
        *(_OWORD *)(v7 + 16) = result[1];
        float64x2_t v19 = 0uLL;
        float64x2_t v14 = vaddq_f64(*(float64x2_t *)result, *(float64x2_t *)result);
        float64x2_t v15 = vmulq_f64(vaddq_f64(*(float64x2_t *)v7, v14), v17);
        int v6 = (double *)(result + 1);
        float64x2_t v18 = vmulq_f64(vaddq_f64(*(float64x2_t *)(v7 + 16), v14), v17);
        float64x2_t v19 = v15;
        CA::Render::compute_angles(v7, v19.f64, v18.f64);
        *(_WORD *)(v7 + 64) = 0;
        v7 += 72;
        uint64_t result = v10 + 2;
        unint64_t v5 = v9;
        break;
      case 4:
        *(_OWORD *)unint64_t v7 = *(_OWORD *)v6;
        int v6 = (double *)(result + 2);
        *(_OWORD *)(v7 + 16) = result[2];
        CA::Render::compute_angles(v7, (double *)result, (double *)result + 2);
        *(_WORD *)(v7 + 64) = 0;
        v7 += 72;
        uint64_t result = v10 + 3;
        unint64_t v5 = v9;
        break;
      case 5:
        if (v5 && v7 > a3) {
          *(unsigned char *)(v7 - 8) = 1;
        }
        return result;
      default:
        continue;
    }
  }
}

void CA::Render::compute_angles(uint64_t a1, double *a2, double *a3)
{
  double v6 = a2[1];
  double v8 = *(double *)a1;
  double v7 = *(double *)(a1 + 8);
  if (vabdd_f64(*a2, *(double *)a1) >= 0.0001 || vabdd_f64(v6, v7) >= 0.0001)
  {
    long double v11 = *a2 - v8;
    double v12 = v6 - v7;
    *(long double *)(a1 + 32) = atan2(v6 - v7, v11);
    double v13 = (v11 * v11 + v12 * v12) / sqrt(fmax(v11 * v11 + v12 * v12, 0.000001));
  }
  else
  {
    double v9 = *a3;
    double v10 = a3[1];
    if (vabdd_f64(*a3, v8) >= 0.0001
      || vabdd_f64(v10, v7) >= 0.0001
      || (double v9 = *(double *)(a1 + 16), v10 = *(double *)(a1 + 24), vabdd_f64(v9, v8) >= 0.0001)
      || vabdd_f64(v10, v7) >= 0.0001)
    {
      *(long double *)(a1 + 32) = atan2(v10 - v7, v9 - v8);
    }
    else
    {
      *(void *)(a1 + 32) = 0x7FF8000000000000;
    }
    double v13 = 0.0;
  }
  *(double *)(a1 + 48) = v13;
  double v14 = *a3;
  double v15 = a3[1];
  double v17 = *(double *)(a1 + 16);
  double v16 = *(double *)(a1 + 24);
  if (vabdd_f64(*a3, v17) < 0.0001 && vabdd_f64(v15, v16) < 0.0001)
  {
    double v18 = a2[1];
    if (vabdd_f64(*a2, v17) >= 0.0001 || vabdd_f64(v18, v16) >= 0.0001)
    {
      double v22 = *a2 - v17;
      double v23 = v18 - v16;
    }
    else
    {
      if (vabdd_f64(v8, v17) < 0.0001 && vabdd_f64(v7, v16) < 0.0001)
      {
        *(void *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0x7FF8000000000000;
LABEL_22:
        double v21 = 0.0;
        goto LABEL_23;
      }
      double v22 = v8 - v17;
      double v23 = v7 - v16;
    }
    *(long double *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = atan2(v23, v22);
    goto LABEL_22;
  }
  double v19 = v14 - v17;
  double v20 = v15 - v16;
  *(long double *)(a1 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = atan2(v15 - v16, v14 - v17);
  double v21 = (v19 * v19 + v20 * v20) / sqrt(fmax(v19 * v19 + v20 * v20, 0.000001));
LABEL_23:
  *(double *)(a1 + 56) = v21;
}

_DWORD *CA::Render::Path::new_path(CA::Render::Path *this, unsigned int a2, int a3)
{
  int v5 = (int)this;
  size_t v6 = (this + 1) + 16 * a2 + 112;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t result = malloc_type_zone_malloc(malloc_zone, v6, 0x8BB15036uLL);
  if (result)
  {
    result[2] = 1;
    result[3] = 36;
    ++dword_1EB2ADE58;
    *(void *)uint64_t result = &unk_1ED02F0E0;
    result[4] = a3;
    result[5] = v5;
    result[6] = a2;
    *((void *)result + 4) = result + 28;
    *((void *)result + 5) = &result[4 * a2 + 28];
    *((void *)result + 7) = 0;
    *((void *)result + 8) = 0;
    *((void *)result + 6) = 0;
  }
  return result;
}

CA::Render::MeshTransform *CA::Render::MeshTransform::MeshTransform(CA::Render::MeshTransform *this, unint64_t a2, unint64_t a3, int a4)
{
  *((_DWORD *)this + 2) = 1;
  ++dword_1EB2ADE4C;
  *(void *)this = &unk_1ED02DBE8;
  *(void *)((char *)this + 12) = 33;
  *((void *)this + 3) = 0;
  double v7 = (void *)((char *)this + 24);
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  if (a2)
  {
    std::vector<CA::Render::MeshVertex>::__vallocate[abi:nn180100](v7, a2);
    double v9 = (char *)*((void *)this + 4);
    bzero(v9, 32 * a2);
    *((void *)this + 4) = &v9[32 * a2];
  }
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  if (a3)
  {
    std::vector<CA::Render::MeshFace>::__vallocate[abi:nn180100]((void *)this + 6, a3);
    double v10 = (char *)*((void *)this + 7);
    bzero(v10, 16 * a3);
    *((void *)this + 7) = &v10[16 * a3];
    *((void *)this + 9) = 0;
    *((void *)this + 1CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
    *((void *)this + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
    if (4 * a3)
    {
      std::vector<CA::Render::MeshFace>::__vallocate[abi:nn180100]((void *)this + 9, 4 * a3);
      long double v11 = (char *)*((void *)this + 10);
      bzero(v11, a3 << 6);
      *((void *)this + 1CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = &v11[64 * a3];
    }
  }
  else
  {
    *((void *)this + 9) = 0;
    *((void *)this + 1CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
    *((void *)this + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  }
  *((_DWORD *)this + 24) = 0;
  *((_DWORD *)this + 25) = a4;
  *((_DWORD *)this + 26) = 0;
  *((unsigned char *)this + 108) = 0;
  *((void *)this + 25) = 0;
  return this;
}

CA::Render::MeshTransform *CA::Render::MeshTransform::MeshTransform(CA::Render::MeshTransform *this, const CA::Render::MeshTransform *a2)
{
  *((_DWORD *)this + 2) = 1;
  ++dword_1EB2ADE4C;
  *(void *)this = &unk_1ED02DBE8;
  *((void *)this + 3) = 0;
  unint64_t v4 = (void *)((char *)this + 24);
  *(void *)((char *)this + 12) = 33;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  int v5 = (char *)*((void *)a2 + 3);
  size_t v6 = (char *)*((void *)a2 + 4);
  if (v6 != v5)
  {
    std::vector<CA::Render::MeshVertex>::__vallocate[abi:nn180100](v4, (v6 - v5) >> 5);
    double v7 = (_OWORD *)*((void *)this + 4);
    do
    {
      long long v8 = *(_OWORD *)v5;
      long long v9 = *((_OWORD *)v5 + 1);
      v5 += 32;
      *double v7 = v8;
      v7[1] = v9;
      v7 += 2;
    }
    while (v5 != v6);
    *((void *)this + 4) = v7;
  }
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  long double v11 = (unsigned char *)*((void *)a2 + 6);
  double v10 = (unsigned char *)*((void *)a2 + 7);
  int64_t v12 = v10 - v11;
  if (v10 != v11)
  {
    std::vector<CA::Render::MeshFace>::__vallocate[abi:nn180100]((void *)this + 6, v12 >> 4);
    double v13 = (char *)*((void *)this + 7);
    memmove(v13, v11, v12);
    *((void *)this + 7) = &v13[v12];
  }
  *((void *)this + 9) = 0;
  *((void *)this + 1CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  *((void *)this + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 0;
  double v15 = (unsigned char *)*((void *)a2 + 9);
  double v14 = (unsigned char *)*((void *)a2 + 10);
  int64_t v16 = v14 - v15;
  if (v14 != v15)
  {
    std::vector<CA::Render::MeshFace>::__vallocate[abi:nn180100]((void *)this + 9, v16 >> 4);
    double v17 = (char *)*((void *)this + 10);
    memmove(v17, v15, v16);
    *((void *)this + 1CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = &v17[v16];
  }
  *((void *)this + 12) = *((void *)a2 + 12);
  *((_DWORD *)this + 26) = *((_DWORD *)a2 + 26);
  *((unsigned char *)this + 108) = *((unsigned char *)a2 + 108);
  *((_DWORD *)this + 28) = *((_DWORD *)a2 + 28);
  *(_OWORD *)((char *)this + 12CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = *(_OWORD *)((char *)a2 + 120);
  *(_OWORD *)((char *)this + 136) = *(_OWORD *)((char *)a2 + 136);
  long long v18 = *(_OWORD *)((char *)a2 + 152);
  long long v19 = *(_OWORD *)((char *)a2 + 168);
  *(_OWORD *)((char *)this + 184) = *(_OWORD *)((char *)a2 + 184);
  *(_OWORD *)((char *)this + 168) = v19;
  *(_OWORD *)((char *)this + 152) = v18;
  *((void *)this + 25) = 0;
  *((_DWORD *)this + 3) |= *((_DWORD *)a2 + 3) & 0xFFFFFF00;
  return this;
}

char *std::vector<CA::Render::MeshFace>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshFace>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshFace>>(unint64_t a1)
{
  if (a1 >> 60) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(16 * a1);
}

char *std::vector<CA::Render::MeshVertex>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshVertex>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshVertex>>(unint64_t a1)
{
  if (a1 >> 59) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(32 * a1);
}

BOOL setDepthNormalization(CAMeshTransform *a1, NSString *a2)
{
  BOOL result = [(NSString *)a2 isEqualToString:@"width"];
  if (result)
  {
    LODWORD(v5) = 2;
    a1->_normalizatiouint64_t n = 2;
  }
  else
  {
    BOOL result = [(NSString *)a2 isEqualToString:@"height"];
    if (result)
    {
      unint64_t v5 = 3;
    }
    else
    {
      BOOL result = [(NSString *)a2 isEqualToString:@"min"];
      if (result)
      {
        unint64_t v5 = 4;
      }
      else
      {
        BOOL result = [(NSString *)a2 isEqualToString:@"max"];
        if (result)
        {
          unint64_t v5 = 5;
        }
        else
        {
          BOOL result = [(NSString *)a2 isEqualToString:@"average"];
          if (result) {
            unint64_t v5 = 6;
          }
          else {
            unint64_t v5 = 1;
          }
        }
      }
    }
    a1->_normalizatiouint64_t n = v5;
  }
  impl = a1->_impl;
  if (impl)
  {
    int64_t subdivisionSteps = a1->_subdivisionSteps;
    impl[24] = v5;
    impl[25] = subdivisionSteps;
    *((unsigned char *)impl + 108) = a1->_replicatesEdges;
  }
  return result;
}

double *CA::Render::Path::keyframe_lengths(CA::Render::Path *this)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v1 = (double *)*((void *)this + 8);
  if (!v1)
  {
    uint64_t v3 = *((unsigned int *)this + 4);
    if (!v3) {
      return 0;
    }
    unint64_t v5 = (float64x2_t *)*((void *)this + 4);
    uint64_t v4 = (unsigned char *)*((void *)this + 5);
    if (*v4 != 1 || v5 == 0)
    {
      return 0;
    }
    else
    {
      size_t v7 = 8 * v3;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      long long v9 = (double *)malloc_type_zone_malloc(malloc_zone, v7, 0x8BB15036uLL);
      CFDictionaryRef v1 = v9;
      if (v9)
      {
        unint64_t v10 = *((unsigned int *)this + 4);
        if (v10)
        {
          unint64_t v11 = 0;
          int64_t v12 = v5 + 1;
          double v13 = 0.0;
          float64x2_t v14 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
          double v15 = v5;
          while (2)
          {
            int v16 = *++v4;
            switch(v16)
            {
              case 0:
                float64x2_t v17 = vsubq_f64(*v5, *v15);
                v17.f64[0] = vaddvq_f64(vmulq_f64(v17, v17));
                double v18 = sqrt(v17.f64[0]);
                if (v17.f64[0] == 1.0) {
                  double v19 = 1.0;
                }
                else {
                  double v19 = v18;
                }
                v9[v11++] = v19;
                double v13 = v19 + v13;
                double v20 = v12;
                goto LABEL_52;
              case 1:
                double v20 = v12 + 1;
                double v15 = v12;
                goto LABEL_22;
              case 2:
                double v20 = v12 + 1;
                float64x2_t v21 = vsubq_f64(*v12, *v5);
                v21.f64[0] = vaddvq_f64(vmulq_f64(v21, v21));
                double v22 = sqrt(v21.f64[0]);
                if (v21.f64[0] == 1.0) {
                  double v23 = 1.0;
                }
                else {
                  double v23 = v22;
                }
                v9[v11++] = v23;
                double v13 = v23 + v13;
LABEL_22:
                unint64_t v5 = v12;
                goto LABEL_52;
              case 3:
                float64x2_t v24 = *v5;
                unint64_t v5 = v12 + 1;
                float64x2_t v25 = v12[1];
                float64x2_t v26 = vaddq_f64(*v12, *v12);
                float64x2_t v27 = vmulq_f64(vaddq_f64(v26, v25), v14);
                float64x2_t v28 = vmulq_f64(vaddq_f64(v26, v24), v14);
                uint64_t v29 = 2;
                goto LABEL_25;
              case 4:
                float64x2_t v24 = *v5;
                float64x2_t v28 = *v12;
                float64x2_t v27 = v12[1];
                unint64_t v5 = v12 + 2;
                float64x2_t v25 = v12[2];
                uint64_t v29 = 3;
LABEL_25:
                uint64_t v75 = 0;
                memset(v74, 0, sizeof(v74));
                uint64_t v73 = 0;
                memset(v72, 0, sizeof(v72));
                uint64_t v71 = 0;
                memset(v70, 0, sizeof(v70));
                uint64_t v69 = 0;
                memset(v68, 0, sizeof(v68));
                uint64_t v67 = 0;
                memset(v66, 0, sizeof(v66));
                uint64_t v65 = 0;
                memset(v64, 0, sizeof(v64));
                uint64_t v63 = 0;
                memset(v62, 0, sizeof(v62));
                uint64_t v61 = 0;
                memset(v60, 0, sizeof(v60));
                uint64_t v59 = 0;
                memset(v58, 0, sizeof(v58));
                uint64_t v57 = 0;
                memset(v56, 0, sizeof(v56));
                uint64_t v55 = 0;
                float64x2_t v30 = vsubq_f64(v28, v24);
                double v31 = vaddvq_f64(vmulq_f64(v30, v30));
                memset(v54, 0, sizeof(v54));
                if (v31 <= 0.0) {
                  double v32 = 1.79769313e308;
                }
                else {
                  double v32 = 1.0 / sqrt(v31);
                }
                double v33 = v27.f64[1];
                double v34 = v25.f64[1];
                double v35 = (v25.f64[1] - v27.f64[1]) * (v25.f64[1] - v27.f64[1])
                    + (v25.f64[0] - v27.f64[0]) * (v25.f64[0] - v27.f64[0]);
                if (v35 <= 0.0) {
                  double v36 = 1.79769313e308;
                }
                else {
                  double v36 = 1.0 / sqrt(v35);
                }
                double v37 = v32 * v31;
                double v38 = v36 * v35;
                double v39 = 0.0;
                if (COERCE__INT64(fabs(v36 * v35 + v37)) <= 0x7FEFFFFFFFFFFFFFLL)
                {
                  LODWORD(j) = 0;
                  double v41 = v24.f64[1];
                  double v42 = v28.f64[1];
                  for (double i = 1.0; ; double i = *((double *)v54 + j))
                  {
                    for (uint64_t j = (int)j; ; ++j)
                    {
                      double v44 = (v27.f64[0] - v28.f64[0]) * (v27.f64[0] - v28.f64[0]) + (v33 - v42) * (v33 - v42);
                      double v45 = v44 <= 0.0 ? 1.79769313e308 : 1.0 / sqrt(v44);
                      double v46 = (v34 - v41) * (v34 - v41) + (v25.f64[0] - v24.f64[0]) * (v25.f64[0] - v24.f64[0]);
                      double v47 = v46 <= 0.0 ? 1.79769313e308 : 1.0 / sqrt(v46);
                      double v48 = v38 + v37 + v45 * v44;
                      BOOL v49 = v48 - v47 * v46 > i && j < 29;
                      if (!v49) {
                        break;
                      }
                      double i = i * 0.5;
                      *((double *)v54 + j) = i;
                      *((void *)v68 + j) = *(void *)&v25.f64[0];
                      *((double *)v56 + j) = v34;
                      *((double *)v70 + j) = (v25.f64[0] + v27.f64[0]) * 0.5;
                      *((double *)v58 + j) = (v34 + v33) * 0.5;
                      *((double *)v72 + j) = (v28.f64[0] + v27.f64[0] * 2.0 + v25.f64[0]) * 0.25;
                      *((double *)v60 + j) = (v42 + v33 * 2.0 + v34) * 0.25;
                      v25.f64[0] = (v25.f64[0] + (v27.f64[0] + v28.f64[0]) * 3.0 + v24.f64[0]) * 0.125;
                      *((void *)v74 + j) = *(void *)&v25.f64[0];
                      double v34 = (v34 + (v33 + v42) * 3.0 + v41) * 0.125;
                      *((double *)v62 + j) = v34;
                      v27.f64[0] = (v27.f64[0] + v28.f64[0] * 2.0 + v24.f64[0]) * 0.25;
                      *((double *)v64 + j) = v38 * 0.5;
                      double v33 = (v33 + v42 * 2.0 + v41) * 0.25;
                      double v50 = (v34 - v33) * (v34 - v33) + (v25.f64[0] - v27.f64[0]) * (v25.f64[0] - v27.f64[0]);
                      if (v50 <= 0.0) {
                        double v51 = 1.79769313e308;
                      }
                      else {
                        double v51 = 1.0 / sqrt(v50);
                      }
                      v28.f64[0] = (v24.f64[0] + v28.f64[0]) * 0.5;
                      double v42 = (v41 + v42) * 0.5;
                      double v37 = v37 * 0.5;
                      double v38 = v51 * v50;
                      *((double *)v66 + j) = v38;
                    }
                    double v39 = v39 + (v47 * v46 + v48) * 0.5;
                    if (!j) {
                      break;
                    }
                    uint64_t j = (int)j - 1;
                    v24.f64[0] = *((float64_t *)v74 + j);
                    double v41 = *((double *)v62 + j);
                    v28.f64[0] = *((float64_t *)v72 + j);
                    double v42 = *((double *)v60 + j);
                    v27.f64[0] = *((float64_t *)v70 + j);
                    double v33 = *((double *)v58 + j);
                    v25.f64[0] = *((float64_t *)v68 + j);
                    double v34 = *((double *)v56 + j);
                    double v37 = *((double *)v66 + j);
                    double v38 = *((double *)v64 + j);
                  }
                }
                double v20 = &v12[v29];
                v9[v11++] = v39;
                double v13 = v39 + v13;
LABEL_52:
                int64_t v12 = v20;
                if (v11 >= v10) {
                  goto LABEL_55;
                }
                continue;
              default:
                goto LABEL_55;
            }
          }
        }
        unint64_t v11 = 0;
        double v13 = 0.0;
LABEL_55:
        BOOL v49 = v10 > v11;
        unint64_t v52 = v10 - v11;
        if (v49) {
          bzero(&v9[v11], 8 * v52);
        }
        *((void *)this + 8) = v1;
        *((double *)this + 9) = v13;
      }
    }
  }
  return v1;
}

void CA::Render::anonymous namespace'::PathAccumulator::push_moveto(unint64_t *a1, _OWORD *a2)
{
  unint64_t v5 = (unsigned char *)a1[1];
  unint64_t v4 = a1[2];
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = *a1;
    long long v8 = &v5[-*a1];
    unint64_t v9 = (unint64_t)(v8 + 1);
    if ((uint64_t)(v8 + 1) < 0) {
      goto LABEL_36;
    }
    unint64_t v10 = v4 - v7;
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v9;
    }
    if (v11) {
      unint64_t v12 = (unint64_t)operator new(v11);
    }
    else {
      unint64_t v12 = 0;
    }
    double v13 = (char *)(v12 + v11);
    v8[v12] = 1;
    uint64_t v6 = (uint64_t)&v8[v12 + 1];
    if (v5 == (unsigned char *)v7)
    {
      v12 += (unint64_t)v8;
    }
    else
    {
      float64x2_t v14 = &v5[~v7];
      do
      {
        char v15 = *--v5;
        (v14--)[v12] = v15;
      }
      while (v5 != (unsigned char *)v7);
      unint64_t v5 = (unsigned char *)*a1;
    }
    *a1 = v12;
    a1[1] = v6;
    a1[2] = (unint64_t)v13;
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *unint64_t v5 = 1;
    uint64_t v6 = (uint64_t)(v5 + 1);
  }
  a1[1] = v6;
  float64x2_t v17 = (_OWORD *)a1[4];
  unint64_t v16 = a1[5];
  if ((unint64_t)v17 < v16)
  {
    *float64x2_t v17 = *a2;
    double v18 = v17 + 1;
    goto LABEL_35;
  }
  unint64_t v19 = a1[3];
  uint64_t v20 = (uint64_t)((uint64_t)v17 - v19) >> 4;
  unint64_t v21 = v20 + 1;
  if ((unint64_t)(v20 + 1) >> 60) {
LABEL_36:
  }
    abort();
  uint64_t v22 = v16 - v19;
  if (v22 >> 3 > v21) {
    unint64_t v21 = v22 >> 3;
  }
  if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v23 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v23 = v21;
  }
  if (v23) {
    unint64_t v23 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::MeshFace>>(v23);
  }
  else {
    uint64_t v24 = 0;
  }
  float64x2_t v25 = (_OWORD *)(v23 + 16 * v20);
  unint64_t v26 = v23 + 16 * v24;
  *float64x2_t v25 = *a2;
  double v18 = v25 + 1;
  float64x2_t v28 = (char *)a1[3];
  float64x2_t v27 = (char *)a1[4];
  if (v27 != v28)
  {
    do
    {
      *--float64x2_t v25 = *((_OWORD *)v27 - 1);
      v27 -= 16;
    }
    while (v27 != v28);
    float64x2_t v27 = (char *)a1[3];
  }
  a1[3] = (unint64_t)v25;
  a1[4] = (unint64_t)v18;
  a1[5] = v26;
  if (v27) {
    operator delete(v27);
  }
LABEL_35:
  a1[4] = (unint64_t)v18;
}

uint64_t CAIOSurfaceCreate(__IOSurface *a1)
{
  if (!a1) {
    return 0;
  }
  if (CAIOSurfaceGetTypeID::once[0] != -1) {
    dispatch_once(CAIOSurfaceGetTypeID::once, &__block_literal_global_2614);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v4 = (uint64_t)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x158uLL, 0x743898A5uLL);
    if (v4) {
      uint64_t v4 = CA::Render::Surface::Surface(v4, a1, -1, 3, 0, 0, 0);
    }
    *(void *)(Instance + 16) = v4;
  }
  return Instance;
}

unint64_t CAImageQueueGetVBLInfo(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3)
  {
    uint64_t v4 = *(int **)(v3 + 24);
    for (int i = 16; i; --i)
    {
      int v6 = *v4;
      __dmb(0xBu);
      if (v4[15] >= a3) {
        unint64_t result = a3;
      }
      else {
        unint64_t result = v4[15];
      }
      if (result)
      {
        uint64_t v8 = 0;
        do
        {
          uint64_t v9 = a2 + v8 * 4;
          *(void *)(v9 + 8) = *(void *)&v4[v8 + 84];
          *(void *)uint64_t v9 = *(void *)&v4[v8 + 82];
          *(_DWORD *)(v9 + 16) = v4[v8 + 86];
          v8 += 6;
        }
        while (6 * result != v8);
      }
      __dmb(0xBu);
      if (v6 == v4[1]) {
        return result;
      }
    }
  }
  return 0;
}

unint64_t CAImageQueueGetTimes(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3)
  {
    uint64_t v4 = *(_DWORD **)(v3 + 24);
    for (int i = 16; i; --i)
    {
      int v6 = *v4;
      __dmb(0xBu);
      if (v4[15] >= a3) {
        unint64_t result = a3;
      }
      else {
        unint64_t result = v4[15];
      }
      if (result)
      {
        uint64_t v8 = (uint64_t *)(v4 + 84);
        uint64_t v9 = a2;
        unint64_t v10 = result;
        do
        {
          uint64_t v11 = *v8;
          v8 += 3;
          *v9++ = v11;
          --v10;
        }
        while (v10);
      }
      __dmb(0xBu);
      if (v6 == v4[1]) {
        return result;
      }
    }
  }
  return 0;
}

dispatch_semaphore_t ___ZN2CA2CG5QueueC2Ev_block_invoke()
{
  dispatch_semaphore_t result = dispatch_semaphore_create(96);
  CA::CG::Queue::_queue_sema = (uint64_t)result;
  return result;
}

void *___ZN2CA3OGL12MetalContext29get_offline_compilation_indexEv_block_invoke()
{
  dispatch_semaphore_t result = &unk_1ED057508;
  CA::OGL::MetalContext::get_offline_compilation_index(void)::indedouble x = (uint64_t)result;
  return result;
}

void *___ZN2CA3OGL12MetalContext27get_TextureFunction_decoderEv_block_invoke()
{
  dispatch_semaphore_t result = &unk_1ED057378;
  CA::OGL::MetalContext::get_TextureFunction_decoder(void)::decoder = (uint64_t)result;
  return result;
}

void *___ZN2CA3OGL12MetalContext26get_MTLPixelFormat_decoderEv_block_invoke()
{
  dispatch_semaphore_t result = &unk_1ED0574E0;
  CA::OGL::MetalContext::get_MTLPixelFormat_decoder(void)::decoder = (uint64_t)result;
  return result;
}

void *___ZN2CA3OGL12MetalContext25get_ImageFunction_decoderEv_block_invoke()
{
  dispatch_semaphore_t result = &unk_1ED057418;
  CA::OGL::MetalContext::get_ImageFunction_decoder(void)::decoder = (uint64_t)result;
  return result;
}

void *___ZN2CA3OGL12MetalContext25get_BlendFunction_decoderEv_block_invoke()
{
  dispatch_semaphore_t result = &unk_1ED0573A0;
  CA::OGL::MetalContext::get_BlendFunction_decoder(void)::decoder = (uint64_t)result;
  return result;
}

__IOSurface *CA::SurfaceUtil::CAIOSurfaceCreate(unsigned int a1, int a2, uint64_t a3, int a4, int a5, unsigned __int8 a6, uint64_t a7, void *a8, const void *a9)
{
  LODWORD(v14) = a2;
  uint64_t v666 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v653 = 0;
  unint64_t v654 = 0;
  unint64_t v651 = 0;
  uint64_t v652 = 0;
  values = 0;
  CFDictionaryRef htpc_plane_dict = 0;
  CFDictionaryRef plane_dict = 0;
  unint64_t v650 = 0;
  if (CADeviceSupportsUniversalCompression::once != -1) {
    dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
  }
  unsigned int v19 = BYTE3(a3);
  uint64_t v648 = a7;
  int v646 = a4;
  int v647 = a5;
  if (BYTE3(a3) == 45)
  {
    int v20 = 1;
    unsigned int v21 = 1;
  }
  else if (v19 == 124)
  {
    unsigned int v21 = 3;
    int v20 = 2;
  }
  else if (v19 == 47)
  {
    int v20 = 2;
    unsigned int v21 = 2;
  }
  else
  {
    int v20 = 0;
    unsigned int v21 = 0;
  }
  int v641 = CADeviceSupportsUniversalCompression::universal;
  if ((int)a3 > 762865203)
  {
    if ((int)a3 <= 1534354993)
    {
      if ((int)a3 <= 796161585)
      {
        if ((int)a3 > 792229423)
        {
          if ((int)a3 <= 796157487)
          {
            if ((int)a3 <= 792229427)
            {
              if (a3 != 792229424)
              {
                int v22 = 792229426;
                goto LABEL_109;
              }
              goto LABEL_277;
            }
            if (a3 == 792229428) {
              goto LABEL_281;
            }
            int v55 = 792872769;
LABEL_234:
            if (a3 != v55) {
              goto LABEL_358;
            }
            uint64_t v95 = a1;
            uint64_t v96 = v14;
            unsigned int v97 = v21;
            goto LABEL_256;
          }
          if ((int)a3 <= 796157491)
          {
            if (a3 != 796157488)
            {
              int v25 = 796157490;
LABEL_100:
              if (a3 != v25) {
                goto LABEL_358;
              }
              goto LABEL_158;
            }
            goto LABEL_261;
          }
          if (a3 != 796157492)
          {
            int v67 = 796161584;
LABEL_260:
            if (a3 != v67) {
              goto LABEL_358;
            }
            goto LABEL_261;
          }
          goto LABEL_263;
        }
        if ((int)a3 <= 762869299)
        {
          if (a3 != 762865204)
          {
            if (a3 != 762869296)
            {
              unsigned __int16 v50 = 30258;
LABEL_293:
              int v68 = v50 | 0x2D780000;
LABEL_294:
              if (a3 != v68) {
                goto LABEL_358;
              }
              goto LABEL_295;
            }
LABEL_297:
            uint64_t v119 = (a1 + 1) >> 1;
            uint64_t v120 = (v14 + 1) >> 1;
            if (v21 - 1 > 2) {
              uint64_t v121 = 10;
            }
            else {
              uint64_t v121 = qword_184998B10[v21 - 1];
            }
            unsigned int v122 = v14;
            if ((v20 - 1) > 2) {
              uint64_t v14 = 20;
            }
            else {
              uint64_t v14 = qword_184998B28[v20 - 1];
            }
            uint64_t v123 = a1;
            unsigned int v124 = a1;
            unsigned int v125 = v122;
            values = CA::SurfaceUtil::create_universal_plane_dict(v21, 1, v123, v122, v121, (uint64_t *)&v654);
            unsigned int v46 = v20;
            uint64_t v47 = v119;
            uint64_t v48 = v120;
            uint64_t v49 = v14;
            LODWORD(v14) = v125;
            a1 = v124;
            goto LABEL_357;
          }
        }
        else
        {
          if ((int)a3 > 792225329)
          {
            if (a3 == 792225330) {
              goto LABEL_205;
            }
            int v54 = 792225332;
            goto LABEL_203;
          }
          if (a3 != 762869300)
          {
            int v28 = 792225328;
            goto LABEL_276;
          }
        }
LABEL_311:
        if (v21 - 1 > 2) {
          uint64_t v106 = 10;
        }
        else {
          uint64_t v106 = qword_184998B10[v21 - 1];
        }
        unsigned int v108 = v20 - 1;
        if ((v20 - 1) > 2)
        {
          uint64_t v110 = 20;
          goto LABEL_318;
        }
        unint64_t v109 = qword_184998B28;
        goto LABEL_316;
      }
      if ((int)a3 > 796423731)
      {
        if ((int)a3 <= 1530426927)
        {
          if ((int)a3 <= 1530422833)
          {
            if (a3 == 796423732) {
              goto LABEL_311;
            }
            if (a3 != 1530422832) {
              goto LABEL_358;
            }
            goto LABEL_320;
          }
          if (a3 != 1530422834)
          {
            if (a3 != 1530422836) {
              goto LABEL_358;
            }
            goto LABEL_333;
          }
LABEL_329:
          uint64_t v652 = 0;
          uint64_t v653 = 0;
          values = CA::SurfaceUtil::create_htpc_plane_dict((CA::SurfaceUtil *)a1, v14, 1, 0, (unint64_t *)&v653, v16);
          uint64_t v65 = (CA::SurfaceUtil *)((a1 + 1) >> 1);
          uint64_t v64 = v653;
          uint64_t v66 = v14;
          goto LABEL_334;
        }
        if ((int)a3 <= 1530426931)
        {
          if (a3 == 1530426928)
          {
LABEL_320:
            uint64_t v652 = 0;
            uint64_t v653 = 0;
            values = CA::SurfaceUtil::create_htpc_plane_dict((CA::SurfaceUtil *)a1, v14, 1, 0, (unint64_t *)&v653, v16);
            uint64_t v65 = (CA::SurfaceUtil *)((a1 + 1) >> 1);
            uint64_t v66 = (v14 + 1) >> 1;
            uint64_t v64 = v653;
LABEL_334:
            uint64_t v118 = 2;
            goto LABEL_335;
          }
          if (a3 != 1530426930) {
            goto LABEL_358;
          }
          goto LABEL_329;
        }
        if (a3 == 1530426932)
        {
LABEL_333:
          uint64_t v652 = 0;
          uint64_t v653 = 0;
          values = CA::SurfaceUtil::create_htpc_plane_dict((CA::SurfaceUtil *)a1, v14, 1, 0, (unint64_t *)&v653, v16);
          uint64_t v64 = v653;
          uint64_t v65 = (CA::SurfaceUtil *)a1;
          uint64_t v66 = v14;
          goto LABEL_334;
        }
        unsigned __int16 v52 = 26160;
        goto LABEL_287;
      }
      if ((int)a3 > 796419633)
      {
        if ((int)a3 > 796423727)
        {
          if (a3 != 796423728)
          {
            int v68 = 796423730;
            goto LABEL_294;
          }
          goto LABEL_297;
        }
        if (a3 != 796419634)
        {
          int v30 = 796419636;
          goto LABEL_310;
        }
        goto LABEL_295;
      }
      if (a3 == 796161586) {
        goto LABEL_158;
      }
      if (a3 == 796161588) {
        goto LABEL_263;
      }
      int v31 = 796419632;
      goto LABEL_156;
    }
    if ((int)a3 > 2084075057)
    {
      if ((int)a3 <= 2088007217)
      {
        if ((int)a3 <= 2088003119)
        {
          if (a3 == 2084075058) {
            goto LABEL_205;
          }
          if (a3 == 2084075060) {
            goto LABEL_281;
          }
          int v55 = 2084718401;
          goto LABEL_234;
        }
        if ((int)a3 <= 2088003123)
        {
          if (a3 != 2088003120)
          {
            int v25 = 2088003122;
            goto LABEL_100;
          }
LABEL_261:
          uint64_t v103 = (a1 + 1) >> 1;
          uint64_t v104 = (v14 + 1) >> 1;
          if (v21 - 1 > 2) {
            unsigned int v105 = 12;
          }
          else {
            unsigned int v105 = dword_184998B40[v21 - 1];
          }
          uint64_t v107 = 2 * v105;
          values = CA::SurfaceUtil::create_universal_plane_dict(v21, 1, a1, v14, v105, (uint64_t *)&v654);
          unsigned int v46 = v21;
          goto LABEL_349;
        }
        if (a3 != 2088003124)
        {
          int v67 = 2088007216;
          goto LABEL_260;
        }
LABEL_263:
        if (v21 - 1 > 2) {
          uint64_t v106 = 12;
        }
        else {
          uint64_t v106 = qword_184998B50[v21 - 1];
        }
        unsigned int v108 = v20 - 1;
        if ((v20 - 1) > 2)
        {
          uint64_t v110 = 24;
LABEL_318:
          uint64_t v126 = a1;
          unsigned int v127 = a1;
          int v128 = v14;
          uint64_t v14 = v14;
          values = CA::SurfaceUtil::create_universal_plane_dict(v21, 1, v126, v14, v106, (uint64_t *)&v654);
          unsigned int v46 = v20;
          uint64_t v47 = v126;
LABEL_356:
          uint64_t v48 = v14;
          LODWORD(v14) = v128;
          a1 = v127;
          uint64_t v49 = v110;
          goto LABEL_357;
        }
        unint64_t v109 = &unk_184998B68;
LABEL_316:
        uint64_t v110 = v109[v108];
        goto LABEL_318;
      }
      if ((int)a3 <= 2088265267)
      {
        if ((int)a3 <= 2088265263)
        {
          if (a3 != 2088007218)
          {
            int v26 = 2088007220;
            goto LABEL_118;
          }
LABEL_158:
          if (v21 - 1 > 2) {
            unsigned int v53 = 12;
          }
          else {
            unsigned int v53 = dword_184998B40[v21 - 1];
          }
          uint64_t v57 = 2 * v53;
          values = CA::SurfaceUtil::create_universal_plane_dict(v21, 1, a1, v14, v53, (uint64_t *)&v654);
          unsigned int v46 = v21;
          uint64_t v47 = (a1 + 1) >> 1;
          uint64_t v48 = v14;
          goto LABEL_342;
        }
        if (a3 != 2088265264)
        {
          int v68 = 2088265266;
          goto LABEL_294;
        }
        goto LABEL_297;
      }
      if ((int)a3 > 2088269361)
      {
        if (a3 != 2088269362)
        {
          int v30 = 2088269364;
LABEL_310:
          if (a3 != v30) {
            goto LABEL_358;
          }
          goto LABEL_311;
        }
LABEL_295:
        uint64_t v77 = (a1 + 1) >> 1;
        if (v21 - 1 > 2) {
          uint64_t v78 = 10;
        }
        else {
          uint64_t v78 = qword_184998B10[v21 - 1];
        }
        if ((v20 - 1) > 2) {
          uint64_t v57 = 20;
        }
        else {
          uint64_t v57 = qword_184998B28[v20 - 1];
        }
        goto LABEL_341;
      }
      if (a3 == 2088265268) {
        goto LABEL_311;
      }
      int v31 = 2088269360;
LABEL_156:
      if (a3 != v31) {
        goto LABEL_358;
      }
      goto LABEL_297;
    }
    if ((int)a3 <= 1534617139)
    {
      if ((int)a3 <= 1534359089)
      {
        if (a3 != 1534354994)
        {
          if (a3 != 1534354996)
          {
            unsigned __int16 v52 = 30256;
LABEL_287:
            int v24 = v52 | 0x5B740000;
LABEL_288:
            if (a3 != v24) {
              goto LABEL_358;
            }
            goto LABEL_289;
          }
          goto LABEL_182;
        }
      }
      else if ((int)a3 > 1534617135)
      {
        if (a3 == 1534617136)
        {
LABEL_289:
          uint64_t v652 = 0;
          uint64_t v653 = 0;
          values = CA::SurfaceUtil::create_htpc_plane_dict((CA::SurfaceUtil *)a1, v14, 2, 0, (unint64_t *)&v653, v16);
          uint64_t v65 = (CA::SurfaceUtil *)((a1 + 1) >> 1);
          uint64_t v66 = (v14 + 1) >> 1;
          uint64_t v64 = v653;
          goto LABEL_290;
        }
        if (a3 != 1534617138) {
          goto LABEL_358;
        }
      }
      else if (a3 != 1534359090)
      {
        int v29 = 1534359092;
        goto LABEL_181;
      }
    }
    else
    {
      if ((int)a3 > 2084070959)
      {
        if ((int)a3 <= 2084070963)
        {
          if (a3 != 2084070960)
          {
            int v22 = 2084070962;
LABEL_109:
            if (a3 != v22) {
              goto LABEL_358;
            }
LABEL_205:
            uint64_t v77 = (a1 + 1) >> 1;
            switch(v21)
            {
              case 1u:
                uint64_t v57 = 12;
                uint64_t v78 = 6;
                break;
              case 3u:
                uint64_t v78 = 4;
                goto LABEL_338;
              case 2u:
                uint64_t v78 = 5;
LABEL_338:
                int v20 = 3;
                uint64_t v57 = 8;
LABEL_341:
                values = CA::SurfaceUtil::create_universal_plane_dict(v21, 1, a1, v14, v78, (uint64_t *)&v654);
                unsigned int v46 = v20;
                uint64_t v47 = v77;
                uint64_t v48 = v14;
LABEL_342:
                uint64_t v49 = v57;
                goto LABEL_357;
              default:
                uint64_t v57 = 16;
                uint64_t v78 = 8;
                break;
            }
            int v20 = v21;
            goto LABEL_341;
          }
LABEL_277:
          uint64_t v103 = (a1 + 1) >> 1;
          uint64_t v104 = (v14 + 1) >> 1;
          unsigned int v115 = v14;
          switch(v21)
          {
            case 1u:
              uint64_t v107 = 12;
              uint64_t v116 = 6;
              break;
            case 3u:
              uint64_t v116 = 4;
              goto LABEL_345;
            case 2u:
              uint64_t v116 = 5;
LABEL_345:
              int v130 = 3;
              uint64_t v107 = 8;
LABEL_348:
              uint64_t v131 = a1;
              unsigned int v132 = a1;
              unsigned int v133 = v115;
              values = CA::SurfaceUtil::create_universal_plane_dict(v21, 1, v131, v115, v116, (uint64_t *)&v654);
              unsigned int v46 = v130;
              LODWORD(v14) = v133;
              a1 = v132;
LABEL_349:
              uint64_t v47 = v103;
              uint64_t v48 = v104;
              uint64_t v49 = v107;
              goto LABEL_357;
            default:
              uint64_t v107 = 16;
              uint64_t v116 = 8;
              break;
          }
          int v130 = v21;
          goto LABEL_348;
        }
        if (a3 == 2084070964) {
          goto LABEL_281;
        }
        int v28 = 2084075056;
LABEL_276:
        if (a3 != v28) {
          goto LABEL_358;
        }
        goto LABEL_277;
      }
      if ((int)a3 <= 1534621233)
      {
        if (a3 != 1534617140)
        {
          int v24 = 1534621232;
          goto LABEL_288;
        }
        goto LABEL_182;
      }
      if (a3 != 1534621234)
      {
        int v29 = 1534621236;
LABEL_181:
        if (a3 != v29) {
          goto LABEL_358;
        }
LABEL_182:
        uint64_t v652 = 0;
        uint64_t v653 = 0;
        values = CA::SurfaceUtil::create_htpc_plane_dict((CA::SurfaceUtil *)a1, v14, 2, 0, (unint64_t *)&v653, v16);
        uint64_t v64 = v653;
        uint64_t v65 = (CA::SurfaceUtil *)a1;
        uint64_t v66 = v14;
LABEL_290:
        uint64_t v118 = 4;
LABEL_335:
        CFDictionaryRef htpc_plane_dict = CA::SurfaceUtil::create_htpc_plane_dict(v65, v66, v118, v64, (unint64_t *)&v652, v63);
        unint64_t v654 = v652 + v653;
        goto LABEL_358;
      }
    }
    uint64_t v652 = 0;
    uint64_t v653 = 0;
    values = CA::SurfaceUtil::create_htpc_plane_dict((CA::SurfaceUtil *)a1, v14, 2, 0, (unint64_t *)&v653, v16);
    uint64_t v65 = (CA::SurfaceUtil *)((a1 + 1) >> 1);
    uint64_t v64 = v653;
    uint64_t v66 = v14;
    goto LABEL_290;
  }
  if ((int)a3 > 645280823)
  {
    if ((int)a3 <= 758670895)
    {
      if ((int)a3 <= 645411895)
      {
        if ((int)a3 <= 645410871)
        {
          if (a3 != 645280824)
          {
            if (a3 != 645346162)
            {
              int v51 = 645346401;
LABEL_251:
              if (a3 != v51) {
                goto LABEL_358;
              }
              uint64_t v95 = a1;
              if (CADeviceSupportsUniversalCompression::universal)
              {
                unsigned int v97 = v21;
                uint64_t v96 = v14;
                uint64_t v101 = 64;
LABEL_257:
                CFDictionaryRef universal_plane_dict = CA::SurfaceUtil::create_universal_plane_dict(v97, 0, v95, v96, v101, (uint64_t *)&v654);
LABEL_851:
                values = universal_plane_dict;
                goto LABEL_358;
              }
              int8x16_t v556 = (CA::SurfaceUtil *)a1;
              uint64_t v557 = v14;
              unint64_t v558 = 8;
LABEL_850:
              CFDictionaryRef universal_plane_dict = CA::SurfaceUtil::create_agx_plane_dict(v556, v557, v558, (uint64_t *)&v654, &v651, &v650, v17);
              goto LABEL_851;
            }
            goto LABEL_254;
          }
LABEL_240:
          uint64_t v86 = a1;
          uint64_t v87 = v14;
          if (CA::Render::fourcc_is_444((CA::Render *)a3)) {
            uint64_t v98 = a1;
          }
          else {
            uint64_t v98 = (a1 + 1) >> 1;
          }
          unsigned int v99 = a1;
          int v100 = v14;
          if (CA::Render::fourcc_is_420((CA::Render *)a3)) {
            uint64_t v14 = (v14 + 1) >> 1;
          }
          else {
            uint64_t v14 = v14;
          }
          values = CA::SurfaceUtil::create_universal_plane_dict(v21, 1, v86, v87, 8, (uint64_t *)&v654);
          unsigned int v91 = v21;
          uint64_t v92 = v98;
          uint64_t v93 = v14;
          LODWORD(v14) = v100;
          a1 = v99;
          uint64_t v94 = 16;
LABEL_247:
          CFDictionaryRef htpc_plane_dict = CA::SurfaceUtil::create_universal_plane_dict(v91, 0, v92, v93, v94, (uint64_t *)&v654);
          unsigned int v82 = v21;
          uint64_t v83 = v86;
          uint64_t v84 = v87;
          uint64_t v85 = 8;
          goto LABEL_248;
        }
        if ((int)a3 > 645411383)
        {
          if (a3 != 645411384)
          {
            unsigned __int16 v23 = 12915;
            goto LABEL_211;
          }
        }
        else if (a3 != 645410872)
        {
          unsigned __int16 v23 = 12403;
          goto LABEL_211;
        }
LABEL_220:
        uint64_t v86 = a1;
        uint64_t v87 = v14;
        if (CA::Render::fourcc_is_444((CA::Render *)a3)) {
          uint64_t v88 = a1;
        }
        else {
          uint64_t v88 = (a1 + 1) >> 1;
        }
        unsigned int v89 = a1;
        int v90 = v14;
        if (CA::Render::fourcc_is_420((CA::Render *)a3)) {
          uint64_t v14 = (v14 + 1) >> 1;
        }
        else {
          uint64_t v14 = v14;
        }
        values = CA::SurfaceUtil::create_universal_plane_dict(v21, 1, v86, v87, 10, (uint64_t *)&v654);
        unsigned int v91 = v21;
        uint64_t v92 = v88;
        uint64_t v93 = v14;
        LODWORD(v14) = v90;
        a1 = v89;
        uint64_t v94 = 20;
        goto LABEL_247;
      }
      if ((int)a3 <= 645424691)
      {
        if ((int)a3 <= 645424687)
        {
          if (a3 != 645411896)
          {
            unsigned __int16 v23 = 13427;
LABEL_211:
            if (a3 != (v23 | 0x26780000)) {
              goto LABEL_358;
            }
            uint64_t v32 = a1;
            uint64_t v33 = v14;
            if (CA::Render::fourcc_is_444((CA::Render *)a3)) {
              uint64_t v79 = a1;
            }
            else {
              uint64_t v79 = (a1 + 1) >> 1;
            }
            unsigned int v80 = a1;
            int v81 = v14;
            if (CA::Render::fourcc_is_420((CA::Render *)a3)) {
              uint64_t v14 = (v14 + 1) >> 1;
            }
            else {
              uint64_t v14 = v14;
            }
            values = CA::SurfaceUtil::create_universal_plane_dict(v21, 1, v32, v33, 10, (uint64_t *)&v654);
            unsigned int v37 = v21;
            uint64_t v38 = v79;
            uint64_t v39 = v14;
            LODWORD(v14) = v81;
            a1 = v80;
            uint64_t v40 = 20;
            goto LABEL_219;
          }
          goto LABEL_220;
        }
        if (a3 != 645424688)
        {
          if (a3 != 645424690) {
            goto LABEL_358;
          }
          goto LABEL_330;
        }
LABEL_328:
        uint64_t v111 = (a1 + 1) >> 1;
        uint64_t v112 = (v14 + 1) >> 1;
        uint64_t v114 = a1;
        uint64_t v129 = v14;
        unsigned int v113 = v21;
LABEL_332:
        values = CA::SurfaceUtil::create_universal_plane_dict(v113, 1, v114, v129, 10, (uint64_t *)&v654);
        unsigned int v46 = v21;
        uint64_t v47 = v111;
        uint64_t v48 = v112;
        uint64_t v49 = 20;
        goto LABEL_357;
      }
      if ((int)a3 > 645428785)
      {
        if (a3 == 645428786)
        {
LABEL_330:
          uint64_t v111 = (a1 + 1) >> 1;
          uint64_t v114 = a1;
          uint64_t v112 = v14;
          unsigned int v113 = v21;
          goto LABEL_331;
        }
        if (a3 != 645428788) {
          goto LABEL_358;
        }
      }
      else if (a3 != 645424692)
      {
        if (a3 != 645428784) {
          goto LABEL_358;
        }
        goto LABEL_328;
      }
      uint64_t v111 = a1;
      uint64_t v112 = v14;
      unsigned int v113 = v21;
      uint64_t v114 = a1;
LABEL_331:
      uint64_t v129 = v112;
      goto LABEL_332;
    }
    if ((int)a3 > 762603055)
    {
      if ((int)a3 <= 762607153)
      {
        if ((int)a3 <= 762603059)
        {
          if (a3 != 762603056)
          {
            int v25 = 762603058;
            goto LABEL_100;
          }
          goto LABEL_261;
        }
        if (a3 != 762603060)
        {
          int v67 = 762607152;
          goto LABEL_260;
        }
        goto LABEL_263;
      }
      if ((int)a3 <= 762865199)
      {
        if (a3 != 762607154)
        {
          int v26 = 762607156;
LABEL_118:
          if (a3 != v26) {
            goto LABEL_358;
          }
          goto LABEL_263;
        }
        goto LABEL_158;
      }
      if (a3 != 762865200)
      {
        unsigned __int16 v50 = 26162;
        goto LABEL_293;
      }
      goto LABEL_297;
    }
    if ((int)a3 > 758674991)
    {
      if ((int)a3 <= 758674995)
      {
        if (a3 != 758674992)
        {
          int v22 = 758674994;
          goto LABEL_109;
        }
        goto LABEL_277;
      }
      if (a3 != 758674996)
      {
        int v55 = 759318337;
        goto LABEL_234;
      }
LABEL_281:
      switch(v21)
      {
        case 1u:
          uint64_t v110 = 12;
          uint64_t v117 = 6;
          break;
        case 3u:
          uint64_t v117 = 4;
          goto LABEL_352;
        case 2u:
          uint64_t v117 = 5;
LABEL_352:
          int v134 = 3;
          uint64_t v110 = 8;
LABEL_355:
          uint64_t v135 = a1;
          unsigned int v127 = a1;
          int v128 = v14;
          uint64_t v14 = v14;
          values = CA::SurfaceUtil::create_universal_plane_dict(v21, 1, v135, v14, v117, (uint64_t *)&v654);
          unsigned int v46 = v134;
          uint64_t v47 = v135;
          goto LABEL_356;
        default:
          uint64_t v110 = 16;
          uint64_t v117 = 8;
          break;
      }
      int v134 = v21;
      goto LABEL_355;
    }
    if (a3 == 758670896) {
      goto LABEL_277;
    }
    if (a3 == 758670898) {
      goto LABEL_205;
    }
    int v54 = 758670900;
LABEL_203:
    if (a3 != v54) {
      goto LABEL_358;
    }
    goto LABEL_281;
  }
  if ((int)a3 > 645101103)
  {
    if ((int)a3 <= 645162545)
    {
      if ((int)a3 <= 645148786)
      {
        if ((a3 - 645101104) > 4 || ((1 << (a3 - 48)) & 0x15) == 0) {
          goto LABEL_358;
        }
        goto LABEL_137;
      }
      if ((int)a3 <= 645149810)
      {
        if (a3 != 645148787 && a3 != 645149299) {
          goto LABEL_358;
        }
        goto LABEL_194;
      }
      if (a3 == 645149811)
      {
LABEL_194:
        uint64_t v32 = a1;
        uint64_t v33 = v14;
        if (CA::Render::fourcc_is_444((CA::Render *)a3)) {
          uint64_t v74 = a1;
        }
        else {
          uint64_t v74 = (a1 + 1) >> 1;
        }
        unsigned int v75 = a1;
        int v76 = v14;
        if (CA::Render::fourcc_is_420((CA::Render *)a3)) {
          uint64_t v14 = (v14 + 1) >> 1;
        }
        else {
          uint64_t v14 = v14;
        }
        values = CA::SurfaceUtil::create_universal_plane_dict(v21, 1, v32, v33, 12, (uint64_t *)&v654);
        unsigned int v37 = v21;
        uint64_t v38 = v74;
        uint64_t v39 = v14;
        LODWORD(v14) = v76;
        a1 = v75;
        uint64_t v40 = 24;
        goto LABEL_219;
      }
      unsigned __int16 v56 = 26160;
      goto LABEL_192;
    }
    if ((int)a3 <= 645166641)
    {
      if (a3 != 645162546)
      {
        if (a3 != 645162548)
        {
          unsigned __int16 v56 = 30256;
LABEL_192:
          if (a3 != (v56 | 0x26740000)) {
            goto LABEL_358;
          }
          uint64_t v69 = (a1 + 1) >> 1;
          uint64_t v70 = (v14 + 1) >> 1;
          uint64_t v71 = a1;
          uint64_t v72 = v14;
          unsigned int v73 = v21;
LABEL_324:
          values = CA::SurfaceUtil::create_universal_plane_dict(v73, 1, v71, v72, 12, (uint64_t *)&v654);
          unsigned int v46 = v21;
          uint64_t v47 = v69;
          uint64_t v48 = v70;
          uint64_t v49 = 24;
LABEL_357:
          CFDictionaryRef htpc_plane_dict = CA::SurfaceUtil::create_universal_plane_dict(v46, 0, v47, v48, v49, (uint64_t *)&v654);
          goto LABEL_358;
        }
        goto LABEL_322;
      }
LABEL_321:
      uint64_t v69 = (a1 + 1) >> 1;
      uint64_t v71 = a1;
      uint64_t v70 = v14;
      unsigned int v73 = v21;
LABEL_323:
      uint64_t v72 = v70;
      goto LABEL_324;
    }
    if ((int)a3 <= 645279799)
    {
      if (a3 != 645166642)
      {
        if (a3 != 645166644) {
          goto LABEL_358;
        }
LABEL_322:
        uint64_t v69 = a1;
        uint64_t v70 = v14;
        unsigned int v73 = v21;
        uint64_t v71 = a1;
        goto LABEL_323;
      }
      goto LABEL_321;
    }
    if (a3 != 645279800 && a3 != 645280312) {
      goto LABEL_358;
    }
    goto LABEL_240;
  }
  if ((int)a3 > 643969847)
  {
    if ((int)a3 <= 645083762)
    {
      if (a3 == 643969848)
      {
        values = CA::SurfaceUtil::create_universal_plane_dict(v21, 0, a1, v14, 32, (uint64_t *)&v654);
        unsigned int v46 = v21;
        uint64_t v47 = a1;
        uint64_t v48 = v14;
        uint64_t v49 = 8;
        goto LABEL_357;
      }
      if (a3 == 644624754)
      {
LABEL_254:
        uint64_t v95 = a1;
        if (!CADeviceSupportsUniversalCompression::universal)
        {
          int8x16_t v556 = (CA::SurfaceUtil *)a1;
          uint64_t v557 = v14;
          unint64_t v558 = 4;
          goto LABEL_850;
        }
        unsigned int v97 = v21;
        uint64_t v96 = v14;
LABEL_256:
        uint64_t v101 = 32;
        goto LABEL_257;
      }
      unsigned __int16 v27 = 12403;
      goto LABEL_127;
    }
    if ((a3 - 645097008) > 4 || ((1 << (a3 - 48)) & 0x15) == 0)
    {
      if (a3 == 645083763)
      {
LABEL_128:
        uint64_t v32 = a1;
        uint64_t v33 = v14;
        if (CA::Render::fourcc_is_444((CA::Render *)a3)) {
          uint64_t v34 = a1;
        }
        else {
          uint64_t v34 = (a1 + 1) >> 1;
        }
        unsigned int v35 = a1;
        int v36 = v14;
        if (CA::Render::fourcc_is_420((CA::Render *)a3)) {
          uint64_t v14 = (v14 + 1) >> 1;
        }
        else {
          uint64_t v14 = v14;
        }
        values = CA::SurfaceUtil::create_universal_plane_dict(v21, 1, v32, v33, 16, (uint64_t *)&v654);
        unsigned int v37 = v21;
        uint64_t v38 = v34;
        uint64_t v39 = v14;
        LODWORD(v14) = v36;
        a1 = v35;
        uint64_t v40 = 32;
LABEL_219:
        CFDictionaryRef htpc_plane_dict = CA::SurfaceUtil::create_universal_plane_dict(v37, 0, v38, v39, v40, (uint64_t *)&v654);
        unsigned int v82 = v21;
        uint64_t v83 = v32;
        uint64_t v84 = v33;
        uint64_t v85 = 16;
LABEL_248:
        CFDictionaryRef plane_dict = CA::SurfaceUtil::create_universal_plane_dict(v82, 0, v83, v84, v85, (uint64_t *)&v654);
        goto LABEL_358;
      }
      unsigned __int16 v27 = 13427;
LABEL_127:
      if (a3 != (v27 | 0x26730000)) {
        goto LABEL_358;
      }
      goto LABEL_128;
    }
LABEL_137:
    uint64_t v41 = a1;
    uint64_t v42 = v14;
    if (CA::Render::fourcc_is_444((CA::Render *)a3)) {
      uint64_t v43 = a1;
    }
    else {
      uint64_t v43 = (a1 + 1) >> 1;
    }
    unsigned int v44 = a1;
    int v45 = v14;
    if (CA::Render::fourcc_is_420((CA::Render *)a3)) {
      uint64_t v14 = (v14 + 1) >> 1;
    }
    else {
      uint64_t v14 = v14;
    }
    values = CA::SurfaceUtil::create_universal_plane_dict(v21, 1, v41, v42, 16, (uint64_t *)&v654);
    unsigned int v46 = v21;
    uint64_t v47 = v43;
    uint64_t v48 = v14;
    LODWORD(v14) = v45;
    a1 = v44;
    uint64_t v49 = 32;
    goto LABEL_357;
  }
  if ((int)a3 > 641234481)
  {
    if ((int)a3 <= 641877824)
    {
      if (a3 == 641234482)
      {
LABEL_319:
        uint64_t v58 = (a1 + 1) >> 1;
        uint64_t v60 = a1;
        uint64_t v59 = v14;
        unsigned int v62 = v21;
LABEL_326:
        uint64_t v61 = v59;
        goto LABEL_327;
      }
      if (a3 != 641234484) {
        goto LABEL_358;
      }
      goto LABEL_325;
    }
    if (a3 != 641877825)
    {
      int v51 = 642934849;
      goto LABEL_251;
    }
    goto LABEL_254;
  }
  if ((int)a3 <= 641230387)
  {
    if (a3 != 641230384)
    {
      if (a3 != 641230386) {
        goto LABEL_358;
      }
      goto LABEL_319;
    }
LABEL_173:
    uint64_t v58 = (a1 + 1) >> 1;
    uint64_t v59 = (v14 + 1) >> 1;
    uint64_t v60 = a1;
    uint64_t v61 = v14;
    unsigned int v62 = v21;
LABEL_327:
    values = CA::SurfaceUtil::create_universal_plane_dict(v62, 1, v60, v61, 8, (uint64_t *)&v654);
    unsigned int v46 = v21;
    uint64_t v47 = v58;
    uint64_t v48 = v59;
    uint64_t v49 = 16;
    goto LABEL_357;
  }
  if (a3 == 641230388)
  {
LABEL_325:
    uint64_t v58 = a1;
    uint64_t v59 = v14;
    unsigned int v62 = v21;
    uint64_t v60 = a1;
    goto LABEL_326;
  }
  if (a3 == 641234480) {
    goto LABEL_173;
  }
LABEL_358:
  uint64_t v136 = 0;
  LODWORD(v137) = 0;
  unsigned int v645 = a6;
  do
  {
    if (*(void **)((char *)&values + v136)) {
      CFIndex v137 = (v137 + 1);
    }
    else {
      CFIndex v137 = v137;
    }
    v136 += 8;
  }
  while (v136 != 24);
  if (v137)
  {
    CFArrayRef v138 = CFArrayCreate(0, (const void **)&values, v137, MEMORY[0x1E4F1D510]);
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F238], v138);
    CFRelease(v138);
    int v139 = -1;
    do
      CFRelease(*(&values + (v137 + v139--)));
    while ((int)v137 + v139 + 2 > 1);
  }
  unint64_t v140 = a8[4];
  unint64_t v141 = (CA::SurfaceUtil *)a1;
  uint64_t v142 = v14;
  if (v140 && v654 > v140 || v651 > a1 || v650 > v14)
  {
    a3 = CA::Render::fourcc_compressed_of_type((CA::Render *)a3, 0, 0);
    CFRelease(Mutable);
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  else if (v654)
  {
LABEL_914:
    int v190 = (v645 >> 2) & 1;
    goto LABEL_915;
  }
  if ((int)a3 > 1932812658)
  {
    if ((int)a3 > 1999843441)
    {
      if ((int)a3 > 2016698679)
      {
        if ((int)a3 <= 2019964015)
        {
          if ((int)a3 <= 2019963439)
          {
            if (a3 == 2016698680) {
              goto LABEL_553;
            }
            int v162 = 2016698739;
            goto LABEL_552;
          }
          if (a3 != 2019963440)
          {
            if (a3 == 2019963442) {
              goto LABEL_520;
            }
            int v162 = 2019963956;
LABEL_552:
            if (a3 != v162) {
              goto LABEL_848;
            }
            goto LABEL_553;
          }
LABEL_581:
          unsigned __int8 v642 = a6;
          int v281 = v14;
          uint64_t v282 = (v14 + 1) >> 1;
          uint64_t v283 = a8[1];
          unint64_t v284 = v283 - 1 + 2 * a1;
          if ((v283 & (v283 - 1)) != 0) {
            uint64_t v236 = v284 / v283 * v283;
          }
          else {
            uint64_t v236 = v284 & -v283;
          }
          int8x8_t v285 = (int8x8_t)a8[2];
          uint8x8_t v286 = (uint8x8_t)vcnt_s8(v285);
          v286.i16[0] = vaddlv_u8(v286);
          unint64_t v287 = v286.u32[0];
          uint64_t v240 = v142 - 1;
          unint64_t v288 = *(void *)&v285 + v142 - 1;
          if (v286.u32[0] > 1uLL) {
            unint64_t v289 = v288 / *(void *)&v285 * *(void *)&v285;
          }
          else {
            unint64_t v289 = v288 & -*(void *)&v285;
          }
          int8x8_t v290 = (int8x8_t)a8[3];
          uint8x8_t v291 = (uint8x8_t)vcnt_s8(v290);
          v291.i16[0] = vaddlv_u8(v291);
          unint64_t v292 = *(void *)&v290 - 1 + v289 * v236;
          if (v291.u32[0] > 1uLL) {
            uint64_t v293 = v292 / *(void *)&v290 * *(void *)&v290;
          }
          else {
            uint64_t v293 = v292 & -*(void *)&v290;
          }
          uint64_t v653 = v293;
          unint64_t v294 = v282 + *(void *)&v285 - 1;
          if (v287 > 1) {
            unint64_t v295 = v294 / *(void *)&v285 * *(void *)&v285;
          }
          else {
            unint64_t v295 = v294 & -*(void *)&v285;
          }
          unint64_t v296 = *(void *)&v290 - 1 + v295 * v236;
          if (v291.u32[0] > 1uLL) {
            uint64_t v297 = v296 / *(void *)&v290 * *(void *)&v290;
          }
          else {
            uint64_t v297 = v296 & -*(void *)&v290;
          }
          uint64_t v652 = v297;
          values = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v142, v236, 0, v293, 1, 2);
          CFDictionaryRef htpc_plane_dict = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)((a1 + 1) >> 1), v282, v236, v653, v652, 1, 4);
          if (CA::Render::fourcc_has_alpha((CA::Render *)a3))
          {
            BOOL v250 = a3 == 2016436536;
            LODWORD(v14) = v281;
            a6 = v642;
LABEL_598:
            if (v250)
            {
              uint64_t v298 = a8[1];
              unint64_t v299 = v298 - 1 + a1;
              if ((v298 & (v298 - 1)) != 0) {
                uint64_t v236 = v299 / v298 * v298;
              }
              else {
                uint64_t v236 = v299 & -v298;
              }
            }
            unint64_t v301 = a8[2];
            unint64_t v302 = v301 + v240;
            if ((v301 & (v301 - 1)) != 0) {
              uint64_t v303 = v302 / v301 * v301;
            }
            else {
              uint64_t v303 = v302 & -(uint64_t)v301;
            }
            uint64_t v304 = a8[3];
            goto LABEL_693;
          }
          CFArrayRef v300 = CFArrayCreate(0, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
          CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F238], v300);
          CFRelease(v300);
          CFRelease(htpc_plane_dict);
          CFRelease(values);
          unint64_t v654 = v652 + v653;
          int v190 = (v645 >> 2) & 1;
          LODWORD(v14) = v281;
          a6 = v642;
LABEL_915:
          uint64_t v355 = v648;
          int v357 = v646;
          int v356 = v647;
          goto LABEL_916;
        }
        if ((int)a3 > 2033463855)
        {
          if (a3 != 2033463856)
          {
            if (a3 != 2037741158 && a3 != 2037741171) {
              goto LABEL_848;
            }
LABEL_463:
            uint64_t v168 = a8[1];
            unint64_t v169 = v168 - 1 + 2 * a1;
            unint64_t v170 = v169 / v168 * v168;
            unint64_t v171 = v169 & -v168;
            if ((v168 & (v168 - 1)) != 0) {
              unint64_t v172 = v170;
            }
            else {
              unint64_t v172 = v171;
            }
            CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFD8], 4);
            CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2F0A0], 2);
            CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFE0], v172);
            uint64_t v173 = a8[2];
            unint64_t v174 = v173 - 1 + v14;
            if ((v173 & (v173 - 1)) != 0) {
              unint64_t v175 = v174 / v173 * v173;
            }
            else {
              unint64_t v175 = v174 & -v173;
            }
            uint64_t v355 = v648;
            int v357 = v646;
            int v356 = v647;
            uint64_t v362 = a8[3];
            unint64_t v363 = v362 - 1 + v175 * v172;
            if ((v362 & (v362 - 1)) != 0) {
              unint64_t v364 = v363 / v362 * v362;
            }
            else {
              unint64_t v364 = v363 & -v362;
            }
            unint64_t v654 = v364;
            int v190 = 1;
            goto LABEL_916;
          }
          goto LABEL_641;
        }
        if (a3 != 2019964016)
        {
          if (a3 == 2033463606)
          {
            uint64_t v319 = a8[1];
            unint64_t v320 = v319 - 1 + 8 * a1;
            unint64_t v321 = v320 / v319 * v319;
            unint64_t v322 = v320 & -v319;
            if ((v319 & (v319 - 1)) != 0) {
              unint64_t v323 = v321;
            }
            else {
              unint64_t v323 = v322;
            }
            CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFD8], 8);
            CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFE0], v323);
            uint64_t v324 = a8[2];
            uint64_t v325 = a8[3];
            unint64_t v326 = v324 - 1 + v14;
            unint64_t v327 = v326 / v324 * v324;
            unint64_t v328 = v326 & -v324;
            if ((v324 & (v324 - 1)) != 0) {
              unint64_t v329 = v327;
            }
            else {
              unint64_t v329 = v328;
            }
            unint64_t v330 = v325 - 1 + v329 * v323;
            unint64_t v331 = v330 / v325 * v325;
            unint64_t v332 = v330 & -v325;
            if ((v325 & (v325 - 1)) != 0) {
              unint64_t v332 = v331;
            }
            unint64_t v654 = v332;
            int v190 = (a6 >> 2) & 1;
            LODWORD(a3) = 2033463606;
            goto LABEL_915;
          }
          goto LABEL_848;
        }
      }
      else
      {
        if ((int)a3 <= 2016567666)
        {
          if ((int)a3 <= 2016436535)
          {
            if (a3 != 1999843442)
            {
              if (a3 == 1999908961)
              {
                uint64_t v205 = a8[1];
                unint64_t v206 = v205 - 1 + 8 * a1;
                unint64_t v207 = v206 / v205 * v205;
                unint64_t v208 = v206 & -v205;
                if ((v205 & (v205 - 1)) != 0) {
                  unint64_t v209 = v207;
                }
                else {
                  unint64_t v209 = v208;
                }
                CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFD8], 8);
                CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFE0], v209);
                uint64_t v210 = a8[2];
                uint64_t v211 = a8[3];
                unint64_t v212 = v210 - 1 + v14;
                unint64_t v213 = v212 / v210 * v210;
                unint64_t v214 = v212 & -v210;
                if ((v210 & (v210 - 1)) != 0) {
                  unint64_t v215 = v213;
                }
                else {
                  unint64_t v215 = v214;
                }
                unint64_t v216 = v211 - 1 + v215 * v209;
                unint64_t v217 = v216 / v211 * v211;
                unint64_t v218 = v216 & -v211;
                if ((v211 & (v211 - 1)) != 0) {
                  unint64_t v218 = v217;
                }
                unint64_t v654 = v218;
                int v190 = (a6 >> 2) & 1;
                LODWORD(a3) = 1999908961;
                goto LABEL_915;
              }
              goto LABEL_848;
            }
            goto LABEL_503;
          }
          if (a3 != 2016436536 && a3 != 2016436595)
          {
            int v151 = 2016567608;
            goto LABEL_519;
          }
          goto LABEL_581;
        }
        if ((int)a3 <= 2016686641)
        {
          if (a3 == 2016567667) {
            goto LABEL_520;
          }
          int v149 = 2016686640;
          goto LABEL_580;
        }
        if (a3 == 2016686642) {
          goto LABEL_520;
        }
        if (a3 == 2016687156) {
          goto LABEL_553;
        }
        if (a3 != 2016687216) {
          goto LABEL_848;
        }
      }
      uint64_t v348 = a8[1];
      unint64_t v349 = v348 - 1 + 4 * a1;
      unint64_t v350 = v349 / v348 * v348;
      unint64_t v351 = v349 & -v348;
      uint64_t v156 = a8;
      if ((v348 & (v348 - 1)) != 0) {
        unint64_t v157 = v350;
      }
      else {
        unint64_t v157 = v351;
      }
      int v158 = (const void *)*MEMORY[0x1E4F2EFD8];
      unint64_t v159 = Mutable;
      int v160 = 4;
      goto LABEL_654;
    }
    if ((int)a3 <= 1952854575)
    {
      if ((int)a3 <= 1937125937)
      {
        if ((int)a3 > 1936077361)
        {
          if (a3 != 1936077362)
          {
            if (a3 != 1936077876)
            {
              int v149 = 1937125936;
              goto LABEL_580;
            }
LABEL_553:
            int v256 = v14;
            unint64_t v257 = a8[1];
            unint64_t v258 = v257 - 1 + 2 * a1;
            unint64_t v259 = v257 - 1 + 4 * a1;
            if ((v257 & (v257 - 1)) != 0)
            {
              uint64_t v236 = v258 / v257 * v257;
              uint64_t v261 = v259 / v257 * v257;
            }
            else
            {
              uint64_t v260 = -(uint64_t)v257;
              uint64_t v236 = v258 & v260;
              uint64_t v261 = v259 & v260;
            }
            int8x8_t v262 = (int8x8_t)a8[2];
            uint8x8_t v263 = (uint8x8_t)vcnt_s8(v262);
            v263.i16[0] = vaddlv_u8(v263);
            unint64_t v264 = v263.u32[0];
            unint64_t v265 = *(void *)&v262 + v142 - 1;
            if (v263.u32[0] > 1uLL) {
              unint64_t v266 = v265 / *(void *)&v262 * *(void *)&v262;
            }
            else {
              unint64_t v266 = v265 & -*(void *)&v262;
            }
            int8x8_t v267 = (int8x8_t)a8[3];
            uint8x8_t v268 = (uint8x8_t)vcnt_s8(v267);
            v268.i16[0] = vaddlv_u8(v268);
            unint64_t v269 = *(void *)&v267 - 1 + v266 * v236;
            if (v268.u32[0] > 1uLL) {
              uint64_t v270 = v269 / *(void *)&v267 * *(void *)&v267;
            }
            else {
              uint64_t v270 = v269 & -*(void *)&v267;
            }
            uint64_t v653 = v270;
            if (v264 > 1) {
              unint64_t v271 = v265 / *(void *)&v262 * *(void *)&v262;
            }
            else {
              unint64_t v271 = v265 & -*(void *)&v262;
            }
            unint64_t v272 = *(void *)&v267 - 1 + v271 * v261;
            if (v268.u32[0] > 1uLL) {
              uint64_t v273 = v272 / *(void *)&v267 * *(void *)&v267;
            }
            else {
              uint64_t v273 = v272 & -*(void *)&v267;
            }
            uint64_t v652 = v273;
            values = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v142, v236, 0, v270, 1, 2);
            CFDictionaryRef htpc_plane_dict = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v142, v261, v653, v652, 1, 4);
            if (CA::Render::fourcc_has_alpha((CA::Render *)a3))
            {
              LODWORD(v14) = v256;
              if (a3 == 2016698680)
              {
                uint64_t v274 = a8[1];
                unint64_t v275 = v274 - 1 + a1;
                if ((v274 & (v274 - 1)) != 0) {
                  uint64_t v236 = v275 / v274 * v274;
                }
                else {
                  uint64_t v236 = v275 & -v274;
                }
              }
              unint64_t v388 = a8[2];
              unint64_t v389 = v388 + v142 - 1;
              if ((v388 & (v388 - 1)) != 0) {
                uint64_t v303 = v389 / v388 * v388;
              }
              else {
                uint64_t v303 = v389 & -(uint64_t)v388;
              }
              uint64_t v304 = a8[3];
LABEL_693:
              unint64_t v386 = v304 - 1 + v303 * v236;
              if ((v304 & (v304 - 1)) == 0)
              {
LABEL_694:
                uint64_t v387 = v386 & -v304;
                goto LABEL_695;
              }
LABEL_687:
              uint64_t v387 = v386 / v304 * v304;
LABEL_695:
              CFDictionaryRef plane_dict = CA::SurfaceUtil::create_plane_dict(v141, v142, v236, v652 + v653, v387, 1, 1);
              CFArrayRef v390 = CFArrayCreate(0, (const void **)&values, 3, MEMORY[0x1E4F1D510]);
              CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F238], v390);
              CFRelease(v390);
              CFRelease(values);
              CFRelease(htpc_plane_dict);
              CFRelease(plane_dict);
              unint64_t v233 = v653 + v387 + v652;
LABEL_913:
              unint64_t v654 = v233;
              goto LABEL_914;
            }
            CFArrayRef v276 = CFArrayCreate(0, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
            CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F238], v276);
            CFRelease(v276);
            CFRelease(htpc_plane_dict);
            CFRelease(values);
            unint64_t v654 = v652 + v653;
            int v190 = (a6 >> 2) & 1;
            LODWORD(v14) = v256;
            goto LABEL_915;
          }
LABEL_520:
          uint64_t v234 = a8[1];
          unint64_t v235 = v234 - 1 + 2 * a1;
          if ((v234 & (v234 - 1)) != 0) {
            uint64_t v236 = v235 / v234 * v234;
          }
          else {
            uint64_t v236 = v235 & -v234;
          }
          int8x8_t v237 = (int8x8_t)a8[2];
          uint8x8_t v238 = (uint8x8_t)vcnt_s8(v237);
          v238.i16[0] = vaddlv_u8(v238);
          unint64_t v239 = v238.u32[0];
          uint64_t v240 = v14 - 1;
          unint64_t v241 = *(void *)&v237 + v240;
          if (v238.u32[0] > 1uLL) {
            unint64_t v242 = v241 / *(void *)&v237 * *(void *)&v237;
          }
          else {
            unint64_t v242 = v241 & -*(void *)&v237;
          }
          int8x8_t v243 = (int8x8_t)a8[3];
          uint8x8_t v244 = (uint8x8_t)vcnt_s8(v243);
          v244.i16[0] = vaddlv_u8(v244);
          unint64_t v245 = *(void *)&v243 - 1 + v242 * v236;
          if (v244.u32[0] > 1uLL) {
            uint64_t v246 = v245 / *(void *)&v243 * *(void *)&v243;
          }
          else {
            uint64_t v246 = v245 & -*(void *)&v243;
          }
          uint64_t v653 = v246;
          if (v239 > 1) {
            unint64_t v247 = v241 / *(void *)&v237 * *(void *)&v237;
          }
          else {
            unint64_t v247 = v241 & -*(void *)&v237;
          }
          unint64_t v248 = *(void *)&v243 - 1 + v247 * v236;
          if (v244.u32[0] > 1uLL) {
            uint64_t v249 = v248 / *(void *)&v243 * *(void *)&v243;
          }
          else {
            uint64_t v249 = v248 & -*(void *)&v243;
          }
          uint64_t v652 = v249;
          values = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v14, v236, 0, v246, 1, 2);
          CFDictionaryRef htpc_plane_dict = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)((a1 + 1) >> 1), v14, v236, v653, v652, 1, 4);
          if (!CA::Render::fourcc_has_alpha((CA::Render *)a3)) {
            goto LABEL_912;
          }
          BOOL v250 = a3 == 2016567608;
          goto LABEL_598;
        }
        if (a3 == 1932812659) {
          goto LABEL_553;
        }
        int v149 = 1936077360;
LABEL_580:
        if (a3 != v149) {
          goto LABEL_848;
        }
        goto LABEL_581;
      }
      if ((int)a3 <= 1949327730)
      {
        if (a3 == 1937125938) {
          goto LABEL_520;
        }
        int v162 = 1937126452;
        goto LABEL_552;
      }
      if (a3 != 1949327731)
      {
        if (a3 == 1949458803) {
          goto LABEL_520;
        }
        int v162 = 1949589875;
        goto LABEL_552;
      }
      goto LABEL_581;
    }
    if ((int)a3 <= 1953903667)
    {
      if ((int)a3 <= 1952855091)
      {
        if (a3 != 1952854576)
        {
          int v151 = 1952854578;
LABEL_519:
          if (a3 != v151) {
            goto LABEL_848;
          }
          goto LABEL_520;
        }
        goto LABEL_581;
      }
      if (a3 != 1952855092)
      {
        if (a3 != 1953903152)
        {
          int v151 = 1953903154;
          goto LABEL_519;
        }
        goto LABEL_581;
      }
      goto LABEL_553;
    }
    if ((int)a3 <= 1983000885)
    {
      if (a3 == 1953903668) {
        goto LABEL_553;
      }
      int v167 = 1982882104;
    }
    else
    {
      if (a3 == 1983000886)
      {
        uint64_t v436 = a8[1];
        unint64_t v437 = v436 - 1 + 4 * a1;
        unint64_t v438 = v437 / v436 * v436;
        unint64_t v439 = v437 & -v436;
        if ((v436 & (v436 - 1)) != 0) {
          unint64_t v440 = v438;
        }
        else {
          unint64_t v440 = v439;
        }
        CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFD8], 4);
        CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFE0], v440);
        uint64_t v441 = a8[2];
        unint64_t v442 = v441 - 1 + v14;
        if ((v441 & (v441 - 1)) != 0) {
          unint64_t v443 = v442 / v441 * v441;
        }
        else {
          unint64_t v443 = v442 & -v441;
        }
        uint64_t v355 = v648;
        int v357 = v646;
        int v356 = v647;
        uint64_t v578 = a8[3];
        unint64_t v579 = v578 - 1 + v443 * v440;
        if ((v578 & (v578 - 1)) != 0) {
          unint64_t v580 = v579 / v578 * v578;
        }
        else {
          unint64_t v580 = v579 & -v578;
        }
        unint64_t v654 = v580;
        int v190 = 1;
        LODWORD(a3) = 1983000886;
        goto LABEL_916;
      }
      if (a3 == 1983013176)
      {
LABEL_617:
        int is_444 = CA::Render::fourcc_is_444((CA::Render *)a3);
        char v310 = is_444;
        int v311 = (CA::SurfaceUtil *)((a1 + 1) >> 1);
        if (is_444) {
          int v311 = (CA::SurfaceUtil *)a1;
        }
        double v640 = v311;
        int is_420 = CA::Render::fourcc_is_420((CA::Render *)a3);
        unsigned int v313 = a1;
        int v643 = v14;
        if (is_420) {
          uint64_t v314 = (v14 + 1) >> 1;
        }
        else {
          uint64_t v314 = v14;
        }
        uint64_t v315 = a8[1];
        unint64_t v316 = (unint64_t)v141 + v315 - 1;
        if ((v315 & (v315 - 1)) != 0)
        {
          uint64_t v236 = v316 / v315 * v315;
          unsigned int v317 = v313;
          uint64_t v318 = ((unint64_t)(2 * v313) + v315 - 1) / v315 * v315;
        }
        else
        {
          uint64_t v236 = v316 & -v315;
          unsigned int v317 = v313;
          uint64_t v318 = (2 * v313 + v315 - 1) & -v315;
        }
        if (v310) {
          uint64_t v365 = v318;
        }
        else {
          uint64_t v365 = v236;
        }
        int8x8_t v367 = (int8x8_t)a8[2];
        int8x8_t v366 = (int8x8_t)a8[3];
        uint8x8_t v368 = (uint8x8_t)vcnt_s8(v367);
        v368.i16[0] = vaddlv_u8(v368);
        unint64_t v369 = v368.u32[0];
        unint64_t v370 = *(void *)&v367 + v142 - 1;
        unint64_t v371 = v370 / *(void *)&v367 * *(void *)&v367;
        unint64_t v372 = v370 & -*(void *)&v367;
        if (v368.u32[0] <= 1uLL) {
          unint64_t v373 = v372;
        }
        else {
          unint64_t v373 = v371;
        }
        uint8x8_t v374 = (uint8x8_t)vcnt_s8(v366);
        v374.i16[0] = vaddlv_u8(v374);
        unint64_t v375 = *(void *)&v366 - 1 + v373 * v236;
        uint64_t v376 = v375 / *(void *)&v366 * *(void *)&v366;
        unint64_t v377 = v375 & -*(void *)&v366;
        if (v374.u32[0] <= 1uLL) {
          uint64_t v378 = v377;
        }
        else {
          uint64_t v378 = v376;
        }
        uint64_t v653 = v378;
        unint64_t v379 = v314 + *(void *)&v367 - 1;
        if (v369 > 1) {
          unint64_t v380 = v379 / *(void *)&v367 * *(void *)&v367;
        }
        else {
          unint64_t v380 = v379 & -*(void *)&v367;
        }
        unint64_t v381 = *(void *)&v366 - 1 + v380 * v365;
        if (v374.u32[0] > 1uLL) {
          uint64_t v382 = v381 / *(void *)&v366 * *(void *)&v366;
        }
        else {
          uint64_t v382 = v381 & -*(void *)&v366;
        }
        uint64_t v652 = v382;
        values = CA::SurfaceUtil::create_plane_dict(v141, v142, v236, 0, v378, 1, 1);
        CFDictionaryRef htpc_plane_dict = CA::SurfaceUtil::create_plane_dict(v640, v314, v365, v653, v652, 1, 2);
        unint64_t v383 = a8[2];
        unint64_t v384 = v383 + v142 - 1;
        if ((v383 & (v383 - 1)) != 0) {
          uint64_t v385 = v384 / v383 * v383;
        }
        else {
          uint64_t v385 = v384 & -(uint64_t)v383;
        }
        LODWORD(v14) = v643;
        uint64_t v304 = a8[3];
        unint64_t v386 = v304 - 1 + v385 * v236;
        a1 = v317;
        if ((v304 & (v304 - 1)) == 0) {
          goto LABEL_694;
        }
        goto LABEL_687;
      }
      int v167 = 1983144248;
    }
    if (a3 != v167) {
      goto LABEL_848;
    }
    goto LABEL_617;
  }
  if ((int)a3 > 1380410944)
  {
    if ((int)a3 <= 1885746227)
    {
      if ((int)a3 <= 1882468911)
      {
        if ((int)a3 <= 1647534391)
        {
          if (a3 != 1380410945)
          {
            if (a3 == 1380411457)
            {
              uint64_t v191 = a8[1];
              unint64_t v192 = v191 - 1 + 8 * a1;
              unint64_t v193 = v192 / v191 * v191;
              unint64_t v194 = v192 & -v191;
              if ((v191 & (v191 - 1)) != 0) {
                unint64_t v195 = v193;
              }
              else {
                unint64_t v195 = v194;
              }
              CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFD8], 8);
              CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFE0], v195);
              uint64_t v196 = a8[2];
              uint64_t v197 = a8[3];
              unint64_t v198 = v196 - 1 + v14;
              unint64_t v199 = v198 / v196 * v196;
              unint64_t v200 = v198 & -v196;
              if ((v196 & (v196 - 1)) != 0) {
                unint64_t v201 = v199;
              }
              else {
                unint64_t v201 = v200;
              }
              unint64_t v202 = v197 - 1 + v201 * v195;
              unint64_t v203 = v202 / v197 * v197;
              unint64_t v204 = v202 & -v197;
              if ((v197 & (v197 - 1)) != 0) {
                unint64_t v204 = v203;
              }
              unint64_t v654 = v204;
              int v190 = (a6 >> 2) & 1;
              LODWORD(a3) = 1380411457;
              goto LABEL_915;
            }
            goto LABEL_848;
          }
          uint64_t v451 = a8[1];
          unint64_t v452 = v451 - 1 + 16 * a1;
          unint64_t v453 = v452 / v451 * v451;
          unint64_t v454 = v452 & -v451;
          if ((v451 & (v451 - 1)) != 0) {
            unint64_t v455 = v453;
          }
          else {
            unint64_t v455 = v454;
          }
          CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFD8], 16);
          CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFE0], v455);
          uint64_t v456 = a8[2];
          unint64_t v457 = v456 - 1 + v14;
          if ((v456 & (v456 - 1)) != 0) {
            unint64_t v458 = v457 / v456 * v456;
          }
          else {
            unint64_t v458 = v457 & -v456;
          }
          uint64_t v355 = v648;
          int v357 = v646;
          int v356 = v647;
          uint64_t v581 = a8[3];
          unint64_t v582 = v581 - 1 + v458 * v455;
          if ((v581 & (v581 - 1)) != 0) {
            unint64_t v360 = v582 / v581 * v581;
          }
          else {
            unint64_t v360 = v582 & -v581;
          }
          unsigned int v361 = a6;
          LODWORD(a3) = 1380410945;
LABEL_661:
          unint64_t v654 = v360;
          int v190 = (v361 >> 2) & 1;
          goto LABEL_916;
        }
        if (a3 == 1647534392)
        {
          uint64_t v396 = a8[1];
          unint64_t v397 = a8[2];
          unint64_t v398 = v396 - 1 + 4 * a1;
          uint64_t v399 = v398 / v396 * v396;
          unint64_t v400 = v398 & -v396;
          if ((v396 & (v396 - 1)) != 0) {
            uint64_t v401 = v399;
          }
          else {
            uint64_t v401 = v400;
          }
          uint64_t v402 = v14 - 1;
          uint64_t v403 = (v397 + v402) & -(uint64_t)v397;
          if ((v397 & (v397 - 1)) != 0) {
            uint64_t v403 = (v397 + v402) / v397 * v397;
          }
          uint64_t v404 = a8[3];
          unint64_t v405 = v404 - 1 + v403 * v401;
          uint64_t v406 = v405 / v404 * v404;
          unint64_t v407 = v405 & -v404;
          if ((v404 & (v404 - 1)) != 0) {
            uint64_t v408 = v406;
          }
          else {
            uint64_t v408 = v407;
          }
          values = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v14, v401, 0, v408, 1, 4);
          uint64_t v409 = a8[1];
          unint64_t v410 = a8[2];
          unint64_t v411 = v409 - 1 + a1;
          unint64_t v412 = v411 & -v409;
          uint64_t v413 = v411 / v409 * v409;
          if ((v409 & (v409 - 1)) != 0) {
            uint64_t v414 = v413;
          }
          else {
            uint64_t v414 = v412;
          }
          uint64_t v415 = (v410 + v402) & -(uint64_t)v410;
          if ((v410 & (v410 - 1)) != 0) {
            uint64_t v415 = (v410 + v402) / v410 * v410;
          }
          uint64_t v416 = a8[3];
          unint64_t v417 = v416 - 1 + v415 * v414;
          uint64_t v418 = v417 / v416 * v416;
          unint64_t v419 = v417 & -v416;
          if ((v416 & (v416 - 1)) != 0) {
            uint64_t v420 = v418;
          }
          else {
            uint64_t v420 = v419;
          }
          CFDictionaryRef htpc_plane_dict = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v14, v414, v408, v420, 1, 1);
          CFArrayRef v421 = CFArrayCreate(0, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
          CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F238], v421);
          CFRelease(v421);
          CFRelease(htpc_plane_dict);
          CFRelease(values);
          unint64_t v654 = v420 + v408;
          int v190 = (a6 >> 2) & 1;
          LODWORD(a3) = 1647534392;
          goto LABEL_915;
        }
        if (a3 != 1714696752)
        {
          int v150 = 1815162994;
          goto LABEL_449;
        }
LABEL_641:
        int v644 = v14;
        uint64_t v14 = (v14 + 1) >> 1;
        unint64_t v333 = a8[1];
        unint64_t v334 = v333 - 1 + a1;
        unint64_t v335 = v333 - 1 + ((a1 + 1) >> 1);
        if ((v333 & (v333 - 1)) != 0)
        {
          uint64_t v337 = v334 / v333 * v333;
          uint64_t v338 = v335 / v333 * v333;
        }
        else
        {
          uint64_t v336 = -(uint64_t)v333;
          uint64_t v337 = v334 & v336;
          uint64_t v338 = v335 & v336;
        }
        int8x8_t v471 = (int8x8_t)a8[2];
        uint8x8_t v472 = (uint8x8_t)vcnt_s8(v471);
        v472.i16[0] = vaddlv_u8(v472);
        unint64_t v473 = v472.u32[0];
        unint64_t v474 = v142 + *(void *)&v471 - 1;
        if (v472.u32[0] > 1uLL) {
          unint64_t v475 = v474 / *(void *)&v471 * *(void *)&v471;
        }
        else {
          unint64_t v475 = v474 & -*(void *)&v471;
        }
        int8x8_t v503 = (int8x8_t)a8[3];
        uint8x8_t v504 = (uint8x8_t)vcnt_s8(v503);
        v504.i16[0] = vaddlv_u8(v504);
        unint64_t v505 = *(void *)&v503 - 1 + v475 * v337;
        if (v504.u32[0] > 1uLL) {
          uint64_t v506 = v505 / *(void *)&v503 * *(void *)&v503;
        }
        else {
          uint64_t v506 = v505 & -*(void *)&v503;
        }
        uint64_t v653 = v506;
        unint64_t v521 = v14 + *(void *)&v471 - 1;
        if (v473 > 1) {
          unint64_t v522 = v521 / *(void *)&v471 * *(void *)&v471;
        }
        else {
          unint64_t v522 = v521 & -*(void *)&v471;
        }
        unint64_t v535 = *(void *)&v503 - 1 + v522 * v338;
        if (v504.u32[0] > 1uLL) {
          uint64_t v536 = v535 / *(void *)&v503 * *(void *)&v503;
        }
        else {
          uint64_t v536 = v535 & -*(void *)&v503;
        }
        uint64_t v652 = v536;
        values = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v142, v337, 0, v506, 1, 1);
        CFDictionaryRef htpc_plane_dict = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)((a1 + 1) >> 1), v14, v338, v653, v652, 1, 1);
        CFDictionaryRef plane_dict = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)((a1 + 1) >> 1), v14, v338, v652 + v653, v652, 1, 1);
        CFArrayRef v555 = CFArrayCreate(0, (const void **)&values, 3, MEMORY[0x1E4F1D510]);
        CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F238], v555);
        CFRelease(v555);
        CFRelease(plane_dict);
        CFRelease(htpc_plane_dict);
        CFRelease(values);
        unint64_t v654 = v653 + 2 * v652;
        int v190 = (a6 >> 2) & 1;
        LODWORD(v14) = v644;
        goto LABEL_915;
      }
      if ((int)a3 <= 1882469427)
      {
        if (a3 != 1882468912)
        {
          int v166 = 1882468914;
          goto LABEL_575;
        }
LABEL_645:
        unsigned int v143 = a1;
        int v144 = v14;
        uint64_t v343 = (v14 + 1) >> 1;
        unint64_t v344 = CA::SurfaceUtil::rowbytes_for_packed_format(v141, a3);
        uint64_t v345 = a8[1];
        unint64_t v346 = v345 - 1 + v344;
        if ((v345 & (v345 - 1)) != 0) {
          uint64_t v347 = v346 / v345 * v345;
        }
        else {
          uint64_t v347 = v346 & -v345;
        }
        int8x8_t v482 = (int8x8_t)a8[2];
        uint8x8_t v483 = (uint8x8_t)vcnt_s8(v482);
        v483.i16[0] = vaddlv_u8(v483);
        unint64_t v484 = v483.u32[0];
        unint64_t v485 = v142 + *(void *)&v482 - 1;
        if (v483.u32[0] > 1uLL) {
          unint64_t v486 = v485 / *(void *)&v482 * *(void *)&v482;
        }
        else {
          unint64_t v486 = v485 & -*(void *)&v482;
        }
        int8x8_t v511 = (int8x8_t)a8[3];
        uint8x8_t v512 = (uint8x8_t)vcnt_s8(v511);
        v512.i16[0] = vaddlv_u8(v512);
        unint64_t v513 = *(void *)&v511 - 1 + v486 * v347;
        if (v512.u32[0] > 1uLL) {
          uint64_t v514 = v513 / *(void *)&v511 * *(void *)&v511;
        }
        else {
          uint64_t v514 = v513 & -*(void *)&v511;
        }
        uint64_t v653 = v514;
        unint64_t v525 = v343 + *(void *)&v482 - 1;
        if (v484 > 1) {
          unint64_t v526 = v525 / *(void *)&v482 * *(void *)&v482;
        }
        else {
          unint64_t v526 = v525 & -*(void *)&v482;
        }
        unint64_t v539 = *(void *)&v511 - 1 + v526 * v347;
        if (v512.u32[0] > 1uLL) {
          uint64_t v540 = v539 / *(void *)&v511 * *(void *)&v511;
        }
        else {
          uint64_t v540 = v539 & -*(void *)&v511;
        }
        uint64_t v652 = v540;
        values = CA::SurfaceUtil::create_plane_dict(v141, v142, v347, 0, v514, 3, 4);
        uint64_t v542 = v652;
        uint64_t v541 = v653;
        int8x16_t v543 = (CA::SurfaceUtil *)((v143 + 1) >> 1);
        uint64_t v544 = v343;
        uint64_t v545 = v347;
        uint64_t v546 = 3;
        uint64_t v547 = 8;
        goto LABEL_905;
      }
      if (a3 != 1882469428)
      {
        if (a3 != 1885745712)
        {
          int v166 = 1885745714;
LABEL_575:
          if (a3 != v166) {
            goto LABEL_848;
          }
          unint64_t v277 = CA::SurfaceUtil::rowbytes_for_packed_format((CA::SurfaceUtil *)a1, a3);
          uint64_t v278 = a8[1];
          unint64_t v279 = v278 - 1 + v277;
          if ((v278 & (v278 - 1)) != 0) {
            uint64_t v280 = v279 / v278 * v278;
          }
          else {
            uint64_t v280 = v279 & -v278;
          }
          int8x8_t v465 = (int8x8_t)a8[2];
          uint8x8_t v466 = (uint8x8_t)vcnt_s8(v465);
          v466.i16[0] = vaddlv_u8(v466);
          unint64_t v467 = v466.u32[0];
          unint64_t v468 = v14 + *(void *)&v465 - 1;
          unint64_t v469 = v468 / *(void *)&v465;
          if (v466.u32[0] > 1uLL) {
            unint64_t v470 = v469 * *(void *)&v465;
          }
          else {
            unint64_t v470 = v468 & -*(void *)&v465;
          }
          int8x8_t v499 = (int8x8_t)a8[3];
          uint8x8_t v500 = (uint8x8_t)vcnt_s8(v499);
          v500.i16[0] = vaddlv_u8(v500);
          unint64_t v501 = *(void *)&v499 - 1 + v470 * v280;
          if (v500.u32[0] > 1uLL) {
            uint64_t v502 = v501 / *(void *)&v499 * *(void *)&v499;
          }
          else {
            uint64_t v502 = v501 & -*(void *)&v499;
          }
          uint64_t v653 = v502;
          if (v467 > 1) {
            unint64_t v520 = v469 * *(void *)&v465;
          }
          else {
            unint64_t v520 = v468 & -*(void *)&v465;
          }
          unint64_t v533 = *(void *)&v499 - 1 + v520 * v280;
          if (v500.u32[0] > 1uLL) {
            uint64_t v534 = v533 / *(void *)&v499 * *(void *)&v499;
          }
          else {
            uint64_t v534 = v533 & -*(void *)&v499;
          }
          uint64_t v652 = v534;
          values = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v14, v280, 0, v502, 3, 4);
          uint64_t v549 = v652;
          uint64_t v548 = v653;
          int32x4_t v550 = (CA::SurfaceUtil *)((a1 + 1) >> 1);
          uint64_t v551 = v14;
          uint64_t v552 = v280;
          goto LABEL_830;
        }
        goto LABEL_645;
      }
LABEL_643:
      unint64_t v339 = CA::SurfaceUtil::rowbytes_for_packed_format((CA::SurfaceUtil *)a1, a3);
      uint64_t v340 = a8[1];
      unint64_t v341 = v340 - 1 + v339;
      if ((v340 & (v340 - 1)) != 0) {
        uint64_t v342 = v341 / v340 * v340;
      }
      else {
        uint64_t v342 = v341 & -v340;
      }
      int8x8_t v476 = (int8x8_t)a8[2];
      uint8x8_t v477 = (uint8x8_t)vcnt_s8(v476);
      v477.i16[0] = vaddlv_u8(v477);
      unint64_t v478 = v477.u32[0];
      unint64_t v479 = v14 + *(void *)&v476 - 1;
      unint64_t v480 = v479 / *(void *)&v476;
      if (v477.u32[0] > 1uLL) {
        unint64_t v481 = v480 * *(void *)&v476;
      }
      else {
        unint64_t v481 = v479 & -*(void *)&v476;
      }
      int8x8_t v507 = (int8x8_t)a8[3];
      uint8x8_t v508 = (uint8x8_t)vcnt_s8(v507);
      v508.i16[0] = vaddlv_u8(v508);
      unint64_t v509 = *(void *)&v507 - 1 + v481 * v342;
      if (v508.u32[0] > 1uLL) {
        uint64_t v510 = v509 / *(void *)&v507 * *(void *)&v507;
      }
      else {
        uint64_t v510 = v509 & -*(void *)&v507;
      }
      uint64_t v653 = v510;
      uint64_t v523 = 2 * v342;
      if (v478 > 1) {
        unint64_t v524 = v480 * *(void *)&v476;
      }
      else {
        unint64_t v524 = v479 & -*(void *)&v476;
      }
      unint64_t v537 = *(void *)&v507 - 1 + v524 * v523;
      if (v508.u32[0] > 1uLL) {
        uint64_t v538 = v537 / *(void *)&v507 * *(void *)&v507;
      }
      else {
        uint64_t v538 = v537 & -*(void *)&v507;
      }
      uint64_t v652 = v538;
      values = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v14, v342, 0, v510, 3, 4);
      uint64_t v549 = v652;
      uint64_t v548 = v653;
      int32x4_t v550 = (CA::SurfaceUtil *)a1;
      uint64_t v551 = v14;
      uint64_t v552 = v523;
LABEL_830:
      uint64_t v553 = 3;
      uint64_t v554 = 8;
      goto LABEL_911;
    }
    if ((int)a3 <= 1886680625)
    {
      if ((int)a3 <= 1886676529)
      {
        if (a3 == 1885746228) {
          goto LABEL_643;
        }
        unsigned __int16 v161 = 26160;
LABEL_539:
        if (a3 != (v161 | 0x70740000)) {
          goto LABEL_848;
        }
        if (!v641)
        {
          unsigned int v143 = a1;
          int v144 = v14;
          uint64_t v562 = (v14 + 1) >> 1;
          unint64_t v563 = CA::SurfaceUtil::rowbytes_for_packed_format(v141, a3);
          uint64_t v564 = a8[1];
          unint64_t v565 = v564 - 1 + v563;
          if ((v564 & (v564 - 1)) != 0) {
            uint64_t v566 = v565 / v564 * v564;
          }
          else {
            uint64_t v566 = v565 & -v564;
          }
          int8x8_t v583 = (int8x8_t)a8[2];
          uint8x8_t v584 = (uint8x8_t)vcnt_s8(v583);
          v584.i16[0] = vaddlv_u8(v584);
          unint64_t v585 = v584.u32[0];
          unint64_t v586 = v142 + *(void *)&v583 - 1;
          if (v584.u32[0] > 1uLL) {
            unint64_t v587 = v586 / *(void *)&v583 * *(void *)&v583;
          }
          else {
            unint64_t v587 = v586 & -*(void *)&v583;
          }
          int8x8_t v600 = (int8x8_t)a8[3];
          uint8x8_t v601 = (uint8x8_t)vcnt_s8(v600);
          v601.i16[0] = vaddlv_u8(v601);
          unint64_t v602 = *(void *)&v600 - 1 + v587 * v566;
          if (v601.u32[0] > 1uLL) {
            uint64_t v603 = v602 / *(void *)&v600 * *(void *)&v600;
          }
          else {
            uint64_t v603 = v602 & -*(void *)&v600;
          }
          uint64_t v653 = v603;
          unint64_t v612 = v562 + *(void *)&v583 - 1;
          if (v585 > 1) {
            unint64_t v613 = v612 / *(void *)&v583 * *(void *)&v583;
          }
          else {
            unint64_t v613 = v612 & -*(void *)&v583;
          }
          unint64_t v617 = *(void *)&v600 - 1 + v613 * v566;
          if (v601.u32[0] > 1uLL) {
            uint64_t v618 = v617 / *(void *)&v600 * *(void *)&v600;
          }
          else {
            uint64_t v618 = v617 & -*(void *)&v600;
          }
          uint64_t v652 = v618;
          values = CA::SurfaceUtil::create_plane_dict(v141, v142, v566, 0, v603, 5, 8);
          uint64_t v542 = v652;
          uint64_t v541 = v653;
          int8x16_t v543 = (CA::SurfaceUtil *)((v143 + 1) >> 1);
          uint64_t v544 = v562;
          uint64_t v545 = v566;
          uint64_t v546 = 5;
          uint64_t v547 = 16;
          goto LABEL_905;
        }
        if (x_log_hook_p()) {
          goto LABEL_649;
        }
        uint64_t v251 = x_log_category_utilities;
        if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_848;
        }
        *(_WORD *)long long buf = 0;
        float v252 = "12-bit packed linear YUV formats unsupported on this platform.";
        goto LABEL_847;
      }
      if (a3 != 1886676530)
      {
        if (a3 != 1886676532)
        {
          unsigned __int16 v161 = 30256;
          goto LABEL_539;
        }
        goto LABEL_626;
      }
      goto LABEL_647;
    }
    if ((int)a3 <= 1919365991)
    {
      if (a3 != 1886680626)
      {
        if (a3 != 1886680628) {
          goto LABEL_848;
        }
LABEL_626:
        if (v641)
        {
          if (x_log_hook_p()) {
            goto LABEL_649;
          }
          uint64_t v251 = x_log_category_utilities;
          if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_848;
          }
          *(_WORD *)long long buf = 0;
          float v252 = "12-bit packed linear YUV formats unsupported on this platform.";
          goto LABEL_847;
        }
        unint64_t v567 = CA::SurfaceUtil::rowbytes_for_packed_format((CA::SurfaceUtil *)a1, a3);
        uint64_t v568 = a8[1];
        unint64_t v569 = v568 - 1 + v567;
        if ((v568 & (v568 - 1)) != 0) {
          uint64_t v570 = v569 / v568 * v568;
        }
        else {
          uint64_t v570 = v569 & -v568;
        }
        int8x8_t v588 = (int8x8_t)a8[2];
        uint8x8_t v589 = (uint8x8_t)vcnt_s8(v588);
        v589.i16[0] = vaddlv_u8(v589);
        unint64_t v590 = v589.u32[0];
        unint64_t v591 = v14 + *(void *)&v588 - 1;
        unint64_t v592 = v591 / *(void *)&v588;
        if (v589.u32[0] > 1uLL) {
          unint64_t v593 = v592 * *(void *)&v588;
        }
        else {
          unint64_t v593 = v591 & -*(void *)&v588;
        }
        int8x8_t v604 = (int8x8_t)a8[3];
        uint8x8_t v605 = (uint8x8_t)vcnt_s8(v604);
        v605.i16[0] = vaddlv_u8(v605);
        unint64_t v606 = *(void *)&v604 - 1 + v593 * v570;
        if (v605.u32[0] > 1uLL) {
          uint64_t v607 = v606 / *(void *)&v604 * *(void *)&v604;
        }
        else {
          uint64_t v607 = v606 & -*(void *)&v604;
        }
        uint64_t v653 = v607;
        uint64_t v614 = 2 * v570;
        if (v590 > 1) {
          unint64_t v615 = v592 * *(void *)&v588;
        }
        else {
          unint64_t v615 = v591 & -*(void *)&v588;
        }
        unint64_t v619 = *(void *)&v604 - 1 + v615 * v614;
        if (v605.u32[0] > 1uLL) {
          uint64_t v620 = v619 / *(void *)&v604 * *(void *)&v604;
        }
        else {
          uint64_t v620 = v619 & -*(void *)&v604;
        }
        uint64_t v652 = v620;
        values = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v14, v570, 0, v607, 5, 8);
        uint64_t v549 = v652;
        uint64_t v548 = v653;
        int32x4_t v550 = (CA::SurfaceUtil *)a1;
        uint64_t v551 = v14;
        uint64_t v552 = v614;
LABEL_910:
        uint64_t v553 = 5;
        uint64_t v554 = 16;
        goto LABEL_911;
      }
LABEL_647:
      if (v641)
      {
        if (x_log_hook_p()) {
          goto LABEL_649;
        }
        uint64_t v251 = x_log_category_utilities;
        if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_848;
        }
        *(_WORD *)long long buf = 0;
        float v252 = "12-bit packed linear YUV formats unsupported on this platform.";
        goto LABEL_847;
      }
      unint64_t v571 = CA::SurfaceUtil::rowbytes_for_packed_format((CA::SurfaceUtil *)a1, a3);
      uint64_t v572 = a8[1];
      unint64_t v573 = v572 - 1 + v571;
      if ((v572 & (v572 - 1)) != 0) {
        uint64_t v574 = v573 / v572 * v572;
      }
      else {
        uint64_t v574 = v573 & -v572;
      }
      int8x8_t v594 = (int8x8_t)a8[2];
      uint8x8_t v595 = (uint8x8_t)vcnt_s8(v594);
      v595.i16[0] = vaddlv_u8(v595);
      unint64_t v596 = v595.u32[0];
      unint64_t v597 = v14 + *(void *)&v594 - 1;
      unint64_t v598 = v597 / *(void *)&v594;
      if (v595.u32[0] > 1uLL) {
        unint64_t v599 = v598 * *(void *)&v594;
      }
      else {
        unint64_t v599 = v597 & -*(void *)&v594;
      }
      int8x8_t v608 = (int8x8_t)a8[3];
      uint8x8_t v609 = (uint8x8_t)vcnt_s8(v608);
      v609.i16[0] = vaddlv_u8(v609);
      unint64_t v610 = *(void *)&v608 - 1 + v599 * v574;
      if (v609.u32[0] > 1uLL) {
        uint64_t v611 = v610 / *(void *)&v608 * *(void *)&v608;
      }
      else {
        uint64_t v611 = v610 & -*(void *)&v608;
      }
      uint64_t v653 = v611;
      if (v596 > 1) {
        unint64_t v616 = v598 * *(void *)&v594;
      }
      else {
        unint64_t v616 = v597 & -*(void *)&v594;
      }
      unint64_t v621 = *(void *)&v608 - 1 + v616 * v574;
      if (v609.u32[0] > 1uLL) {
        uint64_t v622 = v621 / *(void *)&v608 * *(void *)&v608;
      }
      else {
        uint64_t v622 = v621 & -*(void *)&v608;
      }
      uint64_t v652 = v622;
      values = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v14, v574, 0, v611, 5, 8);
      uint64_t v549 = v652;
      uint64_t v548 = v653;
      int32x4_t v550 = (CA::SurfaceUtil *)((a1 + 1) >> 1);
      uint64_t v551 = v14;
      uint64_t v552 = v574;
      goto LABEL_910;
    }
    if (a3 == 1919365992)
    {
      uint64_t v444 = a8[1];
      unint64_t v445 = v444 - 1 + 2 * a1;
      uint64_t v446 = v445 / v444 * v444;
      unint64_t v447 = v445 & -v444;
      if ((v444 & (v444 - 1)) != 0) {
        uint64_t v448 = v446;
      }
      else {
        uint64_t v448 = v447;
      }
      uint64_t v449 = v448 * v14;
      values = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v14, v448, 0, v449, 1, 2);
      CFDictionaryRef htpc_plane_dict = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v14, v448, v449, v449, 1, 2);
      CFDictionaryRef plane_dict = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v14, v448, 2 * v449, v449, 1, 2);
      CFArrayRef v450 = CFArrayCreate(0, (const void **)&values, 3, MEMORY[0x1E4F1D510]);
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F238], v450);
      CFRelease(v450);
      CFRelease(values);
      CFRelease(htpc_plane_dict);
      CFRelease(plane_dict);
      unint64_t v654 = 3 * v449;
      int v190 = (a6 >> 2) & 1;
      LODWORD(a3) = 1919365992;
      goto LABEL_915;
    }
    if (a3 != 1932550515)
    {
      int v151 = 1932681587;
      goto LABEL_519;
    }
    goto LABEL_581;
  }
  if ((int)a3 <= 1027423536)
  {
    if ((int)a3 <= 875704933)
    {
      if ((int)a3 > 846624120)
      {
        if (a3 != 846624121)
        {
          if (a3 == 875704422 || a3 == 875704438)
          {
            unsigned int v143 = a1;
            int v144 = v14;
            uint64_t v145 = (v14 + 1) >> 1;
            uint64_t v146 = a8[1];
            unint64_t v147 = (unint64_t)v141 + v146 - 1;
            if ((v146 & (v146 - 1)) != 0) {
              uint64_t v148 = v147 / v146 * v146;
            }
            else {
              uint64_t v148 = v147 & -v146;
            }
            int8x8_t v391 = (int8x8_t)a8[2];
            uint8x8_t v392 = (uint8x8_t)vcnt_s8(v391);
            v392.i16[0] = vaddlv_u8(v392);
            unint64_t v393 = v392.u32[0];
            unint64_t v394 = v142 + *(void *)&v391 - 1;
            if (v392.u32[0] > 1uLL) {
              unint64_t v395 = v394 / *(void *)&v391 * *(void *)&v391;
            }
            else {
              unint64_t v395 = v394 & -*(void *)&v391;
            }
            int8x8_t v487 = (int8x8_t)a8[3];
            uint8x8_t v488 = (uint8x8_t)vcnt_s8(v487);
            v488.i16[0] = vaddlv_u8(v488);
            unint64_t v489 = *(void *)&v487 - 1 + v395 * v148;
            if (v488.u32[0] > 1uLL) {
              uint64_t v490 = v489 / *(void *)&v487 * *(void *)&v487;
            }
            else {
              uint64_t v490 = v489 & -*(void *)&v487;
            }
            uint64_t v653 = v490;
            unint64_t v515 = v145 + *(void *)&v391 - 1;
            if (v393 > 1) {
              unint64_t v516 = v515 / *(void *)&v391 * *(void *)&v391;
            }
            else {
              unint64_t v516 = v515 & -*(void *)&v391;
            }
            unint64_t v527 = *(void *)&v487 - 1 + v516 * v148;
            if (v488.u32[0] > 1uLL) {
              uint64_t v528 = v527 / *(void *)&v487 * *(void *)&v487;
            }
            else {
              uint64_t v528 = v527 & -*(void *)&v487;
            }
            uint64_t v652 = v528;
            values = CA::SurfaceUtil::create_plane_dict(v141, v142, v148, 0, v490, 1, 1);
            uint64_t v542 = v652;
            uint64_t v541 = v653;
            int8x16_t v543 = (CA::SurfaceUtil *)((v143 + 1) >> 1);
            uint64_t v544 = v145;
            uint64_t v545 = v148;
            uint64_t v546 = 1;
            uint64_t v547 = 2;
LABEL_905:
            CFDictionaryRef htpc_plane_dict = CA::SurfaceUtil::create_plane_dict(v543, v544, v545, v541, v542, v546, v547);
            CFArrayRef v623 = CFArrayCreate(0, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
            CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F238], v623);
            CFRelease(v623);
            CFRelease(htpc_plane_dict);
            CFRelease(values);
            unint64_t v654 = v652 + v653;
            int v190 = (a6 >> 2) & 1;
            LODWORD(v14) = v144;
            a1 = v143;
            goto LABEL_915;
          }
LABEL_848:
          CFRelease(Mutable);
          return 0;
        }
        goto LABEL_463;
      }
      if (a3 != 32)
      {
        if (a3 == 843264104)
        {
          uint64_t v176 = a8[1];
          unint64_t v177 = v176 - 1 + 4 * a1;
          unint64_t v178 = v177 / v176 * v176;
          unint64_t v179 = v177 & -v176;
          if ((v176 & (v176 - 1)) != 0) {
            unint64_t v180 = v178;
          }
          else {
            unint64_t v180 = v179;
          }
          CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFD8], 4);
          CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFE0], v180);
          uint64_t v181 = a8[2];
          uint64_t v182 = a8[3];
          unint64_t v183 = v181 - 1 + v14;
          unint64_t v184 = v183 / v181 * v181;
          unint64_t v185 = v183 & -v181;
          if ((v181 & (v181 - 1)) != 0) {
            unint64_t v186 = v184;
          }
          else {
            unint64_t v186 = v185;
          }
          unint64_t v187 = v182 - 1 + v186 * v180;
          unint64_t v188 = v187 / v182 * v182;
          unint64_t v189 = v187 & -v182;
          if ((v182 & (v182 - 1)) != 0) {
            unint64_t v189 = v188;
          }
          unint64_t v654 = v189;
          int v190 = (a6 >> 2) & 1;
          LODWORD(a3) = 843264104;
          goto LABEL_915;
        }
        goto LABEL_848;
      }
      goto LABEL_503;
    }
    if ((int)a3 <= 875836467)
    {
      if (a3 != 875704934 && a3 != 875704950) {
        goto LABEL_848;
      }
      uint64_t v253 = a8[1];
      unint64_t v254 = v253 - 1 + a1;
      if ((v253 & (v253 - 1)) != 0) {
        uint64_t v255 = v254 / v253 * v253;
      }
      else {
        uint64_t v255 = v254 & -v253;
      }
      int8x8_t v459 = (int8x8_t)a8[2];
      uint8x8_t v460 = (uint8x8_t)vcnt_s8(v459);
      v460.i16[0] = vaddlv_u8(v460);
      unint64_t v461 = v460.u32[0];
      unint64_t v462 = v14 + *(void *)&v459 - 1;
      unint64_t v463 = v462 / *(void *)&v459;
      if (v460.u32[0] > 1uLL) {
        unint64_t v464 = v463 * *(void *)&v459;
      }
      else {
        unint64_t v464 = v462 & -*(void *)&v459;
      }
      int8x8_t v495 = (int8x8_t)a8[3];
      uint8x8_t v496 = (uint8x8_t)vcnt_s8(v495);
      v496.i16[0] = vaddlv_u8(v496);
      unint64_t v497 = *(void *)&v495 - 1 + v464 * v255;
      if (v496.u32[0] > 1uLL) {
        uint64_t v498 = v497 / *(void *)&v495 * *(void *)&v495;
      }
      else {
        uint64_t v498 = v497 & -*(void *)&v495;
      }
      uint64_t v653 = v498;
      if (v461 > 1) {
        unint64_t v519 = v463 * *(void *)&v459;
      }
      else {
        unint64_t v519 = v462 & -*(void *)&v459;
      }
      unint64_t v531 = *(void *)&v495 - 1 + v519 * v255;
      if (v496.u32[0] > 1uLL) {
        uint64_t v532 = v531 / *(void *)&v495 * *(void *)&v495;
      }
      else {
        uint64_t v532 = v531 & -*(void *)&v495;
      }
      uint64_t v652 = v532;
      values = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v14, v255, 0, v498, 1, 1);
      uint64_t v549 = v652;
      uint64_t v548 = v653;
      int32x4_t v550 = (CA::SurfaceUtil *)((a1 + 1) >> 1);
      uint64_t v551 = v14;
      uint64_t v552 = v255;
LABEL_823:
      uint64_t v553 = 1;
      uint64_t v554 = 2;
LABEL_911:
      CFDictionaryRef htpc_plane_dict = CA::SurfaceUtil::create_plane_dict(v550, v551, v552, v548, v549, v553, v554);
LABEL_912:
      CFArrayRef v624 = CFArrayCreate(0, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F238], v624);
      CFRelease(v624);
      CFRelease(htpc_plane_dict);
      CFRelease(values);
      unint64_t v233 = v652 + v653;
      goto LABEL_913;
    }
    if (a3 != 875836468)
    {
      if (a3 != 875836518 && a3 != 875836534) {
        goto LABEL_848;
      }
      uint64_t v163 = a8[1];
      unint64_t v164 = v163 - 1 + a1;
      if ((v163 & (v163 - 1)) != 0) {
        uint64_t v165 = v164 / v163 * v163;
      }
      else {
        uint64_t v165 = v164 & -v163;
      }
      int8x8_t v422 = (int8x8_t)a8[2];
      uint8x8_t v423 = (uint8x8_t)vcnt_s8(v422);
      v423.i16[0] = vaddlv_u8(v423);
      unint64_t v424 = v423.u32[0];
      unint64_t v425 = v14 + *(void *)&v422 - 1;
      unint64_t v426 = v425 / *(void *)&v422;
      if (v423.u32[0] > 1uLL) {
        unint64_t v427 = v426 * *(void *)&v422;
      }
      else {
        unint64_t v427 = v425 & -*(void *)&v422;
      }
      int8x8_t v491 = (int8x8_t)a8[3];
      uint8x8_t v492 = (uint8x8_t)vcnt_s8(v491);
      v492.i16[0] = vaddlv_u8(v492);
      unint64_t v493 = *(void *)&v491 - 1 + v427 * v165;
      if (v492.u32[0] > 1uLL) {
        uint64_t v494 = v493 / *(void *)&v491 * *(void *)&v491;
      }
      else {
        uint64_t v494 = v493 & -*(void *)&v491;
      }
      uint64_t v653 = v494;
      uint64_t v517 = 2 * v165;
      if (v424 > 1) {
        unint64_t v518 = v426 * *(void *)&v422;
      }
      else {
        unint64_t v518 = v425 & -*(void *)&v422;
      }
      unint64_t v529 = *(void *)&v491 - 1 + v518 * v517;
      if (v492.u32[0] > 1uLL) {
        uint64_t v530 = v529 / *(void *)&v491 * *(void *)&v491;
      }
      else {
        uint64_t v530 = v529 & -*(void *)&v491;
      }
      uint64_t v652 = v530;
      values = CA::SurfaceUtil::create_plane_dict((CA::SurfaceUtil *)a1, v14, v165, 0, v494, 1, 1);
      uint64_t v549 = v652;
      uint64_t v548 = v653;
      int32x4_t v550 = (CA::SurfaceUtil *)a1;
      uint64_t v551 = v14;
      uint64_t v552 = v517;
      goto LABEL_823;
    }
    goto LABEL_610;
  }
  if ((int)a3 <= 1278555444)
  {
    if ((int)a3 > 1093677111)
    {
      if (a3 == 1093677112)
      {
LABEL_407:
        uint64_t v152 = a8[1];
        unint64_t v153 = v152 - 1 + a1;
        unint64_t v154 = v153 / v152 * v152;
        unint64_t v155 = v153 & -v152;
        uint64_t v156 = a8;
        if ((v152 & (v152 - 1)) != 0) {
          unint64_t v157 = v154;
        }
        else {
          unint64_t v157 = v155;
        }
        int v158 = (const void *)*MEMORY[0x1E4F2EFD8];
        unint64_t v159 = Mutable;
        int v160 = 1;
        goto LABEL_654;
      }
      if (a3 != 1111970369)
      {
        if (a3 != 1278226488) {
          goto LABEL_848;
        }
        goto LABEL_407;
      }
LABEL_503:
      uint64_t v219 = a8[1];
      unint64_t v220 = v219 - 1 + 4 * a1;
      unint64_t v221 = v220 / v219 * v219;
      unint64_t v222 = v220 & -v219;
      if ((v219 & (v219 - 1)) != 0) {
        unint64_t v223 = v221;
      }
      else {
        unint64_t v223 = v222;
      }
LABEL_506:
      unint64_t v224 = (v223 + 255) & 0xFFFFFFFFFFFFFF00;
      CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFD8], 4);
      CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFE0], v224);
      uint64_t v225 = a8[2];
      uint64_t v226 = a8[3];
      unint64_t v227 = v225 - 1 + v14;
      unint64_t v228 = v227 / v225 * v225;
      unint64_t v229 = v227 & -v225;
      if ((v225 & (v225 - 1)) != 0) {
        unint64_t v230 = v228;
      }
      else {
        unint64_t v230 = v229;
      }
      unint64_t v231 = v226 - 1 + v230 * v224;
      unint64_t v232 = v231 / v226 * v226;
      unint64_t v233 = v231 & -v226;
      if ((v226 & (v226 - 1)) != 0) {
        unint64_t v233 = v232;
      }
      goto LABEL_913;
    }
    if (a3 != 1027423537 && a3 != 1027423539) {
      goto LABEL_848;
    }
    if (!v641)
    {
      uint64_t v559 = a8[1];
      unint64_t v560 = v559 - 1 + 4 * a1;
      unint64_t v561 = v560 / v559 * v559;
      unint64_t v223 = v560 & -v559;
      if ((v559 & (v559 - 1)) != 0) {
        unint64_t v223 = v561;
      }
      goto LABEL_506;
    }
    if (x_log_hook_p())
    {
LABEL_649:
      x_log_();
      goto LABEL_848;
    }
    uint64_t v251 = x_log_category_utilities;
    if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_848;
    }
    *(_WORD *)long long buf = 0;
    float v252 = "YUV passthrough formats unsupported on this platform.";
LABEL_847:
    _os_log_impl(&dword_184668000, v251, OS_LOG_TYPE_DEFAULT, v252, buf, 2u);
    goto LABEL_848;
  }
  if ((int)a3 <= 1279340599)
  {
    if (a3 != 1278555445 && a3 != 1278555701) {
      goto LABEL_848;
    }
LABEL_610:
    uint64_t v305 = a8[1];
    unint64_t v306 = v305 - 1 + 2 * a1;
    unint64_t v307 = v306 / v305 * v305;
    unint64_t v308 = v306 & -v305;
    uint64_t v156 = a8;
    if ((v305 & (v305 - 1)) != 0) {
      unint64_t v157 = v307;
    }
    else {
      unint64_t v157 = v308;
    }
    int v158 = (const void *)*MEMORY[0x1E4F2EFD8];
    unint64_t v159 = Mutable;
    int v160 = 2;
LABEL_654:
    CA_CFDictionarySetInt(v159, v158, v160);
    CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFE0], v157);
    uint64_t v352 = v156[2];
    unint64_t v353 = v352 - 1 + v14;
    if ((v352 & (v352 - 1)) != 0) {
      unint64_t v354 = v353 / v352 * v352;
    }
    else {
      unint64_t v354 = v353 & -v352;
    }
    uint64_t v355 = v648;
    int v357 = v646;
    int v356 = v647;
    uint64_t v358 = a8[3];
    unint64_t v359 = v358 - 1 + v354 * v157;
    if ((v358 & (v358 - 1)) != 0) {
      unint64_t v360 = v359 / v358 * v358;
    }
    else {
      unint64_t v360 = v359 & -v358;
    }
    unsigned int v361 = a6;
    goto LABEL_661;
  }
  if (a3 != 1279340600)
  {
    if (a3 == 1378955371) {
      goto LABEL_503;
    }
    int v150 = 1380401729;
LABEL_449:
    if (a3 != v150) {
      goto LABEL_848;
    }
    goto LABEL_503;
  }
  uint64_t v428 = a8[1];
  unint64_t v429 = v428 - 1 + 2 * a1;
  unint64_t v430 = v429 / v428 * v428;
  unint64_t v431 = v429 & -v428;
  if ((v428 & (v428 - 1)) != 0) {
    unint64_t v432 = v430;
  }
  else {
    unint64_t v432 = v431;
  }
  CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFD8], 2);
  CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFE0], v432);
  uint64_t v433 = a8[2];
  unint64_t v434 = v433 - 1 + v14;
  if ((v433 & (v433 - 1)) != 0) {
    unint64_t v435 = v434 / v433 * v433;
  }
  else {
    unint64_t v435 = v434 & -v433;
  }
  uint64_t v355 = v648;
  int v357 = v646;
  int v356 = v647;
  uint64_t v575 = a8[3];
  unint64_t v576 = v575 - 1 + v435 * v432;
  if ((v575 & (v575 - 1)) != 0) {
    unint64_t v577 = v576 / v575 * v575;
  }
  else {
    unint64_t v577 = v576 & -v575;
  }
  unint64_t v654 = v577;
  int v190 = (a6 >> 2) & 1;
  LODWORD(a3) = 1279340600;
LABEL_916:
  CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2F2C0], a1);
  CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2F0E8], v14);
  CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2F150], a3);
  CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFE8], v357);
  CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2EFB8], v654);
  CA_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E4F2F100], v356);
  if (v355) {
    CA_CFDictionarySetLongLong(Mutable, (const void *)*MEMORY[0x1E4F2F280], v355);
  }
  uint64_t v625 = (const void *)*MEMORY[0x1E4F1CFD0];
  if ((a6 & 0x10) != 0) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F270], (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  if (v190) {
    v626 = v625;
  }
  else {
    v626 = (const void *)*MEMORY[0x1E4F1CFC8];
  }
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F148], v626);
  if ((a6 & 2) != 0) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F120], @"PurpleGfxMem");
  }
  if ((a6 & 0x40) != 0) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F2A0], v625);
  }
  long long v627 = IOSurfaceCreate(Mutable);
  CFRelease(Mutable);
  if (!v627)
  {
    if (x_log_hook_p())
    {
      if ((a3 & 0x80000000) != 0) {
        __maskrune(BYTE3(a3), 0x40000uLL);
      }
      if (BYTE2(a3) > 0x7Fu) {
        __maskrune(BYTE2(a3), 0x40000uLL);
      }
      if (BYTE1(a3) > 0x7Fu) {
        __maskrune(BYTE1(a3), 0x40000uLL);
      }
      if (a3 > 0x7Fu) {
        __maskrune(a3, 0x40000uLL);
      }
      x_log_();
    }
    else
    {
      v628 = x_log_category_utilities;
      if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
      {
        unsigned int v629 = BYTE3(a3);
        uint64_t v630 = MEMORY[0x1E4F14390];
        if ((a3 & 0x80000000) != 0) {
          int v631 = __maskrune(v629, 0x40000uLL);
        }
        else {
          int v631 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v629 + 60) & 0x40000;
        }
        if (v631) {
          int v632 = (int)a3 >> 24;
        }
        else {
          int v632 = 32;
        }
        if (BYTE2(a3) <= 0x7Fu) {
          int v633 = *(_DWORD *)(v630 + 4 * BYTE2(a3) + 60) & 0x40000;
        }
        else {
          int v633 = __maskrune(BYTE2(a3), 0x40000uLL);
        }
        if (v633) {
          int v634 = SBYTE2(a3);
        }
        else {
          int v634 = 32;
        }
        if (BYTE1(a3) <= 0x7Fu) {
          int v635 = *(_DWORD *)(v630 + 4 * BYTE1(a3) + 60) & 0x40000;
        }
        else {
          int v635 = __maskrune(BYTE1(a3), 0x40000uLL);
        }
        if (v635) {
          int v636 = SBYTE1(a3);
        }
        else {
          int v636 = 32;
        }
        if (a3 <= 0x7Fu) {
          int v637 = *(_DWORD *)(v630 + 4 * a3 + 60) & 0x40000;
        }
        else {
          int v637 = __maskrune(a3, 0x40000uLL);
        }
        int v638 = (char)a3;
        *(_DWORD *)long long buf = 67110400;
        if (!v637) {
          int v638 = 32;
        }
        *(_DWORD *)&uint8_t buf[4] = a1;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v14;
        *(_WORD *)&buf[14] = 1024;
        LODWORD(v656) = v632;
        WORD2(v656) = 1024;
        *(_DWORD *)((char *)&v656 + 6) = v634;
        WORD5(v656) = 1024;
        HIDWORD(v656) = v636;
        LOWORD(v657) = 1024;
        *(_DWORD *)((char *)&v657 + 2) = v638;
        _os_log_impl(&dword_184668000, v628, OS_LOG_TYPE_ERROR, "CAIOSurfaceCreate: failed to allocate IOSurface (size: %u x %u, format: %c%c%c%c)\n", buf, 0x26u);
      }
    }
    return 0;
  }
  if (a9) {
    IOSurfaceSetValue(v627, (CFStringRef)*MEMORY[0x1E4F2F128], a9);
  }
  int v662 = 0;
  long long v660 = 0u;
  long long v661 = 0u;
  long long v658 = 0u;
  long long v659 = 0u;
  long long v656 = 0u;
  long long v657 = 0u;
  *(_OWORD *)long long buf = 0u;
  *(_WORD *)((char *)&v658 + 1CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)this, 1) = 3329;
  IOSurfaceSetBulkAttachments2();
  return v627;
}

CFDictionaryRef CA::SurfaceUtil::create_universal_plane_dict(unsigned int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  keys[20] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v42 = a4;
  uint64_t v43 = a3;
  uint64_t v7 = *a6;
  uint64_t valuePtr = 5;
  uint64_t v41 = v7;
  if (a1) {
    uint64_t v8 = 4;
  }
  else {
    uint64_t v8 = 3;
  }
  uint64_t v38 = a1;
  uint64_t v39 = v8;
  uint64_t v9 = -16;
  if (a2) {
    uint64_t v9 = -32;
  }
  uint64_t v10 = 16;
  uint64_t v11 = 32;
  if (a2) {
    uint64_t v10 = 32;
  }
  char v12 = 8;
  if (!a2) {
    uint64_t v11 = 8;
  }
  uint64_t v36 = v11;
  uint64_t v37 = v10;
  char v13 = 4;
  if (a2)
  {
    char v13 = 5;
    char v12 = 10;
    char v14 = 5;
  }
  else
  {
    char v14 = 3;
  }
  int64_t v34 = ((v10 - 1 + a4) & (unint64_t)v9) >> v13;
  int64_t v35 = ((v10 - 1 + a3) & (unint64_t)v9) >> v13;
  uint64_t v33 = ((unint64_t)(a5 << v12) >> 3) & 0x1FFFFFE0;
  int64_t v32 = v35 * v33;
  uint64_t v15 = v34 * v35 * v33 + 127;
  char v16 = vcvtps_s32_f32(log2f((float)v35));
  unint64_t v31 = (((((uint64_t)(1 << v16 << vcvtps_s32_f32(log2f((float)v34))) << v14) + 127) & 0xFFFFFFFFFFFFFF80) + v15) & 0xFFFFFFFFFFFFFF80;
  *a6 = v31 + v7;
  uint64_t v30 = (v15 & 0xFFFFFFFFFFFFFF80) + v7;
  float64x2_t v17 = (void *)*MEMORY[0x1E4F2F1D8];
  keys[0] = *(void **)MEMORY[0x1E4F2EFB0];
  keys[1] = v17;
  double v18 = (void *)*MEMORY[0x1E4F2F248];
  keys[2] = *(void **)MEMORY[0x1E4F2F240];
  keys[3] = v18;
  unsigned int v19 = (void *)*MEMORY[0x1E4F2F170];
  keys[4] = *(void **)MEMORY[0x1E4F2F168];
  keys[5] = v19;
  int v20 = (void *)*MEMORY[0x1E4F2F178];
  keys[6] = *(void **)MEMORY[0x1E4F2F190];
  keys[7] = v20;
  unsigned int v21 = (void *)*MEMORY[0x1E4F2F1B0];
  keys[8] = *(void **)MEMORY[0x1E4F2F188];
  keys[9] = v21;
  int v22 = (void *)*MEMORY[0x1E4F2F1C0];
  keys[10] = *(void **)MEMORY[0x1E4F2F1B8];
  keys[11] = v22;
  unsigned __int16 v23 = (void *)*MEMORY[0x1E4F2F1F0];
  keys[12] = *(void **)MEMORY[0x1E4F2F1C8];
  keys[13] = v23;
  int v24 = (void *)*MEMORY[0x1E4F2F258];
  keys[14] = *(void **)MEMORY[0x1E4F2F1E8];
  keys[15] = v24;
  int v25 = (void *)*MEMORY[0x1E4F2F260];
  keys[16] = *(void **)MEMORY[0x1E4F2F220];
  keys[17] = v25;
  int v26 = (void *)*MEMORY[0x1E4F2F1D0];
  keys[18] = *(void **)MEMORY[0x1E4F2F228];
  keys[19] = v26;
  values[0] = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
  values[1] = CFNumberCreate(0, kCFNumberCFIndexType, &v39);
  values[2] = CFNumberCreate(0, kCFNumberCFIndexType, &v41);
  values[3] = CFNumberCreate(0, kCFNumberCFIndexType, &v31);
  values[4] = CFNumberCreate(0, kCFNumberCFIndexType, &v36);
  values[5] = CFNumberCreate(0, kCFNumberCFIndexType, &v33);
  values[6] = CFNumberCreate(0, kCFNumberCFIndexType, &v33);
  values[7] = CFNumberCreate(0, kCFNumberCFIndexType, &v32);
  values[8] = CFNumberCreate(0, kCFNumberCFIndexType, &v32);
  values[9] = CFNumberCreate(0, kCFNumberCFIndexType, &v41);
  values[10] = CFNumberCreate(0, kCFNumberCFIndexType, &v30);
  values[11] = CFNumberCreate(0, kCFNumberCFIndexType, &v37);
  values[12] = CFNumberCreate(0, kCFNumberCFIndexType, &v37);
  values[13] = CFNumberCreate(0, kCFNumberCFIndexType, &v37);
  values[14] = CFNumberCreate(0, kCFNumberCFIndexType, &v37);
  values[15] = CFNumberCreate(0, kCFNumberCFIndexType, &v43);
  values[16] = CFNumberCreate(0, kCFNumberCFIndexType, &v42);
  values[17] = CFNumberCreate(0, kCFNumberCFIndexType, &v35);
  values[18] = CFNumberCreate(0, kCFNumberCFIndexType, &v34);
  values[19] = CFNumberCreate(0, kCFNumberCFIndexType, &v38);
  CFDictionaryRef v27 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 20, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  for (uint64_t i = 0; i != 20; ++i)
    CFRelease(values[i]);
  return v27;
}

uint64_t CA::CG::ContextDelegate::operation_(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  uint64_t Info = (const double *)CGContextDelegateGetInfo();
  if (CFEqual(a4, @"kCGContextFlush"))
  {
    uint64_t v8 = (*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
    if (v8)
    {
      int v9 = 3;
LABEL_7:
      CA::CG::Queue::flush(v8, v9, 1);
    }
  }
  else if (CFEqual(a4, @"kCGContextSynchronize"))
  {
    uint64_t v8 = (*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
    if (v8)
    {
      int v9 = 2;
      goto LABEL_7;
    }
  }
  else
  {
    if (!CFEqual(a4, @"kCGContextWait"))
    {
      if (CFEqual(a4, @"kCGContextClear"))
      {
        uint64_t v13 = (*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
        if (!v13) {
          return 0;
        }
        char v14 = (CA::CG::DrawOp **)v13;
        Copdouble y = CGGStateCreateCopy();
        if (!Copy) {
          return 0;
        }
      }
      else
      {
        if (!CFEqual(a4, @"kCGContextErase")) {
          return 0;
        }
        uint64_t v16 = (*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
        if (!v16) {
          return 0;
        }
        char v14 = (CA::CG::DrawOp **)v16;
        Copdouble y = CGGStateCreateCopy();
        if (!Copy) {
          return 0;
        }
      }
      uint64_t v17 = Copy;
      CGGStateSetCompositeOperation();
      double v18 = CA::CG::ContextDelegate::fill_rects(Info, v14, a2, v17, 0, MEMORY[0x1E4F1DB10], 1, 1, 1);
      CA::CG::ContextDelegate::submit((uint64_t)Info, (uint64_t)v14, (uint64_t)v18, a2, a3);
      CGGStateRelease();
      return 0;
    }
    uint64_t v11 = (CA::CG::Queue *)(*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
    if (v11)
    {
      char v12 = v11;
      CA::CG::Queue::flush_queue(v11);
      if (CA::CG::Queue::queue(void)::once[0] != -1) {
        dispatch_once_f(CA::CG::Queue::queue(void)::once, 0, (dispatch_function_t)CA::CG::Queue::create_queue);
      }
      dispatch_sync_f((dispatch_queue_t)CA::CG::Queue::_queue, v12, (dispatch_function_t)CA::CG::Queue::finish_callback);
    }
  }
  return 0;
}

uint64_t CA::CG::ContextDelegate::draw_rects_(uint64_t a1, uint64_t a2, uint64_t a3, int a4, long long *a5, unint64_t a6)
{
  if (a6)
  {
    uint64_t Info = (const double *)CGContextDelegateGetInfo();
    uint64_t v12 = (*(uint64_t (**)(const double *))(*(void *)Info + 16))(Info);
    if (v12)
    {
      uint64_t v13 = (CA::CG::Queue *)v12;
      if (a4 == 2
        || (FillColor = (CGColor *)CGGStateGetFillColor(),
            uint64_t v15 = CA::CG::ContextDelegate::fill_rects(Info, (CA::CG::DrawOp **)v13, a2, a3, FillColor, a5, a6, 0, 1),
            CA::CG::ContextDelegate::submit((uint64_t)Info, (uint64_t)v13, (uint64_t)v15, a2, a3),
            a4 >= 2))
      {
        StrokeColor = (CGColor *)CGGStateGetStrokeColor();
        uint64_t v17 = CA::CG::ContextDelegate::stroke_rects(Info, v13, a2, a3, StrokeColor, (uint64_t)a5, a6, 0);
        CA::CG::ContextDelegate::submit((uint64_t)Info, (uint64_t)v13, (uint64_t)v17, a2, a3);
      }
    }
  }
  return 0;
}

uint64_t CA::CG::AccelContextDelegate<CA::CG::IOSurfaceDrawable>::queue(uint64_t a1)
{
  CFDictionaryRef v1 = *(void **)(a1 + 336);
  if (!v1) {
    return 0;
  }
  uint64_t result = v1[9];
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void *))(*v1 + 72))(v1);
    v1[9] = result;
  }
  return result;
}

void CA::CG::ContextDelegate::submit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a3) {
    return;
  }
  *(_DWORD *)(a2 + 24) = CGContextDelegateGetOwnerIdentity();
  updated = CA::CG::ContextDelegate::update_style(a1);
  if (updated) {
    CA::CG::ContextDelegate::resolve_style(a1, a3, a4, a5, updated);
  }
  uint64_t v11 = (void *)(a2 + 32);
  uint64_t v12 = *(void **)(a2 + 32);
  if (CA::CG::Queue::_disable_async)
  {
    *uint64_t v11 = 0;
    *(void *)(a2 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
    ++*(_DWORD *)(a2 + 48);
    dispatch_semaphore_wait((dispatch_semaphore_t)CA::CG::Queue::_queue_sema, 0xFFFFFFFFFFFFFFFFLL);
    if (BYTE9(xmmword_1EB2ACC10)) {
      kdebug_trace();
    }
    if (CA::CG::Queue::_disable_async)
    {
      if (CA::CG::Queue::queue(void)::once[0] == -1) {
        goto LABEL_21;
      }
      goto LABEL_30;
    }
    uint64_t v13 = *(NSObject **)(a2 + 8);
    if (!v13)
    {
      uint64_t v13 = dispatch_group_create();
      *(void *)(a2 + 8) = v13;
    }
    if (CA::CG::Queue::queue(void)::once[0] == -1) {
      goto LABEL_27;
    }
LABEL_31:
    dispatch_once_f(CA::CG::Queue::queue(void)::once, 0, (dispatch_function_t)CA::CG::Queue::create_queue);
    goto LABEL_27;
  }
  if (v12[4])
  {
    *(void *)(a2 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = a3;
    return;
  }
  *uint64_t v11 = 0;
  *(void *)(a2 + 4CA::Render::add_observer(0x31u, 0, (uint64_t)memory_warning, 0, 0) = 0;
  ++*(_DWORD *)(a2 + 48);
  dispatch_semaphore_wait((dispatch_semaphore_t)CA::CG::Queue::_queue_sema, 0xFFFFFFFFFFFFFFFFLL);
  if (BYTE9(xmmword_1EB2ACC10)) {
    kdebug_trace();
  }
  if (CA::CG::Queue::_disable_async)
  {
    if (CA::CG::Queue::queue(void)::once[0] == -1)
    {
LABEL_21:
      char v14 = CA::CG::Queue::_queue;
      dispatch_sync_f(v14, v12, (dispatch_function_t)CA::CG::Queue::render_callback);
      return;
    }
LABEL_30:
    dispatch_once_f(CA::CG::Queue::queue(void)::once, 0, (dispatch_function_t)CA::CG::Queue::create_queue);
    goto LABEL_21;
  }
  uint64_t v13 = *(NSObject **)(a2 + 8);
  if (!v13)
  {
    uint64_t v13 = dispatch_group_create();
    *(void *)(a2 + 8) = v13;
  }
  if (CA::CG::Queue::queue(void)::once[0] != -1) {
    goto LABEL_31;
  }
LABEL_27:
  uint64_t v15 = CA::CG::Queue::_queue;

  dispatch_group_async_f(v13, v15, v12, (dispatch_function_t)CA::CG::Queue::render_callback);
}